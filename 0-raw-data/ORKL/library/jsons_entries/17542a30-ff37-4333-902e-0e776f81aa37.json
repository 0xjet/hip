{
    "id": "17542a30-ff37-4333-902e-0e776f81aa37",
    "created_at": "2023-01-12T15:04:37.163371Z",
    "updated_at": "2025-03-27T02:16:25.475632Z",
    "deleted_at": null,
    "sha1_hash": "2159e16347df19dbda8cfdb2dc369f3dab7e1496",
    "title": "2022-08-04 - Technical Analysis of Bumblebee Malware Loader",
    "authors": "",
    "file_creation_date": "2022-11-28T18:53:59Z",
    "file_modification_date": "2022-11-28T18:53:59Z",
    "file_size": 3691789,
    "plain_text": "# Technical Analysis of Bumblebee Malware Loader\n\n**[cloudsek.com/technical-analysis-of-bumblebee-malware-loader/](https://cloudsek.com/technical-analysis-of-bumblebee-malware-loader/)**\n\nAnandeshwar Unnikrishnan August 4, 2022\n\nMalware loaders are essentially remote access trojans (RATs) that establish communication\nbetween the attacker and the compromised system. Loaders typically represent the first\nstage of a compromise. Their primary goal is to download and execute additional payloads,\nfrom the attacker-controlled server, on the compromised system without detection.\n\n\n-----\n\nResearchers at ProofPoint have discovered a new malware loader called Bumblebee. The\nmalware loader is named after a unique user agent string used for C2 communication. It has\nbeen observed that adversaries have started using Bumblebee to deploy malware such as\nCobaltStrike beacons and Meterpreter shells. Threat group TA578 has also been using\nBumblebee the loader in their campaigns.\n\nThis article explores and decodes Bumblebee malware loader’s:\n\nTechnical features\nLogic flow\nExploitation process\nNetwork maintenance\nUnique features\n\n## Campaign Delivery\n\nAdversaries push ISO files through compromised email (reply) chains, known as thread\nhijacked emails, to deploy the Bumblebee loader. ISO files contain a byte-to-byte copy of\nlow-level data stored on a disk. The malicious ISO files are delivered through Google Cloud\nlinks or password protected zip folders.\n\nISO file retrieved from Google Cloud (“storage.googleapis.com”)\n\nISO\n\nfile retrieved from password protected zip files\nThe ISO files contain a hidden DLL with random names and an LNK file. DLL (Dynamic Link\nLibrary) is a library that contains codes and data which can be used by more than one\nprogram at a time. LNK is a filename extension in Microsoft Windows for shortcuts to local\nfiles.\n\nThe LNK file often contains a direct link to an executable file or metadata about the\nexecutable file, without the need to trace the program’s full path. LNK files are an attractive\nalternative to opening a file, and thus an effective way for threat actors to create script-based\n\n\n-----\n\nattacks. The target location for the LNK files is set to run rundll32.exe, which will call an\nexported function in the associated DLL. If the “show hidden items” option is not enabled on\nthe victim’s system, DLLs may not be visible to the user.\n\n## Bumblebee Loader Analysis\n\nThe analyzed sample\n```\n(f98898df74fb2b2fad3a2ea2907086397b36ae496ef3f4454bf6b7125fc103b8) is a DLL\n\n```\nfile with exported functions.\n\n_Exported functions in the sample DLL file_\n\nBoth the exported functions, IternalJob and SetPath, execute the function sub_180004AA0.\n\n_InternalJob executing the function sub_180004AA0 SetPath executing the function_\n_sub_180004AA0_\n\n### Entropy of the DLL\n\nThe entropy of a file measures the randomness of the data in the file. Entropy can be used to\ndetermine whether there is hidden data or suspicious scripts in the file. The scale of entropy\nis from 0 (not random) to 8 (totally random). High entropy values indicate that there is\nencrypted data stored in the file, while lower values indicate the decryption and storage of\npayload in different sections during runtime.\n\n\n-----\n\nEntropy of the Malware Sample\nThe peak is spread across the data segments of the DLL file. It is highly possible that this\npeak was caused by the presence of packed data in the data segments of the sample DLL.\nThis indicates that the malware, at some point in runtime, will fetch the data from the data\nsegment and unpack it for later use.\n\n### Unpacking and Deploying Payload (Function sub_180004AA0)\n\nThe exported function sub_180004AA0 is a critical component in unpacking and deploying\nthe main payload on the target system.\n\nExported Function sub_180004AA0\nThe function sub_180003490 serves as the unpacker for the main payload.\n\n\n-----\n\nFunction sub_180003490\n\n**Function sub_180003490**\n\nFunction sub_180003490 contains 2 functions of interest:\n\n**_sub_1800021D0: This function routine is responsible for allocating heap memory._**\n\nFunction sub_1800021D0\n**_sub_1800029BC: This function writes the embedded data, in the data segment of the DLL_**\nsample, into the newly allocated heap memory. The packed payload is fetched from the data\nsegment and written into allocated heap memory. The code segment highlighted in the\nimage below is responsible for transferring the data.\n\n\n-----\n\nFunction sub_1800029BC\n\n### Function sub_1800029BC\n\nAssembly code representation of function sub_1800029BC\n\nThe assembly code highlighted yellow transfers the embedded data (packed payload)\nfrom the data segment of DLL to an intermediate CL register.\nThe assembly code highlighted red transfers the data from CL to the allocated heap.\nDuring runtime, the heap memory continues to get filled with the packed payload\nembedded within the DLL samples.\n\n\n-----\n\nHeap memory during run time\n\n### Function sub_180002FF4\n\nAfter dumping the packed payload in the allocated memory, the control goes back to\n_sub_180004AA0 and function sub_180002FF4 is executed._\n\n\n-----\n\n_Function sub_180002FF4_\n\nFunction sub_180002FF4 performs the following operations:\n\nAllocates new heap memory.\nTransfers previously dumped packed payload into newly allocated memory.\nDeallocates previously allocated memory.\n\nAfter the control returns to sub_180004AA0 function sub_180004180 is executed.\n\n\n-----\n\n_Function sub_180004180_\n\n### Function sub_180004180\n\n_Three functions encapsulated in Function sub_180004180_\n\nFunction sub_180004180 has 3 functions:\n\n**_sub_180001670: This function is responsible for allocating multiple heap memories to_**\nthe malware. The malware later dumps the unpacked MZ file into one of the allocated\nmemories.\n**_sub_180003CE4: This function is responsible for unpacking previously dumped_**\npacked payload in the process heap and dumps it into one of the memories allocated\nby sub_180001670.\n**_sub_180001A84: This function is responsible for deallocating memory._**\n\n\n-----\n\nUnpacked MZ artifact in the memory\n\n## Hook Implementation\n\nHooking refers to a range of techniques used to modify the behavior of an operating system,\nsoftware, or software component, by intercepting the function calls, events, or\ncommunication between software components. The code which handles such intercepted\nfunction calls, events, or communication is called a hook.\n\nRight after the Bumblebee loader unpacks the main payload in the memory, it hooks a few\ninteresting functions exported by ntdll.dll (a file containing NT kernel functions, susceptible to\ncyberattacks) through an in-line hooking technique. The in-line hooks play a significant role\nin the execution of the final payload. The trigger mechanism, for the deployment of the\npayload, shows the creativity of the malware developer. Function sub_180001000 is\nresponsible for implementing the in-line hooks.\n\n\n-----\n\nFunction sub_180001000\nFunction sub_180001000 initially saves the addresses of 3 detour functions used for\nhooking. The detour functions are responsible for hijacking control flow in hooked Windows\nfunctions. After storing the addresses, sub_1800025EC is executed to resolve the addresses\nof the target API (Application Programming Interface) functions for hooking.\n\n_Detour functions in sub_180001000 function_\n\n_sub_1800025EC loads ntdll.dll in the address space of the loader process using function_\n_LoadLibraryA. Following the loading of the ntdll, function GetProcAddress is used to resolve_\nthe addresses of functions:\n\n_NtOpenFile_\n_NtCreateSection_\n_NtMapViewOfSection_\n\n\n-----\n\n_LoadLibraryA and GetProcAddress functions_\n\nAfter obtaining the addresses to memory pages of the detour functions for hooking, the\nloader uses function VirtualProtect to change the memory permissions of the target pages.\nAfter changing the permissions, the loader writes the in-line hooks in sub_180002978. Then\n_VirtualProtect is called again to restore the page permissions._\n\n_VirtualProtect and sub_180002978 functions_\n\nThe data passed to VirtualProtect at runtime is shown in the image below. The call to\n_VirtualProtect changes the ntdll.NtOpenFile page permission to 0x40_\n(PAGE_EXECUTE_READWRITE).\n\n\n-----\n\n_Data passed/call to VirtualProtect function_\n\nAfter changing the page permissions of ntdll.NtOpenFile, the loader modifies the initial\nsequence of bytes in the NtOpenFile API by executing function sub_180002978.\n\n_sub_180002978 function modifying the NtOpenFile API_\n\nIn-line hooking involves the following steps:\n\n_ntdll.NtOpenFile before (hooking) execution of sub_180002978 function_\n\nAfter sub_180002978 is executed, a call to NtOpenFile makes the malware code jump\nto location 1800023D4 (detour). This is how malicious in-line hooks change the\nexecution flow of APIs.\n\n\n-----\n\n_Call to NtOpenFile making the malware jump to 1800023D4_\n\nAfter writing the hook, VirtualProtect is used again to restore the page permission of\n_ntdll.NtOpenFile to 0x20 (PAGE_EXECUTE_READ)._\n\n_VirtualProtect function used to restore page permission of ntdll.NtOpenFile_\n\nThe process of changing memory permission and writing in-line hooks is repeated in a\ndo-while loop, for the rest of the target functions, NtCreateSection and\n_NtMapViewOfSection._\n\nDo-while loop repeating the permission and hooks process for other target functions\n\n### Summary of Hooked Functions\n\nAfter successful hooking, whenever target functions are called in the address space of the\nloader process, the control flow is transferred to the in-line the respective hook addresses:\n\n**Target Function** **In-line Hook (Detours)**\n\n**_ntdll.NtOpenFile_** **1800023D4**\n\n**_ntdll.NtCreateSection_** **1800041EC**\n\n**_ntdll.NtMapViewOfSection_** **180001D4C**\n\n## Loading gdiplus.dll is Unique to Bumblebee\n\n\n-----\n\nThe final function executed by the loader is sub_1800013A0. The malware uses the function\n_LoadLibraryW to load the DLL module. It then uses the function GetProcAddress to obtain_\nthe address of a specific function exported by the library loaded.\n\nThis plays a crucial step in deployment of the main payload on the victim system. Unlike\nTTPs (Tactics, Techniques, and Procedures) of common malware loaders, this is where the\nBumblebee loader gets creative.\n\n_Function sub_1800013A0 with LoadLibraryW and GetProcAddress functions_\n\nThe module gdiplus.dll is loaded into the process memory address space. Gdiplus.dll is an\nimportant module, containing libraries that support the GDI Window Manager, in the\nMicrosoft Windows OS.\n\n_Runtime execution of function sub_1800013A0_\n\nThe module gdiplus.dll is executed in the last function of the malware loader. This is the first\ninstance in which the unpacked MZ payload is used directly by the loader. Hence, the\nloading of this module appears suspicious. Also, an unusual base address (0x1d54fd0000) is\n\n\n-----\n\nassigned to the loaded gdiplus.dll module.\n\n_Unusual base address assigned to gdiplus.dll_\n\nBy further examining the suspicious memory, it was found that the address is a mapped\npage with RWX permission in the loader address space. This is a classic use case of\nhollowing where the module content is replaced with unpacked malicious artifacts.\n\n_Address as a mapped page with RWX permission_\n\nBut in our analysis so far we have not come across any code that does the hollowing. Then\nhow did the malware change the contents of the gdiplus.dll? Interestingly this is where the\nmalware developer decided to get creative! The hooking seen earlier is responsible for\nhollowing the loaded module with the unpacked payload. More details about the same are\ncovered in the following section.\n\n## Investigating the Hooks and the Trigger\n\n\n-----\n\nAs seen in the previous section, the malware hooks 3 specific APIs:\n\n_NtOpenFile_\n_NtCreateSection_\n_NtMapViewOfSection_\n\nThe API selection is not random. The internal working of loading any DLL via LoadLibrary\nAPI uses the 3 functions mentioned above. Hooking these functions gives the malware the\nflexibility to deploy the unpacked payload covertly. This feature makes it difficult for\nresearchers to hunt the main payload.\n\nThe detour function at 0x180001D4C is used to hook function NtMapViewOfSection, which\nlays the groundwork for hollowing the loaded module (in this case, gdiplus.dll) with the\nunpacked Bumblebee binary. The detour function is capable of the following actions:\n\nSection object creation via NtCreateSection API\nMapping of the view of gdiplus.dll to loader address space via NtMapViewOfSection\nWriting the unpacked payload into the mapped view of gdiplus.dll\nDeallocating heap memory that holds unpacked payload from earlier steps\n\nThe implementation of the detour function at 0x180001D4C, shows the use of a pointer to\nthe NtCreateSection API, for creating a section object to be used later in mapping the\n_gdiplus.dll module._\n\n_Pointer to NtCreateSection API_\n\nAfter creating a section object, the detour function calls NtMapViewOfSection, via a pointer.\nNow the view for the section is created by the system. The function sub_180002E74 is\nresponsible for filling the mapped view with an unpacked payload.\n\n\n-----\n\n_Pointer to NtMapViewOfSection along with sub_180002E74 function_\n\nThe address of the mapped view, returned by NtMapViewOfSection pointer in the loader\nprocess, which is 0x1D54F5D0000, is the same address seen while examining the process\nmodules.\n\n_Address of the mapped view returned by NtMapViewOfSection_\n\n_Unusual base address assigned to “gdiplus.dll” as seen earlier_\n\nThe mapped view starts from 0x1D54F5D0000. The loader dumps the unpacked payload\nhere, hollowing gdiplus.dll. Hence, the final Bumblebee payload stays hidden inside the\nloaded module gdiplus.dll.\n\nRight after mapping the view, the detour function executes sub_180002E74 to initiate the\nwriting of the unpacked binary.\n\n\n-----\n\n_Function sub_180002E74 responsible for filling the mapped view with the final payload_\n\nThe hooks get activated as soon as the loader loads the gdiplus.dll module via LoadLibraryW\nAPI. Then the payload is covertly loaded into the gdiplus.dll module. The final payload is a\nDLL, hence the loader has to explicitly call an exported function to trigger the execution.\n\nIn this case, the loader obtains the address of exported function SetPath via function\n_GetProcAddress. The control is then transferred to the final payload by the final call to_\n_SetPath, by providing the loader program name as argument._\n\n_Loader obtains the address of exported function “SetPath” via GetProcAddress_\n\nThe image below shows the function SetPath exported by the unpacked Bumblebee\npayload.\n\n\n-----\n\n_SetPath Function_\n\n## Bumblebee Main Payload Analysis\n\nThe core malicious component of the bumblebee is executed in the memory, when the\nhollowed gdiplus.dll is loaded via the LoadLibrary API. When the module is loaded into\nmemory, the function DllMain creates a new thread and executes sub_180008EC0 routine.\n\n\n-----\n\n_The DllMain function of the bumblebee payload_\n\n_sub_180008EC0 routine is quite a large function that is responsible for all the malicious_\nactivities performed by Bumblebee on the compromised system.\n\n\n-----\n\n-----\n\n_Function sub_180008EC0 logic flow_\n\n### Anti VM Checks\n\nThe first activity performed by sub_180008EC0 is to check for a virtual machine (VM)\nenvironment. If the function returns True, then Bumblebee shuts itself down by executing the\n_ExitProcess function._\n\n_sub_18003DA0 performs VM check_\n\nThe VM checking routine is. Rigorous. It employs various techniques to ensure that the\nmalware is not running in a sandbox environment used by security researchers. Some of the\ninteresting features are:\n\nIterating through running processes via functions CreateToolHelp32Snapshot,\n_Process32FirstW, and Process32NextW._\n\n\n-----\n\n_Malware functions which help in iterating through running processes_\n\nEach running process is compared to a list of program names.\n\n_Running process being compared to the list of program names_\n\nThe malware also checks for specific usernames used in sandboxed environments to\nconfirm the absence of a VM.\n\n\n-----\n\n_Malware checking for specific usernames_\n\nThe VM check routine also enumerates active system services running via the\n_OpenSCManagerW API. The names of common services used by VM softwares are_\nstored in an array.\n\n\n-----\n\n_Enumerating active system services running via OpenSCManagerW_\n\nIt also scans the system directory for common drivers and library files used by VM\napplications.\n\n\n-----\n\n_System check for common drivers and library files used by popular VM applications_\n\nThe routine also checks for named pipes to identify the presence of VM.\n\nChecking for named pipes\n\nThese are a few examples of techniques employed by the malware to identify analysis\nenvironments. It also has other functionalities built such as the use of WMI and registry\nfunctionalities to identify hardware information to check for the presence of VM environments\ninstalled on the target system.\n\n### Event Creation\n\n\n-----\n\nAfter VM checks, if it is secure to continue, the malware creates an event. The event ID is\n3C29FEA2-6FE8-4BF9-B98A-0E3442115F67. This is used for thread synchronization.\n\n_The event created by the malware_\n\n### Persistence\n\nThe malware uses wsript.exe as a persistence vector to run the malware each time the user\nlogs into the system. The VB instruction is written into a .vbs file. This is performed when the\nC2 sends the “ins” command as a task to execute on the system.\n\n_Wsript.exe_\n\n_VB instruction written into a .vbs file_\n\n### Token Manipulation\n\nThe malware performs token manipulation to escalate its privilege on the target system by\ngranting the malware process a SeDebugPrivilege. With this privilege the malware can\nperform arbitrary read/write operations.\n\n\n-----\n\n_Malware is given the “SeDebugPrivilege”_\n\nThe malware is capable of performing code injections to deploy malicious code in running\nprocesses using various APIs. The malware dynamically retrieves the addresses of the APIs\nneeded for the code injection. The core bumblebee payload comes with embedded files\nwhich areinjected into the running process to further attack the victim.\n\n_List of APIs used to perform code injections_\n\n### Code Injection Via NtQueueApcThread\n\nWhen the malware receives the command along with a DLL buffer, which gets injected, the\nmalware starts scanning for a list of processes on the system. One of the executables in the\nlist is randomly chosen to inject the malicious DLL.\n\n\n-----\n\n_Malware looking for the list of processes on the system_\n\n_List of executables_\n\nFollowing the code injection, the malware:\n\nCreates a process from the previously selected executable image via COM\n(Component Object Model), in which access to an object’s data is received through\ninterfaces, in a suspended state.\nEnumerates through the running process via the CreateToolhelp32Snapshot API to find\nthe newly spawned process created in the previous step.\nWhen the process is found, the malware manipulates the token and acquires the\n_SeDebugPrivilege token to perform further memory manipulation._\nIf token manipulation is successful, the malware injects a shellcode into the process to\nmake it go to sleep.\n\n\n-----\n\n_Malware creating a process and injecting shellcode into it_\n\nFunction sub_180037A80 is responsible for performing the shellcode injection into the\nspawned process in the suspended state.\n\n_Function sub_180037A80_\n\nAfter injecting the shellcode into the process, the malware resumes the process. It then\nexecutes function sub_18003A9BC to finally inject malicious DLL by creating multiple\nmemory sections and views.\n\n_Executing sub_18003A9BC function to inject malicious DLL_\n\nThe DLL code is executed via the NtQueueApcThread API, which is dynamically resolved\nduring the execution.\n\n\n-----\n\n_DLL code executed via NtQueueApcThread API_\n\n## C2 Network\n\nCommand and Control Infrastructure, also known as C2 or C&C, is a collection of tools and\ntechniques used to maintain contact with a compromised system of devices after the initial\naccess has been gained. The IP address of the C2 can be retrieved from the payload code\nas shown below.\n\n_Retrieving the IP address of C2_\n\n\n-----\n\nThe C2 periodically sends out tasks to the agent to be executed on the system. The malware\nextensively uses WMI (Windows Management Infrastructure) to collect basic victim\ninformation like domain name and user name, and sends the compromised information to the\nC2. The C2 distinguishes active agents based on the client ID assigned to each one.\n\n_Data transferred in C2 communication_\n\nInterestingly, the user agent string used by the malware for communication is “bumblebee”.\n\n### Outbound Traffic\n\n_Data transferred out of the compromised system_\n\n**Client Parameters**\n\nclient-id\ngroup_name\nsys_version\nUser name\nclient_version\n\n### Inbound Traffic\n\n_Commands received by the compromised system_\n\n**Client Parameters**\n\nresponse_status\ntasks\n\n### Commands Supported\n\n\n-----\n\nThe task field in the C2 response will contain one of the following commands:\n\n**Command** **Description**\n\n**dex** **Downloads executable**\n\n**sdl** **Kill Loader**\n\n**ins** **Persistence**\n\n**dij** **DLL inject**\n\n## A Tale of Bundled DLLs and Hooks\n\nThe core payload comes with two DLLs embedded in the binary. The purpose and function of\nboth the DLLs are the same, but one is 32 bit and the other is 64 bit. These are used to\nperform further hooking and control flow manipulations.\n\n**DLL Signatures (SHA256)**\n\n32 bit:\nB9534DDEA8B672CF2E4F4ABD373F5730C7A28FE2DD5D56E009F6E5819E9E9615\n64 bit:\n1333CC4210483E7597B26042B8FF7972FD17C23488A06AD393325FE2E098671B\n\nIn this section we will look into the inner workings of embedded 32 bit DLL. The module looks\nfor a specific set of functions in ntdll.dll, kernel32.dll, kernelbase.dll, and advapi32.dll to later\nremove any hooks present in the code. This will also remove any EDR/AV (Endpoint\nDetection and Response/ Antivirus) implemented hooks used for monitoring.\n\n\n-----\n\n_Functions in ntdll.dll checked for existing hooks_\n\n\n-----\n\n_Functions in kernel32.dll checked for existing hooks_\n\nIn kernelbase32.dll following functions are checked for any already existing hooks:\n\n_Functions in kernelbase32.dll checked for existing hooks_\n\n\n-----\n\n_Functions in advapi32.dll checked for existing hooks_\n\n### The Unhooking Mechanism\n\nThe unhooking process involves the following steps:\n\nThe module retrieves handles to target DLLs via the GetModuleHandleW API. The\nhandle returned by the API is for the DLL loaded in the memory by the malware\nprocess, i.e. the process responsible for executing the bumble loader, which is\n_rundll32.exe._\nThen the malware constructs the absolute path for target DLLs via the\n_LetSystemDirectoryA API, to access the system32 directory, where all system DLLs are_\nlocated.\nA pointer to NtProtectVirtualMemory is computed following the DLL path generation.\nFunction sub_10005B90 is called to do the unhooking. Parameters passed to the\nfunction are:\n\nFirst Arg: Absolute path to target DLL\nSecond Arg: Handle to already loaded target DLL\nThird Arg: Offset to array holding target functions exported by the target DLL\nFourth Arg: Null\nFifth Arg: Pointer to NtProtectVirtualMemory\n\n\n-----\n\n_Steps for Unhooking Mechanism_\n\nFunction sub_10005B90 performs the following operations:\n\nMaps fresh copy of the target DLL from the hard disk to address space of the malware\nprocess via functions CreateFileA, CreateFileMappingA, and MapViewOfFile.\nCalls function sub_10005D40 to perform unhooking. The following data is passed to\nthe function:\n\nFirst Arg: Mapped Address of fresh copy of DLL\nSecond Arg: Same as sub_10005B90\nThird Arg: Same as sub_10005B90\nFourth Arg: Same as sub_10005B90\nFifth Arg: Same as sub 10005B90\n\n\n-----\n\nAfter unhooking, the mapped view is released via the UnMapViewOfFile API.\n\n_Operations performed by function sub_10005B90_\n\nThe logic used for unhooking is straightforward. The malware compares the target function in\nthe loaded module in memory against the function defined in the mapped module via\n_MapViewOfFile. If both the codes don’t match, the content from the mapped module is_\nwritten to the loaded module, to restore the state to that of the mapped version from the hard\ndisk.\n\nThe malware goes through the exports of the loaded DLL and performs a string match\nagainst the set of function names stored as an array in a loop. The sub_10005930 is\nresponsible for string matching.\n\n_String match against the set of function names_\n\n\n-----\n\nWhen the function name in the array of the malware matches the exported function from the\nloaded module, the flag is set to [v8] and breaks from the loop. This occurs in the following\nsteps:\n\nThe malware stores the addresses of functions from both modules(loaded and\nmapped).\nThen the loaded and mapped function codes are checked for hooks, by identifying\ndissimilarities in the code. If the loaded code is the same as the mapped one, it breaks\nfrom the loop and continues to iterate through the remaining functions.\n\n_Malware matches the exported function_\n\nIf the loaded code is not the as same as the mapped code, then the following operations are\nperformed by the malware for unhooking:\n\n\n-----\n\n_VirtualQueryEx API is called to retrieve the base address of the page containing the_\ntarget function.\nThen NtProtectVirtualMemory API is used for changing permissions of the page\ncontaining the function code (READ_WRITE_EXECUTE).\n_VirtualQuery is used again to check for permission; whether the page is writable or not._\nFunction sub_10005890 is called to restore the loaded module with the contents of the\nmapped module. Now the functions in the mapped and loaded modules are in the\nsame state.\n\n_Malware does not match the exported function_\n\nAfter clearing all the hooks in the selected functions, the malware installs hooks.\n\nFunctions RaiseFailFastException from kernel32.dll and api-ms-win-core-errorhandling-l1-1_2.dll are hooked. Then the detour function sub_100057F0 hijacks the control flow when the_\nabove functions are called by the system after hooking is done by the malware.\n\n\n-----\n\n_Installing hooks_\n\nFunction sub_100057F0 simply returns the call.\n\n_Function sub_100057F0_\n\nThe embedded DLL has a hooking strategy similar to that of the Bumblebee loader. Various\nfunctions used by the system, while loading a DLL module, are hooked and wups.dll is\nloaded to trigger the chain.\n\n_Hooking of the functions used while loading DLL and loading of wups.dll_\n\n**Target API** **Detour Function**\n\n**ZwMapViewOfSection** **sub_10004C50**\n\n**ZwOpenSection** **sub_10004FF0**\n\n**ZwCreateSection** **sub_10004BC0**\n\n**ZwOpenFile** **sub_10004F20**\n\n## Code Upgrades In The Wild\n\nAfter analyzing many samples in the wild we observed code modifications in the loader.\n\n\n-----\n\n_Prominent code modifications done in Bumblebee loader ever since its discovery_\n\nThe extreme left sample in the image above is the one we have covered in this report. As we\ncan see from the logic flow of the loader, the malware developer has modified the loader\ncode in the other two samples. All the samples observed in the wild are 64 bit DLL modules\nwith an exported function that has a randomly generated string as the function name. This\ncan be justified by the fact that code plays a major role in whether the malware is detected\nby security products. To circumvent this hurdle, malware developers make changes to the\ncode and the malware design.\n\nNewer loader samples in the wild contain various payloads, such as cobaltStrike beacons\nand Meterpreter shells, unlike the custom bumblebee payload seen in the first generation.\n\n## Indicators of Compromise (IoCs)\n\n**Binary**\n\n**f98898df74fb2b2fad3a2ea2907086397b36ae496ef3f4454bf6b7125fc103b8**\n\n**IPv4**\n\n**45.147.229.23:443**\n\nAuthor Details\n\n\n-----\n\n[Anandeshwar Unnikrishnan](https://cloudsek.com/author/anadeshwar-unnikrishnan/)\nThreat Intelligence Researcher, [CloudSEK](https://cloudsek.com/)\nAnandeshwar is a Threat Intelligence Researcher at CloudSEK. He is a strong advocate of\noffensive cybersecurity. He is fuelled by his passion for cyber threats in a global context. He\ndedicates much of his time on Try Hack Me/ Hack The Box/ Offensive Security Playground.\nHe believes that “a strong mind starts with a strong body.” When he is not gymming, he finds\ntime to nurture his passion for teaching. He also likes to travel and experience new cultures.\n\n[Aastha Mittal](https://cloudsek.com/author/aastha-mittal/)\nTotal Posts: 0\nTechnical Writer at CloudSEK\n×\n\n\n-----\n\n[Anandeshwar Unnikrishnan](https://cloudsek.com/author/anadeshwar-unnikrishnan/)\nThreat Intelligence Researcher, [CloudSEK](https://cloudsek.com/)\nAnandeshwar is a Threat Intelligence Researcher at CloudSEK. He is a strong advocate of\noffensive cybersecurity. He is fuelled by his passion for cyber threats in a global context. He\ndedicates much of his time on Try Hack Me/ Hack The Box/ Offensive Security Playground.\nHe believes that “a strong mind starts with a strong body.” When he is not gymming, he finds\ntime to nurture his passion for teaching. He also likes to travel and experience new cultures.\n\nLatest Posts\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-04 - Technical Analysis of Bumblebee Malware Loader.pdf"
    ],
    "report_names": [
        "2022-08-04 - Technical Analysis of Bumblebee Malware Loader.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "62585174-b1f8-47b1-9165-19b594160b01",
            "created_at": "2023-01-06T13:46:39.369991Z",
            "updated_at": "2025-03-27T02:00:03.065156Z",
            "deleted_at": null,
            "main_name": "TA578",
            "aliases": [],
            "source_name": "MISPGALAXY:TA578",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "52eb5fb6-706b-49c0-9ba5-43bea03940d0",
            "created_at": "2024-11-01T02:00:52.694476Z",
            "updated_at": "2025-03-27T02:00:55.51014Z",
            "deleted_at": null,
            "main_name": "TA578",
            "aliases": [
                "TA578"
            ],
            "source_name": "MITRE:TA578",
            "tools": [
                "Latrodectus",
                "IcedID"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535877,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1669661639,
    "ts_modification_date": 1669661639,
    "files": {
        "pdf": "https://archive.orkl.eu/2159e16347df19dbda8cfdb2dc369f3dab7e1496.pdf",
        "text": "https://archive.orkl.eu/2159e16347df19dbda8cfdb2dc369f3dab7e1496.txt",
        "img": "https://archive.orkl.eu/2159e16347df19dbda8cfdb2dc369f3dab7e1496.jpg"
    }
}