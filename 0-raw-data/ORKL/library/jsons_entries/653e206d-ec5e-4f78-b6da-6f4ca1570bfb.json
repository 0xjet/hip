{
    "id": "653e206d-ec5e-4f78-b6da-6f4ca1570bfb",
    "created_at": "2022-10-25T16:48:12.411993Z",
    "updated_at": "2025-03-27T02:16:42.97179Z",
    "deleted_at": null,
    "sha1_hash": "1d53861aafea11d9a60e798b90d623c8e7c7b9e7",
    "title": "Deep Panda",
    "authors": "Crowdstrike",
    "file_creation_date": "2013-02-21T06:14:19Z",
    "file_modification_date": "2013-02-21T06:14:19Z",
    "file_size": 5635891,
    "plain_text": "# DEEP PANDA\n\n\nINTELLIGENCE TEAM REPORT VER. 1.0\n\n\n-----\n\n### 1\n##### 1 EXECUTIVE SUMMARY 2\n\n### 2\n\n##### 1 TECHNICAL ANALYSIS 3\n\n\nDropper Sample (MD5: 14c04f88dc97aef3e9b516ef208a2bf5) 3\nBackdoor DLL Sample (MD5: 47619fca20895abc83807321cbb80a3d) 5\nInitial C2 Phone Home Beacon 6\nNetwork Protocol and Implementation 7\nBackdoor Functionality, Supported Commands 7\nPost Exploitation Tool Sample (MD5: 2dce7fc3f52a692d8a84a0c182519133) 8\nNetwork Protocol and Implementation 9\nBackdoor DLL Sample (MD5: de7500fc1065a081180841f32f06a537) 10\nC2 Communication Mechanisms 12\nC2 Command Invocation 13\nKernel Driver Sample (MD5: dae6b9b3b8e39b08b10a51a6457444d8) 14\nEntrypoint 14\n\n### 3\n##### 1 MITIGATION / REMEDIATION 18\n\nNetwork Signatures 18\nFile System Artifacts 19\nRegistry Artifacts 19\n\nOther Artifacts 19\n\n### 4\n\n##### 1 ATTRIBUTION 20\n\n### 5\n\n##### 1 CONCLUSION 25\n\n\nDropper/Implant #1 25\nPost Exploitation Tool 25\nImplant #2 26\nBackdoor DLL 26\nSystem Driver 26\n\n\n### 6\n\n##### 1 APPENDIX 27\n\nAppendix A: Command Line Options for Post Exploitation Tool Sample                         27\nAppendix B: Algorithm for computing machine ID 28\nAppendix C: Remote Commands Supported by .NET Backdoor Post Exploitation Tool Sample 28\nAppendix D: Raw bytes of example Authentication packet. 30\nAppendix E: Initialization of KEY and IV for AES 30\nAppendix F: Command & Control Servers 31\nAppendix G: Edward Sun’s kernel network hook code 32\nAppendix H: Command and Control MD5 Correlation 41\n\n\n-----\n\n-----\n\n## EXECUTIVE SUMMARY\n\n������������������������������������������������������������������������������������������������������\n���������������������������������������������������������������������������������������������������\n�������������������������������������������������������������������������������������������������������������\n\nThe samples were clearly malicious and varied in sophistication.  All three samples provided remote access\nto the attacker, via two Command and Control (C2) servers. One sample is typical of what is commonly\nreferred to as a ‘dropper’ because its primary purpose is to write a malicious component to disk and connect\nit to the targeted hosts operating system. The malicious component in this case is what is commonly referred to as a Remote Access Tool (RAT), this RAT is manifested as a Dynamic Link Library (DLL) installed\nas a service. The second sample analyzed is a dual use tool that can function both as a post exploitation\ntool used to infect other systems, download additional tools, remove log data, and itself be used as a\nbackdoor. The third sample was a sophisticated implant that in addition to having multiple communication\ncapabilities, and the ability to act as a relay for other infected hosts, utilized a kernel mode driver that can\nhide aspects of the tool from user-mode tools. This third component is likely used for long-term\nimplantation and intelligence gathering. Some AV engines occasionally identify this sample as Derusbi\nTrojan. CrowdStrike Intelligence Team has seen Trojans from 8 different builder variants of this RAT,\nincluding 64-bit versions, used in targeted attacks in 2011 against Defense, Energy/Power, and Chemical\nIndustries in US and Japan.\n\n�����������������������������������������������������������������������������������������������������\ntarget various strategic interests of the United States including High Tech/Heavy Industry,\nNon-Governmental Organizations (NGOs), State/Federal Government, Defense Industrial Base (DIB), and\norganizations with vast economic interests. This report contains an in-depth technical analysis of the\nsamples, detection/remediation/mitigation information, attribution intelligence, and a conclusion aimed at\nproviding the reader with a synopsis of the report.\n\n\n-----\n\n-----\n\n## TECHNICAL ANALYSIS\n\n#### Dropper Sample (MD5: 14c04f88dc97aef3e9b516ef208a2bf5)\n\nThe executable 14c04f88dc97aef3e9b516ef208a2bf5 is commonly referred to as a ‘dropper’, which is\ndesigned with the purpose of extracting from itself a malicious payload and to initialize and install it into a\ntargeted system. In this case, the malicious payload is a Dynamic-Link Library (DLL), which enables an\nattacker to have full control of the system. This code appears to have been compiled on Wednesday May\n4th, 2011 at 11:04:24 A.M. UTC (equivalent to early evening time in China). Note that the timestamp is in\n���������������������������������������������������������������������������������������������������������\nresolves several library functions provided by Microsoft using the LoadLibrary() and GetProcAddress()\nApplication Programming Interfaces (APIs). The imported function names are not encrypted; however, the\nfunction name is minutely obfuscated by a simple single character substitution:\n\n\n//Obfuscation of GetTempPathA() API function call\nstrcpy((char *)ProcName, “2etTempPathA”);\nProcName[0] = ‘G’;\n\n\nThe dropper invokes the SHGetSpecialFolderPath() API supplying a Constant Special Item ID List (CSIDL)\nof ‘CSIDL_COMMON_DOCUMENTS’ to identify the destination folder for the malicious DLL payload. The\n�������������������������������������������������������������������������������������������������������\nusers. A typical path is C:\\Documents and Settings\\All Users\\Documents.”\n\n������������������������������������������������������������������������������������������������������\navailable name in this set:\n\n1. infoadmn.dll\n2. infoctrs.dll\n3. infocardapi.dll\n\n���������������������������������������������������������������������������������������������������������\n������������������������������������������������������������������������������������������������������������\n�����������������������������������������������������������������������������������������������������\n�������������������������������������������������������������������������������������������������������������\n\n�����������������������������������������������������������������������������������������������������������\n��������������������������������������������������������������������������������������������������\n���������������������������������������������������������������������������������������������������������\nartifact which indicates the language setting on the compiler used by the person who built the binary was\n����������������������������������������������������������������������������������������������������������\n�����������������\n\n\n-----\n\n�������������������������������������������������������������������������������������������������������������������\n���������������������������������������������������������������������������������������������������\n��������������������������������������������������������������������������������������������������������\n��������������������������������������\n\n����������������������������������������������������������������������������������������������������\n�����������������������������������������������������������������������������������������������������������\ncode version. Since the dropped resource is not compressed, the routine fails. This indicates a low\n��������������������������������������������������������������������������������������������������������\n\n�����������������������������������������������������������������������������������������������������������\n���������������������������������������������������������������������������������������������������\nparameter. This export then implements the actual install logic to maintain persistence and invoke the main\nroutine.\n\nThe dropper binary contains an icon resource that resembles the ‘Google Chrome’ browser icon, the re���������������������������������������������������������������������������������������������������������������\nsystems language set to Chinese. The use of the Chrome icon may indicate a possible attempt to socially\n����������������������������������������������������������������������������������������������������\n\n\n-----\n\n#### Backdoor DLL Sample (MD5: 47619fca20895abc83807321cbb80a3d)\n\n����������������������������������������������������������������������������������������������\n14c04f88dc97aef3e9b516ef208a2bf5. This code appears to have been compiled on Wednesday May 4th,\n2011 at 10:48:19 A.M. UTC (equivalent to early evening time in China). It is instantiated when it is mapped\n�������������������������������������������������������������������������������������������������������\n������������������������������������������������������������������������������������������������������\nservice despite the appearance. If the service is present, the malware replaces its previous instances or\nversions of this backdoor. After attempting to disable the existing service, the malware tries to install itself as\na service with that same name. During installation, the sample attempts to use documented APIs such as\nOpenSCManager() and CreateService() to initialize itself as a persistent Windows service. As a\nprecaution, the sample writes settings directly to the Windows Registry to accomplish the same goal if\ninstalling the service with the documented APIs fails. The registry change creates the following key:\n\nHKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\msupdate\\\\Parameters\n\nFollowing this, the subroutine will set the value of the ‘ServiceDLL’ to the module handle of the DLL.\n\nThe next key to be changed is:\nHKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Svchost, which will have\nthe ‘msupdate’ key set to ‘msupdate’.\n\nThe export ‘CollectW3PerfData’ is registered as the main function of the DLL. If the installation of the new\nservice is successful, the sample then starts the new service and exits. If the installation fails, the sample\n���������������������������������������������������������������������������������������������������������\nexported function. In the case of installation failure, rundll32.exe calls the main functions export\n�����������������������������������������������������������������������������������������������������������\n�������������������������������������������������������������������������������������������������������������\nover the machine, as rundll32.exe is frequently launched by tasks such as changing the time, wallpaper,\nor other system settings. This means that after cleaning up the components dropped by the malware, the\nsystem remains vulnerable to local attacks by simply overwriting the legitimate rundll32.exe executable with\na malicious version and await it’s automatic execution by the Operating System.\n\n�����������������������������������������������������������������������������������������������������\nWindow with class “NOD32_%d” where %d is replaced with a pseudo-random number. This may be an\nattempt to fool some automated dynamic analysis or anti-malware software into believing this is the\n�������������������������������������������������������������������������������������������������������\n\nAfter creating this window, the routine starts the main thread that eventually initiates calling out to the\nCommand and Control (C2). In order to accomplish this task, the newly\n\n\n-----\n\ncreated thread initializes networking APIs using WSAStartup() and resolves some other APIs dynamically\nusing LoadLibrary() and GetProcAddress(). Once the proper API’s have been resolved, the sample then\nassigns a NULL SID to the rundll32.exe executable and sets the current process’ Window Station to\n“winsta0”, which enables the sample to access the real user’s desktop if started as service.\n\nThe communication to the C2 is handled by a while() loop, with each successive connection attempt\ncausing the loop to invoke the Windows Sleep() API for a time interval of 2 seconds, exponentially\nincreasing in length up to 1024 seconds (17 minutes) and then restarting back to 2 seconds.\n\n#### Initial C2 Phone Home Beacon\n\n�������������������������������������������������������������������������������������������������������\n����������������������������������������������������������������������������������������������������������\nin the binary, using the User-Agent string “Google”, this code is not activated due to the format of the stat�����������������������������������������������������������������������������������������������������������\na raw socket to the C2 located at 1.9.5.38:443. This indicates the use of a ‘boiler plate code’ or a builder\nsoftware package that automates the creation of the malicious sample.\n\nThe malicious sample sends an initial beacon to the C2 that includes the following information:\n\n���������������������������������������������������������������\n����������������������������������������������������������������������������������������������\nDesktop session or “none” otherwise.\n����������������������������������������������������������������������������������������\n�����������������������\n���������������������������������������������\n������������������������������������������������\n��������������������������������������������������������������������������\n�����������������������������������������������������\n\n��������������������������������������������������������������������������������������������������������\n\nThe following python function can be used to decode the beacon stings:\n\n\ndef decode(crypted):\ndecoded=””\nfor x in crypted:\ndecoded+=chr(((ord(x)^(0x1C +1)) + (0x1C +1)) & 0xFF)\nreturn decoded\n\n\n-----\n\nAfter sending the initial beacon, the routine loops receiving incoming commands and executes them in\nsequence. When a connection can successfully be established to the C2 server, the sleep timer is reset to\ntwo seconds for the next attempt.\n\n#### Network Protocol and Implementation\n\nThe network protocol used by this sample resembles a ‘Type-Length-Value’ layout in both directions.\nEach 16 byte request header consists of:\n\n�������������������������������������������������������������������\n2. A 4-byte little-endian payload length\n3. 8 bytes remaining are a request header that is typically uninitialized and only used by some\ncommands instead of the arbitrary length payload\n\n�����������������������������������������������������������������������������\n\n�������������������������������������������������������������������������������������������������������\nbuffer of 408 bytes size. Providing additional payload of any larger size will result in a trivial exploitable stack\n����������������������������������������������������������������������������������������������������������\nexploitation of this vulnerability is unnecessary due to the already available unauthenticated command\nexecution capabilities of this backdoor.\n\nCertain commands initiate a second connection to the C2 in a separate thread using the same network\n�����������������������������������������������������������������������������������������\n\n#### Backdoor Functionality, Supported Commands\n\nThe primary aim of this backdoor is remote desktop control functionality comparable to VNC or Remote\nDesktop over a custom protocol. It allows the adversary to view the main desktop graphically and\ncontrol the keyboard and mouse. This remote control functionality is implemented as separate messages\n����������������������������������������������������������������������������������������������������\n0x22000001 initiates continuous transmission of screen captures to the C2. The screen captures are\ncreated using a series of Microsoft Windows Graphic Device Interface (GDI) API calls culminating in a call to\nGetDIBits().\n\nCommand 0x20000001 exits the backdoor and 0x20000000 is issued to completely remove the backdoor\nfrom the system.\n\n\n-----\n\nWhen command 0x23000004 is received, a temporary new user “_DomainUser_” with password “Dom4!nUserP4ss” is created and added to the local Administrators group. The backdoor is then started under that\naccount and the user is deleted. It would appear this technique is meant to obfuscate the activities of the\nmalicious sample by masking the process creator’s user name to appear to be a generic domain user. Note\nthat such an account does not normally exist in an Active Directory environment.\n\nAdditionally, the primary C2 connection allows for requests to start additional connections to the C2 implementing the following functionality:\n\n�������������������������������������������������������������������������������������������������\nkilling of running processes\n��������������������������������������������������������������������������������������������\noutput of arbitrary executables; initiated by command 0x23000000\n���������������������������������������������������������������������������\n\n����������������������������\n�����������������������������������\n�������������������������������������������\n�������������������������������������������������\n����������������������������������������������������������������������\n\n#### Post Exploitation Tool Sample (MD5: 2dce7fc3f52a692d8a84a0c182519133)\n\nThis sample is typical of a post exploitation tool; it is written in .NET 2.0. This code appears to have been\ncompiled on Thursday May 26th, 2011 at 10:21:44 A.M. UTC (early evening time in China). The backdoor\nfunctionality can be instantiated either directly from the command line or through commands issued over a\nnetwork based protocol via the C2. If no arguments are given, a connection to the C2 is initiated to the stati�����������������������������������������������������������������������������������������������������������\n��������������������������������������������������������������������������������������������������������������\nC2.\n\n���������������������������������������������������������������������������������������������������������\n�����������������������������������������������������������������������������������������������������������\n���������������������������������������������������������������������������������������������������������\nline arguments can be viewed in Appendix A. This activity is generally associated with log cleaning to complicate a forensic investigation.\n\nThe sample contains an embedded IP address for C2 that is stored in an encrypted format as a string resource:\n\n����������������������������������������������������������������������\n\n\n-----\n\n��������������������������������������������������������������������������������������������������������������\n����������������������������������������������������������������������������������������������������\n���������������������������������������������������������������������������������������������������\n202.86.190.3:80 (Hong Kong: TeleOne(HK) Limited).\n\n#### Network Protocol and Implementation\n\nThere are three components to the protocol:\n\n**Authentication is accomplished using a 32 byte packet, this packet consists of:**\n\n�����������������������������������������������������������������������������������\n2. A four byte random number generated by the rand() function\n3. The machine ID comprised of an obfuscated combination of the Machine name and hard drive\nserial number. The algorithm for generating this is in Appendix B\n4. The communication protocol version number, which in this sample is 0x2\n5. The version of the malicious sample, in this case it is 841\n\nAn example authentication packet sent to the C2 is located in Appendix E\n\n����������������������������������������������������������������������������������������������������������������\n����������������������������������������������������������������������������������������������������������������\nto the client which is then RC4 encrypted using the random number generated in step 2 from above as the\npassword. This value is then transformed using a simple algorithm in Appendix F into a 32 byte array. The\n������������������������������������������������������������������������������������������������������������\nup AES encryption which is then used to encrypt and decrypt any further communications.\n\n\n-----\n\n**Beacon, this is typical of this type of malicious sample, it allows the operator to separate various infected**\nhosts in a targeted campaign. The beacon for this sample is formatted as XML and consists of:\n\n����������������������������\n��������������������\n������������������\n������������������������������������������\n�����������������������\n\nAn example of an unencrypted beacon:\n\n<?xml version=”1.0” encoding=”utf-16”?>\n<BasicInfo xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance” xmlns:xsd=”http://www.\nw3.org/2001/XMLSchema”>\n<HostName> Infected System Hostname</HostName>\n<int_0>-8</int_0>\n<osVersion>Microsoft Windows NT 6.1.7601 Service Pack 1</osVersion>\n<string_0>12/27/2011 16:34:36</string_0>\n<Version>2</Version>\n</BasicInfo>\n\n**Command handling loop, this is a loop structure that will process and execute commands sent by the C2.**\nThe malware sends and receives a heartbeat/keepalive packet every 2 minutes. The command format is\nderived from a structure consisting of:\n\n����������������������������������������������������������������������������������������������������\ndescription of the possible values for commands is in Appendix D. It is important to note that the order in\n������������������������������������������������������������������������������������������������������\n���������������������������������������������������������������������������������������������������\ncalling methods on those assemblies, connecting to new C2 servers and executing processes.\nBackdoor DLL Sample (MD5: de7500fc1065a081180841f32f06a537)\n\n#### Backdoor DLL Sample (MD5: de7500fc1065a081180841f32f06a537)\n\nThis sample is a sophisticated backdoor which implements several communications protocols and was\n������������������������������������������������������������������������������������������������������������\n�������������������������������������������������������������������������������������������������������\nUTC (late evening time in China). The code contains several Run Time Type Information (RTTI) artifacts that\n�����������������������������������������������������������������������������������������������������\n\n\n-----\n\nVariants of this Trojan are sometimes detected under the name ‘Derusbi’ by Microsoft, Trend, Sophos and\nSymantec AV engines.\n\nThis sample is a DLL which can be registered as a service and is used to drop a kernel driver and provide\nan interactive command line shell to the C2. It also is able to bypass User Account Control (UAC) to install\nitself by using the ‘sysprep.exe’ Microsoft Windows executable provided by the targeted system. The steps it\ntakes to install itself onto a system are as follows:\n\n1. Copies itself to to %WINDIR%\\system32\\Msres<3 random characters>.ttf\n�����������������������������������������������������������������������������������������������������������\nthe current system time when the copy was made but with the year changed to 2005.\n������������������������������������������������������������������������������������\nMACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\<service>” This defaults to “wuauserv”,\n���������������������������������������������������������������������������������������\n4. Adds itself to list of services started by ‘netsvc’ using the service name ‘helpsvc’.\n5. If McAfee AV is installed, creates a copy of regsvr32.exe named Update.exe and then schedules\nthe copy to be deleted on reboot using the well documented MoveFileExA API.\n6. It then calls either the original or copy of regsvr32.exe with the parameters /s /u and the path to\nthe copy of itself it made in Step 1. The /u parameter means “uninstall”, which calls\nDllUnregisterServer, this is an unsophisticated method of DLL entry point obfuscation.\n7. DllUnregisterServer installs the driver and initiates the backdoor component.\n\n��������������������������������������������������������������������������������������������������������\nexe” is running (AntiVirus360 program from the Chinese ‘Quihoo 360 Technology Co., LTD’ 360 ),\nor the username of the DLL’s host process context is not ‘SYSTEM’, the driver is not written to disk. Barring\nthe two aforementioned conditions, the sample decrypts the kernel driver to:\n\n“%sysdir%\\Drivers\\{6AB5E732-DFA9-4618-AF1C-F0D9DEF0E222}.sys”\n\n�������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������\nhash of dae6b9b3b8e39b08b10a51a6457444d8.\n\n������������������������������������������������������������������������\n\n“HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Rpc\\Security”\n\n�������������������������������������������������������������������������������������������������������\n����������������������������������������������������������������������������������������������������������������\n��������������������������������������������������������������������������������������������������������\ncode.\n\n\n-----\n\n����������������������������������������������������������������������������������������������������������\nthe backdoor then loads the original service’s DLL into the address space with LoadLibrary and invokes the\nServiceMain export. This effectively hijacks the original service’s entry while retaining its functionality.\n\nWhile there is code in the binary that allows downloading a list of C2 servers from an HTTP URL, the default\n������������������������������������������������������������������������������������������������������\nthe one used by the post exploitation .NET tool.\n\n#### C2 Communication Mechanisms\n\nThe malware has three distinct C2 protocols two of which can be transmitted over HTTP proxies and one\ncan be bundled in two different ‘dual’ modes (see 3.), totaling 7 distinct supported C2 mechanisms. The con����������������������������������������������������������������������������������������������������������\n�������������������������������������������������������������������������������������������������������������\n�������������������������������������������������������������������������������������������������������������\n��������������������������������������������������������������������������������������������������������������\n\n1. Proprietary binary header (optionally over an HTTP Proxy using CONNECT mechanism); this\nprotocol consists of 64 random bytes being sent to the C2. The C2 then responds with 64 bytes\n���������������������������������������������������������������������������������������������\n�����������������������������������������������������������������������������������������������������\nbytes rotated right by seven bits and compares that value to the seven bits rotated right version of\nthe server’s response, effectively neutralizing the rotation’s effect; the purpose of this is unclear.\n�������������������������������������������������������������������������������������������������\nrequest string including HTTP headers (optionally over a HTTP Proxy using CONNECT). The\nmalware requires the response to start with “HTTP/1.0 200” or “HTTP/1.1 200” and an absence of\na “Connection: close” header. This one HTTP connection will be used for bi-directional\ncommunications, sending chunks of POST payload and receiving chunks of the response,\ninterleaved.\n3. Two long-running HTTP requests to the same C2 (optionally over an HTTP Proxy with original\nrequest verb), one GET request to “/Photos/Query.cgi?loginid=” followed by a random number\nand one POST request to “/Catelog/login1.cgi”. The GET request serves as a down-stream\nchannel while the POST request serves as a upstream channel.\n\n�������������������������������������������������������������������������������������������������������\nlegitimate appearing channels as required in order to appear Request For Comment (RFC) compliant with\nthe HTTP protocol.\n\n�����������������������������������������������������������������������������������������������������������\n������������������������������������������������������������������\n\n\n-----\n\n�������������������������������������������������������������������������������������������������������������\ndue to time constraints.\n\nAfter establishing any of the aforementioned channels for arbitrary binary data exchange, the malware will\nstart sending and receiving compressed binary blobs via the channel of choice. The C2’s binary data blobs\nare compressed. No further encryption of the data takes place.\n\nAll C2 transport implementations contain code for accepting and handling server-side connections of the\nrespective protocols. However, this code does not appear to be invoked. It appears that the author of this\ncode shares the library that implements these transports for the client with the C2 server.\n\n#### C2 Command Invocation\n\nThe main backdoor thread then reads commands from the chosen C2 protocol and passes them on to any\nof the following registered handler classes based upon a command ID. The handler class is responsible for\nparsing the remainder of the command.\n\n**��������������������������������������������**\n���������������������������������������������������������������������������������������������������������\n�������������������������������������������������������������������������������������������������������\n����������������������������������������������������������������������������������������������������������������\n������������������������������������������������������������������������������������������������������\n\n**PCC_PROXY: TCP Proxy**\nThis handler class implements a generic TCP proxy. It supports establishing TCP connections to other hosts\nand also listening for incoming connections. The incoming connection contents are forwarded to the C2 and\ndata from the C2 is passed on to connections. It supports up to 1024 parallel connections.\n\n**PCC_MISC : Gather and report system information**\nThe malware is capable of gathering various pieces of information from the system, triggered by a command\nID 10. The capabilities include recovering authentication credentials from various system and client storage\nsuch as Mozilla Firefox, Internet Explorer, and Remote Access Service (RAS). This class also supports\ngathering intelligence on the infected system including identifying security tools by their process name, proxy\naccounts, and version numbers for the Operating System (OS) and Internet Explorer.\n\n**PCC_SYS: System Management**\nThis handler class provides the attacker with the ability to manage system components including start/stop/\ndelete system services, enumerate/alter registry keys, and manage running processes. This class also\nprovides the ability for the attacker to take a screen shot of the users desktop.\n\n**INTERNAL_CMD: Command-Line Shell**\n\n\n-----\n\nThis handler class uses the command ID 5 and implements an interactive command line shell accessible\nfrom the C2 server, containing a series of built-in commands. If the input is not in this list of built-in\ncommands, the malware attempts to invoke cmd.exe in the background, launching a command or command\nline utility already present on the system. The standard output channel of that command is provided back to\nthe C2. The supported built-in commands are:\n\n��������������������������������������������������\n������\n�������\n������\n������\n�������\n��������\n�������\n��������\n���������\n�������\n�������\n���������\n���������������\n�����������������\n����������������������������������������������\n��������\n�����������\n\n**Kill Switch / Self-Destruction**\nThe only command that is implemented directly in the main backdoor thread as a subprocedure call and not\nvia a generic command handler class is command ID 256. This command results in the DLL deleting itself\nand terminating the backdoor process.\n\n#### Kernel Driver Sample (MD5: dae6b9b3b8e39b08b10a51a6457444d8)\n\nThis sample is a packed 32-bit kernel driver extracted by the aforementioned DLL with an MD5 hash of:\nde7500fc1065a081180841f32f06a537, this sample will only function on a Windows 32-bit kernel. This code\nappears to have been compiled on Sunday October 9, 2011 at 4:50:31 P.M. UTC (very early morning time\nof Monday, October 10 in China).\n\n#### Entrypoint\n\nThis section describes how the driver performs its initialization routine.\n\n**Multiple Instance Protection**\nThe driver begins by opening a named event in the BaseNamedObjects object directory with the name\n�������������������������������������������������������������������������������������������������\nexists, the driver fails to load, presumably to avoid a\n\n\n-----\n\nmultiple instances of itself. If the event does not exist, the driver then creates it using the Windows API\n�������������������������������������������������������������������������������������������������������\n��������������������������������������������������������������������������������������������������������������\nand indicative of relatively limited Windows API knowledge of the author of that part of the code. It is\ninteresting to note that some of the hex digits in the object name are mixed case which is potentially\nindicative of the code being re-appropriated from another source.\n\n**Anti-Debugging Protection**\n\nThe second component of the entry point performs an anti-debugging technique, calling the function\nKdDisableDebugger(), which allows the driver to disable usage of the built-in Windows kernel debugging\nfacility that is used by popular kernel debuggers KD and WinDbg. Tools such as Syser Debugger, or\ndebugging through a virtual machine are unaffected by this technique. The sample, rather than importing the\nKdDisableDebugger() API using conventional methods, looks up the API through\nMmGetSystemRoutineAddress() instead. All of the other APIs used by the driver are imported normally, so\nthis is not a technique to hide import APIs used throughout the driver. Searching Google for\n“MmGetSystemRoutineAddress” and “KdDisableDebugger” results in dozens of Chinese language blogs\nwhich explain how to use this technique to “Disable WinDbg”.\n\n**Hooking**\n\n�������������������������������������������������������������������������������������������������������������\nis designed to hook the system call table, while the other hooks the network stack.\n\n**Network Stack Hooking**\n��������������������������������������������������������������������������������������������������������\nthe version is necessary because Windows versions beginning with Vista utilize a redesigned TCP/IP network stack, most hooking operations will require a different implementation for these versions. On versions\nprior to Windows Vista, the TCP/IP driver creates a \\Device\\Tcp device object through which most network\nrequests are piped through. On Vista and later, TCP/IP has been split up into multiple components, and IP\nconnection enumeration, which this driver is targeting, is managed by \\Device\\nsiproxy instead.\n\nIn either case, the driver obtains the device object by using IoGetDeviceObjectPointer() and hooks Major\nFunction 14 the IRP_MJ_DEVICE_CONTROL, as this is the function through which all Input Output\nConTroLls (IOCTLs) are sent, such as the IOCTL for querying active IP connections.\n\n**Network Store Interface (NSI) Hook**\nThe NSI hook, targets IOCTL 0x12001B, which is used by NsiGetObjectAllParameters() in nsi.dll when\nusers typically run commands such as netstat.exe or use any of the IP Helper APIs in iphlpapi.dll. The\npurpose of the hook is to scan the list of active connections returned to the user, and hide any such\nconnection currently bound to a local TCP port in\n\n\n-----\n\nthe range between 40000 and 45000. The hooking is performed by creating a new completion routine\nassociated with any IRP_MJ_DEVICE_CONTROL IRP that matches the IOCTL, attaching to the target\nprocess, performing several memory copies to hide the entry, and detaching.\n\nThis functionality is nearly identical to the code posted by Edward Sun (aka cardmagic, sunmy1@sina.com,\nonlyonejazz@hotmail.com, cardcian@mail.ustc.edu.cn, QQ# 28025945) from Hefei, Anhui province\n(Nanjing Military District) on July 8, 2007, then a China-based researcher at Trend Micro (now working at\n����������������������������������������������������������������������������������������������������at\nhttp://forum.eviloctal.com/viewthread.php?action=printable&tid=29604 (See Appendix G). CrowdStrike has\nno information connecting Mr. Sun to this intrusion activity, his code appears to have been appropriated by\nthe actor to add similar functionality to their code.\n\n**TCP Hook**\nThe TCP hook works almost identically to the NSI hook, though instead hooking IOCTL 0x120003 (IOCTL_\n��������������������������������������������������������������������������������������������������\n����������������������������������������������������������������������������������������������������\nany connections listening on TCP ports in the range between 40000 and 45000.\n\n**System Call Hooking**\n��������������������������������������������������������������������������������������\n�����������������������������������������������������������������������������������������������������\nDWORD at each of these exported functions. Because the system call stub uses the EAX register as an\nindex for the system call ID, and a “mov eax, imm32” instruction” instruction is used, this second DWORD\nwill match the system call ID. It then adds this index to the value of KeServiceDescriptorTable.Base, which\nis the exported kernel variable (on 32-bit Windows only) which directly points to the system call table. This is\none of the simplest ways to do a system call hook, but will not work on 64-bit Windows as this variable is not\nexported in addition to the protection provided by Microsoft PatchGuard.\n\n���������������������������������������������������������������������������������������������������\nWindows API IoAllocateMdl(), and associating the MDL to a non-paged buffer using\nMmBuildMdlForNonPagedPool(). Once the MDL is associated to the non-paged buffer, the sample locks the\nunderlying pages using the Windows API MmProbeAndLockPages(). Instead of hooking the entry in the\ntable directly, which is easily detectable, the driver uses the LDASM open-source disassembly engine to\nanalyze the function that is being pointed to by the table, and applying a Detours-style hook directly in the\ncode. It uses the standard “mov cr0, eax” technique, turning off the Write Protect (WP) bit as it does this.\nWhen the hook is installed, it writes a special DWORD value, ‘KDTR’, which allows it to prevent\ndouble-hooking or badly-hooking the system call, during unhooking, this value is also checked.\n\n**Registry Hooks**\n�����������������������������������\\\\REGISTRY\\\\MACHINE\\\\SYSTEM is blocked. RegSaveKey() which is\n��������������������������������������������������������������������������������������������������������\nbackup of a particular registry key.\n\n\n-----\n\n���������������������������������������������������������������������������������������������������������\n\\\\REGISTRY\\\\MACHINE\\\\SYSTEM\\\\ControlSet001\\\\Services\\\\. It then checks for the values of the\n“ServiceDll” and “Security” keys, in the latter case it applies an XOR on the data with the value 127. The\nuser-mode component of this malware is a service called “msupdate”, this driver is attempting to hide the\n����������������������������������������������������������������������������������������������������������\n�������������������������������������������������������������������������������������������������������\n�����������������������������������������������������������������������������������������������������������\n��������������������������������������������������������������������������������������������������������\nkey, due to the fact that these APIs provide almost identical functionality when it comes to reading registry\nvalues.\n\nIn the registry hooking code of the driver, a call is made to ObReferenceObjectByHandle(). This allows the\ndriver to receive the ‘CM_KEY_OBJECT’ which is then used with ObQueryNameString() to get the key/value\npath. However, no call to ObDereferenceObject() is ever made, which means that all registry objects being\nsent to these APIs are eventually leaked.\n\nIn the registry hook, it was noticed that “CurrentControlSet001” was used as the target, if the target machine\n������������������������������������������������������������������������������������������������������\nfunction as intended. This is the reason the Microsoft implemented a symbolic link to \\\\CurrentControlSet\n�������������������������������������������������������������������������������������������������������������\n\n\n-----\n\n-----\n\n## MITIGATION / REMEDIATION\n\n�����������������������������������������������������������������������������������������������������\n�������������������������������������������������������������������������\n\n#### Network Signatures\n\nThe following network signatures are designed for the popular Open Source IDS called Snort.\nThese signature can be ported to other formats upon request.\n\n**Malware #1**\n\n\nalert tcp any any <> any any (msg: “BackDoor Beacon Attempt”; content:”|78 7c\n71 4c 4a 49 49 49 4A 4C 46|”; classtype:backdoor; sid:123456; rev:27122011;)\n\nalert tcp any any <> any any (msg: “BackDoor Beacon Attempt”; content:”Google”; http_uri; classtype:backdoor; sid:123457; rev:27122011;)\n\nalert ip 1.9.5.38 any <> any any (msg: “Malicious Host Detected”; classtype:backdoor; sid:123460; rev:27122011;)\n\n\n**Malware #2**\n\n\nalert tcp any any <> any any (msg:”BackDoor Beacon Attempt”; content:”|03 01\n74 80 82 21 b5 64 c2 74 22 e3 02 00 00 00 49 03 00 00 00 00 00 00 00 00 00 00\n0000 00 00|”; classtype:backdoor; sid:123458; rev:27122011;)\n\nalert ip 202.86.190.3 any <> any any (msg:”Malicious Host Detected”; classtype:backdoor; sid:123459; rev:27122011;)\n\n\n**Malware #3**\n\n\nalert tcp any any <> any any (msg: “BackDoor C2”; content: “POST /forum/\nlogin.cgi HTTP/1.1”; content:”User-Agent: Mozilla/4.0”; classtype:backdoor;\nsid:123461; rev:27122011;)\n\nalert tcp any any <> any any (msg: “BackDoor C2”; content: “GET /Photos/Query.\ncgi?loginid=”; classtype:backdoor; sid:123462; rev:27122011;)\n\nalert tcp any any <> any any (msg: “BackDoor C2”; content: “POST /Catelog/\nlogin1.cgi HTTP/1.1”; content:”User-Agent: Mozilla/4.0”; classtype:backdoor;\nsid:123461; rev:27122011;)\n\n\n-----\n\n#### File System Artifacts\n\n������������������������������������������������������������������������\n\n**Dropper/DLL**\nC:\\Documents and Settings\\All Users\\Documents\\infoadmn.dll (TS: 2007-03-07 00:00:00)\nC:\\Documents and Settings\\All Users\\Documents\\infoctrs.dll (TS: 2007-03-07 00:00:00)\nC:\\Documents and Settings\\All Users\\Documents\\infocardapi.dll (TS: 2007-03-07 00:00:00)\nMD5: 47619fca20895abc83807321cbb80a3d\n\n**Post Explotiation Tool**\nMD5: 2dce7fc3f52a692d8a84a0c182519133\n\n**Backdoor**\nMD5: de7500fc1065a081180841f32f06a537\n\n**Kernel Driver:**\nMD5: dae6b9b3b8e39b08b10a51a6457444d8\n“%sysdir%\\Drivers\\{6AB5E732-DFA9-4618-AF1C-F0D9DEF0E222}.sys”\n\n#### Registry Artifacts\n\nThe following Windows Registry artifacts are indicative of a compromised host:\n\n**Dropper/DLL**\nHKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\msupdate\nHKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Svchost which will have\nthe ‘msupdate’ key set to ‘msupdate’\n\n**Backdoor**\nHKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Msres<3 character rand>.ttf\n\n#### Other Artifacts\n\n**Dropper/DLL**\nUsername: _DomainUser_ Password:”Dom4!nUserP4ss”\n\n**Backdoor**\nThe backdoor may be detected by several different Anti-Virus products under a signature with the name:\nDerusbi\n\n**Kernel** **Driver**\nObject: {8CB2ff21-0166-4cf1-BD8F-E190BC7902DC}\n\n\n-----\n\n-----\n\n## ATTRIBUTION\n\nAttribution in the cyber domain is always a tricky subject when relying solely on malicious samples.\nCompiler artifacts and language settings can of course be deliberately masked or spoofed. CrowdStrike\nuses a unique approach of comprehensive threat analysis in order to decipher attributable components.\nBased on the corroborating evidence discovered in the course of this analysis, it appears there are\nnumerous indications that this is a Chinese-speaking actor.\n\n�������������������������������������������, a Chinese security product available from\nhttp://www.360.cn/. This is particularly relevant in this case because the backdoor DLL sample with an MD5\n��������������������������������������������������������������������������������������������������������\nthis tool. Speculatively this may be because this security product detects this rootkit, or the author was\nattempting to prevent accidental infection on systems running this Anti-Virus product.\n\nThe obfuscation of the KdDisableDebugger() function call is seen on several Chinese language forums,\nand can be seen being reused in several code samples on those forums. As previously mentioned there is\nno advantage associated with using this call obfuscation, and appears to be reused for no apparent reason\nother than the attackers have copied code directly from forum code.\n\nWhile the various network hooking techniques used in the kernel driver may appear novel or well\n��������������������������������������������������������������������������������������������������������������\n‘rootkit.com’ by a Chinese language developer. This post is currently mirrored on dozens of Chinese hacking\nwebsites.\n\nSimilarly the system call hooking is less impressive after searching for “IoAllocateMdl” and “cr0” (bbs.pediy.\ncom/showthread.php?t=77467�����������������������������������������������������������������������\nperform system call hooking through MDLs. The ldasm inline hooking is also repeated in numerous postings\nto Chinese forums. One particular website (http://read.pudn.com/downloads197/sourcecode/windows/system/927802/CCRootkit/RootkitSys/HookSSDT.c__.htm) had an almost identical ldasm loop that tried to\nidentify the exact same code sequences. Open source research of the 4 innocuous kernel APIs\n����������������������������������������������������������������������������������������������\nChinese website that has a cached rootkit performing similar hooks on the same 3 registry related APIs.\n\nWhile the driver does not use pool tags for most of its allocations, it does utilize them in the networking\nhooking code, much like the examples found on the Chinese language forums. This sample uses pool tags:\n‘tnet,’ and ‘KDTR’. Although the meaning of the KDTR tag is not\n\n1 http://bbs.pediy.com/showthread.php?t=125358\nhttp://kost0911.pixnet.net/blog/post/36914183-anti-anti-windbg\n\n\n-----\n\n���������������������������������������������������������������������������������������������������\ncoincides with the matching functionality of the detour-style inline hook.\n\nThe driver code (MD5: dae6b9b3b8e39b08b10a51a6457444d8) appears to be a combination of various\ncode that is easily searchable on the Internet, and almost always attributed to Chinese language forums\nand websites. The system call hooking parts of the code appear to be identical to the HookSSDT.c code\nauthored by Steven Lai ‘embedlinux’ and utilized in what the author titled ‘CC Rootkit’ on on August 4, 2008\nwho’s email address is hqulyc@126.com. This user has a QQ identity of: 5054-3533, QQ is a popular\n���������������������������������������������������������������������������������������������������������\n(http://user.qzone.qq.com/50543533) appears to be Steven Lai. He was is 28 years old (born September 5,\n�������������������������������������������������������������������������������������������������������������\nat Xiamen XOCECO New Technic Co., Ltd. (http://www.likego.com/en/about.asp), a company that builds\n�������������������������������������������������������������������������������������������������������\nhowever was used by whomever built the kernel driver utilized by the backdoor and for this reason we are\nproviding the background on this individual.\n\n\n-----\n\nATTRIBUTION\n\n##### For more information about Intelligence-as-a-Service or specific attribution information on Deep Panda, contact the CrowdStrike Global Intelligence Team\n\n\n-----\n\nATTRIBUTION\n\n##### For more information about Intelligence-as-a-Service or specific attribution information on Deep Panda, contact the CrowdStrike Global Intelligence Team\n\n\n-----\n\nATTRIBUTION\n\n##### For more information about Intelligence-as-a-Service or specific attribution information on Deep Panda, contact the CrowdStrike Global Intelligence Team\n\n\n�������������������������������������������������������������������������������������������\n\n(http://read.pudn.com/downloads197/sourcecode/windows/system/927802/CCRootkit/RootkitSys/HookSSDT.c__.htm).\n\nAccording to this Linux driver development guide ‘embedlinux’ published on July 31, 2008 (http://wenku.\nbaidu.com/view/e24205294b73f242336c5f45.html), t\n\n\n-----\n\n-----\n\n## CONCLUSION\n\nThe samples involved in this incident are typical of attacks commonly associated with the People’s\nRepublic of China (PRC). These code samples have a variety of Tools, Techniques, and Procedures (TTPs)\n���������������������������������������������������������������������������������������������������������������\n����������������������������������������������������������������������������������������������������������������������\nThe ability to conduct Incident Response (IR) including forensics, and log analysis, greatly augments this\nvisibility into these aspects of the incident. Some indications as to the adversaries’ capabilities can be\nderived from the captured samples alone.\n\n#### Dropper/Implant #1\n\nThe dropper code (MD5: 14c04f88dc97aef3e9b516ef208a2bf5) does not utilize any techniques that are\nunique or unusual, and is consistent with tools, techniques, and procedures of attacks targeting proprietary\ninformation and generally attributed to the PRC. The presence of dead code and its replacement by a more\n��������������������������������������������������������������������������������������������������������\nside. The ‘dead code’ utilizes a more sophisticated compression algorithm provided by a third party which\nwas rendered useless for some reason. This may have been a result of the attacker modifying an existing\ntool, or unknowingly using a re-purposed tool. The dropper resources indicate the compiler used to build the\ntool was running on a system that utilized the Chinese “Simple” language pack and was built on Wednesday\nMay 4th, 2011 at 11:04:24 A.M. UTC (early evening time in China). While this can be deliberately spoofed\n��������������������������������������������������������������������������������������������������������������\nspeaking actor.\n\nThe dropped DLL (MD5: 47619fca20895abc83807321cbb80a3d) itself contains functionality that is typical\n��������������������������������������������������������������������������������������������������������\n�������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������\nencryption/obfuscation using a statically compiled XOR key. The sample uses TCP port 443 for communication, but makes no attempt to mimic the SSL protocol typically used on that port number, which would\nprovide enhanced Operational Security (OPSEC). This code appears to have been compiled on Wednesday May 4th, 2011 at 10:48:19 A.M. UTC (early evening time in China).\n\n#### Post Exploitation Tool\n\nThe post exploitation tool (MD5: 2dce7fc3f52a692d8a84a0c182519133) is a dual-use tool, it can be\ndropped and executed by a client-side exploit, or the adversary can launch it using a variety of command\nline options. This tool is built in Microsoft .NET framework, which is typically an indication of a less sophisticated attacker, because .NET is easier to develop in but requires the .NET framework be present on the\nvictim machine. The tool appears to have been compiled on Thursday May 26th, 2011 at 10:21:44 A.M.\nUTC (early evening time in China). The sample utilizes the AES cryptographic algorithm to protect its C2\ncommunications.\n\n\n-----\n\n#### Implant #2 Backdoor DLL\n\nThis DLL is a moderately sophisticated backdoor with several well designed communication mechanisms\nnot typically seen in these types of implants. The code base for the sample was developed in C++. The\ncode appears to have been compiled on Sunday October 30, 2011 at 12:43:33 P.M. UTC (late evening time\nin China). This sample has multiple communication capabilities available that makes it far more versatile\nand stealthy. It implements relatively well thought out protocols including HTTP and DNS. The tool has the\nability to automatically down select the most effective communication channel once it has been instantiated,\nwhich can help avoid detection from solutions like DNS blacklisting and RFC protocol enforcement. The\nDLL itself contains traces of the original C++ class names that were utilized in the source code, which in\n���������������������������������������������������������������������������������������������������������\n���������������������������������������������������������������������������������������������������\ncommunicating to the C2, thus enhancing OPSEC. The sample contains ‘dead code’ which appears to be\ncommand and control server classes, this is likely an indicator that the C2 client which would communicate\nwith this sample shares the same communications library which was compiled into this sample.\nSystem Driver\nThe kernel driver component dropped by the Backdoor DLL bears many tool marks associating it with the\nCCRootkit package publicly by Steven Lai (a/k/a embedlinux). This kernel mode rootkit implements several\nhooking techniques that are aimed at preventing a system administrator from detecting the backdoor DLL.\nThe implementation of these techniques has some unique idiosyncrasies that permit direct attribution to the\nsource code Steven Lai posted. This driver attempts to hide a wide swath of TCP ports (40000-45000) for\nan unknown reason, however it is suspected that this may relate to the potential network relaying capability\nalluded to for the backdoor dll.\n\n#### System Driver\n\nThe kernel driver component dropped by the Backdoor DLL bears many tool marks associating it with the\nCCRootkit package publicly by Steven Lai (a/k/a embedlinux). This kernel mode rootkit implements several\nhooking techniques that are aimed at preventing a system administrator from detecting the backdoor DLL.\nThe implementation of these techniques has some unique idiosyncrasies that permit direct attribution to the\nsource code Steven Lai posted. This driver attempts to hide a wide swath of TCP ports (40000-45000) for\nan unknown reason, however it is suspected that this may relate to the potential network relaying capability\nalluded to for the backdoor dll.\n\n\n-----\n\n-----\n\n## APPENDIX\n\n#### Appendix A: Command Line Options for Post Exploitation Tool Sample (MD5: 2dce7fc3f52a692d8a84a0c182519133\n\n��������������������������������������������������������������\n\n� ���iu - impersonate user, iu represents a username and expects the following additional arguments.\n� � ���id -domain\n� � ���ip -password\n� � f - perform command based on value. Possible values listed below\n� � ���sh - Connect to C2.\n� � � ���x - hostname, connect to http address to download\n\n���y - port\n���u - username\n���w - password\n� � � ���l - set up listener\n\n���s - hostname\n���p - port\n� � ���v - display communication protocol version\n� � ���dl���������������\n� � � ���url - url to download from.\n� � � �����������������������������\n� � ���ul�������������\n� � � ���url - url to upload to.\n� � � �����������������������\n� � ���cl�������������������������������������������������������������������������������������\n� �������������������������������������������������������������������������������������������������������\n� � ���������������������������������������������������������������������������������������������������\nas to hide the tampering.\n� � � ���p - target path\n� � � ���m������������������������\n� � � ��������������\n� � ���tu�����������������������������������������������������������������������������������������������\ndate of 11-30-2005:12:00:00 with the UTC offset of the system applied.\n� � � ���p - target path\n� � � ���m����������������\n� � � ���r�����������������\n� � ���d������������������������������������������������\n� � � ���t��������������\n� � ���wmi - perform Windows Management Instrumentation (WMI) command\n� � � ���s - machine\n� � � ���u - username\n� � � ���p - password\n� � � ���������������\n� � � ���m - can be one of the following 3 items\n\n\n-----\n\n������������������������\n� � � � � ������������\n� � � � ������������������\n� � � � � ������������������������\n� � � � � �����������������������\n� � � � � �����������������������������������\n� � � � �������������������\n� � ��������������\n� � � ����������������\n� � � ��������������\n� � � ����������������\n� � � �������������������\n� � � ����������������������������������������\n\n#### Appendix B: Algorithm for computing machine ID\n\n\nchar ch = ‘L’;\nforeach(char ch2 in Environment.MachineName)\n{\nch = (char)(ch ^ ch2);\n}\nbyte num3 = (byte)ch;\nreturn (GetVolumeSerial() ^ (uint)(((num3 + (num3 * 0x100)) + (num3 *\n0x10000)) +\n(num3 * 0x1000000)));\n\n\n#### Appendix C: Remote Commands Supported by .NET Backdoor Post Exploita- tion Tool Sample\n\npublic class RcDataCommand\n{\npublic byte channelHint;\npublic RcDataCommandId cmdID;\npublic RcDataCommandType cmdType;\npublic string extraInfo;\npublic string string_0;\n}\n\nImplemented values for cmdID are as follows:\n\n��������������������������������������������������������������\n���������������������������������\n���������������������������������������������������������\n\n\n-----\n\ncmdType can be one of the following (Interesting commands explained in detail):\n\n� ����������\n� �������������\n� ����������\n�����������\n���������������\n�������������������\n�����������������\n����������������������\n��������������������������\n�������������������������������������\n��������������������������������������\n����������������������������������������������������������������\n\n������������������������������������������������\n����������������������������������������\n���������������������������\n�����������������������������������������������������������\n�������������������������������������������������������\n\n������������������������������������\n�������������������\n�����������������������\n������������������������������������������������������\n\n����������������������������������\n�����������������������������������������������\n�����������������������������\n�����������������\n�����������������������������\n�������������������������������\n��������������������������������\n�����������������������\n��������������������\n�������������������������������\n�������������������������������\n������������������\n\n\n-----\n\nstring_0 can have one of the following values dependant upon command id and type.\n\n��������������\n���������\n������������\n�������������\n���������\n���������������\n���������\n����������\n��������\n��������������������������������������\n\n#### Appendix D: Raw bytes of example Authentication packet.\n\n03 01 74 80 82 21 b5 64 c2 74 22 e3 02 00 00 00 49 03 00 00 00 00 00 00 00 00 00 00 00\n00 00 00\n\n#### Appendix E: Initialization of KEY and IV for AES\n\n\nfor (int i = 0; i < 0x20; ++i )\n{    for (int i = 0; i < 0x20; ++i )\n{\nbuffer[i] = (byte)((i + 8) + ((byte)password[num++]));\nbuffer[i] = (byte)(buffer[i] ^ 170);\nnum = num % password.Length;\n\n\n-----\n\n#### Appendix F: Command & Control Servers\n\n\n**C2 Server**\n\n\n**Port** **Geolocation** **Whois** **Samples Used In**\n\n\n1.9.5.38\n\n\n443 Bukit\n\n\n47619fca20895abc83807321cbb80a3d\n\n\nMertajam,\n\nMaylasia\n\n\ninetnum:    1.9.0.0 1.9.255.255\nnetname:\nTMNET-AS-AP\ndescr:     Tmnet,\nTelekom Malaysia\nBhd.\ndescr:     Telekom\nMalaysia Berhad\ndescr:     44th\nFloor, Global Data\nMarketing, TM Global\ndescr:     Jalan\nPantai Baharu\ncountry:    MY\nadmin-c:    TA35AP\ntech-c:    TA35-AP\nmnt-by:    APNIC-HM\nmnt-lower:   TMNET-AP\nmnt-routes:   TMNET-AP\nstatus:     ALLOCATED PORTABLE\nremarks:    -+-+-++-+-+-+-+-+-+-+-++-++-+-+-+-+-+-+-+-+-++-+-+\nremarks:    This\nobject can only be\nupdated by APNIC\nhostmasters.\nremarks:    To\nupdate this object,\nplease contact APNIC\nremarks:    hostmasters and include\nyour organisation’s\naccount\nremarks:    name in\nthe subject line.\nremarks:    -+-+-++-+-+-+-+-+-+-+-++-++-+-+-+-+-+-+-+-+-++-+-+\nchanged:    hmchanged@apnic.net\n20100610\n\n\nsource:     APNIC\n\n\n-----\n\n**C2 Server**\n\n\n**Port** **Geolocation** **Whois** **Samples Used In**\n\n\n202.86.190.3\n\n\n80 Hong Kong inetnum:\n202.86.190.0 202.86.191.255\nnetname:    TeleOne-HK\ncountry:    HK\ndescr:     TeleOne(HK) Limited\nadmin-c:    HL13\ntech-c:    AC612-AP\nstatus:     ASSIGNED NON-PORTABLE\nchanged:    angus@edu.ctm.net\n20041122\nmnt-by:    MAINTCTM-MO\nsource:     APNIC\n\n\n2dce7fc3f52a692d8a84a0c182519133\n\nde7500fc1065a081180841f32f06a537\n\n\n#### Appendix G: Edward Sun’s kernel network hook code\n\n: [ ]NSI Module Hook : Hiding Port Under Windows Vista [ ]\n: eviloctal : 2007-7-8 20:53 : [ ]NSI Module\nHook : Hiding Port Under Windows Vista\n\n�http://rootkit.com/newsread_print.php?newsid=735\n\n(www.eviloctal.com)\n\ncardmagic writes: Windows Vista has changed alot on network module, many old\nport hiding materials are no longer usable.\nIn this post, I will share with you a simple code to hide port under Vista,hope\nit is useful for some guys .\nActually under Windows Vista, netstat.exe will call InternalGetTcpTable2 which\nis exported by Iphlpapi.dll to list all open ports,then InternalGetTcpTable2\nwill transfer control to NsiAllocateAndGetTable which is exported by nsi.dll,\n�������������������������������������������������������������������������������\nkernel mode module of NSI -- nsiproxy.sys. nsiproxy.sys is almost like a\nwrapper of netio.sys, it will then call internal subroutines of netio.sys .\nHere,we will use a relatively easy way -- “NSI Kernel Module Dispatch Routine\n�������������������������������������������������������������������������������\nis an old topic, this time,we will apply this method to nsiproxy.sys. Please\n����������������������������������������������������\nCheck the following code(Notice: I only tested it under Windows Vista RTM\n32bit):\n\n\n-----\n\n:\n///////////////////////////////////////////////////////////////////////////////\n////////\n// Filename: PortHidDemo_Vista.c\n//\n// Author: CardMagic(Edward)\n// Email: [email]sunmy1@sina.com[/email]\n����������������������������������\n//\n// Description:\n//   A Demostration Of Hiding\n����������������������������������������������������\n//  Tested Under Windows Vista Kernel Version 6000 MP (1 procs) Free x86 compatible\n//\n//\n\n#include “stdlib.h”\n#include “ntifs.h”\n\nunsigned short htons(unsigned short hostshort);\nunsigned long inet_addr(const char *name);\ntypedef unsigned long DWORD;\n\n���������������������������������\n������������������������\n\n�������������������������������������\n\n������������������������������������������������������������\n������������������������������\nPDRIVER_DISPATCH orgNsiDeviceIoControl = 0;\n\nDWORD gLocalPort=0,gLocalIp=0;\n\ntypedef struct _HP_CONTEXT\n{\nPIO_COMPLETION_ROUTINE oldIocomplete;\nPVOID oldCtx;\nBOOLEAN bShouldInvolve;\nPKPROCESS pcb;\n}HP_CONTEXT,*PHP_CONTEXT;\n\n\n-----\n\n}INTERNAL_TCP_TABLE_SUBENTRY,*PINTERNAL_TCP_TABLE_SUBENTRY;\n\ntypedef struct _INTERNAL_TCP_TABLE_ENTRY\n{\nINTERNAL_TCP_TABLE_SUBENTRY localEntry;\nINTERNAL_TCP_TABLE_SUBENTRY remoteEntry;\n\n}INTERNAL_TCP_TABLE_ENTRY,*PINTERNAL_TCP_TABLE_ENTRY;\n\ntypedef struct _NSI_STATUS_ENTRY\n{\n��������������������\n\n}NSI_STATUS_ENTRY,*PNSI_STATUS_ENTRY;\n\ntypedef struct _NSI_PARAM\n{\n//\n// Total 3CH size\n//\nDWORD UnknownParam1;\nDWORD UnknownParam2;\nDWORD UnknownParam3;\nDWORD UnknownParam4;\nDWORD UnknownParam5;\nDWORD UnknownParam6;\nPVOID lpMem;\nDWORD UnknownParam8;\nDWORD UnknownParam9;\nDWORD UnknownParam10;\nPNSI_STATUS_ENTRY lpStatus;\nDWORD UnknownParam12;\nDWORD UnknownParam13;\nDWORD UnknownParam14;\nDWORD TcpConnCount;\n}NSI_PARAM,*PNSI_PARAM;\n\nunsigned short htons(unsigned short a)\n{\nunsigned short b = a;\nb = ( b << 8 );\na = ( a >> 8 );\nreturn ( a | b );\n};\n\n\n-----\n\nunsigned long inet_addrt(const char* name)\n{\n������������\nint len = strlen(name);\nunsigned long temp_val[4];\nchar namesec[10] ;\n\n����������������������������������\n{\nmemset(namesec,0,10);\nif(&#39;.&#39; == name[i])\n{\nif(p)\nstrncpy(namesec,name+p+1,i-p);\nelse\nstrncpy(namesec,name,i);\n����������������������������������\n����������\np = i;\n}\n}\n\nstrncpy(namesec,name+p+1,i-p);\n������������������������������\n\nreturn (temp_val[0]|(temp_val[1]<<8)|(temp_val[2]<<16)|(temp_val[3]<<24));\n}\n\nNTSTATUS\nHPCompletion(\n�������������������������������������\nIN PIRP Irp,\nIN PVOID Context\n)\n{\nPIO_STACK_LOCATION irpsp = IoGetCurrentIrpStackLocation(Irp);\nPIO_STACK_LOCATION irpspNext = IoGetNextIrpStackLocation(Irp);\nPHP_CONTEXT pCtx = Context;\nPNSI_PARAM nsiParam;\nint i;\n\nif(NT_SUCCESS(Irp->IoStatus.Status))\n{\n\n\n-----\n\nnsiParam = Irp->UserBuffer;\nif(MmIsAddressValid(nsiParam->lpMem))\n{\n//\n// netstat will involve internal calls which will use\n// nsiParam structure\n//\nif( (nsiParam->UnknownParam8 == 0x38))\n{\nKAPC_STATE apcstate;\nPNSI_STATUS_ENTRY pStatusEntry = (PNSI_STATUS_ENTRY)nsiParam->lpStatus;\nPINTERNAL_TCP_TABLE_ENTRY pTcpEntry = (PINTERNAL_TCP_TABLE_ENTRY)nsiParam->lpMem;\nint nItemCnt = nsiParam->TcpConnCount;\n\nKeStackAttachProcess(pCtx->pcb,&apcstate);\n//\n//make sure we are in the context of original process\n//\nfor(i = 0;i < nItemCnt;i ++)\n{\nif((pTcpEntry[i].localEntry.dwIP == gLocalIp)&&(pTcpEntry[i].localEntry.Port == gLocalPort))\n{\n//\n//NSI will map status array entry to tcp table array entry\n//we must modify both synchronously\n//\nRtlCopyMemory(&pTcpEntry[i],&pTcpEntry[i+1],sizeof(INTERNAL_TCP_TABLE_ENTRY)*(nItemCnt-i));\nRtlCopyMemory(&pStatusEntry[i],&pStatusEntry[i+1],sizeof(NSI_STATUS_ENTRY)*(nItemCnt-i));\nnItemCnt--;\nnsiParam->TcpConnCount --;\ni--;\n}\n}\n\nKeUnstackDetachProcess(&apcstate);\n}\n}\n}\n\n\n-----\n\nirpspNext->Context = pCtx->oldCtx;\nirpspNext->CompletionRoutine = pCtx->oldIocomplete;\n\n//\n//free the fake context\n//\nExFreePool(Context);\n\nif(pCtx->bShouldInvolve)\n������������������������������������������������������������������\nelse\n{\nif (Irp->PendingReturned) {\nIoMarkIrpPending(Irp);\n}\nreturn STATUS_SUCCESS;\n}\n}\n\nNTSTATUS\n�������������������������\n������������������������������������������\nIN ULONG Attributes,\nIN PACCESS_STATE AccessState OPTIONAL,\nIN ACCESS_MASK DesiredAccess OPTIONAL,\n���������������������������������������\nIN KPROCESSOR_MODE AccessMode,\nIN OUT PVOID ParseContext OPTIONAL,\n�����������������������������\n);\n\n�������������������������������������������������\n{\nLARGE_INTEGER waittime;\n\nwaittime.QuadPart = -50*1000*1000;\n�����������������������������������������������������������������������������gNsiDeviceIoControl);\n\n//\n//delay loading driver to make it more secure\n//\n\n\n-----\n\nKeDelayExecutionThread(KernelMode,0,&waittime);\n\nreturn STATUS_SUCCESS;\n}\n\nNTSTATUS HPDummyDeviceIoControl(\n�����������������������������������������������\nIN PIRP Irp\n)\n{\nULONG   ioControlCode;\nPIO_STACK_LOCATION irpStack;\nULONG   status;\n\nirpStack = IoGetCurrentIrpStackLocation(Irp);\n\nioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;\n\nif(IOCTL_NSI_GETALLPARAM == ioControlCode)\n{\nif(irpStack->Parameters.DeviceIoControl.InputBufferLength == sizeof(NSI_\nPARAM))\n{\n//\n//only care the related I/O\n//\nPHP_CONTEXT ctx = (HP_CONTEXT*)ExAllocatePool(NonPagedPool,sizeof(HP_CONTEXT));\nctx->oldIocomplete = irpStack->CompletionRoutine;\nctx->oldCtx = irpStack->Context;\nirpStack->CompletionRoutine = HPCompletion;\nirpStack->Context = ctx;\nctx->pcb = IoGetCurrentProcess();\n\nif((irpStack->Control&SL_INVOKE_ON_SUCCESS) ==SL_INVOKE_ON_SUCCESS)\nctx->bShouldInvolve = TRUE;\nelse\nctx->bShouldInvolve = FALSE;\nirpStack->Control |= SL_INVOKE_ON_SUCCESS;\n}\n}\n\n\n-----\n\n//\n//call original I/O control routine\n//\n���������������������������������������������������\n\nreturn status;\n}\n\nNTSTATUS DriverEntry(\n����������������������������������������\nIN PUNICODE_STRING RegistryPath\n)\n{\nint i;\nNTSTATUS status;\nUNICODE_STRING uniNsiDrvName;\n\n#if DBG\n_asm int 3 //debug\n#endif\n\n����������������������������������������\n\nRtlInitUnicodeString(&uniNsiDrvName,L”\\\\Driver\\\\nsiproxy”);\n\n�������������������������������������������������������������������������������������������������������������������������������\n\nif(!NT_SUCCESS(status))\n{\nreturn STATUS_SUCCESS;\n}\n\n//\n//store the original dispatch function of NSI driver\n//\n���������������������������������������������������������������������������\n\ngLocalIp = inet_addrt(LOCALHIDEIP);\ngLocalPort = htons(LOCALHIDEPORT);\n\n\n-----\n\n//\n//hook NSI dispatch routine\n//\n������������������������������������������������������������������������������myDeviceIoControl);\n\nreturn STATUS_SUCCESS;\n}\n\n\n-----\n\n#### Appendix H: Command and Control MD5 Correlation\n\n**MD5** **Command and Control Server**\n\n\n47619fca20895abc83807321cbb80a3d\n\n2dce7fc3f52a692d8a84a0c182519133\n\nde7500fc1065a081180841f32f06a537\n\n\n1.9.5.38:443\n\n202.86.190.3:80\n\n202.86.190.3:80\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        },
        {
            "id": "99593a68-7f6e-400e-9a9f-a707f66d2e72",
            "created_at": "2022-11-23T11:07:14.353321Z",
            "updated_at": "2022-11-23T11:07:14.353321Z",
            "deleted_at": null,
            "name": "AGRO",
            "url": "https://apt.threattracking.com",
            "description": "APT Groups and Operations Spreadsheet",
            "reports": null
        },
        {
            "id": "6825b8cb-7d82-43d2-b0b0-d51c7e255b42",
            "created_at": "2023-01-06T13:46:37.642134Z",
            "updated_at": "2023-01-06T13:46:37.642134Z",
            "deleted_at": null,
            "name": "MISPGALAXY",
            "url": "https://www.misp-project.org/galaxy.html",
            "description": "MISP Galaxy Clusters",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/6po2pgedkjf4br5p7tm51go7p5g3z6g3",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2014/2014.07.07.Deep_in_Thought/AdversaryIntelligenceReport_DeepPanda_0.pdf",
        "http://cybercampaigns.net/wp-content/uploads/2013/06/Deep-Panda.pdf"
    ],
    "report_names": [
        "AdversaryIntelligenceReport_DeepPanda_0 (1)",
        "AdversaryIntelligenceReport_DeepPanda_0",
        "Deep-Panda.pdf"
    ],
    "threat_actors": [
        {
            "id": "89542ecf-606b-4913-87c5-21512f9b82b9",
            "created_at": "2022-10-25T15:50:23.681673Z",
            "updated_at": "2025-03-27T02:00:55.522794Z",
            "deleted_at": null,
            "main_name": "RTM",
            "aliases": [
                "RTM"
            ],
            "source_name": "MITRE:RTM",
            "tools": [
                "RTM"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "6a99bf81-8ed4-4233-82e2-575e4f9bf282",
            "created_at": "2022-10-25T16:07:24.137248Z",
            "updated_at": "2025-03-27T02:02:10.119569Z",
            "deleted_at": null,
            "main_name": "RTM",
            "aliases": [],
            "source_name": "ETDA:RTM",
            "tools": [
                "AtNow",
                "RTM",
                "RTM Banker",
                "Redaman"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "7a9a7873-8e41-40ae-9d06-b27c92bb54e4",
            "created_at": "2022-10-25T16:47:55.568362Z",
            "updated_at": "2025-03-27T02:05:17.264615Z",
            "deleted_at": null,
            "main_name": "BRONZE FIRESTONE",
            "aliases": [
                "C0d0s0",
                "Deep Panda ",
                "Pupa ",
                "TG-3551 ",
                "APT19 "
            ],
            "source_name": "Secureworks:BRONZE FIRESTONE",
            "tools": [
                " Alice's Rabbit Hole",
                " Briba",
                " Cobalt Strike",
                " Derusbi",
                " PlugX",
                " PoisonIvy",
                " Powershell Empire",
                " Zuguo",
                "9002"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "2f07a03f-eb1f-47c8-a8e9-a1a00f2ec253",
            "created_at": "2022-10-25T16:07:24.277669Z",
            "updated_at": "2025-03-27T02:02:10.157972Z",
            "deleted_at": null,
            "main_name": "TA428",
            "aliases": [
                "Operation LagTime IT",
                "Operation StealthyTrident",
                "ThunderCats"
            ],
            "source_name": "ETDA:TA428",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "Agent.dhwf",
                "Albaniiutas",
                "BlueTraveller",
                "Chymine",
                "Cotx RAT",
                "CoughingDown",
                "Darkmoon",
                "Destroy RAT",
                "DestroyRAT",
                "Gen:Trojan.Heur.PT",
                "Kaba",
                "Korplug",
                "LuckyBack",
                "PhantomNet",
                "PlugX",
                "Poison Ivy",
                "RedDelta",
                "RoyalRoad",
                "SManager",
                "SPIVY",
                "Sogu",
                "TIGERPLUG",
                "TManger",
                "TVT",
                "Thoper",
                "Xamtrav",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "64ca1755-3883-4173-8e0a-6e5cf92faafd",
            "created_at": "2022-10-25T15:50:23.636456Z",
            "updated_at": "2025-03-27T02:00:55.51077Z",
            "deleted_at": null,
            "main_name": "Deep Panda",
            "aliases": [
                "Deep Panda",
                "Shell Crew",
                "KungFu Kittens",
                "PinkPanther",
                "Black Vine"
            ],
            "source_name": "MITRE:Deep Panda",
            "tools": [
                "Mivast",
                "StreamEx",
                "Sakula",
                "Tasklist",
                "Derusbi"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "46a151bd-e4c2-46f9-aee9-ee6942b01098",
            "created_at": "2023-01-06T13:46:38.288168Z",
            "updated_at": "2025-03-27T02:00:02.794118Z",
            "deleted_at": null,
            "main_name": "APT19",
            "aliases": [
                "Black Vine",
                "TEMP.Avengers",
                "PinkPanther",
                "G0073",
                "KungFu Kittens",
                "Group 13",
                "Shell Crew",
                "BRONZE FIRESTONE",
                "G0009",
                "Sunshop Group",
                "DEEP PANDA",
                "Codoso"
            ],
            "source_name": "MISPGALAXY:APT19",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "0639667a-fb3f-43d9-a38c-6c123fd19c7f",
            "created_at": "2022-10-25T16:07:23.335869Z",
            "updated_at": "2025-03-27T02:02:09.743237Z",
            "deleted_at": null,
            "main_name": "APT 19",
            "aliases": [
                "APT 19",
                "Bronze Firestone",
                "C0d0so0",
                "Codoso",
                "Deep Panda",
                "Operation Kingslayer",
                "Red Pegasus",
                "Sunshop Group",
                "TG-3551"
            ],
            "source_name": "ETDA:APT 19",
            "tools": [
                "Agentemis",
                "C0d0so0",
                "Cobalt Strike",
                "CobaltStrike",
                "Derusbi",
                "EmPyre",
                "EmpireProject",
                "Fire Chili",
                "PowerShell Empire",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "c39b0fe6-5642-4717-9a05-9e94265e3e3a",
            "created_at": "2022-10-25T16:07:24.332084Z",
            "updated_at": "2025-03-27T02:02:10.175452Z",
            "deleted_at": null,
            "main_name": "Tonto Team",
            "aliases": [
                "Bronze Huntley",
                "CactusPete",
                "Earth Akhlut",
                "HartBeat",
                "Karma Panda",
                "LoneRanger",
                "Operation Bitter Biscuit",
                "TAG-74",
                "Tonto Team"
            ],
            "source_name": "ETDA:Tonto Team",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "Bioazih",
                "Bisonal",
                "CONIME",
                "Dexbia",
                "Korlia",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Mimikatz",
                "POISONPLUG.SHADOW",
                "RoyalRoad",
                "ShadowPad Winnti",
                "XShellGhost"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716492,
    "ts_updated_at": 1743041802,
    "ts_creation_date": 1361427259,
    "ts_modification_date": 1361427259,
    "files": {
        "pdf": "https://archive.orkl.eu/1d53861aafea11d9a60e798b90d623c8e7c7b9e7.pdf",
        "text": "https://archive.orkl.eu/1d53861aafea11d9a60e798b90d623c8e7c7b9e7.txt",
        "img": "https://archive.orkl.eu/1d53861aafea11d9a60e798b90d623c8e7c7b9e7.jpg"
    }
}