{
    "id": "4c126c10-33a6-4d14-ba42-95a1ea9c68fb",
    "created_at": "2023-04-05T02:10:01.253628Z",
    "updated_at": "2025-03-27T02:05:52.825708Z",
    "deleted_at": null,
    "sha1_hash": "e0b8ab5f6fd5bb28073751a42cebcc0cb30d99ad",
    "title": "2023-03-24 - Bypassing Qakbot Anti-Analysis",
    "authors": "",
    "file_creation_date": "2023-04-03T08:54:26Z",
    "file_modification_date": "2023-04-03T08:54:26Z",
    "file_size": 454688,
    "plain_text": "# Bypassing Qakbot Anti-Analysis\n\n**lab52.io/blog/bypassing-qakbot-anti-analysis-tactics/**\n\nQakBot is a banking trojan that has been evolving since its first version was discovered in\n2008. According to the 2022 report published by CISA, it was one of the most active variants\nin 2021, and during 2022 and so far in 2023 it has remained quite active. Taking a brief look\nat the latests news of QakBot it has been updating its tactics constantly, for example, using a\n[Windows zero-day to avoid displaying the MoTW or the most recent one, using](https://www.bleepingcomputer.com/news/security/new-attacks-use-windows-security-bypass-zero-day-to-drop-malware/) OneNote\nfiles to drop QakBot.\n\nIn this case we are particularly interested in the anti-analysis techniques used by QakBot\n**during the early stages of its execution. These techniques can make malware analysis**\nharder if they are not known, so learning to identify and bypass them is essential to get to\nsee the malware’s operation at its full potential. Furthermore, there are techniques that can\nreplicate / adopt different types of malware, so knowking them opens the door to the study of\ndifferent samples.\n\nThis article is structured according to the verifications carried out using the following sample,\nfocusing of those aspects that are most remarkable.\n\nmd5 58e1c32eeb0130da19625e55ee48cf1e\n\nsha1 00ae1c5066f67e5e71285de99bea8d8b67085743\n\nsha256 f5ff6dbf5206cc2db098b41f5af14303f6dc43e36c5ec02604a50d5cfecf4790\n\nThe following image summarizes the checks performed by QakBot before executing its\npayload. This article is structured following this chain of checks, which corresponds to the\nanti-analysis techniques used by the sample.\n\n\n-----\n\nAnti-analyis checks performed\n\nby Qakbot\n\n## Windows Defender\n\nAt the beginning of the program execution, QakBot will perform a first inevitable check since\nthis sample is intended for Windows systems: to verify if Windows Defender is active.\nQakBot will perform this check by searching for representative files.\n\n_llustration 1 Call to the first_\n\n_check function_\nInside the function we can observe a mov to the EAX register and then a call to a function\nused recurrently during the whole execution of the program. This function has been renamed\nto mw_decode since its objective is to decode text strings, taking the EAX register as\nparameter and performing the XOR operation.\n\n\n-----\n\n_Illustration 2 Call to mw_decode_\n\n_Illustration 3 mw_decode_\n\n_content_\nAfter performing all iterations of the loop, the decrypted string is visible when looking at the\naddress of the ECX register. During all the checks performed by QakBot, this behavior can\nbe seen.\n\nIn this case, the string refers to Windows Defender, since it is part of the empty files created\nby this utility.\n\n\n-----\n\n_Illustration 4 Decrypted string related to_\n\n_Windows Defender: C:\\INTERNAL\\_empty_\n\nFrom here, taking the value C:\\INTERNAL\\_empty as a parameter, it makes a call to the\nfunction GetFileAttributesA of the Windows API. Then, checks if this file already exists in the\nsystem.\n\nThis check is made to know if Windows Defender is present in the system, since the file\nC:\\INTERNAL_empty is part of the files that Windows Defender creates.\n\n_Illustration 5 Call to GetFileAttributesA with representative string_\nIn case, after making the API call, it detects that the Windows Defender-related file is present\nin the system, the sample execution will be stopped. Otherwise, QakBot will continue with its\nexecution, to continue with the checks.\n\n## Representative processes in execution\n\n\n-----\n\nThe next check is on the system processes. The main objective is to evaluate if there is any\nsecurity application that can be used to detect or to anlyse malware, such as antivirus\napplications or applications used by reserarchers, or in sandboxes. In order to do so, Qakbot\nanalyses the list of process and compares it with known representative names of processes.\n\nThe first thing Qakbot will do is to load several hexadecimal values.\n\n_Illustration 6 Loading values in hexadecimal_\n\nAs mentioned before, mw_decode will continue to be used to decode the strings used by\nthe malware, so the hexadecimal value 0x621, seen before at the start of the function, is\nsaved in the EAX register.\n\n_Illustration 7 Call to mw_decode with value 0x621_\n\n_entered as a parameter_\nAfter calling the function in charge of decrypting the strings, it will start a loop to obtain all the\nprocesses names for which it will check their existence in the system.\n\nFor example, the following image shows a list of processes subject to check with the names:\navgcsrvx.exe, avgsvcx.exe and avgcsrva.exe. These are representative processes of AVG\nFree Antivirus.\n\n\n-----\n\n_Illustration 8 Some names of processes that will be checked_\nOnce it has the strings to check, to obtain the first running process in the system it proceeds\nwith calls to the CreateToolhelp32Snapshot and Process32First functions.\n\n_Illustration 9 Calls to_\n\n_CreatToolhelp32Snapshot and Process32First_\nQakbot then checks if the processes names obtained above match any currently active\nprocess in the system.\n\n\n-----\n\n_Illustration 10 Iteration to compare processes names_\nIt will perform this operation with all the processes, if any of them is equal to the ones it has\ndefined, it will terminate the execution. In particular, the following processes names have\nbeen found to be subject to analysis. They are ordered with relation to the type of application\nin the following table.\n\n**Type** **Name of process**\n\nAntivirus Avgcsrvx.exe Avgsvcx.exe Avgcsrva.exe ccSvcHst.exe MsMpEng.exe\nmcshield.exe Avp.exe kavtray.exe Egui.exe ekrn.exe Bdagent.exe\nVsserv.exe vsservppl.exe AvastSvc.exe coreServiceShell.exe\nPccNTMon.exe NTRTScan.exe SAVAdminService.exe SavService.exe\nfshoster32.exe WRSA.exe Vkise.exe Isesrv.exe cmdagent.exe\nByteFence.exe MBAMService.exe mbamgui.exe fmon.exe Dwengine.exe\nDwarkdaemon.exe dwwatcher.exe bds-vision-agent-nai.exe bds-visionapis.exe bds-vision-agent-app.exe\n\n\nMalware\nAnalysis\n\nVirtualization\nEnvironments\n\n\nFiddler.exe lordpe.exe regshot.exe Autoruns.exe Dsniff.exe\nHashMyFiles.exe ProcessHacker.exe Procmon.exe Procmon64.exe\nNetmon.exe pr0c3xp.exe ProcessHacker.exe CFF Explorer.exe\ndumpcap.exe Wireshark.exe idaq.exe Idaq64.exe ResourceHacker.exe\nMultiAnalysis_v1.0.294.exe x32dbg.exe Tcpview.exe OLLYDBG.EXE\nwindbg.exe samp1e.exe sample.exe runsample.exe\n\nVBoxTray.exe vmtoolsd.exe vm3dservice.exe VGAuthService.exe\nTPAutoConnect.exe vmacthlp.exe VBoxTray.exe VboxService.exe\n\n\nAs anticipated, this point groups together checks involving both user protection and analysis\ntools. It is to be expected that successive versions of QakBot will update the previous list.\n\nIf QakBot does not find any process with the above names, it continues its execution with the\nnext check.\n\n## Modules\n\n\n-----\n\nIf it passes the above check, it will make use of the Module32First and Module32Next APIs\nto get all the modules for each of the processes in the system.\n\n_Illustration 11 Use of Module32First_\nIf any of the system modules contain the string ivm-inject.dll or SbieDll.dll it will terminate\nits execution.\n\n_Illustration 12 String ivm-inject.dll_\n\n_Illustration 13 String SbieDll.dll_\n\n\n-----\n\n[The names of the DLLs have been identified as part of the Sandboxie program, used to run](https://sandboxie-plus.com/sandboxie/)\nprograms in isolated environments. If any program uses these modules, it could be an\nindication that this analysis tool is on the system, and QakBot would stop its execution.\n\nIt is worth noting, for example, that the [Sandboxie-Plus version could incorporate utilities to](https://github.com/sandboxie-plus/Sandboxie)\nhide the presence of SbieDll.dll.\n\n## Characteristic names given to the sample\n\nAnalysts have some habits that QakBot will check. In this case, it will check if in the name of\nthe binary itself (the malware) is present any of the characteristic strings that could be used\nby analysts to rename the sample, before its execution, such as “sample”, “mlwr_sm”,\n“artifact.exe”. Again, these strings will be observed after the execution of mw_decode.\n\n_Illustration 14_\n\n_String sample_\nIf any of these strings are found as part of the filename, it will stop the execution of the\nprogram. In addition, this check is not case-sensitive, i.e. it does not distinguish between\nupper and lower case.\n\nIt is curious, for example, that it does not also check that the name of the binary may\ncorrespond to a sha256 pattern, since samples downloaded from platforms such as\nVirusTotal or other systems retain in their name the hash of the binary, which the analyst may\nor may not rename.\n\n## Anti-VM Techniques\n\nQakBot performs specific checks to determine if it is running in a virtual environment. These\nchecks are described below.\n\n## VMware version\n\nThe malware will evaluate whether it is running within a VMWare virtual machine. To do that,\nQakBot will make use of a special VMWare I/O port. In particular, the verification at this point\nfocuses on the port used by the official VMWare tools to perform the communications.\n\nVMWare uses I/O port 0x5658 to communicate internally with the deployed virtual machines,\nso the first step executed by QakBot is to save in the DX register the value corresponding to\n\n\n-----\n\nthe I/O port. After this step, the value 0x564D5868 is stored in EAX. This value corresponds\nto the string ‘VMXh‘, which is the VMWare magic number.\n\nFinally, the internal VMWare command is specified. In this case 0x0A is used, which\ncorresponds to the command to obtain information from VMWare.\n\n_Illustration 15 Check_\n\n_code: VMware_\nAfter performing the “in” instruction, the EBX and ECX registers will be modified.\n\nIn the EBX register the magic number of Vmware will be written, while in the ECX register\nthe value corresponding to VMWare products will be stored. The following values are known:\n\n– 01h = Express\n\n– 02h = ESX Server\n\n– 03h = GSX Server\n\n– 04h = Workstation\n\n## RAM memory size\n\nIf the previous check is passed, QakBot proceeds to obtain the size of the memory allocated\nto the system. This check is performed, like the previous check, using the I/O port, but in this\ncase it uses the value 0x14 as the command. The resulting value will be stored in the EAX\nregister, to later perform a move to EBP. It is important to note that, if the previous check\ndoes not detect that it is running in a VM and passes to this check, here it makes again use\nof the I/O port, which would be a contradiction.\n\n\n-----\n\n_Illustration 16 Check_\n\n_code: PC memory_\nQakBot will decide if it is inside a VM at this point by comparing the value stored in the EBP\nregister, which contains the size of the machine’s RAM, against the value 0x2000, which is\nequivalent to 8192 in decimal. It means that, if the machine has less than 8 Gbytes of RAM,\nQakBot will decide that it is in a virtual machine.\n\n_Illustration 17_\n\n_RAM size check_\nNote that QakBot only performs this check if it has previously detected that it is not running in\na virtual machine using the VMWare I/O port. However, it is curious that the malware uses\nthe VMWare I/O port again during this check, as it should not be able to obtain a valid RAM\nvalue when it is not running in a VMWare environment.\n\n## CPU Characteristics\n\nFor the last check QakBot will make use of the cpuid instruction. This instruction returns\ndifferent values based on the value stored in EAX. In this case an EAX xor operation is\nperformed on EAX, which results in a 0 always.\n\n\n-----\n\n_Illustration 18 cpuid_\n\n_instruction_\nWhen cpuid has a 0 as EAX value, it returns the CPU manufacturer, which is precisely the\ntarget pursued by the malware in this step. Then, it performs three memcpy operations to\nreorder the resulting string.\n\n_Illustration 19 memcpy instructions_\n\nAfter the operations the final string will correspond to the CPU manufacturer of the system.\n\nOnce it has obtained this data, it moves the value 1 to EAX to call cpuid again. When cpuid\nis called with EAX value 1, this operation returns the processor information.\n\n_Illustration 20 Processor_\n\n_information request_\nThe information received in ECX after the execution of the cpuid instruction will always end\nwith a value of 0 in the case of a physical machine, but in the case of a virtual machine it will\nbe 1.\n\nIt should be noted at this point that for both VMware and VirtualBox system execution a\nvalue of 3 is received, so that for both platforms it would be possible to bypass this check.\n\n\n-----\n\n_Illustration 21_\n\n_Return value for VMware_\n\n## Conclusions\n\nThis analysis has focused on the anti-analysis capabilities employed by QakBot in order to\nhelp overcome these obstacles before starting the analysis. The anti-analysis techniques\ndetailed here can be used by different malware, so it is very important to be aware of them.\nHowever, it is important to note that this analysis is based on a specific sample of QakBot\nmalware, and there are various other families of malware that employ different anti-analysis\ntechniques that have not been covered in this report. These techniques may be explored in\nfuture posts.\n\nRegarding the analysis performed, it is also interesting to highlight the checks made by\nQakbot to detect if it is under a virtualized environment, as these checks only applyies to\nVMWare software when using VMWare’s own I/O port, and searching by its unique magic\nnumber.\n\n## References\n\n[VMware Backdoor I/O Port](https://sites.google.com/site/chitchatvmback/backdoor)\n\n[CPUID instruction reference](https://c9x.me/x86/html/file_module_x86_id_45.html)\n\n[Windows Defender DB dump and VDLL’s](https://www.kernelmode.info/forum/viewtopiccf27.html?f=13&t=5496)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-03-24 - Bypassing Qakbot Anti-Analysis.pdf"
    ],
    "report_names": [
        "2023-03-24 - Bypassing Qakbot Anti-Analysis.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1680660601,
    "ts_updated_at": 1743041152,
    "ts_creation_date": 1680512066,
    "ts_modification_date": 1680512066,
    "files": {
        "pdf": "https://archive.orkl.eu/e0b8ab5f6fd5bb28073751a42cebcc0cb30d99ad.pdf",
        "text": "https://archive.orkl.eu/e0b8ab5f6fd5bb28073751a42cebcc0cb30d99ad.txt",
        "img": "https://archive.orkl.eu/e0b8ab5f6fd5bb28073751a42cebcc0cb30d99ad.jpg"
    }
}