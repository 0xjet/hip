{
    "id": "1bf32b40-2f7e-46ca-aa0c-1f38a9c31bbc",
    "created_at": "2023-01-12T15:00:17.502356Z",
    "updated_at": "2025-03-27T02:05:22.260328Z",
    "deleted_at": null,
    "sha1_hash": "ac5464892417832a6dbdfffb8e89b75c06709243",
    "title": "2010-11-12 - ZEROACCESS MALWARE - PART 1- De-Obfuscating and Reversing the User-Mode Agent Dropper",
    "authors": "",
    "file_creation_date": "2022-05-27T21:47:12Z",
    "file_modification_date": "2022-05-27T21:47:12Z",
    "file_size": 2365917,
    "plain_text": "# De-obfuscating and reversing the user-mode agent dropper\n\n**resources.infosecinstitute.com/step-by-step-tutorial-on-reverse-engineering-malware-the-zeroaccessmaxsmiscer-**\ncrimeware-rootkit/\n\nReverse engineering\nNovember 12, 2010 by Giuseppe Bonfa\n\n**Part 1: Introduction and De-Obfuscating and Reversing the User-Mode Agent Dropper**\n\n## Summary\n\nThis four part article series is a complete step-by-step tutorial on how to reverse engineer the\nZeroAccess Rootkit. ZeroAcess is also known as the Smiscer or Max++ rootkit. You can\neither read along to gain an in-depth understand the thought process behind reverse\nengineering modern malware of this sophistication. The author prefers that you download the\nvarious tools mentioned within and reverse the rookit yourself as you read the article.\n\nIf you would like to use the malware sample used in these articles, download it here:\n\n[download]\n\n\n-----\n\nInfoSec Institute would classify ZeroAccess as a sophisticated, advanced rootkit. It has 4\nmain components that we will reverse in great detail in this series of articles. ZeroAccess is a\ncompartmentalized crimeware rootkit that serves as a platform for installing various malicious\nprograms onto victim computers. It also supports features to make itself and the installed\nmalicious programs impossible for power-users to remove and very difficult security experts\nto forensically analyze.\n\nAt the conclusion of the analysis, we will trace the criminal origins of the ZeroAccess rootkit.\nWe will discover that the purpose of this rootkit is to set up a stealthy, undetectable and unremovable platform to deliver malicious software to victim computers. We will also see that\nZeroAccess is being currently used to deliver FakeAntivirus crimeware applications that trick\nusers into paying $70 to remove the “antivirus”. It could be used to deliver any malicious\napplication, such as one that steals bank and credit card information in the future. Further\nanalysis and network forensics supports that ZeroAccess is being hosted and originates from\nthe Ecatel Network, which is controlled by the cybercrime syndicate RBN (Russian Business\nNetwork).\n\nSymantec reports that 250,000+ computers have been infected with this rootkit. If 100% of\nusers pay the $70 removal fee, it would net a total of $17,500,000. As it is not likely that\n100% of users will pay the fee, assuming that perhaps 30% will, resulting $5,250,000 in\nrevenue for the RBN cybercrime syndicate.\n\nIt has the following capabilities:\n\nModern persistence hooks into the OS – Make it very difficult to remove without\ndamaging the host OS\nAbility to use a low level API calls to carve out new disk volumes totally hidden from the\ninfected victim, making traditional disk forensics impossible or difficult.\nSophisticated and stealthy modification of resident system drivers to allow for kernelmode delivery of malicious code\nAdvanced Antivirus bypassing mechanisms.\nAnti Forensic Technology – ZeroAccess uses low level disk and filesystem calls to\ndefeat popular disk and in-memory forensics tools\nServes as a stealthy platform for the retrieval and installation of other malicious\ncrimeware programs\nKernel level monitoring via Asynchronous Procedure Calls of all user-space and kernelspace processes and images, and ability to seamlessly inject code into any monitored\nimage\n\nIn this tutorial, our analysis will follow the natural execution flow for a new infection. This will\nresult in a detailed chronology of the infection methodology and “workflow” that the rootkit\nuses to infect hosts. This conceptual workflow is repeated in many other advanced rootkit\nthat have been analyzed, so it behooves you to understand this process and therefore be\nable to apply it to new malware reversing situations.\n\n\n-----\n\nUsually, when a rootkit infects a host, the workflow is structured as follows:\n\nInfection vector allows for rootkit agent reaches victim’s system. (Drive-by-download,\nclient side exploit or a dropper)\nUser-mode agent execution\nDriver executable decryption and execution\nSystem hiding from Kernel-mode.\nEstablishment on the host and Kernel-mode level monitoring/data-stealing.\nSending of stolen data in a covert data channel.\n\nOur analysis of ZeroAccess is split into a series of articles:\n\nPart 1: Introduction and De-Obfuscating and Reversing the User-Mode Agent Dropper\n\nPart 2: Reverse Engineering the Kernel-Mode Device Driver Stealth Rootkit\n\nPart 3: Reverse Engineering the Kernel-Mode Device Driver Process Injection Rootkit\n\nPart 4: Tracing the Crimeware Origins of ZeroAccess Rootkit by Reversing the Injected Code\n\nOur analysis starts from analyzing the User-mode Agent and finishes at Kernel-mode where\nthe rootkit drops two malicious device drivers.\n\n## Step-by-step analysis\n\nThe ZeroAccess rootkit comes in the form of a malicious executable that delivered via\ninfected Drive by Download Approach. Drive-by download means three things, each\nconcerning the unintended download of computer software from the Internet:\n\n1. Downloads which a person authorized but without understanding the consequences\n\n(e.g. downloads which install an unknown or counterfeit executable program, ActiveX\ncomponent, or Java applet).\n2. Any download that happens without a person’s knowledge.\n3. Download of spyware, a computer virus or any kind of malware that happens without a\n\nperson’s knowledge.\n\nDrive-by downloads may happen when visiting a website, viewing an e-mail message or by\nclicking on a deceptive pop-up window by clicking on the window in the mistaken belief that,\nfor instance, an error report from the computer itself is being acknowledged, or that an\ninnocuous advertisement pop-up is being dismissed. In such cases, the “supplier” may claim\nthat the person “consented” to the download although actually unaware of having started an\nunwanted or malicious software download. Websites that exploit the Windows Metafile\nvulnerability may provide examples of drive-by downloads of this sort.\n\nZeroAccess has some powerful rootkit capabilities, such as:\n\n\n-----\n\nAnti FileSystem forensics by modifying and infecting critical system drivers (disk.sys,\natapi.sys) as well as PIC driver object stealing and IRP Hooking.\nInfecting of System Drivers.\nUser-mode Process Creation interception and DLL Injection, from KernelMode.\nDLL Hiding and Antivirus bypassing.\nExtremely resistant to Infection Removal.\n\n**Part 1: Reverse engineering the user-mode agent/dropper**\n\nThe rootkit is obfuscated via a custom packed executable typically called ‘Max++ downloader\ninstall_2010.exe’. The hashes for this file are:\n\nMD5: d8f6566c5f9caa795204a40b3aaaafa2\n\nSHA1: d0b7cd496387883b265d649e811641f743502c41\n\nSHA256: d22425d964751152471cca7e8166cc9e03c1a4a2e8846f18b665bb3d350873db\n\nBasic analysis of this executable shows the following PE sections and imports:\n\nSections: .text .rdata .rsrc\n\nImports: COMCTL32.dll\n\nThe Import Table is left in a very poor condition for analysis. Typically this means that\nadditional and necessary functions will be imported at Run Time. Let’s now check the Entry\nPoint Code:\n\nThe start code is pretty standard, except for an interesting particular, as you can see at\n00413BD5 we have an int 2Dh instruction.\n\nThe interrupt 2Dh instruction is mechanism used by Windows Kernel mode debugging\nsupport to access the debugging interface. When int 2Dh is called, system creates an\nEXCEPTION_RECORD structure with an exception code of STATUS_BREAKPOINT as well\nas other specific informations. This exeception is processed by calling KiDebugRoutine.\n\n\n-----\n\nInt 2Dh is used by ntoskrnl.exe to interact with DebugServices but we can use it also in usermode. If we try to use it in normal (not a debugged) application, we will get exception.\nHowever if we will attach debugger, there will be no exception.\n\n(You can read more about this at the OpenRCE reference library\nhttp://www.openrce.org/reference_library/anti_reversing_view/34/INT%202D%20Debugger%\n20Detection/ )\n\nWhen int 2Dh is called we get our first taste of ZeroAccess anti-reversing and code\nobsfuction functionality. The system will skip one byte after the interrupt, leading to opcode\nscission. The actual instructions executed will differ from the apparent instructions that will be\ndisplayed in a dissasembler or debugger.\n\nTo continue further we need a mechanism to correctly handle int 2Dh call and mantain the\njump-one-byte feature, and allow us to follow the opcode-splitted code. To do so, we are\ngoing to use StrongOD Olly plugin which can be downloaded here:\n[http://reversengineering.wordpress.com/2010/07/26/strongod-0-3-4-639/](http://reversengineering.wordpress.com/2010/07/26/strongod-0-3-4-639/)\n\nWith StrongOD installed, after tracing over int 2Dh we are presenting with the following\ninstructions:\n\nThe most interesting instruction for us here is the Call 00413bb4. Immediately after this\ninstruction we have garbage code. Let’s enter into this call, and you are now presented with\nthe following code block:\n\n\n-----\n\nAgain, we see int 2Dh, which will lead us one byte after the RETN instruction. The next piece\nof code will decrypt the adjacent routine, after tracing further, finally we land here:\n\nThis call will decrypt another block of code, at after that call execution jump here:\n\nFS:[18] corresponds to TEB (Thread Environment Block) address, from TEB is obtained PEB\n(Process Environment Block) which is located at TEB Address + 30h.\n\nPEB+0C corresponds to PPEB_LDR_DATA LdrData.\n\nIf you are using WinDBG, you can use this quick hint to uncover the link between structure ->\noffset ->involved member by issuing the following command:\n\n0:004> dt nt!_PEB_LDR_DATA\nntdll!_PEB_LDR_DATA\n\n\n-----\n\n+0x000 Length      : Uint4B\n+0x004 Initialized   : UChar\n+0x008 SsHandle     : Ptr32 Void\n+0x00c InLoadOrderModuleList : _LIST_ENTRY\n+0x014 InMemoryOrderModuleList : _LIST_ENTRY\n+0x01c InInitializationOrderModuleList : _LIST_ENTRY\n+0x024 EntryInProgress : Ptr32 Void\n+0x028 ShutdownInProgress : UChar\n+0x02c ShutdownThreadId : Ptr32 Void\n\nAs you can see, the malicious code refers to _PEB_LDR_DATA + 1Ch, by checking the\noutput of WinDbg you can see that ECX now points to InInitializationOrderModuleList. The\ncode that follows is responsible for locating Import Function addresses and then from this\ninformation building an ImportTable on the fly dynamically. Next there is a complex sequence\nof nested calls that have the principal aim of decrypting, layer by layer, the core routines of\nZeroAccess. We will not describe the analysis of this piece of multi-layer code; it is left as an\nexercise for the reader. This section of code is quite long, repetitive, and frankly boring, and\nnot relevant from a functionality point of view.\n\nImported Function addresses are successively protected and will be decrypted on fly only\nwhen they are called. Let’s take a look at how an API call actually looks:\n\nCall 00401172 decrypts and return the API’s address in EAX. In the above code snippet, the\nAPI called is VirtualAlloc. Allocated memory will be used in future execution paths to decrypt\na number of different blocks of instructions. These blocks will eventually constitute an\nexecutable dropped by the original infection agent.\n\nMain executable ( the infection vector we are also referring to as the Agent) builds and drops\nvarious files into victim’s hard disk and as well as in memory. Whether on disk or in memory,\nthe pattern used is always the same:\n\n\n-----\n\nNext, let’s try to determine what is being decrypted in these blocks. We place a breakpoint at\n0040162B, which is immediately after Next Block jump. The end of the Next Block\ncorresponds to the end of decryption process, we will see in allocated memory the familiar\n‘MZ’ signature, letting us know the executable is ready to be used. Before proceding we\nrecommending dumping onto the the hard drive the full executable using the Backup\nfunctionality of Ollydbg.\n\nThe next block of code is protected with a VEH ( Vectored Exception Handler ) by using\nRtlAddVectoredExceptionHandler and RtlRemoveVectoredExceptionHandler. Inside this\nblock we have a truly important piece of code. This block is loaded via the undocumented\nnative API call, LdrLoadDll. A system DLL is called, lz32.dll, as well as the creation of a\nSection Object.\n\n\n-----\n\nA Section Object represents a section of memory that can be shared. A process can use a\nsection object to share parts of its memory address space (memory sections) with other\nprocesses. Section objects also provide the mechanism by which a process can map a file\ninto its memory address space.\n\nTake a look at the red rectangle, calling the value 003C24FB stored in EAX. As you can see\nthis belongs to the previously loaded lz32.dll. Because of this call, execution flow jumps\ninside the lz32.dll, and which contains malicious code decrypted by the rootkit agent.\n\nThis is what the code of lz32.dll program looks like:\n\nIf we trace into the Call 003C23DB, we have a long routine that completes infection, and\nmore precisely we have the kernel mode component installation phase. We will see a series\nof creative routines specifically written to elude classic Antivirus checks, such as the usage\nof Section Objects and Views placed into System Files.\n\nNow, let’s take a look at the core routine of the Agent, which we will analyze piece by piece:\n\n\n-----\n\nDuring the analysis of complex pieces of malware it’s a good practice to leave open the\nHandleView and ModuleView panes within OllyDbg. This will help you keep track of what is\nloaded/unloaded and what files/objects/threads/etc. are opened. Let’s see what happens in\nCall 003C1C2C at address 003C2461.\n\nAt first, we see the enumeration of Drivers placed into system32drivers, and next we have\nthe following piece of code:\n\n\n-----\n\nWe have an interesting algorithm here, after driver enumeration a random number is\ngenerated, next fitted within a range of [0 – 0xFF] and used to randomly select from the\ndriver list a file to be infected. Finally the string formatted as:\n\n**._driver_name_**\n\nNow let’s watch what is going on in HandleView:\n\n\n-----\n\nAs you can see a Section Object is created according to the randomly selected driver file,\nand next will be opened as View inside this Section.\n\nThe access values for this section are set to 0xF001F. Let’s first talk about why this is\nimportant. During a malware analysis session, much like a forensic investigation, is\nfundamental to know what the access potential the various components have, so we can\ndirect our investigation down the right path. This can be determined by checking the access\nrights assigned to various handles.\n\nLet’s lookup what the access right of 0xF001F corresponds by looking in winnt.h:\n\n**#define SECTION_ALL_ACCESS 0xf001f**\n\nSECTION_ALL_ACCESS means the handle has the ability to Read, Write, Query and\nExecute. This is the optimal environment to place a malicious portion of code. Now, lets\nanalyze further:\n\n\n-----\n\nThis block of code takes the driver previously selected and now registers it into:\n\nregistryMACHINESYSTEMCurrentControlSetservices\n\nThe services entry under CurrentControlSet contains parameters for the device drivers, file\nsystem drivers, and Win32 service drivers. For each Service, there is a subkey with the\nname of the service itself. Our registry entry will be named ._driver_name_\n\nStart Type has 0x3 value that means -> Load on Demand\n\nType: 0x1 -> Kernel Device Driver\n\nImage Path -> *\n\n\n-----\n\nThe same driver is always opened. Next, its handle used to send, via ZwFsControlCode, a\nFSCTL (File System Control Code). Taking a look at the API parameters at run time reveals\nthat the FSCTL code is 9C040. This code corresponds to FSCTL_SET_COMPRESSION. It\nsets the compression state of a file or directory on a volume whose file system supports perfile and per-directory compression.\n\nNext, a new executable will be built with the aforementioned decryption scheme and then\nloaded via ZwLoadDriver. This process will result in two device drivers:\n\n1. The first driver is unnamed and will perform IRP Hooking and Object and\n\ndisk.sys/pci.sys Object Stealing (we will analyze this in greater detail later)\n2. The second driver, named B48DADF8.sys, is process creation aware and contains a\n\nnovel DLL injection system (we will also analyze it greater detail later)\n\nOnce the driver infection is complete we land in an interesting piece of code:\n\nHere, we see the loading of fmifs.dll. This DLL is the Format Manager for Installable File\nSystems, and it offers a set of functions for FileSystem Management.\n\nIn this case the exported function is FormatEx. A bit of documentation on FormatEx follows:\n\nVOID\nSTDCALL\nFormatEx(\nPWCHAR    DriveRoot,\nDWORD    MediaFlag,\nPWCHAR Format,\nPWCHAR    Label,\nBOOL    QuickFormat,\nDWORD    ClusterSize,\nPFMIFSCALLBACK  Callback\n);\n\n\n-----\n\nThis function, as the name suggests is used to Format Volumes. In our case the DriverRoot\nis ?C2CAD972#4079#4fd3#A68D#AD34CC121074 and Format is NTFS. This is a\nremarkable feature unique to this rootkit. This call creates a hidden volume, and the volume\nwill contain the driver and DLLs dropped by the ZeroAccess Agent. These files remain totally\ninvisible to the victim (something we teach in our ethical hacking course).\n\nThe next step the Agent takes is to build, with the same decryption routine previously\ndescribed, the remaining malicious executables that will be stored into the newly created\nhidden volume. These two files are:\n\nB48DADF8.sys\nmax++.00,x86.dll\n\nBoth located into the hidden volume, ?C2CAD972#4079#4fd3#A68D#AD34CC121074L. We\nnow we have a good knowledge of what user-mode side of ZeroAccess does, we can focus\nour attention to Kernel Mode side, by reversing the two drivers and dropped DLL.\n\nLet’s continue to follow the workflow of the rootkit. If you are reversing along with us, analysis\nwill logically follow the order of binaries dropped by the Agent. Our first driver to reverse will\nbe the randomly named one, which will be in Part 2 of this tutorial.\n\nPosted: November 12, 2010\n\nAuthor\n\n**Giuseppe Bonfa**\n\n**VIEW PROFILE**\nGiuseppe is a security researcher for InfoSec Institute and a seasoned InfoSec professional\nin reverse-engineering and development with 10 years of experience under the Windows\nplatforms. He is currently deeply focused on Malware Reversing (Hostile Code and Extreme\nPackers) especially Rootkit Technology and Windows Internals. He has previously worked as\nMalware Analyst for Comodo Security Solutions as a member of the most known Reverse\nEngineering Teams and is currently a consultant for private customers in the field of Device\nDriver Development, Malware Analysis and Development of Custom Tools for Digital\nForensics. He collaborates with Malware Intelligence and Threat Investigation organizations\nand has even discovered vulnerabilities in PGP and Avast Antivirus Device Drivers. As a\ntechnical author, Giuseppe has over 10 years of experience and hundreds of published\npieces of research.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2010/2010-11-12 - ZEROACCESS MALWARE - PART 1- De-Obfuscating and Reversing the User-Mode Agent Dropper.pdf"
    ],
    "report_names": [
        "2010-11-12 - ZEROACCESS MALWARE - PART 1- De-Obfuscating and Reversing the User-Mode Agent Dropper.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535617,
    "ts_updated_at": 1743041122,
    "ts_creation_date": 1653688032,
    "ts_modification_date": 1653688032,
    "files": {
        "pdf": "https://archive.orkl.eu/ac5464892417832a6dbdfffb8e89b75c06709243.pdf",
        "text": "https://archive.orkl.eu/ac5464892417832a6dbdfffb8e89b75c06709243.txt",
        "img": "https://archive.orkl.eu/ac5464892417832a6dbdfffb8e89b75c06709243.jpg"
    }
}