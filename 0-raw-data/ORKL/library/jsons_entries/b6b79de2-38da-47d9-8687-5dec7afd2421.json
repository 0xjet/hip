{
    "id": "b6b79de2-38da-47d9-8687-5dec7afd2421",
    "created_at": "2023-02-02T02:07:28.896627Z",
    "updated_at": "2025-03-27T02:06:15.763538Z",
    "deleted_at": null,
    "sha1_hash": "91e85686e4a0625530efdd8837b4cf82037c6a0a",
    "title": "2023-01-26 - Unpacking Emotet Malware",
    "authors": "",
    "file_creation_date": "2023-02-01T07:54:21Z",
    "file_modification_date": "2023-02-01T07:54:21Z",
    "file_size": 236443,
    "plain_text": "# Emotet Unpacking:. Writer: Ilan Duhin | by Ilan Duhin | Jan, 2023\n\n**medium.com/@Ilandu/emotet-unpacking-35bbe2980cfb**\n\nIlan Duhin January 26, 2023\n\n[Ilan Duhin](https://medium.com/@Ilandu?source=post_page-----35bbe2980cfb--------------------------------)\n\nJan 26\n\n\n5 min read\n\n## Emotet Unpacking:\n\nWriter: Ilan Duhin\n\n## Executive Summary:\n\nEmotet is an advanced, self-propagating and modular Trojan. Emotet was once a banking\nTrojan, but recently has been used as a downloader for other malware or malicious\ncampaigns. It uses multiple methods for maintaining persistence and Evasion techniques\n**like packing. In addition, it can be spread through phishing spam emails containing**\nmalicious attachments or links.\n\n\n-----\n\nEmotet uses a number of malicious techniques when he locates on the victim s computer\nsuch as: allocating memory for process injection, and creating new processes/threads\n**to make persistence.**\n\nStarting with x32dbg & Running our sample until the Entry point.\n\nWe should now search for API call of VirtualAlloc (we saw earlier the allocation memory on\nprocess hacker in the dynamic investigation).\n\nSo we need to search in the debugger (Ctrl + G)=VirtualAlloc and press OK so we can put\n**BP on her and see which arguments contain the original code.**\n\nWhen we get to the beginning of the function, our goal is to see the “ret” that describe the\nend of the function so we can put BP.\n\nTo see the end we need to press Enter.\n\nNow we put BP. To make sure that the BP is set we can look at Breakpoint tab.\n\nNow Debug & Run + Step over (F8) the function (the debugger take now us to the original\ncode).\n\nWhen we press step over we jump to the next function below. But if we scroll up one\n**function we see that the register edi store the VirtualAlloc function.**\n\nIn situations like this when we found the call that contains our function we need to check the\narguments that it pushes into it for searching our MZ Header.\n\nThe two arguments we see between the “calls” that used by the function to push them into\nher are: [esp+28] & [esp+2C].\n\nNow we need to check there hex values of unpacked code by clicking “follow in dump”. The\n**first check is empty (we don’t see any clue about MZ Header).**\n\n**Also the second one.**\n\nIn this situation when we don’t find any hex values of unpacked code we need to Run +\n**Step over one more time to search for more functions call of VirtualAlloc so we can search**\nthere if they have arguments that contain the original unpacked code.\n\nSo when we Run again we jumped to the ret 10 instruction again.\n\n**When we press (F8) — step over we jump into the function that calls ebp register that**\ncontains VirtualAlloc function and a number of arguments we need to explore.\n\nSimilar to the first arguments, here we have another one: [edi+54].\n\n\n-----\n\nClick follow in dump and let s see the results. When we scroll up we see that the hex strings\nlooks like executable with description of “This program cannot run in DOS mode”, it is\nperfect for us because every PE header starts like this. Now what is left to find out is\n**where the MZ.**\n\nLittle bit scrolling up and we see the MZ Header that is probably the unpacked code!\n\nIn this stage of analysis (after finding the unpacked code) we should go to Memory map\nTAB to locate the specific address that contains Execute permissions and dump her into\n**new file.**\n\nTo do this, right click on the hex values table & “follow in memory map”.\n\nIts automatically points us to the address that the malware doing it executable capabilities.\n\nAll we have left to do is dump the address of unpacked code into new file like I said earlier.\n\nTo do this, right click on memory address & “Dump memory to file”.\n\nThe most fun part for me in unpacking is when you drag the unpacked file into HxD and\nclean all the beginning before the MZ.\n\nFirst, we search the MZ string with Ctrl+F, when we locate him, we erase all strings before\nhim so we can save it into a cleaned PE File.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-01-26 - Unpacking Emotet Malware.pdf"
    ],
    "report_names": [
        "2023-01-26 - Unpacking Emotet Malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1675303648,
    "ts_updated_at": 1743041175,
    "ts_creation_date": 1675238061,
    "ts_modification_date": 1675238061,
    "files": {
        "pdf": "https://archive.orkl.eu/91e85686e4a0625530efdd8837b4cf82037c6a0a.pdf",
        "text": "https://archive.orkl.eu/91e85686e4a0625530efdd8837b4cf82037c6a0a.txt",
        "img": "https://archive.orkl.eu/91e85686e4a0625530efdd8837b4cf82037c6a0a.jpg"
    }
}