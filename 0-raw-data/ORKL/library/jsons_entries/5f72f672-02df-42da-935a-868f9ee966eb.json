{
    "id": "5f72f672-02df-42da-935a-868f9ee966eb",
    "created_at": "2022-10-27T08:36:05.654978Z",
    "updated_at": "2025-03-27T02:06:05.576425Z",
    "deleted_at": null,
    "sha1_hash": "3cc09f8a97bd7a3159425f9d900ec9730ecb35d6",
    "title": "API Deobfuscator: Identifying Original Function by Iterative Run-until-API Method",
    "authors": "",
    "file_creation_date": "2015-07-21T14:25:17Z",
    "file_modification_date": "2015-07-21T14:25:17Z",
    "file_size": 3039112,
    "plain_text": "|Col1|Col2|Col3|Col4|Col5|Col6|Col7|Col8|Col9|Col10|\n|---|---|---|---|---|---|---|---|---|---|\n|||||||||||\n\n\n-----\n\n### • Introduction\n • API Deobfuscation Method\n\n#### • Memory Access Analysis for Dynamic\n Obfuscation\n • Iterative Run-until API method for Static\n Obfuscation\n\n### • Implementation\n • Demo\n • Conclusion\n\n\n-----\n\n### • Malwares hide functionalities by API\n obfuscation\n\n#### • Commercial packers obfuscate API functions\n • Malware authors have their own API obfuscator\n\n### • No deobfuscation tools for some modern\n packers\n\n#### • x64 packers\n • Custom packers\n\n\n-----\n\n## modern packers\n\n### • Dynamic API Obfuscation\n\n#### • API functions are obfuscated during runtime\n • Instructions and addresses changes every run\n\n###### Branch into a newly allocated block during execution time (obfuscated User32.dll :MessageBox)\n\n\n-----\n\n## modern packers\n\n### • Static API Obfuscation \n\n#### • API functions are obfuscated compile(packing)\n time\n • Instructions and addresses are the same\n\n###### Branch into other section\n\n ……\n\n API Call by ‘ret’ instruction\n\n\n-----\n\n### • After deobfuscation, we have\n\n#### • (Near) original entry point\n • Recovered API function calls at OEP\n\n### • With the deobfuscated image, we can do\n\n#### • Static analysis with disassembled and\n decompiled code\n • Dynamic analysis with debuggers\n\n\n-----\n\n### • How to deobfuscate API obfuscated\n binaries?\n\n#### • Dynamic API Obfuscation\n\n#####  Memory Access Analysis\n\n#### • Static API Obfuscation\n\n#####  Iterative Run-until-API Method\n\n### • How to evade anti-debugging?\n\n#### • Dynamic binary instrumentation (Intel Pin)\n • Anti-anti-debugger plugin in debuggers\n • Emulators\n\n\n-----\n\n|Col1|Col2|Col3|Col4|Col5|Col6|Col7|Col8|Col9|\n|---|---|---|---|---|---|---|---|---|\n||||||||||\n\n\n-----\n\n## for Dynamic Obfuscators\n\n### • Memory Access Analysis\n\n#### • Relate memory reads on API function code and\n corresponding memory writes on obfuscated code\n\n##### • Instruction addresses of obfuscated API function\n  Original API function\n\n#### • Recover original API function by the obfuscated\n call target address\n\n\n-----\n\n### • What happens during runtime obfuscation?\n\n#### • Runtime obfuscator reads each function,\n obfuscates each instruction, writes the obfuscated code into a newly allocated memory\n • Each function is obfuscated in sequence\n\n###### Writing\n Writing Reading\n Reading obfuscated\n obfuscated Ws2_32.\n Ws2_32.bind Ws2_32.\n Ws2_32.bind connect\n connect\n\n\n-----\n\n### • How can we identify the original API function?\n\n#### • Record every memory write before the next API\n function or DLL reads\n • Limit the number of memory write for the last\n API function\n\n###### Write Addresses before  next API function reads\n\n Obfuscated Function Instruction Addresses\n\n Obfuscated API call target\n address\n\n\n-----\n\n### • Find OEP\n\n#### • Record every memory write and execute\n • OEP is the Last written address that is executed\n • Check written memory blocks (1 block = 4\n Kbytes) to save memory\n • OEP is in the original executable file sections\n\n###### Unpacked Execution address\n Packed Unpacked\n instruction Of written blocks\n Section Section\n is written\n\n Additional Additional\n Unpack code is\n Section by Section by\n executed\n\n\n-----\n\n### • Search for intermodular calls at OEP by\n pattern matching\n\n#### • Matched patterns may contain false positives\n • After target address resolution, misinterpreted\n instruction disappears\n\n\n-----\n\n### • Direct call resolution\n\n#### • If the call targets are in the constructed map\n from obfuscated addresses to API function, modify call targets to the original API function address\n • Generate a text file that contains resolved API\n function calls and OEP\n\n\n-----\n\n### • Indirect call resolution\n\n#### • Original segments (.text, .idata, …) are merged\n into one segment by packing\n • Identify a memory block that contains\n successive obfuscated API function addresses\n • Modify obfuscated call addresses in the IAT\n candidate with the original API function\n\n\n-----\n\n### • Example: API Deobufscation Information\n\n\n-----\n\n### • Generating a debugger script to resolve API\n calls\n\n#### • The text file generated by the memory access\n analyzer contains OEP, resolved obfuscated addresses\n • Implemented a python script to generate a\n debugger script that execute until OEP and resolve obfuscated addresses\n\n\n-----\n\n### • Debugging x86 binary with Ollydbg after\n running deobfuscation script\n\n\n-----\n\n### • Decompiled code with dumped file\n\n\n-----\n\n|Col1|Col2|Col3|Col4|Col5|Col6|Col7|Col8|Col9|\n|---|---|---|---|---|---|---|---|---|\n||||||||||\n\n|Col1|Col2|Col3|Col4|Col5|\n|---|---|---|---|---|\n||||||\n\n\n-----\n\n## for Static Obfuscators\n\n### • Static obfuscation pattern at OEP\n\n#### • Obfuscated call pattern\n\n##### • “Call qword ptr [___]” is changed into\n “Call rel32” when obfuscated\n\n#### • Obfuscated call run into API function\n\n##### • Stack shape is preserved\n • API call instruction and the first few instructions in\n the API function are obfuscated\n • After executing obufscated instructions, execution\n reaches an instruction in the original API function\n\n\n-----\n\n### • Search obfuscated call by pattern\n\n#### • CALL rel32 – is a candidate\n • Check whether the address is in another section\n of the process\n\n###### Call rel32; db 00 ‘00’ after call break alignment so thataA few incorrect disassembled code occur\n\n ……\n\n\n-----\n\n### • Obfuscated code is executed until API\n function\n • Run-until-API method\n\n#### • Change RIP into candidate API call address\n • Run until API function\n\n###### Obfuscated Call Start\n\n ……\n\n\n-----\n\n### • Integrity check\n\n#### • We need to check whether the stack pointer\n and the stack content is preserved after executing obfuscate call\n\n###### Check Stack Pointer\n\n Check Stack & Return Address\n\n\n-----\n\n### • Apply run-until API method repeatedly on\n candidate obfuscated calls\n\n#### • Save context & Restore\n\n###### ….\n\n\n-----\n\n### • Iterative run-until-API method can be applied\n to various packers\n\n#### • VMP: API function call is virtualization-\n obfuscated\n • Themida64: API function call is mutated\n • Obsidium: The first few instructions in an API\n function are obfuscated\n • Custom packers\n • But, at last, execution is redirected into a real\n API function\n\n\n-----\n\n### • Debugging x64 binary with x64DBG after\n deobfuscation\n\n\n-----\n\n### • Dumping x86/64 binary and static analysis\n with IDA Pro\n\n###### IAT recovered\n\n\n-----\n\n-----\n\n### • Pin tool to resolve API Address\n\n#### • Windows 8.1/7 – 32/64 bit (on VMWare)\n • Visual Studio 2013\n • Intel Pin 2.14\n\n### • Python script to patch obfuscated call\n • Reversing tools\n\n#### • X64dbg\n • IDA\n\n\n-----\n\n###### dumped\n dbg\n API info exe file\n script\n Debugging\n Debugger Static\n API with\n script Analysis\n Resolver x64dbg &\n Generator with IDA Pro\n Olly\n\n\n-----\n\n-----\n\n# API Deobfuscator\n\n### • Packed 32/64 bit samples\n • Commercial packer packed 32bit malware\n\n\n-----\n\n|Col1|Col2|Col3|Col4|Col5|\n|---|---|---|---|---|\n||||||\n\n\n-----\n\n### • Suggested two methods for API\n deobfuscatoin\n\n#### • Memory access analysis for dynamic\n obfuscation\n • Run-until-API method for static obfuscation\n\n### • Commercial packer protected binary can be\n analyzed using API deobfuscator\n\n#### • Using debugger\n • Using disassembler & decompiler\n\n\n-----\n\n### • Depending on DBI tools\n\n#### • Packers can detect DBI tools\n\n##### • Defeating the transparency feature of DBI (BH US’14) \n • Ex) Obsidium detect Intel Pin as a debugger\n\n#### • DBI tools crash in some applications\n\n### • Static whole function obfuscated code\n cannot be deobfuscated\n\n#### • No instructions in the original API function is\n executed when the whole function is obfuscated\n\n\n-----\n\n### • Anti-anti-debugging\n\n#### • Building x86/64 emulator for unpacking\n\n### • API function resolution\n\n#### • Code optimization and binary diffing for static\n whole function obfuscation\n • Backward dependence analysis for custom\n packers\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://www.blackhat.com/docs/us-15/materials/us-15-Choi-API-Deobfuscator-Resolving-Obfuscated-API-Functions-In-Modern-Packers.pdf"
    ],
    "report_names": [
        "us-15-Choi-API-Deobfuscator-Resolving-Obfuscated-API-Functions-In-Modern-Packers.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1666859765,
    "ts_updated_at": 1743041165,
    "ts_creation_date": 1437488717,
    "ts_modification_date": 1437488717,
    "files": {
        "pdf": "https://archive.orkl.eu/3cc09f8a97bd7a3159425f9d900ec9730ecb35d6.pdf",
        "text": "https://archive.orkl.eu/3cc09f8a97bd7a3159425f9d900ec9730ecb35d6.txt",
        "img": "https://archive.orkl.eu/3cc09f8a97bd7a3159425f9d900ec9730ecb35d6.jpg"
    }
}