{
    "id": "e12b3912-aa1b-4aa1-8bb9-9ced795bb7e3",
    "created_at": "2023-01-12T15:10:38.446382Z",
    "updated_at": "2025-03-27T02:05:53.199045Z",
    "deleted_at": null,
    "sha1_hash": "0ebd8899b5ff51a90d89c7c41b08f17d463e0b2d",
    "title": "2015-09-29 - Andromeda Bot Analysis part 1",
    "authors": "",
    "file_creation_date": "2022-05-28T00:37:30Z",
    "file_modification_date": "2022-05-28T00:37:30Z",
    "file_size": 1226926,
    "plain_text": "# Andromeda Bot Analysis part 1\n\n**[resources.infosecinstitute.com/andromeda-bot-analysis/](http://resources.infosecinstitute.com/andromeda-bot-analysis/)**\n\nMalware analysis\nSeptember 25, 2015 by Ayoub Faouzi\n\n## Introduction:\n\nAndromeda, also known as Win32/Gamarue, is an HTTP based botnet. It was first spotted in\nlate 2011, and is still at this moment used a lot in herding. It has also been observed that this\ntreat is also dropping other malwares like ZeuS, Torpig and Fareit.\n\nThis article will shed some light on the inner working of the last variant of this botnet, how\nmalwares keep changing their structure in order to evade automatic analysis systems, and to\nfrustrate the malware analysts. The loader has both anti-VM and anti-debug features. It will\ninject into trusted processes to hide itself. It has some persistence techniques. The\ninteraction between its twin injected malicious processes and its communication protocol with\nthe command and control server is encrypted.\n\nSimilar to known bots such as ZeuS, Andromeda is also a modular, which means it supports\na plug-in interface system and can incorporate various modules, such as:\n\nKeyloggers\n\n\n-----\n\nForm grabbers\nSOCKS4 proxy module\nRootkits\n\nApart from that, the main code simply consists of a loader, which provides some default\nfeatures. It can download and execute other executable/DLLs, as well as update and delete\nitself if needed.\n\nTypically, variants of the Andromeda malware can be bought online for $300-500 US via an\nunderground forum. Prices vary depending on the version of the botnet, and on how much is\nthe customer willing to spend on the different modules that come with it. The most recent\nversion number I have identified is version 2.09.\n\n## Sales thread:\n\nHere is a screenshot of the command and control administration panel:\n\n\n-----\n\nThe infection vector arrives via a familiar means: from spammed emails with malicious\nattachments to exploit kits such as Sweet Orange or Blackhole hosted in hacked websites\npushing Andromeda and also from other malwares dropping this threat.\n\n## Tools and Downloads:\n\n1. OllyDBG / IDA Pro / PETools / Process Explorer.\n2. Sample and unpacked sample\n\n[download]\n\n## Unpacking:\n\nThe sample we are analyzing here is firstly packed with come custom packer. Let’s unpack it\nfirst to get the original file. In general, you can easily recognize if a file is packed:\n\nby looking at the import table; the program you will have few imports and particularly if\nthe only imports are LoadLibrary and GetProcAddress ;\n\nno readable strings and high entropy ;\n\na big portion of code is inside the .data section ;\n\nThe program has abnormal section sizes, such as a .text section with a SizeofRawData\nof 0 and VirtualSize of nonzero and also the section names themselves may indicate a\nparticular packer.\n\n\n-----\n\nYou could unpack a file simply by tracing the entire unpacking stub until you find a JMP\nbecause you know at some point it must transfer execution to the Original Entry Point (OEP),\nor making a hardware breakpoint at ESP register change (or PUSHAD, POPAD trick), or\nsometimes using the exceptions generated by the packer.\n\nOf course, unpacking varies depending on the complexity of the packer. Sometimes the\nalgorithm of unpacking is well obfuscated and has many anti-debug and anti-trace tricks. For\nexample, the API has been redirected, the packer uses multithreading, some bytes at the\nentry point has been stolen, or the PE header has been removed, etc.\n\nIn the malware analysis field, there is an approach that works in most of time, PE\npackers/crypters compress or encrypt the PE sections or some other data using some\ncompression / encryption algorithms like LZMA. Before running the actual malicious code,\nthe packer would need to decompress the compressed code. To do this usually it allocates\nsome space using VirtualAlloc, VirtualAllocEx, or ZwAllocateVirtualMemory. Then it will\ndecompress the data to the allocated memory. We can set breakpoint on these APIs.\n\nThen, the imports are fixed so the malware can use the imported API’s. To resolve the import\naddresses it will use the API’ GetProcAddress/LoadLibrary or dynamically with\nPEB_LDR_DATA structure. You will see that GetProcAddress would be called repeatedly in\nthe loop. This loop is used to resolve the entire API’s in the DLL. We can set a breakpoint on\nthese APIs as well and bypass the loop to continue debugging.\n\nLet’s just load the sample in OllyDBG and BP on VirtualAlloc:\n\nAfter the BP is hit, run until return (CTRL+F9), then F8, note down the return address which\nis for me 00390000. This is memory space allocated for the code, which is supposed to be\nwritten. Afterwards, scroll down and continue debugging until you see:\n\n**001287F1 65:FF20 JMP DWORD PTR GS:[EAX]**\n\n\n-----\n\nPut a BP at PUSH DS and at Virtual Address (VA) 00390000, and make sure in the OllyDBG\noption that you are ignoring custom exceptions range from 00000000 to FFFFFFFF because\n**JMP DWORD PTR GS:[EAX]**\n\nwill actually generate an exception or patch this instruction to JMP 00390000 then SHIFT +\nF9.\n\nThen you land here:\n\nThen, you will see after the stack frame the instructions that look for the PEB (Process\n[Environment Block), the PEB is pointed to by the TIB (Thread Information Block), which is](http://en.wikipedia.org/wiki/Win32_Thread_Information_Block)\nalways located at FS:[0]. One of the PEB entries is a pointer to a structure called\nPEB_LDR_DATA. This structure contains information about all of the loaded modules in the\ncurrent process. At offset 0x1C of PEB_LDR_DATA is the pointer of\nInInitializationOrderModuleList along the link list of InIntializationOrderModuleList where you\ncan find the loaded DLL. This packer is looking for kernel32.dll. After you find kernel32.dll,\noffset 0x08 holds the base address of kernel32.dll in memory, offset 0x3C is the PE header\nof kernel32.dll and finally offset 0x78 of PE header is the pointer to export function address\ntable.\n\n\n-----\n\nGiven the pointer to the EAT, you will get inside a loop that parses the EAT to look for\nGetProcAddress function address. This API will be used alongside with LoadLibrary to\nresolve dynamically API addresses.\n\nAfter stepping through this code, you will see several MOV instructions that copy by byte the\nnames of APIs the packer is looking for: TerminateThread, GetCurrentThreadId,\n_GetCurrentThread, LoadLibraryA, CreateProcessA, ExitProcess, ResumeThread,_\n_SetThreadContext, GetThreadContext, WriteProcessMemory; VirtualAllocEx,_\n_ZwUnmapViewOfSection, GetModuleHandleA:_\n\nContinue stepping until:\n\n**003907F7 FFD3 CALL EBX ; kernel32.VirtualAlloc**\n\nOr just hit F9 (run), you will get the call to VirtualAlloc which will return for me 003A0000.\nNote down the dwSize, which is 3600. This is the location of where our file will get unpacked.\nContinue tracing until you see:\n\n\n-----\n\nAfter stepping through the whole routine of decompression, you will see the ‘MZ’ magic\nappearing in the beginning of our VA. Note down the VA and the size.\n\nAfter tracing further in the code, you will see the resolution of some APIs. Do these APIs ring\na bell?\n\nIndeed, it’s a typical RunPE packer more known as “VBInject” or “VBCrypt” in the AV\nindustry. The main difference compared to traditional packers that overwrite their own\nprocess’ memory is that the packed executable spawns a new process in which it injects the\nactual malicious PE binary. It may re-launch itself as a new process or lunch a new hallowed\nversion of an innocent application like svchost.exe. The purpose of this technique is to evade\nAV detection, all RunPE work about the same way:\n\nUnpack or decrypt the original EXE file in memory.\nCall CreateProcess on a target EXE using the CREATE_SUSPENDED flag. This maps\nthe executable into memory and it’s ready to execute, but the entry point hasn’t\nexecuted yet.\nNext, Call GetThreadContext on the main thread of the newly created process. The\nreturned thread context will have the state of all general-purpose registers. The EBX\nregister holds a pointer to the Process Environment Block (PEB), and the EAX register\nholds a pointer to the entry point of the innocent application. In the PEB structure, at an\noffset of eight bytes, is the base address of the process image.\nCall [NtUnmapViewOfSection to unmap and free up the virtual address space used by](http://msdn.microsoft.com/en-us/library/ff557711%28VS.85%29.aspx)\nthe new process,\nCall [VirtualAllocEx to re-allocate the memory in the process’ address space to the](http://msdn.microsoft.com/en-us/library/aa366890%28VS.85%29.aspx)\ncorrect size (the size of the new EXE)\nCall [WriteProcessMemory to write the PE headers and each section of the new EXE](http://msdn.microsoft.com/en-us/library/ms681674%28VS.85%29.aspx)\n(unpacked in Step 1) to the virtual address location they expect to be (calling\n[VirtualProtextEx to set the protection flags that each section needs).](http://msdn.microsoft.com/en-us/library/aa366899%28VS.85%29.aspx)\n\n\n-----\n\nThe loader writes the new base address into the PEB and calls SetThreadContext to point\nEAX to the new entry point.\n\nFinally, the loader resumes the main thread of the target process with ResumeThread and\nthe windows PE loader will do its magic. The executable is now mapped into memory without\never touching the disk.\n\nIf you are interested in how this technique is implemented, here is a C++ version of it:\n\n\n-----\n\n```\ntypedef LONG (WINAPI NtUnmapViewOfSection)(HANDLE ProcessHandle, PVOID\nBaseAddress);\nclass runPE{\npublic:\nvoid run(LPSTR szFilePath, PVOID pFile) \n{\nPIMAGE_DOS_HEADER IDH;   \nPIMAGE_NT_HEADERS INH;   \nPIMAGE_SECTION_HEADER ISH; \nPROCESS_INFORMATION PI;  \nSTARTUPINFOA SI;      \nPCONTEXT CTX;       \nPDWORD dwImageBase;    \nNtUnmapViewOfSection xNtUnmapViewOfSection;\nLPVOID pImageBase;     \nint Count;         \nIDH = PIMAGE_DOS_HEADER(pFile);\nif (IDH->e_magic == IMAGE_DOS_SIGNATURE)\n{\nINH = PIMAGE_NT_HEADERS(DWORD(pFile) + IDH->e_lfanew);\nif (INH->Signature == IMAGE_NT_SIGNATURE)\n{\nRtlZeroMemory(&SI, sizeof(SI));\nRtlZeroMemory(&PI, sizeof(PI));\nif (CreateProcessA(szFilePath, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL,\n&SI, &PI))\n{\nCTX = PCONTEXT(VirtualAlloc(NULL, sizeof(CTX), MEM_COMMIT, PAGE_READWRITE));\nCTX->ContextFlags = CONTEXT_FULL;\nif (GetThreadContext(PI.hThread, LPCONTEXT(CTX)))\n{\nReadProcessMemory(PI.hProcess, LPCVOID(CTX->Ebx + 8), LPVOID(&dwImageBase), 4, NULL);\nif (DWORD(dwImageBase) == INH->OptionalHeader.ImageBase)\n{\nxNtUnmapViewOfSection =\nNtUnmapViewOfSection(GetProcAddress(GetModuleHandleA(\"ntdll.dll\"),\n\"NtUnmapViewOfSection\"));\nxNtUnmapViewOfSection(PI.hProcess, PVOID(dwImageBase));\n}\npImageBase = VirtualAllocEx(PI.hProcess, LPVOID(INH->OptionalHeader.ImageBase), INH>OptionalHeader.SizeOfImage, 0x3000, PAGE_EXECUTE_READWRITE);\nif (pImageBase)\n{\nWriteProcessMemory(PI.hProcess, pImageBase, pFile, INH->OptionalHeader.SizeOfHeaders,\nNULL);\nfor (Count = 0; Count < INH->FileHeader.NumberOfSections; Count++)\n{\nISH = PIMAGE_SECTION_HEADER(DWORD(pFile) + IDH->e_lfanew + 248 + (Count * 40));\nWriteProcessMemory(PI.hProcess, LPVOID(DWORD(pImageBase) + ISH->VirtualAddress),\nLPVOID(DWORD(pFile) + ISH->PointerToRawData), ISH->SizeOfRawData, NULL);\n}\nWriteProcessMemory(PI.hProcess, LPVOID(CTX->Ebx + 8), LPVOID(&INH>OptionalHeader.ImageBase), 4, NULL);\nCTX->Eax = DWORD(pImageBase) + INH->OptionalHeader.AddressOfEntryPoint;\nSetThreadContext(PI.hThread, LPCONTEXT(CTX));\n\n```\n\n-----\n\n```\nResumeThread(PI.hThread);\n}\n}\n}\n}\n}\nVirtualFree(pFile, 0, MEM_RELEASE);\n}\n};\n\n```\nThe weaknesses of RunPE should be obvious to anyone: At some point, the loader has to\ndecrypt the executable in the loader’s memory space. Furthermore, the original executable\nwill be mapped in the target process’ memory space in a readable state; you can easily\ndump the executable into a file.\n\nNow that you know the correct API functions to break on, you can get to the actual\nunpacking. Sometimes the malware, to lunch a new process, it might call\nCreateProcessInternal instead of CreateProcess, or to write to the new section, it might call\nZwWriteVirtualMemory instead of WriteProcessMemory rendering your breakpoint in that API\nuseless.\n\nHence, you should always break on the ntdll functions if it’s possible, to make sure the\nmalware doesn’t operate on a lower level than you do or another option is to place a BP on\nLoadLibraryA and GetProcAddress to know which functions are being used. Additionally,\nanother very common thing between all RunPE malware is the call the ZwResumeThread\nfunction at the final step, thus putting a BP on it worth trying.\n\nTherefore, you can just place a breakpoint at ZwResumeThread, wait until the execution\nbreaks there, attach to the spawned process, set a breakpoint at the entry point of the\nsuspended thread and resume it. The execution then pauses at the entry point and you can\ndump the process memory using some debugger plugin like OllyDump or a separate tool.\nYou could see the injection in Process Explorer:\n\nOn the other hand, what I will do is just dumping the code out of the packer process after it\nhas been decrypted. Remember VA 003A0000 and size 0x3600? I am using PETools to\nperform a partial dump:\n\n\n-----\n\nPosted: September 25, 2015\n\nAuthor\n\n**Ayoub Faouzi**\n\n**VIEW PROFILE**\nAyoub Faouzi is interested to computer viruses and reverse engineering, In the first hand, he\nlikes to study PE packers and protectors, and write security tools. In the other hand, he\nenjoys coding in python and assembly.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2015/2015-09-29 - Andromeda Bot Analysis part 1.pdf"
    ],
    "report_names": [
        "2015-09-29 - Andromeda Bot Analysis part 1.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536238,
    "ts_updated_at": 1743041153,
    "ts_creation_date": 1653698250,
    "ts_modification_date": 1653698250,
    "files": {
        "pdf": "https://archive.orkl.eu/0ebd8899b5ff51a90d89c7c41b08f17d463e0b2d.pdf",
        "text": "https://archive.orkl.eu/0ebd8899b5ff51a90d89c7c41b08f17d463e0b2d.txt",
        "img": "https://archive.orkl.eu/0ebd8899b5ff51a90d89c7c41b08f17d463e0b2d.jpg"
    }
}