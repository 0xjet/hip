{
    "id": "269e1556-97c5-4fad-a3b7-88239593f8b0",
    "created_at": "2023-01-12T15:06:51.954137Z",
    "updated_at": "2025-03-27T02:16:37.070334Z",
    "deleted_at": null,
    "sha1_hash": "0c714e9f22cae7f8bfafe65e98bb2627d1f78f45",
    "title": "2018-12-01 - Tracking Mirai Variants (Ya Liu & Hui Wang)",
    "authors": "",
    "file_creation_date": "2022-05-28T15:17:15Z",
    "file_modification_date": "2022-05-28T15:17:15Z",
    "file_size": 2432658,
    "plain_text": "# VB2018 paper: Tracking Mirai variants\n\n**virusbulletin.com/virusbulletin/2018/12/vb2018-paper-tracking-mirai-variants/**\n\n### Ya Liu & Hui Wang\n\nQihoo 360 Technology, China\n\n_Copyright © 2018 Virus Bulletin_\n\nTable of contents\n\nAbstract\n\n1. Introduction\n\n2. Data extraction\n\n2.1 Configurations\n\n2.1.1 table_init() analyser\n\n2.1.2 resolve_cnc_addr() analyser\n\n2.2 Supported attack methods\n\n2.2.1 Fingerprinting attack functions\n\n2.3 Dictionary of usernames/passwords\n\n3. Variant classification and tracking\n\n3.1 Configuration-based schemes\n\n3.1.1 Clustering based on configuration count and size\n\n3.1.2 Clustering based on encryption key\n\n3.2 Attack-method-based schemes\n\n3.2.1 Combination of supported attack methods\n\n4. Typical variants analysis\n\n4.1 MASUTA\n\n4.2 OWARI\n\n4.3 WICKED\n\n5. Conclusion\n\nReferences\n\nAppendix A: Sample SHA256 hashes\n\nAppendix B: Signature of attack methods\n\nAppendix C: All recognized combinations of {attack_method_code, attack_type}\n\n## Abstract\n\nMirai, the infamous DDoS botnet family known for its great destructive power, was made open source soon after being found by\n_MalwareMustDie in August 2016, which led to a proliferation of Mirai variant botnets. Since then, the authors have continuously_\nupdated their code (e.g. adding new types of exploits and attack methods), which has added to the difficulty of detecting and mitigating\nMirai-related threats. To solve that problem we present a set of Mirai variant classification and tracking schemes developed during the\nprocess of analysing over 32,000 Mirai samples. In this paper we will introduce:\n\n1. How to extract data including configurations, supported attack methods, and dictionaries of usernames and passwords from\n\nsamples.\n2. How to use the extracted data to classify and track Mirai variants.\n\nTo demonstrate the effectiveness of our solutions, popular Mirai branches are investigated under the proposed schemes.\n\n## 1. Introduction\n\nMirai became well known in Autumn 2016 for overwhelming several high-profile targets including Krebs on Security, OVH and Dyn\nthrough DDoS attacks. Mirai overtook previous Linux DDoS botnet families (e.g. Gafgyt, Tsunami) in its capacity to infect hundreds of\nthousands of IoT devices in a short period of time, and to provide versatile attack method options. The Mirai source code was released\nsoon after having been found by MalwareMustDie. Inspired by the success of Mirai and the released source code, other bot\nmasters/underground groups soon began to establish their own versions of Mirai botnets, which has caused a proliferation of IoT\n\n\n-----\n\nbotnets over the past 1.5 years. While some of the new botnets only borrowed ideas or code from Mirai (e.g. Hajime [1], Reaper [2]),\nmost of them are exact Mirai descendants [3, 4, 5]. In the post-Mirai era, it should be routine work for security researchers to fight Mirailike threats.\n\nCurrently, it is usual for Mirai variants to be classified with their branch names, which come from the command line ‘/bin/busybox\n<branch >’ found in the Mirai sample. While the default name is ‘MIRAI’, in later variants the ‘branch’ is usually replaced with an authorchosen name (e.g. MASUTA, SATORI, SORA, as shown in Table 1). However, we feel that such a classification scheme is too coarsegrained, and it cannot reveal the variances across variants.\n\n**Branch name** **Sample count**\n\nJOSHO 1,444\n\nOWARI 702\n\nMASUTA 438\n\nCult 434\n\nSORA 400\n\ndaddyl33t 343\n\nMIORI 244\n\nWICKED 128\n\ndwickedgod 125\n\nEXTENDO 100\n\nTable 1: Top 10 new Mirai branches in the past 1.5 years based on their sample count.\n\nOur Mirai tracking work started soon after the malware was first blogged about by MalwareMustDie in August 2016 [6]. Between then\nand May 2018, over 32,000 Mirai samples were collected, from which dozens of variants and 1,000+ C&Cs have been detected.\nAccording to our experience, automatic schemes to classify and track the proliferated variants must be able to do the following:\n\n1. Extract the C&C information.\n2. Figure out the supported attack methods, since Mirai is mainly DDoS attack purposed.\n3. Provide clues for correlating variants and C&Cs, and if possible, help to investigate the actors behind the attacks.\n\nIn this paper, we will introduce our Mirai variant classification and tracking schemes which mainly make use of the data relating to\nconfigurations, supported attack methods and credential dictionaries. The remainder of this paper is organized as follows: in Section 2,\nwe introduce how to extract data including configurations, supported attack methods and attack method fingerprints automatically from\nsamples; in Section 3, we introduce a set of schemes including variant clustering and classification using the extracted data; in Section\n4 we use our proposed schemes to investigate some typical Mirai branches.\n\nTo summarize, the contributions of this paper are as follows:\n\nWe demonstrate solutions for automatically extracting configurations, supported attack methods and credential dictionaries from\nMirai samples.\nWe propose a fingerprint technique that can be used to recognize Mirai attack methods with the information extracted from binary\ncode without the need for reverse engineering work.\nWe summarize the Mirai variants and introduce a set of classification schemes based on the extracted data.\nWe investigate popular Mirai branches with our proposed schemes.\n\nSince it’s common for Mirai botnet authors to compile the same code into binaries for different processors (e.g. x86, x64, ARM, MIPS,\nSPARC, PowerPC), for reasons of simplicity and efficiency, we chose to consider only the subset of samples for x86 and ARM in this\npaper. We believe these two kinds of samples are sufficient to study the Mirai variants due to the redundancy introduced by the ‘onesource-to-multiple-processors’ style of compilation. On the other hand, this paper mainly focuses on Mirai variants with DDoS attack\nmethods, and pays little attention to non-DDoS ones (e.g. Sartori.miner).\n\nThe SHA256 hashes for the samples discussed in this paper are given in Appendix A.\n\n## 2. Data extraction\n\n|Branch name|Sample count|\n|---|---|\n|JOSHO|1,444|\n|OWARI|702|\n|MASUTA|438|\n|Cult|434|\n|SORA|400|\n|daddyl33t|343|\n|MIORI|244|\n|WICKED|128|\n|dwickedgod|125|\n|EXTENDO|100|\n\n\n-----\n\nIt s thought that malware variant classification and tracking is a classical, yet difficult problem. There is no industrial standard on that.\nThe de facto method is to make use of sample information including special code snippets, binary byte sequences or strings, calling\nfunction graphs, and size, etc. In this paper, we simplify the problem by limiting the used data to the following four kinds:\n\n1. Plaintext configurations, together with the encryption algorithm and key.\n2. The C&C domain/IP and port. While originally stored in the configuration database, this information is now usually hard coded in a\n\nfunction named resolve_cnc_addr().\n3. The supported attack methods and their corresponding command codes.\n4. The dictionary of username/password pairs used in the scan module, if it exists.\n\nAll the data is extracted in an automated manner. Since the data is stored in a distributed manner in the samples (rather than all being\nin the same place), it’s difficult to extract all the required data with a single solution. Meanwhile, due to the ‘one-source-to-multipleprocessors’ code compilation, solutions must be able to deal with different processor architectures. Our final solution is composed of\nfour separate analyser programs, each of which includes a static and a dynamic analysis part. The static analysis is done with\nIDAPython to make use of IDA’s multiple processor supporting feature, while the dynamic analysis is based on a proprietary lightweight\nemulation framework which is designed to emulate binary code snippets of interest (e.g. an instruction block). The open-source\nemulator Unicorn [7] is used as the core engine to support common processor architectures including\nx86/x64/ARM/MIPS/PowerPC/SPARC. Both ELF and PE formats are supported.\n\n### 2.1 Configurations\n\nIn Mirai, a self-defined database is designed to store most of the running parameters which we call configurations. The database has\nthe following characteristics:\n\n1. Each item is uniquely indexed with a number which is usually less than 256.\n2. Configurations are encrypted.\n3. Configuration is referenced in a pattern of ‘decrypt->retrieve->re-encrypt’.\n\nA completely extracted configuration database can be seen in Figure 1.\n\nFigure 1: A\n\nsuccessfully extracted configuration database (md5 = 0ae272306d313c6abf1433b85e0a2352).\n\nThe first line holds the summary information, while the left lines correspond to individual configuration items. In this example the C&C\nport has an index number of 1, as indicated by ‘idx_port=1’ in the first line, which points to the item ‘[0x01]: “\\x059”, size=2’. The C&C\nport of 0x539 (a.k.a. 1337) is calculated from the item content of ‘\\x059’.\n\nBasically, configuration extraction can be divided into two steps: (1) extracting the indexes and cipher texts of all items; (2) deciphering\nthem with a self-implemented decryption program. Our analysis of the source shows that the database is initialized in a function called\ntable_init(), as shown in Figure 2.\n\n\n-----\n\nFigure 2: The\n\ntable_init() function in source.\n\nIn table_init(), it’s the function named ‘add_entry()’ that is called repeatedly to install the individual items. In each call to add_entry(),\nthree parameters are passed which individually represent: item index, ciphertext address, and size. A new memory block will be\nallocated inside add_entry() to store the cipher text, then it will be saved to a slot allocated from a global structure named ‘table’. The\nslot position is determined with the following formula:\n```\nitem_addr=table_addr +item_id*tbl_item_size\n\n```\nUnder 32-bit CPU architecture, the tbl_item_size always holds a value of 8, while its value is 16 for 64-bit CPU architectures.\n\nIn the original versions, both the C&C domain/IP and port are stored in the configuration database, which makes it possible to recover\nall necessary information simply by analysing the table_init() function. However, in later variants, C&C\n\ndomains/IPs are usually hard coded in a function called\n\nresolve_cnc_addr(), as shown in Figure 1. Furthermore, due to compiler inline optimization and the fact that the first item is not always\nindexed from a fixed number (e.g. 0), configuration indexing information is missing in table_init().\n\nFortunately, since both C&C and port are referenced in resolve_cnc_addr(), the missing indexing information, together with the hardcoded C&C, can be calculated heuristically with the analysis of resolve_cnc_addr(). Therefore our configuration extraction solution\ncomes as two analyser programs: one for table_init() and the other for resolve_cnc_addr().\n\n**2.1.1 table_init() analyser**\n\nThe table_init() function is called after the bot starts running. As shown in Figure 2, the item installation work is done by repeatedly\ncalling add_entry(). In the case of inline optimization, calls to add_entry() are optimized into those of malloc()/util_memcpy().\n\nThe ‘decrypt->retrieve->re-encrypt’ style of item reference is done separately with the\ntable_unlock_val()/table_retrieve_val()/table_lock_val() functions, with decryption/encryption implemented in\ntable_unlock_val()/table_lock_val(). The encryption algorithm is summarized as follows:\n\n1. Decryption and encryption share the same single-byte XOR’ing algorithm.\n2. Key size is 4. The target byte is XOR’ed with each key byte in turn to get the final ciphertext/plaintext byte.\n\nGiven the associative law of XOR operation, the four-byte key can equivalently be mapped to a one-byte key, which greatly reduces the\nkey space from 2^32 to 2^8, thus making it feasible to search the key with brute force enumeration.\n\nCandidate table_init() functions are found by the static analysis script which goes through all binary functions in samples and picks out\nthose with the following characteristics:\n\nRepeatedly calling add_entry() or malloc()/util_memcpy() in the case of inline optimization.\nComposed of one very large instruction block because no branches are introduced by any switch/loop instructions.\nReferencing dozens of global variables which point to ciphertext memory.\n\nDynamic analysis of the candidate table_init() functions, together with false-positive removals, is done in an emulation program based\non our lightweight emulation framework. The cases of non-inline and inline optimization are considered separately. The key points of\nemulating a non-inline version of table_init() are as follows:\n\nNOP’ing all the CALL instructions and marking them as breakpoints.\nEmulating in single-step mode.\nIn the breakpoint handler, saving arguments 1–3 separately as id, ciphertext address, and size if argument 2 points to a valid data\narea.\n\n\n-----\n\nWhen dynamically analysing the inline optimized code, a trick is used which is inspired by the fact that the return value of malloc()\nwould be used as the first argument of the next call (a.k.a. util_memcpy()). Every time a CALL breakpoint is handled, the return value\n(e.g. EAX in the case of Intel x86 CPU) will be set to a magic value called MAGIC-RET. By doing that, a call with the first argument\nequal to MAGIC-RET would be indicative of util_memcpy, thus triggering the saving of arguments 2 and 3. Similarly, the operation of\nsaving an item to the table can also be traced by checking whether the currently inspected MEM-WRITE operation has a source\noperand of MAGIC-RET. If it does, the slot address will be saved for late index calculation with the following formula:\n```\nitem_id=(item_addr-table_addr)/tbl_item_size\n\n```\nThe table_addr is inferred heuristically from the analysis of resolve_cnc_addr() introduced in Section 2.1.2.\n\nThe key points of emulating an inline optimized table_init() are as follows:\n\n1. NOP’ing all the CALL instructions and marking them as breakpoints.\n2. Hooking all MEM-WRITE instructions.\n3. Emulating in single-step mode.\n4. In the CALL breakpoint handler, saving arguments 2 and 3 as ciphertext address and size if the first argument is MAGIC-RET,\n\nand setting the return value as MAGIC‑RET.\n5. In the MEM-WRITE handler, saving the destination memory address as item_addr if the source operand is MAGIC-RET.\n\nAfter emulation finishes, the ciphertext configurations are read for decryption. Every key in 2^8 is tested until any meaningful plain\nconfigurations are found. The decrypted configurations will be cached for later synthesizing after resolve_cnc_addr() is analysed.\n\n**2.1.2 resolve_cnc_addr() analyser**\n\nThe resolve_cnc_addr() function, called in a SIGTRAP signal handler installed in main(), was originally responsible for retrieving the\nC&C and port from the configuration database with their index numbers. However, more and more Mirai variants have begun to hard\ncode their C&Cs in resolve_cnc_addr(), as illustrated in Figure 3, which mandates the analysis of resolve_cnc_addr() to retrieve the\nright C&C value and port index number. The result will be used for inference of configuration indexing, as mentioned above.\n\nFigure 3: C&C hard coded in resolve_cnc_addr() (md5 =\n\n333d98e27cc885624f073e59fc40dfed).\n\nThe resolve_cnc_addr() function has the following characteristics:\n\n1. It writes at least two global variables (srv_addr.sin_addr and srv_addr.sin_port).\n2. It calls at least three different functions.\n\nCandidate resolve_cnc_addr() functions are found with an IDAPython script in the following ways:\n\n1. Heuristically finding the main() function.\n\n\n-----\n\n2. Finding all callback functions in main() as candidate signal handlers.\n3. Finding callback functions in each candidate signal handler found in (2) as candidate resolve_cnc_addr() functions.\n4. Filtering out those that don’t have reserve_cnc_addr() characteristics.\n5. Extracting the hard-coded C&C if it exists.\n\nThe key steps of emulating resolve_cnc_addr() are as follows:\n\n1. NOP’ing all the CALL instructions and marking them as breakpoints.\n2. Hooking all MEM-WRITE instructions.\n3. Emulating in single-step mode.\n4. In the CALL breakpoint handler, saving a pair of {arg1, ‘CALL’} to an operation list OPS, and setting the return value (e.g. EAX in\n\nthe case of Intel x86) as a magic value MAGIC-RET.\n5. In the MEM-WRITE handler, saving a pair of {write-bytes, ‘WRITE’} to OPS.\n\nAfter emulation stops, the C&C (if not hard coded) and port index numbers are calculated in the following manner:\n\n1. The OPS list is iterated and the unique arg1 values saved in {arg1, ‘CALL’} pairs are counted until a {write-byes, ‘WRITE’} pair is\n\nencountered.\n2. The most frequent arg1 value can be thought of as an index number. If write-bytes in {write-byes, ‘WRITE’} is equal to 4, the\n\nobtained number will be used as the C&C index; if write-bytes is equal to 2, it is used as the C&C port index.\n3. The counting results are cleared for the next round of counting.\n4. Steps 1 to 3 are repeated until OPS is iterated over.\n\nThe indexes that are found are used for C&C retrieval and for inferring the indexing number in the case of inline optimized table_init().\nThe heuristic inference is based on the facts that: (1) although not fixed, the smallest index number must be greater than 0 while\nusually less than 5; (2) the C&C port item always has a size of 2. The detailed process is illustrated as follows:\n\n1. Getting the first item’s address by sorting the values of item_addr obtained in Section 2.1.1, and taking it as first_item_addr.\n2. Assuming the value of first_item_index is 1.\n3. Calculating the table address with the formula: table_addr (=first_item_addr- first_item_index*item_size).\n4. Calculating all other item indexes based on the table_addr obtained in step 3 and the item_addr obtained in Section 2.1.1.\n5. Retrieving the C&C and port with indexes obtained from resolve_cnc_addr(). If the retrieved values make sense, the process\n\nstops here.\n6. Increasing the first_item_index by 1, and going back to step 3 if the first_item_index is less than 5. Otherwise the process stops.\n\nAn example result has been shown in Figure 1, where the C&C and all index numbers have been inferred with the demonstrated\nalgorithm.\n\n### 2.2 Supported attack methods\n\nIt’s known that Mirai is designed for DDoS attacking purposes. Ten supported attack methods are found in the released Mirai source [8].\nAccordingly, ten command codes (e.g. ATK_VEC_xx in Figure 4) are defined in the C&C protocol to deliver attack method types in\ncommands from the controller to bots.\n\nFigure 4: Ten attack\n\nmethods found in the released source.\n\nOur analysis shows that the attack methods usually differ in variants in terms of method count, command code numbering, new types of\nmethods, and method implementation. From the point of view of supported attack methods, Mirai variants could be clustered with\ncombinations of ‘code‑attack typen’, where n is the version number of a specific attack method. For example, the original version of\n\n\n-----\n\nMirai could be represented as:\n```\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 9-atk_std_or_udp, 10-atk_http1}\n\n```\nMeanwhile, the version of the sample illustrated in Figure 1 (md5=0ae272306d313c6abf1433b85e0a2352) has the following\nrepresentation:\n```\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 8-atk_std_or_udp, 9-atk_std_or_udp, 10-atk_tcp_stomp_or_xmas1}\n\n```\nThe obvious difference is that command code 10 has different semantics in the two scenarios.\n\nTo achieve the combination of ‘code-attack_typen’ from a binary sample, we must: (1) extract the attack method codes and their\nfunction addresses from the sample; (2) figure out what attack types each function is used for. Accordingly, two analyser programs are\ndesigned: one program is to extract {code, attack_function} sequences, while the other is to figure out the extracted attack semantics,\nas will be introduced in Section 2.2.1.\n\nAs shown in Figure 4, Mirai attack methods, together with their command codes, are dynamically installed in a function called\n‘attack_init()’. It’s the function named add_attack() that is repeatedly called in attack_init() to save the pairs of {code, attack_function} to\na global structure named ‘methods’. Inside the add_attack() function, calloc() is called to allocate memory for the item of {code,\nattack_function}, and realloc() is called to enlarge the methods by 1 to save the newly allocated item, as shown in Figure 5.\n\nFigure 5:\n\nadd_attack() function in the released source.\n\nSimilar to add_entry() introduced in Section 2.1.1, the add_attack() function may also be inline optimized in some cases, which leads to\ntwo versions of binary add_attack(). Fortunately, the two versions share the following characteristics:\n\n1. Composed of a single block.\n2. A fixed set of one, or two in the case of inline-optimization, unique functions are called repeatedly.\n3. At least one callback function corresponding to the attack method function exists.\n\nThe candidate attack_init() functions are found by an IDAPython script according to the above three characteristics. Non-inline and\ninline versions are considered separately when emulating. The key points of emulating non-inline versions of attack_init() are as\nfollows:\n\n1. NOP’ing all CALL instructions and marking them as breakpoints.\n2. Emulating in single-step mode.\n3. In the breakpoint handler, saving arguments 1–2 if the second argument points to a valid code area.\n\nWhen analysing the inline optimization version of code, a trick is used which is inspired by the fact that the newly allocated memory\nreturned from malloc() will be used as the destination operand in the next MEM-WRITE operation to save the code and atk_function.\nEvery time a CALL breakpoint is handled, the return value (e.g. EAX in the case of Intel x86 CPU) will be set to a magic value called\nMAGIC-RET. The key points of emulating an inline optimization version of attack_init() are as follows:\n\n1. NOP’ing all CALL instructions and marking them as breakpoints.\n2. Hooking MEM-WRITE instructions.\n3. Emulating in single-step mode.\n4. In the CALL breakpoint handler, setting the return value as MAGIC-RET.\n5. In the MEM-WRITE handler, saving the source operand value as atk_code if the destination operand equals MAGIC_RET.\n6. In the MEM-WRITE handler, saving the source operand as atk_function if the destination one equals (MAGIC_RET+4).\n\n\n-----\n\nAn example of the finally found {code, attack_function} pairs is as follows (md5 0ae272306d313c6abf1433b85e0a2352):\n```\n{0_0x8FA0, 1_0xA4C4, 2_0xA988, 8_0x89D8, 3_0xC96C, 4_0xC1F8, 5_0xB998, 10_0xB138, 6_0x9DA8, 7_0x962C, 9_0x8CBC}\n\n```\nThe semantics of the found attack functions are inferred using the fingerprint technique introduced in the next section.\n\n**2.2.1 Fingerprinting attack functions**\n\nTogether with the attack method command codes, as many as 25 attack options (e.g. ATK_OPT_PAYLOAD_SIZE,\nATK_OPT_PAYLOAD_RAND, ATK_OPT_IP_TOS) are defined in the original Mirai C&C protocol to deliver command details, as shown\nin Figure 6.\n\nFigure 6: Attack\n\noptions defined in Mirai C&C protocol.\n\nDetailed analysis shows it’s common for the same functionality to be expressed using different codes across different variants. And\nsome options are usually attack-command-specific, e.g. ATK_OPT_METHOD and ATK_OPT_POST_DATA are only used with\nATK_VEC_HTTP (a.k.a. attack_app_http, as shown in Figure 7), while ATK_OPT_GRE_CONSTIP is only used with ATK_VEC_GREIP\n(a.k.a. attack_gre_ip, as shown in Figure 8) and ATK_VEC_GREETH.\n\nFigure 7: Attack\n\noptions used in attack_app_http().\n\nFigure 8: Attack\n\noptions used in attack_gre_ip().\n\n\n-----\n\nFurthermore, different attack methods usually don t share the same set of attack options, which inspired us to devise a fingerprint\ntechnique as follows:\n\nfingerprint(atk_function)={concatenation of used option codes}\n\nFor example, the attack_app_http in Figure 6 has a fingerprint of ‘0x15_0x14_0x08_0x16_0x18_0x07’, while attack_gre_ip in Figure 7\nhas a fingerprint of ‘0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01_0x13_0x19’.\n\nWith the fingerprint technique, not only can we cluster the variants based on their attack method fingerprints, but we are also able to\nrecognize the supported attack methods of new samples with a signature database of {atk_fingerprint, method_name}. The used option\ncodes are all the data that is needed for fingerprinting. They are always referenced in the first, yet large, instruction block of binary\nattack functions, as shown in Figure 9, by calling the parser functions of attack_get_opt_int()/attack_get_opt_str()/attack_get_opt_ip().\n\nFigure 9: Attack options used in\n\nattack_gre_ip().\n\nDetailed analysis shows that all parser functions share the same characteristics: taking four arguments with arguments 1–2 as source\ndata, arg 3 as option code and arg 4 holding a default value. Inspired by the findings, our option code extraction is achieved by\nemulating the first instruction block of the attack function. The static analysis part is relatively simple: splitting the target attack function\ninto blocks and finding the starting and ending addresses of the first block. A trick to recognize the ‘attack_get_opt_’ prefixed parser\nfunctions in emulation is to set the first and second arguments of the target attack function as two magic values (e.g. MAGIC-VAL1 and\nMAGIC-VAL2) before emulation starts. The key points of emulation are as follows:\n\n1. Setting arguments 1 and 2 of the target function as two magic values (e.g. MAGIC-VAL1 and MAGIC-VAL2).\n2 NOP’ing all the CALL instructions and marking them as breakpoints\n\n\n-----\n\n3. Emulating in single step mode.\n4. Saving arguments 3–4 when breakpoints are encountered with arguments 1–2 equal to MAGIC-VAL1–2.\n\nCurrently, 43 unique attack method fingerprints have been found from the 32,000+ samples, as illustrated in Appendix B.\n\n### 2.3 Dictionary of usernames/passwords\n\nIt’s the scanner module that enables Mirai to infect hundreds of thousands of vulnerable devices in a relatively short period of time. That\nmodule can be divided into two parts: (1) the TCP port prober; (2) a telnet brute force attacker with a dictionary of dozens of, default to\n62, usernames/passwords. Due to its proven efficiency, the prober is not only retained by most Mirai descendants, but also borrowed\nby other botnet families [9]. Meanwhile, telnet brute forcing is also kept by most variants, sometimes used together with new exploits [3,\n5], which makes it common to find a credential dictionary in Mirai variant samples. Our analysis shows that different variants don’t\nusually share the same set of credentials, as shown in Figure 10. Since new usernames and passwords often indicate new infection\nvectors, the dictionary changes can be used for variant detection and tracking [10].\n\nFigure 10: Two\n\nexamples of extracted usernames and passwords (md5_1: dbba02b2d0ef42d2a1ebbab7f03f37f0; md5_2:\n2ff2d4feff4ffcec355f52993ce7b73e).\n\nIn Mirai, the scanning task, including the credential dictionary initialization, is done in a function called scanner_init(), which is\ncharacterized by having a complex binary control flow graph embedded with a very large instruction block, as illustrated in Figure 11.\n\nFigure 11:\n\nBinary version of scanner_init().\n\nDetailed analysis shows it’s the large block that is responsible for installing all the usernames and passwords, which inspires the idea of\nextracting the credentials by emulating the large block. Candidate blocks are found using an IDAPython script that iterates all binary\nblocks and picks out those with the following criteria:\n\n\n-----\n\n1. Having large block size and instruction count.\n2. Referencing dozens of global variables which point to ciphertext usernames and passwords.\n3. Writing at least five global variables which correspond to IP and TCP fields.\n4. Repeatedly calling a unique function (a.k.a. add_auth_entry()).\n\nThe found blocks are emulated based on our lightweight emulation framework. The key points of the emulation program are as follows:\n\n1. NOP’ing all the CALL instructions and marking them as breakpoints.\n2. Emulating in single-step mode.\n3. In the CALL breakpoint handler, saving arguments 1–3 separately as username, password and weight.\n\nThe finally extracted usernames and passwords are deciphered with a self-implemented decryption module similar to that introduced in\nSection 2.1.1. Two examples of the extracted usernames and passwords are illustrated in Figure 10.\n\n## 3. Variant classification and tracking\n\nWhile variant classification and tracking is a complex topic, especially in the case of dozens of variants and tens of thousands of\nsamples, in this section we will discuss such schemes with data limited to those introduced in Section 2.\n\n### 3.1 Configuration-based schemes\n\nSince the configuration database stores most of the running parameters, the variant evolution can be well detected from database\nchanges. For example, the samples illustrated in Figures 12 and 13 share the same C&C and similar configurations, but extra iptables\ncommands are found in the second one, which indicates an exclusive infection and possible infection vectors.\n\nFigure 12:\n\nConfigurations from a sample with md5 = dbba02b2d0ef42d2a1ebbab7f03f37f0.\n\n\n-----\n\nFigure 13:\n\nConfigurations from a sample with md5 = 08abb658c6a293886a8000a31b900e88.\n\nConsidering that there are usually dozens of items in a single configuration database, and configurations vary greatly across variants in\nterms of size and content, it might be not feasible to use all configurations for classification and tracking. Therefore, we devise two\nschemes which rely only on configuration size, count, and encryption key used.\n\n**3.1.1 Clustering based on configuration count and size**\n\nThis scheme is designed to cluster variants and quickly detect anomalous ones in cases where there are a large number of samples.\nThis is achieved by plotting all the samples according to their configurations’ counts and sizes, as shown in Figure 14 where the x-axis\nrepresents size while the y-axis shows the count.\n\nFigure 14:\n\nClustering samples based on configuration count and size.\n\nTwo clusters of samples with much larger configuration size can easily be identified in Figure 14. Further analysis shows they can be\nclassified as the same variant, as shown in Table 2. Detailed analysis shows the extraordinarily large configuration size is due to\ndozens of fake HTTP user-agents added by the author for better HTTP flooding attacks. In fact, the correlated intelligence of branch\nnames, keys and C&Cs strongly suggests that the same underground group is behind the samples.\n\n|Criterion|Branch name|Key|C&C|Samples|\n|---|---|---|---|---|\n\n\n-----\n\n|size > 7400  && count > 100  && count < 120|MIRAI|0x22|cnc.ttoww.com|19|\n|---|---|---|---|---|\n|KYUBI|0x34|cnc.aandy.xyz|4||\n|MIRAI|0x34|cnc.aandy.xyz|8||\n|MIRAI|0x34|www.aandy.cf|7||\n|MIRAI|0x34|www.askjasghasg.ru|16||\n\n\nTable 2: A cluster with very large configuration size.\n\nThis clustering scheme can also be used with other schemes. For example, it can be used to cluster samples belonging to the same\nbranch (e.g. MASUTA, OWARI). Clustering results based on size and count can be useful for further analysis.\n\n**3.1.2 Clustering based on encryption key**\n\nExcept for SATORI, which is not discussed in this paper [5], all the Mirai samples we collected share the same encryption algorithm,\nthus only the encryption key is considered in this paper. Since the key has a space of 2^8, there is a low probability that two variants\nshare the same key coincidentally. Therefore key sharing can be thought of as being caused by code sharing, and can be used to\ncorrelate the botnet authors behind the samples.\n\nIn total, 31 keys have been detected from our collected samples. Their usage stats show a good long tail distribution of samples, as\nillustrated in Table 3.\n\n**Key** **Sample count**\n\n0x22 4,755\n\n0x54 3,938\n\n0x3D 553\n\n0x45 542\n\n0x66 204\n\n0x37 163\n\n0x6F 125\n\n0x02 90\n\n0x62 77\n\n0x67 69\n\n0x55 52\n\n0x78 37\n\n0x34 35\n\n0x03 29\n\n0x56 20\n\n0x10 14\n\n0x11 13\n\n0x76 8\n\n0x42 8\n\nTable 3: Top 20 frequently used keys.\n\nAccording to our analysis, the keys located in the tail area usually indicate a single variant, while frequently used keys indicate a\nrelative in the same family. For example, through the key of 0x54, the branches of Cult, JOSHO and OWARI can be connected, as\nshown in Table 4.\n\n|Key|Sample count|\n|---|---|\n|0x22|4,755|\n|0x54|3,938|\n|0x3D|553|\n|0x45|542|\n|0x66|204|\n|0x37|163|\n|0x6F|125|\n|0x02|90|\n|0x62|77|\n|0x67|69|\n|0x55|52|\n|0x78|37|\n|0x34|35|\n|0x03|29|\n|0x56|20|\n|0x10|14|\n|0x11|13|\n|0x76|8|\n|0x42|8|\n\n\n-----\n\n|MD5|Config count|Config size|Branch|C&C|\n|---|---|---|---|---|\n|0729b89281c831fc035d56fbf14631da|30|333|Cult|198.134.120.150|\n|23a98fc659982da993e7825eb87bb640|30|340|OWARI|198.134.120.150|\n|2ff2d4feff4ffcec355f52993ce7b73e|30|346|JOSHO|198.134.120.150|\n\n\nTable 4: Connecting Cult, JOSHO and OWARI through the key of 0x54.\n\nThe connecting process works as follows:\n\n1. The three branches are connected by the samples sharing the same key.\n2. The grouped samples have a similar configuration count and size, which indicates that they probably belong to the same variant.\n3. The samples share the same C&C, which strongly suggests that they probably come from the same author(s).\n\nOur analysis shows that such connections can be extended to other branches, with most of them finally verified by the shared C&Cs.\nBased on that finding, we devise a coarse-grained grouping scheme of ‘branch+key’ for quickly classifying new samples. In total, 92\ngroups are produced. With the exception of ‘MIRAI_0x22’, which stands for the default branches, the other top 10 groups based on\ntheir C&Cs are shown in Table 5.\n\n**Variant** **C&C count**\n\nJOSHO+0x54 216\n\nOWARI+0x54 134\n\nCult+0x54 81\n\nSORA+0x54 69\n\ndaddyl33t+0x3D 59\n\nMASUTA+0x45 53\n\nEXTENDO+0x54 21\n\nMIORI+0x54 12\n\ndwickedgod+0x3D 10\n\nSaikin+0x66 9\n\nKatrina+0x67 9\n\nTable 5: Top 10 groups of ‘branch+key’ based on C&C count.\n\n### 3.2 Attack-method-based schemes\n\nSince Mirai was designed to launch DDoS attacks, the supported attack methods are a sound basis for variant classification. Based on\nthe attack method fingerprinting technique introduced in Section 2.2, we develop a classification scheme based on the combination of\n{code, attack-type} pairs extracted from samples, as illustrated in Section 3.2.1.\n\n**3.2.1 Combination of supported attack methods**\n\nAccording to our analysis, Mirai variants vary greatly in the supported attack methods in terms of method count, code numbering, and\nimplementation. To quickly distinguish different variants of samples, we devise a coarse-grained classification method based on the\ncombination of supported attack method codes (e.g. 0_1_2_3_4_5_6_7_9_10 for default Mirai samples). Two samples are classified as\npossibly the same variant for further analysis only when they share the same code combination. The top 10 combinations based on the\nsample count are shown in Table 6.\n\n**Attack method code combination** **Count**\n\n0_1_2_3_4_5_6_7_9_10 4,488\n\n0_1_2_3_4_5_6_7_8_9_10 3,890\n\n0_1_2_3_4_5_6_7_8 976\n\n0_1_2_3_4_5_6_7_8_9 353\n\n|Variant|C&C count|\n|---|---|\n|JOSHO+0x54|216|\n|OWARI+0x54|134|\n|Cult+0x54|81|\n|SORA+0x54|69|\n|daddyl33t+0x3D|59|\n|MASUTA+0x45|53|\n|EXTENDO+0x54|21|\n|MIORI+0x54|12|\n|dwickedgod+0x3D|10|\n|Saikin+0x66|9|\n|Katrina+0x67|9|\n\n|Attack method code combination|Count|\n|---|---|\n|0_1_2_3_4_5_6_7_9_10|4,488|\n|0_1_2_3_4_5_6_7_8_9_10|3,890|\n|0_1_2_3_4_5_6_7_8|976|\n\n\n-----\n\n|0_1_2_3_6_7_8|138|\n|---|---|\n|0_1_2_3_4_5_6_7_9|96|\n|0_1_2_3_4|94|\n|0_1_2_3|75|\n|0_1_2_3_4_5_6_7_9_10_11_12|51|\n|0_1_2|48|\n\n\nTable 6: Top 10 attack method code combinations.\n\nSince it’s common for the same code to be assigned to different attack methods in different variants, a more precise classification can\nbe achieved using the combination of code and the corresponding attack method fingerprint. With the help of the fingerprint technique\nintroduced in Section 2.2.1, a total of 126 such unique combinations are found, as shown in Appendix C, where each combination can\nbe thought to represent a variant. It’s worth mentioning that the fingerprints have been converted to the method name for better\nreadability with the signature database we built, as shown in Appendix B.\n\n## 4. Typical variants analysis\n\nTo better demonstrate our proposed schemes, in this section we will investigate some popular Mirai variants with the proposed\nschemes.\n\n### 4.1 MASUTA\n\nIn total, four keys are found to be used in this branch. Their stats are shown Table 7.\n\n**Variant** **Samples** **C&Cs**\n\nMASUTA+0x45 351 53\n\nMASUTA+0x02 90 5\n\nMASUTA+0x22 9 1\n\nMASUTA+0x55 8 1\n\nTable 7: Stats on MASUTA samples and C&Cs.\n\nSample clustering on the largest branch of ‘MASUTA+0x45’ is shown in Figure 15.\n\nFigure 15:\n\nClustering samples of ‘MASUTA+0x45’ based on configuration.\n\nBoth configuration size and count are relatively close. The slight changes in sizes are due to the following reasons:\n\n|Variant|Samples|C&Cs|\n|---|---|---|\n|MASUTA+0x45|351|53|\n|MASUTA+0x02|90|5|\n|MASUTA+0x22|9|1|\n|MASUTA+0x55|8|1|\n\n\n-----\n\n1. Two different prompt lines are used: gosh that chinese family at the other table sure ate alot and The Void .\n2. In some samples the C&Cs are hard coded in resolve_cnc_addr() but old default C&Cs are still kept in configurations.\n[3. Items of ‘Oaf3’, ‘AbAd’, ‘14Fa’ and ‘[email protected]’ are added in some samples.](https://www.virusbulletin.com/cdn-cgi/l/email-protection)\n\nFrom the point of view of attack methods, as many as 25 combinations of {code, atk_type} are found in all MASUTA samples, while\nthere are eight combinations in the ‘MASUTA+0x45’ branch, as shown in Figure 16.\n\nFigure 16:\n\nCombinations attack methods found 'MASUTA+0x45' samples.\n\nThe UNK1 in Figure 16 represents a yet unrecognized fingerprint of\n‘0x02_0x03_0x04_0x05_0x07_0x0a_0x0b_0x0c_0x0d_0x0e_0x0f_0x00_0x01_0x06’.\n\n### 4.2 OWARI\n\nIn total, two keys are found to be used in OWARI samples. Their stats are shown in Table 8.\n\n**Variant** **Samples** **C&Cs**\n\nOWARI+0x54 687 146\n\nOWARI+0x66 15 2\n\nTable 8: Stats on OWARI samples and C&Cs.\n\nSample clustering of OWARI samples is shown in Figure 17.\n\nFigure 17: Clustering\n\nOWARI samples based on configuration.\n\nIt’s interesting that OWARI samples concentrate exactly on four points of (21, 265), (30, 340), (38, 409) and (41, 2524). The slight\nchanges in size are due to the following reasons:\n\n1. Two different prompt lines are used: ‘OWARI09123id9i123xd912’ and ‘Follow twitter.com/1337Wicked’.\n2. In the samples with a size of 2524, several automatic download and killer command lines exist, as shown in Figure 18.\n\nFigure 18:\n\nCommand lines found in OWARI samples with size of 2524.\n\n|Variant|Samples|C&Cs|\n|---|---|---|\n|OWARI+0x54|687|146|\n|OWARI+0x66|15|2|\n\n\n-----\n\nIt s interesting that as many as 12 unique C&Cs are detected from samples with a size of 2424, while they all share the same download\nserver of 185.246.152.173. We think that either they belong to the same group, or the download commands are backdoored by the\nauthor (a.k.a. the so-called ‘twitter.com/1337Wicked’) in his code.\n\nFrom the point of view of attack methods, only two combinations of {code, atk_type} are found in all OWARI samples:\n```\n15 {0-atk_udp1, 1-atk_udp_vse1, 2-atk_tcp_syn1, 3-atk_tcp_ack1, 4-atk_gre1, 5-atk_gre1, 6-atk_std_or_udp, 7-atk_std_or_udp,\n8-atk_tcp_stomp_or_xmas1}\n642 {0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 8-atk_std_or_udp, 9-atk_std_or_udp, 10-atk_tcp_stomp_or_xmas1}\n\n```\nDetailed analysis shows the first combination corresponds to the branch of ‘OWARI+0x66’, while the second to ‘OWARI+ 0x54’.\n\nIt’s worth mentioning that, with the key of 0x66 and the first attack method combination, we successfully connected the ‘OWARI+0x66’\nto another branch named ‘kkuuaassaa’, where all 44 samples share the same C&C of ‘46.243.189.109’. We think they are either written\nby the same author, or there is heavy code sharing.\n\n### 4.3 WICKED\n\nThe WICKED branch became known for including multiple IoT exploits in 2018. In total, 128 samples have been collected (up to May\n2018), with only one key of 0x37 found and six C&Cs detected. Sample clustering is shown in Figure 19.\n\nFigure 19:\n\nClustering samples of WICKED based on configuration.\n\nThe samples can be clustered into four groups, as shown in Table 9.\n\n**(size, count)** **Samples** **C&C**\n\n(48, 614) 15 104.244.72.82\n\n(27, 737) 4 185.246.152.173\n\n(38, 833) 54 104.236.224.5\n\n104.244.72.82\n\n167.99.220.44\n\n185.189.58.211\n\n185.246.152.173\n\n188.166.63.14\n\n(48, 1362~1376) 55 167.99.220.44\n\n185.246.152.173\n\nTable 9: Stats on WICKED samples.\n\n|(size, count)|Samples|C&C|\n|---|---|---|\n|(48, 614)|15|104.244.72.82|\n|(27, 737)|4|185.246.152.173|\n|(38, 833)|54|104.236.224.5 104.244.72.82 167.99.220.44 185.189.58.211 185.246.152.17 3 188.166.63.14|\n|(48, 1362~1376)|55|167.99.220.44 185.246.152.17 3|\n\n\n-----\n\nGiven the fact that several C&Cs are shared across clusters, we think that the WICKED samples are probably produced by the same\nauthors. On the other hand, since the IP of 185.246.152.173 is also shared by OWARI samples, the WICKED branch could be\nconnected to that branch.\n\nThe size changes in configurations are mainly due to the command lines shown in Figures 20 and 21. Contents shown in Figure 19\nindicate an exclusive infection by this branch.\n\nFigure 20: iptables commands found in WICKED samples.\n\nFigure 21: Echo\n\ncommands found in WICKED samples.\n\nFigure 22:\n\nCombination attack methods found in WICKED samples.\n\nFrom the point of view of attack methods, combinations of {code, atk_type} are found in WICKED samples, as shown in Figure 22.\n\n## 5. Conclusion\n\nWe have introduced how to extract data including configurations, supported attack methods, and dictionaries of usernames and\npasswords from Mirai samples, and how to use the extracted data for variant classification and tracking, with different schemes\ndiscussed. Some popular Mirai branches have been investigated with our proposed schemes. In the future, we will keep a close eye on\nthe emerging Mirai variants, and will continue researching better classification schemes, e.g. using fuzzy hashing techniques to group\nsamples based on their extracted configurations. We hope our work will help improve the detection and mitigation of Mirai-like threats.\n\n## References\n\n[1] Hajime: Analysis of a decentralized internet worm for IoT devices. https://security.rapiditynetworks.com/publications/2016-1016/hajime.pdf.\n\n[2] IoT_reaper: A Few Updates. [http://blog.netlab.360.com/iot_reaper-a-few-updates-en/.](http://blog.netlab.360.com/iot_reaper-a-few-updates-en/)\n\n[[3] Now Mirai Has DGA Feature Built in. https://blog.netlab.360.com/new-Mirai-variant-with-dga/.](https://blog.netlab.360.com/new-Mirai-variant-with-dga/)\n\n[4] Early Warning: A New Mirai Variant is Spreading Quickly on Port 23 and 2323. https://blog.netlab.360.com/early-warning-a-newMirai-variant-is-spreading-quickly-on-port-23-and-2323-en/.\n\n[5] Warning: Satori, a Mirai Branch Is Spreading in Worm Style on Port 37215 and 52869. https://blog.netlab.360.com/warning-satori-anew-Mirai-variant-is-spreading-in-worm-style-on-port-37215-and-52869-en/.\n\n[6] MMD-0056-2016 – Linux/Mirai, how an old ELF malcode is recycled. http://blog.malwaremustdie.org/2016/08/mmd-0056-2016linuxMirai-just.html.\n\n[7] Unicorn. [https://www.unicorn-engine.org/.](https://www.unicorn-engine.org/)\n\n[[8] Source Code for IoT Botnet ‘Mirai’ Released. https://krebsonsecurity.com/2016/10/source-code-for-iot-botnet-Mirai-released/.](https://krebsonsecurity.com/2016/10/source-code-for-iot-botnet-Mirai-released/)\n\n[9] ADB.Miner: More Information. [https://blog.netlab.360.com/adb-miner-more-information-en/.](https://blog.netlab.360.com/adb-miner-more-information-en/)\n\n[10] Early Warning: A New Mirai Variant is Spreading Quickly on Port 23 and 2323. https://blog.netlab.360.com/early-warning-a-newmirai-variant-is-spreading-quickly-on-port-23-and-2323-en/.\n\n## Appendix A: Sample SHA256 hashes\n\nMD5 hash: 0ae272306d313c6abf1433b85e0a2352\n\nSHA-256 hash: 0c5bc272d13fc05bca15babd83826ca51accf3a8bc0a52f7e0f7f79ea4496280\n\n\n-----\n\nMD5 hash: dbba02b2d0ef42d2a1ebbab7f03f37f0\n\nSHA-256 hash: 87f49c75ae9aa3138b893a6ff1c316be1c197bed2021ff84bc6a281b25543ee9\n\nMD5 hash: 08abb658c6a293886a8000a31b900e88\n\nSHA-256 hash: dab9ee751d591af93e998b56efa888ef09f50b2e74ab8a6f7b910b00350a866a\n\nMD5 hash: 2db905373ea58920f7dbf9f3e59ba990\n\nSHA-256 hash: 79c3d3b25aba02959ecf734e93b8c162851c11abe81bd7207a16d496ebfa6ab5\n\nMD5 hash: 82358453a5b5be7a54b7013b8f2ec21d\n\nSHA-256 hash: d7ca6f599d37fcfa146b5c044efda4199cb5713fca0984f93301a85b68934c4e\n\nMD5 hash: 0729b89281c831fc035d56fbf14631da\n\nSHA-256 hash: 3af17b130f9b41d5e3645c2622cfe4be5daee0316084cb10c05adf6d60ec1032\n\nMD5 hash: 23a98fc659982da993e7825eb87bb640\n\nSHA-256 hash: f227b9d6f59b27fce5f23551ea15794bd45e26f3eaab44136d6fdf9903992c3b\n\nMD5 hash: 2ff2d4feff4ffcec355f52993ce7b73e\n\nSHA-256 hash: 3cece358fecfc8fbe2e86a1b2c6ae3a0f34d9648cd2306cd734bc717216a728e\n\nMD5 hash: 333d98e27cc885624f073e59fc40dfed\n\nSHA-256 hash: 17a91b2632b625cbd02a009ef64f1faae016de497a7e3b1395e54dc32c8b12d3\n\n## Appendix B: Signature of attack methods\n\n|Attack method|Fingerprint|\n|---|---|\n|atk_app_proxy|null|\n|atk_cf|0x08_0x18|\n|atk_gre1|0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01_0x13_0x19|\n|atk_gre2|0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01_0x12_0x13|\n|atk_gre3|0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01_0x12_0x13_0x06|\n|atk_gre4|0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01_0x12_0x18|\n|atk_gre5|0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01_0x13_0x06|\n|atk_gre6|0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01_0x11_0x12|\n|atk_http1|0x15_0x14_0x08_0x16_0x18_0x07|\n|atk_http2|0x14_0x13_0x08_0x15_0x17_0x07|\n|atk_std_or_udp|0x07_0x06_0x00_0x01|\n|atk_tcp_ack1|0x02_0x03_0x04_0x05_0x06_0x07_0x11_0x12_0x0b_0x0c_0x0d_0x0e_0x0f_0x10_0x00_0x01_0x19|\n|atk_tcp_ack2|0x02_0x03_0x04_0x05_0x06_0x07_0x10_0x11_0x0a_0x0b_0x0c_0x0d_0x0e_0x0f_0x00_0x01_0x13|\n|atk_tcp_ack3|0x02_0x03_0x04_0x05_0x06_0x07_0x10_0x11_0x0a_0x0b_0x0c_0x0d_0x0e_0x0f_0x00_0x01_0x13_0x06|\n|atk_tcp_ack4|0x02_0x03_0x04_0x05_0x06_0x07_0x10_0x11_0x0a_0x0b_0x0c_0x0d_0x0e_0x0f_0x00_0x01_0x18|\n|atk_tcp_ack5|0x02_0x03_0x04_0x05_0x06_0x07_0x11_0x12_0x0b_0x0c_0x0d_0x0e_0x0f_0x10_0x00_0x01|\n|atk_tcp_ack6|0x02_0x03_0x04_0x05_0x06_0x07_0x11_0x12_0x0b_0x0c_0x0d_0x0e_0x0f_0x10_0x00_0x01_0x06|\n|atk_tcp_ack7|0x02_0x03_0x04_0x05_0x06_0x07_0x10_0x11_0x0a_0x0b_0x0c_0x0d_0x0e_0x0f_0x00_0x01|\n\n\n-----\n\n|atk_tcp_ack_or_synack|0x02_0x03_0x04_0x05_0x06_0x07_0x0f_0x10_0x09_0x0a_0x0b_0x0c_0x0d_0x0e_0x00_0x01_0x12|\n|---|---|\n|atk_tcp_stomp_or_xmas1|0x02_0x03_0x04_0x05_0x07_0x0b_0x0c_0x0d_0x0e_0x0f_0x10_0x00_0x01|\n|atk_tcp_stomp_or_xmas2|0x02_0x03_0x04_0x05_0x07_0x0a_0x0b_0x0c_0x0d_0x0e_0x0f_0x00_0x01|\n|atk_tcp_stomp_or_xmas3|0x02_0x03_0x04_0x05_0x07_0x09_0x0a_0x0b_0x0c_0x0d_0x0e_0x00_0x01|\n|atk_tcp_syn1|0x02_0x03_0x04_0x05_0x06_0x07_0x11_0x12_0x0b_0x0c_0x0d_0x0e_0x0f_0x10_0x19|\n|atk_tcp_syn10|0x00_0x02_0x03_0x04_0x05_0x06_0x07_0x10_0x11_0x0a_0x0b_0x0c_0x0d_0x0e_0x0f_0x13|\n|atk_tcp_syn2|0x00_0x02_0x03_0x04_0x05_0x06_0x07_0x10_0x11_0x0a_0x0b_0x0c_0x0d_0x0e_0x0f_0x18|\n|atk_tcp_syn3|0x02_0x03_0x04_0x05_0x06_0x07_0x0f_0x10_0x09_0x0a_0x0b_0x0c_0x0d_0x0e_0x12|\n|atk_tcp_syn4|0x02_0x03_0x04_0x05_0x06_0x07_0x10_0x11_0x0a_0x0b_0x0c_0x0d_0x0e_0x0f|\n|atk_tcp_syn5|0x02_0x03_0x04_0x05_0x06_0x07_0x10_0x11_0x0a_0x0b_0x0c_0x0d_0x0e_0x0f_0x13|\n|atk_tcp_syn6|0x02_0x03_0x04_0x05_0x06_0x07_0x10_0x11_0x0a_0x0b_0x0c_0x0d_0x0e_0x0f_0x13_0x06|\n|atk_tcp_syn7|0x02_0x03_0x04_0x05_0x06_0x07_0x10_0x11_0x0a_0x0b_0x0c_0x0d_0x0e_0x0f_0x18|\n|atk_tcp_syn8|0x02_0x03_0x04_0x05_0x06_0x07_0x11_0x12_0x0b_0x0c_0x0d_0x0e_0x0f_0x10|\n|atk_tcp_syn9|0x02_0x03_0x04_0x05_0x06_0x07_0x11_0x12_0x0b_0x0c_0x0d_0x0e_0x0f_0x10_0x06|\n|atk_udp1|0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01_0x19|\n|atk_udp2|0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01_0x11|\n|atk_udp3|0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01|\n|atk_udp4|0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01_0x18|\n|atk_udp5|0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01_0x19_0x11|\n|atk_udp6|0x07_0x06_0x00_0x01_0x10|\n|atk_udp_dns|0x02_0x03_0x04_0x05_0x06_0x07_0x09_0x00_0x08|\n|atk_udp_or_gre1|0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01_0x12|\n|atk_udp_or_gre2|0x02_0x03_0x04_0x05_0x06_0x07_0x00_0x01_0x13|\n|atk_udp_vse1|0x02_0x03_0x04_0x05_0x06_0x07|\n|atk_udp_vse2|0x02_0x03_0x04_0x05_0x06_0x07_0x11|\n\n\n## Appendix C: All recognized combinations of {attack_method_code, attack_type}\n\n\n-----\n\n```\natk_app_proxy}\n{0-atk_std_or_udp}\n{0-atk_tcp_syn1, 1-atk_tcp_ack1, 2-atk_std_or_udp}\n{0-atk_tcp_syn1, 1-atk_tcp_ack1, 2-atk_tcp_stomp_or_xmas1}\n{0-atk_udp1, 1-atk_std_or_udp, 2-atk_tcp_syn1, 3-atk_tcp_ack1, 4-atk_tcp_stomp_or_xmas1, 5-atk_gre1, 6-atk_udp_dns, 8atk_udp_vse1}\n{0-atk_udp1, 1-atk_tcp_syn1, 2-atk_tcp_ack1, 3-atk_gre1, 4-atk_gre1, 5-atk_std_or_udp, 6-atk_tcp_stomp_or_xmas1}\n{0-atk_udp1, 1-atk_udp6, 2-atk_tcp_syn1, 3-atk_tcp_ack1, 4-atk_tcp_stomp_or_xmas1, 5-atk_gre1, 6-atk_udp_dns, 8atk_udp_vse1}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_std_or_udp, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_gre1, 6-atk_gre1, 7-atk_std_or_udp, 8atk_tcp_stomp_or_xmas1, 9-atk_http1, 10-atk_cf}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_std_or_udp, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_gre1, 6-atk_gre1, 7-atk_std_or_udp, 8atk_tcp_stomp_or_xmas1}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_tcp_syn1, 3-atk_tcp_ack1, 4-atk_gre1, 5-atk_gre1, 6-atk_std_or_udp, 7-atk_std_or_udp, 8atk_tcp_stomp_or_xmas1, 9-atk_http1, 10-atk_cf}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_tcp_syn1, 3-atk_tcp_ack1, 4-atk_gre1, 5-atk_gre1, 6-atk_std_or_udp, 7-atk_std_or_udp, 8atk_tcp_stomp_or_xmas1}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 8-atk_app_proxy, 9-atk_std_or_udp, 10-atk_http1}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 8-atk_cf, 9-atk_std_or_udp, 10-atk_http1}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 8-atk_std_or_udp, 9-atk_http1}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 8-atk_std_or_udp, 9-atk_std_or_udp, 10-atk_tcp_stomp_or_xmas1, 11-atk_http1, 12-atk_cf}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 8-atk_std_or_udp, 9-atk_std_or_udp, 10-atk_tcp_stomp_or_xmas1}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 9-atk_std_or_udp, 10-atk_http1, 11-atk_app_proxy}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 9-atk_std_or_udp, 10-atk_http1, 11-atk_tcp_stomp_or_xmas1, 12-atk_std_or_udp}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 9-atk_std_or_udp, 10-atk_http1, 12-atk_http1, 13-atk_http1}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 9-atk_std_or_udp, 10-atk_http1, 12-atk_http1}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 9-atk_std_or_udp, 10-atk_http1}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 9-atk_std_or_udp, 10-atk_udp_vse1}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 9-atk_std_or_udp}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 9-atk_udp6, 10-atk_http1}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 9-atk_udp6}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_std_or_udp}\n{0-atk_udp1, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 9-atk_std_or_udp}\n{0-atk_udp1, 1-atk_udp_vse1, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7-atk_gre1, 9atk_std_or_udp, 10-atk_http1}\n{0-atk_udp1, 1-atk_udp_vse2, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 9-atk_std_or_udp, 10-atk_http1}\n{0-atk_udp1, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 6-atk_gre1, 7-atk_gre1, 9-atk_std_or_udp}\n{0-atk_udp3, 1-atk_std_or_udp, 2-atk_tcp_syn8, 3-atk_tcp_ack5, 4-atk_tcp_stomp_or_xmas1, 5-atk_udp_or_gre2, 6-atk_udp_dns,\n7-atk_udp_or_gre2, 8-atk_udp_vse1}\n{0-atk_udp3, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn4, 4-atk_tcp_ack7}\n{0-atk_udp3, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn8, 4-atk_tcp_ack5, 5-atk_tcp_stomp_or_xmas1, 6-atk_udp_or_gre2, 7atk_udp_or_gre2, 8-atk_app_proxy}\n{0-atk_udp3, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn8, 4-atk_tcp_ack5, 5-atk_tcp_stomp_or_xmas1, 6-atk_udp_or_gre2, 7atk_udp_or_gre2, 8-atk_std_or_udp, 9-atk_std_or_udp, 10-atk_tcp_stomp_or_xmas1}\n{0-atk_udp3, 1-atk_udp_vse2, 2-atk_udp_dns, 3-atk_tcp_syn9, 4-atk_tcp_ack6, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre5, 7atk_gre5, 9-atk_std_or_udp, 10-atk_http1}\n{0-atk_udp4, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn2, 4-atk_tcp_ack4, 5-atk_tcp_stomp_or_xmas2, 6-atk_gre4, 7atk_gre4, 8-atk_std_or_udp, 9-atk_http2}\n{0-atk_udp4, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn2, 4-atk_tcp_ack4, 5-atk_tcp_stomp_or_xmas2, 6-atk_gre4, 7atk_gre4, 8-atk_std_or_udp, 9-atk_std_or_udp}\n{0-atk_udp4, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn2, 4-atk_tcp_ack4, 5-atk_tcp_stomp_or_xmas2, 6-atk_gre4, 7atk_gre4, 8-atk_std_or_udp}\n{0-atk_udp4, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn2, 4-atk_tcp_ack4}\n{0-atk_udp4, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn7, 4-atk_tcp_ack4, 5-atk_tcp_stomp_or_xmas2, 6-atk_gre4, 7atk_gre4, 8-atk_std_or_udp, 9-atk_http2}\n{0-atk_udp4, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn7, 4-atk_tcp_ack4, 5-atk_tcp_stomp_or_xmas2, 6-atk_gre4, 7atk_gre4, 8-atk_std_or_udp, 9-atk_std_or_udp}\n{0-atk_udp4, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn7, 4-atk_tcp_ack4, 5-atk_tcp_stomp_or_xmas2, 6-atk_gre4, 7atk_gre4, 8-atk_std_or_udp}\n{0-atk_udp4, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn7, 4-atk_tcp_ack4}\n{0-atk_udp5, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7atk_gre1, 9-atk_std_or_udp, 10-atk_http1}\n{0-atk_udp_or_gre1, 1-atk_udp_vse1, 2-atk_tcp_syn3, 3-atk_tcp_ack_or_synack, 4-atk_tcp_ack_or_synack, 5\n```\n\n-----\n\n```\n{0-atk_udp_or_gre2, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn10, 4-atk_tcp_ack2, 5-atk_tcp_stomp_or_xmas2, 6-atk_gre2, 7atk_gre2, 8-atk_std_or_udp}\n{0-atk_udp_or_gre2, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn10, 4-atk_tcp_ack2}\n{0-atk_udp_or_gre2, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn10, 6-atk_gre2, 7-atk_gre2, 8-atk_std_or_udp, 9atk_tcp_stomp_or_xmas2}\n{0-atk_udp_or_gre2, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn10, 6-atk_gre2, 7-atk_gre2, 8-atk_std_or_udp}\n{0-atk_udp_or_gre2, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn5, 4-atk_tcp_ack2, 5-atk_tcp_stomp_or_xmas2, 6-atk_gre2, 7atk_gre2, 8-atk_std_or_udp, 9-atk_tcp_stomp_or_xmas2}\n{0-atk_udp_or_gre2, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn5, 4-atk_tcp_ack2, 5-atk_tcp_stomp_or_xmas2, 6-atk_gre2, 7atk_gre2, 8-atk_std_or_udp}\n{0-atk_udp_or_gre2, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn5, 4-atk_tcp_ack2, 5-atk_tcp_stomp_or_xmas2, 6-atk_gre2, 7atk_gre2, 8-atk_udp6}\n{0-atk_udp_or_gre2, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn5, 4-atk_tcp_ack2, 5-atk_tcp_stomp_or_xmas2, 8atk_std_or_udp}\n{0-atk_udp_or_gre2, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn5, 4-atk_tcp_ack2, 6-atk_gre2, 7-atk_gre2, 8-atk_std_or_udp}\n{0-atk_udp_or_gre2, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn5, 4-atk_tcp_ack2, 6-atk_gre2, 7-atk_gre2, 8-atk_udp6}\n{0-atk_udp_or_gre2, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn5, 4-atk_tcp_ack2}\n{0-atk_udp_or_gre2, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn5, 6-atk_gre2, 7-atk_gre2, 8-atk_std_or_udp, 9atk_tcp_stomp_or_xmas2}\n{0-atk_udp_or_gre2, 1-atk_udp_vse1, 2-atk_udp_dns, 3-atk_tcp_syn5, 6-atk_gre2, 7-atk_gre2, 8-atk_std_or_udp}\n{1-atk_tcp_syn1, 3-atk_std_or_udp, 4-atk_std_or_udp, 5-atk_tcp_stomp_or_xmas1}\n{1-atk_tcp_syn10, 2-atk_tcp_ack2}\n{1-atk_tcp_syn5, 2-atk_tcp_ack2}\n{1-atk_udp_vse1, 2-atk_tcp_syn3, 3-atk_tcp_ack_or_synack, 4-atk_std_or_udp, 5-atk_std_or_udp, 6-atk_tcp_stomp_or_xmas3}\n{1-atk_udp_vse1, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7-atk_gre1, 9-atk_std_or_udp, 10atk_http1}\n{1-atk_udp_vse1, 3-atk_tcp_syn1, 4-atk_tcp_ack1, 6-atk_gre1, 7-atk_gre1, 9-atk_std_or_udp, 10-atk_tcp_stomp_or_xmas1, 11atk_tcp_stomp_or_xmas1}\n{3-atk_tcp_syn1, 4-atk_tcp_ack1, 5-atk_tcp_stomp_or_xmas1, 6-atk_gre1, 7-atk_gre1, 10-atk_http1}\n{3-atk_tcp_syn1, 4-atk_tcp_ack1, 6-atk_gre1, 7-atk_gre1, 10-atk_http1}\n{3-atk_tcp_syn1, 4-atk_tcp_ack1, 6-atk_gre1, 7-atk_gre1, 9-atk_std_or_udp}\n{3-atk_tcp_syn1, 6-atk_gre1, 7-atk_gre1, 10-atk_http1}\n{6-atk_gre1, 7-atk_gre1, 10-atk_http1}\n{9-atk_std_or_udp}\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\n```\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order to infiltrate organizations’ dedicated\nenvironments and transform them into attack launchpads. In this article Aditya Sood presents a new module introduced by…\n\n### Collector-stealer: a Russian origin credential and information extractor\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to exfiltrate sensitive data from end-user systems\nand store it in its C&C panels. In this article, researchers Aditya K Sood and Rohit Chaturvedi present a 360…\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and from that moment onward, was intrigued by\nthe properties of these small pieces of self-replicating code. Joe Wells was an expert on computer viruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\nKurt Natvig wanted to understand whether it’s possible to recompile VBA macros to another language, which could then easily be ‘run’\non any gateway, thus revealing a sample’s true nature in a safe manner. In this article he explains how he recompiled…\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware, discussing his team's findings related to the\nC&C design and some security issues they identified during the research.\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\n\n-----\n\n[We have placed cookies on your device in order to improve the functionality of this site, as outlined in our cookies policy. However, you](https://www.virusbulletin.com/about-vb/privacy-policy/cookies)\nmay delete and block all cookies from this site and your use of the site will be unaffected. By continuing to browse this site, you are\n[agreeing to Virus Bulletin's use of data as outlined in our privacy policy.](https://www.virusbulletin.com/about-vb/privacy-policy/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-12-01 - Tracking Mirai Variants (Ya Liu & Hui Wang).pdf"
    ],
    "report_names": [
        "2018-12-01 - Tracking Mirai Variants (Ya Liu & Hui Wang).pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f0bccc3d-ad77-49c4-8dfd-8a8a8d6fba26",
            "created_at": "2024-05-01T02:03:08.134022Z",
            "updated_at": "2025-03-27T02:05:17.415028Z",
            "deleted_at": null,
            "main_name": "NICKEL FOXCROFT",
            "aliases": [
                "Group 123 ",
                "Moldy Pisces ",
                "RICOCHET CHOLLIMA ",
                "Reaper ",
                "ScarCruft ",
                "APT37 "
            ],
            "source_name": "Secureworks:NICKEL FOXCROFT",
            "tools": [
                "ROKRAT"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "9b02c527-5077-489e-9a80-5d88947fddab",
            "created_at": "2022-10-25T16:07:24.103499Z",
            "updated_at": "2025-03-27T02:02:10.108504Z",
            "deleted_at": null,
            "main_name": "Reaper",
            "aliases": [
                "APT 37",
                "ATK 4",
                "Cerium",
                "Crooked Pisces",
                "Geumseong121",
                "Group 123",
                "ITG10",
                "InkySquid",
                "Moldy Pisces",
                "Opal Sleet",
                "Operation Are You Happy?",
                "Operation Battle Cruiser",
                "Operation Black Banner",
                "Operation Daybreak",
                "Operation Dragon messenger",
                "Operation Erebus",
                "Operation Evil New Year",
                "Operation Evil New Year 2018",
                "Operation Fractured Block",
                "Operation Fractured Statue",
                "Operation FreeMilk",
                "Operation Golden Bird",
                "Operation Golden Time",
                "Operation High Expert",
                "Operation Holiday Wiper",
                "Operation Korean Sword",
                "Operation North Korean Human Right",
                "Operation Onezero",
                "Operation Rocket Man",
                "Operation SHROUDED#SLEEP",
                "Operation STARK#MULE",
                "Operation STIFF#BIZON",
                "Operation Spy Cloud",
                "Operation Star Cruiser",
                "Osmium",
                "Red Eyes",
                "Ricochet Chollima",
                "Ruby Sleet",
                "ScarCruft",
                "TA-RedAnt",
                "TEMP.Reaper",
                "Venus 121"
            ],
            "source_name": "ETDA:Reaper",
            "tools": [
                "Agentemis",
                "BLUELIGHT",
                "Backdoor.APT.POORAIM",
                "CARROTBALL",
                "CARROTBAT",
                "CORALDECK",
                "Cobalt Strike",
                "CobaltStrike",
                "DOGCALL",
                "Erebus",
                "Exploit.APT.RICECURRY",
                "Final1stSpy",
                "Freenki Loader",
                "GELCAPSULE",
                "GOLDBACKDOOR",
                "GreezeBackdoor",
                "HAPPYWORK",
                "JinhoSpy",
                "KARAE",
                "KevDroid",
                "Konni",
                "MILKDROP",
                "N1stAgent",
                "NavRAT",
                "Nokki",
                "Oceansalt",
                "POORAIM",
                "PoohMilk",
                "PoohMilk Loader",
                "RICECURRY",
                "RUHAPPY",
                "RokRAT",
                "SHUTTERSPEED",
                "SLOWDRIFT",
                "SOUNDWAVE",
                "SYSCON",
                "Sanny",
                "ScarCruft",
                "StarCruft",
                "Syscon",
                "VeilShell",
                "WINERACK",
                "ZUMKONG",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536011,
    "ts_updated_at": 1743041797,
    "ts_creation_date": 1653751035,
    "ts_modification_date": 1653751035,
    "files": {
        "pdf": "https://archive.orkl.eu/0c714e9f22cae7f8bfafe65e98bb2627d1f78f45.pdf",
        "text": "https://archive.orkl.eu/0c714e9f22cae7f8bfafe65e98bb2627d1f78f45.txt",
        "img": "https://archive.orkl.eu/0c714e9f22cae7f8bfafe65e98bb2627d1f78f45.jpg"
    }
}