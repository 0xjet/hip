{
    "id": "f30f08a0-881e-4fdb-a943-38d6a5ae7d73",
    "created_at": "2023-01-12T15:07:46.545531Z",
    "updated_at": "2025-03-27T02:05:55.338073Z",
    "deleted_at": null,
    "sha1_hash": "acadf08ed86b295a122a8b4fed3e48d577c1c47d",
    "title": "2022-12-19 - [Z2A]Bimonthly malware challege – Emotet (Back From the Dead)",
    "authors": "",
    "file_creation_date": "2022-12-29T00:33:05Z",
    "file_modification_date": "2022-12-29T00:33:05Z",
    "file_size": 1315568,
    "plain_text": "# [Z2A]Bimonthly malware challege – Emotet (Back From the Dead)\n\n**[kienmanowar.wordpress.com/2022/12/19/z2abimonthly-malware-challege-emotet-back-from-the-dead/](https://kienmanowar.wordpress.com/2022/12/19/z2abimonthly-malware-challege-emotet-back-from-the-dead/)**\n\nDecember 19, 2022\n\n## Summary\n\n Sample hash is: fc345d151b44639631fc6b88a979462dfba3aa5c281ee3a526c550359268c694\n\n This write-up of mine will be divided into three parts:\n\n Grab core Emotet Dll payload. Recover API functions that used by core payload. Decrypt strings\n\n1. Grab core payload\n\n## A quick check of information related to sections of this sample shows that it may be crypted/packed to conceal the real malware inside the original sample, besides there is an extra section with an unusual name: text\n\n\n-----\n\n## Load the sample into x64dbg, set a breakpoint at the VirtualAlloc API function, run payload by press F9. It will break at the VirtualAlloc function:\n\n Execute till return (Ctrl+F9) and follow the allocated memory, trace over the ret instruction to return the Dll’s code will reach the code area like the following:\n\n\n-----\n\n## To quickly get the Emotet core payload, set a bp at the ret command below the loop, then press F9 to let the payload finish decrypting and fill core payload content to the allocated memory. The resulting core payload is decrypted as shown below:\n\n Now, dump the above memory to disk, then fix total size of the payload to 0x2B800, we get the final Emotet core Dll (Md5: 577118e39051f0678a52f871f74cd675):\n\n2. API resolver\n\n2.1. Recover Dll name from pre-calculated hash\n\n\n-----\n\n## Load fixed core Dll above into IDA, go to the export function DllRegisterServer we see there are 2 sub routines as follows:\n\n At sub_1800282D0, Emotet will perform:\n\n 1. Get the address of the API function based on the pre-computed hash value. 2. Jump to the API function to execute.\n\n At et_retrieve_api_addr (0x18000F174) function, the code snippet does the following:\n\n 1. Retrieve the base address of the Dll based on the pre-computed hash value. 2. Retrieve the address of the API function belong to the Dll above.\n\n Continuing to dive into the et_get_dll_base_from_hash (0x0180002960) function, the process of getting the base address of the Dll will be as follows:\n\n\n-----\n\n## Based on the above pseudocode, rewrite the hash function in Python for the name of the Dll as follows:\n\n Let’s check again with the name of the Dll is kernel32.dll:\n\n We can write an IDAPython script that recovers the names of the DLLs that Emotet uses from these pre-computed hashes. The script performs the following tasks:\n\n 1. Iterate all addresses refer to et_retrieve_api_addr function. 2. Find the address of the instruction that assigns the hash value of the Dll name and\n retrieve this hash value.\n\n\n-----\n\n## 3. Calculate the hash value based on the list of common DLL names, then compare the\n calculated hash value with the hash value obtained in the previous step. 4. If equal, create a new enumeration that will store the hash-to-dll-name mapping, then\n convert this hash value back to the name of the Dll.\n\n\n-----\n\n```\nimport idc, ida_enum, idautils, ida_bytes, idaapi, ida_bytes\n\nmost_common_dlls =\n['kernel32.dll','user32.dll','ntdll.dll','shlwapi.dll','iphlpapi.dll','urlmon.dll','ws\n 'comctl32.dll', 'comdlg32.dll', 'msvcrt.dll', 'oleaut32.dll', 'srsvc.dll',\n'winhttp.dll', 'advpack.dll', 'combase.dll', 'ntoskrnl.exe']\n\n#---------------------------------------------------------------------\ndef calc_hash(dll_name):\n\n  \"\"\"\"\"\"\n\n  hash_value = 0x0\n\n  module_name_list = []\n\n  module_name_list = list(dll_name)\n\n  for i in range(len(module_name_list)):\n\n    ch = ord(module_name_list[i])\n\n    hash_value = ((hash_value << 0x10) & 0xFFFFFFFF) + ((hash_value << 0x6) &\n0xFFFFFFFF) + ch - hash_value\n\n  # xored value need to change for each payload\n\n  return ((hash_value ^ 0x106308C0) & 0xFFFFFFFF)\n\n#---------------------------------------------------------------------\ndef get_enum_const(constant):\n\n  \"\"\"\"\"\"\n\n  all_enums = ida_enum.get_enum_qty()\n\n  for i in range(0, all_enums):\n\n    enum_id = ida_enum.getn_enum(i)\n\n    mask = ida_enum.get_first_bmask(enum_id)\n\n    enum_constant = ida_enum.get_first_enum_member(enum_id, mask)\n\n    name = ida_enum.get_enum_member_name(ida_enum.get_enum_member(enum_id,\nenum_constant, 0, mask))\n\n    if int(enum_constant) == constant: return [name, enum_id]\n\n    while True:\n\n      enum_constant = ida_enum.get_next_enum_member(enum_id, enum_constant,\nmask)\n\n      name = ida_enum.get_enum_member_name(ida_enum.get_enum_member(enum_id,\nenum_constant, 0, mask))\n\n      if enum_constant == 0xFFFFFFFF:\n\n        break\n\n      if int(enum_constant) == constant: return [name, enum_id]\n\n  return None\n\n#---------------------------------------------------------------------\ndef convert_offset_to_enum(addr):\n\n  \"\"\"\"\"\"\n\n  n_operand = 0\n\n  if idc.print_insn_mnem(addr) == \"push\":\n\n    constant = idc.get_operand_value(addr, 0) & 0xFFFFFFFF\n\n  elif idc.print_insn_mnem(addr) == \"mov\":\n\n    constant = idc.get_operand_value(addr, 1) & 0xFFFFFFFF\n\n    n_operand = 1\n\n  enum_data = get_enum_const(constant)\n\n  if enum_data:\n\n```\n\n-----\n\n```\n    name, enum_id enum_data\n\n    idc.op_enum(addr, n_operand, enum_id, 0)\n\n    return True\n\n  else:\n\n    return False  \n\n#---------------------------------------------------------------------\ndef enum_for_xrefs(func_addr, eid):\n\n  \"\"\"\"\"\"\n\n  for x in idautils.XrefsTo(func_addr, flags=0):\n\n    call_address = x.frm\n\n    if ida_bytes.is_code(ida_bytes.get_full_flags(call_address)):\n\n      #retrieve address of the instruction that assigns the Dll's hash value to\nthe variable\n\n      pre_module_hash_addr = idaapi.get_arg_addrs(call_address)[1]\n\n      if idc.print_insn_mnem(pre_module_hash_addr) == \"mov\" and\nidc.get_operand_type(pre_module_hash_addr, 1) == idc.o_imm:\n\n        print (\"[+] Target instruction found at\n0x{address:x}\".format(address=pre_module_hash_addr))\n\n        pre_module_hash = idc.get_operand_value(pre_module_hash_addr, 1) &\n0xFFFFFFFF\n\n        module_hash_addr = pre_module_hash_addr\n\n      for dll_name in most_common_dlls:\n\n        calced_hash = calc_hash(dll_name)\n\n        if calced_hash == pre_module_hash:\n\n          print ('  [+] Module name: %s ==> Hash: 0x%x' %(dll_name,\ncalced_hash))\n\n          ida_enum.add_enum_member(eid, '%s_hash' % dll_name,\nint(calced_hash), idaapi.BADADDR)\n\n          if convert_offset_to_enum(module_hash_addr):\n\n            print (\"  [+] Converted 0x%x to %s enumeration\" %\n(idc.get_operand_value(module_hash_addr, 1) & 0xFFFFFFFF, dll_name))\n\n#---------------------------------------------------------------------\ndef main():\n\n  \"\"\"\"\"\"\n\n  target_function = 0x018000F174 #change address of function\n\n  '''Adds enum name'''\n\n  if ida_enum.get_enum(\"MODULE_HASHES\") != 0xffffffffffffffff:\n\n    print('Enum already exists ...')\n\n    return 0xffffffffffffffff\n\n  else:\n\n    eid = ida_enum.add_enum(0, \"MODULE_HASHES\", ida_bytes.hex_flag())\n\n  enum_for_xrefs(target_function, eid)\n\nif __name__ == '__main__':\n\n  main()\n\n## The following figures is the result after executing the script:\n\n```\n\n-----\n\n## We get the full list of Dlls that Emotet will use during execution:\n\n\n-----\n\n2.2. Recover API name from pre-calculated hash\n\n## The pseudocode at the et_get_api_addr_from_hash (0x0180025D84) function does the following task:\n\n Based on the above pseudocode, it can be seen that this hash function is similar to the hash function for Dll name above, we can rewrite it in Python in another way as follows:\n\n\n-----\n\n## Double-check with the API name is ExitProcess:\n\n Following this article, we can write python script to perform the following tasks:\n\n 1. Get the list of exported API functions from the list of Dlls obtained above. 2. Calculate the hash, and write the results to a JSON-formatted file as follows:\n```\n   \"api_hash_value\": \"api_name\"\n\n Results after script runs:\n\n```\n\n-----\n\n## Once JSON file has been generated, we can write another IDAPython script (similar to above script or refer to this code) does the following tasks:\n\n 1. Read the JSON data from the previously created into a dict variable. 2. Iterate all addresses refer to et_retrieve_api_addr function. 3. Find the address of the instruction that assigns the hash value of the Dll name and\n retrieve this hash value. 4. Check the hash value if present in the above dict variable, create a new enumeration\n that will store the hash-to-function-name mapping, then convert our hash back to its enumeration name.\n\n Here are the results after script runs:\n\n\n-----\n\n3. Decrypt strings\n\n## To find the function that decrypt the strings, the fastest way is to find the function that calls the LoadLibraryW API because this function will take as an argument the name of the module to be loaded\n\n\n-----\n\n## As the figure above, sub_18002629C will return the name of the module. The pseudocode at\n\n`sub_18002629C` stores its encrypted string as stack string, then calls the et_decrypt_string\n```\n(0x180025C58) function to decrypt:\n\n## The et_decrypt_string function accepts parameters for the decryption process, including:\n\n 1. Length of decrypted string. 2. Multiplier (used for allocating heap memory to store the decoded string). 3. Encrypted string stored as a stack string. These values are all dynamically calculated\n by Emotet and then stored on the stack. 4. Key used for decryption.\n\n The pseudocode of the function as shown below:\n\n 1. Allocate heap memory to store the decrypted string. 2. Execute the loop, load each dword of the encrypted string, perform the xor operation\n with the decryption key, and then assign the value after decryption to the allocated memory.\n\n```\n\n-----\n\n## To verify we can do xor each value as below or through debugging:\n\n As mentioned above, the encrypted string has a variable length and the values of the encrypted string are dynamically calculated by Emotet before being stored to the stack. Therefore, it is difficult to get these values for writing script to perform decryption. Therefore, one of the most possible ways is to write a script that uses IDA Appcall feature to execute a call to the decryption function and receive the decrypted string as the return result.\n\n\n-----\n\n```\nimport idc, idautils, idaapi\n\n#---------------------------------------------------------------------\ndef clean_data(data):\n\n  data = data.rstrip(b'\\x00')   \n\n  if b'\\x00\\x00' in data:\n\n    data = data.split(b'\\x00\\x00')[0].replace(b'\\x00', b'')\n\n  else:\n\n    if data.count(b'\\x00') == 1:\n\n      data = data.split(b'\\x00')[0]\n\n    else:\n\n      data = data.replace(b'\\x00', b'')\n\n  data = data.decode('latin-1')\n\n  return data\n\n#---------------------------------------------------------------------\ndef find_and_decrypt_data(func_addr):\n\n  for call_addr in idautils.CodeRefsTo(func_addr, 1):\n\n    func_call_addr = idaapi.get_func(call_addr).start_ea\n\n    print (\"Found the function call to the decrypt function at: 0x%x\" %\nfunc_call_addr)\n\n    dec_func_name = idc.get_func_name(func_call_addr)\n\n    print (\"Exec function: %s\" % dec_func_name)    \n\n    dec_func_proto = \"wchar_t * __fastcall {:s}();\".format(dec_func_name)\n\n    dec_func = idaapi.Appcall.proto(dec_func_name, dec_func_proto)\n\n    #Call function to decrypt data and clean the decrypted data\n\n    try:\n\n      dec_data = dec_func()\n\n      dec_data = clean_data(dec_data)\n\n      if dec_data:\n\n        print(\"  [-] Decrypted data: %s\" % repr(dec_data))\n\n        print('-----\\n')\n\n    except Exception as e:\n\n      print(\"FAILED: appcall failed: {}\".format(e))\n\n      continue\n\n    #Set comment\n\n    try:\n\n      idc.set_cmt(call_addr, repr(dec_data), idc.SN_NOWARN)\n\n      idc.set_func_cmt(func_call_addr, repr(dec_data), 1)\n\n    except:\n\n      print(\"FAILED: to add comment\")\n\n      continue\n\n#---------------------------------------------------------------------\ndef main():\n\n  \"\"\"\"\"\"\n\n  dec_str_funcs = [0x0180025C58]\n\n  print('[+] Decrypt string function: ', ['0x%x' % routine for routine in\n\n```\n\n-----\n\n```\ndec_str_funcs])\n\n  for func_addr in dec_str_funcs:\n\n    find_and_decrypt_data(func_addr)\n\n#---------------------------------------------------------------------\nif __name__ == '__main__':\n\n  main() \n\n## The final result after script runs:\n\n```\n\n-----\n\n4. References\n\n## End.\n\n m4n0w4r\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-12-19 - [Z2A]Bimonthly malware challege – Emotet (Back From the Dead).pdf"
    ],
    "report_names": [
        "2022-12-19 - [Z2A]Bimonthly malware challege – Emotet (Back From the Dead).pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536066,
    "ts_updated_at": 1743041155,
    "ts_creation_date": 1672273985,
    "ts_modification_date": 1672273985,
    "files": {
        "pdf": "https://archive.orkl.eu/acadf08ed86b295a122a8b4fed3e48d577c1c47d.pdf",
        "text": "https://archive.orkl.eu/acadf08ed86b295a122a8b4fed3e48d577c1c47d.txt",
        "img": "https://archive.orkl.eu/acadf08ed86b295a122a8b4fed3e48d577c1c47d.jpg"
    }
}