{
    "id": "d16bf975-c855-4789-b739-ca92d9db6800",
    "created_at": "2022-10-25T16:48:23.750078Z",
    "updated_at": "2025-03-27T02:05:19.745261Z",
    "deleted_at": null,
    "sha1_hash": "cd96b74b284193b21abeadedfc64e2257545d9db",
    "title": "",
    "authors": "",
    "file_creation_date": "2020-01-20T10:26:14Z",
    "file_modification_date": "2020-01-20T10:26:16Z",
    "file_size": 3138184,
    "plain_text": "-----\n\n## ASEC REPORT\n#### VOL.97 [Q4 2019]\n\n\n###### ASEC (AhnLab Security Emergency-response Center) is a global security response group consisting of malware\n\n analysts and security experts. This report is published by ASEC and focuses on the most significant security\n\n threats and latest security technologies to guard against such threats. For further details, please visit AhnLab,\n\n Inc.’s homepage (www.ahnlab.com).\n\n\n###### SECURITY TREND OF Q4 2019\n\n\n###### Table of Contents\n\n\n-----\n\n-----\n\n###### Security Issue\n\n\n### Endgame: AhnLab vs. GandCrab Ransomware\n\n\n###### GandCrab ransomware, which is no longer active, was actively distributed for about a year\n\n from January 2018 to May 2019. GandCrab variants caused damage worldwide, including\n\n South Korea. AhnLab, a leader in cyber threat analysis, fought against GandCrab ransomware\n\n to mitigate attacks and effectively respond to the constantly changing attack methods.\n\n GandCrab ransomware shares an extraordinary history with AhnLab. Just like any other\n\n ransomware, GandCrab searches for any running or pre-installed anti-malware program before\n\n interfering with its normal execution and shutting it down. However, GandGrab was found\n\n making an extra effort. GandCrab directly targeted ‘AhnLab’ and its anti-malware program, ‘V3\n\n Lite,’ by mentioning it in its code. GandCrab even revealed the vulnerability of AhnLab V3 and\n\n made attempts to delete the program.\n\n To effectively respond and protect against GandCrab attacks, AhnLab analyzed GandCrab and\n\n all its different versions by thoroughly investigating the distributed code, encryption method,\n\n restoration method, and evasive method used to avoid behavioral-based detection. Also,\n\n anytime a new attack feature targeting AhnLab and V3 was identified, the product developers\n\n\n-----\n\n###### promptly addressed it to ensure maximum security.\n\n The conflict between AhnLab and GandCrab Ransomware was a hot topic in both the IT and\n\n security industry. However, what is known is only a tip of the iceberg. This report will provide\n\n the full story of the long and complicated battle between AhnLab and GandCrab ransomware.\n\n 1. The Prelude to War (GandCrab v2.x)\n\n On February 8th 2018, AhnLab announced the active distribution of GandCrab ransomware\n\n in South Korea through its blog. Shortly after, on April 17th, AhnLab publicly released\n\n GandCrab’s Kill-Switch by analyzing how GandCrab works. The kill-switch blocked and\n\n prevented the encryption of files, thus interfering with GandCrab’s operation.\n\n This triggered the war between GandCrab and AhnLab. Three days later, profanity against\n\n AhnLab was found within the mutex name. However, GandCrab creator did not stop here but\n\n continued to express anger towards AhnLab by changing the host address from 'google.com'\n\n to 'ahnlab.com.’ The host address used for C&C server communication and was randomly\n\n adjusted to avoid network filters.\n\nFigure 1-1 | Mutex including profanity towards AhnLab\n\n\n-----\n\n###### The previously announced encryption blocking method was patched, and the internal\n\n version of GandCrab v3.0.0 was updated. However, AhnLab immediately identified a new\n\n method of blocking encryption by utilizing a pop-up message and published this finding.\n\n 2. Adversary Revealed (GandCrab v4.1.x)\n\n By July 2018, GandCrab was being distributed by various methods including drive-by\n download methods, e-mail, executable files, or fileless, based malware. There was even a case\n\n when a malicious script named ‘ahnlab.txt’ was distributed during a fileless attack exploiting\n\n PowerShell.\n\n While AhnLab was dealing with GandCrab in South-East Asia, Fortinet was also analyzing and\n\n responding to GandCrab in real-time halfway across the globe. On July 9th, Fortinet released\n\n an encryption blocking method that stops encryption if there is a ‘<8hex-chars>.lock’ file of a\n\n certain logic.\n\n Based on the information, AhnLab confirmed that the new method was valid for the latest\n\n version, v4.1.1, as well. On July 13th, AhnLab made an executable file tool and distributed it\n\n to the public.\n\n The GandCrab creator retaliated immediately. They included a sarcastic text within v4.1.2\n\n towards both Fortinet and AhnLab by stating that the ‘.lock’ file isn’t the only blocking\n\n method. It then quickly responded by changing the file generation logic for the ‘.lock’ file.\n\n However, AhnLab figured out the logic of v4.1.2 and updated it in their tool as well as for\n\n v4.1.3.\n\n\n-----\n\n###### While the kill-switch mentioned both AhnLab and Fortinet, the slightly modified internal\n\n version of v4.1.2 only included the “ahnlab” string. It also included a specific URL address,\n\n which contained profanity against AhnLab in Russian.\n\nFigure 1-3 | AhnLab string included in the URL\n\n\n-----\n\n###### 3. GandCrab Strikes Back\n\n In August, the creator of GandCrab officially began to strike back. Through an exclusive\n\n interview with BleepingComputer, the creator sent the exploit source and declared\n\n revealment of V3 Lite's zero-day vulnerability. The creator claimed that this was revenge for\n\n the released Kill-Switch. The creator of GandCrab went on explaining that the Kill-Switch is no\n\n longer effective in the latest versions. Then, the internal version of GandCrab v4.2.1 revealed\n\n the attack pattern code for V3 Lite products, stating that AhnLab and GandCrab was finally\n\n even.\n\n\n-----\n\nFigure 1-6 | GandGrab’s message towards AhnLab hidden in GandCrab v4.2.1\n\n###### The alleged attack code could trigger a BSOD if V3 Lite was installed in the system, and was\n\n executed after encryption. AhnLab released an urgent patch immediately following the\n\n exploit, thus preventing any impact from the exploit.\n\n 4. GandCrab’s Full-on Attack\n\n Since then, the creator of GandCrab has made continuous efforts to uninstall the V3 program\n\n through its scripts and those attempts became more sophisticated as time passed.\n\n\n-----\n\n###### The first method used by GandCrab to uninstall V3 was by inducing user-interaction.\n\n Within the distributed script, as shown below in [Figure 1-7], the creator included a code to\n\n specifically drop and run the JS file, which deletes V3 service upon detection.\n\nFigure 1-7 | GandCrab’s distributed script without obfuscation\n\n###### The dropped JS file finds the path to the V3 deletion program and runs the corresponding\n\n uninstaller according to the user’s Windows version, as shown in [Figure 1-8]. Afterward, it\n\n checks for 60 seconds whether or not V3 has been removed.\n\nFigure 1-8 | JavaScript that induces deletion of V3\n\n\n-----\n\n###### Within that 60 second period, if the user clicks the ‘remove button’ it allows the system to run\n\n the notorious GandCrab Ransomware. This method required user interaction, which meant\n\n that the deletion of the program could not be done in the background without the user\n\n knowing it. This critical limit led the GandCrab creator to update its code on September 2018,\n\n to allow the deletion of the V3 program without letting the user know, as shown in [Figure\n\n 1-9]. The upgraded method allowed the V3 uninstallation screen to be hidden from the user's\n\n sight while also automating the click-button process to run GandCrab ransomware.\n\nFigure 1-9 | Main function of the decoded PowerShell\n\n###### A new executable, cmd.exe, was added in addition to the original process, uninst.exe under\n\n Powershell.exe, for GandCrab v5.0. However, it did not stop here. It continuously altered the\n\n structure of its process tree to evade V3's behavioral-based detection. After September 26th,\n\n WMIC.exe was used instead of cmd.exe to uninstall V3 programs.\n\n AhnLab made continuous updates to its anti-malware program, and GandCrab followed along.\n\n It distributed GandCrab v5.0.2 that incorporated uninstallation using the existing Uninst.exe –\n\n\n-----\n\n###### Uninstall, in addition to the AhnUn000.tmp –UC method. As shown in [Figure 1-10], this version\n\n copies the Uninst.exe file to %temp%\\AhnUn000.tmp, uses WMIC.exe to run the file as the -UC\n\n switch, and changes the V3 product-deletion processor to runas.exe.\n\n In its later versions, GandCrab v5.0.3 only used AhnUn000.tmp –UC to execute the deletion\n\n of the program instead of using Uninst.exe, and in v5.0.4, the main agent for the program\n\n deletion had changed to cscript.exe.\n\n**through**\n\nFigure 1-10 | Process structure of uninstalling\n\n###### AhnLab continued to update its product in response to GandCrab’s weekly update through\n\n its script. On November 6th, AhnLab added CAPTCHA to the V3 Lite uninstall program\n\n to prevent automated deletion. As a result, GandCrab was unable to delete V3 after the\n\n application of CAPTCHA, and removed the uninstall function from its distributed script.\n\n\n**through**\n\n\n-----\n\n###### 5. Endgame, the Last Battle\n\n While GandCrab distributed before December 2018 attempted to delete V3 in various ways,\n\n GandCrab v5.0.4 discovered in January 2019 focused on terminating V3’s operation instead of\n\n merely uninstalling it.\n\n The process to disable V3 Lite is shown in Figure 1-11.\n\nFigure 1-11 | Process to disable V3 Lite\n\n###### Before moving onto the next step, GandCrab checks and uses the sleep function to wait\n\n 15 minutes to check if V3 Lite is running. As the first step, an execution file (help22.exe) is\n\n dropped to stop the service. The dropped file locates V3 Lite, and then duplicates Uninst.\n\n exe, the V3 uninstall program, to %UserProfile%\\help.exe. The duplicated help.exe file then\n\n executes ASDCli.exe and stops the command to disable V3 Lite.\n\n AhnLab immediately responded with critical security patches to respond to GandCrab's\n\n update of uninstalling and disabling V3 program. AhnLab deleted ASDCli.exe and prevented\n\n the stop command from being executed. AhnLab also upgraded the product by requiring\n\n an additional string, other than /Uninstall, to remove the product. The long and complicated\n\n battle between GandCrab and AhnLab seemed to have settled down.\n\n\n-----\n\n###### However, the battle was far from the end. GandCrab’s creator continued to insult AhnLab\n\n by adding an insulting text towards AhnLab in GandCrab v5.2. Distributed in February\n\n 2019, GandCrab v5.2 incorporated a time-delay technique to disturb the dynamic analysis.\n\n GandCrab v5.2 included “AnaLab_sucks” text string within the Window procedure class\n\n name that enables the SetTimer function. ‘AnaLab’ can be assumed as a typo for AhnLab.\n\n Nonetheless, the creator of GandCrab consistently mentioned ‘V3 Lite’ and ‘AhnLab’ directly\n\n within their distributed strings.\n\nFigure 1-12 | AhnLab text string that was used as a class name\n\n###### GandCrab v5.2, distributed a month later in March 2019, no longer had the above-mentioned\n\n text. Instead, a text insulting Bitdefender was included in the mutex. However, it was too\n\n soon to assume that the long battle between AhnLab and GandCrab ransomware had ended.\n\n After AhnLab had responded to GandCrab's plot of disabling V3 in January 2019, GandCrab\n\n v5.2 added an evasive function in April to bypass V3's detection. Unlike the previous attempts\n\n to disable V3 Lite, the new feature injected the malware into AhnLab's anti-malware update\n\n program to perform malicious activities.\n\n\n-----\n\n###### The evasive process of the V3 Lite is shown below in [Figure1-13].\n\nFigure 1-13 | Evasive process used by GandCrab to bypass V3 Lite\n\n###### Like the V3 disabling process, it first checks if “V3 Lite” is running. If the service is running,\n\n it uses the sleep function to wait for 20 minutes before moving onto the next step. After\n\n 20 minutes, it searches for AhnLab anti-malware update program, Autoup.exe, then injects\n\n the ransomware execution data into the program. When the injected code is executed, the\n\n encryption process begins. AhnLab quickly released a security patch to address the above\n\n process.\n\nFigure 1-14 | GandCrab announces shutdown of its operation\n\n\n-----\n\n###### As the famous quote, “everything in life has an end,” what seemed like a never-ending battle\n\n between GandCrab and AhnLab came to an abrupt end when GandCrab’s creator announced\n\n the end of its operation on May 31st, 2019. GandCrab’s creator claimed that it made more\n\n than enough through its operation, as stated in [Figure 1-14]. No new variants were released\n\n ever since and GandCrab v5.3 is GandCrab’s last released version.\n\n Conclusion\n\n The battle between GandCrab and AhnLab lasted for 478 days, starting from February 8th,\n\n 2018 – when AhnLab first mentioned GandCrab Ransomware via its blog (https://asec.ahnlab.\n\n com), to May 31st, 2019 – when the creator of GandCrab Ransomware officially announced\n\n the shutdown of its operation.\n\n GandCrab and AhnLab’s battle highlights one if not the most crucial fact, the importance of\n\n collaboration between security vendors and organizations to fight against advanced threats,\n\n such as GandCrab RaaS (Ransomware-as-a-Service). It is also vital for security vendors to\n\n continuously monitor threats and be resilient. It may seem as though the adversaries always\n\n have a head start in the battle of security. However, advanced attacks cannot prevail if\n\n vulnerabilities are promptly addressed and appropriate updates are made. AhnLab’s prompt\n\n actions exemplified this.\n\n AhnLab will continue to monitor security threats in real-time via its threat analysis and anti-malware\n\n program. In continuous efforts to build a strong alliance with other vendors and organizations,\n\n it will provide TI (Threat Intelligence) through various channels. Although GandCrab’s operation\n\n along with its long battle against AhnLab has ended, cyber-battle will never end.\n\n\n-----\n\n-----\n\n###### ANALYSIS-IN-DEPTH\n\n\n### User-Mode Hooking Bypass Techniques\n\n\n###### Behavioral-based engine, within a sandbox or anti-malware, determines and detects\n\n malicious attempts based on the behavior of the malware. User-mode hooking technique\n\n is one of the most prominent techniques used to detect malware behavior. This technique\n\n consists of injecting a DLL file to monitor the behavior of the malware when it is executed\n\n and then hooking the key API functions required to perform the malicious activities. Thus,\n\n when the malware calls a specific key APIs, the monitoring DLL file keeps a log of the APIs\n\n used to determine the behavior of the malware. The DLL file can detect malicious activities\n\n according to the pre-defined rules set by the analyst.\n\n The user-mode hooking technique commonly targets the Native APIs provided by ntdll.dll. It\n\n is because most malware uses resources related to process, memory, or file input. In doing so,\n\n most APIs must call the system call via ntdll.dll. However, as the number of security solutions\n\n utilizing the user-mode hooking technique increases, techniques to bypass the security\n\n products also increases.\n\n The most well-known techniques used to bypass the user-mode hooking are as follows:\n\n checking if the ntdll file is hooked, reloading the ntdll file, and directly calling the system call.\n\n\n-----\n\n###### The first type of evasive method is checking if the ntdll file has been hooked. The malware\n\n reads the ntdll.dll in the system folder and compares the memory with the loaded ntdll file\n\n by process execution. If there is a difference between the codes, the malware determines\n\n that the hooking is enabled, and proceeds to bypass the user-mode hooking by restoring the\n\n loaded ntdll code to the original one.\n\n The second type of evasive method is reloading the ntdll.dll within the process and not\n\n calling the API from the previous loaded ntdll.dll by the process execution, which is not\n\n possible in theory. This report, however, presents how a malware is able to reload the same\n\n dll file using a simple trick.\n\n The last technique is directly calling out the system call. The Native API of ntdll.dll calls out\n\n the system call using a specific number assigned to it when requesting resources to the\n\n kernel. Thus, using the assigned number, the malware can also call out the system call directly\n\n to perform malicious activities.\n\n This analysis report introduces several malware samples along with the techniques used to\n\n bypass the user-mode hooking.\n\n 1. NTDLL Analysis Technique\n\n###### Malware Sample: Parasite HTTP (MD5: 6cd0020727088daeecd462b2d844d536)\n\n Parasite HTTP was first introduced in July 2018. It started by analyzing whether or not the\n\n currently loaded ntdll.dll has been hooked. The malware first loads the ntdll.dll, located in the\n\n\n-----\n\n###### system folder, to the memory and relocates it according to the process.\n\n The malware then compares the API's starting byte of the original ntdll file within the\n\n current process to the API's starting five bytes of the ntdll file, which was directly loaded and\n\n relocated. If the ntdll file of the current process was hooked, the starting five bytes would\n\n have been changed to a branch statement, and therefore, the API’s starting five bytes of the\n\n two does not match. If the two does not match, the malware restores the five bytes’ value\n\n from the original ntdll API's starting five bytes.\n\nFigure 2-1 | ntdll file comparison - (Left) Newly loaded ntdll file, (Right) original ntdll file\n\n###### The following are the list of APIs and key parameters used in this technique.\n\n1) kernel32.CreateFileW()\n\n2) kernel32.GetFileSize() (NtQueryInformationFile)\n\n3) kernel32.VirtualAlloc() as file (or NtAllocateVirtualMemory)\n\n4) kernel32.ReadFile() (NtReadFile) // hFile required\n\n5) kernel32.CloseHandle() (NtClose)\n\n6) kernel32.VirtualAlloc() as process\n\n7) kernel32.VirtualProtect() W authorization (NtProtectVirtualMemory)\n\n8) kernel32.VirtualProtect() W authorization removed (NtProtectVirtualMemory)\n\n\nTable 2-1 | API used by Parasite HTTP to map ntdll file\n\n\n-----\n\n###### NTDLL Reloading Technique\n\n This technique involves reloading the ntdll file from the memory within the process. The\n\n malware then uses the API of the newly loaded ntdll file. Since reloading the same ntdll.dll\n\n within same process is not officially supported, various bypass techniques are used\n\n 2.1) Clone DLL\n\n###### Malware Sample: SmokeLoader (MD5: 393f3d59f3a481446cadecd492a909c9)\n\n If ntdll.dll in the system path is loaded using LoadLibrary() API, the existing handle for ntdll.\n\n dll is restored without going through the remapping process. This is because the ntdll.dll\n\n is already loaded is the current process. Meaning, the result will be restored to the loaded\n\n address instead of reloading as the path and the name are identical. However, if the ntdll.dll is\n\n loaded after being copied in a different path, it may be mapped to another memory area.\n\n SmokeLoader malware copies the ntdll.dll to Temp path, and reloads the ntdll file through the\n\n LdrLoadDll(). Afterward, it uses the APIs of the newly loaded ntdll.dll. Note that this malware\n\n directly uses the LdrLoadDll() API of ntdll.dll instead of the common LoadLibrary() type API of\n\n kernel32.dll.\n\n The following are the list of APIs and key parameters used in this technique.\n\n1) kernel32.CopyFileW() - FROM %system%\\ntdll.dll,TO \\AppData\\Local\\Temp\\D47F.tmp\n\n2) ntdll.LdrLoadDll()\n\nTable 2-2 | Key API of the Clone DLL\n\n\n-----\n\n###### The following is the memory area after the reloading. (Memory addresses are examples)\n\nAddress Size Owner Section Contains Access\n\n0x64DD0000 00001000 D47F_tmp PE header R\n\n0x64DD1000 000D6000 D47F_tmp .text, RT Code, exports R E\n\n0x64EA7000 00009000 D47F_tmp .data Data RW\n\n0x64EB0000 00057000 D47F_tmp .rsrc Resources R\n\n0x64F07000 00005000 D47F_tmp .reloc Relocations R\n\nTable 2-3 | Memory area of the remapped ntdll file\n\n###### 2.2) File Mapping\n\n###### Malware Sample: AgentTesla Packer (MD5: 05e52cdae5537a7edfe3e5fd81765b1f )\n\n###### Malware Sample: Lokibot Packer (MD5: e00008afe709507e67ec48244618ceeb)\n\n Instead of reloading the ntdll file by using the LoadLibrary() type API, the malware creates\n\n a Memory Mapped File in the virtual memory via the file mapping method. The Memory\n\n Mapped File is not recognized as a loaded library and exists mapped inside the memory.\n\n Thus, it can find and call out the API from the mapped area instead of using the API of the\n\n loaded ntdll file.\n\n The following are the list of APIs and key parameters used in this technique.\n\n1) kernel32.CreateFileW() - Acquires ntdll.dll handle\n\n2) kernel32.CreateFileMappingW()\n\n3) kernel32.MapViewOfFile()\n\nTable 2-4 | Key APIs of File Mapping\n\n\n###### 2.3) Section Remapping\n\n###### Malware Sample: Ave_maria Packer (MD5: 286cf47399f885659d42a8364668533c)\n\n\n-----\n\n###### ntdll.LdrLoadDll() API that was mentioned earlier in the “Clone DLL” section internally\n\n calls the following in order when executed: NtOpenFile() ➔ NtCreateSection() ➔\n\n NtMapViewOfSection() API. Both CreateFileMapping() and MapViewOfFile() API that\n\n were mentioned earlier in ‘File Mapping’ technique internally uses NtCreateSection() and\n\n NtMapViewOfSection() API.\n\n The Section Remapping technique is the method that directly uses internal functions of the\n\n following two APIs: NtCreateSection() and NtMapViewOfSection(). Note that if SEC_IMAGE\n\n is allocated to the page property value to set it as an executable image file when creating a\n\n section, permission is granted to each section accordingly.\n\n The following are the list of APIs and key parameters used in this technique.\n\n1) ntdll.RtlDosPathNameToNtPathName_U() - Acquires ntdll.dll path\n\n2) ntdll.NtCreateFile() - Acquires ntdll.dll handle\n\n3) ntdll.NtCreateSection() - (…,SEC_IMAGE,..)\n\n4) ntdll.NtMapViewOfSection()\n\n\nTable 2-5 | Key APIs of Section Remapping\n\n\n###### 2.4) Manual Loading of DLL\n\n###### Malware Sample: Formbook (MD5: df0cf87da787021e9004d815f9650e09)\n\nFigure 2-2 | SNS Post regarding DLL Manual Loading\n\n\n-----\n\n###### Formbook does not use specific APIs during the ntdll file relocation. Instead, it directly\n\n reads the header of ntdll.dll and computes it to relocate it to the memory. The developer of\n\n Formbook has named this technique as ‘Lagos Island Method.’\n\n The malware loads the ntdll.dll via NtReadFile() to the memory, relocates it as a process\n\n after arranging it to fit the file’s structure through an assembly command, then allocates the\n\n memory with RWE permission (NtAllocateVirtualMemory()) and copies it to the memory.\n\nFigure 2-3 | Relocates the data copy to the RWE memory area below\n\n###### The following are the list of APIs and key parameters used in this technique.\n\n1) NtCreateFile() – Acquires ntdll.dll handle\n\n2) RtlAllocateHeap() – Allocates space for NtReadFile() (RW)\n\n3) NtReadFile() – Reads ntdll.dll\n\n4) RtlAllocateHeap() – Allocates space to relocate as a process form (RW)\n\n5) Relocates with assembly command – Process form\n\n6) NtAllocateVirtualMemory() – Allocates space for the new ntdll (RWE)\n\n7) Copies with assembly command\n\n8) Uses API of the new ntdll\n\n\nTable 2-6 | Key APIs of Manually Load DLL\n\n\n###### Unlike previous techniques, there is a ntdll file that has been relocated to the memory area\n\n with an executable property.\n\n\n-----\n\n###### 2.4) Heaven’s Gate\n\n###### Malware Sample: Miner (MD5: ed575ba72ea8b41ac2c31c8c39ce303b)\n\n###### Malware Sample: BlueCrab (MD5: c67d6dea99c657ee5f56b53e7f87d8ba )\n\n The malware requires a 32-bit program to be executed in a 64-bit environment. Standard\n\n hooking modules injects only the 32-bit dll file into the 32-bit program when it is executed.\n\n Heaven's Gate technique, however, allows the 32-bit process to run the x64 command instead\n\n of the x86 command. The malware uses this technique to switch the process to recognize 64\n bit code, and then calls out the API of the 64-bit dll file.\n\n When the 32-bit program is executed in the 64-bit OS, all the ntdll.dll required for the x86 and\n\n the x64 environment are loaded within the process memory, as shown below in [Figure2-4].\n\nFigure 2-4 | 32-bit process with both x86 and x64 ntdll file loaded\n\n###### When the 32-bit process attempts to approach the kernel, a native API of the 32-bit ntdll\n\n file is called out just like the x86 environment. However, since the environment of the\n\n running process is in the x64 environment, 32-bit ntdll file is not the one that calls out the\n\n system call. Instead, the 64-bit ntdll file calls out the system call after switching to 64-bit via\n\n X86SwitchTo64BitMode() API of wow64cpu.dll.\n\n\n-----\n\n###### However, Heaven’s Gate technique does not follow the common process. Instead, when a 32\n bit program is executed in the x64 environment, it allows the process to run the x64 assembly\n\n code instead of the x86 assembly code.\n\n It is done through following steps:\n\n The CS register on the top left side of [Figure 2-5] is 0x23. The interpretation method of the\n\n CPU’s code can vary depending on the value of the register. CPU interprets the CS register as\n\n x86 code if it is 0x23, and x64 code if it is 0x33.\n\n The goal of Heaven's Gate is to change the value of a CS register to 0x33. However, since\n\n the value of the CS register cannot be changed directly, Heaven’s Gate uses the ‘retf’ (return)\n\n command to change the EIP value of x64 code and the value of a CS register to 0x33.\n\n First, it uses ‘push’ to save the retf (0xCB) command and the CS register value (0x0033) to the\n\n [ESP+4] stack. Afterward, it uses the assembly call command to save the address 0x17001b\n\n to stack [ESP] as the return address value. 0x170014h, executed by the call command, is retf\n\n (0xCB), shown below in [Figure 2-6].\n\nFigure 2-5 | Commanding push and call to convert x86 code to x64 code\n\n\n-----\n\n###### When the call occurs, the command ‘retf’ is executed as shown blow in the [Figure 6]. As a\n\n result, esp 4 bytes is changed to eip, and 2 bytes of esp+4 is changed to CS. In other words,\n\n by setting eip as an address that will be read in 64-bit and changing the CS register value to\n\n 0x33, the CPU interprets the address' machine code in 64-bit language.\n\nFigure 2-6 | When configuring eip and CS register via ‘retf’ command, interpreted by 64-bit language\n\n###### It then performs malicious behavior by using the switched x64 code to call out the 64-bit\n\n ntdll functions or loading another 64-bit dll instead of loading the ntdll file to the memory.\n\n Following are examples:\n\n ① Calling out 64-bit ntdll functions – Miner\n\n Miner malware scans the OS architecture to be injected into the 64-bit process. It runs wuapp.\n\n exe for x86 and 64-bit notepad.exe of %WINDIR% path for x64 through ‘suspend.’\n\nFigure 2-7 | (Left) 32-bit malware, (Right) The injection target, 64-bit notepad.exe\n\n\n-----\n\n###### It then uses the previously explained ‘Heaven’s Gate’ technique to convert to x64 code and\n\n imports specific API address by finding 64-bit ‘ntdll.dll’ from the LDR structure of PEB. The\n\n process is same as the one introduced in the open source, and it can be assumed that the\n\n library from the website was used.\n\n - OPEN SOURCE: (HTTPS://GITHUB.COM/RWFPL/REWOLF-WOW64EXT)\n\n The names of APIs imported from 64-bit ntdll file are as follows:\n\nNtGetContextThread\n\nNtReadVirtualMemory\n\nNtUnmapViewOfSection\n\nNtAllocateVirtualMemory\n\nNtWriteVirtualMemory\n\nNtSetContextThread\n\n\nTable 2-7 | API to be called out after the switching\n\n\n###### API that was introduced in [Table 2-7] is the API frequently refer to as the process hollowing. It\n\n approaches the PEB of a suspended notepad.exe process and imports ImageBaseAddress. After\n\n that, it frees the imported address and allocates memory equal to the amount of PE (miner) for\n\n injection, and injects the malicious PE. Finally, it manipulates ImageBaseAddress of PEB as the\n\n allocated memory address and manifests PE injected through ResumeThread() API.\n\n ② Loading 64-bit dll files to the memory – BlueCrab Ransomware\n\n BlueCrab ransomware scans the user’s OS architecture before exploiting CVE-2018-8453, the\n\n system privilege escalation vulnerability. For the x86 environment, the privilege escalation\n\n occurs through the vulnerability routine, while Heaven’s Gate technique is used to execute\n\n\n-----\n\n###### the vulnerability routine for the x64 environment.\n\n BlueCrab uses 64-bit ntdll.LdrLoadDLL() to additionally load various 64-bit dll files, such as\n\n gdi32.dll, msvcrt.dll, kernel32.dll, kernelbase.dll, and rpcrt4.dll. If the x64 dll files loaded is not\n\n hooked like the x86 dll file, it can be assumed that the malware has successfully bypassed the\n\n hooking.\n\nFigure 2-8 | (Left) Before Heaven’s Gate technique is used, (Right) various x64 dll files loaded with the use of Heaven’s Gate\n\n###### The differences can be clearly seen by comparing the 'File name' tab between the left and\n\n right side, focusing on 64-bit dll files that exist in ..\\System32\\ path, as shown in the [Figure\n\n 2-8]. It shows that 64-bit dll files can be mapped to the 32-bit process.\n\n User-mode hooking techniques commonly only hook x86 dll files for x86 programs and\n\n leaves out x64 dll files. However, as shown in the samples, monitoring becomes impossible\n\n for the APIs of 64-bit ntdll files, used after the deployment of the Heaven’s Gate technique.\n\n AhnLab’s analysis indicated that for the sample, only the 32-bit hooking module (MeDVpHkU.\n\n\n-----\n\n###### dll) was loaded to the process memory when a 32-bit program was executed in the 64-bit OS.\n\n Only the 32-bit dll files was targeted for hooking. Therefore, it can be assumed in [Figure 9]\n\n that for the samples using the technique, 64-bit dll file was not hooked.\n\nFigure 2-9 | (Top) Original 32-bit user32.dll, (Bottom) newly mapped 64-bit user32.dll\n\n###### 3. Direct System Call\n\n###### Malware Sample: Trickbot (MD5: 104b457b6d90fc80ff2dbbcebbb7ca8b)\n\n For the key APIs related to the injection, Trickbot directly organizes and calls the system call\n\n without going through APIs such as ntdll. APIs that are targeted by the direct system call are\n\n all related to the injection. It is as shown below:\n\nNtUnmapViewOfSection()\n\nNtCreateSection()\n\nNtMapViewOfSection()\n\nNtWriteVirtualMemory()\n\nNtResumeThread()\n\nTable 2-8 | APIs targeted by Direct System Call\n\n\n###### The number of system call varies depending on the Windows version. That is why the malware\n\n needs to go through the process of saving the number of a target system call. Trickbot brings\n\n\n-----\n\n###### the whole path of ntdll after referring to the LDR__Module structure when calling the system\n\n call. It brings the path of the ntdll.dll (system32 folder in x86 environment, and syswow64 folder\n\n in x64 environment) and loads the ntdll.dll to the memory allocated with VirtualAlloc() via\n\n ReadFile(). The rest of the process is similar to that of Manually Loaded DLL.\n\n The difference between the two techniques, however, is that the technique above only grants\n\n RW authorization instead of RWE, and only VirtualFree() the memory once the malware acquires\n\n the number of the target system call.\n\n The system call number is acquired via the following steps. Assume that the system call number\n\n which is put into EAX for NtWriteVirtualMemory() is 0x18F. Trickbot first finds the address of\n\n NtWriteVirtualMemory() and then acquires the number 0x18F through the 4-bytes value that\n\n follows after 0xB8, which is the “MOV EAX” command.\n\nFigure 2-10 | System call number of NtWriteVirtualMemory() is 0x18F\n\n\n###### The following is the function for acquiring system call number, and the routine to directly call\n\n it. Taking a look at the address, it can be seen that Trickbot's codes have been fully executed,\n\n including the part where system call can be called without having to use KiFastSystemCall() API\n\n within the ntdll file.\n\nFigure 2-11 | (Top) Functions before importing the NtWriteVirtualMemory() number, (Bottom) Same as KiFastSystemCall()\n\n\n-----\n\n###### The following are the list of APIs and key parameters used in this technique.\n\nRepeats at each instance of calling system call\n\n1) kernel32.CreateFileW() – Acquires ntdll.dll handle\n\n2) kernel32.GetFileSize() – Finds ntdll.dll size\n\n3) kernel32.VirtualAlloc() - Allocates space for ReadFile() (RW)\n\n4) kernel32.ReadFile() – Reads ntdll.dll\n\n5) kernel32.VirtualAlloc() – Allocates space for relocation in the form of process (RW)\n\n6) Relocates through asm command\n\n7) Finds system call number through asm command\n\n8) Executes direct system call\n\n\nTable 2-9 | Direct system call’s overall process and APIs\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/Report/AhnLab/ASEC_REPORT_vol.97_ENG.pdf"
    ],
    "report_names": [
        "ASEC_REPORT_vol.97_ENG"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716503,
    "ts_updated_at": 1743041119,
    "ts_creation_date": 1579515974,
    "ts_modification_date": 1579515976,
    "files": {
        "pdf": "https://archive.orkl.eu/cd96b74b284193b21abeadedfc64e2257545d9db.pdf",
        "text": "https://archive.orkl.eu/cd96b74b284193b21abeadedfc64e2257545d9db.txt",
        "img": "https://archive.orkl.eu/cd96b74b284193b21abeadedfc64e2257545d9db.jpg"
    }
}