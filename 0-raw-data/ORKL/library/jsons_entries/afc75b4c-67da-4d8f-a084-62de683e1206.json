{
    "id": "afc75b4c-67da-4d8f-a084-62de683e1206",
    "created_at": "2023-01-12T15:06:07.162663Z",
    "updated_at": "2025-03-27T02:10:07.352248Z",
    "deleted_at": null,
    "sha1_hash": "20bf56bf1e7a363222f7f1535be6b6d6ad1bb801",
    "title": "2022-02-25 - The Hunt for the Lost Soul- Unraveling the Evolution of the SoulSearcher Malware",
    "authors": "",
    "file_creation_date": "2022-05-28T19:12:48Z",
    "file_modification_date": "2022-05-28T19:12:48Z",
    "file_size": 418009,
    "plain_text": "# The Hunt for the Lost Soul: Unraveling the Evolution of the SoulSearcher Malware\n\n**[fortinet.com/blog/threat-research/unraveling-the-evolution-of-the-soul-searcher-malware](https://www.fortinet.com/blog/threat-research/unraveling-the-evolution-of-the-soul-searcher-malware)**\n\nFebruary 25, 2022\n\nA [threat report published by Symantec in October 2021 recently caught our attention. It discusses an](https://symantec-enterprise-blogs.security.com/blogs/threat-intelligence/espionage-campaign-south-east-asia)\nunknown threat actor conducting an espionage campaign in Southeast Asia using a new custom malware\narsenal. What piqued our curiosity most was the mention of a DLL payload loaded from the registry that\nhad yet to be discovered.\n\nThe reason the module was difficult to find became apparent after analyzing its loader. The module is\nstored as a compressed blob with a custom header in the registry. It is never written to disk, rendering it\nunlikely to appear in datasets like VirusTotal.\n\nAnd so, we embarked on a journey to hunt for the lost module. We have now uncovered a sample of the\nmodule and a plethora of components and variants dating as far back as 2017. Reverse engineering the\nsamples has allowed us to observe the progression of the development of this malware throughout the\nyears. Over time, custom code was added, components were upgraded, capabilities expanded, the code\nbecame neater, and modularity increased.\n\n\n-----\n\nThis blog will examine the different components of this malware and their progression over time, thereby\nmapping the evolution of the Soul malware framework.\n\n**Affected Platforms: Windows**\n**Impacted Users: Windows Users**\n**Impact: Collects sensitive information and executes additional malicious modules**\n**Severity Level: Critical**\n\n## Theory of Evolution\n\nIn the earliest phase, the attackers used a backdoor that incorporated code of the open-source Gh0st RAT\nand NetBot Attacker tools, albeit with considerable modifications. The backdoor is embedded as a\ncompressed blob in its dropper executable, which writes it to disk and runs it.\n\nWithin a year, the backdoor’s code was refactored and had custom code added to it, completing its\ntransformation into what we refer to as a Soul module. Its loader, which we dubbed SoulSearcher,\nchanged as well. Instead of dropping the payload to disk, the compressed module is stored in the registry\nand is loaded in-memory.\n\nSince the beginning of 2020, we have detected increasingly intricate SoulSearcher variants, some of\nwhich support loading multiple modules from the registry. They have significantly transformed over time,\nand their configuration artifacts shed light on possible Soul module capabilities.\n\nAside from the backdoors, additional tools were used, such as keyloggers and a custom-compiled 7zr tool\n(reduced standalone 7-zip).\n\nA complete timeline of the various components is depicted below, beginning in 2017 with the first\nkeylogger and backdoor and ending with the recent SoulSearcher variants found in November 2021.\n\nFigure 1: Timeline of the Soul malware framework\n\nSide note: This timeline is based on compilation timestamps, and although these can be tampered with, in\nthe case of this malware framework, we consider them to be authentic. This is partly because the time\ndistribution of the collected samples correlates with our understanding of the components’ capabilities and\ntheir sightings in the wild. Furthermore, related samples such as loaders and their payloads were compiled\nwithin seconds of each other.\n\nSeveral characteristics are common in all of the components we found:\n\n[DynamiCall import obfuscation from the leaked source code of the notorious Hacking Team’s](https://github.com/hackedteam/core-win32/blob/master/DynamiCall/dynamic_import.cpp)\nRCS backdoor\nStack strings\nData structure similarity, such as the configuration structure\nEncryption and compression algorithms\nNames of mutexes, events, and file mappings\nAdjacent compilation timestamps\n\n## The Original Soul Backdoor\n\nThis is the backdoor used in the earliest phase by the threat actor. It was compiled in October 2017 and\nused revised code from public repositories and other malware leaked online, such as:\n\n\n-----\n\nDynamiCall\nGh0st RAT\n\nFile manipulation functions\nCMD shell code\nCommunication messages and structures\nHTran (an open-source connection bouncer tool)\n7zip\n\nThe backdoor is a DLL dropped to the disk by a simple dropper. The dropper LZMA-decompresses the\nbackdoor and a configuration that they both share. The dropper writes the backdoor to a path specified by\nthe configuration and appends the configuration to it as an overlay. Depending on the command-line\nargument passed to the dropper, the backdoor is executed with LoadLibrary or rundll32.exe. Finally, the\ndropper deletes itself from the disk.\n\n### Configuration\n\nThe backdoor reads its configuration from its file overlay and decrypts it by subtracting and XORing each\nbyte with 0x13.\n\nThe configuration begins with a sequence of bytes whose significance is unknown but is identical in all the\nsamples we found. Other fields are the backdoor file name or full path, the C2 address, and the port in\nlittle-endian. The configuration also contains a service name and description, both unused. In one sample,\nthe string “NetBot” is set as the file name.\n\nFigure 2: Configuration for the backdoor\n\nTwo other fields, an array of DWORDs and a flag (highlighted at offset 0x1f0), control if and when the\nbackdoor should suppress command-related communication.\n\nThe array's values determine the days and hours to accept commands. In this sample, all values are 2.\nEach index represents a particular day of the week and the hour of the day. If the value at a given index is\n0, requests for commands are withheld on the corresponding day and hour.\n\nThe flag determines if receiving commands should be suppressed while there is activity on the machine,\naccording to the following conditions:\n\nOther than the current session, there is an active console session in the system\nOther than the current session, there is an active or connected RDP session in the system\n\nThe sessions are monitored by using the WTSRegisterSessionNotification and WTSEnumerateSessions\nAPIs.\n\nDepending on the configuration, the backdoor can receive commands in active mode (as a client) or\npassive mode (as a server). There are two port numbers, one for each mode.\n\nIf the server port is not 0, the backdoor contacts the server to receive commands.\nIf the listening port is not 0, the backdoor listens on that port and awaits commands from incoming\nconnections (only one connection may be active at a time).\n\n### Communication\n\n\n-----\n\nMessages to the C2 server, including requests for commands, have a fixed structure. Every request to the\nserver is composed of hardcoded HTTP headers impersonating legitimate network traffic to taboola[.]com.\n\nFigure 3: Constant HTTP headers sent in requests to the server\n\nThe structure of the HTTP body sent to the server is depicted below. CompressedBuffer is zlib-deflated\ndata.\n```\n  struct BackdoorRequest {\n       DWORD MessageType;\n       DWORD DecompressedBufferSize;\n       DWORD DecompressedBufferSize;\n       DWORD CompressedBufferSize;\n       BYTE \n  CompressedBuffer[CompressedBufferSize];\n  };\n\n```\nFigure 4: Format of message body sent by the backdoor\n\nReceipt of commands begins when the backdoor sends information about the machine to the server with a\nMessageType of 0x11000000:\n\nHostname\nIP address(es)\nCPU architecture\nRAM size\n\nThe server response structure is similar to that of the request:\n```\n  struct ServerResponse {\n       DWORD CommandType;\n       DWORD DecompressedBufferSize;\n       DWORD DecompressedBufferSize;\n       DWORD CompressedBufferSize;\n       BYTE \n  CompressedBuffer[CompressedBufferSize];\n  };\n\n```\nFigure 5: Format of server response message body for backdoor requests\n\nIn a separate thread, the backdoor may signal the server if command receipt suppression is currently in\neffect with MessageType 0x1100000B.\n\n### Commands\n\n\n-----\n\nWhen the server sends a command, it is one of the CommandType values in the table below, and the\nCompressedBuffer field is empty. The backdoor sends out an additional request for the command's\nparameters, with a MessageType value specified according to the specific command.\n\nType Name\n\n0xFFFFFFFF There are no commands to run.\n\n0x20000000 Close the socket and stop receiving commands.\n\n0x21000000 File manipulation functions that include moving, copying, deleting, downloading, and/or\nuploading files.\n\n0x23000000 It opens an interactive CMD shell, allowing the attacker to execute CMD commands\nuntil terminating the shell by sending the “Exit” command.\n\n0x38000000 [transmitdata function of HTran.](https://github.com/HiwinCN/HTran/blob/master/Windows_Version/HTran.cpp#L503)\n\nFigure 6: Table of commands implemented by the backdoor\n\nThe same is true when the backdoor works in passive mode, except it is limited to handling file\nmanipulation, CMD, and close socket commands.\n\n## The Soul-Searching Loaders\n\nSoulSearcher is a type of second-stage loader seen in the wild since November 2018. All the samples we\nfound are DLLs with a similar flow of operation. They are responsible for executing the Soul module\npayload and parsing its configuration.\n\nThe major differences between the SoulSearcher variants are the type of configuration passed to the\npayload and the location where the configuration and payload are stored.\n\n**Configuration Format** **Date of Earliest Sample** **Configuration Location** **Payload Location**\n\n\n**Binary** Nov 2018 Overlay + registry\nFile\n\n**XML** Apr 2020 Registry\nFile mapping\nFile\n\n\nOverlay\nFile\n\nRegistry\n\n\n**Semicolon-separated** Aug 2021 Embedded in SoulSearcher Registry\n\nFigure 7: Table of SoulSearcher types\n\n### Binary SoulSearcher\n\n\n-----\n\nThese are the earliest SoulSearcher samples in our possession. One of these samples has its payload—a\nSoul module—embedded in it. Every sample exports two functions: DumpAnalyze and DumpAnalyzeEx.\n\nFirst, SoulSearcher searches for the module and configuration, either in its overlay data or files on the\ndisk. If they are found, it saves the module to the registry. Regardless, SoulSearcher then fetches the\npayload from the registry, reflectively loads it, and passes the configuration to it as an argument.\n\nThe configuration is located at the end of the overlay and is decrypted using SUB-XOR 0x13. It has the\nsame format as that of the original Soul backdoor, with an additional field that determines the size of the\ncompressed Soul module in the overlay. Another part of the configuration is retrieved from the\nHKCU\\Software\\OIfkO2i1 registry value and decrypted with SUB-XOR 0x79. If it doesn’t exist, this path is\nalso queried in the other users’ registry hives.\n\nIf the argument “-h <HANDLE>” was passed to the SoulSearcher’s export, the configuration and the\npayload are extracted from sdc-integrity.dat instead of the overlay. They are extracted in the exact same\nway as before. The supplied argument is a handle to a DLL used to retrieve the directory path in which the\n.dat file resides.\n\nIn any case, the module is saved to the registry at HKCU\\Software\\kuhO6Ba0kT.\n\n### XML SoulSearcher\n\nEvery XML SoulSearcher begins with obtaining the configuration previously dropped by an unknown\ncomponent. Most samples retrieve it from the registry, and some have the option of retrieving it from a file\nmapping object or a file on the disk.\n\nFor example, one sample retrieves the configuration from one of the following, depending on whether it is\nrunning as a service:\n\nA value name in the format of a GUID under the service parameters at\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\<ServiceName>\\Parameters\nA file mapping object named Global\\CacheDataMapping\n\nThe retrieved binary data has the following structure:\n\n\n-----\n\n```\n  struct StoredConfiguration {\n       DWORD Magic;\n       DWORD Unused;\n       BYTE LzmaProperties[5];\n       DWORD ConfigSize;\n       DWORD CompressedConfigSize;\n       BYTE ConfigMD5[0x21];\n       BYTE CompressedConfigMD5[0x21];\n       BYTE \n  CompressedConfig[CompressedConfigSize];\n  };\n\n```\nFigure 8: Structure of configuration fetched from the registry\n\nThe structure is processed in the following manner to retrieve the XML configuration:\n\n1. Verify that the size of CompressedConfig is equal to CompressedConfigSize\n2. Verify that CompressedConfigSize and ConfigSize are not 0\n3. Verify that both MD5 checksums are not 0\n4. Ensure that Magic  holds the byte sequence 86 AE 00 00\n5. Perform MD5 checksum validation of the compressed configuration\n6. LZMA-decompress the configuration\n7. Perform MD5 checksum validation of the decompressed configuration\n\nIn one variant, an extra step is taken at the start to decrypt the registry data using AES-256 CBC. The key\nis retrieved from one of two hardcoded paths.\n\nOlder samples deserialize the resulting string with the CreateXmlReader API, while newer samples use\nthe TinyXML open-source library. The XML attribute names shed light on the Soul modules loaded from\nthe registry.\n\n### Semicolon SoulSearcher\n\nBeginning in August 2021, SoulSearcher variants began using a hardcoded semicolon-separated\nconfiguration instead of an XML one from the registry. The first variant of this type was compiled just over\na full month before the release of Symantec’s report.\n\nFigure 9: Example of a semicolon-separated configuration\n\n\n-----\n\nThis configuration lacks the indicative XML attribute names, like those in the XML configurations, resulting\nin a more obscure tool. Nevertheless, here is what we can say about some of these fields:\n\nWe believe the first field, do5Kc1diLHgq5f6 represents the configuration type. In the XML\nconfigurations, the type is represented by the string X6bmLMbAL29AlxB.\nOne of the values states whether the SoulSearcher was installed as a service. If so, the\nconfiguration includes fields for details about the service, such as its name.\nSome of the values determine which Soul modules should be loaded.\nOne field may contain a registry path from which to load a Soul module (while other modules are\nloaded from hardcoded paths).\n\n## When the Soul is Found\n\nOlder SoulSearcher variants load a single Soul module, while some more recent XML and Semicolon\nSoulSearchers may load up to four, depending on their configuration.\n```\n  struct StoredModule {\n       DWORD Unused;\n       QWORD ModuleSize;\n       QWORD CompressedModuleSize;\n       BYTE ModuleMD5[0x21];\n       BYTE \n  CompressedModule[CompressedModuleSize];\n  };\n\n```\nFigure 10: Structure of the payload fetched from the registry\n\nEvery module is fetched from the registry in a similar manner as the configuration:\n\n1. Verify that the size of CompressedModule is equal to CompressedModuleSize\n2. LZMA-decompress the module\n3. Perform MD5 checksum validation of the decompressed module\n4. Ensure that the architecture of the module matches the architecture of the SoulSearcher\n\nThis procedure is identical in every SoulSearcher sample apart from the Binary SoulSearchers, whose\nstructure slightly differs.\n\nThe SoulSearcher reflectively loads the module in-memory and calls its Construct export. Some earlier\nvariants also call additional exports of the module.\n\n## Soul Backdoor Reincarnated\n\nWe found that one Binary SoulSearcher sample from November 2018 had an embedded payload.\n\nThis Soul module closely resembles the original backdoor in terms of functionality, although its code is\nmuch neater. Thorough examination revealed that the code of the original backdoor was reorganized as\nvarious exports. For instance, the code responsible for sending and receiving HTTP messages was\ndivided into the SendMsg and RecvMsg exports.\n\n\n-----\n\nFigure 11: Soul backdoor module exported functions\n\n### Configuration\n\nThe SoulSearcher calls the module’s BeginConnect export with the configuration as an argument. The\nconfiguration has the same binary format as the original backdoor’s configuration but without the servicerelated fields.\n\nFigure 12: Configurations of the original backdoor (left) and the newer backdoor module (right)\n\n### Communication\n\nUnlike the original backdoor, this Soul module only receives commands as a client.\n\nIf resolving the server address via gethostbyname API fails, the backdoor also tries querying two\nhardcoded DNS servers using an undocumented feature of the DnsQuery API:\n\n193.0.14.129 (DNS root server)\n8.8.8.8 (Google Public DNS)\n\nThe constant headers of the request have been changed to impersonate traffic to s-microsoft[.]com, and\nthe GetSubInfo export collects the machine information.\n\nFigure 13: New constant HTTP headers sent in requests to the server\n\n### Commands\n\nThe message structures are the same as those of the original backdoor. As seen in the table below,\nseveral new command codes were not present in the original backdoor. When one of the five named\ncommands is received, the backdoor downloads and executes a DLL from the server. The command\nnames are disclosed in the binary and are passed to the command DLLs as part of their arguments.\nBecause the DLLs themselves are unknown to us, we can only speculate on their functionality based on\ntheir names and the implementations of the same command types in the original backdoor code.\n\nType Name\n\n0xFFFFFFFF There are no commands to run.\n\n0x20000000 Close the socket and stop receiving commands.\n\n0x21000000 **File**\n\n0x23000000 **Cmd**\n\n0x38000000 **Htran**\n\n0x39000000 Update configuration in the registry. The server response buffer is ADD-XOR 0x79\nencrypted before being written to the registry (hardcoded path).\n\n\n-----\n\n0x3A000001 Free command structures and release command-related mutexes.\n\n0x3B000000 **MemoryLoader**\n\n0x3C000000 **UsbNtf**\n\nFigure 14: Table of commands implemented by the backdoor module\n\nAn additional socket connection is created to download a command DLL from the server. First, the\nbackdoor sends a message of type 0x1100000C with a buffer that contains the constant value\n0x4096C083. Like all requests, it is sent via SendMsg in the aforementioned BackdoorRequest structure.\nNext, it sends another message of the same type, but this time the buffer is structured as shown below.\nThe Architecture field contains a value of either 32 or 64 depending on the backdoor’s architecture.\n```\n  struct CommandRequest {\n       DWORD\n  CommandType;\n       BYTE \n  Architecture[6];\n  };\n\n```\nFigure 15: Structure of request for a command DLL from the server\n\nThe server replies to the backdoor with the following structure:\n```\n  struct CommandResponse {\n       DWORD Unused0;\n       BYTE Unused1[6];\n       QWORD ModuleSize;\n       QWORD CompressedModuleSize;\n       BYTE ModuleMD5[0x21];\n       BYTE CompressedModuleMD5[0x21];\n       QWORD Unused2;\n       BYTE \n  CompressedModule[CompressedModuleSize];\n  };\n\n```\n\n-----\n\nFigure 16: Structure of server response for a command DLL\n\nThe backdoor uses the structure to load the command DLL in the following manner:\n\n1. Validate MD5 checksum of compressed module\n2. LZMA-decompress the compressed module\n3. Validate MD5 checksum of decompressed module\n4. If steps 2 or 3 fail, reissue the request to the server\n5. Reflectively load the module in memory\n6. Call the module’s Construct export with arguments that include, among other things:\n\n1. The constant value 0x4096C083 (same value sent to the server priorly)\n2. The name of the command (such as “File” or “UsbNtf”)\n3. The backdoor configuration\n4. The CommandResponse structure received from the server\n\n## More Souls Than One\n\nAs mentioned earlier, each XML SoulSearcher parses an XML-formatted configuration that contains\nattributes with informative names. Based on such artifacts, we were able to classify potential payloads of\nvarious samples in our possession.\n\n**Backdoor**\n\nThese SoulSearcher samples are closely coupled to their payloads to the extent that they are intricate\norchestrators rather than plain loaders. In addition to parsing a configuration, they invoke multiple exported\nfunctions of the Soul module to create full backdoor logic. The configuration fields and imported function\nnames indicate remote shell capability and the utilization of Dropbox.\n\nConfiguration Fields Exports Names\n\n\nIp\nDns\nCntPort\nLstPort\nBlog\nDropboxBlog\nSvcName\nSvcDisp\nSvcDesc\nSvcDll\nOlPass\nOlTime\nSelfDestroy\n\n\nConstruct\nConnectHost1\nForceCloseSocket\nCopyReserveMem\nRecv\nRecvEx\nSend\nSendEx\nBindShell\nAccept\nTransmitData_htran\nKillChildenProcessTree\nExtractIPToConnect\nExtractIPToConnect1\nGetDeviceInfoString1\nGetPseudoSocketInfo\nDecrypt_ByteToByte\n\n\nFigure 17: Configuration fields and imported function names seen in older SoulSearcher versions\n\n**Advanced RAT**\n\n\n-----\n\nOne SoulSearcher parses numerous configuration fields different from the backdoor:\n\n\nAesPass\nClipBoardMntEnable\nDestroyDate\nDestroyDay\nDestroyMode\nDestroyWiFiName\nDestroyWiFiSearchMinu\nDirDiskInternal\nDropboxAppToken1\nDropboxAppToken2\nDropboxAppToken3\nEnableDropbox\nEnableFileMnt\nEnableHijack1\nEnableKeyLog\nEnableService\nExcludeDir\nFileExt\nFileSizeMb\nHijack1DllPath\nHijack1RegSubKey_MemMod1\nHijack1RegValueName_Cfg\nHijack1RegValueName_MemMod1\nIncludeDir\nRecDataPath\nRegKey_Exist\nRegKey_Rec\n\n\nRegSubKey_Exist\nRegSubKey_Rec\nRegValueDataSz\nRegValueName_Exist\nRegValueName_Rec\nSaveInFile\nSaveInReg\nScreenMngEnable\nServiceDescription\nServiceDisplayName\nServiceDllPath\nServiceHide\nServiceImagePath\nServiceName\nServiceRegValueName_Cfg\nServiceRegValueName_MemMod1\nServiceRegValueName_MemMod2\nServiceRegValueName_MemMod3\nServiceSessionIsolationBypass\nTriggerTime\nUsbExt\nUsbExtMode\nz7zPass\nz7zSizeMb\nz7zStoreDir\n\n\nFigure 18: Configuration fields found in one SoulSearcher sample\n\nIf the EnableDropbox attribute is set to true, the SoulSearcher loads a module from the path specified by\nServiceRegValueName_MemMod3. If the EnableKeylog  is set, a module is loaded from the path specified\nby ServiceRegValueName_MemMod1.\n\n**Proxy**\n\nThese samples’ configuration indicates proxy capabilities over HTTP and HTTPS, as well as the ability to\nrun CMD commands.\n\n\nCmdPrefix\nCmdSuffix\nEnableHttps1\nPort\nPort2\nProxyIP1\nProxyIP2\nProxyPort1\nProxyPort2\nProxyUserName1\nProxyUserName2\nProxyUserPass1\n\n\nEnableHttps2\nInterval\nMachineGUID\nProxyUserPass2\nRegPath\nRegRootKey\nRegValueName_Cfg\nRegValueName_Svr32\nRegValueName_Svr64\nURL2\nUrl\n\n\n-----\n\nFigure 19: Configuration fields related to proxy functionality\n\n## Additional Components\n\n### First Stage Loader\n\nAs mentioned before, SoulSearcher is a second-stage component. We also identified a first-stage loader\nof the Binary SoulSearcher variant.\n\nThis loader is a DLL with a single exported function, named SntpService, and depends on a utility DLL\nnamed SntpService.dll, which is expected to already reside on disk. These names are likely used to\n[resemble a legitimate security software product of Sophos of the same name (as seen here).](https://www.processchecker.com/file/SntpService.exe.html)\n\nThe loader checks if its process name is either MSDTC.exe or svchost.exe prior to running SntpService in\na new thread. In the latter case, a mutex named DBWinMutex_1 is created (also used in the Soul module).\n\nThe loader performs two operations. First, it decrypts two .dat files from its directory and saves the output\nto the registry:\n\nsdc-integrity.dat is written to HKCR\\.rat\\PersistentHandler\\TypeFace\nscs-integrity.dat is written to HKCR\\.rat\\PersistentHandler\\MagicNumber\n\nThe decryption scheme is AES-256 CBC with the SHA256 hash of a hardcoded value used as the key.\nBoth files are then deleted from the disk, implying this procedure occurs only on initial infection or when\nupdates are deployed.\n\nSecond, the data from the TypeFace  value is used to load SoulSearcher. It consists of a structure that\ncontains a buffer and its size. The loader skips the buffer’s last 0x3d0  bytes, as those are its configuration,\nand passes the rest of the buffer to the Decrypt_ByteToByte function of SntpService.dll. The output is a\nPE, which the loader reflectively loads and then invokes its DumpAnalyze  export. The loader passes a\nhandle of itself to the SoulSearcher as an argument, both as a pointer and in string format: “-h\n<HANDLE>”.\n\nAdditional exports of SntpService.dll are also resolved:\n\nFigure 20: Imported functions from SntpService.dll\n\nWe found a variant of the utility DLL uploaded to VirusTotal with the name of Kaspersky Antivirus’s\nAvpCon.dll. Similar to the Sophos case cited earlier, this is likely done to appear legitimate. Despite its\nexports being named “Encrypt” and “Decrypt”, all functions actually perform LZMA compression or\ndecompression. This correlates with a Binary SoulSearcher sample that we found compressed, not\nencrypted.\n\nFigure 21: Exports of AvpCon.dll\n\n**Keyloggers**\n\nThe keyloggers were compiled between mid-2017 to late 2020. They all share very similar code, with few\nchanges between them. In addition to the keyloggers Symantec reported on, we found another sample\nfrom September 2020. Although its keylogging function is identical to the other samples, the rest of the\ncode has significant differences.\n\n\n-----\n\nThe keyloggers read their configuration from a file with the same name but with the .dll extension trimmed.\nOur sample, however, uses a configuration from the registry, and the file acts as a kill-switch: if it exists,\nthe keylogger terminates. This sample also has stack strings and DynamiCall obfuscations not present in\nprevious samples.\n\nThe keylogger ensures it is running in Explorer.exe and retrieves its configuration by reading its own last\n0x208 bytes and decrypting them. The decryption is done by adding and XORing each byte with constant\nvalues. Next, the encrypted configuration is set in the registry at HKCU\\Software\\F32xhfHX. On future\nexecutions, the configuration will be fetched from this key. The configuration contains two paths:\n\nKeylogger module file – C:\\Windows\\SndVolSSO.DLL\nKeylogging output file – C:\\users\\minh\\AppData\\Local\\OneDrive\\Cache.dat\n\nInterestingly, the output file path includes a username, hinting that this sample may have been intended for\na specific target machine.\n\nThe keylogger monitors keystrokes using GetRawInputData and clipboard data and logs them in an output\nfile as plaintext. The output file is timestomped to make its timestamp identical to svchost.exe on the\ninfected machine. Errors returned from GetRawInputData are logged to C:\\ProgramData\\Users.inf. The\n[keylogger also logs IME virtual-key codes, which support some Asian languages.](https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes)\n\nFigure 22: Example of keylogger output file “Cache.dat”\n\n### Command-Line Executer Service\n\nThis is a lightweight service DLL that executes a CMD command from the registry key\nHKCR\\.c\\Type\\Type00. It runs the command on 20:00, and if no process named powershell.exe is active\non the system. It is compiled with DynamiCall obfuscation.\n\n### 7zr.exe\n\nThis custom-compiled 7zr executable is modified to include DynamiCall obfuscation.\n\n## Conclusion\n\nThe Soul malware framework has been in active use since 2017, and the threat actors have been steadily\nevolving their tools and capabilities to this day. It should be emphasized that despite the reliance of the\nearlier tools on open-source code, custom keyloggers were already in use at the time, and significant\ndevelopment of custom code has transpired since. Its modular, multi-stage, reflectively executed payloads\ndemonstrate competent adversarial tradecraft and are signs of a well-resourced group. Although the\nattackers’ identity is currently unknown, we believe that they are possibly state-sponsored.\n\nThe details shared in this report stem from the comprehensive analysis of numerous samples.\nNevertheless, we have a feeling that this is just the tip of the iceberg, with more payloads and capabilities\nin the group’s arsenal to expose in the future.\n\n## Fortinet Solutions\n\nFortiEDR detects and blocks these threats out-of-the-box without any prior knowledge or special\nconfiguration. It does this using its post-execution prevention engine to identify malicious activities:\n\n\n-----\n\nFigure 23: FortiEDR blocking the Soul backdoor communication to the C2 server\n\nAll network IOCs have been added to the FortiGuard WebFiltering blocklist.\n\nThe FortiGuard AntiVirus service engine is included in Fortinet’s FortiGate, FortiMail, FortiClient,\nand FortiEDR solutions. FortiGuard AntiVirus has coverage in place as follows:\n\nW64/SoulSearcher.B7D1!tr\nW32/SoulSearcher.B7D1!tr\nW64/SoulSearcherKeyLogger.B7D1!tr.spy\nW32/SoulSearcher.B7D1!tr\nData/SoulSearcher.B7D1!tr\n\nIn addition, as part of our membership in the Cyber Threat Alliance, details of this threat were shared in\nreal-time with other Alliance members to help create better protections for customers.\n\n## Appendix A: MITRE ATT&CK Techniques\n\nID Description\n\nT1569.002 System Services: Service Execution\n\nT1055 Process Injection\n\nT1112 Modify Registry\n\nT1567 Exfiltration Over Web Service\n\nT1041 Exfiltration Over C2 Channel\n\nT1132 Data Encoding\n\nT1082 System Information Discovery\n\nT1083 File and Directory Discovery\n\nT1140 Deobfuscate/Decode Files or Information\n\nT1071.001 Application Layer Protocol: Web Protocols\n\nT1056.001 Input Capture: Keylogging\n\nT1059.003 Command and Scripting Interpreter: Windows Command Shell\n\n\n-----\n\nT1115 Clipboard Data\n\nT1592 Gather Victim Host Information\n\nT1090.001 Proxy: Internal Proxy\n\nT1070.006 Indicator Removal on Host: Timestomp\n\n## Appendix B: IOCs\n\nIOC Type Details\n\n\n1af5252cadbe8cef16b4d73d4c4886ee9cecddd3625e28a59b59773f5a2a9f7f SHA256\n\na6f75af45c331a3fac8d2ce010969f4954e8480cbe9f9ea19ce3c51c44d17e98 SHA256\n\nc4efb58723fd75d51eb92302fbd7541e4462f438282582b5efa3c6c7685e69fd SHA256\n\nedb14233eccb5b6e2d731831e7b18b8b17ea6a3f8925fb5899ce2ef985a66b68 SHA256\n\nfdf0db7f6b60d7563268c15c634adb47e8eec34adfcbf9b10e973916c7517157 SHA256\n\nc7481d6975646b605aba3fb11686e34ee205f7e280069e9d5bf0c1c2eca79be8 SHA256\n\n0f7af0cad4aade0e7058051a449059b35358ddda075d88b2d289625adc02deef SHA256\n\n3cb4887bec169c75f58bc4ed1c6fd3703cc46512596e62186cf8329448dbb47b SHA256\n\ncb954f06c94493c87f25651271657aeb1e3e24f26b6552d3e616bbc2dc660679 SHA256\n\n78feb564c4f6c240ddb17dd0f49ae96df04ee594ed24df81f583136fccf60c1d SHA256\n\n\nSoulSearcher\n\nSoulSearcher\n\nSoulSearcher\n\nSoulSearcher\n\nSoulSearcher\n\nSoulSearcher\n\nSoulSearcher\n\nSoulSearcher\n\nSoulSearcher\n\nSoulSearcher\n\n\n-----\n\nbc91a4fb16f14fb1c436c2bdc7c80b87a02caa5de17897614d07bc7bda200590 SHA256\n\n7edd7d406159ab0eecb22ddbd6060de7c24a4eb0b61fa527935310b94d3b9db4 SHA256\n\nb02b8b6c3d517c6b8652b898963068ba12cd360b5cdcf0aad5fe6ff64f0e9920 SHA256\n\nec164902cbe8daaa88ae923719c5dac900715f3e32d4cea6e71ca04c7cecf3e2 SHA256\n\nbac4b50727c69ca7cc3c0a926bb1b75418a8a0eabd369a4f7118bb9bba880e06 SHA256\n\n69a9ab243011f95b0a1611f7d3c333eb32aee45e74613a6cddf7bcb19f51c8ab SHA256\n\n579fa00bc212a3784d523f8ddd0cfc118f51ca926d8f7ea2eb6e27157ec61260 SHA256\n\n8ff18b6fb5fe4f221cd1df145a938c57bdd399dc24e1847b0dc84a7b8231458f SHA256\n\nf97161aaa383e51b2b259bb618862a3a5163e1b8257832a289c72a677adec421 SHA256\n\nd3647a6670cae4ff413caf9134c7b22b211cb73a172fc1aa6a25b88ff3657597 SHA256\n\nf5cd13b2402190ec73c526116abea5ebab7bd94bcdb68cc2af4f3b75a69ba9c5 SHA256\n\na15eda7c75cf4aa14182c3d44dc492957e9a9569e2d318881e5705da2b882324 SHA256\n\n967e8063bd9925c2c8dd80d86a6b01deb5af54e44825547a60c48528fb5f896d SHA256\n\n64f036f98aad41185163cb328636788a8c6b4e1082ae336dad42b79617e4813d SHA256\n\n7b838fcad7a773bfd8bc26a70f986983553d78b4983d0f2002174f5e56f7f521 SHA256\n\n\nSoulSearcher\n\nSoulSearcher\n\nSoulSearcher\n\nSoulSearcher\n\nFirst stage\nloader for\nSoulSearcher\n\nOriginal Soul\nbackdoor\n\nOriginal Soul\nbackdoor\n\nOriginal Soul\nbackdoor\n\nOriginal Soul\nbackdoor\ndropper\n\nOriginal Soul\nbackdoor\n\nKeylogger\n\nKeylogger\n\nKeylogger\n\nKeylogger\n\nSoul\nbackdoor\n\n\n-----\n\n40fda8137d8464d61240314b6de00ae5c14ed52019e03e4dcadfc00b32c89d23 SHA256\n\n5dee99beb0b6ba1ebdb64515be1d9307262d9b57b0900310d57290dca40bb427 SHA256\n\n6b70ad053497f15b0d4b51b5edabeced3077dddb71b28346df7c7ea18c11fcdf SHA256\n\n852c98a6fbd489133411848775c19a2525274eac9a89a09a09d511915c7cbafc SHA256\n\n\nCommandline executer\nservice\n\n7zr.exe\n\n7zr.exe\n\nAvpCon.dll\n\n\ngmy.cimadlicks[.]net Network \napp.tomelife[.]com Network \ncommunity.weblives[.]net Network \n23.91.108[.]12 Network \nGlobal\\vQVomit4 Mutex \nGlobal\\mFNXzY0g Mutex \nGlobal\\DefaultModuleMutex Mutex \nGlobal\\DBWinMutex_1 Mutex \nGlobal\\DBWinMutex_2 Mutex \nGlobal\\VirusScanWinMsg Event \nGlobal\\3GS7JR4S Event \nGlobal\\SecurityEx Event \n\nGlobal\\CacheDataMappingFile File\nmapping\n\nC:\\Windows\\System32\\wlbsctrl.dll File\nname\n\n\n\n\n\n-----\n\nC:\\Windows\\System32\\ikeext2.dll File\nname\n\nC:\\Windows\\System32\\d6w48ttth.dll File\nname\n\nC:\\Windows\\System32\\shsvc.dll File\nname\n\nC:\\Windows\\System32\\netcsvc.dll File\nname\n\nC:\\Windows\\System32\\fc2qhm7r9.dll File\nname\n\nC:\\Windows\\SndVolSSO.DLL File\nname\n\nSvrLdr_xpsservices.dll File\nname\n\ntimedateapi.dll File\nname\n\nmsfte.dll File\nname\n\nwsecapi.dll File\nname\n\nC:\\Programdata\\Microsoft\\svchost.exe File\nname\n\nNvStreamer.dll File\nname\n\nHelpsvc32.dll File\nname\n\nSVCLDR64.dll File\nname\n\nDataOper64.dll File\nname\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----\n\nC:\\ProgramData\\Users.inf File\nname\n\n%LOCALAPPDATA%\\OneDrive\\Cache.dat File\nname\n\nC:\\ProgramData\\Security_checker\\sc.dll File\nname\n\nC:\\ProgramData\\Xps viewer\\xpsservices.dll File\nname\n\nC:\\Program Files (x86)\\Common Files\\System\\ado\\msado28.dll File\nname\n\nC:\\ProgramData\\networks.dat File\nname\n\nC:\\ProgramData\\Microsoft\\Crypto\\RSA\\Keys.dat File\nname\n\nSntpService.dll File\nname\n\nsdc-integrity.dat File\nname\n\nsds-integrity.dat File\nname\n\n\n\n\n\n\n\n\n\n\n\n\n\nHKCR\\.z\\OpenWithProgidsEx Registry \nHKCR\\.z\\OpenWithListEx Registry \nHKCR\\.sbr\\Order Registry \nHKCR\\.sbr\\StartOverride Registry \nHKU\\<any_key>\\Software\\kuhO6Ba0kT Registry\n\nHKU\\<any_key>\\Software\\OIfkO2i1 Registry \nHKU\\<any_key>\\Software\\7QAEGXJc Registry \n\n-----\n\nHKCR\\.c\\Type\\Type00 Registry \n\nHKR\\Software\\Microsoft\\EventSystem\\8C345CCE-5C37-446E-9E36B57A54FC9C45\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\<service>\\Parameters\\8C345CCE5C37-446E-9E36-B57A54FC9C45\n\n\nRegistry \nRegistry \n\nHKR\\.kci\\PersistentHandler Registry \nHKCR\\.3gp2\\Perceived-Type Registry \nHKCR\\.3gp2\\Content-Type Registry \nHKCR\\.rat\\PersistentHandler\\MagicNumber Registry \nHKCR\\.rat\\PersistentHandler\\TypeFace Registry \nHKCU\\Software\\Microsoft\\FTP\\MostRecentApplication Registry \nHKCU\\Software\\Microsoft\\FTP\\UserInfo Registry \nHKCU\\Software\\F32xhfHX Registry \n_Learn more about Fortinet’s_ _[FortiGuard Labs threat research and intelligence organization and the](https://www.fortinet.com/fortiguard/labs?utm_source=blog&utm_campaign=fortiguard-labs)_\n_[FortiGuard Security Subscriptions and Services portfolio.](https://www.fortinet.com/fortiguard/labs?tab=security-bundles&utm_source=blog&utm_campaign=security-bundles)_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-02-25 - The Hunt for the Lost Soul- Unraveling the Evolution of the SoulSearcher Malware.pdf"
    ],
    "report_names": [
        "2022-02-25 - The Hunt for the Lost Soul- Unraveling the Evolution of the SoulSearcher Malware.pdf"
    ],
    "threat_actors": [
        {
            "id": "a3687241-9876-477b-aa13-a7c368ffda58",
            "created_at": "2022-10-25T16:07:24.496902Z",
            "updated_at": "2025-03-27T02:02:10.256629Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "ETDA:Hacking Team",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "e90c06e4-e3e0-4f46-a3b5-17b84b31da62",
            "created_at": "2023-01-06T13:46:39.018236Z",
            "updated_at": "2025-03-27T02:00:02.978356Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "MISPGALAXY:Hacking Team",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535967,
    "ts_updated_at": 1743041407,
    "ts_creation_date": 1653765168,
    "ts_modification_date": 1653765168,
    "files": {
        "pdf": "https://archive.orkl.eu/20bf56bf1e7a363222f7f1535be6b6d6ad1bb801.pdf",
        "text": "https://archive.orkl.eu/20bf56bf1e7a363222f7f1535be6b6d6ad1bb801.txt",
        "img": "https://archive.orkl.eu/20bf56bf1e7a363222f7f1535be6b6d6ad1bb801.jpg"
    }
}