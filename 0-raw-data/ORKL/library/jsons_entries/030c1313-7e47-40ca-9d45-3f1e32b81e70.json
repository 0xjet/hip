{
    "id": "030c1313-7e47-40ca-9d45-3f1e32b81e70",
    "created_at": "2023-01-12T15:06:22.681643Z",
    "updated_at": "2025-03-27T02:09:30.013121Z",
    "deleted_at": null,
    "sha1_hash": "3ff726c03deca80c5ba4c20edd39064c8315a667",
    "title": "2019-08-13 - The state of advanced code injections",
    "authors": "",
    "file_creation_date": "2022-05-28T04:03:45Z",
    "file_modification_date": "2022-05-28T04:03:45Z",
    "file_size": 522341,
    "plain_text": "# The state of advanced code injections\n\n**[adalogics.com/blog/the-state-of-advanced-code-injections](https://adalogics.com/blog/the-state-of-advanced-code-injections)**\n\n13th august 2019\n\nDavid Korczynski,\n\n_Security Research & Security Engineering_\n\nIn the last few years there has been a significant interest in code injection techniques from\nboth attackers and defenders. These techniques enable the attacker to execute arbitrary\ncode within the address space of some target process (which is why code injections often\nare also called process injections), and attackers, both malware and pentesters, increasingly\nuse these techniques to bypass anti-malware systems and endpoint protection systems in\norder to execute their payloads. Many of these injection techniques are already described in\n[various blog posts, such as the excellent ones by Endgame here and](https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process) **[here, and most](https://www.endgame.com/blog/technical-blog/hunting-memory)**\nrecently a large survey was conducted by researchers from SafeBreach at the most recent\n[Blackhat event with the content available here. However, many of these surveys are closely](https://www.blackhat.com/us-19/briefings/schedule/#process-injection-techniques---gotta-catch-them-all-16010)\nattached to the core programmatic aspects of the injections, whereas they leave out\nelements of why injections are necessarily important and when they are used. In this blog\npost we will cover the state of code injections from a more general setting such as their\nmotivation, some of their technical details as well as highlight examples of attacks that have\nused them. Finally, we give a short view into the future.\n\nUnderstanding code injections from beginner to advanced is one of the courses that we offer\nas part of **[our software security training. We currently have a public event scheduled for](https://adalogics.com/cyber-security-training)**\nthe upcoming 44CON in London 9th-11th September 2019 and you can find the necessary\n[information here. In this course we will teach you the core of these techniques as well as](https://44con.com/44con-training/code-injections-from-beginner-to-advanced-for-defenders-and-attackers/)\nhow to develop sophisticated payloads that rely on code injections. Please consider\nattending the training and the conference!\n\n## Motivation for code injections, for defenders and attackers\n\n\n-----\n\nIn a general sense, attackers use code injection techniques to mitigate defensive systems.\nThis includes everything from bypassing host-based intrusion prevention systems, evading\nmalware sandboxes and avoiding analysis by forensic tools. Naturally, malware has used\nthese techniques for quite a while and even in back in 2013 Palo Alto reported that 13.5% of\n[malware samples used code injections, described in the modern malware review report on](https://media.paloaltonetworks.com/documents/The-Modern-Malware-Review-March-2013.pdf)\npage 16 under \"analysis avoidance ''. In their report they also give an interesting insight\nabout the motivation for code injections, namely \"Code injection was observed in 13.5\n_percent of samples. This technique is notable in particular because it allows malware to hide_\n_within another running process. This has the effect of the malware out of view if a user_\n_checks the task manager and can also foil some attempts at application white-listing on the_\n_host\". Wayne Low documents even before then, in 2012, the first analysis of the Gapz_\nmalware that explicility used a novel code injection technique that - due to it's novelty [bypassed host-based intrusion prevention systems here. Interestingly, the injection that](https://www.virusbulletin.com/virusbulletin/2012/10/code-injection-return-oriented-programming)\n[Gapz deployed used techniques and ideas described around a decade earlier called shatter](https://web.archive.org/web/20060904080018/http://security.tombom.co.uk/shatter.html)\n[attacks, which was even presented at Blackhat in 2004 here.](https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-moore/bh-us-04-moore-whitepaper.pdf)\n\nIn the years 2013-2019 the amount of code injections has continued to grow. There are\ncurrently many reports by anti-malware companies documenting the code injections in\nmalware and I think it's fair to say that now, when a new malware is discovered, it's more\noften than not the case that it uses code injection techniques. A recent survey of techniques\nby SafeBreach documents 14 techniques invented in 2017-2019, and this leaves out 7\nshatter-like attacks that they do not go in details with as well as a whole domain of\ntechniques in the process hollowing space, in which several new variants have been\ndiscovered in recent years. Furthermore, malware samples are currently not limiting their\ninjection lifecycle to only one injection technique, but a recent report shows that Dridex\n**combines five different injection techniques.**\n\nCode injections are not only used by malware. Pentesters, and red teams in general, rely on\nthese techniques to take control of the systems once they have gotten access to the system.\nFor example, the famous **[Meterpreter used by pentesters rely on code injection as well as](https://www.offensive-security.com/metasploit-unleashed/about-meterpreter/)**\n[related techniques, e.g. self-loading DLLs. Shellterpro is another well-known pentester tool](https://www.shellterproject.com/)\nthat is heavily based on code injections. As defensive systems get better, understanding the\ndesign space of code injections can significantly enhance the skills of red teamers, as it\nallows you to manually construct payloads and write injection tools that bypass the specific\ndefensive perimeter of your target. An example of custom tools developed for the purposes\n[of penetration testing was given at Blackhat in 2014 here.](https://www.blackhat.com/docs/us-14/materials/us-14-Mesbahi-One-Packer-To-Rule-Them-All-WP.pdf)\n\n## Brief overviev of code injection foundations\n\nIn this section we give a brief introduction to some of the more common-known injection\ntechniques.\n\n## Traditional remote thread creation\n\n\n-----\n\nThis is the most well known injection technique and simply achieves execution in the target\nprocess by instantiating a remote thread. The general procedure is to get access to the\ntarget process using `OpenProcess, allocating memory in the process using`\n```\nVirtualAlloc, writing malicious code to the allocated memory with\nWriteProcessMemory and finally having this code execute using CreateRemoteThread .\n\n```\nNaturally, there are many variations of this injection technique, both in terms of getting\naccess to the remote process, writing memory to the targets address space and also\ninitiating execution. For example, instead of opening an existing process, the malware can\ncreate a new process with `CreateProcess and inject its code in this new process or rely on`\nlower-level APIs like `NtOpenProcess . The attack can also write to memory using`\n```\nNtWriteVirtualMemory and creating the remote thread can be performed with a variety of\n\n```\nlower-level APIs like `RtlCreateUserThread,` `NtCreateThreadEx and`\n```\nZwCreateThreadEx . This technique is perhaps the most commonly used by malware and\n\n```\n[example reports include Tinba and](https://www.trendmicro.de/cloud-content/us/pdfs/security-intelligence/white-papers/wp_w32-tinba-tinybanker.pdf?_ga=2.231395871.1631440968.1565650174-166280822.1565650174) **[Emotet.](https://securelist.com/the-banking-trojan-emotet-detailed-analysis/69560/)**\n\nIn general, we can construct a similar-looking attack in many ways. The primitive for writing\nmemory to the target process need not be `WriteProcessMemory, but can be any way of`\nmemory sharing. This includes memory mapped files by way of APIs like\n```\nZwCreateSection and ZwMapViewOfSection and also globally shared memory.\n\n```\nFurthermore, from a programmatic perpective we can also use asynchronous procedure\ncalls rather than explicitly starting a new thread in the remote process, which we discuss\nbelow.\n\nRemote thread creation as decompiled by Ghidra.\n\n## Remote thread hijacking\n\nA technique that is closely aligned with creating a remote thread is to hijack a remote thread\ninstead of creating a new one in the target process. From a high-level point of view, the\ndifference between this technique and the previous one is that the previous technique\ncreates a new thread in the target whereas this technique hijacks execution of an exisiting\none. One way to do this is to create a new process, by way of `CreateProcess, in`\nsuspended mode and overwrite the entry point of the newly-started process such that it\n\n\n-----\n\npoints to our attacker-controlled code instead. This effectively means the\n```\nCreateRemoteThread call from before gets substituted with ResumeThread . A more\n\n```\naggressive approach is to simply suspend thread execution in the target process and then\nsubstitute the thread using `SuspendThread . Code execution is then achieved by`\nexchanging the thread context using `GetThreadContext and` `SetThreadContext such`\nthat the registers of the thread context points to attacker-controlled memory. Naturally, since\nthe thread execution of the target process is suspended it is in many scenarios desirable to\nrestore faithful execution in the target process in order for the system to continue execution\nunnoticed.\n\nThe attacker can also initiate execution of the attacker-controlled memory in the remote\nprocess through asynchronous procedure calls such as `QueueUserAPC,`\n```\nNtQueueApcThread, ZwQueueApcThread and RtlQueueApcWow64Thread . However, one\n\n```\nof the drawbacks of doing this, however, is that the remote thread must be in an alertable\nstate to trigger the APC.\n\n## Reflective DLL injection\n\nIn the previous methods we were mainly concerned with how to achieve code execution in\nthe remote process. However, a question that comes up once you achieve code execution is\n_what code to execute. In most cases just executing shellcode doesn't do the job as the_\nattacker desires to have more comprehensive control. Reflective DLL injection is a technique\nthat focuses on this aspect of the code-injection design space using a self-loadable DLL file.\nSpecifically, reflective DLL injection is a technique that creates a DLL such that the DLL has\na minimal Windows loader as an exported function. When this function is triggered the DLL\nwill load itself inside the process of which it has been written, thus avoiding the need to be\nloaded from disk by the regular Windows loader. As such, it is not necessary to, for example,\nrely on calls like `LoadLibrary to load a fully-fledged library inside the target process.`\nRather, the attacker can simply allocate space in the remote process, write the raw DLL\n[content there, and then execute the exported function in the DLL itself. Lazarus is an](https://securingtomorrow.mcafee.com/other-blogs/mcafee-labs/lazarus-resurfaces-targets-global-banks-bitcoin-users/)\nexample of malware that uses reflective DLL injection and pentesters published at Blackhat a\n[white paper on a novel packer that uses reflective DLL injection here.](https://www.blackhat.com/docs/us-14/materials/us-14-Mesbahi-One-Packer-To-Rule-Them-All-WP.pdf)\n\n\n-----\n\nCustom\n\nloading of PE sections in reflective DLL injection. Code for the reflective loader can be found\n**[here.](https://github.com/stephenfewer/ReflectiveDLLInjection/blob/master/dll/src/ReflectiveLoader.c)**\n\n## Process hollowing\n\nA technique closely related to hijacking a remote thread is to simply substitute the entire\nmemory of the remote process with attacker-controlled memory. Process hollowing does this.\nThe steps in process hollowing is to create a process in suspended mode, then deallocate\nthe memory of the suspended process (this is where the \"hollow\" comes from), write an\nattacker-controlled image to the target process and then resume execution of the target\nprocess. Effectively, the goal is to explicitly hide execution of the malicious code in disguise\nof a benign process. Process hollowing is a commong techniques in malware samples, with\n[an example report found here.](https://www.bromium.com/dridex-threat-analysis-july-2019-variant/)\n\n\n-----\n\nUnloading of the main module and then reallocating memory for the new executable in\n[ProcessHollowing. Source code can be found here.](https://github.com/theevilbit/injection/blob/master/ProcessHollowing/ProcessHollowing/ProcessHollowing.cpp)\n\n## Example of advanced techniques\n\nThe majority of injections observed in the wild are of the types described in the previous\nsection. However, (mostly) in recent years several novel techniques have been discovered\nthat rely on approaches outside the scope of the previous techniques. These novel\ntechniques use different API calls to achieve their code injection, sometimes rely on exploitlike techniques such as return oriented programming and are quite often specific to certain\ntarget applications. However, on an abstract level they still remain close to our most basic\ntechniques as they still have to (1) communicate with the target process; (2) ensure attackercontrolled memory is written to the process and (3) trigger execution of attacker-controlled\ncode in the process. It is important to emphasize in this blog post we only highlight some\nexamples of these techniques rather than an exhaustive list. In particular, we have prioritised\nselection of techniques that have been documented to be used in attacks.\n\n## Ghostwriting\n\nThe main idea of GhostWriting is to force the target process to write malicious content in it's\naddress space and force this code to be executed without calling any of `OpenProcess,`\n```\nVirtualAlloc or CreateRemoteThread, or similar. GhostWriting achieves this by\n\n```\nselecting two atomic gadgets (ROP gadgets), one that writes the value of a register to an\naddress given by the value of a different register ( mov [reg1], reg2 ) and another gadget\nthat simply represents an eternal loop `jmp 0x0 . The technique then makes use of`\n```\nSuspendThread, GetThreadContext, SetThreadContext and ResumeThread to\n\n```\n\n-----\n\ncontinuously overwrite memory in the target process. Specifically, it continuously sets the\nregisters such that they overwrite a given address with the desired content, and then jumps\nto the eternal loop. As SetThreadContext allows the attacker to control the registers it is easy\nto overwrite the stack - or any other address in the target process - with whichever content\nthe attacker desires. After the `mov [reg1], reg2 gadget executes it returns to the eternal`\nloop gadget, and the attacker gains control over the execution simply by calling\n```\nSuspendThread, such that the execution does not run in the eternal loop forever. Rather,\n\n```\nthe \"eternal loop\" is used as a temporary safe-state for the attacker to ensure consistency in\nthe target process. A concrete example of using this is to to create a stackframe to\n```\nNtProtectVirtualMemory that sets the necessary permissions for attacker-written\n\n```\nshellcode. However, the technique used for achieving write-what-where and execute-ondemand is far more general and can be used to write any type of code to the target, e.g. a\nfully functioning PE file.\n\nA quite interesting aspect of GhostWriting is that the technique was first made public in 2007,\nyet it still remains largely one or the more sophisticated techniques. The original blog post\n[explaining the technique is available here.](http://blog.txipinet.com/2007/04/05/69-a-paradox-writing-to-another-process-without-openning-it-nor-actually-writing-to-it/)\n\n[Shellcode written by the original GhostWriting code. The source can be found here.](http://blog.txipinet.com/2007/04/05/69-a-paradox-writing-to-another-process-without-openning-it-nor-actually-writing-to-it/)\n\nThe main function that GhostWriting uses to continuously write desired content in target\nprocess. By setting registers in the thread context so they point to selected gadgets\nGhostWriting maintains control of the target process.\nPowerLoader and PowerLoaderEx\n\nThe idea behind PowerLoad is to abuse shared sections in Windows and overwrite several\nfunction pointers inside `explorer.exe to point to attacker-controlled memory in the shared`\nsection. Since this shared section is non executable PowerLoader relies on a ROP chain to\nexecute shellcode within `explorer.exe . In more detail, PowerLoader first gets a handle to`\na window in `explorer.exe . This window contains a pointer to a CTray class object, which`\nis used for handling messages sent to the particular window. PowerLoader then uses\n\n\n-----\n\n```\nSetWindowLongPtr to replace this CTray object, such that it now points to memory in a\n\n```\nshared section. Within this shared section, PowerLoader writes its malicious code, which is a\ncombination of a ROP chain as well as shellcode. PowerLoader then triggers the execution\nof the ROP chain by sending the window a message, using `SendNotifyMessage . The ROP`\nchain then overwrites a function within ntdll called `atan with shellcode and transfers`\nexecution to this shellcode. This technique was first used by the Gapz malware and has\nsince been generalised by researchers from Ensilo, that made the attack non-specific to the\n[shared sections. You can find the source code for PowerLoaderEx here](https://github.com/BreakingMalware/PowerLoaderEx)\n\nMessage handler in explorer that PowerLoader hijacks.\n\n## AtomBombing\n\n\n-----\n\nAtomBombing is another technique that uses ROP chains to get code execution in the\nremote process. Specifically, AtomBombing abuses the global atom table in Windows to\nshare memory between processes and undocumented asynchronous procedure calls to\nforce the target process into calling various functions on behalf of the injecting process. The\ninjecting process writes a ROP chain and shellcode to the global atom table using the\nWindows function `GlobalAddAtom . The injector then uses` `NtQueueApcThread to force`\nthe injected process to call `GlobalGetAtomName to store the ROP chain and shellcode`\ninside the target process. To invoke execution, the injector again uses `NtQueueApcThread`\nto force the injected process to call `SetThreadContext to set eip and esp. Eip is set to the`\naddress of `ZwAllocateVirtualMemory and esp is set to point to the beginning of the ROP`\nchain. The injection is, therefore, achieved with a combination of `NtQueueApcThread and`\n```\nGlobalAddAtom . An interesting aspect of AtomBombing is that not long after the publication\n\n```\n[of the technique an updated version of the infamous Dridex malware was discovered, that](https://securityintelligence.com/dridexs-cold-war-enter-atombombing/)\nhad adopted a modified version of the AtomBombing technique, and this is still being used in\n**[2019.](https://www.bromium.com/dridex-threat-analysis-july-2019-variant/)**\n\n## Process Doppelganging\n\nThe idea behind doppelganging is to improve the limitations of process hollowing, namely\nhow the executable memory is written into the target process. Doppelganging achieves this\nby way of Windows Transactions. Doppelganging loads a benign executable using\n```\nCreateTransaction and CreateFileTransacted, but then overwrites the content of the\n\n```\ntransacted file with malicious code, using `WriteFile . Doppelganging then creates a`\nsection that holds the tainted transaction, i.e. the transaction that holds the malicious\nmemory, and then performs a rollback on the transaction. The rollback will undo the changes\nperformed by the transaction, which in Doppelganging's context is the overwriting of the\nbenign file, so the changes to the benign file won't actually be commited to the file system.\nHowever, the caveat here is that the content of the section still contains the tainted code.\nNow, doppelganging proceeds to create the target process with the content of the malicious\nsection. Doppelganging creates the process in a low-level way using `NtCreateProcess,`\nand, therefore, has to perform various set-ups for the process to accurately execute, such as\nsetting up process parameters and create the process's main threads. An example of\n[Process Doppelganging in the wild was discovered in early 2018.](https://blog.malwarebytes.com/threat-analysis/2018/08/process-doppelganging-meets-process-hollowing_osiris/)\n\n## Earlybird\n\nEarly bird refers to a technique that performs a somewhat traditional code injection via\nremote thread instantiation early in the process initialisation phase. Specifically, the attacker\ncreates a new process in suspended mode and then proceeds to allocate and write memory\nto the process. In order to trigger execution the malware uses an asynchronous procedure\ncall and enforces execution of the APC call using the `NtTestAlert function. The technique`\n\n\n-----\n\n[was discussed by researcher from Cyberbit and even though it received its own name, it is](https://www.cyberbit.com/blog/endpoint-security/new-early-bird-code-injection-technique-discovered/)\nclosely related to earlier techniques traditional injection. This is also confirmed by the fact\n[that the injection dates back to at least 2012.](https://research.checkpoint.com/dorkbot-an-investigation/)\n\nCode snippet of Earlybird injection.\n\n## ctrl-inject\n\nThe ctrl-c key combination is a well-known pattern for exiting and shutting down applications.\nThe ctrl-inject injection technique exploits the underlying features that makes this hotkey\npossible. Specifically, when a user presses the ctrl + c keyword in a console application a\nsystem process ( csrss.exe ) invokes a function called `CtrlRoutine in a new thread of`\nthe given console application. The `CtrlRoutine fetches the given handler for the control`\nsignal (ctrl + c) which contains a function pointer that will be called, which effectively is used\nto handle the signal. In short, the technique overwrites this signal handler with a malicious\nfunction pointer, such that whenever the signal occurs the malicious handler will be called.\n\nThe strengths of ctrl-inject is that the technique does not rely on any function calls like\n```\nCreateRemoteThread, ResumeThread or SetThreadContext, but rather triggers\n\n```\nexecution through the `csrss.exe process. The technique that triggers the execution is a`\nsimple ctrl-c signal which in many scenarios is considered harmless and unsuspicious. The\ndrawback of the technique is that it only works with console based applications.\n\n\n-----\n\n[Code that triggers the injection in ctrl-inject. Source code can be found here](https://github.com/theevilbit/injection/blob/master/Ctrlinject/Ctrlinject/Ctrlinject.cpp)\n\n## PROPagate\n\nThis technique was discovered in late 2017 and uses functionality of window subclassing to\ngain code execution in remote processes. Windows subclassing enables programmers to\nreuse functionality in existing controls by adding functionality and features to them.\nWhenever a window is subclassed, the messages to the original window is intercepted by\nthe subclassing window which executes its own handlers before sending them on to the\n[parent. You can read more about subclassing here. Whenever a window is subclassed it gets](https://docs.microsoft.com/en-us/windows/win32/controls/subclassing-overview)\na new property called either xSubclassInfo or `CC32SubclassInfo and stores the data`\nstructures related to these properties in its address space. This property points to a data\nstructure inside the subclassed process which contains a function pointer that gets executed\nin the event of a message being sent to the window. The idea behind PROPagate is then to\nwrite a malicious data structure inside the remote process and use the `SetProp function`\ncall to point to this handler. The attacker then uses `SendNotifyMessage to trigger the`\nmalicious function handler. Roughly 8 months after the first documentation of PROPagate by\n**[Adam, FireEye](http://www.hexacorn.com/blog/2017/10/26/propagate-a-new-code-injection-trick/)** **[discovered the RIG Exploit Kit delivering a dropper that used PROPagate.](https://www.fireeye.com/blog/threat-research/2018/06/rig-ek-delivering-monero-miner-via-propagate-injection-technique.html)**\n\nThe code that will trigger the PROPagate injection by setting the `UxSubclassInfo property`\n[within the target window to a have a fake handler. Source code can be found here](https://github.com/theevilbit/injection/blob/master/PROPagate/PROPagate/PROPagate.cpp)\n\n## Shatter-style attacks\n\n\n-----\n\nThe final category of code injections that we cover in this course is called Shatter attacks.\nThe basic idea behind these injections is to misuse the message-oriented way that windows\nare architectured within Windows. Specifically, whenever applications use windows they\ncontrol these in a message-oriented ways which is a very modular and effective way of\nmanaging windows. For example, when a key is pressed a messaged is sent to the currently\nactive window stating this key was pressed. However, the way these messages are handled\nby the active window is through message handlers, i.e. data structures, and at certain times\nthese can be overwritten with attacker controlled memory. Since a window can send\nmessages to other windows on the desktop and we can overwrite memory using previously\nmentioned primitives, we can start to construct code injections by overwriting the message\nhandlers in our target processes and then sending messages that trigger the respective\nhandlers.\n\n[Shatter attackers were first presented by Chris Paget (Now Kristine Paget) in 2002, however,](https://web.archive.org/web/20060904080018/http://security.tombom.co.uk/shatter.html)\nthe technique remains relevant. Recently, **[Hexacorn and](https://twitter.com/Hexacorn)** **[Odzhan presented seven new](https://modexp.wordpress.com/2019/04/25/seven-window-injection-methods/)**\nways of doing this.\n\n## Future outlooks\n\nCode injections are continuously being used and there is a trend of increasingly more novel\ntechniques being researched by defenders as well. For example, even in 2019 alone\n**[modexp has presented at least 15 novel injections (many inspired by Hexacorn), and](https://modexp.wordpress.com/)**\nmodern malware samples use long chains of code injections to execute on the target\nsystem, such as the recent **[Dridex that uses five in total. The novel techniques are much](https://www.bromium.com/dridex-threat-analysis-july-2019-variant/)**\nmore specific than the traditional injection attacks, and are now targeted internal structurse\nwithin the target processes rather than relying purely on common APIs. We can safely expect\nmore exploit-like scenarios in the future and also new ways of enforcing process separation.\nFurthermore, even Academia is now in the field as well, both researching how we can use\nsystem-wide execution to construct highly sophisticated malware that operates across many\n[processes (malwash) and](https://www.usenix.org/conference/woot16/workshop-program/presentation/ispoglou) **[how to generically analyse novel injection techniques. Code](https://acmccs.github.io/papers/p1691-korczynskiA.pdf)**\ninjections are here to stay and the complexity of them will increase. We highly recommend\ngetting started with these techniques if you aren't already, and also predict that we will find\nmore defensive tools and techniques being developed in the near future.\n\n## Conclusions\n\nCode injections, also known as process injections, is an important topic in terms of postexploitation strategies. Attackers, including both malware and pentesters, use these\ninjections to execute code in otherwise benign processes as a way to bypass white-lists\ndeployed by the defense products, e.g. host-based intrusion prevention and endpoint\nprotection systems. From a defenders point of view we need to ensure our defense systems\nare aware of these tricks - and derivates hereof - in order to ensure our automated\nprocedures are sound. Furthermore, from an attackers point of view, e.g. a pentester, these\n\n\n-----\n\ntechniques can be of great benefit in order to secure access to a target machine. In this blog\npost we gave a motivation for both defenders and attackers on why studying code injections\nis relevant, and also highlighted technical aspects of several code injection techniques and\nattacks that use them.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-08-13 - The state of advanced code injections.pdf"
    ],
    "report_names": [
        "2019-08-13 - The state of advanced code injections.pdf"
    ],
    "threat_actors": [
        {
            "id": "1dadf04e-d725-426f-9f6c-08c5be7da159",
            "created_at": "2022-10-25T15:50:23.624538Z",
            "updated_at": "2025-03-27T02:00:55.508759Z",
            "deleted_at": null,
            "main_name": "Darkhotel",
            "aliases": [
                "Darkhotel",
                "DUBNIUM",
                "Zigzag Hail"
            ],
            "source_name": "MITRE:Darkhotel",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "2b4eec94-7672-4bee-acb2-b857d0d26d12",
            "created_at": "2023-01-06T13:46:38.272109Z",
            "updated_at": "2025-03-27T02:00:02.790029Z",
            "deleted_at": null,
            "main_name": "DarkHotel",
            "aliases": [
                "DUBNIUM",
                "Fallout Team",
                "Luder",
                "Tapaoux",
                "Shadow Crane",
                "APT-C-06",
                "SIG25",
                "Karba",
                "Nemim",
                "Nemin",
                "G0012",
                "ATK52",
                "T-APT-02",
                "TUNGSTEN BRIDGE",
                "Zigzag Hail"
            ],
            "source_name": "MISPGALAXY:DarkHotel",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c0cedde3-5a9b-430f-9b77-e6568307205e",
            "created_at": "2022-10-25T16:07:23.528994Z",
            "updated_at": "2025-03-27T02:02:09.847683Z",
            "deleted_at": null,
            "main_name": "DarkHotel",
            "aliases": [
                "APT-C-06",
                "ATK 52",
                "CTG-1948",
                "Dubnium",
                "Fallout Team",
                "Higaisa",
                "Luder",
                "Operation DarkHotel",
                "Operation Daybreak",
                "Operation Inexsmar",
                "Operation PowerFall",
                "Operation The Gh0st Remains the Same",
                "SIG25",
                "Shadow Crane",
                "T-APT-02",
                "Tungsten Bridge",
                "Zigzag Hail"
            ],
            "source_name": "ETDA:DarkHotel",
            "tools": [
                "Asruex",
                "DarkHotel",
                "DmaUp3.exe",
                "GreezeBackdoor",
                "Karba",
                "Nemain",
                "Nemim",
                "Ramsay",
                "Retro",
                "Tapaoux",
                "Trojan.Win32.Karba.e",
                "Virus.Win32.Pioneer.dx",
                "igfxext.exe",
                "msieckc.exe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535982,
    "ts_updated_at": 1743041370,
    "ts_creation_date": 1653710625,
    "ts_modification_date": 1653710625,
    "files": {
        "pdf": "https://archive.orkl.eu/3ff726c03deca80c5ba4c20edd39064c8315a667.pdf",
        "text": "https://archive.orkl.eu/3ff726c03deca80c5ba4c20edd39064c8315a667.txt",
        "img": "https://archive.orkl.eu/3ff726c03deca80c5ba4c20edd39064c8315a667.jpg"
    }
}