{
    "id": "08268cad-99e6-43b3-89bc-3844797b4118",
    "created_at": "2023-01-12T14:59:21.086801Z",
    "updated_at": "2025-03-27T02:05:51.658274Z",
    "deleted_at": null,
    "sha1_hash": "7bcbf1a8f72b4e1f35e5a61b4c6b1f445d58052f",
    "title": "2021-10-20 - Hidden in Plain Sight- Identifying Cryptography in BLACKMATTER Ransomware",
    "authors": "",
    "file_creation_date": "2022-05-28T23:38:14Z",
    "file_modification_date": "2022-05-28T23:38:14Z",
    "file_size": 183896,
    "plain_text": "# Hidden in Plain Sight: Identifying Cryptography in BLACKMATTER Ransomware\n\n**[mandiant.com/resources/cryptography-blackmatter-ransomware](https://www.mandiant.com/resources/cryptography-blackmatter-ransomware)**\n\n## Breadcrumb\n\nBlog\n\nJacob Thompson\n\nOct 20, 2021\n\n10 mins read\n\nRansomware\n\nThreat Research\n\n\n-----\n\nMalware\n\nOne of the main goals of evaluating a ransomware sample is to determine what kind of\ncryptography the sample uses. Sometimes this is straightforward; for a BLACKMATTER\nsample we analyzed, it was not. We found the process we used to identify the mathematical\noperations of RSA cryptography from the BLACKMATTER code interesting and reusable for\nother malware samples and for becoming a better reverse engineer in general.\n\n## Introduction\n\nThe BLACKMATTER ransomware family has been identified in several recent attacks. Other\nauthors have published summaries of BLACKMATTER, including its relationship to prior\nfamilies REVIL and DARKSIDE, and method of encryption. Additionally, the U.S. Department\n[of Health and Human Services has published a summary of BLACKMATTER covering](https://www.hhs.gov/sites/default/files/demystifying-blackmatter.pdf)\nhistorical timeline, associated threat groups, and types of victims.\n\nMandiant’s FLARE team performed an internal analysis on a 32-bit BLACKMATTER variant\n(sha256: 5da8d2e1b36be0d661d276ea6523760dbe3fa4f3fdb7e32b144812ce50c483fa).\nLike many ransomware families, BLACKMATTER uses a combination of symmetric and\nasymmetric cryptography to hold its victims’ data for ransom. A BLACKMATTER sample has\nan asymmetric public key inside its configuration, and only the threat actor holds the\ncorresponding private key. When attacking each of a victim’s files, BLACKMATTER first uses\nsymmetric cryptography to encrypt the file. BLACKMATTER then uses the asymmetric public\nkey to encrypt the symmetric key and appends that encrypted key to the end of the file. The\nsymmetric key is then thrown away. The design means that no amount of reverse\nengineering of the BLACKMATTER binary alone can allow the victim to decrypt the files,\nbecause only the attacker’s private key can decrypt the per-file keys and recover the original\ndata.\n\nAs we reversed BLACKMATTER, we quickly found its symmetric encryption to be a modified\nversion of Salsa20. The asymmetric cryptography was not as obvious. Ransomware\nsamples often employ a cryptographic library such as Windows wincrypt, OpenSSL, or\nCrypto++; often the library is statically linked to make it somewhat more difficult to identify.\nBLACKMATTER was unique and used no identifiable cryptographic libraries. Some\ncryptographic routines have telltale behaviors—RC4 fills an array of 256 bytes with the\nvalues 0 to 255, and Salsa20 performs left rotations of 7, 9, 13, and 18 bits. We did not\nimmediately recognize asymmetric code in BLACKMATTER as a familiar algorithm. Magic\nnumbers can identify cryptographic algorithms, such as ChaCha20’s “expand 32-byte k,”\nAES’s Te and Td tables, and ASN.1-related byte sequences such as 30 82 02 (or MIIC after\nbase64 encoding); neither did we recognize any magic numbers.\n\nUltimately, we identified BLACKMATTER’s asymmetric cryptography as 1024-bit RSA, a\ncommon and unremarkable choice that we identified partly through the process of elimination\n(and previous analysis of BLACKMATTER and its predecessor families), but also by locating\n\n\n-----\n\nthe mathematical operations employed by BLACKMATTER and connecting them to the raw\nmath behind RSA. It is the process we employed to locate and identify the RSA algorithm\nthat we thought of as interesting and reusable for other malware samples and reverse\nengineers, and that is the focus of this blog post.\n\n## Review of RSA\n\nFirst, let us begin with a brief review of how RSA works. RSA (Rivest-Shamir-Adleman) is an\narchetypical cryptosystem for asymmetric cryptography. An individual generates a key pair\n(public and private key) according to the algorithm; the private key is kept secret while the\npublic key is widely distributed. Among other uses, any party can send the individual a secret\nmessage by encrypting the message with the public key and delivering it over an\nunprotected communication channel. In legitimate use, RSA could be used in e-commerce to\nestablish a shared secret for encrypting information in a credit card transaction. In illicit use\nlike ransomware, RSA is perfectly suited for concealing the information needed to decrypt\nfiles until payment is received and then exchanged for the private key.\n\nRSA operates on the principle of modular exponentiation, which is easy to perform but hard\nto reverse. Here is a greatly simplified explanation of how RSA keys are generated:\n\n1. Select two distinct large prime numbers p and q. Let n = pq and ϕ(n) = (p-1)(q-1). n is\n\nnot secret and may be freely shared as part of the public key, while also knowing ϕ(n)\nwould allow anyone to break the encryption.\n2. Select an exponent for encryption, e. In practice, e = 65537 is almost always used.\n3. Determine the corresponding exponent for decryption, d ≡ e-1 (mod ϕ(n)), which is\n\nstraightforward using the Extended Euclidean Algorithm, but intractable without\nknowing ϕ(n).\n4. The pair (n, e) is the public key; d is the private key. Information sufficient to derive d\n\n(such as p and q or ϕ(n)) must also be kept secret.\n\n\nA message may then be encrypted by computing E(m) = m mod e _n and decrypted by_\ncomputing D(E(m)) = (me)d mod n ≡ m (mod 1 _n). This property of n, m, e, and d comes from_\nFermat’s Little Theorem and can be explored by reviewing a more detailed explanation of\nRSA.\n\n## Binary Exponentiation\n\n\nThe choice of e = 65537 is intentional and allows encryption to be performed efficiently while\nremaining secure. Since e = 65537 = 65536 + 1 = 216+1, m65537modn can be computed\nusing binary exponentiation as follows:\n\n_x=m_\n\nfor i = 1 to 16:\n\n\n-----\n\n_x = x mod n_\n\n_x = xm mod n_\n\nOnce RSA encryption is distilled to this form, the only complication is that a function is\nneeded to perform “big number” modular multiplication, i.e., f (x, y, n) = xy mod n. Inevitably,\nwhile analyzing BLACKMATTER, our attention was diverted to a function which performs\nmodular multiplication, but whose purpose was not obvious. Compounding that, the constant\n65537 never appears in the code when implemented as above. Next, we present an\nexplanation showing how we verified how each asymmetric cryptographic function in the\nBLACKMATTER sample fit in as part of the RSA encryption process.\n\n## Multiplication Function\n\nThe multiplication of two unsigned binary integers can be expressed as a series of additions\nand multiplications by two, e.g.:\n\n_145 · 113_\n\n_145 · (2 +2 +2 +2 )        6_ _5_ _4_ 0\n\n\n_(145 · 2 + 145 · 2 + 145) · 2 + 145 · 22_ _4_ 0\n\n_((145 · 2 + 145) · 2 + 145) · 2 · 2 · 2 · 2 + 145_\n\nSince a multiplication by two is just a left bit shift by one bit, this makes it possible to multiply\n_x · y using only left shifts and additions, examining each bit of x to determine whether y_\nshould be added into the running product on each iteration before shifting the running\nproduct to the left. The BLACKMATTER big number multiplication function sub_401B24 (x, y,\n_n), based on this exact principle, calculates x = (x * y) % n._\n\nOf course, x86 machines do not have 1024-bit registers or immediate values, so an\noperation on a 1024-bit integer must be broken down into 32 operations on each 32-bit\nchunk of the 1024-bit integer. The x86 instructions rcl, adc, and sbb make such big number\narithmetic possible, using the carry flag to propagate a 0- or 1-bit to the next 32-bit chunk as\nappropriate.\n\nFirst, the big number multiplication function allocates some stack space for a temporary\n1024-bit integer z to hold the running product, and initializes it to zero (Figure 1).\n\n\n-----\n\n_Figure 1: The big number multiplication function starts by_\n\n_initializing a 1024-bit integer z to zero_\nNext, the big number multiplication function loops over each bit in its inputs and outputs. For\neach iteration, the function first shifts z left by one bit (Figure 2).\n\n\n-----\n\n_Figure 2: The big number multiplication_\n\n_function shifts z to the left by one bit. Since z is 1024 bits long, the rcl instruction allows the_\n_shift to be done on each 32-bit chunk_\nThis calculation multiplies z by two, and therefore may cause z to exceed n. To ensure the\ncalculation is performed mod n, the function next subtracts n from z (Figure 3).\n\n\n-----\n\n_Figure 3: After doubling z, the big number multiplication must_\n\n_subtract n from z to ensure the calculation is done mod n_\nNote that the malware did not check whether z ≥ n before performing the subtraction, so if\nthe result was negative, the function adds n to z to reverse the previous subtraction and\nrestore z to the range [0, n) (Figure 4). The malware operates this way because comparing z\nto n before performing the previous subtraction would have been just as computationally\nexpensive as performing the subtraction.\n\n\n-----\n\n_Figure 4: If z -= n produced a negative result, n is added_\n\n_back to z to restore z to the correct range mod n_\nNow, the function shifts x to the left by one bit. The formerly leftmost bit of x is then left in the\ncarry flag. If the bit was 1, y is added to z; if it was 0, y is not added to z (Figure 5).\n\n\n-----\n\n_Figure 5: The big number multiplication function shifts x to_\n\n_the left by one bit and uses the formerly-leftmost bit to determine whether y should be added_\n_to the running product z on this iteration_\nIn either case, z is again restored into the range [0,n) so that all calculations remain mod n.\nThis process continues for 1024 iterations. Put another way, x is examined bit-by-bit to\ndetermine whether or not y should be added to the intermediate product z on each iteration\nbefore it is shifted. After all the iterations, x is overwritten with the product z (Figure 6).\n\n\n-----\n\n_Figure 6: The value x is overwritten with the running_\n\n_product z once the calculation is complete_\nNote that sub_401B24 can be used to calculate x2 mod n by calling sub_401B24(x, x, n).\n\n## Binary Exponentiation Function\n\n\nWe found that the big number multiplication function previously described was repeatedly\ncalled by what we analyzed to be a binary exponentiation function, sub_4019C0 (x, buf, n,\n_m). This binary exponentiation function computes x = x256mod n if m is NULL, or x =_\n_mx256mod n if m is not NULL. When the binary exponentiation function squares x eight times,_\nand optionally multiplies by m, the binary exponentiation function makes nine separate calls\nto the big number multiplication function in an “unrolled” fashion, making its purpose slightly\nmore difficult to identify. Here is an excerpt of the IDA pseudocode from the binary\nexponentiation function:\n\n_const __m128i *__stdcall sub_4019C0 (const __m128i *x, __m128i *buf, int n, int m)_\n\n_{_\n_…_\n\n_x0 = x;_\n\n_y0 = buf;_\n\n_i0 = 8;_\n\n\n-----\n\n_do_\n_{_\n_*y0++ = _mm_load_si128 (x0++) ;_\n_--i0;_\n_}_\n_while ( i0 );_\n_y1 = buf;_\n_x1 = x;_\n_sub_401B24((__m128i *)x, (int)buf, (_DWORD *) n);_\n_i1 = 8;_\n_do_\n_{_\n_*y1++ = _mm_load_si128(x1++);_\n_--i1;_\n_}_\n_while ( i1 );_\n_..._\n_y8 = buf;_\n_x8 = x;_\n_result = sub_401B24 ((__m128i *)x, (int) buf, (_DWORD *) n);_\n_if ( m )_\n_{_\n_i8 = 8;_\n_do_\n_{_\n_*y8++ = _mm_load_si128 (x8++);_\n_--i8;_\n_}_\n_while ( i8 );_\n_return sub_401B24 ((__m128i *) x, m, (_DWORD *) n);_\n_}_\n_return result;_\n_}_\n\n## RSA Encryption Function\n\nWith the pieces put together, now we can understand the RSA encryption function in\nBLACKMATTER that wraps the other routines. The RSA encryption function sub_40183C\n(m, n) encrypts m by calculating m=m65537mod n. As individual steps it operates as follows:\n\n\n1. Let buf and x be 1024-bit integers, and let x = 1.\n2. Call the binary exponentiation function sub_4019C0 (x, buf, n, m) to calculate x = mx256\n\nmod n, which, since x = 1, is just x = m.\n\n\n-----\n\n3. Call the binary exponentiation function sub_4019C0 (x, buf, n, 0) to calculate x = x\n\n\nmod n.\n4. Call the binary exponentiation function sub_4019C0 (x, buf, n, m) to calculate x = mx256\n\nmod n\n\nAt the end of these steps, x = m(m256 256) _mod n = m65537mod n._\n\nHere is an excerpt of the IDA pseudocode from the overall RSA encryption function:\n\n___m128i *__stdcall sub_40183C(__m128i *m, __m128i *n)_\n_{_\n_…_\n_x [0] .m128i_i64 [1] = 0i64;_\n_memset (&x [1], 0, 112);_\n_x [0] .m128i_i64 [0] = 1i64;_\n_sub_4019C0 (x, buf, n, m);_\n_sub_4019C0 (x, buf, n, 0);_\n_sub_4019C0 (x, buf, n, m);_\n_px = x;_\n_pm = m;_\n_i = 8;_\n_do_\n_{_\n_*pm++ = *px++;_\n_--i;_\n_}_\n_while ( i );_\n_return px;_\n_}_\n\nSince Python natively supports big number integers, the entire BLACKMATTER calculation\ncould be simplified in Python as follows:\n\n_x = m_\n_for i in range (16):_\n_x = x * x % n_\n_x = x * m % n_\n\n## Conclusion\n\nIn analyzing BLACKMATTER we found that the author accomplishes RSA encryption with\nonly three freestanding functions with no external libraries. The RSA public key does not\nstand out as it is simply a 1024-bit integer in the binary. There are no magic numbers—not\neven 65537—because of how the code is structured; the number 65537 is implicit in\n\n\n-----\n\nperforming the sixteen squarings followed by one final multiplication by m; it is possible the\nauthor used inline assembly within the three routines. We hope the reader will find these\nobservations useful in spotting RSA implementations in other malware. We also found an\ninsightful reminder in that instead of obscuring the meaning of code through obfuscation and\npacking, an attacker can also hide it in plain sight by creating freestanding and minimalistic\nimplementations of cryptographic algorithms with no external dependencies.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-10-20 - Hidden in Plain Sight- Identifying Cryptography in BLACKMATTER Ransomware.pdf"
    ],
    "report_names": [
        "2021-10-20 - Hidden in Plain Sight- Identifying Cryptography in BLACKMATTER Ransomware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535561,
    "ts_updated_at": 1743041151,
    "ts_creation_date": 1653781094,
    "ts_modification_date": 1653781094,
    "files": {
        "pdf": "https://archive.orkl.eu/7bcbf1a8f72b4e1f35e5a61b4c6b1f445d58052f.pdf",
        "text": "https://archive.orkl.eu/7bcbf1a8f72b4e1f35e5a61b4c6b1f445d58052f.txt",
        "img": "https://archive.orkl.eu/7bcbf1a8f72b4e1f35e5a61b4c6b1f445d58052f.jpg"
    }
}