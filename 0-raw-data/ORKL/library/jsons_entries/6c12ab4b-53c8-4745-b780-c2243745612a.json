{
    "id": "6c12ab4b-53c8-4745-b780-c2243745612a",
    "created_at": "2022-10-25T16:48:15.625781Z",
    "updated_at": "2025-03-27T02:08:41.300969Z",
    "deleted_at": null,
    "sha1_hash": "65813bc5054466f69f114c47867e596c8b7a5b10",
    "title": "",
    "authors": "",
    "file_creation_date": "2011-06-29T04:48:39Z",
    "file_modification_date": "2011-06-29T04:48:39Z",
    "file_size": 325232,
    "plain_text": "# Breaking the links: Exploiting the linker\n\n### Tim Brown\n\n June 29, 2011\n\n_[<mailto:timb@nth-dimension.org.uk>](mailto:timb@nth-dimension.org.uk)_\n_[<http://www.nth-dimension.org.uk/> / <http://www.machine.org.uk/>](http://www.nth-dimension.org.uk/)_\n\n**Abstract**\n\nThe recent discussion relating to insecure library loading on the Microsoft Windows platform\nprovoked a significant amount of debate as to whether GNU/Linux and UNIX variants could\nbe vulnerable to similar attacks. Whilst the general consensus of the Slashdot herd appeared\nto be that this was just another example of Microsoft doing things wrong, I felt this was unfair\nand responded with a blog post[1] that sought to highlight an example of where POSIX style\nlinkers get things wrong. Based on the feedback I received to that post, I decided to investigate\nthe issue a little further. This paper is an amalgamation of what I learnt. As such it contains\nmy own research, the discoveries of others and POSIX lore.\n\n## Contents\n\n**1** **Technical Details** **2**\n1.1 What is the linker? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n1.1.1 The link editor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n1.1.2 The runtime linker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n1.2 The linker attack surface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n1.2.1 The process of linking and executing . . . . . . . . . . . . . . . . . . . . . . . 2\n1.2.2 Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.2.3 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.2.4 issetugid() and friends . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n1.3 Real world exploitation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n1.3.1 The runtime linker as an interpreter . . . . . . . . . . . . . . . . . . . . . . . 6\n1.3.2 The empty library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.3 SIGSEGV’ing for 12 years . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.3.4 What’s in your RPATH? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n1.3.5 Debian makes me sad :( . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.3.6 If an environment variables is set but you don’t trust it, is it still there? . . . 11\n1.3.7 Reflections on Trusting Trust revisited . . . . . . . . . . . . . . . . . . . . . . 12\n1.3.8 Mapping NULL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n1.4 Auditing scripts, binaries and source . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.4.1 Scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.4.2 Binaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.4.3 Source . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.5 Further research . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n1.5.1 Other linkers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n\n**2** **Changes** **14**\n\n1\n\n\n-----\n\n## List of Tables\n\n1 Environmental attack surface for Solaris, Debian GNU/Linux and FreeBSD runtime\nlinker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n\n## List of Figures\n\n1 Process flow for runtime linker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n\n## 1 Technical Details\n\n### 1.1 What is the linker?\n\nThe linker is a program that takes one or more objects generated by a compiler and combines them\ninto a single executable program. On GNU/Linux and UNIX variants, linking generally consists of\ntwo stages, one during compilation and one at runtime.\n\n**1.1.1** **The link editor**\n\nWhen a program comprises multiple object files, the link editor (often referred to as ld) combines\nthese files into an executable program, resolving the dependencies as it goes along. Link editors can\ntake objects from a collection called a library. Unless a static binary has been requested, link editors\ndo not include the whole library in the output. Rather, they include its symbols (references from\nthe other object files or libraries), as a guide to the runtime linker which will need to be resolved\nwhen the binary is executed.\n\n**1.1.2** **The runtime linker**\n\nThe runtime linker (generally known as ld.so) is actually a special loader that resolves the external\ndependencies (in the form of symbols) for a given executable prior to execution. It then maps access\nto the libraries that implement these functions in order to allow successful execution. As we will see\nbelow the way the runtime linker functions can vary significantly even between ostensibly similar\nplatforms.\n\n### 1.2 The linker attack surface\n\n**1.2.1** **The process of linking and executing**\n\nIn order to execute a binary, the runtime linker must resolve any dependencies to ensure that\nexternally referenced functions are available within the excecuted binaries process space.\nFirstly they look at the hints built into the binary being called. These hints take the form of the\n```\nDT_RPATH and DT_RUNPATH ELF headers which consist of colon separated lists of directories that\n\n```\nthe linker should examine when looking for libraries. The linker will typically check whether the\nprocess is setUID or not in order to determine whether macros such as $ORIGIN (which points at\nthe binaries own path) should be expanded or not.\nIn the event that a binary does not have these ELF headers or the linker is unable to resolve\nall dependencies using the hinted directories, it will then examine environment variables such as\n```\nLD_LIBRARY_PATH. As with the expansion of $ORIGIN care should be taken when the process is\n\n```\nsetUID as if the linker were to trust LD_LIBRARY_PATH in such a case then it could be manipulated\ninto loading malicious libraries at the behest of the calling user.\nIf the linker is still unable to find a dependancy, then the system’s default configuration (in the form\nof the library cache (ld.so.cache on Debian GNU/Linux)) is consulted before the linker finally\ntries the hardcoded directories /lib and /usr/lib.\n\n2\n\n\n-----\n\nIn general terms, runtime linkers implement the following flow in resolving dependencies.\n\nFigure 1: Process flow for runtime linker\n\n\n### DT_RPATH issetuid()\n\n Environment\n\n Environment\n\n Environment\n\n issetuid()\n\n issetuid()\n\n issetuid()\n\n Files\n\n Files\n\n Files\n\n FreeBSD 8.1\n\n /lib:/usr/lib\n\n /lib:/usr/lib\n\n|issetuid() issetuid|Col2|Col3|Col4|\n|---|---|---|---|\n||setuid() issetuid|||\n|||setuid||\n|||||\n\n|DT_RPATH DT_RPA|Col2|Col3|Col4|Col5|Col6|Col7|Col8|Col9|Col10|Col11|Col12|Col13|Col14|Col15|\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\n||_RPATH DT_RPA||||||||||||||\n||||||||||||||||\n|||_RPA||A|||||||||||\n||||||||||||||||\n|||||||H E|||||||||\n||||||||||||||||\n||||||||||i|ronment Environm|||||\n|||||||||||||vironm||nt m|\n||||||||||||||||\n||||||||||||||||\n\n|n|t i|\n|---|---|\n\n|s|etuid() issetuid|Col3|Col4|\n|---|---|---|---|\n|||setuid||\n|||||\n\n|Files Files|Col2|Col3|Col4|Col5|\n|---|---|---|---|---|\n||Files Files||||\n||||Files||\n||||||\n||||||\n\n|/lib:/usr/lib /lib:/usr|Col2|Col3|Col4|\n|---|---|---|---|\n||:/usr/lib /lib:/usr|||\n|||b:/usr||\n|||||\n\n\n3\n\n\n-----\n\nYou’ll notice in 1 that certain nodes have been coloured green and red. Whilst I’ll explain the\nreasons for this in more detail later in the paper, nodes that are red contain potential weaknesses\nthat may be exploited by manipulating various facets of the linker attack surface.\n\n**1.2.2** **Environment**\n\nLinkers have a long history of being attacked via environment variables. As you can see below they\nvary significantly in terms of which environment variables each supports and only a small core of\nthem are present in two or more linkers:\n\nTable 1: Environmental attack surface for Solaris, Debian\nGNU/Linux and FreeBSD runtime linker\n\n**Linker Stage** **Solaris 10** **Debian GNU/Linux 6.0 (eglibc)** **FreeBSD 8.1**\nld LD RUN PATH\nld. so LD LIBRARY PATH[1] LD LIBRARY PATH[1] LD LIBRARY PATH\nLD PRELOAD[17] LD PRELOAD[1] LD PRELOAD\nLD TRACE LOADED LD TRACE LOADED\nOBJECTS OBJECTS\n\nLD BIND NOW[7] LD BIND NOW LD BIND NOW\nLD BIND NOT\nLD AOUT LIBRARY\nPATH[1]\n\nLD AOUT\nPRELOAD[1]\n\nLD NOWARN\nLD WARN\nLD KEEPDIR\nLD ORIGIN PATH\nLD SHOW AUXV\nLD HWCAP MASK\nLD USE LOAD BIAS\nLD POINTER\nGUARD\nLD TRACE PRELINKING\nLD DEBUG[127] LD DEBUG[12]\n\nLD DEBUG OUT- LD DEBUG OUTPUT[27] PUT[12]\n\nLD VERBOSE\nLD PROFILE[37] LD PROFILE[13]\n\nLD PROFILE OUT- LD PROFILE OUTPUT[37] PUT[13]\n\nLD ASSUME KERNEL\nLD AUDIT[7] LD AUDIT[4]\n\nLD CONFIG[7]\n\nLD DEMANGLE[7]\n\nLD FLAGS[7]\n\nLD LOADFLTR[7]\n\nLD NOAUDIT[7]\n\nLD NOAUXFLTR[7]\n\nLD NOCONFIG[7]\n\nContinued on next page. . .\n\n4\n\n|Linker Stage|Solaris 10|Debian GNU/Linux 6.0 (eglibc)|FreeBSD 8.1|\n|---|---|---|---|\n|ld||LD RUN PATH||\n|ld. so|LD LIBRARY PATH1 LD PRELOAD17 LD BIND NOW7 LD DEBUG127 LD DEBUG OUT- PUT27 LD PROFILE37 LD PROFILE OUT- PUT37 LD AUDIT7 LD CONFIG7 LD DEMANGLE7 LD FLAGS7 LD LOADFLTR7 LD NOAUDIT7 LD NOAUXFLTR7 LD NOCONFIG7|LD LIBRARY PATH1 LD PRELOAD1 LD TRACE LOADED OBJECTS LD BIND NOW LD BIND NOT LD AOUT LIBRARY PATH1 LD AOUT PRELOAD1 LD NOWARN LD WARN LD KEEPDIR LD ORIGIN PATH LD SHOW AUXV LD HWCAP MASK LD USE LOAD BIAS LD POINTER GUARD LD TRACE PRE- LINKING LD DEBUG12 LD DEBUG OUT- PUT12 LD VERBOSE LD PROFILE13 LD PROFILE OUT- PUT13 LD ASSUME KER- NEL LD AUDIT4|LD LIBRARY PATH LD PRELOAD LD TRACE LOADED OBJECTS LD BIND NOW|\n\n\n-----\n\n**Linker Stage** **Solaris 10** **Debian GNU/Linux 6.0 (eglibc)** **FreeBSD 8.1**\nLD NODIRCONFIG[7]\n\nLD NODIRECT[7]\n\nLD NOENVCONFIG[7]\n\nLD NOLAZYLOAD[7]\n\nLD NOOBJALTER[7]\n\nLD NOVERSION[7]\n\nLD ORIGIN[7]\n\nLD SIGNAL[7]\n\nLD DUMP\nPOST\nLD DUMP REL PRE\nLD LIBMAP\nLD LIBMAP\nABLE\nLD ELF\nPATH\nLD TRACE LOADED\nOBJECTS ALL\nLD TRACE LOADED\nOBJECTS FMT1\nLD TRACE LOADED\nOBJECTS FMT2\nLD TRACE LOADED\nOBJECTS\nNAME\nLD UTRACE\n\nOf course there are a whole raft of other variables[2] that can affect the linker but these are the ones\nsupported by ld and ld.so directly.\n\n**1.2.3** **Files**\n\nIn addition to the environment variables listed above, runtime linkers normally have default configurations which they will fall back on when the variables aren’t set. The pertinant files are listed\nbelow with notes where necessary:\n**Solaris 10:**\n\n_• /var/ld/ld.config_\n\n_• /var/ld/64/ld.config_\n\nThese are typically generated using crle.\n\n**Debian GNU/Linux 6.0 (eglibc):**\n\n1Cleared on setUID/SetGID execution\n2Writes to $0.$$\n3Writes to /var/tmp/<libraryname> or $LD PROFILE OUTPUT/<libraryname> (Solaris) or\n$LD PROFILE OUTPUT (Debian GNU/Linux (eglibc))\n[4Exploited on glibc by Tavis Ormandy: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-CVE-2010-3847](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-CVE-2010-3847)\n[and http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3856](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3856)\n532-bit versions take the form LD 32 . . .\n6Exploited by Nikolaos Rangos (Kingcope): `http://lists.freebsd.org/pipermail/freebsd-announce/`\n```\n2009-December/001289.html\n\n```\n732-bit versions take the form . . . 32 and 64-bit versions take the form . . . 64\n\n5\n\n|Col1|LD NODIRCONFIG7 LD NODIRECT7 LD NOENVCONFIG7 LD NOLAZYLOAD7 LD NOOBJALTER7 LD NOVERSION7 LD ORIGIN7 LD SIGNAL7|Col3|LD DUMP REL POST LD DUMP REL PRE LD LIBMAP LD LIBMAP DIS- ABLE LD ELF HINTS PATH LD TRACE LOADED OBJECTS ALL LD TRACE LOADED OBJECTS FMT1 LD TRACE LOADED OBJECTS FMT2 LD TRACE LOADED OBJECTS PROG- NAME LD UTRACE|\n|---|---|---|---|\n\n\n-----\n\n_• /etc/ld.so.cache_\n\nThis is typically generated from /etc/ld.so.conf and updated when ldconfig is executed, for\nexample as part of the installation of packages.\n\n_• /etc/ld.so.preload_\n\n_• /etc/ld.so.nohwcap_\n\n_• /etc/suid-debug_\n\nWhilst this isn’t documented in the man page for ld.so when present it changes how binaries\nwith the setUID bit set are executed.\n\n**FreeBSD 8.1:**\n\n_• /var/run/ld-elf.so.hints_\n\n_• /var/run/ld-elf32.so.hints_\n\n_• /etc/libmap.conf_\n\n_• /etc/libmap32.conf_\n\n**1.2.4** **issetugid() and friends**\n\nSo how does the runtime linker determine whether it should trust user supplied input such the various\n```\nLD_... environment variables. Well it depends, for the most part all runtime linkers examine the\n\n```\nreal and effective UID of the process, if these are different then the process is considered tainted\nand user supplied input will be ignored. That’s the theory, but in practice it isn’t quite that clear\ncut. Whilst all the linkers I’ve looked at make this check, it does need to be applied every time the\nruntime linker considers an environment variable and as Tavis pointed out, it only takes one case\nwhere the check is missed before you’re in a whole world of pain. Although eglibc does tear down\nthe LD_... environment variables, it only does this after it has processed them, so if there’s a bug\nin the ld.so this may still be exploitable.\nAnother factor worth considering is the fact that the GNU/Linux world is moving away from the\nuse of a simple setUID bit on executable to request a change of privileges. In the last month or so,\nI’ve started to see discussions on oss-security regarding replacing the setUID bit with file system\ncapabilities[3]. Whilst allowing privilege changes using this mechanism should allow the privileges\nto be set in a far more granular manner, it will require significant changes to how processes gain\nand drop privileges, something we’re likely to see exploited in due course.\n\n### 1.3 Real world exploitation\n\n**1.3.1** **The runtime linker as an interpreter**\n\nImagine a situation in which you’ve by one means or another managed to get command execution\nas a non-privileged user and you’re looking for a way to elevate your privileges to the root user. You\nnotice that the kernel is unpatched against a known vulnerability but you can’t create executable\nfiles (for example that pre-compiled version of the exploit you were playing with in your lab last\nweek). This is a real world problem, and one that the runtime linker can help you with. You see,\nthe runtime linker is actually an interpreter, albeit one geared for binaries:\n```\nuser@host:~$ cp /usr/bin/id .\nuser@host:~$ chmod a-x id\nuser@host:~$ ls -la id\n-rw-r--r-- 1 user user 32176 Oct 30 13:55 id\nuser@host:~$ ./id\n\n```\n6\n\n\n-----\n\n```\nbash: ./id: Permission denied\nuser@host:~$ /lib/ld-linux-x86-64.so.2 ./id\nuid=1000(user) gid=1000(user) groups=1000(user),20(dialout),24(cdrom),25(floppy),29(audio),\n44(video),46(plugdev),50(staff),116(lpadmin)\n\n```\nAs you can see here, I’ve taken the id binary and removed its execute bits. Whilst it can’t be run\ndirectly since the execute bits have been removed, the runtime linker (in this case the 64-bit version\nof eglibc’s runtime linker) can still load and execute it without a problem.\nSo why does this work? Well, taking a look at the permissions on the runtime linker we’ll start to\nsee why:\n```\nlrwxrwxrwx 1 root root 12 Sep 16 12:03 /lib/ld-linux-x86-64.so.2 -> ld-2.11.2.so\n-rwxr-xr-x 1 root root 128744 Sep 15 02:31 /lib/ld-2.11.2.so\n\n```\nYou can see that ld-2.11.2.so has execute bits set. The fact is that the runtime linker is just\nanother executable file, albeit one we rarely call directly. Indeed, on most GNU/Linux variants, the\n```\nldd binary is normally implemented as a shell script wrapper around it:\n# This is the ‘ldd’ command, which lists what shared libraries are\n# used by given dynamically-linked executables. It works by invoking the\n# run-time dynamic linker as a command and setting the environment\n# variable LD_TRACE_LOADED_OBJECTS to a non-empty value.\n\n```\nAs pointed out by @taviso and @stealth, it’s worth highlighting that the Linux kernel’s behaviour\nwith regard to noexec is different from the norm. Mounting the file system with noexec actively\nprevents the kernel mmap()’ing the pages with execute permissions. However from a general hardening perspective, if you’re mounting devices with noexec then you should also ensure that the\nruntime linker can’t be executed either.\n\n**1.3.2** **The empty library**\n\nSo there’s been a lot of fuss over the last couple of months about the Microsoft Insecure Library\nLoading Could Allow Remote Code Execution[4] vulnerability. Whilst it’s fair to say that the\nGNU/Linux dynamic linker doesn’t by default include . in its path and you’ll very rarely see it\nlisted in ld.so.conf and friends, there are some corner cases.\nGNU/Linux and POSIX style linkers makes use of a variable called LD_LIBRARY_PATH which is\nconsulted when a binary is executed and which takes precedence over the OS default as set in\n```\nld.so.conf. Consider the following script:\n#!/bin/sh\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/app/lib\napp start\n\n```\nWhat happens if LD_LIBRARY_PATH isn’t set prior to the script being executed? Well, in that case,\nthe app binary is executed with a library path of :/path/to/app/lib. This may seem perfectly\nsatisfactory, but here’s the rub. When the GNU/Linux dynamic linker sees a path with an empty\ndirectory specification such as :/valid/path, /valid/path: or /valid::/path, it treats the empty\nelement as $PWD. This could lead to a library being loaded from the users current working directory\nwhich might be exploitable. Go back to the shell script snippet above and consider what would\n\n7\n\n\n-----\n\nhappen if that was the init script for a privileged process. An administrator needs to stop and start\nit but he works in a security aware environment and only has access to the init script via the sudo\ncommand. So off he goes:\n```\nuser@host:~$ sudo /etc/init.d/app\n\n```\nSudo by default won’t change your working directory when it executes a command as another user\nwhich means that LD_LIBRARY_PATH will end up pointing at the unprivileged user’s own directory.\nWhat that means is that the GNU/Linux dynamic linker will attempt to load any library dependencies firstly from there.\nSince I wrote my blog post highlighting this corner case, a number of real world examples have come\nto light:\n\n_[• http://osvdb.org/show/osvdb/69641 - Mozilla Firefox](http://osvdb.org/show/osvdb/69641)_\n\n_[• http://osvdb.org/show/osvdb/70716 - Sun OpenOffice.org](http://osvdb.org/show/osvdb/70716)_\n\n_[• http://osvdb.org/search?search%5Bvuln_title%5D=LD_LIBRARY_PATH&search%5Btext_type%](http://osvdb.org/search?search%5Bvuln_title%5D=LD_LIBRARY_PATH&search%5Btext_type%5D=alltext)_\n```\n   5D=alltext - and many more...\n\n```\nSo how can you set LD_LIBRARY_PATH safely? Well obviously you can check whether it is set before\nyou append to it, but the following also seems to work quite nicely:\n```\nexport LD_LIBRARY_PATH=\"${LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:}/path/to/app\"\n\n```\nIt’s worth noting too that Debian (at least) are looking to fix[5] the underlying cause.\n\n**1.3.3** **SIGSEGV’ing for 12 years**\n\nWhilst I was fuzzing the various runtime linkers, I came across a number of cases where I could\ncause my test binary to crash by manipulating the various LD_... environment variables. One such\ncase was on Solaris 10 where setting LD_PRELOAD as follows:\n```\nuser@host:~$ LD_PRELOAD=: su \n```\nleads to a segmentation fault.\nThe same bug appeared to affect both setUID and normal binaries and yields the following when\nwhen the core dump is examined with gdb:\n```\nCore was generated by ‘./test’.\nProgram terminated with signal 11, Segmentation fault.\n#0 0xfefcfc71 in ?? ()\n(gdb) x/1i $eip\n0xfefcfc71: movsbl (%esi),%ecx\n(gdb) info reg esi ecx\nesi 0x0 0\necx 0x0 0\n\n```\n8\n\n\n-----\n\nwhich sadly is a NULL pointer dereference inside ld.so.1.\nA similar bug was reported publicly[6] in 2005, but according to Sun this one is different. For what\nit’s worth, it’s been present since Solaris 8 and affects up to and including the last public release of\nOpenSolaris.\nSun have assigned issue number 7001523 to this issue.\nFurther discussions with Sun indicates that this is extremely unlikely to be exploitable since mappings made using mmap() are not preserved during an exec. This rules out the possibility of mapping\naddress zero and then exec()’ing another binary with LD_PRELOAD set.\n\n**1.3.4** **What’s in your RPATH?**\n\nI’ve already spoken in this paper on one such case where the runtime linker can be tricked into using\nmalicious libraries using the LD_LIBRARY_PATH environment variable but there’s actually another\nmore interesting case which I’d like to discuss.\nIf you examine the linker attack surface table above you’ll notice that I mention an environment\nvariable LD_RUN_PATH which affects the link editor. By setting this (or indeed the -rpath flag) it is\npossible to hardset additonal locations where the runtime linker should look when resolving external\ndependencies. On GNU/Linux at least, when the DT_RPATH or DT_RUNPATH exists within the ELF\nheaders of a binary then these will be honoured first when looking for shared libraries. Additionally,\nthe keyword $ORIGIN within this header is expanded to be the path of the directory where the object\nis found, while both . and the empty directory specification are honoured, even for binaries with\nthe setUID bit set. From an attackers pespective, setUID binaries with DT_RPATH are particularly\nnice, since we can make use of hard links to manipulate the runtime linker into using an $ORIGIN\nwhich we can control.\nBy way of a comparison, Solaris and FreeBSD appears to ignore $ORIGIN for setUID binaries and\nDebian patched the $ORIGIN issues with libc6 2.11.2-7.\nNote that Solaris has another problem relating to DT_RPATH which I’ll discuss later.\nFor reference, I took a quick look at three third party applications installed on my test machine,\nEMC VMware Server, IBM DB2 Express Edition and Oracle XE and found a number of interesting\nvalues had been set during the compilation of included binaries DT_RPATH ELF headers.\nFirstly let’s take a look at Oracle XE. On 10.2.0 I identified that a number of binaries that have\n```\nDT_RPATH ELF headers that reference $ORIGIN however these aren’t generally exploitable as the\n\n```\nbinaries concerned are likely to be executed from their installed location and since none of the\nbinaries have the setUID flag set. There was however one interesting case where the osdbagrp\nbinary references a fixed, non existent location:\n```\nhost:/usr/lib/oracle/xe/app/oracle/product/10.2.0/server/bin# readelf -d osdbagrp | grep RPATH\n0x0000000f (RPATH) Library rpath: [/ade/aime1_hrel10/oracle/lib]\n\n```\nIn the event that an attacker could leverage another bug to create and or write to the /ade/aime1_hrel10/oracle/lib\ndirectory or parent then it may be possible subvert the execution flow whenever this binary is called.\nLikewise EMC VMware Server 2.0.2 and VMware Workstation 7.1.3 suffers from a similar flaw:\n```\nhost:/usr/local/bin# readelf -d vmrun | grep RPATH\n0x000000000000000f (RPATH) Library rpath: [/build/mts/release/\nbora-203138/bora/build/release-x64/apps/vixWrapper]\n\n```\nIt’s worth noting that to perform such an attack would likely require an administrator to be manipulated, both to create the directory with weak permissions and to execute the vulnerable binary.\nSo we’ve seen two examples of applications that have minor flaws, how about something useful.\nWell, as my final example, I looked at IBM DB2 Express Edition 9.7. Like the previous examples\n\n9\n\n\n-----\n\nwe’ve seen, DB2 suffers from having binaries that have the DT_RPATH set to non-existant directories\nbut in this case there are some other more interesting flaws. Firstly, one of the binaries affected is\nrun by root on system start from inittab:\n```\nhost:~# tail -1 /etc/inittab\nfmc:2345:respawn:/opt/ibm/db2/V9.7/bin/db2fmcd #DB2 Fault Monitor Coordinator\nhost:~# readelf -d /opt/ibm/db2/V9.7/bin/db2fmcd | grep RPATH\n 0x000000000000000f (RPATH) Library rpath: [/DoNotCreateThisPath_marker1\n.*chglibpath:/opt/ibm/db2/V9.7/lib64:/opt/ibm/db2/V9.7/lib64/N/icc/osslib:\n/opt/ibm/db2/V9.7/lib64/C/icc/osslib:/opt/ibm/db2/V9.7/lib64/N/icc/icclib:\n/opt/ibm/db2/V9.7/lib64/C/icc/icclib:/\n\n```\nBut there’s more:\n```\nhost:~# readelf -d /opt/ibm/db2/V9.7/bin/db2rspgn | grep RPATH\n 0x000000000000000f (RPATH) Library rpath: [.:/DoNotCreateThisPath_marker1\n.*chglibpath:/opt/ibm/db2/V9.7/lib64:/opt/ibm/db2/V9.7/lib64/N/icc/osslib:\n/opt/ibm/db2/V9.7/lib64/C/icc/osslib:/opt/ibm/db2/V9.7/lib64/N/icc/icclib:\n/opt/ibm/db2/V9.7/lib64/C/icc/icclib:/\n\n```\nAs you can see, in this case, the value for the DT_RPATH ELF header includes ., the current working\ndirectory which makes exploitation a little easier.\nOf course, what we really need is a setUID binary that suffers from such a flaw, and IBM in\ntheir wisdom were happy to oblige. Consider the following binary installed as part of IBM Tivoli\nMonitoring for Databases: DB2 Agent:\n```\nuser@host:~$ ls -la /opt/ibm/db2/V9.7/itma/tmaitm6/lx8266/bin/kbbacf1\n-rwsr-xr-x 1 root root 8558 Oct 6 22:11 /opt/ibm/db2/V9.7/itma/tmaitm6/lx8266/bin/kbbacf1\nuser@host:~$ readelf -d /opt/ibm/db2/V9.7/itma/tmaitm6/lx8266/bin/kbbacf1 | grep RPATH\n 0x000000000000000f (RPATH) Library rpath: [/opt/IBM/ITM/tmaitm6/links/\nlnxx86x6-l23-g34/lib:.:./lib:../lib]\n\n```\nAs you can see, as with the previous case of db2rspgn, the value for the DT_RPATH ELF header\nincludes ., but in this case kbbacf1 is setUID root. Such a case can be exploited like so:\n```\nuser@host:~$ ./tmb-vs-ibm-db2\nPoC exploit for IBM DB2 DT_RPATH privesc.\n(c) Tim Brown, 2011\n<mailto:timb@nth-dimension.org.uk>\n<http://www.nth-dimension.org.uk/> / <http://www.machine.org.uk/>\nConstructing bad_libkbb.so...\nHave a root shell...\nuid=0(root) gid=1000(user) groups=0(root),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),44(vid\n#\n\n```\nOracle has assigned issue number 10319062 to the issue with Oracle XE 10.2.0. Whilst they do not\nplan to issue a patch (XE is an unsupported product), they have confirmed that the affected binary\nwas not intended to be shipped and will be removing it from future releases. In the case of VMware\n\n10\n\n\n-----\n\nServer, EMC’s security team confirmed the issue and requested that disclosure was delayed whilst\na review of other product lines was performed. Whilst EMC do not intend to issue a patch for\nVMware Server (again an unsupported product) their review identified that VMware Workstation\nsuffered from the same flaw and in this case a patch will be issued. IBM failed to respond.\n\n**1.3.5** **Debian makes me sad :(**\n\nOn Debian GNU/Linux hosts, the runtime linker cache (ld.so.cache) is generated from the contents\nof /etc/ld.so.conf.d/* (/etc/ld.so.conf just includes the contents of this directory). One of the\nfiles included is /usr/local/lib which is writable by the staff group. This sounds useful but there\nis a problem. The library search path order generated in the cache is such that dependencies are likely\nto be resolved before the runtime linker gets as far as looking at libraries under /usr/local/lib.\nBecause of this I began looking for ways to control the order in which the standard libraries are\nsearched and in doing so I stumbled across the LD_ASSUME_KERNEL variable which can be set for\nthe excution of any binary including those that have the setUID bit set. The eglibc man page for\n```\nld.so[7] states that:\n\n```\nEvery DSO (Dynamic Shared Object, aka shared library) can tell the dynamic linker in\nglibc which minimum OS ABI version is needed. The information about the minimum\nOS ABI version is encoded in a ELF note section usually named .note.ABI-tag. This\nis used to determine which library to load when multiple version of the same library\nis installed on the system. The LD_ASSUME_KERNEL environment variable overrides the\nkernel version used by the dynamic linker to determine which library to load.\n\nBy creating a copy of libc.so.6 under /usr/local/lib with an earlier ABI version and setting\nthe LD_ASSUME_KERNEL environment variable to the same version, any user in the staff group can\ncause binaries with the setUID bit set to use our copy like so:\n```\nuser@host:~$ ./test\nuid=1000,euid=0,gid=1000,egid=0\nuser@host:~$ LD_ASSUME_KERNEL=1.1.1 ./test\n./test: error while loading shared libraries: libc.so.6: cannot open shared object file:\nNo such file or directory\nuser@host:~$ cp libc.so.6 /usr/local/lib/\nuser@host:~$ LD_ASSUME_KERNEL=1.1.1 ./test\nuid=1000,euid=0,gid=1000,egid=0\n\n```\nIt’s worth noting a couple of things about the above attack. Firstly, I had to hexedit the library after\ncompilation to change the change the value of its .note.ABI-tag and secondly that after copying\n```\nlibc.so.6 into /usr/local/lib, I had to force ldconfig to be executed to update the runtime\n\n```\nlinker cache. In the real world you’d need to wait for an updated package to call it on your behalf\nduring installation.\nSince I orginally wrote this section of the paper, I’ve been doing some further research and it appears\nthat I actually got this wrong[8], it is not required to set LD_ASSUME_KERNEL in order for this to\nbe exploited as the cache generated by ldconfig appears to be constructed in reverse alphabetical\norder and therefore /usr/local/lib is checked before /usr/lib.\n\n**1.3.6** **If an environment variables is set but you don’t trust it, is it still there?**\n\nHaving seen how eglibc’s runtime linker can be manipulated, there will no doubt be a number of\npeople cracking jokes about long haired hippies so I figured I’d take a look how FreeBSD’s runtime\nlinker compares. The FreeBSD man page for ld.so[9] seems to indicate that it clears the vast\nmajority of linker related environment variables when it is used to execute but I decided to hook up\nmy fuzzer to make sure it didn’t do anything daft.\n\n11\n\n\n-----\n\nIt seems that whilst it ignores the vast majority of them when resolving runtime dependencies,\nunlike eglibc used by Debian GNU/Linux, it doesn’t actually unset[10] them in unsetenv which\nmeans they’re inheritable by all processes spawned by the setUID binaries. Having a look at the\ncode responsible, it seems to use issetugid()[11] to determine whether to trust the environment\nvariables. So far so good right? Well, not exactly, if the setUID binary sets the processes real user\nID based on the effective ID. This appears to untaint the running setUID process to a degree where\nthe runtime linker will trust the inherited linker specific environment variables including those such\nas LD_PRELOAD which can be used to modify the execution flow. Further testing appeared to show\nthat the Solaris linker was subject to the same attack.\nWhilst I haven’t found any cases of setUID binaries that are exploitable in this manner, it does show\nthe difference that subtleties in a linker implementation can make.\n\n**1.3.7** **Reflections on Trusting Trust revisited**\n\nA long time ago, Ken Thompson published a rather interesting paper entitled Reflections on Trusting\nTrust[12] which discussed the fact that you can’t trust code you didn’t write yourself (whether you\ncan trust your own code is another matter ;)) in which he discussed the idea of writing a compiler\nwhich would introduce vulnerabilities when used to compile arbitrary code. Moreover in his example,\nit would reintroduce this trojan horse if it detected that it was being used to recompile its own source.\nHe theorised that this could go undetected for a significant amount of time due to peoples inherent\ntrust of the compiler. In the process of writing this paper, I found a great example of such a compiler,\nalthough I would like to think that in the case I identified that it wasn’t Ken’s doing.\nThe premise of the bug I spotted is such. On Solaris, the issetugid() equivalent known as\n```\nsecurity() is used by ld.so.1 to set a flag on execution (RT_FL_SECURE) which the linker later uses\n\n```\nto determine whether to trust certain LD_... environment variables. Whilst fuzzing the runtime\nlinker, I notice that my test setUID binary appeared to continue to trust certain variables. I was able\nto call my binary with various LD_AUDIT and LD_PRELOAD variables and see the referenced libraries\nload. Corner case 1 was that the referenced library appeared to be loaded if it was in /usr/lib\nand not /usr/lib/secure as referenced in Sun’s own documentation. The second corner case was\nthat I couldn’t reproduce the effect with any of Sun’s own setUID binaries just with binaries I compiled myself. Anyway, after much head scratching I realised that gcc as distributed by Sun sets a\n```\nDT_RPATH ELF header on every binary it creates, and having dug into the code in some detail that\nld.so.1 will quite happily trust[13] (see is_path_secure()) this ELF header even when a setUID\n\n```\nbinary is being executed. So why does this remind me of Ken’s paper? Well, for much of the time I\nwas scratching my head, I hadn’t even considered the compiler as the villain of the piece, I’d trusted\nit to be trustworthy.\nSo I guess, for most of you the question becomes is it exploitable? The answer sadly appears to be\nno, at least not in most cases. To exploit this bug you need two things to have occurred. Firstly\nyou need a setUID binary compiled using the Sun supplied gcc and secondly you need a library that\ncan be passed via LD_AUDIT or LD_PRELOAD with a viable constructor or deconstructor. Those of\nyou that are familiar with Tavis’s second linker bug will doubtless recognise the second requirement\nbut try as I might I couldn’t find any libraries under /usr/lib etc that had useful functions with\nthis attribute defined, at least not on a default Solaris install.\nSun have assigned issue number 7001536 to this issue and have fixed it in GCC 4.3.2.\n\n**1.3.8** **Mapping NULL**\n\nStrange as it may seem, whilst the GNU/Linux world has finally moved to prevent userland processed\nfrom mmap()’ing NULL, this is not the case on Solaris where it can still be mapped. More strangely\nstill, Sun actually provide a library which maps 0, with the following rationale (taken from the man\npage for ld.so.1[14]:\n\nThe user compatibility library /usr/lib/0@0.so.1 provides a mechanism that establishes a\nvalue of 0 at location 0. Some applications exist that erroneously assume a null character\npointer should be treated the same as a pointer to a null string. A segmentation violation\n\n12\n\n\n-----\n\noccurs in these applications when a null character pointer is accessed. If this library is\nadded to such an application at runtime using LD PRELOAD, the library provides an\nenvironment that is sympathetic to this errant behavior. However, the user compatibility\nlibrary is intended neither to enable the generation of such applications, nor to endorse\nthis particular programming practice.\nIn many cases, the presence of /usr/lib/0@0.so.1 is benign, and it can be pre-loaded\ninto programs that do not require it. However, there are exceptions. Some applications,\nsuch as the JVM (Java Virtual Machine), require that a segmentation violation be generated from a null pointer access. Applications such as the JVM should not preload\n/usr/lib/0@0.so—.\n\n### 1.4 Auditing scripts, binaries and source\n\n**1.4.1** **Scripts**\n\nTo check for unsafe concatenation in shell scripts that could lead to empty directory specifications,\nyou can create your own libc.so in your home directory and then wait for scripts to fail like so:\n```\ntouch ./libc.so.6 && sudo ...\n\n```\nWhilst I’d being playing with privately, it’s also fair to mention that @kees cook also mentioned this\napproach on Twitter.\nAdditionally as described in 1.3.2, you can look for constructs such as:\n```\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/app/lib\n\n```\n**1.4.2** **Binaries**\n\nWith binaries you should firstly check the values of any DT_RPATH and DT_RUNPATH ELF headers\nwithin the binaries using one of the following commands:\n\n_• objdump -x ..._\n\n_• readelf -a ..._\n\n_• scanelf (from PaX)_\n\n_• elfdump (from Sun)_\n\nSecondly, as was seen in 1.3.6, you should be wary of any setUID binaries that depend on setuid()\nand which execute further processes without unsetting any inherited environment variables.\n\n**1.4.3** **Source**\n\nFinally, if you’re lucky enough to have the source, keep any eye out for the following patterns which\nwill lead to the unsafe ELF headers previously described.\nYou should look to identify any build scripts, Makefiles or similar which honour the LD_RUN_PATH\nenvironment variable.\nAs well as watching out for badly written build scripts you should also look at how gcc and the link\neditor themselves are called. The following command patters can be problematic.\n\n_• gcc -Wl,-R,..._\n\n_• ld [-rpath-rpath-link]=...—_\n\n13\n\n\n-----\n\n_• ld -R ..._\n\nAs I’ve already shown with scripts, the presence of . or the empty directory specification of the\n```\nDT_RPATH or DT_RUNPATH ELF headers, or in flags being used by gcc during the build process could\n\n```\nallow libraries to be loaded from the current working directory however you should also be mindful\nof $ORIGIN macros or hard coded directory specications.\n\n### 1.5 Further research\n\n**1.5.1** **Other linkers**\n\nThrough out the process of writing this paper, I’ve only really looked at 3 platforms, Solaris, FreeBSD\nand Debian GNU/Linux in any depth. To anyone with an understanding of the UNIX family tree,\nit should be obvious that there are a number of other POSIX style linkers to explore. Indeed, in\nthe course of writing this paper my attention was drawn to the QNX Neutrino RTOS which RIM\nare using as the base for their new BlackBerry tablet devices. This has a runtime linker which is\ncapable of loading ELF binaries in which I discovered a flaw which allows the execution flow of\nsetUID binaries to be manipulated.\nSome other targets I’d like to examine include:\n\n_• Mac OS X_\n\n_• AIX_\n\n_• OpenBSD_\n\nRIM have assigned PR84526 to the linker flaw in Neutrino.\n\n## 2 Changes\n\n29th June 2011 Another update with a number of redactions removed\n4th January 2011 Updated feedback from Sun/Oracle and EMC. Sun/Oracle okay disclosure\nof all 3 bugs, EMC confirm VMware Workstation also affected\n30th January 2011 Added RIM reference for QNX Neutrino RTOS issue reported on 16th\nDecember 2010 and added feedback from Sun on LD_PRELOAD bug\n5th January 2011 Further bug fixes\n16th December 2010 Bug fixes from oss-security\n15th December 2010 Initial public presentation at CRESTCon 2010 -, public release of paper on\nweb site and via oss-security mailing list\n12th December 2010 Added Sun/Oracle references, Reflections on Trusting Trust revisited, Mapping NULL and other misc bug fixes\n9th December 2010 Redacted specific vulnerabilities until vendor patches have been released,\nalso added details of linking process\n24th November 2010 IBM and EMC contacted regarding DB2 Express Edition and VMware\nServer\n15th November 2010 Sun/Oracle contacted regarding Solaris 10 and Oracle XE\n12th November 2010 Incorporated feedback including details on `issetugid(),`\n`/etc/suid-debug,` file system capabilities, noexec, references and\nother misc bug fixes. Also added details of LD_PRELOAD=: bug\n8th November 2010 Initial external peer review, thanks @stealth and @taviso\n\n14\n\n\n-----\n\n## References\n\n[[1] http://www.nth-dimension.org.uk/blog.php?id=87](http://www.nth-dimension.org.uk/blog.php?id=87)\n\n[[2] http://www.scratchbox.org/documentation/general/tutorials/glibcenv.html](http://www.scratchbox.org/documentation/general/tutorials/glibcenv.html)\n\n[[3] http://www.openwall.com/lists/oss-security/2010/11/08/3](http://www.openwall.com/lists/oss-security/2010/11/08/3)\n\n[[4] http://www.microsoft.com/technet/security/advisory/2269637.mspx](http://www.microsoft.com/technet/security/advisory/2269637.mspx)\n\n[[5] http://www.openwall.com/lists/oss-security/2010/09/29/1](http://www.openwall.com/lists/oss-security/2010/09/29/1)\n\n[[6] http://www.securityfocus.com/archive/1/403575/30/0/threaded](http://www.securityfocus.com/archive/1/403575/30/0/threaded)\n\n[[7] http://manpages.ubuntu.com/manpages/lucid/man8/ldo.so.8.html](http://manpages.ubuntu.com/manpages/lucid/man8/ldo.so.8.html)\n\n[[8] http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=504516](http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=504516)\n\n[[9] http://www.freebsd.org/cgi/man.cgi?query=ld.so](http://www.freebsd.org/cgi/man.cgi?query=ld.so)\n\n[[10] http://svn.freebsd.org/viewvc/base/head/lib/libc/stdlib/getenv.c](http://svn.freebsd.org/viewvc/base/head/lib/libc/stdlib/getenv.c)\n\n[[11] http://svn.freebsd.org/viewvc/base/head/libexec/rtld-elf/rtld.c](http://svn.freebsd.org/viewvc/base/head/libexec/rtld-elf/rtld.c)\n\n[[12] http://cm.bell-labs.com/who/ken/trust.html](http://cm.bell-labs.com/who/ken/trust.html)\n\n[[13] http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/cmd/sgs/](http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/cmd/sgs/rtld/common/paths.c)\n```\n   rtld/common/paths.c\n\n```\n[[14] http://docs.sun.com/app/docs/doc/819-2239/ld.so.1-1?a=view](http://docs.sun.com/app/docs/doc/819-2239/ld.so.1-1?a=view)\n\n15\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "http://www.nth-dimension.org.uk/pub/BTL.pdf"
    ],
    "report_names": [
        "BTL.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716495,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1309322919,
    "ts_modification_date": 1309322919,
    "files": {
        "pdf": "https://archive.orkl.eu/65813bc5054466f69f114c47867e596c8b7a5b10.pdf",
        "text": "https://archive.orkl.eu/65813bc5054466f69f114c47867e596c8b7a5b10.txt",
        "img": "https://archive.orkl.eu/65813bc5054466f69f114c47867e596c8b7a5b10.jpg"
    }
}