{
    "id": "ed3cf9e8-7875-4722-9a32-80158f3781b7",
    "created_at": "2023-01-12T15:08:18.429345Z",
    "updated_at": "2025-03-27T02:05:45.909178Z",
    "deleted_at": null,
    "sha1_hash": "6e4a0e19ff75538c0eb09cab927f119105adf86b",
    "title": "2020-06-09 - RagnarLocker Ransomware Threatens to Release Confidential Information",
    "authors": "",
    "file_creation_date": "2022-05-28T16:17:18Z",
    "file_modification_date": "2022-05-28T16:17:18Z",
    "file_size": 132982,
    "plain_text": "# RagnarLocker Ransomware Threatens to Release Confidential Information\n\n**[mcafee.com/blogs/other-blogs/mcafee-labs/ragnarlocker-ransomware-threatens-to-release-confidential-information](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/ragnarlocker-ransomware-threatens-to-release-confidential-information)**\n\n## Stories\n\nThe latest cybersecurity trends, best practices,\n\nsecurity vulnerabilities, and more\n\n**ARCHIVED STORY**\n\nAlexandre Mundo · JUN 09, 2020\n\n## EXECUTIVE SUMMARY\n\nThe RagnarLocker ransomware first appeared in the wild at the end of December 2019 as\npart of a campaign against compromised networks targeted by its operators.\n\nThe ransomware code is small (only 48kb after the protection in its custom packer is\nremoved) and coded in a high programming language (C/C++). Like all ransomware, the\n**goal of this malware is to encrypt all files that it can and request a ransom for**\n**decrypting them.**\n\nRagnarLocker’s operators, as we have seen with other bad actors recently, threaten to\npublish the information they get from compromised machines if ransoms are not paid.\n\nAfter conducting reconnaissance, the ransomware operators enter the victim’s network and,\nin some pre-deployment stages, steal information before finally dropping the ransomware\nthat will encrypt all files in the victim’s machines.\n\nThe most notable RagnarLocker attack to date saw this malware deployed in a large\ncompany where the malware operators then requested a ransom of close to $11 million\nUSD in return for not leaking information stolen from the company. In this report we will talk\nabout the sample used in this attack.\n\nAt the time of writing there are no free decryptors for RagnarLocker.\n\n\n-----\n\n**However, certain McAfee products, including personal antivirus, endpoint, and**\n**gateway can protect our customers against the threats that we talk about in this**\n**report.**\n\n## RAGNARLOCKER OVERVIEW\n\nThe unpacked malware is a binary file of 32 bits that can be found as an EXE file.\n\nFIGURE 1. INFORMATION ABOUT THE MALWARE\n_FIGURE 1. INFORMATION ABOUT THE MALWARE_\n\nAs can be seen in the previous screenshot, this sample was compiled on the 6th of April\n2020. The attack mentioned earlier took place some days later, but this sample was\nprepared for the victim, as we will explain later.\n\n**Name** malware.exe\n\n**Size** 48,460 bytes unpacked (can change between samples), packed can be\nvariable\n\n\n**File-**\n**Type**\n\n\nEXE 32 bits (can change between samples)\n\n\n**SHA 256** 7af61ce420051640c50b0e73e718dd8c55dddfcb58917a3bead9d3ece2f3e929\n\n**SHA 1** 60747604d54a18c4e4dc1a2c209e77a793e64dde\n\n\n**Compile**\n**time**\n\n\n06-04-2020 (can change between samples)\n\n\n## TECHNICAL DETAILS\n\nAs we often see with ransomware, RagnarLocker starts preparing some strings of\nlanguages for the CIS countries that are embedded within its own code (in Unicode).\n\nFIGURE 2. THE LANGUAGE STRINGS EMBEDDED INTO THE CODE IN THE STACK\n\n_FIGURE 1. INFORMATION ABOUT THE MALWARE_\n\nThe languages that are hardcoded are:\n\nGeorgian\n\nRussian\n\nUkrainian\n\n\n-----\n\nMoldavian\n\nBelorussian\n\nAzerbaijani\n\nTurkmen\n\nKyrgyz\n\nKazakh\n\nUzbek\n\nTajik\n\nAfter preparing these strings, the malware uses the function “GetLocaleInfoW” to get the\nLOCALE_SYSTEM_DEFAULT language as a string. Once obtained, it will check the system\nlanguage with the blacklisted languages and, if any of them match, it will terminate itself\nwith the function “TerminateProcess” and with an error result code of 0x29A (as we have\nseen before with many different malware samples).\n\nFIGURE 3. CHECK OF THE LANGUAGE AGAINST THE BLACKLIST\n\n_FIGURE 3. CHECK OF THE LANGUAGE AGAINST THE BLACKLIST_\n\nThe check against the LOCALE_SYSTEM_DEFAULT is to prevent a user from installing a\nlanguage they would not otherwise use as a means of avoiding infection. The check is\nmade against the language selected in Windows. Of course, not everyone in these\ncountries will be using a CIS language in Windows so English is also ok to use. As with\nother ransomware families, there is no guarantee that infection will be avoided if other\nlanguages are selected as the default.\n\nAfter this the malware will get the name of the infected computer with the function\n“GetComputerNameW” and the username of whoever is actively using the machine at that\ntime with the function “GetUserNameW”.\n\nFIGURE 3. CHECK OF THE LANGUAGE AGAINST THE BLACKLIST\n\n_FIGURE 4. GET THE COMPUTER NAME AND THE USERNAME_\n\nAfter this the malware will read two registry keys:\n\nHKLM\\SOFTWARE\\Microsoft\\Cryptography and the subkey MachineGuid to get the\nGUID of the victim machine.\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion and the subkey\n“ProductName” to get the name of the operating system.\n\n\n-----\n\nFor this the malware uses the functions RegOpenKeyExW, RegQueryValueExW and\n“RegCloseKey” in the hive HKEY_LOCAL_MACHINE. This hive can be read without admin\nrights.\n\nFIGURE 5. READ FROM THE REGISTRY THE NAME OF OPERATING SYSTEM AND\nGUIDE\n\n_FIGURE 5. READ FROM THE REGISTRY THE NAME OF OPERATING SYSTEM AND_\n_GUIDE_\n\nNext, RagnarLocker will prepare the first string in the stack with the function “lstrcpyW” and\nlater will start joining the strings with the function “lstrcatW”.\n\nThe sequence is first the GUID of the machine, then the Windows operating system name,\nthe user logged in the machine and, finally, the name of the victim machine.\n\nIGURE 6. GET INFORMATION OF THE USER AND MACHINE AND JOIN ALL\nSTRINGS\n\n_FIGURE 6. GET INFORMATION OF THE USER AND MACHINE AND JOIN ALL STRINGS_\n\nIn the screenshot some values were modified to protect my virtual machine. After getting\nthis information and preparing the string, the malware makes a custom hash with each.\n\nFor this, the malware will reserve some memory with “VirtualAlloc” and get the size of the\nstring and compute the hash in a very small loop. After this it will format the hash with the\nfunction “wsprintfW” to have it as a Unicode string.\n\nFIGURE 7. MAKE THE CUSTOM HASH AND FORMAT AS UNICODE STRING\n\n_FIGURE 7. MAKE THE CUSTOM HASH AND FORMAT AS UNICODE STRING_\n\nThe hashes are made in the following order:\n\nMachine name (g. 0xf843256f*)\nName of the user logged into the machine (e.g. 0x56ef3218*)\nGUID of the infected machine (e.g. 0x78ef216f*)\nName of the operating system (e.g. 0x91fffe45*)\nFinally, the full string with all strings joined (e.g. 0xe35d68fe*)\n\n*The above values have been changed to protect my machine.\n\nAfter this it will use the function “wsprintfW”, with the template string “%s-%s-%s-%s-%s”, to\nformat the custom hashes together with hyphens between them, but in this case the hashes\nare in this order:\n\nGUID\n\n\n-----\n\nOperating System Name\nName of the logged in user\nName of the infected machine\nFull string with all other strings joined together\n\nFIGURE 8. CREATE CUSTOM HASH OF THE STRINGS AND FORMAT THE FINAL\nSTRING IN A SPECIAL ORDER<\n\n_FIGURE 8. CREATE CUSTOM HASH OF THE STRINGS AND FORMAT THE FINAL_\n_STRING IN A SPECIAL ORDER_\n\nThe malware will get the command line of this launch process and will check if it has more\nthan one argument (the first argument is always in C/C++) with the functions\n“GetCommandLineW”, to get the full command line with arguments if it exists, and\n“CommandLineToArgvW” to get the arguments if they exist.\n\nIf there is more than one argument the malware will avoid the next procedure. To keep the\nnormal flow in the technical details section we will put what happens if only one argument\nexists. In this case the malware will try to make a Windows Event with the name of the\nformatted string with all hashes, as explained earlier (in our example case above, 78ef216f91fffe45-56ef3218-f843256f-e35d68fe).\n\nAfter trying to create the event the malware will check the last error with the function\n“GetLastError” and compare with ERROR_ALREADY_EXISTS (0xB7). If the event already\nexists the malware will check a counter with the value at 0x8000 (32768) and, if is not this\nvalue, it will increase the counter by one and try again to make the event, check the last\nerror, and so on, until it can finally make the event, reach the counter value, or it reaches\nthe maximum value in the counter (64233). If the event cannot be created the malware will\nget the pseudohandle to its own process with the function “GetCurrentProcess” and\nterminate it with the function “TerminateProcess” with the exit code 0x29A.\n\nFIGURE 9. CREATE EVENT LOOP AFTER CHECKING THERE IS ONLY ONE\nARGUMENT IN THE COMMAND LINE\n\n_FIGURE 9. CREATE EVENT LOOP AFTER CHECKING THERE IS ONLY ONE_\n_ARGUMENT IN THE COMMAND LINE_\n\nThis is done for several reasons:\n\nThe event is created to avoid relaunching another instance of the malware at the\nsame time.\nThe check of the counter is made if another instance of the malware is launched, to\nwait for the previous one to finish before continuing the process (this avoids some\nissues with the malware checking for crypted files).\n\n\n-----\n\nThe check of the argument, as we will explain later, can be used to avoid the event\nbehavior so the malware will always try to encrypt files. It is one of the reasons why a\nvaccine against this malware is useless if the malware operator executes the malware\nwith an argument as simple as “1”.\n\nAfter this, the malware will try to access in raw mode all units connected to the victim\nmachine in a physical way, preparing the string “\\\\.\\PHYSICALDRIVE%d”. This string will be\nformatted with the function “wsprintfW”, starting with the first unit that is 0 to a maximum of\n16 in a loop. After the format, the malware will use “CreateFileW” and check that it does not\nreturn the error “ERROR_INVALID_HANDLE” (that means the unit cannot be accessed or\nthat it does not exist). If this error is returned it will increase the counter and format the\nstring with the new value of the counter. If it can open the handle to the unit in raw mode it\nwill send two commands using the function “DeviceIoControl”.\n\nThe commands are:\n\n0x7C0F4 -> IOCTL_DISK_SET_DISK_ATTRIBUTES with the attributes of:\nDISK_ATTRIBUTE_READ_ONLY and DISK_ATTRIBUTE_OFFLINE.\n0x70140 -> IOCTL_DISK_UPDATE_PROPERTIES that will be make the drive update\nits partition table. As the attributes are updated the malware can be accessed in\nsharing mode on the disk.\n\nFIGURE 10. CONTROL THE PHYSICAL DISK TO HAVE ACCESS TO IT\n\n_FIGURE 10. CONTROL THE PHYSICAL DISK TO HAVE ACCESS TO IT_\n\nThe ransomware’s next action is checking the units that exist and can be accessed without\nany problem. This can be done in two ways, the first of which is using the functions\n“FindFirstVolumeA”, “FindNextVolumeA” and “FindVolumeClose”.\n\nFIGURE 11. GET VOLUME LETTER AND INFORMATION TO CHECK IT EXISTS AND\nCAN BE ACCESSED\n\n_FIGURE 11. GET VOLUME LETTER AND INFORMATION TO CHECK IT EXISTS AND_\n_CAN BE ACCESSED_\n\nThe first two functions return the volume and the special internal value associated with it.\nThis information comes from Windows, so the malware needs to translate it to the logic unit\nletter associated to this volume. This is done with the function\n“GetVolumePathNamesForVolumeNameA” that will return the logic letter associated to the\nvolume inspected.\n\nWith this letter the function “GetVolumeInformationA” is then used to get information of the\nvolume if it exists and is enabled. If the volume does not exist or cannot be checked the\nfunction will fail and the volume ignored, and the process will move onto the next volume in\n\n\n-----\n\nthe machine.\n\nAnother check is made using the function “GetLogicalDrives” that will return a structure and,\nby checking one byte, the malware will know if the unit exists or not.\n\nAfter this, the malware will prepare the keys that later will be needed to encrypt the files. To\nmake them it will get the crypto context with the function “CryptAquireContextW” that will\ngenerate random data with “CryptGenRandom” and prepare to permutate this value with\nthe SHA-512 algorithm. These values are the key and nonce of the Salsa20 algorithm that\nwill be used later to encrypt files.\n\nFIGURE 12. AQUIRE CRYPTO CONTEXT AND GENERATE SOME DATA AND\nPREPARE WITH SHA-512D\n\n_FIGURE 12. AQUIRE CRYPTO CONTEXT AND GENERATE SOME DATA AND PREPARE_\n_WITH SHA-512_\n\nThe malware continues decrypting some strings using two steps, one in a big function for\nthe first layer and the other that is used later for the second layer and the final string of the\nservice. The services stopped are:\n\nvss\n\nsql\n\nmemtas -> associated with MailEnable\n\nmepocs -> associated with MailEnable\n\nSophos -> associated with Sophos Antivirus\n\nVeeam -> associated with a program to make backups and save in the cloud\n\nBackup -> associated with Asus WebStorage\n\nPulseway -> associated with remote control software for IT departments\n\nLogme -> associated with remote control software\n\nLogmein -> associated with a remote control software\n\nConectwise -> associated with a remote control software\n\nSplastop -> associated with a remote control software\n\nMysql -> associated with a program of databases\n\nDfs -> associated with the Distribute File System (Microsoft)\n\n\n-----\n\nPlease note: The services list can change between samples.\n\nAfter decrypting the strings, the malware accesses the SCManager with the function\n“OpenSCManagerA”. If it does not want access it will ignore all services and continue onto\nthe next step.\n\nIf it can open a handle to it, it will get the status of the service with the function\n“EnumServicesStatusA” and if the service is stopped already will pass to the next one. The\nmalware calls this function two times, firstly to get the correct size needed for this function,\nwith the last error being checked with ¨GetLastError¨ against the value 0xEA\n(ERROR_MORE_DATA) (that means that the application needs more memory to fill all\ninformation than the function gives).\n\nFIGURE 13. OPEN THE SERVICE MANAGER AND ENUMSERVICESTATUSD\n\n_FIGURE 13. OPEN THE SERVICE MANAGER AND ENUMSERVICESTATUS_\n\nThis memory is reserved and the function called again later, in this case to get the real\nstatus and, if not stopped, the malware will open the service with the function\n“OpenServiceA” and query the status of the service with the function\n“QueryServiceStatusEx”. If the service is not stopped, it will get all dependencies of the\nservice with “EnumDependentServicesA” and finally it will control the service to stop it with\nthe function “ControlService”.\n\nFIGURE 14. OPEN THE SERVICES AND CONTROL THEM\n\n_FIGURE 14. OPEN THE SERVICES AND CONTROL THEM_\n\nAfter this, the malware decrypts a list of the processes that it will try terminating if it finds\nthem in the infected machine. For this decryption, the malware uses a string that converts\ninto an integer and uses this integer as a critical value to decrypt the list.\n\nFor this task, the malware will create a snapshot of all processes in the system per this\nblacklist:\n\n**sql**\n\n**mysql**\n\n**veeam**\n\n**oracle**\n\n**ocssd**\n\n**dbsnmp**\n\n\n-----\n\n**synctime**\n\n**agntsvc**\n\n**isqlpussvc**\n\n**xfssvccon**\n\n**mydesktopqos**\n\n**ocomm**\n\n**dbeng50**\n\n**sqbcoreservice**\n\n**excel**\n\n**infopath**\n\n**msaccess**\n\n**mspub**\n\n**onenote**\n\n**outlook**\n\n**powerpnt**\n\n**steam**\n\n**thebat**\n\n**thunderbird**\n\n**visio**\n\n**wordpad**\n\n**winword**\n\n**EduLink2SIMS**\n\n**bengine**\n\n**benetns**\n\n**beserver**\n\n**pvlsvr**\n\n\n-----\n\n**beremote**\n\n**VxLockdownServer**\n\n**postgres**\n\n**fdhost**\n\n**WSSADMIN**\n\n**wsstracing**\n\n**OWSTIMER**\n\n**dfssvc.exe**\n\n**swc_service.exe**\n\n**sophos**\n\n**SAVAdminService**\n\n**SavService.exe**\n\nPlease note: The processes list can change between samples.\n\nAfter making the snapshot it will enumerate all processes with the functions\n“Process32FirstW” and “Process32NextW” and for each process found will call the function\n“WideCharToMultyByte” to get the size needed to convert the name of the process returned\nin Unicode into Ascii. Later it reserves memory for the name and calls the same function to\nmake the string conversion.\n\nFIGURE 15. GET ALL SYSTEM PROCESSES\n\n_FIGURE 15. GET ALL SYSTEM PROCESSES_\n\nIf the malware, after comparison with the function “StrStrIA”, detects some of the blacklisted\nprocesses it will open the process with the function “OpenProcess” and terminate it with the\nfunction “TerminateProcess” and with the exit code of 0x29A.\n\nFIGURE 16. OPEN THE PROCESS AND TERMINATE IT IF IT IS BLACKLISTED\n\n_FIGURE 16. OPEN THE PROCESS AND TERMINATE IT IF IT IS BLACKLISTED_\n\nThe malware will check for all processes in the blacklist, using part of the string rather than\nthe exact name. Not using the extension allows for greater obfuscation but carries the risk\nthat some processes could be closed by accident if they share that string.\n\n\n-----\n\nAfter this the malware will check if the operating system is 64-bit or not with the function\n“GetNativeSystemInfo” against the value 9 (that means that the OS is 64-bit).\n\nIf the operating system is 64-bit it will get, using “LoadLibraryW” and “GetProcAddress”, the\nfunction “Woe64EnableWow64FsRedirection” to remove the redirection that by default is\nfound in 64-bit operating systems. This call is done in a dynamic way, but the malware does\nnot check that the function was retrieved with success; usually it will be, but it is not 100%\ncertain and a crash calling a null pointer could ensue.\n\nFIGURE 17. CHECK THE OPERATING SYSTEM AND DISABLE REDIRECTION IF\nNEEDED\n\n_FIGURE 17. CHECK THE OPERATING SYSTEM AND DISABLE REDIRECTION IF_\n_NEEDED_\n\nAfter this, the malware will prepare a string in Unicode embedded in the code with the string\n“wmic.exe shadowcopy delete” and will call it with the function “CreateProcessW”. After the\ncall it will wait for up to an infinite amount of time using the function “WaitForSingleObject”\nso that the “wmic.exe” process can finish, irrespective of the size and number of shadow\nvolumes, available machine resources, etc.\n\nOf course, the malware will also use the typical program of “vssadmin” to delete the shadow\nvolumes with the command “vssadmin delete shadows /all /quiet”, as well as with the\nfunction “CreateProcessW”. After that it will wait again with “WaitForSingleObject” for the\nend of the new process.\n\nWhen it finishes, the malware will check again if the operating system is 64-bit and, if it is,\nwill use “LoadLibraryW” and “GetProcAddress” to get the function\n“Wo64EnableWow64FsRedirection” to leave the system as before with the redirection.\nAgain, the malware does not check that the function is resolved with success and calls it\ndirectly in a dynamic way.\n\nFIGURE 18. DESTROY THE SHADOW VOLUMES AND RE-ENABLE THE\nREDIRECTION\n\n_FIGURE 18. DESTROY THE SHADOW VOLUMES AND RE-ENABLE THE REDIRECTION_\n\nWhile it seems like a mistake to destroy the shadow volumes again, it is not, as\nRagnarLocker has support for Windows XP and the WMIC classes do not exist in that\noperating system, hence the need to use the old program “vssadmin” that exists in both\nnew and old operating systems.\n\nThe malware continues with the decryption of one PEM block encoded in base64 and the\nransom note is prepared for the target in memory.\n\n\n-----\n\nAn example of the ransom note, with confidential information removed, can be seen below:\n\nFIGURE 19. DECRYPTION OF THE PEM BLOCK AND THE RANSOM NOTE\n\n_FIGURE 19. DECRYPTION OF THE PEM BLOCK AND THE RANSOM NOTE_\n\nAn example of the ransom note, with confidential information removed, can be seen below:\n\nFIGURE 20. EXAMPLE REDACTED RANSOM NOTE\n\n_FIGURE 20. EXAMPLE REDACTED RANSOM NOTE_\n\nAfter preparing both things the malware decodes the PEM block from the base64 as an\nobject, getting a key that will be used to protect the keys used in the crypto process (of\ncourse this procedure may change in future samples as the malware evolves) of the RSA\nalgorithm. It is important to note here that this RSA key changes per sample.\n\nFIGURE 21. DECODE FROM BASE64 AND DECODE THE OBJECT AND IMPORT IT\nTO USE LATER\n\n_FIGURE 21. DECODE FROM BASE64 AND DECODE THE OBJECT AND IMPORT IT TO_\n_USE LATER_\n\nWith this key it will encrypt the two random keys previously generated to protect them in\nmemory. After that, the crypto will release the memory.\n\nLater, it will get the name of the infected machine again, get the size of the name and will\ncalculate the custom hash with the same algorithm as before.\n\nFIGURE 22. CRYPT THE PREVIOUSLY GENERATED VALUES AND GET THE\nCOMPUTER NAME\n\n_FIGURE 22. CRYPT THE PREVIOUSLY GENERATED VALUES AND GET THE_\n_COMPUTER NAME_\n\nWith this hash it will prepare a string with this structure:\n\nRGNR_\nhash from the name of the victim machine\nthe extension .txt\na backslash character at the start of the string\n\nIt is done with the function “lstrcatW”.\n\nFIGURE 23. CREATION OF THE RANSOM NOTE NAME\n\n_FIGURE 23. CREATION OF THE RANSOM NOTE NAME_\n\n\n-----\n\nWith this string it will get the folder of My Documents for all users with the function\n“SHGetSpecialFolderPathW” (this function, based on the operating system, will get different\npaths for the documents). This string with the path of the folders will join with the string of\nthe ransom note name and later make the final path to create the file.\n\nFIGURE 24. GET THE DOCUMENTS FOLDER TO LATER WRITE THE RANSOM\nNOTE\n\n_FIGURE 24. GET THE DOCUMENTS FOLDER TO LATER WRITE THE RANSOM NOTE_\n\nAfter this it will encode in base64 the critical information to decrypt the files with the function\n“CryptBinaryToStringA”. The malware uses the function the first time to get the size needed\nand reserve memory and then uses it again to encode the data. After encoding the data, it\ncreates the ransom note file in the documents path with the string previously joined with the\npath with the function “CreateFileW” and will write the contents of the ransom note that has\nbeen prepared in memory. Later, it will format a special string with some hardcoded\ncharacters with “—RAGNAR SECRET—” as a start of block and end of block and, between,\nwill format the encode string in base64 and write in the ransom note.\n\nFIGURE 25. CREATION OF THE RANSOM NOTE AND PUT THE RAGNAR SECRET\nAT THE END OF IT\n\n_FIGURE 25. CREATION OF THE RANSOM NOTE AND PUT THE RAGNAR SECRET AT_\n_THE END OF IT_\n\nLater, the malware will create a new string with the strings:\n\n.ragnar_\nhash of the name of the victim machine\n\nThis string will be used later as the new extension in the crypted files. After this the malware\nwill enumerate again the logic units of the system with the function “GetLogicalDrivesW”\nand, to check if the unit is correct, will use the function “GetVolumeInformationW” and check\nthe type of the unit and avoid the type of CD-ROM. For each logic unit it will enumerate all\nfiles and folders and will start the crypto process.\n\nFIGURE 26. GET ALL LOGIC UNITS AND CHECK THEM\n\n_FIGURE 26. GET ALL LOGIC UNITS AND CHECK THEM_\n\nBefore starting the crypto process, the malware will try to write the ransom note in the root\nof each unit that is found as a target.\n\nThe malware will ignore folders with these names:\n\n\n-----\n\nWindows\n\nWindows.old\n\nInternet Explorer\n\nGoogle\n\nOpera\n\nOpera Software\n\nMozilla\n\nMozilla Firefox\n\n$Recycle.Bin\n\nProgramData\n\nAll Users\n\nThe ransom note will be written in all folders that are affected and, as with other\nransomware, it will use the functions “FindFirstFileW” and “FindNextFileW” to enumerate all\ncontents in each folder.\n\nFIGURE 27. CHECK OF THE BLACKLISTED FOLDER NAMES\n\n_FIGURE 27. CHECK OF THE BLACKLISTED FOLDER NAMES_\n\nRagnarLocker also avoids crypting certain files:\n\nautorun.inf\n\nboot.ini\n\nbootfont.bin\n\nbootsect.bak\n\nbootmgr\n\nbotmgr.efi\n\nbootmgfw.efi\n\ndesktop.ini\n\niconcache.db\n\n\n-----\n\nntldr\n\nntuser.dat\n\nntuser.dat.log\n\nntuser.ini\n\nthumbs.db\n\nRGNR_<hash>.txt\n\nFIGURE 28. CHECK OF BLACKLISTED FILE NAMES\n\n_FIGURE 28. CHECK OF BLACKLISTED FILE NAMES_\n\nIf a file has one of these names it will be ignored and, if it has another name, the malware\nwill avoid any file that has these extensions:\n\n.db\n\n.sys\n\n.dll\n\n.lnk\n\n.msi\n\n.drv\n\n.exe\n\nFIGURE 29. CHECK OF BLACKLISTED EXTENSIONS\n\n_FIGURE 29. CHECK OF BLACKLISTED EXTENSIONS_\n\nThese checks are in place to prevent the ransomware from destroying the operating system\nas the victim needs to have access to the machine to pay the ransom.\n\nFor each file that passes all controls a thread will be created that will encrypt it. After\ncreating all threads, the malware will wait for up to an infinite amount of time with the\nfunction “WaitForMultipleObjects”.\n\nIn the crypto process, in the threads, the malware will check if the file has the mark\n“_RAGNAR_” at the end with the function “SetFilePointerEx” and by reading 9 bytes and\nchecking if they are this string. If it has this mark the file will be ignored in the crypto\n\n\n-----\n\nprocess and will be renamed again (with an extension name based on the current machine\nname).\n\nFIGURE 30. CHECK OF THE MARK OF CRYPTO IN THE FILE\n\n_FIGURE 30. CHECK OF THE MARK OF CRYPTO IN THE FILE_\n\nIn other cases the malware will encrypt the file and at the end of it will write the block\ncrypted of the key, used in a block of 256 bytes, and the nonce used in another block of 256\nbytes and, finally, the mark “_RAGNAR_”, along with one byte as NULL to end the string\n(that makes 9 bytes). The key and nonce used in the Salsa20 algorithm are encrypted by\nthe RSA public key embedded in the malware. This ensures only the malware developers\ncan have the RSA private key that belongs to the public key used to decrypt the key and\nnonce and, thus, decrypt the files in the system.\n\nBefore writing this information, the malware will use the function “LockFile” and, when the\nprocess of writing the function is finished, “UnlockFile” to release the file already crypted.\nThis is done to prevent the file being changed or deleted during the encryption process.\n\nFIGURE 31. WRITE THE NEW CONTENTS AT THE END OF THE FILE\n\n_FIGURE 31. WRITE THE NEW CONTENTS AT THE END OF THE FILE_\n\nFIGURE 32. CHANGE OF THE EXTENSION OF THE CRYPTED FILE\n\n_FIGURE 32. CHANGE OF THE EXTENSION OF THE CRYPTED FILE_\n\nAfter all threads of crypto, the malware tries to get the session of the Terminal Services or\nthe session of the user logged in the local machine with the function\n“WTSGetActiveConsoleSessionId”. With this session it gets the current process of the\nmalware with the function “GetCurrentProcess” and the token of this process with the\nfunction “OpenProcessToken”. With the session that was got previously it tries to duplicate\nthe token with the function “DuplicateTokenEx” and sets this token with the function\n“SetTokenInformation”. After this it will get the system directory with the function\n“GetSystemDirectoryW” and joins to this path the string “\\notepad.exe”.\n\nFIGURE 33. GET THE SESSION OF THE LOCAL USER OR TERMINAL SERVICES\nAND MANAGE THE TOKENS\n\n_FIGURE 33. GET THE SESSION OF THE LOCAL USER OR TERMINAL SERVICES AND_\n_MANAGE THE TOKENS_\n\nWith this prepared, the malware executes Notepad and, as an argument, the ransom note\nto show to the user what happened in the machine. The function used in this case is\n“CreateProcessAsUserW” to impersonate the user that had the session previously. Of\ncourse, this function is called with the desktop as “WinSta0\\Default”.\n\n\n-----\n\nFIGURE 34. CREATE A PROCESS OF THE NOTEPAD TO SHOW THE RANSOM\nNOTE\n\n_FIGURE 34. CREATE A PROCESS OF THE NOTEPAD TO SHOW THE RANSOM NOTE_\n\nAfter this the malware finishes itself with the function “ExitProcess” and a code of exit of 0.\n\n## VACCINE\n\nRagnarLocker can have a vaccine if a program is made that can make the event, as\nexplained in the technical part of this blog. If this event exists, the malware does not make\nanything in the system, but this type of vaccine is not likely to offer a long-term solution for\nseveral reasons:\n\nThe way that the event is done, the malware developers can change the algorithm, or\nthe order of the name of the event, or make a mutex instead of an event and the\nvaccine will stop working.\nThe algorithm has a hardcoded value. If this value is changed the final hash will be\ndifferent and the vaccine becomes useless.\nThe malware is developed in such a way that if it has at least two arguments the event\nis not created so, if the operators want to execute with safety, they need only to\nexecute with an argument, for example “<malware.exe> 1”.\nThe malware may evolve over time so the vaccine can be very fragile and limited.\n\nFor these reasons we think that a vaccine using this system is not helpful in the longerterm.\n\n## CONCLUSION\n\nRagnarLocker is a simple ransomware, much like others that exist in the criminal market.\nDue to its small size, its operator’s aggressive behavior and the knowledge they seem to\nhave that allows them to enter the networks of enterprises, as well as the threat to leak\ninformation if the ransom is not paid, RagnarLocker could potentially become a big threat in\nthe future. Time will tell if RagnarLocker becomes a serious threat or disappears against a\nbackdrop of other ransomware with more resources. The code is medium in quality.\n\n## COVERAGE\n\nMcAfee can protect against this threat in all its products, including personal antivirus,\nendpoint and gateway.\n\nThe names that it can have are:\n\nRansom-ragnar\n\n\n-----\n\nAlso, learn how Enhanced Remediation, a new capability in ENS 10.7, can automatically\n[rollback changes made by processes that exhibit malicious behavior.](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/ens-10-7-rolls-back-the-curtain-on-ransomware/)\n\n## MITRE ATT&CK COVERAGE\n\nCommand and Control : Standard Application Layer Protocol\nDefense Evasion : Disabling Security Tools\nDiscovery : Security Software Discovery\nDiscovery : Software Discovery\nDiscovery : System Information Discovery\nDiscovery : System Service Discovery\nDiscovery : System Time Discovery\nDiscovery : Query registry\nExecution : Command-Line Interface\nExecution : Execution through API\nExfiltration : Data Encrypted\nImpact : Data Encrypted for Impact\nImpact : Service Stop\n\n## YARA RULES\n\n**rule RagnarLocker**\n**{**\n\n**/***\n\n**This YARA rule detects the ransomware RagnarLocker in memory or unpacked in**\n**disk for the sample with hash SHA1 97f45184770693a91054075f8a45290d4d1fc06f**\n**and perhaps other samples**\n\n***/**\n\n**meta:**\n\n**author = “McAfee ATR Team”**\n\n**description = “Rule to detect unpacked sample of RagnarLocker”**\n\n**version = “1.0”**\n\n**strings:**\n\n**$a = { 42 81 F1 3C FF 01 AB 03 F1 8B C6 C1 C0 0D 2B F0 3B D7 }**\n\n**condition:**\n\n**$a**\n\n\n-----\n\n**}**\n\n**import “pe”**\n\n**rule ragnarlocker_ransomware**\n\n**{**\n\n**meta:**\n\n**description = “Rule to detect RagnarLocker samples”**\n\n**author = “Christiaan Beek | Marc Rivero | McAfee ATR Team”**\n\n**reference = “https://www.bleepingcomputer.com/news/security/ragnar-locker-**\n**ransomware-targets-msp-enterprise-support-tools/”**\n\n**date = “2020-04-15”**\n\n**hash1 =**\n**“63096f288f49b25d50f4aea52dc1fc00871b3927fa2a81fa0b0d752b261a3059”**\n\n**hash2 =**\n**“9bdd7f965d1c67396afb0a84c78b4d12118ff377db7efdca4a1340933120f376”**\n\n**hash3 =**\n**“ec35c76ad2c8192f09c02eca1f263b406163470ca8438d054db7adcf5bfc0597”**\n\n**hash4 =**\n**“9706a97ffa43a0258571def8912dc2b8bf1ee207676052ad1b9c16ca9953fc2c”**\n\n**strings:**\n\n**//—RAGNAR SECRET—**\n\n**$s1 = {2D 2D 2D 52 41 47 4E 41 52 20 53 45 43 52 45 54 2D 2D 2D}**\n\n**$s2 = { 66 ?? ?? ?? ?? ?? ?? 66 ?? ?? ?? B8 ?? ?? ?? ?? 0F 44 }**\n\n**$s3 = { 5? 8B ?? 5? 5? 8B ?? ?? 8B ?? 85 ?? 0F 84 }**\n\n**$s4 = { FF 1? ?? ?? ?? ?? 3D ?? ?? ?? ?? 0F 85 }**\n\n**$s5 = { 8D ?? ?? ?? ?? ?? 5? FF 7? ?? E8 ?? ?? ?? ?? 85 ?? 0F 85 }**\n\n**$op1 = { 0f 11 85 70 ff ff ff 8b b5 74 ff ff ff 0f 10 41 }**\n\n**$p0 = { 72 eb fe ff 55 8b ec 81 ec 00 01 00 00 53 56 57 }**\n\n**$p1 = { 60 be 00 00 41 00 8d be 00 10 ff ff 57 eb 0b 90 }**\n\n**$bp0 = { e8 b7 d2 ff ff ff b6 84 }**\n\n**$bp1 = { c7 85 7c ff ff ff 24 d2 00 00 8b 8d 7c ff ff ff }**\n\n\n-----\n\n**$bp2 = { 8d 85 7c ff ff ff 89 85 64 ff ff ff 8d 4d 84 89 }**\n\n**condition:**\n\n**uint16(0) == 0x5a4d and**\n\n**filesize < 100KB and**\n\n**(4 of ($s*) and $op1) or**\n\n**all of ($p*) and pe.imphash() == “9f611945f0fe0109fe728f39aad47024” or**\n\n**all of ($bp*) and pe.imphash() == “489a2424d7a14a26bfcfb006de3cd226”**\n\n**}**\n\n## IOCs\n\nSHA256 7af61ce420051640c50b0e73e718dd8c55dddfcb58917a3bead9d3ece2f3e929\n\nSHA256 c2bd70495630ed8279de0713a010e5e55f3da29323b59ef71401b12942ba52f6\n\nSHA256 dd5d4cf9422b6e4514d49a3ec542cffb682be8a24079010cda689afbb44ac0f4\n\nSHA256 63096f288f49b25d50f4aea52dc1fc00871b3927fa2a81fa0b0d752b261a3059\n\nSHA256 b670441066ff868d06c682e5167b9dbc85b5323f3acfbbc044cabc0e5a594186\n\nSHA256 68eb2d2d7866775d6bf106a914281491d23769a9eda88fc078328150b8432bb3\n\nSHA256 1bf68d3d1b89e4f225c947442dc71a4793a3100465c95ae85ce6f7d987100ee1\n\nSHA256 30dcc7a8ae98e52ee5547379048ca1fc90925e09a2a81c055021ba225c1d064c\n\n## USING MVISION EDR TO DETECT RAGNARLOCKER\n\nWith thanks to [Mo Cashman and](https://www.mcafee.com/blogs/author/mo-cashman/) [Filippo Sitzia](https://www.mcafee.com/blogs/author/filippo-sitzia/)\n\nWe downloaded a RagnarLocker sample from Virus Total to test detection capability by\nMVISION Endpoint Detection and Response (EDR). We tested first with the original sample\nwhich was known to most detection engines by this time. We then changed file hashes to\ntest detection with an unknown sample. In both cases, MVISION EDR identified the\nsuspicious behaviors and raised alerts. The original sample was detected as a HIGH Risk\nbecause the file had a known malicious reputation in McAfee Global Threat Intelligence\nwhich is integrated with MVISION EDR. The unknown samples were detected as Medium\nRisk and most likely would have triggered further inspection by a security analyst.\n\n**Sample VT submission**\n\n\n-----\n\n2020-05-30 13:30:55, File size: 48.50 KB, File type Win32 EXE, File name: omniga.exe, VT\ndetections: 51/73\n\n**Test Environment**\n\nOS Win10, ENS 10.7 Threat Protection off, Adaptive Threat Protection off, MVISION EDR\n\n**Execution with original HASH –**\n**3bc8ce79ee7043c9ad70698e3fc2013806244dc5112c8c8d465e96757b57b1e1**\n\n**To further test MVISION EDR effectiveness, we modified the hash file slightly:**\n\n**Execution with HASH changed –**\n**63F5B6ED99C559341CF1AD081BAF55B4EACAD8E46D056764531BD316BF3C3EE3**\n\n**Alerting Results for both samples**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-09 - RagnarLocker Ransomware Threatens to Release Confidential Information.pdf"
    ],
    "report_names": [
        "2020-06-09 - RagnarLocker Ransomware Threatens to Release Confidential Information.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536098,
    "ts_updated_at": 1743041145,
    "ts_creation_date": 1653754638,
    "ts_modification_date": 1653754638,
    "files": {
        "pdf": "https://archive.orkl.eu/6e4a0e19ff75538c0eb09cab927f119105adf86b.pdf",
        "text": "https://archive.orkl.eu/6e4a0e19ff75538c0eb09cab927f119105adf86b.txt",
        "img": "https://archive.orkl.eu/6e4a0e19ff75538c0eb09cab927f119105adf86b.jpg"
    }
}