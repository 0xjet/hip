{
    "id": "39c5fdca-b892-4146-9c42-825b157b1a3a",
    "created_at": "2023-01-12T15:01:57.528961Z",
    "updated_at": "2025-03-27T02:09:55.037765Z",
    "deleted_at": null,
    "sha1_hash": "fb0b07faa64bb2653eaf441ae2536506d4932e5e",
    "title": "2020-12-19 - [RE018-1] Analyzing new malware of China Panda hacker group used to attack supply chain against Vietnam Government Certification Authority - Part 1",
    "authors": "",
    "file_creation_date": "2022-05-28T16:56:15Z",
    "file_modification_date": "2022-05-28T16:56:15Z",
    "file_size": 2743734,
    "plain_text": "# [RE018-1] Analyzing new malware of China Panda hacker group used to attack supply chain against Vietnam Government Certification Authority - Part 1\n\n**blog.vincss.net/2020/12/re018-1-analyzing-new-malware-of-china-panda-hacker-group-used-to-attack-supply-chain-**\nagainst-vietnam-government-certification-authority.html\n\n**I. Introduction**\n\nIn process of monitoring and analyzing malware samples, we discovered an interesting blog\npost of NTT [here. Following the sample hash in this report, we noticed a hash on VirusTotal:](https://insight-jp.nttsecurity.com/post/102glv5/pandas-new-arsenal-part-3-smanager)\n\n_Figure 1. Hash’s information in the NTT blog_\n\nOn the event that a hacker group believed to be from Russia attacked and exploited the\nsoftware supply chain to target a series of major US agencies, along with discovery that the\nkeyword eToken.exe belongs to the software that is quite popularly used in agencies,\norganizations and businesses in Vietnam, we have used eToken.exe and SafeNet as\nkeywords for searching on VirusTotal and Google. As a result, we uncovered information\n[about two remarkable installation files (1,](https://www.virustotal.com/gui/file/6be34df727fcb79123e4e8f472ad24b698d83395fb17d4db019e9976f485cd83/detection) [2) that have been uploaded to VirusTotal since](https://www.virustotal.com/gui/file/b0fd1ff7f5d45be89fffc04937f352754c6055e1f4ca26a9257169ce168569ef/detection)\n**August 2020:**\n\n\n-----\n\n_Figure 2. Information look up on VirusTotal_\n\nThe name of the installation files are quite familiar: gca01-client-v2-x32-8.3.msi and gca01**client-v2-x64-8.3.msi, We have tried to download these two files from the website and they**\nhave the same hash value. However, at the present time, all files on the VGCA homepage\nhave been removed and replaced with the official clean version. According to the initial\nassessment, we consider this could be an attack campaign aimed at the software supply\nchain that can be leveraged to target important agencies, organizations and businesses in\nVietnam.\n\nOn December 17, ESET announced a discovery of an attack on APT they called \"Operationth\nSignSight\" against the Vietnam Government Certification Authority (VGCA). In that report,\nESET said they have also notified VNCERT and VGCA and VGCA has confirmed that they\nwere aware of the attack before and notified the users who downloaded the trojanized\nsoftware.\n\nAt the time of analysis, we have obtained two setup files that have been tampered by\nhackers. This blog post series will focus on analyzing the signatures and techniques that\nhackers have applied to malicious samples in these two installation files.\n\n\n-----\n\n**II. Analyze installation file**\n\nThis application is named as \"SafeNet Authentication Clients\" from SafeNet .Inc company.\nPortable Executable (PE) files are mostly signed with SafeNet certificates.\n\n_Figure 3. PE files signed with SafeNet certificate_\n\nBy using UniExtract tool, we extracted the entire file from an installer (x64 setup file). The\ntotal number of files is 218 files, 68 subfolders, the total size is 75.1 MB (78,778,368 bytes).\nTo find out which file has been implanted by hackers, we only focus on analyzing and\nidentifying unsigned PE files.\n\nWith the help of sigcheck tool in Micorsoft's SysInternals Suite, with the test parameters is\nsigned, hash, scan all PE files, scan the hash on VirusTotal, the output is csv file. Then\nsorting by unsigned file, resulting from VirusTotal, we discovered that eToken.exe is the file\nwas implanted by the hacker.\n\n_Figure 4. Discovered file was implanted by hacker_\n\nThe hash of this eToken.exe matches with the one in NTTSecurity's report. Another strange\npoint is that it’s a 32bit PE but located in the x64 directory, the version information such as\n“Company, Description, Product…” are not valid for such a large company application. Here\n[is the scan result of the eToken file on VirusTotal.](https://www.virustotal.com/gui/file/97a5fe1d2174e9d34cee8c1d6751bf01f99d8f40b1ae0bce205b8f2f0483225c/detection)\n\nSince this application is built with Visual C ++ of Visual Studio 2005 which is old version, and\nuses the Qt4 library, some of the dll files of this installer are also unsigned. We checked each\nfile and determined that the files were clean, leaving only three suspicious files:\n**RegistereToken.exe, eTOKCSP.dll and eTOKCSP64.dll.**\n\n\n-----\n\nSo eToken.exe file is a malware that hackers have added to the installation of the software\nsuite. To find out how eToken.exe is executed, we analyze the installation file: msi file\n(Microsoft Windows Installer file): gca01-client-v2-x64-8.3.msi\n\nExtracting the msi file to raw format before installing, we obtained two .cab files (Microsoft\n_Cabinet file): Data1.cab and Cabs.w1.cab. This is anomaly because a normal msi file has_\nonly one main .cab file. Check the Data1.cab file and the MSI log text file, eToken.exe and\n**RegistereToken.exe are in Data1.cab file. And both .exe files have no GUID ID info:**\n\n_Figure 5. Exe files do not have a GUID ID info_\n\nContinue checking the features: DriverFeature, and two files eToken.exe and\n**RegistereToken.exe msi file with Microsoft's Orca tool (a specialized tool for analyze and**\n_modify msi files). Through a search, the hacker has added a custom action: RegisterToken_\n(without \"e\" before Token) to the msi file and added that CustomAction at the end of\n**InstallExecuteSequence. RegistereToken.exe will be called with the parameter is**\n**eToken.exe:**\n\n_Figure 6. Hacker implanted a custom action_\n\nAnalyzing the RegistereToken.exe file, we see that this file was built on \"Wednesday,\n**22.07.2020 07:40:31 UTC\", ie 07/22/2020, 2h40m31s PM GMT +7, PE64, using VC ++**\n**2013:**\n\n\n-----\n\n_Figure 7. Information of the RegistereToken.exe file_\n\n**RegistereToken.exe's pseudo code only calls the WinExec API to execute the passed in**\nargument:\n\n_Figure 8. Tasks of RegistereToken.exe_\n\nWith all the information above and based on the timestamp in the Data1.cab and\n**RegistereToken.exe files, we can conclude:**\n\nHacker has created and modified the .msi file and created the Data1.cab file at\ntimestamp: 07/20/2020 - 15:15 UTC time, added the eToken.exe file at this time.\nBuild RegistereToken.exe file at timestamp: 22/07/2020 - 07:40 UTC\nAdd RegistereToken.exe file to Data1.cab at timestamp: 22/07/2020 - 08:40 UTC\n\nNote: According to Cab file format, the two Date and Time fields of a file in the cab file are\n**DOS Datetime format, each of which is a Word 2 bytes which reflect the time when the file**\nwas added according to DOS time. Cab file processing programs will convert and display in\nUTC time. That is, the above UTC times are the current time on the hacker machine. See\nmore [here.](https://docs.microsoft.com/en-us/windows/win32/sysinfo/ms-dos-date-and-time)\n\n\n-----\n\n_Figure 9. MS DOS Datetime Information_\n\n**III. Analyze eToken.exe**\n\n**1. Analyze PE Structure**\n\nFile eToken.exe:\n\nSize: 192 KB (196,608 bytes)\nMD5: 830DD354A31EF40856978616F35BD6B7\nSHA256:\n97A5FE1D2174E9D34CEE8C1D6751BF01F99D8F40B1AE0BCE205B8F2F0483225C\n\nInformation about compiler, RichID and build timestamp:\n\nBuild with VC ++ 6 of Microsoft Visual Studio, Service Pack 6.\nBuild at: 26/04/2020 - 15:12:58 UTC\nChecksum is correct, file has not been modified PE Header.\nLinking with MFC42.dll library, Microsoft Foundation Class v4.2 library of Microsoft, is a\nlibrary supporting GUI programming on Windows, always included in Visual Studio\nsuite.\nLink with a special library: dbghelp.dll. Use the MakeSureDirectoryPathExist API\nfunction. See more [here.](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-makesuredirectorypathexists)\n\nChecking the resource section of the file, we determined that this is a Dialog application,\ncreated by MFC Wizard of Visual Studio 6. The project name is VVSup, which means the\n**.exe file when built out would be VVSup.exe.**\n\n\n-----\n\n_Figure 10. File's resource information_\n\n**2. Static code analysis**\n\n**eToken.exe (VVSup.exe) is built with dynamic link DLL mode with MFC42.dll, so the .exe**\nfile will be small and the functions of the MFC42 libirary will be easily identified via the name\nimport of the DLL. The name mangling rule of Microsoft VC ++ compiler reflects the class\nname, function name, parameter name, call type... of functions. IDA helps us to define the\nfunctions import by ordinal of MFC42.dll using the file mfc42.ids and mfc42.idt included\nwith IDA.\n\nHowever, VVSup is built with the RTTI (Runtime Type Information) option is disabled, so\nthere is no information about the RTTI and Virtual Method Table of all classes in the file. We\nonly have RTTI of class type_info, the root class of RTTI.\n\n\n-----\n\n_Figure 11. RTTI Info of type_info class_\n\nThe analysis will show how to define classes, recreate the code of this malware, and share\nexperience in applying when analyzing malwares/files using MFC.\n\nPlugins used:\n\nSimabus’s ClassInformer\nMatrosov’s HexRaysCodeXplorer\n**MFC_Helper**\n\nThe MFC C++ source code can be found in the src\\mfc directory of the Visual Studio\ninstaller. Since MFC4.2 (MFC of VS6) is very old, it can be found on Github. We refer [here.](https://github.com/dblock/msiext/tree/master/externals/WinDDK/7600.16385.1/inc/mfc42)\n[About the relationship chart of the classes of MFC (Hierarchy Chart), you can see at this link.](https://docs.microsoft.com/en-us/cpp/mfc/hierarchy-chart?view=msvc-160)\n\nThree important dlls file to diffing/compare with MFC malware, for example in this sample\n**eToken, are mfc42.dll, mfc42d.dll, mfco42d.dll. You can find and download the correct**\ndebug symbol file (.pdb) of the dlls you have. The most important one is mfc42d.dll (debug\n_build), since its .pdb will contain full information about the types, enumes, classes, and_\nvtables of the MFC classes. We export local types from mfc42d.dll to .h file, then import into\nour idb database. IDA's Parse C ++ has an error, unable to parse the \"<>\" template syntax,\nso we find and replace pairs of \"<\" and \">\" to \"_\" in .h files.\n\nParallel opening mfc42d.dll in new IDA together with IDA is parsing malware, copy names,\ntypes of classes, functions from mfc42d.dll. As mentioned, this malware is an MFC Dialog\napplication, so we will definitely have the following classes in the malware: CObject,\n**CCmdTarget, CWinThread, CWnd, CDialog. According to the MFC Wizard's auto-naming**\nrule, we have classes with the following names: CVVSupApp (inherited from CWinApp),\n**CAboutDlg (dialog About, resID = 100), CVVSupDlg (main dialog, resID = 102).**\n\nScan results of vtables, classes of two plugins ClassInformer and HexRaysCodeXplorer.\n\n\n-----\n\n_Figure 12. Scanning vtables, classes result_\n\nUse MFC_Helper scan CRuntimeClass, as expected, CVVSupDlg has CRuntimeClass\nand add another class: CVVSupDlgAutoProxy. It shows that the hacker when running the\nMFC Wizard, clicked to select support OLE Control.\n\n_Figure 13. Detect classe after run MFC_Helper_\n\nBased on the import function CWinApp::GetRuntimeClass, we can determine CVVSupApp\nvtable, and based on CDialog::GetRuntimeClass we can define two vtables of the other\ntwo dialogs. But which dialog is About, which dialog is a malware dialog? Identify all the\ninternal structures of MFX such as AFX_MSGMAP, AFX_DISPMAP,\n**AFX_INTERFACEMAP...**\n\nUsing the Xref to feature call the CDialog constructor: void __thiscall CDialog::CDialog\n**(CDialog *this, unsigned int nIDTemplate, CWnd *pParentWnd), nIDTemplate is the**\n**resID of the dialog, we define the vtable of CAboutDlg and CMalwareDlg. Because**\n**CMalwareDlg does not have CRuntimeClass and RTTI, so it is temporarily named like that.**\nThe hacker deleted the DECLARE_DYNAMIC_CREATE line of these two classes and the\n**CVVSupApp class when build.**\n\n\n-----\n\n_Figure 14. Identify vtable of CAboutDlg and CMalwareDlg_\n\nRelational Classes table of this malware:\n\n\n-----\n\n_Figure 15. Relational classes table of this malware_\n\nCopy the names of functions, types, function types, parameters ... from the respective parent\nclasses of the above classes, in the correct order in the vtable, identify the generated MFC\nWizard functions and the functions the hacker wrote.\n\n_Figure 16. Result after copy name of functions, types, function types, parameters_\n\nEvery MFC application has a global variable called theApp, belonging to the main class\n**CXXXApp inheriting from CWinApp. In the case of this malware are: CVVSupApp theApp;**\nThis global variable is initialized by C RTL in the start function, called before main/WinMain,\nin table __xc_a. The functions in this table call after the C RTL constructors in __xi_a. These\ntables are the parameters passed to the internal _initterm function of C RTL.\n\n\n-----\n\n_Figure 17. TheApp global variable in the MFC application_\n\nThe flowchart of creating and executing an MFC application is as follows:\n\n_Figure 18. Flowchart of creating and executing an MFC application_\n\nThe CVVSupApp :: InitInstance function is also a common code generated by MFC wizard\n\n\n-----\n\n_Figure 19. CVVSupApp::InitInstance function_\n\nConstructor of CVVSupDlg: void CVVSupDlg::CVVSupDlg() is also common code\ngenerated by MFC Wizard. But in CVVSupDlg::OnInitDialog, which is called from\n**CVVSupDlg::DoModal(), we can see immediately, at the end of the code that the MFC**\nWizard generated, CMalwareDlg is initialized and shown, then the malware exits forcibly\n**exit (0).**\n\n\n-----\n\n_Figure 20. CMalwareDlg was created and shown_\n\nThe value 129 is the resID of the CMalwareDlg dialog, and sizeof(CMalwareDlg) = 0x290,\nwhich is larger than the size of the parent CDialog. It proves that CMalwareDlg was added\nby hackers to some data members. Through analysis, we recreated the data members of\n**CMalwareDlg:**\n\n_Figure 21. Recreate data members of CMalwareDlg_\n\nThe CMalwareDlg::CMalwareDlg Constructor does the following initialization jobs. Note the\ncopy string \"192.168\" into the field m_szMask:\n\n\n-----\n\n_Figure 22. Copy \"192.168\" string to m_szMask field_\n\nWhen shown, CMalwareDlg::OnInitDialog will be called, and the main function that is\nimportant for doing the malware's task is called here:\n\n_Figure 23. The Infect main function will do the malware's job_\n\nThe Infect (we named) function is relatively long, so it should be presented via the flowchart\nbelow:\n\n\n-----\n\n_Figure 24. Infect function flowchart_\n\nWe'll go into detail each of the important child functions called by the Infect function of the\n**CMalwareDlg class. The UserIsAdmin function, using the IsUserAdmin() API of**\n**shell32.dll:**\n\n\n-----\n\n_Figure 25. UserIsAdmin fuction_\n\n**GetSomeAPIAddrs function is a redundant function, function pointers are taken but**\ncompletely unused. We guess this could be an old code.\n\n\n-----\n\n_Figure 26. GetSomeAPIAddrs function_\n\nThe Base64Decode function is like other Base64 decode functions, except that the Base64\ncode table is copied by the hacker to a char arrary m_szBase64Table and accessed from\nhere. After being decoded Base64, the original ServiceName\n\"TmV0QmlvcyBNZXNzYWdlciBSZWdpc3Rlcg==\" will be \"NetBios Messager Register\".\nThe original ServiceDescription\n\"TmV0QmlvcyBjb21tdW5pY2F0aW9uIGJldHdlZW4gc3lzdGVtIGNvbXBvbmVudHMu\"\nwould be \"NetBios communication between system components.\"\n\nThe ExtractCabFile function is a global function, not part of the CMalwareDlg class. Note\nthat the file is created with the attribute hidden.\n\n_Figure 27. ExtractCabFile function_\n\nThe .cab file is completely embedded in the .data section, size = 94874 (0x1729A). Hackers\ndeclared the following equivalent: \"static BYTE g_abCabFile[] = {0xXXXX, 0xYYYY};\" (no\n**const, so it will be located in .data section). Extracting that area, we have a .cab file**\ncontaining a file, named smanager_ssl.dll, the date added to the cab is 04/26/2020 - 23:11\n**UTC, build date 26.04.2020 15:11:24 UTC.**\n\n\n-----\n\n_Figure 28. The embedded .cab file contains the file smanager_ssl.dll_\n\nThe smanager_ssl.dll file (netapi32.dll) will be analyzed in the next post because it is\nrelatively complex.\n\n_Figure 29. RunExtrac32Exe function_\n\nThe ExecuteAndWait function is also a global function, using the ShellExecuteExA API to\ncall and wait until the execution completes.\n\n\n-----\n\n_Figure 30. ExecuteAndWait function_\n\nThe Config of the Proxy on the victim machine is defined by the hacker through a struct as\nshown, PROXY_TYPE is an enum:\n\n_Figure 31. struct PROXY_CONFIG_\n\nThe ReadProxyConfig function will read from the victim's registry first, otherwise it will read\nfrom the Firefox pref.js file. We are still not clear why hackers tried to read from Firefox,\nmaybe they did a reconnaisance to learn about the commonly used web browsers at the\ntarget.\n\n\n-----\n\n_Figure 32. ReadProxyConfig function_\n\nThe ReadProxyConfigFromRegistry function is a bit long so there are only important parts:\n\n_Figure 33. The main job of the ReadProxyConfigFromRegistry function_\n\n\n-----\n\nThe ReadProxyConfigFromFireFox function is very long so we won t cover it in detail here.\nThe UpdateFile function uses the memsearh equivalent function to find a string in the file's\ncontent, and C&C Info will be written at the found location. In the case of this malware, the\nmask string is \"192.168\".\n\n_Figure 34: The UpdateFile function uses the memsearh equivalent function to find a string_\n\nWe recreated the C&C Info struct as follows:\n\n_Figure 35. struct of C&C info_\n\nAnd C&C info has been hardcoded by hackers in the code:\n\n\n-----\n\n_Figure 36. C&C information is hardcoded in the malicious code_\n\nThe content of smanager_ssl.dll* (netapi32.dll**) is original and after being updated from\n**g_CCInfo structure via:**\n\n_Figure 37. Contents of smanager_ssl.dll file (netapi32.dll) before and after being updated_\n\nThe function to load the extracted file and create the Scheduler Task:\n\n\n-----\n\n_Figure 38. Function LoadDllAndCreateSchedulerTask to load the extracted file and create_\n\n_a Scheduler Task_\n\nThen, if the malware is run with admin, it will register as a ServiceDll, with the name\nmentioned above, the Service registry key chosen at random from a table of ten elements,\nand appended \"Ex\". These series include: \"Winmads\", \"Winrs\", \"Vsssvr\", \"PlugSvr\",\n\"WaRpc\", \"GuiSvr\", \"WlanSvr\", \"DisSvr\", \"MediaSvr\", \"NvdiaSvr\".\n\nAfter appending Ex by the sprintf function, the registry key on the victim machine is created\nunder the branch HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost will\nbe one of the following strings: “WinmadsEx”, “WinrsEx”, “VsssvrEx”, “PlugSvrEx”,\n“WaRpcEx”, “GuiSvrEx”, “WlanSvrEx”, “DisSvrEx”, “MediaSvrEx”, “NvdiaSvrEx”.\n\nSince the function is also a bit long, only the main points are covered here:\n\n\n-----\n\n_Figure 39. Create a registry key on a victim machine_\n\n_Figure 40. Create service on victim machine_\n\n\n-----\n\nThe RegistryCall function is a self-written function by hacker, it is a global function, also only\ndoing tasks with the Registry. From our point of view, hackers' programming styles are\nextremely messy and inconsistent (maybe this is how they intentionally confusing), which\nmade it difficult for us to analyze. After registering as a Dll service, the Infect function\ncompletes and returns. Malware will exit because of the above call to exit(0) on\n**OnInitDialog**\n\nWe will provide .xml file containing analysis information on IDA so anyone interested in this\nmalware can use it to re-import IDA and Ghidra using Ghidra's plugin xml_importer.py.\n\nThe IOCs of the malicious code have been noted in the article. You can write your own .bat\nfile or script using PowerShell, VBS ... to find and remove this malware on the victim's\ncomputers.\n\n**Note:**\n\nOriginal smanager_ssl.dll\n\nMD5: C11E25278417F985CC968C1E361A0FB0\nSHA256:\nF659B269FBE4128588F7A2FA4D6022CC74E508D28EEE05C5AFF26CC23B7BD1A5\n\n**netapi32.dll (ie smanager_ssl.dll has updated CCInfo):**\n\nMD5: 43CE409C21CAD2EF41C9E1725CA12CEA\nSHA256:\n6C1DB6C3D32C921858A4272E8CC7D78280B46BAD20A1DE23833CBE2956EEBF75\n\n[Click here for Vietnamese version: Part 1,](https://blog.vincss.net/2020/12/phan-tich-ky-thuat-dong-ma-doc-moi-co-nhieu-dau-hieu-lien-quan-toi-nhom-tin-tac-Panda.html) [Part 2](https://blog.vincss.net/2020/12/re017-2-phan-tich-ky-thuat-dong-ma-doc-moi-co-nhieu-dau-hieu-lien-quan-toi-nhom-tin-tac-Panda.html)\n\n**Trương Quốc Ngân (aka HTC)**\n\n**Malware Analysis Expert - VinCSS (a member of Vingroup)**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-19 - [RE018-1] Analyzing new malware of China Panda hacker group used to attack supply chain against Vietnam Government Certification Authority - Part 1.pdf"
    ],
    "report_names": [
        "2020-12-19 - [RE018-1] Analyzing new malware of China Panda hacker group used to attack supply chain against Vietnam Government Certification Authority - Part 1.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bbdb2d7d-4bf4-4100-a108-f4742cfd69ff",
            "created_at": "2022-10-25T16:07:24.01101Z",
            "updated_at": "2025-03-27T02:02:10.074776Z",
            "deleted_at": null,
            "main_name": "Operation SignSight",
            "aliases": [],
            "source_name": "ETDA:Operation SignSight",
            "tools": [
                "Mimikatz",
                "PhantomNet",
                "SManager"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f5bf6853-3f6e-452c-a7b7-8f81c9a27476",
            "created_at": "2023-01-06T13:46:38.677391Z",
            "updated_at": "2025-03-27T02:00:02.889755Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "MISPGALAXY:Careto",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535717,
    "ts_updated_at": 1743041395,
    "ts_creation_date": 1653756975,
    "ts_modification_date": 1653756975,
    "files": {
        "pdf": "https://archive.orkl.eu/fb0b07faa64bb2653eaf441ae2536506d4932e5e.pdf",
        "text": "https://archive.orkl.eu/fb0b07faa64bb2653eaf441ae2536506d4932e5e.txt",
        "img": "https://archive.orkl.eu/fb0b07faa64bb2653eaf441ae2536506d4932e5e.jpg"
    }
}