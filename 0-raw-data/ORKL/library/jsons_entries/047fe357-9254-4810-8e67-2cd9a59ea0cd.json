{
    "id": "047fe357-9254-4810-8e67-2cd9a59ea0cd",
    "created_at": "2023-01-12T15:04:16.362873Z",
    "updated_at": "2025-03-27T02:05:53.459865Z",
    "deleted_at": null,
    "sha1_hash": "e98ed211b83ae8a3ab52572a268b288088317dc5",
    "title": "2019-02-05 - Revisiting Hancitor in Depth",
    "authors": "",
    "file_creation_date": "2022-05-25T14:13:56Z",
    "file_modification_date": "2022-05-25T14:13:56Z",
    "file_size": 3489667,
    "plain_text": "# Revisiting Hancitor in Depth\n\n**[0ffset.net/reverse-engineering/malware-analysis/reversing-hancitor-again](https://www.0ffset.net/reverse-engineering/malware-analysis/reversing-hancitor-again/)**\n\n[0verfl0w_](https://www.0ffset.net/author/dan489400/)\n5th February 2019\n4 Comments\n\n\n5 February 2019\n\n\nAs you probably guessed from the title, we are going to be taking a look at Hancitor once\nagain, except this time, I’ll be focusing on the second stage of Hancitor that is dropped as a\nresult of a Microsoft Word or Excel document. I was planning to include an analysis of one\nof the third stage payloads – ISFB – in this post, however it would have been extremely\nlong, so I decided to give it it’s own post. This post will replace my original post about\nHancitor (Part 2, not Part 1), as this time I’ve fully analyzed the sample, and therefore do\nnot need to rely on outside information. Both the packed and unpacked samples are\n[available on VirusBay. Let’s get into it!](https://beta.virusbay.io/)\n\nMD5 (Hancitor – Packed): c07661bd4f875b6c6908f2d526958532\n\nMD5 (Hancitor – Unpacked, Unmapped): 5fe47865512eb9fa5ef2cccd9c23bcbf\n\n### Unpacking Hancitor\n\nAs per usual with most malware nowadays, Hancitor’s Second Stage payload is packed, so\nbefore we get to the interesting part, we need to unpack it, which isn’t particularly difficult\nto do so. I will be using Immunity Debugger to step through the unpacking, as x32dbg failed\nto analyze sections correctly. This will be a quick unpacking, and there won’t be much detail\non the unpacking routine as this isn’t the purpose of the post. Upon opening the file in a\ndebugger, scroll down until you see a call to EBX and put a breakpoint on that call:\n\n\n-----\n\nExecute the program and once it has hit the breakpoint, step into EBX. From there, you will\nsee several jumps – follow these jumps and you will notice values being pushed to the stack,\nuntil you see a call to EAX (VirtualProtect).\n\nYou can step over this and follow the jumps again. You’ll notice registers being incremented\nand compared, until you hit an XOR BYTE PTR. As you probably guessed, this is a loop\nthat XOR’s values in the main binary. If you keep stepping over, you’ll reach a JB\ninstruction, and just underneath is a JNO instruction. Put a breakpoint on\nthe JNO instruction, as shown below, and execute the program.\n\n\n-----\n\nOnce you’ve hit the breakpoint, simply step over the next few instructions, until you see a\njump to EAX. Upon following this jump, you’ll find a section of un-analyzed code. Right\nclick and select Analysis->During next analysis, treat selection as->Command,\nand then CTRL-A. The section will be re-analyzed and should resemble something similar\nto the image below.\n\nFrom there, scroll down. You’ll notice strings such as “VirtualAlloc” and “_stricmp” – this\nsection loads different DLLs and imports functions. You can step through this and analyze\nit, or you can scroll down until you see the last API being imported, which in this case\nis “memcpy“. After a call to GetProcAddress ([EBP-28] here), EAX (memcpy) is moved\ninto [EBP-30]. Put a breakpoint on this and execute the program.\n\n\n-----\n\nScroll down further and you’ll see another jump to EAX – put a breakpoint on that and run\nthe program once again.\n\nFollowing this jump should take you to another region of memory – in this case it is\nat 0x000203E4. You’ll see a jump near the bottom of the window, so put a breakpoint on\nthat and execute the program again.\n\n\n-----\n\nJumping to the address will show the Substitution Box creation and scramble instructions,\nwhich creates the lookup table for RC4 decryption. We can skip over this so keep scrolling\ndown until you see several IMUL instructions and another function call. Put a breakpoint\non this call and run the program.\n\nSeveral libraries will be loading upon running the program, but just ignore that. Once the\nbreakpoint has been tripped, step into the function and follow the jump. From there, there\nwill be a call to an API, and a call to a function. Make sure you step into this function, and\nfollow the jump.\n\n\n-----\n\nYou will see another API call and function call. Step into the function, and there will be a\njump to EAX – take this jump, and it will lead you back to the original memory region of the\nbinary.\n\nOnce you get there, you will need to re-analyze the section, just like we did before. Ignore\nthe first function call, and step into the second call.\n\n\n-----\n\nThis function has a few calls, but the important ones are near the bottom –\n**GetMessageA, TranslateMessage, and DispatchMessageA. They will be in a loop, so**\nsimply put a breakpoint after the loop, and run the program. This loop will result in the\nmain Hancitor payload being written to a different region of memory, and run it, so make\nsure you disconnect your machine from the network for this. You will have to pause the\nexecution of the program yourself, as the loop will not exit until the payload thread has.\n\nMake sure you have Process Hacker open as well, as this will allow you to dump the\nunpacked payload. Wait for around 30-45 seconds (although it depends), and search\nfor RWX protected regions of memory in Process Hacker. In this case, there is a 36 Kb\nsection, which upon viewing, has a valid MZ header, so let’s dump it.\n\n\n-----\n\nAs we dumped the payload from memory, it is mapped, so we need to unmap it. Open the\ndumped file in PE-Bear and go to the Section Headers option, as shown in the image. You\nneed to change the value of the Raw Addr. so that it matches the value of the Virtual Addr.\nYou then need to change the Raw size of each of the sections, except for the last section,\nwhich is .reloc here.\n\nUpon doing this, you will notice the imports section starts fixing itself. If you see a similar\nimport table to the one shown below, congratulations, you have successfully unpacked\nHancitor! We can now start analyzing the unpacked payload!\n\n\n-----\n\n### Analyzing Hancitor: Unpacked\n\nI will be statically analyzing the unpacked version of Hancitor, using IDA Pro, although you\ncan use any dissassembler, or even dynamically analyze it.\n\nUpon opening the file, there are three functions, and then a call to ExitProcess. The first two\nfunctions are not important, and simply seem to be used for importing API calls and loading\nlibraries. The third function contains all of the interesting stuff, so let’s jump into that.\n\nInside the main section, there are several functions that are called. The first three are calls\nto a function that simply allocates a heap, with the sizing based on the argument, so we can\nignore that.\n\n\n-----\n\n-----\n\nTaking a look at the next called function, we can see a lot of stuff happening.\n\n\n-----\n\nFirst, Hancitor calls GetVersion, and then calls 4 additional functions to gather more\nsystem information. The first function of the 4 returns a GUID for the user, based on\ngathered volume information and adapter addresses.\n\n\n-----\n\nThe second function locates both the computer name and the username. To get the\ncomputer name, it simply calls GetComputerName and appends an @ sign on the end. In\norder to get the username, rather than calling GetUserName, it enumerates through\nrunning processes searching for explorer.exe, and when found, it opens the process,\nopens the process token, and then gathers the token information. This is then used in a call\nto LookupAccountSidA, which will return the username and the domain which the\nusername was found on. This is then formatted together, so it will\nread Domain\\Username. Then, this is appended to the original computer name.\n\n\n-----\n\nThe third function is responsible for gathering the external IP address. To do so, it uses\nthe WININET library to send a GET request to api[.]ipify[.]com, the go-to for Hancitor.\nIf it fails to connect to the site, it simply sets the IP as 0.0.0.0, and continues on.\n\n\n-----\n\nFinally, the fourth function is used to determine the architecture of the system, whether it is\nx64 or x32 bit. This will determine which string to wsprintf the data to. It attempts to\nimport GetNativeSystemInfo, and if it fails, it will just call GetSystemInfo. If the\nfunction returns 1, the system is a 64 bit system. Otherwise, it will be set as 32 bit.\n\nOnce the architecture has been determined, the BUILD value and C2 URLs are RC4\ndecrypted, using native WinCrypt functions rather than a custom implementation of RC4.\nThe BUILD represents the campaign date of the specific Hancitor sample. In this case, the\nbuild is 17bdp12, which indicates the campaign began on the 17th of December.\n\n\n-----\n\nOnce the decryption has finished, the values retrieved by the five functions are stored in a\nstring using wsprintf. The string depends on the architecture, but only the last 5\ncharacters:\n```\nGUID=%I64u&BUILD=%s&INFO=%s&IP=%s&TYPE=1&WIN=%d.%d(x32)\n\n```\nThis is stored in a buffer, which will be used in a POST request to the recently decrypted\nC2s. After the wsprintf call, Hancitor begins to focus on the C2s. First, it checks to see if\nthe C2s have been decrypted, and if not, it will decrypt them again. Once decrypted, each C2\nURL is split with ‘|‘, for easy splitting. Hancitor copies the first URL to a different region of\nmemory and attempts to connect to it. If it fails to contact the C2, it will try with the next\nURL, until it realizes all C2s are down, and then it sleeps for 60000 milliseconds, and\nretries. If there is still no response, it will exit. The C2s are contacted using\n**WININET API’s, with a POST request containing the formatted data. If a C2 server is**\nonline, it will typically return a large string of encrypted data that indicates what the\nmalware should do next.\n\n\n-----\n\n-----\n\nIf the C2 server is online and does return data, a verification function is called, which takes\nthe returned data as an argument. The first 4 bytes in the response are checked to see if they\nare more than or equal to 65, and less than or equal to 90 (basically checking if they are in\nthe alphabet and are uppercase letters). Then, it checks if the character code of the second\nletter (response[1]) minus 90, plus 65 is equal to the character code of the third letter\n(response[2]). If it is equal, the function will return 0, otherwise it will run another check to\nsee if the character code of the fourth letter (response[3]) is equal to 90 minus the character\ncode of the first letter (response[0]) + 65. The result of this will be returned. If 0 is returned,\nthe malware will return 0, otherwise it will return 1.\n\n\n-----\n\nAnd that brings a close to the first\nfunction – this will be a long one. Back\nto the main payload, if the last function\nreturned 1, Hancitor will begin to\ndecrypt the data, otherwise it will sleep\nand try again. The next function call\naccepts the C2_Response + 4, so it\ndiscards the first 4 bytes, as they are\nsimply for verification. Taking a look at\nthe function, we can see a call to a\nfunction that takes the encrypted data\nand the address of an empty heap that\nwas previously allocated. It returns a\nvalue which is stored in a variable. This particular variable is used in a for loop, so we can\nassume that this is the size of the data. We can also assume that the empty heap will contain\ndata, as each character is XOR’ed using the hexadecimal value 0x7A. Once the loop has\nended, it returns. So let’s take a look at sub_3B1000.\n\nIf you have ever written a Base64 encoder/decoder in languages such as C/C++ or even\nPython, you may recognize this pseudo-code as a Base64 decryption algorithm. Hancitor\nsimply Base64 decodes the C2 response and XOR’s it using 0x7A, making it quite effortless\nto decrypt C2 data.\n\n\n-----\n\nBefore we move onto the next functions, it is important to know what the C2 data actually\nlooks like.\n\nAs you can see, there are 3 “sections” in this decrypted response, with each section starting\nwith { and ending with }, and each URL being split with a |. You can also see at the start of\neach section there is a letter and then : – this letter indicates what Hancitor should do with\n\n\n-----\n\nthe specific URL. The next function splits the sections up, by checking for { and then\ncopying each character to an allocated heap, until the character equals }. This data is then\nused in the next function.\n\nThe next function takes the section of URLs and checks to see if the second character is :,\nand then to see if the first character equals; r, l, e, b, d, c,or n. If it doesn’t equal any of the\ncharacters, it loops. Otherwise, it will continue to the next function, which will carry out the\ncommand.\n\nWhilst Hancitor checks for 8 characters, it only uses 5 of them; r, l, e, b and n. If the\nresponse is n, the malware does nothing. If it is b, it will download a file from the URL,\ndecompress it, and inject it into SVCHOST. If it is e, it will download a file, decompress it,\nand execute it as a new thread. If it is l, it will download a file, decompress it, and execute it\nas a new thread with an argument. Finally, if the command is r, it will download a file,\ndecompress it, and execute it as it’s own process.\n\n\n-----\n\nOne particularly interesting thing about the download and decompress routine is how it\nchecks the first two characters of the decompressed, downloaded file for MZ, to make sure\nit is in fact an EXE or DLL. When executing as an own process, it checks whether or not the\nfile is a DLL or an EXE by looking it up in the file header, and if it is a DLL it uses\nRUNDLL32.exe to execute it.\n\n\n-----\n\nSVCHOST.exe Injection:\n\n\n-----\n\nExecute in New Thread:\n\nExecute as own Process:\n\n\n-----\n\nOnce the process has been executed,\nthe function returns back to the main\npayload, and now fully annotated, you\ncan view the flow of the program.\n\nNow that brings an end to this full analysis of Hancitor’s second stage. I am currently\nworking on writing a Python script that extracts Hancitor communications from PCAP files,\ndecrypts them, and then attempts to interact with the C2 servers to download the third stage\npayload as a file, which will be up on GitHub once it is complete. My ISFB analysis should\nbe posted soon – I am currently quite busy, but expect it soon!\n\n\n-----\n\n```\nIOCs:\n   Build: 17bdp12\n   Hancitor (Packed: MD5): c07661bd4f875b6c6908f2d526958532\n   Hancitor (Unpacked: MD5): 5fe47865512eb9fa5ef2cccd9c23bcbf\n   Second Stage C2s:\n     http://woodlandsprimaryacademy.org/wp-includes/(1|2|3)\n     http://precisionpartners.org/wp-admin/includes/(1|2|3)\n     http://precisionpartners.org/wp-admin/includes/(1|2|3)\n     http://mail.porterranchpetnanny.com/wp-includes/(1|2|3)\n     http://synergify.com/wp-content/themes/ward/(1|2|3)\n\n## 4 Comments\n\n```\nComments are closed.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-02-05 - Revisiting Hancitor in Depth.pdf"
    ],
    "report_names": [
        "2019-02-05 - Revisiting Hancitor in Depth.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535856,
    "ts_updated_at": 1743041153,
    "ts_creation_date": 1653488036,
    "ts_modification_date": 1653488036,
    "files": {
        "pdf": "https://archive.orkl.eu/e98ed211b83ae8a3ab52572a268b288088317dc5.pdf",
        "text": "https://archive.orkl.eu/e98ed211b83ae8a3ab52572a268b288088317dc5.txt",
        "img": "https://archive.orkl.eu/e98ed211b83ae8a3ab52572a268b288088317dc5.jpg"
    }
}