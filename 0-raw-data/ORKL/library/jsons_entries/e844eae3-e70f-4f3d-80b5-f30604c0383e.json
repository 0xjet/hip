{
    "id": "e844eae3-e70f-4f3d-80b5-f30604c0383e",
    "created_at": "2023-01-12T15:01:32.009622Z",
    "updated_at": "2025-03-27T02:08:00.069449Z",
    "deleted_at": null,
    "sha1_hash": "f6d85a058abc30f206787dce95210356f754c622",
    "title": "2022-11-05 - Malware analysis- part 6. Shannon entropy. Simple python script.",
    "authors": "",
    "file_creation_date": "2022-11-28T19:02:49Z",
    "file_modification_date": "2022-11-28T19:02:49Z",
    "file_size": 1967694,
    "plain_text": "# Malware analysis: part 6. Shannon entropy. Simple python script.\n\n**[cocomelonc.github.io/malware/2022/11/05/malware-analysis-6.html](https://cocomelonc.github.io/malware/2022/11/05/malware-analysis-6.html)**\n\nNovember 5, 2022\n\n### 8 minute read\n\n ﷽\n\n Hello, cybersecurity enthusiasts and white hackers!\n\n This post is the result of my own research on Shannon entropy. How to use it for malware analysis in practice.\n\n## entropy\n\n\n-----\n\n### Simply said, Shannon entropy is the quantity of information included inside a message, in communication terminology. Entropy is a measure of the unpredictability of the file’s data. The Shannon entropy is named after the famous mathematician Shannon Claude.\n\n## entropy and malwares\n\n### Now let me unfold a relationship between malwares and entropy. Malware authors are clever and advance and they do many tactics and tricks to hide malware from AV engines. As you know from my previous posts, it’s usually something like payload encryption or function call obfuscation. But at the same time as author is compressing the data as well as inserting some harmful code in the original file author is lowering the unpredictability of data therefore raising the entropy and here we can catch the file based on the entropy value. So, the greater the entropy, the more likely the data is obfuscated or encrypted, and the more probable the file is malicious.\n\n## practical examples\n\n### So how do you calculate Shannon’s entropy?\n\n which can represent as:\n\n i.e.\n\n is a well known identity of the logarithm.\n\n means “The entropy of data X.”.\n\n The right hand of formula represents a summation that sums up:\n\n This is the most important part of the equation, because this is what assigns higher numbers to rarer events and lower numbers to common events.  represents the proportion of each unique character  in the input .\n\n\n-----\n\n### In the Python language it is looks like this:\n```\nimport math\n\ndef shannon_entropy(data):\n\n  # 256 different possible values\n\n  possible = dict(((chr(x), 0) for x in range(0, 256)))\n\n  for byte in data:\n\n    possible[chr(byte)] +=1\n\n  data_len = len(data)\n\n  entropy = 0.0\n\n  # compute\n\n  for i in possible:\n\n    if possible[i] == 0:\n\n      continue\n\n    p = float(possible[i] / data_len)\n\n    entropy -= p * math.log(p, 2)\n\n  return entropy\n\n Let’s go to create script which calculate Shannon entropy of PE file’s sections. Let’s start with a simpler problem. First of all, for simplicity, let’s calculate Shannon entropy for binary files ( entropy.py ):\n\n```\n\n-----\n\n```\nimport argparse\n\nimport math\n\ndef shannon_entropy(data):\n\n  # 256 different possible values\n\n  possible = dict(((chr(x), 0) for x in range(0, 256)))\n\n  for byte in data:\n\n    possible[chr(byte)] +=1\n\n  data_len = len(data)\n\n  entropy = 0.0\n\n  # compute\n\n  for i in possible:\n\n    if possible[i] == 0:\n\n      continue\n\n    p = float(possible[i] / data_len)\n\n    entropy -= p * math.log(p, 2)\n\n  return entropy\n\nif __name__ == \"__main__\":\n\n  parser = argparse.ArgumentParser()\n\n  parser.add_argument('-f','--file', required = True, help = \"target file\")\n\n  args = vars(parser.parse_args())\n  target_file = args['file']\n\n  with open(target_file, 'rb') as f:\n\n    data = f.read()\n\n    if data:\n\n      entropy = shannon_entropy(data)\n\n      print(entropy)\n\n### As you can see, everything is simple. Just read binary file and calculate Shannon entropy.\n\n## demo 1\n\n### Let’s say we have information. For simplicity, as usually meow-meow messagebox payload is used by me.\n\n Run:\npython3 entropy -f ./meow.bin\n\n How will this value change if this binary file is encrypted?\n\n```\n\n-----\n\n### Let s start with XOR encryption. Create simple script ( xor.py ):\n```\nimport argparse\n\n## XOR function to encrypt data\n\ndef xor(data, key):\n\n  key = str(key)\n\n  l = len(key)\n\n  output_str = \"\"\n\n  for i in range(len(data)):\n\n    current = data[i]\n\n    current_key = key[i % len(key)]\n\n    ordd = lambda x: x if isinstance(x, int) else ord(x)\n\n    output_str += chr(ordd(current) ^ ord(current_key))\n\n  return output_str\n\n## encrypting\n\ndef xor_encrypt(data, key):\n\n  ciphertext = xor(data, key)\n\n  ciphertext_str = '{ 0x' + ', 0x'.join(hex(ord(x))[2:] for x in ciphertext) + '\n};'\n\n  print (ciphertext_str)\n\n  return ciphertext\n\nif __name__ == \"__main__\":\n\n  # key for encrypt/decrypt\n\n  my_secret_key = \"mysupersecretkey\"\n\n  parser = argparse.ArgumentParser()\n\n  parser.add_argument('-f','--file', required = True, help = \"target file\")\n\n  args = vars(parser.parse_args())\n  target_file = args['file']\n\n  with open(target_file, 'rb') as f:\n\n    data = f.read()\n\n    if data:\n\n      # encrypted\n\n      ciphertext = xor_encrypt(data, my_secret_key)\n\n      with open(\"xor.bin\", \"wb\") as result:\n\n        result.write(ciphertext.encode())\n\n As you can see, just xor binary file and save it as xor.bin . Let’s check:\npython3 xor.py -f ./meow.bin\n\npython3 entropy -f ./xor.bin\n\n```\n\n-----\n\n### As you can see, entropy is increased from 5.75 to 6.15 .\n\n What about AES encryption? Create another script ( aes.py ):\n\n\n-----\n\n```\n# AES encryption\n\nimport argparse\n\nimport hashlib\n\nfrom Crypto.Cipher import AES\n\nfrom Crypto.Random import get_random_bytes\n\nfrom Crypto.Util.Padding import pad\n\ndef aes_encrypt(data, key):\n\n  k = hashlib.sha256(key).digest()\n\n  iv = 16 * '\\x00'\n\n  cipher = AES.new(k, AES.MODE_CBC, iv.encode(\"UTF-8\"))\n\n  ciphertext = cipher.encrypt(pad(data, AES.block_size))\n\n  return ciphertext\n\nif __name__ == \"__main__\":\n\n  # key for encrypt/decrypt\n\n  my_secret_key = get_random_bytes(16)\n\n  parser = argparse.ArgumentParser()\n\n  parser.add_argument('-f','--file', required = True, help = \"target file\")\n\n  args = vars(parser.parse_args())\n  target_file = args['file']\n\n  with open(target_file, 'rb') as f:\n\n    data = f.read()\n\n    if data:\n\n      # encrypted\n\n      ciphertext = aes_encrypt(data, my_secret_key)\n\n      with open(\"aes.bin\", \"wb\") as result:\n\n        result.write(ciphertext)\n\n### It’s also pretty simple: create AES -encrypted binary aes.bin as result. Let’s check:\npython3 aes.py -f ./meow.bin\n\npython3 entropy -f ./aes.bin\n\n As you can see, for AES encryption, entropy is increased from 5.75 to 7.18 .\n\n Now i modify my script enropy.py to calculate shannon entropy for sections of pe file:\n\n```\n\n-----\n\n```\nimport argparse\n\nimport math\n\nimport pefile\n\ndef shannon_entropy(data):\n\n  # 256 different possible values\n\n  possible = dict(((chr(x), 0) for x in range(0, 256)))\n\n  for byte in data:\n\n    possible[chr(byte)] +=1\n\n  data_len = len(data)\n\n  entropy = 0.0\n\n  # compute\n\n  for i in possible:\n\n    if possible[i] == 0:\n\n      continue\n\n    p = float(possible[i] / data_len)\n\n    entropy -= p * math.log(p, 2)\n\n  return entropy\n\ndef sections_entropy(path):\n\n  pe = pefile.PE(path)\n\n  for section in pe.sections[:3]:\n\n    print(section.Name.decode('utf-8'))\n\n    print(\"\\tvirtual address: \" + hex(section.VirtualAddress))\n\n    print(\"\\tvirtual size: \" + hex(section.Misc_VirtualSize))\n\n    print(\"\\traw size: \" + hex(section.SizeOfRawData))\n\n    print (\"\\tentropy: \" + str(shannon_entropy(section.get_data())))\n\nif __name__ == \"__main__\":\n\n  parser = argparse.ArgumentParser()\n\n  parser.add_argument('-f','--file', required = True, help = \"target file\")\n\n  args = vars(parser.parse_args())\n  target_file = args['file']\n\n  with open(target_file, 'rb') as f:\n\n    sections_entropy(target_file)\n\n### For simplicity and demonstration purposes this calculate and print just first 3 sections.\n\n## demo 2\n\n### As an sample file I used one of my malware from this post:\n\n```\n\n-----\n\n```\n/\n * hack.cpp - run shellcode via EnumDesktopA. C++ implementation\n\n * @cocomelonc\n\n * https://cocomelonc.github.io/tutorial/2022/06/27/malware-injection-20.html\n\n*/\n#include <windows.h>\n\nunsigned char my_payload[] =\n\n // 64-bit meow-meow messagebox\n\n \"\\xfc\\x48\\x81\\xe4\\xf0\\xff\\xff\\xff\\xe8\\xd0\\x00\\x00\\x00\\x41\"\n\n \"\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\"\n\n \"\\x3e\\x48\\x8b\\x52\\x18\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x48\\x8b\\x72\"\n\n \"\\x50\\x3e\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\"\n\n \"\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\"\n\n \"\\xed\\x52\\x41\\x51\\x3e\\x48\\x8b\\x52\\x20\\x3e\\x8b\\x42\\x3c\\x48\"\n\n \"\\x01\\xd0\\x3e\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x6f\"\n\n \"\\x48\\x01\\xd0\\x50\\x3e\\x8b\\x48\\x18\\x3e\\x44\\x8b\\x40\\x20\\x49\"\n\n \"\\x01\\xd0\\xe3\\x5c\\x48\\xff\\xc9\\x3e\\x41\\x8b\\x34\\x88\\x48\\x01\"\n\n \"\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\"\n\n \"\\xc1\\x38\\xe0\\x75\\xf1\\x3e\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\"\n\n \"\\x75\\xd6\\x58\\x3e\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x3e\\x41\"\n\n \"\\x8b\\x0c\\x48\\x3e\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x3e\\x41\\x8b\"\n\n \"\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\"\n\n \"\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\"\n\n \"\\x59\\x5a\\x3e\\x48\\x8b\\x12\\xe9\\x49\\xff\\xff\\xff\\x5d\\x49\\xc7\"\n\n \"\\xc1\\x00\\x00\\x00\\x00\\x3e\\x48\\x8d\\x95\\x1a\\x01\\x00\\x00\\x3e\"\n\n \"\\x4c\\x8d\\x85\\x25\\x01\\x00\\x00\\x48\\x31\\xc9\\x41\\xba\\x45\\x83\"\n\n \"\\x56\\x07\\xff\\xd5\\xbb\\xe0\\x1d\\x2a\\x0a\\x41\\xba\\xa6\\x95\\xbd\"\n\n \"\\x9d\\xff\\xd5\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\"\n\n \"\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\"\n\n \"\\xd5\\x4d\\x65\\x6f\\x77\\x2d\\x6d\\x65\\x6f\\x77\\x21\\x00\\x3d\\x5e\"\n\n \"\\x2e\\x2e\\x5e\\x3d\\x00\";\n\nint main(int argc, char* argv[]) {\n\n LPVOID mem = VirtualAlloc(NULL, sizeof(my_payload), MEM_COMMIT,\nPAGE_EXECUTE_READWRITE);\n\n RtlMoveMemory(mem, my_payload, sizeof(my_payload));\n\n EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, NULL);\n\n return 0;\n\n}\n\n### Run updated script:\npython3 entropy -f ./hack.exe\n\n```\n\n-----\n\n### I uploaded this file to VirusTotal, which also calculate sections’ entropy:\n\n As you can see our script is worked perfectly!\n\n\n-----\n\n### I wonder what the Shannon entropy will show if we use one of our AV evasion tricks?\n\n I just create XOR - encrypted payload from meow.bin for simplicity:\n\n Also add decryption function ( hack2.cpp ):\n\n\n-----\n\n```\n/\n * hack.cpp - run shellcode via EnumDesktopA. C++ implementation\n\n * @cocomelonc\n\n * https://cocomelonc.github.io/tutorial/2022/06/27/malware-injection-20.html\n\n*/\n#include <windows.h>\n\nunsigned char my_payload[] =\n\n // 64-bit meow-meow messagebox encrypted\n\n { 0x91, 0x31, 0xf2, 0x91, 0x80, 0x9a, 0x8d, 0x8c, 0x8d, 0xb3, 0x72,\n\n  0x65, 0x74, 0x2a, 0x34, 0x38, 0x3d, 0x2b, 0x22, 0x23, 0x38, 0x54,\n\n  0xa0, 0x16, 0x2d, 0xe8, 0x20, 0x5, 0x4a, 0x23, 0xee, 0x2b, 0x75,\n\n  0x47, 0x3b, 0xfe, 0x22, 0x45, 0x4c, 0x3b, 0xee, 0x11, 0x22, 0x5b,\n\n  0x3c, 0x64, 0xd2, 0x33, 0x27, 0x34, 0x42, 0xbc, 0x38, 0x54, 0xb2,\n\n  0xdf, 0x59, 0x2, 0xe, 0x67, 0x58, 0x4b, 0x24, 0xb8, 0xa4, 0x74,\n\n  0x32, 0x74, 0xb1, 0x87, 0x9f, 0x21, 0x24, 0x32, 0x4c, 0x2d, 0xff,\n\n  0x39, 0x45, 0x47, 0xe6, 0x3b, 0x4f, 0x3d, 0x71, 0xb5, 0x4c, 0xf8,\n\n  0xe5, 0xeb, 0x72, 0x65, 0x74, 0x23, 0xe0, 0xb9, 0x19, 0x16, 0x3b,\n\n  0x74, 0xa0, 0x35, 0x4c, 0xf8, 0x2d, 0x7b, 0x4c, 0x21, 0xff, 0x2b,\n\n  0x45, 0x30, 0x6c, 0xa9, 0x90, 0x29, 0x38, 0x9a, 0xbb, 0x4d, 0x24,\n\n  0xe8, 0x46, 0xed, 0x3c, 0x6a, 0xb3, 0x34, 0x5c, 0xb0, 0x3b, 0x44,\n\n  0xb0, 0xc9, 0x33, 0xb2, 0xac, 0x6e, 0x33, 0x64, 0xb5, 0x53, 0x85,\n\n  0xc, 0x9c, 0x47, 0x3f, 0x76, 0x3c, 0x41, 0x7a, 0x36, 0x5c, 0xb2,\n\n  0x7, 0xb3, 0x2c, 0x55, 0x21, 0xf2, 0x2d, 0x5d, 0x3a, 0x74, 0xa0,\n\n  0x3, 0x4c, 0x32, 0xee, 0x6f, 0x3a, 0x5b, 0x30, 0xe0, 0x25, 0x65,\n\n  0x24, 0x78, 0xa3, 0x4b, 0x31, 0xee, 0x76, 0xfb, 0x2d, 0x62, 0xa2,\n\n  0x24, 0x2c, 0x2a, 0x3d, 0x27, 0x34, 0x23, 0x32, 0x2d, 0x31, 0x3c,\n\n  0x33, 0x29, 0x2d, 0xe0, 0x9e, 0x45, 0x35, 0x39, 0x9a, 0x99, 0x35,\n\n  0x38, 0x2a, 0x2f, 0x4e, 0x2d, 0xf9, 0x61, 0x8c, 0x2a, 0x8d, 0x9a,\n\n  0x8b, 0x36, 0x2c, 0xbe, 0xac, 0x79, 0x73, 0x75, 0x70, 0x5b, 0x3a,\n\n  0xfe, 0xf0, 0x9d, 0x72, 0x65, 0x74, 0x55, 0x29, 0xf4, 0xe8, 0x70,\n\n  0x72, 0x75, 0x70, 0x2d, 0x43, 0xba, 0x24, 0xd9, 0x37, 0xe6, 0x22,\n\n  0x6c, 0x9a, 0xac, 0x25, 0x48, 0xba, 0x34, 0xca, 0x95, 0xc7, 0xd1,\n\n  0x33, 0x9c, 0xa7, 0x28, 0x11, 0x4, 0x12, 0x54, 0x0, 0x1c, 0x1c,\n\n  0x2, 0x51, 0x65, 0x4f, 0x2d, 0x4b, 0x4d, 0x2c, 0x58, 0x74 };\n\n\n// key for XOR decrypt\n\nchar my_secret_key[] = \"mysupersecretkey\";\n\n// decrypt deXOR function\n\nvoid XOR(char * data, size_t data_len, char * key, size_t key_len) {\n\n int j;\n\n j = 0;\n\n for (int i = 0; i < data_len; i++) {\n\n  if (j == key_len - 1) j = 0;\n\n  data[i] = data[i] ^ key[j];\n\n  j++;\n\n }\n\n}\n\nint main(int argc, char* argv[]) {\n\n```\n\n-----\n\n```\n LPVOID mem VirtualAlloc(NULL, sizeof(my_payload), MEM_COMMIT,\nPAGE_EXECUTE_READWRITE);\n\n // decrypt (deXOR) the payload\n\n XOR((char *) my_payload, sizeof(my_payload), my_secret_key, sizeof(my_secret_key));\n\n RtlMoveMemory(mem, my_payload, sizeof(my_payload));\n\n EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, NULL);\n\n return 0;\n\n}\n\n## demo 3\n\n### Let’s go to see in action. Compile our new “malware”:\nx86_64-w64-mingw32-g++ -O2 hack2.cpp -o hack2.exe -I/usr/share/mingw-w64/include/ -s\n-ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-allconstants -static-libstdc++ -static-libgcc -fpermissive\n\n and calculate entropy:\npython3 entropy.py -f ./hack2.exe\n\n```\n\n-----\n\n### As you can see, in this case, Shannon entropy is increased from 5.95 to 6.02 . Perfect! =^..^=\n\n## conclusion\n\n### As you can see, sometimes entropy can help predict whether a file is malicious or not. It is used in many malware analysis programs.\n\n I hope this post will be helpful for blue teamers and red teamers for better understanding theirs “cat =^..^= and mouse <:3 )~~~” game (or war?).\n\n This is a practical case for educational purposes only.\n\n XOR cipher AES AV engines evasion: part 1 Shannon entropy source code in github\n\n Thanks for your time happy hacking and good bye!\n PS. All drawings and screenshots are mine\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-11-05 - Malware analysis- part 6. Shannon entropy. Simple python script..pdf"
    ],
    "report_names": [
        "2022-11-05 - Malware analysis- part 6. Shannon entropy. Simple python script..pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535692,
    "ts_updated_at": 1743041280,
    "ts_creation_date": 1669662169,
    "ts_modification_date": 1669662169,
    "files": {
        "pdf": "https://archive.orkl.eu/f6d85a058abc30f206787dce95210356f754c622.pdf",
        "text": "https://archive.orkl.eu/f6d85a058abc30f206787dce95210356f754c622.txt",
        "img": "https://archive.orkl.eu/f6d85a058abc30f206787dce95210356f754c622.jpg"
    }
}