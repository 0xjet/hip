{
    "id": "dfb4a117-f5e4-4e77-807c-6b128167cc21",
    "created_at": "2022-10-25T16:48:13.911691Z",
    "updated_at": "2025-03-27T02:05:20.967274Z",
    "deleted_at": null,
    "sha1_hash": "a2efe7865a7204626d5a8ff746d9f23b17d3f636",
    "title": "botnet技术方向讨论",
    "authors": "",
    "file_creation_date": "2015-12-09T11:45:30Z",
    "file_modification_date": "2015-12-09T11:45:30Z",
    "file_size": 926344,
    "plain_text": "## Automatically Classifying Unknown Bots \n by The REGISTER Messages\n\n###### Ya Liu liuya@360.cn Network Security Research Lab, Qihoo 360\n\n\n-----\n\n### Outline\n\n#### • Polymorphism and malware classification\n • C&C protocol based classification\n • REGISTER message based classification\n • Evaluation\n • Pitfalls\n • Conclusions\n\n\n-----\n\n### Polymorphic Malwares\n\n######  A great many of new samples are captured\n\n##### every day\n\n*Malware samples captured in Quarter 1 of 2015\n\n######  Most of them are polymorphic variants of known\n\n##### malwares\n\n\n-----\n\n### Malware Classification\n\n##### • The aim is to classify large number of samples into a\n relative small number of families\n\n###### – e.g., zbot, darkshell, gh0st, ...\n\n##### • Static sample signatures are heavily used by anti-virus\n products to build virus signature databases\n\n###### – e.g., size, strings, binary code snippets\n\n##### • It has FP/FN issues when dealing with modern\n polymorphic malwares\n\n\n-----\n\n#### C&C Protocol based Classification\n\n • Most of modern malwares are distributed to\n build botnets\n • It’s proved effective to classify botnets\n /malware based on their C&C protocols\n\n##### – message types/formats/interactions are used\n\n#### • Detailed C&C protocol specification is a pre-\n condition\n\n##### – Manual RE is necessary in most cases\n\n#### • Scalability issue\n\n\n-----\n\n### The REGISTER Message\n\n#### • The first message exchanged in a C&C session,\n which MUST be sent by the bot\n\n##### – It’s also called login, hello, call-home\n\n#### • Its main usage is to tell the controller:\n\n##### – the bot’s machine configs, e.g., OS version, CPU,\n memory size, net speed – hardcoded info copied from sample for verifying\n\n#### • Many known botnets use this message in their\n protocols\n\n\n-----\n\n|bot name|supported OS|OS info in REGISTER?|CPU info in REGISTER|memory info in REGISTER|\n|---|---|---|---|---|\n|darkshell|win|yes|yes|yes|\n|elknot|linux/win|yes|yes|yes|\n|XOR DDoS|linux|yes|yes|no|\n|chinaz|linux/win|yes|yes|yes|\n|mayday|linux|yes|yes|no|\n|dofloo|linux/win|yes|yes|yes|\n\n\n### Common DDoS Bots’ REGISTERs\n\n**OS info** **CPU info** **memory info**\n\n###### supported  bot name in  in in \n OS\n\n**REGISTER?** **REGISTER** **REGISTER**\n\n###### darkshell win yes yes yes\n\n elknot linux/win yes yes yes\n\n XOR DDoS linux yes yes no\n\n chinaz linux/win yes yes yes\n\n mayday linux yes yes no\n\n dofloo linux/win yes yes yes\n\n\n-----\n\n### Elknot’s REGISTER\n\n#### • This bot is also called Billgates\n • It has variable length and binary format\n\nstruct register_msg {\nmsg_hdr hdr;\nu8 conf[0x40];\nstd::string description;\nu32 cpu_num;\nu32 cpu_spd;\nu32 mem_size;\nstd::string os;\nstd::string magic;\n};\n\n\n-----\n\n### Dofloo’s REGISTER\n\n##### • It’s also called Mr. Black\n • It has text format of “VERSONEX:%s|%d|%d|%s”\n\n###### – VERSONEX:Linux-3.11.0-12-generic|2|3576\n MHz|2016MB|634MB|Hacker – VERSONEX:Windows XP|1|3582|Mr.Black – VERSONEX:Windows XP|1|3582\n MHz|1024MB|245MB|Hacker\n\n\n-----\n\n### Shannon Entropy\n\n#### • “Entropy is a measure of unpredictability of\n information content. “\n\n##### – From en.wikipedia.org\n\n#### • Shannon entropy can be used to measure how\n statistically similar 2 messages are\n\n\n-----\n\n|Family name|Length|Entropy|\n|---|---|---|\n|Kelihos|164|4.6~4.8|\n|XOR DDoS|272|3.22~3.29|\n|mayday|401|0.4~0.6|\n|elknot|variable|2.5~2.8|\n\n\n### Sample REGISTER Statistics\n\n###### Family name Length Entropy\n\n Kelihos 164 4.6~4.8\n\n XOR DDoS 272 3.22~3.29\n\n mayday 401 0.4~0.6\n\n elknot variable 2.5~2.8\n\n\n-----\n\n### Classification based on REGISTER\n\n#### • Rich information included in REGISTER\n messages\n\n##### – length, entropy value, format, semantics fields\n\n#### • A new classification that is based on the\n similarities among REGISTERs in statistics/structure\n • It is scalable because the REGISTER message is\n easy to get\n\n\n-----\n\n### Objectives\n\n#### • To classify unlabeled samples based on their\n REGISTER messages\n\n##### – Simplify the sample analysis work\n\n#### • What we really need to do is to find out the\n number of REGISTER families, and generate signatures for later identification\n\n\n-----\n\n### What We not do\n\n#### • Will not tell you which cluster of REGISTERs are\n malicious, and which are not\n • Will not classify HTTP based REGISTERs\n\n##### – Good solution exists – there is so much classification info (e.g., method,\n uri, headers) that we think it’s better to classify them in a separate solution\n\n\n-----\n\n### The Architecture\n\n\n-----\n\n### REGISTER Profiling\n\n#### • Creating REGISTERs from network traces \n\n##### – Mainly parsing PCAP files\n\n#### • Setting REGISTER attributes for later clustering\n and signature generating\n\n##### – Length, entropy, binary/text format, semantic\n strings\n\n\n-----\n\n### Sample Profiles\n\n{ {\n\"bin\":1, “bin\": 1,\n\"length\": 260, \"length\": 127,\n\"entropy\": 0.703393, \"entropy\": 2.949660 ,\n\"strings\": [ \"strings\": [\n{ {\n\"offset\":4, \"offset\": 55,\n\"size\":64, \"size\": 18,\n\"content\":\"Windows XP\", \"content\": \"08:00:27:6D:C8:C5\",\n\"semantics\": ”os” \"semantics\": \"mac\"\n}, },\n{ {\n\"offset\":68, \"offset\": 73,\n\"size\":128, \"size\": 14,\n\"content\":\"1 * 3187MHz\", \"content\": \"Ubuntu 13.10 \",\n\"semantics\": “cpu” \"semantics\": \"os\"\n}, },\n{ {\n\"offset\":196, \"offset\": 87,\n\"size\":32, \"size\": 40,\n\"content\":\"128MB\", \"content\": \"Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz\",\n\"semantics\": “memory” \"semantics\": \"cpu\"\n} }\n] ]\n} }\n\n\n-----\n\n### Coarse-grained Clustering\n\n#### • To group statistically similar REGISTERs\n\n##### – k-means algorithm is used to cluster vectors of\n <length, entropy>\n\n#### • To reduce the computation cost\n\n##### – A O(N[2]) computation cost is needed if we attempt\n to directly find out structurally similar REGISTERs\n\n\n-----\n\n### Finding Semantic Strings\n\n#### • A heuristic deduction procedure\n\n##### – OS: “linux”, “Ubuntu 13.10”,”Win XP” – Memory: “2016MB”, “2016 MB” – CPU: “Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz”,\n “MHz: 3576,3576”, “3582 MHz”\n\n#### • Every semantic string has following attributes:\n\n##### – semantics – offset – size\n\n\n-----\n\n### Length Field\n\n#### • 3 types of semantics\n\n##### – len_value=len3 – len_value=len2+len3 – len_value=len1+len2+len3\n\n#### • Field size\n\n##### – 32-bit/16-bit/8-bit\n\n#### • Byte order\n\n##### – Host-byte-order or network-byte-order\n\n\n-----\n\n### Fine-grained Clustering\n\n#### • To find out structurally similar REGISTERs\n • 2 REGISTERs are considered as structurally\n similar if and only if:\n\n##### 1. Having similar entropy values 2. Sharing the same set of semantics strings and their\n placing order  3. Sharing the same format of length field 4. Sharing the same encoding format\n\n###### • binary or text\n##### 5. Having similar length\n\n\n-----\n\n### Sample Signatures\n\n{\n\"name\":\"L172O0S11T1448427268.607769\",\n\"ordinal\":[0.5, 1.0],\n\"type\":\"normal\",\n\"length\":172,\n\"entropy\":3.48832,\n“patterns\":\n[\n{\"type\":\"rawbytes\", \"offset\":0, \"length\":11, \"content\":\"31 36 38 00 6C 6C 7C 27 7C 27 7C\"}\n]\n}\n\n{\n\"name\":\"L126O4S16T1448427256.926312\",\n\"ordinal\":[0.5, 1.0],\n\"type\":\"normal\",\n\"length\":126,\n\"entropy\":2.74977,\n“patterns\":\n[\n{\"type\":\"rawbytes\", \"offset\":4, \"length\":16, \"content\":\"76 65 72 73 69 6F 6E 00 00 00 00 00 66 00 00 00\"}\n]\n}\n\n\n-----\n\n### Signature Generation\n\n#### • For each group of structurally similar\n REGISTERs a set of signatures are generated\n • Generation steps includes:\n\n##### 1. Finding out frequent items of (offset, byte_value) 2. Merging offset continuing items 3. Normalizing them into valid signatures\n\n#### • Some policies:\n\n##### – AT_LEAST_OCCURS, default is 3 – AT_LEAST_SIG_BYTES, default is 4\n\n\n-----\n\n### Apriori/FP-Growth and Sig Bytes\n\n#### • “Apriori is an algorithm for frequent item set\n mining and association rule learning over transactional databases.”\n\n##### – From en.wikipedia.org\n\n#### • Currently we use Apriori to find the frequent\n items of (offset, byte_value) among REGISTERs\n • We will update our solution to FP-Growth for\n better performance\n\n\n-----\n\n### Signature Types\n\n#### • Normal\n\n##### – specific byte patterns exist at specified offsets\n\n#### • PCRE : \n\n##### – replacing semantic patterns with equivilant PCRE\n expressions, e.g., “Windows\\s.*”,\n\n#### • Entropy: \n\n##### – No valid patterns could be generated – AND all REGISTERs have the same length and very\n close entropy values\n\n\n-----\n\n### Evaluation\n\n#### • Our system is implemented in C++ and\n python\n\n##### – About 2,500 lines of C++ code.\n\n#### • It takes less than 30 minutes to classify 10K\n REGISTERs\n\n##### – Performed on a 4-core Intel(R) Core(TM) i7-4790\n CPU @ 3.60GHz machine with 4GB of RAM – Single thread\n\n\n-----\n\n### Choice of k\n\n#### • k=20 is the best choice for k-means clustering\n when doing coarse-grained clustering\n\n###### matched\n\n25000\n\n20000\n\n15000\n\n10000\n\n5000\n\n0\n\n0 50 100 150 200 250 300 350 400 450matched\n\n\n-----\n\n### False Negatives/ False Positives\n\n\n-----\n\n### Generated Signature: STUN\n\n{\n\"name\":\"L28O0S4O20S7T1447301150.241028\",\n\"ordinal\":[0.5, 1.0],\n\"sigtype\":\"normal\",\n\"length\":28,\n\"entropy\":2.79622,\n\"blocks\":\n[\n{\"type\":\"rawbytes\", \"offset\":0, \"length\":4, \"content\":\"00 01 00 08\"},\n{\"type\":\"rawbytes\", \"offset\":20, \"length\":7, \"content\":\"00 03 00 04 00 00 00\"}\n]\n}\n\n\n-----\n\n### Generated Signature: SSL \n\n{\n“name”:”L45O0S29T1447301147.172219”,\n“ordinal”:[0.5, 1.0],\n“type”:”normal”,\n“length”:45,\n“entropy”:2.93596,\n“blocks”:\n[\n{“type”:”rawbytes”, “offset”:0, “length”:29, “content”:”80 2B 01 00 02 00 12 00 00 00 10 01 00 80 07 00 C0 03 00 80 06 00\n40 02 00 80 04 00 80”}\n]\n}\n\n\n-----\n\n### Generated Signature: Bladabindi\n\n{\n\"name\":\"L158O0S7O31S1O43S4O51S1O66S1O72S1O81S1O85S1O103S1O134S24T1447301149.680667\",\n\"ordinal\":[0.5, 1.0],\n\"type\":\"normal\",\n\"length\":158,\n\"entropy\":3.3299,\n\"blocks\":\n[\n{\"type\":\"rawbytes\", \"offset\":0, \"length\":7, \"content\":\"6C 76 7C 27 7C 27 7C\"},\n{\"type\":\"rawbytes\", \"offset\":31, \"length\":1, \"content\":\"7C\"},\n{\"type\":\"rawbytes\", \"offset\":43, \"length\":4, \"content\":\"42 4F 4F 4D\"},\n{\"type\":\"rawbytes\", \"offset\":51, \"length\":1, \"content\":\"7C\"},\n{\"type\":\"rawbytes\", \"offset\":66, \"length\":1, \"content\":\"7C\"},\n{\"type\":\"rawbytes\", \"offset\":72, \"length\":1, \"content\":\"30\"},\n{\"type\":\"rawbytes\", \"offset\":81, \"length\":1, \"content\":\"7C\"},\n{\"type\":\"rawbytes\", \"offset\":85, \"length\":1, \"content\":\"7C\"},\n{\"type\":\"rawbytes\", \"offset\":103, \"length\":1, \"content\":\"73\"},\n{\"type\":\"rawbytes\", \"offset\":134, \"length\":24, \"content\":\"7C 27 7C 27 7C 2E 2E 7C 27 7C 27 7C 7C 27 7C 27 7C 5B 65\n6E 64 6F 66 5D\"}\n]\n}\n\n\n-----\n\n### Generated Signature: Nitol\n\n{\n\"name\":\"LXO1S18T1448629222.519142\",\n\"ordinal\":[0.5, 1.0],\n\"type\":\"normal\",\n\"entropy\":1.2787,\n\"blocks\":\n[\n{\"type\":\"rawbytes\", \"offset\":1, \"length\":18, \"content\":\"00 00 00 77 00 00 00 09 04 00 00 57 69 6E 20 58 50 20\"}\n]\n}\n\n\n-----\n\n### Pitfalls\n\n#### • REGISTER is not always used in C&C protocols\n • For UDP based C&C protocol, it’s hard to tell\n which message is REGISTER because of its statelessness nature\n • The same REGISTER may be shared across\n different C&C protocols\n • Our solution is not good at classifying\n variable-length text format REGISTERs\n\n\n-----\n\n### Conclusions\n\n#### • Statistical/structural similarities can be used to\n effectively classify REGISTERs\n • REGISTER based classification can\n complement C&C protocol based classification\n • Our solution is good at classifying binary\n format REGISTERs with fixed lengths\n\n\n-----\n\n# Q&A\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.botconf.eu/wp-content/uploads/2015/12/OK-P13-Liu-Ya-Automatically-Classify-Unknown-Bots-by-The-Register-Messages.pdf"
    ],
    "report_names": [
        "OK-P13-Liu-Ya-Automatically-Classify-Unknown-Bots-by-The-Register-Messages.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716493,
    "ts_updated_at": 1743041120,
    "ts_creation_date": 1449661530,
    "ts_modification_date": 1449661530,
    "files": {
        "pdf": "https://archive.orkl.eu/a2efe7865a7204626d5a8ff746d9f23b17d3f636.pdf",
        "text": "https://archive.orkl.eu/a2efe7865a7204626d5a8ff746d9f23b17d3f636.txt",
        "img": "https://archive.orkl.eu/a2efe7865a7204626d5a8ff746d9f23b17d3f636.jpg"
    }
}