{
    "id": "d22d2e02-a0ee-47cb-9902-5e36c51a5fd5",
    "created_at": "2023-01-12T15:00:45.050436Z",
    "updated_at": "2025-03-27T02:05:27.635189Z",
    "deleted_at": null,
    "sha1_hash": "47537e82163fd58226de23b23a1bd7fe4638ad92",
    "title": "2018-05-12 - MS Crypto Derive Functions",
    "authors": "",
    "file_creation_date": "2022-05-28T17:57:32Z",
    "file_modification_date": "2022-05-28T17:57:32Z",
    "file_size": 82439,
    "plain_text": "# MS Crypto Derive Functions\n\n**[sysopfb.github.io/malware,/reverse-engineering/2018/05/12/MS-Derivation-functions.html](https://sysopfb.github.io/malware,/reverse-engineering/2018/05/12/MS-Derivation-functions.html)**\n\nRandom RE May 12, 2018\n\n### May 12, 2018\n\n Three functions come up a lot when you are trying to write scripts to decode out malware strings or configs, this is me dumping my notes on these functions.\n\n So you have a .NET script using PasswordDeriveBytes? Or well really you have anything doing a routine on data. So what do you do? Well if the routine is semi complicated or I haven’t run upon it before then I will commonly let the malware take the data and then right as it’s passed off to the function in question I will force the data to be dumped out in all stages.\n\n What does this mean? It means if I want to recreate how PasswordDeriveBytes works then I just simply need to pass the same values to it and dump the bytes out to a file on disk using a different script.\n```\nnamespace PassDeriveTest\n{\n  class Program\n  {\n     static string bleh = \"B5YDTLEDBjd+8zy5lzEfjw==\";\n     public static string S(string C_0)\n       {\n          string strPassword = \"amp4Z0wpKzJ5Cg0GDT5sJD0sMw0IDAsaGQ1Afik6NwXr6rrSEQE=\";\n          string s = \"aGQ1Afik6NampDT5sJEQE4Z0wpsMw0IDAD06rrSswXrKzJ5Cg0G=\";\n          string strHashName = \"SHA1\";\n          int iterations = 2;\n          int num = 256;\n          string s2 = \"@1B2c3D4e5F6g7H8\";\n          byte[] bytes = System.Text.Encoding.ASCII.GetBytes(s2);\n          byte[] bytes2 = System.Text.Encoding.ASCII.GetBytes(s);\n          byte[] array = System.Convert.FromBase64String(C_0);\n          System.Security.Cryptography.PasswordDeriveBytes passwordDeriveBytes = new\nSystem.Security.Cryptography.PasswordDeriveBytes(strPassword, bytes2, strHashName, iterations);\n          byte[] bytes3 = passwordDeriveBytes.GetBytes(num / 8);\n          File.WriteAllBytes(\"keydata.bin\", bytes3);\n          System.Security.Cryptography.ICryptoTransform transform = new\nSystem.Security.Cryptography.RijndaelManaged\n          {\n            Mode = System.Security.Cryptography.CipherMode.CBC\n          }.CreateDecryptor(bytes3, bytes);\n          System.IO.MemoryStream memoryStream = new System.IO.MemoryStream(array);\n          System.Security.Cryptography.CryptoStream cryptoStream = new\nSystem.Security.Cryptography.CryptoStream(memoryStream, transform,\nSystem.Security.Cryptography.CryptoStreamMode.Read);\n          byte[] array2 = new byte[array.Length];\n          int count = cryptoStream.Read(array2, 0, array2.Length);\n          memoryStream.Close();\n          cryptoStream.Close();\n          return System.Text.Encoding.UTF8.GetString(array2, 0, count);\n       }\n     static void Main()\n     {\n          string blah = S(bleh);\n          Console.Write(blah);\n     }\n  }\n}\n\n```\n\n-----\n\n### So I m writing the bytes out to a file keydata.bin while at the same time going ahead and decrypting the string, now I know exactly what the bytes used for the AES key will be which were generated from PasswordDeriveBytes. While I’m at it I can go ahead and change the iterations to 1 and output the edge case of what happens when iterations is 1 for generating the bytes, as it turns out it generates the same bytes as iterations being 2.\n\n So now with this data we can attempt to recreate the routine in python and verify if we are in fact generating the same bytes for atleast this case. Generating the data we will need for other cases will be done in a similar manner but sometimes may involve doing things such as letting the malware call a function like CryptDeriveKey and then overwriting the bytecode in the malware itself to call an export function to dump the key into memory. Like most cyber security professions getting better at reverse engineering will usually come down to time, reading specifications and reference materials, testing or rolling your own routines/algorithms. If I want to understand how something works or how to identify it when I’m staring at disassembly then I find it much easier if I’ve already spent the time developing the routine or rolling my own cryto or using someones crypto library and then staring at it disassembled. It’s far from glamorous but some of my most interesting research has involved staring at RFCs for months.\n\n## .NET PasswordDeriveBytes\n\n### Based on PBKDF1, however PBKDF1 doens’t allow for generated bytes to exceed the hash length. Microsofts PasswordDeriveBytes however will reuse the hash before last on the iterations in order to generate more bytes in a stream.\n\n It does this by reusing the last hash from the iteration and prepending an integer to it stringified starting at 1 and going until it has satisfied enough bytes for the requested stream.\n```\nimport hashlib\nfrom base64 import b64decode\ndef MS_PasswordDeriveBytes(pstring, salt, hashfunc, iterations, keylen):\n  if iterations > 0:\n    lasthash = hashlib.sha1(pstring+salt).digest()\n    iterations -= 1\n  else:\n    print(\"Iterations must be > 0\")\n  #If iterations is 1 then basically the same thing happens as 2 based on my testing\n  #if iterations == 0 and keylen > len(lasthash):\n    #print(\"Dunno what happens here\")\n    #return -1\n  for i in range(iterations-1):\n    lasthash = hashlib.sha1(lasthash)\n  bytes = hashlib.sha1(lasthash).digest()\n  ctrl = 1\n  while len(bytes) < keylen:\n    bytes += hashlib.sha1(str(ctrl)+lasthash).digest()\n    ctrl += 1\n  return(bytes[:keylen])\nstpass = 'amp4Z0wpKzJ5Cg0GDT5sJD0sMw0IDAsaGQ1Afik6NwXr6rrSEQE='\nslt = 'aGQ1Afik6NampDT5sJEQE4Z0wpsMw0IDAD06rrSswXrKzJ5Cg0G='\ninitv = '@1B2c3D4e5F6g7H8'\nenc_str = b64decode('B5YDTLEDBjd+8zy5lzEfjw==')\nderbytes = MS_PasswordDeriveBytes(stpass, slt, hashlib.sha1, iterations=2, keylen=32)\nderbytes\n'4\\x88m[\\tz\\x94\\x19x\\xd0\\xe3\\x8b\\x1b\\\\\\xa3)`tj^]d\\x87\\x11\\xb1,g\\xaa[:\\x8e\\xbf'\n\n## RFC2898DeriveBytes\n\n### This one uses PBKDF2, some simple python code for the pbkdf2 library: https://github.com/mitsuhiko/python-pbkdf2\n\n```\n\n-----\n\n```\np\nencrypted = \"ETHfIKGznueFOwZzWrIPuz81fI2+EyHoMzKFUJIPBGc=\"\nsalt = \"Ivan Medvedev\"\nblob = pbkdf2_bin(passwd, salt, keylen=32+16)\nkey = blob[:32]\niv = blob[32:]\nfrom Crypto.Cipher import AES\ndata = \"ETHfIKGznueFOwZzWrIPuz81fI2+EyHoMzKFUJIPBGc=\"\nimport base64\ntemp = base64.b64decode(data)\naes = AES.new(key, AES.MODE_CBC, iv)\n>>> aes.decrypt(temp)\n'A\\x00p\\x00p\\x00L\\x00a\\x00u\\x00n\\x00c\\x00h\\x00.\\x00e\\x00x\\x00e\\x00\\x06\\x06\\x06\\x06\\x06\\x06'\n>>> 'A\\x00p\\x00p\\x00L\\x00a\\x00u\\x00n\\x00c\\x00h\\x00.\\x00e\\x00x\\x00e\\x00'.decode('utf-16')\nu'AppLaunch.exe'\n\n## MS CryptoAPI CryptDeriveKey\n\n### As an example using RC4\n\n If I hash the string ‘test’ using any hash but let’s say md5\n\n And then derive an RC4 key passing 0x280011 as the flags\n\n Then the key is bit length of the flags value 0x280011 » 16 to get the number of bytes simply divide by 8 in this case 5 bytes of the resulting md5 hash will be used as the RC4 key\n>>> import hashlib\n>>> hashlib.md5('test').digest()\n\"\\t\\x8fk\\xcdF!\\xd3s\\xca\\xdeN\\x83&'\\xb4\\xf6\"\n>>> flags = 0x280011\n>>> hex(flags >> 16)\n'0x28'\n>>> 0x28/8\n5\n>>> hashlib.md5('test').digest()[:5]\n'\\t\\x8fk\\xcdF'\n>>> from Crypto.Cipher import ARC4\n>>> rc4 = ARC4.new(hashlib.md5('test').digest()[:5])\n>>> rc4.decrypt(encoded_data)\n\n Hope it helps.\n\n Thanks to @maciekkotowicz and @noottrak\n\n References: https://github.com/Microsoft/referencesource/blob/master/mscorlib/system/security/cryptography/passwordderivebytes.cs https://tools.ietf.org/html/rfc2898#section-5.1\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-05-12 - MS Crypto Derive Functions.pdf"
    ],
    "report_names": [
        "2018-05-12 - MS Crypto Derive Functions.pdf"
    ],
    "threat_actors": [
        {
            "id": "e3492534-85a6-4c87-a754-5ae4a56d7c8c",
            "created_at": "2022-10-25T15:50:23.819113Z",
            "updated_at": "2025-03-27T02:00:55.552554Z",
            "deleted_at": null,
            "main_name": "Threat Group-3390",
            "aliases": [
                "Threat Group-3390",
                "Earth Smilodon",
                "TG-3390",
                "Emissary Panda",
                "BRONZE UNION",
                "APT27",
                "Iron Tiger",
                "LuckyMouse"
            ],
            "source_name": "MITRE:Threat Group-3390",
            "tools": [
                "Systeminfo",
                "gsecdump",
                "PlugX",
                "ASPXSpy",
                "Cobalt Strike",
                "Mimikatz",
                "Impacket",
                "gh0st RAT",
                "certutil",
                "China Chopper",
                "HTTPBrowser",
                "Tasklist",
                "netstat",
                "SysUpdate",
                "HyperBro",
                "ZxShell",
                "RCSession",
                "ipconfig",
                "Clambling",
                "pwdump",
                "NBTscan",
                "Pandora",
                "Windows Credential Editor"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "c63ab035-f9f2-4723-959b-97a7b98b5942",
            "created_at": "2023-01-06T13:46:38.298354Z",
            "updated_at": "2025-03-27T02:00:02.798255Z",
            "deleted_at": null,
            "main_name": "APT27",
            "aliases": [
                "TG-3390",
                "EMISSARY PANDA",
                "TEMP.Hippo",
                "Budworm",
                "Group 35",
                "BRONZE UNION",
                "Lucky Mouse",
                "Iron Taurus",
                "GreedyTaotie",
                "Red Phoenix",
                "ZipToken",
                "Iron Tiger",
                "G0027",
                "Earth Smilodon"
            ],
            "source_name": "MISPGALAXY:APT27",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "5c13338b-eaed-429a-9437-f5015aa98276",
            "created_at": "2022-10-25T16:07:23.582715Z",
            "updated_at": "2025-03-27T02:02:09.875151Z",
            "deleted_at": null,
            "main_name": "Emissary Panda",
            "aliases": [
                "APT 27",
                "ATK 15",
                "Bronze Union",
                "Budworm",
                "Earth Smilodon",
                "Emissary Panda",
                "Group 35",
                "Iron Taurus",
                "Iron Tiger",
                "LuckyMouse",
                "Operation DRBControl",
                "Operation Iron Tiger",
                "Operation PZChao",
                "Operation SpoiledLegacy",
                "Operation StealthyTrident",
                "Red Phoenix",
                "TEMP.Hippo",
                "TG-3390",
                "ZipToken"
            ],
            "source_name": "ETDA:Emissary Panda",
            "tools": [
                "ASPXSpy",
                "ASPXTool",
                "Agent.dhwf",
                "AngryRebel",
                "Antak",
                "CHINACHOPPER",
                "China Chopper",
                "Destroy RAT",
                "DestroyRAT",
                "FOCUSFJORD",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HTTPBrowser",
                "HTran",
                "HUC Packet Transmit Tool",
                "HighShell",
                "HttpBrowser RAT",
                "HttpDump",
                "HyperBro",
                "HyperSSL",
                "HyperShell",
                "Kaba",
                "Korplug",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Mimikatz",
                "Moudour",
                "Mydoor",
                "Nishang",
                "OwaAuth",
                "PCRat",
                "PlugX",
                "ProcDump",
                "PsExec",
                "RedDelta",
                "SEASHARPEE",
                "Sensocode",
                "SinoChopper",
                "Sogu",
                "SysUpdate",
                "TIGERPLUG",
                "TVT",
                "Thoper",
                "Token Control",
                "TokenControl",
                "TwoFace",
                "WCE",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "Xamtrav",
                "ZXShell",
                "gsecdump",
                "luckyowa"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535645,
    "ts_updated_at": 1743041127,
    "ts_creation_date": 1653760652,
    "ts_modification_date": 1653760652,
    "files": {
        "pdf": "https://archive.orkl.eu/47537e82163fd58226de23b23a1bd7fe4638ad92.pdf",
        "text": "https://archive.orkl.eu/47537e82163fd58226de23b23a1bd7fe4638ad92.txt",
        "img": "https://archive.orkl.eu/47537e82163fd58226de23b23a1bd7fe4638ad92.jpg"
    }
}