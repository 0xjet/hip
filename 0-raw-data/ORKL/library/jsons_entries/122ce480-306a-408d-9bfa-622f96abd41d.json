{
    "id": "122ce480-306a-408d-9bfa-622f96abd41d",
    "created_at": "2023-01-12T15:06:54.13177Z",
    "updated_at": "2025-03-27T02:05:34.720713Z",
    "deleted_at": null,
    "sha1_hash": "ccc2ea99249c375189eb05693cbca8e707aa8ba5",
    "title": "2021-08-05 - Analysis of the BlackMatter ransomware",
    "authors": "",
    "file_creation_date": "2022-05-28T18:22:37Z",
    "file_modification_date": "2022-05-28T18:22:37Z",
    "file_size": 588441,
    "plain_text": "# Analysis of the BlackMatter ransomware\n\n**[tesorion.nl/en/posts/analysis-of-the-blackmatter-ransomware/](https://www.tesorion.nl/en/posts/analysis-of-the-blackmatter-ransomware/)**\n\nBy Gijs Rijnders August 5, 2021\n\nIn late July, [BleepingComputer stated that the notorious DarkSide ransomware gang has](https://www.bleepingcomputer.com/news/security/darkside-ransomware-gang-returns-as-new-blackmatter-operation/)\nrebranded as BlackMatter. DarkSide disappeared after the high-profile attack on Colonial\nPipeline this year, but they seem to be back under a new name.\n\n[We recently came across a sample of the BlackMatter ransomware, posted by GrujaRS. As](https://twitter.com/grujars/status/1421780825490837504?s=21)\nnot yet much information is available on this ransomware, we decided to write about its\ninner workings and technical details. As expected, we found some similarities between\n[DarkSide and BlackMatter.](https://chuongdong.com/reverse%20engineering/2021/05/06/DarksideRansomware/)\n\nBlackMatter employs slight obfuscation such as dynamic API resolving and basic string\nencryption mechanisms. In this blog, we will give a general overview of the ransomware.\nFurthermore, we will discuss the obfuscations, as well as the file encryption and some other\ndetails.\n\n## Overview\n\n\n-----\n\nThe BlackMatter ransomware sample we analyzed is a 32-bit Windows executable. Files\nencrypted by it get the extension: ‘.5rzS1NTSv’, and the ransom note as shown is\ndisplayed to the user.\n\nLike many ransomwares do, BlackMatter also creates a mutex upon startup to prevent\nmultiple instances from running in parallel. In the upcoming sections, we will discuss\nseveral aspects of the ransomware in detail.\n\n### Dynamic Win32 API resolving\n\nA common practice to avoid disclosing information about a malware’s behavior is to\nresolve Win32 API function addresses at runtime. This way, function names are not\nvisible in the Import Address Table (IAT) of the binary, and static analysis tools cannot\ngain information from those. BlackMatter also employs this dynamic Win32 API resolving.\nIt resolves the addresses of functions it uses first after starting. In the screenshot below,\nwe see that it first resolves the HeapCreate and HeapAlloc functions, and proceeds to\nload functions from more than 10 different libraries.\n\n\n-----\n\nIf we zoom in on the ‘decrypt_and_resolve_funcs’ function, we find that it decrypts and\nresolves multiple hashes from a given block. BlackMatter contains a block of encrypted\nhashes for each library it requires functions from, followed by a trailing 0xCCCCCCCC.\nEach encrypted hash is first decrypted by a 32-bit XOR with key: 0x22065FED. After\ndecryption, the hash is resolved. The hash of a function name is computed using two\nsimilar hash functions H and H, where H computes the hash of a Unicode library0 1 0\nname (including NULL terminator) and H computes the hash of an ASCII function name1\n(including NULL terminator). The two hash functions, both performing ROR-13\noperations, are given in the screenshot below.\n\nThe hash for a function name is then computed by first calling x = H for the library name.0\nThe initial value for this hash is zero. To compute the final hash, H is then called using1\n‘x’ as the initial value.\n\n\n-----\n\nFor each Win32 API function it resolves, BlackMatter manually creates a so called call\nstub’ for the function. This stub is a small block of Assembly code that proxies or relays\nan API function call. Sometimes a call stub solely jumps to the required API function, but\nin other cases it performs some additional operations such as decryption or decoding. In\nthe screenshot below, we see that after resolving ‘func_addr’, the call stub is created.\n\nWhen an API function is called, the call stub is called instead. The actual function\naddress remains encrypted in memory, and the call stub decrypts it before relaying the\ncall. As we can see in the screenshot below, the call stub is quite simple. It decrypts the\nfunction address using the same 32-bit XOR we previously encountered. The value\n0xDEADBEEF in the screenshot is a placeholder for the actual API function address.\n\n### String encryption\n\nString encryption is commonly employed in malware to thwart static analysis.\nBlackMatter also employs a simple string encryption algorithm, like what was used for\nAPI resolving. Throughout the code, encrypted strings are constructed on the stack by\nDWORDs instead of characters. The resulting buffers are decrypted inline using a simple\nXOR. The string decryption algorithm is given in the screenshot below.\n\n\n-----\n\n### Obtaining the configuration\n\nBlackMatter also contains an embedded configuration, and it is encoded in a similar way\nDarkSide encoded theirs. In this case, the configuration is located in the “.rsrc” segment.\nThe configuration starts with a 32-bit initial state value for the decryption algorithm. In this\ncase, this value is 0xFFCAA1EA. A DWORD indicating the size is next, followed by the\nencrypted configuration. The decryption algorithm is shown in the screenshot below and\nis based on a slightly customized linear congruential generator.\n\n[The decrypted content is then decompressed using the aPlib algorithm. The decrypted](https://github.com/snemes/aplib)\nand decompressed configuration starts with an RSA-1024 public key. Furthermore, the\nconfiguration includes a few Base64-encoded strings that contain:\n\nCommand & control hostnames\nAES-128 encryption key for command & control\nNames of services to kill\nFile and directories to avoid\nRansom note (also encrypted with the algorithm above)\n\n\n-----\n\n### File encryption\n\nNaturally, we want to know how the file encryption process works in the BlackMatter\nransomware. Like DarkSide, the BlackMatter ransomware first kills blacklisted processes\nand services, empties the recycle bins for all drives, and deletes shadow copies. It then\nfinds files on the filesystem to encrypt.\n\n[The file encryption process is set up using I/O completion ports. These completion ports](https://docs.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports)\nprovide an efficient model for handling many concurrent I/O operations on a system with\nmultiple CPUs. An I/O completion port is created with a given number of threads using\nthe CreateIoCompletionPort function. After creation, a queue is created internally, to\nwhich threads can push completion statuses. One can queue a status using the\nPostQueuedCompletionStatus function, and a thread can pull this status from the queue\nusing the GetQueuedCompletionStatus function.\n\nA user-defined data context structure can be attached to a status to keep track of\nvariables during encryption if its first member is an OVERLAPPED structure. Using the\ncompletion status queue, a control flow of I/O actions can be constructed. The file\nencryption function in the BlackMatter ransomware uses the state numbers 0 to 3 to\ncreate a control flow. This control flow is shown in the screenshot below.\n\n\n-----\n\nAs we can see, the encryption starts with a zero: read the next data block from the file.\nThe status then switches to 1: encrypting the block of data previously read and writing it\nback to the file. The file footer is written when the status is set to 2, and when all I/O\ntasks have been completed, the encryption is finished with status number 3.\n\nThe user-defined context structure is created in the screenshot below. It contains for\nexample the number of bytes to encrypt in a file. If the file is smaller than 1MiB, the entire\nfile is encrypted. If the file is larger, the first 1MiB is encrypted.\n\n\n-----\n\nFiles are encrypted using the Salsa20 stream cipher algorithm, and the corresponding\nkeys are encrypted using RSA-1024. If we zoom in on the ‘inits_salsa20_state’ function,\nwe find that the Salsa20 matrix is initialized at random without a key and nonce. In the\nscreenshot below, the matrix is constructed using 8-byte random values. The nonce is\nleft at zero.\n\nBlackMatter first checks whether the CPU inside the victim’s system supports the\nRDRAND instruction. If so, the next random number is generated by combining two calls\nto this instruction. If the victim’s CPU does not support RDRAND, the CPU timestamp\ncounter is used instead. The next random number is then constructed by combining the\nlower 32 bits of two timestamp counters. One is rolled 13 bits to the left, and one 13 bits\nto the right. The screenshot below shows how these random numbers are generated.\n\n\n-----\n\nThe random Salsa20 matrix is encrypted with the RSA-1024 public key included in the\nconfiguration and written to the footer in the encrypted file. The footer contains some\nmore information about the file, such as its original size and a magic value that allows\nBlackMatter to identify already encrypted files. The file encryption process is also quite\nlike DarkSide’s.\n\n### Command & control\n\nBlackMatter contacts command & control hosts to collect information about the victim.\nThe hostnames it contacts are stored in the embedded configuration we previously\ndiscussed. BlackMatter first attempts to contact the command & control hosts using\nHTTPS and falls back to HTTP if it fails. The sent HTTP POST requests target a\nrandomly generated URI consisting of key/value pairs with characters from the Base64\nalphabet. The HTTP data associated to the requests also consists of similar key/value\npairs. The difference is: one of the pairs contains encrypted data.\n\n\n-----\n\nThe HTTP requests are facilitated by the WinInet library, including functions such as\nInternetOpenW, InternetConnectW and HttpSendRequestW. An interesting characteristic\nof the requests is the User-Agent header. BlackMatter contains multiple hardcoded user\nagents, from which it randomly selects one to use in its connections. The user agents are\nshorter than the default ones, as we can see in the screenshot below.\n\nAs we previously mentioned, the encrypted victim information is placed in one of the\nkey/value pairs in the HTTP POST data. The position of the pair in the string is randomly\ndetermined. We can determine which pair to decrypt by Base64-decoding each pair in\nthe data string and checking the size of the results. We attempt decryption on all pairs\nhaving a size aligned to a 16-byte boundary. The encryption algorithm used here is AES128 in ECB mode (independent block-by-block encryption). The key is placed in the\nconfiguration, starting 16 bytes after the RSA-1024 public key. In the sample we\nanalyzed, the key is (hex-encoded): A6F330B09CD47B4FB9214F7836AA46AD. After\ndecrypting, we get the following JSON object.\n\nAs we can see, we analyzed version 1.2 of BlackMatter. The object contains host and\nuser information, such as identifiers for the victim, computer name and username, and\navailable disk space on the infected system. The information in the JSON object is\n\n\n-----\n\nsimilar to what DarkSide sent to their command & control hosts, as they also collected\nsystem, user and disk information.\n\n## Conclusion\n\nIn this blog, we presented a detailed analysis of the BlackMatter ransomware. Others\nsuggested that BlackMatter is a rebrand of the DarkSide ransomware, and the code\nsimilarities we found support this suggestion. The sample is available for download at\n[MalwareBazaar.](https://bazaar.abuse.ch/sample/22d7d67c3af10b1a37f277ebabe2d1eb4fd25afbd6437d4377400e148bcc08d6/)\n\n## Indicators of Compromise (IoCs)\n\n**Indicator** **Description**\n\n22d7d67c3af10b1a37f277ebabe2d1eb4fd25afbd6437d4377400e148bcc08d6 BlackMatter\nransomware\n\npaymenthacks[.]com C2\n\nmojobiden[.]com C2\n\n[© 2022 Tesorion Cybersecurity Solutions. All Rights Reserved. | RSS NL |](https://www.tesorion.nl/nl/feed/) [RSS EN](https://www.tesorion.nl/en/feed/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-08-05 - Analysis of the BlackMatter ransomware.pdf"
    ],
    "report_names": [
        "2021-08-05 - Analysis of the BlackMatter ransomware.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536014,
    "ts_updated_at": 1743041134,
    "ts_creation_date": 1653762157,
    "ts_modification_date": 1653762157,
    "files": {
        "pdf": "https://archive.orkl.eu/ccc2ea99249c375189eb05693cbca8e707aa8ba5.pdf",
        "text": "https://archive.orkl.eu/ccc2ea99249c375189eb05693cbca8e707aa8ba5.txt",
        "img": "https://archive.orkl.eu/ccc2ea99249c375189eb05693cbca8e707aa8ba5.jpg"
    }
}