{
    "id": "e099a472-d76a-4750-90e5-cbfd9c80709f",
    "created_at": "2023-01-12T15:02:58.875169Z",
    "updated_at": "2025-03-27T02:12:11.149324Z",
    "deleted_at": null,
    "sha1_hash": "5c2d651590a7b63fcbc986cc339e1fa48ce17552",
    "title": "2019-10-23 - Spoofing in the reeds with Rietspoof",
    "authors": "",
    "file_creation_date": "2022-05-26T02:01:35Z",
    "file_modification_date": "2022-05-26T02:01:35Z",
    "file_size": 1046514,
    "plain_text": "# VB2019 paper: Spoofing in the reeds with Rietspoof\n\n**[virusbulletin.com/virusbulletin/2020/01/vb2019-paper-spoofing-reeds-rietspoof](https://www.virusbulletin.com/virusbulletin/2020/01/vb2019-paper-spoofing-reeds-rietspoof/)**\n\n### Jan Sirmer, Luigino Camastra & Adolf Středa\n\n_Avast Software, Czech Republic_\n\nTable of contents\n\n## Abstract\n\nSince August 2018 we have been monitoring a new malware family, which we have named\nRietspoof. Rietspoof is a piece of malware that is multi-staged, using different file types\nthroughout its infection chain. It contains several types of stages – both extractors and\ndownloaders; the fourth stage also contains support for remote-control commands. When we\nbegan tracking Rietspoof it was being updated approximately once a month. However, in\nJanuary 2019 we noticed that the frequency of updates had increased to daily.\n\nIn this paper we will share a detailed analysis of each stage of the malware, starting from the\ninitial Microsoft Word document serving as stage one. This stage is followed by a rather\ninterestingly built and obfuscated Visual Basic script (VBS) leading to executable files that\nserve as both bots and downloaders. We will describe all relevant parts of the Visual Basic\nscript, ranging from its unusual anti-behaviour detection tricks to the function which led us\nto the next stage, a CAB file dropped from the VBS.\n\nThe fourth stage is an executable file expanded from the CAB file. This executable file is\ndigitally signed by a valid certificate, usually using Comodo CA. At the end of February, we\nfound samples exhibiting different behaviour: a new VBS file with bot capabilities was\ndropped from the CAB file. The fourth stage serves as a bot that also supports a downloader\nfunctionality. During our investigation, we noticed that the malware author was constantly\nmodifying all the stages. We distilled these changes into a detailed timeline, from which we\ncan observe a lot of changes in the whole concept of this malware family, ranging from a\nreworked C&C communication protocol to a completely rewritten second stage.\n\nIn the fifth stage, the malware author used an interesting dropper technique to deploy fileless\nmalware downloaded from the C&C server. The fifth stage utilized the NTLM protocol to\nprovide authentication and encryption of its communication with the C&C server.\n\nIt is not common to see a C&C communication protocol being modified to such an extent,\ngiven the level of effort required to change it. Similarly, we rarely see feature regression in\nmalware – we observed that the obfuscation of strings was removed in later versions of the\n\n\n-----\n\nfourth stage. Again, we will look at these changes in detail along with the underlying\nprotocols.\n\nAlthough we are monitoring Rietspoof very carefully, our hypothesis is that its authors are\nstill developing this malware, and because of this we only have testing samples.\n\n## Introduction\n\nRietspoof utilizes several stages, combining various file formats throughout its infection\nchain to deliver a potentially more versatile piece of malware. Our data suggests that the first\nstage was delivered through email and instant messaging clients such as Outlook and Skype.\nThe first stage consists of a Microsoft Word document which works as a dropper and runner\nfor a highly obfuscated Visual Basic script containing an encrypted and hard-coded\nencrypted CAB file – the third stage. The Visual Basic script is also digitally signed. The CAB\nfile is expanded into an executable that is digitally signed with a valid signature, generally\nusing Comodo CA or Sectigo RSA. The executable file downloads and installs a downloader\nin stage 4.\n\nWhat’s interesting to note is that the fourth stage uses a simple TCP protocol to communicate\nwith its C&C, whose IP address is hard coded in the binary. The protocol is encrypted by AES\nin CBC mode. In one version we observed the key being derived from the initial handshake.\nLater on, a second version appeared; in this case the key is derived from a hard-coded string.\nIn version two, the protocol not only supports its own protocol running over TCP, but it also\ntries to leverage HTTP/HTTPS requests. It is rather uncommon to see a C&C communication\nprotocol being modified to such an extent, given the level of effort required to change it.\nWhile it is common to change obfuscation methods, the C&C communication protocol\nusually remains relatively unmodified in most malware.\n\nThis downloader uses a home-brew protocol to retrieve another stage (stage 5) from a hardcoded address. While the stage 4 protocol includes bot capabilities, stage 5 acts as a\ndesignated downloader only.\n\n## Stage 1: Microsoft Word document\n\nThe first stage of the Rietspoof attack is a malformed Microsoft Word document which is\nspread through email or instant messaging clients. The first stage works as a dropper and\nrunner for a malicious Visual Basic script.\n\nThe document uses standard social engineering techniques to persuade victims to run it with\nmacros enabled.\n\n\n-----\n\nFigure 1: Social engineering.\n\nOnce macros are enabled, the information regarding the protected document is deleted and\nthe title ‘Emergency exit map’ is shown.\n\nFigure 2: Emergency exit map.\n\nThe attackers use a simple method in which they delete HeaderFooters and show the hidden\ntext.\n\nFigure 3: DeleteAllHeaderFooters.\n\n\n-----\n\nFigure 4: ShowHiddenText.\n\nAfterwards, the script deobfuscates the VBS and saves it onto the machine. The script is then\nexecuted by invoking wscript.exe with a parameter\nc:\\users\\NAME\\appdata\\roaming\\microsoft\\word\\startup\\.\\.\\\\Windows\\Cookies\\wordTemplate.vbs,\nwhich is a path leading to the dropped VBS.\n\nThe raw Visual Basic script is stored as a Base64-encoded string represented by an array of\nhex codes.\n\nFigure 5: Execution flow.\n\n## Stage 2: Visual Basic script\n\n\n-----\n\n### Timeline of development\n\n**First version: 7 August 2018**\n\nThe first version of the VBS that we discovered was probably just a test version of Rietspoof\nas it contained almost no obfuscation. Also, the names of variables and functions correlate\nwith their final functions.\n\nFigure 6: Self explanatory names.\n\nSince version one, each version has been more or less obfuscated and has used different\nbinaryOffset (offset of payload), xorValue (XOR key) and AppName (dropped binary name)\nvalues. Nevertheless, all of them – at least until our blog post [1] was released – showed\nmany similarities.\n\n**Visual Basic functionality**\n\nThe first part of the Visual Basic script is a function for reading and deobfuscating embedded\nbinaries.\n\nFigure 7: Script reads itself from setup offset.\n\nFrom the snippet shown in Figure 7 it is immediately obvious that the script starts reading\ncode at a specific offset, deobfuscating the CAB file and readying it for the next stage. The\ncode is converted, character by character, to its ANSI value and added to the counter\nvariable. At every step, the counter is XOR’ed with val_01 (hard coded to 15) and appended\nto already decoded bytes. Interestingly, at every step, the string var_str_01 is also appended\nto var_str_02.\n\n\n-----\n\nFigure 8: CAB deobfuscation.\n\nAfter this step, var_str_02 is used as a parameter for a new function. The second parameter\nis TempPath, with the following filename:\n\nFigure 9: Dropper function.\n\nFigure 10: Drop CAB file.\n\nAt this stage the CAB file is saved to the machine’s TempPath under the name\nJSWdhndk.sjk. If we observed one the first versions, the name would be data.log instead.\nThe following stage needs to be extracted from it, which is accomplished by using\nexpand.exe, as shown in Figure 11.\n\nFigure 11: Expand CAB file.\n\n### Executing PE and covering tracks\n\n\n-----\n\nThe script checks if the user is logged in as admin by reading the registry key\n“HKEY_USERS\\S-1-5-19\\Environment\\TEMP”. In case of success, it sets\nfunc_read_Registry to True.\n\nFigure 12: Checking if the victim is logged in as admin.\n\nNote that S-1-5-19 belongs to NT Authority and can be accessed only by an admin (as noted\nin the Microsoft documentation [2]).\n\nWhen this flag is set to True, the VBS changes the date to 01-01-2109. Again, the first version\nexhibited slightly different behaviour, using the date 01-01-2099. We can assume this is done\nto confuse some sandboxes or other behaviour-based detection systems and that the first\ndate didn’t work as intended. The interim date with the year 2109(2099) serves only this\npurpose as it is not used in any further stage and is reverted once the next stage is\ndispatched.\n\nAfterwards, as the CAB file has already been expanded, it is deleted from %TEMP%. The\nexpanded executable file is run, and the original script is deleted to cover its tracks. Finally,\nthe date is changed back to the current date.\n\nFigure 13: Spawning more command lines.\n\nAn interesting move by the malware authors is to use cmd /c to run commands from the\ncommand line, as shown in Figure 13. This is most likely an attempt to break behavioural\ndetections by recursively spawning new command line instances.\n\nEven if the previous step is skipped and the current user is not the admin, the next step is to\nrun the expanded PE file. First, the script deletes a scheduled task, Microsoft Windows DOM\nobject helper. This is done to ensure that a new task in the scheduler, pointing to the\n\n\n-----\n\nexpanded PE file, will execute after exactly one minute. Once the task is scheduled, the\nmalware will try to cover its tracks again by deleting the CAB file from the %TEMP%\ndirectory.\n\nFigure 14: Creating schtask job.\n\n**Adding persistence**\n\nIn the new version of the VBS a new function for securing persistence was added, starting on\n22 January 2019. The script creates a new LNK file in Startup with the name\nWindowsUpdate.lnk. This LNK file runs the expanded PE file after startup to ensure the\nexecutable will be run after reboot.\n\nFigure 15: A LNK file is created to add persistence.\n\n**Digital signature**\n\nAll the Visual Basic scripts were digitally signed with a valid signature, which allows them to\nbe started even in protected environments such as a company network.\n\n\n-----\n\nFigure 16: Valid VBS digital signature.\n\nFigure 17: Valid VBS digital signature.\n\n### Reaction to our blog post\n\nOur blog post about the malware [1] was published on 16 February 2019. A few hours later,\nwe found the first completely redesigned Visual Basic script. The file size had been reduced\nto ~ 4-5KB and the script no longer contained a digital signature or any embedded file.\nInstead, the new VBS works as a bot that downloads and runs the next stage, and can also\ndelete itself on command.\n\nAt the beginning, information about the infected device (HW and ID info) is retrieved by the\nscript. A simple GET request with IP address, HW info and ID info as parameters is then\nused to establish communication with a C&C server.\n\n\n-----\n\nFigure 18: Get information about targeted device.\n\nFigure 19: Communication with C&C.\n\nAll IP addresses used in the scripts are hosted on hostings belonging to DigitalOcean, LLC.\n\nIf the d command is received from the C&C server, the VBS deletes itself, sleeps for a while\nand kills WScript.\n\nFigure 20: Delete command.\n\nIf the pr command is received, the script checks for two additional parameters: a URL and a\nfile name. The function then tries to download the file from the provided URL, saves the file\nand runs it afterwards.\n\nFigure 21: Download and run command.\n\n## Stage 3: CAB file\n\nThis stage was eliminated in the latest version of the malware. The CAB file was used to\nreduce the size of embedded code inside the VBS. The CAB format has several nice features,\ne.g. it can easily be unpacked on Windows out of the box without any additional tooling.\n\nAs mentioned previously, the CAB file is extracted into %TEMP% using expand.exe.\n\nFigure 22: CAB file expand.\n\n\n-----\n\n## Stage 4: Dropped bot\n\nWe have seen two versions of the fourth stage of Rietspoof so far. They differ mostly in terms\nof the communication protocol. This stage has the capabilities of a simple bot: it can\ndownload/upload files, start processes, or initiate a self-destruct function. The C&C server\nalso seems to have implemented basic geolocation based on IP address. We didn’t receive\nany ‘interesting’ commands when we tried to communicate with it from our lab network;\nhowever, when we moved our fake client (virtually) to the USA, we received a command\ncontaining the next stage.\n\nWe noticed that the development of this fourth stage is rapidly evolving, sometimes running\ntwo different branches at once. During our analysis, the communication protocol was\nmodified several times and other new features were added. For example, string obfuscation\nwas supported in earlier versions, implemented several days later, and then on 23 January\nwe saw samples that rolled back some of these changes. Newer versions also support the\ncommand line switch /s, used to install themselves as a service named windmhlp.\n\n### Timeline\n\n15 January: Obfuscation placeholders, communication protocol v1\n18 January: Implemented obfuscation, service installation, communication protocol v2\n22 January: Obfuscation scrapped, communication protocol v1\n23 January: Obfuscation scrapped, communication protocol v1, service installation\n\nIf either the bot is blocked by geolocation or there is currently no ongoing distribution, the\ncommunication has a simple structure:\n\nReq: client_hello (deprecated in version 2)\n\nRes: client_hello (deprecated in version 2)\n\nReq: ID\n\nRes: OK or HARDWARE\n\nReq: HW (if previous response was HARDWARE)\n\nRes: OK\n\nThe command HARDWARE is sent only if the sent client ID is seen for the first time. The\ncommand OK always results in termination of the communication. This simple protocol is\nexecuted periodically every several minutes.\n\n### Communication protocol v1\n\n\n-----\n\nThe first version of the fourth-stage communication uses a rather simplistic protocol. At first,\na key and initialization vector are generated by a handshake that consists of a message and a\nresponse, both 32 random bytes, and a four-byte CRC32 checksum. Afterwards, the random\nbytes are XOR’ed together, and applying SHA256 on the result yields the key. Similarly,\napplying MD5 on the SHA256 digest yields the initialization vector. From now on, these\nparameters are used to encrypt messages by AES-CBC. Note that the padding function is\nstrangely designed: the last block is padded to 16 bytes, if necessary, and another 16 zerobytes are always appended after the last block.\n\nFigure 23: Initial handshake and the subsequent key generation. Note that there is a check\nfor port selector in between these two blocks, which is not shown.\n\n\n-----\n\nFigure 24: String “HELLO\\n”, which is obfuscated and subsequently deobfuscated –\nobfuscation placeholder.\n\nThe communication starts with client_hello, a message simply containing “HELLO\\n” that\nexpects “HELLO\\n” as a reply (actually “HELLO\\n\\n\\n\\n\\n\\n…” was always the reply).\nThen, the client sends a command “ID:<MD5 of adapter MAC address>2.10\\n”. The\nresponse OK, HARDWARE, or a more powerful command is received. In the former, the\ncommunication ends and the communication loop sleeps for two to five minutes. The\nresponse HARDWARE induces the request “HW:<OS info> CPU<CPU info> RAM: <RAM\ninfo> USER: <process privileges>”, with process privileges being either ‘admin’ (the process\nhas administrator privileges) or ‘user’ (otherwise). Again, after this message the response OK\nis received, similarly ending the communication.\n\n\n-----\n\nFigure 25: Communication with C&C.\n\nOne of six alternative commands may follow instead of OK:\n\nDEL: Delete file, the filename is prefixed with the location of %TEMP%\n<filename>\n\nRUN: Create process with the file as lpCommandLine, the filename is prefixed with\n<filename> the location of %TEMP%\n\nDWN: Download a file, if the filename has the suffix .upgrade then dump VBS\n<filename> update script which replaces the malware with a newer version\n\nUPL: Upload file from %TEMP%\n<filename>\n\nDAR: Download, save to %TEMP%/<filename> and execute\n<filename>\n\nDSF:\\n Delete itself\n\n### Communication protocol v2\n\nThe second version of the fourth stage of Rietspoof also uses a rather similar protocol with a\nfew new additions. The second version tries to communicate over HTTP/HTTPS unless a\nproxy is set up, in which case it resorts to raw TCP. This new version also eschews the initial\nhandshake as it uses a hard-coded string, M9h5an8f8zTjnyTwQVh6hYBdYsMqHiAz, instead\nof XOR’ing two random strings. Again, this string is put through SHA256, yielding a key, and\nSHA256 composed with MD5, yielding an initialization vector. These parameters are used to\nencrypt messages by AES-CBC.\n\nFigure 26: Obfuscated “HELLO\\n” string.\n\n|DEL: <filename>|Delete file, the filename is prefixed with the location of %TEMP%|\n|---|---|\n|RUN: <filename>|Create process with the file as lpCommandLine, the filename is prefixed with the location of %TEMP%|\n|DWN: <filename>|Download a file, if the filename has the suffix .upgrade then dump VBS update script which replaces the malware with a newer version|\n|UPL: <filename>|Upload file from %TEMP%|\n|DAR: <filename>|Download, save to %TEMP%/<filename> and execute|\n|DSF:\\n|Delete itself|\n\n\n-----\n\nThe HTTP GET requests generated by the malware are more or less ordinary with the\nexception of three headers that may be present. An example of the HTTP request is below.\nNote that the Content‑MD5 header is not mandatory; moreover, the Content-MD5 header is\nused in a custom and standard non-compliant way. Also, the User-agent string is hard coded\nin the binary.\n```\nGET /<path>?<GET data> HTTP/1.1\nHost:<domain>\nConnection:close\nContent-MD5:<base64 encoded message>\nUser-agent:Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204\nFirefox/2.0.0.1\n\n```\nFortunately for us, the old protocol is still present for cases in which an HTTP proxy is used.\nWe believe that this may serve as a protection against trivial man-in-the-middle attacks that\ncould be utilized during analysis of the malware. However, in our case, it allows us to deploy\na new tracking script with very few modifications, as only the key agreement protocol has\nbeen changed.\n\n## Stage 5: Downloader\n\nThis stage tries to establish an authenticated channel through NTLM protocol over TCP with\nthe C&C server, the IP address of which is hard coded.\n\nFigure 27: Initiate NTLM authentication.\n\n\n-----\n\nFigure 28: Main authentication and communication loop.\n\nAfterwards, a communication with the C&C server over the aforementioned channel is\nestablished and two pipes are created.\n\nThe fileless process is created with the API function CreateProcessW. This API function’s\nattributes are filled with command line cmd and special structure StartupInfo.\n\nThe attribute StartupInfo.hStdInput, a standard input handle for the created process, has the\nhandle of the first pipe’s ReadPipe assigned. StartupInfo.hStdOutput and\nStartupInfo.hStdError, corresponding to the standard output handle and standard error\noutput handle, have the handle of the second pipe’s WritePipe assigned. This allows the\ndownloader to execute the next payload filelessly.\n\n\n-----\n\nFigure 29: A process is created from the first pipe.\n\nTherefore, the received data from the C&C server is written to the first pipe. This data is then\nread from the second pipe, which sends it back to the C&C server.\n\n\n-----\n\nFigure 30: Received data is written to the first pipe and read from the second pipe.\n\nFigure 31: Data is read from the second pipe, which sends it back to the C&C server.\n\n## Conclusion\n\nThe Rietspoof family was discovered in August 2018 and saw a significant increase in its\nactivity during January 2019. During this time, the developer has used several valid and\ntrusted certificates to sign related files. The payloads have also gone through rather rapid\n\n\n-----\n\ndevelopment, namely the implementation of the stage 4 communication protocol has been\nchanged several times. While the data on Rietspoof is extensive, motives and modus\noperandi are still unknown, as are the intended targets.\n\nFrom the reaction of Rietspoof’s authors to our blog post and posts on Twitter we can\nconjecture that they are monitoring security companies, or at least Twitter, as they\ncompletely changed the design and infection chain just the day after our blog post was\nreleased.\n\nOur research hasn’t revealed whether we’ve uncovered the entire infection chain. Even\nthough there are stages with bot capabilities, they seem to have primarily been designed as\ndroppers. Additionally, the low prevalence and use of geolocation presents other possible\nunknowns. For instance, we may have missed other samples that are distributed only to a\nspecific IP address range.\n\n## References\n\n[1] Camastra, L.; Širmer, J.; Streda, A.; Obrdlík, L. We’re tracking a new cyberthreat that\ncombines file formats to create a more versatile malware. https://blog.avast.com/rietspoofmalware-increases-activity.\n\n[2] Well-known security identifiers in Windows operating systems.\nhttps://support.microsoft.com/en-us/help/243330/well-known-security-identifiers-inwindows-operating-systems.\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order\nto infiltrate organizations’ dedicated environments and transform them into attack\nlaunchpads. In this article Aditya Sood presents a new module introduced by…\n\n### Collector-stealer: a Russian origin credential and information extractor\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to\nexfiltrate sensitive data from end-user systems and store it in its C&C panels. In this article,\nresearchers Aditya K Sood and Rohit Chaturvedi present a 360…\n\n\n-----\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and\nfrom that moment onward, was intrigued by the properties of these small pieces of selfreplicating code. Joe Wells was an expert on computer viruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\nKurt Natvig wanted to understand whether it’s possible to recompile VBA macros to another\nlanguage, which could then easily be ‘run’ on any gateway, thus revealing a sample’s true\nnature in a safe manner. In this article he explains how he recompiled…\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware,\ndiscussing his team's findings related to the C&C design and some security issues they\nidentified during the research.\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-10-23 - Spoofing in the reeds with Rietspoof.pdf"
    ],
    "report_names": [
        "2019-10-23 - Spoofing in the reeds with Rietspoof.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535778,
    "ts_updated_at": 1743041531,
    "ts_creation_date": 1653530495,
    "ts_modification_date": 1653530495,
    "files": {
        "pdf": "https://archive.orkl.eu/5c2d651590a7b63fcbc986cc339e1fa48ce17552.pdf",
        "text": "https://archive.orkl.eu/5c2d651590a7b63fcbc986cc339e1fa48ce17552.txt",
        "img": "https://archive.orkl.eu/5c2d651590a7b63fcbc986cc339e1fa48ce17552.jpg"
    }
}