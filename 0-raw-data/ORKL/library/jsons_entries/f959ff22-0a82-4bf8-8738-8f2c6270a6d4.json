{
    "id": "f959ff22-0a82-4bf8-8738-8f2c6270a6d4",
    "created_at": "2022-10-25T16:48:18.310958Z",
    "updated_at": "2025-03-27T02:05:59.969336Z",
    "deleted_at": null,
    "sha1_hash": "6985858274b3af283ca285fd67c70d651f05f445",
    "title": "Unflattening ConfuserEx .NET Code in IDA",
    "authors": "",
    "file_creation_date": "2022-09-16T08:03:29Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 370717,
    "plain_text": "##### 2022-09-16\n\n# Unflattening ConfuserEx .NET Code in IDA\n\n### NCSC • GovCERT.ch\n\n\nSchweizerische Eidgenossenschaft\nConfédération suisse\nConfederazione Svizzera\nConfederaziun svizra\n\n\nEidgenössisches Finanzdepartement EFD\n**Nationales Zentrum für Cybersicherheit NCSC**\nGovCERT.ch\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\n## Contents\n\nInitial Unpacking and Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\nCode Flattening After Decompilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\nAnalysis of Code Flattening in CIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\nCaveat: Fragmentation of State Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\nCaveat: Non-Linear Code Fragments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\nCaveat: More Than One switch in a Function . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\nCaveat: Shared Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\nCaveat: Inconsistent State Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\nParsing and Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\nMain Parsing Loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\nDetection of the Suffix Code Type and Extraction of the Constants (find_suffix function) 15\nEmulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\nPatching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\nCIL Branch Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\nAvoiding Overwriting Real Code When Patching . . . . . . . . . . . . . . . . . . . . . . . . . . 24\nResults and Lookout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n\nNCSC • GovCERT.ch **1**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\n[This paper refers to a Ginzo sample, which can be downloaded from MalwareBazaar using MD5](https://malpedia.caad.fkie.fraunhofer.de/details/win.ginzo)\n[5009e04920d5fb95f8a02265f89d25a5. Ginzo is an information stealer written in .NET, known to also](https://bazaar.abuse.ch/sample/3fd0837381babda7ef617b810457f0db32bd7c1f7e345480e6c525050ca818fa/)\nsteal cryptocurrency keys. However, we are not focusing on the malware itself, but instead have a closer\nlook on one of it’s ConfuserEx[1] obfuscation technique.\n\n#### Initial Unpacking and Motivation\n\nThe sample has a first simple encryption layer that can be unwrapped by using dnSpy as a debugger,\ndumping the decrypted code to disk (e.g. using x64dbg), and patching the new code section back into the\noriginal sample. The resulting code still has long class/function names and flattened code, so the next\nusual step to try in such situations is to run de4dot[2] on it:\n```\n de4dot v3.1.41592.3405 Copyright (C) 2011-2015 de4dot@gmail.com\n Latest version and source code: https://github.com/0xd4d/de4dot\n Detected Unknown Obfuscator (.../ginzo-patched.exe)\n Cleaning .../ginzo-patched.exe\n Renaming all obfuscated symbols\n Saving .../ginzo-patched-cleaned.exe\n ERROR: Error calculating max stack value. ...\n Ignored 8 warnings/errors\n Use -v/-vv option or set environment variable SHOWALLMESSAGES=1\n to see all messages\n\n```\nThe resulting .NET binary ginzo-patched-cleaned.exe now has readable symbol names, but unfortunately the ConfuserEx obfuscated code has not been unflattened; de4dot can actually unflatten\nsome ConfuserEx samples, but not all of them. For these situations, there is an additional tool Con_fuserExSwitchKiller[3], which can reorder the switch structures of our sample in its original way. However,_\nsuch obfuscation schemes can change quickly, and it is very well possible to come across samples,\nwhere no ready-to-use unpacker tool exists. E.g., more than 10 years ago a banking trojan known as\n_Torpig[4]_ made heavy use of a similar, if not even more advanced technique on x86 assembly level. That’s\nwhy we’ll study how to deal with such a switch obfuscator by writing our own Python script in IDA Pro[5] to\nunflatten code like this. Of course, the script needs to be modified for changed requirements. The main\ngoal is to be able to decompile the unflattened code using dnspy, or at least produce enough information\nto follow the switch statements ourselves, without the need to do all tedious calculations manually.\n\nUnfortunately, the tools available for .NET assembly reverse engineering are not as good as for native\nbinaries (unmanaged code). The most widely used tool - dnspy - is no longer maintained for several years\nand does not allow to actually disassemble CIL - it only offers decompiled code. There are several .NET\nlibraries that can disassemble .NET[6], which basically is what the famous de4dot deobfuscator tool is\ndoing. This however forces reversere engineers to write such code in C# itself. Most reversers prefer to\n\n1https://mkaring.github.io/ConfuserEx/ and https://github.com/yck1509/ConfuserEx\n2https://github.com/de4dot/de4dot\n3https://github.com/VAllens/ConfuserExSwitchKiller\n4https://de.wikipedia.org/wiki/Torpig\n5Interactive Disassembler, a well known reverse engineering tool, see https://hex-rays.com/\n6E.g. https://github.com/0xd4d/dnlib or https://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/\n\nNCSC • GovCERT.ch **2**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\nwrite Python code, and many are familiar with IDA, which offers a Python scripting interface. Also, IDA\ncan disassemble CIL just fine, but does not offer a decompiler for it. More seriously, IDA can’t directly\nassemble/patch/modify CIL code. So, the .NET support in IDA is not (yet?) where we’d like it to be, but it\nnevertheless offers the required features for our job. We had to use some workarounds to deal with the\nlacking .NET support in IDA. But as .NET becomes more and more popular in malware - similar to malware\nwritten in the Go language - we need to find a way to deal with IDAs shortcomings.\n\n#### Code Flattening After Decompilation\n\nIf we just export the binary to a project using dnspy and study at the decompiled code, it looks as follows\nin a simple situation - we often see dozens of case blocks instead:\n```\n internal void method_0()\n {\n   uint num = 1U;\n   for (;;)\n   {\n     IL_91:\n     uint num2 = 2666110116U;\n     for (;;)\n     {\n      uint num3;\n      switch ((num3 = (num2 ^ 2708435411U)) % 6U)\n      {\n      case 0U:\n        goto IL_91;\n      case 1U:\n        num2 = (num3 * 1468221071U ^ 3530660000U);\n        continue;\n      case 2U:\n        this.struct0_0[(int)num].method_0();\n        num2 = 2183023298U;\n        continue;\n      case 4U:\n        num2 = (((ulong)num < (ulong)(1L << (this.int_0 & 31))) ? \\\n            3536790039U : 2440591868U);\n        continue;\n      case 5U:\n        num += 1U;\n        num2 = (num3 * 2529799854U ^ 3879142487U);\n        continue;\n      }\n      return;\n     }\n   }\n }\n\n```\nThe basic algorithm works like this:\n\n  - One state variable is created (num2 with an alias num3, created by the decompiler). In a more generic\nscenario, several, if not dozens such variables can be used as state variables, declared and initialized\nstep by step at different locations, spread all over the case blocks. An example for this is the aforementioned Torpig trojan. This introduces the additional problem for a deobfuscator to differ between\nstate variables and normal variables. But fortunately, ConfuserEx only uses one state variable.\n\nNCSC • GovCERT.ch **3**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\n  - At the start of every loop iteration, the next state is calculated using this variable (e.g. (num2 ^\n```\n   2708435411U))% 6U), always using the same operation: the state variable is updated using an\n\n```\nXOR operation with a constant, and then a modulo operation with the total number of states tells\nus which state to go to next. Because this calculation happens during runtime, it is not trivial to\nfind out which state follows one given state, without actually running or emulating the code. So, the\ncode structure (different kind of loops, conditional statements, etc) disappears and is replaced as\none single loop containing a single switch. Such a technique is known as code flattening.\n\n  - The code for each state (inside the case code fragments) starts with some (optional) “real” code,\nfollowed by a “control” code fragment, updating the state variable in one of four different manners,\nwhich we call suffix types:\n\n**– Suffix type SIMPLE: The state value is replaced by a completely new one (e.g. num2 =**\n```\n     2183023298U)\n\n```\n**– Suffix type MXOR: The state value is multiplied with a constant and then XORed with another**\nconstant (e.g. num2 = (num3 * 1468221071U ^ 3530660000U))\n**– Suffix type BRANCH: A condition is checked, then the state variable is set to a new value**\ndepending on the outcome. `dnspy shows this as ternary operation ( ... ? ... : ...),`\ne.g. num2 = (((ulong)num < (ulong)(1L << (this.int_0 & 31)))? 3536790039U\n```\n      : 2440591868U) in case 4 above. The condition is “real” code, the rest is “control” code. In\n\n```\nthis case, the state variable is overwritten, similar to SIMPLE\n**– Suffix type BRANCH_MXOR: This is a combination of BRANCH and MXOR. Above sample does not**\nshow this suffix type, but here is an example from a more complex case: num2 = (((num <\n```\n     16777216U)? 4284753547U : 2545021605U)^ num3 * 3864922473U). Again, a ternary\n\n```\noperator checks a condition and chooses a constant depending on the outcome. This value is\nthen XORed with the result of the multiplication of the old state variable with a constant - note\nthat multiplication has a higher precedence than bitwise XOR in C#. This formula is identical\nto the one used with the MXOR type, except the XOR constant depends on the condition. One\nproblem in analysis of such a state machine is that we can’t calculate the next state - or next\ntwo states in case of one of the two branch types - by just statically looking at the code of one\nof the case blocks. While we do know the state itself - this is the case label after all - we do\nnot know the content of the state variable before the modulo operation was applied, because\nmodulo is a non-reversible operation. But the state variable content is needed to calculate the\nnext state; knowledge of the state alone does not suffice. So, such a state machine needs to\nbe fully emulated, using some sort of backtracking, to gain a full analysis.\n\n  - One state (case 0 in above example) - acts as initial state, which usually just assigns the initial value\n(num2 = 2666110116U). The decompiler shows this state outside the switch with an additional\n```\n   goto label (IL_91) and creates a second for (;;) loop. However, this is just the way the decom\n```\npiler shows this code in a try to make it look structured, but failing here. Replacing the goto in the\n```\n   case by a goto from the outside directly into the case code would probably work better. This would\n\n```\nalso allow to drop one of the two nested loops. Note that this initial state does not need to be of type\n```\n   SIMPLE, it can also be of type BRANCH.\n\n```\n  - One or more state acts as end state (or leaf), which leaves the loop. In the above code, this is case 3.\nHere it does not show up as an explicit case label - but it does on level of MSIL instructions, as shown\nbelow. Instead, the switch is left for case 3 as default action, and the following return statement\n\nNCSC • GovCERT.ch **4**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\nterminates the loop. Several end states are possible.\n\nAn analysis of above state machine (performed by the actual script described later on) results in:\n\n```\nFunction Struct1::method_0 at VA 2310\n\n```\n```\n  Switch loop at VA 2378: XOR 2708435411\n  Entry state 0\n  0 [Address 23A1 - 23A1 START]\n  1 [Address 236B - 2377]\n  4 [Address 232A - 2350]\n  IF:\n   2 [Address 2353 - 2364]\n   5 [Address 2317 - 2327]\n   4 ^\n  ELSE:\n   3 [Address 23A8 - 23A8 END]\n\n```\nThe acronym VA stands for virtual address, the memory address of code and data after being loaded,\nwhich is also shown in IDA. VAs need to be distinguished from the actual raw file offset in the sample. This\nshows that code runs from the initial state 0 (which usually does not contain any “real” code) to state 1\n(containing no “real” code at all), then to state 4, where a branch to either state 2 or state 3 (the end state)\noccurs. State 2 leads to state 5 and then loops back to state 4 (the loop-back situation is indicated by a ^\ncharacter). State 4 probably implements a kind of while loop. Such an analysis allows us to unflatten the\ncode manually, resulting in something similar to:\n```\n internal void method_0()\n {\n   uint num = 1u;\n   while ((ulong)num < (ulong)(1L << (this.int_0 & 31)))\n   {\n     this.struct0_0[(int)num].method_0();\n     num += 1u;\n   }\n }\n\n```\nThis code was actually produced by dnspy after the deobfuscation script was applied, but in such simple\ncases a manual reassembly works just fine. Of course, this could better be expressed as a for loop.\n\nWhile one could write a deobfuscator using decompiled code as input using text processing, that would\nnot be a very effective approach for several reasons:\n\n  - The decompiler might make different decisions in different similar situations, leading to the necessity\nto differ many strange situations and using complex regular expressions.\n\n  - The decompiler also often erroneously re-declares local variables inside the case blocks because\nthe real control flow is not known to it, so the scopes of local variables become messy.\n\n  - while-loops would never be simplified to for-loops, because this is done by heuristics in dnspy,\nunless we re-implement those in our deobfuscator.\n\n  - This approach would just not be very satisfying….\n\nNCSC • GovCERT.ch **5**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\nA much better strategy is to deal with this on the level of Microsoft Intermediate Language (MSIL), also\nknown as the Common Intermediate Language (CIL), .NET’s assembly instruction set. The obfuscation\nstructures are much clearer there, though still not as clear as we’d expect and wish - it does still seem to\ncontain many “compiler optimization”-like code fragmentation. This also suggests the obfuscator itself\noperates on source code, and not on CIL instructions level directly.\n\n#### Analysis of Code Flattening in CIL\n\nLet’s look at the flattening code elements on CIL level. CIL is a simple stack-based instruction set[7]. Opcodes are all just one byte, followed by optional operands. This is a screenshot of above method as it\nappears in IDA:\n\nControl code fragments are surrounded by orange frames, and the actual case values for the states are\nwritten in orange over the relevant blocks. The “spider in the web” of the structure is the switch statement in the middle with the preceding loop iteration code implementing the shared next-state-variablecalculation - it expects the previous value of the state variable on the stack. This code fragment actually\nappears in two different small variations. In this more common case, we have:\n```\n ldc.i4 0xA16F71D3 // push 2666110116 on the stack\n              // (above the previous state variable)\n\n```\n7https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=net-6.0\n\nNCSC • GovCERT.ch **6**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n```\n xor // XOR with previous state variable\n dup // Now we have 2 copies of the new state variable\n stloc.1 // store in local variable 1 (reserved for the\n              // state variable) - the other copy remains on stack\n ldc.i4.6 // calculate state variable modulo 6 (number of\n              // states), giving the next state\n rem.un // modulo operator\n switch loc_23A1, loc_236B, loc_2353, loc_23A8, loc_232A, loc_2317\n\n```\nSome variations we see in other places:\n\n  - ldc.i4.6 pushes the value 6 on the stack. Because 6 is a small number, a special opcode using only\none byte can be used. For larger values, this can show as ldc.i4.s 9 (for values up to 127, using\ntwo bytes), or even ldc.i4 0x100 (using five bytes). These two cases both occasionally happen, so\nwe must consider them. Of course, the obviously “random” constant(s) (like ldc.i4 0xA16F71D3\n) could also be expressed in one of the other variations for small values, but this is probably rare,\nso we ignore that possibility for simplicity. It could have consequences as how many bytes remain\navailable for patching in our own code (one, two, or five bytes). The probability for these random\nconstants to be “small” by accident is roughly 1 to 17 million (24 bits).\n\n  - In some rare cases (e.g. at VA 3F12), we see something similar to:\n```\n    ldc.i4 0x98EFB846\n    xor\n    ldc.i4.4\n    rem.un\n    switch loc_3F3D, loc_3F47, loc_3F0D, loc_3EF1\n\n```\nIn this case, the state variable is not stored in a local variable of its own. As the new state variable is\nactually eaten away by rem.un, this is only possible if all state variable calculations in the subsequent\nswitch blocks are of types SIMPLE or BRANCH, so the previous values need not be remembered. This\nmodification looks like a compiler optimization due to the fact the state variable is not read again\nlater on. Once more, this suggests the obfuscator does its work on source code level. We only see\nthis in very small code blocks.\n\nOne interesting and helpful observation is that the switch statement is always followed by an unconditional branch to the end state, br.s loc_23A8 above (marked with State 3 as it is the default if nothing\nmatches), which branches to the final ret statement. So, the tagging as “state 3” above is not completely\ntrue, as it in fact only jumps there. This instruction does not seem to be required though, as the switch\ninstruction above is complete and no default is needed (it’s label for state 3 actually also points to ret),\nbut it help our deobfuscator to identify the “normal” exit state.\n\nFor the different types, we see different code patterns at the end of the blocks, ignoring the end state 3:\n\n  - SIMPLE (e.g. state 2):\n\nNCSC • GovCERT.ch **7**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\n```\nldc.i4 0x821E4AC2 // push completely new state variable on the stack\n\n```\n\n\n- MXOR (e.g. state 5 or state 1)\n```\n  ldloc.1 // push previous state variable on the stack\n  ldc.i4 0x96C9AEAE // push multiplier constant on stack\n  mul\n  ldc.i4 0xE7370457 // push xor constant on stack\n  xor // leaves new state variable on the stack\n\n```\n- BRANCH (e.g. state 4)\n```\n   blt.s loc_2346 // blt.s is a ”real” instruction, but jump\n               // target is ”control” code\n   ldc.i4 0x917879FC // ELSE part: put 2 copies of the ”else” new\n               // state variable on the stack\n   ldc.i4 0x917879FC\n   br.s loc_2350\n  loc_2346: // IF part: put 2 copies of the ”if” new\n               // state variable on the stack\n   ldc.i4 0xD2CF2217\n   ldc.i4 0xD2CF2217\n  loc_2350:\n   pop // code flows combine, one copy is removed\n               // (duplication and pop happen for unknown reasons)\n   br.s loc_2378 // jump back to loop\n\n```\nThis code also appears in a second layout with additional fragmentation, e.g. at VA 2773:\n```\n   bge.un loc_26E6\n   br.s loc_275C\n   ret // unrelated code in the same fct behind\n   ...\n\n```\n```\nloc_26E6:\n\n```\n```\n ldc.i4 0xBA2C2B6D\n ldc.i4 0xBA2C2B6D\nloc_26F0:\n pop\n br.s loc_2737\n ...\n\n```\n```\nloc_275C:\n\n```\n```\n     ldc.i4 0x8873AC65\n     ldc.i4 0x8873AC65\n     br.s loc_26F0\n\n```\nThe three sections can be torn apart and even appear in different order. The only relevant difference\nis the additional unconditional branch in the ELSE part after the conditional branch. This again looks\nlike a compiler optimization and suggests obfuscation happened on source code level. These are\nthe only two layouts we found in the sample.\n\nNCSC • GovCERT.ch **8**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\n  - BRANCH_MXOR (e.g. at VA 2829)\n```\n      blt.un.s loc_2837 // same code as in BRANCH, leaving an XOR constant\n                   // (depending on test) on the stack\n      ldc.i4 0x97B1F2A5\n      ldc.i4 0x97B1F2A5\n      br.s loc_2841\n    loc_2837:\n      ldc.i4 0xFF64268B\n      ldc.i4 0xFF64268B\n    loc_2841:\n      pop\n      ldloc.s 5 // Previous state variable\n      ldc.i4 0xE65E0969 // multiplier constant\n      mul\n      xor\n\n```\nAgain, an unconditional branch could follow the first conditional jump. However, we did not observe\nthat other layout in the sample.\n\nThere are several additional caveats we noticed during analysis, which make automated deobfuscation\nharder in some cases - but as these border cases are rare, we can deal with them manually and let the\ndeobfuscator script do the major part:\n\n**Caveat: Fragmentation of State Code**\n\nThe code inside one state is sometimes itself fragmented, using additional br/br.s instructions. However,\nit is relatively easy to deal with this by just following these branches while traversing the state code.\n\n**Caveat: Non-Linear Code Fragments**\n\nOne would expect every “real” code fragment inside a case block to be a single building block, i.e. without\nadditional conditional branches. Unfortunately, this is not always the case - it seems the obfuscator does\nnot obfuscate every normal conditional branch, but instead leaves some of these inside one case block\nuntouched. We deal with this situation by just following one side of the branch in order to find the end of\na state. This usually works, but there seem to be very few cases where actual non-obfuscated branches\nlead to different follower states or otherwise inconsistent behavior.\n\n**Caveat: More Than One switch in a Function**\n\nSometimes, more than one obfuscation-switch appear in the same function. This is not a major problem,\nbut it can make the initial or end state detection harder (except for the default end state). We try to cover\nthat by defining the appearance of a switch instruction inside a state as an indication the state to be a\nleaf. This would fail if one obfuscation switch appeared inside an actual (non-leaf) state code of an outer\nswitch obfuscation. We did not actually see such a situation, but it would make deobfuscation harder.\n\nNCSC • GovCERT.ch **9**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\n**Caveat: Shared Code**\n\nIn rare situations, two different states share some common control code and branch into this before the\nnext loop iteration starts. We cannot deal with these situations at the moment, and they might result in\ncode that dnspy can no longer decompile. This can also happen in case of some strange interaction with\n```\ntry-except constructs (e.g. at VA 53D6).\n\n```\n**Caveat: Inconsistent State Machine**\n\nWhenever the same state appears as successor of more that one other state, probably some kind of loop\nis implemented. This is a common situation. We expect all re-entries into such re-used states to have the\n_same value of the state variable (or at least values that lead to the same state paths thereafter). Should_\nthis not be the case, we call the state machine inconsistent. Fortunately, all state machines in our sample\nturned out to be consistent. It is hard to think of an obfuscator algorithm producing an inconsistent state\nmachine - it would have to somehow melt two different states into one. A very advanced state obfuscator\nmight be able to actually realize this kind of magic. The situation is comparable to compilers: any standard\nC code results in some type of consistent assembly code, but assembly code in general can be inconsistent\nand not decompilable back into reasonale C code. Any state machine we come across could in theory turn\nout to be inconsistent. We deal with the problem by just detecting it, emitting an error line, and leaving the\ncode unchanged.\n\nThere might be situations where an obfuscator could actually intentionally produce inconsistent states, just\nto break debofuscator scripts. This could be done in code that is never actually be executed, e.g. because\nsome conditions leading to it will never be true, comparable to junk code. It might also be possible that\nactual state code is of a nature that repetitions don’t do any harm, so repeating a state in a different context\nmight be acceptable, if it is only used as a link state to another state value which is not yet used. The\nredundant repeating of the state code would then act like an empty state. This kind of obfuscation would\nbe quite advanced though, and fortunately, we did not need to take care of it in this sample. We’re not\naware of such a technique actually used by code obfuscators.\n\nWe occasionally observed unused states, i.e. states that were never reached during emulation of a state\nmachine. This does not make the state machine inconsistent, and it is safe to just ignore unused states;\nbut it is still a slightly unusual observation. Whereever we checked, these unused states actually did not\ncontain any real code, only control code. So they might very well be obfuscator artifacts.\n\n#### Parsing and Analysis\n\nAs mentioned, we use IDA-Python for parsing. To make things easier, we use the excellent sark library[8] as\ndisassembler wrapper. We define several structures to encapsulate the suffix type SType (a simple enum),\ninformation about the actual suffix code Suffix (most importantly the XOR and multiplication constants),\nand all information about an actual state Block, and finally a Switch structure:\n\n8https://github.com/tmr232/Sark\n\nNCSC • GovCERT.ch **10**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n```\n # SType: the different code constructs which calculate the next\n # state variable value\n class SType(Enum):\n   NA = auto()\n   SIMPLE = auto()\n   MXOR = auto()\n   BRANCH = auto()\n   BRANCH_MXOR = auto()\n # Suffix collect type+context of ctrl code at end of blocks\n @dataclass\n class Suffix:\n   addr: int = 0 # address of first control instruction\n   sType: SType = SType.NA # actual code type\n   val: int = -1 # value used for ”if” / ”else”\n   val_else: int = -1\n   xor: int = 0 # common xor/mult constants (MXOR)\n   mult: int = 0\n   # actual control instructions (for later NOPing):\n   ctrls: List[sark.code.line.Line] = field(default_factory=list)\n # Block encodes information about one switch block\n @dataclass\n class Block:\n   state: int # case tag (idx of block in switch)\n   start: int # start- and end-VA of data\n   end: int = 0\n   is_start: bool = False\n   is_end: bool = False\n   is_ret: bool = False\n   next_state = -1\n   next_state_else = -1\n   enter_value = -1\n   enter_values: Set[int] = field(default_factory=set)\n   suffix = Suffix() # used to calculate next state\n @dataclass\n class Switch:\n   patcher: Patcher # used later to patch code\n   cont_addr: int = 0 # VA for loop calc\n   end_addr: int = 0 # VA of block which ends loop\n   switch_addr: int = 0 # VA of switch statement\n   # entry_states gets the blocks that are initially traversed\n   entry_states: Dict[int, List[int]] = field(default_factory=dict)\n   # control values for state calculation:\n   xor_value: int = 0\n   nbr_blocks: int = 0\n   failed: bool = False # set to true if unusual cases\n   blocks: List[Block] = field(default_factory=list)\n\n```\n**Main Parsing Loop**\n\nUsing above structure, the main code parsing loop starts with:\n\n```\nfor fct in sark.functions():\n\n```\n```\n   buff: List[sark.code.line.Line] = [] # reverse order\n   pattern = bytearray() # Allows us to find the function\n\n```\nNCSC • GovCERT.ch **11**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n```\n   switches: List[Switch] = []\n   lines: Dict[int, sark.code.line.Line] = {}\n   print(f”\\nFunction {fct.name} at VA {fct.ea:X}”)\n   for l in fct.lines:\n      buff.insert(0, l)\n      lines[l.ea] = l\n      ops = l.insn.operands\n      pattern.extend(l.bytes)\n      # detect switch statement with preceding modulus:\n      if l.insn.mnem == ”switch” and \\\n        buff[1].insn.mnem == ”rem.un” and \\\n        buff[2].insn.mnem.startswith(”ldc.i4”):\n\n```\nWe do keep the actual original byte data of the code in a byte array pattern. This is done because IDA\ncurrently does not support code patching for .NET - we can only read CIL instructions. While it would\ncertainly possible to actually mimic the interpretation of .NET headers in Python to map VAs to actual raw\nfile offsets, we decided for the simpler and pragmatic way to just search for pattern in the actual binary\ndata of the executable in order to find the delta - which by the way is not constant for every function.\nThere’s also a caveat about this, which will be discussed further down.\n\nNext, we check if one of the two known code fragments precede this, read and memorize the corresponding\nXOR value and the continuation address - i.e. the address jumped back to at each loop iteration after the\nnew state variable was set:\n```\n # 2 opcode sequences are possible:\n # ldc / xor / dup / stloc / ldc / rem / switch: usual case, state variable is stored as\n # local var\n # ldc / xor / ldc / rem / switch: in some simple cases (e.g. VA 3f1a), the state\n # variable if kept on stack\n if len(buff) > 4 and buff[3].insn.mnem == ”xor” and buff[4].insn.mnem == ”ldc.i4”:\n   xor_value = buff[4].insn.operands[0].imm\n   cont_addr = buff[4].ea # this is where jumps to the next loop occur\n elif len(buff) > 6 and buff[5].insn.mnem == ”xor” and buff[6].insn.mnem == ”ldc.i4”:\n   xor_value = buff[6].insn.operands[0].imm\n   cont_addr = buff[6].ea\n else:\n   raise Exception(”Unknown xor construct before switch”)\n\n```\nAs mentioned earlier, we ignore the really improbable situation where the XOR value were so small that\nan ldc.i4.s or even an implicit instruction suffices. For our sample, the resulting exception in such a\nsituation never triggered.\n\nHowever, when reading the number of states, we need to consider all possibilities. Finally, the Switch\nobject can be created:\n```\n # number of states is pushed in the previous ldc instruction. That one can embed the\n # immediate value into\n # the opcode for small values:\n if buff[2].insn.mnem.startswith(”ldc.i4.”) and len(buff[2].insn.operands) == 0:\n   # Implicit instruction, value is not stored in an operand, extract it from the\n\n```\n\nNCSC • GovCERT.ch **12**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n```\n   # mnemonic as string:\n   nbr_blocks = int(buff[2].insn.mnem.split(”.”)[-1])\n else:\n   # Explicit operand (”.s” or full)\n   nbr_blocks = buff[2].insn.operands[0].imm\n switch = Switch(patcher, switch_addr=l.ea, cont_addr=cont_addr, xor_value=xor_value,\n           nbr_blocks=nbr_blocks)\n\n```\n\nAs additional confirmation, we assert an unconditional branch to the end state follows, which can be a\nfar or a near one. switch.end_addr is set to where this branch jumps to, which is the default end block\naddress:\n\n```\nif l.next.insn.mnem in (”br”, ”br.s”):\n\n```\n```\n   switch.end_addr = l.next.insn.operands[0].addr\n else:\n   raise Exception(”no br after switch”)\n\n```\nFinally, we must extract the entry addresses for every case block. Unlike native assembly, CIL has a switch\n\ninstruction with a variadic number of operands, meaning the list of operands is not always of the same\nlength. As IDA’s instruction model does not support variadic instructions, we can only read a commaseparated string of all labels like one single operand. To get the actual addresses instead of the symbolic\nlabels, we rely on the fact these are of the form loc_+ “hexadecimal address”. As the loc_ prefix requires\n4 characters, this can be expressed in the following way, which admittedly is an ugly hack - remember not\nto rename any labels before applying the script:\n```\n # Create switch blocks for each label (we must parse these as text labels, e.g.\n # ”loc_3F47”, where 3f47 is the VA)\n for state, l in enumerate(ops[0].text.split(',')):\n   switch.blocks.append(Block(state, int(l.strip()[4:], 16)))\n\n```\n\nAnd we add the resulting switch construct: switches.append(switch)\n\nAfter the loop parsed all lines of the function, we come back to each such detected switch, as we need to\nfind more information about the actual blocks, such as: Where do they end? Are they end or start states?\nWhat suffix code is used? What are the relevant constants?\n\n```\nfor switch in switches:\n\n```\n```\n   start_found = False # Will be set to true if start states could be detected\n   for block in switch.blocks:\n      if block.start not in lines:\n        raise Exception(f”Block address {block.start:X} has no instruction”)\n      l = lines[block.start]\n      crefs = list(l.crefs_to)\n\n```\nWe create a list of code references to the first instruction of the block (crefs). For normal states, this list\n\nNCSC • GovCERT.ch **13**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\nonly contains one instruction, namely the switch instruction. Start states should additionally get a code\nreference from where the loop is entered, and the normal end state should get another reference from the\nbranch instruction following the switch. But we can check for the normal end state by directly comparing\nto switch.end_addr assigned in the previous step:\n```\n  # The block that the branch after ”switch” jumps to is a leaf (e.g. does not loop back):\n  if switch.end_addr == l.ea:\n    block.is_end = True\n    block.end = l.ea\n    continue\n\n```\nOtherwise, if there are any cross references that differ from the switch address, we know this is a start state.\nUnfortunately, two obfuscation switches in the same function occasionally share a state (e.g. switch at\nVA 53D6 and switch at 5462 both point to the same block on VA 53FB). This is still an unclear case, and\nfor the moment we consider these as end states:\n```\n  # We need to find the initial states. Normal states have only one xref (the switch\n  # statement itself),\n  # while the initial state is also referenced by the jump-in instructions.\n  for a in crefs:\n    if a != switch.switch_addr: # not in (switch.switch_addr, switch.end_addr):\n      if lines[a].insn.mnem == ”switch”:\n         # if 2 switch statements link top the same state (sigh),\n         # we assume it's a common end state\n         block.is_end, block.is_start = True, False\n         break\n      if block.state not in switch.entry_states:\n         switch.entry_states[block.state] = []\n      switch.entry_states[block.state].append(a)\n      block.is_start = True\n      start_found = True\n\n```\nNow we traverse the code for this block until we reach its end. Certain instructions are interpreted as\nmarkers that we reached an end state; we don’t know at the moment if switch instructions themselves\nindicate an end state. They probably do, but we can’t rely on this. We emit a warning if such a such a\n```\nswitch instruction is not followed by a branch. An example is the switch at VA AC74, which does not\n\n```\nseem to have any end state at all (maybe an endless loop), and is jumped in from another switch at VA\n```\nAF73 (to address AC73). We consider these cases as end states. Note that branches which don’t return to\n\n```\nthe loop entry (cont_addr) are just followed and assumed to occur due to code fragmentation:\n```\n  # Traverse the code for this block:\n  while True:\n    # returns end the block immediately:\n    if l.insn.mnem == ”ret” and not block.is_end:\n      block.end = l.ea\n      block.is_end = True\n      break\n    # embedded switch are tricky - we follow the branch behind:\n    if l.insn.mnem == ”switch”: # ... maybe we can assume these are always end nodes,\n\n```\nNCSC • GovCERT.ch **14**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n```\n                     # but not sure...\n      l = l.next\n      if l.insn.mnem not in (”br”, ”br.s”):\n         print(f” INFO: Strange embedded switch at {l.ea:X} - we assume it's an end node”)\n         block.is_end, block.is_start = True, False\n         break\n      else:\n         l = lines[l.insn.operands[0].addr]\n         continue\n    # If we hit the first instruction of the xor-part, this is the last block before,\n    # where the branch lacks:\n    if l.ea == switch.cont_addr:\n      block.end = l.prev.ea\n      # extract the next-block-constants (code suffix of block):\n      block.suffix = find_suffix(l.prev, block.start)\n      break\n    # ... but most blocks end in a branch to the xor-part:\n    elif l.insn.mnem in (”br”, ”br.s”, ”leave”, ”leave.s”):\n      if l.insn.operands[0].addr == switch.cont_addr:\n         block.end = l.prev.ea\n         block.suffix = find_suffix(l.prev, block.start)\n         # We consider the terminating branch also as control instruction:\n         block.suffix.ctrls.append(l)\n         break\n      # branches that don't return are BRANCH-type instructions that we just follow\n      # (can be fragmented)\n      l = lines[l.insn.operands[0].addr]\n      continue\n    # Should not really happen (but maybe it does): last instruction of function also\n    # ends the block\n    elif l.ea + l.size not in lines:\n      break\n\n```\n```\nl = lines[l.ea + l.size]\n\n```\n\nKeep in mind that all conditional jump conditions in this traversal are considered to fail - that’s how the\n```\nl.next method works. Hence, only one branch is traversed, knowing that in most cases both branches\n\n```\nwill eventually coalesce. Also, while most states end in a br/br.s instruction for the next loop iteration, in\none case we probably see a fall-through (the block located just before this loop).\n\n**Detection of the Suffix Code Type and Extraction of the Constants (find_suffix function)**\n\nThe find_suffix function is responsible for finding the control code part of the block, telling us about\nthe suffix type, and extracting the relevant constants; all of this will be returned in a new Suffix instance.\n```\nfind_suffix also stores references to every control instruction into its ctrls field; these will be later\nnop-ed out in the patching stage. To do it’s work, find_suffix relies on the parameter l, pointing to the\n\n```\nlast instruction of the block previous to the final branch to the next loop iteration (or just the last instruction\nin case of a fall-through state). It does so by walking backwards from that instruction using a temporary\nvariable l2. Because the control code is at most 11 instructions long, it stops when this threshold is reached,\nor when the block’s start-address or the switch instruction is hit. These up to 11 instructions are put into\na list ctrls, like before in reverse order:\n\nNCSC • GovCERT.ch **15**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n```\n   l2 = l\n   tree_else_addr = -1 # for branches, the else part usually follows, but could be\n                # branched to as well\n   # byte sequence of previous instruction (so actually the one behind), allows to detect\n   # 2 identical ldc instructions\n   prev_bytes = b''\n   for i in range(11): # suffixes are never longer\n      if l2.insn.mnem == ”switch”:\n        break\n      ctrls.append(l2)\n      if l2.ea == block_start_addr:\n        break\n\n```\nThe variable tree_else_addr will be used to correctly link the IF-part of a branch to the ELSE-part - see\nbelow for more details. Notice that we keep the binary representation of the previous instruction in a variable prev_bytes; this allows us to easily detect the two subsequent ldc.i4 clones used in the BRANCH\nsuffix types.\n\nWe skip a short piece of code here (shown and explained three code paragraphs further down), which\nasserts the correct flow in case of BRANCH suffix type.\n\nThe code cross-reference approach is used once more to decide if we can just go backwards normally, or\nneed to take care of a branch; this also allows us to follow back unconditional branches without preceding\nfall-through:\n```\n crefs = list(l2.crefs_to)\n if len(crefs) == 1:\n   prev_bytes = l2.bytes\n   l2 = sark.Line(crefs[0])\n   continue\n # Only instructions used in standard branch construct (b.. / ldc / )\n if len(crefs) != 2:\n   raise Exception(f”Only 1 or 2 crefs allowed at {l2.ea:X}”)\n\n```\n\nIf we have more than one reference, we must either be at the pop instruction of one of the two BRANCH\nsuffix types, or one of their ldc.i4 instructions. As explained below, the latter case should already be\ndealt with at this point though. In case of the pop instruction, in all observed layouts - fragmented or not the IF part with its 2 ldc instructions immediately precedes the pop instruction, while the ELSE part ends\nin an unconditional br to the pop instruction. The address of this branch can be extracted using list(\n```\nset(crefs)- set([l2.prev.ea]))[0], which just removes the final instruction of the IF part from the\n\n```\ncode references and so should point to the br of the ELSE part; this address is stored in a local variable\n```\ntree_else_addr, initialized to -1, for one of the next loop iterations:\n # a BRANCH combines at ”pop” instruction; immediately before is the if part (2 ldc's)\n # note: theoretically, a branch cold appear in between\n if l2.insn.mnem == ”pop”:\n   tree_else_addr = list(set(crefs) - set([l2.prev.ea]))[0]\n   prev_bytes = l2.bytes\n   l2 = l2.prev\n\n```\nNCSC • GovCERT.ch **16**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n```\n   continue\n else:\n   prev_bytes = l\n   l2 = l2.prev\n\n```\nWhen going back beyond the pop instruction, we use the fact tree_else_addr was set to a value different from -1 (meaning a popinstruction was seen) in order to detect the first of the two ldc clones in\nthe IF branch - at this point we must jump to the just memorized ELSE branch. This needs to be done\nearlier in the loop (before crefs was assigned, where the skipped code was mentioned), and we also set\n```\ntree_else_addr back to -1:\n\n```\n```\nif tree_else_addr >= 0 and l2.insn.mnem == ”ldc.i4” and l2.bytes == prev_bytes:\n\n```\n```\n   # 2 identical ldc.i4 instructions detected\n   prev_bytes = l2.bytes\n   # after this, we jump to the else tree (linking to the pop)\n   l2 = sark.Line(tree_else_addr)\n   tree_else_addr = -1\n   continue\n\n```\nWhen the collection of the control code is completed, we can use the resulting ctrls list to differ the types:\n\n  - SIMPLE is easily identified by its ldc.i4 instruction at the end - it also is the only actual control\ninstruction:\n\n```\nif ctrls[0].insn.mnem == ”ldc.i4”:\n\n```\n```\n    s.sType = SType.SIMPLE\n    s.val = l.insn.operands[0].imm\n    s.addr = l.ea\n    s.ctrls.append(ctrls[0])\n\n```\n- MXOR is also easy to detect: we just allow for different local variables for the state variable. Keep in\nmind that all 5 instructions checked for are considered control instructions (and suffix’s addr is set\nto the first of them):\n\n```\nelif ctrls[0].insn.mnem == ”xor” and ctrls[1].insn.mnem == ”ldc.i4” and \\\n\n```\n```\n       ctrls[2].insn.mnem == ”mul” and \\\n       ctrls[3].insn.mnem == ”ldc.i4” and ctrls[4].insn.mnem.startswith(”ldloc.”):\n       s.sType = SType.MXOR\n       s.xor = ctrls[1].insn.operands[0].imm\n       s.mult = ctrls[3].insn.operands[0].imm\n       s.addr = ctrls[4].ea\n       s.ctrls.extend(ctrls[0:5])\n\n```\n  - BRANCH needs a bit more flexibility - note that ctrls[6] is just checked for starting with the letter b,\nas it can be the relevant conditional branch, or an additional unconditional fragmentation branch just\nafter it, depending on the layout. Everything except this one or two branches are considered control\ncode (this has to do with the special patching situation explained later on), but depending on the\n\nNCSC • GovCERT.ch **17**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\nsituation, we must set the start address differently:\n```\n    elif ctrls[0].insn.mnem == ”pop” and \\\n        ctrls[1].insn.mnem == ”ldc.i4” and ctrls[2].insn.mnem == ”ldc.i4” and \\\n        ctrls[3].insn.mnem in (”br”, ”br.s”) and \\\n        ctrls[4].insn.mnem == ”ldc.i4” and ctrls[5].insn.mnem == ”ldc.i4” and \\\n        ctrls[6].insn.mnem.startswith(”b”):\n       s.sType = SType.BRANCH\n       s.val = ctrls[1].insn.operands[0].imm\n       s.val_else = ctrls[4].insn.operands[0].imm\n       if ctrls[6].insn.mnem in (”br”, ”br.s”):\n         if ctrls[7].insn.mnem.startswith(”b”):\n            # Fragmentation case, we start one instruction earlier\n            s.addr = ctrls[7].ea\n         else:\n            raise Exception(f”br should be preceeded by conditional branch at VA {ctrls[6].\n              ea}”)\n       else:\n         s.addr = ctrls[6].ea\n       s.ctrls.extend(ctrls[0:6])\n\n```\n  - BANCH_MXOR is dealt with in the same way. As a side note, we did not actually see the fragmented\nlayout for this suffix type:\n\n```\nelif ctrls[0].insn.mnem == ”xor” and ctrls[1].insn.mnem == ”mul” and \\\n\n```\n```\n        ctrls[2].insn.mnem == ”ldc.i4” and ctrls[3].insn.mnem.startswith(”ldloc.”) and \\\n        ctrls[4].insn.mnem == ”pop” and \\\n        ctrls[5].insn.mnem == ”ldc.i4” and ctrls[6].insn.mnem == ”ldc.i4” and \\\n        ctrls[7].insn.mnem in (”br”, ”br.s”) and \\\n        ctrls[8].insn.mnem == ”ldc.i4” and ctrls[9].insn.mnem == ”ldc.i4” and \\\n        ctrls[10].insn.mnem.startswith(”b”):\n      s.sType = SType.BRANCH_MXOR\n      s.val = ctrls[5].insn.operands[0].imm\n      s.val_else = ctrls[8].insn.operands[0].imm\n      s.mult = ctrls[2].insn.operands[0].imm\n      if ctrls[10].insn.mnem in (”br”, ”br.s”):\n         if ctrls[11].insn.mnem.startswith(”b”):\n           s.addr = ctrls[11].ea\n         else:\n           raise Exception(f”br should be preceeded by conditional branch at VA {ctrls[6].ea\n              }”)\n      else:\n         s.addr = ctrls[10].ea\n      s.ctrls.extend(ctrls[0:10])\n\n#### Emulation\n\n```\nAfter a Switch is fully parsed and an initial state actually found, it can be emulated by recursive code; this\nis done for every possible initial state, if there should be more than one:\n\n```\nfor initial_state in switch.entry_states.keys():\n\n```\n```\n   print(f” Entry state {initial_state}”)\n   switch.failed = not switch.emulate(initial_state, value=-1, prev_block=None,\n\n```\nNCSC • GovCERT.ch **18**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\n```\ndo_print=True, indent=1)\n\n```\n```\nSwitch’es emulation method returns True if it has worked without issues. Situations like inconsistent\n\n```\nstate variables return False. The emulation method is pretty straightforward, so we won’t describe it in\ndetail; if things work, the next_state and next_state_else properties of every block should be filled in\ncorrectly. It also allows to print the state machine using do_print and indent.\n\n#### Patching\n\nThe actual patching step is the most critical one. As already mentioned, IDA can’t directly patch CIL code.\nInstead, we must patch directly into the binary. For this purpose, a Patcher class is defined, reading the\noriginal binary and writing the modified binary to the same filename with an additional .dec suffix:\n\n```\nclass Patcher(object):\n\n```\n```\nbin_data: bytes\ndelta: int\n# Read binary data from disk when instantiated:\ndef __init__(self) -> None:\n  with open(idaapi.get_root_filename(), ”rb”) as f:\n     self.bin_data = f.read()\n  self.delta = 0\n\n```\n```\n   def write(self) -> None:\n      with open(idaapi.get_root_filename() + ”.dec”, ”wb”) as f:\n        f.write(self.bin_data)\n\n```\nThe delta value stores the difference between raw file offsets and IDA’s virtual addresses. Unfortunately,\nit needs to be recalculated for each method. Also, as we use sark’s .next property to walk through all\ninstructions of a method, this might sometimes skip some “code caves” (unused junk instructions), so we\ncan’t expect the byte pattern to be precisely identical in the binary to find the offset. So we decided for a\nworkaround to find a match as far as possible:\n```\n   # set_fct: find function code in binary data and calculate ”delta” for this function\n   # (VA-physical mapping)\n   def set_fct(self, start_va_addr: int, pattern: bytes) -> None:\n      while True:\n        # Somethimes instructions are skipped that sark does not see, so not the full\n        # pattern need to match. Decrease until it matches.\n        # TODO: Make sure match is still unique\n        fct_offset = self.bin_data.find(pattern)\n        if fct_offset >= 0:\n           break\n        pattern = pattern[:-1]\n      self.delta = fct_offset - start_va_addr\n\n```\nWhen trying to unflatten code, different approaches can be chosen. The cleanest would be to re-arrange\nthe whole code of a method. We decided against this as we expect many potential problems doing so. For\n\nNCSC • GovCERT.ch **19**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\nonce, all branches in the method must be re-calculated, and care needs to be taken to differ between near\nand far branches. Also, embedded structural elements like try-except-constructs could be broken by just\nmoving code of a function around.\n\nAn easier approach is be to leave all “real” code where it is, and just replace the start of all “control” code\nfragments we previously identified by branches to the next calculated states. This will result in code with\nnon-optimal layout, fragmentation, and non-required branches - the main question however is whether\n```\ndnspy will be able to decompile such code or not. We can’t conclusively answer this question, but our\n\n```\nexperiments showed that this works quite well, as long as all “other” control code (the code not actually\nused for our replacement branches) is nop-ed out, i.e. overwritten by 00 bytes (CIL’s opcode for nop). dnspy\ndoes not seem to be able to detect and ignore unreachable instructions, so we can’t just let these artifacts\nlie around, but are instead forced to clean things up.\n\nTo show the intended result, the code shown in the previous image looks like this after patching - notice\nthat all control code is now gone, but actual code blocks remain at their addresses. We mark the same\n```\nState tags to make comparison easier; e.g. state 1, which does not contain any actual code - it’s like an\n\n```\nempty state - is now reduced to a single branch to the next state 4. Also, at the end of state 4, we actually\nleft the conditional branch where it was (at addresses 2338) and overwrote the first ldc.i4 0x917879FC\ninstruction of the ELSE part by a branch to state 3 (at VA 233A, jumping to 23A8)\n\nNCSC • GovCERT.ch **20**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\nTo show the nop-ed out part, this is the same code in non-graph view:\n```\n seg000:2310 {\n seg000:2310 .maxstack 4\n\n```\nNCSC • GovCERT.ch **21**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n```\n seg000:2310 .locals init (unsigned int32 V0,\n seg000:2310 unsigned int32 V1)\n seg000:2310 ldc.i4.1\n seg000:2311 stloc.0\n seg000:2312 br loc_23A1\n seg000:2317\n seg000:2317 loc_2317:\n seg000:2317 ldloc.0\n seg000:2318 ldc.i4.1\n seg000:2319 add\n seg000:231A stloc.0\n seg000:231B br.s loc_232A\n seg000:231D .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n seg000:232A\n seg000:232A loc_232A:\n seg000:232A\n seg000:232A ldloc.0\n seg000:232B conv.u8\n seg000:232C ldc.i4.1\n seg000:232D ldarg.0\n seg000:232E ldfld int32 Struct1::int_0\n seg000:2333 ldc.i4.s 0x1F\n seg000:2335 and\n seg000:2336 shl\n seg000:2337 conv.i8\n seg000:2338 blt.s loc_2353\n seg000:233A br.s loc_23A8\n seg000:233C .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n seg000:233C .byte 0, 0\n seg000:2353\n seg000:2353 loc_2353:\n seg000:2353 ldarg.0\n seg000:2354 ldfld valuetype Struct0[] Struct1::struct0_0\n seg000:2359 ldloc.0\n seg000:235A ldelema Struct0\n seg000:235F call instance void Struct0::method_0()\n seg000:2364 br.s loc_2317\n seg000:2366 .byte 0, 0, 0, 0, 0\n seg000:236B\n seg000:236B loc_236B:\n seg000:236B br.s loc_232A\n seg000:236D .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n seg000:236D .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n seg000:236D .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n seg000:23A1\n seg000:23A1 loc_23A1:\n seg000:23A1 br.s loc_236B\n seg000:23A3 .byte 0, 0, 0, 0, 0\n seg000:23A8\n seg000:23A8 loc_23A8:\n seg000:23A8 ret\n seg000:23A8 }\n\n```\nAnd indeed, dnspy can correctly decompile this method the way shown above.\n\n**CIL Branch Instructions**\n\nTo understand the patching code, a short detour into CIL is required. Unlike native assembly, the first\nbyte of each instruction is always the opcode - no two- or more-byte opcodes exist. CIL knows exactly 26\ndifferent branch opcodes: one unconditional and 12 conditional ones, and each of them in a far variant\n\nNCSC • GovCERT.ch **22**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\n(4 byte operand) and a near variant (1 byte operand with .s suffix in the mnemonic), so occupying 5 or 2\nbytes. The far- and near-variant opcodes of each branch always differ by exactly 13. E.g. we can modify\nthe opcode of blt to blt.s by subtracting 13 from the opcode, and vice versa. The opcodes for br and\n```\nbr.s are 0x38 and 0x2b, again with a difference of 13. As in native assembly, the encoded operand is a\n\n```\n2-complement delta to the address of the otherwise following instruction, so near branches have a range\nof -128 to 127. When patching code, we must take care of far and near branches because we must not\noverwrite non-control code; this would happen if we changed a near branch to a longer far branch requiring\nthree additional bytes.\n\nThese small helper functions support us with patching code - they should be self-explanatory:\n```\n # Some helper functions to deal with branch functions:\n # 0x2b - 0x37 are near (.s) variants, 0x38 - 0x44 far variants\n # (difference with same condition is always 13)\n # 0x38 / 0x2b are the unconditional jumps\n def is_branch(opcode: int) -> bool:\n   return 0x2b <= opcode <= 0x44\n def is_near(opcode: int) -> bool:\n   return 0x2b <= opcode <= 0x37\n\n```\n```\ndef is_far(opcode: int) -> bool:\n  return 0x38 <= opcode <= 0x44\ndef make_far(opcode: int) -> int:\n  if is_far(opcode):\n\n```\n```\n  return opcode\nreturn opcode + 13\n\n```\n```\ndef make_near(opcode: int) -> int:\n  if is_near(opcode):\n     return opcode\n  return opcode - 13\n\n```\n```\n def is_in_near_range(jump_addr: int, target_addr: int) -> bool:\n   return -128 <= target_addr - (jump_addr + 2) <= 127\n # branch_delta: calculate delta from jump_addr to target_addr and encode in 1\n # (if near) or 4 bytes\n def branch_delta(jump_addr, target_addr, near: bool) -> bytes:\n   if near:\n      return struct.pack(”B”, (target_addr - (jump_addr + 2)) & 0xff)\n   return struct.pack(”<I”, (target_addr - (jump_addr + 5)) & 0xffffffff)\n\n```\nWith this in mind, Patcher implements methods to patch branches, either by overwriting with an unconditional branch (if overwrite_unconditional is set to True), or by replacing the target address of an\nexisting conditional branch, as well as to nop out instructions and code blocks - the latter one uses recursion in case of conditional branches:\n\nNCSC • GovCERT.ch **23**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n```\n   # patch_branch: patch in a branch to the destination address at the given address.\n   # if overwrite_unconditional is true, a br or br.s is encoded.\n   # otherwise, the existing branch condition is kept (just made far or near if required)\n   # returns the number of bytes required (5 for long, 2 for short)\n   def patch_branch(self, jump_addr: int, target_addr: int,\n              overwrite_unconditional=False) -> int:\n      opcode = self.bin_data[jump_addr + self.delta]\n      if overwrite_unconditional:\n        opcode = 0x38 # this is a br instruction\n      if not is_branch(opcode):\n        raise Exception(f”ERROR: there is no branch at address {jump_addr:X}”)\n      near = is_in_near_range(jump_addr, target_addr)\n      if near:\n        inst_size = 2\n        opcode = make_near(opcode)\n      else:\n        inst_size = 5\n        opcode = make_far(opcode)\n\n```\n```\nself.bin_data = self.bin_data[:jump_addr + self.delta] + \\\n\n```\n```\nopcode.to_bytes(1, ”little”) + \\\nbranch_delta(jump_addr, target_addr, near) + \\\nself.bin_data[jump_addr + self.delta + inst_size:]\n\n```\n```\nreturn inst_size\n\n```\n```\ndef nop_inst(self, l: sark.code.line.Line) -> None:\n\n```\n```\naddr = l.ea + self.delta\nself.bin_data = self.bin_data[:addr] + \\\n          (b'\\x00' * l.size) + \\\n          self.bin_data[addr + l.size:]\n\n```\n```\n   def nop_code(self, l: sark.code.line.Line, end_address: int) -> None:\n      while True:\n        self.nop_inst(l)\n        if l.ea == end_address:\n           return\n        if l.insn.mnem in (”br”, ”br.s”):\n           l = sark.Line(l.insn.operands[0].addr)\n           continue\n        if l.insn.mnem.startswith(”b”):\n           self.nop_code(sark.Line(l.insn.operands[0].addr), end_address)\n        l = l.next\n\n```\nThe main code creates one Patcher instance, which is referenced to in every Switch instance as a property patcher, because patch is a method of the Switch class.\n\n**Avoiding Overwriting Real Code When Patching**\n\nAs mentioned before, we must be careful to never overwrite actual code. So let’s look at the different suffix\ntypes and layouts:\n\n  - SIMPLE: The control code for a SIMPLE block is always a ldc.i4 ... instruction, which requires\n5 bytes. As explained earlier, theoretically a 2-byte ldc.i4.s for 1-byte values or even an implicit\n1-byte instruction for very small values could be used; but as this happens very rarely, we think it’s\nsafe to ignore these or deal with these situations manually. As our branch instruction requires 2 or 5\n\nNCSC • GovCERT.ch **24**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\nbytes as well (depending if it’s near or far), we’re safe.\n\n  - MXOR: The same goes here, control code is even longer (and we never saw it fragmented), so overwriting is safe\n\n  - BRANCH: This is the tricky part. We must differ between the 2 layouts.\n\n**– If no fragmentation is used, we’re safe as well: We’ll have a 2- or 5-byte conditional jump, fol-**\nlowed by a two 5 byte ldc instructions of the ELSE part, so 12 or 17 bytes. We must overwrite\nthis in the worst case with a far conditional and a far unconditional jump, so 10 bytes.\n**– If fragmentation is used, the situation is different. In the worst case, we only have a 2-byte**\nconditional near branch followed by a 2-byte unconditional near branch (4 bytes), so we can’t\nfill in 10 bytes without potentially overwriting real code behind. As a workaround, we decided\nto leave these 2 branches untouched, and instead overwrite the first ldc.i4 instruction of the\nIF- and ELSE-part, where we know we have 5 (even 10) bytes available at each location. This\nresults in additional branches, but as this does not seem to be a problem for dnspy, we can live\nwith it. Note that the fact these 2 branch instructions remain as they are is the reason we do not\nconsider them as control instructions, so they are not noped out in the patch method. Note\nthat we could use the same approach for the no-fragmentation case, but decided to not do this,\nmainly because it would be more complicated to implement it without offering advantages.\n\n  - BRANCH_MXOR: This is basically identical to BRANCH.\n\nFinally, we can implement Switch’s patch method. Note that we do not need to change jumps into the\ninitial states, as they already point to the right place. Patching occurs in several stages:\n\n  - nop out the main loop construct (where the main loop’s XOR is calculated), up to and including the\nbranch that follows the switch instruction. As this code was never fragmented, we can go for the\neasy way here.\n\n  - For all blocks, except end blocks:\n\n**– nop out all control instructions (keep in mind that the conditional and optional unconditional**\nbranch instructions of a BRANCH/BRANCH_MXOR type are not affected by this).\n**– Should a state not have been actually used in the emulation, an INFO warning is printed: this is**\nnot exactly an error, but still unusual. Then the whole “real code” block is nop-ed out as well.\n**– For SIMPLE and MXOR suffixes (where block.next_state_else == -1), just patch over an**\nunconditional branch to the calculated next state - we know this can’t overwrite any real code.\n**– For the two BRANCH types we differ between the fragmented case (if a br/br.s follows) and**\nthe monolithic case. In the first case, we overwrite the two first ldc.i4 instructions of the 2\nbranches; we find these by extracting the jump addresses of the conditional and the unconditional branch. Otherwise, we modify the conditional branch to one new target, and put an\nunconditional branch behind.\n```\n   # patch: patch in all required branch and nop codes:\n   def patch(self, lines: Dict[int, sark.code.line.Line]) -> None:\n      # nop out switch loop as it could trigger unwanted crossreferences:\n      l = lines[switch.cont_addr]\n      while True:\n        self.patcher.nop_inst(l)\n        if is_branch(l.bytes[0]):\n           break\n\n```\nNCSC • GovCERT.ch **25**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\n```\nl = l.next\n\n```\n```\nfor block in switch.blocks:\n  if block.is_end or block.is_ret:\n     continue\n\n```\n```\n        # nop out all control instructions:\n        for ctrl_inst in block.suffix.ctrls:\n           self.patcher.nop_inst(ctrl_inst)\n        # nop out all unusuaed states:\n        if block.next_state == -1:\n           print(f”INFO: block {block.state} at VA {block.start} is ”\n              f”unused - code will be nopped out”)\n           self.patcher.nop_code(lines[block.start], block.end)\n           continue\n        # and patch in branches:\n        if block.next_state_else == -1:\n           # State has a unique follower (is not a branch): patch in a\n           # unconditional br instruction\n           self.patcher.patch_branch(block.suffix.addr,\n                          switch.blocks[block.next_state].start,\n                          overwrite_unconditional=True)\n        else:\n           # State has an actual branch:\n           if lines[block.suffix.addr].next.insn.mnem in (”br”, ”br.s”):\n             # Followed by a br/br.s: fragmentation. Long branches might not fit,\n             # so put these over subsequent ldc instructions:\n             self.patcher.patch_branch(\n                 lines[block.suffix.addr].insn.operands[0].addr,\n                 switch.blocks[block.next_state].start,\n                 overwrite_unconditional=True)\n             self.patcher.patch_branch(\n                 lines[block.suffix.addr].next.insn.operands[0].addr,\n                 switch.blocks[block.next_state_else].start,\n                 overwrite_unconditional=True)\n           else:\n             # Otherwise (2 ldc instructions follow) there is enough space\n             size = self.patcher.patch_branch(\n                 block.suffix.addr,\n                 switch.blocks[block.next_state].start,\n                 overwrite_unconditional=False)\n             self.patcher.patch_branch(\n                 block.suffix.addr + size,\n                 switch.blocks[block.next_state_else].start,\n                 overwrite_unconditional=True)\n\n#### Results and Lookout\n\n```\nThe deobfuscator script only reports one function, Class6::smethod_1 as failed because the initial content of the state variable could not be found out. It actually happens at VA 5322 (ldc.i4 0xB4A56FF0),\nbut the situation is a bit complicated due to several switch constructs combined with a try. Another\nfunction, GClass14::method_5, reports several unusues states and results in code dnspy can’t handle.\nThis is a quite long function and needs forther study. It seems to contain a switch statement inside a\nnon-end state of another switch statement, which explains the current inability to deal with it.\n\nAll other 90 obfuscated functions seem to have worked - we did not check if they all make sense though.\n\nNCSC • GovCERT.ch **26**\n\n\n-----\n\n**Unflattening ConfuserEx .NET Code in IDA** 2022-09-16\n\nThere were occasional unusued states reported, but whereever we checked, these states indeed did not\ncontain any real code, so this might just be a normal obfuscator artifact.\n\nSource code is available on https://github.com/govcert-ch/ConfuserEx_IDAPython/\n\nNCSC • GovCERT.ch **27**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        },
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://www.govcert.ch/downloads/whitepapers/Unflattening-ConfuserEx-Code-in-IDA.pdf",
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-16 - Unflattening ConfuserEx Code in IDA.pdf"
    ],
    "report_names": [
        "Unflattening-ConfuserEx-Code-in-IDA.pdf",
        "2022-09-16 - Unflattening ConfuserEx Code in IDA.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716498,
    "ts_updated_at": 1743041159,
    "ts_creation_date": 1663315409,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/6985858274b3af283ca285fd67c70d651f05f445.pdf",
        "text": "https://archive.orkl.eu/6985858274b3af283ca285fd67c70d651f05f445.txt",
        "img": "https://archive.orkl.eu/6985858274b3af283ca285fd67c70d651f05f445.jpg"
    }
}