{
    "id": "dbaca58e-c8f2-44dd-8409-28dbacebc7bd",
    "created_at": "2023-01-12T15:03:06.255393Z",
    "updated_at": "2025-03-27T02:05:36.713688Z",
    "deleted_at": null,
    "sha1_hash": "dc198f8bfab2ada49828c1c8da25ec9fdd8477f9",
    "title": "2021-04-13 - Keeping an eye on CloudEyE (GuLoader) - Reverse engineering the loader",
    "authors": "",
    "file_creation_date": "2022-05-28T17:44:14Z",
    "file_modification_date": "2022-05-28T17:44:14Z",
    "file_size": 2664789,
    "plain_text": "# References\n\n**[cert.pl/en/posts/2021/04/keeping-an-eye-on-guloader-reverse-engineering-the-loader/](https://cert.pl/en/posts/2021/04/keeping-an-eye-on-guloader-reverse-engineering-the-loader/)**\n\nCloudEye (originally GuLoader) is a small malware downloader written in Visual Basic that's\nused in delivering all sorts of malicious payloads to victim machines. Its primary function is to\ndownload, decrypt and run an executable binary off a server (commonly a legitimate one like\nGoogle Drive or Microsoft OneDrive).\n\nAt the time of writing this article, the malicious code can be split into two parts:\n\nThe core of the program that performs VM checks, downloads the code, decrypts and\nruns it\nA small wrapper that hides the core by encrypting it with a simple xor algorithm\n\nWhile the outer layer is pretty tiny and straightforward, mimicking it and manually unpacking\nthe core can be a bit of a headache. In this article, we'll explain how one can leverage IDA\nPro functionalities to simplify this process.\n\nSample analysed:\n\n\n-----\n\nThe first thing you want to do while reverse-engineering Visual Basic binaries in IDA is grab a\ncopy of [vb.idc. It's a super useful IDA script that parses the embedded VB metadata and](https://www.hex-rays.com/products/ida/support/freefiles/vb.idc)\nprovides you with much more information about the binary than the original analysis.\n\nCompare the number of detected event entry points before running the script:\n\nAnd after:\n\n\n-----\n\nLocating the malware entry point is still not trivial, though. You can iterate over all discovered\nentry points and judge if there's anything suspicious or not, but that can become quite\ntedious, and you can still miss some better-hidden code.\n\nSometimes, a good method is to search for all `add instructions and find the \"odd one\" with`\na large immediate value sticking out. You can do that in IDA either by selecting `Search ->`\n```\nText or if you're aspiring to be a power-user: by quickly tapping Alt + t .\n\n```\nMake sure you check the `Find all occurrences box, this will take IDA a bit longer, but it`\nwill allow you to inspect all matches at once.\n\nNow, navigate to the function in question:\n\n\n-----\n\nAnd press `tab to see the matching decompilation (as usual, the decompiler does most of`\nthe job for us):\n\nWith the malware entry address `0x4023CE we can now begin analyzing the real loader.`\nLet's jump to the entry address by selecting `Jump ->` `Jump to address (shortcut` `g )`\n\nSurprisingly, there's no code there, just a bunch of data.\n\nThat's because IDA didn't know to follow the code reference; to fix that, we'll have to mark\nthe data as code ourselves. Start by undefining the fragment `Edit -> Undefine (shortcut`\n```\nu )\n\n```\n\n-----\n\nThis will split the large chunk of data into single-byte lines:\n\nNow we can once again jump to `0x4023CE (the original line contained many bytes, and IDA`\ndoesn't know which one to follow and decides to stay on the first byte) and mark the data as\ncode `Edit -> Code (shortcut` `c ).`\n\nThis will automatically disassemble all reachable code blocks and functions.\n\nWe can almost immediately notice that this isn't an ordinary function, but something rather\nweird is going on: there are many jumps with random data between them. We can clear it up\na bit by grouping the data between code blocks together and adding a few arrows:\n\n\n-----\n\nSome of our avid readers will surely recognize this pattern from our Dissecting Smoke\nLoader article. The main takeaway was that while manually reconstructing the code flow and\ncreating a new disassembly is possible; usually, the best method is to let IDA decompiler\ndeal with such obfuscations.\n\nBut if we try to create a new function at the start address ( Edit -> Functions -> Create\n```\nFunction shortcut p ), all we get is this annoying error message:\n.text:00402FEE: The function has undefined instruction/data at the specified address.\nYour request has been put in the autoanalysis queue.\n\n```\nThat's because IDA wasn't able to disassemble the code at the given address; let's see what\nthe fuzz is about.\n\n\n-----\n\nWell, yes, it doesn t look too correct. Instructions in the form of `jmp short near ptr`\n```\n<addr>+<number> should almost always raise a red flag for you. It very often means that\n\n```\nthe jmp (or any other code-flow-altering instruction) tries to jump into the middle of already\ndefined code/data. In this case, though, it looks like IDA just made an error, and we have to\nmark the data as code manually, similarly as we had done previously.\n\nGood as new! We may have to repeat this several times before we get all parts correct.\n\nAt some point, though, we'll come across a fragment that no longer looks like correct x86\ncode:\n\n\n-----\n\nThat's the code that gets decrypted in previous code blocks; naturally, IDA won't decompile\ninvalid instructions. We can get around that using (at least) 2 methods:\n\nby selecting the code segments, we want to include in our newly-created function\nby patching the last `jmp instruction to` `ret, which will cut off the last invalid block`\nfrom our function\n\nWe'll go with the first method as it's a bit more elegant and simple; for any adventurous\nreaders the `Edit -> Patch program menu and a good x86 opcode reference (like`\n[http://ref.x86asm.net/coder32.html) should be more than enough to try out the other method.](http://ref.x86asm.net/coder32.html)\n\nSelecting the whole memory range by dragging the mouse is a bit boring and can sometimes\ndeselect the selected code on its own. We'll use the `Edit -> Begin selection (shortcut`\n```\nAlt + l ) command. Position the cursor just before the final jmp instruction, begin the\n\n```\nselection, go to the loaders entry point ( 0x4023CE ) and create a new function.\n\nIf everything goes correctly, the relevant fragment in the sidebar should change its color to\nblue:\n\n```\n-->\n\n```\n\n-----\n\nAnd you should be able to tap `Tab and view the simple decompilation pseudocode:`\n\nThe logic is actually quite simple, but the code can get much more bloated and confusing in\nother samples.\n```\nvoid sub_4023CE()\n{\n int v0; // ecx\n char *v1; // eax\n void (*v2)(void); // eax\n int i; // ecx\n v0 = 21564845;\n do\n {\n  __asm { finit }\n  --v0;\n }\n while ( v0 );\n v1 = &rtcCos;\n do\n  --v1;\n while ( *v1 != \"\\x90ZM\" );\n v2 = (*(v1 + 1075))(0, 40960, 4096, 64);\n for ( i = 0; i != 22396; i = i - 40 + 44 )\n  *(v2 + i) = _mm_cvtsi64_si32(_m_pxor(_mm_cvtsi32_si64(*(&loc_403F3F + i)),\n_mm_cvtsi32_si64(0x59DA0A67u)));\n v2();\n JUMPOUT(0x403F34);\n}\n\n```\nGoing step by step:\n\n\n-----\n\n```\nv0 21564845;\ndo\n{\n __asm { finit }\n --v0;\n}\n\n```\nThis is a simple sleep snippet, nothing super interesting there.\n```\nv1 = &rtcCos;\ndo\n --v1;\nwhile ( *v1 != \"\\x90ZM\" );\nv2 = (*(v1 + 1075))(4300, 0, 0, 40960, 4096, 64);\n\n```\nThis is a bit more interesting, it fetches the pointer to `rtcCos from` `MSVBVM60.DLL and`\nthen iterates downrange to find the images base address. It then uses that address to\ncalculate a function address by adding `1075 to the pointer.`\n\nIf we load the dll in IDA and navigate to the fetched address ( 0x732A0000 + 1075 * 4 ) we\ncan learn that it's `VirtualAlloc .`\n\nSo this is all just a sneaky a way of calling it without clearly indicating it in imports. Let's\nmove on.\n```\nfor ( i = 0; i != 22396; i = i - 40 + 44 )\n *(v2 + i) = _mm_cvtsi64_si32(_m_pxor(_mm_cvtsi32_si64(*(&loc_403F3F + i)),\n_mm_cvtsi32_si64(0x59DA0A67u)));\n\n```\nThis part copies `22396 bytes from` `0x403F3F into the newly allocated buffer dexoring it`\nwith the constant `0x59DA0A67 in the process.`\n\nWe can get the decrypted core without debugging the binary using a short Python script:\n```\nimport struct\nfrom malduck import xor\ndata = xor(key=struct.pack(\"<I\", 0x59DA0A67), data=get_bytes(0x403F3F, 22396))\nwith open(\"decrypted.bin\", \"wb\") as f:\n  f.write(data)\n\n```\nAnd finally, the program jumps into the newly copied buffer.\n```\nv2();\n\n```\nTune in next time to the second part, where we'll describe some of the CloudEyE's functions\nand discuss how we can extract the download URLs and the encryption key from unpacked\n[samples automatically using Malduck.](https://github.com/CERT-Polska/malduck)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-13 - Keeping an eye on CloudEyE (GuLoader) - Reverse engineering the loader.pdf"
    ],
    "report_names": [
        "2021-04-13 - Keeping an eye on CloudEyE (GuLoader) - Reverse engineering the loader.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535786,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1653759854,
    "ts_modification_date": 1653759854,
    "files": {
        "pdf": "https://archive.orkl.eu/dc198f8bfab2ada49828c1c8da25ec9fdd8477f9.pdf",
        "text": "https://archive.orkl.eu/dc198f8bfab2ada49828c1c8da25ec9fdd8477f9.txt",
        "img": "https://archive.orkl.eu/dc198f8bfab2ada49828c1c8da25ec9fdd8477f9.jpg"
    }
}