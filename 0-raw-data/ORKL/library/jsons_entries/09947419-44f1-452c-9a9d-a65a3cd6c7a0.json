{
    "id": "09947419-44f1-452c-9a9d-a65a3cd6c7a0",
    "created_at": "2022-10-25T16:48:17.552103Z",
    "updated_at": "2025-03-27T02:15:24.846636Z",
    "deleted_at": null,
    "sha1_hash": "8f6d47d7261f87a25b93801d2dc76b52358c6cf6",
    "title": "",
    "authors": "",
    "file_creation_date": "2016-02-24T01:56:03Z",
    "file_modification_date": "2016-02-24T01:56:10Z",
    "file_size": 2323079,
    "plain_text": "# SECURITY\n\n\nW H I T E P A P E R\n\n##### A FireEye® Company\n\n### MATRYOSHKA MINING\n\n#### Lessons from Operation\n RussianDoll, January 2016\n\n By Michael Bailey\n\n# SECURITY\n\n\n-----\n\n###### Introduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n\n Lay of the Land – Static Analysis with IDA. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n\n Beneath the Surface – Dynamic Analysis with WinDbg. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n\n Digging Deeper – Analysis of a win32k.sys Exploit. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n\n Striking Gold – Building Red Team Tools. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n\n Conclusion. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n\n\n**About This Paper**\n\nConsultants at Mandiant, a FireEye Company, have helped evaluate and enhance the cyber security programs of\ncustomers of all sizes across a range of industries around the world. This paper draws on the combined experience of\nour consultants over the course of hundreds of these service engagements. While we have withheld some identifying\ndetails for the privacy of our clients, the stories are real. The insights, advice, and examples presented here represent\nmore than a decade of work helping clients reduce risk and improve their security posture.\n\n\n-----\n\n### INTRODUCTION\n\n###### This article provides a multi-faceted analysis of the exploit payload referenced in the FireEye Operation RussianDoll[1] blog post. The information herein is intended for malware triage analysts, reverse engineers, and exploit analysts with a full understanding of x86 and basic experience with IDA, and provides tools and background information to recognize and analyze other, future exploits. This article goes on to discuss how red team analysts can apply these principles to carve out exploit functionality or augment exploits to produce tools that will enhance operational effectiveness.\n\n\nerein, we will study the exploit for\nCVE-2015-1701[2] embedded within the\nun-obfuscated 64-bit RussianDoll\n\n## H\n\npayload (MD5 hash 54656d7ae9f6b89413d5b2\n0704b43b10). If you don’t have a copy of this\nparticular binary, you can follow along with an\nopen-source proof of concept (varying in its\ndetails, but having similar functionality)[3].\n\nWe’ll first walk through the payload and see how\nto loosely identify what it does once it has gained\nkernel privilege. Then, we’ll discuss how to get\nhigher-resolution answers from reverse\nengineering by using WinDbg to confirm\nassumptions, manipulate control flow, and\nobserve exploit behavior. Building on this and\nother published sources, we’ll assemble a\ntechnically detailed exploit analysis by examining\nthe relevant portions of win32k.sys. Finally, we’ll\nclose by discussing how to extract and augment\nthis exploit to load encrypted, unsigned drivers\ninto the Windows 7 x64 kernel address space.\n\n\n###### Lay of the Land – Static Analysis\n with IDA\n\nWe will first survey the lay of the land by static\nanalysis with IDA. If you’re new to IDA, check out\nSkull Security’s 2010 blog about using IDA to\ndissect the Energizer Trojan[4]. For a more in-depth\ntreatment, Practical Malware Analysis[5] is very\ninstructive. Finally, MSDN offers a useful review\nof the x64 processor architecture[6].\n\nOur first lead has been given to us: an exploit in\nthis sample gains SYSTEM privileges by abusing\nthe CreateWindowEx API. So, we drop it into IDA\nand follow the p-type xref for CreateWindowExW\nand see that CreateWindowExW is referenced by\na call instruction in the StartAddress thread\nroutine. Figure 1 shows the relevant call setup for\nCreateWindowEx.\n\n\n1 [https://www.fireeye.com/blog/threat-research/2015/04/probable_apt28_useo.html](https://www.fireeye.com/blog/threat-research/2015/04/probable_apt28_useo.html)\n\n2 [http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1701](http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1701)\n\n3 [Available at https://github.com/hfiref0x/CVE-2015-1701/](https://github.com/hfiref0x/CVE-2015-1701/)\n\n[4 https://blog.skullsecurity.org/2010/taking-apart-the-energizer-trojan-part-3-disassembling](https://blog.skullsecurity.org/2010/taking-apart-the-energizer-trojan-part-3-disassembling)\n\n\n-----\n\n**Figure 1:**\nCreateWindowEx\ncall setup for\nlpClassName\n\n\nMicrosoft’s documentation for CreateWindowEx[7] indicates that the function will create an instance of\nthe window class whose name is specified in its second argument, lpClassName, which in this case we can\ntrace back to the string “TEST” Figure 2 shows the relevant setup for the call to RegisterClass.\n\n\n**Figure 2:**\nWindow Class name\nand structure\n\n\nFrom here, we can also see that the window\nprocedure is the callback sub_14001230. The\nwindow procedure is of particular interest\nbecause it is normally executed after\n\n\nCreateWindowEx is called, so we examine it.\nFigure 3 shows the first significant block of code\nin the window procedure, containing a pair of\nunknown local variables, an unknown global\nvariable, and an unknown function pointer.\n\n\n7 [https://msdn.microsoft.com/en-us/library/windows/desktop/ms632680(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms632680(v=vs.85).aspx)\n\n\n-----\n\n**Figure 3:**\nCreateWindowEx\ncall setup for\nlpClassName\n\n\n**Figure 4:**\nInitialization of\nglobal referenced in\nwindow procedure\n\n\nWe find the initialization of dword_140012AFC by following the lone write xref to it. Figure 4 shows that\ndword_140012AFC receives the return value of GetCurrentProcessId.\n\nHence, we rename dword_140012AFC to “currentPID” and move on to pursuing qword_140012AD8.\nFigure 5 shows the sole write xref to this function pointer, with its value coming from GetProcAddress.\n\n\n-----\n\n**Figure 3:**\nCreateWindowEx\ncall setup for\nlpClassName\n\n\nWe can see that the lpProcName argument to\nGetProcAddress is\n“PsLookupProcessByProcessId”; according to\nMSDN[8], PsLookupProcessByProcessId is exported\nby NtosKrnl.exe, making it a kernel routine.\n\nThis lookup is preceded by a call to a subroutine\nthat uses the undocumented\nNtQuerySystemInformation function to obtain\nmodule information for ntoskrnl.exe[9]. The\nmalware then calls LoadLibraryExA to load\nntoskrnl.exe, calls GetProcAddress to find\n\n\nPsLookupProcessByProcessId, and calculates the\nkernel address of the routine.\n\nWe now know that the window procedure\nsupplies the malware’s PID to\nPsLookupProcessByProcessId to obtain a\npointer to its own executive process (_\nEPROCESS) block. Figure 6 shows the window\nprocedure code with the\nPsLookupProcessByProcessId procedure\naddress and the malware’s _EPROCESS block\nboth labeled.\n\n\n8 [https://msdn.microsoft.com/en-us/library/windows/hardware/ff551920(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/hardware/ff551920(v=vs.85).aspx)\n\n9 [A source code example of this can be seen at http://www.rohitab.com/discuss/topic/40696-list-loaded-drivers-with-ntquerysysteminformation/](http://www.rohitab.com/discuss/topic/40696-list-loaded-)\n\n\n-----\n\n**Figure 6:**\nWindow procedure\nobtaining malware’s\n_EPROCESS block\n\n\nFigure 7 shows the subsequent code block, which also calls PsLookupProcessByProcessId, this time\nproviding the hard-coded constant 4 for System.\n\n\n**Figure 7:**\nWindow procedure\nobtaining\n_EPROCESS block\nfor PID 4\n\n\nSeven instructions later, we see that the malware\nsteals the process token from the System\nprocess. Figure 8 shows data being copied from\nthe offset within dword_140012AF8 (which\n\n\ncontains 0x208) in the System process’s\n_EPROCESS block into the malware’s. As we will\nsee later, this is the address of the privileged\ntoken used by the System thread.\n\n\n-----\n\n**Figure 8:**\nWindow procedure\ncopying data from\nSystem _EPROCESS\nblock\n\n\nfunctions[10]. Figure 9 shows the strings from the\nOperation RussianDoll payload, which include\nthe kernel function we found,\nPsLookupProcessByProcessId.\n\nback a long time, such as MS11-046[11]. You can\nconfirm your suspicions about this function by using\na kernel debugger to set a process-specific\nbreakpoint on nt!PsLookupProcessByProcessId so\nthat you can examine the call stack, which is what we\nwill do next.\n\n\n**Figure 9:**\nStrings from malware\nsample including\nPsLookupProcess\nByProcessId\n\n\nWhat if there was no helpful lead? What would\ntip off a triage analyst to the presence of a kernel\nescalation of privilege? One sign is an unpacked\nbinary containing strings referencing native API\n\nLooking this function up on MSDN showed that it is\nexported by ntoskrnl.exe, making it a kernel function.\nA reference to such a function constitutes a lead that\nshould be followed. This same technique has been\nobserved in local privilege escalation exploits going\n\n10 [https://en.wikipedia.org/wiki/Native_API](https://en.wikipedia.org/wiki/Native_API)\n\n11 [https://www.exploit-db.com/docs/18712.pdf](https://www.exploit-db.com/docs/18712.pdf)\n\n\n-----\n\n###### Beneath the Surface – Dynamic Analysis with WinDbg\n\nTo observe the activity of a kernel privilege\nescalation exploit, our best bet is a kernel debugger\nsuch as WinDbg. WinDbg can invasively debug\nuser-space malware and provides powerful tools to\nobserve its activity in kernel space. MSDN provides\nextensive software and setup information regarding\nWinDbg[12, 13, 14, 15]. You might also consider using\nVirtualKD[16] to quickly connect to VMware guests.\n\nWARNING _– Do not install or run malware without_\n_first setting up a safe environment._\n\n\nRecall from the previous section that the\nmalware copies data from offset 208h within the\nSystem process’s _EPROCESS block to the\nmalware’s _EPROCESS block. To confirm our\nsuspicion that 208h is the offset of the access\ntoken within the _EPROCESS block, we can use\nWinDbg’s dt command:\n\ndt nt!_EPROCESS\n\nFigure 10 shows output from WinDbg that\ncorroborates our identification of the token\nstealing routine within the malware.\n\n\n**Figure 10:**\nAbbreviated listing\nof _EPROCESS type\nin WinDbg\n\n\n12 [https://msdn.microsoft.com/en-us/library/windows/hardware/ff551063(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/hardware/ff551063(v=vs.85).aspx)\n\n13 [https://msdn.microsoft.com/en-us/library/windows/hardware/ff538143(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/hardware/ff538143(v=vs.85).aspx)\n\n[14 https://msdn.microsoft.com/en-us/library/windows/hardware/ff556866(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/hardware/ff556866(v=vs.85).aspx)\n\n[15 https://support.microsoft.com/en-us/kb/311503](https://support.microsoft.com/en-us/kb/311503)\n\n\n-----\n\nand checks whether it is running at the\nSECURITY_MANDATORY_LOW_RID (1000h)\nintegrity level, a procedure that is documented by\nMicrosoft[17]. The malware only executes its exploit\nif it detects that it is running in a low-integrity\nprocess. Figure 11 shows the call to\nGetSidSubAuthority and the comparison against\nSECURITY_MANDATORY_LOW_RID.\n\nthe dt command to read the ImageFileName\nmember of the _EPROCESS block:\n\nbp nt!PspInsertProcess “dt nt!_EPROCESS @\nrcx ImageFileName”\n\nWe can then run the malware. Figure 12 shows\n54656d7ae9f6b89413d5b20704b43b10.exe\nactivating the PspInsertProcess breakpoint.\n\n\n**Figure 11:**\nLow-integrity\nprocess check as\nseen in IDA\n\n\nThere at offset 0x208 is the Token. After the\nmalware copies the token from the System process,\nthe kernel’s Security Reference Monitor gives the\nmalware the royal treatment: SYSTEM-level access.\n\nObserving the escalation of privilege in action,\nhowever, takes a little more work. Static analysis\nreveals that the malware calls GetSidSubAuthority\n\nTo induce the malware to escalate privilege, we’ll\nhalt it before it slips past this check, lie to it about\nits access level, and catch it calling\nPsLookupProcessByProcessId. To catch the\nmalware before it gets too far, we use an\ninstrumented breakpoint to trigger before the\nProcess Manager adds each process to the process\nlist. We can also get some additional mileage out of\n\n\n**Figure 12:**\nPspInsertProcess\nbreakpoint activated\nby malware\nexecution\n\n\nTo let nt!PspInsertProcess do its job, we continue (with gu: “go up”) until nt!PspInsertProcess returns to\nnt!NtCreateUserProcess, at which point our malware’s process object has been added to the process list.\nFigure 13 shows the abbreviated output of the !process command.\n\n17 [https://msdn.microsoft.com/en-us/library/bb625966.aspx](https://msdn.microsoft.com/en-us/library/bb625966.aspx)\n\n\n-----\n\n**Figure 13:**\nProcess object for\n54656d7ae9f6b8\n9413d5b20704b4\n3b10.exe\n\n\ninvasively debug the malware. Figure 14 shows this\ntwo-step procedure which requires us to issue the\ng command to allow a process context switch.\n\nbp /p fffffa80`0242cb30\nadvapi32!GetSidSubAuthority\n\nFigure 15 shows this breakpoint activating within\na function whose job it is to jump to the real\nGetSidSubAuthority function.\n\n\n**Figure 14:**\nInvasively debugging\n54656d7ae9f6b8\n9413d5b20704b4\n3b10.exe\n\n\nWe could then copy the address of the process\nobject and supply it to the /i (“invasive”) switch of\nthe .process command, causing WinDbg to\n\nWe next set a user-space breakpoint on\nadvapi32!GetSidSubAuthority, specifying the bp\ncommand’s /p (“process”) switch to break only\nwhen the malware calls this function:\n\n\n-----\n\n**Figure 15:**\nGetSidSubAuthority\nbreakpoint activated\nby malware\n\n\n**Figure 16:**\nLow-integrity\nprocess check as\nseen in WinDbg\n\n\n**Figure 17:**\nChecking rcx against\n1000h\n\n\nWe run until GetSidSubAuthority returns into the malware’s code, and disassemble the code at the\ninstruction pointer. Figure 16 shows that this lands us in the malware’s low-integrity check.\n\nStepping through the low-integrity check, we see that we are about to compare the value of the register\necx with the hard-coded constant 1000h. But as Figure 17 shows, rcx instead contains 2000h.\n\nTo make the malware execute its exploit, we tell it that it is running in a low-integrity process by writing\nthe value 1000h to ecx:\n\nr @ecx = 1000h\n\n\n-----\n\nWe then set a process-specific breakpoint to trigger\nwhen the malware executes the kernel function\nnt!PsLookupProcessByProcessId. Figure 18 shows\nrcx being manipulated, the process-specific\n\n\nbreakpoint being set on\nPsLookupProcessByProcessId, and the new\nbreakpoint being activated by the malware privilege\nescalation code after execution is resumed.\n\n\n**Figure 18:**\nInducing and\nhalting on privilege\nescalation\n\n\nTo confirm the privilege escalation, we examine the stack trace. Figure 19 shows the stack trace, which\nconfirms that we caught the privilege escalation.\n\n\n**Figure 19:**\nAnnotated stack\ntrace of kernel\nprivilege escalation\n\n\nAs can be seen above, the malware sample’s\nmodule name, 54656d7ae9f6b89413d5b20704b\n43b10, appears in both user space and kernel\nspace. This is how the malware manages to copy\n\n\nthe access token from the System thread’s\nEPROCESS block into its own as we observed by\nreverse engineering. Escalation: achieved.\n\n\n-----\n\nthe original byte value in that location, and patch it\nwith the single-byte opcode for the icebp[18]\ninstruction, F1h. At runtime, this will get the kernel\ndebugger’s attention, at which point you can fix the\ninstruction and move on. Figure 20 shows the\nprocess of rewinding the instruction pointer by one\nbyte and restoring the original opcode.\n\norder to automate this repetitive procedure and\nfocus on the analysis, you could use a WinDbg\nscript, such as the following.\n\n\n**Figure 20:**\nCatching and fixing\nan icebp instruction\n\n\nWhat if the malware executed the\nGetSidSubAuthority call before the conclusion of\nthe two-step invasive debugging procedure? A\nmore reliable (but more time-intensive) approach\nto gain control is to locate the file offset of an\ninstruction where you want to break, take note of\n\nIn the course of analysis, this process may need to\nbe repeated many times, as well as the process of\naltering the result of GetSidSubAuthority to\nshepherd the malware into escalating privilege. In\n\n18 http://www.rcollins.org/secrets/opcodes/ICEBP.html\n\n\n-----\n\n**Listing 1:**\nWinDbg script to\nhalt exploit\n\n```\n$$ Run Operation RussianDoll payload until its wndproc is executed, dumping\n$$ @rcx (hWND) as win32k!tagWND. Requires that payload has been interrupted\n\n```\n$$ and WinDbg process context is in payload due to an icebp patch at file\n```\n$$ offset 2A57h.\n.printf “Fixing icebp\\n”\nr rip=@rip-1\neb @rip 0x57\n.printf “Setting breakpoint on GetSidSubAuthority\\n”\n.reload /user\nbp /p @$proc advapi32!GetSidSubAuthority\n.printf “Running...”\ng\n.printf “Altering GetSidSubAuthority SID to be low integrity (1000h)\\n”\n.printf “This instigates exploit to run\\n”\ngu\np\nr ecx=1000h\n.printf “Setting breakpoint on RegisterClassW\\n”\nbp /p @$proc user32!RegisterClassW\n.printf “Running...”\ng\n.printf “Setting breakpoint on lpfnWndProc before calling RegisterClassW\\n”\nbp /p @$proc poi(@rcx+8)\ng\n.printf “Halted at WndProc\\n”\nu @rip\n\n```\n\nAfter confirming that the reverse engineering analysis was correct, the most interesting question\nbecomes: how does the exploit work? In the next section, we explore this in technical detail.\n\n\n-----\n\n###### Digging Deeper – Analysis of a win32k.sys Exploit\n\nTrendMicro has published an analysis of CVE2015-1701[19]. No doubt this is based on a much\nmore technical analysis that touches on the\nintricacies of many Windows internals. Here, we\nobserve the exploit’s interaction with win32k.sys\nto synthesize a more technically elaborate\nanalysis of the vulnerability. This process will\nallow us to identify the concept of operations of\nthis exploit in greater detail, and will build\nexperience necessary to independently analyze\nwin32k.sys exploits without the aid of any other\npublished analysis in future cases.\n\nExploit analysis hinges on familiarizing oneself not\nonly with the malicious sample at hand, but also\nthe vulnerable software itself, which is the context\nin which an exploit does its work. In many cases,\nthis can entail extensive reverse engineering.\nFortunately, we will see that win32k.sys\nexploitation is a well-documented topic. In\naddition to the literature, there are sometimes\npublicly available resources disclosing old\nWindows NT source code, although these can be\nsubject to takedowns[20]. In lieu of source code, the\nReactOS project[21] can serve as a useful model of\nmany Windows NT kernel internals and\ndefinitions. Additionally, Alex Ionescu’s Native\nDevelopment Kit (NDK)[22] provides some\ndefinitions that can be useful for stand-alone\ndevelopment, such as proof of concept work.\n\nTo get started with our analysis, we note that\nTrendMicro’s analysis alludes to a “Server Side\nWindow Proc” flag. Literature can be found dating\nback several years[23] as well as more recently[24]\ndiscussing the role of the server-side window\nprocedure flag within the window object. Win32k.\nsys defines a structure called tagWND which\ncontains information about each window object\nderived from a given window class. Within the\ntagWND object are the bServerSideWindowProc\nflag and the lpfnWndProc function pointer, which\n\n\nwe will use as anchors for our analysis of CVE2015-1701. These and other members can be\nexplored within an active kernel debugging or\ncrash analysis session of WinDbg with the dt\ncommand, such as:\n\ndt win32k!tagWND\n\nSo, we understand that this exploit works by\ncausing win32k.sys to set the\nbServerSideWindowProc flag within a tagWND\nobject while a user-specified function address is\nresident in the lpfnWndProc member of the same\nwindow object; this results in the user-specified\naddress being executed with kernel privilege. But\nhow exactly does this happen?\n\nRecall that in Figure 19, we saw\nwin32k!xxxCreateWindowEx in the call stack at\nthe time when the exploit achieved kernel\nexecution. We can begin by finding the address of\nthe tagWND structure and watching accesses to\nits bServerSideWindowProc flag (byte at offset\n2Ah) and lpfnWndProc (pointer at offset 90h)\nmembers to identify how the flag and window\nprocedure arrive at the values they do. Win32k.\nsys uses a special function,\nwin32k!HMAllocObject, to create window\nobjects, which is how we can identify the new\nwindow as it is created. Within\nxxxCreateWindowEx, there is a single call to\nHMAllocateObject, hence breaking on this\naddress should yield the address of the new\nwindow object within the register rax after the\nHMAllocObject call returns.\n\nSince bServerSideWindowProc is a member of a\nbitfield, we choose to break on a one-byte write to\nthe exact byte that it occupies at PWND+2Ah.\nFigure 21 shows WinDbg breaking on write\naccess to the byte location of\nbServerSideWindowProc upon the first access by\nthe SetOrClrWF routine. This call stack provides\nuseful information later in the analysis.\n\n\n19 [http://blog.trendmicro.com/trendlabs-security-intelligence/exploring-cve-2015-1701-a-win32k-elevation-of-privilege-vulnerability-used-in-targeted-attacks/](http://blog.trendmicro.com/trendlabs-security-intelligence/exploring-cve-2015-1701-a-win32k-elevatio)\n\n20 [For example, here is a Chinese github user’s WinNT4 repository that was subject to a DMCA takedown: https://github.com/njdragonfly/WinNT4](https://github.com/njdragonfly/WinNT4)\n\n[21 https://www.reactos.org/](https://www.reactos.org/)\n\n[22 https://code.google.com/p/native-nt-toolkit/](https://code.google.com/p/native-nt-toolkit/)\n\n\n-----\n\n**Figure 21:**\nFirst bitfield access\nin same byte as\nbServerSideWindowProc\n\n\nThe SetOrClrWF function generically sets or\nclears window flags. Pausing to analyze\nSetOrClrWF, we find that the third argument\ndictates which flag is set, and 0x204 is the unique\nvalue for this argument that will induce\n\n\nSetOrClrWF set the bServerSideWindowProc\nflag. Knowing this, the second access to\nPWND+0x2Ah is notable because SetOrClrWF is\nprovided with the value 0x204. Figure 22 shows\nthe specific flags being set with SetOrClrWF.\n\n\n**Figure 22:**\nServer-side window\nprocedure flag set\n\n\n-----\n\nFrom the call stack (see Figure 21), we can see\nthat the malware calls SetWindowLongPtr, which\nis responsible for ultimately causing\nbServerSideWindowProc to become set (see\nFigure 22). The argument that the exploit provides\nto SetWindowLongPtr is 0xfffffffc, which is a\nDWORD representation of -4. Microsoft's\ndocumentation for SetWindowLongPtr[25] defines\nthe symbol GWLP_WNDPROC as -4, stating that\nit \"Sets a new address for the window procedure.\"\nFurther analysis shows that the malware uses this\nto set its window procedure to the default window\nprocedure. Because win32k.sys defines the\ndefault window procedure,\nxxxSetWindowDataLong sets\nbServerSideWindowProc to indicate that it trusts\nthis procedure to be executed in the kernel.\n\n\nIt would make sense to repeatedly use the gu\ncommand in WinDbg to unwind the stack and see\nhow the malware’s function is invoked, however\nthis can lead to some confusion due to the way\n64-bit user-mode callbacks behave on Windows\nand what information is available to WinDbg to\ninterpret system state. At this point, we go back to\nthe sample and see that the function that calls\nSetWindowLongPtr was written to a location\nwithin the process environment block (PEB)\nmember named KernelCallbackTable. Figure 23\nshows a location within the kernel callback table\nbeing calculated and saved in register rbx before\nits value is exchanged with the address of the\nmalware’s malicious callback.\n\n\n**Figure 23:**\nUser callback hooking\n\n\n25 [https://msdn.microsoft.com/en-us/library/windows/desktop/ms644898(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms644898(v=vs.85).aspx)\n\n\n-----\n\nwith a normal callback table. Figure 24 shows how\nWinDbg can be used to find the offset of the\ncallback table from the PEB.\n\ndps poi($peb+58h) L69h\n\nFigure 25 shows an excerpt of the resulting list of\nfunctions, all of which are within user32.dll except\nfor the one located at offset 0x36, which instead is\nin the malware’s address space.\n\n\n**Figure 24:**\nDetermining PEB\nKernelCallbackTable\noffset\n\n\nWe can learn the name of the function whose\naddress was overwritten by inspecting the\ncallback table and looking for the malicious\nfunction in the callback table, then comparing this\n\nUsing the offset 58h, we can use the dps (“Display\nwords and Symbols”) command in WinDbg to\nexamine the relevant callbacks. Judging by the\npresence of NULL pointers and the nomenclature\nof symbol names within the table, we can infer\nthat there are 105 (69h) callbacks in the table. To\ndump them, we can issue the following command:\n\n\n**Figure 25:**\nMalware kernel\ncallback table\n\n\nFigure 26 shows a parallel excerpt of the callback table in a normal 64-bit process, revealing that the\noverridden callback in the malware is known as _ClientCopyImage[26].\n\n26 Note that if you choose to compare against a 32-bit process on a 64-bit machine, you will see WoW64 equivalents for these callbacks; in this case, disregard the\n“whcb” prefix and focus on the rest of the API name.\n\n\n-----\n\n**Figure 26:**\nKernel callback table\nfor 64-bit svchost.exe\n\n\nWe can quickly search through win32k.sys for\nsymbols named like ClientCopyImage with\nWinDbg, as follows:\n\nx win32k!*clientcopyimage*\n\nDoing so, we find only one symbol with a name\nsimilar to ClientCopyImage, namely\nxxxClientCopyImage. IDA Pro shows three\nreferences to this function, any of which could be\na call site we need to investigate:\n\n\n\n- xxxCreateWindowSmIcon+B1\n\n- xxxCreateClassSmIcon+8D\n\n- xxxLoadDesktopWallpaper+1A0\n\nA quick approach to triaging these for\ninvestigation is to set a breakpoint on each of\nthem, along with the malicious callback, to see\nwhich breakpoint is hit immediately prior to the\ncallback. Figure 27 shows that this reveals\nxxxCreateClassSmIcon as the function\nresponsible for calling the malware’s\nClientCopyImage callback.\n\n\n**Figure 27:**\nLocating callback site\n\n\n-----\n\nFigure 28 shows an excerpt from xxxClientCopyImage, which adds 18h to 1Eh and passes the resulting\nconstant, 36h, to the KeUserModeCallback function.\n\n\n**Figure 28:**\nxxxClientCopyImage\nsetting up call\nto user32!_\nClientCopyImage\n\n\nKeUserModeCallback ultimately uses this\nargument as an index into the callback table in the\nPEB, resulting finally in the call to the hooked\nClientCopyImage callback located 36h bytes off\nthe base of the callback table. Meanwhile, the call\nstack at xxxCreateClassSmIcon+0x8d reveals that\nxxxCreateWindowEx was the caller of\nxxxCreateClassSmIcon.\n\nAt this point, we’ve watched\nbServerSideWindowProc and worked backwards\nto assemble three key facts about the exploit’s\ninteraction with win32k.sys:\n\n- The exploit hooks the _ClientCopyImage\ncallback before xxxCreateWindowEx\nbegins its work\n\n- xxxCreateWindowEx calls\nxxxCreateWindowSmIcon, which in turn\ntransitions back to user mode and calls the\nhooked _ClientCopyImage function\n\n\n\n- Within the malicious _ClientCopyImage hook,\nthe exploit calls SetWindowLongPtr, which\nchanges the malware’s window procedure to a\nserver-side (kernel) default window procedure\n\nThe final question is, how does the malicious\nwindow procedure ever get executed once the\nexploit has told win32k.sys to set point its window\nprocedure to one of the kernel's default routines?\nWe can learn this by monitoring changes to\nlpfnWndProc within the window object.\n\nUsing the same technique as before of breaking\non HMAllocObject within xxxCreateWindowEx,\nwe can locate the window object and break on\nwrite accesses to its window procedure,\nlpfnWndProc. When we do, we note that the first\naccess is the one we already knew about, which is\ncaused by the malware’s _ClientCopyImage\ncallback. The second write to lpfnWndProc\nanswers our question. Figure 29 shows\nxxxCreateWindowEx writing to lpfnWndProc.\n\n\n**Figure 29:**\nAssignment of\nlpfnWndProc from\ntagCLS\n\n\n-----\n\nobject. Figure 30 shows the location of this\noverwrite, which occurs directly after the call to\nxxxCreateClassSmIcon within\nxxxCreateWindowEx. Here, the result of\n\ntechniques described in this article provide a\npath toward identification of some classes of\nexploits, particularly those that attack the kernel.\nIn this case, we identified kernel symbol names\nwithin the malware. Following the references to\nthese names yielded function pointers that we\nused as breakpoint locations in a kernel debugger\nto confirm that kernel execution was achieved.\nWhen the breakpoint was not hit, we identified\nconditions (the LOW_INTEGRITY RID value)\nthat needed to be manipulated to coerce the\nmalware into launching its exploit. In the case of\na previously unseen and uncategorized malware\nsample, the stack trace at this point can provide a\nstarting list of potentially vulnerable functions to\nexamine. After tracing the malware and the\nvulnerable software, it should be possible to\ndraw a conclusion about which code was\nexploited. As for how it was exploited, this can\nsometimes require deeper insight into the\nvulnerable codebase, which can be gained\nthrough source code (if available), literature\nreview, and reverse engineering.\n\n\n**Figure 30:**\nlpfnWndProc\noverwrite\n\n\nThe answer is that prior to this point in the\nwindow creation process, xxxCreateWindowEx\nhas yet to execute the normal code path in which it\nassigns a window procedure to the new window\n\nMapClientNeuterToClientPfn is assigned to\nlpfnWndProc for the new window.\nMapClientNeuterToClientPfn’s job is to compare\nthe window procedure that the application\noriginally registered in its window class against\nnumerous standard window procedures and\nfinally return either the appropriate standard\nwindow procedure, or the unique function\nregistered by the user-space application if no\nmatch is found. xxxCreateWindowEx then copies\nthis value into lpfnWndProc. The problem is that\nthis is not accompanied by any evaluation of\nwhether the bServerSideWindowProc flag should\nbe set or cleared. Because there is no such check,\nand because xxxCreateWindowEx indirectly\ncalled a user-controlled pointer that can be\nhooked by a malicious application,\nxxxCreateWindowEx is vulnerable to a kernel\nescalation of privilege that will execute arbitrary\nuser-specified code.\n\nIn the absence of any public analysis or\nknowledge of what we are looking at, how do we\ncome to these conclusions independently? The\n\n\n-----\n\nOther exploits may not execute arbitrary code.\nLiterature and source code may be unavailable.\nDifferent leads may warrant different analysis\nstrategies based on tracing backward from\nobservations to identify what code is being\ninfluenced and how. The specifics of analyzing a\nparticular exploit will vary, but it is hoped that the\ntechniques employed above can help you build\nhypotheses, confirm them, and move on to the\nsubsequent step of your analysis.\n\n###### Striking Gold – Building Red Team Tools\n\nIf you are a red team operator, you may be asked\nto safely extract an exploit from a malware sample\nin order to escalate privileges or circumvent\ncontrols in a particular scenario. There is evidence\nto suggest that the developers of the Operation\nRussianDoll payload have borrowed source code\nfrom many public references. Several techniques\nand code snippets found in the RussianDoll\npayload can be found on the Internet, including:\n\n- Getting information about modules loaded in\nthe kernel[9]\n\n- Copying the System access token to one’s own\nprocess[11]\n\n- Evaluating the integrity level of one’s process[17]\n\nRed team operators can likewise apply code\nreuse to augment exploits such as this into even\nmore powerful capabilities. Depending on the\nsophistication of the controls and processes in\nyour client’s organization, this can be a valuable\nway to advance the goals of your operation while\nimproving the detection, prevention, and\nresponse capabilities of that group. For example,\ntwo-factor authentication in conjunction with\neffective antivirus can increase the difficulty of\nmonitoring keystrokes or clipboard activity to\ngain unauthorized access to sensitive resources.\nIn such cases, red teams may benefit from a\nkernel-privileged tool that can evade antivirus\nand collect the information necessary to achieve\nthe red team goal. Here, we outline the\n\n\nchallenges of extracting an exploit from malware\nand building a tool that can download, decrypt,\nand load an unsigned kernel driver without ever\nhaving to write it to disk.\n\nWARNING – Do not test kernel software on a\n_machine where you are not willing to lose all your files_\n_due to a programming error._\n\nThe first tasks required to repurpose an exploit\nfound in the wild have already been described\nabove. Step one is to acquire a sample and observe\nit in operation in a safe environment to verify that\nthe exploit was successful (as in the section\n“Beneath the Surface – Dynamic Analysis with\nWinDbg”). The second step is to understand the\nminimum functionality necessary to duplicate the\nexploit. Because the exploit code can be\nintertwined with extraneous malware\nfunctionality, the process of identifying the vital\nelements is made much easier by finding or\nproducing an analysis of the vulnerability itself (as\nin the section “Digging Deeper – Analysis of a\nwin32k.sys Exploit”). Once the core code of the\nexploit has been identified, it is possible to\nreproduce its functionality in source code.\n\nIn the case of the RussianDoll payload, the functional\nelements of the exploit are roughly as follows:\n\n- Registering a window class\n\n- Hooking the _ClientCopyImage callback\n\n- Creating a window\n\n- Copying the System access token\n\nEach functional element may comprise several\npieces. For example, hooking the _ClientCopyImage\ncallback entails at least four steps:\n\n- Authoring a malicious callback to set the\ndefault window procedure\n\n- Locating the kernel callback table\n\n- Altering memory protection for the kernel\ncallback table (to permit write access)\n\n- Overwriting the _ClientCopyImage pointer\nwith the malicious callback address\n\n\n-----\n\nReproducing each element of the exploit in source\ncode may require the hard-coded offsets from the\nmalware to be reproduced in the software.\nHowever, a better way to write an\nunderstandable, stable, and maintainable proof of\nconcept is to understand and define the correct\nstructures. Understanding takes experience, such\nas knowing (or researching) what it looks like\nwhen a process accesses its PEB. As for\nstructures, Alex Ionescu’s NDK[21] contains a set of\ndefinitions that may be useful to this end.\n\nOnce you have reproduced the exploit\nfunctionality, you can apply the same testing\nmethods from verifying the original exploit to\nvalidate your proof of concept. Once validation is\ncomplete, you should test the proof of concept on\neach release of Windows that your team will use it\nagainst. If the exploit executes or manipulates\nkernel code, then it is wise to also test against\nchecked builds of Windows[27] and to use Driver\nVerifier[28] to ensure that the kernel and vulnerable\ndrivers are not left in an unstable state due to\ntheir exploitation. Nobody wants to be known for\nproducing exploits that result in blue screens.\n\nAt this point, with a proof of concept in hand that\nis capable of executing privileged code, it is hard\nnot to wonder why the RussianDoll authors\nstopped at getting SYSTEM privileges. Why not\nload a kernel rootkit to further avoid detection?\nAs it turns out, there are many good reasons not\nto do this. Attackers are economically motivated\nto expend the smallest amount of effort possible\nto accomplish each mission. Thus, effort might be\nwasted crafting anything more sophisticated\nthan what is necessary. Additionally,\nimplementing increased kernel functionality\nincreases the risk of crashing a system during an\noperation, which in turn increases the expense of\ntesting and mission assurance.\n\nThe risk and cost associated with kernel-based\ncapabilities can be worthwhile for scenarios\nwhere kernel privilege offers a unique capability\n\n\nthat cannot be duplicated by user-space code,\nor where stealth parameters entail a low-level\ncapability. Examples that arise from time to time\nin the course of red team operations are hiding\nprocesses or logging keystrokes without\ninterference from antivirus. For this reason, we\nexplore what is necessary to develop an\nunsigned driver loader capable of loading\nencrypted, unsigned driver images over the\nwire. Beyond its powerful offensive potential,\nthis sort of tool also has interesting implications\nin computer security research.\n\nBuilding an unsigned driver loader requires only a\nfew features on top of the exploit code:\n\n- Parsing PE-COFF driver images\n\n- Dynamic linking\n\n- Writing kernel code to be executed from a\nuser address space\n\n- Optionally downloading and/or decrypting\nthe payload\n\nThis process is made significantly easier by\nobtaining a copy of the Windows Driver Kit[29]. A\nWindows kernel programming tutorial is outside\nthe scope of this article, but one can find a very\npragmatic introduction in chapter 2 of “Rootkits:\nSubverting the Windows Kernel”[30].\n\nFor this project, we lay out four milestones:\n\n- Write a stand-alone driver that can\nload other drivers\n\n- Integrate kernel code with the\nuser-space exploit\n\n- Add network code\n\n- Add encryption\n\nAssuming you already have a test driver, the\nfirst milestone is to write a driver that can load\nother drivers. You could certainly start\naugmenting the user-space exploit directly, but\nwriting a stand-alone driver makes it easier to\nuse tools like WinDbg and Driver Verifier to\nvalidate the initial capability.\n\n\n27 [https://msdn.microsoft.com/en-us/library/windows/hardware/Ff543457(v=VS.85).aspx](https://msdn.microsoft.com/en-us/library/windows/hardware/Ff543457(v=VS.85).aspx )\n\n28 [https://msdn.microsoft.com/en-us/library/windows/hardware/ff545448(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/hardware/ff545448(v=vs.85).aspx)\n\n[29 https://msdn.microsoft.com/en-us/windows/hardware/gg454513.aspx](https://msdn.microsoft.com/en-us/windows/hardware/gg454513.aspx)\n\n[30 http://www.amazon.com/Rootkits-Subverting-Windows-Greg-Hoglund/dp/0321294319](http://www.amazon.com/Rootkits-Subverting-Windows-Greg-Hoglund/dp/0321294319)\n\n\n-----\n\nTo parse the resulting buffer, you can opt to include\nWinNT.h and navigate the PE headers yourself,\nhowever it is more productive to examine and reuse\nexisting code. There are multiple user-space loader\nimplementations[34,35] available that can provide a\nstart. These will require you to hammer the PE\nheader definitions from WinNT.h into compatibility\nwith kernel data types, but this is well worth the\nwork to avoid reinventing the wheel altogether[36].\n\nNext, you’ll need to identify and import kernel\nfunctions. Figure 31 shows CFF Explorer[37] displaying\nimports for hello.sys: DbgPrint and KeBugCheckEx.\n\n\n**Figure 31:**\nCFF Explorer\ndisplaying hello.sys\nimports\n\n\nIn writing a driver loader, you have the option of\nwriting code using ZwCreateFile and\nZwReadFile[31] to read the driver from disk, or\nsimply encoding a buffer in your test driver for\nthe time being. Since we’re ultimately planning to\npull the payload down from the network, there’s\nnot much point in writing code to read it from\ndisk. So, I suggest using xxd[32] with the -include\nflag to translate your hello.sys into a C-style\nbuffer declaration (Vim for Windows[33]\nconveniently includes a port of xxd).\n\n31 See the Windows Driver Kit help files for API details.\n\n32 [http://linux.die.net/man/1/xxd](http://linux.die.net/man/1/xxd)\n\n[33 http://www.vim.org/download.php#pc](http://www.vim.org/download.php#pc)\n\n[34 https://github.com/fancycode/MemoryModule](https://github.com/fancycode/MemoryModule)\n\n[35 https://github com/stephenfewer/ReflectiveDLLInjection](https://github.com/stephenfewer/ReflectiveDLLInjection)\n\n\n-----\n\nfrom ntoskrnl.exe. If your payload references other\nmodules, you will need to write code to locate each\nmodule base address and parse the driver to locate\nits exported functions. Figure 32 shows import\nresolution for a simple keystroke logger as an\nexample of a module that only requires functions\nexported by ntoskrnl.exe.\n\nOnce you have tested the stand-alone loader\ndriver, you can migrate it to user space. In the\ncase of CVE-2015-1701, there is proof of\nconcept code available on the Internet[3]. Since\nyour loader is likely to import more than one or\ntwo functions, you’ll want to refactor the\nNtQuerySystemInformation wrapper[39] so you\ncan conveniently look up arbitrary kernel\nfunctions from user-space. Then, initialize a\n\n\n**Figure 31:**\nCFF Explorer\ndisplaying hello.sys\nimports\n\n\nAs long as your payload only references ntoskrnl.exe,\nyour loader can use the kernel’s\nMmGetSystemRoutineAddress routine[38] to resolve\nsymbols exported by the kernel or Hardware\nAbstraction Layer (HAL). This does not significantly\nconstrain the utility of the resulting loader since\nmany rootkits can be written using only functions\n\nAfter you’ve parsed the headers and populated\nthe import table, you’re ready to call the entry\npoint. To rapidly test and develop without\nrebooting, you’ll want to implement an unload\nroutine to call ChildPDO->OnUnload if one has\nbeen registered by the payload. Before\nintegrating your loader with an exploit, test with\nDriver Verifier and a checked build of Windows,\nto detect any subtle errors.\n\n\n38 [https://msdn.microsoft.com/en-us/library/windows/hardware/ff554563(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/hardware/ff554563(v=vs.85).aspx)\n\n[39 http://www.rohitab.com/discuss/topic/40696-list-loaded-drivers-with-ntquerysysteminformation/](http://www.rohitab.com/discuss/topic/40696-list-loaded-drivers-with-ntquerysysteminformation/)\n\n\n-----\n\nfunction pointer for each function imported by\nyour stand-alone loader driver, and port the\ndriver to user space. Consider whether you plan\nto leak the memory you allocated and leave the\npayload permanently resident in memory, or\ncreate some way for a user-space control\napplication to call OnUnload and cause the\nmemory to be cleared and reclaimed.\n\nWith the heavy lifting done, you can add\nnetworking code. Depending on the egress rules\nand security controls in place at the\norganizations you are assessing, you might\nchoose to directly use WinSock[40] and an\narbitrary port, or you might choose WinHTTP[41]\nor WinInet[42] and use the HTTPS protocol.\n\nIf you are not using an encrypted protocol to\ntransmit your driver, you may wish to add\nencryption. Depending upon your development\nschedule, size constraints, and other factors, you\nmight choose to either directly integrate\nsomething like the Rijndael AES algorithm[43]\n(taking care to implement your own cipher mode),\nor build against a full-featured library[44,45]. Note\nthat if you opt to build against a full-featured\nlibrary, it is easier to do so at this stage with the\ndriver loader already ported to user space, than\nporting the library to the kernel to integrate it\nwith the stand-alone driver.\n\nThis describes the engineering effort required to\nbuild an unsigned driver loader on top of a kernel\nescalation of privilege exploit. The resulting code\ncan be reused by integrating it with any exploit\nthat provides execution of arbitrary code in the\nkernel. There are limitations, however. For\ninstance, this code cannot load filesystem\n\n\nmini-filters[46] because the FltRegisterFilter[47]\nroutine requires configuration data from the\nregistry. Even so, this loader can work with many\ndifferent kernel rootkits.\n\nThe existence of publicly available code that can\nproduce a powerful rootkit loader underscores\nthe importance of prompt patching, the\nineffectiveness of user-space endpoint security\nsolutions in some cases, and the potential for\nsimulating advanced red team scenarios. The code\nwe’ve seen used by the RussianDoll developers\n(and by myself) is widely available[17], easily reused[9],\nand often many years old[11].\n\nFor defenders, this should hit home how feasible it\nis for a moderately sophisticated attacker to\ncobble together a powerful and stealthy capability\nand launch it the same day that an exploit\nbecomes available to them. This underscores the\nurgency of closing the loop on patch cycles.\n\nFor security researchers, this kind of tool\nexemplifies that observing user-space behaviors\nand features is insufficient to evaluate threats. It\nalso demonstrates why virtualization and\nwhole-system analysis will be key for\ninstrumenting and detecting the most advanced\nthreats: you can’t trust kernel-based security\nsoftware because you can’t trust the kernel.\n\nFinally, as a red teamer, this provides avenues for\nadvanced attacks. Our hypothetical example was\ncollecting a two-factor token from a user in a case\nwhere endpoint security solutions have interfered\nwith commonly used tools, but your imagination is\nthe only limit on how this can be applied.\n\n\n40 [https://msdn.microsoft.com/en-us/library/windows/desktop/ms740632(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms740632(v=vs.85).aspx)\n\n[41 https://msdn.microsoft.com/en-us/library/windows/desktop/aa384081(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa384081(v=vs.85).aspx)\n\n[42 https://msdn.microsoft.com/en-us/library/windows/desktop/aa385331(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa385331(v=vs.85).aspx)\n\n[43 http://www.efgh.com/software/rijndael.htm](http://www.efgh.com/software/rijndael.htm)\n\n[44 http://openssl org/](http://openssl.org/)\n\n\n-----\n\n### CONCLUSION\n\nIn this analysis, we shared tools and techniques that\ndefensive security professionals can use to conduct\nenhanced analysis of malware, and discussed the\nsteps necessary for red team analysts to synthesize\npowerful offensive tools based on malware used by\nadvanced persistent threat actors. As defensive\nsecurity controls raise the bar to attack, attackers\nwill employ increasingly sophisticated techniques to\n\n**About FireEye**\n\n\ncomplete their mission. Understanding the\nmechanics and impact of these threats, then, is the\nnext step in systematically discovering and\ndeflecting the coming wave of advanced attacks.\n\nWe would like to thank Yu Wang of the FireEye\nexploit analysis team for his notes on CVE-20151701, which accelerated the timeline for\nassembling a coherent analysis approach.\n\n\nFireEye protects the most valuable assets in the world from those who have them in their sights. Our combination of\ntechnology, intelligence, and expertise—reinforced with the most aggressive incident response team—helps eliminate\nthe impact of security breaches. We find and stop attackers at every stage of an incursion. With FireEye, you’ll detect\nattacks as they happen. You’ll understand the risk these attacks pose to your most valued assets. And you’ll have the\nresources to quickly respond and resolve security incidents. The FireEye Global Defense Community includes more\nthan 2,700 customers across 67 countries, including over 157 of the Fortune 500.\n\n\n-----\n\n###### For more about Mandiant Compromise Assessments, visit:\n\n www.fireeye.com\n\nA FireEye® Company\n\n\nMandiant, a FireEye Company | 703.683.3141 | 800.647.7020 | info@mandiant.com | **www.mandiant.com |** **www.fireeye.com**\n\n© 2016 FireEye, Inc. All rights reserved. Mandiant and the M logo are registered\ntrademarks of FireEye, Inc. All other brands, products, or service names are or may be\ntrademarks or service marks of their respective owners. WP.MM.EN.012016\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        },
        {
            "id": "99593a68-7f6e-400e-9a9f-a707f66d2e72",
            "created_at": "2022-11-23T11:07:14.353321Z",
            "updated_at": "2022-11-23T11:07:14.353321Z",
            "deleted_at": null,
            "name": "AGRO",
            "url": "https://apt.threattracking.com",
            "description": "APT Groups and Operations Spreadsheet",
            "reports": null
        },
        {
            "id": "6825b8cb-7d82-43d2-b0b0-d51c7e255b42",
            "created_at": "2023-01-06T13:46:37.642134Z",
            "updated_at": "2023-01-06T13:46:37.642134Z",
            "deleted_at": null,
            "name": "MISPGALAXY",
            "url": "https://www.misp-project.org/galaxy.html",
            "description": "MISP Galaxy Clusters",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2016/2016.03.09.Operation_RussianDoll/wp-mandiant-matryoshka-mining.pdf",
        "https://www2.fireeye.com/rs/848-DID-242/images/wp-mandiant-matryoshka-mining.pdf"
    ],
    "report_names": [
        "wp-mandiant-matryoshka-mining",
        "wp-mandiant-matryoshka-mining.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "e3767160-695d-4360-8b2e-d5274db3f7cd",
            "created_at": "2022-10-25T16:47:55.914348Z",
            "updated_at": "2025-03-27T02:05:17.411172Z",
            "deleted_at": null,
            "main_name": "IRON TWILIGHT",
            "aliases": [
                "ATK5 ",
                "Blue Athena ",
                "BlueDelta ",
                "FROZENLAKE ",
                "Fancy Bear ",
                "Fighting Ursa ",
                "Forest Blizzard ",
                "GRAPHITE ",
                "Group 74 ",
                "PawnStorm ",
                "STRONTIUM ",
                "Sednit ",
                "Snakemackerel ",
                "Sofacy ",
                "TG-4127 ",
                "Tsar Team ",
                "APT28 "
            ],
            "source_name": "Secureworks:IRON TWILIGHT",
            "tools": [
                " Downdelph",
                " Drovorub",
                " EVILTOSS",
                " HIDEDRV",
                " Headlace",
                " LoJack",
                " Powershell Empire",
                " SCONATO",
                " SEDUPLOADER",
                " SHARPFRONT",
                " Scaramouche",
                " Sedkit Exploit Kit",
                " Sofacy downloader",
                " X-Agent",
                " X-Tunnel",
                " Zebrocy",
                " reGeorg",
                "DEALERSCHOICE"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "730dfa6e-572d-473c-9267-ea1597d1a42b",
            "created_at": "2023-01-06T13:46:38.389985Z",
            "updated_at": "2025-03-27T02:00:02.821388Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "FROZENLAKE",
                "BlueDelta",
                "SNAKEMACKEREL",
                "TG-4127",
                "ITG05",
                "TA422",
                "Fancy Bear",
                "FANCY BEAR",
                "Sednit",
                "IRON TWILIGHT",
                "G0007",
                "Sofacy",
                "Forest Blizzard",
                "GruesomeLarch",
                "Pawn Storm",
                "Tsar Team",
                "STRONTIUM",
                "ATK5",
                "Blue Athena",
                "APT-C-20",
                "Group 74",
                "SIG40",
                "Grizzly Steppe",
                "Fighting Ursa",
                "T-APT-12",
                "UAC-0028"
            ],
            "source_name": "MISPGALAXY:APT28",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "ae320ed7-9a63-42ed-944b-44ada7313495",
            "created_at": "2022-10-25T15:50:23.671663Z",
            "updated_at": "2025-03-27T02:00:55.518748Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "APT28",
                "IRON TWILIGHT",
                "SNAKEMACKEREL",
                "Group 74",
                "Sednit",
                "Sofacy",
                "Pawn Storm",
                "Fancy Bear",
                "STRONTIUM",
                "Tsar Team",
                "Threat Group-4127",
                "TG-4127",
                "Forest Blizzard",
                "FROZENLAKE"
            ],
            "source_name": "MITRE:APT28",
            "tools": [
                "Wevtutil",
                "certutil",
                "Forfiles",
                "DealersChoice",
                "Mimikatz",
                "ADVSTORESHELL",
                "Komplex",
                "HIDEDRV",
                "JHUHUGIT",
                "Koadic",
                "Winexe",
                "XTunnel",
                "Drovorub",
                "CORESHELL",
                "OLDBAIT",
                "Downdelph",
                "XAgentOSX",
                "USBStealer",
                "Zebrocy",
                "Fysbis",
                "LoJax"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d2516b8e-e74f-490d-8a15-43ad6763c7ab",
            "created_at": "2022-10-25T16:07:24.212584Z",
            "updated_at": "2025-03-27T02:02:10.141001Z",
            "deleted_at": null,
            "main_name": "Sofacy",
            "aliases": [
                "APT 28",
                "ATK 5",
                "Blue Athena",
                "BlueDelta",
                "FROZENLAKE",
                "Fancy Bear",
                "Fighting Ursa",
                "Forest Blizzard",
                "Grey-Cloud",
                "Grizzly Steppe",
                "Group 74",
                "GruesomeLarch",
                "ITG05",
                "Iron Twilight",
                "Operation DealersChoice",
                "Operation Dear Joohn",
                "Operation Komplex",
                "Operation Pawn Storm",
                "Operation Russian Doll",
                "Operation Steal-It",
                "Pawn Storm",
                "SIG40",
                "Sednit",
                "Snakemackerel",
                "Sofacy",
                "Strontium",
                "T-APT-12",
                "TA422",
                "TAG-0700",
                "TAG-110",
                "TG-4127",
                "Tsar Team",
                "UAC-0028",
                "UAC-0063"
            ],
            "source_name": "ETDA:Sofacy",
            "tools": [
                "ADVSTORESHELL",
                "AZZY",
                "Backdoor.SofacyX",
                "CHERRYSPY",
                "CORESHELL",
                "Carberp",
                "Computrace",
                "DealersChoice",
                "Delphacy",
                "Downdelph",
                "Downrage",
                "Drovorub",
                "EVILTOSS",
                "Foozer",
                "GAMEFISH",
                "GooseEgg",
                "Graphite",
                "HATVIBE",
                "HIDEDRV",
                "Headlace",
                "Impacket",
                "JHUHUGIT",
                "JKEYSKW",
                "Koadic",
                "Komplex",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "LoJack",
                "LoJax",
                "MASEPIE",
                "Mimikatz",
                "NETUI",
                "Nimcy",
                "OCEANMAP",
                "OLDBAIT",
                "PocoDown",
                "PocoDownloader",
                "Popr-d30",
                "ProcDump",
                "PythocyDbg",
                "SMBExec",
                "SOURFACE",
                "SPLM",
                "STEELHOOK",
                "Sasfis",
                "Sedkit",
                "Sednit",
                "Sedreco",
                "Seduploader",
                "Shunnael",
                "SkinnyBoy",
                "Sofacy",
                "SofacyCarberp",
                "SpiderLabs Responder",
                "Trojan.Shunnael",
                "Trojan.Sofacy",
                "USB Stealer",
                "USBStealer",
                "VPNFilter",
                "Win32/USBStealer",
                "WinIDS",
                "Winexe",
                "X-Agent",
                "X-Tunnel",
                "XAPS",
                "XTunnel",
                "Xagent",
                "Zebrocy",
                "Zekapab",
                "carberplike",
                "certutil",
                "certutil.exe",
                "fysbis",
                "webhp"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716497,
    "ts_updated_at": 1743041724,
    "ts_creation_date": 1456278963,
    "ts_modification_date": 1456278970,
    "files": {
        "pdf": "https://archive.orkl.eu/8f6d47d7261f87a25b93801d2dc76b52358c6cf6.pdf",
        "text": "https://archive.orkl.eu/8f6d47d7261f87a25b93801d2dc76b52358c6cf6.txt",
        "img": "https://archive.orkl.eu/8f6d47d7261f87a25b93801d2dc76b52358c6cf6.jpg"
    }
}