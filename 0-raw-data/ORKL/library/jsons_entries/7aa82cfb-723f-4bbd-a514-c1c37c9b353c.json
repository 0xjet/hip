{
    "id": "7aa82cfb-723f-4bbd-a514-c1c37c9b353c",
    "created_at": "2023-01-12T15:09:42.403222Z",
    "updated_at": "2025-03-27T02:05:33.735429Z",
    "deleted_at": null,
    "sha1_hash": "b212846aaa1fc8104202f59e1f8cdc5cf6ecb735",
    "title": "2021-10-26 - DRIDEX- Analysing API Obfuscation Through VEH",
    "authors": "",
    "file_creation_date": "2022-05-27T23:24:25Z",
    "file_modification_date": "2022-05-27T23:24:25Z",
    "file_size": 758955,
    "plain_text": "# DRIDEX: Analysing API Obfuscation Through VEH\n\n**[0ffset.net/reverse-engineering/malware-analysis/dridex-veh-api-obfuscation/](https://www.0ffset.net/reverse-engineering/malware-analysis/dridex-veh-api-obfuscation/)**\n\nOctober 26, 2021\n\n\n-----\n\n[Chuong Dong](https://www.0ffset.net/author/chuong-dong/)\n26th October 2021\nNo Comments\n\nDRIDEX is one of the most famous and prevalent banking Trojans that dates back to around\nlate 2014. Throughout its improvement and variations, DRIDEX has been successful in\ntargeting the financial services sector to steal banking information and crucial user\ncredentials. Typically, DRIDEX samples are delivered through phishing in the form of Word\nand Excel documents containing malicious VBA macros.\n\nIn this post particularly, we will dive into the theory behind DRIDEX’s anti-analysis method of\nobfuscating Windows API calls using string hashing and Vectored Exception Handling.\n\nTo follow along, you can grab the sample on MalwareBazaar!\n\nSha256: [ad86dbdd7edd170f44aac99eebf972193535a9989b06dccc613d065a931222e7](https://bazaar.abuse.ch/sample/ad86dbdd7edd170f44aac99eebf972193535a9989b06dccc613d065a931222e7/)\n\n## Step 1: API Resolving Function\n\nUpon performing some basic static analysis on the sample, we can quickly see that the\nDRIDEX DLL has two functions, OutputDebugStringA and Sleep, in its import address\ntable. Considering how DRIDEX is a large piece of malware with many complex\n\n\n-----\n\nfunctionalities, the lack of imports hints to us that the malware resolves most of its API\ndynamically.\n\nWhen entering the DLL’s entry point, we can immediately see a function called with two\nhashes as parameters. This function is called twice from the entry point function, both times\nwith the same value for the first parameters. For the second call, the return value is called as\na function, so we know that sub_6815C0 must be dynamically resolving API through the\nhashes from its parameters. Furthermore, since both calls share the same value for the first\nparameter but different values for the second one, we can assume that the first hash\ncorresponds to a library name, and the second one corresponds to the name of the target\nAPI in that library.\n\n\n-----\n\nWe can further examine sub_6815C0 to confirm this. The subroutine first starts with passing\nthe DLL hash to the functions sub_686C50 and sub_687564. The return value and the API\nhash are then passed into sub_6867C8 as parameters. From this, we can assume the first\ntwo functions retrieve the base of the DLL corresponding to the DLL hash, and this base\naddress is passed to the last function with the API hash to resolve the API.\n\nWhen diving into sub_687564, we can see that DRIDEX accesses the loader data table from\nthe Process Environment Block (PEB), which contains a doubly linked list of loader data\ntable entries. Each of these entries contains information about a loaded library in memory, so\nby iterating through the table, the malware extracts the name of each library, converts it to\nlowercase, and finally hashes it with sub_69D620 and XORs it with 0x38BA5C7B. Each\nlibrary’s hash is compared against the target hash, and the base address of the target library\nis returned if found. This confirms that sub_687564 retrieves the base of the DLL\ncorresponding to the given DLL hash.\n\n\n-----\n\nSimilarly, in sub_6867C8, DRIDEX uses the base address of the target library to access its\nexport table and iterate through the list containing the address of exports’ names. Since API\nnames are stored as UNICODE strings in the export table, the malware converts each API’s\nname to ASCII and hashes it using the same hashing function sub_69D620. The target API\nhash is XOR-ed with 0x38BA5C7B before being compared to the hash of each API name.\nThis confirms to us that sub_6867C8 dynamically retrieves an API from the target library\nusing a given hash.\n\n\n-----\n\n## Step 2: Identifying API Hashing Algorithm\n\nAt this point, we know that sub_69D620 is the hashing algorithm, and the final hash is\nproduced by XOR-ing the function’s return value with 0x38BA5C7B. The core functionality of\nthis function contains SSE data transfer instructions to deal with XMM registers.\n\n\n-----\n\nTypically, it’s not worth the time to analyze the assembly instructions in these cryptographic\nfunctions. For most cases, we can depend on constant values being loaded or used in the\nprogram to pick out the correct algorithm, and tools like Mandiant’s [capa are awesome in](https://github.com/mandiant/capa)\nhelping us automate this process. Unfortunately, capa fails to identify this specific algorithm,\nso we have to analyze the constants on our own.\n\nFortunately, among the three constants being used in this function, one stands out with the\nrepetition of the value 0x0EDB8832, which is typically used in the CRC32 hashing algorithm.\nAs a result, we can assume that sub_69D620 is a function to generate a CRC32 hash from\na given string, and the API hashing algorithm of DRIDEX boils down to XOR-ing the CRC32\nhash of API/DLL names with 0x38BA5C7B.\n\n\n-----\n\nTo quickly check if this hashing algorithm is correct, we can use OALabs s [hashdb plugin for](https://github.com/OALabs/hashdb)\nIDA to test resolving the API resolved in the DLL’s entry point function. First, since DRIDEX’s\nhashes have an additional layer of XOR, we must set 0x38BA5C7B as hashdb’s XOR key\nbefore looking the hashes up using CRC32.\n\nFinally, we can use hashdb to look up the hashes in the sample. Here, we can see that the\nhash 0x1DAACBB7 corresponds correctly to the ExitProcess API, which confirms to us that\nour assumption about the hashing algorithm is correct.\n\n## Step 3: Vectored Exception Handler\n\nUnlike most malware, DRIDEX does not use the call instruction to call APIs. Instead, the\nmalware uses a combination of int3 and retn instructions to call its Windows APIs after\ndynamically resolving them.\n\n\n-----\n\nThis feature is a great anti-analysis trick because it makes both static and dynamic analysis\nharder. Due to the retn instruction, IDA treats every API call as the end of the parent\nfunction. This makes all instructions behind it unreachable and breaks up the control flow of\nthe function’s decompiled code.\n\n\n-----\n\nThe int3 instruction also slows down dynamic analysis since debuggers like x64dbg register\nthe interrupt as an exception instead of swallowing it as a normal breakpoint to avoid\ndebugger detection. This requires the analyst to manually skip over the int3 instruction or\npass it to the system’s exception handlers while debugging.\n\nTo properly call an API, DRIDEX resolves it from hashes dynamically, stores the API’s\naddress in eax, pushes the API’s parameters on the stack, and executes int3 as shown\nabove. However, instead of using the system’s exception handlers to handle this interrupt,\nthe malware registers its own custom handler by calling sub_687980 at the beginning of the\nDLL entry point function.\n\nThe function sub_687980 dynamically resolves RtlAddVectoredExceptionHandler and\ncalls it to register sub_687D40 as a vectored exception handler. This means that when the\nprogram encounters an int3 instruction, sub_687D40 is invoked by the kernel to handle the\ninterrupt and transfer control to the API stored in eax.\n\nThe handler code first checks the exception information structure to see the exception type\nit’s handling. If the type is EXCEPTION_ACCESS_VIOLATION,\n**EXCEPTION_STACK_OVERFLOW, STATUS_HEAP_CORRUPTION, DRIDEX resolves the**\n**TerminateProcess API and calls it to terminate itself by interrupting with int3.**\n\nFor Vectored Exception Handling, system handlers and user-registered handlers are placed\nin a vector or chain. An exception is passed through handlers on this chain until one properly\nhandles it and returns control to the point at which it occurred. In DRIDEX’s handler, if the\ntype is anything else but EXCEPTION_BREAKPOINT (which is invoked by int3), the handler\nreturns 0 (EXCEPTION_CONTINUE_SEARCH) to pass the exception along to another\nhandler.\n\n\n-----\n\nFinally, if the exception type is EXCEPTION_BREAKPOINT, the handler sets up the API in\n**eax to be called. When an exception occurs, the system transfers control from the user**\nthread that triggers the exception to a kernel thread to execute the exception handlers. As\ncontext switching happens, the system saves all registers from the user thread in memory\nbefore executing the kernel thread, in order to properly restore them when the handlers\nfinish. For Vectored Exception Handling, the context record of the user thread containing its\nregisters is stored in the EXCEPTION_POINTERS structure that is passed as a parameter to\nhandlers.\n\nUsing this structure, DRIDEX’s handler accesses the context record and increments the eip\nvalue to have it points to the retn instruction after int3. Because eip is restored from context\nrecord after handlers finish, this sets the user thread to begin executing at the retn\ninstruction after exception handling. Next, the address of the instruction after retn and the\naddress of the API from eax are consecutively pushed on the stack.\n\n\n-----\n\nBelow is what the current user stack looks like at the end of this handler.\n\nAfter the handler returns the EXCEPTION_CONTINUE_EXECUTION code, the user thread’s\ncontext is restored and the malware begins executing at the retn instruction. Because the\n**retn instruction pops the value at the top of the stack and jumps to it, the malware will jump**\nto the address of the resolved API. This becomes a normal stack frame for a function call\nwith esp pointing to the return address and parameters being properly set up on the stack.\nWhen the API returns, DRIDEX continues executing at the address after the retn instruction.\n\n## Step 4: Writing Script To Patch DLL\n\nAfter understanding how DRIDEX uses VEH to call APIs, we can programmatically patch the\nsample to bypass this anti-analysis feature in IDA and debuggers by modifying all “int3,\n**retn” sequences (0xCCC3) to call eax instructions (0xFFD0) in the sample .text section.**\nThis should make IDA’s decompilation work nicely while preventing the execution from being\ninterrupted in our debuggers!\n\n\n-----\n\n```\nimport pefile\nfile_path = '<DRIDEX SAMPLE PATH>'\nfile = open(file_path, 'rb')\nfile_buffer = file.read()\nfile.close()\ndridex_pe = pefile.PE(data=file_buffer)\ntext_sect_start = 0\ntext_sect_size = 0\nfor section in dridex_pe.sections:\n  if section.Name.decode('utf-8').startswith('.text'):\n    text_sect_start = dridex_pe.get_offset_from_rva(section.VirtualAddress)\n    text_sect_size = section.SizeOfRawData\npatched_text_sect =\nfile_buffer[text_sect_start:text_sect_start+text_sect_size].replace(b'\\xCC\\xC3',\nb'\\xFF\\xD0')\nfile_buffer = file_buffer[0:text_sect_start] + patched_text_sect +\nfile_buffer[text_sect_start+text_sect_size:]\nout_path = '<OUTPUT PATH>'\nout_file = open(out_path, 'wb')\nout_file.write(file_buffer)\nout_file.close()\n\n```\n[If you have any questions regarding the analysis, feel free to reach out to me via Twitter.](https://twitter.com/cPeterr)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-10-26 - DRIDEX- Analysing API Obfuscation Through VEH.pdf"
    ],
    "report_names": [
        "2021-10-26 - DRIDEX- Analysing API Obfuscation Through VEH.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536182,
    "ts_updated_at": 1743041133,
    "ts_creation_date": 1653693865,
    "ts_modification_date": 1653693865,
    "files": {
        "pdf": "https://archive.orkl.eu/b212846aaa1fc8104202f59e1f8cdc5cf6ecb735.pdf",
        "text": "https://archive.orkl.eu/b212846aaa1fc8104202f59e1f8cdc5cf6ecb735.txt",
        "img": "https://archive.orkl.eu/b212846aaa1fc8104202f59e1f8cdc5cf6ecb735.jpg"
    }
}