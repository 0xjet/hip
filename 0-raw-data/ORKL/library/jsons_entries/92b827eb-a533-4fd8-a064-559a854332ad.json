{
    "id": "92b827eb-a533-4fd8-a064-559a854332ad",
    "created_at": "2023-01-12T15:01:52.707214Z",
    "updated_at": "2025-03-27T02:05:49.351951Z",
    "deleted_at": null,
    "sha1_hash": "94c1d4eb18fac202684c9fb307455c36aa73f2f2",
    "title": "2017-09-25 - Analyzing the Various Layers of AgentTesla’s Packing",
    "authors": "",
    "file_creation_date": "2022-05-29T01:28:42Z",
    "file_modification_date": "2022-05-29T01:28:42Z",
    "file_size": 4087041,
    "plain_text": "# Analyzing the Various Layers of AgentTesla’s Packing\n\n**[researchcenter.paloaltonetworks.com/2017/09/unit42-analyzing-various-layers-agentteslas-packing/](https://researchcenter.paloaltonetworks.com/2017/09/unit42-analyzing-various-layers-agentteslas-packing/)**\n\nJeff White September 25, 2017\n\nBy [Jeff White](https://unit42.paloaltonetworks.com/author/jeff-white/)\n\nSeptember 25, 2017 at 10:00 AM\n\n[Category: Unit 42](https://unit42.paloaltonetworks.com/category/unit42/)\n\nTags: [AgentTesla,](https://unit42.paloaltonetworks.com/tag/agenttesla/) [dnSpy](https://unit42.paloaltonetworks.com/tag/dnspy/)\n\n[AgentTesla is a fairly popular key logger built using the Microsoft .NET Framework and has shown a substantial rise in usage over the past few](https://en.wikipedia.org/wiki/.NET_Framework)\nmonths.\n\nIt offers all of the standard features of a keylogger but goes beyond the typical confines of this type of software. One particular feature of\ninterest is the custom packer it uses to hide the primary AgentTesla binary. Packers allow for a binary to essentially be wrapped in another\nbinary to mask the original one from detection.\n\n[There are a number of excellent blogs out there covering AgentTesla’s functionality and it’s](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=11&cad=rja&uact=8&ved=0ahUKEwiuguS2j4PWAhXkzIMKHWy1Ass4ChAWCCcwAA&url=https%3A%2F%2Fblog.fortinet.com%2F2017%2F06%2F28%2Fin-depth-analysis-of-net-malware-javaupdtr&usg=AFQjCNG0sqBMWMMIo) [various obfuscations, but having I recently](https://blogs.forcepoint.com/security-labs/part-two-camouflage-netting)\nunpacked a sample and wanted to focus on this particular function and provide some helpful tools to aide in unpacking it.\n\nFor this analysis, I’ll be using a PE32 version AgentTesla file seen in the wild on August 29 with hashth\n“ca29bd44fc1c4ec031eadf89fb2894bbe646bc0cafb6242a7631f7404ef7d15c”. You’ll find AgentTesla delivered commonly via phishing\ndocuments that usually contain VBA macros to download and run a file – like the one in question.\n\nAs it’s a commercial product, you’ll find a lot of variety in the initial carrier files that deliver the AgentTesla binary; however, at some point you’ll\nfind yourself with a PE.\n\n## Thus, begins the journey…\n\n\n-----\n\nsuppose t e st aye o ob uscat o ea y beg s t t e e tse, ca ed o e jpeg p g e e a d a co o a J G t y g to c eate a\nillusion of legitimacy.\n\nThis is a common technique to fool people and they’ve taken it one step further by opening an image when you execute the binary.\n\nThe first executable is a .NET application, which is no surprise since AgentTesla is very well known for being a .NET key logger. To analyze\n.NET applications, I prefer to use the application dnSpy and, once loading up this sample, we can see there is only one namespace of interest\nwith a handful of functions and a byte array.\n\n\n-----\n\nThe Japanese kanji stands out at first glance but I believe this is less about language and more about being a form of obfuscation – I’ll explain\nwhy shortly.\n\nLooking at the Main() function shows a pattern of multiple calls to two other functions.\n\nTake for example the below string.\n\n1 ゆ.く(ゆ.るこ(New Byte() { 129, 148, 157, 176, 144, 129, 163, 219 })),\n\nThe namespace is “ゆ” and the functions are “く” and “るこ”, with the latter taking a byte array as input and then the resulting output of that\nfunction being passed to the former.\n\n\n-----\n\nSta t g t t e st u ct o, t e e a e t o O ope at o s t at occu t at oo s e t o a ues o t e passed byte a ay a d t e\na static XOR key.\n\nLooking at this function deeper, it uses the last value in the byte array as one of the 3 XOR keys, then adjusts the array in size and begins the\ndecoding loop. Starting at the first byte, it will take this number as the second XOR key and increment it each iteration. The final XOR key is\npulled from the GetBytes call on the long string of kanji.\n\nBefore going any further though, can you spot the issue with the function above? It works and successfully decodes the byte array but there is\na flaw in codes logic that threw me for a loop when trying to implement the code in Python.\n\nIf you manually XOR those values together (129 [first byte] ^ 214 [last byte] ^ 12375 [first kanji]), the resulting output isn’t what gets returned\nwithin the debugger. In fact, it’s not even close which left me scratching my head for a while.\n\n1 129^214^12375 = 12288 (0x3000)\n\nInstead, what we end up with is 104 (0x68). It’s clearly wrong though and I assumed I was missing something in what appeared to be a\nrelatively straight forward, par for the course, decoding function. If I XOR the know good result with the two values from the byte array, I end up\nwith 63 (0x3F), otherwise known as “?”.\n\nWhat’s happening is that the GetBytes call is set to use the default system encoding, which in my case is Windows-1252, so the bytes fall\noutside of the acceptable range and all return as 63 (0x3F), regardless of where the index pointer is in the array. Given this, the only two\nvalues I ever need to worry about are within the array itself and I can ignore most of this code.\n\nBelow is a small Python script which will decode the strings passed into it.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\ndef decode(a):\nxorkey = a[-1]\na = a[0:-1]\nb = [0] * len(a)\nnum = 0\ncounter = 0\nmaxlength = len(b) - 1\nwhile counter <= maxlength:\nb[len(b) - 1 - counter] = chr(a[counter] ^ xorkey ^ 0x3f)\ncounter += 1\nreturn \"\".join(b)\n\n>>> a = [129,148,157,176,144,129,163,219]\n>>> decode(a)\n'GetType'\n\n\nAs the string successfully decodes with using XOR key 0x3F, it implies it was also encoded with this value initially, so the default code page\nused by the author when encoding it was also most likely Windows-1252.\n\nThe reason I believe the kanji is more for obfuscation than anything else is because of this and what the XOR key displays, which is nothing\nbut a jumble of random characters without any coherent message.\n\nThis randomness in function and variable names is similar to the techniques they use in later payloads but now with a different character set.\n\nFor the second function, “く” it simply returns a string from the byte array of the previous function.\n\nGoing back to the previously mentioned byte array, it’s quite large and only has one reference inside this code, highlighted below.\n\n\n-----\n\nte t e byte a ay s passed to t e decod g u ct o, t e output s used as put to a e u ct o, うむれぐ, t at s espo s b e o\ndecompressing the data.\n\nOnce decompressed, the new data is returned in a byte array.\n\nAt this point I copied out the list of integers for the byte array and ran it through the decoding Python function and decompressed the it with the\nzlib library into the next payload.\n\n\n1\n2\n3\n\n\nfh = open(\"output\", \"w\")\nfh.write(zlib.decompress(decode(a), -15))\nfh.close()\n\n\n-----\n\noo g at t e e e s o s t at t s a a ed p d\n\nThis was also a .NET file and we can load it into dnSpy for further analysis; however, before doing that I’ll go over the final part of the first\npacker.\n\n\n1\n2\n3\n4\n5\n\n\nDim objectValue As Object =\nRuntimeHelpers.GetObjectValue(NewLateBinding.LateGet(Nothing,CType(NewLateBinding.LateGet(Nothing, “System.Type”,“GetType”,\n“System.Reflection.Assembly”, Nothing, Nothing, Nothing), Type), “Load”, BINARY_ARRAY, Nothing, Nothing, Nothing))\n\nDim objectValue2 As Object = RuntimeHelpers.GetObjectValue(NewLateBinding.LateGet(RuntimeHelpers.GetObjectValue(objectValue),\nNothing, \"GetType\", \"とむ暮.とむ暮\", Nothing, Nothing, Nothing))\n\nNewLateBinding.LateGet(Nothing, CType(NewLateBinding.LateGet(Nothing, Type.[GetType](\"System.Type\", \"GetType\",\n\"System.Activator\", Nothing, Nothing, Nothing), Type), \"CreateInstance\", New Object() { RuntimeHelpers.GetObjectValue(objectValue2)\n}, Nothing, Nothing, Nothing)\n\n\n-----\n\ne c ea ed up t e e coded st gs so you ca see at t s do g but e ect e y, t ta es t e asse b y, oads t, a d ca s t e a\nfunction, “とむ暮.とむ暮”, within it.\n\nThis DLL uses the same byte array string obfuscation as the initial executable.\n\nIn the above image, you can see it begins by checking whether the file “\\\\Products\\\\WinDecode.exe” exists and then will create the\n“\\\\Products\\\\” directory if it does not. After that it will enumerate processes to kill, delete files, establish itself in the registry for persistence and\nother characteristics typical of this malware.\n\nBut, eventually during the execution, you’ll end up at the next part of the unpacking code.\n\n\n1\n2\n3\n\n\nDim obj2 As Object = とむ暮.れなつ(Me.まこうに(Me.こなき(Me.れな())))\nDim うひ硯る As うひ硯る = New うひ硯る()\nReturn うひ硯る.う(\"Nothing\", String.Empty, CType(obj2, Byte()), True)\n\n\nThe first line calls multiple functions - starting on the far right is “れな”. This function can be seen below and creates an object from a PNG file\nin the resources section of the DLL.\n\n## Picture Time\n\nThe PNG itself doesn’t visually show anything of note but static.\n\n\n-----\n\nThe next function “こなき” is a bit more interesting.\n\nThis loads the image as a bitmap and then it will read the pixels in a certain order to build an array from the values for Red, Green, and Blue\nthat get returned.\n\nFor example, if you look at the bottom left of the image (0,192), you will see a dark green with the hex value 0x1AE2C.\n\n\n-----\n\nThe first entries in the array would be 0x2C (Blue), 0xAE (Green), 0x1 (Red)\n\nTo unpack this, I once again re-wrote the code in Python and used the Python Imaging Library (PIL) to extract the bytes. This particular image\nis 192x192 pixels and 24bits per pixel (3 bytes – RGB) and it iterates over each pixel from left to right, bottom to top, for the array of data.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nfrom PIL import Image\nim = Image.open(\"/Users/pickleRICK/19.png\")\n\ndef imparse(a):\nwidth, height = im.size\ncounter = 0\nb = [0] * (width * height * 3)\nfor y in range(height - 1, -1, -1):\nfor x in range(0,width):\npixel = im.getpixel((x,y))\nb[counter * 3 + 2] = pixel[0] # R\nb[counter * 3 + 1] = pixel[1] # G\nb[counter * 3 + 0] = pixel[2] # B\ncounter += 1\nwhile b[-1] == 0:\ndel b[-1]\nreturn b\n\n\nAfter it returns, the byte array gets passed to the now familiar decode function and then the deflate function.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n&gt;&gt;&gt; dec = imparse(im)\n&gt;&gt;&gt; dec\n\n[44, 174, 1, 0, 237, 11, 8, 125, 109, 41, 15, …\n\n&gt;&gt;&gt; dec = decode(dec)\n&gt;&gt;&gt; dec\n'\\xec\\xbd\\tx\\x1c\\xc5\\x95\\x00\\xdcs\\xf59#\\xa9\\xa6G …\n\n&gt;&gt;&gt; dec = zlib.decompress(dec,-15)\n&gt;&gt;&gt; dec\n'MZ\\x90\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\xff\\xff\\x00 …\n\n\nAs you can see, we have the MZ header and the next binary.\n\nWithin the DLL are additional functions which handle executing the new payload and I’ve gone ahead and decoded some of the native API’s\nthey use to show how they carry out activity.\n\n\n-----\n\n## The final payload\n\nArrival of the last binary – another .NET application called “RII9DKFR5LC4Y669MLOA2C50SFLPHZBN61CZ160Z.exe”. If you read any of the\nposts mentioned earlier on the analysis of AgentTesla, then this will look familiar.\n\n\n-----\n\nFunction and variable names are encoded with Unicode values in the range of 0x200B-0x200E. Strings are decrypted by, in this sample,\nfunction “KMBHFDXSELJYYLVK\\u3002”\n\n\n-----\n\nThis function uses a hardcoded password and salt to derive a key from the SHA1 hashing algorithm as implemented by Microsoft (modified\nPBKDF1). Afterwards, it uses the key and hardcoded IV to decrypt the string with AES-CBC.\n\nA quick Google for that IV shows hundreds of results for it, with most revolving around an encryption example that was used as the base for\nthis function – it even copies the examples variable names.\n\nWhat I found interesting here is that none of these values ever change sample to sample. Even going back to the samples in the write-ups on\nAgentTesla from over 6 months ago, I was able to decrypt their base64 strings listed in the blog. This confirms the same values are in use and\nlikely hard coded into the builder for AgentTesla.\n\nGiven that everything is static then, it’s fairly trivial to extract all of the base64 encoded strings, decrypt them, and look for interesting IoC’s.\n\n\n-----\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nfrom Crypto.Cipher import AES\ndef stringdecrypt(a):\nstring = base64.b64decode(a)\niv = \"@1B2c3D4e5F6g7H8\"\nkey =\n\"\\x34\\x88\\x6D\\x5B\\x09\\x7A\\x94\\x19\\x78\\xD0\\xE3\\x8b\\x1b\\x5c\\xa3\\x29\\x60\\x74\\x6a\\x5e\\x5d\\x64\\x87\\x11\\xb1\\x2c\\x67\\xaa\\x5b\\x3a\\x8e\\xbf\"\n#to 6a/5e for first iteration\ncleartext = AES.new(key[0:32], AES.MODE_CBC, iv).decrypt(string)\nreturn cleartext\n\nfh = open(\"extractedb64\")\ncontent = fh.readlines()\nfh.close()\nfor i in content:\ntry:\ndec = stringdecrypt(i)\nprint \"%s | %s\" % (i.strip(),dec.strip())\nexcept:\npass\n\n\nWhat we end up with is a long list of values like the below.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\ncWUeT8dJU4KfzxUEgGflzQ== | temp\ny9/s0/2Soj9dWZ7YCF9viw== | \\des_date.txt\nhQ1zQ5Cg31OSE+BZ2Os36w== | 2017-08-25\ncWUeT8dJU4KfzxUEgGflzQ== | temp\ny9/s0/2Soj9dWZ7YCF9viw== | \\des_date.txt\n1IhffSZWWBl13XPDs8n3myYCTMqLedaSKEkL/imL258= | dd.MM.yyyy HH:mm:ss\ncWUeT8dJU4KfzxUEgGflzQ== | temp\naXsej6rp5uxy+3ym08w3iA== | ApplicationData\nhaLsi+cj0yodiuWmM+o4Wg== | appdata\nAnV66gJ6ewY8YTWIByRSMA== | Temp\ncWUeT8dJU4KfzxUEgGflzQ== | temp\nzYMGsY8aSA781gMxSStsC9UAfia6hLdLRxgBeS3NtD0= | \\Java\\JavaUpdtr.exe\ncWUeT8dJU4KfzxUEgGflzQ== | temp\ny9/s0/2Soj9dWZ7YCF9viw== | \\des_date.txt\nAkq+/Qobe3bW+jdjmv5oI6h1rNqdq+rlANdh6Ef29KelgAp0y6gsCspLDS+k+xmNC9TpnFhgwZyL///RhoSWxQ== |\nSoftware\\Microsoft\\Windows NT\\CurrentVersion\\Windows\naZG83zDiQxysOvFJFc8qmg== | Load\n8mFIzTz8+GxS3SBdy62qeA== | JavaUpdtr\nIMqa7/uMjEFhAZrJPRn9Gw== | False\nqQj4VB+mzRT8iDf7llcE6Q== | xyz\nhyNN5z+7qAsS695lDXLuHg== | True\n…\n82ZGUDSQrPCv8v1Hf+HpRA== | &lt;/span&gt;\nBJsW0oB1ieLYwE8A0Yu6OlLBTcrh0varR+ibOkyOCrk= | mylogbox4h@gmail.com\n2qbrW8tf2IZoaPGZlcaKWw== | /log.tmp\nv4EpbnhZTubu6HTjEZ8Gdw== | [SavedLog (\nI/tDnJPWEB6yySAivkY/576ixyY2gOP+bLVbbaRIV8A= | yyyy_MM_dd_HH_mm_ss\n2qbrW8tf2IZoaPGZlcaKWw== | /log.tmp\nQ9Yhy5Uive3G6Gspdid9EQ== | Saved_Log_From_\neCqe8oqjGUIRwUWqnBrrpA== | /\nq542gy/+wDIUJhH3OGKnNg== | 3TzIyOOSC+3lcpPaeTxO6g== | _\n4T5LGk6qEvqUS2xRJLUlww== | .html\n\n\nFile names, registry keys, and e-mails to start off hunting with. You can also see where the corresponding base64 is within the code and then\nuse dnSpy to obtain further context on how AgentTesla utilizes these values.\n\nFor example, below is something that stood out as interesting almost immediately.\n\n\n1\n2\n3\n\n\n4nmIR8y7iw8axs2u6GfIQ8f/7fSpMKvqD0ODaew16nI= | mylogbox3h@gmail.com\n5XDX6cForslWY791UzW+zw== | sammy1990\nwf990RzBidRdPMgWIckJ2g== | smtp.gmail.com\n\n\n-----\n\not g to t ese a ues d Spy a d you a u ct o t at see s espo s b e o se d g t e sto e data bac to t e attac e\n\n## Pivoting on a hunch\n\nAt this point, I’ve accomplished the goal I set out for – covering the packing techniques used by the current version of AgentTesla, offering\nsome code to automate unpacking and decrypt some configuration data.\n\nBut why stop when you’re ahead?\n\nI like to Google static values and constants when analyzing malware because you can usually find some interesting stuff – configurations,\nforums, accounts, panels, etc. When I began searching for the file “one.jpeg.png.exe” I stumbled across a site, “b-f-v[.]info”, which hosts\nvarious versions of this keylogger.\n\nThey all function in the same way but the image that displays is related to the first part of the file name. The images are various sizes so the\ndecoding would be different for each; however, the code shown previously will grab the correct Width and Height for building the array.\n\nAlso take note of the dates and when they were modified. The sample covered in this blog was seen on August 29, just two days beforeth\nthese were created – so the person or group behind these appear to be actively creating new versions to send out. I confirmed in these\nsamples we find the same SMTP credentials.\n\n## Conclusion\n\nHopefully this overview of their packing techniques, along with the scripts to unpack each phase, prove helpful to others when looking at\nAgentTesla. Given its recent spikes in popularity, it’s likely not going anywhere anytime soon so the more knowledge you have of the threat, the\nbetter you can defend yourself.\n\n[You can continue to track this threat through the Palo Alto Networks AutoFocus AgentTesla tag and you will find the hashes for all of the files](https://autofocus.paloaltonetworks.com/)\ncovered in this blog below:\n\n### Indicators of Compromise\n\nInitial PE32\n\n\n-----\n\no e jpeg p g e e | ca 9bd c c ec03 ead 89 b 89 bbe6 6bc0ca b6 a 63 0 e d 5c\n\nmypic.jpeg.png.exe | cb0de059cbd5eba8c61c67bedcfa399709e40246039a0457ca6d92697ea516f9\n\nfamilyhome.jpeg.png.exe / myhome.jpeg.png.exe | 444e9fbf683e2cff9f1c64808d2e6769c13ed6b29899060d7662d1fe56c3121b\n\ngift-certificate.pdf.png.exe | 124bb13ede19e56927fe5afc5baf680522586534727babbe1aa1791d116caeeb\n\nrequest-for-quotation.pdf.png.exe | dce91ff60c8d843c3e5845061d6f73cfc33e34a5b8347c4d9c468911e29c3ce6\n\n### DLL’s\n\nrp.dll | 3c48c7f16749126a06c2aae58ee165dc72df658df057b1ac591a587367eae4ad\n\nrp.dll | a5768f1aa364d69e47351c81b1366cc2bfb1b67a0274a56798c2af82ae3525a8\n\n### Second stage encoded images\n\n19.png | e42a0fb66dbf40578484566114e5991cf9cf0aa05b1bd080800a55e1e13bff9e\n\n72.png | cd64f1990d3895cb7bd69481186d5a2b1b614ee6ac453102683dba8586593c03\n\n### AgentTesla\n\nRII9DKFR5LC4Y669MLOA2C50SFLPHZBN61CZ160Z.exe | 3e588ec87759dd7f7d34a8382aad1bc91ce4149b5f200d16ad1e9c1929eec8ec\n\nB92MKZFESR6J7R2PNQ9ZTBA6QN0LIEXTUQEVH3T3.exe | 8fb72967b67b5a224c0fcfc10ab939999e5dc2e877a511875bd4438bcc2f5494\n\n**Get updates from**\n\n**Palo Alto**\n\n**Networks!**\n\nSign up to receive the latest news, cyber threat intelligence and research from us\n\n[By submitting this form, you agree to our Terms of Use and acknowledge our Privacy Statement.](https://www.paloaltonetworks.com/legal-notices/terms-of-use)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-09-25 - Analyzing the Various Layers of AgentTesla’s Packing.pdf"
    ],
    "report_names": [
        "2017-09-25 - Analyzing the Various Layers of AgentTesla’s Packing.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535712,
    "ts_updated_at": 1743041149,
    "ts_creation_date": 1653787722,
    "ts_modification_date": 1653787722,
    "files": {
        "pdf": "https://archive.orkl.eu/94c1d4eb18fac202684c9fb307455c36aa73f2f2.pdf",
        "text": "https://archive.orkl.eu/94c1d4eb18fac202684c9fb307455c36aa73f2f2.txt",
        "img": "https://archive.orkl.eu/94c1d4eb18fac202684c9fb307455c36aa73f2f2.jpg"
    }
}