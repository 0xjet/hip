{
    "id": "92c34989-6095-4ce5-a8a8-8c7568735bcd",
    "created_at": "2023-01-12T15:03:00.28447Z",
    "updated_at": "2025-03-27T02:15:35.645367Z",
    "deleted_at": null,
    "sha1_hash": "8b07d63e5260460eb61cb564169af4d1944e6de3",
    "title": "2022-08-10 - The quantum state of Linux kernel garbage collection CVE-2021-0920 (Part I)",
    "authors": "",
    "file_creation_date": "2022-08-18T03:59:19Z",
    "file_modification_date": "2022-08-18T03:59:19Z",
    "file_size": 1099808,
    "plain_text": "# The quantum state of Linux kernel garbage collection CVE-2021-0920 (Part I)\n\n**[googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html](https://googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html)**\n\nA deep dive into an in-the-wild Android exploit\n\nGuest Post by Xingyu Jin, Android Security Research\n\n[This is part one of a two-part guest blog post, where first we'll look at the root cause of the](https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2021/CVE-2021-0920.html)\nCVE-2021-0920 vulnerability. In the second post, we'll dive into the in-the-wild 0-day\nexploitation of the vulnerability and post-compromise modules.\n\n## Overview of in-the-wild CVE-2021-0920 exploits\n\nA surveillance vendor named Wintego has developed an exploit for Linux socket syscall 0day, CVE-2021-0920, and used it in the wild since at least November 2020 based on the\nearliest captured sample, until the issue was fixed in November 2021. Combined with\nChrome and Samsung browser exploits, the vendor was able to remotely root Samsung\n[devices. The fix was released with the November 2021 Android Security Bulletin, and applied](https://source.android.com/security/bulletin/2021-11-01)\nto Samsung devices in Samsung's December 2021 security update.\n\nGoogle's Threat Analysis Group (TAG) discovered Samsung browser exploit chains being\nused in the wild. TAG then performed root cause analysis and discovered that this\nvulnerability, CVE-2021-0920, was being used to escape the sandbox and elevate privileges.\nCVE-2021-0920 was reported to Linux/Android anonymously. The Google Android Security\nTeam performed the full deep-dive analysis of the exploit.\n\nThis issue was initially discovered in 2016 by a RedHat kernel developer and disclosed in a\n[public email thread, but the Linux kernel community did not patch the issue until it was re-](https://patchwork.ozlabs.org/project/netdev/patch/CAOssrKcfncAYsQWkfLGFgoOxAQJVT2hYVWdBA6Cw7hhO8RJ_wQ@mail.gmail.com/)\nreported in 2021.\n\nVarious Samsung devices were targeted, including the Samsung S10 and S20. By abusing\nan ephemeral race condition in Linux kernel garbage collection, the exploit code was able to\nobtain a use-after-free (UAF) in a kernel sk_buff object. The in-the-wild sample could\neffectively circumvent CONFIG_ARM64_UAO, achieve arbitrary read / write primitives and\nbypass Samsung RKP to elevate to root. Other Android devices were also vulnerable, but we\ndid not find any exploit samples against them.\n\nText extracted from captured samples dubbed the vulnerability â€œquantum Linux kernel\ngarbage collectionâ€, which appears to be a fitting title for this blogpost.\n\n\n-----\n\n## Introduction\n\nCVE-2021-0920 is a use-after-free (UAF) due to a race condition in the garbage collection\nsystem for SCM_RIGHTS. SCM_RIGHTS is a control message that allows unix-domain\nsockets to transmit an open file descriptor from one process to another. In other words, the\nsender transmits a file descriptor and the receiver then obtains a file descriptor from the\nsender. This passing of file descriptors adds complexity to reference-counting file structs. To\naccount for this, the Linux kernel community designed a special garbage collection system.\nCVE-2021-0920 is a vulnerability within this garbage collection system. By winning a race\ncondition during the garbage collection process, an adversary can exploit the UAF on the\nsocket buffer, sk_buff object. In the following sections, weâ€™ll explain the\nSCM_RIGHTS garbage collection system and the details of the vulnerability. The analysis is\nbased on the Linux 4.14 kernel.\n\n## What is SCM_RIGHTS?\n\nLinux developers can share file descriptors (fd) from one process to another using the\n[SCM_RIGHTS datagram with the sendmsg syscall. When a process passes a file descriptor](https://man7.org/linux/man-pages/man7/unix.7.html)\nto another process, SCM_RIGHTS will add a reference to the underlying file struct. This\nmeans that the process that is sending the file descriptors can immediately close the file\ndescriptor on their end, even if the receiving process has not yet accepted and taken\nownership of the file descriptors. When the file descriptors are in the â€œqueuedâ€ state\n(meaning the sender has passed the fd and then closed it, but the receiver has not yet\naccepted the fd and taken ownership), specialized garbage collection is needed. To track this\nâ€œqueuedâ€ state, this [LWN article does a great job explaining SCM_RIGHTS reference](https://lwn.net/Articles/779472/)\ncounting, and it's recommended reading before continuing on with this blogpost.\n\n## Sending\n\nAs stated previously, a unix domain socket uses the syscall sendmsg to send a file descriptor\nto another socket. To explain the reference counting that occurs during SCM_RIGHTS, weâ€™ll\nstart from the senderâ€™s point of view. We start with the kernel function unix_stream_sendmsg,\nwhich implements the sendmsg syscall. To implement the SCM_RIGHTS functionality, the\nkernel uses the structure scm_fp_list for managing all the transmitted file structures.\nscm_fp_list stores the list of file pointers to be passed.\n\n\n-----\n\nstruct scm_fp_list {\n\nshort          count;\n\nshort          max;\n\nstruct user_struct   *user;\n\nstruct file       *fp[SCM_MAX_FD];\n\n};\n\n[unix_stream_sendmsg invokes scm_send (af_unix.c#L1886) to initialize the](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1886)\nscm_fp_list structure, linked by the scm_cookie structure on the stack.\n\nstruct scm_cookie {\n\nstruct pid       *pid;      /* Skb credentials */\n\nstruct scm_fp_list   *fp;      /* Passed files     */\n\nstruct scm_creds    creds;     /* Skb credentials   */\n\n#ifdef CONFIG_SECURITY_NETWORK\n\nu32           secid;     /* Passed security ID  */\n\n#endif\n\n};\n\n[To be more specific, scm_send â†’ __scm_send â†’ scm_fp_copy (scm.c#L68) reads the file](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L68)\ndescriptors from the userspace and initializes scm_cookie->fp which can contain\nSCM_MAX_FD file structures.\n\nSince the Linux kernel uses the sk_buff (also known as socket buffers or skb) object to\nmanage all types of socket datagrams, the kernel also needs to invoke the\nunix_scm_to_skb function to link the scm_cookie->fp to a corresponding skb object. This\n[occurs in unix_attach_fds (scm.c#L103):](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L103)\n\n\n-----\n\nâ€¦\n\n/*\n\n - Need to duplicate file references for the sake of garbage\n\n - collection. Otherwise a socket in the fps might become a\n\n - candidate for GC while the skb is not yet queued.\n\n*/\n\nUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\nif (!UNIXCB(skb).fp)\n\nreturn -ENOMEM;\n\nâ€¦\n\nThe scm_fp_dup call in unix_attach_fds increases the reference count of the file descriptor\nthatâ€™s being passed so the file is still valid even after the sender closes the transmitted file\ndescriptor later:\n\n\n-----\n\nstruct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\n\n{\n\nstruct scm_fp_list *new_fpl;\n\nint i;\n\nif (!fpl)\n\nreturn NULL;\n\nnew_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),\n\nGFP_KERNEL);\n\nif (new_fpl) {\n\nfor (i = 0; i < fpl->count; i++)\n\nget_file(fpl->fp[i]);\n\nnew_fpl->max = new_fpl->count;\n\nnew_fpl->user = get_uid(fpl->user);\n\n}\n\nreturn new_fpl;\n\n}\n\nLetâ€™s examine a concrete example. Assume we have sockets A and B. The A attempts to\npass itself to B. After the SCM_RIGHTS datagram is sent, the newly allocated skb from the\nsender will be appended to the Bâ€™s sk_receive_queue which stores received datagrams:\n\n\n-----\n\nsk_buff carries scm_fp_list structure\n\nThe reference count of A is incremented to 2 and the reference count of B is still 1.\n\n## Receiving\n\nNow, letâ€™s take a look at the receiver side unix_stream_read_generic (we will not discuss the\n[MSG_PEEK flag yet, and focus on the normal routine). First of all, the kernel grabs the](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L2445)\ncurrent skb from sk_receive_queue using skb_peek. Secondly, since scm_fp_list is attached\n[to the skb, the kernel will call unix_detach_fds (link) to parse the transmitted file structures](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L125)\nfrom skb and clear the skb from sk_receive_queue:\n\n/* Mark read part of skb as used */\n\nif (!(flags & MSG_PEEK)) {\n\nUNIXCB(skb).consumed += chunk;\n\nsk_peek_offset_bwd(sk, chunk);\n\nif (UNIXCB(skb).fp)\n\nunix_detach_fds(&scm, skb);\n\nif (unix_skb_len(skb))\n\nbreak;\n\nskb_unlink(skb, &sk->sk_receive_queue);\n\nconsume_skb(skb);\n\nif (scm.fp)\n\nbreak;\n\nThe function scm_detach_fds iterates over the list of passed file descriptors (scm->fp) and\ninstalls the new file descriptors accordingly for the receiver:\n\nfor (i=0, cmfptr=(__force int __user *)CMSG_DATA(cm); i<fdmax;\n\ni++, cmfptr++)\n\n{\n\nstruct socket *sock;\n\nint new_fd;\n\n\n-----\n\nerr = security_file_receive(fp[i]);\n\nif (err)\n\nbreak;\n\nerr = get_unused_fd_flags(MSG_CMSG_CLOEXEC & msg->msg_flags\n\n? O_CLOEXEC : 0);\n\nif (err < 0)\n\nbreak;\n\nnew_fd = err;\n\nerr = put_user(new_fd, cmfptr);\n\nif (err) {\n\nput_unused_fd(new_fd);\n\nbreak;\n\n}\n\n/* Bump the usage count and install the file. */\n\nsock = sock_from_file(fp[i], &err);\n\nif (sock) {\n\nsock_update_netprioidx(&sock->sk->sk_cgrp_data);\n\nsock_update_classid(&sock->sk->sk_cgrp_data);\n\n}\n\nfd_install(new_fd, get_file(fp[i]));\n\n}\n\nâ€¦\n\n/*\n\n- All of the files that fit in the message have had their\n\n- usage counts incremented, so we just free the list.\n\n*/\n\n__scm_destroy(scm);\n\n\n-----\n\n[Once the file descriptors have been installed, __scm_destroy (link) cleans up the allocated](https://elixir.bootlin.com/linux/v4.14.277/source/net/core/scm.c#L119)\nscm->fp and decrements the file reference count for every transmitted file structure:\n\nvoid __scm_destroy(struct scm_cookie *scm)\n\n{\n\nstruct scm_fp_list *fpl = scm->fp;\n\nint i;\n\nif (fpl) {\n\nscm->fp = NULL;\n\nfor (i=fpl->count-1; i>=0; i--)\n\nfput(fpl->fp[i]);\n\nfree_uid(fpl->user);\n\nkfree(fpl);\n\n}\n\n}\n\n## Reference Counting and Inflight Counting\n\nAs mentioned above, when a file descriptor is passed using SCM_RIGHTS, its reference\ncount is immediately incremented. Once the recipient socket has accepted and installed the\npassed file descriptor, the reference count is then decremented. The complication comes\nfrom the â€œmiddleâ€ of this operation: after the file descriptor has been sent, but before the\nreceiver has accepted and installed the file descriptor.\n\nLetâ€™s consider the following scenario:\n\n1. The process creates sockets A and B.\n2. A sends socket A to socket B.\n3. B sends socket B to socket A.\n4. Close A.\n5. Close B.\n\n\n-----\n\nScenario for reference count cycle\n\nBoth sockets are closed prior to accepting the passed file descriptors.The reference counts\nof A and B are both 1 and can't be further decremented because they were removed from\nthe kernel fd table when the respective processes closed them. Therefore the kernel is\nunable to release the two skbs and sock structures and an unbreakable cycle is formed. The\nLinux kernel garbage collection system is designed to prevent memory exhaustion in this\nparticular scenario. The inflight count was implemented to identify potential garbage. Each\ntime the reference count is increased due to an SCM_RIGHTS datagram being sent, the\ninflight count will also be incremented.\n\nWhen a file descriptor is sent by SCM_RIGHTS datagram, the Linux kernel puts its\nunix_sock into a global list gc_inflight_list. The kernel increments unix_tot_inflight which\ncounts the total number of inflight sockets. Then, the kernel increments u->inflight which\ntracks the inflight count for each individual file descriptor in the unix_inflight function\n[(scm.c#L45) invoked from unix_attach_fds:](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/scm.c#L45)\n\n\n-----\n\nvoid unix_inflight(struct user_struct *user, struct file *fp)\n\n{\n\nstruct sock *s = unix_get_socket(fp);\n\nspin_lock(&unix_gc_lock);\n\nif (s) {\n\nstruct unix_sock *u = unix_sk(s);\n\nif (atomic_long_inc_return(&u->inflight) == 1) {\n\nBUG_ON(!list_empty(&u->link));\n\nlist_add_tail(&u->link, &gc_inflight_list);\n\n} else {\n\nBUG_ON(list_empty(&u->link));\n\n}\n\nunix_tot_inflight++;\n\n}\n\nuser->unix_inflight++;\n\nspin_unlock(&unix_gc_lock);\n\n}\n\nThus, here is what the sk_buff looks like when transferring a file descriptor within sockets\nA and B:\n\nThe inflight count of A is incremented\n\nWhen the socket file descriptor is received from the other side, the unix_sock.inflight count\nwill be decremented.\n\n\n-----\n\nLet s revisit the reference count cycle scenario before the close syscall. This cycle is\nbreakable because any socket files can receive the transmitted file and break the reference\ncycle:\n\nBreakable cycle before close A and B\n\nAfter closing both of the file descriptors, the reference count equals the inflight count for each\nof the socket file descriptors, which is a sign of possible garbage:\n\nUnbreakable cycle after close A and B\n\nNow, letâ€™s check another example. Assume we have sockets A, B and ð›¼:\n\n1. A sends socket A to socket B.\n2. B sends socket B to socket A.\n3. B sends socket B to socket ð›¼.\n4. ð›¼ sends socket ð›¼ to socket B.\n5. Close A.\n6. Close B.\n\n\n-----\n\nBreakable cycle for A, B and ð›¼\n\nThe cycle is breakable, because we can get newly installed file descriptor Bâ€™ from the socket\nfile descriptor ð›¼ and newly installed file descriptor A' from Bâ€™.\n\n## Garbage Collection\n\n[A high level view of garbage collection is available from lwn.net:](https://lwn.net/Articles/779472/)\n\n\"If, instead, the two counts are equal, that file structure might be part of an unreachable\ncycle. To determine whether that is the case, the kernel finds the set of all in-flight Unixdomain sockets for which all references are contained in SCM_RIGHTS datagrams (for\nwhich f_count and inflight are equal, in other words). It then counts how many references to\neach of those sockets come from SCM_RIGHTS datagrams attached to sockets in this set.\nAny socket that has references coming from outside the set is reachable and can be\nremoved from the set. If it is reachable, and if there are any SCM_RIGHTS datagrams\nwaiting to be consumed attached to it, the files contained within that datagram are also\nreachable and can be removed from the set.\n\nAt the end of an iterative process, the kernel may find itself with a set of in-flight Unix-domain\nsockets that are only referenced by unconsumed (and unconsumable) SCM_RIGHTS\ndatagrams; at this point, it has a cycle of file structures holding the only references to each\nother. Removing those datagrams from the queue, releasing the references they hold, and\ndiscarding them will break the cycle.\"\n\nTo be more specific, the SCM_RIGHTS garbage collection system was developed in order to\nhandle the unbreakable reference cycles. To identify which file descriptors are a part of\nunbreakable cycles:\n\n1. Add any unix_sock objects whose reference count equals its inflight count to the\n\ngc_candidates list.\n2. Determine if the socket is referenced by any sockets outside of the gc_candidates list.\n\nIf it is then it is reachable, remove it and any sockets it references from the\ngc_candidates list. Repeat until no more reachable sockets are found.\n3. After this iterative process, only sockets who are solely referenced by other sockets\n\nwithin the gc_candidates list are left.\n\n\n-----\n\nLet s take a closer look at how this garbage collection process works. First, the kernel finds\nall the unix_sock objects whose reference counts equals their inflight count and puts them\n[into the gc_candidates list (garbage.c#L242):](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L242)\n\nlist_for_each_entry_safe(u, next, &gc_inflight_list, link) {\n\nlong total_refs;\n\nlong inflight_refs;\n\ntotal_refs = file_count(u->sk.sk_socket->file);\n\ninflight_refs = atomic_long_read(&u->inflight);\n\nBUG_ON(inflight_refs < 1);\n\nBUG_ON(total_refs < inflight_refs);\n\nif (total_refs == inflight_refs) {\n\nlist_move_tail(&u->link, &gc_candidates);\n\n__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);\n\n__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);\n\n}\n\n}\n\nNext, the kernel removes any sockets that are referenced by other sockets outside of the\n[current gc_candidates list. To do this, the kernel invokes scan_children (garbage.c#138)](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L138)\nalong with the function pointer dec_inflight to iterate through each candidateâ€™s sk>receive_queue. It decreases the inflight count for each of the passed file descriptors that\n[are themselves candidates for garbage collection (garbage.c#L261):](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L261)\n\n/* Now remove all internal in-flight reference to children of\n\n - the candidates.\n\n*/\n\nlist_for_each_entry(u, &gc_candidates, link)\n\nscan_children(&u->sk, dec_inflight, NULL);\n\n\n-----\n\nAfter iterating through all the candidates, if a gc candidate still has a positive inflight count it\nmeans that it is referenced by objects outside of the gc_candidates list and therefore is\nreachable. These candidates should not be included in the gc_candidates list so the related\ninflight counts need to be restored.\n\nTo do this, the kernel will put the candidate to not_cycle_list instead and iterates through its\n[receiver queue of each transmitted file in the gc_candidates list (garbage.c#L281) and](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L281)\nincrements the inflight count back. The entire process is done recursively, in order for the\ngarbage collection to avoid purging reachable sockets:\n\n/* Restore the references for children of all candidates,\n\n - which have remaining references. Do this recursively, so\n\n - only those remain, which form cyclic references.\n\n \n - Use a \"cursor\" link, to make the list traversal safe, even\n\n - though elements might be moved about.\n\n*/\n\nlist_add(&cursor, &gc_candidates);\n\nwhile (cursor.next != &gc_candidates) {\n\nu = list_entry(cursor.next, struct unix_sock, link);\n\n/* Move cursor to after the current position. */\n\nlist_move(&cursor, &u->link);\n\nif (atomic_long_read(&u->inflight) > 0) {\n\nlist_move_tail(&u->link, &not_cycle_list);\n\n__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);\n\nscan_children(&u->sk, inc_inflight_move_tail, NULL);\n\n}\n\n}\n\nlist_del(&cursor);\n\n\n-----\n\nNow gc_candidates contains only garbage . The kernel restores original inflight counts from\ngc_candidates, moves candidates from not_cycle_list back to gc_inflight_list and invokes\n[__skb_queue_purge for cleaning up garbage (garbage.c#L306).](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/garbage.c#L306)\n\n/* Now gc_candidates contains only garbage. Restore original\n\n - inflight counters for these as well, and remove the skbuffs\n\n - which are creating the cycle(s).\n\n*/\n\nskb_queue_head_init(&hitlist);\n\nlist_for_each_entry(u, &gc_candidates, link)\n\nscan_children(&u->sk, inc_inflight, &hitlist);\n\n/* not_cycle_list contains those sockets which do not make up a\n\n - cycle. Restore these to the inflight list.\n\n*/\n\nwhile (!list_empty(&not_cycle_list)) {\n\nu = list_entry(not_cycle_list.next, struct unix_sock, link);\n\n__clear_bit(UNIX_GC_CANDIDATE, &u->gc_flags);\n\nlist_move_tail(&u->link, &gc_inflight_list);\n\n}\n\nspin_unlock(&unix_gc_lock);\n\n/* Here we are. Hitlist is filled. Die. */\n\n__skb_queue_purge(&hitlist);\n\nspin_lock(&unix_gc_lock);\n\n__skb_queue_purge clears every skb from the receiver queue:\n\n\n-----\n\n/**\n\n -   __skb_queue_purge - empty a list\n\n -   @list: list to empty\n\n \n -   Delete all buffers on an &sk_buff list. Each buffer is removed from\n\n -   the list and one reference dropped. This function does not take the\n\n -   list lock and the caller must hold the relevant locks to use it.\n\n*/\n\nvoid skb_queue_purge(struct sk_buff_head *list);\n\nstatic inline void __skb_queue_purge(struct sk_buff_head *list)\n\n{\n\nstruct sk_buff *skb;\n\nwhile ((skb = __skb_dequeue(list)) != NULL)\n\nkfree_skb(skb);\n\n}\n\nThere are two ways to trigger the garbage collection process:\n\n1. wait_for_unix_gc is invoked at the beginning of the sendmsg function if there are more\n\nthan 16,000 inflight sockets\n2. When a socket file is released by the kernel (i.e., a file descriptor is closed), the kernel\n\nwill directly invoke unix_gc.\n\nNote that unix_gc is not preemptive. If garbage collection is already in process, the kernel\nwill not perform another unix_gc invocation.\n\nNow, letâ€™s check this example (a breakable cycle) with a pair of sockets f00 and f01, and a\nsingle socket ð›¼:\n\n1. Socket f 00 sends socket f 00 to socket f 01.\n2. Socket f 01 sends socket f 01 to socket ð›¼.\n3. Close f 00.\n4. Close f 01.\n\nBefore starting the garbage collection process, the status of socket file descriptors are:\n\n\n-----\n\nf 00: ref = 1, inflight = 1\nf 01: ref = 1, inflight = 1\nð›¼: ref = 1, inflight = 0\n\nBreakable cycle by f 00, f 01 and ð›¼\n\nDuring the garbage collection process, f 00 and f 01 are considered garbage candidates. The\ninflight count of f 00 is dropped to zero, but the count of f 01 is still 1 because ð›¼ is not a\ncandidate. Thus, the kernel will restore the inflight count from f 01â€™s receive queue. As a\nresult, f 00 and f 01 are not treated as garbage anymore.\n\n## CVE-2021-0920 Root Cause Analysis\n\nWhen a user receives SCM_RIGHTS message from recvmsg without the MSG_PEEK flag,\nthe kernel will wait until the garbage collection process finishes if it is in progress. However, if\nthe MSG_PEEK flag is on, the kernel will increment the reference count of the transmitted\nfile structures without synchronizing with any ongoing garbage collection process. This may\nlead to inconsistency of the internal garbage collection state, making the garbage collector\nmark a non-garbage sock object as garbage to purge.\n\n## recvmsg without MSG_PEEK flag\n\n[The kernel function unix_stream_read_generic (af_unix.c#L2290) parses the](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L2290)\nSCM_RIGHTS message and manages the file inflight count when the MSG_PEEK flag is\nNOT set. Then, the function unix_stream_read_generic calls unix_detach_fds to decrement\nthe inflight count. Then, unix_detach_fds clears the list of passed file descriptors\n(scm_fp_list) from the skb:\n\n\n-----\n\nstatic void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n\n{\n\nint i;\n\nscm->fp = UNIXCB(skb).fp;\n\nUNIXCB(skb).fp = NULL;\n\nfor (i = scm->fp->count-1; i >= 0; i--)\n\nunix_notinflight(scm->fp->user, scm->fp->fp[i]);\n\n}\n\nThe unix_notinflight from unix_detach_fds will reverse the effect of unix_inflight by\ndecrementing the inflight count:\n\nvoid unix_notinflight(struct user_struct *user, struct file *fp)\n\n{\n\nstruct sock *s = unix_get_socket(fp);\n\nspin_lock(&unix_gc_lock);\n\nif (s) {\n\nstruct unix_sock *u = unix_sk(s);\n\nBUG_ON(!atomic_long_read(&u->inflight));\n\nBUG_ON(list_empty(&u->link));\n\nif (atomic_long_dec_and_test(&u->inflight))\n\nlist_del_init(&u->link);\n\nunix_tot_inflight--;\n\n}\n\nuser->unix_inflight--;\n\nspin_unlock(&unix_gc_lock);\n\n}\n\n\n-----\n\nLater skb_unlink and consume_skb are invoked from\n[unix_stream_read_generic (af_unix.c#2451) to destroy the current skb. Following the call](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L2451)\nchain kfree(skb)->__kfree_skb, the kernel will invoke the function pointer skb[>destructor (code) which redirects to unix_destruct_scm:](https://elixir.bootlin.com/linux/v4.14.277/source/net/unix/af_unix.c#L1605)\n\nstatic void unix_destruct_scm(struct sk_buff *skb)\n\n{\n\nstruct scm_cookie scm;\n\nmemset(&scm, 0, sizeof(scm));\n\nscm.pid = UNIXCB(skb).pid;\n\nif (UNIXCB(skb).fp)\n\nunix_detach_fds(&scm, skb);\n\n/* Alas, it calls VFS */\n\n/* So fscking what? fput() had been SMP-safe since the last Summer */\n\nscm_destroy(&scm);\n\nsock_wfree(skb);\n\n}\n\nIn fact, the unix_detach_fds will not be invoked again here from unix_destruct_scm because\nUNIXCB(skb).fp is already cleared by unix_detach_fds. Finally, fd_install(new_fd,\nget_file(fp[i])) from scm_detach_fds is invoked for installing a new file descriptor.\n\n## recvmsg with MSG_PEEK flag\n\nThe recvmsg process is different if the MSG_PEEK flag is set. The MSG_PEEK flag is used\nduring receive to â€œpeekâ€ at the message, but the data is treated as unread.\nunix_stream_read_generic will invoke scm_fp_dup instead of unix_detach_fds. This\n[increases the reference count of the inflight file (af_unix.c#2149):](https://android.googlesource.com/kernel/goldfish/+/eee65a1282369eedfcbb664d0c865a0ef3eb7017/net/unix/af_unix.c#2149)\n\n\n-----\n\n/* It is questionable, see note in unix_dgram_recvmsg.\n\n*/\n\nif (UNIXCB(skb).fp)\n\nscm.fp = scm_fp_dup(UNIXCB(skb).fp);\n\nsk_peek_offset_fwd(sk, chunk);\n\nif (UNIXCB(skb).fp)\n\nbreak;\n\nBecause the data should be treated as unread, the skb is not unlinked and consumed when\nthe MSG_PEEK flag is set. However, the receiver will still get a new file descriptor for the\ninflight socket.\n\n## recvmsg Examples\n\nLetâ€™s see a concrete example. Assume there are the following socket pairs:\n\nf 00, f 01\nf 10, f 11\n\nNow, the program does the following operations:\n\nf 00 â†’ [f 00] â†’ f 01 (means f 00 sends [f 00] to f 01)\nf 10 â†’ [f 00] â†’ f 11\nClose(f 00)\n\n\n-----\n\nBreakable cycle by f 00, f 01, f 10 and f 11\n\nHere is the status:\n\ninflight(f 00) = 2, ref(f 00) = 2\ninflight(f 01) = 0, ref(f 01) = 1\ninflight(f 10) = 0, ref(f 10) = 1\ninflight(f 11) = 0, ref(f 11) = 1\n\nIf the garbage collection process happens now, before any recvmsg calls, the kernel will\nchoose f 00 as the garbage candidate. However, f 00 will not have the inflight count altered\nand the kernel will not purge any garbage.\n\nIf f 01 then calls recvmsg with MSG_PEEK flag, the receive queue doesnâ€™t change and the\ninflight counts are not decremented. f 01 gets a new file descriptor f 00' which increments the\nreference count on f 00:\n\n\n-----\n\nMSG_PEEK increment the reference count of f 00 while the receive queue is not cleared\n\nStatus:\n\ninflight(f 00) = 2, ref(f 00) = 3\ninflight(f 01) = 0, ref(f 01) = 1\ninflight(f 10) = 0, ref(f 10) = 1\ninflight(f 11) = 0, ref(f 11) = 1\n\nThen, f 01 calls recvmsg without MSG_PEEK flag, f 01â€™s receive queue is removed. f 01 also\nfetches a new file descriptor f 00'':\n\nThe receive queue of f 01 is cleared and f 01'' is obtained from f 01\n\nStatus:\n\ninflight(f 00) = 1, ref(f 00) = 3\ninflight(f 01) = 0, ref(f 01) = 1\ninflight(f 10) = 0, ref(f 10) = 1\ninflight(f 11) = 0, ref(f 11) = 1\n\n## UAF Scenario\n\nFrom a very high level perspective, the internal state of Linux garbage collection can be nondeterministic because MSG_PEEK is not synchronized with the garbage collector. There is a\nrace condition where the garbage collector can treat an inflight socket as a garbage\ncandidate while the file reference is incremented at the same time during the\nMSG_PEEK receive. As a consequence, the garbage collector may purge the candidate,\nfreeing the socket buffer, while a receiver may install the file descriptor, leading to a UAF on\nthe skb object.\n\nLetâ€™s see how the captured 0-day sample triggers the bug step by step (simplified version, in\nreality you may need more threads working together, but it should demonstrate the core\nidea). First of all, the sample allocates the following socket pairs and single socket ð›¼:\n\nf 00 f 01\n\n\n-----\n\nf 10, f 11\nf 20, f 21\nf 30, f 31\nsock ð›¼ (actually there might be even thousands of ð›¼ for protracting the garbage\ncollection process in order to evade a BUG_ON check which will be introduced later).\n\nNow, the program does the below operations:\n\nClose the following file descriptors prior to any recvmsg calls:\n\nClose(f 00)\nClose(f 01)\nClose(f 11)\nClose(f 10)\nClose(f 30)\nClose(f 31)\nClose(ð›¼)\n\n\n-----\n\nHere is the status:\n\ninflight(f 00) = N + 1, ref(f 00) = N + 1\ninflight(f 01) = 2, ref(f 01) = 2\ninflight(f 10) = 3, ref(f 10) = 3\ninflight(f 11) = 1, ref(f 11) = 1\ninflight(f 20) = 0, ref(f 20) = 1\ninflight(f 21) = 0, ref(f 21) = 1\ninflight(f 31) = 1, ref(f 31) = 1\ninflight(ð›¼) = 1, ref(ð›¼) = 1\n\nIf the garbage collection process happens now, the kernel will do the following scrutiny:\n\nList f 00, f 01, f 10, f 11, f 31, ð›¼ as garbage candidates. Decrease inflight count for the\ncandidate children in each receive queue.\nSince f 21 is not considered a candidate, f 11â€™s inflight count is still above zero.\nRecursively restore the inflight count.\nNothing is considered garbage.\n\nA potential skb UAF by race condition can be triggered by:\n\n1. Call recvmsg with MSG_PEEK flag from f 21 to get f 11â€™.\n2. Call recvmsg with MSG_PEEK flag from f 11 to get f 10â€™.\n3. Concurrently do the following operations:\n\n1. Call recvmsg without MSG_PEEK flag from f 11 to get f 10â€™â€™.\n2. Call recvmsg with MSG_PEEK flag from f 10â€™\n\nHow is it possible? Letâ€™s see a case where the race condition is not hit so there is no UAF:\n\nThread 0 Thread 1 Thread 2\n\nCall unix_gc\n\nStage0: List f 00, f 01, f 10, f 11,\nf 31, ð›¼ as garbage candidates.\n\nCall recvmsg with\nMSG_PEEK flag from f 21 to\nget f 11â€™\n\n\n-----\n\nStage0: decrease inflight count\nfrom the child of every garbage\ncandidate\n\nStatus after stage 0:\n\ninflight(f 00) = 0\n\ninflight(f 01) = 0\n\ninflight(f 10) = 0\n\ninflight(f 11) = 1\n\ninflight(f 31) = 0\n\ninflight(ð›¼) = 0\n\nStage1: Recursively restore\ninflight count if a candidate still\nhas inflight count.\n\nStage1: All inflight counts have\nbeen restored.\n\nStage2: No garbage, return.\n\n\nIncrease reference count:\nscm.fp =\nscm_fp_dup(UNIXCB(skb).fp);\n\nCall recvmsg with\nMSG_PEEK flag from f 11 to\nget f 10â€™\n\nCall recvmsg with\nMSG_PEEK flag from f 10â€™\n\n\nCall recvmsg without\nMSG_PEEK flag from\nf 11 to get f 10â€™â€™\n\n\nEveryone is happy Everyone is happy Everyone is happy\n\n\n-----\n\nHowever, if the second recvmsg occurs just after stage 1 of the garbage collection process,\nthe UAF is triggered:\n\nThread 0 Thread 1 Thread 2\n\nCall unix_gc\n\nStage0: List f 00, f 01, f 10, f\n11, f 31, ð›¼ as garbage\ncandidates.\n\nCall recvmsg with\nMSG_PEEK flag from f 21 to\nget f 11â€™\n\nIncrease reference count:\nscm.fp =\nscm_fp_dup(UNIXCB(skb).fp);\n\nStage0: decrease inflight\ncount from the child of every\ngarbage candidates\n\nStatus after stage 0:\n\ninflight(f 00) = 0\n\ninflight(f 01) = 0\n\ninflight(f 10) = 0\n\ninflight(f 11) = 1\n\ninflight(f 31) = 0\n\ninflight(ð›¼) = 0\n\nStage1: Start restoring inflight\ncount.\n\nCall recvmsg with\nMSG_PEEK flag from f 11 to\nget f 10â€™\n\n\n-----\n\nCall recvmsg without\nMSG_PEEK flag from\nf 11 to get f 10â€™â€™\n\nunix_detach_fds:\nUNIXCB(skb).fp = NULL\n\nBlocked by\nspin_lock(&unix_gc_lock)\n\n\nStage1: scan_inflight cannot\nfind candidate children from f\n11. Thus, the inflight count\naccidentally remains the\nsame.\n\nStage2: f 00, f 01, f 10, f 31,\nð›¼ are garbage.\n\nStage2: start purging\ngarbage.\n\nStage2: for\n\n, calls __skb_unlink and\nkfree_skb later.\n\n\nStart calling recvmsg with\nMSG_PEEK flag from f 10â€™,\nwhich would expect to receive\nf 00'\n\nGet skb = skb_peek(&sk>sk_receive_queue), skb is\ngoing to be freed by thread 0.\n\nstate->recv_actor(skb, skip,\nchunk, state) UAF\n\n\n-----\n\nGC finished.\n\nStart garbage collection.\n\nGet f 10â€™â€™\n\nTherefore, the race condition causes a UAF of the skb object. At first glance, we should\nblame the second recvmsg syscall because it clears skb.fp, the passed file list. However, if\nthe first recvmsg syscall doesnâ€™t set the MSG_PEEK flag, the UAF can be avoided because\nunix_notinflight is serialized with the garbage collection. In other words, the kernel makes\nsure the garbage collection is either not processed or finished before decrementing the\ninflight count and removing the skb. After unix_notinflight, the receiver obtains f11' and\ninflight sockets don't form an unbreakable cycle.\n\nSince MSG_PEEK is not serialized with the garbage collection, when recvmsg is called with\nMSG_PEEK set, the kernel still considers f 11 as a garbage candidate. For this reason, the\nfollowing next recvmsg will eventually trigger the bug due to the inconsistent state of the\ngarbage collection process.\n\n## Patch Analysis\n\n CVE-2021-0920 was found in 2016\n\n[The vulnerability was initially reported to the Linux kernel community in 2016. The researcher](https://patchwork.ozlabs.org/project/netdev/patch/CAOssrKcfncAYsQWkfLGFgoOxAQJVT2hYVWdBA6Cw7hhO8RJ_wQ@mail.gmail.com/)\nalso provided the correct patch advice but it was not accepted by the Linux kernel\ncommunity:\n\nPatch was not applied in 2016\n\n\n-----\n\nIn theory, anyone who saw this patch might come up with an exploit against the faulty\ngarbage collector.\n\n## Patch in 2021\n\n[Letâ€™s check the official patch for CVE-2021-0920. For the MSG_PEEK branch, it requests](https://lore.kernel.org/lkml/20210802134333.066918619@linuxfoundation.org/)\nthe garbage collection lock unix_gc_lock before performing sensitive actions and\nimmediately releases it afterwards:\n\nâ€¦\n\n+    spin_lock(&unix_gc_lock);\n\n+    spin_unlock(&unix_gc_lock);\n\nâ€¦\n\nThe patch is confusing - itâ€™s rare to see such lock usage in software development.\nRegardless, the MSG_PEEK flag now waits for the completion of the garbage collector, so\nthe UAF issue is resolved.\n\n## BUG_ON Added in 2017\n\nAndrey Ulanov from Google in 2017 found another issue in unix_gc and provided a fix\n[commit. Additionally, the patch added a BUG_ON for the inflight count:](https://lore.kernel.org/lkml/20170315031642.19576-1-andreyu@google.com/)\n\nvoid unix_notinflight(struct user_struct *user, struct file *fp)\n\nif (s) {\n\nstruct unix_sock *u = unix_sk(s);\n\n+        BUG_ON(!atomic_long_read(&u->inflight));\n\nBUG_ON(list_empty(&u->link));\n\nif (atomic_long_dec_and_test(&u->inflight))\n\nAt first glance, it seems that the BUG_ON can prevent CVE-2021-0920 from being\nexploitable. However, if the exploit code can delay garbage collection by crafting a large\namount of fake garbage, it can waive the BUG_ON check by heap spray.\n\n\n-----\n\n## New Garbage Collection Discovered in 2021\n\nCVE-2021-4083 deserves an honorable mention: when I discussed CVE-2021-0920 with\n[Jann Horn and Ben Hawkes, Jann found another issue in the garbage collection, described](https://bugs.chromium.org/p/project-zero/issues/detail?id=2247)\n[in the Project Zero blog post Racing against the clock -- hitting a tiny kernel race window.](https://googleprojectzero.blogspot.com/2022/03/racing-against-clock-hitting-tiny.html)\n\n\\\n\n## Part I Conclusion\n\nTo recap, we have discussed the kernel internals of SCM_RIGHTS and the designs and\nimplementations of the Linux kernel garbage collector. Besides, we have analyzed the\nbehavior of MSG_PEEK flag with the recvmsg syscall and how it leads to a kernel UAF by a\nsubtle and arcane race condition.\n\nThe bug was spotted in 2016 publicly, but unfortunately the Linux kernel community did not\naccept the patch at that time. Any threat actors who saw the public email thread may have a\nchance to develop an LPE exploit against the Linux kernel.\n\nIn part two, we'll look at how the vulnerability was exploited and the functionalities of the post\ncompromise modules.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-10 - The quantum state of Linux kernel garbage collection CVE-2021-0920 (Part I).pdf"
    ],
    "report_names": [
        "2022-08-10 - The quantum state of Linux kernel garbage collection CVE-2021-0920 (Part I).pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "9f101d9c-05ea-48b9-b6f1-168cd6d06d12",
            "created_at": "2023-01-06T13:46:39.396409Z",
            "updated_at": "2025-03-27T02:00:03.074969Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "CHROMIUM",
                "ControlX",
                "Red Dev 10",
                "RedHotel",
                "Red Scylla",
                "TAG-22",
                "BRONZE UNIVERSITY",
                "AQUATIC PANDA",
                "Charcoal Typhoon",
                "BountyGlad"
            ],
            "source_name": "MISPGALAXY:Earth Lusca",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "6abcc917-035c-4e9b-a53f-eaee636749c3",
            "created_at": "2022-10-25T16:07:23.565337Z",
            "updated_at": "2025-03-27T02:02:09.868522Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Bronze University",
                "Charcoal Typhoon",
                "Chromium",
                "Red Dev 10",
                "Red Scylla"
            ],
            "source_name": "ETDA:Earth Lusca",
            "tools": [
                "Agentemis",
                "AntSword",
                "BIOPASS",
                "BIOPASS RAT",
                "BadPotato",
                "Behinder",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "Doraemon",
                "FRP",
                "Fast Reverse Proxy",
                "FunnySwitch",
                "HUC Port Banner Scanner",
                "KTLVdoor",
                "Mimikatz",
                "NBTscan",
                "POISONPLUG.SHADOW",
                "PipeMon",
                "RbDoor",
                "RibDoor",
                "RouterGod",
                "SAMRID",
                "ShadowPad Winnti",
                "SprySOCKS",
                "WinRAR",
                "Winnti",
                "XShellGhost",
                "cobeacon",
                "fscan",
                "lcx",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "7ea1e0de-53b9-4059-802f-485884180701",
            "created_at": "2022-10-25T16:07:24.04846Z",
            "updated_at": "2025-03-27T02:02:10.090459Z",
            "deleted_at": null,
            "main_name": "Patchwork",
            "aliases": [
                "APT-C-09",
                "ATK 11",
                "Capricorn Organisation",
                "Chinastrats",
                "Dropping Elephant",
                "Maha Grass",
                "Quilted Tiger",
                "TG-4410",
                "Thirsty Gemini",
                "Zinc Emerson"
            ],
            "source_name": "ETDA:Patchwork",
            "tools": [
                "AndroRAT",
                "Artra Downloader",
                "ArtraDownloader",
                "AutoIt backdoor",
                "BADNEWS",
                "BIRDDOG",
                "Bahamut",
                "Bozok",
                "Bozok RAT",
                "Brute Ratel",
                "Brute Ratel C4",
                "CinaRAT",
                "Crypta",
                "ForeIT",
                "JakyllHyde",
                "Loki",
                "Loki.Rat",
                "LokiBot",
                "LokiPWS",
                "NDiskMonitor",
                "Nadrac",
                "PGoShell",
                "PowerSploit",
                "PubFantacy",
                "Quasar RAT",
                "QuasarRAT",
                "Ragnatela",
                "Ragnatela RAT",
                "SocksBot",
                "TINYTYPHON",
                "Unknown Logger",
                "WSCSPL",
                "Yggdrasil"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "9c884c88-2c9f-49c5-856a-2383ad1d8ef8",
            "created_at": "2024-05-01T02:03:08.152Z",
            "updated_at": "2025-03-27T02:05:17.422887Z",
            "deleted_at": null,
            "main_name": "ZINC EMERSON",
            "aliases": [
                "Dropping Elephant ",
                "EHDevel ",
                "Manul ",
                "Monsoon ",
                "Operation Hangover ",
                "Patchwork ",
                "TG-4410 ",
                "Viceroy Tiger ",
                "Confucius "
            ],
            "source_name": "Secureworks:ZINC EMERSON",
            "tools": [
                " Hanove",
                " Mac OS X KitM Spyware",
                " Proyecto2",
                " YTY Backdoor",
                "Enlighten Infostealer"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "c81067e0-9dcb-4e3f-abb0-80126519c5b6",
            "created_at": "2022-10-25T15:50:23.285448Z",
            "updated_at": "2025-03-27T02:00:55.42906Z",
            "deleted_at": null,
            "main_name": "Patchwork",
            "aliases": [
                "Hangover Group",
                "Dropping Elephant",
                "Chinastrats",
                "Operation Hangover"
            ],
            "source_name": "MITRE:Patchwork",
            "tools": [
                "NDiskMonitor",
                "QuasarRAT",
                "BackConfig",
                "TINYTYPHON",
                "AutoIt backdoor",
                "PowerSploit",
                "BADNEWS",
                "Unknown Logger",
                "Socksbot"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d53593c3-2819-4af3-bf16-0c39edc64920",
            "created_at": "2022-10-27T08:27:13.212301Z",
            "updated_at": "2025-03-27T02:00:55.529662Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Earth Lusca",
                "TAG-22",
                "Charcoal Typhoon",
                "CHROMIUM",
                "ControlX"
            ],
            "source_name": "MITRE:Earth Lusca",
            "tools": [
                "Mimikatz",
                "PowerSploit",
                "Tasklist",
                "certutil",
                "Cobalt Strike",
                "Winnti for Linux",
                "Nltest",
                "NBTscan",
                "ShadowPad"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535780,
    "ts_updated_at": 1743041735,
    "ts_creation_date": 1660795159,
    "ts_modification_date": 1660795159,
    "files": {
        "pdf": "https://archive.orkl.eu/8b07d63e5260460eb61cb564169af4d1944e6de3.pdf",
        "text": "https://archive.orkl.eu/8b07d63e5260460eb61cb564169af4d1944e6de3.txt",
        "img": "https://archive.orkl.eu/8b07d63e5260460eb61cb564169af4d1944e6de3.jpg"
    }
}