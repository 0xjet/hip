{
    "id": "d70f9559-b08a-4d34-af65-d5eb78692af0",
    "created_at": "2023-01-12T14:59:31.365934Z",
    "updated_at": "2025-03-27T02:05:39.755038Z",
    "deleted_at": null,
    "sha1_hash": "7ab8f4832a766982c4b65fa8437264880314067a",
    "title": "2020-11-06 - Netwalker Ransomware",
    "authors": "",
    "file_creation_date": "2022-05-28T22:08:00Z",
    "file_modification_date": "2022-05-28T22:08:00Z",
    "file_size": 4615879,
    "plain_text": "# NetWalker: il ransomware che ha beffato l‚Äôintera community\n\n**[cert-agid.gov.it/news/netwalker-il-ransomware-che-ha-beffato-lintera-community/](https://cert-agid.gov.it/news/netwalker-il-ransomware-che-ha-beffato-lintera-community/)**\n\n06/11/2020\n\n[NetWalker](https://cert-agid.gov.it/tag/netwalker/)\nOur encryption algorithms are very strong and your files are very well protected, the only way\nto get your files back is to cooperate with us and get the decrypter program.\n\n[‚Ä¶]\n\nAdditionally, you must know that your sensitive data has been stolen by our analyst experts\nand if you choose to no cooperate with us, you are exposing yourself.\n\nMa √® davvero cos√¨?\n\nCe lo siamo chiesti dopo che √® emersa la tendenza da parte dei ransomware ad entrare in\nscena nei casi pi√π eclatanti di data leak.\n\n[Giusto per citare gli ultimi, ne sono un esempio i casi di Luxottica ed](https://cert-agid.gov.it/news/il-malware-nefilim-fa-una-vittima-illustre-in-rete-i-dati-sottratti-a-luxottica/) [Enel.](https://www.cybersecurity360.it/nuove-minacce/ransomware/enel-di-nuovo-vittima-di-ransomware-netwalker-ruba-5-tb-di-dati-e-minaccia-di-renderli-pubblici/)\n\n[Gi√† dall‚Äôanalisi di Maze, coinvolto anche‚Äôesso in un data leak, avevamo constatato come il](https://cert-agid.gov.it/news/il-ransomware-maze-chiude-era-davvero-in-grado-di-esfiltrare-dati/)\nransomware fosse stato solo l‚Äôultimo stadio di un attacco pi√π articolato.\n\nMaze, infatti, non √® in grado di esfiltrare dati, cos√¨ come non lo √® neanche NetWalker. I\nransomware sono da sempre focalizzati solo sulla cifratura dei file, lavoro di per s√® gi√†\nabbastanza complesso anche senza dover aggiungere l‚Äôonere di trasferire GiB, se non TiB,\ndi dati verso un host esterno.\n\nCome Maze quindi, neanche il ransomware NetWalker pu√≤ esfiltrare dati (non importa\nnessuna API in grado di trasferire dei dati all‚Äôesterno), per quanto si senta dire spesso il\ncontrario.\n\nAd essere corretti, NetWalker non comunica affatto con l‚Äôesterno. La vittima deve inserire\nun misterioso JSON nel sito (un hidden service, ovviamente) dei criminali, per ottenere un\ndecryptor.\n\nVedremo in questo articolo come funzioni NetWalker, un malware che, sebbene articolato,\nrisulta di facile analisi (premesse le necessarie competenze sulle implementazioni delle\nprimitive crittografiche usate).\n\nVedremo inoltre cosa sia il misterioso JSON da fornire ai criminali e soprattutto\ndetermineremo se esiste o meno la possibilit√† di un decryptor.\n\nQuasi tutto quello che si s√† di NetWalker √® il frutto di analisi che si limitano a dedurre il\ncomportamento del malware dalla sua configurazione e dalle istruzioni lasciate sulla\nmacchina compromessa.\n\n\n-----\n\n## Il loader\n\nIl campione che abbiamo analizzato era contenuto in un loader PowerShell che non era\nparticolarmente offuscato (le stringhe lo erano ma fortunatamente erano facilmente\ndecifrabili tramite conversione da base64 e XOR con una costante).\nIl compito del loader √® quello di trovare sul sistema il processo `explorer.exe ed iniettarvi`\nuna DLL (disponibile in entrambe le versioni a 32 e 64 bit): se non vi riesce, mappa la DLL\nnel proprio processo (ovvero nell‚Äôinterprete powershell) e la esegue.\nLa DLL √® il ransomware NetWalker vero e proprio.\n\n\n-----\n\nIl loader di NetWalker, deoffuscato e con parti di codice omesse per brevit√†\nIl loader √® piuttosto scontato; unica parte degna di nota sono le ultime due righe che\ncancellano le copie per il ripristino dei dati.\n\nLa cancellazione delle copie per il ripristino dei dati\nQuesto √® un indicatore preciso che si ritrova tipicamente nei ransomware, in quanto √® una\noperazione che i criminali devono necessariamente effettuare per il buon esito della loro\noperazione.\n\n\n-----\n\n## NetWalker\n\nNel suo complesso, NetWalker √® un malware piuttosto semplice da analizzare poich√® non\npresenta offuscamento o tecniche anti-analisi.\n\nL‚Äôesecuzione inizia dell‚Äôentrypoint PE (il convenzionale `DllMain ) ed √® divisa in quattro`\npassi, mostrati qui sotto.\n\nLe quattro fasi di NetWalker: importazione delle API; parsing della configurazione;\ngenerazione delle chiavi di cifratura; cifratura vera e propria\nI pi√π importanti sono gli ultimi due, dove il malware genera le chiavi per la cifratura ed\neffettua il suo lavoro sui file.\n\n\n-----\n\n## Le API e la configurazione\n\nAccorpiamo qui queste due fasi in quanto la prima risulta semplice.\n\nLe API sono recuperate tramite la classica enumerazione dei moduli dal campo `Ldr del`\n```\nPEB .\n\n```\nSempre tradizionalmente, le funzioni da importare e la relativa DLL sono ricercate\ncomparando l‚Äôhash del loro nome, per evitare di usare costanti che potrebbero far scattare\nqualche strumento AV.\n\nLe API sono tutte salvate in un buffer, rinominato `bufferAPI, ed √® quindi facile verificare`\nche tra queste non sono presenti API per la comunicazione di rete.\n\n\n-----\n\nL‚Äôimportazione delle API di NetWalker. Gli interi evidenziati sono due esempi di hash usati\ndurante l‚Äôenumerazione dei moduli e delle funzioni. In basso il buffer in cui sono salvati i\npuntatori alle API.\nGli autori di NetWalker non hanno prestato attenzione ad offuscare il nome delle DLL che\ndevono essere esplicitamente caricate (perch√® non facenti parte del set comune di explorer),\ncome si vede chiaramente dall‚Äôimmagine sotto.\n\n\n-----\n\nSe\n\n\n-----\n\n_mpr.dll non √® gi√† presente (primo blocco), viene caricata, usando il nome in chiaro (secondo_\nblocco).\nTutto il buffer di `0x284 byte √® riempito, per un totale di 161 API.`\n\nPer completezza riportiamo l‚Äôelenco completo:\n\n\n-----\n\n```\n005A6980 7772E046 ntdll.RtlAllocateHeap\n005A6984 7772DFA5 ntdll.RtlFreeHeap\n005A6988 77742561 ntdll.RtlReAllocateHeap\n005A698C 7772DF40 ntdll.memset\n005A6990 77722340 ntdll.memcpy\n005A6994 777322A5 ntdll.memcmp\n005A6998 777D5555 ntdll.sprintf\n005A699C 77739D10 ntdll.strchr\n005A69A0 777619DA ntdll.strtol\n005A69A4 7777C340 ntdll.strcpy\n005A69A8 7777C350 ntdll.strcat\n005A69AC 777D57CD ntdll.wcscpy\n005A69B0 777D579A ntdll.wcscat\n005A69B4 7777C800 ntdll.strstr\n005A69B8 77730CC7 ntdll.wcsstr\n005A69BC 77732504 ntdll.wcscmp\n005A69C0 77737FA5 ntdll.wcsncmp\n005A69C4 77740299 ntdll.RtlRandomEx\n005A69C8 777C99C2 ntdll.RtlRandom\n005A69CC 7772E1F0 ntdll.RtlInitAnsiString\n005A69D0 7772E228 ntdll.RtlInitUnicodeString\n005A69D4 7772E6D5 ntdll.RtlAnsiStringToUnicodeString\n005A69D8 77736AF8 ntdll.RtlUnicodeStringToAnsiString\n005A69DC 7772E146 ntdll.RtlFreeAnsiString\n005A69E0 7772E146 ntdll.RtlFreeAnsiString\n005A69E4 7773C4DD ntdll.LdrLoadDll\n005A69E8 777B2040 ntdll.RtlAdjustPrivilege\n005A69EC 7771FDB0 ntdll.ZwQuerySystemInformation\n005A69F0 7771FC20 ntdll.NtOpenProcess\n005A69F4 777210C0 ntdll.NtOpenProcessToken\n005A69F8 7771FCB0 ntdll.ZwTerminateProcess\n005A69FC 7772012C ntdll.NtQuerySystemTime\n005A6A00 7771FAC0 ntdll.ZwAllocateVirtualMemory\n005A6A04 7771FB58 ntdll.ZwFreeVirtualMemory\n005A6A08 77720038 ntdll.NtProtectVirtualMemory\n005A6A0C 7771FE14 ntdll.ZwWriteVirtualMemory\n005A6A10 7771FE90 ntdll.ZwReadVirtualMemory\n005A6A14 7771FBD8 ntdll.NtQueryVirtualMemory\n005A6A18 7771FFA4 ntdll.NtCreateSection\n005A6A1C 7771FC50 ntdll.ZwMapViewOfSection\n005A6A20 7771FC80 ntdll.ZwUnmapViewOfSection\n005A6A24 77720C30 ntdll.ZwGetContextThread\n005A6A28 77721920 ntdll.ZwSetContextThread\n005A6A2C 77720068 ntdll.ZwResumeThread\n005A6A30 77721D70 ntdll.ZwSuspendThread\n005A6A34 7771FF24 ntdll.NtQueueApcThread\n005A6A38 7771F9E0 ntdll.ZwClose\n005A6A3C 7771FC38 ntdll.ZwSetInformationFile\n005A6A40 7771FA10 ntdll.ZwQueryInformationFile\n005A6A44 7771FE44 ntdll.NtDuplicateObject\n005A6A48 7771F9F8 ntdll.ZwQueryObject\n005A6A4C 7771FD64 ntdll.NtOpenFile\n005A6A50 77757CD9 ntdll.RtlDosPathNameToNtPathName_U\n005A6A54 777C00C1 ntdll.RtlComputeCrc32\n005A6A58 7773876A ntdll.RtlGetVersion\n\n```\n\n-----\n\n```\n005A6A5C 75943F1C kernel32.CreateFileW\n005A6A60 75941282 kernel32.WriteFile\n005A6A64 75943E93 kernel32.ReadFile\n005A6A68 7594193A kernel32.GetFileSize\n005A6A6C 759459AA kernel32.GetFileSizeEx\n005A6A70 7595C7DF kernel32.SetFilePointerEx\n005A6A74 7595CE06 kernel32.SetEndOfFile\n005A6A78 759C48AF kernel32.GetLogicalDriveStringsW\n005A6A7C 75944153 kernel32.GetDriveTypeW\n005A6A80 759413E0 kernel32.CloseHandle\n005A6A84 7594110C kernel32.GetTickCount\n005A6A88 7595D4AC kernel32.GetTempPathW\n005A6A8C 7596D1A6 kernel32.GetTempFileNameW\n005A6A90 759682D5 kernel32.CopyFileW\n005A6A94 75959AC8 kernel32.MoveFileW\n005A6A98 7594897B kernel32.DeleteFileW\n005A6A9C 7594103D kernel32.CreateProcessW\n005A6AA0 759479D8 kernel32.ExitProcess\n005A6AA4 75944221 kernel32.CreateDirectoryW\n005A6AA8 759C4A0F kernel32.RemoveDirectoryW\n005A6AAC 759443AA kernel32.GetWindowsDirectoryW\n005A6AB0 7594502B kernel32.GetSystemDirectoryW\n005A6AB4 7596BB86 kernel32.GetComputerNameExW\n005A6AB8 7594442F kernel32.GetVersion\n005A6ABC 75944918 kernel32.GetModuleFileNameW\n005A6AC0 7595E98B kernel32.FindResourceA\n005A6AC4 75945914 kernel32.LoadResource\n005A6AC8 75945921 kernel32.LockResource\n005A6ACC 75945A91 kernel32.SizeofResource\n005A6AD0 759443FD kernel32.FindFirstFileW\n005A6AD4 759454B6 kernel32.FindNextFileW\n005A6AD8 7594440A kernel32.FindClose\n005A6ADC 759441E8 kernel32.WaitForMultipleObjects\n005A6AE0 75943495 kernel32.CreateThread\n005A6AE4 7594192A kernel32.IsWow64Process\n005A6AE8 7595D620 kernel32.Wow64DisableWow64FsRedirection\n005A6AEC 7595D638 kernel32.Wow64RevertWow64FsRedirection\n005A6AF0 759410FF kernel32.Sleep\n005A6AF4 75941AE4 kernel32.GetFileAttributesW\n005A6AF8 7595D4C7 kernel32.SetFileAttributesW\n005A6AFC 759B87B9 kernel32.WaitForDebugEvent\n005A6B00 759B889F kernel32.ContinueDebugEvent\n005A6B04 759B88E3 kernel32.DebugActiveProcessStop\n005A6B08 759411C0 kernel32.GetLastError\n005A6B0C 759411F8 kernel32.GetCurrentProcessId\n005A6B10 75941ACC kernel32.SetErrorMode\n005A6B14 75942CFC kernel32.LocalFree\n005A6B18 77732C8A ntdll.RtlInitializeCriticalSection\n005A6B1C 777222C0 ntdll.RtlEnterCriticalSection\n005A6B20 77722280 ntdll.RtlLeaveCriticalSection\n005A6B24 75941136 kernel32.WaitForSingleObject\n005A6B28 75944663 kernel32.FlushFileBuffers\n005A6B2C 75941420 kernel32.GetCurrentThreadId\n005A6B30 7596CEDC kernel32.QueryDosDeviceW\n005A6B34 759515BF kernel32.QueryFullProcessImageNameW\n\n```\n\n-----\n\n```\n005A6B38 75943470 kernel32.GetModuleHandleW\n005A6B3C 7594180A kernel32.CreateEventW\n005A6B40 759415A6 kernel32.OpenEventW\n005A6B44 75941691 kernel32.SetEvent\n005A6B48 75944214 kernel32.CreateMutexW\n005A6B4C 75945119 kernel32.OpenMutexW\n005A6B50 7594111E kernel32.ReleaseMutex\n005A6B54 7596B297 kernel32.OutputDebugStringA\n005A6B58 77071A03 advapi32.GetCurrentHwProfileW\n005A6B5C 7707CA04 advapi32.OpenSCManagerW\n005A6B60 770D2401 advapi32.EnumServicesStatusW\n005A6B64 7707C9EC advapi32.OpenServiceW\n005A6B68 77071E3A advapi32.EnumDependentServicesW\n005A6B6C 770970DC advapi32.ControlService\n005A6B70 7708361C advapi32.CloseServiceHandle\n005A6B74 7707792C advapi32.QueryServiceStatusEx\n005A6B78 7708460D advapi32.RegOpenKeyExW\n005A6B7C 7708407E advapi32.RegCreateKeyExW\n005A6B80 77081456 advapi32.RegSetValueExW\n005A6B84 7708462D advapi32.RegQueryValueExW\n005A6B88 7707A965 advapi32.RegDeleteKeyExW\n005A6B8C 770811F2 advapi32.RegDeleteKeyW\n005A6B90 7707CED1 advapi32.RegDeleteValueW\n005A6B94 770976D7 advapi32.RegFlushKey\n005A6B98 7708461D advapi32.RegCloseKey\n005A6B9C 77084133 advapi32.LookupPrivilegeValueW\n005A6BA0 7708410E advapi32.AdjustTokenPrivileges\n005A6BA4 7707C9C4 advapi32.DuplicateTokenEx\n005A6BA8 7707C532 advapi32.CreateProcessAsUserW\n005A6BAC 770814E2 advapi32.RevertToSelf\n005A6BB0 7707C51A advapi32.ImpersonateLoggedOnUser\n005A6BB4 7708429C advapi32.GetTokenInformation\n005A6BB8 770842C4 advapi32.ConvertSidToStringSidW\n005A6BBC 7707CAA6 advapi32.IsWellKnownSid\n005A6BC0 68BC2F06 mpr.WNetOpenEnumW\n005A6BC4 68BC3058 mpr.WNetEnumResourceW\n005A6BC8 68BC4769 mpr.WNetUseConnectionW\n005A6BCC 68BC4744 mpr.WNetAddConnection2W\n005A6BD0 68BCD34E mpr.WNetGetUniversalNameW\n005A6BD4 68BC2DD6 mpr.WNetCloseEnum\n005A6BD8 75F25650 shell32.SHGetFolderPathW\n005A6BDC 75EB3C39 shell32.ShellExecuteW\n005A6BE0 69C63F33 srvcli.NetShareEnum\n005A6BE4 688713D2 netutils.NetApiBufferFree\n005A6BE8 75D109AD ole32.CoInitializeEx\n005A6BEC 75D186D3 ole32.CoUninitialize\n005A6BF0 75D19D0B ole32.CoCreateInstance\n005A6BF4 75CF7259 ole32.CoInitializeSecurity\n005A6BF8 771A4642 oleaut32.SysAllocString\n005A6BFC 771A3E59 oleaut32.SysFreeString\n005A6C00 751813F0 psapi.GetModuleFileNameExW\n\n```\nLa configurazione di NetWalker √® in formato JSON e si trova cifrata nell‚Äôunica sua risorsa.\nQuesta risorsa √® cos√¨ strutturata:\n\n\n-----\n\nRicostruire la struttura della risorsa non √® stato complicato, sotto i frammenti di codice\nrilevanti.\n\nIl caricamento della risorsa, le usuali chiamate a LoadResource, LockResource e\n_SizeOfResouce sono inoltre presenti._\n\n\n-----\n\nLe decifratura della configurazione. E‚Äô stato possibile identificare RC4 grazie ai blocchi\nevidenziati a destra. Quale altro cifrario usa tabelle da 256 byte?\nLa configurazione decifrata √® un JSON che contiene, tra le altre, una chiave che si rilever√†\nessere una chiave pubblica X25519.\n\n\n-----\n\n```\n{\n  \"mpk\":\"MfPiGc7EOHCyHMHGB05GafqzEAvw8xhjuAB7MlNf53I=\",\n  \"mode\":0,\n  \"spsz\":15360,\n  \"thr\":1500,\n  \"idsz\":6,\n  \"encname\":false,\n  \"onion1\":\"pb36hu4spl6cyjdfhing7h3pw6dhpk32ifemawkujj4gp33ejzdq3did.onion\",\n  \"onion2\":\"rnfdsgm6wb6j6su5txkekw4u4y47kp2eatvu7d6xhyn5cs4lt4pdrqqd.onion\",\n  \"lfile\":\"{id}-Readme.txt\",\n\"lend\":\"SGkhDQpZb3VyIGZpbGVzIGFyZSBlbmNyeXB0ZWQuDQpBbGwgZW5jcnlwdGVkIGZpbGVzIGZvciB0aG\n  \"white\":{\n   \"path\":[\n     \"*system volume information\",\n     \"*windows.old\",\n     \"*:\\\\users\\\\*\\\\*temp\",\n     \"*msocache\",\n     \"*:\\\\winnt\",\n     \"*$windows.~ws\",\n     \"*perflogs\",\n     \"*boot\",\n     \"*:\\\\windows\",\n     \"*:\\\\program file*\\\\vmware\",\n     \"\\\\\\\\*\\\\users\\\\*\\\\*temp\",\n     \"\\\\\\\\*\\\\winnt\",\n     \"\\\\\\\\*\\\\windows\",\n     \"*\\\\program file*\\\\vmware\",\n     \"*appdata*microsoft\",\n     \"*appdata*packages\",\n     \"*microsoft\\\\provisioning\",\n     \"*dvd maker\",\n     \"*Internet Explorer\",\n     \"*Mozilla\",\n     \"*Mozilla*\",\n     \"*Old Firefox data\",\n     \"*\\\\program file*\\\\windows media*\",\n     \"*\\\\program file*\\\\windows portable*\",\n     \"*windows defender\",\n     \"*\\\\program file*\\\\windows nt\",\n     \"*\\\\program file*\\\\windows photo*\",\n     \"*\\\\program file*\\\\windows side*\",\n     \"*\\\\program file*\\\\windowspowershell\",\n     \"*\\\\program file*\\\\cuass*\",\n     \"*\\\\program file*\\\\microsoft games\",\n     \"*\\\\program file*\\\\common files\\\\system\",\n     \"*\\\\program file*\\\\common files\\\\*shared\",\n     \"*\\\\program file*\\\\common files\\\\reference ass*\",\n     \"*\\\\windows\\\\cache*\",\n     \"*temporary internet*\",\n     \"*media player\",\n     \"*:\\\\users\\\\*\\\\appdata\\\\*\\\\microsoft\",\n     \"\\\\\\\\*\\\\users\\\\*\\\\appdata\\\\*\\\\microsoft\",\n     \"*\\\\Program File*\\\\Cisco\"\n\n```\n\n-----\n\n```\n   ],\n   \"file\":[\n    \"ntuser.dat*\",\n    \"iconcache.db\",\n    \"gdipfont*.dat\",\n    \"ntuser.ini\",\n    \"usrclass.dat\",\n    \"usrclass.dat*\",\n    \"boot.ini\",\n    \"bootmgr\",\n    \"bootnxt\",\n    \"desktop.ini\",\n    \"ntuser.dat\",\n    \"autorun.inf\",\n    \"ntldr\",\n    \"thumbs.db\",\n    \"bootsect.bak\",\n    \"bootfont.bin\"\n   ],\n   \"ext\":[\n    \"msp\",\n    \"exe\",\n    \"sys\",\n    \"msc\",\n    \"mod\",\n    \"clb\",\n    \"mui\",\n    \"regtrans-ms\",\n    \"theme\",\n    \"hta\",\n    \"shs\",\n    \"nomedia\",\n    \"diagpkg\",\n    \"cab\",\n    \"ics\",\n    \"msstyles\",\n    \"cur\",\n    \"drv\",\n    \"icns\",\n    \"diagcfg\",\n    \"dll\",\n    \"ocx\",\n    \"lnk\",\n    \"ico\",\n    \"idx\",\n    \"ps1\",\n    \"mpa\",\n    \"cpl\",\n    \"icl\",\n    \"msu\",\n    \"msi\",\n    \"nls\",\n    \"scr\",\n    \"adv\",\n    \"386\",\n\n```\n\n-----\n\n```\n    com,\n    \"hlp\",\n    \"rom\",\n    \"lock\",\n    \"386\",\n    \"wpx\",\n    \"ani\",\n    \"prf\",\n    \"rtp\",\n    \"ldf\",\n    \"key\",\n    \"diagcab\",\n    \"cmd\",\n    \"spl\",\n    \"deskthemepack\",\n    \"bat\",\n    \"themepack\"\n   ],\n   \"extfree\":null\n },\n \"kill\":{\n   \"use\":true,\n   \"prc\":[\n    \"nslsvice.exe\",\n    \"pg*\",\n    \"nservice.exe\",\n    \"cbvscserv*\",\n    \"ntrtscan.exe\",\n    \"cbservi*\",\n    \"hMailServer*\",\n    \"IBM*\",\n    \"bes10*\",\n    \"black*\",\n    \"apach*\",\n    \"bd2*\",\n    \"db*\",\n    \"ba*\",\n    \"be*\",\n    \"QB*\",\n    \"oracle*\",\n    \"wbengine*\",\n    \"vee*\",\n    \"postg*\",\n    \"sage*\",\n    \"sap*\",\n    \"b1*\",\n    \"fdlaunch*\",\n    \"msmdsrv*\",\n    \"report*\",\n    \"msdtssr*\",\n    \"coldfus*\",\n    \"cfdot*\",\n    \"swag*\",\n    \"swstrtr*\",\n    \"jetty.exe\",\n\n```\n\n-----\n\n```\n    wrsa.exe,\n    \"team*\",\n    \"agent*\",\n    \"store.exe\",\n    \"sql*\",\n    \"sqbcoreservice.exe\",\n    \"thunderbird.exe\",\n    \"ocssd.exe\",\n    \"encsvc.exe\",\n    \"excel.exe\",\n    \"synctime.exe\",\n    \"mspub.exe\",\n    \"ocautoupds.exe\",\n    \"thebat.exe\",\n    \"dbeng50.exe\",\n    \"*sql*\",\n    \"mydesktopservice.exe\",\n    \"onenote.exe\",\n    \"outlook.exe\",\n    \"powerpnt.exe\",\n    \"msaccess.exe\",\n    \"tbirdconfig.exe\",\n    \"wordpad.exe\",\n    \"ocomm.exe\",\n    \"dbsnmp.exe\",\n    \"thebat64.exe\",\n    \"winword.exe\",\n    \"oracle.exe\",\n    \"xfssvccon.exe\",\n    \"firefoxconfig.exe\",\n    \"visio.exe\",\n    \"mydesktopqos.exe\",\n    \"infopath.exe\",\n    \"agntsvc.exe\"\n   ],\n   \"svc\":[\n    \"Lotus*\",\n    \"veeam*\",\n    \"cbvscserv*\",\n    \"hMailServer\",\n    \"backup*\",\n    \"*backup*\",\n    \"apach*\",\n    \"firebird*\",\n    \"ibmiasrw\",\n    \"IBM Domino*\",\n    \"Simply Accounting Database Connection Manager\",\n    \"IASJet\",\n    \"QB*\",\n    \"*sql*\",\n    \"sql*\",\n    \"QuickBooksDB*\",\n    \"IISADMIN\",\n    \"omsad\",\n    \"dc*32\",\n\n```\n\n-----\n\n```\n    server Administrator,\n    \"wbengine\",\n    \"mr2kserv\",\n    \"MSExchange*\",\n    \"ShadowProtectSvc\",\n    \"SP*4\",\n    \"teamviewer\",\n    \"MMS\",\n    \"AcronisAgent\",\n    \"ARSM\",\n    \"AcrSch2Svc\",\n    \"vsnapvss\",\n    \"SPXService\",\n    \"StorageCraft ImageManager\",\n    \"wrsvc\",\n    \"stc_endpt_svc\",\n    \"acrsch2svc*\"\n   ],\n   \"svcwait\":0,\n   \"task\":[\n    \"reboot\",\n    \"restart\",\n    \"shutdown\",\n    \"logoff\",\n    \"back\"\n   ]\n },\n \"net\":{\n   \"use\":true,\n   \"ignore\":{\n    \"use\":true,\n    \"disk\":true,\n    \"share\":[\n      \"ipc$\",\n      \"admin$\"\n    ]\n   }\n },\n \"unlocker\":{\n   \"use\":true,\n   \"ignore\":{\n    \"use\":true,\n    \"pspath\":[\n      \"*:\\\\windows*\",\n      \"*:\\\\winnt*\",\n      \"*:\\\\program file*\\\\vmwar*\",\n      \"*\\\\Program File*\\\\Fortinet\",\n      \"*\\\\Program File*\\\\Cisco\"\n    ],\n    \"prc\":[\n      \"psexec.exe\",\n      \"system\",\n      \"forti*.exe\",\n      \"fmon.exe\",\n      \"fcaptmon.exe\",\n\n```\n\n-----\n\n```\n      FCHelper64.exe \n     ]\n   }\n  }\n}\n\n```\nRiportiamo brevemente il significato di ogni campo. Per la comprensione di questi √®\nnecessario procedere con la completa analisi del ransomware: noi li riportiamo qui per\nriferimento senza indicare il codice dove sono usati.\n\n**[mpk. Chiave pubblica X25519 con la quale √® ottenuto un segreto condiviso (vedi sotto, per il](https://en.wikipedia.org/wiki/Curve25519)**\nfunzionamento di X25519) usato per cifrare la chiave segreta ed ottenere la chiave di\ncifratura (univoca) di ogni file.\n\n**mode. Modalit√† di cifratura. Sono disponibili tre modi:**\n\n1. Modo 0. Se il file ha dimensione minore di spsz, passa al modo 2, se ha dimensione\n\ninferiore a 5 * spsz passa al modo 1, altrimenti rimani in modo 0.\nIn questo modo, tre blocchi del file sono cifrati, tutti di dimensione spsz e posizionati\nrispettivamente: all‚Äôinizio, a met√† e alla fine.\n2. Modo 1. Un blocco di dimensione spsz √® cifrato ad inizio file.\n3. Modo 2. Tutto il file √® cifrato.\n\n**spsz. Dimensione da cifrare. Non pi√π di una quantit√† di dati pari a tre volte questa**\ndimensione √® cifrata, per ogni file.\n\n**thr. Numero di thread worker da creare. NetWalker usa una sistema di task per cifrare i file.**\nDei thread enumerano i file e altri thread li cifrano. Questo √® il numero massimo di thread in\ntotale (esclusi i thread fissi che fanno altro).\n\n**idsz. Lunghezza dell‚Äôidentificativo di ogni vittima. L‚Äôidentificativo √® usato per calcolare**\nl‚Äôestensione dei file cifrati e per la decifratura dei file in automatico nell‚Äôinfrastruttura dei\ncriminali.\nL‚Äôidentificativo √®, la prima parte del CRC32, convertito in hex, della chiave pubblica X25519\nassociata alla chiave segreta del punto mpk. Questo campo indica quanti caratteri della\nstringa esadecimale prendere.\n\n**encname. Se settato a vero, i nomi dei file sono a loro volta cifrati. NetWalker appende ad**\nogni file un payload, cifrato (vedi sotto), che contiene, tra l‚Äôaltro, il nome originale del file.\n\n**onion1, onion2. I due siti, hidden service, per il pagamento del riscatto.**\n\n**lfile. Template per il nome del file del riscatto. Le entit√† tra parentesi graffe sono sostituite**\ncon appositi valori. In questo caso {id} √® l‚Äôid indicato nel punto idsz.\n\n\n-----\n\n**lend. Template, in base64, per il contenuto del file di riscatto. Un estratto √® contenuto ad**\ninizio news. Questo file contiene l‚Äôentit√† {code} che verr√† sostituita con un JSON necessario\nper il download del decryptor (una volta pagato).\n\n**white. Un oggetto che indica quale cartelle (path), file (file ed extfree) o estensioni (ext)**\nnon cifrare. L‚Äôobiettivo √® evitare la compromissione della macchina vittima, in modo da\npermettergli il pagamento.\n\n**kill. Se abilitato (use), indica quali processi (prc), servizi (svc) e task di Windows (task)**\nterminare. Questi controlli sono fatti in thread appositi, fatti partire dopo un‚Äôattesa di svcwait\nsecondi.\n\n**net. Se abilitato (use) indica di enumerare le risorse di rete eventualmente (ignore.use)**\nignorando determinate condivisioni (ignore.share) o i dischi di rete (ingore.disk).\n\n**unlocker. Se abilitato (use) indica di tentare di sbloccare un file in uso enumerando tutti gli**\nhandle ed i relativi processi, eventualmente (ignore.use) tranne quelli il cui file\n(ignore.pspath) o nome (ignore.prc), e chiudendo i primi.\n\nLa configurazione JSON non √® di immediato utilizzo per un programma scritto in C o affini.\nQuesta viene convertita in un formato nativo e salvata in un buffer, rinominato configBuffer.\nNetWalker utilizza spesso buffer allocati dinamicamente per contenere le sue strutture. Avere\nla ‚Äúmappa geografica‚Äù di questi buffer √® di fondamentale importanza per l‚Äôanalisi del\nransomware.\n\n√à importante in questo caso l‚Äôintuito e l‚Äôesperienza dell‚Äôanalista per individuare le funzioni\nchiave del parsing. Ad esempio la funzione seguente √® facilmente identificata come quella\nresponsabile di fare il parsing della stringa JSON e ritornare una struttura dati apposita.\n\n\n-----\n\nAnalizzando la funzione che abbiamo chiamato parseJSON (mostrata in miniatura) √®\npossibile rendersi conto, per via delle costanti usate, che si tratta di codice per il parsing di\nJSON.\nIn linguaggi in cui l‚Äôallocazione di memoria √® lasciata al programmatore ed i tipi sono statici,\nun oggetto JSON, una volta parsato, si manipola tramite una serie di funzioni accessor.\n\nCi aspettiamo quindi delle funzioni che, dato l‚Äôoggetto del tipo ritornato dalla funzione di\nprima, possano accedere alle sue propriet√† oppure che consentano di ottenerne il valore\nnativo (nel caso sia una stringa, intero, booleano o array).\n\nCi aspettiamo inoltre che per ogni tipo JSON ci sia una corrispondente funzione accessor e\nche il risultato sia in formato nativo (quindi stringhe C o array ed interi nativi).\n\n\n-----\n\nLe nostre aspettative non si dimostrano sbagliate e possiamo identificare e rinominare\nfacilmente le funzioni usate.\n\n\n-----\n\nLa creazione ed il primo popolamento del buffer di configurazione configBuffer Inoltre una\n\n\n-----\n\ndelle funzioni accessor usate per manipolare JSON.\n\n\n-----\n\nUn esempio di accesso al valore di un campo JSON, come ci aspettavamo esiste l‚Äôapposita\nfunzione. Una analoga esiste per gli altri tipi JSON.\nRinominate le funzioni, risulta facile creare una mappa del configBuffer.\n```\nFormat is XX: YYYY where XX is the offset of the field (in hex) and YYYY its\ndescription.\nAll values are native. The arrays hold native data too.\n00: JSON object\n04: ptr to mpk (decoded from base64)\n08: CRC32(mpk)\n0c: mode\n10: spsz\n14: spsz * 5\n18: thr\n1c: idsz\n20: encname\n24: ptr to lfile\n28: ptr to onion1\n2c: ptr to onion2\n30: ptr to lend (decoded from base64)\n34: ptr to array white.path\n38: # array white.path\n3c: ptr to array white.file\n40: # array white.file\n44: ptr to array white.ext\n48: # array white.ext\n4c: ptr to array white.extfree\n50: # array white.extfree\n54: kill.use\n58: kill.svcwait\n5c: ptr to array kill.prc\n60: # array kill.prc\n64: ptr to array kill.svc\n68: # array kill.svc\n6c: ptr to array kill.task\n70: # array kill.task\n74: net.use\n78: net.ignore.use\n7c: net.ignore.disk\n80: ptr array net.ignore.share\n84: # array net.ignore.share\n88: unlocker.use\n8c: unlocker.ignore.use\n90: ptr array unlocker.ignore.pspath\n94: # array unlocker.ignore.pspath\n98: ptr array unlocker.ignore.prc\n9c: # array unlocker.ignore.prc\n\n## Generazione delle chiavi e preparazione alla cifratura\n\n```\n\n-----\n\nQuesta √® la parte pi√π complessa da analizzare, poich√® l implementazione delle primitive\ncrittografiche √® molto ottimizzata ed il loro riconoscimento richiede un‚Äôottima conoscenza dei\nloro principi di implementazione non solo teorici ma anche pratici (tipo le implementazioni\nbranchless usate per evitare attacchi side-channel).\n\nNetWalker utilizza il classico doppio schema a crittografia simmetrica (autenticata) ed\nasimmetrica.\n[La cifratura simmetrica impiega ChaCha8 per la confidenzialit√† (ovvero per cifrare) ed](https://cr.yp.to/chacha.html)\n[HMAC-SHA256 per l‚Äôintegrit√† (ovvero per evitare la manipolazione del payload).](https://en.wikipedia.org/wiki/HMAC)\n[La chiave segreta usata nella cifratura simmetrica √® generata tramite Diffie-Hellman, in](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)\n[particolare tramite una forma di IES che impiega X25519 (conosciuto anche come](https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme)\nCurve25519).\nLa chiave √® generata come segreto condiviso a partire dalla chiave pubblica dei criminali\n(mpk) e da una seconda chiave segreta effimera (vedi dettagli sotto).\n\n### Le primitive e la loro identificazione nel codice.\n\nü§ñ **Questa parte √® particolarmente densa e rivolta a chi √® interessato alle evidenze per**\n**la verifica delle primitive usate.**\n\nLa primitiva pi√π semplice da identificare √® SHA256, per via delle costanti usate per\nl‚Äôinizializzazione.\n\n\n-----\n\nL‚Äôinizializzazione dello stato SHA256\nSHA256 √® usata in due contesti: il primo √® nell‚ÄôHMAC-SHA256 (a cui da il nome) e l‚Äôaltro per\nla generazione dell‚ÄôIV per chacha.\n\nIn quest‚Äôultimo contesto il valore ottenuto √® leggermente modificato, come vedremo.\n\nDato che molto probabilmente NetWalker √® scritto in C o affini, ci aspettiamo di trovare le\nusuali funzioni di init, update e finalize di un hash.\nIdentificarle aiuter√† ad etichettare la prossima primitiva: HMAC-SHA256.\n\n\n-----\n\nLe tre funzioni di generazione di un hash, una volta identificate\nHMAC si pu√≤ riconoscere dalle costanti di padding interno ( 0x36 ripetuto) ed esterno\n( 0x5c ripetuto).\n\nLe due constanti di padding.\nHMAC-SHA256 √® usato nella stessa funzione che effettua la cifratura simmetrica, rinominata\n```\nHMAC_and_encrypt, e si basa sull‚Äôutilizzo di una funzione hmac_internal che inizia (ma\n\n```\nnon termina) il calcolo dell‚Äôhash interno e di una funzione `hmac_outer che calcola l‚Äôhash`\nesterno.\n\n\n-----\n\nUn frammento del codice per la cifratura autenticata simmetrica. Si vedono le funzioni per il\ncalcolo dell‚ÄôHMAC e per la cifratura.\nNel codice sopra si possono indentificare le funzioni ChaCha, che inizialmente avevamo\nincorrettamente identificato come salsa20.\n\nQueste si riconoscono per via di come √® inizializzato lo stato.\n\n\n-----\n\nLa stringa evidenziata sono in realt√† 4 DWORD scelte da D.J. Bernstein\nLa stringa mostrata sopra indica che siamo in presenza di Salsa20 o ChaCha. Il layout in\nmemoria dello stato ha permesso di identificare le funzioni come implementazioni di ChaCha\ne non di Salsa20 (confermato poi sperimentalmente).\n\nChaCha infatti salva la stringa in modo continuo nel suo stato, il popolamento dello stato ha\npermesso di identificare la funzione per il setup della chiave e dell‚ÄôIV e, per esclusione,\nquella di cifratura.\n\nL‚Äôultima primitiva usata da NetWalker √® X25519. Ci sono due elementi chiave per la sua\nidentificazione.\n\n**Il primo √® che le viene passato un buffer, di 32 byte, riempito di zeri tranne per il primo byte,**\nche ha valore 9.\n\n\n-----\n\nUn buffer di 32 byte composto da un 9 seguito da zeri √® molto probabilmente il punto iniziale\nin una curva ellittica\n**[L‚Äôaltro elemento, forse pi√π decisivo, √® l‚Äôoperazione di clamping fatta sul secondo buffer](https://cr.yp.to/ecdh.html)**\npassato alla funzione.\n\nI valori 248, 63 e 64 sono decisivi per identificare la primitiva.\nIl clamping √® tipico di X25519 (ed Ed25519) ed insieme al punto iniziale di valore 9,\npermettono di identificare la primitiva come X25519.\n\n### X25519 e le altre primitive\n\nRispolverando le propriet√† di X25519, almeno quelle usate da NetWalker, possiamo dire che:\n\nLa primitiva X25519(SK, Base) prende in input un intero (SK) ed un punto sulla curva (Base)\ne ritorna il loro prodotto.\n\nQuesta viene usata per generare un segreto in comune tra due comunicanti remoti senza\nche esso sia trasmesso o che sia calcolabile dalle informazioni trasmesse.\n\nIl classico uso del problema del logaritmo discreto ma applicato a questa specifica curva\nellittica.\n\nPer generare una coppia di chiavi si usa:\n\n**SK = 32 byte randomA**\n\n\n**PK = X25519(SK, B )A** **A** **9**\n\n\n-----\n\ndove B √® il punto di valore 9.9\n\nSupposto che Alice e Bob abbiamo una coppia di chiavi chiascuno:\n**SK = 32 byte randomA**\n**PK = X25519(SK, B )A** **A** **9**\n**SK = 32 byte randomB**\n**PK = X25519(SK, B )B** **B** **9**\nquesti possono generare un valore segreto comune (da usare come chiave simmetrica) solo\nscambiandoli le chiavi pubbliche:\n**shared = X25519(SK, PK )A** **B** Alice\n**shared = X25519(SK, PK )B** **A** Bob\n\n\nNetWalker combina le primitive in due funzioni di alto livello:\n\n**hash = SHA256p1(m). E‚Äô lo SHA256 di m ma il primo byte dell‚Äôhash √® incrementato di uno.**\nSolo il primo byte √® incrementato, con un‚Äôaddizione modulo 2 (in pratica √® usata l‚Äôistruzione8\n```\ninc BYTE [...] ).\nSHA256p1(m):\n hash[32] = SHA256(m)\n hash[0] += 1\n return hash\n\n```\n**pk, h, shared = computeShared_Hash_Pk(pk_in). Ha il compito di generare una nuova**\ncoppia di chiavi (pk, sk), di ottenere un valore condiviso shared da (sk e pk_in) e di\ncalcolare lo SHA256p1 di shared.\n```\nmake_sk():\n  rnd = RtlRandomEx if os_version > 0x51 else RtlRandom\n  seed = GetSystemTimeAsFileTime()\n  return [rnd(seed) for _ in range(32)]\ncomputeShared_Hash_Pk(pk_in):\n  sk[32] <- make_sk()\n  pk = X25519(sk, B9)\n  shared = X25519(sk, pk_in)\n  h = SHA256p1(shared)\n  return pk, h, shared\n\n```\n_Abbiamo introdotto la funzione make_sk() per facilit√† di notazione futura, in quanto_\n_NetWalker usa sempre questo metodo per la generazione di chiavi segrete. Usiamo inoltre la_\n_notazione_ `<- e non` `= per l‚Äôassegnazione, a rimarcare la natura casuale della funzione`\n```\nmake_sk() .\n\n```\nLa chiave segreta √® generata salvando l‚Äôora di sistema come ritornata da\n```\nGetSystemTimeAsFileTime ed usando RtlRandomEx (o RtlRandom, in versioni di\n\n```\nWindows pi√π vecchie).\n\n\n-----\n\n**hmac, c = HMAC_and_encrypt(key, iv, data, len). Cifra data usando ChaCha e la chiave e**\nl‚ÄôIV passati (solo i primi 8 byte, gli altri non servono). Inoltre calcola l‚ÄôHMAC di data usando la\nchiave passata.\n```\nHMAC_and_encrypt(key, iv, data, len):\n  c = chacha8(key = key, iv = iv[0..8], data, len)\n  hmac = hmac_sha256(key = key, data, len)\n  return hmac, c\n\n## La chiave segreta e gli altri buffer\n\n```\nCome visto nel punto precedente X25519 non permette di cifrare, √® una primitiva usata per\nlo scambio di chiavi.\n\nIn preparazione per la fase di cifratura, NetWalker genera una chiave segreta e la relativa\nchiave pubblica.\n```\nsecret1 <- make_sk()\npk1 = X25519(secret1, B9)\ncrc_pk1 = CRC32(pk1)\n\n```\nPK1 sar√† la chiave pubblica usata per generare la chiave di cifratura di ogni file. Vedremo\nche al momento di cifrare un file, una coppia di chiavi (PK, SK )F _F_ √® generata per quel file ed\nun segreto shared = X25519(SK, PK1)F _F_ √® ottenuto per essere usato come chiave ChaCha.\n\n\nIl CRC32 (calcolato usando `RtlComputeCrc32 ) √® usato per il check, lato attaccanti, dei dati`\nricevuti.\n\nRisulta quindi necessario conoscere secret1 per riottenere lo stesso segreto a partire da\n_PKF . (SKF non √® mai salvata, e risulta essere, di fatto, una chiave effimera)._\n\n_secret1 √® l‚Äôunica chiave segreta non effimera, cio√® effettivamente necessaria e recuperabile_\ndai criminali.\n\nPer trasmetterla a loro viene quindi cifrata a sua volta. Questo √® fatto generando un‚Äôaltra\ncoppia di chiavi ed usando mpk per generare un segreto comune con i criminali.\n\nL‚Äôuso delle funzioni di alto livello viste sopra √® uniforme in tutto NetWalker ed ha sempre la\nforma mostrata qui sotto.\n```\npk2, h_shared1, shared1 = computeShared_Hash_Pk(mpk)\n\n```\n_shared1 √® l‚Äôaltro segreto di vitale importanza, esso √® usato per cifrare secret1:_\n```\nhmac_secret1, e_secret1 = hmac_and_encrypt(shared1, h_shared1, secret1, 0x20)\n\n```\n\n-----\n\nLa generazione di secret1, di shared1 per la cifratura del primo, del CRC32 di PK1 e la\ncifratura stessa di secret1.\n\n\n-----\n\nIl ransomware procede adesso con la creazione di quattro buffer, che abbiamo rinominato:\n_buffer5C, buffer6C, bufferVar e bufferP50._\nIl primo √® un buffer di lavoro usato estensivamente da NetWalker, gli altri tre sono buffer\ntemporanei usati per la creazione del JSON misterioso (che risulter√† essere proprio il\nbase64 di bufferP50).\n\nIniziamo con il `buffer6C poich√® √® quello pi√π immediato ed √® linkato a` `buffer5C . Il codice`\nche lo genera √® dentro la stessa funzione che genera le chiavi sopra.\n\nCreazione e popolamento del buffer6C\nIl buffer ha il seguente layout.\n\n\n-----\n\n```\nFormat is XX: YYYY where XX is the offset of the field (in hex) and YYYY its\ndescription.\nAll values are native. The arrays hold native data too.\n00-04: CRC32(pk1)\n04-24: pk2\n24-2c: h_shared1\n2c-4c: hmac_secret1\n4c-6c: e_secret1\n\n```\n_buffer6C √® quindi fondamentale per il recupero di secret1._\nInfatti tramite shared1 = X25519(SKcrim, PK2) √® possibile ottenere shared1, decifrare secret1\ncon secret1 = chacha8(key = shared1, iv = h_shared1, data = e_secret1, len = 0x20),\nverificarne la correttezza con HMAC-SHA256(secret1) == hmac_secret1 e tramite il controllo\naggiuntivo CRC32(X25519(secret1, B9)) == CRC32(pk1).\nPermette quindi ai criminali di riottenere tutte le chiavi necessarie alla decifratura dei file.\n\nIl buffer6C √® salvato nel buffer5C, quest‚Äôultimo √® usato frequentemente e contiene valori utili\nal malware.\nNe riportiamo una mappa, il suo popolamento avviene dentro la funzione\n```\nprepareForEncryption e non presenta grosse difficolt√† per l‚Äôanalista.\nFormat is XX: YYYY where XX is the offset of the field (in hex) and YYYY its\ndescription.\nAll values are native. The arrays hold native data too.\n00: OS major\n04: OS minor\n08: is WOW64 process\n0c: 10: current process id\n14: idsz\n18: hex(crc32(pk1))[0..idsz]\n1c: same as 0x18 but in unicode\n20: will be pupulated with net names\n24: len of the buffer at 0x20\n28: CRC32(mpk)\n2c: mpk\n30: CRC32(pk1)\n34: pk1\n38: size of buffer6C (which is 0x6c)\n3c: ptr buffer6C\n40: len of str at 0x44\n44: unicode str for ., where is str at 0x1c\n48: lfile string, interpolated, len\n4c: lfile string, interpolated\n50: lfile string, interpolated with * as {id}\n54: lend string, interpolated, len\n58: lend string, interpolated\n\n```\n\n-----\n\nI valori nel `buffer5C sono tutti di immediata comprensione, eccetto forse per quelli descritti`\ncome ‚Äúinterpolated‚Äù.\nCon questo nome si intende il valore ottenuto da una stringa con placeholder del tipo {id} o\nsimili, una volta sostituito a questi un valore.\nAd esempio `{id}-Readme.txt, una volta interpolato, pu√≤ divenire` `24138-ReadMe.txt .`\nIl nome si rif√† alla funzionalit√† di string interpolation di molti linguaggi moderni.\nLa stringa all‚Äôoffset `0x50, ovvero` `*-Readme.txt (secondo la configurazione mostrata`\nall‚Äôinizio), √® usata per controllare se nella directory di un file appena cifrato √® gi√† presente il\nmanifesto per il riscatto (ed eventualmente crearlo).\nAltro valore importante √® la stringa a `0x18, ovvero il CRC32(pk1) convertito in hex e`\ntroncato ai primi `idsz caratteri.`\nQuesto √® l‚Äôid della vittima, lo chiameremo, appunto, id nel seguito.\n\nUna volta preparato il `buffer5C, NetWalker scrive il contenuto del manifesto per il riscatto.`\nIn particolare ci interessa il campo {code} che viene riempito con un JSON.\n\nViene prima creato il `bufferVar, di dimensione idsz + 0x74 + strlen(lfile), cos√¨ fatto:`\n```\nFormat is XX: YYYY where XX is the offset of the field (in hex) and YYYY its\ndescription.\nAll values are native. The arrays hold native data too.\n00: copy of buffer6C\n6C: idsz (i.e. len of victim's id)\n70: victim's id\n74: len of lfile\n78: lfile\n\n```\nQuesto buffer contiene il `buffer6C e qualche informazione in pi√π, necessarie ai criminali`\nper sapere quale estensione hanno i file cifrati (in modo da poterli enumerare) e come si\nchiamano i file di manifesto (in modo da poterli rimuovere).\n\nQuesto buffer √® essenzialmente il contenuto del JSON contenuto nel manifesto ma non cos√¨\ncome mostrato.\nPer qualche motivo infatti `bufferVar √® cifrato ancora una volta:`\n```\npk3, h_shared2, shared2 = computeShared_Hash_Pk(mpk)\nhmac_buffer_var, e_buffer_var = hmac_and_encrypt(key = shared2, iv = h_shared2, data\n= bufferVar, len = len(bufferVar))\n\n```\nViene, infine creato l‚Äôultimo buffer, `bufferP50, che contiene le informazioni per decifrare`\nbufferVar (il quale contiene le informazioni per cifrare secret1, che serve per decifrare i file):\n\n\n-----\n\n```\nFormat is XX: YYYY where XX is the offset of the field (in hex) and YYYY its\ndescription.\nAll values are native. The arrays hold native data too.\n00: h_shared2\n08: hmac_buffer_var\n28: pk3\n48: CRC32(mpk)\n4c: CRC32(pk1)\n50: e_buffer_var\n\n```\nGli attaccanti possono generare shared2 = X25519(SKcrim, pk3) e decifrare il bufferVar.\n\nIl `bufferP50 √® convertito in base64, diviso in linee di 50 caratteri e poi usato per generare`\nil JSON dalla forma `{code_<id>: base64(bufferP50)} .`\n\nLa\n\n\n-----\n\ngenerazione del JSON misterioso. Con tutte le primitive identificate, la sua analisi √® banale.\nDi seguito un riepilogo.\n\n\n-----\n\nLa struttura del JSON da inviare ai criminali affinch√® possano decifrare i file\n\n## Il flusso di lavoro del malware\n\n\n-----\n\nUna volta preparate le chiavi per la cifratura, il flusso di lavoro del malware √® abbastanza\nimmediato.\n\nIl flusso di lavoro. Nella parte finale, non mostrata, il malware prova a scrivere il manifesto\nnel desktop e nelle root dei dischi impersonando explorer.exe (sebbene sia gi√† eseguito nel\ncontesto di questo)\nLe operazioni del malware sono, in ordine:\n\n**Acquisizione dei privilegi di Debug e impersonificazione di altri processi.**\n\n**Avvio dei thread per la terminazione dei processi (usando NtQuerySystemInformation),**\ndei servizi (usando le API del service manager) e dei task (usando l‚Äôinterfaccia come\nITaskService) indicati nella configurazione.\n\n**Controllo della presenza di file in uso da altre applicazioni. Il controllo avviene usando**\n```\nNtQuerySystemInformation, con classe 0x10 per ottenere tutti gli handle aperti,\n\n```\nduplicando ognuno di essi e verificando se √® possibile mapparne un byte. Questo controllo\nserve a considerare solo gli handle di tipo file\n\n\n-----\n\n**Recupero del token di explorer.exe. per fare ci√≤ il malware usa GetSystemInformation per**\nenumerare tutti i processi. Prima impersona `winlogon.exe e dopo recupera il token di`\nexplorer.\n\n**Avvio dei thread di lavoro. Viene inizializzata una lista doppia concatenata che contiene,**\nper ogni elemento, un puntatore alla procedura da eseguire ed un puntatore ai dati di questa.\nVengono poi creati due thread: uno consuma un elemento dalla lista (se presente) e crea un\nnuovo thread se il numero totale di thread non supera quello indicato dalla configurazione.\nL‚Äôaltro thread rimuove i thread finiti (scorrendo il buffer con i loro handle ed usando\n```\nWaitForSingleObject ) e decrementa il conteggio, permettendo la creazione di nuovi\n\n```\nthread.\n\n\n-----\n\nLa creazione dei due thread: uno per il dispatch ed uno per rimuovere i thread terminati\nAl momento non vi √® ancora lavoro per i thread.\n\n**Viene creato un file di manifesto per il riscatto nel desktop ed aperto con notepad.**\n\n**Enumera i dischi locali e di rete e per ognuno di essi avvia un task di cifratura.**\n\n\n-----\n\nL‚Äôenumerazione dei dischi e i relativi task di cifratura\n\n\n-----\n\nIl task per la cifratura dei dischi si aspetta come parametro un percorso (inizialmente le root\ndei dischi) ed usa `FindFirstFileEx per enumerare tutte le cartelle ed i file in questo`\npercorso.\nPer le cartelle, crea un nuovo task con il loro percorso mentre per i file chiama la procedura\ndi cifratura.\n\nUna parte della funzione di cifratura di un percorso, si vedono il passo ricorsivo (al centro in\nbasso) e quello terminale. Inoltre √® presente il controllo della whitelist in configurazione\n\n## La cifratura di un file\n\nNel file IDA allegato, la funzione di cifratura √® chiamata `CryptFile, e poich√® piuttosto`\nverbosa e lunga non mostriamo qui lo screenshot, ma ci limitiamo a descriverne il\ncomportamento:\n\n1. Gli attributi originali del file sono salvati e poi cambiati in `FILE_ATTRIBUTE_ARCHIVE .`\n\n\n-----\n\n2. Il file √® aperto con `CreateFileW e, se questa fallisce, viene usata la procedura di`\n\nunlocking (Se configurata).\nQuesta enumera tutti gli handle, considera solo quelli di tipo file e che non\nappartengono ai processi come indicato in configurazione, trova l‚Äôhandle interessato e\nlo duplica chiudendolo nel processo sorgente (con `NtDuplicateHandle ) 0`\nchiudendolo poi definitivamente.\nLa cifratura √® riprovata.\n3. Viene recuperata la dimensione del file.\n4. Viene letta l‚Äôultima DWORD del file, se questa √® CRC32(pk1), il file √® saltato. Questo\n\ncontrollo √® fatto per saltare i file gi√† cifrati.\n5. In base alla dimensione del file viene scelto un modo (a meno che la configurazione\n\nnon forzi un modo diverso da 0).\nIl modo 0 cifra tre parti del file di dimensione spsz: una all‚Äôinizio, una a met√† (all‚Äôoffset:\n```\n  [(spsz + size / 2 - 1) / spsz] * spsz, che √® una met√† arrotondata per\n\n```\neccesso) ed una alla fine.\nIl modo 1 √® come il modo 0 ma cifra solo la parte all‚Äôinizio del file.\nIl modo 2 cifra tutto il file.\n6. La cifratura √® fatta di ogni singolo pezzo usando le chiavi:\n\n**pkF, h_sharedF, sharedF = computeShared_Hash_Pk(pk1)**\nogni pezzo √® cifrato usualmente e riscritto inplace nel file\n**hmac_pezzo, pezzo_cifrato= hmac_and_encrypt(key = sharedF, iv = h_sharedF,**\n**data = pezzo_in_chiaro, len = len(pezzo_in_chiaro))**\nGli HMAC sono collezionati in un buffer apposito.\n7. Viene generato un buffer (detto bufferX) contenente\n\n```\nXX: len of file original basename\n\n```\n```\nXX: file original basename\n\n```\nQuesto buffer √® necessario per riottenere il nome originale del file, nel caso la cifratura\ndei nomi dei file sia attivata nella configurazione.\nQuesto buffer √® cifrato con le stesse chiave, generate al punto 6, usate per cifrare i dati\ndel file.\n\n\n-----\n\n8. Viene creato un buffer, poi scritto alla fine del file, che ha la struttura:\n```\n   XX: bufferX encrypted\n   XX: len of buffer\n   XX: hmac bufferX\n   -b8: hmacs of the encrypted file parts\n   -98: h_sharedF\n   -94: mode used\n   -90: spsz used\n   -24: buffer6C\n   -04: pkF\n   -00: CRC32(mpk)\n\n```\nIl buffer contiene pkF, necessaria per la decifratura del file (vedi sotto). Contiene inoltre\ntutte le informazioni su quali parti sono state cifrate, i loro HMAC e il CRC32 di mpk,\nper indicare che il file √® gi√† stato cifrato.\nNotare che il buffer √® strutturato per essere letto al contrario, dalla file del file verso\nl‚Äôinizio.\nInfine questo buffer contiene `buffer6C, permettendo ai criminali di decifrare i file`\ncaricati, come prova della loro ‚Äúonest√†‚Äù.\n9. Il file viene rinominato (eventualmente cifrando il suo nome, se attivato dalla\n\nconfigurazione) per includere l‚Äôestensione .<id>.\n10. Se nella cartella del file non √® gi√† presente un manifesto per il riscatto, questo viene\n\ncreato.\n11. Gli attributi originali del file sono ripristinati.\n\nPer decifrare un file √® necessario conoscere sharedF, siccome questa √® generata con PK1,\n√® possibile ottenerla con:\n\n```\nsharedF = X25519(secret1, pkF)\n\n```\n\nper cui secret1 √® la chiave necessaria per la decifratura dei file e questo spiega il motivo per\ncui √® stata cifrata con tanta cura nella preparazione.\n\n\n-----\n\nLa\n\n\nstruttura, semplificata, di un file cifrato da NetWalker\n\n## Esiste la possibilit√† di un decryptor?\n\nLa risposta √®: No!\n\n\n-----\n\nLa generazione di secret1 usa `GetSystemTimeAsFileTime come seed, ci si pu√≤ chiedere`\nse sia possibile predisporre un attacco bruteforce.\nIn fin dei conti, poco dopo la generazione di secret1 viene creato il file di manifesto nel\ndesktop, per cui la sua data di creazione non sar√† mai troppo lontana dal seed usato\n(probabilmente un secondo, pari a 10 milioni di possibili valori di seed, √® sufficiente).\n\nUn analista pu√≤ recuperare dalla vittima il valore CRC32(pk1), ed enumerare tutti i valori del\nseed fino a che CRC32(X25519(make_sk(candidate_seed), B9)) non √® uguale al valore\nrecuperato.\nNel caso lo sia, si pu√≤ procedere alla conferma, generando sharedF =\n_X25519(make_sk(candidate_seed), pkF) e verificando se i pezzi sono stati correttamente_\ndecifrati (grazie agli HMAC).\n\nTuttavia `RtlRandomFunctionEx non usa solo il seed per generare il numero casuale.`\nEssa ha un pool di entropia di 128*4 byte e quindi non √® possibile solo dal seed riottenere la\nstessa sequenza di numeri casuali usata da NetWalker.\n\nL‚Äôimplementazione di RtlRandomEx\n\n## I database IDA\n\nCondividiamo per comodit√† i DB IDA utilizzati, per facilitare il lettore nel seguire l‚Äôarticolo.\n\n**Link: Scarica i** [DB IDA](https://cert-agid.gov.it/wp-content/uploads/2020/11/netwalker-ida.zip)\n\n[Taggato NetWalker](https://cert-agid.gov.it/tag/netwalker/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-11-06 - Netwalker Ransomware.pdf"
    ],
    "report_names": [
        "2020-11-06 - Netwalker Ransomware.pdf"
    ],
    "threat_actors": [
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535571,
    "ts_updated_at": 1743041139,
    "ts_creation_date": 1653775680,
    "ts_modification_date": 1653775680,
    "files": {
        "pdf": "https://archive.orkl.eu/7ab8f4832a766982c4b65fa8437264880314067a.pdf",
        "text": "https://archive.orkl.eu/7ab8f4832a766982c4b65fa8437264880314067a.txt",
        "img": "https://archive.orkl.eu/7ab8f4832a766982c4b65fa8437264880314067a.jpg"
    }
}