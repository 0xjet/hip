{
    "id": "3bab161b-4422-4a15-965f-14a9808d8f36",
    "created_at": "2023-01-12T15:02:36.312004Z",
    "updated_at": "2025-03-27T02:09:18.044468Z",
    "deleted_at": null,
    "sha1_hash": "c6783391ccbd04f3d32853efed3425837fd543cf",
    "title": "2021-05-25 - Cobalt Strikes Again- An Analysis of Obfuscated Malware",
    "authors": "",
    "file_creation_date": "2022-05-27T21:55:06Z",
    "file_modification_date": "2022-05-27T21:55:06Z",
    "file_size": 11766123,
    "plain_text": "# Cobalt Strikes Again: An Analysis of Obfuscated Malware\n\n**[huntress.com/blog/cobalt-strike-analysis-of-obfuscated-malware](https://www.huntress.com/blog/cobalt-strike-analysis-of-obfuscated-malware)**\n\nHow deep can a rabbit hole go? Recently, we discovered a suspicious-looking run key on a\nvictim system. It was clear that the key was likely malicious, but it didn‚Äôt seem like anything\nout of the ordinary.\n\n[Little did we know, we were about to encounter Cobalt Strike malware hidden across almost](https://www.cobaltstrike.com/)\n700 registry values and encased within multiple layers of fileless executables.\n\nThis particular malware sample went to great lengths to hide itself, deploying numerous\n[evasion tactics and obfuscation techniques in order to evade detection and analysis. And as](https://www.huntress.com/blog/tried-and-true-hacker-technique-dos-obfuscation)\nyou'll see, it goes to show the great lengths hackers will go to evade detection and\ncompromise their targets.\n\nLet's dive in.\n\n## What is Cobalt Strike?\n\nCobalt Strike is a commercial threat-emulation and post-exploitation tool commonly used by\nmalicious attackers and penetration testers to compromise and maintain access to networks.\nThe tool uses a modular framework comprising numerous specialized modules, each\nresponsible for a particular function within the attack chain. Some are focused on stealth and\nevasion, while others are focused on the silent exfiltration of corporate data.\n\n\n-----\n\nWhile the intent of Cobalt Strike is to better equip legitimate red teams and pen testers with\nthe capabilities of sophisticated threat actors, it is often misused when in the wrong hands.\nYou know what they say... with great power comes great responsibility. Cobalt Strike is an\nundeniably powerful framework, but it's easily weaponized by malicious actors as a go-to tool\nfor undercover attacks.\n\n## Finding Cobalt Strike Malware\n\nIt all started with a RunOnce key, which is typically found here:\n```\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\n\n```\nThis key is used to automatically execute a program when a user logs into their machine.\nSince this is a ‚ÄúRunOnce‚Äù key, it will automatically be deleted once it has executed. Typically,\nthis is used by legitimate installation and update tools to resume an update after reboot‚Äîbut\nnot to resume after every reboot.\n\nThere are also ‚ÄúRun‚Äù keys, which don‚Äôt get removed each time and are used both\n[legitimately and maliciously to create persistent footholds between reboots.](https://www.huntress.com/blog/what-is-a-persistent-foothold)\n\nIn this particular case, we found multiple commands for legitimate applications contained in\nthe RunOnce key, but there was one that looked awfully suspicious. üëÄ\n\nWe inspected the command in the suspicious key and found this, which seemed to be\nexecuting a PowerShell command stored in one user‚Äôs environment variables.\n\nLooking at the command in further detail, we can note that it does the following:\n\nloads PowerShell in a hidden window\nloads the environment variables of the current user\nloads a value from the environment with the same name as the current user\n\nretrieves the data from this value and uses them as arguments for the PowerShell\ncommand\n\nThis was starting to look extremely suspicious, and we knew we had to find out what was\nlurking in that environment variable.\n\nAfter extracting that environment variable from the machine, we found a PowerShell\ncommand, this time executing a Base64 encoded string. After decoding and cleaning up the\nBase64 string, it ended up looking like this:\n\n**What Does This Script Do?**\n\n\n-----\n\nIf you re unfamiliar with PowerShell, that script may look a bit intimidating. Ultimately, the\nPowerShell script achieves four main things:\n\nLoads an obfuscated string that has been stored in the registry.\nDe-obfuscates the string and converts the result into a byte array.\nLoads the byte array into memory as a DLL using PowerShell reflection (this is a\ncommon evasion technique that avoids writing a decoded payload to disk).\n\nExecutes the ‚Äútest‚Äù method of that DLL, located in the ‚ÄúOpen‚Äù object class.\n\nFrom a more technical lens, here‚Äôs a line-by-line breakdown of the PowerShell script in\naction:\n\n**Lines 1-9: This section is used to pull data from some more registry keys (up to 700 of**\nthem) and stores this data in a string.\n**Lines 10-17: This defines a function that takes that string and converts it into a byte**\narray. This usually indicates that the string will be used to create an executable file.\n**Lines 19-25: This section is a bit strange. It essentially generates the number 1000**\nand stores it into the $ko variable. It does this in a way that takes a million loop\niterations to generate‚Äîwhich might be an anti-analysis technique.\n**Line 27: Loads the StringToBytes function, but first replaces any instance of the #**\ncharacter with the number in $ko.\n**Line 28: Utilizes reflection to load the byte array into memory as a DLL. This avoids**\nwriting the payload to disk and is a common antivirus evasion technique.\n\n**Line 29: Executes the ‚Äútest‚Äù function of the loaded DLL.**\n\nThe [Huntress ThreatOps team was able to retrieve the relevant registry values from the](https://www.huntress.com/platform/threatops)\nvictim system and modify the script to dump out the payload as a file instead of loading it into\nmemory. This resulted in our first executable payload.\n\n## The First Binary File\n\nAfter successfully reversing that first PowerShell script, we were able to recreate the binary\nfile that it was loading into memory. This file was a 6KB 32-bit .NET binary file.\n\n\n-----\n\nGiven the rather small size (only 6KB) of this file, we were suspicious that we might have\nmissed something. The file seemed too small to contain a proper payload. We suspected\nthat this was not the final payload and was likely a stager used to retrieve another payload.\n\nSince the file was written in .NET, we were able to load it into dnSpy to analyze the source\ncode. This is possible because .NET does not fully compile in the same way that C/C++ code\ndoes and instead ‚Äúcompiles‚Äù to an intermediary bytecode format that can be converted back\ninto source code by tools like dnSpy.\n\nSo, we loaded the file into the dnSpy tool and were quickly able to find the ‚ÄúOpen‚Äù class\nreferenced by the PowerShell script‚Äîwhich is where we found the following code.\n\n\n-----\n\nWhat's interesting is that this code seemed to be loading even more registry values from a\nsuspicious registry key and resetting the RunOnce registry values that initially triggered the\ninvestigation. This allows the malware to persist across reboots as if it were a regular Run\nkey.\n\nOur team was then able to retrieve the suspicious registry key that was being loaded from\nthe user‚Äôs machine, where we found encoded data that was spread across 662 Registry\nvalues. Since the data was pre-formatted in JSON, it was simple to write a regex to dump\nonly the relevant data to a text file. Once this was done, we were able to decode it using a\nsimple Python script‚Äîwhich was essentially just a wrapper around the original code used by\nthe malware.\n\n## The Second Binary File\n\nUsing the output of the Python script, we were able to produce another 32-bit .NET binary\nfile. This one was significantly larger than the first file, so we knew we were getting\nsomewhere!\n\n\n-----\n\nSince this was another .NET file, we loaded it up into dnSpy for another round of analysis.\nThis is where we noticed some interesting evasion and anti-analysis techniques.\n\n**Evasion Techniques: Part One**\n\nThe first thing we noticed was numerous sleep functions scattered across the code, which\nwould cause the program to sleep for 60 seconds between the components of its initial\nsetup.\n\nThis technique is often used to bypass automated scanning tools that don‚Äôt have the time to\nwait for the sleep functions to complete. It can also be used to evade manual dynamic\nanalysis, since an analyst may falsely believe that the malware is not doing anything when\nit‚Äôs actually just taking a quick nap.\n\nLearn More: To dive into more defense evasion techniques, check out our Intro to Antivirus\n_Evasion session from this year's hack_it event!_\n\n**Obfuscation**\n\n\n-----\n\nDeeper down in the code, we observed numerous references to functions used to perform\nprocess injection. The names of these functions were lightly obfuscated using exclamation\nmarks, which can be seen on the right side of the below screenshot.\n\nBrowsing further, we find the victim process that the malware is targeting for the injection. In\nthis case, it was the genuine (and signed) Windows ‚ÄúWerfault.exe‚Äù process.\n\nThis is a legitimate process used by the Windows OS for error reporting‚Äîand it was likely\ntargeted for two reasons:\n\nIt's a genuine and signed Windows process. These are sometimes ignored or\n[whitelisted by detection systems. (Look up LOLBAS as to why it‚Äôs a terrible idea to](https://lolbas-project.github.io/#)\nwhitelist Microsoft binaries.)\n\nSince the Werfault.exe process performs error reporting, it may have legitimate\nreasons for making external network connections, meaning any malicious traffic\ncreated by the malware will have something to blend in with.\n\nThis is consistent with [SpecterOps‚Äô usage recommendations for Cobalt Strike.](https://posts.specterops.io/a-deep-dive-into-cobalt-strike-malleable-c2-6660e33b0e0b)\n\n\"Consider choosing a binary that would not look strange making network connections.\"\n\n\n-----\n\nAs we continued browsing, we found that a large string contained the payload to be injected\ninto Werfault.exe. If you look closely, you can see that it is lightly obfuscated with # values,\nwhich are later replaced with the number 1000.\n\n## The Third Binary File\n\nGetting closer! But this time, the data we saved as our third binary file was not a .NET, so we\ncan‚Äôt peek at the source code using dnSpy.\n\nWe are dealing with a 32-bit Delphi compiled binary, with a fake compiler timestamp dated in\n1992. In case you‚Äôre not familiar with Delphi, it‚Äôs a programming language that allows you to\nwrite, package and deploy cross-platform native applications across a number of operating\nsystems.\n\n\n-----\n\n**Evasion Techniques: Part Two**\n\nWe initially performed some basic static analysis and found that the strings within the code\ncontained references to VirtualProtect (commonly used in process injection), but this function\nwas not listed in the import table. This indicated that the code was likely resolving some\nfunctions at runtime, which is suspicious behavior‚Äîand yet another tactic used to evade\npreventive security tools and thwart analysis.\n\n[We also noted the presence of GetProcAddress and](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) [LoadLibrary, which further confirmed](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya)\nour suspicions that the file may be loading functions at runtime.\n\nIf you‚Äôre not familiar, GetProcAddress is a Win32 API call often used in reflection techniques\nthat can be used to find the memory address of a given symbol (essentially a function) at\nruntime. LoadLibrary is another Win32 API that loads a DLL into the context of the currently\nrunning process. These two functions combined allow a piece of malware to hide\nfunctionality from static analysis and potentially evade some basic forms of detection.\n\n\n-----\n\nLoading up the file within the x32dbg debugger, we observed a large number of calls to the\nsleep function, which would cause the program to sleep 10 seconds between performing\nsuspicious actions. This is yet another anti-analysis tactic.\n\nAfter getting through the sleep calls, we finally made it to some suspicious functions‚Äî\nnamely some calls to VirtualAlloc and VirtualProtect.\n\n[VirtualAlloc is a Win32 API call that will allocate a section of memory that can be used later in](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)\nthe program‚Äôs runtime. Typically, malware might allocate memory and then move malicious\ncode (such as shellcode) into that section before executing it with another API call like\nCreateThread.\n\n[VirtualProtect is an API call that will change the memory protections on a given memory](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)\nsection, this is used to mark a section of memory as readable, writable and/or executable.\n\nPaying close attention to suspicious functions and newly allocated sections of memory, we\neventually hit a breakpoint on CreateThread, which was targeting one of the newly allocated\nsections of memory created by the VirtualAlloc calls. We inspected that section further and\nfound an MZ header, indicating that we had found our fourth binary file.\n\n## The Fourth Binary File\n\nAfter dumping the newly discovered section from the debugger, and re-aligning the sections\nusing PE-bear, we were able to retrieve a fourth binary file: a 32-bit DLL, 315KB in size.\n\n\n-----\n\nInspecting the imports of the function, we observed even more references to VirtualAlloc and\nVirtualProtect, indicating that more process injection was about to take place.\n\nHowever, this time we noticed references to MemCpy, indicating that the process may be\ninjecting or overwriting code into itself rather than into a separate process. Note that if this\ncode was executing as intended, then ‚Äúitself‚Äù would refer to the already injected Werfault.exe\nprocess.\n\n\n-----\n\n[A few lines below the memory imports, we see references to named pipe functions being](https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes)\nimported by the malware. In most cases, named pipes are legitimately used for inter-process\ncommunication. But they are also a key component of Cobalt Strike beacons and a common\ntactic used to evade automated analysis as they tend to cause issues for emulation tools and\nautomated sandboxes.\n\nBelow, we can see something else interesting: a reference to a named pipe that is highly\nconsistent with the Default Naming Scheme of named pipes used by Cobalt Strike.\n\nWe won‚Äôt dive too much into this, but there are a few great write-ups on this topic on the\n[Cobalt Strike blog and by](https://blog.cobaltstrike.com/2021/02/09/learn-pipe-fitting-for-all-of-your-offense-projects/) [F-Secure Labs.](https://labs.f-secure.com/blog/detecting-cobalt-strike-default-modules-via-named-pipe-analysis/)\n\nIn order to confirm that this was really Cobalt Strike malware, and to try and pull more\n[information, we parsed the file using this Cobalt Strike Parser.](https://github.com/Sentinel-One/CobaltStrikeParser)\n\n\n-----\n\nThis worked great and confirmed our suspicions that this was Cobalt Strike.\n\nIt also allowed us to view the Cobalt Strike configuration file, which included the\ncommunication method (HTTPS POST requests) and the IP of the C2 Server.\n\nSubmitting that IP address to VirusTotal, we observed only 1/82 detections. This indicated\nthat the server may not have been widely used, or that it was potentially still active.\n\n\n-----\n\n## The Fifth Binary File\n\nWe are well beyond the point of necessary analysis, but we decided to continue down this\nrabbit hole.\n\nUsing a debugger, we tried to monitor the buffers used by the named pipes, as they are often\nused to move payloads and malicious data used by Cobalt Strike.\n\nShortly after monitoring these buffers, we found a new file appearing in memory. Note the\nMZRE Header, which is part of the default configuration of Cobalt Strike.\n\nDumping out that segment, we were able to pull a fifth binary file. This time, it appeared to be\nthe [Reflective Loader used by the Cobalt Strike Beacon. And as we loaded up the new](https://blog.cobaltstrike.com/2016/06/15/what-is-a-stageless-payload-artifact/)\nbinary, we can see that it is another 32-bit DLL, about 211KB in size.\n\n\n-----\n\nDoing some basic static analysis, we saw that the file is potentially downloading a\nPowerShell script from localhost, indicating that there may be a tiny web server storing\nPowerShell commands somewhere else in the code.\n\n## Manually Finding Indicators of Compromise (IOCs)\n\nEventually, we hit [LoadLibrary again and observed the WinInet.DLL and WS2_32.DLL](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya)\nmodule being loaded. Since these are Windows libraries used for network and web\ncommunication, we knew that the code might be about to reach out to its C2 Server.\n\nWe were able to set breakpoints on web-related functions, which confirmed some of the\nmalicious indicators extracted from the Cobalt Strike parsing tool. And one thing that we\n[noticed was that the beacon references the Avant Browser in the user-agent of its C2](https://www.google.com/search?q=avant+browser&oq=Avant+Browser)\nrequests. This likely means that the C2 server won‚Äôt respond (or will return something\nbenign) unless it sees that header.\n\n\n-----\n\n[Digging deeper, we also find pieces of the Malleable C2 commands used by the beacon,](https://www.cobaltstrike.com/help-malleable-c2)\nwhich in this case are embedded into HTTP cookie headers.\n```\n&‚ÄùCookie:\nJn9f/eO8Xfay/dYKGpmuBIXL6ZpnGtPuLtugLgeU5vsP4K/bMWYy21s2ulMVQjYmUq9ClOYS8XWbLNMwPV3y10\n\n```\nAlthough it looked like the data was Base64 encoded, we were unable to extract anything\nmeaningful from using variations of Base64 decoders.\n\nBut wait‚Äîare these actually addresses?\n\nLooking at the cookie data within the dump view, we noticed that there were three valid\nmemory addresses contained within the encoded version of the cookie data.\n\nOne of these referenced the ws2_32.DLL, and the other two referenced a suspicious section\nof memory.\n\n\n-----\n\nRunning strings on the memory sections referenced in the red underlines provided some\ninteresting results‚Äînamely lots of information about my virtual machine that the malware\nwas likely trying to send to the C2 server.\n\nContinuing on, we noticed some more references to the C2 server and the communication\nmethods used, as well as a reference to a full URL used by the payload.\n\n\n-----\n\nUnfortunately, we didn t have networking enabled on our test machine; so these requests all\nfailed, causing an infinite loop where the beacon would sleep for a while and try again. If we\nwere to enable networking, the beacon would likely download some additional payload\nmodules and begin to truly compromise our machine. Maybe in a later article we can retrieve\none of these payloads and do a deeper technical analysis of what this Cobalt Strike malware\nis capable of.\n\n- ‚Ä¢ ‚Ä¢\n\nThat wraps up our analysis of this persistence mechanism and the binary files involved. It\nwas a wild ride, and hopefully you enjoyed reading as much as we enjoyed researching.\n\nIf there's one lesson this should leave you with, it's that we simply can't rely on automated\ntools alone to protect our systems. Through all these layers of obfuscation and evasion\ntactics, it's clear just how many hoops hackers will jump through to execute their malware‚Äî\nand that's why you need some type of human element to catch these sneaky threat actors in\ntheir tracks.\n\nWe‚Äôll come back to this another day, but for now, this is the end of this rabbit hole.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-05-25 - Cobalt Strikes Again- An Analysis of Obfuscated Malware.pdf"
    ],
    "report_names": [
        "2021-05-25 - Cobalt Strikes Again- An Analysis of Obfuscated Malware.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535756,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653688506,
    "ts_modification_date": 1653688506,
    "files": {
        "pdf": "https://archive.orkl.eu/c6783391ccbd04f3d32853efed3425837fd543cf.pdf",
        "text": "https://archive.orkl.eu/c6783391ccbd04f3d32853efed3425837fd543cf.txt",
        "img": "https://archive.orkl.eu/c6783391ccbd04f3d32853efed3425837fd543cf.jpg"
    }
}