{
    "id": "bccdac57-f376-4522-ab91-ffacdbf7263e",
    "created_at": "2023-01-12T14:58:52.242807Z",
    "updated_at": "2025-03-27T02:05:26.29295Z",
    "deleted_at": null,
    "sha1_hash": "bc5394ce55a9028fd0f217ff38bf6698a10ba874",
    "title": "2020-06-25 - GuLoader- Peering Into a Shellcode-based Downloader",
    "authors": "",
    "file_creation_date": "2022-05-29T01:21:52Z",
    "file_modification_date": "2022-05-29T01:21:52Z",
    "file_size": 1862928,
    "plain_text": "# GuLoader: Peering Into a Shellcode-based Downloader\n\n**crowdstrike.com/blog/guloader-malware-analysis/**\n\nUmesh Wanve June 25, 2020\n\nGuLoader, a malware family that emerged in the wild late last year, is written in Visual Basic\n6 (VB6), which is just a wrapper for a core payload that is implemented as a shellcode. It is\n[distributed via spam email campaigns with archived attachments that contain the malware.](https://www.crowdstrike.com/epp-101/malware/)\nThe majority of malware downloaded by GuLoader is commodity malware, with AgentTesla,\nFormBook and NanoCore being the most predominant.\n\nThis downloader typically stores its encrypted payloads on Google Drive. CrowdStrike has\nobserved that GuLoader downloads its payloads from Microsoft OneDrive and also from\ncompromised or attacker-controlled websites. By utilizing legitimate file-sharing websites,\nGuLoader can evade network-based detection, as these services are not generally filtered or\ninspected in corporate environments. In addition, the downloaded payloads are encrypted\nwith a hard-coded XOR key embedded in the malware, making it difficult for file-sharing\nservice providers to identify the payload as malicious.\n\nGuLoader is an advanced downloader that uses shellcode wrapped in a VB6 executable that\nchanges in each campaign to evade antivirus (AV) detections. The shellcode itself is\nencrypted and later heavily obfuscated, making static analysis difficult.\n\n\n-----\n\nIn this blog, we cover GuLoader s internal details, including its main shellcode, anti-analysis\ntechniques and final payload delivery mechanism.\n\n## Analysis\n\nGuLoader is often distributed through spam campaigns that contain the malware embedded\nin archived attachments. An example of GuLoader spam email is shown in Figure 1.\n\nFigure 1: Sample spam email with RAR attachment (click image to enlarge)\n\nThe attachment contains a malicious executable file named `transfer request form.exe .`\nThe sample is a PE32 file written in Microsoft Visual Basic (just a wrapper for a shellcode\nthat implements the main functionality), as shown in Figure 2. Strings present inside the\nsample don’t reveal much as the binary is packed. The sample contains numerous calls to\nmeaningless VB functions that can slow down the analysis. By stepping through the\nassembly code, we will land into some block of code that is eventually used to decrypt the\nmain shellcode, as shown in Figure 2.\n\n\n-----\n\nFigure 2: Block of code used to decrypt main shellcode (click image to enlarge)\n\nThe snippet above contains junk code inserted within legitimate instructions to thwart\nanalysis. After analyzing and understanding this code further, we see that this code is\nresponsible for decrypting the main shellcode in memory. It uses a 4-byte XOR key to\ndecrypt the packed code to extract the final shellcode. The sample takes the first 4 bytes of\nencrypted data, XORs it with the ESI register and compares it with the value 0x200EC81,\nas shown in Figure 3.\n\n\n-----\n\nFigure 3: XOR key operation routine (click to enlarge image)\n\nIf it does not match, it keeps incrementing ESI and performs an XOR operation until the\nresult matches the expected value. The value `0x200EC81, read as little-endian, translates`\ninto the instruction `sub esp, 0x200, which is the actual start of the final shellcode.`\n```\n(First 4 bytes of encrypted data in little endian   XOR  0x200EC81) \n= XOR Key\n\n```\nwhich for this sample becomes:\n```\n(0x4DB824FD   XOR  0x200EC81)  =       0x4FB8C87C\n\n```\nAfter this, the decryption routine will call `VirtualAlloc() to allocate memory and start`\ndecrypting the final shellcode into the newly allocated memory by XORing encrypted data\nwith key `0x4FB8C87C, as shown in Figure 4.`\n\n\n-----\n\nFigure 4: Decrypted data in memory (click image to enlarge)\n\nOnce the shellcode is decrypted, the code will jump into that new shellcode for further\nexecution. Since the decryption routine has decrypted our shellcode, a memory dump of that\nnewly allocated region gives us lots of interesting strings, including API names and the final\nencrypted payload hosted on Google Drive, as shown below.\n\n### ASCII Strings\n```\n00001A7F hxxps[:]//drive.google.com/uc?export=download&id=1THDitP7iOm05w_6SQSb-C3tgd3cLMzO\n00001ADE Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like\nGecko\n0001B28 wininet.dll\n00001B3B InternetOpenA\n00001B4E InternetSetOptionA\n00001B68 InternetOpenUrlA\n00001B7E InternetReadFile\n00001B94 InternetCloseHandle\n00001BCB ntdll\n00001BD6 NtCreateSection\n\n```\n\n-----\n\n```\n00001BEB NtMapViewOfSection\n00001C03 NtClose\n00001C10 NtGetContextThread\n00001C29 NtSetContextThread\n00001C43 NtProtectVirtualMemory\n00001C5F NtAllocateVirtualMemory\n00001C7C NtWriteVirtualMemory\n00001C98 NtOpenFile\n00001CA9 NtResumeThread\n00001CBD DbgBreakPoint\n00001CD0 DbgUiRemoteBreakin\n00001CE8 NtSetInformationThread\n00001D05 kernel32\n00001D13 WaitForSingleObject\n00001D2D LoadLibraryA\n00001D40 CreateProcessInternalW\n00001D5C GetLongPathNameW\n00001D73 TerminateProcess\n00001D8A CreateThread\n00001D9C AddVectoredExceptionHandler\n00001DBD TerminateThread\n00001DD2 CreateFileW\n00001DE5 WriteFile\n00001DF5 GetFileSize\n00001E07 ReadFile\n00001E15 CloseHandle\n00001E26 Sleep\n00001E31 advapi32\n00001E3F RegCreateKeyExA\n00001E54 RegSetValueExA\n00001E68 user32\n00001E74 EnumWindows\n0000210F Startup key\n00002120 Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\n000021A0 shell32\n000021AD SHCreateDirectoryExW\n000021C8 ShellExecuteW\n\n## Analyzing Shellcode\n\n```\n\n-----\n\nFigure 5: Entry point of the main shellcode (click image to enlarge)\n\nThis entire shellcode is heavily obfuscated, contains lots of junk code and also contains antianalysis and anti-debugging tricks to make shellcode analysis more difficult. The shellcode\nstarts with a few lines that prepare the stack and registers for use within the function before\nan interesting `call 362BA9 instruction, as shown in Figure 6.`\n\nFigure 6: Heaven’s Gate technique (click to enlarge image)\n\nThe code in Figure 6 applies the Heaven’s Gate technique, the technique for executing code\nfrom x86 to x64 with the far `JMP command. The code checks the` `FS:[0xC0] register`\nvalue to see whether the system is x64 or not. If it is x64, the shellcode uses the Heaven’s\nGate call technique.\n\n**Accessing Kernel Imports via PEB**\n\nWhen a malware injects a payload into memory, it needs to determine which API calls to use;\nthis is done by using the Process Environment Block (PEB), which is always located at offset\n```\n0x30 within the Threat Information Block (TIB), which in turn is referenced by the segment\n\n```\nregister `FS:[0x00] . For example, a common method is to find the` `kernel32.dll`\naddress from the loaded modules and enumerate the export table of `kernel32.dll to find`\n```\nGetProcAddress() and start loading the API addresses required for its operation. Figure 7\n\n```\nshows the code that does this after the Heaven’s Gate function call.\n\n\n-----\n\nFigure 7: Accessing kernel imports via PEB (click image to enlarge)\n\n**DJB2 Hashes for Windows API Resolution**\n\nWhen GuLoader needs to call a Windows API function, it must first resolve the function’s\naddress, as it does not have an Import Address Table (IAT). The code shown in Figure 7\niterates through export functions of `kernel32.dll one by one, calculates the DJB2 hashes`\nfor each export API and compares those with the hardcoded hash value `CF31BB1F` (DJB2\nhash of `GetProcAddress API).`\n\n**Python Snippet for DJB2 Hash Calculation**\n\n1. `val = 0x1505`\n2. `inString = \"GetProcAddress\"`\n3. `for ch in inString:`\n4. `val += (val << 5)`\n5. `val &= 0xFFFFFFFF`\n6. `val += ord(ch)`\n7. `val &= 0xFFFFFFFF`\n8. `print(hex(val).upper().lstrip(\"0X\").rstrip(\"L\"))`\n\nOnce the shellcode matches the hash for the string name `GetProcAddress, it will calculate`\nits API address from `kernel32.dll . Then it will start resolving the required APIs shown in`\nthe appendix at the end of this blog.\n\n**Anti-Sandbox/Anti-Emulation**\n\n\n-----\n\nGuLoader also checks the number of application windows to detect an analysis environment.\nThis check uses the function `EnumWindows to enumerate and count all top-level windows`\non the screen. If the number of windows is less than 12, the malware calls\n```\nTerminateProcess with its own process handle as the parameter to terminate. This might\n\n```\nhave been done to evade sandboxes or emulator environments.\n\n**Anti-Attach: Patching DbgBreakPoint and DbgUIRemoteBreakin**\n\nThe Windows API functions `DbgBreakPoint and` `DbgUiRemoteBreakin are called when`\na debugger attaches to a running process. The shellcode patches these two APIs by\nreplacing the `INT3 opcode of` `DbgBreakPoint with` `opcode 90 (NOP, or “no-operation,”`\nto do nothing), and replacing the first few bytes of `DbgUIRemoteBreakin with a dummy call`\n(to cause a crash). This is done to prevent a debugger from attaching to the process, as\nshown in Figure 8.\n\nFigure 8: Patching `DbgBreakPoint and` `DbgUIRemoteBreakin (click image to enlarge)`\n\n**Unhooking API Hooks**\n\nThe shellcode performs some pattern matching in the `NTDLL API’s code functions — for`\nexample, searching for the byte pattern “\\xb8\\x00.{3}\\xb9,” which represents `NTDLL calls to`\nsystem calls. Many security products like AV, endpoint detection and response (EDR) and\nsandbox software put their hooks here, so they can detour the execution flow into their\nengines to monitor and intercept API calls and block anything suspicious. Basic user-mode\nAPI hooks by AV/EDR are often created by modifying the first 5 bytes of the API call with a\njump ( JMP ) instruction to another memory address pointing to the security software.\nConsidering this hooking mechanism, the shellcode scans for all such system calls and then\nrestores its first 5 bytes to the original bytes in `NTDLL, as shown in Figure 9.`\n\n\n-----\n\nFigure 9: Unhooking API hooks code (click image to enlarge)\n\nAs a result, GuLoader bypasses any hooks installed by anti-malware software. Lastly, it\nresets the `NTDLL ’s memory permissions back to` `PAGE_EXECUTE_READ only.`\n\n**Anti-debug (NtSetInformationThread)**\n\nNext, the shellcode calls the `NtSetInformationThread function with`\n```\nThreadHideFromDebugger ( 0x11 ) as the second parameter for hiding the thread from a\n\n```\ndebugger, as shown in Figure 10.\n\nFigure 10: `NtSetInformation thread function with` `ThreadHideFromDebugger parameter (click image`\n\nto enlarge)\n\nThis causes a crash in the debugged application when a breakpoint is hit in the hidden\nthread or when the debugger steps through the instructions.\n\n**Anti-Analysis/Debug Techniques**\n\n\n-----\n\nThe shellcode uses several anti-debugging techniques. The shellcode detects if hardware\nbreakpoints or software breakpoints have been set, each time it calls several key API\nfunctions, as shown in Figure 11.\n\nFigure 11: Software and hardware breakpoint checks (click image to enlarge)\n\n[During their malware analysis, analysts often use hardware or software breakpoints at the](https://www.crowdstrike.com/epp-101/malware-analysis/)\nbeginning of suspicious API calls — for example, by patching the first byte of\n```\nCreateProcessInternalW with 0xCC . By calling the NtGetContextThread function,\n\n```\ndebug registers ( DR0 through `DR7 ) can be used to detect hardware breakpoints, while`\n```\n0xCC, 0X3CD and 0xB0F opcodes are used to detect software breakpoints (if present) at\n\n```\nthe beginning of the API calls.\n\n**Process Hollowing Injection**\n\nProcess hollowing is a code injection technique used by malware in which the executable\ncode of a legitimate process in memory is replaced with malicious code. By executing within\nthe context of legitimate processes, the malware can bypass security solutions. The\nshellcode similarly uses process hollowing techniques in order to inject its code into the\nlegitimate process (here `RegAsm.exe or` `MSBuild.exe or` `RegSvcs.exe ) with a slight`\nvariation. Here, shellcode doesn’t unmap memory code of legitimate processes; instead it\nuses the `NtCreateSection API` [section object to inject its malicious code. The process is](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/section-objects-and-views)\nas follows:\n\n1) Calls `kernel32.CreateProcessInternalW to create the Windows legitimate process`\n“C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\RegAsm.exe” with\n```\nCREATE_SUSPENDED(0x00000004) flags. If it doesn’t find RegAsm.exe, it will try to find\nMSBuild.exe or RegSvcs.exe in the same directory path and loop until it finds one of\n\n```\nthem.\n\n\n-----\n\n2) Opens a file handle to the hard-coded file path C:\\Windows\\syswow64\\mstsc.exe using\n```\nZwOpenFile\n\n```\n3) Calls `ntdll.NtCreateSection on the file handle for` `mstsc.exe . The`\n```\nZwCreateSection function creates a section object that represents a section of memory\n\n```\nthat can be shared. This file handle is used to create a new section object with the\nDesiredAccess parameter.\n\n4) The section is then mapped in the targeted process ( RegAsm.exe ) using the function\n```\nntdll.NtMapViewOfSection with the BaseAddress parameter set to 0x400000 . This\n\n```\nmaps the section in the base address `0x400000, which is typically the address used to`\nmap the executable file image of the process.\n\n5) Calls `ntdll.NtWriteVirtualMemory in order to write the shellcode in the newly`\nallocated memory of the targeted process.\n\n6) Calls `ntdll.NtGetContextThread to obtain information about the main thread within`\nthe suspended subprocess.\n\n7) After the shellcode has been written to the memory of the targeted process, the execution\nneeds to be redirected to it. To achieve this, GuLoader makes use of the function\n```\nntdll.NtSetContextThread to change the context of the only thread running in the\n\n```\ntargeted process (still in a suspended state). This context change sets the EIP register to the\naddress that points to the beginning of the shellcode, which makes the execution start there.\n\n8) Calls `ntdll.NtResumeThread to resume the new thread in` `RegAsm.exe to execute the`\nmalicious shellcode.\n\n**Final Payload**\n\nAfter GuLoader has successfully injected into the `RegAsm.exe process, its shellcode will`\ndownload the final payload from the Google Drive link in memory in an encrypted form, as\nshown in Figure 12.\n\n\n-----\n\nFigure 12: Encrypted final payload downloaded in the memory (click image to enlarge)\n\nThe real encrypted payload is appended after the first 64 bytes of random data. The\nGuLoader shellcode uses a hardcoded XOR key with a length of 517 bytes for this sample\n(as shown in Figure 13) to decrypt the final payload.\n\n\n-----\n\nFigure 13: Embedded XOR key (null terminated) for decrypting final payload (click image to enlarge)\n\nThe following piece of code from the shellcode decrypts its encrypted payload back into its\noriginal one, as shown in Figure 14.\n\n\n-----\n\nFigure 14: Decryption routine and decrypted final payload (click image to enlarge)\n\n## How the CrowdStrike Falcon Platform Protects Against GuLoader\n\nThe CrowdStrike Falcon® platform has the ability to detect and prevent GuLoader by taking\nadvantage of the behavioral patterns indicated by the malware. By turning on suspicious\nprocess blocking, Falcon ensures that GuLoader is killed in the very early stages of\nexecution.\n\n\n-----\n\nFigure 15: GuLoader’s process hollowing detection by Falcon (click image to enlarge)\n\nIn addition, the CrowdStrike® machine learning (ML) algorithm provides additional coverage\nagainst this malware family, as illustrated in Figure 16.\n\nFigure 16: GuLoader process blocked by ML algorithm (click image to enlarge)\n\n## Conclusion\n\nGuLoader has been very active in 2020 and is frequently used by criminals to distribute their\nmalware like AgentTesla, FormBook and NanoCore. The use of process hollowing and\nhosting encrypted payloads on Google Drive is designed to bypass many security solutions\n— but it doesn’t bypass CrowdStrike Falcon.\n\n## Appendix: APIs Resolved by GuLoader\n\n\n-----\n\nLoadLibraryA\nTerminateProcess\nEnumWindows\nZwProtectVirtualMemory\nDbgBreakPoint\nDbgUIRemoteBreakin\nNtGetContextThread\nNtSetContextThread\nNtWriteVirtualMemory\nNtCreateSection\nNtMapViewOfSection\nNtOpenFile\nNtClose\nNtResumeThread\nCreateProcessInternalW\nGetLongPathNameW\nSleep\nCreateThread\nWaitForSingleObject\nTerminateThread\nAddVectoredExceptionHandler\nCreateFileW\nWriteFile\nCloseHandle\nGetFileSize\nReadFile\nShellExecuteW\nSHCreateDirectoryExW\nRegCreateKeyExA\nRegSetValueExA\n\n## Indicators of Compromise (IOCs)\n\n**File** **SHA256**\n\n\n**SPAM**\n**Email**\n\n**Email**\n**Attachment**\n\n**Guloader**\n**Payload**\n\n\n38e6cef6c556cb8ce5254876fd43caf59bbb8239a1ea679891a4d423aafb08dc\n\nc61f1d14582a38474f56426975cc4a2b2fa9ff172c915af9781c9d5682cb629e\n\n[bfa5dba46db1253587058b0392c04c8403846fa55d7dcf1044e94e6a654d4715](https://hybrid-analysis.com/sample/bfa5dba46db1253587058b0392c04c8403846fa55d7dcf1044e94e6a654d4715)\n\n\n-----\n\n**Additional Resources**\n\n_[Learn more about the CrowdStrike Falcon® platform by visiting the product webpage.](https://www.crowdstrike.com/endpoint-security-products/falcon-platform/)_\n_Learn more about CrowdStrike endpoint detection and response by visiting the Falcon_\n_[Insight™ webpage.](https://go.crowdstrike.com/try-falcon-prevent.html)_\n_[Test CrowdStrike next-gen AV for yourself. Start your free trial of Falcon Prevent™](https://go.crowdstrike.com/try-falcon-prevent.html)_\n_today._\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-25 - GuLoader- Peering Into a Shellcode-based Downloader.pdf"
    ],
    "report_names": [
        "2020-06-25 - GuLoader- Peering Into a Shellcode-based Downloader.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535532,
    "ts_updated_at": 1743041126,
    "ts_creation_date": 1653787312,
    "ts_modification_date": 1653787312,
    "files": {
        "pdf": "https://archive.orkl.eu/bc5394ce55a9028fd0f217ff38bf6698a10ba874.pdf",
        "text": "https://archive.orkl.eu/bc5394ce55a9028fd0f217ff38bf6698a10ba874.txt",
        "img": "https://archive.orkl.eu/bc5394ce55a9028fd0f217ff38bf6698a10ba874.jpg"
    }
}