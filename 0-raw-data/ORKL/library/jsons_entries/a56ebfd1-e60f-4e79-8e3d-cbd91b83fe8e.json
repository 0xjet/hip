{
    "id": "a56ebfd1-e60f-4e79-8e3d-cbd91b83fe8e",
    "created_at": "2023-01-12T15:05:26.749576Z",
    "updated_at": "2025-03-27T02:08:40.854725Z",
    "deleted_at": null,
    "sha1_hash": "9b46b5f82bdb813b89ecdf0fe54750b67fcf44ae",
    "title": "2018-07-11 - Tackling Gootkit's Traps",
    "authors": "",
    "file_creation_date": "2022-05-28T03:42:26Z",
    "file_modification_date": "2022-05-28T03:42:26Z",
    "file_size": 1546297,
    "plain_text": "# Tackling Gootkit's Traps\n\n**f5.com/labs/articles/threat-intelligence/tackling-gootkit-s-traps**\n\nbyline July 11, 2018\n\nGootkit is an advanced banking trojan first discovered in mid-2014. Known for using various techniques to\nevade detection, the malware also has its own unique twists: it’s partially written in JavaScript and it\nincorporates the node.js runtime environment.\n\nGootkit employs several checks in order to identify a virtual environment and halt its propagation sequence\nonce that happens. In this post, we’ll demonstrate a way to tackle these anti-research methods in order to\nhave the sample executing in a virtual environment.\n\n## First Glance\n\nRunning the sample in a virtual machine results in the creation of several threads, but no modifications to the\nsystem are made. Without interruptions, Gootkit’s process would continue to run forever.\n\nFigure 1: procmon view of the sample\n\nRunning the sample in a debugger allows us to interrupt the process and inspect its execution flow. Whenever\nthe debugger is paused, Gootkit’s process is sleeping.\n\nFigure 2: View of the stack of the sleeping thread\n\n\n-----\n\nAccording to the return address, the call comes from the malware (not from a system library) and the\nparameter is -1, meaning: sleep forever.\n\nHow can we make the malware go to a more interesting execution flow in the code?\n\n## Diving Deeper into the Assembly Code\n\nLooking at the assembly of the function that calls the sleep API, there are three possible execution paths: #1\nand #2 are paths that we could force the malware to take by patching the conditional jumps that lead to them;\n#3 is the path it takes before reaching the sleep API.\n\nFigure 3: The calling function of the sleep API, thread 1\n\nThere are 3 possible paths of execution. We’ll use a shortcut in order to decide quickly which one is the most\ninteresting one to follow. That shortcut involves checking cross-references(xrefs) from each function, which\nwill indicate where most of the activity would take place.\n\nExecution path #1, contains a call to sub_4047EC, which had no xrefs.\n\n\n-----\n\nExecution path #2, contains a call to sub_409450, which had just a few xrefs.\n\nExecution path #3 creates a thread that will execute sub_40C8C3, which had many xrefs.\n\nSo, execution path #3, the newly created thread, seems like the one to take because it has a massive\nfunction graph, indicating that all the activity will most likely happen there.\n\nAfter placing a breakpoint at the beginning of the thread function(0x40C8C3), we start stepping through. One\nof the subroutines gets stuck in an endless loop, which means Gootkit is sleeping again!\n\nRecap #1: There are two threads, one of which is sleeping forever, but it is not the interesting one. The\nsecond one is in a sleep loop, and our goal is to force it to take a different branch in order to execute the\ninteresting functionality.\n\n\n-----\n\nFigure 4: The calling function of the sleep API, thread #2\n\nThe only way to break the loop is to make the string comparison(StrStrIW) fail. The comparison parameters:\n\nHard-coded string “Xeon”\nData from\n_HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0\\ProcessorNameString_\n\nIf we changed this value in the registry, we could successfully overcome this hurdle. But, would that be the\nend? Would it run? Sadly, after making this change, Gootkit goes back to sleep in another endless loop, this\ntime in a different subroutine.\n\nRecap #2: Again, there are two threads, one that is sleeping forever (but not interesting); the other is running\nin a sleep loop.\n\nFigure 5: Gootkit’s two threads in Immunity Debugger’s thread view\n\n\n-----\n\nFigure 6: Another calling function of the sleep API, thread #2\n\nAfter inspecting the condition that leads us to the sleep API call, it becomes clear that this branch is taken\nwhen the “GetProcAddress” fails. But, why would this simple API fail?\n\nAt second glance, it is evident that the first parameter of the “GetProcAddress” API, the HModule, is always\nequal to null because of the XOR instruction highlighted in red. The conclusion is that this API is meant to fail!\nThis whole function is a trap, and our goal is to avoid entering it altogether.\n\n## Following the Traps\n\nWe’ll rename the function to “trap” and then check all the function references to see how many traps are\nthere.\n\n\n-----\n\nFigure 7: All function references to the trap function\n\nThere are 17 traps to overcome and they are all in the same function, so we assume this is the function\nmaking all the environment checks. We’ll have to check each condition that leads to a trap and make sure to\nchange the environment (or patch the binary) in a way that would bypass the trap.\n\nFigure 8 shows a code snippet from the sub_409AE2 function.\n\n\n-----\n\nFigure 8: The calling function for all the traps in pseudo C view\n\nNote that each “while” loop is performing string decryption on the sequences of bytes shown in the variables\nabove the loop. When following the execution in a debugger, the strings are decrypted, and some meaningful\nindicators of VM checks are visible. (See appendix for decryption function details.)\n\nIn this code snippet, three checks are evident:\n\nMAC address check\nChecking the presence of “dbghelp.dll” — debugger indicator\nChecking the presence of “sbiedll.dll” — sandboxie indicator\n\nBy following the traps and patching the system accordingly, the environment is prepared for Gootkit to run in.\n\nThe rest of the checks include:\n\nCompare user name to \"CurrentUser\"/\"Sandbox\"\nCompare computer name to \"SANDBOX\"/\"7SILVIA\"\n_HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\SystemBiosVersion\" compare with_\nAMI, VirtualBox, BOCHS, INTEL 640000, 55274-640-2673064-23950, and other serials\n\n\n-----\n\nAfter patching a virtual machine and running the sample, it s clear that it is no longer stuck in an endless loop\nand that the sample continues its propagation in the system.\n\nFigure 9: Gootkit installation process\n\n## The Road Not Taken\n\nPatching the virtual environment by changing the MAC address and several registry values is one way to get\nthe sample to run. It is the recommended way to go when running Gootkit samples in an automated analysis\nsystem. However, this post would not be complete without presenting the other solution: patching the binary\nitself.\n\nEvery time there’s a conditional jump to the trap function, one could change it to a simple jump opcode, thus\nskipping the trap function. This would direct the flow from the jump to the next code block while skipping the\ntrap function.\n\nHowever, this patch must be applied 17 times, and that’s a tedious task. Instead, since all the calls to the trap\nfunction come from one function, its preferable to patch and bypass the call to that function.\n\nFigure 10: The “JNZ” instruction opcode(0x75) is changed to the “JMP” instruction opcode(0xEB) in Immunity\nDebugger\n\n## Conclusion\n\nWhen analyzing malware, especially intricate, multi-threaded ones like Gootkit, it is important to choose the\ninteresting thread to follow and to keep in mind that even functions that look like they contain seemingly\n“ordinary” code may be used as a deception.\n\nMD5: 47f8d6d3e4410218c4c64701cb7d7d3d\n\n## Appendix\n\nThe decryption function is an XOR loop with a hard-coded key. The encrypted string and the key are hardcoded sequences of bytes.\n\nIn Python:\n\n\n-----\n\nAn example of the string decryption loop and its parameters:\n\nencrypted_string = \"\\x3A\\x03\\x05\\x15\\x55\\x0E\\x25\\x4F\\x08\\x1C\\x5D\\x62\"\n\nkey = \"\\x49\\x61\\x6C\\x70\\x31\\x62\"\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-07-11 - Tackling Gootkit's Traps.pdf"
    ],
    "report_names": [
        "2018-07-11 - Tackling Gootkit's Traps.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535926,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653709346,
    "ts_modification_date": 1653709346,
    "files": {
        "pdf": "https://archive.orkl.eu/9b46b5f82bdb813b89ecdf0fe54750b67fcf44ae.pdf",
        "text": "https://archive.orkl.eu/9b46b5f82bdb813b89ecdf0fe54750b67fcf44ae.txt",
        "img": "https://archive.orkl.eu/9b46b5f82bdb813b89ecdf0fe54750b67fcf44ae.jpg"
    }
}