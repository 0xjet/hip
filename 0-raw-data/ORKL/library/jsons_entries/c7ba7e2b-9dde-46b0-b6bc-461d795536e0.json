{
    "id": "c7ba7e2b-9dde-46b0-b6bc-461d795536e0",
    "created_at": "2023-01-12T14:59:37.310006Z",
    "updated_at": "2025-03-27T02:16:25.627539Z",
    "deleted_at": null,
    "sha1_hash": "b5c7c1bd51f382b7206c92e023acb30c23462635",
    "title": "2022-04-11 - Obfuscated obfuscation",
    "authors": "",
    "file_creation_date": "2022-05-28T15:12:38Z",
    "file_modification_date": "2022-05-28T15:12:38Z",
    "file_size": 1022176,
    "plain_text": "# Obfuscated obfuscation\n\n**blog.lexfo.fr/dexguard.html**\n\n## Introduction\n\n#### During a Red Team, we stumbled upon a device running Android. Next to the battery slot, a pin header providing access to a debug UART and an USB port were present. After improvising a custom USB cable by crimping bullet terminals since we didn't have access to a soldering iron, we gained access to the device through MTP:\n\n 8-pin connector A mouse had to be sacrificed\n\n USB Connector Improvised USB Cable\n\n Using MTP, we could retrieve a configuration file containing only ASCII characters, however they didn't make sense. Best guess we had was it could be some Base64 with a custom charset randomly selected.\n\n Since we supposed these configuration files would only be obfuscated, we wanted to reverse engineer the application that can read them. Based on the name of a service displayed on the device, we knew what to search for on Google Play to find an APK that would use, and thus decode, such configuration files. As a matter of fact, the application is a Mobile Device Management.\n\n Obviously, the APK was all obfuscated. We quickly found the Java interface used for the decoding of the configuration:\n\n\n-----\n\n```\npublic interface AbstractC3001 {\n  /* renamed from: ı */\n  String mo20891(String str) throws MissingDataForEncryptionException;\n}\n\n#### However, no implementation of this interface could be found in what we had. Obviously, the implementation must have been encrypted and dynamically loaded at runtime.\n\n## Decompiling the APK\n\n#### First, we need to decompile the APK. Jadx can work quite well to get some Java-esque output. Getting the smali for reference with Apktool is also a good idea.\n$ jadx --show-bad-code --deobf -d out/ target.apk \n$ apktool d target.apk\n\n One of the packages is heavily obfuscated in the application. In our case it is named\np014o . The use of Dexguard can be recognized with its Class Manager (CM) that\n\n resolves class and method names at runtime. The prototype for the CM is basically\nString $$c(arg1, arg2, arg3) . We can find it easily:\n$ grep -r 'private static String $$c(' out/sources/\nout/sources/p014o/C2958.java:  private static String $$c(int r7, short r8,\nshort r9) {\n\n Now we need to find \"strange\" resources. Two resources at the root of the application folder have non-printable names that end in '-'. They also start with a Java reference and are followed by a high-entropy blob of data.\n$ ls out/resources/*out/resources/  'out/resources/'$'\\342\\200\\251'' '$'\\342\\200\\251''-'\n$ strings -n 10 out/resources/*java/io/Serializable\njava/io/Serializable\n These resources are actually encrypted with custom versions of well-known cryptographic algorithms. One will be the Class Loader (CL), and the other one the Protected Classes. In order to decrypt the Protected Classes (PC), we first need to decrypt the Class Loader which will contain the key and some parameters for the Protected Classes decryption.\n\n In the CM (in our case: out/sources/p014o/C2958.java ), there is a huge static initialization. This is where the Protected Classes will be decrypted and then loaded.\n\n Last time we checked, the Dexguard mode of operation was:\n\n```\n\n-----\n\n#### load a resource as an InputStream; feed the result to a class inheriting from FilterInputStream to decrypt it; do some useless obfuscation to waste a few minutes of time from a reverser; feed the decrypted result to a ZipInputStream to get a DEX file; finally load the resulting DEX as a Resource using the loadDex method.\n\n So let's find what classes extend FilterInputStream using grep:\n```\n$ grep -r 'extends FilterInputStream' out/sources/p014o/\nout/sources/p014o/C1538.java:public class C1538 extends FilterInputStream {\nout/sources/p014o/C1489.java:public final class C1489 extends FilterInputStream {\nout/sources/p014o/C2081.java:public final class C2081 extends FilterInputStream {\nout/sources/p014o/C1207.java:public final class C1207 extends FilterInputStream {\nout/sources/p014o/C0991.java:public final class C0991 extends FilterInputStream {\nout/sources/p014o/C1742.java:public final class C1742 extends FilterInputStream {\nout/sources/p014o/C1209.java:public final class C1209 extends FilterInputStream {\nout/sources/p014o/C4315CoN.java:public final class C4315CoN extends\nFilterInputStream {\n\n The class in C1207 strongly resembles some fast AES implementation, as can be seen from its dependency C1210 with a static initializer computing AES lookup tables:\n\n```\n\n-----\n\n```\nstatic {\n  byte[] bArr;\n  int i;\n  byte b = 1;\n  byte b2 = 1;\n  do {\n    b = (byte) (((b & 128) != 0 ? 27 : 0) ^ ((b << 1) ^ b));\n    byte b3 = (byte) (b2 ^ (b2 << 1));\n    byte b4 = (byte) (b3 ^ (b3 << 2));\n    byte b5 = (byte) (b4 ^ (b4 << 4));\n    b2 = (byte) (b5 ^ ((b5 & 128) != 0 ? (byte) 9 : 0));\n    bArr = f1476;\n    i = b & 255;\n    int i2 = b2 & 255;\n    bArr[i] = (byte) (((((b2 ^ 99) ^ ((i2 << 1) | (i2 >> 7))) ^ ((i2 << 2) |\n(i2 >> 6))) ^ ((i2 << 3) | (i2 >> 5))) ^ ((i2 >> 4) | (i2 << 4)));\n  } while (i != 1);\n  bArr[0] = 99;\n  for (int i3 = 0; i3 < 256; i3++) {\n    int i4 = f1476[i3] & 255;\n    f1471[i4] = (byte) i3;\n    int i5 = i3 << 1;\n    if (i5 >= 256) {\n      i5 ^= 283;\n    }\n    int i6 = i5 << 1;\n    if (i6 >= 256) {\n      i6 ^= 283;\n    }\n    int i7 = i6 << 1;\n    if (i7 >= 256) {\n      i7 ^= 283;\n    }\n    int i8 = i7 ^ i3;\n    int i9 = ((i5 ^ (i6 ^ i7)) << 24) | (i8 << 16) | ((i8 ^ i6) << 8) | (i8 ^\ni5);\n    f1475[i4] = i9;\n    f1470[i4] = (i9 >>> 8) | (i9 << 24);\n    f1472[i4] = (i9 >>> 16) | (i9 << 16);\n    f1474[i4] = (i9 << 8) | (i9 >>> 24);\n  }\n  f1473[0] = 16777216;\n  int i10 = 1;\n  for (int i11 = 1; i11 < 10; i11++) {\n    i10 <<= 1;\n    if (i10 >= 256) {\n      i10 ^= 283;\n    }\n    f1473[i11] = i10 << 24;\n  }\n}\n\n```\n\n-----\n\n#### The class C1209 looks like a broken stream cipher loosely based on Mersenne twisters with 64-bits word size and two 4-words internal states, as can be deduced from its dependency class C1208 :\n```\npublic final class C1208 {\n  /* renamed from: ι */\n  static long[] m1400(int i, int i2) {\n    long[] jArr = new long[4];\n    jArr[0] = (((long) i2) & 4294967295L) | ((((long) i) & 4294967295L) <<\n32);\n    for (int i3 = 1; i3 < 4; i3++) {\n      long j = jArr[i3 - 1];\n      jArr[i3] = ((j ^ (j >> 30)) * 1812433253) + ((long) i3);\n    }\n    return jArr;\n  }\n}\n\n In the past, we also found TEA, XTEA and Blowfish.\n\n Because the encryption algorithm implemented in C1209 is severely broken, we could directly guess the missing bits of key that are present in the Class Loader and decrypt the Protected Classes. However, in some cases it is still necessary to decrypt the Class Loader to retrieve them. In order to cover all the cases we will do like if we couldn't directly decrypt the Protected Classes with the information we already have.\n\n## Decrypting the Class Loader\n\n#### In order to decrypt the Class Loader, we have to find a reference to one of the two decryption algorithms implemented in C1209 and C1207 . By looking into the CM (class C2958 ), we can find a call to the C1207 constructor:\n\n```\n\n-----\n\n```\nbyte[] bArr3 new byte[16];\nbArr3[0] = -29;\nbArr3[1] = -87;\nbArr3[2] = -61;\nbArr3[3] = 81;\nbArr3[4] = -30;\nbArr3[5] = -71;\nbArr3[6] = -19;\nbArr3[7] = -31;\nbArr3[8] = 123;\nbArr3[9] = -74;\nbArr3[10] = 119;\nbArr3[11] = -37;\nbArr3[12] = -12;\ntry {\n  bArr3[13] = -75;\n  bArr3[14] = 65;\n  bArr3[15] = -104;\n  byte[] bArr4 = (byte[]) bArr3.clone();\n  C1203.m1385(bArr4, f5121, f5116);\n  inputStream = new C1207(inputStream2, 8, bArr4, C1210.m1404(518096760));\n\n#### The first argument is an InputStream, we will take a look at it later. The second is actually the number of rounds, 8 instead of 10 for AES128; the third argument is the key, notice that it is modified by a call to C1203.m1385() . Finally, the last argument is the ShiftRow matrix that is obviously different than the one in normal AES. It is generated through a call to C1210.m1404() . The actual prototype would look like that:\npublic C1207(InputStream inputStream, int numRound, byte[] aesKey, byte[][]\nshiftRowMatrix);\n\n### AES Key\n\n#### The key can be easily identified in the code snippet above. Although, we need to take a look at C1203.m1385 to see how it is actually modified before it is used:\n/* renamed from: o.ĸӀ */\npublic class C1203 {\n  /* renamed from: ɩ */\n  public static void m1385(byte[] bArr, byte b, long j) {\n    for (int i = 0; i < bArr.length; i++) {\n      if (((1 << i) & j) != 0) {\n        bArr[i] = (byte) (bArr[i] ^ b);\n      }\n    }\n  }\n}\n\n As we can see, a XOR operation with f5121 is applied for bytes whose index matches a bit set to 1 in f5116, LSB first.\n\n```\n\n-----\n\n```\nprivate static long f5116 2459692291946227616L;\n/* ... */\nprivate static byte f5121 = -89;\n\n#### We can obtain the final key using a small C code:\nstatic uint8_t key[] = { -29, -87, -61, 81, -30, -71, -19, -31, 123, -74, 119,\n-37, -12, -75, 65, -104 };\nuint8_t *modif_key(uint8_t* ikey, uint8_t m, uint64_t mask, size_t len)\n{\n  int i;\n  for (i = 0; i < len; i++) {\n    if (((1 << i) & mask) != 0) {\n      ikey[i] ^= m;\n    }\n  }\n  return ikey;\n}\n\n The result is:\nBefore: E3A9C351E2B9EDE17BB677DBF4B54198\nAfter: E3A9C351E21EED46DC11D0DBF412413F\n\n### AES Shift Row matrix\n\n#### Next, we need to compute the actual shift row matrix used. Normally the Shift Row operation for AES decryption uses this matrix:\n\n Matrix - original\n\n Let's take a look at C1210.m1404 :\n/* renamed from: ɩ */\npublic static byte[][] m1404(int i) {\n  byte[][] bArr = new byte[4][];\n  for (int i2 = 0; i2 < 4; i2++) {\n    int i3 = i >>> (i2 << 3);\n    bArr[i2] = new byte[]{(byte) (i3 & 3), (byte) ((i3 >> 2) & 3), (byte)\n((i3 >> 4) & 3), (byte) ((i3 >> 6) & 3)};\n  }\n  return bArr;\n}\n\n It is called with 518096760, converting to base-4 ( 0132320120131320 ) and rearranging as done in the snippet above would give the following matrix:\n\n```\n\n-----\n\n#### Matrix - intermediate\n\n Now let's take a look at the C1207 constructor. Although useless, there is another transformation applied to this matrix. This is useless because if we want to make things quick, based on what we already have we can simply compile the C1207 class with\n```\njavac and call it with the arguments we already have computed. So, it doesn't add any\n\n value to the obfuscation. Anyway, here is the final transformation:\n/* renamed from: ι */\nprivate static byte[][] m1399(byte[][] bArr) {\n  byte[][] bArr2 = new byte[bArr.length][];\n  for (int i = 0; i < bArr.length; i++) {\n    bArr2[i] = new byte[bArr[i].length];\n    for (int i2 = 0; i2 < bArr[i].length; i2++) {\n      bArr2[i][bArr[i][i2]] = (byte) i2;\n    }\n  }\n  return bArr2;\n}\n\n For each row, the cell values and their indices are exchanged, giving the final Shift Row matrix used:\n\n Matrix - final\n\n### Input Stream\n\n#### We now have the algorithm to decrypt the Class Loader, which is a modified AES128 with 8-rounds and a custom Shift Row matrix, as well as the decryption key. We also know that the encrypted Class Loader is one of the two resource files with non-printable characters in their names.\n\n If we backtrack the InputStream argument, we obtain it after this call:\n\n```\n\n-----\n\n```\ni6 20;\n/* ... */\nint length4 = bArr.length;\nint i90 = -i6;\nint i91 = (length4 & i90) + (length4 | i90);\n/* ... */\nObject[] objArr22 = new Object[3];\nobjArr22[2] = Integer.valueOf(i91);\nobjArr22[1] = Integer.valueOf(i6);\nobjArr22[0] = bArr;\nshort s30 = (short) 135;\nInputStream inputStream2 = (InputStream) Class.forName($$c((byte) f5118[35], s30,\n(short) ((s30 ^ 376) | (s30 & 376)))).getDeclaredConstructor(byte[].class,\nInteger.TYPE, Integer.TYPE).newInstance(objArr22);\n\n#### Note that the formula (a & b) + (a | b) is equivalent to a + b . While we could decrypt the class name by reimplementing the $$c method, it seems quite obvious that the constructor is simply:\nByteArrayInputStream(byte[] buf, int offset, int length);\n\n The offset is 20 and the length is the whole buffer length minus 20. Since the resources we found started with java/io/Serializable which is 20 bytes long, it actually makes sense.\n\n We need to take a look at what operation is done to bArr before being used in the\nByteArrayInputStream constructor. We have this code snippet above in the code:\ni6 = 20;\ni7 = 8664;\nstr3 = str2;\ncls = null;\nwhile (true) {\n  int i89 = ((i6 | 210) << 1) - (i6 ^ 210);\n  try {\n    byte b19 = bArr[((i6 | 4167) << 1) - (i6 ^ 4167)];\n    bArr[i89] = (byte) ((b19 ^ 9) + ((b19 & 9) << 1));\n\n Note that the formulae ((a | b) << 1) - (a ^ b) and (a ^ b) + ((a & b) <<\n1) are equivalent to a + b . The code above can be reduced to:\nbArr[20 + 210] = bArr[20 + 4167] + 9;\n\n### Getting the Class Loader Dex\n\n#### The resource files were 8708 and 4188 bytes long respectively. Since AES works on 16- bytes blocks, the best candidate is thus the file whose length is 8708 since it is 243 *\n16 + 20 .\n\n```\n\n-----\n\n#### By replacing the 230th byte by the 4187th added with 9 (which gives 0x4 + 0x9 =\n```\n0x0d ), we can finally decrypt the CL using the key\n0xE3A9C351E21EED46DC11D0DBF412413F with a slightly modified version of the AES\n\n implementation to take into account the reduced round number and the custom Shift Row matrix. A diff based on the reference implementation of AES can be found in the annex.\n\n The decryption can be obtained using this C code, for example:\nint main(int argc, char **argv)\n{\n  int fd, outfd, i;\n  uint8_t buf[20], obuf[16];\n  uint32_t keyexp[4*9];\n  fd = open(argv[1], O_RDONLY);\n  read(fd, buf, 20);\n  outfd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\n  modif_key(key, -89, 2459692291946227616ULL, 16);\n  m1404(518096760);\n  m1399();\n  rijndaelKeySetupDec(keyexp, 8, key, 128);\n  while (read(fd, buf, 16) == 16) {\n    rijndaelDecrypt(keyexp, 8, buf, obuf);\n    write(outfd, obuf, 16);\n  }\n  close(outfd);\n}\n\n We can now obtain the JAR file in plaintext:\n$ gcc -o main main.c rijndael-alg-fst.c\n$ ./main encfile1 cl.jar\nKEY: E3A9C351E21EED46DC11D0DBF412413F\nShifRow Matrix:\n0, 3, 1, 2,\n2, 1, 3, 0,\n1, 0, 2, 3,\n3, 2, 0, 1,\n\n And finally get the Dex file:\n$ unzip cl.jar\nArchive: cl.jar\nwarning [cl.jar]: 22 extra bytes at beginning or within zip file\n (attempting to process anyway)\n inflating: classes.dex\n\n## Decrypting the Protected Classes\n\n```\n\n-----\n\n#### We can now feed this classes.dex to Jadx along with the one from the APK we are analyzing so that both are integrated:\n```\n$ mv classes.dex classes2.dex\n$ unzip target.apk classes.dex\nArchive: target.apk\n inflating: classes.dex       \n$ jadx --show-bad-code --deobf -d cl/ classes*.dex\nINFO - loading ...\nINFO - processing ...\nERROR - finished with errors, count: 26\n\n We now have the Class Loader decompiled with the renaming matching the other decompiled classes, thanks to Jadx. The classes have now all be renamed because of the deobfuscation flag given to Jadx. The Class Manager, formerly C2958 is now named C2274 . The second decryption class identified, C1209 is now named C1081 . The newly obtained Class Loader is named C2257 .\n\n### Identifying the Class Loader call to decrypt the Protected Classes\n\n#### If we go back to the Class Manager (now renamed C2274 ), there is one use of an InputStream object that we didn't investigate:\nclsArr7[0] = Class.forName($$c(b20, s31, (short) ((i94 & 415) | (i94 ^ 415))));\nclsArr7[1] = Short.TYPE;\nclsArr7[2] = Integer.TYPE;\nclsArr7[3] = Integer.TYPE;\ninputStream = (InputStream) cls6.getMethod($$c8, clsArr7).invoke(obj25,\nobjArr23);\n\n The argument objArr23 can be found some few lines above:\nObject[] objArr23 = new Object[4];\nobjArr23[3] = -1541368241;\nobjArr23[2] = -197155059;\nobjArr23[1] = (short) 8;\nobjArr23[0] = inputStream2;\n\n This means the method signature looks like this:\nInputStream method(InputStream, short, int, int);\n\n If we take a look at the Class Loader we just decrypted (named C2257 in our case), only one method has this specific signature. Looking for InputStream gives us this code snippet:\n\n```\n\n-----\n\n```\n/ renamed from: ǃ /\npublic InputStream mo19845(InputStream inputStream, short s, int i, int i2)\nthrows IOException {\n  try {\n    try {\n      C1081 r7 = new C1081(inputStream, this.f3561, i, s, this.f3560, i2);\n      try {\n        int i3 = f3551;\n        int i4 = (i3 ^ 61) + ((i3 & 61) << 1);\n        try {\n          f3548 = i4 % 128;\n          int i5 = i4 % 2;\n          return r7;\n        } catch (Exception e) {\n          throw e;\n        }\n      } catch (ClassCastException e2) {\n        throw e2;\n      }\n    } catch (Exception e3) {\n      throw e3;\n    }\n  } catch (IndexOutOfBoundsException e4) {\n    throw e4;\n  }\n}\n\n#### We can see the call to the second decryption algorithm, with some interesting arguments:\nC1081(inputStream, this.f3561, i, s, this.f3560, i2);\n\n### Decryption key\n\n#### The value we were missing to call C1081 (formerly C1209 that we identified as a cipher loosely based on Mersenne twisters) can now be recovered from the Class Loader C2257 :\nthis.f3560 = -1658185820;\nthis.f3561 = -1460155994;\n\n As is usual for DexGuard, we had to decrypt the Class Loader in order to find the key to decrypt the Protected Classes. However, note that in this instance, because the second encryption algorithm used is broken, we could have directly guessed those two missing 32-bits values.\n\n The call to the decryption class is then:\nC1081(inputStream, -1460155994, -197155059, 8, -1658185820, -1541368241);\n\n### Stream cipher\n\n```\n\n-----\n\n#### The C1081 constructor uses the 4th argument (8) as a block size. Although, looking at the code it could be used as a stream cipher directly.\n\n The int arguments are transformed through another class during initialization:\n```\nthis.f1021 = C1080.m1121(i ^ i4, i5 ^ i4);\nthis.f1022 = C1080.m1121(i2 ^ i4, i3 ^ i4);\n\n This is the seeding method identified at the beginning of this analysis that actually helped understand on what was based this algorithm. The implementation of this method is as follows:\npublic final class C1080 {\n  /* renamed from: ι */\n  static long[] m1121(int i, int i2) {\n    long[] jArr = new long[4];\n    jArr[0] = (((long) i2) & 4294967295L) | ((((long) i) & 4294967295L) <<\n32);\n    for (int i3 = 1; i3 < 4; i3++) {\n      long j = jArr[i3 - 1];\n      jArr[i3] = ((j ^ (j >> 30)) * 1812433253) + ((long) i3);\n    }\n    return jArr;\n  }\n}\n\n You might notice the constant 1812433253 which is the value for f used in the 32- bits version of the Mersenne-Twister MT19937. This class actually implements the initialization part of a Mersenne twister with w = 64 and n = 4 . Since it is called twice, we have two internal states. One is initialized with 0xcd75fe9a4209647 and the other one is initialized with 0x501f3142390a81eb . Without decrypting the Class Loader, we would only have the lower part of the first initialization and the upper part of the second.\n\n Now let's take a look at the decryption implementation:\nlong[] jArr = this.f1021;\nlong[] jArr2 = this.f1022;\nshort s = this.f1017;\nint i = (s + 2) % 4;\nint i2 = (s + 3) % 4;\njArr2[i2] = ((jArr[i2] * 2147483085) + jArr2[i]) / 2147483647L;\njArr[i2] = ((jArr[s % 4] * 2147483085) + jArr2[i]) % 2147483647L;\nfor (int i3 = 0; i3 < this.f1019; i3++) {\n  byte[] bArr = this.f1018;\n  bArr[i3] = (byte) ((int) (((long) bArr[i3]) ^ ((this.f1021[this.f1017] >> (i3\n<< 3)) & 255)));\n}\nthis.f1017 = (short) ((this.f1017 + 1) % 4);\n\n```\n\n-----\n\n#### The two MT-like internal states are first updated with one another, then the current 8- byte block from the ciphertext is XOR'd with the current word from the first internal state.\n\n The internal state update puts the integer part of a division by 2^31-1 in the second internal state and the remainder in the first one. Because of that, after the 4th update, we will have a maximum of 31 bits per word in the first internal state and 33 in the second.\n\n Because the operations are done on signed integer, we have to take into account that the remaining upper bits will be either all 0s or all 1s. This means that blocks of ~32 bits are either the same as the cleartext or have all their bits reversed in the resulting ciphertext. This is particularly inefficient.\n\n Moreover, because we know that the plaintext will start with the string java/, we can directly recover the missing upper part of the seed for the first internal state. The remaining missing 32-bits can then be easily bruteforced or computed by guessing the rest of the starting string in the plaintext (based on a dictionary).\n\n### Input Stream\n\n#### As for the Class Loader, a byte in the ciphertext is actually incorrect. The exact same operation is applied with the Protected Class ciphertext, that is, replacing the 230th byte by the 4187th added with 9. Note that it is always the second-to-last byte of the smaller resource that is taken as a reference to modify a byte close to the beginning of the resources.\n\n Note that if we look at the control flow, we should have noticed that the member f3601 from the Class Manager will actually hold the Class Loader. There are checks such as:\n```\nif (!(f3601 == null)) {\n\n This is to determine if we are decrypting the Class Loader (when not null) or the Protected Classes.\n\n### Getting the Protected Classes Dex\n\n#### We will need to do the same byte modification before \"decrypting\". By replacing the 230th byte by the 4187th added with 9 (which gives 0x1 + 0x9 = 0x0a ), we can finally decrypt the Protected classes using the \"double key\" 0xcd75fe9a4209647\n0x501f3142390a81eb .\n\n Since the output of Jadx can be directly compiled, we can use the original implementation in Java. We can also quickly reimplement it in C :\n\n```\n\n-----\n\n```\nint64_t twister1[4];\nint64_t twister2[4];\nvoid init(int64_t seed, int64_t *state)\n{\n  int i;\n  state[0] = seed;\n  for (i = 1; i < 4; i++) {\n    state[i] = (0x6c078965 * (state[i - 1] ^ (state[i - 1] >> 30)) + i);\n  }\n}\nint main(int argc, char **argv)\n{\n  int idx = 0;\n  int i, fd, outfd;\n  uint8_t buf[20];\n  fd = open(argv[1], O_RDONLY);\n  read(fd, buf, 20);\n  outfd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\n  init(0x0cd75fe9a4209647, twister1);\n  init(0x501f3142390a81eb, twister2);\n  while (read(fd, buf, 8) == 8) {\n    twister2[(idx + 3) % 4] = ((twister1[(idx + 3) % 4] * 0x7FFFFDCD) +\ntwister2[(idx + 2) % 4]) / 0x7FFFFFFF;\n    twister1[(idx + 3) % 4] = ((twister1[(idx + 0) % 4] * 0x7FFFFDCD) +\ntwister2[(idx + 2) % 4]) % 0x7FFFFFFF;\n    for (i = 0; i < 8; i++) {\n      buf[i] ^= (twister1[idx] >> (8 * i)) & 0xFF;\n    }\n    idx++;\n    idx %= 4;\n    write(outfd, buf, 8);\n  }\n  close(outfd);\n  close(fd);\n}\n\n#### Then we can obtain the Dex file:\n$ unzip pc.jar\nArchive: pc.jar\nwarning [pc.jar]: 22 extra bytes at beginning or within zip file\n (attempting to process anyway)\n inflating: classes.dex\n\n## Decompiling the whole project\n\n#### We can now feed this new classes.dex to Jadx along with the one from the APK we are analyzing so that both are integrated:\n\n```\n\n-----\n\n```\n$ mv cl/classes.dex classes3.dex\n$ jadx --show-bad-code --deobf -d project/ classes*.dex\nINFO - loading ...\nINFO - processing ...\nERROR - finished with errors, count: 26\n\n#### Note that this time the class name didn't change, since we only added two additional classes with no direct dependency over the rest of the decompilation. We can find the additional classes using diff:\n$ diff -rq project/sources/p010o/ cl/sources/p010o/ | grep Only\nOnly in project/sources/p010o/: C3157.java\nOnly in project/sources/p010o/: C3158.java\n\n The first class implements an AES encryption with a hardcoded key to communicate with the MDM server, and the second one is used to deobfuscate the configuration files. We indeed found what looks like a base64 decoding using an obfuscated custom charset:\nint indexOf = m6296(new char[]{56674, /*[...]*/\n40470}).intern().indexOf(substring2.charAt(i));\nif ((indexOf < m6296(new char[]{29383, 11261, 45856, 8033, 10541, 22108, 25214,\n30659, 58107, 55254, 14618, 58864, 14018, 44529, 7991, 15470, 19635, 39717,\n39670, 16382, 48010, 15556, 55341, 57354, 38037, 11242, 4227, 54049, 48270,\n19667, 812, 6934, 28332, 14278, 47363, 20756, 57729, 41508, 31548, 11732, 20431,\n31561, 33119, 61383, 24025, 58306, 18241, 30904, 52967, 36982, 32032, 40856,\n34637, 20511, 4255, 54644, 53525, 56183, 24255, 22493, 27537, 12587, 31638,\n39543, 20593, 21294}).intern().length() ? 'Z' : 'X') != 'X') {\n  int i4 = f5309 + 111;\n  f5312 = i4 % 128;\n  char[] cArr = {29383, 11261, 45856, 8033, 10541, 22108, 25214, 30659, 58107,\n55254, 14618, 58864, 14018, 44529, 7991, 15470, 19635, 39717, 39670, 16382,\n48010, 15556, 55341, 57354, 38037, 11242, 4227, 54049, 48270, 19667, 812, 6934,\n28332, 14278, 47363, 20756, 57729, 41508, 31548, 11732, 20431, 31561, 33119,\n61383, 24025, 58306, 18241, 30904, 52967, 36982, 32032, 40856, 34637, 20511,\n4255, 54644, 53525, 56183, 24255, 22493, 27537, 12587, 31638, 39543, 20593,\n21294};\n\n### String obfuscation\n\n#### Obviously, DexGuard also provides some level of string obfuscation. The class responsible for the deobfuscation is C1107 (formerly C1236 in the original decompilation output):\n\n```\n\n-----\n\n```\npublic final class C1107 {\n  /* renamed from: ɩ */\n  public static void m1192(char[] cArr, char c, char c2, char c3, char c4) {\n    char c5 = 58224;\n    for (int i = 0; i < 16; i++) {\n      cArr[1] = (char) (cArr[1] - (((cArr[0] + c5) ^ ((cArr[0] << 4) + c3))\n^ ((cArr[0] >>> 5) + c4)));\n      cArr[0] = (char) (cArr[0] - (((cArr[1] >>> 5) + c2) ^ ((cArr[1] + c5)\n^ ((cArr[1] << 4) + c))));\n      c5 = (char) (c5 - 40503);\n    }\n  }\n}\n\n#### Four wide char are necessary, they change in each class that uses this obfuscation. In our class the values are:\nstatic void m6297() {\n  f5307 = 34125;\n  f5310 = 13075;\n  f5311 = 49843;\n  f5306 = 58803;\n}\n\n The method is invoked with the constant in this order:\nC1107.m1192(cArr3, f5306, f5311, f5307, f5310);\n\n The first element gives the string size, since there is some garbage at the end. The deobfuscation can be called directly in java, or reimplemented in another language to decode all obfuscated strings. As a matter of fact, in its latest version, JEB will directly give the decoded string, saving us some precious time.\n\n Originally, we used the following code to deobfuscate the strings:\n\n```\n\n-----\n\n```\nunsigned short cArr[2];\nunsigned char out[256];\nint i, str_idx, str_sz;\nunsigned short c = 58803, c2 = 49843, c3 = 34125, c4 = 13075;\nfor(i=0;i<sizeof str;i+=2) {\n  unsigned short c5 = 58224;\n  cArr[0] = str[i];\n  cArr[1] = str[i+1];\n  for (int i = 0; i < 16; i++) {\n    cArr[1] = (unsigned short) (cArr[1] - (((cArr[0] + c5) ^ ((cArr[0] << 4)\n+ c3)) ^ ((cArr[0] >> 5) + c4)));\n    cArr[0] = (unsigned short) (cArr[0] - (((cArr[1] >> 5) + c2) ^ ((cArr[1]\n+ c5) ^ ((cArr[1] << 4) + c))));\n    c5 = (unsigned short) (c5 - 40503);\n  }\n  if (i == 0) {\n    str_sz = cArr[0];\n    str_idx = 0;\n    out[str_idx++] = (unsigned char) cArr[1];\n  } else if (str_idx < str_sz) {\n    out[str_idx++] = (unsigned char) cArr[0];\n    if (str_idx < str_sz) {\n      out[str_idx++] = (unsigned char) cArr[1];\n    } else {\n      out[str_idx++] = 0;\n    }\n  } else if (str_idx == str_sz) {\n    out[str_idx++] = 0;\n  }\n}\nprintf(\"%s\\n\", out);\n\n#### Which gives the following Java code for the decoding of our configuration files:\nint indexOf = \"[REDACTED]\".indexOf(substring2.charAt(i));;\nif(indexOf <\n\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".length()) {\nsb.append(((char)\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\n}\n\n As we originally guessed, it was indeed a Base64 encoding with a custom charset.\n\n### Deobfuscating the configuration file\n\n#### There is some additional obfuscation after that. The buffer is reversed and each byte is added with a value incremented at each index and reset every 5 characters.\n\n In the end, we obtain some useful credentials to play a bit more with the device:\n<user username=\"admin\" password=\"[REDACTED]\" group=\"ADMIN\" />\n\n```\n\n-----\n\n#### With these credentials, it is possible to reach the Android configuration and activate ADB, as well as the BlueTooth tethering in order to bounce on an internal network.\n\n### Bonus\n\n#### Once ADB was activated, we could dump a lot of files from the device, such as all the applications installed. From there, finding a command injection run as root is just a matter of time. This is useful to dump the WiFi credentials in order to not depend on the device to bounce on the internal network.\n\n## Conclusion\n\n#### The aim of this blog post was to present a method for reverse engineering Android application protected by DexGuard using opensource tools, in the context of a real-world example. Using JEB can however speed up the process of deobfuscation, but as far as we know, the most \"technical\" parts must still be made separately to obtain the decrypted DEX files.\n\n While the device in itself seemed innocuous, it ended up being a great way to gain access to a sensitive network. Stacking layers upon layers of obfuscation doesn't help against a motivated attacker.\n\n## Annex\n\n Diff between AES reference implementation and DexGuard implementation\n\n\n-----\n\n```\ndiff ru aes/rijndael alg fst.c code/rijndael alg fst.c\n--- aes/rijndael-alg-fst.c 2000-12-06 22:48:16.000000000 +0100\n+++ code/rijndael-alg-fst.c 2022-04-05 15:23:49.400531669 +0200\n@@ -725,7 +725,7 @@\n *\n * @return the number of rounds for the given cipher key size.\n */\n-int rijndaelKeySetupEnc(u32 rk[/*4*(Nr + 1)*/], const u8 cipherKey[], int\nkeyBits) {\n+int rijndaelKeySetupEnc(u32 rk[/*4*(Nr + 1)*/], int Nr, const u8 cipherKey[],\nint keyBits) {\n    int i = 0;\n  u32 temp;\n@@ -745,8 +745,8 @@\n      rk[5] = rk[1] ^ rk[4];\n      rk[6] = rk[2] ^ rk[5];\n      rk[7] = rk[3] ^ rk[6];\n-      if (++i == 10) {\n-        return 10;\n+      if (++i == Nr) {\n+        return Nr;\n      }\n      rk += 4;\n    }\n@@ -765,8 +765,8 @@\n      rk[ 7] = rk[ 1] ^ rk[ 6];\n      rk[ 8] = rk[ 2] ^ rk[ 7];\n      rk[ 9] = rk[ 3] ^ rk[ 8];\n-      if (++i == 8) {\n-        return 12;\n+      if (++i == (3 * Nr) >> 2) {\n+        return Nr;\n      }\n      rk[10] = rk[ 4] ^ rk[ 9];\n      rk[11] = rk[ 5] ^ rk[10];\n@@ -787,8 +787,8 @@\n      rk[ 9] = rk[ 1] ^ rk[ 8];\n      rk[10] = rk[ 2] ^ rk[ 9];\n      rk[11] = rk[ 3] ^ rk[10];\n-      if (++i == 7) {\n-        return 14;\n+      if (++i == Nr >> 1) {\n+        return Nr;\n      }\n      temp = rk[11];\n      rk[12] = rk[ 4] ^\n@@ -811,12 +811,12 @@\n *\n * @return the number of rounds for the given cipher key size.\n */\n-int rijndaelKeySetupDec(u32 rk[/*4*(Nr + 1)*/], const u8 cipherKey[], int\nkeyBits) {\n-  int Nr, i, j;\n+int rijndaelKeySetupDec(u32 rk[/*4*(Nr + 1)*/], int Nr, const u8 cipherKey[],\n\n```\n\n-----\n\n```\nint keyBits) {\n+  int i, j;\n  u32 temp;\n  /* expand the cipher key: */\n-  Nr = rijndaelKeySetupEnc(rk, cipherKey, keyBits);\n+  rijndaelKeySetupEnc(rk, Nr, cipherKey, keyBits);\n  /* invert the order of the round keys: */\n  for (i = 0, j = 4*Nr; i < j; i += 4, j -= 4) {\n    temp = rk[i  ]; rk[i  ] = rk[j  ]; rk[j  ] = temp;\n@@ -1125,27 +1125,27 @@\n   for (;;) {\n     t0 =\n       Td0[(s0 >> 24)    ] ^\n-      Td1[(s3 >> 16) & 0xff] ^\n-      Td2[(s2 >> 8) & 0xff] ^\n-      Td3[(s1   ) & 0xff] ^\n+      Td1[(s2 >> 16) & 0xff] ^\n+      Td2[(s1 >> 8) & 0xff] ^\n+      Td3[(s3   ) & 0xff] ^\n       rk[4];\n     t1 =\n-      Td0[(s1 >> 24)    ] ^\n-      Td1[(s0 >> 16) & 0xff] ^\n-      Td2[(s3 >> 8) & 0xff] ^\n+      Td0[(s3 >> 24)    ] ^\n+      Td1[(s1 >> 16) & 0xff] ^\n+      Td2[(s0 >> 8) & 0xff] ^\n       Td3[(s2   ) & 0xff] ^\n       rk[5];\n     t2 =\n-      Td0[(s2 >> 24)    ] ^\n-      Td1[(s1 >> 16) & 0xff] ^\n-      Td2[(s0 >> 8) & 0xff] ^\n-      Td3[(s3   ) & 0xff] ^\n+      Td0[(s1 >> 24)    ] ^\n+      Td1[(s3 >> 16) & 0xff] ^\n+      Td2[(s2 >> 8) & 0xff] ^\n+      Td3[(s0   ) & 0xff] ^\n       rk[6];\n     t3 =\n-      Td0[(s3 >> 24)    ] ^\n-      Td1[(s2 >> 16) & 0xff] ^\n-      Td2[(s1 >> 8) & 0xff] ^\n-      Td3[(s0   ) & 0xff] ^\n+      Td0[(s2 >> 24)    ] ^\n+      Td1[(s0 >> 16) & 0xff] ^\n+      Td2[(s3 >> 8) & 0xff] ^\n+      Td3[(s1   ) & 0xff] ^\n       rk[7];\n     rk += 8;\n@@ -1155,27 +1155,27 @@\n     s0 =\n\n```\n\n-----\n\n```\n       Td0[(t0 >> 24)    ] \n-      Td1[(t3 >> 16) & 0xff] ^\n-      Td2[(t2 >> 8) & 0xff] ^\n-      Td3[(t1   ) & 0xff] ^\n+      Td1[(t2 >> 16) & 0xff] ^\n+      Td2[(t1 >> 8) & 0xff] ^\n+      Td3[(t3   ) & 0xff] ^\n       rk[0];\n     s1 =\n-      Td0[(t1 >> 24)    ] ^\n-      Td1[(t0 >> 16) & 0xff] ^\n-      Td2[(t3 >> 8) & 0xff] ^\n+      Td0[(t3 >> 24)    ] ^\n+      Td1[(t1 >> 16) & 0xff] ^\n+      Td2[(t0 >> 8) & 0xff] ^\n       Td3[(t2   ) & 0xff] ^\n       rk[1];\n     s2 =\n-      Td0[(t2 >> 24)    ] ^\n-      Td1[(t1 >> 16) & 0xff] ^\n-      Td2[(t0 >> 8) & 0xff] ^\n-      Td3[(t3   ) & 0xff] ^\n+      Td0[(t1 >> 24)    ] ^\n+      Td1[(t3 >> 16) & 0xff] ^\n+      Td2[(t2 >> 8) & 0xff] ^\n+      Td3[(t0   ) & 0xff] ^\n       rk[2];\n     s3 =\n-      Td0[(t3 >> 24)    ] ^\n-      Td1[(t2 >> 16) & 0xff] ^\n-      Td2[(t1 >> 8) & 0xff] ^\n-      Td3[(t0   ) & 0xff] ^\n+      Td0[(t2 >> 24)    ] ^\n+      Td1[(t0 >> 16) & 0xff] ^\n+      Td2[(t3 >> 8) & 0xff] ^\n+      Td3[(t1   ) & 0xff] ^\n       rk[3];\n   }\n #endif /* ?FULL_UNROLL */\n@@ -1185,30 +1185,30 @@\n   */\n    s0 =\n      (Td4[(t0 >> 24)    ] & 0xff000000) ^\n-      (Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n-      (Td4[(t2 >> 8) & 0xff] & 0x0000ff00) ^\n-      (Td4[(t1   ) & 0xff] & 0x000000ff) ^\n+      (Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n+      (Td4[(t1 >> 8) & 0xff] & 0x0000ff00) ^\n+      (Td4[(t3   ) & 0xff] & 0x000000ff) ^\n      rk[0];\n  PUTU32(pt  , s0);\n    s1 =\n-      (Td4[(t1 >> 24)    ] & 0xff000000) ^\n-      (Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n-      (Td4[(t3 >> 8) & 0xff] & 0x0000ff00) ^\n\n```\n\n-----\n\n```\n+      (Td4[(t3 >> 24)    ] & 0xff000000) \n+      (Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n+      (Td4[(t0 >> 8) & 0xff] & 0x0000ff00) ^\n      (Td4[(t2   ) & 0xff] & 0x000000ff) ^\n      rk[1];\n  PUTU32(pt + 4, s1);\n    s2 =\n-      (Td4[(t2 >> 24)    ] & 0xff000000) ^\n-      (Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\n-      (Td4[(t0 >> 8) & 0xff] & 0x0000ff00) ^\n-      (Td4[(t3   ) & 0xff] & 0x000000ff) ^\n+      (Td4[(t1 >> 24)    ] & 0xff000000) ^\n+      (Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\n+      (Td4[(t2 >> 8) & 0xff] & 0x0000ff00) ^\n+      (Td4[(t0   ) & 0xff] & 0x000000ff) ^\n      rk[2];\n  PUTU32(pt + 8, s2);\n    s3 =\n-      (Td4[(t3 >> 24)    ] & 0xff000000) ^\n-      (Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\n-      (Td4[(t1 >> 8) & 0xff] & 0x0000ff00) ^\n-      (Td4[(t0   ) & 0xff] & 0x000000ff) ^\n+      (Td4[(t2 >> 24)    ] & 0xff000000) ^\n+      (Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\n+      (Td4[(t3 >> 8) & 0xff] & 0x0000ff00) ^\n+      (Td4[(t1   ) & 0xff] & 0x000000ff) ^\n      rk[3];\n  PUTU32(pt + 12, s3);\n }\ndiff -ru aes/rijndael-alg-fst.h code/rijndael-alg-fst.h\n--- aes/rijndael-alg-fst.h 2000-12-06 18:50:46.000000000 +0100\n+++ code/rijndael-alg-fst.h 2022-04-05 15:23:49.408531739 +0200\n@@ -34,8 +34,8 @@\n typedef unsigned short u16;\n typedef unsigned int  u32;\n-int rijndaelKeySetupEnc(u32 rk[/*4*(Nr + 1)*/], const u8 cipherKey[], int\nkeyBits);\n-int rijndaelKeySetupDec(u32 rk[/*4*(Nr + 1)*/], const u8 cipherKey[], int\nkeyBits);\n+int rijndaelKeySetupEnc(u32 rk[/*4*(Nr + 1)*/], int Nr, const u8 cipherKey[],\nint keyBits);\n+int rijndaelKeySetupDec(u32 rk[/*4*(Nr + 1)*/], int Nr, const u8 cipherKey[],\nint keyBits);\n void rijndaelEncrypt(const u32 rk[/*4*(Nr + 1)*/], int Nr, const u8 pt[16], u8\nct[16]);\n void rijndaelDecrypt(const u32 rk[/*4*(Nr + 1)*/], int Nr, const u8 ct[16], u8\npt[16]);\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-11 - Obfuscated obfuscation.pdf"
    ],
    "report_names": [
        "2022-04-11 - Obfuscated obfuscation.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535577,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653750758,
    "ts_modification_date": 1653750758,
    "files": {
        "pdf": "https://archive.orkl.eu/b5c7c1bd51f382b7206c92e023acb30c23462635.pdf",
        "text": "https://archive.orkl.eu/b5c7c1bd51f382b7206c92e023acb30c23462635.txt",
        "img": "https://archive.orkl.eu/b5c7c1bd51f382b7206c92e023acb30c23462635.jpg"
    }
}