{
    "id": "56d16147-b482-469c-ab21-3cf209c29ab8",
    "created_at": "2022-10-25T16:48:25.045805Z",
    "updated_at": "2025-03-27T02:13:29.224656Z",
    "deleted_at": null,
    "sha1_hash": "6370087a176d2e536888fde5dfd0478d2675ead6",
    "title": "",
    "authors": "",
    "file_creation_date": "2020-09-11T09:25:35Z",
    "file_modification_date": "2020-09-11T09:25:36Z",
    "file_size": 5357340,
    "plain_text": "##### Updated September 11 2020\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n### TABLE OF CONTENTS\n\n**Introduction................................................................................................................................................................................. 3**\n\n**Getting up to speed..................................................................................................................................................................... 3**\n\nListeners............................................................................................................................................................................ 3\n\nWeb management.............................................................................................................................................................. 4\n\nReporting........................................................................................................................................................................... 5\n\n**Attack analysis............................................................................................................................................................................ 5**\n\nTarget Module: Raw Shellcode generator.......................................................................................................................... 5\n\nExecution........................................................................................................................................................................... 5\n\nDetection........................................................................................................................................................................... 7\n\nTarget module: Staged/stageless executable generator.................................................................................................... 8\n\nC2 Communication.......................................................................................................................................................... 10\n\nTarget Module: HTML application attack generator......................................................................................................... 13\n\nTarget Module: Scripted web delivery.............................................................................................................................. 16\n\nTarget Module: Signed Java Applet Attack...................................................................................................................... 17\n\nTarget Module: Smart Java Applet Attack........................................................................................................................ 18\n\nTarget module: System profiler........................................................................................................................................ 24\n\n**Conclusion................................................................................................................................................................................. 26**\n\n**Appendix A: Coverage.............................................................................................................................................................. 27**\n\nStaged/Stageless Executables........................................................................................................................................ 27\n\nScripted Web Delivery PowerShell................................................................................................................................... 27\n\nBeacon Binary Payloads................................................................................................................................................... 27\n\nBeacon PowerShell payloads........................................................................................................................................... 27\n\nHTML Application (HTA) Attacks...................................................................................................................................... 27\n\nCobalt Strike signed applet attack................................................................................................................................... 28\n\nCobalt Strike smart applet attack..................................................................................................................................... 28\n\nCobalt Strike system profiler attack................................................................................................................................. 28\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n\n### INTRODUCTION\n\nCobalt Strike is ubiquitous in the cyber security arena. It’s\na prolific toolkit used at many levels of intrusion to solve\nadversaries' problems like post-intrusion exploitation,\nbeaconing for command and control (C2s), stealth and\nreconnaissance.\n\nCobalt Strike is a modularized attack framework: Each\nmodule fulfills a specific function and stands alone. It’s hard\nto detect, because its components might be customized\nderivatives from another module, new, or completely\nabsent. Malicious actors find Cobalt Strike’s obfuscation\ntechniques and robust tools for C2, stealth and data\nexfiltration particularly attractive.\n\nCisco Talos recently updated its SNORT® and ClamAV®\nsignatures to detect Cobalt Strike, version 4.0, a common\nplatform utilized as one part of attack processes. This\npaper outlines the challenges we were confronted with\nwhen analyzing Cobalt Strike, and the ways we crafted our\ndetection. We will address all the modules we’ve updated\ncoverage for, how we analyzed and thought about detection\nand the signature that resulted.\n\n### GETTING UP TO SPEED\n\nCobalt Strike is a paid penetration-testing tool that anyone\ncan use. Malicious actors have used it for years to deploy\n“Listeners” on victim machines. In this paper, we’ll dive into\nsome of the core components of Cobalt Strike and then\nbreak down our analysis of these components and how we\ncan protect against them. We will also look at Cobalt Strike\nfrom the adversary’s perspective.\n\n_Figure 1: Cobalt Strike Listener console_\n\n\n**LISTENERS**\n\nListeners are at the core of Cobalt Strike. They allow\nadversaries to configure the C2 method used in an attack.\nEvery attack or payload generated in Cobalt Strike requires\nthe targeted user to select a Listener to embed within\nit. This will determine how an infected host will reach\nout to the C2 server to retrieve additional payloads and\ninstructions.\n\nWhen creating a listener, the user can configure the payload\ntype, name, C2 server and port, and other various options\nsuch as named pipes or proxy servers (Figure 1). Users can\nchoose from:\n\n##### • Beacon DNS\n\n • Beacon HTTP\n\n • Beacon HTTPS\n\n • Beacon SMB\n\n • Beacon TCP\n\n • External C2\n\n • Foreign HTTP\n\n • Foriegn HTTPS\n\nPotentially the most powerful aspect of Cobalt Strike is\nthe array of malleable C2 profiles, which allows users to\nconfigure how attacks are created, obfuscate and manage\nthe flow of execution at a very low level.\n\nThere are several ways to visualize how an adversary\ninteracts with infected Cobalt Strike hosts, such as a\nsession table, pivot graph, or a target table. In Figure 2,\nyou can see the session table, along with some options\navailable when selecting a host.\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n_Figure 2: Cobalt Strike session table_\n\nHowever, this does not give insight into how the hosts are\ninterconnected, nor the C2 path taken when contacting the\nCobalt Strike C2. For that, we can swap to the Pivot Graph\n(Figure 3).\n\nIn Figure 3, the `WIN-498IQCJRIUQ` host is connected through\n“DESKTOP-R8VN37V” and all C2 operations are executed\nusing that path. Listeners that are designed only to connect\ninfected hosts laterally include the SMB and TCP beacons.\n\n\nAttackers can also control hosts through the interactive beacon\nconsole. This allows for more advanced control of a host.\n\n**WEB MANAGEMENT**\n\nCobalt Strike delivers exploits and/or malicious payloads\nusing an attacker-controlled web server. The web server\ncan be configured to perform the following actions:\n\n##### • Host files\n\n • Clone an existing website to trick users\n\n • Scripted web delivery\n\n • Signed Applet Attack (Java)\n\n • Smart Applet Attack (Java)\n\n • System profiling\n\n_Figure 4_\n\n\n_Figure 3: Cobalt Strike Pivot Table_\n\nFigure 4 shows how an adversary would manage the\n“Sites” console from their end. In this example, we’re\nhosting a malicious PowerShell script on the ‘/malware’\nURI over port 80.\n\nYou can also see that the HTTP based listeners are also\npresent as they are used to deliver additional payloads and\nC2 commands to victims.\n\nWhen a victim reaches out to the Cobalt Strike web server,\nit’s logged for operators.\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n_Figure 5: Cobalt Strike payload generated with x86 HTTP Listener._\n\n\n**REPORTING**\n\nCobalt Strike offers a variety of report generators to get a\ncomplete breakdown of the infected hosts and associated data.\n\nAvailable options include:\n\n##### • Activity report\n\n • Hosts report\n\n • Indicators of compromise\n\n • Sessions report\n\n • Social engineering report\n\n • Tactics, techniques and procedures\n\n### ATTACK ANALYSIS\n\n**TARGET MODULE: RAW SHELLCODE GENERATOR**\n\nCobalt Strike generates raw, malicious payloads that an\nattacker could implement into other attacks. The payload\ncan be generated as raw shell code or preformatted in\n\n\nalmost any language desired, including PowerShell, Python\nand Java, among many others. When generating raw\npayloads, the user is presented with only the HTTP, HTTPS\nand DNS beacons to choose from. The generated payload\ncan act as a staging payload for the Cobalt beacon, to be\nplugged into an exploit of their choice.\n\nFor analysis, we only concentrated on the x86 and x64\nbinary payloads generated in C. No matter the code\nselected, the resulting payload isn’t designed to execute by\nitself. The generator’s primary function is to format the shell\ncode in a way that allows the user to drop in a third-party\nexploit or custom exploits and have it preformatted in that\nparticular programming language.\n\nFigure 5 shows a payload generated with the x86 HTTP listener.\n\n**EXECUTION**\n\nSince the payload is only a bunch of raw bytes, it won’t\njust run if a user double-clicked the file. The adversary\nwould have to load the shellcode and jump to the desired\nentry point. This is trivial — we can use a quick C script that\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\nloads the desired shellcode and then\nexecutes it as if it were a function.\nThis enables defenders to quickly\nanalyze shell code in some cases\nwithout having to perform any overthe-top attempts to load it (Figure 6).\n\nOnce the buffer is allocated and\ncalled, we can see the start of the\nCobalt Strike shellcode in Figure 7.\n\n\nIt starts with a common shellcode\ninstruction `cld`, which is used to\nmake sure strings are processed\nfrom left to right by clearing the\nDirection Flag (DF). Then, we\nimmediately call the first function to\nimport “wininet.dll” (Figure 8).\n\nImmediately, we can see a string\nfor “wininet”, and a four-byte hex\nvalue pushed onto the stack, and an\nindirect register call on `ebp`, which\ncurrently points to the first instruction\nafter `shellcode_main()` [shellcode_\nmain+0x6].\n\nThe shellcode is unaware of the\nlibraries it needs to execute and\nneeds to import them. This technique\nis often used by malware to\nobfuscate calls to the Windows API\nby resolving imports using a hash of\nthe function. This one, in particular,\nis a modified version of Metasploit's\n“reverse_http” shellcode (Figure 9).\n\nFigure 10 shows a pointer to the\n[Process Environment Block (PEB)](https://en.wikipedia.org/wiki/Process_Environment_Block)\nand the PEB_LDR_DATA data\nstructure within. This target is the\n`InMemoryOrderModuleList,` which\ncontains a list of all modules loaded\nin memory. By traversing this list,\nwe can also get a list of functions\navailable within each module. Cobalt\nStrike iterates over each DLL,\nconverts the full name to lowercase\nand begins to calculate a hash\nvalue of each export using the full\nDLL name and the desired function\n\n\n_Figure 6_\n\n_Figure 7_\n\n_Figure 8_\n\n_Figure 9_\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\nname. The hashing algorithm used is\na simple ROR13, the same one used\nby Metasploit.\n\nThe retrieved DLL + Function name\nis compared to a calculated hash\nagainst the hex value (0x726774C)\npassed in earlier as an argument\nto `call_by_hash()`. If the match is\nsuccessful, Cobalt Strike calls that\nfunction immediately with the other\narguments passed.\n\n\nFigure 11 shows the relevant\nfunctionality from the Metasploit’s\n`hash.py:`\n\nThe payload makes an outbound\nHTTP call to the configured HTTP\nC2 server.\n\nThe Cobalt Strike C2 server responds\nwith an HTTP 200 OK, containing a\nvery large binary blob. This blob is\nthe core functionality of Cobalt Strike,\nbetter known as “beacon.dll.” From\nhere on out, this is the code that will\nbe used to control an infected host.\nAfter retrieving the DLL, it is loaded\n[via a technique called Reflective DLL](https://www.google.com/url?q=https://attack.mitre.org/techniques/T1055/001/&sa=D&ust=1596559074788000&usg=AFQjCNGxlDBHg3K-731T8ArLHwcCpVrVXQ)\n[injection.](https://www.google.com/url?q=https://attack.mitre.org/techniques/T1055/001/&sa=D&ust=1596559074788000&usg=AFQjCNGxlDBHg3K-731T8ArLHwcCpVrVXQ)\n\n**DETECTION**\n\nNow that we have a good\nunderstanding of how a Cobalt\nStrike payload works, we can work\non creating detection for these\npayloads. The goal when creating\ndetection content is to cover\nsomething in its entirety, with the\nfewest rules, without triggering false\npositives. This, for the most part,\nensures we are creating generic\ndetection rather than something that\nonly targets one thing. At Talos, we\nwant our detection to catch variants\nand potential future threats.\n\nWhen looking into coverage for the\nCobalt Strike payloads, we found we\n\n\n_Figure 10_\n\n_Figure 11_\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n\nhad some prior coverage alerting on the payloads, including\nthese Snort rules:\n\n##### • 1:15306:22\n\n • 1:11192:20\n\n • 1:30471:3\n\n • 1:30229:3\n\nThe first two are generic file type detection rules that are\nthe base for setting flowbits in Snort and can be ignored.\nHowever, SIDs 1:30471 and 1:30229 are Metasploit\nshellcode rules we released years ago that still apply here.\n\nAt the time, these rules were suspected to be false positive\nprone and were not enabled by default in policy. We can’t\nnarrow them down to a specific type or protocol. Therefore,\nwe have to remove a lot of checks that tell Snort whether or\nnot to inspect a packet further and re-enabled them.\n\nThe key element here is the Snort header, `alert tcp any\nany -> any any`. Most Snort rules will declare a traffic\ndirection (coming from or going to the user’s network)\nand the applicable port ranges. Since this raw shellcode\ncan be used with potentially any exploit over an unknown\nprotocol or port, we can’t narrow it down to inspection on\nfor example just port 80. We also don’t know if a host is\ncompromised already and attempting to move laterally, so\nwe can’t specify the source and destination networks. This\nmeans that Snort will attempt to match this particular byte\nsequence on all TCP traffic crossing the sensor. Not only\nis this undesirable for performance reasons, it heightens\nthe potential for false positives. We need to be a little more\ncautious when releasing a catch-all rule such as this.\n\nThe following Snort rule also helped in detecting reverse\nshell sessions from metasploit\n\n##### • [1:30480:3] INDICATOR-SHELLCODE Metasploit payload windows_x64_meterpreter_reverse_https\n\nAfter analyzing the preexisting Snort rules, the only thing\nleft to cover is the outbound HTTP request and the binary\nblob Cobalt Strike retrieves from the C2 server. Typically,\ncovering the initial outbound HTTP GET would be ideal\nsince we want to identify potential C2 traffic as fast as\npossible and flag the host as compromised in Cisco\nFirepower NGFW. However, the URI code we used in our\nresearch could be anything and was always random in\nsamples. The HTTP Header fields were also unhelpful, since\nthere wasn’t anything unique enough to distinguish the\nrequest apart from benign traffic. This leaves us with only\n\n\nthe HTTP response containing the binary blob.\n\nThe shellcode started similarly to the raw payload with a\n`cld` instruction followed by a short function designed to\ndecrypt the rest of the payload with an operator configured\nXOR key.\n\nSince we don’t want to target encrypted data with our\ndetection, we used the start of the shellcode as the\ndetection target. This resulted in two new rules, both\nlooking for the same thing across different listeners.\n\n##### • [1:53757:1] MALWARE-OTHER CobaltStrike beacon.dll\ndownload attempt\n\n##### • [1:53758:1] MALWARE-OTHER CobaltStrike beacon.dll\ndownload attempt\n\n**TARGET MODULE: STAGED/STAGELESS EXECUTABLE**\n**GENERATOR**\n\nThis module will encompass both staged and stageless\nCobalt Strike beacons. This is the core component\ndelivered to a victim host and establishes persistence, C2\ncommunication, and any further execution on the host.\nBeacons are extremely versatile and expose a huge number\nof features for operators.\n\n**Staged vs. Stageless**\n\nStageless payloads are delivered to the victim all at once.\nTypically, a stageless payload already contains a large\nvariety of malicious functionality and will not require\nadditional resources to infect the victim.\n\nStaged payloads are usually small, malicious payloads\nthat are used to load a larger, more robust payload. This\nallows an attacker to transfer a small binary to a targeted\nhost and retrieve the desired payload afterward. Stagers\nare designed to be as small as possible so that they can\nbe delivered using different techniques and leave less of a\nfootprint.\n\nHaving a smaller initial payload with less functionality\nis more likely to evade AV detection by appearing to be\nbenign. A stager can then grab the larger payload for more\nfunctionality and load it directly into memory.\n\nStagers allow adversaries to embed your payloads in\ndifferent methods. An adversary could take staged code and\nsend it in an exploit with resource limitations on the target.\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n**Beacon options**\n\nGenerating a beacon payload can\nresult in a few different types of\nexecutable files — each of them\nembedded with a Listener and\narchitecture of your choice. This will\ngenerate an `artifact.exe` file to save\non disk. How it’s used from there is\nup to the operator.\n\n##### • Raw (Stageless only)\n\n • Windows EXE\n\n • Windows Service EXE\n\n\n\n##### • Windows DLL (32 bit)\n\n • Windows DLL (64 bit)\n\n**Staged**\n\nAfter startup, Cobalt Strike spawns a\nnew thread designed to construct a\nnamed pipe for further execution. For\nthe purposes of research, we opted\nto utilize a 32 bit executable with a\nreverse HTTP listener.\n\nFigure 12 shows a format string that\ncalls to `sprintf()` with the default\nstructure of the named pipe. The\nfour-digit number is a randomly\ngenerated number but we can see\nthat in a default configuration, the\nname has a static structure like\n“\\\\\\\\.\\\\pipe\\\\MSSE-6722-server.”\n\nFollowing thread creation, the\nnamed pipe is created and a\nconnection is initiated. The goal of\nthis is to process additional shellcode\nembedded within the binary by\nwriting it to the named pipe thread.\n\nThis pipe is decrypted using a rolling\nXOR against the data. The default\nXOR key for this particular payload\nis 0xE3F4C314. After decryption is\ncomplete, another thread is created\nthat immediately jumps to and\nexecutes the shellcode (Figure 13).\n\n\n_Figure 12_\n\n_Figure 13_\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n_Figure 14_\n\n\n**Stageless**\n\nStageless operates in the same way a staged payload\ndoes — it still spawns a named pipe and data needs to\nbe decrypted just like a staged payload. This payload in\nparticular is larger than 200KB.\n\nHowever, once the final payload is decoded, it needs to be\nloaded into memory. This is performed using a technique\n[called Reflective DLL loading — the process of loading a](https://www.exploit-db.com/docs/english/13007-reflective-dll-injection.pdf)\nlibrary from memory into a host process.\n\nAn executable needs to access various resources to\nfunction correctly. It needs to know its base address in\nmemory and have valid headers and a fully built import\naddress table. This is how an executable knows where to\ncall functions such as LoadLibrary or GetProcAddress.\n\nOnce the reflective loader has rebuilt the necessary sections\nand relocated the image, we’ll see the actual path of execution.\n\nOnce we unpack beacon.dll, we can dump it to disk and see\nthe final artifact.\n\n\n**Beacon configuration**\n\nCobalt Strike configuration is marked in the executable by\npatterns that allow us to parse it directly out of an unpacked\nbeacon DLL. The configuration is XOR encrypted, but by\ndefault, use a static XOR key for each respective beacon\nversion (3 or 4).\n\nFigure 14 shows a decrypted Cobalt Strike configuration\nfrom the unpacked Cobalt Beacon.\n\n**C2 COMMUNICATION**\n\n**Heartbeat**\n\nAn infected host will reach out to the Cobalt Strike C2\nserver periodically with a heartbeat, sending basic\nmetadata back home and gathering any commands issued\nby an operator. When a command is requested to be\nexecuted on the host, it’s queued up and waits for that host\nto reach out.\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n_Figure 15_\n\n_Figure 16_\n\n_Figure 17_\n\n\nFigure 15 shows the heartbeat.\n\nIt looks pretty benign, but all the metadata is stored in the\nHTTP cookie. We can’t simply gain access to that data by\nbase64-decoding the cookie, since Cobalt Strike heartbeat\ndata is encrypted. Cobalt Strike uses RSA with PKCS1\npadding to encrypt the data prior to sending it back home.\n\nTalos researchers extracted the private/public key\ndirectly from the teamserver running on a virtual machine,\nsomething that wouldn’t be possible outside of an isolated\nresearch environment.\n\n**_Tasks_**\n\nNow that we understand the heartbeats, let’s look at\nthe exchange for tasking a beacon. When a task is not\navailable, the server will respond with another encrypted\n\n\npayload in the HTTP 200 OK (Figure 16).\n\nWhen configured, the response payload is an encrypted\ntask. Cobalt Strike uses AES-256 in CBC mode with HMACSHA-256 to encrypt task commands. The AES key can\nbe found in the beacon metadata we decrypted earlier.\nIt is calculated using the first 16 bytes of the decrypted\nmetadata.\n\n**_Callbacks_**\n\nAfter execution, the host calls back to the C2 server.\nThis time, the default configuration was an HTTP POST\ncontaining another encrypted payload (Figure 17).\n\nThe first four bytes are the size of the encrypted payload so\nwe skip those when decrypting.\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\nThe structure of the data observed is:\n\n##### • 4 bytes - Counter\n\n • 4 bytes - Data Size\n\n • 4 bytes - Type of callback\n\n • Variable - Data\n\nFigure 18 is a decrypted Process List callback.\n\n**Detection**\n\nBased on these actions, we wanted to write detection\nthat would catch a Cobalt Strike stager being downloaded\nbefore it can target anything else. Catching the stager is\npivotal, as it is most likely to prevent infection. Once the\nstager traverses into memory, it reflectively loads the final\nbeacon payload and becomes harder to deal with.\n\nResearchers first generated every variant possible and\ncreated PCAPs of the stager traversing over typical ports\nseen in file-data traversal.\n\n\nOnce again, we triggered the Metasploit shellcode rules for\nevery payload when we checked prior coverage:\n\n##### • 1:30229 INDICATOR-SHELLCODE Metasploit windows/\nshell stage transfer attempt\n\n##### • 1:30471 INDICATOR-SHELLCODE Metasploit payload\nwindows_adduser\n\n##### • 1:30480 INDICATOR-SHELLCODE INDICATOR-SHELLCODE Metasploit payload windows_x64_meterpreter_reverse_https\n\nSince we confirmed these rules provide coverage, we can\nmove onto the core stageless beacon.\n\n\n_Figure 18_\n\nThe approach here was to once again find a unique set\nof instructions that can be associated with Cobalt Strike\nbeacons while avoiding false positives. It was pretty difficult\nto find a good match in the stageless beacons, but the\nfunction in Figure 19 sparked our interest.\n\nThis function is pretty simple — its purpose is to parse the\nDOS header and check for the correct file magic signature.\n\n_Figure 19: A function_\n_inside a stageless Cobalt_\n_Strike beacon._\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\nIf it exists, it jumps to the IMAGE_NT_OPTIONAL header\nand checks the magic there.\n\n\nAfter comparison, the AL byte is set to reflect the correct\narchitecture. This is used for further processing of the\nfile header. A quick run in Snort showed that this alerted\non every single beacon we generated. This doesn’t look\nmalicious on the surface, so researchers ran this function\nwith multiple preceding NOPs through false-positive\ntesting. Expectations were not high, but we couldn’t find a\nsingle false positive. This wasn’t the case prior to adding in\nthe extra alignment bytes. Either NOP was less commonly\nused for alignment in modern compilers, or we were\nextremely lucky. Regardless, we had performed enough\ndue diligence in testing to give the rule a shot.\n\nThe result was four rules that are still going strong to this day.\n\n##### • 1:53656 MALWARE-OTHER Cobalt Strike x86 executable download attempt\n\n##### • 1:53657 MALWARE-OTHER Cobalt Strike x86 executable download attempt\n\n##### • 1:53658 MALWARE-OTHER Cobalt Strike x64 executable download attempt\n\n##### • 1:53659 MALWARE-OTHER Cobalt Strike x64 executable download attempt\n\n**TARGET MODULE: HTML APPLICATION ATTACK**\n**GENERATOR**\n\nThe focus of this attack generator is to generate an HTML\nApplication (HTA), a file extension for the HTML executable\nfile format and typically consists of HTML/Dynamic HTML\nand a scripting language of choice. HTA files behave like\nexecutables. They are popular among attackers because\nthey run as a fully trusted application in certain cases.\n\nWhen using the HTML Application Attack generator the user\ncan select a Cobalt Strike listener as usual and the method,\nincluding executable, PowerShell and VBA.\n\nThese methods do not determine the scripting language\nused in the HTA files. In all methods, VBScript is used to\ndeliver the desired payload in the HTA file. The method,\nhowever, changes the payload type and how it is executed\non the host. Let’s take a look at each of them.\n\n**Executable**\n\nThe executable method (Figure 20) is a straightforward\n\n\n_Figure 20_\n\n_Figure 21_\n\n_Figure 22_\n\nattack, as it is simply designed to load a large ASCII hex\nstring and execute it on the host.\n\nThe shellcode is loaded by creating a `Scripting.\nFileSystemOjbect` and using that to create a temporary\nfile on the host. After initializing the temporary file, the\nshellcode stream is converted from hex string to bytes and\nwritten to the file (Figure 18).\n\nFinally, the file is executed using a WScript.Shell object and\nthe temporary file and folder are deleted to cover its tracks\n(Figure 21).\n\n**PowerShell**\n\nThe Powershell method is relatively naive at first glance,\nas it once again uses the WScript.Shell object to invoke\nPowerShell. This time, rather than creating a temporary\nexecutable file, it simply runs powershell with a large\nbase64-encoded command (Figure 22).\n\nWe base64 decode the command, which results in a\nunicode string containing additional PowerShell and another\nbase64 blob. Here, we can start to see the desired path to\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n_Figure 23_\n\ninfection, as it takes the second base64 blob and is creating\nan `IO.MemoryStream` object out of it. A quick look at the\nresulting code shows that we, once again, jumped the gun\nin analysis and it’s gzip compressed.\n\n\nWe can quickly decompress the extracted data on the CLI\n(Figure 23).\n\nThe newly decoded payload declares some new functions.\n\n##### • `func_get_proc_address()`\n\n • `func_get_delegate_type()`\n\nThis is a fairly old technique (around 2012) that allows\nthe user to invoke calls via .NET native method wrappers\nin PowerShell. This allows the user to call the Windows\nAPI using and execute code in a fileless manner via the\n[`System.Reflection` namespace.](https://docs.microsoft.com/en-us/dotnet/api/system.reflection)\n\nWe can then use`GetMethod()` to acquire a handle to the\ndesired functionality and bypass any restrictions. The goal\nin this payload is to expose the `GetProcAddress` library\nfunction so that we can load the desired Windows API code\nand interact with it.\n\nSystem.Reflection exposes another function called\n`GetDeletegateForFunctionPointer`. Using this, Cobalt\nStrike grabs a function pointer to any API function it needs\nfor execution.\n\nOnce an executable section of memory is allocated and\n\n\n_Figure 24_\n\n_Figure 25_\n\npopulated.. Cobalt Strike can then execute the payload\nin memory through another delegate defined for the\nmemory region.\n\nSo what is the base64 string this time? It’s shell code, but\nactually XOR encrypted (Figure 24).\n\nThis is pretty easy to decrypt. We know that it’s XOR’d using\nthe key 0x23 (35) so we can decode this using our method of\nchoice. In this case, we used `xortool-xor` (Figure 25)\n\nEventually, we determined that this is the same code as\nseen in the raw payload section in different packaging.\nOnce Cobalt Strike gets it right, it reuses that work across\nother attack options. This makes it more convenient for\ndefenders to write detection.\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n_Figure 26_\n\n\n**VBA**\n\nThe VBA Method gives a little bit of a different approach\n(Figure 26).\n\nSo far, we’ve seen basic methods of loading binary code\nand executing it. In this method, we can see that it uses an\nExcel Workbook to execute additional code. The first thing\nthat happens is Cobalt Strike loads up an `Excel.Application`\nand then queries a registry key:\n\n`HKEY_CURRENT_USER\\Software\\Microsoft\\\nOffice\\<Excel Version>\\Excel\\Security\\AccessVBOM\\`\n\nThis key is a security setting for restricting default\nprogrammatic access to the Office VB project. If it’s\nenabled, Office will trust all macros and run any code\nwithout a security warning or additional permissions from\nthe user. Cobalt Strike attempts to flip that switch and\n\n\ndisable this protection in the registry.\n\nAfter that, Cobalt Strike once again calls the Windows API\nto execute binary code. Then, it allocates an executable\nsection of memory within the process and runs it by calling\n`kernel32.dll!CreateRemoteThread`.\n\n**Detection**\n\nThis type of multilayer obfuscation is easy to extract when\nin hand but can be extremely effective against security\nproducts that don’t know it’s coming. But it’s possible to\nwork around this.\n\nFor the executable method, the shellcode was actually the\nsame assembly code as what we discussed earlier in the\nStaged/Stageless Executables. The NOP-based function is\ninterpreted as a hex string, so we can clone those rules to\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n\nmatch a hex string, rather than actual bytes.\n\n##### • 1:54110 MALWARE-OTHER Html.Trojan.CobaltStrike\nHTML beacon download attempt\n\n##### • 1:54111 MALWARE-OTHER Html.Trojan.CobaltStrike\nHTML beacon download attempt\n\n##### • 1:54112 MALWARE-OTHER Html.Trojan.CobaltStrike\nHTML beacon download attempt\n\n##### • 1:54113 MALWARE-OTHER Html.Trojan.CobaltStrike\nHTML beacon download attempt\n\nFor the PowerShell method, we have again a ton of\nobfuscated code underneath it, so the coverage should\ntarget generic function calls. For this, we went with the\nPowerShell command arguments, and supplemented that\nwith matching on a Wscript.Shell object being created.\n\n##### • 1:54114 MALWARE-OTHER Html.Trojan.CobaltStrike\npowershell payload download attempt\n\n##### • 1:54115 MALWARE-OTHER Html.Trojan.CobaltStrike\npowershell payload download attempt\n\nLastly, we have the VBA Method. Our researchers found\nthis easy to cover because HTA files don’t often interface\nwith Excel workbooks, let alone one that tinkers with the\n“AccessVBOM” registry key.\n\n##### • 1:54116 MALWARE-OTHER Html.Trojan.CobaltStrike\nVBA payload download attempt\n\n##### • 1:54117 MALWARE-OTHER Html.Trojan.CobaltStrike\nVBA payload download attempt\n\nFrom there, we cloned all that to ClamAV coverage to get\nthe following signatures:\n\n##### • Html.Trojan.CobaltStrike-7932561-0\n\n • Html.Trojan.CobaltStrike-7932562-0\n\n • Html.Trojan.CobaltStrike-7932563-0\n\n • Html.Trojan.CobaltStrike-7932564-0\n\n**TARGET MODULE: SCRIPTED WEB DELIVERY**\n\nIn Cobalt Strike, there’s a feature called “scripted web\ndelivery.” Executing a scripted web delivery attack simply\nmeans that you pick one of the Cobalt Strike payloads/\nlisteners and Cobalt Strike will then host that payload at\na user-configured URI. These can be generated in three\ndifferent languages: Bitsadmin, PowerShell and Python.\n\nAfter hosting the payload, Cobalt Strike provides a\n\n\ncommand that can be executed, in the language of choice,\nthat reaches out and grabs the malicious payload from an\nattacker-controlled web server and executes it.\n\nWe are only going to concentrate on the PowerShell\nimplementation, as it is the most commonly used module.\nThe initial execution is using a web client to download an\nadditional PowerShell payload from the attacker controlled\nweb server and then continue to execute that code.\n\n**Payload**\n\nAfter reaching out to grab the real payload, we get a huge\nobfuscated PowerShell script from the web server, almost\n200KB in size.\n\nThis script contained code reuse from the HTA module,\nbut we still needed to go one layer deeper and verify the\nshellcode was unique in this module. We base64-decode\nthe data and decrypt it using the same `0x23` default\nXOR key — and it’s already much larger than the previous\npayload.\n\nIt’s not raw shellcode like we saw in the HTA payloads,\nyou can immediately see that the “MZ” header is present.\nThis seems to be a stageless beacon included in the\npowershell script. You might wonder why it wasn’t\nincluded in the HTA attack. The reason is the HTA module\nis executing a Powershell one-liner and Windows has\na character limit on command line strings, 32767. That\nnumber is even lower when executing a command from\n`cmd.exe`, 8191. The character limit varies across a variety\nof execution methods and these numbers are not always\ngoing to be correct.\n\nSince this payload is downloaded using a small one-liner to\nexecute a string retrieved from the Cobalt Strike controlled\nserver, that limit is bypassed and a more reliable payload\ncan be provided.\n\n**Detection**\n\nTo detect something, we first have to narrow down what\nwe can actually see in Snort or ClamAV. We are not able\nto deobfuscate a PowerShell script coming across the\nnetwork prior to detection — it’s simply not feasible without\nintroducing latency for the client in most cases.\n\nSo, for detection, we are left with the initial obfuscated\npayload downloaded. That’s not so bad because Cobalt\nStrike, in its current configuration, once again has a\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n_Figure 27_\n\n_Figure 28_\n\n\nstatic format when generating the PowerShell script.\nWe know that in this instance, the code `New-Object\nIO.MemoryStream(,[Convert]:: FromBase64String(` following\nwill always be present in a position relatively close to the\nstart of the file.\n\nThis gives us simple, but efficient, coverage using\n\n##### • 1:53973 MALWARE-OTHER CobaltStrike PowerShell\nweb delivery attempt\n\n##### • 1:53974 MALWARE-OTHER CobaltStrike PowerShell\nweb delivery attempt\n\n**TARGET MODULE: SIGNED JAVA APPLET ATTACK**\n\nThe applets in this attack are self-signed, giving users\nlimited options: a listener (per usual), port, local host and\nthe URI it’s hosted on. This will spawn a hosted Java Applet\non a malicious Cobalt Strike web server to infect users. If a\nuser gives an applet permission to run, infection will occur.\n\n\n**Landing Page**\n\nUpon visiting the page, the user sees a generic landing\npage that loads a malicious JAR file, “cross_platformi9.jar”\nand applet class loaded is defined by the “code” parameter,\n“Java.class” (Figure 27).\n\nThe first thing that catches the eye is that two parameters\nare passed — “id,” which contains a large base64 blob, and\n“type” which is set to “theme.” We can confirm this right off\nthe bat by comparing the length of the raw HTTP beacon\npayload against the length of the decoded binary blob, both\na total of 799 bytes.\n\nA second HTTP GET request is made for the JAR file during\nthe process of loading this applet. So that’s the next step.\n\n**Java archive (JAR)**\n\nFirst, we’ll look at the JAR file (Figure 28).\n\nWe have a few classes, and two DLLs named “main.dll”\nand “main64.dll”. You can also see the default signature file\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n(MYKEY.SF) and RSA certificate (MYKEY.RSA) used to sign\nthe binary. Figure 29 shows us jusing jadx to decompile the\nsource code.\n\n\nThe base code called “Java.class” isn’t complicated — it’s\nan extension of “Applet” designed to spawn a thread. And\nthe Base64.dll class isn’t malicious, it handles base64 as\nexpected.\n\n“Main.class” is fairly basic but shows us that a temporary\nfile is created, named “main.dll” and writes data to that\nfile from either the main64.dll or main.dll file contained in\nthe JAR file based on the system architecture. The system\nproperty “sun.arch.data.model” is a simple method to return\nthe system’s word size, easily determining the architecture.\nFollowing this, the new DLL file path is fed to `System.\nload()`.\n\nCobalt Strike uses the Java Native Interface (JNI) to perform\ninjection. This is essentially the same as creating bindings\nto another program. It allows users to load a library into the\nJava Virtual Machine (JVM) and interact with it.\n\n**Main.dll**\n\nSince inject() is called from the JNI with the shellcode blob,\nwe can load this into IDA and see an exposed function —\n`Java_Main_inject()`.\n\nThe handoff to `Java_Main_inject` isn’t as straightforward as\nit would be passing a byte/character array in C/C++. In this\ncase the exported function looks a little like Figure 30:\n\nThe data is extracted from the JNI objects and then passed\nto the real `inject()` function that spawns a new thread and\nresumes execution in the shellcode passed in from the “id”\nparameter.\n\n**Detection**\n\nWe need to isolate the things we want to cover and\nseparate them from each other when evaluating multiple\n\n_Figure 30_\n\n\n_Figure 29_\n\nlevels of execution. Here, we can identify a few things.\n\n**1.** The landing page that spawns the malicious applet\n\n**2.** The JAR file\n\n**3.** main.dll/main64.dll\n\nThe landing page was fairly simple, as we already identified\nthat the parameter is simply the raw payload from earlier.\nThe JAR files contain the same DLL 32/64 bit and code\nevery time but have a different name. This simplifies things\nas we target what we know is malicious in there.\n\nThe last thing was the extracted DLL, and our prior work\npaid off. We had prior coverage available from various x32/\nx64 download rules we created researching the staged/\nstageless beacons.\n\n**TARGET MODULE: SMART JAVA APPLET ATTACK**\n\nThe Smart Java Applet Attack is very similar to Signed Applets\nin execution. Instead of just running raw shell code, though, it\nattempts to gain execution through various Java exploits. It is\ndeemed “Smart” as it determines what exploit to use based\non the version of Java the victim host is running.\n\n**Landing Page**\n\nThe landing page is for the most part the same as Signed\nApplet Attacks. It spawns a malicious page on the default\nURI, “/SiteLoader.”\n\nOnce again, there’s a base64 blob containing the “id”\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\nparameter and a “type” parameter\nwith the value “os.” The payload is\nslightly different, however, since it\nuses the same shellcode stub. We\nalready know what this does for\nthe most part, so we’ll skip further\nanalysis.\n\n**Java Archive**\n\nPer the Cobalt Strike official\ndocumentation, we can get a brief\nunderstanding of this module’s goal.\n\n\n\n##### • The smart applet analyzes its\nenvironment and decides which\nJava exploit to use. If the Java\nversion is vulnerable, the applet\nwill disable the security sandbox,\nand spawn a session using Cobalt\nStrike’s Java injector.\n\n##### • These exploits in this attack work\nagainst Java 1.7u21 and older.\nJava 1.6u45 and older is also\nvulnerable to this attack.\n\nThe exploits used are not specified\nhowever, we know it affects the Java\nversions shown in Figure 31. Since\nwe don’t know what exploits it’s\nusing already, we must look closer.\n\nThere are a lot more classes shown\nin Figure 32, but we can see that\nmain.dll/main64.dll are still included.\nA quick `sha256sum` reveals that\nthese are the same DLLs included\nin the Signed Applet Attack module.\nWe once again can decompile the jar\nusing `jadx` as we did in the Signed\nApplet Attack. The decompilation\nwas not clean as we receive one\nerror for an unknown instruction,\n“invoke-polymorphic”. This\ninstruction is not currently supported\nin jadx, so we will just ignore it for\nnow and start looking at `JavaApplet.\nclass` in Figure 31.\n\nThis class directs execution based on\n\n\n_Figure 31_\n\n_Figure 32_\n\nthe version of Java installed, here we can identify how it targets each version. The\ncode polls “java.version” via a call to System.getProperty to get the JRE version\ninstalled, if any. Following that it is matched against the PCRE `1.(\\d+).0_(\\d+)`. The\nimportant thing with this PCRE is that it has two capture groups that retrieve major\nand minor Java versions for further processing. It’s important to understand the\n[structure of Java version strings. [See https://www.oracle.com/java/technologies/](https://www.oracle.com/java/technologies/javase/versioning-naming.html)\n[javase/versioning-naming.html].](https://www.oracle.com/java/technologies/javase/versioning-naming.html)\n\n\"1.<Major Version>.0_<Update Release>\"\n\nWhen the version string for the product is reported as “java version 1.8.0_5”, the\nproduct will be called JDK 8u5, JDK 8 update 5 or, when the update version is not\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n_Figure 33_\n\n\nimportant, JDK 8.\n\nWe discovered this module exploits multiple vulnerabilities.\nThe Java execution flow is as follows:\n\n##### • <= Java 6u27 -> `Rhino()`\n\n • <= Java 6u45 -> `AppIcon()`\n\n • == Java 7u0 -> `Rhino()`\n\n • <= Java 7u6 -> `Exec()`\n\n • <= Java 7u21 -> `Bean()`\n\nIf the regex fails and the version string is equal to “1.7.0”\nalso direct execution to `Rhino()`\n\n**Main.java**\n\nMain.java contains the same code as we saw in the Signed\nApplet attack. Its sole purpose is to run main.dll, or main64.\ndll, with the shellcode provided in the “id” parameter by\ninterfacing with the JNI. We will touch on how this works a\n\n\nbit in the next section.\n\n**CVE-2011-3544 - Oracle Java applet rhino script engine**\n**remote code execution**\n\nJava Version <= 1.6.0_27 or Java Version == 7.0\n\nThis class is associated with the Rhino Script Engine which\nis used to run arbitrary code outside of the Java sandbox.\n\nThis was dangerous at one point in time because these\nJavaScript objects were not controlled by the Java\nSecurityManager. Protections were put in place to limit\nattempts to execution however it was determined that you\nbypass the sandbox limitations by storing Java code in a\nstring and then executing it. When executing the `toString()`\nmethod, it returns a Java function in the context of the caller\n(Figure 33).\n\nSo if we are restricted by the permissions of the caller,\nwe are still limited in execution privileges. Instead, we\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n_Figure 34_\n\n_Figure 35_\n\n\nneed to generate an error object containing the code as\nits message. This module extends the Main class. When\nspawning a thread of itself, it will look to see if the class\nimplemented `Runnable` and the `run()` function, which\n`Main` does. This means that the goal is to spawn main.dll\nwith desired shellcode but from outside the sandbox.\n\n**CVE 2013-2465 - Oracle Java 2D ImagingLib remote**\n**code execution**\n\nJava Version <= 1.6.0_45\n\nThis vulnerability exploits a vulnerability when filtering()\nBufferedImage’s using `AffineTransformOp`.\n\nFirst, some necessary helper classes are defined\nto assert certain behavior later down the road,\n“ComponentColorModel” and “ICC_ColorSpace” (Figure 34).\n\nFigure 35 shows a defined ColorComponentModel that\n\n\nis supplied to the `BufferedImage` constructor to fool a\nspecific check within `storeImageArray()`. That check is\nfor `(hintP->packing == BYTE_INTERLEAVED)`. When this\ncheck succeeds, data is written back to the destination.\nThe second class defines a ComponentColorModel\nthat will always return `True` when calling\n`isCompatibleRaster()`.\n\nNow to prepare an exploit, we move to `loadIcon()`. First,\nwe need to prepare the necessary objects for execution.\nThe order of the following allocations is extremely\nimportant as we want them to be aligned in memory\n(Figure 35).\n\nTo get a better understanding of Java access control security.\nA `Statement` object can represent arbitrary method calls.\nWhen an instance of `Statement` is created, the current\nsecurity context is stored in `Statement.acc`. When calling\n`execute()` on that statement, Java attempts to verify that the\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\npermissions surrounding that call have\nnot been changed by looking at the\nvalue of `Statement.acc`. Therefore\nthe goal of this exploit is to gain the\ncorrect permissions on `System.\nsetSecurityManager()` to disable it by\noverwriting it’s `AccessControlContext`.\nTo prepare for that, a new\n`Permissions` object is created with\n`AllPermission()` (Figure 36).\n\n\nNow, comes CVE-2013-2465\n(Figure 37).\n\nTwo `BufferedImage` are created. The\nsecond uses the dataBufferByte[]\nobject we declared earlier. A raster\nis created with a `dataBitOffset`\nthat points outside of the\n`dataBufferByte[16]` memory structure.\nCobaltStrike then sets the first pixel to\n`0xFFFFFFFF`. Finally, the vulnerable\nstoreImageArray() call through filter()\nis performed and data is written back\nto the object and corrupts the adjacent\nobject’s length.\n\nCobalt Strike can now loop\nthrough `iArr[]` until it finds the\ndefault `Statement.acc` field and\noverwrite it with the `AllPermission`\nobject created earlier. Now,\n`setSecurityManger` can be executed\nwith the necessary permissions to\ndisable it and run shellcode.\n\n**CVE-2012-4681 - Oracle Java 7**\n**SunToolkit Remote Code Execution**\n\nJava Version <= 1.7.0_6\n\nThis vulnerability exploits the Java\n`Class.forName()` or `ClassFinder` to\ngain access to private object fields.\nIn the context of CobaltStrike, this\nresolves around calls to `SetField()`\nfrom `sun.awt.SunToolkit`. Originally\nin Java 6, this was not possible as we\nweren’t allowed to gain a reference\nto `sun.awt.SunToolkit`. In Java 7.0_6,\nthis changed and introduced CVE\n\n_Figure 36_\n\n_Figure 37_\n\n2012-4681.\n\nThere are three main methods to this class.\n\n##### • `check()`\n\n • `SetField()`\n\n • `GetClass()`\n\nCheck() is the first function executed in the exploit and the execution path is\npretty simple. As we saw in CVE-2013-2465, a Statement object is created for\n`setSecurityManager()`, along with a new permissions object.\n\nThe next operation is a call to `sf()`, short for `SetField()`, private class method\nwith the statement class type, the desired field “acc”, our Statement object,\nand the new permissions we want. `Sun.awt.SunToolkit` is a restricted class\nfor untrusted code, normally you wouldn’t be able to gain access in our current\nsecurity context.\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\nAn adversary could exploit this vulnerability by calling\n`Class.forName()` as the target method of the Expression. In\nreality, `forName()` is not called. Instead, `Expression` uses\ncustom logic to load classes without verifying permissions.\nWithout `Expression`, this would not be possible.\n\nAfter returning to `SetField()` with our privileged class\naccess, the second issue is exploited to gain access to\na private field. An adversary could go on to disable the\nsecurity manager and execute arbitrary shellcode.\n\n\n**CVE-2013-2460 - Oracle Java ProviderSkeleton invoke()**\n**remote code execution**\n\nJava Version <= 1.7.0_21\n\nThis exploit involves gaining access to a restricted package\nthrough a public interface.\n\nThis exploit can be found in:\n\n##### •  Bean\n\n •  BeanHelper\n\n •  BeanProvider\n\nThe `com.sun.tracing.Provider` and `java.lang.reflect.\nInvocationHandler` are the main culprits here. This gives\naccess to a `Provider` interface, or `ProviderSkeleton`, and\nprovides the base for the target `invoke()` function.\n\nThis starts obtaining a lookup method by creating an\nInvocationhandler via `java.lang.reflect.Proxy`. From there,\nthe exploit can obtain a reference to `MethodHandles.\nlookup` and call it via the InvocationHanlder defined earlier.\n\nThis is most of the work needed to begin exploitation, access\nto the `invoke()` method is already provided. But how does\nthat give an attacker an opportunity to elevate privileges? The\ninvoke method, in Java 7u21, does not perform any checks on\nwhether or not a public method should be accessible by the\ncalling class. See the openjdk commit in Figure 38.\n\n_Figure 40_\n\n\n_Figure 38_\n\n_Figure 39_\n\nThe second issue is that in this case, `invoke()` does not\nreturn the calling blass but instead returns `sun.tracing.\nProviderSkeleton`. This all comes together because\n`ProviderSkeleton` is a privileged class. Eventually, Cobalt Strike\nloads several classes and, once again, disables the manager.\n\nCobalt Strike now uses the `displayAd()` (Figure 39) to make\ncalls to invoke() and return privileged classes that they\nwould otherwise not have access to.\n\nYou can see another call to `getMethod()` prior to invoking\nthe argument, this function is used to obtain access to the\nfamiliar `forName()` method. Then once again like earlier, that\ncan be called to gain access to restricted classes (Figure 40).\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\nNext, three restricted classes are loaded:\n\n##### • `sun.org.mozilla.javascript.internal.Context`\n\n • `sun.org.mozilla.javascript.internal.DefiningClassLoader`\n\n • `sun.org.mozilla.javascript.internal.GeneratedClassLoader`\n\nThis is now used to load the `BeanHelper()` class included\nwith the Smart Applet and execute it under a privileged\ncontext by calling `AccessController.doPrivileged()’, as\nshown in Figure 41.\n\n\nAnd the security manager is disabled... again.\n\n**Detection**\n\nThe amount of devices running Java is astoundingly\nhigh still in 2020. It still continues to be a widely used\nlanguage and commonly installed utility for users. These\nvulnerabilities are pretty old, but for the Smart Applet to be\neffective, the amount of vulnerable devices is likely still high\nenough to warrant them being included.\n\nNow, detection here was the easiest part. Remember\nhow the landing page was extremely similar to the Signed\nApplet module? Additionally, main.dll/main64.dll is again\nincluded in the Smart Applet JAR. We already covered it\nwith the same detection. Case closed on some old Java\nvulnerabilities with prior coverage.\n\n**TARGET MODULE: SYSTEM PROFILER**\n\nThis module is designed to perform reconnaissance on\nsystems visiting a Cobalt Strike-controlled web server. It is\nimportant to note that this module is not intended to infect a\nhost, but rather supply information on the operating system\nand applications installed on a target.\n\n_Figure 42_\n\n\n_Figure 41_\n\n**Payload**\n\nWhen an operator configures the system profiler, there are\ntwo options for gathering the desired information. The first\none utilizes a large JavaScript file that leverages multiple\nActiveX controls to gather information. The second is an\noptional Java Applet, a common theme we’ve seen in\nCobalt Strike, to supply additional information on top of the\nJS. The final configuration option is a redirect. This makes\nthe victim client redirect to another page after performing\nprofiling the system.\n\nThe initial landing page for the system profiler delivers a\npage with code similar to Figure 42:\n\nLet’s glance over both types for a high-level overview.\n\n**Java Applet**\n\nThe initial landing page checks to see if Java is installed and\nenabled in two different ways. First, it uses `deployJava.\ngeJREs()` to return an array of installed versions, or an\nempty array if not present. The second is `navigator.\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n_Figure 43_\n\n_Figure 44_\n\n\njavaEnabled()` which is a simple boolean \"True\" or \"False\".\n\nJava is installed if either check succeeds. The Java Applet,\n“iecheck.class,” runs on the page, as shown in Figure 43.\n\nThe class contains a small code base that only has two\nfunctions. One is designed to return the version of Java,\nthe client is running. The other is a little more tricky and is\ngeared toward exposing the internal IP address of the client.\n\n**JavaScript**\n\nThe JavaScript is the bulk of the profiler and a huge file\nweighing in at over 200KB and almost 5,000 lines of code\n(after beautifying it). It checks browser versions, system\ninformation and installed applications through JavaScript\nand ActiveX calls.\n\n\nSome of the checks include but are not limited to web\nbrowser, operating system, Adobe Acrobat, Adobe Flash\nand more. It also includes another attempt to get the\ninternal IP address of the client, just like the Java Applet.\n\n**Detection**\n\nDetection here is pretty straightforward. Since the profiler\nis trying to do so much at once, we can make quick work on\nthe landing page by checking HTTP responses.\n\nWe want to look for any abnormal combination of\napplication version checks by using ActiveX control class\nIDs and object names, static version checks, and attempts\nto load a Java applet. We can also look for attempts to\nstore data within a 1x1 (width x height) element named\n`checkip`.\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n\nGenerally speaking, it’s the easiest way to catch\ncommunication in the response from the client. At the end\nof the “check.js” file, we see an attempt to make an HTTP\nPOST request back to the server with whatever information\nwas collected (Figure 44).\n\nWe can see that the client data section of the HTTP\npost contains the parameters and values sent to the\n`application()` function.\n\nThis left us with the following detection:\n\n**_Snort_**\n\n##### • 1:13913 BROWSER-PLUGINS AcroPDF.PDF ActiveX\nclsid access attempt\n\n##### • 1:23878 BROWSER-PLUGINS Oracle JRE Deployment\nToolkit ActiveX clsid access attempt\n\n##### • 1:38038 POLICY-OTHER PDF ActiveX CLSID access\ndetected\n\n##### • 1:54180 MALWARE-OTHER Cobalt Strike system profiling attempt\n\n##### • 1:54181 MALWARE-OTHER Cobalt Strike system profiling attempt\n\n\n\n##### • 1:54182 MALWARE-OTHER Cobalt Strike system profiling attempt\n\n**_ClamAV_**\n\n##### • Java.Malware.CobaltStrike-8008971-0\n\n### CONCLUSION\n\nThis is an in-depth view into the Cobalt Strike attack\nframework, how Talos researchers analyzed each module\nand the struggles, breakdowns, victories, and detection that\ncame along with it.\n\nThe research performed resulted in more than 50\nsignatures between Snort and ClamAV combined, covering\nover 400 Cobalt Strike samples.\n\nIt’s important to note that the resulting detection based on\nthis research project is intended to provide robust coverage\nfor Cobalt Strike at its core, but is by no means exhaustive.\nLarge-scale attack frameworks are always evolving,\nespecially highly funded ones such as Cobalt Strike.\n\nResearchers must target what each security product does\nwell and use that to their advantage. With that, you also\nhave to know where its weaknesses lie. Having a good\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\nunderstanding of the strengths and weaknesses in Snort or\nClamAV is key to developing good generic detection.\n\nDoes this mean we have covered Cobalt Strike in its entirety\nand it’s forever dead in the eyes of Talos? No. Does it mean\nwe have provided what we believe to be a reasonably high\nlevel of detection to stop Cobalt Strike in its current form?\nMost definitely.\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n\n### APPENDIX A: COVERAGE\n\n**STAGED/STAGELESS EXECUTABLES**\n\n**Snort**\n\n##### • 1:53656 MALWARE-OTHER Cobalt Strike x86\nexecutable download attempt\n\n##### • 1:53657 MALWARE-OTHER Cobalt Strike x86\nexecutable download attempt\n\n##### • 1:53658 MALWARE-OTHER Cobalt Strike x64\nexecutable download attempt\n\n##### • 1:53659 MALWARE-OTHER Cobalt Strike x64\nexecutable download attempt\n\n**ClamAV**\n\n##### • `Win.Trojan.CobaltStrike-7899871-1\n\n • `Win.Trojan.CobaltStrike-7899872-1\n\n**SCRIPTED WEB DELIVERY POWERSHELL**\n\n**Snort**\n\n##### • 1:45907 MALWARE-CNC Cobalt Strike DNS beacon\noutbound TXT record **(UPDATED)**\n\n##### • 1:45908 MALWARE-CNC Cobalt Strike DNS beacon\ninbound TXT record **(UPDATED)**\n\n##### • 1:53972 MALWARE-OTHER CobaltStrike beacon.dll\nDNS download attempt\n\n##### • 1:53973 MALWARE-OTHER CobaltStrike powershell\nweb delivery attempt\n\n##### • 1:53974 MALWARE-OTHER CobaltStrike powershell\nweb delivery attempt\n\n##### • 1:53975 INDICATOR-COMPROMISE CobaltStrike\nmultiple large DNS TXT query responses\n\n**ClamAV**\n\n##### • `Win.Trojan.Meterpreter-7385375-0`\n\n\n**BEACON BINARY PAYLOADS**\n\n**Snort**\n\n##### • 1:30229 INDICATOR-SHELLCODE Metasploit windows/\nshell stage transfer attempt **(UPDATED)**\n\n##### • 1:30471 INDICATOR-SHELLCODE Metasploit payload\nwindows_adduser **(UPDATED)**\n\n##### • 1:30480 INDICATOR-SHELLCODE INDICATORSHELLCODE Metasploit payload windows_x64_\nmeterpreter_reverse_https **(UPDATED)**\n\n##### • 1:53757 MALWARE-OTHER CobaltStrike beacon.dll\ndownload attempt\n\n##### • 1:53758 MALWARE-OTHER CobaltStrike beacon.dll\ndownload attempt\n\n**ClamAV**\n\n##### • Win.Trojan.MSShellcode-5\n\n • Win.Trojan.CobaltStrike-7913051-0\n\n**BEACON POWERSHELL PAYLOADS**\n\n**Snort**\n\n##### • 1:54095 MALWARE-OTHER Win.Trojan.CobaltStrike\npowershell beacon download attempt\n\n##### • 1:54096 MALWARE-OTHER Win.Trojan.CobaltStrike\npowershell beacon download attempt\n\n**ClamAV**\n\n##### • Win.Trojan.CobaltStrike-7917400-0\n\n**HTML APPLICATION (HTA) ATTACKS**\n\n**Snort**\n\n##### • 1:8068 BROWSER-PLUGINS Microsoft Windows\nScripting Host Shell ActiveX function call access\n\n##### • 1:54110 MALWARE-OTHER Html.Trojan.CobaltStrike\nHTML payload download attempt\n\n##### • 1:54111 MALWARE-OTHER Html.Trojan.CobaltStrike\n\n\n-----\n\n## e a t a d sc e ce o detect g Cobalt St e\n\n\nHTML payload download attempt\n\n##### • 1:54112 MALWARE-OTHER Html.Trojan.CobaltStrike\nHTML payload download attempt\n\n##### • 1:54113 MALWARE-OTHER Html.Trojan.CobaltStrike\nHTML payload download attempt\n\n##### • 1:54114 MALWARE-OTHER Html.Trojan.CobaltStrike\npowershell payload download attempt\n\n##### • 1:54115 MALWARE-OTHER Html.Trojan.CobaltStrike\npowershell payload download attempt\n\n##### • 1:54116 MALWARE-OTHER Html.Trojan.CobaltStrike\nVBA payload download attempt\n\n##### • 1:54117 MALWARE-OTHER Html.Trojan.CobaltStrike\nVBA payload download attempt\n\n**ClamAV**\n\n##### • Html.Trojan.CobaltStrike-7932561-0\n\n • Html.Trojan.CobaltStrike-7932562-0\n\n • Html.Trojan.CobaltStrike-7932563-0\n\n • Html.Trojan.CobaltStrike-7932564-0\n\n**COBALT STRIKE SIGNED APPLET ATTACK**\n\n**Snort**\n\n##### • 1:54169 MALWARE-OTHER Cobalt Strike signed java\napplet execution attempt\n\n##### • 1:54170 MALWARE-OTHER Cobalt Strike signed java\napplet execution attempt\n\n##### • 1:54171 MALWARE-OTHER Cobalt Strike signed java\napplet download attempt\n\n##### • 1:54172 MALWARE-OTHER Cobalt Strike signed java\napplet download attempt\n\n##### • 1:54173 MALWARE-OTHER Cobalt Strike signed java\napplet download attempt\n\n##### • 1:54174 MALWARE-OTHER Cobalt Strike signed java\napplet download attempt\n\n##### • 1:54175 INDICATOR-COMPROMISE Cobalt Strike\ndefault signed applet attack URI\n\n\n**ClamAV**\n\n##### • Win.Trojan.CobaltStrike-8001474-0\n\n • Win.Trojan.CobaltStrike-8001477-1\n\n**COBALT STRIKE SMART APPLET ATTACK**\n\n**Snort**\n\n##### • 1:54183 INDICATOR-COMPROMISE Cobalt Strike\ndefault smart applet attack URI\n\n**ClamAV**\n\n##### • Prior coverage signed applet submissions\n\n**COBALT STRIKE SYSTEM PROFILER ATTACK**\n\n**Snort**\n\n##### • 1:13913 BROWSER-PLUGINS AcroPDF.PDF ActiveX\nclsid access attempt **MAX DETECT**\n\n##### • 1:23878 BROWSER-PLUGINS Oracle JRE Deployment\nToolkit ActiveX clsid access attempt **MAX DETECT**\n\n##### • 1:38038 POLICY-OTHER PDF ActiveX CLSID access\ndetected **MAX DETECT**\n\n##### • 1:54180 MALWARE-OTHER Cobalt Strike system\nprofiling attempt\n\n##### • 1:54181 MALWARE-OTHER Cobalt Strike system\nprofiling attempt\n\n##### • 1:54182 MALWARE-OTHER Cobalt Strike system\nprofiling attempt\n\n**ClamAV**\n\n##### • Java.Malware.CobaltStrike-8008971-0\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2020/2020.09.11_Talos_-_The_art_and_science_of_detecting_Cobalt_Strike/2020.09.11_Talos_-_The_art_and_science_of_detecting_Cobalt_Strike.pdf"
    ],
    "report_names": [
        "2020.09.11_Talos_-_The_art_and_science_of_detecting_Cobalt_Strike"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f4f16213-7a22-4527-aecb-b964c64c2c46",
            "created_at": "2024-06-19T02:03:08.090932Z",
            "updated_at": "2025-03-27T02:05:17.387119Z",
            "deleted_at": null,
            "main_name": "GOLD NIAGARA",
            "aliases": [
                "Carbanak",
                "Carbon Spider ",
                "FIN7 ",
                "Navigator ",
                "Sangria Tempest ",
                "TelePort Crew ",
                "Calcium "
            ],
            "source_name": "Secureworks:GOLD NIAGARA",
            "tools": [
                " Carbanak",
                " Cobalt Strike",
                " DICELOADER",
                " DRIFTPIN",
                " GGLDR",
                " GRIFFON",
                " JSSLoader",
                " Meterpreter",
                " OFFTRACK",
                " PILLOWMINT",
                " POWERTRASH",
                " SUPERSOFT",
                " TAKEOUT",
                " TinyMet",
                "Bateleur"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "d85adfe3-e1c3-40b0-b8bb-d1bacadc4d82",
            "created_at": "2022-10-25T16:07:23.619566Z",
            "updated_at": "2025-03-27T02:02:09.890982Z",
            "deleted_at": null,
            "main_name": "FIN7",
            "aliases": [
                "APT-C-11",
                "ATK 32",
                "Gold Niagara",
                "ITG14",
                "TAG-CR1"
            ],
            "source_name": "ETDA:FIN7",
            "tools": [
                "7Logger",
                "Agentemis",
                "Anunak",
                "Astra",
                "BIOLOAD",
                "BIRDWATCH",
                "Bateleur",
                "Boostwrite",
                "CROWVIEW",
                "Carbanak",
                "Cobalt Strike",
                "CobaltStrike",
                "DICELOADER",
                "DNSMessenger",
                "FOWLGAZE",
                "HALFBAKED",
                "JSSLoader",
                "KillACK",
                "LOADOUT",
                "Lizar",
                "Meterpreter",
                "Mimikatz",
                "POWERPLANT",
                "POWERSOURCE",
                "RDFSNIFFER",
                "SQLRAT",
                "Sekur",
                "Sekur RAT",
                "TEXTMATE",
                "Tirion",
                "VB Flash",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "c39b0fe6-5642-4717-9a05-9e94265e3e3a",
            "created_at": "2022-10-25T16:07:24.332084Z",
            "updated_at": "2025-03-27T02:02:10.175452Z",
            "deleted_at": null,
            "main_name": "Tonto Team",
            "aliases": [
                "Bronze Huntley",
                "CactusPete",
                "Earth Akhlut",
                "HartBeat",
                "Karma Panda",
                "LoneRanger",
                "Operation Bitter Biscuit",
                "TAG-74",
                "Tonto Team"
            ],
            "source_name": "ETDA:Tonto Team",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "Bioazih",
                "Bisonal",
                "CONIME",
                "Dexbia",
                "Korlia",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Mimikatz",
                "POISONPLUG.SHADOW",
                "RoyalRoad",
                "ShadowPad Winnti",
                "XShellGhost"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716505,
    "ts_updated_at": 1743041609,
    "ts_creation_date": 1599816335,
    "ts_modification_date": 1599816336,
    "files": {
        "pdf": "https://archive.orkl.eu/6370087a176d2e536888fde5dfd0478d2675ead6.pdf",
        "text": "https://archive.orkl.eu/6370087a176d2e536888fde5dfd0478d2675ead6.txt",
        "img": "https://archive.orkl.eu/6370087a176d2e536888fde5dfd0478d2675ead6.jpg"
    }
}