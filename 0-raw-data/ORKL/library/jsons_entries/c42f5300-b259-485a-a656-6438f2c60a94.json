{
    "id": "c42f5300-b259-485a-a656-6438f2c60a94",
    "created_at": "2023-01-12T14:59:33.690206Z",
    "updated_at": "2025-03-27T02:09:30.069791Z",
    "deleted_at": null,
    "sha1_hash": "aa2b33b8b7903a757e1dbae3976acb2b1289c5f2",
    "title": "2020-09-17 - Automatic ReZer0 payload and configuration extraction",
    "authors": "",
    "file_creation_date": "2022-05-28T03:50:49Z",
    "file_modification_date": "2022-05-28T03:50:49Z",
    "file_size": 122561,
    "plain_text": "# Automatic ReZer0 payload and configuration extraction\n\n**[maxkersten.nl/binary-analysis-course/analysis-scripts/automatic-rezer0-payload-and-configuration-extraction/](https://maxkersten.nl/binary-analysis-course/analysis-scripts/automatic-rezer0-payload-and-configuration-extraction/)**\n\n#### This article was published on the 17th of September 2020. This article was updated on the 8th of December 2021.\n\n Understanding how a loader works shortens the time an analyst needs when it is encountered again. It also allows an analyst to create detection rules. This is, however, still manual work. Automating the extraction of the payload and possible configuration of a loader is the ideal scenario. This article covers the automatic extraction of both, based on the ReZer0 loader analysis which was analysed earlier on in this course.\n\n As a follow-up article, I dug deep into this loader’s details, as well as historical versions, can be found on McAfee’s Advanced Research Team’s blog.\n\n## Table of contents\n\n The approach\n\n#### As is described in the analysis, the loader’s payload is stored within a private static byte array, whereas the configuration is stored in a private static string array. The required fields are populated based on the string array, which the loader then uses to determine which functions need to be executed.\n\n Within the Dot Net framework, the Assembly class can be used to interact with classes, functions, and fields within a Dot Net binary.\n\n Note that both required fields are static, meaning they are assigned their value when the file is loaded. As such, one can iterate over the private static fields within all classes, as the variable and class names are randomised per sample. Once a byte array or string array is found, additional checks can be performed. If these checks are passed, one can store the payload on the disk and print the loader’s configuration.\n\n## Writing the extractor\n\n#### Based on prior research, the payload is an executable, meaning one can assume it starts with the MZ header. The size of the string array is 37, meaning all other string arrays can be ignored. These checks, especially the second one, may change in the future. If this is the case, or to avoid missing future samples, one could dump all occurrences that are encountered. The code is given in pieces, where each part is explained in the usual step-by- step manner.\n\n\n-----\n\n### Configuring the project\n\n#### The extractor will be written in C# using Visual Studio 2019. Other versions should work as well, but might require different or additional steps. After making a console application, one has to edit the App.config file to allow the project to load code from remote sources. The code snippet to add to the configuration file is given below.\n```\n<runtime>\n  <loadFromRemoteSources enabled=\"true\"/>\n</runtime>\n\n The reason as to why this is required, is the code that is executed within the ReZer0 loader when it is loaded. This is also the exact functionality on which the extractor is based.\n\n### The main function\n\n#### To easily extract payloads from loaders in bulk, this extractor will go over each file in a given directory. As such, the program requires a single command-line argument: the path to a folder that contains the loaders that are to be analysed. Tests of this program as a whole were done based upon on the 215 samples that were found during prior research. The main function is given below.\nstatic void Main(string[] args)\n{\n     //Get all files in the given folder\n     string[] files = Directory.GetFiles(args[0]);\n     //Loop through all files in the given folder\n     foreach (string file in files)\n     {\n          //Handle each file\n          HandleFile(file);\n     }\n     //Keep the window open once all files have been iterated through\n     Console.ReadKey();\n}\n\n### Extracting the payload\n\n#### To extract the payload, one must load the loader sample as an assembly in C#. This does not execute the entry point of the binary, which is essential in this case. Do note that technically, all static code is executed by loading the binary. Once the loader sample is loaded, one needs to go over all classes, as the class name that contains the payload is unknown. For each class, one wants to obtain all private static fields, since the payload is defined as such. The type of the field is then matched for each encountered field. If the payload contains MZ as the first two bytes, it is safe to assume that the payload has been found. Writing it to the disk then preserves the decrypted payload. The payload is already\n\n```\n\n-----\n\n#### decrypted, as it is a static field in the loader, meaning the value is given to the field once the executable is loaded, and prior to the execution of the main function. The code to do so is given below.\n```\n//Load the ReZer0 loader file\nAssembly assembly = Assembly.LoadFile(file);\n//Loop over all classes\nforeach (Type type in assembly.GetTypes())\n{\n     //Get all nonpublic static fields from each class\n     FieldInfo[] fields = type.GetFields(BindingFlags.NonPublic |\nBindingFlags.Static);\n     //Loop over all fields\n     foreach (FieldInfo fieldInfo in fields)\n     {\n          //Get the value of each field, as the name is randomised for the\nloader\n          object value = fieldInfo.GetValue(null);\n          //If the type of the current field's value is a byte array, its the\npayload, as there is only 1 embedded in the class\n          if (value is Byte[])\n          {\n              //Create a local variable to more easily handle it\n              byte[] payload = (byte[])value;\n              //Verify that the byte array is a PE file\n              if (payload[0] == 0x4d && payload[1] == 0x5a)\n              {\n                   //Write the payload to the disk\n                   File.WriteAllBytes(file + \"_extracted\", payload);\n                   Console.WriteLine(\"Wrote payload to disk as \" + file\n+ \"_extracted\");\n                   Console.WriteLine(\"Payload size: \" + payload.Length +\n\" bytes\");\n              }\n          }\n\n### Extracting the configuration\n\n#### To extract the configuration array, one can use the same loop to iterate through all fields. In this case, the requested field type is a string array. If the type matches, and the length is equal to 37, which is the length that is used for the configuration array in the loader, one can assume the configuration array has been found. All that rests then, is to print the configuration value with their corresponding settings. The knowledge based on this is based on the previous research into this loader. The code for the configuration extraction is given below.\n\n```\n\n-----\n\n```\n//If the value type is a string array, it means that the raw configuration values of\nthe loader\nif (value is String[])\n{\n     //Create a local variable based on the value, casting the type safely due to\nthe previous if-statement\n     String[] settings = (String[])value;\n     //If the length of the string array is equal to 37, it is safe to assume that\nthe configuration array has been found\n     //The length is based on prior research\n     if (settings.Length == 37)\n     {\n          //Create and instantiate the output string\n          String output = \"Payload launch method: \";\n          //Get the launch enum value\n          int launchEnum = Conversions.ToInteger(settings[0]);\n          //If the launch enum value is equal to 4, the payload is launched\ndirectly\n          if (launchEnum == 4)\n          {\n              output += \"launch from loader's memory\";\n          }\n          //In other cases, it executes the payload via a hollowed process\n          else\n          {\n              output += \"process hollowing into \";\n              //Depending on the value, the loader uses a specific process\n              if (launchEnum == 0)\n              {\n                   output += \"the loader's process\";\n              }\n              else if (launchEnum == 1)\n              {\n                   output += \"MSBuild.exe\";\n              }\n              else if (launchEnum == 2)\n              {\n                   output += \"vbc.exe\";\n              }\n              else if (launchEnum == 3)\n              {\n                   output += \"RegSvcs.exe\";\n              }\n          }\n          //Add a newline for readability\n          output += \"\\n\";\n          //Get the value of the scheduled task setting\n          int shouldSetScheduledTask = Conversions.ToInteger(settings[1]);\n          //Print the scheduled task value\n          output += \"Sets a scheduled task: \" + shouldSetScheduledTask + \"\\n\";\n          //Get the remote payload execution setting's value\n          int shouldExecuteRemotePayload = Conversions.ToInteger(settings[4]);\n\n```\n\n-----\n\n```\n          //Display the value\n          output += \"Executes remote payload: \" + shouldExecuteRemotePayload +\n\"\\n\";\n          //if the setting is enabled, the specific settings are read and\nprinted\n          if (shouldExecuteRemotePayload == 1)\n          {\n              string url = settings[5];\n              string downloadedFileName = settings[6];\n              output += \"URL: \" + url + \"\\n\";\n              output += \"File name on victim's machine: \" +\ndownloadedFileName + \"\\n\";\n          }\n          //Gets the anti-virtualisation detection setting\n          int shouldDetectVirtualEnvironments =\nConversions.ToInteger(settings[7]);\n          //Prints the setting\n          output += \"Exits when in a virtual environment: \" +\nshouldDetectVirtualEnvironments + \"\\n\";\n          //Gets the anti-sandbox setting\n          int shouldDetectSandboxes = Conversions.ToInteger(settings[8]);\n          //Prints the setting\n          output += \"Exits when in a sandboxes: \" + shouldDetectSandboxes +\n\"\\n\";\n          //Gets the messabox display setting\n          int shouldDisplayMessageBox = Conversions.ToInteger(settings[29]);\n          //Prints the setting's value\n          output += \"Displays messagebox: \" + shouldDisplayMessageBox + \"\\n\";\n          //If the setting is enabled, all details are printed\n          if (shouldDisplayMessageBox == 1)\n          {\n              string messageBoxTitle = settings[30];\n              string messageBoxText = settings[31];\n              int messageBoxButtonsStyle =\nConversions.ToInteger(settings[32]);\n              int messageBoxIconStyle =\nConversions.ToInteger(settings[33]);\n              output += \"\\tTitle: \" + messageBoxTitle + \"\\n\";\n              output += \"\\tText: \" + messageBoxText + \"\\n\";\n              output += \"\\tButtons style: \" + messageBoxButtonsStyle +\n\"\\n\";\n              output += \"\\tIcon style: \" + messageBoxIconStyle + \"\\n\";\n          }\n          //Get the sleep setting\n          int sleepTime = Conversions.ToInteger(settings[34]);\n          //Print the setting\n          output += \"Uses sleep to evade detection: \" + sleepTime + \"\\n\";\n          //If the setting is enabled, the sleep duration is also printed\n          if (sleepTime == 1)\n          {\n              int sleepDuration = Conversions.ToInteger(settings[35]);\n\n```\n\n-----\n\n```\n              output + Sleeps for + sleepDuration + seconds\\n ;\n          }\n          //Add a newline for readability\n          output += \"\\n\";\n          Console.WriteLine(output);\n     }\n}\n\n### Running the extractor\n\n#### Upon putting all the pieces together, one can run the program to iterate all files within a folder. In this test, the files were located at C:\\. The output of the extractor for several files is given below.\nParsing C:\\01a083f468e17d5da38d15907e26a71ce4ec6ee575aa5069e090e3d325f855ce\nWrote payload to disk as\nC:\\01a083f468e17d5da38d15907e26a71ce4ec6ee575aa5069e090e3d325f855ce_extracted\nPayload size: 150016 bytes\nPayload launch method: process hollowing into MSBuild.exe\nSets a scheduled task: 0\nExecutes remote payload: 0\nExits when in a virtual environment: 0\nExits when in a sandboxes: 0\nDisplays messagebox: 0\nUses sleep to evade detection: 0\nParsing C:\\03c27b0f45e222123d76ed5a54538bb27ae2739644567985c8f52216b783116d\nWrote payload to disk as\nC:\\03c27b0f45e222123d76ed5a54538bb27ae2739644567985c8f52216b783116d_extracted\nPayload size: 774144 bytes\nPayload launch method: process hollowing into the loader's process\nSets a scheduled task: 1\nExecutes remote payload: 0\nExits when in a virtual environment: 1\nExits when in a sandboxes: 1\nDisplays messagebox: 0\nUses sleep to evade detection: 0\nParsing C:\\03cb9a030d70871b55b2b60be423496a52d536dbd07a94b5597d7395cd0ec130\nWrote payload to disk as\nC:\\03cb9a030d70871b55b2b60be423496a52d536dbd07a94b5597d7395cd0ec130_extracted\nPayload size: 126976 bytes\nPayload launch method: process hollowing into vbc.exe\nSets a scheduled task: 1\nExecutes remote payload: 0\nExits when in a virtual environment: 0\nExits when in a sandboxes: 0\nDisplays messagebox: 0\nUses sleep to evade detection: 1\nSleeps for 10 seconds\n\n```\n\n-----\n\n## Conclusion\n\n#### Based on the analysis and the usage of reflection within the Dot Net framework, it is possible to extract the required data from a given ReZer0 loader without executing it. Changing the encryption (and therefore the decryption) routine does not make a difference in this scenario, as the fields are already assigned a value once the file is loaded, effectively bypassing the complete encryption module of the loader.\n\n## Extractor code\n\n#### The complete code for the extractor is given below. Keep the aforementioned App.config changes in mind, and import the Visual Basic reference correctly in order to make the code work.\n\n\n-----\n\n```\nusing System;\nusing System.IO;\nusing System.Reflection;\nusing Microsoft.VisualBasic.CompilerServices;\nnamespace ReZer0_extractor\n{\n  /// <summary>\n  /// ReZer0 payload and settings extractor by Max 'Libra' Kersten (@Libranalysis\non Twitter, https://maxkersten.nl)\n  /// Licensed under GPLv3 (https://www.gnu.org/licenses/gpl-3.0.en.html)\n  /// </summary>\n  class Program\n  {\n    /// <summary>\n    /// Extracts the payload from the loader to a file with the same name with\n\"_extracted\" appended to it.\n    /// The config of the loader is printed to the console.\n    /// </summary>\n    /// <param name=\"file\"></param>\n    static void HandleFile(string file)\n    {\n      //Print the file path to indicate which file is being processed\n      Console.WriteLine(@\"Parsing \" + file);\n      //Load the ReZer0 loader file\n      Assembly assembly = Assembly.LoadFile(file);\n      //Loop over all classes\n      foreach (Type type in assembly.GetTypes())\n      {\n        //Get all nonpublic static fields from each class\n        FieldInfo[] fields = type.GetFields(BindingFlags.NonPublic |\nBindingFlags.Static);\n        //Loop over all fields\n        foreach (FieldInfo fieldInfo in fields)\n        {\n          //Get the value of each field, as the name is randomised for the\nloader\n          object value = fieldInfo.GetValue(null);\n          //If the type of the current field's value is a byte array, its\nthe payload, as there is only 1 embedded in the class\n          if (value is Byte[])\n          {\n            //Create a local variable to more easily handle it\n            byte[] payload = (byte[])value;\n            //Verify that the byte array is a PE file\n            if (payload[0] == 0x4d && payload[1] == 0x5a)\n            {\n              //Write the payload to the disk\n              File.WriteAllBytes(file + \"_extracted\", payload);\n              Console.WriteLine(\"Wrote payload to disk as \" + file +\n\"_extracted\");\n              Console.WriteLine(\"Payload size: \" + payload.Length + \"\nbytes\");\n            }\n\n```\n\n-----\n\n```\n          }\n          //If the value type is a string array, it means that the raw\nconfiguration values of the loader\n          if (value is String[])\n          {\n            //Create a local variable based on the value, casting the\ntype safely due to the previous if-statement\n            String[] settings = (String[])value;\n            //If the length of the string array is equal to 37, it is\nsafe to assume that the configuration array has been found\n            //The length is based on prior research\n            if (settings.Length == 37)\n            {\n              //Create and instantiate the output string\n              String output = \"Payload launch method: \";\n              //Get the launch enum value\n              int launchEnum = Conversions.ToInteger(settings[0]);\n              //If the launch enum value is equal to 4, the payload is\nlaunched directly\n              if (launchEnum == 4)\n              {\n                output += \"launch from loader's memory\";\n              }\n              //In other cases, it executes the payload via a hollowed\nprocess\n              else\n              {\n                output += \"process hollowing into \";\n                //Depending on the value, the loader uses a specific\nprocess\n                if (launchEnum == 0)\n                {\n                  output += \"the loader's process\";\n                }\n                else if (launchEnum == 1)\n                {\n                  output += \"MSBuild.exe\";\n                }\n                else if (launchEnum == 2)\n                {\n                  output += \"vbc.exe\";\n                }\n                else if (launchEnum == 3)\n                {\n                  output += \"RegSvcs.exe\";\n                }\n              }\n              //Add a newline for readability\n              output += \"\\n\";\n              //Get the value of the scheduled task setting\n              int shouldSetScheduledTask =\nConversions.ToInteger(settings[1]);\n              //Print the scheduled task value\n\n```\n\n-----\n\n```\n              output + Sets a scheduled task: +\nshouldSetScheduledTask + \"\\n\";\n              //Get the remote payload execution setting's value\n              int shouldExecuteRemotePayload =\nConversions.ToInteger(settings[4]);\n              //Display the value\n              output += \"Executes remote payload: \" +\nshouldExecuteRemotePayload + \"\\n\";\n              //if the setting is enabled, the specific settings are\nread and printed\n              if (shouldExecuteRemotePayload == 1)\n              {\n                string url = settings[5];\n                string downloadedFileName = settings[6];\n                output += \"URL: \" + url + \"\\n\";\n                output += \"File name on victim's machine: \" +\ndownloadedFileName + \"\\n\";\n              }\n              //Gets the anti-virtualisation detection setting\n              int shouldDetectVirtualEnvironments =\nConversions.ToInteger(settings[7]);\n              //Prints the setting\n              output += \"Exits when in a virtual environment: \" +\nshouldDetectVirtualEnvironments + \"\\n\";\n              //Gets the anti-sandbox setting\n              int shouldDetectSandboxes =\nConversions.ToInteger(settings[8]);\n              //Prints the setting\n              output += \"Exits when in a sandboxes: \" +\nshouldDetectSandboxes + \"\\n\";\n              //Gets the messabox display setting\n              int shouldDisplayMessageBox =\nConversions.ToInteger(settings[29]);\n              //Prints the setting's value\n              output += \"Displays messagebox: \" +\nshouldDisplayMessageBox + \"\\n\";\n              //If the setting is enabled, all details are printed\n              if (shouldDisplayMessageBox == 1)\n              {\n                string messageBoxTitle = settings[30];\n                string messageBoxText = settings[31];\n                int messageBoxButtonsStyle =\nConversions.ToInteger(settings[32]);\n                int messageBoxIconStyle =\nConversions.ToInteger(settings[33]);\n                output += \"\\tTitle: \" + messageBoxTitle + \"\\n\";\n                output += \"\\tText: \" + messageBoxText + \"\\n\";\n                output += \"\\tButtons style: \" +\nmessageBoxButtonsStyle + \"\\n\";\n                output += \"\\tIcon style: \" + messageBoxIconStyle +\n\"\\n\";\n\n```\n\n-----\n\n```\n              }\n              //Get the sleep setting\n              int sleepTime = Conversions.ToInteger(settings[34]);\n              //Print the setting\n              output += \"Uses sleep to evade detection: \" + sleepTime +\n\"\\n\";\n              //If the setting is enabled, the sleep duration is also\nprinted\n              if (sleepTime == 1)\n              {\n                int sleepDuration =\nConversions.ToInteger(settings[35]);\n                output += \"Sleeps for \" + sleepDuration + \"\nseconds\\n\";\n              }\n              //Add a newline for readability\n              output += \"\\n\";\n              Console.WriteLine(output);\n            }\n          }\n        }\n      }\n    }\n    /// <summary>\n    /// ReZer0 payload and settings extractor by Max 'Libra' Kersten\n(@Libranalysis on Twitter, https://maxkersten.nl)\n    /// Licensed under GPLv3 (https://www.gnu.org/licenses/gpl-3.0.en.html)\n    /// </summary>\n    static void Main(string[] args)\n    {\n      //Get all files in the given folder\n      string[] files = Directory.GetFiles(args[0]);\n      //Loop through all files in the given folder\n      foreach (string file in files)\n      {\n        //Handle each file\n        HandleFile(file);\n      }\n      //Keep the window open once all files have been iterated through\n      Console.ReadKey();\n    }\n  }\n}\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-09-17 - Automatic ReZer0 payload and configuration extraction.pdf"
    ],
    "report_names": [
        "2020-09-17 - Automatic ReZer0 payload and configuration extraction.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535573,
    "ts_updated_at": 1743041370,
    "ts_creation_date": 1653709849,
    "ts_modification_date": 1653709849,
    "files": {
        "pdf": "https://archive.orkl.eu/aa2b33b8b7903a757e1dbae3976acb2b1289c5f2.pdf",
        "text": "https://archive.orkl.eu/aa2b33b8b7903a757e1dbae3976acb2b1289c5f2.txt",
        "img": "https://archive.orkl.eu/aa2b33b8b7903a757e1dbae3976acb2b1289c5f2.jpg"
    }
}