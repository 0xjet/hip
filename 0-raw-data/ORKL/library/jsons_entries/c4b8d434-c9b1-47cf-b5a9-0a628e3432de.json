{
    "id": "c4b8d434-c9b1-47cf-b5a9-0a628e3432de",
    "created_at": "2022-10-25T16:48:13.229966Z",
    "updated_at": "2025-03-27T02:15:41.765709Z",
    "deleted_at": null,
    "sha1_hash": "4380f06f404326f756a7c48cb7dd0236e1934cb0",
    "title": "Reverse-engineering DUBNIUM's Flash-targeting exploit",
    "authors": "Microsoft",
    "file_creation_date": "2016-06-30T20:26:47Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 644361,
    "plain_text": "**blogs.technet.microsoft.com/mmpc/2016/06/20/reverse-engineering-dubniums-flash-targeting-exploit/**\n\nJune 20, 2016\n\nThe DUBNIUM campaign in December involved one exploit in-the-wild that affected Adobe Flash Player. In this blog,\n[we’re going to examine the technical details of the exploit that targeted vulnerability CVE-2015-8651. For more details](http://www.cvedetails.com/cve/CVE-2015-8651/)\n[on this vulnerability, see Adobe Security Bulletin APSB16-01 .](https://helpx.adobe.com/security/products/flash-player/apsb16-01.html)\n\nNote that Microsoft Edge on Windows 10 was protected from this attack due to the mitigations introduced into the\nbrowser.\n\n## Vulnerability exploitation\n\n### Adobe Flash Player version checks\n\nThe nature of the vulnerability is an integer overflow, and the exploit code has quite extensive subroutines in it. It tries\nto cover versions of the player from 11.x to the most recent version at the time of the campaign, 20.0.0.235.\n\nThe earliest version of Adobe Flash Player 11.x was released in October 2011 (11.0.1.152) and the last version of\nAdobe Flash Player 10.x was released in June 2013 (10.3.183.90). This doesn’t necessarily mean the exploit existed\nfrom 2011 or 2013, but it again demonstrates the broad target the exploit tries to cover.\n\n\nFigure 1 Version check for oldest Flash Player the exploit targets\n\n\nMainly we focused our analysis upon the function named qeiofdsa, as the routine covers any Adobe Flash player\nversion since 19.0.0.185 (released on September 21, 2015).\n\n\n-----\n\nFigure 2 Version check for latest Flash Player the exploit supports\n\n\nWhy is this version of Flash Player so important? Because that is the release which had the latest Vector length\ncorruption hardening applied at the time of the incident. The original Vector length hardening came with 18.0.0.209\nand it is well explained in the Security @ Adobe blog https://blogs.adobe.com/security/2015/12/communitycollaboration-enhances-flash.html.\n\nThe Vector object from Adobe Flash Player can be used as a corruption target to acquire read or write (RW) primitives.\n\nThis object has a very simple object structure and predictable allocation patterns without any sanity checks on the\nobjects. This made this object a very popular target for exploitation for recent years. There were a few more bypasses\nfound after that hardening, and 19.0.0.185 had another bypass hardening. The exploit uses a new exploitation method\n(ByteArray length corruption) since this new version of Adobe Flash Player.\n\nNote, however, that with new mitigation from Adobe released after this incident, the _ByteArray length corruption_\nmethod no longer works.\n\nTo better understand the impact of the mitigations on attacker patterns, we compared exploit code line counts for the\n_pdfsajoe routine, which exploits Adobe Flash Player versions earlier than 19.0.0.185, to the_ _qeiofdsa routine, which_\nexploits versions after 19.0.0.185. We learned that pdfsajoe has 139 lines of code versus qeiofdsa with 5,021.\n\nWhile there is really no absolute way to measure the impact and line code alone is not a standard measurement, we\nknow that in order to target the newer versions of Adobe Flash Player, the attacker would have to write 36 more times\nthe lines of code.\n\n**Subroutine name** **_pdfsajoe_** **_qeiofdsa_**\n\n**Vulnerable Flash Player version** Below 19.0.0.185 19.0.0.185 and up\n\n**Mitigations** No latest Vector mitigations Latest Vector mitigations applied\n\n**Lines of attack code** 139 lines 5,021 lines\n\n**Ratio** 1 36\n\n\n-----\n\nThis tells us a lot about the importance of mitigation and the increasing cost of exploit code development. Mitigation in\nitself doesn’t fix existing vulnerabilities, but it is definitely raising the bar for exploits.\n\n### Heap spraying and vulnerability triggering\n\nThe exploit heavily relies on heap spraying. Among heap spraying of various objects, the code from Figure 3 shows\nthe code where the ByteArray objects are sprayed. This ByteArray has length of 0x10. These sprayed objects are\ncorruption targets.\n\nThe vulnerability lies in the implementation of fast\nmemory opcodes. More detailed information on the\nusage of fast memory opcodes are available in the\n_Faster byte array operations with ASC2_ article at the\nAdobe Developer Center.\n\nAfter setting up application domain memory, the code\n\nFigure 3 Heap-spraying code\n\ncan use avm2.intrinsics.memory. The package\nprovides various methods including li32 and si32\ninstructions. The li32 can be used to load 32bit integer values from fast memory and _si32 can be used to store 32bit_\ninteger values to fast memory. These functions are used as methods, but in the AVM2 bytecode level, they are opcode\nthemselves.\n\n\nFigure 4 Setting up application domain memory\n\n\nDue to the way these instructions are implemented, the out-of-bounds access vulnerability happens (Figure 5). The\nkey to this vulnerability is the second li32 statement just after first li32 one in each IF statement. For example, from\nthe li32((_local_4+0x7FEDFFD8)) statement, the _local_4+0x7FEDFFD8 value ends up as 4 after integer overflow.\nFrom the just-in-time (JIT) level, the range check is only generated for this li32 statement, skipping the range check\nJIT code for the first li32 statement.\n\n\n-----\n\nFigure 5 Out-of-bounds access code using li32 instructions\n\n\nWe compared the bytecode level AVM2 instructions with the low-level x86 JIT instructions. Figure 6 shows the\ncomparisons and our findings. Basically two li32 accesses are made and the JIT compiler optimizes length check for\nboth li32 instructions and generates only one length check. The problem is that integer overflow happens and the\nlength check code becomes faulty and allows bypasses of ByteArray length restrictions. This directly ends with out-ofbounds RW access of the process memory. Historically, fast memory implementation suffered range check\nvulnerabilities (CVE-2013-5330, CVE-2014-0497). The Virus Bulletin 2014 paper by Chun Feng and Elia Florio,\n_[Ubiquitous Flash, ubiquitous exploits, ubiquitous mitigation (PDF download), provides more details on other old but](https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-FengFlorio.pdf)_\nsimilar vulnerabilities.\n\n\n-----\n\nFigure 6 Length check confusion\n\n\nUsing this out-of-bounds vulnerability, the exploit tries to locate heap-sprayed objects.\n\nThese are the last part of memory sweeping code. We counted 95 IF/ELSE statements that sweep through memory\nrange from ba+0x121028 to ba+0x17F028 (where ba is the base address of fast memory), which is 0x5E000\n(385,024) byte size. Therefore, these memory ranges are very critical for this exploit’s successful run.\n\n\n-----\n\nFigure 7 End of memory sweeping code\n\n\nFigure 8 shows a crash point where the heap spraying fails. The exploit heavily relies on a specific heap layout for\nsuccessful exploitation, and the need for heap spraying is one element that makes this exploit unreliable.\n\n\nFigure 8 Out-of-bounds memory access\n\n\nThis exploit uses a corrupt ByteArray.length field and uses it as RW primitives (Figure 9).\n\n\nFigure 9 Instruction si32 is used to corrupt ByteArray.length field\n\n\nAfter ByteArray.length corruption, it needs to determine which ByteArray is corrupt out of the sprayed ByteArrays\n(Figure 10).\n\n\n-----\n\nFigure 10 Determining corrupt ByteArray\n\n\n### RW primitives\n\nThe following shows various RW primitives that this exploit code provides. Basically these extensive lists of methods\nprovide functions to support different application and operating system flavors.\n\n\nFigure 11 RW primitives\n\n\nFor example, the read32x86 method can be used to read an arbitrary process’s memory address on x86 platform. The\n_cbIndex variable is the index into the bc array which is an array of the_ _ByteArray type. The bc[cbIndex] is the specific_\n_ByteArray that is corrupted through the fast memory vulnerability. After setting virtual address as position member, it_\nuses the readUnsignedInt method to read the memory value.\n\n\n-----\n\nFigure 12 Read primitive\n\n\nThe same principle applies to the write32x86 method. It uses the writeUnsignedInt method to write to arbitrary memory\nlocation.\n\n\nFigure 13 Write primitive\n\n\nAbove these, the exploit can perform a slightly complex operation like reading multiple bytes using the readBytes\nmethod.\n\n\nFigure 14 Byte reading primitive\n\n\n## Function object virtual function table corruption\n\nJust after acquiring the process’s memory RW ability, the exploit tries to get access to code execution. This exploit\n\n\n-----\n\nleak. Figure 15 shows how the Function object s virtual function table pointer (vptr) is acquired through a leaked object\naddress, and low-level object offset calculations are performed. The offsets used here are relevant to the Adobe Flash\nPlayer’s internal data structure and how they are linked together in the memory.\n\n\nFigure 15 Resolving Function object vptr address\n\n\nThis leaked virtual function table pointer is later overwritten with a fake virtual function table’s address. The fake virtual\nfunction table itself is cloned from the original one and the only pointer to apply method is replaced with the\n_VirtualProtect API. Later, when the apply method is called upon the dummy function object, it will actually call the_\n_VirtualProtect API with supplied arguments – not the original empty call body. The supplied arguments are pointing to_\nthe memory area that is used for temporary shellcode storage. The area is made read/write/executable (RWX)\nthrough this method.\n\n\n-----\n\nFigure 16 Call VirtualProtect through apply method\n\n\nOnce the RWX memory area is reserved, the exploit uses the call method of the Function object to perform further\ncode execution. It doesn’t use the apply method because it no longer needs to pass any arguments. Calling the _call_\nmethod is also simpler (Figure 17).\n\n\nFigure 17 Shellcode execution through call method\n\n\nThis shellcode-running routine is highly modularized and you can actually use API names and arguments to be passed\nto the shellcode-running utility function. This makes shellcode building and running very extensible. Again, this method\nhas close similarity with the code found with the Adobe Flash exploit leaked during the Hacking Team information leak\nin July 2015.\n\n\n-----\n\nFigure 18 Part of shellcode call routines\n\n\nNote that the exploit’s method of using the corrupted Function object virtual table doesn’t work on Microsoft Edge\nanymore as it has additional mitigation against these kinds of attacks.\n\n## ROP-less shellcode\n\nWith this exploit, shellcode is not just contiguous memory area, but various shellcodes are called through separate call\nmethods. As you can see from this exploit, we are observing more exploits operate without return-oriented\nprogramming (ROP) chains. We can track these calls by putting a breakpoint on the native code that performs the\nActionScript call method. For example, the disassembly in Figure 19 shows the code that calls the _InternetOpenUrlA_\nAPI call.\n\n\nFigure 19 InternetOpenUrlA 1st download\n\n\nThis call only retrieves some portion of a portable executable (PE) file’s header, but not the whole file. It will do another\n\nf th _I t_ _tO_ _U lA API_ ll t t i th i i b d f th l d Thi i t lik l t i k t f\n\n\n-----\n\nFigure 20 InternetOpenUrlA 2nd download\n\n## Conclusion\n\nWith the analysis of the Adobe Flash Player-targeting exploit used by DUBNIUM last December, we learned they are\nusing highly organized exploit code with extensive support of operating system flavors. However, some functionalities\nfor some operating system are not yet implemented. For example, some 64-bit support routines had an empty function\ninside them.\n\nThe way the shellcode is authored makes the exploit code very extensible and flexible as changing shellcode behavior\nis extremely simple – as much as just changing AS3 code lines.\n\nThe actual first stage payload download is not just performed by a single download but are split into two.\n\nThey also use the ByteArray.length corruption technique to achieve process memory RW access. There was a\nhardening upon this object just after this incident and ByteArray now has better sanity checks. Therefore, the same\ntechnique would not work as straightforwardly as in this exploit for the versions after the hardening.\n\nThe exploit relies heavily on heap-spraying techniques, and this is one major element that makes this exploit\nunreliable.\n\nThis is a good example of how mitigation undermines an exploit’s stability, and how it increases exploit development\ncost.\n\nDue to the exploitation method it relies on for the Function object corruption, with Microsoft Edge you have additional\nprotection over this new exploit method.\n\n_Jeong Wook Oh_\n_MMPC_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/rsvvnrm7ct991olqsvbqrie614xt9f3b"
    ],
    "report_names": [
        "Microsoft_RE-DUBNIUM-FlashExploit(06-20-2016)"
    ],
    "threat_actors": [
        {
            "id": "1dadf04e-d725-426f-9f6c-08c5be7da159",
            "created_at": "2022-10-25T15:50:23.624538Z",
            "updated_at": "2025-03-27T02:00:55.508759Z",
            "deleted_at": null,
            "main_name": "Darkhotel",
            "aliases": [
                "Darkhotel",
                "DUBNIUM",
                "Zigzag Hail"
            ],
            "source_name": "MITRE:Darkhotel",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "a3687241-9876-477b-aa13-a7c368ffda58",
            "created_at": "2022-10-25T16:07:24.496902Z",
            "updated_at": "2025-03-27T02:02:10.256629Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "ETDA:Hacking Team",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "e90c06e4-e3e0-4f46-a3b5-17b84b31da62",
            "created_at": "2023-01-06T13:46:39.018236Z",
            "updated_at": "2025-03-27T02:00:02.978356Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "MISPGALAXY:Hacking Team",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "b13c19d6-247d-47ba-86ba-15a94accc179",
            "created_at": "2024-05-01T02:03:08.149923Z",
            "updated_at": "2025-03-27T02:05:17.422065Z",
            "deleted_at": null,
            "main_name": "TUNGSTEN BRIDGE",
            "aliases": [
                "DUBNIUM ",
                "DarkHotel ",
                "CTG-1948 "
            ],
            "source_name": "Secureworks:TUNGSTEN BRIDGE",
            "tools": [
                "Nemim"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "2b4eec94-7672-4bee-acb2-b857d0d26d12",
            "created_at": "2023-01-06T13:46:38.272109Z",
            "updated_at": "2025-03-27T02:00:02.790029Z",
            "deleted_at": null,
            "main_name": "DarkHotel",
            "aliases": [
                "DUBNIUM",
                "Fallout Team",
                "Luder",
                "Tapaoux",
                "Shadow Crane",
                "APT-C-06",
                "SIG25",
                "Karba",
                "Nemim",
                "Nemin",
                "G0012",
                "ATK52",
                "T-APT-02",
                "TUNGSTEN BRIDGE",
                "Zigzag Hail"
            ],
            "source_name": "MISPGALAXY:DarkHotel",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c0cedde3-5a9b-430f-9b77-e6568307205e",
            "created_at": "2022-10-25T16:07:23.528994Z",
            "updated_at": "2025-03-27T02:02:09.847683Z",
            "deleted_at": null,
            "main_name": "DarkHotel",
            "aliases": [
                "APT-C-06",
                "ATK 52",
                "CTG-1948",
                "Dubnium",
                "Fallout Team",
                "Higaisa",
                "Luder",
                "Operation DarkHotel",
                "Operation Daybreak",
                "Operation Inexsmar",
                "Operation PowerFall",
                "Operation The Gh0st Remains the Same",
                "SIG25",
                "Shadow Crane",
                "T-APT-02",
                "Tungsten Bridge",
                "Zigzag Hail"
            ],
            "source_name": "ETDA:DarkHotel",
            "tools": [
                "Asruex",
                "DarkHotel",
                "DmaUp3.exe",
                "GreezeBackdoor",
                "Karba",
                "Nemain",
                "Nemim",
                "Ramsay",
                "Retro",
                "Tapaoux",
                "Trojan.Win32.Karba.e",
                "Virus.Win32.Pioneer.dx",
                "igfxext.exe",
                "msieckc.exe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716493,
    "ts_updated_at": 1743041741,
    "ts_creation_date": 1467318407,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/4380f06f404326f756a7c48cb7dd0236e1934cb0.pdf",
        "text": "https://archive.orkl.eu/4380f06f404326f756a7c48cb7dd0236e1934cb0.txt",
        "img": "https://archive.orkl.eu/4380f06f404326f756a7c48cb7dd0236e1934cb0.jpg"
    }
}