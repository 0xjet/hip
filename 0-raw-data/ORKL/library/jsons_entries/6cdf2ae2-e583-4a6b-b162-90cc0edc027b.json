{
    "id": "6cdf2ae2-e583-4a6b-b162-90cc0edc027b",
    "created_at": "2022-10-25T16:48:23.465054Z",
    "updated_at": "2025-03-27T02:09:29.233538Z",
    "deleted_at": null,
    "sha1_hash": "1be5425625872d882ea412b2c83b7cdf1d56da79",
    "title": "",
    "authors": "",
    "file_creation_date": "1999-11-01T10:22:04Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 140633,
    "plain_text": "# Environmental Key Generation towards Clueless Agents\n\nJames Riordan[⋆] Bruce Schneier\nSchool of Mathematics Counterpane Systems\nUniversity of Minnesota 101 E Minnehaha Parkway\nMinneapolis, MN 55455 Minneapolis, MN 55419, USA\n```\n     riordan@math.umn.edu schneier@counterpane.com\n\n```\n**Abstract. In this paper, we introduce a collection of cryptographic key**\nconstructions built from environmental data that are resistant to adversarial analysis and deceit. We expound upon their properties and discuss\nsome possible applications; the primary envisioned use of these constructions is in the creation of mobile agents whose analysis does not reveal\ntheir exact purpose.\n\n## 1 Introduction\n\nTraditional cryptographic systems rely upon knowledge of a secret key to decipher messages. One of the weaknesses induced by this reliance stems from the\nstatic nature of the secret keys: they do not depend upon temporal, spatial, or\noperational conditions. By contrast, the secrecy requirements of information are\noften strongly linked to these conditions. This disparity is, perhaps, most easily\nseen and most problematic in mobile agents.\n\nMobile agents, by nature, function in and move through a wide variety of environments. Security properties of these environments vary greatly which creates\nproblems when the mobile agent needs to carry security sensitive, or otherwise\nprivate, material. If the agent passes through an insecure network it may be\nanalyzed so that any information carried by the agent becomes available to the\nattacker.\n\nThis information is often private in nature, and cannot easily be disguised.\nFor example, an agent written to conduct a patent search will reveal the nature\nof the information desired. This information may, in turn, reveal the intentions\nof the requester of that patent search.\nThe problem is somewhat similar to the one faced by designers of smart cards\nwhich keep secrets from the card’s carrier. To solve that problem, smart card\ndesigners have developed a number of techniques to make the hardware either\ntamper-resistant or tamper-evident thereby protecting the secret. Unfortunately\nthese techniques are not applicable to mobile agents due to the fact that software,\nunlike hardware, is completely and trivially observable.\n\n_⋆_ The first author is now with the IBM Zurich Research Laboratory in Switzerland\n\n\n-----\n\nTo address this class of problem we introduce the notion of environmental\n_key generation: keying material that is constructed from certain classes of envi-_\nronmental data. Using these keys, agents could receive encrypted messages that\nthey could only decrypt if some environmental conditions were true. Agents with\ndata or executable code encrypted using such keys could remain unaware of their\npurpose until some environmental condition is met.[1]\n\nEnvironmental key generation is similar to the idea of ephemeral keys: keys\nwhich are randomly created at the time of use and destroyed immediately afterward. Public-key systems for encrypting telephone conversations—the STU-III\n\n[Mye94], the AT&T TSD [ATT92], the Station-to-Station protocol [DOW92]—\nmake use of this idea. The communication model is different, however. Ephemeral\nkeys are used when two parties want to communicate securely at a specific time,\neven though there is no secure channel available and the parties have not previously negotiated a shared secret key. Environmental key generation can be used\nwhen the sender wishes to communicate with the receiver, such that the receiver\ncould only receive the message if some environmental conditions are true. Environmental key generation can even be used in circumstances where the receiver\nis not aware of the specific environmental conditions that the sender wants his\ncommunication to depend on.\n\nThe difficulty with constructing an environmental key generation protocol is\nthat the threat model assumes that an attacker has complete control over the environment. All information available to the program is available to the attacker,\nall inputs to the program are supplied by the attacker and the program state\nitself is completely determined by the attacker. As such, the constructions must\nresist direct analysis and dictionary attacks in the form of Cartesian deception\n(in which the attacker lies about the environment).\n\nUltimately, if the attacker has access to both the agent and the activation\nenvironment (the environment in which the agent can construct its keys) then\nhe will have access to all secret information as well. This is often not a problem.\n\nIn this paper, we propose three basic approaches toward securely generating\ncryptographic keys from environmental observations. The first involves direct\nmanipulation of the environment in a specific and cryptographically unspoofable\nmanner. The second involves reliance upon a partially trusted server. The third\nuses the obfuscation of the nature or value of the environmental data being\nsought through the use of one-way functions.\n\n## 2 Clueless Agents\n\nIn the basic construction, an agent has a cipher-text message (a data set, a series\nof instructions, etc.) and a method for searching through the environment for\nthe data needed to generate the decryption key. When the proper environmental\n\n1 These agents might reasonable be likened to the sleeper agents of “The Manchurian\nCandidate” and other Cold War era spy films.\n\n2\n\n\n-----\n\ninformation is located, the key is generated, the cipher-text is decrypted, and\nthe resulting plain-text it acted upon. Without the environmentally supplied\ninput, the agent cannot decrypt its own message (i.e. it is clueless), and can be\nmade cryptographically resistant to analysis aimed at determining the agent’s\nfunction.\n\nLet N be an integer corresponding to an environmental observation, a one\n_H_\nway function, M the hash of the observation N needed for activation, the\n_H_ _⊕_\nbitwise exclusive-or operator, comma the catenation operator, R a nonce, & the\nbitwise and operator, and K a key. The value M is carried by the agent.\n\nOne way functions can be used to conduct tests and construct the keys in a\nway that examination of the agent does not reveal the required environmental\ninformation. A number of such constructions are possible:\n\n**– if** (N ) = M then let K := N\n_H_\n**– if** ( (N )) = M then let K := (N )\n_H_ _H_ _H_\n**– if H(Ni) = Mi then let K := H(N1, ..., Ni)**\n**– if H(N** ) = M then let K := H(R1, N )⊕R2\n\nThe constructions differ in types of data which are most naturally provided\nas input or in the programmer’s ability to determine the output (as needed by\na threshold scheme 6.2); the important feature of each is knowledge of M does\nnot provide knowledge of K.\n\nThis general sort of construction is not uncommon. The if clause of the first\nconstruction is used in most static encrypted password authentication schemes\n(e.g. Unix). As with static password schemes, dictionary attacks present a problem. The fact that an agent may pass through or even execute in a hostile environment compounds this problem greatly (as would publishing your password\nfile). None the less, several useful and cryptographically viable constructions are\npossible.\n\n## 3 Basic Constructions\n\nThe very simplest clueless agents look for their activation keys on a fixed data\nchannel. Example channels include:\n\n**– Usenet news groups. A key could be embedded in any of several places in**\na (possibly anonymous) posting to a particular newsgroup. It could be the\nhash of a particular message, or the hash of a certain part of the message.\n**– Web pages. Likewise, a key could be explicitly or steganographically embed-**\nded in a web page or image.\n**– Mail messages. The message could contain a particular string that would**\nserve as a key, or the key could be a hash of a message.\n**– File systems. A key could be located in a file, the hash of the file or the hash**\nof a particular file name.\n\n3\n\n\n-----\n\n**– Local network resources. A key could be generated as the hash of a local DNS**\nblock transfer or as a result of a broadcast ping packet. Threshold schemes\nwould be particularly valuable with\nschemes like this.\n\nIf, for example, the agent knows that its activation key will be posted to a\nparticular newsgroup, it would continuously scan the newsgroup looking for a\nmessage N such that ( (N )) = M . An attacker would know that N would be\n_H_ _H_\nposted to the newsgroup, but would need to see the message N before he could\nconstruct the key, ( (N )), and thus figure out the agent’s purpose.\n_H_\n\nThe nature of the data channel determines the utility and properties of the\nconstruction based upon that channel. This nature includes:\n\n**– Who can directly or indirectly observe the channel?**\n**– Who can manipulate parts or the whole of the channel?**\n**– Along what paths does the channel flow?**\n**– How do observations of the channel vary with the observer?**\n\nThis abstract notion is best explained by a few diverse examples.\n\n**3.1** **Example: Blind Search**\n\nWe take the data channel to be an online database containing a list of patents\nwith an online mechanism for executing search agents. The channel does not\nhave a particularly interesting nature but yet generates an interesting agent.\n\nWe suppose that Alice has the an idea that she would like to patent. She\nwishes to conduct a patent search yet does not wish to describe her idea to the\nowners of the database search engine. This desire can be realized through the\nuse of a clueless agent.\n\nTo make matters concrete, we assume that Alice’s idea is to build a smoke\ndetector with a “snooze alarm” so that she can temporarily de-activate the alarm\nwithout unplugging it.[2]\n\nShe begins by computing:\n\n1. N := a random nonce\n2. K := (“smoke detector with snooze alarm”),\n_H_\n3. M := EK(“report findings to alice@weaseldyne.com”), and\n4. O := (N “smoke detector with snooze alarm”).\n_H_ _⊕_\n\nShe then writes an agent which scans through the database taking hashes of\nfive word sequences\n\n2 This would be a very useful item for the kitchen; smoke alarm manufacturers take\nnote.\n\n4\n\n\n-----\n\n**– for five word sequence (x) in the database do**\n**– if H(N ⊕** (x)) = O then execute= DH(x)(M )\n\nThe agent can now search through the database for references to “smoke detector with snooze alarm” without actually carrying any information from which\n“smoke detector with snooze alarm” could be derived.\n\nIn this example, if the owner of the database is watching all search agents\nin an attempt to steal idea, he will only observe a description of Alice’s idea if\nhe already has a description of the idea. Methods of rendering this scheme less\nsensitive to different wordings are discussed in Section 6.\n\n**3.2** **Example: Intrusion Detection**\n\nOne of the most problematic aspects of intrusion detection is that wide scale\ndeployment of a particular method tends to limit its effectiveness. If an attacker\nhas detailed knowledge of the detections system installed at a particular site,\nhe is better able to avoid its triggers. As such, it would be better to deploy an\nintrusion detection system whose triggers are not easily analyzable. Environmental key generation could be used to encrypt sections of the intrusion detection’s\nexecutable code until such time as a particular attack is executed.\n\nWhile in this case the attacker could easily stage a dictionary attack by mimicking the LAN’s behavior, such a simulation would require extensive knowledge\nof the LAN. Acquisition of that knowledge would likely to trigger the detection\nsystem.\n\n**3.3** **Example: Network-Based Operation**\n\nIt is often desirable to have an agent which can only run in certain environments.\nThe agent may be collecting auditing data on certain types of machines or certain points in the network. It may need to carry out an electronic commerce\ntransaction, but only from within the network of a certain vendor.\n\nAn interesting, although malicious, application of this sort of construction\nwould the creation of a directed virus. Such a virus could carry a special set\nof special instructions which could only be run in a certain environment. The\nnovelty of this construction is that examination of the virus without explicit\nknowledge of the activation environment would not reveal its “special instructions”.\n\nWe suppose that Alice wishes to write a virus which should carry out the\ninstructions if it finds itself inside weaseldyne.com so that it would be infeasible to determine what the special instructions are without knowing it is keyed\nfor weaseldyne.com. Alice finds the name of a machine on the inside of weaseldyne.com’s network. She does so through some combination of examining mailing\nlist archives, social engineering, and assumptions about naming conventions (e.g.\nthere is often a theme).\n\n5\n\n\n-----\n\nWe will assume that the name of the machine is pooky.weaseldyne.com. She\ncomputes:\n\n1. K = (“pooky.weaseldyne.com[′′])\n_H_\n2. M = EK(“report findings to alice@competitor.com[′′])\n\nShe then writes a virus which, when activated, requests local DNS information\nand applies to each entry looking for its key.\n_H_\n\nIn this example, staging a dictionary attack is already quite difficult. Methods\nof making it yet more difficult are discussed in section 6.\n\n## 4 Time Constructions\n\nThe time-based constructions allow key generation based on the time. These\nconstructions rely upon the presence of a minimally trusted third party to prevent a date based dictionary attack. The third party is minimally trusted in the\nsense that it does not need to know either of the two parties nor does it need to\nknow the nature of the the material for which it generates keys. These protocols\nhave three distinct stages:\n\n1. The programmer-server interaction, where the programmer gets an encryption key from the server.\n2. The programmer-agent interaction, where the programmer gives the agent\nthe encrypted message, some data required (but not sufficient) to decrypt\nthe cipher-text, and information as to where to go to get the additional data\nrequired to decrypt the cipher-text.\n3. The agent-server interaction, where the agent gets the data needed to construct the decryption key and decrypt the cipher-text.\n\nNote that in several cases the first or last aspects are trivial and can be satisfied\nby publications by the sever.\n\nThe forward-time constructions permit key generation only after a given time\nwhile the backward-time permit key generation only before it. These constructions can be nested to permit key generation only during a certain time interval.\n\nThe main weakness of these constructions is that the server could collude\nwith an attacker to analyze the agent. This type weakness can easily be abated\nusing the methods discussed in section 6.\n\n**4.1** **Forward-Time Hash Function**\n\nThe first time-based construction uses a one-way function, such as SHA-1 [NIST93]\nor RIPEMD-160 [DBP96], as its sole cryptographic primitive. Let S be a secret\nbelonging to the server.\n\n6\n\n\n-----\n\n1. The programmer sends the target time, T _[∗], and a nonce, R, to the server._\n2. The server sets T to the current time and returns to the programmer T and\n_H(H(S, T_ _[∗]), H(R, T_ )).\n3. The programmer sets P = H(R, T ) and K = H(H(S, T _[∗]), H(R, T_ )). The\nprogrammer uses K to encrypt the message to the agent, and gives the\nagent a copy of P . He then lets the agent loose in the world.\n4. The agent continuously requests the current time’s secret from the server.\n5. The server returns Si = H(S, Ti). (Alternatively, the server could simply\ncontinuously broadcast Si and the agent could simply watch the broadcast\nstream.)\n6. The agent tries to use K = H(Si, P ) to decrypt its instructions. It will\nsucceed precisely when Si = H(S, T _[∗]) which is when Ti = T_ _[∗]._\n\nThis construction has several properties worth listing:\n\n**– The use of the current time in the construction of P prevents an analyst**\nfrom using the server to stage a dictionary attack.\n**– The form of the daily secret could easily be made hierarchical so that the**\nsecret for one day could be used to compute previous daily secrets.\n**– The use of a nonce, R, reduces the feasibility of a forward time dictionary**\nattack against the server in addition to obscuring the request date of a\nparticular key.\n**– Should this construction be used maliciously so that the courts order the**\nserver to participate in a particular analysis, the server could use P to compute an individual key without giving away all keys for that day.\n\n**4.2** **Forward-Time Public Key**\n\nThe second time-based construction uses public-key encryption, such as RSA\n\n[RSA78] or ElGamal [ElG84]. For each time Ti, the server has a method of\ngenerating a public-key/private-key key pair, (Di, Ei). The server can either\nstore these key pairs, or regenerate them as required.\n\n1. The programmer sends a target time T _[∗]_ to the server.\n2. The server returns the public key, D[∗], for that time.\n3. The programmer uses D[∗] to encrypt the message to the agent. He then lets\nthe agent loose in the world.\n4. The agent continuously requests the current time’s private key from the\nserver.\n5. The server returns Ei. (Again, the server could continuously broadcast Ei).\n6. The agent tries to use Ei to decrypt its instructions. It will succeed precisely\nwhen Ei = E[∗], which is when Ti = T _[∗]._\n\nThis protocol has the advantage that the programmer need not interact with\nthe server in Steps (1) and (2). The server could simply post the Di values for\n\n7\n\n\n-----\n\nvalues of i stretching several years in the future, and the programmer could\njust choose the one he needs. In this application, the server could be put in\na secure location—in orbit on a satellite, for example—and be reasonably safe\nfrom compromise.\n\n**4.3** **Backward-Time Hash Function**\n\nThe backward time construction also uses one-way functions as its sole cryptographic primitive. Again S is a secret belonging to the server.\n\n1. The programmer sends the target time T _[∗]_ and a nonce R to the server.\n2. The server returns H(S, R, T _[∗]) if and only if T_ _[∗]_ is in the future.\n3. The programmer sets K to the returned value and gives the agent a copy of\n_R and T_ _[∗]._\n4. At time T, the agent sends the target time T _[∗]_ and a nonce R to the server.\nIt will receive the valid key K in return if and only if T _[∗]_ is later than T .\n\nBackward time constructions in which the target time T _[∗]_ is unknown to the\nagent are also possible and are explained in section 6.\n\n## 5 General Server Constructions\n\nThe general server construct uses one-way functions and a symmetric encryption\nalgorithm. Again S is a secret belonging to the server.\n\n1. The programmer sends the server a program P and the hash of a particular\npossible output (N ) of the program P .\n_H_\n2. The server returns ES(P ) and H(S, P, H(N )).\n3. The programmer sets K = (S, P, (N )) and uses it to encrypt the message\n_H_ _H_\nto the agent. The programmer then gives ES(P ) to the agent.\n4. The agent gives ES(P ) to the server.\n5. The server decrypts the program P = DS(ES(P )), executes it, and sets M\nequal to the hash of its output. It then returns (S, P, M ) to the agent.\n_H_\n6. The agent tries to use the returned value as its key. It will succeed precisely\nwhen the output of the run program matches the programmer’s original\nexpectations.\n\nhis generic construction requires a safe execution environment, as that provided\nby Java in web browsers, with the additional constraint that the environment\ndoes not contain the secret S.\n\nWhile each of the previously discussed constructs can be built using this\nmethod, they loose several of the anonymity features, and require explicit agentserver interaction.\n\n8\n\n\n-----\n\n## 6 Further Constructions\n\nThese basic constructions can be assembled into higher level constructions.\n\n**6.1** **Reduced dictionary**\n\nOne way of making dictionary attacks [Kle90] infeasible is forcing the attacker to\nuse much too large a dictionary. Let S be a large collection of data and Sl ⊂S be\na much smaller subset of determined by the execution environment. Suppose\n_S_\nthat we know x1, . . . xn ∈Sl. Due to the size disparity between S and Sl it is\nfeasible to search through all n-tuples in Sl such that H(·, . . ., ·) = H(x1, . . ., xn)\nwhile the analogous search in is not possible.\n_S_\n\nA concrete example of this is to let be the complete collection of canonical\n_S_\nDNS names[3] of all hosts and Sl be the sub-collection of names from hosts inside\na domain behind a firewall. Searching through all name triples in Sl would be\nquite easy while searching through all triples in would be impossible.\n_S_\nThis construction would be useful in the virus example of Section 3.3.\n\n**6.2** **Thresholding**\n\nWe note that we can easily create a threshold system using the ideas of secret\nsharing. Suppose that is a set of observations of cardinality n and that we wish\n_S_\nto be able to construct a key K if m of them are present. We let T (m, n) be a\nsecret sharing scheme with shares s1, . . ., sn for share holders 1, . . ., n. Then for\neach xi ∈S we tell the agent that share holder i has name H(N, xi) and that\nhis share is generated by the function H(·) ⊕H(xi) ⊕ _si._\n\n**6.3** **Nesting**\n\nThese constructions can be nested: one environmental key can decrypt a section\nof the agent, which would then yield another encrypted section requiring yet\nanother environmental key. These nestings can be used to create more complex\nenvironmental constructions:\n\nFor example:\n\n**– Forward-time + Backward-time = time interval**\n**– Forward-time + Basic = Forward time, but only if a specific event has oc-**\ncurred.\n\nAgents can slough off previous information and thus can only be analyzed at\ntimes of metamorphosis. In other words, after an agent has triggered based on\n\n3 roughly the full name a host including domain information\n\n9\n\n\n-----\n\nan environmental condition, an attacker could not analyze the agent to determine what the condition was. Moreover, the attacker could not tell where the\npost-transformation agent was a product of the pre-transformation agent. This\nproperties gives rise to many useful anonymity constructions.\n\n## 7 Conclusions\n\nAs applications that allow mobile code become more prevalent, people will want\nto limit what an attacker can learn about themselves. The notion of clueless\nagents presented in this paper will have all sorts of applications: blind search\nengines (patents and product ideas), Manchurian mobile agents, expiration dates\nby backward-time constructs, intrusion detection systems which are difficult to\nbypass (they can watch for exploit without revealing nature of the vulnerability\nthey are guarding), logic bombs, directed viruses (both good and bad), remote\nalarms, etc. The notion of a software construction that hides its true nature is a\npowerful one, and we expect many other applications to appear as the technology\nmatures.\n\n## References\n\n[ATT92] AT&T, Telephone Security Device 3600–User’s Manual, AT&T, 1992.\n\n[DOW92] W. Diffie, P.C. can Oorschot, and M.J. Weiner, “Authentication and Authenticated Key Exchanges,” Designs, Codes, and Cryptography, v. 2,\n1992, pp. 107–125.\n\n[DBP96] H. Dobbertin, A. Bosselaers, and B. Preneel, “RIPEMD-160: A Strengthened Version of RIEPMD,” Fast Software Encryption, Third Interna_tional Workshop, Springer-Verlag, 1996, pp. 71–82._\n\n[ElG84] T. ElGamal, A Public-Key Cryptosystem and a Signature Scheme Based\non Discrete Logarithms, IEEE Transactions on Information Theory, IT-31\n(1985) 469-472.\n\n[Kle90] D.V. Klein, “Foiling the Cracker: A Security of, and Implications to,\nPassword Security,” Proceedings of the USENIX UNIX Security Work_shop, Aug 1990, pp. 5–14._\n\n[Mye94] E.D. Myers, “STU-III—Multilevel Secure Computer Interface,” Proceed_ings of the Tenth Annual Computer Security Applications Conference,_\nIEEE Computer Society Press, 1994, pp. 170–179.\n\n[NIST93] National Institute of Standards and Technology, NIST FIPS PUB 180,\n“Secure Hash Standard,” U.S. Department of Commerce, May 1993.\n\n[RSA78] R. Rivest, A. Shamir, and L. Adleman, “A Method for Obtaining Digital Signatures and Public-Key Cryptosystems,” Communications of the\n_ACM, v. 21, n. 2, Feb 1978, pp. 120-126._\n\nThis article was processed using the L[A]TEX macro package with LLNCS style\n\n10\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://www.schneier.com/academic/paperfiles/paper-clueless-agents.pdf"
    ],
    "report_names": [
        "paper-clueless-agents.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716503,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 941451724,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/1be5425625872d882ea412b2c83b7cdf1d56da79.pdf",
        "text": "https://archive.orkl.eu/1be5425625872d882ea412b2c83b7cdf1d56da79.txt",
        "img": "https://archive.orkl.eu/1be5425625872d882ea412b2c83b7cdf1d56da79.jpg"
    }
}