{
    "id": "8cb8b97c-4406-440e-85da-5625177db378",
    "created_at": "2023-01-12T14:59:05.118915Z",
    "updated_at": "2025-03-27T02:12:11.135454Z",
    "deleted_at": null,
    "sha1_hash": "eea2973f8bff8b30f388f146c2553771a7dd5fa3",
    "title": "2017-12 - Nine circles of Cerber",
    "authors": "",
    "file_creation_date": "2022-05-28T19:38:36Z",
    "file_modification_date": "2022-05-28T19:38:36Z",
    "file_size": 1082288,
    "plain_text": "# VB2017 paper: Nine circles of Cerber\n\n**[virusbulletin.com/virusbulletin/2017/12/vb2017-paper-nine-circles-cerber/](https://www.virusbulletin.com/virusbulletin/2017/12/vb2017-paper-nine-circles-cerber/)**\n\n### Stanislav Skuratovich & Neomi Rona\n\nCheck Point Software Technologies, Belarus & Israel\n\n_Copyright © 2017 Virus Bulletin_\n\nTable of contents\n\nAbstract\n\n1. Introduction\n\n2. Encryption scheme\n\n3. Decryption scheme\n\n4. Fatal flaw\n\n5. Decryption service installation\n\n6. A ransomware-as-a-service ecosystem\n\n7. Following the money trail\n\nSummary\n\nAcknowledgements\n\nReferences\n\n## Abstract\n\nWithout any doubt, 2016 was the year of ransomware. What makes ransomware so\nattractive to attackers is that it offers the possibility of large profits while not requiring too\nmuch effort. With the availability of ransomware-as-a-service, someone with very little actual\nknowledge of computers can easily manage a highly profitable campaign.\n\nA wide variety of different ransomware families appeared over the course of the last year,\nincluding Locky, CryptoWall and CryptXXX, to name just a few. Let's talk about the very\nprofitable Cerber.\n\nThe Cerber ransomware was mentioned for the first time in March 2016 on some Russian\nunderground forums, on which it was offered for rent in an affiliate program. Since then, it\nhas been spread massively via exploit kits, infecting more and more users worldwide,\nmostly in the APAC (Asia-Pacific) region. At the time of writing this paper, there are six\nmajor versions.\n\n\n-----\n\nThere have been multiple successful attempts to decrypt users files without paying a\nransom. At the end of July 2016, Trend Micro released a partially working decryptor for the\nfirst version of Cerber [1]. In early August, we had a chance to take a look at the original\nCerber decryptor code that was available for download upon payment of the ransom. Our\nmain goal was to discover a flaw, based on the standard approaches we use against\nransomware.\n\nFrom our perspective, it wouldn't be as much fun if this was one of the expected bugs – and\nfortunately, the one we discovered wasn't. However, as with any flaw, you need to hide the\nsolution from the criminals. In an ironic twist, the ransomware authors released a new\nCerber 2 version the day before we were due to release the decryptor.\n\nIn order to be able to provide our decryption tool to as many victims as possible, we\ngathered forces and adapted it to the new version on the same day, thus managing to\nrelease it on time. The tool was used by many victims worldwide.\n\nThis paper details the story of the ransomware's fatal flaw and our free decryption service\n\n[2, 3]. We will dive deep into the background of Cerber as a service, the business\noperations, the money flow between the attacker and the affiliate, full global infection\nstatistics and the estimated overall profit of the criminals [4].\n\n## 1. Introduction\n\nIn this paper we discuss one of the largest recent ransomware campaigns, known as\nCerber. We describe the ransomware's encryption routine and reveal technical details of the\nserver-side vulnerability that was used for the successful decryption of thousands of\ninfected machines. We also share information on the money flow and estimated overall\nprofit of the criminals, together with the tools used to collect that information. The decryption\nsoftware will be available as open source on our GitHub repository [5].\n\n## 2. Encryption scheme\n\nLet's describe the encryption scheme used by the Cerber ransomware. It uses mix of\nsymmetric and asymmetric encryption algorithms, such as RC4 and RSA. Almost all the\nencryption keys are generated randomly on the victim's machine.\n\nFirst, let's take a look at the keys that are used by Cerber during the encryption process:\n\n|Key|Appearance/description|Scope|\n|---|---|---|\n|RSA_M_PUB (2048 bits)|Configuration This is a master public key|Global|\n\n\n-----\n\nRSA_X_PUB/PRI (X bits) Random\n\n\nGlobal\n\n\nThis is a local key pair\n\n|RC4_KEY (128 bytes)|Random|Per file|\n|---|---|---|\n\n\nThe structure of the encrypted file is presented in Figure 1.\n\nFigure 1: Structure of encrypted file.\n\nThe goal of the encryption routine is to encrypt a single file from the file system. The\nnumber of bytes that are stolen from the beginning of each encrypted file (hereafter called\n_N) is calculated once and depends on the local RSA key size. The steps performed by_\nCerber to encrypt a single file are as follows:\n\n1. Calculate the number of blocks that will be encrypted (up to the maximum number of\n\nblocks specified in the configuration).\n2. Steal N bytes from the beginning of the file by replacing them with random bytes.\n3. Encrypt each block with the RC4 algorithm using RC4_KEY as a key.\n\n\n-----\n\n4. The following meta information is encrypted and appended to the end of the\n\nprocessed file:\n\n**Information** **Algorithm** **Key**\n\nFileMetainfo RC4 RC4_KEY\n\nFileStolenHeader RSA RSA_X_PUB\n\nRSA_X_PUB/PRI RSA RSA_M_PUB\n\nThe FileStolenHeader contains RC4_KEY, which can be used to restore the\nencrypted blocks, thus it is encrypted using RSA_X_PUB. RSA_X_PRI is encrypted\nby the master RSA_M_PUB key, because it can be used for the FileStolenHeader\ndecryption.\n\nTwo main data structures that represent the encrypted file are presented below:\n```\nstruct FileStolenHeader {\n  char ver_magic[4];  // magic header (version)\n  uint32_t rand_bytes; // random bytes\n  uint16_t fn_len;   // Unicode filename length\n  uint8_t blocks;    // blocks to encrypt\n  uint32_t block_size; // block size\n  uint16_t N_to_steal; // number of bytes to steal\n  uint32_t N_bytes_mmh; // murmur3 hash of stolen\n  char RC4_KEY[16];   // RC4_KEY\n  char stolen_bytes[0]; // stolen bytes\n};\nstruct FileMetainfo {\n  FILETIME Creation;  // original CR time\n  FILETIME LastAccess; // original LA time\n  FILETIME LastWrite;  // original LW time\n  char orig_fn[0];   // original filename\n  uint64_t blocks_mmh[0]; // murmur3 hash of blocks\n};\n\n```\nThe overall structure of an encrypted file was presented in Figure 1, however this can vary\ndepending on the size of encrypted file.\n\nIf a single block is encrypted:\n```\nstruct EncryptedFile {\n  char rand_bytes[N]; // stolen bytes repl\n  char ct[FileSize-N]; // encrypted file data\n  FileMetainfo enc_fmi; // encrypted FMI stru\n  char enc_fsh[0]; // encrypted FSH stru\n  char enc_RSA_X[0]; // encrypted RSA_X_*\n};\n\n```\n|Information|Algorithm|Key|\n|---|---|---|\n|FileMetainfo|RC4|RC4_KEY|\n|FileStolenHeader|RSA|RSA_X_PUB|\n|RSA_X_PUB/PRI|RSA|RSA_M_PUB|\n\n\n-----\n\nIf multiple blocks are encrypted:\n```\nstruct EncryptedFile {\n  char rand_bytes[N];       // stolen bytes repl\n  char pt_0[K];            // plaintext chunk\n  char ct_0[max_block_size]; // ciphertext chunk\n  ...\n  char pt_y[M];           // plaintext chunk\n  char ct_y[max_block_size]; // ciphertext chunk\n  FileMetainfo enc_fmi;     // encrypted FMI stru\n  char enc_fsh[0];        // encrypted FSH stru\n  char enc_RSA_X[0];     // encrypted RSA_X_*\n};\n\n```\nIf the file is small:\n```\nstruct EncryptedFile {\n  char rand_bytes[N];   // stolen bytes repl\n  FileMetainfo enc_fmi;  // encrypted FMI stru\n  char enc_fsh[0];     // encrypted FSH stru\n  char enc_RSA_X[0];  // encrypted RSA_X_*\n};\n\n## 3. Decryption scheme\n\n```\nLet's discuss the decryption scheme that is used by the Cerber ransomware, after the\nransom has been paid. An overview of the decryption scheme is shown in Figure 2.\n\n\n-----\n\nFigure 2: Decryption scheme.\n\nThe following steps are performed by the decryptor in order to restore encrypted files:\n\n1. Extract encrypted blob of RSA_X_PUB/PRI (hereafter ENC_RSA_X_BLOB) from the\n\nend of the encrypted file and send it to the server.\n2. Decrypt RSA_X_PRI on the server by using RSA_M_PRI and send it to the client.\n\nRSA_M_PRI is the master private key and is known only to the attacker.\n3. Use the obtained RSA_X_PRI to decrypt the FileStolenHeader structure, thus\n\nrestoring RC4_KEY and the stolen bytes.\n4 Decrypt encrypted blocks by using RC4 KEY\n\n\n-----\n\n5. Restore original file content by combining stolen header with the decrypted blocks.\n6. Decrypt FileMetainfo structure using RC4_KEY and restore file meta information.\n\nAs we can see, the decryption routine is not complicated. The only blind spot is the\nRSA_M_PRI key. Factorization of a 2048-bit number is a nice challenge [6], but is definitely\nnot what we want to deal with, because cracking such a long key is not feasible in a\nreasonable amount of time.\n\nLet's take a look at how the decryptor communicates with the server in order to obtain\nRSA_X_PRI, which is critical for the decryption process. The decryptor encodes\nENC_RSA_X_BLOB using a base64 algorithm (hereafter PRIVATE_KEY). The ID of the\ninfected machine is calculated as an MD5 of the previously encoded block (hereafter SIGN)\n(see Figure 3).\n\nFigure 3: Signature generation.\n\nThe first message contains only the machine ID, which is sent using the following format:\n```\n\"sign=%s\" % SIGN\n\n```\nThe response from the server contains a CAPTCHA image, which must be solved to\ncontinue decryption. We assume that this is done to protect the decryption server from the\nDDoS.\n\n\n-----\n\nFigure 4: CAPTCHA.\n\nThe CAPTCHA solution, together with PRIVATE_KEY and SIGN, are sent to the server\nusing the following format:\n```\n\"captcha=%d&sign=%s&private_key=%s\" % (CAPTCHA, SIGN, PRIVATE_KEY)\n\n```\nIf the CAPTCHA has successfully been solved and the specified machine ID has made the\nransom payment, the server decrypts RSA_X_PRI and sends it back to the client. Then the\ndecryptor starts the file restore process.\n\n\n-----\n\nFigure 5: Successful decryption.\n\nIf the ransom for the specified machine ID is not paid, the user receives the message\nshown in Figure 6 during communication with decryption server.\n\n\n-----\n\nFigure 6: Ransom not paid.\n\nNow we have familiarized ourselves with the decryption scheme and communication\nmethod, let's consider what can go wrong in the existent solution.\n\n## 4. Fatal flaw\n\nThis section describes the approaches that were used to find a flaw in the decryptor. First,\nwe should understand how exactly the server validates that the ransom has been paid for a\nspecific machine. The most obvious answer is the use of the SIGN field. If the ransom is\npaid for SIGN, the server decrypts PRIVATE_KEY and sends RSA_X_PRI to the user. Let's\ntry to rewrite the server code that is responsible for handling decryption requests from users\nbased on received responses:\n\n\n-----\n\n```\ndef handle_request_decrypt_private_key(packet):\n  if not captcha_correct(packet['captcha']):\n   send('{\"error\": \"Captcha expired or invalid\"}')\n   return\n  if not paid(packet['sign']):\n   send('{\"error\":\"Not paid\"}')\n   return\n  pk = urls_to_b64(packet['private_key'])\n  #**********************************************\n  # DOES SERVER SIDE HAVE SUCH INTEGRITY CHECK ?#\n  if md5(pk).hexdigest() != packet['sign'])\n   send('{???}')\n   return\n  #**********************************************\n  RSA_X_PRI = decrypt(b64decode(pk))\n  send('{\"error\": \"null\", \"private_key\": \"%s\"}' %\\\n   encode(RSA_X_PRI))\n\n```\nNow let's try to recreate the server's exact behaviour based on the received responses and\ncommon sense:\n\n1. Check if CAPTCHA is correct.\n2. Check if SIGN is paid. Server treats SIGN as a unique machine ID.\n3. Perform integrity check on delivered PRIVATE_KEY using SIGN, because SIGN is the\n\nhexlified MD5 of PRIVATE_KEY.\n4. Decrypt PRIVATE_KEY and extract RSA_X_PRI.\n\nThe first two steps can easily be checked by sending an incorrect CAPTCHA solution and\nSIGN that is unpaid. The third step is what we are really interested in.\n\nLet's imagine that SIGN_A signature is paid and we have a possibility to restore\nRSA_X_PRI_A. RSA_X_PRI_A is restored from the PRIVATE_KEY data that is under the\nsender's control. So what happens if the user spoofs that data?\n\n\n-----\n\nFigure 7: Original PRIVATE_KEY for the\n\npaid SIGN.\n\nLet's think what exactly we can achieve by setting PRIVATE_KEY to prepared data\nassuming SIGN_A is paid. What will happen if we can calculate PRIVATE_KEY_V for\nanother infection? Assuming that a data integrity check is absent, then the server will simply\ndecrypt PRIVATE_KEY_V and extract RSA_X_PRI_V, thus giving the possibility to restore\ninfected files for the user who hasn't paid! By applying the same tactics to all infected\nmachines, we can restore them by using only one valid SIGN.\n\nIf the server does not perform an integrity check of the PRIVATE_KEY data, then it is\ndecrypted and the RSA_X_PRI_V key is sent to the user. The user then adopts that key to\nrestore encrypted files.\n\nFigure 8: Spoofed PRIVATE_KEY for the\n\npaid SIGN.\n\n\n-----\n\nTo showcase this theory we paid the ransom for one infection that was performed on a\nspecially prepared machine. All the checks on the server side passed and the decryption\nprocess succeeded (Figure 9).\n\nFigure 9: Successful decryption for original PRIVATE_KEY.\n\nNext, a second machine was infected and encrypted with the Cerber ransomware. It\nobviously had a different PRIVATE_KEY. The original decryptor was dirty patched to use\nthe same SIGN as was previously paid. We started the decryptor on the second infected\nmachine, and all the data on the infected machine was decrypted! (Figure 10).\n\n\n-----\n\nFigure 10: Successful decryption for spoofed PRIVATE_KEY.\n\nThe Cerber authors simply did not perform a data integrity check, thus giving us the\npossibility to exploit this bug and decrypt machines with only one paid signature.\n\nFigure 11: Data\n\nintegrity check that authors have skipped.\n\n## 5. Decryption service installation\n\nThis section provides a general description of what actions were performed in order to\nestablish a decryption service as soon as possible after the vulnerability was discovered.\nOur two main goals were to hide the flaw from the attackers for as long as possible and to\nmake the bandwidth for decryption as wide as possible.\n\nIn order to fulfil both requirements we decided to set up a server that would be responsible\nfor fetching the keys. After being fetched, the obtained key would be sent to the infected\nuser. This key would then be used by the client-side decryptor to restore the files. Figure 12\nprovides an overview of the process.\n\n\n-----\n\nFigure 12: Fetching decryption key for\n\n\nspecific infection.\n\n\n-----\n\nThe following steps are taken in order to retrieve the decryption key for a specific infection:\n\n1. User uploads encrypted file from the infected machine to the Check Point Decryption\n\n_Service (CPDS)._\n2. CPDS extracts ENC_RSA_X_BLOB from the received file, which is aliased with\n\nPRIVATE_KEY_K.\n3. PRIVATE_KEY_K is sent to the Cerber Decryption Server (CDS) together with the\n\npaid SIGN_A.\n4. CDS checks if SIGN_A is paid and decrypts the RSA_X_PRI client private key by\n\nusing RSA_M_PRI.\n5. CDS sends RSA_X_PRI_K in a specific format to the CPDS.\n6. CPDS extracts RSA_X_PRI_K and sends the file with its content to the user.\n7. User uses the obtained file together with the RSA_X_PRI_K in order to restore\n\nencrypted files by the running prepared application.\n\nFigure 13: Infected machine decryption process.\n\nIn order to parallelize victims' requests and reduce both the waiting time and server bug\nfixing, four decryption signatures were purchased. With that number of keys we were able\nto handle up to 20,000 decryption requests per day.\n\n\n-----\n\nFigure 14: Check Point Cerber Ransomware Decryption Tool.\n\nNow that we have examined the server-side flaw that gave us the chance to decrypt\ninfected computers, let's take a look at the Cerber ecosystem and associated money\nlaundering.\n\n## 6. A ransomware-as-a-service ecosystem\n\nCerber ransomware-as-a-service illustrates every aspect of an effective business franchise.\nThe actor behind the operation, dubbed 'crbr', offers the ransomware for sale through a\nprivate, carefully managed affiliate program – actors who are willing to distribute the\nransomware are granted a comprehensive use panel through which they can monitor the\nrate of the infections, encryption process and ransom payments. In return, 40% of the\nprofits are transferred to 'crbr' as a fee. Based on data collected by our sensors, during July\n2016 Cerber affiliates ran over 150 active campaigns, infecting nearly 150,000 victims, with\na total estimated profit of US$195,000 per month, which adds up to US$2.3 million per year\n(the numbers are based on a Bitcoin conversion rate of US$590). In fact, the Cerber\nransomware demonstrates a growth rate higher than that of major global fast food chains.\n\n\n-----\n\nFigure 15: Cerber global distribution map.\n\n## 7. Following the money trail\n\nCerber generates a unique Bitcoin wallet to receive funds from each victim. The generated\nwallet appears in the landing page shown to the victim, represented by an encoded string in\nthe URL. Check Point researchers examined tens of thousands of victim Bitcoin wallets,\nand found that only 0.3% of the victims chose to pay the ransom. But the bigger question is:\nonce a Bitcoin transaction occurs, what happens to the money? Based on our analysis, it\nseems that Cerber uses a Bitcoin mixing service as part of its money flow in order to remain\nuntraceable. A mixing service allows the ransomware author to transfer Bitcoins and\nreceive the same amount back to a wallet that cannot be associated with the original owner.\nThis is achieved by mixing multiple users' funds together, using tens of thousands of Bitcoin\nwallets, making it almost impossible to track them individually (see Figure 16). Based on our\nresearch, automated tools distribute the affiliate shares only after the money has been\nswapped by the mixing service and the malware author's share has been collected.\n\n\n-----\n\nFigure 16: Cerber Bitcoin flow\n\n\n-----\n\n## Summary\n\nThousands of users restored their files while the Check Point Cerber Decryption Service\nwas active. Unfortunately, the attackers were quite responsive and fixed the vulnerability\nwithin 24 hours.\n\nCerber ransomware-as-a-service uses a business model that has been proven to be\neffective by some of the biggest franchise businesses worldwide. Furthermore, the malware\nauthor uses a sophisticated money flow to ensure that the profits remain sealed and that its\nBitcoin wallets cannot be associated with the attack operation. It is therefore little wonder\nthat Cerber ransomware is one of the most widespread pieces of ransomware of our time.\n\n## Acknowledgements\n\nWe would like to thank the Check Point Malware Research and Threat Intelligence teams\nand in particular Aliaksandr Trafimchuk for his devoted help throughout the research.\n\n## References\n\n[1] Cerber Decryptor. http://blog.trendmicro.com/trend-micro-ransomware-file-decryptorupdated/.\n\n[2] Check Point Releases Working Decryptor for the Cerber Ransomware.\nhttps://www.bleepingcomputer.com/news/security/check-point-releases-working-decryptorfor-the-cerber-ransomware/.\n\n[3] Cerber 2 Ransomware: Free Decryption Tool Released.\nhttp://www.bankinfosecurity.com/cerber-2-ransomware-free-decryption-tool-released-a9341.\n\n[4] Cerber. [http://blog.checkpoint.com/2016/08/16/cerberring/.](https://blog.checkpoint.com/2016/08/16/cerberring)\n\n[5] Source code. [https://github.com/CheckPointSW/CerberDecryptionService.](https://github.com/CheckPointSW/CerberDecryptionService)\n\n[[6] RSA Factoring Challenge. https://en.wikipedia.org/wiki/RSA_Factoring_Challenge.](https://en.wikipedia.org/wiki/RSA_Factoring_Challenge)\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\n\n-----\n\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order\nto infiltrate organizations’ dedicated environments and transform them into attack\nlaunchpads. In this article Aditya Sood presents a new module introduced by…\n\n### Collector-stealer: a Russian origin credential and information extractor\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to\nexfiltrate sensitive data from end-user systems and store it in its C&C panels. In this article,\nresearchers Aditya K Sood and Rohit Chaturvedi present a 360…\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and\nfrom that moment onward, was intrigued by the properties of these small pieces of selfreplicating code. Joe Wells was an expert on computer viruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\nKurt Natvig wanted to understand whether it’s possible to recompile VBA macros to another\nlanguage, which could then easily be ‘run’ on any gateway, thus revealing a sample’s true\nnature in a safe manner. In this article he explains how he recompiled…\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware,\ndiscussing his team's findings related to the C&C design and some security issues they\nidentified during the research.\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\nWe have placed cookies on your device in order to improve the functionality of this site, as\n[outlined in our cookies policy. However, you may delete and block all cookies from this site](https://www.virusbulletin.com/about-vb/privacy-policy/cookies)\nand your use of the site will be unaffected. By continuing to browse this site, you are\n[agreeing to Virus Bulletin's use of data as outlined in our privacy policy.](https://www.virusbulletin.com/about-vb/privacy-policy/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-12 - Nine circles of Cerber.pdf"
    ],
    "report_names": [
        "2017-12 - Nine circles of Cerber.pdf"
    ],
    "threat_actors": [
        {
            "id": "dfee8b2e-d6b9-4143-a0d9-ca39396dd3bf",
            "created_at": "2022-10-25T16:07:24.467088Z",
            "updated_at": "2025-03-27T02:02:10.241387Z",
            "deleted_at": null,
            "main_name": "Circles",
            "aliases": [],
            "source_name": "ETDA:Circles",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "bfded1cf-be73-44f9-a391-0751c9996f9a",
            "created_at": "2022-10-25T15:50:23.337107Z",
            "updated_at": "2025-03-27T02:00:55.445946Z",
            "deleted_at": null,
            "main_name": "FIN7",
            "aliases": [
                "FIN7",
                "GOLD NIAGARA",
                "ITG14",
                "Carbon Spider",
                "ELBRUS",
                "Sangria Tempest"
            ],
            "source_name": "MITRE:FIN7",
            "tools": [
                "Mimikatz",
                "AdFind",
                "JSS Loader",
                "HALFBAKED",
                "REvil",
                "PowerSploit",
                "CrackMapExec",
                "Carbanak",
                "Pillowmint",
                "Cobalt Strike",
                "POWERSOURCE",
                "RDFSNIFFER",
                "SQLRat",
                "Lizar",
                "TEXTMATE",
                "BOOSTWRITE"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "bb8702c5-52ac-4359-8409-998a7cc3eeaf",
            "created_at": "2023-01-06T13:46:38.405479Z",
            "updated_at": "2025-03-27T02:00:02.82533Z",
            "deleted_at": null,
            "main_name": "FIN7",
            "aliases": [
                "JokerStash",
                "ATK32",
                "G0046",
                "Coreid",
                "Carbanak",
                "Sangria Tempest",
                "CARBON SPIDER",
                "GOLD NIAGARA",
                "G0008",
                "ELBRUS",
                "Carbon Spider"
            ],
            "source_name": "MISPGALAXY:FIN7",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d85adfe3-e1c3-40b0-b8bb-d1bacadc4d82",
            "created_at": "2022-10-25T16:07:23.619566Z",
            "updated_at": "2025-03-27T02:02:09.890982Z",
            "deleted_at": null,
            "main_name": "FIN7",
            "aliases": [
                "APT-C-11",
                "ATK 32",
                "Gold Niagara",
                "ITG14",
                "TAG-CR1"
            ],
            "source_name": "ETDA:FIN7",
            "tools": [
                "7Logger",
                "Agentemis",
                "Anunak",
                "Astra",
                "BIOLOAD",
                "BIRDWATCH",
                "Bateleur",
                "Boostwrite",
                "CROWVIEW",
                "Carbanak",
                "Cobalt Strike",
                "CobaltStrike",
                "DICELOADER",
                "DNSMessenger",
                "FOWLGAZE",
                "HALFBAKED",
                "JSSLoader",
                "KillACK",
                "LOADOUT",
                "Lizar",
                "Meterpreter",
                "Mimikatz",
                "POWERPLANT",
                "POWERSOURCE",
                "RDFSNIFFER",
                "SQLRAT",
                "Sekur",
                "Sekur RAT",
                "TEXTMATE",
                "Tirion",
                "VB Flash",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535545,
    "ts_updated_at": 1743041531,
    "ts_creation_date": 1653766716,
    "ts_modification_date": 1653766716,
    "files": {
        "pdf": "https://archive.orkl.eu/eea2973f8bff8b30f388f146c2553771a7dd5fa3.pdf",
        "text": "https://archive.orkl.eu/eea2973f8bff8b30f388f146c2553771a7dd5fa3.txt",
        "img": "https://archive.orkl.eu/eea2973f8bff8b30f388f146c2553771a7dd5fa3.jpg"
    }
}