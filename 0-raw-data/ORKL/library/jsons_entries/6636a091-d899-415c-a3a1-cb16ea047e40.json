{
    "id": "6636a091-d899-415c-a3a1-cb16ea047e40",
    "created_at": "2023-06-05T02:06:21.72902Z",
    "updated_at": "2025-03-27T02:16:20.764666Z",
    "deleted_at": null,
    "sha1_hash": "409459b1d1b29338e638d50bfe114fcfdc1dcafb",
    "title": "2023-05-09 - Hunting Russian Intelligence “Snake” Malware",
    "authors": "",
    "file_creation_date": "2023-06-04T12:39:25Z",
    "file_modification_date": "2023-06-04T12:39:25Z",
    "file_size": 3538853,
    "plain_text": "# Hunting Russian Intelligence “Snake” Malware\n\n**[cisa.gov/news-events/cybersecurity-advisories/aa23-129a](https://www.cisa.gov/news-events/cybersecurity-advisories/aa23-129a)**\n\nCybersecurity Advisory\n\nLast Revised\n\nMay 09, 2023\n\nAlert Code\n\nAA23-129A\n\n### SUMMARY\n\nThe Snake implant is considered the most sophisticated cyber espionage tool designed and\nused by Center 16 of Russia’s Federal Security Service (FSB) for long-term intelligence\ncollection on sensitive targets. To conduct operations using this tool, the FSB created a\ncovert peer-to-peer (P2P) network of numerous Snake-infected computers worldwide. Many\nsystems in this P2P network serve as relay nodes which route disguised operational traffic to\nand from Snake implants on the FSB’s ultimate targets. Snake’s custom communications\nprotocols employ encryption and fragmentation for confidentiality and are designed to\nhamper detection and collection efforts.\n\nWe have identified Snake infrastructure in over 50 countries across North America, South\nAmerica, Europe, Africa, Asia, and Australia, to include the United States and Russia itself.\nAlthough Snake uses infrastructure across all industries, its targeting is purposeful and\ntactical in nature. Globally, the FSB has used Snake to collect sensitive intelligence from\nhigh-priority targets, such as government networks, research facilities, and journalists. As\none example, FSB actors used Snake to access and exfiltrate sensitive international\nrelations documents, as well as other diplomatic communications, from a victim in a North\nAtlantic Treaty Organization (NATO) country. Within the United States, the FSB has\nvictimized industries including education, small businesses, and media organizations, as well\nas critical infrastructure sectors including government facilities, financial services, critical\nmanufacturing, and communications.\n\nThis Cybersecurity Advisory (CSA) provides background on Snake’s attribution to the FSB\nand detailed technical descriptions of the implant’s host architecture and network\ncommunications. This CSA also addresses a recent Snake variant that has not yet been\nwidely disclosed. The technical information and mitigation recommendations in this CSA are\nprovided to assist network defenders in detecting Snake and associated activity. For more\n\n\n-----\n\ninformation on FSB and Russian state-sponsored cyber activity, please see the joint advisory\n[Russian State-Sponsored and Criminal Cyber Threats to Critical Infrastructure and](https://www.cisa.gov/news-events/cybersecurity-advisories/aa22-110a) CISA’s\nRussia Cyber Threat Overview and Advisories webpage.\n\nDownload the PDF version of this report:\n\n[Hunting Russian Intelligence “Snake” Malware\n(PDF, 4.11 MB\n)](https://www.cisa.gov/sites/default/files/2023-05/aa23-129a_snake_malware_2.pdf)\n\n### INTRODUCTION\n\n**What is Snake?**\n\nWe consider Snake to be the most sophisticated cyber espionage tool in the FSB’s arsenal.\nThe sophistication of Snake stems from three principal areas. First, Snake employs means to\nachieve a rare level of stealth in its host components and network communications. Second,\nSnake’s internal technical architecture allows for easy incorporation of new or replacement\ncomponents. This design also facilitates the development and interoperability of Snake\ninstances running on different host operating systems. We have observed interoperable\nSnake implants for Windows, MacOS, and Linux operating systems. Lastly, Snake\ndemonstrates careful software engineering design and implementation, with the implant\ncontaining surprisingly few bugs given its complexity.\n\nFollowing open source reporting by cybersecurity and threat intelligence companies on\nSnake tactics, techniques, and procedures (TTPs), the FSB implemented new techniques to\nevade detection. The modifications to the implant enhanced challenges in identifying and\ncollecting Snake and related artifacts, directly hampering detection from both host- and\nnetwork-based defensive tools.\n\nThe effectiveness of this type of cyber espionage implant depends entirely on its long-term\nstealth, since the objective of an extended espionage operation involves remaining on the\ntarget for months or years to provide consistent access to important intelligence. The\nuniquely sophisticated aspects of Snake represent significant effort by the FSB over many\nyears to enable this type of covert access.\n\n**Background**\n\nThe FSB began developing Snake as “Uroburos” in late 2003. Development of the initial\nversions of the implant appeared to be completed around early 2004, with cyber operations\nfirst conducted using the implant shortly thereafter. The name Uroburos is appropriate, as the\nFSB cycled it through nearly constant stages of upgrade and redevelopment, even after\npublic disclosures, instead of abandoning it. The name appears throughout early versions of\nthe code, and the FSB developers also left other unique strings, including\n“Ur0bUr()sGoTyOu#”, which have publicly come back to haunt them.\n\n\n-----\n\nUnique features in early versions of Uroburos included a low resolution image of a portion of\na historical illustration of an uroboros by the German philosopher and theologian Jakob\nBöhme. One approach to a tertiary backdoor used this image as the key. The same image\nhad also been embedded in other Snake-related components. The image, blown up to a\nhigher resolution, is shown below.\n\nIn addition, early FSB developers of the Snake implant left portions of unique code\nthroughout the implant which reveal inside jokes, personal interests, and taunts directed at\nsecurity researchers. For instance, the “Ur0bUr()sGoTyOu#” string referenced above was\nreplaced with “gLASs D1cK” in 2014 following some of the public cybersecurity reporting.\n\n**Attribution**\n\nWe attribute Snake operations to a known unit within Center 16 of the FSB. This unit more\nbroadly operates the numerous elements of the Turla toolset, and has subunits spread\nthroughout Russia in a reflection of historical KGB signals intelligence operations in the\nSoviet Union. Snake has been a core component of this unit’s operations for almost as long\nas Center 16 has been part of the FSB. The extensive influence of Snake across the Turla\ntoolset demonstrates its impact on practically every aspect of the unit’s modern era of cyber\noperations.\n\nDaily operations using Snake have been carried out from an FSB facility in Ryazan, Russia,\nwith an increase in Snake activity during FSB working hours in Ryazan, approximately 7:00\nAM to 8:00 PM, Moscow Standard Time (GMT+3). The main developers were Ryazan-based\nFSB officers known by monikers included in the code of some versions of Snake. In addition\nto developing Snake, Ryazan-based FSB officers used it to conduct worldwide operations;\nthese operations were different from others launched from Moscow or other FSB sites based\non infrastructure and techniques.\n\n\n-----\n\nWhile the development and re-tooling of Snake has historically been done by Ryazan-based\nFSB officers, Snake operations were also launched from an FSB Center 16-occupied\nbuilding in Moscow. Our investigations have identified examples of FSB operators using\nSnake to its full potential, as well as FSB operators who appeared to be unfamiliar with\nSnake’s more advanced capabilities. These observations serve to illustrate the difficulty in\nusing such an advanced toolset across the various geographically dispersed teams\ncomprising this unit within FSB Center 16.\n\nWe have been collectively investigating Snake and Snake-related tools for almost 20 years,\nas well as other operations by this unit since the 1990s. During that time, the FSB has used\nSnake in many different operations, and they have demonstrated the value placed in this tool\nby making numerous adjustments and revisions to keep it viable after repeated public\ndisclosures and other mitigations. Snake’s code and multiple Snake-related tools have been\neither a starting point or a key influence factor for a diverse range of other highly prolific\nimplants and operational tools in the Turla family. Most notably, this has included Carbon\n(aka Cobra)—derived from Snake’s code base—and the similarly Snake-adjacent implant\nChinch (currently known in open sources as ComRAT).\n\n**Victimization**\n\nWe have identified Snake infrastructure in over 50 countries across North America, South\nAmerica, Europe, Africa, Asia, and Australia, to include the United States and Russia itself.\nAlthough Snake leverages infrastructure across all industries, its targeting is purposeful and\ntactical in nature. For instance, if an infected system did not respond to Snake\ncommunications, the FSB actors would strategically re-infect it within days. Globally, the FSB\nhas used Snake to collect sensitive intelligence from high priority targets, such as\ngovernment networks, research facilities, and journalists. As one example, FSB actors used\nSnake to access and exfiltrate sensitive international relations documents, as well as other\ndiplomatic communications, from a victim in a NATO country. Within the United States, the\nFSB has victimized industries including education, small businesses, and media\norganizations, as well as critical infrastructure sectors including government facilities,\nfinancial services, critical manufacturing, and communications.\n\n**Other Tools and TTPs Employed with Snake**\n\nThe FSB typically deploys Snake to external-facing infrastructure nodes on a network, and\nfrom there uses other tools and TTPs on the internal network to conduct additional\nexploitation operations. Upon gaining and cementing ingress into a target network, the FSB\ntypically enumerates the network and works to obtain administrator credentials and access\ndomain controllers. A wide array of mechanisms has been employed to gather user and\nadministrator credentials in order to expand laterally across the network, to include\nkeyloggers, network sniffers, and open source tools.\n\n\n-----\n\nTypically, after FSB operators map out a network and obtain administrator credentials for\nvarious domains in the network, regular collection operations begin. In most instances with\nSnake, further heavyweight implants are not deployed, and they rely on credentials and\nlightweight remote-access tools internally within a network. FSB operators sometimes deploy\na small remote reverse shell along with Snake to enable interactive operations. This\ntriggerable reverse shell, which the FSB has used for around 20 years, can be used as a\nbackup access vector, or to maintain a minimal presence in a network and avoid detection\nwhile moving laterally.\n\n**Snake Architecture**\n\nSnake’s architectural design reflects professional software engineering practices. Critical\npathways within the implant are made of stacks of loosely coupled components that\nimplement well-designed interfaces. In addition to facilitating software development and\ndebugging, this construction allows Snake to use multiple different components for the same\npurpose, choosing the specific component based on environmental considerations. For\nexample, Snake’s custom network communications protocols function as a stack. All\nimplementations use an encryption layer and a transport layer, such as Snake’s custom\nHTTP or raw TCP socket protocol. Each layer of the Snake network protocol stack solely\nimplements a specified interface for operability with the two adjacent layers. The encryption\nlayer and underlying transport layer thus function independently, so any custom Snake\nnetwork protocol can employ an encryption overlay without any change to the encryption\nlayer code.\n\nThis modularity allows Snake operators to choose the most logical network transport for the\ngiven environment without affecting Snake’s other functionality. When using a compromised\nHTTP server as part of the Snake P2P network, the operators can ensure that all traffic to\nthis machine follows the Snake custom HTTP protocol and thereby blends effectively with\nlegitimate traffic. In the context of a compromised machine that legitimately allows secure\nshell (SSH) connections, Snake can utilize its custom raw TCP socket protocol instead of its\ncustom HTTP protocol. All other layers of the Snake protocol stack, from the immediately\nadjacent transport encryption layer to the distant command processing layer, can and do\nremain entirely agnostic to the transport layer as long as it implements its interface correctly.\nThis architecture also allows the Snake developers to easily substitute a new\ncommunications protocol when they believe one has been compromised, without\nnecessitating any downstream changes in the code base. Lastly, this design facilitates the\ndevelopment of fully interoperable Snake implants running on different host operating\nsystems.\n\nSnake’s technical sophistication extends from the software architecture into the lower-level\nsoftware implementation. Original versions of Snake were developed as early as 2003,\nbefore many of the modern programming languages and frameworks that facilitate this type\nof modular development were available. Snake is written entirely in C, which provides\n\n\n-----\n\nsignificant advantages in low-level control and efficiency, but which does not provide direct\nsupport for objects or interfaces at the language level and provides no assistance with\nmemory management. The developers of Snake successfully implemented the implant’s\ncomplex design in C with very few bugs, including careful avoidance of the common pitfalls\nassociated with null-terminated strings and the mixing of signed and unsigned integers.\nAdditionally, the developers demonstrate an understanding of computer science principles\nthroughout the implant’s implementation. This includes selecting and correctly coding\nasymptotically optimal algorithms, designing and utilizing efficient custom encoding\nmethodologies that closely resemble common encoding schemes, and handling the\nnumerous possible errors associated with systems-level programming in a secure manner.\n\n**Capitalizing on Mistakes**\n\nAlthough the Snake implant as a whole is a highly sophisticated espionage tool, it does not\nescape human error. A tool like Snake requires more familiarity and expertise to use\ncorrectly, and in several instances Snake operators neglected to use it as designed. Various\nmistakes in its development and operation provided us with a foothold into the inner workings\nof Snake and were key factors in the development of capabilities that have allowed for\ntracking Snake and the manipulation of its data.\n\nThe FSB used the OpenSSL library to handle its Diffie-Hellman key exchange. The DiffieHellman key-set created by Snake during the key exchange is too short to be secure. The\nFSB provided the function DH_generate_parameters with a prime length of only 128 bits,\nwhich is inadequate for asymmetric key systems. Also, in some instances of what appeared\nto be rushed deployments of Snake, the operators neglected to strip the Snake binary. This\nled to the discovery of numerous function names, cleartext strings, and developer comments\nas seen in the following figure.\n\n\n-----\n\n### SNAKE HOST-BASED TECHNICAL DETAILS\n\nThe FSB has quickly adapted Snake when its capabilities have been publicly disclosed by\nprivate industry. Snake therefore exists in several variants, as it has evolved over almost 20\nyears. This CSA focuses on one of the more recent variants of Snake that up until now has\nnot been widely disclosed. Older variants of Snake will be discussed briefly where\napplicable, but not discussed in depth, as many details of earlier Snake variants already exist\nin the public domain.\n\n**Installer**\n\nThe Snake installer has gone by various names throughout Snake’s existence (e.g.,\n“jpinst.exe”). This advisory will describe the version of the installer which regularly used the\nname “jpsetup.exe”. This executable is packed using a customized obfuscation methodology.\nThe developers appear to have added the unpacking functionality from an open source\nproject for viewing JPEG files. This technique serves to obfuscate the unpacking code within\nan otherwise legitimate code base. The unpacking code extracts an executable, herein\nreferred to as the “Png Exe”, and it extracts an AES encrypted blob from the Png Exe’s\nresources, which herein will be referred to as the “Png Resource”.\n\nThe jpsetup.exe installer requires two arguments to be passed via the command line for\nexecution. The first argument is a wide character string hashed with SHA-256 twice, and the\nresulting value of these computations becomes the AES key that decrypts the Png\nResource. The AES initialization vector (IV) consists of the first 16 bytes of the second\nargument to jpsetup.exe after prepending the argument with a wide character “1” string.\nOnce decrypted, the Png Resource becomes an executable that will be referred to herein as\n“Stage 2”.\n\nWhen unpacked, many components are extracted from Stage 2’s resources. Several of the\nresources are executables with additional resources of their own. Stage 2 creates structures\nfrom its resources, which ultimately become the host artifacts of Snake.\n\n**On-Disk Components**\n\nAs Windows has been the most prevalent operating system targeted by Snake, this\ndocument will only discuss the Windows-based artifacts; however, Snake can be crosscompiled and is capable of running on other operating systems.\n\n_On-Disk Obfuscation_\n\nSnake’s host architecture and network communications allow an unusual level of stealth.\nSnake makes inventive use of its kernel module in both of these contexts. All known\nWindows versions of Snake have used a concealed storage mechanism to hide host\ncomponentry. In addition to using the kernel module to remove the relevant components from\nany listing returned by the operating system, Snake utilizes the kernel module to mediate any\n\n\n-----\n\nrequests between Snake s user mode components and the concealed storage mechanism,\nwhich itself is encrypted with a unique per-implant key. This unique keying creates detection\ndifficulties even for tools that are independent of the compromised operating system, since\nsimple signatures targeting Snake host components would be ineffective.\n\n_Persistence Mechanism_\n\nThe Snake version primarily discussed in this advisory registers a service to maintain\npersistence on a system. Typically, this service is named “WerFaultSvc,” which we assess\nwas used to blend in with the legitimate Windows service WerSvc. On boot, this service will\nexecute Snake’s WerFault.exe, which Snake developers chose to hide among the numerous\nvalid Windows “WerFault.exe” files in the %windows%\\WinSxS\\ directory. Executing\nWerFault.exe will start the process of decrypting Snake’s components and loading them into\nmemory.\n\n\n-----\n\n_Encrypted Registry Key Data_\n\nUpon execution, Snake’s WerFault.exe will attempt to decrypt an encrypted blob within the\nWindows registry that is typically found at\nHKLM:\\SOFTWARE\\Classes\\.wav\\OpenWithProgIds. The encrypted data includes the AES\nkey, IV, and path that is used to find and decrypt the file containing Snake’s kernel driver and\nkernel driver loader. The registry object’s structure can be seen on the right side of the\nfollowing figure. Snake uses Microsoft Windows Cryptography API: Next Generation (CNG)\nkey store to store the AES key needed to decrypt the registry object.\n\n\n-----\n\n_Kernel Driver and Custom Loader_\n\nSnake’s installer drops the kernel driver and a custom DLL which is used to load the driver\ninto a single AES encrypted file on disk. Typically, this file is named “comadmin.dat” and is\nstored in the %windows%\\system32\\Com directory. The structure of this file can be seen on\nthe left side of the figure above. The key, IV, and path to comadmin.dat are stored in the\nencrypted registry blob.\n\n_The Queue File_\n\nThe last host-based artifact to discuss is the Queue File. Typically, this file has been found\nwithin the %windows%\\Registration directory with the format of <RANDOM_GUID>.\n<RANDOM_GUID>.crmlog, and is decrypted by Snake’s kernel driver. Due to the complexity\nand importance of the Queue File, its details are discussed at length in the following\nsubsection.\n\n**The Queue**\n\nThe Queue is a Snake structure that contains various pieces of information, including key\nmaterial, communication channels, modes of operation, the principal user mode component,\netc., that Snake requires for successful operation. It should be noted that this is a name used\nby the developers and is not equivalent to a “queue” in the normal context of computer\nscience. The Queue data is saved on disk in the Queue File, which is a flat file with a\n\n\n-----\n\nsubstructure that includes a 0x2c-byte file header followed by data blocks. Each data block\ncorresponds to exactly one Queue Item, which could be, for example, a simple configuration\nparameter, a Snake command, or an entire embedded executable. Each Queue Item is\nassociated with a specific Queue Container.\n\n_Queue Containers and Items_\n\nEach Container is identified by its Type and Instance values. Each Container Type holds the\nsame type of information used by the Snake implant for a specific purpose. The following\ntable shows the various Container Types and their functions. A Queue can have multiple\nContainers of the same Type, but each of these Containers will have different Instance\nvalues.\n\nThe data in each Container in the Queue is separated into Queue Items with the 0x40-byte\nmetadata structure shown in the following table. The data content of the Queue Item\nimmediately follows this structure. The Queue Items in each Container are distinguished by\ntheir corresponding Item Number as well as their Item Type identifier. The Item Number is\nassigned by the Snake implant itself, while Snake operators generally refer to the Item Type\nvalue when trying to reference a specific item.\n\n\n-----\n\n_Queue File Encryption_\n\nIn previous versions of Snake, the Queue File existed within an encrypted covert store. The\ndata belonging to the Queue Items themselves were also CAST-128 encrypted. In more\nrecent versions, the covert store was removed, and the Queue File exists by itself on disk.\nThe Queue Items inside the Queue File are still encrypted with CAST-128, and in addition,\nthe full Queue File is also CAST-128 encrypted. The CAST keys used to encrypt the Queue\n\n\n-----\n\nItems within a Container Instance can be found in that Instance s corresponding 0x2\nContainer as Item Type 0x229 (see below). The key and IV used to encrypt the Queue File\ncan be found by decoding strings within Snake’s kernel driver.\n\n_Container Descriptions_\n\n0xb Container\n\nThe 0xb Container lists the available modes of operation for a given Snake implant. When\nusing a certain mode, Snake uses a specific set of Containers and communication channels.\nEach infection can use up to four different modes. Each mode in the 0xb Container will have\na Container Instance value that all Containers associated with this mode will use, except for\nthe 0x3 Container.\n\n\n-----\n\n0x0 Container\n\nThe 0x0 Container handles incoming commands/data for the host of the Snake infection.\nCommands will be queued in this Container until the implant is ready to execute them.\n\n0x1 Container\n\n\n-----\n\nThe 0x1 Container handles outbound commands/data for the host of the Snake infection.\nThe data will be queued within the 0x1 Container until the implant is ready to exfiltrate them.\n\n0x2 Container\n\nThe 0x2 Container holds the configuration information for the mode to which it corresponds.\nVarious pieces of information vital to Snake’s successful operation are stored within these\nContainers. This subsection will discuss a subset of the parameters that can be found within\nthe 0x2 Container.\n\n\n-----\n\n-----\n\nPivotal key information can be found within the 0x2 Containers. This includes the inbound\nand outbound RSA keys (Items 0x228 and 0x227, respectively), the CAST key (Item 0x229)\nused to encrypt the individual items within the Queue Container, pre-shared keys used for\nthe top layer of encryption in Snake’s network communication protocol, and a quasi-unique\nvalue for the implant, called the “ustart” value, needed for Snake network connectivity.\n\nSnake is constantly passing data between its kernel and user mode components. The\nmethodology (generally, named pipes) used to make these communications is listed in Items\n0x65-0x6f of the 0x2 Container. Items 0x70-0x7a list the parameters necessary to establish\nthese communications.\n\nItems 0xc9-0xd3 contain details of up to ten other Snake infections, referred to as\n“communication channels”, which the implant can communicate with during Passive\nOperations. The parameters needed to establish Snake sessions with the other hosts can be\nfound in Items 0xd4-0xde.\n\nMany additional data points, such as the process name where Snake injected itself or the\nmodules Snake has loaded from its 0x3 Container, can be found within 0x2 Containers.\n\n0x3 Container\n\nThe 0x3 Container houses embedded files and modules for Snake. A single 0x3 Container\nwill be accessible to all Containers in the Queue. The 0x3 Container has its own dedicated\n0x2 Container that only includes a single Queue Item of Item Type 0x229 (a CAST-128 key).\nThis key will be used to encrypt and decrypt all of the embedded files and modules within the\n0x3 Container.\n\n\n-----\n\nThe Item Types assigned to the embedded files and modules within the 0x3 Container are\nconsistent across all of the Snake infections within Snake’s P2P network. For example, the\n0x01 Item Type is the Zlib library, and therefore any time an Item Type of 0x01 is seen within\nthe 0x3 Container of a Snake infection, that file is always the Zlib library. The implant’s 0x2\nContainer will keep track of libraries that it has loaded. If the DLL is a file on disk, the full path\nto the DLL is saved in the 0x2 Container. If the library was loaded from a 0x3 Container, the\nloaded module will be displayed in the implant’s 0x2 Container in the format “&<Item Type\n(within 3 container) of loaded module>”.\n\n0x4 Container\n\nThe 0x4 Container logs command activity. Each Queue Item within the Container is a log of a\nsingle executed or attempted command. Each mode will have its own corresponding 0x4\nContainer.\n\n\n-----\n\n0x5 Container\n\nThe 0x5 Container holds Snake network logs, noting any IP address that has connected to\nthis implant. Some versions of Snake no longer make use of this Container.\n\n0x6 Container\n\nThe 0x6 Container saves commands that are set to execute at specific times. A Queue Item\nis created for each scheduled command.\n\n0x7 Container\n\nThe 0x7 Container logs the IP addresses of any other Snake implants that have connected\nto this implant during Passive Operations. The commands 0x79 (Read Agents Track) and\n0x7a (Clear Agents Track) are used to interact with this Container. Note that the command\n0x7a had been deprecated in some versions of Snake and returns the error “function\nunsupported” if called.\n\n### SNAKE NETWORK COMMUNICATIONS\n\nSnake’s network communications are encrypted, fragmented, and sent using custom\nmethodologies that ride over common network protocols, including both raw TCP and UDP\nsockets and higher-level protocols like HTTP, SMTP, and DNS. Snake’s protocols for HTTP\nand TCP are the most commonly seen, but functionality exists for UDP, ICMP, and raw IP\ntraffic. Snake’s network communications are comprised of “sessions”, which are distinct from\nthe sessions associated with the legitimate protocol it is riding on top of (e.g., TCP sessions).\nThe Snake session is then comprised of distinct commands. Both Snake’s custom transport\nencryption layer (“enc”) and Snake’s Application Layer have their own encryption\nmechanisms, where the enc layer operates on an individual P2P session and the Snake\nApplication Layer provides end-to-end encryption between the controller (i.e., point of origin)\nand the command’s ultimate destination. The following figure details Snake’s communication\nprotocol stack.\n\n\n-----\n\n**Network Obfuscation**\n\nSnake’s use of its kernel module also facilitates stealthy network communications. To\nparticipate fully in Snake’s P2P network, implanted machines which are not the ultimate\ntarget must act as servers for other Snake nodes. Snake’s kernel module, along with a\nthoughtfully designed mechanism for distinguishing Snake traffic from legitimate client traffic,\nallows the implant to function as a server in the Snake P2P network without opening any new\nports, greatly complicating detection efforts. Additionally, Snake’s custom network\ncommunication protocols are designed to blend with traffic that the compromised server\nnormally would receive. This allows Snake operators to use legitimate servers as\ninfrastructure, which reduces the effectiveness of simple IP address or domain blocking\nwithout needing to open new ports or send unusual looking traffic to this infrastructure.\n\n**Snake’s Network Authentication Technique (“ustart”)**\n\nSnake uses its custom HTTP and raw socket TCP based protocols for large data\ncommunications. With these protocols and others, Snake employs a specific authentication\nmechanism to distinguish Snake traffic from legitimate traffic destined for application\nsoftware on the compromised server. This technique enables one of the uniquely\nsophisticated aspects of Snake, which is its ability to function effectively as server software\n\n\n-----\n\nwithout opening any further ports on the compromised system. The relevant per-implant\nauthentication value is referred to as the “ustart” and is stored in the implant’s Queue File.\nThere are multiple forms of the ustart value, including “ustart”, “ustart2”, and “ustartl”.\n\nRather than open a listening socket on a specified TCP port, the Snake kernel module\nintercepts the first client-to-server packet following the 3-way handshake in every TCP\nsession. The kernel module then determines whether or not the contents of that packet are in\nfact valid for the ustart value of that target Snake implant. If so, the Snake kernel module\nforwards that packet and any future packets in the same TCP session to Snake’s own\nprocessing functionality, and the (presumably legitimate) application listening on that port\nremains unaware of this TCP session. If not, the Snake kernel module allows the packet—\nand the rest of the TCP session as it occurs—to reach the legitimate listening application, for\nexample web server software. See the following for an illustration.\n\nAll of the ustart versions perform authentication by sending a random nonce along with data\nthat comprises a mathematical operation on the combination of the nonce and the ustart\nvalue itself. The receiving machine then extracts the nonce and performs the same\ncomputations to authenticate the sending machine. The ustart2 and ustartl versions use the\n\n\n-----\n\nFowler-Noll-Vo (FNV) hash algorithm to generate the overall authentication value from the\nnonce and the ustart. This mechanism is slightly different in the custom Snake HTTP\nprotocol versus the custom Snake TCP protocol.\n\nUsing the ustart methodology, a node in the Snake P2P network can function as a server\nwithout opening any otherwise closed ports and without interfering in the compromised\nserver’s legitimate functionality. Snake will only communicate over TCP ports on which\nanother application is actively listening. This technique makes detecting Snake compromises\nthrough network traffic monitoring far more difficult. Inbound traffic to an unexpected TCP\nport can be detected or blocked using standard firewall or network intrusion detection\nfunctionality. Replacing a legitimate service application with a modified executable can lead\nto detection at either the host or network level. Snake’s technique bypasses both of these\nmitigations. When combined with the fact that Snake traffic looks similar to expected traffic,\nespecially in the case of Snake’s HTTP based protocols, this renders detecting Snake\ncommunications difficult absent detailed knowledge of Snake’s custom protocols.\n\n**Snake UDP**\n\n_Outbound Communications via DNS Query_\n\nSnake uses a specialized communications protocol to encode information in seemingly\nstandard DNS queries run via the Windows or POSIX API function gethostbyname,\ndepending on the version.\n\nSnake outbound DNS requests consist of character strings that are constructed to resemble\nstandard domain names. The actual information being transmitted from the implant is\ncontained in the part of the character string prior to the first ‘.’ character. For illustration\npurposes, this subsection will outline how an arbitrary string of bytes is manipulated and then\nencoded to form an outbound Snake DNS request carrying data provided by the implant.\n\nSnake outbound DNS requests originally take the form of byte arrays stored on the stack as\nthe implant progresses through the communications function. The byte array has the\nfollowing structure.\n\n\n-----\n\nOnly the low-order seven bits of the flags byte are used, and they have the following\nsignificance.\n\nAfter calculating and obfuscating the byte array values shown above, Snake encodes these\nbyte values as de-facto base32 text, using the ten digits 0-9 and the 26 lowercase ASCII\nletters a-z, with v, w, x, y, and z all corresponding to the same value, as only 32 distinct\ncharacters are needed. Snake then inserts ‘-‘ characters at specified locations and sends the\nDNS request using the gethostbyname function. The resulting encoded string mimics a\nlegitimate DNS request; because characters after the first ‘.’ are not part of the implant’s\ncommunications, any arbitrary suffix (e.g., “.com”) can be used.\n\n_Inbound Communications via DNS Query Response_\n\nAfter sending the encoded DNS request, Snake parses the returned information. In a normal\nDNS request, the returned hostent structure contains a list of IPv4 addresses as 32-bit\nunsigned integers if the domain resolves to one or more IPv4 addresses. In the Snake DNS\nprotocol, these 32-bit integers represent the covert channel data. The Snake implant sorts\n\n\n-----\n\nthe 32-bit integers by the highest order nibble and then interprets the remaining 28 bits of\neach integer as the actual encoded data. The Snake DNS protocol thus provides a wellconcealed, low-bandwidth communications channel. For larger bandwidth communications,\nSnake uses its custom HTTP and TCP protocols.\n\n**Snake HTTP**\n\nThe most common custom protocol that Snake uses is its “http” protocol, which rides on top\nof standard HTTP. It generally looks like normal HTTP communications, including a lot of\nbase64-looking strings, thus blending well with normal network traffic. There have been\nmultiple iterations of Snake’s http protocol, though the differences are only in the encoding;\nonce that is peeled away, the underlying Snake http protocol is the same. For the purposes\nof this document, Snake’s former version of HTTP will be referred to as “http” and its more\nrecent version as “http2”.\n\nSnake communications using http2 are contained within seemingly legitimate Application\nLayer HTTP communications. In the client-to-server direction, the implant data is contained\nwithin an HTTP header field of a GET request, unless the data is over a certain size (usually\n256 bytes, but configurable). Observed field keys have included: Auth-Data, Cache-Auth,\nCookie, and Cockie (note misspelling). This list is not exhaustive; any standard HTTP header\nfield can be used. The communication itself is contained in the legitimate HTTP header\nfield’s value, meaning the content following the ‘:’ character and any whitespace immediately\nthereafter. In HTTP GET requests, the implant generally uses the default path ‘/’, but this is\nnot required and is configurable. Larger client-to-server Snake http2 requests are contained\nin the body of an HTTP POST request, and server-to-client communications are contained in\nthe body of the HTTP response.\n\nAll client-to-server Snake http and http2 requests begin with the ustart authentication. The\nspecifics vary with each ustart version, but in each case the random nonce and the\ncomputed function of the nonce and ustart value are encoded in a manner which closely\nresembles the rest of the Snake communication. Since Snake http and http2 implant\nsessions can span multiple TCP sessions, the ustart authentication mechanism is included in\nevery client-to-server communication.\n\n_Base62 Encoding_\n\nSnake’s http2 protocol uses a custom base62 encoding scheme that has the following\ndifferences from base64. Base62 uses 62 semantically significant characters instead of 64.\nThe ratio of encoded-to-decoded characters in base62 is less dense (11:8) than the ratio\nbase64 can achieve (12:9). Also, base62 uses extraneous characters in certain instances\nthat have no semantic significance.\n\n\n-----\n\nThe base62 characters of semantic significance are the 62 strict alphanumeric characters:\n\n[0-9A-Za-z]. The extraneous characters that can be present in a base62 string—but which\nhave no semantic significance—are: ‘/’, ‘;’, ‘=’, and ‘_‘ (underscore). When present, these\ncharacters are removed prior to performing the decoding process. A valid base62 string can\nhave up to 11 of these extraneous characters. A regular expression for base62 is included in\nthe Mitigations section of this CSA.\n\n_http and http2 Metadata Structure_\n\nAfter the base62 decoding is completed, if necessary, the remaining data begins with an 8byte metadata structure that provides rudimentary sessionization on top of the stateless\nHTTP. Snake’s http and http2 client-to-server communications have three de-facto parts,\nwhich are concatenated into a single HTTP header value. These parts are: 1) an announce\nor authentication string, 2) a custom metadata structure, and 3) payload data. The metadata\nstructure consists of the following:\n```\nstruct http_meta {\n\n    uint32_t session_number;\n\n    uint16_t communication_number;\n\nuint8_t flags;\n\nuint8_t checksum;\n\n};\n\n```\nSnake uses the session_number and communication_number fields to provide its own\ncustom sessionization on top of the stateless Application Layer HTTP protocol. The\nchecksum byte serves to validate the integrity of the structure and must equal the sum of the\nfirst seven bytes modulo 256.\n\n**Snake TCP**\n\nSnake has the ability to communicate through POSIX-style TCP sockets. The implant’s\ncustom TCP protocol, which herein will be called “tcp”, uses thereliability features of the\nunderlying TCP protocol. Thus, in the implant’s custom tcp protocol, the concept of a TCP\nsession and an implant “session” are the same, whereas in the implant’s custom http\nprotocols, one implant session could span multiple Transport Layer TCP sessions. Since the\nimplant’s overall communications protocol is based on the idea of commands and responses,\nSnake depends on being able to specify the length of any given command and response so\nthe recipient Snake node knows when a particular communication ends. Snake achieves this\nin the custom tcp protocol by prefacing eachcommunication with its length encoded as a 32bit big-endian unsigned integer.\n\nImmediately following the TCP 3-way handshake, the implant completes the ustart\nauthentication for this session. Since Snake tcp sessions are mapped one-to-one with an\nunderlying protocol TCP session, the ustart authentication only occurs once per session,\nrather than with each client-to-server communication as in Snake http and http2. The Snake\n\n\n-----\n\ntcp ustart mechanism is similar to the Snake http and http2 mechanisms, except that for\ncertain ustart versions, Snake tcp uses a raw binary ustart which is not encoded in printable\ncharacters.\n\nAfter the ustart authentication, the implant will begin sending length-data pairs. These pairs\ncan be sent in the same packet or in two (or theoretically more) separate packets, but the\npattern of length-data pairs will be present in each half of the stream (i.e., each direction) for\nthe entirety of the implant communications for the remainder of the TCP session. Specifically,\na length-data pair will consist of the length encoded as a big-endian 32-bit unsigned integer\nfollowed by data of exactly that length. For example, consider the instance where the implant\nis sending the following 4 arbitrary bytes:\n```\n89 ab cd ef\n\n```\nThe on-wire communication from the implant would send the integer value 4 encoded as a\nbig-endian 32-bit integer, followed by the actual 4 bytes themselves, as shown below. This\ncould be split across two (or theoretically more) packets.\n```\n00 00 00 04 89 ab cd ef\n\n```\nThe custom tcp protocol (as well as all custom http protocols) have been used in conjunction\nwith the Snake enc protocol. Details of the Snake enc protocol are provided in the following\nsubsection. Due to the manner in which the Snake enc and Snake tcp protocols interact, the\nfirst six length-data pairs of each TCP half-stream (following the single client-to-server\nannounce or authentication packet described above) will have known lengths. Specifically,\neach half-stream will begin with length-data pairs of the following lengths: 0x8, 0x4, 0x10,\n0x1, 0x10, 0x10. Note that these are the lengths of the raw data, so each communication will\nbe preceded by a 4-byte big-endian integer specifying the corresponding length. Thus, one\nof the half-streams could have the following TCP content:\n```\n00 00 00 08 12 34 56 78 9a bc de f0\n\n00 00 00 04 89 ab cd ef\n\n00 00 00 10 12 34 56 78 9a bc de f0 12 34 56 78 9a bc de f0\n\n00 00 00 01 12\n\n00 00 00 10 12 34 56 78 9a bc de f0 12 34 56 78 9a bc de f0\n\n00 00 00 10 12 34 56 78 9a bc de f0 12 34 56 78 9a bc de f0\n\n\n```\n**Snake “enc” Layer**\n\nAs described above, Snake communications are all comprised of “Snake sessions”,\nirrespective of whichever legitimate protocol Snake is operating on top of. Snake’s top layer\nof encryption, called the enc layer, utilizes a multi-step process to establish a unique session\nkey. The session key is formed through the combination of a Diffie-Hellman key exchange\nmixed with a pre-shared key (PSK) known to both parties. This PSK is stored in one of the\ncommunication channels, stored within the Queue.\n\n\n-----\n\nThe overall establishment of the session key requires 12 communication steps, six in each\ndirection, which involve sharing the pseudo-random values used in the Diffie-Hellman\nexchange process as well as custom aspects of the Snake session key derivation method.\nThe session key is used to encrypt the command headers and (inner) encrypted payloads.\n\nThis is the layer in which the critical error of providing a value of 128 bits instead of 128 bytes\nfor the call to DH_generate_parameters within the OpenSSL library occurred. Due to this\ninsufficient key length, breaking the Diffie-Hellman portion of the exchange is possible. Note\nthat in the following figure, the variables ‘p’, ‘g’, ‘a’, and ‘b’ are used in standard descriptions\nof Diffie-Hellman.\n\n### SNAKE APPLICATION LAYER\n\nSnake’s Application Layer is used to process Snake commands. The payload data for a\nSnake session can contain one or more command exchanges, which include both the\nincoming data sent to the implant as well as the response returned to the server. Each\ncommand is associated with a specific ordinal, and due to Snake’s modular design,\noperators are able to add new commands to extend Snake’s capabilities by remotely loading\na new module.\n\nThe Snake implant differentiates between High and Low commands and handles them\ndifferently, based on the ordinal number range. The majority of Snake commands are High\ncommands that have an ordinal of 0x64 (100 decimal) or higher. There are far fewer Low\ncommands, and these include the Forwarding command (with ordinal 0x1), and the four\n\n\n-----\n\nQueue commands (with ordinals 0xa, 0xb, 0xc, and 0xd). While Low commands are mostly\nused for moving data across the network, the High commands give the operator many\noptions for interacting with an infected system.\n\n**Command 0x15-byte Header**\n\nAll commands begin with a 0x15-byte header, followed by optional command parameter\ndata; only some commands require parameters for successful execution. For example, the\ncommand Get, which exfiltrates a file, requires the name of the file to exfiltrate, whereas the\ncommand Process List, which returns a process listing, does not require any parameters.\n\nThe most important Command Header field contains the integer ordinal of the command\nbeing sent. The Item UID field represents a unique identifier for each individual command\ninstance, and these values increase sequentially. The header has two fields used when a\ncommand is set to run at a specified date and time; these commands will be written to the\n0x6 Container.\n\nSome Low commands have another header before the payload data, which will be detailed\nbelow. All other commands have only the Command Header followed by the encrypted\nparameter data.\n\n**Command Encryption**\n\nUnderneath Snake http2 or tcp encryption at the session layer, each command exchange is\nfurther encrypted. In older versions of Snake, the exchanges were CAST-128 encrypted\nusing a different key for incoming and outgoing data. These keys were saved in the 0x2\nContainer in the 0x227 and 0x228 Items. The incoming payload data, if parameter data was\npresent, could be decrypted with the 0x227 CAST key. Any response data was encrypted\nwith the 0x228 CAST key.\n\nIn recent versions, the 0x227 and 0x228 Items hold two RSA-4096 public keys. For each\nside of an exchange, a new 16-byte CAST key is created with Microsoft’s CryptoAPI\nCryptGenRandom function to obtain 16 random bytes. This key is used to CAST-128 encrypt\nthe parameter or response data.\n\n\n-----\n\nFor an incoming command, the CAST key is signed (not encrypted) by the private key\ncorresponding to the public key on the node to create a 512-byte RSA data blob. The\nincoming payload has the RSA blob, followed by the optional parameter data, which is\nCAST-128 encrypted. Snake uses the 0x227 RSA public key to decrypt the RSA blob,\nrecover the CAST key, then decrypt the parameter data.\n\nFor an outgoing command, a new CAST key is obtained from CryptGenRandom, and any\nresponse data is CAST-128 encrypted. The key is then encrypted using the 0x228 public key\nto create a 512-byte data blob. The response payload data contains the 512-byte RSA blob,\nfollowed by the encrypted response data, when present.\n\n**Command Decoding**\n\nThe implant will expect data in a specific format for each command ordinal. Parameter and\nresponse data contain several possible underlying data types, including wide-character\nplaintext strings, numeric values, data tables, files, or a combination of multiple types.\n\nThe parameter data buffer itself will be formatted in a specific way, depending on the\ncommand ordinal. Some commands have required parameters, as well as optional\nparameters. Commands with optional parameters will include a metadata header with the\ndata length and data type (e.g., bool, integer, text, or data buffer) before the optional\nparameter’s data. Other commands will expect the parameters to be formatted with lengthdata pairs, consisting of the parameter data length encoded as a four-byte big-endian integer\nfollowed by data of exactly that length. Still other commands have a custom header or will\nexpect no length or metadata and will simply send the parameter data alone.\n\nThe response data will similarly be formatted by the implant in a specific way according to\nthe command ordinal. The response data typically does not have a length or metadata\npreceding it, with the exception of the data tables. Examples of commands that return a table\nare the Process List command and the List Dir command.\n\nResponse data that includes a table will start with a table description header that indicates\nthe number of columns and rows in the table. In addition, the header will include a Column\nDescriptor structure to indicate the type of data that column will contain, for example a string,\nuint32 or uint64, timestamp in epoch format, or the contents of a whole file (included as a\ntable entry).\n\nAfter the table description header, each field is added to the data payload buffer one at a\ntime in a length-data pair. The fields across the first row are added in order, then the fields\nacross the second row are added immediately after the first row with no metadata or\nseparation, and so on. To parse this table, the server will account for the number of columns\nto determine where the next row starts.\n\n**High Commands**\n\n\n-----\n\nHigh commands are those with an ordinal of 0x64 (decimal 100) or higher. High commands\ngive the operator many options for interacting with an infected system, as well as implant\ncomponents. This subsection will describe some examples of the many High commands that\ncan exist in the implant.\n\nSome of the most basic High commands will gather information about the machine and\nreturn the results. For example, the FSB operators can use the PS command (0x65) to return\na list of running processes, the List Dir command (0x840) to list the contents of a directory, or\nthe Syst command (0x6b) to gather basic system information.\n\nThere are several commands that interact with the infected machine using standard built-in\nOS tools. The operator can use the Kill command (0x67) to kill a process, the Get command\n(0x68) to exfiltrate a file, the Put command (0x69) to write a file, the Del command (0x6a) to\ndelete a file, or the Run command (0x66) to execute a command in a terminal shell and\nreceive the results. For example, operators have used the Run command to run PowerShell\ncommands, ping other hosts, use the Windows “net use” command to map network drives,\nand to run executable files that had been previously written to the node using the Put\ncommand.\n\n\n-----\n\nIn addition to commands that use the built-in OS functionality, there are several High\ncommands that interact with Snake components. An operator can use the Read Config\ncommand (0x70) to read the 0x2 Container, which contains configuration data, or the Set\nConfig Item command (0x71) to set a specific Queue Item within the 0x2 Container. For\nexample, operators have used the Set Config Item command to add or update the IP\naddresses or domains and option parameters used to communicate with other Snake nodes.\nThe Read Agents Track and Clear Agents Track commands (0x79 and 0x7a) interact with\nthe 0x7 Container to read or delete logs which track which other Snake nodes have\nconnected to this node. Note that the 0x7a command has been deprecated in some versions\nof Snake and returns the error “function unsupported” if called\n\n\n-----\n\nSnake has the ability to add additional commands by loading new modules. New modules\ncan be loaded using the Load Modules command (0x72) or directly into memory using the\nLoad Modules Mem command (0x7f). When compiling a module, the developer will assign\nan ordinal to each constituent command, which will then be used by the operator to call the\nnewly added commands. These loaded modules can be removed using the Module Unload\ncommand (0x73).\n\n**Queue Commands**\n\nQueue Command Header\n\nThe four Queue commands contain a 0x3d-byte Queue Header following the Command\nHeader. In more recent versions of Snake, this header is encrypted using the same CAST\nkey used to encrypt the payload data. In this case, the Command Header is followed by the\n512-byte RSA encrypted CAST key blob, the encrypted Queue Header, and finally the\nencrypted payload data.\n\nEven though each of the four Queue commands only use a subset of the fields of the Queue\nHeader (in different ways), the full header must be present for the command to be\nconsidered valid by the implant. Two fields in the header that all four Queue commands use\nare the Container Instance and Container Type fields, which indicate the specific Container\non a node the Queue command intends to interact with. In the Queue Read and Write\ncommands, the Item Type field is used to track the specific commands and their responses\nin the Containers.\n\nQueue Enumerate Command\n\nThe Queue Enumerate command, with ordinal 0xa, is used to enumerate the contents of the\n0x0 or 0x1 Containers to list all incoming or outgoing commands, respectively. The\nenumeration returns the 0x40-byte structure described above for each Queue Item,\nconcatenated into a single return buffer.\n\nQueue Read Command\n\nThe Queue Read command, with ordinal 0xb, is used to read an Item from the specified 0x0\nor 0x1 Container. Several relevant fields in the Queue Header determine how the data is\nsent and stored. For example, the header determines whether the data should be sent\nimmediately back to the server or stored for later transport. The header indicates if the\nimplant should send the Queue Item’s header (i.e., the same 0x40-byte metadata structure\n\n\n-----\n\nreturned by the 0xa command), the Item s data, or both. The header also indicates whether\nthe Queue Item should be deleted after being read and can also indicate that Queue Items\nwith a lower Item Type should be deleted. This allows FSB operators to clear out all\ncommand Items previous to the one being read.\n\nQueue Write Command\n\nThe Queue Write command, with ordinal 0xc, is used to write a Queue Item to the specified\n0x0 or 0x1 Container. The Queue Header will indicate if a new Queue Item will be created, or\nan existing Queue Item will be modified.\n\nIf a Queue Item is set to be modified, an Item with the specified Item Type must exist in the\nspecified Container. Several fields in the header must match specific attributes of the existing\nQueue Item. If these checks are met, the parameter data is written to the Queue Item. Fields\nin the Queue Header will indicate the length of data to be written, and the offset into the\nexisting Queue Item where the write should begin.\n\nIf a Queue Item is set to be created, Snake will delete existing Queue Items of the specified\nItem Type in the Container of interest, then create a new Item of the specified Item Type and\nwrite the parameter data to the Queue Item. A field in the Queue Header will indicate the\nlength of data to be written.\n\nQueue Delete Command\n\nThe Queue Delete command, with ordinal 0xd, is used to delete a Queue Item from the\nspecified 0x0 or 0x1 Container. The Flags field will determine if the single Queue Item should\nbe deleted, or if all Queue Items with a lower Item Type should be deleted as well.\n\n### Forward Commands\n\nForward commands, with command ordinal 0x1, are used to tell an implant to forward a\nSnake command to a second target node, where the command will be executed. The target\nnode sends the response data back to the first implant, which will then package that\nresponse data as its own response back to the caller.\n\nThe command is designed to tell an implant to forward one command to another implant, but\nin practice, Forward commands are often built on top of each other to create a chain of hop\npoints that will continue to forward a command to an end point, where it will be executed.\nThe response data is then sent back through the same chain of hop points until it reaches\nthe operator.\n\nThe Forward command has a 0x199-byte Forward Header, followed by the encrypted\ncommand parameter data that will be sent to the target node of the Forward command. The\nForward Header contains the information the implant will need to connect to the target node,\nincluding the ordinal of the Snake command that is being forwarded to the target node for\nexecution.\n\n\n-----\n\nThe implant that receives the Forward command will construct a new Snake command of the\nordinal indicated in the Forward Header. It will connect to the target node in a new session,\nconstruct the Command Header, and send the encrypted command parameter data on to the\ntarget node. The parameter data already will have been encrypted using the key associated\nwith the target node, so that the target implant will be able to decrypt the parameter data and\nexecute the command.\n\nWhen the Forward command is constructed, the CAST key used to CAST-128 encrypt the\npayload data—to include the 0x199-byte header and the parameter data to be forwarded—is\nencrypted with the RSA key pair used by the first implant. The parameter data that contains\nthe parameters for the command to be forwarded is also CAST-128 encrypted, but the key\nused to encrypt the parameter data is encrypted with the RSA key pair used by the target\nnode. The first implant knows through the header what command ordinal it is forwarding, but\nit is unable to decrypt the parameter data.\n\nIf the Forward Header sent to the first implant indicates that the command to be forwarded\nwas another Forward command, the first target node will decrypt the parameter data and find\nanother Forward Header. This first target node implant will then go through the same process\nto connect to the next target node, constructing the new command with the ordinal indicated\nin the second Forward Header to send the remaining encrypted parameter data to the next\ntarget node. This will repeat until the command to be forwarded is something other than\nanother Forward command.\n\nThe Command Header and pertinent parameters for each target node are encrypted\nspecifically for that node by the operator before the Forward command is sent into the Snake\nP2P network. To illustrate, the diagram below shows how the buffer might look when several\nForward commands are chained together to include two hop points and an end point. The\nfirst hop point (HP1) will recover the first CAST key and CAST-128 decrypt the rest of the\nbuffer, which will uncover the first Forward Header. HP1 will then forward the remainder of\nthe decrypted buffer to the next hop point (HP2), starting with the second CAST key blob.\nHP2 will recover the second CAST key and CAST-128 decrypt the rest of the buffer, which\nwill uncover the second Forward Header. HP2 will then forward the remainder of the\ndecrypted buffer to the end point, starting with the third CAST key blob. The end point will\nrecover the CAST key, decrypt the command parameter data, and execute the command.\n\nWhen a target machine has executed a forwarded command, the return data is encrypted\nwith that implant’s RSA keys and returned directly to the previous hop point. As the data is\nreturned up the chain in the Snake P2P network, the intermediate hop points do not\nmanipulate the encrypted data, as they do not have the RSA private key necessary to do so.\nIn this manner, the return data is de-facto end-to-end encrypted throughout the P2P network\nuntil it arrives back at the FSB operator.\n\n\n-----\n\n## SNAKE IMPLANT OPERATION\n\nSnake uses two main methods for communication and command execution, namely Passive\nand Active. In general, Snake operators will employ Active operations to communicate with\nhop points within Snake’s infrastructure; however, hop points can and do sometimes operate\nusing Snake’s Passive method. Snake’s end points tend to solely operate using the Passive\nmethod.\n\n### Active Operations\n\nDuring Active operations, Snake commands are issued by an FSB operator or a script to a\ntarget machine, generally through Forward commands (described in the previous section).\nThe response to the command is immediately returned to the point of origin following the\nsame path that the command took to reach its end target, as shown in the previous figure on\nForward command structure.\n\n### Passive Operations\n\nDuring Passive operations, Snake implants operate on their own, without the synchronous\ninteraction of FSB operators. The nodes with which an implant communicates during Passive\noperations are stored within its 0x2 Container(s) as communication channels. Up to ten\ncommunication channels can be present at any time; an operator can change these\nchannels via the Set Config Item command.\n\n\n-----\n\nPassive Intake\n\nDuring Passive operations, the implant will beacon by sending a Queue Read (0xb)\ncommand to one of its stored communication channels that it has chosen at random. These\nQueue Read commands look for a Queue Item within a Container with an Instance Number\nequal to the implant’s UID. The matching UID indicates the Queue Items in this Container are\nintended for the beaconing implant.\n\nIf such a Queue Item is found, the beaconing implant will read in the Queue Item and delete\nit off of the host from which it was read. There can be multiple Queue Items found within the\nspecified Queue Container that was beaconed to; each Queue Read command will read one\nof these items. This process is repeated until all items within the Container are read, which\nthe infrastructure node will indicate by sending a specific error in response to the Queue\nRead. This beaconing will continue to randomly select hosts at nondeterministic time\nintervals for as long as the implant is set to perform Passive operations.\n\nPassive Data Exfiltration\n\nSimilar to how Snake intakes commands passively, it can also exfiltrate the resulting data\npassively. This is done using Queue Write (0xc) commands to write to one of the stored\ncommunication channels chosen at random. Once the data is off the end point node,\noperators generally retrieve it manually or using a script. The Item Type field, which is unique\nper executed Snake command, is needed to associate the exfiltrated data with the target\nnode on which the command was run.\n\nIn the context of Passive Snake communications, the term Item Type is defined as a UID for\na given Snake command and its resulting data. The Item Type serves as a unique identifier\nto associate the results of command execution with the original command written by the\noperator. When the FSB collects the data, Snake knows exactly what infection the data came\nfrom, and therefore it can determine what key to use to successfully decrypt the data.\n\n\n-----\n\nTo illustrate how Passive operations are conducted between the end points, the operator,\nand the hop points in between, see the diagram above, which is explained further by the\nfollowing steps:\n\n\n-----\n\n(1), (2): During Passive operations, the Node randomly chooses a host from amongst\nits stored communication channels and will beacon out to it with a Queue Read\ncommand (Hop Point 1 in this case). The Item Type for these beacons will be one\ngreater than the Item Type of the last command received by the Node, indicating in this\nexample that a command of Item Type 0x08 was the last command that was read in by\nthe Node during Passive operations. This Node will continue to beacon with Item Type\n0x09 until it receives a command, via Passive operations, with an Item Type of 0x09 or\ngreater. The lines are dotted for (1) and (2) as this activity will be repeated at random\nintervals until a successful Queue Read occurs.\n(3), (4): In these steps, the operator uses a Queue Write command to write a command\nto Hop Point that is ultimately intended for the Node. The Item Type of the command\nbeing written to Hop Point 1 is assigned 0x20 (for this example). Note that the path of\nthis command, its execution, and its results making it back to the operator can be\ntracked via the red text.\n(5), (6): The Node continues to beacon out looking for commands to read in (5). The\nreturn (6) is successful, and the command written by the operator to Hop Point 1 (3) is\nread in by the Node, then deleted from Hop Point 1.\n(7), (8): The Node attempts another Queue Read to Hop Point 1, however now the Item\nType is set to 0x21, one greater than the command that was just read in by the Node at\n(5) and (6). This returns an error as Hop Point 1 has nothing else for the Node to read\nin, indicating to the Node that everything at Hop Point 1 was read.\n(9), (10): At this point, the Node has executed the command it read in at (5) and (6) and\nis attempting to send back the results. The Node randomly selects another host from its\nstored communication channels, Hop Point 2 in this case, and sends out a 0xb\ncommand to make sure that the Item Type 0x20, the Item Type of the command it\nexecuted, does not already exist within the Queue of Hop Point 2. If it receives an error,\nthere is no Item with Item Type 0x20 on Hop Point 2, and the Node can proceed to\nsend the command results.\n(11), (12): Here the data from the executed command is written to Hop Point 2 with\nItem Type 0x20 into its 0x1 Container with a 0xc command, the Item Type the\ncommand was initially given at creation (3).\n(13), (14): The Node continues its normal beaconing routine again as seen in (1) and\n(2), searching for Item Type 0x21, one greater than the Item Type of the most recently\nexecuted command. As in (1) and (2), the lines here are dotted to denote that this\nprocess will repeat until there was a successful beacon as in (5) and (6).\n\n\n-----\n\n(15-22): These steps show how the operator retrieves the resulting data that was\nwritten to Hop Point 2. The Queue Enumerate command (15) lists the contents of Hop\nPoint 2’s 0x1 Container, showing the data written by the Node (11). This data is\nidentifiable by its Item Type, namely 0x20. The Queue Read command (17) reads in\nthe Item that was found in Hop Point 2’s Container. The Queue Read command that\nfollows (19) is asking if there is any data left. In this case, the entirety of the data was\nread with the first Queue Read (17, 18). Therefore, the error returned from second\nQueue Read command (20) lets the operator know all of the data from Item Type 0x20\nwas read and there is nothing further. A Queue Delete command (21) follows and is\nsent to delete the item with Item Type 0x20 from Hop Point 2.\nThe subsequent Queue Read, Queue Read, and Queue Delete commands (17-21) are\ndenoted with dashed lines to indicate that this sequence of commands is repeated for\nall items returned from the Queue Enumerate command (15).\n\n## MITIGATIONS\n\nA number of complementary detection techniques effectively identify some of the more\nrecent variants of Snake. However, as described above, Snake is purpose-built to avoid\nlarge-scale detection. Below is a discussion of the advantages and disadvantages of various\ndetection methodologies available for Snake.\n\n**Note that some of the techniques identified in this section can affect the availability or**\n**stability of a system. Defenders should follow organizational policies and incident response**\nbest practices to minimize the risk to operations while hunting for Snake.\n\n### Network-Based Detection\n\nNetwork Intrusion Detection Systems (NIDS) can feasibly identify some of the more recent\nvariants of Snake and its custom network protocols as detailed above.\n\n**Advantages: High-confidence, large-scale (network-wide) detection of custom Snake**\ncommunication protocols.\n\n**Disadvantages: Low visibility of Snake implant operations and encrypted data in transit.**\n**There is some potential for false positives in the Snake http, http2, and tcp signatures.**\nSnake operators can easily change network-based signatures.\n\n**Snake http**\n\nSnake client-to-server http and http2 traffic is contained within an arbitrary HTTP header\nfield. The header field value for http begins with 10 pure alphanumeric characters, followed\nby base64 encoding of 8 bytes, which yields exactly 11 valid base64 characters plus one\nbase64 padding character.\n```\n   ^[0-9A-Za-z]{10}[0-9A-Za-z/\\+]{11}=\n\n```\n\n-----\n\nThe following two Suricata rules will detect the traffic described:\n```\nalert http any any -> any any (msg: \"http rule (Cookie)\";\\\n\n  pcre:\"/[0-9A-Za-z]{10}[0-9A-Za-z\\/\\+]{11}=/C\";\\\n\n  flow: established, to_server;\\\n\n  sid: 7; rev: 1;)\n\nalert http any any -> any any (msg: \"http rule (Other Header)\";\\\n\n  pcre:\"/[0-9A-Za-z]{10}[0-9A-Za-z\\/\\+]{11}=/H\";\\\n\n  flow: established, to_server;\\\n\n  sid: 8; rev: 1;)\n\n\n```\n**Snake http2**\n\nThe header field value for http2 begins with 22 pure alphanumeric characters (base62 with\nnon-extraneous characters), followed by the base62 encoding of at least 8 bytes, which must\ncomprise at least 11 base62 characters with the four extraneous characters allowed. The\nactual requirement is stricter than this expression, since the total number of non-extraneous\ncharacters alone must equal or exceed 11; however, it is not possible to encode that aspect\ninto a regular language.\n```\n   ^[0-9A-Za-z]{22}[0-9A-Za-z/;_=]{11}\n\n```\nThe following two Suricata rules will detect the traffic described:\n```\nalert http any any -> any any (msg: \"http2 rule (Cookie)\";\\\n\n  pcre:\"/[0-9A-Za-z]{22}[0-9A-Za-z\\/_=\\;]{11}/C\";\\\n\n  flow: established, to_server;\\\n\n  sid: 9; rev: 1;)\n\nalert http any any -> any any (msg: \"http2 rule (Other Header)\";\\\n\n  pcre:\"/[0-9A-Za-z]{22}[0-9A-Za-z\\/_=\\;]{11}/H\";\\\n\n  flow: established, to_server;\\\n\n  sid: 10; rev: 1;)\n\n\n```\nSnake tcp\n\nThe client-to-server communication for tcp must begin with the ustart, which is not captured\nin this signature set. Immediately following the ustart, the next client-to-server\ncommunication must be the big-endian 32-bit unsigned integer 8 followed by any 8 bytes of\ndata. The next communication must also be client-to-server, and it must comprise the bigendian 32-bit unsigned integer 4 followed by any 4 bytes of data. The next two\ncommunications must be server-to-client, comprising the integer 8 followed by 8 bytes of\ndata and the integer 4 followed by 4 bytes of data.\n\nThe following six Suricata rules will, in conjunction, detect traffic of the form described:\n\n\n-----\n\n```\nalert tcp any any > any any (msg: tcp rule ;\\\n\n  content: \"|00 00 00 08|\"; startswith; dsize: 12;\\\n\n  flow: established, to_server; flowbits: set, a8; flowbits: noalert;\\\n\n  sid: 1; rev: 1;)\n\nalert tcp any any -> any any (msg: \"tcp rule\";\\\n\n  content: \"|00 00 00 04|\"; startswith; dsize:8;\\\n\n  flow: established, to_server; flowbits: isset, a8; flowbits: unset, a8;\\\n\n  flowbits: set, a4; flowbits: noalert;\\\n\n  sid: 2; rev: 1;)\n\nalert tcp any any -> any any (msg: \"tcp rule\";\\\n\n  content: \"|00 00 00 08|\"; startswith; dsize: 4;\\\n\n  flow: established, to_client; flowbits: isset, a4; flowbits: unset, a4;\\\n\n  flowbits: set, b81; flowbits: noalert;\\\n\n  sid: 3; rev: 1;)\n\nalert tcp any any -> any any (msg: \"tcp rule\";\\\n\n  dsize: 8; flow: established, to_client; flowbits: isset, b81;\\\n\n  flowbits: unset, b81; flowbits: set, b8; flowbits: noalert;\\\n\n  sid: 4; rev: 1;)\n\nalert tcp any any -> any any (msg: \"tcp rule\";\\\n\n  content: \"|00 00 00 04|\"; startswith; dsize: 4;\\\n\n  flow: established, to_client; flowbits: isset, b8; flowbits: unset, b8;\\\n\n  flowbits: set, b41; flowbits: noalert;\\\n\n  sid: 5; rev: 1;)\n\nalert tcp any any -> any any (msg: \"tcp rule\";\\\n\n  dsize: 4; flow: established, to_client; flowbits: isset, b41;\\\n\n  flowbits: unset, b41;\\\n\n  sid: 6; rev: 1;)\n\n### Host-Based Detection\n\n```\n**Advantages: High confidence based on totality of positive hits for host-based artifacts.**\n\n**Disadvantages: Many of the artifacts on the host are easily shifted to exist in a different**\nlocation or with a different name. As the files are fully encrypted, accurately identifying these\nfiles is difficult.\n\n**Covert Store Detection**\n\nThe Snake covert store comprises a file-backed NTFS (usually) or FAT-16 (rarely) filesystem.\nThe filesystem is encrypted with CAST-128 in CBC mode. The encryption key can be either\nstatically hardcoded or dynamically stored in a specified Windows registry location. The IV is\n8 bytes, since CAST-128 has an 8-byte block length. The first byte of the IV for any 512-byte\nblock of the covert store is the 0-indexed block number. The remaining bytes of the IV are\nthe corresponding bytes of the key, meaning that bytes at 0-indexed indices 1 through 7 of\nthe IV are the bytes at 0-indexed indices 1 through 7 of the key.\n```\nWhen statically hardcoded, the encryption key has the following constant value:\n​​​​​​\n\n   A1 D2 10 B7 60 5E DA 0F A1 65 AF EF 79 C3 66 FA\n\n```\n\n-----\n\nWhen stored in the Windows registry, the encryption key is the classname associated with\nthe following key:\n```\n   SECURITY\\Policy\\Secrets\\n\n\n```\nThe following initial 8-byte sequences are known to be used by NTFS or FAT-16 filesystems\nas observed:\n```\n   EB 52 90 4E 54 46 53 20\n\n   EB 5B 90 4E 54 46 53 20\n\n   EB 3C 90 4D 53 44 4F 53\n\n   EB 00 00 00 00 00 00 00\n\n\n```\nFor tool development, the following test vector illustrates the encryption of the first given\nheader above (EB 52 90 …) using CAST-128 with the default key shown above and the IV\nconstructed as described, given this header occurs at the beginning of the first 512-byte\nblock of the covert store.\n\n**Plaintext:   EB 52 90 4E 54 46 53 20**\n\n**Key:       A1 D2 10 B7 60 5E DA 0F A1 65 AF EF 79 C3 66 FA**\n\n**IV:         00 D2 10 B7 60 5E DA 0F**\n\n**Ciphertext:  C2 C7 F4 CA F7 DA 3A C8**\n\nBy encrypting each possible initial filesystem byte sequence with CAST-128 using the key\nobtained from the registry—or the default encryption key if the registry entry does not exist—\nand searching for any file with a size that is an even multiple of 220, it is possible to\nefficiently detect Snake covert stores. Validation can be performed by decrypting the entire\nfile using the outlined methodology and then verifying that it comprises an NTFS or FAT-16\nfilesystem.\n\n**Other On-Disk Artifact Detection**\n\n**Registry Blob**\n\nThe registry blob is generally found at the location listed below. In case it is not present at its\ntypical location, the registry blob can be found by searching the full registry for a value of at\nleast 0x1000 bytes in size and entropy of at least 7.9.\n\n**Typical Name: Unknown (RegBlob)**\n\n**Typical Path: HKLM\\SOFTWARE\\Classes\\.wav\\OpenWithProgIds**\n\n**Characteristics: High Entropy**\n\n**Queue File**\n\n**Typical Name: < RANDOM_GUID >.<RANDOM_GUID>.crmlog**\n\n**Typical Path: %windows\\registration\\**\n\n**Unique Characteristics: High Entropy, file attributes of hidden, system, and archive**\n\n\n-----\n\n**Role: Snake Queue File**\n\nThe Snake Queue File generally has a predictable path and filename structure, in addition to\nbeing high entropy. The Snake Queue File can be located by scanning all files in the typical\nqueue path with filenames matching a regular expression that captures the typical naming\nconvention. Files meeting these criteria should be scanned for high entropy, which is\nperformed by the Yara rule below:\n```\nrule HighEntropy\n\n{\n\n  meta:\n\n    description = \"entropy rule\"\n\n  condition:\n\n    math.entropy(0, filesize) >= 7.0\n\n}\n\n\n```\nThe following UNIX find command will scan files with names matching the GUID-based\nconvention (note that the HighEntropy yara rule is assumed to be contained in a file named\n“1.yar”):\n```\nfind /PATH/TO/WINDOWS_DIR -type f -regextype posix-egrep -iregex \\\n\n  '.*\\/registration/(\\{[0-9A-F]{8}\\-([0-9A-F]{4}\\-){3}[0-9A-F]{12}\\}\\.){2}crmlog' \\\n\n   -exec yara 1.yar {} \\;\n\n\n```\nThe following PowerShell command does the same:\n```\nGet-ChildItem -Recurse -File -Path %WINDOWS% | Where-Object {\n\n $_.FullName -match\n\n '(?i)/registration/(\\{[0-9A-F]{8}\\-([0-9A-F]{4}\\-){3}[0-9A-F]{12}\\}\\.){2}crmlog$'\n\n} | ForEach-Object {\n\n yara 1.yar $_.FullName\n\n}\n\n\n```\n**Comadmin**\n\n**Typical Name: comadmin.dat**\n\n**Typical Path: %windows%\\system32\\Com**\n\n**Unique Characteristics: High Entropy**\n\n**Role: Houses Snake’s kernel driver and the driver’s loader**\n\nThe Snake Comadmin file can be found using analogous techniques to that presented above\nfor locating the Snake Queue File. The following UNIX find command will do so:\n```\nfind /PATH/TO/WINDOWS -type f -regextype posix-egrep -iregex \\\n\n  '.*\\/system32/Com/comadmin\\.dat' \\\n\n   -exec yara 1.yar {} \\;\n\n\n```\nThe following PowerShell command does the same:\n\n\n-----\n\n```\nGet ChildItem Recurse File Path %WINDOWS% | Where Object {\n\n  $_.FullName -match '(?i)/system32/Com/comadmin\\.dat$'\n\n} | ForEach-Object {\n\n  yara 1.yar $_.FullName\n\n}\n\n```\n**Werfault**\n\n**Typical Name: Werfault.exe**\n\n**Typical Path: %windows%\\WinSxS\\x86_microsoft-windows-**\nerrorreportingfaults_31bf3856ad364e35_4.0.9600.16384_none_a13f7e283339a0502\\\n\n**Unique Characteristics: Icon is different than that of a valid Windows Werfault.exe file**\n\n**Role: Persistence mechanism**\n\nThe Snake Werfault.exe file has non-standard icon sizes, which form the basis of the Yara\nrule below. This rule should be run on all files in the typical path, specifically the\n%Windows%\\WinSxS directory.\n```\nrule PeIconSizes\n\n{\n\n  meta:\n\n    description = \"werfault rule\"\n\n  condition:\n\n    pe.is_pe\n\n    and\n\n    for any rsrc in pe.resources:\n\n      (rsrc.type == pe.RESOURCE_TYPE_ICON and rsrc.length == 3240)\n\n    and\n\n    for any rsrc in pe.resources:\n\n      (rsrc.type == pe.RESOURCE_TYPE_ICON and rsrc.length == 1384)\n\n    and\n\n    for any rsrc in pe.resources:\n\n      (rsrc.type == pe.RESOURCE_TYPE_ICON and rsrc.length == 7336)\n\n}\n\n\n### Memory Analysis\n\n```\n**Advantages: High confidence as memory provides the greatest level of visibility into Snake’s**\nbehaviors and artifacts.\n\n**Disadvantages: Potential impact on system stability, difficult scalability.**\n\nCapturing and analyzing the memory of a system will be the most effective approach in\ndetecting Snake because it bypasses many of the behaviors that Snake employs to hide\nitself. With a memory analysis tool, such as Volatility, detection of a Snake compromise may\nbe possible.\n\nSnake’s principal user mode component is injected into a chosen process via a single\n\n\n-----\n\nallocation of PAGE_EXECUTE_READWRITE memory. The starting offset is generally\n0x20000000, however the module does allow for relocation if needed. Additionally, since the\nuser mode component is not obfuscated in any way, a valid PE header can be located at the\nbeginning of the allocated memory region. Further validation can be performed by confirming\nthe presence of strings known to exist in the user mode component also within the memory\nregion. A plugin compatible with Volatility3 which can scan all processes on a system using\nthis method is provided in the Appendix. A screenshot showing the results of the plugin\nsuccessfully detecting Snake is displayed below.\n\n## PREVENTION\n\nNote that the mitigations that follow are not meant to protect against the initial access vector\nand are only designed to prevent Snake’s persistence and hiding techniques.\n\n### Change Credentials and Apply Updates\n\nSystem owners who are believed to be compromised by Snake are advised to change their\ncredentials immediately (from a non-compromised system) and to not use any type of\npasswords similar to those used before. Snake employs a keylogger functionality that\nroutinely returns logs back to FSB operators. Changing passwords and usernames to values\nwhich cannot be brute forced or guessed based on old passwords is recommended.\n\nSystem owners are advised to apply updates to their Operating Systems. Modern versions of\nWindows, Linux, and MacOS make it much harder for adversaries to operate in the kernel\nspace. This will make it much harder for FSB actors to load Snake’s kernel driver on the\ntarget system.\n\n### Execute Organizational Incident Response Plan\n\nIf system owners receive detection signatures of Snake implant activity or have other\nindicators of compromise that are associated with FSB actors using Snake, the impacted\norganization should immediately initiate their documented incident response plan.\n\nWe recommend implementing the following Cross-Sector Cybersecurity Performance Goals\n(CPGs) to help defend against FSB actors using Snake, or mitigate negative impacts postcompromise:\n\n\n-----\n\n**CPG 2.A: Changing Default Passwords will prevent FSB actors from compromising default**\ncredentials to gain initial access or move laterally within a network.\n\n**CPG 2.B: Requiring Minimum Password Strength across an organization will prevent FSB**\nactors from being able to successfully conduct password spraying or cracking operations.\n\n**CPG 2.C: Requiring Unique Credentials will prevent FSB actors from compromising valid**\naccounts through password spraying or brute force.\n\n**CPG 2.E Separating User and Privileged Accounts will make it harder for FSB actors to gain**\naccess to administrator credentials.\n\n**CPG 2.F. Network Segmentation to deny all connections by default unless explicitly required**\nfor specific system functionality, and ensure all incoming communication is going through a\nproperly configured firewall.\n\n**CPG 2.H Implementing Phishing Resistant MFA adds an additional layer of security even**\nwhen account credentials are compromised and can mitigate a variety of attacks towards\nvalid accounts, to include brute forcing passwords and exploiting external remote services\nsoftware.\n\n**CPG 4.C. Deploy Security.txt Files to ensure all public facing web domains have a**\nsecurity.txt file that conforms to the recommendations in RFC 9118.\n\n## APPENDIX\n\n### Partnership\n\nThis advisory was developed as a joint effort by an international partnership of multiple\nagencies in furtherance of the respective cybersecurity missions of each of the partner\nagencies, including our responsibilities to develop and issue cybersecurity specifications and\nmitigations. This partnership includes the following organizations:\n\nCollectively, we use a variety of sources, methods, and partnerships to acquire information\nabout foreign cyber threats. This advisory contains the information we have concluded can\nbe publicly released, consistent with the protection of sources and methods and the public\ninterest.\n\n### Disclaimer\n\nThe information in this report is being provided “as is” for informational purposes only. We do\nnot endorse any commercial product or service, including any subjects of analysis. Any\nreference to specific commercial products, processes, or services by service mark,\n\n\n-----\n\ntrademark, manufacturer, or otherwise, does not constitute or imply endorsement,\nrecommendation, or favoring by co-authors.\n\n### MITRE ATT&CK Techniques\n\nThis advisory uses the MITRE ATT&CK® for Enterprise framework, version 13. See MITRE\nATT&CK for Enterprise for all referenced tactics and techniques. MITRE and ATT&CK are\nregistered trademarks of The MITRE Corporation. This report references the following\nMITRE ATT&CK techniques.\n\n**Technique Title** **ID** **Use**\n\n\nNetwork Connection\nEnumeration\n\n\n[T0840](https://attack.mitre.org/techniques/T0840/) Adversaries may perform network connection\nenumeration to discover information about device\ncommunication patterns.\n\n\nData Obfuscation [T1001](https://attack.mitre.org/techniques/T1001/) Adversaries may obfuscate command and control\ntraffic to make it more difficult to detect.\n\n\nProtocol\nImpersonation\n\nOS Credential\nDumping\n\n\n[T1001.003](https://attack.mitre.org/techniques/T1001/003/) Adversaries may impersonate legitimate protocols or\nweb service traffic to disguise command and control\nactivity and thwart analysis efforts.\n\n[T1003](https://attack.mitre.org/techniques/T1003/) Adversaries may attempt to dump credentials to\nobtain account login and credential material, normally\nin the form of a hash or a clear text password, from\nthe operating system and software.\n\n\nRootkit [T1014](https://attack.mitre.org/techniques/T1014/) Adversaries may use rootkits to hide the presence of\nprograms, files, network connections, services,\ndrivers, and other system components.\n\n\nObfuscated Files or\nInformation\n\n\n[T1027](https://attack.mitre.org/techniques/T1027/) Adversaries may attempt to make an executable or\nfile difficult to discover or analyze by encrypting,\nencoding, or otherwise obfuscating its contents on the\nsystem or in transit.\n\n\nSoftware Packing [T1027.002](https://attack.mitre.org/techniques/T1027/002/) Adversaries may perform software packing or virtual\nmachine software protection to conceal their code.\n\n\n-----\n\nMasquerading [T1036](https://attack.mitre.org/techniques/T1036/) Adversaries may attempt to manipulate features of\ntheir artifacts to make them appear legitimate or\nbenign to users and/or security tools.\n\nNetwork Sniffing [T1040](https://attack.mitre.org/techniques/T1040/) Adversaries may sniff network traffic to capture\ninformation about an environment, including\nauthentication material passed over the network.\n\n\nNetwork Service\nDiscovery\n\nDynamic-link Library\nInjection\n\n\n[T1046](https://attack.mitre.org/techniques/T1046/) Adversaries may attempt to get a listing of services\nrunning on remote hosts and local network\ninfrastructure devices, including those that may be\nvulnerable to remote software exploitation.\n\n[T1055.001](https://attack.mitre.org/techniques/T1055/001/) Adversaries may inject dynamic-link libraries (DLLs)\ninto processes in order to evade process-based\ndefenses as well as possibly elevate privileges.\n\n\nKeylogging [T1056.001](https://attack.mitre.org/techniques/T1056/001/) Adversaries may log user keystrokes to intercept\ncredentials as the user types them.\n\nPowerShell [T1059.001](https://attack.mitre.org/techniques/T1059/001/) Adversaries may abuse PowerShell commands and\nscripts for execution.\n\n\nApplication Layer\nProtocol\n\n\n[T1071](https://attack.mitre.org/techniques/T1071/) Adversaries may communicate using OSI application\nlayer protocols to avoid detection/network filtering by\nblending in with existing traffic.\n\n\nWeb Protocols [T1071.001](https://attack.mitre.org/techniques/T1071/001/) Adversaries may communicate using application layer\nprotocols associated with web traffic to avoid\ndetection/network filtering by blending in with existing\ntraffic.\n\nMail Protocols [T1071.003](https://attack.mitre.org/techniques/T1071/003/) Adversaries may communicate using application layer\nprotocols associated with electronic mail delivery to\navoid detection/network filtering by blending in with\nexisting traffic.\n\nDNS [T1071.004](https://attack.mitre.org/techniques/T1071/004/) Adversaries may communicate using the Domain\nName System (DNS) application layer protocol to\navoid detection/network filtering by blending in with\nexisting traffic.\n\n\n-----\n\nData Staged [T1074](https://attack.mitre.org/techniques/T1074/) Adversaries may stage collected data in a central\nlocation or directory prior to Exfiltration.\n\nValid Accounts [T1078](https://attack.mitre.org/techniques/T1078/) Adversaries may obtain and abuse credentials of\nexisting accounts as a means of gaining Initial\nAccess, Persistence, Privilege Escalation, or Defense\nEvasion.\n\n\nFile and Directory\nDiscovery\n\n\n[T1083](https://attack.mitre.org/techniques/T1083/) Adversaries may enumerate files and directories or\nmay search in specific locations of a host or network\nshare for certain information within a file system.\n\n\nMulti-hop Proxy [T1090.003](https://attack.mitre.org/techniques/T1090/003/) To disguise the source of malicious traffic, adversaries\nmay chain together multiple proxies.\n\n\nNon-Application\nLayer Protocol\n\nMulti-Stage\nChannels\n\n\n[T1095](https://attack.mitre.org/techniques/T1095/) Adversaries may use an OSI non-application layer\nprotocol for communication between host and C2\nserver or among infected hosts within a network.\n\n[T1104](https://attack.mitre.org/techniques/T1104/) Adversaries may create multiple stages for command\nand control that are employed under different\nconditions or for certain functions.\n\n\nNative API [T1106](https://attack.mitre.org/techniques/T1106/) Adversaries may interact with the native OS\napplication programming interface (API) to execute\nbehaviors.\n\nModify Registry [T1112](https://attack.mitre.org/techniques/T1112/) Adversaries may interact with the Windows Registry\nto hide configuration information within Registry keys,\nremove information as part of cleaning up, or as part\nof other techniques to aid in persistence and\nexecution.\n\n\nAutomated\nCollection\n\n\n[T1119](https://attack.mitre.org/techniques/T1119/) Once established within a system or network, an\nadversary may use automated techniques for\ncollecting internal data.\n\n\nData Encoding [T1132](https://attack.mitre.org/techniques/T1132/) Adversaries may encode data to make the content of\ncommand and control traffic more difficult to detect.\n\n\n-----\n\nNon-Standard\nEncoding\n\nNetwork Share\nDiscovery\n\nDeobfuscate/Decode\nFiles or Information\n\nExploit Public-Facing\nApplication\n\nDomain Trust\nDiscovery\n\n\n[T1132.002](https://attack.mitre.org/techniques/T1132/002/) Adversaries may encode data with a non-standard\ndata encoding system to make the content of\ncommand and control traffic more difficult to detect.\n\n[T1135](https://attack.mitre.org/techniques/T1135/) Adversaries may look for folders and drives shared on\nremote systems as a means of identifying sources of\ninformation to gather as a precursor for Collection and\nto identify potential systems of interest for Lateral\nMovement.\n\n[T1140](https://attack.mitre.org/techniques/T1140) Adversaries may use Obfuscated Files or Information\nto hide artifacts of an intrusion from analysis.\n\n[T1190](https://attack.mitre.org/techniques/T1190/) Adversaries may attempt to exploit a weakness in an\nInternet-facing host or system to initially access a\nnetwork.\n\n[T1482](https://attack.mitre.org/techniques/T1482/) Adversaries may attempt to gather information on\ndomain trust relationships that may be used to identify\nlateral movement opportunities in Windows multidomain/forest environments.\n\n\nInstaller Packages [T1546.016](https://attack.mitre.org/techniques/T1546/016/) Adversaries may establish persistence and elevate\nprivileges by using an installer to trigger the execution\nof malicious content.\n\n\nDynamic Linker\nHijacking\n\nInter-Process\nCommunication\n\nArchive Collected\nData\n\n\n[T1547.006](https://attack.mitre.org/techniques/T1547/006/) Adversaries may execute their own malicious\npayloads by hijacking environment variables the\ndynamic linker uses to load shared libraries.\n\n[T1559](https://attack.mitre.org/techniques/T1559/) Adversaries may abuse inter-process communication\n(IPC) mechanisms for local code or command\nexecution.\n\n[T1560.003](https://attack.mitre.org/techniques/T1560/003/) An adversary may compress and/or encrypt data that\nis collected prior to exfiltration.\n\n\nHide Artifacts [T1564](https://attack.mitre.org/techniques/T1564/) Adversaries may attempt to hide artifacts associated\nwith their behaviors to evade detection.\n\n\n-----\n\nService Execution [T1569.002](https://attack.mitre.org/techniques/T1569/002/) Adversaries may abuse the Windows service control\nmanager to execute malicious commands or\npayloads.\n\nLateral Tool Transfer [T1570](https://attack.mitre.org/techniques/T1570/) Adversaries may transfer tools or other files between\nsystems in a compromised environment.\n\nProtocol Tunneling [T1572](https://attack.mitre.org/techniques/T1572/) Adversaries may tunnel network communications to\nand from a victim system within a separate protocol to\navoid detection/network filtering and/or enable access\nto otherwise unreachable systems.\n\nEncrypted Channel [T1573](https://attack.mitre.org/techniques/T1573/) Adversaries may employ a known encryption\nalgorithm to conceal command and control traffic\nrather than relying on any inherent protections\nprovided by a communication protocol.\n\n\nSymmetric\nCryptography\n\nAsymmetric\nCryptography\n\n\n[T1573.001](https://attack.mitre.org/techniques/T1573/001/) Adversaries may employ a known symmetric\nencryption algorithm to conceal command and control\ntraffic rather than relying on any inherent protections\nprovided by a communication protocol.\n\n[T1573.002](https://attack.mitre.org/techniques/T1573/002/) Adversaries may employ a known asymmetric\nencryption algorithm to conceal command and control\ntraffic rather than relying on any inherent protections\nprovided by a communication protocol.\n\n\nDLL Side-Loading [T1574.002](https://attack.mitre.org/techniques/T1574/002/) Adversaries may execute their own malicious\npayloads by side-loading DLLs.\n\n\nCompromise\nInfrastructure\n\n\n[T1584](https://attack.mitre.org/techniques/T1584/) Adversaries may compromise third-party\ninfrastructure that can be used during targeting.\n\n\nMalware [T1587.001](https://attack.mitre.org/techniques/T1587/001/) Adversaries may develop malware and malware\ncomponents that can be used during targeting.\n\nObtain Capabilities [T1588](https://attack.mitre.org/techniques/T1588/) Adversaries may buy and/or steal capabilities that can\nbe used during targeting.\n\nStage Capabilities [T1608](https://attack.mitre.org/techniques/T1608/) Adversaries may upload, install, or otherwise set up\ncapabilities that can be used during targeting.\n\n\n-----\n\nDeploy Container [T1610](https://attack.mitre.org/techniques/T1610/) Adversaries may deploy a container into an\nenvironment to facilitate execution or evade defenses.\n\n### Volatility Plugin\n\nThe following plugin for the Volatility memory analysis framework will scan all processes on\nthe system until it finds the Snake user mode component injected into a process. If found,\nthe plugin will list both the injected process and the virtual memory address at which the\nSnake user mode component is loaded.\n\n\n-----\n\n```\n# This plugin to identify the injected usermode component of Snake is based\n\n# on the malfind plugin released with Volatility3\n\n#\n\n# This file is Copyright 2019 Volatility Foundation and licensed under the\n\n# Volatility Software License 1.0\n\n# which is available at https://www.volatilityfoundation.org/license/vsl-v1.0\n\nimport logging\n\nfrom typing import Iterable, Tuple\n\nfrom volatility3.framework import interfaces, symbols, exceptions, renderers\n\nfrom volatility3.framework.configuration import requirements\n\nfrom volatility3.framework.objects import utility\n\nfrom volatility3.framework.renderers import format_hints\n\nfrom volatility3.plugins.windows import pslist, vadinfo\n\nvollog = logging.getLogger(__name__)\n\nclass snake(interfaces.plugins.PluginInterface):\n\n  _required_framework_version = (2, 4, 0)\n\n  @classmethod\n\n  def get_requirements(cls):\n\n    return [\n\n      requirements.ModuleRequirement(name = 'kernel',\n\n      description = 'Windows kernel',\n\n      architectures = [\"Intel32\", \"Intel64\"]),\n\n      requirements.VersionRequirement(name = 'pslist',\n\n      component = pslist.PsList, version = (2, 0, 0)),\n\n      requirements.VersionRequirement(name = 'vadinfo',\n\n      component = vadinfo.VadInfo, version = (2, 0, 0))]\n\n  @classmethod\n\n  def list_injections(\n\n      cls, context: interfaces.context.ContextInterface,\n\n      kernel_layer_name: str, symbol_table: str,\n\n      proc: interfaces.objects.ObjectInterface) -> Iterable[\n\n      Tuple[interfaces.objects.ObjectInterface, bytes]]:\n\n    proc_id = \"Unknown\"\n\n    try:\n\n      proc_id = proc.UniqueProcessId\n\n      proc_layer_name = proc.add_process_layer()\n\n    except exceptions.InvalidAddressException as excp:\n\n      vollog.debug(\"Process {}: invalid address {} in layer {}\".\n\n      format(proc_id, excp.invalid_address, excp.layer_name))\n\n      return\n\n    proc_layer = context.layers[proc_layer_name]\n\n    for vad in proc.get_vad_root().traverse():\n\n      protection_string = vad.get_protection(vadinfo.VadInfo.\n\n      protect_values(context, kernel_layer_name, symbol_table),\n\n      vadinfo.winnt_protections)\n\n      if not \"PAGE_EXECUTE_READWRITE\" in protection_string:\n\n        continue\n\n      if (vad.get_private_memory() == 1\n\n          and vad.get_tag() == \"VadS\") or (vad.get_private_memory()\n\n```\n\n-----\n\n```\n              0 and protection_string ! \n\n          \"PAGE_EXECUTE_WRITECOPY\"):\n\n        data = proc_layer.read(vad.get_start(),\n\n        vad.get_size(), pad = True)\n\n        if data.find(b'\\x4d\\x5a') != 0:\n\n          continue\n\n        yield vad, data\n\n  def _generator(self, procs):\n\n    kernel = self.context.modules[self.config['kernel']]\n\n    is_32bit_arch = not symbols.symbol_table_is_64bit(self.context,\n\n    kernel.symbol_table_name)\n\n    for proc in procs:\n\n      process_name = utility.array_to_string(proc.ImageFileName)\n\n      for vad, data in self.list_injections(self.context,\n\n      kernel.layer_name, kernel.symbol_table_name, proc):\n\n        strings_to_find = [b'\\x25\\x73\\x23\\x31',b'\\x25\\x73\\x23\\x32',\n\n        b'\\x25\\x73\\x23\\x33',b'\\x25\\x73\\x23\\x34',\n\n        b'\\x2e\\x74\\x6d\\x70', b'\\x2e\\x73\\x61\\x76',\n\n        b'\\x2e\\x75\\x70\\x64']\n\n        if not all(stringToFind in data for\n\n        stringToFind in strings_to_find):\n\n          continue\n\n        yield (0, (proc.UniqueProcessId, process_name,\n\n        format_hints.Hex(vad.get_start()),\n\n              format_hints.Hex(vad.get_size()),\n\n              vad.get_protection(\n\n                vadinfo.VadInfo.protect_values(self.context,\n\n        kernel.layer_name, kernel.symbol_table_name),\n\n        vadinfo.winnt_protections)))\n\n        return\n\n  def run(self):\n\n    kernel = self.context.modules[self.config['kernel']]\n\n    return renderers.TreeGrid([(\"PID\", int), (\"Process\", str),\n\n    (\"Address\", format_hints.Hex), (\"Length\", format_hints.Hex),\n\n    (\"Protection\", str)], self._generator(pslist.PsList.list_processes(\n\n    context = self.context, layer_name = kernel.layer_name, \n\n    symbol_table = kernel.symbol_table_name)))\n\n## Related Advisories\n\n```\n\n-----\n\nMay 24, 2023\n\nCybersecurity Advisory | AA23-144a\n\n### People's Republic of China State-Sponsored Cyber Actor Living off the Land to Evade Detection\n\nMay 16, 2023\n\nCybersecurity Advisory | AA23-136A\n\n### #StopRansomware: BianLian Ransomware Group\n\nMay 11, 2023\n\nCybersecurity Advisory | AA23-131A\n\n### Malicious Actors Exploit CVE-2023-27350 in PaperCut MF and NG\n\nApr 18, 2023\n\nCybersecurity Advisory | AA23-108\n\n### APT28 Exploits Known Vulnerability to Carry Out Reconnaissance and Deploy Malware on Cisco Routers\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-05-09 - Hunting Russian Intelligence “Snake” Malware.pdf"
    ],
    "report_names": [
        "2023-05-09 - Hunting Russian Intelligence “Snake” Malware.pdf"
    ],
    "threat_actors": [
        {
            "id": "e3767160-695d-4360-8b2e-d5274db3f7cd",
            "created_at": "2022-10-25T16:47:55.914348Z",
            "updated_at": "2025-03-27T02:05:17.411172Z",
            "deleted_at": null,
            "main_name": "IRON TWILIGHT",
            "aliases": [
                "ATK5 ",
                "Blue Athena ",
                "BlueDelta ",
                "FROZENLAKE ",
                "Fancy Bear ",
                "Fighting Ursa ",
                "Forest Blizzard ",
                "GRAPHITE ",
                "Group 74 ",
                "PawnStorm ",
                "STRONTIUM ",
                "Sednit ",
                "Snakemackerel ",
                "Sofacy ",
                "TG-4127 ",
                "Tsar Team ",
                "APT28 "
            ],
            "source_name": "Secureworks:IRON TWILIGHT",
            "tools": [
                " Downdelph",
                " Drovorub",
                " EVILTOSS",
                " HIDEDRV",
                " Headlace",
                " LoJack",
                " Powershell Empire",
                " SCONATO",
                " SEDUPLOADER",
                " SHARPFRONT",
                " Scaramouche",
                " Sedkit Exploit Kit",
                " Sofacy downloader",
                " X-Agent",
                " X-Tunnel",
                " Zebrocy",
                " reGeorg",
                "DEALERSCHOICE"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a97cf06d-c2e2-4771-99a2-c9dee0d6a0ac",
            "created_at": "2022-10-25T16:07:24.349252Z",
            "updated_at": "2025-03-27T02:02:10.184406Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "ATK 13",
                "Belugasturgeon",
                "Blue Python",
                "CTG-8875",
                "Group 88",
                "ITG12",
                "Iron Hunter",
                "Krypton",
                "Makersmark",
                "Operation Epic Turla",
                "Operation Moonlight Maze",
                "Operation Penguin Turla",
                "Operation Satellite Turla",
                "Operation Skipper Turla",
                "Operation Turla Mosquito",
                "Operation WITCHCOVEN",
                "Pacifier APT",
                "Pensive Ursa",
                "Popeye",
                "SIG15",
                "SIG2",
                "SIG23",
                "Secret Blizzard",
                "TAG-0530",
                "Turla",
                "UNC4210",
                "Venomous Bear",
                "Waterbug"
            ],
            "source_name": "ETDA:Turla",
            "tools": [
                "ASPXSpy",
                "ASPXTool",
                "ATI-Agent",
                "AdobeARM",
                "Agent.BTZ",
                "Agent.DNE",
                "BigBoss",
                "COMpfun",
                "Chinch",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobra Carbon System",
                "ComRAT",
                "DoublePulsar",
                "EmPyre",
                "EmpireProject",
                "Epic Turla",
                "EternalBlue",
                "EternalRomance",
                "GoldenSky",
                "Group Policy Results Tool",
                "HTML5 Encoding",
                "HyperStack",
                "IcedCoffee",
                "IronNetInjector",
                "KSL0T",
                "Kapushka",
                "Kazuar",
                "KopiLuwak",
                "Kotel",
                "LOLBAS",
                "LOLBins",
                "LightNeuron",
                "Living off the Land",
                "Maintools.js",
                "Metasploit",
                "Meterpreter",
                "MiamiBeach",
                "Mimikatz",
                "MiniDionis",
                "Minit",
                "NBTscan",
                "NETTRANS",
                "NETVulture",
                "Neptun",
                "NetFlash",
                "NewPass",
                "Outlook Backdoor",
                "Penquin Turla",
                "Pfinet",
                "PowerShell Empire",
                "PowerShellRunner",
                "PowerShellRunner-based RPC backdoor",
                "PowerStallion",
                "PsExec",
                "PyFlash",
                "QUIETCANARY",
                "Reductor RAT",
                "RocketMan",
                "SMBTouch",
                "SScan",
                "Satellite Turla",
                "SilentMoon",
                "Sun rootkit",
                "TTNG",
                "TadjMakhal",
                "Tavdig",
                "TinyTurla",
                "TinyTurla Next Generation",
                "TinyTurla-NG",
                "Topinambour",
                "Tunnus",
                "Turla",
                "Turla SilentMoon",
                "TurlaChopper",
                "Uroburos",
                "Urouros",
                "WCE",
                "WITCHCOVEN",
                "WhiteAtlas",
                "WhiteBear",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "Wipbot",
                "WorldCupSec",
                "XTRANS",
                "certutil",
                "certutil.exe",
                "gpresult",
                "nbtscan",
                "nbtstat",
                "pwdump"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "8aaa5515-92dd-448d-bb20-3a253f4f8854",
            "created_at": "2024-06-19T02:03:08.147099Z",
            "updated_at": "2025-03-27T02:05:17.408118Z",
            "deleted_at": null,
            "main_name": "IRON HUNTER",
            "aliases": [
                "Belugasturgeon ",
                "Blue Python ",
                "CTG-8875 ",
                "ITG12 ",
                "KRYPTON ",
                "MAKERSMARK ",
                "Pensive Ursa ",
                "Secret Blizzard ",
                "Turla",
                "UAC-0003 ",
                "UAC-0024 ",
                "UNC4210 ",
                "Venomous Bear ",
                "Waterbug ",
                "ATK13 "
            ],
            "source_name": "Secureworks:IRON HUNTER",
            "tools": [
                " ComRAT",
                " Kazuar",
                " KopiLuwak",
                " LightNeuron",
                " Mosquito",
                " Nautilus",
                " Neuron",
                " Penquin",
                " PoisonFrog",
                " PyFlash",
                " Skipper",
                " Snake",
                " Tavdig",
                " TinyTurla",
                " Tunnus",
                "Carbon-DLL"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "730dfa6e-572d-473c-9267-ea1597d1a42b",
            "created_at": "2023-01-06T13:46:38.389985Z",
            "updated_at": "2025-03-27T02:00:02.821388Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "FROZENLAKE",
                "BlueDelta",
                "SNAKEMACKEREL",
                "TG-4127",
                "ITG05",
                "TA422",
                "Fancy Bear",
                "FANCY BEAR",
                "Sednit",
                "IRON TWILIGHT",
                "G0007",
                "Sofacy",
                "Forest Blizzard",
                "GruesomeLarch",
                "Pawn Storm",
                "Tsar Team",
                "STRONTIUM",
                "ATK5",
                "Blue Athena",
                "APT-C-20",
                "Group 74",
                "SIG40",
                "Grizzly Steppe",
                "Fighting Ursa",
                "T-APT-12",
                "UAC-0028"
            ],
            "source_name": "MISPGALAXY:APT28",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "a97fee0d-af4b-4661-ae17-858925438fc4",
            "created_at": "2023-01-06T13:46:38.396415Z",
            "updated_at": "2025-03-27T02:00:02.823045Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Uroburos",
                "Hippo Team",
                "Pacifier APT",
                "MAKERSMARK",
                "ATK13",
                "UAC-0003",
                "IRON HUNTER",
                "Waterbug",
                "TAG_0530",
                "KRYPTON",
                "Popeye",
                "SIG23",
                "UAC-0144",
                "G0010",
                "Blue Python",
                "VENOMOUS Bear",
                "Group 88",
                "Pfinet",
                "ITG12",
                "UNC4210",
                "Secret Blizzard",
                "UAC-0024"
            ],
            "source_name": "MISPGALAXY:Turla",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "ae320ed7-9a63-42ed-944b-44ada7313495",
            "created_at": "2022-10-25T15:50:23.671663Z",
            "updated_at": "2025-03-27T02:00:55.518748Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "APT28",
                "IRON TWILIGHT",
                "SNAKEMACKEREL",
                "Group 74",
                "Sednit",
                "Sofacy",
                "Pawn Storm",
                "Fancy Bear",
                "STRONTIUM",
                "Tsar Team",
                "Threat Group-4127",
                "TG-4127",
                "Forest Blizzard",
                "FROZENLAKE"
            ],
            "source_name": "MITRE:APT28",
            "tools": [
                "Wevtutil",
                "certutil",
                "Forfiles",
                "DealersChoice",
                "Mimikatz",
                "ADVSTORESHELL",
                "Komplex",
                "HIDEDRV",
                "JHUHUGIT",
                "Koadic",
                "Winexe",
                "XTunnel",
                "Drovorub",
                "CORESHELL",
                "OLDBAIT",
                "Downdelph",
                "XAgentOSX",
                "USBStealer",
                "Zebrocy",
                "Fysbis",
                "LoJax"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d11c89bb-1640-45fa-8322-6f4e4053d7f3",
            "created_at": "2022-10-25T15:50:23.509601Z",
            "updated_at": "2025-03-27T02:00:55.487991Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Turla",
                "IRON HUNTER",
                "Group 88",
                "Waterbug",
                "WhiteBear",
                "Krypton",
                "Venomous Bear",
                "Secret Blizzard",
                "BELUGASTURGEON"
            ],
            "source_name": "MITRE:Turla",
            "tools": [
                "PsExec",
                "nbtstat",
                "ComRAT",
                "netstat",
                "certutil",
                "KOPILUWAK",
                "IronNetInjector",
                "LunarWeb",
                "Arp",
                "Uroburos",
                "PowerStallion",
                "Kazuar",
                "Systeminfo",
                "LightNeuron",
                "Mimikatz",
                "Tasklist",
                "LunarMail",
                "HyperStack",
                "NBTscan",
                "TinyTurla",
                "Penquin",
                "LunarLoader"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1685930781,
    "ts_updated_at": 1743041780,
    "ts_creation_date": 1685882365,
    "ts_modification_date": 1685882365,
    "files": {
        "pdf": "https://archive.orkl.eu/409459b1d1b29338e638d50bfe114fcfdc1dcafb.pdf",
        "text": "https://archive.orkl.eu/409459b1d1b29338e638d50bfe114fcfdc1dcafb.txt",
        "img": "https://archive.orkl.eu/409459b1d1b29338e638d50bfe114fcfdc1dcafb.jpg"
    }
}