{
    "id": "4a31bae2-859a-44b2-93ab-bb32e431a32e",
    "created_at": "2023-01-12T15:06:00.410369Z",
    "updated_at": "2025-03-27T02:05:42.176983Z",
    "deleted_at": null,
    "sha1_hash": "5797b6b7af3efae4608cd5fb10f61680998d4296",
    "title": "2019-09-23 - Diving into Pluroxs DNS based protection layer",
    "authors": "",
    "file_creation_date": "2022-05-28T21:41:11Z",
    "file_modification_date": "2022-05-28T21:41:11Z",
    "file_size": 182272,
    "plain_text": "# Diving into Pluroxs DNS based protection layer\n\n**[sysopfb.github.io/malware,/crypters/2019/09/23/Plurox-packer-layer-unpacked.html](https://sysopfb.github.io/malware,/crypters/2019/09/23/Plurox-packer-layer-unpacked.html)**\n\nRandom RE September 23, 2019\n\nSep 23, 2019\n\n## Intro\n\nRecently saw someone mentioning a sample of Plurox performing code flow obfuscation\nbased on the result of a DNS request, kind of interesting and I have apparently lost the link to\nthe person that originally mentioned the hash… so if you recognize it let me know and I’ll\nupdate this post.\n\nThe file we’ll be looking at is\n0385038427750543d98ce02a2a24aef45a937ef226a53fc3f995b5cea513b1c8\n\nPDB:\n```\nE:\\OldSoftware\\Generating\\Crypto\\crypto.pdb\n\n## Strings\n\n```\nEncoded strings is pretty common in malware and especially in protection layers such as\ncrypters/packers and droppers/loaders.\n\nNear the entry point of the sample we’ll find a call instruction with an immediate access of the\nstack. You find this pretty frequently in frameworks that use shellcode such as Metasploit, it’s\nbasically getting the address of the data immediately following the call instruction.\n\nWhat are we doing with this data? Further down we find a loop using XOR while loading the\nfirst DWORD of the data as the XOR key.\n\n\n-----\n\nDoing this statically in python:\n```\nPython>data = GetManyBytes(0x43f007, 0x100)\nPython>key = data[:4]\nPython>data = data[4:]\nPython>key = bytearray(key)\nPython>data = bytearray(data)\nPython>for i in range(len(data)):\nPython> data[i] ^= key[i%len(key)]\nPython>\nPython>data\nAZ� $9� R9� GetProcAddress �\nPython>data.split('\\x00')\n[bytearray(b'\\x12\\xf1\\x0e\\x03AZ\\xf1$9\\x99\\xaf\\xfaR\\x039\\x98GetProcAddress'),\nbytearray(b'VirtualFree'), bytearray(b'UnmapViewOfFile'), bytearray(b'htonl'),\nbytearray(b'ntdll.dll'), bytearray(b'ws2_32.dll'), bytearray(b'ExitProcess'),\nbytearray(b'gethostbyname'), bytearray(b'LoadLibraryA'), bytearray(b'VirtualAlloc'),\nbytearray(b'User32.dll'), bytearray(b'RtlDecompressBuffer'),\nbytearray(b'WSAStartup'), bytearray(b'VirtualProtect'), bytearray(b'google-publicdns-b.google.com'), bytearray(b''), bytearray(b''), bytearray(b'\\x8f'),\nbytearray(b',\\xe1T\\r\\x08\\x08\\xfb\\xfb\\xf7\\xf7\\xfb\\xfb\\xf7\\xf7\\xfb\\xfb\\xf7\\xf7\\xfb\\xfb\\x\n\n```\nThis is our string block along with the domain that will be resolved, the function names and\ndomain immediately make me think this is more related to a protection or crypter layer as\nopposed to directly associated with the underlying malware Plurox. Assumptions however\nare just things that need to be proven.\n\nContinuing on with the code it will enumerate it’s own memory space looking for the start\nvalue ‘MZ’.\n\n\n-----\n\nAfter finding that address it begins utilizing the bytes at the beginning of the decoded string\nblock, turns out these values are headers used to identify two blocks of data that will be\nsaved off.\n\nAfter saving off those chunks of data it will perform the resolution of the domain from the\ndecoded strings.\n\n\n-----\n\nIt will then use that resolved IP as the DWORD XOR key for the smaller layer that was\npreviously saved off.\n\nThis layer is designed to rebuild the larger blob that was previously saved off and then XOR\ndecoded and LZNT decompressed if needed. Unfortunately the values used to rebuild are\nnot static, you will need the number of bytes to copy over and the number of bytes to skip.\nPulling out these values is possible through a number of ways but probably the easiest is to\nsimply regex them out of the decoded layer.\n\n\n-----\n\nSo for creating an unpacker we need to do the following steps:\n```\n1. Load the PE file in memory mapped form\n2. Get the OEP (entry point)\n3. Find the encoded blob of strings\n4. Find the two data blobs using the byte chunks from the decoded strings\n5. Find the XOR key\n6. Decode the second layer code\n7. Get the value for bytes copied and bytes skipped\n8. Rebuild the encoded payload using values from 7\n9. Decode rebuilt payload\n10. Check if compressed\n11. Write to disk\n\n```\nSome of the pieces from above will be quickly glossed over because they are self\nexplanatory, if these pieces are more technically advanced than you are ready for you can\nskip them by all means and just read the comments that way you can hopefully understand\nmy thought process while I constructed the code which could be beneficial while learning.\n\nFor loading the PE file into memory and getting the OEP we will use pefile in python.\n```\nif __name__ == \"__main__\":\n     fdata = open(sys.argv[1], 'rb').read()\n     pe = pefile.PE(data=fdata)\n     oep = pe.OPTIONAL_HEADER.AddressOfEntryPoint\n     found = False\n     memmapped = pe.get_memory_mapped_image()\n\n```\nAt this point we want to try to limit our scope, the encoded blob of strings appears to normally\nbe near the OEP so we can probably try to brute it out within a limited scope of bytes.\n\n\n-----\n\n```\n     data memmapped[oep:oep+0x1000]\n     for i in range(len(data)-24):\n          test_k = bytearray(data[i:i+4])\n          test_v = bytearray(data[i+4:i+0x100])\n          for j in range(len(test_v)):\n              test_v[j] ^= test_k[j%len(test_k)]\n          if 'Alloc' in test_v or 'Process' in test_v or 'Decompress' in\ntest_v:\n              print(\"Found it\")\n              found = True\n              break\n\n```\nSo we are looping through the first 0x1000 bytes after the OEP to try to find encoded string\nbytes. After finding the start we just need to XOR decode the chunk which is semi redundant\nbecause we just did it for our testing loop and then split up the strings. Technically we only\nneed the first 16 bytes but I figured it’d be good to add in code that can quickly parse and\ndump the strings to look for the different domains being used.\n```\n     if found == True:\n          blob = bytearray(data[i+4:i+0x100])\n          key = bytearray(data[i:i+4])\n          for i in range(len(blob)):\n              blob[i] ^= key[i%len(key)]\n          if '\\x00\\x00\\x00' in blob:\n              conf = str(blob.split('\\x00\\x00\\x00')[0]).split('\\x00')\n          else:\n              conf = str(blob).split('\\x00')[:-1]\n\n```\nNext we will pull out the two blobs using the first 16 bytes from the decoded strings\n```\n          off1 = fdata.find(conf[0][:8])\n          l = fdata[off1+8:].find(conf[0][:8])\n          blob1 = fdata[off1+8:off1+l+8]\n          off2 = fdata.find(conf[0][8:16])\n          l = fdata[off2+8:].find(conf[0][8:16])\n          blob2 = fdata[off2+8:off2+l+8]\n\n```\nNow we’re going to do something a little interesting, this is why I enjoy writing scripts like this\nalso. After gathering enough samples and dumping enough layer2s we can start to see byte\npatterns emerge, now we could just resolve the domain and boom we have our XOR key but\nthat’s no fun. So if you go back up to the comparison picture you’ll notice some overlap of\nbytes in the decoded layer2 but more importantly I noticed the 4 bytes after the first 3 bytes\nremain pretty static across many samples tested.\n```\n          known_val = bytearray('\\x01\\xc0\\x6a\\x04')\n\n```\nSo to get the XOR key we just need to XOR the known value with the encoded bytes in the\nsame place and then fixup the key position because we went 3 bytes in instead of 4.\n\n\n-----\n\n```\n          key bytearray(blob1[3:7])\n          for i in range(len(key)):\n              key[i] ^= known_val[i]\n          key = key[1:]+key[:1]\n          temp = bytearray(blob1)\n          for i in range(len(temp)):\n              temp[i] ^= key[i%len(key)]\n\n```\nNow we have our layer2 decoded code that we can regex out the values we need.\n```\n          matches =\nre.findall('''\\xb9.\\x00\\x00\\x00\\xf3\\xa4\\x83\\xc6.\\x83\\xe8''', temp)\n          if len(matches) > 0:\n              (dc, chunk_length, dc, dc, dc, addval) =\nstruct.unpack_from('<BBIBHB',matches[0])\n              out = \"\"\n              total_block = chunk_length + addval\n\n```\nSo we can now fixup our other blob of data by copying over the chunks.\n```\n              i = 0\n              while i < len(blob2):\n                   out += blob2[i:i+chunk_length]\n                   i += total_block\n              out2 = bytearray(out)\n\n```\nThen we just XOR using the same key and check if we need to decompress.\n```\n              for i in range(len(out2)):\n                   out2[i] ^= key[i%len(key)]\n              if 'MZ' != out2[:2]:\n                   out3 = lznt_p.decompress_data(out2)\n              else:\n                   out3 = out2\n              open(sys.argv[1]+'_embedded.bin', 'wb').write(out3)\n          else:\n              print(\"Unknown layer2!\")\n\n```\nWriting public unpackers basically is doing QA or quality assurance for the guys writing the\npackers but sometimes it’s good to do to prove or disprove a theory such as the one I stated\nabove about this layer being a packer layer versus related to Plurox. It’s also good because it\ncan prove beneficial to aspiring malware researchers out there, it’s usually easier to learn\nthrough mimicry so hopefully the above is useful to someone out there.\n\nNow after unpacking a few samples I noticed a few interesting things:\n\nThere’s more than one domain used by this\nThis is indeed a packer used by more than just Plurox\n\nI only did a few samples but I found the following domains being leveraged:\n\n\n-----\n\n```\ngoogle public dns b.google.com\ngoogle-public-dns-a.google.com\nexample.com\n\n```\nI also pretty quickly found a sample that unpacks to a DarkComet sample:\n```\nMD5  7e12e4b19e000e30385fc995db4fe837\nSHA-1 2dacc210e01f380765c7b9fe0dcf7f650f98bbde\nSHA-256  e0bdab9458543ac59ce6030e3b66dd503c2c35c04596eb3e9e30188223946155\n[+] Printing Config to screen\n  [-] Key: CHANGEDATE Value: 0\n  [-] Key: COMBOPATH  Value: 3\n  [-] Key: DIRATTRIB  Value: 0\n  [-] Key: EDTDATE  Value: 16/04/2007\n  [-] Key: EDTPATH  Value: Soft\\olp32.exe\n  [-] Key: FILEATTRIB Value: 0\n  [-] Key: FTPHOST  Value: \n  [-] Key: FTPPASS  Value: \n  [-] Key: FTPPORT  Value: \n  [-] Key: FTPROOT  Value: \n  [-] Key: FTPSIZE  Value: \n  [-] Key: FTPUPLOADK Value: \n  [-] Key: FTPUSER  Value: \n  [-] Key: FWB Value: 0\n  [-] Key: GENCODE  Value: 8Ub1461JKvo2\n  [-] Key: INSTALL  Value: 1\n  [-] Key: KEYNAME  Value: OLP Software\n  [-] Key: MELT  Value: 0\n  [-] Key: MUTEX  Value: CMQCKTN\n  [-] Key: NETDATA  Value: 185.146.157.143:1604\n  [-] Key: OFFLINEK  Value: 1\n  [-] Key: PERSINST  Value: 0\n  [-] Key: PWD Value: \n  [-] Key: SID Value: VM\n[+] End of Config\n\n```\nSome other samples using the protection layer:\n\nAzorult:\n```\nMD5  2cf6634a78c734876377d13f7cd4c178\nSHA-1 d63616dd6e69218c709fffce76834406ab52e6f6\nSHA-256  6e70a71063acdd9570fea8698d090d87e4767f80a643e121839b4449924f2d8c\n\n```\nBaldr:\n```\nMD5  21661041c0912c97cbc9f1e16e5f5d06\nSHA-1 19117be8e15e08acba72a1d7c732bf2e87cb4992\nSHA-256  f1ea3330bf0b5bf426328d41b0faae689366070b4013e92fe87cc1de55eba2c6\n\n```\nClipboard crypto wallet replacer\n\n\n-----\n\n```\nMD5  ea3a524f3375232661bbee54367d92ba\nSHA-1 9a000e8d1b11c7d35af1f54c626e812b41ab0e64\nSHA-256  bdde9b0ca484ca08e0572b846f2a7ba989d999898ce1c095d0b4b678993b8d28\n\n```\nReferences:\n\n1. https://github.com/erocarrera/pefile\n2. https://github.com/google/rekall/blob/master/rekall\ncore/rekall/plugins/filesystems/lznt1.py\n3. https://github.com/rapid7/metasploit-framework\n4. https://github.com/kevthehermit/RATDecoders\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-09-23 - Diving into Pluroxs DNS based protection layer.pdf"
    ],
    "report_names": [
        "2019-09-23 - Diving into Pluroxs DNS based protection layer.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535960,
    "ts_updated_at": 1743041142,
    "ts_creation_date": 1653774071,
    "ts_modification_date": 1653774071,
    "files": {
        "pdf": "https://archive.orkl.eu/5797b6b7af3efae4608cd5fb10f61680998d4296.pdf",
        "text": "https://archive.orkl.eu/5797b6b7af3efae4608cd5fb10f61680998d4296.txt",
        "img": "https://archive.orkl.eu/5797b6b7af3efae4608cd5fb10f61680998d4296.jpg"
    }
}