{
    "id": "a415d2e5-396a-4b7e-83e5-0640fe670504",
    "created_at": "2023-01-12T15:06:09.892265Z",
    "updated_at": "2025-03-27T02:05:46.853269Z",
    "deleted_at": null,
    "sha1_hash": "146178c6f3da05a6cd7aa8ce1d6de3d04230fda2",
    "title": "2022-04-14 - Blinding Snort- Breaking The Modbus OT Preprocessor",
    "authors": "",
    "file_creation_date": "2022-05-28T03:47:30Z",
    "file_modification_date": "2022-05-28T03:47:30Z",
    "file_size": 1376362,
    "plain_text": "# Blinding Snort: Breaking the Modbus OT Preprocessor\n\n**[claroty.com/2022/04/14/blog-research-blinding-snort-breaking-the-modbus-ot-preprocessor/](https://claroty.com/2022/04/14/blog-research-blinding-snort-breaking-the-modbus-ot-preprocessor/)**\n\nApril 14, 2022\n\n**By Uri Katz | April 14, 2022**\n\n**Executive Summary**\n\nTeam82 discovered a means by which it could blind the popular Snort intrusion\ndetection and prevention system to malicious packets.\nThe vulnerability, CVE-2022-20685, is an integer-overflow issue that can cause the\nSnort Modbus OT preprocessor to enter an infinite while-loop.\nA successful exploit keeps Snort from processing new packets and generating alerts.\nThe vulnerability, which can be attacked remotely, has been patched by Cisco and the\nSnort team.\nAll open source Snort project releases earlier than 2.9.19 and release 3.1.11.0 are\nvulnerable.\n[Read Cisco’s advisory here for commercial product patching and mitigation](https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-snort-dos-9D3hJLuj)\ninformation.\n\n**Introduction**\n\nNetwork analysis tools are integral to keeping networks secure by providing real-time\nlogging and analysis of events and traffic. Snort is atop this list of analysis tools as the most\npopular network intrusion detection and prevention system. The open-source version of\nSnort still has an active community of contributors and developers, while Cisco has\ndeveloped commercial versions of Snort since acquiring parent company Sourcefire in\n2013.\n\nSnort is largely used passively on the network, but it can also take action on malicious\npackets, making it a powerful detection tool for defenders. An attacker who could blind this\ntool to malicious traffic, however, could gain an important advantage over network\ndefenders.\n\n\n-----\n\nIn this report, Team82 will demonstrate how it was able to do just that through a\nvulnerability, (CVE-2022-20685) we uncovered in Snort’s Modbus OT preprocessor.\nExploiting this vulnerability allowed us to blind Snort’s ability to detect further attacks and\nrun malicious packets on the network.\n\n\n-----\n\n**Snort Rules and Alerts**\n\nSnort’s open-source network-based intrusion detection/prevention system (IDS/IPS) has the\nability to perform real-time traffic analysis and packet logging on internet protocol (IP)\nnetworks. Snort performs protocol analysis, content searching, and matching based on a\npredefined rule set. Snort rules can be based on raw data or on Snort’s built-in protocol\nparsers.\n\nRules may trigger one of three actions:\n\nAlert rules: Generate an alert\nLog rules: Alert and log the alert\nPass rules: Ignore the packet\n\nTo make the rule-writing process simpler and improve the detection capabilities, Snort\ncomes with a set of preprocessors that are on by default and analyze and structure network\ntraffic into objects that can be referenced later in Snort rules. Some of the preprocessors\n\n\n-----\n\nincluded in Snort are: ARP, DNS, SSH and some OT (operational technology) protocols,\nsuch as [MODBUS /](https://www.snort.org/faq/readme-modbus) [DNP3.](https://www.snort.org/faq/readme-dnp3)\n\n**_Snort’s default configuration (snort.conf)._**\n\nWhen writing Snort rules, one can easily use these objects—for example to check the\nModbus function ID the modbus.func_id attribute can be used, instead of checking offset of\nthe sixth byte in the packet. Here is an example for a snort rule that use modbus\npreprocessor attributes:\n\n**Modbus**\n\nModbus is an industrial protocol developed in 1979, first intended to transfer data over a\nserial line. Later it was expanded to include TCP/UDP support. The main Modbus function\ncodes are:\n\n\n-----\n\n**CVE-2022-20685: Technical Details**\n\nWhile researching Snort OT preprocessors, we decided to focus on Modbus because it was\none of the more complex OT preprocessors Snort supports. To understand what we found,\nwe first need to examine the structure of the Modbus Write File Record function code.\n\n**Write File Record (command 0x15)**\n\nThe Write File Record Modbus command writes multiple groups of file registers to the\nModbus server. A file is an organization of records. Each file may contain up to 10,000\nrecords, addressed 0000 to 9999 decimal or 0x0000 to 0x270F.\n\nThe Write File Record Modbus command allows writing multiple groups of references. Each\ngroup is defined in a separate sub-request field that contains 7 bytes plus the data:\n\n**Reference type: 1 byte (must be specified as 6)**\n**File number: 2 bytes**\n**Starting record number within file: 2 bytes**\n**Length of record to be written: 2 bytes**\n**Data to be written: 2 bytes of data per register**\n\n\n-----\n\nThe number of registers to be written, combined with all other fields in the request, must not\nexceed the allowable length of the Modbus protocol data unit (PDU), which is 253 bytes.\n\nHere is a summary of the Write File Record Modbus command request:\n\n**Vulnerability and Exploitability**\n\nThe Modbus preprocessor handles multiple Modbus function codes. Snort uses the\nModbusCheckRequestLengths function to calculate the expected size for each packet.\n\nIf we look at the function ModbusCheckRequestLengths in the file modbus_decode.c, we\nsee a while-loop that goes over all of the groups in the packet, in order to calculate the total\nrecord lengths.\n\n\n-----\n\n**_Function ModbusCheckRequestLengths in file modbus_decode.c_**\n\nCan you already spot a potential problem? Let’s go over the steps for exploitation:\n\nStep 1\n\nThe tmp_count parameter is initialized using a value from the packet->payload and\nrepresents the number of bytes remaining in the payload, according to the payload_length\nparameter. After tmp_count is set, we enter a while-loop with the exit condition of\nbytes_processed < tmp_count. Therefore, so far tmp_count = 10, which is constant and\nwon’t change during the loop. As long as bytes_processed remains less than 10, the whileloop will continue looping.\n\nTo do so, let’s look at the content of the while-loop. We see that bytes_processed is affected\nby the record_length parameter, which consists of two bytes from the Modbus payload\n(Group → Record Length).\n\n\n-----\n\n**_Function ModbusCheckRequestLengths in file modbus_decode.c_**\n\nStep 2\n\nThe record_length parameter is of type uint16_t, with a value from the user-controlled\nModbus payload. bytes_processed is also uint16_t, and is calculated by multiplying\nrecord_length by 2 + the sub-request header size, which is 7.\n\nHowever, the result of the multiplication can be more than the maximum uint16_t size, thus\noverflowing the value.\n\nFor example:\n\n**record_length = 0xfffe**\n**MODBUS FILE RECORD SUB REQUEST SIZE = 7**\n\n\n-----\n\n**bytes_processed = 7 + (2 0xfffe)**\n\nIn this example, the bytes_processed will be 0x20003, which is:\n\n0000000000000010|0000000000000011\n\n**High                  Low**\n\nIn binary, when the result is cast to uint_16t, the lower 16 bits are kept, meaning the\nbytes_processed will be 0000000000000011, which equals 3. If the bytes_processed is 3,\nwe do not exit the while-loop, because 3 (bytes_processed) < 10 (tmp_count), and we enter\nanother iteration.\n\n**Step 3**\n\nNow, the new record_length will be taken from the user-controlled payload, from a specific\noffset that is partially affected by the bytes_processed value. Since we fully control the\nvalue of the bytes_processed using the integer-overflow bug, we can craft the payload in\nsuch a way that the newly calculated record_length will be any number we choose.\n\nTherefore, if the next value that is read into the record_length (allegedly the next group’s\nrecord length) is 0xfffb, then the bytes_processed will be calculated as follows:\n\nbytes_processed = bytes_processed + MODBUS_FILE_RECORD_SUB_REQUEST_SIZE\n+ 2*record_length\n\nbytes_processed = 3 + 7 + 2*(0xfffb) = 0\n\nSo, the bytes_processed is now 0.The next time we enter the while-loop, the\nbytes_processed is 0 again, so we will go through steps 2 and 3 over and over, until the\nprocess is terminated by the user. This essentially keeps the process stuck in the while-loop\n(steps 2 & 3) “blinding” it forever. In this state, Snort will not process new packets and will\nnot alert.\n\n\n-----\n\n**Conclusion**\n\nSuccessful exploits of vulnerabilities in network analysis tools such as Snort can have\ndevastating impacts on enterprise and OT networks.\n\nCVE-2022-20685, uncovered by Team82, targeted just one facet of this popular network\nintrusion detection and prevention system. It can be exploited remotely to create a denialof-service condition in Snort, keeping it from processing new packets, and generating\nalerts.\n\nTeam82 believes network analysis tools are an under-researched area that deserves more\nanalysis and attention, especially as OT networks are increasingly being centrally managed\nby IT network analysis familiar with Snort and other similar tools.\n\n**[CVE-2022-20685](https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-snort-dos-9D3hJLuj)**\n\n**CWE-190: Integer Overflow or Wraparound**\n\n**CVSSv3 score: 7.5**\n\n**Description: An integer overflow vulnerability in the Snort Modbus OT preprocessor**\nenables an attacker to remotely send a crafted packet to a vulnerable system, triggering an\ninfinite while-loop and creating a denial-of-service condition.\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-14 - Blinding Snort- Breaking The Modbus OT Preprocessor.pdf"
    ],
    "report_names": [
        "2022-04-14 - Blinding Snort- Breaking The Modbus OT Preprocessor.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535969,
    "ts_updated_at": 1743041146,
    "ts_creation_date": 1653709650,
    "ts_modification_date": 1653709650,
    "files": {
        "pdf": "https://archive.orkl.eu/146178c6f3da05a6cd7aa8ce1d6de3d04230fda2.pdf",
        "text": "https://archive.orkl.eu/146178c6f3da05a6cd7aa8ce1d6de3d04230fda2.txt",
        "img": "https://archive.orkl.eu/146178c6f3da05a6cd7aa8ce1d6de3d04230fda2.jpg"
    }
}