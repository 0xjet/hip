{
    "id": "f42a4023-711b-416e-887c-54a874c2a2c8",
    "created_at": "2023-01-12T15:09:43.714165Z",
    "updated_at": "2025-03-27T02:08:40.415628Z",
    "deleted_at": null,
    "sha1_hash": "b9aa62e1d1f2d620496352489c49f29eb47f055a",
    "title": "2015-11-20 - A king's ransom- an analysis of the CTB-locker ransomware",
    "authors": "",
    "file_creation_date": "2022-05-29T01:27:37Z",
    "file_modification_date": "2022-05-29T01:27:37Z",
    "file_size": 1031155,
    "plain_text": "# A king's ransom: an analysis of the CTB-locker ransomware\n\n**samvartaka.github.io/malware/2015/11/20/ctb-locker**\n\n[Recently i was involved in the incident response to a ransomware infection, a](https://en.wikipedia.org/wiki/Ransomware) [CTB-locker](https://securelist.com/analysis/publications/64608/a-new-generation-of-ransomware/)\ninfection to be precise, and i thought it would be interesting to share some of the details here.\nCTB-locker (which stands for Curve-TOR-Bitcoin) aka ‘Critroni’ is one of the more\n[sophisticated ransomware families and seems to have been making the rounds in](https://www.dearbytes.com/blog/verhoogde-activiteit-ctb-locker/) the\nNetherlands [recently.](http://blog.fox-it.com/2015/09/07/the-state-of-ransomware-in-2015/)\n\nThis article details the process of reverse-engineering the crypter/dropper carrying the\nransomware executable and the actual CTB-locker executable itself (the latter building upon\npre-existing RE analyses) as well as giving an assesment on the ‘strength’ (that is, the\ndifficulty of recovering the ‘ransomed’ files) of CTB-locker and its underlying cryptography.\n\nThe general idea behind CTB-locker, as discussed by [Kaspersky and](https://securelist.com/analysis/publications/64608/a-new-generation-of-ransomware/) [Fox-IT, is that it uses](http://blog.fox-it.com/2015/09/07/the-state-of-ransomware-in-2015/)\nthe ECDH key agreement scheme (using Curve25519 as a primitive) to generate a series of\nrandom per-file unique AES keys which are used to encrypt files found disks of all types\n(fixed, removable or network-mapped). The victim is then shown a ransom message and\ninstructed to pay a ransom amount in bitcoins to a per-infection unique bitcoin address in\norder to retrieve the secret key (both bitcoin address and key are retrieved over the TOR\nnetwork) required to decrypt their files. The combination of bitcoin (assuming transactions to\npayout addresses are properly mixed) and TOR give the operators of a CTB-locker\ncampaign a fairly strong guarantee of anonimity while the particular design of its\ncryptographic scheme both ensures file encryption can take place without requiring contact\nto backend servers as well as making file recovery virtually impossible.\n\n## The campaign attack vector\n\nThe (rather unsophisticated) attack was carried out using a mass-mailed malicious\n[attachment-carrying e-mail claiming to be from KPN (a major Dutch telco) notifying the victim](https://en.wikipedia.org/wiki/KPN)\nthere is an outstanding invoice of € 365,41:\n\n\n-----\n\n```\nGeachte heer,\nIn de bijlage ontvangt u de factuur van uw KPN Internetdiensten.\nBedrag en specificaties\nDeze maand is uw factuur in totaal € 365,41. De specificaties van de factuur vindt u\nin de bijlage.\nOverzicht van al uw facturen in MijnKPN\nWilt u een overzicht van al uw facturen of uw persoonlijke instellingen bekijken?\nKlik dan hier om naar MijnKPN te gaan. Dit is uw persoonlijke en beveiligde KPN\nomgeving.\nUitleg van uw factuur\nKlik hier voor uitleg over uw factuur.\nVeelgestelde vragen\nHebt u nog vragen over uw factuur en de betaling ervan, kijk dan op kpn.com/factuur.\nHier vindt u informatie over veelgestelde vragen zoals: de opbouw van de factuur, de\nbetalingsmogelijkheden, de factuur online bekijken en hoe u wijzigingen doorgeeft.\nMet vriendelijke groet,\nBob Mols\nDirecteur Klantenservice\nN.B. dit is een automatisch verzonden e-mail, het is niet mogelijk deze e-mail te\nbeantwoorden.\nKent u KPN Compleet al? Hoe meer u combineert, hoe meer voordelen u krijgt. Kijk voor\nmeer informatie op kpn.com/krijgmeer\n\n```\nThose who can read Dutch will notice the quality of the grammar and spelling (contrary to\nmany phishing and malware mass-mailing campaigns). Also notable is the fact that the email is sent in the name of KPN’s VP of customer contact Bob Mols. Mols (according to his\nLinkedIn profile) appears to have had this role only since May 2015 giving some indication\nabout when the attackers set up this e-mail (though it is quite possible preparations had been\nunderway some time before). None of the hyperlinks (including the one instructing users to\ncheck their invoices) in the e-mail lead to malicious sites (phishing, exploit kit rigged or\notherwise) with the attachment being the only malicious component of the e-mail. Reports\n[around the internet indicate this campaign has been active for some time targeting Dutch](https://www.pchulplijn.nl/helpdesk/virus-verwijderen/ctb-locker/kpn-factuur-internetdiensten-bevat-ctb-locker-virus)\nusers.\n\nThe e-mail originated from the IP address `95.211.225.216 (belonging to LeaseWeb`\nNetherlands B.V., a hosting provider accepting PayPal and Credit Card payments) which\n[seems to have received some](http://dnsbl.inps.de/query.cgi?action=last_mail&ip=95.211.225.216&lang=en) [spam complaints in](https://cleantalk.org/blacklists/95.211.225.216) [the past while the return-path associated](http://www.liveipmap.com/95.211.225.216)\nwith the malicious e-mail was `apache@lcdalw1174.amhost.net indicating probably some`\nPHP mass-mailing script on either a compromised or intentionally malicious webserver.\n\n\n-----\n\nAMhost is a hosting provider (acting as a LeaseWeb reseller) which accepts a variety of\npayment methods including WebMoney (very popular in the Russian criminal underground),\nECoin.cc (a Russian online payment system), Paxum (a Montreal-based global ewallet\npayment system), EPESE (another Russian-language e-payment system) and Credit Card,\nhas contact addresses on the British Virgin Islands and Scotland but has a customer service\noperating Moscow office hours in the Russian and English language.\n\nEither way, the attachment itself is a ZIP archive with the following characteristics:\n\nFilename: Factuur 11100641293.zip\nMD5: 380dfb7c4695be4f1d32d178056662be\nSHA256:\n3746d03a417a308cccce3643787929d6c0f8567cee076689606fc8d3c3b6b916\nFirst virustotal submission: 2015-11-03 22:27:07 UTC\nCompression metadata datetime: 2015-11-03 19:09:54\n\nThe archive contains a single file named ‘Factuur 11100641293.pdf.exe’ with a PDF file icon\nhoping to trick unsuspecting users. Extremely simple but still effective in many cases.\n\n## The Crypter/Dropper\n\nThe malicious ‘Factuur 11100641293.pdf.exe’ has the following characteristics:\n\nFilename: Factuur 11100641293.pdf.exe\nAlternate filenames (according to virustotal intelligence): tvnserver.exe\nMD5: bedba9325fba353c146026a7ae970e8c\nSHA256: c8534583d412d59b4b17c668bf8afddda31155ba6a12e79c2fa228ac9af88c75\nFirst virustotal submission: 2015-11-03 23:32:14 UTC\nPE timestamp: 2015:10:21 16:15:36+01:00\nSpotted (according to virustotal intelligence): as response content to URL\nhxxp://91.121.219.212/tvnserver.exe\nPeID signature: Microsoft Visual C++ 6.0\nDiE signature: MSVC++ 6.0, MFC 4.2, MSLinker 6.0\n\nThe application appears to be written in MSVC++ using the Microsoft Foundation Class\nlibrary and seems to be a different crypter/dropper than the ones used in previous CTB[locker campaigns (including those targeting victims in the Netherlands) [1,](https://www.dearbytes.com/blog/matroesjka-poppen-ctb-locker/) [2]. After reverse](http://christophe.rieunier.name/securite/CTB-Locker/CTB-Locker_Payload/CTB-Locker_payload_obfuscation_layers_analysis.php)\nengineering this crypter and searching for some of its characteristics (hardcoded mutex\nnames, behavior, etc.) i discovered it is the same (or heavily related to) one described in this\narticle by Marion Marschalek about reversing obfuscated Miuref samples and this article by\n[Christopher del Fierro about an obfuscated Cryptowall ransomware sample. It might have](https://business.kaspersky.com/cryptowall-3-0-an-evolution-twist/4137/)\nsaved me some time if some identification tool had properly identified this crypter but oh well.\nI’ll briefly walk through my approach in reverse engineering.\n\n\n-----\n\nGiven that we re dealing with an MFC application with callbacks and whatnot and we don t\nwant to step through the entire thing instruction-by-instruction i simply set a break-onexecute hardware breakpoint on the .text segment allowing me to skip code executed in the\nMFC library (or other loaded libraries) while not skipping over potentially interesting code part\nof the crypter itself.\n\n### First layer\n\nAfter wading through some of the less interesting stuff the crypter gets to the following code:\n\n\n-----\n\n```\n.text:004014BD loc_4014BD:               ; CODE XREF: .text:0040151Aj\n.text:004014BD         lea   ecx, [ebp-1Ch]\n.text:004014C0         call  ??0CString@@QAE@XZ ; CString::CString(void)\n.text:004014C5         push  2\n.text:004014C7         lea   eax, [ebp-14h]\n.text:004014CA         push  edi\n.text:004014CB         push  eax\n.text:004014CC         lea   ecx, [ebp-10h]\n.text:004014CF         mov   byte ptr [ebp-4], 5\n.text:004014D3         call  ?Mid@CString@@QBE?AV1@HH@Z ;\nCString::Mid(int,int)\n.text:004014D8         push  eax\n.text:004014D9         lea   ecx, [ebp-1Ch]\n.text:004014DC         mov   byte ptr [ebp-4], 6\n.text:004014E0         call  ??4CString@@QAEABV0@ABV0@@Z ;\nCString::operator=(CString const &)\n.text:004014E5         lea   ecx, [ebp-14h]\n.text:004014E8         mov   byte ptr [ebp-4], 5\n.text:004014EC         call  ??1CString@@QAE@XZ ; CString::~CString(void)\n.text:004014F1         mov   ecx, [ebp-1Ch]\n.text:004014F4         push  10h\n.text:004014F6         push  0\n.text:004014F8         push  ecx\n.text:004014F9         call  ds:strtol\n.text:004014FF         add   esp, 0Ch\n.text:00401502         lea   ecx, [ebp-1Ch]\n.text:00401505         mov   [ebx], al\n.text:00401507         mov   byte ptr [ebp-4], 3\n.text:0040150B         call  ??1CString@@QAE@XZ ; CString::~CString(void)\n.text:00401510         mov   edx, [ebp-10h]\n.text:00401513         add   edi, 2\n.text:00401516         inc   ebx\n.text:00401517         cmp   edi, [edx-8]\n.text:0040151A         jl   short loc_4014BD\n.text:0040151C\n.text:0040151C loc_40151C:               ; CODE XREF: .text:004014B5j\n.text:0040151C         push  40F2B000h\n.text:00401521         push  0\n.text:00401523         jmp   loc_403315\n                                   (...)\n.text:00403315 loc_403315:\n.text:00403315         lea   eax, [ebp-1B88h]\n.text:0040331B         jmp   loc_401529\n                                   (...)\n.text:00401529 loc_401529:\n.text:00401529         call  eax\n\n```\nWhat happens here is a bunch of CString objects get allocated and decoded into a piece of\nshellcode that gets stored on the stack. This is what part of the memory in question looks like\nbefore decoding:\n\n\n-----\n\n```\n0033957C 65 38 30 44 30 32 30 30 30 30 33 33 43 30 63 33 e80D02000033C0c3\n0033958C 38 42 35 34 32 34 30 63 38 62 34 63 32 34 30 34 8B54240c8b4c2404\n0033959C 38 42 63 32 34 41 35 37 38 62 66 39 38 35 63 30 8Bc24A578bf985c0\n003395AC 37 34 31 32 35 36 38 64 37 32 30 31 38 42 35 34 7412568d72018B54\n003395BC 32 34 31 30 38 61 30 32 38 38 30 31 34 31 34 32 24108a0288014142\n003395CC 34 45 37 35 46 37 35 65 38 42 63 37 35 46 63 33 4E75F75e8Bc75Fc3\n003395DC 35 35 38 42 45 43 35 31 35 31 35 33 35 36 35 37 558BEC5151535657\n           (...)\n\n```\nAnd after (when the hex representation is transformed to bytes and stored on the stack):\n```\n0012E188 E8 0D 02 00 00 33 C0 C3 8B 54 24 0C 8B 4C 24 04\nStack[00000748]:0012E188 call  sub_12E39A\n\n### Second layer\n\n```\nThe `sub_12E39A routine is the second layer of the crypter. It is self-contained and`\ndynamically imports the API functions it needs from various DLLs. Its functionality consists of\nintroducing some system persistence and decrypting (using what i recognized as a selfcontained implementation of the RC4 stream cipher) a third stage payload and can be\nsummarized as:\n\nCopy running executable to startup folder\nSearch for ciphertext buffer and key within program image\nAllocate buffer, decrypt key, decrypt ciphertext and copy to buffer, execute shellcode in\nbuffer\n\nThe pseudo-code looks (edited and reduced for clarity) as follows:\n\n\n-----\n\n```\nint sub_12E39A()\n{\n load_libraries_get_procaddrs();\n GetModuleFilenameW(0, &own_filename, 260);\n SHGetSpecialFolderPathW(0, &app_data_path, CSIDL_LOCAL_APPDATA, False);\n Append(&app_data_path, \"\\\\CSIDL_X\");\n SHGetSpecialFolderPathW(0, &startup_path, CSIDL_STARTUP, False);\n if (strstr(own_filename, \".tmp\"))\n {\n  SetFileAttributesW(&app_data_path, FILE_ATTRIBUTE_NORMAL);\n  CopyFileW(&own_filename, &app_data_path, 0);\n }\n else\n {\n  if (strstr(&own_filename, &startup_path))\n  {\n     goto LABEL_6;\n     }\n     SetFileAttributesW(&own_filename, FILE_ATTRIBUTE_NORMAL);\n     CopyFileW(&app_data_path, &own_filename, 0);\n }\nLABEL_6:\n fhandle = CreateFileW(&own_filename, 0x80000000, 1, 0, 3, 0, 0);\n fsize = GetFileSize(fhandle, 0);\n buffer = VirtualAlloc(0, 10 * fsize, MEM_COMMIT|MEM_RESERVE,\nPAGE_EXECUTE_READWRITE);\n ReadFile(fhandle, buffer, fsize);\n CloseHandle(fhandle);\n memset(ciphertext, 0, ...);\n seek_index = 0;\n while (1)\n {\n     v27 = *(_BYTE *)(seek_index + buffer);\n     if ( *(_BYTE *)(seek_index + buffer + 2) == v27 - 4 && *(_BYTE *)(seek_index\n+ buffer + 4) == v27 - 1 && *(_BYTE *)(seek_index + buffer + 6) == v27 + 2 && *(_BYTE\n*)(seek_index + buffer + 8) == v27 + 3 )\n          break;\n     if (seek_index == fsize - 1)\n          return 0;\n     if (seek_index >= fsize)\n          goto LABEL_26;\n }\n memcpy(ciphertext, *(BYTE*)(buffer + seek_index + 20), 0x4E34);\n memcpy(key, *(BYTE*)(buffer + seek_index), 20);\nLABEL_26:\n do_rc4(ciphertext, key, 0x4E20, 0x14);\n decoded_buffer = VirtualAlloc(0, 0x4E20, 0x3000, 64);\n memcpy(decoded_buffer, ciphertext, 0x4E20);\n\n```\n\n-----\n\n```\n decoded_buffer();\n return 0;\n\n### Third layer\n\n```\nThe third and final layer of the crypter consists of a rather complex multi-purpose function\nwhich is called in recursive fashion where the calling parameters specify what functionality to\nexecute, effectively making it a finite state machine. I didn’t spend too much time reversing\nthe entire thing as i primarily wanted to get to the actual CTB-locker executable (and\ndiscovering this had already been done upon trying to identify it using strings uncovered in\nthe reversing process) but a short summary of the third layer’s functionality is as follows:\n\nCheck if an app named ‘myapp.exe’ is present in the system root directory. If it is, the\nprocess terminates. According to Marschalek this stems from a crypter/packer known\nas ‘Local-App-Wizard’\nUnpack compressed data to a memory block\nVerify our process privileges, create mutex named “qazwsxedc”\nCheck whether we are run in Sandboxie (check if sbiedll.dll is loaded in running\nprocess)\nCheck whether we are run in virtualbox (check if VBoxService.exe or vmtoolsd.exe are\nrunning)\nRun decrypted CTB-locker (in-memory only, never actually dropped to the disk)\nEnsure startup persistence (copy to startup folder, create registry entries, schedule task\nfor startup, etc.)\nGet default web browser application\n\nIt appears we are dealing with a slightly different version of the same crypter described by\nMarschalek and del Fierro. Not all that relevant but it was left unmentioned in their analyses\nthat the employed cipher is, again, an inline implementation of RC4 which is first used to\ndecrypt a key which is then used to decrypt the actual final payload. The final payload is\n[executed (in-memory) using the RunPE technique.](http://www.adlice.com/runpe-hide-code-behind-legit-process/)\n\nRather than trying to watch the injected final payload execute or trying to extract it from its\ninjected parent process i simply dumped the memory buffer holding it after decryption but\nbefore injection using the following small IDC script:\n```\nimport struct\nbuffer_address = 0x...\nfinal_payload_size = 0x...\nfp = open(\"final_payload\", \"wb\");\nfor i in xrange(buffer_address, buffer_address+final_payload_size):\n fp.write(struct.pack('B',Byte(i)));\nfp.close()\n\n```\nAfter dumping the final payload (which is a fully functional PE executable) we can load that\nup in our disassembler of choice.\n\n\n-----\n\n## The CTB-Locker Executable\n\nHidden within the layers of the above described crypter is the actual CTB-locker ransomware\nexecutable. It has the following characteristics:\n\nMD5: 1c0fbff0f6a18ce6d05e0026b7423b64\nSHA256: 5213f2db9add9fed538d3730ccafde120cf3822d7a4c17ec17eba6347e417f8a\nFirst virustotal submission: not seen before\nDiE signature: Microsoft Linker(10.0)\nTrID: UPX (42.3%)\n\nDespite TrID’s (cautious) UPX match the executable is in fact not packed with UPX but\ncrypted using a straight-forward VirtualAlloc/VirtualProtect style crypter with instructions\nscattered around the executable and linked by jumps (though this didn’t prove a problem for\nIDA’s pseudo-code generator which tied it together nicely):\n```\n.text:0042CD47 start      proc near\n.text:0042CD47\n.text:0042CD47 ; FUNCTION CHUNK AT .text:00416B9E SIZE 00000007 BYTES\n.text:0042CD47\n.text:0042CD47         push  ebp\n.text:0042CD48         jmp   loc_416B9E\n                                   (...)\n.text:00416B9E loc_416B9E:               ; CODE XREF: start+1j\n.text:00416B9E         mov   ebp, esp\n.text:00416BA0         jmp   crypter_routine\n                                   (...)\n.text:0046D19E         sub   esp, 20h\n.text:0046D1A1         jmp   loc_46AF19\n                                   (...)\n.text:0043AE16         call  eax\n.text:0043AE18         jmp   loc_457A62\n\n```\nWhich, in pseudo-code, looked roughly like:\n```\nVirtualAlloc(lpAddress, dwSize, ...);\ndecrypt_and_copy(lpAddress, encrypted_code, key, size);\nVirtualProtect(lpAddress, dwSize, PAGE_EXECUTE_READWRITE, ...);\nlpAddress();\n\n```\nThere are two such more or less identical layers before we get to the actual CTB-locker\ncode. I didn’t bother to look into the deobfuscation routine and simply skipped straight to the\npoint where the alloc’ed and deobfuscated memory was executed.\n\n## CTB-locker Internals\n\nMost of the internals of CTB-locker have already been outlined in various posts around the\nweb: by [Luxembourg’s CIRCL, Christophe Rieunier [1,](https://www.circl.lu/pub/tr-33/) [2] and Massimiliano Felici (aka](http://christophe.rieunier.name/securite/CTB-Locker/CTB-Locker_Payload/CTB-Locker_payload_obfuscation_layers_analysis.php)\n[‘Zairon’) [1,](https://zairon.wordpress.com/2015/02/09/ctb-locker-files-decryption-demonstration-feature/) [2]. However, i will give a brief overview of the internals covering both stuff](https://zairon.wordpress.com/2015/02/17/ctb-locker-encryptiondecryption-scheme-in-details/)\n\n\n-----\n\nalready covered and some stuff not covered before especially considering there seemed to\nbe minor differences between the sample i reverse-engineered and the ones discussed in\nvarious public analyses. The primary focus will be on the CTB-locker infrastructure and its\ncryptographic scheme as those are of primary interest.\n\n### Overview\n\n[As outlined in the analyses of CIRCL and](https://www.circl.lu/pub/tr-33/) [Rieunier CTB-locker goes through a series of](http://christophe.rieunier.name/securite/CTB-Locker/CTB-Locker_Payload/CTB-Locker_payload_obfuscation_layers_analysis.php)\npreperatory steps before it starts encrypting files. These steps can be summarized as follows\n(leaving out some of the less interesting parts):\n\nThe .onion addresses of the `payment and` `gateway servers (see the` `CTB-locker`\n```\n   infrastructure section) are deciphered\n\n```\nThe `corehash is generated`\nA mutex (with its named drived from the `corehash ) is checked for existence (to`\nprevent multiple instances of the malware running) and if it doesn’t exist is created\nA list of file extensions it wants to target is prepared\nThe ‘lock screen’ text with the ransom message is prepared (but not yet shown)\nThe executable is loaded into `svchost.exe with elevated privileges`\nWithin `svchost.exe key generation takes place (see the` `Key Generation section)`\nIn addition a thread is created which encrypts all files on fixed, removable or network\nmapped drives (see the `File Encryption section)`\nTwo seperate threads are created for ‘pingback’ communication with the `gateway`\nserver and in order to monitor payment/decryption requests by the victim (see the\n```\n   File Decryption section)\n\n```\nAll shadow copies are deleted using `vssadmin delete shadows all`\nPersistence is ensured\nA list of all encrypted files is dropped and the desktop background is changed to the\n‘lock screen’\n\n**The corehash**\n\n[Central to many of CTB-locker’s operations is what Zairon dubbed the](https://zairon.wordpress.com/2015/02/09/ctb-locker-files-decryption-demonstration-feature/) `corehash . The`\n```\ncorehash is a 256-bit value constructed as follows (in Python equivalent):\n def get_machine_guid():\n  aReg = ConnectRegistry(None, HKEY_LOCAL_MACHINE)\n  aKey = OpenKey(aReg, r\"SOFTWARE\\\\Microsoft\\\\Cryptography\")\n  return QueryValueEx(aKey, \"MachineGuid\")[0]\n def get_core_hash():\n  return sha256(get_machine_guid().replace('-', '').decode('hex')).digest()\n\n```\nThe cryptographic machine GUID holds a UUID created by Windows upon installation and is\n(in theory but not in practice) unique to the particular machine. CTB-locker uses the\n```\ncorehash by splitting it into eight 4-byte DWORDs each of which are used for a particular\n\n```\n\n-----\n\nfunction. The `corehash DWORDs are mapped to 7-character lowercase alphabetic strings`\nwhich are (due to the nature of the `corehash ) more or less ‘per-machine unique’. Mapping`\nfrom DWORD to string is done using the following function (in Python equivalent):\n```\n def dword_to_string(a1):\n  v1 = []\n  v3 = 7\n  v2 = a1\n  while (v3):\n   v4 = v2\n   v2 /= 0x1A\n   v1.append(chr((v4 % 0x1A) + 97))\n   v3 -= 1\n  return \"\".join(v1)\n\n```\nThe DWORDs serve the following purposes (among others):\n\n1st DWORD: `hiddeninfo filename (see` `Key Generation section)`\n4th DWORD: `helpinfo html filename (lists all files encrypted and contains payment`\ninstructions)\n6th DWORD: Copied malicious filename for persistence purposes\n7th DWORD: Mutex name\n\n### A brief recap of ECDH\n\nBefore we move on to key generation i’ll give a brief recap on ECC/ECDH for those who are\na little rusty on the fundamentals. Elliptic Curve Cryptography (ECC) is a public-key\n[cryptography approach using elliptic curves (ie. non-singular algebraic curves of the form y^2](https://en.wikipedia.org/wiki/Elliptic_curve)\n= x^3 + ax + b) over [finite fields (ie. fields with a finite set of elements).](https://en.wikipedia.org/wiki/Finite_field)\n\n**The (EC)DLP**\n\n[The security of ECC is reducible to the Elliptic Curve Discrete Logarithm Problem (ECDLP).](https://en.wikipedia.org/wiki/Discrete_logarithm)\nThat is, given a secret scalar `k and a public point` `P on a (good) curve it is trivial to`\n[determine the point multiplication resulting in a third public point](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication) `Q = kP mod m = P + P +`\n```\n... + P mod m but infeasible (within time and resource constraints as determined by the\n\n```\nsecurity parameter being the size of the curve) to deduct `k from` `Q and` `P . This is the`\nmultiplicative group analogue of the regular discrete logarithm problem (which underpins the\nsecurity of, among others, the regular Diffie-Hellman key agreement scheme) which states\nthat it is trivial to compute `g = b^k but infeasible to compute` `k = logb(g) . There are`\nvarious ways to attack the DLP (often parallel to approaches in integer factorization) but\nassuming the choice of curve and security parameter are solid an attacker will have to ‘hope’\nfor cryptographic scheme design or implementation flaws rather than an attack on the\nprimitive itself.\n\n**ECDH**\n\n\n-----\n\n[One ECC application is the Elliptic Curve Diffie-Hellman (ECDH) scheme which is an](https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman)\nanonymous key agreement scheme allowing for two parties (each with their own EC\nasymmetric keypairs) to establish a shared secret over an insecure channel and operates as\nfollows:\n\nNote that the ECDH protocol is unauthenticated and as such not protected against Man-inthe-Middle attacks (unless at least one public key involved is static in which case (among\nother issues) [forward secrecy, however, becomes an issue).](https://en.wikipedia.org/wiki/Forward_secrecy)\n\n**Curve25519**\n\nThe elliptic curve used by CTB-locker is djb’s [Curve25519 which offers 128 bits of security](https://en.wikipedia.org/wiki/Curve25519)\nand has the following properties:\n\n### Key Generation\n\n[As covered by Zairon in his reverse engineering of CTB-locker’s cryptographic scheme, key](https://zairon.wordpress.com/2015/02/17/ctb-locker-encryptiondecryption-scheme-in-details/)\ngeneration consists of a `GenSecretAndPublicKeys procedure which generates a random`\nsecret key and computes the corresponding public key:\n\nand a `key_generation_procedure which generates two ephemeral Curve25519 keypairs,`\na shared secret (between the secret key of the second ephemeral keypair and the master\npublic key embedded in the malware), a 256-bit AES key (consisting of the SHA256 hash\ndigest of the shared secret) and a `secret_info buffer encrypted using AES-256:`\n\n\n-----\n\nThe pseudo-code corresponding to this key generation scheme (including generation of\nasymmetric keypairs) is as follows:\n```\nint GenSecretAndPublicKeys(secret_key, public_key)\n{\n CryptGenRandom(hProv, 0x14, &rand_buffer);\n GetSystemTimeAsFileTime(&(rand_buffer + 0x14));\n (*(DWORD*)(rand_buffer + 0x1C)) = GetTickCount();\n (*(DWORD*)(rand_buffer + 0x20)) = (GetCurrentProcessId() ^ (GetCurrentThreadId() <<\n16));\n (*(DWORD*)(rand_buffer + 0x24)) = machine_guid[0];\n (*(DWORD*)(rand_buffer + 0x28)) = machine_guid[1];\n (*(DWORD*)(rand_buffer + 0x2C)) = machine_guid[2];\n (*(DWORD*)(rand_buffer + 0x30)) = machine_guid[3];\n secret_key = SHA256(rand_buffer, 52);\n (*(BYTE*)(secret_key)) &= 0xF8;\n (*(BYTE*)(secret_key + 0x1F)) = (((*(BYTE*)(secret_key + 0x1F)) & 0x3F) | 0x40);\n return curve25519(public_key, secret_key, (int)&basepoint);\n}\nint key_generation_procedure()\n{\n (...)\n CryptAquireContextW(hProv, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);\n GenSecretAndPublicKeys(&secret_key_1, &public_key_1);\n GenSecretAndPublicKeys(&secret_key_2, &public_key_2);\n curve25519(&shared_secret, &secret_key_2, &master_public_key);\n aes_key = SHA256(&shared_secret, 32);\n AES_set_encrypt_key(&aes_key, 256, &aes_expanded_key);\n counter = 0;\n do\n {\n  AES_encrypt((int)(&secret_info[counter], &secret_info[counter],\n&aes_expanded_key);\n  counter += 4;\n }\n while ( counter <= 0x28 );\n (...)\n return result;\n}\n\n```\n\n-----\n\nThe `secret_info segment holds` `secret_key_1 and an 8-byte` `machine guid variable`\nused to identify the victim to the backend server (see `File Decryption section) upon`\ncommunications. The `master public key corresponding to this particular campaign is` `D5`\n```\n46 B3 24 6C 7D 19 DA F4 C9 D7 1A 05 63 C3 F4 82 BC 18 35 1C 71 C1 35 AB 4F\n6F 7A 6C 46 95 75 .\n\n```\nJudging from the disassembly, the Curve25519 implementation seems to be taken directly\nfrom Adam Langley’s implementation of the curve25519_donna function based on djb’s\noriginal implementation and as such seems solid. The encrypted `secret_info is stored in`\na hidden file (called `hiddeninfo in Zairon’s analysis) of 654 bytes in`\n```\n<CommonappDataFolder>\\microsoft whose name is derived from the first DWORD of the\ncorehash . The hiddeninfo file is organized roughly as follows and includes the 5 ‘demo’\n\n```\nkeys allowing users to decrypt 5 files offline for free in a “show of good faith” by the\nransomware:\n\n\n-----\n\nThis info block is stored in memory (with the `secretinfo segment encrypted as described`\nbelow) and later written to the `hiddeninfo file. Apart from the seperate encryption of the`\n```\nsecretinfo segment the entire info block is also encrypted prior to storage in\nhiddeninfo using the following approach:\nint store_hidden_info(hidden_info)\n{\n AES_set_encrypt_key(&core_hash, 256, &core_hash_expanded_key);\n counter = 0;\n do\n {\n  AES_encrypt((BYTE*)(hidden_info + counter), (BYTE*)(hidden_info + counter),\ncore_hash_expanded_key);\n }\n while (counter < 0x27E);\n hFile = CreateFile(hidden_info_filename, ...); \n WriteFile(hFile, hidden_info, ...);\n}\n\n```\nThis effectively encrypts the hidden info under the `corehash as the AES key in what has to`\nbe the most inefficient custom block cipher mode of operation i’ve seen yet. In short, the AES\nencryption operates as a block-sized byte-by-byte sliding window over the plaintext. Either\nway this seems more of an obfuscation measure than one meant to ensure information\nconfidentiality as the `corehash can be trivially determined by us. What we’re after,`\nhowever, is `secret_key_1 (see the section on` `File Decryption ) which is seperately`\nencrypted (prior to this encryption) under an AES key derived from the SHA256 hash digest\nof the shared secret between the 2nd ephemeral secret key and the ransomware author(s)’\nmaster public key.\n\n\n-----\n\nGiven the cryptographic centrality of this `shared_secret (from which the key encrypting`\nthe `secretinfo block holding our target` `secret_key_1 is derived) which is established`\nduring the key generation process it is worth taking a look at the RNG underlying the\ngeneration of secret keys. All 256-bit secret keys are derived using SHA256 from 448 bits of\n‘random’ data. This random data is composed as follows:\n\nThe components of this random data are, however, random only to varying degrees.\nAssuming we are faced with a system after it has been hit by a CTB-locker infection (as\nopposed to a running infection) we can deduce the following elements:\n\nGetSystemTimeAsFileTime: This function retrieves the current system date and time in\nUTC format. Given that the ransomware copies itself to `%CSIDL_LOCAL_APPDATA%`\nimmediately after it is run (and just before key generation), creates the `hiddeninfo`\nfile just before encryption and modifies it again just after encryption we can deduce the\n8 bytes drived from this function from the creation/modification datetime stamps of\nthese files (or at the very least reduce the contributed entropy to an absolute minimum\nof a few bits).\n\n\n-----\n\nMachineGuid: We can derive these 16 bytes directly from the\n```\n   HKLM\\SOFTWARE\\Microsoft\\Cryptography\\MachineGuid registry key.\n\n```\nIn addition, depending on the circumstances in which we respond to the infection, we can\nreduce (or fully eliminate) the contributed entropy of the following elements:\n```\n   GetTickCount : This value measures the number of milliseconds that have elapsed\n\n```\nsince system startup. The current system uptime can be retrieved on windows systems\nusing eg. the `systeminfo command (or seen directly in the task manager on`\nWindows 7 systems). Provided the system did not reboot after infection (or the system\nmaintains a log of boot times) we can narrow down the `GetTickCount value at`\ninfection time by subtracting the amount of time ellapsed between creation of the\n```\n   hiddeninfo file and the current moment and subtracting the result of that from the\n\n```\ncurrent system uptime, ie.: `tickestimate = (current_uptime - (current_time -`\n```\n   hiddeninfo_creation_time)) . While this might not get us an exact estimate it does\n\n```\nsignificantly reduce the function’s contributed entropy.\n```\n   GetCurrentProcessId / GetCurrentThreadId : This function returns the PID of the\n\n```\ncalling process. If we are responding to an infection on a machine where the infection\nis still running (or the systems maintains a very granular logging of process events) we\ncan identify the malicious process (which remains active since it runs two threads\nmonitoring for payment/decryption attempts on part of the victim) from where CTBlocker is executing and derive the process and thread ids accordingly (using eg.\n[Process Explorer).](https://technet.microsoft.com/en-us/sysinternals/processexplorer.aspx)\n\nIn the absolute best case scenario, where we manage to eliminate all entropy contributed by\nthe above mentioned functions, this still leaves us with the 160 bits of entropy contributed by\n```\nCryptGenRandom . CryptGenRandom is the CSPRNG provided by the Microsoft Crypto API\n\n```\nand can generally be considered secure. It is based on SHA-1 and derives its entropy from\nthe following sources:\n\nGetCurrentProcessID\nGetCurrentThreadID\nGetTickCount\nGetLocalTime\nQueryPerformanceCounter\nAn MD4 hash of the user’s environment block (which includes username, computer\nname, etc.)\nHigh-precision internal CPU counters, such as RDTSC, RDMSR, RDPMC\nVarious other sources as outlined in the 2nd edition of ‘Writing Secure Code’ by\n[Howard and LeBlanc and this post](http://blogs.msdn.com/b/michael_howard/archive/2005/01/14/353379.aspx)\n\nI think it is pretty safe to say that even if we reduce the entropy contributed by a few\nfunctions whose values we can reconstruct post-incident that the remaining entropy\ncontributed to the secret keys by `CryptGenRandom makes secret key prediction infeasible`\n\n\n-----\n\nat first glance. One would have to deal with the above best case scenario and then\nsomehow effectively reduce the `CryptGenRandom entropy to a quarter of what it is (say ~40`\nbits) to make brute-forcing (with dedicated hardware no less) a feasible approach. So that\nprobably isn’t going to happen but i’d love to be proven wrong here.\n\n### File Encryption\n\nAs discussed in the overview CTB-locker encrypts files (identified on the basis of a list of\ntarget extensions) from within a dedicated thread. File encryption functionality (identifiable by\nthe byte signature `50 F3 A5 E8 03 E9 FF FF 6A 07 33 C0 59 C6 85 4C should`\nanyone want to check out the function for themselves) is as follows:\n\nThe file is moved to a temporary file ( %TEMP%\\<name>.tmp where `<name> is`\ndetermined by the `corehash ) using the MoveFileEx API call`\nThe temporary file is read into memory\nA asymmetric keypair and symmetric secret key are generated\n[The file buffer is compressed using the DEFLATE data compression algorithm from the](https://en.wikipedia.org/wiki/DEFLATE)\n[zlib library (which is statically linked against the executable)](https://en.wikipedia.org/wiki/Zlib)\nAfter compression the file buffer is encrypted using AES-256-ECB\nA header consisting of the public key associated with this file and an encrypted\n```\n   infovector is prepended to the encrypted data\n\n```\nThe header-prepended encrypted buffer is written to the temporary file\nThe temporary file is moved to overwrite the original file using the MoveFileEx API call\nwith the original file getting a new extension (derived from the `corehash ) appended`\nto it\n\n[The file encryption scheme, as documented by Zairon, looks as follows in pseudo-code:](https://zairon.wordpress.com/2015/02/17/ctb-locker-encryptiondecryption-scheme-in-details/)\n\n\n-----\n\n```\nint encrypt_file()\n{\n (...)\n rand_buffer = generate_random_buffer();\n file_curve25519_secret_key = SHA256(&rand_buffer, 48);\n curve25519(&file_curve25519_public_key, &file_curve25519_secret_key, &basepoint);\n curve25519(&file_shared_secret, &file_curve25519_secret_key, &public_key_1);\n file_aes_key = SHA256(&file_shared_secret, 32);\n AES_set_encrypt_key(&file_aes_key, 256, &file_aes_expanded_key);\n (...)\n zlib_DEFLATE(&plaintext);\n for every block of plaintext:\n  AES_encrypt(&block, &block, &aes_expanded_key);\n (...)\n *((DWORD*)infovector) = 'CTB1';\n *((DWORD*)infovector + 4) = infovalue1;\n *((DWORD*)infovector + 8) = infovalue2;\n *((DWORD*)infovector + 12) = 0x00000001;\n AES_encrypt(&infovector, &infovector, &aes_expanded_key);\n (...)\n}\n\n```\nAs the above pseudo-code shows every file is encrypted with a different symmetric key\ndrived from a shared secret between `public_key_1 (generated during the` `Key`\n```\nGeneration phase) and the secret key component of a newly generated ephemeral\n\n```\nCurve25519 keypair.\n\nNote that while encryption is done using AES-256-ECB (a very insecure block cipher mode\nof operation) the security goals of the ransomware are different than those of regular\ncryptographic use. While some confidentiality is lost (due to the infamous ‘ECB penguin’\npattern-perserving nature of ECB mode) this is insufficient to achieve what we would want of\nthis scenario: recovery of file contents. This is especially the case since compression is\napplied to the plaintext before encryption.\n\nThe encrypted file format is as follows:\n\n\n-----\n\n### File Decryption\n\nIn order to decrypt a file one needs to be in possession of `file_aes_key which in turn`\nmeans one needs to be in possession of `file_shared_secret . The only feasible way to`\nobtain this shared secret is through a combination of either `public_key_1 and`\n```\nfile_curve25519_secret_key or file_curve25519_public_key and secret_key_1 .\n\n```\nGiven that the ephemeral secret key is lost after encryption and we only have\n```\nfile_curve25519_public_key (stored plainly in the header prepended to all encrypted\n\n```\nfiles) this means we need to recover `secret_key_1 to decrypt any given file. Since`\n```\nsecret_key_1 is stored in encrypted form in the secretinfo section of the\nhiddeninfo file this in turn means we need to be able to decrypt the secretinfo section\n\n```\nwhich was encrypted using a symmetric key derived from the shared secret between\n```\nsecret_key_2 and master_public_key . Considering that secret_key_2 is lost upon\n\n```\nencryption this would require us to have `public_key_2 and` `master_secret_key . Since`\nthe latter is stored on a backend server belonging to the CTB-locker infrastructure there is no\ncryptanalytic (brute-force or otherwise) way to feasibly recover the required keys.\n\n\n-----\n\nWhen the victim wants to decrypt their files they can do so either by navigating (using TOR)\nto the payment server or they can use the interactive ‘lockscreen’ overlaying the victim’s\ndesktop background. In case of the latter the malware will contact the `gateway server`\n(see the `CTB-locker infrastructure section) to request payment details which looks as`\n[follows (image courtsey of Kaspersky:](https://securelist.com/analysis/publications/64608/a-new-generation-of-ransomware/)\n\n[Upon requesting decryption the malware contacts the gateway server and sends the](https://www.circl.lu/pub/tr-33/)\nfollowing data (in encrypted form as per the details in the infrastructure section) taken from\nthe `hiddeninfo file:`\n\npublic_key_2\nencrypted `secretinfo block (contains` `secret_key_1 and` `machine guid in`\nencrypted form)\nsome general information\n\nIf the ransom has not been paid yet for this particular infection the gateway responds with the\nbitcoin address and payment price info. When the set amount is paid to the bitcoin address\nin question `secret_key_1 is extracted from the received` `secretinfo block (using the`\n```\nmaster_secret_key ) and sent by the gateway server to the malware upon bitcoin\n\n```\ntransaction confirmation. Next the malware can calculate the shared secret (and thus the aes\nkey) for every encrypted file and perform decryption.\n\n\n-----\n\nIt is worth noting that the malware connects to the host `ip.telize.com to utilize its IP and`\nGeoIP API and attempts to connect to the `gateway server using the “onion.gq”`\nonion2web access portal should direct access over TOR fail. The communication with the\n```\ngateway server consist of the following POST requests:\ndebug036:00846064 aPostMsgHttp1_1HostSContent db 'POST /msg HTTP/1.1',0Dh,0Ah\ndebug036:00846064                     ; DATA XREF:\ngateway_info_thread+127o\ndebug036:00846064         db 'Host: %s',0Dh,0Ah\ndebug036:00846064         db 'Content-Length: %i',0Dh,0Ah\ndebug036:00846064         db 0Dh,0Ah,0\ndebug036:0084609C aPostUnlockHttp1_1HostSCont db 'POST /unlock HTTP/1.1',0Dh,0Ah\ndebug036:0084609C                     ; DATA XREF:\ngateway_info_thread+16Co\ndebug036:0084609C         db 'Host: %s',0Dh,0Ah\ndebug036:0084609C         db 'Content-Length: %i',0Dh,0Ah\ndebug036:0084609C         db 0Dh,0Ah,0\n\n```\nWhereas the parsing of its response utilizes the following strings (with response= as the\nindicator of the ciphertext which is decrypted and further parsed using the other strings):\n\n\n-----\n\n```\ndebug036:00845F1C aSpanResponse  db <span>response,0 ; DATA XREF:\nextract_response+17o\ndebug036:00845F2C aSpan      db '</span>',0     ; DATA XREF:\nextract_response+4Co\ndebug036:00845F34 aKey      db 'key=',0       ; DATA XREF:\nextract_response+D7o\ndebug036:00845F39         db  0\ndebug036:00845F3A         db  0\ndebug036:00845F3B         db  0\ndebug036:00845F3C aUsd      db 'usd=',0       ; DATA XREF:\nextract_response+E4o\ndebug036:00845F41         db  0\ndebug036:00845F42         db  0\ndebug036:00845F43         db  0\ndebug036:00845F44 aEur      db 'eur=',0       ; DATA XREF:\nextract_response:loc_76051Fo\ndebug036:00845F49         db  0\ndebug036:00845F4A         db  0\ndebug036:00845F4B         db  0\ndebug036:00845F4C aAddress    db 'address=',0     ; DATA XREF:\nextract_response+19Do\ndebug036:00845F55         db  0\ndebug036:00845F56         db  0\ndebug036:00845F57         db  0\ndebug036:00845F58 aPaid      db 'paid=',0      ; DATA XREF:\nextract_response+1F1o\ndebug036:00845F5E         db  0\ndebug036:00845F5F         db  0\ndebug036:00845F60 aMsg      db 'msg=',0       ; DATA XREF:\nextract_response+23Co\ndebug036:00845F65         db  0\ndebug036:00845F66         db  0\ndebug036:00845F67         db  0\ndebug036:00845F68 aPrice     db 'price=',0      ; DATA XREF:\nextract_response+248o\ndebug036:00845F6F         db  0\ndebug036:00845F70 addr_info    db 38h ; 8       ; DATA XREF: get_wan_ip+7Co\ndebug036:00845F71         db 30h ; 0\ndebug036:00845F72         db  0\ndebug036:00845F73         db  0\n\n### The CTB-locker infrastructure\n\n```\n[The CTB-locker infrastructure has been partially documented (in some cases concerning](http://malware.dontneedcoffee.com/2014/07/ctb-locker.html?showComment=1432541679251)\n[apparently older versions than the sample in question here) around](http://malware.dontneedcoffee.com/2015/05/on-other-side-of-ctb-locker-affiliate.html) [the](https://www.circl.lu/pub/tr-33/) [web. The authors of](https://securelist.com/analysis/publications/64608/a-new-generation-of-ransomware/)\nthe CTB-locker malware both sell the ransomware and appear to be running an affiliate\nprogram.\n\nThe infrastructure basically consists of three components all hosted as TOR hidden services:\n```\n   payment server : This is the server where users can navigate to using TOR and can\n\n```\nenter their public key to identify themselves and get their payment instructions and,\nupon payment decryption key This is the only server users will ‘openly’ interact with\n\n\n-----\n\n```\n   gateway server : This is the server contacted by the malware when users use the\n\n```\n‘lock screen’ decryption request functionality.\n```\n   affiliate server : This server is used for ‘affiliates’ who join the CTB-locker\n\n```\ncampaign for a share of the profit.\n\nNote that CTB-locker doesn’t download or drop a pre-compiled TOR executable but is\nstatically linked against the TOR code. Communications with the hidden services are done\nby setting up a local TOR proxy (running on a port derived from the `corehash ) and running`\nnetwork communications to the backend infrastructure over this local proxy.\n\nThe infrastructure roughly looks as follows:\n\n**Payment Server**\n\n[The payment server looks as follows (as per SANS ISC’s post on the matter):](https://isc.sans.edu/diary/DalexisCTB-Locker+malspam+campaign/19641)\n\n\n-----\n\nThe onion address of the payment server corresponding to this campaign is\n```\njssestaew3e7ao3q.onion .\n\n```\n**Gateway Server**\n\n[As outlined by Kaspersky’s Fedor Sinitsyn network communications with the gateway server](https://securelist.com/analysis/publications/64608/a-new-generation-of-ransomware/)\nare encrypted as follows:\n\nThe server’s public key is embedded in the malware body\nA session ephemeral Curve25519 keypair is generated\n\n\n-----\n\nA shared session secret is established from the ephemeral secret key and server\npublic key\nA shared session symmetric secret key is derived by taking the SHA256 hash digest of\nthe shared session secret\nThe session ephemeral public key is sent to the server\nNetwork communications in both directions are encrypted using the session symmetric\nsecret key\n\nThe onion address of the gateway server corresponding to this campaign is\n```\nrmxlqabmvfnw4wp4.onion .\n\n```\n**Affiliate Server**\n\n[As covered by the malware researcher ‘Kafeine’ the CTB-locker developers offer an affiliate](http://malware.dontneedcoffee.com/2015/05/on-other-side-of-ctb-locker-affiliate.html)\nprogram (next to their sales of the full ransomware kit) so cybercriminals can participate in\nthe scheme without major investments, helping spread the malware and get a cut of the\nprofits without having to operate the backend infrastructure. ‘Kafeine’ provided some\nscreenshots of the affiliate server the most interesting of which show how affiliates have\npersonal `payment and` `gateway servers (build into the exe), the possibility to establish`\ncustom pricing rules (depending on country, filesize, etc.), an API interface and the fact that\n[so-called bitcoin ‘mixing services’ are used to clean/launder payout money. In addition it](https://en.bitcoin.it/wiki/Mixing_service)\nshows Dutch language translations were added on 15-12-2014.\n\nThe affiliate server’s onion address is `ctbservermurt37p.onion with`\n```\nctb2ndyexrfi7zsn.onion as a backup address.\n\n## Recovery options\n\n```\nIn this section i’ll briefly discuss various approaches for recovery and why virtually all of them\nare dead ends. The above analysis speaks for itself with regards to the cryptographic\nscheme and its underlying primitives so i will not cover those any further.\n\n### Attacking CTB-locker through memory forensics\n\nThe key we seek to eventually obtain ( secret_key_1 ) is stored not in volatile memory (eg.\nthe stack) but at a hardcoded offset within the executable’s memory image. Given that the\nexecutable keeps running in the background after infection (in order to facilitate ransom\npayments) a memory dump of the process will dump the contents of the data at this offset as\nwell. Unfortunately when the key is encrypted as part of the `secretinfo section this is`\ndone in-place and as such the dump will only contain data we can already extract from the\n```\nhiddeninfo file. The only moment in time where secret_key_1 is available in plaintext\n\n```\nform is extremely briefly between its generation and its encryption which is prior to the\ninfection making itself known, effectively ruling out the possibility of recovering\n```\nsecret_key_1 this way.\n\n```\n\n-----\n\nWhat we might be able to recover (though the chance is extremely small that this succeeds)\nare remnants of the ephemeral file-specific Curve25519 keypairs or AES key schedules on\nthe stack (provided they haven’t been overwritten during subsequent execution). Note that\nthis ONLY applies when you find yourself responding to an infected machine that hasn’t been\nrebooted yet. If the ransomware process has been terminated, the (already terribly small\nchance) of success disappears completely here. Memory dump inspection can be done by\nfollowing these steps:\n\n[Make a targeted (full) process memory dump using eg. Process Explorer: in the](https://technet.microsoft.com/en-us/sysinternals/processexplorer.aspx)\nprocess listing pick the child process of `svchost.exe with the 7 alphabetic character`\nname (derived from the 6th `corehash DWORD) -> right-click -> create dump ->`\ncreate full dump\n\nMake a backup of all files encrypted by CTB-locker\n\nTry one of the scripts or approaches below to recover keying material\n\nIf you recovered an ephemeral keypair, iterate through all encrypted files until one with\na matching public key in the encryption header is found\n\nIf you recovered an AES key, apply it in a brute-force manner to all encrypted files,\nchecking whether it applies to the infovector (if the first 4 plaintext bytes are ‘CTB1’) or\nto the file in question\n\nIn order to identify ephemeral keypairs we will scan through the memory dump and look for\ntwo 256-bit bytestrings located at 0x70 bytes from eachother (given that the keypair is\nlocated at this distance from eachother in the file encryption function stackframe and this\ndistance is static) which form a valid Curve25519 keypair. Testing this on a (dummy) memory\n[dump looks as follows using this small (and very slow) demo script i wrote:](https://github.com/samvartaka/ctb_locker/blob/master/ctb_memhunter.py)\n```\npython ctb_memhunter.py --dumpfile ./test.dmp --distance 112\n  .CTB-locker memory dump analyzer.\n     (c) 2015, Jos Wetzels\n[+]Found candidate ephemeral keypair!\nSecret: [4141414141414141414141414141414141414141414141414141414141414141]\nPublic: [327df3fc3cdf3f6e37720681f6cce35782018bbaac13696a1497d42c07d3263a]\n\n```\n[In order to identify AES key schedules we can use the FindAES tool by Jesse Kornblum](http://sourceforge.net/projects/findaes/)\nwhich identifies AES schedules (of multiple AES variants but including the one we are\nlooking for, AES-256) in a memory dump. Of course one could take a desperate approach to\nboth scenarios by simply using all 256-bit strings from the memory dump in a brute-force\nattack but this doesn’t make much sense.\n\n\n-----\n\nI didn t have the time to expand this beyond a rather trivial idea, particularly as the chance at\nsuccess is very small here, but should anyone feel the urge to work this out a bit further be\nsure to let me know.\n\n### If the master private key is obtained\n\nThe most reliable recovery scenario would involve obtaining the master private key\ncorresponding to the master public key for the particular campaign an infection belongs to, in\nthis case that would be the private key of `D5 46 B3 24 6C 7D 19 DA F4 C9 D7 1A 05 63`\n```\nC3 F4 82 BC 18 35 1C 71 C1 35 AB 4F 6F 7A 6C 46 95 75 . Recovery of such a key\n\n```\nwould involve a seizure of the CTB-locker infrastructure in order to extract it from the\nbackend where it is held. Until the time that happens there is relatively little to do. Should any\nCTB-locker private keys ever be made public, however, i [have written a small script capable](https://github.com/samvartaka/ctb_locker/blob/master/ctb_recover.py)\nof decrypting CTB-locker encrypted files when provided with the correct master private key.\n\nBefore anyone contacts me for help recovering their files, however, please note that this only\nworks in the event that the required master private key is recovered due to, for example, law\nenforcement seizing the CTB-locker backend infrastructure. Without that key this script\ncannot work.\n\n[In order to run it one will need to first run the following helper script i wrote on the infected](https://github.com/samvartaka/ctb_locker/blob/master/ctb_help.py)\nmachine:\n```\npython ctb_help.py\n{'hidden_info': u'C:\\\\ProgramData\\\\xtvxemq', 'corehash':\n'0000000000000000000000000000000000000000000000000000000000000000'}\n\n```\nWhich gives us the location of the `hiddeninfo file and the` `corehash that can be used to`\ndecrypt it. Make a backup of this `hiddeninfo file and feed the file, the` `corehash and the`\nmaster private key into the recovery script:\n\n\n-----\n\n```\n$ python ctb_recover.py hiddeninfo ./xtvxemq corehash\n0000000000000000000000000000000000000000000000000000000000000000 --tdir ./tdir/ -rdir ./rdir/\n .CTB-locker file decryption tool.\n   (c) 2015, Jos Wetzels\n[-] No master private key supplied, could not recover secretinfo\n[+] Dumping hiddeninfo:\n[+] Public Key 1: [076188020eac609f57363d086a1b69163108cdb111f4167b55d66a1ff952611c]\n[+] Public Key 2: [3910ee01a9896c6442767d4f3efd82d93434979017c331786d755aff1a6cd30c]\n[+] Demo Secret Key 0:\n[2673eaa7d963b3202bf16a34eaa63b28693ce0e966ae571d22ae950dcd8c618a]\n[+] Demo Secret Key 1:\n[7af007512f592ee690ae32d5bab0518480787872d910ae6472bb84780ab63bcf]\n[+] Demo Secret Key 2:\n[27049ae36a905705efbc09e125545230ed7d4220a752a70ea02867522ab74a46]\n[+] Demo Secret Key 3:\n[1721713904937696e741c67160c4ac03d3fa2867d438570f4f978721b1b965fe]\n[+] Demo Secret Key 4:\n[31b419097e2ebf2aad6b9cb3215143b8bc3a0d86a7ed2da7727607b7216299bf]\n[+] Payment Server: [jssestaew3e7ao3q.onion]\n\n### Misc. recovery options\n\n```\n[As a last option one can always try to take one of the steps as outlined here:](http://www.bleepingcomputer.com/virus-removal/ctb-locker-ransomware-information)\n\nRestore from backups. A good and consistent backup policy is important to cope with\nall forms of dataloss. As such if you haven’t regularly made backups before start doing\nso now. And make sure the backups are stored ‘at rest’, ie. not on drives connected to\na machine that could potentially be infected thus defeating the backup purpose.\n\nUse shadow volume copies. Even though CTB-locker tries to delete all shadow volume\ncopies there is a chance this fails and restoring might work this way.\n\nFile recovery software. Since CTB-locker encrypts files by ‘moving them around’ (using\nthe MoveFile API call) rather than doing fully in-place encryption file recovery tools\nsuch as [Photorec might be able to recover some files. The success of this depends on](http://www.cgsecurity.org/wiki/PhotoRec)\nhow much (or rather how little) the infected machine has been used (ie. writing to the\naffected disks) since the infection occured.\n\nThe overall takeaway here, however, is that the cryptographic scheme and primitives\nunderlying CTB-locker are solid (given its intended goal) and so is its implementation (eg.\nuse of CSPRNGs, statically linked ‘off-the-shelf’ cryptographic libraries, etc.), more or less.\nApart from the very slim chance at the memory-forensics key recovery attack described\nabove it seems your best chances are with infection prevention and a solid backup policy.\n\n## IOCs\n\n\n-----\n\n[For completeness i have included a set of Indicators Of Compromise (IOCs) in the OpenIOC](http://www.openioc.org/)\nformat for the attack vector and malware involved in this campaign which can be downloaded\n[here.](https://github.com/samvartaka/ctb_locker/blob/master/ctblocker.ioc)\n\n[samvartaka 20 November 2015](https://samvartaka.github.io/)\n\n[Next Post →](https://samvartaka.github.io/cryptanalysis/2016/02/02/videocrypt-uavs) [← Earlier Post](https://samvartaka.github.io/malware/2015/09/13/hackingteam-crypter)\n[Content by samvartaka. Design by Mark Reid](https://samvartaka.github.io/about)\n[(Some rights reserved)](http://creativecommons.org/licenses/by-nc-sa/3.0/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2015/2015-11-20 - A king's ransom- an analysis of the CTB-locker ransomware.pdf"
    ],
    "report_names": [
        "2015-11-20 - A king's ransom- an analysis of the CTB-locker ransomware.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "ee3363a4-e807-4f95-97d8-b603c31b9de1",
            "created_at": "2023-01-06T13:46:38.485884Z",
            "updated_at": "2025-03-27T02:00:02.845851Z",
            "deleted_at": null,
            "main_name": "FIN6",
            "aliases": [
                "Camouflage Tempest",
                "MageCart Group 6",
                "G0037",
                "TA4557",
                "SKELETON SPIDER",
                "ITG08",
                "White Giant",
                "GOLD FRANKLIN",
                "ATK88"
            ],
            "source_name": "MISPGALAXY:FIN6",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "12517c87-040a-4627-a3df-86ca95e5c13f",
            "created_at": "2022-10-25T16:07:23.61665Z",
            "updated_at": "2025-03-27T02:02:09.889471Z",
            "deleted_at": null,
            "main_name": "FIN6",
            "aliases": [
                "ATK 88",
                "Camouflage Tempest",
                "FIN6",
                "Gold Franklin",
                "ITG08",
                "Skeleton Spider",
                "TAAL",
                "TAG-CR2",
                "White Giant"
            ],
            "source_name": "ETDA:FIN6",
            "tools": [
                "AbaddonPOS",
                "Agentemis",
                "AmmyyRAT",
                "Anchor_DNS",
                "BlackPOS",
                "CmdSQL",
                "Cobalt Strike",
                "CobaltStrike",
                "FlawedAmmyy",
                "FrameworkPOS",
                "Grateful POS",
                "JSPSPY",
                "Kaptoxa",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "LockerGoga",
                "MMon",
                "Magecart",
                "Meterpreter",
                "Mimikatz",
                "More_eggs",
                "NeverQuest",
                "POSWDS",
                "Reedum",
                "Ryuk",
                "SCRAPMINT",
                "SONE",
                "SpicyOmelette",
                "StealerOne",
                "Taurus Loader Stealer Module",
                "Terra Loader",
                "TerraStealer",
                "Vawtrak",
                "WCE",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "cobeacon",
                "grabnew"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "ea7bfe06-7c23-481d-b8ba-eafa6cda3bc9",
            "created_at": "2022-10-25T15:50:23.317961Z",
            "updated_at": "2025-03-27T02:00:55.440858Z",
            "deleted_at": null,
            "main_name": "FIN6",
            "aliases": [
                "FIN6",
                "Magecart Group 6",
                "ITG08",
                "Skeleton Spider",
                "TAAL",
                "Camouflage Tempest"
            ],
            "source_name": "MITRE:FIN6",
            "tools": [
                "FlawedAmmyy",
                "GrimAgent",
                "FrameworkPOS",
                "More_eggs",
                "Cobalt Strike",
                "Windows Credential Editor",
                "AdFind",
                "PsExec",
                "LockerGoga",
                "Ryuk",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673536183,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653787657,
    "ts_modification_date": 1653787657,
    "files": {
        "pdf": "https://archive.orkl.eu/b9aa62e1d1f2d620496352489c49f29eb47f055a.pdf",
        "text": "https://archive.orkl.eu/b9aa62e1d1f2d620496352489c49f29eb47f055a.txt",
        "img": "https://archive.orkl.eu/b9aa62e1d1f2d620496352489c49f29eb47f055a.jpg"
    }
}