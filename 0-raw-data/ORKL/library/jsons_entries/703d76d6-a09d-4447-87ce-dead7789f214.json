{
    "id": "703d76d6-a09d-4447-87ce-dead7789f214",
    "created_at": "2023-01-12T14:59:09.46737Z",
    "updated_at": "2025-03-27T02:09:18.746719Z",
    "deleted_at": null,
    "sha1_hash": "1599a73da116609df15422d3cd3db212cba4a6c7",
    "title": "Writing a C Yara Agent",
    "authors": "",
    "file_creation_date": "2022-07-14T20:52:05Z",
    "file_modification_date": "2022-07-14T20:52:05Z",
    "file_size": 434269,
    "plain_text": "# Writing a C++ Yara Agent\n\n**mez0.cc/posts/yaraengine**\n\n## Table of Contents\n\nTable of Contents\nIntroduction\nYara?\nYara Library Setup\n\nInstalling Yaralib\nInitializing the Library\nCreating a Compiler\nAdding rules\nDetecting Cobalt Strike\n\nReading Process Memory Regions\nReading regions to buffer\nScanning Memory Regions\nDemo\nConclusion\n\n## Introduction\n\n[Whilst writing PreEmpt, one of the requirements was to make use of Yara to be able to](https://mez0.cc/projects/preempt/)\nidentify malware families. In this blog, I wanted to just go over the development process to\nmake use of the C API available for Yara.\n\n## Yara?\n\nFrom [https://virustotal.github.io/yara/:](https://virustotal.github.io/yara/)\n\nYARA is a tool aimed at (but not limited to) helping malware researchers to identify and\nclassify malware samples. With YARA you can create descriptions of malware families (or\nwhatever you want to describe) based on textual or binary patterns. Each description, a.k.a rule,\nconsists of a set of strings and a boolean expression which determine its logic.\n\nEssentially, it allows for rules to be ran over memory, processes, and files to identify malware\nfamilies. Rules are easy to write, here is an example from the Yara homepage:\n\n\n-----\n\n```\nrule silent_banker : banker\n\n{\n\n  meta:\n\n    description = \"This is just an example\"\n\n    threat_level = 3\n\n    in_the_wild = true\n\n  strings:\n\n    $a = {6A 40 68 00 30 00 00 6A 14 8D 91}\n\n    $b = {8D 4D B0 2B C1 83 C0 27 99 6A 4E 59 F7 F9}\n\n    $c = \"UVODFRYSIHLNWPEJXQZAKCBGMT\"\n\n  condition:\n\n    $a or $b or $c\n\n}\n\n```\nThis isn't a blog on writing Yara rules, but essentially `strings are the \"match\" criteria, and`\n```\ncondition are when to flag the rule. In this case, if any of the strings match, then the\n\n```\nrule flags as a match.\n\nWhat this blog will do is write a small agent to run these rules against a specified process ID.\nSo, for that, rules are required. All I did was Google: `cobalt strike yara rules github`\nand made a `.yar file containing rules from:`\n\n1. [https://github.com/Neo23x0/signature-base/blob/master/yara/apt_cobaltstrike.yar](https://github.com/Neo23x0/signature-base/blob/master/yara/apt_cobaltstrike.yar)\n2. [https://github.com/jas502n/cs_yara](https://github.com/jas502n/cs_yara)\n3. https://github.com/Neo23x0/signature\nbase/blob/master/yara/apt_cobaltstrike_evasive.yar\n[4. https://github.com/mgreen27/cobaltstrike-1](https://github.com/mgreen27/cobaltstrike-1)\n\n[5. https://github.com/JPCERTCC/MalConfScan/blob/master/yara/rule.yara](https://github.com/JPCERTCC/MalConfScan/blob/master/yara/rule.yara)\n[6. https://github.com/Te-k/cobaltstrike](https://github.com/Te-k/cobaltstrike)\n\nAll these rules will be ran against the target process. However, the usage of the tool produced\nin this blog can be used as a Yara rule tester. The commandline arguments will be:\n```\nYaraAgent.exe <path to rule> <process id>\n\n\n```\nLet's write some code.\n\n## Yara Library Setup\n\n### Installing Yaralib\n\n[To get Yara's library into Visual Studio, I used vcpkg. Once installed:](https://vcpkg.io/en/packages.html)\n```\n.\\vcpkg install yara\n\n```\n\n-----\n\nThen Yara is available as:\n```\n#include <yara.h>\n\n\n### Initializing the Library\n\n```\nThe [Yara C API documentation is okay, but it lacks when it comes to actually scanning. So,](https://yara.readthedocs.io/en/stable/capi.html)\nfirst thing:\n\nThe first thing your program must do when using libyara is initializing the library. This is done\nby calling the `yr_initialize() function.`\n\nThe library needs to be initialized, for me, I like to use C++ namespaces and classes for this.\nThis will become useful as Yara requires an initialize, and a finalize. Which are perfect\ncandidates for C++ constructors and destructors.\n\nLets add that:\n```\nnamespace Yara\n\n{\n\n  class Manager\n\n  {\n\n  public:\n\n    Manager()\n\n    {\n\n      int init = yr_initialize();\n\n      if (init != ERROR_SUCCESS)\n\n      {\n\n        printf(\"Initialise failed: %s\\n\", GetErrorMsg(init).c_str());\n\n        return;\n\n      }\n\n    }\n\n    ~Manager()\n\n    {\n\n      int finalise = yr_finalize();\n\n      if (finalise != ERROR_SUCCESS)\n\n      {\n\n        printf(\"Finalise failed: %s\\n\", GetErrorMsg(finalise).c_str());\n\n        return;\n\n      }\n\n    }\n\n  }\n\n}\n\n\n```\n[Here, yr_initialize() and yr_finalize() are being called which must be done in the main](https://yara.readthedocs.io/en/stable/capi.html#c.yr_initialize)\nthread. As these are just in the constructor and destructor, they can just be passively handle\nby creating the object:\n```\nYara::Manager yara = Yara::Manager();\n\n```\n\n-----\n\n### Creating a Compiler\n\nThe next thing that needs to happen is that the Yara Compiler needs to be created, this can\nalso be added into the constructor by calling the following function:\n```\nBOOL CreateCompiler()\n\n{\n\n  int create = yr_compiler_create(&compiler);\n\n  if (create == ERROR_SUCCESS)\n\n  {\n\n    return TRUE;\n\n  }\n\n  else\n\n  {\n\n    return FALSE;\n\n  }\n\n}\n\n\n```\nWhere `compiler is a` `private :`\n```\nYR_COMPILER* compiler = NULL;\n\n\n```\nThe constructor is now:\n```\nManager()\n\n{\n\n  int init = yr_initialize();\n\n  if (init != ERROR_SUCCESS)\n  {\n\n    printf(\"Initialise failed: %s\\n\", GetErrorMsg(init).c_str());\n\n    return;\n\n  }\n\n  if (CreateCompiler())\n\n  {\n\n    success = TRUE;\n\n  }\n\n  else\n\n  {\n\n    success = FALSE;\n\n  }\n\n}\n\n\n### Adding rules\n\n```\nNow its ready to receive a rule file. The path was passed in from the commandline and is\nliterally just that, a file path to a yara file.\n\nThe code structure I want for this is:\n\n\n-----\n\n```\nif (yara.AddRuleFromFile(path)  FALSE)\n\n{\n\n  printf(\"[!] Failed to load %s\\n\", path.c_str());\n\n  return -1;\n\n}\n\n```\nSo, lets look at `AddRuleFromFile() :`\n```\nBOOL AddRuleFromFile(std::string file_name)\n\n{\n\n  FILE* rule_file = NULL;\n\n  int result = fopen_s(&rule_file, file_name.c_str(), \"r\");\n\n  if (result != ERROR_SUCCESS)\n\n  {\n\n    printf(\"Failed to open %s: %s\\n\", file_name.c_str(),\nGetErrorMsg(result).c_str());\n\n    return FALSE;\n\n  }\n\n  result = yr_compiler_add_file(compiler, rule_file, NULL, file_name.c_str());\n\n  if (result != ERROR_SUCCESS)\n\n  {\n\n    printf(\"Failed to add rules from %s: %s\\n\", file_name.c_str(),\nGetErrorMsg(result).c_str());\n\n    return FALSE;\n\n  }\n\n  result = yr_compiler_get_rules(compiler, &rules);\n\n  if (result != ERROR_SUCCESS)\n\n  {\n\n    printf(\"Failed to get rules from %s: %s\\n\", file_name.c_str(),\nGetErrorMsg(result).c_str());\n\n    return FALSE;\n\n  }\n\n  return TRUE;\n\n}\n\n\n```\nFirst off, read the file:\n```\nFILE* rule_file = NULL;\n\nint result = fopen_s(&rule_file, file_name.c_str(), \"r\");\n\nif (result != ERROR_SUCCESS)\n\n{\n\n  printf(\"Failed to open %s: %s\\n\", file_name.c_str(),\nGetErrorMsg(result).c_str());\n\n  return FALSE;\n\n}\n\n```\n\n-----\n\nThere are three methods for adding rules:\n\n1. [yr_compiler_add_file()](https://yara.readthedocs.io/en/stable/capi.html#c.yr_compiler_add_file)\n2. [yr_compiler_add_fd()](https://yara.readthedocs.io/en/stable/capi.html#c.yr_compiler_add_fd)\n3. [yr_compiler_add_string()](https://yara.readthedocs.io/en/stable/capi.html#c.yr_compiler_add_string)\n\nThey are all self-explanatory, but the one used here is `yr_compiler_add_file() :`\n```\nresult = yr_compiler_add_file(compiler, rule_file, NULL, file_name.c_str());\n\nif (result != ERROR_SUCCESS)\n\n{\n\n  printf(\"Failed to add rules from %s: %s\\n\", file_name.c_str(),\nGetErrorMsg(result).c_str());\n\n  return FALSE;\n\n}\n\n\n```\nThe function parameters:\n```\nint yr_compiler_add_file(\n\n  YR_COMPILER* compiler,\n\n  FILE* file,\n\n  const char* namespace,\n\n  const char* file_name)\n\nnamespace is left to NULL because:\n\n```\nif namespace is `NULL they will be put into the default namespace.`\n\n[To check this worked, yr_compiler_get_rules() is used. This will either return](https://yara.readthedocs.io/en/stable/capi.html#c.yr_compiler_get_rules)\n[ERROR_SUCCESS or](https://yara.readthedocs.io/en/stable/capi.html#c.ERROR_SUCCESS) [ERROR_INSUFFICIENT_MEMORY.](https://yara.readthedocs.io/en/stable/capi.html#c.ERROR_INSUFFICIENT_MEMORY)\n\nAt this point, the library is initialised and rules are loaded; time to scan some memory.\n\n## Detecting Cobalt Strike\n\nWith all that set up, we still don't have anything to scan. But before that, this is the structure\nI want to get back:\n```\nstd::vector<YaraInfo> matches = yara.ScanProcessMemory(dwPid);\n\n\n```\nA vector of `YaraInfo where` `YaraInfo is my struct:`\n```\ntypedef struct YARAINFO\n\n{\n\n  std::vector<std::string> matched_rules;\n\n  RegionInfo infectedRegion;\n\n} YaraInfo, * PYaraInfo;\n\n\n```\nWhich is a vector of rule names, and another struct:\n\n\n-----\n\n```\ntypedef struct REGIONINFO\n\n{\n\n  LPVOID pBase;\n\n  LPVOID pAllocation;\n\n  DWORD dwRegion;\n\n  DWORD dwProtect;\n\n  DWORD dwState;\n\n  DWORD dwType;\n\n} RegionInfo, * PRegionInfo;\n\n```\n[This is another custom struct, and is very similar to MEMORY_BASIC_INFORMATION.](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memory_basic_information)\n[However, this code is from PreEmpt which has a much bigger data structure (so I just copied](https://mez0.cc/projects/preempt/)\nand pasted that and removed some fields).\n\nA few things need to happen before this can be achieved, so lets look at that.\n\n### Reading Process Memory Regions\n\nFirst off, get a `HANDLE :`\n```\nRAII::Handle hProcess = OpenProcess(PROCESS_READ_FLAGS, FALSE, dwPid);\n\n\n```\n[Here, Resource Acquisition Is Initialization is being used to easily handle the, well,](https://en.cppreference.com/w/cpp/language/raii) `HANDLE .`\nAnd `PROCESS_READ_FLAGS is:`\n```\n#define PROCESS_READ_FLAGS PROCESS_QUERY_INFORMATION | PROCESS_VM_READ\n\n\n```\nFor the process, I want to get a vector of every region is a `RegionInfo struct, like so:`\n```\nstd::vector<RegionInfo> regions = GetProcessRegions(hProcess.Get());\n\n\n```\nHere is the function:\n\n\n-----\n\n```\nstd::vector<RegionInfo> GetProcessRegions(HANDLE hProcess)\n\n{\n\n  std::vector<RegionInfo> regions;\n\n  MEMORY_BASIC_INFORMATION mbi = {};\n\n  LPVOID offset = 0;\n\n  while (VirtualQueryEx(hProcess, offset, &mbi, sizeof(mbi)))\n\n  {\n\n    offset = (LPVOID)((DWORD_PTR)mbi.BaseAddress + mbi.RegionSize);\n\n    RegionInfo regionInfo;\n\n    regionInfo.pBase = mbi.BaseAddress;\n\n    regionInfo.pAllocation = mbi.AllocationBase;\n\n    regionInfo.dwProtect = mbi.Protect;\n\n    regionInfo.dwRegion = mbi.RegionSize;\n\n    regionInfo.dwState = mbi.State;\n\n    regionInfo.dwType = mbi.Type;\n\n    regions.push_back(regionInfo);\n\n  }\n\n  if (regions.size() == 0)\n\n  {\n\n    ErrorHandler::Show().print_win32error(\"VirtualQueryEx()\");\n\n  }\n\n  return regions;\n\n}\n\n```\n[Here, VirtualQueryEx() is being used to retrieve information about pages within the virtual](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualqueryex)\naddress space:\n```\nSIZE_T VirtualQueryEx(\n\n [in]      HANDLE          hProcess,\n\n [in, optional] LPCVOID          lpAddress,\n\n [out]     PMEMORY_BASIC_INFORMATION lpBuffer,\n\n [in]      SIZE_T          dwLength\n\n);\n\n```\nIn order do to that, a `while loop is used whilst incrementing the offset from 0, by the base`\naddress plus the region size. This allows for each page to be incremented over. With each\nregion, we just build out a struct a `push_back the vector.`\n\n[For a visual representation of what this struct looks like, Process Hacker has it covered:](https://processhacker.sourceforge.io/)\n\n\n-----\n\nThe only thing we don't care about here is the `Use .`\n\nOkay, so thats the memory regions of the process mapped out; lets read them as a buffer.\n\n### Reading regions to buffer\n\nThe usage here is:\n```\nstd::vector<RegionInfo> regions = GetProcessRegions(hProcess.Get());\n\nfor (RegionInfo& regionInfo : regions)\n\n{\n\n  std::vector<std::byte> region = ReadRegionToBuffer(regionInfo, hProcess.Get());\n\n  if (region.empty()) continue;\n\n}\n\n\n```\nFor every region, read the region into a vector of bytes. Lets look at\n```\nReadRegionToBuffer() :\nstd::vector<std::byte> ReadRegionToBuffer(RegionInfo regionInfo, HANDLE hProcess)\n\n{\n\n  if (regionInfo.dwProtect == PAGE_NOACCESS) return std::vector<std::byte>{};\n\n  std::vector<std::byte> buffer(regionInfo.dwRegion);\n\n  BOOL bRead = ReadProcessMemory(hProcess, (LPVOID)regionInfo.pBase, buffer.data(),\nregionInfo.dwRegion, NULL);\n\n  if (bRead == FALSE)\n\n  {\n\n    ErrorHandler::Show().print_win32error(\"ReadProcessMemory()\");\n\n  }\n\n  return buffer;\n\n}\n\n\n```\nFirst off, if the protection is `PAGE_NOACCESS, leave. Otherwise, create a vector with the size`\n[of the region. Then ReadProcessMemory() is used:](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory)\n\n\n-----\n\n```\nBOOL ReadProcessMemory(\n\n [in] HANDLE hProcess,\n\n [in] LPCVOID lpBaseAddress,\n\n [out] LPVOID lpBuffer,\n\n [in] SIZE_T nSize,\n\n [out] SIZE_T *lpNumberOfBytesRead\n\n);\n\n```\nThis is quite simple, take in:\n\n1. A `HANDLE to the process`\n2. The base address to read from\n3. Where to put the read bytes\n4. How much TO read\n\n5. How much WAS read\n\nIf it returns `TRUE, then the bytes were read. When this returns, we check if it actually did:`\n```\nif (region.empty()) continue;\n\n\n```\nThen we cast to `unsigned char with another check for empties:`\n```\nconst unsigned char* buffer = (const unsigned char*)region.data();\n\nint buffer_size = region.size();\n\nif (strlen((char*)buffer) == 0) continue;\n\n\n### Scanning Memory Regions\n\n```\nNow that the regions are identified and read into buffers, a `YaraInfo struct is prepared:`\n```\nYaraInfo yaraInfo;\n\n\n```\nAnd finally another Yara Library call:\n```\nint result = yr_rules_scan_mem(rules, buffer, buffer_size, SCAN_FLAGS_PROCESS_MEMORY,\ncapture_matches, &yaraInfo, 0);\n\n\n```\n[This is where the actual magic happens. yr_rules_scan_mem() will scan a memory buffer](https://yara.readthedocs.io/en/v3.4.0/capi.html#c.yr_rules_scan_mem)\nand will return one of the following:\n\n1. [ERROR_SUCCESS](https://yara.readthedocs.io/en/v3.4.0/capi.html#c.ERROR_SUCCESS)\n2. [ERROR_INSUFFICIENT_MEMORY](https://yara.readthedocs.io/en/v3.4.0/capi.html#c.ERROR_INSUFFICIENT_MEMORY)\n3. [ERROR_TOO_MANY_SCAN_THREADS](https://yara.readthedocs.io/en/v3.4.0/capi.html#c.ERROR_TOO_MANY_SCAN_THREADS)\n[4. ERROR_SCAN_TIMEOUT](https://yara.readthedocs.io/en/v3.4.0/capi.html#c.ERROR_SCAN_TIMEOUT)\n\n[5. ERROR_CALLBACK_ERROR](https://yara.readthedocs.io/en/v3.4.0/capi.html#c.ERROR_CALLBACK_ERROR)\n[6. ERROR_TOO_MANY_MATCHES](https://yara.readthedocs.io/en/v3.4.0/capi.html#c.ERROR_TOO_MANY_MATCHES)\n\nLets look at the structure of this call:\n\n\n-----\n\n```\nint yr_rules_scan_mem(\n\n  YR_RULES* rules,\n\n  uint8_t* buffer,\n\n  size_t buffer_size,\n\n  int flags,\n\n  YR_CALLBACK_FUNC callback,\n\n  void* user_data,\n\n  int timeout)\n\n```\nThe first three parameters are clear; the rules we created earlier, a buffer, and a buffer size.\nThe `flags has the following options:`\n```\n#define SCAN_FLAGS_FAST_MODE         1\n\n#define SCAN_FLAGS_PROCESS_MEMORY      2\n\n#define SCAN_FLAGS_NO_TRYCATCH        4\n\n#define SCAN_FLAGS_REPORT_RULES_MATCHING   8\n\n#define SCAN_FLAGS_REPORT_RULES_NOT_MATCHING 16\n\n\n```\nI'm not completely sure what behavioral differences these flags have, so I stuck with\n```\nSCAN_FLAGS_PROCESS_MEMORY .\n\n```\nThe `callback and` `user_data where the most complicated and took some Googling,`\n[shout out to Radare2 for](https://github.com/radareorg/radare2-extras/blob/master/yara/yara/core_yara.c) [making use of this API call and helping me solve this part.](https://github.com/radareorg/radare2-extras/blob/df747eba958300a218f0114a6cfbed82297c6c2b/yara/yara/core_yara.c#L185)\n\nSo, `callback is the function to run on scans; the code I went with:`\n```\nstatic int capture_matches(YR_SCAN_CONTEXT* context, int message, void* message_data,\nvoid* user_data)\n\n{\n\n  PYaraInfo yaraInfo = static_cast<PYaraInfo>(user_data);\n\n  if (message == CALLBACK_MSG_RULE_MATCHING)\n\n  {\n\n    YR_RULE* rule = (YR_RULE*)message_data;\n\n    YR_STRING* string;\n\n    yr_rule_strings_foreach(rule, string)\n\n    {\n\n      std::string rule_name = rule->identifier;\n\n      if (VectorContainsStringA(yaraInfo->matched_rules, rule_name) == FALSE)\n\n      {\n\n        yaraInfo->matched_rules.push_back(rule_name);\n\n      }\n\n    }\n\n  }\n\n  return CALLBACK_CONTINUE;\n\n}\n\n```\n\n-----\n\nNote the `user_data again. What this is, is the structure that you want back. So, when we`\ncalled the function, `&yaraInfo was passed. This can then be retrieved inside the callback,`\nallowing a custom struct to be filled:\n```\nPYaraInfo yaraInfo = static_cast<PYaraInfo>(user_data);\n\n\n```\nIn the above, if a rule matches ( CALLBACK_MSG_RULE_MATCHING ), loop over all the rules\nmatched and add them into the `YaraInfo struct:`\n```\nyaraInfo->matched_rules.push_back(rule_name);\n\n\n```\nThe `VectorContainsStringA is a helper function I use a lot:`\n```\ninline std::string ConvToLowerA(std::string a)\n\n{\n\n  std::transform(a.begin(), a.end(), a.begin(), ::tolower);\n\n  return a;\n\n}\n\ninline BOOL VectorContainsStringA(std::vector<std::string> haystack, std::string\nneedle)\n\n{\n\n  for (std::string& hay : haystack)\n\n  {\n\n    if (ConvToLowerA(hay) == ConvToLowerA(needle))\n\n    {\n\n      return TRUE;\n\n    }\n\n  }\n\n  return FALSE;\n\n}\n\n\n```\nOnce the `yr_rules_scan_mem() function finishes, and the callback is executed, the`\n```\nYaraInfo struct is checked:\nif (yaraInfo.matched_rules.size() > 0)\n\n{\n\n  yaraInfo.infectedRegion = regionInfo;\n\n  allYaraInfo.push_back(yaraInfo);\n\n}\n\n\n```\nThen the `vector of` `YaraInfo is returned:`\n```\nreturn allYaraInfo;\n\n\n```\nALOT has happened in this one function call:\n\n\n-----\n\n```\nstd::vector<YaraInfo> matches yara.ScanProcessMemory(dwPid);\n\nif (matches.size() == 0)\n\n{\n\n  printf(\"[!] No Yara matches!\\n\");\n\n  return -1;\n\n}\n\n```\nTo recap:\n\n1. All the process memory regions were obtained\n2. Read to a buffer\n3. Passed to the Yara Library\n4. Callback function checked each region for rules and updated the `YaraInfo struct with`\n\nmatching rules\n5. A vector of `YaraInfo was returned.`\n\n### Demo\n\nNow that malware is identifed, it can be displayed:\n```\nint idx = 1;\n\nfor (YaraInfo& match : matches)\n\n{\n\n  printf(\"\\\\_ Match: %d/%I64u\\n\", idx, matches.size());\n\n  printf(\" | Base Address: 0x%p\\n\", match.infectedRegion.pBase);\n\n  printf(\" | Allocation Address: 0x%p\\n\", match.infectedRegion.pAllocation);\n\n  printf(\" | Page Protection: %ld\\n\", match.infectedRegion.dwProtect);\n\n  printf(\" | Page State: %ld\\n\", match.infectedRegion.dwState);\n\n  printf(\" | Page Type: %ld\\n\", match.infectedRegion.dwType);\n\n  printf(\" | Rules:\\n\");\n\n  for (std::string& rule : match.matched_rules)\n\n  {\n\n    printf(\"  - %s\\n\", rule.c_str());\n\n  }\n\n  idx++;\n\n  printf(\"\\n\");\n\n}\n\n\n## Conclusion\n\n```\nThis was a very code heavy blog post, but I just wanted to demonstrate how to use the Yara\nLibrary as I couldn't really find too much online about it. As mentioned, this is a feature in\n[PreEmpt and writing this blog helped me get a better understanding of how this works.](https://mez0.cc/projects/preempt/)\n\n[The code for this agent is available on GitHub.](https://github.com/mez-0/YaraEngine)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/AV Tech/Writing a C Yara Agent.pdf"
    ],
    "report_names": [
        "Writing a C Yara Agent.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535549,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1657831925,
    "ts_modification_date": 1657831925,
    "files": {
        "pdf": "https://archive.orkl.eu/1599a73da116609df15422d3cd3db212cba4a6c7.pdf",
        "text": "https://archive.orkl.eu/1599a73da116609df15422d3cd3db212cba4a6c7.txt",
        "img": "https://archive.orkl.eu/1599a73da116609df15422d3cd3db212cba4a6c7.jpg"
    }
}