{
    "id": "889d25df-28af-4db9-966d-5dd44f66a586",
    "created_at": "2023-05-06T02:09:23.327721Z",
    "updated_at": "2025-03-27T02:05:19.213223Z",
    "deleted_at": null,
    "sha1_hash": "593a6d056454bbcf25ac5b9c1be1b174b0d7fa38",
    "title": "2023-04-01 - SmoothOperator",
    "authors": "",
    "file_creation_date": "2023-05-05T01:45:38Z",
    "file_modification_date": "2023-05-05T01:45:38Z",
    "file_size": 2380623,
    "plain_text": "# Malware-Analysis/SmoothOperator.md at main · dodo- sec/Malware-Analysis · GitHub\n\n**[github.com/dodo-sec/Malware-Analysis/blob/main/SmoothOperator/SmoothOperator.md](https://github.com/dodo-sec/Malware-Analysis/blob/main/SmoothOperator/SmoothOperator.md)**\n\ndodo-sec\n\nmain\n\n## Name already in use\n\nA tag already exists with the provided branch name. Many Git commands accept both\ntag and branch names, so creating this branch may cause unexpected behavior. Are\nyou sure you want to create this branch?\n\n## Malware-Analysis/SmoothOperator/SmoothOperator.md\n\nCannot retrieve contributors at this time\n\n## SmoothOperator\n\nThis analysis is focused on the SmoothOperator payloads from Sentinel\n[One. They were obtained via vx-underground and comprise two DLLs. The](https://github.com/dodo-sec/Malware-Analysis/blob/main/SmoothOperator/share.vx-underground.org)\nfirst stage has the hash bf939c9c261d27ee7bb92325cc588624fca75429.\n\n## First stage\n\nThis DLL is a straightforward PE loader, with no obfuscation or encryption\npresent. A good first step is looking for references to VirtualProtect there are two.\n\n\n-----\n\nFirst one looks promising, given the ERW flag being passed to it. Checking\nthe function called afterwards (__guard_dispatch_icall_fptr) leads us\nto an offset, which in turn leads to jmp rax. This is probably a jump to\nunpacked code or the next stage. Let's circle back to the start of the\nfunction where those calls to VirtualProtect are and see what exactly\nwe're marking as executable and then jumping to.\n\nThis looks promising. A DLL named d3dcompiler_47.dll and a call to\n```\nCreateFileW, followed by memory allocation of the same size as that file.\n\n```\nMoving on, we'll see some obvious parsing of a PE file.\n\n\n-----\n\nFinally, we see a loop that starts looking for the sequence 0xFE 0xED 0xFA\n```\n0xCE at the Security directory of d3dcompiler_47.dll and moves forward.\n\n```\nIf we can find that sequence of bytes in a DLL file, we probably have\n```\nd3dcompiler_47.dll - it just so happens that sequence in present in the\n\n```\nsecond DLL from Sentinel One,\n**20d554a80d759c50d6537dd7097fed84dd258b3e. Going forward there**\nare several arithmetic operations followed by the aforementioned\n```\nVirtualProtect and jmp rax. Instead of worrying about those, just pop\n\n```\nthe DLL into a debugger, rename\n```\n20d554a80d759c50d6537dd7097fed84dd258b3e to d3dcompiler_47.dll\n\n```\nand run until the jmp rax. First stage is done.\n\n## Second stage\n\nA quick glance at the debugger following the jmp to rax shows we land at\nsome shellcode at allocated memory.\n\n\n-----\n\nThe dump window also shows the same memory region. One should be\ncareful when dumping it though, since there's plenty of random data\npreceding the shellcode and d3dcompiler_47.dll; throwing it in Ida\nbefore getting rid of that data will make for an annoying time.\n\nOn that note, even though Ida Home supports shellcode analysis, I\ndecided to convert this stage to a PE file. The reason is twofold: first, it\nmeans I won't have to import local types manually; second, it means I can\nkeep the dump as is, which is advantageous because we'll be able to\nfollow direct references to the DLL that follows the shellcode. For that end,\n[I do a simple hack with FASM:](https://flatassembler.net/)\n```\ninclude '..\\..\\fasmw17330\\include\\win64ax.inc'\n\n.code\n\nstart:\n\n file 'stage2.bin'\n\n invoke ExitProcess, 0\n\n.end start\n\n\n```\nThe start of the shellcode features basic position independent code (call\n```\n$+5 followed by pop rcx), which is used to get the address of the start of\n\n```\nthe DLL read into memory by the first stage into rcx. Another displacement\nis applied to get a pointer to what appears to be an User-Agent string into\n```\nr8:\n\n```\n\n-----\n\n```\n1200 2400 Mozilla/5.0 (Windows NT 10.0; Win64; x64)\n\nAppleWebKit/537.36 (KHTML, like Gecko) 3CXDesktopApp/18.11.1197\n\nChrome/102.0.5005.167 Electron/19.1.9 Safari/537.36”\n\n```\nThe next call is to a function that will be tasked with mapping\n```\nd3dcompiler_47.dll. Although it's already in memory, it has not been\n\n```\nmapped as an executable needs to be before it's able to run. Here's the\nstart of it, after renaming and adjusting types for the arguments to match\nwhat was placed in the registers preceding the call.\n\nIn another common practice with shellcode, API hashes are present.\n[HashDB identifies the algorithm employed here as one used by Metasploit.](https://hashdb.openanalysis.net/)\nIf one decides to look into the mw_import_by_hash function, it's important\nto remember that this code deals with PEB64 and TEB64, structs that I\n[couldn't find in Ida. I recommend this resource from BITE* to create your](http://bytepointer.com/resources/tebpeb64.htm)\nown struct for both. Doing this will solve you a couple hours of confused\ncursing at the 32 bit structures.\n\nNext up the actual mapping of the DLL into memory takes place. This is\nmade evident by several snippets of code that parse PE Section Headers\nrelevant to the mapping process. The one below checks to see if the PE\n\n\n-----\n\nbeing processed is indeed for a 64-bit architecture; other lines deal with\nthe PE sections and the entry point address:\n\nA bit further down, memory is allocated to match the size of the DLL\n(according to the value in\n```\nIMAGE_NT_HEADERS64.OptionalHeader.SizeOfImage):\n\n```\nA very interesting sequence follows. It's responsible for resolving all\nimports of the third stage DLL by using LoadLibraryA and\n```\nGetProcAddress. Taking note of which fields of the PE are being parsed\n\n```\nand watching a few loops of it running will help you grasp how an import\ntable is built when an executable is mapped.\n\n\n-----\n\nA lot more code follows this, mapping sections and using VirtualProtect\nto assign the correct protections to each one. We're almost done now!\n\nThere's then a call rbx instruction that leads to a rabbit hole of shellcode\nfunctions. Unfortunately what follows next is something no one likes to\nread in an analysis like this, but I have no idea what those do. My\neducated guess is some combination of anti-emulation/anti-sandbox, since\nthere are multiple uses of the cpuid instruction in there and a test following\nthat call will skip the jump to the next stage and instead just return. If\nanyone is curious, feel free to give it a look.\n\nAfter the return from the mysterious shellcode rabbit hole, we have only a\nfew steps left. The code ensures it has mapped the DLL correctly by\nchecking the size of its Data Directory and the exported functions (there is\n\n\n-----\n\nonly one, DllGetClassObject); it then maps the address of said name to\n```\nr8. Then the name of the export itself is checked by a simple ROR 13 ADD\n\n```\nhash function, another callback to metasploit:\n\nFinally, the arguments (remember those from ages ago??) are put back\ninto the relevant registers and there is a jump to r8, which now holds the\naddress of exported function of the third stage DLL. Its command line\narguments are the User-Agent string from earlier and the constant 0xAA\n(thanks to the [Sentinel One Report for pointing out that this constant is the](https://www.sentinelone.com/blog/smoothoperator-ongoing-campaign-trojanizes-3cx-software-in-software-supply-chain-attack/)\nsize of the User-Agent string).\n\n## Important time-saving tip:\n\nIt's only as I wrap up this write-up that I realized there is no decryption of\nthe third stage DLL done by the shellcode, only mapping and maybe some\nanti-emulation shenanigans. As such, one can really speed up their\nanalysis by extracting the full stage 2 payload and getting rid of everything\nbefore the MZ header of the third stage DLL.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-04-01 - SmoothOperator.pdf"
    ],
    "report_names": [
        "2023-04-01 - SmoothOperator.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1683338963,
    "ts_updated_at": 1743041119,
    "ts_creation_date": 1683251138,
    "ts_modification_date": 1683251138,
    "files": {
        "pdf": "https://archive.orkl.eu/593a6d056454bbcf25ac5b9c1be1b174b0d7fa38.pdf",
        "text": "https://archive.orkl.eu/593a6d056454bbcf25ac5b9c1be1b174b0d7fa38.txt",
        "img": "https://archive.orkl.eu/593a6d056454bbcf25ac5b9c1be1b174b0d7fa38.jpg"
    }
}