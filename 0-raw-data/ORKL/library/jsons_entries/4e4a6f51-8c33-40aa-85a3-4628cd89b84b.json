{
    "id": "4e4a6f51-8c33-40aa-85a3-4628cd89b84b",
    "created_at": "2023-01-12T15:03:42.382614Z",
    "updated_at": "2025-03-27T02:10:11.507841Z",
    "deleted_at": null,
    "sha1_hash": "982b36bf1135e55f3c4eb404cf2166149c93b39f",
    "title": "2019-03-13 - ORANGEWORM GROUP – KWAMPIRS ANALYSIS UPDATE",
    "authors": "",
    "file_creation_date": "2022-05-28T04:50:44Z",
    "file_modification_date": "2022-05-28T04:50:44Z",
    "file_size": 3849254,
    "plain_text": "# ORANGEWORM GROUP – KWAMPIRS ANALYSIS UPDATE\n\n**[securityartwork.es/2019/03/13/orangeworm-group-kwampirs-analysis-update/](https://www.securityartwork.es/2019/03/13/orangeworm-group-kwampirs-analysis-update/)**\n\nLab52 March 13, 2019\n\nThe OrangeWorm group was named and described by the Symantec Company in different\n[blog entries [1]](https://www.symantec.com/blogs/threat-intelligence/orangeworm-targets-healthcare-us-europe-asia) [[2]. We would highlight from these entries that it is a group that has been](https://content.connect.symantec.com/sites/default/files/2018-04/Orangeworm%20IOCs.pdf)\noperational since 2015 and is focused on attacking the health, pharmaceutical,\ntechnological, manufacturing and logistics sectors. The sector most affected is healthcare as\ndescribed by Symantec.\n\nBased on this information, Lab52 has carried out an in-depth study of the Kwampirs tool\n(OrangeWorm’s main tool) used by this group.\n\nNext, the RAT (Remote Administration Tool) in Dll format and the main binary or orchestrator\nof the infection will be analyzed.\n\n## Technical analysis of Kwampirs Dropper\n\nWithin its arsenal, OrangeWorm has a RAT in DLL format whose execution and lateral\nmovement is carried out by an executable together with the one that composes the threat\nknown as Kwampirs.\n\nRegarding the executable, which we will call “Kwampirs Dropper” initially highlight its\nresources, among which are two images with corrupt sections. One of which consists of the\nDLL with RAT capabilities encrypted with an XOR key that in each execution extracts,\ndecrypts and executes:\n\nThis threat has a first execution block, in charge of decrypting all the text strings that it will\nuse and which are encrypted in its “.data” section with a relatively obfuscated XOR algorithm\nin order to make detection and decryption difficult. After deciphering its strings, it extracts the\ncreation and modification dates from User32 dll and collects information about the operating\n\n\n-----\n\nsystem it is on. From this point, its logic can be divided into 4 different paths, depending on\nthe number of parameters, which provide different functionalities for each stage of infection\nof the threat.\n\nIn order to provide the greatest clarity to this report, the order of description of the 4 possible\nways of execution of the Kwampirs dropper will follow that of an infection of this threat,\ninstead of the number of parameters incrementally:\n\n**Execution with a parameter**\n\nThe logic that contains the section of code that is executed when it receives a single\nparameter, is that of a hypothetical installation of the threat, manually, or through a dropper.\n\nIt should be noted that this section is completely dependent on having administrator\nprivileges, and in case of not having them, in many points of the execution jumps directly to\nthe end of the logic, thus ending its execution.\n\nFirst, check the existence of the file “C:\\Windows\\inf\\IE11.PNF”, its size (66Bytes) and if it\nhas enough privileges to access it.\nIf it detects that it already exists (which would indicate that the computer is already infected)\nor that it does not have enough privileges (which would prevent it from performing the rest of\nthe logic) it ends the execution. If it does not exist and has sufficient privileges, it creates the\npersistence service.\n\nThis service generates it with a hardcoded name and data in the strings that it has decrypted\nat the beginning of its execution, and emphasizes that it points to an executable with the\nname it has at that moment, but in %System32% even though it has not been observed that\n\n\n-----\n\nit copies itself to that route at any time. This implies that along with being run with\nadministrator privileges, it also requires having been installed on that route by other means.\n\nAfter creating the service, it starts it, this time without any parameter, which gives way to\nanother execution path within its logic.\nFinally, it creates the file called ie11.PNF in which it writes 66 random bytes:\n\nIn the previous capture, you can see how it creates a buffer of 66Bytes, which it fills with\nrandom bytes, and passes it as a parameter to a function that we have called\n“CreateFileWith2tmp” along with a string, which in this case contains\n“C:\\Windows\\inf\\ie11.PNF”.\n\nThe function “CreateFileWith2tmp” uses it constantly for the creation of each one of the files\nrelated to this threat, and is in charge of generating two temporary files, in one it stores the\nfirst Byte of the buffer it receives as the second parameter, in the second file it stores the rest\nof the buffer, after which, it executes the following command to concatenate the content of\nboth, and store it in a new file with the name that it has received as the third parameter.\n\nAfter generating this file, it finishes its execution, having started another instance of its own,\nas a service, and without parameters.\n\n**Execution without parameters**\n\nWhen the threat starts without parameters, after its first string decryption block and collection\nof system information, it makes a call to the Microsoft API “StartServiceCtrlDispatcherW”\nresponsible for initiating the logic of a Windows service, after which it ends. Therefore, if it is\nnot started as a service, it is not able to perform any action.\n\n\n-----\n\nIf it is loaded as a service, after a first execution of its binary with a parameter, for example,\nthe API “StartServiceCtrlDispatcherW” passes the execution flow of the application to a\nfunction of the binary.\n\nThis function consists in a first verification of the existence and capacity of access to the file\n“C:\\Windows\\inf\\mtmndkb32.PNF” if it finds a recent and accessible version of this one, it\ncontinues its normal execution, in case of not finding it or having problems of access to it, it\ngoes through the processes in search of the copies of itself that it generates to run with 2\nand 3 parameters, and in search of its modules to finish these processes and later, to\neliminate these executables, as a cleanup.\n\nRegardless of whether it finds the PNF file or not, it enters an infinite “while (! 0)” loop, which\nis in charge of keeping its module in DLL format running and maintaining a copy of itself,\nrunning with two parameters, which is in charge of the lateral movement by SMB of the\nthreat.\n\nThe infinite loop, first, looks for instances of its module in DLL format in execution, in case of\nnot finding it, it calls a function that takes charge of extracting from its resources the image\nmentioned at the beginning of the report, trimming the corrupt section, decrypting it with an\nXOR key of 16Bytes, using the following algorithm:\n\n\n-----\n\nand store the result in System32 with one of the following names with extension “.dll”:\n\nOnce you have the module on disk, run it through Microsoft executable “rundll32.exe”\npassing the following parameters:\n\nIt then calls a function whose sole purpose is to call a one-minute “Sleep” 20 times, causing\nhis execution to pause for a period of 20 minutes.\n\nAfter 20 minutes, it makes a call to a function that if it does not find an instance of itself\nrunning with 2 parameters, it makes a copy of its own binary with one of the following names:\n\n\n-----\n\nAnd it executes it with two parameters using the Microsoft API CreateProcessAsUserW,\nwhich allows it to add the token of the current user as the creator of the process, so that the\nprocess is executed in its session:\n\nAfter this, it performs a Sleep with a random value between 1 and 3 minutes, and repeats the\nsame execution flow, thus ensuring that both its module in DLL format and its replica running\nwith two parameters are kept running.\n\nAt this point, we are running the process of the main Kwampirs dropper, loaded as System\nby the persistence service, an instance of rundll32, also as System generated by the process\nitself without parameters, and a second instance of the executable, this time with the\ncredentials of the user who has logged in, thanks to the use of the “CreateProcessAsUserW”\nAPI for its creation:\n\n**Execution with 2 parameters**\n\nWhen the threat is executed with two parameters, after its first string decryption block and\ncollection of system information, it goes directly to a function in charge of scanning private\nIPs, which it tries to access by SMB in order to check its access and infection capacity.\n\nTo do this, it first generates a Thread, which through the Microsoft API “GetTcpTable” obtains\nthe list of IPv4 connections of the system, from which it filters all those that are through ports\n445 and 138, so it is able to isolate those related to SMB traffic, afterwards it tries to infect\nthese IPs directly.\n\nTo make sure it does not miss any computer to which the user has access, but which is not\nfound on the table, the main thread of the threat scans the entire subnet of the computer,\ntrying to infect all its possible IP addresses.\n\n\n-----\n\nWhen the main Thread finishes scanning the computer s subnet. It enters a last zone of\ncode, which generates random private “/ 24” subnets and scans them completely, in order to\ntry to access subnets different from that of the infected computer, but accessible by it.\n\nEach of the IP addresses generated by these three subnet scan approaches is passed to a\nfunction that attempts to infect them by trying to access any of the following units via SMB:\n\nADMIN$\nC$\\WINDOWS\nD$\\WINDOWS\nE$\\WINDOWS\n\nTo do this, it makes a call to the “CreateFile” API, passing as the file path the IP address to\nbe infected with the following path “[IP]\\ ADMIN $ \\ system32 \\ csrss.exe” replacing the first\nelement after the IP address for each of the strings of the previous list, generating the\nfollowing network traffic:\n\nIf it gets access to this file on any computer, it checks the existence of ie11.PNF, to see if it is\nalready infected, otherwise it creates a new one on that computer and gives the date and\ntime extracted from User32.dll :\n\nIf it is able to create that file, it tries to copy itself, for which it chooses some of the hardcoded\nnames it has in its strings:\n\nwmiapsrvce.exe\nwmiapsvrce.exe\nwmiapsvre.exe\nwmiapvsre.exe\nwmiaprvse.exe\n\n\n-----\n\nwmiapsrve.exe\nwmiapsrvcx.exe\n\nAnd it generates a copy of itself with that name, on the remote computer through SMB:\n\nEach time it is able to create both ie11.PNF and the Kwampirs executable, it calls a function\nthat, depending on the SMB scanning routine used to generate it, passes a number to it as a\nparameter. If it has reached this IP from the scanning logic of the system subnet, it passes it\na 0, if it has done it through the scanning routine of random private networks, it passes a 1, if\nit has reached this address to through the thread, it passes a 2.\n\nThis function generates a string like the following:\n\n“Lucas-PC\\Lucas\\192.168.19.2\\0\\Mon Dec 03 17:38:27 2018”\n\nThe string consists of the user and domain with which the other system has been infected,\nthe IP address of the infected victim computer, the number that it has received as a\nparameter and that identifies the SMB scanning algorithm that detected the victim, and the\ndate and time of infection. This string encrypts it with an XOR algorithm using a 203-byte\nhardcoded key and adds it to a temporary file called “Lb978YTy.tmp”\n\nFinally, it creates a new copy of itself in System32 of the local computer, and executes it this\ntime with 3 parameters, to which it passes, firstly the IP address of the computer it has just\ninfected, and then two more parameters, similar to those it has received in its execution.\n\n**Execution with 3 parameters**\n\nThis last branch of execution of the Kwampirs dropper, is in charge of generating persistence\nin remote computers infected by its replica executed with two parameters, and is also in\ncharge of the execution of this persistence, which corresponds to the service called\n“WmiApSrvEx”.\n\nTo do this, it first extracts the last character from its second and third parameters, and\npasses it from “char” to “int”. The second parameter, can be a value between 0 and 3, (if it is\nsomething different, its execution ends). This value corresponds to the remote directory to\n\n\n-----\n\nwhich it has been able to access its replica of two parameters, thus obtaining the accessible\nremote path:\n\n0 = ADMIN$\n1 = C$\\WINDOWS\n2 = D$\\WINDOWS\n3 = E$\\WINDOWS\n\nThe third parameter, can be a number between 0 and 6, and corresponds to the name that\nhas put the copy of itself in the remote computer, as follows:\n\n0 = wmiapsrvce.exe\n1 = wmiapsvrce.exe\n2 = wmiapsvre.exe\n3 = wmiapvsre.exe\n4 = wmiaprvse.exe\n5 = wmiapsrve.exe\n6 = wmiapsrvcx.exe\n\nWith this, and the address of the remote computer that has as its first parameter, tries to\ncreate and start the service “WmiApSrvEx” on the remote computer, generating traffic like the\nfollowing:\n\n\n-----\n\nDepending on whether it is capable of generating and executing the service or not, it makes\na call to the registration function in the “Lb978YTy.tmp” log of infected remote computers, but\nthis time, the parameter can be a 3 if everything went well, or a 4 if it has not been able to\ngenerate or initiate persistence. Thus leaving in the “.tmp” file registry a record of the\ncomputers to which he has had access (logs with 0.1 or 2) and if it has been able to infect\nthem or not with (3 or 4) logs.\n\nIf it is not able to infect the computer, it tries to eliminate the remote ie11.PNF file, obtaining\nin this way for it to try again to infect said computer in a future execution.\n\n## Technical analysis of Kwampirs RAT\n\nOrangeWorm within its arsenal has a RAT in Dll format (from now on Kwampirs) that is\nexecuted by “Kwampirs Dropper”. This device has the following static characteristics:\n\nIn all the samples analyzed the ControlTrace () function is exported. This has not changed\nsince the Symantec report. Kwampirs RAT depending on the number of parameters will have\na different behavior. The possibilities implemented on this occasion are two, when three\nparameters and when four parameters are passed to the function.\n\nThe analysis will describe the behavior of Kwampirs RAT in each of the two existing\nexecution branches:\n\n**Execution with three parameters**\n\nThe actions that Kwampirs RAT performs once it starts with three parameters are:\n\n\n-----\n\n1. The first thing it does is to decipher the compromise indicators (IOCs from now on).\n\nOnce deciphered we will see them reflected in memory:\n\nIn the image above you can see the memory segment with all the URIs that the\nmalware will try in order to communicate. To decipher the IOCs the malware uses the\nfollowing logic:\n\n\n-----\n\n2. The next step is to obtain the MACTimes of the user32.dll Dll. This group modifies the\n\ntimes of certain files that it creates on the disk and fixes the times of the user32.dll Dll,\nas already mentioned “Kwampirs Dropper”. This is a measure to hinder the subsequent\nforensic analysis. In the example below we can see the file 3.tmp (random name) on\nthe left, created by Kwampirs to store the identifiers of the handlers of the Named\nPipes that it has created, and on the right the user32.dll dll of the system. If we look\ncarefully, we see how the modification time coincides exactly:\n\n3. In the mtmndkb32.PNF file, a generated value is saved from the system date at the\n\ntime of execution. In each execution (Kwampirs Dropper as Kwampirs RAT) it checks\nthe exact date the file was created and if not enough time has passed since the file was\ncreated, it does not run again. This is already described by Symantec in its report and\nthe “current” samples have not changed their behavior.\n\n\n-----\n\n4. In the event that Kwampirs RAT is downloaded, a module interacts with the\n\n**mkdiawb3.PNF file before entering the network communication execution flow. This**\nfile stores hashes in md5 of the modules. An example of the file with the hash of the\nencrypted and unencrypted module can be seen below:\n\nThis group calculates the hash on the file (module) after encrypting it and coding it in\nbase64.\n\nIf we do a hash to the downloaded module we will see how it matches with what is\nstored:\n\n5. Kwampirs RAT creates different files with extension “.TMP” in the temporary directory\n\nof the user and in the case of being executed with a user with administrator privileges\nrenames the files and places it in the directory C:\\windows\\inf with extension PNF (of\nwhich we have spoken previously). To copy them, it uses the cmd.exe command as\nshown below in an execution:\n\n\n-----\n\n6. After moving the files, it launches a thread that contacts the command and control\n\nserver (C2 from now on). This thread invokes the StartProcess () function. This thread\nreceives modules from C2 with the hash of the signed module and checks it before\nexecuting them. During this thread, a temporary file is generated where information of\nthe computer is stored and then used in the requests. This file is called digirps.PNF.\nOnce the digirps.PNF file is decrypted you can see how it stores computer information\nsuch as the MAC Address:\n\nAgain to decrypt the file we use the same algorithm but with a different key and the\nMAC of the computer where the sample was executed is indeed obtained. The analysis\ncarried out has not shown that a first interaction with this file adds more useful\ninformation than the MAC Address.\n\n\n-----\n\nAs already mentioned, network communications to C2 are performed in this function.\nUntil it receives a “good” response, Kwampirs RAT sends the following type of packets\n(in this case you can see how a C2 sends a successful response):\n\nWe see how the C2 has returned a code {XXX}: hash_md5_modulo. After receiving\nthe module hash, the C2 sends it to the next GET:\n\nIn this case what it has returned is a module (Dll as well) that it injects in memory and\nlaunches as a new thread of execution (these modules are not dumped to disk). In this\ncase, the module allows executing commands in the operating system. In a first\niteration the module executes commands to gather information:\n\n\n-----\n\nThe module that Kwampirs RAT has downloaded is mapped into memory as follows:\n\nAfter loading it, a thread starts invoking a function named CF. For this sample it is\nnecessary that all the modules come with the function CF () to start the logic. The\nname of the DLL once mapped on this occasion is cmdDLL.dll which confirms that it is\na module ready to execute commands.\n\nNext you can see the module’s loop that reads the .data section with the commands\nand that will be launched with cmd.exe:\n\n\n-----\n\nAnd the following screenshot shows the part of the network that sends the POST\nrequest of the module whose capture of the network traffic was seen before:\n\n\n-----\n\n7. After exiting the thread, the Sleep () function is executed with a random time and\n\nreturns to point 5 to repeat the process.\n\nWhen the Kwampirs RAT is executed with three parameters, the API that makes the HTTP\nrequest sometimes returns error 12029 (it could not establish the HTTP connection). In this\ncase Kwampirs RAT will try to boot the malware with the CreateProcessAsUser () function as\nfollows:\n\n\n-----\n\nIt looks like there are two instances of Kwampirs, but one with the user SYSTEM and\nanother with the user Lucas. This makes sense since there are occasions where the user\nSYSTEM cannot exit through the proxy of the organization and with this technique aims to\ntake the user who may have configured the proxy and thus exit. The user instance tries\nagain to launch the HTTP requests.\n\n**Execution with four parameters**\n\nKwampirs RAT when booted with 4 parameters is used to communicate through Named\nPipes with another instance of Kwampirs RAT.\n\nThe last parameter is the one that will give the name to the file that will store the handles of\nthe named pipes created by that same instance. When booting with this amount of\nparameters, it calls the CreatePipe () function twice to create two Named Pipes. The pipe\nhandlers (in decimal) are stored in a file created in C:\\Windows\\Temp:\n\n232 = E8\n\n\n-----\n\n228 = E4\n\nThe handles of the process show that e8 and e4 are File handles:\n\n\n-----\n\nThis mode of operation, as seen during the analysis, is used to communicate the Kwampirs\nRAT process started as SYSTEM (starting with the service) with the process started as the\nuser owner of the current session of the machine.\n\nIn the previous screenshot you can see how the process rundll32.exe (starting with\nSYSTEM, in this case it would be the master) that could not go to the internet is about to\nwrite in a pipe to send the data to the process that has been created with the\nCreateProcessAsUser () function. This data as you can see in the image is a numerical value\nand a URI. It is seen in the image how the handler where you write WriteFile () is 0x240 (it is\nseen at the top of the stack) that if we open the handles of the rundll32 master process we\nsee that it is a Named Pipe:\n\nIf the handles of the rundll32 master process are opened with a tool like ProcessHacker, it\nwill be seen how it has an open handle on the rundll32 process, created with the user without\nprivileges (from now on rundll32 slave):\n\n\n-----\n\nAnother similar situation that occurs during execution to the previous one is when the master\nrundll32.exe opens the explorer.exe process. This is done with the OpenProcess () api and\nthen OpenProcessToken () in order to obtain the token from the explorer.exe process\n(normally the owner of this process is the authenticated user and is the one most likely to\nhave the configured proxy):\n\n\n-----\n\nThe following is a description of the entire sequence of actions carried out for the rundll32\nmaster process to send information to the rundll32 slave after having seen some peculiarities\npreviously. The following image shows the master process rundll32.exe that just opened the\nslave process with the OpenProcess and will open a temporary file with wfopen:\n\nThe temporary file contains the identifiers of the handles created in the rundll32 SLAVE\nprocess:\n\n\n-----\n\nIn memory of the master process we will find those handles in their hexadecimal value:\n\nOnce these handles are located, the master intends to duplicate them in order to obtain\naccess to those handles in their process and that correspond to those of the slave process to\ncommunicate with each other:\n\nIn this execution, the value of lpTargetHandle was 0x290 and it is linked (or duplicated) with\none of the rundll32.exe slave processes that it just read from the temporary file.\n\n\n-----\n\nSumming up the operation, the master rundll32.exe opens the slave process. Then it reads\nthe temporary one where the handles are (in decimal) of type pipe that the slave has\ncreated. The master makes a duplicate handle of the two pipes of the slave in its process\nand thus pass all the information through these pipes. A situation where this logic is used is\nwhen the master process initiated by the service cannot navigate. In this case, it creates the\nslave with the token of the user who owns the explorer.exe and tries to navigate with the\nURIs provided by the master due to the pipes created.\n\n## References\n\n[1] https://www.symantec.com/blogs/threat-intelligence/orangeworm-targets-healthcareus-europe-asia\n\n[2] https://content.connect.symantec.com/sites/default/files/201804/Orangeworm%20IOCs.pdf\n\n[3] https://www.ccn-cert.cni.es/ca/seguretat-al-dia/noticies-d-actualitat/6156orangeworm-apt-orientada-al-sector-medico.html\n\n## Compromise indicators\n\n\n-----\n\n**IOC** **Tipo**\n\n\n**07f5fa96d31ed75edba8699f53a75502ade214b34469163011ced5b94e393f32**\n\n**12c6c48e1e52ebca20f4b890922fb31965317865d35ac04d216ad8b78f866999**\n\n**1486746bdba1161cfc15f37011c815911c33a2abd657198b835ac5f8eede663c**\n\n**281c2ad26346305dac90ce33c2c417b6a7271f990ba9fa5c7db65d6f2e501e94**\n\n**2d801f75a52f65ffb053ae052cad45a919afd431f5ca46e86abe3d9274c903e4**\n\n**2f04f6b04a735d4ccbc196942acbd3f7a64bc588a0107fc9e344df62a41ad85d**\n\n**303379ebb41bcb39bc8c5b7c102cff1a90a2ee207a51e0c0fd83c0348ea436a5**\n\n**34ce48c7481118aac4b5d772a64e0edf8e107a7f606913c49493d5dbc06f96d7**\n\n**39f8dd73baa0dd67607784b40fb4ad5881b50bb69a59eee2a844b615753062ed**\n\n**3b3c9a372188fea46b05e9253e03473fda963aaa76fdd459590ecca9db5af9fb**\n\n**3d0dbd119e9f1dd57db3331834c5206c4df321f3f6799c9a622f1a8abe462b2d**\n\n**64defebf7e600d92685672c4b4d3d2ed3fc6cca27663a65c42df61843573297b**\n\n**75d93cd55d54a38a9ec47efe26f4a2c4c8c14328175fdd8d69efc0187cef6a2e**\n\n**768fab04b19c18e375183bd762eda75359da3a964aa97000639cdfdd066f6edd**\n\n**7f9531e47146095f681564cfd5d322af3def6468202f62c6215af29c0453fb0a**\n\n**83a0b4476a0f50321308e4e1b4d680430e29a53b9669174d8113d6dcbca817e2**\n\n**85f8fa27a5f013d38a3c4a3742fbc43df90196326110fda9ad05ac2366d3e525**\n\n**908d608f2b39b37a2a72cbdd96476acc1159341927d41103370432ddf148b4d9**\n\n**97dd250670cef14e04db0145efe7fcfc945018b681e87e48a6f012fd7f79d02e**\n\n**a2d2584e1c46bc2954aaf47957f7fb48bc8209cdf04c1ccd226d689094a2b761**\n\n**b489e5469938f1410a955ab26dc2cb2c81923c75f545df3c351767d5f13b728d**\n\n**b570b07b43cdef3fe2f636a9db6da3dd1e2cb68d980a5fe5b3225713d4ce3e8f**\n\n**c783f6180147abfa55e8c6dc137b506b595ea111589a1ba4a870778b1f309b8c**\n\n**cade857aa5735467a69af2267f6c6179286bd5d1ad61b60332a21527b69d9736**\n\n**ced9a61ebaa8de7aa360ad2d24be26e2474fa4164118f8e32f4e2b2aba6ce511**\n\n**d1953d2c07d0572063364f34de99950407d07bd376dd9817ac799d5628ae5339**\n\n\nHashes\nanalyzed\n\n\n-----\n\n**d881198d26d10fc3a3ace876d4ef0db373b586de28a8b489248f3ea1840ba683**\n\n**e3bc08f7a12f9b68a73de99ecd0aaef1447bbbba9e35f518d42fd0e751be858f**\n\n**f8eb3a2054d6bc51fc0a127f9c01c4aaf238c0c681c36164a716268dc452ff91**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-03-13 - ORANGEWORM GROUP – KWAMPIRS ANALYSIS UPDATE.pdf"
    ],
    "report_names": [
        "2019-03-13 - ORANGEWORM GROUP – KWAMPIRS ANALYSIS UPDATE.pdf"
    ],
    "threat_actors": [
        {
            "id": "6a60b1ba-609f-4bed-b15b-3ffc050d2ac6",
            "created_at": "2022-10-25T16:07:24.033083Z",
            "updated_at": "2025-03-27T02:02:10.086126Z",
            "deleted_at": null,
            "main_name": "Orangeworm",
            "aliases": [],
            "source_name": "ETDA:Orangeworm",
            "tools": [
                "Kwampirs",
                "LOLBAS",
                "LOLBins",
                "Living off the Land"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "c4acd072-595e-4d33-9ce9-bbf41010bb1a",
            "created_at": "2023-01-06T13:46:38.751893Z",
            "updated_at": "2025-03-27T02:00:02.909078Z",
            "deleted_at": null,
            "main_name": "Orangeworm",
            "aliases": [],
            "source_name": "MISPGALAXY:Orangeworm",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "3e0bc1b7-0dd7-444a-964b-64dfb5145c8f",
            "created_at": "2022-10-25T15:50:23.413202Z",
            "updated_at": "2025-03-27T02:00:55.463857Z",
            "deleted_at": null,
            "main_name": "Orangeworm",
            "aliases": [
                "Orangeworm"
            ],
            "source_name": "MITRE:Orangeworm",
            "tools": [
                "Kwampirs",
                "netstat",
                "ipconfig",
                "cmd",
                "Arp",
                "Systeminfo"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535822,
    "ts_updated_at": 1743041411,
    "ts_creation_date": 1653713444,
    "ts_modification_date": 1653713444,
    "files": {
        "pdf": "https://archive.orkl.eu/982b36bf1135e55f3c4eb404cf2166149c93b39f.pdf",
        "text": "https://archive.orkl.eu/982b36bf1135e55f3c4eb404cf2166149c93b39f.txt",
        "img": "https://archive.orkl.eu/982b36bf1135e55f3c4eb404cf2166149c93b39f.jpg"
    }
}