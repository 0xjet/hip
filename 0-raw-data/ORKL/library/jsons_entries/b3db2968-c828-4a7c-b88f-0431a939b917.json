{
    "id": "b3db2968-c828-4a7c-b88f-0431a939b917",
    "created_at": "2023-01-12T15:01:48.0998Z",
    "updated_at": "2025-03-27T02:08:00.297817Z",
    "deleted_at": null,
    "sha1_hash": "b87c5eb52234566079cf9ce0cccfa9e28b672b7f",
    "title": "2020-12-16 - SunBurst- the next level of stealth SolarWinds compromise exploited through sophistication and patience",
    "authors": "",
    "file_creation_date": "2022-05-28T17:32:25Z",
    "file_modification_date": "2022-05-28T17:32:25Z",
    "file_size": 1779363,
    "plain_text": "# SunBurst: the next level of stealth\n\n**[blog.reversinglabs.com/blog/sunburst-the-next-level-of-stealth](https://blog.reversinglabs.com/blog/sunburst-the-next-level-of-stealth)**\n\n[Threat Research | December 16, 2020](https://blog.reversinglabs.com/blog/tag/threat-research)\n\nBlog Author\n[Tomislav Peričin, Chief Software Architect & Co-Founder at ReversingLabs. Read More...](https://blog.reversinglabs.com/blog/author/tomislav-peri%C4%8Din)\n\n\n-----\n\n## Executive summary\n\nReversingLabs:\n\nshows conclusive details that Orion software build and code signing infrastructure\n**was compromised.**\ndiscloses compilation artifacts confirming that Orion source code was directly\n**modified to include a malicious backdoor.**\ndiscloses software delivery artifacts confirming that a backdoored Orion software\n**patch was delivered through its existing software release management system.**\nproposes a novel approach to detect and prevent future software supply chain\n**attacks.**\n\n\n-----\n\n## Summary\n\n[SolarWinds, a company that makes IT monitoring and management solutions, has become](https://www.solarwinds.com/)\nthe latest target of a sophisticated supply chain attack. Multiple SolarWinds Orion software\nupdates, released between March and June 2020, have been found to contain backdoor\ncode that enables the attackers to conduct surveillance and execute arbitrary commands on\naffected systems.\n\nReversingLabs' research into the anatomy of this supply chain attack unveiled conclusive\ndetails showing that Orion software build and code signing infrastructure was compromised.\nThe source code of the affected library was directly modified to include malicious backdoor\ncode, which was compiled, signed and delivered through the existing software patch release\nmanagement system.\n\nWhile this type of attack on the software supply chain is by no means novel, what is different\nthis time is the level of stealth the attackers used to remain undetected for as long as\npossible. The attackers blended in with the affected code base, mimicking the software\ndevelopers’ coding style and naming standards. This was consistently demonstrated through\na significant number of functions they added to turn Orion software into a backdoor for any\norganization that uses it.\n\n## Hiding from software developers\n\nPiecing together a story from the outside of the incident is difficult. However, the trail of\nbreadcrumbs left behind is sufficient to glean some insight into the methods the attackers\nused to compromise the Orion software release process.\n\n\n-----\n\nSuch an investigation typically starts with what s known, which in this case is the list of\nbackdoored software libraries. A file named SolarWinds.Orion.Core.BusinessLayer.dll within\nthe Orion platform software package update SolarWinds-Core-v2019.4.5220-Hotfix5.msp is\nthe first version known to contain the malicious backdoor code. That library has been\n[thoroughly analyzed in FireEye's technical blog, which describes the backdoor behavior very](https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html)\nwell.\n\nHowever, we can draw further conclusions about the attackers’ patience, sophistication and\nthe state of Orion software build system from the analysis of metadata.\n\nWhile the first version to contain the malicious backdoor code was 2019.4.5200.9083, as\noutlined by the FireEye blog, there was a previous version that was tampered with by the\nattackers: version 2019.4.5200.8890, from October 2019, and this version had only been\nslightly modified. While it doesn’t contain the malicious backdoor code, it does contain the\n.NET class that will host it in the future.\n\n**Figure 1. - Empty .NET class prior to backdoor code addition [ver. 2019.4.5200.8890]**\n\nThis first code modification was clearly just a proof of concept. Their three step action plan:\nCompromise the build system, inject their own code, and verify that their signed packages\nare going to appear on the client side as expected. Once these objectives were met, and the\nattackers proved to themselves that the supply chain could be compromised, they started\nplanning the real attack payload.\n\nThe name of the class, OrionImprovementBusinessLayer, had been chosen deliberately.\nNot only to blend in with the rest of the code, but also to fool the software developers or\nanyone auditing the binaries. That class, and many of the methods it uses, can be found in\nother Orion software libraries, even thematically fitting with the code found within those\nlibraries. This implies not only the intent to remain stealthy, but also that the attackers were\nhighly familiar with the code base.\n\nCompare, for instance, the functions that compute the UserID. In the Orion Client code, this\nfunction tries to read the previously computed value from the registry, or creates a new GUID\n\n\n-----\n\nfor the user.\n\n**Figure 2. - GetOrCreateUserID in Orion Client [ver. 3.0.0.349]**\n\nMimicking that, the attackers created their own implementations of these functions to also\ncompute the UserID, and named them the same way. Their functions are even using the\nsame GUID format for the ID type later on.\n\n**Figure 3. - GetOrCreateUserID in backdoor class [ver. 2019.4.5200.9083]**\n\nWhile not spot on, this code performs a similar function as the original. The pattern of naming\nclasses, members, and variables appropriately is visible everywhere in the backdoored code.\n\nThere really is a method called CollectSystemDescription and UploadSystemDescription\nused by Orion Client library code. Just like there was an\n**IOrionImprovementBusinessLayer interface the attackers mimicked for the name of the**\nclass in which they placed the backdoor code.\n\nHowever, any code added to the library doesn’t just magically execute itself. The attackers\nstill need to call it somehow. And the way that was done tells us that the build system itself\n\n\n-----\n\nwas compromised.\n\n**Figure 4. - RefreshInternal in the clean software version [ver. 2017.1.5300.1698]**\n\n**Figure 5. - RefreshInternal in the backdoored library [ver. 2019.4.5200.9083]**\n\nCode highlighted in red is the additional functionality the attackers put in. This small block of\ncode creates a new thread that runs the backdoor while Orion software is performing its\nbackground inventory checks. Such a location is perfect for this kind of code to be added, as\nthe original code is already dealing with the long-running background tasks. So like the rest\nof the attacker-injected code, it just blends in.\n\nWhile there are techniques to decompile the .NET code, inject something new, and\nrecompile the code afterwards, this wasn’t the case here. The InventoryManager class was\nmodified at the source code level, and the file was ultimately built with the regular Orion\nsoftware build system.\nThis can be confirmed by looking at the timestamps for the backdoored binary, other libraries\nwithin the same package, and the patch file that delivers them.\n\n\n-----\n\n**Figure 6. - Backdoored library compile time [ver. 2019.4.5200.9083]**\n\n**Figure 7. - Backdoored library PDB symbols time [ver. 2019.4.5200.9083]**\n\n**Figure 8. - Backdoored library signing time [ver. 2019.4.5200.9083]**\n\n\n-----\n\nTimestamps between the PE file headers and the CodeViews match perfectly. That, with the\nrevision number set to one, means that the file was compiled only once – or that it was a\nclean build. Since the file was signed, and cross-signed for timestamping, the timestamps\nwithin the headers can be reliably validated. The cross-signing timestamp is controlled by a\nremote server that is outside of the build environment, and can’t be tampered with.\n\nSigning occurred within a minute of library compilation. That leaves no time for the attackers\nto be able to monitor the build system, replace the binary and change the metadata to match\nthis perfectly. The simplest way for all these timestamp artifacts to align perfectly is to have\nthe attackers’ code injected directly into the source, and then have the existing build and\nsigning system perform the compilation and release processes as defined by the Orion\nsoftware developers.\n\n**Figure 9. - Backdoored library file modification time [ver. 2019.4.5200.9083]**\n\nFinally, the MSP patch file contains a CAB archive that preserves the local last modified time\nfor the library. Which, assuming the build system is running in the GMT+1 time zone, also\nconfirms that the file was last modified during signing.\n\nThe files surrounding the backdoored library that belong to the same namespace were also\ncompiled at the same time. Since they don’t depend on each other, they wouldn’t be built at\nthe same time unless the build system was not running a complete build.\n\nSince the MSP patch file is signed, and its signing time matches the contents of the package,\nthis confirms that the patch file was created on the same machine as the rest of the build.\n\nThe big question is: was source control compromised, or was the attackers' code just placed\non the build machine?\n\n\n-----\n\nUnfortunately, that is something the metadata can t reveal. There are no such artifacts that\nget preserved during software compilation. But the attackers went through a lot of trouble to\nensure that their code looks like it belongs within the code base. That was certainly done to\nhide the code from the audit by the software developers.\n\nWhat is certain is that the build infrastructure was compromised. In addition, the digital\nsigning system was forced to sign untrusted code. While there’s no evidence at the moment\nthat SolarWinds certificates were used to sign other malicious code, that possibility should\nnot be excluded. And, as a precaution, all certificates and keys used on that build system\nshould be revoked.\n\n## Hiding from security analysts\n\nConsider for a second the type of customer that runs Orion software within their\nenvironment. For a software supply chain attack like this to work, the attackers need to keep\nunder the radar and evade millions of dollars of security investment. They need to fool the\nhighly specialized detection software, the people that run it to detect threats, and use it to\nproactively hunt for anomalies – for months. To pull that trick off, the attackers need to strike\nthe right balance between staying hidden and achieving their objective.\n\n**Figure 10. - Backdoored library obfuscated strings [ver. 2019.4.5200.9083]**\n\nLarge security budgets come with quite a lot of perks. Being able to do internal threat hunting\nis certainly one of them. And there’s nothing more threat hunters like to look for than\nanomalies in their data. YARA rules are just one way of finding odd things just laying about.\n\nThe string “Select * From Win32_SystemDriver” is probably found in quite a few of them.\nThat is why the attackers chose to hide all such noisy strings with a combination of\ncompression and Base64 encoding. Such a two step approach was necessary because\nthere are also quite a few hunting rules out there that look for Base64 variants of\naforementioned string.\n\nBy reversing those steps, C07NSU0uUdBScCvKz1UIz8wzNooPriwuSc11KcosSy0CAA==\nfound above becomes “Select * From Win32_SystemDriver”. And all the threat hunting rules\nstay none the wiser.\n\n\n-----\n\nSuch string obfuscation is repeated throughout the code. And that s the balance between\nstanding out in a software developer review and fooling the security systems, a gamble that\nhas paid off for the attackers.\n\n## Preventing supply chain attacks\n\nVery few security companies are focused on securing the software supply chain. For most,\ntalking about reducing the risks that these types of attacks pose is far-off. In many ways,\nwe’re still in the problem awareness phase. And, as unfortunate as they are, incidents like\nthis help draw attention to this multifaceted problem, one that equally affects those that ship\nsoftware and those that consume it.\n\nReversingLabs research and development teams pride themselves with thinking about such\nbig problems before they become widespread concerns. To that goal, we built many\nprototypes of products and solutions to address such problems.\n\nSoftware supply chain protection is certainly a huge problem waiting to be solved. And\ninternally, we've defined product strategies about protecting both sides of the equation - the\ndeveloper and the user.\n\nWe envisioned a system able to scan “gold” software release images prior to their release or\nconsumption. This system is purposely built to look for software tampering, digital signing,\nand build quality issues. It is ingrained into the continuous software development and release\ncycle, with the aim to bring these issues to the surface and provide guidance in eliminating\nthem.\n\nOne key aspect of such a system is the ability to pinpoint behavioral differences between\ncompiled software versions. Dubbed static behavioral indicators, these descriptions translate\nthe underlying code actions into the effects they could have on the machine that runs them.\n\nWhen layed out as a difference between added (green) and removed (red) code, the effects\nof software behavior changes become apparent. For the backdoored SolarWinds binary, this\nraises a number of security alarms that would have made it possible to catch this supply\nchain attack much sooner.\n\n**Figure 11. - Static behavior diff between ver. 2019.4.5200.8890 and ver.**\n**2020.2.5300.12432**\n\n\n-----\n\nThe following list highlights important static code behavior changes between the first\ntampered version and the one which contains the malicious backdoor code.\n\n**1. Reads information about one or more running processes**\nHaving an application suddenly become aware of other running processes in the\nenvironment is highly unusual. For mature code bases, this functionality is typically added in\nmajor releases. There’s typically a big feature planned behind this kind of code. And there’s\nusually a good reason for the addition: some type of inter-process communication, or a\ndesire to control running processes. In any other scenario, such an unplanned addition would\nbe a cause for concern.\n\n**2. Contains references to MD5/SHA1 algorithm .NET Framework classes**\nWhile not highly unusual, hashing algorithms like MD5 and SHA1 are typically implemented\nto solve a specific problem. It’s either some sort of content validation, authentication, or\nuniqueness check. Each of these can usually be mapped to a high-level requirement and\ntracked back to a feature modification request or a similar development task.\n\n**3. Contains references to kernel32.dll / advapi32.dll native Windows API**\nReferencing native Windows APIs from .NET library all of a sudden is very unusual. While\nthe underlying code that interacts with the system is a necessity, even for managed\napplications, there are better ways of doing it. For example, provided language runtimes can\ntypically achieve the same effect as what most developers require from native functions, but\nwithout having to deal with type uncertainty. By itself, regardless of the supply chain attack\ncontext, this is what developers refer to as code smell.\n\n**4. Enumerates system information using WMI**\nWindows Management Instrumentation (WMI) is a set of system functions that enable the\napplication to get information on the status of local and remote computer systems. IT\nadministrators use these functions to manage computer systems remotely. Understanding\nwhy such functionality is added suddenly is crucial. It is unlikely that the scope of the\napplication has changed so dramatically that the interaction between remote computer\nsystems has become a part of its key tasks. And if the goal is to retrieve something from the\nlocal system, there might already be code that has that information.\n\n**5. Enumerates and tampers with user/account privileges**\nLooking up user or account privileges is typically the first step in having them elevated.\nRunning code at elevated privileges is done to perform a limited action, like copying files to\nrestricted folders, manipulating running processes, changing system setting, etc. These are\nall actions that must have a firm reason behind them, and adding them to a mature code\nbase is at least questionable. A developer should be made aware of this type of thing, and\nshould have to sign off on it.\n\n**6. Tampers with system shutdown**\nSticking with the theme of unnecessary privileges for an application, we have a big red flag\n\n\n-----\n\nat the end. Being able to shutdown or reboot a computer isn t something that s added to\ncode unexpectedly. That is a feature that takes coordination between multiple code\ncomponents, and is usually implemented at a single location within the application. Having it\nappear elsewhere is definitely cause for concern.\nRegardless of the side of the software deployment process one finds themselves on, a report\nabout the impact of software code changes is an invaluable piece of information. For\nsoftware developers, it can lead to informed decisions about the underlying code behavior.\nAnd for software consumers, it can ensure detection of anomalous code additions. Either\nway, the impact of such a system is transformative to software deployment processes. It\nserves as a verification barrier that can make it harder for these kinds of software supply\nchain attacks to recur.\n\n## New Control Mechanisms Needed\n\nSUNBURST illustrates the next generation of compromises that thrive on access,\nsophistication and patience. For companies that operate valuable businesses or produce\nsoftware critical to their customers, inspecting software and monitoring updates for signs of\ntampering, malicious or unwanted additions must be part of the risk management process.\nThis type of tampering exploits software distributions that are trusted by the traditional\nsecurity software stack, which is unique in comparison to known malicious implants. The\ndistributions could not be easily inspected, if at all, by any perimeter control. Hiding in plain\nsight behind a globally known software brand or a trusted business-critical process, gives\nthis method access that a phishing campaign could only dream to achieve.\n\nMost cyber security frameworks such as NIST CSF document the need for continuous risk\nmanagement and inspection of data and software. This, in turn, includes the need that all\nthird party and open source software, whether built internally or externally, be continually\ninspected for tampering, malicious content, or any unwanted characteristics that clash with\nan organization’s acceptable policies.\n\nReversingLabs is always thinking about the big challenges that lay ahead. We’d be happy to\ndiscuss our viewpoints and offer solutions towards reducing organizational software supply\n[chain risks. Please get in touch so that we can solve these problems together.](https://register.reversinglabs.com/solarwinds-breach)\n\n**Referenced files:**\n\n**File name** SolarWinds.Orion.Core.BusinessLayer.dll\n\n**Version** 2019.4.5200.8890\n\n**TimeStamp** Thu Oct 10 13:26:39 2019\n\n**Hash** 5e643654179e8b4cfe1d3c1906a90a4c8d611cea\n\n**Note** File contains placeholder OrionImprovementBusinessLayer class.\n\n\n-----\n\n**File name** SolarWinds.Orion.Core.BusinessLayer.dll\n\n**Version** 2019.4.5200.9083\n\n**TimeStamp** Tue Mar 24 08:52:34 2020\n\n**Hash** 76640508b1e7759e548771a5359eaed353bf1eec\n\n**Note** First known instance of the backdoored library.\n\n**File name** SolarWinds.Orion.Core.BusinessLayer.dll\n\n**Version** 2020.2.5200.12394\n\n**TimeStamp** Tue Apr 21 14:53:33 2020\n\n**Hash** 2f1a5a7411d015d01aaee4535835400191645023\n\n**Note** Contains malicious backdoor code.\n\n**File name** SolarWinds.Orion.Core.BusinessLayer.dll\n\n**Version** 2020.2.5300.12432\n\n**TimeStamp** Mon May 11 21:32:40 2020\n\n**Hash** d130bd75645c2433f88ac03e73395fba172ef676\n\n**Note** Contains malicious backdoor code.\n\n**File name** SolarWinds-Core-v2019.4.5220-Hotfix5.msp\n\n**Version** 2019.4.5220\n\n**TimeStamp** Tue March 24 10:57:09 2020\n\n**Hash** 1b476f58ca366b54f34d714ffce3fd73cc30db1a\n\n**Note** HotFix patch containing the first known backdoor instance.\n\n## MORE BLOG ARTICLES\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-16 - SunBurst- the next level of stealth SolarWinds compromise exploited through sophistication and patience.pdf"
    ],
    "report_names": [
        "2020-12-16 - SunBurst- the next level of stealth SolarWinds compromise exploited through sophistication and patience.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535708,
    "ts_updated_at": 1743041280,
    "ts_creation_date": 1653759145,
    "ts_modification_date": 1653759145,
    "files": {
        "pdf": "https://archive.orkl.eu/b87c5eb52234566079cf9ce0cccfa9e28b672b7f.pdf",
        "text": "https://archive.orkl.eu/b87c5eb52234566079cf9ce0cccfa9e28b672b7f.txt",
        "img": "https://archive.orkl.eu/b87c5eb52234566079cf9ce0cccfa9e28b672b7f.jpg"
    }
}