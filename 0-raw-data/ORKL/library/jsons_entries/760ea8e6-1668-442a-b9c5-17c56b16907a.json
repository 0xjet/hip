{
    "id": "760ea8e6-1668-442a-b9c5-17c56b16907a",
    "created_at": "2023-01-12T15:04:29.89082Z",
    "updated_at": "2025-03-27T02:09:30.061185Z",
    "deleted_at": null,
    "sha1_hash": "90a6d6eac338c5e986bcee612c71c310ac74e30a",
    "title": "2021-10-31 - A detailed analysis of the STOP-Djvu Ransomware",
    "authors": "",
    "file_creation_date": "2022-05-27T23:04:10Z",
    "file_modification_date": "2022-05-27T23:04:10Z",
    "file_size": 7820179,
    "plain_text": "# A detailed analysis of the STOP/Djvu Ransomware\n\n**[cybergeeks.tech/a-detailed-analysis-of-the-stop-djvu-ransomware/](https://cybergeeks.tech/a-detailed-analysis-of-the-stop-djvu-ransomware/)**\n\nSummary\n\nSTOP/Djvu ransomware is not a very known ransomware like Conti, REvil or BlackMatter,\nhowever ESET ranked it on the 3rd place in the top ransomware families in Q2 2020\n(https://www.welivesecurity.com/wpcontent/uploads/2020/07/ESET_Threat_Report_Q22020.pdf). This ransomware can run with\none of the following parameters: “–Admin”, “–Task”, “–AutoStart”, “–ForNetRes”, and “–\nService”. The process doesn’t target specific countries based on their country code, and also\ndecrypts a list of files, file extensions and folders that will be skipped. Two persistence\nmechanisms are implemented: a Run registry key and a scheduled task created using COM\nobjects. The malware computes the MD5 hash of the MAC address and performs a GET\nrequest to the C2 server based on it. The binary also acts as a downloader for 2 malicious\nfiles called build2.exe and build3.exe. The victim ID is decrypted using the XOR operator and\nthen written to a file called PersonalID.txt. Both local drives and network shares are targeted\nby the malware, and the files are encrypted using the Salsa20 algorithm. The Salsa20 matrix\nused for encrypting files is based on a UUID generated using the UuidCreate API, which is\nencrypted using an embedded RSA public key (if the C2 server is unreachable) or a public\nkey downloaded from the C2 server. The RSA implementation found in the executable is\n[taken from the OpenSSL project hosted at https://github.com/openssl/openssl.](https://github.com/openssl/openssl)\n\n**Analyst:** [@GeeksCyber](https://twitter.com/GeeksCyber)\n\nTechnical analysis\n\nSHA256: 4380c45fd46d1a63cffe4d37cf33b0710330a766b7700af86020a936cdd09cbe\n\nThe following PDB path can be found in the binary:\n“C:\\xudihiguhe\\jegovicatusoca\\jijetogez\\winucet\\xusev\\kucor.pdb”. There is a call to\nGlobalAlloc that allocates several bytes from the heap:\n\nFigure 1\nThe malware calls the LoadLibraryW function in order to load the “kernel32.dll” file into the\naddress space of the process:\n\n\n-----\n\nFigure 2\nThe GetProcAddress API is utilized to retrieve the address of the “VirtualProtect” function:\n\nFigure 3\nThe memory area allocated above is filled in by the malware, and the VirtualProtect routine is\nused to change its protection to 0x40 = PAGE_EXECUTE_READWRITE:\n\nFigure 4\nThere is also a lot of garbage code in the binary that is never executed, as shown in figure 5:\n\n\n-----\n\nFigure 5\nThe process jumps at the beginning of the new shellcode, as highlighted below:\n\n\n-----\n\nFigure 6\nThe binary retrieves the address of the following functions using GetProcAddress:\n“GlobalAlloc”, “GetLastError”, “Sleep”, “VirtualAlloc”, “CreateToolhelp32Snapshot”,\n“Module32First”, “CloseHandle”. CreateToolhelp32Snapshot is utilized to take a snapshot of\nthe current process that includes all its modules (0x8 = TH32CS_SNAPMODULE):\n\nFigure 7\nThe ransomware extracts information about the first module of the process using the\nModule32First API:\n\nFigure 8\nThe malicious process allocates and populates a new memory area via a function call to\nVirtualAlloc (0x1000 = MEM_COMMIT and 0x40 = PAGE_EXECUTE_READWRITE):\n\nFigure 9\nThe process jumps at the beginning of the new shellcode, as highlighted below:\n\n\n-----\n\nFigure 10\nThe malware calls the LoadLibraryA API to load the following DLLs into memory: user32.dll,\nkernel32.dll and ntdll.dll. It also retrieves the address of the following functions:\n“MessageBoxA”, “GetMessageExtraInfo”, “WinExec”, “CreateFileA”, “WriteFile”,\n“CloseHandle”, “CreateProcessA”, “GetThreadContext”, “VirtualAlloc”, “VirtualAllocEx”,\n“VirtualFree”, “ReadProcessMemory”, “WriteProcessMemory”, “SetThreadContext”,\n“ResumeThread”, “WaitForSingleObject”, “GetModuleFileNameA”, “GetCommandLineA”,\n“NtUnmapViewOfSection”, “NtWriteVirtualMemory”, “RegisterClassExA”,\n“CreateWindowExA”, “PostMessageA”, “GetMessageA”, “DefWindowProcA”,\n“GetFileAttributesA”, “GetStartupInfoA”, “VirtualProtectEx”, “ExitProcess”.\n\nFrom our perspective, the malware developers have implemented some actions that don’t\ninfluence the main execution flow as an anti-analysis mechanism. GetFileAttributesA is used\nto retrieve file system attributes for a non-existent file:\n\nFigure 11\nThe file registers a window class called “saodkfnosa9uin” using the RegisterClassExA\nroutine:\n\nFigure 12\n\n\n-----\n\nThe CreateWindowExA function is utilized to create a new window (0x200 =\n**WS_EX_CLIENTEDGE, 0xCF0000 = WS_OVERLAPPEDWINDOW, 0x80000000 =**\n**CW_USEDEFAULT):**\n\nFigure 13\nThe process allocates a new memory area via a function call to VirtualAlloc (0x1000 =\n**MEM_COMMIT and 0x4 = PAGE_READWRITE):**\n\nFigure 14\nThe ransomware extracts the content of the STARTUPINFO structure:\n\nFigure 15\nThe malware creates a copy of itself in a suspended state via a call to CreateProcessA\n(0x08000004 = CREATE_NO_WINDOW | CREATE_SUSPENDED):\n\nFigure 16\n\n\n-----\n\nGetThreadContext is used to retrieve the context of a specific thread:\n\nFigure 17\nThe malicious binary unmaps a view of a section from the address of the newly created\nprocess using ZwUnmapViewOfSection:\n\nFigure 18\nThe VirtualAllocEx routine is utilized to allocate new space in the newly created process\n(0x3000 = MEM_COMMIT | MEM_RESERVE and 0x40 = PAGE_EXECUTE_READWRITE):\n\nFigure 19\nThe ransomware writes data to the area allocated above using multiple calls to\nZwWriteVirtualMemory, as displayed in figure 20:\n\n\n-----\n\nFigure 20\nThe SetThreadContext function is used to set the context for the remote thread:\n\nFigure 21\nThe binary resumes the main thread of the suspended process using ResumeThread:\n\n\n-----\n\nFigure 22\nWe’ve extracted the executable from memory, and we continue to analyze this file. The\nfollowing PDB path has been found: “e:\\doc\\my work\n(c++)_git\\encryption\\release\\encrypt_win_api.pdb”. The binary initializes the use of the\nWinINet functions by calling the InternetOpenW API (the user agent being “Microsoft Internet\nExplorer”):\n\nFigure 23\nThe malware performs a GET request to https[:]//api.2ip.ua/geo.json, which reveals details\nabout the location of the IP address:\n\nFigure 24\nInternetReadFile is used to read the response from the server, and an example of a JSON\nform is displayed below:\n\nFigure 25\n\n\n-----\n\nThe country_code element is compared with RU (Russian language), BY (Belarusian\nlanguage), “UA” (Ukrainian language), “AZ” (Azerbaijani language), “AM” (Armenian\nlanguage), “TJ” (Tajik language), “KZ” (Kazakh language), “KG” (Kyrgyz language), “UZ”\n(Uzbek language) and “SY” (Syriac language):\n\nFigure 26\nThe systems that have one of the languages enumerated above will not be encrypted. The\npriority for the current process is set to high by calling the SetPriorityClass routine (0x80 =\n**HIGH_PRIORITY_CLASS):**\n\nFigure 27\nThe executable retrieves the command-line string for the process and then returns an array\nof pointers to the command-line arguments:\n\nFigure 28\nIt’s important to mention that the malware can run with one of the following parameters: “–\nAdmin”, “–Task”, “–AutoStart”, “–ForNetRes”, and “–Service”. We’ll describe the execution\nflows with different parameters later on.\n\nAll process IDs that correspond to the processes on the system are retrieved by calling the\nEnumProcesses API:\n\nFigure 29\nEach process object is opened by the ransomware using OpenProcess (0x410 =\n**PROCESS_QUERY_INFORMATION | PROCESS_VM_READ):**\n\nFigure 30\n\n\n-----\n\nThe malware extracts a handle for each module from a process that was successfully\nopened:\n\nFigure 31\nThe GetModuleBaseNameW function is used to retrieve the base name of a module that is\ncompared with the name of the executable (in our case, “wininet_dump.exe”):\n\nFigure 32\nThe binary performs a lot of XOR operations (key = 0x80) in order to decrypt relevant strings.\nThe next figure contains a buffer with the C2 server securebiz[.]org:\n\nFigure 33\n\nThe ransomware opens the Run registry key using RegOpenKeyExW (0x80000001 =\n**HKEY_CURRENT_USER and 0xF003F = KEY_ALL_ACCESS):**\n\n\n-----\n\nFigure 34\nThe process is looking for a value called “SysHelper”, which doesn’t exist at this time:\n\nFigure 35\nThe UuidCreate function is used to generate a new UUID (16 random bytes):\n\nFigure 36\nThe process converts the UUID to a string using the UuidToStringW API:\n\nFigure 37\nA new directory based on the UUID is created by the malware:\n\nFigure 38\nThe CopyFileW routine is utilized to copy the executable to a new file in the above directory:\n\n\n-----\n\nFigure 39\nThe ransomware establishes persistence on the host by creating an entry called “SysHelper”\nunder the Run registry key, which will run the executable with the “–AutoStart” parameter\nwhenever the user logs on:\n\nFigure 40\nThe binary denies “Everyone” to delete the folder created above using the icacls command,\nas highlighted in figure 41:\n\nFigure 41\nA second persistence mechanism consists of creating a scheduled task (using COM objects)\nthat will run the ransomware every 5 minutes.\n\nThe malicious file initializes the COM library on the current thread using the CoInitialize\nfunction:\n\nFigure 42\n\n\n-----\n\nWe have observed that the implementation is similar to the one presented at\n[https://docs.microsoft.com/en-us/windows/win32/taskschd/time-trigger-example–c—,](https://docs.microsoft.com/en-us/windows/win32/taskschd/time-trigger-example--c---)\nhowever we’ll dig deeper and explain how the assembly code looks like.\n\nThe CoInitializeSecurity routine is used to register and set the default security values for the\nprocess (0x6 = RPC_C_AUTHN_LEVEL_PKT_PRIVACY and 0x3 =\n**RPC_C_IMP_LEVEL_IMPERSONATE):**\n\nFigure 43\nThe process creates an object with the CLSID {0F87369F-A4E5-4CFC-BD3E73E6154572DD}, which implements the Schedule.Service class for operating the Windows\nTask Scheduler Service:\n\nFigure 44\nYou can notice if you follow the C++ implementation mentioned above that in a case of a\nfunction call such as p -> f(a,b), the assembly representation contains 3 parameters pushed\non the stack (because the pointer p is pushed as well). An example of such a call is\nrepresented by the ITaskService::GetFolder method, which gets a folder of registered tasks:\n\nFigure 45\nA task called “Time Trigger Task” is deleted using the ITaskFolder::DeleteTask method:\n\nFigure 46\n\n\n-----\n\nThe ITaskService::NewTask function is utilized to create an empty task definition object:\n\nFigure 47\nAn example of a safe release when the pointer is no longer used is shown in figure 48:\n\nFigure 48\nThe binary retrieves the registration information of the task (the description, the author, and\nthe date the task is registered) by calling the ITaskDefinition::get_RegistrationInfo method:\n\nFigure 49\nIRegistrationInfo::put_Author is used to set the author of the task to “Author Name”:\n\nFigure 50\nThe ransomware retrieves the principal for the task (which provides the security credentials)\nby calling the ITaskDefinition::get_Principal function:\n\nFigure 51\nThe security logon type is set to 0x3 (TASK_LOGON_INTERACTIVE_TOKEN), which\nmeans that the task will be run only in an existing interactive session:\n\nFigure 52\n\n\n-----\n\nITaskDefinition::get_Settings is utilized to retrieve the settings that describe how the Task\nScheduler performs the task:\n\nFigure 53\nThe file sets a Boolean value to 0xFFFFFFFF (VARIANT_TRUE) that indicates the Task\nScheduler can start the task at any time after its scheduled time has elapsed using the\nITaskSettings::put_StartWhenAvailable method:\n\nFigure 54\nThe amount of time the Task Scheduler will wait for an idle condition to occur is set to 5\nminutes via a function call to IIdleSettings::put_WaitTimeout:\n\nFigure 55\nITaskDefinition::get_Triggers is used to get a collection of triggers used to start the task:\n\nFigure 56\nThe executable creates a new trigger for the task using the ITriggerCollection::Create\nmethod (0x1 = TASK_TRIGGER_TIME):\n\nFigure 57\nThere is a QueryInterface call with a parameter set as CLSID {B45747E0-EBA7-4276-9F2985C5BB300006} – IID_ITimeTrigger:\n\n\n-----\n\nFigure 58\nThe identifier for the trigger is set to “Trigger1” using the ITrigger::put_Id function:\n\nFigure 59\nThe ransomware sets the date and time when the trigger is deactivated by calling the\nITrigger::put_EndBoundary method:\n\nFigure 60\nThe system time is extracted via a call to the _time64 function:\n\nFigure 61\nThe malware formats the system time into a human-readable form using strftime:\n\nFigure 62\nThe malicious binary sets the date and time when the trigger is activated by calling the\nITrigger::put_StartBoundary method:\n\nFigure 63\nIActionCollection::Create is utilized to create and add a new action to the collection (0x0 =\n**TASK_ACTION_EXEC):**\n\n\n-----\n\nFigure 64\nThere is a QueryInterface call with a parameter set as CLSID {4c3d624d-fd6b-49a3-b9b709cb3cd3f047} – IID_IExecAction:\n\nFigure 65\nThe path of the executable is set to the copied file using the IExecAction::put_Path method:\n\nFigure 66\nThe “–Task” argument is added by calling the IExecAction::put_Arguments function:\n\nFigure 67\nFinally, the malware uses the ITaskFolder::RegisterTaskDefinition method to create the task\ncalled “Time Trigger Task” (0x6 = TASK_CREATE_OR_UPDATE):\n\nFigure 68\nHere is the newly created scheduled task in Windows Task Scheduler:\n\n\n-----\n\nFigure 69\nThe ransomware launches itself with the following parameters “–Admin IsNotAutoStart\nIsNotTask” (IsNotAutoStart = malware didn’t run based on the Run registry key, IsNotTask =\nmalware didn’t run based on the scheduled task):\n\nFigure 70\n**“–Task“ parameter**\n\nWe’ll only highlight different actions that are performed by the ransomware running with this\nparameter without mentioning the same actions as in the case of running with no\nparameters.\n\nGetAdaptersInfo is utilized to retrieve adapter information (including the MAC address) for\nthe localhost:\n\nFigure 71\nThe malware calls the CryptAcquireContextW API in order to obtain a handle to a particular\nkey container within a cryptographic service provider (0x1 = PROV_RSA_FULL and\n0xF0000000 = CRYPT_VERIFYCONTEXT):\n\n\n-----\n\nFigure 72\nThe binary creates a handle to a CSP hash object using the CryptCreateHash API (0x8003 =\n**CALG_MD5):**\n\nFigure 73\nThe ransomware hashes a buffer that contains the MAC address extracted above via a\nfunction call to CryptHashData:\n\nFigure 74\nThe MD5 hash value is extracted by calling the CryptGetHashParam routine (0x2 =\n**HP_HASHVAL):**\n\nFigure 75\nA new thread is created by calling the CreateThread API:\n\nFigure 76\n\n\n-----\n\n**Thread activity – sub_16E690**\n\nThe RegOpenKeyExW function is used to open the\n“Software\\Microsoft\\Windows\\CurrentVersion” registry key (0x80000001 =\n**HKEY_CURRENT_USER and 0xF003F = KEY_ALL_ACCESS):**\n\nFigure 77\nThe process is looking for a value named “SysHelper”, which doesn’t exist at this time (this is\ndifferent from the one in figure 34):\n\nFigure 78\nThe entry from above is created, and its value is set to 1 using the RegSetValueExW API:\n\nFigure 79\nThe executable tries to locate a file called “bowsakkdestx.txt” in the “C:\\Users\\\n<User>\\AppData\\Local” directory, which doesn’t exist on our machine:\n\nFigure 80\nThere is a function call to InternetOpenW similar to the one presented in figure 23 (with the\nsame user agent). The binary performs a GET request to the C2 server securebiz[.]org with\nthe parameter pid = MD5(MAC address):\n\n\n-----\n\nFigure 81\nThe response from the server is read using the InternetReadFile function:\n\nFigure 82\nThe binary creates the file called “bowsakkdestx.txt” using fopen:\n\nFigure 83\nThe file is populated using a function call to fwrite (the C2 server was down during our\nanalysis, so we emulated the network communications using FakeNet):\n\nFigure 84\nAn example of a real response can be seen at https://app.any.run/tasks/900f626a-2bf6-48b285f9-2328f2b2d0d2/ and contains 2 elements: “public_key” and “id”. The malware wants to\nextract the “public_key” value from the response:\n\nFigure 85\n\n\n-----\n\nEven though the C2 server was down, the binary comes with a hard-coded RSA public key.\nThe file from above is deleted in any case:\n\nFigure 86\nUsing multiple XOR operations with 0x80, the ransomware decrypts the RSA public key in\nPKCS1 format, a victim ID, and a URL that leads to another malicious file at\nhttp[:]//securebiz[.]org/files/1/build3.exe:\n\nFigure 87\nWe continue to analyze the main thread. A mutex called “{1D6FC66E-D1F3-422C-8A53C0BBCF3D900D}” is created via a function call to CreateMutexA:\n\n\n-----\n\nFigure 88\nThe malware decrypts the ransom note using the XOR operator:\n\nFigure 89\nThe following information is also decrypted (a list of files to be skipped, a list of extensions to\nbe skipped, and a list of directories to be skipped):\n\nntuser.dat, ntuser.dat.LOG1, ntuser.dat.LOG2, ntuser.pol\n.sys, .ini, .DLL, .dll, .blf, .bat, .lnk, .regtrans-ms\nC:\\SystemID\\, C:\\Users\\Default User\\, C:\\Users\\Public\\, C:\\Users\\All Users\\,\nC:\\Users\\Default\\, C:\\Documents and Settings\\, C:\\ProgramData\\, C:\\Recovery\\,\nC:\\System Volume Information\\, C:\\Users\\%username%\\A”ppData\\Roaming\\,\nC:\\Users\\%username%\\AppData\\Local\\, C:\\Windows\\, C:\\PerfLogs\\,\nC:\\ProgramData\\Microsoft\\, C:\\ProgramData\\Package Cache\\, C:\\Users\\Public\\,\nC:\\$Recycle.Bin\\, C:\\$WINDOWS.~BT\\, C:\\dell\\, C:\\Intel\\, C:\\MSOCache\\, C:\\Program\nFiles\\, C:\\Program Files (x86)\\, C:\\Games\\, C:\\Windows.old\\\nD:\\Users\\%username%\\AppData\\Roaming\\, D:\\Users\\%username%\\AppData\\Local\\,\nD:\\Windows\\, D:\\PerfLogs\\, D:\\ProgramData\\Desktop\\, D:\\ProgramData\\Microsoft\\,\nD:\\ProgramData\\Package Cache\\, D:\\Users\\Public\\, D:\\$Recycle.Bin\\,\nD:\\$WINDOWS.~BT\\, D:\\dell\\, D:\\Intel\\, D:\\MSOCache\\, D:\\Program Files\\, D:\\Program\nFiles (x86)\\, D:\\Games\\\nE:\\Users\\%username%\\AppData\\Roaming\\, E:\\Users\\%username%\\AppData\\Local\\,\nE:\\Windows\\, E:\\PerfLogs\\, E:\\ProgramData\\Desktop\\, E:\\ProgramData\\Microsoft\\,\nE:\\ProgramData\\Package Cache\\, E:\\Users\\Public\\, E:\\$Recycle.Bin\\,\nE:\\$WINDOWS.~BT\\, E:\\dell\\, E:\\Intel\\, E:\\MSOCache\\, E:\\Program Files\\, E:\\Program\nFiles (x86)\\, E:\\Games\\\nF:\\Users\\%username%\\AppData\\Roaming\\, F:\\Users\\%username%\\AppData\\Local\\,\nF:\\Windows\\, F:\\PerfLogs\\, F:\\ProgramData\\Desktop\\, F:\\ProgramData\\Microsoft\\,\nF:\\Users\\Public\\, F:\\$Recycle.Bin\\, F:\\$WINDOWS.~BT\\, F:\\dell\\, F:\\Intel\\\n\n\n-----\n\nThe executable retrieves the user name associated with the current thread by calling the\nGetUserNameW API:\n\nFigure 90\nThe malicious process is looking for a file called “PersonalID.txt” that doesn’t exist at this\ntime:\n\nFigure 91\nCreateDirectoryW is utilized to create a directory called “C:\\SystemID”:\n\nFigure 92\nThe ransomware creates the file “C:\\SystemID\\PersonalID.txt” and writes the victim ID to it:\n\nFigure 93\nIt’s very uncommon that the malware searches the system for a file called\n“I:\\5d2860c89d774.jpg” (0xC0000000 = GENERIC_READ | GENERIC_WRITE, 0x1 =\n**FILE_SHARE_READ, 0x3 = OPEN_EXISTING and 0x80 = FILE_ATTRIBUTE_NORMAL):**\n\nFigure 94\n\n\n-----\n\nLoadCursorW is used to load the standard arrow resource from the executable (0x7F00 =\n**IDC_ARROW):**\n\nFigure 95\nThe binary registers a window class using the RegisterClassExW routine:\n\nFigure 96\nCreateWindowExW is utilized to create a new window called “LPCWSTRszTitle” (0xCF0000\n= WS_OVERLAPPEDWINDOW and 0x80000000 = CW_USEDEFAULT):\n\nFigure 97\nThe window created earlier is hided by calling the ShowWindow routine (0x0 = SW_HIDE):\n\nFigure 98\nWe need to analyze the window procedure defined in figure 96 (sub_16BAE0).\n\nThe malware uses the ntdllDefWindowProcW API in order to call the default window\nprocedure whenever a particular message needs to be processed (0x24 =\n**WM_GETMINMAXINFO, 0x81 = WM_NCCREATE, 0x83 = WM_NCCALCSIZE and 0x1 =**\n**WM_CREATE):**\n\n\n-----\n\nFigure 99\nGetLogicalDrives is used to retrieve a bitmask that represents the available disk drives:\n\nFigure 100\nThe ransomware forces the system not to display the critical-error message box and sending\nthese errors to the calling process (0x1 = SEM_FAILCRITICALERRORS):\n\nFigure 101\nThe file extracts the type of the drives by calling the GetDriveTypeA API and compares it with\n2 (DRIVE_REMOVABLE), 3 (DRIVE_FIXED), 4 (DRIVE_REMOTE) and 6\n(DRIVE_RAMDISK):\n\nFigure 102\nTwo new threads are created using the CreateThread function:\n\n\n-----\n\nFigure 103\n\nFigure 104\nThe file retrieves a message from the message queue by calling the GetMessageW routine,\ntranslates virtual-key messages into character messages using TranslateMessage, and\nfinally dispatches a message to a window procedure using DispatchMessageW:\n\nFigure 105\n**Thread activity – sub_16FD80**\n\nThe malware enumerates all resources on the network via a function call to\nWNetOpenEnumW (0x2 = RESOURCE_GLOBALNET):\n\nFigure 106\nWNetEnumResourceW is utilized to further enumerate the network resources:\n\n\n-----\n\nFigure 107\nThe message DBT_DEVICEREMOVECOMPLETE (“A device or piece of media has been\nremoved”) is sent to the window created earlier, and its procedure will handle it:\n\nFigure 108\nWhen the window procedure receives the message, it calls the GetComputerNameW API in\norder to get the NetBIOS name of the local machine:\n\nFigure 109\n**Thread activity – sub_16F130**\n\nThe ransomware creates the ransom note called “_readme.txt” in every directory that it\nencrypts:\n\nFigure 110\nThe ransom note is populated by calling the WriteFile function, as shown in figure 111:\n\n\n-----\n\nFigure 111\nAn example of a ransom note is highlighted below:\n\nFigure 112\nThe files are enumerated using the FindFirstFileW and FindNextFileW APIs:\n\nFigure 113\nThe directories mentioned under figure 89 will not be encrypted. The file extension is\nextracted by calling the PathFindExtensionW routine:\n\nFigure 114\nThe files and file extensions mentioned under figure 89 will be skipped. The ransomware\nalso avoids files that have the “.tisc” extension because this will be appended after the\nencryption is complete:\n\n\n-----\n\nFigure 115\nEach targeted file is opened using the CreateFileW routine:\n\nFigure 116\nThe file content is read by calling the ReadFile function:\n\nFigure 117\nThere is a function call to CryptAcquireContextW (as in figure 72) and another one to\nCryptCreateHash (as in figure 73). The malware hashes a buffer that contains the first 5\nbytes from the targeted file and the RSA public key, as shown in figure 118:\n\nFigure 118\nThe MD5 hash value is extracted by calling the CryptGetHashParam routine (0x2\n= HP_HASHVAL):\n\n\n-----\n\nFigure 119\nThe binary creates a new UUID (16 random bytes) by calling the UuidCreate API (which\ninternally uses CryptGenRandom):\n\nFigure 120\nThe process converts the UUID to a string using the UuidToStringA API:\n\nFigure 121\nBased on the value generated above, the ransomware constructs the following Salsa20\nmatrix:\n\nFigure 122\n\nA snippet of the Salsa20 algorithm implemented by the malware is presented below:\n\n\n-----\n\nFigure 123\n\nThe process encrypts the file content using the Salsa20 algorithm, however the first 5 bytes\nfrom the targeted file are not encrypted. Based on the strings presented in figure 124 and our\nanalysis of the RSA implementation, we believe that the malware developers have included\n[the OpenSSL code found at https://github.com/openssl/openssl (or similar code taken from](https://github.com/openssl/openssl)\nother projects):\n\n\n-----\n\nFigure 124\n\nThe binary encrypts the UUID generated before using the RSA public key embedded in the\nfile:\n\nFigure 125\nThe encrypted content is written to the file using WriteFile, as shown below:\n\n\n-----\n\nFigure 126\nThe malicious binary writes the encrypted UUID using the same API:\n\nFigure 127\nThe offline ID is also added to the encrypted file:\n\nFigure 128\nThe value “{36A698B9-D67C-4E07-BE82-0EC5B14B4DF5}” is also added to the encrypted\nfile:\n\nFigure 129\nThe encrypted file extension is changed to “.tisc” by the ransomware:\n\n\n-----\n\nFigure 130\nThe encrypted file has the following structure that highlights different elements:\n\nFigure 131\n**“–AutoStart“ parameter**\n\nThe activity is similar to the case discussed above.\n\n**“–Admin IsNotAutoStart IsNotTask“ parameters**\n\nThe binary establishes a connection to the service control manager by calling the\nOpenSCManagerW routine (0x1 = SC_MANAGER_CONNECT):\n\nFigure 132\nA service called “MYSQL” is opened by the process via a function call to OpenServiceW\n(0x20 = SERVICE_STOP):\n\n\n-----\n\nFigure 133\nWhether the service would exist on a host, the ransomware would stop it using the\nControlService API:\n\nFigure 134\n\nThe file decrypts another URL that will be used to download more malicious files,\nhttp[:]//znpst[.]top/dl/build2.exe:\n\nFigure 135\n\nA new thread is created by calling the CreateThread function:\n\nFigure 136\n**Thread activity – StartAddress (sub_16DBD0)**\n\nUuidCreate is utilized to generate a new UUID:\n\n\n-----\n\nFigure 137\nThe UuidToStringA routine is used to convert the UUID to a string:\n\nFigure 138\nThe malicious process creates a new directory based on the UUID generated above:\n\nFigure 139\nThe binary performs a GET request to http[:]//znpst[.]top/dl/build2.exe using\nInternetOpenUrlA:\n\nFigure 140\nAccording to the analysis from\nhttps://any.run/report/cd6bf2f554a9aa446cb36d28e374e1010268cbda8f55eb0043fbe6e2724\n128be/152e55c2-5e8f-4fe2-a764-7876ba00f03e, the above executable is a malware called\nUrsnif (banking Trojan).\n\nThe status code is extracted by calling the HttpQueryInfoW routine (0x20000013 =\n**HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE):**\n\nFigure 141\n\n\n-----\n\nA file called build2.exe is created in the new directory:\n\nFigure 142\nThe InternetReadFile routine is utilized to read the executable from the server, as displayed\nin figure 143:\n\nFigure 143\nShellExecuteA is used to run the newly created executable:\n\nFigure 144\n\nFigure 145\nThe binary performs a GET request to http[:]//securebiz[.]org/files/1/build3.exe using\nInternetOpenUrlA:\n\n\n-----\n\nFigure 146\nAccording to multiple online resources, the above file is supposed to be an infamous infostealer called Vidar. The process of reading data from the server, creating the malicious file,\netc. is the same as above and isn’t explained again.\n\nFor completeness, we will also provide details about the other parameters that can be used,\n[as displayed at https://app.any.run/tasks/635cd7df-e4b7-4d1a-a937-e8d8599e6c72/.](https://app.any.run/tasks/635cd7df-e4b7-4d1a-a937-e8d8599e6c72/)\n\n**“–ForNetRes “jwvfPPgZoQyg6Q6he8weP7iDsH9FKc74ICjysAt2″**\n**r77yXePcnmrctJPWrZCcbJgUlAtOa1FC9Na710t1 IsNotAutoStart IsNotTask”**\n**parameters**\n\nThe binary creates a mutex called “{FBB4BCC6-05C7-4ADD-B67B-A98A697323C1}” using\nthe CreateMutexA API:\n\nFigure 147\nAccording to online sources, the first parameter can be considered as a Key and the second\none as a Personal ID. The malware performs a hashing operation (MD5) on the Key:\n\nFigure 148\nThe hash value is extracted using the CryptGetHashParam function (0x2 = HP_HASHVAL):\n\nFigure 149\nThe execution flow is similar to the one starting with figure 90 and will not be reiterated.\n\n\n-----\n\n**–Service 4904 jwvfPPgZoQyg6Q6he8weP7iDsH9FKc74ICjysAt2**\n**r77yXePcnmrctJPWrZCcbJgUlAtOa1FC9Na710t1” parameters**\n\nThe above value represents the parent process ID, which is converted from string to a long\ninteger value:\n\nFigure 150\nThe ransomware opens the local process object using the OpenProcess routine (0x100000 =\n**SYNCHRONIZE):**\n\nFigure 151\nAfter the parent process enters the signaled state, the file dispatches incoming sent\nmessages, checks for posted messages, and then retrieves the messages:\n\nFigure 152\nThe malicious binary retrieves the exit code of the current process and then kills itself using\nTerminateProcess:\n\nFigure 153\n\nFinally, we describe the case when the country code belongs to the following list: “RU”, “BY”,\n“UA”, “AZ”, “AM”, “TJ”, “KZ”, “KG”, “UZ” and “SY”.\n\nCreateMutexA is utilized to create a mutex called “{FBB4BCC6-05C7-4ADD-B67BA98A697323C1}”:\n\n\n-----\n\nFigure 154\nA batch file called “delself.bat” is created in the %TEMP% directory:\n\nFigure 155\nThe above file is populated using the WriteFile API, and its content is displayed below:\n\nFigure 156\n\nFigure 157\n\nAfter the batch file finishes its execution, the malicious file and the script are deleted:\n\nFigure 158\nReferences\n\n[MSDN: https://docs.microsoft.com/en-us/windows/win32/api/,](https://docs.microsoft.com/en-us/windows/win32/api/) https://docs.microsoft.com/enus/windows/win32/taskschd/time-trigger-example–c—\n\n\n-----\n\nFakenet: [https://github.com/fireeye/flare-fakenet-ng](https://github.com/fireeye/flare-fakenet-ng)\n\nAny.run: [https://app.any.run/tasks/635cd7df-e4b7-4d1a-a937-e8d8599e6c72/](https://app.any.run/tasks/635cd7df-e4b7-4d1a-a937-e8d8599e6c72/)\n\nVirusTotal:\nhttps://www.virustotal.com/gui/file/4380c45fd46d1a63cffe4d37cf33b0710330a766b7700af86\n020a936cdd09cbe\n\nMalwareBazaar:\nhttps://bazaar.abuse.ch/sample/4380c45fd46d1a63cffe4d37cf33b0710330a766b7700af8602\n0a936cdd09cbe/\n\nOpenSSL: [https://github.com/openssl/openssl](https://github.com/openssl/openssl)\n\nINDICATORS OF COMPROMISE\n\nC2 domains:\n\nsecurebiz[.]org\n\nznpst[.]top\n\nSHA256: 4380c45fd46d1a63cffe4d37cf33b0710330a766b7700af86020a936cdd09cbe\n\nScheduled Task: “Time Trigger Task”\n\nRegistry key:\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\SysHelper\n\nUser-agent: “Microsoft Internet Explorer”\n\nPDB paths:\n\n“C:\\xudihiguhe\\jegovicatusoca\\jijetogez\\winucet\\xusev\\kucor.pdb”\n“e:\\doc\\my work (c++)_git\\encryption\\release\\encrypt_win_api.pdb”\n\nURLs:\n\nhttp[:]//securebiz[.]org/fhsgtsspen6/get.php\nhttp[:]//securebiz.org/files/1/build3.exe\nhttp[:]//znpst.top/dl/build2.exe\nhttps[:]//api.2ip.ua/geo.json\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-10-31 - A detailed analysis of the STOP-Djvu Ransomware.pdf"
    ],
    "report_names": [
        "2021-10-31 - A detailed analysis of the STOP-Djvu Ransomware.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535869,
    "ts_updated_at": 1743041370,
    "ts_creation_date": 1653692650,
    "ts_modification_date": 1653692650,
    "files": {
        "pdf": "https://archive.orkl.eu/90a6d6eac338c5e986bcee612c71c310ac74e30a.pdf",
        "text": "https://archive.orkl.eu/90a6d6eac338c5e986bcee612c71c310ac74e30a.txt",
        "img": "https://archive.orkl.eu/90a6d6eac338c5e986bcee612c71c310ac74e30a.jpg"
    }
}