{
    "id": "09ceb713-0511-4379-8c20-d39077bcce47",
    "created_at": "2023-01-12T15:04:18.83318Z",
    "updated_at": "2025-03-27T02:05:53.831733Z",
    "deleted_at": null,
    "sha1_hash": "c571342243a91b903e4110e82c43439269f47c0b",
    "title": "2021-11-09 - Cisco Talos finds 10 vulnerabilities in Azure Sphere’s Linux kernel, Security Monitor and Pluton",
    "authors": "",
    "file_creation_date": "2022-05-27T21:49:40Z",
    "file_modification_date": "2022-05-27T21:49:40Z",
    "file_size": 468369,
    "plain_text": "# Cisco Talos finds 10 vulnerabilities in Azure Sphere’s Linux kernel, Security Monitor and Pluton\n\n**[blog.talosintelligence.com/2021/11/cisco-talos-finds-10-vulnerabilities-in.html](https://blog.talosintelligence.com/2021/11/cisco-talos-finds-10-vulnerabilities-in.html)**\n\n_By Claudio Bozzato and Lilith [-_-];._\n\n[Following our previous engagements (see blog posts 1,](https://blog.talosintelligence.com/2020/07/vuln-spotlight-azure-sphere-july-2020.html) [2,](https://blog.talosintelligence.com/2020/08/vuln-spotlight-microsoft-azure-aug-2020.html) [3 and](https://blog.talosintelligence.com/2020/10/Azure-Sphere-Challenge.html) [4) with Microsoft's Azure](https://blog.talosintelligence.com/2021/04/vuln-spotlight-azure-sphere-april-2021.html)\nSphere IoT platform, we decided to take another look at the device, without all the rush and\ncommotion that normally entails a hacking challenge.\n\nToday, we’re disclosing another 10 vulnerabilities in Azure Sphere — two of which are on the\nLinux side, seven that exist in Security Monitor and one in the Pluton security subsystem.\n\n[As opposed to our previous architectural overview, this post will simply walk through the](https://blog.talosintelligence.com/2020/10/Azure-Sphere-Challenge.html)\nvulnerabilities we discovered as part of our continued research into Azure Sphere, starting\nwith the Linux kernel side.\n\n## Kernel information disclosure\n\n**Microsoft Azure Sphere Kernel GPIO_SET_PIN_CONFIG_IOCTL information**\n**[disclosure vulnerability (TALOS-2021-1339/CVE-2021-41374)](https://talosintelligence.com/vulnerability_reports/TALOS-2021-1339)**\n\n\n-----\n\nAzure Sphere allows applications to manage the set of GPIO pins declared in their manifest\nby sending an ioctl to /dev/gpiochip0. This vulnerability allows an unprivileged attacker using\nthe GPIO_SET_PIN_CONFIG_IOCTL to specify an arbitrary lineoffsets field and trigger an\nout-of-bounds read from a kernel structure. This, in turn, partially leaks kernel memory.\n\n**Microsoft Azure Sphere Kernel GPIO_GET_PIN_ACCESS_CONTROL_USER**\n**[information disclosure vulnerability (TALOS-2021-1340/CVE-2021-41375)](https://talosintelligence.com/vulnerability_reports/TALOS-2021-1340)**\n\nSimilar to the issue above, this one affects the\n_GPIO_GET_PIN_ACCESS_CONTROL_USER_ _ioctl but it requires an attacker to have the_\n_CAP_SYS_ADMIN capability. Note that even though, normally, having CAP_SYS_ADMIN is_\nequivalent to having root privileges, this does not hold true in Azure Sphere. The issue is\nunsigned to signed integer conversion, which again affects the lineoffsets field, and can be\nexploited to arbitrarily leak kernel memory.\n\n## Pluton denial-of-service\n\n**Microsoft Azure Sphere Pluton concurrent syscalls denial-of-service vulnerability**\n**[(TALOS-2021-1347)](https://talosintelligence.com/vulnerability_reports/TALOS-2021-1347)**\n\nThis vulnerability shows that by making concurrent Pluton ioctls, an unprivileged application\ncan hit a rate limit in Pluton, which is handled with a device reboot. This has not been fixed\nby Microsoft, since it’s considered an intended behavior.\n\nAn application normally requires a capability to reboot this device, this vulnerability allows an\napplication to bypass that requirement, however, Microsoft does not recognize these kinds of\nprivilege escalations as vulnerabilities, so they elected not to assign a CVE.\n\n## Security Monitor denial-of-service\n\n**Microsoft Azure Sphere Security Monitor SECTION_ABIDepends denial-of-service**\n**[vulnerability (TALOS-2021-1311)](https://talosintelligence.com/vulnerability_reports/TALOS-2021-1311)**\n\nEvery firmware image on the device has a metadata section, which contains multiple subsections with various information. Currently, we have documented the following metadata\nsub-sections those marked with a “*” are the ones parsed somewhere in Pluton or Secmon:\n\n\n-----\n\nDebug = 0x4244\n\nLegacyABIDepends = 0x4441\n\nIdentity = 0x4449\n\n  - ABIDepends = 0x444E\n\nLegacy = 0x474C\n\n   - Signature = 0x4753\n\n  - Compression = 0x4D43\n\nRequiredFlashOffset = 0x4F52\n\nLegacyABIProvides = 0x5041\n\n  - ABIProvides = 0x504E\n\n  - TemporaryImage = 0x5054\n\nRevocation = 0x5652\n\nEach of these subsections has its own structure, but first, a hexdump to demonstrate the\nmetadata section:\n\nstruct metadata_footer {\n\nuint32_t magic_header;\n\nuint32_t num_subsections;\n\nstruct metadata_section[num_subsections];\n\n}\n\nstruct metatdata_section {\n\nuint16_t tag;\n\nuint16_t size;\n\n<start of per-type data>\n\n}\n\nFor the current vulnerability, we examine the ABIDepends subsection, whose data is\nessentially:\n\n\n-----\n\nstruct ABIDepends {\n\nuint32_t size;\n\nuint64_t ABIdata[size/8];\n\n}\n\nThis is a fairly straightforward bug — the size field inside the ABIDepends structure is just\nnever checked, while it's also the sole terminator for a reading loop. If we set it high enough\nwithin an application that we flash, we easily hit an out-of-bounds read into unmapped\nmemory, causing the device to reboot. Since the image is flashed (i.e. persistent) on boot,\nthe image processing functionality triggers immediately and we get a persistent boot loop\n(until manual recovery).\n\n## Security Monitor “post-kernel” bugs\n\nThe last set of vulnerabilities could only be reached after gaining full privileges in the Linux\nNormal World. Lilith Wyatt will be discussing how this exploit works in detail at Hitcon 2021\non Nov. 26, [be sure to check out her talk. We’ll also release a detailed blog post about it that](https://hitcon.org/2021/)\nday.\n\n**Microsoft Azure Sphere Security Monitor SMSyscallPeripheralAcquire information**\n**[disclosure vulnerability (TALOS-2021-1309)](https://talosintelligence.com/vulnerability_reports/TALOS-2021-1309)**\n\nStarting with SMSyscallPeripheralAcquire, the syscall used for configuring the pin muxing to\ndifferent devices — it contains an information leak in the output buffer that stems from a\nmissing initialization in the object that is populated with output data.\n\n\n-----\n\nDepending on the number of mux pins that are being configured, multiple instances of this\nstructure are created and pieces are directly copied into the output buffer, including a fourbyte copy of offset 0xc of the above structure. Since bytes 0xe and 0xf are uninitialized, we\nget a two-byte secmon heap leak for each pin that's configured, assuming the output buffer\nhas 0x18 bytes for each configured pin.\n\nWhile not the most informative info leak, there is also a more dangerous one.\n\n**Microsoft Azure Sphere Security Monitor SMSyscallWriteBlockToStageImage**\n**information disclosure vulnerability (TALOS-2021-1310)**\n\nThis vulnerability lies inside the SMSyscallWriteBlockToStageImage function. The function\nprototype is:\n\nint32_t SMSyscallWriteBlockToStageImage(int64_t* handle_value, size_t\noffset_into_staging_partition, size_t offset_into_srcbuffer, void * srcptr, size_t\nsrcbuffer_size)\n\nThe first parameter, the handle_value, is essentially a file descriptor that's returned by\n_SMSyscallOpenImageForStaging, whose prototype is as follows:_\n\nint32_t SMSyscallOpenImageForStaging(int32_t image_size, int32_t\nclobbered, uint64_t* output_handle)\n\nAn image_size is passed in, and if there's enough staging memory available, an\n_output_handle is used for the further image staging syscalls. Backing up to_\n_SMSyscallWriteBlockToStageImage, the offset_into_staging_partition variable is how far_\n\n\n-----\n\nwe re flashing into the current staging image, and this value is checked against the\n_image_size from SMSyscallOpenImageForStaging._\n\nThe fourth and fifth arguments, srcptr and srcbuffer_size are exactly what one would expect,\nthe source of the copy. The third argument, offset_into_srcbuffer is an extreme outlier here,\nas you can only write ~0x1020 bytes in the first place; there's a defacto hard-limit in place\nthat's enforced when copying from DMA memory to Secmon's private buffer: the total size of\nthe syscall struct and the buffers inside cannot exceed 0x1060.\n\nWhy have an offset_into_srcbuffer if this offset is on a buffer with a maximum size in the first\nplace? Regardless of the rationale, this value is not checked, which results in us “staging” an\nimage to flash with any data from Secmon's memory space. We can then read this data out\nvia the SMSyscallReadFlash syscall. Effectively, this allows us to read data from the entire\nSecmon memory space.\n\n**Microsoft Azure Sphere Security Monitor SMSyscallStageBaseManifests offset**\n**[calculation out-of-bounds read vulnerability (TALOS-2021-1343/CVE-2021-41376)](https://talosintelligence.com/vulnerability_reports/TALOS-2021-1343)**\n\nThe SMSyscallStageBaseManifests syscall can be used to stage base manifests. Even\nthough a manifest is wrapped in a standard Azure Sphere image, its contents are\nundocumented. Inside all of the base manifests that we’ve found, we can find the image and\ncomponent ID for the Trusted Keystore and the update-cert-store. Only after this manifest is\nstaged, the images defined therein can be flashed. This syscall function prototype is the\nfollowing:\n\nint32_t SMSyscallStageBaseManifests(uint32_t offset, char *src_buffer, uint32_t\nmanifest_length)\n\nThe manifest_length tells the length of the manifest which is expected to be found at some\n_offset after src_buffer. Similarly to the other Secmon syscalls, the manifest_length can’t be_\nlarger than 0x1060. The offset parameter however has no constraints and it is never checked\nbefore or during the syscall execution, and it could be used by an attacker to reference a\nmanifest out-of-bounds. The exploitation however is not trivial, since there are several\nconstraints at play in the manifest headers: in the advisory we show how we can use this\nout-of-bounds read to stage the manifest in DMA memory, so that it can be read by a\nsecondary M4 core and use a TOCTTOU to alter the manifest while it’s getting staged by this\nsyscall, possibly leading to an information leak.\n\n**Microsoft Azure Sphere Security Monitor SMSyscallStageBaseManifests image**\n**[validation signature check bypass vulnerability (TALOS-2021-1342/CVE-2021-42300)](https://talosintelligence.com/vulnerability_reports/TALOS-2021-1342)**\n\n\n-----\n\nThe SMSyscallStageBaseManifests syscall is supposed to verify base manifests (normally\nsigned by Microsoft) before staging them. Manifests are bundled in an Azure Sphere image,\nwhich is the same file type shared with firmware images, applications and the keystore,\namong other functions. One of the header fields of Azure images is the image type, which, in\nthe case of base manifests, should hold a specific value. This advisory shows that by\nchanging the image type of an image manifest, an attacker could bypass the signature\ncheck-in SMSyscallStageBaseManifests, and stage arbitrary manifests. This, in turn, allows\nanyone to flash any Microsoft-signed binary, meaning they could downgrade arbitrary\nfirmware (or the whole device) to a previous version, and target older issues in the code.\n\n**Microsoft Azure Sphere Security Monitor SMSyscallCommitImageStaging stage-**\n**[without-manifest denial of service vulnerability (TALOS-2021-1341)](https://talosintelligence.com/vulnerability_reports/TALOS-2021-1341)**\n\nThe Trusted Keystore is used for image verification at boot time and when installing images.\nIt’s possible to flash any Microsoft-signed Trusted Keystore without the need to flash a\nrelated base manifest. This can be used to flash an old Trusted Keystore from version 20.01\nthat prevents any further verification of the installed firmware images, preventing the device\nfrom booting. This is a denial-of-service that requires manual recovery.\n\n_Note: This vulnerability is theoretical and was discovered in development mode but has not_\n_been confirmed in pre-production or production environments by either Talos or Microsoft._\n_See the advisory for more details._\n\n**Microsoft Azure Sphere Security Monitor SMSyscallCommitImageStaging 1BL**\n**[firmware downgrade vulnerability (TALOS-2021-1344)](https://talosintelligence.com/vulnerability_reports/TALOS-2021-1344)**\n\nThe 1BL is the bootloader used by Azure Sphere. A new version is usually flashed on every\nfirmware upgrade. This vulnerability shows that it is possible to install any 1BL version (thus\nit’s possible to downgrade its version) by staging the corresponding recovery manifest, which\nis found in every firmware release. This would allow an attacker to downgrade the 1BL and\ntarget older issues in the code.\n\n_Note: This vulnerability is theoretical and was discovered in development mode but has not_\n_been confirmed in pre-production or production environments by either Talos or Microsoft._\n_See the advisory for more details._\n\nMicrosoft issued the following statement on the two vulnerabilities listed above:\n\n\n-----\n\n_We thank Cisco Talos for sharing their continued research into Azure Sphere, which_\n_first started during the Azure Sphere Security Research Challenge in 2020. After_\n_reviewing the findings on TALOS-2021-1341 and TALOS-2021-1344, Microsoft_\n_believes the approach described is implemented by design and does not present a_\n_security risk to customer production environments. For more information on our_\n_conclusion, please read our full statement on these Cisco Talos advisories._\n\n## Coverage\n\nThe following SNORTⓇ rules will detect exploitation attempts. Note that additional rules may\nbe released at a future date and current rules are subject to change pending additional\nvulnerability information. For the most current rule information, please refer to your Cisco\nSecure Firewall or Snort.org.\n\nSnort Rules: 57745-57746, 57266-57267, 57747-57748, 57888-57889, 57899-57900, 5793457935, 57963-57964.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-11-09 - Cisco Talos finds 10 vulnerabilities in Azure Sphere’s Linux kernel, Security Monitor and Pluton.pdf"
    ],
    "report_names": [
        "2021-11-09 - Cisco Talos finds 10 vulnerabilities in Azure Sphere’s Linux kernel, Security Monitor and Pluton.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535858,
    "ts_updated_at": 1743041153,
    "ts_creation_date": 1653688180,
    "ts_modification_date": 1653688180,
    "files": {
        "pdf": "https://archive.orkl.eu/c571342243a91b903e4110e82c43439269f47c0b.pdf",
        "text": "https://archive.orkl.eu/c571342243a91b903e4110e82c43439269f47c0b.txt",
        "img": "https://archive.orkl.eu/c571342243a91b903e4110e82c43439269f47c0b.jpg"
    }
}