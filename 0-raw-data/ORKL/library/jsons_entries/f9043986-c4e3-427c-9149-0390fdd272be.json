{
    "id": "f9043986-c4e3-427c-9149-0390fdd272be",
    "created_at": "2023-01-12T15:04:57.381137Z",
    "updated_at": "2025-03-27T02:05:49.742775Z",
    "deleted_at": null,
    "sha1_hash": "7940f5373bb564b4518d869a5cb15c3ed9396630",
    "title": "2021-07-15 - Data Exfiltrator - A New Tactic for Ransomware Adversaries",
    "authors": "",
    "file_creation_date": "2022-05-28T19:32:53Z",
    "file_modification_date": "2022-05-28T19:32:53Z",
    "file_size": 8480848,
    "plain_text": "# Data Exfiltrator\n\n**blog.reversinglabs.com/blog/data-exfiltrator**\n\n[Threat Research | July 15, 2021](https://blog.reversinglabs.com/blog/tag/threat-research)\n\n\n-----\n\nBlog Author\nRobert Simmons, Independent malware researcher and threat researcher at ReversingLabs. Read\nMore...\n\n\n-----\n\n## Summary\n\nOver the past year, a major change in tactics employed by ransomware adversaries is to exfiltrate data\nfrom the victim's environment. The data then serves as the material for an extortion threat on top of the\nransom for encrypted data. This additional tactic became a trend followed by most major ransomware\nfamilies early last year, 2020 .1 To support this tactic, some ransomware operators have added a specific\ntype of malware to perform this exfiltration to their intrusion set . 2 The five samples analyzed here\nperform this type of data exfiltration. They upload a set of files from the victim's computer to command\nand control servers hosted on IP addresses 51.81.153[.]212, 51.161.82[.]135, and 51.77.110[.]6. All of\nthese IP addresses are owned by OVH SAS, a French hosting company. The malware follows the\nexfiltration with a single line PowerShell command that stops the malware's running process and then\ndeletes the malware file that was executed. The malware has a type of anti-analysis behavior called\n\"Relocate API Code\" according to the Malware Behavior Catalog's 3 categorization 4. The malware reads\na copy of system DLLs into memory and resolves imports from there. This causes a problem for\ndebuggers such as x64dbg 5.\n\n\nInterestingly, these files share code with an earlier malware sample with completely different capabilities.\nThis earlier file has been observed alongside TrickBot, CobaltStrike, and ransomware 6. This earlier\nmalware additionally uses the same anti-analysis technique, but does not exfiltrate data. It has the\ncapability to download a CobaltStrike beacon and execute it 7. In addition to this overlap in code and\nbehavior, the command and control (C2) infrastructure domains are registered via the same registrar.\nAlso, the C2 IP addresses are owned by the same hosting company, OVH.\n\n## Anti-analysis Trick\n\nRelocate API Code\n\nThe first behavior one observes when running these samples in a sandbox or in a debugger is that at the\npoint where the imports are resolved an exception is raised. Debugging past this point is not possible\nwithout circumvention of an anti-analysis trick. This circumvention starts by examining the first encoded\n\n\n-----\n\nstring the samples decode. Encoded strings are found in two general forms in these samples. First is\nwith all the rest of the strings in the file in the .data section. Some of these can be seen in Figure 1 with\none example highlighted.\n\nFigure 1: Encoded Strings\n\nNotice the \"mOrxxxx\" characters that trail each of the encoded strings. These trailing characters will be\nexamined below.\n\nThe other location where encoded strings are found is split up character-by-character as stack strings.\nEach byte is moved one-by-one to a location on the stack before the decoding operation occurs. The first\nstring of this type is in the function that resolves imports from kernel32.dll. This encoded string is shown\nin Figure 2.\n\n\n-----\n\nFigure 2: First Encoded String\n\nThis first string decodes to \"C:\\Windows\\System32\\kernel32.dll\". This path is then used to read the DLL\nfrom the filesystem into memory. Imports are then resolved against this copy of the DLL rather than the\nsystem DLL. The function calls to copy the DLL are shown in Figure 3.\n\nFigure 3: Copy DLL Function\n\nIn the debugger's environment, this read fails with an exception which then prevents the imports from\nbeing properly resolved 8. A detailed explanation of what's happening here can be found on OALabs\nYouTube channel 9.To circumvent this trick, one can create a copy of the DLLs on the filesystem and\nchange their names along with the decoded path strings. This way the DLLs can be read correctly and\nthe imports properly resolved. This change can be done on the fly in the debugger after the strings are\ndecoded. An example of changing this on the fly using the filename kernel33.dll is shown in Figure 4.\n\n\nFigure 4: Change DLL Name\n\n\n-----\n\nAlternatively, the single encoded byte needed for this change can be modified in the sample with a hex\neditor to make this change permanent. This also makes restarting the analysis in the debugger less\nannoying. This byte difference is highlighted using HexFiend's 10 comparison function and can be seen in\nFigure 5.\n\nFigure 5: Original Compared to Patch\n\nAfter the DLL path has been decoded, the various imports from that DLL are then decoded from similar\nstack strings. One example with LoadLibraryW is shown in Figure 6. Again, please note the trailing\n\"mOrxxxx\" string immediately after the encoded bytes of the \"LoadLibraryW\" string.\n\nFigure 6: Encoded LoadLibraryW with Trailing Additional String\n\nOnce the import strings are decoded, a custom implementation of GetProcAddress is used on the copy\nof kernel32.dll to resolve the imports. The results of this process can be seen in Figure 7.\n\n\n-----\n\nFigure 7: After Imports Resolved\n\nExamining the exports for these samples shows a DLL name \"Input.exe\" as well as one exported\nfunction \"bsearch\". These exports are shown in Figure 8.\n\nFigure 8: Exports\n\nThis bsearch function is a version of the binary search algorithm 11. It appears once in the samples as\npart of the custom GetProcAddress implementation. This function call is highlighted in Figure 9.\n\n\n-----\n\nFigure 9: Function Call to bsearch in Custom GetProcAddress\n\nAfter the imports from kernel32.dll have been resolved, the next DLL is ntdll.dll. The process shown\nabove is repeated for this DLL. The alternative name used here was npdll.dll. The path after this change\nis shown in Figure 10.\n\nFigure 10: DLL Name Change\n\nSome of the resolved imports give an idea of what's to come and what the capabilities are for these\nsamples. Examples of this are the imports of \"HttpAddRequestHeadersW\" and \"EnumProcesses\" as\nshown in Figures 11 and 12.\n\nFigure 11: Import HttpAddRequestHeadersW\n\nFigure 12: Import EnumProcesses\n\nThe rest of the DLLs after ntdll.dll that are loaded are not loaded using this same antianalysis trick.\nThese other DLLs are user32.dll, wininet.dll, and psapi.dll. The steps to decode and resolve imports from\neach DLL are divided into separate functions. Each of these functions is shown in figure 13.\n\n\n-----\n\nFigure 13: Resolve Import Functions\n\nIn the code of these samples, another interesting library function calling pattern is to call\nNtAllocateVirtualMemory using syscall to allocate memory. This pattern of function call is shown in Figure\n14.\n\nFigure 14: Syscall Used on NtAllocateVirtualMemory\n\n## Collect Environment Information\n\nThe first set of capabilities in these samples is to collect information about the victim's environment. The\nfirst bit of information collected is the name of the computer. The call to GetComputerNameExA is shown\nin Figure 15.\n\n\n-----\n\nFigure 15: Collect Computer Name\n\nThe next bit of environmental information collected is the physical and virtual memory status. This is\ndone via a call to GlobalMemoryStatusEx 12 which is shown in Figure 16.\n\nFigure 16: Measure Physical and Virtual Memory Status\n\nThe memory status is not sent back to the command and control (C2) infrastructure. It is probably used\nin the file processing algorithm because the primary purpose of these samples is to exfiltrate files from\nthe victim's computer. These files must be copied from the filesystem to memory for processing before\nbeing sent to the C2.\n\nThe next data point collected is the username that ran the malware file. This data point does not appear\nto be sent back to the C2 according to the fields in the network traffic. The API call to GetUserNameA is\n\n\n-----\n\nshown in Figure 17.\n\nFigure 17: Collect Username\n\nNext the samples check the free disk space via GetDiskFreeSpaceExA as shown in Figure 18.\n\nFigure 18: Check Disk Free Space\n\nNext the OS version and product information is collected via calls to GetVersionExA and GetProductInfo.\nThese calls are shown in Figure 19.\n\n\n-----\n\nFigure 19: Gather OS Version and Product Information\n\n## Malware Configuration\n\nAfter the environment information has been collected, the malware configuration strings are then\ndecoded. As opposed to the stack strings used in the import resolution process, the configuration strings\nare normal strings in the .data section as shown above. All of these strings have a trailing \"mOrxxxx\"\nstring. Interestingly this additional data does not cause problems for the decoding process. The reason\nfor this is the decoding function works on a null terminated string. Examining the encoded strings closely,\nthis null termination can be seen before the additional characters. An example of this null termination in a\nconfiguration string is shown in Figure 20.\n\nFigure 20: Null Termination\n\nAn example of this null termination in a stack string is shown in Figure 21.\n\n\n-----\n\nFigure 21: Null Termination in Stack String\n\nThe configuration strings for one particular sample 13 are shown in Figure 22.\n\n\nFigure 22: Decoded Configuration Strings\n\nThe second configuration string from the top in Figure 22 above is used in a field called \"key\" in the C2\ntraffic along with the exfiltrated data. Each of the samples analyzed here have different key strings. The\nfollowing table shows each of these strings along with the first five characters of the SHA256 hash of the\nfile the string was collected from.\n\n**SHA256 Prefix** **Key**\n\ndcc4a 46rnyegq235etnerhgf43trrthgbfRYdfnhg\n\n68af2 8953n7b8ewurdfb3njnyuridrwdb\n\n934c5 huve3fn298vmfu293jKVFDSfvjjfe893\n\n\n-----\n\na7cf0 huve3fn298vmfu293jKVFDSfvjjfe893\n\n8cfd5 3f9n8uv0n43809vn3d092v09290\n\n## Exfiltration\n\nThe data exfiltration process starts by enumerating the logical drives that are available on the victim's\ncomputer. This is determined using a call to GetLogicalDriveStringsW and is shown in Figure 23.\n\nFigure 23: Determine Available Logical Drives\n\nFor each of these logical drives, a function is called that walks the file system searching for targeted files\nand exfiltrating them. This walk function interestingly is recursive. This recursion is shown in Figure 24.\n\nFigure 24: Walk Function Recursion\n\nThe first steps taken in the walk drives function is to add an asterisk to the path that is the input of the\nfunction. This is numbered \"1\" below. Then memory is allocated twice in a row. This is numbered \"2\"\nbelow. The string with the trailing asterisk is then written to one of the two allocated memory locations.\nThis is numbered \"3\" below. Finally, this string is used to call \"FindFirstFileW\" with the second allocated\nmemory location as the output location that receives the structure resulting from the API call. These are\nall shown in Figure 25.\n\n\n-----\n\nFigure 25: Finding Files\n\nAs the malware walks the file system, any files that contain one of the following strings in the filename\nare exfiltrated.\n\n.doc .xls .pdf\n\n.docx .xlsx\n\nInterestingly, the algorithm used to find these files is probably not what the adversary expected. Rather\nthan checking for a file extension as a suffix it actually matches any infix of the above strings. Because of\nthis, any file with .xlsx will already match .xls for example. These target file extensions are shown in\nFigure 26.\n\nFigure 26: Target File Extensions\n\nNext the file size is determined using a call to GetFileSize. This information is included in the exfiltrated\ndata. The API call is shown in Figure 27.\n\n\n-----\n\nFigure 27: Determine File Size\n\nAs the file system walk proceeds, the path strings are emitted as debug strings via a call to\nOutputDebugStringW. This is followed immediately by bytes for a Windows carriage return line feed.\nThese two are shown in Figure 28.\n\nFigure 28: Emit Debug Strings\n\nThis malware can exfiltrate large files. It does this by dividing the file into chunks according to a hard\ncoded \"frame size\". This hard coded size is 32535 bytes and is highlighted in Figure 29.\n\n\n-----\n\nFigure 29: Frame Size\n\nThe above also shows all the other fields that are used in the C2 traffic. The frame number starts at \"-0\"\nthen \"1\", \"2\" etc. The \"filecrc\" field is the cyclic redundancy check (CRC) which is used as a checksum for\nerror detection 14. The last two fields are the filename and the computer name.\n\n\n-----\n\nUsing a constructed test file named testfile.doc the TLS encrypted C2 traffic is intercepted and\nanalyzed using Burp 15 and Inetsim 16. The body parameters and the request headers from this test file\nare shown in Figure 30.\n\nFigure 30: Test Document Shown Being Exfiltrated in C2 Network Traffic\n\nInterestingly, the configuration strings include \"GET\" in addition to \"POST\". However, this capability does\nnot appear to be used in these samples. A check is performed which determines which of the two\nrequest methods are used. This check is shown at the top of Figure 31. The POST and GET options are\nshown in the center, and the call to HttpOpenRequestW is shown at the bottom.\n\nFigure 31: Request Method Options\n\n\n-----\n\nThe algorithm used to determine which files are exfiltrated is flawed in that it will match files that are not\nWord, Excel, or PDF documents. It will exfiltrate any file that contains the target strings anywhere in the\nfilename. A test of this is shown in Figure 32 which uses a fake file with the extension \".txt\" and \".pdf\" in\nthe middle of the filename.\n\nFigure 32: Unexpected Exfiltration\n\nAfter all the filesystem walking has completed, the next function called sends a dummy \"end of\ntransmission\" file out to the C2. The filename of the file is \".lock\" and the content is \"locked\". This file only\nexists in memory and network traffic. It is not written to the filesystem. The strings for this dummy file are\nshown in Figure 33.\n\nFigure 33: Dummy File Strings\n\nThis dummy file as seen in the network traffic is shown in Figure 34.\n\n\n-----\n\nFigure 34: End of Transmission Dummy File\n\nAfter all of the above is finished, the last action taken by the samples is to run a PowerShell command\nfrom a string. This command gets the process ID of the parent process of the command itself. It uses that\nprocess ID to kill the malware's process. It then deletes the malware file from the filesystem. This is to\nclean up after the data exfiltration is complete. The command is executed by a call to CreateProcessA as\nshown in Figure 35.\n\nFigure 35: PowerShell Cleanup Command\n\nThe full text of the PowerShell command is shown in Figure 36.\n\n\n-----\n\nPowerShell Command\n\n## Evolving Variants\n\nThe earliest observed variant of this malware family was compiled on April 24th, 2021 according to the\nPE header TimeDateStamp field. It was then first seen in the Titanium Platform on April 25th, 2021. This\nearliest variant did not include the PowerShell cleanup that was used in the later two variants. The\ncomparison of the older sample 18 and the newer sample 19 analyzed using Relyze 20 is shown in Figure\n36.\n\nFigure 36: Addition of PowerShell Cleanup Capability\n\n\n-----\n\nAnother difference between this oldest sample and most of the newer ones is the inclusion of a program\ndatabase (PDB) path. This path is shown in Figure 37.\n\nFigure 37: PDB Path String\n\nThe two newer samples have very few differences. Code-wise, there is one single function that is ~55%\ndifferent between the two. The rest of the code is identical or nearly identical. This small difference is\nshown in Figure 38.\n\nFigure 38: Difference in Newer Samples\n\nAnother interesting difference between the two newer samples is that the newest sample does not call\nback to a hostname for C2 communication. It is configured to call back to the C2 URL on a bare IP\naddress.\n\n## Related Malware\n\nOne function in particular that is found in each of the three samples analyzed above is the string\ndecoding function. Encoding and decoding functions are a good area of code to examine closely and to\nhunt for in malware repositories. This type of function can be stable across samples and tends to be\nreused by an adversary in multiple campaigns even if the capabilities of the malware are radically\ndifferent. Building a YARA rule based on this function reveals an older malware sample 21 which was\nblogged about by researchers at Walmart 22. The results of a retrohunt in the Titanium Platform using this\nYARA rule is shown in Figure 39. The result shown in orange is a false positive. This file is a copy of one\nof the other actual malware files but appears to have been modified by a researcher.\n\n\n-----\n\nFigure 39: Retrohunt Results\n\nThis sample is definitely related to the three samples analyzed here. It uses the same anti-analysis trick\nas well as the same string obfuscation including the \"mOrxxxx\" trailing characters. Both the standard\nstring form as well as the stack strings are found in this sample. However, this older sample is a\nCobaltStrike beacon loader rather than a data exfiltrator. The YARA rule for detecting this code overlap is\nprovided at the end of the blog. As opposed to earlier YARA rules that I have written, I read the advice\nfrom Marc Ochsenmeier on Twitter about adding comments with the meaning of opcodes in YARA rules\nmeant for sharing 23. This rule and future rules will include the assembly as well as the bytecode strings.\n\nIn addition to this older malware sample that is definitely related, a hunt for other malware that contains\nvariations of the string \"mOrxxxx\" reveals a multitude of potentially related malware samples. These are\nnearly uniformly detected as malicious. A future blog will address these additional files. The results of a\nretrohunt for the full string \"mOrxxxx\" is shown in Figure 40.\n\n\n-----\n\nFigure 40: Full String mOrxxxx\n\nThe results of retrohunts for this string with two Xs and one X are shown in Figure 41 and 42.\n\nFigure 41: Retrohunt for String with Two Xs\n\nFigure 42: Retrohunt for String with One X\n\nAnalysis of the results of these retrohunts will be the topic of a future blog post.\n\n## IOCs\n\nSample 1\n\nFile\n\nFilename Input.exe\n\nFilename v2c.exe\n\nMD5 1010bec081572dc3bd16e26a1e37d815\n\nSHA1 bfc0219efb60fb270cee0b7b102afc0d4b0a121a\n\nSHA256 dcc4ac1302ac5693875c4a4b193242cbb441b77cd918569c43fe318bcf64fe3d\n\n\nImport\nHash\n\n\n85ce0801668e488873e72eeb306503da\n\n\nSSDEEP 768:ycscKP14scGOqEMQcanOPBbEbeFpUGC/YDR5Ws:yV3cGOqEMQcanOJFpUGC/Y9\n\nTimestamp 2021-04-24T17:34:20Z\n\nPDB E:\\work\\proj\\file_sender\\x64\\file_sender.pdb\n\nMagic PE32+ executable (GUI) x86-64, for MS Windows\n\nFile Type Win64 EXE\n\nFile Size 35328\n\nFirst Seen 2021-04-25\n\n\n-----\n\nUser Agent\n\nMozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) discord/0.0.309\nChrome/83.0.4103.122 Electron/9.3.5 Safari/537.36\n\nURL\n\nhxxps[://]files[.]pablotech[.]info/uploadFile.php\n\nHostname\n\nfiles[.]pablotech[.]info\n\nDomain\n\n**Name** **Registrar** **IANA ID**\n\npablotech[.]info Hosting Concepts B.V. d/b/a Registrar.eu 1647\n\nSample 2\nFile\n\nFilename Input.exe\n\nFilename sender.exe\n\nMD5 e3300ec2f31f5730970c5bb066d2f0ed\n\nSHA1 c768882e102a5dd3d1c17d306698c5cfc3d9d8d5\n\nSHA256 68af250429833d0b15d44052637caec2afbe18169fee084ee0ef4330661cce9c\n\nImport Hash 6473877da5764bbd5a9b16892ef13b69\n\nSSDEEP 768:zp2FXczP/cpWyB/3RtUcGOqEMIcqfz/YghUx:zp2FsTcB/UcGOqEMIcqfz/Yg4\n\nTimestamp 2021-04-28T03:00:08Z\n\nMagic PE32+ executable (GUI) x86-64, for MS Windows\n\nFile Type Win64 EXE\n\nFile Size 36352\n\nFirst Seen 2021-05-03\n\nUser Agent\n\n\n-----\n\nMozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) discord/0.0.309\nChrome/83.0.4103.122 Electron/9.3.5 Safari/537.36\n\nURL\n\nhxxps[://]figures[.]pablotech[.]info/uploadFile.php\n\nHostname\n\nfigures[.]pablotech[.]info\n\nDomain\n\n**Name** **Registrar** **IANA ID**\n\npablotech[.]info Hosting Concepts B.V. d/b/a Registrar.eu 1647\n\nSample 3\nFile\n\nFilename Input.exe\n\nFilename v2c.exe\n\nMD5 4af8b45c9b0f73d47a499d92064b6c2e\n\nSHA1 424f3c281f46e4cf2350c78cfa89a87873e0b994\n\nSHA256 934c557e52bd47fa312ea4098e05781145d0b81c9dc543ef42b266813bdb05d4\n\n\nImport\nHash\n\n\n6473877da5764bbd5a9b16892ef13b69\n\n\nSSDEEP 768:9vutX7Qp6CPRp8Yh/ZYWcGOqEMUcgk9/Y7hCeUpU:K7QpJp8YFrcGOqEMUcg0/Y7lk\n\nTimestamp 2021-05-17T20:33:40Z\n\nMagic PE32+ executable (GUI) x86-64, for MS Windows\n\nFile Type Win64 EXE\n\nFile Size 36352\n\nFirst Seen 2021-05-18\n\nUser Agent\n\nMozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\n\n\n-----\n\nURL\n\nhxxps[://]51.161.82[.]135/uploadFile.php\n\nIP Address\n\n**IP** **Owner** **ASN**\n\n51.161.82[.]135 OVH SAS 16276\n\nSample 4\nFile\n\nFilename Input.exe\n\nFilename v2.exe\n\nMD5 7c801e3c256d2e9e1f4462fe84e44c68\n\nSHA1 4cd9cecd1d093f290e6f8f0ad6d5e76dbedbf3d9\n\nSHA256 a7cf0f72bb6f1e0a61fbf39e3a3a36db6540250caeef35b47fb51a8959f40984\n\nImport Hash 9f86f12427bca134faaa21bcc0d849d3\n\nSSDEEP 768:vkcGOqEMccVhPO4TrASVqipOHMd6m/YFh50:ccGOqEMccV7rAZipOHA/YFT\n\nTimestamp 2021-05-24T23:06:16Z\n\nPDB E:\\work\\proj\\file_sender\\x64\\file_sender.pdb\n\nMagic PE32+ executable (GUI) x86-64, for MS Windows\n\nFile Type Win64 EXE\n\nFile Size 37376\n\nFirst Seen 2021-06-01\n\nUser Agent\n\nMozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\n\nURL\n\nhxxps[://]51.161.82[.]135/uploadFile.php\n\nIP Address\n\n\n-----\n\n**IP** **Owner** **ASN**\n\n51.161.82[.]135 OVH SAS 16276\n\nSample 5\nFile\n\nFilename file_sender.exe\n\nFilename sender.exe\n\nMD5 12a7595d94e142847a04f11659ed183d\n\nSHA1 f80a2f102ca0297d053c75e0676049dc87cb3f35\n\nSHA256 8cfd554a936bd156c4ea29dfd54640d8f870b1ae7738c95ee258408eef0ab9e6\n\nImport Hash 9f86f12427bca134faaa21bcc0d849d3\n\nSSDEEP 768:sPcGOqEMccNNPayYDcfHyIY2QUy2h08wx:2cGOqEMccNEDuhY2FS84\n\nTimestamp 2021-06-15T10:57:36Z\n\nPDB E:\\work\\proj\\file_sender\\x64\\file_sender.pdb\n\nMagic PE32+ executable (GUI) x86-64, for MS Windows\n\nFile Type Win64 EXE\n\nFile Size 36352\n\nFirst Seen 2021-06-16\n\nUser Agent\n\nMozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\n\nURL\n\nhxxp[://]51.77.110[.]6/uploadFile.php\n\nIP Address\n\n**IP** **Owner** **ASN**\n\n51.77.110[.]6 OVH SAS 16276\n\n## YARA Rule\n\n\n-----\n\nprivate rule WindowsPE\n{\ncondition:\nuint16(0) == 0x5A4D and uint32(uint32(0x3C)) == 0x00004550\n}\n\nrule DataExfiltrator_Decoder\n{\nmeta:\nauthor = \"Malware Utkonos\"\ndate = \"2021-05-07\"\ndescription = \"String decoding function found in data exfiltration malware.\"\nexemplar = \"dcc4ac1302ac5693875c4a4b193242cbb441b77cd918569c43fe318bcf64fe3d\"\nstrings:\n$a = { 4489442418 // mov dword [rsp+0x18 {arg_18}], r8d\n88542410 // mov byte [rsp+0x10 {arg_10}], dl\n48894c2408 // mov qword [rsp+0x8 {arg_8}], rcx\n4883ec28 // sub rsp, 0x28\n8b442440 // mov eax, dword [rsp+0x40 {arg_18}]\n33d2 // xor edx, edx {0x0}\nb904000000 // mov ecx, 0x4\n48f7f1 // div rcx\n}\ncondition:\nWindowsPE and $a\n}\n\nReferences:\n\n1 [https://research.checkpoint.com/2020/ransomware-evolved-double-extortion/](https://research.checkpoint.com/2020/ransomware-evolved-double-extortion/)\n\n2 [https://docs.oasis-open.org/cti/stix/v2.1/cs01/stix-v2.1-cs01.html#_5ol9xlbbnrdn](https://docs.oasis-open.org/cti/stix/v2.1/cs01/stix-v2.1-cs01.html#_5ol9xlbbnrdn)\n\n3 [https://github.com/MBCProject/mbc-markdown/tree/master/yfaq](https://github.com/MBCProject/mbc-markdown/tree/master/yfaq)\n\n4 https://github.com/MBCProject/mbc-markdown/blob/master/anti-behavioral-analysis/evade\ndebugger.md\n\n\n5 [https://x64dbg.com/](https://x64dbg.com/)\n\n6 [https://medium.com/walmartglobaltech/trickbot-crews-new-cobaltstrike-loader-32c72b78e81c](https://medium.com/walmartglobaltech/trickbot-crews-new-cobaltstrike-loader-32c72b78e81c)\n\n7 Ibid.\n\n8 Thanks to Sandor Nemes for assistance in understanding this behavior.\n\n9 [https://www.youtube.com/watch?v=242Tn0IL2jE&t=1053s](https://www.youtube.com/watch?v=242Tn0IL2jE&t=1053s)\n\n[10 https://hexfiend.com/](https://hexfiend.com/)\n\n11 [https://en.cppreference.com/w/c/algorithm/bsearch](https://en.cppreference.com/w/c/algorithm/bsearch)\n\n\n12 [https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex)\n\n13 934c557e52bd47fa312ea4098e05781145d0b81c9dc543ef42b266813bdb05d4\n\n14 [https://en.wikipedia.org/wiki/Cyclic_redundancy_check](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)\n\n15 [https://portswigger.net/burp](https://portswigger.net/burp)\n\n16 [https://www.inetsim.org/](https://www.inetsim.org/)\n\n\n17\n\n\ndcc4ac1302ac5693875c4a4b193242cbb441b77cd918569c43fe318bcf64fe3d\n\n\n-----\n\nIbid.\n\n19 68af250429833d0b15d44052637caec2afbe18169fee084ee0ef4330661cce9c\n\n20 [https://www.relyze.com/](https://www.relyze.com/)\n\n21 0234f80c6fd3768f9619d6fcd50d775ec686719fcc665007bfd1606bbe787744\n\n22 [https://medium.com/walmartglobaltech/trickbot-crews-new-cobaltstrike-loader-32c72b78e81c](https://medium.com/walmartglobaltech/trickbot-crews-new-cobaltstrike-loader-32c72b78e81c)\n\n23 [https://twitter.com/ochsenmeier/status/1379546812437118980](https://twitter.com/ochsenmeier/status/1379546812437118980)\n\n### MORE BLOG ARTICLES\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-07-15 - Data Exfiltrator - A New Tactic for Ransomware Adversaries.pdf"
    ],
    "report_names": [
        "2021-07-15 - Data Exfiltrator - A New Tactic for Ransomware Adversaries.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535897,
    "ts_updated_at": 1743041149,
    "ts_creation_date": 1653766373,
    "ts_modification_date": 1653766373,
    "files": {
        "pdf": "https://archive.orkl.eu/7940f5373bb564b4518d869a5cb15c3ed9396630.pdf",
        "text": "https://archive.orkl.eu/7940f5373bb564b4518d869a5cb15c3ed9396630.txt",
        "img": "https://archive.orkl.eu/7940f5373bb564b4518d869a5cb15c3ed9396630.jpg"
    }
}