{
    "id": "aef4aecd-8c01-4b4f-9170-5914379406e5",
    "created_at": "2023-01-12T15:05:31.797828Z",
    "updated_at": "2025-03-27T02:12:11.101815Z",
    "deleted_at": null,
    "sha1_hash": "a7e409c901a77561a247afc9c22519aed5cc67c0",
    "title": "2007-11-01 - Spam from the kernel",
    "authors": "",
    "file_creation_date": "2022-05-28T03:45:35Z",
    "file_modification_date": "2022-05-28T03:45:35Z",
    "file_size": 175489,
    "plain_text": "# Spam from the kernel\n\n**virusbulletin.com/virusbulletin/2007/11/spam-kernel**\n\n2007-11-01\n\n### Kimmo Kasslin\n\nF-Secure, Malaysia\n\n### Elia Florio\n\nSymantec, Ireland Editor: Helen Martin\n**Abstract**\n\nTrojan.Srizbi is the first example seen in the wild of a complex piece of malware that\noperates fully from kernel mode. Kimmo Kasslin and Elia Florio provide a detailed analysis.\n\n## Introduction\n\nIn December 2006 one of the authors of this article concluded his research paper on kernel\nmalware with the following paragraph [1]:\n\n‘This paper has shown the basic techniques that kernel malware is using to do their job.\nTheir main role has been to perform some specific tasks for the main user-mode component.\nHowever, the scene is changing. There has been lots of interest in various research groups\nto investigate for the possibilities to do more complex tasks directly from kernel. The next big\nthing is going to be the network side. This year we have already seen presentations talking\nabout how backdoors can be implemented directly from kernel mode using only the NDIS\nlayer and custom TCP/IP stack. We have also seen a presentation about bypassing personal\nfirewalls from kernel-mode.’\n\nRegrettably, the prediction became true in June 2007 when the authors started to analyse a\nmalicious kernel-mode driver consisting of large amounts of code. After deeper analysis it\nbecame evident that there were no signs of user-mode injection, meaning that all of the code\nwas being executed at ring 0. Since then the malware family has been known as\nTrojan.Srizbi (or as Rootkit:W32/Agent.EA).\n\n## Origin of Trojan.Srizbi\n\nIn June 2007 several AV companies raised an alert due to a large-scale web-based attack\nbeing carried out with drive-by exploits. A malicious tag was injected into the homepages of\nmany legitimate Italian and Russian websites. Attackers had injected an IFRAME to redirect\n\n\n-----\n\nvisitors to a website running a multi-staged exploit kit, nowadays best known as MPack [2].\nThe specific MPack installation used for this attack was designed to download several\ntrojans from the remote server 81.95.146.150, hosted by the ambiguous ‘Russian Business\nNetwork’.\n\nOne of the nasty creatures to spread from this server was Trojan.Srizbi, a sophisticated\npiece of malware contained within 150Kb of kernel mode code. This was the first public\nrevelation of Srizbi, but further research tracked older samples back to April 2007. The first\nobserved filename was ‘windbg48.sys’, followed by ‘symavc32.sys’ more recently. Other\npseudo random names of this threat always take the format [CHARS][2DIGITS] (e.g.\nCmjg57.sys, Wdml36.sys, Fln51.sys, etc.).\n\nThe Srizbi driver is installed by a dropper component that is packed with UPX and protected\nwith a layer of scrambled code. This layer uses custom spaghetti code obfuscation with\nCALL/JMP mixed with junk opcodes. It resembles the Rustock.B polymorphic packer, but it is\nmore advanced. The dropper code makes API calls by using PUSH/RET sequences, and\nparameters are pushed into the stack with MOV [ESP] and other complex indirect loading\ninstructions, making standard static analysis almost impossible (see Figure 1).\n\n\n-----\n\n**Figure 1. Examples of scrambled API calls used by the Srizbi packer.**\n\nReverse engineering of this piece of code is not straightforward and may require the\nassistance of custom tracing tools. However, it is possible to spot two principal decryption\nroutines in the code:\n\n1. decryption with NOT BYTE\n\n2. decryption with BYTE XOR 0xB0\n\nDecryption routine (1) is identical to the one inside the driver and is used to decrypt all text\nstrings; the XOR decryption (2) is used to decrypt the embedded driver. The Srizbi installer\ndrops a copy of the driver into the ‘%SystemRoot%\\System32\\drivers’ folder and installs it as\na service via OpenSCManager and CreateService. Next, the service is started and the\ninstaller self-deletes.\n\n\n-----\n\nAnother of Srizbi s challenges is the use of CRC values instead of basic string compares\nwhen it searches for names or resolves imported API functions dynamically. In some cases\nthe only viable solution to find which string is being searched by Srizbi is to brute force CRCs\nover a set of possible strings.\n\n## Full-kernel malware\n\nWe can say with some certainty that Trojan.Srizbi represents an important milestone in the\nevolution of malware utilizing kernel-mode techniques. It is the first complex full-kernel\nmalware [3] to have features such as file and registry hiding, bypassing of memory hooks,\nand low-level NDIS hooks with a private TCP/IP stack. The latter is utilized to implement a\nfully blown spam client with an HTTP-based command and control (C&C) infrastructure – all\ndirectly from ring 0.\n\nThe fact that Trojan.Srizbi is fully implemented in kernel mode makes it very powerful. It can\nactivate very early during the boot process, allowing it to make its system modifications\nbefore most security products even have a chance to load. Also, many security products do\nnot consider activities initiated by kernel-mode code to be suspicious or malicious since the\nkernel should be trusted.\n\nA feature that makes Srizbi unique is the fact that it disables and removes other competitor\nrootkits from the infected system very effectively. The trend of malware gangs fighting each\nother is becoming more intense nowadays since every unprotected machine is likely to be\ntargeted by multiple pieces of malware – but in the end, there can be only one! Only the\nstrongest and most sophisticated malware will survive.\n\nSrizbi tries to accomplish this goal in a unique way: it rebuilds a clean copy of KiServiceTable\nby reading NTOSKRNL.EXE directly from disk and then it retrieves all the original (hook-free)\nfunction pointers of the required file and registry API functions. With this technique Srizbi is\nable to bypass most rootkits (and security products) present on the machine and can safely\nenumerate any files and registry keys.\n\nSrizbi rebuilds its own Service Table from disk.\n**Figure 2. Srizbi rebuilds its own Service Table from disk.**\n\nWe also found that Srizbi contains a generic driver removal routine based on CRC values.\nThe routine enumerates services sub keys from following key:\n```\n\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\[SRV_NAME]\n\n```\nIf the CRC of [SRV_NAME] matches one of the following hardcoded CRC values, then the\ntrojan unloads the driver with ZwUnloadDriver then deletes the launch point of the service by\nremoving the related registry key and its sub keys.\n\n\n-----\n\n**CRC value** **Service name**\n\n0xe0e5a117 runtime\n\n0x4c4f27cc runtime2\n\n0xbf36b345 xpdx\n\n0x949b30b3 lzx32\n\n**Table 1. CRC values and service names targeted by Srizbi’s driver removal routine.**\n\nThe services in Table 1 are quite (in)famous within the AV industry, since they are used by\ntwo of today’s most common rootkit malware families: Backdoor.Rustock.B (lzx32, xpdx) and\nTrojan.Pandex (runtime, runtime2). Srizbi also contains the text strings of some other\nmalware, ‘wincom32.sys’ and ‘ntio256.sys’, however they are not referenced and never used\nin the actual code. More evidence of the ongoing war between the Srizbi gang and other\nmalware authors was reported by researchers at Arbor Networks [4], who noticed\nStormWorm bots running DDoS attacks against Srizbi domains.\n\n## NDIS hijacking\n\nFrom a technical point of view the most interesting part of Trojan.Srizbi is its network layer\nimplementation. Its sole purpose is to bypass personal firewalls and other security products\nthat monitor incoming and outgoing network packets. The implication is that the infected\nmachine will be able to communicate with the command and control server and send\nthousands of spam emails even if the firewall is set to the ‘block-all-traffic’ mode.\n\n_Windows networking architecture is divided into different layers where the ones most_\ncommonly used by today’s firewalls are TDI and NDIS. The NDIS layer abstracts the network\nhardware from network drivers and is the lowest layer available for third-party network\ndrivers. This makes it the obvious choice for modern firewalls since the lower they operate\nthe harder it is to bypass them.\n\nUsually NDIS hooking firewalls install their triggers to the following locations:\n\nNDIS library functions\n\nNDIS_PROTOCOL_BLOCK structure handler function pointers\n\nNDIS_OPEN_BLOCK structure handler function pointers\n\nThe actual triggers controlling inbound and outbound traffic are implemented by replacing\nseveral function pointers from inside the two internal NDIS structures that the NDIS layer\nuses for sending packets to and receiving packets from the driver controlling the hardware.\nThe following are some commonly hooked handler functions:\n\n\n-----\n\nNDIS_OPEN_BLOCK->SendHandler\n\nNDIS_OPEN_BLOCK->SendPacketsHandler\n\nNDIS_OPEN_BLOCK->ReceiveHandler\n\nNDIS_OPEN_BLOCK->ReceivePacketHandler\n\nThe firewall driver normally installs inline hooks into four functions exported by ndis.sys that\nallow it to hook the required NDIS handler functions for any newly registered protocol driver.\nOtherwise the new protocol driver would be able to send and receive traffic without the\nfirewall seeing it. The hooked functions are:\n\nNdisRegisterProtocol\n\nNdisDeregisterProtocol\n\nNdisOpenAdapter\n\nNdisCloseAdapter\n\nNow that we have had a brief introduction to how modern firewalls are able to filter the traffic,\nlet’s continue by looking at what makes it possible for Trojan.Srizbi to bypass them\ncompletely.\n\nFirst, Trojan.Srizbi finds a network adapter that it can use to communicate with the Internet. It\ndoes this by finding a suitable interface from the TCP/IP driver’s registry settings. It calls an\nundocumented LookupRoute function exported by tcpip.sys which will give it the IP address\nof the default gateway. Then it enumerates all sub keys under the key:\n```\n\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\n\n```\nIt uses the default gateway address to find the matching interface, or if there are no matches\nit will take the one that has proper IP settings defined. Next, it enumerates all sub keys under\nthe key:\n```\n\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Adapters\n\n```\nFinally, it selects the adapter whose IpConfig value matches the previously found interface.\n\nTrojan.Srizbi gets access to the NDIS structures by installing a dummy protocol temporarily.\nIt first registers a new protocol with a random name by calling NdisRegisterProtocol. Then it\nbinds the protocol to the previously selected adapter by calling NdisOpenAdapter. As a\nresult, the temporary protocol’s NDIS_OPEN_BLOCK handler functions will be set up by the\nunderlying system.\n\n\n-----\n\nAs we have already mentioned these two functions are commonly hooked by the firewall.\nTrojan.Srizbi solves this problem by using its private and hook-free version of ndis.sys.\nDuring initialization it loads the ndis.sys file into memory, resolves its imports and finally\nrelocates the new module into the base address of the original ndis.sys module. This means\nthat the private module will still be using e.g. the same global variables as the original\nndis.sys module.\n\nThe following is the disassembly of the private and original NdisRegisterProtocol functions:\n```\nkd> u poi(Yol33!NdisRegisterProtocol)\n816b917d 8bff     mov  edi,edi\n816b917f 55      push  ebp\n816b9180 8bec     mov  ebp,esp\n816b9182 51      push  ecx\n816b9183 53      push  ebx\n816b9184 56      push  esi\n816b9185 57      push  edi\n816b9186 b938d16ff9  mov  ecx,offset NDIS!ndisPkgs+0x20 (f96fd138)\nkd> u ndis!NdisRegisterProtocol\nNDIS!NdisRegisterProtocol:\nf96ff17d e9b2d75200  jmp  fwdrv+0x934 (f9c2c934)\nf96ff182 51      push  ecx\nf96ff183 53      push  ebx\nf96ff184 56      push  esi\nf96ff185 57      push  edi\nf96ff186 b938d16ff9  mov  ecx,offset NDIS!ndisPkgs+0x20 (f96fd138)\n\n```\nWith the help of the dummy protocol the driver now has a handle to the registered protocol\nthat is bound to the underlying adapter. The handle is returned by NdisRegisterProtocol’s\nsecond argument called NdisProtocolHandle, which is defined as PNDIS_HANDLE. This is\nactually a pointer to the dummy protocol’s NDIS_PROTOCOL_BLOCK. By using the\ninformation stored in this structure the malware is able to find the adapter’s\nNDIS_MINIPORT_BLOCK structure that is part of the lowest layers of NDIS. It then searches\nfor other protocols that are bound to the same adapter, and takes the first one to match any\nof the following protocols:\n\n1. TCPIP\n\n2. PSCHED\n\n3. TCPIP_WANARP\n\nThe way this whole process works is illustrated in Figure 3.\n\n\n-----\n\n**Figure 3. Trojan.Srizbi uses the ‘dummy protocol’ approach to find the NDIS**\n**structures that it hooks.**\n\nNow that the driver has access to the NDIS structures of an existing protocol it will replace a\nbunch of handler functions with its own. In addition, it fetches the addresses of certain\nhandler functions that it will use itself. After it has finished it will just uninstall the dummy\nprotocol.\n\nTrojan.Srizbi uses its NDIS hooks and the original handler functions together with its own\nTCP/IP stack to send and receive packets.\n\nTo send packets it uses the following handler function:\n\nNDIS_MINIPORT_BLOCK->SendPacketsHandler\n\nTo get a notification after the send operation has completed it uses the following hook:\n\nNDIS_OPEN_BLOCK->SendCompleteHandler\n\nTo receive packets it uses the following hooks:\n\nNDIS_OPEN_BLOCK->ReceiveHandler\n\nNDIS_OPEN_BLOCK->ReceivePacketHandler\n\nSince the malware is using its own TCP/IP stack it has somehow to identify which of the\nreceived packets should be passed to its private stack instead of the stack used by the\nsystem. One solution to this problem would be to use its own IP and MAC addresses since\ntheir combination should be unique on most physical machines [5].\n\n\n-----\n\nHowever, Trojan.Srizbi uses a different approach. When it sends packets it always uses a\nsource port that is higher than 32,000. For every packet received it checks whether it is a\nTCP packet, whether its destination IP equals the client's address, and whether the\ndestination port is larger than 32,000. If all of these are true then it forwards the packet to its\nprivate stack. To make sure that no other application (using ephemeral ports) sends packets\nusing its reserved source port range it sets the MaxUserPort registry value to 31,999, which\nis defined under the following key:\n```\n\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\n\n## Stealth spam\n\n```\nSrizbi (like Rustock) is a spam bot. A sophisticated, stealthy and powerful spam machine.\nOnce the trojan takes over NDIS networking, it contacts C&C servers on TCP port 4099 and\nretrieves spam instructions and configurations. The spam backdoor has a large set of\ncommands that allow the botmaster to define a lot of parameters. A deep analysis of the\nC&C protocol is beyond the scope of this document, but we can briefly summarize how it\nworks. Each spam session starts with the download of a ZIP package containing the files\nshown in Table 2.\n\n**File** **Content**\n\nconfig Configuration file with all spam parameters (e.g. task_owner, max_mails,\nmax_sim conn, pipeline, subj, etc.)\n\nmessage Text/HTML body of the spam message\n\nmlist List of recipients\n\n000_data22 List of mail domains\n\n001_ncommall List of names/surnames\n\n002_senderna List of names/surnames\n\n003_sendersu List of names/surnames\n\nmxdata MX records of the domains\n\n**Table 2. Configuration files included in the package provided by the Srizbi C&C server.**\n\nSrizbi also has an advanced feature that allows the trojan eventually to bypass some badly\nconfigured honeypot machines. The trojan does not trust the locally configured DNS server\nof the infected machine and instead receives all the necessary DNS information as part of\nthe ZIP package. For example, if Srizbi needs to resolve the ‘smtp.acme.org’ server to send\nspam, it will receive in the package the necessary MX record info for the ‘acme.org’ domain.\nAny honeypot that simply blocks/redirects DNS resolutions to prevent threats from spamming\n\n\n-----\n\nwill be bypassed by Srizbi because it has a kind of private DNS server over the C&C\nchannel. Srizbi can send image spam in HTML format using English and also Cyrillic\nUnicode character sets.\n\n## Conclusion\n\nDespite all the advanced features implemented for spam and networking, the major\nweakness of Srizbi is its hiding technique. The rootkit attempts to hide itself by placing the\nfollowing kernel hooks:\n\nInline hook: NtOpenKey, NtEnumerateKey\n\n\\FileSystem\\Ntfs driver: IRP_MJ_CREATE, IRP_MJ_DIRECTORY_CONTROL;\n\nThese hooks effectively hide the malware’s driver file and registry keys, but currently they\ncan easily be detected by common rootkit detectors and can effectively be bypassed to\nremove the threat from the infected system.\n\n### Bibliography\n\n[1] Kasslin, K. Kernel malware: the attack from within. 2006. http://www.fsecure.com/weblog/archives/kasslin_AVAR2006_KernelMalware_paper.pdf.\n\n[2] Symantec. MPack – The Movie.\nhttp://www.symantec.com/enterprise/security_response/weblog/2007/06/mpack_the_movie.h\ntml.\n\n[3] Malicious code that executes all its code in ring 0. After it is installed into the system by a\ndropper component (user-mode code or kernel-mode exploit) it will be able to operate by\nitself.\n\n[4] McPherson, D. When spambots attack – each other!\n[http://asert.arbornetworks.com/2007/07/when-spambots-attack-each-other/.](http://asert.arbornetworks.com/2007/07/when-spambots-attack-each-other/)\n\n[5] Hoglund, G.; Butler, J. Rootkits: subverting the Windows kernel. 2005. Upper Saddle\nRiver, NJ. Addison-Wesley Professional. 324 pages. ISBN 0-321-29431-9.\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order\nto infiltrate organizations’ dedicated environments and transform them into attack\nlaunchpads. In this article Aditya Sood presents a new module introduced by…\n\n\n-----\n\n### Collector-stealer: a Russian origin credential and information extractor\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to\nexfiltrate sensitive data from end-user systems and store it in its C&C panels. In this article,\nresearchers Aditya K Sood and Rohit Chaturvedi present a 360…\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and\nfrom that moment onward, was intrigued by the properties of these small pieces of selfreplicating code. Joe Wells was an expert on computer viruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\nKurt Natvig wanted to understand whether it’s possible to recompile VBA macros to another\nlanguage, which could then easily be ‘run’ on any gateway, thus revealing a sample’s true\nnature in a safe manner. In this article he explains how he recompiled…\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware,\ndiscussing his team's findings related to the C&C design and some security issues they\nidentified during the research.\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\n_Copyright © 2007 Virus Bulletin_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2003 - 2009/2007-11-01 - Spam from the kernel.pdf"
    ],
    "report_names": [
        "2007-11-01 - Spam from the kernel.pdf"
    ],
    "threat_actors": [
        {
            "id": "c9617bb6-45c8-495e-9759-2177e61a8e91",
            "created_at": "2022-10-25T15:50:23.405039Z",
            "updated_at": "2025-03-27T02:00:55.462193Z",
            "deleted_at": null,
            "main_name": "Carbanak",
            "aliases": [
                "Carbanak",
                "Anunak"
            ],
            "source_name": "MITRE:Carbanak",
            "tools": [
                "Carbanak",
                "Mimikatz",
                "PsExec",
                "netsh"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "bb8702c5-52ac-4359-8409-998a7cc3eeaf",
            "created_at": "2023-01-06T13:46:38.405479Z",
            "updated_at": "2025-03-27T02:00:02.82533Z",
            "deleted_at": null,
            "main_name": "FIN7",
            "aliases": [
                "JokerStash",
                "ATK32",
                "G0046",
                "Coreid",
                "Carbanak",
                "Sangria Tempest",
                "CARBON SPIDER",
                "GOLD NIAGARA",
                "G0008",
                "ELBRUS",
                "Carbon Spider"
            ],
            "source_name": "MISPGALAXY:FIN7",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "ed3810b7-141a-4ed0-8a01-6a972b80458d",
            "created_at": "2022-10-25T16:07:23.443259Z",
            "updated_at": "2025-03-27T02:02:09.801771Z",
            "deleted_at": null,
            "main_name": "Carbanak",
            "aliases": [
                "Anunak",
                "Carbanak",
                "Carbon Spider",
                "ELBRUS",
                "Gold Waterfall",
                "Sangria Tempest"
            ],
            "source_name": "ETDA:Carbanak",
            "tools": [
                "AVE_MARIA",
                "Agentemis",
                "AmmyyRAT",
                "Antak",
                "Anunak",
                "Ave Maria",
                "AveMariaRAT",
                "BABYMETAL",
                "BIRDDOG",
                "Backdoor Batel",
                "Batel",
                "Bateleur",
                "BlackMatter",
                "Boostwrite",
                "Cain & Abel",
                "Carbanak",
                "Cl0p",
                "Cobalt Strike",
                "CobaltStrike",
                "DNSMessenger",
                "DNSRat",
                "DNSbot",
                "DRIFTPIN",
                "DarkSide",
                "FOXGRABBER",
                "FlawedAmmyy",
                "HALFBAKED",
                "JS Flash",
                "KLRD",
                "MBR Eraser",
                "Mimikatz",
                "Nadrac",
                "Odinaff",
                "POWERPIPE",
                "POWERSOURCE",
                "PsExec",
                "SQLRAT",
                "Sekur",
                "Sekur RAT",
                "SocksBot",
                "SoftPerfect Network Scanner",
                "Spy.Agent.ORM",
                "TEXTMATE",
                "TeamViewer",
                "TiniMet",
                "TinyMet",
                "Toshliph",
                "VB Flash",
                "WARPRISM",
                "avemaria",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535931,
    "ts_updated_at": 1743041531,
    "ts_creation_date": 1653709535,
    "ts_modification_date": 1653709535,
    "files": {
        "pdf": "https://archive.orkl.eu/a7e409c901a77561a247afc9c22519aed5cc67c0.pdf",
        "text": "https://archive.orkl.eu/a7e409c901a77561a247afc9c22519aed5cc67c0.txt",
        "img": "https://archive.orkl.eu/a7e409c901a77561a247afc9c22519aed5cc67c0.jpg"
    }
}