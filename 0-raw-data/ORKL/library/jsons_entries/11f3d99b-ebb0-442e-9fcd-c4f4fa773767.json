{
    "id": "11f3d99b-ebb0-442e-9fcd-c4f4fa773767",
    "created_at": "2023-01-12T15:04:45.239328Z",
    "updated_at": "2025-03-27T02:05:28.228776Z",
    "deleted_at": null,
    "sha1_hash": "e15eb02a5e7874d5f34e48ea418f55e80326adee",
    "title": "2020-08-20 - DBatLoader-ModiLoader Analysis – First Stage",
    "authors": "",
    "file_creation_date": "2022-05-27T22:01:04Z",
    "file_modification_date": "2022-05-27T22:01:04Z",
    "file_size": 441695,
    "plain_text": "# DBatLoader/ModiLoader Analysis – First Stage\n\n**[zero2auto.com/2020/08/20/dbatloader-modiloader-first-stage/](https://zero2auto.com/2020/08/20/dbatloader-modiloader-first-stage/)**\n\n0verfl0wz2a August 20, 2020\n\n**Reversing the First Stage**\n\nI don’t typically tend to reverse engineer Delphi binaries, as most of the malicious software\nwritten in Delphi is actually the wrapper/packer for the main payload written in something like\nC/C++. However, scrolling through Twitter one day, I noticed **[@abuse.ch replying to a tweet](https://twitter.com/abuse_ch/status/1291433457319661572?s=20)**\nabout a somewhat unknown loader currently spreading FormBook. After doing some further\nresearch, it was clear that while there are YARA rules for this particular loader, not much is\nknown about the functionality. Based on the fact it was Delphi-based, I thought it would be a\npretty neat learning experience to dive into, relying on IDA Pro and x32dbg to reverse the\n[sample, rather than using IDR which I’m not much of a fan of. So, let’s get into it!](https://github.com/crypto2011/IDR)\n\n**Brief:**\n\nModiLoader/DBatLoader/NatsoLoader is a 2 stage malware loader that was first spotted on\n[the 9th of June (uploaded to MalwareBazaar). The initial loader reaches out to a cloud](https://bazaar.abuse.ch/browse.php?search=modiloader)\nbased service, in certain cases Google Drive, and downloads the second stage loader, which\nis responsible for dropping the final payload to the disk and executing it. This final payload is\ncommonly FormBook, however it has also dropped Netwire RAT and Remcos in the past.\n\nThe preferred method of distribution for this particular loader is Malspam, often targeting\nspecific regions, although based on the method of storage for the second stage loader,\ngeolocking is not possible (as far as I am aware).\n\n**The Packer:**\n\nThe packer used to pack the sample we will be focusing on is fairly simple, and is also\npresent in 3 other samples of ModiLoader I looked at. Four functions are responsible for\nextracting, decoding, and executing the actual payload, and so it can be assumed the\nremaining functions are junk. There are 3 important hardcoded strings in the packer; the\n“key” to decode the executable, the encoded second stage URL, and a replacement string.\n\n\n-----\n\nThe key is an integer (stored as a string), that is used in a simple operation to decode each\nbyte of the payload. An implementation of this operation can be seen in Python 2.7 below the\nimage.\n```\nhardcoded_int = int(hardcoded_int)\ncalculation = hardcoded_int & 0x800000FF\ncalculation = (calculation | 0xFFFFFF00)\ndecoded_payload = “”\nfor byte in encoded_data:\n     new_byte = abs(calculation + ord(byte)) & 0xFF\n     decoded_payload += struct.pack(\"B\", new_byte)[0]\n\n```\n\n-----\n\nOnce the payload has been decoded, the packer will then search for a placeholder in the\ndecoded payload (the replacement string is the same in both the packer and the decoded\npayload), and then replace that with the encoded URL. Interestingly, this prevented\n**[unpac.me from unpacking one of the samples correctly, as it dumped the decoded payload](https://www.unpac.me/#/)**\nbefore the encoded URL was copied over. This wasn’t the case for every sample, but writing\na quick static unpacker using some Regex isn’t the most difficult task in the world for this\npacker, and may save you some issues with incorrectly unpacked files.\n\nOnce the payload is ready for execution, the packer will allocate a region of memory, map\nthe executable into the region (after resolving imports), and then execute it.\n\nInterested in how to statically unpack these payloads, and automate the rest of the analysis?\nWe will be covering automated analysis for this sample, and many others, as part of our\nZero2Automated Advanced Malware Analysis course! If you’re interested in checking out the\ncourse, you can find it **[here! We look forward to seeing you there!](https://courses.zero2auto.com/)**\n\n**First Stage Loader:**\n\nOpening the first stage in IDA, we are met with the DLLEntryPoint. In this function, we can\nsee one unnamed call (sub_4206A0()), which is the important function, followed by a\n**GetMessage() loop. Take note of the variable v3 and v4 – the NtTib access and savedregs**\nvariable seem fairly constant in most, if not all, functions, and have no major effect on the\nflow of the program, so it seems like this has simply been added during compilation by the\ncompiler. Similarly, the __writefsdword() calls also do not affect the program flow.\n\n\n-----\n\nThe important call (sub_4206A0()) simply calls timeSetEvent(), which will start a specified\n_timer event. The multimedia timer runs in its own thread. After the event is activated, it calls_\n_the specified callback function or sets or pulses the specified event object._\n```\nresult = timeSetEvent(a1, 0, (LPTIMECALLBACK)fptc, 0, 1u);\n\n```\nIn this case, the callback function has been named fptc, and will be executed by the call to\n**timeSetEvent. Stepping into this function, we finally get a wrapper of the main loader code,**\n\nAs we are analysing a Delphi based binary rather than C/C++, IDA can run into a few issues,\nsuch as not correctly setting the function end address, which can cause decompilation errors\nsuch as code blocks not appearing, or unused variables being inserted into decompiled\nblocks. In this function, you can see v8 is passed into the main_loader_func(), however it is\nnot declared anywhere else. In cases like this, it can be much easier to analyse the sample\nusing the disassembly graph view, as you are able to correctly trace back variables.\n\nPut simply, this function will get the file name, get the file age of the file, test the internet\nconnection by trying to connect to microsoft.com, before finally calling the\n**main_loader_func().**\n\n\n-----\n\nThe most important functions to look at inside this function are the sub_4202B0() and\n**deal_with_url_and_payload() functions. deal_with_url_and_payload() accepts 3**\narguments, with the first being some kind of hexlified string, and the second being the string\n_YAKUZA2020. The third argument is an output buffer, which the function will use for storing_\ndata. sub_4202B0() takes 2 arguments, however in this screenshot, IDA has failed to\ndecompile it correctly. The first argument is the same as the third argument for the previous\nfunction, which is v17 in this case. The second argument acts as another output buffer.\nBefore continuing, let’s step into deal_with_url_and_payload().\n\n\n-----\n\nAt first glance, this function only seems to convert the hexlified string to raw bytes, but this\nisn’t the case. If we jump to the disassembly view, we can see an entire block of code\nbetween return_string_len() and convert_char_code(), which involves an XOR operation.\nIn a nutshell, this function will loop through the hexlified string, taking 2 characters on each\nloop, and unhexlifying them. This is then XORed with a byte from the second argument,\n_YAKUZA2020, which is the decryption key. Once decrypted, the byte is then concatenated to_\nthe third argument, which is the output buffer. An example of this algorithm in Python can be\nseen below the images.\n\n\n-----\n\n-----\n\n```\ndef hex_decoder(data, key):\n     outbuf = \"\"\n     data = [int(data[i:i+2], 16) for i in range(0, len(data), 2)] \n     for i in range(0, len(data)):\n          current_byte = data[i]\n          key_byte = ord(key[i % len(key)])\n          outbuf += chr(current_byte ^ key_byte)\n     return outbuf\n\n```\n\n-----\n\nDecrypting the hex string results in a URL, which is passed into sub_4202B0(), AKA\n**grab_payload(). All this function does is connect to the remote server, and read the**\nresponse, storing it in the second argument. The function then returns.\n\nThe payload is stored in a similar hexlified fashion to the URL. After downloading, the sample\nwill flip the data, and proceed to decrypt it using the same method as before, and the same\nkey in this case.\n```\ndecoded_binary = hex_decoder(content[::-1], sample_key)\n\n```\nOnce downloaded and decrypted, the sample will allocate a region of memory, map the\ndownloaded second stage into that region, and then execute it.\n\n\n-----\n\nThis second stage is responsible for grabbing the main payload, which in many cases is\nFormBook. We will be diving into this second stage in the next post!\n```\nIOCs (MD5):\n  Packed Sample: B30459D88F2E3146E248763643FF86EF\n  C2:\nhxxps://cdn[.]discordapp[.]com/attachments/732298690575990898/740083604071251978[/]Ruy\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-08-20 - DBatLoader-ModiLoader Analysis – First Stage.pdf"
    ],
    "report_names": [
        "2020-08-20 - DBatLoader-ModiLoader Analysis – First Stage.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535885,
    "ts_updated_at": 1743041128,
    "ts_creation_date": 1653688864,
    "ts_modification_date": 1653688864,
    "files": {
        "pdf": "https://archive.orkl.eu/e15eb02a5e7874d5f34e48ea418f55e80326adee.pdf",
        "text": "https://archive.orkl.eu/e15eb02a5e7874d5f34e48ea418f55e80326adee.txt",
        "img": "https://archive.orkl.eu/e15eb02a5e7874d5f34e48ea418f55e80326adee.jpg"
    }
}