{
    "id": "aba96225-764d-47ba-9825-4716be765ea5",
    "created_at": "2023-01-12T15:00:11.151627Z",
    "updated_at": "2025-03-27T02:05:21.346645Z",
    "deleted_at": null,
    "sha1_hash": "aa8a3395a4e9d6613fc46feff889105b0bb1f779",
    "title": "2022-02-11 - Netwalker- from Powershell reflective loader to injected dll",
    "authors": "",
    "file_creation_date": "2022-05-27T21:16:41Z",
    "file_modification_date": "2022-05-27T21:16:41Z",
    "file_size": 1364482,
    "plain_text": "# Netwalker: from Powershell reflective loader to injected dll\n\n**[0x00-0x7f.github.io/Netwalker-from-Powershell-reflective-loader-to-injected-Dll/](https://0x00-0x7f.github.io/Netwalker-from-Powershell-reflective-loader-to-injected-Dll/)**\n\n0x00-0x7F blog February 11, 2022\n\nHi! I have lately started delving into maliious powershell payloads and came across a really intriguing\n[powershell loader for “Netwalker ransomware”, performing fileless attack. Fileless techniques enable attackers](https://labs.sentinelone.com/netwalker-ransomware-no-respite-no-english-required/)\nto directly load and execute malicious binary in memory without actually storing it on disk by abusing available\nlegitimate tools on victim machine. Such threats leave no trace of execution and are capable of evading any\ntraditional security tools. This post thoroughly discusses how first stage powershell script filelessly loads and\nexecutes embedded payload through reflective Dll injection.\n\nSHA-256 hash of the sample being analyzed:\n[f4656a9af30e98ed2103194f798fa00fd1686618e3e62fba6b15c9959135b7be](https://bazaar.abuse.ch/download/f4656a9af30e98ed2103194f798fa00fd1686618e3e62fba6b15c9959135b7be/)\n\nPrior knowledge required:\n\nBasic Powershell understanding\nusing .NET reflection to access Windows API in PowerShell\nWindows APIs for Process/Dll injection\n\nThis is around ~5 MBs of powershell script using three layers of encoding, encryption and obfuscation\nrespectively to hide ransomware dll and supporting powershell commands for reflective Dll injection. The\nuppermost layer executes very long base64 encoded command (screenshot covers only a small portion of this\ncommand)\n\n## Processing Base64 encoded layer 1\n\nIn order to get decoded output from initial script, I shall run powershell script into my VM’s Powershell ISE but\nas the Invoke-Expression cmdlet will process base64-encoded payload and execute the ransomware therefore,\nI’ll modify the script for debugging by replacing this comdlet with a variable to store result of base64 decoded\ncommand and dump output in a file as shown in the figure below\n\n## Processing Encrypted layer 2\n\n\n-----\n\nbase64 decoded second layer once again contains a very long bytearray in hex format which is processed in\ntwo steps\n\n1) bytearray contents are decrypted in a for loop with 1 byte hardcoded xor key\n\n2) decrypted contents are stored as ASCII string in another variable in order to be able to create scriptblock for\ndecrypted contents and execute it using Invoke-Command cmdlet\n\nbut I shall also modify second layer to get decrypted layer three contents and dump result into another output\nfile as shown in the figure below\n\n\n-----\n\ndecryptedlayer3.ps1 now contains the obfuscated layer three powershell script embedding ransomware dlls in\nbytearrays and other commands to process the malicious payload\n\n## Processing Obfuscated layer 3\n\nLet’s start digging into layer three powershell script which is quite obfuscated having lengthy and random string\nvariable and routine names responsible to drop final payload. It is required to perform following steps in order to\nexecute Netwalker ransomware on victim’s machine\n\ndefine variables to invoke in-memory Windows API function calls without compilation\ndefine routines to load dll without using Windows loader\ndetect environment\nget PID of a legitimate process from a list of running processes and inject payload via custom loader\ndelete shadow copies\n\nFirst off, it defines required variables and routines:\n\n**to invoke in-memory Windows API function calls without compilation, C# code to declare structs and**\nenums for memory manipulation is defined inside a variable as shown below\n\nand to invoke kernell32.dll APIs using wrapper .Net methods available in powershell\n\n\n-----\n\nfinal command in this case will let us instantiate objects by making Microsoft .Net core classes available in our\npowershell session and ensure ransomware’s true memory residence through reflection.\n\nFollowing set of routines help correctly compute required memory addresses and relocations by casting\ninteger datatypes (signed integers to Unsigned integers and vice versa) so that the script could act as its own\ncustom loader and load dll without using Windows loader\n\nFinally it defines a bunch of routines to write embedded malicious binary into another process’s memory and\nexecute it.\n\nScript starts its execution by detecting underlying processor’s architecture to know whether it is running on x86\nor amd64 and to prepare 32-bit or 64-bit dll accordingly using following if-else block\n\n\n-----\n\n```\n[ y []]$ $p q\n$aukhgaZFiPJBarSpJc = $false\nif ( ( Get-WmiObject Win32_processor).AddressWidth -eq 64 )\n{\n [byte[]]$EbihwfodUZMKtNCBx = $GxwyKvgEkr\n $aukhgaZFiPJBarSpJc = $true  \n if ( $env:PROCESSOR_ARCHITECTURE -ne 'amd64' )\n  {\n   if ($myInvocation.Line) \n     {\n      &\"$env:WINDIR\\sysnative\\windowspowershell\\v1.0\\powershell.exe\" -ExecutionPolicy ByPass NoLogo -NonInteractive -NoProfile -NoExit $myInvocation.Line\n     }\n   else\n     {\n      &\"$env:WINDIR\\sysnative\\windowspowershell\\v1.0\\powershell.exe\" -ExecutionPolicy ByPass NoLogo -NonInteractive -NoProfile -NoExit -file \"$($myInvocation.InvocationName)\" $args\n     }\n   exit $lastexitcode\n  }\n}\n\n```\nlater it allocates memory in current process’s address space and starts writing dll on the allocated memory\nusing following for loop\n```\nfor( $dxQpkwU = 0; $dxQpkwU -lt $TKgfkdkQrLMAN.KGcnFrQVhkckQriBC.nKkeCknfm; $dxQpkwU++ )\n{\n  $PdWhwldJHtQhtsMJe = [System.Runtime.InteropServices.Marshal]::PtrToStructure(\n$lItUIbvCvHxzMmrKtX,[Type][Fvh.wTEWKRjOqBX] )\n  $rZKYDiOJE = RBeMnMHvnbNEob $eIr $( ULhnbcyXERLvVtGXUp $PdWhwldJHtQhtsMJe.sUtYsMhA )\n  $MxyiIYGMhxakrDbKyjL = RBeMnMHvnbNEob $upEcLTMCGhc $( ULhnbcyXERLvVtGXUp\n$PdWhwldJHtQhtsMJe.cymIspbCOaY )\n  $mofiZSsnxylxNuA = $AaauDVCQMlKUXx::PMUN( $VxxHhZYpWSgsPvKNuDx, $MxyiIYGMhxakrDbKyjL, $rZKYDiOJE,\n$PdWhwldJHtQhtsMJe.mkvugoDzrJgTSSJp, [ref]([UInt32]0 ) )\n  if ( $mofiZSsnxylxNuA -eq $false )\n    {\n     return\n    }\n  $lItUIbvCvHxzMmrKtX = RBeMnMHvnbNEob $lItUIbvCvHxzMmrKtX\n$([System.Runtime.InteropServices.Marshal]::SizeOf([Type][Fvh.wTEWKRjOqBX]))\n}\n\n```\nsnapshot of object containig dll that gets written into current process’s memory\n\n\n-----\n\nafter that it calls following routine with certain parameters to inject payload by specifying a legitimate target\nprocess which is ‘explorer.exe’ in this case along with memory location pointer for buffer containg Dll and size\nof the buffer containing dll\n\nthis routine finds PID of explorer.exe form a list of running processes and passes obtained PID to final routine\n\n\n-----\n\nwhich first reflectively injects ransomware dll into explorer.exe by allocating a chunk of memory of specified size\ninto its address space and writing ransomware dll on the allocated memory and then executes it by creating a\nthread that runs in the virtual address space of Explorer.exe process\n\n\n-----\n\nand in the end deletes shadow copies of the data being held on the system at that particular time to completely\neliminate any possibility of recovering it and performs required memory cleanup using following set of\ncommands\n\nas soon as script exits, FE026B-Readme.txt window appears on the system with ransom message and all\nencrypted files with fe026b extension are no longer accessible\n\n**_Note: Ransomware dll being injected can be dumped into a binary file in powershell script, which has SHA-256_**\n_[302ff75667460accbbd909275cf912f4543c4fb4ea9f0d0bad2f4d5e6225837b hash but it can be seen that it is](https://www.virustotal.com/gui/file/302ff75667460accbbd909275cf912f4543c4fb4ea9f0d0bad2f4d5e6225837b/detection)_\n_64-bit PE file and first two bytes in this case have wrong hex value 0xDEAD_\n\n\n-----\n\nreplacng first two bytes 0xDEAD with 0x4D5A in DOS header in HxD editor would result in Netwalker\n[ransomware dll with f93209fccd0c452b8b5dc9db46341281344156bbedd23a47d2d551f80f460534 SHA-256](https://www.virustotal.com/gui/file/f93209fccd0c452b8b5dc9db46341281344156bbedd23a47d2d551f80f460534/detection)\nhash.\n\n## Deciphering Netwalker x86-64 DLL\n\nLet’s load final dll in IDA and perform basic static analysis first, I’ll start by looking up for strings, but they are\nmostly useless, moreover, it has only one export i.e., main entry which seems to implement all its functionality\n\nsecond important thing to note here is that it has no imports address table, which implies that it might be\nobfuscating APIs or strings with some hashing or encryption algorithm, this can be verified by loading the dll in\n**PEiD and looking for possible algorithms in its Krypto ANALyzer plugin which shows multiple references to**\ndifferent encoding, hashing and encrypt/decrypt algorithms in dll as shown in the figure below\n\n\n-----\n\nIf I randomly pick a CRC32 reference and look it up in dll, it is found in sub_180005D60 routine being used in a\nloop\n\n\n-----\n\ndo-while loop in decompiled routine shows CRC32 division flow\n\nlet’s rename this routine to crc32_checksum and look for its cross references, result shows it is cross\nreferenced two times in sub_180001000, if this routine is subsequently checked for further cross references, it\nshows ~165 references\n\n\n-----\n\nwe can assume here that the routine sub_180001000 being cross referenced ~165 times is possibly decrypting\nstrings, I’ll rename it to decrypt_strings\n\nnow let’s take a closer look at sub_180001490 routine which almost has all the Xrefs to decrypt_strings,\nfollowing code shows it is taking two arguments v1, which is being used in all of its calls and a 4-byte hex value\nwhich seems to be CRC32 hash and retrun value is being stored to different offsets of an array\n\n\n-----\n\nthis routine has multiple similar code blocks but with different hash values, here it can be assumed that it is\ndecrypting APIs from different libraries, let’s rename it to resolve_imports and look for its Xrefs which leads to\nDLL’s main DllEntryPoint routine - now it’s time to look into it dynamically.\n\nFirst routine that is being called by DLL is resolve_imports, which in turn calls sub_180001310 routine, it is\ntaking 0x84C05E40 hash value as parameter, a quick Google search shows it is for “ntdll.dll” which can also\nbe verified with Python\n\nthis routine returns handle for ntdll.dll library, later it takes another hash value 0xA1D45974 which is resolved\nto RtlAllocateHeap API, it is first called to allocate a block of memory on heap to later store resolved\naddresses there on different array indexes\n\nthis routine decrypts and resolves serveral APIs from ntdll.dll, kernel32.dll, advapi32.dll, use32.dll, mpr.dll,\n[shell32.dll, netapi32.dll, ole32.dll, oleaut32.dll and psapi.dll libraries. I wrote a simple IDAPython script here](https://github.com/0x00-0x7F/IDAPython_scripts/blob/master/netwalker_crc32hash_resolver.py)\nwhich resolves CRC32 hashes and adds resolved value in comment\n\n\n-----\n\nafter resolving imports, it continues to check for stomped MZ header 0xDEAD by first copying header value\n**0xDEAD in eax, setting up rbx with a certain address and later subtracting 0x400 from rbx in each iteration to**\nreach image’s base address as shown by the loop in figure below\n\nif 0xDEAD header value is intact (i.e., making sure DLL is being run injected in explorer.exe), it continues\nfurther to fix MZ header in memory and read image’s resources - otherwise it’ll throw ACCESS_VIOLATION\nexception and exits\n\n\n-----\n\nafter required resource has been loaded in memory, sub_18000EAF0 routine processes it by first extracting\nfirst 4 bytes of data which is probably length of key, next 7 bytes (cZu-H!<) are extracted as RC4 key which is\nbeing used to decrypt rest of the payload - following code from sub_18000EAF0 routine implemets 3\nrecognizable RC4 loops 1. Initialization (creating Substitution Box) 2. **Scrambling Substitution box with key**\nto generate a pseudo-random keystream 3. **xoring keystream with rest of the data**\n\n\n-----\n\ndecrypted data seems to be malware’s embedded configuration in json format\n\n\n-----\n\nthis can also be verified by copying resource as hex string along with 7-byte hex key on Cyberchef\n\nnext routine sub_180004600 parses configuration to get list of file extensions which needs to be encrypted,\ndefault paths and files that should be whitelisted, attacker’s ToR info and ransomware note along with\nransomware note file name and format, subsequent routines decrypt ransom note with AES decryption\nalgorithm by using 256-bit hardcoded key, checks running processes to kill any blacklisted process and\neventually performs ransomware activity.\n\nThat’s it. See you next time.\n\n**Sources:**\n\n\n-----\n\n1. https://blog.trendmicro.com/trendlabs security intelligence/netwalker fileless ransomware injected via\n\nreflective-loading/\n2. https://any.run/report/f4656a9af30e98ed2103194f798fa00fd1686618e3e62fba6b15c9959135b7be/ca44ad38\n0e46-455e-8cfd-42fb53d41a1d\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-02-11 - Netwalker- from Powershell reflective loader to injected dll.pdf"
    ],
    "report_names": [
        "2022-02-11 - Netwalker- from Powershell reflective loader to injected dll.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535611,
    "ts_updated_at": 1743041121,
    "ts_creation_date": 1653686201,
    "ts_modification_date": 1653686201,
    "files": {
        "pdf": "https://archive.orkl.eu/aa8a3395a4e9d6613fc46feff889105b0bb1f779.pdf",
        "text": "https://archive.orkl.eu/aa8a3395a4e9d6613fc46feff889105b0bb1f779.txt",
        "img": "https://archive.orkl.eu/aa8a3395a4e9d6613fc46feff889105b0bb1f779.jpg"
    }
}