{
    "id": "f15784c1-5d48-4f2d-981c-275f7462d5b0",
    "created_at": "2023-01-12T15:08:21.041604Z",
    "updated_at": "2025-03-27T02:05:26.433313Z",
    "deleted_at": null,
    "sha1_hash": "fd4ff1735e5a8f22b7fda11e813d1d1255cd217e",
    "title": "2020-07-24 - Fifty Shades of Malware Strings",
    "authors": "",
    "file_creation_date": "2022-05-28T18:24:58Z",
    "file_modification_date": "2022-05-28T18:24:58Z",
    "file_size": 118286,
    "plain_text": "# Fifty Shades of Malware Strings\n\n**[medium.com/@tom_rock/fifty-shades-of-malware-strings-d33b0c7bee99](https://medium.com/@tom_rock/fifty-shades-of-malware-strings-d33b0c7bee99)**\n\nThomas Roccia July 27, 2020\n\nTho\nmas\n\n\n[Thomas Roccia](https://tomrocc.medium.com/?source=post_page-----d33b0c7bee99--------------------------------)\n[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F5a9c04d74995&operation=register&redirect=https%3A%2F%2Fblog.securitybreak.io%2Ffifty-shades-of-malware-strings-d33b0c7bee99&user=Thomas+Roccia&userId=5a9c04d74995&source=post_page-5a9c04d74995----d33b0c7bee99---------------------follow_byline-----------)\nJul 24, 2020\n\n\n9 min read\n\nWhen analysing malware, string extraction is one of the first things to do to briefly extract useful\ninformation such as IP address, domains, functions, data, or any other information that has not\nbeen removed by the developer.\n\nA string is a sequence of characters, it can be a constant or a variable. A string is a type of data\nand can be implemented as a byte (or word) data structure that stores a sequence of elements.\nStrings are inherent in computer programming, they are basically valuable data that is used to\ncreate software and, in turn, to get clues about functionality during reverse engineering.\n\nIn threat intelligence, using strings to detect a piece of malware with Yara is also a powerful\nmethod to scan for new malware and detect threats. This is also very useful when tracking a\ngroup of attackers.\n\nIn the previous post [‚ÄúFifty Shades of Malware Hashing‚Äù, we discussed the hashing mechanisms](https://medium.com/@tom_rock/fifty-shades-of-malware-hashing-3783d98df59c?source=friends_link&sk=c3f3ed798e0c087eeb1d368868462724)\nused to identify and classify malware. In this article, we will explore the process of extracting\nstrings in malware, understand how it works, and how you can leverage it in your daily analysis.\n\n## Character Encoding\n\nIn real life there are several languages  and they are written with different characters/alphabet.\nComputers were originally programmed to work with the English language without accents or\nsymbols. But later, modern computer quickly spread and reached other countries and hence the\nneed to use other languages  with different characters such as ‚Äú≈ì‚Äù or ‚Äú√©‚Äù in French, the ‚Äú√±‚Äù in\nSpanish or other characters used in Greek, Cyrillic, Arabic, Korea, Chinese, Japan and many\nothers‚Ä¶\n\nTo handle this different semantics, computers must use a table that stores this information in\norder to have the correct encoding.\n\n## ASCII\n\n\n-----\n\nAmerican Standard Code for Information Interchange (ASCII) is a character-encoding scheme\nand was the first character encoding standard. It represents English character as numbers\nbetween 0 and 127.\n\nThe below table shows the ASCII table.\n\nASCII Table\nEach character, number, or special character is represented by a 7-bit number. Most modern\nprograms still use ASCII and support additional encoding.\n\n\n-----\n\nANSI later extended it to 8 bits and there are several different code pages for symbols 128 to\n255. It is basically an extension of the ASCII character set in that it includes all ASCII\ncharacters with additional codes of 128 characters.\n\n## Unicode\n\nTo handle all the languages  of the world, Unicode was created. It is a standard for character\nencoding. Unicode also supports ASCII and essentially extends the character encoding for\neach language.\n\nIt basically defines a huge table of 1 114 112 [code point, which can be used for all kinds of](https://en.wikipedia.org/wiki/Code_point)\n[letters and symbols. All languages  are currently references using code pages.](https://en.wikipedia.org/wiki/Code_page)\n\n[The full table of Unicode can be found here: https://home.unicode.org/.](https://home.unicode.org/)\n\n## Unicode Transformation Format (UTF)\n\nUnicode assigns a unique number (code point) to each character. To map characters to a code\npoint the Unicode standard includes UTF-8, UTF-16, and UTF-32.\n\nThe three methods are simply different ways of representing Unicode codes with different byte\nsizes.\n\n\n-----\n\nExample of Code Point\nThere are other encodings, but this will be left to the reader for personal research.\n\n## Punycode\n\nInterestingly, in 2020 we don‚Äôt just communicate with letters and words, we also use emoji. For\nexample, we regularly use this one when we are happy: üôÇ or this one when we are sad: üò≠\nand even this one: üëç to show that we agree‚Ä¶ In fact, there is a whole list of emojis that can be\nused to extend and express our feelings with computers.\n\nThe below diagram shows the most used emoji.\n\n\n-----\n\n[Even domain names can use emoji today using punycode. Punycode is a way to convert](https://en.wikipedia.org/wiki/Punycode)\nencoded strings containing Unicode characters for Internet hostnames.\n\nThe example below is an example of a punycode using emoji for a hostname.\n\n\n-----\n\nPunycode Example\nPunycode can also be used for phishing, because some characters may have a similarity to the\nusual English alphabet, attackers can take advantage of using Unicode characters to appear as\n[a legitimate website. This attack is known as IDN homograph attack.](https://en.wikipedia.org/wiki/IDN_homograph_attack)\n\nThe below example shows an example with the ‚Äú·∫°‚Äù instead of the ‚Äúa‚Äù.\n\n\n-----\n\nIDN Homograph Attack\nThis type of attack can be easily set up and users who are not careful can fall into the trap.\n\n[To detect IDN homograph attack, the python script MyLittlePuny can check domain names that](https://github.com/theMiddleBlue/myLittlePuny)\ncan be used. In the screenshot below we can see the use of the script for facebook.com with\nthe letter ‚ÄúA‚Äù.\n\n\n-----\n\nMyLitlePuny on Facebook Domain\n\n## Strings for Threat Intelligence\n\nNow that we know a little more about how character encoding works in modern computers, we\nwill discuss in this section how we can take advantage of it for threat research.\n\n## Strings\n\nThe tool Strings is one of the most used tool when analysing malware. It allows the analyst to\nquickly identify the sequence of characters that can be useful in identifying features, or any\nother variable used by the malware.\n\n\n-----\n\nStrings is a native tool built into any Linux system. A Windows version is available and on Mac\nOSX, strings is available in the Xcode Command Line Tools package.\n\nBelow is the default output of strings.\n\nStrings Help\nTo extract printable characters from a given file, you can use strings without any options.\n\nThis will provide the following output:\n\n\n-----\n\nStrings Extraction\nYou will notice a lot of junk bytes among the output with interesting results. Not all strings found\nby the tool are valid strings, they can be a memory address, CPU instructions, or data used by\nthe program. In this case, we can spot the information that refers to a keylogger.\n\nIt is also possible to extract strings with a specific encoding with the ‚Äú-e‚Äù option.\n\n\n-----\n\nStrings -e b\nIn this case, we extract the information in UTF-16 which prints additional information not\npresent in the default execution of the strings.\n\n## Strings Obfuscation\n\nMalware writers know that analysts look at strings. To avoid rapid identification, they sometimes\nuse obfuscation to hide data in a binary. XOR encryption, base64, or some other mechanisms\nare used in most samples to hide content, making the output of strings useless. Analysing\nobfuscated strings can take a long time.\n\nThe tool [FLOSS, provides a handy tool to quickly identify obfuscated strings in a binary.](https://github.com/fireeye/flare-floss)\n\n\n-----\n\nBasically the tool will try to detect the decoding routines and emulate the code to extract the\ndecoded strings. Although it does not always detect interesting strings, in some cases the tool\nis able to extract very relevant information.\n\nIn the screenshot below we can see the strings decoded using FLOSS in the sample\n304cceff9d29e8f879124f183337b28ffd7c28e2.\n\nFLOSS Decoded Function\nHere you may notice some useful information like cmd.exe commands to run a dll, registry key\nchange and also HTTP request which may indicate behaviour of the sample.\n\n## Using Strings with Graph Theory\n\n\n-----\n\nIn malware research, it can be useful to extract strings and compare them in a large dataset to\nidentify similar samples or similar variables used. Graph theory will make it possible to use this\ndata and put it in a graph to show the connection between a list of samples.\n\nTo compare the similarity within the samples, it is possible to use a similarity algorithm such as\nthe Jaccard index. The Jaccard index is a statistic used to understand the similarities between\nsets of samples.\n\nUsing string extraction with multiple malware and creating a set that will be compared with the\nJaccard distance and written in a graph can quickly help research to understand the connection\nbetween multiple samples.\n\nThe example below demonstrates this concept for the Dtrack malware family.\n\n\n-----\n\nStrings Correlation\nIn this screenshot, we can directly identify malware using the same strings and thus spot the\nsimilarities between the different variants.\n\nIt is also possible to apply this same concept to extract a single strings and identify the samples\nthat use it. In the example below, we apply this concept by extracting a well-known string used\nin several samples as a password: ‚Äúdkwero38oerA^t@#‚Äù.\n\n\n-----\n\nSingle String Extraction\nIn no time we were able to expose samples using the same strings. To generate these graph I\ncreated a Jupyter Notebook that explains and demonstrates the process\n[https://github.com/fr0gger/strings_similarity.](https://github.com/fr0gger/strings_similarity)\n\nExtracting strings and comparing them to plot them in a graph is very powerful for sorting\nmalware and identifying strings sharing. Of course, this method has limitations and packed\nsamples will not provide any useful information. This is why it is very important to clean your\ndataset first.\n\n## Leveraging Strings for Powerful Yara Rules\n\n\n-----\n\nYara is one of the most powerful tools to hunt for malware using strings. The goal of yara is\nbasically to create a rule that will detect the strings previously identified when scanning for\nmalware.\n\nTo write a good yara rule, the first step is to identify unique strings in the binary. Meaning strings\nthat are not common or that are specific to the binary you are currently analysing.\n\nTo create your own Yara rule, you can for example use a registry key with specific values\nrelated to a sample, PDB path, certificates, mutex, filename, specific encoder habits or even\nencrypted strings. It is also worth adding condition corresponding to the file format such as size,\nentropy or even sections.\n\nThe example below demonstrates some use.\n```\nrule Rule_Example {  meta:    description = \"Rule example\"        author =\n\"@fr0gger_\"        date = \"2020\"        rule_version = \"v_\"       \nactor_type = \"\"        hash1 = \"\"  strings:    $s1 = ‚Äúdkwero38oerA‚Äù wide\nascii    $s2 = ‚ÄúCCS_‚Äù nocase    $s3 = ‚Äú%02X:%02X:%02X:%02X:%02X:%02X‚Äù ascii\nfullword    $hex1 = { E2 34 A1 C8 23 FB }    $hex2 = { F4 23 [4-6] 62 B4 }   \n$xor1 = \"This program cannot\" xor    $xor2 = \"This program cannot\" xor(0x01-0xff)  \n$b64 = \"This program cannot\" base64    $re = /md5: [0-9a-fA-F]{32}/  condition:  \nuint16(0) == 0x5a4d and filesize < 2000KB and (3 of $s* or     any of $hex* or any\nof $xor* and $b64 and $re)}\n\n## Limitations\n\n```\nThe use of string extraction is very powerful, but there are some limitations. For example, if your\nbinary is packed or obfuscated, the string extraction won‚Äôt really reflect the binary you are\nanalysing but rather the packing or obfuscation routines used to hide sensitive data.\n\nEven if samples are packed, it is very useful to check the contents for a first look. Analysing\npacked samples doesn‚Äôt mean you can‚Äôt leverage strings for malware hunting, but you should\nconsider this before you continue your research. It will of course be possible to search for these\nspecific packing routines, and this can be powerful if several samples use the same algorithm.\n\nAdditionally, some malware authors will bind the binary to legitimate software, resulting in more\nstrings that will generate false positives when using it with Yara rules.\n\n## Conclusion\n\nIn this blog post, we explored the string extraction process used when analysing malware. We\nhave seen that multiple encoding can be used in a modern computer for different purposes. We\nhave also seen that extracting strings from a malware can be very powerful for quickly\nidentifying its capabilities as well as for further research. It is also possible to combine string\nextraction with graph theory to generate diagrams and expose proofs of similarities between\nmultiple samples.\n\n\n-----\n\nEven though extracting strings is one of the first steps in malware analysis, it is crucial to know\nthe limits and understand that malware authors will obfuscate, hide, or trick the strings inside\nthe binary to counter the analysis. As a malware researcher, you should keep this in mind\nduring your analysing and research process.\n\nI hope you enjoyed this blog, if you like this content you can follow me on Twitter [@fr0gger_ for](https://twitter.com/fr0gger_)\nmore stuffs such as this one. ‚ù§\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-07-24 - Fifty Shades of Malware Strings.pdf"
    ],
    "report_names": [
        "2020-07-24 - Fifty Shades of Malware Strings.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536101,
    "ts_updated_at": 1743041126,
    "ts_creation_date": 1653762298,
    "ts_modification_date": 1653762298,
    "files": {
        "pdf": "https://archive.orkl.eu/fd4ff1735e5a8f22b7fda11e813d1d1255cd217e.pdf",
        "text": "https://archive.orkl.eu/fd4ff1735e5a8f22b7fda11e813d1d1255cd217e.txt",
        "img": "https://archive.orkl.eu/fd4ff1735e5a8f22b7fda11e813d1d1255cd217e.jpg"
    }
}