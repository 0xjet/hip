{
    "id": "e51199b6-2fa5-429b-8504-0d58e7d04f02",
    "created_at": "2023-01-12T15:10:46.938579Z",
    "updated_at": "2025-03-27T02:06:01.988777Z",
    "deleted_at": null,
    "sha1_hash": "3a2b16960385d7c646b0271762b63ed7fdc37458",
    "title": "2022-11-19 - Malicious Packer pkr_ce1a",
    "authors": "",
    "file_creation_date": "2022-11-28T19:11:14Z",
    "file_modification_date": "2022-11-28T19:11:14Z",
    "file_size": 4109108,
    "plain_text": "# Malicious Packer pkr_ce1a\n\n**[malwarology.substack.com/p/malicious-packer-pkr_ce1a](https://malwarology.substack.com/p/malicious-packer-pkr_ce1a?r=1lslzd)**\n\nMalwarology LLC\n\n### First Stage\n\n## Summary\n\nThis [packer has been observed delivering a wide variety of malware families including](https://github.com/MBCProject/mbc-markdown/blob/master/anti-static-analysis/software-packing.md)\n[SmokeLoader and](https://malpedia.caad.fkie.fraunhofer.de/details/win.smokeloader) [Vidar among many others. It has been observed in the wild going back a](https://malpedia.caad.fkie.fraunhofer.de/details/win.vidar)\nnumber of years potentially to 2017. The particular variant of the packer analyzed here\ncontains two sets of bytes with no apparent use which occur on either side of values that are\nintegral to the decoding and unpacking process. These two byte strings are stable across\nmany months of observed samples of this packer. What follows is a detailed analysis of the\nfirst stage of one sample of this packer which delivers a SmokeLoader payload. Until a\nwidely recognized name or identifier can be determined for this packer, it has the designation\n```\npkr_ce1a .\n\n## Identification\n\n```\nThis sample has two known filenames. The first, `6523.exe, is observed in the wild in the`\npath component of the URL used to distribute the file.1 The second, `povgwaoci.iwe, is`\nlocated in the `RT_VERSION resource within the` `VS_VERSIONINFO structure in a field`\nnamed `InternationalName . This field along with others in the same StringTable structure`\n[are not parsed by Exiftool or](https://exiftool.org/) [Cerbero Suite. This indicates that the structure is malformed or](https://cerbero.io/ea/)\nnon-standard.\n\nMalwarology Research is a reader-supported publication. To receive new posts and support\nmy work, consider becoming a free or paid subscriber.\n\nAccording to AV detection results, the correct identification of the unpacked file,\n_SmokeLoader, does appear. There is also one detection based on dynamic analysis:_\n_Zenpack._\n\nThe import hash of this sample is shared by a group of other files.2 However, the large\nmajority of imported functions are called in dead code located after opaque predicates.\nTherefore, the usefulness of this import hash is almost nothing. Closer analysis of the\nopaque predicates in this sample can be found below.\n\n## Behavioral and Code Analysis Findings\n\n\n-----\n\n## Build Analysis\n\nAccording to the File Header, the timestamp of compilation is 2022-02-16T10:14:32Z. The\nlinker version found in the PE32 Optional Header is 9.0.\n\nLinker Version 9.0\nThe compiler is identified as Visual Studio 2008 Release according to function signatures in\nGhidra that match a number of library functions in the sample. One example of this detection\nfor the `___security_init_cookie function is shown in the figure below.`\n\nCompiler Detection: Visual Studio 2008 Release\nThe majority of the library functions found in the sample are from Microsoft Visual C++\n_9.0.21022. This is identified in the sampleâ€™s rich signature._\n\n\n-----\n\nRich Signature: VC++ 9.0.21022\n\n## Main Function\n\nMain Function\n[The instructions highlighted in yellow in the figure above are examples of junk code insertion.](https://github.com/MBCProject/mbc-markdown/blob/master/anti-static-analysis/executable-code-obfuscation.md#:~:text=analysis%20visually%20harder.-,Junk%20Code%20Insertion,-B0032.007)\nThese are dummy instructions that are placed between relevant instructions with the goal of\nmaking signature development more difficult. The instructions at the end of the function\nhighlighted in white are not executed. These highlight colorings are used throughout the\nscreenshots of this analysis.\n\n\n-----\n\nThe first instructions in the main function calculate the size of the encoded data that contains\nthe shellcode which is the next stage of the packer. The first part is read from a constant in\nthe `.data section at address` `0x41cc3c . The second part is hardcoded in the main`\nfunction at address `0x406573 . The size is calculated in the next instruction by adding the`\ntwo parts together. The resulting size is written to a variable in the `.data section.`\nHighlighted in the figure below are the bytes before and after the first constant. These two\nsets of bytes are not read during the execution of the packer, and their purpose is unknown.\nHowever, they are stable across builds of this packer going back for months at least.\n\nStable Surrounding Bytes\nThe address where the encoded data is located goes through a similar process. The first part\nis read from the `.data section then written to a variable in the same section. The addition`\nto the second part does not occur until later in the `unpack_shellcode function. The bytes`\nsurrounding this part are shown in the figure below.\n\nStable Surrounding Bytes\nThe next set of instructions handles loading `kernel32.dll and resolving the address of`\n\n`LocalAlloc` .3 These instructions taken together are unique to this packer and shared\nacross hundreds of variants. The stray instruction at address `0x406588 is part of the`\n[previous logical grouping of instructions. This is an example of interleaving code that is](https://github.com/MBCProject/mbc-markdown/blob/master/anti-static-analysis/executable-code-obfuscation.md#:~:text=to%20confuse%20disassembler.-,Interleaving%20Code,-B0032.014)\nmeant to make signature development more difficult.\n\nResolve `LocalAlloc`\n\n\n-----\n\nThe call to `LocalAlloc is obfuscated by calling it from the` `eax register. This is a type of`\nfunction call obfuscation. The `uBytes parameter to the function is 63072 bytes which is the`\nresult of the calculation described above.\n\nObfuscated Call to `LocalAlloc`\nThe final instructions in the main function are calls to other malicious functions and finally a\ncall to the entry point of the decoded shellcode. The next stage of the packer starts after that\ncall.\n\n## Change Protection Function\n\n\n-----\n\nChange Protection Function\nThis function is a wrapper around an obfuscated call to `VirtualProtect . Starting at`\naddress `0x4058e3 and continuing until the call to` `GetProcAddress, the name of the`\nfunction `VirtualProtect is written character-by-character, out of order, to a variable in the`\n```\n.data section. Building the function name in this way is an example of variable\n\n```\nrecomposition. The address of this string is then used as the `lpProcName parameter to`\n```\nGetProcAddress . Finally, a call is made to VirtualProtect to change the protection\n\n```\nfrom `PAGE_READWRITE ( 0x4 ) to` `PAGE_EXECUTE_READWRITE ( 0x40 ) thus enabling`\nexecution in the newly allocated memory.\n\n\n-----\n\nThe `flNewProtect parameter to the` `VirtualProtect function is also obfuscated by`\nadding together `0x20 and` `0x20 . This hides the` `PAGE_EXECUTE_READWRITE flag of`\n\n`0x40 from being located near the call to` `VirtualProtect . This is a form of` argument\nobfuscation.\n\nObfuscated New Protect Value\n\n## Unpack Shellcode Function\n\nThis function performs three actions that are interspersed with anti-analysis code. The first\naction is moving the encoded data from its starting location in the `.data section to the`\nnewly allocated memory.\n\nMove Encoded Data\n\n\n-----\n\nNote the instructions at addresses `0x405aa7 and` `0x405acd . These are both` opaque\npredicates. An opaque predicate appears to be a conditional jump, but the conditions can\nonly be met in one way making the jump effectively unconditional. The one at the top is\nbasically a fake: it never jumps. The one in the middle always jumps. This one additionally\n[encloses a block of dead code. This packer very frequently couples dead code insertion with](https://github.com/MBCProject/mbc-markdown/blob/master/anti-static-analysis/executable-code-obfuscation.md#:~:text=.%20%5BNEEDS%20REVIEW%5D-,Dead%20Code%20Insertion,-B0032.003)\nopaque predicates that always jump over the dead code. The function calls in the dead code\nare included in the import table making identification via import hash of little utility.\n\nLater on in this function is the call to the `decode function. After that is a call to a function`\nwhich shifts the pointer to the decoded shellcode. The shift changes the offset from the start\nof this data to the location of the shellcode original execution point (OEP). Because the\nshellcode is position independent, this OEP is also offset zero of the shellcode. Both of these\nfunctions are analyzed in more detail below.\n\nThe `shift_shellcode_oep function is additionally wrapped in an anti-emulator loop which`\nhas a very high number of iterations. This slows processing in an emulator which can\npotentially cause a timeout and an analysis failure.\n\nDecode and Shift Shellcode OEP Functions\nNote the comparison instruction at address `0x406486 . During the anti-emulation loop, the`\ncall to `shift_shellcode_oep is made once when the counter reaches` `0x770e . This is a`\ntype of anti-emulation circumvention countermeasure. A basic method for circumventing\nextremely long loops that target emulators is to patch out the loop. Another is to detect the\nloop in the emulator and then modify the counter to leave the loop. Because the shift function\nis called once at a point in the loop, either of these circumventions could end up not\nexecuting this function and would leave the emulator unable to execute the shellcode\ncorrectly.\n\n\n-----\n\nThe `unpack_shellcode function overall contains ten opaque predicates primarily of the`\nsame type shown above. One of them is slightly different in that it creates a dead end filled\nwith dead code. The last instruction in the dead end is a call to `terminate . Therefore, this`\nappears to be a location where the execution of the packer ends.\n\nOpaque Predicate with Dead End\nThere are a total of four anti-emulation loops similar to the one analyzed above. Two of these\nwrap opaque predicates which in turn wrap inserted dead code. One, however, in addition to\nwrapping two opaque predicates, also contains two additional anti-emulator behaviors. Both\n[of these are calls to unusual APIs:](https://github.com/MBCProject/mbc-markdown/blob/master/anti-behavioral-analysis/emulator-evasion.md#:~:text=non%2Dexhaustive%20emulators.-,Unusual,-/Undocumented%20API%20Calls) `GetGeoInfoA and` `GetSystemDefaultLangID . During`\nanalysis, [Qiling emulator halted with an exception because neither of these API calls have](https://github.com/qilingframework/qiling)\nbeen implemented.\n\nAnti-Emulation: Unusual API Calls\nIn the very first code block of the `unpack_shellcode function, a new and subsequently`\nunused exception handler is registered. Chances are about even that this is an antiemulation behavior or it is just junk code. If it is anti-emulation, it is targeting older emulators\n[based on specific versions of Unicorn Engine which do not implement access to the](https://github.com/unicorn-engine/unicorn)\n\n\n-----\n\nWindows Thread Information Block (TIB). Moving the contents of `fs:0x0 as happens at`\naddress `0x405983 would fail in that particular environment. This type of anti-emulation is`\nan [unimplemented opcode.](https://github.com/MBCProject/mbc-markdown/blob/master/anti-behavioral-analysis/emulator-evasion.md#:~:text=emulators%20give%20up.-,Undocumented%20Opcodes,-B0005.002)\n\nRegister New SEH\nIn the last block of the `unpack_shellcode function, before the return, the SEH is reset`\nback to the previous handler. This occurs right after a junk call to `LoadLibraryW from`\nwhich no functions are subsequently resolved.\n\nLast Block of `unpack_shellcode`\n\n## Decode Function\n\n\n-----\n\nDecode Function (Truncated)\nThe data is decoded in chunks. So this function has three basic purposes: convert the\nencoded shellcode size to a chunk count by dividing by 8, wrapping a loop around the call to\nthe `decode_chunk function, and then calling that function. In the middle of this function is a`\nvery large insertion of dead code wrapped by an opaque predicate. This is highlighted in\nwhite in the figure above. It has also been truncated for the screenshot. There are two\n[locations in this function with junk code insertion which impedes signature development: at](https://github.com/MBCProject/mbc-markdown/blob/master/anti-static-analysis/executable-code-obfuscation.md#:~:text=analysis%20visually%20harder.-,Junk%20Code%20Insertion,-B0032.007)\naddresses `0x4057c1 and` `0x4057cc .`\n\nThe chunks are 8 bytes long, therefore at the end of the loop after the call to\n```\ndecode_chunk, 8 is added to the chunk pointer then the chunk count is decremented by\n\n```\none.\n\n\n-----\n\nChunk Decode Loop Control\n\n## Decode Chunk Function\n\n\n-----\n\nDecompiled Decode Chunk Function\nThe `decode_chunk function has four opaque predicates that each wrap dead code, and`\nthere are two locations with junk code insertion. In addition to these, the logic of the function\nis quite convoluted. However, after patching out all of the opaque predicates, dead code, and\njunk code, a cleaner decompilation graph can be analyzed. The figure above is that graph,\nfully annotated and cleaned up.\n\n\n-----\n\nThere are three tiny functions called during the decoding algorithm: `load_data_keyB,`\n```\nadd_key4, and, xor_mix . These simply isolate small pieces of the algorithm to impede\n\n```\nanalysis and make signature development more difficult.\n\nAlgorithm Isolates\n\n## Shift Shellcode OEP Function\n\nShift Shellcode OEP Function\nThe `shift_shellcode_oep function is very simple. It adds` `0x3bf1 to the address of the`\nstart of the decoded shellcode in allocated memory. This shifts the pointer from the start of\nthe decoded data to the offset of the OEP. This is the address that is called in the main\nfunction.\n\n\n-----\n\n## Recommendations\n\nThis packer is polymorphic. Variants and builds share many of the same functionality,\nbehavior, and code features. However, they are in different order with randomization of\nopaque predicates, junk code, and dead code. In spite of this, detection can be achieved by\nfocusing on the two stretches of stable bytes which were identified above. The following two\nYARA rules match these bytes.\n```\nrule Packer_pkr_ce1a_ShellcodeSizePart\n\n{\n\n  meta:\n\n    author = \"Malwarology LLC\"\n\n    date = \"2022-10-14\"\n\n    description = \"Detects bytes surrounding the first part of the data size of\nthe second stage shellcode in Packer pkr_ce1a.\"\n\n    reference = \"https://malwarology.substack.com/p/malicious-packer-pkr_ce1a\"\n\n    sharing = \"TLP:CLEAR\"\n\n    exemplar = \"fc04e80d343f5929aea4aac77fb12485c7b07b3a3d2fc383d68912c9ad0666da\"\n\n    address = \"0x41cc3c\"\n\n    packer = \"pkr_ce1a\"\n\n  strings:\n\n    $a = { 00699AF974[4]96AACB4600 }\n\n  condition:\n\n    $a and\n\n    uint16(0) == 0x5A4D and\n\n    uint32(uint32(0x3C)) == 0x00004550\n\n}\nrule Packer_pkr_ce1a_ShellcodeAddrPart\n\n{\n\n  meta:\n\n    author = \"Malwarology LLC\"\n\n    date = \"2022-10-17\"\n\n    description = \"Detects bytes surrounding the first part of the address of the\nsecond stage shellcode in Packer pkr_ce1a.\"\n\n    reference = \"https://malwarology.substack.com/p/malicious-packer-pkr_ce1a\"\n\n    sharing = \"TLP:CLEAR\"\n\n    exemplar = \"fc04e80d343f5929aea4aac77fb12485c7b07b3a3d2fc383d68912c9ad0666da\"\n\n    address = \"0x41bc9c\"\n\n    packer = \"pkr_ce1a\"\n\n  strings:\n\n    $a = { 0094488D6A[4]F2160B6800 }\n\n  condition:\n\n    $a and\n\n    uint16(0) == 0x5A4D and\n\n    uint32(uint32(0x3C)) == 0x00004550\n\n}\n\n## Supporting Data and IOCs\n\n```\n\n-----\n\n## File\n\n```\nFilename: 6523.exe\n\n```\n```\nFilename: povgwaoci.iwe\n\n```\n```\nMD5: 5663a767ac9d9b9efde3244125509cf3\n\n```\n```\nSHA1: 84f383a3ddb9f073655e1f6383b9c1d015e26524\n\n```\n```\nImphash: bc57832ec1fddf960b28fd6e06cc17ba\n\n```\n```\nTimestamp: 2022-02-16T10:14:32Z\n\n```\n```\nFile Type: Win32 EXE\n\n```\n```\nMagic: PE32 executable (GUI) Intel 80386, for MS Windows\n\n```\n```\nSize: 238080\n\n```\n```\n   First Seen: 2022-10-14T18:37:13Z 4\n\n## Distribution URL\n\n```\n```\nhxxp[://]guluiiiimnstrannaer[.]net/dl/6523.exe\n\n```\n\n## Malware Behavior Catalog\n\nDEFENSE EVASION::Software Packing [F0001]\n\nANTI-BEHAVIORAL ANALYSIS::Emulator Evasion::Undocumented Opcodes\n\n[B0005.002]\n\nANTI-BEHAVIORAL ANALYSIS::Emulator Evasion::Unusual/Undocumented API Calls\n\n[B0005.003]\n\nANTI-BEHAVIORAL ANALYSIS::Emulator Evasion::Extra Loops/Time Locks\n\n[B0005.004]\n\nANTI-STATIC ANALYSIS::Disassembler Evasion::Argument Obfuscation [B0012.001]\n\nANTI-STATIC ANALYSIS::Disassembler Evasion::Variable Recomposition [B0012.004]\n\n\n-----\n\nANTI-STATIC ANALYSIS::Executable Code Obfuscation::Dead Code Insertion\n\n[B0032.003]\n\nANTI-STATIC ANALYSIS::Executable Code Obfuscation::Junk Code Insertion\n\n[B0032.007]\n\nANTI-STATIC ANALYSIS::Executable Code Obfuscation::Interleaving Code\n\n[B0032.014]\n\n## Malware Behavior Catalog Proposed Methods\n\nANTI-BEHAVIORAL ANALYSIS::Emulator Evasion::Unimplemented Opcodes [B0005]\n\nANTI-STATIC ANALYSIS::Executable Code Obfuscation::Opaque Predicate [B0032]\n\nANTI-STATIC ANALYSIS::Executable Code Obfuscation::Function Call Obfuscation\n\n[B0032]\n\n## Analyses\n\n[Intezer](https://analyze.intezer.com/analyses/4ae9acb6-01f0-4ff5-89bf-c967349e08f9)\n\n[UnpacMe](https://www.unpac.me/results/a6d0217d-02c0-4db8-9186-fc0d99137789/)\n\n1\n[Sample downloaded from hxxp[://]guluiiiimnstrannaer[.]net/dl/6523.exe](https://bazaar.abuse.ch/sample/fc04e80d343f5929aea4aac77fb12485c7b07b3a3d2fc383d68912c9ad0666da#:~:text=Sample%20downloaded%20from)\n\n2\n```\nImphash: bc57832ec1fddf960b28fd6e06cc17ba\n\n```\n3\n[LocalAlloc function (winbase.h)](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localalloc)\n\n4\nVirusTotal\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-11-19 - Malicious Packer pkr_ce1a.pdf"
    ],
    "report_names": [
        "2022-11-19 - Malicious Packer pkr_ce1a.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536246,
    "ts_updated_at": 1743041161,
    "ts_creation_date": 1669662674,
    "ts_modification_date": 1669662674,
    "files": {
        "pdf": "https://archive.orkl.eu/3a2b16960385d7c646b0271762b63ed7fdc37458.pdf",
        "text": "https://archive.orkl.eu/3a2b16960385d7c646b0271762b63ed7fdc37458.txt",
        "img": "https://archive.orkl.eu/3a2b16960385d7c646b0271762b63ed7fdc37458.jpg"
    }
}