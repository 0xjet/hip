{
    "id": "f2e57f24-1d10-4f42-96c3-d46e64ed49fd",
    "created_at": "2023-01-12T15:02:14.23439Z",
    "updated_at": "2025-03-27T02:09:18.304304Z",
    "deleted_at": null,
    "sha1_hash": "4289192cf0936d29e94c79901eb82e62dff9d70d",
    "title": "2021-12-31 - HANCITOR- Analysing The Main Loader",
    "authors": "",
    "file_creation_date": "2022-05-27T23:24:38Z",
    "file_modification_date": "2022-05-27T23:24:38Z",
    "file_size": 3228738,
    "plain_text": "# HANCITOR: Analysing The Main Loader\n\n**[0ffset.net/reverse-engineering/malware-analysis/hancitor-analysing-the-main-loader/](https://www.0ffset.net/reverse-engineering/malware-analysis/hancitor-analysing-the-main-loader/)**\n\n\nDecember 31, 2021\n\n\n-----\n\n[Chuong Dong](https://www.0ffset.net/author/chuong-dong/)\n31st December 2021\nNo Comments\n\nThis post is a follow up for my last one on HANCITOR. If you haven’t checked it out, you can\nview it [here.](https://www.0ffset.net/reverse-engineering/malware-analysis/hancitor-maldoc-analysis/)\n\nIn this post, we’ll take a look at the main loader of this malware family, which is used for\ndownloading and launching Cobalt Strike Beacon, information stealers, and malicious\nshellcode.\n\nIf you’re interested in following along, you can grab the loader sample as well as the PCAP\nfor it on [Malware-Traffic-Analysis.net.](https://www.malware-traffic-analysis.net/2021/09/29/index.html)\n\nSHA256: b9bafe8645a4dba7b7a9bd5132b696c0a419998d4f65fe897bb6912c2e019a7b\n\n## Step 1: Unpacking\n\nHANCITOR’s first executable stage is a packed DLL. We can tell since the HANCITOR\npayload is typically not obfuscated and relatively short. The gelforr.dap file dropped from the\nmaldoc stages, on the other hand, is quite large and has a high entropy (the measure of\nrandomness for data in the file). This high entropy can be a good indicator for the sample\ncontaining some data obfuscation.\n\n\n-----\n\nTo dynamically unpack this, we can load the sample in our favourite debugger and try to stop\nthe program after it’s done unpacking the final payload in memory.\n\nFirst, we can set breakpoints on VirtualAlloc and VirtualProtect as those two API calls are\ntypically used by packers to allocate memory for the unpacked executable and change the\nmemory’s protection to executable prior to launching. We can also set breakpoints on\n**CreateProcessInternalW and ResumeThread to try and stop our debugger before the final**\npayload is launched.\n\n\n-----\n\nAt this point, we can have the debugger execute the DLL and wait until these breakpoints are\nhit. As the code is quite large, it takes around 30 seconds before we hit our first VirtualAlloc\nbreakpoint. To observe if the packer writes the unpacked executable into the newly allocated\nmemory, we can capture the return value of the VirtualAlloc call and dump its memory\nbefore continuing the execution.\n\nThe first two allocated regions do not seem to give us anything valuable, but the third one\ndoes. The packer writes what seems to be a compressed PE file in it before calling\n**VirtualProtect to change its protection.**\n\n\n-----\n\nScrolling down a bit to examine this memory region, we can see that its lower part is not\ncompressed at all. To be exact, at offset 0x4389, we can see the uncompressed PE header,\nwhich indicates the beginning of the final unpacked payload.\n\n\n-----\n\nFrom here, we can simply dump this memory region and cut out the top 0x4389 bytes using\nany hex editor to retrieve the unpacked executable for the next stage.\n\nWe can also use PE-bear to examine and ensure that we have fully unpacked the file. After\nchecking that all imports are properly resolved, we will use IDA to perform static analysis on\nthis last stage.\n\n## Step 2: HANCITOR Entry Point\n\n\n-----\n\nThe HANCITOR DLL contains the following 3 exports: BNJAFSRSQIX,\n**SDTECHWMHHONG, and DllEntryPoint. Since the functions BNJAFSRSQIX and**\n**SDTECHWMHHONG share the same address, we can count them as one single function.**\n\nTypically, DllEntryPoint is used as the entry point function for malicious DLL files, but in\nHANCITOR case, this function does not do anything but return 1. This means that the\nmalware does not execute its full capability when loaded using rundll32.exe without an\nexport name specified.\n\nFrom the previous blog post, we know that the second Word document launches the\n**rundll32.exe command to execute the BNJAFSRSQIX export function, so it must be the real**\nentry point for this DLL.\n\n## Step 3: Extracting Victim Information\n\nBy the time this blog post is written, the C2 servers used by the sample have been taken\n[offline, so I will use the traffic captured by Malware-Traffic-Analysis.net in parallel with static](https://www.malware-traffic-analysis.net/2021/09/29/index.html)\nanalysis to show how the malware communicates with its C2 servers.\n\nTo contact C2 servers, the malware generates a string containing the victim’s information\nprior to encrypting and sending it to C2.\n\n\n-----\n\nFirst, HANCITOR generates a global unique identifier (GUID) for the victim. By calling\n**GetAdaptersAddresses, it retrieves an array of addresses associated with the network**\nadapters on the victim’s machine. It begins by XOR-ing the Media Access Control (MAC)\nadapter of each address together. Then, the malware retrieves the machine’s volume serial\nnumber by calling GetVolumeInformationA and XORs it with the result to create the victim’s\nGUID.\n\nFollowing this, HANCITOR extracts the machine’s information by calling\n**GetComputerNameA to retrieve the infected computer’s name.**\n\nIt also retrieves the process ID of an explorer.exe process and calls LookupAccountSidA\nto get the current user’s account name and domain name.\n\nThe machine’s information is then formatted as below.\n```\n<Computer name> @ <Domain name> \\ <Account name>\n\n```\n\n-----\n\nNext, HANCITOR retrieves the victim s IP address by sending a GET request to\n**hxxp://api[.]ipify[.]org. If the malware is unable to contact the website, it uses 0.0.0.0 as the**\nvictim’s IP address instead.\n\nThe documented query_URL_and_get_response function is shown below. After connecting\nto the target server using InternetConnectA, HANCITOR calls HttpOpenRequestA to\ncreate a GET request and HttpSendRequestA to send it to the server. The server’s\nresponse is then retrieved through InternetReadFile calls.\n\nBeside being used for querying the victim’s IP address, this function is later used to\ndownload malware and shellcode from HANCITOR’s C2 servers.\n\n\n-----\n\nThe malware then calls DsEnumerateDomainTrustsA to enumerate and retrieve all\nNETBIOS and DNS domain names.\n\nFinally, HANCITOR decrypts its configuration using RC4 before building the final victim’s\ninformation string.\n\n\n-----\n\nBelow is the content of the decoded configuration. It contains the sample’s build ID\n(2909_xplw) followed by the list of C2 URLs.\n\nThe final victim’s information string is built according to one of the following formats based on\nthe machine’s architecture.\n```\nGUID=<Victim’s GUID>&BUILD=<Build ID>&INFO=<Machine Information>&EXT=<Network domain\nnames>&IP=<Victim’s IP address>&TYPE=1&WIN=<Windows major version>.<Windows minor\nversion>(x64)\nGUID=<Victim’s GUID>&BUILD=<Build ID>&INFO=<Machine Information>&EXT=<Network domain\nnames>&IP=<Victim’s IP address>&TYPE=1&WIN=<Windows major version>.<Windows minor\nversion>(x32)\n\n```\n\n-----\n\n## Step 4: Sending Victim Information To C2 Servers\n\nAfter retrieving the victim information, the malware iterates through the C2 URL list\nembedded in the config and sends the data to the servers.\n\n\n-----\n\nThe function below is used to retrieve the next address in the list by locating the separator ‘|’\nbetween C2 URLs.\n\nThe function to send the victim’s information to the C2 servers has similar API calls to the\nfunction query_URL_and_get_response mentioned above, but instead of a GET request,\nthe malware is sending a POST request to send this data.\n\n\n-----\n\nWe can further confirm our analysis by examining the malicious traffic from the PCAP\n[provided to us by Malware-Traffic-Analysis.net. Below is the POST request being sent to the](https://www.malware-traffic-analysis.net/2021/09/29/index.html)\nC2 server hxxp://forkineler[.]com containing the victim’s information buffer as we have\nanalyzed.\n\n\n-----\n\n## Step 4: Decoding C2 Response\n\nUsing the same PCAP, we can examine the C2 response sent back from the server.\n\n\n-----\n\nThe response comes in the form of a Base64-encoded string.\n```\nVZAEARZAEg4OCkBVVU4XGw8IChUUDlQID1VOSwlUGBMUBwEWQBIODgpAVVVOFxsPCAoVFA5UCA9VTktUGBMUBw\n\n```\nThe first 4 characters in the string are used as a simple check to ensure the response does\ncome from the C2 server. The malware checks if they are all uppercase letters and discards\nthe response if the check fails.\n\nIf the response is valid, HANCITOR decodes the string using Base64 and XORs the result\nwith the character ‘z’. We can use CyberChef to quickly decode it and examine the content.\n\n\n-----\n\nThe decoded response can consist of one or multiple components, where each is made up\nof a command (‘l’) and a value (hxxp://4maurpont[.]ru/41s[.]bin).\n\nBefore processing each response component, HANCITOR checks if the command is in the\nlist of available commands ‘n’, ‘c’, ‘d’, ‘r’, ‘l’, ‘e’, and ‘b’.\n\n\n-----\n\nBeside the ‘n’ command that doesn’t perform anything, every other command instructs the\nmalware to download shellcode or a file and execute it.\n\n\n-----\n\n## Step 5: C2 commands – Downloading Executable & Remote Injection\n\nWhen the command is ‘b’, HANCITOR downloads a file from the URL specified in the\nresponse’s component and performs process injection to launch it.\n\nOne or multiple URLs separated by the character ‘|’ can be provided for the malware to\ndownload files from.\n\nAfter retrieving the file content into memory, HANCITOR decrypts it using a XOR cipher with\nits first 8 bytes as the key. Next, it calls RtlDecompressBuffer to perform LZ decompression\nto decompress the final executable.\n\n\n-----\n\nNext, the malware injects the downloaded executable into an svchost.exe process. To do\nthis, it first creates the process in a suspended state using CreateProcessA.\n\nNext, the malware calls VirtualAllocEx to allocate a buffer in the target’s memory to later\ninject the executable payload into it.\n\nHANCITOR then allocates a heap buffer using HeapAlloc, writes and maps the executable\nto it, and finally calls WriteProcessMemory to write the payload from the heap to svchost’s\nallocated memory.\n\n\n-----\n\nThe malware properly sets up the injected thread’s context by setting the image base\naddress from PEB (through the context’s EBX register) to the injected base address and the\nthread’s entry point (through the context’s EAX register) to the injected entry point.\n\nFinally, it launches the executable by calling ResumeThread to resume the injected thread.\n\n\n-----\n\n## Step 6: C2 commands – Downloading Executable & Self Injection\n\nWhen the command is ‘e’, HANCITOR downloads a file from the URL specified in the\nresponse’s component and injects the executable into its own process to launch it.\n\nThe malware first downloads the file using the same downloading function from the previous\ncommand.\n\nAfter downloading, HANCITOR calls VirtualAlloc to allocate a buffer in its own memory and\nwrites the downloaded executable in there.\n\n\n-----\n\nNext, the malware extracts each imported DLL name through the image’s Import Directory\nTable and calls GetModuleHandleA or LoadLibraryA to retrieve the DLL’s base (depending\nif the DLL is loaded in memory).\n\nFor each imported DLL, the malware manually iterates through its own Import Address Table\n(IAT) to retrieve the name of each imported function. It calls GetProcAddress to get the\naddress of the imported function and updates it in its IAT.\n\nFinally, HANCITOR can launch the injected executable through multiple methods depending\non the launch flags being given in the code.\n\n\n-----\n\nThe first method requires calling CreateThread to launch a new thread that manually\nresolves the injected image’s entry point from its headers and calls that address.\n\nThe next two simply require directly calling the image’s entry point address that is returned\nafter writing the image in memory.\n\n## Step 7: C2 commands – Downloading & Launching Shellcode\n\nWhen the command is ‘l’, HANCITOR downloads shellcode from the URL specified in the\nresponse’s component and injects the shellcode into its own process or svchost to launch it.\n\nThe malware first downloads the file using the same downloading function from the previous\ntwo commands.\n\n\n-----\n\nHANCITOR takes in a parameter to determine if it should inject the shellcode into its own\nprocess or remotely to svchost.\n\nTo inject into svchost, the malware first creates a suspended svchost process, calls\n**VirtualAllocEx to allocate a buffer in the process’s memory, and calls**\n**WriteProcessMemory to write the shellcode into the buffer.**\n\nTo launch the shellcode remotely, the malware then calls CreateRemoteThread to spawn a\nthread that begins executing at the base address of the injected shellcode.\n\nTo inject into its own process, HANCITOR calls VirtualAlloc to allocate a buffer in its\nmemory and manually copies the shellcode byte by byte into the buffer.\n\nFor self-injection, HANCITOR has two different ways of launching the shellcode. The first is\nsimply executing a call instruction to transfer execution to the base address of the shellcode.\nThe second one involves calling CreateThread to launch a thread that does basically the\nsame thing.\n\n\n-----\n\n## Step 8: C2 commands – Downloading File To Temp Directory\n\nWhen the command is ‘r’, HANCITOR downloads a file from the URL specified in the\nresponse’s component, drops it in the Windows Temp folder, and launches it.\n\nThe malware first downloads the file using the same downloading function from the previous\nthree commands.\n\n\n-----\n\nNext, to drop the downloaded file to the Temp directory, the malware calls GetTempPathA to\nretrieve the path to the directory and GetTempFileNameA to generate a temporary file’s\nname in that path with the prefix of “BN”.\n\nThen, it calls CreateFileA and WriteFile to write the downloaded content to the temporary\nfile.\n\nHANCITOR then checks the Characteristics flag in the file header to determine if the file is\nan executable or a DLL.\n\nIf the file is an executable, the malware launches it by calling CreateProcessA with the file’s\npath as the command line to be executed.\n\nIf the file is a DLL, the malware launches its start export function by calling CreateProcessA\nwith a formatted rundll32.exe command as the command line.\n\n\n-----\n\nAt this point, we have fully analyzed every stage of a HANCITOR infection and understood\nhow it can be used to load and launch malicious executable and shellcode! If you have any\n[questions regarding the analysis, feel free to reach out to me via Twitter.](https://twitter.com/cPeterr)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-12-31 - HANCITOR- Analysing The Main Loader.pdf"
    ],
    "report_names": [
        "2021-12-31 - HANCITOR- Analysing The Main Loader.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535734,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653693878,
    "ts_modification_date": 1653693878,
    "files": {
        "pdf": "https://archive.orkl.eu/4289192cf0936d29e94c79901eb82e62dff9d70d.pdf",
        "text": "https://archive.orkl.eu/4289192cf0936d29e94c79901eb82e62dff9d70d.txt",
        "img": "https://archive.orkl.eu/4289192cf0936d29e94c79901eb82e62dff9d70d.jpg"
    }
}