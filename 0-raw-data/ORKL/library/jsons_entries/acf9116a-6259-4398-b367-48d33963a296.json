{
    "id": "acf9116a-6259-4398-b367-48d33963a296",
    "created_at": "2023-06-05T02:06:42.846645Z",
    "updated_at": "2025-03-27T02:06:01.500083Z",
    "deleted_at": null,
    "sha1_hash": "c36659f8c600e08e0c237d179fef3f4f9ae1357e",
    "title": "2016-06-07 - The Story of yet another ransom-fail-ware",
    "authors": "",
    "file_creation_date": "2023-06-04T13:52:05Z",
    "file_modification_date": "2023-06-04T13:52:05Z",
    "file_size": 919593,
    "plain_text": "# Sogeti ESEC Lab\n\n**[web.archive.org/web/20191008053714/http://esec-lab.sogeti.com/posts/2016/06/07/the-story-of-yet-another-ransomfailware.html](http://web.archive.org/web/20191008053714/http://esec-lab.sogeti.com/posts/2016/06/07/the-story-of-yet-another-ransomfailware.html)**\n\n## TL;DR\n\nThis article explains why it is still worth trying to reverse engineer a\nransomware in order to retrieve\nyour encrypted files. You may find a tool to\ndecrypt the files modified by this specific ransomware at\nthe end of the\narticle.\n\n## Context\n\nA few weeks ago, Sogeti ESEC was called on an incident that took place in a client information\nsystem.\n\nThe client noticed some strange activities ongoing on one computer within their network. Indeed,\nsome\nfiles on that computer, including the ones available on network shares, were unreadable.\nUnfortunately most of those files included vital documents for our client, such as financial\ninformation, strategic\ninformation and so on. This data were the achievement of a couple dozen\nyears of work, thus could not be allowed to be\nlost. That is the reason why several backups of those\ndata were done.\n\nAfter some investigations, they quickly understood that a malware was running on it. On their own,\nthey suspected the\npresence of a ransomware.\n\n**Their moves were to:**\n\nend the process that was running\ndelete all the encrypted files\nreboot\nplug the backup storage and copy original files to the infected computer\n\nObviously the malware was still present on the system and had executed itself at boot time, infecting\nall freshly mounted\nbackups, ending up with the loss of their three (3) backups (i.e.: averaging 1To\nworth of data).\n\nThrough a private company they were able to retrieve 40Go of encrypted data. Our mission was to\nunderstand how that\nincident happened and if we were able to retrieve their data.\n\nThis mission has been conducted in collaboration with the Pentest and R&D teams of Sogeti/ESEC.\n\n## Introduction\n\nWikipedia well defines what a ransomware is:\n\n\n-----\n\n```\nA ransomware is a type of malware which restricts access to a machine data in\n\nsome way. Most of the time, the malware encrypts the content of all disks\n\navailable locally and remotely. Then the encryption key is sent to the\n\nattacker and destroyed.\n\nThe instructions to recover the files are also dropped by the malware. The\n\nattacker commonly asks for a ransom to get the files decrypted.\n\n```\nRansomware is the easiest and quickest way of preventing a company to work, creating a leverage\nto get paid, or \"ransom\".\nOf course there is no guarantee of being able to retrieve the lost data.\nOn\nthe top of that, cryptocurrencies - like Bitcoin - allow fast transactions and are more or less easy to\ncash out. That is\none of the reasons this kind of malware is on the rise.\n\nA 2015 study published by Microsoft [1] shows this increase:\n```\n2014 saw exponential infections from ransomware, with families such as Ransom:JS/Krypterade,\nWin32/Crowti,\n\nWin32/Reveton, and Win32/Teerac garnering more than 4 million infections. The start of 2015\nintroduced new\n\ncharacters such as Win32/Tescrypt and Win32/Troldesh.\n\n\n```\nDue to their nature, most of the files encrypted with a ransomware are impossible to retrieve.\nMicrosoft agrees [2]:\n```\nDue to the encryption of the files, it can be practically impossible to reverse-engineer the\nencryption or “crack”\n\nthe files without the original encryption key – which only the attackers will have access\nto.\n\n\n## Compromise\n\n```\nThe discovery of the so-called Patient Zero is really important in order to understand how an\nincident happened.\nIn our case, we easily identified a RDP service opened on the Internet. Through\nthe computer's logs, we identified\nthat a successful authentication of the Administrator user on that\nservice was the root of that compromise. Indeed we\nthen noticed that the password used was really\nweak and could be found in any dictionaries.\n\nFrom there we were able to locate the malware (that was still running on the infected computer) and\ndecided to analyze it.\n\n## Analysis\n\nIn this section, we describe the main steps of the ransomware which are common to this kind of\nmalware.\n\n### Configuration decryption\n\nThe first task done by the ransomware is to decrypt a block of 73476 bytes located at the address\n_0x00413FF8:_\n\n\n-----\n\n```\ni 0;\n\ndo\n{\n\n if ( i * 4 & 1 )\n\n  config[i] ^= 0xAF67D12E;\n\n else\n\n  config[i] ^= 0xF76742E2;\n\n ++i;\n\n}\n\nwhile ( i < 18369 );\n\n```\nThis block contains its configuration. Here is a list of the data contained in it:\n\nSize (on 4 bytes) of the RSA key in bytes\nThe RSA modulus\n```\n00413FF8 80 00 00 00 B5 EF D6 45 33 3D 7B 75 57 96 FD 0A Ç...Á´ÍE3={uWû².\n\n00414008 2A E3 DB 56 78 38 57 CA 2C E3 64 33 AC 8A 75 57 *Ò¦Vx8W-,Òd3¼èuW\n\n00414018 6A 71 64 A0 62 53 1B AC C7 05 A7 23 60 CA 00 47 jqdábS.¼Ã.º#`-.G\n\n00414028 C2 62 58 EC C2 34 AA D1 AE FD 86 F9 EA 78 56 6D -bXý-4¬Ð«²å¨ÛxVm\n\n00414038 C9 83 A4 7D A1 59 C2 29 F7 07 42 F1 C0 40 AE E6 +âñ}íY-)¸.B±+@«µ\n\n00414048 CB F4 E3 EA 47 36 56 03 7F 99 31 D6 CE E8 AB 94 -¶ÒÛG6V..Ö1Í+Þ½ö\n\n00414058 F5 B9 AC 64 F1 0D C8 17 ED 0A 90 24 DB CA 71 00 §¦¼d±.+.Ý..$¦-q.\n\n00414068 30 E8 80 93 3B 93 24 E9 F6 8F 8C 5B BB D3 78 76 0ÞÇô;ô$Ú÷.î[+Ëxv\n\n00414078 CE 5F FB C3 00 00 00 00 00 00 00 00 00 00 00 00 +_¹+............\n\n\n```\nThe RSA exponent\n```\n004141F2 00 00 00 00 00 00 04 00 00 00 00 01 00 01 00 00 ................\n\n\n```\nList of drive letter to infect\n```\n00414472 00 00 00 00 00 00 41 00 42 00 43 00 44 00 45 00 ......A.B.C.D.E.\n\n00414482 46 00 47 00 48 00 49 00 4A 00 4B 00 4C 00 4D 00 F.G.H.I.J.K.L.M.\n\n00414492 4E 00 4F 00 50 00 51 00 52 00 53 00 54 00 55 00 N.O.P.Q.R.S.T.U.\n\n004144A2 56 00 57 00 58 00 59 00 5A 00 00 00 00 00 00 00 V.W.X.Y.Z.......\n\n\n```\nThe magic number for the encrypted file's footer\n```\n004144F8 30 30 35 50 52 5A 00 00 00 00 00 00 00 00 00 00 005PRZ..........\n\n\n```\nThe email address to ask the ransom from\n```\n00414578 2E 00 7B 00 61 00 5F 00 70 00 72 00 69 00 6E 00 ..{.a._.p.r.i.n.\n\n00414588 63 00 40 00 61 00 6F 00 6C 00 2E 00 63 00 6F 00 c.@.a.o.l...c.o.\n\n00414598 6D 00 7D 00 00 00 00 00 00 00 00 00 00 00 00 00 m.}.............\n\n\n```\nThe extension for the encrypted file\n```\n004145F8 2E 00 78 00 74 00 62 00 6C 00 00 00 00 00 00 00 ..x.t.b.l.......\n\n\n```\nThe name of the mutex\n```\n00414678 47 00 6C 00 6F 00 62 00 61 00 6C 00 5C 00 73 00 G.l.o.b.a.l.\\.s.\n\n00414688 6E 00 63 00 5F 00 00 00 00 00 00 00 00 00 00 00 n.c._...........\n\n```\n\n-----\n\nThe folder to exclude from encryption\n```\n00415678 25 00 77 00 69 00 6E 00 64 00 69 00 72 00 25 00 %.w.i.n.d.i.r.%.\n\n\n```\nThe registry key for persistence\n```\n004147F8 53 00 6F 00 66 00 74 00 77 00 61 00 72 00 65 00 S.o.f.t.w.a.r.e.\n\n00414808 5C 00 4D 00 69 00 63 00 72 00 6F 00 73 00 6F 00 \\.M.i.c.r.o.s.o.\n\n00414818 66 00 74 00 5C 00 57 00 69 00 6E 00 64 00 6F 00 f.t.\\.W.i.n.d.o.\n\n00414828 77 00 73 00 5C 00 43 00 75 00 72 00 72 00 65 00 w.s.\\.C.u.r.r.e.\n\n00414838 6E 00 74 00 56 00 65 00 72 00 73 00 69 00 6F 00 n.t.V.e.r.s.i.o.\n\n00414848 6E 00 5C 00 52 00 75 00 6E 00 00 00 00 00 00 00 n.\\.R.u.n.......\n\n\n```\nA list of files to exclude from encryption\n```\n004151F8 45 00 78 00 70 00 6C 00 6F 00 72 00 65 00 72 00 E.x.p.l.o.r.e.r.\n\n00415208 2E 00 65 00 78 00 65 00 3B 00 53 00 76 00 63 00 ..e.x.e.;.S.v.c.\n\n00415218 68 00 6F 00 73 00 74 00 2E 00 65 00 78 00 65 00 h.o.s.t...e.x.e.\n\n\n```\nThe name of the files that contain decryption instructions to follow in order to pay the ransom\n(dropped on disk):\n```\n00414978 44 00 45 00 43 00 52 00 59 00 50 00 54 00 2E 00 D.E.C.R.Y.P.T...\n\n00414988 6A 00 70 00 67 00 00 00 00 00 00 00 00 00 00 00 j.p.g...........\n\n00414A78 44 00 45 00 43 00 50 00 59 00 50 00 54 00 20 00 D.E.C.P.Y.P.T. .\n\n00414A88 46 00 49 00 4C 00 45 00 53 00 2E 00 74 00 78 00 F.I.L.E.S...t.x.\n\n00414A98 74 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 t...............\n\n\n```\nThe file DECPYPT FILES.txt obviously contain a typo (P instead of R). The only reason we found\nis the fact the P\nand R are on the same keyboard key on russian keyboard layout..\n\nThe instructions picture looks like that:\n\n\n-----\n\nThanks to a famous search engine and a russian OCR tool, this is the text in english:\n```\nYour data is encrypted using the latest encryption algorithm.\n\nIf you want to restore the data, send 1 encrypted file by e-mail to\n\nа_princ@аоl.com\n\nYou have 48 hours otherwise keys are removed\n\n\n```\nHe wants one encrypted file, probably to be sure that we have been infected by his\ncryptolocker.\nRansom demand probably comes as a response to the email.\n\n### Persistence\n\nThe ransomware tries to copy itself in %windir% then %appdata%.\n\nOnce done, it creates a registry key System Service\nunder\n```\nSoftware\\Microsoft\\Windows\\CurrentVersion\\Run in order to be run at startup, thus\n\n```\nachieving persistence\n```\nif (v9 && GetModuleFileNameW(0, v0, 0x7FFFu))\n\n{\n\n  if ((wcscpy_s(v1, 0x7FFFu, \"%windir%\\\\System32\"), wcscat_s(v1, 0x7FFFu, L\"\\\\\"),\nwcscat_s(v1, 0x7FFFu, CryptolockerName),\n\n   ExpandEnvString(v1)) && CopyFileTo(v0, v1)  ||\n\n   (wcscpy_s(v1, 0x7FFFu, \"%localappdata%\"), wcscat_s(v1, 0x7FFFu, L\"\\\\\"), wcscat_s(v1,\n0x7FFFu, CryptolockerName),\n\n   ExpandEnvString(v1)) && CopyFileTo(v0, v1))\n\n  {\n\n    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, &SubKey, 0, 0x20106u, &phkResult) ||\n\n    (v5 = RegSetValueExW(phkResult, \"System Service\", 0, 1u, v1, 2 * wcslen(v1)) == 0,\n\n    RegCloseKey(phkResult), !v5))\n\n    {\n\n      if (!RegOpenKeyExW(HKEY_CURRENT_USER, &SubKey, 0, 0x20106u, &phkResult))\n\n      {\n\n        RegSetValueExW(phkResult, \"System Service\", 0, 1u, v1, 2 * wcslen(v1));\n\n        RegCloseKey(phkResult);\n\n      }\n\n    }\n\n  }\n\n}\n\n\n```\nNote: The name of this registry key is contained in the configuration data inside the binary and may\nchange.\n\n### Operation\n\n**After this, the ransomware adds three files to the exception list:**\n```\n  DECRYPT.jpg\n  DECPYPT FILES.txt\n\n```\nthe name of the running binary\n\n\n-----\n\nIt then uses the GetLogicalDrives function to get the list of drives present on the machine.\n```\nwhile (1){\n\n  v2 = GetLogicalDrives();\n\n  v14 = v2;\n\n  if ( v1 != v2 ){\n\n    driveIndex = 0;\n\n    v13 = v2 & ~v1 & 0xFFFFFFFC;\n\n    v16 = 1;\n\n    v15 = 0;\n\n    do{\n\n      if (v13 & v16){\n\n        Src = *&aAbcdefghijklmn[driveIndex];\n\n        v10 = malloc(0x1002Cu);\n\n        *v10 = *lpThreadParameter;\n\n        *(v10 + 16385) = *(lpThreadParameter + 16385);\n\n        *(v10 + 16386) = *(lpThreadParameter + 16386);\n\n        *(v10 + 16387) = *(lpThreadParameter + 16387);\n\n        wcscpy_s(v10 + 2, 0x7FFFu, &Src);\n\n        CreateThread(0, 0, sub_401A90, v10, 0, 0);\n\n        driveIndex = v15;\n\n        v2 = v14;\n\n      }\n\n      driveIndex += 2;\n\n      v16 = __ROL4__(v16, 1);\n\n      v15 = driveIndex;\n\n    }\n\n    while ( driveIndex < '@' );\n\n    v1 = v2;\n\n  }\n\n  Sleep(0x64u);\n\n}\n\n\n```\nOn each of these logical drives, a thread is launched.\nInside each of those threads, four other\nthreads are launched\n```\ndo\n  *(&Handles + v1++) = CreateThread(0, 0, StartAddress, &Parameter, 0, 0);\nwhile ( v1 < 4 );\n\n\n```\nEach of these previous threads will walk through folders recursively and will encrypt each file.\n\n### Encryption\n\nIn this section, we analyzed the different steps involving the encryption scheme used by the\nransomware.\n\n**Key generation**\n\nThe key is the most important operation of the ransomware as all the files will be encrypted with it.\n\nThe ransomware uses two (2) different sources of data, more or less random, to generate the 256\nbits of the key.\n\n\n-----\n\nFirst, it calls the _ftime64 function to get a 64-bit time value by\ndefault. Only the epochs time\nin seconds and the current number of\nmilliseconds will be used by the ransomware. This data\nrepresents 8 bytes\nof data stored at 0x00426c44.\n```\n_ftime64(&data);\n\ndword_426C44 ^= 1000 * ms;\n\ndword_426C48 ^= ((1000 * ms) >> 32) | data;\n\n\n```\nThe second source of data is the result of a call to the rand function of\nthe libc. This call will\nadd 4 bytes of data.\n```\nqword_426C4C = rand() ^ qword_426C4C; // qword_426C4C = 0\n\n\n```\nA 256 bits memory space is allocated for the key and then filled with zeroes. The\nnumber of\nmilliseconds multiplied by 1000 is copied. Then the epochs time in\nseconds. And finally, the rand\nvalue.\n```\n00426C44 08 3A 04 00 FE 56 4F 57 29 00 00 00 00 00 00 00 .:..¦VOW).......\n\n00426C54 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n\n\n```\nAs shown on the previous picture, more than 50% of the space is not updated\nwith random or\nselected values and stay filled with zeroes.\n\nFrom there, the ransomware computes the MD5 hash of these 256 bits to get 16 bytes of data.\n```\nmd5CTX[0] = 0x67452301;\n\nmd5CTX[1] = 0xEFCDAB89;\n\nmd5CTX[2] = 0x98BADCFE;\n\nmd5CTX[3] = 0x10325476;\n\nmd5_update(32, md5CTX, &dword_426C44);\n\nmd5_final(md5CTX);\n\n\n```\nThese 16 bytes are then used as a key to encrypt the 256 bits using the RC4 algorithm.\n```\nrc4_init(&rc4CTX, &data);\n\n...\n\nmemcpy(a1, &data, lenToGenerated);\n\nrc4_encrypt(&rc4CTX, a1, 32);\n\n\n```\nThe resulting encrypted data is the key used to encrypt the files of the system.\n\nTo sum up:\n```\nKEY = RC4(MD5(data), data)\n\ndata = [epochs][milliseconds*1000][rand()][0000][0000][0000][0000][0000]\n\n(each [] = 4 bytes)\n\n\n```\nWe can consider that the key is computed from 96 bits of data or only 74 bits if we consider the\nmaximal millisecond\nvalue being 999.\n\n**Weaknesses**\n\n\n-----\n\nYou may have already found the weaknesses in this encryption scheme.\n\nThe epochs time in seconds can be guessed from the date of last modification of the\nencrypted files. Even if the timestamp has been corrupted, it is still possible\nto bruteforce the\nvalue over a few days.\nRegarding the number of milliseconds, there is no real weakness other than the\nnumber of\nmilliseconds itself. Only 1000 possible values.\nThe third weakness is the call of the rand function. As it is not securely seeded before, and\nthis call is\nalways the first call to this function, the value returned by rand is always the same\n(0x00000029).\nFinally, if we consider that we want to bruteforce the timestamp on 10 days, the key\ngeneration\nalgorithm takes around 20 bits for the timestamp and 10 bits for the number of milliseconds.\n\nA bruteforce should then require only a few minutes to find the key.\n\n**Key encryption**\n\nAfter the key generation, the key is encrypted using RSA and a 1024 bits key located in the config at\n**0x00413ffc.\nExponent is also in the config at 0x004141fc.**\n```\n00413FFC B5 EF D6 45 33 3D 7B 75 57 96 FD 0A 2A E3 DB 56 Á´ÍE3={uWû².*Ò¦V\n\n0041400C 78 38 57 CA 2C E3 64 33 AC 8A 75 57 6A 71 64 A0 x8W-,Òd3¼èuWjqdá\n\n0041401C 62 53 1B AC C7 05 A7 23 60 CA 00 47 C2 62 58 EC bS.¼Ã.º#`-.G-bXý\n\n0041402C C2 34 AA D1 AE FD 86 F9 EA 78 56 6D C9 83 A4 7D -4¬Ð«²å¨ÛxVm+âñ}\n\n0041403C A1 59 C2 29 F7 07 42 F1 C0 40 AE E6 CB F4 E3 EA íY-)¸.B±+@«µ-¶ÒÛ\n\n0041404C 47 36 56 03 7F 99 31 D6 CE E8 AB 94 F5 B9 AC 64 G6V..Ö1Í+Þ½ö§¦¼d\n\n0041405C F1 0D C8 17 ED 0A 90 24 DB CA 71 00 30 E8 80 93 ±.+.Ý..$¦-q.0ÞÇô\n\n0041406C 3B 93 24 E9 F6 8F 8C 5B BB D3 78 76 CE 5F FB C3 ;ô$Ú÷.î[+Ëxv+_¹+\n\n...\n\n004141FC 00 01 00 01 00 00 00 00 00 00 00 00 00 00 00 00 ................\n\n\n```\nAs the size of the data to encrypt is only 32 bytes (256 bits), padding is added\nto the key before\n[encryption. Padding is generated from the rand function,\nprobably following the OAEP padding](http://web.archive.org/web/20191008053714/https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding)\nscheme.\n\n**File encryption**\n\n[The ransomware uses the AES encryption algorithm with a 256 bits key in CBC\nmode. For each file,](http://web.archive.org/web/20191008053714/https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\na random IV is generated using the same function than the\nkey.\n\nThis IV is added in the data at the end of each encrypted file with the magic,\nthe padding length and\nthe encrypted key.\n```\nWriteFile(f, &magic, 6u, &NumberOfBytesWritten, 0); // 005PRZ\n\nWriteFile(f, &IV, 0x10u, &NumberOfBytesWritten, 0);\n\nWriteFile(f, &paddingLen, 1u, &NumberOfBytesWritten, 0);\n\nWriteFile(f, (RSA + 32), 0x80u, &NumberOfBytesWritten, 0);\n\n\n```\nAn example result is depicted below:\n\n\n-----\n\n```\n00103810 30 30 35 50 52 5A D2 5A 22 94 F0 BD DA A1 A0 2B 005PRZ.Z ......\n\n00103820 3F 97 C4 0F 23 F8 10 57 5D BA C9 61 03 AF 34 0C ?...#..W]..a..4.\n\n00103830 76 4D 73 6B 3A 6D 15 77 DD E6 83 EE FD 3C 9E D1 vMsk:m.w.....<..\n\n00103840 15 BC B9 91 38 BC 16 9E 02 3C 83 F2 42 2F 3F 89 ....8....<..B/?.\n\n00103850 89 33 E0 94 C6 C7 FB EE C2 28 7B 0B 65 69 D8 76 .3.......({.ei.v\n\n00103860 FC 55 E4 E9 FA 74 74 26 6C 01 52 19 6B CC 4F 1D .U...tt&l.R.k.O.\n\n00103870 0B 36 3E 55 63 29 1F 9E 87 F0 90 EB 12 81 5A 08 .6>Uc)........Z.\n\n00103880 E5 15 27 10 28 41 6A 14 6A DF 48 E2 BE 2D FE 71 ..'.(Aj.j.H..-.q\n\n00103890 55 63 22 83 CB C4 BA 4B AE 92 98 73 5C E0 B9 04 Uc\"....K...s\\...\n\n001038A0 F2 3F 3F CF 26 56               .??.&V.\n\n```\nAfter the file is encrypted, it is deleted.\n```\nif ( v8 )\n\n{\n\n SetFileAttributesW(a4, dwFileAttributes);\n\n if ( !*(v12 + 172) )\n\n  DeleteFileW(lpFileName);\n\n}\n\nresult = v8;\n\n\n### Decryption\n\n```\nIn this section, we describe the different steps to recover the encryption key\nand decrypt the files.\n\n**Bruteforce the secret key**\n\nBruteforcing the key requires a way to identify when we find the correct key. For\nthat, we use the\nfirst 4 bytes (magic number) of several known filetypes because their header never changes.\nSo, we\nneed at least one encrypted file with the corresponding filetype.\n\nIn the following tables, some of the magic numbers values:\n\n**Extension** **First 4 bytes**\n\n.exe,.dll 4D5A9000\n\n.docx 504b0304\n\n.xlsx 504b0304\n\n.pptx 504b0304\n\n.zip 504b0304\n\n.jpeg ffd8ffe0\n\n.png 89504E47\n\n.pdf 25504446\n\n.rtf 7b5c7274\n\nThe algorithm used to bruteforce the key is :\n\n\n-----\n\n```\nfor timestamp in range(start, end):\n\n  for millisecond in range(1000):\n\n    Key = GenerateKey(timestamp, millisecond*1000)\n\n    if Decrypt(encryptedFile[:4]) == header:\n\n      return KEY_FOUND\n\nreturn KEY_NOT_FOUND\n\n```\n**Key identification**\n\nAs the ransomware is designed to be run at startup, it is possible that files\non the same machine\nwere encrypted with different keys. If we want to decrypt\nall files on a machine, we need a way to\nidentify whether we have the right key\nor not.\n\nFor that, we use the encrypted key block located at the end of each encrypted\nfile. For each run, the\nransomware will encrypt the key using the RSA 1024 bits\nkey and the result is added at the end of\nthe encrypted file.\n\nWhen we finally find the right key for a file, we can store the encrypted key separately.\nAnd when we\nneed to decrypt a file, we only need to compare the encrypted key stored against the one stored\npreviously.\n\n**Key decryption**\n\nThe ransomware uses a 1024 bits modulus with 0x10001 exponent to encrypt the key. Thus, there\nis no way of decrypting\nthe key except if you made some progresses in quantum computing.\n\n**File decryption**\n\nIf we have the encryption key, we are able to decrypt the file using the IV\nstored at the end of each\nencrypted file with AES256 in CBC mode using the freshly retrieved key.\n\nWe also need to remove the last x bytes of the decrypted data by using the padding value stored in\neach encrypted file\nfooter.\n\n### Indicator of compromise\n\nHere is a list of IOCs for this ransomware:\n\nFiles with xtbl or {a_princ@aol.com}.xtbl extension\n\nProcess with mutex starting with snc_\n\n\n-----\n\nPE files present in %appdata% or %windir% with that fingerprint:\n\n**Algorithm** **Fingerprint**\n\nMD5 ebcdda10fdfaa38e417d25977546df4f\n\nSHA1 5b58de17843ac44adc91b41883828cf5b3a11744\n\nSHA256 3c4588fe87146b9c1d0c97a5175bc287d8350ace3f4188d3cd2458638fcd8d97\n\nMachoc https://raw.githubusercontent.com/sogeti-esec-lab/ransomware-xtbl-decrypttool/master/machoc-signature.txt\n\n### Decryption\n\nWe developed a tool that decrypts files encrypted by this malware only.\nFirst, the tool will recover\nthe encryption key using one encrypted file.\n\nPlease use an encrypted file with the last modification timestamp untouched.\n\nThen the files on each disk of the machine will be decrypted.\n\n\n-----\n\nThos tool is available on github:\n\n[Sources](http://web.archive.org/web/20191008053714/https://github.com/sogeti-esec-lab/ransomware-xtbl-decrypt-tool/)\n[Compiled executable](http://web.archive.org/web/20191008053714/https://github.com/sogeti-esec-lab/ransomware-xtbl-decrypt-tool/releases/tag/v1)\n\n### Conclusion\n\nStatistics show that the threat of being infected by a ransomware has only begun. Each month,\nmore\nand more ransomware variants are detected.\n\nSome of them do not use state of the art cryptography yet, or badly\nuse it to encrypt files, such as in\nour case. But in most cases, there\nis no way to decrypt the file without having the secret key of the\nattacker.\n\nHere, the fail comes from the rand function call which is not correctly seeded beforehand,\nthe use\n\nof the timestamp which can easily be bruteforced and the number of\nmilliseconds which holds a\nlimited space of possibilities.\n\nThis post also highlights the good cooperation between the Pentest and the R&D team of Sogeti\nESEC.\nFor that, special thanks to lerobert, jbedrine, meik, who also worked on this incident\nresponse.\n\n[1] [https://www.microsoft.com/security/portal/enterprise/threatreports_september_2015.aspx](http://web.archive.org/web/20191008053714/https://www.microsoft.com/security/portal/enterprise/threatreports_september_2015.aspx)\n\n\n-----\n\n[2] [https://www.microsoft.com/en-us/security/portal/mmpc/shared/ransomware.aspx](http://web.archive.org/web/20191008053714/https://www.microsoft.com/en-us/security/portal/mmpc/shared/ransomware.aspx)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-06-07 - The Story of yet another ransom-fail-ware.pdf"
    ],
    "report_names": [
        "2016-06-07 - The Story of yet another ransom-fail-ware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1685930802,
    "ts_updated_at": 1743041161,
    "ts_creation_date": 1685886725,
    "ts_modification_date": 1685886725,
    "files": {
        "pdf": "https://archive.orkl.eu/c36659f8c600e08e0c237d179fef3f4f9ae1357e.pdf",
        "text": "https://archive.orkl.eu/c36659f8c600e08e0c237d179fef3f4f9ae1357e.txt",
        "img": "https://archive.orkl.eu/c36659f8c600e08e0c237d179fef3f4f9ae1357e.jpg"
    }
}