{
    "id": "3f5af6f2-28be-415a-9830-098c72a13e1a",
    "created_at": "2023-01-12T15:07:08.46448Z",
    "updated_at": "2025-03-27T02:06:15.031551Z",
    "deleted_at": null,
    "sha1_hash": "bfdba0559b3fe3a139d893cc210ed6ad3bd2d9c3",
    "title": "2018-07-25 - Parasite HTTP RAT cooks up a stew of stealthy tricks",
    "authors": "",
    "file_creation_date": "2022-05-28T19:51:13Z",
    "file_modification_date": "2022-05-28T19:51:13Z",
    "file_size": 1322442,
    "plain_text": "# Parasite HTTP RAT cooks up a stew of stealthy tricks\n\n**[proofpoint.com/us/threat-insight/post/parasite-http-rat-cooks-stew-stealthy-tricks](https://www.proofpoint.com/us/threat-insight/post/parasite-http-rat-cooks-stew-stealthy-tricks)**\n\n\nJuly 25, 2018\n\n\n-----\n\n[Blog](https://www.proofpoint.com/us/blog)\n[Threat Insight](https://www.proofpoint.com/us/blog/threat-insight)\nParasite HTTP RAT cooks up a stew of stealthy tricks\n\n\n-----\n\nJuly 25, 2018 Proofpoint Staff\n\n**Overview**\n\nProofpoint researchers recently discovered a new remote access Trojan (RAT) available for sale on\nunderground markets. The RAT, dubbed Parasite HTTP, is especially notable for the extensive array of\ntechniques it incorporates for sandbox detection, anti-debugging, anti-emulation, and other protections.\nThe malware is also modular in nature, allowing actors to add new capabilities as they become available\nor download additional modules post infection.\n\nTo date, we have only observed Parasite HTTP in a single small email campaign with intended\nrecipients primarily in the information technology, healthcare, and retail industries.\n\n**Campaign Analysis**\n\nOn July 16, 2018, Proofpoint observed a small campaign that appeared to leverage human resources\ndistribution lists as well as some individual recipients at a range of organizations. Specifically, the\ncampaign targeted the following distribution lists, among others:\n\nhr@[organization domain]\nrecruiting@\naccessibility@\nresumes@\n\nThe messages purported to be resumes or CV submissions and used subjects including:\n\nadvertised position\nwould like to apply\napplication\n\nThe messages contained Microsoft Word attachments with names such as (Figure 1):\n\nmy_cv.doc\nresume_.doc\ncvnew.doc\ncv.doc\n\n\n-----\n\nnew_resume.doc\n\nThe documents contained macros that, if enabled, would download Parasite HTTP from a remote site.\n\n_Figure 1: Document attachment_\n\n**Parasite HTTP Forum Advertisement**\n\nThe first insight into the new malware observed in the campaign above came from an advertisement on\nan underground forum. The Parasite HTTP ad details a long list of sophisticated features, many of which\nfocus on evading detection and analysis. The full text of the advertisement appears below:\n\n*********************\n\n_Parasite HTTP Remote Administration Tool_\n\n_What is Parasite HTTP?_\n\nParasite HTTP is a professionally coded modular remote administration tool for windows written in C\nthat has no dependencies except the OS itself.\n\nWith the stub size of ~49kb and plugin support it presents perfect solution for controlling large amount of\ncomputers from a remote location.\n\n_Features_\n\nNo dependencies (Coded in C)\nSmall stub size (~49kb uncompressed, ~23kb compressed)\nDynamic API calls (No IAT)\nEncrypted strings\nBypass Ring3 hooks\nSecure C&C panel written in PHP\nFirewall bypass\n\n\n-----\n\nSupports both x86 and x64 Windows OS (from XP to 10)\nFull unicode support\nOnline builder tied to your domain/s (Build bot bin anytime with any settings you wish)\nEncrypted communication with C&C panel (Optional - SSL using self signed certificate)\nPlugin system\nMultiple backup domains\nSystem wide persistence (x86 processes only) (Optional)\nInjection to whitelisted system process (Optional)\nInstall & Melt (Optional)\nHidden startup (Optional)\nAnti-Emulation (Optional)\nAnti-Debug\nExtended statistics and informations in the panel\nAdvanced task management system\nOn Connect task (New clients will execute task/s)\nLow resource usage\nSpecial login page security code\nCaptcha on login page to prevent brute force attacks\nDownload & Execute (Supports both HTTP and HTTPS links)\nUpdate\nUninstall\n\n_Available Plugins (Some are created by me)_\n\nUser management\nBrowser password recovery\nFTP password recovery\nIM password recovery\nEmail password recovery\nWindows licence keys recovery\nHidden VNC\nReverse Socks5 proxy\n\n_System Req_\n\nPHP 5.6 or greater (Gd & OpenSSL)\nIonCube Loader\nSQL Database\n\n*********************\n\n**Malware Analysis**\n\nParasite HTTP contains an impressive collection of obfuscation and sandbox- and research\nenvironment-evasion techniques. In this section we examine the more sophisticated components.\n\n_String Obfuscation_\n\nParasite HTTP uses the following encoding for its obfuscated strings:\n\n\n-----\n\n4-byte XOR key\n2-byte string length in characters\nN-byte obfuscated ASCII/Unicode string\n\nThis 6-byte header exists prior to the reference to the string in assembly. Parasite HTTP contains four\nroutines for operating on strings preceded by a 6-byte header. For each type of string, ASCII or Unicode,\none variant leaves the obfuscated string in place and returns a dynamically-allocated, deobfuscated\nversion of the string. The other variant uses VirtualProtect to deobfuscate the string in place, setting the\nXOR key to 0 after the deobfuscation has been performed, which effectively skips deobfuscation during\nfuture access to the string.\n\n_Sandbox Detection via Sleep Manipulation_\n\nParasite HTTP uses a sleep routine to delay execution and check for sandboxes or emulation.\nSpecifically it employs the following code to perform its sleeps:\n\n_Figure 2: Routine that Parasite HTTP uses to perform sleeps in 10ms increments (decompiled and with_\n_functions renamed for readability)_\n\nThe above function is called by a routine that performs a sandbox check for the expected passage of\ntime as well as non-interference with its own handling of breakpoint instructions it has placed in the\nchecking routine (removed from the display below for readability):\n\n\n-----\n\n_Figure 3: Function that detects sandbox environments by checking for the passage of time and non-_\n_interference with its own handling of breakpoint instructions_\n\nDuring the interval between the installation and removal of the vectored exception handler, several\nbreakpoint instructions are executed in the function which triggers execution of this vectored exception\nhandler, shown below. That handler sets the global flag which notifies the parent function that the\nhandler has run and skips over the breakpoint instruction. This code has been copied verbatim from an\nexample of anti-debugging code posted in a public repository [1].\n\n\n-----\n\n_Figure 4: Exception handler_\n\nThe sandbox checking routine first checks to ensure that the exception handler in Figure 4 has run. It\nthen checks whether between 900ms and two seconds elapsed in response to the routine’s 1 second\nsleep split into 10ms increments. Sandboxes using code like that available in [2] for example, would\nhave run afoul of this particular sandbox check.\n\n_Obfuscation of Sandbox Detection via Skipping of Allocation of Critical Buffers_\n\nWhen Parasite HTTP actually does detect a sandbox, it attempts to hide this fact from any observers. It\ndoes not simply exit or throw an error, instead making it difficult for researchers to determine why the\nmalware did not run properly and crashed. In the screenshot below, we can see how Parasite HTTP\nuses its sandbox detection in a clever way to result in a later crash on attempting to use a buffer whose\nallocation was skipped:\n\n_Figure 5: Code snippet showing mechanism by which critical buffers required for malware functioning_\n_are not allocated if a sandbox is detected_\n\n_Heap Clearing Bug_\n\nParasite HTTP also contains a bug caused by its manual implementation of a GetProcAddress API that\nresults in the clearing code not executing. This can be seen in the following commented decompilation:\n\n\n-----\n\n_Figure 6: Commented decompilation showing a bug in Parasite HTTP_\n\nThe malware attempts to resolve a function named HeapSize to its associated address within\nkernel32.dll. However, its manual GetProcAddress function lacks support for resolving forwarded\nexports. In this case, since HeapSize is in fact a forwarded export to NTDLL’s RtlSizeHeap function, the\nfunction will return NULL and HeapSize and the associated clearing will never be called. This is easily\nconfirmed by monitoring calls to RtlFreeHeap.\n\n_Use of Researcher Code from Github for Detecting Sandbox Hooking via Write Watches_\n\nParasite HTTP adapts code from a public repository [3] for its own sandbox detection purposes. The\ncode is copied verbatim, with the API resolution replaced with its own internal code, the prints removed,\nand the file and environment variable names generated randomly. Of note is that the GetWriteWatch API\nin this case detects more than just writes. Due to demand paging in Windows, the first access, whether\nread or write, to the allocation created will result in the page table entries being instantiated and counted\nas a “write” for the purposes of GetWriteWatch. Since the APIs being called with invalid arguments\nwould never read or write to the allocated buffer, hooks that read from the buffer prematurely or even in\nthe case of failure of the API, as in [4], would fail this sandbox detection.\n\n_Remapping of NTDLL via KnownDlls32\\ntdll.dll for Hook Evasion_\n\n\n-----\n\nOn Microsoft Windows, versions 7 and newer that have KnownDlls functionality, Parasite HTTP resolves\ncertain critical APIs by using a DLL remapping technique that while previously documented, has not, to\nour knowledge, been used recently in other major malware families. Malware behavior hidden by this\ntechnique include process injection and the Poweliks technique of including a NUL character in registry\nvalue names. The malware preserves support for older versions of Windows by falling back to using the\nexisting copy of NTDLL loaded in memory. This behavior can be seen in the following decompilation\nlisting:\n\n_Figure 7: Code snippet showing NTDLL remapping_\n\nMapping the new copy of NTDLL effectively provides it with a copy free of any hooks placed on the\ninitial NTDLL mapping, rendering its thread injection and registry modifications invisible to most userland\nhooking implementations. Further, since this mapping is accomplished with NtOpenSection and\nNtMapViewOfSection, it will not involve the typical calls to filesystem APIs used by other variants of the\ntechnique to achieve the same goal.\n\n_Obfuscated Checking for Breakpoints within a Critical Function of the Malware_\n\nParasite HTTP includes an obfuscated check for debugger breakpoints within a range of its own\ncode. This functionality is only used in one location to check a single function in the malware that calls\nout to the sandbox detection based on GetWriteWatch checks (Figure 8):\n\n\n-----\n\n_Figure 8: Obfuscated check for debugger breakpoints_\n\nThis code is also copied from [1] with the malware having implemented the added “level of indirection”\nmentioned in the code comment. It is worth noting that this technique is naive and unreliable long-term\nover arbitrary code, as unintentional 0xcc bytes can be found in a simple byte-by-byte scan of code\nthrough certain instruction encodings, local stack frame offsets, relative references, indirect addresses,\nor immediate constants.\n\n_Extension of Themida/Formbook Technique for Unhooking APIs in NTDLL/Kernel32/Kernelbase_\n\nIn its initial process, Parasite HTTP removes hooks on the aforementioned DLLs by reading them in\nfrom disk and comparing the first 5 bytes of each exported function to that present in the currently\nmapped version in memory. Though this technique is naive in its implementation, not making use of any\ninstruction decoder and limiting itself to 5 hardcoded bytes, it is effective in practice. Consider the case\nof a sandbox using an indirect jump (6 bytes) for its hooks -- the malware will restore only the first 5\nbytes to the original, leaving the final byte of the hook in place, most likely resulting in a crash upon its\nexecution.\n\n**Conclusion**\n\nThreat actors and malware authors continuously innovate in their efforts to evade defenses and improve\ninfection rates. Parasite HTTP provides numerous examples of state-of-the-art techniques used to avoid\ndetection in sandboxes and via automated anti-malware systems. For consumers, organizations, and\ndefenders, this represents the latest escalation in an ongoing malware arms race that extends even to\ncommodity malware like Parasite. While we have currently only observed Parasite HTTP in a small\ncampaign, we expect to see features like those used in Parasite continue to propagate across other\nmalware variants.\n\n**References**\n\n[1] [https://github.com/LordNoteworthy/al-khaser/blob/master/al-khaser/Anti%20Debug/Interrupt_3.cpp](https://github.com/LordNoteworthy/al-khaser/blob/master/al-khaser/Anti%20Debug/Interrupt_3.cpp)\n\n[2] [https://github.com/spender-sandbox/cuckoomon-modified/blob/MSVC/hook_sleep.c#L122](https://github.com/spender-sandbox/cuckoomon-modified/blob/MSVC/hook_sleep.c#L122)\n\n[3] [https://github.com/LordNoteworthy/al-khaser/blob/master/al-khaser/Anti%20Debug/WriteWatch.cpp](https://github.com/LordNoteworthy/al-khaser/blob/master/al-khaser/Anti%20Debug/WriteWatch.cpp)\n\n[4] [https://github.com/spender-sandbox/cuckoomon-modified/blob/MSVC/hook_thread.c#L232](https://github.com/spender-sandbox/cuckoomon-modified/blob/MSVC/hook_thread.c#L232)\n\n**Indicators of Compromise (IOCs)**\n\n\n-----\n\n**IOC** **IOC**\n**Type**\n\n\n**Description**\n\n\n6479a901a17830de31153cb0c9f0f7e8bb9a6c00747423adc4d5ca1b347268dc SHA256 Macro\nDocument\n\nhxxp://dboxhost[.]tk/moz/bza.exe URL Document\nPayload\n(Parasite\nHTTP)\n\nb52706530d7b56599834615357e8bbc1f5bed669001c06830029784eb4669518 SHA256 Parasite\nHTTP\n\nxetrodep[.]top Domain Parasite\nHTTP C&C\n\njekoslo[.]space Domain Parasite\nHTTP C&C\n\nbefrodet[.]top Domain Parasite\nHTTP C&C\n\n**ET and ETPRO Suricata/Snort/ClamAV Signatures**\n\n2831834 || ETPRO TROJAN Parasite HTTP Checkin\n\nSubscribe to the Proofpoint Blog\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-07-25 - Parasite HTTP RAT cooks up a stew of stealthy tricks.pdf"
    ],
    "report_names": [
        "2018-07-25 - Parasite HTTP RAT cooks up a stew of stealthy tricks.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536028,
    "ts_updated_at": 1743041175,
    "ts_creation_date": 1653767473,
    "ts_modification_date": 1653767473,
    "files": {
        "pdf": "https://archive.orkl.eu/bfdba0559b3fe3a139d893cc210ed6ad3bd2d9c3.pdf",
        "text": "https://archive.orkl.eu/bfdba0559b3fe3a139d893cc210ed6ad3bd2d9c3.txt",
        "img": "https://archive.orkl.eu/bfdba0559b3fe3a139d893cc210ed6ad3bd2d9c3.jpg"
    }
}