{
    "id": "04b4dd2a-b728-4ca7-838b-d284b1f94683",
    "created_at": "2023-01-12T15:08:33.091939Z",
    "updated_at": "2025-03-27T02:06:03.998915Z",
    "deleted_at": null,
    "sha1_hash": "d6444702fdc74d70a58b714b3be620285e3009f1",
    "title": "2022-08-30 - Raccoon Stealer 2.0 Malware analysis",
    "authors": "",
    "file_creation_date": "2022-09-01T10:29:57Z",
    "file_modification_date": "2022-09-01T10:29:57Z",
    "file_size": 1268428,
    "plain_text": "# Raccoon Stealer 2.0 Malware analysis\n\n**any.run/cybersecurity-blog/raccoon-stealer-v2-malware-analysis/**\n\nANY.RUN August 30, 2022\n\nRaccoon Stealer was one of the most mentioned malware in 2019. Cybercriminals sold this simple but versatile info\nstealer as a MaaS just for $75 per week and $200 per month. And it successfully attacked numerous systems. But in\nMarch 2022, threat authors shut down their operations.\n\nIn July 2022, a new variant of this malware was released. And now Raccoon Stealer 2.0 has gone viral and got a\nnew name in the wild – RecordBreaker. In this article, we will analyze several samples of the info stealer to find out\nits techniques and what data it collects.\n\n## What is Raccoon Stealer?\n\n[Raccoon Stealer is a kind of malware that steals various data from an infected computer. It’s quite a basic malware,](https://any.run/malware-trends/raccoon)\nbut hackers who provide excellent service and simple navigation have made Raccoon popular.\n\nRaccoon malwareRaccoon malware\n**The malware’s owners are interested in the following data:**\n\nLogin/password pairs from various services saved in browsers\nCookies from different browsers\nBank data\nCryptocurrency wallets\nCredit card information\nArbitrary files, which can be of interest to intruders\n\n## Raccoon – a sample overview\n\nIn the process of malware analysis, we worked with the following samples:\n\n**sha-256**\n\n9ee50e94a731872a74f47780317850ae2b9fae9d6c53a957ed7187173feb4f42\n\n0142baf3e69fe93e0151a1b5719c90df8e2adca4301c3aa255dd19e778d84edf\n\n022432f770bf0e7c5260100fcde2ec7c49f68716751fd7d8b9e113bf06167e03\n\n048c0113233ddc1250c269c74c9c9b8e9ad3e4dae3533ff0412d02b06bdf4059\n\n263c18c86071d085c69f2096460c6b418ae414d3ea92c0c2e75ef7cb47bbe693\n\n27e02b973771d43531c97eb5d3fb662f9247e85c4135fe4c030587a8dea72577\n\n494ab44bb96537fc8a3e832e3cf032b0599501f96a682205bc46d9b7744d52ab\n\nf26f5331588cb62a97d44ce55303eb81ef21cf563e2c604fe06b06d97760f544\n\nfcdc29b4d9cb808c178954d08c53c0519970fe585b850204655e44c1a901c4de\n\n\n-----\n\n_Raccoon malware overview in DiE_\n\nMITRE ATT&CK Matrix produced by [ANY.RUN Sandbox:](https://any.run/?utm_source=anyrunblog&utm_medium=article&utm_content=raccoon_stealer)\n\n## Challenges during the malware analysis of Raccoon stealer v2\n\nRaccoon stealer v.2 got extremely famous, and, of course, we decided to look into it closely. And here, we have\nfaced several challenges:\n\nWhen we first started our malware analysis, we immediately got a sample\n**9ee50e94a731872a74f4778037850ae2b9fae9d6c53a957ed7187173feb4f4, which we were unable to run in our**\nsandbox. This example was packed and immediately finished execution when we tried to run it in a virtual\nenvironment. So, our team decided to investigate the sandbox evasion mechanisms.\n\n\n-----\n\nDuring the sample s reverse engineering, we encountered another issue: the packer detects the presence of Anti\nAnti-Debugger and terminates before checking the execution’s environment. In our case, we used TitanHide.\n\nWhen running the program under a debugger, the NtQueryInformationProcess call causes the ProcessInformation\nvariable to be overwritten. The packer compares the random value written to this variable earlier with the value after\nthe call. If they are different, it stops execution.\n\n**The challenge was solved with the following script for x64dbg:**\n```\nbphc\n\nrun\n\nfindallmem 0, #e91727f5ff#\n\nbph ref.addr(0)+5\n\nrun\n\n $p = [esp+0x10]\n\n$val = [p]\n\nlog \"secret:{0}\",$val\n\nbphc         \n\nsti        \n\nsti           \n\nmov [$p], $val      \n\nret \n\n```\nIt turned out that [the bug was known but had not been fixed at the moment of our research. After the report, it was](https://github.com/mrexodia/TitanHide/issues/70)\n[fixed. Therefore, this Anti-debugger detection method no longer works.](https://github.com/mrexodia/TitanHide/commit/6a5a68a2447ad9454adfcbd9390ec05b9dcef2d6)\n\nBut this script didn’t solve the problem of running in the virtual environment without a debugger. So we continued our\nmalware analysis and came across an interesting piece of code:\n\nAs it turned out, this piece of code is executed differently in virtual and real environments. An exception occurs after\nthe IF flag is set in the flag register with the popfd command. If we run in a virtual environment, the exception handler\npre-installed by the malware considers that the exception occurred on the “call” instruction.\n\nHowever, when running on a real machine, the exception occurs on the “nop” instruction. Thus, by comparing the\naddresses of the exceptions that occurred, the malware determines the presence of a virtual environment.\n\nBypassing this check is enough to decrease the EIP register value by one when entering the exception handler. After\nthat, the malware is successfully launched.\n\n[After making the necessary corrections on our end, this detection method no longer works in ANY.RUN sandbox.](https://any.run/?utm_source=anyrunblog&utm_medium=article&utm_content=raccoon_stealer)\n\n## Execution process of RecordBreaker malware\n\n**Loading WinAPI libraries, getting addresses of used functions**\n\nFirst, Raccoon dynamically loads WinAPI libraries using kernel32.dll!LoadLibraryW and gets addresses of WinAPI\nfunctions using kernel32.dll!GetProcAddress\n\n\n-----\n\n_Raccoon is dynamically loading needed libraries and getting WinAPI imports addresses_\n\n**Decryption of strings**\n\nDepending on the sample, the algorithm for encrypting strings can be:\n\nencrypted with RC4 algorithm, then encoded into the Base64 format\nXOR encrypted with a random key, e.g.:\n\n_Raccoon Stealer is using XOR_\n\n_strings encryption_\n\nencryption may not be applied at all\n\n**Examples of decrypted strings:**\n\nlogins.json\n\n\\autofill.txt\n\n\\cookies.txt\n\n\\passwords.txt\n\nformhistory.sqlite\n\n…\n\n**C2 servers decryption**\n\nThe next malware step is to decrypt C&C servers. There can be several up to five ones. As in the case of strings, the\nencryption algorithm of C&C servers may vary depending on a sample.\n\nFrom all the samples we have reviewed, at least two methods have been identified:\n\nEncryption using the RC4 algorithm with further recoding to Base64:\n\nRaccoonstealer is using RC4 -> Base64 encryption chain for C2sRaccoonstealer is using RC4 -> Base64\n_encryption chain for C2s_\n\n\n-----\n\nEncryption with XOR:\n\n_XOR C2s encryption_\n\n**Raccoon termination triggers**\n\n\n_Raccoon malware is using_\n\n\nAt this stage the malware has not executed any malicious code yet. There are certain triggers that may cause the\nprogram to terminate without executing any other actions.\n\nThe user’s locale is checked (in some samples, certain locales corresponding to the locales of CIS countries cause\nRaccoon to terminate)\n\n_Raccoon is checking for specific_\n\n_user locale_\n\nA check is made to see if the malware has been rerun, in parallel with another sample running on this machine.\nRecordBreaker tries to open a particular mutex (the value of the mutex varies in different samples). If it succeeds, it\nterminates immediately. If not, it creates the mutex itself.\n\n_Raccoon v2 is_\n\n_checking for a specific mutex_\n\n[We can see the result in ANY.RUN: the mutex was created.](https://any.run/?utm_source=anyrunblog&utm_medium=article&utm_content=raccoon_stealer)\n\n\n-----\n\n_Mutex operations are captured by ANY.RUN interactive sandbox_\n\n**Privilege Level Check**\n\nAfter creating a mutex, the malware performs a System/LocalSystem level privilege check using\nAdvapi32.dll!GetTokenInformation and Advapi32.dll!ConvertSidToStringSidW comparing StringSid with L “S-1-5-18”:\n\n_Raccoonstealer 2.0 is checking for System/LocalSystem privileges_\n\n**Process enumeration**\n\nIf the check shows that RecordBreaker has the privilege level it needs, it starts enumerating processes using the\nTlHelp32 API (kernel32.dll!CreateToolhelp32Snapshot to capture processes and kernel32.dll!Process32First /\nkernel32.dll!Process32Next). In our samples this information isn’t collected or processed in any way.\n\n\n-----\n\n_Raccoon malware is_\n\n_enumerating currently running processes_\n\n**Connecting to C2 servers**\n\nThe next important step is to attempt to connect to one of the C&C servers. To do this, Raccoon stealer generates a\nstring like:\n```\nmachineId={machineguid}|{username}&configId={c2_key}\n\n```\nThen the program tries to send a POST request with the string to every possible server.\n\n_Raccoon Stealer is trying to connect to C2s_\n\n[An example of a connection request that was intercepted by the HTTP MITM proxy feature in ANY.RUN sandbox:](https://any.run/?utm_source=anyrunblog&utm_medium=article&utm_content=raccoon_stealer)\n\nRaccoon info stealer C2 connection requestRaccoon info stealer C2 connection request\n\nIt is important to note that if there are multiple C&C servers, the malware will only accept commands from the one it\nwas able to connect to first. In response to the above request, the server will send the malware a configuration. If\nRecordBreaker fails to connect to any of the C&C servers, it will stop its work.\n\n## Description of the malware configuration structure\n\nConfiguration lines are divided into prefixes, each tells the malware how to interpret a particular line. Here is a table\ndescribing these prefixes and what they do:\n\n\n-----\n\n**Prefix** **Example** **Prefix’s function**\n\n\nlibs_ libs_nss3:http://{HOSTADDR}/{RANDOM_STRING}/nss3.dll\n\nlibs_msvcp140:http://{HOSTADDR}/{RANDOM_STRING}/msvcp140.dll\nlibs_vcruntime140:http://{HOSTADDR}/{RANDOM_STRING}/vcruntime140.dll\n\ngrbr_ grbr_dekstop:%USERPROFILE%\\Desktop\\|*.txt, *.doc, *pdf*|-|5|1|0|files\n\ngrbr_documents:%USERPROFILE%\\Documents\\|*.txt, *.doc, *pdf*||5|1|0|files\n\ngrbr_downloads:%USERPROFILE%\\Downloads\\|*.txt, *.doc, *pdf*|-|5|1|0|files\n\nwlts_ wlts_exodus:Exodus;26;exodus;*;*partitio*,*cache*,*dictionar*\n\nwlts_atomic:Atomic;26;atomic;*;*cache*,*IndexedDB*\n\nwlts_jaxxl:JaxxLiberty;26;com.liberty.jaxx;*;*cache*\n\news_ ews_meta_e:ejbalbakoplchlghecdalmeeeajnimhm;MetaMask;Local Extension\nSettings ews_tronl:ibnejdfjmmkpcnlpebklmnkoeoihofec;TronLink;Local\nExtension Settings\n\news_bsc:fhbohimaelbohpjbbldcngcnapndodjp;BinanceChain;Local Extension\nSettings\n\n\nLegitimate libraries\nnecessary for malware\nwork\n\nTargeted arbitrary files\nfrom custom\ndirectories\n\nTargeted cryptowallets and the files\nassociated with them\n\nTargeted cryptowallet\nrelated extensions for\nGoogle Chrome\n\n\nldr_ [missing in the configuration of the sample] Additional commands\nthat should be\nexecuted by malware\n\n\ntlgrm_ tlgrm_Telegram:Telegram\nDesktop\\tdata|*|*emoji*,*user_data*,*tdummy*,*dumps*\n\n\nTargeted files related\nto the Telegram\nmessenger\n\n\nscrnsht_ scrnsht_Screenshot.jpeg:1 The name of the\nscreenshot(s) that the\nmalware takes in the\nprocess\n\ntoken 101f4cb19fcd8b9713dcbf6a5816dc74 Part of the URL path\nfor further queries to\nC2\n\nsstmnfo_ sstmnfo_System Info.txt:System Information: |Installed applications: | The file description\nwith some system\ndata and a list of\ninstalled applications\nthat the malware will\ngenerate later\n\nOnce the info stealer receives information concerning what kind of data to collect from C2, it proceeds to do so.\n\n## System data collection\n\nThe stealer collects various information about the infected system, including the OS bitness, information about RAM,\nCPU, and user data like the applications installed in the system.\n\n**Raccoon’s mechanisms for data collection:**\n\ngets the size of the main monitor using user32.dll!GetSystemMetrics\n\nRaccoon malware v2 is getting the user’s display resolutionRaccoon malware v2 is getting the user’s display\n_resolution_\n\nfinds a list of GPU devices, using user32.dll!EnumDisplayDevicesW\n\n\n-----\n\n_Raccoon_\n\n_Stealer is iterating through display devices_\n\ndetermines the architecture (bitness) of the system by calling the x64-specific function\nkernel32.dll!GetSystemWow64DirectoryW and comparing the last error code with\nERROR_CALL_NOT_IMPLEMENTED\n\nRaccoon malware v2 is getting the user’s display resolutionRaccoon malware v2 is getting the user’s display\n_resolution_\n\ncollects RAM information via kernel32.dll!GlobalMemoryStatusEx\n\nRaccoon malware ver.2 is checking the user’s system RAM informationRaccoon malware ver.2 is checking the\n_user’s system RAM information_\n\ngets information about the user’s timezone by kernel32!GetTimeZoneInformation:\n\nRaccoon malware is collecting the user’s system timezone dataRaccoon malware is collecting the user’s system\n_timezone data_\n\ngrabs the OS version from the registry, using advapi32.dll!RegOpenKeyExW and\nadvapi32.dll!RegQueryValueExW to read the value of the key\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProductName\n\n_Raccoonstealer gets the user’s OS version_\n\nobtains Information about the vendor of the CPU using asm-instruction __cpuid:\n\n\n-----\n\n_Raccoonstealer 2.0 is_\n\n_getting CPU vendor info_\n\ngets CPU cores number with kernel32.dll!GetSystemInfo\n\nRaccoon malware is getting CPU cores countRaccoon malware is getting CPU cores count\n\ncollects the user’s default locale info requesting kernel32.dll!GetUserDefaultLCID and\nkernel32.dll!GetLocaleInfoW\n\n_Raccoon info stealer is getting the user’s_\n\n_default locale info_\n\ngrabs data about installed apps from the registry using advapi32.dll!RegOpenKeyExW,\nadvapi32.dll!RegEnumKeyExW, and advapi32.dll!RegQueryValueExW.\n\nThe “DisplayName” and “DisplayVersion” values of all\n\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall key sub-keys:\n\nRaccoon malware 2.0 is traversing through the user’s installed applications listRaccoon malware 2.0 is traversing\n_through the user’s installed applications list_\nAfter obtaining the system information, RecordBreaker gets ready to steal user data. The malware loads the\npreviously downloaded legitimate libraries to reach this goal.\n\nRaccoon Stealer is loading previously downloaded legitimate third-party libsRaccoon Stealer is loading previously\n_downloaded legitimate third-party libs_\nThis way the program has the functions needed for operations:\n\n\n-----\n\n_Raccoonstealer gets functions addresses from the newly loaded modules_\n\nOnce the libraries have been loaded, Raccoon starts to collect user data.\n\n## User data collection\n\n**Cookies**\n\nFirst of all, the stealer collects cookies. It creates a copy of the cookies file and tries to open it. If it fails to do so, the\ncurrent subroutine is terminated.\n\n_Raccoon malware v2 is copying the cookies database and trying to open it_\n\nIf the sample manages to open the database, it retrieves cookies from it by executing the SQL query\n```\nSELECT host, path, isSecure, expiry, name, value FROM moz_cookies\n\n```\n.\n\n\n-----\n\n_Raccoon_\n\n_stealer v2 is executing a SQL request to retrieve data from the cookies database_\n\n**Autofill data**\n\nThe next step in Raccoon’s “plan” is to retrieve the autofill data. The program tries to open the database logins.json:\n\n\n-----\n\n_Raccoon Stealer 2.0 is trying to open the logins.json database_\n\nThen the stealer tries to decrypt the data from that database, using the Зnss3.dll!PK11SDR_Decrypt method.\n\n_Raccoon malware 2.0 decrypts encrypted_\n\n_logins.json database_\n\nAfter that, the malware formats collected data like so:\n```\n“URL:%s\\nUSR:%s\\nPASS:%s”\n\n```\n\n-----\n\nUsing encrypted data, Raccoon malware formats it to a more readable stateUsing encrypted data, Raccoon\n_malware formats it to a more readable state_\n\n**Autofill form data**\n\nAfter these manipulations, the stealer collects the autofill form data. It attempts to open the formhistory.sqlite\ndatabase:\n\n_Raccoon info stealer tries to open another database_\nIf the connection to the database is successful, the program retrieves form data values from it with an SQL query\nlike:\n```\nSELECT name, value FROM autofill\n\n```\n\n-----\n\n_Raccoonstealer is executing another SQL request to retrieve data_\n[RecordBreaker concatenates all data together and sends POST requests to C2. ANY.RUN sandbox’s HTTP MITM](https://any.run/?utm_source=anyrunblog&utm_medium=article&utm_content=raccoon_stealer)\nproxy feature intercepts all the data that the malware has managed to collect.\n\nSystemInfo POST request\n\n\n-----\n\n_System info request made by Raccoon aka RecordBreaker_\n\nUserInfo POST request\n\n_User info request made by Raccoon malware_\nWhen the C2 server gets each chunk of data, it responds “received”:\n\nC2 server responds\n\n## Crypto-wallets, Custom, and Telegram file data collection\n\n**Crypto-wallets data**\n\nRecordBreaker is looking for users’ crypto-wallets data using filters and templates retrieved from the configuration.\n\n\n-----\n\n_RecordBreaker is looking for the user’s crypto-wallets data_\n\n**Custom files**\n\nThen, the wallet.dat file is searched (it contains local information about the bitcoin wallet). After that, the stealer looks\nfor arbitrary files from custom directories specified in the configuration.\n\n\n-----\n\n_Raccoonstealer is looking for any custom files_\n\n**Telegram messenger files**\n\nThe sample is looking for files related to Telegram messenger using data from the configuration.\n\n\n-----\n\n_RecordBreaker is looking for files related to Telegram messenger_\nAfter the malware has sent all the files, it takes a screenshot(s).\n\n_screenshots of the user’s environment_\n\n[An example of a screenshot captured by ANY.RUN:](https://any.run/?utm_source=anyrunblog&utm_medium=article&utm_content=raccoon_stealer)\n\n\n_Raccoon malware v2 is making_\n\n\n-----\n\n_The screenshot made by the 2d version of Raccoon malware_\n\nIf any additional commands are provided in configuration, the sample will execute them before finishing its work. For\nexample, Raccoon executes other commands with the help of WinAPI (shell32.dll!ShellExecuteW) if C2 has sent\nthem in the prefix ldr_:\n\n_Raccoonstealer executes extra commands_\nThen, the malware releases the remaining allocated resources, unloads the libraries, and finishes its work.\n\n## Raccoon configuration extraction\n\nYou can use our Python script to extract C2 servers from the unpacked Raccoon sample, or get malware\n[configuration right in our service, which will unpack the sample from memory dumps and extract C2s for you:](https://app.any.run/tasks/df94e59b-fa59-4f8f-ba81-93781e82046f)\n\n\n-----\n\n_Raccoon malware configuration_\n\n\n-----\n\n```\n p, y,, g\nfrom enum import IntEnum\n\nfrom base64 import b64decode, b64encode\n\nfrom malduck import xor, rc4, base64\n\n# c2 buffer len & invalid c2 placeholder\n\nRACCOON_C2_PLACEHOLDER = b\" \" * 64\n\nRACCOON_C2_BUFF_LEN = len(RACCOON_C2_PLACEHOLDER)\n\n# c2s array size & key size\n\nRACCOON_C2S_LEN = 5\n\nRACCOON_KEY_LEN = 32\n\nclass ERaccoonBuild(IntEnum):\n\n  UNKNOWN_BUILD = -1,\n\n  OLD_BUILD = 0,\n\n  NEW_BUILD = 1\n\n# extracts ascii and unicode strings from binary file\n\nclass RaccoonStringExtractor:\n\n  ASCII_BYTE = string.printable.encode()\n\n  c2_list = []\n\n  rc4_key = str()\n\n  xor_key = str()\n\n  raccoon_build = ERaccoonBuild.UNKNOWN_BUILD\n\n  def __init__(self, binary_path) -> None:\n\n    with open(binary_path, 'rb') as bin:\n\n      self.buffer = bin.read()\n\n    self.__process_strings()\n\n  def __is_base64_encoded(self, data) -> bool:\n\n    try:\n\n      data = data.rstrip()\n\n      return b64encode(b64decode(data)) == data\n\n    except Exception:\n\n      return False\n\n  def __is_valid_key(self, key) -> bool:\n\n    key_re = re.compile(rb\"^[a-z0-9]{%d,}\" % RACCOON_KEY_LEN)\n\n    return re.match(key_re, key)\n\n  def __process_strings(self) -> None:\n\n    ascii_re = re.compile(rb\"([%s]{%d,})\" % (self.ASCII_BYTE, 4))\n\n    self.c2_list = []\n\n    ascii_strings = []\n\n    for i, match in enumerate(ascii_re.finditer(self.buffer)):\n\n      a_string = match[0]\n\n      offset = match.start()\n\n      string_entry = (a_string, offset)\n\n      ascii_strings.append(string_entry)\n\n      if len(a_string) == RACCOON_C2_BUFF_LEN and \\\n\n        a_string != RACCOON_C2_PLACEHOLDER and \\\n\n          self.__is_base64_encoded(a_string) == True:\n\n        self.raccoon_build = ERaccoonBuild.OLD_BUILD\n\n        print(f\"[+] found possible encrypted c2 {a_string.rstrip()} at {hex(offset)}\")\n\n        self.c2_list.append(string_entry)\n\n          if len(self c2 list) == 1: # first c2 found\n\n```\n\n-----\n\n```\n              _ y, _ g [ ]\n          # rc4 key should be 32-bytes long and contain only a-z 0-9 chars\n\n          if self.__is_valid_key(rc4_key):\n\n            self.rc4_key = rc4_key\n\n            print(f\"[+] found possible rc4 key {self.rc4_key} at {hex(offset)}\")\n\n          else:\n\n            continue\n\n    # have we found any c2s yet?\n\n    if len(self.c2_list) == 0:\n\n      for a_string, offset in ascii_strings:\n\n        if len(a_string) == RACCOON_KEY_LEN and self.__is_valid_key(a_string):\n\n          self.raccoon_build = ERaccoonBuild.NEW_BUILD\n\n          self.xor_key = a_string\n\n          print(f\"[+] found possible xor key {self.xor_key} at {hex(offset)}\")\n\n          # extract c2s for new builds\n\n          curr_offset = offset + 36\n\n          for _ in range(0, RACCOON_C2S_LEN):\n\n            enc_c2 = self.buffer[curr_offset : curr_offset + RACCOON_C2_BUFF_LEN]\n\n            if enc_c2.find(0x20) != 0 and enc_c2 != RACCOON_C2_PLACEHOLDER: # check if c2 is\nempty\n\n              print(f\"[+] found possible encrypted c2 {enc_c2.rstrip()} at\n{hex(curr_offset)}\")\n\n              self.c2_list.append((enc_c2, curr_offset))\n\n            curr_offset += RACCOON_C2_BUFF_LEN + 8 # each c2 is padded by 8 bytes\n\n          return # don't process strings any further\n\n    else:\n\n      return\n\n    print(f\"[!] C2Cs not found, could be a new build of raccoon sample\")\n\nclass RaccoonC2Decryptor:\n\n  def __init__(self, sample_path: str) -> None:\n\n    self.extractor = RaccoonStringExtractor(sample_path)\n\n  def __is_valid_c2(self, c2):\n\n    return re.match(\n\n      rb\"((https?):((//)|(\\\\\\\\))+([\\w\\d:#@%/;$()~_?\\+-=\\\\\\.&](#!)?)*)\", c2\n    )\n\n  def decrypt(self) -> bool:\n\n    raccoon_build = self.extractor.raccoon_build\n\n    if raccoon_build == ERaccoonBuild.OLD_BUILD:\n\n      return self.decrypt_method_1()\n\n    elif raccoon_build == ERaccoonBuild.NEW_BUILD:\n\n      return self.decrypt_method_2()\n\n    else:\n\n      return False # unknown raccoon build\n\n  def decrypt_method_1(self) -> None:\n\n    for enc_c2, _ in self.extractor.c2_list:\n\n      decrypted_c2 = rc4(\n\n        self.extractor.rc4_key,\n\n        base64(enc_c2.rstrip())\n\n      )\n\n      if self.__is_valid_c2:\n\n        print(f\"[>] decrypted c2: {decrypted_c2}\")\n\n      else:\n\n        print(f\"[!] invalid c2: {decrypted_c2}\")\n\n  def decrypt method 2(self) -> None:\n\n```\n\n-----\n\n```\n         _, _ _\n      decrypted_c2 = xor(\n\n        self.extractor.xor_key,\n\n        enc_c2.rstrip()\n\n      )\n\n      if self.__is_valid_c2:\n\n        print(f\"[>] decrypted c2: {decrypted_c2}\")\n\n      else:\n\n        print(f\"[!] invalid c2: {decrypted_c2}\")\n\ndef main():\n\n  # parse arguments\n\n  if len(sys.argv) == 2:\n\n    sample_path = os.path.abspath(sys.argv[1])\n\n  else:\n\n    print(f\"[!] usage: {os.path.basename(__file__)} <sample path>\")\n\n    return False\n\n  try:\n\n    RaccoonC2Decryptor(sample_path).decrypt()\n\n  except Exception as ex:\n\n    print(f\"[!] exception: {ex}\")\n\nif __name__ == '__main__':\n\n  main()\n\n```\n**IOCs:**\n\nFilename SHA-256\n\n\\AppData\\LocalLow\\nss3.dll c65b7afb05ee2b2687e6280594019068c3d3829182dfe8604ce4adf2116cc46e\n\n\\AppData\\LocalLow\\msvcp140.dll 2db7fd3c9c3c4b67f2d50a5a50e8c69154dc859780dd487c28a4e6ed1af90d01\n\n\\AppData\\LocalLow\\vcruntime140.dll 9d02e952396bdff3abfe5654e07b7a713c84268a225e11ed9a3bf338ed1e424c\n\n\\AppData\\LocalLow\\mozglue.dll 4191faf7e5eb105a0f4c5c6ed3e9e9c71014e8aa39bbee313bc92d1411e9e862\n\n\\AppData\\LocalLow\\freebl3.dll b2ae93d30c8beb0b26f03d4a8325ac89b92a299e8f853e5caa51bb32575b06c6\n\n\\AppData\\LocalLow\\softokn3.dll 44be3153c15c2d18f49674a092c135d3482fb89b77a1b2063d01d02985555fe0\n\n\\AppData\\LocalLow\\sqlite3.dll 1b4640e3d5c872f4b8d199f3cff2970319345c766e697a37de65d10a1cffa102\n\n**HTTP/HTTPS Requests:**\n\n[http://[C2 address]/](http://10.10.0.46/about:blank)\n\n[http://[C2 address] /aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/nss3.dll](http://10.10.0.46/about:blank)\n\n[http://[C2 address]/aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/msvcp140.dll](http://10.10.0.46/about:blank)\n\n[http://[C2 address]/aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/vcruntime140.dll](http://10.10.0.46/about:blank)\n\n[http://[C2 address]/aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/mozglue.dll](http://10.10.0.46/about:blank)\n\n[http://[C2 address]/aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/freebl3.dll](http://10.10.0.46/about:blank)\n\n[http://[C2 address]/aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/sqlite3.dll](http://10.10.0.46/about:blank)\n\n[http://[C2 address]/[config token]](http://10.10.0.46/about:blank)\n\n\n-----\n\n[http://[C2 address]/aN7jD0qO6kT5bK5bQ4eR8fE1xP7hL2vK/softokn3.dll](http://10.10.0.46/about:blank)\n\n## Conclusion\n\n[We have done malware analysis of the Raccoon stealer 2.0 performance using a v2 sample in ANY.RUN sandbox.](https://any.run/?utm_source=anyrunblog&utm_medium=article&utm_content=raccoon_stealer)\nThe examined sample has used various techniques to evade detection: legitimate libraries for data collection,\ndynamic library loading, string encryption, and C&C server encryption. Some examples are additionally protected by\npackers or being a part of other malware.\n\nCopy the script of Raccoon stealer and try to extract C2 servers by yourselves and let us know about your results.\n\nAnd write in the comments below what other malware analysis you are interested in. We will be glad to add it to the\nseries!\n\n[malware analysis](https://any.run/cybersecurity-blog/tag/malware-analysis/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-30 - Raccoon Stealer 2.0 Malware analysis.pdf"
    ],
    "report_names": [
        "2022-08-30 - Raccoon Stealer 2.0 Malware analysis.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536113,
    "ts_updated_at": 1743041163,
    "ts_creation_date": 1662028197,
    "ts_modification_date": 1662028197,
    "files": {
        "pdf": "https://archive.orkl.eu/d6444702fdc74d70a58b714b3be620285e3009f1.pdf",
        "text": "https://archive.orkl.eu/d6444702fdc74d70a58b714b3be620285e3009f1.txt",
        "img": "https://archive.orkl.eu/d6444702fdc74d70a58b714b3be620285e3009f1.jpg"
    }
}