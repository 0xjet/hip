{
    "id": "416cdbaf-f53d-497b-be2b-aed9993c3a40",
    "created_at": "2023-01-12T15:05:52.908533Z",
    "updated_at": "2025-03-27T02:11:34.422894Z",
    "deleted_at": null,
    "sha1_hash": "449a92698bbcf1d46a02b6d3cb4c53f0e9443717",
    "title": "2022-03-08 - Daxin Backdoor- In-Depth Analysis, Part One",
    "authors": "",
    "file_creation_date": "2022-05-28T23:22:48Z",
    "file_modification_date": "2022-05-28T23:22:48Z",
    "file_size": 2589273,
    "plain_text": "# Daxin Backdoor: In-Depth Analysis, Part One\n\n**[symantec-enterprise-blogs.security.com/blogs/threat-intelligence/daxin-malware-espionage-analysis](https://symantec-enterprise-blogs.security.com/blogs/threat-intelligence/daxin-malware-espionage-analysis)**\n\nThreat Hunter TeamSymantec\n\n## In the first of a two-part series of blogs, we will delve deeper into Daxin, examining the driver initialization, networking, key exchange, and backdoor functionality of the malware.\n\n[Following on from our earlier blog detailing the discovery of Backdoor.Daxin, Symantec’s](https://symantec-enterprise-blogs.security.com/blogs/threat-intelligence/daxin-backdoor-espionage)\nThreat Hunter Team, part of Broadcom Software, would like to provide further technical\ndetails on this threat.\n\nUsed by a China-linked espionage group, Daxin exhibits technical sophistication previously\nunseen by such actors. In particular, it implements communications features that appear to\nhave been designed for deep penetration of highly-secured networks. The focus of this blog\nseries is to document how these features were implemented.\n\n\n-----\n\nDaxin comes in the form of a Windows kernel driver. In this blog, we will detail the driver\ninitialization, networking, key exchange, and backdoor functionality. In our next blog, the\nsecond of two, we will examine the communications and network features of the malware.\n\nOur analysis is based on a Backdoor.Daxin sample (SHA256:\nea3d773438c04274545d26cc19a33f9f1dbbff2a518e4302addc1279f9950cef). The forensic\nevidence collected by us indicates that this sample had been deployed in November 2021\nagainst two separate organizations.\n\nThe described Daxin features are contained in many earlier Daxin variants unless stated\notherwise. The recent changes to the driver codebase are to support more recent Windows\nversions and fix certain bugs.\n\n## Driver initialization\n\nThe Daxin sample analyzed appears to be packed with a standard VMProtect packer. Many\nearlier samples feature an additional, outside, packing layer on top of VMProtect. That\noutside packer was custom-made for the driver and even reused the same customized\nencryption algorithm used in the final payload. We believe that the attackers decided to\nremove that custom packer due to compatibility issues with recent Windows releases.\n\nWhenever the driver is started, the code added by the packer decrypts and decompresses\nthe final payload, and then passes control to the entry point of the decompressed payload. At\nthis point, the malicious code is visible in kernel memory, albeit with some obfuscations.\n\nThe bulk of the payload initialization code is involved with the network stack of the Windows\nkernel. This includes identification of some non-exported structures and hooking of the\nWindows TCP/IP stack.\n\nDaxin hooks the Network Driver Interface Specification (NDIS) layer by modifying every preexisting NDIS_OPEN_BLOCK for the TCP/IP protocol, where the ReceiveNetBufferLists and\n_ProtSendNetBufferListsComplete handlers are replaced with its own. For each of these_\n_NDIS_OPEN_BLOCKs, the related NDIS_M_DRIVER_BLOCK may also be modified by_\nreplacing any existing SendNetBufferListsHandler. When the SendNetBufferListsHandler is\nnot present, the corresponding NDIS_MINIPORT_BLOCK is modified by replacing\n_NextSendNetBufferListsHandler._\n\nTo identify all NDIS_OPEN_BLOCKs for the TCP/IP protocol, the driver relies on calling\n_NdisRegisterProtocol() to create and return a new head of non-exported ndisProtocolList._\nThen it walks ndisProtocolList of every NDIS_PROTOCOL_BLOCK comparing the Name\nattribute of each visited NDIS_PROTOCOL_BLOCK structure with the string “TCPIP”. The\n_OpenQueue field of the matching structure points to the list of NDIS_OPEN_BLOCKs to_\n\n\n-----\n\n[hook. This basic technique is known and documented, but Daxin hooks a slightly different set](https://www.blackhat.com/presentations/bh-usa-06/BH-US-06-Tereshkin.pdf)\nof handlers. We believe that these adjustments are not exclusive to Daxin and are driven by\narchitectural changes in Windows Network Architecture.\n\nIn order to identify the related NDIS_M_DRIVER_BLOCKs and NDIS_MINIPORT_BLOCKs,\nthe driver analyses “ndis.sys” machine code to locate non-exported\n_ndisFindMiniportOnGlobalList() and ndisMiniDriverList. The relevant_\n_NDIS_MINIPORT_BLOCKs are then obtained starting with the previously identified_\n_NDIS_OPEN_BLOCKs, where the RootDeviceName of each instance is passed as a_\nparameter for the ndisFindMiniportOnGlobalList() call that returns the structure to hook.\nFinally, to locate related NDIS_M_DRIVER_BLOCKs, the driver walks ndisMiniDriverList\nchecking the MiniportQueue list of each item for the already identified\n_NDIS_MINIPORT_BLOCKs._\n\nDetails of the hooking process demonstrated in this blog were captured in the lab using a\nvirtual machine with a kernel debugger attached.\n\nWhen registering the fake protocol, Daxin calls the NdisRegisterProtocol() API passing a\n_ProtocolCharacteristics argument with the hardcoded Name attribute “NDISXRPT”._\n\n\n-----\n\nFigure 1. Hardcoded name and obfuscated NdisRegisterProtocol() call.\nBecause the layout of the NDIS_OPEN_BLOCK structure changes between different\nWindows builds, Daxin needs to determine the correct offsets to use. First it checks\n_NtBuildNumber against a set of hardcoded values for which NDIS_OPEN_BLOCK offsets_\nare explicitly given (Figure 2).\n\n\n-----\n\nFigure 2: Daxin checks NtBuildNumber against a set of hardcoded values for which\nNDIS_OPEN_BLOCK offsets are explicitly given.\nThe most recent Windows build number hardcoded in Daxin’s codebase is 17763. It\ncorresponds to Windows Server 2019 and Windows 10 version 1809 (Redstone 5). When\nthe Windows build is not recognized, Daxin attempts to use an alternative method to\ndetermine the NDIS_OPEN_BLOCK offsets.\n\nDaxin then collects details of all NDIS structures to hook, as discussed earlier, along with\ninformation about the related network interfaces. Finally, for each network interface, it\nreplaces the original handlers with its own.\n\n\n-----\n\nFigure 3. For each network interface, Daxin replaces the original handlers with its own.\n\n## Networking\n\nBoth the ReceiveNetBufferLists hook and the SendNetBufferListsHandler (or\n_NextSendNetBufferListsHandler) hook implement logic to inspect the network packets and_\nthen hijack some packets before passing the remaining packets to the original handlers. The\n_ProtSendNetBufferListsComplete hook completes any send operation initiated by Daxin,_\nsuch that NET_BUFFER_LIST structures owned by malware are removed and deallocated\nbefore calling the original handler.\n\nBefore describing the hooks’ implementation in detail, we will first examine a few examples\nof the observed behavior in Daxin.\n\n\n-----\n\nIn the first scenario, the ReceiveNetBufferLists hook checks the data section of certain TCP\npackets for predefined patterns. Any matching TCP packets are then removed from the\n_NetBufferLists before calling the original ReceiveNetBufferLists handler. At the same time,_\nfor each removed TCP packet, the malicious driver sends two new packets. The first packet\nis a spoofed RST TCP packet sent to the original destination, so that its recipient marks the\nTCP connection as closed. The second packet is an ACK TCP packet sent to the original\nsource. From that point, the malicious driver maintains the TCP connection with the original\nsource, relying on the ReceiveNetBufferLists hook to hijack any related network packets. A\ntest demonstrating this scenario is illustrated in Figure 4.\n\n\n-----\n\nFigure 4. The ReceiveNetBufferLists hook checks the data section of certain TCP packets for\na predefined “magic” pattern before hijacking the connection.\n\n\n-----\n\nWhen generating its network traffic, Daxin uses its own code to forge network packets,\nbypassing the legitimate Windows TCP/IP stack. To illustrate this, we reconfigured the\nWindows TCP/IP stack to use non-standard Time to Live (TTL). Since Daxin does not\nrespect the updated parameter, its traffic stands out in the Wireshark capture shown in\nFigure 4.\n\nThe TCP retransmissions in the Wireshark capture are due to our scripts for the kernel\ndebugger that slow down driver response. The retransmissions are not expected otherwise.\nWe decided to activate these scripts to illustrate the internal working of the driver, where we\ncan recognize individual packets from our Wireshark capture, as illustrated in Figure 5.\n\n\n-----\n\nFigure 5. By capturing individual packets, we can illustrate the internal working of Daxin.\nIn another scenario, Daxin initiates a new TCP connection and maintains it over the whole\nlifetime of the TCP session. The malware relies on the ReceiveNetBufferLists hook to hijack\nany network packets related to this connection. The hijacked packets do not reach the\nlegitimate Windows TCP/IP driver. An example TCP connection initiated by the malicious\ndriver will be discussed later in this blog series.\n\nIn the last scenario, Daxin sends a DNS request using the UDP protocol. The response UDP\npacket is hijacked by the ReceiveNetBufferLists hook and the DNS response is parsed by\nthe malicious driver. We exercised this functionality in our lab when exploring configuration\noptions related to command-and-control connectivity.\n\nThe described scenarios indicate that Daxin implements its own TCP/IP stack. This was\nconfirmed with further reverse engineering of the driver, where we identified both data\nstructures and subroutines implementing IPv4, TCP, and UDP.\n\nThe main purpose of the NDIS hooks installed by Daxin is to allow for its malicious TCP/IP\nstack to coexist with the legitimate Windows TCP/IP stack on the same machine. When\ncertain conditions are met, the hooks also allow it to hijack pre-existing TCP connections.\n\nThe ReceiveNetBufferLists hook checks the NblFlags member of the NET_BUFFER_LIST\nstructure at the head of its NetBufferLists argument for the\n_NDIS_NBL_FLAGS_IS_LOOPBACK_PACKET flag. Whenever the flag is set, the hook_\nsimply passes the network data to the original ReceiveNetBufferLists handler with no other\nprocessing. Otherwise, it calls a helper subroutine passing the NetBufferLists linked list of\n_NET_BUFFER_LISTs. The helper subroutine divides the original linked list of_\n_NET_BUFFER_LISTs into two chains: one chain of allowed packets for further processing by_\nthe legitimate stack and another chain of hijacked packets to drop. The hook then passes the\n\n\n-----\n\nchain of allowed packets to the original ReceiveNetBufferLists handler. Next, if the\n_NDIS_RECEIVE_FLAGS_RESOURCES flag is not set in its ReceiveFlags argument, the_\nhook releases ownership of the chain of hijacked packets using NdisReturnNetBufferLists().\n\nThe SendNetBufferListsHandler hook checks if the NdisPoolHandle member of the\n_NET_BUFFER_LIST structure, passed as its NetBufferList argument, corresponds to the_\npool created by Daxin itself to use when sending malicious traffic. If so, the hook simply\npasses the network data to the original SendNetBufferListsHandler with no other processing.\nOtherwise, it calls the same helper subroutine as used by the ReceiveNetBufferLists hook to\ndivide its NetBufferList argument into two chains. It then passes the chain of allowed packets\nto the original SendNetBufferListsHandler. Finally, the chain of hijacked packets is retired\nusing the NdisMSendNetBufferListsComplete() or ProtSendNetBufferListsComplete handler.\n\nThe helper subroutine used by both hooks walks the original linked list of\n_NET_BUFFER_LISTs extracting network packets from each visited NET_BUFFER_LIST_\nstructure and calling the malicious packet filter for each extracted packet. The verdict\nreturned by the packet filter for the first packet from the visited NET_BUFFER_LIST structure\ndetermines if the structure should be allowed for further processing by the legitimate stack or\ndropped by the hook.\n\nThe packet filter is central to the networking capabilities of Daxin as it controls dispatching of\nthe extracted packets to various Daxin's sub-modules, where each sub-module implements\ndifferent functionality. The filter returns an “accept” or “drop” verdict to indicate if relevant\npackets should reach the legitimate TCP/IP stack or not. It operates as follows:\n\n1. Checks if the packet is related to any of the network flows from the malicious network\n\ntunnel. If so, it captures the packet for forwarding to the remote attacker via an\nencrypted channel and returns with a “drop” verdict.\n2. Checks if the Ethernet source and destination MAC addresses are equal. If so, it\n\nreturns with an “accept” verdict.\n3. In cases where it was called from the ReceiveNetBufferLists hook, it checks if the\n\nEthernet source MAC address corresponds to any of the network interfaces of the local\nmachine. If so, it returns with an “accept” verdict.\n4. In cases of TCP over IPv4 packets, it tracks certain parameters of an active TCP\n\nconnection for use by TCP hijacking logic in the future (if needed).\n5. In cases of non-IPv4 packets or when called from the ReceiveNetBufferLists hook, it\n\ncalls each handler from the list of Daxin’s packet handlers, stopping on the first handler\nthat claims ownership of the packet. Whenever Daxin’s handler claims ownership on\nthe IPv4 packet, the filter returns with a “drop” verdict.\n\n\n-----\n\nThese Daxin packet handlers are dynamically registered and unregistered by the\nmalicious TCP/IP stack as required, minimizing the overhead. Furthermore, in case of\nTCP, the list of handlers is bucketed by the server port (which supports TCP servers\nlistening for new connections) or the combination of client and server ports (which\nsupports TCP sessions). The packet is parsed before calling handlers and the parser\nlogic limits the combination of supported protocols to ARP, UDP over IPv4, and TCP\nover IPv4.\n\n1. In cases of TCP over IPv4 packets when called from the ReceiveNetBufferLists hook, it\n\nchecks that the TCP data in the packet:\n\nStarts with the string “POST” and contains the string “756981520337” without any\nline break “\\r\\n” in-between, or\nStarts with the sequence of bytes 0x10 0x99 0x10 and is at least eight-bytes long,\nor\nStarts with the sequence of bytes 0x10 0x99 0x11 and is at least eight-bytes long\n\nWhen a match is found, it triggers hijacking of the related TCP connection and returns\nwith a “drop” verdict. It should be noted that these checks are not limited to the start of\nthe TCP conversation, and so it is possible to trigger hijacking after exchanging an\narbitrary amount of data. This provides the option to start communication with the\nmalicious driver at the end of a long conversation with a legitimate server hosted on the\ninfected computer.\n\nFinally, the ProtSendNetBufferListsComplete hook walks the list of NET_BUFFER_LIST\nstructures passed as its second argument checking if the NdisPoolHandle member of the\nvisited NET_BUFFER_LIST structure corresponds to the pool created by the malicious driver\nitself to use when sending malicious traffic. The matching structures are removed from the\nlist and, after validating the Flags member, deallocated. The hook then passes the modified\nlist to the original ProtSendNetBufferListsComplete handler.\n\nA [technical paper by Kaspersky on the Slingshot advanced persistent threat (APT) group](https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2018/03/09133534/The-Slingshot-APT_report_ENG_final.pdf)\ndescribes a technique to identify NET_BUFFER_LIST that is very similar to how the\n_ProtSendNetBufferListsComplete hook works, including the use of_\n_NdisAllocateNetBufferListPool() and NdisAllocateNetBufferAndNetBufferList(). However,_\nthere are no other significant structural overlaps.\n\n## Key exchange\n\nWhenever Daxin hijacks a TCP connection, it checks the received data for a specific\nmessage. The expected message initiates a custom key exchange, where two peers follow\ncomplementary steps. When discussing this key exchange protocol, we are going to use the\nterm “initiator” when referring to the side sending the initial message. The opposite side will\nbe called “target”. Interestingly, the analyzed sample can implement both the initiator side\nand the target side of this custom key exchange protocol.\n\n\n-----\n\nFirstly, Daxin starts the target-side protocol for each hijacked TCP connection. Additionally, it\ncan be configured to connect to a remote TCP server, where it exchanges a certain\nhandshake and then also starts the target-side protocol. This scenario will be discussed in\nour next blog in this series in a section titled “External communication.” Finally, Daxin can be\ninstructed to connect to a remote TCP server, where it starts the initiator-side protocol. We\nwill expand on this in the next section.\n\n## Backdoor capabilities\n\nA successful key exchange opens an encrypted communication channel. Daxin uses this\ncommunication channel to exchange various messages. Some messages instruct the\nmalware to perform various operations, such as starting an arbitrary process on the affected\ncomputer. Others carry results of these operations, such as output generated by the started\nprocess, for example. The set of operations recognized by Daxin is rather compact, with the\nmost basic operations being reading and writing arbitrary files.\n\nDaxin can also execute arbitrary EXE and DLL binaries. In the case of EXE files, Daxin starts\na new user-mode process. The standard input and output of the started process is\nredirected, so that the remote attacker can interactively send input and receive output. When\nordered to execute a DLL file, Daxin performs injection into one of the pre-existing\n“svchost.exe” processes.\n\nDaxin provides a dedicated communication mechanism for any additional components\ndeployed by the attacker on the affected computer. Any compatible component can open a\n“\\\\.\\Tcp4” device created by Daxin to register itself for communication, where it can optionally\nassign a 32-bit service identifier to distinguish itself from other services that may be active on\nthe same computer. Daxin then forwards any matching communication between the remote\nattacker and registered services.\n\nNext, the remote attacker can inspect and update the backdoor configuration. The\nconfiguration is implemented as a generic key-value structure that is stored in an encrypted\nform in the Windows Registry for persistence. All used configuration items will be listed in the\n“External communication” section in a subsequent blog.\n\nThere are also dedicated messages that encapsulate raw network packets to be transmitted\nvia a local network adapter. Any response packets are then captured by the malicious driver\nand forwarded to the remote attacker. This allows the remote attacker to establish\ncommunications with any servers reachable from the affected machine on the target’s\nnetwork, creating a network tunnel for the remote attacker to interact with servers of interest.\n\nFinally, a special message can be used to set up new connectivity across multiple malicious\nnodes, where the list of nodes is included in a single command. For each node, the message\nprovides the details required to establish communication, specifically the node IP address, its\nTCP port number, and the credentials to use during custom key exchange. When Daxin\n\n\n-----\n\nreceives this message, it picks the next node from the list. Then it uses its malicious TCP/IP\nstack to connect to the TCP server listed in the picked entry. Once connected, Daxin starts\nthe initiator-side protocol. On the peer computer, if it is infected with a copy of Daxin, the\ninitiator traffic causes the TCP connection to be hijacked, as explained earlier. This is\nfollowed by the custom key exchange to open a new encrypted communication channel.\nNext, the connecting driver sends an updated copy of the original message over this new\nchannel, where the position of the next node to use is incremented. The process then\nrepeats for the remaining nodes on the list.\n\nThe TCP connections created during the above process, along with the connection that\nreceived the original connectivity setup instruction are then used for subsequent\ncommunications. Whenever an intermediate node receives a message, it may execute the\nrequested operation or forward it along the connectivity path. For certain operations, the\nnode to execute the operation is specified by the position along the path. In some remaining\ncases, the operation is always forwarded to the last node. Finally, certain operations are\nalways executed by the first node only.\n\nThis method to create multi-hop connectivity is noteworthy. It is not uncommon for the\nattackers to jump through multiple hops in victim networks to get around firewalls or to better\nblend in with usual network traffic. This usually involves multiple steps when using other\nmalware, where each jump requires a separate action. However, in the case of the analyzed\nsample, the attackers combined these into a single operation. This may indicate that Daxin is\noptimized for attacks against well-protected networks and cases when the attackers need to\nperiodically reconnect into the compromised network.\n\nThe ability to use hijacked TCP connections for backdoor communications is also significant.\nThis may be required when exploiting tightly controlled networks, with strict firewall rules or\nwhen the defenders monitor for network anomalies. On the infected machine, any malicious\nnetwork connections are bypassing the Windows TCP/IP stack, and this could provide some\ndegree of stealth. The attackers invested significant effort in implementing these features\nwith a malicious TCP/IP stack supporting TCP connection hijacking.\n\nThe implementation of network tunneling, where the malicious driver passes the packets\ndirectly between the remote attacker and the target’s network demonstrates how the\nattackers attempt to minimize their footprint without sacrificing functionality.\n\n## Backdoor demonstration\n\nIn order to demonstrate Daxin’s backdoor capabilities, we prepared a lab setup to both\nillustrate what was described in the previous section and also to collect some examples of\nmalicious network traffic to discuss later.\n\n\n-----\n\nOur lab setup consisted of four separate networks and five machines. Some of the machines\nhad two network interfaces to communicate with different networks, but all packet forwarding\nfunctionality was disabled. Each machine ran various network services that were reachable\nfrom its neighbors only.\n\nFigure 6. Test setup to illustrate Daxin’s backdoor capabilities.\nIn our setup, the attackers can communicate with “Alice-PC”, while all of the other machines\nare unreachable directly to the attackers. This simulates the network of a hypothetical victim,\nwhere machines serving different roles have very restrictive connectivity. “Alice-PC” could\nrepresent a DMZ service that is accessible from the internet, but all the other machines are\ntightly isolated.\n\n\n-----\n\nWe infected all of the configured machines with Daxin, except for just one machine deep in\nour network that was left clean. Next, based on our understanding of the malicious\ncommunications protocol gained during reverse engineering of the malicious driver, we\nimplemented a rough client to interact with the Daxin backdoor running on “Alice-PC”. We\nused this client to instruct the backdoor on “Alice-PC” to create a communications channel to\n“Dave-PC” passing via two intermediate nodes: “Bob-PC” and “Charlie-PC”. The connectivity\nwas established successfully, and we were able to interact with all the infected machines.\nFinally, we were able to use this malicious network tunnel via “Dave-PC” to communicate\nwith legitimate services on “Clean-PC”.\n\n## Conclusion\n\nThis concludes the first part of our technical analysis of Daxin. In our second, and final blog,\nwe will examine the communications and networking features of the malware.\n\nBroadcomSymantec Enterprise Blogs\nYou might also enjoy\n\nThreat Intelligence9 Min Read\n\n## Daxin: Stealthy Backdoor Designed for Attacks Against Hardened Networks\n\n### Espionage tool is the most advanced piece of malware Symantec researchers have seen from China-linked actors.\n\n## About the Author\n\n\n-----\n\n### Threat Hunter Team\n\n**Symantec**\n\nThe Threat Hunter Team is a group of security experts within Symantec whose mission is to\ninvestigate targeted attacks, drive enhanced protection in Symantec products, and offer\nanalysis that helps customers respond to attacks.\n\n## Want to comment on this post?\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-08 - Daxin Backdoor- In-Depth Analysis, Part One.pdf"
    ],
    "report_names": [
        "2022-03-08 - Daxin Backdoor- In-Depth Analysis, Part One.pdf"
    ],
    "threat_actors": [
        {
            "id": "72aaa00d-4dcb-4f50-934c-326c84ca46e3",
            "created_at": "2023-01-06T13:46:38.995743Z",
            "updated_at": "2025-03-27T02:00:02.972623Z",
            "deleted_at": null,
            "main_name": "Slingshot",
            "aliases": [],
            "source_name": "MISPGALAXY:Slingshot",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f55c7778-a41c-4fc6-a2e7-fa970c5295f2",
            "created_at": "2022-10-25T16:07:24.198891Z",
            "updated_at": "2025-03-27T02:02:10.138587Z",
            "deleted_at": null,
            "main_name": "Slingshot",
            "aliases": [],
            "source_name": "ETDA:Slingshot",
            "tools": [
                "Cahnadr",
                "GollumApp",
                "NDriver"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535952,
    "ts_updated_at": 1743041494,
    "ts_creation_date": 1653780168,
    "ts_modification_date": 1653780168,
    "files": {
        "pdf": "https://archive.orkl.eu/449a92698bbcf1d46a02b6d3cb4c53f0e9443717.pdf",
        "text": "https://archive.orkl.eu/449a92698bbcf1d46a02b6d3cb4c53f0e9443717.txt",
        "img": "https://archive.orkl.eu/449a92698bbcf1d46a02b6d3cb4c53f0e9443717.jpg"
    }
}