{
    "id": "3caf7c25-29e5-43d9-bbfe-410221ba56e0",
    "created_at": "2023-01-12T15:06:30.584204Z",
    "updated_at": "2025-03-27T02:05:53.566567Z",
    "deleted_at": null,
    "sha1_hash": "4d227d83a9bfac5389caf80798a6284ef15c38de",
    "title": "2021-11-01 - Two Tools for Malware Analysis and Reverse Engineering in Ghidra",
    "authors": "",
    "file_creation_date": "2022-05-28T01:29:27Z",
    "file_modification_date": "2022-05-28T01:29:27Z",
    "file_size": 1038771,
    "plain_text": "# Two Tools for Malware Analysis and Reverse Engineering in Ghidra\n\n**[insights.sei.cmu.edu/blog/two-tools-for-malware-analysis-and-reverse-engineering-in-ghidra/](https://insights.sei.cmu.edu/blog/two-tools-for-malware-analysis-and-reverse-engineering-in-ghidra/)**\n\n[Jeffrey Gennari](https://insights.sei.cmu.edu/authors/jeffrey-gennari/)\n\nNovember 1, 2021\n\n\n-----\n\n[Since the public release by the National Security Agency of the](https://en.wikipedia.org/wiki/National_Security_Agency) software reverse engineering\n(SRE) tool suite [Ghidra, our team of researchers at the SEI’s CERT Division have been](https://www.nsa.gov/resources/everyone/ghidra/)\nworking to create a new suite of tools to make it easier for analysts to take advantage of\n[Ghirdra’s capabilities and interface. This new suite of tools, known as Kaiju, helps malware](https://insights.sei.cmu.edu/blog/introducing-cert-kaiju-malware-analysis-tools-for-ghidra/)\nanalysis and reverse engineering take advantage of Ghidra’s capabilities and interface,\nwhich are relatively easy to use during malware analysis. The tools included with Kaiju give\nmalware analysts many advantages as they are faced with increasingly diverse and complex\nmalware threats.\n\n[One of the more complex plugins included in Kaiju is a Satisfiability Modulo Theories (SMT)-](https://dl.acm.org/doi/10.5555/1792734.1792766)\n[based path analysis tool named GhiHorn. In this post we present and discuss the use of two](https://github.com/CERTCC/kaiju/blob/main/docs/GhiHorn.md)\nGhihorn tools: API Analyzer and Path Analyzer. Both of these tools enable analysts to find\npaths in executables based on numerous criteria, such as user-specified start and end\n[addresses or passing through specific program points. Our previous work has shown that](https://insights.sei.cmu.edu/blog/path-finding-in-malicious-binaries-first-in-a-series/)\nexecutable path finding can support various malware analysis activities. One example that\nwe have previously cited is a malware program that contains a check for the presence of a\ndebugger, a common technique meant to hinder analysis. The analyst may wish to know if\nthere is a viable execution path that circumvents this check and, if there is a path, what\ninputs and environmental conditions are needed to traverse it. Both PathAnalyzer and\nApiAnalyzer can be used to address and solve these types of problems.\n\n## GhiHorn Tools: ApiAnalyzer and PathAnalyzer\n\nOn top of the GhiHorn platform we have implemented two path analysis tools: PathAnalyzer\nand ApiAnalyzer. Both tools use Horn encoding and solving as their primary strategy for path\nanalysis, and both emphasize the usefulness of results.\n\n### PathAnalyzer\n\nPathAnalyzer allows an analyst to determine if a path exists between two locations in a\nprogram and, if so, what values are required to take that path. PathAnalyzer integrates with\nGhidra as a plugin (Figure 1). An analyst must provide start and goal addresses to seed the\nanalysis. If a path is feasible, PathAnalyzer returns an answer in the form of a graph\ncontaining information about the recovered path.\n\n\n-----\n\nFigure 1: PathAnalyzer user interface\n\nAn example of a recovered path is shown in Figure 2. Each vertex in the graph represents a\n[basic block traversed. GhiHorn operates on live variables present in each basic block, with](https://en.wikipedia.org/wiki/Live_variable_analysis)\nan emphasis on variables that are linked to decompilation data structures. The variable\nvalues in the vertices are the values that Z3 selected to reach the goal address. The graph is\nclickable in the Ghidra user interface, meaning that selecting a node will highlight the\nrelevant decompilation and disassembly instructions for the answer vertex.\n\n\n-----\n\nFigure 2: PathAnalyzer answer graph\n\nIf no path is found, then a counterexample graph is generated showing how the query failed.\nIn this version of GhiHorn the counterexample is not very meaningful. Currently, the actual\nresults for unsatisfiable queries are presented as they are returned by Z3: as a graph with\nBoolean values assigned to states found in the encoding. For example, Table 1 shows the\ndisassembly for a function. Attempting to find a path from the beginning of the function at\naddress `0x100003f50 to the address` `0x100003f9d is unsatisfiable because` `local_1c`\nis always an even number, and the condition guarding the instruction at `0x100003f9d`\nchecks for an odd number. The disassembly is shown because the default result for an\nunsatisfiable answer is to return Boolean values (true or false) for block addresses. Aside\nfrom learning that this particular attempt to find a path is infeasible, we are still working to\nmake counterexamples more useful.\n\n\n-----\n\nTable 1: Unsatisfiable example\n\n### ApiAnalyzer\n\nThe second tool based on GhiHorn, named ApiAnalyzer, uses binary path and data flow\nanalysis to reason about program behaviors. Like its Pharos namesake, the premise of\nGhiHorn ApiAnalyzer is that interesting program behaviors can be determined by finding API\nfunction call sequences that share common data. For example, Figure 3 below shows the\ncommon way to list the processes running on a system using the Windows Tool Help\nFunctions. The API calls used are highlighted in red.\n\n\n-----\n\nFigure 3: Source code to iterate through running processes using API calls to Windows Tool\nHelp Functions\n\nThe GhiHorn version of ApiAnalyzer formulates a program using the same hornified control\nflow graph as PathAnalyzer. This approach is reasonable given that the API analysis\nproblem can be framed as a path reachability problem with a few additional constraints\nnamely that the path must traverse a specific sequence of API function calls. More\nspecifically the additional constraints are introduced to tally the API function calls covered\nand to track variable values passed between API functions.\n\nThe API call sequences and variables to track are specified as signatures using a JSONbased format similar to that of the Pharos ApiAnalyzer. For example, a simple signature to\nlink the opening and closing of the same file is shown in Table 2. Note that the two functions\noperate on the same data: a variable labeled `HANDLE. CreateFileA returns the initial`\nvalue, and `CloseHandle must operate on that same value for a match to exist.`\n\nTable 2 : API signature\n\nThe ApiAnalyzer plugin is shown in Figure 4. In this image, two simple signatures are being\nsearched for: reading and writing the same file, as well as opening and closing the same file.\nBoth signatures are found in the program, and an answer graph is presented. This graph is\nshown in Figure 5.\n\n\n-----\n\nFigure 4: Ghidra ApiAnalyzer user interface\n\n\n-----\n\nFigure 5: ApiAnalyzer answer graph\n\nApiAnalyzer’s answer graph is basically the same as the graph generated by PathAnalyzer.\nImported API functions for which there is an implementation are highlighted in cyan. API\nfunctions for which there is no implementation are colored magenta. As before, the graph\nincludes variable values that are used to construct the path, and the graph can be used for\nnavigation in the Ghidra disassembly and decompiler windows.\n\n## The Future of GhiHorn\n\n\n-----\n\nGhiHorn provides the capability to reason about program paths in Ghidra. The Horn-based\ntools provided by GhiHorn and the tight integration with Ghidra’s user interface makes formal\nprogram analysis tools accessible to malware analysts and reverse engineers. Future\nversions of the plugin will continue to provide new and better ways to consume results and to\nmodel more complex code structures. We also plan on generating better counterexamples to\nmake it more evident why a path could not be recovered. Finally, we’re working on a better\nmemory model that better represents a real program’s address space.\n\nGhiHorn is publicly available as part of the CERT Kaiju Framework. The source code and\nbuild instructions for GhiHorn (and all Kaiju tools) are available on [GitHub. We welcome](https://github.com/certcc/kaiju)\nsuggestions for improvements or for new utilities that would be useful for building new tools\nto support malware analysis and reverse engineering.\n\nAdditional Resources\n\nRead the SEI Blog post _[Introducing CERT Kaiju: Malware Analysis Tools for Ghidra.](https://insights.sei.cmu.edu/blog/introducing-cert-kaiju-malware-analysis-tools-for-ghidra/)_\n\nRead the SEI Blog post _[GhiHorn: Path Analysis in Ghidra Using SMT Solvers.](https://insights.sei.cmu.edu/blog/ghihorn-path-analysis-in-ghidra-using-smt-solvers/)_\n\nView the SEI Podcast Reverse Engineering Object-Oriented Code with Ghidra and\n_New Pharos Tools._\n\nWRITTEN BY\n\nMORE BY THE AUTHOR\n\n**[GhiHorn: Path Analysis in Ghidra Using SMT Solvers](https://insights.sei.cmu.edu/blog/ghihorn-path-analysis-in-ghidra-using-smt-solvers/)**\n\nOctober 18, 2021 • By [Jeffrey Gennari](https://insights.sei.cmu.edu/authors/jeffrey-gennari/)\n\n**[Introducing CERT Kaiju: Malware Analysis Tools for Ghidra](https://insights.sei.cmu.edu/blog/introducing-cert-kaiju-malware-analysis-tools-for-ghidra/)**\n\nSeptember 13, 2021 • By [Garret Wassermann,](https://insights.sei.cmu.edu/authors/garret-wassermann/) [Jeffrey Gennari](https://insights.sei.cmu.edu/authors/jeffrey-gennari/)\n\n**[Using OOAnalyzer to Reverse Engineer Object Oriented Code with Ghidra](https://insights.sei.cmu.edu/blog/using-ooanalyzer-to-reverse-engineer-object-oriented-code-with-ghidra/)**\n\nJuly 15, 2019 • By [Jeffrey Gennari](https://insights.sei.cmu.edu/authors/jeffrey-gennari/)\n\n**[Path Finding in Malicious Binaries: First in a Series](https://insights.sei.cmu.edu/blog/path-finding-in-malicious-binaries-first-in-a-series/)**\n\n\n-----\n\nDecember 10, 2018 By [Jeffrey Gennari](https://insights.sei.cmu.edu/authors/jeffrey-gennari/)\n\n**[Pharos Binary Static Analysis Tools Released on GitHub](https://insights.sei.cmu.edu/blog/pharos-binary-static-analysis-tools-released-on-github/)**\n\nAugust 28, 2017 • By [Jeffrey Gennari](https://insights.sei.cmu.edu/authors/jeffrey-gennari/)\n\nMORE IN REVERSE ENGINEERING FOR MALWARE ANALYSIS\n\n**[GhiHorn: Path Analysis in Ghidra Using SMT Solvers](https://insights.sei.cmu.edu/blog/ghihorn-path-analysis-in-ghidra-using-smt-solvers/)**\n\nOctober 18, 2021 • By [Jeffrey Gennari](https://insights.sei.cmu.edu/authors/jeffrey-gennari/)\n\n**[Introducing CERT Kaiju: Malware Analysis Tools for Ghidra](https://insights.sei.cmu.edu/blog/introducing-cert-kaiju-malware-analysis-tools-for-ghidra/)**\n\nSeptember 13, 2021 • By [Garret Wassermann,](https://insights.sei.cmu.edu/authors/garret-wassermann/) [Jeffrey Gennari](https://insights.sei.cmu.edu/authors/jeffrey-gennari/)\n\n**3 Ransomware Defense Strategies**\n\nNovember 9, 2020 • By [Marisa Midler](https://insights.sei.cmu.edu/authors/marisa-midler/)\n\n**[Using OOAnalyzer to Reverse Engineer Object Oriented Code with Ghidra](https://insights.sei.cmu.edu/blog/using-ooanalyzer-to-reverse-engineer-object-oriented-code-with-ghidra/)**\n\nJuly 15, 2019 • By [Jeffrey Gennari](https://insights.sei.cmu.edu/authors/jeffrey-gennari/)\n\n**[Business Email Compromise: Operation Wire Wire and New Attack Vectors](https://insights.sei.cmu.edu/blog/business-email-compromise-operation-wire-wire-and-new-attack-vectors/)**\n\nApril 8, 2019 • By [Anne Connell](https://insights.sei.cmu.edu/authors/anne-connell/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-11-01 - Two Tools for Malware Analysis and Reverse Engineering in Ghidra.pdf"
    ],
    "report_names": [
        "2021-11-01 - Two Tools for Malware Analysis and Reverse Engineering in Ghidra.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535990,
    "ts_updated_at": 1743041153,
    "ts_creation_date": 1653701367,
    "ts_modification_date": 1653701367,
    "files": {
        "pdf": "https://archive.orkl.eu/4d227d83a9bfac5389caf80798a6284ef15c38de.pdf",
        "text": "https://archive.orkl.eu/4d227d83a9bfac5389caf80798a6284ef15c38de.txt",
        "img": "https://archive.orkl.eu/4d227d83a9bfac5389caf80798a6284ef15c38de.jpg"
    }
}