{
    "id": "144e66f6-abe8-4271-86df-186edd3e3af0",
    "created_at": "2023-01-12T15:02:10.253946Z",
    "updated_at": "2025-03-27T02:06:02.575709Z",
    "deleted_at": null,
    "sha1_hash": "0efaa84aa0dd7f0b0371fca2666f6a9bd220bb0d",
    "title": "2022-05-28 - A Case of Vidar Infostealer - Part 2",
    "authors": "",
    "file_creation_date": "2022-05-25T20:38:18Z",
    "file_modification_date": "2022-05-25T20:38:18Z",
    "file_size": 1347108,
    "plain_text": "# A Case of Vidar Infostealer - Part 2\n\n**0x00-0x7f.github.io/A-Case-of-Vidar-Infostealer-Part-2**\n\n0x00-0x7F blog May 18, 2022\n\n[Hi, welcome to the Part 2 of my Vidar infostealer analysis writeup. In part 1 of this post, I](https://0x00-0x7f.github.io/A-Case-of-Vidar-Infostealer-Part-1-(-Unpacking-)/)\ncovered detailed technical analysis of packed executable dropped by initial stager by\nextracting and exploring embedded shellcode which is unpacking and self-injecting final\npayload. This part focuses on detailed static analysis of final injected payload: unpacked\nVidar infostealer, defying anti-analysis techniques employed by malware (string decryption,\ndynamically loading DLLs and resolving APIs), automating analysis and finally uncovering\nstealer’s main functionality through deobfuscated/decrypted strings.\n\n**[SHA256: fca48ccbf3db60291b49f2290317b4919007dcc4fb943c1136eb70cf998260a5](https://bazaar.abuse.ch/sample/fca48ccbf3db60291b49f2290317b4919007dcc4fb943c1136eb70cf998260a5/)**\n\n**Vidar in a Nutshell**\n\nThe Vidar Stealer is popular stealer written in C++ and has been active since October 2018\nand seen in numerous different campaigns. It has been utilized by the threat actors behind\nGandCrab to use Vidar infostealer in the process for distributing the ransomware as second\nstage payload, which helps increasing their profits. The family is quite flexible in its\noperations as it can be configured to grab specific information dynamically. It fetches its\nconfiguration from C2 server at runtime which dictates what features are activated and which\ninformation is gathered and exfiltrated from victim machine. It also downloads several\nbenign supporting dlls (freebl3.dll, mozglue.dll, msvcp140.dll and nss3.dll) to process\nencrypted data from browsers such as email credentials, chat account details, web-browsing\ncookies, etc., compresses everything into a ZIP archive, and then exfiltrates the archive to the\nattackers via an HTTP POST request. Once this is done, it kills its own process and deletes\ndownloaded DLLs, working directory contents and main executable in an attempt to wipe all\nevidence of its presence from the victim’s machine.\n\n**Technical Analysis**\n\nI’ll start analysis by loading this executable directly in IDA to look for important strings,\nIDA’s strings window show some intersting plaintext and base64 encoded strings stored in\n.rdata section\n\n\n-----\n\nif I quickly decode few base64 strings in Cyberchef, it results in junk data giving a clue that\nstrings are possibly encrypted before they were base64 encoded\n\n\n-----\n\nnext I’ll check for encryption algorithm but KANAL fails to detect any potential algorithm for\nstring encryption as given in figure below\n\nso let’s start digging it statically to see\nhow string encryption actually works in\nthis case, for this purpose I’ll double\nclick a base64 encoded string randomly\nto see where it’s been used by finding its\nXrefs which takes us to sub_423050\nroutine\n\n\n-----\n\nthis routine seems to be processing most of the base64 encoded strings and storing result for\neach processed string in a global variable, apart from first two variables which seem to be\nstoring plaintext values for possible decryption key and domain, let’s rename this routine to\n**wrap_decrypt_strings**\n\n\n-----\n\n**sub_422F70 in wrap_decrypt_strings routine can be seen from figure above to be**\nrepititively called with base64 strings, has been Xref’d for ~400 times, it can be assumed it is\nprocessing encrypted strings and can be renamed to decrypt_strings for our convenience as\nshown in the figure below\n\n\n-----\n\nfurther exploring decrypt_strings by loading the executable in x64dbg, debugging unveils\nthat first two calls to sub_4011C0 routine are just copying values of key and base64\nencoded encrypted string to local variables, next routine sub_422D00 is decoding base64\nstring, stores decoded hex value to a local variable and returns address of this local variable\n\nbase64 decoded hex string can also be verified in cyberchef\n\nlater it calculates length for base64 decoded hex string and allocates buffer equivalent of that\nlength on heap, next two calls to sub_401330 routine are allocating two buffers on heap for\nkey and base64 decoded hex string respectively before it proceeds to finally decrypt data\nusing sub_422980, quick decompilation of code for this routine results in three well\nrecognized RC4 loops\n\n\n-----\n\nstring decryption can be confirmed by following Cyberchef recipe\n\ndecompiled version of decrypt_strings routine sums up all the steps described above\n\n\n-----\n\nonce processing for wrap_decrypt_strings completes, it continues to process next routine\nfrom _WinMain, a quick overview of sub_419700 this routine reveals that it makes\nextensive use of global variables which were initialized in wrap_decrypt_strings apart\nfrom two calls to sub_4196D0 and sub_4195A0 routines respectively which can further\nbe explored by debugging\n\nin the figure above, routine sub_4196D0 is parsing PEB structure to get base address for\nKernel32.dll loaded in memory by accessing _PEB -> PEB_LDR_DATA ->\nInLoadOrderModuleList structures respetively, next routine sub_4195A0 being called is\ntaking two parametes: 1). kernel32.dll base address 2). address of a global variable\ndword_432204 (LoadLibraryA) in first call and dword_432438 (GetProcAddress) in second\ncall\n\n\n-----\n\nwhere sub_4195A0 is parsing kernel32.dll’s header by navigating from\nIMAGE_DOS_HEADER -> IMAGE_NT_HEADER ->\nIMAGE_OPTIONAL_HEADER.DATA_DIRECTORY ->\nIMAGE_EXPORT_DIRECTORY.AddressOfNames to retrieve export name and compare it\nwith value of API contained by input parameter value which in this case is LoadLibraryA\n\nif both strings match, it returns API’s address by accessing value of\nIMAGE_EXPORT_DIRECTORY.AddressOfFunctions field, resolved address is stored in\n**dword_432898 variable while second call to sub_4195A0 resolves GetProcAddress,**\nstores resolved address to dword_43280C which is subsequently used to resolve rest of\n[API functions at runtime. I wrote an IDAPython script here which is first decrypting strings](https://github.com/0x00-0x7F/IDAPython_scripts/blob/master/Vidar/deobfuscate_resolve_Vidar.py)\n\n\n-----\n\nfrom wrap_decrypt_strings, resolving APIs from sub_419700 routine, adding\ncomments and giving meaningful names to global variables storing resolved APIs to properly\nunderstand code flow and its functionality. decrypt_strings routine from IDAPython script\nis finding key, locating ~400 base64 encoded encrypted strings, base64 decoding strings and\nusing key to decrypt base64 decoded hex strings, adding decrypted strings as comments and\nrenaming variables as shown in figure below\n\n**resolve_apis routine from script is resolving ~100 APIs from 11 libraries from**\n**sub_419700 routine**\n\n\n-----\n\nafter resolving APIs, next routine sub_41F4A0 checks if victime machine is part of CIS\n**(Commonwealth of Independent States) countries which include Armenia, Azerbaijan,**\nBelarus, Georgia, Kazakhstan, Kyrgyzstan, Moldova, Russia, Tajikistan, Turkmenistan,\nUkraine, and Uzbekistan, it retrieves language ID for current user by calling\nGetUserDefaultLangID API and compares returned result with specified location codes\n\nwhere 0x43F corresponds to Kazakhstan, 0x443 to Uzbekistan, 0x82C to Azerbaijan and so\non, it continues performing its tasks if user’s language ID doesn’t fall in the above mentioned\ncategory, otherwise it’ll stop execution and exit, next routine sub_41B700 performs\nwindows defender anti-emulation check by compareing computer name to HAL9TH and\nuser name to JohnDoe strings\n\n\n-----\n\n-----\n\nonce all required checks are passed, sub_420BE0 routine is called which consists of\nstealer’s grabbing module, it prepares urls and destination path strings where downloaded\ndlls from C2 server are to be stored before performing any other activity\n\nit downloads 7 dlls under C:\\Programdata\\\n\n\n-----\n\nnext it creates its working directory under C:\\Programdata, name of directory is randomly\ngenerated 15 digit string like C:\\ProgramData\\920304972255009 where it further\ncreates four sub-directories (autofill, cc, cookies and crypto) which are required to be created\nto store stolen data from browser, outlook, cryptocurrency wallets and system information\ngathering modules\n\ndifferent types of browsers are being targeted to steal autofill, credit card, cookies, browsing\nhistory and victim’s login credentials, this module is equipped with advanced stealing and\nencryption techniques\n\n\n-----\n\nit further queries registry about SMTP and IMAP servers with confidential data and\npassword, gathers data about connected outlook accounts (if any) and finally dumps all the\ndata to outlook.txt file in its working directory\n\n\n-----\n\nlater it scans for .wallet, .seco, .passphrase and .keystore files for ~30 cryptocurrency wallets\non their installed paths and copies scanned files to “crypto” in working directory\n\n\n-----\n\nVidar creates an HTTP POST request for C&C (http://himarkh.xyz/main.php) server in order\nto download configuration for grabbing module at runtime, parses downloaded configuration\nand proceeds to gather host, hardware and installed software related info\n\nwhich is stored in system.txt file according to the specified format as shown in figure below\n\n\n-----\n\n-----\n\nthe same routine also captures screenshots which is stored as “screenshot.jpg” inside working\ndirectory\n\n\n-----\n\nimmidiately after that a zip file with “_8294024645.zip” name format is created and stolen\ncontents from working directory are compressed (file is compressed using Zip2 encryption\nalgorithm as identified by KANAL)\n\nthe compressed file is now ready to be exfiltrated to its C&C server in another POST request\n\nafter exiting from recursive grabbing module, it deletes downloaded DLLs and files created in\nworking directory being used to dump stolen data and information in order to remove its\ntraces from victim machine\n\n\n-----\n\n-----\n\neventually it prepares a command “/c taskkill /pid PID & erase EXECUTABLE_PATH\n**& RD /S /Q WORKING_DIRECTORY_PATH\\* & exit” which gets executed using**\ncmd.exe to kill the running infostealer process and to delete remaining directories created by\nthis process and the process itself.\n\nThat’s it for Vidar infostealer’s in-depth static analysis and analysis automation! see you soon\nin another blogpost.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-05-28 - A Case of Vidar Infostealer - Part 2.pdf"
    ],
    "report_names": [
        "2022-05-28 - A Case of Vidar Infostealer - Part 2.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535730,
    "ts_updated_at": 1743041162,
    "ts_creation_date": 1653511098,
    "ts_modification_date": 1653511098,
    "files": {
        "pdf": "https://archive.orkl.eu/0efaa84aa0dd7f0b0371fca2666f6a9bd220bb0d.pdf",
        "text": "https://archive.orkl.eu/0efaa84aa0dd7f0b0371fca2666f6a9bd220bb0d.txt",
        "img": "https://archive.orkl.eu/0efaa84aa0dd7f0b0371fca2666f6a9bd220bb0d.jpg"
    }
}