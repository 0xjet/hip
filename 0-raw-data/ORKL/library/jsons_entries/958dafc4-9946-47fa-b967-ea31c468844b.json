{
    "id": "958dafc4-9946-47fa-b967-ea31c468844b",
    "created_at": "2023-01-12T15:03:17.105604Z",
    "updated_at": "2025-03-27T02:06:03.879772Z",
    "deleted_at": null,
    "sha1_hash": "efa8dae7e8f742a05c4b1b407b6cfd31e57e657a",
    "title": "2019-02-14 - Malware Tales- Gootkit",
    "authors": "",
    "file_creation_date": "2022-05-28T15:18:26Z",
    "file_modification_date": "2022-05-28T15:18:26Z",
    "file_size": 2959728,
    "plain_text": "# Malware Tales: Gootkit\n\n**certego.net/en/news/malware-tales-gootkit/**\n\n**Date:**\n14 February 2019\n\n**Tag:**\n[Gootkit,](https://www.certego.net/en/news/index/type:Tag/slug:gootkit/) [Malware](https://www.certego.net/en/news/index/type:Tag/slug:malware/)\n\nToday we are going to start a new series of blog posts called “Malware tales”: the intent is to\ngo deep on code-level analysis of most widespread malware to allow everyone to get a\nbetter picture of everyday cyber threats. Also, we’d like to demystify malware and show that\nwe are just talking about a bunch of code\n\n**Summary:**\n\n1. The Threat\n2. Payload delivery\n3. Gootkit executable\n4. Stage 1: Packed Gootkit\n5. Stage 2: Gaining a foothold\n6. Stage 3: Check-in phase\n7. Last stage\n\n\n-----\n\n8. Additional findings\n9. Conclusions\n\n**The Threat:**\n\n**Gootkit belongs to the category of Infostealers and Bankers therefore it aims to steal**\ninformation available on infected machines and to hijack bank accounts to perform unwanted\ntransactions.\n\nIt has been around at least since 2014 and it seems being actively distributed in many\ncountries, including Italy.\n\n[Previous reports about this threat can be found following this link:Malpedia](https://malpedia.caad.fkie.fraunhofer.de/details/win.gootkit)\n\nToday we are going to dive into the analysis of a particular variant that came up the last\nweek.\n\n**Payload Delivery:**\n\nThe infection vector is an email written in Italian. In this case adversaries used one of the\nmost common social engineering techniques to trigger the user to open the attachment.\n\n\n-----\n\nThe downloaded file is a heavily obfuscated Javascript file called _GLS_Notifica.js . If the_\nuser opens it, the native Javascript interpreter wscript.exe would be executed by default and\nit would perform the following HTTP request:\n\nThe result is the download of a cabinet file that is an archive file which can be extracted\nnatively by Windows. Inside there is a Portable Executable file that is saved into the\n**%TEMP% folder (“C:\\Users\\<username>\\AppData\\Local\\Temp”) and launched.**\n\n**Javascripts downloaders are a common payload delivery because a little obfuscation can**\nbe enough to make them very difficult to be detected by antivirus engines.\n\n**Gootkit executable:**\n\nFirst run of the sample in an automated environment revealed that something new was\nadded in this version. As we can see in the following images, malware authors added a new\nlayer of protection to the malicious agent. The comparison has been made with a variant\nspread during December of 2018 in Italy. (images are from [AnyRun)](https://any.run/)\n\n\n-----\n\nThis means that the original program was “packed” with the aim to slow down reverse\nengineers and to make ineffective static analysis tools like Yara rules.\n\n**Stage 1: Packed Gootkit**\n\nIn such cases, a malware analyst knows that he has to extract the original payload as fast as\npossible without losing time to try to understand the inner workings of this stage.\n\nA great open-source tool exists which can resolve the problem in a matter of seconds. It’s\ncalled PE-Sieve [(Github). Even though it does not always work, in this case it can dump the](https://github.com/hasherezade/pe-sieve)\nunmapped version of the original executable because the malicious software uses a\ntechnique called Process Hollowing a.k.a. RunPE. This method consists in starting a new\nprocess in a suspended state, “hollowing” out the content of the process, replacing it with\nmalicious code and, finally, resuming the thread.\n\nIn the image we can see that the 6th parameter of \"CreateProcessW\" was set to \"4\",\nindicating that the process will start in a suspended state.\n\nWe are talking about a well known technique that is easily detectable with the monitoring of\nthe Windows API calls that are needed to perform the injection. But here comes the trick.\n\n\n-----\n\nFollowing the flow of execution we couldn t find all the needed API calls: we got\n_NtCreateProcess, NtGetContextThread, NtReadVirtualMemory and NtSetContextThread._\n\nThe most important ones that are used by monitoring applications to detect the technique\nwere missing:\n\n_NtUnmapViewOfSection to “hollow” the target process_\n_NtWriteVirtualMemory to write into the target process_\n_NtResumeThread to resume the suspended thread_\n\nLet’s find out what’s happening!\n\nAfter some shellcode injections inside its memory space, the process executes a call to\n_IsWow64Process API that is used by the application to understand if the process is running_\n[under the WOW64 environment (Wiki): this is a subsystem of the Windows OS that is able to](https://it.wikipedia.org/wiki/WOW64)\nrun 32-bit applications, like this one, on 64-bit operating systems.\n\nThe result of this check is used to run two different paths of code but with the same scope:\nrun one of the aforementioned missing API calls in the Kernel mode. This means that, in this\nway, classic user-level monitoring tools would not catch these calls and the RunPE technique\nwould remain unnoticed.\n\nSpecifically, in case the process is running in a 32-bit environment, it would use the\n_SYSENTER command to switch into the Kernel mode, while, on the contrary, it would use_\nthe SYSCALL command to perform the same operation.\n\nTo complicate even further, the SYSCALL command can’t be called in the context of a 32-bit\napplication. This means that the executable needs to perform a “trick-into-the-trick” to\nexecute this operation. We are talking about a technique known as The Heaven’s Gate.\n\nPractically, thanks to the RETF instruction, it’s possible to change the code segment (CS)\nfrom 0x23 to 0x33, de facto enabling 64-bit mode on the running process.\n\nIn the following image we highlight the entrance and the exit of the “Gate” which contains the\n64-bit code that performs the SYSCALL operation.\n\n\n-----\n\nInstead, in this other image, we can see the process status before opening the gate\n(grey=suspended process) and after having closed it (orange=running process).\n\n\n-----\n\nAlso, Gootkit takes advantage of The Heaven’s Gate as an anti-debugging technique\nbecause the majority of commonly used debuggers can’t properly handle this situation, not\nallowing the analyst to follow the code of the Gate step-by-step.\n\n[For further details, this method was deeply explained in this blog (MalwareBytes)](https://blog.malwarebytes.com/threat-analysis/2018/01/a-coin-miner-with-a-heavens-gate/)\n\nGoing back to the point, the first stage resulted more complicated than expected because it\npushed over the limits of obfuscation and stealthiness with the combination of various\ntechniques.\n\n**Stage 2: Gaining a foothold**\n\nAt this point we can proceed with the analysis of the unpacked Gootkit.\n\nThe very first considerable finding was the check for the existence of a mutex object named\n“ServiceEntryPointThread”. If it exists, the process would terminate itself.\n\nBut how mutexes works? Mutexes are used as a locking mechanism to serialize access to a\nresource on the system. Malware sometimes uses it as an “infection marker” to avoid to\ninfect the same machine twice. The fascinating thing about mutexes is that they are a\ndouble-edged weapon: security analysts could install the mutex in advance to vaccinate\n[endpoints. (ref: Zeltser blog)](https://zeltser.com/malware-vaccination-infection-markers/)\n\nThis means that this is a great indicator of compromise that we can use not only to detect the\ninfection but also to prevent it.\n\n\n-----\n\nMoving on, we found that malware authors implemented a lot of checks to understand if the\nmalware is running inside a virtual environment. Some of them are:\n\nIt checks if the registry key\n“HKLM\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0\\ProcessorNameString”\ncontains the word “Xeon”\n\nit checks if the computer name is “7SILVIA” or “SANDBOX”, if the username is\n“CurrentUser” or “Sandbox” or if “sbiedll.dll” has been loaded.\n\nit checks if “HKLM\\HARDWARE\\Description\\System\\VideoBiosVersion” contains the\nword “VirtualBox”\n\nit checks “HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\SystemBiosVersion” for\nthe string “VBOX”\n\nIn the case one of this check fails, the program would execute a Sleep operation in a infinite\ncycle in the attempt to thwart automated sandbox execution.\n\nAfter that, we encountered the implementation of a particular persistence mechanism that it\nseems Gootkit has been using for many months: it’s already documented in various blog\n[posts, for ex. ReaQta blog.](https://reaqta.com/2018/12/gootkit-campaign-italian-government/)\n\n\n-----\n\nBriefly, the infostealer generates a INF file with the same filename of itself.\n\nContent of the INF file:\n\nThen it creates 3 different registry keys (“Count”, “Path1” and “Section1”) inside\n_“HKCU\\Software\\Microsoft\\IEAK\\GroupPolicy\\PendingGPOs” with the purpose to allow the_\nthreat to execute on reboot.\n\nIt seems that this technique was reported to be used only by Gootkit.\n\nFamous security tools still can’t detect this mechanism even if it has been used for months.\n\nFor example, the famous SysInternal Autoruns tool, that should be able to show all the\nprograms that are configured to run on system bootup or login, fails the detection of this\npersistence method.\n\nStepping through the code, we noticed that, at runtime, Gootkit decrypts the strings it uses\nwith a custom algorithm to evade static analysis detection of anomalous behaviour.\n\n\n-----\n\nIt s a combination of stack strings, XOR commands and the modulo operation.\n\n[An exhaustive explanation of the decryption routine can be found here:link](https://paper.tuisec.win/detail/1f762a57f618c6e)\n\nSkipping further, eventually there’s a call to “CreateProcessW” to start a new instance of\nGootkit with the following parameter: --vwxyz\n\n**Stage 3: Check-in phase**\n\nQuickly we found out that executing the malware with the cited parameter allows us to skip\nall the previous anti-analysis controls to get into the part of the code that starts to contact the\nCommand & Control Server.\n\nThe first check-in to home is done to the following URL via HTTPS:\n\n\n-----\n\nAs we can see from the image, many headers were added to the request to send different\ninformations of the infected machine to the C&C Server.\n\nIn particular one of the headers caught my attention: “ X-IsTrustedComp”. Digging into the\ncode we found that the value would be set to “1” if an environment variable called\n“crackmeololo” was found in the host, “0” otherwise.\n\nThat seems another “escaping” mechanism implementing by the author, probably to stop the\ninfection chain for his own debugging purposes.\n\n**Last stage:**\n\nThe response that arrives from the previous connection contains the final stage of Gootkit,\nconfigured to work properly on the infected machine.\n\nThe malware dynamically loaded “RtlDecompressBuffer” call to use it to decompress the\npayload; then, it injected into an area of the current process memory.\n\n\n-----\n\nAfterwards the flow of execution is transferred to the start of the injected code.\n\nThe final payload is a DLL file that is bigger than 5MB because it contains the Node.js engine\nwhich is probably needed to run some embedded javascript files. At this time we decided to\nstop our analysis and leave the rest to future work.\n\n**Additional findings:**\n\nWhile debugging, we noticed that Gootkit does not check only if a parameter called “ -_vwxyz” was passed to the command line Also it checks if other 3 parameters:_\n\n\n-----\n\n**--reinstall**\n\n**--service**\n\n**-test**\n\nPretty strange thing. We haven’t found the malware to actively use these arguments yet.\nHowever, stepping through code we discovered that:\n\n1 - the “--reinstall” command leaded the execution to some curious code. First, the malware\nused “CreateToolHelp32Snapshot” to retrieve a list of the current running processes.\n\nThen, it iterated through the retrieved list via “ Process32FirstW” and “Process32NextW” with\nthe aim to get a handle to the active “explorer.exe” instance.\n\nAt this point it killed “explorer.exe”. The following image shows the process list before the\n“TerminateProcess” command.\n\n\n-----\n\nAfter having executed that command, we found that a new instance of the malware spawned\nas a child of “explorer.exe”.\n\nWhat happened? We performed some tests and it seems that “ explorer.exe” was killed and\nthen automatically restarted by “winlogon.exe”. Therefore “explorer.exe” accessed the keys\ninvolved in the persistence mechanism previously explained:\n\nUsing this trick, the malware is able to “reinstall” itself, without the need to use suspicious\nAPI calls like “ CreateProcessW”.\n\n2 - the “ --service” command did not change the flow of execution with the exception of\ncreating a new environment variable called “USERNAME_REQUIRED” and set it to “TRUE”.\n\nEventually we found that the final stage checks if the aforementioned variable exists.\n\n\n-----\n\n3 - the “ -test” command just terminate the process. Indeed it’s a test.\n\n**Conclusions**\n\nWe explored some of the functionalities of one of the most widespread Infostealers of these\ndays, revealing new and old tricks that is using to remain undetected as much time as\npossible.\n\n**Certego is actively monitoring every day threats to improve our detection and response**\nmethods, continuously increasing the effectiveness of the incident response workflow.\n\nPS: Let us know if you liked this story and feel free to tell us how we can improve it!\n\n**Hash:**\n```\n597f734c780f283d6cd7c7443700a65249b8350ec1ad58b8aa790a32f57eec4d \nGLS_Notifica.js\n5ed739855d05d9601ee65e51bf4fec20d9f600e49ed29b7a13d018de7c5d23bc\ngootkit 1st stage\ne32d72c4ad2b023bf27ee8a79bf82c891c188c9bd7a200bfc987f41397bd61df \ngootkit 2nd stage\n0ad2e03b734b6675759526b357788f56594ac900eeb5bd37c67b52241305a10a \ngootkit DLL module\n\n```\n**About the author:**\n\n**Matteo Lodi, Cyber Threat Intelligence Team Leader**\n\nTwitter: [https://twitter.com/matte_lodi](https://twitter.com/matte_lodi)\n\n**License:**\n\nQuest'opera è distribuita con Licenza Creative Commons Attribuzione - Non commerciale - Non opere\nderivate 4.0 Internazionale.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-02-14 - Malware Tales- Gootkit.pdf"
    ],
    "report_names": [
        "2019-02-14 - Malware Tales- Gootkit.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535797,
    "ts_updated_at": 1743041163,
    "ts_creation_date": 1653751106,
    "ts_modification_date": 1653751106,
    "files": {
        "pdf": "https://archive.orkl.eu/efa8dae7e8f742a05c4b1b407b6cfd31e57e657a.pdf",
        "text": "https://archive.orkl.eu/efa8dae7e8f742a05c4b1b407b6cfd31e57e657a.txt",
        "img": "https://archive.orkl.eu/efa8dae7e8f742a05c4b1b407b6cfd31e57e657a.jpg"
    }
}