{
    "id": "41df2958-ffa0-4341-afe1-e997f9006a0a",
    "created_at": "2023-01-12T15:01:21.092118Z",
    "updated_at": "2025-03-27T02:16:39.962828Z",
    "deleted_at": null,
    "sha1_hash": "660cc6a5098cb5becd5941396a52544ce0787a7a",
    "title": "2020-05-12 - Evading Detection with Excel 4.0 Macros and the BIFF8 XLS Format",
    "authors": "",
    "file_creation_date": "2022-05-29T01:25:32Z",
    "file_modification_date": "2022-05-29T01:25:32Z",
    "file_size": 573799,
    "plain_text": "# Evading Detection with Excel 4.0 Macros and the BIFF8 XLS Format\n\n**[malware.pizza/2020/05/12/evading-av-with-excel-macros-and-biff8-xls/](https://malware.pizza/2020/05/12/evading-av-with-excel-macros-and-biff8-xls/)**\n\nMay 13, 2020\n\n[Abusing legacy functionality built into the Microsoft Office suite is a tale](https://pentestlab.blog/2018/01/16/microsoft-office-dde-attacks/) [as](https://blog.talosintelligence.com/2017/07/template-injection.html) [old](https://news.sophos.com/en-us/2019/07/18/a-new-equation-editor-exploit-goes-commercial-as-maldoc-attacks-using-it-spike/) [as](https://www.decalage.info/files/eu-19-Lagadec-Advanced-VBA-Macros-Attack-And-Defence.pdf) [time. One](https://security-soup.net/analysis-of-a-new-emotet-maldoc-with-vba-downloader/)\nfunctionality that is popular with red teamers and maldoc authors is using Excel 4.0 Macros\nto embed standard malicious behavior in Excel files and then execute phishing campaigns\n[with these documents. These macros, which are fully documented online, can make web](https://exceloffthegrid.com/using-excel-4-macro-functions/)\nrequests, execute shell commands, access win32 APIs, and have many other capabilities\nwhich are desirable to malware authors. As an added bonus, the Excel format embeds\nmacros within Macro sheets which can be more challenging to examine statically than VBA\nmacros which are easier to extract. As a result, many malicious macro documents have a\nmuch lower than expected rate of detection in the AV world.\n\nMalware campaigns, such as the ZLoader campaign (described in great detail by InQuest\n[Labs here,](https://inquest.net/blog/2019/01/29/Carving-Sneaky-XLM-Files) [here, and](https://inquest.net/blog/2020/03/18/Getting-Sneakier-Hidden-Sheets-Data-Connections-and-XLM-Macros) [here) are actively abusing this functionality to perform mass phishing](https://inquest.net/blog/2020/05/06/ZLoader-4.0-Macrosheets-)\nattacks. The campaign is so prolific that I’ve actually received one of these maldocs in one of\nmy personal email accounts. Because of its effectiveness and low detection rate, this\ntechnique is also popular in the penetration testing community. Outflank described how to\nembed shellcode in Excel 4.0 Macros in 2018, and [tooling has](https://github.com/med0x2e/genxlm) [been published to abuse this](https://github.com/outflanknl/Scripts/blob/master/ShellcodeToJScript.js)\n[functionality via Excel’s ExecuteExcel4Macro VBA API.](https://docs.microsoft.com/en-us/office/vba/api/excel.application.executeexcel4macro)\n\nWhile there is clearly already a spotlight on the subject of Excel 4.0 Macros, I believe that\nonly the surface of this attack vector has been scratched. There’s no doubt that defenders\nare building better signal on malicious macros (one of the tools which originally had 0\n[detections on VirusTotal is now up to 15 at the time of writing this post), but there is also](https://www.virustotal.com/gui/file/f5a67b22f0362403b851664b6edd25928383d7f68099b61612e580b94734fe7a/detection)\nevidence that some of this signal can be brittle and unreliable.\n\nFor example, the ZLoader campaign obfuscates its macros using a series of cells that build\neach command from CHAR expressions. Ex: =CHAR(61) evaluates to the = character.\n\n\n-----\n\nA ZLoader\n\n[Campaign’s Macro Sheet (image from @DissectMalware)](https://twitter.com/DissectMalware/status/1243282739123621888)\nThere’s plenty to build a signature on in this sheet:\n\nThe repeated usage of the =CHAR(#) cells to define formula content one character at a\ntime.\nThe use of the Auto_Open label which triggers automatic execution of the macro sheet\nonce the “Enable Content” button is pressed.\nZLoader marks their macro sheets as hidden which has a detectable static signature\nThe use of numerous Formula expressions to dynamically generate additional\nexpressions at runtime.\n\nA lot of this would appear to be good enough signal to just block outright – Windows\nDefender, for example, considers just about any usage of =CHAR(#) to be malicious. Making\nan empty macro sheet that contains one cell with =CHAR(42) and another with =HALT() will\nimmediately flag the document as malicious:\n\n\n-----\n\nIf you try to save this document with Windows Defender enabled, it will block the save\noperation\nThis is probably a bit overkill, but apparently the number of legitimate users that do this is\nsmall enough that Windows can roll out a patch to all machines marking it malicious. A more\nreasonable signature, which seems resistant to false positives, is @DissectMalware’s\nmacro_sheet_obfuscated_char YARA rule:\n```\nrule macro_sheet_obfuscated_char\n{\n meta:\n  description = \"Finding hidden/very-hidden macros with many CHAR functions\"\n  Author = \"DissectMalware\"\n  Sample = \"0e9ec7a974b87f4c16c842e648dd212f80349eecb4e636087770bc1748206c3b\n(Zloader)\"\n strings:\n  $ole_marker = {D0 CF 11 E0 A1 B1 1A E1}       \n  $macro_sheet_h1 = {85 00 ?? ?? ?? ?? ?? ?? 01 01}\n  $macro_sheet_h2 = {85 00 ?? ?? ?? ?? ?? ?? 02 01}  \n  $char_func = {06 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\n?? ?? ?? ?? 1E 3D 00 41 6F 00}\n condition:\n  $ole_marker at 0 and 1 of ($macro_sheet_h*) and #char_func > 10\n}\n\n```\nThis rule looks for three things:\n\n1. The standard magic header for Office documents D0CF11E0A1B11AE1 at the start of\n\nthe file.\n[2. A macro sheet (defined in a BoundSheet8 BIFF Record) with a hidden state set to](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/b9ec509a-235d-424e-871d-f8e721106501)\n\n**Hidden or VeryHidden.**\n[3. The presence of at least 10 Formula BIFF Records which have an Rgce field](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/8e3c6978-6c9f-4915-a826-07613204b244)\n\n[containing two Ptg structures – a](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/9310c3bb-d73f-4db0-8342-28e1e0fcb68f) **[PtgInt representing the value 0x3D (which maps to](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/508ecf18-3b81-4628-95b3-7a9d2a295bca)**\nthe = character) and a **[PtgFunc with an](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/87ce512d-273a-4da0-a9f8-26cf1d93508d)** **[Ftab value of 0x6F (the matching tab value for](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/00b5dd7d-51ca-4938-b7b7-483fe0e5933b)**\nthe CHAR function).\n\n\n-----\n\n[Unless you are fairly acquainted with the Excel 2003 Binary format (also known as BIFF8),](https://www.loc.gov/preservation/digital/formats/fdd/fdd000510.shtml)\nthe third search condition is likely to read as a series of random letters jammed together\nrather than anything coherent. To better understand what exactly is being discussed, let’s\ntake a quick detour into the BIFF8 file format.\n\n## The Excel 97-2003 Binary File Format (BIFF8)\n\n[Before office documents were saved in the Open Office XML (OOXML) format, they were](https://en.wikipedia.org/wiki/Office_Open_XML)\nsaved in a much more succinct binary format focused on describing the maximum amount of\ninformation with the minimum number of bytes. Legacy office documents are stored in a\n[Compound Binary File Format (CBF) while their actual application specific data (such as](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cfb/53989ce4-7b05-4f8d-829b-d08d6148375b)\nWord document content or Excel workbook information) is stored within binary streams\nembedded in the CBF header.\n\nExcel’s workbook stream is a direct series of Binary Interchange File Format (BIFF) records.\nThe records are fairly simple – there are 2 bytes for describing the record type, 2 bytes for\ndescribing the remaining length of the record, and then the relevant record bytes. An Excel\n[workbook is just a series of BIFF records beginning with a BOF record and eventually ending](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/4d6a3d1e-d7c5-405f-bbae-d01e9cb79366)\nwith a final [EOF record.](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/012176fe-5802-423b-9135-78e22642456b) [Microsoft’s Open Specifications project has helpfully documented](https://docs.microsoft.com/en-us/openspecs/main/ms-openspeclp/3589baea-5b22-48f2-9d43-f5bea4960ddb)\nevery one of these records online. For example, if we are parsing a stream and read a record\nbeginning with the byte sequence `85 00 0E 00, we are reading a BoundSheet8 record`\nthat is 14 bytes long.\n\nThe BoundSheet8\n\ndefinition from Microsoft\nFrom Microsoft’s documentation we can see that BoundSheet8 records contain a 4 byte\noffset pointing to the relevant BOF record, 2 bits used for describing the visible state of the\nsheet, a single byte used for describing the sheet type, and a variable number of bytes used\nfor the name of the sheet.\n\n\n-----\n\nHex\n\ndump of a VeryHidden Macro sheet’s BoundSheet8 BIFF record\nThe above hex dump represents a BoundSheet8 record for a Macro sheet that has been\n“Very Hidden” – essentially made inaccessible from within Excel’s UI. This record would\nmatch the YARA sig byte regex of `$macro_sheet_h2 = {85 00 ?? ?? ?? ?? ?? ?? 02`\n```\n01} . The signature begins with the matching BIFF record id for BoundSheet8 ( 85 00 ),\n\n```\nthen ignores the size (2 bytes) and the lbPlyPos record (4 bytes). It then matches the\n**hsState field ( 02 ) followed by the byte indicating that the sheet is a macro sheet ( 01 ).**\nThis is a reasonable match for sheets that follow the BIFF8 specification.\n\n## Fiddling with BIFF Records\n\nHowever, there are a few tricks to essentially dodge this signature component by abusing\nflexibility in the specification. For example, the hsState field is only supposed to be\nrepresented by 2 bits – the remaining 6 bits of that byte are reserved. Theoretically this\nmeans that touching these bits should invalidate a spreadsheet, but this is not what happens\nin practice. Say we replaced the value `02 (b’00000010 in binary) with a different value by`\nflipping some bits (b’10101010) like `AA – would Excel also treat that as a hidden sheet? I`\ncan’t speak for all versions of Excel, but in my testing with Excel 2010 and 2019, the answer\nis yes.\n\nEssentially, by following the majority of the specification, but not following the exact way that\nExcel has traditionally generated these documents creates an entirely new set of Excel\nbinary sheets which bypasses most static signatures. The remainder of this blog post will\nfocus on a few examples of abusing the BIFF8 specification to create alternate, but valid,\nExcel documents.\n\n### Label (Lbl) Records\n\n**[Lbl records are used for explicitly naming cells in a worksheet for reference by other](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/d148e898-4504-4841-a793-ee85f3ea9eef)**\nformulas. In some cases, Lbl records can contain macros or trigger the download and\nexecution of other macros. From a malicious macro author’s perspective, though, the most\nlikely usage of a Lbl record is to define the Auto_Open cell for their workbook. If a workbook\nhas an explicitly defined Auto_Open cell then, once macros are enabled, Excel will\nimmediately begin evaluating the macros defined at that cell and continue evaluating cells\nbelow it until a HALT() function is invoked. Understandably, the existence of an Auto_Open\n**[Lbl record is considered fairly suspicious, so there are a number](http://www.greyhathacker.net/?p=948)** [of workarounds attackers](https://twitter.com/DissectMalware/status/1251271398481367040)\nhave taken to hide their usage of this functionality. Let’s see if there are some other evasion\ntechniques hiding in the Lbl record specification:\n\n\n-----\n\n[The Lbl record is a big](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/d148e898-4504-4841-a793-ee85f3ea9eef)\n\nstructure with plenty of room for abuse\nBy default, when an Auto_Open label is defined in a BIFF8 document, it has its fBuiltin flag\nset to true, and its name field set to the value `01, indicating that this is an Auto_Open`\nfunction. The first 17 bytes of this record (21 if you include the 4 byte header) can likely be\nused as a signature to identify usage. This does assume a lack of meddling with the\nreserved bytes which default to `00, but signatures could probably replace these with`\nwildcard bytes and not pick up too many false positives. Given that normal labels are never\ngoing to have a single byte value of `01, there is a very small chance of triggering false`\npositives with this as well.\n\nA default Lbl\n\nentry for Auto_Open\nIf a user attempts to save any variation on the Auto_Open label (like alternative capitalization\n**AuTo_OpEn), Excel will automatically convert it back to the shortened fBuiltin version**\nshown above. However, when Excel opens an OOXML formatted workbook there is no\nequivalent shorthand record for Auto_Open, it is simply stored as a string. So what happens\nif we explicitly create a Lbl record, leave fBuiltin as false, and give it a name of\n**Auto_Open?**\n\n\n-----\n\nA Lbl record\n\nwith fBuiltin flipped to false, and the Name field set to Auto_Open\nIf a Lbl record is generated with these properties and inserted into an Excel document, Excel\nwill still treat the referenced cell as an Auto_Open cell and trigger it. So we can create a\nlabel that triggers Auto_Open behavior but doesn’t look like the default record. This is a\ngood start, but once a technique like this became well known it would also be vulnerable to a\nquick signature. As is, there are already plenty of AV solutions that will explicitly look for the\n**Auto_Open string since attackers have been abusing this in OOXML documents in the wild.**\n\nAn\n\nexample of an OOXML document abusing Excel’s flexible Auto_Open parsing\nExcel is surprisingly flexible when it comes to considering a text field matching the\n**Auto_Open label – apparently the application only checks if the label starts with the string**\n**Auto_Open. This results in maldocs with labels like Auto_Open21. In fact, if you use Excel**\nto save a label with name like Auto_Open222, it will actually save the record using a\ncombination of the fBuiltin flag, and then append the extra characters, as can be seen\nbelow.\n\n_How Excel_\n\n_saves the label Auto_Open222 – note it maintains the fBuiltin flag (20) and doesn’t include_\n_the Auto_Open text, just the 0x01 indicating Auto_Open_\nAppending characters is great, but can we inject additional characters into the Auto_Open\nstring in a way that Excel will still read it? A common trick in bypassing input validation is to\ntry injecting null bytes to see if it results in the string being terminated early. Occasionally null\nbytes are also good for changing the length of a string without affecting its value.\n\nThe\n\nAuto_Open label with null bytes injected\n\n\n-----\n\nHow Excel’s Name\n\nManager renders this Lbl record\nExcel will actually give us the best of both worlds, from an attacker perspective, when\ninjecting null bytes. The Auto_Open functionality will remain intact and still trigger for the cell\nwe specify, but the Name Manager will not properly display any part of the name after the\nfirst null byte. Additionally, our Lbl record’s name data will not be easily match-able with a\npredictable regex.\n\nThe rabbit hole actually can go deeper than just null byte injection, however – the Name field\n[in Lbl records is represented by a XLUnicodeStringNoCch record. This record allows us to](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/e64abeee-2f3a-4004-b9e3-3d67e29d6066)\nspecify strings using either (essentially) ASCII or UTF16 depending on whether we set the\n**fHighByte flag. Besides further breaking any signatures relying on a contiguous Auto_Open**\nstring, the usage of UTF16 opens a whole new world of string abuse to attackers.\n\n[Unicode is traditionally a parsing](https://hackernoon.com/%CA%BC-%C5%9B%E2%84%87%E2%84%92%E2%84%87%E2%84%82%CA%88-how-unicode-homoglyphs-will-break-your-custom-sql-injection-sanitizing-functions-1224377f7b51) [nightmare](https://medium.com/bugbountywriteup/unicode-vs-waf-xss-waf-bypass-128cd9972a30) [in the security space due to inconsistent](https://www.rapid7.com/db/vulnerabilities/windows-mozilla-firefox-bom-utf-xss)\nhandling of edge cases across implementations. Excel is no exception to this, and it appears\nthat when an unexpected character is encountered, the label parsing code will simply ignore\nit. From testing it appears that any “invalid” unicode character found will be skipped entirely.\nThere are likely exceptions to the rule, but it appears that any entry that claims to be an\ninvalid combination on fileformat.info can be injected into XLUnicodeStringNoCch records\nwithout impacting parsing. For example, if we build a string like\n```\n\"\\ufefeA\\uffffu\\ufefft\\ufffeo\\uffef_\\ufff0O\\ufff1p\\ufff6e\\ufefdn\\udddd\",\n\n```\nthis will still trigger the Excel Auto_Open functionality.\n\nAfter some\n\nfun with Unicode this looks VERY different from our initial Lbl record\nThis could be combined with null byte injection to hide the manipulation from the Name\nManager UI entirely, or the Lbl record’s fHidden bit could be set to stop it from appearing in\nthe Name Manager entirely. The ability to inject an arbitrary amount garbage in between\nletters in the Lbl name significantly increases the difficulty of building a reliable signature for\nthis technique.\n\n### The Rgce and Ptg Structures\n\n\n-----\n\nLet s revisit the YARA rule from earlier, specifically the part for detecting usages of\n**=CHAR(#):**\n```\n$char_func = {06 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\n?? ?? 1E 3D 00 41 6F 00}\n\n```\n[This signature is keying on the beginning of a Formula record, and then the](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/8e3c6978-6c9f-4915-a826-07613204b244)\n[CellParsedFormula structure towards the end. CellParsedFormula structures contain three](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/7dd67f0a-671d-4905-b87b-4cc07295e442)\nthings:\n\n1. cce – The size of the following rgce structure\n2. rgce – The actual structure containing what we’d consider to contain the formula\n3. rgcb – A secondary structure containing supporting information that might be\n\nreferenced in rgce\n\n[So what on earth is an Rgce structure? Why it’s a set of](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/6cdf7d38-d08c-4e56-bd2f-6c82b8da752e) **[Ptg structures of course! Ptg](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/9310c3bb-d73f-4db0-8342-28e1e0fcb68f)**\nstructures, [short for “Parse Thing”, are the base component of Formulas. While one might](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/e7625cc8-3da9-4154-b449-49cf1bbd9703)\nexpect to find a string representation of a formula like =CHAR(61), this wouldn’t mesh with\nBIFF8’s hyper-focus on reducing file size. Each formula is represented as a series of Ptg\nexpressions which describes a small piece of what a user would consider to be a formula.\nFor example, =CHAR(61) is in fact two components – a reference to the internal CHAR\nfunction, and the number 61. Each of these representations has a corresponding Ptg\nstructure.\n\n[The CHAR function is represented by a PtgFunc, a Ptg record which contains a reference to](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/87ce512d-273a-4da0-a9f8-26cf1d93508d)\n[a predefined list of functions in Excel known as the Ftab.](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/00b5dd7d-51ca-4938-b7b7-483fe0e5933b)\n\n[The Ftab value table](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/00b5dd7d-51ca-4938-b7b7-483fe0e5933b)\n\nspecifying that 0x6F is the CHAR function\n\n\n-----\n\n[The number 61 is represented by a PtgInt structure which is just the standard Ptg header](https://docs.microsoft.com/en-us/openspecs/office_file_formats/ms-xls/508ecf18-3b81-4628-95b3-7a9d2a295bca)\nand an integer with the value of 61:\n\nMany Ptg records, like the PtgInt, are fairly straightforward\nAs a result, we end up with the binary signature of `1E 3D 00 41 6F 00 ( 41 is the Ptg`\nnumber for PtgFunc). One thing that might stand out here, however, is the fact that the\nordering of this data seems backwards – the PtgInt(61) data is stored before the\n**PtgFunc(CHAR) data.**\n\n[This is because Ptg expressions are described using Reverse Polish Notation (RPN). RPN](https://en.wikipedia.org/wiki/Reverse_Polish_notation)\nallows for quick parsing of a series of operators and operands without needing to worry\nabout parentheses, items are processed in the order they are read. For example: `3 4 − 5`\n```\n+ represents taking the value 3 and 4, then applying the subtraction function to those values\n\n```\nto get -1. The value 5 is taken and the addition function is applied to -1 and 5, resulting in 4.\nThis mentality is useful for stack-based programming languages, and it is used here to\nsimulate what is essentially a stack of Ptg expressions. In our example here, the operand\n**PtgInt(61) is popped off the stack, then the PtgFunc(CHAR) is applied to it.**\n\nThe reason this is relevant is because the RPN stack-based format of Ptg structures allows\nus to easily create some very obfuscated expressions without needing to worry about their\nbinary representation. For example, Microsoft Defender blocks all =CHAR(#) expressions –\nbut what if we write a formula like =CHAR(ROUND(61.0,0)). This function is essentially the\nsame, but ends up being represented very differently at the byte level:\n\nThe\n\nbytes of our new Formula’s rgce\nThe rgce listed here is now PtgNum(61.0), PtgInt(0), PtgFunc(ROUND), PtgFunc(CHAR).\nAs an added “bonus”, PtgNum represents its data as a double, so the value of 61 is\nrepresented as `00 00 00 00 00 80 4E 40 . Embedding a function has also completely`\n\n\n-----\n\nchanged the order of our Ptg structures such that the bytes of PtgFunc(CHAR) and\n**PtgNum(61.0) are no longer adjacent. The original signature of** `1E 3D 00 41 6F 00 is no`\nlonger tracking this Formula.\n\nIn short, the rgce block is ideally designed from a malware author’s perspective. There are\nnumerous ways to represent the exact same functionality that look completely different from\na static analysis perspective. The byte layout of the rgce block is also highly sensitive to\nchange, turning a single value into a function invocation can rearrange the order of all other\n**Ptg bytes within the expression.**\n\n## Introducing Macrome\n\nMuch of the work necessary for testing some of these methods involved manually writing\nXLS files rather than using Excel. While there are plenty of tools for reading the BIFF8 XLS\nformat, good tooling for manually creating and modifying XLS files doesn’t appear to be as\ncommon. As a result, I’ve created a tool for building and deobfuscating BIFF8 XLS Macro\ndocuments. This tool, [Macrome, uses a modified version of the b2xtranslator library used by](https://github.com/michaelweber/Macrome)\n[BiffView.](https://www.aldeid.com/wiki/BiffView)\n\nMacrome implements many of the obfuscations described in this blog post to help\npenetration testers more easily create documents for phishing campaigns. The modified\nb2xtranslator library can be used for research and experimentation with alternate obfuscation\nmethods. Macrome also provides functionality that can be used to reverse many of these\nobfuscations in support of malware analysts and defenders. The tool was originally going to\ninclude functionality to process macros to help bypass obfuscated formulas, but\n[@DissectMalware has already created a fantastic tool called XLMMacroDeobfuscator which](https://twitter.com/DissectMalware/)\ngoes above and beyond anything I was planning on dropping. It’s really a great piece of tech\nthat I’d recommend anyone who has to analyze these kinds of documents.\n\nI’ll be posting in the future about how to further expand Macrome and implement your own\nobfuscation and deobfuscation methods. In the meantime, please give the tool a try at\n[https://github.com/michaelweber/Macrome. If you have any suggestions or feature requests](https://github.com/michaelweber/Macrome)\nplease let me know here or open an issue!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-05-12 - Evading Detection with Excel 4.0 Macros and the BIFF8 XLS Format.pdf"
    ],
    "report_names": [
        "2020-05-12 - Evading Detection with Excel 4.0 Macros and the BIFF8 XLS Format.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "2864e40a-f233-4618-ac61-b03760a41cbb",
            "created_at": "2023-12-01T02:02:34.272108Z",
            "updated_at": "2025-03-27T02:02:10.209072Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "ETDA:WildCard",
            "tools": [
                "RustDown",
                "SysJoker"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "256a6a2d-e8a2-4497-b399-628a7fad4b3e",
            "created_at": "2023-11-30T02:00:07.299845Z",
            "updated_at": "2025-03-27T02:00:03.257794Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "MISPGALAXY:WildCard",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535681,
    "ts_updated_at": 1743041799,
    "ts_creation_date": 1653787532,
    "ts_modification_date": 1653787532,
    "files": {
        "pdf": "https://archive.orkl.eu/660cc6a5098cb5becd5941396a52544ce0787a7a.pdf",
        "text": "https://archive.orkl.eu/660cc6a5098cb5becd5941396a52544ce0787a7a.txt",
        "img": "https://archive.orkl.eu/660cc6a5098cb5becd5941396a52544ce0787a7a.jpg"
    }
}