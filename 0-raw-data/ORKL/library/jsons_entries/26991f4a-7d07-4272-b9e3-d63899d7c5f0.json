{
    "id": "26991f4a-7d07-4272-b9e3-d63899d7c5f0",
    "created_at": "2023-01-12T15:02:30.668299Z",
    "updated_at": "2025-03-27T02:09:29.174986Z",
    "deleted_at": null,
    "sha1_hash": "86295f7f6e878b5b7d1fa35dcb4cd04a4d02c32f",
    "title": "2022-05-02 - Detecting Hypervisor-assisted Hooking",
    "authors": "",
    "file_creation_date": "2022-05-28T02:37:21Z",
    "file_modification_date": "2022-05-28T02:37:21Z",
    "file_size": 101204,
    "plain_text": "# Detecting Hypervisor-assisted Hooking\n\n**momo5502.com/blog/**\n\nI recently started to experiment with hypervisors and their use for bypassing anti-cheat or\nanti-tampering systems.\n\nThis post will describe the concept of hypervisor-assisted hooking and a few simple\napproaches to detect such hooks.\n\n## What is a hypervisor?\n\nIn short: A hypervisor allows to run virtual machines with hardware acceleration.\n\nThe concept of hypervisors in general is a huge topic, but for this post, all that depth doesn‚Äôt\nreally matter.\n\nThe way virtualization is done using a hypervisor is by abstracting certain critical\ncomponents. For example privileged instructions or memory.\n\nThis allows uncritical instructions to run on real hardware, while privileged operations can be\nintercepted and virtualized.\n\n## How is memory virtualized?\n\nIn modern hypervisor technologies, for example Intel VT-X or AMD-V, memory is virtualized\nby adding ‚ÄúSecond Level Address Translation‚Äù (SLAT).\n\nWhen resolving a virtual memory address to physical space in ram, the translation is not only\ndone once by the kernel, but a second time by the hypervisor. That way, memory of virtual\nmachines can be controlled by the host.\n\nIntel calls this functionality ‚ÄúExtended Page Tables‚Äù (EPT), for AMD this is called ‚ÄúNested\nPage Tables‚Äù (NPT).\n\nThis technology, however, is not limited to running virtual machines, because the CPU does\nnot distinguish between host OS and virtualized OS. The hypervisor decides that. Therefore\nall kind of memory can be virtualized, including memory of the host OS.\n\n## How does hypervisor-assisted hooking work?\n\nThe idea of hypervisor-assisted hooking is to redirect code execution from a virtual page to a\ndifferent physical page than reads or writes to the same virtual page.\n\n\n-----\n\nI m going to focus on Intel s EPT technology. A description of how this works for AMD can be\n[found here. However, due to limitations, the technique is by far not as powerful on AMD.](https://github.com/tandasat/SimpleSvmHook)\n\nI‚Äôm not going to describe how address translation works on x86 in detail. If you want a good\n[explanation, I can recommend reading this article.](https://www.triplefault.io/2017/07/introduction-to-ia-32e-hardware-paging.html)\n\nHowever, in short, address translation is done using tables that describe where virtual\nmemory pages reside in physical memory.\n\nThose pages can have certain permissions. They can be executable, readable or writable.\nOr any combination of those three (on AMD a page can never be executable without also\nbeing readable, this is the limitation mentioned above).\n\nIf a page is readable, but not executable, any kind of execution will trigger an exception.\nHowever, with EPT, this address translation happens a second time in the hypervisor. The\npermissions also need to be valid there. Meaning if a page is readable and executable in the\nfirst level of translation, but not in the second level, the one done using EPT, a ‚ÄúVM exit‚Äù will\nbe triggered upon execution.\n\nThis will exit the VM and pass execution to a handler that was previously registered by the\nhypervisor. This handler can then decide how to proceed with this error.\n\nTo abuse this behaviour to install stealth hooks, we first need to clone the physical page.\nThat way, there will be an original page and a fake page, that will contain all our\nmodifications.\n\nBy marking the entry in the page table as non-executable, we will be able to intercept\nexecutions to that page in the VM exit handler of our hypervisor.\n\nThe handler can then replace the reference to the physical page with our fake page and\nretrigger the execution.\n\nHowever, once the CPU tries to read (or write) that memory, it would read our fake page. To\nprevent that, permissions of the page are marked as execute-only. That way, reads and\nwrites will trigger a VM-exit again, which allows swapping in the original page. By marking\nthis one as no-execute, the hypervisor can continuously swap our fake page in and out, to\nhide it from any kind of memory-based integrity check.\n\n## Is it possible to detect such hooks?\n\nUsually, hooks, or any kind of memory manipulations, are detected by reading memory and\ncomparing it to what it is supposed to look like, for example by hashing it.\n\nWith an EPT hook, those reads will always go to the original unmodified page and never\nreveal any manipulation. Therefore, using conventional integrity checks will not work.\n\n\n-----\n\nOf course, trying to detect the driver or hypervisor in general is a viable way. However, not\nevery hypervisor is necessarily evil and installs EPT hooks.\n\nMicrosoft‚Äôs hypervisor (Hyper-V) is usually active on modern Windows systems, to for\n[example assert kernel integrity (HyperGuard). So detecting EPT hooks here would result in a](https://windows-internals.com/hyperguard-secure-kernel-patch-guard-part-1-skpg-initialization/)\nfalse positive.\n\nAdditionally, the hypervisor can hide itself from the list of loaded driver using EPT hooks,\nmaking it invisible.\n\nInstead, I tried detecting EPT hooks using side channels, so for example by trying to observe\nthe effects of a VM exit. Essentially, I came up with 3 different methods:\n\n### Write Check\n\nThe first method is pretty weak, but works with many open-source hypervisors. It essentially\nabuses the fact that most hypervisors don‚Äôt reflect memory writes in their fake page.\n\nThis means if a write happens to the virtual page, it will be performed on the original physical\npage. But the fake physical page won‚Äôt contain the change.\n\nTo detect an EPT hook by writing to a page, we first need to find a spot on that page that is\nsafe to write to.\n\nWhen compiling code, modern compilers usually align code of a function to 16 bytes.\nMeaning, in between two functions, there are often quite a few unused bytes that serve no\npurpose except aligning the next function.\n\nThose bytes are usually nops (0x90) or software breakpoints (int 3, 0xCC).\n\nMicrosoft‚Äôs compiler emits software breakpoints:\n```\n00000001800170B0 4C 24 30 E8 48 08 00 00 85 C0 78 D8 83 7C 24 30\n00000001800170C0 00 74 CF E9 F6 C3 01 00 CC CC CC CC CC CC CC CC\n00000001800170D0 48 89 5C 24 08 57 48 83 EC 20 8B FA 48 8B D9 BA\n\n```\nTherefore, searching for 2 or more consecutive CC instructions often reveals unused space.\nOf course, those CCs could be an operand, for example in `mov rax, 0xCCCCCC... . So for`\na robust implementation, it might be useful to use a disassembler. But for the sake of\nsimplicity, two consecutive CCs reveal unused space.\n\nExecuting such a CC instruction will result in an exception. This exception can be caught\nusing exception handlers or using Microsoft‚Äôs __try/__finally constructs.\n\n\n-----\n\nWe can now overwrite this instruction and replace it with, for example, a return instruction\n(0xC3). Without EPT hooks, executing the new instruction will not yield any exception. If an\nexception still occurs, it is very likely that an EPT hook is installed with a hypervisor that does\nnot reflect writes to the fake page.\n\nOf course this can easily be mitigated by checking for writes to the original page before\nswapping in the fake page.\n\nHowever, this check can be extended. Writing to memory on one core should yield the same\nresult on a different one (on Intel). As hypervisors are installed per core, writes not only to be\nreflected to the fake page of one core, but also to pages maintained by different cores.\n\nTherefore, spawning a few threads and executing the written 0xC3 instruction can also\nreveal EPT hooks.\n\n[An example implementation of this check can be found here.](https://github.com/momo5502/ept-hook-detection/blob/main/write_check.cpp)\n\nThis check as a whole relies on bad or lazy implementation of EPT hooking. Therefore, I\nwould not consider this a very good check. However, if it ever detects a hook, it is unlikely to\nbe a false positive, which makes it very safe. As long as one makes sure the C3 is reverted\nback to a CC after performing the check üòõ\n\n### Timing Check\n\nThis mechanism abuses the fact that VM exits and page swaps take time.\n\nThe idea is to create an execution pattern that triggers VM exits due to EPT violations and\nmeasure the execution.\n\nFirst, we need to find something we can easily execute. Searching for a return instruction\n(0xC3) in the target page will allow us to execute this instruction as function and measure the\ntime.\n\n[To measure the time, we will use the RDTSC instruction which will return the current CPU](https://c9x.me/x86/html/file_module_x86_id_278.html)\nticks.\n\nOnce this is ready, the check will measure timing of two patterns:\n\n1. Repeatedly reading the same instruction without executing it\n2. Alternating executions and reads of the same instruction\n\nReding the instruction without executing it should be quite fast, even with EPT hooks\ninstalled, because there is no need to page-in any page over and over again, as it was\nalready paged in during the first read. Doing a warmup can even optimize the result.\n\n\n-----\n\nIf an EPT hook is present on the page, alternating between executions and reads to the page\nwill cause a VM exit and thus a page swap every time. This takes time.\n\nIf no EPT hook is present, this should take about twice as long as just reading the memory\n(assuming that reading a single return instruction takes as long as executing it, which is\nroughly the case).\n\nTherefore, due to the induced VM exits of EPT hooks, the timing should diverge quite a lot.\nMore than a factor of 10, even 100.\n\n[An example implementation of this check can be found here.](https://github.com/momo5502/ept-hook-detection/blob/main/timing_check.cpp)\n\nA limitation is that RDTSC can be virtualized by the hypervisor. A carefully crafted hypervisor\ncould therefore measure the time spent during VM exits and subtract that from the value\nRDTSC would initially return.\n\nAdditionally, due to time being involved, false positives can occur. Context switches can\nhappen and many other disturbances can cause inaccurate results.\n\n### Thread Check\n\nThis check improves upon the previous mechanism. Again, timing of reads vs. alternating\nexecutions/reads is measured and evaluated.\n\nHowever, instead of relying on RDTSC as a clock, time is measured by synchronizing two\nthreads and letting them race. For example by incrementing a counter on one thread while\nanother thread performs the task to be measured.\n\nTo reduce the probability of context switches, it is possible to bind the two threads to different\n[physical cores using SetThreadAffinityMask. Additionally SetThreadPriority can be used to](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask)\nfurther reduce the probability of context switches.\n\n[An example implementation of this check can be found here.](https://github.com/momo5502/ept-hook-detection/blob/main/thread_check.cpp)\n\nEven if the probability of false postives is quite high here, probability of false negatives is low.\nMeaning if no EPT hook was detected, it is unlikely there is one installed on the checked\npage. Turns out probability of false negatives is equally likely. If the counting thread gets\ncontext switched, but not the other thread, a false negative can occur.\n\nHowever, averaging out the times of multiple checks can yield very reliable results.\n\nAdditionally, it is definitely not trivial to mitigate this check for a hypervisor. Therefore, I\nconsider this to be the best of the three approaches.\n\n## Summary\n\n\n-----\n\nThe mechanisms described here show the possibility to detect EPT hooks from usermode,\nwithout the need of elevated privileges.\n\nOne thing to remember is, they only scan a single page. Checking the entire executable\naddress space of a process can get very costly, but might be desirable in a real world\napplication.\n\nStill, this shows that ways to detect EPT hooks exist. In the end, however, it remains a cat\nand mouse game.\n\nA quick google search did not really reveal existing research on the topic of detecting EPT\nhooks. But, as I rather wanted to spend my time experimenting, I‚Äôm sure others have found\ndifferent, if not better detections.\n\n[My hypervisor experiments with EPT hooking can be found here.](https://github.com/momo5502/hypervisor)\n[My implementation of the checks can be found here.](https://github.com/momo5502/ept-hook-detection)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-05-02 - Detecting Hypervisor-assisted Hooking.pdf"
    ],
    "report_names": [
        "2022-05-02 - Detecting Hypervisor-assisted Hooking.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535750,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653705441,
    "ts_modification_date": 1653705441,
    "files": {
        "pdf": "https://archive.orkl.eu/86295f7f6e878b5b7d1fa35dcb4cd04a4d02c32f.pdf",
        "text": "https://archive.orkl.eu/86295f7f6e878b5b7d1fa35dcb4cd04a4d02c32f.txt",
        "img": "https://archive.orkl.eu/86295f7f6e878b5b7d1fa35dcb4cd04a4d02c32f.jpg"
    }
}