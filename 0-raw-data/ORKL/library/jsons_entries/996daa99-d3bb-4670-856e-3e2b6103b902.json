{
    "id": "996daa99-d3bb-4670-856e-3e2b6103b902",
    "created_at": "2023-01-12T15:08:08.691329Z",
    "updated_at": "2025-03-27T02:09:55.034232Z",
    "deleted_at": null,
    "sha1_hash": "371d5535a5407a15488868e98c20c6b01c2edfc1",
    "title": "2021-04-12 - PaaS, or how hackers evade antivirus software",
    "authors": "",
    "file_creation_date": "2022-05-28T17:47:07Z",
    "file_modification_date": "2022-05-28T17:47:07Z",
    "file_size": 487854,
    "plain_text": "# PaaS, or how hackers evade antivirus software\n\n**[ptsecurity.com/ww-en/analytics/pt-esc-threat-intelligence/paas-or-how-hackers-evade-antivirus-software/](https://www.ptsecurity.com/ww-en/analytics/pt-esc-threat-intelligence/paas-or-how-hackers-evade-antivirus-software/)**\n\nPositive Technologies\n\nPublished on 12 April 2021\n\nMalware is one of the main tools of any hacking group. Depending on the level of qualification and the specifics of operation, hackers can use\nboth publicly available tools (such as the Cobalt Strike framework) and their own developments.\n\nCreating a unique set of tools for each attack requires huge resources; therefore, hackers tend to reuse malware in different operations and\nalso share it with other groups. The mass use of the same tool inevitably leads to its getting on the radar of antivirus companies, which, as a\nresult, reduces its efficiency.\n\nTo prevent it from happening, hackers use code packing, encryption, and mutation techniques. Such techniques can often be handled by\n[separate tools called crypters or sometimes simply packers. In this article, we will use the example of the RTM banking trojan to discuss which](https://www.ptsecurity.com/ru-ru/research/hacker-groups/rtm/)\npackers attackers can use, how they complicate detection of the malware, and what other malware they can pack.\n\n## Packer-as-a-service\n\nA hacker group responsible for RTM distribution regularly sent mass phishing emails with malicious attachments until the end of 2020.\nApparently, the attacks were automated.\n\n\n-----\n\nFigure 1. RTM phishing\n\nemail, December 2020\nEach attachment contained files that significantly differed from each other, but the final payload remained almost the same.\n\nFigure 2. Example of RTM\n\narchive\nSuch feature is a natural consequence of using crypters. Initially, the group behind RTM used its own unique crypter. In 2020, however, the\ngroup changed it twice.\n\nWhen analyzing samples packed in a new way, we detected numerous other malware protected by similar method. Taking into account the fact\nthat packing process is automated, such overlapping with other malware allows us to assume that attackers use the packer-as-a-service\nmodel. In this model, packing of malicious files is delegated to a special service managed by a third party.\n\n\n-----\n\nFigure 3. Website of a crypt service\nAccess to such services can often be found on sale on hacker forums.\n\nFigure 4. Advertisement of file packing as a service\nLater in this article, we will discuss specific examples of crypters used by the RTM group.\n\n## Rex3Packer\n\nThe first use of this packer by the RTM group that we detected dates back to November 2019. The group started actively using the packer in\nApril–May 2020. Rare uses of the packer for distributing old versions of the RTM trojan were also observed in late January 2021.\n\n\n-----\n\nFigure 5. Phishing email by RTM, January 2021\nWe couldn't associate this packer with any of the publicly described ones, so we named it according to three specifics of its working: recursion,\nbit reverse, and reflective loading of PE files (reflection), hence the name Rex3Packer.\n\n### Unpacking algorithm\n\nThe overall algorithm for extracting the payload is as follows:\n\n1. A predetermined amount of memory is allocated with read, write, and execute rights using VirtualAlloc.\n2. The content of the current process image in the memory is copied to the allocated buffer (in particular, section .text).\n3. Control passes to the function inside the buffer.\n4. The difference is calculated between the location of data in the buffer and in the PE file image (difference between the addresses in the\n\nbuffer and virtual addresses in the image). This difference is written to the ebx register. All references to virtual addresses in code are\nindexed by the content of this register. As a result, wherever necessary, a correction is added to the PE image addresses that allows\n\nobtaining the corresponding address in the buffer. Figure 6. Calls to functions and variables\n\ntaking into account the correction in the ebx register\n5. Another buffer is allocated for packed data.\n6. By calling VirtualProtect, RWX rights are assigned to the entire memory region with the PE file image.\n7. The packed data is copied to the buffer.\n8. The packed data is decoded.\n9. The memory region with the PE image is filled with null bytes.\n10. The decoded data represents an executable file—the PE payload. This payload is reflectively loaded to where the initial PE image was,\n\nand control passes to its entry point.\n\n\n-----\n\nspec c a go t o decod g pac ed data s o spec a te est to us t s case, t ou d be co ect to co pa e pac g t\ncompression, as the algorithm is such that the size of packed data is always bigger than that of the initial data.\n\nThe packed data is preceded by a 16-byte header that contains four 4-byte fields:\n\nSize of the header\nSize of initial data (PE payload)\nPosition in initial data (*) at which they are divided (more details below)\nEncoding mode (1, 2, or 4)\n\nThe decoding looks as follows:\n\n1. Inside each byte, bit order is reversed (for example, 10011000 becomes 00011001).\n2. Depending on encoding mode (1, 2, 4), data is divided into blocks with N size of 9, 5, or 3 bytes, respectively. The result of the block\n\ndecoding is N-1 byte (8, 4, or 2).\n3. In the first N-1 bytes of the block, some bits are missing: their values always equal zero. To restore the original bytes, the missing bits are\n\nextracted from the last byte of the block by using 00000001, 00010001, or 01010101 masks. The mask is shifted for each subsequent\nbyte. As a result, the last byte of the block is composed of the bits extracted from previous bytes and united by the logical operation OR.\nFor example, in mode 4, the last byte is composed of even bits of the block's first byte and odd bits of the block's second byte. As a result\nof \"returning\" these bits to the first and second bytes, an original sequence of two bytes is composed.\n\nFigure 7. Scheme of obtaining initial bytes in\n\nmode 4\n4. When bits are restored in all blocks, the obtained data represents the initial PE file divided by two parts at position (*). These parts, in\n\nturn, were swapped. The second rearrangement (taking into account the (*) value) allows obtaining the original file.\n\n### Obfuscation\n\nTo complicate code analysis, various obfuscation techniques are used in the packer:\n\nIn between the execution of significant code, various WinAPI functions are called. Their results are saved but not used, and the functions\nare selected so that not to affect the program operation.\n\nFigure 8. Calling WinAPI functions\n\nA typical feature of this packer is the presence of cycles (not performing useful operations) implemented via a recursive function.\n\nFigure 9. Recursive function (sample without junk code)\n\n\n-----\n\no u t e ob uscat o, se e a do e s o a do y ge e ated u ct o s a e added to e ecutab e e ey ay ca eac ot e, but o e\nof them obtains control ever.\n\nFigure 10. Example of\n\ngenerated function\n\n### Usage\n\nIn addition to RTM samples, we detected the use of Rex3Packer for packing various malware, mainly originating from the CIS countries. Below\nis the list with examples of such malware:\n\n**Malware family** **SHA256**\n\n[Phobos Ransomware](https://malpedia.caad.fkie.fraunhofer.de/details/win.phobos) 6e9c9b72d1bdb993184c7aa05d961e706a57b3becf151ca4f883a80a07fdd955\n\n[Zeppelin Ransomware](https://malpedia.caad.fkie.fraunhofer.de/details/win.zeppelin_ransomware) 8d44fdbedd0ec9ae59fad78bdb12d15d6903470eb1046b45c227193b233adda6\n\n[Raccoon Stealer](https://malpedia.caad.fkie.fraunhofer.de/details/win.raccoon) 3be91458baa365febafb6b33283b9e1d7e53291de9fec9d3050cd32d98b7a039\n\n[KPOT Stealer](https://malpedia.caad.fkie.fraunhofer.de/details/win.kpot_stealer) 9b6af2502547bbf9a64ccfb8889ee25566322da38e9e0ccb86b0e6131a67df1e\n\n[Predator The Thief](https://malpedia.caad.fkie.fraunhofer.de/details/win.predator) d1060835793f01d1e137ad92e4e38ef2596f20b26da3d12abcc8372158764a8f\n\n[QakBot](https://malpedia.caad.fkie.fraunhofer.de/details/win.qakbot) 18cc92453936d1267e790c489c419802403bb9544275b4a18f3472d2fe6f5dea\n\n[We also detected the use of this packer for packing malware samples of the Nemty,](https://malpedia.caad.fkie.fraunhofer.de/details/win.nemty) [Pony, and](https://malpedia.caad.fkie.fraunhofer.de/details/win.pony) [Amadey families. This is, of course, not an](https://malpedia.caad.fkie.fraunhofer.de/details/win.amadey)\nexhaustive list of all cases of using Rex3Packer.\n\n## HellowinPacker\n\nIn May 2020, RTM started using a new packer and went on using it until the beginning of 2021. We called it HellowinPacker because of the file\nname \"hellowin.wav\" we spotted in strings of some samples.\n\nThe packer's key feature is two levels of code mutation. The first one significantly changes the unpacking code structure, making samples look\ndifferent from each other.\n\n\n-----\n\nFigure 11. Comparison of code in two samples of different structure\nThe example above shows the comparison of samples 5b5f30f7cbd6343efd409f727e656a7039bff007be73a04827cce2277d873aa0 (on the\nleft) and 1f9a8b3c060c2940a81442c9d9c9e36c31ad37aaa7cd61e1d7aec2d86fe1c585 (on the right).\n\nThe second level only changes some details, and the code structure remains in general the same. The changes mainly affect assembler\ninstructions and constants that do not impact the program operation. As a result, the code looks almost identical when decompiled.\n\nFigure 12. Comparison of code in two samples of the same structure\n\n\n-----\n\nJust e e 3 ac e, e o ac e s act e y used by attac e s to pac a ous a a e ote t at a a e o t e sa e a y as t e\nsame structure when packed. This lasts for at least some time, after which the structure can change.\n\nAll these features coincide with the description of a packing service the access to which is sold on hacker forums:\n\n[Uniqueness] A customer is given a unique crypter that does not depend on other customers. If your files were spotted, your uploads are to\nblame. We're not looking for 10,000+ customers, we provide correct Premium support and have a very limited number of clients. We make only\nunique stubs for a customer.\n\nApparently, each unique crypter has its own structure of generated code. The crypter itself can also mutate code but at a lower level, without\nchanging the program structure. In any case, the significant executable code remains the same.\n\n### Unpacking algorithm\n\nOne of the first actions in all packed files is an attempt to open the registry key HKEY_CLASSES_ROOT\\Interface\\{b196b287-bab4-101ab69c-00aa00341d07} (character case may differ in each particular case) and request a default value. Correct program operation in some\nmodifications of generated code depends on whether these operations are successful.\n\nInterface GUIDs may also differ. Here are some of the possible options:\n\n{3050f1dd-98b5-11cf-bb82-00aa00bdce0b}\n{aa5b6a80-b834-11d0-932f-00a0c90dcaa9}\n{683130a6-2e50-11d2-98a5-00c04f8ee1c4}\n{c7c3f5a1-88a3-11d0-abcb-00a0c90fffc0}\n{b8da6310-e19b-11d0-933c-00a0c90dcaa9}\n\nThe subsequent code obtains the address at which a block of encrypted data is located.\n\nThis block starts with a 4-byte number, which stores the size of initial data (those that will be obtained after decoding). By calling VirtualAlloc,\na memory block of required size with RWX rights is allocated for decrypted data. Encrypted data is copied to the allocated memory by blocks\nof X bytes each. In the original file, \"spaces\" of Y byte length are located between these blocks.\n\nFigure 13. Scheme of data copying in HellowinPacker\n\nData is then decrypted by 4-byte blocks:\n\nEach next block is interpreted as an integer (DWORD).\nIndex of the first byte in the block is added to the integer.\nAn xor operation is executed between the obtained value and the sum of the index and a fixed key (Z number)\n\n\n-----\n\na p e o a go t p e e tat o yt o\n```\ndef decrypt(data, Z):\n  index = 0\n  while index < len(data):\n    dword = struct.unpack(\"<I\", data[index:index + 4])[0]\n    dword = (dword + index) & (2 ** 32 - 1)\n    dword = dword ^ (index + Z)\n    data[index:index + 4] = struct.pack(\"<I\", dword)\n    index += 4\n\n```\nValues X, Y, and Z vary depending on a particular packed sample.\n\nThe next stage of extracting payload—the shellcode—is located inside the decrypted data. The shellcode takes control when the decryption\nends.\n\nThe shellcode dynamically loads functions required for its operation. These functions are listed in the \"import table\" located at the beginning of\ndecrypted data.\n\nFigure 14. \"Import table\" in decrypted data\n\nFor greater variability, the strings in the \"import table\" may be partially filled with random symbols. In the example above, the first function\nname \"GetProcAddress\" is fully replaced by the string \"aaa45678901234\", and the names \"VirtualAlloc\" and \"VirtualProtect\" are damaged.\nRight before processing the table, the shellcode restores correct values of all the symbols.\n\nFigure 15. Code for restoring damaged names of functions\n\nPayload (this time, it is the PE file) is extracted by the shellcode from the rest of the decrypted data. It is encrypted again by the same\nalgorithm as described above. For Z key, figure 1001 is always used.\n\nWhen the decryption is finished, the shellcode performs reflective loading of the PE file using the functions imported at the first stage.\n\n### Obfuscation\n\nJust like Rex3Packer, HellowinPacker samples call WinAPI functions not related to the main program logic. However, in this case, they are\nmostly used to complicate behavior analysis and detection in sandboxes. This is also confirmed by the fact that in most cases various\nfunctions are called in a row at the very beginning of the program.\n\n\n-----\n\nFigure 16. Entry point in one of the packed libraries\n\nAn additional effect of the WinAPI use is the impossibility of detection by a list of imported functions and by imphash.\n\nWhen working with various numeric values, a certain \"arithmetic\" obfuscation is often observed: necessary constants are represented as sums\nor differences of other constants (which in some cases equal zero). To obtain constants, WinAPI functions can also be called, yielding\npredictable results (for example, 0 in case of failure).\n\nAn example of such obfuscation is given on the Figure below: the only goal of this function is to assign the value of the argument source to a\nvariable pointed by target. In this case, the output of calling GetStockObject(789644) will always equal zero, as the function was given an\nintentionally incorrect argument.\n\nFigure 17. \"Arithmetic\" obfuscation in the HellowinPacker code\n\nVarious mutations are encountered at the assembler level as well: inserting junk code, using opaque predicates, calling functions with unused\narguments and repeated calls of the functions, and replacing instructions with their equivalents.\n\nFigure 18. Example of obfuscation at the assembler code level\n\n### Usage\n\nHellowinPacker exists at least since 2014 and has been so far used in various mass malware. Here are only a few examples:\n\n\n-----\n\n**Malware familyMalware family** **SHA256SHA256**\n\n[Cerber Ransomware](https://malpedia.caad.fkie.fraunhofer.de/details/win.cerber) 1e8b814a4bd850fc21690a66159a742bfcec212ccab3c3153a2c54c88c83ed9d\n\n[ZLoader](https://malpedia.caad.fkie.fraunhofer.de/details/win.zloader) 44ede6e1b9be1c013f13d82645f7a9cff7d92b267778f19b46aa5c1f7fa3c10b\n\n[Dridex](https://malpedia.caad.fkie.fraunhofer.de/details/win.dridex) f5dfbb67b582a58e86db314cc99924502d52ccc306a646da25f5f2529b7bff16\n\n[Bunitu](https://malpedia.caad.fkie.fraunhofer.de/details/win.bunitu) 54ff90a4b9d4f6bb2808476983c1a902d7d20fc0348a61c79ee2a9e123054cce\n\n[QakBot](https://malpedia.caad.fkie.fraunhofer.de/details/win.qakbot) c2482679c665dbec35164aba7554000817139035dc12efc9e936790ca49e7854\n\nThe packer has been frequently mentioned in reports by other researchers. The earliest mention we found dates back to 2015. In an article\nabout crypters, Malwarebytes experts analyze malware samples that use HellowinPacker. Later, other researchers referred to it as the Emotet\n[packer (1,](https://www.bromium.com/wp-content/uploads/2019/07/Bromium-Emotet-Technical-Analysis-Report.pdf) [2). In 2020, our colleagues from NCC Group called it CryptOne and described how it can be used to pack the WastedLocker](https://github.com/seth1002/analysis_report/blob/master/Emotet/2019_0918/packer_analyze.md)\n[ransomware. According to NCC Group, the crypter was also used by the Netwalker,](https://malpedia.caad.fkie.fraunhofer.de/details/win.mailto) [Gozi ISFB v3,](https://malpedia.caad.fkie.fraunhofer.de/details/win.isfb) [ZLoader, and](https://malpedia.caad.fkie.fraunhofer.de/details/win.zloader) [Smokeloader malware](https://malpedia.caad.fkie.fraunhofer.de/details/win.smokeloader)\nfamilies.\n\n## Conclusion\n\nOur example of using the crypters shows us how hackers can delegate responsibilities among each other, especially when it comes to mass\nmalware. Developing malicious payload, protecting it from antivirus tools («crypt»), and delivering it to end users—all this can be performed by\ncompletely unrelated hackers, and each element of this chain can be offered as a service. This approach lowers the cybercrime entry\nthreshold for technically unskilled criminals: to conduct a mass attack, all they have to do is to provide a necessary amount of money to pay for\nall the services.\n\nThe packers we described are certainly not the only ones that exist on the market. However, they demonstrate the common features of such\ntools: as a result of their work, an executable file is obtained with obfuscated polymorphic code of the unpacker and a payload encrypted in\nsome way or another. Mutations in code and reuse of the same crypters make static detection of payload almost impossible. However, since\nthe payload is somehow decrypted to the memory and then starts its malicious activity, behavioral analysis using sandboxes (such as PT\nSandbox) allows detecting malware and providing accurate verdicts even for packed files. In addition, it should be noted that packers do not\naffect the interaction of malware with C&C servers in any way. This makes it possible to determine the presence of malware in the network\n[using traffic analysis tools such as PT Network Attack Discovery.](https://www.ptsecurity.com/ww-en/products/network-attack-discovery/)\n\n## Verdicts of our products\n\n### PT Sandbox\n\nTrojan.Win32.RTM.a\n\nTrojan.Win32.RTM.b\n\nTrojan-Banker.Win32.RTM.a\n\nTrojan-Banker.Win32.RTM.b\n\nTrojan-Banker.Win32.RTM.c\n\nTrojan-Banker.Win32.RTM.d\n\nTrojan-Banker.Win32.RTM.e\n\nTrojan-Banker.Win32.RTM.f\n\n### PT Network Attack Discovery\n\nREMOTE [PTsecurity] TeamBot/RTM\n\nsid: 10004412;\n\nBACKDOOR [PTsecurity] TeamBot/RTM\n\nsid: 10004415;\n\nMALWARE [PTsecurity] RTM Banker CnC POST\n\nsid: 10000765;\n\nMALWARE [PTsecurity] RTM.N (Redaman)\n\nsid: 10005556; 10005557;\n\nMALWARE [PTsecurity] Spy.RTM.AF\n\nsid: 10005468;\n\n\n-----\n\n[ secu ty] oja [ a e ]/\nsid: 10004855; 10004875;\n\nMALWARE [PTsecurity] Win32/Spy.RTM.N (Redaman)\nsid: 10003414; 10004754; 10005555;\n\nPAYLOAD [PTsecurity] RTM.Payload.xor\nsid: 10005585;\n\n## IOCs (RTM)\n\n**Detection**\n**date** **Crypter** **SHA256** **SHA1**\n\n19.04.2020 RTM a4229a54f76815ac30a2a878eadf275e199c82da657dbc5f3fc05fe95603c320 ad22ceb309dd30dc769f63174292\n\n22.04.2020 Rex3Packer 9b88e8143e4452229dac7fdcc3d9281d21390f286c086f09aec410f120dc4325 f881729f6a5ca6fe80f385a2b0f858\n\n13.05.2020 HellowinPacker 43e8ebacfa319ff7d871eef3cc35266cfa7c6f44dd787f27a48311e39727e10f 8a28b75285409c55d5bbeca62e3\n\n\n28.01.2021 Rex3Packer (2\nlayers)\n\n\nfbf5974daee93bf5a2ed1816a4edbb108ceccb264d3e3f72d0aed268dd45e315 2e3352c6341ce57a03aaf2c4fbf48\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-12 - PaaS, or how hackers evade antivirus software.pdf"
    ],
    "report_names": [
        "2021-04-12 - PaaS, or how hackers evade antivirus software.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f5bf6853-3f6e-452c-a7b7-8f81c9a27476",
            "created_at": "2023-01-06T13:46:38.677391Z",
            "updated_at": "2025-03-27T02:00:02.889755Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "MISPGALAXY:Careto",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536088,
    "ts_updated_at": 1743041395,
    "ts_creation_date": 1653760027,
    "ts_modification_date": 1653760027,
    "files": {
        "pdf": "https://archive.orkl.eu/371d5535a5407a15488868e98c20c6b01c2edfc1.pdf",
        "text": "https://archive.orkl.eu/371d5535a5407a15488868e98c20c6b01c2edfc1.txt",
        "img": "https://archive.orkl.eu/371d5535a5407a15488868e98c20c6b01c2edfc1.jpg"
    }
}