{
    "id": "95360917-ca8d-47bc-b837-23b01b70cbfe",
    "created_at": "2023-01-12T15:06:07.810425Z",
    "updated_at": "2025-03-27T02:09:30.157709Z",
    "deleted_at": null,
    "sha1_hash": "f2f5ba7654b0a991519b2fba75803ce209ef6961",
    "title": "Detecting Manual Syscalls from User Mode",
    "authors": "",
    "file_creation_date": "2021-02-15T22:12:00Z",
    "file_modification_date": "2021-02-15T22:12:00Z",
    "file_size": 150238,
    "plain_text": "# Detecting Manual Syscalls from User Mode\n\n**winternl.com/detecting-manual-syscalls-from-user-mode**\n\nFebruary 10, 2021\n\nBy now direct system calls are ubiquitous in offensive tooling. Manual system calls remain\neffective for evading userland based EDRs. From within userland, there has been little\nanswer to this powerful technique. Such syscalls can be effectively mitigated from kernel\nmode, but for many reasons, most EDRs will continue to operate exclusively from usermode.\nThis post will present a novel method for detecting manual syscalls from usermode.\n\n## Previous Work\n\nIn 2015, [Alex Ionescu presented a talk at RECON entitled, Hooking Nirvana: Stealthy](https://twitter.com/aionescu)\n_Instrumentation Hooks, where, among other techniques, he described an instrumentation_\n[callback engine which is used internally by Microsoft. You can watch his talk here and read](https://www.youtube.com/watch?v=pHyWyH804xE)\n[his presentation slides here.](https://github.com/ionescu007/HookingNirvana/blob/master/Esoteric%20Hooks.pdf)\n\n[The techniques discussed here have already been weaponized for offensive code injection, but](https://splintercod3.blogspot.com/p/weaponizing-mapping-injection-with.html)\nas far as I can tell, have not been applied defensively.\n\n[My research is also based off of previous work done by @qaz_qaz and his PoC here.](https://twitter.com/_qaz_qaz) This\narticle also served as a primary point of reference.\n\nAnd finally, a user by the name of esoterik on the game-hacking forum unknowncheats\n[provided an example of a thread safe implementation of the instrumentation hook. Full](https://www.unknowncheats.me/forum/1967011-post29.html)\nthread.\n\n## Hooking Nirvana Revisted\n\n[There exists an internal instrumentation engine, known as Nirvana, used by Microsoft which](https://www.usenix.org/legacy/events/vee06/full_papers/p154-bhansali.pdf)\nhas been present since Windows Vista.\n\n_Nirvana is a lightweight, dynamic translation framework that can be used to monitor and_\n_control the (user mode) execution of a running process without needing to recompile or rebuild_\n_any code in that process. This is sometimes also referred to as program shepherding,_\n_sandboxing, emulation, or virtualization. Dynamic translation is a powerful complement to_\n_existing static analysis and instrumentation techniques._\n\n_– Microsoft_\n\nTo understand how this technique will ultimately work, it is necessary to first understand\nkernel to user mode callbacks. Ntdll maintains a set of exported functions which are used by\nthe kernel to invoke specific functionality in usermode. There are a number of these callbacks\n\n\n-----\n\nwhich are well documented. These functions are called when the kernel transitions back to\nuser mode. The location (i.e. exported function) will vary based upon intended functionality.\n\n_LdrInitializeThunk – Thread and initial process thread creation starting point._\n_KiUserExceptionDispatcher – Kernel exception dispatcher will IRET here on 1 of 2_\nconditions.\n\n1. the process has no debug port.\n2. the process has a debug port, but the debugger chose not to handle the exception.\n_KiRaiseUserExceptionDispatcher – Control flow will land here in certain instances_\nduring a system service when instead of returning a bad status code, it can simply\ninvoke the user exception chain. For instance: CloseHandle() with an invalid handle\nvalue.\n_KiUserCallbackDispatcher – Control flow will land here for Win32K window and_\nthread message based operations. It then calls into function table contained in the\nprocess PEB\n_KiUserApcDispatcher – This is where user queued apc’s are dispatched._\n\n[The above list was taken from this article. There are many such callbacks, and if you’d like to](https://www.codeproject.com/Articles/543542/Windows-x64-system-service-hooks-and-advanced-debu)\n[explore more you can visit Nynaeve’s blog.](http://www.nynaeve.net/?p=200)\n\nEach time the kernel encounters a scenario in which it returns to user mode code, it will\ncheck if the KPROCESS!InstrumentationCallback member is not NULL. If it is not NULL\nand it points to valid memory, the kernel will swap out the RIP on the trap frame and replace\nit with the value stored in the InstrumentationCallback field.\n\n0: kd> dt _kprocess\n\nnt!_KPROCESS\n\n// ...\n\n+0x3d8 InstrumentationCallback : Ptr64 Void\n\n[view raw kprocess.cpp hosted with by](https://gist.github.com/jackullrich/0ef359c7c918ac6a3354fd34da782c23/raw/265055ccb26c757098030dad8fea5cec68490c85/kprocess.cpp) [GitHub](https://github.com/)\nBut remember, this is the KPROCESS structure, which resides in kernel memory. Official\ndocumentation on the InstrumentationCallback field is sparse to non, but serendipitously,\nMicrosoft may have inadvertently leaked a clue we can utilize in their SDK. Referencing a\nspecific version of the Windows 7 SDK, there exists a\n_PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION structure._\n\ntypedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION\n\n{\n\nULONG Version;\n\n\n-----\n\nULONG Reserved;\n\nPVOID Callback;\n\n} PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION,\n*PPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;\n\n[view raw typedef.cpp hosted with by](https://gist.github.com/jackullrich/6c26b11cb66c0ff92837f45136885ca9/raw/56667899a68b1034585e3386a876f65aebef62b6/typedef.cpp) [GitHub](https://github.com/)\nThe KPROCESS!InstrumentationCallback field can be set from usermode by calling\n_NtSetInformationProcess with an undocumented PROCESSINFOCLASS value and a pointer_\nto a PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION structure.\n\nIt is worth noting that process instrumentation behavior and capabilities change between\nmost Windows versions, and certain functionality only exists in later Windows versions. For\nthis post, all research and development is done on a 64-bit Windows 10 machine.\n\n## Nirvana — Now What?\n\nTo recap, there exists internal functionality on Windows machines to instrument (read:\nhook) all kernel to usermode callbacks. In order to detect evasive syscall behavior, there must\nbe a defensive thesis on what makes a syscall malicious. Ideally, a defensive actor would like\nto allow all syscalls which originate from a legitimate source and block execution when\nsyscalls originate from a malicious source. Manual syscalls may function exactly as legitimate\nones but often originate well outside of where they “should be”. And the as saying goes, what\ngoes up must come down. Well, for this context, what transitions to the kernel, must\ntransition back to usermode. And this is exactly the defensive thesis used.\n\n_All syscalls which do not transition from_ _the kernel back to usermode at a known valid_\n_location, are in fact crafted for evasive purposes._\n\nThe plan now becomes clear. Find out if the syscall returns back to usermode at a known\nlocation. This address could be an exported function in ntdll.dll or win32u.dll (I’m sure there\nare more callbacks). It may not be a memory page in the .text section an unknown module.\n\n## Plan of Defense\n\nBecause Nirvana’s instrumentation engine hooks transitions from the kernel, we are tasked\nwith determining where the transition originated from. An auxiliary task, which increases\ninstrumentation robustness, is determining whether the transition was in fact a syscall or\nanother type of transition, such as an APC which would return to\n_ntdll!KiUserApcDispatcher. Still, these addresses should always return to a known module._\n\nAfter a syscall is issued, R10 will contain the address of the first instruction to be executed\nback in userland. This is almost always a return instruction. Validating the integrity of this\naddress can detect the presence of manual syscall invocations.\n\n\n-----\n\n## Instrumenting from User Mode\n\nSetting the KPROCESS!InstrumentationCallback field is easy. It can be done in about 20\nlines of code and only a single function call.\n\n#define PROCESS_INFO_CLASS_INSTRUMENTATION 40\n\ntypedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION\n\n{\n\nULONG Version;\n\nULONG Reserved;\n\nPVOID Callback;\n\n} PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION, *\nPPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;\n\nPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION nirvana;\n\nnirvana.Callback = (PVOID)(ULONG_PTR)InstrumentationCallbackThunk;\n\nnirvana.Reserved = 0; /* Always 0 */\n\nnirvana.Version = 0; /* x64 -> 0 | x86 -> 1 */\n\nNtSetInformationProcess(\n\nGetCurrentProcess(),\n\n(PROCESS_INFORMATION_CLASS)PROCESS_INFO_CLASS_INSTRUMENTATION,\n\n&nirvana,\n\nsizeof(nirvana));\n\n[view raw Instrumentation.cpp hosted with by](https://gist.github.com/jackullrich/9e8ca1d21b2eaebab7584b8441de811f/raw/57ce9d5ed6c466f5e3f9dae65d360db5c3ae6777/Instrumentation.cpp) [GitHub](https://github.com/)\nNow that we have the InstrumentationCallback field updated, we must implement the hook.\nThe hook has to be cognizant of all non-volatile registers, proper stack alignment,\nunintended recursion, and thread safety. The hook is implemented in two separate files, in\npart because the 64-bit MSVC compiler does not support inline assembly. The first part of\nthe instrumentation hook is coded in assembly. This procedure will be pointed to by the\n_KPROCESS!InstrumentationCallback field. It is responsible for preserving registers (which_\n\n\n-----\n\ncannot easily be accomplished without inline assembly) and subsequently calling the next\npart of the hooking routine. The second function is written in C/C++ and will contain the\nlogic needed to verify the integrity of the syscall.\n\nPrior to Windows 10, the instrumentation functionality used by this project was only\navailable for 64-bit Windows versions. To support x86 and WoW64, four new fields were\nadded to the TEB structure.\n\n_TEB_64\n\n+0x02D0 ULONG_PTR InstrumentationCallbackSp\n\n+0x02D8 ULONG_PTR InstrumentationCallbackPreviousPc\n\n+0x02E0 ULONG_PTR InstrumentationCallbackPreviousSp\n\n+0x02EC BOOLEAN InstrumentationCallbackDisabled\n\n[view raw teb.cpp hosted with by](https://gist.github.com/jackullrich/9b898e4654564f440f47ffdaf2c806a3/raw/bacd4ea27e5f1fe4075e32c7f53f84b9eaa5bd27/teb.cpp) [GitHub](https://github.com/)\nIn x64 Windows, I believe, but am not certain, these fields are unused when implementing\ninstrumentation callbacks. However, because they present a thread safe location to store\ninformation regarding the callback, the hook can use these addresses for reading and writing\ninformation. The following code is originally from esoterik, found under the previous\nresearch section.\n\nInstrumentationCallbackThunk proc\n\nmov gs:[2e0h], rsp ; _TEB_64 InstrumentationCallbackPreviousSp\n\nmov gs:[2d8h], r10 ; _TEB_64 InstrumentationCallbackPreviousPc\n\nmov r10, rcx ; Save original RCX\n\nsub rsp, 4d0h ; Alloc stack space for CONTEXT structure\n\nand rsp, -10h ; RSP must be 16 byte aligned before calls\n\nmov rcx, rsp\n\ncall __imp_RtlCaptureContext ; Save the current register state. RtlCaptureContext does\nnot require shadow space\n\nsub rsp, 20h ; Shadow space\n\ncall InstrumentationCallback\n\nInstrumentationCallbackThunk endp\n\n[view raw thunk64 asm hosted with by GitHub](https://gist.github.com/jackullrich/6fd5abd71ba8a555e7f1f9e3d8ff4a2f/raw/64801c603a8d4fe6d6fce7a52c4831edbca642f2/thunk64.asm)\n\n\n-----\n\nBecause Rtl functions are implemented entirely in usermode, there is no need to worry\nabout recursion here.\n\nThe second, and main part of the instrumentation routine is responsible for analyzing the\nexecution context at the point of kernel to usermode return. The routine is only a PoC and\nperforms a very cursory bounds check to determine whether RIP is pointing to a memory\nlocation within ntdll.dll or win32u.dll. If not, the program will warn of a potential manual\nsyscall and break execution.\n\nHere’s my version of the instrumentation hook which implements the minimal required code\nfor a PoC. Optionally it performs a reverse lookup if the executable is built with debug\ninformation.\n\n#define RIP_SANITY_CHECK(Rip,BaseAddress,ModuleSize) (Rip > BaseAddress) &&\n(Rip < (BaseAddress + ModuleSize))\n\nVOID InstrumentationCallback(PCONTEXT ctx)\n\n{\n\nBOOLEAN bInstrumentationCallbackDisabled;\n\nULONG_PTR NtdllBase;\n\nULONG_PTR W32UBase;\n\nDWORD NtdllSize;\n\nDWORD W32USize;\n\n#if _DEBUG\n\nBOOLEAN SymbolLookupResult;\n\nDWORD64 Displacement;\n\nPSYMBOL_INFO SymbolInfo;\n\nPCHAR SymbolBuffer[sizeof(SYMBOL_INFO) + 1024];\n\n#endif\n\nULONG_PTR pTEB = (ULONG_PTR)NtCurrentTeb();\n\n//\n\n\n-----\n\n// https://www.geoffchappell.com/studies/windows/win32/ntdll/structs/teb/index.htm\n\n//\n\nctx->Rip = *((ULONG_PTR*)(pTEB + 0x02D8)); // TEB>InstrumentationCallbackPreviousPc\n\nctx->Rsp = *((ULONG_PTR*)(pTEB + 0x02E0)); // TEB>InstrumentationCallbackPreviousSp\n\nctx->Rcx = ctx->R10;\n\n//\n\n// Prevent recursion. TEB->InstrumentationCallbackDisabled\n\n//\n\nbInstrumentationCallbackDisabled = *((BOOLEAN*)pTEB + 0x1b8);\n\nif (!bInstrumentationCallbackDisabled) {\n\n//\n\n// Disabling for no recursion\n\n//\n\n*((BOOLEAN*)pTEB + 0x1b8) = TRUE;\n\n#if _DEBUG\n\nSymbolInfo = (PSYMBOL_INFO)SymbolBuffer;\n\nRtlSecureZeroMemory(SymbolInfo, sizeof(SYMBOL_INFO) + 1024);\n\nSymbolInfo->SizeOfStruct = sizeof(SYMBOL_INFO);\n\nSymbolInfo->MaxNameLen = 1024;\n\nSymbolLookupResult = SymFromAddr(\n\nGetCurrentProcess(),\n\nctx->Rip,\n\n&Displacement,\n\n\n-----\n\nSymbolInfo\n\n);\n\n#endif\n\n#if _DEBUG\n\nif (SymbolLookupResult) {\n\n#endif\n\nNtdllBase = (ULONG_PTR)InterlockedCompareExchangePointer(\n\n(PVOID*)&g_NtdllBase,\n\nNULL,\n\nNULL\n\n);\n\nW32UBase = (ULONG_PTR)InterlockedCompareExchangePointer(\n\n(PVOID*)&g_W32UBase,\n\nNULL,\n\nNULL\n\n);\n\nNtdllSize = InterlockedCompareExchange(\n\n(DWORD*)&g_NtdllSize,\n\nNULL,\n\nNULL\n\n);\n\nW32USize = InterlockedCompareExchange(\n\n(DWORD*)&g_W32USize,\n\nNULL,\n\nNULL\n\n\n-----\n\n);\n\nif (RIP_SANITY_CHECK(ctx->Rip, NtdllBase, NtdllSize)) {\n\nif (NtdllBase) {\n\n#if _DEBUG\n\n//\n\n// See if we can look up by name\n\n//\n\nPVOID pFunction = GetProcAddress((HMODULE)NtdllBase, SymbolInfo->Name);\n\nif (!pFunction) {\n\nprintf(\"[-] Reverse lookup failed for function: %s.\\n\", SymbolInfo->Name);\n\n}\n\nelse {\n\nprintf(\"[+] Reverse lookup successful for function %s.\\n\", SymbolInfo->Name);\n\n}\n\n#endif\n\n}\n\nelse {\n\nprintf(\"[-] ntdll.dll not found.\\n\");\n\n}\n\n}\n\nelse if (RIP_SANITY_CHECK(ctx->Rip, W32UBase, W32USize)) {\n\nif (W32UBase) {\n\n#if _DEBUG\n\n//\n\n\n-----\n\n// See if we can look up by name\n\n//\n\nPVOID pFunction = GetProcAddress((HMODULE)W32UBase, SymbolInfo->Name);\n\nif (!pFunction) {\n\nprintf(\"[-] Reverse lookup failed for function: %s.\\n\", SymbolInfo->Name);\n\n}\n\nelse {\n\nprintf(\"[+] Reverse lookup successful for function %s.\\n\", SymbolInfo->Name);\n\n}\n\n#endif\n\n}\n\nelse {\n\nprintf(\"[-] win32u.dll not found.\\n\");\n\n}\n\n}\n\nelse {\n\nprintf(\"[SYSCALL-DETECT] Kernel returns to unverified module, preventing further\nexecution!\\n\");\n\n#if _DEBUG\n\nprintf(\"[SYSCALL-DETECT] Function: %s\\n\", SymbolInfo->Name);\n\n#endif\n\nDebugBreak();\n\n}\n\n#if _DEBUG\n\n}\n\nelse {\n\n\n-----\n\n//\n\n// SymFromAddr failed\n\n//\n\nprintf(\"SymFromAddr failed.\\n\");\n\n// DebugBreak();\n\n}\n\n#endif\n\n//\n\n// Enabling so we can catch next callback.\n\n//\n\n  - ((BOOLEAN*)pTEB + 0x1b8) = FALSE;\n\n}\n\nRtlRestoreContext(ctx, NULL);\n\n}\n\nIdeally, there should be much more verification done to ensure the integrity of the syscall.\nUltimately this will be left as an exercise to the reader. Here are some of my own ideas (I’d\nlove to hear yours):\n\nIf running an instrumentation routine on an executable with a pdb symbol file store,\none can use the set of symbol handler functions located within dbghelp.dll to perform\nreverse lookups. The symbol handler functions can resolve RIP to a function name\n[using the function SymFromAddr. If the function does not resolve, the syscall was most](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symfromaddr)\nlikely issued in an evasive way.\nAn immediate bypass to this technique which comes to mind is to simply overwrite a\nlegitimate, but seldom used exported function in ntdll.dll. One could simply overwrite\nthe syscall number with your desired index and call the function as normal. A\nresolution to this bypass might be to implement an anti-tamper routine on ntdl.dll’s\naddress space. Perhaps hash and cross-reference each of it’s Nt* routines.\n\n\n-----\n\nReverse disassembly seems feasible in providing further analysis of the origin of the\nsyscall. Syscalls will (always?) be followed by a ret instruction, which is the location\npointed to by RIP upon transition back to usermode. One can assume the previous\ninstruction will be a syscall (x64 Windows 10). Following the syscall stub structure\npresent in x64 Windows 10, the instruction preceding the syscall would move the\nsyscall service index into eax. I wonder if it’s possible to retrieve the syscall index from\nthe information available when the kernel returns to usermode? It would be a very\npowerful defensive technique to reverse disassemble RIP until the Nt* procedure base\nis identified (mov r10, rcx). Then cross-referencing the syscall index found via reverse\ndisassembly to the corresponding syscall index and address pair found by performing a\n[sort on the set of {Zw* U Nt*} function addresses (as described by odzhan). If the base](https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/)\naddresses and syscall indeces do not match, then the syscall was likely manual.\n\n## Final Remarks\n\nOf course, this is just another tool in the proverbial toolkit, and does not represent a\nsignificant change in the dynamic of the userland threat landscape. I do however, think this a\npowerful technique that has been overlooked by the blue team. Most userland unhookers do\nnot account for this instrumentation callback. Conversely, I see lots of potential for misuse\nand offensive tooling — as I hope you do too.\n\n[Full PoC available on my GitHub.](https://github.com/jackullrich/syscall-detect)\n\nNotepad functionality is allowed through the instrumentation callback. Functions are being\nresolved correctly via SymFromAddr. There is a noticeable performance impact due to\nconsole logging. Additionally, notepad will crash when the dll is injected before full process\ninitialization. The hook needs a lot more work!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/AV Tech/Detecting Manual Syscalls from User Mode.pdf"
    ],
    "report_names": [
        "Detecting Manual Syscalls from User Mode.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535967,
    "ts_updated_at": 1743041370,
    "ts_creation_date": 1613427120,
    "ts_modification_date": 1613427120,
    "files": {
        "pdf": "https://archive.orkl.eu/f2f5ba7654b0a991519b2fba75803ce209ef6961.pdf",
        "text": "https://archive.orkl.eu/f2f5ba7654b0a991519b2fba75803ce209ef6961.txt",
        "img": "https://archive.orkl.eu/f2f5ba7654b0a991519b2fba75803ce209ef6961.jpg"
    }
}