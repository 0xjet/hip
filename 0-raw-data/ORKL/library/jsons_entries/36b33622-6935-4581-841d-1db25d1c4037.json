{
    "id": "36b33622-6935-4581-841d-1db25d1c4037",
    "created_at": "2023-01-12T15:08:09.864521Z",
    "updated_at": "2025-03-27T02:06:06.277895Z",
    "deleted_at": null,
    "sha1_hash": "8472cfae8daacbb44b09293876727c413a54e71c",
    "title": "2016-12-07 - Floki Bot Strikes, Talos and Flashpoint Respond",
    "authors": "",
    "file_creation_date": "2022-05-27T21:10:01Z",
    "file_modification_date": "2022-05-27T21:10:01Z",
    "file_size": 810557,
    "plain_text": "# Floki Bot Strikes, Talos and Flashpoint Respond\n\n**blog.talosintel.com/2016/12/flokibot-collab.html**\n\n## Executive Summary\n\nFloki Bot is a new malware variant that has recently been offered for sale on various darknet\nmarkets. It is based on the same codebase that was used by the infamous Zeus trojan, the\n[source code of which was leaked in 2011. Rather than simply copying the features that were](https://github.com/Visgean/Zeus)\npresent within the Zeus trojan \"as-is\", Floki Bot claims to feature several new capabilities\nmaking it an attractive tool for criminals. As Talos is constantly monitoring changes across\nthe threat landscape to ensure that our customers remain protected as threats continue to\nevolve, we took a deep dive into this malware variant to determine the technical capabilities\nand characteristics of Floki Bot.\n\nDuring our analysis of Floki Bot, Talos identified modifications that had been made to the\ndropper mechanism present in the leaked Zeus source code in an attempt to make Floki Bot\nmore difficult to detect. Talos also observed the introduction of new code that allows Floki Bot\nto make use of the Tor network. However, this functionality does not appear to be active for\nthe time being. Finally, through the use of the [FIRST framework during the analysis process,](http://blog.talosintel.com/2016/12/project-first-share-knowledge-speed-up.html)\nTalos was able to quickly identify code/function reuse between Zeus and Floki Bot. This\nmade sample analysis more efficient and decreased the amount of time spent documenting\nvarious functions present within the Floki Bot samples we analyzed.\n\n\n-----\n\n[Talos worked in collaboration with Flashpoint during the analysis of Floki Bot. This](https://www.flashpoint-intel.com/)\ncollaborative effort allowed Talos and Flashpoint to quickly communicate intelligence data\nrelated to active campaigns distributing Floki Bot as well as data regarding the technical\nfunctionality present within the malware. Additionally, Talos is making scripts available to the\nopen source community that will help malware analysts automate portions of the Floki Bot\nanalysis process and make the process of analyzing Floki Bot easier to perform.\n\n## Floki Bot Details\n\nThe infection process used by Floki Bot is comprised of several steps. At a high level, this\nprocess is illustrated in the following diagram:\n\n**Figure 1: Inject Sequence of Malware Code**\n\nWe started our analysis of Floki Bot using the following binary:\n\n5e1967db286d886b87d1ec655559b9af694fc6e002fea3a6c7fd3c6b0b49ea6e (SHA256)\n\nOnce the malware is executed, it attempts to inject malicious code into 'explorer.exe' - the\nMicrosoft Windows file manager. If it is unable to open 'explorer.exe', it will then inject into\n'svchost.exe'. The first injection is simply a trampoline (step one in Figure 1). This trampoline\n\n\n-----\n\nperforms two different calls. The first call is a Sleep() for 100 milliseconds. The second call\npasses control to another payload function. The argument to that function is a structure with\nthe initial sample's process ID, the decryption key for further binary payloads, and the pointer\nand size of the payload resource in the initial sample's address space. Curiously enough,\nthough the initial sample has resources labeled 'bot32' and 'bot64', the sample we analyzed\nis hardcoded to only pass the address of the 'bot32' resource to the injected payload. The\nreversed code responsible for mapping the 'bot32', 'bot64' and 'key' resources is shown in\nFigure 2.\n\n**Figure 2: Mapping of 'bot32', 'bot64' and 'key' Resources**\n\nAs you can see from the following screenshots, Figure 3 shows the code responsible for\npreparing the shellcode for the injection. This operation is performed in the initial binary.\nFigure 4 shows the result of the injection into the 'explorer.exe' process. We can clearly\nobserve that the disassembly is based on the previous shellcode and contains the two calls\n\n\n-----\n\ndescribed above. Specifically, the call at 0xA001F invokes the payload, which is the step two\nin Figure 1.\n\n**Figure 3: Shellcode Preparation**\n\n**Figure 4: Disassembly of the Injected Shellcode**\n\nThe next logical step is another injection which also happens within the 'explorer.exe'\naddress space. This time the payload - the one executed after the trampoline - resolves the\nrequired APIs via the use of a CRC lookup and then maps the 'bot32' resource section from\nthe initial binary.\n\nThe resource is encrypted with RC4, and can be decrypted with the 16 byte key data from\nthe 'key' resource, which is passed as an argument to the injected code. Moreover, the\nresource is compressed with the LZNT1 algorithm, and is extracted by invoking\nRtlDecompressBuffer. Talos has created and is releasing a script called 'PayloadDump'\nwhich will extract these bot payloads. This bot is the final component and is the one\ncontaining the banking trojan functionality. It is flagged by many AV engines as a classic\nZeus bot. The bot is loaded and injected into 'explorer.exe'. These steps are the labeled 3\nand 4 in Figure 1.\n\nAt every stage, the malware uses hashing to obfuscate module and function names used in\ndynamic library resolution. Interestingly, the initial sample and the bot (bot32) executable use\nthe same CRC32 implementation and XOR the result with a static key in our case this was\n\n\n-----\n\n0x5E58, while the payload uses the same CRC32 implementation but a different XOR key, in\nour case 0x3086. The names of the modules are converted to lowercase before the\ncomputation (Windows file names are traditionally case insensitive).\n\nCurrently, the 'bot32' resource is immediately recognized by more than 30 AV engines on\nVirustotal, with most of the detections identifying it as Zbot, while the 'bot64' resource is\ndetected as malicious by only 10 AV engines. During our analysis, we extracted the sample\nfrom both a physical memory dump of the explorer.exe process (See the Memory Analysis\nsection), as well as from the resource section of the initial binary. At first glance, this sample\nlooks like a normal Zeus bot. The main difference is support for the Tor network that should\nbe activated when the C2 domain specified in the malware configuration ends with '.onion'\nwhich is the pseudo TLD for Tor related domains.. When this is the case, a standard Tor\nproxy server is configured to listen on localhost:9050, as you can see in the screenshot\nbelow:\n\n**Figure 5: Floki Bot Tor Functionality**\n\nThis feature appears to be under development and could not be activated in the samples\nTalos analyzed.\n\n## Floki Bot's Dropper/Loader\n\nThe loader used by Floki Bot is not encrypted. It also does not utilize any anti-debugging\ntechniques. The loader does hide the system calls used to inject the malicious payload into\nother processes. The injection technique used by the Floki Bot loader has already been\n[thoroughly documented here so we will not go into significant detail on how that process](https://blog.malwarebytes.com/threat-analysis/2016/11/floki-bot-and-the-stealthy-dropper/)\nworks.\n\n## Network Analysis\n\nFloki Bot communicates with C2 over an HTTPS connection. Interestingly, the malware\nauthor advertises an anti deep packet inspection feature. To achieve this, the bytes in\nnetwork packets are packaged in BinStorage structures that are sent over HTTPS. Each byte\nin the BinStorage structure is XOR'd by the previous byte and then additionally encrypted\nwith RC4. This functionality was also present in the leaked Zeus source code and is not new\nto Floki Bot. By breaking the HTTPS connection and decrypting the packet payloads, we\n\n\n-----\n\nnoticed that the malware sends back information about the infected machine such as the\ncomputer name and the screen resolution. Floki Bot claimed it \"cannot be detected by DeepPacket-Inspection unlike Zeus\", but the only major change to the leaked source code is Tor\nsupport, which was not found to be used by any samples found in the wild. Talos was able to\ndecrypt Floki Bot network packets after intercepting them using mitmproxy as the malware\ndoes not use certificate pinning for its communications.\n\n## Memory Analysis\n\nDuring our analysis we also performed a memory-based forensic analysis after infecting a\nVM with Floki Bot. In this way we used an opposite approach, starting our analysis from the\nend and then trying to rebuild the different steps of the infection process. First, we took a\n[physical memory dump with win32dd and analyzed it with Volatility - a famous open source](http://www.volatilityfoundation.org/)\nmemory forensics framework. First we used the 'pslist' Volatility plugin. This plugin lists all\nprocesses by walking the double linked list connecting all of the _EPROCESS objects.\nNothing suspicious was found from its output. We then used the 'netscan' plugin and it\nshowed network activity from the 'explorer.exe' process, which is something that needed\nmore investigation as it is definitely not normal to have network traffic from the file manager.\nBased on this finding, we ran 'malfind' on the 'explorer.exe' process and identified interesting\ntraces and the PE file injected into the process. We dumped these artifacts and they\nmatched the partial results of the reversing process. We could observe the trampoline, the\npayload and the PE file. In relation to the persistence mechanisms employed by Floki Bot,\nwe identified some artifacts using 'filescan' and observed that the binary (with a random\nname) was also copied into the Startup folder.\n\n## Collaboration with Flashpoint\n\nDuring our investigation into the Floki Bot malware, we leveraged a collaborative relationship\nwith Flashpoint, who we worked with to gather intelligence information and share technical\ndetails regarding the malware samples, the campaigns that are currently using Floki Bot, and\nthe darknet markets on which Floki Bot is being bought and sold. Flashpoint has been\ntracking several Floki Bot actors and campaigns. Flashpoint has also released a blog post\nthat contains relevant intelligence information related to currently active Floki Bot campaigns\n[operating globally. The Flashpoint post can be found here.](https://www.flashpoint-intel.com/flokibot-curious-case-brazilian-connector/)\n\n## Using FIRST to Analyze Floki Bot\n\nDuring the analysis process, Talos leveraged the Function Identification and Recovery\nSignature Tool (FIRST) and associated IDA Python plugin to collect and document\nfunctionality present within the Floki Bot samples that were analyzed. FIRST is an open\n\n\n-----\n\nsource framework recently released by Talos that allows malware analysts and researchers\nto collaborate and share analysis data related to the malicious functions present in malware\nsamples.\n\nUsing FIRST enables quick and efficient analysis of malware as it minimizes the amount of\ntime spent analyzing malicious code that has already been analyzed and documented.\nFIRST currently contains information for over 170,000 functions including: common libraries\nlike Zlib and OpenSSL, leaked malware source code, and malicious Windows and Linux files\nanalyzed by the community. It is particularly helpful when analyzing statically linked\nexecutables with thousands of library functions. Tools like Bindiff can be very useful, but they\nonly let you compare a handful of files, and you have to find and obtain these files before you\ncan do these comparisons. The FIRST plugin automatically looks for function similarities in\neach of the thousands of files submitted by the community.\n\nIDA Pro uses FLIRT signatures to attempt to identify commonly used library functions, but it\nwas unable to identify any functions in this sample of Floki Bot. IDA Pro's default response to\nunidentified functions is to name the functions according to the starting address. In this case\nwe get 516 functions with generic names like \"sub_402F34\".\n\n**Figure 6: IDA Pro Function List before running FIRST**\n\nWe queried FIRST, and within seconds had 128 functions labelled with meaningful names,\nprototypes, and comments. We can now instantly see what these functions do, and what\narguments they take, even when those arguments are custom structures.\n\n\n-----\n\n**Figure 7: IDA Pro Function List after running FIRST**\n\nMany functions are difficult to classify without first analyzing their child-functions. Analysts\noften use a depth-first approach to label functions with obvious behaviors, then backtrack to\nthe parent once they have a better understanding of the nested functions.\n\n\n-----\n\n**Figure 8: IDA Pro Showing Calls to Unknown Functions without FIRST**\n\nFIRST identified all of the functions in this example, and labeled them with their argument\nnames and types. Functions now have comments showing these functions were from leaked\nZeus source code, which gives us a substantial lead on where to find more info about the\nunidentified functions. Some functions not identified by FIRST are similar to functions in the\nZeus source, but have been changed by modifications in the source code or compiler\noptions.\n\n\n-----\n\n**Figure 9: The Same Function Labeled by FIRST**\n\nIf you compared this Floki Bot executable with Zeus, you would see the sizes of the\nBASECONFIG structures are different, and the offsets for global variables have changed as\nwell. One of FIRST's engines identified these functions despite modifications to these\nparameters. Thanks to FIRST, we are able to quickly find the chunk of leaked source code\nresponsible for this function.\n\n**Figure 10: Leaked Function Source Code**\n\nAll of the analysis data and function documentation that was created by Talos while\nanalyzing Floki Bot samples have been made available via the public Talos FIRST server\n\n\n-----\n\n(beta). More information about the FIRST framework and how it can be used can be found\n[here.](http://blog.talosintel.com/2016/12/project-first-share-knowledge-speed-up.html)\n\n## Tool Release\n\nDuring the analysis process, Talos also created scripts to help automate portions of the\nanalysis of Floki Bot, which are now being released to the open source community. These\nscripts enable analysts to dump the configuration parameters used by Floki Bot samples, as\nwell as the Floki Bot payload itself.\n\nPayloadDump - Extracts the final payload in PE32 format from the initial Floki Bot sample.\n\nConfigDump - Enables the extraction of the Floki Bot configuration parameters used by the\nsample.\n\n[These scripts can be downloaded from Github here.](https://github.com/vrtadmin/flokibot)\n\n## Conclusion\n\nFloki Bot is another example of what happens when the source code of successful malware\nkits gets leaked online. As we have seen several times since the Zeus source code became\navailable, new malware variants based on this codebase continue to emerge. Floki Bot is\nunique in that the authors of this malware have put effort into expanding upon the\nfunctionality that was present in Zeus and have implemented new functionality making Floki\nBot very attractive to criminals.\n\nAs Floki Bot is currently being actively bought and sold on several darknet markets it will\nlikely continue to be seen in the wild as cybercriminals continue to attempt to leverage it to\nattack systems in an aim to monetize their efforts. As the leak of the Zeus source code\ncontinues to have ripple effects across the threat landscape, Talos will continue to monitor\nthis and other threats that are actively being used in the wild to ensure that customers\nremain protected as new threats emerge or as existing threats change over time.\n\n## Coverage\n\nAdditional ways our customers can detect and block this threat are listed below.\n\n\n-----\n\n[Advanced Malware Protection (AMP) is ideally suited to prevent the execution of the](https://www.cisco.com/c/en/us/support/security/amp-firepower-software-license/tsd-products-support-series-home.html)\nmalware used by these threat actors.\n\n[CWS or](https://www.cisco.com/c/en/us/products/security/cloud-web-security/index.html) [WSA web scanning prevents access to malicious websites and detects malware](https://www.cisco.com/c/en/us/products/security/web-security-appliance/index.html)\nused in these attacks.\n\n[The Network Security protection of IPS and NGFW have up-to-date signatures to detect](https://www.cisco.com/c/en/us/products/security/intrusion-prevention-system-ips/index.html)\nmalicious network activity by threat actors.\n\n## Indicators of Compromise (IOCs)\n\n### Malware Binaries:\n\n08e132f3889ee73357b6bb38e752a749f40dd7e9fb168c6f66be3575dbbbc63d (SHA256)\n\n5028124ce748b23e709f1540a7c58310f8481e179aff7986d5cfd693c9af94da (SHA256)\n\n0aa1f07a2ebcdd42896d3d8fdb5e9a9fef0f4f894d2501b9cbbe4cbad673ec03 (SHA256)\n\n5e1967db286d886b87d1ec655559b9af694fc6e002fea3a6c7fd3c6b0b49ea6e (SHA256)\n\nd1d851326a00c1c14fc8ae77480a2150c398e4ef058c316ea32b191fd0e603c0 (SHA256)\n\ne0b599f73d0c46a5130396f81daf5ba9f31639589035b49686bf3ef5f164f009 (SHA256)\n\ne43ee2ab62f9dbeb6c3c43c91778308b450f5192c0abb0242bfddb8a65ab883a (SHA256)\n\n2b832ef36978f7852be42e6585e761c3e288cfbb53aef595c7289a3aef0d3c95 (SHA256)\n\n4bdd8bbdab3021d1d8cc23c388db83f1673bdab44288fccae932660eb11aec2a (SHA256)\n\n3c2c753dbb62920cc00e37a7cab64fe0e16952ff731d39db26573819eb715b67 (SHA256)\n\n7bd22e3147122eb4438f02356e8927f36866efa0cc07cc604f1bff03d76222a6 (SHA256)\n\n9d9c0ada6891309c2e43f6bad7ffe55c724bb79a0983ea6a51bc1d5dc7dccf83 (SHA256)\n\ne205a0f5688810599b1af8f65e8fd111e0e8fa2dc61fe979df76a0e4401c2784 (SHA256)\n\nac5ae89af8d2ffdda465a4038f0f24fcbcb650140741c2b48adadc252a140e54 (SHA256)\n\n### Command and Control URLs:\n\nhttps[:]//193.201.225[.]30/sweetdream/gxve8xj4a7t8t8sug8s57.php\n\nhttps[:]//shhtunnel[.]at/class/gate.php\n\n\n-----\n\nhttps[:]//extensivee[.]bid/000L7bo11Nq36ou9cfjfb0rDZ17E7ULo_4agents/gate.php\nhttps[:]//5.154.190[.]248/gate.php\nhttps[:]//vtraffic[.]su/gate.php\nhttps[:]//springlovee[.]at/adm/config.bin\nhttps[:]//feed.networksupdates[.]com/feed/webfeed.xml\nhttps[:]//wowsupplier[.]ga/cpflkabwbebeu/gtlejbsbu.php\nhttps[:]//adultgirlmail[.]com/mail/gate.php\nhttps[:]//uspal[.]cf/3faf5c96-9c2b-11e6-95d4-00163c75bf83/gate.php\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-12-07 - Floki Bot Strikes, Talos and Flashpoint Respond.pdf"
    ],
    "report_names": [
        "2016-12-07 - Floki Bot Strikes, Talos and Flashpoint Respond.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536089,
    "ts_updated_at": 1743041166,
    "ts_creation_date": 1653685801,
    "ts_modification_date": 1653685801,
    "files": {
        "pdf": "https://archive.orkl.eu/8472cfae8daacbb44b09293876727c413a54e71c.pdf",
        "text": "https://archive.orkl.eu/8472cfae8daacbb44b09293876727c413a54e71c.txt",
        "img": "https://archive.orkl.eu/8472cfae8daacbb44b09293876727c413a54e71c.jpg"
    }
}