{
    "id": "e006bbbb-4177-4f7b-b177-87086a6c6d88",
    "created_at": "2023-01-12T14:59:24.640917Z",
    "updated_at": "2025-03-27T02:06:06.496265Z",
    "deleted_at": null,
    "sha1_hash": "4ac98f27f69dd9a8c9fba6e814d3cbbd7079dce2",
    "title": "2021-09-14 - The Recent iOS 0-Click, CVE-2021-30860, Sounds Familiar. An Unreleased Write-up- One Year Later",
    "authors": "",
    "file_creation_date": "2022-05-28T23:15:50Z",
    "file_modification_date": "2022-05-28T23:15:50Z",
    "file_size": 555019,
    "plain_text": "# The Recent iOS 0-Click, CVE-2021-30860, Sounds Familiar. An Unreleased Write-up: One Year Later\n\n**blog.zecops.com/research/the-recent-ios-0-click-cve-2021-30860-sounds-familiar-an-unreleased-write-up-one-year-**\nlater/\n\nBy ZecOps Research Team September 14, 2021\n\n## TLDR;\n\nZecOps identified and reproduced an Out-Of-Bounds Write vulnerability that can be triggered\n[by opening a malformed PDF. This vulnerability reminded us of the FORCEDENTRY](https://citizenlab.ca/2021/09/forcedentry-nso-group-imessage-zero-click-exploit-captured-in-the-wild/)\nvulnerability exploited by NSO/Pegasus according to the CitizenLabs blog.\n\nAs a brief background: ZecOps have analyzed several devices of Al-Jazeera journalists in\nthe summer 2020 and automatically and successfully found compromised devices without\nrelying on any IOC. These attacks were later attributed to NSO / Pegasus.\n\n[ZecOps Mobile EDR and Mobile XDR are available here.](https://www.zecops.com/our-solution)\n\nNoteworthy, although these two vulnerabilities are different – they are close enough and\nworth a deeper read.\n\n**Timeline:**\n\n\n-----\n\nWe reported this vulnerability on September 1st, 2020 – iOS 14 beta was vulnerable\nat the time.\nThe vulnerability was patched on September 14th, 2020 – iOS 14 beta release.\nApple contacted us on October 20, 2020 – claiming that the bug was already fixed –\n(“We were unable to reproduce this issue using any current version of iOS 14. Are you\n_able to reproduce this issue using any version of iOS 14? If so, we would appreciate_\n_any additional information you can provide us, such as an updated proof-of-concept.”)._\nNo CVE was assigned.\n\nIt is possible that NSO noticed this incremental bug fix, and dived deeper into CoreGraphics.\n\n## The Background\n\nEarlier last year, we obtained a PDF file that cannot be previewed on iOS. The PDF sample\ncrashes previewUI with segmentation fault, meaning that a memory corruption was triggered\nby the PDF.\n\nOpen the PDF previewUI flashes and shows nothing:\n\n\n-----\n\nThe important question is: how do we find out the source of the memory corruption?\n\nThe MacOS preview works fine, no crash. Meaning that it’s the iOS library that might have an\nissue. We confirmed the assumption with the iPhone Simulator, since the crash happened on\nthe iPhone Simulator.\n\n\n-----\n\nIt’s great news since Simulator on MacOS provides better debug tools than iOS. However,\nhaving debug capability is not enough since the process crashes only when the corrupted\nmemory is being used, which is AFTER the actual memory corruption.\n\nWe need to find a way to trigger the crash right at the point the memory corruption happens.\n\n[The idea is to leverage Guard Malloc or](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MallocDebug.html) [Valgrind, making the process crash right at the](https://valgrind.org/)\nmemory corruption occurs.\n\n“Guard Malloc is a special version of the malloc library that replaces the standard\nlibrary during debugging. Guard Malloc uses several techniques to try and crash your\napplication at the specific point where a memory error occurs. For example, it places\nseparate memory allocations on different virtual memory pages and then deletes the\nentire page when the memory is freed. Subsequent attempts to access the deallocated\nmemory cause an immediate memory exception rather than a blind access into\nmemory that might now hold other data.”\n\n## Environment Variables Injection\n\nIn this case we cannot simply add an environment variable with the command line since the\npreviewUI launches on clicking the PDF which does not launch from the terminal, we need to\ninject libgmalloc before the launch.\n\n\n-----\n\nThe process launchd_sim launches Simulator XPC services with a trampoline process\ncalled “xpcproxy_sim”. The “xpcproxy_sim” launches target processes with a posix_spawn\nsystem call, which gives us an opportunity to inject environment variables into the target\nprocess, in this case “com.apple.quicklook.extension.previewUI”.\n\nThe following lldb command “process attach –name xpcproxy_sim –waitfor” allows us to\nattach xpcproxy_sim then set a breakpoint on posix_spawn once it’s launched.\n\nOnce the posix_spawn breakpoint is hit, we are able to read the original environment\nvariables by reading the address stored in the $r9 register.\n\nBy a few simple lldb expressions, we are able to overwrite one of the environment variables\ninto “DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib”, injection complete.\n\n\n-----\n\nContinuing execution, the process crashed almost right away.\n\n\n-----\n\n## Analyzing the Crash\n\nFinally we got the Malloc Guard working as expected, the previewUI crashes right at the\nmemmove function that triggers the memory corruption.\n\nAfter libgmalloc injection we have the following backtrace that shows an Out-Of-Bounds\n**write occurs in “CGDataProviderDirectGetBytesAtPositionInternal”.**\n\n\n-----\n\n```\nThread 3 Crashed:: Dispatch queue: PDFKit.PDFTilePool.workQueue\n0  libsystem_platform.dylib    0x0000000106afc867\n_platform_memmove$VARIANT$Nehalem + 71\n1  com.apple.CoreGraphics     0x0000000101b44a98\nCGDataProviderDirectGetBytesAtPositionInternal + 179\n2  com.apple.CoreGraphics     0x0000000101d125ab\nprovider_for_destination_get_bytes_at_position_inner + 562\n3  com.apple.CoreGraphics     0x0000000101b44b09\nCGDataProviderDirectGetBytesAtPositionInternal + 292\n4  com.apple.CoreGraphics     0x0000000101c6c60c\nprovider_with_softmask_get_bytes_at_position_inner + 611\n5  com.apple.CoreGraphics     0x0000000101b44b09\nCGDataProviderDirectGetBytesAtPositionInternal + 292\n6  com.apple.CoreGraphics     0x0000000101dad19a get_chunks_direct + 242\n7  com.apple.CoreGraphics     0x0000000101c58875 img_raw_read + 1470\n8  com.apple.CoreGraphics     0x0000000101c65611 img_data_lock + 10985\n9  com.apple.CoreGraphics     0x0000000101c6102f CGSImageDataLock + 1674\n10 com.apple.CoreGraphics     0x0000000101a2479e ripc_AcquireRIPImageData +\n875\n11 com.apple.CoreGraphics     0x0000000101c8399d ripc_DrawImage + 2237\n12 com.apple.CoreGraphics     0x0000000101c68d6f\nCGContextDrawImageWithOptions + 1112\n13 com.apple.CoreGraphics     0x0000000101ab7c94\nCGPDFDrawingContextDrawImage + 752\n\n```\nWith the same method, we can take one step further, with the MallocStackLogging flag\nlibgmalloc provides, we can track the function call stack at the time of each allocation.\n\nAfter setting the “MallocStackLoggingNoCompact=1”, we got the following backtrace\nshowing that the allocation was inside CGDataProviderCreateWithSoftMaskAndMatte.\n\n\n-----\n\n```\nALLOC 0x6000ec9f9ff0 0x6000ec9f9fff [size 16]:\n0x7fff51c07b77 (libsystem_pthread.dylib) start_wqthread |\n0x7fff51c08a3d (libsystem_pthread.dylib) _pthread_wqthread |\n0x7fff519f40c4 (libdispatch.dylib) _dispatch_workloop_worker_thread |\n0x7fff519ea044 (libdispatch.dylib) _dispatch_lane_invoke |\n0x7fff519e9753 (libdispatch.dylib) _dispatch_lane_serial_drain |\n0x7fff519e38cb (libdispatch.dylib) _dispatch_client_callout |\n0x7fff519e2951 (libdispatch.dylib) _dispatch_call_block_and_release |\n0x7fff2a9df04d (com.apple.PDFKit) __71-[PDFPageBackgroundManager\nforceUpdateActivePageIndex:withMaxDuration:]_block_invoke |\n0x7fff2a9dfe76 (com.apple.PDFKit) -[PDFPageBackgroundManager\n_drawPageImage:forQuality:] |\n0x7fff2aa23b85 (com.apple.PDFKit) -[PDFPage imageOfSize:forBox:withOptions:] |\n0x7fff2aa23e1e (com.apple.PDFKit) -[PDFPage\n_newCGImageWithBox:bitmapSize:scale:offset:backgroundColor:withRotation:withAntialiasi\n |\n0x7fff2aa22a40 (com.apple.PDFKit) -[PDFPage\n_drawWithBox:inContext:withRotation:isThumbnail:withAnnotations:withBookmark:withDeleg\n |\n0x7fff240bdfe0 (com.apple.CoreGraphics) CGContextDrawPDFPage |\n0x7fff240bdac4 (com.apple.CoreGraphics) CGContextDrawPDFPageWithDrawingCallbacks |\n0x7fff244bb0b1 (com.apple.CoreGraphics) CGPDFScannerScan | 0x7fff244bab02\n(com.apple.CoreGraphics) pdf_scanner_handle_xname |\n0x7fff2421e73c (com.apple.CoreGraphics) op_Do |\n0x7fff2414dc94 (com.apple.CoreGraphics) CGPDFDrawingContextDrawImage |\n0x7fff242fed6f (com.apple.CoreGraphics) CGContextDrawImageWithOptions |\n0x7fff2431999d (com.apple.CoreGraphics) ripc_DrawImage |\n0x7fff240ba79e (com.apple.CoreGraphics) ripc_AcquireRIPImageData |\n0x7fff242f6fe8 (com.apple.CoreGraphics) CGSImageDataLock |\n0x7fff242f758b (com.apple.CoreGraphics) img_image |\n0x7fff24301fe2 (com.apple.CoreGraphics) CGDataProviderCreateWithSoftMaskAndMatte |\n0x7fff51bddad8 (libsystem_malloc.dylib) calloc |\n0x7fff51bdd426 (libsystem_malloc.dylib) malloc_zone_calloc \n\n## The Vulnerability\n\n```\nThe OOB-Write vulnerability happens in the function\n“CGDataProviderDirectGetBytesAtPositionInternal” of CoreGraphics library, the\nallocation of the target memory was inside the function\n“CGDataProviderCreateWithSoftMaskAndMatte“.\n\n\n-----\n\nIt allocates 16 bytes of memory if the “bits_per_pixel” equals or less than 1 byte, which is\nless than copy length.\n\nWe came out with a minimum PoC and reported to Apple on September 1st 2020, the issue\nwas fixed on the iOS 14 release. We will release this POC soon.\n\n\n-----\n\nZecOps [Mobile EDR & Mobile XDR customers are protected against NSO and are well](https://www.zecops.com/contact/free-trial)\nequipped to discover other sophisticated attacks including 0-days attacks.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-14 - The Recent iOS 0-Click, CVE-2021-30860, Sounds Familiar. An Unreleased Write-up- One Year Later.pdf"
    ],
    "report_names": [
        "2021-09-14 - The Recent iOS 0-Click, CVE-2021-30860, Sounds Familiar. An Unreleased Write-up- One Year Later.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535564,
    "ts_updated_at": 1743041166,
    "ts_creation_date": 1653779750,
    "ts_modification_date": 1653779750,
    "files": {
        "pdf": "https://archive.orkl.eu/4ac98f27f69dd9a8c9fba6e814d3cbbd7079dce2.pdf",
        "text": "https://archive.orkl.eu/4ac98f27f69dd9a8c9fba6e814d3cbbd7079dce2.txt",
        "img": "https://archive.orkl.eu/4ac98f27f69dd9a8c9fba6e814d3cbbd7079dce2.jpg"
    }
}