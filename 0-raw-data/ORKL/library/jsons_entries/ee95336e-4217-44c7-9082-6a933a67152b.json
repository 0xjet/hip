{
    "id": "ee95336e-4217-44c7-9082-6a933a67152b",
    "created_at": "2023-01-12T14:59:28.403443Z",
    "updated_at": "2025-03-27T02:09:29.196157Z",
    "deleted_at": null,
    "sha1_hash": "e8c732a84d7531aae6e08c113edf2a3976ad3c86",
    "title": "2021-02-03 - Backdoored Browser Extensions Hid Malicious Traffic in Analytics Requests",
    "authors": "",
    "file_creation_date": "2022-05-29T01:17:47Z",
    "file_modification_date": "2022-05-29T01:17:47Z",
    "file_size": 1946498,
    "plain_text": "# Backdoored Browser Extensions Hid Malicious Traffic in Analytics Requests\n\n**[decoded.avast.io/janvojtesek/backdoored-browser-extensions-hid-malicious-traffic-in-analytics-requests/](https://decoded.avast.io/janvojtesek/backdoored-browser-extensions-hid-malicious-traffic-in-analytics-requests/)**\n\nby [Jan Vojtěšek and Jan RubínFebruary 3, 202119 min read](https://decoded.avast.io/category/pc/)\n\n\nFebruary 3, 2021\n\n\nChances are you are reading this blog post using your web browser. Chances also are your web browser has various extensions that provide\nadditional functionality. We usually trust that the extensions installed from official browser stores are safe. But that is not always the case as\nwe recently found.\n\n[This blog post brings more technical details on CacheFlow: a threat that we first reported about in December 2020. We described a huge](https://blog.avast.com/malicious-browser-extensions-avast)\ncampaign composed of dozens of malicious Chrome and Edge browser extensions with more than three million installations in total. We\nalerted both Google and Microsoft about the presence of these malicious extensions on their respective extension stores and are happy to\nannounce that both companies have since taken all of them down as of December 18, 2020.\n\nCacheFlow was notable in particular for the way that the malicious extensions would try to hide their command and control traffic in a covert\nchannel using the `Cache-Control HTTP header of their analytics requests. We believe this is a new technique. In addition, it appears to us`\nthat the Google Analytics-style traffic was added not just to hide the malicious commands, but that the extension authors were also interested\nin the analytics requests themselves. We believe they tried to solve two problems, command and control and getting analytics information,\nwith one solution.\n\nWe found that CacheFlow would carry out its attack in the following sequence:\n\n\n-----\n\nHigh-level overview of the CacheFlow malware\nBased on our telemetry, the top three countries where Avast users downloaded and installed the CacheFlow extensions were Brazil, Ukraine,\nand France.\n\nDistribution of Avast users that installed one of the malicious extensions\n[We initially learned about this campaign by reading a Czech blog post by Edvard Rejthar from CZ.NIC. He discovered that the Chrome](https://blog.nic.cz/2020/11/19/hledani-skodliveho-kodu-mezi-doplnky/)\nextension “Video Downloader for FaceBook™” (ID `pfnmibjifkhhblmdmaocfohebdpfppkf ) was stealthily loading an obfuscated piece of`\nJavaScript that had nothing to do with the extension’s advertised functionality. Continuing from his findings, we managed to find many other\nextensions that were doing the same thing. These other extensions offered various legitimate functionality, with many of them being video\ndownloaders for popular social media platforms. After reverse engineering the obfuscated JavaScript, we found that the main malicious\npayload delivered by these extensions was responsible for malicious browser redirects. Not only that, but the cybercriminals were also\ncollecting quite a lot of data about the users of the malicious extensions, such as all of their search engine queries or information about\neverything they clicked on.\n\n\n-----\n\ne e te s o s e b ted qu te a g e e o s ea ess by e p oy g a y t c s to o e t e c a ces o detect o st o a, t ey\navoided infecting users who were likely to be web developers. They determined this either through the extensions the user had installed or by\nchecking if the user accessed locally-hosted websites. Furthermore, the extensions delayed their malicious activity for at least three days\nafter installation to avoid raising red flags early on. When the malware detected that the browser developer tools were opened, it would\nimmediately deactivate its malicious functionality. CacheFlow also checked every Google search query and if the user was googling for one of\nthe malware’s command and control (C&C) domains, it reported this to its C&C server and could deactivate itself as well.\n\nAccording to user reviews on the Chrome Web Store, it seems that CacheFlow was active since at least October 2017. All of the stealthiness\ndescribed above could explain why it stayed undetected for so long.\n\nUser review\n\non the Chrome Web Store from October 2017 that mentions modification of Google search results\n\n## The covert channel\n\nFirst, we’ll show the hidden backdoor that the extensions used to download and execute arbitrary JavaScript. Specifically, we’ll describe the\nbackdoor from the Chrome extension “Downloader for Instagram” v5.7.3 (ID `olkpikmlhoaojbbmmpejnimiglejmboe ), but this analysis`\napplies to the other extensions as well, since the malicious code hidden in them is very similar in functionality.\n\n“Downloader for Instagram” page on the Chrome Web Store\nIt is generally a good idea to start the analysis of unknown Chrome extensions from the `manifest.json file. The manifest of “Downloader`\nfor Instagram” gives us some interesting pieces of information.\n\n\n-----\n\nst o a, t e co te t_secu `ty_po` `cy` s de ed suc a ay t at t s poss b e to use t e a ous e a u ct o to oad add t o a\nJavaScript. However, looking for the string `eval in the extension’s source code did not yield any interesting results. As we’ll show later, the`\nextension does use the `eval function quite a lot, but it hides its usage, so it is not immediately apparent.`\n\nContent Security Policy definition from the `manifest.json file`\nSecondly, the extension asks for quite a lot of permissions and it is not immediately clear why these permissions would be needed to\ndownload videos from Instagram. Especially interesting is the `management permission, which allows the extension to control other`\nextensions. The combination of the `webRequest and the` `<all_urls> permissions is also interesting. Together, these two permissions`\nmake it possible for the extension to intercept pretty much any web request coming from the browser.\n\nPermissions requested by the malicious extensions\n\nFinally, the manifest defines two background scripts: `js/jquery.js and` `js/background.js . These scripts are persistent, which means`\nthat they will keep running unless the extension gets disabled.\n\nBackground scripts declared in the `manifest.json file`\n\nOne of these background scripts, `background.js, is where the suspicious` `webRequest API is used. This script accesses the HTTP`\nresponse headers of all intercepted web requests and stores their values in localStorage.\n\nCacheFlow saves the values of all\n\nsufficiently long HTTP response headers into localStorage.\nThe content of localStorage is then read by the other persistent malicious background script: `jquery.js . While this script appears at first`\n[glance to be the legitimate jQuery library, some additional functions were inserted into it. One of those additional functions is misleadingly](https://jquery.com/)\nnamed `parseRelative, while all it does is return the` `window.localStorage object.`\n\nMisleadingly named `parseRelative function hidden inside` `jquery.js`\n\nAnother inserted and misleadingly named function is `initAjax .`\n\n\n-----\n\n```\ninitAjax function decodes the content of localStorage['cache-control'] and stores decoded values in the window object.\n\n```\nThis function is particularly interested in the content of `localStorage['cache-control'], which should at this point be set to the value of`\nthe last received `Cache-Control HTTP response header. The function splits the content of this header with a comma and attempts to`\ndecrypt each part using a custom function named `strrevsstr, before finally parsing it out as a JSON string.`\n```\nstrrevsstr function used by the extension to decrypt strings\n\n```\nThe obvious question now is why would the extension expect to intercept requests that contain an encrypted JSON string in the `Cache-`\n```\nControl response header?\n\n```\nThe answer is that the threat actors are using the content of the `Cache-Control header as a covert channel to send hidden commands to`\nthe malicious extension.\n\nAs a part of the malicious extension’s regular functionality, analytics requests about some events are sent to `https://stats.script-`\n```\nprotection[.]com/__utm.gif . These are standard analytics requests that bear resemblance to Google Analytics. The catch is, that the\n\n```\nserver used by this extension might respond to the analytics requests with a specially formed `Cache-Control header, which the client will`\ndecrypt, parse out and execute.\n\n\n-----\n\nFlow of the covert channel\nTo see what the commands could look like, we simulated the extension and sent a fake analytics HTTP request to `https://stats.script-`\n```\nprotection[.]com/__utm.gif . After a couple of attempts, we received a specially crafted Cache-Control header.\n\n```\nFiddler capture of a seemingly innocent analytics request that\n\ncontains a hidden command in the `Cache-Control response header`\nNote that the response will contain the encoded command only when some conditions are met. First of all, the GET parameter `it has to be`\nset at least three days into the past. Since this parameter contains the time when the extension was installed, this effectively ensures that the\nextension will not exhibit any malicious behavior during the first three days. There is also a check based on the IP address, since we\nrepeatedly did not receive any commands from one source IP address, even though we did receive a command for the same GET request\nfrom another IP address. As the logic behind these checks is safely hidden on the C&C server, there might be additional checks that we are\nnot aware of.\n\nWhen the content of the received `Cache-Control header is` [decoded using the custom](https://github.com/avast/ioc/blob/master/CacheFlow/extras/decryptor_strrevsstr.py) `strrevsstr function as outlined above, we get the`\ncommand in the following JSON. As was seen in the `initAjax function, all of the attributes from this JSON get stored in the global`\n```\nwindow object.\n\n```\n\n-----\n\nCommand decoded from the `Cache-Control`\n\nresponse header\nUpon receiving such a command, the extension downloads the second stage from `command['uu'] in a function named` `siblingAfter,`\nwhich is also hidden inside `jquery.js . The dollar sign from` `command['jj'] here represents the` `jQuery object, so the function uses the`\n```\njQuery.get function to download the next stage from command['uu'] and to store it in localStorage.dataDefault .\n\n```\nCode snippet that downloads the next stage\n\nfrom the URL specified in `command['uu']`\nFinally, there is yet another function hidden in `jquery.js, which executes the downloaded JavaScript using the` `eval function from`\n```\ncommand['ee'] .\n\n```\nCode snippet that uses the `eval`\n\nfunction on the downloaded JavaScript\nThe downloaded JavaScript is an obfuscated intermediary downloader. Its purpose is to download the third-stage payload from\n```\nulkon.johnoil[.]com using an XHR request. Unfortunately, because the server will only send the next stage under certain conditions,\n\n```\ngetting a response containing the third stage can be quite tricky. If it gets successfully downloaded, it is encrypted and stored persistently in\nlocalStorage. It then gets executed whenever a tab is updated using the `chrome.tabs.onUpdated listener.`\n\nIntermediary downloader\n\nserves as the second stage of the malware.\n\n## The payload\n\nThe payload starts out by testing if it can make use of `eval and` `localStorage . If either of those two is not working properly, CacheFlow`\nwould not be able to perform most of its malicious functionality.\n\n\n-----\n\nDeobfuscated snippet of the payload which tests if the `eval function works by adding`\n\ntwo random numbers\nAdditionally, the payload periodically checks if developer tools are opened. If they are, it deactivates itself in an attempt to avoid detection.\nThe check for developer tools is also performed whenever the current window gets resized, which might be because the user just opened\ndeveloper tools.\n\nDeobfuscated snippet of code that checks\n\nif the developer tools are opened\nAs was already mentioned, the malware authors have gone to extreme lengths to make sure that the hidden malicious payloads do not get\ndiscovered. We believe they were not satisfied with the previous check and decided to further profile the victim in order to avoid infecting\nusers who seemed more tech-savvy. One of the ways they did this was by enumerating the other extensions installed by the victim and\n[checking them against a hardcoded list of extension IDs. Each extension on the list was assigned a score and if the sum of scores of installed](https://github.com/avast/ioc/blob/master/CacheFlow/extras/developer_extensions.txt)\nextensions exceeded a certain threshold, the list of extensions would be sent to the C&C server, which could then command the malicious\n[payload to deactivate. Examples of the extensions on the list were “Chrome extension source viewer”, “Link Redirect Trace”, or “JWT](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin)\nDebugger”. We believe this “weighting” system helped to better differentiate actual developer systems which would have several of these\nextensions and a higher score from casual users who would have fewer extensions and thus a lower score.\n\n\n-----\n\nDeobfuscated snippet of code that enumerates other extensions\n\ninstalled by the victim\nAnother way to profile the potential victim was to check the URLs they were browsing. Whenever the victim navigated to a URL identified by\nan IP address from one of the private IPv4 ranges or to a URL with a TLD `.dev,` `.local, or` `.localhost, the malware would send the`\nvisited URL to its C&C server. The malware also checked all Google (and only Google) queries against a regular expression that matched its\nC&C domains and internal identifiers. This way, it would know that somebody was taking a deeper look into the extension and could take\nactions to hide itself. Interestingly, the domains were not fully specified in the regular expressions, with some characters being represented as\nthe dot special character. We assume that this was an attempt to make it harder to create a domain blocklist based on the regular expression.\n\nRegular expression used to detect if the victim is googling one of the malware’s C&C domains\nAt this point, the malware also attempted to gather information about the victim. This information included birth dates, email addresses,\ngeolocation, and device activity. For instance, the birth dates were retrieved from the personal information entered into the victim’s Google\naccount. Once again, the attackers focused only on Google: we did not see any similar attempts to get Microsoft account information. To\n[retrieve the birthday, CacheFlow made an XHR request to https://myaccount.google.com/birthday and parsed out the birth date from the](https://myaccount.google.com/birthday)\nresponse.\n\nDeobfuscated\n\nsnippet of code where the malware attempts to obtain the birth date of the victim\nNote that while it may seem that making such a cross-origin request would not be allowed by the browser, this is all perfectly possible under\nthe extension security model since the extension has the `<all_urls> permission. This permission gives the extension access to all hosts,`\nso it can make arbitrary cross-site requests.\n\n\n-----\n\no de to a e t a de o Goog e to ea e t at Cac e o as abus g ts se ces to gat e pe so a o at o, t a so eg ste ed a\nspecial `chrome.webRequest.onBeforeSendHeaders listener. This listener removes the` `referer request header from all the relevant XHR`\nrequests, so Google would not easily know who is actually making the request.\n\nDeobfuscated snippet of code where the malware removes the `referer`\n\nfrom requests to Google\nFinally, to perform its main malicious functionality, the payload injects another piece of JavaScript into each tab using the\n```\nchrome.tabs.executeScript function.\n\n## The injected script\n\n```\nThe injected script implements two pieces of functionality. The first one is about hijacking clicks. When the victim clicks on a link, the\nextension sends information about the click to `orgun.johnoil[.]com and might receive back a command to redirect the victim to a`\ndifferent URL. The second functionality concerns search engine results. When the victim is on a search engine page, the extension gathers\nthe search query and results. This information is then sent to the C&C server, which might respond with a command to redirect some of the\nsearch results.\n\n### Link hijacking\n\nThe link hijacking is implemented by registering an `onclick listener over the whole` `document .`\n\nDeobfuscated snippet of code showing the registration of the `onclick`\n\nlistener\nThe listener is then only interested in main button presses (usually “left clicks”) and clicks on elements with the tag name `a or` `area . If the`\nclick meets all the criteria, an XHR request to `https://orgun.johnoil[.]com/link/ is sent. This request contains one GET parameter,`\n```\na, which holds concatenated information about the click and is encrypted using the custom strsstr function. This information includes\n\n```\nthe current location, the target URL, various identifiers, and more.\n\nWe simulated a fake request about a click to a link leading to `https://facebook[.]com and received the following response:`\n```\nayiudvh3jk6lNjkzMTQ0eAgYGAQRFhNYTVxbE04IBlFDFgEEHBtYQV0HThdXEwJRBANSUVBEDghQCgNOWUMXAhskaiohB3Z4YQlvSU8oaygLZkhBYCJlAW\n\n```\nUpon receiving such a response, the malware first makes sure that it starts with a certain randomly generated string and ends with the same\nstring, but in reverse. This string ( ayiudvh3jk6l highlighted in the example above) was generated by the extension and was also included\nin the `a parameter that was sent in the XHR request. The extension then takes the middle portion of the response and decrypts it using the`\n```\nstrrevsstr function (which is the inversion of strsstr ). This yields the following string:\nayiudvh3jk6lhttps://go.lnkam[.]com/link/r?\nu=https%3A%2F%2Fwww.facebook[.]com%2F&campaign_id=b7YMMAqMdAL7wyzNe5m3wz&source=uvm3rdsqc9zo69l6kj3hvduiya\n\n```\nOnce again, the malware checks the beginning and the end of the decrypted string for the same randomly generated string as used before\nand extracts the middle portion of it. If it begins with the substring `http, the malware proceeds to perform the link hijack. It does this by`\ntemporarily changing the `href attribute of the element that the user clicked on and executing the` `click method on it to simulate a mouse`\nclick. As a fallback mechanism, the malware just simply sets `window.location['href'] to the link hijack URL.`\n\n\n-----\n\nDeobfuscated snippet of code that shows how the malware hijacks the\n\nvictim’s clicks\n\n### Modification of search results\n\nThe second functionality is performed only if the victim is currently on a Google, Bing, or Yahoo search page. If they are, the malware first\ngathers the search query string and the results. The way this is performed varies based on the search engine. For Google, the search query\nstring is found as the value of the first element named `q . If that somehow fails, the malware alternatively tries to get the search query from`\nthe `q GET parameter.`\n\nDeobfuscated\n\nsnippet of code that shows how the malware obtains the search query\nThe search results on Google are obtained by searching for elements with the class name `rc and then iterating over their child` `a`\nelements.\n\nDeobfuscated snippet of code that shows how the malware obtains\n\nthe search results\nOnce gathered, the search query and results are sent in an XHR request to `servscrpt[.]de . A salted MD5 checksum of the results is`\nincluded in the request as well, we believe in an attempt to discover fake requests (but this check can obviously be trivially bypassed by\nrecomputing the MD5 checksum). The XHR response contains a list of domains whose links the malware should hijack. The hijack itself is\nperformed by registering an `onmousedown listener on the` `a element. Once fired, the listener calls the` `preventDefault function on the`\nevent and then `window.open to redirect the user to the malicious URL.`\n\nInterestingly, CacheFlow also modifies some of the hijacked search results by adding a clickable logo to them. We believe this is done in\norder to make those results stand out and thus increase the chances of the victim clicking on them. However, the position of the logo is not\naligned well, which makes the search result look odd and suspicious, since Google, Microsoft, or Yahoo would probably put a bit more effort\ninto formatting it.\n\n\n-----\n\nCo pa so o t e o g a Goog e sea c esu t (top) t t e esu t t at as od ed by t e a a e (botto )\nThe logo is added by creating a brand new `div element which holds an` `img element. Once created and formatted, this element is inserted`\ninto the DOM, so that it appears to the left of the original search result. The logo is obtained from the `serviceimg[.]de domain, which`\nserves a unique 90×45 logo per domain.\n\nDeobfuscated\n\nsnippet of code where the malware creates an element with the added logo\n\n## Conclusion\n\nIn this blog post, we provided technical details about CacheFlow: a huge network of malicious browser extensions that infected millions of\nusers worldwide. We described how the malicious extensions were hijacking their victims’ clicks and modifying their search engine results.\nSince CacheFlow was well capable of hiding itself, we covered in detail the techniques it was using to hide the fact that it was executing\nmalicious code in the background. We believe that understanding how these techniques work will help other malware researchers in\ndiscovering and analyzing similar threats in the future.\n\n### Indicators of Compromise\n\n[The full list of IoCs is available at https://github.com/avast/ioc/tree/master/CacheFlow.](https://github.com/avast/ioc/tree/master/CacheFlow)\n\n**Name** **Hash**\n```\n manifest.json 2bc86c14609928183bf3d94e1b6f082a07e6ce0e80b1dffc48d3356b6942c051\n background.js bdd2ec1f2e5cc0ba3980f7f96cba5bf795a6e012120db9cab0d8981af3fa7f20\n jquery.js 3dad00763b7f97c27d481242bafa510a89fed19ba60c9487a65fa4e86dcf970d\n Intermediary downloader 4e236104f6e155cfe65179e7646bdb825078a9fea39463498c5b8cd99d409e7a\n Payload ebf6ca39894fc7d0e634bd6747131efbbd0d736e65e68dcc940e3294d3c93df4\n Injected script 0f99ec8031d482d3cefa979fbd61416558e03a5079f43c2d31aaf4ea20ce28a0\n\n```\n**Chrome Extension Name** **Extension ID**\n```\n Direct Message for Instagram mdpgppkombninhkfhaggckdmencplhmg\n DM for Instagram fgaapohcdolaiaijobecfleiohcfhdfb\n Invisible mode for Instagram Direct Message iibnodnghffmdcebaglfgnfkgemcbchf\n Downloader for Instagram olkpikmlhoaojbbmmpejnimiglejmboe\n App Phone for Instagram bhfoemlllidnfefgkeaeocnageepbael\n Stories for Instagram nilbfjdbacfdodpbdondbbkmoigehodg\n Universal Video Downloader eikbfklcjampfnmclhjeifbmfkpkfpbn\n Video Downloader for FaceBook™ pfnmibjifkhhblmdmaocfohebdpfppkf\n Vimeo™ Video Downloader cgpbghdbejagejmciefmekcklikpoeel\n Zoomer for Instagram and FaceBook klejifgmmnkgejbhgmpgajemhlnijlib\n VK UnBlock. Works fast. ceoldlgkhdbnnmojajjgfapagjccblib\n Odnoklassniki UnBlock. Works quickly. mnafnfdagggclnaggnjajohakfbppaih\n Upload photo to Instagram™ oknpgmaeedlbdichgaghebhiknmghffa\n Spotify Music Downloader pcaaejaejpolbbchlmbdjfiggojefllp\n The New York Times News lmcajpniijhhhpcnhleibgiehhicjlnk\n FORBES lgjogljbnbfjcaigalbhiagkboajmkkj\n Скачать фото и видео из Instagram akdbogfpgohikflhccclloneidjkogog\n\n```\n**Edge Extension Name** **Extension ID**\n\n\n-----\n\n```\nDirect Message for Instagram lnocaphbapmclliacmbbggnfnjojbjgf\nInstagram Download Video & Image bhcpgfhiobcpokfpdahijhnipenkplji\nApp Phone for Instagram dambkkeeabmnhelekdekfmabnckghdih\nUniversal Video Downloader dgjmdlifhbljhmgkjbojeejmeeplapej\nVideo Downloader for FaceBook™ emechknidkghbpiodihlodkhnljplpjm\nVimeo™ Video Downloader hajlccgbgjdcjaommiffaphjdndpjcio\nVolume Controller dljdbmkffjijepjnkonndbdiakjfdcic\nStories for Instagram cjmpdadldchjmljhkigoeejegmghaabp\nUpload photo to Instagram™ jlkfgpiicpnlbmmmpkpdjkkdolgomhmb\nPretty Kitty, The Cat Pet njdkgjbjmdceaibhngelkkloceihelle\nVideo Downloader for YouTube phoehhafolaebdpimmbmlofmeibdkckp\nSoundCloud Music Downloader pccfaccnfkjmdlkollpiaialndbieibj\nInstagram App with Direct Message DM fbhbpnjkpcdmcgcpfilooccjgemlkinn\nDownloader for Instagram aemaecahdckfllfldhgimjhdgiaahean\n\n```\n**URL**\n\n\n-----\n\n```\ns3.amazonaws[.]com/wwwjs/hc8e0ccd7266c.js\n\n```\n\n[Tagged asanalysis,](https://decoded.avast.io/tag/analysis/) [browser extension,](https://decoded.avast.io/tag/browser-extension/) [CacheFlow,](https://decoded.avast.io/tag/cacheflow/) [covert channel,](https://decoded.avast.io/tag/covert-channel/) [evasion,](https://decoded.avast.io/tag/evasion/) [malware](https://decoded.avast.io/tag/malware/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-02-03 - Backdoored Browser Extensions Hid Malicious Traffic in Analytics Requests.pdf"
    ],
    "report_names": [
        "2021-02-03 - Backdoored Browser Extensions Hid Malicious Traffic in Analytics Requests.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535568,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653787067,
    "ts_modification_date": 1653787067,
    "files": {
        "pdf": "https://archive.orkl.eu/e8c732a84d7531aae6e08c113edf2a3976ad3c86.pdf",
        "text": "https://archive.orkl.eu/e8c732a84d7531aae6e08c113edf2a3976ad3c86.txt",
        "img": "https://archive.orkl.eu/e8c732a84d7531aae6e08c113edf2a3976ad3c86.jpg"
    }
}