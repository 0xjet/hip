{
    "id": "ed21f405-5b22-48a1-87f2-14e28ba90d60",
    "created_at": "2022-10-25T16:48:22.160202Z",
    "updated_at": "2025-03-27T02:09:29.666813Z",
    "deleted_at": null,
    "sha1_hash": "203258819d7fbffdfae2c5df96d71254a2816ca6",
    "title": "Pest Control: Taming The Rats",
    "authors": "Matasano",
    "file_creation_date": "2012-10-05T18:36:58Z",
    "file_modification_date": "2012-10-05T18:36:58Z",
    "file_size": 562088,
    "plain_text": "# pest control: taming the rats\n\n\nAuthors\n\nShawn Denbow\n\nTwitter: @sdenbow_\n\nEmail: [denbos@rpi.edu](mailto:denbos@rpi.edu)\n\nJesse Hertz\n\nTwitter: @hectohertz\n\nEmail: jhertz@brown.edu\n\n\n## Remote Administration Tools (RATs) allow a remote attacker to control and access the system. In this paper, we present our analysis of their protocols, explain how to decrypt their traffic, as well as present vulnerabilities we have found.\n\nIntroduction\n\nAs 2012 Matasano summer interns, we were tasked with running a research\nproject with a couple criteria:\n\n- [It should be something we are both interested in.]\n\n- [We should be able to present our research for the company at the end of ]\n\nour internship. However, on completion, we decided that it would be best if\nwe made our findings public.\n\nWith John Villamil, our advisor, we decided that given our interest in low-level\nanalysis, we should analyze Remote Administration Tools (RATs). RATs have\nrecent seen media attention RATs due to their use by oppressive governments\nin spying on activists and other “dissidents”. We felt this to be a perfect\nproject.\n\nRemote Administration Tools are pieces of software which, once installed on a\nvictim’s computer allow a remote user to control and access the system. RATs\ncan be used legitimately by system administrators, or they can be used\nmaliciously.\n\nThere are a variety of methods by which they are installed on a computer:\nVarious social engineering tactics can be employed to get a user to open the\nexecutable, they can be bundled with other pieces of software, they can be\ninstalled as the payload of a virus or worm, or they can be installed after an\nattacker gains access to a system through an exploit. Most of the commonly\navailable RATs are at least able to perform keylogging, screen and camera\ncapture, file management, code and script execution, power control, registry\nmanagement, and password sniffing. Wikipedia has a more complete list of\ncommon RAT functionality [1].\n\nOur research focused on analyzing several publicly available RATs: DarkComet,\nBandook, CyberGate and Xtreme RAT. Interestingly, all of the RATs we\nanalyzed were coded either in part or entirely in Delphi. They all featured a\nreverse connecting architecture, as well as some form of cryptography or\nobfuscation of their communications. In this paper, we present our analysis of\ntheir protocols, explain how to decrypt their traffic, as well as present\nvulnerabilities we have found. The appendices to this paper contain MITM\ntools for decrypting traffic, as well as proof of concept exploits for the\nvulnerabilities we’ve found.\n\n\n-----\n\nBasic RAT Architecture\n\nMost RATs employ a “reverse-connecting” architecture.\n\nThe “client” program, resides on the attacker’s machine and is used to control\na compromised system. If often features a full UI designed for ease of use.\n\nIn contrast, the “server” program is a much smaller stub which is installed on\nthe compromised computer. These servers feature no UI, and take measures\nto disguise their presence.\n\nOn execution, the sever initiates a connection back to the client computer,\nand remote control is then possible. The client program typically has the\nability to generate server stubs, which have the IP address of the client (the\ncommand and control center) hard coded into them.\n\nSome free versions of the RATs we investigated were feature limited to\nproducing server stubs that were not stealthy or could only connect to\nlocalhost, with the ability to generate “full” stubs only available on purchasing\nthe paid version. Some servers had measures to defeat or disable antivirus\nand firewall software on the compromised machine.\n\nThe DarkComet RAT\n\nDarkComet is one of the most popular RATs in use today, gaining recent\nnotoriety after its use by the Syrian government [13]. The encryption method\nused in DarkComet has already been extensively analyzed by various\nresearchers [2] [3], so we will not reiterate here.\n\nWe reverse engineered the DarkComet protocol and analyzed it for\nvulnerabilities.\n\nAfter a quick look at its protocol, it is easy to see that it uses a “|” as it’s\ndelimiter between string parameters. Although, there is no delimiter between\nthe command and the first parameter.\n\nThe DarkComet client stores information about servers in a SQLite database,\nwhich is kept in the directory from which the client runs. This database also\nholds usernames and passwords for FTP servers to which the client has been\nconfigured to connect. When a new connection is established, a handshake\noccurs which looks like this:\n\n\n© Copyright 2012 Matasano Security.\n\n\n-----\n\nFor testing purposes, we wrote our own “server” which replied with the\nfollowing shorter SIN (Server Info) string:\n\ninfoesX|1|S|5|0s|W |x||US|I]|{7}|80%|E|6|5\n\nSQL Injection in DarkComet\n\nBy attaching a debugger to the client, we were able to view the SQL strings it\ngenerated by the client to query its database. Upon connection with the\nabove SIN string, the following SQL statement is executed:\n\n\"SELECT * FROM dc_users WHERE UUID=\"{7}\"\nIf that UUID is not in the database, the following statement is executed:\n\n\"INSERT INTO dc_users VALUES( \"{7}\", \"1\", \"S\", \"W\", \"0\")\"\nIf that UUID already exists, then the following statement is executed:\n\n\"UPDATE dc_users SET userIP=\"1\" WHERE UUID=\"{7}\"\"\n\nThere is no input validation or sanitization, so all of these SQL statements are\ninjectable with the following caveats:\n\n- [Executing multiple commands in one statement with “;”s is disabled, ]\n\nanything after a “;” will not be executed\n\n- [load_extension() is disabled]\n\nThese can be used to modify data in the database. We did not further\ndevelop these vulnerabilities to get information out of the database, as our\nnext exploit made doing so unnecessary.\n\nArbitrary File Read from the Client’s File System in DarkComet\n\nDarkComet uses a protocol that we have termed “QuickUp” in order to do\nad-hoc uploading of files. For instance, the client has a feature which allows\nyou to edit the compromised computers “hosts” file. This is done by\ndownloading the hosts file to the client computer, editing it, and then\nuploading it back to the server. The last part of that exchange uses the\nQuickUp protocol, and looks like this:\n\n\n© Copyright 2012 Matasano Security.\n\n\n-----\n\nNote that the protocol consists of two stages, the QUICKUP command issued\nfrom the client, which establishes a “new” connection, and the QUICKUP\ncommand issued from the server, which begins the file transfer. Most\nimportantly, after the new connection has been opened, the server requests\nthe file to be uploaded. Three major weaknesses are present in this\nimplementation:\n\n- [There is no check that the file in the client QUICKUP is the same as the file ]\n\nin the server QUICKUP\n\n- [The client responds to a QUICKUP commands, even if there was no ]\n\ncorresponding QUICKUP from the client\n\n- [The client allows the server to specify the absolute path]\n\nThis flaw allows the retrieval of any file on the filesystem that it has\npermissions to read. So for instance, to get a dump of the SQLite database,\nwe can do the following:\n\n(1) Connect to the server and successfully complete the handshake\n\n(2) Open a new connection over our old one, the client will now reply:\n\nDarkComet SQLite DB Dump\n\nC->S:\n\nIDTYPE\n_We now send a QUICKUP command unprompted_\nS->C:\n\nQUICKUP111|comet.db|UPLOADEXEC\n\nC->S (U):\n\n\\x41\\x00\\x43\n\nS->C (U):\n\nA\n\nC->S (U):\n\nLENGTH_OF_FILE\n\nS->C (U):\n\nA\n\nC->S (U):\n\nRAW_DATA_OF_COMET.DB\n\nAny file in the DarkComet directory can be read this way. Alternatively,\nabsolute paths can be specified, allowing read access to any file on the client’s\nfilesystem (that DarkComet has permissions to access).\n\nReading “C:\\secret.txt” from Client’s File System\n\n\n© Copyright 2012 Matasano Security.\n\n\n-----\n\nReading “C:\\secret.txt” from Client’s File SystemOverall, this presents an issue\nfor anyone using DarkComet. If a server sample is discovered, it is trivial to\nretrieve the key from the binary that is used in the network communication.\nThe key retrieval process can even be automated [4]. Recently, the developer\nof the RAT has quit any further development due to its misuse, therefore\nleaving this issue unpatched [12].\n\nFor a stub server (written in python) that can exploit both of these\nvulnerabilities, see Appendix A.\n\nThe Bandook RAT\n\nBandook is written in a mix of C++ and Delphi [5] [6]. The server is able to use\nprocess injection, API unhooking, and kernel patching to bypass (some\nversions) of the Windows firewall. The server itself is fairly limited in\nfunctionality, but has the ability to be extended through a plugin architecture:\nthe client can upload plugin code to the server. The client comes with several\nplugins which need to be installed on the server to enable full functionality. By\ndefault, the server attempts to hide itself by creating a process based on the\ndefault browser settings.\n\nIt lacks any real cryptography to protect its traffic. Instead, it obfuscates its\ntraffic by XORing against the constant 0xE9:\n\n### XOR Loop with Constant\n\nAlmost all messages are suffixed with “&&&” in cleartext:\n\n### Server Keepalive with “&&&”\n\nThe client comes bundled with TightVNC 1.2.9.0, which has a publicly\nknown security vulnerability. More information regarding the vulnerability\nand proof of concept code is available online [7].\n\nThe latest public release of Bandook is v1.35, while the private version is\nat 1.4. The public version was released April 2007, which makes it quite\nold and outdated. It only supports up to Windows Vista, while the private\nversion supports up to Win7.\n\n\n© Copyright 2012 Matasano Security.\n\n\n-----\n\nReverse Engineering The Bandook Protocol\nWe will leave out the “&&&” cleartext suffix from our analysis.\nEstablishing a connection with the client is simple. The server will start by\nsending one command:\n\nBandook Connection Initialization\n\nS -> C:\n\n&first& # 0d 1h 15m # Admin # # 172.16.250.128 / WhiteHouse\n\n#yes#yes#no#no#bndk13me#USA#no#yes#yes#\n\nSo a “first” command is used to establish a connection. The fields separated\nby “#” correspond to info displayed in the client, such as IP, username,\nuptime, and location. The fields marked yes/no correspond to whether the\nserver has a given plugin or not.\n\nThe keepalive is as follows:\n\nBandook Keepalive\n\nC -> S:\n\n&BANG&\n\nS-> C:\n\n&BAMG&\n\nTo see the protocol for additional functionality, we recommend using the\nMITM decoder in Appendix B. To any researchers who are interested in\nfurther work on Bandook, we have a fairly detailed set of notes on the\nadditional functionality protocols, which is available upon request.\n\nThe CyberGate RAT\n\nCyberGate is another RAT written in Delphi. It’s also the only RAT we saw that\nfeatured protection against reverse engineering. Using LordPE to obtain a\ndump, you can see the following strings:\n\n### CyberGate Anti-Analysis\n\n\n© Copyright 2012 Matasano Security.\n\n\n-----\n\nBoth PEiD and Detect It Easy could not identify what packer had been used.\nWe worked on unpacking it, until we finally discovered a tool called\nProtectionID. This was able to identify the packer as Safengine Licensor. From\nsome basic research, we discovered that unpacking the Safengine Licensor is a\nproject in itself. Due to our time constraint, we found it would be best to\ncontinue our efforts analyzing another RAT.\n\nBefore moving on though, we were able to uncover enough information about\nits protocol from the server stubs we created (which aren’t packed).\nInterestingly, CyberGate uses two different schemes for communication.\n\nCommunication from the client to the server is done using a variant of\nbase64. The messages are base64 encoded, except instead of the\ncanonical base64 string:\n\n“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567\n\n89+/”\n\nthe string used is\n\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwx\n\nyz+/\"\n\nThis is an obfuscation technique that is also common in enterprise\nsoftware; because the base64 dictionary has been scrambled, a standard\nbase64 decoder produces gibberish when fed the data.\n\nThe base64 encoded messages end with the string “###@@@”, which when\nreplaced with “==” and then fed into a base64 decoder (working against the\ncustom string), produce cleartext.\n\nIn the other direction, messages going from the server to the client are first\ncompressed using zlib (at a compression level of 1), and then encrypted with\nRC4 against the following key:\n\nnjgnjvejvorenwtrnionrionvironvrnvcg210public\n\nThey are then prefixed with the string “@@XXXXXXXXXX@@”\n\nBased off of this information, we think it’s safe to assume the private version\nwill have some subtle differences in its communication. Most likely the key is\ndifferent, but the overall communication architecture is the same.\n\n\n© Copyright 2012 Matasano Security.\n\n\n-----\n\n### CyberGate RC4 Swap\n\n\n© Copyright 2012 Matasano Security.\n\n\n-----\n\nIts keepalive looks like this:\n\nCyberGate Keepalive\n\nC -> S (U):\nping|S-> C:\nS->C (U):\npong|CyberGateServerConsole###10157|\n\nA MITM script that can decrypt traffic is in Appendix C.\n\nXtreme RAT\n\nXtreme RAT was another one of the RATs used by the Syrian government. We\nhaven’t seen much public analysis of Xtreme RAT. The guys over at malware.lu\npublished a simple article covering a sample they received in an email. Their\n\n\n© Copyright 2012 Matasano Security.\n\n\n-----\n\nanalysis covered identifying and decrypting config information from the stub\n\n[10]. Our analysis will look into the communication protocol of the RAT.\n\nBefore looking at any internals, we opted to get a feel for the UI. On the first\nrun, users are prompted to enter a password. Once entered, the program asks\nusers to retype the password to confirm it. After doing so, a file named\n“user.info” is created in the same directory. This file is simply a unicode string\nof the MD5 hash of your password.\n\n### Unicode MD5 Hash of Password in\n\nSo if your password is “123”, your user.info will contain the hash\n‘a933d13f81649bebe035dc21f4002ff1’. However, when we tried hashing\n“123” we found a different result (the correct hash is\n‘202cb962ac59075b964b07152d234b70’.) It turns out this is an issue that was\nintroduced in Delphi 2009, when the default string type switched from ANSI\nstrings to unicode strings. The MD5 implementation is not unicode aware [11],\nleading to incorrect hashes.\n\nWhen creating a server, we tried to change the password from its default\n‘0123456789’. It turns out Xtreme RAT limits your password to being only\ndigits. It also rejects any password that cannot fit in a 32-bit signed integer.\nWell, that’s not making us feel very secure.\n\nThe public version also limits the user to creating a stub which can only\nconnect to localhost on port 81. It also includes an annoying nag screen\nnotifying the user that it is the public version. However, all the functionality of\nthe private version is present. In order to begin analyzing its communication,\nwe had to change the communication IP. First, a quick analysis of the server\nstub.\n\nThe Xtreme RAT Server\n\nThe stub sets itself up using a classic technique found in basic malware. It first\nuses CreateProcess() to create a new process (named based on the default\nbrowser.)\n\n### CreateProcess() Based on Default\n\nNext, it uses WriteProcessMemory() to copy code to the newly created process\n(PE header starts at 0x1610000).\n\n\n© Copyright 2012 Matasano Security.\n\n\n-----\n\n### Copying Code to the Newly Created\n\nIt finishes the setup by simply resuming the thread using ResumeThread().\nAfter patching the process to have an opcode of 0xEBFE, which is an infinite\nloop, at the point where the thread resumes, we attached a debugger and\nnoticed that the process begins packed with UPX.\n\n### Standard Entry Point\n\nUnpacking is trivial from this point. Locate the JMP following the POPAD\ninstruction.\n\n### Standard JMP to OEP\n\nThis brings us to our OEP:\n\n### Original Entry Point for\n\nAfter patching the dump to connect to a different address, and removing the\nnag screen, we were able to start our analysis of the communication.\n\nXtreme RAT Communication\n\n\n© Copyright 2012 Matasano Security.\n\n\n-----\n\nThe communication of Xtreme RAT begins with the server making a\nconnection to the client. We then have the following:\n\nXtreme RAT Identify Message\n\nS ->C (U):\n\nmyversion|3.6 Public\\r\\n\n\nThe client acknowledges by sending:\n\nXtreme RAT ACK\n\nC ->S (U):\n\\x58\\x0d\\x0a\n\nCommunication continues with the client asking for info about the server.\nNotice that before any message sent, the stub or client will first send the\npassword and length of the message to come, in little endian format.\nAnnoyingly, sometimes it sends this header as its own packet, sometimes it\ncomes prefixed to the actual content. And sometimes it prefixes the header\nwith an ACK of “\\x58\\x0d\\x0a”. In this example, the password is 1234 and the\nlength of the message to follow is 166 bytes.\n\n### Xtreme RAT Password/Length Message\n\nC -> S:\n\n\\xd2\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\xa6\\x00\\x00\\x00\\x00\\x00\\x00\\x00\n\n|-> Password = 0x4d2 = 1234\n\n|->Four bytes padding\n\n|-> Length = 0xa6 = 166\n\n|->Four bytes padding\n\nNow what follows is some zlib compressed data with size 166 bytes. Note that\nsometimes our MITM script fails to decode the zlib compressed data, for\nreasons unknown to us. After decompression we have the following:\n\n\n© Copyright 2012 Matasano Security.\n\n\n-----\n\nBreaking it into its parts we have:\n\nXtreme RAT Maininfo Dissected\n\nCMD:\nmaininfo\nSEPARATOR:\n\\xc2\\x00\\xaa\\x00\\xc2\\x00\\xaa\\x00\\xc2\\x00\\xaa\n\\x00\\x23\\x00\\x23\\x00\\x23\\x00\\xe2\\x00\\x22\\x20\\x61\\x01\\xe2\\x00\\x22\\x20\\x61\\x01\\xe2\\x00\\x22\\x20\n\\x61\\x01\nRANDOM STRING:\npK8qxVwtQ7XBgCuT0bFldfRjaSLmhHPGJyirE5z2A431ZMYUe69WnDcsoNk\nMD5:\n90dd3e7e19b35baa54015d0b4a08f2d0\n\nThe random string is just that, a random string of length 0x3B or 59. It’s\ngenerated using the character set: [0-9],[A-Z],[a-z]. The hash is the incorrect\nMD5sum of “XtremeRAT”. This will always remain the same (at least for the\npublic version 3.6).\n\nWhat follows is a response which contains some information about the system.\nIt follows the same protocol as before, with the password and length header,\nand the remaining message being compressed with zlib. After this response,\nthe stub is now connected to the client, but will continue to send more info,\nsuch as a screenshot of the desktop and a list of any webcams installed.\n\nAt this point, a full connection is established. The client will send a keep alive\nwhile idle, which looks like the following:\n\nXtreme RAT Keepalive\n\nC -> S:\n\nping\n\nS -> C:\n\npong|937|Current_Window (Server_Name)\n\nAlso worth noting, Xtreme has the ability to try to disguise its handshake as\nHTTP. In which case, its opening request will look like (with the default\npassword):\n\n\n© Copyright 2012 Matasano Security.\n\n\n-----\n\nConclusion\n\nRATs represent an under-researched but highly active area of malware “in the\nwild”. With both governments and non-state actors using RATs for\nsurveillance, knowledge about them carries increasing significance. A good\nunderstanding of their protocols is critical to network and system\nadministrators deploying tools that can notice the presence of a RAT.\n\nAll of the RATs we analyzed were written in Delphi. This gave the RATs some\nresilience against classical security mistakes (buffer/heap overflows) that are\nmuch easier to make in a language like C or C++. However, we still found\nserious vulnerabilities in DarkComet, which was the most widely deployed of\nthe RATs we studied. Our analysis of the communications should provide a\nsolid foundation for other researchers interested in further reverse engineering\nand vulnerability research on RATs.\n\nSome notable coincidences in behaviors between RATs (use of Delphi, using\nthe “|” character as a separator, similar UIs, use of zlib, use of RC4, and other\nprotocol similarities) may suggest shared code, although we do not have\nenough evidence to make any definitive statements on that subject.\n\nSpecial thanks to John Villamil (@day6reak) for his guidance and\nknowledge on this project, and to the rest of the Matasano Security team!\n\n\n© Copyright 2012 Matasano Security.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/k6kyhjnok9n5vqtchm4u1luoluth0j1i",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2012/2012.10.08.Pest_Control/PEST-CONTROL.pdf"
    ],
    "report_names": [
        "PEST-CONTROL"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716502,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1349462218,
    "ts_modification_date": 1349462218,
    "files": {
        "pdf": "https://archive.orkl.eu/203258819d7fbffdfae2c5df96d71254a2816ca6.pdf",
        "text": "https://archive.orkl.eu/203258819d7fbffdfae2c5df96d71254a2816ca6.txt",
        "img": "https://archive.orkl.eu/203258819d7fbffdfae2c5df96d71254a2816ca6.jpg"
    }
}