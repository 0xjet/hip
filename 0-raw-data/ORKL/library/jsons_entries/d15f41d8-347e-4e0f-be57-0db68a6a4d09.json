{
    "id": "d15f41d8-347e-4e0f-be57-0db68a6a4d09",
    "created_at": "2023-01-12T15:08:40.155341Z",
    "updated_at": "2025-03-27T02:05:30.790049Z",
    "deleted_at": null,
    "sha1_hash": "4c9399f95c5497df4a9392311350f03a6503ce71",
    "title": "2020-07-12 - Deobfuscating DanaBot’s API Hashing",
    "authors": "",
    "file_creation_date": "2022-05-28T04:01:05Z",
    "file_modification_date": "2022-05-28T04:01:05Z",
    "file_size": 469728,
    "plain_text": "# Deobfuscating DanaBot’s API Hashing\n\n**[malwareandstuff.com/deobfuscating-danabots-api-hashing/](https://malwareandstuff.com/deobfuscating-danabots-api-hashing/)**\n\n[Published by hackingump on July 12, 2020](https://malwareandstuff.com/author/klopsch/)\n\n\nJuly 12, 2020\n\n\nYou probably already guessed it from the title’s name, API Hashing is used to obfuscate a\nbinary in order to hide API names from static analysis tools, hindering a reverse engineer to\nunderstand the malware’s functionality.\n\nA first approach to get an idea of an executable’s functionalities is to more or less dive\nthrough the functions and look out for API calls. If, for example a `CreateFileW function is`\ncalled in a specific subroutine, it probably means that cross references or the routine itself\nimplement some file handling functionalities. This won’t be possible if API Hashing is used.\n\nInstead of calling the function directly, each API call has a corresponding checksum/hash. A\nhardcoded hash value might be retrieved and for each library function a checksum is\ncomputed. If the computed value matches the hash value we compare it against, we found\nour target.\n\n\n-----\n\nAPI Hashing used by DanaBot\nIn this case a reverse engineer needs to choose a different path to analyse the binary or\ndeobfuscate it. This blog article will cover how the DanaBot banking trojan implements API\nHashing and possibly the easiest way on how this can be defeated. The `SHA256 of the`\nbinary I am dissecting here is added at the end of this blog post.\n\n## Deep diving into DanaBot\n\nDanaBot itself is a banking trojan and has been around since atleast 2018 and was first\n[discovered by ESET[1]. It is worth mentioning that it implements most of its functionalities in](https://www.welivesecurity.com/2019/02/07/danabot-updated-new-cc-communication/)\nplugins, which are downloaded from the C2 server. I will focus on deobfuscating API Hashing\nin the first stage of DanaBot, a DLL which is dropped and persisted on the system, used to\ndownload further plugins.\n\n\n-----\n\n**Reversing the ResolvFuncHash routine**\n\nAt the beginning of the function, the `EAX register stores a pointer to the` `DOS header of the`\nDynamic Linked Library which, contains the function the binary wants to call. The\ncorresponding hash of the yet unknown API function is stored in the `EDX register. The`\nroutine also contains a pile of junk instructions, obfuscating the actual use case for this\nfunction.\n\nThe hash is computed solely from the function name, so the first step is to get a pointer to all\nfunction names of the target library. Each DLL contains a table with all exported functions,\nwhich are loaded into memory. This Export Directory is always the first entry in the Data\nDirectory array. The PE file format and its headers contain enough information to reach this\nmentioned directory by parsing header structures:\n\nCycling through the PE headers to obtain the ExportDirectory and AddressOfNames\nIn the picture below, you can see an example of the mentioned junk instructions, as well as\nthe critical block, which compares the computed hash with the checksum of the function we\nwant to call. The routine iterates through all function names in the Export Directory and\ncalculates the hash.\n\nThe loop breaks once the computed hash matches the value that is stored in the `EDX`\nregister since the beginning of this routine.\n\n\n-----\n\nGraph overview of obfuscated API Hashing function\n\n**Reversing the hashing algorithm**\n\nThe hashing algorithm is fairly simple and nothing too complicated. Junk instructions and\nopaque predicates complicate the process of reversing this routine.\n\nThe algorithm takes the `nth and the` `stringLength-n-1th char of the function name and`\nstores them, as well as capitalised versions into memory, resulting in a total of 4 characters.\nEach one of those characters is `XOR'd with the string length. Finally they are multiplied and`\nthe values  are added up each time the loop is run and result in the hash value.\n\n\n-----\n\n```\ndef get_hash(funcname):\n  \"\"\"Calculate the hash value for function name. Return hash value as integer\"\"\"\n  strlen = len(funcname)\n  # if the length is even, we encounter a different behaviour\n  i = 0\n  hashv = 0x0\n  while i < strlen:\n    if i == (strlen - 1):\n      ch1 = funcname[0]\n    else:\n      ch1 = funcname[strlen - 2 - i]\n    # init first character and capitalize it\n    ch = funcname[i]\n    uc_ch = ch.capitalize()\n    # Capitalize the second character\n    uc_ch1 = ch1.capitalize()\n    # Calculate all XOR values\n    xor_ch = ord(ch) ^ strlen\n    xor_uc_ch = ord(uc_ch) ^ strlen\n    xor_ch1 = ord(ch1) ^ strlen\n    xor_uc_ch1 = ord(uc_ch1) ^ strlen\n    # do the multiplication and XOR again with upper case character1\n    hashv += ((xor_ch * xor_ch1) * xor_uc_ch)\n    hashv = hashv ^ xor_uc_ch1\n    i += 1\n  return hashv\n\n```\nA python script for calculating the hash for a given function name is also uploaded on my\n[github page[2] and free for everyone to use. I’ve also uploaded a text file with hashes for](https://github.com/hackingump/malwareStuff)\nexported functions of commonly used DLLs.\n\n## Deobfuscation by Commenting\n\nSo now that we cracked the algorithm, we want to update our disassembly to know which\nhash value represents which function. As I’ve already mentioned, we want to focus on\nsimplicity. The easiest way is to compute hash values for exported functions of commonly\nused DLLs and write them into a file.\n\n\n-----\n\nGenerated hashes\nWith this file, we can write an `IdaPython script to comment the library function name next`\nto the Api Hashing call. Luckily the Api Hashing function is always called with the same\npattern:\n\nMove the wanted hash value into the `EDX register`\nMove a `DWORD into` `EAX register`\n\nFirst we retrieve all `XRefs of the Api Hashing function. Each` `XRef will contain an address`\nwhere the Api Hashing function is called at, which means that in atleast the 5 previous\ninstructions, we will find the mentioned pattern. So we will fetch the previous instruction until\nwe extract the wanted hash value, which is being pushed into `EDX . Finally we can use this`\nimmediate to extract the corresponding api function from the hash values we have generated\nbefore and comment the function name next to the `Xref address.`\n\n\n-----\n\n```\ndef add_comment(addr, hashv, api_table):\n  \"\"\"Write a comment at addr with the matching api function.Return True if a\ncorresponding api hash was found.\"\"\"\n  # remove the \"h\" at the end of the string\n  hashv = hex(int(hashv[:-1], 16))\n  keys = api_table.keys()\n  if hashv in keys:\n    apifunc = api_table[hashv]\n    print \"Found ApiFunction = %s. Adding comment.\" % (apifunc,)\n    idc.MakeComm(addr, apifunc)\n    comment_added = True\n  else:\n    print \"Api function for hash = %s not found\" % (hashv,)\n    comment_added = False\n  return comment_added\ndef main():\n  \"\"\"Main\"\"\"\n  f = open(\n    \"C:\\\\Users\\\\luffy\\\\Desktop\\\\Danabot\\\\05-072020\\\\Utils\\\\danabot_hash_table.txt\", \"r\")\n  lines = f.readlines()\n  f.close()\n  api_table = get_api_table(lines)\n  i = 0\n  ii = 0\n  for xref in idautils.XrefsTo(0x2f2858):\n    i += 1\n    currentaddr = xref.frm\n    addr_minus = currentaddr - 0x10\n    while currentaddr >= addr_minus:\n      currentaddr = PrevHead(currentaddr)\n      is_mov = GetMnem(currentaddr) == \"mov\"\n      if is_mov:\n        dst_is_edx = GetOpnd(currentaddr, 0) == \"edx\"\n        # needs to be edx register to match pattern\n        if dst_is_edx:\n          src = GetOpnd(currentaddr, 1)\n          # immediate always ends with 'h' in IDA\n          if src.endswith(\"h\"):\n            add_comment(xref.frm, src, api_table)\n            ii += 1\n  print \"Total xrefs found %d\" % (i,)\n  print \"Total api hash functions deobfuscated %d\" % (ii,)\nif __name__ == '__main__':\n  main()\n\n## Conclusion\n\n```\n\n-----\n\nAs reverse engineers, we will probably continue to encounter Api Hashing in various different\nways. I hope I was able to show you some quick & dirty method or give you at least some\nfundament on how to beat this obfuscation technique. I also hope that, the next time a blue\nteam fellow has to analyse DanaBot, this article might become handy to him and saves him\nsome time reverse engineering this banking trojan.\n\n## IoCs\n\nDropper =\n```\n   e444e98ee06dc0e26cae8aa57a0cddab7b050db22d3002bd2b0da47d4fd5d78c\n\n```\nDLL = `cde01a2eeb558545c57d5c71c75e9a3b70d71ea6bbeda790a0b871fcb1b76f49`\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-07-12 - Deobfuscating DanaBot’s API Hashing.pdf"
    ],
    "report_names": [
        "2020-07-12 - Deobfuscating DanaBot’s API Hashing.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536120,
    "ts_updated_at": 1743041130,
    "ts_creation_date": 1653710465,
    "ts_modification_date": 1653710465,
    "files": {
        "pdf": "https://archive.orkl.eu/4c9399f95c5497df4a9392311350f03a6503ce71.pdf",
        "text": "https://archive.orkl.eu/4c9399f95c5497df4a9392311350f03a6503ce71.txt",
        "img": "https://archive.orkl.eu/4c9399f95c5497df4a9392311350f03a6503ce71.jpg"
    }
}