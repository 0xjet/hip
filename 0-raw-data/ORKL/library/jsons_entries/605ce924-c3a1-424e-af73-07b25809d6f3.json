{
    "id": "605ce924-c3a1-424e-af73-07b25809d6f3",
    "created_at": "2023-01-12T15:10:43.564512Z",
    "updated_at": "2025-03-27T02:09:30.084819Z",
    "deleted_at": null,
    "sha1_hash": "899f637bf8a8e16e71f828abefd81306451a22f8",
    "title": "2022-03-26 - Analysis of a Caddy Wiper Sample Targeting Ukraine",
    "authors": "",
    "file_creation_date": "2022-05-28T16:14:05Z",
    "file_modification_date": "2022-05-28T16:14:05Z",
    "file_size": 466135,
    "plain_text": "# Analysis of a Caddy Wiper Sample Targeting Ukraine\n\n**n0p.me/2022/03/2022-03-26-caddywiper/**\n\n## Analysis of a Caddy Wiper Sample\n\n Introduction\n\n[CaddyWiper was first reported by ESET as below:](https://www.welivesecurity.com/2022/03/15/caddywiper-new-wiper-malware-discovered-ukraine/)\n\nDubbed CaddyWiper by ESET analysts, the malware was first detected at 11.38 a.m.\nlocal time (9.38 a.m. UTC) on Monday. The wiper, which destroys user data and\npartition information from attached drives, was spotted on several dozen systems in a\nlimited number of organizations. It is detected by ESET products as\nWin32/KillDisk.NCX.\n\n[One of my friends pinged me a few days later with a link to a CaddyWiper sample. Since this](https://bazaar.abuse.ch/download/a294620543334a721a2ae8eaaf9680a0786f4b9a216d75b55cfd28f39e9430ea/)\nsample was a particularly small one, I decided to write a blog post going through each\nfunction from scratch and introducing the tools I used to make my life easier. Hopefully, this\ncan serve as a reference to junior malware analysts who want to get started with this craft.\n\nFirst off, I’m a Linux user myself and I use mainly Linux tools to analyse malware. `pev is a`\nset command-line utilities providing a high level analysis of a `PE binary. It consists of the`\nfollowing tools\n\n\n-----\n\n```\n  of\n  s2\n  rv\n  a\n  pe\n  di\n  s\n  pe\n  ha\n  sh\n  pe\n  ld\n  d\n  pe\n  pa\n  ck\n  pe\n  re\n  s\n  pe\n  sc\n  an\n  pe\n  se\n  c\n  pe\n  st\n  r\n  re\n  ad\n  pe\n  rv\n  a2\n  of\n  s\n\n```\nrunning `pehash on the sample offers the following:`\n\n\n-----\n\n```\n filepath:\n a294620543334a721a2ae8eaaf9680a0786f4b9a216d75b55cfd28f39e9430ea.exe\n md5: 42e52b8daf63e6e26c3aa91e7e971492\n sha1: 98b3fb74b3e8b3f9b05a82473551c5a77b576d54\n sha256: a294620543334a721a2ae8eaaf9680a0786f4b9a216d75b55cfd28f39e9430ea\n ssdeep:\n 192:76f0CW5P2Io4evFrDv2ZRJzCn7URRsjVJaZF:76fPWl24evFrT2ZR5Cn7UR0VJo\n imphash: ea8609d4dad999f73ec4b6f8e7b28e55\nreadpe result:\n DOS Header\n  Magic number: 0x5a4d (MZ)\n  Bytes in last page: 144\n  Pages in file: 3\n  Relocations: 0\n\n```\n\n-----\n\n```\n Size of header in paragraphs: 4\n Minimum extra paragraphs: 0\n Maximum extra paragraphs: 65535\n Initial (relative) SS value: 0\n Initial SP value: 0xb8\n Initial IP value: 0\n Initial (relative) CS value: 0\n Address of relocation table: 0x40\n Overlay number: 0\n OEM identifier: 0\n OEM information: 0\n PE header offset: 0xc8\nCOFF/File header\n\n```\n\n-----\n\n```\n Machine: 0x14c IMAGE_FILE_MACHINE_I386\n Number of sections: 3\n Date/time stamp: 1647242376 (Mon, 14 Mar 2022 07:19:36\nUTC)\n Symbol Table offset: 0\n Number of symbols: 0\n Size of optional header: 0xe0\n Characteristics: 0x102\n Characteristics names\n IMAGE_FILE_EXECUTABLE_IMAGE\n IMAGE_FILE_32BIT_MACHINE\nOptional/Image header\n Magic number: 0x10b (PE32)\n Linker major version: 10\n Linker minor version: 0\n\n```\n\n-----\n\n```\nSize of .text section: 0x1c00\nSize of .data section: 0x400\nSize of .bss section: 0\nEntrypoint: 0x1000\nAddress of .text section: 0x1000\nAddress of .data section: 0x3000\nImageBase: 0x400000\nAlignment of sections: 0x1000\nAlignment factor: 0x200\nMajor version of required OS: 5\nMinor version of required OS: 1\nMajor version of image: 0\n\n```\n\n-----\n\n```\nMinor version of image: 0\nMajor version of subsystem: 5\nMinor version of subsystem: 1\nSize of image: 0x5000\nSize of headers: 0x400\nChecksum: 0\nSubsystem required: 0x2 (IMAGE_SUBSYSTEM_WINDOWS_GUI)\nDLL characteristics: 0x8140\nDLL characteristics names\nIMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE\nIMAGE_DLLCHARACTERISTICS_NX_COMPAT\nIMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE\nSize of stack to reserve: 0x100000\n\n```\n\n-----\n\n```\n Size of stack to commit: 0x1000\n Size of heap space to reserve: 0x100000\n Size of heap space to commit: 0x1000\nData directories\n Directory\n IMAGE_DIRECTORY_ENTRY_IMPORT: 0x3008 (40 bytes)\n Directory\n IMAGE_DIRECTORY_ENTRY_BASERELOC: 0x4000 (12 bytes)\n Directory\n IMAGE_DIRECTORY_ENTRY_IAT: 0x3000 (8 bytes)\nImported functions\n Library\n Name: NETAPI32.dll\n Functions\n Function\n Hint: 39\n Name: DsRoleGetPrimaryDomainInformation\nExported functions\nSections\n Section\n Name: .text\n\n```\n\n-----\n\n```\nVirtual Size: 0x1b4a (6986 bytes)\nVirtual Address: 0x1000\nSize Of Raw Data: 0x1c00 (7168 bytes)\nPointer To Raw Data: 0x400\nNumber Of Relocations: 0\nCharacteristics: 0x60000020\nCharacteristic Names\nIMAGE_SCN_CNT_CODE\nIMAGE_SCN_MEM_EXECUTE\nIMAGE_SCN_MEM_READ\nSection\nName: .rdata\nVirtual Size: 0x6a (106 bytes)\nVirtual Address: 0x3000\n\n```\n\n-----\n\n```\nSize Of Raw Data: 0x200 (512 bytes)\nPointer To Raw Data: 0x2000\nNumber Of Relocations: 0\nCharacteristics: 0x40000040\nCharacteristic Names\nIMAGE_SCN_CNT_INITIALIZED_DATA\nIMAGE_SCN_MEM_READ\nSection\nName: .reloc\nVirtual Size: 0x18 (24 bytes)\nVirtual Address: 0x4000\nSize Of Raw Data: 0x200 (512 bytes)\nPointer To Raw Data: 0x2200\nNumber Of Relocations: 0\n\n```\n\n-----\n\n```\n  Characteristics: 0x42000040\n  Characteristic Names\n  IMAGE_SCN_CNT_INITIALIZED_DATA\n  IMAGE_SCN_MEM_DISCARDABLE\n  IMAGE_SCN_MEM_READ\n\n```\nIf you’re new to analyzing a PE, I highly recommend looking at the official Microsoft\ndocuments for PE Format. Some notes from the link:\n\nAt location 0x3c, the stub has the file offset to the PE signature. This information\nenables Windows to properly execute the image file, even though it has an MS-DOS\nstub. This file offset is placed at location 0x3c during linking. After the MS-DOS stub, at\nthe file offset specified at offset 0x3c, is a 4-byte signature that identifies the file as a\nPE format image file. This signature is “PE\\0\\0” (the letters “P” and “E” followed by two\nnull bytes).\n\n## Main function Analysis\n\nthe main function starts at `00401000 and it looks like it doesn’t return a status code. in` `c`\nterms, it means the `main function is written like so:` `void main(...) .`\n\nIn the main function, we can see a call to the external function\n```\nDsRoleGetPrimaryDomainInformation at 0040113a :\n\n```\n\n-----\n\naccording to Microsoft documentation, The `DsRoleGetPrimaryDomainInformation`\nfunction retrieves state data for the computer. This data includes the state of the directory\nservice installation and domain data.\n\nIf we take a closer look at the function call, we can see that the function has been called with\n3 parameters: `DsRoleGetPrimaryDomainInformation(0,1,&empty_int_pointer); . the`\n0 refers to the `lpServer parameter, meaning the function will be called on the local`\ncomputer (refer to the link above for more info on that). The `1 is the` `InfoLevel`\n\n\n-----\n\nparameter, which specifies the level of output needed, as well as the type of output being\npushed to our `empty_int_pointer . referring to` [Microsoft Documentation, we can see](https://docs.microsoft.com/en-us/windows/win32/api/dsrole/ne-dsrole-dsrole_primary_domain_info_level) `1`\nrefers to the first item in the C++ enum, which is `DsRolePrimaryDomainInfoBasic :`\n```\n  typedef enum\n  _DSROLE_PRIMARY_DOMAIN_INFO_L\n  EVEL\n  {\n  DsRolePrimaryDomainInfoBasic\n  = 1,\n  DsRoleUpgradeStatus,\n  DsRoleOperationState\n  }\n  DSROLE_PRIMARY_DOMAIN_INFO_LE\n  VEL\n  ;\n\n```\nIf we follow the docs, it’ll mention our output type as\n\n`DSROLE_PRIMARY_DOMAIN_INFO_BASIC, and refers to` [this page. Looks like our return value](https://docs.microsoft.com/en-us/windows/win32/api/dsrole/ns-dsrole-dsrole_primary_domain_info_basic)\nwill be in this struct:\n\n\n-----\n\n```\n  typedef struct\n  _DSROLE_PRIMARY_DOMAIN_INFO_\n  BASIC\n  {\n  DSROLE_MACHINE_ROLE\n  MachineRole;\n  ULONG Flags;\n  LPWSTR DomainNameFlat;\n  LPWSTR DomainNameDns;\n  LPWSTR DomainForestName;\n  GUID DomainGuid;\n  }\n  DSROLE_PRIMARY_DOMAIN_INFO_B\n  ASIC\n , *\n  PDSROLE_PRIMARY_DOMAIN_INFO_\n  BASIC\n  ;\n\n```\nclearly the attack is interested in `MachineRole, and compares it with value` `5 . Let’s dig`\ndeeper to see what `5 means. If we go to` [this doc, we’ll see the following](https://docs.microsoft.com/en-us/windows/win32/api/dsrole/ne-dsrole-dsrole_machine_role) `enum :`\n\n\n-----\n\n```\n  typedef enum\n  _DSROLE_MACHINE_ROLE {\n  DsRole_RoleStandaloneWorkstati\n  on\n ,\n  DsRole_RoleMemberWorkstation,\n  DsRole_RoleStandaloneServer,\n  DsRole_RoleMemberServer,\n  DsRole_RoleBackupDomainControl\n  ler\n ,\n  DsRole_RolePrimaryDomainContro\n  ller\n  } DSROLE_MACHINE_ROLE;\n5 is the primary Domain Controller. Looking at the code, you can see the attacker does not\n\n```\nintend to attack the primary DC, and will skip them.\n\nAfter getting all the info, I started to rename the functions and add a bit of comment, as well\nas converting types in Ghidra to make sure it’s readable:\n\n\n-----\n\nNow we can see there’s a `wiper function, which runs on` `C:\\\\Users as well as` `D:\\\\ for`\n24 chars ( E:\\\\, F:\\\\, ... ), which means basically all drive letters.\n\nlet’s go take a look at the `wiper function. That’s where the attacker’s malicious code is`\nlocated.\n\n## The wiper function\n\nThe function itself is a `void one. Meaning the attacker didn’t really care if the wiping is`\nsuccessful or not. Reading a bit of the function itself, the first bit of interesting information is\nseen at line ~180. There seems to be another function, that gets called with both `* and`\n```\n\\\\ values.\n\n```\n\n-----\n\n-----\n\n```\n  FUN_00402a80((int)local_ccc,param_1,&local_e4\n  4);\n  FUN_00402a80((int)local_89c,local_ccc,&local_\n  e20);\n\n```\nAfter digging around the `wipe function, you can see` `kernel32.dll as a stack string with`\nthese functions being called from it (in order):\n```\n  FindFirst\n  FileA\n  FindNextF\n  ileA\n  CreateFil\n  eA\n  GetFileSi\n  ze\n  LocalAllo\n  c\n  SetFilePo\n  inter\n  WriteFile\n  LocalFree\n  CloseHand\n  le\n  FindClose\n\n```\n[All above functions are thoroughly documented in Microsoft’s official Win32 API Docs](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/)\n\nEssentially, the wiper is looking for all the files under `C:\\Users and` `D: through` `Z: and`\ntries to enumerate the first file within those directories (with `FindFirstFileA ), then`\nenumerates through the folders with `FindNextFileA, opens the file, scrambles the header`\n\n\n-----\n\nof each file, and does it across all folder recursively. Here s the main `wiper function with`\nfunction names and syscalls somewhat renamed to a more readable format\n\n### Subfunction FUN_00402a80\n\nBefore we rename this function to something human-readable, we should know what it does.\nHere’s the pseudo-code of the function itself:\n\n\n-----\n\nThe function appears to concat two strings together with a couple of `while loops and put`\nthem in the first parameter’s pointer. in `python terms, it basically means` `param_1 =`\n```\nparam_2 + param_3 . From now on, I’ll refer to FUN_00402a80 as concat\n\n### subfunction FUN_00401530\n\n```\nAfter concatenating the paths with `* and` `\\\\,` `FUN_00401530 gets called with two`\nparameters: `findFirstFileA and` `kernel32.dll, as specified in lines directly after`\ncalling the two concat functions (line 190 to 200 inside the `wipe function in Ghidra).`\n\n\n-----\n\nEven though the logic of the function seems complicated, from what it gets and produces as\nan output, it’s safe to assume the function is a Win32 API client. The DLL filename as well as\nthe specific functionality is pushed to the function and the result is an integer that\ncorresponds to the API response code. From now on, I’ll refer to `FUN_00401530 as`\n\n```\nsyscall_wrapper\n\n```\n\n## Other Interesting Functions\n\n```\nFUN_00401a10\n\n```\n\n-----\n\nUsing the same trick we did before, it s easy to see this function using the same\n```\nsyscall_wrapper to invoke multiple functions from advapi32.dll :\n  SetEntriesInAclA\n  AllocateAndInitiali\n  zeSid\n  SetNamedSecurityInf\n  oA\n  GetCurrentProcess\n  OpenProcessToken\n  SeTakeOwnershipPriv\n  ilege\n  FreeSid\n  LocalFree\n  CloseHandle\n\n```\nThis function looks to be looking into each particular file’s ownership and tries to get around\nsome ACLs and “access denied” errors that it comes across. I would describe it as a basic\nway to try to make a file writable enough so it can destroy it. Although I didn’t read each\nindividual syscall to back that claim. `FUN_00401750 is the main carrier of this operation. In`\n```\nFUN_00401750, we can see the following functions:\n  LookupPrivilegeV\n  alueA\n  AdjustTokenPrivi\n  leges\n  GetLastError\nFUN_00401750 simply tries to see if the malware has enough permission to change\n\n```\npermissions on a file. I’ll rename it to `priv_check .`\n\nAs a result, based on my guess, `FUN_00401a10 is renamed to` `priv_set`\n\n## Putting it all together\n\nThis is a small Malware sample, and it’s effective and fast. In a nutshell, this is what the\nattack vector had in mind\n\nChecks if the Computer is a primary domain controller or not. If not, it leaves it behind\nand doesn’t wipe it.\nIt identifies C:\\Users and D: through Z: as primary attack targets\n\n\n-----\n\nRecursively:\n\nFinds the first file in the folder\nTries to see the permission it has to write to the file\nTries elevating privileges to gain permission to write to the file\nOpens the file in write mode\nrewrites the file header with gibberish\nClose the file\n\nInterestingly, If you run the binary through something like the `strings command, you’ll`\nonly see a few strings, like so\n```\n  strings\n  a294620543334a721a2ae8eaaf9680a0786f4b9a216d75b55cfd28f39e9430ea.exe\n  !This program cannot be run in DOS mode.\n  Rich%\n  .text\n  `.rdata\n  @.reloc\n  DsRoleGetPrimaryDomainInformation\n  NETAPI32.dll\n\n```\nThis is because the attacker is making use of `stack strings .` [This link has a good](https://rioasmara.com/2020/10/20/evade-strings-detection-with-stack-based/)\nexplanation of what are stack strings and how are they used to avoid detection.\n\n## Detection\n\nThe easiest detection for this particular sample could be a hash value. But since this\nmalware is small, hashes, even `ssdeep are not a very good idea. Let’s try to build a YARA`\nrule that defines what we learned from the malware.\n```\n  rule caddywiper {\n  meta:\n  author = \"Ali Mosajjal\"\n  email = \"\"\n  license = \"Apache 2.0\"\n\n```\n\n-----\n\n```\n description \n\"Caddy Wiper Stack String Detection\"\n strings:\n $s1 = /F.{6}i.{6}n.{6}d.{6}F.{6}i.{6}r.{6}s.{6}t.{6}F.{6}i.{6}l.{6}e.{6}A/ //\nFindFirstFileA\n $s2 = /F.{6}i.{6}n.{6}d.{6}N.{6}e.{6}x.{6}t.{6}F.{6}i.{6}l.{6}e.{6}A/ //\nFindNextFileA\n $s3 = /C.{6}r.{6}e.{6}a.{6}t.{6}e.{6}F.{6}i.{6}l.{6}e.{6}A/ // CreateFileA\n $s4 = /G.{6}e.{6}t.{6}F.{6}i.{6}l.{6}e.{6}S.{6}i.{6}z.{6}e/ // GetFileSize\n $s5 = /L.{6}o.{6}c.{6}a.{6}l.{6}A.{6}l.{6}l.{6}o.{6}c/ // LocalAlloc\n $s6 = /S.{6}e.{6}t.{6}F.{6}i.{6}l.{6}e.{6}P.{6}o.{6}i.{6}n.{6}t.{6}e.{6}r/ //\nSetFilePointer\n $s7 = /W.{3}r.{3}i.{3}t.{3}e.{3}F.{3}i.{3}l.{3}e/ // WriteFile\n $s8 = /L.{6}o.{6}c.{6}a.{6}l.{6}F.{6}r.{6}e.{6}e/ // LocalFree\n $s9 = /C.{6}l.{6}o.{6}s.{6}e.{6}H.{6}a.{6}n.{6}d.{6}l.{6}e/ // CloseHandle\n $s10 = /F.{3}i.{3}n.{3}d.{3}C.{3}l.{3}o.{3}s.{3}e/ // FindClose\n\n```\n\n-----\n\n```\n  condition:\n  all of ($s*) and filesize < 100KB\n  }\n\n```\nAs we saw, since the attacker was clever enough to use Stack String, our YARA rule is going\nto be slow and regex-y but it still works. Interestingly, for `WriteFile and` `FindClose I had`\nto adjust my regex to factor in the slightly smaller `MOV assembly code. I’ve also put a file`\nsize cap on the sample to ignore potentially different variants of this malware.\n\nAs an exercise, you can create similar detection for the `dll files, which are a bit trickier`\nconsidering they’re both `wide strings and Stack Strings.`\n\nHope you enjoyed this brief analysis. I’ll put the Ghidra zipped file alongside the scripts,\ncomments etc in a Github Repo if anyone is interested. Let me know what Malware should I\ndissect next :)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-26 - Analysis of a Caddy Wiper Sample Targeting Ukraine.pdf"
    ],
    "report_names": [
        "2022-03-26 - Analysis of a Caddy Wiper Sample Targeting Ukraine.pdf"
    ],
    "threat_actors": [
        {
            "id": "6b4a82e8-21f1-4bc7-84cf-e27334998b48",
            "created_at": "2022-10-25T16:07:23.84296Z",
            "updated_at": "2025-03-27T02:02:09.997164Z",
            "deleted_at": null,
            "main_name": "DEV-0270",
            "aliases": [
                "DEV-0270",
                "DireFate",
                "Lord Nemesis",
                "Nemesis Kitten",
                "Yellow Dev 23",
                "Yellow Dev 24"
            ],
            "source_name": "ETDA:DEV-0270",
            "tools": [
                "Impacket",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "WmiExec"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d8af157e-741b-4933-bb4a-b78490951d97",
            "created_at": "2023-01-06T13:46:38.748929Z",
            "updated_at": "2025-03-27T02:00:02.908256Z",
            "deleted_at": null,
            "main_name": "APT35",
            "aliases": [
                "Newscaster Team",
                "Magic Hound",
                "G0059",
                "Phosphorus",
                "Mint Sandstorm",
                "TunnelVision",
                "COBALT MIRAGE"
            ],
            "source_name": "MISPGALAXY:APT35",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "e3676dfe-3d40-4b3a-bfbd-4fc1f8c896f4",
            "created_at": "2022-10-25T15:50:23.808974Z",
            "updated_at": "2025-03-27T02:00:55.550912Z",
            "deleted_at": null,
            "main_name": "Magic Hound",
            "aliases": [
                "Magic Hound",
                "TA453",
                "COBALT ILLUSION",
                "Charming Kitten",
                "ITG18",
                "Phosphorus",
                "APT35",
                "Mint Sandstorm"
            ],
            "source_name": "MITRE:Magic Hound",
            "tools": [
                "Impacket",
                "CharmPower",
                "FRP",
                "Mimikatz",
                "Systeminfo",
                "ipconfig",
                "netsh",
                "PowerLess",
                "Pupy",
                "DownPaper",
                "PsExec",
                "Havij",
                "sqlmap"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "1699fb41-b83f-42ff-a6ec-984ae4a1031f",
            "created_at": "2022-10-25T16:07:23.83826Z",
            "updated_at": "2025-03-27T02:02:09.995863Z",
            "deleted_at": null,
            "main_name": "Magic Hound",
            "aliases": [
                "APT 35",
                "Ballistic Bobcat",
                "Charming Kitten",
                "CharmingCypress",
                "Cobalt Illusion",
                "Cobalt Mirage",
                "Educated Manticore",
                "Magic Hound",
                "Mint Sandstorm",
                "Operation BadBlood",
                "Operation Sponsoring Access",
                "Operation SpoofedScholars",
                "Operation Thamar Reservoir",
                "Phosphorus",
                "TA453",
                "TEMP.Beanie",
                "Tarh Andishan",
                "Timberworm",
                "TunnelVision",
                "UNC788",
                "Yellow Garuda"
            ],
            "source_name": "ETDA:Magic Hound",
            "tools": [
                "7-Zip",
                "AnvilEcho",
                "BASICSTAR",
                "CORRUPT KITTEN",
                "CWoolger",
                "CharmPower",
                "ChromeHistoryView",
                "CommandCam",
                "DistTrack",
                "DownPaper",
                "FRP",
                "Fast Reverse Proxy",
                "FireMalv",
                "Ghambar",
                "GoProxy",
                "GorjolEcho",
                "HYPERSCRAPE",
                "Havij",
                "MPK",
                "MPKBot",
                "Matryoshka",
                "Matryoshka RAT",
                "MediaPl",
                "Mimikatz",
                "MischiefTut",
                "NETWoolger",
                "NOKNOK",
                "PINEFLOWER",
                "POWERSTAR",
                "PowerLess Backdoor",
                "PsList",
                "Pupy",
                "PupyRAT",
                "SNAILPROXY",
                "Shamoon",
                "TDTESS",
                "WinRAR",
                "WoolenLogger",
                "Woolger",
                "pupy",
                "sqlmap"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536243,
    "ts_updated_at": 1743041370,
    "ts_creation_date": 1653754445,
    "ts_modification_date": 1653754445,
    "files": {
        "pdf": "https://archive.orkl.eu/899f637bf8a8e16e71f828abefd81306451a22f8.pdf",
        "text": "https://archive.orkl.eu/899f637bf8a8e16e71f828abefd81306451a22f8.txt",
        "img": "https://archive.orkl.eu/899f637bf8a8e16e71f828abefd81306451a22f8.jpg"
    }
}