{
    "id": "020f3860-52fd-4a76-9ce0-d84a9fee37da",
    "created_at": "2023-01-12T15:08:21.899964Z",
    "updated_at": "2025-03-27T02:16:47.042009Z",
    "deleted_at": null,
    "sha1_hash": "9955ce789bfba2984d59232dc13186351bbe6523",
    "title": "2020-05-24 - Reverse Engineering the Mustang Panda PlugX Loader",
    "authors": "",
    "file_creation_date": "2022-05-28T17:07:57Z",
    "file_modification_date": "2022-05-28T17:07:57Z",
    "file_size": 1203736,
    "plain_text": "# oR10n Labs\n\n**[or10nlabs.tech/reverse-engineering-the-mustang-panda-plugx-loader](https://or10nlabs.tech/reverse-engineering-the-mustang-panda-plugx-loader)**\n\nBy oR10n\n\n2020-05-24\n[HomeReverse EngineeringReverse Engineering the Mustang Panda PlugX Loader](https://or10nlabs.tech/)\n\n## Reverse Engineering the Mustang Panda PlugX Loader\n\nHello everyone! In this series, we will be diving into the inner workings of a new-ish variant of\nPlugX malware gaining traction around the Asia Pacific region for the past few months.\n\n## Introduction\n\nPlugX is a fully featured remote access trojan (RAT) with various capabilities such as file\nupload/download, file operations, registry operations, process operations, keystroke logging,\ncapturing screenshots or videos, and initiating remote shell on compromised systems.\n\n[Based on the analysis reports released by two security companies – Anomali and](https://www.anomali.com/blog/china-based-apt-mustang-panda-targets-minority-groups-public-and-private-sector-organizations) [Avira, this](https://insights.oem.avira.com/new-wave-of-plugx-targets-hong-kong/)\nnew variant is primarily used by a suspected China-based APT group being referred to as\n\"Mustang Panda\", to target organizations primarily located in the Asia Pacific region.\n\nFor this post, we will reverse engineer the loader component of the new variant to\nunderstand how it loads, decrypts, and executes the encrypted payload in memory. Then, we\nwill create a quick-and-dirty python script to automate the decryption process so we won’t\nneed to run the loader every time we want to do a deeper analysis on a payload or perform\nbulk analysis. Lastly, I will show you one of the ways to hunt for new encrypted payloads\nuploaded in VirusTotal.\n\n\n-----\n\nBut before we get our hands dirty, let us first take a look on how PlugX is initially delivered\nand executed on a system.\n\n## PlugX Delivery and Execution\n\nAs you might have known from previous analysis reports, PlugX is primarily made up of three\nmain components:\n\n1. A legitimate executable used for loading and executing a malicious DLL\n2. A malicious DLL used for decrypting, loading, and executing an encrypted payload\n3. An encrypted payload containing the main RAT functionalities\n\nOn the earlier variants of PlugX, these three components are typically delivered via phishing\nemails containing an attached self-extracting RAR (SFX) archive, acting as a dropper for\nthese components. However for this variant, this RAR archive was replaced by a malicious\nLNK file as seen on the Anomali analysis report.\n\n**[Note: Logrhythm released an article on April 2018, detailing the evolution and variants of](https://logrhythm.com/blog/deep-dive-into-plugx-malware/)**\nPlugX over the years.\n\nA general overview of the delivery and execution flow looks like this:\n\n## Reverse Engineering the Loader\n\nFor our analysis, we will take a deeper look at a sample discovered by Avira in the wild.\nThese are the details of the PlugX components for our analysis:\n\n**Component** **Filename** **MD5**\n\n\n-----\n\n**Component** **Filename** **MD5**\n\nLegit exe AdobeInstall.exe c70d8dce46b4551133ecc58aed84bf0e\n\nLoader hex.dll eafaba7898e149895b36ee488e3d579c\n\nPayload adobeupdate.dat 58bdf783da4c627d2f13612a09a9b5a8\n\nLet’s dive in!\n\nAs a first step in reverse engineering, it’s a good practice to perform static analysis first to\ngain a general overview of the sample that can serve as a guide through out the process.\n\nChecking the sample on CFF explorer shows us that it has only 1 Export function named\n**CEFProcessForHandlerEx.**\n\nIt also has a very few Import functions which suggests that this sample dynamically loads\nWin32 API functions at runtime via GetModuleHandleA and GetProcAddress.\n\n\n-----\n\nAdditionally, we can also run a string utility to check out the strings on the sample. I normally\nuse FIreEye’s [FLOSS tool which is a string utility on steroids. Aside from displaying static](https://github.com/fireeye/flare-floss)\nASCII/UNICODE strings, it can also display stack strings and automatically decode strings\nthat are encoded with simple and well known algorithms.\n\nHere are some of the interesting strings FLOSS found on the sample:\n```\nLocalFree\nLocalAlloc\nGetProcAddress\nGetModuleHandleA\nVirtualProtect\nCloseHandle\nCreateFileA\nReadFile\n\\adobeupdate.dat\nGetModuleFileNameA\nkernel32\nGetFileSize\nlstrcatA\nstrlen\n\n```\nBased from these strings, we can come up with a hypothesis on the general flow and\nfunctionality of the sample:\n\nDynamically loads Win32 API functions from kernel32 at runtime via\n**GetModuleHandleA and GetProcAddress**\nObtains the full path of the running process via GetModuleFileNameA\nPerforms string operations via strlen and lstrcatA\nAllocates a memory buffer via LocalAlloc\nReads a file named adobeupdate.dat via CreateFileA, GetFileSize, ReadFile, and\n**CloseHandle**\nMarks an allocated memory buffer as executable using VirtualProtect\n\nNext, we can load the sample on a disassembler like IDA and a debugger like x32dbg. For\ndebugging, you can open AdobeInstall.exe and set a DLL breakpoint on hex.dll in order to\ndebug it.\n\n**Note: AdobeInstall.exe loads hex.dll from the same directory and PlugX have taken**\nadvantage of this to load the malicious DLL as a form of anti-detection/anti-analysis\ntechnique.\n\n\n-----\n\nSince there’s only one export function in the DLL, it is fairly safe to assume that the sample\nonly has one purpose – to load, decrypt, and execute the encrypted payload.\n\nWe can easily follow the export function in IDA and dertermine that the main function of the\nDLL lies in sub_10001354.\n\nThe first few lines of disassembly will show you \"\\adobeupdate.dat\", \"kernel32\", and\n\"GetModuleFileNameA\" being initiated as stack strings. Usage of stack strings is a common\nanti-analysis and anti-detection technique employed by malware. This is typically used to\nprevent certain strings from showing up on basic string utilities.\n\n\n-----\n\nAfter initiating the stack strings, the address of GetModuleFileNameA is dynamically\nresolved via GetModuleHandleA and GetProcAddress. Upon resolving its address in\n**kernel32, GetModuleFileNameA is called.**\n\nRunning through it in x32dbg shows that GetModuleFileNameA returned the full path of the\nbinary for the running process – which is \"C:\\Users\\user\\Desktop\\AdobeInstall.exe\".\n\nNext, the full path and the character \"\\\" is passed as a parameter in a function\n**sub_10001000. This function splits the full path using \"\\\" as delimiter and returns the**\naddress of the filename – which is \"\\AdobeInstall.exe\".\n\nA few lines after, the first character of \"\\AdobeInstall.exe\" is replaced by 0x00, thereby\nsplitting the full path into two different strings in memory \"C:\\Users\\user\\Desktop\" and\n\"AdobeInstall.exe\".\n\nNext, the address of lstrcatA is also resolved dynamically using the same\n**GetModuleHandleA and GetProcAddress technique mentioned earlier. lstrcatA is used to**\nform the full path of the encrypted payload by concatenating \"C:\\Users\\user\\Desktop\" and\n\"\\adobeupdate.dat\".\n\n\n-----\n\nNow that the full path of the encrypted payload is formed, a call to a function sub_10001084\nis made in order to read the file contents of the encrypted payload, get the file size, and load\nthe contents into a buffer in memory.\n\nThe following arguments are pushed into the stack before the function call is made:\n\nLooking closely at the disassembly of the function, we can see that same as before, the\naddress of CreateFileA, GetFileSize, ReadFile, and CloseHandle are resolved dynamically\nusing the same GetModuleHandleA + GetProcAddress technique.\n\nAfter resolving the addresses of the functions, a call to each one is made in the following\norder:\n\n**CreateFileA to open the encrypted payload**\n**GetFileSize to obtain the file size of the encrypted payload**\n**LocalAlloc to allocate a buffer in memory**\n**ReadFile to read the contents of the encrypted payload and place it in the buffer**\n\n\n-----\n\nAfter making these function calls, the address of the buffer containing the contents of the\nencrypted payload and the file size are stored in the arguments pushed to the stack earlier.\nThen finally, a call to CloseHandle is made and EIP returns to the main function.\n\n\n-----\n\nJust a few lines of disassembly after, we can see some instructions assigning the address of\nthe buffer to a new variable and that variable being passed as a parameter to strlen.\n\nThese instructions essentially obtain the encryption key from the encrypted payload and\ndetermine its length via strlen. As you might remember, a string is an array of characters\nterminated with a NULL byte. So passing the address of the encrypted buffer to strlen will\ngive us the length of the first string it sees.\n\nLater on, we will see how this string is used as a key for the decryption routine.\n\nA few lines after, we can see a sub operation being performed on the file size using the\ndetermined key size to compute the file size of the payload without the key and the NULL\nbyte.\n\nMoving down further on the main function, we can immediately see that there is a loop\nbefore it proceeds to the final set of instructions.\n\nWhat this loop does is basically read the remaining bytes after the encryption key from the\noriginal buffer and copy it to a new buffer.\n\n\n-----\n\nRight after the loop, the key size, key, file size, and new buffer is pushed to the stack and a\ncall to a function sub_100018D0 is made. This is the function that contains the algorithm to\ndecrypt the encrypted payload.\n\nLooking closely at the disassembly of the function, we can immediately determine that the\nalgorithm performs XOR using a multi-byte key.\n\n\n-----\n\nRunning this on a debugger, shows that the decrypted payload is a PE file.\n\nGoing back to the main function after the call to the decryption function, we can see the\naddress of VirtualProtect being resolved using the same GetModuleHandleA +\n**GetProcAddress technique.**\n\nUpon resolving the address, we can see a call to VirtualProtect to change the access\nprotection of the buffer containing the decrypted payload to 0x40\n(PAGE EXECUTE READWRITE)\n\n\n-----\n\nLastly, we can see a call to the address of the buffer to execute the decrypted payload.\n\n..and there you have it folks, PlugX is now loaded to memory and executed on the system.\n\n## Automating the payload decryption\n\nTo make our lives easier, I created this quick-and-dirty python script to automatically decrypt\npayloads for this variant:\n\n## Hunting for encrypted payloads in VirusTotal\n\nI’m also sharing this VT hunting YARA rule that I came up with to hunt for encrypted\npayloads associated with this variant. The rule is based on the filenames mentioned on the\nAvira report.\n\nYou may get some false positives on this one, but together with the python script above, this\ncan be an effective approach to hunt for encrypted payloads that may otherwise go\nunnoticed on VT.\n\nThat’s it guys! I really hope you learned something new today and as always, thank you for\nreading my blog!\n\n**PS: Stay tuned for the next post on this series where we’ll reverse engineer some interesting**\nparts of the PlugX payload itself. Cheers!\n\n\n-----\n\n[Tags:MustangPanda,](https://or10nlabs.tech/tag/mustangpanda/) [PlugX,](https://or10nlabs.tech/tag/plugx/) [Reverse Engineering](https://or10nlabs.tech/tag/reverse-engineering/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-05-24 - Reverse Engineering the Mustang Panda PlugX Loader.pdf"
    ],
    "report_names": [
        "2020-05-24 - Reverse Engineering the Mustang Panda PlugX Loader.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "1691c25f-1aa4-4168-8ce2-7aa8f23246e7",
            "created_at": "2024-06-04T02:03:07.724221Z",
            "updated_at": "2025-03-27T02:05:17.284601Z",
            "deleted_at": null,
            "main_name": "BRONZE PRESIDENT",
            "aliases": [
                "Mustang Panda ",
                "Red Lich ",
                "Temp.Hex ",
                "HoneyMyte "
            ],
            "source_name": "Secureworks:BRONZE PRESIDENT",
            "tools": [
                " Cobalt Strike",
                " ORat",
                " PlugX",
                " RCSession",
                "China Chopper"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "b69037ec-2605-4de4-bb32-a20d780a8406",
            "created_at": "2023-01-06T13:46:38.790766Z",
            "updated_at": "2025-03-27T02:00:02.919758Z",
            "deleted_at": null,
            "main_name": "MUSTANG PANDA",
            "aliases": [
                "TEMP.HEX",
                "TA416",
                "TANTALUM",
                "Twill Typhoon",
                "Earth Preta",
                "Stately Taurus",
                "LuminousMoth",
                "Polaris",
                "BRONZE PRESIDENT",
                "HoneyMyte",
                "Red Lich"
            ],
            "source_name": "MISPGALAXY:MUSTANG PANDA",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "9baa7519-772a-4862-b412-6f0463691b89",
            "created_at": "2022-10-25T15:50:23.354429Z",
            "updated_at": "2025-03-27T02:00:55.45162Z",
            "deleted_at": null,
            "main_name": "Mustang Panda",
            "aliases": [
                "Mustang Panda",
                "TA416",
                "RedDelta",
                "BRONZE PRESIDENT"
            ],
            "source_name": "MITRE:Mustang Panda",
            "tools": [
                "Cobalt Strike",
                "RCSession",
                "NBTscan",
                "PoisonIvy",
                "PlugX"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "2ee03999-5432-4a65-a850-c543b4fefc3d",
            "created_at": "2022-10-25T16:07:23.882813Z",
            "updated_at": "2025-03-27T02:02:10.0116Z",
            "deleted_at": null,
            "main_name": "Mustang Panda",
            "aliases": [
                "Bronze President",
                "Camaro Dragon",
                "Earth Preta",
                "HoneyMyte",
                "Mustang Panda",
                "Operation SMUGX",
                "Operation SmugX",
                "PKPLUG",
                "Red Lich",
                "Stately Taurus",
                "TEMP.Hex"
            ],
            "source_name": "ETDA:Mustang Panda",
            "tools": [
                "9002 RAT",
                "AdFind",
                "Agent.dhwf",
                "Agentemis",
                "CHINACHOPPER",
                "China Chopper",
                "Chymine",
                "ClaimLoader",
                "Cobalt Strike",
                "CobaltStrike",
                "DCSync",
                "DOPLUGS",
                "Darkmoon",
                "Destroy RAT",
                "DestroyRAT",
                "Farseer",
                "Gen:Trojan.Heur.PT",
                "HOMEUNIX",
                "Hdump",
                "HenBox",
                "HidraQ",
                "Hodur",
                "Homux",
                "HopperTick",
                "Hydraq",
                "Impacket",
                "Kaba",
                "Korplug",
                "LadonGo",
                "MQsTTang",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "NBTscan",
                "NetSess",
                "Netview",
                "Orat",
                "POISONPLUG.SHADOW",
                "PUBLOAD",
                "PVE Find AD Users",
                "PlugX",
                "Poison Ivy",
                "PowerView",
                "QMAGENT",
                "RCSession",
                "RedDelta",
                "Roarur",
                "SPIVY",
                "ShadowPad Winnti",
                "SinoChopper",
                "Sogu",
                "TIGERPLUG",
                "TONEINS",
                "TONESHELL",
                "TVT",
                "TeamViewer",
                "Thoper",
                "TinyNote",
                "WispRider",
                "WmiExec",
                "XShellGhost",
                "Xamtrav",
                "Zupdax",
                "cobeacon",
                "nbtscan",
                "nmap",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536101,
    "ts_updated_at": 1743041807,
    "ts_creation_date": 1653757677,
    "ts_modification_date": 1653757677,
    "files": {
        "pdf": "https://archive.orkl.eu/9955ce789bfba2984d59232dc13186351bbe6523.pdf",
        "text": "https://archive.orkl.eu/9955ce789bfba2984d59232dc13186351bbe6523.txt",
        "img": "https://archive.orkl.eu/9955ce789bfba2984d59232dc13186351bbe6523.jpg"
    }
}