{
    "id": "87ad8218-80d4-4cfb-acaf-34ab479b200b",
    "created_at": "2023-01-12T15:03:48.997823Z",
    "updated_at": "2025-03-27T02:05:44.126219Z",
    "deleted_at": null,
    "sha1_hash": "704da83cc02b6324fd6b2d922e9e80fdff3343ca",
    "title": "2021-04-09 - Emotet Command and Control Case Study",
    "authors": "",
    "file_creation_date": "2022-05-28T03:33:57Z",
    "file_modification_date": "2022-05-28T03:33:57Z",
    "file_size": 1599791,
    "plain_text": "# Emotet Command and Control Case Study\n\n**[unit42.paloaltonetworks.com/emotet-command-and-control/](https://unit42.paloaltonetworks.com/emotet-command-and-control/)**\n\nChris Navarrete, Yanhui Jia April 9, 2021\n\nBy [Chris Navarrete and](https://unit42.paloaltonetworks.com/author/chris-navarrete/) [Yanhui Jia](https://unit42.paloaltonetworks.com/author/yanhui-jia/)\n\nApril 9, 2021 at 12:00 PM\n\n[Category: Malware,](https://unit42.paloaltonetworks.com/category/malware-2/) [Unit 42](https://unit42.paloaltonetworks.com/category/unit-42/)\n\nTags: [C2,](https://unit42.paloaltonetworks.com/tag/c2/) [command and control,](https://unit42.paloaltonetworks.com/tag/command-and-control/) [Cybercrime,](https://unit42.paloaltonetworks.com/tag/cybercrime/) [Emotet,](https://unit42.paloaltonetworks.com/tag/emotet/) [exploit](https://unit42.paloaltonetworks.com/tag/exploit/)\n\nThis post is also available in: 日本語 [(Japanese)](https://unit42.paloaltonetworks.jp/emotet-command-and-control/)\n\n## Executive Summary\n\nOn March 8, 2021, Unit 42 published “Attack Chain Overview: Emotet in December 2020 and\nJanuary 2021.” Based on that analysis, the updated version of Emotet talks to different\ncommand and control (C2) servers for data exfiltration or to implement further attacks. We\nobserved attackers taking advantage of a sophisticated evasion technique and encryption\nalgorithm to communicate with C2 servers in order to probe the victim's network environment\nand processes, allowing attackers to steal a user’s sensitive information or drop a new\npayload.\n\n\n-----\n\nIn this blog, we provide a step-by-step technical analysis, beginning from where the main\nlogic starts, covering the encryption mechanisms and ending when the C2 data is exfiltrated\nthrough HTTP protocol to the C2 server.\n\n[Palo Alto Networks Next-Generation Firewall customers are protected from Emotet with](https://www.paloaltonetworks.com/network-security/next-generation-firewall)\n[Threat Prevention and](https://www.paloaltonetworks.com/products/secure-the-network/subscriptions/threat-prevention) [WildFire security subscriptions. Customers are also protected with](https://www.paloaltonetworks.com/products/secure-the-network/wildfire)\n[Cortex XDR.](https://www.paloaltonetworks.com/cortex/cortex-xdr)\n\n## Technical Analysis\n\nThis analysis will use custom function names (i.e., collect_process_data) that replace the\nregular IDA Pro's function format (i.e., sub_*) and will assume a 32-bit (x86) DLL executable\nwith an image base address of 0x2E1000. The user can refer to the following image that\ncontains function offsets, names and custom names for easy reference.\n\n**NOTE: Sub-functions used are not listed, since these can be easily located from the**\npresented function offsets.\n\nFigure 1. IDA’s functions reference information.\nThe present analysis begins from the entry point function c2_logic_ep (sub_2E2C63).\n\n**Encryption API Functions**\n\nThis malware uses two main functions: encryption_functions_one and\nencryption_functions_two. Both functions makes use of Microsoft's Base\nCryptography (CryptoAPI). The following section includes the properties used and actions\nperformed by these crypto functions during the malware execution.\n\n\n-----\n\n_CryptAcquireContextW - Uses a PROV_DH_SCHANNEL as provider type (0x18)._\nThe CRYPT_VERIFYCONTEXT and CRYPT_SILENT flags are combined with a\nbitwise-OR operation (0xf0000040) to make sure that no user interface (UI) is\ndisplayed to the user.\n_CryptDecodeObjectEx - Uses a message encoding_\ntype X509_ASN_ENCODING and PKCS_7_ASN_ENCODING that are combined with\na bitwise-OR operation (0x10001), a structure\ntype X509_BASIC_CONSTRAINTS (0x13) and a total of 0x6a bytes that are going to\nbe decoded.\n_CryptImportKey - Imports a key-blob of 0x74 in size (bytes) and_\ntype PUBLICKEYBLOB (0x6) with a CUR_BLOB_VERSION (0x2) version.\n_CryptGenKey - Uses an ALG_ID value that is set to CALG_AES_128 (0x0000660e)_\nand generates a 128-bit AES session key.\n_CryptCreateHash - Uses an ALG_ID value that is set to CALG_SHA (0x00008004),_\nwhich, as the the name suggests, sets the SHA hashing algorithm.\n_CryptDuplicateHash - Receives a handle to the hash to be duplicated._\n_CryptEncrypt - This function receives two main parameters: a handle to the encryption_\nkey generated by the CryptGenKey function and a handle to a hash object generated\nby CryptCreateHash. This value will be used after encryption by calling\nthe CryptEncrypt function and passing as a parameter the pointer to the C2 data.\n_CryptExportKey - Uses a SIMPLEBLOB (0x1) type and CRYPT_OAEP (0x00000040)_\nas a flag. The pointer to the buffer where the key-blob is exported is part of the\nmalware's C2 data.\n_CryptGetHashParam - As in the case of the CryptExportKey function, the destination_\npointer is part of the malware's C2 data.\n_CryptDestroyHash - As its name implies, destroys the given hash._\n\n**Machine ID Generation and Length Checking**\n\nThe generate_machine_id function, as its name states, is in charge of generating a machine\nidentifier for the infected computer. The method used to generate the machine identifier is by\nmaking a call to the _snprintf function, which uses the format string %s_%08X to\nconcatenate the value generated by GetComputerNameA and GetVolumeInformationW. In\nthe particular case of the test machine used in this analysis, the resulting value is\n**ANANDAXPC_58F2C41B.**\n\nFigure 2. Function call to generate a machine identifier (machine-ID value).\n\n\n-----\n\nOnce the machine-id is generated, a length-check verification is also generated. This is\nachieved by calling the \"lstrlen\" function wrapper gen_machine_id_length and passing as a\nparameter the returning value from the previous function call. For the case of the testing\nmachine, the resulting length was \"12\", and such value will reside in a particular stack\nvariable since it will be used as part of the C2 data. Subsequently, a new function call is\nmade to the write_GoR function. Its original purpose is unknown, however, based on the\nanalysis and how the returning value (0x16F87C) is used. It’s presumably a delimiter, since it\nis located at the end of the C2 data.\n\nFigure 3 . Function call to generate C2 data delimiter.\n\n**Operating System Data Collection**\n\nPart of the exfiltrated data also includes OS information, and this is achieved by calling\nthe collect_os_data function.\n\nFigure 4. Function call to collect OS information.\nThis function makes calls to RtlGetVersion, which stores data inside of\nan OSVERSIONINFOW structure, and GetNativeSystemInfo performs the same by saving\nits data inside a SYSTEM_INFO structure.\n\n\n-----\n\nFigure 5. OSVERSIONINFOW and SYSTEM_INFO structures filled up by API calls.\nOnce the data structures are populated, specific data is fetched by the instructions located at\nthese offsets: 0x2EC3DB (Ret value), 0x2EC440 (MajorVersion), 0x2EC3DB, 0x2EC3D0\n(MinorVersion) and 0x2EC45A (Architecture|PROCESSOR_ARCHITECTURE_INTEL).\n\nThe returning value is computed by adding and multiplying against fixed\nvalues: MajorVersion, MinorVersion, Architecture and the returning value (0x1) of\nthe RtlGetNtProductType call, which is a symbolic constant (NtProductWinNT) of the\nNT_PRODUCT_TYPE enumeration data type. The following Python code simulates the logic\nthat generates such value.\n\nFigure 6. Python proof of concept (PoC) emulating the OS data generation algorithm.\n\n**Remote Desktop Services Session Information Collection**\n\nMore calls are performed, including the one to GetCurrentProcessId, which retrieves the\nprocess identifier for the current process, and the returning value is passed to the\n_ProcessIdToSessionId function as parameter. According to the_ [MSDN description,](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-processidtosessionid)\n\n\n-----\n\nthe ProcessIdToSessionId function retrieves the Remote Desktop Services session\nassociated with a specified process.\" The returning value of this function indicates the\nTerminal Services session the current process is running on.\n\nFigure 7. Function call to retrieve the Terminal Service session identifier.\n\n**Process Scanning and C2 Data Collection**\n\nThis function collects active running processes on the system by the execution of the\ntraditional method of calling\nthe CreateToolhelp32Snapshot, Process32FirstW, GetCurrentProcessId and\n_Process32NextW functions. Before entering to this function, the instruction at_\noffset 0x2E4715 loads the address of a local variable in the EAX register and pushed onto\nthe stack. This variable will contain a pointer generated by a call to the RtAllocateHeap\nfunction that will eventually receive the process data information.\n\nFigure 8. Function call to generate and initialize values with process data.\nThis function also makes calls to the sub-function named copy_collected_data_parent.\nDuring its execution, it generates a new memory section made by a call to\nthe RtlAllocateHeap function, and some subsequent calls to the memcpy wrapper function to\ncopy collected C2 data to the new allocated section.\n\nFigure 9. Function call that collects and initializes values with C2 data.\n\n\n-----\n\nThe next function to call is HTTP_LAUNCHER, which contains sub-functions that provide\nweb capability, among other tasks. At this point in time, the variables are initialized with the\ncorresponding return values from the previously executed functions. The following ASCII\ndump shows the variable addresses, the related data and information about which function,\nor instruction offset, provided the given data.\n\nFigure 10. Stack-snapshot including collected data and the data generation functions\nreferences.\nThe next step is a call to the c2_data_write function, which calls\nthe write_collected_data sub-function and passes as parameters two values:\n\n1. A pointer to the C2 data (0x2EAC3E).\n2. The returning value (address) of a new memory allocation generated by a call to\n\nthe RtlAllocateHeap function located at offset 0x2F989B.\n\nThis newly generated data passes through an algorithm, which in addition to writing (at\noffset 0x2FA830) also modifies certain bytes (at offset 0x2FA6DE) of the C2 data, especially\nsome filename extensions.\n\nFigure 11. Function calls that write collected data in memory.\n\n\n-----\n\nOnce the data is collected, a call to write_c2_data_zero is made, which will allocate\nadditional memory by calling the AllocateHeap (0x2E99DC) function. This function will\neventually be called twice, and it will call more sub-functions in where the instructions at\noffset 0x2F362A of the write_c2_data_one function will generate two DWORD values: 0x1,\nwhich is a fixed value, and 0x132, which is the length of the C2 data. The next step is a call\nto copy_c2_data (a wrapper to memcpy at offset 0x2F794C) function, which copies the C2\ndata to a new location next to the two values mentioned earlier.\n\nFigure 12. Function calls that perform intermediary C2 data copying.\nThe next sequential function execution is a call to CryptDuplicateHash. After that, a call\nto copy_binary_data is made, which makes a final C2 data copy to a new memory allocation.\nThis location will contain the last C2 data before being encrypted by\nthe CryptEncrypt function, as will be performed in subsequent steps.\n\nFigure 13. Function calls that make a final copy of unencrypted C2 data.\nThe following picture shows the buffer with its related values and description highlighted with\ndifferent colors for easy reference.\n\nFigure 14.\n\nIn-memory byte offsets and sizes, including individual descriptions.\n\n\n-----\n\nThe next call is to the CryptEncrypt function wrapper, which will reach the real API function\nvia an indirect call to the EAX register located at offset 0x2F0AD4.\n\nFigure 15. Function call to CryptEncrypt to encrypt C2 data.\nThe following picture shows the before and after encryption status of the C2 data.\n\nFigure 16. Before and after encryption status of C2 data.\nOnce the C2 data is encrypted, the following step is to export the current encryption key by\ncalling the CryptExportKey function at offset 0x2EFF2C.\n\nFigure 17. Function call to CryptExportKey wrapper.\nAfter exporting the key, a loop located at offset 0x2EFF41 has an instruction at\noffset 0x2EFF43 that writes into C2 data 0x60 bytes of the exported key.\n\n\n-----\n\nFigure 18. Write loop to populate exported crypto key data.\nNow, a call to the API function CryptGetHashParam is made with a parameter that contains a\npointer to CryptDestroyHash that will write 20 bytes of the generated hash into the C2 data.\n\nFigure 19. Function call to CryptGetHashParam.\nThe following image shows how the final C2 data is stored in memory.\n\nFigure 20. In-memory byte\n\ninclusion of Exported Key, Hash Value and Encrypted C2 data.\n\n**C2 Exfiltration: HTTP Post Request Generation**\n\nAt this stage, the C2 data containing Exported Key, Hash Value, and Encrypted C2\n**data are done. Thus, the last stage is the completion of the data exfiltration. The following**\nsteps prepare the required data (e.g., IP address, HTTP form structure and values, etc.).\n\nFigure 21. Function calls to fulfill the first half of HTTP requirements before data exfiltration.\n\n\n-----\n\nAt this point, subsequent function calls are performed to generate the binary data that will be\nincluded within the HTTP form. The following section will describe the detailed steps that\nlead to such encrypted data and its exfiltration to the C2 server.\n\nThis step consists of copying the C2 data (bytes) to the web form. This is achieved by the\nexecution of the copy_c2_data sub-function. This function will generate a binary MIME\n**attachment of the \"application/octet-stream\" content type with the input data to be suitable**\nfor binary transfer.\n\nFigure 22. Function calls to copy binary data to the web form.\nAt this stage, the final payload is preparing the environment to submit information to the C2\nserver. To do so, it executes function calls to retrieve the required data to finally perform the\nHTTP request.\n\nFigure 23. Function calls to fulfill the second half of HTTP requirements before data\nexfiltration.\nAs can be seen in the function call list, the HttpSendRequestW() API function is used to send\nthe data to the server. This function allows the sender to exceed the amount of data that is\nnormally sent by HTTP clients.\n\n\n-----\n\nFigure\n\n\n-----\n\np g q g p y,\nEncrypted C2 data.\n\n## Conclusion\n\nEmotet was active in the wild for several years before a coordinated law enforcement\ncampaign shut down its infrastructure in late January 2021. Its attack tactics and techniques\nhad evolved over time, and the attack chain is very mature and sophisticated, which makes it\na good case study for security researchers. This research provides an example of Emotet C2\ncommunication, including C2 server IP selection and data encryption, so we can better\nunderstand how Emotet malware utilizes this sophisticated technique to evade security\nproduction detection.\n\nPalo Alto Networks customers are protected from this kind of attack by the following:\n\n[1. Threat Prevention signatures](https://www.paloaltonetworks.com/products/secure-the-network/subscriptions/threat-prevention) [21201,](https://threatvault.paloaltonetworks.com/?query=21201) [21185 and](https://threatvault.paloaltonetworks.com/?query=21185) [21167 identify HTTP C2 requests](https://threatvault.paloaltonetworks.com/?query=21167)\n\nattempting to download the new payload and post sensitive info.\n[2. WildFire and](https://www.paloaltonetworks.com/products/secure-the-network/wildfire) [Cortex XDR identify and block Emotet and its droppers.](https://www.paloaltonetworks.com/cortex/cortex-xdr)\n\n**Indicators of Compromise**\n\nSamples\n\n2cb81a1a59df4a4fd222fbcb946db3d653185c2e79cf4d3365b430b1988d485f\n\nDroppers\n\nbbb9c1b98ec307a5e84095cf491f7475964a698c90b48a9d43490a05b6ba0a79\n\nbd1e56637bd0fe213c2c58d6bd4e6e3693416ec2f90ea29f0c68a0b91815d91a\n\nURLs\n\nhttp://allcannabismeds[.]com/unraid-map/ZZm6/\n\nhttp://giannaspsychicstudio[.]com/cgi-bin/PP/\n\nhttp://ienglishabc[.]com/cow/JH/\n\nhttp://abrillofurniture[.]com/bph-nclex-wygq4/a7nBfhs/\n\nhttps://etkindedektiflik[.]com/pcie-speed/U/\n\nhttps://vstsample[.]com/wp-includes/7eXeI/\n\nhttp://ezi-pos[.]com/categoryl/x/\n\nIPs\n\n5.2.136[.]90\n\n161.49.84[.]2\n\n70.32.89[.]105\n\n190.247.139[.]101\n\n138.197.99[.]250\n\n152.170.79[.]100\n\n190 55 186[ ]229\n\n\n-----\n\n132.248.38[.]158\n110.172.180[.]180\n37.46.129[.]215\n203.157.152[.]9\n157.245.145[.]87\n\n**Get updates from**\n**Palo Alto**\n**Networks!**\n\nSign up to receive the latest news, cyber threat intelligence and research from us\n\n[By submitting this form, you agree to our Terms of Use and acknowledge our Privacy](https://www.paloaltonetworks.com/legal-notices/terms-of-use)\nStatement.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-09 - Emotet Command and Control Case Study.pdf"
    ],
    "report_names": [
        "2021-04-09 - Emotet Command and Control Case Study.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535828,
    "ts_updated_at": 1743041144,
    "ts_creation_date": 1653708837,
    "ts_modification_date": 1653708837,
    "files": {
        "pdf": "https://archive.orkl.eu/704da83cc02b6324fd6b2d922e9e80fdff3343ca.pdf",
        "text": "https://archive.orkl.eu/704da83cc02b6324fd6b2d922e9e80fdff3343ca.txt",
        "img": "https://archive.orkl.eu/704da83cc02b6324fd6b2d922e9e80fdff3343ca.jpg"
    }
}