{
    "id": "2f33587b-b9e8-47e7-8e84-6606a5d13560",
    "created_at": "2023-01-12T15:09:21.051069Z",
    "updated_at": "2025-03-27T02:05:47.409189Z",
    "deleted_at": null,
    "sha1_hash": "420837cd81bfa0c71a80f1b9ad309bc9bb61e215",
    "title": "2016-11-02 - Nymaim Malware- Deep Technical Dive – Adventures in Evasive Malware",
    "authors": "",
    "file_creation_date": "2022-05-28T04:03:50Z",
    "file_modification_date": "2022-05-28T04:03:50Z",
    "file_size": 3129055,
    "plain_text": "# Nymaim Malware: Deep Technical Dive – Adventures in Evasive Malware\n\n**[arielkoren.com/blog/2016/11/02/nymaim-deep-technical-dive-adventures-in-evasive-malware/](https://arielkoren.com/blog/2016/11/02/nymaim-deep-technical-dive-adventures-in-evasive-malware/)**\n\nAK November 2, 2016\n\nNymaim is mostly known worldwide as a downloader, although it seems they evolved from\nformer versions, now having new functionalities to obtain data on the machine with no need\nto download a new payload. Some of the exported functionalities allow harvesting passwords\nand browsers data from the machine, hidden on the file system until communication occurs.\nPayloads downloaded from the C&C are not saved locally on the machine but instead are\nloaded dynamically to memory with a unique internal calling convention.\n\nOne of the signature features I noticed when I began analyzing the Nymaim payload were\nthe novel anti-reverse engineering and obfuscation techniques. Frustrating the analyzer\nmany different code pieces for the same function requires piecing them together in order to\nfully understand the code. Most of the code is heavily obfuscated using ‘spaghetti code’\nmethods but we’ll dive into that in a 1 (bit).\n\nIn addition to the already obfuscated code, the DGA (Domain generation algorithm) use quite\nan interesting technique to make sure it won’t be sink-holed easily, as well as further\nchallenging analyzation.\n\n\n-----\n\nIn this blog, I will review the anti-reverse engineering techniques the malware authors\nimplemented in the code, explain the unique DGA they made, and show different automation\nconcepts to conquer the code and make the analyzer’s life a lot easier.\n\n## And so it begins…\n\nIn general, when I dive into a new malware, I begin with a set of goals or objectives I need to\ndiscover and understand such as the DGA mechanism of a malware, or analyzing the\nprotocol and functionality. When I focus on the DGA for instance, while debugging, I expect\nthe malware to hit (at some point) a DNS resolving function such as `getaddrinfo,`\n```\ngethostbyname or any similar API. Unfortunately, Nymaim hit none of the expected DNS\n\n```\nresolving APIs exported. Confused for a moment, I decided to try a breakpoint on the\n```\nsendto function and indeed the breakpoint is hit. It is a crafted DNS request with a messed\n\n```\nup Call Stack and a hardcoded dns server. I can’t conclude anything definitive, I have to find\nthe caller to the `sendto function manually. Following the RETs and JMPs I finally get to the`\nfunction called the `sendto function. But wait, it looks so weird! (Dramatic drumming…)`\n\nFig. 1, The calling convention to the sendto function\nno way this is the `sendto function!`\n\n## So, it continues! Obfuscation is legit code protection\n\n\n-----\n\nLet us examine the IDA snippet above (Fig. 1), while keeping in mind what the `sendto`\nfunction looks like:\n\nWS2_32!sendto(SOCKET s,\n\nconst char *buf,\n\nint len,\n\nint flags,\n\nconst struct sockaddr *to,\n\nint tolen)\n\nThere are 6 arguments in total. After static analysis of the code, the arguments passed on\nthe stack don’t make much sense in terms of what `sendto is expecting (value wise). Also`\nthere are 9 push opcodes in total. Something fishy is going on in there. Let’s examine the\nlast call function `call sub_1805525 which is the OPCODE I returned to manually from the`\n```\nsendto function.\n\n```\n<SpoilerAlert>\n\nThis function is one of many spaghetti functions found in the code\n\n</SpoilerAlert>\n\n\n-----\n\nFig. 2, How the\n\ncalled function looks like\nTo fully comprehend what is going on, we will first have to understand how the stack would\nlook after calling this function in terms of EBP offsets:\n\nFirst of all pushing EAX (arg_8) and then two more DWORDS, arg_4 (0xCF260F5F) and\narg_0 (0x30D8FC16).\n\nThen calling the function (call sub_1805525) which will put the appropriate ret address as the\nlast value on the stack and that’s all we need to know stack-wise for now when calling this\nfunction.\n\nThen inside the called function the function’s prologue happens\n\n\n-----\n\n```\npush ebp\nmov ebp, esp\n\n```\nThis puts into the base register (EBP) the current stack\naddress to relatively point to stack variables using EBP and\nnot ESP. Let’s see what this function does exactly (As seen\non the IDA snippet above):\n(0) + (1) Overwrite `arg_8 with the` `RetAddress, (2) + (3)`\nsum the values of the two DWORDS pushed on the stack\n( arg_0 + arg_4 ), (4) the result from the last operation will\nbe added to the `arg_8 which was already overwritten with`\nthe `RetAddress .`\nBasically it receives two numbers and a dummy stack value, 3\narguments in total. Resulting in a new return address with the\nvalue of `[ReturnAddress + arg_0 + arg_4] .`\nXreferencing this whole mathematical function shows me it is\nbeing called from 36 m\nore places. There are dozens (!) more variants of this function and about 2600 different\nplaces in which all of the variants being called inside the code.\nBack to analyzing, the new address should be:\n```\n[0x0183BF0B + 0x30D8FC16 + 0XCF260F5F], cutting the 32 bit part will result\n\n```\nin `[0x0182CA80]`\n\n\n-----\n\nFig. 3,\n\nAPI obfuscation for some api calls, sendto commented\nGreat success! The above snippet (Fig. 3) is another part of the obfuscation. The function\nthat would be called next ( sub_180D32D ) is some API-Wrapper. Actually there are no\nstandard API calls anywhere in the code, everything is calculated dynamically… everything.\nIt’s terrible I know.\n\nDiving into that API-Wrapper function is possible (and actually required for the most part).\nHowever I won’t do that in the scope of this blog post.\n\nSo this spaghetti calling convention messes up the code and I will have to fix it if I want to do\nany effective static analysis of it. Before I present the solution for this problem, however, Let’s\nexamine the rest of the unresolved issues in the calling function to `sendto .`\n\n\n-----\n\nFig. 4, Caller to the sendto function, extra unresolved code\nThe next thing we need to investigate, is the repeated function `sub_183AC7E`\n\n\n-----\n\nFig. 5, Push reg obfuscation\nI will make it easy, This is a huge switch-case of putting a register value on the stack\ndependent of the given value. For example, the following code (our `sendto scenario):`\n\n\n-----\n\n```\nseg000:0183BED7       push 10h\nseg000:0183BED9       push 72h ; 'r'\nseg000:0183BEDB       call sub_183AC7E\nseg000:0183BEE0       push 6Fh ; 'o'\nseg000:0183BEE2       call sub_183AC7E\nseg000:0183BEE7       push 6Ch ; 'l'\nseg000:0183BEE9       call sub_183AC7E\nseg000:0183BEEE       push 73h ; 's'\nseg000:0183BEF0       call  sub_183AC7E\nseg000:0183BEF5       push dword ptr [ebp-184h]\n\n```\nCan be translated to\n```\npush 10h\npush esi\npush ebx\npush eax\npush edi\npush dword ptr [ebp-184h]\n\n```\nNow i can peacfully say i know everything i need to de-obfuscate this `sendto call (Well not`\neverything, i did skip the API-Wrapper function, but everything besides that) With all this new\ninformation at hand, we can move on to the next part\n\n## Tomāto-Tomăto, Potāto-Potăto It’s all the same\n\nThe two problems i aim to solve, fixing that spaghetti code calling convention, and to fix the\n```\npush_reg function. These two functions rule most of the code, so fixing these two should\n\n```\nbe a huge step forward in understanding the code and statically analyzing it.\n\nSo how is it done? Easy, Magic!\n\nor in its unofficial name, IDA-Python, scripting an automation process to go over all of the\ncode, wherever one of these functions occur, fix it and change it to a simpler and more\nreadable code format while retaining the same functionality.\n\nSo let’s get practical shall we? Starting with the `push_reg function`\n\nI need to change every call to that function, which is made up of two opcodes:\n```\n6A XX        push <BYTE>\nE8 XX XX XX XX   call <DWORD>\n\n```\nPush and Call, which are both in total 7 bytes in memory. If I could replace these 7 bytes with\nthe appropriate values of the Push <Register> and do it over all of the code, it will be a big\nstep in de-obfuscating the code.\n\nSo now that I know exactly what I want to replace, I wrote a script which does exactly that:\n\n\n-----\n\n```\nPUSH_REGISTER_ADDR 0x0183AC7E\nPUSH_REG_VALUE = 0x6C\nSIZEOF_PUSH_BYTE = 2\ndef fix_reg_push(function_address):\n        patched_counter = 0\n        unpatched_counter = 0\n        values_to_patch = {PUSH_REG_VALUE : 0x50,    # push eax\n              PUSH_REG_VALUE + 1 : 0x51,   # push ecx\n              PUSH_REG_VALUE + 2 : 0x52,   # push edx\n              PUSH_REG_VALUE + 3 : 0x53,   # push ebx\n              PUSH_REG_VALUE + 5 : 0x55,   # push ebp\n              PUSH_REG_VALUE + 6 : 0x56,   # push esi\n              PUSH_REG_VALUE + 7 : 0x57,   # push edi}\n      # Go through all xrefs\n      for xcall in XrefsTo(function_address):\n              # Make code if is not already\n              opcode_length = idc.MakeCode(xcall.frm SIZEOF_PUSH_BYTE)\n              if SIZEOF_PUSH_BYTE != opcode_length:\n                      print \" [*] fix_reg_push not code\n[0x%08X]\" % push_addr\n                      not_code_counter += 1\n                      continue\n              # Obtain previous opcode address\n              push_addr = idc.PrevHead(xcall.frm)\n              # Sanity check 2\n              if \"push\" != GetMnem(push_addr):\n                      print \" [*] fix_reg_push not push\ninstruction [0x%08X]\" % push_addr\n                      print GetMnem(push_addr)\n                      not_push_counter += 1\n                      continue\n              # Get new value\n              push_value = GetOperandValue(push_addr, 0)\n              byte_val = values_to_patch.get(push_value, None)\n              if None == byte_val:\n                      print \" [*] fix_reg_push unexpected push\nvalue [0x%08X]\" % push_addr\n                      bad_push_counter += 1\n                      continue\n              # Patch code\n              idaapi.patch_word(push_addr, 0x04EB) # EB 04 -> Jmp\n$+4...\n              idaapi.patch_long(push_addr + 2, 0x90909090) #\n            idaapi.patch_byte(push_addr + 6, byte_val)\n              patched_counter += 1\n      print \" [*] fix_reg_push - Total: [%d]\\npatched functions:\n\n```\n\n-----\n\n```\n[%d]\\nunpatched functions: [%d] % (patched_counter + unpatched_counter,\npatched_counter, unpatched_counter)\ndef main():\n      fix_reg_push(PUSH_REGISTER_ADDR)\nif \"__main__\" == __name__:\n      main()\n\n```\nThe code above is separated into a couple of sections:\n\nCalling my `fix_reg_push function with the appropriate function address which handles the`\npush register by value\nRunning through all the Xrefs of the function and making IDA identify the bytes as code if it\nhasn’t already. Otherwise there would be issues identifying opcodes later in the script\nMaking sure the xref is valid and working as expected. I don’t want to create any weird code\npatches so I make some necessary sanity checks\nPatching the code, changing the 7 original bytes to `PUSH <reg> and` `JMP <byte> for`\nbetter code clarity.\n\nLets examine the before and after results:\n\n**Before** **After**\n\nAs you can see, I translated the reg_push functions (all of them) to a readable simple deobfuscated push opcodes which have a length of one byte. I could have just done a NOPslide for the rest of the bytes left, but I decided to implement a jmp opcode instead with the\nmemory I had left to overwrite. It’s a matter of taste. The code became much more readable\nand now I can finally read which register represents which value on the stack. This function\nwas fixed at over 3,900 places in the code. So it was definitely worth it.\n\n\n-----\n\nAnd that s it for the first part.\n\nPatching the code on IDA made everything a lot more readable in terms of static analysis.\nNext, there is still that spaghetti calling convention I will have to fix, but as I investigated\nmore of the code, I noticed there are dozens of variations with different calculations being\nmade, and for each one of those, there are a dozen more duplications which look identical to\neach other. The only logical thing left for me to do, was to make a regex to find every\nmatching function.\n\nFig. 6, three spaghetti functions found on the code, using add, xor and sub for calculations\nFortunately finding the common base between all functions wasn’t so hard. All of them have\nmore or less the same prologue, and pretty much the same epilogue. So creating some kind\nof byte regex to find all of them (and fix them!) isn’t very hard. So I’ve done just that.\n\nAfter automatically finding all of these spaghetti functions, I will patch the code just as I have\ndone with the ‘push_reg‘ functions. Only this time I have a lot more “space” in terms of bytes\nto do so\n\nFig. 7, focusing on the sendto call\nIn total, there are 16 bytes, that I would like to change to just CALL (5 bytes), so I have\nenough space to override as I want. This method is practically the same as the method I\nused before. So there is no reason to put another code block to show how its done. Looking\nfor all variants of these functions gave me a result of almost 100 different variations, with a\ntotal of approximately 3,000 different Xrefs in the code (for all variants).\n\nThe final result after patching both the spaghetti calling convention and the push registry by\nvalue:\n\n\n-----\n\nFig. 8, Final patch\n\n## You Can Run, But You Can’t Hide…\n\n\n-----\n\nFinally, having the important parts de-obfuscated, I could continue on to the DGA. Let me pre\nannounce, the authors intent to avoid being sinkholed payed off, good job! It has been a\nwhile since I’ve seen someone trying to protect their code and their DGA as much as they\ndid. So let’s get to it\n\nMost malwares who have a DGA use some value which changes periodically. This one is no\ndifferent and is based on the current date to calculate it’s DGA (Day, Month, Year). Though\nit’s not as simple as it sounds: Instead of using some sort of builtin linear random function\n(such as msvcsrt!rand and msvcrt!srand), they implemented their own functions for making\nrandom numbers and setting the initial seed. Their MagicSeed (I’m going to use that term a\nlot), means the number calculated every day, generated by the current date for example is\nmade out of 128 bits. Every time anything needs to obtain the MagicSeed’s value, the\nMagicSeed changes as well. So I had to follow all of the code very carefully, not to miss\nanything regarding the MagicSeed’s usage.\n\nHow It All Works\n\nI will now explain how the malware reaches the C&C server and the obfuscation made\nbehind the DGA.\n\nAs you would expect from any malware, they make a simple domain list using a MagicSeed,\nthen try to resolve each of the domains created, using google’s dns servers to prevent being\ndns-sinkholed, until one is being resolved and that would usually be the C&C server.\nHowever, this is not our case because it would be too boring to talk about just that wouldn’t\nit?\n\nSo as it gets more complicated, as when trying to resolve all of the generated domains, only\nthe first domain which will be resolved into exactly two different IP addresses. For example,\nthese domains (which are generated at 30/09/2016):\n\n**Generated Domain** **Resolved IP addresses**\n\njfwwqi.com\n\navljz.net 4.2.0.1\n4.2.0.2\n4.2.0.3\n\nhlrhtvl.com\n\nmcodqfban.com 192.168.0.1\n192.168.0.2\n\nxdvhfogmw.pw 13.37.80.80\n\nobsvi.com\n\nigcvdloatwf.in\n\n\n-----\n\n**Generated Domain** **Resolved IP addresses**\n\nzcekjgrmmx.in\n\nThe only domain that will be used from this list would be\n\nmcodqfban.com 192.168.0.1\n192.168.0.2\n\nBecause it is being resolved into two different IP addresses.\n\nYet, these two IP addresses have no direct connection to the C&C server. They are just\ngoing to be another stepping stone in Nymaim’s logic in order to create a new MagicSeed\nnumber.\n\nAnd with that new MagicSeed, create a new domain list. with exactly the same algorithm as\nthe first domain list was generated, But hold on, there is more:\n\nBefore trying to use this newly created domain list, a checksum algorithm is used over the\nnewly created domain list, and the result is compared with a builtin checksums list.\n\nThis probably means that the domains themselves are finite and have probably been prebought, or they are just waiting for the right time to buy a new domain that matches their\nchecksum list.\n\nAfter the list passes the checksum check, the first domain in the list is taken and its TLD is\nchanged to “.COM”.\n\nAfter all this effort, I would guess that domain is all that is left and the IP addresses matching\nthe resolving of this domain are what would be the C&C server. However my guess was\nwrong. The IPs resolved from that newly created domain are not yet the correct IP addresses\nof the C&C servers. For every IP address we get from the DNS request, a loop of xoring and\nrotation calculations are being made over each of the IP Addresses in order to obtain the real\nC&C server IP addresses (Finally!). Let’s summarize everything with a pseudo code:\n\n\n-----\n\n```\ntlds [ .net, .com, .in, .pw ]\nGenerateDomains(magic_num)\n{\n        domains = []\n      seed = CreateUniqueSeed(TODAYS_DATE)\n      rand = GetRandomNumber(seed)\n      for(int i=0; i<16; i++)\n      {\n              domain_str = GenString(rand, seed, magic_num)\n              domain_str += tlds[GetRandomNumber(seed)\n              domains += [domain_str]\n      }\n      return domains\n}\nResolveDomains(domain_list)\n{\n        for(i =0, i<16; i++)\n        {\n              ip_addresses = DnsResolve(domain_list[i])\n              if (2 == ip_addresses.length())\n                      return ip_addresses\n      }\n}\nMain()\n{\n        domains = GenerateDomains(0)\n      ips = ResolveDomains(domains)\n      new_domains = GenerateDomains(ips)\n      domain = new_domains[0].replace(\".com\")\n      real_ips = ResolveDomains(domain)\n      real_ips = XorIPS(real_ips)\n      CommunicateWithRealServer(real_ips)\n}\n\n```\nGenerateDomains\n\nCreating a unique seed based on current date\nGenerate random number from seed\nCreate a domain string from generated random number and the seed\nCreate a new random, use it to append TLD\nReturns a list of 16 domains created\nResolveDomains\n\nTrying to resolve domain list ip addresses\nCheck if exactly 2 IP addresses were obtained in the dns request\nReturn list of resolved addresses\n\n\n-----\n\nMain\n\nGenerating first list of domains\nGet good matching ip addresses (Only 2 ip addresses)\nGenerate new list of domains from the ips we got\nChange TLD of the first domain from the list generated\nResolve domain\nObtain real C&C ip addresses through calculations\nCommunicate with C&C\n\nI have also added a graph form for convenience\n\nFig. 9, Graph format of the pseudo code\nThis is a lot of stuff to do in order just to get a C&C server IP address. Those little tricks they\nused made it harder to reverse and understand the Nymaim code, and harder to sink-hole\nthe malware as well.\n\nSo here we see prime example of how malware authors try to avoid being sink-holed by\nusing obfuscation methods as protection for their code.\n\nBut then again, everything can be conquered and beaten if you wear on your malware\nthinking-cap and put your mind into it.\n\nRef analyzed sample:\n\nc41ffc1fd6e3f5157181b6e45f45f4fe\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-11-02 - Nymaim Malware- Deep Technical Dive – Adventures in Evasive Malware.pdf"
    ],
    "report_names": [
        "2016-11-02 - Nymaim Malware- Deep Technical Dive – Adventures in Evasive Malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536161,
    "ts_updated_at": 1743041147,
    "ts_creation_date": 1653710630,
    "ts_modification_date": 1653710630,
    "files": {
        "pdf": "https://archive.orkl.eu/420837cd81bfa0c71a80f1b9ad309bc9bb61e215.pdf",
        "text": "https://archive.orkl.eu/420837cd81bfa0c71a80f1b9ad309bc9bb61e215.txt",
        "img": "https://archive.orkl.eu/420837cd81bfa0c71a80f1b9ad309bc9bb61e215.jpg"
    }
}