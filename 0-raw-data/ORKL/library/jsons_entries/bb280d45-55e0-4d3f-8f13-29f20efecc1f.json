{
    "id": "bb280d45-55e0-4d3f-8f13-29f20efecc1f",
    "created_at": "2022-10-25T16:48:21.815281Z",
    "updated_at": "2025-03-27T02:09:20.766919Z",
    "deleted_at": null,
    "sha1_hash": "61cbc94ba10fa02aa103a45c681a5cf52c74b402",
    "title": "",
    "authors": "",
    "file_creation_date": "2021-04-14T02:41:41Z",
    "file_modification_date": "2021-04-14T02:41:41Z",
    "file_size": 645439,
    "plain_text": "# Zero-day vulnerability in Desktop Window Manager (CVE-2021-28310) used in the wild\n\n**[securelist.com/zero-day-vulnerability-in-desktop-window-manager-cve-2021-28310-used-in-the-wild/101898](https://securelist.com/zero-day-vulnerability-in-desktop-window-manager-cve-2021-28310-used-in-the-wild/101898/)**\n\n[While analyzing the CVE-2021-1732 exploit originally discovered by the DBAPPSecurity Threat Intelligence Center](https://ti.dbappsecurity.com.cn/blog/index.php/2021/02/10/windows-kernel-zero-day-exploit-is-used-by-bitter-apt-in-targeted-attack/)\nand used by the BITTER APT group, we discovered another zero-day exploit we believe is linked to the same actor.\nWe reported this new exploit to Microsoft in February and after confirmation that it is indeed a zero-day, it\n[received the designation CVE-2021-28310. Microsoft released a patch to this vulnerability as a part of its April](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-28310)\nsecurity updates.\n\nWe believe this exploit is used in the wild, potentially by several threat actors. It is an escalation of privilege (EoP)\nexploit that is likely used together with other browser exploits to escape sandboxes or get system privileges for\nfurther access. Unfortunately, we weren’t able to capture a full chain, so we don’t know if the exploit is used with\nanother browser zero-day, or coupled with known, patched vulnerabilities.\n\nThe exploit was initially identified by our advanced exploit prevention technology and related detection records. In\nfact, over the past few years, we have built a multitude of exploit protection technologies into our products that\nhave detected several zero-days, proving their effectiveness time and again. We will continue to improve defenses\nfor our users by enhancing technologies and working with third-party vendors to patch vulnerabilities, making the\ninternet more secure for everyone. In this blog we provide a technical analysis of the vulnerability and how the bad\nguys exploited it. More information about BITTER APT and IOCs are available to customers of the Kaspersky\n[Intelligence Reporting service. Contact: intelreports@kaspersky.com.](mailto:intelreports@kaspersky.com)\n\n## Technical details\n\nCVE-2021-28310 is an out-of-bounds (OOB) write vulnerability in dwmcore.dll, which is part of Desktop Window\nManager (dwm.exe). Due to the lack of bounds checking, attackers are able to create a situation that allows them to\n[write controlled data at a controlled offset using DirectComposition API. DirectComposition is a Windows](https://docs.microsoft.com/en-us/windows/win32/directcomp/directcomposition-portal)\ncomponent that was introduced in Windows 8 to enable bitmap composition with transforms, effects and\n[animations, with support for bitmaps of different sources (GDI, DirectX, etc.). We’ve already published a blogpost](https://securelist.com/cve-2019-0797-zero-day-vulnerability/89885/)\nabout in-the-wild zero-days abusing DirectComposition API. DirectComposition API is implemented by the\nwin32kbase.sys driver and the names of all related syscalls start with the string “NtDComposition”.\n\n\n-----\n\n**_DirectComposition syscalls in the win32kbase.sys driver_**\n\nFor exploitation only three syscalls are required: NtDCompositionCreateChannel,\nNtDCompositionProcessChannelBatchBuffer and NtDCompositionCommitChannel. The\nNtDCompositionCreateChannel syscall initiates a channel that can be used together with the\nNtDCompositionProcessChannelBatchBuffer syscall to send multiple DirectComposition commands in one go for\nprocessing by the kernel in a batch mode. For this to work, commands need to be written sequentially in a special\nbuffer mapped by NtDCompositionCreateChannel syscall. Each command has its own format with a variable length\nand list of parameters.\n\n\n-----\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n\nenum DCOMPOSITION_COMMAND_ID\n\n{\n\nProcessCommandBufferIterator,\n\nCreateResource,\n\nOpenSharedResource,\n\nReleaseResource,\n\nGetAnimationTime,\n\nCapturePointer,\n\nOpenSharedResourceHandle,\n\nSetResourceCallbackId,\n\nSetResourceIntegerProperty,\n\nSetResourceFloatProperty,\n\nSetResourceHandleProperty,\n\nSetResourceHandleArrayProperty,\n\nSetResourceBufferProperty,\n\nSetResourceReferenceProperty,\n\nSetResourceReferenceArrayProperty,\n\nSetResourceAnimationProperty,\n\nSetResourceDeletedNotificationTag,\n\nAddVisualChild,\n\nRedirectMouseToHwnd,\n\nSetVisualInputSink,\n\nRemoveVisualChild\n\n};\n\n\n**_List of command IDs supported by the function_**\n**_DirectComposition::CApplicationChannel::ProcessCommandBufferIterator_**\n\nWhile these commands are processed by the kernel, they are also serialized into another format and passed by the\nLocal Procedure Call (LPC) protocol to the Desktop Window Manager (dwm.exe) process for rendering to the\nscreen. This procedure could be initiated by the third syscall – NtDCompositionCommitChannel.\n\nTo trigger the vulnerability the discovered exploit uses three types of commands: CreateResource, ReleaseResource\nand SetResourceBufferProperty.\n\n\n-----\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n\nvoid CreateResourceCmd(int resourceId)\n\n{\n\nDWORD *buf = (DWORD *)((PUCHAR)pMappedAddress + BatchLength);\n\n*buf = CreateResource;\n\nbuf[1] = resourceId;\n\nbuf[2] = PropertySet; // MIL_RESOURCE_TYPE\n\nbuf[3] = FALSE;\n\nBatchLength += 16;\n\n}\n\nvoid ReleaseResourceCmd(int resourceId)\n\n{\n\nDWORD *buf = (DWORD *)((PUCHAR)pMappedAddress + BatchLength);\n\n*buf = ReleaseResource;\n\nbuf[1] = resourceId;\n\nBatchLength += 8;\n\n}\n\nvoid SetPropertyCmd(int resourceId, bool update, int propertyId, int storageOffset, int hidword, int lodword)\n\n{\n\nDWORD *buf = (DWORD *)((PUCHAR)pMappedAddress + BatchLength);\n\n*buf = SetResourceBufferProperty;\n\nbuf[1] = resourceId;\n\nbuf[2] = update;\n\nbuf[3] = 20;\n\nbuf[4] = propertyId;\n\nbuf[5] = storageOffset;\n\nbuf[6] = _D2DVector2; // DCOMPOSITION_EXPRESSION_TYPE\n\nbuf[7] = hidword;\n\nbuf[8] = lodword;\n\nBatchLength += 36;\n\n}\n\n\n**_Format of commands used in exploitation_**\n\n\n-----\n\nLet’s take a look at the function CPropertySet::ProcessSetPropertyValue in dwmcore.dll. This function is\nresponsible for processing the SetResourceBufferProperty command. We are most interested in the code\nresponsible for handling DCOMPOSITION_EXPRESSION_TYPE = D2DVector2.\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n33\n\n\nint CPropertySet::ProcessSetPropertyValue(CPropertySet *this, ...)\n\n{\n\n...\n\nif (expression_type == _D2DVector2)\n\n{\n\nif (!update)\n\n{\n\nCPropertySet::AddProperty<D2DVector2>(this, propertyId, storageOffset, _D2DVector2, value);\n\n}\n\nelse\n\n{\n\nif ( storageOffset != this->properties[propertyId]->offset & 0x1FFFFFFF )\n\n{\n\ngoto fail;\n\n}\n\nCPropertySet::UpdateProperty<D2DVector2>(this, propertyId, _D2DVector2, value);\n\n}\n\n}\n\n...\n\n}\n\nint CPropertySet::AddProperty<D2DVector2>(CResource *this, unsigned int propertyId, int storageOffset, int\ntype, _QWORD *value)\n\n{\n\nint propertyIdAdded;\n\nint result =\nPropertySetStorage<DynArrayNoZero,PropertySetUserModeAllocator>::AddProperty<D2DVector2>(\n\nthis->propertiesData,\n\ntype,\n\nvalue,\n\n\n-----\n\n34\n\n35\n\n36\n\n37\n\n38\n\n39\n\n40\n\n41\n\n42\n\n43\n\n44\n\n45\n\n46\n\n47\n\n48\n\n49\n\n50\n\n51\n\n52\n\n53\n\n54\n\n55\n\n56\n\n57\n\n58\n\n59\n\n60\n\n61\n\n62\n\n63\n\n64\n\n65\n\n66\n\n67\n\n68\n\n69\n\n\n&propertyIdAdded);\n\nif ( result < 0 )\n\n{\n\nreturn result;\n\n}\n\nif ( propertyId != propertyIdAdded || storageOffset != this->properties[propertyId]->offset & 0x1FFFFFFF )\n\n{\n\nreturn 0x88980403;\n\n}\n\nresult = CPropertySet::PropertyUpdated<D2DMatrix>(this, propertyId);\n\nif ( result < 0 )\n\n{\n\nreturn result;\n\n}\n\nreturn 0;\n\n}\n\nint CPropertySet::UpdateProperty<D2DVector2>(CResource *this, unsigned int propertyId, int type,\n_QWORD *value)\n\n{\n\nif ( this->properties[propertyId]->type == type )\n\n{\n\n*(_QWORD *)(this->propertiesData + (this->properties[propertyId]->offset & 0x1FFFFFFF)) = *value;\n\nint result = CPropertySet::PropertyUpdated<D2DMatrix>(this, propertyId);\n\nif ( result < 0 )\n\n{\n\nreturn result;\n\n}\n\nreturn 0;\n\n}\n\nelse\n\n\n-----\n\n70\n\n71\n\n\n{\n\nreturn 0x80070057;\n\n}\n\n}\n\n\n**_Processing of the SetResourceBufferProperty (D2DVector2) command in dwmcore.dll_**\n\nFor the SetResourceBufferProperty command with the expression type set to D2DVector2, the function\nCPropertySet::ProcessSetPropertyValue(…) would either call CPropertySet::AddProperty<D2DVector2>(…) or\nCPropertySet::UpdateProperty<D2DVector2>(…) depending on whether the update flag is set in the command.\nThe first thing that catches the eye is the way the new property is added in the\nCPropertySet::AddProperty<D2DVector2>(…) function. You can see that it adds a new property to the resource,\nbut it only checks if the propertyId and storageOffset of a new property are equal to the provided values after the\nnew property is added, and returns an error if that’s not the case. Checking something after a job is done is bad\ncoding practice and can result in vulnerabilities. However, a real issue can be found in the\nCPropertySet::UpdateProperty<D2DVector2>(…) function. No check takes place that will ensure if the provided\npropertyId is less than the count of properties added to the resource. As a result, an attacker can use this function\nto perform an OOB write past the propertiesData buffer if it manages to bypass two additional checks for data\ninside the properties array.\n\n\n1\n\n2\n\n\n(1) storageOffset == this->properties[propertyId]->offset & 0x1FFFFFFF\n\n(2) this->properties[propertyId]->type == type\n\n\n**_Conditions which need to be met for exploitation in dwmcore.dll_**\n\nThese checks could be bypassed if an attacker is able to allocate and release objects in the dwm.exe process to\ngroom heap into the desired state and spray memory at specific locations with fake properties. The discovered\nexploit manages to do this using the CreateResource, ReleaseResource and SetResourceBufferProperty commands.\n\nAt the time of writing, we still hadn’t analyzed the updated binaries that are fixing this vulnerability, but to exclude\nthe possibility of other variants for this vulnerability Microsoft would need to check the count of properties for\nother expression types as well.\n\nEven with the above issues in dwmcore.dll, if the desired memory state is achieved to bypass the previously\nmentioned checks and a batch of commands are issued to trigger the vulnerability, it still won’t be triggered\nbecause there is one more thing preventing it from happening.\n\nAs mentioned above, commands are first processed by the kernel and only after that are they sent to Desktop\nWindow Manager (dwm.exe). This means that if you try to send a command with an invalid propertyId,\nNtDCompositionProcessChannelBatchBuffer syscall will return an error and the command will not be passed to the\ndwm.exe process. SetResourceBufferProperty commands with expression type set to D2DVector2 are processed in\nthe win32kbase.sys driver with the functions\nDirectComposition::CPropertySetMarshaler::AddProperty<D2DVector2>(…) and\nDirectComposition::CPropertySetMarshaler::UpdateProperty<D2DVector2>(…), which are very similar to those\npresent in dwmcore.dll (it’s quite likely they were copy-pasted). However, the kernel version of the\nUpdateProperty<D2DVector2> function has one notable difference – it actually checks the count of properties\nadded to the resource.\n\n\n-----\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n\nint DirectComposition::CPropertySetMarshaler::UpdateProperty<D2DVector2>\n(DirectComposition::CPropertySetMarshaler *this, unsigned int *commandParams, _QWORD *value)\n\n{\n\nunsigned int propertyId = commandParams[0];\n\nunsigned int storageOffset = commandParams[1];\n\nunsigned int type = commandParams[2];\n\nif ( propertyId >= this->propertiesCount\n\n|| storageOffset != this->properties[propertyId]->offset & 0x1FFFFFFF)\n\n|| type != this->properties[propertyId]->type )\n\n{\n\nreturn 0xC000000D;\n\n}\n\nelse\n\n{\n\n*(_QWORD *)(this->propertiesData + (this->properties[propertyId]->offset & 0x1FFFFFFF)) = *value;\n\n...\n\n}\n\nreturn 0;\n\n}\n\n\n**_DirectComposition::CPropertySetMarshaler::UpdateProperty<D2DVector2>(…) in_**\n**_win32kbase.sys_**\n\nThe check for propertiesCount in the kernel mode version of the UpdateProperty<D2DVector2> function prevents\nfurther processing of a malicious command by its user mode twin and mitigates the vulnerability, but this is where\nDirectComposition::CPropertySetMarshaler::AddProperty<D2DVector2>(…) comes in to play. The kernel version\nof the AddProperty<D2DVector2> function works exactly like its user mode variant and it also applies the same\nbehavior of checking property after it has already been added and returns an error if propertyId and storageOffset\nof the created property do not match the provided values. Because of this, it’s possible to use the\nAddProperty<D2DVector2> function to add a new property and force the function to return an error and cause\ninconsistency between the number of properties assigned to the same resource in kernel mode/user mode. The\npropertiesCount check in the kernel could be bypassed this way and malicious commands would be passed to\nDesktop Window Manager (dwm.exe).\n\nInconsistency between the number of properties assigned to the same resource in kernel mode/user mode could be\na source of other vulnerabilities, so we recommend Microsoft to change the behavior of the AddProperty function\nand check properties before they are added.\n\nThe whole exploitation process for the discovered exploit is as follows:\n\n1. Create a large number of resources with properties of specific size to get heap into predictable state.\n2. Create additional resources with properties of specific size and content to spray memory at specific locations\n\nwith fake properties.\n3. Release resources created at stage 2.\n\n\n-----\n\n4. Create additional resources with properties. These resources will be used to perform OOB writes.\n\n5. Make holes among resources created at stage 1.\n6. Create additional properties for resources created at stage 4. Their buffers are expected to be allocated at\n\nspecific locations.\n7. Create “special” properties to cause inconsistency between the number of properties assigned to the same\n\nresource in kernel mode/user mode for resources created at stage 4.\n8. Use OOB write vulnerability to write shellcode, create an object and get code execution.\n9. Inject additional shellcode into another system process.\n\nKaspersky products detect this exploit with the verdicts:\n\nHEUR:Exploit.Win32.Generic\nHEUR:Trojan.Win32.Generic\nPDM:Exploit.Win32.Generic\n\nZero-day vulnerability in Desktop Window Manager (CVE-2021-28310) used in the wild\n\nYour email address will not be published. Required fields are marked *\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2021/2021.04.13.CVE-2021-28310_APT/Zero-day%20vulnerability%20in%20Desktop%20Window%20Manager%20%28CVE-2021-28310%29%20used%20in%20the%20wild%20_%20Securelist.pdf"
    ],
    "report_names": [
        "Zero-day vulnerability in Desktop Window Manager (CVE-2021-28310) used in the wild _ Securelist"
    ],
    "threat_actors": [
        {
            "id": "bf6cb670-bb69-473f-a220-97ac713fd081",
            "created_at": "2022-10-25T16:07:23.395205Z",
            "updated_at": "2025-03-27T02:02:09.777308Z",
            "deleted_at": null,
            "main_name": "Bitter",
            "aliases": [
                "T-APT-17",
                "TA397"
            ],
            "source_name": "ETDA:Bitter",
            "tools": [
                "Artra Downloader",
                "ArtraDownloader",
                "Bitter RAT",
                "BitterRAT",
                "Dracarys"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "655f7d0b-7ea6-4950-b272-969ab7c27a4b",
            "created_at": "2022-10-27T08:27:13.133291Z",
            "updated_at": "2025-03-27T02:00:55.490812Z",
            "deleted_at": null,
            "main_name": "BITTER",
            "aliases": [
                "T-APT-17"
            ],
            "source_name": "MITRE:BITTER",
            "tools": [
                "ZxxZ"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716501,
    "ts_updated_at": 1743041360,
    "ts_creation_date": 1618368101,
    "ts_modification_date": 1618368101,
    "files": {
        "pdf": "https://archive.orkl.eu/61cbc94ba10fa02aa103a45c681a5cf52c74b402.pdf",
        "text": "https://archive.orkl.eu/61cbc94ba10fa02aa103a45c681a5cf52c74b402.txt",
        "img": "https://archive.orkl.eu/61cbc94ba10fa02aa103a45c681a5cf52c74b402.jpg"
    }
}