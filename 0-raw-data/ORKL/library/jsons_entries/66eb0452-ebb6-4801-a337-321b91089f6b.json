{
    "id": "66eb0452-ebb6-4801-a337-321b91089f6b",
    "created_at": "2023-01-12T15:00:14.59903Z",
    "updated_at": "2025-03-27T02:05:30.383838Z",
    "deleted_at": null,
    "sha1_hash": "86e851f9182571f9204a35af59764c9f03ca9583",
    "title": "2020-09-02 - Machine learning from idea to reality- a PowerShell case study",
    "authors": "",
    "file_creation_date": "2022-05-28T03:32:04Z",
    "file_modification_date": "2022-05-28T03:32:04Z",
    "file_size": 498878,
    "plain_text": "# Machine learning from idea to reality: a PowerShell case study\n\n**[blog.fox-it.com/2020/09/02/machine-learning-from-idea-to-reality-a-powershell-case-study/](https://blog.fox-it.com/2020/09/02/machine-learning-from-idea-to-reality-a-powershell-case-study/)**\n\nSeptember 2, 2020\n\n**Detecting both ‘offensive’ and obfuscated PowerShell scripts in Splunk using**\n**Windows Event Log 4104**\n\n_Author: Joost Jansen_\n\nThis blog provides a ‘look behind the scenes’ at the RIFT Data Science team and describes\nthe process of moving from the need or an idea for research towards models that can be\nused in practice. More specifically, how known and unknown PowerShell threats can be\ndetected using Windows event log 4104. In this case study it is shown how research into\ndetecting offensive (with the term ‘offensive’ used in the context of ‘offensive security’) and\nobfuscated PowerShell scripts led to models that can be used in a real-time environment.\n\n_About the Research and Intelligence Fusion Team (RIFT):_\n\n_RIFT leverages our strategic analysis, data science, and threat hunting capabilities to create_\n_actionable threat intelligence, ranging from IOCs and detection capabilities to strategic_\n_reports on tomorrow’s threat landscape. Cyber security is an arms race where both attackers_\n_and defenders continually update and improve their tools and ways of working. To ensure_\n_that our managed services remain effective against the latest threats, NCC Group operates a_\n_Global Fusion Center with Fox-IT at its core. This multidisciplinary team converts our leading_\n_cyber threat intelligence into powerful detection strategies._\n\n## Introduction to PowerShell\n\nPowerShell plays a huge role in a lot of incidents that are analyzed by Fox-IT. During the\ncompromise of a Windows environment almost all actors use PowerShell in at least one part\nof their attack, as illustrated by the vast list of actors linked to this MITRE technique [1].\nPowerShell code is most frequently used for reconnaissance, lateral movement and/or C2\n\n\n-----\n\ntraffic. It lends itself to these purposes, as the PowerShell cmdlets are well-integrated with\nthe Windows operating system and it is installed along with Windows in most recent\nversions.\n\nThe strength of PowerShell can be illustrated with the following example. Consider the\nprivilege-escalation enumeration script PowerUp.ps1 [2]. Although the script itself consists of\n4010 lines, it can simply be downloaded and invoked using:\n\nIn this case, the script won’t even touch the disk as it’s executed in memory. Since threat\nactors are aware that there might be detection capabilities in place, they often encode or\nobfuscate their code. For example, the command executed above can also be run base64encoded:\n\nwhich has the exact same result.\n\nUsing tools like Invoke-Obfuscation [3], the command and the script itself can be obfuscated\neven further. For example, the following code snippet from PowerUp.ps1\n\ncan also be obfuscated as:\n\nThese well-known offensive PowerShell scripts can already be detected by using static\nsignatures, but small modifications on the right place will circumvent the detection. Moreover,\nthese signatures might not detect new versions of the known offensive scripts, let alone\ndetect new techniques. Therefore, there was an urge to create models to detect offensive\nPowerShell scripts regardless of their obfuscation level, as illustrated in Table 1.\n\nTable 1: Detection of different\n\nmalicious PowerShell scripts\n\n\n-----\n\n## Don t reinvent the wheel\n\nAs we don’t want to re-invent the wheel, a literature study revealed fellow security companies\nhad already performed research on this subject [4, 5], which was a great starting point for\nthis research. As we prefer easily explainable classification models over complex ones (e.g.\nthe neural networks used in the previous research) and obviously faster models over slower\nones, not all parts of the research were applicable. However, large parts of the data\ngathering & pre-processing phase were reused while the actual features and classification\nmethod were changed.\n\nSince detecting offensive & obfuscated PowerShell scripts are separate problems, they\nrequire separate training data. For the offensive training data, PowerShell scripts embedded\nin “known bad” GitHub repositories were scraped. For the obfuscated training data, parts of\nthe Revoke-Obfuscation training data set were used [6]. An equal amount of legitimate\n(‘known not-obfuscated’ and “known not-offensive”) scripts were added to the training sets\n(retrieved from the PowerShell Gallery [7]) resulting in the training sets listed in Table 2.\n\nTable 2: Training set sizes\nTo keep things simple and explainable the decision was made to base the initial model on\ntoken (offensive) and character (obfuscated) percentages. This did require some\npreprocessing of the scripts (e.g. removing the comments), calculating the features and in\nthe case of the offensive scripts, tokenization of the PowerShell scripts. Figures 1 & 2\nillustrate how some characters and tokens are unevenly distributed among the training sets.\n\nFigure 1: Average occurrence of several ASCII characters in obfuscated and not-obfuscated\nscripts\n\n\n-----\n\nFigure 2: Average occurrence of several tokens in offensive and not-offensive scripts\nThe percentages were then used as features for a supervised classification model to train,\nalong with some additional features based on known bad tokens (e.g. base64, iex and\nconvert) and several regular expression patterns. Afterwards all features and labels were fed\nto our SupervisedClassification helper class, which is used in many of our projects to\nstandardize the process of (synthetic) sampling of training data, DataFrame transformations,\nmodel selection and several other tasks. For both models, the SupervisedClassification class\nselected the Random Forest algorithm for the classifying task. Figure 3 summarizes the\nworkflow for the obfuscated PowerShell model.\n\nFigure 3: High-level overview of the training process for the obfuscation model\n\n## Usage in practice\n\nSince these models were exported, they can be used for multiple purposes by loading the\nmodels in Python, feeding PowerShell scripts to it and observe the predicted outcomes. In\nthis example, Splunk was chosen as the platform to use this model because it is part of our\nManaged Detection & Response service and because of Splunk’s ability to easily run custom\nPython commands.\n\nWindows is able to log blocks of PowerShell code as it is executed, called ‘PowerShell Script\nBlock Logging’ which can be enabled via GPO or manual registry changes. The logs\n(identified by Windows Event ID 4101) can then be piped to a Splunk custom command\n_Reconstruct4101Logging, which will process the script blocks back into the format the model_\n\n\n-----\n\nwas trained on. Afterwards, the reconstructed script is piped into e.g. the\n_ObfuscatedPowershell custom command, which will load the pre-trained model, predict the_\nprobabilities for the scripts being obfuscated and returns these predictions back to Splunk.\nThis is shown in Figure 4.\n\nFigure 4: Usage of the pre-trained model in Splunk along with the corresponding query\n\n## Performance\n\nBack in Splunk some additional tuning can be performed (such as setting the threshold for\npredicting the positive class to 0.7) to reduce the amount of false positives. Using crossvalidation, a precision score of 0.94 was achieved with an F1 score of 0.9 for the obfuscated\nPowerShell model. The performance of the offensive model is not yet as good as the\nobfuscated model, but since there are many parameters to tune for this model we expect this\nto improve in the foreseeable future. The confusion matrix for the obfuscated model is shown\nin Table 3.\n\nTable 3: Confusion matrix\n\nDespite the fact that other studies achieve even higher scores, we believe that this relatively\nsimple and easy to understand model is a great first step, for which we can iteratively\nimprove the scores over time. To finish off, these models are included in our Splunk\nManaged Detection Engine to check for offensive & obfuscated PowerShell scripts on a\nregular interval.\n\n## Conclusion and recommendation\n\nPowerShell, despite being a legitimate and very useful tool, is frequently misused by threat\nactors for various malicious purposes. Using static signatures, well-known bad scripts can be\ndetected, but small modifications may cause these signatures to be circumvented. To detect\nmodified and/or new PowerShell scripts and techniques, more and better generic models\nshould be researched and eventually be deployed in real-time log monitoring environments.\nPowerShell logging (including but not limited to the Windows Event Logs with ID 4104) can\nbe used as input for these models. The recommendation is therefore to enable the\n\n\n-----\n\nPowerShell logging in your organization, at least at the most important endpoints or servers.\nThis recommendation, among others, was already present in our whitepaper on ‘Managing\nPowerShell in a modern corporate environment‘ [8] back in 2017 and remains very relevant\nto this day. Additional information on other defensive measures that can be put into place\ncan also be found in the whitepaper.\n\n### References\n\n[1] [https://attack.mitre.org/techniques/T1059/001/](https://attack.mitre.org/techniques/T1059/001/)\n\n[2] [https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1](https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1)\n\n[3] [https://github.com/danielbohannon/Invoke-Obfuscation](https://github.com/danielbohannon/Invoke-Obfuscation)\n\n[4] [https://arxiv.org/pdf/1905.09538.pdf](https://arxiv.org/pdf/1905.09538.pdf)\n\n[5] https://www.fireeye.com/blog/threat-research/2018/07/malicious-powershell-detection-viamachine-learning.html\n\n[6] [https://github.com/danielbohannon/Revoke-Obfuscation/tree/master/DataScience](https://github.com/danielbohannon/Revoke-Obfuscation/tree/master/DataScience)\n\n[7] [https://www.powershellgallery.com/](https://www.powershellgallery.com/)\n\n[8] https://www.nccgroup.com/uk/our-research/managing-powershell-in-a-modern-corporateenvironment/\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-09-02 - Machine learning from idea to reality- a PowerShell case study.pdf"
    ],
    "report_names": [
        "2020-09-02 - Machine learning from idea to reality- a PowerShell case study.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535614,
    "ts_updated_at": 1743041130,
    "ts_creation_date": 1653708724,
    "ts_modification_date": 1653708724,
    "files": {
        "pdf": "https://archive.orkl.eu/86e851f9182571f9204a35af59764c9f03ca9583.pdf",
        "text": "https://archive.orkl.eu/86e851f9182571f9204a35af59764c9f03ca9583.txt",
        "img": "https://archive.orkl.eu/86e851f9182571f9204a35af59764c9f03ca9583.jpg"
    }
}