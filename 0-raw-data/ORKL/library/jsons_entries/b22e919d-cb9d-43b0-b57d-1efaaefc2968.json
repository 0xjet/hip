{
    "id": "b22e919d-cb9d-43b0-b57d-1efaaefc2968",
    "created_at": "2022-10-25T16:48:17.510165Z",
    "updated_at": "2025-03-27T02:13:34.705863Z",
    "deleted_at": null,
    "sha1_hash": "80df30f965d4fe41eee6fba99905a75eb9a1c1d9",
    "title": "",
    "authors": "",
    "file_creation_date": "2018-01-24T17:32:27Z",
    "file_modification_date": "2018-01-24T17:32:30Z",
    "file_size": 1348290,
    "plain_text": "# ESET’S GUIDE TO DEOBFUSCATING AND DEVIRTUALIZING FINFISHER\n\n\n-----\n\n## CONTENTS\n\n**Introduction** **3**\n\n**Anti-disassembly** **4**\n\n**FinFisher’s virtual machine** **7**\n\nTerms and definitions 8\n\nVm_start 8\n\n**FinFisher’s interpreter** **10**\n\n1. Creating an IDA graph 10\n\n2. Vm_dispatcher 11\n\n3. Vm_context 12\n\n4. \u0007Virtual instruction implementations – vm_handlers 14\n\n5. Writing your own disassembler 17\n\n6. \u0007Understanding the implementation of this virtual machine 19\n\n7. \u0007Automating the disassembly process for more FinFisher samples 20\n\n8. \u0007Compiling disassembled code without the VM 20\n\n**Conclusion** **22**\n\n**Appendix A: IDA Python script for naming FinFisher vm_handlers** **23**\n\n\n-----\n\n## INTRODUCTION\n\n\nThanks to its strong anti-analysis measures, the\n\nFinFisher spyware has gone largely unexplored.\n\nDespite being a prominent surveillance tool,\n\nonly partial analyses have been published on its\n\nmore recent samples.\n\nThings were put in motion in the summer\n\nof 2017 with ESET’s analysis of FinFisher\n\nsurveillance campaigns that ESET had\n\ndiscovered in several countries. In the course of\n\n[our research, we have identified campaigns where](https://www.welivesecurity.com/2017/09/21/new-finfisher-surveillance-campaigns/)\n\n_[internet service providers most probably played](https://www.welivesecurity.com/2017/09/21/new-finfisher-surveillance-campaigns/)_\n\nthe key role in compromising the victims with\n\nFinFisher.\n\nWhen we started thoroughly analyzing this\n\nmalware, the main part of our effort was\n\novercoming FinFisher’s anti-analysis measures\n\nin its Windows versions. The combination\n\nof advanced obfuscation techniques and\n\nproprietary virtualization makes FinFisher very\n\nhard to de-cloak.\n\nTo share what we learnt in de-cloaking this\n\nmalware, we have created this guide to help\n\nothers take a peek inside FinFisher and analyze\n\nit. Apart from offering practical insight into\n\nanalyzing FinFisher’s virtual machine, the\n\nguide can also help readers to understand\n\nvirtual machine protection in general – that\n\nis, proprietary virtual machines found inside a\n\nbinary and used for software protection. We\n\nwill not be discussing virtual machines used in\n\ninterpreted programming languages to provide\n\ncompatibility across various platforms, such as\n\nthe Java VM.\n\n\nWe have also analyzed Android versions of\n\nFinFisher, whose protection mechanism is based\n\non an open source LLVM obfuscator. It is not as\n\nsophisticated or interesting as the protection\n\nmechanism used in the Windows versions, thus\n\nwe will not be discussing it in this guide.\n\nHopefully, experts from security researchers to\n\nmalware analysts will make use of this guide to\n\nbetter understand FinFisher’s tools and tactics,\n\nand to protect their customers against this\n\nomnipotent security and privacy threat.\n\n\n-----\n\n## ANTI- DISASSEMBLY\n\nWhen we open a FinFisher sample in IDA Pro,\n\nthe first protection we notice in the main\n\nfunction is a simple, yet very effective, anti\ndisassembly trick.\n\nFinFisher uses a common anti-disassembly\n\ntechnique – hiding the execution flow by\n\nreplacing one unconditional jump with two\n\ncomplementary, conditional jumps. These\n\nconditional jumps both target the same\n\nlocation, so regardless of which jump is made,\n\nthe same effective code execution flow results.\n\nThe conditional jumps are then followed by\n\ngarbage bytes. These are meant to misdirect the\n\ndisassembler, which normally will not recognize\n\nthat they are dead code, and will steam on,\n\ndisassembling garbage code.\n\nWhat makes this malware special is the way\n\nin which it uses this technique. In most other\n\nmalware we’ve analyzed, it is only used a few\n\ntimes. FinFisher, however, uses this trick after\n\nevery single instruction.\n\n\nThis protection is very effective at fooling the\n\ndisassembler – many parts of the code aren’t\n\ndisassembled properly. And of course, it is\n\nimpossible to use the graph mode in IDA Pro.\n\nOur first task will be to get rid of this anti\ndisassembly protection.\n\nThe code was clearly not obfuscated manually\n\nbut with an automated tool and we can observe\n\na pattern in all the jump pairs.\n\nThere are two different types of jump pairs –\n\nnear jump with a 32-bit offset and short jump\n\nwith an 8-bit offset.\n\nThe opcodes of both conditional near jumps\n\n(with a dword as a jump offset) start with a\n\n0x0F byte; while the second bytes are equal\n\nto 0x8?, where ? in both jump instructions\n\ndiffers only by 1 bit. This is because x86 opcodes\n\nfor complementary jumps are numerically\n\nconsecutive. For example, this obfuscation\n\nscheme always pairs JE with JNE (0x0F 0x84 vs\n\n0x0F 0x85 opcodes), JP with JNP (0x0F 0x8A vs\n\n0x0F 0x8B opcodes), and so on.\n\nThese opcodes are then followed by a 32\nbit argument specifying the offset to the\n\ndestination of the jump. Since the size of\n\nboth instructions is 6 bytes, the offsets in two\n\nconsequent jumps differ exactly by 6. (Figure 1)\n\n\nFigure 1 // \u0007Screenshot showing instructions followed by two conditional near jumps every time\n\n\n-----\n\nFor example, the code below can be used to detect two of these consecutive conditional jumps:\n\n\nDeobfuscation of short jumps is based on the\n\nsame idea, only the constants are different.\n\nThe opcode of a short conditional jump equals\n\n0x7?, and is followed by one byte – the jump\n\noffset. So again, when we want to detect two\n\nconsecutive, conditional near jumps, we have to\n\nlook for opcodes: 0x7?; offset; 0x7? ± 1; offset -2.\n\nThe first opcode is followed by one byte, which\n\ndiffers by 2 in two consequent jumps (which is,\n\nagain, the size of both instructions). (Figure 2)\n\nFor example, this code can be used to detect\n\ntwo conditional short jumps:\n\n\nAfter detecting one of these conditional jump\n\npairs, we deobfuscate this code by patching the\n\nfirst conditional jump to unconditional (using\n\nthe 0xE9 opcode for the near jump pairs and\n\n0xEB for the short jump pairs) and patch the\n\nrest of the bytes with NOP instructions (0x90)\n```\n def patch_jcc32(addr):\n   PatchByte(addr, 0x90)\n   PatchByte(addr+1, 0xE9)\n   PatchWord(addr+6, 0x9090)\n   PatchDword(addr+8,\n      0x90909090)\n def patch_jcc8(addr):\n   PatchByte(addr, 0xEB)\n   PatchWord(addr+2, 0x9090)\n\n```\nIn addition to these two cases, there might be\n\nsome places where a jump pair consists of a\n\nshort and a near jump, rather than two jumps of\n\nthe same category. However, this only occurs in\n\na few cases in the FinFisher samples and can be\n\nfixed manually.\n\nWith these patches made, IDA Pro starts to\n\n“understand” the new code and is ready (or at\n\nleast almost ready) to create a graph. It may be\n\nthe case that we still need to make one more\n\nimprovement: append tails, i.e. assign the node\n\nwith the destination of the jump to the same\n\n\n-----\n\nFigure 2 // Examples of instructions followed by two conditional short jumps every time\n\ngraph where the node with the jump instruction\n\nis located. For this, we can use the IDA Python\n\nfunction append_‌func_‌tail.\n\nThe last step of overcoming the anti-disassembly\n\ntricks consists of fixing function definitions. It may\n\nstill occur that the instruction after the jumps is\n```\npush ebp, in which case IDA Pro (incorrectly)\n\n```\ntreats this as the beginning of a function and\n\ncreates a new function definition. In that case, we\n\nhave to remove the function definition, create the\n\ncorrect one and append tails again.\n\nThis is how we can get rid of FinFisher’s first\n\nlayer of protection – anti-disassembly.\n\n\n-----\n\n## FINFISHER’S  VIRTUAL MACHINE\n\nAfter a successful deobfuscation of the first\n\nlayer, we can see a clearer main function whose\n\nsole purpose is to launch a custom virtual\n\nmachine and let it interpret the bytecode with\n\nthe actual payload.\n\nAs opposed to a regular executable, an\n\nexecutable with a virtual machine inside uses\n\na set of virtualized instructions, rather than\n\ndirectly using the instructions of the processor.\n\nVirtualized instructions are executed by a\n\nvirtual processor, which has its own structure\n\nand does not translate the bytecode into a\n\nnative machine code. This virtual processor as\n\nwell as the bytecode (and virtual instructions)\n\nare defined by the programmer of the virtual\n\nmachine. (Figure 3)\n\nAs mentioned in the introduction, a well-known\n\nexample of a virtual machine is the Java Virtual\n\nMachine. But in this case, the virtual machine\n\nis inside the binary, so we are dealing with a\n\nvirtual machine used for a protection against\n\nreverse engineering. There are well-known\n\ncommercial virtual machine protectors, for\n\nexample VMProtect or Code Virtualizer.\n\nThe FinFisher spyware was compiled from\n\nsource code and the compiled binary was\n\nthen protected with a virtual machine at the\n\nFigure 3 // Bytecode interpreted by the virtual CPU\n\n\nassembly level. The protection process includes\n\ntranslating instructions of the original binary\n\ninto virtual instructions and then creating a\n\nnew binary that contains the bytecode and the\n\nvirtual CPU. Native instructions from the original\n\nbinary are lost. The protected, virtualized\n\nsample must have the same behavior as a non\nprotected sample.\n\nTo analyze a binary protected with a virtual\n\nmachine, one needs to:\n\n1. Analyze the virtual CPU.\n\n2. Write one’s own disassembler for this custom\n\nvirtual CPU\n\nand parse the bytecode.\n\n3. Optional step: compile the disassembled code\n\ninto a binary file to\n\nget rid of the virtual machine.\n\nThe first two tasks are very time-consuming,\n\nand the first one can also get quite difficult.\n\nIt includes analyzing every vm_‌handler and\n\nunderstanding how registers, memory access,\n\ncalls, etc. are translated.\n\n\n-----\n\n### Terms and definitions\n\nThere is no standard for naming particular parts\n\nof a virtual machine. Hence, we will define some\n\nterms which will be referenced throughout the\n\nwhole paper.\n\n- Virtual machine (vm) – custom, virtual CPU;\n\ncontains parts like the\n\n_vm_‌dispatcher, vm_‌start, vm_‌handlers_\n\n- _vm_‌start – the initialization part; memory_\n\nallocation and decryption routines are\n\nexecuted here\n\n- Bytecode (also known as pcode) – virtual\n\nopcodes of vm_‌instructions with their\n\narguments are stored here\n\n- _vm_‌dispatcher – fetches and decodes virtual_\n\nopcode; is basically a preparation for the\n\nexecution of one of the vm_‌handlers\n\n- _vm_‌handler – an implementation of a_\n\n_vm_‌instruction; executing one vm_‌handler_\n\nmeans executing one vm_‌instruction\n\n- Interpreter (also known as vm_‌loop) –\n\n_vm_‌dispatcher + vm_‌handlers – the virtual_\n\nCPU\n\n- Virtual opcode – an analog of the native\n\nopcode\n\n- _vm_‌context (vm_‌structure) – an internal_\n\nstructure used by the interpreter\n\n- _vi_‌params – a structure in the vm_‌context_\n\nstructure; the virtual instruction parameters,\n\nused by the vm_‌handler; it includes the\n\n_vm_‌opcode and arguments_\n\nWhen interpreting the bytecode, the virtual\n\nmachine uses a virtual stack and a single virtual\n\nregister.\n\n- _vm_‌stack – an analog of a native stack, which_\n\nis used by the virtual machine\n\n- _vm_‌register – an analog of a native register,_\n\nused by this virtual machine; further\n\nreferenced as tmp_‌REG\n\n- _vm_‌instruction – an instruction defined_\n\nby developers of vm; the body (the\n\nimplementation) of the instruction is called its\n\n_vm_‌handler_\n\n\nIn the following sections, we will describe the\n\nparts of the virtual machine in more technical\n\ndetail and explain how to analyze them.\n\nA deobfuscated graph of the main malware\n\nfunction consists of three parts – an\n\ninitialization part and two other parts which\n\nwe have named vm_‌start and interpreter\n\n_(vm_‌dispatcher + vm_‌handlers)._\n\nThe initialization part specifies a unique\n\nidentifier of what could be interpreted as a\n\nbytecode entry point, and pushes it on the stack.\n\nThen, it jumps to the vm_‌start part that is an\n\ninitialization routine for the virtual machine\n\nitself. It decrypts the bytecode and passes\n\ncontrol to the vm_‌dispatcher that loops over\n\nthe virtual instructions of the bytecode and\n\ninterprets them using the vm_‌handlers.\n\nThe vm_‌dispatcher starts with a pusha\n\ninstruction and ends with a jmp dword ptr\n```\n[eax+ecx*4] instruction (or similar), which is a\n\n```\njump to the relevant vm_‌handler.\n\n### Vm_‌start\n\nThe graph created after the deobfuscation of\n\nthe first layer is seen in Figure 4. The vm_‌start\n\npart is not so important for the analysis of the\n\ninterpreter. However, it can help us understand\n\nthe whole implementation of the vm; how it\n\nuses and handles virtual flags, virtual stack, etc.\n\nThe second part – the vm_‌dispatcher with\n\n_vm_‌handlers – is the crucial one._\n\nThe vm_‌start is called from almost every\n\nfunction, including the main function. The calling\n\nfunction always pushes a virtual instruction\n\nidentifier and then it jumps to vm_‌start. Every\n\nvirtual instruction has its own virtual identifier.\n\nIn this example, the identifier of the virtual\n\nentry point, where the execution from the main\n\nfunction starts, is 0x21CD0554. (Figure 5)\n\nIn this part, there is a lot of code for preparing\n\nthe vm_‌dispatcher – mainly for preparing\n\nthe bytecode and allocating memory for the\n\n\n-----\n\nFigure 5 //\u0007 vm_start is called from each of the 119 virtualized functions.\nThe ID of the first virtual instruction of the respective function\nis given as an argument.\n\nwhole interpreter. The most important parts of the code do the\n\n\nfollowing:\n\n1. Allocate 1MB with RWX permission for bytecode and a few\n\n\nmore variables.\n\n\n2. Allocate 0x10000 bytes RWX for local variables in the virtual\n\nmachine for the current thread – the vm_‌stack.\n\n\n3. Decrypt a piece of code using an XOR decryption routine. The\n\ndecrypted code is an aPLib unpacking routine.\n\n\nThe XOR decryption routine used in the sample is a slightly\n\nmodified version of XOR dword, key routine. Actually, it skips\n\nthe first of the six dwords and then XORs only the remaining\n\n\n5 dwords with the key. Following is the algorithm for the\n\nroutine (further referred to as XOR decryption_‌code):\n\n\n4. Call aPLib unpacking routine to unpack bytecode. After\n\nunpacking, virtual opcodes are still encrypted. (Figure 6)\n\n\nPreparing virtual opcodes (step 1, 3 and 4) is done only once –\n\nat the beginning – and is skipped in subsequent executions of\n\n_vm_‌start, when only instructions for proper handling of flags_\n\nand registers are executed.\n\n\n-----\n\nFigure 6 // \u0007All the code from the vm_start to the vm_dispatcher in grouped nodes named based on their purpose.\n\n\n## FINFISHER’S INTERPRETER\n\nThis part includes the vm_‌dispatcher with all\n\nthe vm_‌handlers (34 in FinFisher samples) and\n\nis crucial for analyzing and/or devirtualizing the\n\nvirtual machine. The interpreter executes the\n\nbytecode.\n\nThe instruction jmp dword ptr [eax+ecx*4]\n\njumps to one of the 34 vm_‌handlers. Each\n\n_vm_‌handler implements one virtual machine_\n\n\ninstruction. In order to know what every\n\n_vm_‌handler does, we first need to understand_\n\nthe vm_‌context and vm_‌dispatcher.\n\n### 1. Creating an IDA graph\n\nBefore diving into it, creating a well-structured\n\ngraph can really help understanding the\n\ninterpreter. We recommend splitting the\n\ngraph into two parts – the vm_‌start and the\n\n_vm_‌dispatcher, i.e. to define a beginning of a_\n\nfunction at the vm_‌dispatcher’s first instruction.\n\nWhat is still missing is the actual vm_‌handlers\n\nreferenced by the vm_‌dispatcher. In order to\n\nconnect these handlers with the graph of the\n\n\n-----\n\n_vm_‌dispatcher, the following functions can be_\n\nused:\n```\nAddCodeXref(addr_‌of_‌jmp_‌instr, \n\n```\nvm_‌handler, XREF_‌USER|fl_‌JN)\n\nadding references from the last vm_‌dispatcher\n\ninstruction to the beginnings of the\n\n_vm_‌handlers_\n```\nAppendFchunk\n\n```\nappending tails again\n\nAfter appending every vm_‌handler to the\n\ndispatcher function, the resulting graph should\n\nlook like (Figure 7)\n\n\n### 2. Vm_‌dispatcher\n\nThis part is responsible for fetching and\n\ndecoding the bytecode. It performs the\n\nfollowing steps:\n\n- Executes pusha and pusf instructions to\n\nprepare virtual registers and virtual flags for\n\nfurther execution of a virtual instruction.\n\n- Retrieves the base address of the image and\n\naddress of vm_‌stack\n\n- Reads 24 bytes of bytecode specifying the\n\nnext vm_‌instruction\n\nand its arguments\n\n\nFigure 7 // Graph of the vm_dispatcher with all 34 vm_handlers.\n\n\n-----\n\n- Decrypts the bytecode with the previously\n\ndescribed XOR decryption routine\n\n- Adds the image base to the bytecode\n\nargument in case the argument is a global\n\nvariable\n\n- Retrieves the virtual opcode (number 0-33)\n\nfrom the decrypted bytecode\n\n- Jumps to the corresponding vm_‌handler\n\nwhich interprets the virtual opcode\n\nAfter the vm_‌handler for an instruction has\n\nexecuted, the same sequence of steps is\n\nrepeated for the next one, starting from the\n\n_vm_‌dispatcher’s first instruction._\n\nIn the case of the vm_‌call handler, the control\n\nis passed to the vm_‌start part instead (except\n\nFigure 8 // Screenshot of one of the vm handlers\n\n\nfor instances when a non-virtualized function\n\nfollows).\n\n### 3. Vm_‌context\n\nIn this part, we will describe the vm_‌context\n\n– a structure used by the virtual machine,\n\ncontaining all the information necessary\n\nfor executing the vm_‌dispatcher and each\n\n_vm_‌handler._\n\nWhen looking at the code of both the\n\n_vm_‌dispatcher and the vm_‌handlers in greater_\n\ndetail, we can notice there are a lot of data\n\noperation instructions, referring to ebx+offset,\n\nwhere offset is a number from 0x00 to 0x50.\n\nIn Figure 8, we can see what the main part of\n\n_vm_‌handler 0x05 in one FinFisher sample looks_\n\nlike. (Figure 8)\n\n\n-----\n\nThe ebx register points to a structure we named\n\n_vm_‌context. We must understand how this_\n\nstructure is used – what the members are, what\n\nthey mean, and how they are used. When solving\n\nthis puzzle for the first time, a bit of guessing\n\nis needed as to how the vm_‌context and its\n\nmembers are used.\n\nFor example, let’s have a look at the sequence of\n\ninstructions at the end of the vm_‌dispatcher:\n```\n movzx ecx, byte ptr [ebx+0x3C]\n // opcode for vm_handler\n jmp dword ptr [eax+ecx*4] \n // jumping to one of the 34 vm_\n handlers\n\n```\nSince we know that the last instruction is a\n\njump to a vm_‌handler, we can conclude that\n\necx contains a virtual opcode and thus the\n\n0x3C member of a vm_‌struct refers to a virtual\n\nopcode number.\n\nLet’s make one more educated guess. At the end\n\nof almost every vm_‌handler,\n\n\nthere is the following instruction:\n```\nadd dword ptr [ebx], 0x18.\n\n```\nThis same member of the vm_‌context was\n\nalso used earlier in the vm_‌dispatcher’s\n\ncode – just before jumping to a vm_‌handler.\n\nThe vm_‌dispatcher copies 24 bytes from\n\nthe structure member to a different location\n\n([ebx+38h]) and decrypts it with the XOR\n\ndecryption routine to obtain a part of the actual\n\nbytecode.\n\nHence, we can start thinking of the first\n\nmember of the vm_‌context ([ebx+0h]) as a\n\n_vm_‌instruction_‌pointer, and of the decrypted_\n\nlocation (from [ebx+38h] to [ebx+50h]) as an\n\nID of a virtual instruction, its virtual opcode and\n\narguments. Together, we will call the structure\n\n_vi_‌params._\n\nFollowing the steps described above, and using\n\na debugger to see what values are stored in the\n\nrespective structure members, we can figure\n\nout all the members of the vm_‌context.\n\nAfter the analysis, we can rebuild both\n\nFinFisher’s vm_‌context and vi_‌params\n\nstructure:\n\n```\nstruct vm_context {\nDWORD vm_instruct_ptr; // instruction pointer to the bytecode\nDWORD vm_stack; // address of the vm_stack\nDWORD tmp_REG; // used as a “register” in the virtual machine\nDWORD vm_dispatcher_loop; // address of the vm_dispatcher\nDWORD cleanAndVMDispatchFn; // address of the function which pops values and jumps\n\n```\nto the vm_dispatcher skipping the first few instructions from it\n```\nDWORD cleanUpDynamicCodeFn; // address of the function which cleans vm_instr_ptr and\ncalls cleanAndVMDispatchFn\nDWORD jmpLoc1; // address of jump location\nDWORD jmpLoc2; // address of next vm_opcode – just executing next vm_instruction\nDWORD Bytecode_start; // address of the start of the bytecode in data section\nDWORD DispatchEBP;\nDWORD ImageBase; // Image base address\n\n```\nDWORD ESP0_flags; // top of the native stack (there are saved flags of the vm_code)\n\nDWORD ESP1_flags; // same as previous\n```\nDWORD LoadVOpcodesSectionFn;\nvi_params bytecode; // everything necessary for executing vm_handler, see below\nDWORD limitForTopOfStack; // top limit for the stack\n};\n\n```\n\n-----\n\n### 4. \u0007Virtual instruction implementations – vm_‌handlers\n\nEach vm_‌handler handles one virtual opcode\n\n– since we have 34 vm_‌handlers, there\n\nare at most 34 virtual opcodes. Executing\n\none vm_‌handler means executing one\n\n_vm_‌instruction, so in order to reveal what a_\n\n_vm_‌instruction does, we need to analyze the_\n\ncorresponding vm_‌handler.\n\nAfter reconstructing the vm_‌context and\n\nnaming all the offsets from ebx, the previously\n\nshown vm_‌handler changes to a much more\n\nreadable form, as seen in Figure 9.\n\n\nAt the end of this function, we notice a\n\nsequence of instructions, starting with the\n\nvm_‌instruction_‌pointer, being incremented\n\nby 24 – the size of each vm_‌instruction’s\n\nvi_‌params structure. Since this sequence\n\nis repeated at the end of almost every\n\nvm_‌handler, we conclude it is a standard\n\nfunction epilogue and the actual body of the\n\nvm_‌handler can be written as simply as:\n```\nmov [tmp_‌REG], Arg0\n\n```\nSo, there we go – we have just analyzed the\n\nfirst instruction of the virtual machine. :-)\n\nFigure 9 // The previous\n_vm_handler after_\ninserting the\n_vm_context structure_\n\n\n-----\n\nTo illustrate how the analyzed instruction works\n\nwhen executed, let’s consider the vi_‌params\n\nstructure filled as follows:\n```\n struct vi_params {\n DWORD ID_of_virt_instr = doesn’t\n matter;\n DWORD OpCode = 0x0C;\n DWORD Arg0 = 0x42;\n DWORD Arg4 = 0;\n DWORD Arg8 = 0;\n DWORD ArgC = 0;\n };\n\n```\nFrom what was stated above, we can see that\n\nthe following instruction will be executed:\n```\nmov [tmp_‌REG], 0x42\n\n```\nFigure 10 // Screenshot of a JNP_handler\n\n\nAt this point, we should understand what\n\none of the vm_‌instructions does. The\n\nsteps we followed should serve as a decent\n\ndemonstration of how the entire interpreter\n\nworks.\n\nHowever, there are some vm_‌handlers that are\n\nharder to analyze. This vm’s conditional jumps\n\nare tricky to understand because of the way\n\nthey translate flags.\n\nAs mentioned before, the vm_‌dispatcher starts\n\nwith pushing native EFLAGS (of vm_‌code) to\n\nthe top of the native stack. Therefore, when the\n\nhandler for a respective jump is deciding whether\n\nto jump or not, it looks at EFLAGS at the native\n\nstack and implements its own jump method.\n\nFigure 10 illustrates how the virtual JNP handler is\n\nimplemented by checking the parity flag.\n\n(Figure 10)\n\n\n-----\n\nFor other virtual conditional jumps, it may be necessary to check several flags – for example, the jump\n\nresult of the virtualized JBE depends on the values of both CF and ZF – but the principle stays the\n\nsame.\n\nAfter analyzing all 34 vm_‌handlers in FinFisher’s virtual machine, we can describe its virtual\n\ninstructions as follows:\n\nFigure 11 // vm_table with all 34 vm_handlers accessed\n\n\nPlease note that the keyword “tmp_‌REG”\n\nrefers to a virtual register used by the virtual\n\nmachine –temporary register in the vm_‌context\n\nstructure, while “reg” refers to a native register,\n\ne.g. eax.\n\nLet’s have a look at the analyzed instructions\n\nof the virtual machine. For example,\n\n_case_‌3_‌vm_‌jcc is a general jump handler that_\n\ncan execute any native jump, either conditional\n\nor unconditional.\n\nApparently, this virtual machine does not\n\nvirtualize every native instruction – that’s where\n\ninstructions in cases 4 and 6 come in handy.\n\n\nThese two vm_‌handlers are implemented to\n\nexecute native code directly – all they do is to\n\nread the opcode of a native instruction given as\n\nan argument and execute the instruction.\n\nOne more thing to note is that the vm_‌registers\n\nare always at the top of the native stack, while\n\nthe identifier of the register to be used is stored\n\nin the last byte of arg0 of the virtual instruction.\n\nThe following code can be used to access the\n\nrespective virtual register:\n\n\n-----\n\n### 5. Writing your own disassembler\n\nAfter we have correctly analyzed all the\n\n_vm_‌instructions, there is still one step to_\n\nbe done before we can start the analysis\n\nof the sample – we need to write our own\n\ndisassembler for the bytecode (parsing it\n\nmanually would be problematic due to its size).\n\nBy putting in the effort and writing a more\n\nrobust disassembler we can save ourselves\n\nsome trouble when FinFisher’s virtual machine\n\nis changed and updated.\n\nLet’s start with the vm_‌handler 0x0C, which\n\nexecutes the following instruction:\n```\nmov [tmp_‌REG], reg\n\n```\nThis instruction takes exactly one argument\n\n– the identifier of a native register to be used\n\nas reg. This identifier must be mapped into\n\na native register name, for instance using a\n```\nresolve_‌reg function as described above.\n\n```\nThe following code can be used to dissasemble\n\nthis vm_‌handler:\n```\n def vm_0C(state, vi_params):\n   global instr\n   reg_pos = 7 – (vi_arams[arg0]\n   & 0x000000FF)\n   tmpinstr = “mov [tmp_REG],\n   %s” % resolve_reg(reg_pos)\n   instr.append(tmpinstr)\n   return\n\n```\nAgain, vm_‌handlers for jumps are harder\n\nto understand. In case of jumps, members\n\n_vm_‌context.vi_‌params.Arg0 and vm_‌context._\n\n_vi_‌params.Arg1 store the offset by which to_\n\n\njump. This “jump offset” is actually an offset in\n\nthe bytecode. When parsing jumps, we need to\n\nput a marker to the location to which it jumps.\n\nFor example, this code can be used:\n```\n def computeLoc1(pos, vi_params):\n   global instr\n   jmp_offset = (vi_params[arg0]\n & 0x00FFFFFF) + (vi_params[arg1]\n & 0xFF000000)\n   if jmp_offset < 0x7FFFFFFF:\n      jmp_offset /= 0x18 # their\n      increment by 0x18 is my\n      increment by 1\n   else:\n      jmp_offset = int((      0x100000000 + jmp_offset)\n      / 0x18)\n   return pos+jmp_offset\n\n```\nFinally, there is a vm_‌handler responsible for\n\nexecuting native instructions from arguments,\n\nwhich needs special treatment. For this, we\n\nhave to use a disassembler for native x86\n\ninstructions – for example, the open source tool\n\nDistorm.\n\nThe length of an instruction is stored in\n\nvm_‌context.vi_‌params.OpCode & 0x0000FF00.\n\nThe opcode of the native instruction that\n\nwill be executed is stored in the arguments.\n\nThe following code can be used to parse the\n\nvm_‌handler that executes native code:\n\n\n-----\n\nUp to this point, we have created Python\n\nfunctions to disassemble each vm_‌handler. All\n\nof these, combined with the code responsible\n\nfor marking jump locations, finding the ID of\n\na virtual instruction after the call and a few\n\nothers, are necessary for writing your own\n\ndisassembler.\n\nAfterwards, we can run the finished\n\ndisassembler on the bytecode.\n\nFigure 12 // Part of the unpacked and decrypted FinFisher bytecode\n\nFor example, from the part of the bytecode\n\nshown in Figure 12, we may get the following\n\noutput:\n\n\n-----\n\n### 6. \u0007Understanding the implementation of this virtual machine\n\nAfter we have analyzed all the virtual handlers\n\nand constructed a custom disassembler, we can\n\nhave one more look at the virtual instructions to\n\nget an overall idea of how they were created.\n\nFirst, we must understand that the virtualization\n\nprotection was implemented at the assembly\n\nlevel. The authors translated native instructions\n\ninto their own, somewhat complicated\n\ninstructions, which are to be executed by a\n\ncustom virtual CPU. To achieve this, a temporary\n\n“register” (tmp_‌REG) is used.\n\nWe can look at some examples to see how\n\nthis translation works. For example, the virtual\n\ninstruction from the previous example –\n```\nmov tmp_‌REG, EAX\npush tmp_‌REG\n\n```\n– was translated from the original native\n\ninstruction push eax. When virtualized, a\n\ntemporary register was used in an intermediate\n\nstep to change the instruction into something\n\nmore complicated.\n\nLet’s consider another example:\n\n```\nmov tmp_REG, 0\nadd tmp_REG, EBP\nadd tmp_REG, 0x10\nmov tmp_REG, [tmp_REG]\npush tmp_REG\n\n```\n\nThe native instructions that were translated into\n\nthese virtualized instructions were the following\n\n(with reg being one of the native registers):\n```\nmov reg, [ebp+0x10]\npush reg\n\n```\nThis is, however, not the only way to virtualize\n\na set of instructions. There are other virtual\n\nmachine protectors with other approaches. For\n\ninstance, one of the commercial vm protectors\n\ntranslates each math operation instruction\n\n\ninto NOR logic, with a number of temporary\n\nregisters being used instead of one.\n\nConversely, FinFisher’s virtual machine did not\n\ngo as far as to cover all the native instructions.\n\nWhile many of them can be virtualized, some\n\ncan’t – math instructions, such as add, imul and\n```\ndiv, being some examples. If these instructions\n\n```\nappear in the original binary, the vm_‌handler\n\nresponsible for executing native instructions is\n\ncalled to handle them in the protected binary.\n\nThe only change is that EFLAGS and native\n\nregisters are popped from the native stack just\n\nbefore the native instruction is executed, and\n\npushed back after it is executed. This is how the\n\nvirtualization of every native instruction was\n\navoided.\n\nA significant drawback of protecting binaries\n\nwith a virtual machine is the performance\n\nimpact. In the caseof FinFisher’s virtual\n\nmachine, we estimate it to be more than one\n\nhundred times slower than native code, based\n\non the number of instructions that have to be\n\nexecuted to handle every single vm_‌instruction\n\n(vm_‌dispatcher + vm_‌handler).\n\nTherefore, it makes sense to protect only\n\nselected parts of the binary– and this is also the\n\ncase in the FinFisher samples we analyzed.\n\nMoreover, as mentioned before, some of\n\nthe virtual machine handlers can call native\n\nfunctions directly. As a result, the users of the\n\nvirtual machine protection (i.e. the authors\n\nof FinFisher) can look at the functions at the\n\nassembly level and mark which of them are\n\nto be protected by the virtual machine. For\n\nthose that are marked, their instructions will be\n\nvirtualized, for those that are not, the original\n\nfunctions will be called by the respective virtual\n\nhandler. Thus, the execution might be less time\nconsuming while the most interesting parts of\n\nthe binary stay protected. (Figure 13)\n\n\n-----\n\nFigure 13 // Scheme representing FinFisher’s entire vm protection and how the execution can jump out of the vm\n\n\n### 7. \u0007Automating the disassembly process for more FinFisher samples\n\nIn addition to the length of the bytecode our\n\nparser has to process, we have to keep in mind\n\nthat there is some randomization across various\n\nFinFisher samples. Although the same virtual\n\nmachine has been used for the protection, the\n\nmapping between the virtual opcodes and the\n\n_vm_‌handlers is not always constant. They can_\n\nbe (and are) paired randomly and differently\n\nfor each of the FinFisher samples we analyzed.\n\nIt means that if the vm_‌handler for the 0x5\n\nvirtual opcode in this sample handles the mov\n```\n[tmp_‌REG], arg0 instruction, it may be\n\n```\nassigned a different virtual opcode in another\n\nprotected sample.\n\nTo address this issue, we can use a signature\n\nfor each of the analyzed vm_‌handlers. The\n\nIDA Python script in Appendix A can be applied\n\nafter we have generated a graph as shown in\n\nFigure 7 (it is particularly important to have\n\nthe jz/jnz jump obfuscation eliminated – as\n\ndescribed in the first section of this guide) to\n\nname the handlers based on their signatures.\n\n(With a small modification, the script can also\n\n\nbe used to recreate the signatures in case the\n\n_vm_‌handlers are changed in a future FinFisher_\n\nupdate.)\n\nAs mentioned above, the first vm_‌handler\n\nin the FinFisher sample you analyze may be\n\ndifferent than JL, as in the example FinFisher\n\nsample, but the script will identify all of the\n\n_vm_‌handlers correctly._\n\n### 8. \u0007Compiling disassembled code without the VM\n\nAfter disassembly and after a few\n\nmodifications, it is possible to compile the\n\ncode. We will treat virtual instructions as native\n\ninstructions. As a result, we will get a pure\n\nbinary without the protection.\n\nMost of the vm_‌instructions can be compiled\n\nimmediately using copy-paste, since the output\n\nof our disassembler mostly consists of native\nlooking instructions. But some cases need\n\nspecial treatment:\n\n- tmp_‌REG – since we defined tmp_‌REG as\n\na global variable, we need to make code\n\nadjustments for cases when an address\n\nstored in it is being dereferenced. (Since\n\n\n-----\n\ndereferencing an address which is in a global\n\nvariable is not possible in the x86 instruction\n\nset.) For example, the vm contains the virtual\n\ninstruction mov tmp_‌REG, [tmp_‌REG] which\n\nneeds to be rewritten as follows:\n```\n push eax\n mov eax, tmp_REG\n mov eax, [eax]\n mov tmp_REG, eax\n pop eax\n\n```\n- Flags – Virtual instructions do not change\n\nthe flags, but native math instructions do.\n\nTherefore, we need to make sure that virtual\n\nmath instruction won’t change flags in the\n\ndevirtualized binary either, which means\n\nwe have to save flags before executing\n\nthis instruction and restore them after the\n\nexecution.\n\n- Jumps and calls – we have to put a marker to\n\nthe destination virtual instruction (jumps) or\n\nfunction (calls).\n\n\n\n- API function calls – in most cases, API\n\nfunctions are loaded dynamically, whereas\n\nin others they are referenced from the IAT of\n\nthe binary, so these cases need to be handled\n\naccordingly.\n\n- Global variables, native code – Some global\n\nvariables need to be kept in the devirtualized\n\nbinary. Also in the FinFisher dropper, there is a\n\nfunction for switching to x64 from x86 that is\n\nexecuted natively (actually it is done only with\n\nthe retf instruction). All these must be kept\n\nin the code when compiling.\n\nDepending on the output of your disassembler,\n\nyou may still need to do a few more\n\nmodifications to get pure native instructions\n\nthat can be compiled. Then, you can compile the\n\ncode with your favorite assembly-compiler into\n\na binary without the VM.\n\n\n-----\n\n## CONCLUSION\n\nIn this guide, we have described how FinFisher\n\nuses two elaborate techniques to protect\n\nits main payload. The primary intention of\n\nthis protection is not to avoid AV detection,\n\nbut to cover the configuration files and new\n\ntechniques implemented in the spyware by\n\nhindering analysis by reverse engineers. As\n\nno other detailed analysis of the obfuscated\n\nFinFisher spyware has been published to date,\n\nit seems the developers of these protection\n\nmechanisms have been successful.\n\nWe have shown how we can overcome the\n\nanti-disassembly layer automatically, and how\n\nthe virtual machine can be efficiently analyzed.\n\nWe hope this guide can help reverse engineers\n\nanalyze vm-protected FinFisher samples, as\n\nwell to better understand other virtual machine\n\nprotectors in general.\n\n\n-----\n\n### Appendix A\n\n IDA Python script for naming  FinFisher vm_‌handlers\n\nThe script is also available on ESET’s GitHub repository:\n\n_[https://github.com/eset/malware-research/blob/master/finfisher/ida_finfisher_vm.py](https://github.com/eset/malware-research/blob/master/finfisher/ida_finfisher_vm.py)_\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        },
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.welivesecurity.com/wp-content/uploads/2018/01/WP-FinFisher.pdf"
    ],
    "report_names": [
        "WP-FinFisher.pdf"
    ],
    "threat_actors": [
        {
            "id": "08c8f238-1df5-4e75-b4d8-276ebead502d",
            "created_at": "2023-01-06T13:46:39.344081Z",
            "updated_at": "2025-03-27T02:00:03.056208Z",
            "deleted_at": null,
            "main_name": "Copy-Paste",
            "aliases": [],
            "source_name": "MISPGALAXY:Copy-Paste",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716497,
    "ts_updated_at": 1743041614,
    "ts_creation_date": 1516815147,
    "ts_modification_date": 1516815150,
    "files": {
        "pdf": "https://archive.orkl.eu/80df30f965d4fe41eee6fba99905a75eb9a1c1d9.pdf",
        "text": "https://archive.orkl.eu/80df30f965d4fe41eee6fba99905a75eb9a1c1d9.txt",
        "img": "https://archive.orkl.eu/80df30f965d4fe41eee6fba99905a75eb9a1c1d9.jpg"
    }
}