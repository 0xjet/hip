{
    "id": "d1facd3b-9618-4816-a8ab-54826770ddc7",
    "created_at": "2023-01-12T15:06:33.562598Z",
    "updated_at": "2025-03-27T02:17:02.403161Z",
    "deleted_at": null,
    "sha1_hash": "220aa8f9497dd44a115facb75823a14a3ebf2924",
    "title": "2022-05-11 - BPFDoor - An Evasive Linux Backdoor Technical Analysis",
    "authors": "",
    "file_creation_date": "2022-05-28T23:25:49Z",
    "file_modification_date": "2022-05-28T23:25:49Z",
    "file_size": 2096108,
    "plain_text": "# BPFDoor - An Evasive Linux Backdoor Technical Analysis\n\n**[sandflysecurity.com/blog/bpfdoor-an-evasive-linux-backdoor-technical-analysis/](https://www.sandflysecurity.com/blog/bpfdoor-an-evasive-linux-backdoor-technical-analysis/)**\n\n[Malware](https://www.sandflysecurity.com/blog/tag/malware/) [Linux Forensics](https://www.sandflysecurity.com/blog/tag/linux-forensics/)\n\n**Date**\nMay 11, 2022\n\n**Author**\nThe Sandfly Security Team\n\n\nMay 11, 2022\n\n\nRecently Kevin Beaumont revealed a new evasive backdoor targeting Linux associated with\n[the Chinese Red Menshen threat actors. In his article he reveals that this backdoor has been](https://doublepulsar.com/bpfdoor-an-active-chinese-global-surveillance-tool-54b078f1a896)\noperating globally for many years with potentially thousands of instances already deployed.\n\n\n-----\n\nThe backdoor has also been noted by investigators at PricewaterhouseCoopers in their\nlatest [Cyber Threat Intelligence Retrospect Report (pg. 36).](https://www.pwc.com/gx/en/issues/cybersecurity/cyber-threat-intelligence/cyber-year-in-retrospect/yir-cyber-threats-report-download.pdf)\n\n[The source for this backdoor was posted by anonymously and Sandfly researchers are able](https://pastebin.com/kmmJuuQP)\nto provide the following in-depth technical analysis. At a high level, it does the following:\n\nGoes memory resident and deploys anti-forensics and evasion to hide.\n\nLoads a Berkeley Packet Filter (BPF) sniffer allowing it to efficiently watch traffic and\nwork in front of any locally running firewalls to see packets (hence BPFDoor).\n\nUpon receiving a special packet, it will modify the local firewall to allow the attacker IP\naddress to access resources such as a spawned shell or connect back bindshell.\n\nOperations are hidden with process masquerading to avoid detection.\n\nWhile the malware takes steps to evade casual observation, it is easily seen if you know\nwhere and how to look. We'll review the above and provide detection tips.\n\n## Source Build Size and Compatibility\n\nThe BPFDoor source is small, focused and well written. While the sample we reviewed was\nLinux specific, with some small changes it could easily be ported to other platforms (a Solaris\nbinary reportedly exists). BPF is widely available across operating systems and the core\nshell functions would likely work across platforms with little modification.\n\nThe dynamically linked binary is small at about 35K on Ubuntu:\n```\n-rwxr-xr-x 1 root root  34952 May 11 00:03 bpfdoor\n\n```\nStatically linked it would grow to about 1MB, but the dynamically linked version would likely\nwork on most modern Linux distributions. Cross compiling for various CPUs is also possible\nso this implant would likely work on embedded Linux devices as well.\n\n## Implant Operation Steps\n\nThe binary itself just needs to be downloaded onto the victim and run. It doesn't matter how\nor where it gets to the host as it takes care of moving itself to a suitable area once run to\nremain resident. However, the binary does need root permissions to run.\n\nWhen run, the binary has an initialization sequence as follows:\n\n1) Copy binary to the /dev/shm directory (Linux ramdisk).\n\n2) Rename and run itself as /dev/shm/kdmtmpflush.\n\n\n-----\n\n3) Fork itself and run fork with --init flag which tells itself to execute secondary clean-up\noperations and go resident.\n\n[4) The forked version timestomps the binary file /dev/shm/kdmtmpflush and initiates packet](https://attack.mitre.org/techniques/T1070/006/)\ncapture loop.\n\n5) The forked version creates a dropper at /var/run/haldrund.pid to mark it is resident and\nprevent multiple starts.\n\n6) The original execution process deletes the timestomped /dev/shm/kdmtmpflush and exits.\n\n7) The forked version remains resident and monitors traffic for magic packet to initiate\nattacker operations such as a bindshell.\n\n## Persistence\n\nThe implant itself has no persistence mechanisms as it is highly focused on a single task.\nPersistence would need to be initiated by the attacker in some other way such as rc or init\nscripts or scheduled tasks such as with crontab. The initial report referenced above indicates\nthat persistence scripts have been found.\n\nThe implant uses /dev/shm on Linux. This is a ramdisk and is cleared out on every reboot.\nFor persistence reasons, the implant will need to be somewhere else on the host to survive\nreboots or be inserted again remotely.\n\nIncident response teams that find this implant operating should assume the real binary is\n**somewhere else on the file system. Check all system boot scripts for unusual references**\nto binaries or paths.\n\n## Timestomping\n\nThe binary copies itself to /dev/shm/kdmtmpflush which is only in RAM and clears out every\nreboot. The interesting part of the implant is that it sets a bogus time to timestomp the binary\nbefore deletion. The relevant code is below:\n```\ntv[0].tv_sec = 1225394236;\ntv[0].tv_usec = 0;\ntv[1].tv_sec = 1225394236;\ntv[1].tv_usec = 0;\nutimes(file, tv);\n\n```\nThe date is set to 1225394236 seconds from epoch which translates to: Thursday, October\n**30, 2008 7:17:16 PM (GMT)**\n\n\n-----\n\nWe did some searches to see if this date has any significance but didn t see anything\nobvious. It could have some significance to the author or could be random.\n\nThe interesting part about this is the timestomp happens by the forked process before the\nmain process tries to delete the binary. We assume this is a failsafe mechanism. If the\nimplant should fail to load and not delete itself from /dev/shm/kdmtmpflush then the file left\nbehind will have an innocuous looking time on it that masks when it was created. It would\nalso make incident response harder if you are looking for recently created files (this one\nlooks like it was created 14 years ago).\n\n## PID Dropper\n\nThe implant creates a zero byte PID file at /var/run/haldrund.pid. This file is deleted if the\nimplant terminates normally, but if there is a problem such as a hard shutdown or crash, the\nfile may be left behind. The implant will not start if this file is present as it is used to mark that\nit may already be running.\n\n## Binary Deletion\n\nAfter the binary starts, it deletes itself making recovery harder. However, recovering a\n[deleted process binary on Linux is trivial once it is running (see our article on how to do it).](https://www.sandflysecurity.com/blog/how-to-recover-a-deleted-binary-from-active-linux-malware/)\nBut the main thing deletion does is allow the binary to avoid detection by malware scanners\nthat rely on file scanning. The binary is simply not on the disk to be scanned and if the main\nbinary is hidden/encrypted on the device for persistence it would be very hard to find.\n\n\n-----\n\nHowever on Linux a deleted process binary is extremely suspicious. If you search for any\nkind of process with a deleted binary then it stands out:\n```\nls -alR /proc/*/exe 2> /dev/null | grep deleted\n\n```\nIf you are using Sandfly to protect your Linux systems you will have received multiple\nautomated alerts about a suspicious binary running. The red arrow shows that the process is\nmasquerading as something else. We'll talk about that in a bit.\n\n\n-----\n\nIn general, any process deleting its binary after running is going to be malicious.\n\n## Masquerading\n\nThe binary masquerades its name by selecting from one of 10 names randomly:\n```\n/sbin/udevd -d\n/sbin/mingetty /dev/tty7\n/usr/sbin/console-kit-daemon --no-daemon\nhald-addon-acpi: listening on acpi kernel interface /proc/acpi/event\ndbus-daemon --system\nhald-runner\npickup -l -t fifo -u\navahi-daemon: chroot helper\n/sbin/auditd -n\n/usr/lib/systemd/systemd-journald\n\n```\nThe names are made to look like common Linux system daemons. The implant overwrites\nthe argv[0] value which is used by the Linux /proc filesystem to determine the command line\nand command name to show for each process. By doing this, when you run commands like\n\n\n-----\n\n_ps you will see the bogus name. Below you can see the process running under the_\nmasquerade name dbus-daemon --system.\n\nThis masquerading tactic has been around for a while. While it works, the real process name\nis still visible inside Sandfly with the masqueraded versions also showing. This kind of\ndifference in real process name vs. the command line values indicates also there is a\nproblem.\n\n\n-----\n\nIf you find a suspicious process ID (PID), you can quickly investigate what the real name\nmay be by going to /proc/<PID> and doing a simple ls command:\n```\ncd /proc/<PID>\nls -al\n\n```\nYou will see the exe link which will be pointing to the real binary location which can confirm at\nleast what the binary was called when started. Also you'll see the timestamp on the file is\nwhen the binary was started which can help bracket the time of intrusion. Linux also helpfully\nlabels the binary as \"(deleted)\"\n\n\n-----\n\n## Environment Wipe\n\nThe last thing the implant does before going fully resident is wipe out the process\nenvironment. When you start a process on Linux it stores a lot of useful forensic information\nin /proc/<PID>/environ. This area can often reveal useful information such as SSH\nconnections that started the process, usernames, etc.\n\n\n-----\n\nThe environment wipe the implant uses is interesting because it wipes out envp[] (third\nargument to main() which is where environment variables are passed in as array in Linux).\nSee below for explanation of how to use argv iteration to get environment variables:\n\n[argv prints out environment variables](https://stackoverflow.com/questions/31045329/argv-prints-out-environment-variables)\n\nThis is a pretty good mechanism and ensures there are no environment variables left on the\nrunning process. Although it won't work in this case, we have an article on how to do live\nprocess environment forensics here:\n\n[Using Linux Process Environment Variables for Live Forensics](https://www.sandflysecurity.com/blog/using-linux-process-environment-variables-for-live-forensics/)\n\nThe end result is that the implant leaves the environment completely blank which can\nhappen under some normal circumstances, but usually not. Below we see the fake dbus\nimplant and the real dbus on the same box. The real dbus environment has some data with\nit. A completely empty environment is unusual for normal processes.\n\n\n-----\n\n## BPF Filter Activation and Analysis\n\nOnce the implant has done its anti-forensics and evasion housekeeping, it goes into the\npacket capture loop. The packet capture function loads a BPF filter (hence the name). BPF is\na highly efficient way to filter packets coming into a system which massively reduces CPU\nload by preventing all packets from needing to be analyzed by the receiver. It effectively\noperates as a very efficient pre-filter and only passes likely valid packets for review to the\nimplant.\n\nWith BPFDoor they have taken a BPF filter and converted it to BPF bytecode. This keeps the\nimplant small and less reliant on system libraries that may need to parse a human readable\nBPF filter, and allows for filters that the normal expression syntax cannot represent.\n\nWe have reverse engineered the bytecode below to show you what it is doing. It does\nbasically two things:\n\nGrabs either an ICMP (ping), UDP or TCP packet.\n\nSees if it has magic data value. If not then reject.\n\nThe commented assembly and pseudocode is here:\n\n\n-----\n\n```\nl0:   ldh [12]        // A halfword from offset 12 [Ethernet: EtherType]\nl1:   jeq #0x800, l2, l29   // if EtherType==IPv4 goto l2; else goto l29\nl2:   ldb [23]        // A = byte from packet offset 23 [IPv4: Protocol] \n(data begins at offset 14 of ethernet packet; so this is offset 9 in the IPv4 packet)\nl3:   jeq #0x11, l4, l9    // if Protocol==UDP goto l4, else goto l9\nl4:   ldh [20]        // A = IPv4 flags+fragment offset\nl5:   jset #0x1fff, l29, l6  // ...if fragmentation offset != 0, goto l29\nl6:   ldxb 4*([14]&0xf)    // X = IPv4 Header Length\nl7:   ldh [x+22]       // A = halfword from offset X+22... first halfword of\nUDP datagram data\nl8:   jeq #0x7255, l28, l29  // if A==0x7255 goto l28, else goto l29\nl9:   jeq #0x1, l10, l17   // if Protocol==ICMP goto l10, else goto l17 (jumped\nto from l3; register contains IP protocol)\nl10:  ldh [20]        // A = IPv4 flags+fragment offset\nl11:  jset #0x1fff, l29, l12 // ...if fragmentation offset != 0, goto l29\nl12:  ldxb 4*([14]&0xf)    // X = IPv4 Header Length\nl13:  ldh [x+22]       // A = halfword from offset X+22... first halfword of\nICMP data\nl14:  jeq #0x7255, l15, l29  // if A==0x7255 goto l15, else goto l29\nl15:  ldb [x+14]       // A = byte from offset X+14... ICMP Type\nl16:  jeq #0x8, l28, l29   // if ICMP Type == Echo Request (ping) goto l28, else\ngoto l29\nl17:  jeq #0x6, l18, l29   // if Protocol==TCP goto l18, else goto l29 (jumped\nto from l3; register contains IP protocol)\nl18:  ldh [20]        // A = IPv4 flags+fragment offset\nl19:  jset #0x1fff, l29, l20 // ...if fragmentation offset != 0, goto l29\nl20:  ldxb 4*([14]&0xf)    // X = IPv4 Header Length\nl21:  ldb [x+26]       // A = byte from offset X+26... Assume no IPv4\noptions so X=20; packet offset 46 = TCP segment offset 12\nl22:  and #0xf0        // A = A & 0xF0 (high nibble of TCP offset 12 = Data\noffset = TCP header size in 32-bit words)\nl23:  rsh #2         // A = A >> 2 (this has the effect of multiplying the\nhigh nibble by four, e.g A>>4 then A<<2). A now contains number of bytes in the TCP\nheader\nl24:  add x          // A = A + X. Adding IPv4 header length + TCP header\nlength.\nl25:  tax           // X = A\nl26:  ldh [x+14]       // A = halfword from packet offset X+14 (14 is\nethernet header, x is IPv4+TCP header, so this offset is first TCP payload byte)\nl27:  jeq #0x5293, l28, l29  // if A==0x5293 goto l28, else goto l29\nl28:  ret #0xffff       // return match\nl29:  ret #0         // return doesn't-match\nPseudocode. \"return false\" means packet doesn't match; \"return true\" means packet\nmatches.\nif (EtherType == IPv4) {\n  if (Packet is an additional piece of a fragmented packet)\n  {\n    return false;\n  }\n  else\n  {\n    if (Protocol == UDP && data[0:2] == 0x7255)\n    {\n\n```\n\n-----\n\n```\n      return true;\n    }\n    else if (Protocol == ICMP && data[0:2] == 0x7255 && ICMP Type == Echo\nRequest)\n    {\n      return true;\n    }\n    else if (Protocol == TCP && data[0:2] == 0x5293)\n    {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n}\nelse\n{\n  return false;\n}\n\n```\nTo get past the filter you will need to send the right data in the packet as shown above.\n\nThe filter rejects most traffic from entering the main packet decoding loop so the implant will\nrun with very little CPU signature. Packets that make it through the BPF check are quickly\nchecked for a valid password before any further operations take place.\n\n## Packet Capture and Firewall Bypass\n\nThe relevance of the BPF filter and packet capture is that it is sniffing traffic at a lower level\nthan the local firewall. This means that even if you run a firewall the implant will see,\n**and act upon, any magic packet sent to the system. The firewall running on the local host**\nwill not block the implant from having this visibility. This is an important point to understand.\n\nFurther, if you have a network perimeter firewall, but it allows traffic to a host on ICMP, UDP\nor TCP to any port, then the implant can see it. Any inbound traffic to the sever can activate\nthe magic packet check and initiate a backdoor.\n\nFor instance, if you run a webserver and lock it down so only port TCP 443 can be accessed,\nthe attacker can send a magic packet to TCP port 443 and activate a backdoor. Same for\nany UDP packet or even a simple ICMP ping. We'll talk about how it does this below.\n\n## Locating Packet Sniffing Processes\n\nFinding a process sniffing packets on Linux by hand is not always obvious. It's just not\nnormal for most people to check for such things and as a result something like BPFDoor can\nremain around for a long time unnoticed.\n\n\n-----\n\nHowever, with this malware in a wait state loop searching for packets you can look for traces\nleft under the process stack by viewing /proc/<PID>/stack. With BPFDoor we can see\nreferences to function calls in the Linux kernel that indicate the process is likely grabbing\npackets.\n\nYou can search the entire /proc/*/stack area for any process that is showing packet capture\nfunctions like the above:\n```\ngrep packet_recvmsg /proc/*/stack\ngrep wait_for_more_packets /proc/*/stack\n\n```\nFalse alarms with this search are possible, but you can narrow down possible candidates like\nbelow. The red arrow is the PID in question running BPFDoor.\n\n\n-----\n\nThe above is time consuming though and not practical in many cases. Instead, we\nrecommend an automated sweep from Sandfly to quickly identify all processes with packet\nsockets in operation. With this, BPFDoor is immediately found. The packet capture socket in\noperation shows up easily and there is no mistaking that this process is reading network\ntraffic.\n\n\n-----\n\n-----\n\n-----\n\n## RC4 Encryption and Passwords\n\nTo access the implant you need not just a magic packet, but also the correct password. The\nleaked source has some passwords set, but there is no reason to believe these are used in\nactual deployment.\n\nThe implant uses RC4 as the encryption layer. RC4 is a very robust cipher for this application\nand is the only truly secure cipher you can write on a napkin. It's a great choice for small\nimplant code like this.\n\nIn the case of the implant we will deduct a few points because they did not throw out the first\nfew kilobytes from the cipher stream which can weaken it, but overall this cipher is a good\nchoice to keep things small and fast.\n\nThe implant can take an optional password. The password is compared against two internal\nvalues. If it matches one value it will setup a local bindshell backdoor. If it matches another it\nwill do a reverse bindshell connect-back to the specified host and port.\n\n\n-----\n\nThere is a third option though and that is if no password is specified, then a function is called\nthat sends a single UDP packet with the value \"1\". This might be some kind of operation\ncheck status to show the implant is still running. Relevant code below:\n```\nif ((s_len = sendto(sock, \"1\", 1, 0, (struct sockaddr *)&remote, sizeof(struct\nsockaddr))) < 0) {\n        close(sock);\n        return -1;\n    }\n\n```\nNote the above is not passed through the RC4 encryption. If you are investigating this on\nyour network, it may be worthwhile looking for single UDP packets with just the data \"1\" in\nthem and nothing else from many hosts over time to a single host IP (controller).\n\n## Firewall Bypass for Bindshell Backdoor\n\nThe implant has a unique feature to bypass the host firewall and make the traffic look\nlegitimate. When the magic packet is received by the host, the implant will spawn a new\ninstance and change the local iptables rules to do a redirect from the requesting host to the\nshell port.\n\nFor instance, the implant can redirect all traffic from the attacker using TCP port 443\n(encrypted web) to the shell. Externally, the traffic will look like TLS/SSL traffic but in fact the\nattacker is interacting with a remote root shell on the system.\n\nLet's review what this means with a diagram:\n\n\n-----\n\nThe steps are as follows if the actor requests the system open a local shell:\n\n1) Implant is listening to all traffic coming to the host regardless of firewall.\n\n2) Implant sees magic packet.\n\n3) Magic packet can contain IP address, port and password for attacker. Otherwise it uses\nthe origin IP address.\n\n4) Depending on password, implant will open local or connect-back backdoor.\n\n5) Implant selects a TCP port sequentially starting at 42391 up to 43391.\n\n6) Implant binds to first unused port in this range.\n\n7) For local shell, iptables is called to redirect all traffic from attacker host IP from the\nrequested port to the bound port range from the above steps.\n\n8) Attacker connects with TCP to the defined port they requested (e.g. TCP port 443).\n\n9) Traffic from that host is redirected from the port to the shell routing behind the firewall.\n\n10) Observed traffic still appears to be going to host on a legitimate port, but in fact is being\nrouted to the shell on the host.\n\nIf this is confusing, then let's look at the shell in action using SSH as our target port.\n\n\n-----\n\n**NOTE: We disabled the RC4 encryption in the implant for example purposes to use**\n**_netcat. The real implant would require the correct password and RC4 encryption layer_**\n**to see these results.**\n\nBelow we connect to a host on SSH port 22. We get back a normal OpenSSH banner. Then\non another window we send the magic packet on UDP to the host (or TCP or ICMP). The\nimplant sees this packet and that we want to use TCP port 22 as our shell access port. The\nimplant starts a shell on a high TCP port and then redirects the traffic. When we connect\nagain to port 22, instead of SSH we now get a shell with root access.\n\nHere again is the important point: All other users still get SSH. Only the attacker's traffic\n**is redirected to the shell even though it goes to the same SSH port!**\n\n\n-----\n\nYou ll see also when you connect the value 3458 is sent above. This may be a version\nidentifier for the implant operator.\n\nThe redirect rules for the shell access are seen below. Here you see that the TCP port 42392\nwas found available and the shell bound to it. All TCP port 22 traffic from our attacker host\n(192.168.1.1) is now routed to this shell on this port. The traffic looks like encrypted SSH\ncommunications going to TCP port 22, but in reality is being directed to the shell port once it\nhits the iptables rule for the attacker host only.\n```\n/sbin/iptables -t nat -D PREROUTING -p tcp -s 192.168.1.1 --dport 22 -j REDIRECT -to-ports 42392\n/sbin/iptables -D INPUT -p tcp -s 192.168.1.1 -j ACCEPT\n\n## Connect-Back Bindshell\n\n```\nThe implant also has the ability to connect back to a host as defined in the magic packet.\nOperation here is largely the same, but this may not be as stealthy having a system connect\noutbound (and many orgs may block servers talking outbound). The first method of packet\nredirect is far more dangerous and harder to find as it will look like legitimate traffic going to\nthe server and not originating outbound.\n\n## Status Check\n\nAs discussed above, if you do not supply any password or an incorrect password in a magic\npacket the implant will simply send out \"1\" on UDP. We believe this is some kind of status\ncheck to allow keeping tabs on many systems.\n\n**Organizations may want to consider running a network scan against their hosts**\n**sending a magic packet on ICMP, UDP or TCP with a known UDP port you monitor to**\n**see if any systems respond. Any host responding has an active implant.**\n\n## Shell Anti-Forensics and Evasion\n\nThe shell is spawned by forking a controller and finally the shell itself. The controlling PID will\nbe masquerading running under the name:\n\n_/usr/libexec/postfix/master_\n\nThe shell itself will be running under the name:\n\n_qmgr -l -t fifo -u_\n\nIn the ps listing you'll see the following. Here the implant is restarted under a new bogus\nname. Then you see the two processes masking the shell operation when it is operating.\n\n\n-----\n\nAgain if you go under /proc/<PID> and do a listing you will see the reference to the real\nnames.\n\nSandfly hunter view shows the mismatch between the shell and the masquerading names it\nis using. Here the masquerading name clearly does not match the shell path and actual\nprocess name we saw.\n\n\n-----\n\nThe shell also sets up some anti-forensics for good measure. The environment is carefully\nselected to only have the following. We'll use strings /proc/<PID>/environ to look at what it is\ndoing below:\n\n\n-----\n\n```\nroot@bpfdoor:/# strings /proc/2500/environ\nHOME=/tmp\nPS1=[\\u@\\h \\W]\\\\$ \nHISTFILE=/dev/null\nMYSQL_HISTFILE=/dev/null\nPATH=/bin:/usr/kerberos/sbin:/usr/kerberos/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin\nvt100\n\n```\nThe implant is telling the shell to not log shell history and also does the same for MySQL.\nThis means that the operators likely are doing a lot of work with MySQL to call this out\nspecifically. The listing of kerberos in the path also means that kerberos authentication\nsystems may be a frequent target.\n\nSandfly finds this shell in numerous ways, but the anti-forensics is a dead giveaway it's up to\nno good.\n\n\n-----\n\n## Implant Termination\n\nThe implant has mechanisms to terminate itself if there is an error or for other reasons. It will\nclean up its dropper file and exit cleanly. There are no destructive commands built into the\nimplant, but obviously a root shell is all you need.\n\n## Sandfly Detection\n\nAlthough the implant takes many measures to hide, it is easily found if you know where and\nhow to look. Sandfly finds it easily and would have been able to for quite a while now.\n\nA host running this backdoor will have many distinct and very severe Sandfly alerts that\nsomething is wrong. Although the techniques here will help incident responders investigate\ntheir hosts by hand, we offer a [free 500 host license for Sandfly that will do it much faster](https://www.sandflysecurity.com/get-sandfly/)\nand more completely.\n\n\n-----\n\n## Conclusions\n\nThis implant is well executed and layers known-tactics such as environment anti-forensics,\ntimestomping, and process masquerading effectively. The use of BPF and packet capture\nprovides a way to bypass local firewalls to allow remote attackers to control the implant.\nFinally, the redirect feature is unique and very dangerous as it can make malicious traffic\nblend in seamlessly with legitimate traffic on an infected host with exposed ports to the\ninternet.\n\nThe code does not reveal much about the authors, but it clearly was done by someone that\nknows what they are doing with an intent to remain undetected.\n\n## Indicators of Compromise\n\n\n-----\n\nUse these to help manually search for BPFDoor. Please see our Linux compromise cheat\nsheet for commands to help you with these checks.\n\n**Do not use hashes to find this malware. Hashes work very poorly on Linux to find**\nmalware as the binaries are easily re-compiled and changed. This kind of malware needs\ntactics hunting to find it consistently.\n\n## Hunting Tactics\n\nPossible binary left behind if implant fails to load:\n```\n/dev/shm/kdmtmpflush\n\n```\nDropper if implant active or did not clean up:\n```\n/var/run/haldrund.pid\n\n```\nDeleted process called kdmtmpflush or similar.\n\nProcesses missing environment variables.\n\nAny process running from /dev/shm\n\nAny process operating with a packet socket open that you don't recognize as needing that\nkind of access.\n\nProcess stack trace showing kernel function calls involved with packet capture:\n```\ngrep packet_recvmsg /proc/*/stack\ngrep wait_for_more_packets /proc/*/stack\n\n```\nUnusual redirect rules in iptables.\n\nAny process bound to TCP port 42391-43391 as a listening service.\n\nSystem boot scripts referencing unusual binaries or strange path locations.\n\nUDP outbound traffic containing only the data \"1\" perhaps from many hosts back to a single\nIP for status checks.\n\nLow bandwidth intermittent data streams to ports where you'd expect high traffic. For\ninstance someone using an interactive shell sending manual commands with long latency\nbetween packets (e.g. using a bindshell backdoor) would be an unusual pattern on a\nwebserver pushing big data over TCP port 443 to web browsers.\n\n**Share this:**\n\n## Let Sandfly keep your Linux systems secure\n\n\n-----\n\n[Learn More](https://www.sandflysecurity.com/get-sandfly/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-05-11 - BPFDoor - An Evasive Linux Backdoor Technical Analysis.pdf"
    ],
    "report_names": [
        "2022-05-11 - BPFDoor - An Evasive Linux Backdoor Technical Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "9c8a7541-1ce3-450a-9e41-494bc7af11a4",
            "created_at": "2023-01-06T13:46:39.358343Z",
            "updated_at": "2025-03-27T02:00:03.06082Z",
            "deleted_at": null,
            "main_name": "Red Menshen",
            "aliases": [
                "Red Dev 18"
            ],
            "source_name": "MISPGALAXY:Red Menshen",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535993,
    "ts_updated_at": 1743041822,
    "ts_creation_date": 1653780349,
    "ts_modification_date": 1653780349,
    "files": {
        "pdf": "https://archive.orkl.eu/220aa8f9497dd44a115facb75823a14a3ebf2924.pdf",
        "text": "https://archive.orkl.eu/220aa8f9497dd44a115facb75823a14a3ebf2924.txt",
        "img": "https://archive.orkl.eu/220aa8f9497dd44a115facb75823a14a3ebf2924.jpg"
    }
}