{
    "id": "a3f39b32-ed8b-4ceb-b1d1-edb69e8c028e",
    "created_at": "2022-10-25T16:48:15.594421Z",
    "updated_at": "2025-03-27T02:14:11.714849Z",
    "deleted_at": null,
    "sha1_hash": "5dba7529dfdcd435578dad0c219da02da54b28a0",
    "title": "",
    "authors": "",
    "file_creation_date": "2012-03-14T10:53:12Z",
    "file_modification_date": "2012-03-14T10:53:42Z",
    "file_size": 2565716,
    "plain_text": "# Know Your Digital Enemy\n\n### Anatomy of a Gh0st RAT\n\n\nBy Michael G. Spohn\nPrincipal Consultant, Incident Response & Digital Forensic Practice\nMcAfee[®] Foundstone[®] Professional Services\n\n\n-----\n\n## Table of Contents\n\nBackground 3\n\nGh0st RAT Overview 3\n\nGh0st RAT Capabilities 8\n\nGh0st RAT Operation 9\n\nGh0st RAT Components 12\n\nRESSDT.SYS 14\n\nSVCHOST.DLL 16\n\nINSTALL.EXE 17\n\nGH0ST.EXE 21\n\nFunction ResetSSDT() 21\n\nGh0st RAT Encryption 22\n\nGh0st RAT Network Communication 23\n\nGh0st RAT Source Code 29\n\nGh0st RAT Defenses 34\n\nSummary 36\n\nAbout the Author 36\n\nAbout McAfee Foundstone Professional Services 36\n\n\n-----\n\nBackground\n[On March 29, 2009, the Information Warfare Monitor[1] (IWM) published a document titled Tracking](http://www.infowar-monitor.net/research/)\n_[Gh0stNet—Investigation of a Cyber Espionage Network. This document details the extensive](http://www.infowar-monitor.net/research/)_\ninvestigative research surrounding the attack and compromise of computer systems owned by the\nPrivate Office of the Dalai Lama, the Tibetan Government-in-Exile, and several other Tibetan enterprises.\nAfter 10 months of exhaustive investigative work, this team of talented cyber investigators identified the\ntool used to compromise victim systems—a sophisticated piece of malware named Gh0st RAT (Remote\nAccess Terminal).\n\n[On May 25, 2011, cyber investigator, forensic tool writer, and author Harlan Carvey, published a blog](http://windowsir.blogspot.com/2011/05/tools.html)\n[post listing some of his favorite forensic tools. In this post, Harlan referred to an interesting, yet dated,](http://windowsir.blogspot.com/2011/05/tools.html)\n[website that described, in detail, the capabilities of the Gh0st RAT malware. This site, “xpl0it Analysis,”](http://xanalysis.blogspot.com/2009/04/gh0st-rat.html)\neven includes links to download a beta version (3.6) of the Gh0st RAT source code.\n\nAs soon as I navigated to the stale “xpl0it Analysis” website and read the details of the Gh0st RAT\nmalware, I became very interested in learning more about it. Even though the links to the Gh0st\nBeta source code on the xpl0it Analysis site were removed long ago, I was able to find a copy of it\nsomewhere on the Internet and decided to analyze it.\n\nExamination of the Gh0st RAT source code revealed that it is a derivative of the same code used to create\nthe RAT binaries described in the IWM research paper and the xpl0it Analysis website. Unfortunately, the\ncode base would not compile due to numerous coding bugs and missing dependencies.\n\nAfter many weeks of work, I was able to correct hundreds of bugs in the source code which allowed me\nto build a working version of Gh0st RAT Beta 3.6. Although I converted the resource text labels from\nChinese to English, the base source code was left intact.\n\nThis document describes what I learned during my analysis of the Gh0st RAT source code. I describe in\ngreat detail how the multiple binaries work together, the extensive capabilities of the malware, and the\nstructure of the source code tree. I also explore how the malware compromises a host, its obfuscation\nand encryption methods, and how it communicates. Finally, I provide some tips on how to identify a host\ncompromised by the RAT and how to defend against it.\n\nEven though this Gh0st RAT contains source code dating back to 2001, the lessons we can learn from\nit are very relevant today. In early 2011, McAfee Foundstone and McAfee researchers identified a Gh0st\nRAT, very similar to the one described in this paper, that was used to attack large corporations in the oil\n[and gas industry. This investigation, known as Night Dragon, is described in a separate white paper.](http://www.mcafee.com/us/resources/white-papers/wp-global-energy-cyberattacks-night-dragon.pdf)\n\nThe use of RAT tools by cybercriminals continues because they are very efficient and powerful. They are\nlightweight and provide complete remote control access to a compromised host. The command and\ncontrol (C2) component can manage thousands of compromised hosts. Understanding how these tools\nwork is critical if we want to understand the threat and put in place countermeasures to defend against\ntheir use.\n\nGh0st RAT Overview\nIf you are not familiar with the technical capabilities of a Gh0st RAT, in this section I show the actual\noperation of a RAT using screen shots. There are two main components of a Gh0st RAT system: the\nclient and the server.\n\nThe server is a small Microsoft Windows DLL that runs on a compromised host. It runs as a Windows\nservice and starts up when the system starts. Upon startup, it connects and “checks in” to a C2 client\nand awaits further instructions.\n\n\n-----\n\nThe client component is a standard Windows application. It provides a graphical view, using a grid, to list\nall of the RAT servers that have checked in. It has a dropdown menu with a list of operations to perform\non a remote server. Figure 1 below shows a running C2 client. Notice that there are two checked-in RAT\nservers. A right-click on a server entry displays a menu that provides complete control of the remote host.\n\nFigure 1. Gh0st RAT client (C2).\n\nFigures 2 to 9 show screen shots of the popular and more useful features from the C2 client.\n\nFigure 2. File Manager.\n\n\n-----\n\nFigure 3. Screen Control.\n\nFigure 4. Keylogger.\n\n\n-----\n\nFigure 5. Remote Terminal.\n\nFigure 6. System Management—processes.\n\n\n-----\n\nFigure 7. System Management—Dialup Users.\n\nFigure 8. Live video feed.\n\nFigure 9. Live audio capture.\n\n\n-----\n\nAfter reviewing these screen shots, the threat of this tool is frighteningly clear. Let there be no doubt a\nhost compromised by a Gh0st RAT is completely and totally owned. Also, don’t overlook the danger the\nRemote Terminal (Figure 5) presents. An attacker can use this tool to move laterally across your network.\n\nI also want to emphasize the video and audio feeds the server provides really do work. On a relatively\nfast network, the video and audio are crystal clear. This tool demands respect and attention from those\nof you responsible for protecting your corporate assets.\n\nIn the next section, we look at the capabilities of the Gh0st RAT in more detail.\n\nGh0st RAT Capabilities\nThe Gh0st RAT Beta 3.6 code base builds a completely functional RAT with amazing capabilities. A list of\nits capabilities is shown below in Table 1.\n\nTable 1: Gh0st RAT Capabilities\n\nGh0st RAT Capabilities\n\nExisting Rootkit Removal Clears System Service Descriptor Table SSDT of all existing hooks.\n\nFile Manager Complete file explorer capabilities for local and remote hosts.\n\nScreen Control Complete control of remote screen.\n\nProcess Explorer Complete listing of all active processes and all open windows.\n\nKeystroke Logger Real-time and offline remote keystroke logging.\n\nRemote Terminal Fully functional remote shell.\n\nWeb Cam Eavesdropping Live video feed of remote web camera, if available.\n\nVoice Monitoring Live remote listening using installed microphone, if available.\n\nDial-Up Profile Cracking Listing of Dial-Up profiles, including cracked passwords.\n\nRemote Screen Blanking Blanks compromised host screen, making computer unusable.\n\nRemote Input Blocking Disables compromised host mouse and keyboard.\n\nSession Management Remote shutdown and reboot of host.\n\nRemote File Downloads Ability to download binaries from the Internet to remote host.\n\nCustom Gh0st Server Creation Configurable server settings placed into custom binary.\n\nThere are four binary components that make up the Gh0st suite. The first is a very small device driver\nthat performs a single task: resetting the Windows System Service Dispatch Table (SSDT). This is the only\nkernel level binary in the toolset. It runs at system startup on the compromised host and removes all\nhooks in the SSDT.\n\nThe second binary is a Windows DLL that gets installed on a compromised host as a Windows service.\nThis service is the server component of the Gh0st toolkit. It checks in to the Gh0st C2 controller (client)\non startup and awaits instructions. It is this binary that contains the capabilities described in Table 1.\n\nThe third binary is the Gh0st install program. This is commonly called “the dropper.” It contains the two\nabove described binaries and performs all of the work necessary to install the Gh0st server on a host and\nstartup the Gh0st service.\n\nThe final binary is the C2 controller, known as the Gh0st client. This is a typical Windows application\nthat is used to track and manage Gh0st servers on remote compromised hosts. This is the tool the\ncybercriminals use to exfiltrate information from your networks.\n\n\n-----\n\nGh0st RAT Operation\nThe operation of the RAT tool is very straightforward. Upon startup, the client component presents a\ntabbed window that allows remote operation of compromised hosts. The main window of an online RAT\nclient is shown below in Figure 10.\n\nFigure 10. Gh0st RAT client (C2).\n\nNotice there are three tabs at the bottom of the main frame: Connections, Settings, and Build. The\nConnections tab lists all of the compromised hosts that have checked in and are awaiting further\ninstructions. This view contains columns including a unique ID for each host, WAN and LAN addresses,\nhostname, installed OS, CPU speed, ping speed, and whether the host has a webcam installed. You can\nsee in Figure 10 that there are two hosts that have checked in.\n\nThe status bar contains four panes. On the far left is the IP address of the client computer. The second\npane displays the TX/RX communication rate in KB/S for each remote host. The third pane shows the\nport the C2 client is listening on. Finally, the fourth pane shows the number of checked in hosts.\n\nThe Settings tab is where you provide configuration settings for the C2 client. You provide the\ninformation in this form that will be baked into the server application on the Build tab. This tab is shown\nbelow in Figure 11.\n\nFigure 11. Gh0st Settings tab\n\n\n-----\n\nYou can see that I have set my listening port to 80 and that I limit the maximum number of client\nconnections to 8,000. You can set this value to unlimited by checking the No Limit checkbox. You also\nhave the option to disable tooltips if desired.\n\nThe On-line signature group of controls is used to create a unique Key String that a server must use to\nfind a C2 client. Here you provide the IP or URL and port you want the server to use when checking in.\nYou can also provide proxy settings and credentials if a proxy is in use.\n\nYou will notice in Figure 11 that the Key String value is delimited by AAAA. The data between the AAAA\ndelimiters is the encoded data in the On-line signature fields.\n\nThe Key String value in Figure 11 is the encoded string 192.168.1.249:80. The encoding algorithm is\nBase64 and then each byte is obfuscated further using addition and XOR. This signature is appended to\nthe end of the server binary when you build a server component.\n\nThe Build tab is used to create a custom server application using the unique key string created on the\nSettings tab. This is shown in Figure 12.\n\nFigure 12. Gh0st Build tab.\n\nYou have two choices in how you provide the key string to the server. First, you can provide a URL and\nfile name. To do so, check the Enabled box and enter a valid URL and filename. The contents of the file,\nhosted somewhere on the Internet, must contain the Key String for the C2 client.\n\nFor example, if the enabled checkbox is checked, and the URL http://www.badurl.zzz/ip.jpg was entered,\nthis URL will be encoded in the Key String value and placed at the end of the server binary file. When\nthe server is installed on a compromised host, the server will connect to the URL provided and download\nthe file ip.jpg. The contents of this file must contain the Key String of the C2 client. Using this method of\nproviding a Key String to a RAT allows the C2 operators to move the C2 client whenever needed.\n\nIf you want to bake the Key String into the server binary and not use a URL, uncheck the Enabled\ncheckbox and paste your key string in the Key String field. In Figure 12, you can see I copied and pasted\nthe Server Key from the Settings tab since I want to use the same computer the C2 client is currently\nrunning on.\n\n\n-----\n\nThe Display Name and Description fields are placed in the compromised host registry and will display\nin the Services.msc management console service name and description fields. I suggest that you make\nthese fields appear as legitimate services. Also remember, the Display Name must be unique on the host\nor the creation of the RAT service will fail.\n\nWhen you are satisfied with your settings, click on the Generate button. You will be asked where you\nwant to save the server binary and what you want to name it (default Server.exe). The Gh0st client will\nextract the Server.exe binary from the Resource section of its own binary and save it to disk.\n\nThe Key String and the encrypted display name and description fields are appended to the end of the\nbinary. You can see this in a hex dump of the binary shown in Figure 13.\n\nFigure 13. Encrypted Server Key in SERVER.EXE.\n\nI describe the encryption algorithm and SERVER.EXE in greater detail later in this report.\n\n\n-----\n\nGh0st RAT Components\nIn this section we dive deeper into the structure of the Gh0st RAT components. Figure 14 below shows\nhow all of the components fit together.\n\nFigure 14. Gh0st RAT components.\n\n\n-----\n\nThe binaries that make up the Gh0st toolset are described below in Table 2.\n\nTable 2: Gh0st RAT Components\n\nGh0st RAT Components\n\nRESSDT.SYS Device driver that clears the SSDT of all existing hooks.\n\nSVCHOST.DLL Windows service DLL that runs on a compromised host (server).\n\nINSTALL.EXE Dropper application used to install SVCHOST.DLL.\n\nSERVER.EXE INSTALL.EXE binary with encrypted configuration info appended to end.\n\nGH0ST.EXE C2 server management tool and custom INSTALL.EXE creator (client).\n\nThe Gh0st architecture takes advantage of the ability to create custom Windows resources in a Windows\nbinary. This mechanism is used quite often by malware authors. The process involves the creation of a\ncustom resource and then hiding another binary executable in this custom resource section of the executable.\nIn other words, you can hide an executable within an executable.\n\nIf you refer back to Figure 14, you can see that Gh0st makes extensive use of this capability. Notice the binary\nRESSDT.SYS is placed in the resource section of SVCHOST.DLL. This means SVCHOST.DLL is carrying a device\ndriver payload in its resource section that can reset the SSDT of a Windows host.\n\nLikewise, you can see that INSTALL.EXE contains SVCHOST.DLL in its resource section. This means that\nINSTALL.EXE has a payload in its resource section that contains two binaries: RESSDT.SYS and SVCHOST.DLL.\n\nFinally, you can see the GH0ST.EXE binary contains INSTALL.EXE within its resource section. This means\nthat the GH0ST.EXE binary contains all of the components of the Gh0st RAT infrastructure.\n\nThe Gh0st RAT source code base contains Microsoft Visual Studio (MSVS) project files that create\nthe four binaries. When the projects are compiled, the required binaries are placed with the resource\nsections. Below is a list that describes how all these pieces work together.\n\n1. The Windows Driver Kit (WDK) is used to compile the RESSDT.C code and create RESSDT.SYS binary.\n2. The MSVS project SVCHOST compiles/creates the SVCHOST.DLL binary. The RESSDT.SYS binary is\nplaced in its resource section.\n3. The MSVS project INSTALL compiles/creates the INSTALL.EXE binary. The SVCHOST.DLL binary is\nplaced in its resource section.\n4. The MSVS project GH0ST compiles/creates the GH0ST.EXE binary. The INSTALL.EXE binary is placed in\nits resource section.\n5. The GH0ST.EXE application is used to configure a custom Gh0st server binary (See Gh0st RAT\nOperation section). When the Generate button on the Build tab is clicked, the INSTALL.EXE binary is\nextracted from its own resource section and saved to disk (default name is SERVER.EXE).\n6. The encrypted configuration information from the Build tab is appended to the SERVER.EXE binary.\nYou can see this in Figure 13.\n7. The SERVER.EXE binary is placed on a host that is about to be compromised and executed.\n8. SERVER.EXE extracts the SVCHOST.DLL binary from its resource section and places it in the %Temp%\nfolder with a random file name. Next, the RESSDT.SYS binary is extracted from the SVCHOST.DLL and\nalso placed in the %TEMP% folder.\n9. SERVER.EXE resets the SSDT using the RESSDT.SYS device driver. It then does all its magic\ncompromising the host by changing security settings, creating the Gh0st server service, making\nregistry changes, and more. It then completes its work by starting the Gh0st server service.\n10. When the compromised host starts up and the Gh0st server service starts, the RESSDT.SYS binary\nis extracted from the SVCHOST.DLL and placed in the %TEMP% folder with a random file name.\nThe device driver is loaded and used to reset the SSDT. The device driver is then unloaded and the\ntemporary file is deleted.\n11. The Gh0st server service seeks out its C2 controller, checks in, and awaits further instructions.\n\n\n-----\n\nRESSDT.SYS\n\nThe first Gh0st RAT component we will examine is a device driver named RESDST.SYS. As the name\nsuggests, this small driver performs only one function: it resets the SSDT in the Windows kernel. This\ndevice driver gets loaded during the Gh0st server install on a compromised host and every time the\nGh0st server service starts at Windows boot time.\n\nWhy would the Gh0st authors go to the trouble to write a device driver that removes all hooks in the\nSSDT? I suggest that there are two reasons for this. First, resetting the SSDT to boot-time condition\ndisables any other rootkits or other malware that may already have hooks in place. Second, this act will\nalso remove any SSDT hooks put there by security tools such as host intrusion prevention systems (HIPS)\nor antivirus engines. I know, for example, the Cisco Security Agent (CSA) hooks every entry in the SSDT\nso it can keep a close eye on kernel activity. These hooks will get removed by this device driver.\n\nThe device driver code is very compact and quite elegant. It uses the DeviceIOControl infrastructure of\na Windows device driver to receive IO Request Packets (IRP) from a user-land application. There are four\nfunctions defined in the driver shown below in Table 3.\n\nTable 3: RESSDT.SYS Function Declarations\n\nRESSDT.SYS Function Declarations\n\nNTSTATUS DriverEntry( IN PDRIVER_OBJECT theDriverObject, IN PUNICODE_STRING theRegistryPath )\n\nNTSTATUS DisPatchCreateClose(PDEVICE_OBJECT pDriverObj,PIRP pIrp);\n\nNTSTATUS DispatchDeviceControl(IN PDEVICE_OBJECT DeviceObject,IN PIRP pIrp);\n\nvoid DriverUnload(PDRIVER_OBJECT pDriverObj);\n\nThe DriverEntry() function has a predefined argument list and is required by Windows. This function is\nwhere a driver places all its setup code. Our driver performs the following tasks within this function.\n\n1. Sets all IRP_MJ_MAXIMUM_FUNCTION table entries to point to function DisPatchCreateClose().\n\n2. Sets the IRP_MJ_DEVICE_CONTROL table entry to point to function DispatchDeviceControl().\n\n3. Sets theDriverObject->DriverUnload pointer to point to function DriverUnload().\n\n4. Creates an IODevice object with the name \\\\Device\\\\RESSDT.\n\n5. Creates a symbolic link to the IODevice object with the name \\\\??\\RESSDTDOS.\n\nThe driver sets up its function call table by pointing all table entries to function DisPatchCreateClose()\nexcept for the IOControl function which points to DispatchDeviceControl(). In short, the only operation\nthis driver is interested in is IOControlRequests. This is pretty standard stuff. Forensic investigators should\ntake note of the device driver names. These names should always raise suspicion because it is pretty rare\nto have a device driver that resets the SSDT.\n\n- The DisPatchCreateClose() function does nothing but return STATUS_SUCCESS. It is an empty function.\n\n- The DriverUnload() function deletes the IODevice symbolic link and then deletes the IODevice object.\n\nThis leaves only the function DispatchDeviceControl() for us to examine. In short, this function is\ndesigned to receive an IRP from Windows whenever a user-land application makes a DeviceIOControl\ncall to this driver. As I will show later on, the user-land application calls the DeviceIOControl function and\npasses it two pieces of information: a SSDT table index number and a pointer to a function. The device\ndriver simply places the passed-in function pointer in the SSDT table at the passed in index.\n\n\n-----\n\nBelow is a list of actions the DispatchDeviceControl() function performs for those of you interested in\nthe details:\n\n1. Calls IoGetCurrentIrpStackLocation(pIrp) to obtain a pointer to the user-land stack.\n\n2. Sets up variables to hold the IOControlCode, pointers to the user-land input and output buffers\npassed via the stack pointer location, and the sizes of these buffers.\n\n3. Enters a switch() statement that only triggers on the value IOCTL_SETPROC.\n\na. Verifies that the pointers to the input and output buffers are valid.\nb. Reads the SSDT index variable from the user-land input buffer.\nc. Verifies that the index variable value is <= the maximum number of SSDT entries.\nd. Sets up a pointer to the base of the kernel SSDT.\ne. Uses the register CR0 trick to gain write access to the SSDT.\nf. Sets the requested SSDT entry to the requested SSDT function pointer.\ng. Uses the register CR0 trick to reset read-only access to the SSDT.\n\n4. Returns STATUS_SUCCESS.\n\nIn short, a user-land application makes a DeviceIOControl() function call to the device driver, passing it\nan index into the SSDT and a function pointer that the driver is to place in that index. The driver obtains\na pointer to the base of the SSDT from the kernel, abuses register CR0 by changing the SSDT memory\npages to write mode, and then makes the required change to the SSDT. The driver then switches the\nSSDT memory pages back to read-mode and returns a success code to the user-land application.\n\nThe register CR0 hack was first widely published by Greg Hoglund and James Butler in their book\n_Rootkits—Subverting the Windows Kernel.[2] You can see in the code snippet in Figure 15 how this works._\n\nFigure 15. CR0 hack code snippet.\n\nOn line 114, a pointer is set to point to the base of the SSDT. Then, in-line assembly code changes CR0\nto allow writes to protected kernel memory. On line 123, the SSDT pointer is incremented to point to\nthe correct table entry requested by the caller and a function pointer is placed in that table entry. Finally,\nthe CR0 register is set back to read-only.\n\nIf it is not clear to you how all this works, the important thing to remember is that RESDDT.SYS is a small\ndevice driver whose only purpose in life it to reset the Windows kernel SSDT to the state it was in when\nthe system booted. The bottom line is all existing hooks/hacks to the SSDT are removed.\n\n\n-----\n\nSVCHOST.DLL\n\nThe second Gh0st RAT component we will examine is the DLL that gets installed as a service on a\ncompromised host and provides the Gh0st RAT server functions. The setup and installation of this DLL as\na service is done by the install program (Dropper) SERVER.EXE. I will cover the details of the installation\nand configuration of the RAT service in the INSTALL.EXE section of this document.\n\nBelow is the list of tasks the service DLL performs from startup until it checks in with its C2 controller.\n\n1. Calls function FindConfigString(). This function searches the DLL’s own binary image for the\nconfiguration string delimiter AAAAAA, starting from the end. If this string is not found, the DLL will\nexit and the service fails to start. If the string is found, the configuration string is loaded into memory.\nThis configuration string will have either an IP address and a port, or a URL with a file name.\n\n2. Sets a Windows station, first by saving the current station by calling GetProcessWindowStation().\nThen it creates a new Windows station named winsta0 by calling OpenWindowStation(). Since I was\nnot familiar with these calls, I queried MSDN. Here is what I discovered:\n\n“Windows provides three main categories of objects: user interface, graphics device interface\n[(GDI), and kernel. Kernel objects are securable, while user objects and GDI objects are not.](http://msdn.microsoft.com/en-us/library/ms724485%28v=VS.85%29.aspx)\nTherefore, to provide additional security, user interface objects are managed using window\nstations and desktops, which themselves are securable objects.”[3]\n\n3. Checks to see if a global instance variable is not NULL. If it has a value other than NULL, it means an\ninstance of the service is already running. If this is the case, a series of function calls occur that resets\nthe SSDT and restarts the service.\n\n4. Calls getLoginInfo(). This function decrypts the configuration string found in Step 1. If the\nconfiguration string contains a URL, this function will open an Internet connection to the URL and\ndownload the configuration string and decrypt it. If it does not contain a URL, the string is simply\ndecrypted and parsed. This function populates the following variables with the relative data:\n\na. lpszHost\n\nb. dwPort\n\nc. lpszProxyHost\n\nd. dwProxyPort\n\ne. lpszProxyUser\n\nf. lpszProxyPass\n\n(Note: These variable values will be seen in a memory dump so be prepared to look for them.)\n\n5. If the above proxy-related variables are populated, the connection socket used to connect to the C2\nclient is configured to use the PROXY_SOCKS_VER5 configuration.\n\n6. Calls and saves the return value of GetTickCount(). This is used to determine how long the server is\nconnected to the client.\n\n7. Calls sendLoginInfo(). This function collects the column values shown by the client C2 grid columns\nand then attempts to report in to the C2 client.\n\n8. Creates an instance of the class CKernelManager setting the socket, service name, event, hostname,\nand port variables. It then sets the socketClient object callback function to the new CKernelManager\ninstance. In short, this means any socket communication received from the C2 client is processed by\nthe CKernelManager.\n\n9. Enters a do/while loop waiting for an instruction from the C2 client.\n\n(Note: if the server cannot connect to the C2 client, it will sit in a loop and attempt to reconnect every\n1 minute.)\n\n\n-----\n\nINSTALL.EXE\n\nThe third Gh0st RAT component we will examine is the Dropper INSTALL.EXE. This is a stand-alone\nWindows application that contains all required code to prepare a compromised host for the installation\nof the Gh0st RAT server service and the launching of that service.\n\nBelow is the list of tasks the INSTALL.EXE application performs from startup until it starts the\nserver service.\n\n1. The first action is a series of interesting function calls. First, the Win32 API GetInputState() function\nis called. This function returns TRUE if there are mouse button or keyboard messages in the calling\nthread’s message queue. Next is a call to PostThreadMessage() with a NULL message type. Finally,\nGetMessage() is called. It is very interesting that none of the return values of these functions are\nexamined. It appears the application just wants to prime its Windows message pump.\n\n2. Next is a call to FindConfigString(hInstance, “AAAAAA”). This function calls the Win32 API\nGetmoduleFilename() to determine its own filename. It then calls CreateFile() to open its own binary\nin read mode. It then seeks (to the byte) 1024 bytes from the end of its own binary and searches\nfor the string AAAAAA. You may recall this is a delimiter used to encode the server KeyString. If\nit finds the delimiter string, it returns a string pointer to the beginning of the configuration string.\nThe AAAAAA delimiter points to the beginning of the C2 hostname:port or the URL containing the\nServerKey string.\n\n3. The application makes a second call to FindConfigString(hInstance, CCCCCC). This time the function\nis asked to return a string pointer to the CCCCCC delimiter of the encrypted configuration string\nin its own binary. The CCCCCC delimiter points to the beginning of the server service name and\ndescription strings. If the configuration string is not found, the program exits.\n\n4. The two previously located encrypted configuration strings are decrypted with two calls to the\nMyDecode() function. The encryption details of the Gh0st RAT are discussed in the “Encryption”\nsection of this report.\n\n5. Calls GetCommandLine() and searches for a command line string Gh0st Update. If it does not find\nthis command line argument, it creates a Mutex using the encrypted configuration string as its name.\nIf this Mutex name already exists, the program exits. Otherwise it releases and closes the Mutex. This\naction ensures that two instances of the install program will not run at the same time.\n\n6. Calls SetAccessRights(). This function performs the following actions:\n\na. Calls Win32 API GetSystemDirectory() to determine where the \\Windows\\System32 folder is.\n\nb. Calls Win32 API GetUserName() to determine what user account it is running under.\n\nc. Calls the Win32 API AddAccessRights() function passing in the current user name and\nrequesting GENERIC_ALL access rights to the Windows\\System32 and \\Windows\\System32\\\nDrivers folder.\n\nd. Calls the Win32 API NetGetLocalGroups() to obtain a list of groups the current user belongs to.\n\ne. Calls the Win32 API AddAccessRights() function passing in the current user name and\nrequesting GENERIC_ALL access rights to all of the groups the current user belongs to\n(identified in step d).\n\n7. Calls local function ResetSSDT(). A description of this function can be found in the “ResetSSDT\nFunction” section of this document.\n\n8. Calls local function InstallService(). This function performs the following steps:\n\na. The prototype for this function is:\n\nchar* InstallService(LPCSTR lpServiceDisplayName,\n\nLPCST lpServiceDescription,\n\nLPCSTR lpConfigureString);\n\nAs you can see, the unencrypted service display name string, service description string, and the\n_encrypted ServerKey string are passed into this function._\n\nb. All of the following actions are taken within one huge Try{ and }Catch block. So, the installation\nof the server is an all or nothing proposition.\n\n\n-----\n\nc. Calls Win32 API RegOpenKeyEx() function to open the registry key SOFTWARE\\Microsoft\\\nWindows NT\\CurrentVersion\\Svchost.\n\nd. Queries the above key for the value “netsvcs.” This value is of type REG_MULTI_SZ. On my\nWindows XP test system, this registry value contains 46 strings. The first 26 of these values are\nshown in Figure 6. These strings are the names of Windows services that may be running on\nyour system. Just because a service is listed under this key does not mean that service is installed\nand running on your system.\n\nFigure 16. “netsvcs” Registry value (partial).\n\ne. Obtains a HANDLE to the Service Control Manager by calling the Win32 API call\nOpenSCManager().\n\nf. Calls Win32 API call GetSystemDirectory() to determine where the \\Windows\\System32 is.\n\ng. Loops through each string in the netsvcs Registry value and queries the Registry key MACHINE\\\\\nSYSTEM\\\\CurrentControlSet\\\\Services to determine if the service is installed on the system. For\nexample, the first query from my list in Figure 16 would look for the value MACHINE\\\\SYSTEM\\\\\nCurrentControlSet\\\\Services\\\\AppMgmt.\n\nh. When a netsvcs value is found that is not installed (that is, not used) as a service on the host,\nthis netsvcs value will be used as the Gh0st RAT service.\n\ni. Calls local function AddsvchostService(). This function appends a string to the Registry value\nSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost\\netsvcs queried in step d above.\nThe appended string will be in the form netsvs_0xN, where N is a number starting with 0 (that\nis, netscvs_0x0). If the string netsvs_0x0 already exists in the key value, it will add the string\nnetsvs_0x1 and so on. Once a value has been added, the function returns a string with the\nservice name it added to this Registry key value. This entry is used to keep track of the location\nof the INSTALL.EXE program location.\n\n\n-----\n\nj. Calls Win32 API call CreateService(). The details of this function call parameters are shown in\nFigure 17.\n\nFigure 17. CreateService() API call.\n\nThis function creates an entry in the SCM database for the new service. The ptr parameter\ncontains the name of the unused service string identified in step g above. More information\n[about this function call can be located here on MSDN.](http://msdn.microsoft.com/en-us/library/ms682450%28v=VS.85%29.aspx)\n\nk. If the CreateService() function call fails, it gets called again. This second call changes the\nSERVICE_WIN32_SHARE_PROCESS parameter to SERVICE_WIN32_OWN_PROCESS. The bet is\nthat one of these two functions calls will succeed.\n\nl. Now that the new service has been added to the SCM database, service details are written to\nthe SYSTEM\\CurrentControlSet\\Services key. You can see these values in Figures 18 through 20.\n\nFigure 18. Gh0st RAT Service Registry Key.\n\nFigure 19. Gh0st RAT Service Registry Parameters Key.\n\n\n-----\n\nFigure 20. Gh0st RAT Service Registry Security Key.\n\nNotice in Figure 20 the REG_BINARY Security value under the security key. This data value\ncontains the encrypted Server Key value.\n\nm. Calls local function ReleaseResource(). The Gh0st RAT server binary is now extracted from the\nINSTALL.EXE’s own resource section. (The name of this resource is “BIN”). Once the binary is\nextracted, it is writtent to the \\Windows\\System32 folder with the name of the installed service\nappended with ex.dll. For example, on my test system the name of the hijacked (unused) service\nused by INSTALL.EXE is Irmon. The name of the RAT binary is Irmonex.dll. This binary also has\nthe Hidden attribute set.\n\n9. Creates a Registry key “SYSTEM\\CurrentControlSet\\Services\\netsvc_0xN. This key name will be\nthe same name created back in step i. A subkey is created named InstallModule with a sting value\ncontaining the full path of the INSTALL.EXE application (Figure 21). This registry key is used by the\nGh0st server service to find and delete the program that installed it.\n\nFigure 21. netsvcs_0xn Registry Key.\n\n10. Calls local function StartService(). This function calls the Win32 API function OpenSCManager().\nIt next calls the Win32 API OpenService() passing it the name of the newly created Gh0st service.\nFinally, it calls StartService() to begin the fun. It closes all open SCM handles and returns. The Gh0st\nservice starts and looks for its C2 client.\n\n11. At this point everything is in place, so the INSTALL.EXE kills itself by calling the Win32 API call\nExitProcess().\n\nSo there you have it. The complete picture of what the INSTALL.EXE application does to compromise a\nhost and install the Gh0st service. I am sure you will agree that somebody went to a lot of trouble to\nimplement this very innovative process. Obviously, the authors of this tool have a deep understanding of\nthe Windows operating system.\n\n\n-----\n\nGH0ST.EXE\n\nThe final Gh0st RAT component we will examine is the C2 client GH0ST.EXE. From a code perspective,\nthis is the largest component in the toolset. It contains all of the C&C capabilities of the RAT system. The\ntwo main functions this module serves is the management and control of Gh0st servers and the ability\nto create customized server install programs.\n\nMost of the capabilities of the GH0ST.EXE binary were covered in the “Gh0st Rat Overview” and “Gh0st\nRat Operations” sections of this report, so I won’t repeat them here. The process of building a custom\nGh0st server application is very simple. The INSTALL.EXE binary containing both the SVCHOST.DLL and\nRESSDT.SYS binaries are hidden in the GH0ST.EXE binary Resource section. When the Build command\nis used, GH0ST.EXE simply extracts the INSTALL.EXE from its resource section and saves it to disk. It\nthen appends the encrypted ServerKey, Service Name, and Service Description strings to the end of the\nextracted file.\n\nFunction ResetSSDT()\n\nI think it is important to explore a very interesting function that resets the SSDT of the compromised\nhost. As you recall from the “Gh0st Rat Components” section, there is a device driver named RESSDT.\nSYS that implements the device driver IOControl capabilities to receive requests from a user-land\napplication. This driver accepts an SSDT index number and a function pointer from the user-land\napplication. It places the function pointer in the requested SSDT table index. Let’s take a look at how the\nuser-land application uses this device driver.\n\nIn this case, the two user-land applications that call this function are INSTALL.EXE and SVCHOST.DLL.\nINSTALL.EXE (SERVER.EXE) calls this function during the compromise/install process of the Gh0st server\nsevice. SVCHOST.DLL (?????EX.DLL) calls this function every time the service starts at system boot time.\n\nBelow is a list detailing what the ResetSSDT() function does.\n\n1. Calls the local function RestoreSSDT(), which performs the following actions:\n\na. Calls local function LoadDriver(). This function essentially completely hijacks the Windows beep.sys\ndevice driver. It does this by opening the SCM and stopping the Beep service if it is running and\ndoes the following:\n\ni. Calls the Win32 API function SetFileAttributes() to change the beep.sys device driver file\nto FILE_ATTRIBUTE_NORMAL.\n\nii. Loads the beep.sys into a memory-mapped file.\n\niii. Extracts the RESSDT.SYS binary from the resource section of the SVCHOST.DLL binary.\n\niv. Replaces the beep.sys code in the memory-mapped file with the RESSDT.SYS binary.\n\nv. Saves the new beep.sys code back to \\Windows\\System32\\Drivers folder.\n\nvi. Starts the Beep service using the SCM API.\n\nvii. Calls the Win32 API function CreateFileA() and opens a file named \\\\.\\RRESSDTDOS,\nwhich you may recall is the symbolic link name of the RESSDT.SYS device driver.\n\nviii. Returns a HANDLE to the RESSDT.SYS device driver.\n\nb. Calls local function ReSSDT(). This function accepts the above handle to the RESSDT.SYS device\ndriver and performs the following actions.\n\ni. Calls Win32 API function GetProcAddress(GetModuleHandle(“ntdll.dll”),\n“NtQuerySystemInformation”) to obtain a function pointer.\n\nii. Calls Win32 API function NtQuerySystemInformation() using the undocumented SYSTEM_\nMODULE_INFORMATION parameter to obtain a pointer to a MODULES structure. This\nstructure is used to identify the image name of the windows kernel.\n\niii. Calls Win32 API function LoadLibraryEx() to obtain a handle to the Windows kernel.\n\niv. Calls Win32 API function GetProcAddress(“KeServiceDescriptorTable”) to obtain a pointer\nto the SSDT.\n\nv. Walks the Windows kernel image to obtain pointers to each service loaded into the SSDT.\n\n\n-----\n\nvi. For each service found in the kernel, the SSDT index and function pointer is passed to the\nRESSDT.SYS device driver using an IOControl call.\n\nc. Calls local function UnloadDriver() to stop the RESSDT.SYS device driver running under the\nBeep service.\n\nThis is pretty impressive code. The Gh0st authors went to a lot of trouble to include this capability of\nresetting the SSDT to remove existing rootkits and security software hooks.\n\nGh0st RAT Encryption\nIn this section we take a look at the method the Gh0st tools use for encryption. There are three levels\nof encryption/obfuscation used in the system: Base64 encoding, a custom encoding scheme, and\ncompression of network traffic streams using the standard zip compression algorithm.\n\nThe Base64 encoding is done by the function base64_encode(). Comparing the code in this function\nwith published public domain Base64 algorithms confirms this is legitimate Base64 encoding scheme.\n\nThe custom encoding scheme is provided by the function MyEncode(). The contents of this simple\nfunction is shown in Figure 22.\n\nFigure 22. Gh0st RAT MyEncode() function.\n\nThis function accepts a char pointer as the lone parameter and returns a char pointer containing the\nencoded string passed in. The function determines the length of the input string and allocates a memory\nbuffer of that size plus one byte. The imput string is copied into this memory buffer and each character\nin the buffer is modified by two operations. First, the char is exclusive ORed with 0x19 (25). Then the\nchar value is incremented by 0x86 (134). Once this is done, the encoded string is passed to the base64_\nencode() function.\n\nThe ultimate outcome of this function is an encryted string that would be nearly impossible to decode\nwithout knowing the algorithms used. As shown in Figure 23 the MyDecode() function simply reverses\nthe encoding.\n\n\n-----\n\nFigure 23. Gh0st RAT MyDecode() function.\n\nGh0st RAT Network Communication\nThe network communication between the Gh0st RAT C2 client and a compromised host (server) is very\nsimple. A data packet consists of four fields:\n\n1. A five-byte packet header. This header contains the characters Gh0st.\n\n2. A four-byte integer that contains the size in bytes of the entire packet.\n\n3. A four-byte integer that containes the size in bytes of the entire packet when uncompressed.\n\n4. A variable-sized packet that contains the packet payload. The client sends small requests that contain\ncommands, and the server responds to those commands with the requested data.\n\nThe header, 13 bytes in length, is sent in the clear. This means you can clearly see the the Gh0stheader\ntext on the wire. I was surprised by this discovery and doubt newer versions of Gh0st RATs do this. It is\ntoo easy to detect.\n\nThe packet payload is compressed using the open source zlib compression library. There is no obfuscation\nor other encyption used. I confirmed this in my research by capturing network data using WireShark and\nunencrypting the packet payloads with a Python script using the zlib module unencrypt() function.\n\nAfter the header, the first byte of the packet payload contains an operation code. There are three types\nof codes: Commands, Tokens, and Modes. In the source code, these codes are contained in a large\nenum in a header file.\n\nCommand codes are sent by the client (C2) instructing the server what to do. If you study the list of\ncommands in Table 4, you can see the command codes correspond very closely to the menu items that\nappear when you right-click a server in the client connections grid.\n\nTable 4. Gh0st RAT Command Codes\n\nCommand Code Value\n\nCOMMAND_ACTIVED 0x00\n\nCOMMAND_LIST_DRIVE 0x01\n\nCOMMAND_LIST_FILES 0x02\n\nCOMMAND_DOWN_FILES 0x03\n\nCOMMAND_FILE_SIZE 0x04\n\nCOMMAND_FILE_DATA 0x05\n\nCOMMAND_EXCEPTION 0x06\n\nCOMMAND_CONTINUE 0x07\n\n\n-----\n\nCommand Code Value\n\nCOMMAND_STOP 0x08\n\nCOMMAND_DELETE_FILE 0x09\n\nCOMMAND_DELETE_DIRECTORY 0x10\n\nCOMMAND_SET_TRANSFER_MODE 0x11\n\nCOMMAND_CREATE_FOLDER 0x12\n\nCOMMAND_RENAME_FILE 0x13\n\nCOMMAND_OPEN_FILE_SHOW 0x14\n\nCOMMAND_OPEN_FILE_HIDE 0x15\n\nCOMMAND_SCREEN_SPY 0x16\n\nCOMMAND_SCREEN_RESET 0x17\n\nCOMMAND_ALGORITHM_RESET 0x18\n\nCOMMAND_SCREEN_CTRL_ALT_DEL 0x19\n\nCOMMAND_SCREEN_CONTROL 0x20\n\nCOMMAND_SCREEN_BLOCK_INPUT 0x21\n\nCOMMAND_SCREEN_BLANK 0x22\n\nCOMMAND_SCREEN_CAPTURE_LAYER 0x23\n\nCOMMAND_SCREEN_GET_CLIPBOARD 0x24\n\nCOMMAND_SCREEN_SET_CLIPBOARD 0x25\n\nCOMMAND_WEBCAM 0x26\n\nCOMMAND_WEBCAM_ENABLECOMPRESS 0x27\n\nCOMMAND_WEBCAM_DISABLECOMPRESS 0x28\n\nCOMMAND_WEBCAM_RESIZE 0x29\n\nCOMMAND_NEXT 0x30\n\nCOMMAND_KEYBOARD 0x31\n\nCOMMAND_KEYBOARD_OFFLINE 0x32\n\nCOMMAND_KEYBOARD_CLEAR 0x33\n\nCOMMAND_AUDIO 0x34\n\nCOMMAND_SYSTEM 0x35\n\nCOMMAND_PSLIST 0x36\n\nCOMMAND_WSLIST 0x37\n\nCOMMAND_DIALUPASS 0x38\n\nCOMMAND_KILLPROCESS 0x39\n\nCOMMAND_SHELL 0x40\n\nCOMMAND_SESSION 0x41\n\nCOMMAND_REMOVE 0x42\n\nCOMMAND_DOWN_EXEC 0x43\n\n\n-----\n\nCommand Code Value\n\nCOMMAND_UPDATE_SERVER 0x44\n\nCOMMAND_CLEAN_EVENT 0x45\n\nCOMMAND_OPEN_URL_HIDE 0x46\n\nCOMMAND_OPEN_URL_SHOW 0x47\n\nCOMMAND_RENAME_REMARK 0x48\n\nCOMMAND_REPLAY_HEARTBEAT 0x49\n\nThe Token codes are used by the server to identify the payload types is returns to the client. You can see\nthese codes in Table 5.\n\nTable 5: Gh0st RAT Token Codes\n\nToken Code Value\n\nTOKEN_AUTH 100\n\nTOKEN_HEARTBEAT 101\n\nTOKEN_LOGIN 102\n\nTOKEN_DRIVE_LIST 103\n\nTOKEN_FILE_LIST 104\n\nTOKEN_FILE_SIZE 105\n\nTOKEN_FILE_DATA 106\n\nTOKEN_TRANSFER_FINISH 107\n\nTOKEN_DELETE_FINISH 108\n\nTOKEN_GET_TRANSFER_MODE 109\n\nTOKEN_GET_FILEDATA 110\n\nTOKEN_CREATEFOLDER_FINISH 111\n\nTOKEN_DATA_CONTINUE 112\n\nTOKEN_RENAME_FINISH 113\n\nTOKEN_EXCEPTION 114\n\nTOKEN_BITMAPINFO 115\n\nTOKEN_FIRSTSCREEN 116\n\nTOKEN_NEXTSCREEN 117\n\nTOKEN_CLIPBOARD_TEXT 118\n\nTOKEN_WEBCAM_BITMAPINFO 119\n\nTOKEN_WEBCAM_DIB 120\n\nTOKEN_AUDIO_START 121\n\nTOKEN_AUDIO_DATA 122\n\nTOKEN_KEYBOARD_START 123\n\nTOKEN_KEYBOARD_DATA 124\n\n\n-----\n\nToken Code Value\n\nTOKEN_PSLIST 125\n\nTOKEN_WSLIST 126\n\nTOKEN_DIALUPASS 127\n\nTOKEN_SHELL_START 128\n\nThe Mode codes are used by both the client and the server to request/respond to specific action setting.\nYou can see these codes in Table 6.\n\nTable 6. Gh0st RAT Mode Codes\n\nMode Code Value\n\nTRANSFER_MODE_NORMAL 0x00\n\nTRANSFER_MODE_ADDITION 0x01\n\nTRANSFER_MODE_ADDITION_ALL 0x02\n\nTRANSFER_MODE_OVERWRITE 0x03\n\nTRANSFER_MODE_OVERWRITE_ALL 0x04\n\nTRANSFER_MODE_JUMP 0x05\n\nTRANSFER_MODE_JUMP_ALL 0x06\n\nTRANSFER_MODE_CANCEL 0x07\n\nTo illustrate a packet exchange, let’s first explore what a server Check-in packet looks like. This is the first\ncommunication between the server and the client. The Gh0st RAT network communications relies on\ndata structures to constuct payloads. The Check-in or Login packet data is encapsulated in a structure\nnamed LOGININFO (Figure 24).\n\nFigure 24. Gh0st RAT LOGININFO structure.\n\nThe LOGININFO field content is described below:\n\n- bToken contains the TOKEN value TOKEN_LOGIN (102). See Figure 25.\n\n- OsVerInfoEx is a Win32 API structure that contains much information about the host operating system.\n[You can learn more about this structure on MSDN. This structure is populated by the server with a call](http://msdn.microsoft.com/en-us/library/ms724833%28v=vs.85%29.aspx)\nto the Win32 API function GetVersionEx().\n\n- The CPUClockMhz value is populated by querying the Registry key “HARDWARE\\DESCRIPTION\\System\\\nCentralProcessor\\0\\~Mhz” key value\n\n- The IPAddress field is populated by querying an open socket structure\n\n\n-----\n\n- The HostName string is populated by a call to the Win32 API function gethostname()\n\n- The bIsWebCam value is populated by a call to the Win32 API function capGetDriverDescription(). This\nfunction returns TRUE is a capture driver is present or FALSE otherwise.\n\n- The dwSpeed value always appears to be 0\n\nOnce the LOGININFO is populated, the structure is passed to the zlib compress() function. A packet\nheader is constructed with the Gh0st signature, the compressed length of the entire packet, and the\nuncompressed length of the entire packet. The header and payload are combined and sent down the\nwire to the C2 client.\n\nI captured a Login exchange between a server and client using Wireshark. The Login packet sent by the\nserver is shown in Figure 28.\n\nFigure 25. Gh0st RAT Server Login packet.\n\nIn this packet capture, you can see the server (192.168.1.224) exchange the SYN, SYN-ACK, ACK\npackets with the client (192.168.1.249) to establish a TCP session on Port 80. Once the TCP session is\nestablished, the server sends the Login packet. The contents of the login packet are highlighted in blue\nin Figure 25.\n\nNotice you can clearly see the Gh0st header signature highlighted in yellow in Figure 26. The fourbyte header value highlighted in green is the size of the entire packet compressed, which is 158 bytes\n(Little-endian 0x9e). The magenta header value is the size of the entire packet uncompressed which is\n224 bytes (Little-endian 0xe0).\n\nFigure 26. Gh0st RAT Login packet header.\n\n\n-----\n\nI used a Python script to uncompress the data payload of the Login packet. A hex dump of the\nunencrypted payload is shown in Figure 27.\n\nFigure 27. Gh0st RAT uncompressed Login packet.\n\nThe first byte of the payload contains the Token code. You can see this value, highlighted in yellow, is\n0x66 (102) which is the TOKEN_LOGIN value shown in Table 4. The data immediately following the\nToken code is the binary OSVERSIONINFOEX structure followed by the CPUClockMhz value and the\nbinary IP address. Highlighted in green is the HostName field, which you can clearly see is EeePC. The\nfield highlighted in magenta is the Boolean bIsWebCam value. In this case it is a 0x01, which means this\nhost has a webcam onboard.\n\nOnce the client receives the Login packet, it is uncompressed and parsed. A new row is added to the\nConnections tab grid of the client and the details of the server host are populated in the appropriate\nfields. The number of active connections displayed on the Connections tab grid status bar is incremented\nby 1.\n\nOnce a server has logged it to the client (C2), it waits for commands. When a user of the C2 client\nwants to perform an action on a server, a Command packet is created and sent. To illustrate what a\ncommand packet looks like refer to Figure 28.\n\nFigure 28. Gh0st RAT Command packet.\n\nHere again we see the Gh0st header signature and see the compressed size of the packet is 0x16 (22)\nand the uncompressed size is 0x01 (1). This is a case where compressing the packet works against you.\nYou can see in Figure 29, the uncompressed payload data is one byte with a value of 0x23 (35). Looking\nat Table 4, you see the command is COMMAND_SYSTEM, which is a request for a remote command\nshell (Terminal).\n\n\n-----\n\nFigure 29. Gh0st RAT unencrypted Command payload.\n\nIt should be clear from the above discussion that the Gh0st RAT client and server communicate using\na series of pre-defined Commands, Tokens, and Modes. A network packet contains a 13-byte header\nwith the string Gh0st clearly visible. The data payload of a RAT network packet is compressed using the\nstandard open-source zlib compression library. No encryption is used.\n\nThe communication process is very simple. A Gh0st RAT server connects to a client and sends a Login\npacket containing information about the compromised host. The client adds the server to its connection\ngrid and displays the details of the host. From this point on, the client sends Command request packets\nto the server. The server processes the request and sends back to the client the requested data, whether\nit is remote screen data, voice, video, or more.\n\nGh0st RAT Source Code\nThe Gh0st RAT Beta 3.6 source code was contained in a ZIP file containing 258 files. I found it at a\nsuspicious looking site on the Internet. There was no way for me to determine the original source or the\ncontents of the file. I downloaded it to a Linux box and examined the contents. Initial review identified\nthe structure of the ZIP file contents contained a Microsoft Visual Studio (MSVS) development project.\n\nThe MSVC workspace file identifies it was created with MSVS Version 6.0. Figure 30 below shows the\nstructure of the workspace.\n\nFigure 30. Gh0st Visual Studio workspace.\n\nThe structure of the solution fits perfectly within the Gh0st framework. RESSDT.sys gets compiled into\nSVCHOST.DLL, in the svchost project, the server workhorse of the Gh0st suite. The SVCHOST.DLL gets\ncompiled into INSTALL.EXE created by the install project. Finally, the INSTALL.EXE is compiled into the\nGH0ST.EXE client produced by the gh0st project.\n\nThe svchost project has many source files since this is where most of the Gh0st functionality resides.\nFigures 31 and 32 below show the file composition of the svchost project. Notice at the bottom of the\nfigure the RESSDT.SYS is included in this project because it is added to the projects resource section.\n\n\n-----\n\nFigure 31. Svchost project header files. Figure 32. Svchost project implementation files.\n\nThe install project is much simpler than the svchost project. As you can see in Figure 33 below, the\nsvchost project has one implementation file: install.cpp. The svchost.dll binary is included in this project\nbecause it is placed in the resource section.\n\nRemember, the only role of the INSTALL.EXE program is to provide a dropper mechanism to compromise\na host.\n\nFigure 33. Install project files.\n\n\n-----\n\nOf the three projects, the Gh0st project has the most source files. This is due to the fact the Gh0st\napplication is a Win32 graphical user interface (GUI) project. Most of the source files in this project drive\nthe GUI components of the Gh0st client.\n\nA listing of the project files are shown in Figures 34 and 35 below.\n\nFigure 34. Gh0st project header files. Figure 35. Gh0st project implementation files.\n\n\n-----\n\nAs discussed in previous sections, once the Gh0st project is successfully compiled, there are four binary\nfiles that make up the suite of malware tools: RESSDT.SYS, SVCHOST.DLL, INSTALL.EXE, and GH0ST.EXE.\n\nFigure 36 below shows the resource section of the SVCHOST.DLL. The resource BIN with an ID of 102\ncontains the RESSDT.SYS binary.\n\nFigure 36. SVCHOST.DLL resource section.\n\nFigure 37 shows the resource section of INSTALL.EXE. The resource BIN with an ID of 101 contains the\nSVCHOST.DLL binary.\n\nFigure 37. INSTALL.EXE resource section.\n\n\n-----\n\nFinally, Figure 38 shows the resource section of GH0ST.EXE. It is contained in the resource named BSS\nwith an ID of 173. This resource contains the INSTALL.EXE binary.\n\nFigure 38. GH0ST.EXE resource section.\n\nThe above figures clearly illustrate the power and convenience of hijacking resource sections of a PE\nfile to embed other PE files. This is very common with all types of malware. Good forensic investigators\nshould always check suspicious binaries for embedded PE files.\n\nIt should be noted the Gh0st solution has three external dependencies. First, the svchost and\nGh0st projects link in code from the zlib project’s static library. This makes sense since the network\ncommunication stream between the client and server is compressed using the standard zlib compression\n[algorithm. You can find out more about the zlib project here: http://zlib.net/.](http://zlib.net/)\n\nThe second dependency is in the Gh0st project. It statically links with a Microsoft Foundation Classes\n(MFC) library named CJ60. Research on the web revealed this is an older freeware library of Windows\nGUI helper classes. This includes fancy buttons, toolbars, and list boxes. The below text is from the class\nlibrary main header file. It shows the code library was created between 1998 and 1999 by Kirk Stowell.\n\n“// CJ60Lib.h : header file\n//\n// Copyright  1998-99 Kirk Stowell\n//       mailto:kstowell@codejockeys.com\n//       http://www.codejockeys.com/kstowell/\n//\n// This source code may be used in compiled form in any way you desire.\n// Source file(s) may be redistributed unmodified by any means PROVIDING\n// they are not sold for profit without the authors expressed written consent,\n// and providing that this notice and the author’s name and all copyright\n// notices remain intact. If the source code is used in any commercial\n// applications then a statement along the lines of:\n//\n// “Portions Copyright 1998-99 Kirk Stowell” must be included in the\n// startup banner, “About” box or printed documentation. An email letting\n\n\n-----\n\n// me know that you are using it would be nice as well. That’s not much to ask\n// considering the amount of work that went into this.\n//\n// This software is provided “as is” without express or implied warranty. Use\n// it at your own risk! The author accepts no liability for any damage/loss of\n// business that this product may cause.”\n\nSince the CJ60 code library uses Microsoft’s MFC framework, the third dependency of the Gh0st project\nis the static Microsoft MFC library file nafxcw.lib. Statically linking the MCF library makes the Gh0st binary\nslightly larger, but it removes the requirement of having the right MFC DLL on a compromised host system.\n\nA couple of final notes about the Gh0st solution source code. First, based on the style of the source\ncode, it appears that there were several code writers involved in this project. The coding style is different\nacross the source files. Some source files have many comments, while others have none. Unfortunately,\nall of the comments are illegible in the source code due to failure of accurate code set translation from\nChinese to English.\n\nSecond, there is almost a complete lack of error and/or exception handling in the entire code base. It\nappears that the coders did not want to invest the time into building robust code. In almost all of the\ncode, if a serious error occurs, the application simply exits. If non-fatal errors occur, the code simply\nignores the error and moves on.\n\nGh0st RAT Defenses\nIf you spent time studying this document, you now have a detailed understanding of how sophisticated\nthe Gh0st RAT malware is. Even though the sources for this particular RAT are a few years old, this type\nof malware is in wide use within certain hacking undergrounds. Current variants of the Gh0st RATs use a\nmore sophisticated network communication protocol.\n\nSo how do you defend against a Gh0st RAT? It is certainly not easy—but fundamental security practices\nand knowing what to look for go a long way in defending your infrastructure. I suggest there are six\nthings you can do to identify Gh0st RATs in your enterprise:\n\n1. Put eyes on the wire.\n\n2. Perform regular internal port scans.\n\n3. Monitor your DNS servers.\n\n4. Closely monitor end-node services.\n\n5. Closely monitor end-node event logs.\n\n6. Increase end-user security awareness training.\n\n1. Put eyes on the wire.\n\nI do a great deal of emergency incident response work and am constantly amazed at how many\norganizations lack the ability to closely monitor network traffic at the packet level. IDS/IPS systems\nor solutions that provide deep packet inspection monitoring are a critical component of a competent\nsecurity arsenal. You simply must know what is moving across your networks.\n\nIf you have these technologies in place, detecting the Gh0st RAT examined in this white paper would be\ntrivial due the use of the Gh0st handshake in the packet headers. A simple IDS signature is all you would\nneed. Today’s Gh0st RATs are much more sophisticated and harder to find on the wire.\n\nSome things to look for with your IDS/IPS or network monitoring solutions include:\n\n- Outbound port 80 (HTTP) and 443 (HTTPS) traffic to IP addresses and URLs in the Far East[4]\n\n- Outbound port 80 (HTTP) traffic connecting to remote server without sending user-agent information\n\n- Create IDS signatures to detect the unique data content at the end of the dropper application (for\nexample, AAAAAA or CCCCCC)\n\n- Create IDS signatures to detect embedded PE files within PE files\n\n\n-----\n\nRemember, the modern Gh0st RATs are going to be using a lot more sophisticated network\ncommunications then what is in Gh0st RAT Beta 3.6.\n\n2. Perform regular internal port scans.\n\nOne of the interesting things about Gh0st RATs, is that they tend to establish persistent connections to\na client. This means the compromised host will have open TCP ports that cannot be explained. Routinely\nscanning your internal network for suspicious open ports on systems, particularly workstations, can help\nyou find Gh0st RATs.\n\n3. Monitor your DNS servers.\n\nEvery time I suggest to a client that they should be logging DNS requests, I also get that look followed\nby “You have got to be kidding.” Logging DNS is painful, but it can be invaluable when hunting down\nGh0st RATs. Most modern malware uses dynamic DNS to allow the cybercriminals the most flexibility in\nmoving their RAT clients.\n\nAt the very least, you should configure your DNS servers to log or alert on any requests to dynamic DNS\nlocations. You should also consider logging all DNS requests to sites in the Far East. There are plenty of\nresources available to provide you IP address ranges based on geography as well as list of popular and/or\nmalicious dynamic DNS hosting providers.\n\n4. Closely monitor end-node services.\n\nIn the last few years, there has been a lot of discussion about the increasing use of rootkits by\ncybercriminals. For the purposes of this discussion, I consider a rootkit as malware designed to run in\nRing 0 alongside the kernel. In general, I am talking about device drivers.\n\nIn my experience, most malware today still runs in user-land (Ring 3). Writing device drivers is tedious\nand error-prone. There are also a lot fewer programmers who can write them. Instead, most malware\nauthors write code that abuses the Windows services infrastructure to survive reboot. The result? Most\nmalware runs as a service—hiding in plain sight.\n\nWhenever I am analyzing a host for indicators of compromise, I focus like a laser on installed services.\nYou should too. One of my colleagues recently wrote a tool that scans a network of Windows hosts\nlooking for suspicious services. This tool is very effective at sniffing out malware. I encourage you to\nimplement techniques to monitor what services are running on your systems.\n\n5. Closely monitor end-node event logs.\n\nAs long as you are monitoring services on end nodes, you should also be centrally logging and\nmonitoring Windows event logs. Everybody dislikes dealing with event logs, but as a forensic\ninvestigator, there is gold in that data. I encourage you to turn on auditing and enable logging for\nboth successful and failed logins.\n\nI also recommend you pay particularly close attention to the security event log entries 528 and 540\n(successful logins). Drill down and look for logon types 3 (SMB shares) and 10 (RDP). Finally, identify the\nlogon account.\n\nAlmost all intruders will move laterally across you network, remotely logging onto workstations and\nservers using elevated privileged accounts. They will either connect to another machine via SMB admin\nshares (C$, IPC$, or ADMIN$) or using remote desktop. Either way, you should be monitoring event logs\nfor this activity.\n\n6. Increase end-user security awareness training.\n\nIf I were given just one option to improve an organization’s security posture, it would be an easy choice:\nend-user security awareness training. Why? Because end users are going to be the ones who let the bad\nguys in by falling victim to phishing attacks or URL redirection. They also are going to be the ones to\nalert you when something is wrong.\n\n\n-----\n\n2821 Mission College Boulevard\nSanta Clara CA 95054\n\n\nIn my experience, most serious security incidents are identified in one of three ways: end-user complaints\nto the help desk, alert network security personnel who sense that something is amiss, and notifications\nthat a system has been compromised by a third party.\n\nIf you invest in end-user training, you are enabling every single employee to learn what security threats\nexist and how not to fall prey to them. You are also increasing their sensitivity to report suspicious\ncomputer behavior.\n\nFor example, if an end-user understands the capabilities of Gh0st RAT, they are much less likely to ignore\nmouse cursor movements when they are not at the keyboard. They will also find it very suspicious their\nwebcam light is on when they have no video application open.\n\nSecurity awareness training is one of the best investments you can make to reduce your risk of compromise.\n\nSummary\nIf you made it this far, then you obviously have some interest in understanding the deep internal workings\nof a Gh0st RAT. In this paper, you learned how capable, and dangerous, this genre of malware is. The\nthreat this malware brings to your organization is two-fold. First, once installed on a compromised host, it\nprovides the remote cybercriminal complete remote control of the system. It also evades antivirus and HIPS\ndetection because it does nothing suspicious once the service is installed. It simply starts up at boot time,\nconnects to a remote client on port 80 or 443 and awaits further instructions.\n\nIdentifying outbound network traffic from a Gh0st RAT is also problematic. Since most RATs use HTTP or\nHTTPS communications channels with encrypted payloads, it is very difficult to identify the presence of a\nRAT on the wire.\n\nMy goal in writing this paper is to increase the awareness of these RAT tools, particularly in\nenvironments that are subject to advanced persistent threat (APT) attacks. As always, the best defense\nagainst these tools is to focus on good old security fundamentals.\n\nAbout the Author\n\nMichael Spohn is a principal security consultant at McAfee Foundstone, where he provides incident\nresponse (IR) and digital forensic services to clients. His duties include creating IR management programs,\nanalyzing and testing existing IR plans, conducting forensic investigations, and providing IR and forensic\ntraining. He is also a member of the McAfee Foundstone Emergency IR Team, which provides emergency\nservices to clients when an elevated security breach occurs.\n\nAbout McAfee Foundstone Professional Services\n\nMcAfee Foundstone Professional Services, a division of McAfee, offers expert services and education to\nhelp organizations continuously and measurably protect their most important assets from the most critical\nthreats. Through a strategic approach to security, McAfee Foundstone identifies and implements the right\nbalance of technology, people, and process to manage digital risk and leverage security investments more\neffectively. The company’s professional services team consists of recognized security experts and authors\nwith broad security experience with multinational corporations, the public sector, and the US military.\n\n1 [Kehrer, Paul. “Trustwave’s SpiderLabs Security Advisory TWSL2011-007,” July 2011. https://www.trustwave.com/spiderlabs/advisories/TWSL2011-007.txt](https://www.trustwave.com/spiderlabs/advisories/TWSL2011-007.txt)\n\n2 [Apple. “About the security content of iOS 4.3.5 Software Update for iPhone,” July 2011. http://support.apple.com/kb/HT4824](http://support.apple.com/kb/HT4824)\n\n3 [Apple. “About the security content of iOS 4.2.10 Software Update for iPhone,” July 2011. http://support.apple.com/kb/HT4825](http://support.apple.com/kb/HT4825)\n\n4 [Percoco, Nicholas and Paul Kehrer. “Getting SSLizzard,” August 2011. http://defcon.org/html/defcon-19/dc-19-speakers.html#Percoco](http://defcon.org/html/defcon-19/dc-19-speakers.html#Percoco)\n\nMcAfee, the McAfee logo, and McAfee Foundstone are registered trademarks or trademarks of McAfee, Inc. or its subsidiaries in the\nUnited States and other countries Other marks and brands may be claimed as the property of others The product plans specifications and\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2012/2012.04.10.Gh0st_RAT/Know%20Your%20Digital%20Enemy.pdf"
    ],
    "report_names": [
        "Know Your Digital Enemy"
    ],
    "threat_actors": [
        {
            "id": "ea844ee6-eb12-42c0-8426-11395fe81e6f",
            "created_at": "2022-10-25T15:50:23.300796Z",
            "updated_at": "2025-03-27T02:00:55.434471Z",
            "deleted_at": null,
            "main_name": "Night Dragon",
            "aliases": [
                "Night Dragon"
            ],
            "source_name": "MITRE:Night Dragon",
            "tools": [
                "at",
                "gsecdump",
                "zwShell",
                "PsExec",
                "ASPXSpy",
                "gh0st RAT"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "09a8f8fe-e907-47b4-8709-a97717dde3cc",
            "created_at": "2022-10-25T16:07:23.90252Z",
            "updated_at": "2025-03-27T02:02:10.020919Z",
            "deleted_at": null,
            "main_name": "Night Dragon",
            "aliases": [],
            "source_name": "ETDA:Night Dragon",
            "tools": [
                "ASPXSpy",
                "ASPXTool",
                "Cain & Abel",
                "gsecdump",
                "zwShell"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "020794ec-7315-47de-818c-2032c362fd15",
            "created_at": "2023-01-06T13:46:38.306576Z",
            "updated_at": "2025-03-27T02:00:02.800515Z",
            "deleted_at": null,
            "main_name": "Night Dragon",
            "aliases": [
                "G0014"
            ],
            "source_name": "MISPGALAXY:Night Dragon",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1666716495,
    "ts_updated_at": 1743041651,
    "ts_creation_date": 1331722392,
    "ts_modification_date": 1331722422,
    "files": {
        "pdf": "https://archive.orkl.eu/5dba7529dfdcd435578dad0c219da02da54b28a0.pdf",
        "text": "https://archive.orkl.eu/5dba7529dfdcd435578dad0c219da02da54b28a0.txt",
        "img": "https://archive.orkl.eu/5dba7529dfdcd435578dad0c219da02da54b28a0.jpg"
    }
}