{
    "id": "da8e4956-1f6d-4c1f-929a-4d10e7fa5496",
    "created_at": "2022-10-25T16:48:14.317411Z",
    "updated_at": "2025-03-27T02:08:41.38991Z",
    "deleted_at": null,
    "sha1_hash": "1d77fc297b798189640262c948d9e4a7578dd069",
    "title": "",
    "authors": "",
    "file_creation_date": "2016-07-19T07:56:58Z",
    "file_modification_date": "2016-07-19T07:56:58Z",
    "file_size": 3625584,
    "plain_text": "##### RAMBO: Run-time packer Analysis with Multiple Branch Observation\n\n###### Xabier Ugarte-Pedrero, Davide Balzarotti, Igor Santos, Pablo G. Bringas\n\n\n-----\n\n## Outline\n\n\n## Outline\n\n#### • Why multi-path exploration for packers?\n • Approach\n – Domain-specific optimizations – Heuristics\n • Evaluation\n • Discuss the results\n\n\n-----\n\n## Run-time packers...\n\n\n## Run-time packers...\n\n#### • Widely used by malware authors to obfuscate/\n protect their code\n • 2 main goals\n – Hide the original code from static analysis – Implement anti-analysis methods\n\n • Anti-debug\n • Anti-dump\n • VM / Sandbox / Tool detection\n • Making both automated and manual analysis more\n difficult\n\n\n-----\n\n## Shifting-decode-frames\n\n#### Also known as “partial code revelation” Takes advantage of the limitation of dynamic\n analysis\n – Single path! Decrypt code/data on-demand Prevent “run and dump” Used by certain “advanced” protectors (i.e.\n Armadillo) Presented in academic literature (Bilge et. al.)\n – Compile time function based protection\n\n\n## Shifting-decode-frames\n\n#### • Also known as “partial code revelation”\n • Takes advantage of the limitation of dynamic\n analysis\n – Single path!\n • Decrypt code/data on-demand\n • Prevent “run and dump”\n • Used by certain “advanced” protectors (i.e.\n Armadillo)\n • Presented in academic literature (Bilge et. al.)\n – Compile time function based protection\n\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n## Multi-path exploration...\n\n\n## Multi-path exploration...\n\n#### • Computationally complex\n – Specially with obfuscated (even self-\n modifying) code\n • Does not scale to real-world, large, complex\n malware\n\n\n-----\n\n## Multi-path exploration...\n\n\n## Multi-path exploration...\n\n#### • Computationally complex\n – Specially with obfuscated (even self-\n modifying) code\n • Does not scale to real-world, large, complex\n malware\n\n### Can we apply optimizations to multi-path\n exploration  for this specific use case?\n\n\n-----\n\n## Multi-path exploration\n\n\n## Multi-path exploration\n\n#### • Computationally complex\n – Specially with obfuscated (even self-\n modifying) code\n • Does not scale to real-world, large, complex\n malware\n\n### Can we apply heuristics to multi-path\n exploration  for unpacking this type of packers?\n\n\n-----\n\n## Some intuitions...\n\n\n## Some intuitions...\n\n##### • We do NOT need to explore every single path in the\n binary, just enough paths to uncover all the interesting regions.\n • We do NOT need to understand which are the conditions\n to reach each path (unlike other use-cases, such as vulnerability analysis.\n • We do NOT need to maintain the environment / system\n perfectly consistent. We just need to make sure that the execution is stable enough to uncover the protected regions.\n\n\n-----\n\n## Multi-path exploration\n\n\n## Multi-path exploration\n\n##### • Baseline implementation\n – Based on the concepts presented by Moser et al.\n • Bitblaze platform\n – Dynamic taint analysis (Temu)\n\n • Taint result of function calls:\n – Network/file/argument/time related – Symbolic analysis (Vine)\n\n • Based on Weakest precondition & queries to STP\n • Concrete address for indirect memory accesses – System-level snapshots\n\n • Heavier, but we avoid dealing with system level\n inconsistencies: handles, open files, sockets...\n\n\n-----\n\n## Optimizations\n\n\n## Optimizations\n\n### #1 Partial symbolic execution\n\n##### Only execute certain regions of interest\n### #2 Inconsistent multi-path exploration\n\n##### Ignore path constraints if solver cannot provide a\n solution Give priority to paths that can be solved consistently\n### #3 Sacrifice global consistency\n\n##### Maintain consistency only for the regions of interest\n\n\n-----\n\n## Optimizations\n\n### #4 Discard long traces #5 Bypass blocking API calls #6 String comparisons\n\n##### Our model avoids exploring string comparison API\n calls We taint the output whenever input arguments are\n tainted This relaxes the constraints, allowing certain\n inconsistencies\n\n### The general goal is to simplify symbolic\n\n\n## Optimizations\n\n### #4 Discard long traces #5 Bypass blocking API calls #6 String comparisons\n\n##### Our model avoids exploring string comparison API\n calls We taint the output whenever input arguments are\n tainted This relaxes the constraints, allowing certain\n inconsistencies\n\n### The general goal is to simplify symbolic\n\n\n-----\n\n## General workflow\n\n#### Approach: \n 1. Extract unpacked memory regions (frames)\n – Generically detect the frames & dump at\n the appropriate point\n\n • Prev. work: Deep Packer Inspection 2. Process extracted code (disassemble, compute\n CFG) 3. Find interesting points in the code (specific\n instructions) 4. Compute which paths lead to these points 5. Prioritize these paths during multi-path\n\n\n## General workflow\n\n#### Approach: \n 1. Extract unpacked memory regions (frames)\n – Generically detect the frames & dump at\n the appropriate point\n\n • Prev. work: Deep Packer Inspection 2. Process extracted code (disassemble, compute\n CFG) 3. Find interesting points in the code (specific\n instructions) 4. Compute which paths lead to these points 5. Prioritize these paths during multi-path\n\n\n-----\n\n## General workflow\n\n#### Approach: \n 1. Extract unpacked memory regions (frames)\n – Generically detect the frames & dump at\n the appropriate point\n\n • Prev. work: Deep Packer Inspection 2. Process extracted code (disassemble, compute\n CFG) 3. Find interesting points in the code (specific\n instructions) 4. Compute which paths lead to these points 5. Prioritize these paths during multi-path\n\n\n## General workflow\n\n#### Approach: \n 1. Extract unpacked memory regions (frames)\n – Generically detect the frames & dump at\n the appropriate point\n\n • Prev. work: Deep Packer Inspection 2. Process extracted code (disassemble, compute\n CFG) 3. Find interesting points in the code (specific\n instructions) 4. Compute which paths lead to these points 5. Prioritize these paths during multi-path\n\n\n-----\n\n## Heuristic\n\n\n## Heuristic\n\n#### Decide which paths should be expanded first\n\n • Several paths can trigger the execution of a region\n • We can skip paths that can only lead to regions\n already unpacked\n\n\n-----\n\n## Heuristic\n\n\n## Heuristic\n\n##### Steer the execution to the interesting points:\n\n • JMP & CALL instructions\n – that we have not executed in any run, but: – If they lead to a region that has not been unpacked\n yet\n • CJMP instructions leading to protected regions\n – That have not been executed (but were unpacked) – If we have only explored one of their paths\n • Direct memory access (address not unpacked yet)\n • Indirect calls (explore all the paths to these points)\n • Immediate values that fall in the range of a protected\n memory region (may represent a memory access)\n\n\n-----\n\n## Heuristic\n\n\n## Heuristic\n\n##### Also need to consider inter-procedural CFG:\n\n • Explore all the paths that lead to a function, if it contains\n “points of interest”. Path selection during MPE:\n\n • Breadth First Search\n – Incrementally expand all the paths in the tree – Prioritize other paths over loops\n • Prioritize branches with the lowest number of\n expansions\n • Prioritize paths that can be forced consistently over\n inconsistent ones\n\n\n-----\n\n## Heuristic\n\n\n## Heuristic\n\n##### Last resort: path bruteforcing\n\n • Set maximum number of expansions for each branch.\n • When this limit is reached for all the tainted branches:\n – Force the alternative path of non-tainted branches\n (INCONSISTENT!)\n • Introduces inconsistencies, but can be useful to:\n – Bypass loops or control structures with very\n complex internal logic depending on input\n\n • E.g.: Parsers – In some cases, we just need to jump to some point\n in the code to trigger its unpacking.\n\n\n-----\n\n## Evaluation\n\n\n## Evaluation\n\n#### Case study #1: Backpack + Kaiten IRC Bot\n\n • Compile-time packer proposed by Bilge et al.\n • Function based granularity\n • Kaiten: IRC bot that connects a channel and\n receives commands\n\n\n-----\n\n|Functions unpacked|5/31|11/31|27/31|8/31|\n|---|---|---|---|---|\n|Interesting points|-|52|96|-|\n|Cjmps|-|36|110|-|\n|Snapshots|-|167|544|6015|\n|Tainted-consistent cjmps|-|161|525|5888|\n|Tainted-inconsistent cjmps|-|6|19|127|\n|Untainted cjmps|-|0|40|-|\n|Long traces discarded|-|6|0|-|\n\n\n**Iteration 0** **Iteration 1** **Iteration 2** **No Heur.**\n\n**Functions unpacked** **5/31** **11/31** **27/31** **8/31**\n\n**Interesting points** **-** **52** **96** **-**\n\n**Cjmps** **-** **36** **110** **-**\n\n**Snapshots** **-** **167** **544** **6015**\n\n**Tainted-consistent cjmps** **-** **161** **525** **5888**\n\n**Tainted-inconsistent cjmps** **-** **6** **19** **127**\n\n**Untainted cjmps** **-** **0** **40** **-**\n\n**Long traces discarded** **-** **6** **0** **-**\n\n**Time** **5m** **24m** **1.2h** **8h**\n\n\n-----\n\n## Evaluation\n\n\n## Evaluation\n\n#### Case study #2: Armadillo\n\n • Page based granularity (based on memory\n protection)\n • Protected 2 bots: SDBot, SpyBot.\n\n\n-----\n\n|SDBOT|It. 0|It. 1|It. 2|It. 3|No Heur.|\n|---|---|---|---|---|---|\n|Functions unpacked|2/7|4/7|6/7|7/7|4/7|\n|Interesting points|-|3|2|7|-|\n|Cjmps|-|65|162|264|-|\n|Snapshots|-|14|366|367|3974|\n|Tainted-consistent cjmps|-|13|295|296|3660|\n|Tainted-inconsistent cjmps|-|1|71|71|314|\n|Untainted cjmps|-|0|1|1|-|\n|Long traces discarded|-|1|14|14|-|\n|Time|30m|2.2h|2.8h|3.2h|8h|\n\n\n**SDBOT** **It. 0** **It. 1** **It. 2** **It. 3** **No Heur.**\n\n**Functions unpacked** **2/7** **4/7** **6/7** **7/7** **4/7**\n\n**Interesting points** **-** **3** **2** **7** **-**\n\n**Cjmps** **-** **65** **162** **264** **-**\n\n**Snapshots** **-** **14** **366** **367** **3974**\n\n**Tainted-consistent cjmps** **-** **13** **295** **296** **3660**\n\n**Tainted-inconsistent cjmps** **-** **1** **71** **71** **314**\n\n**Untainted cjmps** **-** **0** **1** **1** **-**\n\n**Long traces discarded** **-** **1** **14** **14** **-**\n\n**Time** **30m** **2.2h** **2.8h** **3.2h** **8h**\n\n\n-----\n\n|SPYBOT|Iteration 0|Iteration 1|Iteration 2|No Heur.|\n|---|---|---|---|---|\n|Functions unpacked|3/9|8/9|9/9|6/9|\n|Interesting points|-|26|1|-|\n|Cjmps|-|163|214|-|\n|Snapshots|-|113|153|4466|\n|Tainted-consistent cjmps|-|17|31|4096|\n|Tainted-inconsistent cjmps|-|96|122|370|\n|Untainted cjmps|-|17|34|-|\n|Long traces discarded|-|9|34|-|\n|Time|30m|3h|2.75h|8h|\n\n\n**SPYBOT** **Iteration 0** **Iteration 1** **Iteration 2** **No Heur.**\n\n**Functions unpacked** **3/9** **8/9** **9/9** **6/9**\n\n**Interesting points** **-** **26** **1** **-**\n\n**Cjmps** **-** **163** **214** **-**\n\n**Snapshots** **-** **113** **153** **4466**\n\n**Tainted-consistent cjmps** **-** **17** **31** **4096**\n\n**Tainted-inconsistent cjmps** **-** **96** **122** **370**\n\n**Untainted cjmps** **-** **17** **34** **-**\n\n**Long traces discarded** **-** **9** **34** **-**\n\n**Time** **30m** **3h** **2.75h** **8h**\n\n\n-----\n\n## Conclusions\n\n\n## Conclusions\n\n### • Plain vanilla multi-path exploration was\n not able to recover the code in a reasonable time (even with partial/ inconsistent exploration)\n • With heuristic:\n – Almost 100% recovery of code / data – Significant reduction of time /\n resources when applying heuristics\n\n\n-----\n\n## Discussion\n\n\n## Discussion\n\n##### • Strong limitations for sample selection\n – For backpack, we needed linux-based source code.\n\n – We needed sufficiently complex samples:\n\n • For Armadillo, several pages of code.\n • Complex parsing routines or logic. – We needed non-packed samples.\n\n • Otherwise, the packer would reveal all the original\n code at once. – Simple malware families execute most the code in a\n single run (we needed bots).\n\n\n-----\n\n## Discussion\n\n###### Technical complexity of protectors may affect multi-path exploration\n\n Calling convention violation\n\n Alternative methods to redirect control flow (push + ret,\n indirect calls, SEH/VEH based…)\n\n Resource exhaustion (intentionally introduce complexity\n to exhaust time-consuming analysis engines such as emulators)\n\n Nanomites (substitute branches by interrupts, compute\n the branch in a separate region of code or process)\n\n\n## Discussion\n\n###### • Technical complexity of protectors may affect multi-path exploration\n\n – Calling convention violation\n\n – Alternative methods to redirect control flow (push + ret,\n indirect calls, SEH/VEH based…)\n\n – Resource exhaustion (intentionally introduce complexity\n to exhaust time-consuming analysis engines such as emulators)\n\n – Nanomites (substitute branches by interrupts, compute\n\n\n-----\n\n# Questions!\n\n\n-----\n\n##### talosintelligence.com\n blog.talosintel.com\n @talossecurity\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        }
    ],
    "references": [
        "https://talos-intelligence-site.s3.amazonaws.com/production/document_files/files/000/000/062/original/RamboDIMVA2016.pdf"
    ],
    "report_names": [
        "RamboDIMVA2016.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716494,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1468915018,
    "ts_modification_date": 1468915018,
    "files": {
        "pdf": "https://archive.orkl.eu/1d77fc297b798189640262c948d9e4a7578dd069.pdf",
        "text": "https://archive.orkl.eu/1d77fc297b798189640262c948d9e4a7578dd069.txt",
        "img": "https://archive.orkl.eu/1d77fc297b798189640262c948d9e4a7578dd069.jpg"
    }
}