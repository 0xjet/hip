{
    "id": "0beeca95-458f-4a2c-8ad0-2097bf303079",
    "created_at": "2023-01-12T14:59:12.468871Z",
    "updated_at": "2025-03-27T02:13:11.73009Z",
    "deleted_at": null,
    "sha1_hash": "a8f00b354e9dcf0b53cfb21e480cb17fcc6800d7",
    "title": "2022-05-04 - Attacking Emotet’s Control Flow Flattening",
    "authors": "",
    "file_creation_date": "2022-05-28T04:01:14Z",
    "file_modification_date": "2022-05-28T04:01:14Z",
    "file_size": 1837955,
    "plain_text": "# Attacking Emotet’s Control Flow Flattening\n\n**[news.sophos.com/en-us/2022/05/04/attacking-emotets-control-flow-flattening/](https://news.sophos.com/en-us/2022/05/04/attacking-emotets-control-flow-flattening/)**\n\nAndreas Klopsch May 4, 2022\n\nEmotet has been one of the most professional and long-lasting cybercrime services and\nmalware infections in the threat landscape. Notorious since shortly after its debut in 2014, the\nbotnet was disrupted in January 2021 by a multinational law enforcement effort that sidelined\nits activity for almost a year. Unfortunately, in November 2021 the botnet re-emerged and\nonce again began to appear on Sophos’ radar.\n\nTo protect our customers, SophosLabs is always looking for the most significant techniques,\ntactics, and procedures used to distribute and deliver Emotet. In this post, we’ll look at Control\nFlow Flattening (CFF), one of several obfuscation tactics Emotet’s developers use to make\ndetection and reverse engineering of the malware’s payload more difficult. We’ll provide a\nbrief example of CFF applied to a simple hello-world program, and then discuss how Sophos\nresearchers address CFF in Emotet’s code. We’ll finish by summarizing the challenges and\nproblems we encountered during research.\n\nEmotet’s internals have been covered by many researchers, but we have not seen\ndiscussions on de-obfuscating its use of Control Flow Flattening so far.\n\n\n-----\n\n**Emotet: Resurgence and Tenacity**\n\nFigure 1 shows the volume of Emotet payloads detected in our sandbox systems in the first\nquarter of 2022. As the chart shows, we receive multiple Emotet submissions daily; we\nbelieve that the recurring larger spikes result from large-scale campaigns being kicked off by\nthe malware’s distributors. This is a sensible assumption; Emotet is mainly distributed via\nemail spam, and more malicious emails naturally lead to more sandbox submissions.\n\n_Figure 1: Timeline of 2022 Emotet detections in SophosLabs’ sandbox systems_\n\nIn addition to Emotet’s delivery mechanism and prevalence, we also analyze the final payload\nin depth. Thus, we noticed Control Flow Flattening in an unpacked Emotet sample. Control\nFlow Flattening hides program flow by putting all function blocks next to each other. It is a\nwell-known obfuscation technique used to conceal the purpose of software. While extracting\nthe original code from a flattened binary is inherently challenging, we have successfully\nadapted some existing toolsets to deobfuscate the majority of Emotet payload functionality.\n\n**What is Control Flow Flattening?**\n\nControl Flow Flattening is a technique that aims to obfuscate program flow by taking away tidy\nprogram structures in favor of putting the program blocks inside a loop with a single switch\nstatement controlling program flow.\n\nFirst, the body of the function is broken into basic blocks, and then the blocks are put next to\neach other on the same level. A visualization of this transformation can be seen in Figure 2.\nControl Flow Flattening can be combined with other obfuscation techniques, such as API\nHashing or String Encryption. Some of the most prominent obfuscators for flattening functions\nare [OLLVM and](https://github.com/obfuscator-llvm/obfuscator/wiki) [Tigress.](http://tigress.cs.arizona.edu/)\n\n\n-----\n\n_Figure 2: Comparing a flattened and non-flattened control flow graph (CFG)_\n\nLet’s take a quick look at a simplified example of CFF in action.\n\n**Flattening Hello World**\n\nFor demonstration purposes, we’ve compiled a simple program written in C. On the left side of\nFigure 3, an annotated control flow graph (CFG) of the binary is shown. On the right side you\ncan see the decompiled output generated by the Hex-Rays Decompiler.\n\nIn this figure, no obfuscation techniques have been applied. The Hex-Rays Decompiler has\nno trouble generating an easy-to-read high-level language representation of the disassembly.\nEven without a decompiler, an experienced reverse engineer can simply follow the control\nflow graph to understand its purpose.\n\n\n-----\n\n_Figure 3: Control Flow Graph and decompiled output of sample program_\n\nNow we’ll flatten the function and compare the results. Figure 4 displays the CFG and\ndecompiled output after Control Flow Flattening was applied. On the left side, we see that the\nnumber of basic blocks has more than doubled, and reading the decompiled output is not\npossible any more without spending a significant amount of time analyzing it.\n\n_Figure 4: Annotated example of a flattened function_\n\nOverall, CFF introduces the following problems to hamper our analysis:\n\nThe control flow is concealed. Instead of being able to follow the blocks, a control flow\ndispatcher block is implemented. This block determines which blocks are executed next.\nA state variable annotated as `stateVar` in the decompiled output is updated with high\nentropy variables throughout the function. The state variable is used by the control flow\ndispatcher to decide which block gets executed next.\nThe two problems above lead to a highly complex decompiled output. While it is still\npossible to follow the execution flow, the time and effort needed to understand the\nfunction is significantly larger than it would be compared to the decompiled output in\nFigure 3.\n\n**Unflattening Emotet**\n\nTo deobfuscate Emotet’s use of Control Flow Flattening, we started with a review of existing\ntools and research on CFG deobfuscation. Some of those include:\n\n[Hex-Rays Microcode API vs. Obfuscating Compiler by Rolf Rolles](https://hex-rays.com/blog/hex-rays-microcode-api-vs-obfuscating-compiler/)\n[Defeating Compiler-Level Obfuscations used in APT10 Malware by VMWare’s Threat](https://blogs.vmware.com/security/2019/02/defeating-compiler-level-obfuscations-used-in-apt10-malware.html)\nAnalysis Unit\n[Deobfuscation: recovering an OLLVM-protected program by Francis Gabriel of](https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html)\nQuarkslab\n[D810: A journey into control flow unflattening by Boris Batteaux of eShard](https://eshard.com/posts/D810-a-journey-into-control-flow-unflattening)\n\n\n-----\n\nFor deeper dives into the algorithm behind CFG Unflattening, the articles referenced above\nprovide a wealth of information.\n\nIn Figure 5 you can see the decompiled output and CFG of a function in an unpacked Emotet\nsample. Excluding the Control Flow Flattening applied here, the output might seem confusing,\nbecause Emotet applies more than just one obfuscation technique. (If you are not familiar with\nthose other techniques, an appendix at the end of this article briefly explains the other\nobfuscation techniques .)\n\nFirst, the function calls OpenSCManagerA to retrieve a handle to the Service Control\nManager. Next, it calls OpenServiceW to open an existing service. If opening the service\nsucceeds, the opened service will be deleted via DeleteService. Finally, the opened handles\nwill be closed. If the service was deleted successfully, the function returns 1, otherwise 0.\n\n_Figure 5: Annotated example of a flattened function_\n\nIf we compare the decompiled output of Figure 3 and Figure 4, we can see multiple\nsimilarities, and we can identify the CFG dispatcher again. In the decompiled output, we see a\nvariable we annotated as `stateVar . Like the output in Figure 3, this is our state variable`\nthat is constantly updated and used by the dispatcher to determine which block is executed\nnext.\n\nOn a high level, if we want to restore the control flow, we need to:\n\n1. Identify the dispatcher block and states\n2. For each block, identify the corresponding constant and find the address of the next\n\nblock to execute based on dispatcher and state variable value\n3. Patch the outbound dispatcher blocks to jump to the address of the original next block\n\n\n-----\n\nInstead of patching and operating on the disassembly directly, we make use of the Hex-Rays\nMicrocode API. Microcode is an intermediate language used by the Hex-Rays decompiler.\nDuring decompilation, the decompiler steps through different maturity phases. The different\nphases are displayed in Figure 6 below. The API allows us to hook the decompilation\nprogress and operate on the microcode instead of patching the disassembly directly.\n\n_Figure 6: IDA Microcode maturity levels_\n\n**Adjusting the Tool**\n\nWe used an IDAPython fork of the Rolf Rolles’ HexRaysDeob tool as our foundation. Like the\nfork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure\nabove. As seen in Figure 6, that maturity level includes information about inbound and\noutbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the\noriginal code was based around the MMAT_LOCOPT layer. Changing the layer would have\nrequired plenty more investigation, verification, and adjustments of the existing code than\nkeeping the layer. Below is a summarization of changes we applied on the existing code base.\n\n**Handling Multiple/Related Dispatchers**\n\nIn multiple functions, running the deobfuscation algorithm on a single dispatcher did not\ngenerate an output we were satisfied with. Analysis showed that more complex functions\nmight contain multiple nested dispatchers instead of one. We added additional logic to identify\nand run the algorithm on multiple dispatchers. This option can be turned on or off by setting\nthe RUN_MLTPL_DISPATCHERS flag to True or False. In Figure 7 below, you can see an\nexample of a function with two potential dispatchers.\n\n\n-----\n\n_Figure 7: Example of a function with two potential dispatchers_\n\n**Risky Search for the Cluster Head**\n\nA flattened block might be implemented by multiple microcode blocks. To find the end of the\nregion, the original algorithm by Rolf Rolles generates a dominator tree and uses the\ngenerated information to determine the end of a region, or the beginning of a cluster. In some\ncases, the algorithm failed to find the cluster head. We added an additional function to\ndetermine the cluster head as a fallback. We believe that the original algorithm by Rolf Rolles\nis more reliable; however, evaluation showed that the fallback algorithm still led to good\nresults and improved the decompiled output.\n\n**Adding Additional Patterns and Small Code Updates**\n\nIn some cases, the existing logic failed in patching all flattened blocks. After analyzing multiple\nfunctions, we identified various patterns that reoccurred throughout the whole binary. We\nadded additional logic to identify and unflatten blocks following these patterns to the existing\ncode base. Finally, we adjusted the overall code a little. Some of the changes include:\n\nThe IDAPython fork of Rolf Rolles´ HexRaysDeob tool was based on Python2.7. We\nupdated several parts of the code to match Python3 standards.\n\n\n-----\n\nIn the original version of the tool, if the run function was invoked once, the plugin got\nactivated and if the tool determined the function as flattened via an algorithm, it\nattempted to unflatten it. During implementation and testing, we experienced crashes of\nIDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB\ndatabase. As an additional safety mechanism, the address of the target function must\nbe added to the array “white_list” to allow unflattening. Overall, we recommend saving\noften and keeping a separate IDB copy when using the tool.\n\nOut of 254 functions, we categorized 68 functions as flattened. From these 68 functions, we\nwere able to unflatten 38 successfully. Nineteen functions were partially flattened, and 11\nfunctions failed. By “unflattened successfully,” we mean cases in which our script failed to\nunflatten a maximum of 3 states. “Partially unflattened” means that most of the function\nremains flattened, but our tool was able to unflatten some blocks. Finally, “failed” means that\nwe were not able to deobfuscate a single block in the function.\n\nFigure 8 below shows the function from Figure 5 after our script was applied.\n\n_Figure 8: Analyzed function after the CFG unflattening tool was applied_\n\n**IoCs**\n\n**Description** **SHA256**\n\n\n-----\n\nPacked\nEmotet\n\nUnpacked\nEmotet\n\n\n**9a0286ec0a3e7ea346759c9497c8b5c7c212fa2c780a1cabb094134bf492a51b**\n\n1bbce395c839c737fdc983534b963a1521ab9693a5b585f15b8a4950adea5973\n\n\n[Our unflattening tool is now available on the SophosLabs Github. (For those interested in](https://github.com/sophoslabs/emotet_unflatten_poc)\n[such things, we also recommend to your attention a CFF-unpacking tool released by ESET](https://github.com/eset/stadeo)\nseveral years back to address control-flow flattening in the Stantinko botnet – another\nexample of why, since attackers freely share tactics, techniques, and procedures among\nthemselves, defenders are wise to do the same.)\n\n**Conclusion and Limitations**\n\nControl Flow Flattening is a complex topic, and the purpose of this article is to share our\nexperience and results attacking Emotet’s Control Flow Flattening. While we made multiple\nadjustments and met with some success, our solution is not able to deobfuscate all functions\ncompletely. Among the outstanding issues:\n\nThe algorithm to detect nested dispatchers is simple. Therefore, we have added an\noption to turn it on and off. In rare cases, a faulty output is generated if the nested\ndispatcher is enabled.\nIn many functions, we had to deal with conditional states. Depending on the outcome of,\nfor example, a WINAPI function, the state variable changes to a different value at\nruntime. Additional patching and insertion of microcode instructions would be needed to\nunflatten these conditional blocks.\nOur main approach was to add logic for reoccurring patterns in the binary. As our work\nprogressed, we realized that a microcode emulator might have been a better choice, or\nwould have been an adjustment that led to more unflattened blocks.\nDuring development and evaluation, we experienced multiple crashes. We are all\nhumans and we make mistakes, so some crashes will result from bugs in our code.\nHowever, judging from the error messages, we believe that there is a deeper-rooted\nproblem in the Python port of the Microcode API. Therefore, we recommend saving\noften and keeping a copy of the IDB file.\n\nOverall, we recommend that researchers always cross-check their results and not trust the\noutput blindly. Control Flow Flattening used in conjunction with other obfuscation techniques\ncertainly complicates the process of reverse engineering Emotet, but the technique we’ve\ndescribed helps to even the odds against researchers examining this high-profile malware.\n\n## Appendix: Emotet and Code Obfuscation\n\n\n-----\n\nWhen sharing the decompiled output of functions in an Emotet sample, it is impossible not to\nencounter other Emotet obfuscation techniques beyond CFF. This appendix covers the most\nprevalent obfuscation techniques we have identified in an unpacked Emotet sample. Keep in\nmind that Emotet is usually delivered in a packed form and needs to be unpacked first.\n\n**String Encryption**\n\nEmotet contains encrypted strings in its unpacked form. Before usage, strings will be\ndecrypted and freed again right after each serves its purpose.\n\n_Figure 9: Cross references of DecryptString function with corresponding decrypted string_\n\n**API Hashing**\n\nEmotet uses API Hashing to conceal the usage of API functions. The malware calculates the\nhash of exported function names for a given DLL. If the calculated hash matches the constant\npushed onto the stack at method invocation, the pointer to the exported function will be\nretrieved.\n\n_Figure 10: Disassembly of ApiHash function invocation_\n\n\n-----\n\nIn most cases, API Hashing calls and their corresponding dynamic call are wrapped into\nseparate functions. We have automated this analysis, and functions with prefix DYN_ are\nfunctions determined at runtime via API Hashing.\n\n**Junk Instructions**\n\nEmotet embeds junk instructions to confuse reverse engineers. Junk instructions are\ninstructions that do not serve any purpose except to complicate and slow down analysis.\nFigure 11 below shows an example of a junk instruction block.\n\n_Figure 11: Example of junk instructions in unpacked Emotet sample_\n\n**Stack Obfuscation**\n\nAnother interesting technique that confuses the IDA decompiler is the way in which Emotet\npasses parameters to functions. In Figure 12 below, we show how DYN_BCryptEncrypt is\ninvoked.\n\nDYN_BCryptEncrypt first resolves the API function BCryptEncrypt and stores the pointer to\nthis function in register EAX. The function is then called via call EAX. Instead of just pushing\nthe necessary parameters, this method pushes values onto the stack not being used by the\nactual EAX call. This leads to generation of a function signature that is much harder to read\nthan normal.\n\n\n-----\n\n_Figure 12: Multiple values being pushed onto the stack before DYN_BCryptEncrypt is invoked_\n\n_Figure 13: Corresponding generated function signature_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-05-04 - Attacking Emotet’s Control Flow Flattening.pdf"
    ],
    "report_names": [
        "2022-05-04 - Attacking Emotet’s Control Flow Flattening.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "ec14074c-8517-40e1-b4d7-3897f1254487",
            "created_at": "2023-01-06T13:46:38.300905Z",
            "updated_at": "2025-03-27T02:00:02.799108Z",
            "deleted_at": null,
            "main_name": "APT10",
            "aliases": [
                "TA429",
                "STONE PANDA",
                "POTASSIUM",
                "Red Apollo",
                "HOGFISH",
                "Cloud Hopper",
                "BRONZE RIVERSIDE",
                "ATK41",
                "G0045",
                "Menupass Team",
                "happyyongzi",
                "CVNX",
                "Granite Taurus"
            ],
            "source_name": "MISPGALAXY:APT10",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "ba3fff0c-3ba0-4855-9eeb-1af9ee18136a",
            "created_at": "2022-10-25T15:50:23.298889Z",
            "updated_at": "2025-03-27T02:00:55.433541Z",
            "deleted_at": null,
            "main_name": "menuPass",
            "aliases": [
                "menuPass",
                "POTASSIUM",
                "Stone Panda",
                "APT10",
                "Red Apollo",
                "CVNX",
                "HOGFISH",
                "BRONZE RIVERSIDE"
            ],
            "source_name": "MITRE:menuPass",
            "tools": [
                "certutil",
                "FYAnti",
                "UPPERCUT",
                "SNUGRIDE",
                "P8RAT",
                "RedLeaves",
                "SodaMaster",
                "pwdump",
                "Mimikatz",
                "PlugX",
                "PowerSploit",
                "ChChes",
                "cmd",
                "QuasarRAT",
                "AdFind",
                "Cobalt Strike",
                "PoisonIvy",
                "EvilGrab",
                "esentutl",
                "Impacket",
                "Ecipekac",
                "PsExec",
                "HUI Loader"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "ba9fa308-a29a-4928-9c06-73aafec7624c",
            "created_at": "2024-05-01T02:03:07.981061Z",
            "updated_at": "2025-03-27T02:05:17.28602Z",
            "deleted_at": null,
            "main_name": "BRONZE RIVERSIDE",
            "aliases": [
                "CTG-5938 ",
                "CVNX ",
                "Hogfish ",
                "MenuPass ",
                "POTASSIUM ",
                "Red Apollo ",
                "Stone Panda ",
                "APT10 "
            ],
            "source_name": "Secureworks:BRONZE RIVERSIDE",
            "tools": [
                " ChChes",
                " Cobalt Strike",
                " PlugX",
                " PoisonIvy",
                " QuasarRAT",
                " QuasarRAT Loader",
                " RedLeaves",
                "ANEL"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535552,
    "ts_updated_at": 1743041591,
    "ts_creation_date": 1653710474,
    "ts_modification_date": 1653710474,
    "files": {
        "pdf": "https://archive.orkl.eu/a8f00b354e9dcf0b53cfb21e480cb17fcc6800d7.pdf",
        "text": "https://archive.orkl.eu/a8f00b354e9dcf0b53cfb21e480cb17fcc6800d7.txt",
        "img": "https://archive.orkl.eu/a8f00b354e9dcf0b53cfb21e480cb17fcc6800d7.jpg"
    }
}