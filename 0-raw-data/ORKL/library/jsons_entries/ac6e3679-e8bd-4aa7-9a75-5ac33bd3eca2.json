{
    "id": "ac6e3679-e8bd-4aa7-9a75-5ac33bd3eca2",
    "created_at": "2023-01-12T15:05:23.475664Z",
    "updated_at": "2025-03-27T02:16:25.896237Z",
    "deleted_at": null,
    "sha1_hash": "998c16115848585d6526250191de0eb35f8e0885",
    "title": "2019-07-18 - Android Malware Analysis - Dissecting Hydra Dropper",
    "authors": "",
    "file_creation_date": "2022-05-27T22:13:00Z",
    "file_modification_date": "2022-05-27T22:13:00Z",
    "file_size": 1998246,
    "plain_text": "# Android Malware Analysis : Dissecting Hydra Dropper\n\n**[pentest.blog/android-malware-analysis-dissecting-hydra-dropper/](https://pentest.blog/android-malware-analysis-dissecting-hydra-dropper/)**\n\nAhmet Bilal Can July 18, 2019\n\n[Hydra is another android bankbot variant. It uses overlay to steal information like Anubis . Its name](https://eybisi.run/Mobile-Malware-Analysis-Tricks-used-in-Anubis/)\ncomes from [command and control panel. Through July 2018 to March 2019 there was atleast 8-10](https://twitter.com/PRODAFT/status/1096458491852664840)\nsample on Google Play Store. Distribution of malware is similar to Anubis cases. Dropper apps are\nuploaded to Play Store. But unlike Anubis, Dropper apps extract dex file from png file with kinda\nstenography and downloads malicious app from command and control server with dropped dex.\n[You can find the sample that I will go through in this post here : Dropper](https://koodous.com/apks/46aeb04f2f03ebe7c716fc6e58a5dea763cd9b00eb7a466d10a0744f50a7368f/comments)\n\nToC:\n\nBypass checks that on the java side\nGDB Debug\nGhidra shenanigans\nUnderstanding creation of the dex file\nBonus\n\nFirst of all, if the dropper app likes the environment it runs, it will load the dex file and connect to\nthe command and control server. There are multiple checks on java and native side. We will debug\nthe native side with gdb and use ghidra to help us to find checks and important functions.\n\n## Time Check\n\nWhen we open the first app with jadx we can see time check in class\n\n```\ncom.taxationtex.giristexation.qes.Hdvhepuwy.\n\n```\n\n-----\n\n```\npublic static boolean j() {\n    return new Date().getTime() >= 1553655180000L && new Date().getTime() <=\n1554519180000L;\n}\n\n```\nThis function called in another class : com.taxationtex.giristexation.qes.Sctdsqres\n```\nclass Sctdsqres {\n  private static boolean L = false;\n  private static native void fyndmmn(Object obj);\n  Sctdsqres() {\n  }\n  static void j() {\n    if (Hdvhepuwy.j()) {\n      H();\n    }\n  }\n  static void H() {\n    if (!L) {\n      System.loadLibrary(\"hoter\");\n      L = true;\n    }\n    fyndmmn(Hdvhepuwy.j());\n  }\n}\n\n```\nFirst, it checks the time and if the condition holds, the app will load the native library and call\n```\nfyndmmn(Hdvhepuwy.j()); which is native function. We need to bypass this check so app will\n\n```\nalways load the library.\n\nI used `apktool to disassemble apk to smali and changed` `j() to always return true.`\n\napktool d com.taxationtex.giristexation.apk\ncd com.taxationtex.giristexation/smali/com/taxationtext/giristexation/qes\nedit j()Z in Hdvhepeuwy.smali\n```\n.method public static j()Z\n  .locals 1\n  const/4 v0, 0x1\n  return v0\n.end method\n\n```\nrebuild apk with `apktool b com.taxationtex.giristexation -o hydra_time.apk and sign`\nit.\n\nNow time control will always return true and after loading native library and `fyndmmn native`\nfunction is called. Even with this still app doesnâ€™t load dex file.\n\n## GDB Debug\n\n[Here is a great post explaining how to setup gdb to debug native libraries. Steps:](https://packmad.github.io/gdb-android/)\n\n[Download android sdk with ndk](https://dl.google.com/android/repository/android-ndk-r20-linux-x86_64.zip)\n\n\n-----\n\nadb push ~android-ndk-r20/prebuilt/android-TARGET-ARCH/gdbserver/gdbserver\n/data/local/tmp\nadb shell â€œchmod 777 /data/local/tmp/gdbserverâ€\nadb shell â€œls -l /data/local/tmp/gdbserverâ€\nget process id, ps -A | grep com.tax\n/data/local/tmp/gdbserver :1337 â€“attach $pid\nadb forward tcp:1337 tcp:1337\ngdb\ntarget remote :1337\nb Java_com_tax\\TAB\n\nThere is a small problem here. App will load the library and call the native function and exit. The\napp needs to wait for gdb connection. My first thought was putting sleep and then connect with\ngdb.\n\napktool d hydra_time.apk\nvim\nhydra_time/com.taxationtex.giristexation/smali/com/taxationtex/giristexation/qes/Sctdsqres.smali\n\nafter following block:\n```\n.line 43\n:cond_0\n\n```\nAdd\n```\nconst-wide/32 v0, 0xea60\ninvoke-static {v0, v1}, Landroid/os/SystemClock;->sleep(J)V\n\n```\nand since `locals variable is 1 and we use an extra v1 variable, increment it to 2`\n```\n.method static H()V\n  .locals 2\n\n```\nAgain sign and install the app. If all goes well the app will wait 60 seconds in a white screen. Now\nwe can connect with gdb.\n```\nps | grep com.tax\n/data/local/tmp/gdbserver :1337 --attach $pid\n\n```\nI use pwndbg for better gdb experience, you can try peda or whatever you want.\n\nadb forward tcp:1337 tcp:1337\ngdb\ntarget remote :1337\n\n\n-----\n\ndebug session\nIt takes some time to load all libraries. Put breakpoint to native function `fymdmmn`\n\n\n-----\n\nset breakpoint\nIf you want to sync gdb and ghidra addresses, type vmmap at gdb and look for first entry of\n```\nlibhoter.so .\n0xe73be000 0xe73fc000 r-xp 3e000 0 /data/app/com.taxationtex.giristexation1/lib/x86/libhoter.so\n\n```\nSo `0xe73be000 is my base address.`\n\nGo to `Window ->` `Memory Map and press` `Home icon on the upper right. Put your base address`\nand rebase the binary.\n\nLook at the entry of native function in ghdira:\n\n\n-----\n\nfyndmmn function\n\nWhy call the time function ? Again time check ? Rename return value of time function (curr_time)\nand press `ctrl+shift+f from assembly view and go to location that context is` `READ`\n```\nreturn (uint)(curr_time + 0xa3651a74U < 0xd2f00)\n\n```\nSo we were right, again time check. Rename the current function to `check_time . Calculate the`\nepoch time:\n```\n>>> 0xffffffff-0xa3651a74+0xd2f00\n>>> 1554519179\n>>> (1554519179+ 0xa3651a74) & 0xffffffff < 0xd2f00\n>>> True\n\n```\nconvert epoch to time : Saturday, April 6, 2019 2:52:59 AM\nYep this was the time that app was on play store. Check how this boolean is used. Look for xrefs\nof `check_time function.`\n\nYep, as we think it will exit if time doesnâ€™t hold.\nFirst breakpoint/binary patch point is here. Or we can change emulator/phoneâ€™s time to April 5\n2019.\n```\nb *(base + 0x8ba8)\n\n```\nBut bypassing time check is not enough.\n\n## Ghidra Shenanigans\n\nNow diving into binary file you will find multiple functions like this :\n\n\n-----\n\nIf you look at while loop.\n\n\ndecryption blocks\n\nxor while loop\n\n\n2 blocks of data are XORed. ( Length 0x18) We can put breakpoint after do while but it will not be\nefficient solution. Letâ€™s think a programmatic way to find decrypted strings.\nThese xor blocks are next to each other. If we can get length of blocks we can easily get decrypted\nstring. Then find the function that use these xor blocks and rename it. Afterwards we can jump\n```\n2*length and get next xor blocks. Repeat.\n\n```\nStarting xor block is at `0x34035 .`\nGet xrefs of block:\n\n\n-----\n\nxor block\n\n\ngo to function,\n\nget\n\ncmp value\nget size from CMP instruction, since we know the address of first xor block, add size to first\naddress and get the address of second xor block. XOR the blocks and rename the calling function.\n\nGhidra : go to `Window ->` `Script Manager ->` `Create New Script ->` `Python .`\nSet name for script and letâ€™s write our ghidra script.\n\n\n-----\n\n```\nimport ghidra.app.script.GhidraScript\nimport exceptions\nfrom ghidra.program.model.address import AddressOutOfBoundsException\nfrom ghidra.program.model.symbol import SourceType\ndef xor_block(addr,size):\n     ## get byte list\n     first_block = getBytes(toAddr(addr),size).tolist()\n     second_block = getBytes(toAddr(addr+size),size).tolist()\n     a = \"\"\n     ## decrypt the block\n     for i in range(len(first_block)):\n          a += chr(first_block[i]^second_block[i])\n    ## each string have trash value at the end, delete it\n     trash = len(\"someval\")\n     return a[:-trash]\ndef block(addr):\n  ## block that related to creation of dex file. pass itt\n     if addr == 0x34755:\n          return 0x0003494f\n     ## get xrefs\n     xrefs = getReferencesTo(toAddr(addr))\n     if len(xrefs) ==0:\n          ## no xrefs go to next byte\n          return addr+1\n     for xref in xrefs:\n          ref_addr = xref.getFromAddress()\n          try:\n              inst = getInstructionAt(ref_addr.add(32))\n          except AddressOutOfBoundsException as e:\n              print(\"Found last xor block exiting..\")\n              exit()\n  ## Get size of block with inst.getByte(2)\n          block_size = inst.getByte(2)\n  ## decrypt blocks\n          dec_str = xor_block(addr,block_size)\n  ## get function\n          func = getFunctionBefore(ref_addr)\n          new_name = \"dec_\"+dec_str[:-1]\n  ## rename the function\n          func.setName(new_name,SourceType.USER_DEFINED)\n  ## log\n          print(\"Block : {}, func : {}, dec string :\n{}\".format(hex(addr),func.getEntryPoint(),dec_str))\n     return addr+2*block_size\ndef extract_encrypted_str():\n     ## starting block\n     curr_block_location = 0x34035\n     for i in range(200):\n          curr_block_location = block(curr_block_location)\n\n```\n\n-----\n\n```\ndef run():\n     extract_encrypted_str()\nrun()\n\n```\nTo run the script, select created script in `Script Manager and press Run.`\nNow look at the output.\n\nghidra script output\nAs you can see there are functions : `getSimCountryISO,` `getNetworkCountryIso,`\n```\ngetCountry and one suspicious string : tr . Without running we can assume code will check if\n\n```\nthese functionâ€™s return values are equals to `tr . I know this app targets Turkish people so this is`\nreasonable to avoid sandbox and even manual analyze.\n\nIf you follow from these functionsâ€™ xrefs to function `FUN_00018A90() (called after time check) you`\ncan see this block :\n\ncountry check\n\nSo next patch/breakpoint is this check :\n\n```\nb *(base + 0x8c80)\n\n```\n\nAfter these checks code will drop dex and load it. If you run without patch/breakpoints only\n```\nedevlet page is shown and nothing happens. Get your base address and try bypassing checks :\n\n```\n\n-----\n\n```\nb (base 0x8ba8)\nb *(base + 0x8c80)\ncopy eip : .... a8 -> set $eip = .... aa\nc\ncopy eip : .... 80 -> set $eip = .... 82\nc\n\n```\nAfter these breakpoints, app will create dex file and load it. You will see Accessibility page pop-pup\nif you do it correctly.\n\nchecks bypassed\nOr we can patch `je instructions to` `jne in native library and build apk again.`\n\n## Understanding creation of the dex file\n\nIf you look for dropped file in filesystem, you wonâ€™t see anything. File is removed with `remove .`\nWe can attach frida and catch dropped file easily. But forget about it for now and find how png file\nis used to create dex file.\n\nLook at the last parts of the ghidra scriptâ€™s output.\n\n\n-----\n\nghidra script output\nSomehow `prcnbzqn.png is processed with` `AndroidBitmap and dex file is created with the`\nname `xwchfc.dex . Then with` `ClassLoader API dex file is loaded and`\n```\nmoonlight.loader.sdk.SdkBuilder class is called.\n\n```\nCheck function : `0xeec0`\n\nget png\n\nfile from asset folder\nIterates over assets and finds png file. Good. Rename this function `asset_caller . Go to xrefs of`\nthis func and find `0xe2c0 . I renamed some of functions.` `dex_header creates dex file on`\nmemory. `dex_dropper drops dex file to system and loads.`\n\n\n-----\n\nhierarchy of functions\nHow dex_header creates dex file ? Go to function definition.\n\ndex creator function\n```\nbitmap_related creates bitmap from png file. Bitmap object is passed to dex_related\n\n```\nfunction. Bitmap ?\n\nIf you read png file byte byte you donâ€™t get color codes of pixels directly. You need to convert it to\nbitmap. So app first transfer png file to bitmap and read hex values of pixels. Fire up gimp/paint\nand look at the hex codes of first pixel of the image and compare with below picture ðŸ™‚\n\nrgb values of pixels\n\n\n-----\n\nNow comes fun part. How these values are used. At `0xfbf0 you can find` `dex_related`\nfunction.\n\nBitmap object is passed to this function. Now there are 2 important functions here:\n\nimportant function\n\n\ntwo\n\n```\nbyte_chooser will return one byte and dex_extractor will use that byte to get final dex bytes.\n4_cmp variable is set to 0 at the beginning and will set to 0 at the end of else block. So flow will\n\n```\nhit `byte_chooser 2 times before entering` `dex_extractor . Here is` `byte_chooser`\n\nbyte chooser function\nparam_3 is hex codes of pixels. param_2 is like seed. If its first call of byte_chooser it is set to 0. In\nsecond call of byte_chooser, param_2 will be return value of first call and left shifted by 4. Then its\nset to 0 at the end of else block.\n\nAfter calculating the byte by calling byte_chooser twice, return value is passed to\n```\ndex_extractor .\n\n```\ndex byte calculator function\nparam_2 is calculated byte param_1 is index.\n\nNow we know how the dex file is created. Letâ€™s do it with python\n\n\n-----\n\n```\nfrom PIL import Image\nimport struct\nimage_file = \"prcnbzqn.png\"\nso_file = \"libhoter.so\"\noffset = 0x34755\nsize = 0x1fa\noutput_file = \"drop.dex\"\nim = Image.open(image_file)\nrgb_im = im.convert('RGB')\nim_y = im.size[1]\nim_x = im.size[0]\ndex_size = im_y*im_x/2-255\nf = open(so_file)\nd = f.read()\nd = d[offset:offset+size]\ndef create_magic(p1,p2,p3):\n     return (p1<<2 &4 | p2 & 2 | p2 & 1 | p1 << 2 & 8 | p3)\ndef dex_extractor(p1,p2):\n     return (p1/size)*size&0xffffff00| ord(d[p1%size]) ^ p2\ncount = 0\ndex_file = open(output_file,\"wb\")\nsecond = False\nmagic_byte = 0\nfor y in range(0,im.size[1]):\n     for x in range(0,im.size[0]):\n          r, g, b = rgb_im.getpixel((x, y))\n          magic_byte = create_magic(r,b,magic_byte)\n          if second:\n              magic_byte = magic_byte & 0xff\n              dex_byte = dex_extractor(count,magic_byte)\n              dex_byte = dex_byte &0xff\n              if count > 7 and count-8 < dex_size:\n                   dex_file.write(struct.pack(\"B\",dex_byte))\n              magic_byte = 0\n              second = False\n              count+=1\n          else:\n              magic_byte = magic_byte << 4\n              second = True\ndex_file.close()\n\n```\nLetâ€™s look at the output file with jadx\n\n\n-----\n\ndropped dex file\nRemember moonlight from output of ghidra script ? Yep this looks correct.\n\n## Frida <3\n\nWell I cant write an article without mentioning frida. Bypass checks with frida.\n\nThere are time checks on java and native side.\nCountry check\nFile is removed at native side.\n\n\n-----\n\n```\nvar unlinkPtr Module.findExportByName(null, unlink );\n// remove bypass\nInterceptor.replace(unlinkPtr, new NativeCallback( function (a){\n   console.log(\"[+] Unlink : \" + Memory.readUtf8String(ptr(a)))\n}, 'int', ['pointer']));\nvar timePtr = Module.findExportByName(null, 'time');\n// time bypass\nInterceptor.replace(timePtr, new NativeCallback( function (){\n  console.log(\"[+] native time bypass : \")\n  return 1554519179\n},'long', ['long']));\nJava.perform(function() {\n  var f = Java.use(\"android.telephony.TelephonyManager\")\n  var t = Java.use('java.util.Date')\n  //country bypass\n  f.getSimCountryIso.overload().implementation = function(){\n    console.log(\"Changing country from \" + this.getSimCountryIso() + \" to tr \")\n    return \"tr\"\n  }\n  t.getTime.implementation = function(){\n  console.log(\"[+] Java date bypass \")\n  return 1554519179000 \n  }\n })\n\n```\noutput of frida session\nPull the dex file with `adb pull path/xwcnhfc.dex .`\n\n## Homework\n\n\n-----\n\nThis part is homework for reader ðŸ™‚ Next version of this malware only use native arm binaries. So\nwe canâ€™t easily debug without having arm based device. But we can use our dex dropper python\nscript. Malware [sample. Load the arm binary to ghidra. Find the correct offset of the dex data block](https://koodous.com/apks/6c13658a81921f658f660a0f670eb61e9459d8105c1a72910a6bc8abd7795c65)\nand the size of the block. dex_extractor function might look different but it does the same thing. So\nyou need to only change the name of the files, offset and size variables at the python script. Hash\nof dropped dex file : 7ff02fb46009fc96c139c48c28fb61904cc3de60482663631272396c6c6c32ec\n\n## Conclusion\n\nWe attached gdb to debug native code and found certain checks. Wrote a ghidra script to\nautomate decryption of strings and frida script to bypass checks. Also learned that png files needs\nto be converted with Bitmap to get pixel values. So next time you see png file and suspicious app,\nlook for bitmap calls ðŸ˜‰\n\n## References\n\nGDB Debug : [https://packmad.github.io/gdb-android/](https://packmad.github.io/gdb-android/)\nFeatured image : [https://www.deviantart.com/velinov/art/Hydra-monster-144496963](https://www.deviantart.com/velinov/art/Hydra-monster-144496963)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-07-18 - Android Malware Analysis - Dissecting Hydra Dropper.pdf"
    ],
    "report_names": [
        "2019-07-18 - Android Malware Analysis - Dissecting Hydra Dropper.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535923,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653689580,
    "ts_modification_date": 1653689580,
    "files": {
        "pdf": "https://archive.orkl.eu/998c16115848585d6526250191de0eb35f8e0885.pdf",
        "text": "https://archive.orkl.eu/998c16115848585d6526250191de0eb35f8e0885.txt",
        "img": "https://archive.orkl.eu/998c16115848585d6526250191de0eb35f8e0885.jpg"
    }
}