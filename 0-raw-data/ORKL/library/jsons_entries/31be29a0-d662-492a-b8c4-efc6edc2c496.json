{
    "id": "31be29a0-d662-492a-b8c4-efc6edc2c496",
    "created_at": "2023-01-12T14:59:48.081544Z",
    "updated_at": "2025-03-27T02:08:40.646784Z",
    "deleted_at": null,
    "sha1_hash": "1c490350749cdd33d33da06296da6eb97d2900e2",
    "title": "2022-07-25 - CosmicStrand- the discovery of a sophisticated UEFI firmware rootkit",
    "authors": "",
    "file_creation_date": "2022-08-18T03:26:13Z",
    "file_modification_date": "2022-08-18T03:26:13Z",
    "file_size": 829694,
    "plain_text": "# CosmicStrand: the discovery of a sophisticated UEFI firmware rootkit\n\n**securelist.com/cosmicstrand-uefi-firmware-rootkit/106973/**\n\nAuthors\n\nGReAT\n\n## Introduction\n\nRootkits are malware implants which burrow themselves in the deepest corners of the operating\nsystem. Although on paper they may seem attractive to attackers, creating them poses\nsignificant technical challenges and the slightest programming error has the potential to\n[completely crash the victim machine. In our APT predictions for 2022, we noted that despite](https://securelist.com/advanced-threat-predictions-for-2022/104870/)\nthese risks, we expected more attackers to reach the sophistication level required to develop\nsuch tools. One of the main draws towards malware nested in such low levels of the operating\nsystem is that it is extremely difficult to detect and, in the case of firmware rootkits, will ensure a\ncomputer remains in an infected state even if the operating system is reinstalled or the user\nreplaces the machine’s hard drive entirely.\n\nIn this report, we present a UEFI firmware rootkit that we called CosmicStrand and attribute to\nan unknown Chinese-speaking threat actor. One of our industry partners, Qihoo360, published a\nblog post about an early variant of this malware family in 2017.\n\n\n-----\n\n## Affected devices\n\nAlthough we were unable to discover how the victim machines were infected initially, an analysis\nof their hardware sheds light on the devices that CosmicStrand can infect. The rootkit is located\nin the firmware images of Gigabyte or ASUS motherboards, and we noticed that all these\nimages are related to designs using the H81 chipset. This suggests that a common vulnerability\nmay exist that allowed the attackers to inject their rootkit into the firmware’s image.\n\nIn these firmware images, modifications have been introduced into the CSMCORE DXE driver,\nwhose entry point has been patched to redirect to code added in the .reloc section. This code,\nexecuted during system startup, triggers a long execution chain which results in the download\nand deployment of a malicious component inside Windows.\n\nLooking at the various firmware images we were able to obtain, we assess that the modifications\nmay have been performed with an automated patcher. If so, it would follow that the attackers\nhad prior access to the victim’s computer in order to extract, modify and overwrite the\nmotherboard’s firmware. This could be achieved through a precursor malware implant already\ndeployed on the computer or physical access (i.e., an evil maid attack scenario). Qihoo’s initial\nreport indicates that a buyer might have received a backdoored motherboard after placing an\norder at a second-hand reseller. We were unable to confirm this information.\n\n## Overview of the infection process\n\nBefore getting into the various components that compose this rootkit, we would like to provide a\nhigh-level view of what it tries to accomplish. The goal of this execution chain is to deploy a\nkernel-level implant into a Windows system every time it boots, starting from an infected UEFI\ncomponent.\n\nUEFI malware authors face a unique technical challenge: their implant starts running so early in\nthe boot process that the operating system (in this case Windows) is not even loaded in memory\nyet – and by the time it is, the UEFI execution context will have terminated. Finding a way to\npass down malicious code all the way through the various startup phases is the main task that\nthe rootkit accomplishes.\n\nThe workflow consists in setting hooks[1] in succession, allowing the malicious code to persist\nuntil after the OS has started up. The steps involved are:\n\nThe initial infected firmware bootstraps the whole chain.\nThe malware sets up a malicious hook in the boot manager, allowing it to modify Windows’\nkernel loader before it is executed.\nBy tampering with the OS loader, the attackers are able to set up another hook in a\nfunction of the Windows kernel.\nWhen that function is later called during the normal start-up procedure of the OS, the\nmalware takes control of the execution flow one last time.\n\n\n-----\n\nIt deploys a shellcode in memory and contacts the C2 server to retrieve the actual\nmalicious payload to run on the victim’s machine.\n\nThese steps are summed up in the following graph:\n\n## UEFI implant – detailed analysis\n\n**MD5** [DDFE44F87FAC7DAEEB1B681DEA3300E9](https://opentip.kaspersky.com/DDFE44F87FAC7DAEEB1B681DEA3300E9/?utm_source=SL&utm_medium=SL&utm_campaign=SL)\n\n**SHA1** 9A7291FC90F56D8C46CC78397A6F36BB23C60F66\n\n**SHA256** 951F74882C1873BFE56E0BFF225E3CD5D8964AF4F7334182BC1BF0EC9E987A0A\n\n\n**Link**\n**time**\n\n\nWednesday, 12.08.2015 12:17:57 UTC\n\n\n-----\n\n**File**\n**type**\n\n**File**\n**size**\n\n\nEFI Boot Service DXE Driver\n\n96.84 KB\n\n\n**GUID** A062CF1F-8473-4AA3-8793-600BC4FFE9A8 (CSMCORE)\n\nHaving established what the malware implant tries to accomplish, we can now look into more\ndetail at how each of these steps is performed.\n\n1. The whole execution chain begins with an EFI driver. It appears to be a patched version of\n\na legitimate one named CSMCORE (intended to facilitate the boot of the machine in\nlegacy mode via the MBR), where the attackers have modified the pointer to the\nHandleProtocol boot service function. Every time this function is called, the execution is\nredirected to attacker-supplied code that tries to determine which component called it (it is\nlooking for a specific one to infect – efi). By examining the function arguments as well as\nthe bytes located at the return address, CosmicStrand can identify the exact “call” it is\nlooking for.\n\n2. This specific point in the execution was chosen because at this stage the boot manager is\n\nloaded in memory, but isn’t yet running. CosmicStrand seizes this chance to patch a\nnumber of bytes in its Archpx64TransferTo64BitApplicationAsm\n3. That function is later called during the normal OS startup process, also at a strategic time:\n\nby then the Windows OS loader is also present in memory and can in turn be modified.\n\n\n-----\n\n4. When it runs, Archpx64TransferTo64BitApplicationAsm locates a function from the OS\n\nloader (OslArchTransferToKernel) by looking for a specific byte pattern. CosmicStrand then\nadds a hook at the very end of it.\n\n5. OslArchTransferToKernel is called just before execution is transferred from the Windows\n\nloader to the Windows kernel, which makes it a traditional hooking point for rootkits of that\nsort.\n\n\n-----\n\n6. Before the Windows kernel has had a chance to run, CosmicStrand sets up yet another\n\nhook in the ZwCreateSection Malicious code is copied[2] into the image of ntoskrnl.exe in\nmemory, and the first bytes of ZwCreateSection are overwritten to redirect to it. We note\nthat the attackers were careful to place the malicious code inside the slack space of\nntoskrnl.exe’s .text section, which makes this redirection a lot less conspicuous in the eyes\nof possible security products.\n\n\n[At this point, CosmicStrand also seemingly attempts to disable PatchGuard, a security](https://en.wikipedia.org/wiki/Kernel_Patch_Protection)\nmechanism introduced to prevent modifications in key structures of the Windows kernel in\nmemory. To do so, it locates ntoskrnl.exe’s KiFilterFiberContext function[3] and modifies it\nso it returns without performing any work. It is worth noting that the localization of this\nfunction, also achieved by searching for hardcoded patterns, is very exhaustive and even\n[contains patterns corresponding to the Redstone 1 release from August 2016.](https://en.wikipedia.org/wiki/Windows_10_version_1607)\n\n7. The Windows kernel then starts, and ends up calling the hooked ZwCreateSection function\n\nwhile running normally. When that happens, CosmicStrand gains control of the execution\nagain, and restores the original code before running more malicious code.\n\n\n-----\n\n8. The ZwCreateSection hook s primary purpose is to collect the addresses of API functions\n\nprovided by the kernel, and create a sort of import table for the next component. Using the\nresolved functions, it also allocates a buffer in the kernel’s address space where it maps a\nshellcode, before calling it.\n\n## Kernel shellcode\n\nAll the steps described so far only served the purpose of propagating code execution from the\nUEFI down to the Windows kernel. This shellcode is the first actually malicious component of the\nchain so far. It sets up a [thread notify routine that gets invoked each time a new thread is](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreatethreadnotifyroutine)\ncreated. CosmicStrand waits until one turns up in winlogon.exe, and then executes a callback in\nthis high-privilege context.\n\nThere, CosmicStrand sleeps for 10 minutes and tests the internet connectivity of the infected\nmachine. CosmicStrand doesn’t rely on high-level API functions to generate network traffic, but\n[instead interacts directly with the Transport Device Interface: it generates the needed IRPs (I/O](https://www.codeproject.com/Articles/9974/Driver-Development-Part-5-Introduction-to-the-Tran)\nrequest packets) and passes them to the network stack by sending IOCTLs to the TCP or UDP\ndevice object. DNS requests are performed in this fashion, using either Google’s DNS server\n(8.8.8[.]8) or a custom one (222.222.67[.]208).\n\nCosmicStrand retrieves its final payload by sending a specifically crafted UDP (preferably) or\nTCP packet to its C2 server, update.bokts[.]com. The reply is expected to return in one or\nseveral packets containing chunks of 528 bytes following this structure:\n\n**Offset (bytes)** **Description**\n\n0-4 Magic number\n\n4-8 Total length of the payload\n\n8-12 Length of the current chunk\n\n12-16 CRC32 checksum of the current chunk\n\n16-* Payload chunk\n\nThe various chunks are reassembled into a series of bytes that are mapped into kernel space\nand interpreted as a shellcode. Unfortunately, we were not able to obtain a copy of data coming\nfrom the C2 server. We did, however, find a user-mode sample in-memory on one of the infected\nmachines we could study, and believe it is linked with CosmicStrand. This sample is an\nexecutable that runs command lines in order to create a user (“aaaabbbb”) on the victim’s\nmachine and add it to the local administrators group.\n\n\n-----\n\nWe can infer from this that shellcodes received from the C2 server might be stagers for attackersupplied PE executables, and it is very likely that many more exist.\n\n## Older CosmicStrand variants\n\nDuring the course of our investigation, we also discovered older versions of this rootkit. They\nfeature the same deployment process and their minute differences pertain to the kernel\nshellcode.\n\nIt attempts to hijack a thread from exe instead of winlogon.exe.\nThe C2 domain contacted to obtain additional shellcode in order to run is different\n(erda158[.]to).\nThe older variant printed debugging messages every time a new process was created in\nthe system.\n\nBased on our analysis of the infrastructure used for the two variants, we estimate that the older\none saw use between the end of 2016 and mid-2017, and the current one was active in 2020.\n\n## Infrastructure\n\nWe are aware of two C2 servers, one for each variant. According to passive DNS data available\nfor them, these domains had a long lifetime and resolved to IP addresses during limited\ntimeframes – outside of which the rootkit would have been inoperative. It is therefore interesting\nto note that while the attackers opted to deploy an extremely persistent implant, the actual\nexploitation of the victim machines may not have lasted more than a few months. It is, however,\npossible that these domains were occasionally reactivated for very short durations, and that this\ninformation would not have been recorded by passive DNS systems.\n\n\n**Domain** **IP** **First**\n**seen**\n\nwww.erda158[.]top 58.84.53[.]194 201612-27\n\n115.239.210[.]27 2017-04-30 201706-24\n\n\n**Last seen** **ASN**\n\n2017-04-26 AS48024\n(NEROCLOUD)\n\nAS58461\n(CHINANET)\n\n\n-----\n\nupdate.bokts[.]com 23.82.12[.]30 202005-03\n\n23.82.12[.]31 2020-07-25 202007-25\n\n23.82.12[.]32 2020-03-09 202007-25\n\n\n2020-05-03 AS30633 (Leaseweb\nUSA)\n\nAS30633 (Leaseweb\nUSA)\n\nAS30633 (Leaseweb\nUSA)\n\n\nCareful readers will notice the three-year gap between the activity periods of the two domains. It\nis possible that during that time, the attackers were controlling the victim’s machines using usermode components deployed through CosmicStrand, or (more likely) that other variants and C2\nservers that we did not yet discover exist somewhere.\n\n## Victims\n\nWe were able to identify victims of CosmicStrand in China, Vietnam, Iran and Russia. A point of\ninterest is that all the victims in our user base appear to be private individuals (i.e., using the free\nversion of our product) and we were unable to tie them to any organization or even industry\nvertical.\n\n## Attribution\n\nSeveral data points lead us to believe that CosmicStrand was developed by a Chinese-speaking\nthreat actor, or by leveraging common resources shared among Chinese-speaking threat actors.\nSpecifically, a number of code patterns featured in CosmicStrand were also observed in another\n\n\n-----\n\nmalware family, the MyKings botnet (e.g., MD5 [E31C43DD8CB17E9D68C65E645FB3F6E8).](https://opentip.kaspersky.com/E31C43DD8CB17E9D68C65E645FB3F6E8/?utm_source=SL&utm_medium=SL&utm_campaign=SL)\n[This botnet, used to deploy cryptominers, was documented by Sophos in 2020 where they noted](https://www.sophos.com/en-us/medialibrary/PDFs/technical-papers/sophoslabs-uncut-mykings-report.pdf)\nthe presence of several Chinese-language artifacts.\n\nSimilarities with CosmicStrand include:\n\nThe use of an MBR rootkit to establish stealthy persistence in MyKings.\nCosmicStrand and MyKings use identical tags when they allocate memory in kernel mode\n(Proc and GetM).\nBoth families generate network packets the same way, and leverage the UDP and TCP\ndevice objects directly.\nThe API hashing code used in the two of them is identical, as evidenced by the screenshot\nbelow. As far as we know, this algorithm was only ever found in two other rootkits,\n[MoonBounce and xTalker – also tied to Chinese-speaking threat actors.](https://securelist.com/moonbounce-the-dark-side-of-uefi-firmware/105468/)\n\n\n-----\n\nIn addition to this code similarity, the fact that the hardcoded fallback DNS server used by\nCosmicStrand is located in CHINANET-BACKBONE (AS4134) could be perceived as a very lowconfidence sign that the attackers are part of the Chinese-speaking nexus. Beyond this tie, we\n\n\n-----\n\nhave decided that we do not have sufficient information that would allow us to link CosmicStrand\nto an existing cluster.\n\n## Conclusions\n\nCosmicStrand is a sophisticated UEFI firmware rootkit that allows its owners to achieve very\ndurable persistence: the whole lifetime of the computer, while at the same time being extremely\nstealthy. It appears to have been used in operation for several years, and yet many mysteries\nremain. How many more implants and C2 servers could still be eluding us? What last-stage\npayloads are being delivered to the victims? But also, is it really possible that CosmicStrand has\n[reached some of its victims through package “interdiction”? In any case, the multiple rootkits](https://www.theguardian.com/books/2014/may/12/glenn-greenwald-nsa-tampers-us-internet-routers-snowden?r)\ndiscovered so far evidence a blind spot in our industry that needs to be addressed sooner rather\nthan later.\n\nThe most striking aspect of this report is that this UEFI implant seems to have been used in the\nwild since the end of 2016 – long before UEFI attacks started being publicly described. This\ndiscovery begs a final question: if this is what the attackers were using back then, what are they\nusing today?\n\n**_The GReAT team would like to extend its special thanks to their former colleague, Mark_**\n**_Lechtik, for his key involvement in this research._**\n\n[1] A hook is a modification to the normal flow of execution of a program. It aims to execute\n\nadditional code provided by the attacker before or after a given function. In some environments,\nfunction hooking is provided for legitimate purposes and can be set up easily through\nconventional programming mechanisms. In other cases, where they are not explicitly supported,\nattackers can still achieve hooking by overwriting (and later on, restoring) the code that is about\nto be executed. Both cases are leveraged by this rootkit.\n\n\n\n[2] Here we skip the implementation details and shellcode tricks used by the rootkit in order to\n\nobtain the address of the malicious code. The precise workflow of this part is left as an exercise\nto the reader, and documented extensively in our private report on this activity.\n\n[3] [More information about this function is available in research from other vendors.](https://blog.tetrane.com/downloads/Tetrane_PatchGuard_Analysis_RS4_v1.01.pdf)\n\n[Drivers](https://securelist.com/tag/drivers/)\n[Firmware](https://securelist.com/tag/firmware/)\n[Malware Descriptions](https://securelist.com/tag/malware-descriptions/)\n[Malware Technologies](https://securelist.com/tag/malware-technologies/)\n[Rootkits](https://securelist.com/tag/rootkits/)\n[UEFI](https://securelist.com/tag/uefi/)\n\nAuthors\n\n\n-----\n\nGReAT\n\nCosmicStrand: the discovery of a sophisticated UEFI firmware rootkit\n\nYour email address will not be published. Required fields are marked *\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-07-25 - CosmicStrand- the discovery of a sophisticated UEFI firmware rootkit.pdf"
    ],
    "report_names": [
        "2022-07-25 - CosmicStrand- the discovery of a sophisticated UEFI firmware rootkit.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535588,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1660793173,
    "ts_modification_date": 1660793173,
    "files": {
        "pdf": "https://archive.orkl.eu/1c490350749cdd33d33da06296da6eb97d2900e2.pdf",
        "text": "https://archive.orkl.eu/1c490350749cdd33d33da06296da6eb97d2900e2.txt",
        "img": "https://archive.orkl.eu/1c490350749cdd33d33da06296da6eb97d2900e2.jpg"
    }
}