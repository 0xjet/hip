{
    "id": "ad47d626-f56d-4046-8e83-2c4d04a849a7",
    "created_at": "2023-01-12T15:02:17.618149Z",
    "updated_at": "2025-03-27T02:13:58.318986Z",
    "deleted_at": null,
    "sha1_hash": "e30846b0003f0b1ed34f5fdc1cccaaffd13ac061",
    "title": "2022-11-22 - Nighthawk- An Up-and-Coming Pentest Tool Likely to Gain Threat Actor Notice",
    "authors": "",
    "file_creation_date": "2022-11-28T19:09:38Z",
    "file_modification_date": "2022-11-28T19:09:38Z",
    "file_size": 2844878,
    "plain_text": "# Nighthawk: An Up-and-Coming Pentest Tool Likely to Gain Threat Actor Notice\n\n**[proofpoint.com/us/blog/threat-insight/nighthawk-and-coming-pentest-tool-likely-gain-threat-actor-notice](https://www.proofpoint.com/us/blog/threat-insight/nighthawk-and-coming-pentest-tool-likely-gain-threat-actor-notice)**\n\nNovember 18, 2022\n\n\n-----\n\n[Blog](https://www.proofpoint.com/us/blog)\n[Threat Insight](https://www.proofpoint.com/us/blog/threat-insight)\nNighthawk: An Up-and-Coming Pentest Tool Likely to Gain Threat Actor Notice\n\n\n-----\n\nNovember 22, 2022\nAlexander Rausch and the Proofpoint Threat Research Team\n\n## Key Takeaways\n\nNighthawk is an advanced C2 framework intended for red team operations through\ncommercial licensing.\nProofpoint researchers observed initial use of the framework in September 2022 by a\nlikely red team.\nWe have seen no indications at this time that leaked versions of Nighthawk are being\nused by attributed threat actors in the wild.\nThe tool has a robust list of configurable evasion techniques that are referenced as\n“opsec” functions throughout its code.\nProofpoint researchers expect Nighthawk will show up in threat actor campaigns as the\ntool becomes more widely recognized or as threat actors search for new, more capable\ntools to use against targets.\n\n## Overview\n\nIn September 2022, Proofpoint researchers identified initial delivery of a penetration testing\n[framework called Nighthawk. Launched in late 2021 by MDSec, Nighthawk is similar to other](https://www.mdsec.co.uk/nighthawk/)\nframeworks such as [Brute Ratel and](https://unit42.paloaltonetworks.com/brute-ratel-c4-tool/) [Cobalt Strike and, like those, could see rapid adoption](https://www.proofpoint.com/us/blog/threat-insight/cobalt-strike-favorite-tool-apt-crimeware)\nby threat actors wanting to diversify their methods and add a relatively unknown framework\nto their arsenal. This possibility, along with limited publicly available technical reporting on\nNighthawk, spurred Proofpoint researchers into a technical exploration of the tool and a\ndetermination that sharing our findings would be in the best interest of the cybersecurity\ncommunity.\n\nWhile this report touches on the activity observed in Proofpoint data, the primary focus is\nNighthawk’s packer and subsequent payload capabilities.\n\n## Threat Actors <3 Red Teaming Tools\n\n\n-----\n\nHistorically, threat actors have integrated legitimate tools into their arsenal for various\nreasons, such as complicating attribution, leveraging specific features such as endpoint\ndetection evasion capabilities or simply due to ease of use, flexibility, and availability. In the\nlast few years, threat actors from cybercriminals to advanced persistent threat actors have\nincreasingly turned to red teaming tools to achieve their goals.\n\n[Between 2019 and 2020, Proofpoint observed a 161% increase in threat actor use of Cobalt](https://www.proofpoint.com/us/blog/threat-insight/cobalt-strike-favorite-tool-apt-crimeware)\n[Strike. This increase was quickly followed by the adoption of Sliver—an open-source, cross-](https://github.com/BishopFox/sliver/tree/6c02971b54831884d30407b632a379947dd289ad)\nplatform adversary simulation and red team platform. Sliver was first released in 2019 and by\nDecember 2020 had been incorporated into threat actors’ tactics, techniques, and\nprocedures—a timeline which could possibly occur with Nighthawk in the future. By late\n[2021, Proofpoint had identified an initial access facilitator for ransomware threat actors using](https://www.proofpoint.com/us/blog/security-briefs/ta551-uses-sliver-red-team-tool-new-activity)\n[Sliver. And, as recently as summer 2022, other security researchers have noted a range of](https://www.microsoft.com/en-us/security/blog/2022/08/24/looking-for-the-sliver-lining-hunting-for-emerging-command-and-control-frameworks/)\n[threat actors of varying skills, resources, and motivations integrating it as well as Brute Ratel,](https://unit42.paloaltonetworks.com/brute-ratel-c4-tool/)\nanother red teaming and adversarial attack simulation tool, into their campaigns.\n\n## Testing, Testing…1…2…3\n\nProofpoint researchers observed initial use of the Nighthawk framework beginning in midSeptember 2022 with several test emails being sent using generic subjects such as “Just\nchecking in” and “Hope this works2.” Over the course of a few weeks, emails were sent with\nmalicious URLs, that, if clicked, would lead to an ISO file containing the Nighthawk loader\npayload as a PE32+ executable file, which will be explored in the next section.\n\nProofpoint researchers were able to identify that the payload delivered was the Nighthawk\npenetration testing framework based on open-source research, including MDSec’s [blog on](https://www.mdsec.co.uk/2022/05/nighthawk-0-2-catch-us-if-you-can/)\nthe latest version of the tool.\n\n## The Loader\n\nThe Nighthawk loader artifact analyzed by Proofpoint researchers is a PE32+ binary that\nuses some obfuscation and encryption methods to make analysis more difficult and\nprolonged. The loader has the following structure (Figure 1) including a .uxgbxd section that\ncontains possibly decoy code and the .text section which contains the main event: the PE\nentry point, the unpacking code, the configuration structure, and the encrypted Nighthawk\npayload.\n\n\n-----\n\n_Figure 1. The structure of the Nighthawk PE32+ binary._\n\nThe PE entry point (Figure 2) within the .text section implements some control obfuscation by\ncalculating the offset for the main function. This is likely done in order to interfere with static\ndisassembly engines.\n\n_Figure 2. PE entry point._\n\nInitially, the loader code builds a small import table and parses a configuration structure that\nspecifies which evasion and keying method are to be used. Functions are dynamically\nresolved through symbol hashing and manually parsing the export directory of loaded\n[modules retrieved through the LDR_DATA_TABLE_ENTRY in the](https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/2110%2021H2%20(November%202021%20Update)/_LDR_DATA_TABLE_ENTRY) [PEB. If a desired library is](https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/2110%2021H2%20(November%202021%20Update)/_PEB_LDR_DATA)\nnot present in memory, it is either loaded using LoadLibraryW in a direct call or as a\ndispatched job via RtlQueueWorkItem.\n\n\n-----\n\n_Figure 3. LoadLibrary implementation._\n\nAll meaningful strings are encoded with a simple algorithm and decoded on the fly. This\ninline string decoding means that for only a brief period of time the strings are present in\nmemory. This creates an advantage for potential threat actors making detection of the tool\nmore difficult.\n\n\n-----\n\n_Figure 4. Loader string encoding._\n\nSome functionality can use WinAPI or direct system calls depending on the corresponding\nconfiguration option. This functionality can be used to evade some endpoint detection\nsystems and sandboxes that use usermode hooks for instrumentation.\n\nThe following code removes any potentially registered ProcessInstrumentationCallback\n[which can be used to transparently instrument code. This code, if enabled, is directly](https://github.com/ionescu007/HookingNirvana/blob/master/Esoteric%20Hooks.pdf)\nexecuted after the configuration parsing and import table setup phase.\n\n_Figure 5. Clearing the ProcessInstrumentationCallback._\n\nAs another means of evading endpoint detection and response security solutions, the loader\ncode contains optional unhooking functionality for ntdll.dll, kernel32.dll and kernelbase.dll\nthat is intended to remove user mode hooks from system libraries.\n\nAfter initialization, a key for decryption of the payload is derived from one of several system\nfeatures. Which method is selected to retrieve the payload decryption key is based on user\nconfiguration.\n\nSupported keying methods are:\n\ncontent of a specified registry key\nuser SID retrieved from the process token\naccount domain SID retrieved with LsaQueryInformationPolicy\nretrieval of the encryption key via DNS CNAME or TXT query\nretrieval of the encryption key via HTTPS request\nusername, read with GetUserNameA\ncomputer name, read with GetComputerNameA\nreading the key from a specified file at a specified offset\nretrieval of the encryption key via DNS over TLS via CNAME or TXT query\nuse of the system drive serial number that is read via\nIOCTL_STORAGE_QUERY_PROPERTY IOCTL to //./PhysicalDrive0\n\n\n-----\n\nThe presence of these keying methods is one of the clues that led Proofpoint researchers to\nidentify this malware as Nighthawk early on. This list matches the features described\nin [MDSec’s blog – “Nighthawk 0.2 – Catch Us If You Can”.](https://www.mdsec.co.uk/2022/05/nighthawk-0-2-catch-us-if-you-can/)\n\nAfter a key derivation from the result of the selected keying function, the payload embedded\nin the .text section is decrypted and executed. The keying feature is engineered to minimize\nexposure of the cleartext implant and to make it difficult to analyze the malware in a sandbox\nor lab environment.\n\n## The Nighthawk Payload\n\nThe Nighthawk payload, which is coded in C++, is embedded as a DLL with a small\nshellcode prepended (Figure 6) that jumps with the correct offset into the reflective loader\ncode contained within the DLL.\n\n_Figure 6. Prepended shellcode._\n\nThe DLL contains the following sections:\n\nTo hide suspicious API calls, Nighthawk uses dynamic API resolution through symbol\nhashing as well (Figure 7). The correct module and function symbol is identified by checking\nfor a matching hash on the lowercase library name or symbol string.\n\n\n-----\n\n_Figure 7. Nighthawk string hashing function for dynamic API resolution._\n\nThis technique is standard tradecraft for malware developers and used in a comparable way\nin many other malwares and frameworks such as Cobalt Strike.\n\nEmbedded strings are encoded with a simple substitution cipher. Single characters are\nlooked up in a ciphertext alphabet and replaced with the corresponding character in a\ncleartext alphabet. If no match in the ciphertext alphabet is found, the character is not\nsubstituted.\n\nThis string encoding is simple but effective in countering signature engines that feature\nfunctionality to match XORed strings.\n\nReimplemented string decoding algorithm in Python below.\n\nCIPHERTEXT_ALPHABET = \")]9ufjt.,AgU$cwTFzMdxHa!I>hl[ 6QEBmok&;4r?\n07G:s^N{qe_P(+b1S8=X/5DvWKiV*<O}-ZnpJ3yYL2RC\"\n\nCLEARTEXT_ALPHABET = \",lDvbd<)!asg>.B-GNoK&9P$;6c3O_hFHJqQm4r0y]wtk:\n{(8xX^EjT?Cen}+z=/5SIViu2*ZY[pURW1f L7MA\"\n\ndef decode_string(encoded):\n\nd = []\n\nfor c in encoded:\n\nif c in CIPHERTEXT_ALPHABET:\n\nd.append(CLEARTEXT_ALPHABET[CIPHERTEXT_ALPHABET.find(c)])\n\nelse:\n\nd.append(c)\n\nreturn \"\".join(d)\n\nNighthawk loads a configuration profile from the .profile section after some initial setup work.\n\n\n-----\n\nThe embedded profile itself is a gzip compressed and AES encrypted JSON object where\nthe string type fields are encoded with the substitution cipher described above. The 128bit\nAES key is either prepended to the encrypted configuration profile or retrieved via HTTPS or\nDNS.\n\n_Figure 8. Encrypted profile configuration._\n\n_Figure 9. Decrypted and decompressed profile configuration._\n\n\n-----\n\n_Figure 10. Partial Nighthawk configuration profile with additional string decoding._\n\n## Nighthawk Evasion\n\nNighthawk features an extensive list of configurable evasion techniques that are referenced\nas “opsec” functions throughout its code. These techniques are important because they\ninclude capabilities that prevent certain endpoint detection notifications and evade process\nmemory scans.\n\nProofpoint researchers identified the numerous following evasion options that can be\nspecified in the opsec section of the configuration profile. Some of these capabilities are\n[explained in MDSec’s blog while others have not been sufficiently publicly documented. It is](https://www.mdsec.co.uk/2022/05/nighthawk-0-2-catch-us-if-you-can/)\non the latter capabilities where we have focused our analysis—details of which can be found\nafter this table.\n\n\n**Opsec**\n**Configuration**\n**Option**\n\n\n**Functionality**\n\n\nuse-syscalls Use direct system calls instead of WinApi where applicable.\n\n\nindirectsyscalls\n\nunhooksyscalls\n\n\nUse indirect system calls by setting up system call arguments and calling\na syscall instruction in ntdll instead of a syscall instruction inside the\nNighthawk code.\n\nRemove hooks from ntdll.dll\n\n\n-----\n\nself-encryptmode\n\nself-encryptafter\n\nreport-selfencrypt-status\n\nself-encryptwhile-listening\n\nstomp-peheader\n\nmasqueradethread-stacks\n\nencrypt-heapmode\n\nclear-veh-onunhook\n\nclear-veh-onimp-res\n\nclear-hwbpon-unhook\n\n\nValid options are:\n\noff\n\nstub\nno-stub-rop\nno-stub-timer\nno-stub-regwait\n\nThe exact functionality is unknown at the time of writing.\n\nThe exact functionality is unknown at the time of writing.\n\nThe exact functionality is unknown at the time of writing.\n\nOverwrites the DOS header magic value, the space between the DOS\nand PE header, the PE magic and section names.\n\nThis option overwrites the stack of threads during hibernation.\n\nEncrypts the heap when the implant hibernates.\n\nValid options are:\n\noff\n\nimplant\nimplant+zero\n\nThis option temporarily sets a dummy exception handler by patching the\nLdrpVectorHandlerList during import resolution.\n\nThis option temporarily sets a dummy exception handler by patching the\nLdrpVectorHandlerList during import resolution.\n\nThis option clears all hardware breakpoints via NtSetContextThread\nduring the usermode hook removal process.\n\n\n-----\n\nclear-hwbpon-imp-res\n\nclear-dllnotifications\n\nusethreadpool\n\nbackingmodule\n\n\nThis option clears all hardware breakpoints via NtSetContextThread\nduring API resolution.\n\nThis setting clears the list of DLL loading notification callbacks registered\nwith LdrRegisterDllNotification.\n\nUse RtlQueueWorkItem to dispatch tasks to a thread pool.\n\nThe exact functionality is unknown at the time of writing.\n\n\nunhook-dlls Remove usermode hooks from the list of specified DLLs.\n\nblock-dlls Block the specified DLLs from being loaded by hooking LoadLibraryExW.\n\nuse-hwbp-for Use hardware breakpoints to implement hooking for the specified\nfeatures.\n\nValid options are:\n\nimplant+zero\ninproc-console\nblock-dlls\npatch-etw-event\npatch-etw-control\npatch-amsi\n\n\nunhook-usingwpm\n\nunhook-vianative\n\nunhook-clearguard\n\n\nOverwrite hooks using WriteProcessMemory.\n\nOverwrite hooks using NtProtectVirtualMemory and memmove (intrinsic).\n\nClear the PAGE_GUARD permission from inaccessible memory and set\nthe permissions for PAGE_NO_ACCESS memory to\nPAGE_EXECUTE_READ.\n\n\nhide-windows Hide GUI Windows of the Nighthawk process using EnumWindows and\nShowWindow.\n\n\n-----\n\nsleep-mode Selects a sleep mechanism.\n\nValid options are:\n\nsleep: SleepEx\ndelay: NtDelayExecution\nwait-single: NtWaitForSingleObject\nwait-multi: NtWaitForMultipleObjects\nwait-signal: CreateEventW and NtSignalAndWaitForSingleObject\n\n\ndisable-picallback\n\npatch-etwevent\n\npatch-etwcontrol\n\n\nDisable process instrumentation callbacks by using\nNtSetInformationProcess to set the ProcessInstrumentationCallback\ninformation class.\n\nHook NtTraceEvent.\n\nHook NtTraceControl.\n\n\npatch-amsi Hook AmsiScanBuffer.\n\n\nthreadpoolloadlibrary\n\nthread-startaddresses\n\n\nUse RtlQueueWorkItem to dispatch calls to LoadLibraryW for library\nloading.\n\nThe exact functionality is unknown at the time of writing.\n\n\n**DLL load notification removal (unhook-dlls): Nighthawk implements a technique that can**\nprevent endpoint detection products from receiving notifications for newly loaded DLLs in the\ncurrent process context via callbacks that were registered with LdrRegisterDllNotification.\nThis technique is enabled by the clear-dll-notifications option.\n\nThe intended way to unregister a DLL load notification callback is to use\nLdrUnregisterDllNotification; however, this requires a cookie value that is returned by the\ninitial LdrRegisterDllNotification.Nighthawk works around this by directly modifying the list of\nstructures that store callbacks for a given process.\n\n\n-----\n\n_Figure 11. Reversed nh_opsec_unregister_dll_load_notifications function._\n\nOf particular interest is the technique used to find the head of the LdrpDllNotificationList\n(Figure 12).\n\n\n-----\n\n_Figure 12. Reversed nh_get_LdrpDllNotificationList function._\n\nThe head of LdrpDllNotificationList is in the .data section of ntdll.dll and the cookie value\nreturned by LdrRegisterDllNotification is a pointer to a list entry in LdrpDllNotificationList.\n\nThus, walking this list leads to a list entry located inside the ntdll.dll .data section and this list\nentry is the head of LdrpDllNotificationList. This implementation is much more stable than\nother implementations that rely on disassembling code referencing LdrpDllNotificationList in\nntdll.dll.\n\n\n-----\n\n**Disabling process instrumentation callback (disable-pi-callback): Nighthawk disables**\nthis callback by setting an empty callback using NtSetInformationProcess similar to the\nimplementation used in the loader.\n\n_Figure 13. Reversed nh_disable_process_instrumentation_callback function._\n\n**Self-encryption (self-encryption-mode):** [Modern](https://www.cobaltstrike.com/blog/sleep-mask-update-in-cobalt-strike-4-5/) [C2 frameworks often implement self-](https://bruteratel.com/tabs/badger/commands/sleep/)\nencryption capabilities to evade process memory scans.Nighthawk implements several\nvariants of self-encryption methods that can be configured with the self-encrypt-mode option.\n\nThe advanced, more interesting options are no-stub-rop, no-stub-timer, and no-stub-regwait.\n\nAll these options are implemented without any resident code but rather use a ROP chain or\ncallbacks to directly call into the APIs used to encrypt, sleep, and finally decrypt the implant\nby proxy through NtContinue. When this code is executed, all other threads are already\nsuspended and have a spoofed stack depending on the configuration of the masqueradethread-stacks option.\n\n[The no-stub implementations generally use SystemFunction040/RtlEncryptMemory and](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlencryptmemory)\n[SystemFunction041/RtlDecryptMemory to implement the encryption and decryption](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtldecryptmemory)\nfunctionality. [NtContinue is used as a “super gadget” to invoke these APIs with the correct](http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtContinue.html)\nset of parameters. NtWaitForSingleObject, RegisterWaitForSingleObject, and\nCreateQueueTimer are used to implement a sleep primitive for the three options respectively\n\n\n-----\n\nAll of these methods are sophisticated and relatively hard to detect but the most eyecatching implementation is the no-stub-rop option. This self-encryption method uses return\noriented programming to implement the encryption logic by constructing a ROP chain\nconsisting of the following two code gadgets (note: gadgets are dynamically discovered by\n[iterating modules present in the PEB InLoadOrderModuleList) and the NtContinue “super](https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/2110%2021H2%20(November%202021%20Update)/_PEB_LDR_DATA)\ngadget”:\n\nIncrement the stack pointer\n\nadd rsp, value > 0x28\n\nret\n\nGet the pointer to the [CONTEXT structure for NtContinue from the stack](https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/2110%2021H2%20(November%202021%20Update)/_CONTEXT)\n\npop rcx\n\nret\nBy using these building blocks a ROP chain is constructed that calls VirtualProtect to set the\nmemory of the loaded Nighthawk implant read writable,\nSystemFunction040/RtlEncryptMemory to encrypt the implant, WaitForSingleObject to sleep,\nand SystemFunction041/RtlDecryptMemory to decrypt the implant again followed by\nVirtualProtect to set the memory permissions to read write executable. These functions are\ninvoked through NtContinue with the arguments provided through the CONTEXT structure\nparameter.\n\nFigure 14 illustrates the concept.\n\n\n-----\n\n_Figure 14. Illustration of the no-stub-rop self-encryption method._\n\n## Outlook\n\nNighthawk is a mature and advanced commercial C2 framework for lawful red team\noperations that is specifically built for detection evasion, and it does this well. While\nProofpoint researchers are not aware of adoption of Nighthawk in the wild by attributed threat\nactors, it would be incorrect and dangerous to assume that this tool will never be\nappropriated by threat actors with a variety of intents and purposes. Historic adoption of tools\nlike Brute Ratel by advanced adversaries, including those aligned with state interests and\nengaging in espionage, provides a template for possible future threat landscape\ndevelopments. Detection vendors in particular should ensure proper coverage of this tool as\ncracked versions of effective and flexible post-exploitation frameworks can show up in the\ndark corners of the internet when either threat actors are looking for a novel tool or the tool\nhas reached a certain prevalence.\n\n\n-----\n\n_Proofpoint researchers will continue to analyze the Nighthawk framework and monitor for_\n_threat actor campaigns leveraging the tool. An update to this blog or a follow-up report will be_\n_published depending on additional findings._\n\nSubscribe to the Proofpoint Blog\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-11-22 - Nighthawk- An Up-and-Coming Pentest Tool Likely to Gain Threat Actor Notice.pdf"
    ],
    "report_names": [
        "2022-11-22 - Nighthawk- An Up-and-Coming Pentest Tool Likely to Gain Threat Actor Notice.pdf"
    ],
    "threat_actors": [
        {
            "id": "26a04131-2b8c-4e5d-8f38-5c58b86f5e7f",
            "created_at": "2022-10-25T15:50:23.579601Z",
            "updated_at": "2025-03-27T02:00:55.50292Z",
            "deleted_at": null,
            "main_name": "TA551",
            "aliases": [
                "TA551",
                "GOLD CABIN",
                "Shathak"
            ],
            "source_name": "MITRE:TA551",
            "tools": [
                "QakBot",
                "IcedID",
                "Valak",
                "Ursnif"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "04e34cab-3ee4-4f06-a6f6-5cdd7eccfd68",
            "created_at": "2022-10-25T16:07:24.578896Z",
            "updated_at": "2025-03-27T02:02:10.286803Z",
            "deleted_at": null,
            "main_name": "TA551",
            "aliases": [
                "Gold Cabin",
                "Monster Libra",
                "Shathak",
                "TA551"
            ],
            "source_name": "ETDA:TA551",
            "tools": [
                "BokBot",
                "CRM",
                "Gozi",
                "Gozi CRM",
                "IceID",
                "IcedID",
                "Papras",
                "Snifula",
                "Ursnif",
                "Valak",
                "Valek"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "90f216f2-4897-46fc-bb76-3acae9d112ca",
            "created_at": "2023-01-06T13:46:39.248936Z",
            "updated_at": "2025-03-27T02:00:03.031127Z",
            "deleted_at": null,
            "main_name": "GOLD CABIN",
            "aliases": [
                "Shakthak",
                "TA551",
                "ATK236",
                "G0127",
                "Monster Libra"
            ],
            "source_name": "MISPGALAXY:GOLD CABIN",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "40b623c7-b621-48db-b55b-dd4f6746fbc6",
            "created_at": "2024-06-19T02:03:08.017681Z",
            "updated_at": "2025-03-27T02:05:17.342829Z",
            "deleted_at": null,
            "main_name": "GOLD CABIN",
            "aliases": [
                "TA551 ",
                "Shathak"
            ],
            "source_name": "Secureworks:GOLD CABIN",
            "tools": [
                ""
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535737,
    "ts_updated_at": 1743041638,
    "ts_creation_date": 1669662578,
    "ts_modification_date": 1669662578,
    "files": {
        "pdf": "https://archive.orkl.eu/e30846b0003f0b1ed34f5fdc1cccaaffd13ac061.pdf",
        "text": "https://archive.orkl.eu/e30846b0003f0b1ed34f5fdc1cccaaffd13ac061.txt",
        "img": "https://archive.orkl.eu/e30846b0003f0b1ed34f5fdc1cccaaffd13ac061.jpg"
    }
}