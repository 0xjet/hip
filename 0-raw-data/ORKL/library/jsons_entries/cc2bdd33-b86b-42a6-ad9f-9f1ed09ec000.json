{
    "id": "cc2bdd33-b86b-42a6-ad9f-9f1ed09ec000",
    "created_at": "2023-01-12T15:08:54.463854Z",
    "updated_at": "2025-03-27T02:12:11.127424Z",
    "deleted_at": null,
    "sha1_hash": "df1d837cde7f93cdb37a36bc49e273a55bb2b309",
    "title": "2015-02-27 - VB2014 paper- The pluginer - Caphaw",
    "authors": "",
    "file_creation_date": "2022-05-28T17:47:17Z",
    "file_modification_date": "2022-05-28T17:47:17Z",
    "file_size": 1027551,
    "plain_text": "# VB2014 paper: The pluginer - Caphaw\n\n**virusbulletin.com/virusbulletin/2015/02/paper-pluginer-caphaw**\n\n2015-02-27\n\n### Micky Pun\n\nFortinet, Canada\n\n### Neo Tan\n\nFortinet, Canada Editor: Martijn Grooten\n**Abstract**\n\nCaphaw, also known as Shylock, has been a quiet, yet persistent player on the botnet scene since 2011. It stands in great contrast to\nmost botnet malware in that it was released with complete functionality rather than being released into the wild while still in the testing\nphase. The bold nature of the campaign (an easily identifiable entry point code sequence) was backed up by Caphaw’s intricately\ndesigned code structure which made it hard for analysts to create a complete profile of its malicious behaviour with various obfuscation\nand anti-sandbox techniques. In their VB2014 paper, Micky Pun and Neo Tan discuss the technical aspects of handling the antireversing strategies devised by the malware writer and evaluate how Caphaw could become a permanent fixture in the botnet scene in\nthe future.\n\n## Abstract\n\nOften identified by its abilities to spread through Skype and inject bank pages, Caphaw, also known as Shylock, has been a quiet, yet\npersistent player on the botnet scene since 2011. Caphaw is a rare kind of botnet in that it was released with complete functionality. It\nstands in great contrast to most botnet malware that is released into the wild while still in the testing phase. The bold nature of the\ncampaign (an easily identifiable entry point code sequence) was backed up by Caphaw’s intricately designed code structure which\nmade it hard for analysts to create a complete profile of its malicious behaviour with various obfuscation and anti-sandbox techniques.\nIn this article, we will discuss the technical aspects of handling the anti reversing strategies devised by the malware writer and evaluate\nhow Caphaw could become a permanent fixture in the botnet scene in the future.\n\n## Brief history of Caphaw\n\nOur research team first received a sample of Caphaw in late October 2011. In this version, the Caphaw client was extracted from the\n.data section of a companion memory injector and written into the memory of explorer.exe. Since every Caphaw sample includes its\nbuild version in order to identify itself to different instances through a named pipe, we have been able to build up a decent picture of\nmajor developmental milestones (see Figure 1).\n\n**Figure 1. Caphaw version timeline.**\n\n[(Click here to view a larger version of Figure 1.)](https://www.virusbulletin.com/uploads/images/figures/2015/02/PunTan-1-large.jpg)\n\nThe 1.0.x versions of Caphaw client consisted only of master mode and slave mode. Some of the modules, namely backsocket and\ndllhook, were bundled together with the Caphaw client in the custom packer. Some other capabilities, such as VNC and archiver, could\nbe downloaded from the Internet later, after the configuration files enabled them. Most of the strings were not encrypted, hence they\nwere visible after unpacking.\n\nIn the 1.4.1 version, the memory injector was combined into the Caphaw client, hence the malware also needed to handle the situation\nwhen the Caphaw DLL client was not invoked by a memory injector. It also added anti-VM and anti-debug mechanisms so that the\nmalicious payload would not trigger if it detected that it was running in a sandbox or debugging environment. Plug-ins were also\nintroduced in this version to remove the limitations of the original ‘modules’ system. The introduction of plug ins provided a more\n\n\n-----\n\nconvenient way to introduce new functionalities and standardize communication with the master between different modules. In addition,\nthe malware author created a test mode in order for the developer to be able to test the module and plug-in after download without\nbeing bothered by the newly added anti-VM and anti-debugging features.\n\nCaphaw showed signs of stability when version 1.7.x was introduced in February 2013. No major structural changes were made at this\npoint. Even later, in version 1.8.x, there were only slight changes to the traffic data pattern and additional code obfuscation. One\nobvious change in this version was the improvement to the custom encryption method of strings to eliminate wasted spaces (four zero\nbytes) at each encrypted string.\n\nOther than modifications to Caphaw which allow it to run more stably on an infected host, some small changes can be seen in its\nconfiguration parsing through different versions. Some older features (e.g. /hijackcfg/backconnect, /hijackcfg/oskill) have become\nobsolete in later versions, while new features (e.g. /hijackcfg/upload_file, /hijackcfg /grabemails/, /hijackcfg/upload_file) have been\nadded in newer clients. Detailed information on the available configuration in different versions is listed in Appendix 2.\n\n## Basic features\n\nThe Caphaw client is a DLL which can easily be identified by its entry point code where it checks the fdwReason parameter. The earlier\nversion of Caphaw was packed in a memory injector, so it would only continue to execute the malicious DLL if it recognized itself being\nloaded into the virtual memory space by the LoadLibrary API. In the later versions, Caphaw used a more advanced custom packer and\nintegrated the memory injected into the DLL client. The entry point of the DLL client reflects the fact that the malware is also capable of\nbeing a standalone memory injecting payload based on the fdwReason value.\n\nNewer versions of Caphaw have been improving their condition checking so that malicious behaviour is not launched in unintended\nenvironments. The main idea of the payload starts with setting up named pipes for inter-process communication, paving the way for a\nmulti-thread system operating the client. The older versions consist only of a master mode and a slave mode, where the master (shown\nin Figure 2) is responsible for communication with the C&C server while interacting with the slaves to run tasks that are enabled by the\nconfiguration file. Later versions also introduced ‘plug-ins’, which have standardized communication with the master, making plug-ins\ncompatible with different versions of the master.\n\n**Figure 2. Caphaw overview.**\n\n[(Click here to view a larger version of Figure 2.)](https://www.virusbulletin.com/uploads/images/figures/2015/02/PunTan-2-large.jpg)\n\nPrior to launching the master, Caphaw will determine whether it has been injected into to a specific browser (‘iexplore.exe’ or\n‘firefox.exe’). On hooking a recognized browser, it starts individual threads on the master to cover four areas of C&C server\ncommunication:\n\n1. Pinging the C&C server\n\n2. Sending back computer information\n\n3. Downloading and parsing the configuration file and carrying out tasks\n\n4. Logging (errors or master, slave, plug-in messages).\n\nInformation sent to the C&C server is encrypted with RC4 using a key (known as ID here) generated based on the host’s environment.\nThen all of the traffic is encapsulated with the SSL protocol. A few default C&C server domains are included in the code and the\nmalware uses a special generator to create a subnet name assuming that the DNS server will respond with an active C&C server IP\n\n\n-----\n\naddress. When the right condition is reached on the server side, the C&C server will send back a configuration file encrypted with\nbase64 and RC4 using the unique ID mentioned previously as the key.\n\n## Information collection\n\nTo encrypt the data that is sent, the malware author uses a custom algorithm to create a unique identification number. The algorithm\ncan be described as follows:\n\nData = CustomHashingCpuid [8 bytes] + VolumeSerialNumber [4 bytes] + ComputerName [? Bytes] + SecurityIdentifier [? Bytes]\n\nID = CustomOrderSwapping(MD5sum(Data))\n\nSince executing cpuid with different values stored in EAX yields different results, the malware author devised a wise plan to hash\nimportant information into eight bytes – see Listing 1.\n```\nFunc CustomHashingCpuid\nFor (i = 0 to 1):  ;Get vendor ID and Processor Info and Feature Bits\n CPUID( i)\n Result[0..3] ^= eax\n If i == 1:\n Ebx &= 0xFFFFFFh //store with processor’s additional feature info\n Result[0..3] ^= ebx\n Result[4..8] ^= ecx\n Result[4..8] ^= edx\nFor (i = 0x80000002h to 0x80000004h): ;Processor Brand String\n CPUID(i)\n Result[0..3] ^= eax\n Result[0..3] ^= ebx\n Result[4..8] ^= ecx\n Result[4..8] ^= edx\n return Result\nListing 1: The malware author devised a wise plan to hash important information into eight bytes.\n\n```\nThe malware uses the unique ID to encrypt the other information sent to the C&C server. Table 1 depicts the parameters and their\nrequest values (e.g.\nkey=a323e7d52d&id=012F789B3884E1400F7F5D954521F85B&inst=master&net=usa&cmd=cfg&time=2013.05.15+08%3a02%3a29.421).\n\n\n**Parameter**\n\n\n**Length**\n**(bytes)** **Description**\n\n\nkey 5 Using a custom algorithm to render a five-byte number from a hard-coded number in the malware\nbinary\n\nid 32 Unique ID generated based on the infected host’s information\nAlso used as RC4 key\n\ninst 5-8 Installation type which affects how the client parses and executes the downloaded file\n\n1. master\n\n2. slave\n\n3. pluginer\n\nnet N/A Hard-coded botnet name\n\ncmd 3-4 Command\n\n1. log\n\n2. ping\n\n3. cfg\n\n\n-----\n\n**Parameter**\n\n\n**Length**\n**(bytes)** **Description**\n\n\nw N/A Message type\n\n1. fileupload\n\n2. cmpinfo\n\n3. sols\n\n4. rqt\n\nbt 23 Build time (hard coded)\n\nversion 11 Build version (hard coded)\n\ntime 23 Current time\n\njt N/A Job time (in seconds)\nCurrent time minus initial infection time\n\n**Table 1. Information sent back to the C&C server.**\n\nThe key is generated using the following algorithm:\n```\nByte input[4] = hard-coded_value;\ntemp = sprintf( ‘%u%u%u%u’,input[0],input[1], input[2], input[3]);\ntemp = lldiv(temp, 0x3) // long unsigned division\ntemp = sprint( ‘%I64u’,atoi64(temp))\ntemp = md5sum(temp)\ntemp = md5sum(temp[0..9] )\nresult = temp[0-4]\n\n```\nThe hard-coded value for generating the key is the build time of the malware.\n\nThe malware will also generate a detailed report on the victim’s computer if the client determines that this is the first time the malware\nhas run on the machine. The report will be encrypted slightly more simply than the other communications and sent back to the server\nwith the command ‘cmd=log&w=cmpinfo’. This contains extended details of the infected host. The list is surprisingly thorough; we will\nlist just some of the more interesting parts:\n\nOS version, serial and CDKey\n\nCPU, RAM information\n\nFile system structure and available space\n\nComputer name, user name and privileges\n\nCode pages – Windows character encoding\n\nBrowser version\n\nList of anti-malware products (the relationships between the anti-malware value and the process names are shown in Appendix 1)\n\nWhether it is running in a virtual machine\n\nCertain local executable file information, including: userinit.exe, cftmon.exe, vsdrv.exe, etc.\n\nList of running services\n\nList of running processes\n\nList of installed programs\n\nSnapshots of register values (EAX, EBX, ECX, EDX)\n\nFigure 3 shows an example of the report. As you can see, AntiMalware=VMware here, since the bot considers the sandbox technique\nto be a kind of anti-virus method. Besides looking for a sandbox environment, it also scans through every current process to find\nmatches of other anti-virus products. A complete list is shown in Appendix 1.\n\n\n-----\n\n**Figure 3. A small fraction of the initial report.**\n\nThe purpose of this is obviously to draw a detailed description of the victim for more precise or tailored payloads/plug-ins to attack.\n\nAfter the initial report, it also tries to search for a bitcoin wallet in some known directories and upload it using w=rqt if it finds one. This\nattack can only affect an unprotected wallet file, since it doesn’t check whether the file is encrypted or not.\n\n## Anti-debug/analysis tricks\n\nThe following strategy is employed to obstruct reverse engineering of the malware:\n\n1. Caphaw has demonstrated an effective technique of obstructing static analysis by encrypting strings such as library names and\n\ncondition constants using a custom encryption routine and encoding API names using their hashing values. With a low probability\nof collision on string name hashes, the API call addresses can easily be retrieved by generating the hash of each API name in the\nimport table and retrieving the API call address when a match is found. This method can avoid revealing the API name strings.\nBesides, with all other critical string information encrypted, the analyst can only predict the function of the routines by looking at\nthe numeric values and call follows, thus, static analysis is nearly impossible (see Figure 4).\n\n**Figure 4. Code snippet showing how the API is resolved by using its hash value.**\n\n[(Click here to view a larger version of Figure 4.)](https://www.virusbulletin.com/uploads/images/figures/2015/02/PunTan-4-large.jpg)\n\n\n-----\n\n2. Table 2 depicts the tests the malware uses to detect virtual machine (VM) environments. For example, by iterating the full module\n\nname path returned by the ZwQuerySystemInformation API, it can detect a VM environment by detecting the existence of a\nknown hash of a known VM filename (such as vmscsi.sys) with the hashes of all module names. If a sandbox environment is\ndetected, the malware will delete itself and exit the process.\n\n\n-----\n\n**Targeted**\n**virtual**\n**environment** **Detection method**\n\nCheck if any of the following registry entries exist and contain the string ‘VirtualBox’ at ‘BIOVersion’ and\n‘SystemManufacturer’:\n\nSYSTEM\\ControlSet001\\Control\\SystemInformation\n\n**Virtual PC**\n\nTest 1: (system module check)\n\nMatch the hash of a running process with the hash of the following string:\n\nvmsrvc.exe\n\nvpcmap.exe\n\n**Table 2. Sandbox detection methods.**\n\n3. Unlike most malware, Caphaw has dedicated a huge amount of code to condition checking to ensure that the payload is deployed\n\nunder the exact conditions intended. Buried in a massive amount of obfuscated code, recovering all the capabilities of this\nmalware is rather time consuming and could easily be missed.\n\nIn the process of reversing the code, we discovered that the author had left a few backdoors open for testing the malware. When\nexecuting the malicious routine with these special arguments, it will execute the client in different modes. The malware will first check if\nthe local time is within two hours of the malware build time. If this is the case, it will go further and check whether the ‘-testing’ and ‘-vm’\narguments are provided in the command. If these conditions are met accordingly, the malware will not release any payload, or trigger\nthe anti-VM detection routine.\n\n**Figure 5. The malware compares the difference between the current time and the build time to two hours (7,200 seconds).**\n\n[(Click here to view a larger version of Figure 5.)](https://www.virusbulletin.com/uploads/images/figures/2015/02/PunTan-5-large.jpg)\n\n## Communication with C&C Server\n\n\n-----\n\nThe initial list of C&C server domains is encrypted in the binary. However, Caphaw uses a special technique to hide the active server\nIPs. The life of the domains is usually very short – it usually ranges from a couple of hours to one or two days – and on the client side, it\ngenerates the full server domains and request URLs by using the hard-coded ones in the following format: [random generated prefix].\n\n[hard-coded domain]?r=[random number]. All of the communication traffic goes through C&C server port 443 using the SSL protocol.\n\nThe pseudocode of the sub domain name generation is as follows:\n```\nCHAR_TABLE = {abcdefghijklmnopqrstuvwxyz0123456789};\nwhile ( char_count != 0)\n{\n  generated_sname += CHAR_TABLE[calcRandom(0x24)];\n  char_count --;\n}\nint calcRandom(int char_count_max)//generates random number under char_count_max\n{\n  v1 = randomDGASeed;\n  if ( !randomDGASeed )\n    v1 = gettickcount();\n  randomDGASeed = 214013 * v1 + 2531011;\n  return ((randomDGASeed >> 16) & 32767) / 32767.0 * char_count_max;\n}\n\n```\nThe char_count is also generated randomly using the calcRandom() function with char_count_max obtained from the following function\nwith a fixed argument: a1 = 0xC and a2=0x32. Therefore, char_count_max is constrained between 0xC and 0x12.\n```\nint generateCharCount (int a1, int a2)\n{\n  return calcRandom(2 * a2 * a1 / 100) + a1 * (100 - a2) / 100;\n}\n\n```\nThe thread responsible for communicating keeps generating domain names and querying them until it gets a response (see Figure 6).\n\n**Figure 6. Retrying generated URLs.**\n\n[(Click here to view a larger version of Figure 6.)](https://www.virusbulletin.com/uploads/images/figures/2015/02/PunTan-6-large.jpg)\n\nThen it sends the message to the response IP address in SSL protocol. A sample message in plaintext is as follows:\n```\nkey=a323e7d52d&id=012F789B3884E1400F7F5D954521F85B&inst=master&net=usa&cmd=cfg&time=2013.05.15+08%3a02%3a29.421\n\n```\nIt is then encrypted using RC4 algorithm with the key being the domain it was querying appended to the fixed string ‘ca5f2abe’ (e.g.\n‘bzdfv2bjw791h.e-protections.suca5f2abe’). However, in the current version, the initial report is encrypted using a different RC4 key\ngenerated by a simpler format which appends a hard-coded string to the C&C IP address (e.g. ‘189.127.48.11bzdfv2bjw791h’). Then it\nis encoded with base64, and posted to the server with ‘z=’ in front of the encoded message. If the ‘cmd’ variable is equal to ‘cfg’, the\nC&C server will send back the base64 result of the configuration message, subsequently encrypted by RC4 algorithm with a different\nkey. The key is the string of the ‘id’ value generated on the victim’s environment. After decryption, the configuration is in XML format.\nListing 2 shows a sample configuration.\n\n\n-----\n\n```\n<botnet name=”15aug”/>\n<timer_cfg success=”1200”faail=”1200”/>\n<timer_log success=”600”fail=”600”/>\n<timer_ping success=”1200”fail=”1200”/>\n<urls_server>\n<url_server url=”https://sysinfonet.cc/ping.html”/>\n<url_server url=”https://sysinfo.cc/ping.html”/>\n<url_server url=”https://netprotections.cc/ping.html”/>\n</urls_server>\n<archiver url=”https://netprotections.cc/files/rar.exe”cmd=”a -r -dh -ep2 -v500k”/>\n<url_update md5=”62b8e4b26b46eb58cb10a00b5ed390ea”url=”/files/010-update-2ds5b9dp3db5/15aug_xcv.exe”updating=”offline”/>\n<vnc url dll=”/files/010-update2ds5b9dp3db5/vnc.dll”urldll_md5=”456a5739345754ad4af562a0c7d0ab0b”url=”https://80.86.88.87:8890”value=”off”/>\n<httpinject value=”on”url=”/files/010-update-2ds5b9dp3db5/hidden7770777.jpg”md5=”5dc90a34b59ea12414bd2923dc72e77d”/>\n<grabemails value=”off”/>\n<plugins>\n<plugin name=”archbot”url=”https://store-imgs.net/files/xmlz.gsm”value=”on”cmd=”https://store-imgs.net”/>\n<plugin name=”BackSocks”url=”/files/010-update-2ds5b9dp3db5/Bot.dll”value=”load”cmd=”higuards.cc:18365”/>\n<plugin name=”DiskSpread”url=”/files/010-update-2ds5b9dp3db5/dsp.psd”value=”on”cmd=”usa_xcv.exe”/>\n<plugin name=”MessengerSpread”url=”/files/010-update-2ds5b9dp3db5/msg.gsm”value=”on”cmd=”astats.su|||15aug_xcv.exe”/>\n</plugins>\n</hijackcfg>\nListing 2: A sample configuration.\n\n```\nAs you can see, the root level tag ‘hijackcfg’ suggests that this configuration is mainly for the hijacking process. With different install\nmodes, the bot parses different parts of the configuration.\n\n**Tag** **Inst = Master** **Inst = Slaver** **Inst = Pluginer**\n\nBotnet ✔ ✔ ✔\n\nTimer_cfg ✔ ✔ ✔\n\nTimer_log ✔ ✔ ✔\n\nTimer_ping ✔ ✔ ✔\n\nUrl_server ✔ ✔ ✔\n\nArchiver ✔\n\nUrl_update ✔\n\nVnc ✔ ✔\n\nHttpinject ✔ ✔ ✔\n\nGrabemails ✔\n\nPlugin ✔\n\n**Table 3. Comparison of parsing tags in different modes.**\n\nThe XML configuration is then parsed and saved into the named pipe. In this example, the ‘botnet’ tag shows the name of the botnet.\nThe ‘timer’ tags are the retry timeout settings. The ‘url_server’ tag stores the latest C&C server URLs. The ‘archiver’ tag contains a\ndownload address of a legitimate packer tool named ‘RAR 3.00’, which is used to pack the botnet client into a size of around 500KB\nwith the command line options ‘a -r -dh -ep2 -v500k’. The ‘url_update’ tag contains the address of the update file of this bot. Therefore,\nthe bot has two ways of updating its C&C server list: one from the url_server tag, and one from the update of the bot’s binary. This\nmakes tracking solely the downloading of the cfg file meaningless, because someone could just recompile the bot with a new C&C\nserver list to get rid of the tracker.\n\nThen there are the download modules. These modules can be either installed or uninstalled according to whether the ‘value’ is ‘on’ or\n‘off’. The ‘vnc’ tag contains the download address of the vnc module. The ‘httpinject’ tag contains the download address of the script file\nwhich is to be injected into the web pages. And the ‘grabemails’ tag may contain the download address of the module which can\nharvest users’ email address books.\n\nThe MD5 is for pre-download comparison – if a module already exists in the system, it will not be downloaded again. The ‘plugin’ tags\ncontain the download addresses of the DLLs to be loaded into the injected process. To be distinct from the executable modules, the\nDLLs are always loaded via the exported function in order, ‘Init’ then ‘Start’. And the ‘cmd’ values are fed as the command line options\nof the DLL.\n\n\n-----\n\nNotice that most of the URLs in this configuration are missing domain names. The bot generates domains using the same algorithm as\ndescribed previously, appends ‘r=[random]’ to the end of the URL, and sends a Get message to try to download the file (e.g.\nhttps://bzdfv2bjw791h.netprotections.cc/files/010-update-2ds5b9dp3db5/msg.gsm?r=1312723419). In the most recent version of the\nmalware (at the time of writing), the message is changed to POST with an empty z= value.\n\nFor keeping track of the updated C&C servers, the parsed url_server and the httpinject information is also saved into a local file in\n%AppData% with a random name (e.g. 1937592302.dat) and encrypted using the RC4 algorithm with the id (as seen in Table 1). The\nfollowing is a sample content of the decrypted .dat file:\n```\nbotnet=usa\ninjects=/files/010-update-9gdrdhb30/hidden7770777.jpg\nserver1=https://ehistats.su/ping.html\nserver2=https://sysinfo.cc/ping.html\nserver3=https://netprotections.cc/ping.html\nserver4=https://sysinfonet.cc/ping.html\nserver5=https://iestats.cc/ping.html\nserver6=https://ieguards.su/ping.html\n\n## Inline hooking and anti-hooking\n\n```\nThe malware injects itself into other active processes. If it finds out that the host process is either iexplore.exe or firefox.exe, it will inline\nhook the communication APIs used by the browser processes, then contact the C&C server with the ‘cmd’ value set to ‘cfg’ in order to\nget the latest configuration. Otherwise, if the host process is not explorer.exe, userinit.exe or rundll32.exe, it will start to contact the C&C\nserver with the ‘cmd’ value set to ‘ping’ in the message.\n\nThe APIs it is targeting in iexplore.exe are the following:\n\nws2_32.dll:\n\nsend\n\nwininet.dll:\n\nHttpOpenRequestA\n\nHttpOpenRequestW\n\nHttpSendRequestA\n\nHttpSendRequestW\n\nHttpSendRequestExA\n\nHttpSendRequestExW\n\nInternetReadFile\n\nInternetReadFileExA\n\nInternetReadFileExW\n\nInternetCloseHandle\n\nInternetQueryDataAvailable\n\nInternetSetStatusCallback\n\nThe screenshot in Figure 7 shows that the HttpSendRequestW API in iexplore.exe is inline-hooked.\n\n**Figure 7. The beginning of the HttpSendRequestW API is hooked.**\n\nThe APIs it targets in firefox.exe are the following:\n\n\n-----\n\nnspr4.dll:\n\nPR_Read\n\nPR_Write\n\nPR_Close\n\nnss3.dll:\n\nCERT_VerifyCertName\n\nCERT_VerifyCertNow\n\nThe functions hooking these APIs can disable security warnings and manipulate the sending and receiving of the web pages. This is the\ncore feature that enables Caphaw’s man-in-the-browser abilities. And because the bot uses some of these APIs for communication with\nthe C&C servers as well, it creates a backdoor table to store the first couple of instructions of the API call following a push-retn jump\nback to the original routine. When contacting the C&C server, it calls these addresses directly to bypass the inline hooks, which were\nmade by itself.\n\n**Figure 8. Pre-defined location used to store dummy code, now stores the initial instructions (in red) and a jump to the API.**\n\n## Modules and plug-ins\n\nThe following is a list of modules and plug-ins that have been downloaded by Caphaw over the years:\n\n1. Browser cookie stealer (using archiver to archive and upload)\n\n2. Flash cookies (SOLS) stealer\n\n3. VNC server\n\n4. Video capture and uploader (using archiver to archive and upload)\n\n5. Message Spreader (via Skype)\n\n6. Disk Spreader (worm)\n\n7. Backsocks (modifies source code of 3proxy – a 3APA3A simplest proxy server, socks.c precisely).\n\nThe cookie stealer has the ability to steal or delete HTML and Flash cookies to facilitate the HTTP inject. The VNC server can enable\nthe attacker to gain remote access to the victim’s computer. The video capture and uploader can be used to monitor the victim’s\ninteraction with the computer, therefore drawing an even more complete picture of the target. The last three plug-ins are the recently\nactive ones. Message Spreader can send spam messages via Skype to spread itself or other malware. Disk Spreader can spread the\n\n\n-----\n\nbot via removable drives. Backsocks can tunnel the attacker s traffic through the victim s machine into its internal networks, which\nopens up a new area of resources for the attacker to gain access to – and because it uses the back SOCKS protocol, it can also work in\na NAT network.\n\nAll of these plug-ins can easily be installed/uninstalled. We believe the actual list of downloadable plug-ins will be larger than this. By\nknowing the user’s information, the bot master can also tailor the list of plug-ins to be installed on the victim’s machine. BoB\n\n## Botnet operations\n\nCaphaw is known for its ability to steal banking information and is most active in North America and western European countries. Figure\n9 shows the distribution of active Caphaw C&C server locations during May 2014. In 31 days we discovered in total 28 active servers\nwhich were mainly located in North America and western European countries. Note that North America has alone has 12 C&C servers\nwhich are evenly distributed between the east and west coast.\n\n**Figure 9. Location of active Caphaw C&C servers in May 2014.**\n\n## Conclusion\n\nAfter two years of development, Caphaw has become a dangerous piece of malware. Unlike other botnets, Caphaw is meticulous about\nits targets and extremely cautious in not launching any malicious activities if the environment is not deemed ‘safe’. In addition to\ngenerating profit through man-in-the-browser attacks and occasional bitcoin mining, Caphaw has also shown great interest in infiltrating\ninternal networks with its arsenal of tools (Backsocks, Disk Spreader, video capturing and VNC server), which seems far beyond the\nrequirements of simply making money quickly.\n\nHaving two ways of updating its C&C server list and utilizing advanced code obfuscation techniques have benefited Caphaw in its ability\nto remain undiscovered in a host for a long time. All of these signs indicate that Caphaw is a competent APT candidate which is capable\nof hosting a reliable botnet. However, taking the time to reverse engineer Caphaw has proven fruitful as we have uncovered its core\nmodule’s code structure, anti-analysis tricks and communication protocol. This gives us great leverage in terms of tracking and fighting\nthis threat.\n\n## Appendix 1: Detected anti-virus vendors and targeted process\n\n**Anti-malware value** **Process name**\n\nAgava firewall Fwservice.exe\n\nAtGuard firewall iamapp.exe\n\nAuthentium vseamps.exe\n\nAuthentium vsedsps.exe\n\nAvast ashServ.exe\n\nAvast AvastSvc.exe\n\n\n-----\n\n**Anti-malware value** **Process name**\n\nAvast aswUpdSv.exe\n\nAvast ashDisp.exe\n\nAvira avgnt.exe\n\nAvira avguard.exe\n\nAvira sched.exe\n\nAVG avgwdsvc.exe\n\nAVG avgfws.exe\n\nAVG avgemcx.exe\n\nAVG avgrsx.exe\n\nAVG avgchsvx.exe\n\nAVG avgcc.exe\n\nAVG avgemc.exe\n\nAVG avgupsvc.exe\n\nAVG avgw.exe\n\nAVG guard.exe\n\nAVG avgamsvr.exe\n\nBitDefender vsserv.exe\n\nAnti-malware value Process name\n\nBullGuard BullGuard.exe\n\nBullGuard BullGuardBhvScanner.exe\n\nCA caamsvc.exe\n\nCA isafe.exe\n\nCA casc.exe\n\nCA ccEvtMgr.exe\n\nCA ccprovsp.exe\n\nCA ccschedulersvc.exe\n\nComodo firewall cfp.exe\n\nComodo firewall cssurf.exe\n\nComodo firewall cmdagent.exe\n\nComcast Spyware Scan ComcastAntiSpyService.exe\n\nComcast Spyware Scan ComcastAntispy.exe\n\nDeepFreeze deepfreeze.exe\n\nDoctor Web dwengine.exe\n\nDoctor Web drweb32w.exe\n\nDoctor Web frwl_svc.exe\n\nEmsisoft a2service.exe\n\niS3 SZServer.exe\n\n\n-----\n\n**Anti-malware value** **Process name**\n\nKaspersky avp.exe\n\nKERIO winroute.exe\n\nMalwarebytes mbamservice.exe\n\nMalwarebytes mbam.exe\n\nMSEssentials msseces.exe\n\nNod32 egui.exe\n\nNod32 ekrn.exe\n\nNod32 nod32krn.exe\n\nNod32 nod32kui.exe\n\nNeT firewall Firewall.msc\n\nNorton360 ccSvcHst.exe\n\nNorton navapw32.exe\n\nNorton navapsvc.exe\n\nMcAfee SSScheduler.exe\n\nMcAfee EngineServer.exe\n\nMcAfee Mcshield.exe\n\nMcAfee mfeann.exe\n\nMcAfee mcagent.exe\n\nMcAfee VsTskMgr.exe\n\nMcAfee myAgtSvc.exe\n\nMcAfee McSACore.exe\n\nMS Firewall Client FwcAgent.exe\n\nMS Firewall Client FwcMgmt.exe\n\nLavasoft Ad-Aware AAWService.exe\n\nLavasoft Ad-Aware AAWWSC.exe\n\nLavasoft Ad-Aware AAWTray.exe\n\nOnlineArmor firewall oasrv.exe\n\nOutpost firewall op_mon.exe\n\nPanda avengine.exe\n\nPanda PavFnSvr.exe\n\nPanda PavPrSvr.exe\n\nPanda psksvc.exe\n\nPanda firewall pshost.exe\n\nPanda firewall ppfw.exe\n\nRapport rapportservice.exe\n\nRapport rapportmgmtservice.exe\n\nPC Cleaner PCCleaners.exe\n\n\n-----\n\n**Anti-malware value** **Process name**\n\nPrevx prevx.exe\n\nPC Tools SSDMonitor.exe\n\nSophos ALsvc.exe\n\nSophos almon.exe\n\nSophos ManagementAgentNT.exe\n\nSophos RouterNT.exe\n\nSophos SAVAdminService.exe\n\nSophos SavService.exe\n\nSophos swi_service.exe\n\nSoftPerfect Personal Firewall fw.exe\n\nSpyware Doctor FGuard.exe\n\nSpyware Doctor pctsGui.exe\n\nSpybotSD TeaTimer.exe\n\nSUPERAntiSpyware SUPERAntiSpyware.exe\n\nSymantec ccApp.exe\n\nSymantec ccSvcHst.exe\n\nSymantec Rtvscan.exe\n\nSymantec DefWatch.exe\n\nSymantec ccEvtMgr.exe\n\nSymantec ccSetMgr.exe\n\nSymantec ccSvcHst.exe\n\nSymantec DoScan.exe\n\nSymantec SPBBCSvc.exe\n\nSymantec SmcGui.exe\n\nTrend Micro coreFrameworkHost.exe\n\nTrend Micro PccNTMon.exe\n\nQuickHeal onlinent.exe\n\nQuickHeal SCANMSG.exe\n\nWebroot WRConsumerService.exe\n\nWindows Defender MSASCui.exe\n\nWindows Defender MsMpEng.exe\n\nVirgin Media Fws.exe\n\nVirgin Media RpsSecurityAwareR.exe\n\nVirgin Media ServicepointService.exe\n\nVirgin Media ServiceManager.exe\n\nVirgin Media AVGIDSAgent.exe\n\nZoneAlarm vsmon.exe\n\n\n-----\n\n**Anti-malware value** **Process name**\n\nZoneAlarm IswSvc.exe\n\n## Appendix 2: Recognized XML tag for configuration file\n\n**1.2** **1.4** **1.6** **1.9**\n\n/hijackcfg/vnc ✔ ✔ ✔\n\n/hijackcfg/urls_server/url_server ✔ ✔ ✔ ✔\n\n/hijackcfg/url_update ✔ ✔ ✔ ✔\n\n/hijackcfg/upload_file ✔ ✔ ✔\n\n/hijackcfg/uninstall ✔ ✔ ✔ ✔\n\n/hijackcfg/timer_ping ✔ ✔ ✔ ✔\n\n/hijackcfg/timer_inj_log ✔\n\n/hijackcfg/timer_err_log ✔\n\n/hijackcfg/timer_log ✔ ✔ ✔\n\n/hijackcfg/timer_dll_cfg ✔\n\n/hijackcfg/timer_cfg ✔ ✔ ✔\n\n/hijackcfg/solfiles value=%s ✔ ✔\n\n/hijackcfg/solfiles ✔ ✔ ✔ ✔\n\n/hijackcfg/oskill ✔\n\n/hijackcfg/plugins/plugin ✔ ✔ ✔\n\n/hijackcfg/modules ✔ ✔ ✔\n\n/hijackcfg/httpinject ✔ ✔ ✔ ✔\n\n/hijackcfg/grabemails ✔\n\n/hijackcfg/execute ✔ ✔ ✔ ✔\n\n/hijackcfg/dll_load/dll ✔ ✔ ✔ ✔\n\n/hijackcfg/cookies value=%s ✔ ✔\n\n/hijackcfg/cookies ✔ ✔ ✔ ✔\n\n/hijackcfg/certfiles ✔ ✔ ✔\n\n/hijackcfg/botnet ✔ ✔ ✔ ✔\n\n/hijackcfg/backconnect ✔ ✔\n\n/hijackcfg/archiver ✔ ✔ ✔ ✔\n\n/unit ✔ ✔ ✔ ✔\n\n/inject ✔ ✔ ✔ ✔\n\n/end ✔ ✔ ✔ ✔\n\n/data ✔ ✔ ✔ ✔\n\n/begin ✔ ✔ ✔ ✔\n\n\n-----\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order to infiltrate organizations’ dedicated\nenvironments and transform them into attack launchpads. In this article Aditya Sood presents a new module introduced by…\n\n### Collector-stealer: a Russian origin credential and information extractor\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to exfiltrate sensitive data from end-user systems\nand store it in its C&C panels. In this article, researchers Aditya K Sood and Rohit Chaturvedi present a 360…\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and from that moment onward, was intrigued by\nthe properties of these small pieces of self-replicating code. Joe Wells was an expert on computer viruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\nKurt Natvig wanted to understand whether it’s possible to recompile VBA macros to another language, which could then easily be ‘run’\non any gateway, thus revealing a sample’s true nature in a safe manner. In this article he explains how he recompiled…\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware, discussing his team's findings related to the\nC&C design and some security issues they identified during the research.\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\n_Copyright © 2015 Virus Bulletin_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2015/2015-02-27 - VB2014 paper- The pluginer - Caphaw.pdf"
    ],
    "report_names": [
        "2015-02-27 - VB2014 paper- The pluginer - Caphaw.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "132e1e0f-8725-42cb-8c2d-d2f3ebb1f005",
            "created_at": "2023-12-08T02:00:05.758552Z",
            "updated_at": "2025-03-27T02:00:03.267631Z",
            "deleted_at": null,
            "main_name": "UAC-0118",
            "aliases": [
                "FRwL",
                "FromRussiaWithLove"
            ],
            "source_name": "MISPGALAXY:UAC-0118",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536134,
    "ts_updated_at": 1743041531,
    "ts_creation_date": 1653760037,
    "ts_modification_date": 1653760037,
    "files": {
        "pdf": "https://archive.orkl.eu/df1d837cde7f93cdb37a36bc49e273a55bb2b309.pdf",
        "text": "https://archive.orkl.eu/df1d837cde7f93cdb37a36bc49e273a55bb2b309.txt",
        "img": "https://archive.orkl.eu/df1d837cde7f93cdb37a36bc49e273a55bb2b309.jpg"
    }
}