{
    "id": "848caabd-efcf-4eb6-9f4c-89cb85e1b89e",
    "created_at": "2023-01-12T15:00:35.547154Z",
    "updated_at": "2025-03-27T02:15:17.368205Z",
    "deleted_at": null,
    "sha1_hash": "94246e717b16be52cc510d1c1defb06c90fc9f67",
    "title": "2018-06-18 - Decrypting APT33‚Äôs Dropshot Malware with Radare2 and Cutter ‚Äì Part 2",
    "authors": "",
    "file_creation_date": "2022-05-28T15:52:37Z",
    "file_modification_date": "2022-05-28T15:52:37Z",
    "file_size": 1589276,
    "plain_text": "# Decrypting APT33‚Äôs Dropshot Malware with Radare2 and Cutter ‚Äì Part 2\n\n**[megabeets.net/decrypting-dropshot-with-radare2-and-cutter-part-2/](https://www.megabeets.net/decrypting-dropshot-with-radare2-and-cutter-part-2/)**\n\nJune 18, 2018\n\n## Prologue\n\nPreviously, in the first part of this article, we used Cutter, a GUI for radare2, to statically\nanalyze APT33‚Äôs Dropshot malware. We also used radare2‚Äôs Python scripting capabilities in\norder to decrypt encrypted strings in Dropshot. If you didn‚Äôt read the first part yet, I suggest\nyou do it [now.](https://www.megabeets.net/decrypting-dropshot-with-radare2-and-cutter-part-1/)\n\nToday‚Äôs article will be shorter, now that we are familiar with cutter and r2pipe, we can quickly\nanalyze another interesting component of Dropshot ‚Äî an encrypted resource that includes\nDropshot‚Äôs actual payload. So without further ado, let‚Äôs start.\n\n\n-----\n\n## Downloading and installing Cutter\n\nCutter is available for all platforms (Linux, OS X, Windows). You can download the latest\n[release here. If you are using Linux, the fastest way to use Cutter is to use the AppImage](https://github.com/radareorg/cutter/releases)\nfile.\n\nIf you want to use the newest version available, with new features and bug fixes, you should\nbuild Cutter from source by yourself. It isn‚Äôt a complicated task and it is the version I use.\n\nFirst, you must clone the repository:\n```\ngit clone --recurse-submodules https://github.com/radareorg/cutter\ncd cutter\n\n```\nBuilding on Linux:\n```\n./build.sh\n\n```\nBuilding on Windows:\n```\nprepare_r2.bat\nbuild.bat\n\n```\n[If any of those do not work, check the more detailed instruction page here](https://github.com/radareorg/cutter/blob/master/docs/Compiling.md)\n\n## Dropshot \\ StoneDrill\n\nAs in the last part, we‚Äôll analyze Dropshot, which is also known by the name StoneDrill. It is a\nwiper malware associated with the APT33 group which targeted mostly organizations in\nSaudi Arabia. Dropshot is a sophisticated malware sample, that employed advanced antiemulation techniques and has a lot of interesting functionalities. The malware is most likely\n\n\n-----\n\n[related to the infamous Shamoon malware. Dropshot was analyzed thoroughly by](https://en.wikipedia.org/wiki/Shamoon)\n[Kaspersky and later on by](https://app.box.com/s/olc867zxc9nkjzm3wkjwi0b0e2awahtn) [FireEye. In this article, we‚Äôll focus on decrypting the encrypted](https://www.fireeye.com/blog/threat-research/2017/09/apt33-insights-into-iranian-cyber-espionage.html)\nresource of Dropshot which contains the actual payload of the malware.\n\n[The Dropshot sample can be downloaded from here (password: infected). I suggest you star](https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%203%20-%20Malware%20analysis/dropshot.exe.zip)\n(‚òÖ) [the repository to get updates on more radare2 tutorials üôÇ](https://github.com/ITAYC0HEN/A-journey-into-Radare2/)\n\n**Please, be careful when using this sample. It is a real malware, and more than that, a**\n**wiper! Use with caution!**\n\n_Since we‚Äôll analyze Dropshot statically, you can use a Linux machine, as I did._\n\n## Getting Started\n\nAssuming you went through the first part of the article, you are already familiar with Cutter\nand r2pipe. Moreover, you should already have a basic clue of how Dropshot behaves. Open\nthe Dropshot sample in Cutter, execute in Jupyter the r2pipe script we wrote and seek to the\n`main` function using the ‚ÄúFunctions‚Äù widget or the upper search bar.\n\nA function we analyzed in the previous article | Click to enlarge\n\n## main ()\n\nThe role of the `main() function in a program shouldn‚Äôt be new to you since it is one of the`\nfundamental concepts of programming. Using the Graph mode, we‚Äôll go thorugh `main ‚Äòs`\nflow in order to find our target ‚Äì the resource decryption routine. We can see that a function\nat `0x403b30 is being called at the first block of` `main .`\n\n\n-----\n\nDouble-clicking this line will take us to the graph of `fcn.00403b30, a rather big function.`\nGoing through this function, we‚Äôll see some non-sense Windows API calls with invalid\narguments. When describing Dropshot, I said that it uses anti-emulation heavily ‚Äì this\nfunction, for example, performs anti-emulation.\n\n\n-----\n\nClick to enlarge\n\n### Anti-Emulation\n\nAnti-emulation techniques are used to fool the emulators of anti-malware products. The\nemulators are one of the most important components of many security products. Among\nothers, they are used to analyze the behavior of malware, unpack samples and to analyze\nshellcode. It is doing this by emulating the program‚Äôs workflow by mimicking the target\narchitecture‚Äôs instruction set, as well as the running environment, and dozens or even\nhundreds of popular API functions. All this is done in order to make a malware ‚Äòthink‚Äô it has\nbeen executed in a real environment by a victim user.\n\nThe emulator engine is mimicking the API or the system calls that are offered by the actual\noperating systems. Usually, it will implement popular API functions from libraries such\nas user32.dll, kernel32.dll, and ntdll.dll. Most of the times this will be a dummy\nimplementation where the fake functions won‚Äôt really do anything except returning a\nsuccessful return value.\n\n\n-----\n\nBy using different anti-emulation techniques, malware authors are trying to fool a generic or\neven a specific emulator. The most common technique, which is also implemented in\nDropshot‚Äôs `fcn.00403b30, is the use of uncommon or undocumented API calls. This`\ntechnique can be improved by using incorrect arguments (like NULL) to a certain API\nfunction which should cause an Access Violation exception in a real environment.\n\nIn our case, Dropshot is calling some esoteric functions as well as passing non-sense\narguments to different API functions.\n\n_More information about emulation and anti-emulation mechanisms are available in the_\n_[following, highly recommended, book: The Antivirus Hacker‚Äôs Handbook](https://www.amazon.com/Antivirus-Hackers-Handbook-Joxean-Koret/dp/1119028752)_\n\nNow that we know all this, we can rename this function from `fcn.00403b30 to a more`\nmeaningful name. I used ‚ÄúAntiEmulation‚Äù but you can choose whatever name you want, as\nlong as it is meaningful to you. Clicking the call instruction and then pressing Shift+N will\nopen the Rename dialog box. Right-clicking the row and choosing ‚ÄúRename‚Äù will do the job\nas well.\n\nAfter `main is calling to the AntiEmulation function, we are facing a branch. Here‚Äôs the`\nassembly, copied from Cutter‚Äôs Disassembly widget:\n```\n|      0x004041a6      call AntiEmulation\n|      0x004041ab      mov eax, 1\n|      0x004041b0      test eax, eax\n|   ,=< 0x004041b2      je 0x40429d\n|    |  0x004041b8      push 4\n\n```\nAs you can see, the code would never branch to `0x40429d since this` `test eax,`\n```\neax followed by je ... is basically checking whether eax equals 0. One instruction\n\n```\nbefore, the program moved the value 1 to `eax, thus` `0x40429d would be The Road Not`\nTaken.\n\nWe‚Äôll skip the next block which is responsible for creating temporary files and take a look at\nthe block starting at `0x4041f9 . In this block, we‚Äôll see that Dropshot is creating a modeless`\n[Dialog box using CreateDialogParamA with the following](https://msdn.microsoft.com/en-us/library/windows/desktop/ms645445(v=vs.85).aspx)\n\n\n-----\n\nparameters: `CreateDialogParamA(0, 0x410, 0, DialogFunc, 0); .`\n\nThe DialogPrc callback which is passed to `CreateDialogParamA is recognized by radare2`\nand shown by Cutter as `fcn.DialogFunc . This function contains the main logic of the`\ndropper and this is the function that we‚Äôll focus on. Later in this block, `ShowWindow is being`\ncalled in order to ‚Äúshow‚Äù the window. Obviously, this is a dummy window which would never\nbe shown since the malware author doesn‚Äôt want any artifact to be shown to the victim.\n```\nShowWindow will trigger the execution of fcn.DialogFunc .\n\n```\nDouble-clikcing on `fcn.DialogFunc will take us to the function itself. We can see that it is`\nperforming several comparisons for the messages it receives and then is calling to a very\ninteresting function `fcn.00403240 .`\n\n## Handling the Resources\n\nThe first block of `fcn.00403240 is pretty straightforward. Dropshot is getting a handle to`\nitself using `GetModuleHandleA . Then, by using` `FindResourceA, it is locating a resource`\nwith a dummy type 0x67 (Decimal: 111) and a name 0x6e (Decimal: 110). Finally, it is loading\na resource with this name using `LoadResource .`\n\n\n-----\n\nUsing Cutter, we can see the content of this resource. Simply go to the Resources widget\nand locate the resource with the name ‚Äú110‚Äù.\n\n\n-----\n\nAs you can see in the screenshot above, the size of the resource is 28 Bytes and its Lang is\nFarsi which might hint us about the threat actor behind Dropshot.\n\nDouble-clicking the resource will take us to the resource‚Äôs address. Let‚Äôs click on the\nHexdump widget to see its data. In the hexdump we can see that this resource contains the\nfollowing bytes: `01 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 01 00 00 00 01`\n```\n00 00 00 00 00 00 00 . Those of you who are familiar with radare2 may use the Console\n\n```\nwidget in the bottom left to do this quickly with `px :`\n\nThis resource will be used later but we won‚Äôt be getting into it since it is out of the scope of\nthis post.\n\n\n-----\n\nAfter loading the resource, in the next block we can see the start of a loop:\n\nThis loop is checking if `local_2ch equals to 0x270f (Decimal: 9999) and if yes it exits from`\nthe loop. Inside this loop, there will be another loop of 999 iterations. So basically, this is how\nthis nested loop looks like:\n```\n for ( i = 0; i < 9999; ++i )\n {\n  for ( j = 0; j < 999; ++j )\n  {\n    dummy_code;\n  }\n }\n\n```\nThis is just another anti-emulation\\analysis technique which is basically doing nothing. This is\nanother example of the heavy use of anti-emulation by Dropshot.\n\nAfter this loop, the right branch is taken and this is an interesting one.\n\n\n-----\n\nClick to enlarge\n\nAt first, `VirutalAlloc in the size of 512 bytes is being called. Next,` `fcn.00401560 is`\ncalled with 3 arguments. Let‚Äôs enter this function and see what‚Äôs in there:\n\n\n-----\n\nClick to enlarge\n\nHey! Look who‚Äôs back! We can see the 2 functions we analyzed in the previous article:\n```\ndecryption_function and load_ntdll_or_kernel32 . That‚Äôs great! Also, you can\n\n```\nnotice the comment on `call decryption_function which is telling us that the decrypted`\nstring is `GetModuleFileNameW . This comment is the result of the r2pipe script we wrote.`\n\nIn this function, `GetModuleFileNameW will be decrypted, then Kernel32.dll will be loaded`\nand `GetProcAddress will be called to get the address of` `GetModuleFileNameW and then`\nit will move it to `[0x41dc04] . Later in this function,` `[0x41dc04] will be called.`\n\nBasically, this function is wrapper around `GetModuleFileNameW, something which is`\ncommon in Dropshot‚Äôs code. Let‚Äôs rename this function to `w_GetModuleFileNameW where`\n‚Äúw_‚Äù stands for ‚Äúwrapper‚Äù. Of course, you can choose whatever naming convention you\nprefer.\n\nRight after the call to `w_GetModuleFileNameW, Dropshot is using VirtualAlloc to allocate 20`\n(0x14) bytes, then there is a call to `fcn.00401a40 which is a function quite similar to`\n```\nmemset, it is given with 3 arguments (address, value and size), just like memset and it is\n\n```\nresponsible to fill the range from `address to` `address+size with the given`\n```\nvalue . Usually, along the program, this function is used to fill an allocated buffer with\n\n```\nzeroes. This is quite strange to me, since VirtualAlloc is already ‚Äúinitializes the memory it\nallocates to zero‚Äù. Let‚Äôs name this function to `memset_ using Shift+N or via right click and`\nmove on.\n\n\n-----\n\nRight after the program is zeroing-out the allocated memory, we see a call to another\nfunction ‚Äì `fcn.00401c90 . We can see 3 arguments which are being passed to it, 0x14,`\n0x66, and 0x68. Since sometimes we prefer to see decimal numbers and not hex, let‚Äôs use\nanother useful trick of Cutter. Right-click on any of these hex numbers and choose ‚ÄúSet\nImmediate Base to‚Ä¶‚Äù and then select ‚ÄúDecimal‚Äù.\n\nNow we can see that the values which are being passed to `fcn.00401c90 are 20, 102 and`\n104. Looks familiar? 20 was the size of the buffer that was just allocated. 102 and 104\nremind us the Resource name and type that used before (110 and 111). Are we dealing with\nresources here? Let‚Äôs see.\n\nMoving to the Resources widget again, we can see that there‚Äôs indeed a resource named\n‚Äú102‚Äù which ‚Äú104‚Äù is its type. And yes, it is 19B long, close enough üòâ\n```\nfcn.00401c90 is one of the key functions involved in the dropper functionality of Dropshot.\n\n```\nThe thing is, that this function is rather big and quite complicated when you don‚Äôt know how\nto look at it. We‚Äôll get back to it in one minute but before that, I want to show you an\napproach I use while reverse engineering some pieces of code and while facing a chain of\ncalls to functions which are probably related to each other.\n\nFirst, we saw that 20 bytes were allocated by `VirtualAlloc and the pointer to the`\nallocated memory was moved to `[local_ch] . Right after that,` `memset_ was called in`\norder to zero-out 20 bytes at [local_ch], i.e to zero-out the allocated buffer. Immediately\nafter, `fcn.00401c90 was called and 3 arguments were passed to it ‚Äì 104, 102 and our`\n\n\n-----\n\nbeloved 20. We know that 102 is a name of a resource and its size is almost 20. We don t\nknow yet what this function is doing but we know that its return value( eax ) is being passed\nalong with 2 more arguments to another function, `fcn.00401a80 . The other arguments are,`\nyou guessed right, 20 and the allocated buffer. A quick look at `fcn.00401a80, which is a`\nreally tiny function, will reveal us that this function is copying a buffer to the allocated\n[memory. This function is quite similar to memcpy so we‚Äôll rename it to](http://en.cppreference.com/w/c/string/byte/memcpy) `memcpy_ . So now we`\ncan do an educated guess and say that `fcn.00401c90 is reading a resource to a buffer`\nand returns a pointer to it.\n\nUsing this approach, we can understand (or at least guess) a complicated function without\neven analyzing it. Just by looking at a programs chain of function calls, we can build the\npuzzle and save us important time.\n\nThat said, we‚Äôll still give this function a quick analysis because we want to be sure that we\nguessed right, and more importantly ‚Äî because this is an interesting function.\n\n## Resource Parser\n\nThe next part is where things are getting more complicated. We‚Äôll start by going over\n```\nfcn.00401c90 pretty fast so try to follow. Also, you may want to make sure you fasten\n\n```\nyourself since we are going on a rollercoaster ride through the PE structure.\n\nTake a look at the first block of this function. You‚Äôll see one `call and a lot of` `mov,`\n```\nadd and calculation of offsets. This is how a typical PE parsing looks like.\n\n```\n\n-----\n\n```\n/ (fcn) fcn.00401c90 468\n|  fcn.00401c90 (int arg_8h, int arg_ch, int arg_10h);\n|      0x00401c90      push ebp\n|      0x00401c91      mov ebp, esp\n|      0x00401c93      sub esp, 0x44\n|      0x00401c96      mov dword [local_40h], 0\n|      0x00401c9d      push 0\n|      0x00401c9f      call GetModuleHandleW\n|      0x00401ca5      mov dword [local_34h], eax\n|      0x00401ca8      mov eax, dword [local_34h]\n|      0x00401cab      mov dword [local_20h], eax\n|      0x00401cae      mov ecx, dword [local_20h]\n|      0x00401cb1      mov dword [local_24h], ecx\n|      0x00401cb4      mov edx, dword [local_24h]\n|      0x00401cb7      mov eax, dword [edx + 0x3c]\n|      0x00401cba      add eax, dword [local_24h]\n|      0x00401cbd      mov dword [local_38h], eax\n|      0x00401cc0      mov ecx, dword [local_38h]\n|      0x00401cc3      add ecx, 0x18\n|      0x00401cc6      mov dword [local_3ch], ecx\n|      0x00401cc9      mov edx, dword [local_3ch]\n|      0x00401ccc      add edx, 0x60\n|      0x00401ccf      mov dword [local_28h], edx\n|      0x00401cd2      mov eax, 8\n|      0x00401cd7      shl eax, 1\n|      0x00401cd9      mov ecx, dword [local_28h]\n|      0x00401cdc      mov edx, dword [ecx + eax]\n|      0x00401cdf      mov dword [local_44h], edx\n|      0x00401ce2      mov eax, 8\n|      0x00401ce7      shl eax, 1\n|      0x00401ce9      mov ecx, dword [local_28h]\n|      0x00401cec      mov edx, dword [local_20h]\n|      0x00401cef      add edx, dword [ecx + eax]\n|      0x00401cf2      mov dword [local_10h], edx\n|      0x00401cf5      mov eax, dword [local_10h]\n|      0x00401cf8      mov dword [local_4h], eax\n|      0x00401cfb      mov ecx, dword [local_4h]\n|      0x00401cfe      movzx edx, word [ecx + 0xe]\n|      0x00401d02      mov eax, dword [local_4h]\n|      0x00401d05      movzx ecx, word [eax + 0xc]\n|      0x00401d09      add edx, ecx\n|      0x00401d0b      mov dword [local_ch], edx\n|      0x00401d0e      mov dword [local_14h], 0\n|   ,=< 0x00401d15      jmp 0x401d20\n...\n...\n\n```\nAt first, a handle to the current process is received using `GetModuleHandleW . Then, the`\nhandle ( eax ) is being moved to a variety of local variables. First, it is being moved to\n```\n[local_34h] at 0x00401ca5 . Then you can see eax moved to [local_20h] which is\n\n```\nlater being moved to `[local_24h] using` `ecx .`\n\n\n-----\n\nSo basically we have a bunch of local variables that currently hold the handle `hmodule . We`\ncan rename all three variables to `[hmodule_x] so it‚Äôll be easier to keep track of all the`\nreference to `hmodule . To rename flags you can use the Console widget and just execute`\n```\nafvn old_name new_name . For example, I executed: afvn local_34h hmodule_1; afvn\nlocal_20h hmodule_2; afvn local_24h hmodule_3 .\nGetModuleHandle returns a handle to a mapped module, this basically means that our\nhmodule s point to our binary‚Äôs base address. In line 0x00401cb4 we can see that\n[hmodule_3] is moved to edx, then the value at [edx + 0x3c] is being moved to eax\n\n```\nand `[hmodule_3] is added to it at` `0x00401cba . Finally,` `eax is moved to`\n```\n[local_38h] . To put it simply, we can use the following pseudo-code:\n[local_38h] = (BYTE*)hmodule + *(hmodule + 0x3c)\n\n```\nSo what‚Äôs in this address? Use your favorite binary structure viewer to find out. In this\n[example, I‚Äôll use PEview but you can use any other program you prefer ‚Äì including the binary](http://wjradburn.com/software/)\n[structure parsing feature of radare2, if you‚Äôre already a radare2 pro (see pf?).](http://radare.today/posts/parsing-a-fileformat-with-radare2/)\n\nOpen Dropshot in PEview and inspect the DOS Header:\n\nAs you can see, in offset `0x3c there is a pointer (0x108) to the offset to the new EXE`\n[Header which is basically the IMAGE_NT_HEADER. Awesome! So](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680336(v=vs.85).aspx) `[local_38h] holds the`\naddress of the NT Header. Let‚Äôs rename it to `NT_HEADER and move on.`\n\n\n-----\n\nAt address `0x00401cc0 we can see that` `NT_HEADER is moved to` `ecx and then the`\nprogram is adding 0x18 to `ecx . Last, the value in` `ecx is moved to` `[local_3ch] . Just`\nas before, let‚Äôs open again our PE parser and check what is in `NT_HEADER + 0x18 . Adding`\n0x18 to 0x108 will give us 0x120. Let‚Äôs see what is in this offset:\n\nClick to enlarge\n\nNice! 0x120 is the offset of the [IMAGE_OPTIONAL_HEADER as can be seen in the image](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680339(v=vs.85).aspx)\nabove. Let‚Äôs rename `local_3ch to` `OPTIONAL_HEADER . To cut a long story short, Dropshot`\n[is then parsing the IMAGE_DATA_DIRECTORY structure (OPTIONAL_HEADER + 0x60),](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680305(v=vs.85).aspx)\nthe RESOURCE_TABLE, and last it iterates through the different resources and compares\nthe resource type and the resource name to the function‚Äôs arguments. Finally, it uses\n```\nmemcpy_ to copy the content of the required resource to a variable and returns this variable.\n\n```\nNow we can rename the function to `get_resource and the arguments to the`\ncorresponding meaning of them by executing `afvn arg_8h arg_rsrc_type; afvn arg_ch`\n```\narg_rsrc_name; afvn arg_10h arg_dwsize .\n\n```\nNow that we are sure about what this function does, we can see where else it is referenced.\nRight-click on the function and choosing ‚ÄúShow X-Refs‚Äù (or simply pressing ‚Äòx‚Äô) will take us to\nthe X-Refs window. We can see that `get_resource is being called from two locations. One`\n( 0x0040336d ) is already familiar to us, it is called to get resource ‚Äú102‚Äù. The second call (at\n```\n0x00403439 ), a few instructions later, is new to us ‚Äî it is called to get the content of\n\n```\nanother resource, named ‚Äú101‚Äù (0x65).\n\n\n-----\n\nRemember the screenshot of the Resources widget from before? We can see there the\nresource named ‚Äú101‚Äù. What makes ‚Äú101‚Äù so interesting is that it is much bigger than the\nother ‚Äî its size is 69.6 KB! This is Dropshot‚Äôs payload. By going to the Resources widget\nand double-clicking ‚Äú101‚Äù will take us to the resource‚Äôs offset in the binary. In the Hexdump\nwidget, we can see that the content of this resource makes no sense and has a really high\nentropy (7.8 out of the maximum 8):\n\nClick to enlarge\n\n\n-----\n\nThis data is compressed/encrypted somehow so we need to decrypt it. Let s continue our\nanalysis to find out how.\n\n## How To Decrypt The Resource\n\nIn order to decrypt the resource, we should follow the program‚Äôs flow to see how and where\nthe payload is being used. Right after `get_resource is being called with ‚Äú101‚Äù and ‚Äú103‚Äù,`\nthe resource is copied to `[local_20h] using` `memcpy_ (at` `0x00403446 ). Let‚Äôs call it`\n```\ncompressed_payload . The compressed buffer is then passed to fcn.00401e70 which is\n\n```\na function that performs dummy math calculations on the resource‚Äôs data. Probably another\nAnti-Emulation technique or simply a way to waste our time. I‚Äôll rename it to\n```\ndummy_math . Next, compressed_payload is being passed to fcn.00401ef0 along with\n\n```\nanother buffer `[local_54h] .`\n\nThe analysis of this function is out of the scope of this article but this function is responsible\nto decompress a buffer using [zlib and put the decompressed buffer in](https://zlib.net/) `[local_54h] . You`\ncan see, for example, that `fcn.00401ef0 is calling to` `fcn.004072f0 which contains`\nstrings like ‚Äúunknown compression method‚Äù and ‚Äúinvalid window size‚Äù which can be found in\nthe file [inflate.c in the zlib repository. I renamed](https://github.com/madler/zlib/blob/master/inflate.c#L622) `fcn.00401ef0 to` `zlib_decompress and`\n```\nlocal_54h to decompressed_payload .\n\n```\nI‚Äôll tell you now that simply a decompression of the buffer isn‚Äôt enough since there‚Äôs still\nanother simple decryption to do. Straight after the decompressing, we can see more of the\nAnti-Emulation which we are already familiar with. Finally, our decompressed buffer is being\npassed to `fcn.00402620 . This function is responsible for the last decryption of the`\n[resource and then it performs a notorious technique known as ‚ÄúProcess Hollowing‚Äù or](https://attack.mitre.org/wiki/Technique/T1093)\n‚ÄúRunPE‚Äù in order to execute the decrypted payload.\n\nSo how `fcn.00402620 decrypts the decompressed payload? Simply, it uses` `ror 3 to`\nrotate-right each byte in the decompressed buffer. 3 stands for the number of bits to rotate.\n\n\n-----\n\nThe rest of this function is interesting as well but it has nothing to do with decrypting the\nresource so I‚Äôll leave it to you.\n\nTo sum things up, and before we adding the logic for the resource decryption inside the script\nwe wrote in the previous article ‚Äì let‚Äôs sketch how the decryption function should look like. It\nshould be something like this:\n```\nrsrc_101 = get_resource(\"101\")\ndecompressed_payload = decompress(rsrc_101)\ndecrypted_payload = []\nfor b in decompressed_payload:\n  decrypted_payload.append(ror3(b))\n\n## Scripting time! Decrypting the resource\n\n```\n[Scripting radare2 is really easy thanks to r2pipe. It is the best programming interface for](https://github.com/radare/radare2-r2pipe)\nradare2.\n\nThe r2pipe APIs are based on a single r2 primitive found\nbehind `r_core_cmd_str() which is a function that accepts a string parameter`\ndescribing the r2 command to run and returns a string with the result.\n\n\n-----\n\n[r2pipe supports many programming languages including Python,](https://github.com/radare/radare2-r2pipe/tree/master/python) [NodeJS,](https://github.com/radare/radare2-r2pipe/tree/master/nodejs/r2pipe) [Rust,](https://github.com/radare/radare2-r2pipe/tree/master/rust) [C, and](https://github.com/radare/radare2-r2pipe/tree/master/c)\nothers.\n\nLuckily, Cutter is coming with the python bindings of `r2pipe integrated into its Jupyter`\ncomponent. We‚Äôll write an r2pipe script that will do the following:\n\nSave the compressed resource into a variable\nDecompress the resource using zlib\nPerform ror3 on each byte in the decompressed payload\nSave the decrypted resource to a file\n\nJust as in the previous part, let‚Äôs go to the Jupyter widget and open the script we wrote when\ndecrypted the strings (part1).\n\nThe first thing to do is to read the content of the encrypted and compressed resource to a\nfile:\n```\nrsrcs = cutter.cmdj('iRj')\nrsrc_101 = {}\n# Locate resource 101 and dump it to an array\nfor rsrc in rsrcs:\n  if rsrc['name'] == 101:\n    rsrc_101 = cutter.cmdj(\"pxj %d @ %d\" %\n                (rsrc['size'], rsrc['vaddr']))\n   iR was used to get the list of resources and their offsets in the file. Next, we iterate\n\n```\nthrough the different resources untill we find a resource named ‚Äú101‚Äù. Last, using\n```\n   px we are reading the resource‚Äôs bytes into a varibale. We appended j to the\n\n```\ncommands in order to get their output as JSON.\n\nNext, we want to decompress the buffer using zlib. Python is coming with ‚Äúzlib‚Äù library by\ndefault which is great news for us. Add `import zlib to the top of the script and use this`\ncode to decompress the buffer:\n```\n# Decompress the zlibbed array\ndecompressed_data = zlib.decompress(bytes(rsrc_101))\n\n```\nNow that our buffer is decompressed in `decompressed_data, all we left to do is to perform`\nright rotation on the data and save it to a file.\n\nDefine [the following](https://www.falatic.com/index.php/108/python-and-bitwise-rotation) `ror lambda:`\n```\ndef ror(val, r_bits, max_bits): return \\\n  ((val & (2**max_bits-1)) >> r_bits % max_bits) | \\\n  (val << (max_bits-(r_bits % max_bits)) & (2**max_bits-1))\n\n```\nAnd use it in your code like this:\n\n\n-----\n\n```\ndecrypted_payload []\n# Decrypt the payload\nfor b in decompressed_data:\n  decrypted_payload.append((ror(b, 3, 8)))\n\n```\nLast, save it to a file:\n```\n# Write the payload (a PE binary) to a file\nopen(r'./decrypted_rsrc.bin', 'wb').write(bytearray(decrypted_payload))\n\n```\nNow let‚Äôs combine the script from the previous article to the one we created now and test it in\nJupyter. The combined script should first decode the encrypted scripts, and then it should\ndecrypt the resource and save it to the disk.\n\n**The final script can be found** **[here.](https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%203%20-%20Malware%20analysis/decrypt_dropshot.py)**\n\nCopy it and paste it into your Jupyter notebook. You can also execute your version of the\ncode to see if you got it right by yourself.\n\n\n-----\n\nSeems like our script was executed successfully and ‚ÄúSaved the PE to ./decrypted_rsrc.bin‚Äù.\nGreat!\n\n\n-----\n\nThe last thing we want to do is to open `decrypted_rsrc.bin in a new instance of Cutter in`\norder to verify that this is indeed a PE file and that we didn‚Äôt corrupt the file in some way.\n\nClick to enlarge\n\nAwesome! Cutter recognized the file as PE and seems like the code is correctly interpreted.\nThis binary we just decrypted and saved is the Wiper module of Dropshot ‚Äì a quite\ninteresting piece of malware on its own. This module, just as its dropper, is using heavy antiemulation and similar technique to decrypt its strings. You can give it a try and analyze it on\nyour own using Cutter, radare2, and r2pipe. Good Luck!\n\n## Epilogue\n\nHere comes to an end the second and the last part of this series about decrypting Dropshot\nwith Cutter and r2pipe. We got familiar with Cutter, radare2 GUI, and wrote a decryption\nscript in r2pipe‚Äôs Python binding. We also analyzed some components of APT33‚Äôs Dropshot,\nan advanced malware.\n\n[As always, please post comments to this post or message me privately if something is](https://www.megabeets.net/about.html#contact)\nwrong, not accurate, needs further explanation or you simply don‚Äôt get it. Don‚Äôt hesitate to\nshare your thoughts with me.\n\n**Subscribe on the left if you want to get the next articles straight in your inbox.**\n\n\n-----\n\n[Eat Veggies](https://www.megabeets.net/about.html#vegan)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-06-18 - Decrypting APT33‚Äôs Dropshot Malware with Radare2 and Cutter ‚Äì Part 2.pdf"
    ],
    "report_names": [
        "2018-06-18 - Decrypting APT33‚Äôs Dropshot Malware with Radare2 and Cutter ‚Äì Part 2.pdf"
    ],
    "threat_actors": [
        {
            "id": "b23e717c-0b27-47e0-b3c8-4defe6dd857f",
            "created_at": "2023-01-06T13:46:38.367369Z",
            "updated_at": "2025-03-27T02:00:02.815758Z",
            "deleted_at": null,
            "main_name": "APT33",
            "aliases": [
                "ATK35",
                "Peach Sandstorm",
                "TA451",
                "APT 33",
                "Elfin",
                "Refined Kitten",
                "MAGNALLIUM",
                "HOLMIUM",
                "COBALT TRINITY",
                "G0064"
            ],
            "source_name": "MISPGALAXY:APT33",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "9fe49a5b-f3e6-4fbf-99a1-db15dad460c3",
            "created_at": "2024-05-01T02:03:08.045004Z",
            "updated_at": "2025-03-27T02:05:17.325038Z",
            "deleted_at": null,
            "main_name": "COBALT TRINITY",
            "aliases": [
                "Elfin ",
                "HOLMIUM ",
                "MAGNALIUM ",
                "Peach Sandstorm ",
                "Refined Kitten ",
                "TA451 ",
                "APT33 "
            ],
            "source_name": "Secureworks:COBALT TRINITY",
            "tools": [
                " Cadlotcorg",
                " Dello RAT",
                " Imminent Monitor",
                " KDALogger",
                " Koadic",
                " NanoCore",
                " NetWire",
                " POWERTON",
                " PoshC2",
                " Poylog",
                " PupyRAT",
                " Schoolbag",
                "AutoCore"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "e5ff825b-0456-4013-b90a-971b93def74a",
            "created_at": "2022-10-25T15:50:23.824058Z",
            "updated_at": "2025-03-27T02:00:55.553346Z",
            "deleted_at": null,
            "main_name": "APT33",
            "aliases": [
                "APT33",
                "HOLMIUM",
                "Elfin",
                "Peach Sandstorm"
            ],
            "source_name": "MITRE:APT33",
            "tools": [
                "PowerSploit",
                "AutoIt backdoor",
                "PoshC2",
                "Mimikatz",
                "NanoCore",
                "DEADWOOD",
                "StoneDrill",
                "POWERTON",
                "LaZagne",
                "TURNEDUP",
                "NETWIRE",
                "Pupy",
                "ftp",
                "Shamoon"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535635,
    "ts_updated_at": 1743041717,
    "ts_creation_date": 1653753157,
    "ts_modification_date": 1653753157,
    "files": {
        "pdf": "https://archive.orkl.eu/94246e717b16be52cc510d1c1defb06c90fc9f67.pdf",
        "text": "https://archive.orkl.eu/94246e717b16be52cc510d1c1defb06c90fc9f67.txt",
        "img": "https://archive.orkl.eu/94246e717b16be52cc510d1c1defb06c90fc9f67.jpg"
    }
}