{
    "id": "84752ec0-71ba-4163-8d50-2b5e344c0466",
    "created_at": "2023-01-12T15:09:38.257761Z",
    "updated_at": "2025-03-27T02:16:14.158885Z",
    "deleted_at": null,
    "sha1_hash": "fe208fb7688f7df41fcce23833a0f5656ba43af8",
    "title": "2021-09-30 - All your hashes are belong to us- An overview of malware hashing algorithms",
    "authors": "",
    "file_creation_date": "2022-05-28T02:22:48Z",
    "file_modification_date": "2022-05-28T02:22:48Z",
    "file_size": 948830,
    "plain_text": "# All your hashes are belong to us: An overview of malware hashing algorithms\n\n**[gdatasoftware.com/blog/2021/09/an-overview-of-malware-hashing-algorithms](https://www.gdatasoftware.com/blog/2021/09/an-overview-of-malware-hashing-algorithms)**\n\nVirusTotal's \"Basic Properties\" tab alone lists eight different hashes and supports even more\nto use them for queries and hunt signatures. Hashes are important for malware analysis, as\nwell as identification, description and detection. But why do so many of them exist and when\nshould you use which hash function?\n\n## Cryptographic hashes: MD5, SHA-1, SHA-256\n\nCryptographic hashing algorithms are a mathematical function that produces an\nalphanumeric string that is unique for a specific file or data input, making it an unalterable\nidentifier. Unlike encryption, cryptographic hashing is a one-way function and only works in\none direction. It is designed to be practically infeasible to compute the original input based on\nthe hash value alone. Even changing a single byte in the input will result in a different hash\nvalue. That way an adversary cannot see if their input sample is anywhere close to\nproducing the desired hash value.\n\nAll of these hashes have a fixed length. For the standard implementation of MD5 it is 128 bits\n(16 bytes), for SHA-1 160 bits (20 bytes) and for SHA256 the length is in the name: 256 bits\n(32 bytes).\n\n\n-----\n\nThe main purposes of these hashes are identification and blocklisting of samples. Using\nthem for blocklisting makes sense because an attacker will have difficulty to design a\nmalware with the same hash value as a clean file. They are ideal for identification because\ncryptographically secure hashes are meant to make collisions unlikely.\n\nMD5 and SHA-1 should not be used anymore because they have been broken [fisher20]\n\n[kashyap06]. E.g. for MD5 people can create hash collisions in a way that allows control over\nthe content [kashyap06]. But both are still sometimes used in hash listings of malware\narticles and some detection technologies might still work with MD5 hashes because\ncomputing them is fast and the values don't need much storage space. Therefore it is an\nimportant and common search option for sample databases.\n\n## Fuzzy Hashes: dcfldd, ssdeep, TLSH, mvHash-B\n\nFuzzy hashes are also called Similarity Preserving Hash Functions (SPHF). Unlike\ncryptographic hashes their goal is to provide a comparison or similarity measure. Fuzzy hash\nfunctions are further categorized into four types [p.1, martinez14]:\n\n[Block-Based Hashing (BHB), e.g., the program dcfldd by Harbour creates hash values](http://dcfldd.sourceforge.net/)\nvia BHB\nContext-Triggered Piecewise Hashing (CTPH), of which the most popular example is\nssdeep\nStatistically-Improbable Features (SIF), e.g., sdhash\nBlock-Based Rebuilding (BBR). e.g., mvHash-B\n\n**BHB creates a hash for every fixed-sized block of the input data. The larger the input data,**\nthe longer the resulting hash value will be. A similarity is determined by counting all blocks\nwith the same hash value. BHB is used in forensics (dcfldd is a forensics tool) but not so\nmuch for sample analysis. Maybe because the arbitrary and potentially large size of the hash\nvalue makes it impractical for signatures and storage.\n\n**CTPH uses trigger points instead of fixed-sized blocks. Everytime a specific trigger point hits,**\nthe algorithms calculates a hash value of the current chunk of data. The conditions for the\ntrigger points are chosen in such a way that the final hash value doesn't grow arbitrarily in\nsize with increased input data size. E.g., ssdeep has a desired number of 64 chunks per\ninput file, so the trigger point is dependent on the size of input data. To compare two files,\nssdeep uses an edit distance algorithm: The more steps it takes to transform one ssdeep\nhash value to the other, the less similar the files are.\n\nThe development of ssdeep was a milestone at the time. New hashing algorithms which\nimprove certain aspects of ssdeep have been created since. E.g., SimFD has a better false\npositive rate and MRSH improved security aspects of ssdeep [breitinger13]. The author's\n\n\n-----\n\n[website states that ssdeep is still often preferred due to its speed (e.g., compared to TLSH)](https://ssdeep-project.github.io/ssdeep/index.html)\nand it is the \"de facto standard\" for fuzzy hashing algorithms used for malware samples and\ntheir classification. Sample databases like VirusTotal and Malwarebazaar support it.\n\nTLSH stands for Trend-Micro Locality Sensitive Hash, which was published in a paper in\n2013 [oliver13]. According to their paper TLSH has better accuracy than ssdeep when\nclassifying malware samples [p.12, oliver13]. Just like ssdeep it is a CTPH. TLSH is\nsupported by VirusTotal.\n\nThe idea of SIF hashing is to find features of a file that are unlikely present by chance and\ncompare those features to other files. Sdhash uses entropy calculation to pick the relevant\nfeatures and then creates the hash value based on them. That also means sdhash cannot\nfully cover a file and modifications to a file may not influence the hash value at all if they are\nnot part of a statistically-improbable feature. Sdhash shows better accuracy than ssdeep\nwhen classifying malware samples [p.12, oliver13][roussev11]. However, its strong suit is the\ndetection of fragments and not comparison of files [p.8, breitinger12].\n\n**BBR uses auxiliary data to rebuild a file. mvHash-B for instance maps every byte of the input**\nfile to either 0xFF or 0x00 by comparing it to its neighbors via a majority voting. If most of the\nneighbors are 1, the byte becomes 0xFF, otherwise 0x00. Afterwards the byte sequences are\ncompressed to form a hash value. Other examples are the algorithms discussed in the\nsection Image similarity: aHash, pHash, dHash\n\n## Control Flow Graph hashing: Machoc and Machoke\n\n[Machoc creates a numeric representation of a sample's control flow graph (CFG). Suppose](https://github.com/ANSSI-FR/polichombr/blob/dev/docs/MACHOC_HASH.md)\nyou have a CFG like in the image on the right. The numbered blocks are turned into the\n[following string (example from Github page):](https://github.com/ANSSI-FR/polichombr/blob/dev/docs/MACHOC_HASH.md)\n```\n1:2,3;\n2:;\n3:4,10;\n4:6;\n5:6;\n6:c,7;\n7:c,8;\n8:5,9;\n9:10;\n10:;\n\n```\nMachoc then applies Murmuhash3 to this string to create the final hash value. Therefore,\nsamples with the same control flow graph will have the same hash value.\n\n[Machoke is the same algorithm, but a different implementation. Machoc bases their control](https://github.com/conix-security/machoke)\nflow graphs on IDAPython or miasm, whereas Machoke uses radare2 and r2pipe.\n\n\n-----\n\nThese hashing algorithms are limited to the executable types supported by their\ndisassemblers and are vulnerable to control flow obfuscation.\n\nControl flow graph hashes are not only useful for AV detection and sample clustering. They\nare also suitable to get a binary diff for samples, i.e., to identify similar and different functions\nin two samples. Binary diffing is a common technique for malware analysis to find differences\nbetween two versions of a malware family or identify re-used code in different malware\nfamilies. Control flow hashing may also be applied to automatically rename known functions,\nthus, improve the readability of disassembled code for reversers.\n\n\n-----\n\nMachoc applies block numbering to a control flow\n\ngraph; image from https://github.com/ANSSIFR/polichombr/blob/dev/docs/screenshots/cfg_numbered.png\n\n## Import hashing: ImpHash, TypeRefHash and ImpFuzzy\n\nAll of these hashing algorithms work with imported functions, types or modules. The idea is\nthat the imports indicate behavioral capabilities of a malware, so a hash value will hopefully\nbe the same for samples with similar capabilities.\n\n\n-----\n\n[The ImpHash is used specifically for Portable Executable (PE) files and based on the PE](https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html)\nimport table contents. It concatenates the imported function names and module names, puts\nthem to lowercase, then creates the MD5 value of the resulting string. That MD5 value is the\nImpHash.\n\nExplanation video of Imphash history and algorithm\n\nWindows samples that are based on the .NET framework are also PE files. However, usually\nthey only have one PE import, which is the .NET runtime. So the ImpHash is rather useless\nfor .NET based PE files. Everything that is imported by the user-defined .NET code resides\nin .NET specific metadata tables. The TypeRef table is the .NET counterpart to the PE import\n[table. It contains namespaces and types used by the sample. The TypeRefHash algorithm](https://www.gdatasoftware.com/blog/2020/06/36164-introducing-the-typerefhash-trh)\norders and concatenates TypeNamespaces and TypeNames, then creates the SHA-256\nhash value of the resulting string.\n\nThe choice of using a cryptographic hash as intermediate step for import hashing is not ideal\nwhen keeping in mind that the idea behind ImpHash was to cluster samples of similar\nbehavioral capabilities. Algorithms like ImpHash and TypeRefHash only determine clusters of\nsamples that have exactly the same imports. Fuzzy hash values look similar if the input was\nsimilar. That is is why [algorithms like ImpFuzzy were created, which uses ssdeep instead of](https://blogs.jpcert.or.jp/en/2016/05/classifying-mal-a988.html)\nMD5. A recent study [naik20] shows better results in malware classification tasks for fuzzy\nimport hashing methods that employ ssdeep, sdHash or mvHash-B compared to MD5 for the\nImpHash.\n\nThe [ImpFuzzy blog post evaluates malware family classification for 200 non-packed samples](https://blogs.jpcert.or.jp/en/2016/05/classifying-mal-a988.html)\nusing either ssdeep for the whole file, ImpHash (MD5 on imports) or ImpFuzzy (ssdeep on\nimports). For this specific test setup, ImpFuzzy shows consistently better success rates than\nthe other two hashing algorithms (see image below) but the author also states that this\nsetting creates false positives.\n\n\n-----\n\nMalware classification success rates of ImpFuzzy vs ImpHash vs ssdeep, image from\nhttps://blogs.jpcert.or.jp/en/2016/05/classifying-mal-a988.html\n\n## Human readable hash: Humanhash\n\nThe humanhash has one purpose: It should be rememberable and pronouncable by humans,\nso we can search for these hash values in databases. Example hashes are \"happy-edwardthree-xray\", \"johnny-triple-william-jig\" or \"virginia-quebec-march-london\".\n\nThe hash value is created by converting the input size to 4 bytes, then mapping each byte to\na wordlist. The author states its uniqueness is 1 in 4.3 billion. This hash is not robust against\ncollisions, but it does not have to be.\n\nThe [original author's Github page states humanhash was inspired by Chroma-Hash, which is](https://github.com/zacharyvoase/humanhash)\na colorful representation of hashes, and the NATO phonetic alphabet.\n\nIn my personal opinion more sample sharing platforms should add humanhash to their list of\nhashes. E.g., it would be a great addition to VirusTotal. Malwarebazaar supports humanhash\nand seeing it among the other hash values (image below) makes apparent what this sample\nwill be remembered by apart from the filename and AgentTesla tag.\n\n\n-----\n\nHash listing on Malwarebazaar for the virginia-quebec-march-london sample\n\n## Image similarity: aHash, pHash, dHash\n\nChecking icon similarity is especially useful if malware pretends to be a known application or\noffice document. E.g., it is common for malware to try to appear as Word or PDF document\nby using icons for these applications in combination with double extensions like pdf.exe or\nfile extension spoofing. Detecting such malware techniques with signatures or searching for\nthem in databases is possible with similarity hashes that are specifically for comparing\npictures, e.g., VirusTotal and Malwarebazaar support searches via dHash.\n\n[There are many hashing algorithms for image comparison, e.g., this blog article compares](https://content-blockchain.org/research/testing-different-image-hash-functions/)\nsix of them. But the ones mentioned the most are pHash, aHash and dHash.\n\nAll three hashing algorithms first resize the picture to a fixed size and then convert it into\ngrayscale. At this point aHash aka average hash compares every pixel value to the average\ngrayscale pixel value of the image. If it is greater (= brighter) than the average, it sets the\npixel to 1, otherwise to 0. pHash aka perceptual hash applies a Discrete Cosine Transform\nand compares pixels based on frequencies. dHash aka difference hash compares every\npixel to their right neighbor (except the last one in each row). If the pixel value is increasing,\nit is set to 1; otherwise it is set to 0.\n\nThe consensus according to several articles [animeloop17][hackerfactor13] seems to be that\ndHash is the fastest of the three algorithms and also accurate, but it does not detect\nsimilarity in cropped images. pHash has the best accuracy but also the worst performance.\naHash seems to be the least accurate of the three algorithms.\n\n\n-----\n\nImage hashing algorithms are also used in sample clustering and applied to an image\nvisualization of the malware file itself [bhaskara18].\n\nResult of different image hashing algorithms\n\n## Digital certificates: Authentihash\n\nThis cryptographic hash is computed on signed PE files and an important part of Microsoft's\ndigital signature format Authenticode. Its purpose is to verify that a file has not been\ntampered with after it has been signed by a software publisher. File manipulation would\nresult in a different hash value than the one listed in the file's digital signature. The\nAuthentihash includes the PE image excluding certificate related data and overlay. That\nmeans appended data does not affect the hash value which has been abused by polyglot\nmalware, that is malware that has several file types at once. More details about such\n[malware is in the article \"Code-Signing: How Malware gets a Free Pass\"](https://www.gdatasoftware.com/blog/how-malware-gets-a-free-pass)\n\nAdditionally appended data is sometimes also used to store settings of a file. E.g., as seen in\n[MuddyWater campaign samples, the ScreenConnect clients have a valid certificate, but](https://www.anomali.com/blog/probable-iranian-cyber-actors-static-kitten-conducting-cyberespionage-campaign-targeting-uae-and-kuwait-government-agencies)\npotentially risky settings are in the overlay and do not affect the signature.\n\nFor malware analysts Authentihash is useful to verify digital signers and to find such polyglot\nmalware files or similar singed files with different appended data, e.g., with VirusTotal\nqueries.\n\n\n-----\n\nAppended malicious Java archive to a signed MSI file, resulting in a validly signed malware\nexecutable. Image from https://www.gdatasoftware.com/blog/how-malware-gets-a-free-pass\n\n## Rich PE Header hashes: Rich, RichPV\n\nThe Rich Header is part of Portable Exectuable files since Visual Studio 97 SP3. According\nto a study conducted in 2019 [p. 5, poslusny19], the Rich Header exists in 73.20 percent of\nall native PE files and represents a fingerprint of the development environment. That means\nit is useful for attribution, sample hunting, clustering, and as part of detection signatures.\n\nThe Rich Header hash or short Rich is calculated the following way [p. 8, dubyk19]: Part of\nthe Rich Header is XOR encrypted. The Rich Header algorithm first searches for the\ndecryption key, then decrypts the rich header data between the magic values \"DanS\",\nindicating the beginning of the plain text header, and \"Rich\", indicating the end of the plain\ntext header. Finally the MD5 hash function is applied on the decrypted area. The resulting\nhash value is the Rich Header hash of the sample. The XOR decryption makes sure that the\nsame Rich Header data contents yield the same hash value if the XOR key changes.\n\nOne modification of Rich is called RichPV and excludes the most volatile Rich Header field\nfrom the MD5 input data, the so called pC or Product Count field [p. 8, dubyk19]. \"pC\nmeasures the number of source files referenced by the PE. As a result, the pC field has the\npotential to change across different PEs as the number of source files increase and\ndecrease even if the products and their versions remain constant\" [p. 8, dubyk19]. So\ngenerally, if we want to find samples that were compiled on the same system, from the same\nsource code project, RichPV hash should be more suitable than Rich hash.\n\nVirusTotal displays the Rich hash in the Details tab. RichPV might be a useful addition to\nthat.\n\n\n-----\n\n## References\n\n[animeloop17] \"Animeloop: animation loop recognition\", September 2017\n[https://blog.windisco.com/animeloop-paper-en/](https://blog.windisco.com/animeloop-paper-en/)\n\n[bhaskara18] Vineeth S. Bhaskara and Debanjan Bhattacharyya, \"Emulating malware\nauthors for proactive protectionusing GANs over a distributed image visualization ofdynamic\n[file behavior\", July 2018, https://arxiv.org/pdf/1807.07525.pdf](https://arxiv.org/pdf/1807.07525.pdf)\n\n[breitinger12] F. Breitinger and H. Baier, \"Properties of a similarity preserving hash function\nand their realization in sdhash,\" 2012 Information Security for South Africa, 2012, pp. 1-8,\ndoi: 10.1109/ISSA.2012.6320445.\n\n[breitinger13] Breitinger F., Baier H. (2013) \"Similarity Preserving Hashing: Eligible Properties\nand a New Algorithm MRSH-v2\". In: Rogers M., Seigfried-Spellar K.C. (eds) Digital\nForensics and Cyber Crime. ICDF2C 2012. Lecture Notes of the Institute for Computer\nSciences, Social Informatics and Telecommunications Engineering, vol 114. Springer, Berlin,\n[Heidelberg. doi.org/10.1007/978-3-642-39891-9_11](https://doi.org/10.1007/978-3-642-39891-9_11)\n\n[dubyk19] Dubyk, Maksim. \"Leveraging the PE Rich Header for Static Malware Detection and\nLinking.\" (2019). https://www.giac.org/paper/grem/6321/leveraging-pe-rich-header-staticalware-etection-linking/169729\n\n[fisher20] Dennis Fisher, \"SHA-1 ‘Fully and Practically Broken’ By New Collision\", January\n2020 [https://duo.com/decipher/sha-1-fully-and-practically-broken-by-new-collision](https://duo.com/decipher/sha-1-fully-and-practically-broken-by-new-collision)\n\n[hackerfactor13] Neal Krawetz, \"Kind of Like That\", January 2013,\n[http://www.hackerfactor.com/blog/?/archives/529-Kind-of-Like-That.html](http://www.hackerfactor.com/blog/?/archives/529-Kind-of-Like-That.html)\n\n[kashyap06] Kashyap N. A \"Meaningful MD5 Hash Collision Attack\" [Internet]. 2006.\nAvailable at: http://citeseerx.ist.psu.edu/viewdoc/download?\ndoi=10.1.1.126.2659&amp;rep=rep1&amp;type=pdf\n\n[kim20] Kim, Jun-Seob & Jung, Wookhyun & Kim, Sangwon & Lee, Shinho & Kim, Eui.\n(2020). Evaluation of Image Similarity Algorithms for Malware Fake-Icon Detection. 16381640. 10.1109/ICTC49870.2020.9289501.\n\n[martinez14] Martínez, V., F. Álvarez and L. H. Encinas. “State of the Art in Similarity\nPreserving Hashing Functions.”, 2014,\n[https://digital.csic.es/bitstream/10261/135120/1/Similarity_preserving_Hashing_functions.pdf](https://digital.csic.es/bitstream/10261/135120/1/Similarity_preserving_Hashing_functions.pdf)\n\n[naik20] N. Naik, P. Jenkins, N. Savage, L. Yang, T. Boongoen and N. Iam-On, \"Fuzzy-Import\nHashing: A Malware Analysis Approach,\" 2020 IEEE International Conference on Fuzzy\nSystems (FUZZ-IEEE), 2020, pp. 1-8, doi: 10.1109/FUZZ48607.2020.9177636.\n\n\n-----\n\n[oliver13] Oliver, J., Cheng, C., Chen, Y.: TLSH - A Locality Sensitive Hash. 4th Cybercrime\nand Trustworthy Computing Workshop\", Sydney, November 2013\n[https://github.com/trendmicro/tlsh/blob/master/TLSH_CTC_final.pdf](https://github.com/trendmicro/tlsh/blob/master/TLSH_CTC_final.pdf)\n\n[poslusny19] Poslušný, Michal & Kálnai, Peter. (2019). \"Rich Headers: leveraging this\nmysterious artifact of the PE format for threat hunting.\"\n[https://www.virusbulletin.com/uploads/pdf/magazine/2019/VB2019-Kalnai-Poslusny.pdf](https://www.virusbulletin.com/uploads/pdf/magazine/2019/VB2019-Kalnai-Poslusny.pdf)\n\n[roussev11] Vassil Roussev, \"An evaluation of forensic similarity hashes,\" Digital\nInvestigation, vol. 8, Supplement, no. 0, pp. 34 – 41, 2011.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-30 - All your hashes are belong to us- An overview of malware hashing algorithms.pdf"
    ],
    "report_names": [
        "2021-09-30 - All your hashes are belong to us- An overview of malware hashing algorithms.pdf"
    ],
    "threat_actors": [
        {
            "id": "2ed8d590-defa-4873-b2de-b75c9b30931e",
            "created_at": "2023-01-06T13:46:38.730137Z",
            "updated_at": "2025-03-27T02:00:02.903261Z",
            "deleted_at": null,
            "main_name": "MuddyWater",
            "aliases": [
                "Boggy Serpens",
                "Mango Sandstorm",
                "TEMP.Zagros",
                "Static Kitten",
                "G0069",
                "TA450",
                "Earth Vetala",
                "Seedworm",
                "COBALT ULSTER",
                "ATK51"
            ],
            "source_name": "MISPGALAXY:MuddyWater",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "31e69945-6c1e-40c3-ba8e-a77e81dd142a",
            "created_at": "2024-05-01T02:03:08.047377Z",
            "updated_at": "2025-03-27T02:05:17.326452Z",
            "deleted_at": null,
            "main_name": "COBALT ULSTER",
            "aliases": [
                "ENT-11 ",
                "ITG17 ",
                "MERCURY ",
                "Mango Sandstorm ",
                "MuddyWater ",
                "STAC 1171 ",
                "Seedworm ",
                "Static Kitten ",
                "TEMP.Zagros ",
                "UNC3313 ",
                "Yellow Nix ",
                "Earth Vetala "
            ],
            "source_name": "Secureworks:COBALT ULSTER",
            "tools": [
                " Canopy",
                " CrackMapExec",
                " CredNinja",
                " Empire",
                " FORELORD",
                " Koadic",
                " LaZagne",
                " Ligolo",
                " MKL64",
                " Metasploit",
                " Mimikatz",
                " MiniDump",
                " Mori",
                " MuddyC2Go",
                " MuddyC3",
                " PhonyC2",
                " Plink",
                " PowGoop",
                " PowerStats",
                " RemoteUtilities",
                " Revsocks",
                " ScreenConnect",
                " SimpleHelp",
                " Small Sieve",
                " Syncro",
                " Venom Proxy",
                " WMIExec",
                "AnyDesk"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "02e1c2df-8abd-49b1-91d1-61bc733cf96b",
            "created_at": "2022-10-25T15:50:23.308924Z",
            "updated_at": "2025-03-27T02:00:55.437268Z",
            "deleted_at": null,
            "main_name": "MuddyWater",
            "aliases": [
                "MuddyWater",
                "Earth Vetala",
                "Static Kitten",
                "Seedworm",
                "TEMP.Zagros",
                "Mango Sandstorm",
                "TA450"
            ],
            "source_name": "MITRE:MuddyWater",
            "tools": [
                "STARWHALE",
                "POWERSTATS",
                "Out1",
                "PowerSploit",
                "Small Sieve",
                "Mori",
                "Mimikatz",
                "LaZagne",
                "PowGoop",
                "CrackMapExec",
                "ConnectWise",
                "SHARPSTATS",
                "RemoteUtilities",
                "Koadic"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "3c430d71-ab2b-4588-820a-42dd6cfc39fb",
            "created_at": "2022-10-25T16:07:23.880522Z",
            "updated_at": "2025-03-27T02:02:10.010443Z",
            "deleted_at": null,
            "main_name": "MuddyWater",
            "aliases": [
                "ATK 51",
                "Boggy Serpens",
                "Cobalt Ulster",
                "ITG17",
                "Mango Sandstorm",
                "MuddyWater",
                "Operation BlackWater",
                "Operation Earth Vetala",
                "Operation Quicksand",
                "Seedworm",
                "Static Kitten",
                "T-APT-14",
                "TA450",
                "TEMP.Zagros",
                "Yellow Nix"
            ],
            "source_name": "ETDA:MuddyWater",
            "tools": [
                "Agentemis",
                "BugSleep",
                "CLOUDSTATS",
                "ChromeCookiesView",
                "Cobalt Strike",
                "CobaltStrike",
                "CrackMapExec",
                "DELPHSTATS",
                "EmPyre",
                "EmpireProject",
                "FruityC2",
                "Koadic",
                "LOLBAS",
                "LOLBins",
                "LaZagne",
                "Living off the Land",
                "MZCookiesView",
                "Meterpreter",
                "Mimikatz",
                "MuddyC2Go",
                "MuddyRot",
                "Mudwater",
                "POWERSTATS",
                "PRB-Backdoor",
                "PhonyC2",
                "PowGoop",
                "PowerShell Empire",
                "PowerSploit",
                "Powermud",
                "QUADAGENT",
                "SHARPSTATS",
                "SSF",
                "Secure Socket Funneling",
                "Shootback",
                "Smbmap",
                "Valyria",
                "chrome-passwords",
                "cobeacon",
                "prb_backdoor"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536178,
    "ts_updated_at": 1743041774,
    "ts_creation_date": 1653704568,
    "ts_modification_date": 1653704568,
    "files": {
        "pdf": "https://archive.orkl.eu/fe208fb7688f7df41fcce23833a0f5656ba43af8.pdf",
        "text": "https://archive.orkl.eu/fe208fb7688f7df41fcce23833a0f5656ba43af8.txt",
        "img": "https://archive.orkl.eu/fe208fb7688f7df41fcce23833a0f5656ba43af8.jpg"
    }
}