{
    "id": "073fab48-b00f-4d95-bdd4-b7af79758bd2",
    "created_at": "2023-01-12T15:05:19.982818Z",
    "updated_at": "2025-03-27T02:05:25.117018Z",
    "deleted_at": null,
    "sha1_hash": "6ce0a6016b8e1deb54e0effcc5236c6026ead681",
    "title": "2020-09-11 - [RE016] Malware Analysis- ModiLoader",
    "authors": "",
    "file_creation_date": "2022-05-28T15:23:32Z",
    "file_modification_date": "2022-05-28T15:23:32Z",
    "file_size": 2216265,
    "plain_text": "# [RE016] Malware Analysis: ModiLoader\n\n**[blog.vincss.net/2020/09/re016-malware-analysis-modiloader-eng.html](https://blog.vincss.net/2020/09/re016-malware-analysis-modiloader-eng.html)**\n\n**1. Introduction**\n\nRecently, I have been investigating a malware loader which is ModiLoader. This loader is\ndelivered through the Malspam services to lure end users to execute malicious code. Similar\nto other loaders, ModiLoader also has multi stages to download the final payload which is\nresponsible for stealing the victim's information. After digged into some samples, I realized\nthat this loader is quite simple and didn't apply anti-analysis techniques like Anti-Debug,\n**[Anti-VM that we have seen in GuLoader/CloudEyE samples (1;2). Instead, for avoiding](https://blog.vincss.net/2020/03/re011-unpack-crypter-cua-malware-netwire-bang-x64dbg.html)**\nantivirus detection, this loader uses digital signatures, decrypts payloads, Url, the inject code\nfunction at runtime and executes the payload directly from memory.\n\nCurrently, according to my observation, there are not many analysis documents about this\nloader in the world as well as in Vietnam. So, in this post, I will cover techniques are used by\n[this loader as well as apply new released tool from FireEye is capa that helps to quickly find](https://www.fireeye.com/blog/threat-research/2020/07/capa-automatically-identify-malware-capabilities.html)\nthe loader's main code. During the analysis, I also try to simulate the malicious code in\npython script for automatic extracting and decoding payload, Url.\n\n## 2. About the sample\n\n**SHA256:** [9d71c01a2e63e041ca58886eba792d3fc0c0064198d225f2f0e2e70c6222365c](https://bazaar.abuse.ch/sample/9d71c01a2e63e041ca58886eba792d3fc0c0064198d225f2f0e2e70c6222365c/)\n\n\n-----\n\nResults from PE Scanner tools show that this loader is written in Delphi, using Digital\n**Signatures to bypass the AV programs running on the client:**\n\n## 3. Technical analysis\n\n**3.1. First stage analysis**\n\nAt the first stage, the loader (considered as the first payload) performs the task of extracting\ndata, decoding the second payload (this payload can be dll or exe), and executing the\npayload from memory.\n\nBy using IDA, at the end of the automated analysis, IDA has identified up to 5,385 functions:\n\n\n-----\n\nCode block at start() function of loader:\n\nAlthough, much more functions were identified as above, most of them are Windows APIs as\nwell as Delphi’s library functions, so that finding out the main code related to decoding the\n[second payload will take a long time. With the help of capa, I quickly found the code related](https://www.fireeye.com/blog/threat-research/2020/07/capa-automatically-identify-malware-capabilities.html)\nto executing the second payload and then traced back to the code that responsible for\ndecoding this payload.\n\n\n-----\n\nThe entire code at sub_498CDC() function is responsible for parsing the payload, mapping\ninto the memory and executing it. Code in this function before and after applying the relevant\nstruct:\n\nTrace back will reach sub_4994EC(), this function performs tasks:\n\nReads all data from the resource named \"T__7412N15D\" into memory.\n\nFinds \"OPPO\" string in resource binary data to retrieve the encrypted payload.\n\n\n-----\n\nPerforms decoding to get the second payload. The key used in decoding process is a\nnumeric value.\nSearches string in the second payload and replace it with the encoded URL string.\n\nIn the picture above, the decryption key is an integer converted from the string. In this\nsample, key value is 0x30\n\n. The code is responsible for decoding the payload as shown below:\n\n\n-----\n\nAn implementation of this decoding operation can be written in Python as the below image:\n\nOnce the payload has been decoded, the loader will search for the placeholder in the\ndecoded payload and replace the 168 “z” characters with the encoded URL string. Finally,\nonce the payload is ready for execution, it calls sub_498CDC() for executing the payload.\n\nAnd from beginning until now, the above entire technical analysis can be done with a python\nscript to obtain the second payload.\n\n\n-----\n\n**3.2. Second stage analysis**\n\nCheck the payload retrieved in the above step, it is also written in Delphi:\n\nWith the similar method, I found sub_45BE08() which is responsible for allocating the region\nof memory, map the final payload after decoded into this region, and then execute it.\n\nBy tracing back, I found the code that starts at TForm1_Timer1Timer (recognized by IDA by\n_signature) at the address is 0x45CC10. Before calling f_main_loader() at address is_\n**0x45C26C, the code from here is responsible for decoding Url and checking the Internet**\nconnection by trying to connect to the decoded Url is https://www.microsoft.com.\n\nDecoding algorithm at f_decode_char_and_concat_str() function is as simple as follows:\n**dec_char = (enc_char >> 4) | (0x10 * enc_char);**\n\nAt f_main_loader(), it also uses the same above function to decode and get the string is\n**\"Yes\". This string is later used as xor_Key for decoding the Url to download the last payload**\n(The encrypted Url is the string in the replacement step that was described above) as well as\ndecoding the downloaded payload. f_decode_url_and_payload(void *enc_buf, LPSTR\n**szKey, void *dec_buf) function takes three parameters:**\n\nThe first parameter is enc_buf, used for store the encoded data.\nThe second parameter is szKey. It is the \"Yes\" string used to decode the data.\n\n\n-----\n\nThe third parameter is dec_buf, used for store the decoded data.\n\nDiving into this decoding function, you will realize that it will loop through all data, each\niteration takes 2 bytes, convert the string to an integer, then xor with the character extracted\nfrom the decryption key. Once decrypted, the byte is then concatenated to the third\nargument, which is the output buffer.\n\nThis entire decoding function is rewritten in python as follows:\n\nBack to the f_main_loader(), first it will decode the Url for retrieving the last payload:\n\nPerform decoding using the python code above, I obtain the Url as below image:\n\n\n-----\n\nNext, it uses the WinHTTP WinHttpRequest COM object for downloading the encrypted\npayload from the above Url. Instead of using Internet APIs functions from Wininet library as\nin some other samples, the change to using COM object might be aimed at avoiding\ndetection by AV programs.\n\nHere, I use wget to download the payload. The payload’s content is stored in hex strings\nsimilar to the encoded above Url.\n\nPayload data will be reversed and decoded by the same f_decode_url_and_payload\nfunction with the same decoding key is \"Yes\". Once decrypted, the sample will allocate a\nregion of memory, map the payload into that region, and then execute it.\n\nAlong with the python code above, I can decode the downloaded payload and obtain the final\npayload. This payload is a dll file and also written in Delphi:\n\n\n-----\n\n**3.3. Third stage analysis**\n\nThe above payload is quite complicated, it performs the following tasks:\n\nReads data from a resource named \"DVCLAL\" into memory.\nDecrypts this resource, then based on the “*()%@5YT!@#G__T@#$%^&*\n**()__#@$#57$#!@” pattern to read the decrypted data into the corresponding variables.**\nRetrieves the user’s directory information through the %USERPROFILE% environment\nvariable and set up the path to %USERPROFILE%\\AppData\\Local folder.\nCreates Vwnt.url and Vwntnet.exe (copy of loader) files in\n**%USERPROFILE%\\AppData\\Local folder if that files not exist, then set the value is**\n“Vwnt” that pointing to the %USERPROFILE%\\AppData\\Local\\Vwnt.url file at\n“HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run” key. Then write data to\n**Vwnt.url with content that points to Vwntnet.exe file:**\n\nCombines the decrypted data from the above resource for decrypting the new payload.\n\n\n-----\n\nDecrypts the function is responsible for injecting code. Check \"C:\\Program Files\n**(x86)\\internet explorer\\ieinstal.exe\" exists or not, if exists it will inject payload into**\n**ieinstal.exe.**\n\nBased on the strings was dumped from the decrypted payload, I can confirm that it\nbelongs to the Warzone RAT, a well-known RAT that is being offered online and\npromoted on various hacking forums.\n\n\n-----\n\n## 4. References\n\n[Xem bài phiên bản tiếng Việt](https://blog.vincss.net/2020/09/re016-malware-analysis-modiloader-vie.html)\n\n**Tran Trung Kien (aka m4n0w4r)**\n\n**Malware Analysis Expert**\n\n**R&D Center - VinCSS (a member of Vingroup)**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-09-11 - [RE016] Malware Analysis- ModiLoader.pdf"
    ],
    "report_names": [
        "2020-09-11 - [RE016] Malware Analysis- ModiLoader.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535919,
    "ts_updated_at": 1743041125,
    "ts_creation_date": 1653751412,
    "ts_modification_date": 1653751412,
    "files": {
        "pdf": "https://archive.orkl.eu/6ce0a6016b8e1deb54e0effcc5236c6026ead681.pdf",
        "text": "https://archive.orkl.eu/6ce0a6016b8e1deb54e0effcc5236c6026ead681.txt",
        "img": "https://archive.orkl.eu/6ce0a6016b8e1deb54e0effcc5236c6026ead681.jpg"
    }
}