{
    "id": "dbbd238d-94d9-4282-911a-c433d0f97b70",
    "created_at": "2023-01-12T15:04:50.382856Z",
    "updated_at": "2025-03-27T02:05:35.910975Z",
    "deleted_at": null,
    "sha1_hash": "33624a53c7860de9424f141d76a59bb1ba421df0",
    "title": "2022-10-17 - Stack String Decryption with Ghidra Emulator (Orchard)",
    "authors": "",
    "file_creation_date": "2022-10-23T13:31:47Z",
    "file_modification_date": "2022-10-23T13:31:47Z",
    "file_size": 709809,
    "plain_text": "# Stack String Decrypt con Ghidra Emulator (Orchard)\n\n**[malverse.it/stack-string-decryptor-con-ghidra-emulator-orchard](https://malverse.it/stack-string-decryptor-con-ghidra-emulator-orchard)**\n\n## Introduzione\n\n### Ciao a tutti! Oggi vedremo come realizzare uno script sfruttando le API di Ghidra per decifrare le stringhe di Orchard. In particolare analizzeremo il sample V3 (MD5: cb442cbff066dfef2e3ff0c56610148f) sviluppato in C++. Questo malware sfrutta inoltre unâ€™interessante tecnica DGA il cui seed non Ã¨ deterministico e dipende dal balance del genesis block; lâ€™analisi tecnica di questo aspetto si puÃ² trovare sui blog bin.re e 360 Netlab.\n\n Orchard per la decryption delle stringhe memorizza nello stack lâ€™offset del carattere allâ€™interno dellâ€™alfabeto; vedremo quindi come Ã¨ possibile realizzare un semplice script che sfrutta lâ€™EmulatorHelper di Ghidra per la decifratura.\n\n Iniziamo!\n\n## Analisi\n\n### Il malware inserisce nello stack gli offset dellâ€™alfabeto e viene costruito ottenendo degli int da variabili globali e valori immediati; successivamente vengono chiamate due funzioni, la prima che si occupa di creare un oggetto e la seconda di fare la decryption della stringa.\n\n La tecnica utilizzata dal malware Ã¨ molto semplice, tuttavia Ã¨ possibile complicare maggiormente lâ€™analisi facendo sÃ¬ che i valori nello stack dipendando dal risultato di funzioni, come ad esempio spiegato qui; in questo caso non potremmo escludere dallâ€™esecuzione tutte le chiamate a funzione come fatto successivamente per Orchard, in quanto non ci permetterebbe di ottenere il valore corretto della stringa.\n\n\n-----\n\n### Costruzione dello stack inserendo gli offset e chiamata delle due funzioni\n\n\n-----\n\n### Variabili globali\n\n che contengono gli offset Interessante notare come floss non riesca a decifrare questo tipo di stringhe:\n\n\n-----\n\n### Risultato di floss Per lâ€™emulation successiva ci interessa come vengono utilizzati i registri e in particolare per la prima funzione:\n\n EDX: puntatore al primo offset allâ€™interno dello stack. EAX: contiene il valore che sottratto allâ€™indirizzo del primo offset e diviso per 4 permette di ottenere la lunghezza della stringa. ECX: puntatore this.\n\n Ad esempio in questo caso EDX punta a 0x19F8E4 e quindi 33,39,33,34,25,2D,24,32,29,36,25 che equivale alla stringa SYSTEMDRIVE. In EAX invece abbiamo 0x19F910, quindi (0x19F910 â€“ 0x19F8E4)/ 4 = 11 che Ã¨ il numero di offset presenti.\n\n\n-----\n\n### Utilizzo dei registri EAX, EDX e ECX La prima funzione si occupa di creare lâ€™oggetto allocando una nuova area di memoria e copiando gli offset dallo stack.\n\n\n-----\n\n### Creazione di un nuovo oggetto La seconda funzione invece si occupa di decifrare la stringa, ottenendo gli offset che servono come indici per lâ€™alfabeto:\n\n\n-----\n\n### Funzione di decifratura\n\n Alfabeto utilizzato per la decryption\n\n## Emulation con Ghidra\n\n### Per effettuare Emulation ci sono diverse soluzioni come Unicorn, Flare-Emu, Qiling e Dumpulator. In questo caso utilizzeremo le API di Ghidra attraveso la classe EmulatorHelper . Per approfondire lâ€™argomento: QUI, QUI e QUI.\n\n In particolare, i passaggi effettuati per lâ€™emulazione sono:\n\n\n-----\n\n### Ottenere tutte le chiamate alla funzione di Decryption\n Ottenibile facilmente con le API Ghidra getReferencesTo e getFromAddress Determinare quale istruzioni devono essere emulate\n Funzione getStartAndEndAddress Una stessa funzione puÃ² contenere piÃ¹ chiamate alla funzione di Decryption, quindi lâ€™inizio dellâ€™emulation Ã¨ il prologo della funzione chiamante oppure lâ€™indirizzo dellâ€™istruzione successiva a una precedente chiamata di Decryption Emulare solamente le istruzioni che ci interessano\n Escludere chiamate che possono modificare il flusso (call, jmp, ecc) Lâ€™API Ghidra getFlowType permette di ottenere il FlowType dellâ€™istruzione Leggere lâ€™output dopo lâ€™emulation\n Indirizzo contenuto in EDX permette di ottenere il primo valore dellâ€™offset nello stack (Valore contenuto in EAX â€“ valore contento in EDX) / 4 = size delle stringa Le API Ghidra readRegister e readMemory permettono di leggere i valori memorizzati nei registri e nel range di memoria specificato\n\n Il codice per effettuare lâ€™emulation:\n\n\n-----\n\n```\nfrom ghidra.app.emulator import EmulatorHelper\n\nfrom ghidra.program.model.symbol import SymbolUtilities\n\ndef decrypt(data):\n\n  alphabet = \"!\\\"#$%&'()*+,-./0123456789:;<=>?\n@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyzw\"\n\n  decrypted = \"\"\n\n  for b in data:\n\n    if(b != 0): \n\n      decrypted += alphabet[b-1]\n\n  return decrypted\n\n\nclass Emulator(object):\n\n  def __init__(self):\n\n    self.emulator = EmulatorHelper(currentProgram)\n\n  def run(self):\n\n    references = getReferencesTo(toAddr(\"DecryptStackStrings\"))\n\n    decryptOk = 0\n\n    numCall = len(references)\n\n    # Ottengo l'indirizzo delle chiamate alla funzione di Decryption\n\n    for ref in references:\n\n      callAddr = ref.getFromAddress()\n\n      # Ottengo l'indirizzo di partenza e finale per l'emulation\n\n      start, end = self.getStartAndEndAddress(callAddr)\n\n      print(\"--------------------------------------------------------------\")\n\n      print(\"Start: \" + start.toString() )\n\n      print(\"End: \" + end.toString() )\n\n      print(\"--------------------------------------------------------------\")\n\n      # Imposto i registri e avvio l'emulation con gli indirizzi\nprecedentemente trovati\n\n      self.setupRegister(start)\n\n      self.runEmulation(start, end)\n\n      # Ottengo i valori dei registri EBP, EDX, EAX per calcolare la size e\nl'indirizzo di partenza degli offset\n\n      valueEBP = self.emulator.readRegister(\"EBP\")\n\n      valueEDX = self.emulator.readRegister(\"EDX\")\n\n      valueEAX = self.emulator.readRegister(\"EAX\")\n\n\n```\n\n-----\n\n```\n      # Calcolo la dimensione della stringa\n\n      size = valueEAX - valueEDX\n\n      addr = toAddr(self.emulator.readRegister(\"EDX\"))\n\n      code = bytes(self.emulator.readMemory(addr, size))\n\n      decryptedString = decrypt(code)\n\n      if(len(decryptedString) != 0):\n\n        #hexdump.hexdump(code)\n\n        #print(\"{%s} Decrypted: %s \" % (callAddr, decryptedString) )\n\n        print(\"{%s} - %s \" % (callAddr, decryptedString) )\n\n        decryptOk += 1\n\n        # Imposto il commento su Ghidra\n\n        codeUnit = currentProgram.getListing().getCodeUnitAt(callAddr)\n\n        codeUnit.setComment(codeUnit.PLATE_COMMENT, decryptedString)\n\n\n    print(\"Decryption done:\" + str(decryptOk))\n\n    print(\"Call number: \" + str(numCall))\n\n    self.emulator.dispose()\n\n  def setEIPNextInstruction(self):\n\n    nextInstr = getInstructionAt(self.emulator.getExecutionAddress()).getNext()\n\n    self.emulator.writeRegister(self.emulator.getPCRegister(),\nnextInstr.getAddress().getOffset())\n\n    return nextInstr\n\n  # Funzione che permette di ottenere l'indirizzo di partenza e termine\ndell'emulation   \n\n  def getStartAndEndAddress(self, fromAddr):\n\n    # Ottengo il prologo della funzione attuale\n\n    functionAddr = getFunctionContaining(fromAddr).getEntryPoint()\n\n    while True:\n\n      instr = getInstructionBefore(fromAddr)\n\n      addr = instr.getAddress()\n\n      mnemonic = instr.getMnemonicString().lower()\n\n      if(len(instr.getOpObjects(0)) > 0): \n\n        op1 = instr.getOpObjects(0)[0]\n\n```\n\n-----\n\n```\n        op1_str op1.toString().lower()\n\n        op2 = instr.getOpObjects(0)[1]\n\n        op2_str = op2.toString().lower()\n\n      # Chiamata funzione CreateObject, indirizzo dove l'emulation deve\nterminare\n\n      if mnemonic == \"call\" and op1_str == \"00703390\":\n\n        end = addr\n\n      # Se siamo arrivati al prologo oppure a un'altra chiamata di decryption,\nquello Ã¨ l'indirizzo di partenza dell'emulation\n\n      if functionAddr == addr or (mnemonic == \"call\" and op1_str ==\n\"0070af90\"):\n\n        return addr, end\n\n      fromAddr = instr.getAddress()\n\n  def setupRegister(self, start):\n\n    emulator = self.emulator\n\n    # Ottengo la memoria per lo stack e inizializzo ESP e EBP\n\n    stack_address = (start.getAddressSpace().getMaxAddress().getOffset() >> 1) 0x7fff\n\n    emulator.writeRegister(\"ESP\", stack_address)\n\n    emulator.writeRegister(\"EBP\", stack_address)\n\n    emulator.writeRegister(emulator.getPCRegister(), start.getOffset())\n\n\n  def runEmulation(self, start, end):\n\n    emulationDone = False\n\n    while not monitor.isCancelled():\n\n      executionAddr = self.emulator.getExecutionAddress() \n\n      currentInstruction = getInstructionAt(executionAddr)\n\n\n      # Eseguo solamente istruzioni di tipo FALL_THROUGH escludendo quelle che\npossono modificare il flusso (call, jmp, ja, ecc)\n\n      op = str(currentInstruction).lower() \n\n      flowType = currentInstruction.getFlowType().toString()\n\n      prefixes = [\"lock\"]\n\n      while(flowType != \"FALL_THROUGH\" or op in prefixes):\n\n```\n\n-----\n\n```\n        newInstruction self.setEIPNextInstruction() \n\n        flowType = newInstruction.getFlowType().toString()\n\n        op = newInstruction.toString()\n\n      if self.emulator.step(monitor) == False:\n\n        raise Exception(\"Emulation Error:\n'{}'\".format(self.emulator.getLastError()))\n\n\n      if (executionAddr == end):\n\n        emulationDone = True\n\n        break \n\n    if not emulationDone:\n\n      raise Exception(\"[EMULATION] Error Emulation! \")\n\n    print(\"[EMULATION] Done!\")\n\n\nif __name__==\"__main__\":\n\n  print(\" [EMULATION] Starting.. \")\n\n  Emulator().run()\n\n### Il risultato della decryption:\n\n```\n\n-----\n\n```\n{0072087c} Message\n\n{00720957} - Problem_Type\n\n{00720a34} - Message_Type\n\n{0071e62c} - .exe\n\n{0071c81e} - SYSTEMDRIVE\n\n{0071c8b2} - C:\\\n\n{0071cae8} - %08lX\n\n{0071d047} - psapi.dll\n\n{0071d176} - GetModuleFileNameExW\n\n{00720546} - Serial_Number\n\n{00720620} - Message_Type\n\n{0070c08d} - kernel32.dll\n\n{0070c18b} - Wow64DisableWow64FsRedirection\n\n{0070c263} - Wow64RevertWow64FsRedirection\n\n{0071d977} - nvcuda.dll\n\n{0071da4e} - cuDriverGetVersion\n\n{0071ed62} - Identity\n\n{0071eeb5} - Operating_System\n\n{0071f046} - System_Architecture\n\n{0071f19b} - Elevated\n\n{0071f292} - Threads\n\n{0071f3b1} - Camera\n\n{0071f49e} - Antivirus\n\n{0071f5b5} - Version\n\n{0071f72f} - Active_Window\n\n{0071f864} - CPU_Model\n\n{0071f9a1} - GPU_Models\n\n{0071fa8a} - Ram_Size\n\n{0071fb91} - Authenticate_Type\n\n{0071a8a9} - ntdll.dll\n\n{0071a9c9} - RtlGetVersion\n\n{0071a02d} - MajorVersion\n\n{0071a108} - MinorVersion\n\n{0071a1e7} - BuildNumber\n\n{0071a2e0} - ProductType\n\n{0071abf7} - ROOT\\SecurityCenter2\n\n{0071ae48} - SELECTdisplayNameFROMAntiVirusProduct\n\n{0071aee8} - WQL\n\n{0071b1d4} - displayName\n\n{0070b3de} - Name\n\n{0070b4a2} - Type\n\n{00718915} - nvapi.dll\n\n{007189e1} - nvapi_QueryInterface\n\n{0071902e} - OpenCL.dll\n\n{007190ec} - clGetPlatformIDs\n\n{007191ac} - clGetDeviceIDs\n\n{00719278} - clGetDeviceInfo\n\n{00721710} - %04d-%02d-%02d\n\n{00721762} - .duckdns.org\n\n{0072178c} - .com\n\n{007217b6} - .net\n\n{007217e0} - .org\n\n```\n\n-----\n\n```\n{0072193d} https://blockchain.info/balance?\nactive=1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa\n\n{00722452} - CPU_Status\n\n{00722538} - GPU_Status\n\n{0072260b} - CPU_Hashrate\n\n{007226e8} - GPU_Hashrate\n\n{007227b2} - GPU_Type\n\n{007228ac} - GPU_Algorithm\n\n{0072297f} - Message_Type\n\n{007195b1} - Host\n\n{00719670} - Port\n\n{00719741} - File_Name\n\n{0071980e} - Handle\n\n{00722ce8} - Domain\n\n{00722dad} - Port\n\n{00722e8b} - Process_ID\n\n{00722f66} - Process_Name\n\n{00723041} - Process_Path\n\n{0072311f} - Is_Patched\n\n{007231f6} - In_Memory\n\n{007232d4} - Patch_Name\n\n{007233b2} - Install_Path\n\n{0072349a} - System_Idle\n\n{00723581} - System_Uptime\n\n{00723674} - Power_SaverMode\n\n{00723751} - Message_Type\n\n{00702716} - Required_Binary\n\n{007027ea} - Cuda_Version\n\n{0070c879} - *.exe\n\n{0072393e} - Buffer\n\n{007239cd} - Execute_Name\n\n{00723a62} - Binary_Source\n\n{00723af6} - Execute_Type\n\n{00723cd6} - Execute_Name\n\n{00723dbf} - Execute_Result\n\n{00723ec0} - Execute_Result_Type\n\n{00723f9d} - Message_Type\n\n{00724146} - Option\n\n{007241e8} - Message_Option\n\n{007242d8} - Type\n\n{00724373} - Transfer_Port\n\n{00724401} - Message_Type\n\n{00724539} - Buffer\n\n{007245c0} - Handle\n\n{0072465d} - Message_Option\n\n```\n\n-----\n\n### Grazie per lâ€™ascolto! Per qualunque commento e migliorie (sicuramente ce ne sono tante ðŸ™‚ ) fatemi sapere nei commenti!! A presto ðŸ˜€\n\n Share this content:\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-10-17 - Stack String Decryption with Ghidra Emulator (Orchard).pdf"
    ],
    "report_names": [
        "2022-10-17 - Stack String Decryption with Ghidra Emulator (Orchard).pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535890,
    "ts_updated_at": 1743041135,
    "ts_creation_date": 1666531907,
    "ts_modification_date": 1666531907,
    "files": {
        "pdf": "https://archive.orkl.eu/33624a53c7860de9424f141d76a59bb1ba421df0.pdf",
        "text": "https://archive.orkl.eu/33624a53c7860de9424f141d76a59bb1ba421df0.txt",
        "img": "https://archive.orkl.eu/33624a53c7860de9424f141d76a59bb1ba421df0.jpg"
    }
}