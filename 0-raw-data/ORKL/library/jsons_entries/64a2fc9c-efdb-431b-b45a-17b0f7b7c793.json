{
    "id": "64a2fc9c-efdb-431b-b45a-17b0f7b7c793",
    "created_at": "2023-01-12T15:09:26.86083Z",
    "updated_at": "2025-03-27T02:05:50.617762Z",
    "deleted_at": null,
    "sha1_hash": "8ceaac7ae0ce025b6be6c11669b9a3fdb3a95a38",
    "title": "2016-08 - Analysis of a packed Pony downloader",
    "authors": "",
    "file_creation_date": "2022-05-29T01:27:43Z",
    "file_modification_date": "2022-05-29T01:27:43Z",
    "file_size": 1828313,
    "plain_text": "# analysis of a packed pony downloader\n\n**uperesia.com/analysis-of-a-packed-pony-downloader**\n\n\n-----\n\nPosted by Felix Weyne, August 2016.\n\nAuthor contact: [Twitter |](https://www.uperesia.com/referer.php?id=twitter) LinkedIn\nTags: pony, dropper, password stealer, reverse engineering, malware, packers, process\nhollowing, .NET reflection\n\n[This Spring I attended the SANS reverse-engineering malware course. I strongly recommend](https://www.sans.org/course/reverse-engineering-malware-malware-analysis-tools-techniques)\nthis course to anyone who is active in IT security. The course not only teaches you how to\ndissect malware, it also gives you a good insight on how malware is spread and a better\nunderstanding on the techniques malware authors use to bypass defense systems. Whether\nyou work in a security operations center or whether you are responsible for designing and\nimplementing an IT security strategy, sooner or later you will be confronted by the challenges\nthat advanced malware pose. In this blog, I will discuss a few of those challenges by\nanalyzing a real malware sample. During the analysis, I will discuss three challenges that the\nmalware sample poses: the capability (and threat) of the malware, the tricks that the malware\nuses to hide itself and the defence mechanism embedded in the malware to slow\ndown/sabbotage analysis.\n\nThe sample I'll be using in this blog belongs to the Pony password stealer/downloader\n**malware family. The main function of the malware is to drop (download) other malware and**\nto steal passwords (e.g. mail/FTP credentials, stored passwords in browser, ...) and virtual\ncurrencies (e.g. bitcoin). The sample is double packed in order to thwart antivirus and other\ndefense systems. A packed malware sample can be compared to matryoshka dolls: the\n**smallest doll (the actual malware) is nested in other dolls (the packers) and if you only**\n**inspect the outer layer (the packed sample), you will not see the smallest, innermost**\n**doll (in our case: the Pony malware). Only when you open the dolls (dissect the packed**\nmalware), you realize that nothing is what it seems.\n\n\n-----\n\nImage 1: Graphical representation of packed Pony malware\n\nThere is a known saying about (packed) malware: malware can hide but it must run. This\nmeans that the innermost doll (the Pony malware) may hide itself by surrounding itself by\nother dolls (packers), but if it wants to be of use (execute), it must reveal itself: it needs to\nunpack itself. There are two methods to unpack packed malware. Both methods can be\ncompared to the security controls in the power plant of Springfield (yes, this is a Simpsons\nreference ). You can either pass each security control (i.e.: statically inspect and simulate\nthe code that is responsible for unpacking the malware), or if you're lucky you can find and\nuse a backdoor that allows you to bypass all the security features (i.e. running the packed\nmalware, let it unpack itself and dump it from memory) .\n\nStage one dropper\n\n[The sample I'll be analyzing can be found here (password=infected). This Pony sample is](https://www.uperesia.com/resources/packed_pony.zip)\nprotected by two packers. The sample (to which I will refer as stage 1 dropper) unpacks itself\nin memory, this results into another packed sample (to which I will refer as stage 2 dropper).\nThe second packed sample uses resources from the first packed sample to finally create the\nPony malware (to which I will refer as the stage 3 payload). The stage one sample is a .NET\nbinary, so we can inspect the sample in a .NET disassembler such as ILSpy. Looking at the\nsample, we immediately notice a few strange things. The code contains a lot of strange\nsymbols (that represent class and function names) and does not call any API functions that\nyou would expect to see in a normal program. The .NET binary also contains an image with\nseemingly random pixels, called \"jucausa\".\n\n\n-----\n\nImage 2: Inspecting the stage one dropper in ILSpy. Notice the strange samples and the\nresource image.\n\nThese findings indicate that the sample is a packer. Further analysis will show that the\n**malware (stage 3 payload) hides itself inside the image, so when an antivirus statically**\n**examines the stage one dropper, it will only see the unpacking code, not the**\n**embedded Pony malware. Packing malware is a well known used 'trick' by malware authors**\nto evade antivirus signatures. This technique helps malware authors to transform a malware\nsample which is recognized by tons of antiviruses into a malware sample for which there is\nnot yet a detection signature. In the next analysis step, we will run the stage one dropper in a\nsandbox environment. We'll let the dropper unpack its payload (the stage two dropper) in\nmemory. Once the payload is unpacked in memory, we will dump it from the memory so we\ncan further inspect the stage two dropper.\n\nStage two dropper\n\nWhen we run the stage one dropper in a sandbox environment, we see that the sample\ncreates a child process, in which it unpacks itself. Shortly after creating the childproces, the\nchildproces is terminated and a new process 'RegAsm' is started. RegAsm is a legitimate\nprocess in which the stage three payload (the Pony malware) is injected. In this paragraph\nwe will focus on dumping and analyzing the dropper residing in the child process (second\nstage dropper). In the next paragraph we will focus on dumping the Pony malware (third\nstage payload) that is injected in RegAsm.\n\n\n-----\n\nIn order to dump the second stage process, we need to suspend it before it terminates itself.\nI'm using Process Hacker and my ninja reflexes to quickly suspend the childproces . By\nsuspending the child process, the unpacking routines are also frozen, so I have all the time\nin the world to figure out how to dump the unpacked malware. Because the first stage\ndropper was a .NET binary, I made the assumption that the second stage dropper may also\nbe a .NET binary. With the help of MegaDumper I tried to dump the contents of the\nchildproces. This approach worked, dumping the contents resulted in a few executables and\nDLL's.\n\nImage 3: dumping the second stage dropper from memory.\n\nWhen we open the dumped 'mydllclass.dll' in ILSpy, we can spot some interesting code. The\n**codes purpose is to slow down/sabbotage analysis by checking if the sample is**\n**running in a sandbox environment. It checks for environments like Vmware or**\n**Sandboxie.**\n\n\n-----\n\nImage 4: second stage dropper contains analysis environment detection code\n\nWhen we dive a bit further into the code, we can spot a routine that loads the \"jucausa\"\nresource. We can also spot a routine that decrypts and decompresses this resource. Finally,\nwe can also spot a routine that uses a process hollowing technique. If you don't know what\n[process hollowing is, you can read about it in this blog.](https://www.uperesia.com/a-closer-look-to-fileless-click-fraud-malware-poweliks)\n\nImage 5: second stage dropper decrypts payload and injects it using a process hollowing\ntechnique\n\nThese pieces of code really illustrate well the capabilities of the malware: The image in the\n**first stage dropper is used by the second stage dropper. The second stage dropper**\n**extracts the payload from the image, and injects it into RegAsm using a process**\n\n\n-----\n\n**hollowing technique. In the following paragraph, we will extract that payload.**\n\nStage two payload (alternative method)\n\nThe previous paragraph explained how to extract the stage two dropper by dumping it from\nmemory. This paragraph is a brief intermezzo which shows an alternative method to dump\nthe second stage dropper. Packers written in .NET often load their payload by making\n**use of a .NET functionality called 'Reflection'. This functionality enables a programmer to**\nload objects (e.g. executables) directly into memory, without writing it to disk first. With the\nhelp of a .NET debugger, such as dnSpy, one can also easily dump the second stage\ndropper. The easiest approach that worked on this packed Pony sample was searching for\nreferences to 'Assembly.Load' (a functionality in the Reflection class). When setting a\ndebugger breakpoint on that line of code, it is very easy to run the executable and to dump\n(save) the argument passed to the 'Assembly.load' function, as shown on image six. This\nargument is the executable that is loaded into memory.\n\nImage 6: using .NET debugger dnSpy to dump the second stage payload\n\nStage three payload\n\n\n-----\n\nThe stage three payload that s injected in RegAsm, cannot be dumped with MegaDumper\nbecause the executable isn't a .NET executable. However, we can dump the executable\nusing a debugger like OllyDbg. We use Process Hacker to suspend the RegAsm process\n(no ninja reflexes needed this time, the RegAsm process doesn't kill itself quickly because\nthe final payload is running in there). Once the process has been suspended, we attach\n**OlleDbg to it (image seven). In the memory space of RegAsm we search for the executable**\nmagic number \"MZ\" (image eight). When looking for \"MZ\", we can spot in RegASMs memory\nwhat seems to be an executable (notice 'This program cannot be run in DOS mode'). This\nexecutable can be dumped from memory using the OllyDumpEx plugin (image eight).\n\nImage 7: extracting Pony from the hollowed RegAsm process using OllyDbg\n\n\n-----\n\nImage 8: searching for the injected Pony executable in RegAsms memory\n\n\n-----\n\nImage 9: dumping the injected payload from RegAsms memory with OllyDumpEx\n\nWhen searching for strings in the dumped executable, one can spot some interesting strings.\nWe see URL's that contain the 'Panel/gate.php' structure. This structure refers to the default\nPony server side path setup. The server side component receives and stores the stolen\ncredentials. The strings found in the dumped executable also suggest that configurations and\ndatabases of software like Filezilla, Firefox or Google Chrome are queried. It also interesting\nto see that the malware contains a list of what seems to be a set of default passwords (who\nuses jesus as a password ?!). This behaviour is also typical for the Pony malware. In the\nlast paragraph, we'll shortly discuss the Pony malware.\n\n\n-----\n\nImage 10: Quick inspection of the dumped payload.\n\nPony password stealer/dropper\n\n**Nowadays, malware is modular: there are crimeware kits helping to set up your own C&C**\n(Command and Control server) and prepare the payload. This is also the case for the Pony\nmalware: the payload can be build via a nice graphical user interfaces, because the threat\nactors who are using the malware aren't necessarily as technical savy as the group who\ncoded the malware. Additionally to the C&C setup and the payload itself, crypters are used\nto pack the payload, and e.g. Exploit Kits (browser exploit, PDF exploit, Office exploit,\n**...) are used to deliver it.**\n\nBelow an example of a pony builder can be found. The builder gives you the option to load\n(drop) additional files, to configure the location of the command and control server and to\nselect from which applications the stored credentials need to be stolen. By default, the Pony\nbuilder executable contains an icon of a Pony (d'uh). If you use Google reverse image\n\n\n-----\n\nsearch on the Pony icon, you ll notice that the malware authors have stolen that icon from the\n[popular FarmVille game. Stealing credentials and passwords is one thing, but stealing from](https://en.wikipedia.org/wiki/FarmVille)\nFarmVille, really ?\n\nImage 11: Pony builder pannel.\n\n\n-----\n\nImage 12: The origin of Pony's icon: farmville\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-08 - Analysis of a packed Pony downloader.pdf"
    ],
    "report_names": [
        "2016-08 - Analysis of a packed Pony downloader.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536166,
    "ts_updated_at": 1743041150,
    "ts_creation_date": 1653787663,
    "ts_modification_date": 1653787663,
    "files": {
        "pdf": "https://archive.orkl.eu/8ceaac7ae0ce025b6be6c11669b9a3fdb3a95a38.pdf",
        "text": "https://archive.orkl.eu/8ceaac7ae0ce025b6be6c11669b9a3fdb3a95a38.txt",
        "img": "https://archive.orkl.eu/8ceaac7ae0ce025b6be6c11669b9a3fdb3a95a38.jpg"
    }
}