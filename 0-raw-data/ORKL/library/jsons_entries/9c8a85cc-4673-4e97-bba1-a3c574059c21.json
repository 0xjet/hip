{
    "id": "9c8a85cc-4673-4e97-bba1-a3c574059c21",
    "created_at": "2023-01-12T15:01:07.680952Z",
    "updated_at": "2025-03-27T02:12:11.123409Z",
    "deleted_at": null,
    "sha1_hash": "c06dfbaf874d9e699057845a21d75ab869e1a427",
    "title": "2018-02-08 - A review of the evolution of Andromeda over the years before we say goodbye",
    "authors": "",
    "file_creation_date": "2022-05-28T19:00:25Z",
    "file_modification_date": "2022-05-28T19:00:25Z",
    "file_size": 1070018,
    "plain_text": "# A review of the evolution of Andromeda over the years before we say goodbye\n\n**[virusbulletin.com/virusbulletin/2018/02/review-evolution-andromeda-over-years-we-say-goodbye/](https://www.virusbulletin.com/virusbulletin/2018/02/review-evolution-andromeda-over-years-we-say-goodbye/)**\n\n### Bahare Sabouri & He Xu\n\nFortinet, Canada\n\n_Copyright © 2018 Virus Bulletin_\n\nTable of contents\n\nIntroduction\n\nOverview of Andromeda\n\nLoader\n\nMain structure\n\nPayload\n\nEvolution of C&C\n\nSide note\n\nConclusion\n\nReferences\n\nSample information\n\nVersion 2.06\n\nVersion 2.07\n\nVersion 2.08\n\nVersion 2.09\n\nVersion 2.10\n\n## Introduction\n\nAndromeda, also known as Gamaru and Wauchos, is a modular and HTTP-based botnet that was\ndiscovered in late 2011. From that point on, it managed to survive and continue hardening by evolving\nin different ways. In particular, the complexity of its loader and AV evasion methods increased\nrepeatedly, and C&C communication changed between the different versions as well.\n\nWe deal with versions of this threat on a daily basis and we have collected a number of different\nvariants. The botnet first came onto our tracking radar at version 2.06, and we have tracked the\nversions since then. In this paper we will describe the evolution of Andromeda from version 2.06 to\n2.10 and demonstrate both how it has improved its loader to evade automatic analysis/detection and\nhow the payload varies among the different versions.\n\nThis article could also be seen as a way to say 'goodbye' to the botnet: a takedown effort, followed by\nthe arrest of the suspected botnet owner in December 2017, may mean we have seen the last of the\nbotnet that has plagued Internet users for more than half a decade.\n\n\n-----\n\n## Overview of Andromeda\n\nThe first Andromeda to be discovered was spotted in the wild in 2011, and the new 2.06 version\nfollowed quickly afterwards in early 2012. Not much is known about any earlier versions and it is\npossible they were never released into the wild.\n\nThe campaign continued to develop with versions 2.07, 2.08, 2.09 and 2.10. The latest known version,\n2.10, was first seen in 2015 and may be the final version released: according to posts on underground\nforums, the development of the threat stopped around a year ago. Figure 1 shows a brief history of\nAndromeda.\n\nFigure 1: A brief history of Andromeda.\n\nRegardless of the version, Andromeda arrives on the target machine as a packed sample. Various\npackers have been used, from very famous packers such as UPX and SFX RAR to lesser known and\neven customized ones which are compiled in various languages such as Autoit, .Net and C++.\n\n\n-----\n\nUnpacking the first layer of the sample reveals the loader, which is small both in terms of size (13KB to\n20KB) and in the number of function calls it contains.\n\n## Loader\n\nIn all versions of Andromeda the loader avoids making direct calls to APIs. Instead, it incorporates\nhashes to find and call the APIs via general purpose registers. Versions 2.06, 2.07 and 2.08 pass hash\nvalues as immediate values to a function and thus find the matching API name. Version 2.06 uses a\ncustom hash function, while versions 2.07 and 2.08 use CRC32. Versions 2.09 and 2.10 have the\nsame trivial custom hash function. Figure 3 shows the loader in version 2.09 handling an array of hash\nvalues.\n\nFigure 2: Version 2.08\n\npasses the hash as an immediate value to 'resolveAddress_byHash'.\n\nFigure 3: In version 2.09, the\n\nloader handles an array of hash values.\n\nVersion 2.10 also keeps an array of API hash values. The hash algorithm is a custom function and, in\norder to complicate static analysis further, the author incorporates opaque predicates, as shown in\nFigure 4.\n\n\n-----\n\nFigure 4: Opaque predicates in the version 2.10 loader make static anaylsis more difficult.\n\n## Main structure\n\nThe section in the loader that is used to evade virtual machines and, more generally, analysis, is\nsimilar in versions 2.06, 2.07 and 2.08. In these variants, the loader enumerates the processes running\non the machine and compares them against a list of unwanted processes. In order to do this, the\nloader converts the name of each process to lowercase and then calculates its hash value. The hash\nvalues are then compared against a hard-coded list of values. The same algorithm as is used to hash\nAPI names is used here. The hash algorithm in version 2.08 has an extra xor instruction (xor eax,\n0E17176Fh). As shown in Figure 5, the newer versions have longer lists of unwanted processes.\n\n\n-----\n\nFigure 5: From left to right: version 2.06, 2.07 and 2.08 hard-coded hash values correspond to the list\nof unwanted processes.\n\n|2.06|2.07|2.08|\n|---|---|---|\n\n\n-----\n\n0x4CE5FD07: vmwareuser.exe\n\n0x8181326C:\nvmwareservice.exe\n\n0x31E233AF: vboxservice.exe\n\n0x91D47DF6: vboxtray.exe\n\n0xE8CDDC54:\nsandboxiedcomlaunch.exe\n\n0x8C6D6C:\nsandboxierpcss.exe\n\n0x0A8D0BA0E: procmon.exe\n\n0x0A4EF3C0E: wireshark.exe\n\n0x5CD7BA5E: netmon.exe\n\n\n0x99DD4432: vmwareuser.exe\n\n0x2D859DB4:\nvmwareservice.exe\n\n0x64340DCE: vboxservice.exe\n\n0x63C54474: vboxtray.exe\n\n0x349C9C8B:\nsandboxiedcomlaunch.exe\n\n0x3446EBCE:\nsandboxierpcss.exe\n\n0x5BA9B1FE: procmon.exe\n\n0x3CE2BEF3: regmon.exe\n\n0x3D46F02B: filemon.exe\n\n0x77AE10F7: wireshark.exe\n\n0x0F344E95D: netmon.exe\n\n\n0x97CA535D: vmwareuser.exe\n\n0x23928ADB:\nvmwareservice.exe\n\n0x6A231AA1: vboxservice.exe\n\n0x6DD2531B: vboxtray.exe\n\n0x3A8B8BE4:\nsandboxiedcomlaunch.exe\n\n0x3A51FCA1:\nsandoxierpcss.exe\n\n0x55BEA691: procmon.exe\n\n0x32F5A99C: regmon.exe\n\n0x3351E744: filemon.exe\n\n0x79B90798: wireshark.exe\n\n0x0FD53FE32: netmon.exe\n\n0x23A97A00:\nprl_tools_service.exe\n\n0x0ADC6152B: prl_tools.exe\n\n0x1365FAFE: prl_cc.exe\n\n0x98847CD1:\nsharedintapp.exe\n\n0x299BC837: vmtoolsd.exe\n\n0x35E8EFEA: vmsrvc.exe\n\n0x632434B6: vmusrvc.exe\n\n\nTable 1: Corresponding process to each hash.\n\nNext, the bot takes advantage of registry artifacts and checks the registry value in the following key:\n\nKey: HKLM\\system\\currentcontrolset\\services\\disk\\enum\n\nValueName: 0\n\nVersion 2.06 parses the value of the subkey for the presence of the substrings 'qemu', 'vbox' and\n'wmwa'. Similarly, versions 2.07 and 2.08 check for 'qemu', 'vbox' and 'vmwa'. (It is likely that 'wmwa'\nwas a bug in version 2.06 that was patched later.) Upon finding any of these strings, each version\ntakes a different approach to redirect the flow of the code.\n\nBefore redirecting the code in versions 2.06 and 2.07, the sample designates another snippet of code\nthat uses a technique known as 'time attack' in order to prevent further analysis. The malware acquires\nthe timestamp counter (by calling rdtsc) twice and calculates the difference between the two. If the\ndifference is less than 512ms, it proceeds to resolve imports and decrypt the payload. Otherwise, it\nleads to a dummy code, where the loader drops a copy of itself in %ALLUSERSPROFILE% and\nrenames it to svchost.exe.\n\nFigure 6:\n\nTimestamp analysis to detect the debugger.\n\n\n-----\n\nFollowing that, it creates an autorun registry for the dropped file as follows:\n\nKey: HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\nValueName: SunJavaUpdateSched\n\nEventually, waiting for a command in an infinite loop, it sniffs port 8000. A received command will then\nbe run in the command window.\n\nAs part of its evolution, version 2.07 implements a custom exception handler using a call to\nSetUnhandledExceptionFilter. Similarly, version 2.08 calls RtlAddVectoredExceptionHandler and adds\nthe custom handler as the first handler into the vectored exception handler chain (VEH), as shown in\nFigures 7 and 8.\n\nFigure 7: Bot creates a custom exception handler in version 2.07.\n\nFigure 8: Bot adds a custom exception handler into VEH in version 2.08.\n\n\n-----\n\nIf the malware finds any of the substrings in the retrieved registry, it runs a function that causes an\naccess violation. The access violation is created intentionally when the sample tries to overwrite the\nDLL characteristics in the PE header which only has read rights, as shown in Figures 9 and 10.\n\nFigure 9: Overwriting the PE header raises an exception.\n\nFigure 10: The PE\n\nheader only has read rights.\n\nIn this case, if the sample is not being debugged, control is passed immediately to the custom handler.\nThe custom exception handler decrypts a piece of code that will be injected into another process later\n(Figure 11).\n\nFigure 11: Custom exception handler.\n\nVersions 2.07 and 2.08 share another feature that controls whether the loader bypasses anti-VM and\nanti-debugging procedures. The loader calls GetVolumeInformationA on the 'C:\\' drive and acquires the\ndrive name. Next, it calculates the CRC32 of the drive name and compares it against a hard-coded\n\n\n-----\n\nvalue, 0x20C7DD84 (Figure 12). If they match, it bypasses the anti-forensics checks and proceeds\ndirectly to invoke the exception. The author probably used this technique to test the bot in his/her\nvirtual machine without the need to go through the anti-VM/anti-analysis features.\n\nFigure 12: Drive\n\nC checksum is calculated and compared to 0x20C7DD84.\n\nVersions 2.09 and 2.10 evade debugging and analysis by implementing the same idea as previous\nversions, but this time in the payload. Eventually, in all versions, the loader injects the payload into a\nremote process using a process hollowing technique and runs it in memory.\n\n## Payload\n\nAs mentioned, the payloads of versions 2.09 and 2.10 start with some anti-VM tricks, despite the\nearlier versions having taken care of this in the loader. Like the older versions, they check for a list of\nblacklisted processes in case the machine is compromised. The number of blacklisted processes in\nversion 2.09 is exactly the same as in 2.08, whereas it increases to 21 processes in version 2.10 (see\nFigure 13). Like versions 2.07 and 2.08, versions 2.09 and 2.10 calculate the CRC32 of the process\nname. However, instead of implementing the algorithm, they call RtlComputeCrc32 directly. If the bot\nfinds any of the target processes, it runs a snippet of code to sleep for one minute in an infinite loop in\norder to evade detection.\n\nFigure 13: The\n\nnumber of blacklisted processes increases in version 2.10.\n\n\n-----\n\nIf HKLM\\software\\policies contains the registry key is_not_vm and the key is VolumeSerialNumber,\nversion 2.10 bypasses these checks. This behaviour is comparable to that in versions 2.07 and 2.08\nwhere the bot checked the checksum of the root drive.\n\n## Evolution of C&C\n\nThe main aim of Andromeda's payload is to steal the infected system's information, talk to the\ncommand-and-control (C&C) server, and download and install additional malware onto the system. In\norder to do this, it initiates a sophisticated command-and-control channel with the server. Each version\nof Andromeda uses a different format for the message and the report that it sends to the server.\n\nAs shown in Table 2, each version has two message formats, both sent as HTTP POST requests:\nAction Request and Task Report. Action Request contains the information exfiltrated from the\ncompromised system; the bot sends it to the server after encryption. Task Report, as the name implies,\nprovides a report about the accomplished task.\n\n**Version** **Action Request** **Task Report**\n\n**2.06** id:%lu|bid:%lu|bv:%lu|sv:%lu|pa:%lu|la:%lu|ar:%lu id:%lu|tid:%lu|result:%lu\n\n**2.07** id:%lu|bid:%lu|bv:%lu|os:%lu|la:%lu|rg:%lu id:%lu|tid:%lu|res:%lu\n\n**2.08** id:%lu|bid:%lu|bv:%lu|os:%lu|la:%lu|rg:%lu id:%lu|tid:%lu|res:%lu\n\n**2.09** id:%lu|bid:%lu|os:%lu|la:%lu|rg:%lu id:%lu|tid:%lu|err:%lu|w32:%lu\n\n**2.10** {“id”:%lu,“bid”:%lu,“os”:%lu,“la”:%lu,“rg”:%lu} {“id”:%lu,“tid”:%lu,“err”:%lu,“w32”:%lu}\n\n{“id”:%lu,“bid”:%lu,“os”:%lu,“la”:%lu,“rg”:%lu,“bb”:%lu}\n\nTable 2: Evolution of the message formats.\n\nThe Action Request format shares some essential tags among all versions, such as 'id' and 'bid', while\nsome other tags are version‑specific, such as 'ar' in version 2.06 and 'bb' in version 2.10. It is only the\nlast version of the bot that uses JSON format to communicate with the C&C server.\n\nTable 3 describes the role of each tag in the format.\n\n|Version|Action Request|Task Report|\n|---|---|---|\n|2.06|id:%lu|bid:%lu|bv:%lu|sv:%lu|pa:%lu|la:%lu|ar:%lu|id:%lu|tid:%lu|result:%lu|\n|2.07|id:%lu|bid:%lu|bv:%lu|os:%lu|la:%lu|rg:%lu|id:%lu|tid:%lu|res:%lu|\n|2.08|id:%lu|bid:%lu|bv:%lu|os:%lu|la:%lu|rg:%lu|id:%lu|tid:%lu|res:%lu|\n|2.09|id:%lu|bid:%lu|os:%lu|la:%lu|rg:%lu|id:%lu|tid:%lu|err:%lu|w32:%lu|\n|2.10|{“id”:%lu,“bid”:%lu,“os”:%lu,“la”:%lu,“rg”:%lu} {“id”:%lu,“bid”:%lu,“os”:%lu,“la”:%lu,“rg”:%lu,“ bb”:%lu}|{“id”:%lu,“tid”:%lu,“err”:%lu,“w32”:%lu}|\n\n|Action Request|Task Report|Col3|Col4|\n|---|---|---|---|\n|Tag|Information|Tag|Information|\n|id|Volume serial number of victim machine|id|Volume serial number of victim machine|\n|bid|Bot ID, a hard-coded DWORD in payload|tid|Task ID provided by server|\n|bv|Bot version|res/result/err|Flag indicating if task is successful|\n\n\n-----\n\n|pa|Flag indicating whether OS is 32-bit or 64-bit|w32|System error code, returned by RtlGetLastWin32Error|\n|---|---|---|---|\n|la|Local IP address acquired from sockaddr structure|||\n|ar/rg|Flag indicating if the process runs in the administrator group|||\n|sv/os|Version of the victim operating system|||\n|bb|Flag indicating if victim system uses a Russian, Ukrainian, Belarusian or Kazakh keyboard|||\n\n\nTable 3: Definition of tags.\n\nWe believe that 'bid' is used to represent build ID and, interestingly, in some versions, like 2.06 and\n2.10, it indicates a date in the format YYYYMMDD, as can be seen in Figure 14. In other instances,\nthis tag represents a hard-coded random number. The latest observed 'bid' in version 2.10 is 22 May\n2017, which suggests that development stopped then.\n\nFigure\n\n14: 'bid' value in version 2.10.\n\nAfter version 2.08, 'bv', which indicates the bot version, is removed from the request message.\nHowever, in the two latest versions, there remains a clue as to the bot version, which is a hard-coded\nxor key. This xor key is used in five different places in version 2.09 and twice in version 2.10. In all\ncases, it xors the 'id' and will be further manipulated to be used as the file name or registry value (see\nFigures 15 and 16).\n\nFigure 15: The bot version is represented as a hard-coded xor key and used as a file name.\n\n\n-----\n\nFigure 16: The\n\nbot version is represented as a hard-coded xor key and used in registries.\n\nWhen the message is prepared for the required information, in all versions except the most recent one,\nthe string is encrypted in two steps. The first step uses a 20-byte hard‑coded RC4 key and the second\nstep uses base64 encoding. Version 2.10 encrypts the message only using the RC4 algorithm. After\nposting the message to the server, the bot receives a message from the server. The bot validates the\nmessage by calculating its CRC32 hash excluding the first DWORD, which serves as a checksum. If\nthe hash equals this excluded DWORD, it proceeds to decrypt the message using the 'id' value as the\nRC4 key.\n\nNext, it decodes the base64 string and obtains a plain text message. Received messages have the\nfollowing structure:\n```\nstruct RecvBlock {\n   uint8_t cmd_id;\n   uint32_t tid;\n   char cmd_param[];\n};\n\n```\nAccording to the communicated cmd_id, the bot carries out a designated command which could be any\nnumber from the following: 1, 2, 3, 4, 5, 6, 9. In versions prior to 2.09, the bot is capable of performing\nall seven tasks. But in versions 2.09 and 2.10, it discards commands 4 and 5.\n\nIn Table 4 we take a look at each task and describe it further using static analysis of the code.\n\n\n-----\n\n|cmd_id|Task type|Description|\n|---|---|---|\n|1|Download EXE|Using the domain provided in the command_parameter, the bot downloads an exe, saves it in the temp folder with a random name, and executes it.|\n|2|Install plug-in|Using the domain provided in the command_parameter, the bot installs and loads plug-ins.|\n|3|Update bot|Using the domain provided in the command_parameter, the bot gets the exe file to update itself. If a file named ‘Volume Serial Number’ exists in the registry, the bot drops the update in the temp folder and gives it a random name. Otherwise, the file is dropped in the current directory. This task is followed by cmd_id=9, which kills the older bot.|\n|4|Install DLL|Using the domain provided in the command_parameter, the bot downloads a DLL into the %alluserprofile% folder with a random name and .dat extension.|\n|5|Delete DLLs|The DLL loaded in cmd_id=4 is uninstalled.|\n|6|Delete plug-ins|The plug-ins loaded in cmd_id=3 are uninstalled.|\n|9|Kill bot|All threads are suspended and the bot is uninstalled.|\n\n\nTable 4: The seven command IDs and their tasks.\n\nIt is interesting to note that the cmd_id value changes a little in versions 2.09 and 2.10. As a result, the\nbot first downloads the plug-in and later finds three plug-in exports, aStart, aUpdate and aReport, using\na call to the GetProcAddress API (Figure 17).\n\nFigure 17: The\n\npayload also searches for plug-in exports aStart and aUpdate.\n\nTo summarize, Andromeda normally spreads via exploit kits located on compromised websites. The\nprimary sample is packed and drops the loader after the unpacking stage. In the earlier versions of the\nbot the loader contains anti-VM and anti-analysis tricks. In all versions, the loader decrypts the payload\nand resolves APIs for indirect calls in the payload. As a result, using an anti-API hooking trick, the\nloader saves the first instruction of the API call into memory and jumps to the second instruction.\n\nIn the last two versions of the bot (2.09 and 2.10) the payload contains anti-VM and anti-analysis\nfeatures. In version 2.07 and later versions, the payload leverages an inline hooking technique and\nhooks selected APIs. For example, in versions 2.07 and 2.08 the bot hooks GetAddrInfoW,\nZwMapViewOfSection and ZwUnmapViewOfSection; in version 2.09 it hooks GetAddrInfoW and\n\n\n-----\n\nNtOpenSection; and in version 2.10 it hooks GetAddrInfoW and NtMapViewOfSection. In all versions,\nthe bot steals information from the compromised system, sends the information to the server (after\nencryption), and waits for a command from the server.\n\nUpon receiving a command from the server, the bot acts accordingly, installing plug-ins and\ndownloading other malware. Finally, the bot sends a report about its mission to the server.\n\nFigure 18: Andromeda at a glance.\n\n## Side note\n\nIt has been a while since the last version of Andromeda was released. We have been waiting a long\ntime for a new variant to emerge, but Reuters reported recently:\n\n'National police in Belarus, working with the U.S. Federal Bureau of Investigation, said they had\narrested a citizen of Belarus on suspicion of selling malicious software who they described as\nadministrator of the Andromeda network.' [3]\n\nBased on that, we can tentatively call this the end of the Andromeda era, and conclude that there won't\nbe any further releases.\n\n## Conclusion\n\nFrom 2011 to 2015, Andromeda kept analysts busy with its compelling features and functionality, and it\nremains among the most prevalent malware families today. Over the course of four years, five major\nversions were released, each new version being more complex than its predecessor. This guaranteed\nthat Andromeda remained a sophisticated threat. A flexible C&C provided a wide range of functionality\nand efficiency, increasing the power of the threat by installing various modules. Meanwhile, it\nintegrated several RC4 keys to encrypt data for C&C communications, thus making detection a\nsignificantly more complex challenge. Fortunately, however, analysts have become sufficiently familiar\nwith Andromeda's ecosystem over the years to learn how to navigate all of its challenges.\n\n\n-----\n\n## References\n\n[1] Tan, N. Andromeda 2.7 features. Fortinet blog. 23 April 2014.\n[https://blog.fortinet.com/2014/04/23/andromeda-2-7-features.](https://blog.fortinet.com/2014/04/23/andromeda-2-7-features)\n\n[2] Xu, H. A good look at the Andromeda botnet. Virus Bulletin. May 2013.\n[https://www.virusbulletin.com/virusbulletin/2013/05/good-look-andromeda-botnet.](https://www.virusbulletin.com/virusbulletin/2013/05/good-look-andromeda-botne)\n\n[3] Sterling, T.; Auchard, E. Belarus arrests suspected ringleader of global cyber crime network.\n[Reuters. 5 December 2017. https://ca.reuters.com/article/technologyNews/idCAKBN1DZ1VY-OCATC.](https://ca.reuters.com/article/technologyNews/idCAKBN1DZ1VY-OCATC)\n\n[4] Xu, H. Cracked Andromeda 2.06 spreads bitcoinn miner. Fortinet blog. 7 January 2015.\n[https://blog.fortinet.com/2015/01/07/cracked-andromeda-2-06-spreads-bitcoin-miner.](https://blog.fortinet.com/2015/01/07/cracked-andromeda-2-06-spreads-bitcoin-miner)\n\n## Sample information\n\n### Version 2.06\n\n**MD5: 73564f834fd0f61c8b5d67b1dae19209**\n\n**SHA256: 4ad4752a0dcaf3bb7dd3d03778a149ef1cf6a8237b21abcb525b9176c003ac3a**\n\n**Fortinet detection name: W32/Kryptik.AFJS!tr**\n\n### Version 2.07\n\n**MD5: d7c00d17e7a36987a359d77db4568df0**\n\n**SHA256: 44950952892d394e5cbe9dcc7a0db0135a21027a0bf937ed371bb6b8565ff678**\n\n**Fortinet detection name: W32/Injector.ZVR!tr**\n\n### Version 2.08\n\n**MD5: b4d37eff59a820d9be2db1ac23fe056e**\n\n**SHA256: 92d25f2feb6ca7b3e0d921ace8560160e1bfccb0beeb6b27f914a5930a33e316**\n\n**Fortinet detection name: W32/Tepfer.ASYP!tr.pws**\n\n### Version 2.09\n\n**MD5: 3f2762d18c1abc67e21a7f9ad4fa67fd**\n\n**SHA256: 2f44d884c9d358130050a6d4f89248a314b6c02d40b5c3206e86ddb834e928f6**\n\n**Fortinet detection name: W32/BLDZ!tr**\n\n### Version 2.10\n\n**MD5: fb0a6857c15a1f596494a28c3cf7379d**\n\n**SHA256: 73802eaa46b603575216fb212bcc18c895f4c03b47c9706cde85368c0334e0cd**\n\n\n-----\n\n**Fortinet detection name: W32/Malicious_Behavior.VEX**\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order to infiltrate\norganizations’ dedicated environments and transform them into attack launchpads. In this article Aditya\nSood presents a new module introduced by…\n\n### Collector-stealer: a Russian origin credential and information extractor\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to exfiltrate\nsensitive data from end-user systems and store it in its C&C panels. In this article, researchers Aditya\nK Sood and Rohit Chaturvedi present a 360…\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and from that\nmoment onward, was intrigued by the properties of these small pieces of self-replicating code. Joe\nWells was an expert on computer viruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\nKurt Natvig wanted to understand whether it’s possible to recompile VBA macros to another language,\nwhich could then easily be ‘run’ on any gateway, thus revealing a sample’s true nature in a safe\nmanner. In this article he explains how he recompiled…\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware, discussing\nhis team's findings related to the C&C design and some security issues they identified during the\nresearch.\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\nWe have placed cookies on your device in order to improve the functionality of this site, as outlined in\nour [cookies policy. However, you may delete and block all cookies from this site and your use of the site](https://www.virusbulletin.com/about-vb/privacy-policy/cookies)\nwill be unaffected. By continuing to browse this site, you are agreeing to Virus Bulletin's use of data as\n[outlined in our privacy policy.](https://www.virusbulletin.com/about-vb/privacy-policy/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-02-08 - A review of the evolution of Andromeda over the years before we say goodbye.pdf"
    ],
    "report_names": [
        "2018-02-08 - A review of the evolution of Andromeda over the years before we say goodbye.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535667,
    "ts_updated_at": 1743041531,
    "ts_creation_date": 1653764425,
    "ts_modification_date": 1653764425,
    "files": {
        "pdf": "https://archive.orkl.eu/c06dfbaf874d9e699057845a21d75ab869e1a427.pdf",
        "text": "https://archive.orkl.eu/c06dfbaf874d9e699057845a21d75ab869e1a427.txt",
        "img": "https://archive.orkl.eu/c06dfbaf874d9e699057845a21d75ab869e1a427.jpg"
    }
}