{
    "id": "82b5a018-3c71-460b-8257-4560c73f3cd8",
    "created_at": "2023-01-12T15:08:57.396783Z",
    "updated_at": "2025-03-27T02:16:25.81643Z",
    "deleted_at": null,
    "sha1_hash": "fc38bead62b7114951cd20fd1a6cda58847d4671",
    "title": "2020-09-25 - The Fresh Smell of ransomed coffee",
    "authors": "",
    "file_creation_date": "2022-05-28T02:46:42Z",
    "file_modification_date": "2022-05-28T02:46:42Z",
    "file_size": 11271400,
    "plain_text": "# The Fresh Smell of ransomed coffee\n\n**[decoded.avast.io/martinhron/the-fresh-smell-of-ransomed-coffee/](https://decoded.avast.io/martinhron/the-fresh-smell-of-ransomed-coffee/)**\n\nby [Martin HronSeptember 25, 202028 min read](https://decoded.avast.io/author/martinhron/)\n\n\nSeptember 25, 2020\n\n\nWe turned a coffee maker into a dangerous machine asking for ransom by modifying the\nmaker’s firmware. While we could, could someone else do it too? As you might expect, the\nanswer is: Yes. Follow us on a journey where we show you that firmware is the new\nsoftware.\n\n## Firmware is the new software\n\nSome research is so fun that it confirms why I do this work. I was asked to prove a myth,\ncall it a suspicion, that the threat to IoT devices is not just to access them via a weak router\nor exposure to the internet, but that an IoT device itself is vulnerable and can be easily\nowned without owning the network or the router. I also bet that I could make that threat\npersist and present a true danger to any user. We often say that your home network,\nthought of as a chain of trust, is only as strong as its weakest link, but what if the same\nwere true at the device level? What would that mean?\n\nLet’s say you have an IoT device that is well protected with functions that can be accessed\nthrough a well-defined API; even if you can control the device through the API, you probably\ncan’t do too much harm. Firmware, the programming inside the device has logical\nconstraints that don’t allow you, for example, to close garage doors while someone is in the\nway of them or overheat a device so that it combusts.\n\n\n-----\n\nWe used to trust that hardware, such as a common kitchen appliance, could be trusted and\ncould not be easily altered without physically dismounting the device. But with today’s\n“smart” appliances, this is no longer the case.\n\nMy colleagues often hear me say that “firmware is a new software.” And that software is\nvery often flawed. We see it everywhere. CPU flaws, and cryptographic chips generating\nweak keys that can be easily broken. The weakened state of IoT security is due in large\npart to the fact that, nowadays, it is more convenient and cheap to place a processor inside\na device which controls and orchestrates all hardware parts, motors, sensors, heating\nelements, etc. based on a short program called firmware. This solution is not only cheap,\nbut has also one important property – it can be updated\n\nBack in the day, if there was a so-called design flaw in a piece of hardware, the rigid design\n(often hardwired) meant the vendor would need to replace the whole component or logic\nboard or even replace the entire device. Manufacturers would have to change the\nmanufacturing process and at potentially great financial losses. In the era of firmware, this\ncan be easily mitigated just by issuing a firmware update.\n\nThe process of updating firmware can vary greatly, from connecting to the special device\nusing a special tool (which still requires the vendor’s physical interaction) to the more and\nmore popular way of OTA (over the air) updates. In this case, a vendor doesn’t have to be\nphysically present and the whole process is done either automatically over the internet or\nsemi-automatically after a user’s notification and approval of the update.\n\n## Making your first geeky coffee\n\nSo let’s see what we have. We have a coffee maker that allows you to make coffee the old\nfashioned way by pressing a few buttons or via a mobile phone or tablet using an app. The\nmaker operates with Wi-Fi and when unboxed you have to connect it to your network\nthrough a companion app on your mobile phone. When turned on for the first time, the\ncoffee maker works in a local mode and it creates its own Wi-Fi network that the hopeful\ncoffee drinker first connects to in order to set up the device.\n\nIt’s worth to mention that this coffee maker is no longer supported by the vendor as they\nmoved to a more secure platform in 2017 and technology because of all the flaws illustrated\nin this research. But this also shows a general problem we have with abandoned IoT\ndevices.\n\nWhen we downloaded the companion app, we saw that it allows you to create a network of\nany devices of this particular vendor and connects these devices to the home network and\nthen allows you to control all the functions of your coffee maker or smart kettle. It also\nallows you to check the firmware version of the device and update it if needed.\n\n\n-----\n\nThe protocol that this device speaks has already been documented on the internet by\nseveral other researchers. As expected, it’s a simple binary protocol with hardly any\nencryption, authorization or authentication. Communication with machines takes place on\n```\nTCP port 2081 . The format of the command is very simple:\n\n```\nIn response (if there is a response) the coffee maker sends back:\n```\nresponse_type differs based on the command, but the general rule is: If the response\n\n```\ncontains data `response_type = command + 1, if it’s just a status then`\n```\nresponse_type=3 and then there is only one data byte which contains resulting status,\n\n```\nwhere `1 means success. The complete list of commands is in the GitHub repository.`\n\nSo just for illustration, by issuing this command:\n\n_making a nice cup of coffee with_\n\n_“default” settings_\nYou’ll make yourself a nice cup/cups of coffee based on the default settings of the coffee\nmaker. As you can see, there is no security, so anyone who has access to the network and\nis able to reach the IP address of the coffee maker can control it. What is more interesting,\nis that all these commands are also available through that default opened Wi-Fi network\nwhen the device is not joined to a home network yet.\n\n## Update the future\n\nLet’s return to our main goal of hijacking the coffee maker for nefarious purposes. How\nsecure is the updating process? Can we break into it? Can we even change the firmware to\ndo something else than was originally intended? Can we turn the device into a physically\ndangerous device? Can we do it remotely? As I said in the beginning, the weakest link\nalways compromises the whole system. Either it’s a network or a device. The goal is\nanswering all the above questions and prove that IoT devices could be also compromised\nat the firmware level.\n\n\n-----\n\nTo start, we wanted to learn how the update process works. We have several options to do\nthis, but we already have a recipe for this based on similar past research we have done.\nThe general rule is to make it as simple as possible; here is our to-do list when trying to\nreverse the update process of a piece of firmware.\n\n1. Get it (the file with the firmware)\n2. Unpack it (if it is packed/encrypted)\n3. Reverse engineer it (translate those zeroes and ones into meaningful code)\n4. Modify it (add the malicious content)\n5. Upload it (and push it back to the device)\n\nIt’s simple right?\n\n## Finding the firmware\n\nFirst, we need to get the firmware somehow, and again there are several options. Let’s stick\nto the rule, the simplest option first:\n\n1. Google it – as obvious as it seems, sometimes security researchers omit this step\n\nwhich could save them a lot of work. Firmware is often available on the internet to be\ndownloaded.\n2. Capture and analyze network traffic – if the protocol is unencrypted the easiest way is\n\nto just capture the network traffic, in that case, we have three more options where to\nlook\n\ntraffic between the device and the internet\ntraffic between device and companion app, if there is any\ntraffic between the companion app and the internet\n3. Analyze and reverse engineer the companion app. Before we dive deeply into the\n\ndevice, it’s advisable to first peek into the device’s companion app, it’s usually the\neasiest solution for grabbing the communication protocol and commands. No luck with\nany of the above? It’s time to dismount the device, trace the board to identify all the\ncomponents, get datasheets to find debugging ports, and possibly dump the firmware\ndirectly from the chip. This is really an adventure in hardware and not for everyone.\n\nLife is not so simple, and neither is reverse engineering IoT devices. It turned out that we\nhad to use a combination of all the aforementioned techniques. First, we googled it, and as\nthe commands have already been documented, we found a command that says `“update`\n```\nthe firmware.” But the command itself (its parameters and format) had not been\n\n```\ndocumented. So by issuing:\n\n\n-----\n\nthis simple (two bytes) command\n\n_switches coffee maker into update mode_\nthe coffee maker goes into an update mode (on the newer firmware you have to push a\nbutton to actually start the update, but this is not the case with older versions !)\n\nHmm nice, but nothing happens. By analyzing network traffic, we concluded that there is\nnothing to analyze, as there is no traffic coming out of the coffee maker at this stage. So we\ntried the Android companion app.\n\n\n-----\n\n_Android application for smart coffee maker, right picture shows an update screen_\nYou can see the update button is grayed out, so obviously, the firmware is up-to-date and\nthere is no easy option to push the firmware update to be able to see what’s in the network\ntraffic. What’s interesting here is what’s missing. There was no communication to the\ninternet neither from the coffee maker nor from the app. So how is it possible that the app\nknows that the coffee maker has the latest firmware? The only packets of data that went\nthrough were those between the machine and app when the app had been asking the\nmachine for the version of the firmware.\n\nTypical traffic analysis of IoT with companion app: we are interested in traffic between app\n\n\n-----\n\nand internet and app and device.\nThis is strange, and it seemed to tell us that the firmware is probably not on the internet and\nmust be part of the app. So we opened the .apk file as easy as a .zip file. What we found\nthere, proved our assumption.\n\n_Files inside the apk: You can see firmware for both products are contained in the two files_\n_with suffix .bin_\nThe firmware is part of the Android app and it also means that new versions of the firmware\nalways come with new versions of the app. This makes perfect sense if you think about it\nfor a second. The new firmware usually adds new functionality, which has to be reflected\nsomehow inside the user interface of the app, and it allows us to find a file containing the\nfirmware without even touching the device. That’s nice and not very common.\n\n## Reverse engineering\n\nIn the next step of my research we try to figure out what the file contains. The first thing any\nreverse engineer would do would be to just eyeball the file and see what it contains. What\nwe saw there was a bunch of strings that actually made sense. From this, we could deduce\nthere is no encryption and the firmware is probably a “plaintext” image that is uploaded\ndirectly into the `FLASH memory of the coffee maker.`\n\n\n-----\n\nContent of the file tells us that there is no encryption involved and also that there is a\nprobably extra WiFi modem module\nTo be able to understand what the firmware does we had to decode the binary into an\nassembly, that means we needed to know the processor or architecture this firmware is\ntargeting.\n\nWe can guess or we can experiment. Or we could dismount the device to get information\nabout the hardware the old-fashioned way. So after unscrewing a few screws and taking off\na few plastic covers, we finally got our hands on a circuit board. This is what it looks like:\n\n\n-----\n\n-----\n\n_coffee maker and its control board_\nWe can immediately see, there is one component we are already very familiar with. The\n\n`ESP8266` module. This is a very common chip that provides Wi-Fi capabilities and is\nwidely used in many devices by manufacturers as a Wi-Fi modem or even as the main CPU\nof the device. That’s not the case this time. We identified other chips that seemed important\nand came to a different conclusion.\n\n\n-----\n\n_1 – ESP8266 with AT modem firmware, 2 – STM32F05106 ARM Cortex M0 – main CPU_\n_that glues everything together, 3 – I2C EEPROM with configuration, 4 – debug ports and_\n_programming interface_\nThe main `CPU in this case, and the real heart of the whole coffee maker, is an` `ARM`\n```\nCortex M0 processor that controls all the connected gadgets (coffee grinder, coffee flap,\n\n```\nwater level sensor, hotbed heater, main heater, display, buttons and “missing carafe”\nsensor). To make it easier to understand, we came up with the block diagram of the whole\nmaker:\n\n\n-----\n\n_A block diagram of coffee machine’s main components_\nWe can see that the `ESP8266 is only used as a WiFi modem that provides WiFi`\ncapabilities to the main CPU (this could sound funny as the `ESP8266 is many times more`\npowerful and has a much more memory than the main CPU, but it’s true). Anyway, we have\nwhat we came for. Now that we know the exact type of CPU, we can download the data\nsheet and extract some basic information that will help us figure out where to begin with\ndisassembly.\n\n\n-----\n\n_basic specs as can be found on STMicroelectronics web site_\nWe know that this CPU is rudimentary and resource-limited enough that there won’t be an\noperating system which usually makes RE easier, as there is not much code to go through.\nIn this case, we used IDA (interactive disassembler) and after some trial and error attempts,\nwe loaded the binary onto the starting address `0x08004000 . Normally, the CPU starts it’s`\nexecution from a `0x08000000 address, but later we found out that at the beginning of the`\naddress space there is a second custom bootloader (a piece of code that is there to allow\nupdates of the rest of the code on chip) that takes care of the upgrade process and is a\nalways running as a safe place in the case something goes wrong during the update\nprocess. When you find yourself in the unfamiliar land of unknown firmware, you usually get\nsomething like this in IDA (that’s the tool we use a lot in our threat labs to reverse engineer\nmalware and unknown code generally):\n\n\n-----\n\nIDA environment displaying functions and strings views\nWe see a number of unnamed routines and a list of strings. Now, the real work begins. You\nhave to find which routine does what and slowly piece together how the whole thing works.\nIt’s a matter of preference, but I usually start with the strings. From a string you can usually\ndeduce what functions use the string and based on that reference, you can usually uncover\nwhat the function does. It also helps to identify the most common and most referenced\nfunctions first. Specifically in the case of IoT, a good clue could be also to identify memory\nmapped `I/O pins, so when you see reference to such memory, you know that function`\ntouches some HW component attached. Let’s skip tedious parts of analysis and let us show\nyou a few picks.\n\n\n-----\n\nUsing architecture\n\nknowledge to understand code: From address seen we deduced that this must be function\naccessing missing carafe switch, thus function being called is generic function for reading\npin and function calling will be part of ‘brew’ command\nAlthough we didn’t reverse all the functions, we got most of the important ones. We also\ndiscovered the global variables that store the state of buttons and received data over Wi-Fi,\nas well as the routines that control the display and all the gadgets. We also found the\nfunction for allocating and freeing memory, beeping, delay, etc. We found the main loop of a\nprogram that executes all the subfunctions as well as the main command routine – that is\nthe function which based on the received packet over the network performs the command.\nThis allowed us to create a list of all the remote commands that the coffee maker is able to\nperform and match them with previous research and even extend it.\n\n\n-----\n\nBy cross referencing function calls and addresses we are slowly uncovering what each\nfunction does\nAfter reversing the entire firmware, we knew exactly where every peripheral connects, how\nto control it, and all the commands that the coffee maker is able to perform. The most\ninteresting was the firmware upgrade routine itself. After a closer look into the function that\nhandles the command that induced the “update” screen, it turned out that the coffee maker\nnotes something into the eeprom memory and performs the reboot. So now it was clear that\nthe update process is handled by the bootloader which is not a part of a firmware package.\nAlso when the “update” message is on the screen, the name of the Wi-Fi changes, from\n```\n“Smarter Coffee:xx” where xx is the same as the lowest byte of the MAC address of\n\n```\nthe device. So obviously even if your coffee maker is connected to your home network\nwhen it comes to updating, it’s always done over the Wi-Fi in “Access Point” mode.\n\n\n-----\n\nspotting main function that processes all commands based on appearance of the call graph\n\nclose-up of cluster of WiFi related functions\n\nWhen we tried to reverse the update protocol we had a few different options. Since we\nknew what processor was inside, we could try to dump the whole firmware (including\nbootloader) out of the chip and reverse engineer the bootloader. We went with a more\n\n\n-----\n\nsimple approach and decided to reverse engineer the Android app and find the update part\nas it is usually easier to read decompiled Java code than CPU assembly language. It took\nus a while, but we identified and documented the whole process:\n\n_process of an update obtained by reversing the apk file_\nWhat is so surprising here is that the update procedure doesn’t use any encryption or\nsignature of the firmware. EVERYTHING is transmitted in PLAINTEXT over an\nUNSECURED WiFi connection, the only check is CRC at the end.\n\n## First update and modification\n\nNow we have all the information we need to try our first update. Using Python we\nimplemented a simple uploader, which works in two steps. First, it tries to find the coffee\nmaker’s Wi-Fi and then connects to it (by default, the coffee maker is always reachable on\n```\n192.168.4.1 port 2081 ). By sending the “start update command”, the coffee maker\n\n```\nswitches itself into the update mode.\n\n\n-----\n\nthis simple (two bytes) command\n\n_switches coffee maker into update mode_\nThe script waits for the Wi-Fi to change from `“Smarter Coffee:xx” to` `“Smarter`\n```\nCoffee Update:xx” . Once that happens, it connects again to the same address and\n\n```\nsends new firmware using the aforementioned procedure. For starters, we just sent a\nslightly updated version of the firmware, which instead of displaying “missing carafe”\ndisplayed this:\n\nSo the whole procedure of replacing the firmware takes approx. 15-25 seconds and is\ncompletely automatic.\n\n## Everything is an image here\n\nInterestingly, there is no font or textual output for the display, everything you see on screen\nis stored in the firmware as an image. So, there are, for example, images for the number of\ncups (1-12). The images are black and white and the encoding is pretty simple, as you can\nsee in the following diagram:\n\n\n-----\n\nblack & white image encoding\n\n## Creating modified firmware\n\nNow we have everything we need to create our own modified firmware. Originally, we\nwanted to prove the fact that this device could mine cryptocurrency, considering the CPU\nand architecture it is certainly doable, but at a speed of `8MHz it doesn’t make any sense as`\nthe produced value of such a miner would be negligible.\n\nWe decided to turn the coffee maker into a ransomware machine where a certain trigger\ninitiates the ransom message. It looks completely innocent and operates normally until the\ntrigger is hit by an attacker making it even more surprising.\n\nTo do so, We hijacked one of the commands that originally served to connect the maker to\nthe network so that when a user tries to connect the machine to home network a user can\ntrigger the ransom behavior themself unintentionally.\n\nWe used the unused memory space at the very end of the firmware to create the malicious\ncode. By using the ARM assembler we created ransomware that when triggered renders\nthe coffee maker unusable and asks for ransom, while at the same time turning on the\nhotbed, water dispensing heating element, permanently and spinning up the grinder,\nforever, displaying the ransom message and beeping. We thought this would be enough to\nfreak any user out and make it a very stressful experience. The only thing the user can do\nat that point is unplug the coffee maker from the power socket.\n\n\n-----\n\n_snippet of “malicious”_\n\n\n_code: this is the part that displays ransom on the display_\nHere you can see it in action:\n\n## Plan(n/t)ing attack vectors\n\n\n-----\n\nSo now that we proved it s possible to change the coffee maker s firmware without touching\nit, let’s have a look at how you can get your hands on the coffee maker as an attacker. What\npossibilities do we have and can we overcome the “security” measure of the newer\nfirmware version, where the device owner is required to press the start button before the\nupdate happens.\n\n## Attack vector 1: Passer-by.\n\nIn this approach we need physical access to the device to initiate the update.\n```\n+ Easy to perform\n- Need physical proximity, the coffee maker must be in an unconfigured state (not\n\n```\nconnected to a home network)\n\nThis attack option probably has the least impact. To perform it, you need access to the\ndevice or need to at least be in range of its Wi-Fi signal. If the device is already connected\n[to the home network, you can use a deauthentication attack as the device is also vulnerable](https://en.wikipedia.org/wiki/Wi-Fi_deauthentication_attack)\nto “default-fallback to Wi-fi Access Point mode”, when it’s unable to connect to a pre-set\nWiFi network. Let’s look at the scheme of this attack:\n\nThe attacker issues an “update start” command and then just after that, the Wi-Fi changes\nits name to “Smarter Coffee Update:xx” . The attacker then starts sending modified firmware\nto the machine.\n\n## Attack vector 2a: Breaking the perimeter.\n\nIn this scenario we use the network to get to the coffee maker.\n```\n+ Can be done remotely\n- Need to break into the network first, and need a Wi-Fi enabled device/router inside the\n\n```\nnetwork, if the coffee machine is running on a newer firmware version, the user needs to\nconfirm the update by pressing the button.\n\nThis is a very common scenario where an attacker first breaks into the home network. The\ncrucial part of this attack is to find a device via which you can control the Wi-Fi. An ideal\ncandidate is, of course, a Wi-Fi router.\n\nAs the coffee maker always turns itself into a Wi-Fi access point while upgrading its\nfirmware, you need a device inside the network you can use to connect to it. This is usually\na pretty common function of any router, so for a short time, you can easily reconfigure the\nrouter to be a client, instead of a Wi-Fi access point. Because the update process is so\nshort, the outage should be hardly noticeable. Some routers are even capable of being a\nclient and access point at the same time using a single radio.\n\n\n-----\n\n## Attack vector 2b: Breaking the perimeter.\n\nThis attack is a variant of the previous attack vector, the only difference is that it fools the\nuser into pressing the update button without any concerns.\n```\n+ Reach, overcome the user interaction problem\n- Requires more planning and access to the network, not an instant effect\n\n```\nThe novelty here is that in the exact moment when the app asks for the version of the\nfirmware, the attacking script (running on the router) just spoofs the response and sends\nback a response indicating the coffee maker firmware is out-of-date, which leads to a\nprompt in the app that it needs to be updated. The rest is easy – you can now replace the\nfirmware as it flows from the app to the coffee maker.\n\nThis attack could be also performed in a “passer-by” manner, when you have proximity to\nthe coffee maker and it’s not joined to a network.\n\n## Attack vector 3: Social engineering. An android app as a mediator.\n\nIn this attack scenario, we trick the user into downloading a fake app to control the coffee\nmaker.\n```\n+ No interaction with the network or protocol needed\n- Social engineering, outcome is not guaranteed\n\n```\nThis is a classic attack scenario. You just need to replace the firmware inside the coffee\nmakers official companion Android app and re-sign it with a stolen certificate and try to push\nit into the Google Play Store or any other third party app store. You can use any social\nengineering technique to push the user into downloading the fake app, as there is no\nsignature in the firmware, the coffee maker gladly accepts it. Basically, any form of creating\na fake version of the app and pushing the user to install it works.\n\n## Found vulnerabilities and issues\n\nDuring our analysis, we found several weaknesses and one critical vulnerability. As you can\nalready imagine, the most serious vulnerability is the one that enables an attack to replace\nthe coffee maker’s firmware remotely.\n\nThere are differences between firmware versions, the oldest one didn’t need any user\ninteraction to be updated, whereas newer versions of the coffee maker’s firmware ask the\nuser to press the “start” button on the machine to begin the update. However, even if it\nrequires the user to press the button before the update, you can still use social engineering\nattacks by repeatedly sending the start update packet, which will cause the user to see the\nsame prompt over and over, even when pressing “cancel”.\n\n\n-----\n\nBecause the update happens over an unencrypted network, you can also spoof the\nfirmware version and make the companion app believe the coffee maker actually needs to\nupdate and then inject malicious code. In this case users will likely happily press update.\n\nAnother weakness is the possibility to permanently dissociate the device from the home WiFi network. Even if it is already connected to a secure Wi-Fi network you can disconnect the\n[machine from the network by using a deauthentication attack. Strangely enough, it will](https://en.wikipedia.org/wiki/Wi-Fi_deauthentication_attack)\nmake no attempt to reconnect, so it loses connection forever, or at least until someone\nresets it. If you keep deauthing the device during its restart, it switches itself back into\n“Access Point” mode with open Wi-Fi waiting for the attacker to connect.\n\n## The disclosure and fix\n\nEven if we were to contact the vendor, we would likely get no response. According to their\nwebsite, this generation of coffee maker is no longer supported. So users should not expect\na fix.\n\n## Final thoughts\n\nAre you still interested in a smart coffee maker after all this? As shown on the map below\n(source: [wigle) there are nearly](https://wigle.net/) `570 smart coffee makers from this vendor out there`\nthat have not been set up. That means the smart functionalities are not being used by these\n```\n570 machines. However, the owners of these machines have unintentionally made it\n\n```\neasier to hack their devices, as each of these coffee makers makes itself an access point to\nwhich anyone in range can connect and misuse.\n\nAdditionally, this case also demonstrates one of the most concerning issues with modern\nIoT devices: “The lifespan of a typical fridge is 17 years, how long do you think\n**vendors will support software for its smart functionality?”. Sure, you can still use it**\neven if it’s not getting updates anymore, but with the pace of IoT explosion and bad attitude\nto support, we are creating an army of abandoned vulnerable devices that can be misused\nfor nefarious purposes such as network breaches, data leaks, ransomware attack and\nDDoS.\n\n\n-----\n\nUnconfigured Smarter Coffee machines across the globe\nAs we said at the very beginning, in the security domain we used to consider software as an\nuntrusted part of the ecosystem, while considering the hardware as secure and trusted.\nMore and more often, we see how this trust is being broken. Unfortunately, many vendors\nmake firmware attacks more viable by just leaving security behind and making it wide open\nto attackers. For cybercriminals this opens and the whole new world of attack surfaces to\nabuse. It may not be that easy to write and replace firmware, but the advantages of\nstealthiness and persistence you can achieve are just so tempting.\n\nWe live in a world where things talk to things, and where the number of smart things is\nslowly outnumbering the number of computers. These devices, for the most part, have no\nscreen and can therefore mask malicious activities running in the background from their\nowners.\n\n## IoCs, CVE + artifacts\n\n**CVE-2020-15501 Smarter Coffee Maker before 2nd generation allows firmware**\nreplacement without authentication or authorization. User interaction is required to press a\nbutton. `NOTE: This vulnerability only affects products that are no longer`\n```\nsupported by the maintainer.\n\n```\n**Distinct firmware images**\n\n\n-----\n\nSHA256\n```\n 1eff6702b158b1554284f3ef6eb9d05748f43ba353d60954f21c6f20fd71e6ce\n 650a7bc7a55162988c77df34235c8e87eda9c8e2fcecd72b74c5f69e3edd088c\n\n```\n**Github repository with firmware images, IDA datbase, uploader**\n\n[Avast IoC repository](https://github.com/avast/ioc/tree/master/SmarterCoffee)\n\n**References to similar research:**\n\n[Reversing the Smarter Coffee IoT Machine Protocol to Make Coffee Using the Terminal](https://t.co/ZwqZnYwiFk?amp=1)\n\n[https://www.pentestpartners.com/security-blog/another-unsmart-smarter-app/](https://www.pentestpartners.com/security-blog/another-unsmart-smarter-app/)\n\n[github.com/Tristan79/iBrew(opens in a new tab)](https://github.com/Tristan79/iBrew)\n\n[https://www.pentestpartners.com/security-blog/hacking-a-wi-fi-coffee-machine-part-1/](https://www.pentestpartners.com/security-blog/hacking-a-wi-fi-coffee-machine-part-1/)\n\n[Tagged asanalysis,](https://decoded.avast.io/tag/analysis/) [cve,](https://decoded.avast.io/tag/cve/) [hardware,](https://decoded.avast.io/tag/hardware/) [reversing,](https://decoded.avast.io/tag/reversing/) [vulnerability](https://decoded.avast.io/tag/vulnerability/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-09-25 - The Fresh Smell of ransomed coffee.pdf"
    ],
    "report_names": [
        "2020-09-25 - The Fresh Smell of ransomed coffee.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536137,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653706002,
    "ts_modification_date": 1653706002,
    "files": {
        "pdf": "https://archive.orkl.eu/fc38bead62b7114951cd20fd1a6cda58847d4671.pdf",
        "text": "https://archive.orkl.eu/fc38bead62b7114951cd20fd1a6cda58847d4671.txt",
        "img": "https://archive.orkl.eu/fc38bead62b7114951cd20fd1a6cda58847d4671.jpg"
    }
}