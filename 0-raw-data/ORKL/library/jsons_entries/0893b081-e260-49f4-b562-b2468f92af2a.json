{
    "id": "0893b081-e260-49f4-b562-b2468f92af2a",
    "created_at": "2023-01-12T15:08:59.975385Z",
    "updated_at": "2025-03-27T02:16:39.979657Z",
    "deleted_at": null,
    "sha1_hash": "8aa4954dedb9e478d1f92d0bdb64d781a17e1c9d",
    "title": "2020-12-22 - [TrendMicro CTF 2020 Finals] Wildcard-2- Yara exfiltration",
    "authors": "",
    "file_creation_date": "2022-05-29T01:33:30Z",
    "file_modification_date": "2022-05-29T01:33:30Z",
    "file_size": 100438,
    "plain_text": "# [TrendMicro CTF 2020 Finals] Wildcard-2: Yara exfiltration\n\n**ubcctf.github.io/2020/12/tmctf-2020-finals-wildcard2/**\n\n22 Dec 2020 by - [Arctic Wyvern](https://ubcctf.github.io/authors/rctcwyvrn/)\n\nMaple Bacon qualified and participated in the TrendMicro CTF finals and placed a solid 5th\nplace. One of the challenges used a popular malware analysis/antivirus tool called `yara`\nwhich was quite fun, so here’s a writeup.\n\nNote: I almost never touch these sorts of binary problems, but I have some experience with\nyara so I took a stab at it. Bear with me when I explain obvious things :)\n\n## A quick primer on yara\n\nWhat is [yara? Yara is a tool developed by VirusTotal, a malware detection service which](https://github.com/VirusTotal/yara)\ncombines some custom analysis tools with many many third party antivirus tools.\n\nYara is a static analysis tool that works sorta like regex, but with the goal of identifying\nmalware in mind. So like regex, yara lets you write rules and will tell you if a file matches the\ngiven rule.\n\nHere’s an example rule, meant for detecting the `silent_banker malware family`\n```\nrule silent_banker : banker\n{\n  meta:\n    description = \"This is just an example\"\n    threat_level = 3\n    in_the_wild = true\n  strings:\n    $a = {6A 40 68 00 30 00 00 6A 14 8D 91}\n    $b = {8D 4D B0 2B C1 83 C0 27 99 6A 4E 59 F7 F9}\n    $c = \"UVODFRYSIHLNWPEJXQZAKCBGMT\"\n  condition:\n    $a or $b or $c\n}\n\n## The challenge\n\n```\nThe challenge is no longer accessible, so some of the details may be a bit wrong, but here\nare the important details\n\n\n-----\n\nThe challenge presents an api where we can submit a rule file. The server then\ngenerates a new binary, runs the given rule, and returns the result (hit/no hit)\nThere are limitations on the rule files we can send:\n\nThere can only be one rule in the file\nIt must be a yara text file, not a compiled one\nThe file must be less than 5kb\n\nThe binary generation works by filling in the following template with garbage and the\ngold_dust variable\n\n\n-----\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n// GARBAGE, Encoded FLAG and KEY\nchar gold_dust[] = {}; // <-- gets filled before compilation\n// <Garbage functions 1>\nchar *decode(char *enc, int enc_size, char *key, int key_size)\n{\n  char *dec;\n  dec = (char *)malloc(enc_size + 1);\n  if (!dec)\n  {\n    return NULL;\n  }\n  for (int i = 0; i < enc_size; i++)\n  {\n    dec[i] = enc[i] ^ key[i % key_size];\n  }\n  dec[enc_size] = 0;\n  return dec;\n}\n// <Garbage functions 2>\nint main(int argc, char **argv)\n{\n  char *flag;\n  // <Garbage code>\n  flag = decode(gold_dust + <flag offset>, <flag len>, gold_dust + <key offset>,\n<key len>);\n  if (!flag)\n  {\n    return -1;\n  }\n  printf(\"FLAG is TMCTF{ %s }\\n\", flag);\n  free(flag);\n  return 0;\n}\n// <Garbage functions 3>\n\n```\nwhere garbage functions are generated with\n\n\n-----\n\n```\ndef generate_garbage_function(label, count):\n  template = \"void garbage_func_%s_%d() { return; }\"\n  return '\\n'.join([template % (label, n) for n in range(count)])\n\n```\nand garbage code is generated with\n```\ndef generate_garbage_code(min_size, max_size):\n  count = generate_random_num(min_size, max_size)\n  return '__asm__(\"{}\");'.format('nop;'*count)\n\n```\nThe most important part for us is the `gold_dust buffer, where the flag will be encoded. It’s`\ngenerated by:\n\n1. Generating a random key, with random length\n2. Encrypting the flag with repeating XOR\n3. Creating a random buffer with a length between 256 and 512 kb\n4. Putting encrypted flag and key at random offsets in the buffer\n```\ndef encode_flag(flag, key):\n  return bytes([flag[i] ^ key[i%len(key)] for i in range(len(flag))])\ndef generate_gold_dust(garbage, flag, flag_offset, key, key_offset):\n  flag_size = len(flag)\n  key_size = len(key)\n  gold_dust = bytearray(garbage)\n  gold_dust[flag_offset: flag_offset+flag_size] = flag\n  gold_dust[key_offset: key_offset+key_size] = key\n  return bytes(gold_dust)\n\n```\nNow that we have all that set up, you might be wondering ok what else? We can submit yara\nrules to random binaries, there has to be something else right?\n\nNo, there’s nothing else. We need to exfiltrate the flag just from what’s been mentioned.\n\nA flag that is only ever encrypted and cryptographically unrecognizable from the buffer\nthat surrounds it and the key.\nExfiltrating information one bit at a time.\nThere’s no information kept between two rule runs, with completely new randomly\ngenerated binaries for each run.\n\nAt this point it was 2am, so I went to bed thinking this challenge had to be impossible.\n\nHere’s one of the generated binaries (though I messed with the flag encoding a bit so don’t\n[try to actually run the solution on it) tortoise.c](https://ubcctf.github.io/assets/code/tmctf2020-finals/wildcard2/tortoise.c)\n\n## The solution\n\n\n-----\n\nMy first instinct was to try and figure out a way of guessing the flag and then generating a\nrule that pattern matches against the gold_dust, but the massive size, randomized data, and\nthe fact that the flag is encrypted made that approach completely impossible.\n\nHere’s a better way of exfiltrating the flag, one byte at a time\n\n1. Figure out how to read the ith byte of the plaintext flag\n2. Generate 255 rules where it only matches if the ith byte matches chr(b)\n3. Submit them all, and see which one hits\n\nSo steps 2 and 3 are easy, step 1 is the hard part.\n\nHow can we read the unencrypted flag? To read the first byte of the flag we need the\nfollowing\n\nThe address of the flag in the gold_dust\nThe address of the key in the gold_dust\n\n## How can we get these two addresses?\n\nIn the main function we see that the generated binaries have a call to `decode, which has`\nthe two arguments that we want. How can we find where the call to decode is?\n\nWell we have a very helpful set of “garbage code” right before the call to decode, so we\nknow that the assembly in that area must be\n```\n90 - nop\n90 - nop\n90 - nop\n... <hundreds of nops>\n90 - nop\n90 - nop\nC7 44 24 0C <key len>  - loading the key_size arg\nC7 44 24 08 <key_addr>  - loading the key arg\nC7 44 24 04 <flag len>  - loading the flag_size arg\nC7 44 24 <flag_addr>   - loading the flag arg\nE8 <relative addr>    - call to decode\n\n```\nSo we can make a yara string `$nops = {90 90 90 90 90 90 90 90 90 90 90 90 90 90`\n```\n90 90 C7 44 24 0c}, which will match this pattern\n\n```\nWith the yara `@ and` `[1] operators we can get the address where the rule matched for the`\nfirst time. Since this pattern is so distinct we can basically guarantee that this rule will only hit\nat the desired location. There are 16 `90 ’s in the rule, so` `@nops[1] + 16 will be the start`\nof the argument loading. Using the `uint32 yara function we can read a 4 byte address`\nfrom the binary at a given address. So to read the addresses we can do\n```\nuint32(@nops[1] + 16 + 8 + 8 + 8 + 3)\n\n```\n\n-----\n\nfor the flag address and\n```\nuint32(@nops[1] + 16 + 8 + 4) \n\n```\nfor the key address\n\nNow you would think we could then call `uint8(uint32(@nops[1] + 16 + 8 + 8 + 8 +`\n```\n3)) to read the first encrypted byte, but that doesn’t work because the address in the\n\n```\nargument is a virtual address. It’s the address where `gold_dust variable in` `.data will be`\nloaded, not the raw address where the actual data is in the binary.\n\nThe binary will load `.data to the executable’s` `image_base + the relative virtual address`\nfor `.data, so what we can do is take our virtual address for` `flag and` `key, subtract the`\nimage base and subtract the RVA, leaving just the `flag_offset and` `key_offset . Then`\nwe can just add on the raw offset to `.data in the binary and we get an address which we`\ncan read flag/key data from. This can be easily done with the “pe” module from module,\nwhich pulls out the `image_base, RVA of` `.data, and the raw data offset.`\n\nSo with that we can read a single byte at those two locations, xor them, and then generate\nrules that check if that result is a given byte. Then all we need to do is generate all those\nrules for each index of the flag.\n\nWe can exfiltrate the flag length by sending rules to check the value of `uint32(@nops[1] +`\n```\n16 + 8 + 8 + 4), which is the flag_size argument for decode . Remember we also\n\n```\nneed to modulo cycle the key using the `key_size variable, which we can read using`\n```\nuint32(@nops[1] + 16 + 4) .\n\n```\nHere is the final rule template\n\n\n-----\n\n```\ntemplate  import pe \nrule nopss {\n  strings:\n    $nops = {90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 C7 44 24 0c}\n  condition:\n    %s == \n      uint8(\n        uint32(@nops[1] + 16 + 8 + 8 + 8 + 3) \n        - pe.sections[1].virtual_address \n        - pe.image_base + pe.sections[1].raw_data_offset\n        + %d\n      ) ^ \n      uint8(\n        uint32(@nops[1] + 16 + 8 + 4) \n        - pe.sections[1].virtual_address \n        - pe.image_base + pe.sections[1].raw_data_offset\n        + (%d %% uint32(@nops[1] + 16 + 4))\n      )\n}\"\"\"\nflag_size = 10\nfor i in range(flag_size):\n  for guess in range(32,127):\n    ch = chr(guess)\n    rule = template % (str(hex(guess)), i, i)\n\n```\nAnd boom, flag! `TMCTF{16d1eb767f}`\n\nYara ends up being used as a simple string/hex search tool in the rare CTF challenge where\nit appears, but this one was definitely a lot more complicated and fun to figure out. A cool\nchallenge for sure and one that shows off more of what yara can do.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-22 - [TrendMicro CTF 2020 Finals] Wildcard-2- Yara exfiltration.pdf"
    ],
    "report_names": [
        "2020-12-22 - [TrendMicro CTF 2020 Finals] Wildcard-2- Yara exfiltration.pdf"
    ],
    "threat_actors": [
        {
            "id": "2864e40a-f233-4618-ac61-b03760a41cbb",
            "created_at": "2023-12-01T02:02:34.272108Z",
            "updated_at": "2025-03-27T02:02:10.209072Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "ETDA:WildCard",
            "tools": [
                "RustDown",
                "SysJoker"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "256a6a2d-e8a2-4497-b399-628a7fad4b3e",
            "created_at": "2023-11-30T02:00:07.299845Z",
            "updated_at": "2025-03-27T02:00:03.257794Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "MISPGALAXY:WildCard",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536139,
    "ts_updated_at": 1743041799,
    "ts_creation_date": 1653788010,
    "ts_modification_date": 1653788010,
    "files": {
        "pdf": "https://archive.orkl.eu/8aa4954dedb9e478d1f92d0bdb64d781a17e1c9d.pdf",
        "text": "https://archive.orkl.eu/8aa4954dedb9e478d1f92d0bdb64d781a17e1c9d.txt",
        "img": "https://archive.orkl.eu/8aa4954dedb9e478d1f92d0bdb64d781a17e1c9d.jpg"
    }
}