{
    "id": "3392a018-3d5f-4dd1-a928-210c0d21795e",
    "created_at": "2023-01-12T15:05:06.296118Z",
    "updated_at": "2025-03-27T02:05:31.428963Z",
    "deleted_at": null,
    "sha1_hash": "2ec90d5c569c05e743a62a279d671d489705d208",
    "title": "2016-08-30 - Pythons and Unicorns and Hancitor…Oh My! Decoding Binaries Through Emulation",
    "authors": "",
    "file_creation_date": "2022-05-29T01:28:34Z",
    "file_modification_date": "2022-05-29T01:28:34Z",
    "file_size": 1311572,
    "plain_text": "# Pythons and Unicorns and Hancitor…Oh My! Decoding Binaries Through Emulation\n\n**researchcenter.paloaltonetworks.com/2016/08/unit42-pythons-and-unicorns-and-hancitoroh-my-decoding-binaries-**\nthrough-emulation/\n\nJeff White August 30, 2016\n\nBy [Jeff White](https://unit42.paloaltonetworks.com/author/jeff-white/)\n\nAugust 30, 2016 at 1:20 PM\n\n[Category: Malware,](https://unit42.paloaltonetworks.com/category/malware-2/) [Unit 42](https://unit42.paloaltonetworks.com/category/unit42/)\n\nTags: [hancitor,](https://unit42.paloaltonetworks.com/tag/hancitor/) [LuminosityLink,](https://unit42.paloaltonetworks.com/tag/luminositylink/) [Microsoft Word,](https://unit42.paloaltonetworks.com/tag/microsoft-word/) [Python,](https://unit42.paloaltonetworks.com/tag/python/) [shellcode,](https://unit42.paloaltonetworks.com/tag/shellcode/) [Unicorn Engine,](https://unit42.paloaltonetworks.com/tag/unicorn-engine/) VB\nDropper, [WildFire,](https://unit42.paloaltonetworks.com/tag/wildfire/) [XOR key](https://unit42.paloaltonetworks.com/tag/xor-key/)\n\nThis post is also available in: 日本語 [(Japanese)](https://unit42.paloaltonetworks.jp/unit42-pythons-and-unicorns-and-hancitoroh-my-decoding-binaries-through-emulation/)\n\nThis blog post is a continuation of my previous post, VB Dropper and Shellcode for Hancitor\nReveal New Techniques Behind Uptick, where we analyzed a new Visual Basic (VB) macro\ndropper and the accompanying shellcode. In the last post, we left off with having successfully\nidentified where the shellcode carved out and decoded a binary from the Microsoft Word\ndocument.\n\nOften when analysts are faced with an embedded payload for which they want to write a\ndecoder, they simply re-write the assembly algorithm in their language of choice and process\nthe file. The complexity of these algorithms varies when attempting to translate from machine\n\n\n-----\n\ncode to a higher-level language. It can be quite frustrating at times, depending on the\namount of coffee you’ve had and complexity of the algorithms.\n\nIn this post, I’ll show how we can use an attacker’s own decoding algorithm combined with\nCPU emulation to decode or decrypt payloads fairly easily by simply reusing the assembly in\n[front of us. Specifically, I’ll be focusing on using the Unicorn Engine module in Python to run](http://www.unicorn-engine.org/)\nthe attacker’s decoding functions within an emulated environment to extract our encoded\npayloads. Our end goal is to identify the command and control (C2) servers being used by\nthe final Hancitor payload by running our Python script against the Microsoft Word document.\n\nNow, you may ask, why even worry about this to begin with? In the last post we just let the\nprogram run and the payload was written to disk for easy retrieval, so why bother? The main\nanswer to that is bulk-analysis automation. If we can write a program that we can point at a\ndirectory full of documents, then we can quickly extract embedded payloads for C2 extraction\nand parsing to form a more holistic view of what we’re dealing with. An example of such bulk\nanalysis was witnessed earlier this year in July when we looked at a large sample set of\nLuminosityLink malware samples.\n\n## Decoding Routines\n\nAs a reminder, in the last blog post we were working with the following sample:\n\n03aef51be133425a0e5978ab2529890854ecf1b98a7cf8289c142a62de7acd1a\n\nWe’ll continue where we left off after identifying the decoding routine, as seen in figure 1. The\nfunction at loc_B92 added 0x3 to each byte and uses 0x13 to XOR the result. Once every\nbyte in the embedded binary has been processed, it pushes the location of the embedded\nbinary to the stack and calls function sub_827.\n\n\n-----\n\n_Figure 1 Start of decoding routine_\n\nWithout going too far into detail on the decoding routine, know that there are five parts to it,\nand that each one manipulates the bytes in some way before the overall function ends and\nour payload is decoded.\n\n_Figure 2 Proximity view of decoding functions in IDA_\n\n\n-----\n\nWhat we re effectively going to do is copy the bytes from sub_8A6, sub_827, sub_7E7,\nsub_7CA, and sub_7D7. These are the core functions that handle all of the decoding. In\naddition to this, we’ll need our embedded payload, which can be located in the Word\ndocument through the magic header of “POLA” as discussed in the previous blog.\n\nOnce we have the copied bytes, we’ll setup our emulation environment, adjust our assembly,\nand run our own shellcode to retrieve the payload. In the context of this blog, I’m just going to\nrefer to the x86 instructions as shellcode to keep things straightforward.\n\nStarting with offset 0xB92, we’ll copy the bytes for the two blocks, ending just after our call\nsince the payload will be decoded by that point.\n\n_Figure 3 Decoding function and associated bytes_\n\nNext we’ll copy the bytes from sub_827, which are all of the bytes from offset 0x827 to\n0x8A5.\n\n_Figure 4 Additional decoding functions and associated bytes_\n\nLast, we’ll collect the bytes from the three smaller functions. If you note their location, you\ncan see they are contiguous. Keeping the bytes in order is convenient but not necessary. If\nthey don’t line up, you’ll simply need to adjust the operands for the calls or jumps so that they\ngo where they should.\n\n\n-----\n\n_Figure 5 Additional decoding functions and associated bytes_\n\nOnce all of the bytes have been saved, we can write them to a file and open it up in a\ndisassembler to see what issues we need to correct, if any.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# sub_8A6\nsc = b'\\x8A\\x04\\x0F\\x04\\x03\\x34\\x13\\x88\\x04\\x0F\\x41\\x81\\xF9\\xAC\\x3A\\x01\\x\n00\\x72\\xED\\x57\\xE8\\x7C\\xFC\\xFF\\xFF\\x83\\x7D\\xFC\\x01'\n# sub_7CA\nsc += b'\\x6B\\xC0\\x06\\x99\\x83\\xE2\\x07\\x03\\xC2\\xC1\\xF8\\x03\\xC3'\n# sub_7D7\nsc +=\nb'\\x6B\\xC0\\x06\\x25\\x07\\x00\\x00\\x80\\x79\\x05\\x48\\x83\\xC8\\xF8\\x40\\xC3'\n<em># sub_7E7</em>\nsc +=\nb'\\x8D\\x48\\xBF\\x80\\xF9\\x19\\x77\\x07\\x0F\\xBE\\xC0\\x83\\xE8\\x41\\xC3\\x8D\\x\n48\\x9F\\x80\\xF9\\x19\\x77\\x07\\x0F\\xBE\\xC0\\x83\\xE8\\x47\\xC3\\x8D\\x48\\xD0\\x\n80xF9\\x09\\x77\\x07\\x0F\\xBE\\xC0\\x83\\xC0\\x04\\xC3\\x3C\\x2B\\x75\\x04\\x6A\\x\n3E\\x58\\xC3\\x3C\\x2F\\x75\\x04\\x6A\\x3F\\x58\\xC3\\x33\\xC0\\xC3'\n# sub_827\nsc +=\nb'\\x55\\x8B\\xEC\\x51\\x51\\x8B\\x45\\x08\\x83\\x65\\xFC\\x00\\x89\\x45\\xF8\\x8A\\x\n00\\x84\\xC0\\x74\\x68\\x53\\x56\\x57\\xE8\\xA3\\xFF\\xFF\\xFF\\x8B\\xD8\\x8B\\x45\\x\nFC\\xE8\\x7C\\xFF\\xFF\\xFF\\x8B\\x4D\\xF8\\x8D\\x14\\x08\\x8B\\x45\\xFC\\xE8\\x7B\\x\nFF\\xFF\\xFF\\x8B\\xF8\\x8B\\xF0\\xF7\\xDE\\x8D\\x4E\\x08\\xB0\\x01\\xD2\\xE0\\xFE\\x\nC8\\xF6\\xD0\\x20\\x02\\x83\\xFF\\x03\\x7D\\x09\\x8D\\x4E\\x02\\xD2\\xE3\\x08\\x1A\\x\nEB\\x15\\x8D\\x4F\\xFE\\x8B\\xC3\\xD3\\xF8\\x8D\\x4E\\x0A\\xD2\\xE3\\x08\\x02\\xC6\\x\n42\\x01\\x00\\x08\\x5A\\x01\\xFF\\x45\\x08\\x8B\\x45\\x08\\x8A\\x00\\xFF\\x45\\xFC\\x\n84\\xC0\\x75\\x9E\\x5F\\x5E\\x5B\\xC9\\xC3'\n\n\nLooking at our shellcode, only one major issue appears, which is the initial call to the\ndecoding function being at a different address.\n\n\n-----\n\n_Figure 6 Broken call within shellcode_\n\nAs we want to call to our previous function sub_827, which is at the end of our shellcode, we\ncan adjust this call to point to the start of that function. Looking at our code in a hex editor,\nthe start of the function is exactly 97 bytes (0x61) into our shellcode, so we can change the\ninstruction 0xE87CFCFFFF to 0xE861000000.\n\n_Figure 7 Correcting the previously broken call_\n\nNext, we can validate our change worked as expected within the disassembler and that our\nfunctions are now all correctly linked.\n\n_Figure 8 Validating correction of call_\n\n## Embedded Payload\n\n\n-----\n\nWe know that our embedded payload address is located on the EDI register that gets\npushed onto the stack through our previous dynamic analysis. For the initial validation of this\nmethod, we’ll go ahead and manually copy the bytes, starting with the magic header of\n“POLA” and a size of 0x13AAAC bytes, to our Python script. At the end of the blog, I’ll\ninclude a full script that will automatically extract this binary from the Word Document.\n\n\n1\n2\n3\n\n\n# POLA 0x504F4C41\nencoded_binary =\nb'\\x50\\x4F\\x4C\\x41\\x08\\x00\\xFF\\xFF\\xAC\\x3A\\x01[truncated]’\n\n\n## Enter the Unicorn\n\nAs we now have all of the data we need to decode the binary, the last step for this part is to\nbuild the emulation environment for our code to run on. To accomplish this, I’ll use the open[source Unicorn Engine.](http://www.unicorn-engine.org/)\n\nThe first thing we’ll want to do is assign the address space we’ll be working within, along with\ninitializing Unicorn for the architecture we want to emulate (x86), and map some memory to\nuse. Next we’ll write our shellcode and encoded binary to our memory space and initialize\nsome values. Finally, we’ll output the decrypted data to STDOUT.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nADDRESS = 0x1000000\nmu = Uc(UC_ARCH_X86, UC_MODE_32)\nmu.mem_map(ADDRESS, 4 * 1024 * 1024)\n\n# Write code to memory\nmu.mem_write(ADDRESS, X86_CODE32)\n# Start of encoded data + offset to binary, pushed to Stack at\nstart\nmu.reg_write(UC_X86_REG_EDI, 0x10000F9 + 0x0C)\n# Initialize ECX counter to 0\nmu.reg_write(UC_X86_REG_ECX, 0x0)\n# Initialize Stack for functions\nmu.reg_write(UC_X86_REG_ESP, 0x1300000)\n\nprint \"Encrypt: %s\" % mu.mem_read(0x10000F9,150)\nmu.emu_start(ADDRESS, ADDRESS + len(X86_CODE32))\nprint \"Decrypt: %s\" % mu.mem_read(0x10000F9,150)\n\n\n_Figure 9 Successful decoding_\n\nSuccess! We can write that section of memory to a file and see what we have.\n\n\n-----\n\n1\n2\n3\n\n\nf = open(\"demo.exe\", \"w\")\nf.write(mu.mem_read(0x10000F9 + 0x0C, 0x13AAC))\nf.close()\n\n\n_Figure 10 Decoded binary properties_\n\nUnfortunately we find ourselves with a packed binary that may have our actual Hancitor\nsample, so we’ll need to try and decode yet another payload.\n\n\n-----\n\n## Attack of the Binaries\n\nThis binary has a fair amount of functions and code, but very early on we see the binary\nlookup the address for the same API we discussed in our earlier blog post,\nRtlMoveMemory(), and then copy what we presume is our encoded payload.\n\n_Figure 11 RtlMoveMemory() being called_\n\n_Figure 12 Encoded payload_\n\nContinuing to debug the program, just three instructions later it returns to what looks like our\nnext decoding routine.\n\n\n-----\n\n_Figure 13 Decoding function_\n\nLetting these blocks complete a few times validates we’re in the right spot, as we quickly\nidentify the MZ executable header.\n\n_Figure 14 Validation of decoding_\n\nWe’ve now found the location of the encoded binary, due to RtlMoveMemory(), and the\nlocation of our function that we need to emulate.\n\n## Function Copying\n\nAnalyzing this function, it’s much less complex than the last one, but takes a different\napproach of iterating over a 12-byte key, located at 0x40743C in our example, and using it to\nXOR the encoded payload.\n\n\n-----\n\n_Figure 15 12-byte XOR key_\n\nWe’ll follow the same methodology as previous to add it into our program.\n\nStarting at loc_406442, we’ll copy all of the bytes for the three blocks in the picture below,\nwhich is the decoding loop.\n\n_Figure 16 Decoding loop and associated bytes_\n\nNext we’ll copy the XOR key and encoded payload into our script and build a test file so that\nit follows the following order of operation:\n\nshellcode -> key -> payload\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# loc_406442\nsc =\nb'\\x85\\xC9\\x7C\\x29\\x8B\\x35\\x40\\x90\\x40\\x00\\xB8\\x67\\x66\\x66\\x66\\xF\n7\\xE9\\xC1\\xFA\\x02\\x8B\\xC2\\xC1\\xE8\\x1F\\x03\\xC2\\x8D\\x04\\x80\\x03\\xC0\n\\x8B\\xD1\\x2B\\xD0\\x8A\\x82\\x3C\\x74\\x40\\x00\\x30\\x04\\x0E\\x41\\x3B\\x0D\\\nx4C\\x90\\x40\\x00\\x72\\xCA'\n# XOR Key\nsc += b'\\x48\\x45\\x57\\x52\\x54\\x57\\x45\\x57\\x45\\x54\\x48\\x47'\nencoded_binary = b'\\x05\\x1F\\xC7\\x52\\x57\\x57\\x45\\x57[truncated]’\n\n\nLooking at the code in the disassembler, we can tell there are a few values we’ll have to prep\nbefore we can make this code run in our emulated environment. Specifically, we’ll need to\nedit two MOV instructions and a CMP instruction that reference locations that don’t exist in\nour code.\n\n\n-----\n\nBased on our dynamic analysis, we know that the lpBuffer is a pointer to the address of the\nencoded payload, so we can change this instruction to move the starting location, where our\npayload will reside, into the ESI register. The current instruction is referencing an address in\nthe data segment that holds the address to the payload. We’ll replace it with an immediate\nMOV instruction by changing 0x8B3540904000 to 0xBE42000190, where 0x100042 is the\nstart of our buffer. Since we changed the opcode, the length of our new instruction was one\nbyte short and I padded it with a 0x90 – NOP to keep everything aligned.\n\n_Figure 17 Change location of payload_\n\nThe first MOV is for our encoded payload, the second MOV is for our XOR key. The second\nMOV uses a different opcode that plays more favorably to our needs, so we’ll simply change\nthe existing address to the location of the key by modifying 0x8A823C744000 to a value of\n0x8A8236000001.\n\n_Figure 18 Change location of the XOR key_\n\nThe final item to change is the compare instruction. Based off dynamic analysis, we know it’s\nlooking for the value 0x5000, so we’ll change the opcode to support an immediate operand\nand modify 0x3B0D4C904000 to a value of 0x81F900500000.\n\n_Figure 19 Hard-set compare value_\n\n## Emulation\n\n\n-----\n\nTo set up our environment for this sample, the only value we need to worry about is EDX,\nwhich needs to be a pointer to our encoded payload, and gets moved into the EAX register\nduring the loop. Similar to before, we’ll setup our address space, define the architecture, map\nmemory, and configure some initial register values.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nADDRESS = 0x1000000\nmu = Uc(UC_ARCH_X86, UC_MODE_32)\nmu.mem_map(ADDRESS, 4 * 1024 * 1024)\n\n# Write code to memory\nmu.mem_write(ADDRESS, X86_CODE32)\n# Start of encoded data\nmu.reg_write(UC_X86_REG_EDX, 0x1000042)\n# Initialize ECX counter to 0\nmu.reg_write(UC_X86_REG_ECX, 0x0)\n# Initialize Stack for functions\nmu.reg_write(UC_X86_REG_ESP, 0x1300000)\n\nprint \"Encrypt: %s\" % mu.mem_read(0x1000042,250)\nmu.emu_start(ADDRESS, ADDRESS + len(X86_CODE32))\nprint \"Decrypt: %s\" % mu.mem_read(0x1000042,250)\n\n\nThis yields the following result:\n\n_Figure 20 Decrypted payload after running Python script_\n\nIf we take a look at this binary and peer at the strings, we can see that we’re finally at the\nend of the road.\n\n_Figure 21 Hancitor C2 URLs, external IP check, and Google remote check_\n\n\n-----\n\nTo recap the process:\n\nStarted with a Microsoft Word document\nExtracted base64 encoded shellcode\nExtracted encoded payload\nEmulated decoding function from shellcode to decode payload (binary)\nExtracted XOR key from new binary\nExtracted next encoded payload from new binary\nEmulated decoding function from new binary to decode Hancitor (binary)\n\nOur last step is to put everything together into a nice package that we can use to scan\nthousands of Microsoft Word documents containing Hancitor and identify all of the C2\ncommunications. Here’s a link to the [Hancitor decoder script we created.](https://github.com/pan-unit42/public_tools/blob/master/hancitor/hancitor_decrypt.py)\n\n\n-----\n\nFor the purpose of this test, I took a small sample set of 10,000 unique Microsoft Word\ndocuments that were first seen on August 15, 2016 and observed by Palo Alto Networks\nWildFire as creating a process with a name of “WinHost32.exe”. This, coupled with a few\nother criteria, gives me a corpus of testing samples that we know will be Hancitor and that I\ncan run this script against.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n[+] FILE: fe23150ffec79eb11a0fed5e3726ca6738653c4f3b0f24dd9306f6460131b34c\n#### PHASE 1 ####\n[-] ADD: 0x3\n[-] XOR: 0x13\n[-] SIZE: 80556\n[!] Success! Written to disk as\nfe23150ffec79eb11a0fed5e3726ca6738653c4f3b0f24dd9306f6460131b34c_S1.exe\n#### PHASE 2 ####\n[-] XOR: HEWRTWEWETHG\n[!] Success! Written to disk as\nfe23150ffec79eb11a0fed5e3726ca6738653c4f3b0f24dd9306f6460131b34c_S2.exe\n### PHASE 3 ###\n[-] http://api.ipify.org\n[-] http://google.com\n[-] http://bettitotuld.com/ls3/gate.php\n[-] http://tefaverrol.ru/ls3/gate.php\n[-] http://eventtorshendint.ru/ls3/gate.php\n\n[+] FILE:\nfe7d4a583c1ae380eff25a11bda4f6d53b92d49a7a4d72c775b21488453bbc96\n#### PHASE 1 ####\n[-] ADD: 0x3\n[-] XOR: 0x13\n[-] SIZE: 80556\n[!] Success! Written to disk as\nfe7d4a583c1ae380eff25a11bda4f6d53b92d49a7a4d72c775b21488453bbc96_S1.exe\n#### PHASE 2 ####\n[-] XOR: HEWRTWEWETHG\n[!] Success! Written to disk as\nfe7d4a583c1ae380eff25a11bda4f6d53b92d49a7a4d72c775b21488453bbc96_S2.exe\n### PHASE 3 ###\n[-] http://api.ipify.org\n[-] http://google.com\n[-] http://bettitotuld.com/ls3/gate.php\n[-] http://tefaverrol.ru/ls3/gate.php\n[-] http://eventtorshendint.ru/ls3/gate.php\n\n[+] FILE: fea98cc92b142d8ec98be6134967eacf3f24d5e089b920d9abf37f372f85530d\n#### PHASE 1 ####\n[-] ADD: 0x3\n[-] XOR: 0x14\n[-] SIZE: 162992\n[!] Success! Written to disk as\nfea98cc92b142d8ec98be6134967eacf3f24d5e089b920d9abf37f372f85530d_S1.exe\n#### PHASE 2 ####\n[-] XOR: ð~ð~ð~\n\n[!] Detected Nullsoft Installer! Shutting down\n\n\n-----\n\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n[+] FILE:\nfeb58e18dd320229d41d5b5932c14d7f2a26465e3d1eec9f77de211dc629f973\n#### PHASE 1 ####\n[-] ADD: 0x3\n[-] XOR: 0x13\n[-] SIZE: 80556\n[!] Success! Written to disk as\nfeb58e18dd320229d41d5b5932c14d7f2a26465e3d1eec9f77de211dc629f973_S1.exe\n#### PHASE 2 ####\n[-] XOR: HEWRTWEWETHG\n[!] Success! Written to disk as\nfeb58e18dd320229d41d5b5932c14d7f2a26465e3d1eec9f77de211dc629f973_S2.exe\n### PHASE 3 ###\n[-] http://api.ipify.org\n[-] http://google.com\n[-] http://bettitotuld.com/ls3/gate.php\n[-] http://tefaverrol.ru/ls3/gate.php\n[-] http://eventtorshendint.ru/ls3/gate.php\n\n\n## Analysis\n\nThe results were fairly unimpressive, however you win some and you lose some. It still\nprovides some interesting observations.\n\nFor our sample set, there were only 3 C2 URLs across all 8,851 Hancitor payloads we\nsuccessfully decoded:\n\n\n1\n2\n3\n\n\nhxxp://bettitotuld[.]com/ls3/gate.php\nhxxp://tefaverrol[.]ru/ls3/gate.php\nhxxp://eventtorshendint[.]ru/ls3/gate.php\n\n\nLooking at the stage 1 payloads, we decoded 9,967, which is almost the entire set.\nReviewing the metadata for the PE files, 8,851 exhibited the following characteristics, which\nare included in a YARA rule at the end of this document.\n\nCompanyName: 'SynapticosSoft, Corporation.'\n\nOriginalFilename: 'MpklYuere.exe'\n\nProductName: 'ngqlgdA'\n\nAdditionally, we identified three XOR keys being used in stage 1:\n\n\n1\n2\n3\n\n\n13  [-] XOR: 0xe\n1103  [-] XOR: 0x14\n8851  [-] XOR: 0x13\n\n\n-----\n\nAfter correlating the data, each of the keys corresponded to a different stage 2 dropper and\nour script was designed to target and decoded the most heavily used. General observations\nfor the other two decoders are that the one with key 0xE uses the same XOR key for the\nsecond stage Hancitor payload “HEWRTWEWETHG” and would likely be straightforward to\nadd to the decoding script. The 1,103 other files with key 0x14 were identified as Nullsoft\nInstallers.\n\nFor the 8,851 that successfully decoded their stage 2 payload, I did not note any PE’s with\nany file information; however, a YARA rule is included which matches them all. The last thing\nI’ll mention regarding the stage 2 files is the different file sizes.\n\n\n1\n2\n3\n4\n\n\n3  [-] SIZE: 114688\n10  [-] SIZE: 109912\n1103  [-] SIZE: 162992\n8851  [-] SIZE: 80556\n\n\nThis data is pulled from the variable in our shellcode and we can see that there is a slight file\nsize variation in the 13 that used the XOR key 0xE, which might imply slightly modified\npayloads.\n\n## Conclusion\n\nHopefully this was an educational demonstration using the extremely powerful Unicorn\nEngine to build a practical malware decoder. These techniques can be applied to many\ndifferent samples of malware and can free you up from the more tedious process of figuring\nout how to program a slew of bitwise interactions and focus more on analysis and\ncountermeasures.\n\n## Indicators\n\n[At the following GitHub repository, you will find 3 YARA rules, listed below, which can be](https://github.com/pan-unit42/public_tools/tree/master/hancitor)\nused to detect the various pieces described throughout these two blogs, and the script that\nwas built throughout this blog for decoding Hancitor.\n\nhancitor_dropper.yara – Detect Microsoft Word document dropper\n\nhancitor_stage1.yara – Detect first PE dropper\n\nhancitor_payload.yara – Detect Hancitor malware payload\n\n**Get updates from**\n\n**Palo Alto**\n\n**Networks!**\n\nSign up to receive the latest news, cyber threat intelligence and research from us\n\n\n-----\n\n[By submitting this form, you agree to our Terms of Use and acknowledge our Privacy](https://www.paloaltonetworks.com/legal-notices/terms-of-use)\nStatement.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-08-30 - Pythons and Unicorns and Hancitor…Oh My! Decoding Binaries Through Emulation.pdf"
    ],
    "report_names": [
        "2016-08-30 - Pythons and Unicorns and Hancitor…Oh My! Decoding Binaries Through Emulation.pdf"
    ],
    "threat_actors": [
        {
            "id": "acae6371-5530-498a-8b99-c2f55652ffd5",
            "created_at": "2022-10-25T16:07:23.980316Z",
            "updated_at": "2025-03-27T02:02:10.061182Z",
            "deleted_at": null,
            "main_name": "Operation Parliament",
            "aliases": [],
            "source_name": "ETDA:Operation Parliament",
            "tools": [
                "Remote CMD/PowerShell terminal"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "3bda9919-b9cd-451c-89e6-c7674f8c6257",
            "created_at": "2023-01-06T13:46:38.782181Z",
            "updated_at": "2025-03-27T02:00:02.917403Z",
            "deleted_at": null,
            "main_name": "Operation Parliament",
            "aliases": [],
            "source_name": "MISPGALAXY:Operation Parliament",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535906,
    "ts_updated_at": 1743041131,
    "ts_creation_date": 1653787714,
    "ts_modification_date": 1653787714,
    "files": {
        "pdf": "https://archive.orkl.eu/2ec90d5c569c05e743a62a279d671d489705d208.pdf",
        "text": "https://archive.orkl.eu/2ec90d5c569c05e743a62a279d671d489705d208.txt",
        "img": "https://archive.orkl.eu/2ec90d5c569c05e743a62a279d671d489705d208.jpg"
    }
}