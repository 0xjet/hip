{
    "id": "87e331e5-e483-44f7-b721-88a0c7ea447a",
    "created_at": "2023-01-12T14:59:47.869705Z",
    "updated_at": "2025-03-27T02:16:26.510322Z",
    "deleted_at": null,
    "sha1_hash": "23d9fdaf4adca389dba74d5bc246a1f91cc41ca2",
    "title": "2021-10-27 - Evading EDR Detection with Reentrancy Abuse",
    "authors": "",
    "file_creation_date": "2022-05-28T01:31:49Z",
    "file_modification_date": "2022-05-28T01:31:49Z",
    "file_size": 1890469,
    "plain_text": "# Evading EDR Detection with Reentrancy Abuse\n\n**[deepinstinct.com/blog/evading-antivirus-detection-with-inline-hooks](https://www.deepinstinct.com/blog/evading-antivirus-detection-with-inline-hooks)**\n\nOctober 27, 2021\n\n## 100% Prevention Score in the 2022 MITRE ATT&CK Evaluation for\n Enterprise\n\n[Learn more](https://www.deepinstinct.com/news/deep-instinct-shows-100-percent-score-in-mitre-evaluations)\n\nOctober 27, 2021 | [Asaf Gilboa](https://www.deepinstinct.com/author/asaf-gilboa)\n\nCybercriminals have developed a diverse toolset to uncover vulnerabilities and repurpose\nexisting software features to find entry points through cyber defenses. In this blog, we’ll\nexplore a new way to exploit reentrancy that can be used to evade the behavioral analysis of\nEDR and legacy antivirus products.\n\n\n-----\n\nWhile the technique we ll examine focuses on a single-hooked API, this method of evasion\ncan be used against almost any antivirus tool’s hooks by reverse-engineering the AV product\nto allow a bypass and custom-tailoring the bypass method.\n\n[Most antivirus and endpoint detection and response (EDR) products focus on scanning and](https://www.deepinstinct.com/endpoint-detection-response)\ndetection, with some leveraging additional capabilities on top of their file scanning\nmechanism to detect malicious activity.\n\nOne of these capabilities involves tracking processes in-memory through behavioral analysis\nor heuristics. In short, the antivirus solution will detect or prevent certain behaviors that are\ndeemed to be malicious, such as dumping credentials from memory or injecting code into\nanother process. Finding these malicious activities helps the antivirus software detect a\nthreat that isn’t caught by the file-scanning capability. It is also useful when the file hash is\n[not blacklisted, or the attack is fileless.](https://www.deepinstinct.com/prevent-fileless-malware)\n\nIn order to find malicious behavior in process, an antivirus product will usually have its own\nDLL loaded into every process via its signed kernel driver on process startup. Once loaded,\nthis DLL will then place hooks on the APIs that require tracking.\n\nFor code injection, kernel32.dll’s functions including “CreateRemoteThread,” “VirtualAllocEx,”\nand “WriteProcessMemory” will most frequently be used. Most of the time security vendors\nwill prefer to hook the lowest-level API possible, such as hooking “NtWriteVirtualMemory”\ninside ntdll.dll instead of “WriteProcessMemory.” This is done for programs that do not call\nthe higher-level APIs, which can limit the heuristics’ ability to catch malicious behavior.\n\nWhat is Inline Hooking?\n\nUserland hooks is a very popular way for antivirus tools to inspect the behavior of a process.\nHooking is the process of intercepting a function call. As the guardian of the endpoint,\nintercepting calls to various APIs allows the antivirus product to not only detect, but also to\nprevent unwanted or suspicious activity. This is done most by inline hooking (sometimes\nknown as detouring).\n\n\n-----\n\nHooking and Reentrancy\n\nA very common problem that occurs when hooking Windows APIs is reentrancy. This occurs\nwhen a thread calls a hooked API, and the hook then calls another hooked API, or even that\nsame hooked API (either directly or indirectly). This process can lead to unnecessary\noverhead—and can also lead to an infinite recursion.\n\nReentrancy issues are a significant challenge for antivirus tools because using hooks on\nevery single process can cause severe stability issues, freezing, and other performance\nproblems. A common approach to this is to be careful about what code to write in the hook\nitself and make sure to not call any other API (directly or indirectly); this method limits what\nbehaviors can be monitored. However, a more elegant solution is simply to check for\nreentrancy. In this approach the hook’s trampoline will be called directly if reentrancy is\ndetected, skipping whatever checks and logic the hook usually goes through in its process.\n\nBelow is a diagram to show the flow of a reentrancy-friendly hook:\n\n\n-----\n\nTechnical Explanation\n\nLocating Hooks\n\nFor this next section we will play the part of the attacker and walk through the steps that one\nwould take to evade antivirus with one line of code.\n\n[The first step to locate a hook is to determine what APIs are hooked. HookShark is a terrific](https://guidedhacking.com/resources/hookshark-hookshark64-download.30/)\ntool to detect inline hooking. It provides a quick way to find what APIs a security vendor\nhooks.\n\nFor this example, when Notepad is launched, pressing “Scan this process” shows these\nresults:\n\n\n-----\n\nAn API that caught our attention is NtWriteVirtualMemory, which is used for process injection\ntechniques. As the attacker, we will determine if the antivirus would detect the attempt at\n[process hollowing (using the project here: https://github.com/m0n0ph1/Process-Hollowing).](https://github.com/m0n0ph1/Process-Hollowing)\nAs we can see, it was detected:\n\nThe second step is to determine where the hook sits. Luckily for us, the hook is inside the\nantivirus’ injected DLL – aswhook.dll.\n\n\n-----\n\nDisassembling the Hook\n\nNow that we know what file to disassemble, it should be very easy to open IDA and locate\nthe hook.\n\nThis is the function as seen in IDA:\n\n\n-----\n\nNow, we know this a hook for the function NtWriteVirtualMemory, so this should be what the\nAPI looks like:\n```\nNTSTATUSNtWriteVirtualMemory(\n     INHANDLEProcessHandle,\n     INPVOIDBaseAddress,\n     INPVOID Buffer,\n     INULONGNumberOfBytesToWrite,\n     INOUTPULONGNumberOfBytesWritten);\n\n```\nNow, we can simply change the function’s definition and name:\n\nThis will be easier to disassemble now that we know the type definitions of all the arguments.\n\nThe hook looks like this:\n\n\n-----\n\nHere is the decompiled version:\n\n\n-----\n\nAs we can see, there are four conditional jumps being made before the hook logic starts. At\nleast one of them should be the reentrancy check. If any of the conditions are met, the\ntrampoline will be called directly, skipping the logic of the hook. As we see in the first\nscreenshot, the first conditional jump checks whether ProcessHandle is a pseudo-handle (-1)\nto the current process. Since that isn’t very helpful, let’s see what the three other conditions\nare.\n\nAs we see in this screenshot, var_4 is a pointer to an integer. If sub_10006820 returns\nsomething other than 0x0, or if var_4 is NULL or the value inside var_4 is 0x1, a conditional\njump will occur.\n\nWe can deduce that sub_10006820 sets the value of var_4, probably according to the value\nstored in dword_10008060. Let’s disassemble it:\n\n\n-----\n\nFirst, we know inside fs:18h is the TEB (Thread Environment Block), so after we added\n“_TEB” struct definition to IDA, we can now see something pretty interesting:\n\nIn 0x10006837 we see that ecx is using an index in the TEB’s TlsSlots member. This refers\nto TLS – Thread Local Storage (see note #1).\n\nThe TEB.TlsSlots array size is 64. But what if a program wants to allocate a TLS slot in the\n65th index? In 0x1000682F, we see ecx being compared to the value 64. So, this translates\nroughly to the following C code:\n```\nif (*dword_10008060 <= 64)\n   *arg_4 = TEB.TlsSlots[dword_10008060];\n\n```\nIn 0x10006844 ecx is being compared to 1088. IDA doesn’t offer any known constants for\nthis seemingly arbitrary value. If we continue with the disassembly, however, this makes\nmore sense:\n\n\n-----\n\nThe instruction at 0x10006853 refers to edx again, which we know to be a pointer to TEB.\nThis means that [edx+0F94h] translates to TEB.TlsExpansionSlots.\n\nGoing back to the previous question – if a program calls TlsAlloc() after all the slots of the\nTEB.TlsSlots array are already allocated, TlsAlloc() will internally allocate memory on the\nheap via RtlAllocateHeap() and set TEB.TlsExpansionsSlots member to that allocated\nmemory’s address. This gives the thread an additional 1024 TLS slots it can use. If there’s\nan attempt to write to a TLS slot whose index is above 64, it will write to the allocated\nmemory on the heap instead of the TEB.TlsSlots array.\n\nSo, now the number 1088 makes sense – it’s just the result of 1024 (number of available\nslots in the TlsExpansionSlots that are stored on the heap) + 64 (number of available slots in\nthe TlsSlots that are stored directly inside the TEB). So, if the value stored in\ndword_10008060 is above 1088, it’s considered an illegitimate index.\n\nWhile we may be tempted to propose a solution where our malicious program allocates all\nthe 1088 TLS slots in order for this subroutine to return STATUS_INVALID_PARAMETER,\nthis solution isn’t possible because the vendor’s DLL allocates an index once it loads into the\nprocess, which is too early for us to intercept.\n\nBack to the code – if the conditional jump at 0x1000685B happens, the value inside arg_4\nwill be set to 0x0. This roughly translates to the following C code:\n```\nif (TEB.TlsExpansionSlots == NULL)\n   *arg_4 = 0x0;\n\n```\nSo now that we know how the value arg_4 is set, we can go back here:\n\n\n-----\n\nWe now know that var_4 is the value stored in the TLS slot, so we’ll rename it TlsValue. We\nalso know dword_10008060 is a pointer to a TLS index, so we’ll rename it g_TlsIndex.\n\nThis roughly translates to the following C code:\n```\nPDWORD TlsValue;\nif (sub_10006820(g_TlsIndex, TlsValue) == 0 || TlsValue == NULL || *TlsValue == TRUE)\n   // Skip the hook’s logic\n\n```\nThe instruction at 0x10002A81 sets the value stored at *TlsValue to 0x1. Later, we can see\nthis value is set back to 0x0 (at 0x10002ABF):\n\n\n-----\n\nTo recap, the security vendor accesses a TLS slot via a global variable to store an address\nwhich points to a Boolean value, which, if set to FALSE will cause the code to perform the\nhook’s logic, and if it is TRUE, it will skip it and go straight to the trampoline. Once it finishes\ndoing the hook’s logic it will reset the Boolean value back to FALSE.\n\nExploiting the Reentrancy Mechanism\n\nIf the g_TlsIndex is above 64, TlsExpansionSlots must be set to NULL so that TlsValue will\nalso be set to NULL. If g_TlsIndex is 64 or below. TlsValue should be NULL or the Boolean\nvalue in the address stored inside of it must be set to TRUE.\n\nWithout knowing the value of g_TlsIndex we have no way of knowing which TLS slot to\nmanipulate, so what should we do?\n\nOur solution is to set all of the TLS slots and TlsExpansionSlots to NULL temporarily before\na call to NtWriteVirtualMemory, and once we return from that call, we can restore all the TLS\nslots to their previous state. This is an easy solution that can be integrated with any\nmalicious code; we simply have to slightly modify the source code of whatever offensive tools\nwe want to use.\n\nA more elegant solution would be to use a C++ object that will be allocated on the stack.\nWhat it will do in its constructor is back up the values of all the TLS slots and the pointer of\nTlsExpansionSlots and then set them all to NULL, and once its destructor is called then it will\nrestore the original values of all of the TLS slots and the pointer of TlsExpansionSlots.\n\nThis action looks like this:\n\n\n-----\n\nWhenever we want to call an API that we know is hooked, we will simply create a block of\ncode around the call to that API. Creating a block of code guarantees that TlsKiller’s\ndestructor will be called as soon as the hooked API is over. In our case we know that\nWriteProcessMemory ends up calling NtWriteVirtualMemory so we must put TlsKiller in the\nsame block as WriteProcessMemory. For the sake of brevity one example is given:\n\nAfter re-compiling and running the executable, we get this:\n\n\n-----\n\nNo complaints from the Antivirus!\n\nOne Line of Code to Evade Antivirus\n\nIt seems that by simply adding one line of code before a call to a hooked API we were able\nto completely evade the antivirus tool’s behavioral analysis.\n\nDepending on which attacks the antivirus aims to prevent with its memory heuristics it is\npossible to bypass whatever defense they will put up, as long as they use the same method\nof checking for reentrancy in their hooks.\n\nSome antivirus products may devise their own methods to avoid reentrancy, and others\nmight use TLS indexes too, which means they will also be susceptible to this attack. While\nthey might do it differently (for example, not use the heap at all and just set the TLS slots as\nBoolean value or as an integer value), it will take very little effort to see if their hooks can be\nbypassed.\n\nOther antivirus solutions might devise an entire mechanism altogether. It should also be\nnoted that not all of the hooks placed by an antivirus have a mechanism to avoid reentrancy\n(for example NtProtectVirtualMemory is hooked but no check is done for reentrancy), so it is\nimportant to know which functions are affected by this.\n\nConclusion:\n\nWhile Antivirus products have a high detection rate when it comes to known malware, they\noften prioritize stability first, requiring them to be compatible with edge-cases and overall\nperformance. This lessens their security posture and opens up myriad possibilities for\nattackers. Therefore, a feature which was intended for stability can be re-purposed as a\nbypass method and open a path for intrusion and compromise. Further research will shed\nmore light on which features of an antivirus can be abused.\n\n\n-----\n\nIf you d like to learn more about Deep Instinct s industry-leading approach to stopping\nmalware, backed by a $3M guarantee, please download our new eBook, Ransomware: Why\nPrevention is better than the Cure.\n\nNote #1: TLS Slots\n\nTLS stands for “Thread Local Storage,” which some researchers might recognize by name\nas a known mechanism to run code before the PE’s entrypoint (TLS callbacks). This is,\nhowever, something else and unrelated.\n\nThread Local Storage is exactly what it sounds like – a place for threads to store their own\nlocal information in the TEB.TlsSlots array, which is an array of void pointers called TLS\nslots. Basically, that means that every thread has its own array which it can fill with values as\nit sees fit.\n\nSince the mechanism is a bit more complicated than just accessing an array, there are 4\nAPIs that can be used for TLS:\n\nTlsAlloc() – Allocates an index for the TLS. This index will be considered reserved and can\nbe used by any thread to get and set their local values in their TEB.TlsSlots.\n\nTlsFree(DWORD dwTlsIndex) – Releases the index allocated by TlsAlloc().\n\nTlsGetValue(DWORD dwTlsIndex) – Returns the value stored in the thread’s\nTEB.TlsSlots[dwTlsIndex].\n\nTlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue) – Sets lpTlsValue as the value in\nTEB.TlsSlots[dwTlsIndex].\n\nReferences:\n\n[https://docs.microsoft.com/en-us/windows/win32/procthread/thread-local-storage](https://docs.microsoft.com/en-us/windows/win32/procthread/thread-local-storage)\n\n[http://www.nynaeve.net/?p=181](http://www.nynaeve.net/?p=181)\n\n[https://github.com/microsoft/detours/wiki/OverviewInterception](https://github.com/microsoft/detours/wiki/OverviewInterception)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-10-27 - Evading EDR Detection with Reentrancy Abuse.pdf"
    ],
    "report_names": [
        "2021-10-27 - Evading EDR Detection with Reentrancy Abuse.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535587,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1653701509,
    "ts_modification_date": 1653701509,
    "files": {
        "pdf": "https://archive.orkl.eu/23d9fdaf4adca389dba74d5bc246a1f91cc41ca2.pdf",
        "text": "https://archive.orkl.eu/23d9fdaf4adca389dba74d5bc246a1f91cc41ca2.txt",
        "img": "https://archive.orkl.eu/23d9fdaf4adca389dba74d5bc246a1f91cc41ca2.jpg"
    }
}