{
    "id": "2d276b66-6eab-4606-9194-30738b4ddbdf",
    "created_at": "2023-01-12T14:58:49.601155Z",
    "updated_at": "2025-03-27T02:09:30.089892Z",
    "deleted_at": null,
    "sha1_hash": "4529d18e6fc99d0434786cf448b941bc26c63307",
    "title": "2021-01-08 - The malware analyst’s guide to aPLib decompression",
    "authors": "",
    "file_creation_date": "2022-05-27T21:13:24Z",
    "file_modification_date": "2022-05-27T21:13:24Z",
    "file_size": 313058,
    "plain_text": "# The malware analyst’s guide to aPLib decompression\n\n**[0xc0decafe.com/malware-analysts-guide-to-aplib-decompression/](https://0xc0decafe.com/malware-analysts-guide-to-aplib-decompression/)**\n\nJanuary 8, 2021\n\n[aPLib is a compression library that is very easy to use and integrate with C/C++ projects. It is](http://ibsensoftware.com/products_aPLib.html)\n[a pure LZ-based compression library. There is also an executable packer based on it called](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)\n[aPACK. Due to its ease of use and tiny footprint, it’s a very popular library utilized by many](http://ibsensoftware.com/products_aPACK.html)\n[malware families like ISFB/Ursnif,](https://labs.sentinelone.com/writing-malware-configuration-extractors-isfb-ursnif/) [Rovnix, and many more. Knowledge about aPLib](https://github.com/bowlofstew/rovnix/blob/master/bootkit/Inc/aplib.h)\ndetection and aPLib decompression is crucial for every malware analyst.\n\nThis blog post dives into many internals of aPlib, explains how to detect aPLib compression\nwith your bare eyes as well as YARA, and finally shows you how to decompress aPLib\ncompressed blobs with several tools.\n\n## aPLib v1.1.1 internals\n\n[aPLib is a library implementing the compression algorithm found in the executable](http://ibsensoftware.com/products_aPLib.html)\ncompressor [aPACK. It is a pure](http://ibsensoftware.com/products_aPACK.html) [LZ compression implementation. The library aPLib is known](https://en.wikipedia.org/wiki/LZ77_and_LZ78)\nfor its fast decompression speed and tiny footprint of the decompression code. As of writing,\nthe current version is `v1.1.1 .`\n\n\n-----\n\nThe objective of this section is not to explain how the actual compression algorithm at\naPLib’s core works, but rather to give a quick overview of the library itself (project structure,\nrelevant functions, relevant structs).\n\nSince you’ll likely encounter aPLib decompression during malware analysis, I’ll focus on the\ndecompression portion of aPLib in the following. Nevertheless, this blog post should be also\nvaluable for those who look into aPLib compression.\n\n### The aPLib library\n\n[The library can be found at the author’s website. It comprises a lot of valuable information.](http://ibsensoftware.com/files/aPLib-1.1.1.zip)\nFirst and foremost, there is the source code for decompression (but not compression!):\n```\n└── src\n   ├── 32bit\n   │  ├── crc32.asm\n   │  ├── depack.asm\n   │  ├── depackf.asm\n   │  ├── depacks.asm\n   │  ├── scheck.asm\n   │  ├── sdepack.asm\n   │  ├── sgetsize.asm\n   │  └── spack.asm\n   ├── 64bit\n   │  ├── crc32.asm\n   │  ├── depack.asm\n   │  ├── depackf.asm\n   │  ├── depacks.asm\n   │  ├── scheck.asm\n   │  ├── sdepack.asm\n   │  ├── sgetsize.asm\n   │  └── spack.asm\n   ├── depack.c\n   ├── depack.h\n   ├── depacks.c\n   └── depacks.h\n\n```\nSecond, there is some additional user documentation ( html and `chm ). Third, there are`\nlibraries to statically or dynamically link against. Several platforms are supported including\nWindows:\n```\n├── lib\n │  ├── dll\n │  │  ├── aplib.dll\n │  │  ├── aplib.h\n │  │  └── aplib.lib\n │  ├── dll64\n │  │  ├── aplib.dll\n │  │  ├── aplib.h\n │  │  └── aplib.lib\n\n```\nThe library offers several decompression functions that fall in three classes:\n\n\n-----\n\n```\n   aP_depack, aP_depack_asm, and aP_depack_asm_fast assume valid input data\n\n```\nand may crash if the input is invalid\n```\n   aP_depack_safe and aP_depack_asm_safe catch decompression errors and do\n\n```\nnot crash on invalid input data\n```\n   aPsafe_depack is a function wrapper adding a header to the compressed data\n\n```\nAt their core, they all utilize the LZ-based compression algorithm. In the following sections, I’ll\nhave a look at each of the three classes.\n\n### aP_depack*\n\nThe decompression function `aP_depack decompresses a compressed binary blob. The`\ncounterpart of `aP_depack_safe is the function` `aPsafe_pack .`\n\nThe following function signature is defined in `depack.h :`\n```\nunsigned int aP_depack(const void *source, void *destination);\n\n```\nThe functions of this class assume that the compressed data is valid. This saves some sanity\nchecks, which in turn results in faster decompression and a smaller footprint of the\ndecompression code. However, it is likely that they crash if an error is encountered.\n\n### aP_depack_safe*\n\nThe functions of this class solely add additional sanity checks. If they encounter an error\ncondition, they return `APLIB_ERROR (defined as` `0xFFFFFFFF ). Furthermore, they require`\nthe length of the input (compressed data) and the size of the output (decompressed data) as\nseen in the signature of the `aP_depack_safe function:`\n```\nunsigned int aP_depack_safe(const void *source,\n               unsigned int srclen,\n               void *destination,\n               unsigned int dstlen);\n\n```\nOtherwise, they are equivalent to the functions from the `aP_depack* class.`\n\n### aPsafe_depack\n\nThe decompression function `aPsafe_depack decompresses a compressed binary blob`\nsafely. It is a wrapper around the functions of the class. The counterpart of `aPsafe_depack`\nis the function `aPsafe_pack .`\n\nThe function signature of `aPsafe_depack resembles the signature of` `aP_depack_safe :`\n```\nunsigned int aPsafe_depack(const void *source,\n               unsigned int srclen,\n               void *destination,\n               unsigned int dstlen);\n\n```\n\n-----\n\n```\naPsafe_depack requires that the compressed blob starts with a header. This header\n\n```\ncomprises additional information regarding the blob. This is for example very useful if we\nwant to send an aPLib compressed blob over the network. The header structure looks like\nthe following struct:\n```\nstruct aPLib_header {\nDWORD tag;\nDWORD header_size;\nDWORD packed_size;\nDWORD packed_crc;\nDWORD orig_size;\nDWORD orig_crc;\n}\n\n```\nThe struct `aPLib_header has a size of 24 bytes. This holds on` `x86 and` `x64 systems.`\nBut there are several checks in the library that ensure that the `header_size is at least 24`\nbytes. The following screenshot shows a PE executable packed with `appack :`\n\naPLib\n\ncompressed PE executable: 24 bytes header (magic highlighted), followed by compressed\npayload\nWe can see the magic `AP32 ( 0x32335041 ), directly followed by the header size of 0x18 /`\n24 bytes. The next four DWORDs are the `packed_size,` `packed_crc,` `orig_size, and`\n```\norig_crc . After the header comes the payload, which starts in this case with M8Z since\n\n```\nwe compressed a PE executable. We will use this fact later on for detection.\n\n## Detect if a binary statically links against aPLib\n\nDetecting if a binary comprises the capability of aPLib compression/decompression is\nstraightforward in the case it dynamically links against aPLib and it comprises a valid IAT\n(Import Address Table). However, in the case of custom/malicious binaries, it typically\nstatically links against aPLib.\n\nStill, there are many ways how we can detect this. First, we’ve already seen constants like\n```\nAP32 ( 0x32335041 ), which we could leverage to detect aPLib. But there are also several\n\n```\nstrings present that refer to aPLib itself or its author (Jørgen Ibsen) as seen in the following\nscreenshot:\n\n\n-----\n\nStrings that\n\nrefer to aPLib and its author\nThese ASCII strings are:\n\n“aPLib v1.1.1 – the smaller the better :)”\n“Copyright (c) 1998-2014 Joergen Ibsen, All Rights Reserved.”\nMore information: http://www.ibsensoftware.com/\n\n[Another way would be detection via matching the assembly code. Tools like mkYARA can](https://github.com/fox-it/mkYARA)\nhelp you to generate (strict/relaxed) YARA rules for assembly functions/algorithms.\n\nHowever, at this point, I do not want to reinvent the wheel and I just refer to one of the freely\n[available YARA rules like the one from “_pusher_”:](https://github.com/x64dbg/yarasigs/blob/master/packer.yara)\n\n\n-----\n\n```\nrule aPLib : Jorgen Ibsen        \n{       \n meta:    \n author=\"_pusher_\"     \n date=\"2016-09\"      \n description=\"www.ibsensoftware.com/products_aPLib.html\"       \n strings:      \n $a0 = { 60 8B 74 24 24 8B 7C 24 28 8B 44 24 2C FC 33 DB B2 80 39 18 74 42 A4 B3 02\nE8 6D 00 00 00 73 F6 33 C9 E8 64 00 00 00 73 }     \n $a1 = { 60 8B 74 24 24 8B 7C 24 28 FC 33 DB 33 D2 A4 B3 02 E8 6D 00 00 00 73 F6 33\nC9 E8 64 00 00 00 73 1C 33 C0 E8 5B 00 00 00 }    \n $a3 = { B2 80 33 DB A4 B3 02 E8 6D 00 00 00 73 F6 33 C9 E8 64 00 00 00 73 1C 33 C0\nE8 5B 00 00 00 73 23 B3 02 41 B0 10 E8 4F 00 00 00 12 C0 73 F7 75 3F AA EB D4 E8 4D\n00 00 00 2B CB 75 10 E8 42 00 00 00 EB 28 AC D1 E8 74 4D 13 C9 EB 1C 91 48 C1 E0 08\nAC E8 2C 00 00 00 3D 00 7D 00 00 }    \n $a4 = { 61 94 55 B6 80 A4 FF 13 73 F9 33 C9 FF 13 73 16 33 C0 FF 13 73 1F B6 80 41\nB0 10 FF 13 12 C0 73 FA 75 3A AA EB E0 FF 53 08 02 F6 83 D9 01 75 0E FF 53 04 EB 24\nAC D1 E8 74 2D 13 C9 EB 18 91 48 C1 E0 08 AC FF 53 04 3B 43 F8 73 0A 80 FC 05 73 06\n83 F8 7F 77 02 41 41 95 8B C5 }     \n $a5 = { B2 80 A4 B6 80 FF 13 73 F9 33 C9 FF 13 73 16 33 C0 FF 13 73 1F B6 80 41 B0\n10 FF 13 12 C0 73 FA 75 3C AA EB E0 FF 53 08 02 F6 83 D9 01 75 0E FF 53 04 EB 26 AC\nD1 E8 74 2F 13 C9 EB 1A 91 48 C1 E0 08 AC FF 53 04 3D 00 7D 00 00 73 0A 80 FC 05 73\n06 83 F8 7F 77 02 }    \n $a6 = { B2 80 31 DB A4 B3 02 E8 6D 00 00 00 73 F6 31 C9 E8 64 00 00 00 73 1C 31 C0\nE8 5B 00 00 00 73 23 B3 02 41 B0 10 E8 4F 00 00 00 10 C0 73 F7 75 3F AA EB D4 E8 4D\n00 00 00 29 D9 75 10 E8 42 00 00 00 EB 28 AC D1 E8 74 ?? 11 C9 EB 1C 91 48 C1 E0 08\nAC E8 2C 00 00 00 3D 00 7D 00 00 73 0A 80 FC 05 73 06 83 F8 7F 77 02 }    \n $a7 = { 33 C9 FF D3 73 16 33 C0 FF D3 73 23 B6 80 41 B0 10 FF D3 12 C0 73 FA 75 42\nAA EB E0 E8 46 00 00 00 02 F6 83 D9 01 75 10 E8 38 00 00 00 EB 28 AC D1 E8 74 48 13\nC9 EB 1C 91 48 C1 E0 08 AC E8 22 00 00 00 3D 00 7D 00 00 73 0A 80 FC 05 73 06 83 F8\n7F 77 02 41 41 95 }    \n $a8 = { 33 C9 FF 14 24 73 18 33 C0 FF 14 24 73 21 B3 02 41 B0 10 FF 14 24 12 C0 73\nF9 75 3F AA EB DC E8 43 00 00 00 2B CB 75 10 E8 38 00 00 00 EB 28 AC D1 E8 74 41 13\nC9 EB 1C 91 48 C1 E0 08 AC E8 22 00 00 00 3D 00 7D 00 00 73 0A 80 FC 05 73 06 83 F8\n7F 77 02 41 41 95 }    \n $a9 = { 33 C0 FF 13 73 1F B6 80 41 B0 10 FF 13 12 C0 73 FA 75 3A AA EB E0 FF 53 08\n02 F6 83 D9 01 75 0E FF 53 04 EB 24 AC D1 E8 74 2D 13 C9 EB 18 91 48 C1 E0 08 AC FF\n53 04 3B 43 F8 73 0A 80 FC 05 73 06 83 F8 7F 77 02 41 41 95 }    \n $a10 = { 60 8B 74 24 24 8B 7C 24 28 FC B2 80 33 DB A4 B3 02 E8 6D 00 00 00 73 F6 33\nC9 E8 64 00 00 00 73 1C 33 C0 E8 5B 00 00 00 73 23 B3 02 41 B0 10 E8 4F 00 00 00 12\nC0 73 F7 75 3F AA EB D4 E8 4D 00 00 00 2B CB 75 10 E8 42 00 00 00 EB 28 AC D1 E8 74\n4D 13 C9 EB 1C 91 48 C1 E0 08 AC E8 2C 00 00 00 3D 00 7D 00 00 73 0A 80 FC 05 73 06\n83 F8 7F 77 02 41 41 95 }    \n //taken from r!sc aspr unpacker,    \n $a11 = { B2 80 8A 06 46 88 07 47 02 D2 75 05 8A 16 46 12 D2 73 EF 02 D2 75 05 8A 16\n46 12 D2 73 4A 33 C0 02 D2 75 05 8A 16 46 12 D2 0F 83 D6 00 00 00 02 D2 75 05 8A 16\n46 12 D2 13 C0 02 D2 75 05 8A 16 46 12 D2 13 C0 02 D2 75 05 8A 16 46 12 D2 13 C0 02\nD2 75 05 8A 16 46 12 D2 13 C0 74 06 57 2B F8 8A 07 5F 88 07 47 EB A0 B8 01 00 00 00\n02 D2 75 05 8A 16 46 12 D2 13 C0 02 D2 75 05 8A 16 46 12 D2 72 EA 83 E8 02 75 28 B9\n01 00 00 00 02 D2 75 05 8A 16 46 12 D2 13 C9 02 D2 75 05 8A 16 46 12 D2 72 EA 56 8B\nF7 2B F5 F3 A4 5E E9 58 FF FF FF 48 C1 E0 08 8A 06 46 8B E8 B9 01 00 00 00 02 D2 75\n05 8A 16 46 12 D2 13 C9 02 D2 75 05 8A 16 46 12 D2 72 EA 3D 00 7D 00 00 73 1A 3D 00\n05 00 00 72 0E 41 56 8B F7 2B F0 F3 A4 5E E9 18 FF FF FF 83 F8 7F 77 03 83 C1 02 56\n8B F7 2B F0 F3 A4 5E E9 03 FF FF FF 8A 06 46 33 C9 D0 E8 74 12 83 D1 02 8B E8 56 8B\nF7 2B F0 F3 A4 5E E9 E8 FE FF FF 5D 2B 7D 0C 89 7D FC 61 }    \n\n```\n\n-----\n\n```\n condition:      \n any of them    \n        }\n\n```\nNevertheless, there is still the possibility that all strings are overwritten, constants like `AP32`\nare changed or are dynamically computed. Just remember that having not a match does not\nrule out aPLib usage completely but it makes it very unlikely.\n\n## Detect aPLib compression with your bare eyes and YARA\n\nThe following three sections shows you how to detect aPLib compression with your bare\neyes and suggest several YARA rules to automate detection.\n\n### aPLib header\n\nIf the compressed blob is safely packed, then it is quite easy to find them within larger blobs.\nAll we need to do is looking for the aPLib magic `AP32 and the default header size of 0x18:`\n\naPLib\n\ncompressed blob beginning with AP32 header\nThis boils down to searching for the byte sequence `0x4150333218000000 . We can write a`\nquick and dirty YARA signature:\n```\nrule aplib_compressed_blob_with_header {\n   meta:\n     author = \"Thomas Barabosch\"\n     version = \"20200109\"\n     description = \"Detects aPLib compressed blobs that comprise an aPLib\nheader.\"\n   strings:\n     $aplib_compressed_with_header = { 41 50 33 32 18 00 00 00 }\n   condition:\n     $aplib_compressed_with_header\n }\n\n### Compressed PE executables without aPLib header\n\n```\nHowever, as a malware analyst, you will stumble upon aPLib compressed blobs that do not\ncomprise an aPLib header very frequently. At least, the good news is that the trained eye can\neasily spot aPLib compressed PE files. These blobs of compressed PE files do not start with\nthe classic `MZ magic but with` `M8Z :`\n\n\n-----\n\nOnce you know that `M8Z means aPLib compression, it makes sense to write a small YARA`\nsignature to detect this in the future. Here I assume that we dumped a blob from, for\ninstance, the heap, and the magic is at the beginning of the file:\n```\nrule aplib_compressed_pe {\n   meta:\n     author = \"Thomas Barabosch\"\n     version = \"20201226\"\n     description = \"Detects aPLib compressed PE files, e.g. from memory dumps.\"\n   strings:\n     $mz_compressed = \"M8Z\"\n   condition:\n     $mz_compressed at 0\n }\n\n### Compressed ELF executables without aPLib header\n\n```\nFurthermore, I compressed a couple of ELF x64 files with `appack . I wanted to see if there`\nis also a pattern that gives aPLib compression away. If we byte-compare the output of two\ncompressed files, then we will see the following:\n\nComparing\n\naPLib compressed /bin/ls and /bin/zip (ELF x64)\nBoth compressed blobs start with the same `AP32 magic and the default header size of`\n0x18. Of course, the next four DWORDs are the `packed_size,` `packed_crc,`\n```\norig_size, and orig_crc are completely different. But then there are 10 bytes that are\n\n```\n\n-----\n\nequal: `0x7F07454C4602011E1501 . These bytes include the ELF magic` `ELF, which is not`\nat the beginning but does not get disfigured like the PE magic `MZ to` `M8Z . Right now, I am`\nnot sure if this is a consistent behavior across all ELF files or just for ELF x64 files.\n\nAgain, we can write a YARA rule for this:\n```\nrule aplib_compressed_elf_executable {\n   meta:\n     author = \"Thomas Barabosch\"\n     version = \"20200109\"\n     description = \"Detects aPLib compressed ELF executables. Note that there may\nbe a aPLib header starting 24 bytes BEFORE the match!\"\n   strings:\n     $aplib_compressed_elf = { 7F 07 45 4C 46 02 01 1E }\n   condition:\n     $aplib_compressed_elf\n }\n\n```\nThe YARA rules that I’ve presented here leave room for improvement. For example, we can\ncheck for cases where we have an aPLib header followed by a compressed PE executable,\nand so on. Be creative and let me know what you’ve found out!\n\n## aPLib decompression\n\nFinally, we’ve learned so much about aPLib compression, how to spot it with our bare eyes\nand detect it with YARA. But there is one final piece missing: we need to talk about aPLib\ndecompression. The following sections show you how to achieve aPLib decompression with\nthree different tools.\n\n### aPLib decompression with apack\n\nBefore looking at more complex scenarios, we can always resort to the tools that come with\n[aPLib. The library comes with an example tool called](http://ibsensoftware.com/products_aPLib.html) `appack . The source of this tool is`\nstored under `examples/appack.c and there are several` `make files for various platforms.`\n```\nappack offers two commands c and d :\nappack, aPLib compression library example\n Copyright 1998-2014 Joergen Ibsen (www.ibsensoftware.com)\n Syntax:\n Compress  : appack c <file> <packed_file> \n Decompress : appack d <packed_file> <depacked_file>\n\n```\nFor instance, we can decompress an aPLib compressed blob with the `d command as in the`\nfollowing snippet illustrated:\n```\n> appack d bin_ls.bin bin_ls\n appack, aPLib compression library example\n Copyright 1998-2014 Joergen Ibsen (www.ibsensoftware.com)\n Decompressed 66101 -> 151352 bytes in 0.01 seconds\n\n```\n\n-----\n\nThat s it, pretty simple. But this is not suitable for more complex scenarios, e.g. automation.\nHere, we have two options. First, we can use the aPLib library itself and write C programs.\nSecond, we can automate aPLib decompression using Python.\n\n### aPLib decompression with malduck\n\nLately, I utilize [Malduck a lot. So, let’s see how we can decompress an aPLib compressed](https://malduck.readthedocs.io/en/latest/)\n[blob with it. We can decompress these files with the following script based on Malduck:](https://malduck.readthedocs.io/en/latest/)\n```\nimport malduck\nimport sys\ndef main(argv):\n  if len(argv) != 2:\n    print('Usage: aplib.py PATH_TO_APLIB_COMPRESSED_BUFFER')\n  with open(argv[1], 'rb') as f:   \n    data = f.read()   \n    try:     \n      res = malduck.aplib(data)\n      if res:\n        with open(argv[1] + '_aplib_decompressed', 'wb') as g:\n          g.write(res)\n      else:\n        print(f'Malduck did not decompress the buffer.')\n    except Exception as e:\n      print(f'Could not aplib decompress: {e}')\n if name == 'main':\n   main(sys.argv)\n\n```\nThe function `malduck.aplib` [may take a flag called](https://malduck.readthedocs.io/en/latest/compression.html) `headerless . This flag forces`\nheaderless compression and does not check for the `AP32 magic. It defaults to` `True .`\n\nEven though this script seems to be trivial, it is a perfect skeleton for more complex tasks\nthat resolve around aPLib compression. For instance, if you’ve to write a script for extracting\nthe malware configuration of a specific family, which happens to use aPLib as part of the way\nhow it stores its configuration.\n\n### aPLib decompression with aplib-ripper\n\n[Another great tool is aplib-ripper by](https://github.com/herrcore/aplib-ripper) [herrcore. It rips one or several aPLib compressed PE](https://github.com/herrcore)\nexecutables from a blob. It searches for the string `M8Z, forces a headerless`\n[decompression, and finally verifies and trims the output with pefile.](https://github.com/erocarrera/pefile)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-01-08 - The malware analyst’s guide to aPLib decompression.pdf"
    ],
    "report_names": [
        "2021-01-08 - The malware analyst’s guide to aPLib decompression.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535529,
    "ts_updated_at": 1743041370,
    "ts_creation_date": 1653686004,
    "ts_modification_date": 1653686004,
    "files": {
        "pdf": "https://archive.orkl.eu/4529d18e6fc99d0434786cf448b941bc26c63307.pdf",
        "text": "https://archive.orkl.eu/4529d18e6fc99d0434786cf448b941bc26c63307.txt",
        "img": "https://archive.orkl.eu/4529d18e6fc99d0434786cf448b941bc26c63307.jpg"
    }
}