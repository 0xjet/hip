{
    "id": "fb11efe8-8c2e-451e-8d6f-42b642e95ff0",
    "created_at": "2023-02-02T02:07:27.104182Z",
    "updated_at": "2025-03-27T02:05:25.469962Z",
    "deleted_at": null,
    "sha1_hash": "3ad561ac1491dc2f012c2f5311cf864acdd19e9e",
    "title": "2023-01-13 - Getting Rusty and Stringy with Luna Ransomware",
    "authors": "",
    "file_creation_date": "2023-02-01T07:47:24Z",
    "file_modification_date": "2023-02-01T07:47:24Z",
    "file_size": 1578942,
    "plain_text": "# Getting Rusty and Stringy with Luna Ransomware\n\n**nikhilh-20.github.io/blog/luna_ransomware/**\n\n## Metadata\n\nSHA256: 1cbbf108f44c8f4babde546d26425ca5340dccf878d306b90eb0fbec2f83ab51\n\n[VT download link](https://www.virustotal.com/gui/file/1cbbf108f44c8f4babde546d26425ca5340dccf878d306b90eb0fbec2f83ab51)\n\n## Table of Contents\n\n Family Introduction\n\nThe Luna ransomware appeared in July 2022. Unlike its competitors, this threat targeted\nVMware ESXi instances from the day it started operating.\n\n## Rust Strings\n\nIn my experience as a malware analyst, I‚Äôve been used to seeing ASCII and null-terminated\nstrings in binaries. I was content writing IDAPython scripts where I created strings by\nsearching for ASCII and null characters. And one fine day, I had a Rust binary on my plate\nwhich broke my scripts. I interviewed the Rust God about strings. Here‚Äôs how it went:\n\n\n-----\n\nFig. 1: Rust Strings\n\n### String Slice: &str\n\n\n-----\n\nString slice is the term for &str type of strings. These kinds of strings may exist in the binary\nor on the stack or heap. They always reference UTF-8 characters and are immutable. Let‚Äôs\nconsider this simple Rust program:\n```\nfn main() {\n\n  let str1: &str = \"Hello World!\\n\";\n\n}\n\n\n```\nFig. 2 shows a snap of the disassembly as seen in IDA Home 7.7:\n\nFig. 2: String Slice\n\nString slices are essentially a data structure containing the address of the slice and its\nlength. Such structures are also called fat pointers because they contain extra data besides\njust the memory address. Consider the following Rust program which prints the size (in\nbytes) of the &str type:\n```\nuse std::mem::size_of;\n\nfn main() {\n\n  println!(\"A &str size in bytes: {}\", size_of::<&str>());\n\n}\n\n\n```\nOn execution, it prints:\n```\nA &str size in bytes: 16\n\n\n```\nMy system architecture is x64, so the size of &str, a fat pointer, is 16 bytes. The first 8 bytes\nis the memory address of the actual string literal and the next 8 bytes represents the length\nof that string literal The following structure represents a string slice:\n\n\n-----\n\n```\nstruct string_slice\n\n{\n\n _QWORD val;\n\n _QWORD len;\n\n};\n\n```\nIDA detects the above structure as core::fmt::ArgumentV1 and is defined as:\n```\nstruct core::fmt::ArgumentV1\n\n{\n\n core::fmt::_extern_0}::Opaque *value;\n\n core::result::Result<(),core::fmt::Error> (*formatter)\n(core::fmt::_extern_0}::Opaque *, core::fmt::Formatter *);\n\n};\n\n```\nAlthough IDA‚Äôs structure is of the correct size (16 bytes), it is not particularly readable. So, I\nreplaced it with my structure definition for better readability. Fig. 3 shows it in action.\n\nFig. 3: String Slice IDA Structure\n\n### String\n\nThe next string type in Rust is String. These kinds of strings are allocated only on the heap\nand they are mutable.\n```\nString is also a data structure. It contains the address of the slice, its length on the heap\n\n```\nand also the capacity of the heap region. Consider the following Rust program which prints\nthe size (in bytes) of the String type:\n\n\n-----\n\n```\nuse std::mem::size_of;\n\nfn main() {\n\n  println!(\"A String size in bytes: {}\", size_of::<String>());\n\n}\n\n```\nOn execution, it prints:\n```\nA String size in bytes: 24\n\n\n```\nMy system architecture is x64, so the size of String is 24 bytes. The first 8 bytes is the\nmemory address of the string slice; the next 8 bytes represents the length of that string literal\nand the last 8 bytes is the capacity of the memory region in the heap. The capacity signifies\nthe maximum number of bytes that the string can hold. If a longer string is required, then\nreallocation occurs on the heap. The following structure represents a String:\n```\nstruct String\n\n{\n\n _QWORD val;\n\n _QWORD len;\n\n _QWORD cap;\n\n};\n\n```\nFor example, a String may be allocated on the heap having the following structure field\nvalues:\n```\nval = \"Hello!\"\n\nlen = 6\n\ncap = 10\n\n\n```\nIDA detects the above structure as alloc::string::String and is defined as:\n```\nstruct alloc::string::String\n\n{\n\n alloc::vec::Vec<u8,alloc::alloc::Global> vec;\n\n};\n\n```\nLet‚Äôs consider this simple Rust program:\n```\nfn main() {\n\n  let str1: String = String::from(\"Hello World! üôè\\n\");\n\n}\n\n\n```\nFig. 4 shows a snap of the disassembly as seen in IDA Home 7.7. Here, v1 is the String\nvariable.\n\n\n-----\n\nFig. 4: String IDA Structure\n\nFig 5. shows a snap of the UTF-8 encoding of the string literal:\n\nFig. 5: String UTF-8 Encoding\n\n### Rust Strings Print\n\nIt can be seen in Fig. 4 that there is no null character after the Hello World! üôè\\n string.\nThis can make reading strings in IDA decompilation difficult as seen in Fig. 2 where the next\nstring has polluted the decompilation. I wrote an IDAPython script which prints Unicode\nstrings found in a Rust-based binary. I‚Äôve been unable to find an IDAPython function which\ncan create UTF-8 strings.\n\n### Luna Strings\n\nUsing the [IDAPython script, I found interesting strings.](https://nikhilh-20.github.io/blog/luna_ransomware/scripts/rust_strings_print_ida.py)\n\n\n-----\n\nFig. 6: String UTF-8 Encoding\n\n\n-----\n\n```\nLuna\n\n.ini\n\n.exe\n\n.dll\n\n.lnk\n\nError while writing encrypted data to:\n\nError while writing public key to:\n\nError while writing extension to:\n\nError while renaming file:\n\nW1dIQVQgSEFQUEVORUQ/XQ0KDQpBbGwgeW91ciBmaWxlcyB3ZXJlIG1vdmVkIHRvIHNlY3VyZSBzdG9yYWdlL\ng0KTm9ib2R5IGNhbiBoZWxwIHlvdSwgZXhjZXB0IHVzLg0KV2UgaGF2ZSBwcml2YXRlIGtleSwgd2UgaGF2ZS\nB5b3VyIGJsYWNrIHNoaXQuDQpXZSBhcmUgc3Ryb25nbHkgYWR2aWNlIHlvdSB0byBiZSBpbnRlcmVzdGVkIGl\nuIHNhZmV0eSBvZiB5b3VyIGZpbGVzLCBhcyB3ZSBjYW4gc2hvdyB5b3VyIHJlYWwgZmFjZS4NCg0KW1dIQVQg\nRE8gV0UgTkVFRD9dDQoNCkFkbWlzc2lvbiwgcmVzcGVjdCBhbmQgbW9uZXkuDQpZb3VyIGluZm9ybWF0aW9uI\nGNvc3RzIG1vbmV5Lg0KDQpbV0hPIEFSRSBXRT9dDQpBIGxpdHRsZSB0ZWFtIG9mIHBlb3BsZSB3aG8gY2FuIH\nNob3cgeW91ciBwcm9ibGVtcy4NCg0KW0hPVyBUTyBSRUFDSCBBTiBBR1JFRU1FTlQgV0lUSCBZT1U/XQ0KDQp\nTZW5kIHVzIGEgbWVzc2FnZSB3aXRoIHRob3NlIGUtbWFpbHM6DQoJZ2l2ZWZpc2h0b2FtYW42NjZAcHJvdG9u\nbWFpbC5jb20NCglnaXZlaG9va3RvYW1hbjY2NkBwcm90b25tYWlsLmNvbQ0KDQogICA\n\nError while writing note\n\nAES-NI not supported on this architecture. If you are using the MSVC toolchain, this\nis because the AES-NI method's have not been ported, yet\n\nInvalid AES key size.\n\nhost unreachable\n\nconnection reset\n\n/proc/self/exe\n\nopenserver\n\nwindows\n\nprogram files\n\nrecycle.bin\n\nprogramdata\n\nappdata\n\nall users\n\nEncrypting file:\n\nHow to use:\n\n -file /home/user/Desktop/file.txt (Encrypts file.txt in /home/user/Desktop\ndirectory)\n\n -dir /home/user/Desktop/ (Encrypts /home/user/Desktop/ directory)\n\n```\nThe base64-encoded string decodes to the ransom note:\n\n\n-----\n\n```\n[WHAT HAPPENED?]\n\nAll your files were moved to secure storage.\n\nNobody can help you, except us.\n\nWe have private key, we have your black shit.\n\nWe are strongly advice you to be interested in safety of your files, as we can show\nyour real face.\n\n[WHAT DO WE NEED?]\n\nAdmission, respect and money.\n\nYour information costs money.\n\n[WHO ARE WE?]\n\nA little team of people who can show your problems.\n\n[HOW TO REACH AN AGREEMENT WITH YOU?]\n\nSend us a message with those e-mails:\n\n     givefishtoaman666@protonmail.com\n\n     givehooktoaman666@protonmail.com\n\n## IDA Land\n\n```\nWhen analyzing Rust binaries, there are some notes to keep in mind:\n\nUnlike C or C++-based binaries, it is not easy to navigate Rust-based binaries in a topdown approach, i.e. start at the top and analyze your way down. This is because Rust\nadds a bunch of runtime code (error handling, memory-safe management, etc.) that\npollutes the disassembly.\nWithin the same Rust binary, there can exist multiple calling conventions.\nIDA (atleast Home 7.7) may not have the capability to identify Rust library functions, so\nthey are all marked as regular functions. You might end up analyzing code for 2 hours\nthat ends up being runtime or library code.\n\nThe previous IDAPython script comes in handy to identify points from where you can start\nanalysis. I could navigate to the string location in the .rodata segment, cross-reference to\nthe source which loads that string and then analyze that piece of code rather than starting at\nthe top. I started my analysis with the code that references the base64-encoded string of the\nransom note. I hoped this would position me in the neighborhood of the code that does the\nencryption.\n\n### Writing Ransom Note\n\nAs mentioned before, the binary contains the base64-encoded form of the ransom note. It\ndecodes it and then writes it into a file named readme-Luna.txt.\n\n\n-----\n\nFig. 7: Luna Ransom Note\n\n### Skips Files and Directories\n\nLuna doesn‚Äôt encrypt files which have:\n\nsubstring Luna in their filenames\none of the following extensions:\n```\n      .dll\n      .exe\n      .lnk\n      .ini\n\n```\nLuna doesn‚Äôt encrypt files under directories which contain one of the following substrings:\n```\n   openserver\n   windows\n   program files\n   recycle.bin\n   programdata\n   appdata\n   all users\n\n### Encryption Scheme\n\n```\nLuna employs an encryption scheme that is commonly found in the ransomware world. It\nleverages both asymmetric and symmetric cryptography, i.e., the key for the symmetric\ncryptography is derived is from asymmetric cryptography. It uses [curve25519-dalek package](https://github.com/dalek-cryptography/curve25519-dalek)\n[for Elliptic-Curve Cryptography (ECC) and crypto::aes module for AES-256 CTR-mode](https://docs.rs/rust-crypto/latest/crypto/aes/index.html)\ncryptography.\n\n\n-----\n\nLuna s encryption scheme can be summarized as follows:\n\nIt generates a public and private key on Curve25519.\nThe binary also contains the threat actor‚Äôs Curve25519 public key. Using the generated\nprivate key and the threat actor‚Äôs public key, the sample derives the 32-byte shared\nsecret.\nThe shared secret is used as the key for AES-256 CTR-mode. The IV is a string slice\n(a 16-byte fat pointer) pointing to a string literal, Luna.\n\nBoth the shared secret and the generated public key are zero‚Äôd in memory to prevent data\nleak. As I was writing this, I remembered Javier Yuste‚Äôs [Avaddon ransomware decryption tool](https://github.com/JavierYuste/AvaddonDecryptor)\nwhich relied on key information being available in memory. Perhaps, zero‚Äôing key information\nin memory is Luna‚Äôs safeguard against such decryption tools.\n\n### File Encryption\n\nLuna encrypts 50,000 bytes of plaintext file contents at a time. Since AES is in CTR mode,\ni.e., a stream cipher, the output ciphertext size is equal to the input plaintext size.\n\nFor the threat actor‚Äôs decryption tool to work, the ransomware binary has to store encryptionrelated information in the encrypted file. In this case, the threat actor would need two points\nof information per encrypted file:\n\nCurve25519 32-byte public key generated by the binary to calculate the shared secret\nused to encrypt the file.\nThe IV value used by AES-256 CTR-mode encryption.\nTo this end, the Luna binary\nstores the previously generated Curve25519 32-byte public key and the IV string literal,\n```\n   Luna to the end of the encrypted file.\n\n```\nEach encrypted file is given the extension, .Luna.\n\n## Peculiarities\n\n### Capability Peculiarities\n\nWhen I hear of ransomware targeting VMware ESXi, I usually come across capability in the\nbinary to shut down running VMs. This helps in clean encryption of files. However, Luna\ndoesn‚Äôt seem to contain any such capability which may result in encrypted files being\ncorrupted and incapable of being recovered.\n\n### Execution Peculiarities\n\nI was wrapping up this article when I noticed a few peculiarities in Luna‚Äôs execution.\n\n\n-----\n\nFig. 8: Execution Peculiarities\n\n## Summary\n\nIn this article, we looked at a sample of Luna ransomware.\n\n\n-----\n\nIt used an encryption scheme of Curve25519 (asymmetric cryptography) and AES-256\nCTR-mode (symmetric cryptography).\nUnlike popular ransomware families like BlackBasta and BlackCat, Luna doesn‚Äôt use\nintermittent encryption strategies and encrypts the entire file.\nCurve25519 public key and AES-256 IV values are stored at the end of the encrypted\nfile.\nLike most ransomware families, certain files and directories are not encrypted.\nI also introduced you to strings in Rust. I presented an IDAPython script that prints\nUTF-8 strings found in the .rodata segment of a Rust-based binary. These results\ngave a start point for our analysis.\nFinally, we looked at a few peculiarities (or bugs) in Luna‚Äôs code which makes for\nbuggy directory traversal.\n\nIn summary, Luna is the typical ransomware but with bugs and no optimizations.\n\n## References\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-01-13 - Getting Rusty and Stringy with Luna Ransomware.pdf"
    ],
    "report_names": [
        "2023-01-13 - Getting Rusty and Stringy with Luna Ransomware.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1675303647,
    "ts_updated_at": 1743041125,
    "ts_creation_date": 1675237644,
    "ts_modification_date": 1675237644,
    "files": {
        "pdf": "https://archive.orkl.eu/3ad561ac1491dc2f012c2f5311cf864acdd19e9e.pdf",
        "text": "https://archive.orkl.eu/3ad561ac1491dc2f012c2f5311cf864acdd19e9e.txt",
        "img": "https://archive.orkl.eu/3ad561ac1491dc2f012c2f5311cf864acdd19e9e.jpg"
    }
}