{
    "id": "ca0c60d6-2a61-4ae2-89f2-091f93d107c0",
    "created_at": "2023-01-12T15:09:32.892814Z",
    "updated_at": "2025-03-27T02:08:41.260355Z",
    "deleted_at": null,
    "sha1_hash": "0c4ea2a56afd3415757b99875405245228fe1eba",
    "title": "2019-11-09 - API-Hashing in the Sodinokibi-Revil Ransomware - Why and How-",
    "authors": "",
    "file_creation_date": "2022-05-29T01:19:19Z",
    "file_modification_date": "2022-05-29T01:19:19Z",
    "file_size": 150644,
    "plain_text": "# API-Hashing in the Sodinokibi/REvil Ransomware â€“ Why and How?\n\n**[blag.nullteilerfrei.de/2019/11/09/api-hashing-why-and-how/](https://blag.nullteilerfrei.de/2019/11/09/api-hashing-why-and-how/)**\n\nborn\n\nThis post is written for aspiring reverse engineers and will talk about a technique called _API\nhashing_. The technique is used by malware authors to hinder reverse engineering. We will\nfirst discuss the reasons a malware author may even consider using API hashing. Then we\nwill cover the necessary technical details around resolving dynamic imports at load-time and\nat runtime and finally, will described API hashing and show a Python script that emulates the\nhashing method used in Sodinokibi/REvil ransomware. # Top Down vs. Bottom Up One way\nto think about different approaches of reverse engineering is _Top Down_ vs. _Bottom Up_.\nTop Down means that you start with the entry point(s) of a binary and follow the execution\nflow. Bottom Up means that you start at an *interesting location* of the binary and try to\nunderstand, if and how the execution flow will reach it. Such a location may for example be\nan interesting string embedded in the binary ( http://example.com or `s3cr3t for`\nexample). So-called *imports* are also a good entry point for a Bottom Up analysis. One\nstrength of the Bottom Up approach is, that you can _focus_ your analysis efforts with very\nlittle understanding of the malware or - to phrase it differently - at a very early point in time:\nYou want to know where the juice crypto stuff is happening? Look for calls to the Windows\nAPI function `BCryptOpenAlgorithmProvider . Want to know, where the payload, later`\ndropped to `%TEMP%\\evil.exe, comes from? Look for reference to the string` `\\evil.exe .`\nSince this approach is so powerful, malware authors are highly motivated to make it harder\nfor the reverse engineer to use it. One of these counter-measures is called \"dynamic API\nresolutions with name hashing\" and described in this blog post. # API Resolution at LoadTime Under Windows, imports are listed in the import address table (IAT) of the Portable\nExecutable (PE) file. The table references functions that can be used during execution but\nare located in an external module. If a program wants to call `PathCanonicalize in`\n```\nSHLWAPI.dll for example, the IAT of your executable contains an entry referencing that\n\n```\nfunction. Say, you are looking for the command & control (C2) server of the malware, then\nyou may want to look at the the functions referencing `WININET.dll and find the`\n```\nInternetConnect entry. A string containing the C2 may be referenced in the the vacinity of\n\n```\ncalls to this function. # API Resolution at Runtime An obvious counter-measure against this\nreverse engineering approach is, to not use the function pointer from the IAT but resolve it at\nruntime. For this, the Windows API offers the functions `LoadLibrary and`\n```\nGetProcAddress . The LoadLibrary function accepts the name of a DLL and returns a\n\n```\nhandle to it. This handle can then be passed to `GetProcAddress together with a function`\nname to get a pointer to the corresponding function:\n\n\n-----\n\n```\n#include <stdio.h>\n#include <windows.h>\ntypedef BOOL(*funcType)(LPSTR, LPCSTR);\nint main() {\n  char buf[MAX_PATH];\n  HMODULE hModule = LoadLibrary(\"SHLWAPI.dll\");\n  funcType PathCanonicalizeA = (funcType)GetProcAddress(hModule,\n\"PathCanonicalizeA\");\n  if (! PathCanonicalizeA(buf, \"A:\\\\path\\\\.\\\\somewhere\\\\..\\\\file.dat\")) {\n    return 1;\n  }\n  printf(\"%s\", buf);\n  FreeLibrary(hModule);\n  return 0;\n}\n\n```\nLooking at references to `PathCanonicalizeA in the IAT will not lead to the call seen in the`\nabove code listing, defeating the technique described in _Static Imports_. For convenience\nreasons, one can now store the addresses retrieved by `GetProcAddress in global`\nvariables: If these global variables are named like the actual API functions, one wouldn't\neven need to change old code. Switching back to the perspective of a reverse engineer, one\ncan look for the _string_ `PathCanonicalizeA now. It needs to be passed to the`\n```\nGetProcAddress function at some point. This, of course, can then be defeated by\n\n```\nobfuscating the strings in the binary. But we will explore a different avenue in this post: The\nbelow-described method avoids inclusion of function names altogether. Instead, only a fixsized hash of the function name will be present which has the additional benefit of saving on\nstorage space. This is especially interesting when developing shellcode, where size\nrestrictions may be tough and real. # API Hashing Let's again put ourselfs into the shoes of a\nmalware author and let us further assume, we have a list of all exported function names for a\ngiven DLL. We can now calculate a hash for each function name. The hash doesn't need be\ncryptographically secure or even evenly distributed on the codomain. It only needs to be\nrelatively collision-free on the set of all exported function names. It may become clearer\nsoon, what that means exactly. The following hashing function - which is used in a recent\nsample of the Sodinokibi/REvil ransomware - initializes a state with `0x2b and then uses`\neach character of the function name as argument for an arithmetic operation. It performs an\narbitrary arithmetic operation in the end and finally returns the resulting state.\n```\n#!/usr/bin/env python3\ndef calc_hash(function_name):\n  ret = 0x2b\n  for c in function_name:\n    ret = ret * 0x10f + ord(c)\n  return (ret ^ 0xafb9) & 0x1fffff\n\n```\nThe table below lists the resulting hash for a few functions exported from `WINHTTP.dll .`\nOne already may notice that all the hashes are different. In fact, they are pairwise-different\n\n\n-----\n\nfor all functions exported from `WINHHTP.dll, so if we would only consider exports of that`\nDLL and only want to use these eleven functions, the hash can be used to uniquly identify\nthe API function. API function name | Hash ----------------------------|-----------```\nWinHttpSendRequest | 0x1ce2a7 WinHttpSetOption | 0x1a5e67\nWinHttpReadData | 0x064450 WinHttpCloseHandle | 0x0fd1fe WinHttpOpen |\n0x0a459a WinHttpQueryDataAvailable | 0x0b8299 WinHttpReceiveResponse |\n0x128d32 WinHttpConnect | 0x105ed8 WinHttpQueryHeaders | 0x09d98e\nWinHttpOpenRequest | 0x066635 WinHttpCrackUrl | 0x0c17e7 You might have\n\n```\nguessed, what the overall goal now is: somehow get a list of all API function names together\nwith their addresses, calculate the hashes for each of their names and only use the hash\nwhen referring to them. This way, we would avoid inclusion of any string - obfuscated or not that refers to the API function by name. This works as long as for each function we want to\nuse, the hashing method is collision-free over all considered function names. # Retrieving\nAPI function names But how do we get a list of all exported functions, potentially for all kinds\nof DLLs? As already described in the _Static Imports_ section, every Portable Executable\n(PE) file, including DLLs, contain a table with all exported functions. And since all the data\nfrom a PE file is loaded into memory, these table is present in memory too. To be precise, the\ntable is the first entry of the `DataDirectory array of the _Optional Header_ of the PE. The`\nOptional Header is a structure of type `IMAGE_OPTIONAL_HEADER and part of another`\nstructure called _PE Header_, which is located at offset `0x18 . The PE Header is of type`\n```\nIMAGE_NT_HEADERS and can be found when following the address at the very end of the\n\n```\n_DOS Header_ (that is at offset `0x3c ). The DOS Header is of type` `IMAGE_DOS_HEADER .`\nTo summarize this rambling the other way around: * The _DOS Header_ is located at the\nbeginning of a PE file. * The _PE Header_ is referenced at position `0x3c of the _DOS`\nheader_. * The _Optional Header_ is part of the PE header at offset `0x18 . * All _Data`\nDirectories_ are stored at offset `0x60 of the Optional Header. * The _Export Directory_ is`\nthe first Data Directory. If you prefere code over words, the following pseudo-C-snippet\nshows, how to retrieve the export directory starting from a pointer to a PE in memory:\n```\nIMAGE_DOS_HEADER pe_file = get_ptr_to_memory_containing_pe();\nIMAGE_NT_HEADERS pe_header = *(pe_file + 0x3c);\nIMAGE_OPTIONAL_HEADER optional_header = pe_header + 0x18;\nDATA_DIRECTORY data_directories[16] = optional_header + 0x60;\nIMAGE_EXPORT_DIRECTORY export_directory = data_directories[0];\n\n```\n**#lifehack**: offsets `0x3c and` `0x78 (which is the sum of the two offsets` `0x18 + 0x60`\nfrom the listing above) appearing in assembly or decompiled code indicate that PE parsing is\ngoing on with the goal to retrieve exports from a PE file. # Listing exports of DLLs Let's get\nour hands dirty: In this section, we will briefly explain, how to easily collect API function\nnames from Windows DLLs. This is useful independently of the malware family one analysis.\nIn the section after, we will look at a concret sample of the Sodinokibi/REvil ransomware.\nWith the help of a Python script, we will calculate API hashes for the collected function\nnames and compare the resulting hashes with the content of a buffer embedded in the\nmalware. The following Python script accepts a list of DLLs on the command line. Each line\n\n\n-----\n\nof its output is the name of the DLL followed by a space and the name of an export of the\nDLL.\n```\n#!/usr/bin/env python3\nimport sys\nimport pefile\nimport glob\nfor arg in sys.argv[1:]:\n  for file_name in glob.glob(arg):\n    try:\n      with open(file_name, 'rb') as fp:\n        pe = pefile.PE(data=fp.read())\n    except pefile.PEFormatError:\n      continue\n    if not hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):\n      continue\n    export = pe.DIRECTORY_ENTRY_EXPORT\n    dll_name = pe.get_string_at_rva(export.struct.Name)\n    if not dll_name:\n      continue\n    if len(export.symbols) == 0:\n      continue\n    for pe_export in export.symbols:\n      if not pe_export.name:\n        continue\n      print(dll_name.decode('utf-8'), pe_export.name.decode('utf-8'))\n\n```\nYou can use the script to accumulate exports for as many DLLs as possible. We will collect\nthe result in a file called `exports.txt . # API Hashing in Sodinokibi/REvil Ransomware`\nLet's consider the sample with SHA-256 hash\n```\n5f56d5748940e4039053f85978074bde16d64bd5ba97f6f0026ba8172cb29e93 . It belongs\n\n```\nto the Sodinokibi/REvil ransomware family and contains a build timestamp of 2019-06-10\n15:29:32. Reverse engineering with Ghidra yields the buffer shown below in hex-encoded\nformat.\n```\nae91d3b60313b7aca7e29c9ff53a4b505bf85fc37c42ad39da426c2851aa6caeaad50b9f84573f3d142cbc\n\n```\nRight after startup, the malware interprets it as an array of length `0x230 storing a` `DWORD`\nin each entry. Each `DWORD corresponds to an API function and Sodinokibi/REvil uses API`\nhashing to resolve the corresponding addresses. The Python script listed in the _Appendix_\nemulates the behaviour of the malware: it reads all exports from `exports.txt, calculate all`\nhashes for all exports, and list each `DWORD of the buffer stored in` `buffer.bin together`\nwith their API function name: DLL Name | API Hash | Function Name ---------------|-------------|------------------------------ ADVAPI32.dll | `0x2b7d106b | CheckTokenMembership`\nADVAPI32.dll | `0x40b57bbe | FreeSid ADVAPI32.dll |` `0x431d781e | IsValidSid`\nADVAPI32.dll | `0x43e878e7 | GetTokenInformation ADVAPI32.dll |` `0x45357e2f |`\nGetUserNameW ADVAPI32 dll | 0x49d572d6 | OpenProcessToken ADVAPI32 dll |\n\n\n-----\n\n```\n0x5b2a6022 | CryptAcquireContextW ADVAPI32.dll | 0x8012bb13 |\n\n```\nImpersonateLoggedOnUser ADVAPI32.dll | `0x8c2cb729 | RegCloseKey ADVAPI32.dll |`\n```\n0x8f6ab47f | RevertToSelf ADVAPI32.dll | 0x9c12a701 | RegOpenKeyExW ADVAPI32.dll\n\n```\n| `0x9d3ca625 | RegSetValueExW ADVAPI32.dll |` `0xc35ff85b | RegQueryValueExW`\nADVAPI32.dll | `0xd48aef93 | RegCreateKeyExW ADVAPI32.dll |` `0xda1fe106 |`\nAllocateAndInitializeSid ADVAPI32.dll | `0xe46bdf69 | CryptGenRandom combase.dll |`\n```\n0x39ad427c | CreateStreamOnHGlobal CRTDLL.dll | 0x958c2a38 | _snwprintf\n\n```\nCRYPT32.dll | `0x2dc78a5e | CryptStringToBinaryW CRYPT32.dll |` `0xadcf0a5e |`\nCryptBinaryToStringW GDI32.dll | `0x3371decc | DeleteObject GDI32.dll |` `0x346dd9cc |`\nDeleteDC GDI32.dll | `0x4bc6a666 | SetTextColor GDI32.dll |` `0x5829b59a | SetBkColor`\nGDI32.dll | `0x6e5983e6 | SetPixel GDI32.dll |` `0x842f699b | GetDeviceCaps GDI32.dll |`\n```\n0x8c936138 | CreateFontW GDI32.dll | 0xab3e468f | GetDIBits GDI32.dll | 0xc1bc2c14\n\n```\n| GetObjectW GDI32.dll | `0xd0803d2a | SetBkMode GDI32.dll |` `0xeb6406c3 |`\nCreateCompatibleBitmap GDI32.dll | `0xec0601b3 | GetStockObject GDI32.dll |`\n```\n0xedc4007f | SelectObject GDI32.dll | 0xf7bc1a03 | CreateCompatibleDC KERNEL32.dll\n\n```\n| `0x08c76270 | MapViewOfFile KERNEL32.dll |` `0x0924639c | DeleteFileW KERNEL32.dll`\n| `0x0b6061c9 | WaitForSingleObject KERNEL32.dll |` `0x0f5c65e6 | GetNativeSystemInfo`\nKERNEL32.dll | `0x13dbba0b | timeBeginPeriod KERNEL32.dll |` `0x15fc7f40 |`\nGetFileAttributesW KERNEL32.dll | `0x1b4f71f8 | Process32NextW KERNEL32.dll |`\n```\n0x1ce07649 | GetVolumeInformationW KERNEL32.dll | 0x286c42da |\n\n```\nCreateToolhelp32Snapshot KERNEL32.dll | `0x2f324589 | UnmapViewOfFile`\nKERNEL32.dll | `0x2ff4455d | FindClose KERNEL32.dll |` `0x32bf580a |`\nGetCommandLineW KERNEL32.dll | `0x35195fa1 | GetFileSize KERNEL32.dll |`\n```\n0x3c89563a | HeapCreate KERNEL32.dll | 0x3d3f5784 | OpenMutexW KERNEL32.dll |\n0x40d32a7d | SetErrorMode KERNEL32.dll | 0x427728cd | FindNextFileW KERNEL32.dll\n\n```\n| `0x43f52945 | CreateFileMappingW KERNEL32.dll |` `0x490d23af | ExitProcess`\nKERNEL32.dll | `0x4d1e27a2 | SystemTimeToFileTime KERNEL32.dll |` `0x4f3d2599 |`\nWriteFile KERNEL32.dll | `0x504b3af5 | PostQueuedCompletionStatus KERNEL32.dll |`\n```\n0x50733aca | CompareFileTime KERNEL32.dll | 0x588e3220 | GetModuleFileNameW\n\n```\nKERNEL32.dll | `0x5c6436d6 | CreateMutexW KERNEL32.dll |` `0x5fcd3573 |`\nOpenProcess KERNEL32.dll | `0x66d30c7b | GetDiskFreeSpaceExW KERNEL32.dll |`\n```\n0x6a0800be | GetUserDefaultUILanguage KERNEL32.dll | 0x719e1b29 |\n\n```\nGetProcessHeap KERNEL32.dll | `0x7f5b15e7 | GetDriveTypeW KERNEL32.dll |`\n```\n0x8aabe016 | FindFirstFileW KERNEL32.dll | 0x8cabe614 | SetFileAttributesW\n\n```\nKERNEL32.dll | `0x8cdbe673 | MultiByteToWideChar KERNEL32.dll |` `0x90c6fa75 | Sleep`\nKERNEL32.dll | `0x91f2fb5a | ReleaseMutex KERNEL32.dll |` `0x93b3f91f |`\nGetComputerNameW KERNEL32.dll | `0x9763fdd3 | Process32FirstW KERNEL32.dll |`\n```\n0x9a9bf02c | LocalAlloc KERNEL32.dll | 0x9ad6f07d | CreateFileW KERNEL32.dll |\n0x9c60f6ca | GetSystemDefaultUILanguage KERNEL32.dll | 0x9e07f4be | GlobalAlloc\n\n```\nKERNEL32.dll | `0xa185cb2c | CloseHandle KERNEL32.dll |` `0xa468cec4 |`\nSetFilePointerEx KERNEL32.dll | `0xaf7fc5dd | GetSystemDirectoryW KERNEL32.dll |`\n\n\n-----\n\nKERNEL32.dll | `0xbf26d591 | Wow64RevertWow64FsRedirection KERNEL32.dll |`\n```\n0xc1ddab7a | GetProcAddress KERNEL32.dll | 0xc610aca5 |\n\n```\nGetQueuedCompletionStatus KERNEL32.dll | `0xc97fa3d5 | LocalFree KERNEL32.dll |`\n```\n0xca02a0b5 | GetCurrentProcessId KERNEL32.dll | 0xca0863c2 | timeGetTime\n\n```\nKERNEL32.dll | `0xcb37a181 | MulDiv KERNEL32.dll |` `0xcbe9a151 |`\nWow64DisableWow64FsRedirection KERNEL32.dll | `0xcc3aa698 | CreateThread`\nKERNEL32.dll | `0xcc49a6fa | GetTempPathW KERNEL32.dll |` `0xd0cdba63 | GlobalFree`\nKERNEL32.dll | `0xdb88b122 | GetFileSizeEx KERNEL32.dll |` `0xdd54b7ec | VirtualAlloc`\nKERNEL32.dll | `0xe2e48854 | ReadFile KERNEL32.dll |` `0xe36b89db |`\nWideCharToMultiByte KERNEL32.dll | `0xe5a88f1a | HeapDestroy KERNEL32.dll |`\n```\n0xe6c88c71 | GetSystemInfo KERNEL32.dll | 0xe96d83df | GetFileAttributesExW\n\n```\nKERNEL32.dll | `0xeb7281db | GetWindowsDirectoryW KERNEL32.dll |` `0xee8d8436 |`\nMoveFileW KERNEL32.dll | `0xf1989b33 | CreateIoCompletionPort KERNELBASE.dll |`\n```\n0x380572b8 | PathFindExtensionW MPR.dll | 0x7518713e | WNetEnumResourceW\n\n```\nMPR.dll | `0xae6caa51 | WNetCloseEnum MPR.dll |` `0xc258c662 | WNetOpenEnumW`\nntdll.dll | `0x3822879e | RtlFreeHeap ntdll.dll |` `0x7697c934 | RtlTimeToTimeFields ntdll.dll |`\n```\n0x8fe93045 | RtlDeleteCriticalSection ntdll.dll | 0x95e62a4e | NtOpenFile ntdll.dll |\n0xacb71303 | RtlGetLastWin32Error ntdll.dll | 0xb86307ce | RtlInitializeCriticalSection\n\n```\nntdll.dll | `0xc09d7f3e | NtClose ntdll.dll |` `0xc97676c4 | RtlEnterCriticalSection ntdll.dll |`\n```\n0xd2ae6d17 | RtlLeaveCriticalSection ntdll.dll | 0xd69d6931 | RtlAllocateHeap ntdll.dll |\n0xe4135ba8 | NtQueryInformationFile ntdll.dll | 0xfac34566 | RtlInitUnicodeString rtm.dll |\n0x6acc17e7 | EnumOverTable SHCORE.dll | 0x2b1ca591 | CommandLineToArgvW\n\n```\nSHCORE.dll | `0x64472ee8 | SHDeleteValueW SHCORE.dll |` `0x9f0bd5aa |`\nSHDeleteKeyW SHELL32.dll | `0x9cbc123d | ShellExecuteExW USER32.dll |` `0x368a11e7`\n| GetForegroundWindow USER32.dll | `0x9359b433 | GetDC USER32.dll |` `0xb6d391ae |`\nwsprintfW USER32.dll | `0xbda29ac3 | GetKeyboardLayoutList USER32.dll |` `0xd228f54c |`\nSystemParametersInfoW USER32.dll | `0xec21cb5b | FillRect USER32.dll |` `0xfb28dc52 |`\nDrawTextW USER32.dll | `0xfcbfdbc2 | ReleaseDC WINHTTP.dll |` `0x1b146635 |`\nWinHttpOpenRequest WINHTTP.dll | `0x235a5e67 | WinHttpSetOption WINHTTP.dll |`\n```\n0x23ef5ed8 | WinHttpConnect WINHTTP.dll | 0x38b7459a | WinHttpOpen WINHTTP.dll |\n0x39714450 | WinHttpReadData WINHTTP.dll | 0x9f9ce2a7 | WinHttpSendRequest\n\n```\nWINHTTP.dll | `0xa4a0d98e | WinHttpQueryHeaders WINHTTP.dll |` `0xacd6d1fe |`\nWinHttpCloseHandle WINHTTP.dll | `0xf0078d32 | WinHttpReceiveResponse WINHTTP.dll`\n| `0xffb58299 | WinHttpQueryDataAvailable This data can now be used to deduce which`\nfunctions are called and enable a Buttom Up approach again. Looking at the only references\nto `WinHttpConnect for example will probably lead to a C2 server. # Appendix`\n\n\n-----\n\n```\n#!/usr/bin/env python3.7\nfrom revil import calc_hash\ndef chunks(l, n):\n  for i in range(0, len(l), n):\n    yield l[i:i + n]\ndef main():\n  exports = []\n  with open('exports.txt', 'r') as fp:\n    for line in fp:\n      sp = line.strip().split(' ')\n      if len(sp) != 2:\n        continue\n      exports.append(sp)\n  with open('buffer.bin', 'rb') as fp:\n    hash_buffer = fp.read()\n  resolutions = {}\n  for chunk in chunks(hash_buffer, 4):\n    api_hash = int.from_bytes(chunk, byteorder='little')\n    for dll_name, export_name in exports:\n      calculated_hash = calc_hash(export_name)\n      if calculated_hash == ( ( api_hash ^ 0x76c7 ) << 0x10 ^ api_hash ) &\n0x1fffff:\n        if dll_name not in resolutions.keys():\n          resolutions[dll_name] = []\n        resolutions[dll_name].append((api_hash, export_name))\n        break\n  for dll_name, pairs in resolutions.items():\n    for api_hash, export_name in pairs:\n      print(F'{dll_name}\\t0x{api_hash:08x}\\t{export_name}')\nif __name__ == '__main__':\n  main()\n\n```\nUpdate (2019-11-22): No mention of the term \"static import\" now because it doesn't make\nsense. Instead of \"dynamic\" vs. \"static\" imports, the post now talks about imports resolved at\n\"load-time\" vs. those resolved at \"runtime\".\nTags: [ghidra -](https://blag.nullteilerfrei.de/tag/ghidra/) [reversing](https://blag.nullteilerfrei.de/tag/reversing/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-11-09 - API-Hashing in the Sodinokibi-Revil Ransomware - Why and How-.pdf"
    ],
    "report_names": [
        "2019-11-09 - API-Hashing in the Sodinokibi-Revil Ransomware - Why and How-.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536172,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1653787159,
    "ts_modification_date": 1653787159,
    "files": {
        "pdf": "https://archive.orkl.eu/0c4ea2a56afd3415757b99875405245228fe1eba.pdf",
        "text": "https://archive.orkl.eu/0c4ea2a56afd3415757b99875405245228fe1eba.txt",
        "img": "https://archive.orkl.eu/0c4ea2a56afd3415757b99875405245228fe1eba.jpg"
    }
}