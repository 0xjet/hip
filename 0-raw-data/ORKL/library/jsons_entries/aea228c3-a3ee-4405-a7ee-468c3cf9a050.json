{
    "id": "aea228c3-a3ee-4405-a7ee-468c3cf9a050",
    "created_at": "2023-01-12T15:08:37.129139Z",
    "updated_at": "2025-03-27T02:12:36.922258Z",
    "deleted_at": null,
    "sha1_hash": "40f58e078fc030745a3413e3934a7efe6baad23b",
    "title": "2017-09-19 - A Modern Hypervisor as a Basis for a Sandbox",
    "authors": "",
    "file_creation_date": "2022-05-28T18:58:34Z",
    "file_modification_date": "2022-05-28T18:58:34Z",
    "file_size": 318507,
    "plain_text": "# A Modern Hypervisor as a Basis for a Sandbox\n\n**securelist.com/a-modern-hypervisor-as-a-basis-for-a-sandbox/81902/**\n\nAuthors\n\n[Vyacheslav Rusakov](https://securelist.com/author/vyacheslavrusakov/)\n\n[Vladislav Pintiysky](https://securelist.com/author/vladislavpintiysky/)\n\nIn the field of information security, [sandboxes are used to isolate an insecure external environment from a secure internal environment (or vice](https://encyclopedia.kaspersky.com/glossary/sandbox/?utm_source=securelist&utm_medium=blog&utm_campaign=termin-explanation)\nversa), to protect against the exploitation of vulnerabilities, and to analyze malicious code. At Kaspersky Lab, we have several sandboxes,\nincluding an Android sandbox. In this article, we will look at just one of them that was customized to serve the needs of a specific product and\n[became the basis of Kaspersky Anti Targeted Attack Platform. This particular sandbox is an analysis system for Windows applications that](https://www.kaspersky.com/enterprise-security/anti-targeted-attacks)\nhelps automate the analysis and detection of malicious code, conduct research and promptly detect the latest types of attacks.\n\nThere are several ways of implementing a sandbox to perform dynamic analysis of malicious code. For example, the following methods can be\nused:\n\nStandard [emulation, interception of functions in the user space and in the kernel space;](https://encyclopedia.kaspersky.com/glossary/emulation/?utm_source=securelist&utm_medium=blog)\nInformation from kernel callback functions and from various filter drivers;\nHardware virtualization.\n\nCombinations of these methods are also possible.\n\nPractice has shown that implementation of full-fledged emulation is a costly affair as it requires continuous support and enhancements to the\nemulation of API functions, as well as increased attention to execution evasion and emulation detection techniques. Interceptors didn’t last too\nlong either: malware learned to bypass them using relatively simple methods, ‘learning’ to identify if they are present and refusing to execute\ntheir malicious payload to avoid detection.\n\n\n-----\n\net ods to detect a d bypass sp c g a e bee o o yea s t s su c e t to c ec o t ace t e p o ogues o popu a u ct o s o\nbuild your own prologues to bypass an interceptor (the latter is used by cryptors and packers). Moreover, splicing technology itself is fairly\nunstable in a multithreaded environment. It’s also obvious that in a user space the level of isolation of malicious code from interceptors is\neffectively zero, because the operating system itself is modified – something that is very conspicuous.\n\nAnd that’s not all. In order to receive the results for the execution of an API function, it’s necessary to regain control after its execution, which is\ntypically done by rewriting the return address. This mechanism has also proven unstable. However, the biggest headache came with the\nattempt to transfer this sort of mechanism to new operating systems.\n\nTherefore, if a security solution vendor claims their sandbox uses splicing of API functions, takes events from the Windows kernel and is\n“amazing, unique, undetectable and produces near-100% results”, we recommend you avoid them like the plague. Some vendors may be\nperfectly happy with that sort of quality, but we definitely aren’t.\n\nHaving taken note of all the above facts (and a number of others), we have implemented our own sandbox based on hardware virtualization. At\nthe current time this is an optimal solution in terms of balance between performance, extendibility and isolation.\n\nA hypervisor provides a good degree of isolation of the guest virtual machine from the host by ensuring control over CPU and RAM. At the\nsame time, modern processors have a minimal impact on performance when virtualization is used.\n\n## The infrastructure\n\nThe hardware for our sandbox has been acquired at different times over recent years, and is still being added to, so its infrastructure is rather\ndiverse. Today, we have around 75 high-performance servers deployed, constituting four nodes in three data centers; in total, there are\nsome 2500 vCPUs. We use a variety of hardware types, from M2 systems and blade servers to M5 systems running Intel Xeon E5, with\nsupport for the technologies we need. Up to 2000 virtual machines are running at any given time.\n\nUp to four million objects per day are processed by the service at peak times, and around two million at off-peak times.\n\nFor Internet access within the sandbox, about 15 channels are used, the details of which we prefer not to disclose. Outgoing traffic from the\nnode reaches 5 Gb/s at peak times and 2 Gb/sec at off-peak times.\n\n## The internal structure\n\nOur sandbox consists of multiple components, each of which is responsible for designated functions. The transport subsystem communicates\nwith the outside world, receives commands from the outside and passes on the collected information. There are subsystems that perform file\nand network interactions, monitor threads/processes and references to the Windows registry. The logging subsystem collects the input and\noutput information of API functions. There is also a component in the system that emulates user actions. In addition, we have included an\noption to create and use plugins, so the functional capabilities can be extended.\n\n\n-----\n\nThe advantage of our solution is its broad functionality, plus the logging system can be installed on any operating system or on actual\nhardware. The image of the guest operating system can be customized to suit the client’s needs.\n\nOur analysts can also create dedicated subprograms to perform detection based on collected artifacts, as well as carry out different types of\nresearch. These subprograms include those that operate within the sandbox in real time.\n\n### Object processing and artifacts\n\nDepending on the type of file that comes in for processing, it will be ‘packed’ by the Task Processor component into a special kind of packet\nthat contains additional information on how the file should be launched, which operating system to select, the amount of time for processing,\netc.\n\n\n-----\n\nAfter that, another component, the Task Executor, performs the following actions:\n\n1. Launches virtual machine;\n2. Submits file;\n3. Applies extra configuration to guest operating system;\n4. Executes file;\n5. Waits until execution is complete;\n6. Scans and/or transfers collected artifacts.\n\nThe following artifacts are collected by Kaspersky Lab’s sandbox:\n\nProgram’s execution log (all API function calls with all parameters, plus some events);\nDumps of various memory ranges, loaded modules etc.;\nAll types of changes in file system and system registry;\nPCAP files containing networking data;\nScreenshots.\n\n### The logging subsystem\n\nThe central mechanism of Kaspersky Lab’s sandbox is the logging subsystem that implements the method of non-invasive interception of\ncalled API functions and the return values. This means the subsystem is capable of ‘suspending’ the thread of the process being investigated\nat those moments when it calls an API function or returns from it, and of processing that event synchronously. All this takes place without any\nmodifications to the code.\n\nFor each page of the virtual address space, we introduce an attribute of that page’s association with the DLL Known Module (KM). At any\ngiven point in time for a particular thread, either the pages that have the KM attribute installed are executable, or those pages where it has not\nbeen installed, but never both at the same time. This means that when an API function call is attempted, control is delegated to the KM page\nwhich at that moment is not executable according to the above rule. The processor generates an exception, which results in an exit to the\nhypervisor, and that event is processed. The exact opposite takes place when the API function returns control.\n\n\n-----\n\nThe left-hand side of the above diagram represents the memory of a typical process: the areas highlighted in red are those where execution of\ninstructions is disabled, and the areas in green are those where execution of instructions is enabled. The right of the diagram shows the same\nprocess in two states: execution is enabled in the system libraries or elsewhere, but never both at the same time. Accordingly, if you learn how\nto turn the entire address space of user mode red at the right time, you can catch the returns from system calls.\n\nFor all of this to work, copies of original address space page tables are introduced. They are used to translate the virtual address into a\nphysical address. In one of the copies, the pages with the KM attribute are executable, and the pages without the KM attribute are nonexecutable. In the other copy, it is the other way around. Each record in this sort of table corresponds to a certain page of the virtual address\nspace and, among other things, has the NX attribute that tells the processor if it can execute the instructions on that page. The above rule\ndefines the content of this attribute, depending on the copy and the page’s association with KM. To keep the copies of page tables up to date,\nthere is a module in the subsystem that reacts synchronously to changes in the original address space and, in accordance with our rules,\nmakes those changes to the copies of the address spaces. The operating system, meanwhile, is unaware of the fact that it is running on\ncopies of the original address space, and as far as it is concerned everything is transparent.\n\n## Anti-evasion\n\nModern malware uses a whole variety of methods to evade execution of code that may expose malicious activity.\n\nThe following techniques are used most frequently:\n\nDetecting a virtual runtime environment (a sandbox, emulator, etc.) from indirect evidence;\n‘Targeted’ execution: malicious activity is exposed only if the program is launched in the right/required runtime environment, at a specific\ntime, etc.\n\nIf malicious code detects a research environment, the following (or more) may happen:\n\nInstantaneous termination;\nSelf-destruction;\nExecution of a useless section of code;\nExecution of a secure section of code;\nAttempt to compromise the detected research system;\nOther.\n\n\n-----\n\nt e syste does ot eet t e equ ed pa a ete s, t e a c ous p og a ay pe o a y o t e abo e, but ost p obab y t dest oy\nitself so that it leaves no traces in the system.\n\nSandbox developers need to pay particular attention to evasion techniques, and Kaspersky Lab is no exception. We find out about these\n[techniques from a variety of sources, such as public presentations, articles, open-source tools (e.g. Pafish) and, of course, from analyzing](https://github.com/a0rtega/pafish)\nmalicious code. Along with the continuous improvements we make to our sandbox, we have also implemented automated randomization of\nvarious guest environment parameters to reduce execution evasion rates.\n\n### Vault 7 evasion methods\n\n[As a result of the Vault 7 leak, we discovered the following information about a potential method for evading code execution in our sandbox:](https://wikileaks.org/ciav7p1/cms/page_2621847.html)\n\n“The Trojan Upclicker (as reported by eEye) uses the SetWindowsHookExA API with the WH_MOUSE_LL parameter to wait until the user lets\nup the left mouse button (WM_LBUTTONUP) before performing any malicious functionality (then it injects into Explorer.exe). A sandbox\nenvironment that does not mimic mouse actions (probably most of them) will never execute the malicious behavior. This is probably effective\nagainst Kaspersky and others.”\n\n[This was an interesting assumption, so we immediately checked it. We implemented a console-based application (the source code is attached,](https://github.com/KasperskyLab/Articles/tree/master/Wait-for-Mouse-Click)\nso readers can use it to check their sandboxes), and it was little surprise that the function ExecuteEvil() executed successfully.\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n\n/*\n\nCopyright 2017 AO Kaspersky Lab. All Rights Reserved.\n\nAnti-Sandboxing: Wait for Mouse Click PoC: https://wikileaks.org/ciav7p1/cms/page_2621847.html\n\nRU: https://securelist.ru/a-modern-hypervisor-as-a-basis-for-a-sandbox/80739/\n\nEN: https://securelist.com/a-modern-hypervisor-as-a-basis-for-a-sandbox/81902/\n\n*/\n\n#include \"stdafx.h\"\n\n#include <windows.h>\n\n#include <iostream>\n\n#include <thread>\n\n#include <atomic>\n\nHHOOK global_hook = nullptr;\n\nstd::atomic<bool> global_ready(true);\n\nvoid ExecuteEvil() {\n\nstd::cout << \"This will never be executed in Sandbox\" << std::endl;\n\n// TODO: add your EVIL code here\n\nUnhookWindowsHookEx(global_hook);\n\nExitProcess(42);\n\n}\n\nLRESULT CALLBACK LowLevelMouseProc(_In_ int nCode, _In_ WPARAM wParam, _In_ LPARAM lParam) {\n\nif ( nCode < 0 ) {\n\n\n-----\n\n31\n\n32\n\n33\n\n34\n\n35\n\n36\n\n37\n\n38\n\n39\n\n40\n\n41\n\n42\n\n43\n\n44\n\n45\n\n46\n\n47\n\n48\n\n49\n\n50\n\n51\n\n52\n\n53\n\n54\n\n\n( p,,, );\n\n}\n\nif ( nCode == HC_ACTION && wParam == WM_LBUTTONUP && global_ready == true ) {\n\nglobal_ready = false;\n\nstd::thread(ExecuteEvil).detach(); // execute EVIL thread detached\n\n}\n\nreturn CallNextHookEx(nullptr, nCode, wParam, lParam);\n\n}\n\nint _tmain(int argc, _TCHAR* argv[]) {\n\nFreeConsole(); // hide console window\n\nglobal_hook = SetWindowsHookEx(WH_MOUSE_LL, LowLevelMouseProc, nullptr, 0);\n\n// emulate message queue\n\nMSG msg;\n\nwhile ( GetMessage(&msg, NULL, 0, 0) ) {\n\nSleep(0);\n\n}\n\nreturn 0;\n\n}\n\n\n[GitHub](https://github.com/KasperskyLab/Articles/tree/master/Wait-for-Mouse-Click)\n\nIt came as no surprise, because there is a dedicated component in our sandbox that emulates user actions and whose actions are\nindistinguishable from those of a regular user. This component exhibits generic behavior and, moreover, it ‘knows’ popular applications,\ninteracting with them just like a regular user, e.g. it ‘reads’ documents opened in Microsoft Word and installs applications if an installer is\nlaunched.\n\n## Heuristic search for exploits\n\nThanks to a system of plugins, we can infinitely expand the functionalities of the sandbox. One such plugin, Exploit Checker, detects typical\nactivity of early post-exploitation phases. The events it detects are logged, and the memory assigned to them is dumped to the hard drive for\nfurther analysis.\n\nBelow are some examples of Exploit Checker events:\n\nExploited exceptions:\n\nDEP violation\nHeap corruption\nIllegal/privileged instruction\nOthers\nStack execution;\nEoP detection;\nPredetection of Heap Spray;\nExecution of user space code in Ring 0;\nChange of process token;\n\n\n-----\n\nOt e s\n\n### CVE-2015-2546\n\n[Let’s take a look at the vulnerability CVE-2015-2545 and its extension CVE-2015-2546. Microsoft Office versions 2007 SP3, 2010 SP2, 2013](http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2015-2545)\nSP1 and 2013 RT SP1 are exposed to the former – it allows remote attackers to execute arbitrary code using a crafted EPS file. The latter\n[allows remote attackers to execute arbitrary code in kernel mode. Both vulnerabilities were used in a targeted attack by the Platinum (aka](https://securelist.com/analysis/publications/74828/cve-2015-2545-overview-of-current-threats/)\nTwoForOne) group. The attackers first exploited CVE-2015-2545 to execute code in the process WINWORD.EXE, and then CVE-2015-2546 to\nescalate privileges up to the SYSTEM level.\n\nCVE-2015-2546 is a classic Use-After-Free (UAF)-type vulnerability. Exploitation results in an escalation of process privileges up to SYSTEM\nlevel. Let’s take a closer look at this second vulnerability.\n\nBy detonating a crafted document in our sandbox, we obtained an aggregate execution log which we then filtered for events with the Exploit\nChecker plugin. This produced quite a lot of events, so we will only present the most interesting, i.e. those that allow us to obtain the shellcode\nof CVE-2015-2546 – user space code executed in kernel mode. (SMEP is used to counteract this technique.)\n\n\n1\n\n2\n\n3\n\n4\n\n\n\n[...]\n\n<EXPLOIT_CHECK Process=\"FLTLDR.EXE\" Pid=\"0x000000000000XXXX\"\nTid=\"0x000000000000XXXX\">UserSpaceSupervisorCPL(\"VA:0000000001FC29C0\",allocbase=0000000001FC0000,base=0000000001FC200\n\n<EXPLOIT_CHECK Process=\"FLTLDR.EXE\" Pid=\"0x000000000000XXXX\" Tid=\"0x000000000000XXXX\">SecurityTokenChanged()</EXPLO\n\n[...]\n\n1. We find the dump with ID = 0xD among the memory dumps of the process FLTLDR.EXE;\n2. The base address of the memory area is 0x1FC2000, the address of the code is located at 0x1FC29C0;\n3. Shellcode offset equals 0x1FC29C0 — 0x1FC2000 = 0x9C0.\n\n_Shellcode in a memory dump_\n\n\nNaturally the shellcode search algorithm will change depending on the type of vulnerability but that doesn’t change the basic principle\n\n\n-----\n\np o t C ec e s a p ug o t e ogg g syste t at p o des e t a e e ts, based o ce ta eu st cs, to t e e ecut o og pa t o t at,\nit collects the required artifacts: memory dumps that are used for further analysis and for detection.\n\n## BlackEnergy in the sandbox\n\n[We have already reported on an attack launched in Ukraine by the APT group BlackEnergy using Microsoft Word documents. Here’s a](https://securelist.com/blog/research/73440/blackenergy-apt-attacks-in-ukraine-employ-spearphishing-with-word-documents/)\nsummary of the analysis:\n\n1. Microsoft Word documents containing macros were used in the attack;\n2. A macro drops the file vba_macro.exe, a typical BlackEnergy dropper, to the disk;\n3. exe drops the file FONTCACHE.DAT, a regular DLL file, to the disk;\n4. For the DLL file to execute at each system launch, the dropper creates an LNK file in the startup system folder;\n5. The Trojan connects to its C&C at 5.149.254.114.\n\nBelow is a fragment of the execution log that we obtained by detonating a malicious Microsoft Word document in our sandbox running a guest\nWindows 7 x64 environment.\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n30\n\n31\n\n\n\n[0XXX] >> ShellExecuteExW (\"[HIDDEN_DIR]\\e15b36c2e394d599a8ab352159089dd2.doc\")\n\n[...]\n\n<PROCESS_CREATE_SUCCESS Pid=\"0xXXX\" ParentPid=\"0xXXX\" CreatedPid=\"0xYYY\" />\n\n<PROC_LOG_START Pid=\"0xYYY\" RequestorPid=\"0xXXX\" Reason=\"OnCreateChild\">\n\n<ImagePath>\\Device\\HarddiskVolumeZ\\Program Files (x86)\\Microsoft Office\\Office14\\WINWORD.EXE</ImagePath>\n\n<CmdLine>&quot;%PROGRAM_FILES%\\Microsoft Office\\Office14\\WINWORD.EXE&quot; /n &quot;[HIDDEN_DIR]\\e15b36c2e394d599a8\n\n</PROC_LOG_START>\n\n[...]\n\n<LOAD_IMAGE Pid=\"0xYYY\" ImageBase=\"0x30000000\" ImageSize=\"0x15d000\">\n\n<ImagePath>\\Device\\HarddiskVolumeZ\\Program Files (x86)\\Microsoft Office\\Office14\\WINWORD.EXE</ImagePath>\n\n</LOAD_IMAGE>\n\n<LOAD_IMAGE Pid=\"0xYYY\" ImageBase=\"0x78e50000\" ImageSize=\"0x1a9000\">\n\n<ImagePath>\\SystemRoot\\System32\\ntdll.dll</ImagePath>\n\n</LOAD_IMAGE>\n\n<LOAD_IMAGE Pid=\"0xYYY\" ImageBase=\"0x7de70000\" ImageSize=\"0x180000\">\n\n<ImagePath>\\SystemRoot\\SysWOW64\\ntdll.dll</ImagePath>\n\n</LOAD_IMAGE>\n\n[...]\n\n[0YYY] >> SetWindowTextW (0000000000050018,00000000001875BC -> \"e15b36c2e394d599a8ab352159089dd2.doc [Compatibility Mode\n\n[...]\n\n<FILE_CREATED Pid=\"0xYYY\">\n\n<Name>\\Device\\HarddiskVolumeZ\\Users\\[HIDDEN_USER]\\AppData\\Local\\Temp\\vba_macro.exe</Name>\n\n</FILE_CREATED>\n\n<FILE_WRITE Pid=\"0xYYY\" Position=\"0x0\" Size=\"0x0000000000000001\">\n\n<Name>\\Device\\HarddiskVolumeZ\\Users\\[HIDDEN_USER]\\AppData\\Local\\Temp\\vba_macro.exe</Name>\n\n</FILE_WRITE>\n\n<FILE_WRITE Pid=\"0xYYY\" Position=\"0x1\" Size=\"0x0000000000000001\">\n\n<Name>\\Device\\HarddiskVolumeZ\\Users\\[HIDDEN_USER]\\AppData\\Local\\Temp\\vba_macro.exe</Name>\n\n</FILE_WRITE>\n\n<FILE_WRITE Pid=\"0xYYY\" Position=\"0x2\" Size=\"0x0000000000000001\">\n\n<Name>\\Device\\HarddiskVolumeZ\\Users\\[HIDDEN_USER]\\AppData\\Local\\Temp\\vba_macro.exe</Name>\n\n\n-----\n\n33\n\n34\n\n35\n\n36\n\n37\n\n38\n\n39\n\n40\n\n41\n\n42\n\n43\n\n44\n\n45\n\n46\n\n47\n\n48\n\n49\n\n50\n\n51\n\n52\n\n53\n\n54\n\n55\n\n56\n\n57\n\n58\n\n59\n\n60\n\n61\n\n62\n\n63\n\n64\n\n65\n\n66\n\n67\n\n68\n\n69\n\n70\n\n71\n\n72\n\n73\n\n\n_\n\n[...]\n\n<FILE_WRITE Pid=\"0xYYY\" Position=\"0x1afff\" Size=\"0x0000000000000001\">\n\n<Name>\\Device\\HarddiskVolumeZ\\Users\\[HIDDEN_USER]\\AppData\\Local\\Temp\\vba_macro.exe</Name>\n\n</FILE_WRITE>\n\n<FILE_MODIFIED Pid=\"0xYYY\">\n\n<Name>\\Device\\HarddiskVolumeZ\\Users\\[HIDDEN_USER]\\AppData\\Local\\Temp\\vba_macro.exe</Name>\n\n</FILE_MODIFIED>\n\n[0YYY] << CloseHandle () [00000001] {0000}\n\n[...]\n\n[0YYY] >> CreateProcessW (0000000000000000 -> (NULL),000000000047FEDC -> \"%SYSTEM_ROOT%\\Users\\[HIDDEN_USER]\\AppDat\n(NULL),00000000001883B0 -> (STARTUPINFOEXW*){(STARTUPINFOW){,,lpDesktop=0000000000000000 -> (NULL),lpTitle=00000000000\n\n<PROCESS_CREATE_SUCCESS Pid=\"0xYYY\" ParentPid=\"0xYYY\" CreatedPid=\"0xZZZ\" />\n\n<PROC_LOG_START Pid=\"0xZZZ\" RequestorPid=\"0xYYY\" Reason=\"OnCreateChild\">\n\n<ImagePath>\\Device\\HarddiskVolumeZ\\Users\\[HIDDEN_USER]\\AppData\\Local\\Temp\\vba_macro.exe</ImagePath>\n\n<CmdLine>%SYSTEM_ROOT%\\Users\\[HIDDEN_USER]\\AppData\\Local\\Temp\\vba_macro.exe</CmdLine>\n\n</PROC_LOG_START>\n\n<LOAD_IMAGE Pid=\"0xYYY\" ImageBase=\"0xcb90000\" ImageSize=\"0x1b000\">\n\n<ImagePath>\\Users\\[HIDDEN_USER]\\AppData\\Local\\Temp\\vba_macro.exe</ImagePath>\n\n</LOAD_IMAGE>\n\n[...]\n\n[0ZZZ] << SHGetFolderPathA (,,,,000000000018FCC0 -> \"%SYSTEM_ROOT%\\Users\\[HIDDEN_USER]\\AppData\\Local\") [00000000] {0000}\n\n[0ZZZ] >> CreateFileA (000000000018FCC0 -> \"%SYSTEM_ROOT%\\Users\\[HIDDEN_USER]\\AppData\\Local\\FONTCACHE.DAT\",4000000\n\n<FILE_CREATED Pid=\"0xZZZ\">\n\n<Name>\\Device\\HarddiskVolumeZ\\Users\\[HIDDEN_USER]\\AppData\\Local\\FONTCACHE.DAT</Name>\n\n</FILE_CREATED>\n\n[...]\n\n<FILE_WRITE Pid=\"0xZZZ\" Position=\"0x0\" Size=\"0x000000000000DE00\">\n\n<Name>\\Device\\HarddiskVolumeZ\\Users\\[HIDDEN_USER]\\AppData\\Local\\FONTCACHE.DAT</Name>\n\n</FILE_WRITE>\n\n[...]\n\n<FILE_MODIFIED Pid=\"0xZZZ\">\n\n<Name>\\Device\\HarddiskVolumeZ\\Users\\[HIDDEN_USER]\\AppData\\Local\\FONTCACHE.DAT</Name>\n\n</FILE_MODIFIED>\n\n[0ZZZ] << CloseHandle () [00000001] {0000}\n\n[...]\n\n<FILE_CREATED Pid=\"0xZZZ\">\n\n<Name>\\Device\\HarddiskVolumeZ\\Users\\[HIDDEN_USER]\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\{C2F5139\n\n</FILE_CREATED>\n\n[...]\n\n<FILE_WRITE Pid=\"0xZZZ\" Position=\"0x0\" Size=\"0x000000000000075D\">\n\n<Name>\\Device\\HarddiskVolumeZ\\Users\\[HIDDEN_USER]\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\{C2F5139\n\n\n-----\n\n75\n\n76\n\n77\n\n78\n\n79\n\n80\n\n81\n\n82\n\n83\n\n84\n\n85\n\n86\n\n87\n\n88\n\n89\n\n90\n\n91\n\n92\n\n\n_\n\n<FILE_MODIFIED Pid=\"0xZZZ\">\n\n<Name>\\Device\\HarddiskVolumeZ\\Users\\[HIDDEN_USER]\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\{C2F5139\n\n</FILE_MODIFIED>\n\n[...]\n\n[0ZZZ] >> ShellExecuteW (0000000000000000,000000000018FEC8 -> \"open\",000000000018F8B0 -> \"%SYSTEM_ROOT%\\Users\\[HIDDE\n(NULL),0000000000000000 -> (NULL),00000000) => 000000000042195D {0000}\n\n[...]\n\n<PROCESS_CREATE_SUCCESS Pid=\"0xZZZ\" ParentPid=\"0xZZZ\" CreatedPid=\"0xAAA\" />\n\n<PROC_LOG_START Pid=\"0xAAA\" RequestorPid=\"0xZZZ\" Reason=\"OnCreateChild\">\n\n<ImagePath>\\Device\\HarddiskVolumeZ\\Windows\\SysWOW64\\rundll32.exe</ImagePath>\n\n<CmdLine>&quot;%SYSTEM_ROOT%\\Windows\\System32\\rundll32.exe&quot; &quot;%SYSTEM_ROOT%\\Users\\[HIDDEN_USER]\\AppD\n\n</PROC_LOG_START>\n\n[...]\n\n[0ZZZ] >> CreateProcessA (000000000018F334 -> \"%SYSTEM_ROOT%\\Windows\\system32\\cmd.exe\",000000000018EE20 -> \"/s /c \\\"for /L\n\\\"%SYSTEM_ROOT%\\Users\\[HIDDEN_USER]\\AppData\\Local\\Temp\\VBA_MA~1.EXE\\\" & ping localhost -n 2 & if not exist \\\"%SYSTEM_ROO\n1)\\\"\",0000000000000000,0000000000000000,00000000,08000000,0000000000000000,0000000000000000 -> (NULL),000000000018F848\n(NULL),dwX=00000000,dwY=00000000,dwXSize=00000000,dwYSize=00000000,dwXCountChars=00000000,dwYCountChars=00000000,d\n-> (NULL),,},000000000018F88C) => 0000000000421666 {0000}\n\n<PROCESS_CREATE_SUCCESS Pid=\"0xZZZ\" ParentPid=\"0xZZZ\" CreatedPid=\"0xBBB\" />\n\n<PROC_LOG_START Pid=\"0xBBB\" RequestorPid=\"0xZZZ\" Reason=\"OnCreateChild\">\n\n<ImagePath>\\Device\\HarddiskVolumeZ\\Windows\\SysWOW64\\cmd.exe</ImagePath>\n\n<CmdLine>/s /c &quot;for /L %i in (1,1,100) do (attrib +h &quot;%SYSTEM_ROOT%\\Users\\[HIDDEN_USER]\\AppData\\Local\\Temp\\VBA_M\nlocalhost -n 2 &amp; if not exist &quot;%SYSTEM_ROOT%\\Users\\[HIDDEN_USER]\\AppData\\Local\\FONTCACHE.DAT&quot; Exit 1)&quot;<\n\n</PROC_LOG_START>\n\n[...]\n\n\nAs a result of executing the malicious document, we obtained the following:\n\nA log of called API functions in all processes associated with malicious activities;\nMemory maps for all these processes, including both the loaded modules and heap memory;\nAll changes to the file system;\nNetwork packets;\nScreenshots.\n\nThis information is more than sufficient for a detailed analysis.\n\n## Conclusions\n\nKaspersky Lab’s sandbox for Windows applications is a large and a complex project that has been running for several years now. During this\nperiod, the logging system has demonstrated its effectiveness, so we use it not only in our internal infrastructure but in Kaspersky Anti\nTargeted Attack Platform too.\n\nThe use of a hypervisor has solved numerous problems related to malicious programs detecting sandbox environments. However,\ncybercriminals are continuously inventing new techniques, so we keep a close watch on the threat landscape and quickly introduce any\nnecessary updates to the code base.\n\n[Antivirus Technologies](https://securelist.com/tag/antivirus-technologies/)\n[Security technology](https://securelist.com/tag/security-technology/)\n[Targeted attacks](https://securelist.com/tag/targeted-attacks/)\n[Virtualization](https://securelist.com/tag/virtualization/)\n\nAuthors\n\n\n-----\n\n[Vyacheslav Rusakov](https://securelist.com/author/vyacheslavrusakov/)\n\n[Vladislav Pintiysky](https://securelist.com/author/vladislavpintiysky/)\n\nA Modern Hypervisor as a Basis for a Sandbox\n\nYour email address will not be published. Required fields are marked *\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-09-19 - A Modern Hypervisor as a Basis for a Sandbox.pdf"
    ],
    "report_names": [
        "2017-09-19 - A Modern Hypervisor as a Basis for a Sandbox.pdf"
    ],
    "threat_actors": [
        {
            "id": "33f527a5-a5da-496a-a48c-7807cc858c3e",
            "created_at": "2022-10-25T15:50:23.803657Z",
            "updated_at": "2025-03-27T02:00:55.550132Z",
            "deleted_at": null,
            "main_name": "PLATINUM",
            "aliases": [
                "PLATINUM"
            ],
            "source_name": "MITRE:PLATINUM",
            "tools": [
                "JPIN",
                "Dipsind",
                "adbupd"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "b3e954e8-8bbb-46f3-84de-d6f12dc7e1a6",
            "created_at": "2022-10-25T15:50:23.339976Z",
            "updated_at": "2025-03-27T02:00:55.446795Z",
            "deleted_at": null,
            "main_name": "Sandworm Team",
            "aliases": [
                "Sandworm Team",
                "ELECTRUM",
                "Telebots",
                "IRON VIKING",
                "BlackEnergy (Group)",
                "Quedagh",
                "Voodoo Bear",
                "IRIDIUM",
                "Seashell Blizzard",
                "FROZENBARENTS",
                "APT44"
            ],
            "source_name": "MITRE:Sandworm Team",
            "tools": [
                "Bad Rabbit",
                "Mimikatz",
                "Exaramel for Linux",
                "Exaramel for Windows",
                "GreyEnergy",
                "PsExec",
                "Prestige",
                "P.A.S. Webshell",
                "VPNFilter",
                "Cyclops Blink",
                "SDelete",
                "AcidRain",
                "Industroyer",
                "Industroyer2",
                "BlackEnergy",
                "Cobalt Strike",
                "NotPetya",
                "KillDisk",
                "PoshC2",
                "Impacket",
                "Invoke-PSImage",
                "Olympic Destroyer"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "7d8ef10e-1d7b-49a0-ab6e-f1dae465a1a4",
            "created_at": "2023-01-06T13:46:38.595679Z",
            "updated_at": "2025-03-27T02:00:02.869216Z",
            "deleted_at": null,
            "main_name": "PLATINUM",
            "aliases": [
                "TwoForOne",
                "G0068",
                "ATK33"
            ],
            "source_name": "MISPGALAXY:PLATINUM",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "e61c46f7-88a1-421a-9fed-0cfe2eeb820a",
            "created_at": "2022-10-25T16:07:24.061767Z",
            "updated_at": "2025-03-27T02:02:10.094583Z",
            "deleted_at": null,
            "main_name": "Platinum",
            "aliases": [
                "ATK 33",
                "Operation EasternRoppels",
                "TwoForOne"
            ],
            "source_name": "ETDA:Platinum",
            "tools": [
                "AMTsol",
                "Adupib",
                "Adupihan",
                "Dipsind",
                "DvDupdate.dll",
                "JPIN",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "RedPepper",
                "RedSalt",
                "Titanium",
                "adbupd",
                "psinstrc.ps1"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536117,
    "ts_updated_at": 1743041556,
    "ts_creation_date": 1653764314,
    "ts_modification_date": 1653764314,
    "files": {
        "pdf": "https://archive.orkl.eu/40f58e078fc030745a3413e3934a7efe6baad23b.pdf",
        "text": "https://archive.orkl.eu/40f58e078fc030745a3413e3934a7efe6baad23b.txt",
        "img": "https://archive.orkl.eu/40f58e078fc030745a3413e3934a7efe6baad23b.jpg"
    }
}