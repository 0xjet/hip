{
    "id": "e73b5ea1-5695-4a34-8518-e554186d60b4",
    "created_at": "2023-05-06T02:10:04.660177Z",
    "updated_at": "2025-03-27T02:05:33.054084Z",
    "deleted_at": null,
    "sha1_hash": "1747aaee4af34223c9eff7eb14de548764214aa2",
    "title": "2023-04-05 - Automating Qakbot Decode At Scale",
    "authors": "",
    "file_creation_date": "2023-05-05T01:57:55Z",
    "file_modification_date": "2023-05-05T01:57:55Z",
    "file_size": 3840532,
    "plain_text": "# Automating Qakbot decode at scale\n\n**docs.velociraptor.app/blog/2023/2023-04-05-qakbot/**\n\nThis is a technical post covering practical\n\nMatt Green - @mgreen27\n2023-04-05\n\nmethodology to extract\nconfiguration data from\nrecent Qakbot samples. In this blog, I will\nprovide\nsome background on Qakbot, then walk through decode themes in\nan easy to visualize\nmanner. I will then share a Velociraptor artifact\nto detect and automate the decode process at\nscale.\n\n\n-----\n\nQak!\n\nQakbot or QBot, is a modular malware first observed in 2007 that has\nbeen historically\nknown as a banking Trojan. Qbot is used to steal\ncredentials, financial, or other endpoint\ndata, and in recent years,\nregularly a loader for other malware leading to hands on keyboard\nransomware.\n\nTypical delivery includes malicious emails as a zipped attachment, LNK,\nJavascript,\nDocuments, or an embedded executable. The example shown in\nthis post was delivered by\nan email with an attached pdf file:\n\n\n-----\n\nAn example Qakbot infection chain\nQakbot has some notable defense evasion capabilities including:\n\n1. Checking for Windows Defender sandbox and terminating on discovery.\n2. Checking for the presence of running anti-virus or analysis tools,\nthen modifying its\n\nlater stage behavior for evasion.\n3. Dynamic corruption of payload on startup and rewrite on system shutdown.\n\nDue to the commodity nature of delivery, capabilities and end game,\nit is worth extracting\nconfiguration from observed samples to scope\nimpact from a given campaign. Hunting\nenterprise wide and finding a\npreviously missed machine or discovering an ineffective control\ncan be\nthe difference in preventing a domain wide ransomware event, or a\nsimilar really bad\nday.\n\n## Configuration\n\nQakbot has an RC4 encoded configuration, located inside two resources\nof the unpacked\npayload binary. The decryption process has not changed\nsignificantly in recent times, but for\nsome minor key changes. It uses\na SHA1 of a hard coded key that can typically be extracted\nas an\nencoded string in the .data section of the payload binary. This key\noften remains static\nacross campaigns, which can speed up analysis with\nthe maintainance of a recent key list.\n\nCurrent samples undergo two rounds of RC4 decryption with validation\nbuilt in. The\nvalidation bytes dropped from the data for the second\nround.\n\nAfter the first round:\n\nThe first 20 bytes in hex is for validation and is compared with the\nSHA1 of the\nremaining decoded data\nBytes [20:40] is the key used for the second round of decoding\nThe Data to decode is byte [40:] onwards\nThe same validation process occurs for the second round decoded data\n```\n      Verification = data[:20]\n      DecodedData = data[20:]\n\n```\n\n-----\n\nFirst round of Qakbot decode and verification\nCampaign information is located inside the smaller resource where,\nafter this decoding and\nverification process, data is clear text.\n\nDecoded campaign information\n\nThe larger resource stores Command and Control configuration. This is\ntypically stored in\n```\nnetaddress format with varying separators. A\ncommon technique for finding the correct\n\n```\nmethod is searching for common\nports and separator patterns in the decoded data.\n\n\n-----\n\nEasy to spot C2 patterns: port 443\n\n## Encoded strings\n\nQakbot stores blobs of xor encoded strings inside the .data section of\nits payload binary. The\ncurrent methodology is to extract blobs of key\nand data from the referenced key offset which\nsimilarly is reused\nacross samples.\n\nCurrent samples start at offset 0x50, with an xor key, followed by a\nseparator of 0x0000\nbefore encoded data. In recent samples I have\nobserved more than one string blob and\nthese have occurred in the same\nformat after the separator.\n\n\n-----\n\nEncoded strings .data\nNext steps are splitting on separators, decode expected blob pairs and\ndrop any non\nprintable. Results are fairly obvious when decoding is\nsuccessful as Qakbot produces clean\nstrings. I typically have seen two\nwell defined groups with strings aligning to Qakbot\ncapabilities.\n\n\n-----\n\nDecoded strings: RC4 key highlighted\n\n## Payload\n\nQakbot samples are typically packed and need execution or manual\nunpacking to retrieve\nthe payload for analysis. Its very difficult to\nobtain this payload remotely at scale, in practice\nthe easiest way is\nto execute the sample in a VM or sandbox that enables extracting the\npayload with correct PE offsets.\n\nWhen executing locally Qakbot typically injects its payload into a\nWindows process, and can\nbe detected with yara targeting the process\nfor an unbacked section with\n```\nPAGE_EXECUTE_READWRITE protections.\n\n```\nBelow is an example of running PE-Sieve / Hollows Hunter tool\nfrom Hasherezade. This\nhelpful tool enables detection of several types\nof process injection, and the dumping of\ninjected sections with\nappropriately aligned headers. In this case, the injected process is\n```\nwermgr.exe but it’s worth to note, depending on variant and process\nfootprint, your injected\n\n```\nprocess may vary.\n\n\n-----\n\nDumping Qakbot payload using pe-sieve\n\n## Doing it at scale\n\nNow I have explained the decode process, time to enable both detection\nand decode\nautomation in Velociraptor.\n\n[I have recently released\nWindows.Carving.Qakbot\nwhich leverages a PE dump capability in](https://docs.velociraptor.app/exchange/artifacts/pages/qakbot/)\nVelociraptor 0.6.8 to enable\nlive memory analysis. The goal of the artifact was to automate\nmy\ndecoding workflow for a generic Qakbot parser and save time for a\ncommon analysis. I\nalso wanted an easy to update parser to add\nadditional keys or decode nuances when\nchanges are discovered.\n\n\n-----\n\nWindows.Carving.Qakbot: parameters\nThis artifact uses Yara to detect an injected Qakbot payload, then\nattempts to parse the\npayload configuration and strings. Some of the\nfeatures in the artifact cover changes\nobserved in the past in the\ndecryption process to allow a simplified extraction workflow:\n\nAutomatic PE extraction and offset alignment for memory detections.\n```\n   StringOffset - the offset of the string xor key and encoded strings\nis reused regularly.\n\n```\nPE resource type: the RC4 encoded configuration is typically inside\n2 resources, I’ve\nobserved BITMAP and RCDATA\nUnescaped key string: this field is typically reused over samples.\nType of encoding: single or double, double being the more recent.\nHidden TargetBytes parameter to enable piping payload in for\nanalysis.\nWorker threads: for bulk analysis / research use cases.\n\n\n-----\n\nWindows.Carving.Qakbot: live decode\n\n## Research\n\nThe Qakbot parser can also be leveraged for research and run bulk\nanalysis. One caveat is\nthe content requires payload files that have\nbeen dumped with offsets intact. This typically\nrequires some post\ncollection filtering or PE offset realignment but enables Velociraptor\nnotebook to manipulate post processed data.\n\nSome techniques I have used to bulk collect samples:\n\nSandbox with PE dumping features: api based collection\nVirustotal search: crowdsourced_yara_rule:0083a00b09|win_qakbot_auto\nAND\n```\n   tag:pedll AND NOT tag:corrupt\n(note: this will collect some broken\npayloads)\n\n```\n\n-----\n\nBulk collection: IPs seen across multiple campaign names and ports\nSome findings from a small data set ~60 samples:\n\nNamed campaigns are typically short and not longer than a few\nsamples over a few\ndays.\nIP addresses are regularly reused and shared across campaigns\nMost prevalent campaigns are BB and obama prefixed\nMinor campaigns observed: azd, tok and rds with only one or\ntwo observed payload\nsamples each.\n\nStrings analysis can also provide insights to sample behavior over\ntime to assist analysis. A\ngreat example is the adding to process name\nlist for anti-analysis checks.\n\n\n-----\n\nBulk collection: Strings highlighting anti-analysis check additions over time\n\n## Conclusion\n\nDuring this post I have explained the Qakbot decoding process and\nintroduced an exciting\nnew feature in Velociraptor. PE dumping is a\nuseful capability and enables advanced\ncapability at enterprise scale,\nnot even available in expensive paid tools. For widespread\nthreats\nlike Qakbot, this kind of content can significantly improve response\nfor the blue team,\nor even provide insights into threats when analyzed\nin bulk. In the coming months the\nVelociraptor team will be publishing\na series of similar blog posts, offering a sneak peek at\nsome of the\ntypes of memory analysis enabled by Velociraptor and incorporated into\nour\ntraining courses.\n\nI also would like to thank some of Rapid7’s great analysts - Jakob Denlinger\nand James\n```\nDunne for bouncing some ideas when writing this\npost.\n\n## References\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-04-05 - Automating Qakbot Decode At Scale.pdf"
    ],
    "report_names": [
        "2023-04-05 - Automating Qakbot Decode At Scale.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1683339004,
    "ts_updated_at": 1743041133,
    "ts_creation_date": 1683251875,
    "ts_modification_date": 1683251875,
    "files": {
        "pdf": "https://archive.orkl.eu/1747aaee4af34223c9eff7eb14de548764214aa2.pdf",
        "text": "https://archive.orkl.eu/1747aaee4af34223c9eff7eb14de548764214aa2.txt",
        "img": "https://archive.orkl.eu/1747aaee4af34223c9eff7eb14de548764214aa2.jpg"
    }
}