{
    "id": "c3fde42b-b6db-4e4f-bccc-d11448e1d29a",
    "created_at": "2023-11-01T02:05:12.135325Z",
    "updated_at": "2025-03-27T02:16:21.000153Z",
    "deleted_at": null,
    "sha1_hash": "b031465c809a1a7e6a24b482347ae2307cf371a4",
    "title": "Hunting Russian Intelligence “Snake” Malware",
    "authors": "",
    "file_creation_date": "2023-05-08T13:57:21Z",
    "file_modification_date": "2023-05-10T11:35:36Z",
    "file_size": 4309123,
    "plain_text": "_Co-Authored by:_ **TLP:CLEAR** Product ID: AA23-129A\n\n\n# Hunting Russian Intelligence “Snake” Malware\n\n## SUMMARY\n\nThe Snake implant is considered the most sophisticated cyber espionage tool designed and used by\nCenter 16 of Russia’s Federal Security Service (FSB) for long-term intelligence collection on sensitive\ntargets. To conduct operations using this tool, the FSB created a covert peer-to-peer (P2P) network of\nnumerous Snake-infected computers worldwide. Many systems in this P2P network serve as relay\nnodes which route disguised operational traffic to and from Snake implants on the FSB’s ultimate\ntargets. Snake’s custom communications protocols employ encryption and fragmentation for\nconfidentiality and are designed to hamper detection and collection efforts.\n\nWe have identified Snake infrastructure in over 50 countries across North America, South America,\nEurope, Africa, Asia, and Australia, to include the United States and Russia itself. Although Snake\nuses infrastructure across all industries, its targeting is purposeful and tactical in nature. Globally, the\nFSB has used Snake to collect sensitive intelligence from high-priority targets, such as government\nnetworks, research facilities, and journalists. As one example, FSB actors used Snake to access and\nexfiltrate sensitive international relations documents, as well as other diplomatic communications,\nfrom a victim in a North Atlantic Treaty Organization (NATO) country. Within the United States, the\nFSB has victimized industries including education, small businesses, and media organizations, as\nwell as critical infrastructure sectors including government facilities, financial services, critical\nmanufacturing, and communications.\n\nThis Cybersecurity Advisory (CSA) provides background on Snake’s attribution to the FSB and\ndetailed technical descriptions of the implant’s host architecture and network communications. This\nCSA also addresses a recent Snake variant that has not yet been widely disclosed. The technical\ninformation and mitigation recommendations in this CSA are provided to assist network defenders in\ndetecting Snake and associated activity. For more information on FSB and Russian state-sponsored\ncyber activity, please see the joint advisory Russian State-Sponsored and Criminal Cyber Threats to\nCritical Infrastructure and CISA’s Russia Cyber Threat Overview and Advisories webpage.\n\n_To report suspicious or criminal activity related to information found in this Joint Cybersecurity Advisory, contact_\n_your local FBI field office or CISA’s 24/7 Operations Center at_ _Report@cisa.gov or (888) 282-0870. When_\n_available, please include the following information regarding the incident: date, time, and location of the incident;_\n_type of activity; number of people affected; type of equipment used for the activity; the name of the submitting_\n_company or organization; and a designated point of contact._\n\n_This document is marked TLP:CLEAR. Recipients may share this information without restriction. Information is_\n_subject to standard copyright rules. For more information on the Traffic Light Protocol, see cisa.gov/tlp/._\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n## TABLE OF CONTENTS\n\n### Summary ......................................................................................................................................... 1\n\n Introduction ..................................................................................................................................... 4\n\n#### What is Snake? ............................................................................................................................ 4\n\n Background ................................................................................................................................... 4\n\n Attribution ..................................................................................................................................... 5\n\n Victimization ................................................................................................................................. 5\n\n Other Tools and TTPs Employed with Snake ........................................................................... 6\n\n Snake Architecture ...................................................................................................................... 6\n\n Capitalizing on Mistakes ............................................................................................................. 7\n\n### Snake Host-Based Technical Details ....................................................................................... 8\n\n#### Installer .......................................................................................................................................... 8\n\n On-Disk Components ................................................................................................................... 8\n\n The Queue ................................................................................................................................... 11\n\n### Snake Network Communications ........................................................................................... 17\n\n#### Network Obfuscation ................................................................................................................. 17\n\n Snake’s Network Authentication Technique (“ustart”) ........................................................ 17\n\n Snake UDP .................................................................................................................................. 19\n\n Snake HTTP ................................................................................................................................. 20\n\n Snake TCP ................................................................................................................................... 21\n\n Snake “enc” Layer ...................................................................................................................... 23\n\n### Snake Application Layer ........................................................................................................... 24\n\n#### Command 0x15-byte Header ................................................................................................... 24\n\n Command Encryption ................................................................................................................ 24\n\n Command Decoding .................................................................................................................. 25\n\n High Commands ......................................................................................................................... 26\n\n Queue Commands ..................................................................................................................... 27\n\n Forward Commands .................................................................................................................. 28\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n### Snake Implant Operation .......................................................................................................... 31\n\n#### Active Operations ....................................................................................................................... 31\n\n Passive Operations .................................................................................................................... 31\n\n### Mitigations .................................................................................................................................... 35\n\n#### Network-Based Detection ......................................................................................................... 35\n\n Host-Based Detection ................................................................................................................ 37\n\n Memory Analysis ........................................................................................................................ 40\n\n### Prevention ..................................................................................................................................... 42\n\n#### Change Credentials and Apply Updates ................................................................................. 42\n\n Execute Organizational Incident Response Plan .................................................................. 42\n\n### Appendix ........................................................................................................................................ 43\n\n#### Partnership .................................................................................................................................. 43\n\n Disclaimer ................................................................................................................................... 43\n\n MITRE ATT&CK® Techniques ................................................................................................... 43\n\n Volatility Plugin ........................................................................................................................... 47\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n## INTRODUCTION\n\n### What is Snake?\n\nWe consider Snake to be the most sophisticated cyber espionage tool in the FSB’s arsenal. The\nsophistication of Snake stems from three principal areas. First, Snake employs means to achieve a\nrare level of stealth in its host components and network communications. Second, Snake’s internal\ntechnical architecture allows for easy incorporation of new or replacement components. This design\nalso facilitates the development and interoperability of Snake instances running on different host\noperating systems. We have observed interoperable Snake implants for Windows, MacOS, and Linux\noperating systems. Lastly, Snake demonstrates careful software engineering design and\nimplementation, with the implant containing surprisingly few bugs given its complexity.\n\nFollowing open source reporting by cybersecurity and threat intelligence companies on Snake tactics,\ntechniques, and procedures (TTPs), the FSB implemented new techniques to evade detection. The\nmodifications to the implant enhanced challenges in identifying and collecting Snake and related\nartifacts, directly hampering detection from both host- and network-based defensive tools.\n\nThe effectiveness of this type of cyber espionage implant depends entirely on its long-term stealth,\nsince the objective of an extended espionage operation involves remaining on the target for months\nor years to provide consistent access to important intelligence. The uniquely sophisticated aspects of\nSnake represent significant effort by the FSB over many years to enable this type of covert access.\n\n### Background\n\nThe FSB began developing Snake as “Uroburos” in late 2003. Development of the initial versions of\nthe implant appeared to be completed around early 2004, with cyber operations first conducted using\nthe implant shortly thereafter. The name Uroburos is appropriate, as the FSB cycled it through nearly\nconstant stages of upgrade and redevelopment, even after public disclosures, instead of abandoning\nit. The name appears throughout early versions of the code, and the FSB developers also left other\nunique strings, including “Ur0bUr()sGoTyOu#”, which have publicly come back to haunt them.\n\nUnique features in early versions of Uroburos included a low\nresolution image of a portion of a historical illustration of an\nuroboros by the German philosopher and theologian Jakob\nBöhme. One approach to a tertiary backdoor used this image\nas the key. The same image had also been embedded in other\nSnake-related components. The image, blown up to a higher\nresolution, is shown at right.\n\nIn addition, early FSB developers of the Snake implant left\nportions of unique code throughout the implant which reveal\ninside jokes, personal interests, and taunts directed at security\nresearchers. For instance, the “Ur0bUr()sGoTyOu#” string\nreferenced above was replaced with “gLASs D1cK” in 2014\nfollowing some of the public cybersecurity reporting.\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n### Attribution\n\nWe attribute Snake operations to a known unit within Center 16 of the FSB.[1] This unit more broadly\noperates the numerous elements of the Turla[2] toolset, and has subunits spread throughout Russia in\na reflection of historical KGB signals intelligence operations in the Soviet Union. Snake has been a\ncore component of this unit’s operations for almost as long as Center 16 has been part of the FSB.[3]\nThe extensive influence of Snake across the Turla toolset demonstrates its impact on practically\nevery aspect of the unit’s modern era of cyber operations.\n\nDaily operations using Snake have been carried out from an FSB facility in Ryazan, Russia, with an\nincrease in Snake activity during FSB working hours in Ryazan, approximately 7:00 AM to 8:00 PM,\nMoscow Standard Time (GMT+3). The main developers were Ryazan-based FSB officers known by\nmonikers included in the code of some versions of Snake. In addition to developing Snake, Ryazanbased FSB officers used it to conduct worldwide operations; these operations were different from\nothers launched from Moscow or other FSB sites based on infrastructure and techniques.\n\nWhile the development and re-tooling of Snake has historically been done by Ryazan-based FSB\nofficers, Snake operations were also launched from an FSB Center 16-occupied building in Moscow.\nOur investigations have identified examples of FSB operators using Snake to its full potential, as well\nas FSB operators who appeared to be unfamiliar with Snake’s more advanced capabilities. These\nobservations serve to illustrate the difficulty in using such an advanced toolset across the various\ngeographically dispersed teams comprising this unit within FSB Center 16.\n\nWe have been collectively investigating Snake and Snake-related tools for almost 20 years, as well\nas other operations by this unit since the 1990s. During that time, the FSB has used Snake in many\ndifferent operations, and they have demonstrated the value placed in this tool by making numerous\nadjustments and revisions to keep it viable after repeated public disclosures and other mitigations.\nSnake’s code and multiple Snake-related tools have been either a starting point or a key influence\nfactor for a diverse range of other highly prolific implants and operational tools in the Turla family.\nMost notably, this has included Carbon (aka Cobra)—derived from Snake’s code base—and the\nsimilarly Snake-adjacent implant Chinch (currently known in open sources as ComRAT).\n\n### Victimization\n\nWe have identified Snake infrastructure in over 50 countries across North America, South America,\nEurope, Africa, Asia, and Australia, to include the United States and Russia itself. Although Snake\nleverages infrastructure across all industries, its targeting is purposeful and tactical in nature. For\ninstance, if an infected system did not respond to Snake communications, the FSB actors would\nstrategically re-infect it within days. Globally, the FSB has used Snake to collect sensitive intelligence\nfrom high priority targets, such as government networks, research facilities, and journalists. As one\nexample, FSB actors used Snake to access and exfiltrate sensitive international relations documents,\n\n1 This unit is distinct from a sister unit in FSB Center 16 which the FBI publicly attributes to Dragonfly operations.\n2 Turla is one of many open source terms used to describe the family of implants used by this FSB Center 16 unit. Snake\nand the broader Turla family have also previously been referenced in private sector reporting using the names Krypton,\nVenomous Bear, Penquin, Agent.BTZ, ComRAT, Waterbug, Tavdig, Wipbot, Epic Turla, Mosquito, Carbon, and others.\n3 The 3rd Chief Directorate of FAPSI was transferred to the FSB as Center 16 when FAPSI was dissolved in 2003.\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nas well as other diplomatic communications, from a victim in a NATO country. Within the United\nStates, the FSB has victimized industries including education, small businesses, and media\norganizations, as well as critical infrastructure sectors including government facilities, financial\nservices, critical manufacturing, and communications.\n\n### Other Tools and TTPs Employed with Snake\n\nThe FSB typically deploys Snake to external-facing infrastructure nodes on a network, and from there\nuses other tools and TTPs on the internal network to conduct additional exploitation operations. Upon\ngaining and cementing ingress into a target network, the FSB typically enumerates the network and\nworks to obtain administrator credentials and access domain controllers. A wide array of mechanisms\nhas been employed to gather user and administrator credentials in order to expand laterally across\nthe network, to include keyloggers, network sniffers, and open source tools.[4]\n\nTypically, after FSB operators map out a network and obtain administrator credentials for various\ndomains in the network, regular collection operations begin. In most instances with Snake, further\nheavyweight implants are not deployed, and they rely on credentials and lightweight remote-access\ntools internally within a network. FSB operators sometimes deploy a small remote reverse shell along\nwith Snake to enable interactive operations. This triggerable reverse shell, which the FSB has used\nfor around 20 years, can be used as a backup access vector, or to maintain a minimal presence in a\nnetwork and avoid detection while moving laterally.[5]\n\n### Snake Architecture\n\nSnake’s architectural design reflects professional software engineering practices. Critical pathways\nwithin the implant are made of stacks of loosely coupled components that implement well-designed\ninterfaces. In addition to facilitating software development and debugging, this construction allows\nSnake to use multiple different components for the same purpose, choosing the specific component\nbased on environmental considerations. For example, Snake’s custom network communications\nprotocols function as a stack. All implementations use an encryption layer and a transport layer, such\nas Snake’s custom HTTP or raw TCP socket protocol. Each layer of the Snake network protocol stack\nsolely implements a specified interface for operability with the two adjacent layers. The encryption\nlayer and underlying transport layer thus function independently, so any custom Snake network\nprotocol can employ an encryption overlay without any change to the encryption layer code.[6]\n\nThis modularity allows Snake operators to choose the most logical network transport for the given\nenvironment without affecting Snake’s other functionality. When using a compromised HTTP server\nas part of the Snake P2P network, the operators can ensure that all traffic to this machine follows the\nSnake custom HTTP protocol and thereby blends effectively with legitimate traffic. In the context of a\ncompromised machine that legitimately allows secure shell (SSH) connections, Snake can utilize its\ncustom raw TCP socket protocol instead of its custom HTTP protocol. All other layers of the Snake\nprotocol stack, from the immediately adjacent transport encryption layer to the distant command\nprocessing layer, can and do remain entirely agnostic to the transport layer as long as it implements\n\n4 MITRE ATT&CK IDs: [T0840], [T1003], [T1040], [T1046], [T1056.001], [T1078], [T1083], [T1135], [T1482]\n5 MITRE ATT&CK IDs: [T1190], [T1570], [T1587.001], [T1608]\n6 MITRE ATT&CK IDs: [T1095], [T1547.006], [T1587.001]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nits interface correctly. This architecture also allows the Snake developers to easily substitute a new\ncommunications protocol when they believe one has been compromised, without necessitating any\ndownstream changes in the code base. Lastly, this design facilitates the development of fully\ninteroperable Snake implants running on different host operating systems.\n\nSnake’s technical sophistication extends from the software architecture into the lower-level software\nimplementation. Original versions of Snake were developed as early as 2003, before many of the\nmodern programming languages and frameworks that facilitate this type of modular development\nwere available. Snake is written entirely in C, which provides significant advantages in low-level\ncontrol and efficiency, but which does not provide direct support for objects or interfaces at the\nlanguage level and provides no assistance with memory management. The developers of Snake\nsuccessfully implemented the implant’s complex design in C with very few bugs, including careful\navoidance of the common pitfalls associated with null-terminated strings and the mixing of signed and\nunsigned integers. Additionally, the developers demonstrate an understanding of computer science\nprinciples throughout the implant’s implementation. This includes selecting and correctly coding\nasymptotically optimal algorithms, designing and utilizing efficient custom encoding methodologies\nthat closely resemble common encoding schemes, and handling the numerous possible errors\nassociated with systems-level programming in a secure manner.\n\n### Capitalizing on Mistakes\n\nAlthough the Snake implant as a whole is a highly sophisticated espionage tool, it does not escape\nhuman error. A tool like Snake requires more familiarity and expertise to use correctly, and in several\ninstances Snake operators neglected to use it as designed. Various mistakes in its development and\noperation provided us with a foothold into the inner workings of Snake and were key factors in the\ndevelopment of capabilities that have allowed for tracking Snake and the manipulation of its data.\n\nThe FSB used the OpenSSL library to handle its Diffie-Hellman key exchange. The Diffie-Hellman\nkey-set created by Snake during the key exchange is too short to be secure. The FSB provided the\nfunction DH_generate_parameters with a prime length of only 128 bits, which is inadequate for\nasymmetric key systems. Also, in some instances of what appeared to be rushed deployments of\nSnake, the operators neglected to strip the Snake binary. This led to the discovery of numerous\nfunction names, cleartext strings, and developer comments as seen in the following figure.\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n## SNAKE HOST-BASED TECHNICAL DETAILS\n\nThe FSB has quickly adapted Snake when its capabilities have been publicly disclosed by private\nindustry. Snake therefore exists in several variants, as it has evolved over almost 20 years. This CSA\nfocuses on one of the more recent variants of Snake that up until now has not been widely disclosed.\nOlder variants of Snake will be discussed briefly where applicable, but not discussed in depth, as\nmany details of earlier Snake variants already exist in the public domain.\n\n### Installer\n\nThe Snake installer has gone by various names throughout Snake’s existence (e.g., “jpinst.exe”). This\nadvisory will describe the version of the installer which regularly used the name “jpsetup.exe”. This\nexecutable is packed using a customized obfuscation methodology. The developers appear to have\nadded the unpacking functionality from an open source project for viewing JPEG files. This technique\nserves to obfuscate the unpacking code within an otherwise legitimate code base.[7] The unpacking\ncode extracts an executable, herein referred to as the “Png Exe”, and it extracts an AES encrypted\nblob from the Png Exe’s resources, which herein will be referred to as the “Png Resource”.[8]\n\nThe jpsetup.exe installer requires two arguments to be passed via the command line for execution.\nThe first argument is a wide character string hashed with SHA-256 twice, and the resulting value of\nthese computations becomes the AES key that decrypts the Png Resource. The AES initialization\nvector (IV) consists of the first 16 bytes of the second argument to jpsetup.exe after prepending the\nargument with a wide character “1” string. Once decrypted, the Png Resource becomes an\nexecutable that will be referred to herein as “Stage 2”.[9]\n\nWhen unpacked, many components are extracted from Stage 2’s resources. Several of the resources\nare executables with additional resources of their own. Stage 2 creates structures from its resources,\nwhich ultimately become the host artifacts of Snake.\n\n### On-Disk Components\n\nAs Windows has been the most prevalent operating system targeted by Snake, this document will\nonly discuss the Windows-based artifacts; however, Snake can be cross-compiled and is capable of\nrunning on other operating systems.\n\n##### On-Disk Obfuscation\n\nSnake’s host architecture and network communications allow an unusual level of stealth. Snake\nmakes inventive use of its kernel module in both of these contexts. All known Windows versions of\nSnake have used a concealed storage mechanism to hide host componentry. In addition to using the\nkernel module to remove the relevant components from any listing returned by the operating system,\nSnake utilizes the kernel module to mediate any requests between Snake’s user mode components\nand the concealed storage mechanism, which itself is encrypted with a unique per-implant key. This\n\n7 The Snake developers have long used custom packers for the implant. This packer had several options for disguising the\ninstaller on a host. The first was as a JPEG viewer; later options included disguising the installer as Notepad++ or 7zip.\n8 MITRE ATT&CK IDs: [T1027.002], [T1140], [T1546.016], [T1588], [T1610]\n9 MITRE ATT&CK IDs: [T1573.001], [T1573.002]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nunique keying creates detection difficulties even for tools that are independent of the compromised\noperating system, since simple signatures targeting Snake host components would be ineffective.[10]\n\n##### Persistence Mechanism\n\nThe Snake version primarily discussed in this advisory registers a service to maintain persistence on\na system. Typically, this service is named “WerFaultSvc,” which we assess was used to blend in with\nthe legitimate Windows service WerSvc. On boot, this service will execute Snake’s WerFault.exe,\nwhich Snake developers chose to hide among the numerous valid Windows “WerFault.exe” files in\nthe %windows%\\WinSxS\\ directory. Executing WerFault.exe will start the process of decrypting\nSnake’s components and loading them into memory.[11]\n\n10 MITRE ATT&CK IDs: [T1014], [T1027], [T1547.006], [T1610]\n11 MITRE ATT&CK IDs: [T1027], [T1036], [T1140], [T1564], [T1569.002]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n##### Encrypted Registry Key Data\n\nUpon execution, Snake’s WerFault.exe will attempt to decrypt an encrypted blob within the Windows\nregistry that is typically found at HKLM:\\SOFTWARE\\Classes\\.wav\\OpenWithProgIds. The encrypted\ndata includes the AES key, IV, and path that is used to find and decrypt the file containing Snake’s\nkernel driver and kernel driver loader. The registry object’s structure can be seen on the right side of\nthe following figure. Snake uses Microsoft Windows Cryptography API: Next Generation (CNG) key\nstore to store the AES key needed to decrypt the registry object.[12]\n\n##### Kernel Driver and Custom Loader\n\nSnake’s installer drops the kernel driver and a custom DLL which is used to load the driver into a\nsingle AES encrypted file on disk. Typically, this file is named “comadmin.dat” and is stored in the\n%windows%\\system32\\Com directory. The structure of this file can be seen on the left side of the\nfigure above. The key, IV, and path to comadmin.dat are stored in the encrypted registry blob.[13]\n\n12 MITRE ATT&CK IDs: [T1106], [T1112], [T1547.006]\n13 MITRE ATT&CK IDs: [T1027], [T1547.006], [T1569.002], [T1574.002]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n##### The Queue File\n\nThe last host-based artifact to discuss is the Queue File. Typically, this file has been found within the\n%windows%\\Registration directory with the format of <RANDOM_GUID>.<RANDOM_GUID>.crmlog,\nand is decrypted by Snake’s kernel driver. Due to the complexity and importance of the Queue File,\nits details are discussed at length in the following subsection.[14]\n\n### The Queue\n\nThe Queue is a Snake structure that contains various pieces of information, including key material,\ncommunication channels, modes of operation, the principal user mode component, etc., that Snake\nrequires for successful operation. It should be noted that this is a name used by the developers and is\nnot equivalent to a “queue” in the normal context of computer science. The Queue data is saved on\ndisk in the Queue File, which is a flat file with a substructure that includes a 0x2c-byte file header\nfollowed by data blocks. Each data block corresponds to exactly one Queue Item, which could be, for\nexample, a simple configuration parameter, a Snake command, or an entire embedded executable.\nEach Queue Item is associated with a specific Queue Container.\n\n##### Queue Containers and Items\n\nEach Container is identified by its Type and Instance values. Each Container Type holds the same\ntype of information used by the Snake implant for a specific purpose. The following table shows the\nvarious Container Types and their functions. A Queue can have multiple Containers of the same\nType, but each of these Containers will have different Instance values.\n\n14 MITRE ATT&CK IDs: [T1027], [T1112], [T1564], [T1610]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nThe data in each Container in the Queue is separated into Queue Items with the 0x40-byte metadata\nstructure shown in the following table. The data content of the Queue Item immediately follows this\nstructure. The Queue Items in each Container are distinguished by their corresponding Item Number\nas well as their Item Type identifier. The Item Number is assigned by the Snake implant itself, while\nSnake operators generally refer to the Item Type value when trying to reference a specific item.\n\n##### Queue File Encryption\n\nIn previous versions of Snake, the Queue File existed within an encrypted covert store. The data\nbelonging to the Queue Items themselves were also CAST-128 encrypted. In more recent versions,\nthe covert store was removed, and the Queue File exists by itself on disk. The Queue Items inside the\nQueue File are still encrypted with CAST-128, and in addition, the full Queue File is also CAST-128\nencrypted. The CAST keys used to encrypt the Queue Items within a Container Instance can be\nfound in that Instance's corresponding 0x2 Container as Item Type 0x229 (see below). The key and\nIV used to encrypt the Queue File can be found by decoding strings within Snake’s kernel driver.\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n##### Container Descriptions\n\n0xb Container\n\nThe 0xb Container lists the available modes of operation for a given Snake implant. When using a\ncertain mode, Snake uses a specific set of Containers and communication channels. Each infection\ncan use up to four different modes. Each mode in the 0xb Container will have a Container Instance\nvalue that all Containers associated with this mode will use, except for the 0x3 Container.[15]\n\n0x0 Container\n\nThe 0x0 Container handles incoming commands/data for the host of the Snake infection. Commands\nwill be queued in this Container until the implant is ready to execute them.\n\n15MITRE ATT&CK IDs: [T1104]\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n0x1 Container\n\nThe 0x1 Container handles outbound commands/data for the host of the Snake infection. The data\nwill be queued within the 0x1 Container until the implant is ready to exfiltrate them.\n\n0x2 Container\n\nThe 0x2 Container holds the configuration information for the mode to which it corresponds. Various\npieces of information vital to Snake’s successful operation are stored within these Containers. This\nsubsection will discuss a subset of the parameters that can be found within the 0x2 Container.\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nPivotal key information can be found within the 0x2 Containers. This includes the inbound and\noutbound RSA keys (Items 0x228 and 0x227, respectively), the CAST key (Item 0x229) used to\nencrypt the individual items within the Queue Container, pre-shared keys used for the top layer of\nencryption in Snake’s network communication protocol, and a quasi-unique value for the implant,\ncalled the “ustart” value, needed for Snake network connectivity.\n\nSnake is constantly passing data between its kernel and user mode components. The methodology\n(generally, named pipes) used to make these communications is listed in Items 0x65-0x6f of the 0x2\nContainer. Items 0x70-0x7a list the parameters necessary to establish these communications.[16]\n\nItems 0xc9-0xd3 contain details of up to ten other Snake infections, referred to as “communication\nchannels”, which the implant can communicate with during Passive Operations. The parameters\nneeded to establish Snake sessions with the other hosts can be found in Items 0xd4-0xde.\n\nMany additional data points, such as the process name where Snake injected itself or the modules\nSnake has loaded from its 0x3 Container, can be found within 0x2 Containers.\n\n0x3 Container\n\nThe 0x3 Container houses embedded files and modules for Snake. A single 0x3 Container will be\naccessible to all Containers in the Queue. The 0x3 Container has its own dedicated 0x2 Container\nthat only includes a single Queue Item of Item Type 0x229 (a CAST-128 key). This key will be used to\nencrypt and decrypt all of the embedded files and modules within the 0x3 Container.\n\n16 MITRE ATT&CK IDs: [T1559]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nThe Item Types assigned to the embedded files and modules within the 0x3 Container are consistent\nacross all of the Snake infections within Snake’s P2P network. For example, the 0x01 Item Type is\nthe Zlib library, and therefore any time an Item Type of 0x01 is seen within the 0x3 Container of a\nSnake infection, that file is always the Zlib library. The implant’s 0x2 Container will keep track of\nlibraries that it has loaded. If the DLL is a file on disk, the full path to the DLL is saved in the 0x2\nContainer. If the library was loaded from a 0x3 Container, the loaded module will be displayed in the\nimplant’s 0x2 Container in the format “&<Item Type (within 3 container) of loaded module>”.[17]\n\n0x4 Container\n\nThe 0x4 Container logs command activity. Each Queue Item within the Container is a log of a single\nexecuted or attempted command. Each mode will have its own corresponding 0x4 Container.\n\n0x5 Container\n\nThe 0x5 Container holds Snake network logs, noting any IP address that has connected to this\nimplant. Some versions of Snake no longer make use of this Container.\n\n0x6 Container\n\nThe 0x6 Container saves commands that are set to execute at specific times. A Queue Item is\ncreated for each scheduled command.\n\n0x7 Container\n\nThe 0x7 Container logs the IP addresses of any other Snake implants that have connected to this\nimplant during Passive Operations. The commands 0x79 (Read Agents Track) and 0x7a (Clear\nAgents Track) are used to interact with this Container. Note that the command 0x7a had been\ndeprecated in some versions of Snake and returns the error “function unsupported” if called.\n\n17 MITRE ATT&CK IDs: [T1055.001]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n## SNAKE NETWORK COMMUNICATIONS\n\nSnake’s network communications are encrypted, fragmented, and sent using custom methodologies\nthat ride over common network protocols, including both raw TCP and UDP sockets and higher-level\nprotocols like HTTP, SMTP, and DNS. Snake’s protocols for HTTP and TCP are the most commonly\nseen, but functionality exists for UDP, ICMP, and raw IP traffic. Snake’s network communications are\ncomprised of “sessions”, which are distinct from the sessions associated with the legitimate protocol it\nis riding on top of (e.g., TCP sessions). The Snake session is then comprised of distinct commands.\nBoth Snake’s custom transport encryption layer (“enc”) and Snake’s Application Layer have their own\nencryption mechanisms, where the enc layer operates on an individual P2P session and the Snake\nApplication Layer provides end-to-end encryption between the controller (i.e., point of origin) and the\ncommand’s ultimate destination. The following figure details Snake’s communication protocol stack.[18]\n\n### Network Obfuscation\n\nSnake’s use of its kernel module also facilitates stealthy network communications. To participate fully\nin Snake’s P2P network, implanted machines which are not the ultimate target must act as servers for\nother Snake nodes. Snake’s kernel module, along with a thoughtfully designed mechanism for\ndistinguishing Snake traffic from legitimate client traffic, allows the implant to function as a server in\nthe Snake P2P network without opening any new ports, greatly complicating detection efforts.\nAdditionally, Snake’s custom network communication protocols are designed to blend with traffic that\nthe compromised server normally would receive. This allows Snake operators to use legitimate\nservers as infrastructure, which reduces the effectiveness of simple IP address or domain blocking\nwithout needing to open new ports or send unusual looking traffic to this infrastructure.[19]\n\n### Snake’s Network Authentication Technique (“ustart”)\n\nSnake uses its custom HTTP and raw socket TCP based protocols for large data communications.\nWith these protocols and others, Snake employs a specific authentication mechanism to distinguish\nSnake traffic from legitimate traffic destined for application software on the compromised server. This\n\n18 MITRE ATT&CK IDs: [T1001.003], [T1071], [T1071.003], [T1090.003], [T1095], [T1132], [T1572], [T1573]\n19 MITRE ATT&CK IDs: [T1001.003], [T1071], [T1132.002], [T1547.006], [T1584]\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\ntechnique enables one of the uniquely sophisticated aspects of Snake, which is its ability to function\neffectively as server software without opening any further ports on the compromised system. The\nrelevant per-implant authentication value is referred to as the “ustart” and is stored in the implant’s\nQueue File. There are multiple forms of the ustart value, including “ustart”, “ustart2”, and “ustartl”.[20]\n\nRather than open a listening socket on a specified TCP port, the Snake kernel module intercepts the\nfirst client-to-server packet following the 3-way handshake in every TCP session. The kernel module\nthen determines whether or not the contents of that packet are in fact valid for the ustart value of that\ntarget Snake implant. If so, the Snake kernel module forwards that packet and any future packets in\nthe same TCP session to Snake’s own processing functionality, and the (presumably legitimate)\napplication listening on that port remains unaware of this TCP session. If not, the Snake kernel\nmodule allows the packet—and the rest of the TCP session as it occurs—to reach the legitimate\nlistening application, for example web server software. See the following for an illustration.[21]\n\nAll of the ustart versions perform authentication by sending a random nonce along with data that\ncomprises a mathematical operation on the combination of the nonce and the ustart value itself. The\n\n20 MITRE ATT&CK IDs: [T1132.002], [T1572]\n21 MITRE ATT&CK IDs: [T1071.001], [T1547.006]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nreceiving machine then extracts the nonce and performs the same computations to authenticate the\nsending machine. The ustart2 and ustartl versions use the Fowler-Noll-Vo (FNV) hash algorithm to\ngenerate the overall authentication value from the nonce and the ustart. This mechanism is slightly\ndifferent in the custom Snake HTTP protocol versus the custom Snake TCP protocol.\n\nUsing the ustart methodology, a node in the Snake P2P network can function as a server without\nopening any otherwise closed ports and without interfering in the compromised server’s legitimate\nfunctionality. Snake will only communicate over TCP ports on which another application is actively\nlistening. This technique makes detecting Snake compromises through network traffic monitoring far\nmore difficult. Inbound traffic to an unexpected TCP port can be detected or blocked using standard\nfirewall or network intrusion detection functionality. Replacing a legitimate service application with a\nmodified executable can lead to detection at either the host or network level. Snake’s technique\nbypasses both of these mitigations. When combined with the fact that Snake traffic looks similar to\nexpected traffic, especially in the case of Snake’s HTTP based protocols, this renders detecting\nSnake communications difficult absent detailed knowledge of Snake’s custom protocols.\n\n### Snake UDP\n\n##### Outbound Communications via DNS Query\n\nSnake uses a specialized communications protocol to encode information in seemingly standard DNS\nqueries run via the Windows or POSIX API function gethostbyname, depending on the version.[22]\n\nSnake outbound DNS requests consist of character strings that are constructed to resemble standard\ndomain names. The actual information being transmitted from the implant is contained in the part of\nthe character string prior to the first ‘.’ character. For illustration purposes, this subsection will outline\nhow an arbitrary string of bytes is manipulated and then encoded to form an outbound Snake DNS\nrequest carrying data provided by the implant.\n\nSnake outbound DNS requests originally take the form of byte arrays stored on the stack as the\nimplant progresses through the communications function. The byte array has the following structure.\n\nOnly the low-order seven bits of the flags byte are used, and they have the following significance.\n\n22 MITRE ATT&CK IDs: [T1001.003], [T1071.004], [T1132.002]\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nAfter calculating and obfuscating the byte array values shown above, Snake encodes these byte\nvalues as de-facto base32 text, using the ten digits 0-9 and the 26 lowercase ASCII letters a-z, with v,\nw, x, y, and z all corresponding to the same value, as only 32 distinct characters are needed. Snake\nthen inserts ‘-‘ characters at specified locations and sends the DNS request using the gethostbyname\nfunction. The resulting encoded string mimics a legitimate DNS request; because characters after the\nfirst ‘.’ are not part of the implant’s communications, any arbitrary suffix (e.g., “.com”) can be used.[23]\n\n##### Inbound Communications via DNS Query Response\n\nAfter sending the encoded DNS request, Snake parses the returned information. In a normal DNS\nrequest, the returned hostent structure contains a list of IPv4 addresses as 32-bit unsigned integers if\nthe domain resolves to one or more IPv4 addresses. In the Snake DNS protocol, these 32-bit integers\nrepresent the covert channel data. The Snake implant sorts the 32-bit integers by the highest order\nnibble and then interprets the remaining 28 bits of each integer as the actual encoded data.\n\nThe Snake DNS protocol thus provides a well-concealed, low-bandwidth communications channel.\nFor larger bandwidth communications, Snake uses its custom HTTP and TCP protocols.\n\n### Snake HTTP\n\nThe most common custom protocol that Snake uses is its “http” protocol, which rides on top of\nstandard HTTP. It generally looks like normal HTTP communications, including a lot of base64looking strings, thus blending well with normal network traffic. There have been multiple iterations of\nSnake’s http protocol, though the differences are only in the encoding; once that is peeled away, the\nunderlying Snake http protocol is the same. For the purposes of this document, Snake’s former\nversion of HTTP will be referred to as “http” and its more recent version as “http2”.[24]\n\nSnake communications using http2 are contained within seemingly legitimate Application Layer HTTP\ncommunications. In the client-to-server direction, the implant data is contained within an HTTP header\nfield of a GET request, unless the data is over a certain size (usually 256 bytes, but configurable).\nObserved field keys have included: Auth-Data, Cache-Auth, Cookie, and Cockie (note misspelling).\nThis list is not exhaustive; any standard HTTP header field can be used. The communication itself is\ncontained in the legitimate HTTP header field’s value, meaning the content following the ‘:’ character\nand any whitespace immediately thereafter. In HTTP GET requests, the implant generally uses the\ndefault path ‘/’, but this is not required and is configurable.[25]\n\n23 MITRE ATT&CK IDs: [T1001.003], [T1071.004], [T1132.002]\n24 MITRE ATT&CK IDs: [T1001.003], [T1071.001], [T1572]\n25 MITRE ATT&CK IDs: [T1001.003], [T1071.001]\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nLarger client-to-server Snake http2 requests are contained in the body of an HTTP POST request,\nand server-to-client communications are contained in the body of the HTTP response.\n\nAll client-to-server Snake http and http2 requests begin with the ustart authentication. The specifics\nvary with each ustart version, but in each case the random nonce and the computed function of the\nnonce and ustart value are encoded in a manner which closely resembles the rest of the Snake\ncommunication. Since Snake http and http2 implant sessions can span multiple TCP sessions, the\nustart authentication mechanism is included in every client-to-server communication.\n\n##### Base62 Encoding\n\nSnake’s http2 protocol uses a custom base62 encoding scheme that has the following differences\nfrom base64. Base62 uses 62 semantically significant characters instead of 64. The ratio of encodedto-decoded characters in base62 is less dense (11:8) than the ratio base64 can achieve (12:9). Also,\nbase62 uses extraneous characters in certain instances that have no semantic significance.[26]\n\nThe base62 characters of semantic significance are the 62 strict alphanumeric characters: [0-9A-Zaz]. The extraneous characters that can be present in a base62 string—but which have no semantic\nsignificance—are: ‘/’, ‘;’, ‘=’, and ‘_‘ (underscore). When present, these characters are removed prior\nto performing the decoding process. A valid base62 string can have up to 11 of these extraneous\ncharacters. A regular expression for base62 is included in the Mitigations section of this CSA.\n\n##### http and http2 Metadata Structure\n\nAfter the base62 decoding is completed, if necessary, the remaining data begins with an 8-byte\nmetadata structure that provides rudimentary sessionization on top of the stateless HTTP. Snake’s\nhttp and http2 client-to-server communications have three de-facto parts, which are concatenated into\na single HTTP header value. These parts are: 1) an announce or authentication string, 2) a custom\nmetadata structure, and 3) payload data. The metadata structure consists of the following:\n```\n     struct http_meta {\n        uint32_t session_number;\n        uint16_t communication_number;\n        uint8_t flags;\n        uint8_t checksum;\n     };\n\n```\nSnake uses the session_number and communication_number fields to provide its own custom\nsessionization on top of the stateless Application Layer HTTP protocol. The checksum byte serves to\nvalidate the integrity of the structure and must equal the sum of the first seven bytes modulo 256.\n\n### Snake TCP\n\nSnake has the ability to communicate through POSIX-style TCP sockets. The implant’s custom TCP\nprotocol, which herein will be called “tcp”, uses the reliability features of the underlying TCP protocol.\nThus, in the implant’s custom tcp protocol, the concept of a TCP session and an implant “session” are\nthe same, whereas in the implant’s custom http protocols, one implant session could span multiple\n\n26 MITRE ATT&CK IDs: [T1132.002], [T1572]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nTransport Layer TCP sessions. Since the implant’s overall communications protocol is based on the\nidea of commands and responses, Snake depends on being able to specify the length of any given\ncommand and response so the recipient Snake node knows when a particular communication ends.\nSnake achieves this in the custom tcp protocol by prefacing each communication with its length\nencoded as a 32-bit big-endian unsigned integer.[27]\n\nImmediately following the TCP 3-way handshake, the implant completes the ustart authentication for\nthis session. Since Snake tcp sessions are mapped one-to-one with an underlying protocol TCP\nsession, the ustart authentication only occurs once per session, rather than with each client-to-server\ncommunication as in Snake http and http2. The Snake tcp ustart mechanism is similar to the Snake\nhttp and http2 mechanisms, except that for certain ustart versions, Snake tcp uses a raw binary ustart\nwhich is not encoded in printable characters.\n\nAfter the ustart authentication, the implant will begin sending length-data pairs. These pairs can be\nsent in the same packet or in two (or theoretically more) separate packets, but the pattern of lengthdata pairs will be present in each half of the stream (i.e., each direction) for the entirety of the implant\ncommunications for the remainder of the TCP session. Specifically, a length-data pair will consist of\nthe length encoded as a big-endian 32-bit unsigned integer followed by data of exactly that length.\nFor example, consider the instance where the implant is sending the following 4 arbitrary bytes:[28]\n```\n     89 ab cd ef\n\n```\nThe on-wire communication from the implant would send the integer value 4 encoded as a big-endian\n32-bit integer, followed by the actual 4 bytes themselves, as shown below. This could be split across\ntwo (or theoretically more) packets.\n```\n     00 00 00 04 89 ab cd ef\n\n```\nThe custom tcp protocol (as well as all custom http protocols) have been used in conjunction with the\nSnake enc protocol. Details of the Snake enc protocol are provided in the following subsection. Due\nto the manner in which the Snake enc and Snake tcp protocols interact, the first six length-data pairs\nof each TCP half-stream (following the single client-to-server announce or authentication packet\ndescribed above) will have known lengths. Specifically, each half-stream will begin with length-data\npairs of the following lengths: 0x8, 0x4, 0x10, 0x1, 0x10, 0x10. Note that these are the lengths of the\nraw data, so each communication will be preceded by a 4-byte big-endian integer specifying the\ncorresponding length. Thus, one of the half-streams could have the following TCP content:\n```\n     00 00 00 08 12 34 56 78 9a bc de f0\n     00 00 00 04 89 ab cd ef\n     00 00 00 10 12 34 56 78 9a bc de f0 12 34 56 78 9a bc de f0\n     00 00 00 01 12\n     00 00 00 10 12 34 56 78 9a bc de f0 12 34 56 78 9a bc de f0\n     00 00 00 10 12 34 56 78 9a bc de f0 12 34 56 78 9a bc de f0\n\n```\n27 MITRE ATT&CK IDs: [T1001.003], [T1071.001]\n28 MITRE ATT&CK IDs: [T1132.002]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n### Snake “enc” Layer\n\nAs described above, Snake communications are all comprised of “Snake sessions”, irrespective of\nwhichever legitimate protocol Snake is operating on top of. Snake’s top layer of encryption, called the\nenc layer, utilizes a multi-step process to establish a unique session key. The session key is formed\nthrough the combination of a Diffie-Hellman key exchange mixed with a pre-shared key (PSK) known\nto both parties. This PSK is stored in one of the communication channels, stored within the Queue.[29]\n\nThe overall establishment of the session key requires 12 communication steps, six in each direction,\nwhich involve sharing the pseudo-random values used in the Diffie-Hellman exchange process as\nwell as custom aspects of the Snake session key derivation method. The session key is used to\nencrypt the command headers and (inner) encrypted payloads.\n\nThis is the layer in which the critical error of providing a value of 128 bits instead of 128 bytes for the\ncall to DH_generate_parameters within the OpenSSL library occurred. Due to this insufficient key\nlength, breaking the Diffie-Hellman portion of the exchange is possible. Note that in the following\nfigure, the variables ‘p’, ‘g’, ‘a’, and ‘b’ are used in standard descriptions of Diffie-Hellman.\n\n29 MITRE ATT&CK IDs: [T1573], [T1573.002], [T1610]\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n## SNAKE APPLICATION LAYER\n\nSnake’s Application Layer is used to process Snake commands. The payload data for a Snake\nsession can contain one or more command exchanges, which include both the incoming data sent to\nthe implant as well as the response returned to the server. Each command is associated with a\nspecific ordinal, and due to Snake’s modular design, operators are able to add new commands to\nextend Snake’s capabilities by remotely loading a new module.\n\nThe Snake implant differentiates between High and Low commands and handles them differently,\nbased on the ordinal number range. The majority of Snake commands are High commands that have\nan ordinal of 0x64 (100 decimal) or higher. There are far fewer Low commands, and these include the\nForwarding command (with ordinal 0x1), and the four Queue commands (with ordinals 0xa, 0xb, 0xc,\nand 0xd). While Low commands are mostly used for moving data across the network, the High\ncommands give the operator many options for interacting with an infected system.[30]\n\n### Command 0x15-byte Header\n\nAll commands begin with a 0x15-byte header, followed by optional command parameter data; only\nsome commands require parameters for successful execution. For example, the command Get, which\nexfiltrates a file, requires the name of the file to exfiltrate, whereas the command Process List, which\nreturns a process listing, does not require any parameters.[31]\n\nThe most important Command Header field contains the integer ordinal of the command being sent.\nThe Item UID field represents a unique identifier for each individual command instance, and these\nvalues increase sequentially. The header has two fields used when a command is set to run at a\nspecified date and time; these commands will be written to the 0x6 Container.\n\nSome Low commands have another header before the payload data, which will be detailed below. All\nother commands have only the Command Header followed by the encrypted parameter data.\n\n### Command Encryption\n\nUnderneath Snake http2 or tcp encryption at the session layer, each command exchange is further\nencrypted. In older versions of Snake, the exchanges were CAST-128 encrypted using a different key\nfor incoming and outgoing data. These keys were saved in the 0x2 Container in the 0x227 and 0x228\n\n30 MITRE ATT&CK IDs: [T1001], [T1104]\n31 MITRE ATT&CK IDs: [T1074], [T1119], [T1560.003]\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nItems. The incoming payload data, if parameter data was present, could be decrypted with the 0x227\nCAST key. Any response data was encrypted with the 0x228 CAST key.[32]\n\nIn recent versions, the 0x227 and 0x228 Items hold two RSA-4096 public keys. For each side of an\nexchange, a new 16-byte CAST key is created with Microsoft’s CryptoAPI CryptGenRandom function\nto obtain 16 random bytes. This key is used to CAST-128 encrypt the parameter or response data.\n\nFor an incoming command, the CAST key is signed (not encrypted) by the private key corresponding\nto the public key on the node to create a 512-byte RSA data blob. The incoming payload has the RSA\nblob, followed by the optional parameter data, which is CAST-128 encrypted. Snake uses the 0x227\nRSA public key to decrypt the RSA blob, recover the CAST key, then decrypt the parameter data.\n\nFor an outgoing command, a new CAST key is obtained from CryptGenRandom, and any response\ndata is CAST-128 encrypted. The key is then encrypted using the 0x228 public key to create a 512byte data blob. The response payload data contains the 512-byte RSA blob, followed by the\nencrypted response data, when present.\n\n### Command Decoding\n\nThe implant will expect data in a specific format for each command ordinal. Parameter and response\ndata contain several possible underlying data types, including wide-character plaintext strings,\nnumeric values, data tables, files, or a combination of multiple types.[33]\n\nThe parameter data buffer itself will be formatted in a specific way, depending on the command\nordinal. Some commands have required parameters, as well as optional parameters. Commands with\noptional parameters will include a metadata header with the data length and data type (e.g., bool,\ninteger, text, or data buffer) before the optional parameter’s data. Other commands will expect the\nparameters to be formatted with length-data pairs, consisting of the parameter data length encoded\nas a four-byte big-endian integer followed by data of exactly that length. Still other commands have a\ncustom header or will expect no length or metadata and will simply send the parameter data alone.\n\nThe response data will similarly be formatted by the implant in a specific way according to the\ncommand ordinal. The response data typically does not have a length or metadata preceding it, with\nthe exception of the data tables. Examples of commands that return a table are the Process List\ncommand and the List Dir command.\n\nResponse data that includes a table will start with a table description header that indicates the\nnumber of columns and rows in the table. In addition, the header will include a Column Descriptor\nstructure to indicate the type of data that column will contain, for example a string, uint32 or uint64,\ntimestamp in epoch format, or the contents of a whole file (included as a table entry).\n\nAfter the table description header, each field is added to the data payload buffer one at a time in a\nlength-data pair. The fields across the first row are added in order, then the fields across the second\nrow are added immediately after the first row with no metadata or separation, and so on. To parse this\ntable, the server will account for the number of columns to determine where the next row starts.\n\n32 MITRE ATT&CK IDs: [T1573]\n33 MITRE ATT&CK IDs: [T1132.002]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n### High Commands\n\nHigh commands are those with an ordinal of 0x64 (decimal 100) or higher. High commands give the\noperator many options for interacting with an infected system, as well as implant components. This\nsubsection will describe some examples of the many High commands that can exist in the implant.\n\nSome of the most basic High commands will gather information about the machine and return the\nresults. For example, the FSB operators can use the PS command (0x65) to return a list of running\nprocesses, the List Dir command (0x840) to list the contents of a directory, or the Syst command\n(0x6b) to gather basic system information.\n\nThere are several commands that interact with the infected machine using standard built-in OS tools.\nThe operator can use the Kill command (0x67) to kill a process, the Get command (0x68) to exfiltrate\na file, the Put command (0x69) to write a file, the Del command (0x6a) to delete a file, or the Run\ncommand (0x66) to execute a command in a terminal shell and receive the results. For example,\noperators have used the Run command to run PowerShell commands, ping other hosts, use the\nWindows “net use” command to map network drives, and to run executable files that had been\npreviously written to the node using the Put command.[34]\n\n34 MITRE ATT&CK IDs: [T1059.001]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nIn addition to commands that use the built-in OS functionality, there are several High commands that\ninteract with Snake components. An operator can use the Read Config command (0x70) to read the\n0x2 Container, which contains configuration data, or the Set Config Item command (0x71) to set a\nspecific Queue Item within the 0x2 Container. For example, operators have used the Set Config Item\ncommand to add or update the IP addresses or domains and option parameters used to communicate\nwith other Snake nodes. The Read Agents Track and Clear Agents Track commands (0x79 and 0x7a)\ninteract with the 0x7 Container to read or delete logs which track which other Snake nodes have\nconnected to this node. Note that the 0x7a command has been deprecated in some versions of\nSnake and returns the error “function unsupported” if called.\n\nSnake has the ability to add additional commands by loading new modules. New modules can be\nloaded using the Load Modules command (0x72) or directly into memory using the Load Modules\nMem command (0x7f). When compiling a module, the developer will assign an ordinal to each\nconstituent command, which will then be used by the operator to call the newly added commands.\nThese loaded modules can be removed using the Module Unload command (0x73).\n\n### Queue Commands\n\nThe Snake commands with ordinals 0xa, 0xb, 0xc, and 0xd are used to enumerate, read, write, and\ndelete items from the 0x0 or 0x1 Queue Containers, respectively. Note that these commands are not\nused to manipulate any other Containers.[35]\n\n##### Queue Command Header\n\nThe four Queue commands contain a 0x3d-byte Queue Header following the Command Header. In\nmore recent versions of Snake, this header is encrypted using the same CAST key used to encrypt\nthe payload data. In this case, the Command Header is followed by the 512-byte RSA encrypted\nCAST key blob, the encrypted Queue Header, and finally the encrypted payload data.[36]\n\nEven though each of the four Queue commands only use a subset of the fields of the Queue Header\n(in different ways), the full header must be present for the command to be considered valid by the\nimplant. Two fields in the header that all four Queue commands use are the Container Instance and\nContainer Type fields, which indicate the specific Container on a node the Queue command intends\nto interact with. In the Queue Read and Write commands, the Item Type field is used to track the\nspecific commands and their responses in the Containers.\n\n35 MITRE ATT&CK IDs: [T1001], [T1104]\n36 MITRE ATT&CK IDs: [T1573]\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n##### Queue Enumerate Command\n\nThe Queue Enumerate command, with ordinal 0xa, is used to enumerate the contents of the 0x0 or\n0x1 Containers to list all incoming or outgoing commands, respectively. The enumeration returns the\n0x40-byte structure described above for each Queue Item, concatenated into a single return buffer.\n\n##### Queue Read Command\n\nThe Queue Read command, with ordinal 0xb, is used to read an Item from the specified 0x0 or 0x1\nContainer. Several relevant fields in the Queue Header determine how the data is sent and stored.\nFor example, the header determines whether the data should be sent immediately back to the server\nor stored for later transport. The header indicates if the implant should send the Queue Item’s header\n(i.e., the same 0x40-byte metadata structure returned by the 0xa command), the Item’s data, or both.\nThe header also indicates whether the Queue Item should be deleted after being read and can also\nindicate that Queue Items with a lower Item Type should be deleted. This allows FSB operators to\nclear out all command Items previous to the one being read.\n\n##### Queue Write Command\n\nThe Queue Write command, with ordinal 0xc, is used to write a Queue Item to the specified 0x0 or\n0x1 Container. The Queue Header will indicate if a new Queue Item will be created, or an existing\nQueue Item will be modified.\n\nIf a Queue Item is set to be modified, an Item with the specified Item Type must exist in the specified\nContainer. Several fields in the header must match specific attributes of the existing Queue Item. If\nthese checks are met, the parameter data is written to the Queue Item. Fields in the Queue Header\nwill indicate the length of data to be written, and the offset into the existing Queue Item where the\nwrite should begin.\n\nIf a Queue Item is set to be created, Snake will delete existing Queue Items of the specified Item\nType in the Container of interest, then create a new Item of the specified Item Type and write the\nparameter data to the Queue Item. A field in the Queue Header will indicate the length of data to be\nwritten.\n\n##### Queue Delete Command\n\nThe Queue Delete command, with ordinal 0xd, is used to delete a Queue Item from the specified 0x0\nor 0x1 Container. The Flags field will determine if the single Queue Item should be deleted, or if all\nQueue Items with a lower Item Type should be deleted as well.\n\n### Forward Commands\n\nForward commands, with command ordinal 0x1, are used to tell an implant to forward a Snake\ncommand to a second target node, where the command will be executed. The target node sends the\nresponse data back to the first implant, which will then package that response data as its own\nresponse back to the caller.\n\nThe command is designed to tell an implant to forward one command to another implant, but in\npractice, Forward commands are often built on top of each other to create a chain of hop points that\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nwill continue to forward a command to an end point, where it will be executed. The response data is\nthen sent back through the same chain of hop points until it reaches the operator.[37]\n\nThe Forward command has a 0x199-byte Forward Header, followed by the encrypted command\nparameter data that will be sent to the target node of the Forward command. The Forward Header\ncontains the information the implant will need to connect to the target node, including the ordinal of\nthe Snake command that is being forwarded to the target node for execution.\n\nThe implant that receives the Forward command will construct a new Snake command of the ordinal\nindicated in the Forward Header. It will connect to the target node in a new session, construct the\nCommand Header, and send the encrypted command parameter data on to the target node. The\nparameter data already will have been encrypted using the key associated with the target node, so\nthat the target implant will be able to decrypt the parameter data and execute the command.\n\nWhen the Forward command is constructed, the CAST key used to CAST-128 encrypt the payload\ndata—to include the 0x199-byte header and the parameter data to be forwarded—is encrypted with\nthe RSA key pair used by the first implant. The parameter data that contains the parameters for the\ncommand to be forwarded is also CAST-128 encrypted, but the key used to encrypt the parameter\ndata is encrypted with the RSA key pair used by the target node. The first implant knows through the\nheader what command ordinal it is forwarding, but it is unable to decrypt the parameter data.\n\nIf the Forward Header sent to the first implant indicates that the command to be forwarded was\nanother Forward command, the first target node will decrypt the parameter data and find another\nForward Header. This first target node implant will then go through the same process to connect to\nthe next target node, constructing the new command with the ordinal indicated in the second Forward\nHeader to send the remaining encrypted parameter data to the next target node. This will repeat until\nthe command to be forwarded is something other than another Forward command.\n\nThe Command Header and pertinent parameters for each target node are encrypted specifically for\nthat node by the operator before the Forward command is sent into the Snake P2P network. To\nillustrate, the diagram below shows how the buffer might look when several Forward commands are\nchained together to include two hop points and an end point. The first hop point (HP1) will recover the\nfirst CAST key and CAST-128 decrypt the rest of the buffer, which will uncover the first Forward\nHeader. HP1 will then forward the remainder of the decrypted buffer to the next hop point (HP2),\nstarting with the second CAST key blob. HP2 will recover the second CAST key and CAST-128\ndecrypt the rest of the buffer, which will uncover the second Forward Header. HP2 will then forward\nthe remainder of the decrypted buffer to the end point, starting with the third CAST key blob. The end\npoint will recover the CAST key, decrypt the command parameter data, and execute the command.\n\nWhen a target machine has executed a forwarded command, the return data is encrypted with that\nimplant’s RSA keys and returned directly to the previous hop point. As the data is returned up the\nchain in the Snake P2P network, the intermediate hop points do not manipulate the encrypted data,\nas they do not have the RSA private key necessary to do so. In this manner, the return data is defacto end-to-end encrypted throughout the P2P network until it arrives back at the FSB operator.\n\n37 MITRE ATT&CK IDs: [T1090.003], [T1573]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n## SNAKE IMPLANT OPERATION\n\nSnake uses two main methods for communication and command execution, namely Passive and\nActive. In general, Snake operators will employ Active operations to communicate with hop points\nwithin Snake’s infrastructure; however, hop points can and do sometimes operate using Snake’s\nPassive method. Snake’s end points tend to solely operate using the Passive method.[38]\n\n### Active Operations\n\nDuring Active operations, Snake commands are issued by an FSB operator or a script to a target\nmachine, generally through Forward commands (described in the previous section). The response to\nthe command is immediately returned to the point of origin following the same path that the command\ntook to reach its end target, as shown in the previous figure on Forward command structure.\n\n### Passive Operations\n\nDuring Passive operations, Snake implants operate on their own, without the synchronous interaction\nof FSB operators. The nodes with which an implant communicates during Passive operations are\nstored within its 0x2 Container(s) as communication channels. Up to ten communication channels can\nbe present at any time; an operator can change these channels via the Set Config Item command.\n\n##### Passive Intake\n\nDuring Passive operations, the implant will beacon by sending a Queue Read (0xb) command to one\nof its stored communication channels that it has chosen at random. These Queue Read commands\nlook for a Queue Item within a Container with an Instance Number equal to the implant’s UID. The\nmatching UID indicates the Queue Items in this Container are intended for the beaconing implant.\n\nIf such a Queue Item is found, the beaconing implant will read in the Queue Item and delete it off of\nthe host from which it was read. There can be multiple Queue Items found within the specified Queue\nContainer that was beaconed to; each Queue Read command will read one of these items. This\nprocess is repeated until all items within the Container are read, which the infrastructure node will\nindicate by sending a specific error in response to the Queue Read. This beaconing will continue to\nrandomly select hosts at nondeterministic time intervals for as long as the implant is set to perform\nPassive operations.\n\n##### Passive Data Exfiltration\n\nSimilar to how Snake intakes commands passively, it can also exfiltrate the resulting data passively.\nThis is done using Queue Write (0xc) commands to write to one of the stored communication\nchannels chosen at random. Once the data is off the end point node, operators generally retrieve it\nmanually or using a script. The Item Type field, which is unique per executed Snake command, is\nneeded to associate the exfiltrated data with the target node on which the command was run.\n\nIn the context of Passive Snake communications, the term Item Type is defined as a UID for a given\nSnake command and its resulting data. The Item Type serves as a unique identifier to associate the\nresults of command execution with the original command written by the operator. When the FSB\n\n38 MITRE ATT&CK IDs: [T1104]\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\ncollects the data, Snake knows exactly what infection the data came from, and therefore it can\ndetermine what key to use to successfully decrypt the data.\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nTo illustrate how Passive operations are conducted between the end points, the operator, and the hop\npoints in between, see the diagram above, which is explained further by the following steps:[39]\n\n     - (1), (2): During Passive operations, the Node randomly chooses a host from amongst its\nstored communication channels and will beacon out to it with a Queue Read command (Hop\nPoint 1 in this case). The Item Type for these beacons will be one greater than the Item Type\nof the last command received by the Node, indicating in this example that a command of Item\nType 0x08 was the last command that was read in by the Node during Passive operations.\nThis Node will continue to beacon with Item Type 0x09 until it receives a command, via\nPassive operations, with an Item Type of 0x09 or greater. The lines are dotted for (1) and (2)\nas this activity will be repeated at random intervals until a successful Queue Read occurs.\n\n     - (3), (4): In these steps, the operator uses a Queue Write command to write a command to Hop\nPoint 1[40] that is ultimately intended for the Node. The Item Type of the command being written\nto Hop Point 1 is assigned 0x20 (for this example). Note that the path of this command, its\nexecution, and its results making it back to the operator can be tracked via the red text.\n\n     - (5), (6): The Node continues to beacon out looking for commands to read in (5). The return (6)\nis successful, and the command written by the operator to Hop Point 1 (3) is read in by the\nNode, then deleted from Hop Point 1.\n\n     - (7), (8): The Node attempts another Queue Read to Hop Point 1, however now the Item Type\nis set to 0x21, one greater than the command that was just read in by the Node at (5) and (6).\nThis returns an error as Hop Point 1 has nothing else for the Node to read in, indicating to the\nNode that everything at Hop Point 1 was read.\n\n     - (9), (10): At this point, the Node has executed the command it read in at (5) and (6) and is\nattempting to send back the results. The Node randomly selects another host from its stored\ncommunication channels, Hop Point 2 in this case, and sends out a 0xb command to make\nsure that the Item Type 0x20, the Item Type of the command it executed, does not already\nexist within the Queue of Hop Point 2. If it receives an error, there is no Item with Item Type\n0x20 on Hop Point 2, and the Node can proceed to send the command results.\n\n     - (11), (12): Here the data from the executed command is written to Hop Point 2 with Item Type\n0x20 into its 0x1 Container with a 0xc command, the Item Type the command was initially\ngiven at creation (3).\n\n     - (13), (14): The Node continues its normal beaconing routine again as seen in (1) and (2),\nsearching for Item Type 0x21, one greater than the Item Type of the most recently executed\n\n39 MITRE ATT&CK IDs: [T1090.003], [T1104]\n40 The operator knows that Hop Point 1 is stored in the communications channels of the Node, thus the operator knows\nthat the Node will beacon out to Hop Point 1 at some point and be able to retrieve the data.\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\ncommand. As in (1) and (2), the lines here are dotted to denote that this process will repeat\nuntil there was a successful beacon as in (5) and (6).\n\n     - (15-22): These steps show how the operator retrieves the resulting data that was written to\nHop Point 2. The Queue Enumerate command (15) lists the contents of Hop Point 2’s 0x1\nContainer, showing the data written by the Node (11). This data is identifiable by its Item Type,\nnamely 0x20. The Queue Read command (17) reads in the Item that was found in Hop Point\n2’s Container. The Queue Read command that follows (19) is asking if there is any data left. In\nthis case, the entirety of the data was read with the first Queue Read (17, 18). Therefore, the\nerror returned from second Queue Read command (20) lets the operator know all of the data\nfrom Item Type 0x20 was read and there is nothing further. A Queue Delete command (21)\nfollows and is sent to delete the item with Item Type 0x20 from Hop Point 2.\n\n     - The subsequent Queue Read, Queue Read, and Queue Delete commands (17-21) are\ndenoted with dashed lines to indicate that this sequence of commands is repeated for all items\nreturned from the Queue Enumerate command (15).\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n## MITIGATIONS\n\nA number of complementary detection techniques effectively identify some of the more recent\nvariants of Snake. However, as described above, Snake is purpose-built to avoid large-scale\ndetection. Below is a discussion of the advantages and disadvantages of various detection\nmethodologies available for Snake.\n\n**Note that some of the techniques identified in this section can affect the availability or stability**\n**of a system. Defenders should follow organizational policies and incident response best practices to**\nminimize the risk to operations while hunting for Snake.\n\n### Network-Based Detection\n\nNetwork Intrusion Detection Systems (NIDS) can feasibly identify some of the more recent variants of\nSnake and its custom network protocols as detailed above.\n\n**Advantages: High-confidence, large-scale (network-wide) detection of custom Snake communication**\nprotocols.\n\n**Disadvantages: Low visibility of Snake implant operations and encrypted data in transit. There is**\n**some potential for false positives in the Snake http, http2, and tcp signatures. Snake operators**\ncan easily change network-based signatures.\n\n##### Snake http\n\nSnake client-to-server http and http2 traffic is contained within an arbitrary HTTP header field. The\nheader field value for http begins with 10 pure alphanumeric characters, followed by base64 encoding\nof 8 bytes, which yields exactly 11 valid base64 characters plus one base64 padding character.\n```\n       ^[0-9A-Za-z]{10}[0-9A-Za-z/\\+]{11}=\n\n```\nThe following two Suricata rules will detect the traffic described:\n```\n   alert http any any -> any any (msg: \"http rule (Cookie)\";\\\n     pcre:\"/[0-9A-Za-z]{10}[0-9A-Za-z\\/\\+]{11}=/C\";\\\n     flow: established, to_server;\\\n     sid: 7; rev: 1;)\n   alert http any any -> any any (msg: \"http rule (Other Header)\";\\\n     pcre:\"/[0-9A-Za-z]{10}[0-9A-Za-z\\/\\+]{11}=/H\";\\\n     flow: established, to_server;\\\n     sid: 8; rev: 1;)\n\n##### Snake http2\n\n```\nThe header field value for http2 begins with 22 pure alphanumeric characters (base62 with nonextraneous characters), followed by the base62 encoding of at least 8 bytes, which must comprise at\nleast 11 base62 characters with the four extraneous characters allowed. The actual requirement is\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nstricter than this expression, since the total number of non-extraneous characters alone must equal or\nexceed 11; however, it is not possible to encode that aspect into a regular language.\n```\n       ^[0-9A-Za-z]{22}[0-9A-Za-z/;_=]{11}\n\n```\nThe following two Suricata rules will detect the traffic described:\n```\n   alert http any any -> any any (msg: \"http2 rule (Cookie)\";\\\n     pcre:\"/[0-9A-Za-z]{22}[0-9A-Za-z\\/_=\\;]{11}/C\";\\\n     flow: established, to_server;\\\n     sid: 9; rev: 1;)\n   alert http any any -> any any (msg: \"http2 rule (Other Header)\";\\\n     pcre:\"/[0-9A-Za-z]{22}[0-9A-Za-z\\/_=\\;]{11}/H\";\\\n     flow: established, to_server;\\\n     sid: 10; rev: 1;)\n\n##### Snake tcp\n\n```\nThe client-to-server communication for tcp must begin with the ustart, which is not captured in this\nsignature set. Immediately following the ustart, the next client-to-server communication must be the\nbig-endian 32-bit unsigned integer 8 followed by any 8 bytes of data. The next communication must\nalso be client-to-server, and it must comprise the big-endian 32-bit unsigned integer 4 followed by any\n4 bytes of data. The next two communications must be server-to-client, comprising the integer 8\nfollowed by 8 bytes of data and the integer 4 followed by 4 bytes of data.\n\nThe following six Suricata rules will, in conjunction, detect traffic of the form described:\n```\n   alert tcp any any -> any any (msg: \"tcp rule\";\\\n     content: \"|00 00 00 08|\"; startswith; dsize: 12;\\\n     flow: established, to_server; flowbits: set, a8; flowbits: noalert;\\\n     sid: 1; rev: 1;)\n   alert tcp any any -> any any (msg: \"tcp rule\";\\\n     content: \"|00 00 00 04|\"; startswith; dsize:8;\\\n     flow: established, to_server; flowbits: isset, a8; flowbits: unset, a8;\\\n     flowbits: set, a4; flowbits: noalert;\\\n     sid: 2; rev: 1;)\n   alert tcp any any -> any any (msg: \"tcp rule\";\\\n     content: \"|00 00 00 08|\"; startswith; dsize: 4;\\\n     flow: established, to_client; flowbits: isset, a4; flowbits: unset, a4;\\\n     flowbits: set, b81; flowbits: noalert;\\\n     sid: 3; rev: 1;)\n\n```\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n```\n   alert tcp any any -> any any (msg: \"tcp rule\";\\\n     dsize: 8; flow: established, to_client; flowbits: isset, b81;\\\n     flowbits: unset, b81; flowbits: set, b8; flowbits: noalert;\\\n     sid: 4; rev: 1;)\n   alert tcp any any -> any any (msg: \"tcp rule\";\\\n     content: \"|00 00 00 04|\"; startswith; dsize: 4;\\\n     flow: established, to_client; flowbits: isset, b8; flowbits: unset, b8;\\\n     flowbits: set, b41; flowbits: noalert;\\\n     sid: 5; rev: 1;)\n   alert tcp any any -> any any (msg: \"tcp rule\";\\\n     dsize: 4; flow: established, to_client; flowbits: isset, b41;\\\n     flowbits: unset, b41;\\\n     sid: 6; rev: 1;)\n\n### Host-Based Detection\n\n```\n**Advantages: High confidence based on totality of positive hits for host-based artifacts.**\n\n**Disadvantages: Many of the artifacts on the host are easily shifted to exist in a different location or**\nwith a different name. As the files are fully encrypted, accurately identifying these files is difficult.\n\n##### Covert Store Detection\n\nThe Snake covert store comprises a file-backed NTFS (usually) or FAT-16 (rarely) filesystem. The\nfilesystem is encrypted with CAST-128 in CBC mode. The encryption key can be either statically\nhardcoded or dynamically stored in a specified Windows registry location. The IV is 8 bytes, since\nCAST-128 has an 8-byte block length. The first byte of the IV for any 512-byte block of the covert\nstore is the 0-indexed block number. The remaining bytes of the IV are the corresponding bytes of the\nkey, meaning that bytes at 0-indexed indices 1 through 7 of the IV are the bytes at 0-indexed indices\n1 through 7 of the key.\n\nWhen statically hardcoded, the encryption key has the following constant value:\n```\n     A1 D2 10 B7 60 5E DA 0F A1 65 AF EF 79 C3 66 FA\n\n```\nWhen stored in the Windows registry, the encryption key is the classname associated with the\nfollowing key:\n```\n     SECURITY\\Policy\\Secrets\\n\n\n```\nThe following initial 8-byte sequences are known to be used by NTFS or FAT-16 filesystems as\nobserved:\n```\n     EB 52 90 4E 54 46 53 20\n     EB 5B 90 4E 54 46 53 20\n\n```\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n```\n     EB 3C 90 4D 53 44 4F 53\n     EB 00 00 00 00 00 00 00\n\n```\nFor tool development, the following test vector illustrates the encryption of the first given header\nabove (EB 52 90 …) using CAST-128 with the default key shown above and the IV constructed as\ndescribed, given this header occurs at the beginning of the first 512-byte block of the covert store.\n\n**Plaintext:** `EB 52 90 4E 54 46 53 20`\n\n**Key:** `A1 D2 10 B7 60 5E DA 0F A1 65 AF EF 79 C3 66 FA`\n\n**IV:** `00 D2 10 B7 60 5E DA 0F`\n\n**Ciphertext:** `C2 C7 F4 CA F7 DA 3A C8`\n\nBy encrypting each possible initial filesystem byte sequence with CAST-128 using the key obtained\nfrom the registry—or the default encryption key if the registry entry does not exist—and searching for\nany file with a size that is an even multiple of 220, it is possible to efficiently detect Snake covert\nstores. Validation can be performed by decrypting the entire file using the outlined methodology and\nthen verifying that it comprises an NTFS or FAT-16 filesystem.\n\n##### Other On-Disk Artifact Detection\n\nRegistry Blob\n\nThe registry blob is generally found at the location listed below. In case it is not present at its typical\nlocation, the registry blob can be found by searching the full registry for a value of at least 0x1000\nbytes in size and entropy of at least 7.9.\n\n**Typical Name: Unknown (RegBlob)**\n\n**Typical Path: HKLM\\SOFTWARE\\Classes\\.wav\\OpenWithProgIds**\n\n**Characteristics: High Entropy**\n\nQueue File\n\n**Typical Name: < RANDOM_GUID >.<RANDOM_GUID>.crmlog**\n\n**Typical Path: %windows\\registration\\**\n\n**Unique Characteristics: High Entropy, file attributes of hidden, system, and archive**\n\n**Role: Snake Queue File**\n\nThe Snake Queue File generally has a predictable path and filename structure, in addition to being\nhigh entropy. The Snake Queue File can be located by scanning all files in the typical queue path with\nfilenames matching a regular expression that captures the typical naming convention. Files meeting\nthese criteria should be scanned for high entropy, which is performed by the Yara rule below:\n```\n   rule HighEntropy\n   {\n\n```\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n```\n     meta:\n       description = \"entropy rule\"\n     condition:\n       math.entropy(0, filesize) >= 7.0\n   }\n\n```\nThe following UNIX find command will scan files with names matching the GUID-based convention\n(note that the HighEntropy yara rule is assumed to be contained in a file named “1.yar”):\n```\n   find /PATH/TO/WINDOWS_DIR -type f -regextype posix-egrep -iregex \\\n     '.*\\/registration/(\\{[0-9A-F]{8}\\-([0-9A-F]{4}\\-){3}[0-9A-F]{12}\\}\\.){2}crmlog' \\\n      -exec yara 1.yar {} \\;\n\n```\nThe following PowerShell command does the same:\n```\n   Get-ChildItem -Recurse -File -Path %WINDOWS% | Where-Object {\n    $_.FullName -match\n    '(?i)/registration/(\\{[0-9A-F]{8}\\-([0-9A-F]{4}\\-){3}[0-9A-F]{12}\\}\\.){2}crmlog$'\n   } | ForEach-Object {\n    yara 1.yar $_.FullName\n   }\n\n```\nComadmin\n\n**Typical Name: comadmin.dat**\n\n**Typical Path: %windows%\\system32\\Com**\n\n**Unique Characteristics: High Entropy**\n\n**Role: Houses Snake’s kernel driver and the driver’s loader**\n\nThe Snake Comadmin file can be found using analogous techniques to that presented above for\nlocating the Snake Queue File. The following UNIX find command will do so:\n```\n   find /PATH/TO/WINDOWS -type f -regextype posix-egrep -iregex \\\n     '.*\\/system32/Com/comadmin\\.dat' \\\n     -exec yara 1.yar {} \\;\n\n```\nThe following PowerShell command does the same:\n```\n   Get-ChildItem -Recurse -File -Path %WINDOWS% | Where-Object {\n     $_.FullName -match '(?i)/system32/Com/comadmin\\.dat$'\n   } | ForEach-Object {\n     yara 1.yar $_.FullName\n\n```\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n```\n   }\n\n```\nWerfault\n\n**Typical Name: Werfault.exe**\n\n**Typical Path: %windows%\\WinSxS\\x86_microsoft-windows-**\nerrorreportingfaults_31bf3856ad364e35_4.0.9600.16384_none_a13f7e283339a0502\\\n\n**Unique Characteristics: Icon is different than that of a valid Windows Werfault.exe file**\n\n**Role: Persistence mechanism**\n\nThe Snake Werfault.exe file has non-standard icon sizes, which form the basis of the Yara rule below.\nThis rule should be run on all files in the typical path, specifically the %Windows%\\WinSxS directory.\n```\n   rule PeIconSizes\n   {\n     meta:\n       description = \"werfault rule\"\n     condition:\n       pe.is_pe \n       and \n       for any rsrc in pe.resources:\n         (rsrc.type == pe.RESOURCE_TYPE_ICON and rsrc.length == 3240)\n       and\n       for any rsrc in pe.resources:\n         (rsrc.type == pe.RESOURCE_TYPE_ICON and rsrc.length == 1384)\n       and\n       for any rsrc in pe.resources:\n         (rsrc.type == pe.RESOURCE_TYPE_ICON and rsrc.length == 7336)\n   }\n\n### Memory Analysis\n\n```\n**Advantages: High confidence as memory provides the greatest level of visibility into Snake’s**\nbehaviors and artifacts.\n\n**Disadvantages: Potential impact on system stability, difficult scalability.**\n\nCapturing and analyzing the memory of a system will be the most effective approach in detecting\nSnake because it bypasses many of the behaviors that Snake employs to hide itself. With a memory\nanalysis tool, such as Volatility, detection of a Snake compromise may be possible.\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nSnake’s principal user mode component is injected into a chosen process via a single allocation of\nPAGE_EXECUTE_READWRITE memory. The starting offset is generally 0x20000000, however the\nmodule does allow for relocation if needed. Additionally, since the user mode component is not\nobfuscated in any way, a valid PE header can be located at the beginning of the allocated memory\nregion. Further validation can be performed by confirming the presence of strings known to exist in\nthe user mode component also within the memory region. A plugin compatible with Volatility3 which\ncan scan all processes on a system using this method is provided in the Appendix. A screenshot\nshowing the results of the plugin successfully detecting Snake is displayed below.\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n## PREVENTION\n\nNote that the mitigations that follow are not meant to protect against the initial access vector and are\nonly designed to prevent Snake’s persistence and hiding techniques.\n\n### Change Credentials and Apply Updates\n\nSystem owners who are believed to be compromised by Snake are advised to change their\ncredentials immediately (from a non-compromised system) and to not use any type of passwords\nsimilar to those used before. Snake employs a keylogger functionality that routinely returns logs back\nto FSB operators. Changing passwords and usernames to values which cannot be brute forced or\nguessed based on old passwords is recommended.\n\nSystem owners are advised to apply updates to their Operating Systems. Modern versions of\nWindows, Linux, and MacOS make it much harder for adversaries to operate in the kernel space. This\nwill make it much harder for FSB actors to load Snake’s kernel driver on the target system.\n\n### Execute Organizational Incident Response Plan\n\nIf system owners receive detection signatures of Snake implant activity or have other indicators of\ncompromise that are associated with FSB actors using Snake, the impacted organization should\nimmediately initiate their documented incident response plan.\n\nWe recommend implementing the following Cross-Sector Cybersecurity Performance Goals (CPGs)\nto help defend against FSB actors using Snake, or mitigate negative impacts post-compromise:\n\n**CPG 2.A: Changing Default Passwords will prevent FSB actors from compromising default**\ncredentials to gain initial access or move laterally within a network.\n\n**CPG 2.B: Requiring Minimum Password Strength across an organization will prevent FSB actors**\nfrom being able to successfully conduct password spraying or cracking operations.\n\n**CPG 2.C: Requiring Unique Credentials will prevent FSB actors from compromising valid accounts**\nthrough password spraying or brute force.\n\n**CPG 2.E Separating User and Privileged Accounts will make it harder for FSB actors to gain**\naccess to administrator credentials.\n\n**CPG 2.F. Network Segmentation to deny all connections by default unless explicitly required for**\nspecific system functionality, and ensure all incoming communication is going through a properly\nconfigured firewall.\n\n**CPG 2.H Implementing Phishing Resistant MFA adds an additional layer of security even when**\naccount credentials are compromised and can mitigate a variety of attacks towards valid accounts, to\ninclude brute forcing passwords and exploiting external remote services software.\n\n**CPG 4.C. Deploy Security.txt Files to ensure all public facing web domains have a security.txt file**\nthat conforms to the recommendations in RFC 9118.\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n## APPENDIX\n\n### Partnership\n\nThis advisory was developed as a joint effort by an international partnership of multiple agencies in\nfurtherance of the respective cybersecurity missions of each of the partner agencies, including our\nresponsibilities to develop and issue cybersecurity specifications and mitigations. This partnership\nincludes the following organizations:\n\n     - Federal Bureau of Investigation\n\n     - National Security Agency\n\n     - Cybersecurity and Infrastructure Security Agency\n\n     - Cyber National Mission Force\n\n     - The United Kingdom’s National Cyber Security Centre\n\n     - Canadian Centre for Cyber Security\n\n     - Communications Security Establishment\n\n     - Australian Cyber Security Centre\n\n     - New Zealand National Cyber Security Centre\n\nCollectively, we use a variety of sources, methods, and partnerships to acquire information about\nforeign cyber threats. This advisory contains the information we have concluded can be publicly\nreleased, consistent with the protection of sources and methods and the public interest.\n\n### Disclaimer\n\nThe information in this report is being provided “as is” for informational purposes only. We do not\nendorse any commercial product or service, including any subjects of analysis. Any reference to\nspecific commercial products, processes, or services by service mark, trademark, manufacturer, or\notherwise, does not constitute or imply endorsement, recommendation, or favoring by co-authors.\n\n### MITRE ATT&CK Techniques\n\nThis advisory uses the MITRE ATT&CK® for Enterprise framework, version 13. See MITRE ATT&CK\nfor Enterprise for all referenced tactics and techniques. MITRE and ATT&CK are registered trademarks\nof The MITRE Corporation. This report references the following MITRE ATT&CK techniques.\n\n|Technique Title ID Use|Col2|Col3|\n|---|---|---|\n|Network Connection Adversaries may perform network connection enumeration to T0840 Enumeration discover information about device communication patterns.|||\n|Adversaries may obfuscate command and control traffic to make Data Obfuscation T1001 it more difficult to detect.|||\n|Protocol Impersonation|T1001.003|Adversaries may impersonate legitimate protocols or web service traffic to disguise command and control activity and thwart analysis efforts.|\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n|Adversaries may attempt to dump credentials to obtain account OS Credential Dumping T1003 login and credential material, normally in the form of a hash or a clear text password, from the operating system and software.|Col2|Col3|\n|---|---|---|\n|Adversaries may use rootkits to hide the presence of programs, Rootkit T1014 files, network connections, services, drivers, and other system components.|||\n|Adversaries may attempt to make an executable or file difficult to Obfuscated Files or T1027 discover or analyze by encrypting, encoding, or otherwise Information obfuscating its contents on the system or in transit.|||\n|Adversaries may perform software packing or virtual machine Software Packing T1027.002 software protection to conceal their code.|||\n|Adversaries may attempt to manipulate features of their artifacts Masquerading T1036 to make them appear legitimate or benign to users and/or security tools.|||\n|Adversaries may sniff network traffic to capture information about Network Sniffing T1040 an environment, including authentication material passed over the network.|||\n|Adversaries may attempt to get a listing of services running on Network Service Discovery T1046 remote hosts and local network infrastructure devices, including those that may be vulnerable to remote software exploitation.|||\n|Adversaries may inject dynamic-link libraries (DLLs) into Dynamic-link Library T1055.001 processes in order to evade process-based defenses as well as Injection possibly elevate privileges.|||\n|Adversaries may log user keystrokes to intercept credentials as Keylogging T1056.001 the user types them.|||\n|Adversaries may abuse PowerShell commands and scripts for PowerShell T1059.001 execution.|||\n|Adversaries may communicate using OSI application layer Application Layer Protocol T1071 protocols to avoid detection/network filtering by blending in with existing traffic.|||\n|Adversaries may communicate using application layer protocols Web Protocols T1071.001 associated with web traffic to avoid detection/network filtering by blending in with existing traffic.|||\n|Adversaries may communicate using application layer protocols Mail Protocols T1071.003 associated with electronic mail delivery to avoid detection/network filtering by blending in with existing traffic.|||\n|DNS|T1071.004|Adversaries may communicate using the Domain Name System (DNS) application layer protocol to avoid detection/network filtering by blending in with existing traffic.|\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n|Adversaries may stage collected data in a central location or Data Staged T1074 directory prior to Exfiltration.|Col2|Col3|\n|---|---|---|\n|Adversaries may obtain and abuse credentials of existing Valid Accounts T1078 accounts as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion.|||\n|Adversaries may enumerate files and directories or may search in File and Directory T1083 specific locations of a host or network share for certain Discovery information within a file system.|||\n|To disguise the source of malicious traffic, adversaries may chain Multi-hop Proxy T1090.003 together multiple proxies.|||\n|Adversaries may use an OSI non-application layer protocol for Non-Application Layer T1095 communication between host and C2 server or among infected Protocol hosts within a network.|||\n|Adversaries may create multiple stages for command and control Multi-Stage Channels T1104 that are employed under different conditions or for certain functions.|||\n|Adversaries may interact with the native OS application Native API T1106 programming interface (API) to execute behaviors.|||\n|Adversaries may interact with the Windows Registry to hide configuration information within Registry keys, remove Modify Registry T1112 information as part of cleaning up, or as part of other techniques to aid in persistence and execution.|||\n|Once established within a system or network, an adversary may Automated Collection T1119 use automated techniques for collecting internal data.|||\n|Adversaries may encode data to make the content of command Data Encoding T1132 and control traffic more difficult to detect.|||\n|Adversaries may encode data with a non-standard data encoding Non-Standard Encoding T1132.002 system to make the content of command and control traffic more difficult to detect.|||\n|Adversaries may look for folders and drives shared on remote systems as a means of identifying sources of information to Network Share Discovery T1135 gather as a precursor for Collection and to identify potential systems of interest for Lateral Movement.|||\n|Deobfuscate/Decode Files Adversaries may use Obfuscated Files or Information to hide T1140 or Information artifacts of an intrusion from analysis.|||\n|Exploit Public-Facing Application|T1190|Adversaries may attempt to exploit a weakness in an Internet- facing host or system to initially access a network.|\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\n|Adversaries may attempt to gather information on domain trust Domain Trust Discovery T1482 relationships that may be used to identify lateral movement opportunities in Windows multi-domain/forest environments.|Col2|Col3|\n|---|---|---|\n|Adversaries may establish persistence and elevate privileges by Installer Packages T1546.016 using an installer to trigger the execution of malicious content.|||\n|Adversaries may execute their own malicious payloads by Dynamic Linker Hijacking T1547.006 hijacking environment variables the dynamic linker uses to load shared libraries.|||\n|Inter-Process Adversaries may abuse inter-process communication (IPC) T1559 Communication mechanisms for local code or command execution.|||\n|An adversary may compress and/or encrypt data that is collected Archive Collected Data T1560.003 prior to exfiltration.|||\n|Adversaries may attempt to hide artifacts associated with their Hide Artifacts T1564 behaviors to evade detection.|||\n|Adversaries may abuse the Windows service control manager to Service Execution T1569.002 execute malicious commands or payloads.|||\n|Adversaries may transfer tools or other files between systems in Lateral Tool Transfer T1570 a compromised environment.|||\n|Adversaries may tunnel network communications to and from a victim system within a separate protocol to avoid Protocol Tunneling T1572 detection/network filtering and/or enable access to otherwise unreachable systems.|||\n|Adversaries may employ a known encryption algorithm to conceal Encrypted Channel T1573 command and control traffic rather than relying on any inherent protections provided by a communication protocol.|||\n|Adversaries may employ a known symmetric encryption algorithm Symmetric Cryptography T1573.001 to conceal command and control traffic rather than relying on any inherent protections provided by a communication protocol.|||\n|Adversaries may employ a known asymmetric encryption algorithm to conceal command and control traffic rather than Asymmetric Cryptography T1573.002 relying on any inherent protections provided by a communication protocol.|||\n|Adversaries may execute their own malicious payloads by side- DLL Side-Loading T1574.002 loading DLLs.|||\n|Adversaries may compromise third-party infrastructure that can Compromise Infrastructure T1584 be used during targeting.|||\n|Malware|T1587.001|Adversaries may develop malware and malware components that can be used during targeting.|\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n\nAdversaries may buy and/or steal capabilities that can be used\nObtain Capabilities T1588\n\nduring targeting.\n\nAdversaries may upload, install, or otherwise set up capabilities\nStage Capabilities T1608\n\nthat can be used during targeting.\n\nAdversaries may deploy a container into an environment to\nDeploy Container T1610\n\nfacilitate execution or evade defenses.\n\n### Volatility Plugin\n\nThe following plugin for the Volatility memory analysis framework will scan all processes on the\nsystem until it finds the Snake user mode component injected into a process. If found, the plugin will\nlist both the injected process and the virtual memory address at which the Snake user mode\ncomponent is loaded.\n```\n   # This plugin to identify the injected usermode component of Snake is based\n   # on the malfind plugin released with Volatility3\n   #\n   # This file is Copyright 2019 Volatility Foundation and licensed under the\n   # Volatility Software License 1.0\n   # which is available at https://www.volatilityfoundation.org/license/vsl-v1.0\n   import logging\n   from typing import Iterable, Tuple\n   from volatility3.framework import interfaces, symbols, exceptions, renderers\n   from volatility3.framework.configuration import requirements\n   from volatility3.framework.objects import utility\n   from volatility3.framework.renderers import format_hints\n   from volatility3.plugins.windows import pslist, vadinfo\n   vollog = logging.getLogger(__name__)\n   class snake(interfaces.plugins.PluginInterface):\n     _required_framework_version = (2, 4, 0)\n     @classmethod\n     def get_requirements(cls):\n        return [\n         requirements.ModuleRequirement(name = 'kernel',\n              description = 'Windows kernel',\n              architectures = [\"Intel32\", \"Intel64\"]),\n         requirements.VersionRequirement(name = 'pslist',\n              component = pslist.PsList, version = (2, 0, 0)),\n         requirements.VersionRequirement(name = 'vadinfo',\n              component = vadinfo.VadInfo, version = (2, 0, 0))]\n     @classmethod\n     def list_injections(\n         cls, context: interfaces.context.ContextInterface,\n              kernel_layer_name: str, symbol_table: str,\n         proc: interfaces.objects.ObjectInterface) -> Iterable[\n              Tuple[interfaces.objects.ObjectInterface, bytes]]:\n       proc_id = \"Unknown\"\n        try:\n\n```\n|Adversaries may buy and/or steal capabilities that can be used Obtain Capabilities T1588 during targeting.|Col2|Col3|\n|---|---|---|\n|Adversaries may upload, install, or otherwise set up capabilities Stage Capabilities T1608 that can be used during targeting.|||\n|Deploy Container|T1610|Adversaries may deploy a container into an environment to facilitate execution or evade defenses.|\n\n\n**TLP:CLEAR** International Partnership\n\n\n-----\n\n**TLP:CLEAR** International Partnership\n```\n         proc_id = proc.UniqueProcessId\n         proc_layer_name = proc.add_process_layer()\n        except exceptions.InvalidAddressException as excp:\n         vollog.debug(\"Process {}: invalid address {} in layer {}\".\n              format(proc_id, excp.invalid_address, excp.layer_name))\n          return\n       proc_layer = context.layers[proc_layer_name]\n        for vad in proc.get_vad_root().traverse():\n         protection_string = vad.get_protection(vadinfo.VadInfo.\n              protect_values(context, kernel_layer_name, symbol_table),\n              vadinfo.winnt_protections)\n          if not \"PAGE_EXECUTE_READWRITE\" in protection_string:\n             continue\n          if (vad.get_private_memory() == 1\n               and vad.get_tag() == \"VadS\") or (vad.get_private_memory()\n                     == 0 and protection_string !=\n                     \"PAGE_EXECUTE_WRITECOPY\"):\n           data = proc_layer.read(vad.get_start(),\n                 vad.get_size(), pad = True)\n             if data.find(b'\\x4d\\x5a') != 0:\n               continue\n             yield vad, data\n     def _generator(self, procs):\n       kernel = self.context.modules[self.config['kernel']]\n       is_32bit_arch = not symbols.symbol_table_is_64bit(self.context,\n          kernel.symbol_table_name)\n        for proc in procs:\n         process_name = utility.array_to_string(proc.ImageFileName)\n          for vad, data in self.list_injections(self.context,\n              kernel.layer_name, kernel.symbol_table_name, proc):\n           strings_to_find = [b'\\x25\\x73\\x23\\x31',b'\\x25\\x73\\x23\\x32',\n                 b'\\x25\\x73\\x23\\x33',b'\\x25\\x73\\x23\\x34',\n                 b'\\x2e\\x74\\x6d\\x70', b'\\x2e\\x73\\x61\\x76',\n                 b'\\x2e\\x75\\x70\\x64']\n             if not all(stringToFind in data for\n                 stringToFind in strings_to_find):\n               continue\n             yield (0, (proc.UniqueProcessId, process_name,\n                 format_hints.Hex(vad.get_start()),\n                format_hints.Hex(vad.get_size()),\n                vad.get_protection(\n                  vadinfo.VadInfo.protect_values(self.context,\n                 kernel.layer_name, kernel.symbol_table_name),\n                 vadinfo.winnt_protections)))\n             return\n     def run(self):\n       kernel = self.context.modules[self.config['kernel']]\n        return renderers.TreeGrid([(\"PID\", int), (\"Process\", str),\n          (\"Address\", format_hints.Hex), (\"Length\", format_hints.Hex),\n          (\"Protection\", str)], self._generator(pslist.PsList.list_processes(\n          context = self.context, layer_name = kernel.layer_name,\n          symbol_table = kernel.symbol_table_name)))\n\n```\n\n**TLP:CLEAR** International Partnership\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://www.cisa.gov/sites/default/files/2023-05/aa23-129a_snake_malware_2.pdf"
    ],
    "report_names": [
        "aa23-129a_snake_malware_2.pdf"
    ],
    "threat_actors": [
        {
            "id": "649b5b3e-b16e-44db-91bc-ae80b825050e",
            "created_at": "2022-10-25T15:50:23.290412Z",
            "updated_at": "2025-03-27T02:00:55.431037Z",
            "deleted_at": null,
            "main_name": "Dragonfly",
            "aliases": [
                "TEMP.Isotope",
                "DYMALLOY",
                "Berserk Bear",
                "TG-4192",
                "Crouching Yeti",
                "IRON LIBERTY",
                "Energetic Bear",
                "Ghost Blizzard"
            ],
            "source_name": "MITRE:Dragonfly",
            "tools": [
                "MCMD",
                "Impacket",
                "CrackMapExec",
                "Backdoor.Oldrea",
                "Mimikatz",
                "PsExec",
                "Trojan.Karagany",
                "netsh"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "1a76ed30-4daf-4817-98ae-87c667364464",
            "created_at": "2022-10-25T16:47:55.891029Z",
            "updated_at": "2025-03-27T02:05:17.408867Z",
            "deleted_at": null,
            "main_name": "IRON LIBERTY",
            "aliases": [
                "ATK6 ",
                "BROMINE ",
                "CASTLE ",
                "Crouching Yeti ",
                "DYMALLOY ",
                "Dragonfly ",
                "Energetic Bear / Berserk Bear ",
                "Ghost Blizzard ",
                "TEMP.Isotope ",
                "TG-4192 ",
                "ALLANITE "
            ],
            "source_name": "Secureworks:IRON LIBERTY",
            "tools": [
                " Ddex Loader",
                " Havex",
                " Karagany",
                " Loek",
                " MCMD",
                " Sysmain",
                " xfrost",
                "ClientX"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "3a0be4ff-9074-4efd-98e4-47c6a62b14ad",
            "created_at": "2022-10-25T16:07:23.590051Z",
            "updated_at": "2025-03-27T02:02:09.878211Z",
            "deleted_at": null,
            "main_name": "Energetic Bear",
            "aliases": [
                "ATK 6",
                "Blue Kraken",
                "Crouching Yeti",
                "Dragonfly",
                "Electrum",
                "Energetic Bear",
                "Ghost Blizzard",
                "Group 24",
                "ITG15",
                "Iron Liberty",
                "Koala Team",
                "TG-4192"
            ],
            "source_name": "ETDA:Energetic Bear",
            "tools": [
                "Backdoor.Oldrea",
                "CRASHOVERRIDE",
                "Commix",
                "CrackMapExec",
                "CrashOverride",
                "Dirsearch",
                "Dorshel",
                "Fertger",
                "Fuerboos",
                "Goodor",
                "Havex",
                "Havex RAT",
                "Hello EK",
                "Heriplor",
                "Impacket",
                "Industroyer",
                "Karagany",
                "Karagny",
                "LightsOut 2.0",
                "LightsOut EK",
                "Listrix",
                "Oldrea",
                "PEACEPIPE",
                "PHPMailer",
                "PsExec",
                "SMBTrap",
                "Subbrute",
                "Sublist3r",
                "Sysmain",
                "Trojan.Karagany",
                "WSO",
                "Webshell by Orb",
                "Win32/Industroyer",
                "Wpscan",
                "nmap",
                "sqlmap",
                "xFrost"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "a97cf06d-c2e2-4771-99a2-c9dee0d6a0ac",
            "created_at": "2022-10-25T16:07:24.349252Z",
            "updated_at": "2025-03-27T02:02:10.184406Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "ATK 13",
                "Belugasturgeon",
                "Blue Python",
                "CTG-8875",
                "Group 88",
                "ITG12",
                "Iron Hunter",
                "Krypton",
                "Makersmark",
                "Operation Epic Turla",
                "Operation Moonlight Maze",
                "Operation Penguin Turla",
                "Operation Satellite Turla",
                "Operation Skipper Turla",
                "Operation Turla Mosquito",
                "Operation WITCHCOVEN",
                "Pacifier APT",
                "Pensive Ursa",
                "Popeye",
                "SIG15",
                "SIG2",
                "SIG23",
                "Secret Blizzard",
                "TAG-0530",
                "Turla",
                "UNC4210",
                "Venomous Bear",
                "Waterbug"
            ],
            "source_name": "ETDA:Turla",
            "tools": [
                "ASPXSpy",
                "ASPXTool",
                "ATI-Agent",
                "AdobeARM",
                "Agent.BTZ",
                "Agent.DNE",
                "BigBoss",
                "COMpfun",
                "Chinch",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobra Carbon System",
                "ComRAT",
                "DoublePulsar",
                "EmPyre",
                "EmpireProject",
                "Epic Turla",
                "EternalBlue",
                "EternalRomance",
                "GoldenSky",
                "Group Policy Results Tool",
                "HTML5 Encoding",
                "HyperStack",
                "IcedCoffee",
                "IronNetInjector",
                "KSL0T",
                "Kapushka",
                "Kazuar",
                "KopiLuwak",
                "Kotel",
                "LOLBAS",
                "LOLBins",
                "LightNeuron",
                "Living off the Land",
                "Maintools.js",
                "Metasploit",
                "Meterpreter",
                "MiamiBeach",
                "Mimikatz",
                "MiniDionis",
                "Minit",
                "NBTscan",
                "NETTRANS",
                "NETVulture",
                "Neptun",
                "NetFlash",
                "NewPass",
                "Outlook Backdoor",
                "Penquin Turla",
                "Pfinet",
                "PowerShell Empire",
                "PowerShellRunner",
                "PowerShellRunner-based RPC backdoor",
                "PowerStallion",
                "PsExec",
                "PyFlash",
                "QUIETCANARY",
                "Reductor RAT",
                "RocketMan",
                "SMBTouch",
                "SScan",
                "Satellite Turla",
                "SilentMoon",
                "Sun rootkit",
                "TTNG",
                "TadjMakhal",
                "Tavdig",
                "TinyTurla",
                "TinyTurla Next Generation",
                "TinyTurla-NG",
                "Topinambour",
                "Tunnus",
                "Turla",
                "Turla SilentMoon",
                "TurlaChopper",
                "Uroburos",
                "Urouros",
                "WCE",
                "WITCHCOVEN",
                "WhiteAtlas",
                "WhiteBear",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "Wipbot",
                "WorldCupSec",
                "XTRANS",
                "certutil",
                "certutil.exe",
                "gpresult",
                "nbtscan",
                "nbtstat",
                "pwdump"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "8aaa5515-92dd-448d-bb20-3a253f4f8854",
            "created_at": "2024-06-19T02:03:08.147099Z",
            "updated_at": "2025-03-27T02:05:17.408118Z",
            "deleted_at": null,
            "main_name": "IRON HUNTER",
            "aliases": [
                "Belugasturgeon ",
                "Blue Python ",
                "CTG-8875 ",
                "ITG12 ",
                "KRYPTON ",
                "MAKERSMARK ",
                "Pensive Ursa ",
                "Secret Blizzard ",
                "Turla",
                "UAC-0003 ",
                "UAC-0024 ",
                "UNC4210 ",
                "Venomous Bear ",
                "Waterbug ",
                "ATK13 "
            ],
            "source_name": "Secureworks:IRON HUNTER",
            "tools": [
                " ComRAT",
                " Kazuar",
                " KopiLuwak",
                " LightNeuron",
                " Mosquito",
                " Nautilus",
                " Neuron",
                " Penquin",
                " PoisonFrog",
                " PyFlash",
                " Skipper",
                " Snake",
                " Tavdig",
                " TinyTurla",
                " Tunnus",
                "Carbon-DLL"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a97fee0d-af4b-4661-ae17-858925438fc4",
            "created_at": "2023-01-06T13:46:38.396415Z",
            "updated_at": "2025-03-27T02:00:02.823045Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Uroburos",
                "Hippo Team",
                "Pacifier APT",
                "MAKERSMARK",
                "ATK13",
                "UAC-0003",
                "IRON HUNTER",
                "Waterbug",
                "TAG_0530",
                "KRYPTON",
                "Popeye",
                "SIG23",
                "UAC-0144",
                "G0010",
                "Blue Python",
                "VENOMOUS Bear",
                "Group 88",
                "Pfinet",
                "ITG12",
                "UNC4210",
                "Secret Blizzard",
                "UAC-0024"
            ],
            "source_name": "MISPGALAXY:Turla",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d11c89bb-1640-45fa-8322-6f4e4053d7f3",
            "created_at": "2022-10-25T15:50:23.509601Z",
            "updated_at": "2025-03-27T02:00:55.487991Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Turla",
                "IRON HUNTER",
                "Group 88",
                "Waterbug",
                "WhiteBear",
                "Krypton",
                "Venomous Bear",
                "Secret Blizzard",
                "BELUGASTURGEON"
            ],
            "source_name": "MITRE:Turla",
            "tools": [
                "PsExec",
                "nbtstat",
                "ComRAT",
                "netstat",
                "certutil",
                "KOPILUWAK",
                "IronNetInjector",
                "LunarWeb",
                "Arp",
                "Uroburos",
                "PowerStallion",
                "Kazuar",
                "Systeminfo",
                "LightNeuron",
                "Mimikatz",
                "Tasklist",
                "LunarMail",
                "HyperStack",
                "NBTscan",
                "TinyTurla",
                "Penquin",
                "LunarLoader"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1698804312,
    "ts_updated_at": 1743041781,
    "ts_creation_date": 1683554241,
    "ts_modification_date": 1683718536,
    "files": {
        "pdf": "https://archive.orkl.eu/b031465c809a1a7e6a24b482347ae2307cf371a4.pdf",
        "text": "https://archive.orkl.eu/b031465c809a1a7e6a24b482347ae2307cf371a4.txt",
        "img": "https://archive.orkl.eu/b031465c809a1a7e6a24b482347ae2307cf371a4.jpg"
    }
}