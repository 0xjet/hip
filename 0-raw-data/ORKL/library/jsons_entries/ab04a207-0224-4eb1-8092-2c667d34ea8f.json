{
    "id": "ab04a207-0224-4eb1-8092-2c667d34ea8f",
    "created_at": "2023-01-12T15:07:36.252266Z",
    "updated_at": "2025-03-27T02:05:52.945195Z",
    "deleted_at": null,
    "sha1_hash": "b4b46a12732e1a09c62ec46c73d0cfe89e8c6094",
    "title": "2016-09-02 - Necurs – hybrid spam botnet",
    "authors": "",
    "file_creation_date": "2022-05-28T04:07:00Z",
    "file_modification_date": "2022-05-28T04:07:00Z",
    "file_size": 520221,
    "plain_text": "# Necurs – hybrid spam botnet\n\n**cert.pl/en/news/single/necurs-hybrid-spam-botnet/**\n\n[Necurs is one of the biggest botnets in the world – according to MalwareTech there are a](https://intel.malwaretech.com/botnet/necurs_dga/?h=24)\ncouple millions of infected computers, several hundred thousand of which are online at any\ngiven time. Compromised computers send spam email to large number of recipients –\nusually the messages are created to look like a request to check invoice details or to confirm\npurchase. The attachments contain packed scripts which install malware when ran.\nCurrently, the dropped ransomware is Locky, which encrypts the hard disk and then asks for\nmoney (often in Bitcoin) in order to retrieve the original files. Necurs is an example of hybrid\nnetwork in terms of Command and Control architecture – a mixture of centralized model\n(which allows to quickly control the botnet), with peer-to-peer (P2P) model, making it next to\nimpossible to take over the whole botnet by shutting down just a single server. For those\nreasons, the huge success of Necurs is no surprise.\n\n## Behaviour\n\nThe malware attempts to connect to the C2 server, whose IP address is retrieved in a\nnumber of different ways. First, a couple of domains or raw IP addresses are embedded in\nthe program resources (in encrypted form – more about this in the technical analysis\nsection). If the connection fails, Necurs runs domain generation algorithm, crafting up to\n2048 pseudorandom names, generation of which depends on current date and seed\nhardcoded in encrypted resources, and tries them all in a couple of threads. If any of them\nresolves and responds using the correct protocol, it is saved as a server address. Otherwise,\nif all these methods fail, C2 domain is retrieved from the P2P network – the initial list of about\n2000 peers (in form of IP+port pairs) is hardcoded in the binary. During analysis, Necurs\nused the last method, since none of the DGA domains was responding. It is however\npossible, that in the future the botnet’s author will start to register these domains – a new list\nof potential addresses is generated every 4 days.\n\n\n-----\n\nAfter establishing a successful connection to the C2, Necurs downloads (using custom\nprotocol over HTTP) a list of information – from now on, I will call them “resources”. Every\nresource is identified by a constant 64-bit number. It is quite likely a hash of some sensible\nname used in source code, but after compilation we obviously cannot access it. Nonetheless,\nanalyzing how these resources are used in the code, we could map some of the IDs to useful\nnames.\n\nExamples of information sent by the C2 include: new P2P neighborhood (ca. 2000 IP:port\npairs), new C2 domain list, sleep command (usually about twenty minutes or so), or request\nto download and run DLL module. Every request we receive contains the sleep request – it is\nprobably a way to reduce the server’s load.\n\nThe analyzed binary did not contain what we really sought – mail sending routine. As it turns\nout, that functionality is in one of the dropped DLLs. Unfortunately, it was written in C++,\nwhich increased code size (because the author used C++ templates) and therefore, slowed\ndown reverse engineering. For that reason, we mostly used behavioral analysis – debugging\nmalware and observing sent data (before the encryption of course).\n\nAs we could see, the payload is formatted as JSON. Unfortunately all of the keys were\nobfuscated and it was impossible to discover their meaning just by the name – for example\n“dg3XGB9” corresponds to the current Unix time. There are a couple of message formats,\nbut not all of them are really interesting. The most important was the request for mail to be\nsent and of course the server’s response. The text Necurs sends is not just literal email – a\nsimple script language is used to randomize them:\n\n\n-----\n\nWe can see, that the script supports local variables (declared by %%var directive),\npredefined functions, such as randnum, but there are also references to external data –\ne.g. [file.doc] – these variables are downloaded in a separate request. We checked the\nattachments, and despite the name (file.doc), these are ZIP archives containing a single JS\nfile. When executed, they download and run Zepto, a rather new variant of Locky\nransomware.\n\n## Technical analysis\n\nNecurs uses a couple of anti-analysis techniques. For example, every C2 connection is\nattempted randomly: either to the address given in function argument, or to the address\nbeing a hash of the argument. Virtualization is detected using instructions such as “vmcpuid”,\nor “in al”. Some malware analysis environments can also fail on checking whether Facebook\nand random domain resolve to the same IP address. Many texts and binary resources are\nencrypted – communication with peers and C2 as well.\n\n**Resources**\n\nConstants in the binary are hidden in a separate section – the file contains two named\n“.reloc” sections, the second of which contains resources. First four bytes of that section are\ninterpreted as a decryption key, and the resources themselves start at offset 0x18. Every\nbyte is xored with key, which changes according to LCG\nalgorithm: K’=K*0x19661f+0x3c6ef387. After decryption, the data is a list of concatenated\nstructures of the following format:\n\nLast field size is size>>8. Every resource has its unique identifier – examples of resources\nare initial peer or C2 communication keys or initial peer neighborhood list.\n\n**P2P communication**\n\nP2P communication is unfortunately much more complicated. All information exchange\nhappens over UDP protocol. The outermost layer of communication is:\n\nWrapped data are encrypted using the key calculated as a sum of the key field and the first\n32 bits of the public key contained in file resources. The homemade encryption algorithm is\nequivalent to the following Python code:\n\nChecksum sent as second field in the structure is simply a final value of key after encryption.\nThe decrypted data have the following form:\n\nSize of data is size_flag>>4, and the type of the message is determined by four least\nsignificant bits of that field. For example, first message (“greeting”) has these bits all zeroed.\n\nThe next stage depends on the message type. For the first message, the structure is:\n\nShould the peer respond the message has the following form:\n\n\n-----\n\nThe whole message is signed using key from file resources. The most important field of this\nstructure is resources – list of resources in the same format as described in “Resources”\nsection. Interestingly, peers don’t send new neighborhood list – these are sent by the C2\nitself. The most likely reason for this measure is avoiding P2P poisoning, since it is known\nthat peer list received from the main server is authorized and correct.\n\n**C2 communication**\n\nC2 protocol is vaguely similar to the P2P one, but encryption routines and structures it uses\nare a bit different – also, the underlying protocol is HTTP (POST payload) instead of raw\nUDP sockets. The first stage is exactly the same (outer_layer structure), with different\nconstants in encryption algorithm:\n\nDecrypted data is of the following structure:\n\nThe first field contains randomly generated 8 bytes, probably to increase entropy of sent data\nand to make it harder to see patterns like common initial bytes across messages.\n\nContents of the payload field (perhaps compressed, depending on the second bit of flags)\ndepends on message type (command field). If it is file download request (command=1), the\npayload is simply the SHA-1 hash of the requested file. On the other hand, if the whole\nmessage is a periodic command request (command=0), the payload structure is much more\ncomplex – again, a kind of list of resources, but with different structure. Every resource has\nthe following general form (can be thought of as header):\n\nDepending on resource type, data has different format:\n\nType 4 is usually used to send text data, which is probably the reason of the resource size\nbeing increased by one (for null terminator). Client sends a list of such resources to the C2.\nWe were able to identify the meaning of some of them:\n\nDGA seed\nnumber of seconds since malware start\nUnix timestamp of malware start\nOS version and its default language\ncomputer’s IP (local if behind NAT)\nUDP port used to listen for P2P connections\ncustom hash of current peer list\n\nThe server response uses a very similar format. The payload also depends on request type –\nif it was 1 (download file request), server responds with that file’s contents (usually\ncompressed, depending on flags). For command request, the server response is the list of\nresources in the same format as above. Some of these resources can be interpreted as\n\n\n-----\n\ncommands to be executed, for example sleep N milliseconds or log off the user (although\nI did not see the latter used in the wild).\nSample (parsed) resource list received from C2:\n\nOut of a large number of possible resources, the most important are the new peer list (only if\nits hash differs from current), or announcement of a new DLL being available to download.\nThe latter resource has its own structure for communication purposes (a real matrioshka!),\nalso made of a list of concatenated sub-resources of the following form:\n\nThe command can be interpreted as a request for running DLL identified by its SHA-1 with\ncommand line parameters stated in cmdline field – in practice, the argument is a newlineseparated list of C2 addresses (with HTTP path) to be connected to.\n\n\n-----\n\n**Spam C2 communication**\n\nThe last protocol I will describe in this post, is the communication of the downloaded DLL\nmodule, whose responsibility is to send spam emails. The information is wrapped in the\nfollowing structure (sent as POST data over HTTP):\n\nThe encryption algorithm:\n\nAfter decryption, there are no more steps – we receive raw data as a JSON string (unless\nthe compression flag was set, in which case the data needs to be unpacked – as we found\nout, a QuickLZ library was used in the malware for this purpose). Unfortunately, keys are\nobfuscated, so we had to guess their meaning. Sample JSON (pretty-printed and edited to fit\non screen):\n\n\n-----\n\nFinally, one of the fields in the received dictionary contains a script used to generate\nrandomized emails (like on the top of the post), and as another field – list of parameters\npassed to this script (e.g. eng_Names). We can make a separate request to download value\nof these arguments – as a response, we will receive, for example, list of English names to be\nsubstituted, or a few base64-encoded files to be used as an attachment.\n\n**Example communication**\n\n\n-----\n\nI m aware understanding all those structures and ways they are used is quite hard, so I have\ncreated a simplified graph showing the data flow. Example communication could look like\nthis:\n\n\n-----\n\nSample hashes:\nfe929245ee022e3410b22456be10c4f1 - original file (packed)\n35be639c5618272f70a0bbfbc25d4465 - dropped DLL module\n\nYARA rules:\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-09-02 - Necurs – hybrid spam botnet.pdf"
    ],
    "report_names": [
        "2016-09-02 - Necurs – hybrid spam botnet.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536056,
    "ts_updated_at": 1743041152,
    "ts_creation_date": 1653710820,
    "ts_modification_date": 1653710820,
    "files": {
        "pdf": "https://archive.orkl.eu/b4b46a12732e1a09c62ec46c73d0cfe89e8c6094.pdf",
        "text": "https://archive.orkl.eu/b4b46a12732e1a09c62ec46c73d0cfe89e8c6094.txt",
        "img": "https://archive.orkl.eu/b4b46a12732e1a09c62ec46c73d0cfe89e8c6094.jpg"
    }
}