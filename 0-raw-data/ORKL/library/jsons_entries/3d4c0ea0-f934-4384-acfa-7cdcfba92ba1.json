{
    "id": "3d4c0ea0-f934-4384-acfa-7cdcfba92ba1",
    "created_at": "2023-01-12T15:02:28.164964Z",
    "updated_at": "2025-03-27T02:15:24.905072Z",
    "deleted_at": null,
    "sha1_hash": "6648a70b732ec3ecafc737a6864141b49686a344",
    "title": "2020-12-03 - TrickBot Now Offers ‘TrickBoot’- Persist, Brick, Profit",
    "authors": "",
    "file_creation_date": "2022-05-28T00:25:16Z",
    "file_modification_date": "2022-05-28T00:25:16Z",
    "file_size": 1249623,
    "plain_text": "# TrickBot Now Offers ‘TrickBoot’: Persist, Brick, Profit\n\n**[eclypsium.com/2020/12/03/trickbot-now-offers-trickboot-persist-brick-profit/](https://eclypsium.com/2020/12/03/trickbot-now-offers-trickboot-persist-brick-profit/)**\n\nEclypsium December 3, 2020\n\n## Researchers discover a new module in the TrickBot toolset aimed at detecting UEFI / BIOS firmware vulnerabilities\n\n_[Join AdvIntel and Eclypsium for a live webinar exploring the implications of Trickbot’s foray](https://www.brighttalk.com/webcast/17865/457875?utm_source=Eclypsium&utm_medium=brighttalk&utm_campaign=457875)_\n_into firmware on December 9, 2020._\n\n[Download the PDF >](https://eclypsium.com/wp-content/uploads/2020/12/TrickBot-Now-Offers-TrickBoot-Persist-Brick-Profit.pdf)\n\n## Executive Summary\n\n\n-----\n\n[Collaborative research between Advanced Intelligence (AdvIntel) and Eclypsium has](https://www.advanced-intel.com/)\ndiscovered that the TrickBot malware now has functionality designed to inspect the\nUEFI/BIOS firmware of targeted systems. This new functionality, which we have dubbed\n“TrickBoot,” makes use of readily available tools to check devices for well-known\nvulnerabilities that can allow attackers to read, write, or erase the UEFI/BIOS firmware of a\ndevice.\n\nAt the time of writing, our research uncovered TrickBot performing reconnaissance for\nfirmware vulnerabilities. This activity sets the stage for TrickBot operators to perform more\nactive measures such as the installation of firmware implants and backdoors or the\ndestruction (bricking) of a targeted device. It is quite possible that threat actors are already\n[exploiting these vulnerabilities against high-value targets. Similar UEFI-focused threats have](https://eclypsium.com/2020/10/14/protecting-your-organizations-from-mosaicregressor-and-other-uefi-implants/)\ngone years before they have been detected. Indeed, this is precisely their value to attackers.\n\nThis marks a significant step in the evolution of TrickBot. Firmware level threats carry unique\nstrategic importance for attackers. By implanting malicious code in firmware, attackers can\nensure their code is the first to run. Bootkits allow an attacker to control how the operating\nsystem is booted or even directly modify the OS to gain complete control over a system and\nsubvert higher-layer security controls. UEFI level implants are powerful and stealthy. Since\nfirmware is stored on the motherboard as opposed to the system drives, these threats can\nprovide attackers with ongoing persistence even if a system is re-imaged or a hard drive is\nreplaced. Equally impactful, if firmware is used to brick a device, the recovery scenarios are\nmarkedly different (and more difficult) than recovery from the traditional file-system\nencryption that a ransomware campaign like Ryuk, for example, would require.\n\nTrickBot has proven to be one of the most adaptable pieces of malware today, regularly\nincorporating new functionality to escalate privilege, spread to new devices, and maintain\npersistence on a host. The addition of UEFI functionality marks an important advance in this\nongoing evolution by extending its focus beyond the operating system of the device to lower\nlayers that are often not inspected by security products and researchers.\n\nGiven that the TrickBot group toolset has been used by some of the most dangerous\ncriminal, Russian, and North Korean actors to target healthcare, finance, telecoms,\neducation, and critical infrastructure, we view this development as critically important to both\nenterprise risk and national security. Adversaries leveraging TrickBot now have an\nautomated means to know which of their latest victim hosts are vulnerable to UEFI\nvulnerabilities, much like they added capabilities in 2017 to exploit EternalBlue and\nEternalRomance vulnerabilities.\n\n## Contents:\n\n TrickBot Background\n\n\n-----\n\nTrickBot is a highly modular trojan that is particularly notable for its ability to gain\nadministrator privileges, spread within a network, and deliver additional malware payloads.\nOriginally identified in 2016, TrickBot was initially focused on stealing financial data and was\nconsidered a banking trojan. However, as the malware evolved, attackers quickly found that\nit was a valuable enabler in all types of malware campaigns. Notably, TrickBot has been\n[widely observed working in conjunction with Emotet to deliver Ryuk ransomware.](https://www.youtube.com/watch?v=u1XvMcwdvgI&feature=youtu.be&t=310)\n\nTrickBot includes several key features that make it valuable for persistent malware\ncampaigns. The tool is able to capture user and admin credentials using Mimikatz and has\n[incorporated UAC bypass techniques to ensure it can run with administrator privileges on an](https://www.bleepingcomputer.com/news/security/trickbot-uses-a-new-windows-10-uac-bypass-to-launch-quietly/)\ninfected host without alerting the user. TrickBot also makes use of the EternalBlue exploit\n(MS17-010) to spread to additional hosts in the network via SMB. These capabilities make\nTrickBot an ideal dropper for almost any additional malware payload. By adding the ability to\ncanvas victim devices for specific UEFI/BIOS firmware vulnerabilities, TrickBot actors are\nable to target specific victims with firmware-level persistence that survives re-imaging or\neven device bricking capability.\n\nThe following graphics show the last two months of active TrickBot infections, peaking at up\nto 40,000 in a single day. Getting a footprint is not a challenge for TrickBot operators.\nDetermining which victims are high-value targets and persisting in those environments to hit\nthem again later defines a large portion of the TrickBot toolset and frames the significance of\nthis discovery.\n\n**Credit:** [AdvIntel](https://www.advanced-intel.com/)\n\n\n-----\n\nThe number of Active TrickBot infections globally, post-TrickBot take-down attempts by cyber\nvendors and US Cyber Command, based on ISP geo. Credit: [AdvIntel](https://www.advanced-intel.com/)\n\n## TrickBot Actor Insights\n\nWhile TrickBot as a malware toolset has been used by a diverse set of actors, there is one\ngroup that drives the majority of its use and is worth providing insights on in the context of\nthis research in order to emphasize how powerful and successful TrickBot-based campaigns\nare. The group’s alias is “Overdose,” and they are the primary Platform-as-a-Service fraud\ngroup behind TrickBot campaigns, namely those that result in Conti and Ryuk ransomware.\n[The group has made at least $150m since 2018 and recently extracted ~$34m (2,200 BTC)](https://www.bleepingcomputer.com/news/security/how-ryuk-ransomware-operators-made-34-million-from-one-victim/)\n[from a single victim. This is the same group behind a spate of attacks on Healthcare victims,](https://www.advanced-intel.com/post/anatomy-of-attack-inside-bazarbackdoor-to-ryuk-ransomware-one-group-via-cobalt-strike)\nincluding that of UHS. No direct attribution has been made as to their identity, other than they\nare Russian-speaking and Eastern European. As can be seen in the graphic below, they\nparticipate in a number of criminal/fraud-related activities.\n\nTheir most common attack chain largely begins via EMOTET malspam campaigns, which\nthen loads TrickBot and/or other loaders, and moves to attack tools like PowerShell Empire\nor Cobalt Strike to accomplish objectives relative to the victim organization under attack.\nOften at the end of the kill-chain either Conti or Ryuk ransomware is deployed\n\n\n-----\n\n[The same actor also uses LightBot, which is a set of PowerShell scripts designed to perform](https://www.bleepingcomputer.com/news/security/lightbot-trickbot-s-new-reconnaissance-malware-for-high-value-targets/)\nreconnaissance on victim networks, hardware, and software, in order to hand-pick which are\nhigh-value targets. It is clear that such actors would benefit greatly from including a UEFI\nlevel bootkit in their kill chain. They would survive system re-imagining efforts during the\nrecovery phase of a Ryuk or Conti event, and they would further their ability to semipermanently brick a device. This provides criminal actors more leverage during ransom\nnegotiation.\n\nWith this module, the TrickBot kill chain is primed with a list of vulnerable targets for\nfirmware-level compromise. The malware authors can leverage Emotet to malspam\norganizations and use TrickBoot to understand where and how to target the UEFI firmware.\nRyuk and Conti malware operators often offer to remove backdoors in an enterprise if the\nransom is paid. With this new module, these actors can remove backdoors like webshells,\naccounts, remote admin tools but keep a covert UEFI implant on the system to leverage\nlater.\n\n## DISCOVERY OF NEW TRICKBOOT FUNCTIONALITY\n\nCollaborative research between Advanced Intelligence (AdvIntel) and Eclypsium has\ndiscovered new TrickBot functionality capable of probing the UEFI/BIOS firmware for nearly\nall Intel-based systems since 2014. The new functionality, which we have dubbed\n\n\n-----\n\nTrickBoot, leverages readily available tools to enable the following reconnaissance actions:\n\nIdentify the device platform\nCheck the status of BIOS write protections for the SPI flash\nCheck for well-known vulnerabilities that can allow attackers to read, write, or erase\nUEFI/BIOS firmware.\n\nThus far, the TrickBot module is only performing reconnaissance and has not been seen\nmodifying the firmware itself. However, the malware already contains code to read, write, and\nerase firmware. These primitives could be used to insert code to maintain persistence, as\nhas been seen previously with the LoJax or MosaicRegressor. Attackers could also simply\nerase the BIOS region to completely disable the device as part of a destructive attack or\nransomware campaign. The possibilities are almost limitless.\n\nTrickBot has a history of reusing established tools and exploits such as Mimikatz and\nEternalBlue, and the malware is taking a similar approach to achieving persistence.\nSpecifically, TrickBoot uses the RwDrv.sys driver from the popular RWEverything tool in\norder to interact with the SPI controller to check if the BIOS control register is unlocked and\nthe contents of the BIOS region can be modified. TrickBoot includes an obfuscated copy of\nRwDrv.sys embedded within the malware itself. It drops the driver into the Windows directory,\nstarts the RwDrv service, and then makes DeviceIoControl calls to talk to the hardware.\n\nRWEverything (read-write everything) is a powerful tool that can allow an attacker to write to\nthe firmware on virtually any device component, including the SPI controller that governs the\nsystem UEFI/BIOS. This can allow an attacker to write malicious code to the system\nfirmware, ensuring that attacker code executes before the operating system while also hiding\nthe code outside of the system drives. These capabilities have been abused in the past as a\n[way for attackers to maintain persistence in firmware, most notably by the LoJax malware](https://www.trendmicro.com/vinfo/us/security/news/cyber-attacks/lojax-uefi-rootkit-used-in-cyberespionage)\n[and the Slingshot APT campaign. However, TrickBoot marks a significant expansion of these](https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2018/03/09133534/The-Slingshot-APT_report_ENG_final.pdf)\ntechniques in the wild.\n\n## TECHNICAL ANALYSIS\n\nAs is often the case with new TrickBot modules, the name “PermaDll” or the original name as\n“user_platform_check.dll” caught the attention of Advanced Intelligence researchers during\nthe October 2020 discovery of the new TrickBot attack chain. “Perma,” sounding akin to\n“permanent,” was intriguing enough on its own to want to understand this module’s role in\nTrickBot’s newest arsenal of loadable modules with the usual TrickBot export modules. Initial\nanalysis pointed to the possibility there might be capabilities related to understanding\nwhether a victim system’s UEFI firmware could be attacked for purposes of persistence or\ndestruction. A joint collaboration was started with Eclypsium to analyze this module and to\nput whatever was found into context for defenders. During the initial discovery of this new\n\n\n-----\n\nmodule on October 19, 2020, the team processed the encoded permaDll32 . They\nleveraged a custom-built AES encryption TrickBot module decrypter, which revealed the\ndecoded module that became the subject of this in-depth analysis and discovery.\n\nIt took over five years for the industry to discover the use of Hacking Team’s VectorEDK\nUEFI implant code that was used in the wild as part of the MosaicRegressor campaign,\ndespite the source code being readily available on github and even documented in its use.\nGiven how active, well-resourced, and capable TrickBot authors are, we wanted to research,\nanalyze, and expose whatever tooling they already have in place in order to allow\norganizations to prepare effective defenses more rapidly.\n\nThe malware module outputs “PCH” queries based on the string slicing obfuscation.\n\n\n-----\n\nThe “permaDll” module checks for administrator privileges with the output “Not Admin.”\n\n## Overview of the Boot Process, SPI Controller, and UEFI Firmware\n\nThe boot process governs how a system and its components are initialized and coordinates\nthe loading of the operating system, making it one of the most fundamentally important\naspects of security for any device. The code supporting the boot process is the first code\nexecuted on a system and is likewise some of the most privileged code, requiring protection\neven from privileged operating system (OS) code. If the boot process is compromised,\nattackers gain control over the OS itself and establish ongoing persistence on the device\neven if the OS is reinstalled.\n\nThe boot process begins in the SPI flash memory chip that is built into the motherboard of\nthe device. The SPI contains the system’s BIOS, or more often, UEFI firmware, which has\nlargely replaced BIOS as the default system firmware in modern systems. This UEFI\nfirmware will control the boot process and ultimately select the appropriate OS bootloader\nand execute the initial OS code before handing control over to the operating system itself.\n\nAll requests to the UEFI firmware stored in the SPI flash chip go through the SPI controller,\nwhich is part of the Platform Controller Hub (PCH) on Intel platforms. This SPI controller\nincludes access control mechanisms, which can be locked during the boot process in order\nto prevent unauthorized modification of the UEFI firmware stored in the SPI flash memory\nchip. Modern systems are intended to enable these BIOS write protections to prevent the\n\n\n-----\n\nfirmware from being modified; however, these protections are often not enabled or\nmisconfigured. If the BIOS is not write-protected, attackers can easily modify the firmware or\neven delete it completely.\n\nMore broadly, any time an actor can write to SPI flash, there are a number of extremely\nuseful things that can be accomplished from the attacker’s perspective:\n\nBricking a device at the firmware level via a remote malware or ransomware campaign.\nRe-infecting a device that’s just been through a traditional system restore process.\nBypassing or disabling security controls that OS and software rely upon, such as\nvirtualization-and container-based security isolation, credentials isolation, softwarebased full-disk encryption, and other endpoint and identity protection controls.\nChaining exploitation of other device components such as Intel CSME/AMT firmware or\nBaseboard Management Controllers.\nRolling back important firmware and microcode updates patching hardware flaws like\nCPU transient execution vulnerabilities.\n\n## TrickBoot Implications\n\nThe TrickBot malware toolkit has a broad impact on national security. Used by criminal,\nRussian, and North Korean actors, it is widely deployed and benefits from the most\nwidespread malspam apparatus of our day: Emotet. In a single day in October, 40,000\nactive, fully compromised devices were observed. Because it is offered only to the most\nvetted and well-funded actors, it has been forged into what can best be described as an\narsenal of capability, integrating powerful exploitation capabilities like EternalBlue and\nEternalRomance to help it worm through networks and leveraging PowerShell to perform\nextremely effective reconnaissance to determine high-value targets. It does this with agility,\nstealth, and the ability to incorporate specific modules only as needed to accomplish\ncampaign objectives without tipping its hat to defenders. Organizations should note the\nfollowing considerations when assessing the impact of the new TrickBoot capability:\n\n1. This new capability provides TrickBot operators a way to brick any device it finds to be\n\nvulnerable. Recovering from corrupted UEFI firmware requires replacing or re-flashing\nthe motherboard, which is more labor-intensive than simply re-imagining or replacing a\nhard drive. The new TrickBoot module targets all Intel-based systems produced in\nrecent years. While it looks for a particular type of known vulnerability in how system\nfirmware is protected in persistent SPI flash, UEFI is a very complex firmware\nimplementation with many vulnerabilities discovered in recent years, which makes the\nmajority of the systems in use today susceptible to this threat.\n\n\n-----\n\n2. Historically, TrickBot actors have needed to evade and persist at the operating system\n\nlevel. But this has become a ‘race against time,’ as eventually today’s AV and EDR\ntools catch up to the actor at the OS layer. Once UEFI persistence is achieved,\nTrickBot operators can disable most of the OS level security controls, which then allows\nthem to re-surface to a modified OS with neutered endpoint protections and carry out\nobjectives with unhurried time on their side.\n\n3. Normally an actor wanting to gain UEFI level access needs to plan, customize, and\n\nbuild attack tools to target a specific victim environment. But with TrickBoot, actors can\nsimply ‘land’ on tens of thousands of hosts per day and extract which of them are\ninside a high-value target organization and vulnerable to UEFI attacks.\n\n4. Actors are going lower in the stack to avoid detection. The same actors (APT28)\n\nbehind the DNC hack in 2016 also deployed LoJax, a UEFI implant with a similar\ninfection method and use of the same vulnerability this TrickBoot module looks for. The\ndifference here is that TrickBot’s modular automated approach, robust infrastructure,\nand rapid mass-deployment capabilities bring a new level of scale to this trend. This\nscale allows threat actors to target verticals or portions of critical infrastructure with\ndestructive or espionage campaigns.\n\n5. Most organizations and missions are not tooled to be able to detect, let alone mitigate,\n\nthis class of firmware threat. It is precisely, for this reason, that threat actors push\nfurther down the stack. This means that as a nation, neither our proactive or reactive\nefforts are likely sufficient to get ahead of this new threat. Our hope is that this\ndiscovery, research, and recommended mitigations help elevate the awareness needed\nto address this global threat head-on.\n\n## TrickBoot Technical Details\n\nBoth 32-bit and 64-bit versions of this new TrickBot module have been observed so far.\n\nBoth versions appear to be functionally the same, but for this analysis, we’ll be using\naddresses and code samples from the 32-bit version.\n\n### Obfuscation Techniques\n\nTrickBot uses the string and library-call obfuscation library from\n[https://github.com/andrivet/ADVobfuscator, so most strings in the DLL are obfuscated. This](https://github.com/andrivet/ADVobfuscator)\nmodule does not use the library-call obfuscation, but other TrickBot samples have been\nfound to use that feature.\n\n\n-----\n\nRather than including obfuscated strings in the data section of the executable, all strings are\nencoded as inline instructions to write obfuscated strings to local stack frame buffers and\nthen immediately decode them at the time of use.\n\nSeveral variants of this obfuscation method are used within this sample, and each string has\nits own unique “key” value that is used to modify each byte of the string. Variants observed in\nthis sample include:\n\nsubtracting the key value from each byte\nxoring the key value against each byte\nadding the key value to the index into the string and xoring that against each byte\n\nA fourth variant, which uses dec to subtract one from each byte, was also found within the\nsample, but this is likely a compiler optimization of the subtract case when the value of 1 was\nchosen as the random key at compile time.\n\nSome previous TrickBot samples included this string-building and deobfuscation code inline\nwithin each function everywhere obfuscated strings are used, but this sample has many\ncopies of the deobfuscation functions. Most are used to decode only a single string, but\nthese can be re-used when strings are the same length, and the same variant is being used.\n\nThe deobfuscation variants look like this:\n\n\n-----\n\nIn addition to the obfuscated strings, this sample includes a copy of the RwDrv.sys driver\nfrom RWEverything which is simply xored against a hardcoded value. This value is 0x75 in\nthe 32-bit sample and 0x4E in the 64-bit sample. The function to decode the driver and drop\nit into the Windows directory is at 0x10009F9D, and we’ll refer to it as\n“decode_and_drop_rwdrvsys.”\n\n### RwDrv.sys kernel driver and other primitives\n\nRwDrv.sys is a well-known kernel driver that acts as a privileged proxy to allow userspace\napplications to directly access hardware interfaces. It has been used in the wild as part of\nattack campaigns such as Lojax to talk to the SPI controller hardware in order to modify the\nUEFI firmware by inserting new UEFI modules and gain pre-boot code execution and\npersistence.\n\nThis type of kernel driver is particularly dangerous because allowing user space applications\ndirect access to hardware interfaces can bypass operating security controls and gain\nprivilege escalation, persistence, and even brick the hardware itself. As part of a previous\nresearch effort, we identified a large number of these signed drivers which can be used in\nthis type of attack scenario and which generally give malware operators the ability to\nremotely perform firmware level attacks on victim hosts.\n\nAdditionally, 0x10009BFC, which we’ll refer to as “open_or_init_driver” is a helper function\nwhich calls decode_and_drop_rwdrvsys and also several other helper functions to load the\ndriver, create a Windows service, and open a handle to the RwDrv service.\n\nSince this sample doesn’t use the library-call obfuscation provided by ADVobfuscator, all of\nthe calls to DeviceIoControl are in-the-clear and easy to find. Thus, we can take a closer look\nat these functions and deobfuscate the strings they contain.\n\n\n-----\n\nAs an example, 0x1000B167 contains the obfuscated string uefi_expl_port_read() ERROR:\nNot initialized”. This code is from Dmytro Oleksiuk’s fwexpl repository available at\n[https://github.com/Cr4sh/fwexpl. In particular, this sample includes functions from](https://github.com/Cr4sh/fwexpl)\n[https://github.com/Cr4sh/fwexpl/blob/master/src/libfwexpl/src/libfwexpl_rwdrv.cpp in order to](https://github.com/Cr4sh/fwexpl/blob/master/src/libfwexpl/src/libfwexpl_rwdrv.cpp)\nuse the RwDrv.sys driver to access hardware interfaces.\n\nThe functions from [libfwexpl_rwdrv.cpp which are included in this TrickBot sample are:](https://github.com/Cr4sh/fwexpl/blob/master/src/libfwexpl/src/libfwexpl_rwdrv.cpp)\n\n**0x1000B167 uefi_expl_port_read**\n\nUses DeviceIoControl call to rwdrv.sys to read data from hardware IO ports\nSupports reading 8-bit (ioctl 0x222810), 16-bit (ioctl 0x222818), and 32-bit (ioctl\n0x222820) values\n\n**0x1000B4AC uefi_expl_port_write**\n\nUses DeviceIoControl call to rwdrv.sys to write data to hardware IO ports\nSupports writing 8-bit (ioctl 0x222814), 16-bit (ioctl 0x22281c), and 32-bit (ioctl\n0x222824) values.\n\n**0x1000A4BA uefi_expl_phys_mem_read**\n\nUses DeviceIoControl call to rwdrv.sys to read from physical memory addresses\nCan read data from arbitrary physical memory addresses via ioctl 0x222808\n\n**0x1000A973 uefi_expl_phys_mem_write**\n\nUses DeviceIoControl call to rwdrv.sys to write to physical memory addresses•\nCan write data to arbitrary physical memory addresses via ioctl 0x22280c\n\n### Platform model and hardware identification\n\nThe PCI access functions in the fwexpl repository require the user to calculate the legacy\nPCI configuration address to be used rather than taking bus, device, function and register\narguments, so two additional helper functions were added to make it easier to use:\n\n**0x1000A3FD pci_read_reg**\n\nUses uefi_expl_port_write and uefi_expl_port_read to read PCI registers via\nlegacy PCI Configuration Access Mechanism (ports 0xCF8 and 0xCFC)\n\n**0x1000A45A pci_write_reg**\n\nUses uefi_expl_port_write to write PCI registers via legacy PCI Configuration\nAccess Mechanism (ports 0xCF8 and 0xCFC)\n\nBuilding on top of these hardware-access primitives, the sample contains additional helper\nfunctions to perform a number of interesting operations such as 0x100093C7, which we’ll\nrefer to as “identify_platform.”\n\n\n-----\n\nThis function uses pci_read_reg to read VendorID, DeviceID, and RevisionID fields from the\nCPU Root Complex (BDF 0:0.0) and Platform Controller Hub (PCH) LPC Interface (BDF\n0:1F.0). Reading these allows permaDll32 to determine which specific model of CPU and\nPCH the device is running on.\n\npci_read_reg(0, 0, 0, 0, 2, &cpu_vid_did);\npci_read_reg(0, 0, 0, 8, 0, &cpu_rid);\npci_read_reg(0, 31, 0, 0, 2, &pch_vid_did);\npci_read_reg(0, 31, 0, 8, 0, &pch_rid);\n\nThe locations of registers for the SPI controller have changed over the generations of Intel\nPCH, and another function, 0x1000C00F, which we’ll refer to as “pch_did_to_generation,”\ncompares the PCH Device ID that was read from the hardware against a collection of known\nDeviceID values to determine which generation of PCH the code is running on.\n\nGenerally, this malware will attempt to run on all Intel platforms. This set of device IDs is\nused to determine where to look for the BIOS Control register, the Flash Protected Range\nregisters, and SPIBAR. The set of device IDs it looks for covers client platforms from Skylake\nthrough Comet Lake and also the C620 Series of Server PCH. If the device ID is something\nnot on this list, the malware will use the pre-Skylake register definitions. The tables of PCH\nDevice IDs included in this sample are the following:\n\n**0x1002402C 100 Series PCH DIDs (Skylake):**\n\n0xA143: Intel H110 (100 series) PCH\n0xA144: Intel H170 (100 series) PCH\n0xA145: Intel Z170 (100 series) PCH\n0xA146: Intel Q170 (100 series) PCH\n0xA147: Intel Q150 (100 series) PCH\n0xA148: Intel B150 (100 series) PCH\n0xA149: Intel C236 (100 series) PCH\n0xA14A: Intel C232 (100 series) PCH\n0xA14D: Intel CQM170 (100 series) PCH\n0xA14E: Intel HM170 (100 series) PCH\n0xA150: Intel CM236 (100 series) PCH\n0xA151: Intel QMS180 (100 series) PCH\n0xA152: Intel HM175 (100 series) PCH\n0xA153: Intel QM175 (100 series) PCH\n0xA154: Intel CM238 (100 series) PCH\n0xA155: Intel QMU185 (100 series) PCH\n0x9D43: PCH-U Baseline\n0x9D43: PCH-U Baseline\n\n**0x10024050 200 Series PCH DIDs (Kaby Lake):**\n\n\n-----\n\n0xA2C4: Intel H270 (200 series) PCH\n0xA2C5: Intel Z270 (200 series) PCH\n0xA2C6: Intel Q270 (200 series) PCH\n0xA2C7: Intel Q250 (200 series) PCH\n0xA2C8: Intel B250 (200 series) PCH\n0xA2C9: Intel Z370 (200 series) PCH\n0xA2D2: Intel X299 (200 series) PCH\n\n**0x10024060: 300 Series PCH DIDs (Coffee Lake):**\n\n0xA306: Intel Q370 (300 series) PCH\n0xA304: Intel H370 (300 series) PCH\n0xA305: Intel Z390 (300 series) PCH\n0xA308: Intel B360 (300 series) PCH\n0xA303: Intel H310 (300 series) PCH\n0xA30D: Intel HM370 (300 series) PCH\n0xA30C: Intel QM370 (300 series) PCH\n0xA30E: Intel CM246 (300 series) PCH\n0x9D4B: PCH-Y with iHDCP 2.2 Premium\n0x9D4E: PCH-U with iHDCP 2.2 Premium\n0x9D50: PCH-U with iHDCP 2.2 Base\n0x9D53: PCH-U Base\n0x9D56: PCH-Y Premium\n0x9D58: PCH-U Premium\n0x9D84: Intel 300 series On-Package PCH\n\n**0x10024080 400 Series PCH DIDs (Comet Lake):**\n\n0xA3C8: 400 series PCH B460\n0xA3DA: 400 series PCH H410\n0x068D: 400 series PCH (CML-H) HM470\n0x068E: 400 series PCH (CML-H) QM490\n0x069A: 400 series PCH (CML-H) H420E\n0x0284: Intel 400 series PCH-LP Prem-U\n0x0285: Intel 400 series PCH-LP Base-U\n0x3481: Intel 495 series PCH-LP U\n0x3482: Intel 495 series PCH-LP Prem-U\n0x3486: Intel 495 series PCH-LP Y\n0x3487: Intel 495 series PCH-LP Prem-Y\n\n**0x10024098 C620 Series Server PCH DIDs:**\n\n0xA1C1: Intel C621 (C620 series) PCH\n0xA1C2: Intel C622 (C620 series) PCH\n\n\n-----\n\n0xA1C3: Intel C624 (C620 series) PCH\n0xA1C4: Intel C625 (C620 series) PCH\n0xA1C5: Intel C626 (C620 series) PCH\n0xA1C6: Intel C627 (C620 series) PCH\n0xA1C7: Intel C628 (C620 series) PCH\n0xA1CA: Intel C629 (C620 series) PCH\n0xA242: Intel C624 (C620 series) PCH\n0xA243: Intel C627 (C620 series) PCH\n0xA244: Intel C621 (C620 series) PCH\n0xA245: Intel C627 (C620 series) PCH\n0xA246: Intel C628 (C620 series) PCH\n\nThe code has two copies of the 400 Series PCH DID entries and checks the current PCH\nDID against both, which appears to be a bug, but does not cause functional problems.\n\n**0x100240B4 Copy of 400 Series PCH DIDs (Comet Lake):**\n\n0xA3C8: 400 series PCH B460\n0xA3DA: 400 series PCH H410\n0x068D: 400 series PCH (CML-H) HM470\n0x068E: 400 series PCH (CML-H) QM490\n0x069A: 400 series PCH (CML-H) H420E\n0x0284: Intel 400 series PCH-LP Prem-U\n0x0285: Intel 400 series PCH-LP Base-U\n0x3481: Intel 495 series PCH-LP U\n0x3482: Intel 495 series PCH-LP Prem-U\n0x3486: Intel 495 series PCH-LP Y\n0x3487: Intel 495 series PCH-LP Prem-Y\n\n### Target-specific hardware resource configuration\n\nOnce the code has determined which generation of PCH it’s running on, it uses the function\nat 0x1000C0A2, which we’ll refer to as “get_regs_from_generation” to know where to access\nthese registers:\n\n**SPIBAR (Base Address Register for MMIO access to SPI controller registers)**\n\nThis register is used to gain access to additional SPI controller MMIO registers\nbeyond those in PCI Configuration Space.\n\n**BC (BIOS Control)**\n\nThis register contains write-protect and lock bits to control access to the BIOS\nRegion at the hardware level.\n\n\n-----\n\n**PR0-PR4 (Flash Protected Ranges)**\n\nThese registers each contain Base, Limit, Write Protection Enable, and Read\nProtection Enable, which can be used to enforce additional access controls at a\nmore granular level than that provided by the BIOS Control register and the SPI\nFlash Descriptor.\n\nIf the TrickBot module is running on a PCH that was not included in the set of lookup tables\nin pch_did_to_generation, this function uses a pre-Skylake set of default values for the\nhardware-access operations that follow.\n\nNow that the malware knows where to find these SPI controller registers, there are some\nadditional helper functions which can be used to check the state of the BIOS Region\nprotections and perform SPI operations to the external flash chip:\n\n**0x1000948D read_bios_control_reg**\n\nThis uses pci_read_reg to read and return the current value of the BIOS Control\nregister\n\n**Click here to see the code.**\n\n**0x10009386 is_bios_locked**\n\nThis uses read_bios_control_reg to read the BIOS Control register and check if the\nLock Enabled (LE) bit is set.\n\n**Click here to see the code.**\n\n**0x1000947E is_smm_bios_protection_enabled**\n\nThis uses read_bios_control_reg to read the BIOS Control register and checks if the\nEnable InSMM.STS (EISS) bit, which was previously known as SMM BIOS Write\nProtection (SMM_BWP), is set. When this bit is set, the BIOS region is not writable\nregardless of the state of the WPD (Write Protect Disable) bit, which is also in the BIOS\nControl register unless the process is running in System Management Mode and sets\nthe InSMM.STS bit (0xFED30880[0]).\nOne detail to keep in mind here is that even if the SMM Bios Write Protection bit is\nenabled, it doesn’t necessarily mean that it’s not possible to write to the BIOS Region.\nThere have been many issues with buggy SMI handlers that leave the system\nvulnerable during the firmware update process or enable arbitrary memory read/write\nas a “confused deputy”.\n\n**Click here to see the code.**\n\n**0x1000BA66 determine_spibar**\n\n\n-----\n\n**•This function uses pci_read_reg to read SPIBAR, which is the SPI Base Address**\nRegister, and points to the current physical address which is used for MMIO access to\nadditional SPI controller registers.\n\n**Click here to see the code.**\n\n**0x10009394 read_pr_reg**\n\nThis function uses uefi_expl_phys_mem_read_qword to read the current contents of\nthe requested Flash Protected Range register. This is used to determine if additional\nprotections have been enabled beyond that provided by the SPI Flash Descriptor and\nthe BIOS Control register.\n\n**Click here to see the code.**\n\n**0x1000B942 try_disable_bios_write_protection**\n\nThis function checks if the BIOS Write Protection Disable (WPD) bit is set, tries to set it\nif it was previously unset, and reports the status to the caller.\nInterestingly, there’s a bug here. This function tries to check if the EISS/SMM_BWP bit\nis set but incorrectly reads the BIOS Control register offset (0xDC) from SPIBAR\ninstead of from the LPC Interface (0:1F.0). This results in this code always thinking that\nthe EISS/SMM_BWP bit is unset. It also incorrectly attempts to set the WPD bit by\nwriting to the BIOS Control register offset via SPIBAR in addition to PCI Config Space.\n\nIn Atom SoC platforms (Avoton, Cherrytrail, Baytrail, etc.), the BIOS Control\nregister is in SPIBAR, but at a different offset (0xFC).\n\n**Click here to see the code.**\n\n**0x1000BA42 enable_bios_write_protection**\n\nThis function attempts to set the BWP bit in the BIOS Control register but incorrectly\nwrites to that offset via SPIBAR and not to the BC register in PCI Configuration Space.\n\n**Click here to see the code.**\n\n**0x10009281 check_spi_protections**\n\nThis function calls multiple helper functions such as read_bios_control_reg,\nis_bios_locked, is_smm_bios_protection_enabled, and\ntry_disable_bios_write_protection to try to enable writes to the SPI region and returns\nthe result.\nIt also uses read_pr_reg and read_from_bios_region to determine if the BIOS Region\nis not-readable, which is a less common occurrence.\n\n**Click here to see the code.**\n\n\n-----\n\n**0x1000BFA0 wait_while_spi_cycle_in_progress**\n\nThis function uses uefi_expl_phys_mem_dword to read the Hardware Sequencing\nFlash Status and Control (BIOS_HSFSTS_CTL) register to check the status of the SPI\nCycle In Progress (H_SCIP) bit. This bit is set when the SPI hardware is currently\nprocessing a request.\n\n**0x1000BEF8 get_region_base_and_size**\n\nThis function uses uefi_expl_phys_mem_read_dword to determine the Flash Linear\nAddress (FLA) and size for the requested region by reading the FDOD (Flash\nDescriptor Observability Data) and Flash Region 0-6 (BIOS_FREGn) registers. This\nregion configuration is stored in the SPI Flash Descriptor, which is the first 4096 bytes\nof the SPI chip contents.\n\n**0x1000BACD do_spi_operations**\n\nThis is a large function that takes requests from other parts of the code and performs\nreads and writes to SPI controller registers using the uefi_expl_* primitives and other\nhelper functions in order to perform the requested operation.\n\nThe prototype for this function looks like this:\n\n**Click here to see the code.**\n\nThe code supports the following types of SPI Flash Cycle requests:\n\nRead\nWrite\nErase\nRead SFDP\n\nRead JEDEC ID\nWrite Status\nRead Status\n\n**0x1000BEDD read_from_spi_region**\n\nThis is a helper function to make calls do_spi_operation with a hardcoded cycle_type of\nRead.\n\n**Click here to see the code.**\n\nOf particular note, this module could be trivially changed to brick systems by changing\nthe line above to:\n\n**Click here to see the code**\n\n\n-----\n\nThis would result in the code erasing the BIOS region on any vulnerable systems.\nBricking a device at this level can require replacement of hardware in order to restore a\nsystem back to operation and is a much more invasive fix than replacing modular\ncomponents like HDDs or memory, given it may require replacing the entire\nmotherboard.\n\n### Test framework and status reporting\n\nBecause TrickBot uses a modular framework to allow new modules to be developed and\ndeployed to targets, this sample includes some infrastructure code to implement this\nframework, which is shared with previous samples.\n\nThe main function where the module-specific operations start is at 0x1000D663, which we’ll\nrefer to as “permadll32_main_module”. This is the main function for this module, which loads\nand initializes the RwDrv.sys driver by calling open_or_init_driver, determines the identity of\nthe platform (both CPU and PCH) by calling identify_platform, determines which register\nlocations to use for this platform by calling get_regs_from_generation, checks if the SPI\nBIOS Region is writable by calling check_spi_protections, and returns the platform identity\nand if the SPI BIOS Region is writable back to the caller.\n\nAlthough this module appears only to identify the target hardware and determine if the BIOS\nregion is writable, its code could be easily modified to write to the SPI Flash to implant the\nsystem by modifying the firmware or brick the system by erasing the BIOS Region entirely.\nThis could be automated via the use of an additional module to perform the attack after the\nreconnaissance has been completed by this module or via ‘at-the-keyboard’ manual\noperations.\n\n## Mitigation\n\nGiven the popularity of TrickBot in the wild, it is important for security teams to ensure that\ntheir devices are not vulnerable and have not been compromised. Firmware integrity checks\nare particularly important for any device that is known to have been compromised by\nTrickBot. The following steps can be performed with open-source tools such as CHIPSEC or\nvia the Eclypsium platform.\n\nCheck devices to ensure that BIOS write protections are enabled. See how in our\n[Protecting System Firmware Storage blog. Eclypsium customers can specifically look](https://eclypsium.com/2019/10/23/protecting-system-firmware-storage/)\nfor systems with the “Missing BIOS Write Protection” vulnerability.\n\n[Verify firmware integrity by checking firmware hashes against known good versions of](https://eclypsium.com/2020/10/14/protecting-your-organizations-from-mosaicregressor-and-other-uefi-implants/)\nfirmware. Monitor firmware behavior for any signs of unknown implants or\nmodifications.\n\n\n-----\n\nUpdate firmware to mitigate numerous vulnerabilities that have been discovered. See\n[our blog on Firmware Updates for the Enterprise for best practices.](https://eclypsium.com/2020/05/14/tools-and-techniques-for-updating-enterprise-firmware/)\n\nIncident Response (IR) teams performing host-level forensics on devices impacted by\n[TrickBot should examine firmware as part of their playbook in order to ensure](https://eclypsium.com/2019/04/02/firmware-needs-to-be-part-of-your-incident-response-playbook/)\neradication and to gain hotwash insight into risks presented by adversaries targeting\ndevice firmware in their specific environment.\n\n## Conclusion\n\nGiven the size and scope of TrickBot, the discovery of a module specifically targeting\nfirmware is troubling. These threat actors are collecting targets that are verified to be\nvulnerable to firmware modification, and one line of code could change this reconnaissance\nmodule into an attack function. Like other in-the-wild firmware attacks, TrickBot reused\npublicly available code to quickly and easily enable these new firmware-level capabilities. At\na time when geopolitical events and a global pandemic have upended life across the globe,\nTrickBot is digging into the hidden area of firmware that is often overlooked. This presents a\ngreater risk than ever before because the scale of TrickBot, which has previously brought\nhighly disruptive ransomware, now brings firmware attacks to many more organizations who\nare likely unprepared for such techniques.\n\n## TrickBoot IOCs\n```\npermaDll32 Hashes:\nmd5: 491115422a6b94dc952982e6914adc39\nsha1: 55803cb9fd62f69293f6de21f18fd82f3e3d1d68\nsha256: c1f1bc58456cff7413d7234e348d47a8acfdc9d019ae7a4aba1afc1b3ed55ffa\npermaDll32 (pre-decryption) Hashes:\nmd5: cef670f443d2335f44a1838463ea44ed\nsha1: 30aa28e6df66fe7b4ec643635df8187ede31db06\nsha256: c065e39ce4e90a5a966f76d9798cb5b962d51a3f35e3890f91047acfefa8c58e\n\n```\n**Note: The TrickBoot module includes an obfuscated copy of RwDrv.sys embedded inside it,**\nbut when this file is dropped into the Windows directory, it can be identified with the following\nIOCs.\n```\nRwdrv.sys Hashes:\nmd5: 257483d5d8b268d0d679956c7acdf02d\nsha1: fbf8b0613a2f7039aeb9fa09bd3b40c8ff49ded2\nsha256: ea0b9eecf4ad5ec8c14aec13de7d661e7615018b1a3c65464bf5eca9bbf6ded3\n\n```\n**Yara Signature:**\n\n\n-----\n\n```\nrule crime_win32_perma_uefi_dll : Module\n{\nmeta:\n author = \"@VK_Intel | Advanced Intelligence\"\n description = \"Detects TrickBot Banking module permaDll\"\n md5 = \"491115422a6b94dc952982e6914adc39\"\nstrings:\n     $module_cfg = \"moduleconfig\"\n     $str_imp_01 = \"Start\"\n     $str_imp_02 = \"Control\"\n     $str_imp_03 = \"FreeBuffer\"\n     $str_imp_04 = \"Release\"\n     $module = \"user_platform_check.dll\"\n     $intro_routine = { 83 ec 40 8b ?? ?? ?? 53 8b ?? ?? ?? 55 33 ed a3 ?? ?? ??\n?? 8b ?? ?? ?? 56 57 89 ?? ?? ?? a3 ?? ?? ?? ?? 39 ?? ?? ?? ?? ?? 75 ?? 8d ?? ?? ??\n89 ?? ?? ?? 50 6a 40 8d ?? ?? ?? ?? ?? 55 e8 ?? ?? ?? ?? 85 c0 78 ?? 8b ?? ?? ?? 85\nff 74 ?? 47 57 e8 ?? ?? ?? ?? 8b f0 59 85 f6 74 ?? 57 6a 00 56 e8 ?? ?? ?? ?? 83 c4\n0c eb ??}\ncondition:\n6 of them\n}\n\n```\n**[Click here to download the indicators of compromise for automation.](https://eclypsium.com/wp-content/uploads/2020/12/trickboot_ioc_files.zip)**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-03 - TrickBot Now Offers ‘TrickBoot’- Persist, Brick, Profit.pdf"
    ],
    "report_names": [
        "2020-12-03 - TrickBot Now Offers ‘TrickBoot’- Persist, Brick, Profit.pdf"
    ],
    "threat_actors": [
        {
            "id": "a3687241-9876-477b-aa13-a7c368ffda58",
            "created_at": "2022-10-25T16:07:24.496902Z",
            "updated_at": "2025-03-27T02:02:10.256629Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "ETDA:Hacking Team",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "72aaa00d-4dcb-4f50-934c-326c84ca46e3",
            "created_at": "2023-01-06T13:46:38.995743Z",
            "updated_at": "2025-03-27T02:00:02.972623Z",
            "deleted_at": null,
            "main_name": "Slingshot",
            "aliases": [],
            "source_name": "MISPGALAXY:Slingshot",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "e90c06e4-e3e0-4f46-a3b5-17b84b31da62",
            "created_at": "2023-01-06T13:46:39.018236Z",
            "updated_at": "2025-03-27T02:00:02.978356Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "MISPGALAXY:Hacking Team",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f55c7778-a41c-4fc6-a2e7-fa970c5295f2",
            "created_at": "2022-10-25T16:07:24.198891Z",
            "updated_at": "2025-03-27T02:02:10.138587Z",
            "deleted_at": null,
            "main_name": "Slingshot",
            "aliases": [],
            "source_name": "ETDA:Slingshot",
            "tools": [
                "Cahnadr",
                "GollumApp",
                "NDriver"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "e3767160-695d-4360-8b2e-d5274db3f7cd",
            "created_at": "2022-10-25T16:47:55.914348Z",
            "updated_at": "2025-03-27T02:05:17.411172Z",
            "deleted_at": null,
            "main_name": "IRON TWILIGHT",
            "aliases": [
                "ATK5 ",
                "Blue Athena ",
                "BlueDelta ",
                "FROZENLAKE ",
                "Fancy Bear ",
                "Fighting Ursa ",
                "Forest Blizzard ",
                "GRAPHITE ",
                "Group 74 ",
                "PawnStorm ",
                "STRONTIUM ",
                "Sednit ",
                "Snakemackerel ",
                "Sofacy ",
                "TG-4127 ",
                "Tsar Team ",
                "APT28 "
            ],
            "source_name": "Secureworks:IRON TWILIGHT",
            "tools": [
                " Downdelph",
                " Drovorub",
                " EVILTOSS",
                " HIDEDRV",
                " Headlace",
                " LoJack",
                " Powershell Empire",
                " SCONATO",
                " SEDUPLOADER",
                " SHARPFRONT",
                " Scaramouche",
                " Sedkit Exploit Kit",
                " Sofacy downloader",
                " X-Agent",
                " X-Tunnel",
                " Zebrocy",
                " reGeorg",
                "DEALERSCHOICE"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "730dfa6e-572d-473c-9267-ea1597d1a42b",
            "created_at": "2023-01-06T13:46:38.389985Z",
            "updated_at": "2025-03-27T02:00:02.821388Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "FROZENLAKE",
                "BlueDelta",
                "SNAKEMACKEREL",
                "TG-4127",
                "ITG05",
                "TA422",
                "Fancy Bear",
                "FANCY BEAR",
                "Sednit",
                "IRON TWILIGHT",
                "G0007",
                "Sofacy",
                "Forest Blizzard",
                "GruesomeLarch",
                "Pawn Storm",
                "Tsar Team",
                "STRONTIUM",
                "ATK5",
                "Blue Athena",
                "APT-C-20",
                "Group 74",
                "SIG40",
                "Grizzly Steppe",
                "Fighting Ursa",
                "T-APT-12",
                "UAC-0028"
            ],
            "source_name": "MISPGALAXY:APT28",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "ae320ed7-9a63-42ed-944b-44ada7313495",
            "created_at": "2022-10-25T15:50:23.671663Z",
            "updated_at": "2025-03-27T02:00:55.518748Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "APT28",
                "IRON TWILIGHT",
                "SNAKEMACKEREL",
                "Group 74",
                "Sednit",
                "Sofacy",
                "Pawn Storm",
                "Fancy Bear",
                "STRONTIUM",
                "Tsar Team",
                "Threat Group-4127",
                "TG-4127",
                "Forest Blizzard",
                "FROZENLAKE"
            ],
            "source_name": "MITRE:APT28",
            "tools": [
                "Wevtutil",
                "certutil",
                "Forfiles",
                "DealersChoice",
                "Mimikatz",
                "ADVSTORESHELL",
                "Komplex",
                "HIDEDRV",
                "JHUHUGIT",
                "Koadic",
                "Winexe",
                "XTunnel",
                "Drovorub",
                "CORESHELL",
                "OLDBAIT",
                "Downdelph",
                "XAgentOSX",
                "USBStealer",
                "Zebrocy",
                "Fysbis",
                "LoJax"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535748,
    "ts_updated_at": 1743041724,
    "ts_creation_date": 1653697516,
    "ts_modification_date": 1653697516,
    "files": {
        "pdf": "https://archive.orkl.eu/6648a70b732ec3ecafc737a6864141b49686a344.pdf",
        "text": "https://archive.orkl.eu/6648a70b732ec3ecafc737a6864141b49686a344.txt",
        "img": "https://archive.orkl.eu/6648a70b732ec3ecafc737a6864141b49686a344.jpg"
    }
}