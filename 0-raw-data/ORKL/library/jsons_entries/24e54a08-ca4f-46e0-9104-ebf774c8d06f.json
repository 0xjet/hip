{
    "id": "24e54a08-ca4f-46e0-9104-ebf774c8d06f",
    "created_at": "2022-10-25T16:48:17.212516Z",
    "updated_at": "2025-03-27T02:05:56.514501Z",
    "deleted_at": null,
    "sha1_hash": "841e63f842029a2a45047edee7312cae9a3e1353",
    "title": "",
    "authors": "",
    "file_creation_date": "2017-03-01T10:09:12Z",
    "file_modification_date": "2017-03-01T10:09:12Z",
    "file_size": 1199972,
    "plain_text": "[(https://breakingmalware.com/)](https://breakingmalware.com/)\n[(https://breakingmalware.com/)](https://breakingmalware.com/)\n\n(https://breakingmalware.com/)\n\n[(https://breakingmalware.com/)Sponsored by enSilo (http://www.ensilo.com/)](https://breakingmalware.com/)\n\n[Tal Liberman (https://breakingmalware.com/author/tal-liberman/)](https://breakingmalware.com/author/tal-liberman/)\n\n[October 27, 2016 (https://breakingmalware.com/injection-techniques/atombombing-brand-new-code-injection-for-windows/)](https://breakingmalware.com/injection-techniques/atombombing-brand-new-code-injection-for-windows/)\n[49 Comments (https://breakingmalware.com/injection-techniques/atombombing-brand-new-code-injection-for-windows/#comments)](https://breakingmalware.com/injection-techniques/atombombing-brand-new-code-injection-for-windows/#comments)\n\n# AtomBombing: Brand New Code Injection for Windows\n (https://breakingmalware.com/injection- techniques/atombombing-brand-new-code-injection-for- windows/)\n\n**TL;DR Here’s a new code injection technique, dubbed AtomBombing, which exploits Windows atom tables and Async Procedure Calls (APC). Currently, this technique**\n\ngoes undetected by common security solutions that focus on preventing infiltration.\n\nCode injection has been a strong weapon in the hacker’s arsenal for many years. For background on code injection and its various uses in APT type attack scenarios\n\nplease take a look at:\n\nhttp://blog.ensilo.com/atombombing-a-code-injection-that-bypasses-current-security-solutions (http://blog.ensilo.com/atombombing-a-code-injection-that-bypasses-current\nsecurity-solutions)\n\n## Overview\n\nI started poking around to see how hard it would be for a threat actor to find a new method that security vendors are unaware of and bypasses most security products. It\n\nalso needed to work on different processes rather than being tailored to fit a specific process.\n\nI would like to introduce you to AtomBombing – a brand new code injection technique for Windows.\n\nAtomBombing works in three main stages:\n\n1. Write-What-Where – Writing arbitrary data to arbitrary locations in the target process’s address space.\n\n2. Execution – Hijacking a thread of the target process to execute the code written in stage 1.\n\n\n-----\n\n3. Restoration – Cleaning up and restoring the execution of the thread hijacked in stage 2.\n\n## AtomBombing Stage 1: Write-What-Where\n\nI stumbled onto a couple of rather interesting API calls:\n\n**[GlobalAddAtom (https://msdn.microsoft.com/en-us/library/windows/desktop/ms649060(v=vs.85).aspx) – Adds a character string to the global atom table and](https://msdn.microsoft.com/en-us/library/windows/desktop/ms649060(v=vs.85).aspx)**\n\nreturns a unique value (an atom) identifying the string.\n**[GlobalGetAtomName (https://msdn.microsoft.com/en-us/library/windows/desktop/ms649063(v=vs.85).aspx) – Retrieves a copy of the character string associated](https://msdn.microsoft.com/en-us/library/windows/desktop/ms649063(v=vs.85).aspx)**\n\nwith the specified global atom.\n\nBy calling GlobalAddAtom one can store a null terminated buffer in the global atom table. This table is accessible from every other process on the system. The buffer can\nthen be retrieved by calling GlobalGetAtomName. GlobalGetAtomName expects a pointer to an output buffer, so the caller chooses where the null terminated buffer will be\n\nstored.\n\nIn theory, if I could add a buffer containing shellcode to the global atom table by calling GlobalAddAtom, and then somehow get the target process to call\n\nGlobalGetAtomName I could copy code from my process to the target process, without calling WriteProcessMemory.\n\nCalling GlobalAddAtom from my process is pretty straightforward, but how would I get the target process to call GlobalGetAtomName?\n\nBy using Async Procedure Calls (APC):\n\n_QueueUserApc – adds a user-mode asynchronous procedure call (APC) object to the APC queue of the specified thread._\n\n\nDWORD WINAPI QueueUserAPC(\n\n_In_ PAPCFUNC pfnAPC,\n\n_In_ HANDLE  hThread,\n_In_ ULONG_PTR dwData\n\n);\n\n\nQueueUserApc receives a pointer to an APCProc which is defined as follows:\n\n\nVOID CALLBACK APCProc(\n\n_In_ ULONG_PTR dwParam\n\n);\n\n\nGlobalGetAtomName’s prototype is:\n\n\nUINT WINAPI GlobalGetAtomName(\n\n_In_ ATOM  nAtom,\n\n_Out_ LPTSTR lpBuffer,\n\n_In_ int  nSize\n\n);\n\n\nSince GlobalGetAtomName expects 3 parameters (while APCProc is defined to expect only 1 parameter) we can’t use QueueUserApc to get the target process to call\n\nGlobalGetAtomName.\n\nLet’s take a look at the internals of QueueUserApc:\n\n(./AtomBombing_ Brand New Code Injection for Windows - Breaking\n\nMalware_files/Figure-0-QueueUserApc-Internals.png)\n\nFigure 1: QueueUserApc\n\nAs you can see QueueUserApc uses the undocumented NtQueueApcThread syscall in order to add the APC to the target thread’s APC queue.\n\n\n-----\n\nInterestingly enough NtQueueApcThread receives a pointer to a function that is to be called asynchronously in the target thread, but the function being passed is not the\n\noriginal APCProc function the caller passed to QueueUserApc. Instead the function being passed is ntdll!RtlDispatchAPC, and the original APCProc function passed to\n\nQueueUserApc is passed as a parameter to ntdll!RtlDispatchAPC.\n\nLet’s take a look at ntdll!RtlDispatchAPC:\n\n(./AtomBombing_ Brand New Code Injection for Windows - Breaking Malware_files/Figure-1\nRtlDispatchApc.png)\n\nFigure 2: ntdll!RtlDispatchAPC\n\nIt starts by checking if the 3 parameter is valid, which means an ActivationContext needs to be activated before dispatching the APC.rd\n\nIf an ActivationContext needs to be activated:\n\n(./AtomBombing_ Brand New Code Injection for Windows - Breaking\n\nMalware_files/Figure-2-RtlDispatchApc-2.png)\n\nFigure 3: ntdll!RtlDispatchAPC – RtlActivateActivationContextUnsafeFast\n\nThe function ntdll!RtlDispatchAPC executes the following:\n\n1. The passed ActivationContext (currently in ESI) will be activated by calling RtlActivateActivationContextUnsafeFast.\n\n2. The parameter to the original APCProc function (i.e. the third parameter passed to QueueUserApc) is pushed onto the stack. This is because we are about to call the\n\noriginal APCProc function.\n\n3. Right before dispatching the APC, a call to CFG (__guard_check_icall_fptr) is made to make sure the APC target is a CFG valid function.\n\n4. A call to the original APCProc is made, and that’s it – the APC has been dispatched.\n\nOnce APCProc returns, the activation context is deactivated:\n\n\n-----\n\n(./AtomBombing_ Brand New Code Injection for Windows - Breaking\n\nMalware_files/Figure-3-RtlDispatchApc-3.png)\n\nFigure 4: ntdll!RtlDispatchAPC –\n\nRtlDeactivateActivationContextUnsafeFast\n\nIf, on the other hand, no activation context needs to be activated:\n\n(./AtomBombing_ Brand New Code Injection for\n\nWindows - Breaking Malware_files/Figure-4\nRtlDispatchApc-4.png)\n\nFigure 5: ntdll!RtlDispatchAPC – no activation\n\ncontext\n\nThe code skips all the activation context related stuff and simply dispatches the APC right away after calling CFG.\n\nWhat does all this mean? When calling QueueUserApc we are forced to pass an APCProc which expects one parameter. However, under the hood QueueUserApc uses\n\nNtQueueApcThread to call ntdll!RtlDispatchAPC which expects 3 parameters.\n\nWhat was our goal? To call GlobalGetAtomName. How many parameters does it expect? 3. Can we do this? Yes. How? NtQueueApcThread!\n\nSee _main_ApcWriteProcessMemory (https://github.com/BreakingMalwareResearch/atom-_\n\nbombing/blob/f5a04e3fd6eda114e1a7e66429d7e9ec864ec7d4/AtomBombing/main.cpp#L822) in AtomBombing’s GitHub repository\n\n(https://github.com/BreakingMalwareResearch/atom-bombing).\n\n## AtomBombing Stage 2: Execution\n\nObviously I could never hope to consistently find RWX code caves in my target processes. I needed a way to consistently allocate RWX memory in the target process\n\nwithout calling VirtualAllocEx within the context of the injecting process. Sadly, I could not find any such function that I could invoke via APC and would allow me to allocate\n\nexecutable memory or change the protection flags of already allocated memory.\n\nWhat do we have so far? Write-what-where + a burning desire to get some executable memory. I thought long and hard how to get over this hurdle, and then it hit me.\n\nWhen DEP was invented, its creators thought, “that’s it, data is no longer executable, therefore no one will ever be able to exploit vulnerabilities again”. Unfortunately, that\n\nwas not the case; a new exploitation technique was invented solely to bypass DEP: ROP – Return Oriented Programming.\n\nHow can we use ROP to our advantage in order to execute our shellcode in the target process?\n\nWe can copy our code to an RW code cave in the target process (using the method described in stage 1). Then use a meticulously crafted ROP chain to allocate RWX\n\nmemory, copy the code from the RW code cave to the newly allocated RWX memory, and finally jump to the RWX memory and execute it.\n\nFinding an RW code cave is not a big problem. For this proof of concept, I decided to use the unused space after the data section of kernelbase.\n\nSee main_GetCodeCaveAddress (https://github.com/BreakingMalwareResearch/atom\n_bombing/blob/f5a04e3fd6eda114e1a7e66429d7e9ec864ec7d4/AtomBombing/main.cpp#L1098) in AtomBombing’s GitHub repository_\n\n(https://github.com/BreakingMalwareResearch/atom-bombing).\n\n### The ROP Chain:\n\nOur ROP chain needs to do 3 things:\n\n1. Allocate RWX memory\n\n2. Copy the shellcode from the RW code cave to the newly allocated RWX memory\n\n3. Execute the newly allocated RWX memory\n\n\n-----\n\n#### ROP Chain Step 1: Allocating RWX Memory\n\nWe would like to allocate some RWX memory. The first function that comes to mind is VirtualAlloc – a very useful function that can be used to allocate RWX memory.\n\nThe only problem is that the function returns the newly allocated RWX memory in EAX which would make our ROP chain complicated by having to find a way to pass\nthe value VirtualAlloc stored in EAX to the next function in the chain.\n\nA very neat trick can be employed in order to simplify our ROP chain and make it more sophisticated. Instead of using VirtualAlloc, we can use\n\nZwAllocateVirtualMemory, which returns the newly allocated RWX memory as an output parameter. This way we can actually set up our stack so that\n\nZwAllocateVirtualMemory stores the newly allocated memory further along the stack, effectively passing the address to the next function in the chain (see Table 1).\n\n#### ROP Chain Step 2: Copying the Shellcode\n\nThe next function we need is a function that will copy memory from one buffer to another. Two options come to mind: memcpy and RtlMoveMemory. When creating\n\nthis kind of ROP chain one might be initially inclined to go with RtlMoveMemory because it uses the stdcall calling convention, meaning it will clean up the stack after\n\nitself. This is a special case though. We need to copy memory to an address (placed on the stack by ZwAllocateVirtualMemory) and then somehow this address needs\n\nto be called. If we used RtlMoveMemory, it will pop the address of the RWX shellcode right off the stack upon its return. On the other hand, if we use memcpy, the first\n\nentry on the stack would be the return address of memcpy, followed by the destination parameter of memcpy (i.e. the RWX shellcode).\n\n#### ROP Chain Step 3: Executing the newly allocated RWX memory\n\nWe have allocated RWX memory and copied our shellcode to it. We are about to return from memcpy but the address of the RWX shellcode on the stack is 4 bytes\naway from the return address. Therefore, all we have to do is add an extremely simple gadget to our ROP chain. This simple gadget will execute the opcode “ret”.\n\nmemcpy will return to this simple gadget which will “ret” right into our RWX shellcode.\n\nSee _main_FindRetGadget (https://github.com/BreakingMalwareResearch/atom-_\n\n_bombing/blob/f5a04e3fd6eda114e1a7e66429d7e9ec864ec7d4/AtomBombing/main.cpp#L1131)_ in AtomBombing’s GitHub repository\n\n(https://github.com/BreakingMalwareResearch/atom-bombing).\n\nFor those who have to see it to believe it:\n\nSet EIP to point to ZwAllocateVirtualMemory, and ESP to point to this ROP chain:\n\n|Address|Value|Comment|\n|---|---|---|\n|0x30000000|ntdll!memcpy|// Return address from ZwAllocateVirtualMemory|\n|0x30000004|0xffffffff|// Pseudo handle to the current process|\n|0x30000008|0x30000020|// Where to store the allocated memory|\n|0x3000000C|NULL|// Irrelevant|\n|0x30000010|0x30000028|// Pointer to the size of the needed memory|\n|0x30000014|MEM_COMMIT|// Commit and not reserve|\n|0x30000018|PAGE_EXECUTE_READWRITE|// RWX|\n|0x3000001C|POINTER_TO_SOME_RET_INSTRUCTION|// Return Address from memcpy, our extremely simple ret gadget.|\n|0x30000020|NULL|// Where the allocated memory will be saved and the destination parameter of memcpy. This will store the address of the RWX shellcode.|\n\n\n-----\n\n|0x30000024|CODE_CAVE_ADDRESS|// The RW code cave containing the shellcode to be copied|\n|---|---|---|\n|0x30000028|SHELLCODE_SIZE|// The size of the shellcode to be allocated|\n\n\n**Table 1: The whole ROP chain.**\n\nSee _main_BuildROPChain (https://github.com/BreakingMalwareResearch/atom-_\n\n_bombing/blob/f5a04e3fd6eda114e1a7e66429d7e9ec864ec7d4/AtomBombing/main.cpp#L1192)_ in AtomBombing’s GitHub repository\n\n(https://github.com/BreakingMalwareResearch/atom-bombing).\n\n### Invoking the ROP Chain\n\nBut wait, APCs allow me to send 3 parameters. Obviously I need to store 11 parameters on the stack. Our best bet is to pivot the stack to some RW memory which will\n\ncontain our ROP chain (e.g. the RW code cave in kernelbase).\n\nHow could we pivot the stack?\n\n\nNTSYSAPI NTSTATUS NTAPI NtSetContextThread(\n\n_In_    HANDLE hThread,\n\n_In_ const CONTEXT *lpContext\n\n);\n\n\nThis syscall will set the context (register values) of hThread to the values contained in lpContext. If we can get the target process to call this syscall with an lpContext that\n\nwill set ESP to point to our ROP chain and set EIP to point to ZwAllocateVirtualMemory, then our ROP chain will execute. The execution of the ROP chain will eventually\n\nlead to the execution of our shellcode.\n\nHow do we get the target process to make this call? APC has been good to us so far, but this syscall expects 2 parameters and not 3, so when it returns the stack will be\n\ncorrupt, and the behavior will be undefined. That said, if we pass a handle to the current thread as hThread, then the function will never return. The reason is that once\n\nexecution gets passed on to the kernel, the context of the thread will be set to the context specified by lpContext, and there will be no trace that NtSetContextThread was\n\never called. If everything works out as we hope, we will have successfully hijacked a thread and got it to execute our malicious shellcode.\n\nSee _main_ApcSetThreadContext (https://github.com/BreakingMalwareResearch/atom-_\n_bombing/blob/f5a04e3fd6eda114e1a7e66429d7e9ec864ec7d4/AtomBombing/main.cpp#L877)_ in AtomBombing’s GitHub repository\n\n(https://github.com/BreakingMalwareResearch/atom-bombing).\n\n## AtomBombing Stage 3: Restoration\n\nWe do have one problem, though. The thread that we hijacked had a purpose before we had hijacked it. If we don’t restore its execution, there is no telling what kind of\n\neffect we could have on the target process.\n\nHow do we restore execution? I’d like to remind you that we are now in the context of an APC. When the APC function completes, somehow execution is restored safely.\n\nLet’s look at the dispatching of APCs from the target process’s point of view.\n\nIt looks like the function in charge of dispatching APCs (WaitForSingleObjectEx in this example) is ntdll!KiUserApcDispatcher.\n\n\n-----\n\n(./AtomBombing_ Brand New Code Injection for Windows - Breaking\nMalware_files/Figure-5-KiUserApcDispatcher.png)\n\nFigure 6: KiUserApcDispatcher\n\nWe can see 3 “calls” in this block of code. The first call is to CFG, the next call is to ECX (which is the address of the APC function), and finally a call to the undocumented\n\nZwContinue.\n\nZwContinue expects to receive a pointer to a CONTEXT structure and resumes the execution. Actually the kernel will check if there are any more APCs in the thread’s APC\nqueue, and dispatch them before finally resuming the thread’s original execution, but we can ignore that.\n\nThe CONTEXT structure being passed to ZwContinue is stored in EDI before calling the APC function (stored in ECX). We can save EDI’s value at the beginning of our\nshellcode, and call ZwContinue with EDI’s original value at the end of the shellcode, thereby restoring execution safely.\n\nSee _AtomBombingShellcode (https://github.com/BreakingMalwareResearch/atom-_\n_bombing/blob/f5a04e3fd6eda114e1a7e66429d7e9ec864ec7d4/AtomBombingShellcode/main.c#L31)_ in AtomBombing’s GitHub repository\n\n(https://github.com/BreakingMalwareResearch/atom-bombing).\n\nWe have to make sure that the value of EDI will not be overridden during the call to NtSetContextThread, since it modifies the values of the registers. This can easily be\n\naccomplished by setting ContextFlags (member of the CONTEXT structure passed to NtSetContextThread) to CONTEXT_CONTROL which means that only EBP, EIP,\nSEGCS, EFLAGS, ESP, and SEGSS will be affected. As long as (CONTEXT.ContextFlags|CONTEXT_INTEGER == 0) we should be ok.\n\n(./AtomBombing_ Brand New Code Injection for Windows - Breaking Malware_files/Figure-6-Chrome.png)\n\nFigure 7: AtomBombing chrome.exe\n\nAnd there you have it, we have injected code into chrome.exe. Our injected code spawned the classic calc.exe proving that it works.\n\nLet’s try to inject code into vlc.exe:\n\n\n-----\n\n(./AtomBombing_ Brand New Code Injection for Windows - Breaking Malware_files/Figure-7-VLC.png)\nFigure 8: AtomBombing vlc.exe\n\n[The complete implementation can be found on GitHub (https://github.com/BreakingMalwareResearch/atom-bombing). It has been tested against Windows 10 x64 Build](https://github.com/BreakingMalwareResearch/atom-bombing)\n1511 (WOW) and Windows 10 x86 Build 10240. Compile for “release”.\n\nLet’s do the same with mspaint.exe:\n\n\n-----\n\n(./AtomBombing_ Brand New Code Injection for Windows - Breaking Malware_files/Figure-8-MSPaint.png)\n\nFigure 9: AtomBombing mspaint.exe\n\nOh no, it crashed.\n\n## Final Steps\n\nHow do we proceed from here? I have worked it out and at this point, I’d rather leave this as an exercise to the reader. As an initial hint, I suggest you take a look at my\n\nprevious blog post (https://breakingmalware.com/documentation/documenting-undocumented-adding-control-flow-guard-exceptions/\n(https://breakingmalware.com/documentation/documenting-undocumented-adding-control-flow-guard-exceptions/)). I’m sure you’ll also find creative ideas, that I myself\n\nhaven’t found, to handle this problem and I’d be happy to start this discussion.\n\n[You can use the comments below or catch me @tal_liberman (https://twitter.com/Tal_Liberman). Through Twitter, I’ll also release some tidbits throughout the week. At any](https://twitter.com/Tal_Liberman)\n\nrate, I will publish my solution next week.\n\n## APPENDIX: Finding Alertable Threads\n\nOne thing we have not yet mentioned is that QueueUserApc only works on threads that are in an alertable state. How does a thread enter an alertable state?\n\nAccording to Microsoft:\n\n“””\n\nA thread can only do this by calling one of the following functions with the appropriate flags:\n\nSleepEx\nWaitForSingleObjectEx\n\nWaitForMultipleObjectsEx\nSignalObjectAndWait\nMsgWaitForMultipleObjectsEx\n\nWhen the thread enters an alertable state, the following events occur:\n\n\n-----\n\n1. The kernel checks the thread’s APC queue. If the queue contains callback function pointers, the kernel removes the pointer from the queue and sends it to the\n\nthread.\n\n2. The thread executes the callback function.\n3. Steps 1 and 2 are repeated for each pointer remaining in the queue.\n\n4. When the queue is empty, the thread returns from the function that placed it in an alertable state.\n\n[https://msdn.microsoft.com/en-us/library/windows/desktop/aa363772(v=vs.85).aspx (https://msdn.microsoft.com/en-us/library/windows/desktop/aa363772(v=vs.85).aspx)](https://msdn.microsoft.com/en-us/library/windows/desktop/aa363772(v=vs.85).aspx)\n\n“””\n\nFor our technique to be effective the target process must have at least one thread that is in an alertable state, or will enter an alertable state at some point, otherwise our\n\nAPCs will never actually execute.\n\nI’ve checked various software, and I’ve noticed that most of the programs I’ve checked have at least one alertable thread. Examples: Chrome.exe, Iexplore.exe, Skype.exe,\n\nVLC.exe, MsPaint.exe, WmiPrvSE.exe, etc.\n\nSo now we have to find an alertable thread in the target process. There are many ways of doing this. I chose to use a method that is trivial, works in most cases, and is\n\neasy to implement and explain.\n\nWe’ll create an event for each thread in the target process, then ask each thread to set its corresponding event. We’ll wait on the event handles, until one is triggered. The\nthread whose corresponding event was triggered is an alertable thread.\n\nHow can an event be set? By calling SetEvent(HANDLE hEvent).\n\nHow will we get the threads in the target process to call SetEvent? APC of course. Since SetEvent receives exactly one parameter we can use QueueUserApc to call it.\n\nThe actual details of the implementation can be found in main_FindAlertableThread (https://github.com/BreakingMalwareResearch/atombombing/blob/f5a04e3fd6eda114e1a7e66429d7e9ec864ec7d4/AtomBombing/main.cpp#L1494) in AtomBombing’s GitHub repository\n\n(https://github.com/BreakingMalwareResearch/atom-bombing).\n\n[Injection Techniques (https://breakingmalware.com/category/injection-techniques/)](https://breakingmalware.com/category/injection-techniques/)\n\n[apc (https://breakingmalware.com/tag/apc/), atombombing (https://breakingmalware.com/tag/atombombing/), code injection (https://breakingmalware.com/tag/code-](https://breakingmalware.com/tag/apc/)\n[injection/), research (https://breakingmalware.com/tag/research/), windows (https://breakingmalware.com/tag/windows/)](https://breakingmalware.com/tag/research/)\n\n## Post navigation\n\n← Elastic Boundaries – Elevating privileges by environment variables expansion (https://breakingmalware.com/vulnerabilities/elastic-boundaries-elevating-privileges-byenvironment-variables-expansion/)\n\n[AtomBombing CFG Protected Processes → (https://breakingmalware.com/injection-techniques/atombombing-cfg-protected-processes/)](https://breakingmalware.com/injection-techniques/atombombing-cfg-protected-processes/)\n\n##### We were unable to load Disqus. If you are a moderator please see our troubleshooting guide.\n\n**Search for:** Search … Search\n\n### Tomer Bitton, VP Research, enSilo\n\nObsessed by malware, hostile code and extreme packers. Low-level researcher. Feel free to contact.\n\n[(http://il.linkedin.com/in/p4r4n0id)](http://il.linkedin.com/in/p4r4n0id) [(https://twitter.com/p4r4n0id_il)](https://twitter.com/p4r4n0id_il)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2017/2017.02.28.dridexs-cold-war-enter-atombombing/AtomBombing_%20Brand%20New%20Code%20Injection%20for%20Windows%20-%20Breaking%20Malware.pdf"
    ],
    "report_names": [
        "AtomBombing_ Brand New Code Injection for Windows - Breaking Malware"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716497,
    "ts_updated_at": 1743041156,
    "ts_creation_date": 1488362952,
    "ts_modification_date": 1488362952,
    "files": {
        "pdf": "https://archive.orkl.eu/841e63f842029a2a45047edee7312cae9a3e1353.pdf",
        "text": "https://archive.orkl.eu/841e63f842029a2a45047edee7312cae9a3e1353.txt",
        "img": "https://archive.orkl.eu/841e63f842029a2a45047edee7312cae9a3e1353.jpg"
    }
}