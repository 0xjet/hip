{
    "id": "fa1b67e1-9c90-487c-8f89-d00b5badb7f8",
    "created_at": "2023-01-12T15:04:48.282715Z",
    "updated_at": "2025-03-27T02:06:09.658816Z",
    "deleted_at": null,
    "sha1_hash": "2316a9679a0c1ac1d6afe920fc2bfec3de77d388",
    "title": "2021-07-25 - Ghidra script to decrypt a string array in XOR DDoS",
    "authors": "",
    "file_creation_date": "2022-05-28T03:50:57Z",
    "file_modification_date": "2022-05-28T03:50:57Z",
    "file_size": 128410,
    "plain_text": "# Ghidra script to decrypt a string array in XOR DDoS\n\n**[maxkersten.nl/binary-analysis-course/analysis-scripts/ghidra-script-to-decrypt-a-string-array-in-xor-ddos/](https://maxkersten.nl/binary-analysis-course/analysis-scripts/ghidra-script-to-decrypt-a-string-array-in-xor-ddos/)**\n\n_This article was published on the 25th of July 2021. This article was updated on the 8th of_\n_December 2021._\n\nThe XOR DDoS bot, an ELF file for Linux distributions, is used to perform DDoS attacks.\nThis article focuses on a rather small segment of the malware family: the internally used\nencrypted string array, and its decryption. This article will dive into arrays, the decryption\nloop, the decryption routine, and the creation of a Ghidra script in Java to automate this\nprocess.\n\n## Table of contents\n\n The sample\n\n[The sample can be downloaded from VirusBay,](https://virusbay.io/sample/browse/349456ecaa1380a142f15810a8260378) [Malware Bazaar, or](https://bazaar.abuse.ch/sample/0f00c2e074c6284c556040012ef23357853ccac4ad1373d1dea683562dc24bca/) [MalShare. The hashes](https://malshare.com/sample.php?action=detail&hash=349456ecaa1380a142f15810a8260378)\nare given below.\n```\nMD5: 349456ecaa1380a142f15810a8260378\nSHA-1: 02dd15ecdeedefd7a2f82ba0df38703a74489af3\nSHA-256: 0f00c2e074c6284c556040012ef23357853ccac4ad1373d1dea683562dc24bca\nSize: 625889 bytes\n\n## Used tooling\n\n```\n[The analysis in this article has been done with a self-built version of Ghidra. The used](https://ghidra-sre.org/)\nsources date back to the first of June 2021. The used for-loop that is seen later in this article\nis displayed as a while-loop in earlier Ghidra versions. Other than that, no significant\nchanges are present between versions. All analysis options have been used when analysing\nthe file.\n\n## Arrays in theory\n\nArrays, disregarding of the type, are structured the same way. The first element, which\nresides at index zero, marks the start of the array, followed by the other elements if present.\nTo obtain the element for a given index, the size of each element is multiplied by the index\nnumber, which is then added to the address of the first element. The code below provides an\nexample in pseudo code, where T is the element’s type.\n```\nlong elementAddress = arrayBase + (sizeof(T) * i);\n\n```\n\n-----\n\nWhen dealing with strings, the length can be variable, as not all strings have the same\nlength. In some cases, strings with a fixed length are used, this uses more memory than is\nrequired, but makes it easy to find the element for a given index. Alternatively, the string’s\n[length can be calculated using strlen, which is then used instead of the sizeof function. This](https://www.tutorialspoint.com/c_standard_library/c_function_strlen.htm)\nrequires more CPU cycles, as the string length needs to be calculated, but it uses less\nmemory.\n\n## Understanding the loop\n\nThe given sample contains symbols, which make the analysis easier. The main function is\nalready called main, and contains the decryption loop for the string array at 0804d12a. The\ncomplete loop’s assembly code is given below.\n```\n     MOV    dword ptr [EBP + local_3c],0x0\n     JMP    LAB_0804d12e\n LAB_0804d108\n     MOV    EDX,dword ptr [EBP + local_3c]\n     MOV    EAX,EDX\n     SHL    EAX,0x2\n     ADD    EAX,EDX\n     SHL    EAX,0x2\n     ADD    EAX,daemonname\n     MOV    dword ptr [ESP + local_3dec],0x14\n     MOV    dword ptr [ESP]=>local_3df0,EAX\n     CALL    encrypt_code\n     ADD    dword ptr [EBP + local_3c],0x1\n LAB_0804d12e\n     CMP    dword ptr [EBP + local_3c],0x16\n     JBE    LAB_0804d108\n\n```\nThe loop, like most loops in assembly languages, starts with the initialisation of a variable to\nstore the count in. This variable is commonly named i when named by programmers. In this\ncase, the variable is named local_3c by Ghidra. The naming scheme of Ghidra is based on\nthe location. A jump is then made downwards, where the value of local_3c is compared to\n_0x16, or 22 in decimal. If the value of local_3c is below or equal, the jump upwards is taken._\nThe two labels, LAB_0804d108 and LAB_0804d12e, can be renamed to loop_body and\n_loop_compare respectively to increase the readability. The variable local_3c can be renamed_\nto i for further clarification.\n\nTo understand the loop’s body, each instruction will be explained below, in the usual step-bystep manner. At first, the value of i, which resides at EBP + i is moved into EDX, after which it\nis also moved into EAX.\n```\nMOV    EDX,dword ptr [EBP + i]\nMOV    EAX,EDX\n\n```\nNext, the value in EAX is shifted left by two bits. A left shift of N equals two to the power of N.\nIn this case, it means that EAX is multiplied by four.\n\n\n-----\n\n```\nSHL    EAX,0x2\n\n```\nThe value of i is then added to EAX, after which it is multiplied by four again.\n```\nADD    EAX,EDX\nSHL    EAX,0x2\n\n```\nThe variable named daemonname refers to the string array, although Ghidra does not\nrecognise the type due to the fact that it contains the encrypted strings. The base address of\nthe array is then added to EAX.\n```\nADD    EAX,daemonname\n\n```\nIn short, EAX contains the array’s base address and the offset based on i.\n\nThe next three instructions push two arguments on the stack, after which the decryption\nfunction (named encrypt_code) is called. The first argument, as they are read from the stack\nin the reverse order, is equal to EAX, which contains the current element’s address. The\nsecond argument is equal to 0x14, or 20 in decimal. As such, it becomes apparent that this\nstring array is based on strings with a fixed length, although this does not mean that every\nstring is 20 bytes in size. Rather, the length of each string is between 0 and 19, given that\neach string is terminated with a null byte.\n```\nMOV    dword ptr [ESP + local_3dec],0x14\nMOV    dword ptr [ESP]=>local_3df0,EAX\nCALL    encrypt_code\n\n```\nAt last, the value of i is incremented with one.\n```\nADD    dword ptr [EBP + i],0x1\n\n```\nThe calculation for the offset of the next element can be simplified as follows.\n```\nfor (int i = 0; i <= 0x16; i++)\n{\n     int result = i;\n     result = result * 4;\n     result += i;\n     result = result * 4;\n     System.out.println(result);\n}\n\n```\nFurther simplified, one can rewrite the code above as follows.\n```\nfor (int i = 0; i <= 0x16; i++)\n{\n     int result = ((i * 4) + i) * 4;\n     System.out.println(result);\n}\n\n```\n\n-----\n\nSince multiplication is the same as repeated addition, one can even further simplify the\nformula. At first, i is multiplied by four, after which i is added. This can be simplified by stating\nthat i is multiplied by five. The outcome of this is multiplied by four. As such, the original\nvalue is multiplied by four, after which its multiplied by five. In total, i is multiplied by (four\ntimes five) twenty. The code below shows the simplification in several steps.\n```\n((i * 4) + i) * 4;\n(i * 5) * 4\ni * 20\n\n```\nThe likely reason as to why the code looks like this, is the efficiency of the shift instructions,\nwhen compared to the multiplication instructions. The compiler likely chose to replace a\nsingle multiplication with less resource intensive instructions.\n\nWhen looking at the main function in Ghidra’s decompiler, one can find the string array\ndecryption loop at line 100, 101, and 102. The excerpt is given below. Note that the\nrefactoring of the variables in the assembly code is reflected in this code.\n```\nfor (i = 0; i < 0x17; i = i + 1) {\n encrypt_code(daemonname + i * 0x14,0x14);\n}\n\n```\nNote that this loop displays 0x17 with regards to the amount of iterations, rather than 0x16.\nThe condition for the loop is less than, rather than less than or equal, meaning the value\nneeds to be incremented with one.\n\nFully understanding the code, and how it is generated, will be useful when creating a Ghidra\nscript later on.\n\n## Remaking the decryption routine\n\nThe decryption function, named encrypt_code, is used to decrypt a given encrypted string\nwith a given length. The function is given below.\n```\nbyte * encrypt_code(byte *param_1,int param_2)\n{\n byte *local_10;\n int local_c;\n local_10 = param_1;\n for (local_c = 0; local_c < param_2; local_c = local_c + 1) {\n  *local_10 = *local_10 ^ xorkeys[local_c % 0x10];\n  local_10 = local_10 + 1;\n }\n return param_1;\n}\n\n```\n\n-----\n\nThe first argument (named param_1) can be renamed into input, whereas the second\nargument (named param_2) can be renamed into length. The variable named local_10 is a\ncopy of the given input, as it points to the same value. As such, it can be renamed into\n_inputCopy. The loop uses local_c as its counter, which can be renamed into i. The refactored_\ncode is given below.\n```\nbyte * encrypt_code(byte *input,int length)\n{\n byte *inputCopy;\n int i;\n inputCopy = input;\n for (i = 0; i < length; i = i + 1) {\n  *inputCopy = *inputCopy ^ xorkeys[i % 0x10];\n  inputCopy = inputCopy + 1;\n }\n return input;\n}\n\n```\nThe variable xorkeys is a string, although Ghidra does not recognise it as such. Changing\nthe type, using T as a hotkey in the disassembly view, will display its content. Alternatively,\none can also get the raw value of the bytes instead. The key equals BB2FA36AAA9541F0.\n\nWhen rewriting the decryption function in Java, there is one more more thing to take into\naccount. Strings in C end with a null byte, but when using a byte array to create a string in\nJava, this byte is to be omitted. As not all strings are equal to the predefined length, a check\nis to be included to break the loop when the null byte is encountered. When breaking the\nloop, the bytes that have been decrypted thus far are to be used to create a new string. The\nrecreated function is given below.\n```\nprivate String decrypt(byte[] input, char[] key) {\n byte[] output = new byte[input.length];\n for (int i = 0; i < input.length; i++) {\n  if(input[i] == 0) {\n   break;\n  }\n  output[i] = (byte) (input[i] ^ key[i % 0x10]);\n }\n return new String(output);\n}\n\n```\nNote that the key is passed as an argument to the function, as this will come in useful when\ncreating the script. By passing the value as an argument to the function, one can keep all\nvariables in a single place within the script.\n\n## Writing the Ghidra script\n\n\n-----\n\nThe script itself uses the decryption function that was created in the previous step. To\ndecrypt the string array, several variables need to be initialised first. The decryption key, as is\nrequired by the decryption function, as well as the location of the array (defined as\n_arrayBase), the size of a single element (defined as elementSize), and the amount of_\nelements of the array (defined as arraySize).\n```\nchar[] key = \"BB2FA36AAA9541F0\".toCharArray();\nint arrayBase = 0x080cf1c0;\nint elementSize = 0x14;\nint arraySize = 0x17;\n\n```\nTo get the value of each element, one needs to multiply the loop count with the predefined\nelement size, after which the array’s base address is added. To get the data from the\n[sample, one can use the getBytes function, which requires an Address to know where to](https://ghidra.re/ghidra_docs/api/ghidra/program/flatapi/FlatProgramAPI.html#getBytes(ghidra.program.model.address.Address,int))\nstart reading the bytes from, and an integer to know how many bytes should be read. To\n[convert an integer, long, or string to an Address object, one needs to use the toAddr function.](https://ghidra.re/ghidra_docs/api/ghidra/program/flatapi/FlatProgramAPI.html#toAddr(int))\n\nThe obtained bytes are decrypted by the decryption function, along with the decryption key.\nThe result is then printed to Ghidra’s console.\n```\ntry {\n for (int i = 0; i < arraySize; i++) {\n     int offset = i * elementSize;\n     int location = arrayBase + offset;\n     byte[] input = getBytes(toAddr(location), elementSize);\n     String decrypted = decrypt(input, key);\n     println(decrypted);\n }\n} catch (MemoryAccessException e) {\n e.printStackTrace();\n println(\"\\nA memory access exception occurred, please refer to the stacktrace above\nfor more information\");\n}\n\n```\nIn the case of an error with the getBytes function, a MemoryAccessException is thrown. The\nimage below shows the output of the script once its execution has finished.\n\n\n-----\n\n## Conclusion\n\nDecrypting content from a sample provides a lot more insight as to what the sample does,\nespecially because these strings are concealed for a reason. In some cases, bots within the\nsame family reuse the encryption key. If the key changes, it is easy to replace it in the script,\nor make use of a dialog in the script that requests the key once executed.\n\nUnderstanding how to easily access variables and memory in a script in Ghidra is helpful\nwhen analysing any sample. Given that some code segments are easy to reuse, it is useful\nto create scripts that are made up of easily reusable functions.\n\n## The complete script\n\nThe complete script, including documentation, is given below. Note the hardcoded key,\nelement length, and array length. For more information on how to avoid hardcoding values in\n[a script, one can visit the Amadey string decryption script article.](https://maxkersten.nl/binary-analysis-course/analysis-scripts/ghidra-script-to-decrypt-strings-in-amadey-1-09/)\n\n\n-----\n\n```\n//This script is used to decrypt a string array within the XOR DDoS bot. Note that it\nthe array's location, element size, and array size are hardcoded in the script.\n//@author Max 'Libra' Kersten (https://maxkersten.nl, @Libranalysis)\n//@category string array decryption\n//@keybinding\n//@menupath\n//@toolbar\nimport ghidra.app.script.GhidraScript;\nimport ghidra.program.model.mem.MemoryAccessException;\npublic class xorddos_array_decryption extends GhidraScript {\n /**\n  * This function is called by Ghidra, as such it is the entry into the script\n  */\n @Override\n protected void run() throws Exception {\n  //The hardcoded decryption key, works for numerous samples, but this script is\nbased on 0f00c2e074c6284c556040012ef23357853ccac4ad1373d1dea683562dc24bca\n  char[] key = \"BB2FA36AAA9541F0\".toCharArray();\n  //The location of the array's base address, which resides at index 0\n  int arrayBase = 0x080cf1c0;\n  //The size of each element within the array\n  int elementSize = 0x14;\n  //The amount of elements in the array\n  int arraySize = 0x17;\n  try {\n   //Since the assembly code uses a Jump Below or Equal instruction to compare i\nto 0x16, the loop needs to iterate 0x17 times to cover the complete array\n   for (int i = 0; i < arraySize; i++) {\n    //Declare the offset from the array base (meaning the size of each element\ntimes the element that is selected)\n    int offset = i * elementSize;\n    //Declare the location within the program\n    int location = arrayBase + offset;\n    //Get the bytes for one element at the given location\n    byte[] input = getBytes(toAddr(location), elementSize);\n    //Decrypt the given data using the given key\n    String decrypted = decrypt(input, key);\n    //Print the decrypted string\n    println(decrypted);\n   }\n  } catch (MemoryAccessException e) {\n   //Print the stacktrace, and provide further indication that an error occured\n   e.printStackTrace();\n   println(\"\\nA memory access exception occurred, please refer to the stacktrace\nabove for more information\");\n  }\n }\n /**\n  * Decrypts the given input using the given key and returns a new string with the\ndecrypted content in it\n  * @param input the data to decrypt\n\n```\n\n-----\n\n```\n  @param key the key to decrypt the given input\n  * @return the decrypted input in the form of a string\n  */\n private String decrypt(byte[] input, char[] key) {\n  //Create a new byte array to store the decrypted data in\n  byte[] output = new byte[input.length];\n  //Iterate over all bytes\n  for (int i = 0; i < input.length; i++) {\n   //If the byte equals zero, the string is terminated, meaning the loop needs to\nbe broken, which returns a string based on the data that has been decrypted thus far\n   if(input[i] == 0) {\n    break;\n   }\n   //Decrypt the current byte\n   output[i] = (byte) (input[i] ^ key[i % 0x10]);\n  }\n  //Once the loop breaks, or all iterations have finished, a new string is returned\n  return new String(output);\n }\n}\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-07-25 - Ghidra script to decrypt a string array in XOR DDoS.pdf"
    ],
    "report_names": [
        "2021-07-25 - Ghidra script to decrypt a string array in XOR DDoS.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535888,
    "ts_updated_at": 1743041169,
    "ts_creation_date": 1653709857,
    "ts_modification_date": 1653709857,
    "files": {
        "pdf": "https://archive.orkl.eu/2316a9679a0c1ac1d6afe920fc2bfec3de77d388.pdf",
        "text": "https://archive.orkl.eu/2316a9679a0c1ac1d6afe920fc2bfec3de77d388.txt",
        "img": "https://archive.orkl.eu/2316a9679a0c1ac1d6afe920fc2bfec3de77d388.jpg"
    }
}