{
    "id": "d72f789d-a230-4655-9b1b-ced48294cf16",
    "created_at": "2023-01-12T15:10:47.965047Z",
    "updated_at": "2025-03-27T02:16:26.216856Z",
    "deleted_at": null,
    "sha1_hash": "7438f34aa5769a574b0bb8607daade87245f6bf3",
    "title": "2018-05-21 - Decrypting APT33‚Äôs Dropshot Malware with Radare2 and Cutter ‚Äì Part 1",
    "authors": "",
    "file_creation_date": "2022-05-27T22:54:51Z",
    "file_modification_date": "2022-05-27T22:54:51Z",
    "file_size": 2355876,
    "plain_text": "# Decrypting APT33‚Äôs Dropshot Malware with Radare2 and Cutter ‚Äì Part 1\n\n**[megabeets.net/decrypting-dropshot-with-radare2-and-cutter-part-1/](https://www.megabeets.net/decrypting-dropshot-with-radare2-and-cutter-part-1/)**\n\nMay 21, 2018\n\n## Prologue\n\nAs a reverse engineer and malware researcher, the tools I use are super important for me. I\nhave invested hours and hours in creating the best malware analysis environment for myself\nand chose the best tools for me and my needs. For the last two years, radare2 is my go-to\ntool for a lot of reverse-engineering tasks such as automating RE related work, scripting,\nCTFing, exploitation and more. That said, I almost never used radare2 for malware analysis,\nor more accurately, for analysis of malware for Windows. The main reason was that radare2\ncommand-line interface felt too clumsy, complicated and an over-kill. IDA Pro was simply\nbetter for these tasks, a quick inspection of functions, data structures, renaming,\ncommenting, et cetera. It felt more intuitive for me and that what I was searching for while\ndoing malware analysis. And then came Cutter.\n\n## Cutter\n\nAlong the years, the radare2 community had tried to develop many different graphicinterfaces for radare2. None of them came even close to Cutter. Cutter is a QT C++ based\nGUI for radare2. In my opinion, it is the GUI that radare2 deserves. To quote from Cutter‚Äôs\nGithub page:\n\nCutter is not aimed at existing radare2 users. It instead focuses on those whose are\nnot yet radare2 users because of the learning curve, because they don‚Äôt like CLI\napplications or because of the difficulty‚Ä¶\n\n\n-----\n\nCutter is a young project, only one-year-old, and it is the official GUI of radare2 (the first and\nonly GUI to be announced ‚Äúofficial‚Äù). Cutter is a cross-platform GUI that aims to export\nradare2‚Äôs plenty of functionality into a user-friendly and modern GUI. In this post, I‚Äôll show\nyou some of Cutter‚Äôs features and how I work with it. To be honest, Cutter is intuitive so you\nprobably won‚Äôt need me to show you around, but just in case.\n\n**Downloading and installing Cutter**\n\nCutter is available for all platforms (Linux, OS X, Windows). You can download the latest\n[release here. If you are using Linux, the fastest way to use Cutter is to use the AppImage](https://github.com/radareorg/cutter/releases)\nfile.\n\nIf you want to use the newest version available, with new features and bug fixes, you should\nbuild Cutter from source by yourself. It isn‚Äôt a complicated task and it is the version I use.\n\nFirst, you must clone the repository:\n```\ngit clone --recurse-submodules https://github.com/radareorg/cutter\ncd cutter\n\n```\nBuilding on Linux:\n```\n./build.sh\n\n```\nBuilding on Windows:\n```\nprepare_r2.bat\nbuild.bat\n\n```\n[If any of those do not work, check the more detailed instruction page here.](https://github.com/radareorg/cutter/blob/master/docs/Compiling.md)\n\n## Dropshot \\ StoneDrill\n\nDropshot, also known as StoneDrill, is a wiper malware associated with the APT33 group\nwhich targeted mostly organizations in Saudi Arabia. Dropshot is a sophisticated malware\nsample, that employed advanced anti-emulation techniques and has a lot of interesting\n[functionalities. The malware is most likely related to the infamous Shamoon malware.](https://en.wikipedia.org/wiki/Shamoon)\n[Dropshot was analyzed thoroughly by Kaspersky and later on by](https://app.box.com/s/olc867zxc9nkjzm3wkjwi0b0e2awahtn) [FireEye. In this article, we‚Äôll](https://www.fireeye.com/blog/threat-research/2017/09/apt33-insights-into-iranian-cyber-espionage.html)\nfocus on analyzing how Dropshot decrypted the strings inside it in order to evade analysis. In\npart 2 of this article, which will be published soon, we‚Äôll focus on decrypting the encrypted\nresource of Dropshot which contains the actual payload of the malware.\n\n[The Dropshot sample can be downloaded from here (password: infected). I suggest you star](https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%203%20-%20Malware%20analysis/dropshot.exe.zip)\n(‚òÖ) [the repository to get updates on more radare2 tutorials üôÇ](https://github.com/ITAYC0HEN/A-journey-into-Radare2/)\n\n**Please, be careful when using this sample. It is a real malware, and more than that, a**\n**wiper! Use with caution!**\n\n\n-----\n\n_Since we ll analyze Dropshot statically, you can use a Linux machine, as I did._\n\nWho said radare2 doesn‚Äôt have a decent GUI? | Decrypting the encrypted strings of\n[APT33‚Äôs Dropshot malware using Cutter (@r2gui) and](https://twitter.com/r2gui?ref_src=twsrc%5Etfw) [@radareorg‚Äòs Python API.](https://twitter.com/radareorg?ref_src=twsrc%5Etfw)\nCheck it out @ [https://t.co/u50oaVYsOU](https://t.co/u50oaVYsOU) [pic.twitter.com/8loEAG07IW](https://t.co/8loEAG07IW)\n\n[‚Äî Itay Cohen (@megabeets_) May 21, 2018](https://twitter.com/megabeets_/status/998589232259137536?ref_src=twsrc%5Etfw)\n\n## Getting Started\n\nNow that we have Cutter installed, we are set to go and start our analysis. Open Cutter by\ndouble-clicking on its Icon or typing `./Cutter in the command line. Under the ‚ÄúOpen File‚Äù`\ntab select a new file and press ‚Äúopen‚Äù. After opening the file, we landed on the ‚ÄúLoad\nOptions‚Äù window of Cutter. This is an intuitive dialog where we can tell radare2 how to\nanalyze the file. By expanding the ‚ÄúAdvanced options‚Äù, we can set a specific Architecture, a\nCPU, choose a file format and many more.\n\n\n-----\n\nIn order to analyze this sample more accurately, I chose to modify a more advanced option.\nBy moving the Analysis slider we can modify the level of Analysis. We‚Äôll move it to the right in\norder to choose the Advanced analysis mode. Then, disable the auto-renaming of functions\nby removing the check from ‚ÄúAutorename functions based on context ( aan )‚Äù. I chose to\ndisable `aan since in this sample, the algorithm behind` `aan is renaming some functions`\nwith confusing names.\n\n\n-----\n\nAfter clicking OK we ll see the main window of Cutter, the dashboard. In your case, it might\nlook different than mine but it can be easily configured. For example, by clicking ‚ÄúView ->\nPreferences‚Äù you will be able to change the theme colors and to configure the disassembly.\nThe widgets are very flexible and can be located almost anywhere on the screen. You can\nalso add more widgets to the screen by choosing the desired widget from the ‚ÄúWindow‚Äù\nmenu item. Take a few minutes to play with the environment since we‚Äôll not dive deep into\nthe interface.\n\nClick to enlarge\n\n## Basic static analysis\n\nWhen analyzing a malware sample, I usually start by statically examining the binary. A basic\nstatic analysis can sometimes confirm whether a file is malicious, provide information about\nits functionality, and help us understand what we are facing. Although the basic static\nanalysis is straightforward and can be quick, it‚Äôs largely ineffective against sophisticated\nmalware. So before reading any assembly, let‚Äôs have a look around on some widgets.\n\n### Strings\n\nStarting with the Strings widget, we are not seeing anything too interesting. Some strings\nmight indicate names of files to be dropped ‚Äì like ‚ÄúC-Dlt-C-Org-T.vbs‚Äù and ‚ÄúC-Dlt-C-TrshT.tmp‚Äù, others look unique but not telling us much, for example, ‚ÄúHello dear‚Äù. We can also\nsee some API functions and library strings we are familiar with, but there‚Äôs no ‚Äúsmoking gun‚Äù.\n\n### Entropy\n\n\n-----\n\nAnother attribute that is worth checking is the file s entropy. What is an entropy of a binary\n[file? I‚Äôll use a nice quote which is originated from this page (in Russian, I have no idea what](https://exelab.ru/art/wasm2.php#4)\n[is written here) but was taken by me from this great article about entropy.](http://n10info.blogspot.co.il/2014/06/entropy-and-distinctive-signs-of-packed.html)\n\n_Oh, what‚Äôs the way this word hasn‚Äôt been mocked in thermodynamics! The measure of_\n_order in the system, the measure of energy dissipating and what‚Äôs not! Without any_\n_doubt, a real physicist will be sick of our definition while a real mathematician is going_\n_to be outraged. Nevertheless, as true dilettantes, let‚Äôs define the word ‚Äúentropy‚Äù as a_\n**_measure of the efficiency of information storage._**\n\nSimply put, entropy (in our case) is the measurement of randomness in a given set of values\n(data). The Entropy of a file (or data) is calculated similarly in different programs. Usually, it is\na number between 0.0 to 8.0. The value of entropy is a reliable sign that the file is packed,\ncompressed or contains packed or compressed data inside. A packed binary will probably\nhave high entropy value. How high? Well, it differs. Some would say that 6.0 is high enough,\nsome will say that 7.0 and above. I prefer to be somewhere in the middle and to treat 6.8 as\ngood indicator that the binary or some of its components are compressed or packed.\n\nWe can easily see the calculated entropy of Dropshot by looking at Cutter‚Äôs Dashboard\nwidget:\n\nAs you can see, our file has an entropy of 7.1 which is a very good indication of a\ncompressed\\packed data. To be more specific, we can see in the Sections widget the\nentropy of each section:\n\nLook how high the entropy of `.rsrc section is. Remember that the highest possible`\nentropy value is 8.0. No doubt, we have an interesting data in this section. We‚Äôll get to that\nlater in the 2nd part of this series\n\n\n-----\n\n## Understanding the strings decryption process\n\nWhile I was going through Dropshot code, I found that it is using a rather not-too-complicated\nmethod to decrypt its embedded strings (well, most of them). This function stood up in my\nanalysis mainly because it was called many many times in the code and was used mainly\nbefore `LoadLibraryA and` `GetProcAddress . So it looked to me as a technique to load`\nlibraries and functions dynamically in order to complicate analysis. A very popular approach\namong malware authors. The aim of this article is not to understand every component of the\nmalware, but to get familiar with Cutter, scripting with radare2, and how both can be used by\nmalware researchers. Thus, (sadly) I won‚Äôt explain every step I took to find the decryption\nfunction.\n\nAs said before, spotting the decryption function was done thanks to its popularity and its\ncruciality to the program‚Äôs flow. If you want to give it a shot and try to find it by yourself ‚Äî this\nis the time.\n\nWhether you found it or were too lazy to even search, here‚Äôs the answer ‚Äî the decryption\nfunction is located at `0x4012a0 and appears to take two parameters. In the next`\nscreenshot, we‚Äôll see a function which is using the decryption function.\n\nClick to enlarge\n\nThe demonstrated function above ( 0x4017a0 ) is passing two parameters into our\ndecryption function ( 0x4012a0 ). The first argument is `0xb (Decimal: 11) and the second`\nargument is an address at `0x41b8cc . This is the time to rename our strings decryption`\nfunction in order to ease our analysis. It can be easily done by clicking on\n\n\n-----\n\n```\nfcn.004012a0 and pressing Shift + N or by right-clicking and choosing\n\n```\n‚ÄúRename `fcn.004012a0 ‚Äú. Enter the new name and press OK. I chose to call it`\n```\nstrings_decrypter .\n\n```\nNext, we can see that the output of `strings_decrypter ( eax ) is being pushed to another`\nfunction at `0x4013b0 in addition to another argument, 1. Let‚Äôs have a look at this function:`\n\nClick to enlarge\n\nThe function is taking the right branch if the argument passed to it is 0 (i.e `EAX == 0 ) and`\nthe left branch if it is not. Either way, it will call `LoadLibraryA with a string that would be`\ndecrypted using our beloved decryption function. I‚Äôll spoil it for you ‚Äî the function would load\n```\nntdll.dll on the right branch and kernel32.dll on the left. Simply put, the function is\n\n```\nloading the required library in order to use a function from it. I‚Äôll rename this function to\n```\nload_ntdll_or_kernel32 . Now let‚Äôs get back to the previous function and continue to\n\n```\nexamine it.\n\n\n-----\n\nAfter choosing loading either `ntdll.dll or` `kernel32.dll, the function`\ncalls `GetProcAddress with a handle to the loaded library and the string that it decrypted at`\nthe beginning. We can be sure that this string is an exported API function of\n```\nkernel32.dll . A few instructions later we can see that the referenced API function is\n\n```\nbeing called.\n\nWe don‚Äôt have any idea which API function is being called. That‚Äôs why we need to\nunderstand how `strings_decrypter is working and what is each parameter that is being`\npassed to it.\n\n## Analyzing the decryption function\n\nWe talked about this function constantly but we didn‚Äôt see it yet. Here‚Äôs the graph of the\nfunction as created by Cutter:\n\nClick to enlarge\n\nSo, what do we have here? We obviously won‚Äôt go over it step by step, but we need to, and\nwill, understand the general idea. We already know that this function receives two\narguments. The first one is an address and the second is a number. The address argument\nis held by a variable named `arg_8h, the integer is stored at` `arg_ch . At the first block,`\nstarting at `0x4012a0, we can see that a buffer at the size of` `arg_ch+1 is allocated by`\n\n\n-----\n\n```\nVirtualAlloc . Then the address to the allocated buffer is assigned to local_8h . We\n\n```\ncan rename it to `buffer by clicking on its name and pressing Shift+N. This can also be`\ndone using the right-click context menu.\n\nAfter that, we can see that zero is assigned to `local_4h . The next block is a starting of a`\nloop. We can see that the integer stored at `arg_ch is assigned to` `edx which in turn is`\ncompared with `local_4h . We can understand now that` `arg_ch is some kind of length or`\nsize and `local_4h is a loop index. Let‚Äôs rename both to` `length and` `index . Now that`\nwe know the purpose of one argument of the two and the purpose of the two local variables,\nwe need to understand what is in the address that is passed via `arg_8h . In our example,`\nwe saw the value `0x41b8cc being passed to our` `strings_decrypter function. Let‚Äôs go`\nto the Hexdump widget and seek to this address. Just type this address in the upper textbox\nin order to seek a flag or an address. We can see that this is a half-word (2 bytes) array of\nintegers that starts from `0x41b8cc and ends at` `0x0041b8e1 . Using another great feature`\nfrom Cutter (at the right side of the screen), we can generate a C array of half-words:\n\nThat‚Äôs a really great feature, right?! Cutter can generate different types of arrays to ease\nscripting tasks. Here are some examples:\n\n**C half-words (Little Endian):**\n\n\n-----\n\n```\n#define _BUFFER_SIZE 11\nconst uint16_t buffer[11] = {\n 0x0005, 0x0006, 0x000e, 0x0006, 0x001c, 0x0006, 0x0007, 0x000b,\n 0x000e, 0x0006, 0x0022};\n\n```\n**Python:**\n```\nimport struct\nbuf = struct.pack (\"22B\", *[\n0x05,0x00,0x06,0x00,0x0e,0x00,0x06,0x00,0x1c,0x00,0x06,\n0x00,0x07,0x00,0x0b,0x00,0x0e,0x00,0x06,0x00,0x22,0x00])\n\n```\n**Javascript:**\n```\nvar buffer = new Buffer(\"BQAGAA4ABgAcAAYABwALAA4ABgAiAA==\", 'base64');\n\n```\nThis array will help us later to write the decryption script. For now, let‚Äôs continue to figure out\nhow `strings_decrypter works. Entering the loop, we can see that` `eax will hold the`\n```\nindex and ecx will hold the aforementioned array. Then, a byte from [ecx + eax*2] is\n\n```\nmoved to `edx . Basically,` `edx now equals to` `half_word_array[index*2] . Next, our`\nbuffer is moved to `eax which in turn is being added with the value of` `index, setting`\n```\neax to a specific offset in the allocated buffer. Then, at 0x004012eb, we can see that a\n\n```\nbyte is moved to `cl . This byte is taken from index` `[edx] of a pre-defined string. Double-`\nclicking the string will reveal us the full string ‚Äî\n```\nAaCcdDeFfGhiKLlMmnNoOpPrRsSTtUuVvwWxyZz32.\\EbgjHI\n_YQB:\"/@\\x0a\\x0d\\x1a . Immediately after that, the byte from cl is copied into the\n\n```\nspecific index in our `buffer . The loop continues` `length times.`\n\nAfter all this mess we can say that the array which is passed to this function, `arg_8h, is`\nsimply an array of offsets in this string and `length is the length of the string to be built.`\nThis is how Dropshot builds its strings, by passing the offsets array and the string‚Äôs length.\nLet‚Äôs confirm this claim by testing it with Python.\n\n[This is where another great feature of Cutter is being used, an integrated Jupyter notebook.](http://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html)\nWe don‚Äôt need to open any external Python shell, we can use Cutter‚Äôs Jupyter widget.\n\n\n-----\n\nOh, I love this feature!\n\nSo let‚Äôs write a quick proof of concept to confirm that this is really how this decryption\nfunction works. Here‚Äôs the quick POC in python:\n```\n# The pre-defined decryption table (the string)\ndecryption_table = 'AaCcdDeFfGhiKLlMmnNoOpPrRsSTtUuVvwWxyZz32.\\EbgjHI\n_YQB:\"/@\\x0a\\x0d\\x1a'\n# The offsets array (0x41b8cc) which is passed to the function\noffsets_array = [\n0x05,0x00,0x06,0x00,0x0e,0x00,0x06,0x00,0x1c,0x00,0x06,\n0x00,0x07,0x00,0x0b,0x00,0x0e,0x00,0x06,0x00,0x22,0x00]\n# The length which is passed to the function\nlength = 11\ndecrypted_string = ''\nfor i in range(length):\n  decrypted_string += decryption_table[ offsets_array[ i*2 ] ]\nprint (\"Decrypted: %s\" % (decrypted_string))\n\n```\nAnd let‚Äôs run it in Jupyter:\n\n\n-----\n\nGreat! We can see that we successfully decrypted the string and got ‚ÄúDeleteFileW‚Äù which is\nan API function. So now we can feel confident to rename the last argument, `arg_8h, to`\n‚Äúoffsets_array‚Äù.\n\nNow that we figured out how `strings_decrypter is working, and even decrypted one`\nstring, we can see where else this function is being called and decrypt all the other strings.\nTo see the cross-references to `strings_decypter, click on its name and press X on the`\nkeyboard. This will open the xrefs window. Cutter will also show us a preview of each\nreference to this function which makes the task of inspecting xrefs much easier.\n\n\n-----\n\nClick to enlarge\n\nWe can see dozens of calls to `strings_decrypter, too much for a manual decryption.`\nThat is where the power of radare2 and Cutter scripting will come handy!\n\n## Scripting time! Decrypting the strings\n\n[Scripting radare2 is really easy thanks to r2pipe. It is the best programming interface for](https://github.com/radare/radare2-r2pipe)\nradare2.\n\nThe r2pipe APIs are based on a single r2 primitive found\nbehind `r_core_cmd_str() which is a function that accepts a string parameter`\ndescribing the r2 command to run and returns a string with the result.\n\n[r2pipe supports many programming languages including Python,](https://github.com/radare/radare2-r2pipe/tree/master/python) [NodeJS,](https://github.com/radare/radare2-r2pipe/tree/master/nodejs/r2pipe) [Rust,](https://github.com/radare/radare2-r2pipe/tree/master/rust) [C, and](https://github.com/radare/radare2-r2pipe/tree/master/c)\nothers.\n\nLucky us, Cutter is coming with the python bindings of `r2pipe integrated into its Jupyter`\ncomponent. We‚Äôll write an r2pipe script that will do the following:\n\nDeclare constant variables for the addresses we already know (decryption function,\ndecryption table)\nDump the content of the decryption table to a variable\nIterate over all the references to the decryption table and save the arguments passed\nto it\nManually decrypt the encrypted string\nPrint the decrypted function to the screen and add inline comments in the assembly\n\n- Note that the following script requires an understanding of radare2 commands. Most of the\ncommands I‚Äôll use here explained in my previous articles on my series of articles: ‚ÄúA journey\ninto Radare 2‚Äù. Make sure to check it out!\n\n\n-----\n\nThe first item on our list is to define the addresses of the components we have already\ndetected: the decryption table and the decryption function.\n```\nimport cutter\n# Declaration of decryption-table related variables\ndecryption_table = 0x41BA3C\ndecryption_table_end = 0x41BA77\ndecryption_table_len = decryption_table_end - decryption_table\ndecryption_function = 0x4012A0\n\n```\nNext, we need to analyze the binary so radare2 will detect the xrefs and functions. `aa is a`\nbasic analysis command of radare2. `cutter.cmd is a function that receives a radare2`\ncommand and returns its output, if there‚Äôs any output at all.\n```\ncutter.cmd('aa')\n\n```\nLet‚Äôs move on and dump the content of the decryption_table to a variable. `pxj is used`\nto print hexdump, the j suffix can be used in most of the radare2 commands to get a JSON\noutput. `cutter.cmdj will parse the JSON output for us.`\n```\n# Dump the decryption table to a variable\ndecryption_table_content = cutter.cmdj(\n  \"pxj %d @ %d\" % (decryption_table_len, decryption_table))\n\n```\nSo basically in this piece of code, we are telling radare2 to take\n```\ndecryption_table_len bytes from ( @ ) the address of decryption_table . Now we\n\n```\nhave all the data we need in order to start iterate over the references to the decryption\nfunction.\n\nUsing a Python `for loop, we will iterate over the output of` `axtj . This command stands`\nfor analyze xrefs to and it is being used to list all the data and code references to a specific\naddress. In our case, this address will be our decryption function. The first thing that we will\ndo in each iteration is to parse the two arguments that are passed to the decryption function.\nThese will be the offset array and the length of the string to be decrypted. We‚Äôll parse the\narguments using `pdj -2 @ <some xref address> .` `pdj stands for print disassembly.`\nPassing `-2 to` `pdj is telling radare2 to print 2 instructions before the given address. We`\nassume that these two arguments will be passed to the function right before it is being called\nby the program.\n\n\n-----\n\n```\n# Iterate x refs to the decryption function\nfor xref in cutter.cmdj('axtj %d' % decryption_function):\n  # Get the arguments passed to the decryption function: length and encrypted\nstring\n  length_arg, offsets_arg = cutter.cmdj('pdj -2 @ %d' % (xref['from']))\n  # String variable to store the decrypted string\n  decrypted_string = \"\"\n  # Guard rail to avoid exception\n  if (not 'val' in length_arg):\n    continue\n\n```\nNow for the fun part, decrypting the string. Since we already did a POC of it, we know how\nthe decryption works. This will be easy to implement using a `for loop:`\n```\n  # Manually decrypt the encrypted string\n  for i in range(0, length_arg['val']):\n    decrypted_string += chr(decryption_table_content[cutter.cmdj(\n      'pxj 1 @ %d' % (offsets_arg['val'] + (i*2)))[0]])\n\n```\nGreat! Now `decypted_string is holding the, well, the decrypted string. All we left to do is`\nto print it to the console and add inline-comments in each call. The command `CC will be`\nused to add the comments.\n```\n  # Print the decrypted and the address it was referenced to the console\n  print(decrypted_string + \" @ \" + hex(xref['from']))\n  # Add comments to each call of the decryption function\n  cutter.cmd('CC Decrypted: %s @ %d' % (decrypted_string, xref['from']))\n\n```\nNow we can combine it all into one script:\n\n\n-----\n\n```\nimport cutter\n# Declaration of decryption-table related variables\ndecryption_table = 0x41BA3C\ndecryption_table_end = 0x41BA77\ndecryption_table_len = decryption_table_end - decryption_table\ndecryption_function = 0x4012A0\ncutter.cmd('aa')\n# Dump the decryption table to a variable\ndecryption_table_content = cutter.cmdj(\n  \"pxj %d @ %d\" % (decryption_table_len, decryption_table))\n# Iterate x-refs to the decryption function\nfor xref in cutter.cmdj('axtj %d' % decryption_function):\n  # Get the arguments passed to the decryption function: length and encrypted\nstring\n  length_arg, offsets_arg = cutter.cmdj('pdj -2 @ %d' % (xref['from']))\n  # String variable to store the decrypted string\n  decrypted_string = \"\"\n  # Guard rail to avoid exception\n  if (not 'val' in length_arg):\n    continue\n  # Manually decrypt the encrypted string\n  for i in range(0, length_arg['val']):\n    decrypted_string += chr(decryption_table_content[cutter.cmdj(\n      'pxj 1 @ %d' % (offsets_arg['val'] + (i*2)))[0]])\n  # Print the decrypted and the address it was referenced to the console\n  print(decrypted_string + \" @ \" + hex(xref['from']))\n  # Add comments to each call of the decryption function\n  cutter.cmd('CC Decrypted: %s @ %d' % (decrypted_string, xref['from']))\n  # Refresh the interface\n  cutter.refresh()\n\n```\nNow we can paste the script to the Jupyter notebook inside Cutter and execute it. A second\nafter, we can take a look at the Comments widget and see that our script worked and\nupdated the comments:\n\n\n-----\n\nWe can also see these comments inline in the disassembly:\n\nClick to enlarge\n\nAwesome! We did it, we decrypted the encrypted strings and added inline comments to ease\n[the analysis process. The final script can be found here.](https://github.com/ITAYC0HEN/A-journey-into-Radare2/blob/master/Part%203%20-%20Malware%20analysis/decrypt_dropshot.py)\n\n## Epilogue\n\nHere comes to an end the first part of this article about decrypting Dropshot with Cutter and\nr2pipe. We got familiar with Cutter, radare2 GUI, and wrote a decryption script in r2pipe‚Äôs\nPython binding. We also analyzed some components of APT33‚Äôs Dropshot, an advanced\nmalware.\n\nThe next part will be shorter and in it, we‚Äôll see how to decrypt an encrypted resource inside\nDropshot. This resource is the actual payload of Dropshot. So stay tuned!\n\n\n-----\n\n[As always, please post comments to this post or message me privately if something is](https://www.megabeets.net/about.html#contact)\nwrong, not accurate, needs further explanation or you simply don‚Äôt get it. Don‚Äôt hesitate to\nshare your thoughts with me.\n\n**Subscribe on the left if you want to get the next articles straight in your inbox.**\n\n[Eat Veggies](https://www.megabeets.net/about.html#vegan)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-05-21 - Decrypting APT33‚Äôs Dropshot Malware with Radare2 and Cutter ‚Äì Part 1.pdf"
    ],
    "report_names": [
        "2018-05-21 - Decrypting APT33‚Äôs Dropshot Malware with Radare2 and Cutter ‚Äì Part 1.pdf"
    ],
    "threat_actors": [
        {
            "id": "b23e717c-0b27-47e0-b3c8-4defe6dd857f",
            "created_at": "2023-01-06T13:46:38.367369Z",
            "updated_at": "2025-03-27T02:00:02.815758Z",
            "deleted_at": null,
            "main_name": "APT33",
            "aliases": [
                "ATK35",
                "Peach Sandstorm",
                "TA451",
                "APT 33",
                "Elfin",
                "Refined Kitten",
                "MAGNALLIUM",
                "HOLMIUM",
                "COBALT TRINITY",
                "G0064"
            ],
            "source_name": "MISPGALAXY:APT33",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "9fe49a5b-f3e6-4fbf-99a1-db15dad460c3",
            "created_at": "2024-05-01T02:03:08.045004Z",
            "updated_at": "2025-03-27T02:05:17.325038Z",
            "deleted_at": null,
            "main_name": "COBALT TRINITY",
            "aliases": [
                "Elfin ",
                "HOLMIUM ",
                "MAGNALIUM ",
                "Peach Sandstorm ",
                "Refined Kitten ",
                "TA451 ",
                "APT33 "
            ],
            "source_name": "Secureworks:COBALT TRINITY",
            "tools": [
                " Cadlotcorg",
                " Dello RAT",
                " Imminent Monitor",
                " KDALogger",
                " Koadic",
                " NanoCore",
                " NetWire",
                " POWERTON",
                " PoshC2",
                " Poylog",
                " PupyRAT",
                " Schoolbag",
                "AutoCore"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "e5ff825b-0456-4013-b90a-971b93def74a",
            "created_at": "2022-10-25T15:50:23.824058Z",
            "updated_at": "2025-03-27T02:00:55.553346Z",
            "deleted_at": null,
            "main_name": "APT33",
            "aliases": [
                "APT33",
                "HOLMIUM",
                "Elfin",
                "Peach Sandstorm"
            ],
            "source_name": "MITRE:APT33",
            "tools": [
                "PowerSploit",
                "AutoIt backdoor",
                "PoshC2",
                "Mimikatz",
                "NanoCore",
                "DEADWOOD",
                "StoneDrill",
                "POWERTON",
                "LaZagne",
                "TURNEDUP",
                "NETWIRE",
                "Pupy",
                "ftp",
                "Shamoon"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536247,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1653692091,
    "ts_modification_date": 1653692091,
    "files": {
        "pdf": "https://archive.orkl.eu/7438f34aa5769a574b0bb8607daade87245f6bf3.pdf",
        "text": "https://archive.orkl.eu/7438f34aa5769a574b0bb8607daade87245f6bf3.txt",
        "img": "https://archive.orkl.eu/7438f34aa5769a574b0bb8607daade87245f6bf3.jpg"
    }
}