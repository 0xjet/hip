{
    "id": "361eae1b-3e41-4639-805e-479f5ca8fbcb",
    "created_at": "2023-01-12T15:02:41.849207Z",
    "updated_at": "2025-03-27T02:09:30.94545Z",
    "deleted_at": null,
    "sha1_hash": "c586e990a738f00ec6fac744b3d823df9d4d7aaf",
    "title": "2020-11-27 - Dissecting APT21 samples using a step-by-step approach",
    "authors": "",
    "file_creation_date": "2022-05-27T23:03:48Z",
    "file_modification_date": "2022-05-27T23:03:48Z",
    "file_size": 6261931,
    "plain_text": "# Dissecting APT21 samples using a step-by-step approach\n\n**[cybergeeks.tech/dissecting-apt21-samples-using-a-step-by-step-approach/](https://cybergeeks.tech/dissecting-apt21-samples-using-a-step-by-step-approach/)**\n\nSummary\n\nIn this blog post we’re presenting a detailed analysis of 2 malicious files (a backdoor known as “Travelnet”)\nlinked to an APT (Advanced Persistent Threat) actor called APT21.\n\nAPT21, also known as Zhenbao or Hammer Panda, is a group of suspected state sponsored hackers of\nChinese origin.\n\nAccording to multiple online sources, that we have referenced in the article, APT 21 historically targeted the\nRussian government and groups which seek greater autonomy or independence from China, such as those\nfrom Tibet or Xinjiang.\n\nThe first file is a dropper used to register a malicious DLL (NetTraveler trojan) as a service. The main\npurpose of the trojan is to gather information about the environment such as user name, host name, IP\naddress of the host, Windows OS version, different configurations of the CPU, information about memory\nconsumption, the list of processes. The malicious process is interested in .doc, .docx, .xls, .xlsx, .txt, .rtf, .pdf\nfiles on disk and also on USB drives and network shares in order to exfiltrate them. During the entire\ninfection, multiple .ini configuration files are created and also the malware has the capability to download\nand execute additional files on the infected machine. The data is compressed using a custom Lempel-Zivbased algorithm and encoded with a modified Base64 algorithm before it will be exfiltrated to the Command\nand Control server.\n\nTechnical analysis\n\n**Section I**\n\nDropper\n\nSHA256: FECA8DB35C0C0A901556EFF447C38614D14A7140496963DF2E613B206527B338\n\nOne of the first steps the malware is performing consists of creating a mutex called ” INSTALL SERVICES\nNOW!” (note the space). The mutex is used to avoid reinfection of an already infected machine:\n\nFigure 1\n\nThe malicious process creates a configuration file at “C:\\Windows\\System\\config_t.dat” which will be heavily\nused during the entire infection. The API call used to accomplish this task is CreateFileA and it’s presented\nin figure 2:\n\n\n-----\n\nFigure 2\nThe following bytes found at a precise location in the malicious file are read in order to decrypt them:\n\nFigure 3\n\nThe decryption routine is shown in the next figure and consists of a XOR operation with 0x3E:\n\nFigure 4\n\n\n-----\n\nAfter the decryption is over the new string represents a URL which contains the C2 server as we ll see later\non:\n\nFigure 5\n\nThe configuration file is populated using WritePrivateProfileStringA API calls as shown below. Please note\nthat WebPage is equal to the string decrypted above and the others options will be explained later on in a\nbetter context:\n\nFigure 6\n\nFigure 7\n\nFigure 8\n\n\n-----\n\nFigure 9\n\nFigure 10\nAfter all of these API calls the configuration file has the following schema:\n\nFigure 11\n\nNow there is a byte at offset 0x334 in the file which indicates if the malicious process is supposed to use a\nproxy or not (by default this value is 0 and UP=0 means the malware is not using a proxy for network\ncommunications). If that byte is set to 1, the malware writes UP=1 in the configuration file and also 5\nadditional values: PS (proxy address), PP (proxy port), PU (proxy user), PW (proxy password) and PF\n(unknown). RegQueryValueExA API is used to retrieve the type and data for netsvcs (svchost.exe)\nassociated with “HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\nNT\\CurrentVersion\\Svchost”:\n\n\n-----\n\nFigure 12\nThe malicious file enumerates all the available services on the host and compares them with a hardcoded\nlist presented in figure 13. The first service which is not found on the system will be used for malicious\npurposes as we’ll describe further.\n\nFigure 13\n\nThe strategy is as follows: it will enumerate the keys corresponding to a service like\n“HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\<ServiceName>” in order to see if the\nservice is installed or not. The following services have been present on the analyzing machine:\nCertPropSvc, SCPolicySvc, lanmanserver, gpsvc, iphlpsvc, msiscsi, schedule, winmgmt, SessionEnv and\nthe first one which was missing is FastUserSwitchingCompatibility. RegOpenKeyExA API is utilized to check\nfor the existence of the services, one such example is detailed in the figure below:\n\nFigure 14\nThe file “C:\\WINDOWS\\system32\\FastUserSwitchingCompatibilityex.dll” associated with\nFastUserSwitchingCompatibility service is supposed to be deleted by the running process (it doesn’t exist\non the machine):\n\n\n-----\n\nFigure 15\nA new service called “FastUserSwitchingCompatibility” is created using CreateServiceA API function which\ntries to impersonate the legitimate service, the binary path of the service being\n%SystemRoot%\\System32\\svchost.exe -k netsvcs (legitimate process):\n\nFigure 16\nIf the call is successful we’ll see a registry key like the one displayed in figure 17. (this technique is part of\nevasion techniques). Attackers will try to impersonate/use legitimate system binaries or libraries on the host\nto hide malicious activity. This will allow them to blend with regular activity and remain hidden. (you can find\n[more details about lolbins at https://lolbas-project.github.io/).](https://lolbas-project.github.io/)\n\nFigure 17\nIn order to verify that the service was successfully created the malicious process tries to open\n“HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\FastUserSwitchingCompatibility” (now it\nexists because it corresponds to the newly created service):\n\n\n-----\n\nFigure 18\nA new key called “Parameters” is created under\n“HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\FastUserSwitchingCompatibility” using\nRegCreateKeyA API. This will be used to register a malicious DLL as a service:\n\nFigure 19\nThe process creates an empty file called temp.bat in the same directory as the initial executable (in our\ncase, Desktop). The content of the batch file is shown below:\n\nFigure 20\nThe purpose of the batch file is to register the DLL found at\n“C:\\WINDOWS\\system32\\FastUserSwitchingCompatibilityex.dll” as a service by adding “ServiceDll” entry.\nFile “C:\\WINDOWS\\system32\\FastUserSwitchingCompatibilityex.dll” doesn’t exist at this time, however it’s\ncreated by the malware using CreateFileA API as shown below (it will be populated with malicious code as\nwe’ll see in a bit):\n\nFigure 21\n“Timestomping” is a tehnique used by a malicious actor to modify files’ timestamps (for example\ncreated/modified timestamps) in order not to raise any suspicions about the file. In our case the created and\nmodified timestamps of the DLL file are set to Tuesday, August 17, 2004, 9:00:00 PM:\n\n\n-----\n\nFigure 22\n\nNow the DLL file created earlier is filled with malicious code using WriteFile API. Even if the path of the file\nlooks legitimate (running from “C:\\Windows\\SysWOW64” directory), it’s just impersonating a legitimate\nservice:\n\nFigure 23\nIt’s worth mentioning that registering a DLL file as a service is a persistence mechanism. The newly created\nservice is started using StartServiceA API and the flow of execution is passed to the DLL export function\nServiceMain:\n\n\n-----\n\nFigure 24\n**Section II**\n\nDLL file\n\nSHA256: ED6AD64DAD85FE11F3CC786C8DE1F5B239115B94E30420860F02E820FFC53924\n\nOne of the first steps the malware is performing is to invoke GetProcessWindowStation API which returns a\nhandle to the current window station and then it uses OpenWindowStationA API to open the interactive\nwindow station (“Winsta0”). The process assigns the specified window station (“Winsta0”) which is the only\ninteractive window station (the service is supposed to be interactive) to the calling process using the\nSetProcessWindowStation function:\n\nFigure 25\nAs in the first example the process creates a different mutex called “NetTravler Is Running!”. If it exists it will\nexit without reinfecting the machine:\n\nFigure 26\nNow it retrieves a few elements from the configuration file config_t.dat created by the first process:\nWebPage, DownCmdTime, UploadRate, AutoCheck, UP and CheckedSuccess (it doesn’t exist at this time,\nso the function returns 0). All of the values are extracted using GetPrivateProfileString and\nGetPrivateProfileInt APIs:\n\nFigure 27\n\n\n-----\n\nFigure 28\n\nFigure 29\n\nFigure 30\n\nFigure 31\n\nFigure 32\nBecause we’re running the DLL using an executable used by x32dbg to debug the DLL files, the process\nname is similar to “DLLLoader32_58D1.exe” (in our case). The malicious process creates a .log file which\nhas the same name as the executable (“DLLLoader32_58D1.log”):\n\nFigure 33\n\n\n-----\n\nThe file enumerates the directories from C:\\Program File (x86) and the output is copied to the newly\ncreated file:\n\nFigure 34\n\nRegOpenKeyExA API is used to open\n“HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders” registry key\nand the “History” value is extracted from it using RegQueryValueEx. The content of “History” value is\n“C:\\Users\\<Username>\\AppData\\Local\\Microsoft\\Windows\\History”:\n\nFigure 35\nThe malware is looking for a file called “C:\\Users\\\n<Username>\\AppData\\Local\\Microsoft\\Windows\\History\\History.IE5\\index.dat” which contains Internet\nbrowsing history activity, including Internet based searches and opened files:\n\n\n-----\n\nFigure 36\nThe process extracts “Version” value from\n“HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\Internet Explorer” using\nRegQueryValueEx function:\n\nFigure 37\nWindow 10’s Internet Explorer is Build 916299, Version 9.11.16299.0 as shown in the figure below:\n\nFigure 38\nThe following information is appended to the .log file: IE History is empty because that file is missing on\nWindows 10 and the IE version (note that “version” word is written in Chinese language “版本”):\n\nFigure 39\n\n\n-----\n\nGetVersionExA function is utilized to find the current operating system. The recognized versions are:\nMicrosoft Windows 7, Microsoft Windows Vista, Microsoft Windows 2003, Microsoft Windows 2000,\nMicrosoft Windows XP and Microsoft Windows NT:\n\nFigure 40\nIt also extracts the “ProductType” value from\n“HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\ProductOptions” registry key. On our\nsystem the value is equal to “WinNT”:\n\nFigure 41\nThe following string is appended to the .log file: “操作系统版本” translates to “Operating system version”:\n\n\n-----\n\nFigure 42\n\nThe user agent used in the network communications is always set to “Mozilla/4.0 (compatible; MSIE 6.0)”.\nThere is also an Accept request HTTP header as shown below:\n\nFigure 43\n[The process tries to connect to http://www.microsoft.com/info/privacy_security.htm (this URL used to be](http://www.microsoft.com/info/privacy_security.htm)\navailable in the past) in order to verify if there is an internet connection. The HTTP request is shown in\nfigure 44:\n\nFigure 44\nIf the connection is successful the following strings will be added at the end of the .log file:\n\nFigure 45\n\nFurthermore UP (use proxy indicator) is set to 0 and it adds a value called CheckedSuccess (set to 1) to\nconfig_t.dat using WritePrivateProfileStringA API:\n\n\n-----\n\nFigure 46\nNow, if the connection was unsuccessful, an “Method1 Fail!!!!!” message is written to\nDLLLoader32_58D1.log. Process32First and Process32Next functions are used to find “EXPLORER.exe”\nprocess and then the process tries to open it using OpenProcess API:\n\nFigure 47\nBasically the attacker’s purpose is to steal “explorer.exe” process’ token by calling OpenProcessToken in\norder to open the access token associated with “explorer.exe” and then it uses ImpersonateLoggedOnUser\nfunction to impersonate the security context of a user. The function calls are displayed in figure 48 and\nfigure 49, respectively.\n\nFigure 48\n\nFigure 49\n\n\n-----\n\nThe process is using RegOpenKeyExA to open\n“HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings” registry key and\nthen it extracts “ProxyEnable” value to see if the computer uses a proxy server:\n\nFigure 50\nAlso same function is used to get the “ProxyServer” (hostnames/IPs of the proxy server on the network) and\n“ProxyOverride” (hostnames/IPs that bypass the proxy server) values from the same registry key. The\nextraction of “ProxyServer” value is shown below:\n\nFigure 51\nAs in the first method, the attacker verifies if he’s able to connect to the same URL using the proxy settings\nhe found in the registry. If the connection is successful it will append the content of that page to the .log file\ntogether with some new parameters:\n\nFigure 52\n\nAlso, because the method works, the malicious process modifies the config_t.dat file by setting UP=1,\nPF=10 and then PS (proxy server), PP (proxy port), PU (proxy user), PW (proxy password) are set\naccording to the settings found. If the connection fails, the message “Method3 Fail!!!!!” is appended to the\n.log file. Method4 is pretty similar to Method3 presented above and will not be explained in details. One of\nthe differences is that the “Method4 Fail!!!!!” message is appended to the .log file if the network connection\nisn’t successful.\n\nIf all methods fail, the infection will stop and the following operations are performed (self-deleting malware):\n“HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\FastUserSwitchingCompatibility\\Enum”,\n“HKEY LOCAL MACHINE\\SYSTEM\\CurrentControlSet\\Services\\FastUserSwitchingCompatibility\\Parameters”,\n\n\n-----\n\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\FastUserSwitchingCompatibility\\Security\nand “HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\FastUserSwitchingCompatibility”\nregistry keys are deleted using RegDeleteKeyA function. The following files are deleted as well:\n“C:\\WINDOWS\\system32\\enumfs.ini”, “C:\\WINDOWS\\system32\\dnlist.ini”,\n“C:\\WINDOWS\\system32\\udidx.ini”, “C:\\WINDOWS\\system32\\uenumfs.ini” and\n“C:\\WINDOWS\\system32\\stat_t.ini” (some of them don’t exist at this time).\n\nIf one of the methods enumerated above works, the malicious process sleeps for 60 seconds and then\ncreates another thread that we’ll call Thread1, sleeps another 10 seconds, and creates Thread2. The main\nthread will enter into an infinite loop until the variable found at 0x100163E8 (absolute address) is set to 3:\n\nFigure 53\n\n**Thread1 activity**\n\nFirstly the thread retrieves the volume serial number (“A2C9-AD2F”) associated with “C:\\” directory using\nGetVolumeInformationA function. This number will be used as a host id in the communication with the C2\nserver as we will see later on. Also it uses GetComputerNameA API to find the NETBIOS name of the\ncomputer, GetUserNameA API to find the username associated with the current thread, gethostname API to\nretrieve the host name for the computer and gethostbyname/inet_ntoa functions to print the IP address of\nthe computer:\n\n\n-----\n\nFigure 54\nOne more time the “ProductType” value from\n“HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\ProductOptions” registry key is retrieved as\nshown in figure 55:\n\nFigure 55\nThe malicious process enumerates the available disks drives and it’s interested in type 3 drives\n(DRIVE_FIXED) as shown in the screenshot below:\n\n\n-----\n\nFigure 56\n\nRegOpenKeyExA API is utilized to open\n“HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0” registry key and then\nRegQueryValueEx is used to retrieve “VendorIdentifier”, “Identifier” and “~MHz” values:\n\n\n-----\n\nFigure 57\nThe process uses GlobalMemoryStatus function to get information about system’s usage of physical and\nvirtual memory. All the information extracted so far will be stored in a new file called\n“C:\\Windows\\SysWOW64\\system_t.dll” in order to exfiltrate it. All translations from chinese to english are\nprovided to better understand the content of the file: “计算机信息” translates to “computer information”, “计算\n机” translates to “computer”, “用户名” translates to username, “Ip地址” translates to “Ip address”, “操作系统”\ntranslates to “operating system”, “磁盘空间” translates to “disk space”, “总磁盘空间为” translates to “The\ntotal disk space is”, “剩余磁盘空间为” translates to “The remaining disk space is”, “占” translates to “take\nup”, “物理内存” translates to “physical memory”, “总物理内存” translates to “Total physical memory” and “可\n用内存” translates to “Available memory”:\n\nFigure 58\n\nA list of processes is retrieved using Process32First and Process32Next APIs as shown below:\n\n\n-----\n\nFigure 59\nAfter the operation is complete and the malware obtains the list of processes, it will be appended to\nsystem_t.dll (“进程列表” translates to “Process list”):\n\nFigure 60\n\nThe next step is to create a pipe using CreatePipe API . This will be used as an inter-process\ncommunication mechanism. It will create a new process “ipconfig /all” which displays the full TCP/IP\nconfiguration for all adapters and the output will be transmitted back to the original process through pipes:\n\n\n-----\n\nFigure 61\nThe output of the ipconfig process is saved to system_t.dll as shown in the figure below:\n\nFigure 62\nThe malware checks the UP value from config_t.dat using GetPrivateProfileInt function. According to the\nKaspersky report, the content of system_t.dll file will be compressed using a custom Lempel-Ziv-based\nalgorithm and encoded with a modified Base64 algorithm. The function responsible for this operation and\nthe “modified Base64” alphabet is displayed in figure 63:\n\n\n-----\n\nFigure 63\nThe encoded data is exfiltrated via a GET request to vipmailru[.]com (C2 server). The following parameters\nare provided in the URL: hostid = the serial number of current disk drive, hostname = hostname, hostip = IP\nof the machine, filename = “travlerbackinfo-<year>-<month>-<day>-<hour>-<minute>.dll”:\n\nFigure 64\nIf the server response contains “Success:”, the exfiltration was successful. The malicious process also\ndeletes system_t.dll using DeleteFileA API . It performs another GET request (to the same C2 server) with\nthe parameters including “action=getcmd” and others which were already explained above:\n\nFigure 65\n\n\n-----\n\nThe result of the query must contain [CmdBegin]\\r\\n at the beginning of the message and [CmdEnd]\\r\\n\nat the end of it. The message between the “borders” is saved at “C:\\Windows\\System32\\stat_t.ini” and then\nthe process performs a GET request (same C2 server) with a modified parameter “action=gotcmd” and\nother parameters used before:\n\nFigure 66\nAs before, if everything works fine the file expects an HTTP response which contains “Success” string. The\nprocess is looking to delete a file called “C:\\Windows\\SysWOW64\\dnlist.ini” which doesn’t exist at this time.\nThe file will be created and populated with the following data:\n\nFigure 67\n\nFile stat_t.ini is deleted using DeleteFileA function and then it calls GetACP API which returns the current\nWindows ANSI code page identifier for the operating system. Because the value of ScanAll is True in\ndnlist.ini, the malware scans for all available disk drives using GetLogicalDrives API and then compares the\ntype of them with 3 (DRIVE_FIXED) or 4 (DRIVE_REMOTE) using GetDriveTypeA API:\n\n\n-----\n\nFigure 68\n\nLet’s suppose that “C:\\” is the first drive found by the process. The file will enumerate all files and directories\nfrom the “C:\\” drive and the directories name will be saved as dn (where n=1,2,3, …) and the files name will\nbe stored as fn (where n=1,2,3,…), together with filecount (total number of files) and dircount (total number\nof directories). All information described will be stored in a new file called\n“C:\\Windows\\SysWOW64\\enumfs.ini”:\n\n\n-----\n\nFigure 69\n\nThe operation applied to “C:\\” drive is recursive and it’s applied to each directory (all information will be\nappended to enumfs.ini). The following information is added/modified in dnlist.ini:\n\n[EnumTime]\nDateTime = scan date\n\n[ScanList]\nScanAll = False\n\nThe enumfs.ini file will be transferred to the C2 server via a GET request as before (compressed +\nencoded). The filename parameter has the following form: “FileList-<month><day>-<hour><minute>\n<second>.ini”:\n\n\n-----\n\nFigure 70\nThe server response is expected to contain “Success:”. The attacker is interested in the following types of\nfiles: .doc, .docx, .xls, .xlsx, .txt, .rtf, .pdf (Types parameter from dnlist.ini file). The malicious process tries to\nopen uenumfs.ini which doesn’t exist at this moment, and then enumerates the files found in\n“C:\\User<Username>\\AppData\\Local\\Temp\\ntvba00.tmp\\”. This specific directory will be created by Thread2\nand will contain all files which have been selected to be exfiltrated to the C2 server:\n\nFigure 71\nNow the process contacts the C2 server again with the parameter “action=getdata”. It expects one of the\nfollowing responses: “A2C9AD2F:UNINSTALL”, “A2C9AD2F:UPDATE”, “A2C9AD2F:RESET” or\n“A2C9AD2F:UPLOAD” (note that “A2C9AD2F” is the volume serial number extracted a while ago):\n\nFigure 72\nCase 1: (UNINSTALL)\n\nThe following registry keys are deleted using RegDeleteKeyA API:\n“HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\FastUserSwitchingCompatibility\\Enum”,\n“HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\FastUserSwitchingCompatibility\\Parameters”,\n“HKEY LOCAL MACHINE\\SYSTEM\\CurrentControlSet\\Services\\FastUserSwitchingCompatibility\\Security”\n\n\n-----\n\nand HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\FastUserSwitchingCompatibility .\nAlso the process deletes enumfs.ini, dnlist.ini, “C:\\WINDOWS\\system32\\udidx.ini”, uenumfs.ini and stat_t.ini.\nOne such call is displayed below:\n\nFigure 73\nThe C2 server is informed that the operation is complete by performing a GET request with\n“action=updated” parameter:\n\nFigure 74\nCase 2: (UPDATE)\n\nSame registry keys and files are deleted as described above. Moreover, there is a GET request to the\nCommand and Control server using “action=datasize” parameter and the HTTP response is supposed to\ninclude “Success:” if everything works smoothly:\n\nFigure 75\nThe malware is trying to download a file named updata.exe from the C2 server (this file not available for\nanalysis, as the C2 server was down at the time of the analysis):\n\nFigure 76\n\n\n-----\n\nThe magic bytes of the downloaded file are compared to MZ (the format for executable, DLL files in\nWindows) and also it’s looking for “PE” string at a specific offset as well. The downloaded file is saved as\n“C:\\Windows\\install.exe” and run by the malicious process:\n\nFigure 77\n\nThe same request as in Figure 74 is performed once more in order to keep the server in the loop for every\nnew step.\n\nCase 3: (RESET)\n\nThe following files are deleted: enumfs.ini, dnlist.ini, “C:\\WINDOWS\\system32\\udidx.ini”, uenumfs.ini and\nstat_t.ini. Same request displayed in Figure 74 is used to contact the C2 server (this step is done in every\ncase).\n\nCase 4: (UPLOAD)\n\nThis case is identical to Case 2 (UPDATE) with the difference that no files/registry keys are deleted.\n\nAfter the execution flow passes all cases, the process sleeps for 60 seconds and then it goes back in the\nloop.\n\n**Thread2 activity**\n\nRegisterClassA function is used to register a window class for use in CreateWindow/CreateWindowEx calls,\nit creates a windows using CreateWindowExA (windows class name is “NTMainWndClass”, 0x80000000 –\nWS_POPUP style). Also, the window procedure used in RegisterClassA API call (sub_10004535) is called 5\ntimes as follows (one for each type of message): 0x81 (WM_NCCREATE), 0x83 (WM_NCCREATE), 0x01\n(WM_CREATE), 0x05 (WM_SIZE) and 0x03 (WM_SIZE). We should also mention the following calls:\n\n\n-----\n\nShowWindow (Sets the specified window s show state), UpdateWindow (it sends a WM_PAINT message to\nthe window), GetMessage (gets a message from the calling thread’s message queue) and\nTranslateMessage (translates messages into character messages):\n\nFigure 78\n\nThe malware is interested in WM_DEVICECHANGE (0x219) messages with a parameter of\nDBT_DEVICEARRIVAL (0x8000) which means that for example a new USB drive has been plugged in or a\nnetwork shared folder is mounted on the system:\n\n\n-----\n\nFigure 79\n“USearch” and “UTypeLimit” values parsed from dnlist.ini are expected to be set to “True”, also “UAuto”\nvalue is “False” in dnlist.ini (this could indicate if the exfiltration of the targeted files should be automatically\nor not). The attacker is also interested in “Types” parameter (the targeted extensions) and we’ll see why in a\nbit. The idea is to scan each and every device inserted and also the network shares mounted on the host\nand create a “file system” structure in uenumfs.ini file (as it did in Thread1):\n\nFigure 80\n\nAs in the first case, this search will apply for every directory found on the drive, recursively. The process\ncreates a “C:\\Users\\<Username>\\AppData\\Local\\Temp\\ntvba00.tmp\\” directory and its attribute is set to\nhidden. The following file is also created: “C:\\Windows\\SysWOW64\\uenumfs.ini” (the content of it will be\nsimilar to enumfs.ini):\n\nFigure 81\nFor each file found on the USB drive/network share, the process compares it’s extension with the list\nmentioned before: .doc, .docx, .xls, .xlsx, .txt, .rtf, .pdf:\n\nFigure 82\nLet’s suppose that “C:\\eula.1028.txt” (for the sake of simplicity) is a targeted file. The malware calculates a\nhash (MD5) of a combination between the filename and last modified timestamp (please note the initialize\nvariables which correspond to MD5 algorithm):\n\n\n-----\n\nFigure 83\n\nFigure 84\n\nAfter the function is finished the following result will represent the hash (unique identifier) corresponding to\neula.1028.txt file:\n\nFigure 85\n\nNow “C:\\eula.1028.txt” is copied to “C:\\Users\\<Username>\\AppData\\Local\\Temp\\ntvba00.tmp\\U2007-11-0712-00-5f7a78e7927532ba2a930ec8d47e252a.txt” (hidden file) – 2007 (year), 11 (month), 07 (day), 12\n(hour), 00 (minute), 5f7a78e7927532ba2a930ec8d47e252a is the hash computed above (all values\ncorrespond to last modified timestamp):\n\nFigure 86\nThe process creates “C:\\Windows\\SysWOW64\\udidx.ini” file and will add all hashes computed as explained\nbefore:\n\nFigure 87\nLast modified timestamp of the new file is set as the value extracted from the initial file:\n\n\n-----\n\nFigure 88\n\nAn example of udidx.ini file after copying all document-related files is shown in the figure below:\n\nFigure 89\n\nFinally the file is using DefWindowProcA API to ensure that window messages the application does not\nprocess have a default processing function (WM_DEVICECHANGE – 0x219, DBT_DEVICEARRIVAL –\n0x8000):\n\nFigure 90\nReferences\n\nKaspersky report: https://media.kasperskycontenthub.com/wpcontent/uploads/sites/43/2018/03/08080841/kaspersky-the-net-traveler-part1-final.pdf\n\n\n-----\n\nVirusTotal link:\nhttps://www.virustotal.com/gui/file/feca8db35c0c0a901556eff447c38614d14a7140496963df2e613b206527b\n338/detection\n\nVirusTotal link:\nhttps://www.virustotal.com/gui/file/ed6ad64dad85fe11f3cc786c8de1f5b239115b94e30420860f02e820ffc539\n24/detection\n\n[MSDN: https://docs.microsoft.com/en-us/windows/win32/api/](https://docs.microsoft.com/en-us/windows/win32/api/)\n\nFireEye: [Advanced Persistent Threat Groups (APT Groups)](https://www.fireeye.com/current-threats/apt-groups.html)\n\n[DarkReading: Chinese Cyberspies Pivot To Russia In Wake Of … (darkreading.com)](https://www.darkreading.com/endpoint/chinese-cyberspies-pivot-to-russia-in-wake-of-obama-xi-pact/d/d-id/1324242)\n\nINDICATORS OF COMPROMISE\n\nC2 domain: vipmailru[.]com\n\nSHA256: FECA8DB35C0C0A901556EFF447C38614D14A7140496963DF2E613B206527B338\n\nSHA256: ED6AD64DAD85FE11F3CC786C8DE1F5B239115B94E30420860F02E820FFC53924\n\nMutexes: “NetTravler Is Running!”, ” INSTALL SERVICES NOW!”\n\nFile names on disk:\n\n%System%\\config_t.dat\n%windir%\\system32\\enumfs.ini\n%windir%\\system32\\dnlist.ini\n%windir%\\system32\\udidx.ini\n%windir%\\system32\\uenumfs.ini\n%windir%\\system32\\stat_t.ini\n%windir%\\system32\\system_t.dll\n%windir%\\install.exe\n%TEMP%\\ntvba00.tmp\\\ntemp.bat\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-11-27 - Dissecting APT21 samples using a step-by-step approach.pdf"
    ],
    "report_names": [
        "2020-11-27 - Dissecting APT21 samples using a step-by-step approach.pdf"
    ],
    "threat_actors": [
        {
            "id": "808d8d52-ca06-4a5f-a2c1-e7b1ce986680",
            "created_at": "2022-10-25T16:07:23.899157Z",
            "updated_at": "2025-03-27T02:02:10.019417Z",
            "deleted_at": null,
            "main_name": "NetTraveler",
            "aliases": [
                "APT 21",
                "Hammer Panda",
                "NetTraveler",
                "TEMP.Zhenbao"
            ],
            "source_name": "ETDA:NetTraveler",
            "tools": [
                "Agent.dhwf",
                "Destroy RAT",
                "DestroyRAT",
                "Kaba",
                "Korplug",
                "NetTraveler",
                "Netfile",
                "PlugX",
                "RedDelta",
                "Sogu",
                "TIGERPLUG",
                "TVT",
                "Thoper",
                "TravNet",
                "Xamtrav"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "254f2fab-5834-4d90-9205-d80e63d6d867",
            "created_at": "2023-01-06T13:46:38.31544Z",
            "updated_at": "2025-03-27T02:00:02.802896Z",
            "deleted_at": null,
            "main_name": "APT21",
            "aliases": [
                "HAMMER PANDA",
                "TEMP.Zhenbao",
                "NetTraveler"
            ],
            "source_name": "MISPGALAXY:APT21",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535761,
    "ts_updated_at": 1743041370,
    "ts_creation_date": 1653692628,
    "ts_modification_date": 1653692628,
    "files": {
        "pdf": "https://archive.orkl.eu/c586e990a738f00ec6fac744b3d823df9d4d7aaf.pdf",
        "text": "https://archive.orkl.eu/c586e990a738f00ec6fac744b3d823df9d4d7aaf.txt",
        "img": "https://archive.orkl.eu/c586e990a738f00ec6fac744b3d823df9d4d7aaf.jpg"
    }
}