{
    "id": "1fa55a4d-55cf-4e40-ab3b-b016c7c0f61e",
    "created_at": "2023-01-12T15:05:27.893595Z",
    "updated_at": "2025-03-27T02:05:56.846356Z",
    "deleted_at": null,
    "sha1_hash": "f91ac7a25fe66816a0600b8755e37d6c42be4b1a",
    "title": "2020-05-05 - Awaiting the Inevitable Return of Emotet",
    "authors": "",
    "file_creation_date": "2022-05-28T04:51:19Z",
    "file_modification_date": "2022-05-28T04:51:19Z",
    "file_size": 1457283,
    "plain_text": "# Awaiting the Inevitable Return of Emotet\n\n**[hornetsecurity.com/en/security-information/awaiting-the-inevitable-return-of-emotet/](https://www.hornetsecurity.com/en/security-information/awaiting-the-inevitable-return-of-emotet/)**\n\nSecurity Lab May 5, 2020\n\n## Summary\n\nEmotet is probably the most prolific of the recent malware distribution operations. They often\nchange their malware to ensure it is not detected by any anti-virus software. Even though the\nEmotet botnet is on “spam break” recent changes in a component of the malware has\nprompted Hornetsecurity’s Security Lab to take a look at the latest version of Emotet in order\nto be prepared for its next steps. Emotet has added new code obfuscation techniques. But\nthe Security Lab explains how it can still be analyzed.\n\nThe updates to Emotet’s loader do not impact Hornetsecurity’s filters as the Emotet loader is\nnever send directly attached to an email. However, the presented analysis and downloadable\nGhidra scripts can help other researchers to jump start their Emotet reverse engineering\ndespite the added obfuscation.\n\n## Background\n\nThe malware now commonly known as Emotet was first observed in 2014. It was a banking\ntrojan stealing banking details and banking login credentials from victims. But it pivoted to a\nmalware-as-a-service (MaaS) operation providing malware distribution services to other\n\n\n-----\n\ncybercriminals.\n\n### Emotet Infection Chain\n\nAt least the initial portion of the Emotet infection chain and its used tactics and techniques as\ndefined by the MITRE ATT&CK framework are outlined in the following flow diagram:\n\n\n-----\n\n-----\n\nOf particular interest is that Emotet steals emails from victims and uses them as templates\nfor new malspam. It uses what is known as email thread hijacking where it replies to old\nemail threads with one of its malicious emails. Victims are much more likely to open emails\nfrom known correspondents and even more likely when that email is received in the context\nof an existing email conversation thread. As a result Emotet distribution campaigns have\nbeen very successful. These kind of attacks are one of the main reason why security leaders\nneed to invest into security awareness training to mitigate IT security risks through people.\n\nEmotet is so dangerous because in addition to its own modules to steal victims emails and\nmisuse their computers as C2 and spam servers it delivers other malware, such as TrickBot,\nwhich ultimately leads to a Ryuk ransomware infection. So even if a victim cleans the Emotet\ninfection they may already have additional malware running on their system(s) that are not\nthe initial Emotet infection that they cleaned.\n\nWhen victims become infected with Emotet they become part of the Emotet botnet.\n\n### Botnet\n\nThe Emotet botnet is split into separate botnets. Researchers called them Epoch 1 and 2\nbecause they received payload updates at different times. Each Epoch has its own unique\nRSA key used for its C2 communication. On 2019-09-17 a portion of the Epoch 1 botnet was\nseparated into the Epoch 3 botnet.\n\nEach bot connects to C2 servers of its Epoch. If a victim is infected by an Emotet document\nbelonging to Epoch 1, the document will download the Emotet loader from the Epoch 1\ninfrastructure and subsequently become part of Epoch 1.\n\nThe current structure of the Emotet botnet’s Tier 1 C2 servers is as follows:\n\n\n-----\n\nChanges are deployed to the E2 botnet first. It is possible that this is done as a test to ensure\nthat in case of introduced breaking changes only one part of the total botnet is lost.\n\n### (Recent) History\n\nWhile we could dig deep into the entangled history of Emotet, its origins and shared code\nwith Feodo, or its relations to Cridex and Dridex, we rather focus on the more recent history.\n\nAs hopefully everyone knows that currently (at the time of writing) the Emotet botnet does\nnot send spam. The botnet often has these breaks. But it often comes back from such a\nbreak with updates rendering it more dangerously as before. A timeline of recent “spam\nbreaks” is as follows:\n\n\n-----\n\nReturning 2018-10-31 Emotet delivered a new Email Stealer Module. Returning 2019-09-16\nEpoch 3 was split from Epoch 1. In preparation of this publication on 2020-04-29 TrickBot (a\nnotorious malware often distributed via Emotet) has been observed dropping the Emotet\nloader. Speculations are that due to the long absence in Emotet malspam, which is used to\nseed the botnet with new bots, and current infections being constantly cleaned, the number\nof Emotet bots may have shrunk to a critical low number, so they are seeded by the\noperators behind the TickBot malware in a quid-pro-quo for Emotet’s TrickBot distribution\nefforts. But these are only speculations and nothing clear is known at this time.\n\nWhat is known is that now with changes to the Emotet loader being dropped from Epoch 2\nsince 2020-04-20 the questions are when and with what new tricks will Emotet return this\ntime. Hence, Hornetsecurity’s Security Lab has analyzed the recent changes in the Emotet\nmalware.\n\n## Technical Analysis\n\nDue to a lack of current Emotet spam we can not analyze any malicious emails or\ndocuments. We therefore present an analysis of the Emotet loader binary.\n\n### Emotet Loader Binary\n\nWe analyzed both the “old” version that was dropped from Epoch 1 on 2020-02-20 (which\nhas not received any notable changes since the 2020-02-05 update), and the “new” version\ndropped from Epoch 2 on 2020-02-20 onwards.\n\n**Packer**\n\nThe metadata of the new version contains fragments of news article text. The File\nDescription, Internal Name, Original Filename, Product Name, and Copyright texts are filled\nwith fragments of news articles:\n\n\n-----\n\nThis is another indicator that Emotet uses the same packer as Trickbot, which has been seen\nwith news article text in its metadata shortly before Emotet featured news article texts.\nResearchers have duped this crypter “Exes’r’rus” [JRoosen].\n\nBecause malware packers frequently change, this change is not unusual. It has been seen\naround 2020-02-14, but The Emotet loader payload can still be extracted via generic (and\nautomated) unpacking mechanisms.\n\n**Obfuscation**\n\nEmotet added more obfuscation. The most notable change is control flow flattening and junk\ncode. This makes the binary more annoying to analyze as well as allow for simpler\npolymorphic changes. Most of the obfuscation was already added in the 2020-02-05 change.\n\nControl Flow Flattening\n\nControl flow flattening is an obfuscation technique. It splits a code sequence into multiple\nparts and rearranges then in a way that is more difficult to follow. A common way is to place\nthe code parts into a loop and on each loop run executing different code parts in the loop\nbody determined by a state variable.\n\nThe code sequence:\n```\nCODE_1;\nCODE_2;\nCODE_3;\nreturn;\n\n```\nis turned into:\n\n\n-----\n\n```\nstate STATE_1\ndo\n{\n     if ( state > MAGIC_VALUE_1 )\n     {\n          if ( state == STATE_2 )\n          {\n              CODE_2;\n              state = STATE_3;\n          }\n          if ( state == STATE_1 )\n          {\n              CODE_1;\n              state = STATE_2;\n          }\n     }\n     else if ( state == JUNK_STATE_1 )\n     {\n          JUNK_CODE_1;\n          state = STATE_4\n     }\n     else\n     {\n          if ( state == STATE_3 )\n          {\n              JUNK_CODE_2;\n              state = JUNK_STATE_1;\n          }\n          if ( state == STATE_4 )\n          {\n              CODE_3;\n              return;\n          }\n     }\n} while(1);\n\n```\nWhile semantically identical the second code is harder to follow.\n\nIn Emotet this looks like:\n\n\n-----\n\nEmotet uses this to move code blocks around, as can be seen in this example, where the\ncode block setting up the headers of the HTTP C2 communication is near the beginning of\nthe function in one binary and near the end of the function in another binary:\n\n\n-----\n\nJunk Code\n\nAnother technique Emotet uses is called junk code. Here useless code that does not change\nthe semantics of a program is added.\n\nThe code sequence:\n```\nunsigned int function(unsigned int n) \n{\n  if (n == 0) \n    return 1; \n  return n * function(n - 1); \n}\n\n```\nis turned into:\n```\nunsigned int function(unsigned int n) \n{\n  unsigned int a = 1234;\n  unsigned int b = 4321;\n  a = n + b;\n  b = n + a;\n  if (n == 0 && a > 10 && b > 20)\n  {\n    b = n - a;\n    n = b;\n    return 1;\n  }\n  a = b + 42;\n  return n * function(n - 1); \n}\n\n```\n\n-----\n\nHere the calculations on the variables `a and` `b are irrelevant code. They do not influence`\nthe result of the code at all. However, an analyst does not know which calculations are\nimportant and which are not. Hence, while semantically identical the second code is harder\nto understand.\n\nLuckily modern analysis software is able to simplify artificially complicated code. So a\ncomplex looking function:\n\nis automatically reduced to a return of a static value:\n\nThis is used in the next obfuscation method.\n\nOpaque Predicates\n\nOpaque predicates are branch conditions for which the outcome is already known, but which\nstill need to be evaluated at runtime. An example would be a code that gets the current time\ntwice. Because time never goes backwards the first value will not be greater than the\n\n\n-----\n\nsecond:\n```\ntime_t a = time(NULL);\ntime_t b = time(NULL);\nif ( a <= b )\n  CODE;\nelse\n  JUNK_CODE;\n\n```\nWhile to a human this is logical, a machine would still need to evaluate what values `a and`\n```\nb have to determine whether to take the jump or not.\n\n```\nEmotet uses functions with a static return value – see previous junk code example above –\nand uses their return values as a branch condition:\n\nThe branches used for control flow flattening also use opaque predicates, as the `state`\nvariable changes predictable but must be evaluated at runtime.\n\n**Dynamic Library and Function Resolution**\n\nAll library calls are dynamically resolved by hash. Previous versions stored the resolved\nfunctions. Now they are just-in-time resolved before every call.\n\nFor each library call, first the library is obtained ( emotet_get_lib() ). Then the address of\nthe desired function is obtained ( emotet_get_func ):\n\nLibraries are resolved via the `InLoadOrderModuleList reachable from the Process`\nEnvironment Block (PEB) ( FS:[0x30] ):\n\n\n-----\n\nThen the `DllBaseName for every loaded module is hashed and compared against the`\ncurrent queried hash. If the hash matches the `DllBase is returned. The`\n```\nGET_LIB_XOR_VALUE varies for each binary. This means that library hashes change from\n\n```\nsample to sample and can not be pre-calculated. They must be calculated for each sample\nindividually.\n\nAddresses of functions are obtained via manually traversal of in this case the export directory\ndata structure. Each exported function name of the previously resolved DLL’s image is\niterated over and hashed. If the hash matches the function’s address is returned:\n\n\n-----\n\nEmotet still uses the same hashing algorithm as previous versions:\n\n\n-----\n\nThe `emotet_get_func() function uses a variation without mapping the uppercase`\ncharacters to lowercase, i.e., its hash is case-sensitive, and ingesting a `char string instead`\nof a `wchar string. The` `emotet_hash() function is also heavily laced with junk code,`\nwhich luckily the decompiler already simplified and/or discarded.\n\nUsing the Ghidra analysis scripts `emotet_lib_imports.py and`\n```\nemotet_func_imports.py the called library and function names can be reconstructed from\n\n```\ntheir hashes:\n\nThe following libraries that are usually not loaded into a process by default are loaded via\n```\nLoadLibraryW :\nshell32.dll\nuserenv.dll\nurlmon.dll\nwininet.dll\nwtsapi32.dll\nadvapi32.dll\ncrypt32.dll\nshlwapi.dll\n\n```\n\n-----\n\nHandles to the libraries are stored to allocated memory. But never used. We have found\nother functions and code paths that are never used. These is likely leftover code that was not\nremoved during code updates.\n\n**XOR Obfuscation**\n\nStrings and the RSA key are (as in previous versions) XOR obfuscated. The use the\nfollowing structure:\n```\ntypedef emotet_xor_data_t {\n  uint32_t xor_key;\n  uint32_t len;\n  uint32_t data[];\n} emotet_xor_data_t;\n\n```\nThey are decrypted by first XOR’ing `len with` `xor_key . Then XOR’ing decoded and to 4-`\nbyte boundaries aligned `len bytes of` `data with` `xor_key :`\n\n\n-----\n\nThe XOR key again changes from binary to binary. But still the decoding process can be\nautomated, e.g. the `emotet_string_decode.py script can decode used strings:`\n\n\n-----\n\nThey are also just-in-time decrypted on demand to a new memory allocation. The memory\nallocation holding the decrypted string is deleted again after use for every use of the string.\n\n**Static Analysis Tutorial**\n\nWith the basics of the new obfuscation techniques covered we quickly outline how Emotet\ncan still be analyzed.\n\n1. Unpack your Emotet sample. E.g., using the free open source community developed\n\nCAPE sandbox [CAPE].\n2. Import into Ghidra [GHIDRA].\n3. Run Auto Analysis.\n4. Run `emotet_lib_imports.py with` `currentAddress in 2nd function called in`\n```\n   entry function (this is what we refer to as the emotet_get_lib function).\n\n```\n5. Run `emotet_func_imports.py (selecting` `func_names.txt ) with`\n```\n   currentAddress in 3rd function called in entry function (this is what we refer to as\n\n```\nthe `emotet_get_func function).`\n6. Run `emotet_string_decode.py with` `currentAddress in` `emo_*_LoadLibraryW`\n\nfunction.\n7. Run `emotet_string_decode.py with` `currentAddress in 1st function called in`\n```\n   emo_*_LoadLibraryW function.\n\n```\nThen you have:\n\nComments for library and function resolution.\nTwo enum types `emotet_{lib,func}_hash with enums for the library and function`\nhashes, which you can optionally apply to the `emotet_get_{lib,func}` functions.\nEmotet strings decrypted and set as comments, labels as well as searchable\nbookmarks.\n\n\n-----\n\nC2 communication is found by searching for usage of the `HttpSendRequestW function. The`\ntype of request and request headers can be found by backtracking via the first parameter\n( hRequest ) to `HttpSendRequestW . Alternatively usage of the` `HttpOpenRequestW`\nfunction, the `InternetConnect` function, the `POST string, or the` `Referer:`\n```\nhttp://%s/%s ... string will yield the relevant code.\n\n```\nC2 IP storage can be found by searching for the `%u.%u.%u.%u string. These octets are`\nfilled from data in a allocation we named `emotet_c2_data . This allocation is filled from a`\ndata location we named `emotet_c2_list . If you run` `emotet_ip_decode.py with`\n\n`currentAddress set to the address of` `emotet_c2_list` the C2 list is decoded and\nannotated as a comment.\n\nThe C2 HTTP request template looks like:\n```\nPOST\nReferer: http://%s/%s\nContent-Type: multipart/form-data; boundary=%s\n--%S\nContent-Disposition: form-data; name=\"%s\"; filename=\"%s\"\nContent-Type: application/octet-stream\n\n```\nRSA key is found by searching the source of the 3rd parameter ( pbEncoded ) to the\n```\nCryptDecodeObjectEx function. It is XOR encoded like the strings. You can run\nemotet_data_decode.py with currentAddress on the data location passed to the\n\n```\nfunction that returns the pointer that is then passed as the 3rd parameter to the\n```\nCryptDecodeObjectEx function. You can use openssl asn1parse -inform DER -in\nemotet_key.bin to check if the decoded emotet_key_bin is valid. The key must be the\n\n```\nexact length without any appended bytes beyond the ASN1 DER sequence stream.\n\nSearch for functions using the `OpenSCManagerW function. One function will contain an`\nassignment to a data location. Emotet uses `OpenSCManagerW to check whether it has`\nadmin rights or not. This is where what we call the `is_admin flag is set. Use “Auto Create`\nStructure” on the data reference and name it `emotet_data and name the field assigned the`\nvalue `1` `is_admin .`\n\nSearch for functions using the string `%s\\%s.exe . This is where the executable path is`\nconstructed. In its vicinity the `emotet_data data location is accessed. Determine by their`\nusage as parameters to the `_snwprintf function which of the two fields in the`\n```\nemotet_data structure is the exe_path and which is the exe_name .\n\n```\nThen use “References -> Find use of emotet_data_t.exe_name” to find out how the\n```\nexe_name is generated. Do the same for the exe_path . The exe_name will also be used\n\n```\nto generate the service name. Relevant code is found by searching for `CreateServiceW .`\nPersistence via run keys is found via `RegCreateKeyExW and/or the`\n```\nSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run string.\n\n```\n\n-----\n\nSearching for usage of the `%s:Zone.Identifier string finds where Emotet deletes its`\nZone.Identifier ADS, which on Windows is used to mark files downloaded from external sites\nas potentially unsafe.\n\nAs an interesting side note older new versions contained code removing old Emotet binaries\nwhich names were generated from word lists:\n\nThis functionality has been removed from the latest version, indicating that the migration to\nthe new version has been completed for Epoch 2 and there is no need to delete old binaries\nanymore:\n\n\n-----\n\n(Either that or the function has moved and has not been picked up by our string deobfuscator\nscript.)\n\nThe following video demonstrates how our scripts can be used to jump start your own\nanalysis of the Emotet loader:\n\n**Download our scripts on** **[Github.](https://github.com/hornetsecurity/sl-research/tree/master/20200504-awaiting-the-inevitable-return-of-emotet)**\n\n### Tier 1 C2 geolocation\n\nEmotet’s tier 1 C2 proxies and servers are geolocated all over the world:\n\n(C2 IP list as observed 2020-04-20.)\n\n## Conclusion and Remediation\n\n\n-----\n\nTo protect against Emotet the US CERT recommends to implement filters at the email\ngateway to filter out emails with known malspam indicators” [USCERT].\n\nHornetsecurity’s [Email Spam Filtering with the highest detection rates on the market are not](https://www.hornetsecurity.com/en/services/spam-filter/)\nimpacted by the updates to the Emotet loader (as the loader is never send directly via\nemails) and thus will (as in the past) block all Emotet malspam indicators, such as macro\ndocuments used for infection, but also known Emotet download URLs. Hornetsecurity’s\n[Advanced Threat Protection extends this protection by also detecting yet unknown malicious](https://www.hornetsecurity.com/en/services/advanced-threat-protection/)\nlinks by dynamically downloaded and executing the potentially malicious content in a\nmonitored and sandboxed environment. Meaning that even in the event the Emotet loader\nchanges is accompanied in a change in delivery tactics, Hornetsecurity is prepared.\n\nBeyond blocking the incoming Emotet emails defenders can use public available information\nby the Cryptolaemus team, a voluntary group of IT security people banding together to fight\nEmotet. They provide new information daily via their website [CryptolaemusWeb]. There you\ncan obtain the latest C2 IP list for finding and/or blocking C2 traffic. For real-time updates you\ncan follow their Twitter account [CryptolaemusTwitter].\n\nWe acknowledge that our presented analysis only scratches the surface of the Emotet\nmalware complex, but when Emotet returns so will we, with updated analyses of new\nmalicious documents and/or any other new developments.\n\n## References\n\n[USCERT] [https://www.us-cert.gov/ncas/alerts/TA18-201A](https://www.us-cert.gov/ncas/alerts/TA18-201A)\n\n[[JRoosen] https://twitter.com/JRoosen/status/1228215329022603267](https://twitter.com/JRoosen/status/1228215329022603267)\n\n[CERTPL] [https://www.cert.pl/en/news/single/whats-up-emotet/](https://www.cert.pl/en/news/single/whats-up-emotet/)\n\n[CAPE] [https://capesandbox.com/](https://capesandbox.com/)\n\n[GHIDRA] [https://ghidra-sre.org/](https://ghidra-sre.org/)\n\n[Cryptolaemus] [https://paste.cryptolaemus.com/](https://paste.cryptolaemus.com/)\n\n[CryptolaemusTwitter] [https://twitter.com/Cryptolaemus1](https://twitter.com/Cryptolaemus1)\n\n## Samples Used\n\n### Hashes\n\nSHA256 Description\n\n`cc96711da9ef7b63d5f1749d8866b0149f84506f9d53d79de018dac92e9443a0` Epoch 1\nsample\n(“old”\nversion)\n2020-0420\n\n\n-----\n\nSHA256 Description\n\n`4c3acc885006faebe59e0bfdd452499056d8fcc9e6a810d7ff93762ce1a061ad` Epoch 1\nsample\nunpacked\npayload\n2020-0420\n\n`4250a3ab9044b4a3a5f8319e712306bb06df61b1dee8b608505c026bacba4aa1` Epoch 2\nsample\n(“new”\nversion)\n2020-0420\n\n`14f8463a86bbae338925fbbcb709953ae7f1bffdb065fee540b6fa88fbbce70e` Epoch 2\nsample\nunpacked\npayload\n2020-0420\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-05-05 - Awaiting the Inevitable Return of Emotet.pdf"
    ],
    "report_names": [
        "2020-05-05 - Awaiting the Inevitable Return of Emotet.pdf"
    ],
    "threat_actors": [
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535927,
    "ts_updated_at": 1743041156,
    "ts_creation_date": 1653713479,
    "ts_modification_date": 1653713479,
    "files": {
        "pdf": "https://archive.orkl.eu/f91ac7a25fe66816a0600b8755e37d6c42be4b1a.pdf",
        "text": "https://archive.orkl.eu/f91ac7a25fe66816a0600b8755e37d6c42be4b1a.txt",
        "img": "https://archive.orkl.eu/f91ac7a25fe66816a0600b8755e37d6c42be4b1a.jpg"
    }
}