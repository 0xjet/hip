{
    "id": "a0859c13-384a-4a0d-90d3-05fce716829f",
    "created_at": "2023-01-12T15:03:53.881151Z",
    "updated_at": "2025-03-27T02:05:52.054098Z",
    "deleted_at": null,
    "sha1_hash": "47ef880682b10082551074a17ebc111da9d60a4d",
    "title": "2021-11-12 - AgentTesla dropped via NSIS installer",
    "authors": "",
    "file_creation_date": "2022-05-27T23:16:49Z",
    "file_modification_date": "2022-05-27T23:16:49Z",
    "file_size": 1365969,
    "plain_text": "# AgentTesla dropped via NSIS installer\n\n**[l1v1ngc0d3.wordpress.com/2021/11/12/agenttesla-dropped-via-nsis-installer/](http://l1v1ngc0d3.wordpress.com/2021/11/12/agenttesla-dropped-via-nsis-installer/)**\n\ndominik 12 Nov 2021\n\nLately one of our customers received a suspicious file which was blocked by our sandbox\nsolution but it was unclear if this was malicious and if so what malware it was so I did an analysis\nand want to share my results with you. The main goal of this article is to show how to extract the\nfinal payload.\n\nThe sample is now available on VT:\nce8a9bf908ce35bf0c034c61416109a44f015eabf058b12485450cd40af95fc3\n\n## NSIS installer\n\nIf we do some static analysis via DiE (Detect it Easy) we see that the file is of type NSIS installer.\nOne easy way to obtain the files is to just simply extract the files with 7-ZIP. Unfortunately I’m not\naware of any way to reverse the NSIS script (any hint welcome ;-)).\n\nAfter extracting the file we find a folder $PLUGINDIR as expected and another file with a random\nname and some bytes in it.\n\n## First dll – swfmwfkkeh.dll\n\nInside of the $PLUGINSDIR directory we find one file named swfmwfkkeh.dll (SHA1:\n56f3d68f10bde42216634f987b421feee696506e). Once again we open it up in DiE and find out\nthat its written in C/C++ and some exports which look a little strange.\n\nIn the imports there are some false flags but the VirtualProtect seems to be reasonable\n\n\n-----\n\nNow we open up the file in IDA Pro and take a look at the export functions\n\nWe assume that the NSIS installer will start the DLL and call the exported function „zznqqqjqi“ so\nwe start our analysis there. After setting up the stack the function intiliazes „var_14“ which then is\ncompared if its above 4722 (in fact the function does a „jump not below“ with the main\nfunctionality in the false tree).\n\nWe will start with the right block first because there you can see that the memory address at\n10009014 will receive RWX permissions and after that will be called. So we can assume that at\nthis location there must be some assembly code. Now lets take a look what happens in the left\nblock because this is where we land after the first comparison. At this point „var_14“ is still below\n4722. As you can see the variable (now in ecx) is used as a pointer in the marked area by\nutilizing „byte ptr loc_10009014[ecx]“. So it grabs the first bytes of what ever is at this address. If\n\n\n-----\n\nwe take a look what is there we see some „strange assembly code – this doesn t look as valid\nassembly code at all. If we look further down in the left block we see some xor, sub, add and mov\noperations so we can assume that this code will be modified.\n\nAfter all the byte manipulations are done the byte is written back to the address 10009014. This\ntime esi receives the pointer (mov esi, [ebp+var_14]).\n\nThen we jump back to the comparison if var_14 is already above 4722. If this is the case we\nchange the page permissions to RWX and execute the now modified code.\n\n## Let’s debug some code\n\nThe decryption routine is very very long and we don’t want to go into reversing this algorithm.\nBelow is a screenshot of the algorithm – hell no!\n\n\n-----\n\n-----\n\nSo lets open the file up in x64dbg and jump to user code but stop there. We want to start at the\nfunction „zznqqqjqi“. If we switch to text mode in IDA we can see the address. We have two\noptions to change the instruction pointer (EIP) to continue from this address. First we can rightclick on the EIP register and modify the value.\n\nOr we can jump to the address in the disassembly view (Ctrl + G) and then right-click „Set new\norigin here“.\n\n\n-----\n\nAfter that we can start debugging.\n\n\n-----\n\nWe also see as we did in IDA Pro the initialization of the pointer and the comparision with 1272\n(hex) = 4722 (dez). Here is on speciality about assembly. Instead of the jnb operation we saw in\nIDA Pro we see a jae (jump if above or equal). In fact the operations are interchangeable\nbecause both check if the ZERO flag is set.\n\nWe know from our static analysis that after the decryption loop we change the permission of the\npage so lets follow the jump and place a breakpoint at this point.\n\nNow we want to obverse how the code changes (without reversing the algorithm). Follow the\naddress 10009014 in disassembler to see the code.\n\n\n-----\n\n**Before decryption**\n\n**After decryption**\n\nAs you can see now the code changed fundamentally and it starts with a jmp to another offset in\nthe code. Jump back to the current instruction by double-clicking the EIP register.\n\nLets single step over the VirtualProtect and then jump into the decrypted code (F7).\n\nWe follow the jump and land at this address where we can see values being push/popped and\nthen moved into a local variable (ebp-28). These values are ASCII codes so we can convert them\nmanually or step over until we reach 0x10009849 where the string is terminated by a 0 (xor\neax,eax = 0; mov memory,ax).\n\n\n-----\n\nIf we follow the address ebp-28 we can see the string\n\nAfter that the next call will get us the Magic (4D 5A) of Kernel32.dll\n\nAfter that we see a lot of calls to the same function and what we suspect to be API hashes. So\nlets dive into this function and try to figure out what algorithm is used to hash the API function\nnames. For easier analysis I dumped the DLL again with Scylla and opened it up again in IDA\nPro.\n\n## API Hashing\n\nWe will go into the details of the function but what it mainly does is hashing the function names\n(exports) of the DLL and comparing it with the provided hash. If they match the function is found\nand a pointer to the function is stored.\n\nWe know that the function receives the address to the module base of kernel32.dll. The address\nis passed via the ECX register. Additionally the function receives the precomputed hash via the\nEDX register. The first steps in the program are to store the passed arguments into edi\nrespectively in var 4 Then the function goes over the memory region and reads in the PE\n\n\n-----\n\nstructure looking for the export directory. To better unterstand whats going on here and what\noffsets are used take a look at this (huge) diagram:\n[https://raw.githubusercontent.com/corkami/pics/master/binary/pe102/pe102.svg](https://raw.githubusercontent.com/corkami/pics/master/binary/pe102/pe102.svg)\n\nNow the function gets the first name from the export directory (edx+esi*4) and calls the function\nsub_100096B6. The function name (better: the address of the function name) is passed via the\nECX register.\n\n\n-----\n\nAnd here we have find the hashing algorithm. First the address of the function name is stored in\nESI. Then we move the constant 2326 (hex) into EDX register and jump down to loc_100096CF\nwhere we get the first char by utilizing „movsx edi, byte ptr [esi]“. Then the constant 2326h is\ncopied into EAX. With „test edi, edi“ the function checks if there are still characters in the function\nname left or if the string termination („0“) is reached.\n\n\n-----\n\n### Pseudocode of the hashing algorithm\n\nIf we remove some of the optimizations by the compiler and do the shr / shl operations inline\n(these operations can only be done on registers therefore the compiler had to assemble it this\nway) then we get a very simple code. Basically its just starting with a constant (I called iv for\nInitialization Vector) and then shifts right and left and adds the current char. This way we go over\nall the chars in the string until we reach the end of the string. To simplify things I use a fixed string\nof „GetTempPathW“. To account for the EDX register (which is 32 bytes long) we have to make\nsure that we stay inside this range and therefore have to do an AND operation with 0xFFFFFFFF.\n```\niv = 0x2326\nname = \"GetTempPathW\"\nhash = 0\nfor i in range(len(name)):\n  iv = (iv + (iv >> 1 | iv << 7) + ord(name[i])) & 0xFFFFFFFF\n  hash = iv \nprint(hex(hash))\n\n### Resolve the called API hashes\n\n```\n\n-----\n\nIf we jump over one of these function calls we see the pointer in the EAX being returned. So we\ncan jump over all the function call and make notes of the resolved API hashes. You could write a\nIDAPython script if you want but there are not many hashes so I decided to do it manually.\n\nFrom what we see we can expect some file operations.\n\nAfter all necessary APIs are resolved we can see that the malware does the same push/pop trick\nas before – so we do the same and run to the end and jump to the address in the dump\n\n\n-----\n\nThere we see a strange string „w66zlsqpnyue6“.\n\n## Reading and decrypting main payload\n\nLets continue debugging. And find out what this string is used for. Next we have a call to a\nmemory region and as you might have expected its an API call. We call GetTempPathW.\n\nWith the next call we are able to figure out what the previous strange string means. The string is\nappended to the result of GetTempPathW and therefore it must be a file. If you recall ebp-44 is\nthe string and ebp-480 contains the string of the temp folder.\n\nAfter the call the newly formed string is stored at ebp-480 and we can follow this memory in the\ndump and see the final result\n\n\n-----\n\nNext we have a call to CreateFileW. Remember that the parameters are pushed to the stack in\nreverse order. One interesting fact about this call is the value 80000000 which is a constant for\nGENERIC_READ which means that the file must already exist or we will get an error. At this\npoint we can assume that the NSIS installer will copy the file over to the temp directory. To\nproceed with our debugging we have to copy the file ourselves. You can find the file in the „root“\nfolder.\n\nIf the call succeeds EAX will contain the handle to the file. The result of the call is storend and\nchecked in the next line.\n\nIf this is successful the malware gets the size of the file with a call to GetFileSize\n\nThe same logic as above is used to check if the file size is not equal 0. Next we allocate virtual\nmemory with a call to VirtualAlloc and pass the size (stored at ebp-8) to the function. The\nallocated memory is stored in ebp-C.\n\n\n-----\n\nWe do another check if the function succeeded and continue with a call to read file. The\ndestination buffer is the just allocated memory region. In my case its 0x750000.\n\nAfter the file is read we can take a look at the memory region.\n\nThis does look like encrypted data but lets continue our analysis. After reading the file we close\nthe handle to the file and jump into another function at 10009A0E. Notice that the functions\nreceives two parameters. First the file size (ebp-8) and the allocated region of memory (ebp-C).\n\nIn the function we see a familiar code structure – it has great similarities with the first decryption\nloop. First there is a pointer initialized with zero stored as local variable at ebp-8. Then the\npointer is incremented by one and check against the argument at ebp+C which is the file size. If\nthe pointer value is lower than the size of data (jae) the encryption will continue otherwise we\njump to 10009C8B. After the jump is NOT taken we see that the value at ebp+8 (the data itself) is\nmoved into eax and then the pointer (counter) gets added.\n\n\n-----\n\nAs we did with the previous encryption loop we don’t want to dig into the algorithm and just see\nwhats happening. We know that this code will manipulate the read file so go to address\n10009C8B and set a breakpoint. After the decryption is complete we can see a MZ header in the\ndump.\n\nSo right-click on the address 750000 and follow in memory map. Then right-click the address\nagain and choose „Dump memory to file“. We want to stop our analysis of the initial sample here\nand continue with the dumped PE.\n\n## Analyzing the dumped PE\n\nWe once again start with some basic static analysis and open the file in DiE.\n\n\n-----\n\nImmediately we can see that the PE imports APIs to handle resources so lets check if there is\nsomething interesting.\n\nAnd wow … there is an unencrypted PE inside of the resource section. To dump this PE we will\nutilize Resource Hacker and dump the file via „Save Resource to a BIN file…“\n\n## Analyzing the dumped resource\n\nOnce again we open the dumped PE in DiE and see that its written in .NET and obfuscated.\n\n\n-----\n\nFrom this point on I just dropped this sample into the CAPE and got a hit on AgentTeslaV3 YARA\nsignatures.\n\nMission complete!\n\n## IoCs\n\n**NSIS Installer** ce8a9bf908ce35bf0c034c61416109a44f015eabf058b12485450cd40af95fc3\n\n**swfmwfkkeh.dll** 6d8bc73c6f2ef4ee700fc8bc4088f73a14dab355a2dd4e3e9aa3ddf52f7e946e\n\n\n**Encrypted**\n**resource**\n**(inside of NSIS**\n**data)**\n\n**w66zlsqpnyue6**\n\n\nc02ff5253bf3930f1ee14e088f50c827bf2209f3a7e9f00ed3994fd417d790b2\n\n\n**Dumped PE** 9a72e5859b5564cecff5d5a4a929e81595d68aca1972ea2cf0fcf71c518d2cb9\n\n**AgentTesla V3** 5459e87eb0a39243a35405866b2dca1d57c2c1ee02d24052635fcc48de5d397c\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-11-12 - AgentTesla dropped via NSIS installer.pdf"
    ],
    "report_names": [
        "2021-11-12 - AgentTesla dropped via NSIS installer.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535833,
    "ts_updated_at": 1743041152,
    "ts_creation_date": 1653693409,
    "ts_modification_date": 1653693409,
    "files": {
        "pdf": "https://archive.orkl.eu/47ef880682b10082551074a17ebc111da9d60a4d.pdf",
        "text": "https://archive.orkl.eu/47ef880682b10082551074a17ebc111da9d60a4d.txt",
        "img": "https://archive.orkl.eu/47ef880682b10082551074a17ebc111da9d60a4d.jpg"
    }
}