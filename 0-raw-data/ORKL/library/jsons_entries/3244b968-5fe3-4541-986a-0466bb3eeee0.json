{
    "id": "3244b968-5fe3-4541-986a-0466bb3eeee0",
    "created_at": "2023-01-12T15:00:20.009257Z",
    "updated_at": "2025-03-27T02:08:41.239165Z",
    "deleted_at": null,
    "sha1_hash": "d68c60f47c3960e61bc93a3072e32f3eccab9516",
    "title": "2015-10-17 - How to Write Simple but Sound Yara Rules – Part 2",
    "authors": "",
    "file_creation_date": "2022-05-28T18:30:00Z",
    "file_modification_date": "2022-05-28T18:30:00Z",
    "file_size": 230978,
    "plain_text": "# How to Write Simple but Sound Yara Rules – Part 2\n\n**[bsk-consulting.de/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/](https://www.bsk-consulting.de/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/)**\n\nOctober 17, 2015\n\n[Months ago I wrote a blog article on “How to write simple but sound Yara rules“. Since then](https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/)\nthe mentioned techniques and tools have improved. I’d like to give you a brief update on\ncertain Yara features that I frequently use and tools that I use to generate and test my rules.\n\n## Handle Very Specific Strings Differently\n\nIn the past I was glad to see very specific strings in samples and sometimes used these\nstrings as the only indicator for detection. E.g. whenever I’ve found a certain typo in the PE\nheader fields like “Micorsoft Corportation” I cheered and thought that this would make a great\nsignature. But – and I have to admit that now – this only makes a nice signature. Great\nsignatures require not only to match on a certain sample in the most condensed way but\naims to match on similar samples created by the same author or group.\n\nLook at the following rule:\n\n\n-----\n\nrule Enfal_Malware_Backdoor {\nmeta:\ndescription = \"Generic Rule to detect the Enfal Malware\"\nauthor = \"Florian Roth\"\ndate = \"2015/02/10\"\nsuper_rule = 1\nhash0 = \"6d484daba3927fc0744b1bbd7981a56ebef95790\"\nhash1 = \"d4071272cc1bf944e3867db299b3f5dce126f82b\"\nhash2 = \"6c7c8b804cc76e2c208c6e3b6453cb134d01fa41\"\nscore = 60\nstrings:\n$x1 = \"Micorsoft Corportation\" fullword wide\n$x2 = \"IM Monnitor Service\" fullword wide\n$a1 = \"imemonsvc.dll\" fullword wide\n$a2 = \"iphlpsvc.tmp\" fullword\n$a3 = \"{53A4988C-F91F-4054-9076-220AC5EC03F3}\" fullword\n$s1 = \"urlmon\" fullword\n$s2 = \"Registered trademarks and service marks are the property of their\" wide\n$s3 = \"XpsUnregisterServer\" fullword\n$s4 = \"XpsRegisterServer\" fullword\ncondition:\nuint16(0) == 0x5A4D and\n(\n( 1 of ($x*) ) or\n( 2 of ($a*) and all of ($s*) )\n)\n}\nWhat I do when I review the 20 strings that are generated by yarGen is that I try to\ncategorize the extracted strings in 3 different groups:\n\n**Very specific strings (one of them is sufficient for successful detection, e.g. IP**\naddresses, payload URLs, PDB paths, user profile directories)\n**Specific strings (strings that look good but may appear in goodware as well, e.g.**\n“wwwlib.dll”)\n**Other strings (even strings that appear in goodware; without random code from**\ncompressed or encrypted data; e.g. “ModuleStart”)\n\nThen I create a condition that defines:\n\nA Certain Magic Header (remove it in case of ASCII text like scripts or webshells)\n1 of the very specific strings OR\nsome of the specific strings combined with many (but not all) of the common strings\n\n\n-----\n\nHere is another example that does only have very specific strings (x) and common strings\n(s):\n\nrule Cobra_Trojan_Stage1 {\nmeta:\ndescription = \"Cobra Trojan - Stage 1\"\nauthor = \"Florian Roth\"\nreference = \"https://blog.gdatasoftware.com/blog/article/analysis-of-project-cobra.html\"\ndate = \"2015/02/18\"\nhash = \"a28164de29e51f154be12d163ce5818fceb69233\"\nstrings:\n$x1 = \"KmSvc.DLL\" fullword wide\n$x2 = \"SVCHostServiceDll_W2K3.dll\" fullword ascii\n$s1 = \"Microsoft Corporation. All rights reserved.\" fullword wide\n$s2 = \"srservice\" fullword wide\n$s3 = \"Key Management Service\" fullword wide\n$s4 = \"msimghlp.dll\" fullword wide\n$s5 = \"_ServiceCtrlHandler@16\" fullword ascii\n$s6 = \"ModuleStart\" fullword ascii\n$s7 = \"ModuleStop\" fullword ascii\n$s8 = \"5.2.3790.3959 (srv03.sp2.070216-1710)\" fullword wide\ncondition:\nuint16(0) == 0x5A4D and filesize < 50000 and 1 of ($x*) and 6 of ($s*)\n}\nIf you can’t create a rule that is sufficiently specific, I recommend the following methods to\nrestrict the rule:\n\n**Magic Header (use it as first element in condition – see performance guidelines, e.g.**\n“uint16(0) == 0x5A4D”)\n**File Size (malware that mimics valid system files, drivers or legitimate software often**\ndiffers significantly in size; try to find the valid files online and set a size value in your\nrule, e.g. “filesize > 200KB and filesize < 600KB\")\n**String Location (see the “Location is Everything” section)**\n**Exclude strings that occur in false positives (e.g. $fp1 = “McAfeeSig”)**\n\n## Location is Everything\n\nOne of the most underestimated features of Yara is the possibility to define a range in which\nstrings occur in order to match. I used this technique to create a rule that detect metasploit\nmeterpreter payloads quite reliably even if it’s encoded/cloaked. How that?\n\nIf you see malware code that is hidden in an overlay at the end of a valid executable (e.g.\n“ab.exe”) and you see only strings that are typical function exports or mimics a well-known\nexecutable ask the following questions:\n\n\n-----\n\nIs it normal that these strings are located at this location in the file?\nIs it normal that these strings occur more than once in that file?\nIs the distance between two strings somehow specific?\n\nMalware Strings\n\nIn case of the unspecific malware code in the PE overlay, try to define a rule that looks for a\ncertain file size (e.g. filesize > 800KB) and the malware strings relative to the end of the file\n(e.g. $s1 in (filesize-500..filesize)).\nThe following example shows a unspecified webshell that contains strings that may be\nmodified by an attacker in future versions when applied in a victim’s network. Try always to\n\n\n-----\n\nextract strings that are less likely to be changed.\n\nWebshell Code PHP\n\nThe variable name “$code” is more likely to change than the function combination\n“@eval(gzinflate(base64_decode(” at the end of the file. It is possible that valid php code\ncontains “eval(gzinflate(base64_decode(” somewhere in the code but it is less likely that it\noccurs in the last 50 bytes of the file.\nI therefore wrote the following rule:\nrule Webshell_b374k_related_1 {\nmeta:\ndescription = \"Detects b374k related webshell\"\nauthor = \"Florian Roth\"\nreference = \"https://goo.gl/ZuzV2S\"\nscore = 65\nhash = \"d5696b32d32177cf70eaaa5a28d1c5823526d87e20d3c62b747517c6d41656f7\"\ndate = \"2015-10-17\"\nstrings:\n$m1 = \"<?php\"\n$s1 = \"@eval(gzinflate(base64_decode(\" ascii\ncondition:\n$m1 at 0 and $s1 in (filesize-50..filesize) and filesize < 20KB\n}\n\n## Performance Guidelines\n\nI collected many ideas by Wesley Shields and Victor M. Alvarez and composed a gist called\n“Yara\n\nPerformance Guidelines”. This guide shows you how to write Yara rules that use less CPU\ncycles by avoiding CPU intensive checks or using new condition checking shortcuts\nintroduced in Yara version 3.4.\n\n[Yara Performance Guidelines](https://gist.github.com/Neo23x0/e3d4e316d7441d9143c7)\n\n## PE Module\n\n\n-----\n\nPeople sometimes ask why I don t use the PE module. The reason is simple: I avoid using\nmodules that are rather new and would like to see it thoroughly tested prior using it in my\nscanners running in productive environments. It is a great module and a lot of effort went into\nit. I would always recommend using the PE module in lab environments or sandboxes. In\nscanners that walk huge directory trees a minor memory leak in one of the modules could\nlead to severe memory shortages. I’ll give it another year to prove its stability and then start\nusing it in my rules.\n\n## yarGen\n\nyarGen has an opcode feature since the last minor version. It is active by default but only\nuseful in cases in which not enough strings could be extracted.\n\nI currently use the following parameters to create my rules:\n\npython yarGen.py --noop -z 0 -a \"Florian Roth\" -r \"http://link-to-sample\" /mal/malware\nThe problem with the opcode feature is that it requires about 2,5 GB more main memory\nduring rule creation. I’ll change it to an optional parameter in the next version.\n\n## yarAnalyzer\n\nyarAnalyzer is a rather new tool that focuses on rule coverage. After creating a bigger rule\nset or a generic rule that should match on several samples you’d like to check the coverage\nof your rules in order to detect overlapping rules (which is often OK).\nyarAnalyzer helps you to get an overview on:\n\nrules that match on more than one sample\nsamples that show hits from more than one rule\nrules without hits\nsamples without hits\n\n\n-----\n\nyarAnalayzer Screenshot\n\n[yarAnalyzer Github Repository](https://github.com/Neo23x0/yarAnalyzer)\n\n## String Extraction and Colorization\n\nTo review the strings in a sample I use a simple shell one-liner that a good friend sent me\nonce.\n\n“strings” version for Linux\n\n#!/bin/bash\n\n(strings -a -td \"$@\" | sed 's/^\\(\\s*[0-9][0-9]*\\) \\(.*\\)$/\\1 A \\2/' ; strings -a -td -el \"$@\" | sed 's/^\\\n(\\s*[0-9][0-9]*\\) \\(.*\\)$/\\1 W \\2/') | sort -n\n“gstrings” version for OS X (sudo port install binutils)\n\n#!/bin/bash\n\n(gstrings -a -td \"$@\" | gsed 's/^\\(\\s*[0-9][0-9]*\\) \\(.*\\)$/\\1 A \\2/' ; gstrings -a -td -el \"$@\" | gsed\n's/^\\(\\s*[0-9][0-9]*\\) \\(.*\\)$/\\1 W \\2/') | sort -n\nIt produces an output as shown in the above screenshot with green text and the description\n“Malware Strings” showing the offset, ascii (A) or wide (W) and the string at this offset.\n\n[For a colorization of the string check my new tool “prisma” that colorizes random type](https://github.com/Neo23x0/prisma)\nstandard output.\n\n\n-----\n\nPrisma STDOUT colorization\n\n## Contact\n\nFollow me on Twitter: [@Cyb3rOps](https://twitter.com/Cyb3rOps)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2015/2015-10-17 - How to Write Simple but Sound Yara Rules – Part 2.pdf"
    ],
    "report_names": [
        "2015-10-17 - How to Write Simple but Sound Yara Rules – Part 2.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535620,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1653762600,
    "ts_modification_date": 1653762600,
    "files": {
        "pdf": "https://archive.orkl.eu/d68c60f47c3960e61bc93a3072e32f3eccab9516.pdf",
        "text": "https://archive.orkl.eu/d68c60f47c3960e61bc93a3072e32f3eccab9516.txt",
        "img": "https://archive.orkl.eu/d68c60f47c3960e61bc93a3072e32f3eccab9516.jpg"
    }
}