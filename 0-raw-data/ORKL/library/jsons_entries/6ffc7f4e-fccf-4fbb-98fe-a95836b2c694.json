{
    "id": "6ffc7f4e-fccf-4fbb-98fe-a95836b2c694",
    "created_at": "2023-01-12T15:00:18.782723Z",
    "updated_at": "2025-03-27T02:05:57.063303Z",
    "deleted_at": null,
    "sha1_hash": "e860c6dafa95585cce288ae64e5381e19fc2ebf3",
    "title": "2022-03-21 - The Art and Science of macOS Malware Hunting with radare2 - Leveraging Xrefs, YARA and Zignatures",
    "authors": "",
    "file_creation_date": "2022-05-28T19:56:21Z",
    "file_modification_date": "2022-05-28T19:56:21Z",
    "file_size": 3364921,
    "plain_text": "# The Art and Science of macOS Malware Hunting with radare2 | Leveraging Xrefs, YARA and Zignatures\n\n**sentinelone.com/labs/the-art-and-science-of-macos-malware-hunting-with-radare2-leveraging-xrefs-yara-and-**\nzignatures/\n\nPhil Stokes\n\nWelcome back to our series on macOS reversing. Last time out, we took a look at challenges\n[around string decryption, following on from our earlier posts about beating malware anti-](https://www.sentinelone.com/labs/techniques-for-string-decryption-in-macos-malware-with-radare2/)\nanalysis techniques and [rapid triage of Mac malware with radare2. In this fourth post in the](https://www.sentinelone.com/labs/6-pro-tricks-for-rapid-macos-malware-triage-with-radare2/)\nseries, we tackle several related challenges that every malware hunter faces: you have a\nsample, you know it’s malicious, but\n\nHow do you determine if it’s a variant of other known malware?\nIf it is unknown, how do you hunt for other samples like it?\nHow do you write robust detection rules that survive malware author’s refactoring and\nrecompilation?\n\nThe answer to those challenges is part Art and part Science: a mixture of practice, intuition\nand occasionally luck(!) blended with a solid understanding of the tools at your disposal. In\nthis post, we’ll get into the tools and techniques, offer you tips to guide your practice, and\nencourage you to gain experience (which, in turn, will help you make your own luck) through\na series of related examples.\n\nAs always, you’re going to need a few things to follow along, with the second and third items\nin this list installed in the first.\n\n\n-----\n\n[1. An isolated VM – see instructions here for how to get set up](https://www.sentinelone.com/labs/6-pro-tricks-for-rapid-macos-malware-triage-with-radare2/)\n2. Some samples – see Samples Used below\n[3. Latest version of r2 – see the github repo here.](https://github.com/radareorg/radare2)\n\n## What are Zignatures and Why Are They Useful?\n\nBy now you might have wondered more than once if this post just had a really obvious typo:\nZignatures, not signatures? No, you read that right the first time! Zignatures are r2’s own\nformat for creating and matching function signatures. We can use them to see if a sample\ncontains a function or functions that are similar to other functions we found in other malware.\nSimilarly, Zignatures can help analysts identify commonly re-used library code, encryption\nalgorithms and deobfuscation routines, saving us lots of reversing time down the road (for\n[readers familiar with IDA Pro or Ghidra, think F.L.I.R.T or Function ID).](https://hex-rays.com/products/ida/tech/flirt/in_depth/)\n\nWhat’s particularly nice about Zignatures is that you can not only search for exact matches\nbut also for matches with a certain similarity score. This allows us to find functions that have\nbeen modified from one instantiation to the other but which are otherwise the same.\n\nZignatures can help us to answer the question of whether an unknown sample is a variant of\na known one. Once you are familiar with Zignatures, they can also help you write good\ndetection rules, since they will allow you to see what is constant in a family of malware and\nwhat is variant. Combined with YARA rules, which we’ll take a look at later in this post, you\ncan create effective hunting rules for malware repositories like VirusTotal to find variants or\nuse them to help inform the detection logic in malware hunting software.\n\n## Create and Use A Zignature\n\n[Let’s jump into some malware and create our first Zignature. Here’s a recent sample of](https://www.virustotal.com/gui/file/0c08992841d5a97e617e72ade0c992f8e8f0abc9265bdca6e09e4a3cb7cb4754)\nWizardUpdate (you might remember we looked at an older sample of WizardUpdate in our\npost on [string decryption).](https://www.sentinelone.com/labs/techniques-for-string-decryption-in-macos-malware-with-radare2/)\n\n\n-----\n\nLoading the sample into r2, analyzing its functions, and displaying its hashes\nWe’ve loaded the sample into r2 and run some analysis on it. We’ve been conveniently\ndropped at the `main() function, which looks like this.`\n\nWizardUpdate `main() function`\nThat `main function contains some malware specific strings, so should make a nice target`\nfor a Zignature. To do so, we use the `zaf command, supplying the parameters of the`\nfunction name and the signature name. Our sample file happened to be called\n“WizardUpdateB1”, so we’ll call this signature “WizardUpdateB1_main”. In r2, the full\ncommand we need, then, is:\n```\n> zaf main WizardUpdate_main\n\n```\nWe can look at the newly-created Zignature in JSON format with `zj~{} (if you’re not sure`\n[why we’re using the tilde, review the earlier post on grepping in r2).](https://www.sentinelone.com/labs/6-pro-tricks-for-rapid-macos-malware-triage-with-radare2/)\n\n\n-----\n\nAn r2 Zignature viewed in JSON format\nTo see that the Zignature works, try `zb and note the output:`\n```\nzb returns how close the match was to the Zignature and the function at the current\n\n```\naddress\nThe first entry in the row is the most important, as that gives us the overall (i.e., average)\nmatch (between 0.00000 and 1.00000). The next two show us the match for bytes and\ngraph, respectively. In this case, it’s a perfect match to the function, which is of course what\nwe would expect as this is the sample from which we created the rule.\n\nYou can also create Zignatures for every function in the binary in one go with `zg .`\n\n\n-----\n\nCreate function signatures for every function in a binary with one command\nBeware of using `zg on large files with thousands of functions though, as you might get a lot`\nof errors or junk output. For small-ish binaries with up to a couple of hundred functions it’s\nprobably fine, but for anything larger than that I typically go for a targeted approach.\n\nSo far, we have created and tested a Zignature, but it’s real value lies in when we use the\nZignature on other samples.\n\n## Create A Reusable and Extensible Zignatures File\n\nAt the moment, your Zignatures aren’t much use because we haven’t learned yet how to\nsave and load Zignatures between samples. We’ll do that now.\n\nWe can save our generated Zignatures with `zos <filename> . Note that if you just provide`\nthe bare filename it’ll save in the current working directory. If you give an absolute path to an\nexisting file, r2 will nicely merge the Zignatures you’re saving with any existing ones in that\nfile.\n\nRadare2 does have a default address from which it is supposed to autoload Zignatures if the\nautoload variable is set, namely `~/.local/share/radare2/zigns/ (in some`\n[documentation, it’s](https://r2wiki.readthedocs.io/en/latest/options/e/values-that-e-can-modify/zign/#zign) `~/.config/radare2/zigns/ ) However, I’ve never quite been able to`\nget autoload to work from either address, but if you want to try it, create the above location\nand in your radare2 config file ( ~/.radare2rc ) add the following line.\n```\ne zign.autoload = true\n\n```\nIn my case, I load my zigs file manually, which is a simple command: `zo <filename> to`\nload, and `zb to run the Zignatures contained in the file against the function at the current`\naddress.\n\n\n-----\n\nSample WizardUpdate_B2’s `main function doesn’t match our Zignature`\n\nSample WizardUpdate_B5’s `main function is a perfect match for our Zignature`\n\nAs you can see, the Sample above B5 is a perfect match to B1, whereas B2 is way off with\nthe match only around 46.6%.\nWhen you’ve built up a collection of Zignatures, they can be really useful for checking a new\nsample against known families. I encourage you to create Zignatures for all your samples as\nthey will pay dividends down the line. Don’t forget to back them up too. I learned the hard\nway that not having a master copy of my Zigs outside of my VMs can cause a few tears!\n\n## Creating YARA Rules Within radare2\n\nZignatures will help you in your efforts to determine if some new malware belongs to a family\nyou’ve come across before, but that’s only half the battle when we come across a new\nsample. We also want to hunt – and detect – files that are like it. For that, YARA is our friend,\nand r2 handily integrates the creation of YARA strings to make this easy.\n\nIn this next example, we can see that a different WizardUpdate sample doesn’t match our\nearlier Zignature.\n\nThe output from `zb shows that the current function doesn’t match any of our previous`\n\n\n-----\n\nfunction signatures\nWhile we certainly want to add a function signature for this sample’s `main() to our existing`\nZigs, we also want to hunt for this on external repos like VirusTotal and elsewhere where\nYARA can be used.\n\nOur main friend here is the `pcy command. Since we’ve already been dropped at`\n```\nmain() ’s address, we can just run the pcy command directly to create a YARA string for\n\n```\nthe function.\n\nGenerating a YARA string for the current function\nHowever, this is far too specific to be useful. Fortunately, the `pcy command can be tailored`\nto give us however many bytes we wish at whatever address.\n\nWe know that WizardUpdate makes plenty of use of `ioreg, so let’s start by searching for`\ninstances of that in the binary.\n\n\n-----\n\nSearching for the string “ ioreg ” in a WizardUpdate sample\nLots of hits. Let’s take a closer look at the hex of the first one.\n\n\n-----\n\nA URL embedded in the WizardUpdate sample\nThat URL address might be a good candidate to include in a YARA rule, let’s try it. To grab it\nas YARA code, we just seek to the address and state how many bytes we want.\n\nGenerating a YARA string of 48 bytes from a specific address\n\n\n-----\n\nThis works nicely and we can just copy and paste the code into VT s search with the content\nmodifier. Our first effort, though, only gives us 1 hit on VirusTotal, although at least it’s\ndifferent from our initial sample (we’ll add that to our collection, thanks!).\n\nOur string only found a single hit on VirusTotal\nBut note how we can iterate on this process, easily generating YARA strings that we can use\nboth for inclusion and exclusion in our YARA rules.\n\n\n-----\n\nThis time we had better success with 46 hits for one string\nThis string gives us lots of hits, so let’s create a file and add the string.\n```\npcy 32 >> WizardUpdate_B.yara\n\n```\nOutputting the YARA string to a file\nFrom here on in, we can continue to append further strings that we might want to include or\nexclude in our final YARA rule. When we are finished, all we have to do is open our new\n```\n.yara file and add the YARA meta data and conditional logic, or we can paste the contents\n\n```\nof our file into VTs Livehunt template and test out our rule there.\n\n## Xrefs For the Win\n\nAt the beginning of this post I said that the answer to some of the challenges we would deal\nwith today were “part Art and part Science”. We’ve done plenty of “the Science”, so I want to\nround out the post by talking a little about “the Art”. Let’s return to a topic we covered briefly\n[earlier in this series – finding cross-references in r2 – and introduce a couple of handy tips](https://www.sentinelone.com/labs/defeating-macos-malware-anti-analysis-tricks-with-radare2/)\nthat can make development of hunting rules a little easier.\n\nWhen developing a hunting or detection rule for a malware family, we are trying to balance\ntwo opposing demands: we want our rule to be specific enough not to create false positives,\nbut wide or general enough not to miss true positives. If we had perfect knowledge of all\nsamples that ever had been or ever would be created for the family under consideration, that\nwould be no problem at all, but that’s precisely the knowledge-gap that our rule is aiming to\nfill.\n\n\n-----\n\nA common tip for writing YARA rules is to use something like a combination of strings,\nmethod names and imports to try to achieve this balance. That’s good advice, but sometimes\nmalware is packed to have virtually none of these, or not enough to make them easily\ndistinguishable. On top of that, malware authors can and do easily refactor such artifacts and\nthat can make your rules date very quickly.\n\nA supplementary approach that I often use is to focus on code logic that is less easy for\nauthor’s to change and more likely to be re-used.\n\nLet’s take a look at this sample of [Adload written in Go. It’s a variant of a much more prolific](https://www.sentinelone.com/labs/a-threat-hunters-guide-to-the-macs-most-prevalent-adware-infections-2022/)\nversion, also written in Google’s Golang. Both versions contain calls to a legit project found\non [Github, but this variant is missing one of the distinctive strings that made its more](https://github.com/denisbrodbeck/machineid)\nwidespread cousin fairly easy to hunt.\n\nA version of Adload that calls out to a popular project on Github\nHowever, notice the URL at `0x7226 . That could be interesting, but if we hit on that domain`\nname string alone in VirusTotal we only see 3 hits, so that’s way too tight for our rule.\n\n\n-----\n\nYour rules won’t catch much if your strings are too specific\n\nLet’s grab some bytes immediately after the C2 string is loaded\nWe might do better if we try grabbing bytes of code right after that string has been loaded, for\nwhile the API string will certainly change, the code that consumes it perhaps might not. In\nthis case, searching on 96 bytes from `0x7255 catches a more respectable 23 hits, but that`\nstill seems too low for a malware variant that has been circulating for many months.\n\nNotice the dates – this malware has probably far more than just 23 samples\nLet’s see if we can do better. One trick I find useful with r2 is to hunt down all the XREFs to a\nparticular piece of code and then look at the calling functions for useful sequences of byte\ncode to hunt on.\n\nFor example, you can use `sf. to seek to the beginning of a function from a given address`\n(assuming it’s part of a function, of course) and then use `axg to get the path of execution to`\nthat function all the way from `main() . You can use` `pds to give you a summary of the calls`\nin any function along the way, which means combining `axg and` `pds is a very good way to`\nquickly move around a binary in r2 to find things of interest.\n\n\n-----\n\nUsing the `axg command to trace execution path back to main`\nNow that we can see the call graph to the C2 string, we can start hunting for logic that is\nmore likely to be re-used across samples. In this case, let’s hunt for bytes where\n```\nsym.main.main calls the function that loads the C2 URL at 0x01247a41 .\n\n```\nFinding reusable logic that should be more general than individual strings\nGrabbing 48 bytes from that address and hunting for it on VT gives us a much more\nrespectable 45 TP hits. We can also see from VT that these files all have a common size,\n5.33MB, which we can use as a further pivot for hunting.\n\n\n-----\n\nOur hunt is starting to give better results, but don’t stop here!\nWe’ve made a huge improvement on our initial hits of 3 and then 23, but we’re not really\ndone yet. If we keep iterating on this process, looking for reusable code rather than just\nspecific strings, imports or method names, we’re likely to do much better, and by now you\nshould have a solid understanding of how to do that using r2 to help you in your quest. All\nyou need now, just like any good piece of malware, is a bit of persistence!\n\n## Conclusion\n\nIn this post, we’ve taken a look at some of r2’s lesser known features that are extremely\nuseful for hunting malware families, both in terms of associating new samples to known\nfamilies and in searching for unknown relations to a sample or samples we already have. If\n[you haven’t checked out the previous posts in this series, have a look at Part 1,](https://www.sentinelone.com/labs/6-pro-tricks-for-rapid-macos-malware-triage-with-radare2/) [Part 2 and](https://www.sentinelone.com/labs/defeating-macos-malware-anti-analysis-tricks-with-radare2/)\n[Part 3. If you would like us to cover other topics on r2 and reverse engineering macOS](https://www.sentinelone.com/labs/techniques-for-string-decryption-in-macos-malware-with-radare2/)\nmalware, [ping me or](https://twitter.com/philofishal) [SentinelLabs on Twitter with your suggestions.](https://twitter.com/labssentinel?lang=en)\n\n## Samples Used\n\n**File name** **SHA1**\n\nWizardUpdate_B1 2f70787faafef2efb3cafca1c309c02c02a5969b\n\nWizardUpdate_B2 dfff3527b68b1c069ff956201ceb544d71c032b2\n\nWizardUpdate_B3 814b320b49c4a2386809b0bdb6ea3712673ff32b\n\nWizardUpdate_B4 6ca80bbf11ca33c55e12feb5a09f6d2417efafd5\n\nWizardUpdate_B5 92b9bba886056bc6a8c3df9c0f6c687f5a774247\n\n\n-----\n\nWizardUpdate_B6 21991b7b2d71ac731dd8a3e3f0dbd8c8b35f162c\n\nWizardUpdate_B7 6e131dca4aa33a87e9274914dd605baa4f1fc69a\n\nWizardUpdate_B8 dac9aa343a327228302be6741108b5279adcef17\n\nAdload 279d5563f278f5aea54e84aa50ca355f54aac743\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-21 - The Art and Science of macOS Malware Hunting with radare2 - Leveraging Xrefs, YARA and Zignatures.pdf"
    ],
    "report_names": [
        "2022-03-21 - The Art and Science of macOS Malware Hunting with radare2 - Leveraging Xrefs, YARA and Zignatures.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535618,
    "ts_updated_at": 1743041157,
    "ts_creation_date": 1653767781,
    "ts_modification_date": 1653767781,
    "files": {
        "pdf": "https://archive.orkl.eu/e860c6dafa95585cce288ae64e5381e19fc2ebf3.pdf",
        "text": "https://archive.orkl.eu/e860c6dafa95585cce288ae64e5381e19fc2ebf3.txt",
        "img": "https://archive.orkl.eu/e860c6dafa95585cce288ae64e5381e19fc2ebf3.jpg"
    }
}