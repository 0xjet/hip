{
    "id": "48d5e0c9-9b46-4eab-845c-80ef054b148a",
    "created_at": "2023-01-12T15:01:48.241596Z",
    "updated_at": "2025-03-27T02:09:29.856697Z",
    "deleted_at": null,
    "sha1_hash": "33cdba9ea053d8c2c98d176f4491ba53ab3be448",
    "title": "2016-11-21 - Android malware analysis with Radare- Dissecting the Triada Trojan",
    "authors": "",
    "file_creation_date": "2022-05-27T22:14:04Z",
    "file_modification_date": "2022-05-27T22:14:04Z",
    "file_size": 1112617,
    "plain_text": "# Android malware analysis with Radare: Dissecting the Triada Trojan\n\n**[nowsecure.com/blog/2016/11/21/android-malware-analysis-radare-triada-trojan/](https://www.nowsecure.com/blog/2016/11/21/android-malware-analysis-radare-triada-trojan/)**\n\nNew MASVS Mobile Pen Test From NowSecure\n\nShow More\n\n**NowSecure Debuts New OWASP MASVS Mobile Pen Tests**\n\nThis blog post covers NowSecure’s New OWASP MASVS Mobile Pen Tests. To support the\nneeds of the OWASP Mobile Application Security Verification Standard (MASVS) security\nrequirements, NowSecure recently expanded its expert mobile application penetration tests\nto offer OWASP MASVS compliance and incorporated OWASP MASVS findings into\nNowSecure Platform software for automated mobile application security testing.\n\n[Learn More](https://www.nowsecure.com/blog/2022/03/22/nowsecure-debuts-new-owasp-masvs-mobile-pen-tests/)\n\n\n-----\n\nDeliver Secure Mobile Apps Faster\n\nSolutionsSolutions\n\nResourcesResources\n\nCompanyCompany\n\nI periodically assess suspicious mobile apps in order to identify malicious behavior, get\nideas for new product functionality, or implement preflight checks to make sure apps\n[submitted to our automated mobile app security testing solution can be properly assessed.](https://www.nowsecure.com/blog/2016/09/19/announcing-nowsecure-lab-automated/)\nAs part of my work as a mobile security analyst at NowSecure, I recently performed Android\nmalware analysis with Radare on a sample of the Triada Trojan.\n\nRadare2 is known to disassemble Linux, Windows, and OSX binaries, but what about\nAndroid? Well, it can load Dalvik DEX (odex, multidex), ELF (.so, ART, executables, etc.),\nJava CLASS files and more!\n\nI wrote this blog post to provide an introduction on how to use Radare for Android malware\nanalysis. After reading this post, you’ll understand how to use Radare2 to disassemble\nAndroid binaries, how to identify suspicious or malicious app behavior, and some of the\nbenefits and limitations of using Radare2 for this use case.\n\n## Identifying a suspicious Android app\n\nFinding a sample of Android malware isn’t difficult, but I wanted to dissect something\n[interesting. I searched Koodous, a platform for Android malware research, for “free](https://koodous.com/)\ndownload” and found an app named “Free Youtube Video Download.” The app struck me as\nsuspicious because screenshots were taken from another app, and the official icon was\naltered. So I clicked the download button and began my analysis.\n\n## Intent: Deciding whether a suspicious Android app is malware\n\nA good first step in evaluating a suspicious file is understanding what other people already\n[know about the file by scanning it with an anti-virus solution such as VirusTotal. I uploaded](https://www.virustotal.com/)\n[the sample, and VirusTotal reported a detection ratio of 34/55 and identified it as the Triada](https://virustotal.com/en/file/3c85c9a44f4c03f462fde63ae03bca5347ededeb6c6e2b79bcaf91e7a20c84e5/analysis/)\n\n\n-----\n\nAndroid Trojan. So the app was infected.\n\nKeep in mind that anti-virus technology can sometimes fail or return false-positive results\nbecause malware evolves faster than anti-virus vendors can develop good heuristics or\nsignatures to filter them out.\n\nTo gather more information beyond that provided by anti-virus engines, I examined a YARA\n[rule that detects the sample and uses the Androguard YARA module written by some peeps](https://github.com/Koodous/androguard-yara)\nfrom the Koodous team.\n\nThe sample was discovered in March 2016, and there’s still no publicly available technical\nanalysis. At the time, [Kaspersky Lab called Triada the most advanced Android malware to](http://me.kaspersky.com/en/about/news/virus/2016/Kaspersky-Lab-Discovers-Triada)\ndate and compared it to Windows malware in terms of complexity. To read more detailed\ninformation about the infection techniques used by this particular malware sample, see the\n[blog post “Attack on Zygote: a new twist in the evolution of mobile threats.”](https://securelist.com/analysis/publications/74032/attack-on-zygote-a-new-twist-in-the-evolution-of-mobile-threats/)\n\nAs I prepared to dig deeper, I collected more samples that matched the same YARA rule by\npasting the rule in the Koodous search box, which resulted in three more .apks. While I had\ngathered multiple samples that matched the YARA rule, I couldn’t be sure whether or not\nthey were variants of the same family.\n\n## Exploring the functionality of Android malware\n\nWhen analyzing a suspicious Android app, you’ll evaluate the following factors:\n\n**Obfuscation techniques – Obfuscation may be used to legitimately protect**\nintellectual property or to hide malicious code.\n**Excessive permissions – If the app requests excessive permissions, it may simply**\nbe a mistake made by the developer or deliberate and for nefarious purposes.\n**Strange files on the device – Trash files, binary resources or encrypted payloads.**\n**Emulator checks – Requiring a patch for the app or using an actual device for**\nanalysis.\n**ARM-only libraries – Making it so the app can’t be executed on an x86 emulator, for**\nexample.\n**Strings pointing to system binaries – This may be a legitimate root detection**\nmechanism or part of an escalation of privileges exploit.\n**Hardcoded IPs in the binaries – These may be IP addresses for testing servers**\nforgotten by developers or for command-and-control servers (botnets).\n**Links to APKs – Developers may have forgotten to remove these links used for**\ntesting purposes or the links may point to second-stage payloads.\n**Access to the SMS/messaging functionality – This may be legitimate and used for**\ntwo-factor authentication or for malicious purposes such as unauthorized subscription\npayment services scams or stealing authentication codes for bank payments, etc.\n\n\n-----\n\n**Modified legitimate apps – Bad actors regularly modify legitimate apps to**\ninclude/hide a malware payload within them.\n**App source or reliability of hosting/connectivity channel – If the source of an .apk**\nis an alternative Android marketplace or unknown, you can’t be sure what review\nprocess the app went through.\n\nIf the app comes from a suspicious source, you should trust it less than an app that comes\nfrom an official marketplace (which will typically document its review process), and it\nwarrants deeper analysis to check for malicious intent. In the same way, if an app asks for\nmore permissions than seems appropriate, avoid installing it and do more analysis.\nManually analyzing the files within the .apk is a good place to start and will help you select\nsome metrics to help understand the app’s intent and capabilities.\n\nWhen you analyze a malware sample, determining what code is part of the original app as\nopposed to the malware itself, the protector, ads, or a tracking system can be a challenge.\nIt’s common to find numerous statistics SDKs within the same app collecting data about the\ndevice and user behavior. You’ll also find boot-time services that launch them after reboot.\n\nIn this case, I found the sample generating a JSON file enumerating all the installed apps\ncontaining permissions for doing host card emulation (HCE) for NFC. The sample also\ndynamically loads two encrypted blobs and references another .apk protected with APK\nProtect. Extracting those pieces requires dynamic analysis, which I plan to cover in a future\narticle.\n\n\n-----\n\nPerforming a full analysis goes beyond the scope of this blog post, but I will walk through\nthe introductory steps that readers can then use as a starting place for more in-depth\nanalysis. The steps I will cover include the following:\n\n1. Extracting details about the malware like lists of permissions, types of binaries,\n\nfunction names, imported symbols, classes, strings contained in the binaries, etc.\n\n\n-----\n\n2. Performing static analysis on the suspicious binaries within the app in order to\n\nunderstand what the code is doing with the resources identified in the first step.\n3. Emulating the sample in a QEMO-based Android environment in order to trace\n\nprogram execution and identify system events and behaviors.\n\nMost mobile malware will not execute on non-ARM or emulated environments, and so I\nanalyzed the sample on an actual hardware device with clean, reflashed firmware.\n\n### AndroidManifest.xml\n\nWhile its extension is .xml, AndroidManifest.xml is not plain text. It is a binary XML format\nused only in Android, and you can convert it to a readable format with the\n[Axml2xml.rb Ruby script (also available via r2pm -i axml2xml).](https://github.com/thadd/axml2xml.rb)\n\n[You can also use the rafind2 program within Radare to extract strings of interest from the](http://rada.re/r/)\nfile (note that strings will not work at all):\n```\n$ rafind2 -ZS android AndroidManifest.xml\n$ rafind2 -ZS permissions AndroidManifest.xml\n$ rafind2 -ZS intent AndroidManifest.xml\n\n```\nSome common permissions used by malware include the following:\n\n\n-----\n\n```\npermission.CHANGE_WIFI_STATE\npermission.CHANGE_NETWORK_STATE\npermission.INSTALL_PACKAGES\npermission.INSTALL_SHORTCUT\npermission.SYSTEM_OVERLAY_WINDOW\npermission.ACCESS_DOWNLOAD_MANAGER\npermission.MOUNT_UNMOUNT_FILESYSTEMS\npermission.RECORD_AUDIO\npermission.RECEIVE_BOOT_COMPLETED\npermission.KILL_BACKGROUND_PROCESSES\npermission.ACCESS_MTK_MMHW\npermission.DISABLE_KEYGUARD\npermission.SYSTEM_ALERT_WINDOW/\npermission.GET_TASKS\n...\n\n### Classes.dex\n\n```\nThis file contains the Dalvik code of the application. All of an app’s original Java code is\ntranspiled into Dalvik and assembled in the DEX file, which runs on a stack-less, registerbased virtual machine. Some versions of Android will emulate the code directly from the\n.dex file, others will translate it to real machine code via JIT (just-in-time) techniques, and\nmost modern versions of Android will precompile most of that code into an AOT (ahead-oftime) executable targeting the ART (Android runtime).\n\nYou can use Radare2 to extract information from the .dex file using the following\ncommands:\n```\n> icq # enumerate classnames\n> iiq # imports (external methods)\n> ic # enumerate classes and their methods\n> izq # list all strings contained in the program\n\n```\n\n-----\n\nOne important hint is to compare the permissions requested by the manifest and the ones\nused by the app itself. In this case, as long as the application can dynamically load new\ncode we will not see the true purpose unless we perform a dynamic analysis.\n\nChecking out the imports of the classes.dex will give us some hints about which kind of\nsystem APIs the application is using.\n```\n$ rabin2 -qi classes.dex | grep -i -e sms -e bluetooth -e install -e PackageManager\n-e Datagram -e Telephony -e nfc\n\n```\nIn addition we can use dexdump to enumerate all the intents used in the main dex:\n```\n$ dexdump -d | grep ‘“android.’ | cut -d, -f 2- | sort -u\n\n```\nOnce we have a complete disassembly from dexdump, you can use your favorite editor or\neven plain grep to find string-const calls. But in Radare2 you can also use the /r command\nto find references to strings or methods in order to identify who is using those suspicious\nstrings and for what purpose.\n\n### Filtering Strings\n\nTo filter the output of commands, you can use the ~ operator in the Radare2 shell. The ~\noperator is similar to the UNIX grep utility, but it runs internally and doesn’t require any\nseparate system process to run.\n\nUsing the following string filters you can identify some interesting findings in the classes.dex\nfile:\n\n/system /data /bin/su …\nhttp://\nhttps://\n.apk\n%d %d %d %d\n\n\n-----\n\nInstall\nSMS\nDexClassLoader InjectCall (used for Dalvik code injection)\napplication/vnd.android (mimetype used to spawn .apk installations)\n==  (embedded base64 resources)\n\nAfter executing the string filters on the malware sample, I found some hard-coded IPs,\npaths to system binaries like su for device root checks, Dalvik code injection calls, the\nstrings commonly used for installing .apks and finally the URL to another file named\n300010.apk.\n\nWhen an anti-virus vendor or a researcher discovers URLs linking to malware, they typically\nsend a take-down notice to the appropriate ISP. The ISP will then contact the owner of the\nserver hosting the malware or directly block those servers. So I was sure to grab the\n300010.apk before it was removed so that I could perform further analysis.\n\nBecause the .apk is protected with APK Protect, we need to decrypt the dynamically loaded\ncode in order to understand what the app is doing exactly. This [Android unpacker tool can](https://github.com/strazzere/android-unpacker/tree/master/native-unpacker)\nbe used for that purpose.\n\nIn this .dex file, I might also find strings encoded in base64, which can be decoded\nautomatically by setting up the RABIN2_DEBASE64 environment variable or using the\ncommand rax2 -D on every single string. It turns out that some base64 encoded strings\ncontain binary data and others show interesting locations inside the binary, like\nloadLibrary().\n```\n$ RABIN2_DEBASE64=1 rabin2 -qzz classes.dex\n\n### Filtering methods\n\n```\nRadare2’s visual mode also supports an interactive heads-up display that will filter out all\nstring, method, and class names from the .dex file. To enter the visual mode, run the “V_”\ncommand, then type ‘_’ in visual mode. Next, type text that you want to highlight. When you\npress <enter>, the UI will jump to that place in the disassembler so that you can view the\ntext in context.\n\nSome relevant text you may want to search for include:\n\nonReceive (used by event handlers)\nInit (all classes have one of them)\nPassword\nInstall\nDex\nSMS\n\n\n-----\n\nMost of the time, malware is protected with ProGuard or other obfuscation tools that will\nmake the class/method/field names completely useless. In that case, you need to dig into\nthe disassembly or perform dynamic analysis to recover the original strings and understand\nthe purpose of each method.\n\n### Disassembling\n\nRadare2 provides a visual mode (V command) and web user interface (via the =H\ncommand) that allows you to use the mouse and get a more interactive view than the just a\nstatic prompt.\n\nAt this point, for analysis purposes, you may want to compare the output of Radare2 with\nother tools like `dexdump -d`, which is available in the Android SDK. Radare2 is known to\nbe more reliable when tweaking .dex binaries, making it a good alternative when\ndecompilers and transpilers can’t be used.\n```\n$ r2pm -i dex2jar\n$ r2pm -r dex2jar classes.dex\n\n```\n\n-----\n\nOnce the .dex file is transpiled into Java Classes, we can use Radare2 to disassemble the\ncontents of the JAR. Because having multiple views of the same code and reading\nassembly is not always the fastest way to understand some parts of a program, you may\nwant to use a decompiler like `jd-gui` which is freely available and can load all the classes\ninto the JAR file simultaneously.\n\nUnfortunately, transpiling from Dalvik to Java bytecode or decompiling Java methods does\nnot always work. Any number of different tools can fail at automated disassembly So an\nanalyst needs to know and understand the risks and weak points of disassembly\ncapabilities within each tool and be able to resolve those problems by hand.\n\nFor example, if we try to disassemble the 300010.apk with dexdump we will get a fancy\nsegmentation fault (which has since been fixed in the Android 7 SDK):\n```\n     $ dexdump -d classes.dex > /dev/null\n     GLITCH: zero-width instruction at idx=0x0000\n     GLITCH: zero-width instruction at idx=0x0000\n     GLITCH: zero-width instruction at idx=0x0000\n     Segmentation fault: 11\n\n```\nTranspiling to Java will partially fail:\n```\n     $ r2pm -r dex2jar classes.dex 2>&1 |grep Error | wc -l\n        40\n\n```\nAndroguard will stop analyzing after an exception:\n```\n     $ androgui.py -i classes.dex\n     Traceback (most recent call last):\n      File \"/Library/Python/2.7/site-packages/androguard/core/bytecodes/dvm.py\",\nline 7014, in get_raw_string\n       off = self.__manage_item[ \"TYPE_STRING_ID_ITEM\" ]\n[idx].get_string_data_off()\n     IndexError: list index out of range\n\n```\nIn one case, trying to open the .apk in IDA Pro resulted in 9,382 error messages. In cases\nsuch as this, a low level disassembler like Radare2 can help.\n\n### Libraries\n\nNative libraries are usually interfaced with Java using JNI symbols, which are exposed in\nthe shared library found in the lib/ subdirectory inside the .apk. Those libraries are usually\nsplit into different subdirectories depending on the target architecture that is supposed to\nrun (e.g., ARM, x86, ARM64, MIPS, etc.)\n\nIn this case we have only ARM binaries, which are typically compiled in Thumb2 mode.\nRadare2 will load those binaries just fine, but you may be interested in switching between\nARM and Thumb modes:\n\n\n-----\n\n```\n     > e asm.bits 16 # set thumb2 mode\n     > e asm.bits=32 # set ARM mode\n\n```\nThere are other variables like asm.cpu that can be useful to get the correct disassembly in\nsome cases, but this will be enough for most situations.\n\nIn visual mode we can also use the HUD mode (use the ‘_’ key as explained before) to\ncollect information from the binary, such as symbols (isq), imports (iiq), or strings (izq).\n\nAfter running those commands, you can make an educated guess about the libraries’\npurposes:\n```\n     lib/armeabi/libbspatch.so   # bzip2 + binary patch API, used by umeng API\nto update stuff\n     lib//armeabi/libcore.so    # upay cryptography\n(Java_com_lem_sdk_util_CoreEnct_decrypt\n     lib//armeabi/libmagic.so   # java code injection by using reflection\nmethods\n\n```\nAt the least, none of them seem related to downloading YouTube videos.\n\nIn order to disassemble and understand what the code is doing, you will want to emulate\nand analyze the code. You can also do this with Radare2. Radare2’s emulation capability is\nimplemented on top of ESIL (Evaluable Strings Intermediate Language), which is a\ncompletely safe virtual machine that has nothing to do with Dalvik or real hardware at all,\nso you can consider it as safe as static analysis.\n\nThe reason why emulation is necessary to disassemble ARM binaries is because some\npointers are computed by more than one instruction. This requires tracking the state\nchanges and resolving the correct strings and method references.\n\n\n-----\n\n```\n     > e asm.describe true  # show description of each ARM instruction\n     > e asm.pseudo = true   # show pseudo instruction instead of assembly\n     > e asm.emu = true    # emulate code using ESIL\n     > e asm.emustr = true   # show string and method referenced in the emu\ncomments\n     > e anal.hasnext=true   # assume a new function is found after the last\none\n\n```\nSome commands that help with malware analysis include:\n```\n     > aa - analyze all public symbols (use aaa or aaaa for more!)\n     > afr - analyze functions recursively\n     > aae - analyze all code references computed with ESIL emulation\n     > aac - analyze all call destinations as functions\n\n```\nIn case you’re interested in a higher level version of the code, you can use the Retargetable\nDecompiler package in Radare2 to take advantage of the online decompilation service\n[available at www.retdec.com.](http://www.retdec.com/)\n\n\n-----\n\nRadial graph of target’s full classes.dex references\n\n### Assets\n\nAn .apk file contains several companion files that are loaded by the app at runtime. Some\nassets are images, others are XML files describing the user interface. During malware\nanalysis, you may find suspicious companion files that you want to take a closer look at.\n\nYou can use the `pm` command in Radare2 or the file tool to guess the filetype with the\nmagic header information on every file:\n```\n     $ find . -type f -exec r2 -qnci~^file -cpm ‘{}’ ‘;’\n     $ file assets/*\n\n```\n\n-----\n\nThe reason to use the internal magic implementation of Radare2 instead of GNU is mainly\n[because there are known vulnerabilities for libmagic file which may be used to run code or](http://www.itsecdb.com/oval/definition/oval/com.redhat.rhsa/def/20160760/)\ninvalidate the analysis. RedHat patched the issue this summer, but some other distributions\nand Docker images remain vulnerable. Radare2’s implementation of libmagic has been\ntaken from OpenBSD, fuzzed, and enhanced. In my experience, Radare2 is also more\nreliable and easier to modify if needed.\n\nIn addition to the print magic (`pm`) command we can use the /m command which will run\n`pm` on every offset to find known magic signatures on raw files. This is useful for carving\nfiles from memory dumps, core images, and more.\n\nWhen I examined the files contained within this sample of malware, I found some files with\nthe .png extension that seemed to contain encrypted data.\n\n## Conclusion: The Triada Android Trojan’s capabilities\n\nAfter using Google to see what other researchers have published about the Tirada Android\nTrojan, I began to understand the real risks brought about by this malware and how it can\nharm users:\n\nRoots the device and modifies the Zygote\nFactory Reset will not remove the malware\nSeems to target pre-KitKat devices but affects all versions\nMay ship some modular exploits to raise privileges\n\nAt this point, I’ve explained how to perform some very basic static analysis on a couple\ntargets. As part of my analysis, I’ve confirmed that this is in fact a modular virus capable of\ndownloading more binaries and applications at runtime. But, we’re still far from\nunderstanding the malware in its entirety due to encrypted components, code loaded at\nruntime, installation of additional applications, networking communications, and more.\n\n\n-----\n\nPRIVACY DISCLOSURE: NowSecure uses first party and third party cookies to provide\nfunctions of this website and our services, to uniquely identify visitors, to analyze use of our\nwebsite, and to target our marketing. You can choose to block cookies using your browser\nsettings. By continuing to use our website or services you indicate your agreement. To learn\nmore about the cookies we use and how we may collect and use your personal data, visit our\n[Privacy Policy](https://www.nowsecure.com/company/privacy-policy/)\n\nThe cookie settings on this website are set to \"allow cookies\" to give you the best browsing\nexperience possible. If you continue to use this website without changing your cookie\nsettings or you click \"Accept\" below then you are consenting to this.\n\nClose\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-11-21 - Android malware analysis with Radare- Dissecting the Triada Trojan.pdf"
    ],
    "report_names": [
        "2016-11-21 - Android malware analysis with Radare- Dissecting the Triada Trojan.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535708,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653689644,
    "ts_modification_date": 1653689644,
    "files": {
        "pdf": "https://archive.orkl.eu/33cdba9ea053d8c2c98d176f4491ba53ab3be448.pdf",
        "text": "https://archive.orkl.eu/33cdba9ea053d8c2c98d176f4491ba53ab3be448.txt",
        "img": "https://archive.orkl.eu/33cdba9ea053d8c2c98d176f4491ba53ab3be448.jpg"
    }
}