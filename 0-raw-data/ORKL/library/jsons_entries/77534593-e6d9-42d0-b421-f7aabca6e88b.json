{
    "id": "77534593-e6d9-42d0-b421-f7aabca6e88b",
    "created_at": "2023-01-12T15:07:09.765096Z",
    "updated_at": "2025-03-27T02:05:30.663915Z",
    "deleted_at": null,
    "sha1_hash": "9bb9930b2518346bed5f4107783bbde74a66ac8c",
    "title": "2021-12-28 - CrowdStrike Strengthens Exploit Protection Using Intel CPU Telemetry",
    "authors": "",
    "file_creation_date": "2022-05-28T04:46:37Z",
    "file_modification_date": "2022-05-28T04:46:37Z",
    "file_size": 1291297,
    "plain_text": "# Falcon Hardware Enhanced Exploit Detection\n\n**[crowdstrike.com/blog/introducing-falcon-hardware-enhanced-exploit-detection/](https://www.crowdstrike.com/blog/introducing-falcon-hardware-enhanced-exploit-detection/)**\n\nTimo Kreuzer - Yarden Shafir - Satoshi Tanda - Blair Foster December 28, 2021\n\nFalcon adds a new feature that uses Intel hardware capabilities to detect complex\nattack techniques that are notoriously hard to detect.\nCrowdStrike’s new Hardware Enhanced Exploit Detection feature delivers memory\nsafety protections for a large number of customers on older PCs that lack modern inbuilt protections.\nOnce activated, the new feature detects exploits by analyzing suspicious operations\nassociated with exploit techniques, such as shellcode injection, return-oriented\nprogramming and others, strengthening CrowdStrike’s existing layered protection\nagainst sophisticated adversaries and threats throughout the attack chain.\n\nCrowdStrike’s goal is to stop breaches — and we do that better than any cybersecurity\ncompany in the world. As attackers advance their tactics and techniques, we continually\nrefine our tools and capabilities to stay ahead of them. We recently added a new feature to\nthe CrowdStrike Falcon® sensor: Hardware Enhanced Exploit Detection, which uses\nhardware capabilities to detect complex attack techniques that are notoriously hard for\n\n\n-----\n\nsoftware alone to detect and prevent. With the release of version 6.27 of the Falcon sensor,\nthis feature is now available on systems with Intel CPUs, sixth generation or newer, running\nWindows 10 RS4 or later.\n\nFalcon Hardware Enhanced Exploit Detection leverages a CPU feature developed by Intel\ncalled Intel Processor Trace (Intel PT) that delivers extensive telemetry useful for the\ndetection and prevention of code reuse exploits. Intel PT records code execution on the\nprocessor and is often used for performance diagnosis and analysis. Intel PT allows the CPU\nto continuously write information about the currently executing code into a memory buffer,\nwhich can be used to reconstruct the exact control flow. The primary usage scenario is to\ntrace an executable while it runs, store the trace on the disk and afterward analyze it to\nreproduce the exact sequence of instructions that has been executed. The program behavior\nvisibility provided by this feature makes it useful for security exploit detection and\ninvestigation as well.\n\nIf Intel PT is enabled and supported by the machine, the Falcon sensor will enable execution\ntracing for a selected set of programs. Whenever the program executes a critical system\nservice (like creating a new process), the sensor will analyze the captured trace to look for\nsuspicious operations. This innovative approach to exploit detection is already proving\nvaluable and has detected several return-oriented programming-based (ROP) exploit chains\ntriggered by vulnerabilities such as CVE-2019-17026, which targets FireFox.\n\nTo fully understand this feature, it’s important to first understand the attacker’s technique,\nwhich is often the first step in an attack chain leading to a breach. This chain involves a\nseries of actions perpetrated by an adversary or malicious software and can include some or\nall of the following: initial access, execution, gaining persistence, privilege escalation,\ndefense evasion, credential access, network discovery, [lateral movement, collection,](https://www.crowdstrike.com/cybersecurity-101/lateral-movement/)\ncommand and control, and exfiltration.\n\nThe Falcon sensor provides visibility into many of these steps, using machine learning and\nartificial intelligence along with indicators of attack (IOAs) to correlate certain attacker\nbehaviors to detections. This allows Falcon to interrupt the attack chain at multiple points to\nprevent further actions, before any damage is done. The earlier in the chain this can be\nachieved, the better.\n\n## Exploits to Gain Initial Access\n\nOne of the early mechanisms used by adversaries for initial access is exploiting\nvulnerabilities in software to achieve execution of malicious code. There are countless ways\nof achieving this, usually starting by making a vulnerable application or service process a\nmaliciously crafted input, like a file or network packet, that triggers a bug, like a buffer\noverflow or use-after-free, which through one or more exploitation techniques eventually\n\n\n-----\n\nleads to code execution controlled by the attacker. Some of these techniques are shellcode\ninjection, return-oriented programming, call-oriented programming, counterfeit objectoriented programming and jump-oriented programming.\n\n### Shellcode Injection\n\nThis technique places the malicious code (aka “shell code”) into a stack or heap buffer and\nthen uses a software bug to overwrite a function’s return address or a function pointer to\npoint to the malicious code. As soon as the function returns, or the overwritten function\npointer is used, the shell code is executed. Since the widespread introduction of Data\nExecution Prevention (DEP), which prevents the CPU from executing instructions on the\nstack and heap by marking it as non-executable (NX), this technique requires the attacker to\nfirst change the memory protection on the injected shell code to remove the NX protection.\nTherefore, it requires at least one more exploit technique to modify the memory protection.\nThis has led to code-reuse attacks, which execute small pieces of code from the program\nitself or its libraries. The most well-known variant of these attack methods is return-oriented\nprogramming, or ROP.\n\n### Return-oriented Programming (ROP)\n\nThis technique bypasses DEP by getting rid of shellcodes entirely and reusing existing code\nfrom the executable or loaded DLLs. Instead of placing the malicious code directly into\nmemory, a stack buffer is filled with the addresses of ROP “gadgets” — small pieces of code\nthat consist of a few instructions followed by a return instruction. The attacker then abuses a\nsoftware bug to overwrite a function’s return address to point to the first ROP gadget, which\nconsists of instructions to adjust the stack pointer so that it points to the buffer containing the\naddresses of the following ROP gadgets, which can be on the stack or on the heap. Each\ngadget will execute a few instructions and then “return” to the next gadget address on the\nstack. By chaining appropriate ROP gadgets, an attacker can craft a chain of instructions\nthat lead to the desired operation like bypassing DEP, loading a DLL or starting a new\nprocess. If the ROP chain is carefully crafted, it can even clean up the traces of the stack\nmanipulation — like pivoting the stack pointer to a heap address — before executing the final\noperation, so that it becomes difficult to detect by just analyzing the call stack.\n\nFor example, here’s a simple demonstration of ROP. Function Foo() calls function Bar(),\npushing the return address on the stack. Function Bar() contains a vulnerability that allows\nan attacker to take control of the stack and overwrite the return address, placing the address\nof a malicious shellcode there instead. Once the function returns, the malicious return\naddress is called and the shellcode executes:\n\n\n-----\n\n### Other Code-reuse Attacks\n\nThere are a few other techniques that attackers can use instead of or in combination with\nROP:\n\n\n-----\n\n**Call-oriented programming (COP): This technique is similar to ROP, but instead of**\noverwriting the return address on the stack, it overwrites a function pointer. This can be\nuseful to initialize an exploit, as it can be easier to leverage a buffer overflow to\noverwrite a function pointer on the stack or on the heap than to overwrite the return\naddress on the stack without destroying the stack cookie.\n**Counterfeit object-oriented programming (COOP): This technique uses a C++**\nobject with virtual methods to redirect the flow of execution. Instead of modifying a\nfunction pointer directly, a v-table pointer in an object is overwritten.\n**Jump-oriented programming (JOP): This technique uses an indirect jmp instruction**\nin the software to redirect execution to an attacker-controlled location. Instead of\nchaining return addresses, JOP usually uses a table of addresses of JOP gadgets\ntogether with a so-called “dispatcher gadget”: a small piece of code that increments a\nregister value to point to the next address in the jump table and then does an indirect\njump to that address. The JOP gadget in turn executes a few instructions and then\ndoes an indirect jump back to the dispatcher gadget.\n\n## Existing Countermeasures\n\nDifferent mechanisms exist to prevent or detect these exploits, including stack cookies,\ncontrol flow integrity, call stack analysis and Intel CET. Unfortunately, many of these\napproaches have limitations reducing their effectiveness, as we discuss next.\n\n### Stack Cookies\n\nA stack cookie is a value that is placed on the stack, between the local variables and the\nreturn address. The compiler will generate code that initializes the stack cookie on function\nentry by XORing a magic value with the current stack pointer, and subsequently checks the\nvalue before returning to the caller and crashes the process if the value doesn’t match the\nexpected one. This mechanism is typically only added to functions that use stack buffers,\nwhich could suffer from a buffer overflow bug, preventing it from being abused to overwrite\nthe return address.\n\n### Control Flow Integrity (CFI)\n\nControl flow integrity describes a family of mechanisms that attempt to protect indirect calls\n(e.g., from function pointers or virtual methods) from being manipulated. This is done by\ninserting compiler-generated code that validates that the target of an indirect call is a\nlegitimate call target.\n\nOn Windows, this protection mechanism is called Control Flow Guard (CFG). To validate the\ncall target, a bitmap is used, which is generated by the kernel from metadata in the images of\nall loaded DLLs and executables and mapped into the address space of every process that\nsupports it. Each bit represents 8 bytes of code, resulting in a huge bitmap. Unfortunately,\n\n\n-----\n\nCFG needs to be enabled with a compiler flag and it isn t widely adopted yet. It cannot be\nenforced on DLLs that were compiled without CFG, and for processes that have it disabled,\nit’s automatically disabled for all system DLLs as well, even though they support it.\n\nWindows 11 has an improved mechanism called Extreme Flow Guard (XFG). Here the\ncompiler inserts a 64-bit hash of the function signature before each function. For each\nindirect function call, the compiler generates instructions that load both the function pointer\nand the hash of the function to be called into registers followed by a call to a dispatch\nfunction that first validates whether the hash matches the one stored before the target\nfunction, before jumping to the target. The current implementation in the pre-release of\nWindows 11 is rather useless, though, because a hash mismatch (as well as an unaligned\ntarget address) simply leads to a fallback to bitmap-based CFG.\n\n### Call Stack Analysis\n\nWhile all previously described mitigations are implemented through the operating system,\nsecurity software has its own ways of detecting such techniques. For example, security\nsoftware can intercept certain system functions and analyze the call stack for signs of\nmanipulation, like a stack frame outside of the actual stack or return addresses on the stack\nthat do not match any call instructions.\n\nThis is typically a sign of a ROP exploit. But more sophisticated exploits are able to restore\nthe stack into a sane state before calling any system services, making it almost impossible to\ndetect the exploitation just by looking at the stack, after the exploitation has taken place.\n\n### Intel CET\n\nSince “Tiger Lake,” Intel CPUs support a feature called Control-Flow Enforcement\nTechnology (Intel CET). It provides two features to protect from code-reuse attacks: indirect\nbranch tracking (IBT) and shadow stack (SS). IBT adds the ENDBR instruction, which marks\nlegitimate targets of indirect calls and jumps, disallowing indirect jumps and calls to any other\ninstruction. Shadow stack, which is inaccessible to user mode, automatically stores copies of\nreturn addresses from the normal stack and detects mismatches of the return value between\nthe normal stack and shadow stack. It is supported by Windows 10 RS5.\n\n## CrowdStrike’s Alternate Approach\n\nWhile a number of viable solutions exist, they are either limited in their protection (stack\ncookies, stack analysis) or require support from the compiler and OS, and in the case of Intel\nCET, require a modern PC refresh. It can be expected that unprotected software will be\naround for many years to come.\n\nTo address the issue now for existing software, an alternate approach is needed. To address\nthis, we investigated the use of Intel Processor Trace to implement a software solution.\n\n\n-----\n\n## Intel Processor Trace\n\nIntel Processor Trace, or Intel PT, is a CPU feature present on Intel CPUs since the fifth\ngeneration (“Broadwell”). It allows the CPU to continuously write information about the\ncurrently executing code into a memory buffer, which can be used to reconstruct the exact\ncontrol flow. The primary usage scenario is to trace an executable while it runs, store the\ntrace on the disk and afterward analyze it to reproduce the exact sequence of instructions\nthat has been executed. In this scenario, the analysis doesn’t need to be extremely fast, but\nthe capture of the trace still needs to be efficient to not excessively slow down the process’\nexecution.\n\nTo achieve this, the CPU writes the trace using packets that are extremely optimized for size,\nresulting in an overhead of only a few percent.\n\nTo minimize the amount of data to write, the CPU doesn’t store any information that can be\nreproduced from the executable code, which is expected to be available for analysis.\n\nFor example, the CPU will only write a packet when execution is going to a location that\ncannot be determined from the instruction being executed. This means execution of direct\njumps and calls, which have target addresses hardcoded in the binary, will not cause a\npacket to be generated. Indirect calls and jumps, as well as returns, which cannot be derived\nfrom the executable code, will result in a packet that specifies the target address of the\ninstruction.\n\nAnother operation that results in packet generation is a conditional jump. For such a jump,\nthe target is already encoded in the executable, so the only information needed is whether\nthe branch was taken or not, which can be represented by a single bit. To achieve this, the\nCPU will write a packet type called Taken Not Taken (TNT) packets into the buffer, which will\nstore multiple bits, each representing a single conditional jump.\n\nAnother optimization is not writing the full target address of an indirect jump, but only the\nlowest bytes of the target address, since the top bytes usually remain the same. This usually\nreduces a packet from 9 bytes to 5 bytes or even 3.\n\n### Configuration\n\nIntel PT is configured using model-specific registers (MSRs). These registers exist per CPU\ncore and thus affect tracing on a per-CPU basis. To capture the trace of an application, it is\nnecessary to collect the trace on a per-thread level. To achieve this, the operating system\nneeds to save and restore these MSRs on each thread-context switch. This is done by using\nthe XSAVES and XRSTORS instructions, which allow the operating system kernel to save\nand restore different register sets. These are extended versions of older XSAVE and\nXRSTOR, which only allowed to save and restore generic user-mode available registers and\ncould thus be executed in user mode. The S suffix in the new instructions indicates\n\n\n-----\n\nSupervisor mode (or kernel mode), allows to save and restore the privileged CPU state and\ncan only be executed by the kernel. Starting from the sixth generation, Intel CPUs\n(“Skylake”) can save and restore the Intel PT state MSRs with these instructions.\nAdditionally, the OS needs to support this. Windows 10 implements this since RS4.\n\n## Using Intel PT to Detect Exploitation\n\nBeing able to capture the execution trace of an application, security software that runs in the\nkernel now has the ability to look for code reuse attacks by parsing the captured trace\npackets together with the executed instructions in the address space of the application.\nBeing able to decode the instructions relies on them still being present when the packets are\nbeing analyzed. This is almost always the case, when the number of analyzed instructions\ndoesn’t get too large.\n\nWhile it is generally desirable to keep the number of instructions in the buffer low to reduce\nthe analysis cost, it also has to be large enough to fully cover larger library functions, like\nCreateProcess, which execute a large amount of instructions before switching to kernel\nmode, so that the exploit that led to the call to it is still in the buffer when the kernel mode\nservice is finally called.\n\nIn its analysis, security software can now check for different suspicious operations, like\nreturns not matching calls, suspicious stack pointer loads, excessive use of indirect calls and\njumps, and more.\n\nWith the release of version 6.27, the CrowdStrike Falcon sensor has a new feature called\nHardware Enhanced Exploit Detection, which leverages Intel PT in the way described above.\n\nIf the feature is enabled and supported by the machine, the sensor will enable execution\ntracing for a selected set of programs. Whenever the program executes a critical system\nservice (like creating a new process), the sensor will analyze the captured trace to look for\nsuspicious operations. Due to the requirements mentioned above, the feature is only\navailable on systems with Intel CPUs of the sixth generation or newer, running Windows 10\nRS4 or later.\n\n### Operation\n\nFor each process that is selected for trace analysis, each thread will be configured to enable\ntracing of all user mode code. A trace buffer is allocated for each thread (32 KB has been\nshown to be sufficient), and the MSRs are configured in the context of the thread. Windows\nwill save and restore the configuration MSRs on each thread context switch, thus making\nsure the trace buffer will only contain the traces from this thread.\n\nKernel mode callbacks with configurable pre-filtering decide when an analysis is due and\nthen run the analyzer, again in the context of the thread that is performing the operation.\n\n\n-----\n\nThe analyzer decodes the packets written in the trace buffer and decodes instructions as\nneeded to reproduce the control flow.\n\nTo efficiently decode the trace, the analyzer uses a custom PT packet decoder that is\noptimized for the required operations it needs to perform. Additionally, it uses a highly\noptimized instruction decoder, which is able to decode tens of millions of instructions per\nsecond. This allows the analyzer to decode and validate a trace buffer that is large enough to\ncover calls to functions like CreateProcess in a few milliseconds. A typical analysis\nprocesses around 130,000 instructions in around 5 milliseconds. Obviously, this is still an\noverhead that can result in slowdown of the application if done too often. Therefore, analysis\nneeds to be triggered only rarely, like when a new process is created or a new dll is loaded.\nPre-filtering based on the invoked system call and the parameters of the events helps reduce\nthe number of analysis operations and configurable size of the analyzed buffer, and as a\nresult, can reduce the analysis duration.\n\nOne method of analysis is maintaining a “shadow stack,” which records the addresses of call\ninstructions and subsequently validates the targets of return instructions to match them.\n\nWhenever a call instruction is decoded, the analyzer will add an entry to the shadow stack,\nand whenever a ret is decoded, the analyzer will pop an entry from the shadow stack and\ncompare it with the target IP that was captured in the trace buffer. Mismatches are recorded.\n\nSince the trace will start at an arbitrary location (e.g., from deep within a call chain), the\nshadow stack might not be built or might be already empty when a return is found. As a\nfallback, when no entries are present in the shadow stack — thus the legitimate return\naddress is unknown to the analyzer — it checks whether the target address is after a call\ninstruction.\n\nWhen an application is exploited using ROP and a system call was invoked as a result of a\nROP chain, the execution trace would contain a number of returns that don’t match the\nrecording from a shadow stack and in the majority of cases also don’t return to an address\nfound immediately after a call instruction. Additional indicators of exploitation are sequences\nof short gadgets followed by a ret and unusual stack pointer-modifying operations.\n\nWhenever the analyzer encounters one of these, it is considered a potential ROP gadget.\nDuring the analysis, data is collected, and then evaluated afterward to decide whether a\nROP attack is likely based on the data.\n\n### False Positive Mitigation\n\nAs already mentioned, the binary code that the trace has recorded executing is usually still in\nmemory. There can be cases, though, when it is not. For example, JIT code might have been\ndeallocated or overwritten after it was executed, but before the analysis happens. This can\nlead to being unable to follow the execution trace, or even misinterpretation of it. There are\n\n\n-----\n\nmitigations in the analyzer that will detect such scenarios and avoid accumulating false\npositives. Additionally, the analyzer collects telemetry data about decoding failures, allowing\nconfig to selectively disregard the results.\n\n### Detection\n\nAs of Falcon sensor version 6.27, we have added a new detection\n(SuspiciousExecutionTrace) and a telemetry event (PtTelemetry) that accompanies it. Early\nanalysis shows that this approach to exploit detection will prove fruitful as we have been able\nto demonstrate detection efficacy on a number of ROP-based exploit chains triggered by\nvulnerabilities such as CVE-2019-17026, which targets FireFox.\n\n(Click to enlarge)\n\n## Summary\n\nIn our mission to stop breaches, CrowdStrike strives to continually expand our suite of exploit\ndetection and prevention capabilities. Many CPU features, such as Intel PT, are underutilized\nand can be efficiently leveraged to detect and prevent exploits, and we will continue to invest\nin these CPU technologies to bring innovative capabilities to the Falcon sensor. It is essential\nto mention that CrowdStrike Falcon takes a layered approach to protecting customers\nagainst exploits and advanced threats by using machine learning (on sensor and in the\ncloud) and behavior-based detection using IOAs. Customers who run the Falcon sensor on\nvirtual machines or other configurations that do not support Falcon Hardware-Enhanced\nExploit Detection are still fully protected by Falcon’s layered approach to securing customer\nenvironments.\n\n\n-----\n\n**Additional Resources**\n\n_[Visit the product website to learn how the powerful CrowdStrike Falcon platform](https://www.crowdstrike.com/endpoint-security-products/falcon-platform/)_\n_provides comprehensive protection across your organization, workers, data and_\n_identities._\n_[Get a full-featured free trial of CrowdStrike Falcon Prevent™ and learn how true next-](https://www.crowdstrike.com/resources/free-trials/try-falcon-prevent/)_\n_gen AV performs against today’s most sophisticated threats._\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-12-28 - CrowdStrike Strengthens Exploit Protection Using Intel CPU Telemetry.pdf"
    ],
    "report_names": [
        "2021-12-28 - CrowdStrike Strengthens Exploit Protection Using Intel CPU Telemetry.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536029,
    "ts_updated_at": 1743041130,
    "ts_creation_date": 1653713197,
    "ts_modification_date": 1653713197,
    "files": {
        "pdf": "https://archive.orkl.eu/9bb9930b2518346bed5f4107783bbde74a66ac8c.pdf",
        "text": "https://archive.orkl.eu/9bb9930b2518346bed5f4107783bbde74a66ac8c.txt",
        "img": "https://archive.orkl.eu/9bb9930b2518346bed5f4107783bbde74a66ac8c.jpg"
    }
}