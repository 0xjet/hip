{
    "id": "67a0ce5b-9bfe-4275-963d-fbdbba61617a",
    "created_at": "2023-01-12T14:59:14.304704Z",
    "updated_at": "2025-03-27T02:16:59.281022Z",
    "deleted_at": null,
    "sha1_hash": "b16b432e3ab460634e986e9193c086ceb6f7182d",
    "title": "2013-08-01 - Andromeda 2.7 features",
    "authors": "",
    "file_creation_date": "2022-05-28T19:47:56Z",
    "file_modification_date": "2022-05-28T19:47:56Z",
    "file_size": 1475565,
    "plain_text": "# Andromeda 2.7 features\n\n**virusbulletin.com/virusbulletin/2013/08/andromeda-2-7-features**\n\n2013-08-01\n\n### Suweera De Souza\n\nFortinet, Canada\n\n### Neo Tan\n\nFortinet, Canada Editor: Helen Martin\n**Abstract**\n\nA new version of the Andromeda bot was recently spotted in the wild with strengthened self-defence mechanisms and\nnovel methods for keeping its process hidden and running persistently. Moreover, its communication data structure and\nencryption scheme have changed, rendering previous Andromeda IPS/IDS signatures useless. Suweera De Souza and\nNeo Tan take a detailed look at Andromeda 2.7.\n\nRecently, we found a new version of the Andromeda bot in the wild. This version has strengthened its self-defence\nmechanisms by utilizing more anti-debug/anti VM tricks than its predecessors. It also employs some novel methods for\ntrying to keep its process hidden and running persistently. Moreover, its communication data structure and encryption\nscheme have changed, rendering the old Andromeda IPS/IDS signatures useless.\n\nIn this article, we will look at the following:\n\nIts unpacking routine\n\nIts anti-debug/anti VM tricks\n\nIts malicious code injection routine\n\nThe interaction between its twin injected malicious processes\n\nIts communication protocol, encryption algorithm and command control.\n\n## Overview of unpacking routine\n\nThe sample we analysed is firstly packed with UPX. However, once unpacked, the code inside is another custom\npacker. This custom packer creates dynamic memory and decrypts code into this memory (Figure 1). It jumps to a lot of\naddresses by pushing the offset onto the stack and then returning to it. The code in memory calls VirtualAlloc three\ntimes. The first allocated memory is used for storing bytes copied from the original file. Those bytes are then copied\nover to the third allocated memory where they are rearranged by swapping bytes (using the algorithm shown in Figure\n2). Finally, the partially decrypted bytes are copied to the second allocated memory, where the data is decompressed\nusing the aPLib decompression library. The result is a PE file which is then written over the original file image, and the\nanti-debugging tricks are carried out from here. Figure 1 gives an overview of the unpacking routine.\n\n\n-----\n\n**Figure 1. The unpacking process.**\n\n**Figure 2. Algorithm showing how the bytes were swapped.**\n\n## The way to the real routine\n\nThis version of Andromeda employs many anti debug/anti VM tricks, which result in the bot switching to a pre-set fake\nroutine in order to prevent it from running in the VM environment, being debugged or monitored. The purpose is\nobvious: to prevent analysts from being able to access the real malicious routine. In the following sections, we’ll take a\ndetailed look at these defence mechanisms.\n\n### Anti-API hook\n\nThe sample allocates another section of memory for its anti API hooking technique. The technique consists of storing\nthe first instruction of the API to memory, followed by a jump to its second instruction in the DLL.\n\nFor example, in Figure 3, memory location 0x7FF9045E stores the location of memory 0x7FF80060, which is where the\nfirst instruction of the API ntdll.RtlAllocateHeap is stored, followed by a jump to the second instruction in the DLL.\n\n\n-----\n\n**Figure 3. Anti-API hooking.**\n\n### Customized exception handler\n\nA pointer to a handler function is passed to the SetUnhandledExceptionFilter API. The handler is called when an\naccess violation error is intentionally created by the sample when it tries to write into the file’s PE header. The code in\nthe handler is only executed if the process is not being debugged.\n\nThis function (Figure 4) gets the pExceptionPointers >ContextRecord (the second DWORD of arg_0) in order to set the\nlocation of the real payload (sub_401EA5) to the EIP (ebx+0B8h) upon return. It also gets the ESP (ebx+0C4h) and\nthen sets the two arguments which will be passed to the payload function: arg0 to dword_402058 and arg1 to\nsub_401AA2. Dword_402058 points to the encrypted code and sub_401AA2 points to another decryption routine which\nwill be injected by the code decrypted from dword_402058.\n\n**Figure 4. UnhandledExceptionFilter function.**\n\n[(Click here to view a larger version of Figure 4.)](https://www.virusbulletin.com/uploads/images/figures/2013/08/Andromeda-4-large.jpg)\n\n### Anti-VM and anti-forensics\n\n\n-----\n\nThe GetVolumeInformationA API is called on drive C:\\ to get the name of the drive. Then the bot calculates the CRC32\nhash value of the name (Figure 5). If the hash value of the drive name matches 0x20C7DD84, it will bypass all the antidebugging and anti-VM checks and invoke the exception directly. When the CRC32 hash is reversed, one possible\nresult is ‘BVabi’. This could be the name of the author’s C drive, so that he/she could skip all the trouble when\ndebugging his/her own program.\n\n**Figure 5. Checking if the drive name’s CRC32 value is 0x20C7DD84.**\n\nIf the hash value of the drive name doesn’t match, the following anti-debug/anti-VM tricks are employed:\n\n1. Iterating through process names and computing their CRC32 hash values: if a hash value matches any of those\n\non a list of hash values of VM processes (Figure 6) and forensics tools (regmon.exe, filemon.exe, etc.), this\nindicates that the debugging process is inside a sandbox environment and being monitored.\n\n**Figure 6. Matching the process with CRC32 hash values.**\n\n2. Trying to load the libraries guard32.dll and sbiedll.dll, which belong to Comodo and Sandboxie respectively. If the\n\nlibraries can be loaded successfully, this indicates that the debugging process is inside a sandbox environment.\n\n3. Querying for a value in the system\\currentcontrolset\\services\\disk\\enum registry to search for the presence of any\n\nvirtual machine (Figure 7).\n\n**Figure 7. Querying for virtual machines**\n\n4. Calling the opcode rdtsc, which returns the processor time stamp. When first called, it saves it in edx, and the\n\nsecond time it saves it in eax. The registers are subtracted and if the result of the tickcount is more than 0x200h,\nthis indicates that the process is being debugged.\n\nIf the bot does detect the presence of either a debugger or a virtual machine, it decrypts the dummy code. This code\ncopies itself under %alluserprofiles% as svchost.exe with hidden system file attributes. It then writes itself in the registry\nHKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run as SunJavaUpdateSched. A socket is then created to listen\nactively, but no connection has been made previously.\n\n### Data structure of encrypted routine\n\nAs mentioned, the bot will decrypt the code as the next routine, whether dummy code or a useful routine. The\nencrypted code of the file is contained within a specific structure that the file uses when carrying out its decryption\nroutine. In this sample, there are three sets of encrypted code which represent three different routines. One routine\n\n\n-----\n\ncontains dummy code that is decrypted only when the sample is being debugged or run in a virtual machine. The\nsecond routine contains code that injects itself into another process, whereon the third routine is decrypted in that\nprocess. The data structure is shown in Figure 8.\n\n**Figure 8. Data structure used by the bot.**\n\nThe encrypted data, which is located at 0x28h after the structure, is decrypted using RC4. The key used is a fixed\nlength of 0x10h and is located at the beginning of the structure. The decrypted code is further decompressed into\nallocated memory using the aPLib decompression library.\n\n## Twin malicious injected processes\n\nThe bot will inject its core code into two processes after successfully bypassing all the anti-debug/anti-VM tricks. First,\nlet’s see how the malicious code is injected into processes before we shed light on how the two injected processes\ninteract with each other.\n\n### Code injection routine\n\nThe bot calls the GetVolumeInformation API on C:\\, to get the VolumeSerialNumber. It then checks whether the\nenvironment variable ‘svch’ has already been created [1]. If it has, then it will inject itself into svchost.exe. If the\nenvironment variable is not present, it will set the environment variable ‘src’ to point to its own file path and then inject\ninto msiexec.exe. This suggests that the bot injects its code into two different processes at different instances. We shall\nsee why in the next section.\n\nIt then gets the Windows directory. Before injection, the bot needs to find the location of these files (svchost.exe,\nmsiexec.exe) in the Windows directory. Thus, it calls ZwQueryInformationProcess and accordingly concatenates the\nprocess name with \\System32 for 32-bit and \\SysWOW64 for 64-bit systems.\n\nThe injection process involves several steps:\n\n1. As with the previous versions, the malware calls CreateFile to get the handle of the file it wants to inject. It then\n\ngets its section handle by calling ZwCreateSection, which is used by ZwMapViewOfSection to get the image of\nthe file in memory. From this image, it extracts the size of image and the address of the entry point from the PE\nheader.\n\n2. A memory address with the same size as that of the image of the file it wants to inject is created with\n\npage_execute_readwrite access. Then the image of the file is copied over to this memory address.\n\n3. Another memory address is created with the same size as that of the image of the original bot file, also with\n\npage_execute_readwrite access. The original file is then copied over to this new memory address.\n\n\n-----\n\n4. A suspended process of the file to be injected is created. The memory address containing the original file is\n\nunmapped. ZwMapViewOfSection is called with the bot’s file handle and the process handle (acquired from\ncreating the suspended file process). So now the injected file’s process handle has a map view of the botnet file.\nBefore it calls ResumeThread to resume the process, it changes the entry point of the injected file to point to its\ncode, which it has modified as follows:\n```\n   push <address of botnet code to jump to>\n   ret\n\n### Twin process interaction\n\n```\nThe code that is injected into the process decrypts more code into memory using the methods described in the\nprevious section. This final decrypted code is the commencement of the botnet’s payload. In this version, Andromeda\ndisplays some new techniques in its execution.\n\nFirst, it modifies the registry entry\nHKLM\\system\\currentcontrolset\\services\\sharedaccess\\parameters\\firewallpolicy\\standardprofile\\authorizedapplications\\list\nto the value of %s:*:Generic Host Process, which points to the path of the current process. This is done to allow the\nprocess to bypass the firewall.\n\nNext, it tries to determine whether the environment variable ‘svch’ has been set. If it has, it means that another instance\nof the file has been run. If it has not been set, then the malware has yet to inject itself into the other process.\n\nThe creation of two processes is important for the bot. One process is used to make sure that the copy of the bot which\nwill be created in %alluserprofile% is always present and that the registry entries have not been modified. The second\nprocess is used for connecting to the C&C server and executing instructions based on the messages received.\nAdditionally, the two processes communicate with each other through an instance of creating a pipe connection. It is\nthis connection that enables either process to check that both instances of the bot are always running or to terminate\nthe processes in the event of an update or installation. The analysis of this part has been divided into Process 1 and\nProcess 2, so as to better understand the communication between the two processes (Figure 9).\n\n**Figure 9. The flow of communication between the two bot processes.**\n\n[(Click here to view a larger version of Figure 9.)](https://www.virusbulletin.com/uploads/images/figures/2013/08/Andromeda-9-large.jpg)\n\n### Process 1 (installation routine and watchdogs)\n\nThis part of code is executed when the environment variable ‘svch’ has not been found. The bot tries to connect to the\npipe name, which is ‘kill’ xor’ed by the VolumeSerialNumber. If it can connect, then the bot terminates the other\nprocess. This thread is created as a check to terminate the other bot process in the event of an installation.\n\n\n-----\n\nIt then tries to get the environment variable src, which was created before injection. The value contains the path from\nwhich the original file was run. It uses this path to create a copy of the original file before deleting it, and saves it in\n%alluserprofile% with a random filename.\n\nNext, the bot wants to enable the file to autorun, so it saves the path of the file in %alluserprofile% in the registry. At\nfirst, it tries to access the subkey \\software\\microsoft\\windows\\currentversion\\Policies\\Explorer\\Run in registry HKLM. If\nit is unsuccessful, it accesses the subkey \\software\\microsoft\\windows nt\\currentversion\\windows in HKCU. The registry\nthat it accesses successfully is the one that is used throughout for any modifications (explained in pseudo code in\nFigure 10). Once it has accessed the registry, it sets the security key of the registry to KEY_ALL_ACCESS. The\nsecurity key is obtained by passing the string ‘D:(A;;KA;;;WD)’ to the\nConvertStringSecurityDescriptorToSecurityDescriptorA API, which converts it to a security key. Once it has set the\nsecurity key, it saves the path of the new file to the registry under the value of VolumeSerialNumber (for HKLM) or Load\n(for HKCU). The original file in the old path is deleted and the environment variable ‘src’ is set, pointing to 0.\n\n**Figure 10. Pseudo code of registry chosen.**\n\nAfter this, the bot creates two watchdog threads which are primarily used to keep re-setting the file and the registry\nentries if they have been modified. The first thread checks if any modification has been made to the filename in\n%alluserprofile%, or if it has been deleted. Then it creates the file again with the same filename. It accomplishes this by\nfirst saving the file to the buffer by calling ReadFile. Then it calls the FindFirstChangeNotificationW API, whose handle\nwill retrieve the changes made to the filename. If the handle is 0xFFFFFFFF, then no changes have been made, and it\nenters a loop. If a change has been notified, then it creates the file again with the same filename, and writes the\ncontents of the file back from the buffer created by ReadFile.\n\nThe second thread checks if any changes have been made to a value in the registry. If a change has been made, then\nit resets the registry security key and the value in the registry. Notification of changes made to the registry is set by\ncalling RegNotifyChangeKeyValue.\n\nThe bot then creates two environment variables – ‘ppid’, pointing to its process ID, and ‘svch’ with the value of 1. It then\nruns the file that has been created in %alluserprofile%. After running the file, it tries to connect to the pipe ‘kill’ xor’ed by\nthe VolumeSerialNumber. Since the value of svch has been set to 1, the second process will create a thread that\ncreates the named pipe connection and executes a second thread to connect to the C&C server. When the first process\ncan connect successfully to the pipe connection created by the second process, it resets the environment variables\n‘svch’ and ‘ppid’ to 0.\n\n### Process 2 (core routine)\n\nWhen the bot is run in another process, it sets the environment variable ‘svch’ to 0. A thread is created that creates a\nnamed pipe. If a connection is established, the thread reads the bytes that are written from the other process. If the\nmessage is ‘kill’ xor’ed by VolumeSerialNumber, the process terminates. However, if the message is ‘gpid’, then it\nsends its current process ID to the first process. This information is used by the old process to access information\nabout the new process when the new process terminates. When the new process terminates, the old process checks\nthe handle of the process. If the message is ‘kill’ xor’ed by VolumeSerialNumber, then the old process terminates. This\ncheck is made when the bot wants to update itself and hence has to make sure that the watchdog threads have been\nterminated. Otherwise, the old process terminates the new process and runs the file in %alluserprofile% again.\n\nAfter the new process has created its thread to connect to the C&C server, it will get the ‘ppid’ environment variable.\nThis variable contains the process ID of the old process. Like the old process, it uses this information to access when\nthe old process terminates. And if the message is ‘kill’ xor’ed by VolumeSerialNumber, then the new process\nterminates. This check is performed when an installation is taking place. Otherwise, the new process runs the file in\n%alluserprofile% and terminates itself.\n\n\n-----\n\nFigure 11 shows how the process IDs are used by the processes.\n\n**Figure 11. Process IDs used by the processes.**\n\nThe second thread created by the new process carries out some further code injection. It first resolves winhttp.dll APIs\nusing the anti-API hooking technique and also inline hooks three APIs: ws2_32.GetAddrInfoW (Figure 12 and Figure\n13), ntdll.ZwMapViewOfSection and ntdll.ZwUnmapViewOfSection. The control flow of the APIs is redirected by\ninserting a jump to the malicious function. Before writing to the API, it calls VirtualProtect. After the bytes have been\nwritten, it calls FlushInstructionCache so that the changes take effect immediately.\n\n**Figure 12. Before inline hooking GetAddrInfoW.**\n\n**Figure 13. After inline hooking GetAddrInfoW.**\n\nIt then calls QueueUserAPC, which creates an asynchronous procedure call object. This object points to the code\nwhich decrypts some encrypted strings using RC4 decryption (Figure 14). These encrypted strings are the domains it\nintends to connect to. Before each decrypted string, it inserts the DWORD 0x6C727501 xor’ed by\nVolumeSerialNumber, which is ASCII for URL. This magic DWORD is used when it calls the RtlWalkHeap API to\nretrieve the domain names from the heap.\n\n**Figure 14. The decrypted domain names (now offline).**\n\n## Communication protocol, encryption algorithm\n\n\n-----\n\n### Create connections\n\nThe hooked GetAddrInfoW API performs a DNS query for the input host name from Google DNS server 8.8.4.4 (Figure\n15) using a randomly generated query identifier. It then returns the query result or ‘127.0.0.1’ if the DNS query fails. The\nDNS record received is then used for querying the C&C domain name. It does this to avoid any application level DNS\nserver redirection. The hooked ZwMapViewOfSection and ZwUnmapViewOfSection APIs will be used later to\nmap/unmap the plug in image downloaded from the C&C server.\n\n**Figure 15. Hard-coded Google DNS server IP in the GetAddrInfoW hooked function.**\n\n### Communication protocol and encryption algorithm\n\nBefore establishing a connection, the bot prepares the message to be sent to the C&C server. It uses the following\nformat:\n```\nid:%lu|bid:%lu|bv:%lu|os:%lu|la:%lu|rg:%lu\n\n```\nid is the VolumeSerialNumber, which is used as an RC4 key to decrypt the message received\n\nbid is a hard coded DWORD used for the communication\n\nbv is the version of the botnet (in this case it is 2.7)\n\nos is the version of the current operating system\n\nla is the socket name byte swapped\n\nrg is set to 1 if the process is in the Administrator group, otherwise it is 0 (Figure 16).\n\n\n-----\n\nThis string is encrypted using RC4 with a hard coded key of length 0x20 and is further encrypted using base64. The\nmessage is then sent to the server. Once a message is received, the bot calculates the CRC32 hash of the message\nwithout including the first DWORD (Figure 16). If the calculated hash matches the first DWORD, the message is valid.\nLater it is decrypted using RC4 with the VolumeSerialNumber as the key. After the RC4 decryption the message is in\nthe format gn([base64-encoded string]). This used to be just the base64 encoded string, but for some reason the author\ndecided not to make the server backward compatible with the older bot versions. Then it decodes the base64 string\ninside the brackets to get the message in plain text (Figure 17).\n\n**Figure 16. First DWORD of message received containing the CRC32 hash value.**\n\n**Figure 17. Message received from the server.**\n\nThe first DWORD of the message is used as a multiplier to multiply a value in a fixed offset. The DWORD in that offset\nis used as an interval to delay calling the thread again to establish another connection. The next byte indicates what\naction to carry out – there are seven options:\n\nCase 1 (download EXE):\n\nConnect to the domain decrypted from the message to download an EXE file. Save the file to the %tmp% location\nwith a random name and run the process.\n\nCase 2 (load plug-ins):\n\nConnect to the domain decrypted from the message, install and load plug ins. The plug ins are decrypted by RC4\nusing the same key of length 0x20h.\n\nCase 3 (update case):\n\nConnect to the domain to get the update EXE file. If a filename of VolumeSerialNumber is present in the registry,\nthen save the PE file to the %tmp% location with a random name; else save it to the current location with the\nname of the file as VolumeSerialNumber. The file in %tmp% is run, while the current process terminates. It also\nsends the message ‘kill’ xor’ed by VolumeSerialNumber to terminate the older process.\n\nCase 4 (download DLL):\n\nConnect to the domain and save the DLL file to the %alluserprofile% location. The file is saved as a .dat file with a\nrandom name and loaded from a specified export function. The registry is modified so it can be auto-loaded by\nthe bot.\n\nCase 5 (delete DLLs):\n\nDelete and uninstall all the DLLs loaded and installed in Case 4.\n\nCase 6 (delete plug-ins):\n\nUninstall all the plug-ins loaded in Case 3.\n\n\n-----\n\nCase 7 (uninstall bot):\n\nSuspend all threads and uninstall the bot.\n\nAfter executing the action based on which instruction it received, another message is sent to the server to notify it that\nthe action has been completed:\n```\nid:%lu|tid:%lu|res:%lu\n\n```\nid is the VolumeSerialNumber\n\ntid is the next byte (task id) after the byte displaying the case number in the message received\n\nres is the result of whether or not the task was carried out successfully.\n\nOnce the message has been sent, the thread exits and waits for the delay interval period to pass before it reconnects\nto the server to receive additional instructions.\n\n## Conclusion\n\nThis new version of the Andromeda bot has demonstrated its tenacity by executing code that ensures every instance of\nits process is kept running and by employing more anti debug/anti VM tricks than its previous version. However, it is still\npossible to bypass all those tricks once we have complete knowledge of its executing procedures. Moreover, we could\neasily block its communication data after addressing the decryption performance issue.\n\n### Bibliography\n\n[1] All the environment variables used in this version of Andromeda are encrypted using xor on the\nVolumeSerialNumber, which the file acquires by calling GetVolumeInformationA on drive C:\\. The bot employs this\ntechnique as a way of specifying its status in the machine. ‘svch’ is a flag if the process is injected into svchost.exe;\n‘src’ stores the location of the file; ‘ppid’ stores the first process ID;‘gpid’ stores the second process ID.\n\n[2] Tan, N. Andromeda Botnet. Virus Bulletin, June 2012, pp.5–11.\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order to infiltrate organizations’\ndedicated environments and transform them into attack launchpads. In this article Aditya Sood presents a new module\nintroduced by…\n\n### Collector-stealer: a Russian origin credential and information extractor\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to exfiltrate sensitive data from\nend-user systems and store it in its C&C panels. In this article, researchers Aditya K Sood and Rohit Chaturvedi\npresent a 360…\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and from that moment onward,\nwas intrigued by the properties of these small pieces of self-replicating code. Joe Wells was an expert on computer\nviruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\n\n-----\n\nKurt Natvig wanted to understand whether it s possible to recompile VBA macros to another language, which could then\neasily be ‘run’ on any gateway, thus revealing a sample’s true nature in a safe manner. In this article he explains how\nhe recompiled…\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware, discussing his team's findings\nrelated to the C&C design and some security issues they identified during the research.\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\n_Copyright © 2013 Virus Bulletin_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2013/2013-08-01 - Andromeda 2.7 features.pdf"
    ],
    "report_names": [
        "2013-08-01 - Andromeda 2.7 features.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535554,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1653767276,
    "ts_modification_date": 1653767276,
    "files": {
        "pdf": "https://archive.orkl.eu/b16b432e3ab460634e986e9193c086ceb6f7182d.pdf",
        "text": "https://archive.orkl.eu/b16b432e3ab460634e986e9193c086ceb6f7182d.txt",
        "img": "https://archive.orkl.eu/b16b432e3ab460634e986e9193c086ceb6f7182d.jpg"
    }
}