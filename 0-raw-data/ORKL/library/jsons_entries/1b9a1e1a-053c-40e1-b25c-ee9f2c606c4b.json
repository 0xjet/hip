{
    "id": "1b9a1e1a-053c-40e1-b25c-ee9f2c606c4b",
    "created_at": "2023-01-12T15:02:05.878855Z",
    "updated_at": "2025-03-27T02:16:25.893896Z",
    "deleted_at": null,
    "sha1_hash": "f4d1a9b493c4d2b745140ea4a91204359735506d",
    "title": "2020-02-24 - MMD-0066-2020 - Linux-Mirai-Fbot - A re-emerged IoT threat",
    "authors": "",
    "file_creation_date": "2022-05-29T01:00:47Z",
    "file_modification_date": "2022-05-29T01:00:47Z",
    "file_size": 4124078,
    "plain_text": "# MMD-0066-2020 - Linux/Mirai-Fbot - A re-emerged IoT threat\n\n**[blog.malwaremustdie.org/2020/02/mmd-0065-2021-linuxmirai-fbot-re.html](https://blog.malwaremustdie.org/2020/02/mmd-0065-2021-linuxmirai-fbot-re.html)**\n\nChapters: [TelnetLoader] [EchoLoader] [Propagation] [NewActor] [Epilogue]\n\n## Prologue\n\nA month ago I wrote about IoT malware for Linux operating system, a Mirai botnet's client\n[variant dubbed as FBOT. The writing [link] was about reverse engineering Linux ELF ARM](https://blog.malwaremustdie.org/2020/01/mmd-0065-2020-linuxmirai-fbot.html)\n**32bit to dissect the new encryption that has been used by their January's bot binaries,**\n\nThe threat had been on vacuum state for almost one month after my post, until now it comes\nback again, strongly, with several technical updates in their binary and infection scheme, a\nre-emerging botnet that I detected its first come-back activities starting from on February 9,\n**2020.**\n\nThis post is writing several significant updates of new Mirai FBOT variant with strong\nspreading propagation and contains important details that have been observed. The obvious\nMirai variant capabilities and some leak codes' adapted known techniques (mostly from other\nMirai variants) will not be covered.\n\nThis is snippet log of FBOT infection we recorded, as a re-emerging \"PoC\" of the threat:\n\n## The changes in infection activity\n\n\n-----\n\nInfection method of FBOT has been changed to be as per shown below, taken from log of\nthe recent FBOT infection session:\n\nAs you can see, there are \"hexstrings\" blobs pushed into the compromised IoT on a telnet\n**CLI connection. That hexstrings is actually a small ELF binary adjusted to the architecture**\nof the infected device (FBOT has a rich binary factory to infect various Linux IOT supported\nCPU), to be saved as a file named \"retrieve\". This method is significantly new for Mirai\nFBOT infection, and other infection methods (in their scanner funcion) is more or less similar\nto their older ones. Mirai FBOT seems not to drop the legacy infection methods they use too,\nand the adversary is adding \"hexstring push\" way now to increase the bot client's infection\nprobability. I will cover some more changes in the next section.\n\n## The binary analysis\n\nIn this part we will analyze two binaries of the recent FBOT. One is the pushed hextstrings\none with the ELF format is in ARM v5 32bit little-endian. And for the other ELF, in this post I\nam picking up the Intel 64bit binary, since my recent blogs and image-posts are all covering\nenough ARM or MIPS.\n\n## 1. ARM 32bit ELF downloader (the \"telnet\" loader) in pipes\n\nThe pushed-hexstrings is saved as file called \"retrieve\" which is actually a downloader for\nthe Mirai FBOT bot client binary. It was not the smallest downloader I've seen in ELF\nsamples all of these years but it does the job well. The binary is having this information:\n\n\n-----\n\n```\nretrieve: ELF 32 bit LSB executable, ARM, EABI4 version 1 (SYSV), \n     statically linked, stripped\nMD5 (retrieve) = d0a7194be28ce86fd68f1cc4fb9f5d42\nSHA1 (retrieve) = c98c28944dc8e65d781c8809af3fab56893efeef\n1448 Feb 23 03:04 retrieve\n\n```\nSmall enough to put all strings in binary in a small picture :)\n\nThe binary is a plain and straight ELF file, with normal headers intact, without any packing\nand so on, it contains the main execution part which is started at virtual address 0x838c and\nit will right away call to 0x81e8 where the main activity are coded:\n```\n/ 388: entry0 ();\n|    |  ; var int32_t var_14h @ sp+0x84\n|    |  ; var int32_t var_12h @ sp+0x86\n|    |  ; var int32_t var_10h @ sp+0x88\n|    `=< 0x0000838c   95ffffea    b 0x81e8\n- - - - - - - - - - \n[0x000081e8]> pd\n|  ; CODE XREF from entry0 @ 0x838c\n|  0x000081e8 f0412de9 push {r4, r5, r6, r7, r8, lr}\n|  0x000081ec 74319fe5 ldr r3, [aav.aav.0x000083fd] \n|  0x000081f0 98d04de2 sub sp, sp, 0x98\n|  0x000081f4 0080a0e3 mov r8, 0\n:  0x000081f8 000000ea b 0x8200\n   :      :\n\n```\nThe other part is the data, where all values of variables are stored. it is located from virtual\naddress 0x83f4 at section..rodata (0x83fc), as per shown below:\n\n\n-----\n\nTo call the saved data the ELF is using below loader scheme that has been arranged by the\ncompiler:\n\nTo be noted that this scheme is unrelated to the malicious code itself.\n\nNext, the malware is stripped, so in radare2 you will see the name like \"fcn.00008xxx\", for\nevery function names, from the original function coded by the mal-coder, the used Linux calls\nand the system calls. So, at first, we have to put the right naming to the right function if we\n[can (Please check out my previous blog about Linux/AirDrop [link] for this howto reference).](https://blog.malwaremustdie.org/2019/09/mmd-0064-2019-linuxairdropbot.html)\nIn my case, I restored its naming to the correct location, as per shown in the table like this:\n\n\n-----\n\nNow we can start to read the code better, the next thing to do is writing the close-to-original\nC-code by adjusting several ARM assembly to form the code. Remember to be careful if you\nuse the decompilers, you still have to recognize several parts that can not be processed\nautomatically, in example, in DFIR distro Tsurugi Linux which is having radare2 precompiled\nwith three versions of decompiler plugins, you will see a cool result like this from r2ghidra**dec, r2dec and pdc.**\n\n_I will demonstrate this Linux distribution in the FIRST annual conference 2020 at the lighting_\n_talk, so please stay tune._\n\nAfter you put your naming to each functions, and try to form the original code by the\nguidance of your decompiler, then try to re-check again to your binary flow. This binary is\nquite small but it has several error trapping checks in the step of execution, please make\nsure you don't miss them.\n\nIn my case I reversed the source code to be something like this:\n\n\n-----\n\nAt this moment we can understand how it works, after firstly confirming the binary is for\n**ARM5, it wrote \"MIRAI\" and creating socket for TCP connection to remote IP**\n**194(.)180(.)224(.)13 to fetch the download URL of the bot binary payload. And it open the**\n**\".t\" file with the specific file executable permissions, then saved the received data into that**\nfile. Upon socket creation error, or C2 connection error, or file creation error, or also data\nretrieving error, this program will just quit after writing \"NIF\", and upon a success effort it will\nwrite \"FIN\", close its working sockets and quit. A neat downloader is it? Simple, small and\ncan support many scripting effort too, along with merit to hide its payload source, why Mirai\nbotnet original author was using this type of binary loaders in the first place.\n\nThe code I reversed won't work if used, since it is a pseudo code, compiler won't process it,\nbut it is enough to explain how this binary operates, and also explains where is the origin of\nthis program too. I know this by experience since I have been dissecting and following Mirai\n[from the day one [0][1][2][3][4], but this downloader is based on Mirai downloader that has](https://en.wikipedia.org/wiki/Mirai_(malware))\nbeen modified by a certain actor, again a leaked code is proven recycling.\n\nFor the practical purpose to fast extracting the payload URL in this type of FBOT loader, I\nmade a very practical reversing crash course in 4 minutes for the purpose as per embedded\nbelow:\n\n_(pause the video by pressing space or click the video screen)_\n\n## 2. x86-64 ELF bot client, what's new?\n\n\n-----\n\nNow we are done with the first binary, so it is the turn of the next binary. In the download\nserver at the path of payloads resides several architecture of binaries too. That's where I\npicked the ELF x86_64 one for the next reversing topic. The detail is as follows:\n```\nbot.x86_64: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), \n      statically linked, stripped\nMD5 (bot.x86_64) = ae975a5cdd9fb816a1e286e1a24d9144\nSHA1 (bot.x86_64) = a56595c303a1dd391c834f0a788f4cf1a9857c1e\n31244 Feb 23 20:09 bot.x86_64*\n\n```\nLet's check it out..\nThe header and entry0 (and entropy values if you check further) of the binary is showing the\nsign of packed binary design.\n\n\n-----\n\n```\nProgram Headers:\nType   Offset       VirtAddr      PhysAddr\n     FileSiz      MemSiz       Flags Align\nLOAD   0x0000000000000000 0x0000000000400000 0x0000000000400000\n     0x000000000000790c 0x000000000000790c R E  200000\nLOAD   0x0000000000000e98 0x000000000060fe98 0x000000000060fe98\n     0x0000000000000000 0x0000000000000000 RW   1000\nGNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000\n     0x0000000000000000 0x0000000000000000 RW   8\n[Entrypoints]\nvaddr=0x004067d0 paddr=0x000067d0 haddr=0x00000018 hvaddr=0x00400018 type=program\n/ 2701: entry0 (int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4, int64_t\narg_10h);\n| ===> 0x004067d0  e8cb0b0000   call 0x4073a0 <===to unpacking\n|   0x004067d5  55       push rbp\n|   0x004067d6  53       push rbx\n|   0x004067d7  51       push rcx   \n|   0x004067d8  52       push rdx   \n|   0x004067d9  4801fe     add rsi, rdi \n|   0x004067dc  56       push rsi   \n|   0x004067dd  4180f80e    cmp r8b, 0xe \n|,=< 0x004067e1  0f85650a0000  jne 0x40724c\n: :  0x004067e7  55       push rbp\n      :     :\n- - - - - - - - - - - - - - - - - - - - - - - \n/ 34: fcn.004073a0 (); <== unpacking function\n|   ; var int64_t var_9h @ rbp-0x9\n|   0x004073a0  5d       pop rbp\n|   0x004073a1  488d45f7    lea rax, [var_9h]\n|   0x004073a5  448b38     mov r15d, dword [rax]\n|   0x004073a8  4c29f8     sub rax, r15\n|   0x004073ab  0fb75038    movzx edx, word [rax + 0x38]\n|   0x004073af  6bd238     imul edx, edx, 0x38\n|   0x004073b2  83c258     add edx, 0x58        ; 88\n|   0x004073b5  4129d7     sub r15d, edx\n|   0x004073b8  488d0c10    lea rcx, [rax + rdx]\n|   0x004073bc  e874ffffff   call fcn.00407335   \n:       :    :      :\n\n```\n\n-----\n\nThe binary snippet code:\n\nThe unpacking process will load the packed data in 0x004073c2 for further unpacking\nprocess. You can check my talk in the R2CON 2018 [[link] about many tricks I shared on](https://blog.malwaremustdie.org/p/new-video-of-this-talk-has-just-been.html)\nunpacking ELF binaries for more reference to handle this binary.\n\nAfter unpacking you will get a new binary with characteristic similar to this:\n```\nfbot2-depacked: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), \n        statically linked, stripped\nMD5 (fbot2-depacked) = bf161c87d10ecb4e5d9b3e1c95dd35da\nSHA1 (fbot2-depacked) = 3aecd1ae638a81d65969c2e0553cfacc639f32a6\n58557 Feb 23 13:03 fbot2-depacked\n\n```\n\n-----\n\nIf you will see these strings that means you un-packed (or de-pakced) successfully.\n\nIn the string above you can see the matched data with the infection log, which is telling us\nthat this binary is actually infecting and attacking another IoT device for the next infection.\nYou can see that hardcoded in teh binary in this virtual address:\n\nThe binary is working similar to older Mirai variants like Satori, Okiru or others, and having\nseveral ELF downloaders embedded in the bot client to be pushed during the infection\nprocess to the targeted devices. It is hard coded as per seen in this data:\n\n\n-----\n\n-----\n\nThe encrypted data part can be seen in this virtual address of the unpacked ELF:\n\nThis is where the pain coming isn't it? :) Don't worry, I will explain:\n\nThe decryption flow is not changing much, however the logic for encryption is changing. It\nseems the mal-coders doesn't get their weakness yet and tried fixing a wrong part of the\ncodes to prevent our reversing. Taking this advantage, you can use my introduced decryption\n[dissection method explained in the previous post about Linux Mirai/FBOT [link] to dissect this](https://blog.malwaremustdie.org/2020/01/mmd-0065-2020-linuxmirai-fbot.html)\none too. It works for me, should work for you as well.\n\n\n-----\n\nBelow is my decryption result for encrypted configuration:\n\nThe binary will operate as per commonly known Mirai variant bots, it will listen to TCP/3467\nand callback to C2 at 194(.)36(.)188(.)157 on TCP/4321 for the botnet communication\npurpose, and as per other Mirai variants the persistence factor is in the botnet\ncommunication. There are some parts taken from Satori and Okiru for embedding\n_downloaders to be used in victim's IoT. The unique feature is the writing for_\n**\"9xsspnvgc8aj5pi7m28p\\n\" strings upon execution. This bot client is enriched with more**\nscanner functions (i.e. hardcoded SSDP request function to scan for plug-and-play devices\nthat can be utilized as DDoS amplification, in Mirai this attack will use spoofed IP address of\nthe victims to launch attack).\n\nFor getting more idea of what this binary does, the strings from the unpacked binary I\ndumped it [here in a safe](https://pastebin.com/qDdkEGFH) _pastebin source file. Combine the strings that I dumped from_\nunpacked binary with the packed one under different sub_rules, and use the hardcoded\nunpacking functions opcodes for your Yara rules to detect this packer, hashes and IP from\nthis post are useful also for IOC/Yara detection. VirusTotal can help to guide you more\nOSINT for the similar ones.\n\nI think that will be all for FBOT new binary updates. So let's move on to the much more\nimportant topic..reversing the botnet instance itself, how is the speed, spreads and how big,\nto understand how to stop them.\n\n## The \"worrisome\" infection speed, evasion tricks and detection ratio problem\n\n**1. Infection and propagation rates of new FBOT**\n\n\n-----\n\nThe new wave of infection of the new version is monitored rapidly, and the sign is not so\ngood.\n\nSince the firstly detected until this post was started to be written (Feb 22), FBOT was having\n**almost 600 infection IP addresses, and due to low scale network monitoring we have, we**\ncan expect that the actual value of up to triple to what we have mentioned. Based on our\nmonitoring the FBOT has been initially spread in the weaker security of IoT infrastructure\nnetworks in the countries sorted as per below table:\n\nIn the geographical map, the spotted infection as per February 22, 2020 is shown like this:\n\nThe IP addresses that are currently active propagating Linux Mirai FBOT infection up to\n[February 22, 2020 can be viewed as a list in this safe](https://pastebin.com/8n9G964c) _pastebin link, or as_ full table with\nnetwork information.\n\n\n-----\n\nThe IP counts is growing steadily, please check and search whether your network s IoT\ndevices are affected and currently became a part of Mirai FBOT DDoS botnet. The total\ninfection started from around +/- 590 nodes, and it is increasing rapidly to +/- 930 nodes\nwithin less than 48 hours afterwards from my point of monitoring. I will try to upgrade the\ndata update more regularly.\n\n**2. Update information on FBOT propagation speed (Feb 24, 2020)**\n\nI just confirmed the infection nodes of FBOT is growing rapidly from February 22 to February\n24, 2020. Within less than 48 hours the total infected nodes is raising from +/- 590 nodes to\n+/- 930 nodes. In the mid February 25 the total infection is 977 nodes. After the botnet\ngrowth disclosure the speed of infection has dropped from average 100 nodes new infection\nto 20 devices per day, concluded the total botnet of infected IP on March 2, 2020 is +/- 1,410\ndevices.\n\nThe speed of infection is varied in affected networks (or countries), and that is because the\naffected device topology is different. I managed to record the growth of the nodes from my\npoint of monitoring under the table shown below from top 15 infection rank, we will try the\nbest to update this table.\n\n\n-----\n\n```\nMirai FBOT Infection growth,\nFrom Feb 22 to Feb 25, 2020 JST   \n------------------------------------------Country Feb22  Feb24  Feb25   Feb25\n              (day)  (night)\n     (582)  (932)  (977)  (1086)\n------------------------------------------Taiwan  190  => 284 => 302  => 340\nHongKong 107  => 132 => 132  => 140\nVietnam 109  => 134 => 135  => 139\nKorea   6  =>  74 =>  84  => 104\nChina   40  =>  74 =>  79  =>  93\nRussia  14  =>  29 =>  31  =>  35\nBrazil  19  =>  27 =>  28  =>  30\nSweden  13  =>  26 =>  26  =>  27\nIndia   7  =>  21 =>  22  =>  24\nUSA    15  =>  17 =>  17  =>  20\nUkraine  4  =>  14 =>  15  =>  15\nPoland   7  =>  10 =>  10  =>  10\nTurkey   0  =>  4 =>  6  =>  9\nRomania  4  =>  6 =>  7  =>  7\nItaly   3  =>  6 =>  6  =>  6\nCanada   4  =>  5 =>  5  =>  6\nNorway   3  =>  5 =>  5  =>  6\nSingapore 3  =>  5 =>  5  =>  6\nColombia  1  =>  4 =>  4  =>  6\nFrance   2  =>  4 =>  5  =>  5\n-----------------------------------------Average spread speed = +/- 100 nodes/dayas per Feb 25, 2020 - malwaremustdie,org  \n\n```\nThe February 24, 2020 Mirai FBOT infection information update (mostly are IoT's nodes), in\n[a list of unique IP addresses can be viewed in ==>[here].](https://pastebin.com/vvdtvwsD)\n[For the network information of those infected nodes can be viewed in ==>[here].](https://gist.github.com/unixfreaxjp/0b3e44a58dce33a3a41855da521a8128)\n\nThe February 25 (daylight/JST), 2020 Mirai FBOT infection information update, in a list of\n[unique IP addresses can be viewed in ==>[here].](https://pastebin.com/r5pxcBay)\n[For the network information of those infected nodes can be viewed in ==>[here].](https://gist.github.com/unixfreaxjp/be7fde13bcc43bc6d3e7fa9c8ea96f96)\n\nThe February 25 (midnight/JST), 2020 Mirai FBOT infection information update, in a list of\n[unique IP addresses can be viewed in ==>[here].](https://pastebin.com/BR274XZ9)\n[For the network information of those infected nodes can be viewed in ==>[here].](https://gist.github.com/unixfreaxjp/cf5a7845baa47579b6d0736b9c7a20d4)\n\nOn February 26, 2020 Mirai FBOT botnet has gained new 128 nodes of additional IOT IP, I\n[listed those in ==>[here]](https://gist.github.com/unixfreaxjp/557273ec855d90ea92913865f79946e1)\n\nOn February 27, 2020 Mirai FBOT botnet has gained new 74 nodes of additional IOT IP, I\n[listed those in ==>[here]](https://gist.github.com/unixfreaxjp/c1e2549842ba7523f8c5b860b3b7d181)\n\n\n-----\n\nOn March 2, 2020 Mirai FBOT botnet has infected 1,410 nodes of IoT devices all over the\n[globe. I listed those networks in here ==>[here] for the incident handling purpose, if we](https://gist.github.com/unixfreaxjp/7a7c546274b6ff9c7d529d9411db0b6d)\nbreakdown the data per country it will look as per info below:\n\nLast status of [#Mirai](https://twitter.com/hashtag/Mirai?src=hash&ref_src=twsrc%5Etfw) [#Fbot infection:](https://twitter.com/hashtag/Fbot?src=hash&ref_src=twsrc%5Etfw)\nHit cycle total = 5177\nActual alive IP = 1404\nRank:\nTaiwan: 432\nVietnam: 186\nS.Korea: 155\nHongKong: 149\nPRC/China: 126\nRussia: 50\nIndia: 39\nBrazil: 36\nSweden: 31\nUnited States: 27\nUkraine: 17\nTurkey: 10\nPoland: 10\n[Japan: 10#MalwaremustDie](https://twitter.com/hashtag/MalwaremustDie?src=hash&ref_src=twsrc%5Etfw)\n\n[— ☩MalwareMustDie (@malwaremustd1e) March 2, 2020](https://twitter.com/malwaremustd1e/status/1234306694416494592?ref_src=twsrc%5Etfw)\n\nIn the above data you see the \"hit cycle\" values, which is a value explaining the frequency of\nthe botnet infected IoT in trying to infect other devices and recorded.\n\nThe latest renewed data we extracted is on March 4, 2020, where Mirai FBOT botnet has\n[infected 1,430 nodes of IoT devices. I listed their IP addresses in here ==>[link] with the](https://pastebin.com/SyceY8JF)\n[network info is in here ==>[link]. This is our last direct update for the public feeds since the](https://gist.github.com/unixfreaxjp/97f8d74088a2255c417717cb8fe508ef)\nprocess is taking too much resources, and the next of data can only be accessed at IOC\nsites.\n\nIf you would like to know what kind of IOT devices are infected by Mirai Fbot malware, a nice\nhowto in extracting those device information is shared by Msr. Patrice Auffret (thank you!)\n[of ONYPHE (Internet SIEM) in his blog post ==>[link].](https://www.onyphe.io/blog/analyzing-mirai-fbot-infected-devices-found-by-malwaremustdie/)\n\nThe maximum nodes of Mirai FBOT botnet in the past was around five thousands nodes,\nwe predicted this number (or more) is what the adversaries are aiming now in this newly\nreleased campaign's variant. However, after the awareness and analysis post has been\n\n\n-----\n\npublished the growth ratio of the new Fbot botnet is starting to drop. The overall volume and\ngrowth for this new Mirai Fbot variant can be viewed as per below graph:\n\nIn order to reduce the threat from escalation process, it would be hard to block the whole\nscope of the infected IoT networks, but one suggested effective way to mitigate this threat is\nmaking efforts to clean them up first from the infection, and then control the IoT infrastructure\ninto always be into recent secure state along with replacing their firmware, or even their\nhardware if needed. If you don't take them under your control, sooner or later the adversaries\nwill come and they will do that in their botnet.\n\n**3. About the C2 nodes**\n\nThe C2 hosts, which are mostly serving the Mirai FBOT payloads and panels, are highly\n**advisable for the blocking and further legal investigation. The C2 IP address data, their**\nactivity and network information that has been detected from our point is listed in a\nchronological activity time line as per below detail:\n\n\n-----\n\n[A month ago, when I wrote about the new encryption of Mirai Fbot [link], the C2 nodes were](https://blog.malwaremustdie.org/2020/01/mmd-0065-2020-linuxmirai-fbot.html)\nspotted in the different locations as per listed in the below table, and even now you can also\nstill see the older version of Mirai Fbot malware running on infected IoT too, that has not\nbeen updated to new variant are having traffic to these older C2:\n\n_This information is shared for the incident and response follow up and IoT threat awareness_\n_purpose to support mitigation process at every affected sides. At this moment we saved the_\n_timestamp information privately due to large data, to be shared through ISP/Network_\n_CSIRT's routes._\n\n4. The detection ratio, evasion methods, IOC & what efforts we can do\n\nThe detection ratio of the packed binary of new Linux Mirai FBOT is not high, and contains\nmisinformation. This is caused by the usage of packer and the encryption used by the\n[malware itself. The current detection ratio and malware names can be viewed in [this URL]](https://www.virustotal.com/gui/file/07bf82f007ccb4b8bf455c67837606c738b8d9f4ec0ab85f36793470967900c0/community)\nor as per screenshot below:\n\n\n-----\n\nIn the non-intel architecture the detection ratio can be as bad as this one:\n\nSo, the detection ratio is not very good and it is getting lower for the newly built binaries for\nIoT platform. The usage of packer is successfully evading anti virus scanning perimeter. But\nyou can actually help all of us to raise detection ratio by sending samples for this related\nthreat to the VirusTotal and if you see unusual samples and you want me to analyze that,\n[please send it to me through ==> [this interface]. Including myself, there are many good folks](https://blog.malwaremustdie.org/p/send-sample.html)\njoining hands in investigating and marking which binaries are the Linux/Mirai FBOT ones,\nthat will bring improvement to the naming thus detection ratio of this variant's Linux malware.\n\nThe signature and network traffic scanning's evasion tricks of new Mirai Fbot binaries is not\nonly by utilizing \"hexstring-push\" method, but the usage of packer, embedded loaders in\n**_packed binary & stronger encryption in config data that is actually contains some block-_**\nable HTTP request headers. By leveraging these aspects these Mirai FBOT now has\nsuccessfully evaded current setup perimeters and is doing a high-speed infection under our\nradars. This is the evasion tricks used by the adversaries that our community should concern\nmore in the future, it will be repeated again and maybe in a better state, since it is proven\nworks.\n\nThe IOC for this threat contains more than 1,000 attributes and is having sensitive\ninformation, it is shared in MISP project (and also at the OTX) with the summary as per\nbelow. The threat is on-going, the threat actors are watching, please share with OPSEC\nintact:\n\n\n-----\n\nIn our monitoring effort up to (March 3, 2020) the botnet IP addresses has volume about +/**1,424. You can use the data posted in MISP event to re-map them into your new object**\ntemplates for IOT threat classification & correlation, to follow the threat infection progress\nand its C2 activity better, to combine with your or other other monitoring resources\ndata/feeds.\n\n**[UPDATE] In our latest monitoring up to (April 17, 2020) this botnet has volume about +/-**\n**[1,546 IP addresses [-1-] [-2-].](https://gist.github.com/unixfreaxjp/5f73a5c89a81935c552d5613b6086959)**\n\n## [NEW] Another FBOT \"hexstring\" downloader, the \"echo\" type\n\nThere is FBOT pushed hexstring that is smaller in size. If you see the infection log there is a\nslight difference after hextrings pushed at \"./retrieve; ./.t telnet;\" and \"./retrieve; ./.t echo\",\n[the token of \"telnet\" [link] and \"echo\" is the difference, both token are coming from different](https://blog.malwaremustdie.org/2020/02/mmd-0065-2021-linuxmirai-fbot-re.html#telnetloader)\nbuilt versions of FBOT scanner/spreader functions.\n\n\n-----\n\n[We have covered the \"telnet\" one in the beginning of this post [link], now let's learn together](https://blog.malwaremustdie.org/2020/02/mmd-0065-2021-linuxmirai-fbot-re.html#telnetloaderdissect)\non how the \"echo\" loader's one works in this additional chapter. It is important for people\nwho struggle to mitigate IoT new infection to understand this analysis method, in order to\nextract C2 information automatically from a specific offset address in the pushed binary of\nspecific pushed \"hexstring\" types. In my case I am using a simple python script to\nautomatically extracting C2 data from several formats of hexstring attacks, and it works well.\n\nThe pushed binary in the \"echo\" version is smaller, it's about 1180 bytes [[link] and working](https://pastebin.com/raw/ESeYP7bK)\n(and coded) in slightly different way. But how different is it? Why is it different? Where is it\ncoming from? We need to reverse it to answer these questions. Let's start with seeing what it\nlooks like.\n\nThe saved blob of the binary looks like this, I marked the part of where IP address of the\npayload server is actually coded:\n\n\n-----\n\nNow let's start dissecting it. But beforehand, since I've been still asked questions on\nreversing ARM stripped binaries, so I will make this additional chapter explanation clearer, in\nsteps, for you. All you have to do is downloading and using Tsurugi DFIR Linux SECCON\n**version** [[link] that I use for this, then fire the pre-installed radare2 to load the binary of this](https://blog.0day.jp/p/20191218.html)\n[example (again, it is ARM Embedded ABI arch made by ARM ltd [link], a default port in](https://developer.arm.com/docs/ihi0036/c/application-binary-interface-for-the-arm-architecture-the-base-standard-abi-2018q4-documentation)\n[Linux Debian for ARM architecture, the blob of binary is a little endian binary in ELF [link]](https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/)\n32bits, hence many are calling this architecture as \"armel\"), and our reverse engineering\nresult should be the same :)\n\nAnother embedded Linux binary reversing guidance I wrote (in a different architecture),\nwhich is about analyzing a MIPS big endian ELF, that is also talking about a different and\nmore complex process on a new IoT malware, you can read it on another post in here ==>\n\n[[link], as the next step after you get through this exercise.](https://blog.malwaremustdie.org/2019/09/mmd-0064-2019-linuxairdropbot.html)\n\nIf you want to practice more reversing on small size ELF sample, for the ARM architecture I\n[have this sample written at this sub-section for you==>[link]. And for Intel x86 architecture](https://blog.malwaremustdie.org/2016/10/mmd-0058-2016-elf-linuxnyadrop.html#s)\n**32bits I have two other reversing posts that you can use to practice during corona virus**\n\n\n-----\n\n[isolation time, they are in here==>[link1] and [link2]. Please hang in there!](https://blog.malwaremustdie.org/2014/09/linux-elf-bash-0day-fun-has-only-just.html)\n\nThe attribute (file information) of this binary, if you save it correctly, is like this:\n```\nMD5 (retrieve2) = d2cb8e7c1f93917c621f55ed24362358\nretrieve2.bin: ELF 32-bit LSB executable, ARM, EABI4 version 1 (SYSV), \n        statically linked, stripped\nstrings: GET /fbot.arm7 HTTP/1.0\n1180 Mar 14 21:50 retrieve2.bin*\n\n```\nYou can start with going to this virtual address at 819c (it's 0x0000819c in your radare2\ninterface) and print the disassembly in the function with \"pdf\" after analyzing the whole\nbinary and the entry0 (this) function (af). In order to get you to a specific address in a binary\nyou can use command \"s {address}\" (s means seek), in this example type: s 0x0000819c.\n\nThis is the main operational function of the loader, but the symbol of this ELF has been\n\"stripped\" made function names are not shown, so we don't know much of its operation. We\ncan start to check how many functions are they. Here's a trick command in radare2 to check\nhow many functions are used or called from this main operational routine:\n\n\n-----\n\n```\n:> af\n:> pdsf~fcn\n0x000081c4 bl fcn.00008168 fcn.00008168\n0x000081d4 fcn.000080c0 fcn.000080c0\n0x000081e4 bl fcn.000080e0 fcn.000080e0\n0x000081f0 fcn.000080c0 fcn.000080c0\n0x00008200 bl fcn.00008110 fcn.00008110\n0x0000820c fcn.000080c0 fcn.000080c0\n0x00008228 bl fcn.0000813c fcn.0000813c\n0x00008234 fcn.000080c0 fcn.000080c0\n0x00008258 bl fcn.0000813c fcn.0000813c\n0x00008274 bl fcn.00008110 fcn.00008110\n0x00008280 bl fcn.000080c0 fcn.000080c0\n:> aflt\n.--------------------------------------------------------------------.\n| addr    | size | name     | nbbs | xref | calls | cc |\n)--------------------------------------------------------------------(\n| 0x0000829c | 264  | entry0    | 7   | 5   | 5   | 3  |\n| 0x000082a0 | 88  | fcn.000082a0 | 2   | 7   | 1   | 1  |\n| 0x00008300 | 44  | fcn.00008300 | 1   | 3   | 0   | 1  |\n| 0x00008168 | 44  | fcn.00008168 | 1   | 1   | 1   | 1  |\n| 0x000080c0 | 32  | fcn.000080c0 | 1   | 5   | 1   | 1  |\n| 0x000080e0 | 44  | fcn.000080e0 | 1   | 1   | 1   | 1  |\n| 0x00008110 | 44  | fcn.00008110 | 1   | 2   | 1   | 1  |\n| 0x0000813c | 44  | fcn.0000813c | 1   | 2   | 1   | 1  |\n`--------------------------------------------------------------------'\n\n```\nThese are the all used functions, not so much, so please try to dissect this with static\n**analysis only, you don't need to execute any sample, yet, please do this under virtual**\nmachine to follow below guidance to do so.\n[Now, let's use my howto reference ==>[link] to put the syscall function name and guess-able](https://blog.malwaremustdie.org/2019/09/mmd-0064-2019-linuxairdropbot.html#syscallnaming)\nfunction name if any into the places. After you figured the function, run the script below in\nyour radare2 shell to register your chosen naming to those virtual addresses where the\nfunctions are started:\n```\n:> s 0x0000813c ; afn ____sys_read\n:> s 0x00008110 ; afn ____sys_write\n:> s 0x000080e0 ; afn ____sys_connect\n:> s 0x000080c0 ; afn ____sys_exit\n:> s 0x00008168 ; afn ____sys_socket\n:> s 0x000082a0 ; afn ____svc_0\n\n```\nSo you will find the nice table result looks like this:\n\n\n-----\n\n```\n:> aflt\n.--------------------------------------------------------------------.\n| addr    | size | name      | nbbs | xref | calls | cc |\n)---------------------------------------------------------------------(\n| 0x0000829c | 264  | entry0     | 7   | 5   | 5   | 3  |\n| 0x000082a0 | 88  | svc_0     | 2   | 7   | 1   | 1  |\n| 0x00008300 | 44  | to_0xFFFF0FE0 | 1   | 3   | 0   | 1  |\n| 0x00008168 | 44  | ____sys_socket | 1   | 1   | 1   | 1  |\n| 0x000080c0 | 32  | ____sys_exit  | 1   | 5   | 1   | 1  |\n| 0x000080e0 | 44  | ____sys_connect| 1   | 1   | 1   | 1  |\n| 0x00008110 | 44  | ____sys_write | 1   | 2   | 1   | 1  |\n| 0x0000813c | 44  | ____sys_read  | 1   | 2   | 1   | 1  |\n`--------------------------------------------------------------------'\n\n```\nIn figuring a correct system call (in short = syscall) name in this binary, you should find a\nnumber of which syscall is actually going to be called (known as syscall_number), and for\nthat svc_0 is the function/service to translate the requests to pass it (alongside with its\narguments) to the designated syscall. This is why I listed the functions in 82a0 and 8300,\nwhich are the svc_0 and its component, and they both are used for syscall translation\npurpose.\n\nThe functions in addresses of: 80c0, 80e0, 8110, 813c and 8168 are the \"syscall_wrapper\"\n[functions [link] that needs a help from svc_0 to perform their desired system call operations](http://man7.org/linux/man-pages/man2/intro.2.html)\n(to trap to kernel mode to invoke a system call). In our case, one of the argument in the\n**syscall wrapper function will define a specific syscall_number when the wrapper**\nfunctions are called from this main routine. The svc_0 is processing that passed argument to\npoint into a right system call function translated in the syscall table, and then to pass\nadditional argument(s)needed for the operation of the designated syscall afterward, that's\nhow it works in this binary.\n\nSo in the simple logic, the syscall_wrapper looks like this:\n```\n@ SOME_ADDRES_SYSCALL_WRAPPER\nint ____sys_SOME_SYSCALL(int arg)\n { \n  return svc_0(SYSCALL_NUMBER, arg); \n }\n\n```\nThe above code can be further applied better in every wrapper functions as per below:\n\n\n-----\n\n```\n@ 0x00080c0\nint ____sys_exit(int arg)\n{ return svc_0(1, arg); }\n@ 0x00080e0\nint ____sys_connect(int arg)\n{ return svc_0(283, arg); }\n@ 0x0008110\nint ____sys_write(int arg)\n{ return svc_0(4, arg); }\n@ 0x000813c\nint ____sys_read(int arg)\n{ return svc_0(3, arg); }\n@ 0x0008168\nint ____sys_socket(int arg)\n{ return svc_0(281, arg); }\n\n```\nThose numbers of \"1\", \"3\", \"4\", \"281\" and \"283\" are all the syscall numbers that the\ndesignated Linux OS will translate them to the correct system call according to the kernel's\nprovided syscall table in the file:\n```\n/usr/include/{YOUR_ARCH}/asm/unistd_{YOUR_BIT}.h\n\n```\nI hope up to this point you can understand how to figure the syscalls used in this stripped\nARM ELF binary, a little bit different than the MIPS one but the concept is the same, there is\na syscall_wrapper functions, there is the syscall translator service, the number and a table to\ntranslate them, and voila! You know what the syscall name is, and you're good to go to the\nnext step!\n..just remember that we are still at virtual address 0x00008198 that's referred form entry0\nwith b ARM assembly command. Go back to the entry0 and after analysis you can print\nagain the assembly, and under it (scroll down if you need), you should see the renamed\nfunctions are referring to the syscall wrapper (svc_0) in the result now.\n\n\n-----\n\nAnd then you can go to address 0x0000819c again and print out the disassembly result,\nwhich is now it is showing the function namings :) yay!\n\nFor reverser veterans maybe up to this step is enough to read how this binary works, but for\nbeginners that is not yet familiar with non-Intel architecture maybe you will need to follow\nthese next steps too.\n\nLet's now fire the r2Ghidra-dec (or r2dec) to disassembly the function, use the additional\ncommand option \"o\" in the end of \"pdg\" to see the offset (You can use pdda for r2dec).\n\n\n-----\n\n_(Pardon to my poorly chosen naming on variables that may confuse you, like,_\n_connect_length which is more to string_length used for write(), etc)_\n\nYou may want to know a way my reading IP address in hex fast by radare2:\n\nYou should see that your reversed function names should be appeared in the result, along\nwith the commented part on the radare2 shell console too. You can change the variable\nnamings too if you want but first let's simplify this result, the next paragraph will explain a\nfurther reason for that.\n\n**Ghidra decompiler by default will show values as variables for those that are pushed into the**\n_stacks by registers. You should trace them well, because these bytes pushed are important_\nvalues as per marked in the printed disassembly pictures above, yes, they are arguements\nfor the called functions, and having important meanings. After understanding those, at this\npoint you can try to simplify and reform the ghidra decompiling result into a simpler C codes.\nMinor syntax mistakes are okay..I do that a lot too, try to make it as simple as you can\nwithout losing those arguments.\n\n**r2dec de-compiles the ARM opcodes very well too, the pdda command's result includes the**\nnew function names and comments intact to the pseudo C generated, that can be traced to\nits offset. r2dec in ARM decompiling is reserving the register names as variables, referring to\nits assembly operation due to script parsing algorithm logic is currently designed that\n\n\n-----\n\nway.This is useful for you to elaborate which register that is actually used as argument for\nwhat function, a bit lower level than r2ghidra, yet this will help you to learn how the ARM\nassembly is actually working. However in some shell terminals (like I am, using VT100 basis)\nmaybe you can not see good syntax highlight coloring, but you can copy them into any\nsyntax highlight supported editor, to find it easier to read, as per following screenshot:\n\nAnother decompiler in radare2 that works fine for the case after you renamed the functions,\nand can give you some hints in more simplify, in lower level syntax that is still highly\ninfluenced by the assembly code, it is called as \"pdc\".\n\nI refer to pdc when dealing with a complex binaries with many loops or branched-flow of\nlogic, to guide me tracing a flow faster than reading only the assembly code, pdc is a very\nuseful for that purpose since pdc can recognize and handle cascade loops very well, I am\nusing it a lot in reading a decoder or de-obfuscation assisting the simple emulation operation\n(ESIL), or in the systems where r2ghidra or r2dec have not enough space to be built. But\ntoday we are not going to discuss this de-compiler further to avoid confusion.\n\nJust for the reference, the pdc's de-compiling result is shown as per below, as a comparative\n_purpose:_\n\n\n-----\n\nIn my work desktop I reformed the simplification result of radare2's auto-pseudo-generated\ncodes of this binary, into this following C codes, after re-shaping it to the close-to-original\none, Consider this as an example and not on the very final C form yet, but more or less all of\nthe argument values and logic work flow are all in there. Try to do it yourself before seeing\nthis last code, use what r2dec and r2ghidra gave you as reference.\n\n\n-----\n\nSo now you know about the extraction URL payload for \"echo\" loader hexstring. Don't worry\nIf there is other slight change in way that ELF loader preserving download IP or URL data.\nYou can always dissect it again easily by the same method, and in practical it is not\nnecessary to reverse the whole loader binary but just aim the download IP and its URL (and\nor port number), depends on your flavor.\n\nBelow is the video tutorial for faster process and practical way to adjust the changes on\ndownload IP/URL. This concept can be appied for FBot variants with a pushed-hexstring\nloaders especially the ones that are using Mirai basis loader design. Noted that: this\nextraction concept is also worked to Hajime, LuaBot, and other Mirai variants with a minor\nadjustments. For honeypot users, you can use this method to automate the payload URL\nextraction for each hexstring entries without even downloading the payload.\n\n_(pause the video by pressing space or click the video screen)_\n\n_The conclusion of this chapter:_\n\nUnlike the \"telnet\" one, the difference on how this \"echo\" type of pushed hextring works, can\nbe described as follows, tagged with \"minor\" and \"major\" differences:\n\n1. (Major?) It does not confirming the architecture, frankly, that doesn't matter anyway.\n\n\n-----\n\n2. (Major) It doesn t save the read downloaded data into file, like **.t file that open() in**\n\n\"telnet\" version, so this \"echo\" version is just printout the download result to stdout, this\nexplaining the piping handling, hard coded in the FBOT spreader function is a must to\nsave the payload into affected devices. This reduce big I/O operational steps.\n3. (Minor) It doesn't bother to close the connection after the writing is done, and just exit\n\nthe program.\n4. (Minor) It isn't using IP reforming step, just using a hardcoded hexadecimal form of IP\n\naddress.\n\nThis explains how the \"echo\" type is smaller in size compares to the \"telnet\" type. And in\naddition, the both of \"telnet\" (previously explained) and \"echo\" (now explained) pushed ELF\nloaders are all \"inspired\" from Mirai's Okiru and Satori ELF loaders.\n\nI hope you like this additional part too, thank you for contacting and asking questions, happy\nRE practise!\n\nFor the folks who have to get recovered or isolated due to corona virus pandemic, this\nchapter I dedicated to them. Please try to spend your time at home in brushing your reverse\n[engineering skill on Linux binaries with practising this example or sample.](https://pastebin.com/raw/ESeYP7bK)\n\n[You can download the Tsurugi DFIR Linux distro's ISO from the official side [link], or use the](https://tsurugi-linux.org/)\n[SECCON special edition I use [link], Tsurugi can be used in Live mode in several virtual](https://blog.0day.jp/p/20191218.html)\nmachines (wmware, vbox, kvm) or USB bootable, or you can install it into your unused old\n[PC. With a build effort, you can also install radare2 [link] with r2ghidra [link] and r2dec [link]](https://github.com/radareorg/radare2)\nfrom the github sites. These are all open source tools, it is free and good folks are working\nhard in maintaining & improving them, please support them if you think they're useful!\n\n## New actor, old version [Update for April 24, 2020]\n\nWe have spotted the new spark of what looks like the FBOT activity, started from April 24th,\n2020. as per recorded in the following log screenshot below, this seems like the Mirai FBOT\nis downgraded to earlier era's version, which I found it strange so I just need to look it further:\n\n\n-----\n\nTo make sure the payload is actually served, some testing and record to check them has\nbeen also conducted as per recorded too in the screenshot below:\n\nThe bot binaries are all packed, but with the older ways, at this point it raises more suspicion:\n\n\n-----\n\nAfter the unpacking I found that the \"CTF like\" encryption that I was blogged in this post and\nprevious post wasn't there, took me like 5 minutes to decrypt this one, but I bet by now you\nall can do the unpacking and decrypting this way much faster yes? After all of the exercises\nyou took in previous chapter above. :D\n\nBack to this version's the scanner's atacker source IP as per shown in the picture above, I\n[sorted all of the infection effort the per this list ==>[link], and sort the source IP as per this list](https://gist.github.com/unixfreaxjp/64dd1beb347990c972daf89b015910e6)\n[==>[link]. to then compared to what has been recorded so far as Mirai FBOT's scanner IP](https://gist.github.com/unixfreaxjp/a204645266c5283fe1e32c0398c0b1f5)\n\n\n-----\n\n(read: IoT infected with Mirai FBOT) written in several links in previous chapters.\n\nThe result is none of them is matched. It seems that there is another botnet is propagating\ninfection using either the copycat version or museum version of the FBOT with the very low\nquality on its core's code and just being added with some new scanning interface.\n\nTo be more clear in the comparison betwen nea actor's FBOT and previous botnet's one.\nBelow is the botnet geographical map of the new actor's botnet, that's is showing an infection\nfocus on Hongkong and China, that's is different to the similar map made by infection of\nprevious FBOT which was focusing on Taiwan, Vietnam, then to Hongkong, the link is\nhere==[link]\n\nAdditionally, on April 25, 2020, this new actor was started to launch the pushed hexstrings to\ninfect new IoT via echo command, that the video ccan be seen in here==>[link]. In that case,\nthe used IP address can be grep easily in the hexstring itself, it's written like this:\n**\\xa0\\xe3\\x12\\x30\\xa0\\xe3\\xce\\x10\\xa0\\xe3\\xe3\\x20 and these hexs means the last three**\ndigits IP address used to download the FBOT payload. You can adjust this string into a grep\ncommand to your honeypot or IoT log, by adding escape sequence backslash before the\n**\"\\x\" . The latest new actor infection log I shared in the GIST link above contains the nodes**\nthat infects with this hexstrings from the same C2.\n\nLet's go back to the binaries used of this FBOT version, if you can unpack it very well, you\nwill see the below details that can support the theory.\n\nSome scanner strings used in this new actor's Mirai FBFOT version:\n\n\n-----\n\nThese are the payload binaries name:\n\nAnd this is the hardcoded Stupidly Simple DDoS Protocol(SSDP) headers used for\namplification flood reflection attack:\n\nAgain, about SSDP flood in simple words: It's a flood composed by UDP packets using\nsource port 1900. This port is used by the SSDP and is legitimately specified for UPnP\nprotocols. In UPnP there's \"M-SEARCH frame\" as main method for device discovery using\nmulticasting on 239.255.255.250:1900 (reserved for this purpose). The adversaries are\ntaking advantage from three weaknesses of UPnP protocol in (1) utilizing it for amplification\nattack, or (2) reflection attack and while doing those it obviously can (3) spoof the source IP\naddress. The above picture is showing that Mirai FBOT is having this flood functionality.\n\nWhat has been concluded in this additional (update) chapter is, there is more than one actor\nis using Mirai FBOT, the one with the \"CTF like\" crypt function that looks like stopping its\nactivity and abandon the botnet under the scale volume of 1,600 to 1,700 nodes, and there is\n\n\n-----\n\na new one, using the older yet standard version, suspecting could be a older version\nleaked/shared/re-used and now actively operated by another actor(s).\n\nThe IOC for this update chapter (new actor one):\n```\nC2: 5[.]206[.]227[.]18 (same FBOT port number for nodes & C2)\nspf FQDN: darksdemon[.]gov\nPayloads: 5.206.227.18/bot/bot.{ARCH}\nTemporary filename: bot.{ARCH}.tmp\nPayloads:\nbot.arm4,5: dfa6b60d0999eb13e6e5613723250e62\nbot.arm7:  924d74ee8bfca43b9a74046d9c15de92\nbot.mips:  4b323cd2d5e68e7757b8b35e7505e8d9\nbot.x86:  591ca99f1c262cd86390db960705ca4a\nbot.x86_64: 697043785e484ef097bafa2a1e234aa0\nOthers payloads are not included: *.mipsel, *.superh \n\n```\nUpdates on new actor's Mirai/FBOT:\n\nWithin ONE month new-actor of [#Linux/#Mirai](https://twitter.com/hashtag/Linux?src=hash&ref_src=twsrc%5Etfw) [#FBOT has raised his #botnet from 299](https://twitter.com/hashtag/FBOT?src=hash&ref_src=twsrc%5Etfw)\nnodes\n[(ref:https://t.co/vOjQ5nwDrY)](https://t.co/vOjQ5nwDrY)\n\nto 653(↑+354) nodes\n[(ref:https://t.co/u05uTVtFhf).](https://t.co/u05uTVtFhf)\n\n1. CN 165\n2. TW 138\n3. HK 125\n*) SE 31, RU 26, US 20\n\nIP is on [@MISPProject for CERT process#MalwareMustDie](https://twitter.com/MISPProject?ref_src=twsrc%5Etfw)\n[pic.twitter.com/mfErSSy0c1](https://t.co/mfErSSy0c1)\n\n[— ☩MalwareMustDie (@malwaremustd1e) May 27, 2020](https://twitter.com/malwaremustd1e/status/1265736192965791744?ref_src=twsrc%5Etfw)\n\n## The epilogue\n\nWe hope this post can raise attention needed to handle the worrisome of this new FBOT\npropagation wave in the internet. Also we wrote this post to help beginner threat analysts,\nbinary reversers, and incident response team, with hoping to learn together about Linux\nmalware in general and specifically on IoT botnet.\n\n\n-----\n\nThere is some more insight information about this threat that maybe can help you to\n[understand the threat better, including a how to mitigate this, it is in this article ==>[link]](https://securityaffairs.co/wordpress/98479/malware/fbot-re-emerged.html?fbclid=IwAR1RwEZZfHvnLr7aiveVRyljUN3Pxpp06XkYtpxwQY2nJkMoN2jAjUgYs_I)\n(thank you for the interview!). Also if you successfully analyze and monitor similar threat,\nplease don't forget to inform your CERT/CC so they can help to coordinate the handling\nfurther to the CSIRT on every related carriers and services, and also those escalation\nrecords can be useful to be used during notification to the authority, for applying a better\npolicy for IoT structure in your region.\n\nWe are in the era where Linux or IoT malware is getting into their better form with\nadvantages, it is important to work together with threat intelligence and knowledge sharing,\nto stop every new emerging activity before they become a big problem for all of us later on.\n\nOn behalf of the rest of our team, we thank all of the people who support our work, morally\nand with their friendship. MMD understands that security information and knowledge sharing\nis also very important to maintain the stability of internet to make our life easier. Thank you to\nall tools/framework's vendors and services who are so many of them and who are so kind to\nsupport our research and sharing works with their environments, also, to the media folks who\nare helping us all of these yeas. I and the team will look forward to support more \"secureetays\" for 2020 and for more years to come.\n\nI will try to update regularly the information posted in this article, please bear with recent\nadditional information and maybe changes, so stay tuned always.\n\n_This technical analysis and its contents is an original work and firstly published in the current_\n_MalwareMustDie Blog post (this site), the analysis and writing is made by @unixfreaxjp._\n\n[The research contents is bound to our legal disclaimer guide line in sharing of](https://blog.malwaremustdie.org/p/the-rule-to-share-malicious-codes-we.html)\nMalwareMustDie NPO research material.\n\nMalware Must Die!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-02-24 - MMD-0066-2020 - Linux-Mirai-Fbot - A re-emerged IoT threat.pdf"
    ],
    "report_names": [
        "2020-02-24 - MMD-0066-2020 - Linux-Mirai-Fbot - A re-emerged IoT threat.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535725,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653786047,
    "ts_modification_date": 1653786047,
    "files": {
        "pdf": "https://archive.orkl.eu/f4d1a9b493c4d2b745140ea4a91204359735506d.pdf",
        "text": "https://archive.orkl.eu/f4d1a9b493c4d2b745140ea4a91204359735506d.txt",
        "img": "https://archive.orkl.eu/f4d1a9b493c4d2b745140ea4a91204359735506d.jpg"
    }
}