{
    "id": "0c2b8cc5-12a0-4e18-b231-097cf12e9765",
    "created_at": "2023-01-12T15:02:14.976073Z",
    "updated_at": "2025-03-27T02:05:28.708231Z",
    "deleted_at": null,
    "sha1_hash": "e23a0bce9138109af1f4ba0195aa4a43212bd2b4",
    "title": "2022-06-09 - Yara- In Search Of Regular Expressions",
    "authors": "",
    "file_creation_date": "2022-06-13T04:01:45Z",
    "file_modification_date": "2022-06-13T04:01:45Z",
    "file_size": 515764,
    "plain_text": "# Yara: In Search Of Regular Expressions\n\n**[engineering.avast.io/yara-in-search-of-regular-expressions/](https://engineering.avast.io/yara-in-search-of-regular-expressions/)**\n\nThis blog post is based on my paper Pattern Matching in YARA: Improved Aho-Corasick\nAlgorithm and a [pull request that I opened on the upstream version of Yara. My main goal is](https://github.com/VirusTotal/yara/pull/1379)\nto describe the changes from a more practical point of view and also provide some updates\nand changes that were made from the initial design proposed in the paper, as practical\nusage in Avast showed me some additional ways how to improve my code.\n\nYara is a pattern-matching tool used mainly to classify and identify malware. It is also an\nopen-source project with an active community that is working hard to improve this tool every\nday. In this post, I will not go into details about what Yara is and how it can be used. For that,\nyou can visit my [personal blog or watch my talk about Yara at](https://regeciova-dominika.medium.com/botconf-2022-388109f43387) [Botconf 2022.](https://www.youtube.com/watch?v=3G0xaJkIE3M&list=PL8fFmUArVzKjQ6A1OLfN2nnob4KIz8aT-&index=10)\n\n## Motivation\n\nWe use the Yara tool every day at Avast, and it is a critical help for our malware analysts. We\nare also trying to give back and bring as many of our improvements and additional features\ninto the upstream version as possible.\n\nThe changes I am proposing address a problem faced by our analysts: the “slowing down”\nwarning, where rules can generate the following:\n\n\n-----\n\n```\n$ ./yara yara_rule.yar r /directory\nwarning: rule “can_be_slow” in ../yara_rule.yar(4): string “$slow_string” may slow\ndown scanning\nCode language: Bash (bash)\n\n```\nBesides the fact that we should be aware of every warning, not just straight errors, this\nnegatively influences the usability of rules. For example, the VT Hunting platform does not\naccept rules with warnings.\n\nMost notably, one of our analysts was trying to create a rule that would detect Bitcoin\naddresses, as in the rule below, and had to combat this warning constantly.\n```\n// btc.yar rule\nrule contains_btc_address\n{\n  strings:\n    $btc = /[13][a-km-zA-HJ-NP-Z1-9]{25,34}/ fullword ascii wide\n  condition:\n    $btc\n}\nCode language: PHP (php)\n\n```\nHowever, we would like to use some of these rules, so what is the solution? And what\nexactly is the reason that Yara is warning about low performance? Can this be changed or\nimproved?\n\n## Problem analysis\n\nAfter analyzing the problem, I found the potential issue that decreased the number of\nprimarily regular expressions that could be used in Yara rules without warnings.\n\nTo understand that, I will briefly explain how Yara works internally. For more details, you can\n[visit an excellent summary in Performance Guidelines, where I also added a few of my](https://github.com/Neo23x0/YARA-Performance-Guidelines)\nnotes, or look directly at the documentation and the code itself.\n\nYara firstly searches for potential matches with the help of the Aho-Corasick machine. In this\nstep, it finds all possible places in input, where the whole strings can be found, and\nadditionally, where rules can hit. Just after that, the bytecode engine is run to verify the\nmatches, and then the conditions of the rules are also checked.\n\nFor this first step, short substrings, up to 4 bytes, are selected from strings. A series of\nheuristics are used to choose the unique sequences.\n\nThis is wanted as we do not want to search for the `00 00 00 00 sequence as it would hit`\ntoo many times.\n\nThe main problem is that the heuristics strongly prefer text strings and cannot work with\nregular expressions very effectively.\n\n\n-----\n\nIn our case, the Bitcoin addresses let to zero-length atom. What does that mean? The\nbytecode engine must check every byte from the input because every position could be a\npotential match. And this is a truly time-consuming task, thus the warnings.\n\nBut what if we could help Yara better understand the regular expressions and help it narrow\ndown the number of potential matches? Would the speed of scanning improve?\n\nAfter creating the proof of concept, I can say yes, we can do it.\n\n## Proposed Changes\n\nYou can read about all the details and formal theory behind the changes in my paper, but I\nwill try to describe the changes in a more practical way here.\n\nFirst, I extended the definition of atoms from text strings to regular expressions. That means\nthat they are able to represent the subclass of these languages. I kept the length of 4 bytes\nor rather a sequence of four classes. The class is a set of characters. It can be one\ncharacter, that would be a literal, a collection of characters, like in `[a-d] representing the`\nset `{a, b, c, d} . The last case is noted as a dot in regular expression as any character`\n(sometimes without the new line, depending on the implementation).\n\n\n-----\n\nIn this version, the Bitcoin address would be represented as `[13][a-km-zA-HJ-NP-Z1-9]`\n```\n{2}, noting the repetition of the second class. It also could be [13][a-km-zA-HJ-NP-Z1-9]\n{3} . Still, experiments showed that the additional class does not improve the speed as\n\n```\nsignificantly as the repetition does not provide a substantial decrease in the number of\npotential matches.\n\nThe heuristics for selections of atoms were broadened and changed to prefer still simple text\nliterals where they can be found and include more complex ones, as in our case at the same\ntime.\n\nThis part underwent several changes, and in the end, I tried to keep the changes as minimal\nas possible. My goal is not only to improve the scanning of the regular expressions but also\nscanning of other cases the same in the worst scenario. Even a tiny change in heuristics can\ndramatically affect the number of potential matches and thus the scanning speed, so this had\nto be handled carefully.\n\nThe class itself is represented as a bitmap, an array of integers where individual characters\nare coded with a bit value set to 1 if the character is set, 0 otherwise. For example, for\ncharacter `a, the bit on position` `bitmap[12][1] is used, as its ASCII code (97) is divided`\nby 8, and the resulting number is 12. The presence of the number is indicated by a bit with\nthe value one on the position given by operation modulo 8.\n\nThe selected atoms are then inserted into the Aho-Corasick automaton, a prefix tree\nmachine. It is an extended version of a general finite automaton, where we are adding\nstrings from the root state and detecting the common prefixes as we create states only when\nnecessary. In my proposed version, it can also accept the classes instead of just simple text\nstrings. In this step, the same classes are detected in the common prefix in a similar fashion\nas before.\n\nThis leads to a problem because the Aho-Corasick contains so-called failure links that allow\nseveral matches (and even interleaving ones) to be detected at one pass from the input. This\nrequires that the machine is deterministic even with failure links that return to previous\nstates. My change, however, broke this determinism. Additional changes had to be made,\nand the machine was transformed into a deterministic one even for failure links.\n\nWith these changes, we detected a subset of potential matches again, and the bytecode\nengine is run less often, even with the use of regular expressions. Also, the Bitcoin address\ncan be detected without warnings about the slowing down scanning with my proposed\nchanges.\n\nBut what about the actual speed of the scanning? Was it improved?\n\n\n-----\n\n## Tests\n\nFor tests, I run both versions on the server with the Debian operating system in release\n4.9.168 on a 64-bit architecture with a processor Intel Xeon 5–2697 v4 with a clock rate of\n2.30GHz. The memory clock rate was 2.40GHz. As a compiler, the GCC in version 8.3.0 was\nused.\n\nI selected two rules, one with the Bitcoin address and one from unit tests, to provide\nadditional information on the overall effects of the proposed changes. More tests can be\nfound in my paper.\n\nTo measure speed, I scanned two larger folders with various subfolders and files with 15 GB\nand 760 GB of data in total.\n\nBTC Address Rule\n```\n// btc.yar rule\nrule contains_btc_address\n{\n  strings:\n    $btc = /[13][a-km-zA-HJ-NP-Z1-9]{25,34}/ fullword ascii wide\n  condition:\n    $btc\n}\nCode language: PHP (php)\n\n```\n**The rule btc.yar** **Set 1 (15 GB)** **Set 2 (760 GB)**\n\nThe upstream version 1m 20.134s 8h 55m 21.727s\n\n\n-----\n\nThe classes version 6.683s 40m 22.879s\n\nThe results for btc.yar YARA rules\n**Hex Value Rule**\n```\n// hex.yar rule\nrule hex_value_test\n{\n  strings:\n    $hex = {61 6? 63 [1–5] 65 66}\n  condition:\n    $hex\n}\nCode language: PHP (php)\n\n```\n**The rule hex.yar** **Set 1 (15 GB)** **Set 2 (760 GB)**\n\nThe upstream version 6.399s 39m 7.329s\n\nThe classes version 6.285s 37m 43.513s\n\nThe results for hex.yar YARA rules\n\n## Conclusion\n\nYara is a fascinating tool for pattern matching, and I am happy that there is an online\ncommunity that is very active and helpful.\n\nAt Avast, we want to give back as much as possible, and for that reason, I also published the\nchanges that we have been using in the company for a while now.\n\nNote that there will be a discussion with the authors of Yara about this commit, and there can\nbe some additional updates and changes, so the updated version is the most suitable for\ngeneral usage.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-06-09 - Yara- In Search Of Regular Expressions.pdf"
    ],
    "report_names": [
        "2022-06-09 - Yara- In Search Of Regular Expressions.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535734,
    "ts_updated_at": 1743041128,
    "ts_creation_date": 1655092905,
    "ts_modification_date": 1655092905,
    "files": {
        "pdf": "https://archive.orkl.eu/e23a0bce9138109af1f4ba0195aa4a43212bd2b4.pdf",
        "text": "https://archive.orkl.eu/e23a0bce9138109af1f4ba0195aa4a43212bd2b4.txt",
        "img": "https://archive.orkl.eu/e23a0bce9138109af1f4ba0195aa4a43212bd2b4.jpg"
    }
}