{
    "id": "508c7aa8-8afd-4eeb-af90-d67bd8971789",
    "created_at": "2022-10-25T16:48:23.639907Z",
    "updated_at": "2025-03-27T02:05:35.535521Z",
    "deleted_at": null,
    "sha1_hash": "5c4415913a16a0331600816bb4cf8a1954e743dd",
    "title": "Hikit Analysis",
    "authors": "Novetta",
    "file_creation_date": "2014-10-28T02:43:26Z",
    "file_modification_date": "2014-10-28T02:43:26Z",
    "file_size": 1021456,
    "plain_text": "# Hikit Analysis\n\n## Basic Description\nHikit consists of at least two generations of malware that provides basic RAT functionality. The first\ngeneration of Hikit (referred to as “Gen 1”) operates as a server and requires an externally exposed\nnetwork interface in order for an attacker to access the victim machine. The second generation of Hikit\n(referred to as “Gen 2”) uses the more traditional client model and beacons out to an attacker’s C2\nserver. While the communication models shifted dramatically between Gen 1 and Gen 2, both\ngenerations of Hikit retain the same basic RAT function consisting of remote command shell, file\nmanagement, network proxy and port forwarding.\n\nBoth Gen 1 and Gen 2 sub-families of Hikit consist of a main DLL (referred to as “the DLL”) that\ncontains the RAT functionality; a kernel driver (referred to as “the Driver”) with Gen 2 also employs an\nadditional component: a loader executable. The driver component of Gen 1 and Gen 2 are drastically\ndifferent in their operation and intent. For the Gen 1 sub-family of Hikit, the driver acts as a NDIS\n(network) driver that is responsible for interfacing the DLL to the network while preventing a direct\nWinSock interface from occurring. The Gen 1 Driver listens to network traffic arriving at the local\nnetwork interface and waits for a specific trigger string. The trigger string varies by Driver and DLL\nsample. The Gen 2 Driver is a simpler system driver that acts as a rootkit to hide processes, registry\nkeys and network connections associated with Gen 2 activity on the victim’s system.\n\nGen 2 uses a standard client-server malware model meaning that the malware no longer requires a\ndirect Internet-facing network card, no longer uses a network driver for networking, and provides the\nability to network multiple Gen 2 samples behind a firewall with greater ease (from the attacker’s\nperspective). The Gen 2 sub-family, however, no longer employs network stealth provided by the Gen 1\nnetwork driver which exposes the C2 server addresses to analysts.\n\nEach of the Hikit generations contains multiple sub-generations as the author(s) of Hikit have evolved\ntheir code over time. There is a noticeable steep improvement over the code base of Gen 1 Hikit family\nduring its 2011 development period. The Gen 2 sub-generations share a similar improvement scale\nbetween late 2011 and late 2013.\n\n## Evolution\nThe earliest known Hikit sample dates back to 31 March 2011. Known as the Gen 1.0 sub-generation of\nHikit Gen 1, the first known sample of Hikit deviated from the later traditional Gen 1 model. The Gen 1.0\nsample was a standalone executable whereas subsequent Gen 1 sub-generations use a DLL running\nas a service. The Gen 1.0 sample is clearly a work-in-progress. The Gen 1.0 sample, while different\nthan subsequent sub-generations, does still rely on the Driver component and for the most part the\nstructure of the code does not differ much going forward into the Gen 1 evolution.\n\nLess than three weeks after Gen 1.0, the author(s) of Hikit move into Gen 1.1. The notable change is\nthat the Hikit model of using a DLL and driver, which has remained until present day, comes into being.\nThe code matures slightly between Gen 1.0 and Gen 1.1 but the functionality does not change. Both\nGen 1.0 and Gen 1.1 use plaintext data transmissions.\n\n\n-----\n\nDevelopment appears to halt on Gen 1 for 4 months between 20 June 2011 and 23 October 2011\nbased on a lack of available samples found. During this time the development of Hikit appears to\nchange locations. Gen 1 samples have Program Database (PDB) file strings that identify the file path of\nthe Hikit source code. For Gen 1.0 and Gen 1.1 samples, the file path of the Hikit source code is\nconsistently h:\\JmVodServer\\hikit. Starting with Gen 1.2, the file path switches to\n```\ne:\\SourceCode\\hikit_new. It is at this time that the functionality of Hikit Gen 1 begins to mature. \n\n```\nIn Gen 1.2, the communication between the infected machine and the attacker is encrypted using an\nXOR mask. A more subtle change is the renaming of the “socks5” command to simply “proxy” within\nthe code. The code within Hikit begins to mature but the overall functionality does not expand beyond\nthe original set of commands found in Gen 1.0. The other remarkable change within the Gen 1.1 to Gen\n1.2 development is the way in which the session handshake trigger operates. In Gen 1.0 and Gen 1.1,\nthe DLL instructs the Driver to listen for a specific string (typically a HTTP request string) and responds\nwith another string. In Gen 1.2, the Driver has a hardcoded trigger string (a specific HTTP request\nstring) and the DLL instructs the Driver to inspect a specific HTTP header field for a specific\nhexadecimal value. This moves Gen 1.2 into more of a username/password authentication scheme\nwhereas previous sub-generations could potentially be accessed by accidental HTTP requests. At the\nsame time, the Driver responds with a specific value with in the Etag HTTP header field. This places\nGen 1.2 into a more stealth position as a random, non-HTTP compliant response from Gen 1.0 and\nGen 1.1 samples is more obvious than a legitimate HTTP response with a specially crafted Etag\nheader.\n\nGen 1.2’s development cycle appears to exist between 23 October 2011 and 2 November 2011 with\nseveral new samples being found on the Internet having legitimate compile times during this time\nwindow. There is, however, evidence that the development of Hikit Gen 1 and Gen 2 overlap by several\nmonths. The earliest Gen 2 sample known to exist dates to 28 August 2011, two months before the first\nknown Gen 1.2 sample. The last known Gen 1.2 sample, and by extension, the last known Gen 1\nsample, dates to 9 April 2012.\n\nThe first known Gen 2 sub-generation, Gen 2.0 Alpha, much like Gen 1.0, represents an early\ndevelopment version of the Gen 2 Hikit sub-family. Gen 2.0 Alpha is a stand-alone Windows console\nexecutable that can run as a service executable. Gen 2.0 Alpha supports the same commands as Gen\n1.2 with an additional command that returns the infection’s configuration information.\n\nOn 9 February 2012 the first known sample for Gen 2.0 Beta is compiled by the developer(s) of Hikit.\nAlso a stand-alone console executable like Gen 2.0 Alpha, the Gen 2.0 Beta code changes internally\nwithout providing significant functionality improvements with the exception of now the executable uses\na device driver to hide network, file, and registry artifacts related to its operation. Both Gen 2.0 Alpha\nand Gen 2.0 Beta still retain PDB file path information within their binaries. During the development\nphase of Gen 2.0 Alpha, development of the Gen 2.0 Alpha variants changes locations. First version of\nthe Gen 2.0 Alpha malware, from 28 August 2011, has the PDB path located in\n```\nH:\\JmVodServer\\Matrix_new2 whereas the file path for later Gen 2.0 Alpha and Gen 2.0 Beta\n\n```\nbinaries has the PDB path in E:\\SourceCode\\Matrix_new which suggests that the source code for\nboth Gen 1 and Gen 2 existed on the same machine and moved at roughly the same time. This may\nindicate either a single developer or a team (or set of teams) with shared resources.\n\nThe first known Gen 2.1 binary has a compile date of 17 April 2012. Gen 2.1 represents the first Gen 2\nsub-generation to use an executable-based loader, DLL and driver model, a model that all subsequent\nGen 2 sub-generations employ. The functionality of the Gen 2.1 sub-generation is the same as the\n\n\n-----\n\nprevious generations with no new commands being introduced. Gen 2.1 is the first sub-generation in\nthe Gen 2 sub-family to introduce 64-bit binaries.\n\nThe Gen 2.2 sub-generation appears to have begun on 20 July 2012. Gen 2.2 is notable for altering\nwhere the configuration information of the RAT is stored and using both DLL-based and executablebased loaders. Also notable is the fact that the sub-generation spans a significant amount of time with\nintermittent periods of development. The bulk of the Gen 2.2 samples that have the tell-tale marks of\nbeing the product of a builder have a compile date of 26 July 2013, a full year after the first known Gen\n2.2 sample. Between 21 July 2012 and 20 February 2013, there are no known Gen 2.2 binaries. The\ntwo 20 July 2012 samples have different compile times indicating they were not the product of a builder\nbut rather unique compilations. Between 21 February 2013 and 27 February 2013, there are 4 unique\ncompilation dates for the DLL component with 7 unique, known Gen 2.2 DLLs. The bulk of Gen 2.2\nsamples have a compile date of 26 July 2013. There are approximately 25 known Gen 2.2 DLLs with\nthe 26 July 2013 compile date. The Gen 2.2 sub-generation appears to exist through at least 19\nSeptember 2013.\n\nThe last known Gen 2 sub-generation, Gen 2.3, began on 12 December 2013. Gen 2.3 is notable for its\nuse of a legitimate SSL certificate as part of the handshake between the infected machine and the\nattacker’s C2. The DLL will send a legitimate SSL certificate as a means to disrupt heuristic IDS\nsensors that look for encrypted traffic. Another interesting aspect of the Gen 2.3 sub-generation is that\nthere is no longer a marker to designate the beginning of the embedded configuration. Gen 2.1 and\nGen 2.2 uses a specific string to indicate the beginning of the embedded configuration presumably in\norder to allow the builder to locate the configuration space when constructing a new configuration for\nthe binaries. Gen 2.3, however, uses a specific location instead, requiring the builder to calculate the\nspecific location using the PE/COFF header of the binary. Also, while Gen 2.1 and Gen 2.2 retain the\nconfiguration within the DLL component, Gen 2.3 stores the configuration within the loader component.\nThis allows the attackers to configure the loader without having to update the DLL.\n\nThe evolution of Hikit is a long and drawn out series of small, incremental development changes. The\nimportant take away from the evolution of Hikit is that the developers for Gen 1 appear to have changed\nin late 2011 and development of Gen 2 has a several month overlap with the development and usage\nof Gen 1. The following table provides a quick reference to the generational (and sub-generational)\ndesignations of Hikit.\n\n\n-----\n\n**August**\n\n28, 2011\n\n\n_Timeline Outlined in Appendix A: HiKit Versions_\n\n## The Driver\nThe Driver component for Hikit varies based on the specific Hikit sub-family (Gen 1 or Gen 2). As such\nit is necessary to describe each in the context of its specific sub-family.\n\n### Gen 1 Driver\nThe Driver component of Gen 1 Hikit variants provides the interface between the victim’s network\ninterface card (NIC) and the DLL. The Driver is a NDIS (network) driver that integrates into the victim’s\nnetwork stack. The Driver intercepts any and all network communication that traverses the Windows\nnetwork stack and potentially removes the data from the network stack under very specific conditions.\nWhen the Driver removes data from the network stack, the Driver stores the removed data in local\nbuffers for the Gen 1 DLL to query against. The purpose of this behavior is to allow the DLL to interact\nwith the network without utilizes the WinSock API which could potentially reveal the presence of Hikit.\n\nIn order to interact with the Driver, the DLL uses the function `IoDeviceControl` to send commands to\nthe Driver. The Driver registers itself at both `\\Device\\w7fw` and `\\DosDevices\\w7fw` thereby\nallowing the DLL to access the Driver by performing a `CreateFile` request to `\\\\.\\w7fw` or\n```\n\\\\.\\Globals\\w7fw in order to obtain a handle to the Driver. The Driver’s interface supports the\n\n```\nfollowing OIDs:\n\n\n-----\n\nOID Function\n**0x12C828** No-op\n**0x12C82C** Retrieves bytes from the recv queue.\n**0x12C830** Add bytes to the xmit queue.\n**0x12C838** Set key value (the trigger value)\n**0x12C840** Change mode for current process’s channel to 2\n**0x12C844** Activates channel\n**0x12C848** Shuts down a channel by flushing all queued packets/data to the network with ACK|FIN\nset in the flags\n**0x12C84C** Returns the current mode for a given channel\n**0x12C850** Get the Driver’s version\n\nThe Driver will remove data from the network stack only if a new channel is being established. A new\nchannel occurs when the Driver detects a trigger string. The trigger string is typically a short form HTTP\nrequest with the following trigger strings found in the wild:\n\nGeneration(s) Trigger String Authentication Response Value\nValue\n\n**Gen 1.0, 1.1** GET /password .welcome.\nHTTP/1.1\\r\\n\\r\\n\n\n**Gen 1.2** GET / HTTP/1.1\\r\\n 75BCD15 HTTP/1.1 200 OK\nPragma: no-cache\nContent-Type: text/html\nETag: \"{other\ndigits}75BCD15{other digits}:{3 hex\ndigits}\"\nConnection: Keep-Alive\n**Gen 1.2** POST / HTTP/1.1\\r\\n 75BCD15 HTTP/1.1 200 OK\nPragma: no-cache\nContent-Type: text/html\nETag: \"{other\ndigits}75BCD15{other digits}:{3 hex\ndigits}\"\nConnection: Keep-Alive\n\nUp to and including Gen 1.1 Drivers required the DLL to specify the trigger string in addition to the\nauthentication value whereas Gen 1.2 Drivers had the trigger strings hardcoded.\n\nIn Gen 1.2, whenever the Driver detects a trigger string, the Driver inspects the rest of the data\nreceived for the authentication value. If the token follows the trigger string (there is no specific limitation\non how far from the trigger string the password token must be), then the Driver generates a new\nchannel that the DLL will use as the conduit between the DLL and the client.\n\n|OID Function|Col2|\n|---|---|\n|0x12C828|No-op|\n|0x12C82C|Retrieves bytes from the recv queue.|\n|0x12C830|Add bytes to the xmit queue.|\n|0x12C838|Set key value (the trigger value)|\n|0x12C840|Change mode for current process’s channel to 2|\n|0x12C844|Activates channel|\n|0x12C848|Shuts down a channel by flushing all queued packets/data to the network with ACK|FIN set in the flags|\n|0x12C84C|Returns the current mode for a given channel|\n|0x12C850|Get the Driver’s version|\n\n|The Driver will remove data from the network stack only if a new channel is being established. A new channel occurs when the Driver detects a trigger string. The trigger string is typically a short form HTTP request with the following trigger strings found in the wild:|Col2|Col3|Col4|\n|---|---|---|---|\n|Generation(s) Trigger String Authentication Response Value Value||||\n|Gen 1.0, 1.1|GET /password HTTP/1.1\\r\\n\\r\\n||.welcome.|\n|Gen 1.2|GET / HTTP/1.1\\r\\n|75BCD15|HTTP/1.1 200 OK Pragma: no-cache Content-Type: text/html ETag: \"{other digits}75BCD15{other digits}:{3 hex digits}\" Connection: Keep-Alive|\n|Gen 1.2|POST / HTTP/1.1\\r\\n|75BCD15|HTTP/1.1 200 OK Pragma: no-cache Content-Type: text/html ETag: \"{other digits}75BCD15{other digits}:{3 hex digits}\" Connection: Keep-Alive|\n\n\n-----\n\nThe Driver appears to be based off the NDIS example source code PassThru. More specifically, the\nauthor(s) of the Driver appear to have used the modified version of the PassThru example,\nPassThruEx, by James Antognini and Thomas Devine from a 2003 blog post[1].\n\n### Gen 2 Driver\nThe Gen 2 sub-family, beginning with Gen 2.0 Beta, employs a Windows device driver (“the Driver”) to\nhide aspects of the DLL’s functionality from normal system processes. The Driver is a relatively\nstraightforward piece of software. It does not attempt to obfuscate its functionality from static analysis\nand it hooks a minimum number of kernel API functions in order to hide different pieces of information.\nThe Driver is based primarily on the open source Agony rootkit[2] and it has evidence of some portions of\nthe code coming directly from a Chinese blog[3].\n\nThe Driver expose an IOCTL interface that supports the following OIDs:\n\nOID Function\n**0x22C000** Add driver (system module) to hide.\n**0x22C004** Reveal all hidden items.\n**0x22C008** Add IP:Port endpoint to hide.\n**0x22E000** No-Op\n**0x22FFD0** Remove PID from hidden list.\n**0x22FFD4** Add PID to list of PIDs to hide.\n**0x22FFD8** Add service to list of services to hide.\n**0x22FFE0** Add local port to list of ports to hide.\n**0x22FFE4** Currently unused. Evidence suggest this was previously a port hiding function, but it\nis no longer functional.\n**0x22FFE8** Currently unused. It is unclear the purpose of this function. It takes a string as its\nargument.\n**0x22FFEC** Add directory to list of directories to hide.\n**0x22FFF0** Add registry key to list of registry keys to hide.\n**0x22FFF4** Add registry key value to list of registry values to hide.\n**0x22FFFC** Purge all hooks and hidden items (\"unhook\")\n\nThe Driver is capable of hiding processes (by PID, not name), system modules, services, network\nconnections, listening ports, directories (and by extension, files), as well as registry keys and values. In\norder to hide these items, the Driver hooks various Windows Kernel API calls. The following table maps\nthe items the Driver can hide to the API function that the Driver hooks:\n\nItem API Function Hooked\n**Process ID** `ZwDeviceIoControlFile`\n**(PID)**\n\n**Registry Key** `ZwEnumerateKey`\n**Registry Value** `ZwEnumerateValueKey`\n**Directory** `QueryDirectoryFile`\n\n1 \r James \r Antognini \r and \r Thomas \r F. \r Divine. \r “Extending \r the \r Microsoft \r PassThru \r NDIS \r Intermediate \r Driver—Parts: \r Two \r IP\nAddress \r Blocking \r NDIS \r IM \r Drivers”. \r December \r 15, \r 2003\n2 \r pudn. \r “Agony \r Rootkit \r code, \r the \r stability \r and \r can \r be \r useful \r Driver \r Develop”.\nhttp://en.pudn.com/downloads74/sourcecode/windows/vxd/detail265112_en.html. \r 8 \r April \r 2007.\n3 \r CardMagic. \r “[Reserved] \r NSI \r Module \r Hook: \r Hiding \r Port \r Under \r Windows \r Vista”. http://forum.eviloctal.com/archiver/tid29604.html. \r 8 \r July \r 2007.\n\n|The Driver expose an IOCTL interface that supports the following OIDs:|Col2|\n|---|---|\n|OID Function||\n|0x22C000|Add driver (system module) to hide.|\n|0x22C004|Reveal all hidden items.|\n|0x22C008|Add IP:Port endpoint to hide.|\n|0x22E000|No-Op|\n|0x22FFD0|Remove PID from hidden list.|\n|0x22FFD4|Add PID to list of PIDs to hide.|\n|0x22FFD8|Add service to list of services to hide.|\n|0x22FFE0|Add local port to list of ports to hide.|\n|0x22FFE4|Currently unused. Evidence suggest this was previously a port hiding function, but it is no longer functional.|\n|0x22FFE8|Currently unused. It is unclear the purpose of this function. It takes a string as its argument.|\n|0x22FFEC|Add directory to list of directories to hide.|\n|0x22FFF0|Add registry key to list of registry keys to hide.|\n|0x22FFF4|Add registry key value to list of registry values to hide.|\n|0x22FFFC|Purge all hooks and hidden items (\"unhook\")|\n\n|the items the Driver can hide to the API function that the Driver hooks:|Col2|\n|---|---|\n|Item API Function Hooked||\n|Process ID (PID)|ZwDeviceIoControlFile|\n|Registry Key|ZwEnumerateKey|\n|Registry Value|ZwEnumerateValueKey|\n|Directory|QueryDirectoryFile|\n\n\n-----\n\n**Loaded Drivers** `ZwQuerySystemInformation`\n\nIn order to hide services, the Driver will access the memory of the services.exe process, locate the\nlinked list of services and remove the service entry that the Driver wishes to hide. This is a surprisingly\ninvasive method to obfuscate a process.\n\nUpon activation, the Driver will expose its interface by calling `IoCreateDevice` with the name\n`\\Device\\agony` (for Gen 2.0 Beta samples), \\Device\\HTTPS (for Gen 2.1 samples),\n`\\Device\\advcachemgr` (for Gen 2.2 samples) or \\Device\\diskdump (for Gen 2.3 samples). The\nDriver also creates a symbolic link to the device using the same name but under the `\\DosDevices\\`\ntree.\n\nFor reasons unknown, the authors of the Driver used code from a Chinese blog that details how to hide\nnetwork connections on Windows Vista and later decided to keep the example IP address within the\ncode.\n\n## Functionality and Commands\nThe Hikit family has supported roughly the same set of commands since the first known samples of\nGen 1.0. Gen 2.0 introduced a single command to provide insight into an infected machine’s Hikit\nconfiguration (something that is not necessary for Gen 1 variants since they are server-based). The\nRAT supports the following commands:\n\n**Command** **Introduced** **Description**\n**shell** Gen 1.0 Establishes a remote command shell on the victim machine\n**file** Gen 1.0 File managerment\n**connect** Gen 1.0 Establishes a tunnel connection (e.g. port forwarding) through\nanother Hikit sample\n**socks5** Gen 1.0 Establishes a forwarding proxy (retired in Gen 1.2)\n**proxy** Gen 1.2 Establishes a forwarding proxy\n**information** Gen 2.0 Returns the configuration for the Hikit infection\n\nAlpha\n\n**exit** Gen 1.0 Terminates a channel\n\n### Command: shell\nThe `shell` command activates a remote shell on the victim’s computer. The remote shell function uses\nthe standard pipe redirection method for interfacing a network application (in this case, the DLL) to a\nhidden command shell.\n\n### Command: file\nThe `file` command provides an attacker with a variety of disk access options such as listing\ndirectories, changing the current directory, and uploading and downloading files.\n\n|Item API Function Hooked|Col2|\n|---|---|\n|Local Listening Port|ZwDeviceIoControlFile|\n|Remote Endpoint|ZwDeviceIoControlFile|\n|Loaded Drivers|ZwQuerySystemInformation|\n\n|Command Introduced Description|Col2|Col3|\n|---|---|---|\n|shell|Gen 1.0|Establishes a remote command shell on the victim machine|\n|file|Gen 1.0|File managerment|\n|connect|Gen 1.0|Establishes a tunnel connection (e.g. port forwarding) through another Hikit sample|\n|socks5|Gen 1.0|Establishes a forwarding proxy (retired in Gen 1.2)|\n|proxy|Gen 1.2|Establishes a forwarding proxy|\n|information|Gen 2.0 Alpha|Returns the configuration for the Hikit infection|\n|exit|Gen 1.0|Terminates a channel|\n\n\n-----\n\n### Command: connect\nThe `connect` function provides the functionality to allow one Hikit DLL to interface with another DLL of\na similar version. The use of this functionality can best be illustrated by considering the fact that the\nGen 1 Driver requires an exposed network interface in order for an external attacker to access the Gen\n1’s RAT function. This would prohibit lateral movement within a victim’s network as the bulk of any\norganization’s network infrastructure is not directly exposed to the Internet. By using the connect\ncommand, an attacker can instruct the externally exposed Gen 1 DLL to route traffic to a Gen 1 DLL\nthat is behind the firewall, effectively making the externally exposed Gen 1 DLL a local router for Hikit\ntraffic.\n\n### Command: proxy (Gen 1.2 and later), socks5 (Gen 1.0 and 1.1)\nThe `proxy` (or `socks5) command allows an attacker to utilize a Hikit-infected machine as a proxy.`\n\n### Command: information\nGen 2 samples rely on a configuration in order to know where the C2 server exists along with other\noperational aspects such as the name of its service and operational times. This information is important\nfor the attacker to have access to in order to determine if any aspect of the configuration is out of date\n(thus requiring a new variant of the Gen 2 binary to be configured and deployed). The `information`\ncommand returns to the attacker the complete configuration and current state of the Gen 2 malware.\n\n### Command: exit\nAs the name implies, the `exit` command causes the DLL to discontinue the current connection.\n\n## Hikit Core Analysis\nWith the Gen 1 sub-family using a server model and the Gen 2 sub-family using the client model,\nunderstanding how each of the DLL components of the sub-families works is best done, as with the\nDriver above, in the context of the specific sub-family.\n\n### Gen 1 Analysis\nAs noted previously in this report, the Gen 1 sub-family has several sub-generations but overall the\nfunctionality of the Gen 1 sub-family has remained constant. With the exception of Gen 1.0, the\nfunctionality of Gen 1 comes from the DLL component (Gen 1.0 uses a stand-alone executable to\nachieve the same results). The DLL operates as a service, requiring an attacker is install the DLL as a\nservice at some point prior to activation. The DLL contains only two exports: DllEntryPoint and\n```\nDllRegisterServer. \r Ultimately, both exports generate a new thread of the same function\n\n```\n(“mainThread”). The difference between the two exports is that DllRegisterServer can take an\noptional command line argument of the letter “u” which will instruct the main thread to uninstall the Gen\n1 system from a victim’s computer. If the uninstall argument exists, `mainThread` will simply remove the\nDriver from the victim’s machine and terminate. The authors of Gen 1 used freely available source code\nfound online for their removal function.[4]\n\n4 \r PCAUSA. \r “Programmatically \r Installing \r NDIS \r Protocol \r Drivers” \r http://www.ndis.com/ndisgeneral/ndisinstall/programinstall.htm. \r 2 \r December \r 2013.\n\n\n-----\n\nWhen the DLL activates, either by a call to `DllEntryPoint` or by calling `DllRegisterServer`\nwithout the u parameter, `mainThread` begins by verifying the version of the Driver installed on the\nvictim’s machine. This requires sending OID 0x12C850 to the Driver and comparing the resulting 32-bit\nvalue with the required driver version. If the version is incorrect (i.e. it doesn’t match the specified\nversion), the DLL installs the version of the Driver found within the DLL’s resource section (under the\n`BIN` resource tree).\n\nWith the Driver version verified (or forcibly corrected by installing the appropriate Driver), the DLL will\ninstruct the Driver to use a specified string (for Gen 1.0 and Gen 1.1 samples) or a DWORD (for Gen\n1.2 samples) as the acknowledgment value to send to a connecting client who requests the appropriate\nURL. The DLL again checks the version of the Driver and, in some versions of the DLL, will print a\nmessage indicating the version of the Driver installed and report the “Transate version” (the word\ntranslate is misspelled within the binary). It appears that the Driver and the communication protocol\nversion do not necessarily have to match exactly, allowing the possibility that the Driver and the DLL\ncould be compiled at separate times. If the Driver version is less than the “Transate” version (indicating\nthat the Driver is a version too old to support the necessary communication protocols), the DLL will, in\nsome version of the DLL, print out a line to the screen indicating the DRIVER_MIN_VERSION required\nalong with the current Driver version. Following this, the DLL will then attempt to install the correct\nversion of the Driver prior to terminating. It is unclear why this code exists given that the DLL will check\nthe Driver version and correct the Driver if necessary prior to reaching the portion of the code that\nreports the `DRIVER_MIN_VERSION. \r It is possible that the second Driver version check is a last ditch`\neffort to ensure the correct Driver is installed.\n\nThe DLL enters an infinite loop where the DLL waits for the Driver to report a new channel exists. A\nchannel represents an established connection between the Driver and an external party that has\nprovided the proper initial request and, for Gen 1.2 variants, provided the proper authentication value.\nWhen the Driver establishes a new channel, the DLL generates a runtime data structure before\ngenerating a new thread (“HikitThreadFunc”) which will service any request coming from the new\nchannel. This allows the DLL to service multiple channels at one time.\n\nThe HikitThreadFunc function is, at its core, a simple wait and respond loop. The function begins by\ntransmitting a Hikit command prompt to the client (Hikit>) before settling into an infinite loop of\n\n  - Read data from channel (wait until data is available)\n\n  - [For Gen 1.2] Decrypt the packet header\n\n  - Verify the packet header to ensure the communication version is correct and the payload data\nsize is non-zero\n\n  - Read the remainder of the packet (e.g. the payload portion)\n\n  - If the packet type field (dwPacketType) is zero, send the payload section to the command\nprocessor.\n\n  - Send the Hikit prompt\n\nThe communication scheme between the DLL and the client consists of a 20 to 24 byte header (for Gen\n1.0 and Gen 1.1) or a 28 byte header (for Gen 1.2) followed by an optional payload. The format of the\nGen 1.0 and Gen 1.1 header is as follows:\n\n\n-----\n\n```\nstruct PacketHeader\n{\n   char magic[5];\n   char zeros[3];\n   DWORD dwHikitVersion;\n   DWORD dwCmdType;\n   DWORD dwLocale; // omitted in some Gen 1.0 variants\n   DWORD dwPayloadSize;\n};\n\n```\nWhile the Gen 1.2 header is:\n```\nstruct PacketHeader\n{\n   DWORD key;\n   DWORD dwHikitVersion;\n   DWORD dwPacketType;\n   DWORD dwLocale;\n   DWORD dwCodePage;\n   DWORD dwPayloadSize;\n};\n\n```\nFor Gen 1.0 and Gen 1.1 samples, the magic field contains the string “.. ..” (two dots followed by a\nspace then two more dots). Whereas the key field in Gen 1.2 samples contains a 32-bit value that\nrepresents the XOR key for the remainder of the PacketHeader and any additional payload data. The\nXOR scheme works on 32-bit chunks of data where each 32-bit chunk of data is XOR’d against the key\nvalue.\n\nVersion checking is important in all Gen 1 variants. The dwHikitVersion field allows the client and\nthe DLL to ensure that they have a compatible communication scheme in place prior to executing\ncommands.\n\nGen 1 samples have a particular interest in the victim’s locale language preferences. While it is typical\nfor most RATs that provide remote shells to simply pass data unfiltered from client to server and server\nto client without regard to code pages, Gen 1 samples take special care to record the code page and\nlocale information in each and every packet header that traverses the divide between client and server\nand server and client. This could indicate that the authors of Gen 1 understood from an early stage in\nthe development of Gen 1 that they would be attacking computer systems with different locales and\ncode pages.\n\n### Gen 2 Analysis\nThe Gen 2 sub-family, like Gen 1.2, uses a DLL for the core of its RAT functionality. In order for the\nDLL to load, Gen 2 (starting with Gen 2.1) uses a loader application (referred to simply as “the\nLoader”). The Loader comes in the form of a standard executable image or a DLL image. Despite the\ndifferent models, both variants of the Loader load the embedded DLL in the exact same way. The only\ndifference between the executable and DLL versions of the Loader comes in how they handle the\ninitialization of the embedded DLL.\n\n\n-----\n\n|Col1|Col2|\n|---|---|\n\n\n_Figure 1: DLL (left) and executable (right) Loader startup routines_\n\nFigure 1 provides a side by side comparison of the startup routines for the executable and DLL\nLoaders. Both versions of the Loader begin by loading the embedded DLL from the Loader’s resources\n(item 102 under the Group Icons resource tree), decrypting and decompressing the image into memory,\nthen manually loading the DLL into memory using a custom loading routine. The function\n```\n     LoadEmbeddedImage, as seen in part in Figure 2, is responsible for this operation. \n\n```\n\n-----\n\nThe Loader stores the embedded DLL within a Group Icon resource within a legitimate icon image. In\norder to locate the embedded DLL, `LoadEmbeddedImage` will use the `DecodeString` function to\ndecrypt the delimiter string (which is typically `zzzzzzzzzz` or `yyyyyyyyyy) and then search the icon’s`\nresource memory for the delimiter string. Once located, `LoadEmbeddedImage` will use the first 12\nbytes immediately after the string as the information structure about the embedded DLL. The structure\n(seen below) defines the size of the embedded DLL within the icon’s resource memory, the size of the\n\n\n_Figure 2: LoadEmbeddedImage function snippet_\n\nThe Loader obfuscates many strings by using a simple XOR encoding scheme. Decryption of encoded\nstrings consists of taking the first value of the string as the XOR key, XOR’ing all subsequent bytes until\nthe result of the XOR returns 0. The decoding of the encoded strings is handled by the DecodeString\nfunction.\n\nThe Loader stores the embedded DLL within a Group Icon resource within a legitimate icon image. In\n\n\n-----\n\nDLL after it is decompressed and a 4-byte XOR key that `LoadEmbeddedImage` must use to decode\nthe embedded DLL prior to decompression.\n```\n struct ImageHeader\n {\n  DWORD dwImageEncodedSize;\n  DWORD dwImageSizeDecompressed;\n  DWORD EncodingKey;\n };\n\n```\n`LoadEmbeddedImage` copies the compressed embedded DLL into a newly allocated heap buffer and\nthen calls the function `decodeBuffer` (using the `EncodingKey` value) to decrypt the embedded DLL.\nAnother heap buffer is allocated with a size equal to the value of `dwImageSizeDecompressed. \r The`\ndecompression buffer along with the now decoded compressed buffer are given to lzo_decompress\nwhich decompresses the compressed image using the LZO1X algorithm[5].\n\nWith the embedded DLL now decompressed into a heap buffer, LoadEmbeddedImage calls\n`ImageLoaderData::LoadDll` to manually load the DLL into memory.\n`ImageLoaderData::LoadDll` interprets the PE/COFF header of the DLL image, loads the image\ninto the appropriate memory configuration, performs the necessary relocation operations, and calls the\n`DllMain` (DLL’s entry point) function.\n\nAfter loading the embedded DLL image into memory, the Loader will either call the DLL’s\n`StartServer` or `MatrixMain` function depending on the type of Loader. The standalone Loaders use\nthe `MatrixMain` function while the DLL Loaders will call the `StartServer` function. The Loaders,\nupon unloading, will call the StopServer function in order to shut down the embedded DLL.\n\nThe Gen 2 DLL exposes five exported functions (besides the `DllEntryPoint/DllMain).`\n\n**Export Name** **Description**\n**DllRegisterServer** If the Gen 2 RAT is running, waits for the RAT to shut down before returning.\n**MatrixMain** Activates the Gen 2 RAT (called from a stand-alone Loader)\n**SetModuleHandle** The given parameter becomes the new module handle for the RAT.\n**StartServer** Activates the Gen 2 RAT (called from a DLL Loader)\n**StopServer** Stops the Gen 2 RAT (called from a DLL Loader)\n\n`MatrixMain` and `StartServer` both ultimately generate a new thread (using the POSIX API function\n`beginthreadex` instead of the more common `CreateThread) that contains the main loop of the Gen`\n2 RAT functionality. MatrixMain, however, has added functionality. The prototype for MatrixMain is as\nfollows:\n```\n   int MatrixMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR\n                lpCmdLine, int nShowCmd))\n\n```\n5 \r Markus \r F.X.J. \r Oberhumer, \r “LZO \r real-­‐time \r data \r compression \r library” \r http://www.oberhumer.com/opensource/lzo/. \r 29\nJune \r 2014.\n\n|Export Name Description|Col2|\n|---|---|\n|DllRegisterServer|If the Gen 2 RAT is running, waits for the RAT to shut down before returning.|\n|MatrixMain|Activates the Gen 2 RAT (called from a stand-alone Loader)|\n|SetModuleHandle|The given parameter becomes the new module handle for the RAT.|\n|StartServer|Activates the Gen 2 RAT (called from a DLL Loader)|\n|StopServer|Stops the Gen 2 RAT (called from a DLL Loader)|\n\n\n-----\n\nwhere Arguments parameter can be:\n\n**Arguments string** **Purpose**\n`test {DWORD identifier (IP?)}` Overrides the current configuration with the given\n`{listening Port} [C2 address] [C2 port]` settings. The C2 arguments are optional.\n\n`i` Installs trojan service\n`u` Uninstalls the trojan service\n`s` Sets the SHOW flag for the service to instruct the\nDriver to reveal the service.\n`h` Sets the HIDE flag for the service to instruct the\nDriver to hide the service.\n`q` Sets the STOP flag for the RAT.\n\nIf the i parameter is given, the DLL will install itself as a service on the victim’s machine. The DLL will\ncreate a new service (e.g. “Network DDE Service”) and assign itself as the executable for the service.\n\nThe DLL’s RAT functionality provides basic features such as network port forwarding (proxying), file\ntransfer, and remote command shell. The RAT functionality provides an attacker with the ability to\nestablish a phantom network within a victim’s infrastructure by having individual instances of Gen 2 DLL\nlisten for incoming connections on local ports (presumably, NAT’d ports) and accept commands from\nthe inbound connection. This allows an attacker to establish several Gen2 infections within a victim’s\ninfrastructure and if outbound connectivity is prohibited for any of the infected machines, the attacker\ncan route commands to the pseudo-isolated infections through accessible infected machines providing\na high level of persistence to the malware. Each Gen 2 infection can support up to 10 listening ports.\n\nThe communication between the Gen 2 malware and the C2 (or other Gen 2 malware, in the case of\nthe internal routing functionality) is encrypted using a simple DWORD XOR scheme. Each\ncommunication burst (either between the malware and the C2 or the malware and neighboring\nmalware) begins with a 24-byte header identical to the header found in Gen 1.2. Immediately following\nthe header is the type-specific (as indicated by the `dwPayloadType field) payload data. Note that the`\n`dwXORKey` value is NOT encoded with the XOR value, but rather is the value that is used for encoding\nthe header and payload.\n\nEach DLL includes a hardcoded, default configuration. At the time that the RAT functionality activates,\nthe DLL will drop the current configuration to disk. If the configuration file already exists, then the RAT\nwill use the file version of the configuration over the default configuration. The configuration data\nstructure (seen below) doubles as a current state record for some aspects of the communication\nsubsystem of the DLL. When stored on disk, the configuration is preceded by a GUID value (16 bytes)\nthat represents the unique identifier for the specific infection. The configuration is XOR encoded using\nthe first 4 bytes (as a DWORD) of the GUID.\n\n|Arguments string Purpose|Col2|\n|---|---|\n|test {DWORD identifier (IP?)} {listening Port} [C2 address] [C2 port]|Overrides the current configuration with the given settings. The C2 arguments are optional.|\n|i|Installs trojan service|\n|u|Uninstalls the trojan service|\n|s|Sets the SHOW flag for the service to instruct the Driver to reveal the service.|\n|h|Sets the HIDE flag for the service to instruct the Driver to hide the service.|\n|q|Sets the STOP flag for the RAT.|\n\n\n-----\n\n```\n struct Config\n {\n  WCHAR wszComment[32];\n  C2ConfigInfo arrC2s[2];\n  ListeningPortConfig ListeningPorts[10];\n  int dwStartTime;\n  int dwEndTime;\n  __int16 Flags;\n  SYSTEMTIME sleepUntil;\n  __int16 unused_align2_2;\n  int fRunHidden;\n };\n struct C2ConfigInfo\n {\n  WCHAR wszAddress[32];\n  __int16 wPort;\n  __int16 unused_align2;\n  int fValidC2;\n };\n struct ListeningPortConfig\n {\n  unsigned __int16 wPort;\n  unsigned __int16 unused_align2;\n  int fReady;\n  SOCKET hSocket;\n  HANDLE hEvent;\n  HANDLE hListenerThread;\n };\n\n```\nIn order to provide some level of stealth, the RAT will install a rootkit on 32-bit versions of Windows.\nThe DLL contains a device driver image embedded within an encoded buffer which the RAT\nfunctionality code will extract to the %TEMP% directory (after XOR’ing the buffer with 0x76). To activate\nthe rootkit, the RAT functionality code creates a service with the driver in the %TEMP% directory as the\nexecutable for the service. The RAT functionality code then activates the service and opens a handle to\ndevice driver’s interface (e.g. \\Globals\\HTTPS). With the handle open to the rootkit driver, the RAT\nfunctionality code deletes the service in order to reduce the visible footprint of the new driver. To further\nreduce the footprint of the driver, the RAT functionality code also uses the cloaking functionality of the\nrootkit to hide the DLL’s PID, any references to the GUID {4AE26357-79A3-466D-A6D9```\nFC38BFB67DEA}, the DLL’s service names (e.g. “NetDDESrv” and \"Network DDE Service\") and the\n\n```\nservice entry as well. Additionally, the code also attempts to hide a service named “Hitx”.\n\n## Support Software\nIn addition to the main Hikit malware, there are at least two examples of support programs that belong\nto the Hikit family. Samples b04de6c417b6f8836e3f2d8822be2e68f4f9722b and\n7c4da9deff3e5c7611b9e1bd67d0e74aa7d2d0f6 are examples of Gen 1.0 and Gen 1.2 operator\nconsoles. The console is a text based application that takes a Gen 1.0 or Gen 1.2 infection’s IP address\nand proceeds to connect and authenticate with the infected server. Once connected, the operator has\nthe basic Hikit functionalities available to them via commands such as file and shell.\n\n\n-----\n\n## Detection\nDetecting Hikit variants on disk and in memory is possible using the following YARA signature\ndeveloped by Symantec:\n```\nrule hikit\n{\n   strings:\n       $hikit_pdb1 = /(H|h)ikit_/\n       $hikit_pdb2 = \"hikit\\\\\"\n       $hikit_str3 = \"hikit>\" wide\n       $driver = \"w7fw.sys\" wide\n       $device = \"\\\\Device\\\\w7fw\" wide\n       $global = \"Global\\\\%s__HIDE__\" wide nocase\n       $backdr = \"backdoor closed\" wide\n       $hidden = \"*****Hidden:\" wide\n   condition:\n       (1 of ($hikit_pdb1,$hikit_pdb2,$hikit_str3)) and ($driver or\n$device or $global or $backdr or $hidden)\n}\nrule hikit2\n{\n   strings:\n    $magic1 = {8C 24 24 43 2B 2B 22 13 13 13 00}\n    $magic2 = {8A 25 25 42 28 28 20 1C 1C 1C 15 15 15 0E 0E 0E 05 05 05\n00}\n   condition:\n    $magic1 and $magic2\n}\nrule hidkit\n{\n   strings:\n    $a = \"---HIDE\"\n    $b = \"hide---port = %d\"\n   condition:\n    uint16(0)==0x5A4D and uint32(uint32(0x3c))==0x00004550 and $a and $b\n}\n\n```\nDetecting nominal Gen 1.2 and later network activity is problematic given the nature of the\ncommunication structure. The encrypted nature of the nominal Gen 1.2 and later network traffic makes\na signature difficult. Snort signature 30948 may detect some Hikit based network traffic for only Gen 1.0\nand Gen 1.1.\n\n\n-----\n\nFrom a system objects perspective, Gen 2 samples produce up to three named events. The event\nnames change per infection, but have a common format. The following three strings represent the\nknown mutex strings for Gen 2 samples:\n```\n                  Global\\%s__SHOW__\n                  Global\\%s__HIDE__\n                  Global\\%s__STOP__\n\n```\nwhere the %s format variable is replaced with a UUID value string specific to the infected machine.\n\n\n-----\n\n-----\n\n## Appendix A: HiKit Versions\n\n\n**Generation**\n**Identifier**\n\n\n**Starting Date** **Notable Features**\n\n\n**Gen 1.0** 31 March 2011 First known Hikit samples. Stand-alone console executable.\n**Gen 1.1** 18 April 2011 Uses DLL and driver model.\n**Gen 2.0** 28 August 2011 First client-based Hikit variants. Stand-alone console\n**Alpha** executable. Does not use a device driver. Encrypted\n\ncommunication.\n**Gen 1.2** 23 October 2011 Command “socks5” changes to “proxy”. Encrypted\ncommunication.\n**Gen 2.0** 27 February 2012 Introduces the use of the device driver.\n**Beta**\n\n**Gen 2.1** 17 April, 2012 First known production variant of the Gen 2 family. Uses the\nconcept of the Loader, the DLL and the Driver as a complete\nsystem.\n**Gen 2.2** 21 February 2013 Changes storage location for configuration file. Largely similar\nto Gen 2.1. DLL-based and executable-based loaders. Largest\nin-service time span.\n**Gen 2.3** 12 December Significantly more advanced authentication when doing intra2013 malware communication. Use of SSL certificate during\n\nhandshake.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/k1zaybbj4ickaq5u0flu9bpmtp8a1e5k",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2014/2014.10.14.Hikit_Preliminary_Analysis/Hikit_Analysis-Final.pdf",
        "https://www.novetta.com/wp-content/uploads/2014/11/HiKit.pdf"
    ],
    "report_names": [
        "Hikit_Analysis-Final",
        "HiKit.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716503,
    "ts_updated_at": 1743041135,
    "ts_creation_date": 1414464206,
    "ts_modification_date": 1414464206,
    "files": {
        "pdf": "https://archive.orkl.eu/5c4415913a16a0331600816bb4cf8a1954e743dd.pdf",
        "text": "https://archive.orkl.eu/5c4415913a16a0331600816bb4cf8a1954e743dd.txt",
        "img": "https://archive.orkl.eu/5c4415913a16a0331600816bb4cf8a1954e743dd.jpg"
    }
}