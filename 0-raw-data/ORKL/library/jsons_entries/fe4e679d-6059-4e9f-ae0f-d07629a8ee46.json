{
    "id": "fe4e679d-6059-4e9f-ae0f-d07629a8ee46",
    "created_at": "2023-01-12T14:59:38.968014Z",
    "updated_at": "2025-03-27T02:09:29.288966Z",
    "deleted_at": null,
    "sha1_hash": "7e713df8bec4b9b14227665a5b2f985e95b2b2dd",
    "title": "2022-04-17 - Reversing a NSIS dropper using quick and dirty shellcode emulation",
    "authors": "",
    "file_creation_date": "2022-05-28T23:25:00Z",
    "file_modification_date": "2022-05-28T23:25:00Z",
    "file_size": 1665524,
    "plain_text": "# Reversing a NSIS dropper using quick and dirty shellcode emulation\n\n**[malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/](https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/)**\n\n**Sample:**\n\n[e850f3849ea82980cf23844ad3caadf73856b2d5b0c4179847d82ce4016e80ee (Bazaar,](https://bazaar.abuse.ch/sample/e850f3849ea82980cf23844ad3caadf73856b2d5b0c4179847d82ce4016e80ee/) [VT)](https://www.virustotal.com/gui/file/e850f3849ea82980cf23844ad3caadf73856b2d5b0c4179847d82ce4016e80ee)\n\n**Infection chain:**\n\nExcel stylesheet -> Office equation -> Shellcode (downloader) -> NSIS installer -> Shellcode\n(stage 1) -> Shellcode (stage 2) -> Lokibot\n\n**Tools used:**\n\n[Malcat,](https://malcat.fr/) [Speakeasy emulator](https://github.com/mandiant/speakeasy)\n\n**Difficulty:**\n\nEasy\n\n## The Excel document\n\nThe sample we are about to dissect today is an OpenXML Excel document which came as\nemail attachment. The malicious document is very similar to the one we did analyze in our\n[previous blog post: an encrypted OpenXML Excel document embedding an Equation object](https://malcat.fr/blog/exploit-steganography-and-delphi-unpacking-dbatloader/)\nexploiting CVE-2018-0798. The same author is most likely behind this document as well,\nthey just updated the bait picture:\n\n\n-----\n\nFigure 1: Excel sheet baiting the user to deactivate safe mode\nWe won't go through the exploit shellcode extraction and decryption process again since the\n[procedure is exactly the same (see here, shellcode offset is also](https://malcat.fr/blog/exploit-steganography-and-delphi-unpacking-dbatloader/#exploiting-cve-2018-0798) `0x50 ). The exploit is again`\na downloader, downloading from the following url:\n\n```\nhxxp://103.153.79.104/windows10/csrss.exe\n\n```\n\nAt the time of the analysis, the file is still online. But this time, we don't get a DBatLoader\ninstance, but a NSIS installer instead. So let us fetch the file and have a look at the installer.\n\n## NSIS installer\n\nThe file `csrss.exe is a 418KB PE file of sha256`\n\n`291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d` [(Bazaar,](https://bazaar.abuse.ch/sample/291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d/)\n[VT). A NSIS installer is nothing more than a NSIS archive appended to the NSIS PE installer.](https://www.virustotal.com/gui/file/291df8186e62df74b8fcf2c361c6913b9b73e3e864dde58eb63d5c3159a4c32d)\nThe file format of the archive, while not very documented, is relatively simple as we will see.\n\n## NSIS archive\n\nA NSIS archive is composed of a small NSIS header followed by the archive content. The\nheader does not contain a lot of information:\n\n\n-----\n\n```\nFirstHeader: \n  Flags:                           // some installation\nflags\n  Signature:                 0xdeadbeef   // NSIS archive start\nmagic\n  Magic:                   \"NullsoftInst\" // also magic\n  InstallerSize:               0x6244     // unpacked size of\nthe setup script\n  ArchiveSize:                0x5e12e     // size of the\narchive\n\n```\nLike you can see, it does not tell us a lot. Directly following the headers come the \"files\". I\nsay \"files\" because they don't really have names, it is more like a list of data bytes or buffers.\nThe files are compressed, and can be stored using two modes:\n\nthe solid mode: archive content is a single compressed stream. The unpacked stream\nis a sequence of N buffers, where each buffer is prefixed by a DWORD telling the size\nof the buffer.\nthe non-solid mode: archive content is a sequence of N compressed streams, one for\neach file. Each compressed stream is prefixed by a DWORD telling the size of the\nstream.\n\nThere is sadly no flag in the header telling us which mode is used, this information is\nhardcoded inside the NSIS installer executable. The only solution there is trial and error: if\nthe start of the archive starts with a DWORD which could be a size, then it's most likely the\n_non-solid mode. If it looks like a compression header, then it's most likely the solid mode._\nAnd regarding compression, NSIS supports three compression algorithms:\n\nLZMA (without headers)\nZlib\nA custom bzip2 compression algorithm\n\nMalcat supports NSIS files using both solid and non-solid mode for the Zlib and LZMA\ncompression methods, but lacks support for bzip2, since the compression algorithm is\ncustom. But since it's also the least used one, it's not really a big deal. The NSIS archive we\nare looking at is a solid LZMA archive, so unpacking it is no issue. Like for most archive\nformats, Malcat lists found files in the upper left corner of the screen, under the Virtual File\n_System tree. Double-clicking on a file opens it inside Malcat._\n\nFigure 2: Content of the archive\n\n\n-----\n\nThe first file is always the installer setup script, followed by user-provided files and/or installer\nplugins. As you can see, Malcat did give name to some of the files (all but the last one) which\nsomehow contradicts what I said before. But these names have been recovered by reversing\nthe SETUP script, and there is no guarantee that it is the real name for these files. Even\nworse, a buffer in the archive can be extracted under different names on the local filesystem,\nso don't trust these names 100%.\n\n## The SETUP script\n\nThe first thing to look at when reversing a NSIS installer is the setup script. NSIS scripts are\na bunch of sections and assembly code written for the NSIS virtual machine. The NSIS VM\narchitecture is relatively simple:\n\nEvery instruction is encoded on 7 DWORDs: first DWORD is for the opcode (about 70\ndifferent opcodes) and the other 6 DWORD encode arguments\nDepending on the opcode, arguments can be either:\n\na register (up to 31 registers): `$0 ..` `$9,` `$R0 ..` `$R9 or one of 11 specific`\nregisters like `$EXEPATH or` `$CMDLINE (some are read-only, so more like`\nconstants)\na global variable: `$var0 ..` `$varN`\nan integer, signed or unsigned. It can also be an offset into the code section for\njump-like opcodes\na string, more precisely an index into the `Strings section of the setup script`\nStrings themselves can be somewhat complex to parse/interpret:\n\nthere are 3 NSIS versions: ansi, park (a mix between ansi and unicode) and\nunicode. Each version encodes strings differently. There is sadly no flag telling\nyou which version is used.\nstrings can contains any of 4 special opcodes: `skip,` `shell,` `var or` `lang`\nstrings can include reference to system paths, variables or other strings, e.g.\n\n```\n\"open {$INSTDIR}\\rampage\\goodie\\noticeably.tif\"\n\n```\n\nLuckily for us, the full edition of Malcat features a NSIS disassembler / decompiler, so let us\njump directly to the entry point of the script (Ctrl+E) and have a look at the `OnInit method:`\n\n\n-----\n\nFigure 3: NSIS setup script entry point\nWe can see that the script does the following:\n\nextract the first buffer (offset `header+0 in archive) to a file named` `d54hdan9c9ebsx`\nextract the second buffer (offset `header+0x34f0f in archive) to a file named` `lognp`\nextract the third buffer (offset `header+0x36390 in archive) to`\n```\n   ${PLUGINDIR}\\dwksh.dll, wherever that could be\n\n```\ncall dwksh.dll's exported method `sdvffryp without any argument`\n\nThe rest of the method seems like junk code, judging by the strings which are either random\nletters or picked out of dictionary. Quickly inspecting the first two files tells us that both are\nencrypted and/or compressed, so no quick-win there. We have to dig into the dll.\n\n## Stage 1: dwksh.dll\n\ndwksh.dll is a 294KB 32-bits DLL of sha256\n\n`be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e` [(VT). It](https://www.virustotal.com/gui/file/be00a655cdf4e4706bf1bbf3659d698f967cad66acdf7cda0d12f16dc0cfda3e/detection)\ncontains several obfuscated methods. But we reversed the setup script and know what to\nlook for: the method `sdvffryp . This methods starts by reading a local file named` `lognp :`\n\n\n-----\n\nFigure 4: lognp file is accessed\nIt then seems to decrypt it in memory into an executable buffer before jumping at the\nbeginning of the buffer (see the `call eax below?). The file` `lognp is relatively small`\n(5KB), it definitely looks like a shellcode.\n\nFigure 5: decryption loop in method sdvffryp\n\n\n-----\n\nThe decryption is pretty straightforward according to the sleigh decompiler. Every byte seem\nto be decrypted using the following formula:\n```\n  byte[i] = ((((byte[i] - 3) ^ 0xf2) + 0x11) ^ 0x28) - 1\n\n```\nDecrypting the `lognp file should be a piece of cake. Just open the file inside Malcat, select`\nevery byte (Ctrl+A) and open the transform dialog (Ctrl+T). There you can chose the\n```\ncustom arithmetic transform which allows you to transform sequence of\n\n```\nbytes/words/dwords using a custom python expression. Just paste the equation above,\nreplacing `byte[i] by` `value and voila, you've just decrypted the second stage.`\n\nFigure 6: decrypting the shellcode\nFor the lazy readers, you can download the decrypted `lognp file` [here (password: infected).](https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/shellcode.zip)\n\n## Stage2: obfuscated shellcode\n\n Analyzing the shellcode\n\nThe `lognp file, once decrypted, does not appear to be in any known file format. But the first`\nbyte is `E9, which is a jump in the x86 architecture and is very typical for shellcode prologs.`\nSo before starting the analysis, we will have to tell Malcat two things:\n\n\n-----\n\nthe architecture used: x86 in our case. This can be set using the dropdown menu in the\nstatus bar\nthe entry point of the shellcode, which is at address 0 in our case. We just have to\ndefine a new function start at this address using the context menu in disassembly\nmode (F3)\n\nAfter this, Malcat is smart enough to recover most of the shellcode's CFG using its usual set\nof analyses. Following the control flow, we quickly arrive in the function `sub_7dd which`\ncontains interesting patterns:\n\nthe string `d54hdan9c9ebsx (one of the NSIS archive's file names) is pushed on the`\nstack at address `0x8eb`\nsomething like a `CreateFileA API call is performed at address` `0x989 (the constant`\n```\n   0x80000000 is most likely for GENERIC_READ ). If we wanted to be sure, we would\n\n```\nhave to emulate the API lookup function at address `0x776, but it looks like safe`\nassumption.\nsoon after, the function `sub_a01 gets called. Decompiling this functions reveals`\nsomething similar to a decryption loop\n\nThe whole process can be retraced in the animated GIF below:\n\n\n-----\n\nFigure 7: locating the decryption function inside the shellcode\nThe code of the decryption function is given below. It is obviously obfuscated, and sadly it\nwould not be immediate to reimplement it in python in Malcat. So we will have to find an\nalternative. Since the decryption function prototype is very simple (it just needs a pointer to\nthe buffer and the buffer size) and is without side effects, why not give emulation a go?\n\n\n-----\n\n```\nBYTE sub_a01(BYTE buffer, uint4 size) {\n  uint1 uVar1;\n  char cVar2;\n  uint1 uVar3;\n  uint4 i;\n  i = sub_0;\n  while (i < size) {\n    uVar3 = i;\n    uVar1 = -uVar3 - ((*(buffer + i) >> 1 | buffer[i] << 7) - 0x40 ^ 0xf2);\n    uVar1 = -uVar3 - (uVar1 >> 7 | uVar1 * '\\x02');\n    uVar1 = -uVar3 - (((uVar1 >> 3 | uVar1 * ' ') ^ uVar3) - uVar3 ^ 0x9c) ^\n0xd6;\n    cVar2 = ~((uVar1 >> 7 | uVar1 << 1) + 0x34 ^ 0x87) - 0x10;\n    uVar1 = ~(((-cVar2 >> sub_5 | cVar2 * -8) ^ 0x1d) + 0xac) ^ 0x5e;\n    uVar1 = ~-(((0x99 - ((uVar1 >> 2 | uVar1 << 6) + 0x49) ^ 0xa0) + 0x30 ^ 0x34)\n+ uVar3);\n    uVar1 = (-uVar1 >> 6 | uVar1 * -4) - uVar3 ^ uVar3;\n    uVar1 = (-uVar1 >> 2 | uVar1 * -0x40) + 0x93;\n    uVar1 = (-((((uVar1 >> sub_5 | uVar1 * '\\b') - 0x2e ^ 7) + 0xd ^ 0x96) +\n0x31) ^ 0x73) + uVar3;\n    uVar1 = -uVar3 - ((uVar1 >> 2 | uVar1 * '@') + 0x61) ^ uVar3;\n    uVar1 = ~((uVar1 >> 3 | uVar1 << sub_5) ^ uVar3);\n    uVar1 = (uVar1 >> 7 | uVar1 << 1) + uVar3 ^ 0x2e;\n    uVar1 = ~(~((uVar3 - (~(~(-(0xbc - ((uVar1 >> 6 | uVar1 << 2) - uVar3) ^\n0x1e) ^ 0xc5) ^ 0x46) ^ 0xc1) ^ 0x4c) +\n          uVar3) ^ 0x4d) + 0x4c ^ uVar3;\n    uVar3 = 0x2d - (-((uVar1 >> 3 | uVar1 << sub_5) + uVar3) ^ 0x43);\n    buffer[i] = (uVar3 >> 7 | uVar3 * '\\x02') + 0x15;\n    i = i + 1;\n  }\n  return buffer;\n}\n\n## Emulating the decryption function\n\n```\nTo emulate shellcodes, Malcat comes bundled with a script named\n```\nspeakeay_shellcode.py which emulates shellcodes using the Speakeasy emulator. Note\n\n```\nthat Speakeasy is not bundled with Malcat, you will have to install the python package\nyourself (and if you are running Malcat under Windows, be sure to check `Use system`\n```\npython interpreter in the options).\n\n### Patching lognp\n\n```\nBefore emulating anything, we need to solve a problem: the data to decrypt\n( d54hdan9c9ebsx ) is not embedded in the `lognp shellcode, it is read from the filesystem`\nusing `CreateFileA . So emulation is likely to fail. How are we going to solve this issue?`\n\nThere is the clean way: we could hook the CreateFileA/ReadFile APIs in speakeasy and\nintercept the call to give back the content of the file `d54hdan9c9ebsx .`\n\n\n-----\n\nBut there is also the dirty way: we could patch the decrypted `lognp shellcode in order to`\nembed the content of `d54hdan9c9ebsx in the shellcode space and patch the shellcode`\nentry point to perform a call to the decryption function with the right parameters. Of course\nwe will chose the dirty way. It is not only way faster, it is also more fun.\n\nHere is how to proceed:\n\n1. First open a copy of the decrypted `lognp shellcode in Malcat with extra space at the`\n\nend of the file (File > Open Copy of File). The file `d54hdan9c9ebsx is 216843 bytes`\nbig, we'll append 300KB just to be sure.\n2. Copy the content of the file `d54hdan9c9ebsx in the clipboard: in a second Malcat`\n\ninstance, open `d54hdan9c9ebsx and then hit Ctrl+A followed by Ctrl+C`\n3. Paste the copied data after the shellcode in the first Malcat instance, let's say at\n\naddress `0x2000 to make it easy to remember`\n4. Enter disassembly view (F3) and go to the shellcode's entry point at address 0\n\nMalcat does not (yet) support assembling your own instruction, so we will need to manually\nedit the machine code. Click on any hexa byte in disasm mode and enter edit mode (Insert\nkey). We need to assemble the following code:\n\n1. Push the second parameter which is the size of the buffer to decrypt (216843 =\n\n0x34F0B). `push uint32 is assembled using` `0x68 +` `LSB-encoded uint32 in x86:`\n```\n   68 0B 4F 03 00\n\n```\n2. Push the first parameter which is the address of the buffer to decrypt ( 0x2000 ): `68`\n```\n   00 20 00 00\n\n```\n3. Call to the decryption function. The call opcode is `0xE8 + signed displacement`\n\nstarting from the end of the call opcode. The end of our call opcode is at address\n```\n   0x000F, we want to jump to 0x0A01, so 0x0A01 - 0x000F = 0x09f2 . We need\n\n```\nto assemble `E8 F2 09 00 00 .`\n\nYou can use Malcat's calculator to perform quick computation while analysing a binary,\njust hit Ctrl+Space. Internally, it uses the python interpreter, so use python syntax.\n\nAt the end, the patched shellcode should look like in the picture below. For the lazy readers,\nyou can download the patched `lognp file` [here (password: infected).](https://malcat.fr/blog/reversing-a-nsis-dropper-using-quick-and-dirty-shellcode-emulation/shellcode.patched.zip)\n\n\n-----\n\nFigure 8: patching the shellcode\n\n### Running speakeasy\n\nNow the only thing we have to do is to let speakeasy do its magic:\n\nlet us define the entry point: right-click at address 0 and chose Force function start in\nthe context menu\nrun the script `speakeasy_shellcode.py (Ctrl+U to run user scripts)`\n\n... and voila, Malcat should open the result in a new file. A PE file has been detected by\nMalcat's file format parser at address 0x2000, perfect! Just double-click the PE file under\n\"Carved Files\" to open it.\n\n\n-----\n\nFigure 9: decrypted d54hdan9c9ebsx\n\n## Stage 3: Lokibot and config extraction\n\nThe last (and final) stage we get is a PE file of sha\n\n`02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151` [(VT).](https://www.virustotal.com/gui/file/02dee91a81652e5234414e452622307fd61e7988e82bec43665f699f805c3151)\nJudging by the low entropy and the visible strings, the file does not seem to be obfuscated,\ngood news. So which kind of malware do we face? Malcat's Yara rules already spotted one\nof main malware intent: stealing credentials, as we can see in the screenshot below:\n\nFigure 10: file summary, displaying matching Yara rules\nIf we want to be more precise, we can use Malcat's online intelligence view (Ctrl+I, only for\npaid versions). Normally I would avoid using Virustotal to identify a malware family (because\nof packer reuse among threat actors). But here we are dealing with the plain text final\n\n\n-----\n\nmalware, so we should get at least some valid labels. In our case, it seems to be Lokibot, a\nsimple password stealer:\n\nFigure 11: querying online intelligence\nCan we go further? The last section of the PE file is weirdly named `\".x\" . It contains a`\nsingle method at address `0x4a0000 and a few bytes of referenced data at address`\n```\n0x4a0074 . Looking at the function, it seems to decode the data using a XOR opcode, with\n\n```\nthe key `0xDDDDFFFF . But actually, only the first byte of the key is used ( 0xFF ), so it is`\nstrictly equivalent to performing a simple `NOT on the data. Great, let us decrypt these few`\nbytes using Malcat's transform:\n\n\n-----\n\nFigure 12: decrypting the data buffer in the .x section\nGreat, we got the address of the command and control server for this sample. This was a\npretty easy catch ^^\n\n## Conclusion\n\nNSIS installers have been abused by malware authors for some years now. While the NSIS\nVM instruction set is relatively limited, DLL plugins allow malicious actors to extend installer\ncapabilities and obfuscate malware. In this example, two layers of shellcodes were used by\nthe NSIS installer in order to deliver its final payload: a LokiBot password stealer.\n\nInstead of running everything in a VM, we made great use of Malcat's NSIS disassembler,\nMalcat's transforms and speakeasy emulator in order to quickly unpack these two layers\nstatically.\n\nWe hope you enjoyed this new quick-and-dirty malware unpacking sessions. Future blog\nposts will be more focused toward beginners as we will introduce a few of Malcat's features\nas in-depth tutorials.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-17 - Reversing a NSIS dropper using quick and dirty shellcode emulation.pdf"
    ],
    "report_names": [
        "2022-04-17 - Reversing a NSIS dropper using quick and dirty shellcode emulation.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535578,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653780300,
    "ts_modification_date": 1653780300,
    "files": {
        "pdf": "https://archive.orkl.eu/7e713df8bec4b9b14227665a5b2f985e95b2b2dd.pdf",
        "text": "https://archive.orkl.eu/7e713df8bec4b9b14227665a5b2f985e95b2b2dd.txt",
        "img": "https://archive.orkl.eu/7e713df8bec4b9b14227665a5b2f985e95b2b2dd.jpg"
    }
}