{
    "id": "48e4c582-6b54-434f-82b2-a334b644b372",
    "created_at": "2024-06-25T02:05:45.240923Z",
    "updated_at": "2025-03-27T02:16:46.985616Z",
    "deleted_at": null,
    "sha1_hash": "031ff6dbad37e99f26db63994ad93a2dd2df5eb3",
    "title": "",
    "authors": "",
    "file_creation_date": "2024-06-08T16:30:48Z",
    "file_modification_date": "2024-06-08T16:30:48Z",
    "file_size": 737337,
    "plain_text": "# La rétro-ingénierie de code malveillant dans la CTI - Analyse de l’évolution d’une chaîne d’infection\n\nCharles Meslay\ncharles.meslay@sekoia.io\n\nSekoia.io\n\n**Résumé. Cet article a pour but de présenter le rôle de la rétro-ingénierie**\ndes codes malveillants dans le domaine du renseignement sur la menace\ncyber ou Cyber Threat Intelligence (CTI). Après un bref rappel de ce\nqu’est que la CTI, nous partirons d’un cas réel d’investigation autour de\nla chaîne d’infection du code FlowCloud lié à un mode opératoire adverse\nnommé « TA410 ». Cet article présentera les mécanismes de protection de\nce code : mécanismes anti-analyse et chiffrement des différentes étapes de\nla chaîne d’infection. Les résultats de ces travaux seront ensuite utilisés\nafin de créer une nouvelle règle de détection YARA qui permettra de\ntrouver un nouveau variant disposant de zéro de détection sur VirusTotal.\n\n## 1 Introduction\n\n**1.1** **Qu’est-ce que la CTI ?**\n\nLa Cyber Threat Intelligence (CTI) ou renseignement sur la menace\ncyber correspond à l’étude des groupes d’attaquants informatique. Ce\ndomaine de recherche, multidisciplinaire, a pour but d’étudier les modes\nopératoires adverses (MOA) dans le but de les détecter au plus tôt pour\nse protéger de ceux-ci. La CTI s’articule autour de plusieurs domaines\nd’expertise. Pour faciliter la compréhension, nous nous limitons ici à\nuniquement trois d’entre eux.\nLe premier n’est pas technique, mais lié à la connaissance stratégique.\nLe but de ce domaine est d’étudier le contexte dans lequel sont effectuées\nles attaques, qu’il s’agisse de campagnes étatiques ou cybercriminelles.\nL’analyse des enjeux politiques entre pays peut ainsi permettre d’expliquer\ncertaines attaques et donc d’anticiper de futures opérations adverses. Cette\ncompétence intègre aussi une connaissance de l’organisation des groupes\nd’attaquants. Cela peut aussi bien correspondre à l’étude de l’organisation\nde groupes cybercriminels que l’organisation cyber d’un Etat.\nUn deuxième domaine lié à la CTI est l’étude des groupes d’attaquants\nvia le suivi de leur infrastructure. Comme présenté lors de l’édition 2023\n\n\n-----\n\n2 La rétro-ingénierie de code malveillant dans la CTI\n\ndu SSTIC par Charles Hourtoule et Simon Msika [2], un MOA comme\nMustang Panda, réputé d’origine chinoise, peut être suivi via des spécificités dans la configuration de leurs serveurs : l’identification d’un motif dans\nle certificat d’un serveur permet d’illuminer une partie de l’infrastructure\nde l’attaquant. Ainsi, un suivi continu de cette infrastructure permettra\nde détecter une compromission non pas via les traces laissées sur un poste\nmais via les connexions réseaux.\n\nEnfin, un dernier domaine est l’analyse des codes malveillants utilisés\npar un MOA. Bien que les objectifs soient multiples, cette analyse permet\nde documenter de façon précise les codes utilisés afin :\n\n— d’en extraire des indicateurs de compromissions ;\n— d’identifier des moyens de remédiations ;\n— de rapprocher des menaces entre elles et ainsi de suivre une menace\ndans le temps.\n\nCet article a pour but d’explorer ce dernier domaine. Nous tenterons\nd’expliquer comment l’analyse de code via la rétro-ingénierie permet de\nsuivre l’évolution de codes malveillants via l’exemple du code FlowCloud\nassocié au mode opératoire TA410.\n\n**1.2** **Présentation du MOA TA410 et de la chaîne d’infection**\n**de FlowCloud**\n\nTA410 est un MOA supposé d’origine chinoise actif depuis au moins\n2019. Ce MOA a été pour la première fois documenté en 2020 par ProofPoint à l’occasion d’une campagne d’attaque contre des fournisseurs d’énergie aux États Unis [4]. La description de cette campagne par Proofpoint\nfait état d’un implant nommé FlowCloud, qui donne un accès complet au\nsystème compromis.\n\nEn avril 2022, les chercheurs d’ESET, ont décrit de façon détaillée\nla chaîne d’infection et les fonctionnalités de FlowCloud [1]. La chaîne\nd’infection est assez complexe mais est typique des chaines d’infection\nhabituellement rencontrées. Sans rentrer dans l’ensemble de la chaîne\nd’infection, nous pouvons retenir que celle-ci commence par la création\nd’un service qui exécutera une application vulnérable à du « DLL-sideloading » afin de charger une DLL malveillante. Cette DDL, nommée\nXXXModule_dlcore0 charge une autre DLL qui elle-même déchiffre et\nexécute un autre code qui chargera FlowCloud.\n\n\n-----\n\nC. Meslay 3\n\n**1.3** **YARA, un outil de signature de code**\n\nDans les annexes de l’article de blog, ESET fournit des hashs de fichiers\nqu’il est possible de récupérer sur VirusTotal ainsi que plusieurs « règles\nYARA » dont une sur les techniques anti-analyses de FlowCloud. YARA\nest un outil permettant d’effectuer des recherches dans des fichiers à partir\nde règles dans lesquelles des recherches sur des motifs spécifiques sont\ndéfinis (qu’il s’agisse de chaînes de caractères ou directement basés sur\nune suite d’octets). Des règles YARAs sont ainsi utilisées afin de « signer »\ndes codes (ou des sous-parties de codes).\nUn des objectifs du travail de rétro-ingénierie est d’identifier des motifs\nspécifiques aux maliciels afin de pouvoir les détecter et les classer.\nC’est ce qui est fait ici par ESET en fournissant à la communauté une\nrègle YARA qui signe les mécanismes anti-analyse utilisés dans FlowCloud\n(figure 1).\n\n**Fig. 1. Règle YARA fournie par ESET Research**\n\n\n-----\n\n4 La rétro-ingénierie de code malveillant dans la CTI\n\nUne règle YARA est généralement divisée en trois sections :\n— la section condition est une expression booléenne qui définit la\nlogique de la règle en utilisant les variables définies dans la section\nstrings ;\n— la section strings permet de définir des variables utilisables dans\nla section condition ;\n— la section meta permet de définir des metadonnées.\nCette règle vérifie la présence de deux choses :\n— uint16(0) == 0x5a4d : qui correspond à la présence des octets\n0x4d 0x5a au début du fichier. Il s’agit ici de vérifier la présence\nde l’en-tête MZ spécifique aux fichiers PE sous Windows.\n— la présence de la valeur $chunk_1 (via les mots clés\n« all of them »). Cette variable contient une suite d’octets correspondant à une séquence particulière de code assembleur. L’auteur\nde cette règle a précisé le sens de ces octets en commentaire.\nL’intérêt de créer des règles YARA est multiple. Tout d’abord, d’un\npoint de vue détection, l’objectif est de pouvoir analyser les fichiers d’un\nsystème au regard de ses règles afin d’identifier des codes malveillants.\nCela peut par exemple être utilisé par des EDR (« Endpoint Detection\nResponse » ou des antivirus). Un autre intérêt est de pouvoir suivre dans le\ntemps l’évolution des codes malveillants ou tenter de trouver de nouveaux\nvariants en soumettant ces règles à des bases de données de fichiers.\nIl est important de noter que la création d’une règle YARA nécessite\ntoujours d’effectuer un compromis entre :\n— définir des critères suffisamment précis pour être sûr qu’une règle\nest spécifique à un code particulier, c’est à dire réduire au maximum\nle nombre de faux positifs.\n— être suffisamment générique afin de détecter, si possible, tous les\ncodes de cette famille, c’est à dire réduire au maximum le nombre\nde faux négatifs.\nDans la suite de cet article nous montrerons la démarche que nous\navons adopté afin d’analyser des variants du chargeur de FlowCloud ainsi\nque la création d’une règle YARA pertinente.\n\n## 2 Suivi de la menace dans le temps via le chargeur de FlowCloud\n\nL’article d’ESET contient des Indicateurs de Compromissions (« In_dicator Of Compromises » ou « IoC »). Parmis ces IoCs, des hashs de_\n\n\n-----\n\nC. Meslay 5\n\nfichiers sont présents. L’un d’eux étant disponible sur VirusTotal,[1] nous\ndécidons de débuter notre investiguation par l’analyse de ce fichier.\nDans ce chapitre, nous présenterons les principales étapes de la rétroingénierie de ce code ainsi que d’autres variants connus dans le but de\ncomprendre les spécificités de ces codes. Nous pourrons ensuite en extraire\ndes motifs spécifiques pour créer notre propre règle YARA. Celle-ci sera\nenfin utilisée pour tenter identifier de nouveaux variants.\n\n**2.1** **Analyse du fichier initial**\n\nAprès avoir récupéré le fichier sur VirusTotal, nous pouvons procéder\nà son analyse. Lors de l’ouverture du logiciel malveillant à l’intérieur d’un\noutil tel que IDA Pro, on constate qu’il échoue à l’analyse. En effet, de\nnombreuses portions de code sont considérés par IDA Pro comme des\ndonnées brutes (IDA Pro n’a pas réussi à désassembler ces octets, en gris\nsur la figure 2) ou comme des instructions en dehors d’une fonction (IDA\nPro n’a pas été capable de reconstruire la fonction associée, en rouge sur\nla figure 2).\n\n**Fig. 2. Vue schématisée du résultat de la décompilation du maliciel par IDA Pro**\n\nComme nous allons le voir, l’analyse dans IDA Pro a échoué à cause\nd’une technique d’obfuscation utilisée dans ce code. Cette technique antianalyse correspond à la portion de code signée par la règle YARA de la\nfigure 1. Plus précisément la technique d’obfuscation utilisée est visible\ndans la figure 3.\nPour comprendre ce qu’il se passe ici, prenons le temps de comprendre\ncomment fonctionne IDA Pro. Le désassembleur d’IDA Pro traite tous\nles octets les uns à la suite des autres. Ainsi, lorsqu’il arrive à l’adresse\n0x100010B7, le désassembleur :\n1. identifie que cette instruction est codée sur deux octets et qu’il\ns’agit d’un saut conditionnel vers l’adresse 0x100010BA ;\n2. désassemble l’instruction suivante, qui commence à l’adresse\n0x100010B9 dont la taille est de deux octets. Cette instruction aura\npour effet d’effectuer un saut vers, elle aussi, l’adresse 0x100010BA.\n\n[1 https://www.virustotal.com/gui/file/c0568d6c0aa6d019454c9613b1a9b0ef](https://www.virustotal.com/gui/file/c0568d6c0aa6d019454c9613b1a9b0ef)\n\n\n-----\n\n6 La rétro-ingénierie de code malveillant dans la CTI\n\n**Fig. 3. Exemple du premier motif utilisé pour mettre en défaut IDA Pro**\n\nIci, nous voyons que le désassembleur, qui réalise une analyse séquentielle des octets, est mis en défaut puisque la prochaine instruction\nexécutée est à l’adresse 0x100010BA qui est au milieu d’une instruction.\nCette technique est ainsi appelée, « Jump In The Middle ».\n\nÀ partir de cette adresse, nous pouvons considérer le désassembleur\ncomme « désynchronisé » par rapport au flux d’exécution réel du programme : les instructions suivantes ne correspondent alors plus aux instructions réellement exécutées par le programme.\n\nDans ce cas, le travail du rétro-analyste est d’aider le désassembleur à\ngérer cette situation. Pour cela, une solution est de supprimer l’instruction\nà l’adresse 0x100010B9 et d’en créer une nouvelle à l’adresse 0x100010BA.\nCela permet de voir que cette nouvelle instruction est un saut inconditionnel, « jump eax » où la valeur de eax dépend du retour de la fonction\nsub_10001d30.\n\n**Fig. 4. Première passe de modifications pour corriger l’analyse effectuée par IDA**\nPro\n\n\n-----\n\nC. Meslay 7\n\nNous ne rentrerons pas dans le détail de la fonction sub_10001D30,\nmais celle-ci est utilisée pour vérifier que la DLL ne s’exécute pas dans\nune sandbox. L’exécution dans un débogeur permet de voir que la valeur\nde retour, eax vaut :\n— 1 si le code détecte un environnement d’analyse. Dans ce cas, le\njmp eax effectue un saut vers l’adresse 0x11, ce qui génère une\nerreur.\n— L’adresse de retour de la fonction sub_10001D30, c’est à dire\n0x100010AF dans le cas présent. Le jmp eax effectuera donc un\nsaut vers l’adresse 0x100010AF+0x10=0x100010BF.\nNous pouvons alors simplifier le code en remplaçant certains octets\npar la valeur 0x90 qui correspond à l’instruction « no operation » :\n— les octets qui correspondent aux instructions de saut (« jge » ansi\nque le premier octet du « jmp ») ;\n— les trois octets à partir de l’adresse 0x100010BC car ces octets ne\nsont jamais « exécutés ».\nEn résultat, nous obtenons la figure 5 qui est une version simplifiée\nmais équivalente à ce qui est réellement exécuté.\n\n**Fig. 5. Seconde passe de modifications pour corriger l’analyse effectuée par IDA**\nPro\n\nNotons que la fonction sub_10001D50 est une autre anti-debug. Si le\nrésultat est 1, le processus se termine.\nDans cet exemple, nous avons manuellement aidé IDA Pro, mais ce\nmotif (ainsi que les fonctions anti-debug) est répété de multiples fois (32\nfois dans cet exécutable). Il est alors nécessaire d’automatiser le processus\nde suppression de ces motifs et des appels aux fonctions anti-debug. Dans\nce cas précis, il est possible de remplacer l’ensemble des octets de la\n\n\n-----\n\n8 La rétro-ingénierie de code malveillant dans la CTI\n\nfigure 5 par des octets « no operation ». En effet, le rôle de ces octets est\nuniquement lié à de la détection d’environnement d’analyse.\nEn se basant sur l’exemple de plugin IDA Pro de Rolf Rolles,[2] il suffit\nalors de modifier la fonction ev_ana_insn comme le montre la figure 6.\n\n**Fig. 6. Adaptation de la fonction ev_ana_insn**\n\nCe script est assez simple : il vérifie que l’octet courant est le début\nd’un bloc à supprimer. Si c’est le cas, nous remplaçons ce bloc par 37\ninstructions « no operation » (0x25 dans la figure 6). IDA Pro est alors\nen capacité de reconstruire la fonction et de produire un code décompilé\nautomatiquement. Après quelques renommages de variables et fonctions,\nretypages triviaux et l’ajout de quelques commentaires, on obtient le code\nC présenté dans la figure 7.\nIl est ainsi assez aisé d’identifier les principales étapes de cette fonction :\n\n1. récupération du chemin actuel de l’exécutable ;\n\n2. ouverture et lecture du fichier setlangloc.dat. Le contenu est\ncopié dans une zone mémoire nouvellement allouée ;\n\n3. création d’un patch pour modifier certaines instructions dans ce\nprocessus afin d’appeler le code à l’intérieur de setlangloc.dat ;\n\n4. application ce patch.\n\nLa figure 8 présente les données du patch dans le segment rdata.\nUne première piste identifiée pour créer une nouvelle règle YARA est\nd’utiliser les données du patch. Ces octets pourront être utilisés pour créer\nun nouveau motif de détection dans la notre règle YARA.\n\n[2 https://github.com/RolfRolles/FinSpyVM/blob/master/FinSpyDeob.py](https://github.com/RolfRolles/FinSpyVM/blob/master/FinSpyDeob.py)\n\n\n-----\n\nC. Meslay 9\n\n**Fig. 7. Résultat final suite à l’automatisation de la désobfuscation**\n\n**Fig. 8. Octets du patch dans le segment rdata**\n\n**2.2** **Analyse de variants**\n\nÀ partir de la règle YARA sur le motif anti-analyse, deux autres\nfichiers sont trouvés sur VirusTotal que nous nommerons « Variant A » [3]\n\net « Variant B ».[4]\n\nCes fichiers sont connus comme étant également liés à FlowCloud.\nDans le but d’améliorer notre signature, nous allons analyser ces fichiers\nafin d’identifier leur caractéristiques et spécificités.\n\n**Variant A. Ce variant présente de nombreuses similarités avec le chargeur**\ninitial de FlowCloud. Néanmoins, lors de son chargement dans IDA Pro,\n\n[3 https://www.virustotal.com/gui/file/1e3baba3b7261eb9441fce16a1310532](https://www.virustotal.com/gui/file/1e3baba3b7261eb9441fce16a1310532)\n[4 https://www.virustotal.com/gui/file/1c1ad9fd655ee80447f7bb38a570313b](https://www.virustotal.com/gui/file/1c1ad9fd655ee80447f7bb38a570313b)\n\n\n-----\n\n10 La rétro-ingénierie de code malveillant dans la CTI\n\net malgré le script précédemment créé, le désassemblage échoue. Nous\nobservons rapidement qu’un autre motif anti-analyse est présent, comme\nle montre la figure 9.\n\n**Fig. 9. Première nouvelle technique anti-analyse**\n\nCette technique consiste à sauvegarder la une valeur de eax sur la pile,\nmettre eax à zéro puis restaurer la valeur de eax. La mise à zéro de eax\na pour effet que le saut conditionnel « jz » est pris. Le flux d’exécution\nsaute alors au milieu du « call » suivant.\n\n**Fig. 10. Désobfuscation de la nouvelle technique anti-analyse**\n\nLa figure 10 présente le résultat après une correction manuelle de cette\nobfuscation. Nous remarquons qu’elle est immédiatement suivie du motif\nanti-analyse présenté précédemment. Nous pouvons donc mettre à jour\nnotre script de désobfuscation afin de prendre en compte cette nouvelle\ntechnique.\n\n\n-----\n\nC. Meslay 11\n\nNotons, qu’une autre technique d’obfsucation est présente. Celle-ci\nn’empêche pas l’analyse par IDA Pro, mais a pour effet de rajouter\ndes variables au code obtenu après décompilation. Cette technique est\nprésentée dans la figure 11.\n\n**Fig. 11. Deuxième nouvelle technique d’obfuscation**\n\nAprès avoir traité cette technique de la même façon que les précédentes\n(en remplaçant toutes ces instructions par des « no operation » dans\nnotre plugin), nous pouvons recharger ce fichier dans IDA Pro. Nous\nobservons que le désassemblage est correctement effectué comme le montre\nla figure 12.\n\n**Fig. 12. Résultat de la décompilation du premier variant**\n\n\n-----\n\n12 La rétro-ingénierie de code malveillant dans la CTI\n\nComme précédemment, cette figure n’a fait l’objet que de quelques\nrenommages et ajouts de commentaires. Nous pouvons assez rapidement\nobserver que ce code est similaire au code obtenu dans la figure 7.\n\nNéanmoins, bien que de nombreuses similarités existent, nous observons\ntrois différences avec le fichier initial :\n\n— la première correspond au nom de fichier utilisé pour l’étape\nsuivante. Auparavant, celui-ci était récupéré via plusieurs appels de fonctions (GetModuleFileNameW, PathRemoveFileSpecW\net PathAppendW). Maintenant, ce nom de fichier est déchiffré dans\nune fonction dédiée.\n— La seconde différence correspond au chargement du contenu de\nl’étape suivante. Dans le premier fichier, un simple memcpy était\nutilisé pour copier le contenu du fichier. Dans ce nouveau variant,\nune fonction est appelée afin de déchiffrer l’étape suivante : Cette\nseconde fonction de déchiffrement prend en paramètre une graine\nutilisée pour le calcul de la clé de déchiffrement. Comme la valeur\n0xd3 est passée en paramètre de cette fonction, la valeur de la\nclé est alors 0x7b. La figure 13 présente cette fonction chargée de\ndériver la clé est d’appliquer le déchiffrement.\n\n**Fig. 13. Fonction dérivant la clé et déchiffrant l’étape suivante**\n\n— Enfin, une troisième différence correspond à l’application du patch.\nIci, l’application du patch est déportée dans une autre fonction. La\n\n\n-----\n\nC. Meslay 13\n\nfigure 14 présente cette fonction. Celle-ci correspond à ce qui était\neffectué précédemment.\n\n**Fig. 14. Fonction qui applique le patch**\n\n**Variant B. Le deuxième variant est très proche du premier variant. Il**\ndispose par exemple des mêmes fonctions de chiffrement et du même mécanisme de dérivation de clé. Cela nous indique qu’il peut être intéressant\nde signer aussi ces mécanismes pour les inclure dans une règle YARA.\nUn fait de comparaison intéressant entre ces trois versions est le nombre\nd’occurences des motifs d’obfuscation. Les résultats sont présentés dans le\ntableau 1\n\nFichier motif ESET motif obfuscation 1 motif obfuscation 2\nFichier initial 48 0 0\nVariant A 69 136 136\nVariant B 1 64 128\n\n**Tableau 1. Nombre d’occurences des motifs dans chaque fichier**\n\nCes résultats montrent que le dernier variant ne dispose que d’une\nseule occurence du motif initial signé par la règle YARA d’ESET. Une\nhypothèse est que cette obfuscation a vocation à disparaitre dans les\nprochaines versions. Cela peut donc inciter à réaliser une nouvelle règle\nYARA dont la présence de ce motif est optionnelle.\n\n|Fichier|motif ESET|motif obfuscation 1|motif obfuscation 2|\n|---|---|---|---|\n|Fichier initial|48|0|0|\n|Variant A|69|136|136|\n|Variant B|1|64|128|\n\n\n-----\n\n14 La rétro-ingénierie de code malveillant dans la CTI\n\n**2.3** **Création de nouvelles signatures**\n\nÀ ce stade, nous disposons d’une règle YARA qui se base uniquement\nsur un motif anti-analyse. Or, comme nous avons pu le voir, toutes ces\nvariantes disposent de plusieurs similarités (fonctions cryptographiques)\nmais aussi de deux nouvelles techniques anti-analyse.\nNous pouvons donc tenter de créer une nouvelle règle YARA basée sur\nde nouvelles heuristiques :\n— les mécanismes de déchiffrement (du nom du fichier et du contenu\nde celui-ci)\n— le mécanisme de dérivation de la clé pour le déchiffrement du\ncontenu du fichier\n— les deux nouveaux motifs anti-analyse\n— les octets du patch appliqué\nSigner des algorithmes cryptographique peut être intéressant si l’implémantation est spécifique au code étudié. Dans le cas présent, le déchiffrement du contenu du fichier correspondant juste à une addition suivant\nd’un xor ne semble pas opportun. En effet, cela pourrait mener à de\nnombreux faux positifs.\nPar contre, bien que nous n’ayons pas abordé cette partie dans cet\narticle par soucis de clarté, le déchiffrement du nom du fichier semble plus\nspécifique. La figure 15 présente un extrait de cette fonction.\n\n**Fig. 15. Extrait de la fonction de déchiffrement du nom du fichier**\n\nDe cet algorithme nous avons extrait les octets suivants :\n\n\n1 $decryption_function = {8A C8 80 C1 26 32 D1 30 14 38}\n\n\nLe mécanisme de dérivation des clés peut lui être signé par cette\nvariable :\n\n\n1 $derivation_key = {6B 04 00 00 F7 ?? 81 c2 a8 01 00 00}\n\n\nEnfin, nous avons les deux nouveaux motifs anti-analyses ainsi que les\noctets du patch :\n\n\n-----\n\nC. Meslay 15\n\n\n1 $new_pattern_1 = {50 33 c0 58 74 01 e8}\n\n2 $new_pattern_2 = {89 44 24 fc 58 8D 64 24 fc 81 fc 00 10 00 00 77\n_֒→_ 06 81 c4 ?? ?? ?? ?? 8B 44 24 FC}\n\n3 $patch_bytes = {68 78 56 34 12 C3 90 90 90 90 90 00}\n\n\nAu final, notre nouvelle règle YARA est présentée dans la figure 16.\n\n**Fig. 16. Nouvelle règle YARA signant les variants**\n\nIci, notre objectif est de trouver de nouveaux fichiers. Nous décidons\ndonc de faire en sorte que cette règle soit assez laxiste. C’est pourquoi\nnous décidons d’utiliser la directive « 2 of them » et non « all of them »\nafin que cette règle vérifie les fichiers ne disposant que deux de ces cinq\nmotifs.\n\nLa création d’une règle YARA n’est pas une fin en soi. En effet, ces\nrègles doivent être capitalisées afin qu’elles soient confrontés aux nouveaux\nfichiers soumis à détection. De plus, il est généralement conseillé de\nconfronter ces règles à des bases de données de fichiers existantes. Cette\ndernière fonctionnalité est souvent appelée « RetroHunt »\n\n\n-----\n\n16 La rétro-ingénierie de code malveillant dans la CTI\n\n**2.4** **Nouveau variant**\n\nCette nouvelle règle YARA nous a permis de récupérer un nouveau\nfichier sur VirusTotal nommé msedgeupdate.dll,[5] téléversé en septembre\n2023. En novembre 2023, lorsque nous avons réalisé cette investigation, ce\nfichier n’était détecté par aucun antivirus (la dernière analyse effectuée\nsur VirusTotal datant du 15 novembre 2023).\nL’objectif de ce chapitre est donc d’analyser ce fichier pour s’avoir s’il\ns’agit bien d’un nouveau variant ou pas et de s’assurer que notre règle est\nbien pertinente.\n\n**Analyse de msedgeupdate.dll. Tout d’abord, nous pouvons vérifier**\nque ce fichier vérifie quatre des motifs créés :\n— $decryption_function\n— $patch_bytes\n— $new_pattern_1\n— $new_pattern_2\nLe seul motif non présent dans cet implant\nest celui relatif au mécanisme de dérivation de clé\n($derivation_key = {6B 04 00 00 F7 ?? 81 c2 a8 01 00 00}).\nNotons de plus que le motif identifié dans la règle YARA d’ESET n’est\npas présent.\nLe tableau 2 est une mise à jour du tableau 1 prenant en compte ce\nnouveau fichier.\n\nFichier Motif ESET $new_pattern_1 $new_pattern_2\nFichier initial 48 0 0\nVariant A 69 136 136\nVariant B 1 64 128\nNouveau fichier 0 280 280\n\n**Tableau 2. Nombre d’occurences des motifs dans chaque fichier**\n\nNotre plugin de désobfuscation nous permet de facilement supprimer\nles mécanismes anti-analyse et de retrouver très rapidement une fonction\nressemblant à ce que nous avons observé précédemment. Celle-ci est\nprésentée dans la 17.\nContrairement aux précédents variants, nous pouvons voir que le nom\ndu fichier à charger n’est pas chiffré mais est issu du nom du fichier courant.\n\n[5 https://www.virustotal.com/gui/file/c0a29416705997d796b94cdce648348d](https://www.virustotal.com/gui/file/c0a29416705997d796b94cdce648348d)\n\n|Fichier|Motif ESET|$new_pattern_1|$new_pattern_2|\n|---|---|---|---|\n|Fichier initial|48|0|0|\n|Variant A|69|136|136|\n|Variant B|1|64|128|\n|Nouveau fichier|0|280|280|\n\n\n-----\n\nC. Meslay 17\n\n**Fig. 17. Fonction principale du nouveau fichier**\n\nL’extension dll est remplacée par dat. Ainsi, le nom du fichier utilisé\npour l’étape d’après est msedgeupdate.dat. Notons que même si le nom\nde fichier n’est pas chiffré, la fonction de déchiffrement est présente dans\nla DLL. C’est pourquoi les octets de la variable $decryption_function\nsont bien présents.\nLa fonction de déchiffrement du contenu du fichier est un peu différente.\nComme le montre la figure 18, contrairement aux variants précédents, le\nmécanisme de dérivation de clé n’est plus présent. La clé (sur un octet)\nest ainsi codée en dur et vaut 0x7b. Il est intéressant de noter cette\nvaleur correspond au résultat de l’algorithme de dérivation de clé utilisé\nprécédemment. Une hypothèse ici peut être que le compilateur a optimisé\nle code en remplaçant l’algorithme de dérivation de clé par sa valeur finale.\n\n**Fig. 18. Fonction de déchiffrement du nouveau variant**\n\n\n-----\n\n18 La rétro-ingénierie de code malveillant dans la CTI\n\nLa fonction relative au patch partage aussi des caractéristiques identiques avec les précédents fichiers, notamment la même séquence d’octets\n(figure 19).\n\n**Fig. 19. Fonction appliquant le patch au nouveau variant**\n\nÀ ce stade, nous pouvons avoir une confiance élevée sur le fait qu’il\ns’agit bien d’un nouveau variant associé à FlowCloud. Mais essayons d’aller\nplus loin.\n\n**Analyse** **de** **msedgeupdate.dat.** Nous avons vu que le fichier\nmsedgeupdate.dll a pour objet le chargement et le déchiffrement d’un\nfichier nommé msedgeupdate.dat. Par chance, nous pouvons retrouver\nsur VirusTotal un fichier nommé msedgeupdate.dat téléversé en même\ntemps que ce nouveau variant.[6]\n\nUne première ouverture de ce fichier dans un éditeur de texte montre\nque ce fichier semble être un fichier de données inintelligible. Cela est\ncohérent avec notre analyse puisque l’étape précédente commençait par\ndéchiffrer ce fichier. Lorsque nous déchiffrons manuellement ce fichier nous\nobtenons bien un shellcode qui s’autodéchiffre afin d’obtenir une nouvelle\nDLL protégée par VMProtect.\n\n[6 https://www.virustotal.com/gui/file/6d5bcb74a284d119dd32f7b09d37369f](https://www.virustotal.com/gui/file/6d5bcb74a284d119dd32f7b09d37369f)\n\n\n-----\n\nC. Meslay 19\n\nUn élément intéressant ici, est que la fonction de déchiffrement dispose\ndu même mécanisme de dérivation de clé que précédemment. Ainsi, dans ce\nnouveau fichier déchiffré nous retrouvons le seul motif de notre règle YARA\nqui n’était pas présent dans le fichier msedgeupdate.dll. La figure 20\nprésente la fonction de déchiffrement avec l’algorithme de dérivation de la\nclé précédemment utilisé.\n\n**Fig. 20. Fonction de déchiffrement présente dans le fichier msedgeupdate.dat**\ndéchiffré\n\nLa dernière étape est plus compliquée à analyser du fait des protections\nassurées par VMProtect. Néanmoins, nous avons une confiance très élevée\nsur le fait que ce fichier est une nouvelle variante de la chaîne d’infection\nde FlowCloud d’autant plus que :\n— l’utilisation de VMProtect par FlowCloud est déjà documentée [3].\n— le serveur de commande & contrôle (C2) avec lequel communiquait\nl’implant disposait de similarités avec d’anciens C2 connus de\nFlowCloud.\n\n## 3 Conclusion\n\nEn conclusion, cet article avait pour but de présenter la CTI sous\nl’angle de la création de règles YARA via la rétro-ingénierie de logiciel\nmalveillant. Bien que la création de règles YARA n’est pas l’unique but du\ntravail d’un analyste CTI, il n’en reste pas moins un élément de base dans\nle suivi des MOA permettant le suivi de leurs codes et de leur évolution\ndans le temps. L’exemple pris avait pour but de proposer une approche\npas à pas de l’étude d’un code et de la création d’une règle YARA. Enfin,\nnous espérons avoir intéressé le lecteur via l’analyse d’exemples réels d’une\nfamille de codes malveillants.\n\n\n-----\n\n20 La rétro-ingénierie de code malveillant dans la CTI\n\n## Références\n\n1. ESET Alexandre Côté Cyr, Matthieu Faou. A lookback under the TA410 umbrella :\n[Its cyberespionage TTPs and activity. 2022. https://www.welivesecurity.com/](https://www.welivesecurity.com/2022/04/27/lookback-ta410-umbrella-cyberespionage-ttps-activity/)\n[2022/04/27/lookback-ta410-umbrella-cyberespionage-ttps-activity/.](https://www.welivesecurity.com/2022/04/27/lookback-ta410-umbrella-cyberespionage-ttps-activity/)\n\n2. Simon Msika Charles Hourtoule. Comment anticiper la menace : l’exemple de\nMustang Panda. SSTIC, 2023.\n\n3. MACNICA Hiroshi Takeuchi. USB flows in the Great River : classic tradecraft is still\nalive. 2023. [https://www.virusbulletin.com/conference/vb2023/abstracts/](https://www.virusbulletin.com/conference/vb2023/abstracts/usb-flows-great-river-classic-tradecraft-still-alive/)\n[usb-flows-great-river-classic-tradecraft-still-alive/.](https://www.virusbulletin.com/conference/vb2023/abstracts/usb-flows-great-river-classic-tradecraft-still-alive/)\n\n4. Michael Raggi and the ProofPoint Threat Insight Team. LookBack Forges\nAhead : Continued Targeting of the United States’ Utilities Sector Reveals\nAdditional Adversary TTPs. 2019. [https://www.proofpoint.com/us/threat-](https://www.proofpoint.com/us/threat-insight/post/lookback-forges-ahead-continued-targeting-united-states-utilities-sector-reveals)\n[insight/post/lookback-forges-ahead-continued-targeting-united-states-](https://www.proofpoint.com/us/threat-insight/post/lookback-forges-ahead-continued-targeting-united-states-utilities-sector-reveals)\n[utilities-sector-reveals.](https://www.proofpoint.com/us/threat-insight/post/lookback-forges-ahead-continued-targeting-united-states-utilities-sector-reveals)\n\n\n-----",
    "language": "FR",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.sstic.org/media/SSTIC2024/SSTIC-actes/la_retro-ingnierie_de_code_malveillant_dans_la_cti/SSTIC2024-Article-la_retro-ingnierie_de_code_malveillant_dans_la_cti_-_analyse_de_levolution_dune_chaine_dinfection-meslay.pdf"
    ],
    "report_names": [
        "SSTIC2024-Article-la_retro-ingnierie_de_code_malveillant_dans_la_cti_-_analyse_de_levolution_dune_chaine_dinfection-meslay.pdf"
    ],
    "threat_actors": [
        {
            "id": "faa4a29b-254a-45bd-b412-9a1cbddbd5e3",
            "created_at": "2022-10-25T16:07:23.80111Z",
            "updated_at": "2025-03-27T02:02:09.985067Z",
            "deleted_at": null,
            "main_name": "LookBack",
            "aliases": [
                "FlowingFrog",
                "LookBack",
                "LookingFrog",
                "TA410",
                "Witchetty"
            ],
            "source_name": "ETDA:LookBack",
            "tools": [
                "FlowCloud",
                "GUP Proxy Tool",
                "SodomMain",
                "SodomMain RAT",
                "SodomNormal"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "9ffcbb0c-7a0f-419f-a174-f18a02ce47f1",
            "created_at": "2023-01-06T13:46:39.059774Z",
            "updated_at": "2025-03-27T02:00:02.98747Z",
            "deleted_at": null,
            "main_name": "TA410",
            "aliases": [],
            "source_name": "MISPGALAXY:TA410",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "1691c25f-1aa4-4168-8ce2-7aa8f23246e7",
            "created_at": "2024-06-04T02:03:07.724221Z",
            "updated_at": "2025-03-27T02:05:17.284601Z",
            "deleted_at": null,
            "main_name": "BRONZE PRESIDENT",
            "aliases": [
                "Mustang Panda ",
                "Red Lich ",
                "Temp.Hex ",
                "HoneyMyte "
            ],
            "source_name": "Secureworks:BRONZE PRESIDENT",
            "tools": [
                " Cobalt Strike",
                " ORat",
                " PlugX",
                " RCSession",
                "China Chopper"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "b69037ec-2605-4de4-bb32-a20d780a8406",
            "created_at": "2023-01-06T13:46:38.790766Z",
            "updated_at": "2025-03-27T02:00:02.919758Z",
            "deleted_at": null,
            "main_name": "MUSTANG PANDA",
            "aliases": [
                "TEMP.HEX",
                "TA416",
                "TANTALUM",
                "Twill Typhoon",
                "Earth Preta",
                "Stately Taurus",
                "LuminousMoth",
                "Polaris",
                "BRONZE PRESIDENT",
                "HoneyMyte",
                "Red Lich"
            ],
            "source_name": "MISPGALAXY:MUSTANG PANDA",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "9baa7519-772a-4862-b412-6f0463691b89",
            "created_at": "2022-10-25T15:50:23.354429Z",
            "updated_at": "2025-03-27T02:00:55.45162Z",
            "deleted_at": null,
            "main_name": "Mustang Panda",
            "aliases": [
                "Mustang Panda",
                "TA416",
                "RedDelta",
                "BRONZE PRESIDENT"
            ],
            "source_name": "MITRE:Mustang Panda",
            "tools": [
                "Cobalt Strike",
                "RCSession",
                "NBTscan",
                "PoisonIvy",
                "PlugX"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "2ee03999-5432-4a65-a850-c543b4fefc3d",
            "created_at": "2022-10-25T16:07:23.882813Z",
            "updated_at": "2025-03-27T02:02:10.0116Z",
            "deleted_at": null,
            "main_name": "Mustang Panda",
            "aliases": [
                "Bronze President",
                "Camaro Dragon",
                "Earth Preta",
                "HoneyMyte",
                "Mustang Panda",
                "Operation SMUGX",
                "Operation SmugX",
                "PKPLUG",
                "Red Lich",
                "Stately Taurus",
                "TEMP.Hex"
            ],
            "source_name": "ETDA:Mustang Panda",
            "tools": [
                "9002 RAT",
                "AdFind",
                "Agent.dhwf",
                "Agentemis",
                "CHINACHOPPER",
                "China Chopper",
                "Chymine",
                "ClaimLoader",
                "Cobalt Strike",
                "CobaltStrike",
                "DCSync",
                "DOPLUGS",
                "Darkmoon",
                "Destroy RAT",
                "DestroyRAT",
                "Farseer",
                "Gen:Trojan.Heur.PT",
                "HOMEUNIX",
                "Hdump",
                "HenBox",
                "HidraQ",
                "Hodur",
                "Homux",
                "HopperTick",
                "Hydraq",
                "Impacket",
                "Kaba",
                "Korplug",
                "LadonGo",
                "MQsTTang",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "NBTscan",
                "NetSess",
                "Netview",
                "Orat",
                "POISONPLUG.SHADOW",
                "PUBLOAD",
                "PVE Find AD Users",
                "PlugX",
                "Poison Ivy",
                "PowerView",
                "QMAGENT",
                "RCSession",
                "RedDelta",
                "Roarur",
                "SPIVY",
                "ShadowPad Winnti",
                "SinoChopper",
                "Sogu",
                "TIGERPLUG",
                "TONEINS",
                "TONESHELL",
                "TVT",
                "TeamViewer",
                "Thoper",
                "TinyNote",
                "WispRider",
                "WmiExec",
                "XShellGhost",
                "Xamtrav",
                "Zupdax",
                "cobeacon",
                "nbtscan",
                "nmap",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1719281145,
    "ts_updated_at": 1743041806,
    "ts_creation_date": 1717864248,
    "ts_modification_date": 1717864248,
    "files": {
        "pdf": "https://archive.orkl.eu/031ff6dbad37e99f26db63994ad93a2dd2df5eb3.pdf",
        "text": "https://archive.orkl.eu/031ff6dbad37e99f26db63994ad93a2dd2df5eb3.txt",
        "img": "https://archive.orkl.eu/031ff6dbad37e99f26db63994ad93a2dd2df5eb3.jpg"
    }
}