{
    "id": "4b3421ba-a02e-4e6a-8b24-cf5fa8854f6c",
    "created_at": "2022-10-25T16:48:22.037488Z",
    "updated_at": "2025-03-27T02:16:39.989238Z",
    "deleted_at": null,
    "sha1_hash": "ffec7ec255fbb2b3cc14d291f50d18d067cc1dc6",
    "title": "Windows Privilege Escalations:  Still abusing Service Accounts to get SYSTEM privileges",
    "authors": "",
    "file_creation_date": "2022-03-25T16:34:46Z",
    "file_modification_date": "2022-03-25T16:34:46Z",
    "file_size": 817433,
    "plain_text": "### Ransomware Encryption Internals: A Behavioral\n Characterization\n\n###### Antonio Cocomazzi Threat Intelligence Researcher, SentinelOne\n\n\n-----\n\n#### whoami\n\n###### ➔ Threat Intelligence Researcher @\n```\n  SentinelOne\n\n ➔ Mainly deal with malware analysis\n  and reverse engineering\n\n ➔ Free time = coding offensive tools\n  + deepin into Windows internals\n\n ➔ Previously presented at BlueHat,\n\n```\n```\n@splinter_code\n@antonioCoco\n\n```\n\n-----\n\n#### Why this research\n\n###### ➔ Data encryption is the core functionality of every Ransomware and it\n```\n   enables their successful operations to extort money from the victims\n\n ➔ Static indicators are acceptable but behavioral indicators are gold\n\n ➔ Extracting Behavioral Indicators means deep knowledge -> lots of study ->\n   very time intensive\n\n ➔ Providing a behavioral characterization should ease this --^\n\n ➔ Identifying behavioral commonalities can provide detection opportunities\n   generic enough to identify all the most advanced Ransomware families,\n   instead of relying of specific detection for specific families\n\n```\n\n-----\n\n#### Agenda\n\n###### ➔ Defining the data encryption scope ➔ Evolution, Trends and Unique features ➔ The behavioral characterization ➔ Behavioral detection based on overlapping\n```\n   implementations\n    ◆ Cross Drive File Enumeration detection\n    ◆ File Footer Writing detection\n    ◆ Encryption Key Randomization detection\n    ◆ Restart Manager API heavy usage detection\n\n ➔ Conclusion\n\n```\n\n-----\n\n## Defining the data encryption scope\n\n\n-----\n\n#### Defining the data encryption scope\n\n###### ➔ Data Encryption characterization requires a dedicated threat\n```\n  model wide enough to cover Ransomware behaviors in a generic way\n\n ➔ Four Macro features:\n   ◆ Files And Directories Enumeration\n   ◆ File Encryption\n   ◆ Encryption Parallelization\n   ◆ Encryption Optimization\n\n ➔ Selected Ransomware:\n   ◆ Babuk\n   ◆ BlackMatter\n   ◆ Conti\n\n```\n\n-----\n\n# Some months later…\n\n\n-----\n\n## Evolution, Trends and Unique\n features\n\n\n-----\n\n#### The shifts in the encryption schemes\n\n###### ➔ Main shift is the adoption of Elliptic-Curve Diffie-Hellman (ECDH) key\n```\n   exchange algorithms instead of RSA as asymmetric encryption -> main\n   difference the private key is never left on the victim host neither in\n   encrypted form\n\n ➔ The evolution of the encryption implementation aims to avoid the usage of\n   the CryptoAPI functionalities offered by the Windows operating system\n\n ➔ Ransomware developers prefer to use open-source libraries or custom\n   implementation for their symmetric and asymmetric encryption operations\n   (e.g. curve25519-donna, HC-128, custom ChaCha20...)\n\n ➔ All l d f ili d th i f ti i d t t th\n\n```\n\n-----\n\n##### The shift from RSA to ECDH in Asymmetric Encryption: RSA\n\n```\nsecret.txt\n\n```\n```\nsecret.txt.encrypted\n\n```\n```\nsecret text\ncontent\n\n```\n```\nGenerate Embed\n      RSA public Key\n\n```\n```\nData Input Symmetric Data Output\n      Encryption\n              Input Key\n       Symmetric Key\n               Random Key\n        Generate\n\n```\n|Random Key|Col2|\n|---|---|\n|||\n\n```\nRansomware.exe\n\n```\n```\nOperator\n\n```\n```\n RSA\nEncrypt\n\n```\n\n-----\n\n##### The shift from RSA to ECDH in Asymmetric Encryption: RSA\n\n```\nsecret.txt\n\n```\n```\nsecret.txt.encrypted\n\n```\n```\nsecret text\ncontent\n\n```\n```\nData Input Data Output\n\n```\n```\nGenerate Embed\n      RSA public Key\n\n```\n```\nRansomware.exe\n\n```\n```\nOperator\n\n```\n```\n RSA\nEncrypt\n\n```\n\n-----\n\n##### The shift from RSA to ECDH in Asymmetric Encryption: RSA\n\n```\nsecret.txt\n\n```\n```\nsecret.txt.encrypted\n\n```\n```\nsecret text\ncontent\n\n```\n```\nData Input Symmetric Data Output\n      Encryption\n              Input Key\n       Symmetric Key\n                   Data Output\n\n```\n```\nGenerate\n\n```\n```\nRSA public Key\n\n```\n```\nOperator\n\n```\n|111001100110 100101010110 101001|Col2|\n|---|---|\n|Encrypted Symmetric Key||\n|t||\n\n```\nOnly this\n\n```\n```\nInput Key Data Input\n       RSA\n      Decrypt\n\n```\n\n-----\n\n##### The shift from RSA to ECDH in Asymmetric Encryption: ECDH\n\n```\nsecret.txt\n\n```\n```\nsecret.txt.encrypted\n  111001100110\n  100101010110\n  101001\n    EC Public Key\n     Ephemeral\nPublic Input\n   Key\n        ECDH\n        Key\n      Agreement\nEC Public\nKey Ephemeral\n   Private\n\n```\n```\nOperator\n\n```\n\n-----\n\n##### The shift from RSA to ECDH in Asymmetric Encryption: ECDH\n\n```\nsecret.txt\n\n```\n```\nsecret.txt.encrypted\n\n```\n```\nsecret text\ncontent\n\n```\n```\nData Input Symmetric Data Output\n      Encryption\n\n```\n```\n                    Input Key\n            Symmetric Key\n                    ECDH\n     Embed\n                   Ephemeral\n                   Key Setup\nEC Public\nKey Master Ransomware.exe\n\n```\n```\n           Key\n          Agreement\n EC Public\nKey Ephemeral\n\n```\n```\nDestroy Key\n\n```\n|EC Ke Agree|DH y ment|\n|---|---|\n\n```\nOperator\n\n```\n\n-----\n\n##### The shift from RSA to ECDH in Asymmetric Encryption: ECDH\n\n```\nsecret.txt\n\n```\n```\nsecret text\ncontent\n\n```\n```\nData Input Data Output\n\n```\n```\nsecret.txt.encrypted\n  111001100110\n  100101010110\n  101001\n    EC Public Key\n     Ephemeral\n        Main Difference:\n       The symmetric key\n       never touches the\n        disk neither in\n        encrypted form\n\n```\n```\nEC Public\nKey Master\n\n```\n```\nECDH\n\n```\n```\nOperator\n\n```\n```\nPrivate Input Key Key\n\n```\n\n-----\n\n#### Automated discovery of internal resources to target\n\n###### ➔ Every Ransomware implementation bundle automated ways to find\n```\n  and seek for relevant resources to encrypt\n\n ➔ The common trend identified is to enumerate all local\n  directories and finding the remote shared resources\n\n ➔ Unique implementations that perform a more in-depth seek:\n   ◆ BlackMatter uses LDAP queries to retrieve all the computer names in the domain\n      and build a list of the remote machines to encrypt files from\n   ◆ Conti retrieves the network addresses of the machines connected to the network\n      through the ARP table stored locally\n\n```\n\n-----\n\n#### Automated discovery of internal resources to target\n\n###### ➔ Blackmatter automated LDAP discovery:\n```\n      ADsOpenObject(“LDAP://rootDSE”, ..., IID_IADs, &IADs_object) ->\n      IADs_object::Get(..., &defaultNamingContext) ->\n      ADsOpenObject(wcscat(“LDAP://CN=Computers,”, defaultNamingContext.bstrVal, ...,\n      &IID_IADsContainer, &pADsContainer) ->\n      ADsBuildEnumerator(pADsContainer, &ppEnumVariant) ->\n      ADsEnumerateNext(ppEnumVariant, …, defaultNamingContext, ...) ->\n      IAD bj t::G t( “dNSH tN ” &d H tN V i t)\n\n```\n\n-----\n\n#### Growing focus in performance improvements\n\n###### ➔ One interesting evolution identified is the adoption of tasks\n```\n  parallelization in the Ransomware payloads -> The main\n  motivation around that is to shorten the time of reaction of the\n  security team behind the compromised organization\n\n ➔ All ransomware implementations analyzed prefer a native\n  multithreading approach over a multiprocessing approach\n\n ➔ The main trends observed for the encryption parallelization is\n  the usage of I/O completion ports\n\n```\n\n-----\n\n#### Growing focus in performance improvements\n\n###### ➔ Some unique performance improvements implementations...\n\n ➔ Babuk uses a unique approach with Semaphores and custom\n```\n  management of the thread pools and shared data structure.\n   ◆ Less overhead than using completion ports\n\n ➔ BlackMatter uses undocumented Windows functions to increase its\n  process class and IO priority\n   ◆ This instructs the kernel to schedule primarily the execution of the threads\n      running in the Ransomware process thus granting a performance improvement\n\n```\n\n-----\n\n#### Automated discovery of internal resources to target\n\n###### ➔ Blackmatter undocumented functions to increase process priority:\n\n\n-----\n\n#### Additional efforts to maximize the encryption damages\n\n###### ➔ Ransomware developers ensure that the disruptive operations\n```\n  carried out by their Encryptor have a higher impact on the\n  targeted systems\n\n ➔ The common trend is to kill a set of processes and services\n  starting from a list of “unwanted” names\n\n ➔ Moreover, for unknown processes that hold lock conditions on\n  files, the Restart Manager API are used to identify all the\n  processes that prevent the successful encryption of files\n  already in use\n\n```\n\n-----\n\n#### Additional efforts to maximize the encryption damages\n\n###### ➔ Another common feature is the usage of functions to erase\n```\n  volume backups (i.e. shadow copies)\n\n ➔ The methods observed:\n   ◆ Vssadmin.exe (delete shadows, resize shadowstorage)\n     Utility to delete or resize the shadow copies\n   ◆ Using COM (IWbemLocator, IWbemContext, IWbemServices)\n     Out-of-process COM objects to interact with the VSS providers through\n     WMI services\n\n```\n\n-----\n\n#### Automated discovery of internal resources to target\n\n###### ➔ Babuk implementation for killing file lock holders:\n\n\n-----\n\n## The behavioral characterization\n\n\n-----\n\n#### The behavioral characterization\n```\n            Feature Feature\n\n###### ➔ Files And Directories Enumeration ➔ File Encryption\n\n```\n```\n◆ Mount hidden volumes\n◆ Local Drive Enumeration\n◆ Remote Drive Enumeration\n◆ File Enumeration\n\n```\n```\nSub-features\n\n```\n```\n◆ Asymmetric Encryption\n◆ Symmetric Encryption\n◆ Key Randomization\n◆ Encrypted Block Writing\n◆ File Footer Writing\n\n```\n```\n          Feature\n                                 Feature\n\n###### ➔ Encryption Optimization ➔ Encryption Parallelization\n\n```\n```\n◆ Kill unwanted Services\n◆ Kill unwanted Processes\n◆ Shadow Copies Deletion\n◆ Kill file lock holders\n\n```\n```\nSub-features\n\n```\n```\n◆ Multi threading\n◆ Synchronization\n\n```\n\n-----\n\n#### The behavioral characterization\n\n###### ➔ The various Ransomware families analyzed implements the sub```\n  features in various ways\n\n ➔ By collecting all the details about the implementations it’s\n  possible to map the implementations of each sub-features to the\n  corresponding family\n\n ➔ The mapping has been based on the NT/Win32 API usage of the\n  implementations\n\n ➔ The goal of this mapping is to provide a way to recognize\n  overlapping implementations across families and ease the\n  development of effective detection to identify Ransomware\n  behaviors commonalities\n\n```\n\n-----\n\n#### The behavioral characterization\n\n###### ➔ Results for “Files And Directories Enumeration”:\n\n\n-----\n\n#### The behavioral characterization\n\n###### ➔ Results for “Files Encryption”:\n\n\n-----\n\n#### The behavioral characterization\n\n###### ➔ Results for “Encryption Optimization”:\n\n\n-----\n\n#### The behavioral characterization\n\n###### ➔ Results for “Encryption Parallelization”:\n\n\n-----\n\n## Behavioral detection based on\n overlapping implementations\n\n\n-----\n\n#### Behavioral detection based on overlapping implementations\n\n###### ➔ Overlapping sub-features implementations:\n\n\n-----\n\n#### Cross Drive File Enumeration detection\n\n###### ➔ Every Ransomware analyzed performs the sub-feature “File Enumeration” with\n```\n   the same implementation:\n   ◆ FindFirstFileEx(“[DRIVE]:\\[PATH]\\*”, ...)\n   ◆ FindNextFile()\n\n ➔ The usage of the Win32 Api function FindFirstFileEx() combined with the\n   wildcard ‘*’ char appended at the end of each path found on the system\n   does generate a specific IRP at the kernel level:\n\n```\n\n-----\n\n#### Cross Drive File Enumeration detection\n\n###### ➔ A potential problem with this approach is that it could be prone\n```\n  to a high false positive rate\n\n ➔ Here is where it comes into play the concept of the “Cross\n  Drive” file enumeration.\n   ◆ Every Ransomware performs a series of operations to identify all the hidden, local and\n       remote drives on the system prior to the file enumeration operation\n\n ➔ The IRP_MJ_DIRECTORY_CONTROL IRP is dispatched to multiple\n  logical drives. This makes the operation quite unique and\n  abnormal for usual benign applications\n\n```\n\n-----\n\n#### Cross Drive File Enumeration detection\n\n\n-----\n\n#### File Footer Writing detection\n\n###### ➔ Every Ransomware analyzed performs the sub-feature “File Footer Writing”\n```\n   with the same implementation:\n   ◆ SetFilePointerEx(hFile, …, FILE_END)\n   ◆ WriteFile(hFile, fileFooterStruct, sizeof(fileFooterStruct), …)\n\n ➔ The combination of these Win32 Api functions generate a specific IRP with\n   specific characteristics at the kernel level:\n\n```\n\n-----\n\n#### File Footer Writing detection\n\n###### ➔ In a pre operation callback IRM_MJ_WRITE, if the parameter\n```\n  IrpSp->Parameters.Write.ByteOffset is equal to the actual\n  size of the file in which the write is happening\n   ◆ It means that’s an append operation\n   ◆ Then the value IrpSp->Parameters.Write.Length should be stored for\n      further validation\n   ◆ This value represents the actual size of the struct used by the\n      ransomware to append the footer information needed for the decryption\n\n ➔ Unfortunately, the file footer struct size differs between\n  Ransomware implementations\n   ◆ We can aggregate the number of append operations that have the same\n      recurring length\n   ◆ This characterizes the behavior of a Ransomware trying to write its own\n\n```\n\n-----\n\n#### File Footer Writing detection\n\n###### ➔ Babuk example of “File Footer Writing” implementation:\n\n\n-----\n\n#### File Footer Writing detection\n\n###### ➔ By monitoring the file writes performed in this way, it is possible\n```\n   to count how many file markers are appended to files\n\n ➔ E.g. We can keep track of these file writes with a dictionary data\n   structure where on the key is stored the Length of the write\n   operation and as a value the counter of how many times that write\n   with that size has been appended to a file\n\n ➔ When a Ransomware is executed it should be observed that the\n   counter contained in the value of a specific key of the dict is\n   exceeding a threshold\n\n```\n\n-----\n\n#### Restart Manager API heavy usage detection\n\n###### ➔ Restart Manager API usage common implementation:\n```\n   ◆ RmStartSession()\n   ◆ RmRegisterResource(..., &filePath, …)\n   ◆ RmGetList()\n\n ➔ Whenever a call to CreateFile() fails to return a valid file\n   handle, the Ransomware assumes the failure is due to some file\n   locking mechanism held by some process\n   ◆ This generates a heavy usage of the Restart Manager APIs\n\n ➔ Lowest NT API to monitor by reversing RmGetList() from\n   RstrtMgr.dll:\n   ◆ RmGetList()\n   ◆ CRestartManager::GetAffectedApplications()\n   ◆ CRestartManager::UpdateInternalData()\n   ◆ RmFileFactory::UniqueAffectedPids()\n   ◆ RMRegisteredFile::AffectedPids()\n\n```\n\n-----\n\n#### Restart Manager API heavy usage detection\n\n###### ➔ The invocation of NtQueryInformationFile() from\n```\n  RmGetList() uses an undocumented FILE_INFORMATION_CLASS\n  value of FileProcessIdsUsingFileInformation\n\n ➔ Peak usage of this call performed with the\n  FileProcessIdsUsingFileInformation value (0x2F) could be\n  used to characterize the usage of the Restart Manager API\n  specifically by a Ransomware\n\n ➔ The detection spot occurs at userland level :(\n\n```\n\n-----\n\n#### Encryption Key Randomization detection\n\n###### ➔ Private keys are generated through PRNG (pseudo random number\n```\n   generator) either for symmetric or asymmetric encryption\n   ◆ This randomization operation is performed for each file encrypted thus\n       generating a high volume usage of the PRNG functionalities\n   ◆ These implementations rely on the Win32 API calls CryptGenRandom() and\n       CryptGenKey() from advapi32.dll\n   ◆ The observed value “dwLen” for the CryptGenRandom() call do overlap between the\n       different implementations\n   ◆ Usually this value is equal to 16 or 32 that match the size of the private keys\n       for the encryption algorithms implemented (so 128 or 256 bits)\n\n ➔ Not very generic and robust like others detection methods...\n   ◆ But it can be used as an opportunistic way to detect implementation based on\n       these APIs usage\n\n```\n\n-----\n\n#### Conclusion\n\n###### ➔ Giving insights of what are the core operations\n```\n  characterizing the data encryption stage makes analysis of\n  these complex threats easier\n\n ➔ Identifying commonalities in implementations allows to\n  create behavioral indicators based on the side-effects\n  generated by those operations valid for most Ransomware\n  families\n\n ➔ The main reason for preferring behavioral indicators over\n  static indicators is because they are much more reliable\n  and harder to evade\n\n ➔ TL;DR Behavioral detection is the right approach for\n\n```\n\n-----\n\n#### Special Thanks\n\n###### ➔ SentinelOne’s team (Claudia, Daniel, Andreas) ➔ Idan Weizman ➔ Chuong Dong (@cPeterr)\n\n\n-----\n\n# Thank You!\n```\n         @splinter_code\n         splintercod3@gmail.com\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://raw.githubusercontent.com/antonioCoco/infosec-talks/main/InsomniHack_2022_Ransomware_Encryption_Internals.pdf"
    ],
    "report_names": [
        "InsomniHack_2022_Ransomware_Encryption_Internals.pdf"
    ],
    "threat_actors": [
        {
            "id": "2864e40a-f233-4618-ac61-b03760a41cbb",
            "created_at": "2023-12-01T02:02:34.272108Z",
            "updated_at": "2025-03-27T02:02:10.209072Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "ETDA:WildCard",
            "tools": [
                "RustDown",
                "SysJoker"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "256a6a2d-e8a2-4497-b399-628a7fad4b3e",
            "created_at": "2023-11-30T02:00:07.299845Z",
            "updated_at": "2025-03-27T02:00:03.257794Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "MISPGALAXY:WildCard",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716502,
    "ts_updated_at": 1743041799,
    "ts_creation_date": 1648226086,
    "ts_modification_date": 1648226086,
    "files": {
        "pdf": "https://archive.orkl.eu/ffec7ec255fbb2b3cc14d291f50d18d067cc1dc6.pdf",
        "text": "https://archive.orkl.eu/ffec7ec255fbb2b3cc14d291f50d18d067cc1dc6.txt",
        "img": "https://archive.orkl.eu/ffec7ec255fbb2b3cc14d291f50d18d067cc1dc6.jpg"
    }
}