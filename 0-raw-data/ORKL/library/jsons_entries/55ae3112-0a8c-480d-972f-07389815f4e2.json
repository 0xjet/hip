{
    "id": "55ae3112-0a8c-480d-972f-07389815f4e2",
    "created_at": "2023-01-12T15:01:11.761803Z",
    "updated_at": "2025-03-27T02:15:35.611953Z",
    "deleted_at": null,
    "sha1_hash": "070646887c90fbd54af03928cf181b4f5e4050c3",
    "title": "2022-05-05 - BLISTER Loader",
    "authors": "",
    "file_creation_date": "2022-05-28T01:19:29Z",
    "file_modification_date": "2022-05-28T01:19:29Z",
    "file_size": 1048919,
    "plain_text": "# BLISTER Loader\n\n**[elastic.github.io/security-research/malware/2022/05/02.blister/article/](https://elastic.github.io/security-research/malware/2022/05/02.blister/article/)**\n\n[BLISTER](https://elastic.github.io/security-research/tags/#blister) [Malware](https://elastic.github.io/security-research/tags/#malware)\n\n\n-----\n\n-----\n\n**Cyril François ·** [@cyril-t-f | Daniel Stepanic ·](https://github.com/cyril-t-f) [@dstepanic | Salim Bitam ·](https://github.com/dstepanic) [@soolidsnake 2022-05-](https://github.com/soolidsnake)\n05\n\n## Key Takeaways¶\n\nBLISTER is a loader that continues to stay under the radar, actively being used to load a\nvariety of malware including clipbankers, information stealers, trojans, ransomware, and\nshellcode\nIn-depth analysis shows heavy reliance of Windows Native API’s, several injection capabilities,\nmultiple techniques to evade detection, and counter static/dynamic analysis\nElastic Security is providing a configuration extractor that can be used to identify key elements\nof the malware and dump the embedded payload for further analysis\n40 days after the initial reporting on the BLISTER loader by Elastic Security, we observed a\nchange in the binary to include additional architectures. This shows that this is an actively\ndeveloped tool and the authors are watching defensive countermeasures\n\nThe BLISTER Malware Loader\n\nFor information on the BLISTER malware loader and campaign observations, check out our blog\npost and configuration extractor detailing this:\n\n## Overview¶\n\nThe Elastic Security team has continually been monitoring the BLISTER loader since our initial\n[release at the end of last year. This family continues to remain largely unnoticed, with low detection](https://www.elastic.co/blog/elastic-security-uncovers-blister-malware-campaign)\nrates on new samples.\n\n\n-----\n\nExample of BLISTER loader detection rates\nA distinguishing characteristic of BLISTER’s author is their method of tampering with legitimate DLLs\nto bypass static analysis. During the past year, Elastic Security has observed the following legitimate\nDLL’s patched by BLISTER malware:\n\n**Filename** **Description**\n\ndxgi.dll DirectX Graphics Infrastructure\n\nWIAAut.DLL WIA Automation Layer\n\nPowerCPL.DLL Power Options Control Panel\n\nWIMGAPI.DLL Windows Imaging Library\n\nrdpencom.dll RDPSRAPI COM Objects\n\ncolorui.dll Microsoft Color Control Panel.\n\ntermmgr.dll Microsoft TAPI3 Terminal Manager\n\nlibcef.dll Chromium Embedded Framework (CEF) Dynamic Link Library\n\nCEWMDM.DLL Windows CE WMDM Service Provider\n\nintl.dll LGPLed libintl for Windows NT/2000/XP/Vista/7 and Windows 95/98/ME\n\nvidreszr.dll Windows Media Resizer\n\nsppcommdlg.dll Software Licensing UI API\n\nDue to the way malicious code is embedded in an otherwise benign application, BLISTER may be\nchallenging for technologies that rely on some forms of machine learning. Combined with codesigning defense evasion, BLISTER appears designed with security technologies in mind.\n\n[Our research shows that BLISTER is actively developed and has been linked in public reporting to](https://www.trendmicro.com/en_us/research/22/d/Thwarting-Loaders-From-SocGholish-to-BLISTERs-LockBit-Payload.html?utm_source=trendmicroresearch&utm_medium=smk&utm_campaign=0422_Socgholish)\n[LockBit ransomware and the SocGholish framework; in addition, Elastic has also observed BLISTER](https://malpedia.caad.fkie.fraunhofer.de/details/win.lockbit)\n[in relation to the following families: Amadey,](https://malpedia.caad.fkie.fraunhofer.de/details/win.amadey) [BitRAT,](https://malpedia.caad.fkie.fraunhofer.de/details/win.bit_rat) [Clipbanker,](https://malpedia.caad.fkie.fraunhofer.de/details/win.clipbanker) [Cobalt Strike,](https://malpedia.caad.fkie.fraunhofer.de/details/win.cobalt_strike) [Remcos, and](https://malpedia.caad.fkie.fraunhofer.de/details/win.remcos)\n[Raccoon along with others.](https://malpedia.caad.fkie.fraunhofer.de/details/win.raccoon)\n\nIn this post, we will explain how BLISTER continues to operate clandestinely, highlight the loader’s\ncore capabilities (injection options, obfuscation, and anti-analysis tricks) as well as provide a\nconfiguration extractor that can be used to dump BLISTER embedded payloads.\n\n[Consider the following sample representative of BLISTER for purposes of this analysis. This sample](https://www.virustotal.com/gui/file/afb77617a4ca637614c429440c78da438e190dd1ca24dc78483aa731d80832c2)\nwas also used to develop the initial BLISTER family YARA signature, the configuration extraction\nscript, and evaluate tools against against unknown x32 and x64 BLISTER samples.\n\n## Execution Flow¶\n\nThe execution flow consists of the following phases:\n\n\n-----\n\nDeciphering the second stage\nRetrieving configuration and packed payload\nPayload unpacking\nPersistence mechanisms\nPayload injection\n\n### Launch / Entry Point¶\n\nDuring the first stage of the execution flow, BLISTER is embedded in a legitimate version of the\n[colorui.dll library. The threat actor, with a previously achieved foothold, uses the Windows built-in](https://www.virustotal.com/gui/file/1068e40851b243a420cb203993a020d0ba198e1ec6c4d95f0953f81e13046973/details)\n```\nrundll32.exe utility to load BLISTER by calling the export function LaunchColorCpl:\n\n```\nRundll32 execution arguments\n```\nrundll32.exe \"BLISTER.dll,LaunchColorCpl\"\n\n```\nThe image below demonstrates how BLISTER’s DLL is modified, noting that the export start is\npatched with a function call (line 17) to the malware entrypoint.\n\nExport of Patched BLISTER DLL\nIf we compare one of these malicious loaders to the original DLL they masquerade as, we can see\nwhere the patch was made, the function no longer exists:\n\n\n-----\n\nExport of Original DLL Used by BLISTER\n\n### Deciphering Second Stage¶\n\n[BLISTER’s second stage is ciphered in its resource section ( .rsrc ).](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-rsrc-section)\n\nThe deciphering routine begins with a loop based sleep to evade detection:\n\nInitial Sleep Mechanism\n\n\n-----\n\nBLISTER then enumerates and hashes each export of `ntdll, comparing export names against`\nloaded module names; searching specifically for the NtProtectVirtualMemory API:\n\nAPI Hash\nFinally, it looks for a memory region of `100,832 bytes by searching for a specific memory pattern,`\nbeginning its search at the return address and leading us in the `.rsrc section. When found,`\nBLISTER performs an eXclusive OR (XOR) operation on the memory region with a four-byte key,\nsets it’s page protection to `PAGE_EXECUTE_READ with a call to` `NtProtectVirtualMemory, and`\ncall its second stage entry point with the deciphering key as parameter:\n\nMemory Tag & Memory Region Setup\n\n### Obfuscation¶\n\nBLISTER’s second-stage involves obfuscating functions, scrambling their control flow by splitting\ntheir basic blocks with unconditional jumps and randomizing basic blocks’ locations. An example of\nwhich appears below.\n\n\n-----\n\nFunction’s Control Flow Scrambling\nBLISTER inserts junk code into basic blocks as yet another form of defense evasion, as seen below.\n\nJunk Code Insertion\n\n### Retrieving Configuration and Packed Payload¶\n\n\n-----\n\nBLISTER uses the previous stage s four-byte key to locate and decipher its configuration.\n\nThe routine begins by searching its memory, beginning at return address, for its four-byte key\nXORed with a hardcoded value as memory pattern:\n\nMemory pattern search loop\nWhen located, the `0x644 byte configuration is copied and XOR-decrypted with the same four-byte`\nkey:\n\n\n-----\n\nConfig decryption\nFinally, it returns a pointer to the beginning of the packed PE, which is after the `0x644 byte blob:`\n\nPointer return to packed PE\nSee the configuration structure in the appendix.\n\n### Time Based Anti Debug¶\n\nAfter loading the configuration, and depending if the kEnableSleepBasedAntiDebug flag ( 0x800 )\nis set, BLISTER calls its time-based anti-debug function:\n\nCheck configuration for Sleep function\nThis function starts by creating a thread with the Sleep Windows function as a starting address and\n10 minutes as the argument:\n\n\n-----\n\nSleep function (600000 ms / 10 minutes)\nThe main thread will sleep using NtDelayExecution until the sleep thread has exited:\n\nNtDelayExecution used with Sleep function\nFinally the function returns `0 when the sleep thread has run at least for 9 1/2 minutes:`\n\nCondition to end sleep thread\nIf not, the function will return `1 and the process will be terminated:`\n\n\n-----\n\nProcess termination on sleep function if error\n\n### Windows API¶\n\n**Blister’s GetModuleHandle¶**\n\nBLISTER implements its own GetModuleHandle to evade detection, the function takes the library\nname hash as a parameter, iterates over the process [PEB LDR’s modules and checks the hashed](https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data)\nmodule’s name against the one passed in the parameter:\n\nFunction used to verify module names\n\n**Blister’s GetProcAddress¶**\n\nBLISTER’s GetProcAddress takes the target DLL and the export hash as a parameter, it also takes\na flag that tells the function that the library is 64 bits.\n\n\n-----\n\nThe DLL can be loaded or mapped then the function iterates over the DLL s export function names\nand compares their hashes with the ones passed in the parameter:\n\nBLISTER’s GetProcAddress hash checking dll’s exports\nIf the export is found, and its virtual address isn’t null, it is returned:\n\nReturn export virtual address\nElse the DLL is LdrLoaded and BLISTER’s GetProcAddress is called again with the newly loaded\ndll:\n\nLdrLoad the DLL and call GetProcAddress again\n\n**Library Manual Mapping¶**\n\nBLISTER manually maps a library using NtCreateFile in order to open a handle on the DLL file:\n\nNtCreateFile used within mapping function\nNext it creates a section with the handle by calling NtCreateSection with the SEC_IMAGE attribute\nwhich tells Windows to loads the binary as a PE:\n\nNtCreateSection used within mapping function\n_NtCreateSection used within mapping function_\n\nFinally it maps the section with NtMapViewOfSection:\n\n\n-----\n\nNtMapViewofSection used within mapping function\n\n**x32/x64 Ntdll Mapping¶**\n\nFollowing the call to its anti-debug function, BLISTER manually maps 32 bit and 64 bit versions of\nNTDLL.\n\nIt starts by mapping the x32 version:\n\n32 bit NTDLL mapping\n[Then it disables SysWOW64 redirection:](https://docs.microsoft.com/en-us/windows/win32/winprog64/file-system-redirector)\n\nSysWOW64 disabled\nAnd then maps the 64 bit version:\n\n64 bit NTDLL mapping\nThen if available, the mapped libraries will be used with the GetProcAddress function, i.e:\n\nMapped libraries using GetProcAddress\n\n**LdrLoading Windows Libraries and Removing Hooks¶**\n\nAfter mapping 32 and 64 bit NTDLL versions BLISTER will LdrLoad several Windows libraries and\nremove potential hooks:\n\n\n-----\n\nFunction used to load Windows libraries and remove hooks\nFirst, it tries to convert the hash to the library name by comparing the hash against a fixed list of\nknown hashes:\n\nHash comparison\nIf the hash is found BLISTER uses the LdrLoad to load the library:\n\n\n-----\n\nLeveraging LdrLoad to load DLL\nThen BLISTER searches for the corresponding module in its own process:\n\nSearching for module in own process\nAnd maps a fresh copy of the library with the module’s FullDllName:\n\nRetrieving Module’s FullDllName\n\nManual Mapping function\nBLISTER then applies the relocation to the mapped library with the loaded one as the base address\nfor the relocation calculation:\n\nPerforming relocation\nNext BLISTER iterates over each section of the loaded library to see if the section is executable:\n\nChecking executable sections\nIf the section is executable, it is replaced with the mapped one, thus removing any hooks:\n\n\n-----\n\nSection replacement\n\n**x64 API Call¶**\n\nBLISTER can call 64-bit library functions through the use of special 64-bit function wrapper:\n\nBLISTER utilizing 64-bit function library caller\n\n64-bit function library caller\nTo make this call BLISTER switches between 32-bit to 64-bit code using the old Heaven’s Gate\n[technique:](https://blog.talosintelligence.com/2019/07/rats-and-stealers-rush-through-heavens.html)\n\nObserved Heaven’s Gate byte sequences\n\n\n-----\n\nHeaven’s Gate - Transition to 64 bit mode\n\nHeaven’s Gate - Transition to 32 bit mode\n\n## Unpacking Payload¶\n\nDuring the unpacking process of the payload, the malware starts by allocating memory using\n**NtAllocateVirtualMemory and passing in configuration information. A** `memcpy function is used to`\nstore a copy of encrypted/compressed payload in a buffer for next stage (decryption).\n\n\n-----\n\nUnpacking BLISTER payload\n\n### Deciphering¶\n\n[BLISTER leverages the Rabbit stream cipher, passing in the previously allocated buffer containing](https://en.wikipedia.org/wiki/Rabbit_(cipher))\nthe encrypted payload, the compressed data size along with the 16-byte deciphering key and 8-byte\nIV.\n\nDecipher function using the Rabbit cipher\n\nObserved Rabbit Cipher Key and IV inside memory\n\n### Decompression¶\n\nAfter the decryption stage, the payload is then decompressed using RtlDecompressBuffer with the\n```\nLZNT1 compression format.\n\n```\nDecompression function using LZNT1\n\n## Persistence Mechanism¶\n\nTo achieve persistence, BLISTER leverages Windows shortcuts by creating an `LNK file inside the`\nWindows startup folder. It creates a new directory using the CreateDirectoryW function with a\nunique hardcoded string found in the configuration file such as: C:\\ProgramData`UNIQUE STRING>`\n\n\n-----\n\nBLISTER then copies `C:\\System32\\rundll32.exe and itself to the newly created directory and`\nrenames the files to `UNIQUE STRING>.exe and` `UNIQUE STRING>.dll, respectively.`\n\nBLISTER uses the CopyModuleIntoFolder function and the IFileOperation Windows COM\ninterface for [bypassing UAC when copying and renaming the files:](https://elastic.github.io/security-research/whitepapers/2022/02/03.exploring-windows-uac-bypass-techniques-detection-strategies/article/)\n\nBLISTER function used to copy files\nThe malware creates an `LNK file using IShellLinkW COM interface and stores it in`\n```\nC:\\Users<username>\\AppData\\Roaming\\Microsft\\Windows\\Start Menu\\Startup as UNIQUE\nSTRING>.lnk\n\n```\nMapping shortcut to BLISTER with arguments\nThe `LNK file is set to run the export function LaunchColorCpl of the newly copied malware with`\nthe renamed instance of rundll32. `C:\\ProgramData\\UNIQUE STRING>\\UNIQUE STRING>.exe`\n```\nC:\\ProgramData\\UNIQUE STRING>\\UNIQUE STRING>.dll,LaunchColorCpl\n\n```\n\n-----\n\n## Injecting Payload¶\n\nBLISTER implements 3 different injection techniques to execute the payload according to the\nconfiguration flag:\n\nBLISTER injection techniques by config flag\n\n### Shellcode Execution¶\n\nAfter decrypting the shellcode, BLISTER is able to inject it to a newly allocated read write memory\nregion with NtAllocateVirtualMemory API, it then copies the shellcode to it and it sets the memory\nregion to read write execute with NtProtectVirtualMemory and then executes it.\n\nExecute shellcode function\n\n### Own Process Injection¶\n\n\n-----\n\nBLISTER can execute DLL or Executable payloads reflectively in its memory space. It first creates a\nsection with NtCreateSection API.\n\nRunPE function\nBLISTER then tries to map a view on the created section at the payload’s preferred base address. In\ncase the preferred address is not available and the payload is an executable it will simply map a\nview on the created section at a random address and then do relocation.\n\nCheck for conflicting addresses\nConversly, if the payload is a DLL, it will first unmap the memory region of the current process image\nand then it will map a view on the created section with the payload’s preferred address.\n\nDLL unmapping\nBLISTER then calls a function to copy the PE headers and the sections.\n\nCopying over PE/sections\n\n\n-----\n\nFinally, BLISTER executes the loaded payload in memory starting from its entry point if the payload\nis an executable. In case the payload is a DLL, it will find its export function according to the hash in\nthe config file and execute it.\n\n### Process Hollowing¶\n\n[BLISTER is able to perform process hollowing in a remote process:](https://attack.mitre.org/techniques/T1055/012/)\n\nFirst, there is an initial check for a specific module hash value ( 0x12453653 ), if met, BLISTER\nperforms process hollowing against the Internet Explorer executable.\n\nInternet Explorer option for process hollowing\nIf not, the malware performs remote process hollowing with Werfault.exe. BLISTER follows\nstandard techniques used for process hollowing.\n\nProcess hollowing function\nThere is one path within this function: if certain criteria are met matching Windows OS versions and\nbuild numbers the hollowing technique is performed by dropping a temporary file on disk within the\n**AppData folder titled Bg.Agent.ETW with an explicit extension.**\n\nCompatibility Condition check\n\n\n-----\n\nCompatibility Condition function\n\nTemporary file used to store payload\nThe malware uses this file to read and write malicious DLL to this file. `Werfault.exe is started by`\nBLISTER and then the contents of this temporary DLL are loaded into memory into the Werfault\nprocess and the file is shortly deleted after.\n\nProcmon output of compatibility function\n\n## Configuration Extractor¶\n\nAutomating the configuration and payload extraction from BLISTER is a key aspect when it comes to\nthreat hunting as it gives visibility of the campaign and the malware deployed by the threat actors\nwhich enable us to discover new unknown samples and Cobalt Strike instances in a timely manner.\n\nOur extractor uses a [Rabbit stream cipher implementation and takes either a directory of samples](https://github.com/Robin-Pwner/Rabbit-Cipher)\nwith -d option or -f for a single sample,\n\n\n-----\n\nConfig extractor output\nTo enable the community to further defend themselves against existing and new variants of the\nBLISTER loader, we are making the configuration extractor open source under the Apache 2\n[License. The configuration extractor documentation and binary download can be accessed here.](https://elastic.github.io/security-research/tools/blister-config-extractor/)\n\n## Conclusion¶\n\nBLISTER continues to be a formidable threat, punching above its own weight class, distributing\npopular malware families and implants leading to major compromises. Elastic Security has been\ntracking BLISTER for months and we see no signs of this family slowing down.\n\nFrom reversing BLISTER, our team was able to identify key functionality such as different injection\nmethods, multiple techniques for defense evasion using anti-debug/anti-analysis features and heavy\nreliance on Windows Native API’s. We also are releasing a configuration extractor that can statically\nretrieve actionable information from BLISTER samples as well as dump out the embedded payloads.\n\n## Appendix¶\n\n### Configuration Structure¶\n\n Configuration’s Flags¶\n\n Hashing Algorithm¶\n\nBLISTER hashing algorithm\n\n\n-----\n\n```\nuint32_t HashLibraryName(wchar_t name) {\n uint32_t name {0};\n while (*name) {\n hash = ((hash >> 23) | (hash << 9)) + *name++;\n }\n return hash ;\n}\n\n### Indicators¶\n\n```\n**Indicator** **Type** **Note**\n\nafb77617a4ca637614c429440c78da438e190dd1ca24dc78483aa731d80832c2 SHA256 BLISTER\nDLL\n\n### YARA Rule¶\n\nThis updated YARA rule has shown a 13% improvement in detection rates.\n\nBLISTER YARA rule\n```\nrule Windows_Trojan_BLISTER {\n  meta:\n    Author = \"Elastic Security\"\n    creation_date = \"2022-04-29\"\n    last_modified = \"2022-04-29\"\n    os = \"Windows\"\n    arch = \"x86\"\n    category_type = \"Trojan\"\n    family = \"BLISTER\"\n    threat_name = \"Windows.Trojan.BLISTER\"\n    description = \"Detects BLISTER loader.\"\n    reference_sample =\n\"afb77617a4ca637614c429440c78da438e190dd1ca24dc78483aa731d80832c2\"\n  strings:\n    $a1 = { 8D 45 DC 89 5D EC 50 6A 04 8D 45 F0 50 8D 45 EC 50 6A FF FF D7 }\n    $a2 = { 75 F7 39 4D FC 0F 85 F3 00 00 00 64 A1 30 00 00 00 53 57 89 75 }\n    $a3 = { 78 03 C3 8B 48 20 8B 50 1C 03 CB 8B 78 24 03 D3 8B 40 18 03 FB 89 4D F8 89\n55 E0 89 45 E4 85 C0 74 3E 8B 09 8B D6 03 CB 8A 01 84 C0 74 17 C1 C2 09 0F BE C0 03 D0 41 8A\n01 84 C0 75 F1 81 FA B2 17 EB 41 74 27 8B 4D F8 83 C7 02 8B 45 F4 83 C1 04 40 89 4D F8 89 45\nF4 0F B7 C0 3B 45 E4 72 C2 8B FE 8B 45 04 B9 }\n    $b1 = { 65 48 8B 04 25 60 00 00 00 44 0F B7 DB 48 8B 48 ?? 48 8B 41 ?? C7 45 48 ??\n?? ?? ?? 4C 8B 40 ?? 49 63 40 ?? }\n    $b2 = { B9 FF FF FF 7F 89 5D 40 8B C1 44 8D 63 ?? F0 44 01 65 40 49 2B C4 75 ?? 39\n4D 40 0F 85 ?? ?? ?? ?? 65 48 8B 04 25 60 00 00 00 44 0F B7 DB }\n  condition:\n    any of them\n}\n\n## References¶\n\n Artifacts¶\n\n```\nArtifacts are also available for download in both ECS and STIX format in a combined zip bundle\n\n\n-----\n\n[Download indicators.zip](https://elastic.github.io/security-research/malware/2022/05/02.blister/indicators.zip)\n\nLast update: May 18, 2022\nCreated: May 6, 2022\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-05-05 - BLISTER Loader.pdf"
    ],
    "report_names": [
        "2022-05-05 - BLISTER Loader.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "9f101d9c-05ea-48b9-b6f1-168cd6d06d12",
            "created_at": "2023-01-06T13:46:39.396409Z",
            "updated_at": "2025-03-27T02:00:03.074969Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "CHROMIUM",
                "ControlX",
                "Red Dev 10",
                "RedHotel",
                "Red Scylla",
                "TAG-22",
                "BRONZE UNIVERSITY",
                "AQUATIC PANDA",
                "Charcoal Typhoon",
                "BountyGlad"
            ],
            "source_name": "MISPGALAXY:Earth Lusca",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "6abcc917-035c-4e9b-a53f-eaee636749c3",
            "created_at": "2022-10-25T16:07:23.565337Z",
            "updated_at": "2025-03-27T02:02:09.868522Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Bronze University",
                "Charcoal Typhoon",
                "Chromium",
                "Red Dev 10",
                "Red Scylla"
            ],
            "source_name": "ETDA:Earth Lusca",
            "tools": [
                "Agentemis",
                "AntSword",
                "BIOPASS",
                "BIOPASS RAT",
                "BadPotato",
                "Behinder",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "Doraemon",
                "FRP",
                "Fast Reverse Proxy",
                "FunnySwitch",
                "HUC Port Banner Scanner",
                "KTLVdoor",
                "Mimikatz",
                "NBTscan",
                "POISONPLUG.SHADOW",
                "PipeMon",
                "RbDoor",
                "RibDoor",
                "RouterGod",
                "SAMRID",
                "ShadowPad Winnti",
                "SprySOCKS",
                "WinRAR",
                "Winnti",
                "XShellGhost",
                "cobeacon",
                "fscan",
                "lcx",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d53593c3-2819-4af3-bf16-0c39edc64920",
            "created_at": "2022-10-27T08:27:13.212301Z",
            "updated_at": "2025-03-27T02:00:55.529662Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Earth Lusca",
                "TAG-22",
                "Charcoal Typhoon",
                "CHROMIUM",
                "ControlX"
            ],
            "source_name": "MITRE:Earth Lusca",
            "tools": [
                "Mimikatz",
                "PowerSploit",
                "Tasklist",
                "certutil",
                "Cobalt Strike",
                "Winnti for Linux",
                "Nltest",
                "NBTscan",
                "ShadowPad"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535671,
    "ts_updated_at": 1743041735,
    "ts_creation_date": 1653700769,
    "ts_modification_date": 1653700769,
    "files": {
        "pdf": "https://archive.orkl.eu/070646887c90fbd54af03928cf181b4f5e4050c3.pdf",
        "text": "https://archive.orkl.eu/070646887c90fbd54af03928cf181b4f5e4050c3.txt",
        "img": "https://archive.orkl.eu/070646887c90fbd54af03928cf181b4f5e4050c3.jpg"
    }
}