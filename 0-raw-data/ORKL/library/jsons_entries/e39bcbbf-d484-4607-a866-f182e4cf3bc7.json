{
    "id": "e39bcbbf-d484-4607-a866-f182e4cf3bc7",
    "created_at": "2023-01-12T15:08:14.904946Z",
    "updated_at": "2025-03-27T02:09:18.424253Z",
    "deleted_at": null,
    "sha1_hash": "83996cce7c3b10c678d6062a9915bed720001926",
    "title": "2022-07-20 - Analysis of a trojanized jQuery script- GootLoader unleashed",
    "authors": "",
    "file_creation_date": "2022-08-18T03:29:16Z",
    "file_modification_date": "2022-08-18T03:29:16Z",
    "file_size": 5822404,
    "plain_text": "# Analysis of a trojanized jQuery script: GootLoader unleashed\n\n**[blog.nviso.eu/2022/07/20/analysis-of-a-trojanized-jquery-script-gootloader-unleashed/](https://blog.nviso.eu/2022/07/20/analysis-of-a-trojanized-jquery-script-gootloader-unleashed/)**\n\nJuly 20, 2022\n\nIn this blog post, we will perform a deep analysis into GootLoader, malware which is known\nto deliver several types of payloads, such as Kronos trojan, REvil, IcedID, GootKit payloads\nand in this case Cobalt Strike.\n\nIn our analysis we’ll be using the initial malware sample itself together with some malware\nartifacts from the system it was executed on. The malicious JavaScript code is hiding within\na jQuery JavaScript Library and contains about 287kb of data and consists of almost 11.000\nlines of code. We’ll do a step-by-step analysis of the malicious JavaScript file.\n\nTLDR techniques we used to analyze this GootLoader script:\n\n1. Stage 1: A legitimate jQuery JavaScript script is used to hide a trojan downloader:\n\nSeveral new functions were added to the original jQuery script. Analyzing these\nfunctions would show a blob of obfuscated data and functions to deobfuscate this blob.\n\n\n-----\n\n2. The algorithm used for deobfuscating this blob (trojan downloader):\n\n1. For each character in the obfuscated data, assess whether it is at an even or\n\nuneven position (index starting at 0)\n1. If uneven, put it in front of an accumulator string\n1. If even, put it at the back of the accumulator string\n1. The result is more JavaScript code\n3. Attempt to download the (obfuscated) payload from one of three URLs listed in the\n\nresulting JavaScript code.\n\n1. This failed due to the payload not being served anymore and we resorted to\n\nmake an educated guess to search for an obfuscated (as defined in the previous\noutput) “createobject” string on VirusTotal with the “content” filter, which resulted\nin a few hits.\n4. Stage 2: Decode the obfuscated payload\n\n1. Take 2 digits\n1. Convert these 2 decimal digits to an integer\n1. Add 30\n1. Convert to ASCII\n1. Repeat till the end\n1. The result is a combination of JavaScript and PowerShell\n5. Extract the JavaScript, PowerShell loader, PowerShell persistence and analyze it to\n\nextract the obfuscated .NET loader embedded in the payload\n6. Stage 3: Analyze the .NET loader to deobfuscate the Cobalt Strike DLL\n7. Stage 4: Extract the config from the Cobalt Strike DLL\n\n## Stage 1 – sample_supplier_quality_agreement 33187.js\n\nFilename: sample_supplier_quality_agreement 33187.js\n\nMD5: dbe5d97fcc40e4117a73ae11d7f783bf\n\nSHA256: 6a772bd3b54198973ad79bb364d90159c6f361852febe95e7cd45b53a51c00cb\n\nFile Size: 287 KB\n\nTo find the trojan downloader inside this JavaScript file, the following grep command was\nexecuted:\n```\ngrep -P \"^[a-zA-Z0-9]+\\(\"\n\n```\nFig 1. The function “hundred71(3565)” looks out of place here\nThis grep command will find entry points that are calling a JavaScript function outside any\nfunction definition, thus without indentation (leading whitespace). This is a convention that\nmany developers follow, but it is not a guarantee to quickly find the entry point. In this case,\n\n\n-----\n\nthe function call hundred17(3565) looks out of place in a mature JavaScript library like\njQuery.\n\nWhen tracing the different calls, there’s a lot of obfuscated code, the function “color1” is\nobserved Another way to figure out what was changed in the script could be to compare it to\nthe legitimate version[1] of the script and “diff” them to see the difference. The legitimate\nscript was pulled from the jQuery website itself, based on the version displayed in the\nbeginning of the malicious script.\n\nFig 2. The version of the jQuery JavaScript Library displayed here was used to fetch the\noriginal\nBefore starting a full diff on the entire jQuery file, we first extracted the functions names with\nthe following grep command:\n```\ngrep 'function [0-9a-zA-Z]'\n\n```\nThis was done for both the legitimate jQuery file and the malicious one and allows us to\nquickly see which additional functions were added by the malware creator. Comparing these\ntwo files immediately show some interesting function names and parameters:\n\n\n-----\n\nFig 3.\n\nMany functions were added by the malware author as seen in this screenshot\nA diff on both files without only focusing on the function names gave us all the added code\nby the malware author.\n\nColor1 is one of the added functions containing most of the data, seemingly obfuscated,\nwhich could indicated this is the most relevant function.\n\nFig 4. Out of all the added functions, “color1()” contains the most amount of data\nThe has6 variable is of interest in this function, as it combines all the previously defined\nvariables into 1:\n\nFurther tracing of the functions eventually leads to the main functions that are responsible for\ndeobfuscating this data: “modern00” and “gun6”\n\nFig 5. Function modern00, responsible for part of the deobfuscation algorithm\n\n\n-----\n\nFig 6. Function gun6, responsible for the modulo part of the deobfuscation algorithm\nThe deobfuscation algorithm is straightforward:\n\nFor each character in the obfuscated string (starting with the first character), add this\ncharacter to an accumulator string (initially empty). If the character is at an uneven position\n(index starting from 0), put it in front of the accumulator, otherwise put it at the back. When all\ncharacters have been processed, the accumulator will contain the deobfuscated string.\n\nThe script used to implement the algorithm would look similar to the following written in\nPython:\n\nFig 7. Proof of concept Python script to display how the algorithm functions\n\nFig 8. Running the deobfuscation script displays readable code\nCreateObject, observed in the deobfuscated script, is used to create a script execution object\n(WScript.Shell) that is then passed the script to execute (first script). This script (highlightd in\nwhite) is also obfuscated with JavaScript obfuscation and the same script obfuscation that\nwas observed in the first script.\n\n\n-----\n\nDeobfuscating that script yields a second JavaScript script. Following, is the second script,\nwith deobfuscated strings and code, and “pretty-printed”:\n\nFig 9. Pretty printed deobfuscated code\nThis script is a downloader script, attempting to initiate a download from 3 domains.\n\nwww[.]labbunnies[.]eu\nwww[.]lenovob2bportal[.]com\nwww[.]lakelandartassociation[.]org\n\nThe HTTPS requests have a random component and can convey a small piece of\ninformation: if the request ends with “4173581”, then the request originates from a Windows\nmachine that is a domain member (the script determines this by checking for the presence of\nenvironment variable %USERDNSDOMAIN%).\n\nThe following is an example of a URL:\n\nhxxps://www[.]labbunnies[.]eu/test[.]php?cmqqvfpugxfsfhz=71941221366466524173581\n\nIf the download fails (i.e., HTTP status code different from 200), the script sleeps for 12\nseconds (12345 milliseconds to be precise) before trying the next domain. When the\ndownload succeeds, the next stage is decoded and executed as (another) JavaScript script.\nDifferent methods were attempted to download the payload (with varying URLs), but all\nmethods were unsuccessful. Most of the time a TCP/TLS connection couldn’t be established\nto the server. The times an HTTP reply was received, the body was empty (content-length 0).\nAlthough we couldn’t download the payload from the malicious servers, we were able to\nretrieve it from VirusTotal.\n\n## Stage 2 – Payload\n\n\n-----\n\nWe were able to find a payload that we believe, with high confidence, to be the original stage\n2. With high confidence, it was determined that this is indeed the payload that was served to\nthe infected machine, more information on how this was determined can be found in the\nfollowing sections. The payload, originally uploaded from Germany, can be found here:\nhttps://www.virustotal.com/gui/file/f8857afd249818613161b3642f22c77712cc29f30a6993ab6\n8351af05ae14c0f\n\nMD5: ae8e4c816e004263d4b1211297f8ba67\n\nSHA-256: f8857afd249818613161b3642f22c77712cc29f30a6993ab68351af05ae14c0f\n\nFile Size: 1012.97 KB\n\nThe payload consists of digits. To decode it, take 2 digits, add 30, convert to an ASCII\ncharacter, and repeat this till the end of the payload. This deobfuscation algorithm was\ndeduced from the previous script, in the last step:\n\nFig 10. Stage 2 acquired from VirusTotal\n\n\n-----\n\nFig 11. Deobfuscation algorithm for stage 2\nAs an example, we’ll decode the first characters of the strings in detail: 88678402\n\n1. 88 –> 88+30 = 118\n\nFig 12. ASCII value 118 equals the letter v\n\n1. 67 –> 67 + 30 = 97\n\n\n-----\n\nFig 13. ASCII value 97 equals the letter a\n\n1. 84 –> 84 + 30 = 114\n\nFig 14. ASCII value 114 equals the letter r\n\n1. 02 –> 02+30 = 32\n\n\n-----\n\nFig 15. ASCII value 32 equals the symbol “space”\nThis results in: “var “, which indicates the declaration of a variable in JavaScript. This means\nwe have yet another JavaScript script to analyze.\n\nTo decode the entire string a bit faster we can use a small Python script, which will automate\nthe process for us:\n\nFig 16. Proof of concept Python script to display how the algorithm functions\nFirst half of the decoded string:\n\n\n-----\n\nFig 17. Output of the deobfuscation script, showing the first part\nSecond half of the decoded string:\n\nFig 18. Output of the deobfuscation script, showing the second part\nThe same can be done with the following CyberChef recipe, it will take some time, due to the\namount of data, but we saw it as a small challenge to use CyberChef to do the same.\n```\n#recipe=Regular_expression('User%20defined','..',true,true,false,false,false,false,'Li\n\n```\n\n-----\n\nFig 19. The CyberChef recipe in action\nThe decoded payload results in another JavaScript script.\n\nMD5: a8b63471215d375081ea37053b52dfc4\n\nSHA256: 12c0067a15a0e73950f68666dafddf8a555480c5a51fd50c6c3947f924ec2fb4\n\nFile size: 507 KB\n\nThe JavaScript script contains code to insert an encoded PE file (unmanaged code) and\ncreate a key with as value as encoded assembly\n(“HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Phone”) and then launches 2 PowerShell\nscripts. These 2 PowerShell scripts are fileless, and thus have no filename. For referencing\nin this document, the PowerShell scripts are named as follows:\n\n1. powershell_loader: this PowerShell script is a loader to execute the PE file injected into\n\nthe registry\n2. powershell_persistence: this PowerShell script creates a scheduled task to execute the\n\nloader PowerShell script (powershell_loader) at boot time.\n\n\n-----\n\nFig 20. Deobfuscated & pretty-printed JavaScript script found in the decoded payload\nA custom script was utilized to decode this payload as a whole and extract all separate\nelements from it (based on the reverse engineering of the script itself). The following is the\noutput of the custom script:\n\nFig 21. Output of the custom script parsing all the components from the deobfuscated\nAll the artifacts extracted with this script match exactly with the artifacts recovered from the\ninfected machine. These can be verified with the fileless artifacts extracted from Defender\nlogs, with matching cryptographic hash:\n\n\n-----\n\nStage 2 SHA256 Script:\n12c0067a15a0e73950f68666dafddf8a555480c5a51fd50c6c3947f924ec2fb4\nStage 2 SHA256 Persistence PowerShell script (powershell_persistence):\n48e94b62cce8a8ce631c831c279dc57ecc53c8436b00e70495d8cc69b6d9d097\nStage 2 SHA256 PowerShell script (powershell_loader) contained in Persistence\nPowerShell script:\nc8a3ce2362e93c7c7dc13597eb44402a5d9f5757ce36ddabac8a2f38af9b3f4c\nStage 3 SHA256 Assembly:\nf1b33735dfd1007ce9174fdb0ba17bd4a36eee45fadcda49c71d7e86e3d4a434\nStage 4 SHA256 DLL:\n63bf85c27e048cf7f243177531b9f4b1a3cb679a41a6cc8964d6d195d869093e\n\nBased on this information, it can be concluded, with high confidence, that the payload found\non VirusTotal is identical to the one downloaded by the infected machine: all hashes match\nwith the artifacts from the infected machine.\n\nIn addition to the evidence these matching hashes bring, the stage 2 payload file also ends\nwith the following string (this is not part of the encoded script):\n@83290986999722234173581@. This is the random part of the URL used to request this\npayload. Notice that it ends with 4173581, the unique number for domain joined machines\nfound in the trojanized jQuery script.\n\n### Payload retrieval from VirusTotal\n\nAlthough VirusTotal has reports for several URLs used by this malicious script, none of the\nreports contained a link to the actual downloaded content. However, using the following\nquery: content:”378471678671496876716986″, the download content (payload) was found\non VirusTotal; This string of digits corresponds to the encoding of string “CreateObject”. (see\nFig. 20)\n\nIn order to attempt the retrieval of the downloaded content, an educated guess was made\nthat the downloaded payload would contain calls to function CreateObject, because such\nfunctions calls are also present in the trojanized jQuery script. There are countless files on\nVirusTotal that contain the string “CreateObject”, but in this particular case, it is encoded with\nan encoding specific to GootLoader. Each letter of the string “CreateObject” is encoded to its\nnumerical representation (ASCII code), and subtracted with 30. This returns the string\n“378471678671496876716986”.\n\n## Stage 3 – .NET Loader\n\nMD5 Assembly: d401dc350aff1e3fd4cc483238208b43\n\nSHA256 Assembly:\nf1b33735dfd1007ce9174fdb0ba17bd4a36eee45fadcda49c71d7e86e3d4a434\n\n\n-----\n\nFile Size: 13.50 KB\n\nThis .NET loader is fileless and thus has no filename.\n\nThe PowerShell loader script (powershell_loader)\n\n1. extracts the .NET Loader from the registry\n2. decodes it\n3. dynamically loads & executes it (i.e., it is not written to disk).\n\nThe .NET Loader is encoded in hexadecimal and stored inside the registry. It is slightly\nobfuscated: character # has to be replaced with 1000.\n\nThe .NET loader:\n\n1. extracts the DLL (stage 4) from the registry\n2. decodes it\n3. dynamically loads & executes it ( i.e., it is not written to disk).\n\nThe DLL is encoded in hexadecimal, but with an alternative character set. This is translated\nto regular hexadecimal via the following table:\n\nFig 22. “Test” function that decodes the DLL by using the replace\nThis Test function decodes the DLL and executes it in memory. Note that without the .NET\nloader, statistical analysis could reveal the DLL as well. A blog post[2], written by our\ncolleague Didier Stevens on how to decode a payload by performing statistical analysis can\noffer some insights on how this could be done.\n\n## Stage 4 – Cobalt Strike DLL\n\n\n-----\n\nMD5 DLL: 92a271eb76a0db06c94688940bc4442b\nSHA256 DLL: 63bf85c27e048cf7f243177531b9f4b1a3cb679a41a6cc8964d6d195d869093e\n\nThis is a typical Cobalt Strike beacon and has the following configuration (extracted with\n1768.py)\n\nFig 23. 1768.py by DidierStevens used to detect and parse the Cobalt Strike beacon\nNow that Cobalt Strike is loaded as final part of the infection chain, the attacker has control\nover the infected machine and can start his reconnaissance from this machine or make use\nof the post-exploitation functionality in Cobalt Strike, e.g. download/upload files, log\nkeystrokes, take screenshots, …\n\n## Conclusion\n\nThe analysis of the trojanized jQuery JavaScript confirms the initial analysis of the artifacts\ncollected from the infected machine and confirms that the trojanized jQuery contains\nmalicious obfuscated code to download a payload from the Internet. This payload is\ndesigned to filelessly, and with boot-persistence, instantiate a Cobalt Strike beacon.\n\n**About the authors**\n\n\nDidier\nStevens\n\n\nDidier Stevens is a malware expert working for NVISO. Didier is a SANS\nInternet Storm Center senior handler and Microsoft MVP, and has developed\nnumerous popular tools to assist with malware analysis. You can find Didier\non [Twitter and](https://twitter.com/DidierStevens) [LinkedIn.](https://be.linkedin.com/in/didierstevens)\n\n\n-----\n\nSasja\nReynaert\n\n\nSasja Reynaert is a forensic analyst working for NVISO. Sasja is a GIAC\nCertified Incident Handler, Forensics Examiner & Analyst (GCIH, GCFE,\n[GCFA). You can find Sasja on LinkedIn.](https://www.linkedin.com/in/sasjareynaert/)\n\n\n[You can follow NVISO Labs on Twitter to stay up to date on all our future research and](https://twitter.com/NVISO_Labs)\npublications.\n\n[[1]:https://code.jquery.com/jquery-3.6.0.js](https://code.jquery.com/jquery-3.6.0.js)\n\n[[2]:https://blog.didierstevens.com/2022/06/20/another-exercise-in-encoding-reversing/](https://blog.didierstevens.com/2022/06/20/another-exercise-in-encoding-reversing/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-07-20 - Analysis of a trojanized jQuery script- GootLoader unleashed.pdf"
    ],
    "report_names": [
        "2022-07-20 - Analysis of a trojanized jQuery script- GootLoader unleashed.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536094,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1660793356,
    "ts_modification_date": 1660793356,
    "files": {
        "pdf": "https://archive.orkl.eu/83996cce7c3b10c678d6062a9915bed720001926.pdf",
        "text": "https://archive.orkl.eu/83996cce7c3b10c678d6062a9915bed720001926.txt",
        "img": "https://archive.orkl.eu/83996cce7c3b10c678d6062a9915bed720001926.jpg"
    }
}