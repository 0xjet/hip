{
    "id": "5ac4a561-f1d9-4d4c-a5e7-50d793b2224b",
    "created_at": "2023-01-12T14:59:08.724068Z",
    "updated_at": "2025-03-27T02:08:40.75878Z",
    "deleted_at": null,
    "sha1_hash": "c7fac5fa321ddeca9e155cfed034dd7e06c7e95b",
    "title": "2020-10-12 - Why Emotet’s Latest Wave is Harder to Catch Than Ever Before – Part 2",
    "authors": "",
    "file_creation_date": "2022-05-29T01:38:59Z",
    "file_modification_date": "2022-05-29T01:38:59Z",
    "file_size": 468106,
    "plain_text": "# Why Emotet’s Latest Wave is Harder to Catch than Ever Before - Part 2\n\n**[deepinstinct.com/2020/10/12/why-emotets-latest-wave-is-harder-to-catch-than-ever-before-part-2/](https://www.deepinstinct.com/2020/10/12/why-emotets-latest-wave-is-harder-to-catch-than-ever-before-part-2/)**\n\nOctober 12, 2020\n\nOctober 12, 2020 | [Ron Ben Yizhak](https://www.deepinstinct.com/author/ron-ben-yizhak)\n\nEmotet, the largest malware botnet today, started in 2014 and continues to be one of the\nmost challenging threats in today’s landscape. This botnet causes huge damage by\nspreading ransomware and info stealers to its infected systems. Recently, a rise in the\n[number of Emotet infections was observed in France, Japan, and New Zealand. The high](https://www.zdnet.com/article/france-japan-new-zealand-warn-of-sudden-spike-in-emotet-attacks/)\nnumber of infections shows the effectiveness of the Emotet malware at staying undetected.\n\nThe previous wave of Emotet started in September 2019 and ended in February 2020. The\nactivity was paused for 5 months, and then, on July 17, the current wave started. Theth\ncreators behind Emotet are aware that organizations are getting more successful at\ndetecting previous versions as they increase their infection rates. Inevitably, the wave starts\nto drop as the industry gains a greater understanding and control of the threat.\n\n\n-----\n\n[A point comes when the malware creators realize they need to go back to the lab. For a](https://www.darkreading.com/attacks-breaches/emotet-return-brings-new-tactics-and-evasion-techniques/d/d-id/1338654)\nperiod of time, they go under the radar completely as they start working on the next wave,\nmaking it as potent and evasive as possible. The tactic seems to be working: After going\ndark for a few months, Emotet appears to have reemerged more evasive than before, this\ntime with a payload delivered from a loader that security tools aren't equipped to handle.\n\nIn the [previous article, we examined the Emotet loader. We revealed how it evades detection](https://www.deepinstinct.com/2020/08/12/why-emotets-latest-wave-is-harder-to-catch-than-ever-before/)\nby inserting benign code that subverts security products by obfuscating its malicious\nfunctionality. This loader contains a hidden payload that is decrypted and then executed.\nThis payload uses new evasion techniques that were not seen in the loader, and it has some\nunique indicators that will lead us to the git repository used by the developers to generate\ntheir malware.\n\n[We collected reports published by cryptolaemus from July 17, the beginning of the currentth](https://paste.cryptolaemus.com/)\nwave, until September 3 . Based on this information 444,000 unique Emotet loaders wererd\ngenerated, with the peak occurring at the end of August.\n\n\nIn this blog post, the writer investigates the payload that was encrypted inside the loader,\nanalyzes the next steps in the infection process, and discovers the techniques used to make\nthis malware difficult to analyze.\n\n## The Shellcode\n\n\n-----\n\nIn the last step in the execution of the malware, a memory buffer was allocated, and the\ndecrypted payload was copied there. The payload consists of a shellcode followed by a PE\nfile, and an overlay containing the string “dave”. The shellcode performs reflective loading on\nthe PE file by executing the following steps:\n\n1. Read the PEB structure in order to locate the APIs necessary for its functionality such\n\nas LoadLibrary, VirtualAlloc, VirtualProtect, and more\n2. Allocate a memory buffer according to the value of SizeOfImage in the optional header\n3. Copy the image headers\n4. Copy the image sections and change the memory protection according to the section\n\ncharacteristics\n5. Retrieve the correct addresses of the functions listed in the IAT\n6. Perform relocations according to the relocations table\n7. Jump to the entry point\n8. Search a function whose name can be converted to the hash 0x30627745 and call it\n\nwith the string “dave” from the overlay\n\nThis shellcode utilizes a malicious technique that loads the PE file in a way that makes it\nmore difficult to detect using memory forensics. It replaces the DOS header with zeroes in\norder to remove strings such as “MZ” and “This program cannot be run in DOS mode”.\nThese strings can be used to detect PE files that were injected into memory.\n\nMemory comparison: on the left is the PE file after it is loaded by the shellcode and on the\nright is how it should look.\n\nThere were a few unusual things about this shellcode:\n\n1. The shellcode searched the export table of the file for a function to call although it Isn’t\n\na DLL and it contains no exports.\n2. The string “dave” seemed out of place and meaningless.\n\n\n-----\n\n3. The hashing algorithm found is common among shellcodes and the hashes of the\n\nWinAPI used by the code can be found in online repositories, but the hash of the\nexported function (0x30627745) didn’t appear there.\n\n[Searching these indicators led to the git repository, which contains the source code for this](https://github.com/cryzlasm/sRDI-1)\nshellcode. We found out that by default the shellcode searches for an export named\n“SayHello” in the file it loads and “dave” is a parameter that is sent to this function. The\nEmotet group didn’t change the default parameters in the script and that IOC led to the\nsource code.\n\nNow that we know how the shellcode operates, we can move on to the PE file that was\nloaded, which is the final payload of the loader.\n\n## The Final Payload\n\nRemoving the shellcode and the overlay string from the data that was extracted from the\nloader resulted in this PE file:\n\nD59853E61B8AD55C37FBA7D822701064A1F9CFAF609EE154EF0A56336ABA07C1\n\nCompared to the loader, which was disguised as a benign file, this file has clear malicious\nindicators:\n\n1. Code obfuscation – The malware’s developers used a complicated switch case to\n\nmake the flow of code difficult to understand. It contains many unnecessary jump\ninstructions that make the debugging process longer.\n\n\n-----\n\nGraph overview of the main function generated using IDA, showing the code obfuscation.\n\n1. No strings – After performing static analysis on the sample, no meaningful strings were\n\nfound. This is because the malware contains encrypted strings and decrypts them only\nwhen they are used. When debugging the sample interesting strings were found such\nas registry keys used for persistence and format strings used for HTTP requests.\n2. Avoid suspicious calls – Some API calls are known to be monitored by security\n\nproducts since many malware strains abuse them. The malware needs to know if it\nruns with admin privileges in order to determine how deep inside the system it can\n[install itself. Instead of using the simple API for it (IsUserAnAdmin), it tries to gain a](https://docs.microsoft.com/en-us/windows/win32/api/shlobj_core/nf-shlobj_core-isuseranadmin)\nhandle with full access rights to the service control manager, which is only accessible\nwith admin rights. This method is less suspicious and might help the malware avoid\ncertain heuristic detections used by security products.\n3. Empty import table – The malware hides its functionality and intents by not listing any\n\nAPI functions in its IAT. This way static analysis will not help us determine the malware\ncapabilities and behavior. Instead, the malware retrieves WinAPI addresses\ndynamically.\n\n\n-----\n\nMuch like the shellcode previously discussed, it reads the PEB structure, but it also uses a\nunique hashing algorithm so standard hash dictionaries for WinAPI won’t help to convert the\nhashes the code uses back to strings. In order to make the code easier to understand we’ll\nhave to create our own dictionary.\n\nWhen looking at the disassembly, the hashing algorithm looks complicated, but it contains a\nlot of mathematical operations that cancel each other out. Using IDA pseudo-code utility, we\ncan convert it to a simple C code. This code was used to create a dictionary with hashes of\nmany DLL files and API names. We wrote a script that uses IDAPython in order to add the\nname of the dll files and APIs next to the hashes in the code.\n```\n<span style=\"color: #0000ff;\">import</span> idautils\n<span style=\"color: #0000ff;\">import</span> json\nhashes_dict = json.load(<span style=\"color: #0000ff;\">open</span>(<span style=\"color:\n#993366;\">\"emotet_hashes.json\"</span>, <span style=\"color: #993366;\">'r'</span>))\ndlls_set = <span style=\"color: #33cccc;\">set</span>()\napis_set = <span style=\"color: #33cccc;\">set</span>()\n<span style=\"color: #0000ff;\">for</span> func in idautils.Functions():\n  flags = idc.get_func_attr(func, FUNCATTR_FLAGS)\n  <span style=\"color: #339966;\"># skip library & thunk functions</span>\n  <span style=\"color: #0000ff;\">if</span> flags & FUNC_LIB or flags & FUNC_THUNK:\n    <span style=\"color: #0000ff;\">continue</span>\n  dism_addr = <span style=\"color: #33cccc;\">list</span>(idautils.FuncItems(func))\n  <span style=\"color: #0000ff;\">for</span> ea in dism_addr:\n    <span style=\"color: #0000ff;\">if</span> idc.print_insn_mnem(ea) == <span\nstyle=\"color: #993366;\">\"mov\"</span>:\n      register = idc.print_operand(ea, 0)\n      value = idc.print_operand(ea, 1)\n      <span style=\"color: #339966;\"> # ecx contains the hash respresenting the\ndll</span>\n      <span style=\"color: #0000ff;\">if</span> register == <span style=\"color:\n#993366;\">'ecx'</span>:\n        <span style=\"color: #0000ff;\">if</span> value in hashes_dict[<span\nstyle=\"color: #993366;\">\"dlls\"</span>]:\n          dll_name = hashes_dict[<span style=\"color: #993366;\">\"dlls\"\n</span>][value]\n          dlls_set.add(dll_name)\n          idc.set_cmt(ea, dll_name, 0)\n      <span style=\"color: #339966;\"># edx contains the hash respresenting the\nAPI</span>\n      <span style=\"color: #0000ff;\">elif</span> register == <span style=\"color:\n#993366;\">\"edx\"</span>:\n        <span style=\"color: #0000ff;\">if</span> value in hashes_dict[<span\nstyle=\"color: #993366;\">\"apis\"</span>]:\n          api = hashes_dict[<span style=\"color: #993366;\">\"apis\"</span>]\n[value]\n          apis_set.add(api)\n          idc.set_cmt(ea, api, 0)\n<span style=\"color: #0000ff;\">print</span>(f<span style=\"color: #993366;\">\"\n{len(dlls_set)} DLLs and {len(apis_set)} APIs were found\"</span>)\n\n```\n\n-----\n\n```\n<span style font size: 8pt; >IDAPython script that adds the hidden imports to the\ncode</span>\n\n```\nThe purpose of this malware is to send information to the C2 servers about the infected\nsystem and receive commands as well as other files to execute. The file contains a list of IP\naddresses that are iterated over until a response is received from one of the servers.\n\nThe malware collects information such as the computer name and running processes,\nencrypts the data using AES, and sends it over HTTP. The server sends back malware such\nas ransomware and info stealers that are executed on the infected system.\n\n## Summary\n\nIn this blog post, we analyzed the next steps in the execution of the Emotet malware. We\ndiscovered that the attackers used a publicly accessible shellcode generator, which\ncontained unique indicators. Next, we looked at the final payload of the loader that was\nresponsible for communicating with the C2 servers and downloading additional files.\nAlthough much effort was put into making the code hard to understand, we showed how to\nmake it decipherable. By observing the entire infection process done by the Emotet malware,\nwe can see how this botnet achieves going undetected for such long periods.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-10-12 - Why Emotet’s Latest Wave is Harder to Catch Than Ever Before – Part 2.pdf"
    ],
    "report_names": [
        "2020-10-12 - Why Emotet’s Latest Wave is Harder to Catch Than Ever Before – Part 2.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535548,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653788339,
    "ts_modification_date": 1653788339,
    "files": {
        "pdf": "https://archive.orkl.eu/c7fac5fa321ddeca9e155cfed034dd7e06c7e95b.pdf",
        "text": "https://archive.orkl.eu/c7fac5fa321ddeca9e155cfed034dd7e06c7e95b.txt",
        "img": "https://archive.orkl.eu/c7fac5fa321ddeca9e155cfed034dd7e06c7e95b.jpg"
    }
}