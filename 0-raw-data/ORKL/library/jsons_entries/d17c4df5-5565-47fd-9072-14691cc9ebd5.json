{
    "id": "d17c4df5-5565-47fd-9072-14691cc9ebd5",
    "created_at": "2023-01-12T15:00:29.99484Z",
    "updated_at": "2025-03-27T02:05:22.372177Z",
    "deleted_at": null,
    "sha1_hash": "6489434b2dd7a6b7d2e83b9549311add4dac0bcb",
    "title": "2020-08-05 - Playing with GuLoader Anti-VM techniques",
    "authors": "",
    "file_creation_date": "2022-05-28T18:57:44Z",
    "file_modification_date": "2022-05-28T18:57:44Z",
    "file_size": 319881,
    "plain_text": "# Playing with GuLoader Anti-VM techniques\n\n**[blueliv.com/cyber-security-and-cyber-threat-intelligence-blog-blueliv/research/playing-with-guloader-anti-vm-techniques-malware/](https://www.blueliv.com/cyber-security-and-cyber-threat-intelligence-blog-blueliv/research/playing-with-guloader-anti-vm-techniques-malware/)**\n\nPlaying with GuLoader Anti-VM techniques\n\n05.Aug.2020\n\nCarlos Rubio and supported by the Blueliv Labs team\n\n[Threat Intelligence](https://www.blueliv.com/blog?tags=335)\n\n\n-----\n\nGuLoader\n\n\nGuLoader is one of the most widely used loaders to distribute malware throughout 2020. Among the malware families distributed by GuLoader,\nwe can find FormBook, [AgentTesla and other commodity malware. A recent research performed by Check Point suggests that GuLoader code](https://research.checkpoint.com/2020/guloader-cloudeye/)\nis almost identical to a loader named as CloudEye and sold “legitimately” as a protection mechanism for binaries. At Blueliv we have been\nkeeping track of it and have observed that some of the methods it uses to detect virtual machine execution and hook detection, although not\nnew, are still quite effective, as we have seen that in several online sandboxes this loader does not run correctly. Our own sandbox was\ndetected by GuLoader, but it is correctly handled now, executing this malware family without problems. In this blogpost, we will explain the\ntechniques that this loader uses to thwart the analysts and their virtual machines/sandboxes, offering an application to check if a sandbox is\ndetected by this technique or not.\n\n\n-----\n\n## Anti Analysis & Anti VM techniques\n\nGuLoader uses the following techniques to make analysis tasks more difficult and to detect if it is running in a virtual machine:\n\n[Using ZwQueryVirtualMemory to locate pages containing vm-related strings.](https://blog.vincss.net/2020/05/re014-guloader-antivm-techniques.html)\nEnumeration of windows (EnumWindows)\nHooking ntdll_DbgBreakPoint and ntdll_DbgUiRemoteBreakin\nChecking breakpoints\nHiding the thread (NtSetInformationThread with 0x11)\nChecking the existence of `C:\\Program Files\\Qemu-ga\\qemu-ga.exe and` `C:\\Program Files\\qga\\qga.exe`\n```\n   RDTSC Virtual machine detection\n\n```\nHook detection\n\nDue to the fact that many of these techniques have been documented, we will focus on the following ones throughout this article:\n\nHook detection\nRDTSC Virtual machine detection\n\n### Sandbox hook detection\n\nGuLoader uses the following code fragment to detect if it’s running in a sandbox with hooks installed.\n\n_ANTI_HOOK\n\nfnop\n\npop ebx\n\ncld\n\ncmp dword ptr [ebx], 0\n\njnz short _jmp_copied_NtAllocateVirtualMemory\n\nclc\n\nxor ecx, ecx\n\n_copy:\n\nclc\n\npush dword ptr [eax+ecx]\n\npop dword ptr [ebx+ecx]\n\nadd ecx, 4\n\ncmp ecx, 18h\n\njnz short _copy\n\ncld\n\n_jmp_copied_NtAllocateVirtualMemory:\n\nfnop\n\njmp ebx\n\n_ANTI_HOOK\n\nWith the push `dword ptr [eax+ecx] and` `pop dword ptr [ebx+ecx] the NtAllocateVirtualMemory function is copied till` `retn 0x18 :`\nntdll_NtAllocateVirtualMemory\n\narg_0= byte ptr 4\n\nmov eax, 15h\n\nxor ecx, ecx\n\n\n-----\n\nea ed, [esp a g_0]\n\ncall large dword ptr fs:0C0h\n\nadd esp, 4\n\nretn 18h\n\nThen it jumps to the code where it has copied the function, using `jmp ebx and executes it. If it is running in an environment without hooks,`\nthe function will be executed correctly. But in the case that there is a hook in the function and this hook makes a relative jump, for example with\nopcode E9 (such as those performed by the cuckoo monitor), when the function that has been copied to another position is executed, it will\njump to an unknown position and an exception will occur, causing an abrupt termination of the program.\n\n### RDTSC Virtual machine detection\n\nEven though this technique is widely known, the interesting thing is the way that it has been implemented. GuLoader uses the following\nalgorithm to detect if it is inside a virtual machine:\n_VM_DETECT proc near\n\ncld\n\n_VM_DETECT_START:\n\nfnop\n\nxor edi, edi\n\nnop\n\nmov ecx, 186A0h\n\ncld\n\nnop\n\n_VM_DETECT_CONTINUE:\n\npush ecx\n\ncall _RDTSC_OPS\n\npop ecx\n\ncmp edx, 32h\n\njl short _VM_DETECT_CONTINUE\n\nadd edi, edx\n\ndec ecx\n\ncmp ecx, 0\n\njnz short _VM_DETECT_CONTINUE\n\ncmp edi, 0\n\njl short _VM_DETECT_START\n\ncmp edi, 68E7780h\n\njge short _VM_DETECT_START\n\nmov eax, edi\n\nretn\n\n_VM_DETECT endp\n\n1. The value `0x186A0 is stored in` `ECX . This value indicates the number of times` `EDI will be incremented with the result of the`\n```\n_RDTSC_OPS function as long as the result of the operation is greater than 0x 32 . 2. After that it will perform a call to the _RDTSC_OPS\n\n```\nfunction, explained later in detail. For now, it is only necessary to know that this function will return a value higher than 0. 3. Then it checks if\nth l i hi h th 0 32 If th t’ th it dd th lt i th i t d d th l Oth i it t t\n\n\n-----\n\n`_` `_` `C _CO` `U` to ca `_` `SC_O S aga` s a ote, t e a ue etu ed by _ `SC_O S at t s po t s g eate t a` 0 but ess\nthan 0x32 continuously, the program will remain in an infinite loop. 4. This will be done until `ECX is 0, so the result of the function will be`\nadded to the `EDI value with the` `add edi, edx operation` `0x186A0 times. 5. Finally, it will check if the result of those increments is greater`\nor equal to `0x68E7780 . The result must be lower to pass the virtual machine check. If not, the execution will return to` `_VM_DETECT_START . It`\nis important to highlight that in a virtual machine without any modification or hook over `RDTSC this is the point where the program will remain`\nrunning in an infinite loop. Basically, the malware developer estimated that the addition of values returned by the execution of the function\n```\n_RDTSC_OPS 0x186A0 times within a virtualized environment will result in a value above 0x68E7780 due to the overhead generated by the\n_RDTSC_OPS function. If the value of RDTSC has been artificially lowered below 0x32 to attempt to bypass similar techniques, the analysis\n\n```\nwill be stuck in this Anti-VM check forever.\n\n**__RDTSC_OPS function_**\n\nGuLoader uses the following algorithm to obtain the execution times between two `RDTSC calls, after a` `CPUID EAX=1 as shown below:`\n_RDTSC_OPS\n\nlfence\n\nrdtsc\n\nlfence\n\nshl edx, 20h\n\nor edx, eax\n\nmov esi, edx\n\npusha\n\nmov eax, 1\n\ncpuid\n\nbt ecx, 1Fh\n\njb short $+2\n\npopa\n\nlfence\n\nrdtsc\n\nlfence\n\nshl edx, 20h\n\nor edx, eax\n\nsub edx, esi\n\ncmp edx, 0\n\njle short _RDTSC_OPS\n\nretn\n\n_RDTSC_OPS\n\nThe algorithm performs the following operations:\n\n1. First obtains the elapsed time in `EAX (low-part) and` `EDX (high-part) through` `RDTSC .`\n\n2. Performs an `OR operation between the high and the low part, and saves the result in` `ESI .`\n\n3. It makes the call to `CPUID with` `EAX=1 and then, thanks to the` `bt ecx, 1Fh instruction, it checks if it is running in a virtual machine.`\nHowever, the result of the operation is not relevant, because the call to `CPUID is made with the intention of generating a VM-Exit causing that`\nthe hypervisor passes the execution to the Virtual Machine Manager. This allows to differentiate if it is running in a virtual machine, because\nthe call takes more time than in a physical machine.\n\n4. Makes a call to `RDTSC and get again the time that has been spent in` `EAX (low-part) and` `EDX (high-part).`\n\n\n-----\n\n5 e o s a `O` ope at o bet ee t e g a d o pa ts, a d subt acts t e p e ous esu t sto ed `S`\n\n6. If the result is greater than 0, as would be expected in normal execution, the function will return the result in `EDX, otherwise it will return to`\nthe start of the function. It is important to highlight that it is possible that in some sandboxes the sample will be locked in an infinite loop at this\npoint., depending on the way the sandbox deals with the detection problem by `RDTSC .`\n\n**_Implementation changes in some GuLoader versions_**\n\nWe also found some differences between different GuLoader samples, particularly in the functions responsible for performing the virtual\nmachine check.\n\n**Sample** **SHA256**\n\n**GuLoader Blueliv Article** 25018a8ff2a535ed05ebe8a1d2158a79dbeb53fc0be67d4e788bc936cb551b6d\n\n**GuLoader Checkpoint Shellcode** 295cb5b21bafcafa8d770d5ce325893340037c8efe545691b8289aff82315539\n\n**CloudEyE Checkpoint Shellcode** 3ca3f172d222d5f52be734079658e2a141d92e15c8edd4ea7515a72cf03a28a3\n\n[Comparing the sample that we used to write the article with the different shellcodes that can be found in the following Check Point article, it is](https://research.checkpoint.com/2020/guloader-cloudeye/)\npossible to see how the `_VM_DETECT function has gone through some modifications.`\n\n_Comparison of the _VM_DETECT function in different samples_\n\nThe function on the left corresponds to the sample that we have analyzed throughout the article and the function on the right corresponds to\nthe shellcodes mentioned in Check Point’s article. We can see that the function on the left adds a check after calling `_RDTSC_OPS where it`\nchecks if the value is less than `0x32 . As mentioned previously, this new check may be due to the fact that there are sandboxes that after the`\ncall to the `_RDTSC_OPS function return values in` `EDX below the normal. So GuLoader can avoid to be fully executed in those sandboxes`\nwhere it will stay in an infinite loop at this point. We can also see that the value compared in `EDI in the function on the left is` `0x68E7780,`\nwhich is greater than `0x66FF300 (function on the right). It is possible that the variation of this value is due to the fact that there are non-`\nvirtualized machines whose value after these operations is above `0x66FF300 and in some update they have had to increase the value up to`\n```\n0x68E7780, although this is just an assumption.\n\n```\n**_Blueliv Anti-VM detection tool_**\n\n\n-----\n\ns tec que as qu te te est g to us because so e o t e e ste t sa dbo es e e ot dea g t t e ssue at s y e t oug t t\nwas a good idea to create a tool to help to detect the problem. This tool permits to know if a sandbox is detected by the technique described\nabove (the most restrictive version). You can find [this tool in our repository. If anyone is interested in discussing these technique or taking a](https://github.com/Blueliv/guloader-antivm-detection)\nlook at the source code in order to fix the problem in a sandbox, be free to reach to us. The tool has been created from the code of the\nGuLoader sample without modifications, to avoid modifying its behavior. If the sandbox is detected, it displays by console the `EDI value after`\nthe `0x186A0 loop have been completed.`\n\n>However, if the sandbox is not detected, a message appears on the screen indicating that it does not detect the sandbox.\n\nIf the tool does not display any value, there are two possibilities:\n\nThe result of the operation between the `RDTSCs is less than or equal to 0.`\n\nThe result returned by the `_RDTSC_OPS function is less than 0x32.`\n\nIn both cases the execution would stay in an infinite loop. It is recommended to analyze the application step by step to find the problem. We\nhave conducted some tests using the article’s sample in several well-known public sandboxes and have found that the sample does not run\ncorrectly in most of them. In those that allow access to the API log it is possible to see that the last logged API calls are:\n\n**NtCreateFile of** `C:\\Program Files\\Qemu-ga\\qemu-ga.exe`\n**NtCreateFile of** `C:\\Program Files\\qga\\qga.exe`\n\nThis is because the `RDTSC and anti-hook checks are performed after those calls, and may be avoiding the correct execution of the sample.`\nWe hope our tool can help to fix those problems.\n\n**_Blueliv sandbox execution graph_**\n\nWe can see below the execution graph generated by the Blueliv **sandbox, using our kernel monitor, during the execution of this sample**\n( 25018a8ff2a535ed05ebe8a1d2158a79dbeb53fc0be67d4e788bc936cb551b6d ):\n\n\n-----\n\nAs explained in this article, during the execution of the sample it performs several anti-virtual machine and anti-hook checks in order to thwart\nthe analysis, but our sandbox was able to bypass them and continue with the execution flow. When executed it runs twice ( liTK.exe ), then\nthe GuLoader sample creates persistence and changes its name to host.exe and finally downloads from Microsoft OneDrive the final payload.\n**The final payload could not be retrieved if the sandbox would not correctly bypass the mentioned anti-vm techniques.**\n\n## Conclusions\n\nCybercriminals and malware authors are always evolving, modifying their tools and using techniques to evade virtual machines and difficult the\nanalysis of the samples. GuLoader is a clear example of this, a really active loader which makes use of some modifications of well-known\n[techniques like the RDTSC check to go further in the detection of sandboxes. The tool we providewill help to confirm if GuLoader is able to](https://github.com/Blueliv/guloader-antivm-detection)\ndetect a sandbox and we hope that the affected online sandboxes can benefit from it and fix this problem. Keeping a sandbox in a good shape\nand with all the latest anti-vm techniques under control is crucial to be able to detonate samples and artifacts, and bypass packers and\nobfuscation layers. At Blueliv we know that and we investigate and fix all the problems that we detect so the number of extracted IOCs and\nour malware classification keeps having a good quality. This is especially important for our internal investigations, for our customers and for our\n**[Threat Exchange Network, where our sandbox can be used free of charge.  This blog post was authored by Carlos Rubio and](https://community.blueliv.com/#!/discover)**\n**_supported by the Blueliv Labs team._**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-08-05 - Playing with GuLoader Anti-VM techniques.pdf"
    ],
    "report_names": [
        "2020-08-05 - Playing with GuLoader Anti-VM techniques.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535629,
    "ts_updated_at": 1743041122,
    "ts_creation_date": 1653764264,
    "ts_modification_date": 1653764264,
    "files": {
        "pdf": "https://archive.orkl.eu/6489434b2dd7a6b7d2e83b9549311add4dac0bcb.pdf",
        "text": "https://archive.orkl.eu/6489434b2dd7a6b7d2e83b9549311add4dac0bcb.txt",
        "img": "https://archive.orkl.eu/6489434b2dd7a6b7d2e83b9549311add4dac0bcb.jpg"
    }
}