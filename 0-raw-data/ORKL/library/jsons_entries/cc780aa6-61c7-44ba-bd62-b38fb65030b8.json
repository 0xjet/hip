{
    "id": "cc780aa6-61c7-44ba-bd62-b38fb65030b8",
    "created_at": "2022-10-25T16:48:23.980269Z",
    "updated_at": "2025-03-27T02:06:11.875645Z",
    "deleted_at": null,
    "sha1_hash": "21e5175d1dd3c2c2b628898401956c7bf5bde38c",
    "title": "Teaching an old RAT new tricks",
    "authors": "",
    "file_creation_date": "2016-04-22T18:40:12Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 2497867,
    "plain_text": "## s s\n\n# d w r s\n\n**s** **d** **r** **21 2016** **Joseph Landry**\n\n\n**u** **r**\n\n**r** **rs**\n\n**s ur** **s**\n\n\n**Attackers have been successfully deploying RATs for years to remotely control users systems - giving**\n**them full access to the victim’s files or resources such as cameras, recording key strokes, or�**\n**downloading further malware. Traditionally RATs have been deployed when a user opens an email**\n**attachment, or downloads a file from a website or peer-to-peer network. In both cases, these vectors�**\n**involve use of files to deliver the payload - which are easier to detect.�**\n\n**Recently we detected a more sophisticated technique that a handful of countries across Asia are**\n**actively using to infect systems with RATs. This new technique ensures that the payload/file remains in�**\n**memory through its execution, never touching the disk in a de-encrypted state. In doing so, the**\n**attacker can remain out of view from antivirus technologies, and even ‘next-generation’ technologies**\n**that only focus on file-based threat vectors. Also, the samples analyzed have the ability detect the�**\n**presence of a virtual machine to ensure it’s not being analyzed in a network sandbox.**\n\n**And finally it’s important to highlight that the RAT itself is not new. In fact this technique can be used to�**\n**deliver any “known” RAT to a victim’s system. We analyzed this sample against our SentinelOne EPP**\n**to confirm is does not evade our behavior-based detection mechanisms. This is due to the fact that�**\n**we’re monitoring all processes at the user-space/kernel-space interface - and because all**\n**communication between the application and the kernel must be unencrypted, we detect the sample at**\n**both process injection points**\n\n\n-----\n\n**Samples Analyzed**\n\n**Main Sample**\n\n**r** **32** **E NE** **2 0**\n\n**H** **256 su**\n\n**9551 15319 068** **966 8 9 563 522 d9 1** **2d19 122** **8 018 8**\n\n**H** **1 su** **3 1** **5 3509281 d 0 61 1 8** **6 d3** **393 55**\n\n**5 su** **65 52** **2d6 3d121** **826** **65d 9**\n\n**s z** **32102** **s 32**\n\n**Unpacked Samples**\n\n**◦  e5c71180f117270538487cd9b9b1b6d8 - Packed \"Benchmark\" DLL ▪**\n**9e05fb115bd4e85cfc0e32c72aa721be - Monitor (PerfWatson.exe) ◦**\n**d740ed3f33ca4cef3a6aa717f94bf52a - NanoCore RAT dumped from memory**\n\n**Behavioral Analysis**\n\n**When run, the binary will copy itself to**\n**%APPDATA%\\Microsoft\\Blend\\14.0\\FeedCache\\nvSCPAPISrv.exe and extracts a second binary**\n**named PerfWatson.exe**\n\n**It then executes both binaries.**\n\n**For persistence, a registry key is created at HKEY_CURRENT_USER\\Software\\Microsoft\\Windows**\n\n\n-----\n\n**Finally, the RAT tries connecting back to its control server:**\n\n**z** **2015** **r** **161**\n\n**z** **r** **161**\n\n**chickenkiller.com is owned by a free dynamic DNS service.**\n\n**At the time of this writing, the DNS records still exist, but the address they resolve to appears to be**\n**down.**\n\n**Unpacking**\n\n**\"Benchmark\" .NET DLL**\n\n**The main executable contains an XOR encrypted .NET DLL in its .NET managed resources and the**\n**logic to unpack it. This DLL contains the logic to unpack and inject the RAT as well as monitor the**\n**application, PerfWatson.exe. This DLL is referred to as \"Benchmark\" because that is the .NET**\n**namespace it uses.**\n\n**After decrypting the resource, it is linked into the process using**\n**[System.Reflection.Assembly.Load(byte[]). This method is documented on �MSDN here. Using this](https://msdn.microsoft.com/en-us/library/h538bck7%28v=vs.110%29.aspx)**\n**method, the DLL will never be written to the filesystem. This technique could have been chosen by the�**\n**developers to evade antivirus detection.**\n\n\n-----\n\n**Under the hood, Assembly.Load(), uses a call to the win32 api call CreateFileMappingW() with the hFile**\n**parameter set to INVALID_HANDLE_VALUE. According to MSDN, this will create a mapped file that is�**\n**backed by the paging filesystem, not the standard filesystem. A layer below CreateFileMapping, the�**\n**system call NtCreateSection is invoked.**\n\n**After the empty file is created, it is mapped into memory using the Win32 API call MapViewOfFileEx.�**\n**The layer below this invokes the system call NtMapViewOfSection.**\n\n**Now, a call to memcpy() is used to copy the decrypted DLL into the newly allocated address range.**\n\n\n-----\n\n**Unpacking Settings and NanoCore**\n\n**The settings for \"Benchmark\" and the NanoCore executable are serialized, DES encrypted, spliced,**\n**and stored across multiple PNG files as pixel data. The PNG files are concatenated and stored in the�**\n**.NET managed resources of the main executable.**\n\n**Some of the settings that can be configured are:�**\n\n**E** **r u** **s d** **d**\n\n**s** **d** **s** **s** **r** **r** **s** **d N** **r**\n\n**s** **ss** **us r**\n\n**Id** **r** **r** **r** **s r** **N**\n\n**w** **d** **r** **d** **r** **I** **r** **d** **r** **d ru**\n\n**r** **I** **d** **r** **ss**\n\n**After viewing one of these images, it is obvious they are not used to conveying visual information to a**\n**human eye.**\n\n\n-----\n\n**After writing a short python script, I was able to extract all 19 PNG files. If you have robot eyes, you can�**\n**see a cat.**\n\n**Here is a C# decompilation of the method used to extract the information out of the pixel data.**\n\n\n-----\n\n**Once everything is decrypted, the set options are executed, and the NanoCore RAT payload is injected**\n**into a new child process. The method of injection is discussed later.**\n\n**Unpacking PerfWatson.exe**\n\n**Now that \"Benchmark\" is loaded into memory, it is tasked with copying the main executable and**\n**extracting PerfWatson.exe to %APPDATA%\\\\Microsoft\\Blend\\14.0\\FeedCache\\.**\n\n**PerfWatson.exe is stored inside Benchmark as a base64 encoded string. There is no encryption or**\n**obfuscation outside of the base64 encoding.**\n\n**Inside the .NET assembly, the string is stored as a DefaultSettingValue string. The developers might**\n**have used this as a way to conceal the meaning of this long string.**\n\n**Once the string is decoded it is written to disk and executed**\n\n\n-----\n\n**Injecting the Payload**\n\n**The NanoCore RAT payload is never written to disk to avoid detection. Instead, it is injected into a new**\n**process. The injection routine can be summarized by these Win32 API and system calls:**\n\n**r** **r** **ss** **E** **E** **EN** **r** **d** **r** **ss** **sus** **d** **d**\n\n**N** **r** **d** **s d** **d** **E** **d** **u d** **EI** **r** **s** **r**\n\n**d r** **ss** **r** **ds** **E** **I** **s** **ddr ss** **d**\n\n**N** **w** **s ru s** **w** **r** **s** **r** **d** **d**\n\n**0** **00000**\n\n**r u** **E** **s d** **s** **r**\n\n**N** **r** **r u** **r**\n\n**0 00 00000** **E H** **d r**\n\n**0 00 02000**\n\n**0 00 36000** **rsr**\n\n**0 00 3 000** **r**\n\n**E** **I** **s** **ddr ss** **d** **s** **s** **ddr ss** **0** **00000**\n\n**N** **r** **d** **d** **s** **EI** **r** **s** **r** **r** **d**\n\n**N** **r** **su** **r** **d** **us s** **d** **r** **ss** **sus** **d** **d** **d**\n\n**ru** **r** **ss** **s** **sus** **d** **d**\n\n**N** **r** **d** **s r** **d r** **d** **r** **ss**\n\n\n-----\n\n**r** **r** **d** **ddr ss** **E** **s** **w** **w** **d s** **r** **d**\n\n**ddr ss r** **r** **d** **s** **w** **d**\n\n\n-----\n\n**d** **w** **s r** **s** **N** **r** **r u** **r** **d u d**\n\n**E** **I** **s** **ddr ss**\n\n**N** **r** **d s** **d** **u d** **EI** **r** **s** **r s** **u**\n\n\n-----\n\n**u** **s s** **r** **d w** **N** **r** **su** **r** **d**\n\n**du** **r** **ss** **d s** **w** **s** **d** **r** **ss s us** **N** **r**\n\n\n-----\n\n**For more information on how SentinelOne protects against attacks such as these, visit our resources**\n**[page at sentinelone.com/resources](https://www.sentinelone.com/resources)**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2016/2016.04.21.Teaching_an_old_RAT_new_tricks/teaching-an-old-rat-new-tricks.pdf"
    ],
    "report_names": [
        "teaching-an-old-rat-new-tricks"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716503,
    "ts_updated_at": 1743041171,
    "ts_creation_date": 1461350412,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/21e5175d1dd3c2c2b628898401956c7bf5bde38c.pdf",
        "text": "https://archive.orkl.eu/21e5175d1dd3c2c2b628898401956c7bf5bde38c.txt",
        "img": "https://archive.orkl.eu/21e5175d1dd3c2c2b628898401956c7bf5bde38c.jpg"
    }
}