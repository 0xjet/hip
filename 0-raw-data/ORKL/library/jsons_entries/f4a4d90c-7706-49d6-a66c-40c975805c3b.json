{
    "id": "f4a4d90c-7706-49d6-a66c-40c975805c3b",
    "created_at": "2023-01-12T15:08:07.643633Z",
    "updated_at": "2025-03-27T02:16:26.584883Z",
    "deleted_at": null,
    "sha1_hash": "19485f2aebf81b02fe749cee9af6dc28f80a3398",
    "title": "2020-12-15 - A deep dive into an NSO zero-click iMessage exploit- Remote Code Execution",
    "authors": "",
    "file_creation_date": "2022-05-27T21:28:15Z",
    "file_modification_date": "2022-05-27T21:28:15Z",
    "file_size": 543254,
    "plain_text": "# A deep dive into an NSO zero-click iMessage exploit: Remote Code Execution\n\n**[googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html](https://googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html)**\n\nPosted by Ian Beer & Samuel Groß of Google Project Zero\n\nWe want to thank Citizen Lab for sharing a sample of the FORCEDENTRY exploit with us,\nand Apple’s Security Engineering and Architecture (SEAR) group for collaborating with us on\nthe technical analysis. The editorial opinions reflected below are solely Project Zero’s and do\nnot necessarily reflect those of the organizations we collaborated with during this research.\n\nEarlier this year, Citizen Lab managed to capture an NSO iMessage-based zero-click exploit\nbeing used to target a Saudi activist. In this two-part blog post series we will describe for the\nfirst time how an in-the-wild zero-click iMessage exploit works.\n\nBased on our research and findings, we assess this to be one of the most technically\nsophisticated exploits we've ever seen, further demonstrating that the capabilities NSO\nprovides rival those previously thought to be accessible to only a handful of nation states.\n\n[The vulnerability discussed in this blog post was fixed on September 13, 2021 in iOS 14.8 as](https://support.apple.com/en-us/HT212807)\nCVE-2021-30860.\n\nNSO\n\n[NSO Group is one of the](https://en.wikipedia.org/wiki/NSO_Group) [highest-profile providers of \"access-as-a-service\", selling packaged](https://www.atlanticcouncil.org/in-depth-research-reports/report/countering-cyber-proliferation-zeroing-in-on-access-as-a-service/)\nhacking solutions which enable nation state actors without a home-grown offensive cyber\ncapability to \"pay-to-play\", vastly expanding the number of nations with such cyber\ncapabilities.\n\nFor years, groups like Citizen Lab and Amnesty International have been tracking the use of\nNSO's mobile spyware package \"Pegasus\". Despite NSO's claims that they \"[evaluate] the\npotential for adverse human rights impacts arising from the misuse of NSO products\"\nPegasus has been linked to the hacking of the New York Times journalist Ben Hubbard by\nthe Saudi regime, [hacking of human rights defenders in Morocco and](https://www.amnesty.org/en/latest/research/2019/10/morocco-human-rights-defenders-targeted-with-nso-groups-spyware/) [Bahrain,](https://citizenlab.ca/2021/08/bahrain-hacks-activists-with-nso-group-zero-click-iphone-exploits/) the targeting\nof Amnesty International staff and dozens of other cases.\n\nLast month the United States added NSO to the \"Entity List\", severely restricting the ability of\n[US companies to do business with NSO and stating in a press release that \"[NSO's tools]](https://www.commerce.gov/news/press-releases/2021/11/commerce-adds-nso-group-and-other-foreign-companies-entity-list)\nenabled foreign governments to conduct transnational repression, which is the practice of\nauthoritarian governments targeting dissidents, journalists and activists outside of their\nsovereign borders to silence dissent.\"\n\n\n-----\n\nCitizen Lab was able to recover these Pegasus exploits from an iPhone and therefore this\nanalysis covers NSO's capabilities against iPhone. We are aware that NSO sells similar\nzero-click capabilities which target Android devices; Project Zero does not have samples of\nthese exploits but if you do, please reach out.\n\nFrom One to Zero\n\n[In previous cases such as the Million Dollar Dissident from 2016, targets were sent links in](https://citizenlab.ca/2016/08/million-dollar-dissident-iphone-zero-day-nso-group-uae/)\nSMS messages:\n\nScreenshots of Phishing SMSs reported to Citizen Lab in 2016\n\nsource: [https://citizenlab.ca/2016/08/million-dollar-dissident-iphone-zero-day-nso-group-uae/](https://citizenlab.ca/2016/08/million-dollar-dissident-iphone-zero-day-nso-group-uae/)\n\nThe target was only hacked when they clicked the link, a technique known as a one-click\nexploit. Recently, however, it has been documented that NSO is offering their clients zeroclick exploitation technology, where even very technically savvy targets who might not click a\nphishing link are completely unaware they are being targeted. In the zero-click scenario no\nuser interaction is required. Meaning, the attacker doesn't need to send phishing messages;\nthe exploit just works silently in the background. Short of not using a device, there is no way\nto prevent exploitation by a zero-click exploit; it's a weapon against which there is no\ndefense.\n\nOne weird trick\n\nThe initial entry point for Pegasus on iPhone is iMessage. This means that a victim can be\ntargeted just using their phone number or AppleID username.\n\n\n-----\n\niMessage has native support for GIF images, the typically small and low quality animated\nimages popular in meme culture. You can send and receive GIFs in iMessage chats and they\nshow up in the chat window. Apple wanted to make those GIFs loop endlessly rather than\n[only play once, so very early on in the iMessage parsing and processing pipeline (after a](https://googleprojectzero.blogspot.com/2021/01/a-look-at-imessage-in-ios-14.html)\nmessage has been received but well before the message is shown), iMessage calls the\nfollowing method in the IMTranscoderAgent process (outside the \"BlastDoor\" sandbox),\npassing any image file received with the extension .gif:\n\n[IMGIFUtils copyGifFromPath:toDestinationPath:error]\n\nLooking at the selector name, the intention here was probably to just copy the GIF file before\nediting the loop count field, but the semantics of this method are different. Under the hood it\nuses the CoreGraphics APIs to render the source image to a new GIF file at the destination\npath. And just because the source filename has to end in .gif, that doesn't mean it's really a\nGIF file.\n\nThe ImageIO library, [as detailed in a previous Project Zero blogpost, is used to guess the](https://googleprojectzero.blogspot.com/2020/04/fuzzing-imageio.html)\ncorrect format of the source file and parse it, completely ignoring the file extension. Using\nthis \"fake gif\" trick, over 20 image codecs are suddenly part of the iMessage zero-click attack\nsurface, including some very obscure and complex formats, remotely exposing probably\nhundreds of thousands of lines of code.\n\nNote: Apple inform us that they have restricted the available ImageIO formats reachable from\nIMTranscoderAgent starting in iOS 14.8.1 (26 October 2021), and completely removed the\nGIF code path from IMTranscoderAgent starting in iOS 15.0 (20 September 2021), with GIF\ndecoding taking place entirely within BlastDoor.\n\nA PDF in your GIF\n\nNSO uses the \"fake gif\" trick to target a vulnerability in the CoreGraphics PDF parser.\n\nPDF was a popular target for exploitation around a decade ago, due to its ubiquity and\ncomplexity. Plus, the availability of javascript inside PDFs made development of reliable\nexploits far easier. The CoreGraphics PDF parser doesn't seem to interpret javascript, but\nNSO managed to find something equally powerful inside the CoreGraphics PDF parser...\n\nExtreme compression\n\nIn the late 1990's, bandwidth and storage were much more scarce than they are now. It was\n[in that environment that the JBIG2 standard emerged. JBIG2 is a domain specific image](https://en.wikipedia.org/wiki/JBIG2)\ncodec designed to compress images where pixels can only be black or white.\n\nIt was developed to achieve extremely high compression ratios for scans of text documents\nand was implemented and used in high-end office scanner/printer devices like the XEROX\nWorkCenter device shown below. If you used the scan to pdf functionality of a device like this\n\n\n-----\n\na decade ago, your PDF likely had a JBIG2 stream in it.\n\nA Xerox WorkCentre 7500 series multifunction printer, which used JBIG2\n\nfor its scan-to-pdf functionality\n\nsource: https://www.office.xerox.com/en-us/multifunction-printers/workcentre-75457556/specifications\n\nThe PDFs files produced by those scanners were exceptionally small, perhaps only a few\nkilobytes. There are two novel techniques which JBIG2 uses to achieve these extreme\ncompression ratios which are relevant to this exploit:\n\nTechnique 1: Segmentation and substitution\n\n\n-----\n\nEffectively every text document, especially those written in languages with small alphabets\nlike English or German, consists of many repeated letters (also known as glyphs) on each\npage. JBIG2 tries to segment each page into glyphs then uses simple pattern matching to\nmatch up glyphs which look the same:\n\nSimple pattern matching can find all the shapes which look similar on a page,\n\nin this case all the 'e's\n\nJBIG2 doesn't actually know anything about glyphs and it isn't doing OCR (optical character\nrecognition.) A JBIG encoder is just looking for connected regions of pixels and grouping\nsimilar looking regions together. The compression algorithm is to simply substitute all\nsufficiently-similar looking regions with a copy of just one of them:\n\nReplacing all occurrences of similar glyphs with a copy of just one often yields a document\nwhich is still quite legible and enables very high compression ratios\n\nIn this case the output is perfectly readable but the amount of information to be stored is\nsignificantly reduced. Rather than needing to store all the original pixel information for the\nwhole page you only need a compressed version of the \"reference glyph\" for each character\nand the relative coordinates of all the places where copies should be made. The\ndecompression algorithm then treats the output page like a canvas and \"draws\" the exact\nsame glyph at all the stored locations.\n\n\n-----\n\nThere s a significant issue with such a scheme: it s far too easy for a poor encoder to\naccidentally swap similar looking characters, and this can happen with interesting\n[consequences. D. Kriesel's blog has some motivating examples where PDFs of scanned](http://www.dkriesel.com/en/blog/2013/0802_xerox-workcentres_are_switching_written_numbers_when_scanning)\ninvoices have different figures or PDFs of scanned construction drawings end up with\nincorrect measurements. These aren't the issues we're looking at, but they are one\nsignificant reason why JBIG2 is not a common compression format anymore.\n\nTechnique 2: Refinement coding\n\nAs mentioned above, the substitution based compression output is lossy. After a round of\ncompression and decompression the rendered output doesn't look exactly like the input. But\nJBIG2 also supports lossless compression as well as an intermediate \"less lossy\"\ncompression mode.\n\nIt does this by also storing (and compressing) the difference between the substituted glyph\nand each original glyph. Here's an example showing a difference mask between a\nsubstituted character on the left and the original lossless character in the middle:\n\nUsing the XOR operator on bitmaps to compute a difference image\n\nIn this simple example the encoder can store the difference mask shown on the right, then\nduring decompression the difference mask can be XORed with the substituted character to\nrecover the exact pixels making up the original character. There are some more tricks\noutside of the scope of this blog post to further compress that difference mask using the\nintermediate forms of the substituted character as a \"context\" for the compression.\n\nRather than completely encoding the entire difference in one go, it can be done in steps, with\neach iteration using a logical operator (one of AND, OR, XOR or XNOR) to set, clear or flip\nbits. Each successive refinement step brings the rendered output closer to the original and\nthis allows a level of control over the \"lossiness\" of the compression. The implementation of\nthese refinement coding steps is very flexible and they are also able to \"read\" values already\npresent on the output canvas.\n\nA JBIG2 stream\n\nMost of the CoreGraphics PDF decoder appears to be Apple proprietary code, but the JBIG2\n[implementation is from Xpdf, the source code for which is freely available.](https://www.xpdfreader.com/download.html)\n\n\n-----\n\nThe JBIG2 format is a series of segments, which can be thought of as a series of drawing\ncommands which are executed sequentially in a single pass. The CoreGraphics JBIG2\nparser supports 19 different segment types which include operations like defining a new\npage, decoding a huffman table or rendering a bitmap to given coordinates on the page.\n\nSegments are represented by the class JBIG2Segment and its subclasses JBIG2Bitmap and\nJBIG2SymbolDict.\n\nA JBIG2Bitmap represents a rectangular array of pixels. Its data field points to a backingbuffer containing the rendering canvas.\n\nA JBIG2SymbolDict groups JBIG2Bitmaps together. The destination page is represented as\na JBIG2Bitmap, as are individual glyphs.\n\nJBIG2Segments can be referred to by a segment number and the GList vector type stores\npointers to all the JBIG2Segments. To look up a segment by segment number the GList is\nscanned sequentially.\n\nThe vulnerability\n\nThe vulnerability is a classic integer overflow when collating referenced segments:\n\nGuint numSyms; // (1)\n\nnumSyms = 0;\n\nfor (i = 0; i < nRefSegs; ++i) {\n\nif ((seg = findSegment(refSegs[i]))) {\n\nif (seg->getType() == jbig2SegSymbolDict) {\n\nnumSyms += ((JBIG2SymbolDict *)seg)->getSize(); // (2)\n\n} else if (seg->getType() == jbig2SegCodeTable) {\n\ncodeTables->append(seg);\n\n}\n\n} else {\n\nerror(errSyntaxError, getPos(),\n\n\"Invalid segment reference in JBIG2 text region\");\n\ndelete codeTables;\n\nreturn;\n\n}\n\n\n-----\n\n}\n\n...\n\n// get the symbol bitmaps\n\nsyms = (JBIG2Bitmap **)gmallocn(numSyms, sizeof(JBIG2Bitmap *)); // (3)\n\nkk = 0;\n\nfor (i = 0; i < nRefSegs; ++i) {\n\nif ((seg = findSegment(refSegs[i]))) {\n\nif (seg->getType() == jbig2SegSymbolDict) {\n\nsymbolDict = (JBIG2SymbolDict *)seg;\n\nfor (k = 0; k < symbolDict->getSize(); ++k) {\n\nsyms[kk++] = symbolDict->getBitmap(k); // (4)\n\n}\n\n}\n\n}\n\n}\n\nnumSyms is a 32-bit integer declared at (1). By supplying carefully crafted reference\nsegments it's possible for the repeated addition at (2) to cause numSyms to overflow to a\ncontrolled, small value.\n\nThat smaller value is used for the heap allocation size at (3) meaning syms points to an\nundersized buffer.\n\nInside the inner-most loop at (4) JBIG2Bitmap pointer values are written into the undersized\nsyms buffer.\n\nWithout another trick this loop would write over 32GB of data into the undersized\nsyms buffer, certainly causing a crash. To avoid that crash the heap is groomed such that the\nfirst few writes off of the end of the syms buffer corrupt the GList backing buffer. This\nGList stores all known segments and is used by the findSegments routine to map from the\nsegment numbers passed in refSegs to JBIG2Segment pointers. The overflow causes the\nJBIG2Segment pointers in the GList to be overwritten with JBIG2Bitmap pointers at (4).\n\n\n-----\n\nConveniently since JBIG2Bitmap inherits from JBIG2Segment the seg->getType() virtual call\nsucceed even on devices where Pointer Authentication is enabled (which is used to perform\na weak type check on virtual calls) but the returned type will now not be equal to\njbig2SegSymbolDict thus causing further writes at (4) to not be reached and bounding the\nextent of the memory corruption.\n\nA simplified view of the memory layout when the heap overflow occurs showing the\nundersized-buffer below the GList backing buffer and the JBIG2Bitmap\n\nBoundless unbounding\n\nDirectly after the corrupted segments GList, the attacker grooms the JBIG2Bitmap object\nwhich represents the current page (the place to where current drawing commands render).\n\nJBIG2Bitmaps are simple wrappers around a backing buffer, storing the buffer’s width and\nheight (in bits) as well as a line value which defines how many bytes are stored for each line.\n\n\n-----\n\nThe memory layout of the JBIG2Bitmap object showing the segnum, w, h and line fields\nwhich are corrupted during the overflow\n\nBy carefully structuring refSegs they can stop the overflow after writing exactly three more\nJBIG2Bitmap pointers after the end of the segments GList buffer. This overwrites the vtable\npointer and the first four fields of the JBIG2Bitmap representing the current page. Due to the\nnature of the iOS address space layout these pointers are very likely to be in the second\n4GB of virtual memory, with addresses between 0x100000000 and 0x1ffffffff. Since all iOS\nhardware is little endian (meaning that the w and line fields are likely to be overwritten with\n0x1 — the most-significant half of a JBIG2Bitmap pointer) and the segNum and h fields are\nlikely to be overwritten with the least-significant half of such a pointer, a fairly random value\ndepending on heap layout and ASLR somewhere between 0x100000 and 0xffffffff.\n\nThis gives the current destination page JBIG2Bitmap an unknown, but very large, value for h.\nSince that h value is used for bounds checking and is supposed to reflect the allocated size\nof the page backing buffer, this has the effect of \"unbounding\" the drawing canvas. This\nmeans that subsequent JBIG2 segment commands can read and write memory outside of\nthe original bounds of the page backing buffer.\n\n\n-----\n\nThe heap groom also places the current page s backing buffer just below the undersized\nsyms buffer, such that when the page JBIG2Bitmap is unbounded, it's able to read and\nwrite its own fields:\n\nThe memory layout showing how the unbounded bitmap backing buffer is able to reference\nthe JBIG2Bitmap object and modify fields in it as it is located after the backing buffer in\nmemory\n\nBy rendering 4-byte bitmaps at the correct canvas coordinates they can write to all the fields\nof the page JBIG2Bitmap and by carefully choosing new values for w, h and line, they can\nwrite to arbitrary offsets from the page backing buffer.\n\nAt this point it would also be possible to write to arbitrary absolute memory addresses if you\nknew their offsets from the page backing buffer. But how to compute those offsets? Thus far,\nthis exploit has proceeded in a manner very similar to a \"canonical\" scripting language\nexploit which in Javascript might end up with an unbounded ArrayBuffer object with access\n\n\n-----\n\nto memory. But in those cases the attacker has the ability to run arbitrary Javascript which\ncan obviously be used to compute offsets and perform arbitrary computations. How do you\ndo that in a single-pass image parser?\n\nMy other compression format is turing-complete!\n\nAs mentioned earlier, the sequence of steps which implement JBIG2 refinement are very\nflexible. Refinement steps can reference both the output bitmap and any previously created\nsegments, as well as render output to either the current page or a segment. By carefully\ncrafting the context-dependent part of the refinement decompression, it's possible to craft\nsequences of segments where only the refinement combination operators have any effect.\n\nIn practice this means it is possible to apply the AND, OR, XOR and XNOR logical operators\nbetween memory regions at arbitrary offsets from the current page's JBIG2Bitmap backing\nbuffer. And since that has been unbounded… it's possible to perform those logical operations\non memory at arbitrary out-of-bounds offsets:\n\nThe memory layout showing how logical operators can be applied out-of-bounds\n\n\n-----\n\nIt s when you take this to its most extreme form that things start to get really interesting. What\nif rather than operating on glyph-sized sub-rectangles you instead operated on single bits?\n\nYou can now provide as input a sequence of JBIG2 segment commands which implement a\nsequence of logical bit operations to apply to the page. And since the page buffer has been\nunbounded those bit operations can operate on arbitrary memory.\n\nWith a bit of back-of-the-envelope scribbling you can convince yourself that with just the\navailable AND, OR, XOR and XNOR logical operators you can in fact compute\nany computable function - the simplest proof being that you can create a logical NOT\noperator by XORing with 1 and then putting an AND gate in front of that to form a NAND\ngate:\n\nAn AND gate connected to one input of an XOR gate. The other XOR gate input is\nconnected to the constant value 1 creating an NAND.\n\nA NAND gate is an example of a universal logic gate; one from which all other gates can be\n[built and from which a circuit can be built to compute any computable function.](https://www.nand2tetris.org/)\n\nPractical circuits\n\nJBIG2 doesn't have scripting capabilities, but when combined with a vulnerability, it does\nhave the ability to emulate circuits of arbitrary logic gates operating on arbitrary memory. So\nwhy not just use that to build your own computer architecture and script that!? That's exactly\nwhat this exploit does. Using over 70,000 segment commands defining logical bit operations,\nthey define a small computer architecture with features such as registers and a full 64-bit\nadder and comparator which they use to search memory and perform arithmetic operations.\nIt's not as fast as Javascript, but it's fundamentally computationally equivalent.\n\nThe bootstrapping operations for the sandbox escape exploit are written to run on this logic\ncircuit and the whole thing runs in this weird, emulated environment created out of a single\ndecompression pass through a JBIG2 stream. It's pretty incredible, and at the same time,\npretty terrifying.\n\nIn a future post (currently being finished), we'll take a look at exactly how they escape the\nIMTranscoderAgent sandbox.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-15 - A deep dive into an NSO zero-click iMessage exploit- Remote Code Execution.pdf"
    ],
    "report_names": [
        "2020-12-15 - A deep dive into an NSO zero-click iMessage exploit- Remote Code Execution.pdf"
    ],
    "threat_actors": [
        {
            "id": "42a6a29d-6b98-4fd6-a742-a45a0306c7b0",
            "created_at": "2022-10-25T15:50:23.710403Z",
            "updated_at": "2025-03-27T02:00:55.531313Z",
            "deleted_at": null,
            "main_name": "Silence",
            "aliases": [
                "Whisper Spider"
            ],
            "source_name": "MITRE:Silence",
            "tools": [
                "Winexe",
                "SDelete"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "88e53203-891a-46f8-9ced-81d874a271c4",
            "created_at": "2022-10-25T16:07:24.191982Z",
            "updated_at": "2025-03-27T02:02:10.13692Z",
            "deleted_at": null,
            "main_name": "Silence",
            "aliases": [
                "ATK 86",
                "Contract Crew",
                "TAG-CR8",
                "TEMP.TruthTeller",
                "Whisper Spider"
            ],
            "source_name": "ETDA:Silence",
            "tools": [
                "EDA",
                "EmpireDNSAgent",
                "Farse",
                "Ivoke",
                "Kikothac",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Meterpreter",
                "ProxyBot",
                "ReconModule",
                "Silence.Downloader",
                "TiniMet",
                "TinyMet",
                "TrueBot",
                "xfs-disp.exe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536087,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1653686895,
    "ts_modification_date": 1653686895,
    "files": {
        "pdf": "https://archive.orkl.eu/19485f2aebf81b02fe749cee9af6dc28f80a3398.pdf",
        "text": "https://archive.orkl.eu/19485f2aebf81b02fe749cee9af6dc28f80a3398.txt",
        "img": "https://archive.orkl.eu/19485f2aebf81b02fe749cee9af6dc28f80a3398.jpg"
    }
}