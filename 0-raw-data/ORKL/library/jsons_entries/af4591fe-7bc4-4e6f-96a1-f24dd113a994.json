{
    "id": "af4591fe-7bc4-4e6f-96a1-f24dd113a994",
    "created_at": "2023-06-05T02:07:28.087707Z",
    "updated_at": "2025-03-27T02:05:29.782418Z",
    "deleted_at": null,
    "sha1_hash": "425d47fd79c951ac9df68ccb1bc37bb16ee59cd8",
    "title": "2023-05-03 - Teasing the Secrets From Threat Actors- Malware Configuration Parsing at Scale",
    "authors": "",
    "file_creation_date": "2023-06-04T12:26:21Z",
    "file_modification_date": "2023-06-04T12:26:21Z",
    "file_size": 1861833,
    "plain_text": "# Teasing the Secrets From Threat Actors: Malware Configuration Parsing at Scale\n\n**[unit42.paloaltonetworks.com/teasing-secrets-malware-configuration-parsing](https://unit42.paloaltonetworks.com/teasing-secrets-malware-configuration-parsing)**\n\nMark Lim, Daniel Raygoza, Bob Jung May 3, 2023\n\nBy [Mark Lim,](https://unit42.paloaltonetworks.com/author/mark-lim/) [Daniel Raygoza and](https://unit42.paloaltonetworks.com/author/daniel-raygoza/) [Bob Jung](https://unit42.paloaltonetworks.com/author/bob-jung/)\n\nMay 3, 2023 at 6:00 AM\n\n[Category: Malware](https://unit42.paloaltonetworks.com/category/malware-2/)\n\nTags: [Advanced WildFire,](https://unit42.paloaltonetworks.com/tag/advanced-wildfire/) [IcedID,](https://unit42.paloaltonetworks.com/tag/icedid/) [memory detection,](https://unit42.paloaltonetworks.com/tag/memory-detection/) [WildFire](https://unit42.paloaltonetworks.com/tag/wildfire/)\n\nThis post is also available in: 日本語 [(Japanese)](https://unit42.paloaltonetworks.jp/teasing-secrets-malware-configuration-parsing/)\n\n## Executive Summary\n\nConfiguration data that changes across each instance of deployed malware can be a gold\nmine of information about what the bad guys are up to. The problem is that configuration\ndata in malware is usually difficult to parse statically from the file, by design. Malware authors\nknow the intelligence value as they provide directives for how the malware should behave.\n\nMalware is like most complex software systems in that there are many advantages for code\nreuse and abstraction. Therefore, it is not surprising to see that the concept of software\nconfiguration is pervasive across the various malware families we analyze. After all, it’s pretty\n\n\n-----\n\nhard to imagine a stereotypical cybercriminal wanting to bother with recompiling their code to\nchange an IP address or whatever else, when going after different targets.\n\nBut the good news is that statically armored configuration data can often easily be found and\nparsed directly from memory. We will cover a nice example of an IcedID (information stealer)\nconfiguration, how it was obfuscated and how we’ve extracted it.\n\nPalo Alto Networks customers receive improved detection for the evasions discussed in this\nblog through Advanced WildFire. As we continue to parse and extract this information from\nmalware families at scale, we hope to build out a pool of threat intelligence that will better\nhelp us understand the campaigns and tactics of the various threat actors who are targeting\nvarious organizations.\n\n**Related Unit 42 Topics** **[Memory Detection,](https://unit42.paloaltonetworks.com/tag/memory-detection)** **[Malware](https://unit42.paloaltonetworks.com/category/malware-2/)**\n\nWhat Are Malware Configurations?\n\nIcedID Analysis\n\nUnpacking IcedID Stage One\n\nLocating the Encrypted Configuration Data Blob\n\nExtracting the Encryption Key\n\nDecrypting the Configuration Data Blob With the Encryption Key\n\nUnpacking the IcedID Stage Two Binary\n\nLocating the Encrypted Configuration Data Blob\n\nExtracting the Encryption Key\n\nDecrypting the Configuration Data Blob With the Encryption Key\n\nScaling Up\n\nConclusion\n\nIndicators of Compromise\n\nAdditional Resources\n\n## What Are Malware Configurations?\n\nSo what exactly do we mean by the term “configuration” when talking about malware?\nOutside the context of malware, we think of configuration in terms of defining how systems\nshould behave. For example, we would consider the rules used to define which networking\nroutes for a firewall are allowed, or which font size your web browser uses while you read\nthis, as configurable information.\n\nFor malware, this is no different. Malware configurations are just collections of elements that\ndefine how a malware operates, such as the following:\n\nCommand-and-control (C2) network addresses\nPasswords for remote administrators\n\n\n-----\n\nFile paths in which to drop persistent payloads\n\nThe way these elements are embedded in malware components tends to be specific to each\nmalware family. Also, they might evolve over time as malware undergoes development, or\nwhen malware authors change their build process.\n\nGenerally speaking, malware configuration elements tend to be the properties of malware\nthat the authors want to make easily editable between campaigns and deployments without\nrequiring manual code edits for each one. Malware configuration elements can also expose\nlatent behaviors and malware infrastructure that are not typically observable under routine\ndynamic analysis.\n\nMalware configurations have intelligence value for security practitioners because they\nprovide insights into campaigns over time. In some cases, defenders could use them as\nactionable artifacts for network detection, or for identifying infected hosts. The successful\nextraction and validation of a malware configuration can also be used to reinforce our\nconfidence when identifying a file as malicious.\n\nBecause malware configurations have value to security systems and defenders alike, it is\nstate-of-practice for modern malware authors to protect their configuration elements using\ndifferent techniques. These protections often include a blend of encryption, obfuscation and\n[compression. They might also be layered with evasive techniques.](https://unit42.paloaltonetworks.com/sandbox-evasion-memory-detection/)\n\nThis protection poses a significant challenge for malware configuration extractors that\noperate solely by using static analysis, because all of these protections must be detected\nand bypassed before extraction can be performed. Using an advanced dynamic analysis\nsandbox combined with intelligent runtime memory analysis makes it possible to bypass\nmany of these protections and pinpoint the best opportunities to perform extraction.\n\nWhen we represent and store these configurations using standardized schemas, it enables\nus to extract maximum value through automation, machine learning and interactive analysis.\nThe [DC3-MWCP library defines a schema for many of the most common configuration](https://github.com/dod-cyber-crime-center/DC3-MWCP)\n[element types, and it provides a simple library for serialization to JSON.](https://www.json.org/json-en.html)\n\nThe [MITRE](https://www.mitre.org/) [MAEC and](https://maecproject.github.io/) [STIX projects also provide us with a more general vocabulary for](https://oasis-open.github.io/cti-documentation/)\nrepresenting malware configuration elements. This also allows us to correlate the elements\nwith observable objects collected during dynamic analysis.\n\n## IcedID Analysis\n\nLet’s look at one IcedID binary and how its configurations are encrypted.\n\nHash 05a3a84096bcdc2a5cf87d07ede96aff7fd5037679f9585fee9a227c0d9cbf51\n\n\n-----\n\nThis [particular attack chain, shown in Figure 1, was discovered in early November 2022. It](https://twitter.com/Unit42_Intel/status/1588524735368937484?s=20&t=YXkHyDy_wX1vbbynVm9R6A)\ndelivered IcedID, an information stealer also known as Bokbot, as the final payload. This\n[threat is well-known malware that has been attacking people since 2019.](https://unit42.paloaltonetworks.com/atoms/monsterlibra/)\n\nThe following diagram shows the infection chain.\n\nFigure\n\n1. IcedID infection chain.\nAuthors of IcedID took pains to hide their configurations. Recent samples of IcedID stage two\nwould only be downloaded if the victim’s machine matched the requirements of the threat\nactor.\n\nThe configurations of IcedID consisted of C2 URLs and their campaign IDs. The C2 URLs\nincluded some that might not be revealed during the execution of the IcedID binaries. The\ncampaign ID links IcedID samples back to specific threat actors.\n\nWe will go through the following steps to extract the configurations found in the IcedID stage\none and two binaries:\n\n1. Unpack the IcedID binary\n2. Locate the encrypted configuration data blob\n3. Extract the encryption key\n4. Decrypt the configuration data blob with the encryption key\n\n### Unpacking IcedID Stage One\n\nIcedID stage one unpacks itself by first allocating memory using the VirtualAlloc function.\nThis is followed by erasing the allocated memory using the Memset function, as shown in\nFigure 2. Finally, it copies the unpacked data to the allocated memory using the Memmove\nfunction.\n\nTo dump the unpacked data, we set a breakpoint at Memmove. The second argument of\nMemmove contains the address of the unpacked data. Figure 2 also shows the DOS MZ\nheader of the unpacked IcedID stage one in the right-hand side of the hex dump.\n\n\n-----\n\nFigure 2. Unpacking IcedID stage one.\n\n### Locating the Encrypted Configuration Data Blob\n\nNext, we located the encrypted configuration data blob using the unpacked stage one\nIcedID. While debugging the unpacked IcedID stage one file, we set a breakpoint at the\naddress that called WinHttpConnect, as shown in Figure 3. The address pointed to by\nregister RDI contains the string of the C2 URL.\n\nFigure 3. Debugging IcedID stage one.\nBy [backtracing the code, we located a function that used the decrypted configuration as](https://www.gnu.org/software/libc/manual/html_node/Backtraces.html#:~:text=A%20backtrace%20is%20a%20list,purposes%20of%20logging%20or%20diagnostics.)\nshown in Figure 4.\n\nFigure 4. Tracing code in IcedID stage one.\nTracing the code flow back, we found the loop that decrypted the configuration, as shown in\nFigure 5.\n\nFigure 5. Configuration decryption loop for IcedID stage one.\nThe instruction at 0x7FEF33339CD loaded the address of the encrypted configuration data\nblob (Encrypted Config) into register RDX.\n\n\n-----\n\n### Extracting the Encryption Key\n\nThe instruction at 0x7FEF33339D4 reads the encryption key. The key is 0x40 bytes offset\nfrom the address of Encrypted_Config. We also learned the configuration is 0x20 bytes long.\nAn XOR [loop was used to decrypt the configuration.](https://stackoverflow.com/questions/39442293/assembly-code-how-does-xor-in-a-loop-works)\n\n### Decrypting the Configuration Data Blob With the Encryption Key\n\nAfter gathering the encryption key, the encrypted data blob and the decryption routine, we\ncan now decrypt the configuration using the following script shown in Figure 6.\n\nFigure 6. Configuration decryption script for IcedID stage one.\nThe decrypted IcedID stage 1 configuration has the following format, as shown in Figure 7.\n\n\n-----\n\nFigure 7.\n\nIcedID stage one configuration format.\nFrom the decrypted configuration, we can extract the following IoCs:\n\nC2 URL bayernbadabum[.]com\n\nCampaign ID 1139942657\n\nNow, we will decrypt the configuration for the IcedID stage two binary.\n\n### Unpacking the IcedID Stage Two Binary\n\nAs the IcedID stage two binary uses the same packer as stage one, we will not repeat the\nunpacking steps here.\n\n### Locating the Encrypted Configuration Data Blob\n\nWe set a breakpoint at the address that calls Winhttpconnect, as shown in Figure 8.\n\nFigure 8. Debugging IcedID stage two.\nAfter tracing the code, we located the function that used the decrypted configuration, as\nshown in Figure 9.\n\nFigure 9. Tracing code in IcedID stage two.\n\n### Extracting the Encryption Key\n\n\n-----\n\nTracing the code flow even further back, we found the function that decrypts the\nconfiguration. The first few instructions located the encrypted configuration blob. The\nencrypted blob is 0x25c bytes long. The encryption key is the last 0x10 bytes of the\nencrypted configuration blob, as shown in Figure 10.\n\nFigure 10. Loading the encryption key for IcedID stage two.\nAfter retrieving the encryption key, the next step is the loop to decrypt the encrypted blob, as\nshown in Figure 11.\n\nFigure 11. Configuration decryption loop for IcedID stage two.\n\n### Decrypting the Configuration Data Blob With the Encryption Key\n\nWe replicated the instructions in the decryption loop using Python. After gathering the\nencryption key, encrypted data blob and the decryption routine, we can now decrypt the\nconfiguration using the following script (shown in Figure 12).\n\n\n-----\n\nFigure 12. Configuration decryption script for IcedID stage two. Note: Jquinn147 and\nmyrtus0x0 published a similar configuration decryption script for IcedID in May 2021, called\n[IcedDecrypt (GitHub).](https://github.com/BinaryDefense/IcedDecrypt/blob/main/IcedDecrypt.py)\nThe decrypted IcedID stage two configuration has the following format, shown in Figure 13.\n\nFigure 13. Configuration\n\nformat for IcedID stage two.\nFrom the decrypted configuration, we can extract the following indicators of compromise\n(IoCs):\n\n\n-----\n\nC2 URLs newscommercde[.]com\nspkdeutshnewsupp[.]com\n\ngermanysupportspk[.]com\n\nnrwmarkettoys[.]com\n\nC2 URI news\n\nCampaign ID 1139942657\n\nWe have manually decrypted the configuration for both the IcedID stage one and two\nbinaries.\n\n## Scaling Up\n\nNow that we’ve discussed the work of figuring out how to target the configuration data in\nmemory, the next challenge is to figure out how to perform this at scale. The massive scale\nof most malware processing systems means that most practitioners looking to build out a\nconfiguration extraction system will need to be careful about adding additional overhead.\nThis means that we will need a mechanism to intelligently identify only the samples of\ninterest for each parser, so we’re not unnecessarily running dozens of parsers across\nmillions of samples.\n\nWe think a reasonable approach to this problem involves using intelligent runtime memory\nanalysis, as it provides us with excellent visibility into the secrets malware authors want to\nprotect. A typical workflow for our malware configuration extractors includes the following\nactivities:\n\nScanning memory and/or other dynamic analysis artifacts\nApplying a noise filter on the results to identify the best candidates for extraction\nPerforming extraction using the best fitting module and storing the results for reporting\nand indexing\n\nGeneralizing this common workflow presented us with the opportunity to make the following\nimprovements:\n\nOptimizing the search phase by only scanning analysis data once in most cases\nApplying abstractions and reusable code for many common tasks\nLimiting the impact of modules with problematic inputs or other bugs\nGiving our security researchers visibility into the performance of their modules\n\n\n-----\n\nThe following example shows some of the IoCs from a recent IcedID extractor after being\ndeployed at scale. Having a nice framework for deploying configuration extractors means\nthat once you are finished crafting a configuration extraction script, it’s time to kick your feet\nup and relax while hundreds of configurations flow into your malware configuration database.\n\nFigure 14. IoCs from IcedID samples.\n\n## Conclusion\n\n\n-----\n\nThank you for joining us in this overview of malware configurations and why we are working\nhard to parse this information at scale in Advanced WildFire. Reverse engineering variants of\neach malware family allow us to build out parsers to extract meaningful and relevant data for\nall of them at scale.\n\nThere is a staggering amount of diversity among payloads in the malware landscape, which\nmakes the task of supporting them all more or less impossible. Where possible, we use\nmetrics-based approaches to prioritize focus on the malware families and variants most\nrelevant to our customers. In this ongoing area of research, our team will continue to expand\nsupport for new malware families and variants.\n\nPalo Alto Networks customers receive protections from threats such as those discussed in\nthis post with [Advanced WildFire.](https://www.paloaltonetworks.com/network-security/advanced-wildfire)\n\n## Indicators of Compromise\n\n05a3a84096bcdc2a5cf87d07ede96aff7fd5037679f9585fee9a227c0d9cbf51\n\n## Additional Resources\n\n_Updated May 17, 2023, at 6:00 a.m. PT._\n\n**Get updates from**\n\n**Palo Alto**\n\n**Networks!**\n\nSign up to receive the latest news, cyber threat intelligence and research from us\n\n[By submitting this form, you agree to our Terms of Use and acknowledge our Privacy](https://www.paloaltonetworks.com/legal-notices/terms-of-use)\nStatement.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-05-03 - Teasing the Secrets From Threat Actors- Malware Configuration Parsing at Scale.pdf"
    ],
    "report_names": [
        "2023-05-03 - Teasing the Secrets From Threat Actors- Malware Configuration Parsing at Scale.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1685930848,
    "ts_updated_at": 1743041129,
    "ts_creation_date": 1685881581,
    "ts_modification_date": 1685881581,
    "files": {
        "pdf": "https://archive.orkl.eu/425d47fd79c951ac9df68ccb1bc37bb16ee59cd8.pdf",
        "text": "https://archive.orkl.eu/425d47fd79c951ac9df68ccb1bc37bb16ee59cd8.txt",
        "img": "https://archive.orkl.eu/425d47fd79c951ac9df68ccb1bc37bb16ee59cd8.jpg"
    }
}