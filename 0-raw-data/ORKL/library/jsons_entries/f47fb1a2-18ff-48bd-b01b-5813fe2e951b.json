{
    "id": "f47fb1a2-18ff-48bd-b01b-5813fe2e951b",
    "created_at": "2023-01-12T15:01:21.405963Z",
    "updated_at": "2025-03-27T02:11:01.42739Z",
    "deleted_at": null,
    "sha1_hash": "87f8e02d7e220ce7fe659a0eefd3e572b480b53f",
    "title": "2020-05-31 - Revisiting the NSIS-based crypter",
    "authors": "",
    "file_creation_date": "2022-05-28T02:32:56Z",
    "file_modification_date": "2022-05-28T02:32:56Z",
    "file_size": 717220,
    "plain_text": "# Revisiting the NSIS-based crypter\n\n**[blog.malwarebytes.com/threat-analysis/2021/05/revisiting-the-nsis-based-crypter/](https://blog.malwarebytes.com/threat-analysis/2021/05/revisiting-the-nsis-based-crypter/)**\n\nThreat Intelligence Team May 31, 2021\n\n_[This blog post was authored by hasherezade](https://twitter.com/hasherezade)_\n\n[NSIS (Nullsoft Scriptable Install System) is a framework dedicated to creating software](https://nsis.sourceforge.io/Main_Page)\ninstallers. It allows to bundle various elements of an application together (i.e. the main\nexecutable, used DLLs, configs), along with a script that controls where are they going to be\nextracted, and what their execution order is. It is a free and powerful tool, making distribution\nof software easier. Unfortunately, its qualities are known not only to legitimate developers but\nalso to malware distributors.\n\n[For several years we have been observing malware distributed via NSIS-based crypters. The](https://blog.malwarebytes.com/threat-analysis/2015/12/malware-crypters-the-deceptive-first-layer/)\nouter layer made of a popular and legitimate tool makes for a perfect cover. The flexibility of\nthe installer allows to implement various ideas for obfuscating malicious elements. We wrote\n[about unpacking them in the past, i.e. here, and](https://blog.malwarebytes.com/threat-analysis/2015/07/revisiting-the-bunitu-trojan/) [here. With time their internal structure has](https://hshrzd.wordpress.com/2016/07/03/unpacking-nsis-based-crypter-step-by-step/)\nevolved, so we decided to revisit them and describe the inside again using samples from\nsome of the Formbook stealer campaigns.\n\n## Samples\n\nThis analysis is based on the following samples:\n\n\n-----\n\n[8F80426CEC76E7C9573A9C58072399AF](https://www.virustotal.com/gui/file/507dbfd6aa22a40c64e153af688a18c03616e3473eee95f5312f6e9b2b3beb5a/community)\n\n[carrying a Formbook sample: 05dc8c8d912a58a5dde38859e741b2c0](https://www.virustotal.com/gui/file/7e8635287dabea0a70c9b3ff4935356b5191c55e114ce77fdbfb877c45bf33db/details)\n[98061CCF694005A78FCF0FBC8810D137](https://www.virustotal.com/gui/file/5285e7eca4c9b0ce96a5fc6983eaf7c08ad000c5388606fe77c5d72b97d70cf3/detection)\n\n[carrying a Formbook sample: f34bd301f4f4d53e2d069b4842bca672](https://www.virustotal.com/gui/file/62c43f60d9b9eb52a642f6a52fbd4659d3257e075db44dc7e44c3e006903d9b3/detection)\n\n## Inside\n\nLike every NSIS-based installer, this executable is an archive that can be unpacked with the\n[help of 7zip. The older versions of 7zip (i.e. 15.05) were also able to extract the NSIS script:](https://sourceforge.net/projects/sevenzip/files/7-Zip/15.05/)\n\n[[NSIS].nsi. Unfortunately, in the newer releases script extraction is no longer supported.](https://gist.github.com/hshrzd/1c3e9a5cb168065d3e93c7f3d877a9b8)\n\nOnce we unpack the file, we can see several elements, as well as directories typical for\nNSIS:\n\nThe System.dll is a DLL typical for any NSIS installer, responsible for executing the\ncommands from the script. It is the first component of the archive to be loaded. We can find it\nin each of the samples.\n\nWhat is more interesting are the files in the main directory. The first one, 1 KB in size, is a\nshellcode. It starts from bytes:\n```\n0x55, 0x8B, 0xEC, 0x81, 0xEC\n\n```\n\n-----\n\nAnalogous shellcode can be found in the second sample from this campaign.\n\nIn the same directory there are two other files. One of them is around 7 KB, and the next:\nmuch bigger. Both of them are encrypted, and to find out what they contain we need to\nanalyze the full chain of loading.\n\n[Looking inside the NSIS script we can see the performed actions that are very simple:](https://gist.github.com/hshrzd/1c3e9a5cb168065d3e93c7f3d877a9b8#file-nsis-nsi-L245)\n```\nFunction .onInit\n InitPluginsDir\n SetOutPath $INSTDIR\n File 5e9ikl8w3iif7ipp6\n File 3ugs67ip868x5n\n File tjdorfrldbgdlq\n System::Alloc 1024\n Pop $0\n System::Call \"kernel32::CreateFile(t'$INSTDIR\\tjdorfrldbgdlq', i 0x80000000, i 0, p\n0, i 3, i 0, i 0)i.r10\"\n System::Call \"kernel32::VirtualProtect(i r0, i 1024, i 0x40, p0)p.r1\"\n System::Call \"kernel32::ReadFile(i r10, i r0, i 1024, t., i 0) i .r3\"\n System::Call ::$0()\n Call func_80\n[...]\n\n```\n\n-----\n\nThe first file of the set (containing the shellcode) is read into the executable memory. Then,\nthe loaded module is just called.\n\n### Shellcode #1 – functionality\n\nIf we load those shellcodes into IDA we can see their functionality very clearly, as they are\nnot obfuscated.\n\nShellcode from sample #1:\n\nShellcode from sample #2\n\n\n-----\n\nAlthough the code is a bit different in both, they can be divided with the same steps and\nbuilding blocks.\n\n1. The name of the next file is loaded as a stack-based wide string\n2. The base of kernel32.dll is fetched from PEB\n\n\n-----\n\n3. A set of function from kernel32.dll is retrieved – each of them by the name s\n\nchecksums. Functions are always the same – dedicated to reading the file from the\ndisk: CreateFileW, GetTempPathW, lstrcatW, ReadFile, VirtualAlloc, GetTempPathW.\n4. The function GetTempPathW is used to retrieve the path to the %TEMP% directory,\n\nwhere all the components from the archive were automatically extracted at runtime of\nthe NSIS file\n5. The name of the next file is concatenated to the the %TEMP% path\n6. Memory is allocated for the file content, and the file is read into this buffer\n7. A custom decryption algorithm is being applied on the buffer (the algorithm is different\n\nfor different samples). The buffer turns out to be a next shellcode\n8. Finally, the next shellcode is executed\n\nThe name of the\n\nnext file is loaded as a stack-based wide string\nThe hashing function used for import resolving follows the same pattern in both cases, yet\nthe constant used to initialize it (denoted as HASH_INIT) is different across the samples.\n\nint __stdcall calc_hash(char *name)\n\n{\n\nint next_chunk;\n\nint hash;\n\nfor ( hash = HASH_INIT; ; hash = next_chunk + 33 * hash )\n\n{\n\n\n-----\n\nnext_chunk = *name++;\n\nif ( !next_chunk )\n\nbreak;\n\n}\n\nreturn hash;\n\n}\n\n[view raw](https://gist.github.com/hshrzd/578770a5261d422e1e112cdd3d8ed75e/raw/409b267fb9d305c178f89b4ba7b72355a5a7b347/nsis_calc_hash.cpp) [nsis_calc_hash.cpp hosted with ❤ by](https://gist.github.com/hshrzd/578770a5261d422e1e112cdd3d8ed75e#file-nsis_calc_hash-cpp) [GitHub](https://github.com/)\nThe algorithm used for the buffer decryption differs across the samples.\n\n\n-----\n\nThe\n\n\nsecond shellcode revealed after the unpacking algorithm finished processing\n\n### Shellcode #2 – functionality\n\n\n-----\n\nThis shellcode is used for decrypting and loading the final payload (PE file) from the third of\nthe encrypted files. It is unpacked and ran by the previous layer. In the analyzed cases, this\nelement was around 7-8 KB.\n\nThis shellcode is similarly structured as the previous one. It starts by preparation of the\nstrings: stack-based strings are being pushed. One of them is the name of the next file that is\ngoing to be loaded. Also, the key that will be used for the decryption is prepared.\n\n\n-----\n\nThe next step is loading of the imported functions. As before, they are resolved by their\nhashes.\n\n\n-----\n\nThen the functions are used to load and decrypt the payload. If loading the next stage has\nfailed, the installer will restart itself.\n\nThe decryption function is custom, similar (but not identical) to RC4:\n\nvoid __stdcall decrypt_buf(BYTE *data, BYTE *key, unsigned int size)\n\n\n-----\n\n{\n\nBYTE key_stream[512];\n\nint j;\n\nchar next;\n\nint i;\n\nint v6 = 0;\n\nint v4 = 0;\n\nfor ( i = 0; i < 256; ++i )\n\n{\n\nkey_stream[i + 256] = i;\n\nkey_stream[i] = key[i % size];\n\n}\n\nfor ( i = 0; i < 256; ++i )\n\n{\n\nv6 = (key_stream[i] + v6 + key_stream[i + 256]) % 256;\n\nnext = key_stream[v6 + 256];\n\nkey_stream[v6 + 256] = key_stream[i + 256];\n\nkey_stream[i + 256] = next;\n\n}\n\nv6 = 0;\n\nfor ( j = 0; j < DATA_SIZE; ++j )\n\n{\n\ni = (i + 1) % 256;\n\nv6 = (v6 + key_stream[i + 256]) % 256;\n\nnext = key_stream[v6 + 256];\n\nkey_stream[v6 + 256] = key_stream[i + 256];\n\n\n-----\n\nkey_stream[i + 256] = next;\n\nv4 = (key_stream[v6 + 256] + key_stream[i + 256]) % 256;\n\ndata[j] ^= key[j % size];\n\ndata[j] ^= key_stream[v4 + 256];\n\n}\n\n}\n\n[view raw](https://gist.github.com/hshrzd/578770a5261d422e1e112cdd3d8ed75e/raw/409b267fb9d305c178f89b4ba7b72355a5a7b347/nsis_decrypt.cpp) [nsis_decrypt.cpp hosted with ❤ by](https://gist.github.com/hshrzd/578770a5261d422e1e112cdd3d8ed75e#file-nsis_decrypt-cpp) [GitHub](https://github.com/)\nThis algorithm is common to both analyzed samples – yet the decryption key differs.\n\n### Loading PE\n\nAfter the PE is decrypted, the function for its loading is deployed.\n\nThe payload is implanted into a newly created suspended process (a new instance of the\ncurrent executable) using one of the most popular techniques of PE injection: Process\nHollowing (a.k.a. RunPE). The content of the payload is mapped into the new process using\nlow level APIs: NtCreateSection, NtMapViewOfSection. Then, the Entry Point is redirected to\nthe new executable via SetThreadContext, and finally the execution is resumed with\nNtResumeThread.\n\nThe authors used several common techniques to obfuscate this process.\n\nAs before, the used functions are loaded by their checksums. The PE loading function\nmakes a use of the following set:\n\nThe low-level functions, directly related with performing the injection, are called via raw\nsyscalls retrieved directly from NTDLL. Also in this case, functions has been resolved by\ntheir hashes.\n\nList of used functions (with corresponding hashes).\n\n\n-----\n\n```\n 4b1a50d1 : NtCreateSection\n e0ddd5cb : NtMapViewOfSection\n 20b0f111 : NtResumeThread\n 81af6d4e : NtUnmapViewOfSection\n be530033 : NtWriteVirtualMemory\n\n```\n_[The code used to resolve the hashes is available here: hash_resolver.cpp.](https://gist.github.com/hshrzd/7264136e485ad63bb28de53f7da24504#file-hash_resolver-cpp)_\n\nOverview of the PE loader\n\n**Manual syscalls calling**\n\n\n-----\n\nIn order to make the injection stealthier, the loader uses a common technique of stealing\n[syscalls”, also known as “hell’s gate”. This technique is based on the fact that some low-level](https://twitter.com/vxunderground/status/1267865030495789056?s=20)\nDLLs, such as NTDLL, contain numbers of raw syscalls. By extracting the syscalls, and\nexecuting them manually, the malware can use the API of the operating system, without a\nneed of calling functions from the DLL. That allows to bypass some monitoring in the\nsituation if the system DLLs are hooked. More in-depth analysis of this technique was\n[described here.](https://blog.malwarebytes.com/threat-analysis/2016/11/floki-bot-and-the-stealthy-dropper/)\n\nFirstly, a fresh copy of NTDLL is loaded from the file on the disk, an manually mapped. Then,\na function defined by its hash is retrieved (using the same hashing algorithm that was used\nto retrieve imports from normally loaded DLLs):\n\nAfter the pointer to the beginning of the function is fetched, a small disassembling loop is\nused to find the familiar pattern: moving the ID of the syscall into EAX register.\n\n\n-----\n\nThe syscall ID is returned for further use.\n\nOnce the syscall number has been extracted, the malware intends to execute it from its own\ncode. However, a 32-bit application cannot make direct syscalls on 64-bit system, since it is\nnot native. In such cases, syscalls are usually made via Wow64 emulation layer. In order to\nmake them directly, the authors of the malware switch to the 64-bit mode first: using a\n[technique called “Heaven’s Gate”.](https://blog.malwarebytes.com/threat-analysis/2018/01/a-coin-miner-with-a-heavens-gate/)\n\nThe malware comes with two variants of the stub executing a syscall. The decision for which\nof the versions should be applied is made based on the check if the process runs as Wow64\n(emulated 32 bit on 64 bit Windows):\n\nIf the process runs on a 32-bit system, the syscall can be made in a direct way, using\nSYSENTER:\n\n\n-----\n\nIf the system is 64-bit, the malware (that is 32-bit) switches into 64-bit mode via “Heaven’s\nGate”.\n\nFar return to the address\n\nprefixed with 0x33 segment – entering the 64-bit mode\nOnce the execution mode is changed into 64 bit, the syscall is called, its results stored, and\nthe application can switch back to 32-bit mode to continue normal execution.\n\n\n-----\n\nThe 64-bit code, executed after the mode is switched via Heaven’s Gate\n\n## Evolution\n\nThis crypter has been around for several years, and during this time it went through several\nphases of evolution. In this part of the analysis we will compare it with the earlier version\n[from February of this year, described in the following writeup.](https://yoroi.company/research/yes-cyber-adversaries-are-still-using-formbook-in-2021/)\n\nIn contrast to the current one, the version from February contained a malicious component in\nthe form of a DLL. We can also find a second, encrypted component, which carries the\npayload.\n\nThe [extracted NSIS script contains a different sequence of commands:](https://gist.github.com/hshrzd/9c1bbed161efa2f3bbb2c8ba428e0125#file-nsis-nsi)\n\n\n-----\n\n```\nFunction .onInit\n SetOutPath $INSTDIR\n File $INSTDIR\\o15bmldpqdxcin.dll\n File $INSTDIR\\emvmcmzr.n\n System::Call $INSTDIR\\o15bmldpqdxcin.dll::Gxkeoxkzs(w$\\\"$INSTDIR\\emvmcmzr.n$\\\")\n DetailPrint label\n StrCpy $0 9\n IntOp $0 $0 + 4\n Goto $0\n DetailPrint done\nFunctionEnd\n\n```\nIn this case, the standard NSIS component (System.dll) is used to call the function exported\nfrom the DLL, passing the path to the encrypted component as a parameter.\n\nLooking inside the exported function we can find a significant similarity to the Shellcode #1\nwhich was described in the former part of this writeup.\n\nAs before, we can see decryption of the next stage with the help of a custom algorithm. This\ntime, the next stage is contained in a buffer hardcoded in the DLL (rather than stored in a\nseparate file). It contains a very similar function dedicated to decrypting and loading the final\npayload. Yet, we can see some minor differences.\n\n\n-----\n\nFirst of all, the file name is passed dynamically rather than hardcoded.\n\nSecond, we can see a check against blacklisted processes. Their names are hashed, and\ncompared to the hardcoded list of hashes (i.e. 0x26090612 -> “avgui.exe”). This type of\nchecks are among common evasion techniques. However, in this case, detection of a\nforbidden process only delays execution, and does not suspend it or terminate. Possibly it is\na bug in the implementation, and the if statement was intended to be a while loop instead.\nNevertheless, the authors decided to give up the check in the latest version.\n\nApart from those details, this stage is identical to the Shellcode #2 from the newer version.\n\n## Popular and persistent\n\nThis packer has been around for many years, and probably will stay with us for some years\nto come. Its structure shows that it is created by experienced authors, using well known, yet\nnot trivial techniques. Its evolution is slow but steady. Usage of a popular installation engine\n\n\n-----\n\nmakes it easy to blend in with legitimate applications.\n\nIts popularity and diversity of payloads suggests that it is not linked to one specific actor, but\nrather sold as an independent component on one of many underground forums.\n\n## Appendix\n\nOther materials about previous versions of NSIS-based crypters:\n\n[https://yoroi.company/research/yes-cyber-adversaries-are-still-using-formbook-in-2021/](https://yoroi.company/research/yes-cyber-adversaries-are-still-using-formbook-in-2021/)\nhttps://www.welivesecurity.com/2021/01/12/operation-spalax-targeted-malware-attackscolombia/\n[https://news.sophos.com/en-us/2020/05/14/raticate/](https://news.sophos.com/en-us/2020/05/14/raticate/)\nhttps://www.mcafee.com/blogs/other-blogs/mcafee-labs/ransomware-families-use-nsisinstallers-to-avoid-detection-analysis/\nhttps://www.microsoft.com/security/blog/2017/03/15/ransomware-operators-are-hidingmalware-deeper-in-installer-packages/\nhttps://isc.sans.edu/forums/diary/Quick+analysis+of+malware+created+with+NSIS/237\n03/\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-05-31 - Revisiting the NSIS-based crypter.pdf"
    ],
    "report_names": [
        "2020-05-31 - Revisiting the NSIS-based crypter.pdf"
    ],
    "threat_actors": [
        {
            "id": "64d750e4-67db-4461-bae2-6e75bfced852",
            "created_at": "2022-10-25T16:07:24.01415Z",
            "updated_at": "2025-03-27T02:02:10.077988Z",
            "deleted_at": null,
            "main_name": "Operation Spalax",
            "aliases": [],
            "source_name": "ETDA:Operation Spalax",
            "tools": [
                "AsyncRAT",
                "Bladabindi",
                "Jorik",
                "Remcos",
                "RemcosRAT",
                "Remvio",
                "Socmer",
                "njRAT"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "0d07b30c-4393-4071-82fb-22f51f7749e0",
            "created_at": "2022-10-25T16:07:24.097096Z",
            "updated_at": "2025-03-27T02:02:10.106625Z",
            "deleted_at": null,
            "main_name": "RATicate",
            "aliases": [],
            "source_name": "ETDA:RATicate",
            "tools": [
                "AgenTesla",
                "Agent Tesla",
                "AgentTesla",
                "BetaBot",
                "BlackRAT",
                "BlackRemote",
                "Bladabindi",
                "CloudEyE",
                "ForeIT",
                "Formbook",
                "GuLoader",
                "Jorik",
                "Loki",
                "Loki.Rat",
                "LokiBot",
                "LokiPWS",
                "NSIS",
                "Negasteal",
                "NetWeird",
                "NetWire",
                "NetWire RAT",
                "NetWire RC",
                "NetWired RC",
                "Neurevt",
                "Nullsoft Scriptable Install System",
                "Origin Logger",
                "Recam",
                "Remcos",
                "RemcosRAT",
                "Remvio",
                "Socmer",
                "ZPAQ",
                "njRAT",
                "vbdropper",
                "win.xloader"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "2f07a03f-eb1f-47c8-a8e9-a1a00f2ec253",
            "created_at": "2022-10-25T16:07:24.277669Z",
            "updated_at": "2025-03-27T02:02:10.157972Z",
            "deleted_at": null,
            "main_name": "TA428",
            "aliases": [
                "Operation LagTime IT",
                "Operation StealthyTrident",
                "ThunderCats"
            ],
            "source_name": "ETDA:TA428",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "Agent.dhwf",
                "Albaniiutas",
                "BlueTraveller",
                "Chymine",
                "Cotx RAT",
                "CoughingDown",
                "Darkmoon",
                "Destroy RAT",
                "DestroyRAT",
                "Gen:Trojan.Heur.PT",
                "Kaba",
                "Korplug",
                "LuckyBack",
                "PhantomNet",
                "PlugX",
                "Poison Ivy",
                "RedDelta",
                "RoyalRoad",
                "SManager",
                "SPIVY",
                "Sogu",
                "TIGERPLUG",
                "TManger",
                "TVT",
                "Thoper",
                "Xamtrav",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "5c13338b-eaed-429a-9437-f5015aa98276",
            "created_at": "2022-10-25T16:07:23.582715Z",
            "updated_at": "2025-03-27T02:02:09.875151Z",
            "deleted_at": null,
            "main_name": "Emissary Panda",
            "aliases": [
                "APT 27",
                "ATK 15",
                "Bronze Union",
                "Budworm",
                "Earth Smilodon",
                "Emissary Panda",
                "Group 35",
                "Iron Taurus",
                "Iron Tiger",
                "LuckyMouse",
                "Operation DRBControl",
                "Operation Iron Tiger",
                "Operation PZChao",
                "Operation SpoiledLegacy",
                "Operation StealthyTrident",
                "Red Phoenix",
                "TEMP.Hippo",
                "TG-3390",
                "ZipToken"
            ],
            "source_name": "ETDA:Emissary Panda",
            "tools": [
                "ASPXSpy",
                "ASPXTool",
                "Agent.dhwf",
                "AngryRebel",
                "Antak",
                "CHINACHOPPER",
                "China Chopper",
                "Destroy RAT",
                "DestroyRAT",
                "FOCUSFJORD",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HTTPBrowser",
                "HTran",
                "HUC Packet Transmit Tool",
                "HighShell",
                "HttpBrowser RAT",
                "HttpDump",
                "HyperBro",
                "HyperSSL",
                "HyperShell",
                "Kaba",
                "Korplug",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Mimikatz",
                "Moudour",
                "Mydoor",
                "Nishang",
                "OwaAuth",
                "PCRat",
                "PlugX",
                "ProcDump",
                "PsExec",
                "RedDelta",
                "SEASHARPEE",
                "Sensocode",
                "SinoChopper",
                "Sogu",
                "SysUpdate",
                "TIGERPLUG",
                "TVT",
                "Thoper",
                "Token Control",
                "TokenControl",
                "TwoFace",
                "WCE",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "Xamtrav",
                "ZXShell",
                "gsecdump",
                "luckyowa"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535681,
    "ts_updated_at": 1743041461,
    "ts_creation_date": 1653705176,
    "ts_modification_date": 1653705176,
    "files": {
        "pdf": "https://archive.orkl.eu/87f8e02d7e220ce7fe659a0eefd3e572b480b53f.pdf",
        "text": "https://archive.orkl.eu/87f8e02d7e220ce7fe659a0eefd3e572b480b53f.txt",
        "img": "https://archive.orkl.eu/87f8e02d7e220ce7fe659a0eefd3e572b480b53f.jpg"
    }
}