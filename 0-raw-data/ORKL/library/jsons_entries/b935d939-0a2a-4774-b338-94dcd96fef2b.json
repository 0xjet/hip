{
    "id": "b935d939-0a2a-4774-b338-94dcd96fef2b",
    "created_at": "2023-01-12T15:04:53.527831Z",
    "updated_at": "2025-03-27T02:05:48.714382Z",
    "deleted_at": null,
    "sha1_hash": "1469609cf3921fe7afb3e9a6970eb8517a27c815",
    "title": "2020-02-18 - What’s up Emotet-",
    "authors": "",
    "file_creation_date": "2022-05-28T17:44:07Z",
    "file_modification_date": "2022-05-28T17:44:07Z",
    "file_size": 1348494,
    "plain_text": "# What’s up Emotet? | CERT Polska\n\n**cert.pl/en/news/single/whats-up-emotet/**\n\n## What’s up, Emotet?\n\nEmotet is one of the most widespread and havoc-wreaking malware families currently out\nthere. Due to its modular structure, it’s able to easily evolve over time and gain new features\nwithout having to modify the core.\n\n\n-----\n\nIts first version dates back to 2014. Back then it was primarily a banking trojan. These days\nEmotet is known mostly for its spamming capabilities and as a delivery mechanism of other\nmalware strains.\n\nIt has recently undergone a substantial change in communication protocol and obfuscation\ntechniques. This might be a response to the release of tools allowing researchers to easily\ndownload payloads from the C2 servers1 and detect machines infected with Emotet .2\n\nIn this article, we will go over the standard Emotet features and take a look at some of the\nchanges that have been spotted.\n\n[Sample analysed: 500221e174762c63829c2ea9718ca44f](https://www.virustotal.com/gui/file/fc11f30fb0debf8b8f42a7e9c0678df69c8b171c0038ea7aca7217b43b3c220f/detection)\n[Unpacked Emotet core: e8143ef2821741cff199eeda513225d7](https://www.virustotal.com/gui/file/c742c19145779e5e08cfca9b4f584ef32fb08f8cd3216249327a7033689a7845/detection)\n\n## Table of Contents\n\n Anti-analysis features\n\n Code Flow Obfuscation\n\nIn order to make reverse engineering more difficult for researchers, a VM-like obfuscation\nwas implemented. To achieve this, every function was split into basic blocks which were then\nrepositioned into a simple state machine.\n\nDemangling the functions back to their original form is nontrivial, although possible. However,\nit was found that reverse engineering obfuscated binaries is still possible.\n\n\n-----\n\n_Function graph of the main function_\n\n## Encrypted Strings\n\nAll used strings are encrypted almost like in the previous versions. Most noticeable difference\nis related to the xor key – it’s not passed as a parameter anymore. Instead, it’s located at the\nbeginning of the data to be decrypted.\n\n_Example encrypted string_\n\n\n-----\n\n_Encrypted string structure_\n\nOne can decrypt those strings pretty easily using a quick Python script.\n\n_Python function used for decrypting strings_\n\n## WinAPI\n\nAnother method of slowing down the analysis that the malware authors really like is hiding\nthe Window API calls by replacing them with a custom lookup function.\n\nExecuting API calls using hash lookups isn’t a new thing in Emotet. In contrast to previous\nversions however, the new version fetches them on a need-to-use basis instead of loading\nthem all at once and storing them in a data section.\n\n_Api lookup function being used_\n\n\n-----\n\n_Simple hash function used for function name hashing_\n\nIt can be solved rather easily. All one has to do is just reimplement the hashing function,\niterate over common WinAPI function names and create an enum with all recovered hashes.\n\nIt’s very important to set the accepted type in find_api to the newly-created enum type. This\nwill allow IDA to automatically place the enum values in function calls.\n\n_Comparison of a single function before and after applying the enum type_\n\n### Deleting previous versions of itself\n\nWhile analysing the encrypted strings, one of lists of keywords present in earlier versions\nwas noticed. It was used to generate random system paths in which to put the Emotet core\nbinary. This seemed weird because this method was replaced with completely random file\npaths.\n\nAfter closer inspection and confirmation by @JRoosen3 it turned out that these keywords are\nused to delete Emotet binaries that were dropped there by previous versions.\n\n\n-----\n\n_Part of the function used for deleting older versions of Emotet_\n\n## Extracting static configuration\n\n### Public key\n\nThe RSA public key is stored as a regular encrypted string. It’s embedded in the binary in\norder to encrypt the AES keys used for secure communication with the C2. This will deter all\ncommunication eavesdropping attempts.\n\nThe public key isn’t stored in plaintext, but fetched like rest of the encrypted strings. Thus, it\ncan be decrypted using the same script:\n\nThe resulting key is encoded using DER format and can be parsed using the following script:\n\n_Result PEM-encoded public key_\n\n### C2 list\n\nThe method of retrieving C2 hosts has not changed. They are still stored as 8-byte blocks\ncontaining packed IP address and port.\n\n\n-----\n\n## Communication\n\n Path generation\n\nKeyword-generated paths have been abandoned in favour of fully random ones.\n\nEach new path consists of a random amount of alphanumeric segments separated by\nslashes.\n\n\n-----\n\n_Path generation algorithm_\n\nAdditionally, instead of simply uploading the payload data inside the POST body, it is now\nsent as a file upload using multipart/form-data enctype.\n\nThe method of generating random attachment names and filenames is quite similar to the\none used in generating URL paths.\n\n_Part of function responsible for encoding the data as a file_\n\n\n-----\n\n_Example request and response dissected in Wireshark_\n\n## Request structure\n\nThis the part that has gone under the most changes. Protocol buffers have been dropped in\nfavour of a custom binary protocol.\n\n### Packet encryption\n\nJust like in previous versions, all packets are encrypted using AES-CBC with 16 nullbytes as\nIV. The AES key is generated using the CryptGenKey function, encrypted using the decoded\nRSA public key and appended to each request.\n\nAdditionally, an SHA-1 hash of the packets contents is also sent for integrity verification\npurposes.\n\n_The packet encryption structure_\n\n### Packet structure\n\n\n-----\n\nCommand packets are compressed and encapsulated in a simple packet structure.\n\n_[Outer packet dissection presented using dissect.cstruct](https://github.com/fox-it/dissect.cstruct)_\n\n## Packet compression\n\nAnother change is the compression algorithm used for compressing and decompressing\npacket body.\n\nHistorically, the zlib algorithm has been used for that. It’s hard to pinpoint the exact algorithm\nthat is now used, but the procedure evolution_unpack4 from quickbms project was found to\ncorrectly uncompress the data received from the C2 servers\n\n\n-----\n\n_Pseudocode of the new algorithm used to uncompress packets_\n\nIt was decided to reimplement the uncompression procedure in Python, the resulting script is\nlisted below.\n\n### Register packet structure\n\nAs mentioned earlier, the protobuf structures have been abandoned in favour of custom\nstructures.\n\nOne of the observed packet types is the command used to register the bot on the botnet and\nreceive modules to execute.\n\nThe register packet structure can be easily presented using the following c struct:\n\n\n-----\n\n_[Register packet dissection presented using dissect.cstruct](https://github.com/fox-it/dissect.cstruct)_\n\n## Summary\n\nThe goal of this article was to help other researchers with their Emotet research after recent\nchanges.\n\nEmotet has once again proven to be an advanced threat capable of adapting and evolving\nquickly in order to wreak more havoc.\n\nThis article barely scratches the surface of the Emotet’s inner workings, and should be\ntreated as a good entry point, not as a complete guide. We encourage everyone to use this\ninformation, and hopefully share further results and/or discrupt the botnet’s operations.\n\n## Further reading\n\n References\n\n1: [https://d00rt.github.io/emotet_network_protocol/](https://d00rt.github.io/emotet_network_protocol/)\n\n2: [https://github.com/JPCERTCC/EmoCheck](https://github.com/JPCERTCC/EmoCheck)\n\n[3: https://twitter com/JRoosen/status/1225188513584467968](https://twitter.com/JRoosen/status/1225188513584467968)\n\n\n-----\n\n4: [https://github.com/mistydemeo/quickbms/blob/master/unz.c#L5501](https://github.com/mistydemeo/quickbms/blob/master/unz.c#L5501)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-02-18 - What’s up Emotet-.pdf"
    ],
    "report_names": [
        "2020-02-18 - What’s up Emotet-.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535893,
    "ts_updated_at": 1743041148,
    "ts_creation_date": 1653759847,
    "ts_modification_date": 1653759847,
    "files": {
        "pdf": "https://archive.orkl.eu/1469609cf3921fe7afb3e9a6970eb8517a27c815.pdf",
        "text": "https://archive.orkl.eu/1469609cf3921fe7afb3e9a6970eb8517a27c815.txt",
        "img": "https://archive.orkl.eu/1469609cf3921fe7afb3e9a6970eb8517a27c815.jpg"
    }
}