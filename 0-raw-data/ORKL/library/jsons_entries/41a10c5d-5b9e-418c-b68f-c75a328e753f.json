{
    "id": "41a10c5d-5b9e-418c-b68f-c75a328e753f",
    "created_at": "2023-01-12T15:07:08.892568Z",
    "updated_at": "2025-03-27T02:08:40.982027Z",
    "deleted_at": null,
    "sha1_hash": "92a740a3efa96d3130c49db195a5a3f94776f39e",
    "title": "2021-04-01 - Code Reuse Across Packers and DLL Loaders",
    "authors": "",
    "file_creation_date": "2022-05-28T19:32:49Z",
    "file_modification_date": "2022-05-28T19:32:49Z",
    "file_size": 3843207,
    "plain_text": "# Code Reuse Across Packers and DLL Loaders\n\n**[blog.reversinglabs.com/blog/code-reuse-across-packers-and-dll-loaders](https://blog.reversinglabs.com/blog/code-reuse-across-packers-and-dll-loaders)**\n\n[Threat Research | April 1, 2021](https://blog.reversinglabs.com/blog/tag/threat-research)\n\n\n-----\n\nBlog Author\nRobert Simmons, Independent malware researcher and threat researcher at\n[ReversingLabs. Read More...](https://blog.reversinglabs.com/blog/author/robert-simmons)\n\n\n-----\n\nOne of the core tenets of computer science is code reuse. Why write something new, when\ncode that already exists can be repurposed or changed slightly and then reused for a\ndifferent situation. This is no different in the world of malware. SystemBC is a family of\nremote access trojans used to provide access to the local network of a victim and are a\nbeachhead for lateral movement inside that network 1. SystemBC has been observed using\na variety of packers 2. One specific sample 3 has multiple stages of unpacking which\neventually lead to an unpacker stub that has nearly complete code overlap with the\nunpacking stub used in DLL loaders that are found to deliver Ursnif, IceID, DanaBot, Dridex,\nZloader, HanciTor, Valak, and a single example of TrickBot. What follows is a detailed\nanalysis of the packed SystemBC sample up to the unpacker stub in question. From that\nstub a large set of DLL loaders is discovered via YARA hunting. Finally, the generalized\nprocess for dumping the payload from these DLLs is shown.\n\n## Packed SystemBC Sample\n\nThe first stage of the packer in this sample has some extraneous code in addition to the code\nthat performs initial unpacking. Other than this extraneous code, there are a few key points\nof interest. The first one being a mutex, \"guessHi\", that is checked for near the start of\nexecution in the main function. This mutex loaded from a hard coded string along with the\ncall to OpenMutexW is shown in Figure 1.\n\n\n-----\n\nFigure 1: Code Block with \"guessHi\" String and OpenMutexW\n\nAnother interesting feature of the file is a cryptographic signature block at the end of the file,\nbut according to the PE header, there is no signature directory content. Because of this\nmissing data in the header, this file is not properly signed. The data directories from the PE\nheader with the empty security directory highlighted is shown in Figure 2.\n\n\n-----\n\nFigure 2: No Security Directory Referenced in PE Header\n\nHowever, looking at the very end of the file in a hex editor reveals that there is a blob of DER\nencoded binary that is clearly a cryptographic signature for the file. Because this DER data is\nnot referenced in the header as shown above, this signature may have been copied from a\ndifferent file. The start of this signature blob is shown in Figure 3.\n\nFigure 3: Cryptographic Signature Blob\n\nLooking more closely at the content in this signature, a Gmail address is revealed:\n\"draskovicnono[@]gmail[.]com\". This email address is highlighted in Figure 4.\n\nFigure 4: Gmail Address in Signature\n\nAdditionally, this same email address can be found using the search feature on the extracted\nstrings list in the Titanium Platform. This string search is shown in Figure 5.\n\nFigure 5: Gmail Address in Extracted Strings\n\n\n-----\n\nAnother important string from this file is the program database string . In this file that string\nis \"c:\\lawHeart\\costforward\\pagepushwritten.pdb\". One can find this particular string in the\nA1000 under the CodeViews feature. This string is shown in Figure 6.\n\nFigure 6: Code Views with Program Database Path\n\nUsing any of these strings or by pivoting using the ReversingLabs Hash Algorithm (RHA)\nreveals one other file that is related to the SystemBC sample being analyzed 5. The results of\nan RHA pivot is shown in Figure 7.\n\nFigure 7: RHA Pivoting Results\n\n\nHowever, on closer inspection comparing the bytes of the two files in Hex Fiend 6, the only\nmajor difference is an additional 4 kilobytes of data which is just a second copy of the\nalready existing file info data. No other significant differences are found, so these two files\nare effectively the same file. This difference is shown in Figure 8.\n\n\n-----\n\nFigure 8: Difference in the Two Samples\n\nThe function that specifically performs the unpacking routine in this file is found at the\naddress 0x414ED0. This function contains a set of three calls to kernel32.Sleep. These are a\nbasic anti-analysis technique and need to be circumvented to make analysis easier. These\nthree API function calls are shown in Figure 9 with one of them shown in the disassembler\nview.\n\nFigure 9: API Calls to Kernel32.Sleep\n\nIn the debugger, the number of milliseconds for each of these Sleeps can be modified to zero\nthem out. This is shown in Figure 10.\n\nFigure 10: Zero Out Sleeps\n\nAfter the sleeps are neutralized, the first stage of the unpacker writes the next stub to the\n.data section of the module in memory. The call into that code is shown in Figure 11.\n\n\n-----\n\nFigure 11: Call into Next Stage of Unpacker\n\nAs shown in Figure 12, the destination of this call is in the initialized data section of the\nmodule with the name .data.\n\nFigure 12: Initialized Data Section\n\nThe first set of instructions in this next stage is a small loop that decodes the rest of the stub\nin place. This loop is highlighted in Figure 13.\n\nFigure 13: Decoding Loop\n\nAfter the decoding loop has written out the rest of the stub, the resulting instructions are used\nto write a YARA rule. The specific instructions used are highlighted in Figure 14.\n\n\n-----\n\nFigure 14: Decoded Instructions\n\nThe process to write the YARA rule starts with writing out the exact bytes of these\ninstructions. Here, just the first few instructions are shown, but in the actual process the\nwhole set of instructions all the way to and including the first function call at 0x43F3EE is\nused. The example instructions are the following.\n\nE8 00000000 5B 81EB FD148000 8D83 00108000 8983 CC148000\n\nNext, each of the bytes that are specific to locations in this particular file or values that may\nbe unique to this instance of the packer are converted into wildcards and jumps. The bytes\nthat this applies to are shown in red below.\n\nE8 00000000 5B 81EB FD148000 8D83 00108000 8983 CC148000\n\nThe resulting byte string with these jumps and wildcards in place is the following.\n\nE8 00 00 00 00 5B 81 EB [4] 8D 83 [4] 89 83 [4] 8D B3 [4] 89 B3 [4]\n8B 46 ?? 89 83 [4] 8D B3 [4] 56 8D B3 [4] 56 6A ?? 68 [4] 8D BB [4]\nFF D7\n\nThe full YARA rule using this byte string is provided at the end of this blog.\n\n## Related DLLs\n\nUsing the YARA rule written using the process above, a retro-hunt is run in the Titanium\nPlatform. The results of this are a large set of hundreds of malicious DLLs that are all packed\nand utilize the same unpacker stub found in the second stage of the packed SystemBC\nsample above. These results in the A1000 are shown in Figure 15. This is a very accurate\nYARA rule in that there are zero false positives found in the result set.\n\n\n-----\n\nFigure 15: Retro-hunt Results\n\nThis is a moderately large set of files, so unpacking each one to determine what malware\nfamily is being delivered would be time consuming. Therefore a strategy for grouping the files\ninto clusters which can then have representative files analyzed is a good idea. One effective\nstrategy for this particular data set is to group the files by import hash. Figure 16 shows all\nthe DLLs that share an import hash in descending size of the groups, but excluding single\nmember groups.\n\n\n-----\n\nFigure 16: Files Grouped by Import Hash\n\nEach cluster can then be examined to determine if the members of a cluster are in fact all\ndelivering the same unpacked payload. Figure 17 shows one cluster that has two different\ndetection names according to automation. The fuzzy hash, ssdeep, is also shown as a sanity\ncheck to make sure that the structure of the files in the cluster are nearly the same.\n\nFigure 17: Cluster of Files Sharing One Import Hash\n\n## Two Basic Flavors\n\nAmong all these files, there are two basic flavors of packing. The payload binary is written to\nallocated memory in all cases, but in one case this payload is uncompressed and the other is\ncompressed. The uncompressed payload can simply be dumped directly and then analyzed.\nHowever, in the case of the compressed payload, one needs to determine the compression\n\n\n-----\n\nalgorithm and then decompress the data before analyzing the resulting binary. This can be\ndone a few different ways. First, the unpacker itself will decompress the binary and overwrite\nthe original DLL's module. After that, the DLL can be dumped and analyzed. Alternatively,\none can, as noted earlier, determine the algorithm and decompress the data. However, there\nis an easier, more straightforward method using the Titanium Platform. The first step is to\nopen the DLL in x64dbg and run the executable up to the entry point. From there, one sets a\nbreakpoint at the return instruction in kernel32.VirtualAlloc. This breakpoint is shown in\nFigure 18.\n\nFigure 18: Breakpoint on VirtualAlloc\n\nOnce set, run the file until that breakpoint is reached. When execution is on this return\ninstruction, observe the address of the newly allocated memory in the EAX register. An\nexample of this is shown in Figure 19 with the address of the newly allocated memory\nhighlighted.\n\n\n-----\n\nFigure 19: Newly Allocated Memory\n\nOnce execution has arrived at this point, set one more breakpoint on VirtualProtect. The\nreason for waiting until execution is deep into the unpacker stubs before setting the\nbreakpoint on VirtualProtect is that often there are benign calls to VirtualProtect that one\nwould need to pass over before even getting to the initial VirtualAlloc, and that can get\ntedious.\n\nFor each call to VirtualAlloc, follow that new memory address in x64dbg's dump then run to\nthe next call to VirtualAlloc. Each time examine the new data that is written to the allocated\nmemory. This is where eventually the payload binary is written to. In the first flavor of\nunpacking mentioned above, it will be crystal clear when the MZ magic number along with\nthe DOS stub appear in the allocated memory. However, the second flavor where the\npayload is compressed will also be quite recognizable, if not a bit garbled. An example of this\ncompressed flavor is shown in Figure 20.\n\nFigure 20: Compressed Payload\n\n\n-----\n\nThis is where the Titanium Platform comes in handy. Just dump this memory to a file and\nupload it to the A1000. After it has been analyzed, navigate to the extracted files and drill into\nthe extracted file until the payload DLL is revealed. This extracted DLL is shown in Figure 21.\n\nFigure 21: Decompressed Payload\n\nAnalysis of all the clusters of DLLs in the retro-hunt results in this manner, along with all the\nimport hashes with only one file, reveals that this unpacker code has been used to deliver\nmany malware families over the past year. These families include Ursnif, IceID, DanaBot,\nDridex, Zloader, HanciTor, Valak, and a single example of TrickBot. A full list of file hashes in\nclusters by payload malware family is provided below.\n\n## IOCs\n\nSystemBC Samples\n\nc1d31fa7484170247564e89c97cc325d1f317fb8c8efe50e4d126c7881adf499\n\n6afe08f542426b9662b84907d35870e9714c2755e1da95ed42db33a37aaf33b9\n\nMutex\n\nguessHi\n\nEmail Address\n\n**draskovicnono[@]gmail[.]com**\n\n\n-----\n\nPDB Path\n\n**c:\\lawHeart\\costforward\\pagepushwritten.pdb**\n\n## YARA Rule\n\n[A full list of file hashes in clusters by payload malware family is provided here.](https://f.hubspotusercontent10.net/hubfs/3375217/Blog/Related%20DLLs.pdf)\n\nReferences:\n\n[1https://malpedia.caad.fkie.fraunhofer.de/details/win.systembc](https://malpedia.caad.fkie.fraunhofer.de/details/win.systembc)\n\n\n[2https://news.sophos.com/en-us/2020/12/16/systembc/](https://news.sophos.com/en-us/2020/12/16/systembc/)\n\n3c1d31fa7484170247564e89c97cc325d1f317fb8c8efe50e4d126c7881adf499\n\n\n[4https://en.wikipedia.org/wiki/Program_database](https://en.wikipedia.org/wiki/Program_database)\n\n56afe08f542426b9662b84907d35870e9714c2755e1da95ed42db33a37aaf33b9\n\n\n[6https://ridiculousfish.com/hexfiend/](https://ridiculousfish.com/hexfiend/)\n\n### MORE BLOG ARTICLES\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-01 - Code Reuse Across Packers and DLL Loaders.pdf"
    ],
    "report_names": [
        "2021-04-01 - Code Reuse Across Packers and DLL Loaders.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536028,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653766369,
    "ts_modification_date": 1653766369,
    "files": {
        "pdf": "https://archive.orkl.eu/92a740a3efa96d3130c49db195a5a3f94776f39e.pdf",
        "text": "https://archive.orkl.eu/92a740a3efa96d3130c49db195a5a3f94776f39e.txt",
        "img": "https://archive.orkl.eu/92a740a3efa96d3130c49db195a5a3f94776f39e.jpg"
    }
}