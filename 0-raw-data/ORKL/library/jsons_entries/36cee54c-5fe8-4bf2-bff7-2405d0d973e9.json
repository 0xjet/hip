{
    "id": "36cee54c-5fe8-4bf2-bff7-2405d0d973e9",
    "created_at": "2023-01-12T15:03:02.014776Z",
    "updated_at": "2025-03-27T02:09:30.232849Z",
    "deleted_at": null,
    "sha1_hash": "25926b3fd83dbefd5206807c934d17ebeca138d4",
    "title": "2020-07-23 - Attacking MS Exchange Web Interfaces",
    "authors": "",
    "file_creation_date": "2022-05-28T19:28:18Z",
    "file_modification_date": "2022-05-28T19:28:18Z",
    "file_size": 5811665,
    "plain_text": "# Attacking MS Exchange Web Interfaces\n\n**[swarm.ptsecurity.com/attacking-ms-exchange-web-interfaces/](https://swarm.ptsecurity.com/attacking-ms-exchange-web-interfaces/)**\n\nArseniy Sharoglazov July 23, 2020\n\n## Author\n\n[Arseniy Sharoglazov](https://swarm.ptsecurity.com/author/arseniy-sharoglazov/)\nPenetration Testing Expert\n\n[_mohemiv](https://twitter.com/_mohemiv)\n\nDuring External Penetration Testing, I often see MS Exchange on the perimeter:\n\nExamples of MS Exchange web interfaces\nExchange is basically a mail server that supports a bunch of Microsoft protocols. It’s usually\nlocated on subdomains named autodiscover, mx, owa or mail, and it can also be detected by\nexisting `/owa/,` `/ews/,` `/ecp/,` `/oab/,` `/autodiscover/,` `/Microsoft-Server-`\n```\nActiveSync/, /rpc/, /powershell/ endpoints on the web server.\n\n```\n\n-----\n\nThe knowledge about how to attack Exchange is crucial for every penetration testing team. If\nyou found yourself choosing between a non-used website on a shared hosting and a MS\nExchange, only the latter could guide you inside.\n\nIn this article, I’ll cover all the available techniques for attacking MS Exchange web interfaces\nand introduce a new technique and a new tool to connect to MS Exchange from the Internet\nand extract arbitrary Active Directory records, which are also known as LDAP records.\n\n## Techniques for Attacking Exchange in Q2 2020\n\nLet’s assume you’ve already brute-forced or somehow accessed a low-privilege domain\naccount.\n\nIf you had been a Black Hat, you would try to sign into the Exchange and access the user’s\nmailbox. However, for Red Teams, it’s never possible since keeping the client data private is\nthe main goal during penetration testing engagements.\n\nI know of only 5 ways to attack fully updated MS Exchange via a web interface and not\ndisclose any mailbox content:\n\n**Getting Exchange User List and Other Information**\n\nExchange servers have a url /autodiscover/autodiscover.xml that implements Autodiscover\nPublishing and Lookup Protocol (MS-OXDSCLI). It accepts special requests that return a\nconfiguration of the mailbox to which an email belongs.\n\nIf Exchange is covered by Microsoft TMG, you must specify a non-browser User-Agent in the\nrequest or you will be redirected to an HTML page to authenticate.\n\n[Microsoft TMG’s Default User-Agent Mapping](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ff826797(v=vs.85))\n\nAn example of a request to the Autodiscover service:\n\n\n-----\n\n```\nPOST /autodiscover/autodiscover.xml HTTP/1.1\nHost: exch01.contoso.com\nUser-Agent: Microsoft Office/16.0 (Windows NT 10.0; Microsoft Outlook 16.0.10730;\nPro)\nAuthorization: Basic Q09OVE9TT1x1c2VyMDE6UEBzc3cwcmQ=\nContent-Length: 341\nContent-Type: text/xml\n<Autodiscover\nxmlns=\"http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006\">\n  <Request>\n   <EMailAddress>kmia@contoso.com</EMailAddress>\n<AcceptableResponseSchema>http://schemas.microsoft.com/exchange/autodiscover/outlook/r\n  </Request>\n</Autodiscover>\n\n```\nThe specified in the <EMailAddress> tag email needs to be a primary email of an existing\nuser, but it does not necessarily need to correspond to the account used for the\nauthentication. Any domain account will be accepted since the authentication and the\nauthorization are fully done on IIS and Windows levels and Exchange is only processing the\nXML.\n\nIf the specified email has been accepted, you will get a big response containing a\ndynamically constructed XML. Examine the response, but don’t miss the four following items:\n\n\n-----\n\nAn example of the Autodiscover service’s output\nIn the X-BackEndCookie cookie you will find a SID. It’s the SID of the used account, and not\nthe SID of the mailbox owner. This SID can be useful when you don’t know the domain of the\nbruteforced user.\n\nIn the <AD> and <Server> tags you will find one of Domain Controllers FQDNs, and the\nExchange RPC identity. The DC FQDN will refer to the domain of the mailbox owner. Both\n_<AD> and <Server> values can vary for each request. As you go along, you’ll see how you_\nmay apply this data\n\n\n-----\n\nIn the <OABUrl> tag you will find a path to a directory with Offline Address Book (OAB) files.\n\nUsing the <OABUrl> path, you can get an Address List of all Exchange users. To do so,\nrequest the <OABUrl>/oab.xml page from the server and list OAB files:\n\nGetting access to Offline Address Books\nThe Global Address List (GAL) is an Address Book that includes every mail-enabled object in\nthe organization. Download its OAB file from the same directory, unpack it via the oabextract\ntool from libmspack library, and run one of the OAB extraction tools or just a strings\ncommand to get access to user data:\n\n\n-----\n\nAn example of extracting data via Offline Address Books\nThere could be multiple organizations on the server and multiple GALs, but this function is\nalmost never used. If it’s enabled, the Autodiscover service will return different OABUrl\nvalues for users from different organizations.\n\nThere are ways to get Address Lists without touching OABs (e.g., via MAPI over HTTP in\nRuler or [via OWA or EWS in MailSniper), but these techniques require your account to have](https://github.com/dafthack/MailSniper)\na mailbox associated with it.\n\nAfter getting a user list, you can perform a Password Spraying attack via the same\nAutodiscover service or via any other domain authentication on the perimeter. I advise you\ncheck out [ntlmscan utility, as it contains a quite good wordlist of NTLM endpoints.](https://github.com/nyxgeek/ntlmscan)\n\n**Pros and Cons**\n\nAny domain account can be used\nThe obtained information is very limited\nYou can only get a list of users who have a mailbox\nYou have to specify an existent user’s primary email address\n\n\n-----\n\nThe attacks are well-known for Blue Teams, and you can expect blocking or monitoring\nof the needed endpoints\nAvailable extraction tools do not support the full OAB format and often crash\n\nDon’t confuse Exchange Autodiscover with Lync Autodiscover; they are two completely\ndifferent services.\n\n**Usage of Ruler**\n\nRuler is a tool for connecting to Exchange via MAPI over HTTP or RPC over HTTP v2\nprotocols and insert special-crafted records to a user mailbox to abuse the user’s Microsoft\nOutlook functions and make it execute arbitrary commands or code.\n\nAn example of Ruler usage\nThere are currently only three known techniques to get an RCE in such a way: via rules, via\nforms, and via folder home pages. All three are fixed, but organizations which have no\nWSUS, or have a WSUS configured to process only Critical Security Updates, can still be\nattacked.\n\n[Microsoft Update Severity Ratings](https://www.microsoft.com/en-us/msrc/security-update-severity-rating-system)\n\nYou must install both Critical and Important updates to protect your domain from Ruler’s\nattacks\n\n**Pros and Cons**\n\nA successful attack leads to RCE\nThe used account must have a mailbox\nThe user must regularly connect to Exchange and have a vulnerable MS Outlook\nThe tool provides no way to know if the user uses MS Outlook and what its version is\nThe tool requires you to specify the user’s primary email address\nThe tool requires /autodiscover/ endpoint to be available\nThe tool has no Unicode support\nThe tool has a limited protocol support and may fail with mystery errors\nBlue Teams can reveal the tool by its hardcoded strings and BLOBs, including the\n“Ruler” string in its go-ntlm external library\n\nLink to a tool: [https://github.com/sensepost/ruler](https://github.com/sensepost/ruler)\n\n**Usage of PEAS**\n\n\n-----\n\nPEAS is a lesser-known alternative to Ruler. It s a tool for connecting to Exchange via\nActiveSync protocol and get access to any SMB server in the internal network:\n\nAn example of PEAS usage\nTo use PEAS, you need to know any internal domain name that has no dots. This can be a\nNetBIOS name of a server, a subdomain of a root domain, or a special name like localhost. A\ndomain controller NetBIOS name can be obtained from the FQDN from the <AD> tag of the\nAutodiscover XML, but other names are tricky to get.\n\nThe PEAS attacks work via the Search and ItemOperations commands in ActiveSync.\n\nNote #1\n\nIt’s a good idea to modify PEAS hard-coded identifiers. Exchange stores identifiers of all\nActiveSync clients, and Blue Teams can easily request them via an LDAP request. These\nrecords can be accessible via any user with at least Organization Management privileges:\n\n\n-----\n\nGetting a list of accounts that have used PEAS via LDAP using (msExchDeviceID=123456)\nfilter\nThese identifiers are also used to wipe lost devices or to filter or quarantine new devices by\ntheir models or model families. If the quarantine policy is enforced, Exchange sends emails\nto administrators when a new device has been connected. Once the device is allowed, a\ndevice with the same model or model family can be used to access any mailbox.\n\nAn example of widely used identifiers:\n```\nmsExchDeviceID: 302dcfc5920919d72c5372ce24a13cd3\nmsExchDeviceModel: Outlook for iOS and Android\nmsExchDeviceOS: OutlookBasicAuth\nmsExchDeviceType: Outlook\nmsExchDeviceUserAgent: Outlook-iOS-Android/1.0\n\n```\nIf you have been quarantined, PEAS will show an empty output, and there will be no signs of\nquarantine even in the decrypted TLS traffic.\n\nNote #2\n\n\n-----\n\nThe ActiveSync service supports http/https URLs for connecting to Windows SharePoint\nServices (WSS). This feature can be abused by performing a blind SSRF attack, and you will\nhave an option to authenticate to the target with any credentials via NTLM:\n\nForcing Exchange to make a WSS connection to http://SHP01/test/test/test with\nCONTOSO\\sharepoint-setup account\n\n[An example of a WSS connection: activesync_wss_sample.pcap](https://swarm.ptsecurity.com/wp-content/uploads/2020/07/activesync_wss_sample.pcap)\nThe shown requests will be sent even if the target is not a SharePoint. For HTTPS\nconnections, the certificate will require a validation. As it is ActiveSync, the target hostname\nshould have no dots.\n\n**Pros and Cons**\n\nThe tool has no bugs on the protocol level\nThe tool supports usage of different credentials for each Exchange and SMB/HTTP\nThe tool attacks are unique and cannot be currently done via other techniques or\nsoftware\nThe used account must have a mailbox\nThe ActiveSync protocol must be enabled on the server and for the used account\nThe support of UNC/WSS paths must not be disabled in the ActiveSync configuration\n\n\n-----\n\nThe list of allowed SMB/WSS servers must not be set in the ActiveSync configuration\nYou need to know hostnames to connect\nActiveSync accepts only plaintext credentials, so there is no way to perform the NTLM\nRelay or Pass-The-Hash attack\n\nThe tool has some bugs related to Unicode paths, but they can be easily fixed.\n\nLink to a tool: [https://github.com/FSecureLABS/PEAS](https://github.com/FSecureLABS/PEAS)\n\n**Abusing EWS Subscribe Operation**\n\nExchange Web Services (EWS) is an Exchange API designed to provide access to mailbox\nitems. It has a Subscribe operation, which allows a user to set a URL to get callbacks from\nExchange via HTTP protocol to receive push notifications.\n\nIn 2018, the ZDI Research Team discovered that Exchange authenticates to the specified\nURL via NTLM or Kerberos, and this can be used in NTLM Relay attacks to the Exchange\nitself.\n\n[Impersonating Users on Microsoft Exchange](https://www.thezdi.com/blog/2018/12/19/an-insincere-form-of-flattery-impersonating-users-on-microsoft-exchange)\n\nForcing Exchange to make a connection to http://attacker.com/test/test/test\nAfter the original publication, the researcher Dirk-jan Mollema demonstrated that HTTP\nrequests in Windows can be relayed to LDAP and released the PrivExchange tool and a new\nversion of NTLMRelayX to get a write access to Active Directory on behalf of the Exchange\naccount.\n\n[Abusing Exchange: One API call away from Domain Admin](https://dirkjanm.io/abusing-exchange-one-api-call-away-from-domain-admin/)\n\nCurrently, Subscribe HTTP callbacks do not support any interaction with a receiving side, but\nit’s still possible to specify any URL to get an incoming connection, so they can be used for\nblind SSRF attacks.\n\n**Pros and Cons**\n\nThe used account must have a mailbox\n\n\n-----\n\nYou must have an extensive knowledge of the customer s internal network\n\nLink to a tool: [https://github.com/dirkjanm/PrivExchange](https://github.com/dirkjanm/PrivExchange)\n\n**Abusing Office Web Add-ins**\n\nThis technique is only for persistence, so just read the information by the link if needed.\n\nLink to a technique: https://www.mdsec.co.uk/2019/01/abusing-office-web-add-ins-for-funand-limited-profit/\n\n## The New Tool We Want\n\nBased on the available attacks and software, it’s easy to imagine the tool that will be great to\nhave:\n\nThe tool must work with any domain account\nThe tool must not rely on /autodiscover/ and /oab/ URLs\nThe knowledge of any email addresses must not be required\nAll used protocols must be fully and qualitatively implemented\nThe tool must be able to get Address Lists on all versions of Exchange in any encoding\nThe tool must not rely on endpoints which can be protected by ADFS, as ADFS may\nrequire Multi-Factor Authentication\nThe tool must be able to get other useful data from Active Directory: service account\nnames, hostnames, subnets, etc\n\nThese requirements led me to choose RPC over HTTP v2 protocol for this research. It’s the\noldest protocol for communication with Exchange, it’s enabled by default in Exchange\n2003/2007/2010/2013/2016/2019, and it can pass through Microsoft Forefront TMG servers.\n\n## How RPC over HTTP v2 works\n\nLet’s run Ruler and see how it communicates via RPC over HTTP v2:\n\n**Connection #1**\n\n\n-----\n\nTraffic dump of\n\n\n-----\n\n**Parallel Connection #2**\n\n\n-----\n\nTraffic dump of\n\n\n-----\n\nRuler #2 connection\nRPC over HTTP v2 works in two parallel connections: IN and OUT channels. It’s a patented\nMicrosoft technology for high-speed traffic passing via two fully compliant HTTP/1.1\nconnections.\n\n[The structure of RPC over HTTP v2 data is described in the MS-RPCH Specification, and it](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rpch/c0f4c9c5-1a61-4d10-b8e2-005378d1d212)\njust consists of ordinary MSRPC packets and special RTS RPC packets, where RTS stands\nfor Request to Send.\n\nRPC over HTTP v2 carries MSRPC\n\nThe endpoint /rpc/rpcproxy.dll actually is not a part of Exchange. It’s a part of a service called\n**RPC Proxy. It’s an intermediate forwarding server between RPC Clients and RPC Servers.**\n\nThe Exchange RPC Server is on port 6001 in our case:\n\nAn example of\n\na pure ncacn_http endpoint\nWe will refer to such ports as ncacn_http services/endpoints. According to the specification,\neach client must use RPC Proxies to connect to ncacn_http services, but surely you can\nemulate RPC Proxy and connect to ncacn_http endpoints directly, if you need to.\n\nRPC IN and OUT channels operate independently, and they can potentially pass through\ndifferent RPC Proxies, and the RPC Server can be on a different host as well:\n\n\n-----\n\nThe RPC Server, i.e., the ncacn_http endpoint orchestrates IN and OUT channels, and\npacks or unpacks MSRPC packets into or from them.\n\nBoth RPC Proxies and RPC Servers control the amount of traffic passing through the chain\nto protect from Denial-of-Service attacks. This protection is one of the reasons for the\nexistence of RTS RPC packets.\n\n## Determining target RPC Server name\n\nIn the RPC over HTTP v2 traffic dump, you can see that Ruler obtained the RPC Server\nname from the Autodiscover service and put it into the URL:\n\nTraffic dump of Ruler’s RPC over HTTP v2 connection\nInterestingly, according to the MS-RPCH specification, this URL should contain a hostname\nor an IP; and such “GUID hostnames” cannot be used:\n\n\n-----\n\n[An excerpt from the MS-RPCH specification: 2.2.2 URI Encoding](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rpch/0b7aecea-cd35-436d-9b4b-ae1e1fd5174f)\n[The article by Microsoft RPC over HTTP Security also mentions nothing about this format,](https://docs.microsoft.com/en-us/windows/win32/rpc/rpc-over-http-security)\nbut it shows the registry key where RPC Proxies contain allowed values for this URL:\n```\nHKLM\\Software\\Microsoft\\Rpc\\RpcProxy .\n\n```\n\n-----\n\nAn example of a content of HKLM\\Software\\Microsoft\\Rpc\\RpcProxy key\nIt was discovered that each RPC Proxy has a default ACL that accepts connections to the\nRPC Proxy itself via 593 and 49152-65535 ports using its NetBIOS name, and all Exchange\nservers have a similar ACL containing every Exchange NetBIOS name with corresponding\nncacn_http ports.\n\nSince RPC Proxies support NTLM authentication, we can always get theirs NetBIOS names\nvia NTLMSSP:\n\n\n-----\n\nAn\n\nexample of getting target NetBIOS name via NTLMSSP using nmap\nSo now we likely have a technique for connecting to RPC Proxies without usage of the\nAutodiscover service and knowing the Exchange GUID identity.\n\nBased on the code available in Impacket, I’ve developed RPC over HTTP v2 protocol\nimplementation, rpcmap.py utility, and slightly modified rpcdump.py to verify our ideas and\npave the way for future steps:\n\n\n-----\n\nRunning rpcmap.py for Exchange 2019. The previous version of this tool was contributed to\nImpacket in May 2020.\n\n\n-----\n\nTraffic dump of RPC IN Channel of rpcmap.py\nAlthough rpcmap.py successfully used our technique to connect to the latest Exchange,\ninternally the request was processed in a different way: Exchange 2003/2007/2010 used to\nget connections via rpcproxy.dll, but Exchange 2013/2016/2019 have RpcProxyShim.dll.\n\n**RpcProxyShim.dll hooks RpcProxy.dll callbacks and processes Exchange GUID identities.**\nNetBIOS names are also supported for backwards compatibility. RpcProxyShim.dll allows to\nskip authentication on the RPC level and can forward traffic directly to the Exchange process\nto get a faster connection.\n\nFor more information about RpcProxyShim.dll and RPC Proxy ACLs, read comments in our\nMS-RPCH implimentation code.\n\n## Exploring RPC over HTTP v2 endpoints\n\nLet’s run rpcmap.py with -brute-opnums option for MS Exchange 2019 to get information\nabout which endpoints are accessible via RPC over HTTP v2:\n\n\n-----\n\n```\n$ rpcmap.py debug auth transport CONTOSO/mia:P@ssw0rd auth rpc\n'CONTOSO/mia:P@ssw0rd' -auth-level 6 -brute-opnums 'ncacn_http:\n[6001,RpcProxy=exch01.contoso.com:443]'\n[+] StringBinding has been changed to\nncacn_http:EXCH01[6001,RpcProxy=exch01.contoso.com:443]\nProtocol: [MS-DCOM]: Distributed Component Object Model (DCOM) Remote\nProvider: N/A\nUUID: 00000131-0000-0000-C000-000000000046 v0.0\nOpnums 0-64: rpc_s_access_denied\nProtocol: [MS-DCOM]: Distributed Component Object Model (DCOM)\nProvider: N/A\nUUID: 00000134-0000-0000-C000-000000000046 v0.0\nOpnums 0-64: rpc_s_access_denied\nProtocol: [MS-DCOM]: Distributed Component Object Model (DCOM) Remote\nProvider: N/A\nUUID: 00000143-0000-0000-C000-000000000046 v0.0\nOpnums 0-64: rpc_s_access_denied\nProtocol: [MS-OXABREF]: Address Book Name Service Provider Interface (NSPI) Referral\nProtocol\nProvider: N/A\nUUID: 1544F5E0-613C-11D1-93DF-00C04FD7BD09 v1.0\nOpnum 0: rpc_x_bad_stub_data\nOpnum 1: rpc_x_bad_stub_data\nOpnums 2-64: nca_s_op_rng_error (opnum not found)\nProtocol: [MS-DCOM]: Distributed Component Object Model (DCOM)\nProvider: ole32.dll\nUUID: 18F70770-8E64-11CF-9AF1-0020AF6E72F4 v0.0\nOpnums 0-64: rpc_s_access_denied\nProtocol: [MS-OXCRPC]: Wire Format Protocol\nProvider: N/A\nUUID: 5261574A-4572-206E-B268-6B199213B4E4 v0.1\nOpnum 0: rpc_x_bad_stub_data\nOpnums 1-64: nca_s_op_rng_error (opnum not found)\nProcotol: N/A\nProvider: N/A\nUUID: 5DF3C257-334B-4E96-9EFB-A0619255BE09 v1.0\nOpnums 0-64: rpc_s_access_denied\nProtocol: [MS-OXCRPC]: Wire Format Protocol\nProvider: N/A\nUUID: A4F1DB00-CA47-1067-B31F-00DD010662DA v0.81\nOpnum 0: rpc_x_bad_stub_data\nOpnum 1: rpc_x_bad_stub_data\nOpnum 2: rpc_x_bad_stub_data\nOpnum 3: rpc_x_bad_stub_data\nOpnum 4: rpc_x_bad_stub_data\nOpnum 5: rpc_x_bad_stub_data\nOpnum 6: success\nOpnum 7: rpc_x_bad_stub_data\n\n```\n\n-----\n\n```\nOpnum 8: rpc_x_bad_stub_data\nOpnum 9: rpc_x_bad_stub_data\nOpnum 10: rpc_x_bad_stub_data\nOpnum 11: rpc_x_bad_stub_data\nOpnum 12: rpc_x_bad_stub_data\nOpnum 13: rpc_x_bad_stub_data\nOpnum 14: rpc_x_bad_stub_data\nOpnums 15-64: nca_s_op_rng_error (opnum not found)\nProtocol: [MS-RPCE]: Remote Management Interface\nProvider: rpcrt4.dll\nUUID: AFA8BD80-7D8A-11C9-BEF4-08002B102989 v1.0\nOpnum 0: success\nOpnum 1: rpc_x_bad_stub_data\nOpnum 2: success\nOpnum 3: success\nOpnum 4: rpc_x_bad_stub_data\nOpnums 5-64: nca_s_op_rng_error (opnum not found)\nProcotol: N/A\nProvider: N/A\nUUID: BA3FA067-8D56-4B56-BA1F-9CBAE8DB3478 v1.0\nOpnums 0-64: rpc_s_access_denied\nProtocol: [MS-NSPI]: Name Service Provider Interface (NSPI) Protocol\nProvider: ntdsai.dll\nUUID: F5CC5A18-4264-101A-8C59-08002B2F8426 v56.0\nOpnum 0: rpc_x_bad_stub_data\nOpnum 1: rpc_x_bad_stub_data\nOpnum 2: rpc_x_bad_stub_data\nOpnum 3: rpc_x_bad_stub_data\nOpnum 4: rpc_x_bad_stub_data\nOpnum 5: rpc_x_bad_stub_data\nOpnum 6: rpc_x_bad_stub_data\nOpnum 7: rpc_x_bad_stub_data\nOpnum 8: rpc_x_bad_stub_data\nOpnum 9: rpc_x_bad_stub_data\nOpnum 10: rpc_x_bad_stub_data\nOpnum 11: rpc_x_bad_stub_data\nOpnum 12: rpc_x_bad_stub_data\nOpnum 13: rpc_x_bad_stub_data\nOpnum 14: rpc_x_bad_stub_data\nOpnum 15: rpc_x_bad_stub_data\nOpnum 16: rpc_x_bad_stub_data\nOpnum 17: rpc_x_bad_stub_data\nOpnum 18: rpc_x_bad_stub_data\nOpnum 19: rpc_x_bad_stub_data\nOpnum 20: rpc_x_bad_stub_data\nOpnums 21-64: nca_s_op_rng_error (opnum not found)\n\n```\n[The rpcmap.py works via the Remote Management Interface described in MS-RPCE 2.2.1.3.](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/3165f378-ede3-48a8-b871-be1183e1b7fb)\nIf it’s available, it can show all interfaces offered by the RPC Server. Note that the tool may\nshow non-available endpoints, and provider and protocol lines are taken from the Impacket\ndatabase, and they can be wrong.\n\n\n-----\n\nCorrelating the rpcmap.py output with the Exchange documentation, the next table with a\ncomplete list of protocols available via RPC over HTTP v2 in MS Exchange was formed:\n\n**Protocol** **UUID** **Description**\n\n\n[MS‑OXCRPC](https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxcrpc/137f0ce2-31fd-4952-8a7d-6c0b242e4b6a) A4F1DB00-CA47-1067B31F-00DD010662DA v0.81\n\n[MS‑OXCRPC](https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxcrpc/137f0ce2-31fd-4952-8a7d-6c0b242e4b6a) 5261574A-4572-206E-B2686B199213B4E4 v0.1\n\n[MS‑OXABREF](https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxabref/88c2b896-fe4f-4e28-8a87-e83a73d9c90e) 1544F5E0-613C-11D1-93DF00C04FD7BD09 v1.0\n\n[MS‑OXNSPI](https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxnspi/63662a26-c8fc-4493-a41a-fbcbb7e43136) F5CC5A18-4264-101A8C59-08002B2F8426 v56.0\n\n\nWire Format Protocol EMSMDB Interface\n\nWire Format Protocol AsyncEMSMDB\nInterface\n\nAddress Book Name Service Provider\nInterface (NSPI) Referral Protocol\n\nExchange Server Name Service Provider\nInterface (NSPI) Protocol\n\n\nMS-OXCRPC is the protocol that Ruler uses to send MAPI messages to Exchange, and MSOXABREF and MS-OXNSPI are two completely new protocols for the penetration testing\nfield.\n\n## Exploring MS-OXABREF and MS-OXNSPI\n\nMS-OXNSPI is one of the protocols that Outlook uses to access Address Books. MSOXABREF is its auxiliary protocol to obtain the specific RPC Server name to connect to it via\nRPC Proxy to use the main protocol.\n\nMS-OXNSPI contains 21 operations to access Address Books. It appears to be an OAB with\nsearch and dynamic queries:\n\n\n-----\n\nContents of [the MS-OXNSPI specification](https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxnspi/63662a26-c8fc-4493-a41a-fbcbb7e43136)\nThe important thing for working with MS-OXNSPI is understanding what Legacy DN is. In the\nspecification you will see terms “DN” and “DNs” that seem to refer to Active Directory:\n\n\n-----\n\n[An excerpt from the MS-OXNSPI specification: 3.1.4.1.13 NspiDNToMId](https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxnspi/a4e056f0-7d05-4e6d-8acb-65751e83a071)\nThe truth is, these DNs are not Active Directory DNs. They are Legacy DNs.\n\nIn 1997, Exchange was not based on Active Directory and used its predecessor, X.500\nDirectory Service. In 2000, the migration to Active Directory happened, and for each\nX.500 attribute a corresponding attribute in Active Directory was assigned:\n\n**X.500 Attribute** **Active Directory Attribute**\n\nDXA‑Flags none\n\nDXA‑Task none\n\ndistinguishedName legacyExchangeDN\n\nobjectGUID objectGUID\n\nmail mail\n\nnone distinguishedName\n\n… …\n\nX.500 distinguishedName was moved to legacyExchangeDN, and Active Directory was given\nits own distinguishedName. But, from Exchange protocols point of view, not that much has\nchanged. The protocols were modified to access Active Directory instead of X.500 Directory\nService, but a lot of the terminology and internal features remained the same.\n\n\n-----\n\nI would say X.500 space on top of Active Directory was formed, and all elements with\nlegacyExchangeDN attribute represent it.\n\nLet’s see how it’s done in practice.\n\nI’ve developed the implementation of MS-OXNSPI protocol, but before we use it, let’s\nrequest our sample object via LDAP:\n\nConnecting to Active Directory via LDAP and getting information about a sample user\nAs expected, the distinguishedName field contains the object’s Active Directory\nDistinguished Name, and the legacyExchangeDN field contains a different thing we call\nLegacy DN.\n\nTo request information about this user via MS-OXNSPI, we will use its Legacy DN as a DN,\nas it represents a DN in our imaginary X.500 space:\n\nConnecting to Exchange via MS-OXNSPI and performing the NspiDNToMId operation\n\n\n-----\n\nThe NspiDNToMId operation we called returned a temporary object identifier that works only\nduring this session. We will talk about it in the next section, but for now, just observe that we\npassed Legacy DN as a DN and it worked.\n\nAlso note we have used “Administrator” account and it worked despite the fact that this\naccount doesn’t have a mailbox. Even a machine account would work fine.\n\nLet’s request all the object properties via the obtained temporary identifier:\n\nRequesting the sample object information via MS-OXNSPI\nYou can see we were able to get a lot of properties which do not show up via other\ntechniques (e.g., OAB extracting). Sadly, not all Active Directory properties are here.\nExchange returns only fields of our imaginary X.500 space.\n\nAs the documentation describes operations to get all members of any Address Book, we are\nable to develop a tool to extract all available fields of all mailbox accounts. I will present this\ntool at the end, but now let’s move on since we wanted to get access to whole Active\nDirectory information.\n\n## Revealing Formats of MIDs and Legacy DNs\n\n\n-----\n\nOne of the key terms in MS-OXNSPI is Minimal Entry ID (MId). MIDs are 4-byte integers that\nact like temporary identifiers during a single MS-OXNSPI session:\n\n[An excerpt from the MS-OXNSPI specification: 2.2.9.1 MinimalEntryID](https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxnspi/902ede0d-bb0a-46f0-bf68-03a6ed08d4e8)\nThe documentation does not disclose the algorithm used for MIDs creation.\n\nTo explore how MIDs are formed, we will call NspiGetSpecialTable operation and obtain a list\nof existing Address Books:\n\n\n-----\n\nThe demonstration of usage of NspiGetSpecialTable operation\nIn the output, the PidTagAddressBookContainerId field contains an assigned MId for each\nAddress Book. It’s easy to spot that they are simply integers that are decrementing from\n0xFFFFFFF0:\n\n**MID HEX Format** **MID Unsigned Int Format** **MID Signed Int Format**\n\n0xFFFFFFF0 4294967280 -16\n\n0xFFFFFFEF 4294967279 -17\n\n0xFFFFFFEE 4294967278 -18\n\n… … …\n\nThe 4294967280 number also appeared in the previous section where we requested sample\nuser information. It’s here again because I used a blank session to take this screenshot. If it\nwas the same session, we would get MIDs assigned from 4294967279.\n\n\n-----\n\nTake a look into the PidTagEntryId field in the shown output. It contains new for us Legacy\nDN format:\n```\n/guid=B2D6307C8376CA4DA4CE20E29BB1F2DF\n\n```\nIf you will try to request objects using this format, you will discover you can get any Active\nDirectory object by its objectGUID:\n\nGetting access to a service account’s data by its objectGUID\nThis output shows the other similar Legacy DN format:\n```\n/o=NT5/ou=00000000000000000000000000000000/cn=F24B833B62919948B1D1D2D888CDB10B\n\n```\nSo, we need very little to obtain whole Active Directory data: we must either get a list of all\nActive Directory GUIDs, or somehow make the server assign a MId to each Active Directory\nobject.\n\n## Revealing Hidden Format of MIDs\n\n\n-----\n\nI redrawn the previously used schematic to show how MS-OXNSPI works from the server\nperspective:\n\nExchange does not match or sort the data itself; it’s acting like a proxy. Most of the work\nhappens on Domain Controllers. Exchange uses LDAP and MS-NSPI protocols to connect to\nDCs to access the Active Directory database.\n\nMS-NSPI is the MSRPC protocol that is almost fully compliant with MS-OXNSPI:\n\nContents of the MS-OXNSPI\n\nspecification\n\n\n-----\n\nContents of [the MS-NSPI specification](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nspi/6dd0a3ea-b4d4-4a73-a857-add03a89a543)\n\nThe main difference is that the MS-NSPI protocol is offered by the ntdsai.dll library in the\nlsass.exe memory on DCs when Exchange is set up.\n\nThe MS-NSPI and MS-OXNSPI protocols are even sharing UUIDs:\n\n**Protocol** **UUID**\n\nMS‑NSPI F5CC5A18-4264-101A-8C59-08002B2F8426 v56.0\n\nMS‑OXNSPI F5CC5A18-4264-101A-8C59-08002B2F8426 v56.0\n\nSo, MS-NSPI is the third network protocol after LDAP and MS-DRSR (MS-DRSR is also\nknown as DcSync and DRSUAPI) to access the Active Directory database.\n\nLet’s connect to a Domain Controller via MS-NSPI using our code developed for MSOXNSPI:\n\n\n-----\n\nDetermining MS-NSPI endpoint on a DC and connecting to it\nAnd let’s call NspiGetSpecialTable, the operation we previously used for obtaining a list of\nexisting Address Books, directly on a DC:\n\nCalling NspiGetSpecialTable on a Domain Controller\nThe returning Address Books remain the same, but the MIDs are different. A MId on a\nDomain Controller represents an object DNT.\n\n\n-----\n\n**Distinguished Name Tags (DNTs) are 4-byte integer indexes of objects inside a Domain**\nController NTDS.dit database. DNTs are different on every DC: they are never replicated, but\ncan be copied during an initial DC synchronization.\n\nDNTs usually start between 1700 and 2200, end before 100,000 in medium-sized domains,\nand end before 5,000,000 in large-sized domains. New DNTs are created by incrementing\nprevious ones. According to the Microsoft website, the maximum possible DNT is\n231 (2,147,483,648).\n\n**MIDs on Domain Controllers are DNTs**\n\nThe fact that DCs use DNTs as MIDs is convenient since, in this way, DCs don’t need to\nmaintain an in-memory correspondence table between MIDs and GUIDs for each object. The\ndownside is that an NSPI client can request any DNT skipping the MID-assigning process.\n\n## Requesting DNTs via Exchange\n\nLet’s construct a table with approximate MID ranges we have discovered:\n\n**MID Range** **Used to**\n\n0x00000000 .. 0x0000000F Trigger specific behaviors in specific methods\n(e.g., indicating the end of a table)\n\n0x00000010 .. 0x7FFFFFFF Used by Domain Controllers as MIDs and DNTs\n\n0xFFFFFFF0 .. 0x80000000 Used by Exchange as dynamically assigned MIDs\n\nIt’s clear Domain Controllers MIDs and Exchange MIDs are not intersecting. It’s done on\npurpose:\n\n**Exchange allows proxying DC MIDs to and from the end-user**\n\nThis is one of the ways how Exchange devolves data matching operations to Domain\nControllers. An example of an operation that clearly shows this can be NspiUpdateStat:\n\n\n-----\n\nCalling the NspiUpdateStat operation via MS Exchange\nIn fact, in Exchange 2003, MS-OXNSPI didn’t exist and the future protocol named MSOXABREF returned a Domain Controller address to the client. Next, the client contacted the\nMS-NSPI interface on a DC via RPC Proxy without passing traffic through Exchange.\n\nAfter 2003, NSPI implementation started to move from DCs to Exchange, and you will find\nthe NSPI Proxy Interface term in books of that time. In 2011, the initial MS-OXNSPI\nspecification was published, but internally it’s still based on Domain Controller NSPI\nendpoints.\n\nThis story also explains why we see the 593/tcp port with ncacn_http endpoint mapper on\nevery DC nowadays. This is the port for Outlook 2003 to locate MS-NSPI interface via RPC\nProxies.\n\nIf you are wondering if we can look up all DNTs from zero to a large number as MIDs via\nExchange, this is exactly how our tool will get all Active Directory records.\n\n## The Tool’s Overview\n\nThe exchanger.py utility was developed to conduct all described movements:\n\n\n-----\n\nDisplaying supported attacks in exchanger.py\nThe list-tables attack lists Address Books and can count entities in every one of them:\n\nExample usage of the list-tables attack\n\n\n-----\n\nThe dump-tables attack can dump any specified Address Book by its name or GUID. It\nsupports requesting all the properties, or one of the predefined set of fields. It’s capable of\ngetting any number of rows via one request:\n\nThe help of the dump-tables attack\n\n\n-----\n\nExample usage of the dump-tables attack\nThe guid-known attack returns Active Directory objects by their GUIDs. It’s capable of looking\nup GUIDs from a specified file.\n\nExample usage of the guid-known attack\n\n\n-----\n\nThe dnt-lookup option dumps all Active Directory records via requesting DNTs. It requests\nmultiple DNTs at one time to speed up the attack and reduce traffic:\n\nExample usage of the dnt-lookup attack\nThe dnt-lookup attack supports the -output-file flag to write the output to a file, as the output\ncould be larger than 1 GB. The output file will include, but will not be limited to: user\nthumbnails, all description and info fields, user certificates, machine certificates (including\nmachine NetBIOS names), subnets, and printer URLs.\n\n## The Tool’s Internal Features\n\nThe internal exchanger.py features:\n\nPython2/Python3 compatibility\nNTLM and Basic authentication, including Pass-The-Hash attack\nTLS SNI support; HTTP Chunked Transfer Encoding support\nFull Unicode compliance\nRPC over HTTP v2 implementation tested on 20+ targets\nRPC Fragmentation and RPC over HTTP v2 Flow control\nMS-OXABREF implementation\nMS-NSPI/MS-OXNSPI implementation\n\n\n-----\n\nComplete OXNSPI/NSPI/MAPI fields database\nOptimized NDR parser to work with large-sized RPC results\n\nThe tool doesn’t support usage of the Autodiscover service, since during many penetration\ntests, this service was blocked or it was almost impossible to guess an email to get its\noutput.\n\nWhen Basic is forced or Microsoft TMG is covering the Exchange, the tool will not be able to\nget the RPC Server name from NTLMSSP, or this name will not work. If this happens,\nmanually request the RPC Server name via Autodiscover or find it in HTTP headers, in\nsources of OWA login form, or in mail headers of emails from the server and set it in -rpc_hostname flag:_\n\nExamples of setting -rpc-hostname flag\nIf you are not sure in what hostname the tool is getting from NTLMSSP, use -debug flag to\nshow this information and other useful debugging output.\n\n## The Tool’s Limitations\n\n\n-----\n\nThe tool was developed with support for any Exchange configuration and was tested in all\nsuch cases. However, there are two issues that can occur:\n\n**Issue with Multi-Tenant Configurations**\n\nWhen Exchange uses multiple Active Directory domains, the dnt-lookup attack may crash a\nDomain Controller.\n\nProbably no one has ever used all the features of MS-NSPI, especially on Global Catalog\nDomain Controllers, and the ntdsai.dll library may throw some unhandled exceptions which\nresult in lsass.exe termination and a reboot. We were unable to consistently reproduce this\nbehavior.\n\nThe list-tables, dump-tables and guid-known attacks are safe and work fine with Exchange\nMulti-Tenant Configurations.\n\n**Issue with Nginx**\n\nIf MS Exchange is running behind an nginx server that was not specially configured for\nExchange, the nginx will buffer data in RPC IN/OUT Channels and release them by 4k/8k\nsize blocks. This will break our tool and MS Outlook as well.\n\nWe’d probably can develop a workaround for this by expanding RPC traffic with unnecessary\ndata.\n\n## Getting The Tool\n\nThe exchanger.py tool, and rpcmap.py and rpcdump.py utilities are now avaliable in the\n[official Impacket repository: https://github.com/SecureAuthCorp/impacket](https://github.com/SecureAuthCorp/impacket)\n\nThanks [@agsolino for merging!](https://twitter.com/agsolino)\n\nI hope we’ll see an offline OAB unpacker and MS-OXCRPC and MAPI implementation with\nat least Ruler functions in exchanger.py in the future.\n\n## Mitigations\n\nWe recommend that all our clients use client certificates or a VPN to provide remote access\nto employees. No Exchange, or other domain services should be available directly from the\nInternet.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-07-23 - Attacking MS Exchange Web Interfaces.pdf"
    ],
    "report_names": [
        "2020-07-23 - Attacking MS Exchange Web Interfaces.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535782,
    "ts_updated_at": 1743041370,
    "ts_creation_date": 1653766098,
    "ts_modification_date": 1653766098,
    "files": {
        "pdf": "https://archive.orkl.eu/25926b3fd83dbefd5206807c934d17ebeca138d4.pdf",
        "text": "https://archive.orkl.eu/25926b3fd83dbefd5206807c934d17ebeca138d4.txt",
        "img": "https://archive.orkl.eu/25926b3fd83dbefd5206807c934d17ebeca138d4.jpg"
    }
}