{
    "id": "bd19d624-dfa7-4deb-84f5-cbbf92f34413",
    "created_at": "2023-01-12T15:02:24.007337Z",
    "updated_at": "2025-03-27T02:08:40.798448Z",
    "deleted_at": null,
    "sha1_hash": "e731a7c4c4a0042e5a80e9311d79cedbd38cd192",
    "title": "Anti-emulation trends in modern packers",
    "authors": "",
    "file_creation_date": "2017-02-13T20:03:25Z",
    "file_modification_date": "2017-02-13T19:55:12Z",
    "file_size": 603166,
    "plain_text": "DOI 10.1007/s11416 017 0291 9\n\n\nORIGINAL PAPER\n\n\n# Anti-emulation trends in modern packers: a survey on the evolution of anti-emulation techniques in UPA packers\n\n**C˘at˘alin Valeriu Li¸t˘a[1]** **· Doina Cosovan[1]** **· Drago¸s Gavrilu¸t[1]**\n\nReceived: 28 May 2016 / Accepted: 22 January 2017\n© Springer-Verlag France 2017\n\n\n**Abstract Writing modern day executable packers has**\nturned into a rather profitable business. In many cases, the\nreason for packing is not protecting genuine applications\nagainst piracy or plagiarism, but rather avoiding reverseengineering and detection of malicious samples. Unlike\ndevelopers, which show moderate interest for using a packer\nand lack time and resources for creating one, malware creators show a huge interest and are willing to spend large\namounts of money to use this technology (especially if it\noffers protection against security solutions). This happens\nmainly because protecting from piracy and plagiarism isn’t\nthat profitable as spreading new and undetected malware on\nas many computers as possible. Consequently, creating a custom packer designed to avoid malware detection has grown\ninto a very profitable business.\nHowever, developing a good packer is not an easy task\nto accomplish. Novel techniques of achieving anti-static\nanalysis, anti-virtual machine, anti-sandbox, anti-emulation,\nanti-debugging, anti-patching, and so on, have to be discovered and added regularly. From the malware creator’s\nperspective, this must happen frequently enough so that the\nupdates are issued shortly after malware researchers analyze and bypass the existing mechanisms because, once these\ntechniques are bypassed, the detection rate increases in the\ncase of the malware samples packed with the old version of\nthe packer.\nIn this paper, we present our findings which resulted from\n\n## B Doina Cosovan\ndoina.cosovan@info.uaic.ro\n\nC˘at˘alin Valeriu Li¸t˘a\ncatalin.lita@info.uaic.ro\n\nDrago¸s Gavrilu¸t\ndgavrilut@bitdefender.com\n\n1 Alexandru Ioan Cuza University, Iasi, Romania\n\n\nclosely monitoring the fight between malware researchers\nand packer developers during a period of almost two years.\nWe focus on three different packers used for prevalent malware families like Upatre, Gamarue, Hedsen. We named\nthose packers UPA 1, UPA 2, and UPA 3 and we discuss the\nmechanisms used in them to achieve anti-emulation. Each\ntechnique is presented by listing the code and explaining the\ninner workings in details. In the end, we manage to get a\ngrasp of the current trends in achieving anti-emulation when\ndeveloping modern packers.\n\n**Keywords Malware · Packer · Reverse-engineering ·**\nAnti-emulation\n\n### 1 Introduction\n\nMalware, just like any other software, started as a plain code\nprogram. As this kind of code is really simple to detect, it has\nbecome clear that other means for hiding a program’s true\nintentions had to be developed. Thus malware creators started\nto encrypt the malware body. This lead malware researchers\nto switch the pattern matching detection signatures from the\nmalware body to the malware decryptor, as the latter was\nstatic and written in plain code.\nAs a consequence, two different techniques emerged in\norder to protect the malicious code: oligomorphism and\npolymorphism. While oligomorphic malware uses different\ndecryptors, polymorphic malware uses the same decryptor,\nchanged with the help of various techniques like register\nswapping, routine permutation, code reordering, equivalent\ncode substitution, and code transposition. The use of these\noperations can change a piece of code in a way that it becomes\nunrecognizable even to human eye.\n\n\n-----\n\nSince it is not feasible to search all decryptors used in the\nwild in case of oligomorphism nor to generate all possible\ndecryptors in case of polymorphism, the emulators started\nto be used for malware detection in order to dynamically\nexecute the decryptor and obtain the decrypted virus body.\nBecause the virus body is unchanged or rather similar, the\npattern matching signatures can trigger the detection on the\ncontent obtained after emulation.\nAlso, obtaining the original code of the payload is important for reverse engineering the malicious code in order to\nget an understanding regarding the malware inner workings.\nThis is usually the first step when cleaning an affected computer or taking down a botnet.\nAs a reaction to the appearance of code emulators, malware creators started to develop anti-emulation mechanisms\nin order for the sample to be able to realize it is running in\nan emulator and to stop decrypting the malicious body.\nBesidesanti-emulation,variousanti-virtualmachine,antisandbox, anti-debugging, and anti-disassembly techniques\nstarted to be developed. Some groups specialized particularly in protection against payload extraction, others in\nvarious anti-disassembly mechanisms, and so on. Thus building packers became a profitable industry on its own.\nSince anti-sandbox, anti-debugging, anti-virtual machine,\nand anti-disassembly mechanisms have been widely covered\nin the literature, we focus on less studied anti-emulation\ntechniques. We also cover the context in which these antiemulation techniques are used and we monitor the changes\nthey undergo as packer creators adapt to advances made in\nthe emulator evolution by the security solutions.\nThis paper is structured as follows. The Section 2 presents\nthe papers that studied and detailed the anti-sandbox, antidebugging,anti-virtualmachine,andanti-disassemblymechanisms that we will further refer as anti-* techniques. The\nSections 3, 4, and 5 cover the evolution of the anti-emulation\ntechniques for the UPA 1, UPA 2, and respectively UPA 3\npackers. In the end, in Section 6, we conclude by discussing\nthe difficulty of implementing and bypassing the presented\nanti-emulation techniques as well as the strategies used by\neach of the packers in order to achieve their goals.\n\n### 2 Related work\n\n**2.1 Anti-* techniques**\n\nAnti-virtual machine, anti-sandbox, anti-debugging, and\nanti-disassembly techniques have been studied extensively\nin the literature. A few papers detailing them are presented\nas follows.\nThe authors in [1] present an overview of malware protection mechanisms directed against disassemblers, debuggers\nand virtual machines. 34 anti-debugging, 5 anti-disassembly,\n\n\n10 obfuscation, and 3 anti-virtual machine techniques are\nanalyzed in detail. Detection mechanisms are proposed\naccordingly in order to automatically search those specific\ntechniques through a collection of more than 4 million samples and provide statistics. Also, statistics regarding the used\npackers are provided. Our research focuses on the antiemulation techniques instead.\nIn [2], software armoring techniques like packers, runtime obfuscations, virtual machine and debugger detectors\nare presented with the help of a newly developed platform,\ncalled Saffron. It makes use of dynamic instrumentation and\npage fault assisted debuggers in order to achieve its task.\n\n[3] comprises a study on anti-virtual machine, antisandbox, and anti-debugger techniques currently used by\nmalicious samples like Zeus, SpyEye, SpyRat in order to\ntarget specific operating systems (Windows XP, Windows\nVista, Windows 7), virtual machines (VMWare, Virtual Box),\ndebuggers (SoftICE), and sandbox solutions (Sandboxie,\nAnubis, GFI CWSandbox, JoeBox, Norman Sandbox). The\ntechniques are discussed in detail and real world case studies\nare presented.\n\n[4] provides a taxonomy of anti-sandbox techniques: artifact fingerprinting (related processes, environment specific\nfiles, registry keys, I/O ports, devices and its attributes), execution environment fingerprinting, timing detection. Also, a\nsystem, called TENTACLE, is presented. Its purpose is to\nautomatically discover anti-sandbox techniques. The malicious samples are executed over and over again. Every time,\nthey are expected to take different paths as, at each execution,\nvarious sandbox / virtual machine related artifacts are camouflaged. With the help of CEI (Code Execution Integrity),\nexecution branches are detected. In the end, it is supposed to\nidentify unnatural process terminations, which are expected\nto be anti-sandbox mechanisms.\nIn [5], the authors consider an unpacker to be one of\nthe following: a memory-dumper, a debugger, an emulator,\nor an Write-Execute interceptor. The paper covers various\nways of tricking each of these perspectives, cumulating more\nthan 30 trick categories. The author continues its research\nin a series of 9 articles, containing description and countermeasures for anti-dumping, anti-debugging, anti-emulating,\nanti-disassembly, and other miscellaneous tricks.\n\n[6] contains a survey presenting debugger detection\nand attacks, software / hardware breakpoint and patching\ndetection, anti-analysis, anti-disassembly, and other tricking\nmechanisms (process injection, debugger blocker, TLS callbacks, stolen bytes, multi-threaded packers, API redirection,\nand virtual machines).\n\n[7] covers common unpacking methods in an AntiMalware engine, ways of tricking various types of unpacking\n(static unpacking, emulator unpacking, both mixed routine and emulator-based unpacking), and defenses against\nthem.\n\n\n-----\n\n**2.2 Anti-debugging techniques**\n\nSome examples of papers that focus on anti-debugging are\ndetailed below.\n\n[8] presents an enormous collection of anti-debugging\ntechniques at different levels (hardware, process-level,\nsystem-level, user-interface) regarding different aspects\n(APIs,executiontiming,uncontrolledexecution,flags,heap).\nBoth detailed description and code are provided where necessary.\n\n[9] classifies and presents various anti-debugging techniques used on Windows NT-based operating systems, focusing more on changes at the process level.\n\n[10] provides an overview of the debugging mechanism\nin Windows, a classification of the most prevalent debuggers according to the debugging methods they use, and a\ndescription of anti-debugging strategies which makes use of\ndebugging API, special debug structures, and exceptions.\nIn [11], the authors developed a taxonomy of malware evasion techniques, focusing on anti-virtualization and\nanti-debugging behavior (hardware, execution environment,\napplication). The prevalence of these techniques is analyzed\nby executing 6900 distinct malware samples in three different\nenvironments: in real systems, in virtual machines, and with\na debugger attached. In the end, a mechanism is developed,\nwhich protects plain machines by simulating a monitored\nenvironment.\nWhile some papers present anti-debugging techniques as\nactions taken by cyber-criminals in order to harden malware analysis and struggle to find ways of automatically\ndetectingandmitigatingthem, other papers present thedeveloper’s view on the matter. Specifically, these mechanisms are\nanalyzed in the light of helping developers to protect their\ncode, as in [12]. In this paper, a few API-based, registrybased, hardware-based, timing-based, and exception-based\nanti-debugging techniques are presented along with some\nways to automatically detect modified code and directly\naccess process and thread blocks containing details about\nthe running process.\nAnother paper aiming at protecting software through\nanti-debugging techniques is [13]. The proposed solution,\nSPAD, implements the most popular 13 software-only antidebugging methods. It was tested and proved successful with\n8 widely used debuggers, including user-mode debuggers\nlike HideOD, OllyDbg, StrongOD, Phantom, and Ollyice;\nkernel debuggers like WinDbg; and system-level debuggers\nlike Syser, SoftICE.\nTheauthorsin[14],havealsodevelopedananti-debugging\nframework, that unlike [13], is based on hardware virtualization technology. It provides solutions against software and\nhardware breakpoints, but also protects the target process\nfrom being accessed by other processes.\n\n\n**2.3 Anti-disassembly techniques**\n\nThe following papers present an interest in anti-disassembly\ntechniques.\nThe authors in [15], came up with mechanisms used to\nthwart the disassembly process, like junk insertion, thwarting\nlinear sweep, thwarting recursive traversal (branch functions,\ncall conversion, opaque predicates, jump table spoofing).\nThese were tested against 2 widely used static disassembly\nalgorithms and they failed to correctly disassemble 65% of\nthe instructions and 85% of the functions.\nA technique, based on dynamic code generation at runtime, is proposed in [16].\nIn [17], authors propose a few techniques regarding binary\nanalysis, based on control flow graph information and statistical methods, in order to improve the disassembly process of\nmalicious samples that make use of anti-disassembly techniques.Interestingly,theauthorshaveobserved4mainwrong\nassumptions made by most disassemblers, which allows for\nthem to be tricked in incorrectly disassembling samples:\nvalid instructions must not overlap, conditional jumps can\neither be taken or not taken, an arbitrary amount of junk\nbytes can be inserted at unreachable locations, and the control flow does not have to continue immediately after a call\ninstruction. They also propose and test solutions for these\nproblems.\n\n**2.4 Anti-virtual machine techniques**\n\nResearch related to anti-virtual machine mechanisms is presented in the following papers.\nIn [18], the authors discuss a few attacks on virtual\nmachineemulatorsforVMWare,VirtualPC,Parallels,Bochs,\nHydra, QEMU, and Xen. The presented attacks aim at detecting the virtual machine (in order for the malware to stop\nperforming the malicious actions while executed in a virtual\nenvironment), and performing denial of service (causing the\nvirtual environment to crash). In the end, a few recommendations are provided in order to protect against some of the\npresented attacks. The author continues his work in [19], discussing even more detection techniques, attacks, and defense\nmechanisms for the virtual machine emulators discussed in\nits previous paper, but also analyzing a few more: Hydra,\nSandbox, VirtualBox, CWSandbox.\nIn [20], the security level of using virtual machines is analyzed. A virtual machine is considered to be “root secure” if\nno level of privilege within the virtualized guest environment permits interference with the host system. The analysis\nwas performed by analyzing the source code in case of\nopen-source emulators and black-box testing based on fuzz\ntechnique for proprietary software products. As tools, they\nused mainly crashme for stress testing and iofuzz for fuzz\n\n\n-----\n\ntesting. In the end, various vulnerabilities have been discovered for QEMU, VMware Workstation and Server, Bochs,\nXen, and two other undisclosed virtual machines.\nIn [21], the author presents some security flaws that are\nunique to virtual environments and which can be used to\nexploit any virtualization technology. These include communication between VMs or between VM and host, VM Escape,\nVM monitoring from the host, VM monitoring from another\nVM, Denial of Service, Guest-to-Guest attack, external modification of a VM, external modification of the hypervisor.\nIn [22], a way to detect the presence of a virtual machine\nusing the local data table is described. While [23] illustrates a\nfew virtual machine detection methods and introduces DSD\ntracer, a malware analysis framework that integrates static\nand dynamic analysis.\n\n_2.4.1 Anti-emulation techniques_\n\nMany advances related to the anti-virtual machine, antisandbox, anti-debugging, and anti-disassembly techniques\nhave been accomplished and information is readily available.\nThe anti-emulation mechanisms, however, were covered\nonly partly in a small number of papers, presented as\nfollows.\nIn [24], authors seek to answer the question whether system emulators, which handle instructions in software, are\nmore difficult to detect than traditional virtual machines. In\norder to find the answer, various mechanisms of detecting\nsystem emulators are discussed, which involve analyzing differences in behavior, timing, and hardware specific values.\nIn [25], an anti-anti-emulation system is proposed. It monitors the changes performed by the emulator and repairs\nthe differences. The anti-emulation checks addressed in this\npaper involve timing attacks, CPU semantics attacks, and\nhardware characteristic attacks.\nThe [26] is an overview of the rogue malware in the past\nyears.Sincetheyalsopresentafewinterestinganti-emulation\ntechnique used by this malware category, this paper is also\nrelevant to our research.\nThe paper [7] explains very shortly the implications that\narise on executing, in an emulated environment, of samples\nusing modern or undocumented CPU instructions, fake API\ncalls, structured exception handling, and long loops. Various\nmechanisms of bypassing the conditions used to decide when\nto stop the emulation process are discussed as well.\nThe most extensive and detailed explanation of various\nanti-emulation techniques is presented in [5]. Mechanisms\nlike unimplemented or undocumented instructions, unimplemented or internal APIs, invalid API parameters, software\ninterrupts, time locks, selector verification, memory layout\nand file format tricks are discussed emphasizing their impact\non emulators.\n\n\n### 3 UPA 1 packer\n\nUPA 1 is an advanced packer, used by prevalent malware like\nthe Upatre downloader, Gamarue worm, Hedsen spammer\nand others. We started analyzing this packer’s evolution when\nthe first samples were identified, in May 2013, and continued\nupuntiltheendof2015.Interestingly,thepackerwasbundled\nwith various and complex anti-emulation techniques from the\nbeginning, continuing to add even more, month after month.\nThis advertises the packer creators as experts in the field.\nDuring the entire UPA 1 evolution we have been monitoring, the mechanisms used to encrypt the payload remained\nfairly constant and consisted in a combination of base64,\nRTL compression, and a simple encryption (for example, the\nXOR operation using a 1-byte key). In this section, we will\npresent the most important anti-emulation techniques used\nby this packer to prevent a security solution from detecting\nits payload.\n\n**3.1 Rare instructions**\n\nEmulators implement many assembly instructions, but not all\nof them. Thus, if a packer is using a rare assembly instruction,\nthe emulator will not be able to process it and the payload\nwill not be decrypted. An example of rare instruction usage\ncan be seen in Listing 1.\n\n**Listing 1 Using Rare Instructions**\n\nmovq mm1, qword ptr [ **ebp+var_4 ]**\nmovq **qword ptr [ esp ], mm1**\n\n**3.2 Rare API functions**\n\nSimilarly, the emulators implement only widely used API\nfunctions. Calling obscure or even undocumented API functions cause an abrupt termination of the application when\nexecuted in the emulator. UPA 1 uses the not so common\nCryptStringToBinary API function to decrypt a base64encrypted buffer.\n\n**3.3 PEB structure**\n\nThe PEB structure [1] is usually parsed by malware creators in\norder to obtain the image base of loaded libraries or to detect\ndebugger presence by checking the value of the NtGlobalFlag. The second technique is illustrated in Listing 2.\n\n**Listing 2 Checking NtGlobalFlag from PEB Structure**\n\n**mov** **eax, PEB_pointer**\n**push** **eax**\n\n[1 https://msdn.microsoft.com/en-us/library/windows/desktop/](https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx)\n[aa813706(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx)\n\n\n-----\n\n**mov** **eax, [ eax+68h]** _; NtGlobalFlag_\n**and** **al, 70h**\n**cmp** **al, 70h**\n**jz** **short debugger_not_present**\n\nAlthough the main purpose of this technique is to detect\ndebugger’s presence, it acts as anti-emulation as well because\nthe emulators may not have an exact implementation of the\nPEB structure.\n\n**3.4 TLS callbacks**\n\nIf the emulator doesn’t know that it must run a TLS callback before running the code from the entry point, then the\nexecution might differ from the intended one.\nThis packer registers the TLS callback TlsCallback_0,\nwhich executes the following actions:\n\n– detect debugger presence by checking the NtGlobalFlag\nvalue from PEB\n– parse LDR_DATA from PEB structure to get the image\nbase of kernel32 and ntdll libraries\n– decrypt the name and get the address of the RtlDecompressBuffer function\n– decrypt the name and get the address of the ZwUnmapViewOfSection function\n\nThe TLS callback computes the addresses of the kernel32 and ntdll libraries and of the RtlDecompressBuffer\nand ZwUnmapViewOfSection functions, which are used in\nthe code from the entry point. If the TLS callback is not executed before the main function, the sample will try to use\nthose addresses, which are not properly initialized in this\ncase, and will crash.\n\n**3.5 Windows API results**\n\nChecking the return value of a specific Windows API\nfunction, called with specific parameters, is another antiemulation technique implemented by UPA 1. It is illustrated\nin Listing 3.\n\n**Listing 3 Checking Return Value of API Call**\n\nno_handle = FindWindowA(&ClassName,\n\"nngrohcebymvibaqcwvq dmsbqon\" )\n**i f ( OpenClipboard ( no_handle ))**\n{\nunpack_and_execute_payload ( ) ;\n}\n\nFirst, the FindWindowA function is called with a random window name. If it is correctly implemented, then it\nwill fail and will return NULL. Then, its result is passed\n\n\nas a parameter to the OpenClipboard function. The OpenClipboard function succeeds if either the passed parameter\nis a valid handle or NULL. In case OpenClipboard function\nsucceeds, the sample will continue by unpacking and executing the payload. Otherwise, if the FindWindowA function is\nincorrectly implemented and returns a value different from 0,\nwhich is not a valid handle, then OpenClipboard will fail and\nthe program will finish its execution. The same thing happens\nif OpenClipboard is incorrectly implemented, failing when\nreceiving NULL as parameter.\n\n**3.6 FastPebLockRoutine callback**\n\nThis trick starts by extracting the operating system version\nfrom the PEB structure. If it matches Windows XP or Windows 2000, it sets the FastPebLockRoutine’s field from the\nPEB structure to a pointer to a callback function. By calling RtlAcquirePebLock, it causes the callback function to\nbe executed. In case of newer operating systems, the callback function is called directly, without the entire mechanism\nof FastPebLockRoutine. The execution flow is illustrated in\nListing 4.\n\n**Listing 4 Registering FastPebLockRoutine Callback**\n\n**i f (is_WinXP () or is_Win2000 ( ) )**\n{\nregister_callback (\nFastPebLockRoutine,\ncallback_function ) ;\nRtlAcquirePebLock ( ) ;\n}\n**else**\n{\ncallback_function ( ) ;\n}\n\nMost probably, the Anti-Virus emulators are running a\nWindows system matching one of the two specified versions.\nIf the sample is executed on an operating system usually\nused by the emulators, then, instead of executing the function\ndirectly, it is set as callback in the PEB structure. Thus the\nfunction is not executed if the emulator doesn’t implement\nthis specific callback mechanism.\nThe callback for the FastPebLockRoutine decrypts the\nencrypted payload and injects it into a newly created process.\nConsequently, ignoring the callback means not executing the\npayload.\n\n**3.7 SecureMemoryCache callback**\n\nThis technique is similar to the previous one. It registers a callback function by calling RtlRegisterSecureMemoryCacheCallback. Next it calls RtlFlushSecureMemoryCache in order to trigger the registered callback function.\n\n\n-----\n\nAn emulator won’t execute the callback until it implements\nthis specific mechanism.\n\n**3.8 TopLevelExceptionFilter callback**\n\nThe function to be executed next is registered as the\nTopLevelExceptionFilter handler by calling the SetUnhandledExceptionFilter function, as illustrated in Listing 5.\n\n**Listing 5 Setting UnhandledExceptionFilter Callback**\n\nSetUnhandledExceptionFilter (\nTopLevelExceptionFilter_handler ) ;\n\n**int TopLevelExceptionFilter_handler (**\nEXCEPTION_POINTERS ∗ ExceptionInfo )\n{\nexception_record =\nExceptionInfo[0]−>ExceptionRecord ;\nRtlFlushSecureMemoryCache (\n&memory_cache, memory_length ) ;\n**return 1;**\n}\n\nThen, in a newly created thread, an exception is generated by design. The generated exception triggers the\nTopLevelExceptionFilter_handler function that was previously registered. The callback function calls RtlFlushSecureMemoryCache that triggers another callback function,\nas described in the previous technique.\n\n**3.9 Window creation callback**\n\nA WindowClass is registered by calling RegisterClassExA.\nIt has a field called wnd_proc, which can be initialized with\nthe address of a function to be triggered after the CreateWindowExA function is called. Emulators don’t usually call the\nwnd_proc function.\nAtthebeginningoftheyear2015,theUPA1packeradded,\nfor a short period of time, a new anti-emulation technique.\nSpecifically, when calling the window procedure, with the\nWM_CREATE message, the function expects the EBX register to have the value 0. Based on the EBX register value, it\ncomputes the location where the address of an API function,\ncalculated by CRC, will be saved, as presented in Listing 6.\n\n**Listing 6 Saving API address**\n\n**mov** [ **ebx+edx** ∗4], eax\n\nIf the EBX register has a value different than 0 when the\nfunction is called, then the location where the API function\naddress is saved will be dependent on that value. Being saved\nat a different address, the old value from the intended location\nwill be called later on, causing a crash.\n\n\n**3.10 Big loops**\n\nUPA 1 makes use of big loops with millions of iterations. This\ntechnique is not new, but still an effective one. It undergoes\nmany changes during the 2015 year.\nInMarch2015,itjustcallsafunctionwithECXcontaining\nthe number of loops, as illustrated in Listing 7.\n\n**Listing 7 Big Loops in March 2015**\n\n**mov** **ecx, 6.110.179**\n**call** big_loop_calling_IsDebuggerPresent\n\nIn June 2015, it uses two big loops, one with an API call\nand the other without an API call, as can be observed in\nListing 8.\n\n**Listing 8 Big Loops in June 2015**\n\n**mov** **ecx, 6.791.700**\n**call** just_big_loop\n**mov** **ecx, 6.791.701**\n**call** big_loop_calling_IsDebuggerPresent\n\nIn July 2015, it started to execute sqrt and rol in one of the\nbig loops in order to vary the instructions. This is presented\nin Listing 9.\n\n**Listing 9 Big Loops in July 2015**\n\nv3 = 199.990 ;\ndo\n{\nr esul t = sqrt ( r esul t ) ;\na2 = __ROL__(a2, 96) ;\n−−v3 _;_\n} while (v3) ;\n\n**mov** **ecx, 32.782.721**\n**call** big_loop\n\nIn August 2015, the number of iterations sqrt is called is\nsignificantly increased, as can be observed from Listing 10.\n\n**Listing 10 Big Loops in August 2015**\n\nv5 = 19.999.990 ;\ndo\n{\nr esul t = sqrt ( r esul t ) ;\n−−v5 _;_\n} while (v5) ;\n\n**mov** **ecx, 6.791.700**\n**call** big_loop\n\nIn September 2015, a test is added after the call of the\nfunction containing the big loop: specifically it tests if the\nECX register gets to have the value 0 after the execution of the\nloop. According to Listing 11, this is achieved by adding the\n\n\n-----\n\nvalue of the ECX register to the address of the next function\nto be called. In case ECX is zero, the execution will continue\nsuccessfully. Otherwise, the execution will be unpredictable,\nexecuting from the computed address.\nThis seems to be a defense against emulators trying to\nbypass the big loops. If an emulator observes the same\ninstructions being executed over and over again, it can draw\nthe conclusion that it is executing a garbage big loop and\nit can exit the loop early. If this happens, ECX will end up\nhaving a value different than zero as this register is used to\ncount the iterations decreasingly.\n\n**Listing 11 Big Loops in September 2015**\n\n**mov** **ecx, 9.999.999**\n**call** big_loop\n**lea** **eax, sub_4024CF**\n**add** **eax, ecx**\n**call** **eax**\n\nIn November 2015, the big loop is no longer a function\nbeing called, but integrated in the calling code, as illustrated\nin the Listing 12.\n\n**Listing 12 Big Loops in November 2015**\n\n**mov** **edx, 998.261**\n**dec** **edx**\n**jnz** loc_403D36\n\n### 4 UPA 2\n\nIn order to illustrate the evolution of the anti-emulation techniques used by the UPA 2 packer, we monitored the updates\nit issued during the past year. This packer was mostly used\nby the Upatre downloader. Its first appearance dates to the\nbeginning of 2015.\n\n**4.1 Stack check**\n\nShortly after the process starts its execution, the first antiemulation technique is put in place. It consists in checking\nthe stack address. Specifically, if the last WORD of the value\nstored in the ESP register is less than 0xFF00, then the program terminates the execution, as illustrated in Listing 13.\n\n**Listing 13 Checking Stack Address**\n\n**mov** **eax, 0**\n**add** **eax, esp**\n**add** **bx, 1**\n**push** 0FFh\n**pop** **ecx**\n**rol** **ecx, 8**\n**mov** **si, ax**\n**cmp** **si, cx**\n\n\n**ja** continue\n**mov** **eax,** **offset TerminateThread**\n**push** 0\nretn\n\nThe execution is terminated differently in different samples:\n\n– execute an int 3, issuing an exception;\n– start executing from address 0, causing access violation;\n– jump to an address containing invalid instructions, causing a crash;\n– jump to an invalid address, causing an access violation;\n– infinitely loop over this check without changing the stack\naddress;\n– return;\n\nIn the middle of the year, the ESP register was changed\nwith EBP and two months later the change was reverted.\nTowards the end of the year, the value was increased to\n0xFF01.\nAfterwards, the logic was changed so that if the last byte\nof ESP is smaller than or equal to 2, then the program returns.\nAnd, in the end, this technique was dropped altogether.\n\n**4.2 Flag check**\n\nAnother anti-emulation technique that checks the state of\nthe process at the beginning of execution consists in checking whether the ZF flag is set when the process is started.\nListing 14 contains the first 5 instructions executed by the\nsample.\n\n**Listing 14 Checking ZF Flag**\n\n**push** **edx**\n**pop** **ebx**\n**mov** **ecx, edx**\n**mov** **ebp, esp**\n**jz** no_anti_1\n\nSincepush,popandmovaretheonlyexecutedinstructions\nand they do not change any flags, we can assume this check\nallows for an emulator detection. If the ZF flag is set then the\nsize of the stack is no longer checked.\n\n**4.3 Registry state after API calls**\n\nAnother anti-emulation technique consists in checking\nwhether the values of particular registers are being changed\nafter calling specific Windows API functions. This packer\nimplements this method in three different ways.\nFirst, it initializes the ecx register with the value 2, calls\nthe GetACP function, and then expects ecx to be different\nfrom zero, as illustrated in Listing 15.\n\n\n-----\n\n**Listing 15 Checking Register Value after API Call**\n\n**mov** **ecx, 2**\n**call** **ds :GetACP**\n**test** **ecx, ecx**\n**jnz** no_anti_1\nretn\n\nSecond, it initializes the ecx register with 0, calls the GetSystemDirectoryA function, and expects ecx to be different\nfrom zero (Listing 16).\n\n**Listing 16 Checking Register Value after API Call**\n\n**mov** **ecx, 0**\n**call** **eax ; GetSystemDirectoryA**\n**test** **ecx, ecx**\n**jnz** no_anti_3\nretn\n\nThird, it initializes ecx with 0, calls the function CreateFileA, and expects ecx to have a value different from 0\n(Listing 17).\n\n**Listing 17 Checking Register Value after API Call**\n\n**xor** **ecx, ecx**\n**mov** **eax, [ eax ]**\n**call** **eax ; CreateFileA**\n**test** **eax, eax**\n**jnz** check_ecx\n**int** 3 ; Trap to Debugger\ncheck_ecx :\n**test** **ecx, ecx**\n**jnz** no_anti\n**int** 3 ; Trap to Debugger\n\nIn all three cases, if the condition is not met, then int 3 is\nexecuted or the program returns.\nThe GetSystemDirectoryA check is annihilated in one\nof the next versions. In Listing 18, although the GetSystemDirectoryA check is present, the program executes from\nno_anti_2 regardless of the check’s result.\n\n**Listing 18 Checking Register Value after API Call**\n\n**mov** **edi,** **offset ReplaceFileA**\n**mov** **ebx,** **offset SQLPrepare**\n**add** **ebx, 1400h**\n**pusha**\n**mov** **eax, 0**\n**xor** **eax, eax**\n**add** **eax, edi**\n**add** **eax, 2EAh**\n**sub** **esp, 4**\n**mov** [ esp+24h+var_24 ], 190h\n**push** **ebx**\n**sub** **eax, 0C7BB6212h**\n**add** **eax, 0C7BB6200h**\n\n\n**mov** **eax, [ eax ]**\n**mov** **ecx, 0**\n**call** **eax ; GetSystemDirectoryA**\n**test** **ecx, ecx**\n**jnz** $+6 ; jumps to no_anti_2\nno_anti_2 :\n\nThis check is reintroduced later, but this time ecx is\nexpected not to have a specific value (0x12FFB0) in order\nfor the program to continue its execution (Listing 19). ecx\nseemstobeinitializedwiththisvaluebythesystembeforethe\nprogram starts its execution. So, the actual check consists in\nensuring that the GetSystemDirectoryA function changes the\nvalue of ecx. Some emulators don’t change the value of ecx\nwhen executing the GetSystemDirectory function and thus\ntheir presence is successfully detected by this technique.\n\n**Listing 19 Checking Register Value after API Call**\n\n**push** 17Ch\n**push** **ebx**\n**call** GetSystemDirectoryA\n**cmp** **ecx, 12FFB0h**\n**jnz** no_anti_2\n**int** 3 ; Trap to Debugger\n\nIn the next versions, the same check applies, but the\nGetSystemDirectoryA function is replaced with the GetWindowsDirectoryA function, as can be observed in Listing 20.\n\n**Listing 20 Checking Register Value after API Call**\n\n**mov** [ esp+28h+uSize ], 17Ch\n**push** **edi**\n**call** GetWindowsDirectoryA\n**mov** **edx, 12FFB0h**\n**cmp** **ecx, edx**\n**jnz** no_anti_1\n**int** 3 ; Trap to Debugger\n\n**4.4 Return values of API calls**\n\nBesides checking the values of registers, the actual returned\nvalue of specific API calls is checked as well. For example,\nthe UPA 2 packer calls the GetTickCount function and checks\nits returned value. If the function returns a value smaller than\nor equal to 1, then the program jumps to a wrong address and\ncrashes, otherwise it continues the execution normally. The\ncode can be observed in Listing 21.\n\n**Listing 21 Checking Return Value of API Calls**\n\n**mov** **eax,** **offset GetTickCount**\n**call** **dword ptr [ eax ]**\n**cmp** **eax, 1**\n**jle** return_to_wrong_address\n\n\n-----\n\nreturn_to_wrong_address :\n**add** **ebx, 11FAh**\n**push** **ebx**\nretn\n\nSince the EBX register hasn’t been initialized, the code\nwill continue to execute from an arbitrary address, thus having an unpredictable behavior, but most probably crashing\nsoon.\nThe use of GetTickCount is explained as follows. The\nGetTickCount function returns the number of milliseconds\nthat passed from the moment the Operating System was\nstarted. That number is stored as a DWORD, therefore if\na system runs continuously for a period of almost 50 days,\nthen that number will overflow and restart counting from 0.\nAssuming the computer is not stopped for a period of one\nyear, this number will be equal to 0 for a maximum of 7\ntimes and each time it will keep the value 0 only for a millisecond. Thus, the probability for GetTickCount to return 0\nin a real system is very low.\nIn some emulators, however, the GetTickCount function\nwas adapted to bypass a well-known anti-emulation technique. It takes advantage by the overhead added by an\nemulator in order to detect its presence. Specifically, it consists in comparing the difference between the values returned\nby two consecutive calls to GetTickCount with a threshold, which is chosen so that it is higher than the difference\nusually obtained on a real system, but lower than the difference usually obtained on emulators. This anti-emulation\ntechnique could be bypassed by implementing GetTickCount\nso that it always returns 0 or 1, which means that the difference between two consecutive calls is always 0 and thus\nfails to detect the emulator’s presence. This adaptation of\nthe GetTickCount function made possible the anti-emulation\ntechnique described in this subsection.\n\n**4.5 DLL presence and header values**\n\nThis packer also checks the presence of specific DLL files\nand the value of certain fields within their headers.\nThe offset of the PE header [2], the e_lfanew field from\nIMAGE_DOS_HEADER, must match specific values for\nthe packer to normally continue its execution. For example,\ne_lfanew must be:\n\n1. 0xE0,0xF0,or0xE8in%system_directory%/mfcsubs.dll\n2. 0xE0, 0xE8, or 0x20B in %system_directory%/DuSer.dll\n\nFor the second example, however, if the value of e_lfanew\ndoesn’t match any value from the list, there is one condition\n\n[2 http://www.microsoft.com/whdc/system/platform/firmware/](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx)\n[PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx)\n\n\nthat can still validate the library and let the program continue\nits execution normally: the value located at the offset 0x120\nfrom the beginning of the header / file must be 0x00042000\n(in Windows XP, this value matches and it corresponds to\nBaseOfData because the address of the PE header is 0xF0) or\n0x00024000 (probably BaseOfData in another operating system). In case neither e_lfanew nor BaseOfData field matches\nthe checked values, then the program jumps to an address\nfrom the stack and an exception is generated while executing\nthe data from there as code.\nIn newer versions, the checked field is changed from\ne_lfanew to SizeOfCode, which is located in the IMAGE_NT\n_HEADERS. A few examples are illustrated further.\nFirst, in %system_directory%/sbe.dll, if SizeOfCode is\nsmaller than 0x000301FF, then int 3 is executed.\nSecond, in %system_directory%/qcap.dll, if SizeOfCode\nis equal to zero then the program starts executing the code\nwithout decrypting it first; if SizeOfCode has a value smaller\nthan 0x000201FF then int 3 is executed.\nThird, in %system_directory%/catsrv.dll, SizeOfCode\nmust be one of the following values: 0x00000300, 0x00024\n005, 0x00024006, or bigger than 0x000201FE, otherwise the\nprogram crashes.\nIn even newer examples, first the presence of the library is\nchecked and only afterwards its corresponding header fields.\nIn one of the analyzed samples, if %system directory%/catsrv.dll is not present / could not be opened in read\nmode, then int 3 is executed, as illustrated in Listing 22.\n\n**Listing 22 Checking DLL Presence**\n\n**push** **edx ; \"rb\"**\n**push** **ebx ; %system_directory%/c a t s r v . d l l**\n**call** **dword ptr [ eax ] ; fopen**\n**test** **eax, eax**\n**jnz** no_anti_3\n**int** 3 ; Trap to Debugger\n\nIf SizeOfCode ≤ 0x000206FD, then the code from the\ncompute_wrong_address label is executed, otherwise - the\ncode from the compute_correct_address label (Listing 23).\n\n**Listing 23 Checking SizeOfCode Value in Various DLLs**\n\n**mov** **eax, ebx**\n**sub** **eax, 10h**\n**add** **eax, 4Ch**\n**mov** **eax, [ eax ] ; eax = e_lfanew**\n**add** **eax, ebx ; eax = PE header address**\n**push** 1Eh\n**pop** **esi**\n**sub** **esi, 2**\n**mov** **eax, [ eax+** **esi ] ; eax = SizeOfCode**\n**cmp** **eax, 206FDh**\n**nop**\n**jle** compute_wrong_address\n\n\n-----\n\n**jmp** compute_correct_address\n\nThe compute_wrong_address function has the code presented in Listing 24.\n\n**Listing 24 Computing Incorrectly the Address of the Encrypted Buffer**\n\ncompute_wrong_address :\n**add** **esi, 5FAh**\n**push** **esi**\nretn\n\nThe code from compute_wrong_address is used by compute_correct_address too, but not before initializing esi with\nencrypted_buffer_address (Listing 25).\n\n**Listing 25 Computing Correctly the Address of the Encrypted Buffer**\n\ncompute_correct_address :\n**mov** **esi,** **offset unk_404C0A**\n**xor** **eax, eax**\n**add** **esp, 3Ch**\n**jmp** compute_wrong_address\n\nLater, the minimum value of SizeOfCode in %system_directory%/catsrv.dll is increased to 0x000206FF, probably following some updates or new versions of the library.\nAfter some time, the tested library is changed to %system_directory%/gdi32.dll. If its SizeOfCode is smaller than\nor equal to 0x26000, then it tests the library again (a never\nending loop), otherwise it continues with decrypting and executing the payload. The code is presented in Listing 26.\n\n**Listing 26 Checking SizeOfCode Value in Various DLLs**\n\ntry_again :\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n**push** IMAGE_DOS_HEADER.e_lfanew\n**pop** **eax**\n**add** **eax, edi**\n**mov** **eax, [ eax ] ; eax = e_lfanew**\n**add** **eax, edi ; eax = PE header address**\n**push** 1Eh\n**pop** **ebx**\n**sub** **ebx, 2**\n**mov** **eax, [ eax+ebx** ] ; eax = SizeOfCode\n**cmp** **eax, 26000h**\n**jle** try_again\n**jg** jmp_to_decrypt\n**int** 3 ; Trap to Debugger\n\njmp_to_decrypt :\n**jmp** decrypt\n\nAfterwards, the %system_directory%/comctl32.dll is\nsearched on the system and validated as follows: if SizeOfCode ≤ 0x24000 then it retries the library validation (a\nnever ending loop), otherwise it decrypts and executes the\npayload.\n\n\nIn the last versions, the packer decrypts and executes its\npayload only if a specific system library has its SizeOfCode\nbetween two specified values. Some examples are:\n\n1. %system_directory%/duser.dll - between 0x20400 and\n0x90000\n2. %system_directory%/wsecedit.dll - between 0x25200\nand 0x90000\n3. %system_directory%/wuapi.dll - between 0x21400 and\n0x90000\n\nThe Listing 27 illustrates this behavior for the first example, the other two being very similar.\n\n**Listing 27 Checking SizeOfCode Value in Various DLLs**\n\n**mov** [ esp+30h+var_30 ], 2Fh\n**inc** [ esp+30h+var_30 ]\n**inc** [ esp+30h+var_30 ]\n**pop** **eax**\n**add** **eax, 0Bh ; eax = 0x3C**\n**push** **dword ptr [ edi+eax ]**\n**pop** **eax** _; eax = e_lfanew_\n**add** **eax, edi ; eax = PE header address**\n**push** 1Eh\n**pop** **esi**\n**sub** **esi, 2 ; esi = 0x1C**\n**mov** **eax, [ eax+** **esi ] ; eax = SizeOfCode**\n**jmp** loc_402316\n\nloc_402316 :\n**mov** **edx, 20400h**\n**cmp** **eax, edx**\n**jg** loc_40236C\n**int** 3 ; Trap to Debugger\n\nloc_40236C :\n**cmp** **eax, 90000h**\n**ja** call_wrong_address\n**call** decrypt\n\ncall_wrong_address :\n**add** **esi, 0FFFFDEF4h**\n**push** **esi**\n**call** [ esp+30h+var_30 ]\n\nIf SizeOfCode is smaller than the minimum required, then\nint 3 is executed. If it is bigger than the maximum required\nthen a wrong address is called, resulting in an Access Violation exception being generated.\nAnother interesting aspect to note here is the use of\nunnecessary spaces at the end of library names or duplicated slashes between the system directory and the library\nnames, when loading them. An example of such a string is\n“%system_directory%//wuapi.dll”. The Operating Systems\n\n\n-----\n\ncan deal with these cases, although it is not documented.\nBecause of the missing documentation, emulators don’t usually treat these cases.\n\n### 5 UPA 3\n\nUPA 3 is a custom packer used exclusively for the Upatre\ndownloader. The first samples were spotted in the wild in\nNovember 2013. Unlike the UPA 1 packer, which started\nwith many different anti-* techniques, the UPA 3 packer\ndidn’t have neither many nor advanced anti-* techniques in\nthe beginning. Next, we will present the mechanisms it uses.\n\n**5.1 Return values of API calls**\n\nIt checks whether RegisterClassA returns a non zero value\nand whether acmStreamConvert returns the value 5 for specific values of the parameters, as illustrated in Listing 28.\n\n**Listing 28 Checking Return Value of API Call**\n\n**call** **ds : RegisterClassA**\n**sub** **esp, 4**\n**call** loc_401000\n\nloc_401000 :\n**and** **eax, eax**\n**jz** exit___loc_4010E9\n**call** sub_40221E\n\nsub_40221E :\n**xor** **edi, edi**\n**push** 0 _; fdwConvert_\n**push** 0 _; pash_\n**push** has _; has_\n**call** **ds : acmStreamConvert**\n**cmp** **eax, 5**\n**jz** **short loc_402236**\nretn\n\n**5.2 Window messages**\n\nUPA 3 contains interesting and complex anti-emulation techniques involving window messages, which were introduced\na few days after the first samples were found.\nIn the first example, the packer creates a window with a\nwnd_proc callback function waiting for window messages.\nWhen wnd_proc receives a WM_CREATE message, it creates a button and sends a BM_CLICK message to the newly\ncreated button, as presented in Listing 29.\n\n**Listing 29 Handling WM_CREATE in Window Callback**\n\n**i f (msg == WM_CREATE)**\n\n\n{\nhWnd_button = CreateWindowExA(\n0, \" button \", \" prerequ \",\n1342177281, 5, 45, 160, 35,\nhWndParent, 0, hInstance, 0);\nPostMessageA (hWnd_button,\nBM_CLICK, 0, 0);\n}\n\nThe BM_CLICK message generates a WM_COMMAND\nmessage, which is received by the wnd_proc function and\nhandled in Listing 30.\n\n**Listing 30 Handling WM_COMMAND in Window Callback**\n\n**i f (Msg == WM_COMMAND)**\n{\n**i f ((HWND) lParam == hWnd_button)**\n**return decrypt_next_layer ( ) ;**\n}\n\nThis technique is more complicated because the emulator\nmust know how to handle window messages and how to send\nthe WM_COMMAND message in case of a MB_CLICK\nmessage with the lParam containing the button handle.\nIn the second example, the DialogBoxParamW function is\nusedtocreateawindowwithacallbackfunction,aspresented\nin Listing 31.\n\n**Listing 31 Creating Window with Callback Function**\n\nDialogBoxParamW( hInstance,\n(LPCWSTR)0x3E8, 0, DialogFunc, 0);\n\nThe callback function (DialogFunc) handles window messages. In case of a WM_INITDIALOG message, it retrieves\na dialog item having the ID equal to 1001 and sends a\nWM_SETFONT message to it, as in Listing 32.\n\n**Listing 32 Handling WM_INITDIALOG in Window Callback**\n\n**i f** ( msg == WM_INITDIALOG )\n{\nhWnd = GetDlgItem (hDlg, 1001);\nSendMessageW(hWnd,\nWM_SETFONT, : : wParam, 1);\n}\n\nWhen called, the GetDlgItem function generates a WM\n_COMMAND message. The DialogFunc callback receives\nthis message in Listing 33.\n\n**Listing 33 Handling WM_COMMAND in Window Callback**\n\n**i f** ( msg == WM_COMMAND )\n{\nGetSystemTime(&SystemTime ) ;\nr es ul t = decrypt_next_layer ( ) ;\n}\n\n\n-----\n\nThis WM_COMMAND message is treated in more details\nin Listing 34, which presents the corresponding assembly\ncode.\n\n**Listing 34 Handling WM_COMMAND in Window Callback**\n\n**mov** **eax,** **offset SystemTime**\n**push** **eax**\n**push** **eax ; lpSystemTime**\n**call** **ds : GetSystemTime**\n**pop** **edx**\n**xor** **eax, eax**\n**mov** **ax, [** **edx+2] ; wMonth**\n**add** **eax,** **offset unk_404087**\n**push** **ds : GetModuleHandleA**\n**push** **offset sub_401912**\n**call** decrypt_next_layer\n\ndecrypt_next_layer :\n**mov** **esi,** **offset word_402676**\n**mov** **edi, eax**\n**mov** **eax, 4**\n**mov** **ecx, 0Fh**\n**call** decrypt_buffer\n**push** **edi**\n\nThe current month, retrieved from the time structure\nreturned by the GetSystemTime function, is used to compute where to decrypt the current buffer. The example from\nListing 35 emphasizes this behavior.\n\n**Listing 35 Computing the Address for Decrypted Buffer**\n\n**mov** **ax, [** **edx+2] ; wMonth**\n**add** **eax,** **offset unk_404087**\n**mov** **edi, eax**\n\nThis mechanism ensures the sample executes properly\nonly in a specific month of the year. This behavior is understandable for a downloader like Upatre because it uses the\nsame version of the packer for a few days only. Once the\nsecurity vendors add detection for this version of the packer,\nUpatre will start using another version of the packer in order\nto evade detection.\nFrom the emulator’s point of view, however, this is a problem because it must detect the samples anytime, not just in\na specific month of the year. This presents difficulties when\ndebugging as well because the malware analyst must pay\nattention and make sure that the date of the system is the\nexpected one.\nIn 2014, the mechanism had undergone some changes.\nThe code can be analyzed in Listing 36.\n\n**Listing 36 Window Callback in 2014**\n\n**i f (msg == WM_INITDIALOG)**\n{\nhWnd = GetDlgItem (hWnd, 503);\n\n\nSendMessageA(\nhWnd, WM_SETFONT, wParam, 1);\n}\n**else**\n{\n**while (msg != WM_SETFONT) ;** _/ / i n f i n i t e loop_\nGetSystemTime(&SystemTime ) ;\nr es ul t = decrypt_next_layer ( ) ;\n}\n\nAmong the changes are the use of another value for the\ndialog item ID used by the GetDlgItem function, and the\ninfinite loop executed when receiving a message different\nfrom WM_INITDIALOG and WM_SETFONT.\nIn some of the next packer iterations, it combines the use\nof the BM_CLICK message as in the first example, handled\nby a callback function registered with the help of the DialogBoxParamW function as in the second example. The relevant\ncode is illustrated in Listing 37.\n\n**Listing 37 Handling BM_CLICK in a callback registered with Dialog-**\nBoxParamW\n\nDialogBoxParamA( hInstance,\n(LPCSTR)0x335, 0, DialogFunc, 0);\n\n**unsigned int DialogFunc (**\nHWND hDlg, **int msg,**\n**unsigned int wParam, HWND lParam )**\n{\n**i f (msg == WM_INITDIALOG)**\n{\nhDlgItem_99 = GetDlgItem (hDlg, 99);\nSendMessageW(\n(HWND) hDlgItem_99,\nBM_CLICK, 0, 0);\n}\n**i f (msg == WM_COMMAND)**\n{\n**i f (wParam == 99)**\n**return decrypt_next_layer ( ) ;**\n}\n}\n\nIn later packer versions, the things get even more complicated as the previous techniques are combined into a single\none and more window messages have to be generated and\nprocessed. The code form Listing 38 helps understanding\nthe message flow and taken actions.\n\n**Listing 38 Combining Techniques**\n\nentry_point :\nDialogBoxParamA( hInstance,\n(LPCSTR)0x1F4, 0, DialogFunc, 0);\n\n**unsigned int DialogFunc (**\n\n\n-----\n\nHWND hDlg, **int msg,**\n**unsigned int wParam, HWND lParam )**\n{\n**i f (msg == WM_INITDIALOG)**\n{\nhDlgItem_501 = GetDlgItem (hDlg, 501);\nhDlgItem_504 = GetDlgItem (hDlg, 504);\n}\n**i f (msg == WM_COMMAND)**\n{\n**i f ( lParam != hDlgItem_504 )**\n**return PostMessageA(**\nhDlgItem_504, BM_CLICK, 0, 0);\n**i f ( ! ( wParam >> 16))**\n{\ndecrypt_next_layer ( ) ;\n}\n}\n}\n\nAt entry point, a DialogFunc callback is registered for the\nnewly created window. Immediately after the window is created, the callback function receives the WM_INITDIALOG\nmessage and thus calls the GetDlgItem function with the\ndialog item ID 501 and then 504, both generating a\nWM_COMMAND message.\nAt receiving the WM_COMMAND message, the DialogFunc posts a BM_CLICK message with wParam equal\nto 0. When the BM_CLICK message gets processed, a\nWM_COMMAND message with wParam equal to 0 is generated, triggering the execution of the next decryption layer.\nLater on, an even more advanced technique is put in place.\nBy sending the message EM_GETLINECOUNT to hEdit_2,\nthe return value will be 4 because it’s name has 4 lines. This\nnumber is later used to compute the address from which the\nexecution is about to be continued. Listing 39 presents this\ntechnique.\n\n**Listing 39 Computing Next Execution Address**\n\nentry_point :\nCreateWindowExA(0, \" contents \",\n0, 0, 3300, 1400, 756,\n500, 0, 0, hInstance, 0);\n\nLRESULT wnd_proc (\nHWND hWndParent, UINT Msg,\nWPARAM wParam, LPARAM lParam )\n{\n**i f (Msg == WM_CREATE)**\n{\nwindow_name = \" sabcdeaaaa \\ r \\ n\" ;\ns t r c a t (window_name, \"ebubu \\ r \\ n\" ) ;\ns t r c a t (window_name, \" iccasc \\ r \\ n\" ) ;\n\n\nhEdit_1 = CreateWindowExA(\n0, \" edit \", 0, 0x50010000,\n25, 155, 240, 30, hWndParent,\n0, hInstance, 0);\n\nhEdit_2 = CreateWindowExA(\n0, \" edit \", window_name,\n0x50010004u, 25, 155, 240, 30,\nhWndParent, 0, hInstance, 0);\n\nSendMessageA( hEdit_1, WM_SETTEXT,\n0, (LPARAM) \" i n s t a b i l i t y \" ) ;\nSendMessageA( hEdit_2, WM_SETFONT,\n(WPARAM)window_name, 1);\n}\n**i f (Msg == WM_COMMAND)**\n{\n**i f ((HWND) lParam == hEdit_1**\n&& wParam == 0x4000000 )\n{\nnr_lines = SendMessageA( hEdit_2,\nEM_GETLINECOUNT, 0, 0);\n(( void ( ∗ )( void ) ) ( ( char ∗)loc_401273\n+ 16 ∗ nr_lines + 1 ) ) ( ) ;\n}\n}\n}\n\nThe assembly code that computes the final address is presented in the Listing 40, the resulted value being 0x401274\n+ 0x40 = 0x4012B4.\n\n**Listing 40 Computing Next Execution Address**\n\n**cmp** **eax, hEdit_1**\n**jnz** loc_4012AE\n**mov** **eax, [** **ebp+wParam]**\n**cmp** **eax, 4000000h**\n**jnz** loc_4012AE\n**push** 0 ; lParam\n**push** 0 ; wParam\n**push** 0BAh ; Msg _; EM_GETLINECOUNT_\n**push** hWnd ; hWnd\n**call** SendMessageA\n**shl** **eax, 4**\n**mov** **ecx, eax**\n**add** **ecx, ( offset loc_401273+1)**\n**call** **ecx**\n**xor** **eax, eax**\n**pop** **ebp**\nretn 10h\n\nDuring the next evolution step, the wnd_proc function is\nchanged completely as can be observed from the Listing 41.\n\n\n-----\n\n**Listing 41 Using WM_PARENTNOTIFY Message**\n\n**int starts_with_value_3 = 3;**\n\n**void wnd_proc (**\nHWND hWnd, UINT Msg,\nWPARAM wParam, LPARAM lParam )\n{\n**switch (Msg)**\n{\n**case WM_INITDIALOG:**\nLoadLibraryA ( \"Riched32 . dll \" ) ;\ncreate_3_windows ( ) ;\n**break ;**\n**case WM_QUIT:**\nPostQuitMessage (0);\n**break ;**\n**case WM_PARENTNOTIFY:**\n**i f ( starts_with_value_3 == 1)**\ndecrypt_next_layer (\nstarts_with_value_3 − 1);\n**else**\n−−starts_with_value_3 ;\n**break ;**\n**default :**\nDefWindowProcA(hWnd,\nMsg, wParam, lParam ) ;\n**break ;**\n}\n}\n\nAt dialog initialization, the callback calls the CreateWindowExA function three times: two times with the “edit” type\nand once with the “RichEdit” type. Afterwards, it waits three\nWM_PARENTNOTIFY messages before executing further\nfrom the loc_401D3E location, illustrated in Listing 42.\n\n**Listing 42 Using EM_LINEFROMCHAR Message**\n\nloc_401D3E :\n**mov** **ecx, 0CAh**\n**push** 0 ;lParam\n**push** 1Dh ;wPram\n**dec** **ecx**\n**push** **ecx ;Message => EM_LINEFROMCHAR**\n**push** hRichEdit_1 ;hWnd\n**call** **ds : SendMessageA**\n**mov** **ecx, 401C4Eh**\n**push** **eax**\n**test** **eax, eax**\n**jnz** **short loc_401D93**\n\nThe next step consists in sending the EM_LINEFROMCHAR message (the code 0xC9) to hRichEdit_1, one\nof the three windows created previously inside the cre\n\nate_3_windows function. The creation of the hRichEdit_1\nwindow is illustrated in the Listing 43.\n\n**Listing 43 Window Creation**\n\nwindow_name = \" gitydon \\ r \\ n\" ;\ns t r c a t (window_name, \"abloom \\ r \\ n\" ) ;\ns t r c a t (window_name, \" a b i l i t y \\ r \\ n \\ r \\ n\" ) ;\ns t r c a t (window_name, \" aberration \\ r \\ n\" ) ;\ns t r c a t (window_name, \"abbey \\ r \\ n\" ) ;\ns t r c a t (window_name, \" kibitz \\ r \\ n\" ) ;\ns t r c a t (window_name, \" increase \\ r \\ n\" ) ;\ns t r c a t (window_name, \" evangelist \\ r \" ) ;\ns t r c a t (window_name, \" kicky \\ r \\ n\" ) ;\nhRichEdit_1 = ( int )CreateWindowExA(\n0, \" RichEdit \", window_name,\n0x50810004u, 26, 186, 242,\n32, v2, 0, hInstance, 0);\n\nThen it checks the value returned for the EM_LINEFROMCHAR message to be different than zero. It returns\nthe value 3 in OllyDbg in this particular case because the\ncharacter at position 0x1D is on the third line.\nIn newer samples, the check uses the exact value returned\nby the EM_LINEFROMCHAR message.\nIn even newer samples, the technique is changed completely again. The Listing 44 details it.\n\n**Listing 44 Window Procedure Evolution**\n\n**i f (Msg == WM_CREATE)**\n{\nhRichEdit = CreateWindowExA(0,\n\" RichEdit \", \" \", 0x40000004, 40,\n40, 160, 28, hWnd, 0, hInstance, 0);\nSendMessageA(hWnd,\nWM_COMMAND, 0x68u, 105);\nSendMessageA( hRichEdit,\nEM_FINDWORDBREAK, 0, 15);\n**for ( i = 0; i < 10000;++ i )**\nSleep (100);\nr esul t = 1;\n}\n\n**i f (Msg == WM_COMMAND)**\n**i f (wParam == 0x68)**\n{\nSendMessageA( hRichEdit,\nEM_SETWORDBREAKPROC, 0,\n(LPARAM) wordbreak_callback ) ;\n**return DefWindowProcA(**\nhWnd, Msg, wParam, lParam ) ;\n}\n\n**int wordbreak_callback (**\n**int a1,** **int a2,** **int a3,** **int a4 )**\n\n\n-----\n\n{\nchar_position = SendMessageA(\nhWnd, EM_POSFROMCHAR, 0, 0);\nDestroyWindow(hWnd) ;\ndecrypt_next_layer ( char_position ) ;\n**return 10;**\n}\n\nAt window creation, the window procedure callback sends\ntwo messages: a WM_COMMAND message with wParam\nequal to 0x68 and a EM_FINDWORDBREAK message.\nAfter sending these messages, it just sleeps 1000 seconds.\nThe first message sent by the window procedure callback\n\n- the WM_COMMAND message - is received and processed\nby the same window procedure callback. In order to make\nsure it’s the same message it sent itself earlier, it checks if\nthe wParam parameter equals 0x68. If it is, then the callback\nsends an EM_SETWORDBREAKPROC message, thus registering a word break callback: wordbreak_callback.\nThe second message sent by the window procedure callback - the EM_FINDWORDBREAK message - triggers the\nwordbreak_callback.\nThe wordbreak_callback function sends an EM_POSFROMCHAR message, that returns a char_position value\nequal to 0x7fff in ollyDbg. This value is used to compute the\nlocation from where to execute further.\nIn the next iterations, the sleeps are removed and the\nEM_CHARFROMPOS message is used instead of the\nEM_POSFROMCHAR message.\nAnother change consists in making sure some files don’t\nexist before sending the initial WM_COMMAND. This is\nperformed as illustrated in Listing 45, by checking the return\nvalue of the CreateFile function.\n\n**Listing 45 Checking File Non-Existence**\n\n**i f ( CreateFileA ( \" etings . txt \",**\nGENERIC_READ, 0, 0, OPEN_EXISTING,\n0, 0) == HANDLE−1)\n{\nSendMessageA(hWnd,\nWM_COMMAND, 0x68, 100);\n}\n\nAt the beginning of the year 2015, it returned to basics\nand started to use simple techniques similar to the ones used\nin the 2013 year. An example is illustrated in Listing 46. The\noriginal code is quite obfuscated with various SendMessage\ncalls, but the listing presents a simplified version containing\nonly the relevant commands.\n\n**Listing 46 Returning to Simple Tricks**\n\n**i f** ( msg == WM_INITDIALOG )\n{\ndlg_item = GetDlgItem (hDlg, 0x71 ) ;\n: : wParam = 0x65 ;\n\n\nSendMessageW( dlg_item, BM_CLICK, 0, 0);\n}\n\n**i f** ( msg == WM_COMMAND )\n{\n**i f** ( wParam == 0x71 )\n{\nSendMessageA(hDlg,\nWM_COMMAND, : : wParam, 0);\n}\n\n**i f** ( wParam == 0x65 )\n{\n(( void ( __thiscall ∗ )(WPARAM))\ndecrypt_next_layer ) ( : : wParam ) ;\n}\n}\n\nThe GetDlgItem function, called with the id equal to 0x71,\nis used to generate a WM_COMMAND. When dealing with\nthis WM_COMMAND, it sends another WM_COMMAND\nmessage with wParam equal to 0x65. Finally, when receiving\nthe WM_COMMAND with wParam equal to 0x65, it starts\ndecrypting the next layer.\nListing 47 presents another interesting mechanism. It\nsends the TB_INSERTBUTTONW (0x443) message. At the\nfirst execution of the callback, a value is set to 0x10FF while\nat the second execution - that specific value is returned. The\nimportance of this value consists in the fact that the address\nfrom which to execute further on is computed with its help.\n\n**Listing 47 Using TB_INSERTBUTTONW Message**\n\n**i f (Msg == WM_CREATE)**\n{\nSendMessageA(hWnd, 0x467, 0, 0);\n**return 0;**\n}\n\n**i f (Msg == 0x467)**\n{\nSendMessageA ( : :hWnd,\nTB_INSERTBUTTONW, 0, 0x10FFu ) ;\n**for ( i = 0x48Du;** i < 0x4C9u; ++i )\nSendMessageA(hWnd, i, i, 0);\n}\n\n**i f (Msg == 0x496)**\n{\nv8 = SendMessageA ( : :hWnd,\nTB_INSERTBUTTONW, 0, 0x307Fu ) ;\ndecrypt_next_layer (v8 ) ;\n}\n\n\n-----\n\nOn the next iteration of this trick, the value for TB_INSER\nTBUTTONW was changed and a check was added in order\nto make sure that the file “Desktopini” doesn’t exist. It is\nillustrated in Listing 48.\n\n**Listing 48 Checking Existence of Desktopini File**\n\nlpFileName = \" Desktopini \" ;\n**i f ( CreateFileA ( lpFileName, 0x80000000u,**\n1u, 0, 3u, 0x80u, 0) == (HANDLE) − 1)\n{\nSendMessageA(hWnd, 0x46Cu, 0, 0);\n}\n\nIn the newer samples, the message used to keep the value\nfor address computation was changed from TB_INSERTBU\nTTONW (0x443) to EM_SETEVENT- MASK (0x445), as\ncan be observed in Listing 49.\n\n**Listing 49 Using EM_SETEVENTMASK Message**\n\n**i f** ( Msg == WM_CREATE )\n{\n: :hWnd = CreateWindowExA(0, \" richedit \",\n&byte_405133, 0x40000004u, 4, 94,\n600, 300, hWnd, 0, hInstance, 0);\nSendMessageA ( : :hWnd, EM_SETEVENTMASK,\n0, 0x101u ) ;\n**for ( i = 1173; ( signed int ) i < 1225; ++i )**\nSendMessageA(hWnd, i, i, 0);\n}\n\n**i f** ( Msg == 1174 )\n{\nv9 = SendMessageA ( : :hWnd,\nEM_SETEVENTMASK, 0, 0);\ndecrypt_next_layer (v9 ) ;\n}\n\nIn the middle of 2015, the UPA 3 packer switched to a\nnew mechanism, illustrated in Listing 50.\n\n**Listing 50 Using SetFocus Message and EditControl IDs**\n\n**i f (Msg == WM_CREATE)**\n{\nhEdit_1 = CreateWindowExA(\n0, \"EDIT\", &lpWindowName,\n0x40000000u, 300, 35, 300, 30,\nhWnd, (HMENU)4, hInstance, 0);\nhRich_edit_1 = CreateWindowExA(\n0, \" richedit \", &lpWindowName,\n0x40000004u, 5, 95, 600, 300,\nhWnd, 0, hInstance, 0);\nSetFocus ( hEdit_1 ) ;\n}\n\n**i f (Msg == WM_COMMAND)**\n\n\n{\n**i f (wParam == 4)**\n{\nsub_403610 (hWnd, 4);\n**return 0;**\n}\n}\n\n**int sub_403610 (HWND hWnd,** **int a2 )**\n{\nUINT v2 ;\nSendMessageA( hRich_edit_1, 0x445u,\n0, a2 + 1537);\nv2 = 1172;\n**do**\n{\nSendMessageA(hWnd, v2, v2, 0);\n++v2 ;\n} while (( int )v2 < 1226);\n}\n\n**i f (Msg == 1173)**\n{\nwanted_value = SendMessageA(\nhRich_edit_1, 0x445u, 0, 0);\n}\n\n**i f (Msg == 1174)**\n{\nDestroyWindow(hWnd) ;\ndecrypt_next_layer ( wanted_value ) ;\n}\n\nLet’s dissect the content of the Listing 50 step by step. In\nthe beginning, in the call to CreateWindowExA, from Listing 51, the tenth parameter (which has the value 4 in this case)\nis the identifier of this edit control. This identifier is used later,\nwhen a WM_COMMAND message, generated by SetFocus\n(hEdit_1), is received. Next, it uses the previous technique\nwith the EM_SET EVENTMASK (0x445) message.\n\n**Listing 51 Creating EditControl with Specific ID**\n\nhEdit_1 = CreateWindowExA(0, \"EDIT\",\n&byte_405907, 0x40000000u, 300, 35,\n300, 30, hWnd, (HMENU)4, hInstance, 0);\n\nThis technique is changed soon by generating the WM_\nCOMMAND in another form. If previously the SetFocus function was used, now the SendMessageA( hEdit_1,\nWM_SETFOCUS, 0, 0) is executed. The callback for the\nWM_COMMAND generated by WM_SET- FOCUS is different as well. It initializes wanted_value with the high\nword of the wParam dword (wParam ≫ 16), which corresponds to the control-defined notification code. If it is not\n\n\n-----\n\nequal with the id of hEdit_1, it defaults to 0x100. After\nthe WM_SETFOCUS message is processed, wanted_value\ncontains the value 0x100. The next step consists in calling\nthe CreateWindowExA function twice, as illustrated in Listing 52.\n\n**Listing 52 Calling CreateWindowExA with Specific IDs**\n\nCreateWindowExA(0, \" edit \", byte_406871,\n0x40000000u, 300, 5, 10, 32, hWnd,\n(HMENU)3, hInstance, 0);\nCreateWindowExA( 0, \" button \", \"Ok\",\n0x40000000u, 505, 405, 100, 31, hWnd,\n(HMENU)7, hInstance, 0);\n\nEach CreateWindowExA generates a WM_PARENTNOTIFY message with the identifier of the child window,\nHIWORD(wParam), being equal to the previously mentioned identifier: 3 for the first CreateWindowExA and 7\nfor the second one. When receiving the WM_PARENTNOTIFY message, the callback will add the identifiers to\nwanted_value, resulting the value 0x100 + 0x3 + 0x7 =\n0x10A. In the end, the value from EM_SETEVENTMASK\nand a constant are added to wanted_value, the final result\nbeing passed to the decrypt_next_layer function. The piece\nof code achieving this in presented Listing 53.\n\n**Listing 53 Computing Needed Value**\n\n**i f (Msg == WM_CREATE)**\n{\nhEdit_1 = CreateWindowExA(0, \" edit \",\n0, 0x40000000u, 300, 60, 300, 32,\nhWnd, (HMENU)5, hInstance, 0);\nwanted_value = 0x96u ;\nSendMessageA(hWnd, 0x478u, 0, 0);\n\nhRichEdit = CreateWindowExA(\n0, aRichedit, &lpWindowName,\n0x40000004u, 5, 105, 520, 330,\nhWnd, (HMENU)4, hInstance, 0);\n}\n\n**i f (Msg == 0x478)**\n{\n**for ( i = 0x490u ;** i < 0x4C6u; ++i )\n{\nPostMessageA(hWnd, i, 0, i + 1);\n}\nSendMessageA( hEdit_1, WM_SETFOCUS, 0, 0);\n}\n\n**i f (Msg == WM_PARENTNOTIFY)**\n{\nwanted_value += (wParam >> 16);\n\n\n**i f ((wParam >> 16) == 3)**\nSendMessageA( hRichEdit,\n0x443u, 0, 0x10E8u ) ;\n}\n\n**i f (Msg == WM_COMMAND)**\n{\nwanted_value = wParam >> 16;\n}\n\n**i f (Msg == 0x49C)**\n{\nv9 = SendMessageA( hRichEdit,\n0x443u, 0, 0x3F0u ) ;\nv8 = wanted_value ;\n**for ( j = 128; j > 0; −−j )**\nv8 += j ;\nwanted_value = v9 + v8 ;\n}\n\n**i f (Msg == 0x4A2)**\n{\ndecrypt_next_layer ( wanted_value ) ;\n}\n\nWith the passing of time the code gets simplified a little.\nFor example, in August 2015, it looks like in the Listing 54. It\nbegins with a trick from the previously described mechanism:\nCreateWindowExA generates a WM_PARENTNOTIFY\nwith the identifier of the child window, HIWORD(wParam),\nbeing equal to the identifier. This is executed multiple times.\nThe newly added part consists in using the LB_INIT- STORAGE message to return a value. The code is illustrated in\nListing 54.\n\n**Listing 54 Using LB_INITSTORAGE Message**\n\nwanted_value += SendMessageA(hWnd,\nLB_INITSTORAGE, 0x7D00u, 0xD07u ) ;\n\nIn this cases, the returned value is 0x7D00. The wanted_\nvalue is computed and then used in the function that decrypts\nthe next layer.\nThe interesting part here is that not sending the WM_\nPAINT message causes a jump to the decryption function,\nwhose execution causes a crash because the wanted_value\nvariable is not properly initialized. The Listing 55 illustrates\nthis mechanism.\n\n**Listing 55 Execution Flow for the Last Variants of the UPA3 Packer**\n\n**i f (Msg == WM_CREATE)**\n{\nwanted_value = 0;\nCreateWindowExA (,,,,,,,,,4,,);\nCreateWindowExA (,,,,,,,,,C,, ) ;\nCreateWindowExA (,,,,,,,,,0,,);\n\n\n-----\n\nCreateWindowExA (,,,,,,,,,0,,);\nCreateWindowExA (,,,,,,,,,0,,);\nCreateWindowExA (,,,,,,,,,5,,);\nCreateWindowExA (,,,,,,,,,6,,);\nCreateWindowExA (,,,,,,,,,7,,);\nCreateWindowExA (,,,,,,,,,8,,);\nCreateWindowExA (,,,,,,,,,9,,);\nCreateWindowExA (,,,,,,,,,1,,);\nCreateWindowExA (,,,,,,,,,2,,);\nCreateWindowExA (,,,,,,,,,3,,);\nCreateWindowExA (,,,,,,,,,A,, ) ;\nCreateWindowExA (,,,,,,,,,B,, ) ;\n}\n\n**i f (msg == WM_PARENTNOTIFY)**\n{\nwanted_value += wParam >> 16;\n**i f ((wParam >> 16) == 5)**\n{\nwanted_value += SendMessageA(hWnd,\nLB_INITSTORAGE, 0x7D00u, 0xD07u ) ;\n}\n**else**\n{\n**i f ((wParam >> 16) == 9)**\nPostMessageA (hWndParent, 0x78u,\n0xFFFFu, 0);\n}\n}\n\n**i f (msg == WM_PAINT)**\n{\nBeginPaint (hWndParent, &Paint ) ;\n**goto LABEL_18;**\n}\n\n**i f (msg == 0x78)**\n{\nLABEL_18:\ndecrypt_next_layer ( wanted_value ) ;\n}\n\nThis mechanism was kept as part of the packer until the\nend of year, only small changes being applied here and there:\nthe numbers used for the identifiers, the value used for the\nLB_INITSTORAGE message.\n\n### 6 Conclusions\n\n**6.1 Anti-emulation techniques**\n\nThe presented anti-emulation techniques differ when it\ncomes to the amount of work required by the emulators\n\n\nto patch them and by the malware creators to bypass these\npatches.\nThe following anti-emulation techniques require a high\neffort in order to be fixed in the emulators, but once it’s done,\nthe packer creators cannot change them easily to evade emulators again. After a period of time it will be of no use to\nkeep them in the packer code because they can easily trigger\ndetection and not stop the emulators any more.\n\n1. TLS callbacks\n2. FastPebLockRoutine callbacks\n3. SecureMemoryCache callbacks\n4. TopLevelExceptionFilter callbacks\n5. window creation callbacks\n6. message handling\n\nThe medium difficulty for fixing the emulators comes\nwith the medium difficulty for the packer creators to change\nsome characteristics of the mechanism in order to bypass the\npatches issued by the emulators. The following techniques\nfall within this category:\n\n1. PEB structure fields\n2. library header values\n3. rare instructions\n4. window creation\n\nFor example, imagine an emulator that can be bypassed by\nsearching a not implemented field within the PEB structure.\nIn this case, the emulator can be fixed to properly implement\nthat field. Unfortunately, packer developers can find another\nPEB structure component which is improperly implemented\nor not implemented at all to use against the newly updated\nemulator.\nSimilarly, adding a rare instruction to the set of instructions the emulator implements solves the issue only temporarily until the packer creators find another rare instruction\nthat is not implemented in the same emulator.\nThe techniques listed below are part of the category\naccording to which both patching the emulators and bypassing the patch are easily performed.\n\n1. rare API functions\n2. return values of API functions\n3. register values changed by API function\n4. rare library presence\n\nFixing and bypassing the use of rare API function calls is\neven easier. The packer just calls an API without checking\nthe return value as in the previous technique. To fix this, the\nemulator can implement a function with that name by simply\nreturning the value 0, while the packer creators just change\nthe function.\n\n\n-----\n\nWhile most anti-emulator techniques requires the same\neffort (high, medium or low) for both emulator and packer\nwriters, there are some which don’t meet this requirement:\nthe usage of big loops and the usage of time / logic bombs.\nBoth are hard to fix in an emulator and easy to implement in\na packer\nRegarding the usage of big loops, an emulator can’t afford\nto execute a sample for a long period of time, which is\nrequired to bypass a big loop. Even more, an emulator is\nslower on execution than a real system. At the same time,\npacker creators will not have to do a complicated work to\nchange a big loop so that it is no longer detected and bypassed\nby the emulator.\nSimilarly, adding a time / logic bomb is easily achieved,\nwhile finding and bypassing it - hard.\n\n**6.2 UPA packers strategies**\n\nThe UPA 1 packer started with multiple and various complex\nanti-emulation techniques, encompassing rare instructions\nand functions, API result checks, PEB checks, big loops, as\nwell as various callbacks for FastPebLockRoutine, SecureMemoryCache, TopLevelExceptionFilter, TLS, and window\ncreation. As a response to emulators implementing the missing instructions, API functions, and callback mechanisms, it\nstarted to remove them one by one, remaining, in the end,\nmainly with big loops, containing simple but varying API\ncalls or / and instructions.\nThe UPA 2 packer performed, in its beginnings, some\nchecks on the state of the stack and on the values of the flags,\nbut understood fairly fast that these are not reliable ways\nfor emulator detection. Maturing, it started to rely heavily\non checking that the values of registers are changed accordingly after specific API calls and that specific libraries are\npresent on the system and have correct values for their specific header fields. Although these mechanisms are easily\nfixed in emulators, packer writers can also easily change the\nchecked API function or register in case of the first technique\nand the library or header field in case of the second technique.\nThe only solution to fix this problem generically would be\nimplementing correctly all the libraries and API functions in\nthe emulator, which is not feasible.\nThe UPA 3 packer individualizes by using almost exclusively mechanisms involving window creation and message\nhandling. It started with rather simple techniques, complicating them with a fast pace. In the end, however, it ended\nup returning to the simple ones, but obfuscating the code\nimplementing them so that detection is harder to add on the\nanti-emulation technique itself.\nThe simplicity, from the very beginning, of the UPA 2\npacker as well as the simplification of the execution flow\nwe witnessed by monitoring the evolution of the other two,\nlead us to the idea that packer creators are trying to reach\n\n\nan equilibrium between the complexity of the behavior and\nthe simplicity of the aspect of the developed anti-emulation\ntechniques. In this way, two goals are achieved.\nFirst, if anti-emulation techniques are hidden in plain sight\nby having the looks of simple pieces of code achieving simple\ntasks makes it harder for the malware researchers to spot and\nbypass them.\nSecond, by ensuring the emulation techniques are composed of operations found in many genuine use cases, the\nmalware creators prevent the malware researchers to add\ndetection to the anti-emulation technique itself as this would\ncause false positives. Many genuine applications use big\nloops with common API calls and instructions (UPA 1),\nlibrary checks (UPA 2), window creation and message handling (UPA 3).\n\n### References\n\n1. Branco, R.R., Barbosa, G.N., Neto, P.N.: Scientific but not academical overview of malware anti-debugging, anti-disassembly and\nanti-vm technologies. Blackhat, Las Vegas (2012)\n2. Quist, D., Smith, V.: Covert debugging circumventing software\narmoring techniques. Black Hat Briefings, Las Vegas (2007)\n3. Issa, A.: Anti-virtual machines and emulations. J. Comput. Virol.\n**[8(4), 141–149 (2012). doi:10.1007/s11416-012-0165-0](http://dx.doi.org/10.1007/s11416-012-0165-0)**\n4. Chubachi, Y., Aiko, K.: Tentacle: Environment-sensitive malware\npalpation\n5. Ferrie, P.: Anti-unpacker tricks–part one. Virus Bull. 4 (2008).\n\n[http://www.virusbtn.com/pdf/magazine/2008/200812.pdf](http://www.virusbtn.com/pdf/magazine/2008/200812.pdf)\n6. Yason, M.V.: The art of unpacking (2007). Retrieved 12 Feb 2008\n7. Tan, X.: Anti-unpacker tricks in malicious code. In: Proceedings\nof 10th Annual AVAR International Conference (2007)\n8. Ferrie, P.: The ultimate anti-debugging reference, p 14. Tech. rep.\n(2011)\n9. Falliere, N.: Windows anti-debug reference (2007). Retrieved 1 Oct\n2007\n10. Gao, S., Lin, Q., Xia, M., Yu, M., Qi, Z., Guan, H.: Debugging classification and anti-debugging strategies. In: Fourth International\nConference on Machine Vision (ICMV 11), pp. 83503C–83503C.\nInternational Society for Optics and Photonics (2011)\n11. Chen, X., Andersen, J., Mao, Z. M., Bailey, M., Nazario,\nJ.: Towards an understanding of anti-virtualization and antidebugging behavior in modern malware. In: The 38th Annual\nIEEE/IFIP International Conference on Dependable Systems and\nNetworks,DSN2008,June24–27,2008,Anchorage,Alaska,USA,\npp. 177–186 (2008)\n12. Shields, T.: Anti-debugging–a developers view. Veracode Inc.,\nUSA (2010)\n13. Qi, Z., Li, B., Lin, Q., Yu, M., Xia, Mingyuan, Guan, Haibing: SPAD: software protection through anti-debugging using\nhardware-assisted virtualization. J. Inf. Sci. Eng. 28(5), 813–827\n(2012)\n14. Yi, T., Zong, A., Yu, M., Gao, S., Lin, Q., Yu, P., Ren, Z., Qi,\nZ.: Anti-debugging framework based on hardware virtualization\ntechnology. In: ICRCCS’09 International Conference on Research\nChallenges in Computer Science, IEEE, pp. 218–220 (2009)\n15. Linn, C., Debray, S.K.: Obfuscation of executable code to improve\nresistance to static disassembly. In: Proceedings of the 10th ACM\nConference on Computer and Communications Security, CCS\n2003, ACM, Washington, DC, October 27–30, 2003, pp. 290–299\n\n\n-----\n\n16. Aycock, J., deGraaf, R., Jacobson Jr., M.: Anti-disassembly using\ncryptographic hash functions. J. Comput. Virol. 2(1), 79–85 (2006)\n17. Krügel, C., Robertson, W.K., Valeur, F., Vigna, G.: Static disassembly of obfuscated binaries. In: Proceedings of the 13th USENIX\nSecurity Symposium, August 9–13 2004, San Diego, CA, USA,\npp. 255–270 (2004)\n18. Ferrie, P.: Attacks on virtual machine emulators. Symantec Adv.\nThreat Res. (2008)\n19. Ferrie, P: Attacks on more virtual machine emulators. Symantec\nTechnol. Exch. 55 (2007)\n20. Ormandy, T.: An empirical study into the security exposure to\nhosts of hostile virtualized environments. 2007. Ce court article\nde recherche analyse la sécurité de quelques solutions de virtualisation, dont certaines traitées dans mon mémoire. Lauteur analyse\nla robustesse et la résilience des applications testées (2007)\n21. Reuben, J.S.: A survey on virtual machine security, vol. 2,\n[p 36. Helsinki University of Technology. http://www.tml.tkk.fi/](http://www.tml.tkk.fi/Publications/C/25/papers/Reuben_final.pdf)\n[Publications/C/25/papers/Reuben_final.pdf (2007)](http://www.tml.tkk.fi/Publications/C/25/papers/Reuben_final.pdf)\n\n\n22. Danny, Q., Smith, V.: Detecting the presence of virtual machines\nusing the local data table. Offens. Comput. (2006)\n23. Lau, B., Svajcer, V.: Measuring virtual machine detection in malware using DSD tracer. J. Comput. Virol. 6(3), 181–195 (2010)\n24. Raffetseder, T., Krügel, C., Kirda, E.: Detecting system emulators.\nIn: Information Security, 10th International Conference, ISC 2007,\nValparaíso, Chile, October 9–12, pp. 1–18 (2007)\n25. Kang, M.G., Yin, H., Hanna, S., McCamant, S., Song, D.: Emulating emulation-resistant malware. In: Proceedings of the 1st ACM\nworkshop on Virtual machine security, pp. 11–22. ACM (2009)\n26. ODea, H.: The Modern Roguemalware with a Face. In: Proceedings\nof the Virus Bulletin Conference (2009)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/AV Tech/Anti-emulation trends in modern packers.pdf"
    ],
    "report_names": [
        "Anti-emulation trends in modern packers.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535744,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1487016205,
    "ts_modification_date": 1487015712,
    "files": {
        "pdf": "https://archive.orkl.eu/e731a7c4c4a0042e5a80e9311d79cedbd38cd192.pdf",
        "text": "https://archive.orkl.eu/e731a7c4c4a0042e5a80e9311d79cedbd38cd192.txt",
        "img": "https://archive.orkl.eu/e731a7c4c4a0042e5a80e9311d79cedbd38cd192.jpg"
    }
}