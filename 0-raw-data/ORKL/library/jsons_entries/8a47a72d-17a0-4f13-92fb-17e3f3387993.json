{
    "id": "8a47a72d-17a0-4f13-92fb-17e3f3387993",
    "created_at": "2023-01-12T15:05:43.055571Z",
    "updated_at": "2025-03-27T02:11:00.591292Z",
    "deleted_at": null,
    "sha1_hash": "1d1715234d762ce2d3f1962c99fe5c64ab321da0",
    "title": "2020-04-27 - Quick look at Nazar's backdoor - Network Communication",
    "authors": "",
    "file_creation_date": "2022-05-28T04:04:56Z",
    "file_modification_date": "2022-05-28T04:04:56Z",
    "file_size": 95819,
    "plain_text": "# Quick look at Nazar's backdoor - Network Communication\n\n**blog.malwarelab.pl/posts/nazar_eyservice_comm/**\n\n## Intro\n\n\nApril 27, 2020\n\n\nIn [previous episode we described capabilities of Nazar’s EYService, an passive backdoor](https://blog.malwarelab.pl/posts/nazar_eyservice/)\nthat utilize PSSDK to sniff on network traffic. In this post we’ll take a look at how this malware\ncommunicates with outside world.\n\n## Binary Diffing\n\nMalware is statically linked with PSSDK which makes analysis not very pleasant, and the fact\nthat this software is long dead and has no documentation doesn’t help either! However it was\nquite popular back in the day and its not that hard to find examples of usage, the most\n[notable one being metasploit. Looking at their source code can give us some ideas how](https://github.com/rapid7/metasploit-payloads/blob/master/c/meterpreter/source/extensions/sniffer/sniffer.c)\nPSSDK API should be used.\n\nBut that is not enough, while we can guess some APIs a lot of them remains mystery - here\nwith help comes binary diffing and [Diaphora .1](https://github.com/joxeankoret/diaphora) We only need to find a good binary to diff\nagainst.\n\nFortunately authors of PSSDK used a lot of uniqe names for their classes such as\n\n```\nCHNSyncList or CHNMemoryStream or even CBpfAsmLexer - armed with those names\n\n```\nfinding a PSSDK dll is a matter of throwing them in your favorite search engine .2 Once we\nhad a binary our next problem turns out to be Diaphora and IDA Pro, Diaphora was ported to\nuse newest version of IDA’s API but it was also ported to Python3 and we prefer to stick to\n[Python2 as long as it is possible! If you are like us you can find our changes here. Ok](https://github.com/mak/diaphora)\nproblems solved lets do some diffing!\n\n## C2 Protocol\n\nAfter recovering API names from PSSDK we are presented with rather simple main function\n\n\n-----\n\n```\nDWORD __stdcall main_thread_func(LPVOID lpThreadParameter)\n{\n struc_1 *v1; // edi\n int v2; // esi\n const void **v4; // edi\n v1 = MgrCreate();\n MgrInitialize((int)v1);\n v2 = MgrGetFirstAdapterCfg(v1);\n do\n {\n  if ( !AdpCfgGetAdapterType(v2) )\n   break;\n  v2 = MgrGetNextAdapterCfg(v1, v2);\n }\n while ( v2 );\n g_Adp = AdpCreate();\n AdpSetConfig((int)g_Adp, v2);\n if ( !AdpOpenAdapter(g_Adp) )\n {\n  AdpGetConnectStatus((int)g_Adp);\n  Size = AdpCfgGetMaxPacketSize(v2);\n  g_My_IP = (char *)AdpCfgGetIpA(v2, 0);\n  AdpCfgGetMACAddress(v2, &g_My_MAC, 6);\n  v4 = (const void **)BpfCreate();\n  BpfAddCmd((int)v4, 0x30, 0x17);       // BPF_LD+BPF_B+BPF_ABS, [offset of\npacket.ip.proto]\n  BpfAddJmp((int)v4, 0x15, 0x11, 0, 1);    // BPF_JMP+BPF_JEQ+BPF_K,\nIP_PROTO_UDP\n  BpfAddCmd((int)v4, 6, -1);         // BPF_RET+BPF_K\n  BpfAddCmd((int)v4, 6, 0);          // BPF_RET+BPF_K\n  AdpSetUserFilter((int)g_Adp, v4);\n  AdpSetUserFilterActive((int)g_Adp, (void *)1);\n  AdpSetOnPacketRecv((int)g_Adp, (int)recive_packet, 0);\n  AdpSetMacFilter((int)g_Adp, 2);       // mfOwnerRecv\n  while ( 1 )\n  {\n   if ( g_SendPong == 1 )\n   {\n    g_My_IP = (char *)AdpCfgGetIpA(v2, 0);\n    C2::response(2);\n    g_SendPong = 0;\n   }\n   Sleep(0x3E8u);\n  }\n }\n return 0;\n}\n\n```\nWhats happening here, is basically boilerplate to set up BPF filter and a callback function\nthat will handle incomming packets. BPF filtere here checks if 23th byte of a packet equals\n17, 23th byte should be (in normal internet traffic) `Protocol field of IPv4 header, 17 is a`\nvalue denoting UDP in that field 3. BPF filter checks if incoming packet is using UDP protocol\n\n4\n\n\n-----\n\n## Requests from C2\n\nFunction `recive_packet is responsible for stripping down headers of next protocols and`\nfinally call a function that we described in previous post. Two important things are happening\nduring this parsing `Identification field is extracted from IPv4 header and` `Destination`\n```\nPort from UDP header. First one is save for later use, it will be important during crafting\n\n```\nresponse to c2, second is checked against 1234. If value of this field is different nothing will\nhappen. That tells us that this backdoor is passively listing on port 1234.\n```\nint __cdecl handle_udp(udp_hdr *a1, int a2, int src_ip, int ip_id)\n{\n int size; // edi\n size = HIBYTE(a1->len) - 8;\n ntohs(a1->src_port);\n if ( ntohs(a1->dst_port) != 1234 )\n  return 0;\n handle_commands((c2_packet *)&a1[1], src_ip, ip_id, size);\n return 1;\n}\n\n```\nAfter all headers are striped the content of UPD packet is straightforward\n\n## Response to C2\n\nLets move to responses, backdoor supports 3 types of responses\n\nsend `pong`\nsend victim info\nsend file\n\nSince UDP packets need to be crafted from scratch the code is quite messy but after\napplying proper types everything looks nice and clear\n\n\n-----\n\n```\n pPacket.ip_hdr._bf_0 (pPacket.ip_hdr._bf_0 & 0xF | 0x40) & 0xF5 | 5;\n pPacket.ip_hdr.ip_tos = 0;\n v5 = htons(payload_size + 28);\n pPacket.ip_hdr.ip_id = 1;\n pPacket.ip_hdr.ip_len = v5;\n pPacket.ip_hdr.ip_off = 0;\n pPacket.ip_hdr.ip_ttl = -1;\n pPacket.ip_hdr.ip_proto = 17;\n pPacket.ip_hdr.ip_chksum = 0;\n pPacket.ip_hdr.ip_src.S_un.S_addr = inet_addr(g_My_IP);\n pPacket.ip_hdr.ip_dst = v2;\n pPacket.udp_hdr.src_port = htons(1234u);\n pPacket.udp_hdr.dst_port = htons(4000u);\n pPacket.udp_hdr.len = htons(payload_size + 8);\n pPacket.udp_hdr.checksum = 0;\n\n```\nWe can even see some oddities that would make an good base for snort/suricata rule\n\n### - Ping\n\nC2 can request a live check issuing command 999, when malware sees a packet with this\ncommand it will replay to port 4000 with UDP packet containing simple string `101;0000;`\n\n### - OS info\n\nC2 can request informations on infected host issuing command 555 when malware sees a\npacket with this command it will replay to port 4000 with UDP packet that contains:\n\nComputer name\nVersion of operating system\n\n\npacket will have a fallowing format: `100;%COMPNAME%;%WINNAME%;`\n\n### - Send file\n\n\n5\n\n\nVarious commands can produce a files with logs and bot has to exfiltrate them, this is done\nin a same way as previous commands however destination port is different. Instead of using\nhardcoded one, previously saved value from `Identification field of incoming packet is`\nused. In order to exfiltrate a file bot will create packets containing content of the file and one\nmore packet with content ‘—%FILE_SIZE%’ where %FILE_SIZE% denotes a size of file\nbeing send to c2.\n\n## Closing words\n\nIn this post we showed how EYService communicates with c2. Digging into network protocol\nallows us to better understand its capabilities and fix previous wrong assumptions, gaining\nfull view of this malware. Understanding how malware is communicating is crucial for\n\n\n-----\n\ndetection as patterns used in network communication tend to stay longer unchanged\ncontrary to code of malware itself. Finally passive backdoors are pretty rare and their\nanalysis require knowledge of how internet protocols are build, so we are thankful for this\nopportunity to brush it up ;]\n\n## Snort/Suricata Rules\n```\nalert udp $HOME_NET 1234 -> $EXTERNAL_NET 4000 (msg:\"Nazar EYService Pong\nresponse\");id:1; ttl:-1;content:\"101;0000;\";reference: url,\nhttps://blog.malwarelab.pl/posts/nazar_eyservice_comm;classtype:trojan-activity;sid;1\nalert udp $HOME_NET 1234 -> $EXTERNAL_NET 4000 (msg:\"Nazar EYService OSInfo\nresponse\");id:1; ttl:-1;content:\"100;\";reference: url,\nhttps://blog.malwarelab.pl/posts/nazar_eyservice_comm;classtype:trojan-activity;sid;1\nalert udp $HOME_NET 1234 -> $EXTERNAL_NET any (msg:\"Nazar EYService File exfiltrate\nresponse\");id:1; ttl:-1;content:\"---\";reference: url,\nhttps://blog.malwarelab.pl/posts/nazar_eyservice_comm;classtype:trojan-activity;sid;1\n\n```\nPlease note that those rules are provided as is, and are created based on code rather than\nactual traffic, and where not battle tested!\n\n1. BinDiff is also an option but it has some problems with our binary ↩\n\n2. example of PSSDK dll,\n\nc5ef3bd6a93edaca685e2ea796f0684b208b4700b8bdcf8dfbf78c47aa9562c9 ↩\n\n[3. https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers](https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers) ↩\n\n4. there is an assumption here that all traffic is using Ethernet and IPv4 protocols on lower\n\nlevels of OSI model ↩\n\n5. Looking at the possible strings for os version shows us how old this malware can be as\n\na versions goes from win95 to win xp ↩\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-04-27 - Quick look at Nazar's backdoor - Network Communication.pdf"
    ],
    "report_names": [
        "2020-04-27 - Quick look at Nazar's backdoor - Network Communication.pdf"
    ],
    "threat_actors": [
        {
            "id": "bf773c52-830b-46e3-aa61-58c82eb323ee",
            "created_at": "2023-01-06T13:46:39.135077Z",
            "updated_at": "2025-03-27T02:00:03.004808Z",
            "deleted_at": null,
            "main_name": "Nazar",
            "aliases": [
                "SIG37"
            ],
            "source_name": "MISPGALAXY:Nazar",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f3b19931-3751-4ece-a235-15b397951dc2",
            "created_at": "2022-10-25T16:07:23.889537Z",
            "updated_at": "2025-03-27T02:02:10.015565Z",
            "deleted_at": null,
            "main_name": "Nazar",
            "aliases": [
                "SIG37"
            ],
            "source_name": "ETDA:Nazar",
            "tools": [
                "Distribute.exe",
                "EYService",
                "GpUpdates.exe",
                "Microolap Packet Sniffer",
                "TCPDUMP for Windows"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535943,
    "ts_updated_at": 1743041460,
    "ts_creation_date": 1653710696,
    "ts_modification_date": 1653710696,
    "files": {
        "pdf": "https://archive.orkl.eu/1d1715234d762ce2d3f1962c99fe5c64ab321da0.pdf",
        "text": "https://archive.orkl.eu/1d1715234d762ce2d3f1962c99fe5c64ab321da0.txt",
        "img": "https://archive.orkl.eu/1d1715234d762ce2d3f1962c99fe5c64ab321da0.jpg"
    }
}