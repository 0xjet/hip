{
    "id": "d56a0350-1f35-4950-84ce-97dceae85c83",
    "created_at": "2023-01-12T15:00:48.217661Z",
    "updated_at": "2025-03-27T02:05:28.007896Z",
    "deleted_at": null,
    "sha1_hash": "f4d016e8cf520d5078e2c160c65dd62a6ca82e8b",
    "title": "“This will only hurt for a moment”_ code injection on Linux and macOS with LD_PRELOAD",
    "authors": "",
    "file_creation_date": "2021-03-08T01:09:34Z",
    "file_modification_date": "2021-03-08T01:09:34Z",
    "file_size": 132825,
    "plain_text": "# “This will only hurt for a moment”: code injection on Linux and macOS with LD_PRELOAD\n\n**[getambassador.io/resources/code-injection-on-linux-and-macos](https://www.getambassador.io/resources/code-injection-on-linux-and-macos/)**\n\nItamar Turner-Trauring\n\nHave you ever wanted to make a program behave differently without modifying the source\ncode? On Linux and macOS (the operating system formerly known as OS X) you can do this\nwith the `LD_PRELOAD or` `DYLD_INSERT_LIBRARIES mechanisms respectively, which allow`\nyou to override the system and library calls from a particular process. While this may seem\ndangerous, it’s actually pretty easy to do and can be quite useful.\n\nIn this post I’ll discuss:\n\nWhy you might want to do this.\nHow these mechanisms work.\nSome limitations of the mechanisms involved, some of which impact both Linux and\nmacOS, and some of which are limited to macOS.\n\n## Code injection for fun and profit\n\nWhen you run a program it calls out to shared libraries, and to the kernel using system calls.\nOverriding these calls allows you to override the program’s behavior in a variety of\ninteresting ways.\n\nFor example, your program will often need to check the current time. What if you wanted to\nchange it to be a different value? You could change the whole system’s clock, but that’s\nproblematic and may have unexpected side-effects on other programs.\n\n[Alternatively, you can use faketime to override the calls that retrieve the current time.](https://github.com/wolfcw/libfaketime/)\nInstead of getting the real time a wrapped process will get whatever time you choose to set:\n```\n$ /bin/date\nThu Apr 13 14:29:25 EDT 2017\n$ faketime '2008-12-24 08:15:42' /bin/date\nWed Dec 24 08:15:42 EST 2008\n\n```\n\n-----\n\n[Other uses include making a process look like root when setting file permissions, or](https://wiki.debian.org/FakeRoot/)\n[pretending you have changed the root of the filesystem.](https://github.com/dex4er/fakechroot/)\n\n[Here at Datawire, to give another example, we’ve been working on Telepresence, a program](http://telepresence.io/)\n[that makes a local process appear as if it were in a remote cluster running Kubernetes.](https://kubernetes.io/)\nKubernetes runs its own DNS server, with custom domain names like\n```\nmyservice.default.svc.cluster.local, and has its own internal IPs for services. We\n\n```\nwant these IPs and DNS records to be used by the local process.\n\n[There are other ways to achieve this effect, but we’ve been using torsocks, which overrides](https://github.com/dgoulet/torsocks/)\nTCP socket connections\nand DNS lookups and routes them through a proxy. The original purpose of `torsocks was`\nto route calls through the Tor onion router network, which gives users greater privacy. Here\nyou can see how my external IP changes when I run a process under `torsocks . I send a`\n[request to ipify.org, an API that returns the callers IP address, and as you can see](http://ipify.org/) `torsocks`\ntransparently routes my HTTP request through various Tor proxies:\n```\n$ curl http://api.ipify.org?format=json # get my external IP\n{\"ip\":\"98.216.104.162\"}\n$ torsocks curl http://api.ipify.org?format=json # get my external IP, via tor\n{\"ip\":\"144.217.161.119\"}\n$ host 144.217.161.119\n119.161.217.144.in-addr.arpa domain name pointer tor-exit.clutterbuck.uk.\n\n```\nSo how do all these programs work?\n\n## No process is an island\n\nWhen you run a program the resulting process cannot operate on its own. It needs\nfunctionality from libraries and from the kernel; the libraries may in turn depend on other\nlibraries or on the kernel. Consider this simple C program:\n\n\n-----\n\n```\n#include <stdio.h>\nint main()\n{\nprintf(\"Hello, world!\");\nreturn 0;\n}\n```</stdio.h>\nNote that this and later examples are on Linux; I'll mention differences from macOS\nwhere relevant.\nWe can compile the program statically and run the resulting binary:\n```console\n$ gcc -static hello.c -o hello-static\n$ chmod +x hello-static\n$ ./hello-static\nHello, world!\n\n```\nThe size of the binary is rather large, considering what it does:\n```\n$ ls -lh hello-static\n-rwxrwxr-x 1 itamarst itamarst 888K Apr 13 14:44 hello-static\n\n```\nThat’s because we compiled it statically: all the code it relies on, other than the kernel, is\nincluded in the file. We can watch calls to the kernel, aka system calls, using the `strace`\nutility (or `dtruss on macOS):`\n```\n$ strace ./hello-static > /dev/null\nexecve(\"./hello-static\", [\"./hello-static\"], [/* 91 vars */]) = 0\n... elided ...\nwrite(1, \"Hello, world!\\n\", 14) = 14\nexit_group(0) = ?\n+++ exited with 0 +++\n\n```\nAs you can see the `printf library call ended up calling the` `write system call.`\n\n\n-----\n\n## From system calls to shared libraries\n\nMost binaries are not distributed as static binaries. Instead of library code being included in\nthe binary, the binary just notes the shared libraries it relies on, and they get loaded at\nruntime:\n```\n$ gcc -fPIC hello.c -o hello-shared\n$ chmod +x hello-shared\n$ ./hello-shared\nHello, world!\n$ ls -lh hello-shared\n-rwxrwxr-x 1 itamarst itamarst 8.4K Apr 13 14:47 hello-shared\n\n```\nWe’ve gone from a binary of 888k to only 8k!\n\nSo what are these shared libraries the binary relies on? We can list them using `ldd (or the`\nsimilar but not identical `otool on macOS):`\n```\n$ ldd /bin/echo\nlinux-vdso.so.1 => (0x00007fff1b726000)\nlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fef59330000)\n/lib64/ld-linux-x86-64.so.2 (0x000056139fb3e000)\n   linux-vdso.so.1 is a way for the Linux kernel to inject kernel code into the process\n\n```\nmemory, so that certain system calls run faster.\n```\n   libc.so.6 is the C standard library, which includes APIs like printf .\n   ld-linux-x86-64.so.2 is the dynamic linker: this is the code that knows how to load\n\n```\nother shared libraries, like `libc.so.6, into the process memory on startup.`\n\nJust like the static binary we can use `strace to watch the system calls from running the`\nshared binary:\n\n\n-----\n\n```\n$ strace ./hello shared > /dev/null\nexecve(\"./hello-shared\", [\"./hello-shared\"], [/* 91 vars */]) = 0\n... elided ...\nopen(\"/lib/x86_64-linux-gnu/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0P\\t\\2\\0\\0\\0\\0\\0\"..., 832) =\n832\n... elided ...\nwrite(1, \"Hello, world!\\n\", 14) = 14\nexit_group(0) = ?\n+++ exited with 0 +++\n\n```\nNotice how this time the binary loaded additional files, the `libc.so.6 shared library.`\n\nIn the static binary the implementation of `printf was included in the binary itself, part of`\nthe extra 880kb of data in that binary.In the shared binary that code lives in `libc.so.6,`\nand we can use the `ltrace utility to see that call:`\n\n\n-----\n\n```\n$ ltrace ./hello shared > /dev/null\n__libc_start_main(0x400526, 1, 0x7ffc47290b48, 0x400540 <unfinished>\nputs(\"Hello, world!\") = 14\n+++ exited (status 0) +++\n```</unfinished>\nWhere's `printf`, you may ask?\nAs it turns out, the generated binary isn't using `printf`, it's actually using\n`puts` instead. The compiler has decided to use `puts` as an optimization since no\nformatting is involved and so `puts` is a simpler and faster equivalent. We can see\nthat `puts` is defined but not implemented in the binary by using the `nm` utility to\nlook up undefined symbols:\n```console\n$ nm -u ./hello-shared\nw __gmon_start__\nw _ITM_deregisterTMCloneTable\nw _ITM_registerTMCloneTable\nw _Jv_RegisterClasses\nU __libc_start_main@@GLIBC_2.2.5\nU puts@@GLIBC_2.2.5\n\n## Injecting shared libraries\n\n```\nRemember how `ld-linux loads shared libraries? It also does some other useful things. In`\nparticular, if you set the `LD_PRELOAD environment variable it will load the shared libraries`\nset in that variable into the process. (On macOS this variable is called\n```\nDYLD_INSERT_LIBRARIES .)\n\n```\nThis injected library can override functions in other shared libraries, and if we choose call\nback to the original version. For example, recall that we discovered that `printf is`\nimplemented using `puts . Let’s override` `puts with the following shared library:`\n\n\n-----\n\n```\n#include <dlfcn.h></dlfcn.h>\ntypedef int (*original_puts_function_type)(const char *str);\n/* Our custom version that will override the libc version: */\nint puts(const char *str)\n{\n/* Load the original puts(): */\noriginal_puts_function_type original_puts;\noriginal_puts = (original_puts_function_type) dlsym(RTLD_NEXT,\"puts\");\n/* Call it twice: */\noriginal_puts(str);\nreturn original_puts(str);\n}\n\n```\nNow we can compile this into a library, and then use it to override the call to `puts in our`\nshared binary:\n```\n$ gcc -shared -fPIC -o doubleputs.so doubleputs.c -ldl\n$ LD_PRELOAD=./doubleputs.so ./hello-shared\nHello, world!\nHello, world!\n\n```\nThe `ld-linux linker loads` `doubleputs.so into the process, and all calls to` `puts get`\nrouted to our overridden version. And that’s how `torsocks and` `faketime and`\n```\nfakechroot all work: by overriding system or library calls with custom versions using the\nLD_PRELOAD mechanism.\n\n## Caveats and limitations\n\n```\nCode injection has its share of problems, of course.\n\n### Which functions?\n\nRemember how we compiled a program with `printf() but got a binary with` `puts()`\ninstead? More broadly, the library calls you need to wrap in order to inject code are hard to\npredict.\n\n\n-----\n\nSome library calls will have multiple variants, some library calls will share internal private\nimplementations with other library calls… none of them are likely to be designed for code\ninjection.\n\nEven worse, different operating systems and compilers will require you to wrap different\ncalls:\n\nOur original example using `gcc on Linux ended up using` `puts .`\nOn OS X I got a binary that called `_printf .`\nOn Linux using the `clang compiler instead of` `gcc I got a binary that called`\n```\n   printf .\n\n### Static binaries and Go\n\n```\nSince `LD_PRELOAD and the macOS equivalent work using the dynamic linker, it doesn’t`\nwork for static binaries. Notice we don’t get a double print:\n```\n$ LD_PRELOAD=./doubleputs.so ./hello-static\nHello, world!\n\n```\nTypically the only place you’ll encounter static binaries is when writing Go. The default Go\ncompiler has its own mechanism for calling system calls directly, and tends to ship static\nbinaries. If you want to use `LD_PRELOAD with Go your best bet is to use` `gccgo, the` `gcc -`\nbased Go compiler.\n\n### Security problems\n\nFor security reasons `LD_PRELOAD doesn’t work with suid binaries: the ability to inject`\narbitrary code into a process running as another user has some obvious problems.\n\nOn macOS there is an additional problem. Newer versions of macOS have a security\nsubsystem called `System Integrity Protection . For our purposes the problem is that it`\nprevents injecting code via `DYLD_INSERT_LIBRARIES (the macOS equivalent of`\n```\nLD_PRELOAD ) into any binary in /bin, /sbin, /usr/bin and /usr/sbin .\n\n```\nLuckily, there’s an easy workaround. Just create a new directory, copy all the binaries from\n```\n/bin, /sbin, /usr/bin and /usr/sbin into that directory, and then add it to the start\n\n```\nof your `$PATH environment variable. Once the binaries are out of those special directories`\ncode injection works just fine, and since they’re only 100MB copying them is quite fast.\n\n## Further reading\n\n[Rafał Cieślak wrote an excellent intro to](https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/) `LD_PRELOAD ; I borrowed the` `dlsym code`\nfrom there.\n\n\n-----\n\n[The man pages for ld-linux and dyld explain the](https://linux.die.net/man/8/ld-linux/) `LD_PRELOAD and`\n```\n   DYLD_INSERT_LIBRARIES environment variables respectively in more detail.\n\n```\n[And if you’re a Kubernetes developer check out Telepresence, a great way to have a local](https://telepresence.io/)\ndevelopment environment for a remote Kubernetes cluster.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Process Injection/“This will only hurt for a moment”_ code injection on Linux and macOS with LD_PRELOAD.pdf"
    ],
    "report_names": [
        "“This will only hurt for a moment”_ code injection on Linux and macOS with LD_PRELOAD.pdf"
    ],
    "threat_actors": [
        {
            "id": "a66438a8-ebf6-4397-9ad5-ed07f93330aa",
            "created_at": "2022-10-25T16:47:55.919702Z",
            "updated_at": "2025-03-27T02:05:17.412024Z",
            "deleted_at": null,
            "main_name": "IRON VIKING",
            "aliases": [
                "ATK14 ",
                "BlackEnergy Group",
                "Blue Echidna ",
                "CTG-7263 ",
                "ELECTRUM ",
                "FROZENBARENTS ",
                "Hades/OlympicDestroyer ",
                "IRIDIUM ",
                "Qudedagh ",
                "Sandworm Team ",
                "Seashell Blizzard ",
                "TEMP.Noble ",
                "Telebots ",
                "Voodoo Bear ",
                "APT44 "
            ],
            "source_name": "Secureworks:IRON VIKING",
            "tools": [
                " BlackEnergy",
                " GCat",
                " GreyEnergy",
                " Industroyer",
                " KillDisk",
                " NotPetya",
                " PSCrypt",
                " TeleBot",
                " TeleDoor",
                " xData",
                "BadRabbit"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "b3e954e8-8bbb-46f3-84de-d6f12dc7e1a6",
            "created_at": "2022-10-25T15:50:23.339976Z",
            "updated_at": "2025-03-27T02:00:55.446795Z",
            "deleted_at": null,
            "main_name": "Sandworm Team",
            "aliases": [
                "Sandworm Team",
                "ELECTRUM",
                "Telebots",
                "IRON VIKING",
                "BlackEnergy (Group)",
                "Quedagh",
                "Voodoo Bear",
                "IRIDIUM",
                "Seashell Blizzard",
                "FROZENBARENTS",
                "APT44"
            ],
            "source_name": "MITRE:Sandworm Team",
            "tools": [
                "Bad Rabbit",
                "Mimikatz",
                "Exaramel for Linux",
                "Exaramel for Windows",
                "GreyEnergy",
                "PsExec",
                "Prestige",
                "P.A.S. Webshell",
                "VPNFilter",
                "Cyclops Blink",
                "SDelete",
                "AcidRain",
                "Industroyer",
                "Industroyer2",
                "BlackEnergy",
                "Cobalt Strike",
                "NotPetya",
                "KillDisk",
                "PoshC2",
                "Impacket",
                "Invoke-PSImage",
                "Olympic Destroyer"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "39842197-944a-49fd-9bec-eafa1807e0ea",
            "created_at": "2022-10-25T16:07:24.310589Z",
            "updated_at": "2025-03-27T02:02:10.167471Z",
            "deleted_at": null,
            "main_name": "TeleBots",
            "aliases": [],
            "source_name": "ETDA:TeleBots",
            "tools": [
                "BadRabbit",
                "Black Energy",
                "BlackEnergy",
                "CredRaptor",
                "Diskcoder.C",
                "EternalPetya",
                "ExPetr",
                "Exaramel",
                "FakeTC",
                "Felixroot",
                "GreyEnergy",
                "GreyEnergy mini",
                "KillDisk",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "NonPetya",
                "NotPetya",
                "Nyetya",
                "Petna",
                "Petrwrap",
                "Pnyetya",
                "TeleBot",
                "TeleDoor",
                "Win32/KillDisk.NBB",
                "Win32/KillDisk.NBC",
                "Win32/KillDisk.NBD",
                "Win32/KillDisk.NBH",
                "Win32/KillDisk.NBI",
                "nPetya"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "8941e146-3e7f-4b4e-9b66-c2da052ee6df",
            "created_at": "2023-01-06T13:46:38.402513Z",
            "updated_at": "2025-03-27T02:00:02.824555Z",
            "deleted_at": null,
            "main_name": "Sandworm",
            "aliases": [
                "G0034",
                "IRIDIUM",
                "Blue Echidna",
                "FROZENBARENTS",
                "Seashell Blizzard",
                "IRON VIKING",
                "ELECTRUM",
                "TeleBots",
                "UAC-0113",
                "UAC-0082",
                "APT44",
                "Quedagh",
                "VOODOO BEAR",
                "TEMP.Noble"
            ],
            "source_name": "MISPGALAXY:Sandworm",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535648,
    "ts_updated_at": 1743041128,
    "ts_creation_date": 1615165774,
    "ts_modification_date": 1615165774,
    "files": {
        "pdf": "https://archive.orkl.eu/f4d016e8cf520d5078e2c160c65dd62a6ca82e8b.pdf",
        "text": "https://archive.orkl.eu/f4d016e8cf520d5078e2c160c65dd62a6ca82e8b.txt",
        "img": "https://archive.orkl.eu/f4d016e8cf520d5078e2c160c65dd62a6ca82e8b.jpg"
    }
}