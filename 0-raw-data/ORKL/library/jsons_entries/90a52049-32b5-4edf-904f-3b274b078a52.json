{
    "id": "90a52049-32b5-4edf-904f-3b274b078a52",
    "created_at": "2023-01-12T15:07:40.310941Z",
    "updated_at": "2025-03-27T02:06:12.801852Z",
    "deleted_at": null,
    "sha1_hash": "c0e1f17de4c688f3c795dbde083658c9130cbd44",
    "title": "2020-10-08 - Sophisticated new Android malware marks the latest evolution of mobile ransomware",
    "authors": "",
    "file_creation_date": "2022-05-28T22:07:14Z",
    "file_modification_date": "2022-05-28T22:07:14Z",
    "file_size": 6399486,
    "plain_text": "# Sophisticated new Android malware marks the latest evolution of mobile ransomware\n\n**microsoft.com/security/blog/2020/10/08/sophisticated-new-android-malware-marks-the-latest-evolution-of-mobile-**\nransomware/\n\nOctober 8, 2020\n\nAttackers are persistent and motivated to continuously evolve – and no platform is immune.\nThat is why Microsoft has been working to extend its industry-leading endpoint protection\n[capabilities beyond Windows. The addition of mobile threat defense into these capabilities](https://techcommunity.microsoft.com/t5/microsoft-defender-for-endpoint/microsoft-defender-for-endpoint-adds-depth-and-breadth-to-threat/ba-p/1695824)\nmeans that Microsoft Defender for Endpoint (previously Microsoft Defender Advanced Threat\nProtection) now delivers protection on all major platforms.\n\nMicrosoft’s mobile threat defense capabilities further enrich the visibility that organizations\nhave on threats in their networks, as well as provide more tools to detect and respond to\nthreats across domains and across platforms. Like all of Microsoft’s security solutions, these\nnew capabilities are likewise backed by a global network of threat researchers and security\nexperts whose deep understanding of the threat landscape guide the continuous innovation\nof security features and ensure that customers are protected from ever-evolving threats.\n\nFor example, we found a piece of a particularly sophisticated Android ransomware with novel\ntechniques and behavior, exemplifying the rapid evolution of mobile threats that we have also\nobserved on other platforms. The mobile ransomware, detected by Microsoft Defender for\nEndpoint as AndroidOS/MalLocker.B, is the latest variant of a ransomware family that’s been\nin the wild for a while but has been evolving non-stop. This ransomware family is known for\nbeing hosted on arbitrary websites and circulated on online forums using various social\nengineering lures including masquerading as popular apps cracked games or video\n\n\n-----\n\nplayers. The new variant caught our attention because it s an advanced malware with\nunmistakable malicious characteristic and behavior and yet manages to evade many\navailable protections, registering a low detection rate against security solutions.\n\nAs with most Android ransomware, this new threat doesn’t actually block access to files by\nencrypting them. Instead, it blocks access to devices by displaying a screen that appears\nover every other window, such that the user can’t do anything else. The said screen is the\nransom note, which contains threats and instructions to pay the ransom.\n\n_Figure 1. Sample ransom note used by older ransomware variants_\n\n\n-----\n\nWhat s innovative about this ransomware is how it displays its ransom note. In this blog, we ll\ndetail the innovative ways in which this ransomware surfaces its ransom note using Android\nfeatures we haven’t seen leveraged by malware before, as well as incorporating an opensource machine learning module designed for context-aware cropping of its ransom note.\n\n## New scheme, same goal\n\nIn the past, Android ransomware used a special permission called\n“SYSTEM_ALERT_WINDOW” to display their ransom note. Apps that have this permission\ncan draw a window that belongs to the system group and can’t be dismissed. No matter what\nbutton is pressed, the window stays on top of all other windows. The notification was\nintended to be used for system alerts or errors, but Android threats misused it to force the\nattacker-controlled UI to fully occupy the screen, blocking access to the device. Attackers\ncreate this scenario to persuade users to pay the ransom so they can gain back access to\nthe device.\n\nTo catch these threats, security solutions used heuristics that focused on detecting this\n[behavior. Google later implemented platform-level changes that practically eliminated this](https://www.androidpolice.com/2019/03/16/android-q-steps-up-the-fight-up-against-overlay-based-malware/)\nattack surface. These changes include:\n\n1. Removing the SYSTEM_ALERT_WINDOW error and alert window types, and\n\nintroducing a few other types as replacement\n2. Elevating the permission status of SYSTEM_ALERT_WINDOW to special permission\n\nby putting it into the “above dangerous” category, which means that users have to go\nthrough many screens to approve apps that ask for permission, instead of just one click\n3. Introducing an overlay kill switch on Android 8.0 and later that users can activate\n\nanytime to deactivate a system alert window\n\nTo adapt, Android malware evolved to misusing other features, but these aren’t as effective.\nFor example, some strains of ransomware abuse accessibility features, a method that could\neasily alarm users because accessibility is a special permission that requires users to go\nthrough several screens and accept a warning that the app will be able to monitor activity via\naccessibility services. Other ransomware families use infinite loops of drawing non-system\nwindows, but in between drawing and redrawing, it’s possible for users to go to settings and\nuninstall the offending app.\n\nThe new Android ransomware variant overcomes these barriers by evolving further than any\nAndroid malware we’ve seen before. To surface its ransom note, it uses a series of\ntechniques that take advantage of the following components on Android:\n\n1. The “call” notification, among several categories of notifications that Android supports,\n\nwhich requires immediate user attention.\n\n\n-----\n\n2. The onUserLeaveHint() callback method of the Android Activity (i.e., the typical GUI\n\nscreen the user sees) is called as part of the activity lifecycle when the activity is about\nto go into the background as a result of user choice, for example, when the user\npresses the Home key.\n\nThe malware connects the dots and uses these two components to create a special type of\nnotification that triggers the ransom screen via the callback.\n\n_Figure 2. The notification with full intent and set as “call’ category_\n\nAs the code snippet shows, the malware creates a notification builder and then does the\nfollowing:\n\n1. setCategory(“call”) – This means that the notification is built as a very important\n\nnotification that needs special privilege.\n2. setFullScreenIntent() – This API wires the notification to a GUI so that it pops up when\n\nthe user taps on it. At this stage, half the job is done for the malware. However, the\nmalware wouldn’t want to depend on user interaction to trigger the ransomware screen,\nso, it adds another functionality of Android callback:\n\n\n-----\n\n_Figure 3. The malware overriding onUserLeaveHint_\n\nAs the code snippet shows, the malware overrides the onUserLeaveHint() callback function\nof Activity class. The function onUserLeaveHint() is called whenever the malware screen is\npushed to background, causing the in-call Activity to be automatically brought to the\nforeground. Recall that the malware hooked the RansomActivity intent with the notification\nthat was created as a “call” type notification. This creates a chain of events that triggers the\nautomatic pop-up of the ransomware screen without doing infinite redraw or posing as\nsystem window.\n\n## Machine learning module indicates continuous evolution\n\nAs mentioned, this ransomware is the latest variant of a malware family that has undergone\nseveral stages of evolution. The knowledge graph below shows the various techniques this\nransomware family has been seen using, including abusing the system alert window, abusing\naccessibility features, and, more recently, abusing notification services.\n\n\n-----\n\n_Figure 4. Knowledge graph of techniques used by ransomware family_\n\nThis ransomware family’s long history tells us that its evolution is far from over. We expect it\nto churn out new variants with even more sophisticated techniques. In fact, recent variants\ncontain code forked from an open-source machine learning module used by developers to\nautomatically resize and crop images based on screen size, a valuable function given the\nvariety of Android devices.\n\nThe frozen TinyML model is useful for making sure images fit the screen without distortion. In\nthe case of this ransomware, using the model would ensure that its ransom note—typically\nfake police notice or explicit images supposedly found on the device—would appear less\ncontrived and more believable, increasing the chances of the user paying for the ransom.\n\nThe library that uses tinyML is not yet wired to the malware’s functionalities, but its presence\nin the malware code indicates the intention to do so in future variants. We will continue to\nmonitor this ransomware family to ensure customers are protected and to share our findings\nand insights to the community for broad protection against these evolving mobile threats.\n\n## Protecting organizations from threats across domains and platforms\n\n\n-----\n\nMobile threats continue to rapidly evolve, with attackers continuously attempting to sidestep\ntechnological barriers and creatively find ways to accomplish their goal, whether financial\ngain or finding an entry point to broader network compromise.\n\nThis new mobile ransomware variant is an important discovery because the malware exhibits\nbehaviors that have not been seen before and could open doors for other malware to follow.\nIt reinforces the need for comprehensive defense powered by broad visibility into attack\nsurfaces as well as domain experts who track the threat landscape and uncover notable\nthreats that might be hiding amidst massive threat data and signals.\n\nMicrosoft Defender for Endpoint on Android, now generally available, extends Microsoft’s\nindustry-leading endpoint protection to Android. It detects this ransomware\n(AndroidOS/MalLocker.B), as well as other malicious apps and files using cloud-based\nprotection powered by deep learning and heuristics, in addition to content-based detection. It\nalso protects users and organizations from other mobile threats, such as mobile phishing,\nunsafe network connections, and unauthorized access to sensitive data. Learn more about\nour [mobile threat defense capabilities in](https://techcommunity.microsoft.com/t5/microsoft-defender-for-endpoint/microsoft-defender-for-endpoint-adds-depth-and-breadth-to-threat/ba-p/1695824) [Microsoft Defender for Endpoint on Android.](https://techcommunity.microsoft.com/t5/microsoft-defender-atp/announcing-microsoft-defender-atp-for-android/ba-p/1480787)\n\n[Malware, phishing, and other threats detected by Microsoft Defender for Endpoint are](https://www.microsoft.com/microsoft-365/windows/microsoft-defender-atp?rtc=1)\nreported to the Microsoft Defender Security Center, allowing SecOps to investigate mobile\nthreats along with endpoint signals from Windows and other platforms using Microsoft\nDefender for Endpoint’s rich set of tools for detection, investigation, and response.\n\nThreat data from endpoints are combined with signals from email and data, identities, and\napps in [Microsoft 365 Defender (previously Microsoft Threat Protection), which orchestrates](https://www.microsoft.com/en-us/security/business/threat-protection/integrated-threat-protection)\ndetection, prevention, investigation, and response across domains, providing coordinated\ndefense. Microsoft Defender for Endpoint on Android further enriches organizations’ visibility\ninto malicious activity, empowering them to comprehensively prevent, detect, and respond to\nagainst attack sprawl and cross-domain incidents.\n\n## Technical analysis\n\n### Obfuscation\n\nOn top of recreating ransomware behavior in ways we haven’t seen before, the Android\nmalware variant uses a new obfuscation technique unique to the Android platform. One of\nthe tell-tale signs of an obfuscated malware is the absence of code that defines the classes\ndeclared in the manifest file.\n\n\n-----\n\n_Figure 5. Manifest file_\n\nThe classes.dex has implementation for only two classes:\n\n1. The main application class gCHotRrgEruDv, which is involved when the application\n\nopens\n2. A helper class that has definition for custom encryption and decryption\n\nThis means that there’s no code corresponding to the services declared in the manifest file:\n_Main Activity, Broadcast Receivers, and Background. How does the malware work without_\ncode for these key components? As is characteristic for obfuscated threats, the malware has\nencrypted binary code stored in the Assets folder:\n\n\n-----\n\n_Figure 6. Encrypted executable code in Assets folder_\n\nWhen the malware runs for the first time, the static block of the main class is run. The code is\nheavily obfuscated and made unreadable through name mangling and use of meaningless\nvariable names:\n\n_Figure 7. Static block_\n\n### Decryption with a twist\n\nThe malware uses an interesting decryption routine: the string values passed to the\ndecryption function do not correspond to the decrypted value, they correspond to junk code\nto simply hinder analysis.\n\nOn Android, an Intent is a software mechanism that allows users to coordinate the functions\nof different Activities to achieve a task. It’s a messaging object that can be used to request\nan action from another app component.\n\n\n-----\n\nThe Intent object carries a string value as _action parameter. The malware creates an Intent_\ninside the decryption function using the string value passed as the name for the Intent. It\nthen decrypts a hardcoded encrypted value and sets the “action” parameter of the Intent\nusing the setAction API. Once this Intent object is generated with the action value pointing to\nthe decrypted content, the decryption function returns the Intent object to the callee. The\ncallee then invokes the getAction method to get the decrypted content.\n\n_Figure 8. Decryption function using the Intent object to pass the decrypted value_\n\n### Payload deployment\n\nOnce the static block execution is complete, the Android Lifecycle callback transfers the\ncontrol to the OnCreate method of the main class.\n\n_Figure 9. onCreate method of the main class decrypting the payload_\n\nNext, the malware-defined function decryptAssetToDex (a meaningful name we assigned\nduring analysis) receives the string “CuffGmrQRT” as the first argument, which is the name\nof the encrypted file stored in the Assets folder.\n\n\n-----\n\n_Figure 10. Decrypting the assets_\n\nAfter being decrypted, the asset turns into the .dex file. This is a notable behavior that is\ncharacteristic of this ransomware family.\n\n_Figure 11. Asset file before and after decryption_\n\nOnce the encrypted executable is decrypted and dropped in the storage, the malware has\nthe definitions for all the components it declared in the manifest file. It then starts the final\ndetonator function to load the dropped .dex file into memory and triggers the main payload.\n\n\n-----\n\n_Figure 12. Loading the decrypted .dex file into memory and triggering the main payload_\n\n### Main payload\n\nWhen the main payload is loaded into memory, the initial detonator hands over the control to\nthe main payload by invoking the method XoqF (which we renamed to triggerInfection during\nanalysis) from the gvmthHtyN class (renamed to PayloadEntry).\n\n_Figure 13. Handover from initial module to the main payload_\n\n\n-----\n\nAs mentioned, the initial handover component called triggerInfection with an instance of\n_appObj and a method that returns the value for the variable config._\n\n_Figure 14. Definition of populateConfigMap, which loads the map with values_\n\nCorrelating the last two steps, one can observe that the malware payload receives the\nconfiguration for the following properties:\n\n1. number – The default number to be send to the server (in case the number is not\n\navailable from the device)\n2. api – The API key\n3. url – The URL to be used in WebView to display on the ransom note\n\nThe malware saves this configuration to the shared preferences of the app data and then it\nsets up all the Broadcast Receivers. This action registers code components to get notified\nwhen certain system events happen. This is done in the function initComponents.\n\n\n-----\n\n_Figure 15. Initializing the BroadcastReceiver against system events_\n\nFrom this point on, the malware execution is driven by callback functions that are triggered\non system events like connectivity change, unlocking the phone, elapsed time interval, and\nothers.\n\n**_Dinesh Venkatesan_**\n\n_Microsoft Defender Research_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-10-08 - Sophisticated new Android malware marks the latest evolution of mobile ransomware.pdf"
    ],
    "report_names": [
        "2020-10-08 - Sophisticated new Android malware marks the latest evolution of mobile ransomware.pdf"
    ],
    "threat_actors": [
        {
            "id": "529c1ae9-4579-4245-86a6-20f4563a695d",
            "created_at": "2022-10-25T16:07:23.702006Z",
            "updated_at": "2025-03-27T02:02:09.93109Z",
            "deleted_at": null,
            "main_name": "Hafnium",
            "aliases": [
                "Red Dev 13",
                "Silk Typhoon"
            ],
            "source_name": "ETDA:Hafnium",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "7c969685-459b-4c93-a788-74108eab6f47",
            "created_at": "2023-01-06T13:46:39.189751Z",
            "updated_at": "2025-03-27T02:00:03.017103Z",
            "deleted_at": null,
            "main_name": "HAFNIUM",
            "aliases": [
                "ATK233",
                "G0125",
                "Operation Exchange Marauder",
                "Red Dev 13",
                "Silk Typhoon"
            ],
            "source_name": "MISPGALAXY:HAFNIUM",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "2704d770-43b4-4bc4-8a5a-05df87416848",
            "created_at": "2022-10-25T15:50:23.306305Z",
            "updated_at": "2025-03-27T02:00:55.43633Z",
            "deleted_at": null,
            "main_name": "HAFNIUM",
            "aliases": [
                "HAFNIUM",
                "Operation Exchange Marauder",
                "Silk Typhoon"
            ],
            "source_name": "MITRE:HAFNIUM",
            "tools": [
                "Tarrask",
                "ASPXSpy",
                "Impacket",
                "PsExec",
                "China Chopper"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536060,
    "ts_updated_at": 1743041172,
    "ts_creation_date": 1653775634,
    "ts_modification_date": 1653775634,
    "files": {
        "pdf": "https://archive.orkl.eu/c0e1f17de4c688f3c795dbde083658c9130cbd44.pdf",
        "text": "https://archive.orkl.eu/c0e1f17de4c688f3c795dbde083658c9130cbd44.txt",
        "img": "https://archive.orkl.eu/c0e1f17de4c688f3c795dbde083658c9130cbd44.jpg"
    }
}