{
    "id": "7dabad3e-df00-4e44-b5d4-ef75d3dbc5e2",
    "created_at": "2023-01-12T15:07:58.453684Z",
    "updated_at": "2025-03-27T02:12:03.894464Z",
    "deleted_at": null,
    "sha1_hash": "3401cf48c37cec6d4f036a8032400f5f5d09746d",
    "title": "2022-05-04 - Scheduled Task Tampering",
    "authors": "",
    "file_creation_date": "2022-05-27T19:06:02Z",
    "file_modification_date": "2022-05-27T19:06:02Z",
    "file_size": 738283,
    "plain_text": "# Scheduled Task Tampering\n\n**labs.f-secure.com/blog/scheduled-task-tampering/**\n\n## Introduction\n\n[Microsoft recently published an article that documented how the HAFNIUM threat actor](https://www.microsoft.com/security/blog/2022/04/12/tarrask-malware-uses-scheduled-tasks-for-defense-evasion/)\nleveraged a flaw in how scheduled tasks are stored in the registry to hide their presence.\nThis made it immediately clear that it was likely that the one presented was not the only flaw\nthat affected the scheduled task component.\n\nWe began researching how the registry structure of the scheduled tasks could be abused to\naccomplish various goals, such as lateral movement and persistence.\n\nSpecifically, we investigated what were the minimum conditions for a task to be created,\nwithout going through the classic interfaces such as Remote Procedure Calls (RPC).\n\n[Both Microsoft's article and SpectreOps' research on capability abstraction confirmed that all](https://posts.specterops.io/abstracting-scheduled-tasks-3b6451f6a1c5)\nthe scheduled tasks eventually will be stored in the registry under the following registry keys:\n```\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tasks\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\n\n```\nThe question was, would it be possible to create the relevant registry entries and create a\ntask, and possibly, without generating events?\n\nIn this post we will explore two approaches that can be used to achieve the same result:\ncreate or modify a scheduled task and execute it, without generating the relevant telemetry.\nFirst, we will explore how direct registry manipulation could be used to create or modify tasks\nand how this did not generate the usual entries in the eventlog. Finally, an alternative route\nbased on tampering with the Task Scheduler ETW will be presented that will completely\nsuppress most of logging related to the Task Scheduler.\n\n## Available Telemetry\n\nBefore attempting to evade or circumvent how the Task Scheduler log its events, a brief\nintroduction of what type of logging the Task Scheduler offers.\n\nWhen creating, modifying, running or deleting a task, the following telemetry will be\ngenerated:\n\n'Microsoft-Windows-TaskScheduler' - ETW provider that offers raw telemetry on task\nscheduler activity. Various security solutions that are based on ETW can tap directly\ninto this data source.\n\n\n-----\n\nMicrosoft-Windows-TaskScheduler/Operational events from the Eventlog - If task\nHistory is enabled, this events will reflect what will be captured by the ETW provider\nmentioned above.\nEvents 4698 to 4702 - In order to obtain these events, Object Auditing needs to be\nconfigured in the Local Security Policy's advanced auditing options. This source\ncontains similar information as above but will end in the \"Security\" event log. Later on\nwe will see what is the difference between this and 'Microsoft-WindowsTaskScheduler/Operational'. These events log the creation and modification of tasks,\nbut not when a task is executed or which action a specific task executes. Troughout the\npost, this will be simply referred as the \"Security\" event log.\n\nBy analysing common attacker's knowledge frameworks such as ATT&CK, we can see that\n[in the recommended auditing of the \"Scheduled Task\" technique we have both the 'Microsoft-](https://attack.mitre.org/techniques/T1053/005/)\nWindows-TaskScheduler/Operational' and the 4XXX events from the Object Auditing. Since\nthey contain similar information, it is normal to think that they can be used interchangeably.\nIn fact, open source detection rule repositories like Sigma search for events generated by\none source, but not both.\n\nThe following sections will document all the various techniques that were used to evade\nwhich types of events and how practical that would be in a real life scenario.\n\n## Registry Structure\n\nIf we analyse the structure of the aforementioned registry keys, it is possible to observe that\nthe entry under the 'Tree\\<taskName>' key the following values are present:\n\n'Default' - Left to empty\n'Id' - Is a GUID that indicates the subkey under the 'Tasks' key.\n'Index' - DWORD value, could not understand what this was used for\n'SD' - The security descriptor of the task, which was already discussed by Microsoft\n\nThe image below is an example of that:\n\n\n-----\n\nThe values of the Tasks subkey are mostly binary blobs and encoded strings that indicate\ninformation such as:\n\nThe task triggers\nThe task action\nThe hash of the XML file in the 'C:\\windows\\system32\\tasks' folder\n\nIn addition to the above, another undocumented registry key was identified that played a big\nrole in the task creation:\n```\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\nNT\\CurrentVersion\\Schedule\\TaskCache\\Plain\\{GUID}\n\n```\nWhere GUID is the unique identifier of the task as discussed above. No values were\nconfigured under the GUID subkey. We will see in the task creation section how this was\nfundamental.\n\nAs mentioned above, our research focused on how to create or tamper with a task without\ngoing through the RPC interfaces, but only using direct registry manipulation. The following\nsections will explore how both the objectives were achieved and their respective caveats\nwhilst understanding how tasks are saved in the registry.\n\n## Task Creation\n\nWithout going too deep on reverse-engineering the RPC server responsible for the task\ncreation, we exported the registry values of a previously created task, modified some values\nsuch as the task GUID, URI, and the Path, and imported the keys into the registry.\n\nNOTE: In order to import the keys it is necessary to elevate to SYSTEM\n\nAfter the import was done, it was possible to see that the task appeared in the Task\nScheduler GUI but no task creation events were generated, both in the EventLog or the\n**Task Scheduler ETW feed.**\n\n\n-----\n\nHowever, this technique had one big problem. When the created task was started, the\nfollowing error was obtained:\n\n\n-----\n\nThis made the technique pretty useless, we had a cool way of creating tasks but no way to\nrun them!\n\nAfter some trial and error, two solutions were identified for this problem:\n\nRestarting the 'Schedule' service would \"load\" the task in the memory of the relevant\nsvchost process, allowing the task to run\nModification of the task definition would also force the load of the task in memory\n\nThe first approach, despite being noisier and more disruptive, did not generate any\n**additional events and now it was possible to execute the newly created task. Note that**\n**it is mandatory to create the GUID subkey under the 'Plain' key as discussed in the**\n**section above, otherwise this will not work.**\n\nThe second approach did not require any killing of innocent processes and restart of services\nand mainly consisted of the update of the newly created task definition.\n\nNote that despite the example showing the usage of the 'schtasks' utility, the same result\ncould be achieved using the Task Scheduler RPC interface.\n\nNow, the interesting part is that the update of a task definition will generate an entry in the\nevent log.\n\n\n-----\n\nThe screenshots below show the log entries of the TaskScheduler auditing and the\nTaskScheduler ETW feed:\n\nInterestingly, despite the task definition change generated events, the 'Microsoft-WindowsTaskScheduler/Operational' events contained only the information about the change that was\napplied. In the case above, we changed just the user that was used to execute the task, and\ntherefore no additional information was present in the event information.\nThis was not the case with the Task Scheduler Security logs, as every modification in the\ntask definition generated an entry in the event log that contained the whole task definition\nXML, as shown here:\n\n\n-----\n\n## Task Modification\n\nWhilst exporting a task that was created on the attacker's host works, it was still necessary to\nunderstand the meaning of some of the structures in the registry. This would allow us to\nmodify existing tasks directly on the compromised host and possibly hiding our activities.\n\nSince attackers are likely going to be interested in modifying the action that a task performs,\nwe will analyse the 'Actions' value from the registry. An example is shown below:\n\nAs it is possible to see, two Unicode strings are present in the structure, the value \"Author\"\nand the command that will be executed.\n\nA deeper examination of the values within the binary blob led to the following:\n\n\n-----\n\n'03 00' - seem to be static bytes\nSizeof author string, seems to indicate who's the user that is supposed to run the task,\nother tasks were found to have 'LocalSystem' as an example, others 'Authenticated\nUsers'\n'66 66' - seems to be static for tasks that start another program, other COM bases\ntasks were found to have different values\nSizeof action string - a value that indicates how long the action string will be\nAction string - UNICODE representation of the string that indicates the action to\nperform\n\nAlthough it was not possible to fully understand the meaning of each field, some common\npatterns were identified.\n\nIt must be noted that attackers don't necessarily need to know the meaning of each bit of the\nkey mentioned above. In fact, it is possible to create a task with the desired malicious action\nlocally, export the key and then import it into the target system.\n\n\n-----\n\nWith this knowledge, attackers can edit the relevant fields of a Task s Action and execute\nmalicious actions. It must be noted that the task should be \"loaded\" in memory using any of\nthe approaches proposed above.\n\nIf the attackers restarted the scheduler service to load the modified task in memory, no\nevents were generated in the Security eventlog or in the 'Microsoft-WindowsTaskScheduler/Operational' logs.\n\n## Alternative Approach: ETW Tampering\n\nETW patching is a technique whereby an attacker abuses flaws in the ETW architecture with\nthe aim of preventing either a specific process or the whole system from generating ETW\n[telemetry. This was popularised by MDSec's research \"Hiding Your .NET - ETW\" and](https://www.mdsec.co.uk/2020/03/hiding-your-net-etw/)\n[Palantir's Tampering with Windows Event Tracing. As an example, MDSec's research was](https://blog.palantir.com/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63)\nfocused towards hiding .NET related events, however, considering how ubiquitous ETW is on\nWindows systems, many other abuse opportunities are present.\n\nDuring the research, it was in fact possible to verify that all the Task Scheduler logs were\ngenerated by the Eventlog service, but the event information was sent by the Scheduler\nservice using ETW. **This meant that if an attacker is able to tamper with the ETW on the\nScheduler service, no logs will be generated.**\n\n[Recent research on patchless AMSI bypasses by CCob showed that it was possible to](https://ethicalchaos.dev/2022/04/17/in-process-patchless-amsi-bypass/)\ncombine hardware breakpoints and Vectored Exception Handlers (VEH) in order to modify\nhow a function behaved. In case of the AMSI bypass, the breakpoint was set to the start of\nthe 'AmsiScanBuffer' function and the custom VEH handler simply returned a predefined\nvalue and restored the execution flow as if the 'AmsiScanBuffer' function terminated\nnormally. We won't go into the technical details on how the technique works as the blog post\nabove does an excellent job in explaining the required concepts.\n\n[Adapting this to ETW tampering was easy enough, starting from the initial PoC published by](https://gist.github.com/CCob/fe3b63d80890fafeca982f76c8a3efdf)\nthe blog's author. The only major modification was that the VEH and breakpoints in the\nprovided PoC were applied only to the current thread, and therefore to make it work for the\nwhole process it was necessary to iterate trough all the process' threads and configure the\nbreakpoints and VEH accordingly. In addition, a logic to scan for new threads on a periodic\nbasis was also added, because threads that were newly created by the Scheduler service\nwould not be subject to this bypass.\n\nThe modified PoC was compiled as a Windows DLL and injected into the svchost.exe\nprocess that was hosting the Scheduler service. The following video shows the results of the\nattack:\n\n\n-----\n\nAs it is possible to see, before the attack the various events were generated as expected\nafter tasks were executed or modified. However, after injecting the malicious DLL onto the\ntarget svchost process, no more events were sent to the eventlog.\n\nDespite the video shows the usage of process hacker to perform DLL injection, in a real life\nscenario it would be possible to convert the DLL to a Reflective DLL and inject it using\nstealthier process injection techniques.\n\nThis tampering approach presents multiple OpSec advantages over the classic ETW function\npatching, as no modification was done against the in-memory DLL. This would avoid all the\ndetections based on Write on Copy that are also implemented in open-source scanners like\n[Moneta. In addition, removing the VEH and breakpoints is relatively trivial once the attackers](https://github.com/forrest-orr/moneta)\nperformed their actions and should leave minimal traces on the attacked process. Similar\nresults can be achieved with different hooking techniques that do not rely on patching the\nmemory of the '.text' section of a DLL, such as Page Guard hooking or similar.\n\nFinally, using this technique would allow attackers to avoid more convoluted paths such as\nthe ones that were previously described that involved modifying binary values in the registry.\nUsing the classic scheduled task deployment that go via COM or RPC in conjunction with\nthis bypass would effectively have the same effect in terms of defense evasion.\n\nTo summarise, the table below shows the various task scheduler log sources and how they\nare affected by the proposed techniques:\n\n\nTechnique Security\nLogs\n\n\nMicrosoft-WindowsTaskScheduler/Operational\n\n\nMicrosoftWindowsTaskScheduler\nETW\n\n\nTask creation/modification\nvia RPC\n\nTask creation/modification\nvia registry manipulation\n\nTask creation/modification\nwith tampered ETW\n\n\nYes Yes Yes\n\nNo No No\n\nYes No No\n\n\nTask modification via RPC Yes Yes Yes\n\n\nTask modification via\nRegistry and Scheduler\nrestart\n\n\nNo No No\n\n\nTask Executed via RPC No Yes Yes\n\nNOTE: We are not planning to release any tool that automates this attack anytime soon.\n\n\n-----\n\n## Abuse Cases\n\nTo summarise, the following abuse case were identified:\n\nAn attacker creates a malicious scheduled task via the registry to establish persistence\nand wants to hide their activity\nAn attacker tampers with an existing and benign task to inject a malicious action\nAn attacker creates a malicious task via either RPC or registry and masks it as a\nbenign task\n\nThe third case presents an interesting scenario, since if an attacker can create a task - either\nwith the classic techniques or this variation - they can then \"spoof\" the 'Actions' value to\nmake the task appear legitimate. If the 'Actions' field is modified, its value will be reflected\nimmediately in the Task Scheduler GUI. However, if the task definition is not updated or the\nhost is rebooted, each time the task will be executed, the malicious action will be triggered\ninstead.\n\nTo better explain this, an example is provided below:\n\nAttacker creates a malicious task A on the victim host that will execute 'C:\\evil.exe'\nThe attacker then modifies the registry entry of the newly created task and changes the\naction to be 'C:\\legitimate.exe'\nThe attacker can run the task, and 'C:\\evil.exe' will be executed\nDefenders trying to spot malicious activity on the host will see that the created task\nshould have executed 'C:\\legitimate.exe' but no logs of task modification are present.\n\nNote that in this proposed hypothetical scenario, the attacker might not necessarily want to\nhide the initial task creation activity. This is mainly to impede manual investigation on the\nhost, as the Action in the Task Scheduler GUI would differ from the actual task that is being\nexecuted.\n\n## Extra: Lateral Movement\n\n[Due to permission restrictions, as mentioned by other researchers in publicly available tools,](https://github.com/netero1010/ScheduleRunner)\nnormally manually modifying registry keys associated to scheduled tasks is not possible.\nThis is because the relevant registry keys have ACLs such that only the SYSTEM user can\nmodify them.\n\nTo validate that, let's try to add one of the keys required for the task creation using\nImpacket's reg.py script, with an account that has admin rights over the remote host:\n\n\n-----\n\n```\nreg.py isengard.local/administrator@WIN FCMCCB17G6U.ISENGARD.LOCAL add keyName\n'HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tasks\\\n{61687CDA-FEBB-4F23-8E3B-5F2D8778CA7B}'\nImpacket v0.9.25.dev1+20220218.140931.6042675a - Copyright 2021 SecureAuth\nCorporation\n[*] Service RemoteRegistry is in stopped state\n[*] Starting service RemoteRegistry\n[-] DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied\n\n```\nWell, now the question is, can we use the SYSTEM account remotely and use what we\ndiscovered to perform this attack remotely? The short answer is yes, but let's explore what\nare the caveats.\n\n[In our experiments, we found that it was possible to use the Silver Ticket technique to craft a](https://attack.mitre.org/techniques/T1558/002/)\nticket that had the SYSTEM SID (S-1-5-18) in the PAC. It goes without saying that in order to\nperform a Silver Ticket attack, you must possess the NTLM or AES key associated with a\ncomputer account. This can be obtained in multiple ways, such as using the \"Shadow\nCredentials\" attack or by extracting it from the remote host using remote registry with tool\nsuch as Impacket's secretsdump.py.\n\nNow, let's assume that we obtained the NTLM hash of a computer account, what's next?\n\nUsing Impacket's ticketer we can forge the silver ticket with the \"-extra-sid\" parameter:\n```\nticketer.py -nthash [NTLM] -domain-sid S-1-5-21-861978250-176888651-3117036350 domain isengard.local -dc-ip 192.168.182.132 -extra-sid S-1-5-18 -spn HOST/WINFCMCCB17G6U.isengard.local WIN-FCMCCB17G6U$\nImpacket v0.9.25.dev1+20220218.140931.6042675a - Copyright 2021 SecureAuth\nCorporation\n[*] Creating basic skeleton ticket and PAC Infos\n[*] Customizing ticket for isengard.local/WIN-FCMCCB17G6U$\n[*]   PAC_LOGON_INFO\n[*]   PAC_CLIENT_INFO_TYPE\n[*]   EncTicketPart\n[*]   EncTGSRepPart\n[*] Signing/Encrypting final ticket\n[*]   PAC_SERVER_CHECKSUM\n[*]   PAC_PRIVSVR_CHECKSUM\n[*]   EncTicketPart\n[*]   EncTGSRepPart\n[*] Saving ticket in WIN-FCMCCB17G6U$.ccache\n\n```\nNow that the ticket is saved, we can just use it with other impacket tools and apply the\nchanges to the registry:\n\n\n-----\n\n```\nexport KRB5CCNAME /tmp/WIN FCMCCB17G6U\\$.ccache\nreg.py -k -no-pass 'ISENGARD.LOCAL/WIN-FCMCCB17G6U$'@WIN-FCMCCB17G6U.ISENGARD.LOCAL\nadd -keyName 'HKLM\\SOFTWARE\\Microsoft\\Windows\nNT\\CurrentVersion\\Schedule\\TaskCache\\Tasks\\{61687CDA-FEBB-4F23-8E3B-5F2D8778CA7B}'\nImpacket v0.9.25.dev1+20220218.140931.6042675a - Copyright 2021 SecureAuth\nCorporation\nSuccessfully set subkey HKLM\\SOFTWARE\\Microsoft\\Windows\nNT\\CurrentVersion\\Schedule\\TaskCache\\Tasks\\{61687CDA-FEBB-4F23-8E3B-5F2D8778CA7B}\n\n```\nDespite the command above shows only the creation of one of the various keys required for\na task to be created, it would be simple enough to automate the whole process.\n\n## Detection and Hunting\n\nFrom a defensive standpoint, the first thing we should mention is that the task creation and\nmodification did not generate events, the action of starting a task will.\n\nSpecifically, every time a task starts an action such as running an EXE you will have an\nevent that looks like the following:\n\nNote that this event is not present in the Task Scheduler's Security events, that will log only\ncreation, deletion and modification of a task. Therefore, if ETW is tampered on the Scheduler\nservice, the action started by a task will not be captured.\n\nAn alternative and more robust approach would include the parent-child process relationship,\nas all the processes started by the Task Scheduler will have a specific svchost as a parent.\n\nFrom a hunting and detection perspective, looking for registry operations that affect the keys\nmentioned in this article that are not originated from a svchost process is probably a good\nway to spot attackers that perform this attack without too much sophistication. The first\n\n\n-----\n\nimage below shows a benign event generated from svchost:\n\nThis image shows a similar registry operation, but performed by the 'reg.exe' process rather\nthan svchost:\n\nIt goes without saying that attackers can easily spawn an svchost process or inject into an\nexisting one to perform this attack, but that might (should?) trigger other controls.\n\nOn the ETW tampering side, the recommendations are not specific to the Scheduler abuse\nbut should be mainly focused towards:\n\nDetecting memory injection against system processes - In order to deploy the ETW\npatches, attackers are likely to inject code into a target process. Detecting process\ninjection is a topic that goes way beyond the scope of this research and therefore we\nwon't spend too much time on that.\n[Detecting abuse of VEH - NCC published an interesting post on how this could be](https://research.nccgroup.com/2022/01/03/detecting-anomalous-vectored-exception-handlers-on-windows/)\napproached. However, the proposed detections were mainly focused on detecting\nhandlers that pointed to memory regions that are not backed by a file on disk.\nAdvanced attackers could easily avoid those indicators by either hiding their code on\nmemory pages that are associated with files that exist on disk or simply removing the\nVEH after they performed their actions.\nDetecting changes in ETW log volume - rapid changes to the volume of logs generated\nby a specific feed should be treated as suspicious, although attackers can still revert\nback the changes after the malicious actions are complete. Note that implementing this\nin a big enough estate could be extremely difficult to accomplish.\n\nThe following Sigma rule can be used to hunt for attackers that attempted to manually modify\nscheduled tasks from the registry:\n\n\n-----\n\n```\ntitle: Task Tampering Detection\nstatus: experimental\ndescription: Detects manual Scheduled Task tampering via registry modification\nauthor: Riccardo Ancarani\ndate: 03/05/2022\nlevel: high\nlogsource:\n  product: windows\n  service: sysmon\ndetection:\n  selection:\n    EventID: 13\n    TargetObject: 'HKLM\\SOFTWARE\\Microsoft\\Windows\nNT\\CurrentVersion\\Schedule\\TaskCache\\*'\n  filter:\n    - Image|endswith: '\\svchost.exe'\n  condition: selection and not filter\n\n```\nThe Sigma rule above leverages Sysmon's logging capabilities and looks for the event ID 13\n(Registry write) on the specific keys used for this attack. It also filters all the activity\ngenerated from \"svchost.exe\".\n\n[The rule was tested against Sigma's baseline EVTX files and did not produce any false](https://github.com/NextronSystems/evtx-baseline)\npositive.\n\n[An example of a true positive successfully identified using the Chainsaw tool:](https://github.com/countercept/chainsaw)\n\n## Conclusions\n\nIn this post we examined various techniques that attackers can use to create or tamper with\nscheduled tasks using mostly registry operations. From a defense evasion perspective, this\nwould limit the logs that defenders can use to spot malicious activity.\n\nHigh-level detections strategies were provided to help blue team members to hunt for such\nabuses.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-05-04 - Scheduled Task Tampering.pdf"
    ],
    "report_names": [
        "2022-05-04 - Scheduled Task Tampering.pdf"
    ],
    "threat_actors": [
        {
            "id": "529c1ae9-4579-4245-86a6-20f4563a695d",
            "created_at": "2022-10-25T16:07:23.702006Z",
            "updated_at": "2025-03-27T02:02:09.93109Z",
            "deleted_at": null,
            "main_name": "Hafnium",
            "aliases": [
                "Red Dev 13",
                "Silk Typhoon"
            ],
            "source_name": "ETDA:Hafnium",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "7c969685-459b-4c93-a788-74108eab6f47",
            "created_at": "2023-01-06T13:46:39.189751Z",
            "updated_at": "2025-03-27T02:00:03.017103Z",
            "deleted_at": null,
            "main_name": "HAFNIUM",
            "aliases": [
                "ATK233",
                "G0125",
                "Operation Exchange Marauder",
                "Red Dev 13",
                "Silk Typhoon"
            ],
            "source_name": "MISPGALAXY:HAFNIUM",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "2704d770-43b4-4bc4-8a5a-05df87416848",
            "created_at": "2022-10-25T15:50:23.306305Z",
            "updated_at": "2025-03-27T02:00:55.43633Z",
            "deleted_at": null,
            "main_name": "HAFNIUM",
            "aliases": [
                "HAFNIUM",
                "Operation Exchange Marauder",
                "Silk Typhoon"
            ],
            "source_name": "MITRE:HAFNIUM",
            "tools": [
                "Tarrask",
                "ASPXSpy",
                "Impacket",
                "PsExec",
                "China Chopper"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536078,
    "ts_updated_at": 1743041523,
    "ts_creation_date": 1653678362,
    "ts_modification_date": 1653678362,
    "files": {
        "pdf": "https://archive.orkl.eu/3401cf48c37cec6d4f036a8032400f5f5d09746d.pdf",
        "text": "https://archive.orkl.eu/3401cf48c37cec6d4f036a8032400f5f5d09746d.txt",
        "img": "https://archive.orkl.eu/3401cf48c37cec6d4f036a8032400f5f5d09746d.jpg"
    }
}