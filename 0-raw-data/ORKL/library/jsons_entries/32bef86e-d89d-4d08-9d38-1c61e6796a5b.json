{
    "id": "32bef86e-d89d-4d08-9d38-1c61e6796a5b",
    "created_at": "2023-01-12T15:08:14.825142Z",
    "updated_at": "2025-03-27T02:16:39.938189Z",
    "deleted_at": null,
    "sha1_hash": "78ce9de17353d5fad8c49a37bbf18505029135cf",
    "title": "2021-12-17 - Diavol Ransomware",
    "authors": "",
    "file_creation_date": "2022-05-27T23:24:33Z",
    "file_modification_date": "2022-05-27T23:24:33Z",
    "file_size": 2051485,
    "plain_text": "# Diavol Ransomware\n\n**[chuongdong.com/reverse engineering/2021/12/17/DiavolRansomware/](https://chuongdong.com/reverse%20engineering/2021/12/17/DiavolRansomware/)**\n\nChuong Dong December 17, 2021\n\n[Reverse Engineering · 17 Dec 2021](http://10.10.0.46/categories/#reverse%20engineering)\n\n## Contents\n\n Overview\n\nThis is my analysis for the DIAVOL Ransomware.\n\n**DIAVOL is a relatively new ransomware that uses a unique method with shellcode to launch**\nits core functions and RSA to encrypt files.\n\nThe malware contains a hard-coded configuration that stores informations such as files to\nencrypt and RSA public key, but it can also requests these informations from the threat\nactor’s remote server.\n\nUnlike most major ransomware, this new malware’s encryption scheme is relatively slow due\nto its recursive method for file traversal.\n\n_Figure 1: DIAVOL Post-Infection._\n\n## IOCS\n\n\n-----\n\n[Huge shout-out to Curated Intelligence for providing this sample.](https://twitter.com/CuratedIntel)\n\nThe analyzed sample is a 64-bit Windows executable.\n\n**MD5: f4928b5365a0bd6db2e9d654a77308d7**\n\n**SHA256: ee13d59ae3601c948bd10560188447e6faaeef5336dcd605b52ee558ff2a8588**\n\n**Sample:** [MalwareBazaar](https://bazaar.abuse.ch/sample/ee13d59ae3601c948bd10560188447e6faaeef5336dcd605b52ee558ff2a8588/)\n\n_Figure 2: VirusTotal Result._\n\n## Ransom Note\n\nThe content of the default ransom note is stored in plaintext in DIAVOL’s configuration. The\nmalware can also request a ransom note from its remote server and override the default with\nthat.\n\n**DIAVOL’s ransom note filename is README-FOR-DECRYPT.txt.**\n\n\n-----\n\n_Figure 3: DIAVOL’s Ransom Note._\n\n## Static Code Analysis\n\n Anti-Analysis: Launching Functions with Shellcode\n\nFor anti-analysis, DIAVOL loads shellcode containing its core functions into memory and\nexecutes it dynamically, which makes static analysis a bit harder.\n\nFirst, the malware calls VirtualAlloc to allocate two memory buffers to later load these\nshellcodes in.\n\n_Figure 4: Allocating Shellcode Buffers._\n\nWhen DIAVOL wants to execute a certain functionality, it calls a function to load the\nshellcode into memory and executes a call instruction to transfer control to the shellcode.\n\n\n-----\n\n_Figure 5: Loading & Executing Shellcode._\n\nFirst, to load shellcode into memory, DIAVOL extracts the bitmap image corresponds to the\ngiven resource name by calling LoadBitmapW, CreateCompatibleDC, SelectObject, and\n**GetObjectW.**\n\nNext, it calls GetDIBits to retrieve the bits of the bitmap image and copies them into the\nshellcode buffer as a DIB.\n\n_Figure 6: Loading Shellcode into memory._\n\nUnlike normal shellcode, DIAVOL’s don’t manually walk the PEB to resolve its imports\ndynamically. The malware loads a “JPEG” with the same name in the resource section,\nextracts a list of imported functions with their corresponding DLL, and manually calls\n**LoadLibraryA and GetProcAddress to resolve it for the shellcode. The resolved API**\naddresses are stored at the end of the buffer, so the shellcode can make calls to those APIs\nusing their exact offsets, which makes the loaded payload position-independent.\n\n\n-----\n\n_Figure 7: Resolving API Addresses For Shellcode._\n\nBelow is the bitmap and the imported API list extracted from Resource Hacker.\n\n_Figure 8: DIAVOL Resource Section._\n\nBecause each shellcode should be position-independent, we can simply load it into IDA for\nstatic analysis after extraction. However, the API addresses won’t make sense when IDA\nloads the shellcode because they are relative to where the DLLs are in the malware’s\nmemory.\n\n\n-----\n\n_Figure 9: Loading Shellcode Into IDA._\n\nTo fix this, we just need to rename the API addresses in the order that they appear in the\ncorresponding JPEG resource. After renaming, the shellcode should be decompiled\ncorrectly, and we can begin our static analysis on it.\n\n_Figure 10: Fixing Shellcode’s API Calls In IDA._\n\n## Command-line Arguments\n\n\n-----\n\n**DIAVOL can run with or without command-line arguments.**\n\nBelow is the list of arguments that can be supplied by the operator.\n\n**Argument** **Description**\n\n**-p <target>** Path to a file containing files/directories to be encrypt specifically\n\n**-h <target>** Path to a file containing remote files/directories to enumerate with\nSMB\n\n**-m local** Encrypting local files and directories\n\n**-m net** Encrypting network shares\n\n**-m scan** Scanning and encrypting network shares through SMB\n\n**-m all** Encrypting local and network drives without scanning through SMB\n\n\n**-log**\n**<log_filename>**\n\n\nEnable logging to the specified log file\n\n\n**-s <IP_address>** Remote server’s IP address to register bot\n\n**-perc <percent>** Percent of data to be encrypted in a file (default: 10%)\n\n## Bot ID Generation\n\nThe first functionality DIAVOL executes is generating the bot ID through loading and\nexecuting the shellcode from the resource GENBOTID.\n\nPrior to launching the shellcode, DIAVOL calls time64 to retrieve the current timestamp on\nthe system and uses it as the seed for srand to initialize the pseudo-random number\ngenerator.\n\nNext, it generates the following structure and passes it to the shellcode. The bot_ID field is\nlater used to register the victim to the threat actor’s remote server, and the victim_ID is the\nvictim ID that is written to the ransom note. The RSA_CRYPT_BUFF is a buffer that is later\nused to encrypt files.\n```\nstruct DIAVOL_GENBOTID_STRUCT\n{\n char* bot_ID;\n wchar_t* victim_ID;\n BYTE* RSA_CRYPT_BUFF;\n int (__stdcall *rand)();\n};\n\n```\n\n-----\n\n_Figure 11: Initialize Structure For GENBOTID._\n\nTo generate the victim ID, the shellcode creates a unique GUID using CoCreateGuid and\nuses it as a random number to index into the string “0123456789ABCDEF” to generate a\nrandom 32-character string.\n\n_Figure 12, 13: Generating Random 32-character Victim ID._\n\n\n-----\n\nTo generate the bot ID, the malware first calls GetComputerNameA and GetUserNameA to\nretrieve the computer name and user name. It also calls RtlGetVersion to retrieve the\nversion of the victim’s computer and uses it to index into the string “0123456789ABCDEF”\nto generate an 8-character string.\n\nThen, the bot ID is built in the following string format.\n\n** + + \"_W\" + <8_character_string_from_OS_version> + \".\"**\n\n_Figure 14, 15: Generating Bot ID._\n\nFinally, to populate the RSA_CRYPT_BUFF field, the malware calls the rand function to\ngenerate a random 1024-byte buffer.\n\n\n-----\n\n_Figure 16: Generating RSA CRYPT Buffer._\n\n## Hard-coded Configuration\n\nThe configuration of DIAVOL is stored in plaintext in memory. To extract it, the malware\nallocates the following structure using LocalAlloc and populates it using the hard-coded\nvalues from memory.\n```\nstruct DIAVOL_CONFIG\n{\n _QWORD server_IP_addr; // remote server to register bot\n wchar_t* group_ID; // bot group ID\n wchar_t* Base64_RSA_key; // Base64-encoded RSA key\n wchar_t* process_kill_list; // processes to kill\n wchar_t* service_stop_list; // services to stop\n wchar_t* file_ignore_list; // filenames to avoid encrypting\n wchar_t* file_include_list; // filenames to include encrypting\n wchar_t* file_wipe_list; // filenames to delete\n wchar_t* target_file_list; // target files to encrypt first (overriden by \"-p\"\ncommand-line)\n wchar_t* ransom_note; // ransom note in reverse\n _QWORD findfiles_complete_flag; // is set to true when the first FINDFILES\niteration is done\n};\n\n```\n\n-----\n\n_Figure 17, 18: Populate Configuration._\n\nBelow are the hard-coded values for the configuration.\n\n\n-----\n\n```\n{\n server_IP_addr: \"127.0.0.1\",\n group_ID = \"c1aaee\",\n Base64_RSA_Key = \"BgIAAACkAABSU0ExAAQAAAEAAQCxVuiQzWxjl9dwh2F77Jxqt/PIrJoczV2RKluW\nM+xv0gSAZrL8DncWw9hif+zsvJq6PcqC0NugL3raLFbaUCUT8KAGgrOkIPmnrQpz\n5Ts2pQ0mZ80UlkRpw10CMHgdqChBqsnNkB9XF/CFYo4rndjQG+ZO22WX+EtQr6V8\nMYOE1A==\",\n process_kill_list = [\"iexplore.exe\", \"msedge.exe\", \"chrome.exe\", \"opera.exe\",\n\"firefox.exe\", \"savfmsesp.exe\", \"zoolz.exe\", \"firefoxconfig.exe\", \"tbirdconfig.exe\",\n\"thunderbird.exe\", \"agntsvc.exe\", \"dbeng50.exe\", \"dbsnmp.exe\", \"isqlplussvc.exe\",\n\"msaccess.exe\", \"msftesql.exe\", \"mydesktopqos.exe\", \"mydesktopservice.exe\", \"mysqldnt.exe\", \"mysqld-opt.exe\", \"mysqld.exe\", \"ocautoupds.exe\", \"ocssd.exe\", \"oracle.exe\",\n\"sqlagent.exe\", \"synctime.exe\", \"thebat.exe\", \"thebat64.exe\", \"encsvc.exe\",\n\"ocomm.exe\", \"xfssvccon.exe\", \"excel.exe\", \"infopath.exe\", \"mspub.exe\",\n\"onenote.exe\", \"outlook.exe\", \"powerpnt.exe\", \"visio.exe\", \"wordpad.exe\",\n\"CNTAoSMgr.exe\", \"mbamtray.exe\", \"NtrtscPccNTMon.exe\", \"tmlisten.exe\",\n\"sqlmangr.exe\", \"RAgui.exe\", \"QBCFMonitorService.exe\", \"supervise.exe\", \"fdhost.exe\",\n\"Culture.exe\", \"RTVscan.exe\", \"Defwatch.exe\", \"wxServerView.exe\", \"GDscan.exe\",\n\"QBW32.exe\", \"QBDBMgr.exe\", \"qbupdate.exe\", \"axlbridge.exe\", \"360se.exe\",\n\"360doctor.exe\", \"QBIDPService.exe\", \"wxServer.exe\", \"httpd.exe\", \"fdlauncher.exe\",\n\"MsDtSrvr.exe\", \"tomcat6.exe\", \"java.exe\", \"wdswfsafe.exe\"],\n service_stop_list = [\"DefWatch\", \"ccEvtMgr\", \"ccSetMgr\", \"SavRoam\", \"dbsrv12\",\n\"sqlservr\", \"sqlagent\", \"Intuit.QuickBooks.FCS\", \"dbeng8\", \"QBIDPService\",\n\"Culserver\", \"RTVscan\", \"vmware-usbarbitator64\", \"vmware-converter\",\n\"VMAuthdService\", \"VMnetDHCP\", \"VMUSBArbService\", \"VMwareHostd\", \"SQLADHLP\",\n\"msmdsrv\", \"tomcat6\", \"QBCFMonitorService\", \"Acronis VSS Provider\", \"SQL Backups\",\n\"SQLsafe Backup Service\", \"SQLsafe Filter Service\", \"Symantec System Recovery\",\n\"Veeam Backup Catalog Data Service\", \"Zoolz 2 Service\", \"AcrSch2Svc\", \"ARSM\",\n\"BackupExecAgentAccelerator\", \"BackupExecAgentBrowser\",\n\"BackupExecDeviceMediaService\", \"BackupExecJobEngine\", \"BackupExecManagementService\",\n\"BackupExecRPCService\", \"BackupExecVSSProvider\", \"bedbg\", \"MMS\", \"mozyprobackup\",\n\"ntrtscan\", \"PDVFSService\", \"SDRSVC\", \"SNAC\", \"SQLWriter\", \"VeeamBackupSvc\",\n\"VeeamBrokerSvc\", \"VeeamCatalogSvc\", \"VeeamCloudSvc\", \"VeeamDeploymentService\",\n\"VeeamDeploySvc\", \"VeeamEnterpriseManagerSvc\", \"VeeamHvIntegrationSvc\",\n\"VeeamMountSvc\", \"VeeamNFSSvc\", \"VeeamRESTSvc\", \"VeeamTransportSvc\",\n\"sms_site_sql_backup\", \"MsDtsServer\", \"MsDtsServer100\", \"MsDtsServer110\",\n\"msftesql$PROD\", \"MSOLAP$SQL_2008\", \"MSOLAP$SYSTEM_BGC\", \"MSOLAP$TPS\",\n\"MSOLAP$TPSAMA\", \"MSSQL$BKUPEXEC\", \"MSSQL$ECWDB2\", \"MSSQL$PRACTICEMGT\",\n\"MSSQL$PRACTTICEBGC\", \"MSSQL$PROD\", \"MSSQL$PROFXENGAGEMENT\", \"MSSQL$SBSMONITORING\",\n\"MSSQL$SHAREPOINT\", \"MSSQL$SQL_2008\", \"MSSQL$SQLEXPRESS\", \"MSSQL$SYSTEM_BGC\",\n\"MSSQL$TPS\", \"MSSQL$TPSAMA\", \"MSSQL$VEEAMSQL2008R2\", \"MSSQL$VEEAMSQL2012\",\n\"MSSQLFDLauncher\", \"MSSQLFDLauncher$PROFXENGAGEMENT\",\n\"MSSQLFDLauncher$SBSMONITORING\", \"MSSQLFDLauncher$SHAREPOINT\",\n\"MSSQLFDLauncher$SQL_2008\", \"MSSQLFDLauncher$SYSTEM_BGC\", \"MSSQLFDLauncher$TPS\",\n\"MSSQLFDLauncher$TPSAMA\", \"MSSQLSERVER\", \"MSSQLServerADHelper\",\n\"MSSQLServerADHelper100\", \"MSSQLServerOLAPService\", \"MySQL57\", \"MySQL80\",\n\"OracleClientCache80\", \"ReportServer$SQL_2008\", \"RESvc\", \"SQLAgent$BKUPEXEC\",\n\"SQLAgent$CITRIX_METAFRAME\", \"SQLAgent$CXDB\", \"SQLAgent$ECWDB2\",\n\"SQLAgent$PRACTTICEBGC\", \"SQLAgent$PRACTTICEMGT\", \"SQLAgent$PROD\",\n\"SQLAgent$PROFXENGAGEMENT\", \"SQLAgent$SBSMONITORING\", \"SQLAgent$SHAREPOINT\",\n\"SQLAgent$SQL_2008\", \"SQLAgent$SQLEXPRESS\", \"SQLAgent$SYSTEM_BGC\", \"SQLAgent$TPS\",\n\"SQLAgent$TPSAMA\", \"SQLAgent$VEEAMSQL2008R2\", \"SQLAgent$VEEAMSQL2012\", \"SQLBrowser\",\n\"SQLSafeOLRService\", \"SQLSERVERAGENT\", \"SQLTELEMETRY\", \"SQLTELEMETRY$ECWDB2\",\n\"mssql$vim_sqlexp\", \"IISAdmin\", \"NetMsmqActivator\", \"POP3Svc\", \"SstpSvc\",\n\"UI0Detect\", \"W3Svc\", \"aphidmonitorservice\", \"intel(r) proset monitoring service\",\n\n```\n\n-----\n\n```\n unistoresvc_1af40a, audioendpointbuilder, MSExchangeES, MSExchangeIS,\n\"MSExchangeMGMT\", \"MSExchangeMTA\", \"MSExchangeSA\", \"MSExchangeSRS\",\n\"msexchangeadtopology\", \"msexchangeimap4\", \"Sophos Agent\", \"Sophos AutoUpdate\nService\", \"Sophos Clean Service\", \"Sophos Device Control Service\", \"Sophos File\nScanner Service\", \"Sophos Health Service\", \"Sophos MCS Agent\", \"Sophos MCS Client\",\n\"Sophos Message Router\", \"Sophos Safestore Service\", \"Sophos System Protection\nService\", \"Sophos Web Control Service\", \"AcronisAgent\", \"Antivirus\", \"AVP\",\n\"DCAgent\", \"EhttpSrv\", \"ekrn\", \"EPSecurityService\", \"EPUpdateService\", \"EsgShKernel\",\n\"ESHASRV\", \"FA_Scheduler\", \"IMAP4Svc\", \"KAVFS\", \"KAVFSGT\", \"kavfsslp\", \"klnagent\",\n\"macmnsvc\", \"masvc\", \"MBAMService\", \"MBEndpointAgent\", \"McAfeeEngineService\",\n\"McAfeeFramework\", \"McAfeeFrameworkMcAfeeFramework\", \"McShield\", \"McTaskManager\",\n\"mfefire\", \"mfemms\", \"mfevtp\", \"MSSQL$SOPHOS\", \"sacsvr\", \"SAVAdminService\",\n\"SAVService\", \"SepMasterService\", \"ShMonitor\", \"Smcinst\", \"SmcService\",\n\"SntpService\", \"sophossps\", \"SQLAgent$SOPHsvcGenericHost\", \"swi_filter\",\n\"swi_service\", \"swi_update\", \"swi_update_64\", \"TmCCSF\", \"tmlisten\", \"TrueKey\",\n\"TrueKeyScheduler\", \"TrueKeyServiceHelWRSVC\", \"vapiendpoint\"],\n file_ignore_list = [\"*.exe\", \"*.sys\", \"*.dll\", \"*.lock64\",\n\"*readme_for_decrypt.txt\", \"*locker.txt\", \"*unlocker.txt\", \"%WINDIR%\\\\\",\n\"%PROGRAMFILES%\\\\\", \"%PROGRAMW6432%\\\\\", \"*\\\\Microsoft\\\\\", \"*\\\\Windows\\\\\", \"*\\\\Program\nFiles*\\\\\", \"%TEMP%\\\\\"],\n file_include_list = [\"*\"],\n file_wipe_list = [],\n target_file_list = [],\n ransom_note = \"\\n\\r!NPV revo roT esu ot yrT .krowten etaroproc ro yrtnuoc ruoy ni\nkcolb eb yam resworB roT\\n\\r\\n\\r%tob_dic%/<redacted>/<redacted>//:sptth - etisbew ruo\ntisiv dna resworB roT eht nepO .2\\n\\r.ti llatsni dna resworB roT daolnwoD .1\\n\\r\\n\\r#\n?kcab selif ym teg ot woH #\\n\\r\\n\\r.etisbew swen ruo no dehsilbup eb lliw tnemyap\ngnikam ton fo esac ni taht krowten ruoy morf atad dedaolnwod osla evah ew taht\nnoitaredisnoc otni ekaT\\n\\r.krowten eht erotser rof loot noitpyrced y\"\n}\n\n## Bot Registration\n\n```\nTo register the victim as a bot, DIAVOL first builds the content of the POST request to later\nbe sent to the register remote server.\n\nThis is done through combining the bot ID generated in Bot ID Generation and the hardcoded group ID in the configuration in the following format.\n```\ncid=<bot_ID>&group=\n<group_ID>&ip_local1=111.111.111.111&ip_local2=222.222.222.222&ip_external=2.16.7.12\n\n```\n\n-----\n\n_Figure 19: Building Register Request._\n\nNext, the malware allocates memory for the following structure before loading and executing\nthe shellcode from resource REGISTER.\n```\nstruct DIAVOL_REGISTER_STRUCT\n{\n char* agent; // \"Agent\"\n char* C2_IP_addr; // C2 IP address from configuration or command-line \"-s\"\n char* request_type; // \"POST\"\n char* domain_dir; // \"/BnpOnspQwtjCA/register\"\n char* content_type; // \"Content-Type: application/x-www-form-urlencoded;\ncharset=UTF-8\"\n __int64 content_type_len; // length of content type\n char* payload_content; // register request\n __int64 payload_content_len; // length of register request\n};\n\n```\n\n-----\n\n_Figure 20: Building Register Structure & Register Bot._\n\nTo send the POST request, the shellcode InternetOpenA to initializes the application’s use\nof the WinINet functions, InternetConnectA to connect to the C2 server,\n**HttpOpenRequestA to open a POST request at the specified domain directory, and**\n**HttpSendRequestA to send the crafted POST request.**\n\nFinally, the malware calls HttpQueryInfoA to query and return the server’s response.\n\n_Figure 21: Sending POST Request To Register Bot._\n\n## Configuration Overriding\n\nBeside using the command line parameters, DIAVOL can also request different values from\nits remote server to override the configuration fields unlike most major ransomware.\n\n\n-----\n\nFirst, the malware checks to make sure the victim has been properly registered as a bot to\nthe main register server by checking if the server’s response code is 200.\n\n_Figure 22: Checking Register Response Code._\n\nNext, it loads and executes the shellcode from the resource FROMNET to request different\nconfiguration values.\n\nFor the calls to the shellcode, the malware allocates the following structure before passing it\nin as a parameter.\n```\nstruct DIAVOL_FROMNET_STRUCT\n{\n char* agent; // \"Agent\"\n char* C2_IP_addr; // \"173.232.146.118\" (Hard-coded)\n char* request_type; // \"GET\"\n char* domain_dir; // \"/Bnyar8RsK04ug/<bot_ID>/<group_ID>/<field_name>\n char* content_type; // \"Content-Type: application/x-www-form-urlencoded;\ncharset=UTF-8\"\n __int64 content_type_len; // the length of the content type\n};\n\n```\nFor the domain directory of the server’s address, the field name depends on the\nconfiguration field the malware is requesting. Once registration is done, DIAVOL requests for\nthe following field names:\n\n**key: Base64-encoded RSA key**\n**services: service stop list**\n**priority: target files to encrypt first**\n**ignore: filenames to avoid encrypting**\n**ext: filenames to include encrypting**\n**wipe: filenames to delete**\n**landing: Ransom note**\n\n\n-----\n\n_Figure 23: Populating FROMNET Structure._\n\nThe shellcode calls InternetConnectA to connect to the C2 server, HttpOpenRequestA to\nopen a GET request, and HttpSendRequestA to send the request. Next, it then calls\n**InternetReadFile to read the server’s response for the requested field and return that.**\n\n_Figure 24: Sending GET Request For Config Field._\n\nNext, because the lists in the configuration contains environment variables, DIAVOL resolves\nthem by calling GetEnvironmentVariableW and converts them to lowercase using\n**CharLowerBuffW.**\n\n\n-----\n\n_Figure 25: Parsing Configuration Lists._\n\nFinally, the ransom note in the configuration is reversed and the string “%cid_bot%” is\nreplaced with the generated victim ID.\n\n_Figure 26: Building Final Ransom Note._\n\n## Stopping Services\n\n**DIAVOL loads and executes the shellcode from the resource SERVPROC to stop the**\nservices specified in the configuration.\n\n\n-----\n\n_Figure 27: Loading & Executing SERVPROC._\n\nGiven a list of services to stop, the shellcode iterates through the list and stops them through\nthe service control manager.\n\nIt first calls OpenSCManagerW to retrieve a service control manager handle with all access,\n**OpenServiceW to retrieve a handle to the target service, and ControlService to send a**\ncontrol stop code to stop it.\n\n_Figure 28: Stopping Target Services._\n\n## Terminating Processes\n\n**DIAVOL loads and executes the shellcode from the resource KILLPR to terminate the**\nprocesses specified in the configuration.\n\n\n-----\n\n_Figure 29: Loading & Executing KILLPR._\n\nThe shellcode first calls CreateToolhelp32Snapshot to take a snapshot of all processes in\nthe system. Using the snapshot, it iterates through each process using Process32FirstW\nand Process32NextW. For each process, its executable name is compared against every\nname in the configuration’s process list to be terminated.\n\n\n-----\n\n_Figure 30, 31: Terminating Target Processes._\n\n## RSA Initialization\n\nPrior to file encryption, DIAVOL sets up the cryptography buffers that are later used to\nencrypt files.\n\nFirst, it allocates memory for the following structure before loading and executing the\nshellcode from resource RSAINIT.\n```\nstruct DIAVOL_RSAINIT_STRUCT\n{\n HCRYPTPROV hCryptProv; // Handle to cryptographic service provider\n BYTE* Base64_RSA_key; // Base64-encoded RSA key\n char* container_str; // \"MicrosoftCryptoGuard\"\n char* provider_str; // \"Microsoft Enhanced Cryptographic Provider v1.0\"\n BYTE* RSA_CRYPT_BUFF;\n BYTE* RSA_FOOTER;\n};\n\n```\n_Figure 32: Loading & Executing RSAINIT._\n\nThe shellcode’s job is to populate RSA_FOOTER field to later be used during file encryption.\n\nFirst, it calls CryptStringToBinaryW to Base64-decode the RSA public key and\n**CryptAcquireContextW to retrieve a handle to the corresponding cryptographic service**\nprovider.\n\n\n-----\n\n_Figure 33: Decode RSA Key & Retrieve CSP Handle._\n\nNext, the malware calls CryptImportKey to import the RSA public key and retrieve the key\nhandle. It calls VirtualAlloc to allocate a memory buffer and divides the RSA_CRYPT_BUFF\nbuffer into 117-byte blocks. For each block, DIAVOL appends it into the allocated buffer and\ncalls CryptEncrypt to encrypt it using the RSA key handle.\n\n\n-----\n\n_Figure 34: Importing RSA Public Key & Encrypting RSA_CRYPT_BUFF._\n\nFinally, the 2304-byte encoded buffer will be copied into the RSA_FOOTER buffer. How this\nand the RSA_CRYPT_BUFF buffer are used will later be discussed during file encryption.\n\n_Figure 35: Writing Encrypted Content Into RSA_FOOTER._\n\n## Finding Drives To Encrypt\n\n**DIAVOL loads and executes the shellcode from the resource ENMDSKS to enumerate and**\nfind all drives in the system when the encryption mode from the command line is local, net,\n**scan, or all.**\n\nThe shellcode receives the list of files to avoid encrypting and a buffer to contain the name of\ndrives found during enumeration as parameters.\n\n_Figure 36: Loading & Executing ENMDSKS._\n\nThe shellcode first calls GetLogicalDriveStringsW to retrieve a list of all the drives in the\nsystem. For each drive, its name is converted into lowercase and passed into\n**GetDriveTypeW as a parameter to retrieve its type.**\n\n\n-----\n\nThe drive only gets processed if its type is DRIVE_REMOTE or DRIVE_FIXED and its name\nis not in the list of files to avoid.\n\n_Figure 37: Enumerating Drives._\n\nIf the drive is valid to be encrypted, its name is appended to the buffer of drives from the\nshellcode’s parameter.\n\n\n-----\n\n_Figure 38: Populating Target Drives List._\n\nIf the drive is a remote drive, the malware calls WNetGetConnectionW to retrieve the name\nof the network resource associated with it.\n\n_Figure 39: Finding Network Resource From Drive Name._\n\nFinally, using the name of the network resource, the malware calls gethostbyname to\nretrieve a hostent structure that contains the IP address of the remote host.\n\n\n-----\n\nFinally, DIAVOL adds that IP address to the list of files to avoid encrypting.\n\n_Figure 40: Adding Network Resource IP Address To Avoid Enumerating Twice._\n\n## Scanning Target Network Shares Through SMB\n\n**DIAVOL has two different shellcode for scanning network shares using SMB in the**\n**SMBFAST and SMB resources.**\n\nThe SMBFAST shellcode is used to scan for network shares from the target host list given\nby the “-h” command-line parameter.\n\nPrior to launching this shellcode, DIAVOL allocates memory for this following structure to\ncontain information about network hosts to enumerate for shares.\n\n\n-----\n\n```\nstruct DIAVOL_SMB_STRUCT\n{\n FARPROC GetProcAddress;\n FARPROC memset;\n wchar_t *TARGET_NETWORK_SHARE_LIST; // Target network host names to enumerate for\nshares (from \"-h\" command-line)\n DWORD *remote_host_IP_list; // Buffer to receive IP address of network hosts\n __int64 curr_network_share_name[16]; // Buffer to contain currently-processed share\nname\n _WORD DNS_server_name[260]; // Buffer to receive DNS or NetBIOS name of the remote\nserver\n MIB_IPNETTABLE *IpNetTable;\n MIB_IFROW pIfRow;\n __int64 unk[2];\n};\n\n```\nThe malware also allocates memory for this structure to receive the name of all scanned\nnetwork resources. Both structures are then passed to the shellcode as parameters.\n```\nstruct DIAVOL_SMB_LIST\n{\n __int64 length;\n char *SMB_net_share_list;\n};\n\n```\n_Figure 41: Loading & Executing SMBFAST._\n\nSince the SMBFAST shellcode only scans for host names in the given target list, it\nenumerates through the list and writes each network share name into the\n**curr_network_share_name field to be processed.**\n\nFirst, the malware calls gethostbyname to retrieve a hostent structure for the current share\nname. Using the structure, it extracts the host’s list of IP addresses and appends it to the\n**remote_host_IP_list field.**\n\n\n-----\n\n_Figure 42: SMBFAST: Retrieve Target Host IP Addresses._\n\nNext, for each IP address retrieve from the host, the malware writes it to the\n**DIAVOL_SMB_STRUCT->DNS_server_name buffer. This is then passed as a parameter to**\na NetShareEnum call to retrieve information about each shared resource on the server with\nthat IP address.\n\n_Figure 43: SMBFAST: Retrieve Share Resource Info From IP Address._\n\nNext, for each resource on the server, DIAVOL adds it to the DIAVOL_SMB_LIST**>SMB_net_share_list buffer in the following format.**\n```\n<Server_IP_Address>//<Resource_Name>//\n\n```\n\n-----\n\nThe resource name is extracted from the shi1_netname from the SHARE_INFO_1 structure\nthat comes from the previous NetShareEnum call.\n\n_Figure 44, 45: SMBFAST: Adding Share Resource’s Full Path To Output List._\n\nThe final list is later used to encrypt these shared resources.\n\n## Scanning Network Shares In ARP Table Through SMB\n\nThe SMB shellcode is used to scan for network shares from the hosts extracted from the\n**Address Resolution Protocol (ARP) table.**\n\nPrior to launching this shellcode, DIAVOL allocates memory for the DIAVOL_SMB_STRUCT\nstructure and the DIAVOL_SMB_LIST structure similar to the SMBFAST shellcode.\n\n\n-----\n\n_Figure 46: Loading & Executing SMB._\n\nFirst, the shellcode calls GetIpNetTable to retrieve the IPv4-to-physical address mapping\ntable on the victim’s machine.\n\nUsing that table, the malware extracts the list of MIB_IPNETROW structures containing\nentries for IP addresses in the ARP table. For each MIB_IPNETROW structure, DIAVOL\ncalls GetIfEntry to retrieve information for the specified interface on the local computer.\n\n_Figure 47: SMB: Retrieving Information For IP Addresses In ARP Table._\n\nNext, the malware iterates through the DIAVOL_SMB_STRUCT->remote_host_IP_list\nbuffer to check if any given IP address from the “-h” command-line parameter is in the ARP\ntable.\n\n\n-----\n\n_Figure 48: SMB: Looking Up Target IP Addresses In ARP Table._\n\nFor each target IP address that is also in the ARP table, the malware writes it to the\n**DIAVOL_SMB_STRUCT->DNS_server_name buffer. This is then passed as a parameter to**\na NetShareEnum call to retrieve information about each shared resource on the server with\nthat IP address.\n\n_Figure 49: SMB: Retrieve Share Resource Info From IP Address._\n\n\n-----\n\nThe rest of the code is similar to the SMBFAST shellcode. For each resource on the server,\n**DIAVOL adds it to the DIAVOL_SMB_LIST->SMB_net_share_list buffer in the following**\nformat.\n```\n<Server_IP_Address>//<Resource_Name>//\n\n## Encryption: Target File Enumeration\n\n```\n**DIAVOL’s file encryption is divided into three parts. The first part is enumerating and**\nencrypting all files from the target list in the malware’s configuration.\n\nUp to this point, the files and directories in the list can come from the hard-coded values in\nmemory or from the command-line parameter “-p”.\n\nFirst, it allocates memory for the following structure before loading and executing the\nshellcode from resource FINDFILES.\n```\nstruct DIAVOL_FINDFILES_STRUCT\n{\n char* target_file; // The name of the file/directory to be encrypted\n DIAVOL_CONFIG *diavol_config; // Malware configuration\n FARPROC encrypt_file; // Function to encrypt file\n};\n\n```\nFor the target_file field, the malware iterates through the target file list and launches the\n**FINDFILES shellcode to encrypt each one.**\n\n_Figure 50: Loading & Executing FINDFILES._\n\n\n-----\n\nThe FINDFILES shellcode first converts the target filename to lowercase and checks to\nmake sure the filename does not match with anything in the configuration’s file to ignore list\nor the target file list (to avoid enumerating a directory twice).\n\nBecause the names in the list can contain wildcard characters (‘*‘ for matching zero or more\ncharacters and ’?’ for matching one character), the shellcode contains some additional code\nto check for that against the target filename.\n\n_Figure 51: Checking To Avoid Encrypting File._\n\nNext, DIAVOL calls FindFirstFileW to begin its enumeration on the target file. For each file it\nfinds, the malware checks and avoids files whose name are ”.” or ”..” to infinite recursion\nduring enumeration.\n\n_Figure 52: Starting Enumeration._\n\nIf the currently processed file is a directory, the malware similarly converts it into lowercase\nand checks to make sure the filename is not in the file to ignore list or the target file list.\n\n\n-----\n\nIf the found directory is valid to be enumerated, the malware updates the target_file field to\nthe directory’s name and recursively calls the FINDFILES shellcode function again.\n\nIf it is not valid, DIAVOL calls FindNextFileW to move on to find another file.\n\n_Figure 53: Recursive Traversal On Found Directories._\n\nIf the currently processed file is a directory, the malware also converts it into lowercase and\nchecks to make sure the filename is not in the file to ignore list or the target file list.\n\nIf the filename is in the configuration’s file to wipe list, the malware calls DeleteFileW to\ndelete it.\n\n_Figure 54: Deleting File._\n\nNext, if the filename’s format matches with anything in the configuration’s file to include list,\nthe malware calls LocalAlloc to allocate memory and write the filename in there. Finally, it\npasses the allocated buffer to the DIAVOL_FINDFILES_STRUCT->encrypt_file function to\nencrypt it.\n\n\n-----\n\n_Figure 55: Sending File To Be Encrypted._\n\nOnce the enumeration is done for the original target file, the malware calls FindClose to\nclose the file search handle and pass the target file’s name to the\n**DIAVOL_FINDFILES_STRUCT->encrypt_file function to encrypt it.**\n\n_Figure 56: Closing Search Handle & Encrypting Target File._\n\nThe encrypt_file function will be analyzed in a later section. This function can either take in\na directory name or a filename as the parameter.\n\n## Encryption: Remote File Enumeration Through SMB\n\nAfter scanning the network for network share resources through the SMBFAST and SMB\nshellcodes, the malware spawns threads to enumerate the resources in those lists.\n\nPrior to each thread_encrypt call, the malware updates the target_file field to contain each\nresource list from the two shellcodes.\n\n\n-----\n\n_Figure 57: Setting Up Network Resource Enumeration._\n\nThe thread_encrypt function calls CreateThread to create a suspended thread launching\nan inner function with the FINDFILES structure passed in as parameter.\n\n**DIAVOL also passes the thread handle to a global handle array to later launch it.**\n\n_Figure 58: Launching Suspended Thread To Enumerate Share Resource._\n\nFor each resource in the list, the thread executes the FINDFILES to enumerate it.\n\n\n-----\n\n_Figure 59: Thread To Launch FINDFILES Shellcode To Enumerate Resource._\n\nFinally, to launch all these threads to begin the remote file enumeration, the malware iterates\nthrough the global handle array and calls ResumeThread on each thread handle.\n\n\n-----\n\n_Figure 60: Resuming Suspended Threads To Begin Enumeration._\n\n## Encryption: System Drives Enumeration\n\nThe final part of the enumeration is on the local and network drives retrieved from the\n**ENMDSKS shellcode in the previous section.**\n\nThe list of drives to encrypt is passed to the target_file field in the FINDFILES structure, and\nthe malware launches the FINDFILES shellcode to enumerate and encrypt each drive.\n\n\n-----\n\n_Figure 61: Enumerating & Encrypting Network + Local Drives._\n\n## Encryption: File Encryption\n\nThe encrypt_file used in the FINDFILES shellcode takes in the name of a directory/file to\nencrypt.\n\nFirst, it sets up the following structure.\n```\nstruct DIAVOL_ENCDEFILES_TRUCT\n{\n HANDLE RSA_hKey; // RSA Public Key Handle\n wchar_t *file_name; // filename to encrypt\n __int64 MAX_FILE_CRYPT_PERCENT; // From the \"-perc\" command-line parameter\n FARPROC calculate_percent; // function to calculate percent (a / b * c where b is\n100)\n BYTE *RSA_CRYPT_BUFF;\n BYTE *RSA_FOOTER;\n FARPROC log_to_file; // logging function\n};\n\n```\n_Figure 62: Populating ENCDEFILES Structure._\n\nIf the name from the parameter is a directory, DIAVOL calls SetCurrentDirectoryW to\nchange the current directory for the malware’s process to the directory’s name.\n\nIt then calls CreateFileW to create the ransom note file and WriteFile to write the ransom\nnote in there.\n\n\n-----\n\n_Figure 63: Dropping Ransom Note._\n\nEarlier, before setting up the FINDFILES shellcode, the malware also loads the ENCDEFILE\nshellcode into another buffer in memory.\n\nWhen the name from the parameter is of a file, the malware launches the ENCDEFILE\nshellcode to encrypt it.\n\n_Figure 64: Launching ENCDEFILE Shellcode To Encrypt File._\n\nTo encrypt the file, the shellcode first calls CreateFileW to retrieve a handle for the target file.\n\nIt then calls GetFileSizeEx to retrieve the size of the file and calculates the maximum size to\nencrypt the file. This is done by calculating the MAX_FILE_CRYPT_PERCENT percent from\nthe total file size.\n\nNext, the file is encrypted in 2048-byte blocks each, and the malware allocates a 2048-byte\nbuffer using VirtualAlloc to host this data. For each block, DIAVOL calls ReadFile to read\ndata into the allocated buffer and encrypts it using the RSA_CRYPT_BUFF buffer.\n\nIt then calls SetFilePointerEx to set the file pointer to the beginning of the newly encrypted\nblock and calls WriteFile to write the encrypted block back in.\n\nAfter the encryption is finished, DIAVOL calls SetFilePointerEx to set the file pointer to the\nend of the file. It then calls WriteFile to write to the end the RSA_FOOTER buffer, the max\nfile size to encrypt, and the negation of every byte of that size.\n\nUsing this file footer, the threat actor’s decryptor can retrieve the RSA_FOOTER buffer and\ndecrypt it into the RSA_CRYPT_BUFF buffer using their RSA private key to decrypt the file.\n\n_Figure 66: Writing File Footer._\n\nFinally, DIAVOL calls VirtualAlloc to allocate a buffer to store the encrypted filename. It\nwrites the original filename in this buffer and appends it with the extension “.lock64” before\ncalling MoveFileW to change the filename.\n\n\n-----\n\n_Figure 67: Setting Encrypted File Extension._\n\n## Shadow Copies Deletion\n\nTo delete all shadow copies on the system, DIAVOL loads and executes the shellcode from\nthe VSSMOD resource.\n\n_Figure 68: Loading & Executing VSSMOD._\n\nFirst, the shellcode resolves these two stackstrings:\n\n“CompSpec”\n“/c vssadmin Delete Shadows /All /Quiet » NULL”\n\n\n-----\n\n_Figure 69, 70: Resolving Stackstrings._\n\nNext, it calls GetEnvironmentVariableW on the “CompSpec” string to retrieve a full path to\nthe command-line interpreter.\n\nWith that, it calls ShellExecuteW to execute the command “vssadmin Delete Shadows /All\n**/Quiet » NULL” to delete all shadow copies on the system.**\n\n_Figure 71: Deleting Shadow Copies._\n\n## Changing Desktop Image\n\nTo change the desktop image, DIAVOL loads and executes the shellcode from the\n**CHNGDESK resource.**\n\n\n-----\n\n_Figure 72: Loading & Executing CHNGDESK._\n\nThe shellcode first resolves the following stackstrings:\n\n”.\\encr.bmp”\n“Control Panel\\Desktop”\n“Wallpaper”\n“WallpaperOld”\n\nNext, it calls RegOpenKeyExW to retrieve the registry key using the sub key “Control\n**Panel\\Desktop”. With the registry key, the malware calls RegQueryValueExW to query the**\npath to the current wallpaper image and RegSetValueExW to set that path as the value of\n**“WallpaperOld”.**\n\n_Figure 73: Setting WallpaperOld Registry Value._\n\nTo build the bitmap path to drop on the system, the malware calls GetDesktopWindow and\n**SHGetSpecialFolderPathW to retrieve the path to the special folder containing image files**\ncommon to all users. It then appends “encr.bmp” to that path.\n\n\n-----\n\n_Figure 74: Building Bitmap Path._\n\nTo build the bitmap from scratch, DIAVOL calls CreateCompatibleDC,\n**GetDesktopWindow, and CreateDIBSection to create a bitmap as big as the current**\ndesktop window size. It also calls GetStockObject to set the bitmap’s background to black\nand SetTextColor to set the text color to white.\n\n_Figure 75: Creating Background Bitmap._\n\n\n-----\n\nNext, it resolves the following stackstrings:\n\n“All your files are encrypted!”\n“For more information see README-FOR-DECRYPT.txt”\n\nThe malware then calls DrawTextW to write these two strings into the bitmap, CreateFileW\nto create the bitmap file in the special folder, and WriteFile to write the generated bitmap into\nthe file.\n\n_Figure 76: Writing Bitmap Data To File._\n\nFinally, it calls SystemParametersInfoW to set wallpaper to the newly created bitmap file.\n\n_Figure 77: Setting Wallpaper To Generated Bitmap._\n\n## Self Deletion\n\nAfter finishing file encryption and changing the wallpaper, the malware deletes its own\nexecutable.\n\nFirst, it calls GetModuleFileNameW to retrieve its own executable path. Then it builds the\nfollowing string using that.\n```\n\"/c del <malware_executable_path> >> NULL\"\n\n```\n\n-----\n\n_Figure 78: Building CMD Parameter._\n\nNext, it calls GetEnvironmentVariableW on the “CompSpec” string to retrieve a full path to\nthe command-line interpreter.\n\nWith that, it calls ShellExecuteW to execute the parameter above to delete its own\nexecutable.\n\n_Figure 79: Deleting Its Own Executable._\n\n## Logging\n\nThroughout its execution, DIAVOL logs all of its operations when logging is enabled through\ncommand-line.\n\nIn the logging function, the malware receives a string as a parameter. It calls GetLocalTime\nto retrieve the current system time when the logging occurs and write that to the log file\nbuffer.\n\n\n-----\n\nThe malware then appends the input string parameter to the log file buffer and calls\n**WriteFile to write to the log file.**\n\n_Figure 80: Logging Functionality._\n\n## References\n\nhttps://www.fortinet.com/blog/threat-research/diavol-new-ransomware-used-by-wizard-spider\n\nhttps://securityintelligence.com/posts/analysis-of-diavol-ransomware-link-trickbot-gang/\n\nyashechka, don’t be too distanced ;) Just wanna say hi on XSS\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-12-17 - Diavol Ransomware.pdf"
    ],
    "report_names": [
        "2021-12-17 - Diavol Ransomware.pdf"
    ],
    "threat_actors": [
        {
            "id": "2864e40a-f233-4618-ac61-b03760a41cbb",
            "created_at": "2023-12-01T02:02:34.272108Z",
            "updated_at": "2025-03-27T02:02:10.209072Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "ETDA:WildCard",
            "tools": [
                "RustDown",
                "SysJoker"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "63061658-5810-4f01-9620-7eada7e9ae2e",
            "created_at": "2022-10-25T15:50:23.752974Z",
            "updated_at": "2025-03-27T02:00:55.538582Z",
            "deleted_at": null,
            "main_name": "Wizard Spider",
            "aliases": [
                "Wizard Spider",
                "UNC1878",
                "TEMP.MixMaster",
                "Grim Spider",
                "FIN12",
                "GOLD BLACKBURN",
                "ITG23",
                "Periwinkle Tempest",
                "DEV-0193"
            ],
            "source_name": "MITRE:Wizard Spider",
            "tools": [
                "TrickBot",
                "AdFind",
                "BITSAdmin",
                "Bazar",
                "LaZagne",
                "Nltest",
                "GrimAgent",
                "Dyre",
                "Ryuk",
                "Conti",
                "Emotet",
                "Rubeus",
                "Mimikatz",
                "Diavol",
                "PsExec",
                "Cobalt Strike"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f6f91e1c-9202-4497-bf22-9cd5ef477600",
            "created_at": "2023-01-06T13:46:38.86765Z",
            "updated_at": "2025-03-27T02:00:02.938998Z",
            "deleted_at": null,
            "main_name": "WIZARD SPIDER",
            "aliases": [
                "FIN12",
                "UNC2053",
                "Pistachio Tempest",
                "TEMP.MixMaster",
                "GOLD BLACKBURN",
                "Periwinkle Tempest",
                "DEV-0193",
                "Storm-0193",
                "Trickbot LLC",
                "DEV-0237"
            ],
            "source_name": "MISPGALAXY:WIZARD SPIDER",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "e6a21528-2999-4e2e-aaf4-8b6af14e17f3",
            "created_at": "2022-10-25T16:07:24.422115Z",
            "updated_at": "2025-03-27T02:02:10.216817Z",
            "deleted_at": null,
            "main_name": "Wizard Spider",
            "aliases": [
                "DEV-0193",
                "Gold Blackburn",
                "Gold Ulrick",
                "Grim Spider",
                "ITG23",
                "Operation BazaFlix",
                "Periwinkle Tempest",
                "TEMP.MixMaster",
                "Wizard Spider"
            ],
            "source_name": "ETDA:Wizard Spider",
            "tools": [
                "AdFind",
                "Agentemis",
                "Anchor_DNS",
                "BEERBOT",
                "BazarBackdoor",
                "BazarCall",
                "BazarLoader",
                "Cobalt Strike",
                "CobaltStrike",
                "Conti",
                "Diavol",
                "Dyranges",
                "Dyre",
                "Dyreza",
                "Dyzap",
                "Gophe",
                "Invoke-SMBAutoBrute",
                "KEGTAP",
                "LaZagne",
                "LightBot",
                "PowerSploit",
                "PowerTrick",
                "PsExec",
                "Ryuk",
                "SessionGopher",
                "TSPY_TRICKLOAD",
                "Team9Backdoor",
                "The Trick",
                "TheTrick",
                "Totbrick",
                "TrickBot",
                "TrickLoader",
                "TrickMo",
                "Upatre",
                "bazaloader",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bc119938-a79c-4e5f-9d4d-dc96835dfe2e",
            "created_at": "2024-06-04T02:03:07.799286Z",
            "updated_at": "2025-03-27T02:05:17.337094Z",
            "deleted_at": null,
            "main_name": "GOLD BLACKBURN",
            "aliases": [
                "Periwinkle Tempest ",
                "Wizard Spider ",
                "ITG23 "
            ],
            "source_name": "Secureworks:GOLD BLACKBURN",
            "tools": [
                " Buer Loader",
                " Dyre",
                " Team9",
                " TrickBot",
                "BazarLoader"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "256a6a2d-e8a2-4497-b399-628a7fad4b3e",
            "created_at": "2023-11-30T02:00:07.299845Z",
            "updated_at": "2025-03-27T02:00:03.257794Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "MISPGALAXY:WildCard",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536094,
    "ts_updated_at": 1743041799,
    "ts_creation_date": 1653693873,
    "ts_modification_date": 1653693873,
    "files": {
        "pdf": "https://archive.orkl.eu/78ce9de17353d5fad8c49a37bbf18505029135cf.pdf",
        "text": "https://archive.orkl.eu/78ce9de17353d5fad8c49a37bbf18505029135cf.txt",
        "img": "https://archive.orkl.eu/78ce9de17353d5fad8c49a37bbf18505029135cf.jpg"
    }
}