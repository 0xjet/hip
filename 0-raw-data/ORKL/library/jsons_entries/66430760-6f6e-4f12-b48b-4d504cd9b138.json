{
    "id": "66430760-6f6e-4f12-b48b-4d504cd9b138",
    "created_at": "2023-01-12T15:08:55.644125Z",
    "updated_at": "2025-03-27T02:16:40.000065Z",
    "deleted_at": null,
    "sha1_hash": "ec25d46dfb9780a63eb346a8523ad0e31072230b",
    "title": "2022-02-12 - Full Hancitor malware analysis",
    "authors": "",
    "file_creation_date": "2022-05-27T18:58:22Z",
    "file_modification_date": "2022-05-27T18:58:22Z",
    "file_size": 2586158,
    "plain_text": "# Full Hancitor malware analysis\n\n**muha2xmad.github.io/malware-analysis/fullHancitor/**\n\n### Muhammad Hasan Ali\n\nMalware Analysis learner\n\n12 minute read\n\n**As-salamu Alaykum**\n\n## Introduction\n\n\nFebruary 12, 2022\n\n\nHancitor is a famous malware loader that has been in use for years since first being observed in 2015. A\nmalware loader drops the actual malicious content on the system then executes the first stage of the\nattack. Hancitor has been the attacker’s loader of choice to deliver malwares like: FickerStealer, Sendsafe,\nand Cobalt Strike if the victim characteristics are met. In recent months, more threat intelligence has been\ngathered to confirm the selection of Hancitor by Cuba Ransomware gangs as well. The popularity of\n[Hancitor among threat actors is considered to last for a while. ref](https://blog.group-ib.com/hancitor-cuba-ransomware)\n\n\n-----\n\nFigure: How Hancitor infection happens. *paloaltonetworks photo\n\n## Unpacking process\n\n[We tried in a later article to unpack Hancitor malware. see it from Here. But we will try another way to](https://muha2xmad.github.io/unpacking/hancitor/)\nunpack it in this sample. Open the sample in the `x32dbg and set two BPs on` `VirtualAlloc and`\n```\nVirtualProtect then run F9 . We hit VirtualAlloc and then Execute till return then Follow\nin Dump of EAX. Keep doing that to hit the VirtualProtect BP we will see M8Z an indicator of Aplib\n\n```\ncompression.\n\n\n-----\n\nFigure:\n\nThen if we scroll down to the offset xx4380 we will get the `MZ string which is the start of our unpacked file`\nused in the analysis. Then save it to a file to start the analysis.\n\n## Abnormal Entry point\n\nIn Hancitor, there are 3 exports `BNJAFSRSQIX,` `SDTECHWMHHONG,` `DllEntryPoint . And the first two`\nfunctions have the same address. For the first thought the entry point will be `DllEntryPoint, but if we`\ncheck this function it only returns 1. From the malicious document which we extract the maliciuos Hancitor\nmalware. Launched the rundll32.exe command to execute the `BNJAFSRSQIX function, so it must be the`\nreal entry point for this DLL.\n\nFigure(1):\n\n## Gathering victim information\n\nWe enter `BNJAFSRSQIX we see a call to a function which i renamed it to` `Hancitor_Main . Then enter`\n```\nsub_10001AA0 renamed info_gathering . First the malware gathers information about the host\n\n```\ncontains: OS version, Computer name, Domains names, Victim IP address, whether the machine is x64 or\nx86 OS.\n\n\n-----\n\nFigure(2):\n\nFigure(3): pseudocode of figure 2\n\n\n-----\n\nThen we enter `getVictimID then enter` `sub_10001C70 which is the function that generates a unique ID`\nfor the victim. First, calling `GetAdaptersAddresses to get the addresses associated with the network`\nadapters on the victim machine then XOR-ing each (MAC) adapter with its address together. And calling\n```\nGetVolumeInformationA to retrieve the volume serial number of the machine then XORs it with the\nresult to create the victim’s unique ID.\n\n```\nFigure(4): pseudocode of sub_10001C70 function\n\nHow to get the IP of the victim? By sending a GET request to `hxxp://api[.]ipify[.]org . If the`\nmalware is unable to contact the website, it uses `0.0.0.0 as the victim’s IP address.`\n\nFigure(5):\n\nThen the final gathering step is to concatinate the gathered victim’s information in two ways to be sent to\nC2 server:\n```\nGUID=<Victim's GUID>&BUILD=<Build ID>&INFO=<Machine Information>&EXT=<Network domain names>&IP=\n<Victim's IP address>&TYPE=1&WIN=<Windows major version>.<Windows minor version>(x64)\nGUID=<Victim's GUID>&BUILD=<Build ID>&INFO=<Machine Information>&EXT=<Network domain names>&IP=\n<Victim's IP address>&TYPE=1&WIN=<Windows major version>.<Windows minor version>(x32)\n\n```\n\n-----\n\nFigure(6):\n\n## Configuration Extraction\n\n Manually Extraction\n\nMalware authors use tricks to obfuscate thier C2 IoCs. One of them is to encrypt it into a big chunk of data\nas in Hancitor Malware. So we need to search for big chunk of data which later will be decrypted during\nthe runtime. We will find our encrypted configuration in the begining of `.data section and if we select the`\nhex values then press `D we see it has refernces which means that it’s used somewhere.`\n\n\n-----\n\nFigure(7):\n\nThere are two chunks of data `Pbdata and` `byte_10005018 . If we press` `x over one of them it takes us`\nto a function which will be called `mw_Decrypt_Data which is the function decrypts the configuration of`\nthe malware. And these two chuncks of data are parameters in this function.\n\nFigure(8):\n\nNow enter this `mw_Decrypt_Data function. We see there are 5 API calls:`\n```\nCryptCreateHash : initiates the hashing of a stream of data.CryptCreateHash the 2nd parameter is\n\n```\n`Algid which identifies the hash algorithm to use. Its value is` `0x8004u which used SHA1` see the\ndecumentation of Algid\n```\nCryptDeriveKey : generates cryptographic session keys derived from a base data value CryptDeriveKey\n\n```\nthe 2nd parameter is `Algid Its value is` `0x6801u which used RC4`\n\n\n-----\n\nThe 4th parameter is `dwflags which determinte the size of the key which the key is a set with the upper`\n16 bits of `0x280011u which is` `0x28 divided by 8. Then the key size is 5 bytes.`\n\nFigure(9):\n\nWe get the SHA1 key from `pbdata . And we get the RC4 data from` `byte_10005018 and decrypte the`\nRC4-encrypted data using the first 5 bytes of the SHA1 key.\n\n*How we select hex values only? Do as in the figure 9. then choose `hex string (unspaced) . then copy`\nwhat is in the `preview .`\n\nFigure(10):\n\n[Then open cyberchef using](https://gchq.github.io/CyberChef/) `from hex and` `SHA1 we get the SHA1 key`\n```\nad818c687f8dc7f281135753e567eababa03d0ba . Then select the whole chunck of data of\nbyte_10005018 and copy hex as we did in SHA1 and use RC4 and using the first 5 bytes of SHA1.\n\n```\n\n-----\n\nFigure(11):\n\nHere are 3 C2 servers which the malware communicate with for further commands based on the collected\nvictim host information. Build ID `2909_xplw .`\n```\n hxxp://forkineler(.)com/8/forum.php\n hxxp://yemodene(.)ru/8/forum.php\n hxxp://fordecits(.)ru/8/forum.php\n\n## Automated Extraction\n\n```\nFigure(12):\n\n\n-----\n\n```\n po pe e a se da a o a o a\nimport re   #Use a regular expression to locate our config data\nimport struct # Convert binary data into numeric values.\nimport hashlib #Generate a SHA1 hash\nfile_path = r'file path' #file path\ndata = open(file_path,'rb').read() # read it in binary \npe = pefile.PE(data=data) # to parse data as PE file to acess sections and offsets\n# Use Regular Expression to Locate The Decryption Code\nkey = rb'\\x6a(.)\\x68(....)\\x68\\x00\\x20\\x00\\x00' #opcode as in the figure(6).\nm = re.search(key, data) # extract the data that was matched by the wildcard.\nif m != None:\n print(\"key length: %r\" % m.group(1))\n print(\"key address: %r\" % m.group(2)) \n# Convert The Extracted Key Information\nstruct.unpack('b', m.group(1))[0] #converte into bytes\nhex(struct.unpack('<I', m.group(2))[0]) # converting an unsigned integer (DWORD) stored in littleendian format in hex\n# Use The Key Information To Extract The Key Data\nkey_len = struct.unpack('b', m.group(1))[0]\nkey_address = struct.unpack('<I', m.group(2))[0]\nkey_rva = key_address - pe.OPTIONAL_HEADER.ImageBase\nkey_offset = pe.get_offset_from_rva(key_rva)\nkey_data = data[key_offset:key_offset+key_len]\nconfig_data = data[key_offset+key_len:key_offset+key_len+0x2000]\n# Hash The Key Data To Create The Key\nm = hashlib.sha1()\nm.update(key_data)\nkey = m.digest()[:5]\n# RC4 Decryption\ndef rc4crypt(data, key):\n  #If the input is a string convert to byte arrays\n  if type(data) == str:\n    data = data.encode('utf-8')\n  if type(key) == str:\n    key = key.encode('utf-8')\n  x = 0\n  box = list(range(256))\n  for i in range(256):\n    x = (x + box[i] + key[i % len(key)]) % 256\n    box[i], box[x] = box[x], box[i]\n  x = 0\n  y = 0\n  out = []\n  for c in data:\n    x = (x + 1) % 256\n    y = (y + box[x]) % 256\n    box[x], box[y] = box[y], box[x]\n    out.append(c ^ box[(box[x] + box[y]) % 256])\n  return bytes(out)\n# Parsing The Config\nconfig = rc4crypt(config_data, key)\nbuild_id = config.split(b'\\x00')[0]\nc2_string = b''\nfor s in config.split(b'\\x00')[1:]:\n  if s != b'':\n     c2 string s\n\n```\n\n-----\n\n```\n     b ea\nc2_list = c2_string.split(b'|')\nprint(\"BUILD: %s\" % build_id)\nfor c2 in c2_list:\n  if c2 != b'':\n    print(\"C2: %s\" % c2)\n\n```\n[For better understanding visit OALabs github](https://github.com/OALabs/Lab-Notes/blob/main/Hancitor/hancitor.ipynb)\n\n## C2 server Communication\n\nAfter collecting all victim information and put into one fourm as we mentioned above. the malware tries to\nget the C2 URL from the configuration and sends the data to C2 the servers. If we enter the function\n```\ngetNext_URL . It tries to get the next URL address from the list using the location of | between the C2\n\n```\nservers.\n\nFigure(13):\n\nThen we enter `send_Data_To_C2 function, we see 3 API calls which are an indication of sending data to`\nC2 server:\n\n[HttpOpenRequestA: Creates an HTTP POST request handle.](https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-httpopenrequesta)\n\n[HttpSendRequestA: Sends the specified request or data to the HTTP server.](https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-httpsendrequesta)\n\n[InternetReadFile: Reads data or commands from a handle opened by the HttpOpenRequest function.](https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetreadfile)\n\n\n-----\n\nFigure(14):\n\nFrom PCAP of [Malware-Traffic-Analysis.net. We ping the 1st C2 server (](https://www.malware-traffic-analysis.net/2021/09/29/index.html)\nhxxp://forkineler(.)com/8/forum.php) to get the IP `194.147.115.132 which will help us to get the C2`\nresponse. Open the PCAP file and search with `ip.addr == 194.147.115.132 then` `follow then` `TCP`\n```\nstream . As we see POST and GET request and base64 encoded response. base64 encoded C2\n\n```\nresponse:\n```\nVZAEARZAEg4OCkBVVU4XGw8IChUUDlQID1VOSwlUGBMUBwEWQBIODgpAVVVOFxsPCAoVFA5UCA9VTktUGBMUBw== .\n\n```\nThen enter `check_C2_response function: first it checks the 1st 4 chars IsUpperCase? if Not in upper`\ncase the check fails and return 0.\n\nFigure(15):\n\n\n-----\n\nIf the check is valid then it decodes the base64 C2 response and XORs the result with the letter `z using`\n```\nCyberChef .\n\n```\nFigure(16):\n\nAs we see in the last figure the response command contains:\n```\n A specific action from `{'b','e','l','n','r'}`\n A colon (:) char\n A URL is used to download malicious content\n\n```\nFigure(17):\n\n## Download content and inject\n\nExplaining the set of actions the malware will do from `{'b','e','l','n','r'} .`\n\n\n-----\n\nFigure(18):\n```\nb action\n\n```\nThe downloaded content will be injected into a new `svchost.exe process using the APIs:`\n```\nVirtualAllocEx and WriteProcessMemory . First the malware downloads content, as in the\ndownload_content function, from the malicious URL in the C2 response then inject it into a new\nsvchost process.\n\n```\nFigure(19): action: download_inject_into_New_svchost function\n\nEntering `download_content then entering` `decrypt_decompress_downloadedContent . We will see`\nthat it’s trying to decrypt the downlaoded content by XOR-ing with its first 8 bytes then using\n\n`RtlDecompressBuffer function to decompress.` [See doc then continue](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtldecompressbuffer)\n\n\n-----\n\nFigure(20): decrypt_decompress_downloadedContent function\n\nFigure(21): using CreateProcessA to create a suspended svchost process\n\nusing `VirtualAllocEx to allocate a buffer in the memory, then` `w_HeapAlloc to allocate a heap buffer,`\nand then `WriteProcessMemory to write the payload from the heap to svchost allocated memory.`\n\n\n-----\n\nFigure(22): using CreateProcessA to create a suspended svchost process\n\nFigure(23): the entryPoint of svchost is the entryPoint of injected malicious content\n```\nb action in brief:\n\n```\n1. Download the malicious content from the URL.\n\n\n-----\n\n2. Decrypting and decompress the content.\n3. create `svchost in a suspended state.`\n4. Allocate a buffer in the memory for the malicous content.\n5. Load the malicious content into the allocated buffer.\n6. Make the entryPoint of the injected malicous content is the entryPoint of `svchost.exe process`\n7. Then resume the process\n```\ne action\n\n```\nThe downloaded content will be injected into the current running process. Download then inject.\n\nFigure(24): Download then inject into the currently running process\n\n\n-----\n\nFigure(25): Loading the import table\n```\ne action in brief:\n\n```\n1. Download the malicious content from the URL.\n2. Decrypting and decompress the content.\n3. Allocate memory for the content in the current running process.\n4. Load import table\n5. Load the malicious content into the allocated buffer.\n6. launch the thread using two methods:\n\nusing `CreateThread which resolves the entryPoint Or`\nusing the returned entryPoint after writing the content in memory.\n```\ni action\n\n```\nDownloads shellcode and inject it into the current process or into `svchost.exe .`\n\n\n-----\n\nFigure(26): How injecting and executing the shellcode using i action\n```\ni action in brief:\n\n```\n1. Download the shellcode from the URL.\n2. Decrypting and decompress the content which is shellcode.\n3. inject the shellcode by one methode:\n\nCreating `svchost.exe process then inject the process then resumes the process. Or`\nInject into the current running process.\n```\nn action\n\n```\nDoes nothing, or it’s used to ping the victim.\n```\nr action\n\n```\nDrop an EXE or DLL in the `Temp folder then inject into` `svchost.exe .`\n\n\n-----\n\nFigure(27): How injecting and executing the content using r action\n```\nr action in brief:\n\n```\n1. Download the the content from the URL.\n2. Decrypting and decompress the content.\n3. Gets the path of TEMP folder and create a file and its random name begins with `BN in the path of`\n\nTEMP folder.\n4. Execute the downloaded content which depends on if it’s an EXE or DLL:\n\nAn EXE it will be executed normally.\na DLL executed by using `rundll32.exe .`\n\n## Summary\n\n**Abnormal Entry point:** `DllEntryPoint is not the real entryPoint, but` `BNJAFSRSQIX is the EnryPoint.`\n\n**Gathering victim information: Gatheing info about the victim which gives choice for the malware to**\ngenerate unique ID and downlaod which content.\n\n**Configuration Extraction: The key is encrypted in SHA1 and the embedded configuration encrypted in**\nRC4. The malware uses `CryptoAPI to do the decryption using the first 5 bytes of the SHA1 key.`\n\n**C2 server Communication: The victim information will be sended to the C2 server. After decoding the**\nbase64 encoded with additional layer of single-byte XOR C2 response. The decoded C2 response has\n```\nBuild ID and URLs from which the malicous content is downloaded.\n\n```\n**Download content and inject: From the decoded C2 response, the malware will decide which content**\nwill be downlaoded then injected then executed. If it’s a malicious EXE, DLL, or shellcodes.\n\n## IoCs\n\n**No.** **Description** **Hash and URLs**\n\n1 The packed DLL (MD5 ) 32799A01C72148AB003AF600F8EB40DC\n\n2 The unpacked DLL (MD5) B7679D55FC9B5F3447FF743EEAAB7493\n\n3 C2 response server hxxp://4maurpont.ru/41s.bin (194.147.115.132)\n\n4 C2 Server 1 hxxp://forkineler(.)com/8/forum.php\n\n\n-----\n\n**No.** **Description** **Hash and URLs**\n\n5 C2 Server 2 hxxp://yemodene(.)ru/8/forum.php\n\n6 C2 Server 3 hxxp://fordecits(.)ru/8/forum.php\n\n## Article quote\n\nﻣﺎ أﺿﯿﻖ اﻟﻄﺮﯾﻖ ﻋﻠﻲّ ﻣﺎ ﻟﻢ ﺗﻜﻦ دﻟﯿﻠﻪ! وﻣﺎ أوﺣﺸﻪ ﻋﻠﻲّ ﻣَﻦ ﻟﻢ ﺗﻜﻦ أﻧﯿﺴﻪ !ﺳﺒﺤﺎﻧﻚ\n\n## REF\n\n[1. https://cyber-anubis.github.io/malware%20analysis/hancitor/#the-b-command](https://cyber-anubis.github.io/malware%20analysis/hancitor/#the-b-command)\n\n[2. https://www.0ffset.net/reverse-engineering/malware-analysis/hancitor-analysing-the-main-loader/](https://www.0ffset.net/reverse-engineering/malware-analysis/hancitor-analysing-the-main-loader/)\n\n3. https://www.youtube.com/watch?\n\n[v=OQuRwpUTBpQ&list=PLGf_j68jNtWG_6ZwFN4kx7jfKTQXoG_BN&index=9&t=2s&ab_channel=O](https://www.youtube.com/watch?v=OQuRwpUTBpQ&list=PLGf_j68jNtWG_6ZwFN4kx7jfKTQXoG_BN&index=9&t=2s&ab_channel=OALabs)\nALabs\n\n[4. https://www.binarydefense.com/analysis-of-hancitor-when-boring-begets-beacon/](https://www.binarydefense.com/analysis-of-hancitor-when-boring-begets-beacon/)\n\n5. https://elis531989.medium.com/dissecting-and-automating-hancitors-config-extraction\n1a6ed85d99b8\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-02-12 - Full Hancitor malware analysis.pdf"
    ],
    "report_names": [
        "2022-02-12 - Full Hancitor malware analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "5d2bd376-fcdc-4c6a-bc2c-17ebbb5b81a4",
            "created_at": "2022-10-25T16:07:23.667223Z",
            "updated_at": "2025-03-27T02:02:09.916086Z",
            "deleted_at": null,
            "main_name": "GCHQ",
            "aliases": [
                "Government Communications Headquarters",
                "Operation Socialist"
            ],
            "source_name": "ETDA:GCHQ",
            "tools": [
                "Prax",
                "Regin",
                "WarriorPride"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "2864e40a-f233-4618-ac61-b03760a41cbb",
            "created_at": "2023-12-01T02:02:34.272108Z",
            "updated_at": "2025-03-27T02:02:10.209072Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "ETDA:WildCard",
            "tools": [
                "RustDown",
                "SysJoker"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "256a6a2d-e8a2-4497-b399-628a7fad4b3e",
            "created_at": "2023-11-30T02:00:07.299845Z",
            "updated_at": "2025-03-27T02:00:03.257794Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "MISPGALAXY:WildCard",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536135,
    "ts_updated_at": 1743041800,
    "ts_creation_date": 1653677902,
    "ts_modification_date": 1653677902,
    "files": {
        "pdf": "https://archive.orkl.eu/ec25d46dfb9780a63eb346a8523ad0e31072230b.pdf",
        "text": "https://archive.orkl.eu/ec25d46dfb9780a63eb346a8523ad0e31072230b.txt",
        "img": "https://archive.orkl.eu/ec25d46dfb9780a63eb346a8523ad0e31072230b.jpg"
    }
}