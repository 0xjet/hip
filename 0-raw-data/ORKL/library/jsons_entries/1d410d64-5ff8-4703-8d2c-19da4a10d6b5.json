{
    "id": "1d410d64-5ff8-4703-8d2c-19da4a10d6b5",
    "created_at": "2023-04-05T02:09:25.726912Z",
    "updated_at": "2025-03-27T02:06:07.162259Z",
    "deleted_at": null,
    "sha1_hash": "131b964a7220227226f4f9072cb39383e3ea932c",
    "title": "2023-03-15 - DotRunPEX - Demystifying New Virtualized .NET Injector used in the Wild",
    "authors": "",
    "file_creation_date": "2023-04-03T08:33:28Z",
    "file_modification_date": "2023-04-03T08:33:28Z",
    "file_size": 10104943,
    "plain_text": "# DotRunpeX – demystifying new virtualized .NET injector used in the wild\n\n**[research.checkpoint.com/2023/dotrunpex-demystifying-new-virtualized-net-injector-used-in-the-wild/](https://research.checkpoint.com/2023/dotrunpex-demystifying-new-virtualized-net-injector-used-in-the-wild/)**\n\nMarch 15, 2023\n\n**Research by: Jiri Vinopal.**\n\n## Highlights:\n\n**_Check Point Research (CPR) provides an in-depth analysis of the dotRunpeX injector and its relation_**\n**_to the older version_**\n**_DotRunpeX is protected by virtualization (a customized version of KoiVM) and obfuscation_**\n**_(ConfuserEx) – both were defeated_**\n**_Investigation shows that dotRunpeX is used in the wild to deliver numerous known malware families_**\n**_Commonly distributed via phishing emails as malicious attachments and websites masquerading as_**\n**_regular program utilities_**\n**_We confirmed and detailed the malicious use of a vulnerable process explorer driver to disable the_**\n**_functionality of Anti-Malware services_**\n**_CPR introduces several PoC techniques that were approved to be effective for reverse engineering_**\n**_protected or virtualized dotnet code_**\n\n## Introduction\n\n\n-----\n\nDuring the past few months, we have been monitoring the dotRunpeX malware, its usage in the wild, and infection\nvectors related to dozens of campaigns. The monitoring showed that this new dotnet injector is still evolving and in\nhigh development. We uncovered several different methods of distribution where in all cases, the dotRunpeX was a\npart of the second-stage infection. This new threat is used to deliver numerous different malware families, primarily\nrelated to stealers, RATs, loaders, and downloaders.\n\nThe oldest sample related to the new version of dotRunpeX is dated 2022-10-17. The first [public information about](https://twitter.com/vinopaljiri/status/1585308917722009603)\nthis threat is dated 2022-10-26.\n\nThe main subject of this research is an in-depth analysis of both versions of the dotRunpeX injector, focusing on\ninteresting techniques, similarities between them, and an introduction to the PoC technique used to analyze a new\n[version of dotRunpeX as it is being delivered virtualized by a customized version of KoiVM .NET protector.](https://github.com/yck1509/KoiVM)\n\n## Background & Key Findings\n\nDotRunpeX is a new injector written in .NET using the Process Hollowing technique and used to infect systems\nwith a variety of known malware families. Although this injector is new, there are some connections to its older\nversion sharing some similarities. The name of this injector is based on its version information which is the same for\nboth dotRunpeX versions, consistent across all samples we analyzed and containing ProductName –\n```\nRunpeX.Stub.Framework.\n\n```\nWhile we have been monitoring this threat, we spotted a few publicly shared pieces of information, mainly by\nindependent researchers, that were related to the functionality of dotRunpeX but misattributed to a different wellknown malware family.\n\nWe are aware of a [publication about one campaign delivering this threat, but our findings and conclusions based on](https://www.sentinelone.com/labs/malvirt-net-virtualization-thrives-in-malvertising-attacks/)\nthe report below slightly differ. By monitoring this threat for a few months, we got enough information to differentiate\nthe first-stage loaders from the second stage (dotRunpeX) with no signs of the relation between them. We\nrevealed the connections to its older version, the distribution of numerous malware families, and several different\ntechniques used as a vector of infection.\n\nAmong the variety of downloaders and cryptocurrency stealers, we spotted these known malware families delivered\nby dotRunpeX:\n\n\n-----\n\nFigure 1: Malware Families Delivered by DotRunpeX\nFrom the timeline perspective, based on the compilation timestamps of dotRunpeX samples that did not appear to\nbe altered, this new threat became popular mainly during November 2022 and January 2023. What could be just an\ninteresting coincidence or just some kind of sign of attackers waiting under the Christmas tree is that we did not see\na lot of samples compiled during December 2022.\n\n\n-----\n\nFigure 2: DotRunpeX Timeline – Compilation Timestamps\n\n## Vector of infection\n\nDotRunpeX injector commonly comes as a second stage of the original infection. The typical first stages are very\ndifferent variants of .NET loaders/downloaders. The first-stage loaders are primarily being delivered via phishing\nemails as malicious attachments (usually as a part of “.iso”, “.img”, “.zip”, and “.7z”) or via websites masquerading\nas regular program utilities. Apart from the most common infection vectors, the customers of dotRunpeX are not\nashamed to abuse Google Ads or even target other potential attackers via trojanized malware builders.\n\nExample phishing email Transaction Advice 502833272391_RPY - 29/10/2022 delivering the first stage loader\nas a part of malicious “.7z” attachment that results in loading of dotRunpeX (SHA256:\n“457cfd6222266941360fdbe36742486ee12419c95f1d7d350243e795de28200e”).\n\nFigure 3: Phishing email “Transaction Advice 502833272391_RPY – 29/10/2022”\nExample phishing websites – masquerading regular program utilities (Galaxy Swapper, OBS Studio, Onion\nBrowser, Brave Wallet, LastPass, AnyDesk, MSI Afterburner) and delivering the first stage loaders that result in\ndotRunpeX infection in a part of the second stage.\n\n\n-----\n\nWebsite masquerading as Galaxy Swapper: https://www.galaxyswapper[.]ru/\n\nFigure 4: Google search for the utility Galaxy Swapper leads to “https://www.galaxyswapper[.]ru/”\nDownload redirects\nto https://gitlab[.]com/forhost1232/galaxyv19.11.14/-/raw/main/GalaxyV19.11.14.zip.\n\nFigure 5: Download button on “https://www.galaxyswapper[.]ru/” redirects to a trojanized program\nWebsite masquerading as LastPass Password Manager: http://lastpass[.]shop/en/\n\n\n-----\n\nFigure 6: Website “http://lastpass[.]shop/en/” masquerading as LastPass Password Manager\nThe fake website of LastPass Password Manager was already down at the time of the investigation. Still, we can\nconfirm that the fake software was downloaded from the “Final\n**_URL” https://gitlab[.]com/forhost1232/lastpassinstaller/-/raw/main/LastPassInstaller.zip._**\n\nFigure 7: Download button on “http://lastpass[.]shop/en/” redirects to a trojanized program\nThe GitLab page https://gitlab[.]com/forhost1232 contained dozens of programs trojanized by dotRunpeX\nmalware.\n\n\n-----\n\nFigure 8: Dozens of trojanized programs on GitLab repository “https://gitlab[.]com/forhost1232”\nAll of the trojanized programs on the previously mentioned GitLab page contain the main .NET application enlarged\nwith an overlay to avoid scanning with sandboxes very likely.\n\nFigure 9: Examples of trojanized programs served by the GitLab repository “https://gitlab[.]com/forhost1232”\nThe mentioned .NET applications with overlay are the typical first stages, behaving as dotnet loaders with simple\nobfuscation. These different variants of loaders use reflection to load the dotRunpeX injector in the second stage.\nSome of them are very simple, and some are more advanced.\n\nSimple first-stage loader (direct usage of method System.Reflection.Assembly.Load()):\n\n\n-----\n\nFigure 10: Simple first-stage loader\nAn example of a more advanced first-stage loader (using AMSI Bypass and DynamicMethod to load and execute\nthe second stage via reflection) can be seen below. The advantage of this kind of advanced loader is that there is\nno direct reference to System.Reflection.Assembly.Load() method so it could possibly avoid detection of\nengines relying on static parsing of .NET metadata.\n\nFigure 11: More advanced first-stage loader using AMSI bypass and DynamicMethod\nDeobfuscated form of the latter one could be seen in the picture below:\n\n\n-----\n\nFigure 12: A deobfuscated form of a more advanced first-stage loader\nProgrammatic way of second-stage extraction (dotRunpeX stage) from these kinds of loaders could be simply\n[implemented using AsmResolver and](https://github.com/Washi1337/AsmResolver) [reflection as shown below.](https://learn.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection)\n\nFigure 13: Extraction of dotRunpeX from first-stage loader using AsmResolver and reflection\nImportant to note that those examples of phishing websites leading to the GitLab page were related to just one\ncampaign where the dotRunpeX injector was always responsible for injecting Redline malware with C2 –\n```\n77.73.134.2.\n\n```\nIn addition to the most common vectors of infection mentioned earlier, we observed quite an interesting case of\ninfection vector, where a customer of dotRunpeX was probably bored enough to target ordinary victims and\ndecided to target other potential attackers. Something that is supposed to be a Redline\n\n\n-----\n\nbuilder Redline_20_2_crack.rar (SHA256:\n“0e40e504c05c30a7987785996e2542c332100ae7ecf9f67ebe3c24ad2468527c”) was trojanized with a downloader\nthat uses a reflection to load dotRunpeX as a hidden “added feature” of the builder.\n\nFigure 14: Folder structure of trojanized Redline builder\nIt turned out that during the building process of the Redline, configured to your needs, one will also get another\nRedline sample, probably the one that you didn’t desire, as a gift embedded in the dotRunpeX.\n\nFigure 15: Downloader that uses a reflection to load dotRunpeX delivering another Redline malware\n\n## Technical Analysis: Highlights\n\n### The old version of dotRunpeX:\n\nUsing custom obfuscation – only obfuscations of names\nConfigurable but limited (target for payload injection, elevation + UAC Bypass, XOR key for payload\ndecryption)\n\n\n-----\n\nOnly one UAC Bypass technique\nUsing simple XOR to decrypt the main payload to be injected\nUsing [D/Invoke similar technique to call native code (based on using GetDelegateForFunctionPointer()) –](https://github.com/TheWover/DInvoke)\nbut using decoy syscall routine\nUsing D/Invoke for remapping of “ntdll.dll”\n\n### The new version of dotRunpeX:\n\n[Protected by a customized version of the KoiVM virtualizer](https://github.com/yck1509/KoiVM)\nHighly configurable (disabling Anti-Malware services, Anti-VM, Anti-Sandbox, persistence settings, key for\npayload decryption, UAC bypass methods)\nMore UAC Bypass techniques\nUsing simple XOR to decrypt the main payload to be injected (omitted in the latest developed versions)\nAbusing procexp driver (Sysinternals) to kill protected processes (Anti-Malware services)\nSigns of being Russian based – procexp driver name Иисус.sys translated as “jesus.sys”\n\n### Similarities between both versions:\n\n64-bit executable files “.exe” written in .NET\nUsed to inject several different malware families\nUsing simple XOR to decrypt the main payload to be injected\nPossible usage of the same UAC bypass technique (the new version of dotRunpeX has more techniques\navailable)\n\nFigure 16: UAC bypass technique\n\nUsing the same version information\n\n\n-----\n\nFigure 17: DotRunpeX version information\n\nUsing the same .NET resource name BIDEN_HARRIS_PERFECT_ASSHOLE to hold the encrypted payload to be\ninjected\n\nFigure 18: Dotnet resource name of new version vs. old version\n\nUsing the same code injection technique – Process Hollowing\nUsing the same structured class for definitions of Native delegates\n\n\n-----\n\nFigure 19: The same structured class for definitions of Native delegates\n\n## Full technical analysis – old version of dotRunpeX\n\nFor the analysis of the older version of dotRunpeX, sample SHA256:\n“65cac67ed2a084beff373d6aba6f914b8cba0caceda254a857def1df12f5154b” was used. This sample is a 64-bit\nexecutable file “.exe” written in .NET, implementing custom obfuscation – only obfuscations of names. The version\ninformation is consistent across all samples we analyzed, and we can notice the ProductName –\n```\nRunpeX.Stub.Framework that could be some kind of first hint that we are dealing with a dotnet injector.\n\n```\nFigure 20: Consistent version information of the old dotRunpeX version\nFor simplicity, we partly deobfuscated the names of methods, their arguments, and local variables. Right in\nthe Main() method, we can see simple XOR decryption of the resource BIDEN_HARRIS_PERFECT_ASSHOLE that\ncontains an encrypted payload to be injected. The resource name was consistent across all samples we analyzed.\n\nFigure 21: The main method leads to simple XOR decryption of the embedded payload\nWe can also see the namespace UACBypass with the class name UAC. This class implements UAC (User Account\n**_Control) bypass method, but it is not configured to use in this sample._**\n\n\n-----\n\nFigure 22: UAC bypass method\nMethod Inject() is implementing a code injection technique called “Process Hollowing”. We can notice spawning\na process in a suspended state right in the picture below.\n\nFigure 23: Creation of suspended process as a part of the Process Hollowing technique\nThis technique is nothing new in the world of malware development. Still, there is something interesting we can\n[immediately spot once we check P/Invoke (technology that allows access to structs, callbacks, and functions in](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke)\nunmanaged libraries from managed code) defined methods of this sample. These methods can be seen in\nthe ImplMap table, which is a part of .NET metadata.\n\nFigure 24: The ImplMap table – the old version of the dotRunpeX\n\n\n-----\n\nCertain WIN APIs or NT APIs must be used to perform the Process Hollowing technique. And as we saw in\nthe ImplMap table, some of the most crucial APIs are missing. To be more specific, we cannot see any APIs related\nto unmapping and writing to remote process memory. The reason behind this is the usage of\nthe [D/Invoke framework to call certain NT API routines that could usually trigger attention.](https://github.com/TheWover/DInvoke)\n\nD/Invoke contains powerful primitives that may be combined intelligently to dynamically invoke unmanaged code\nfrom disk or memory with careful precision. It relies on the usage of the dotnet\nmethod GetDelegateForFunctionPointer() and corresponding delegates definitions.\n\nIn this case, NT APIs ZwOpenSection, ZwMapViewOfSection, ZwUnmapViewOfSection, NtClose,\n```\nNtWriteVirtualMemory, NtResumeThread, and RtlMoveMemory are implemented via D/Invoke. The corresponding\n\n```\ndefinitions of delegates can be seen below.\n\nFigure 25: The class for definitions of Native delegates\nWhat is even more interesting, 4 NT APIs\n(ZwUnmapViewOfSection, NtWriteVirtualMemory, NtResumeThread, RtlMoveMemory) implemented via D/Invoke are\nusing something that could be considered as an added PoC technique and is not a part of the original D/Invoke\nframework – syscall patching. For example, we can check how NtWriteVirtualMemory invocations are\nimplemented via a method called CallNtWriteVirtualMemory().\n\nFigure 26: Example of D/Invoke implementation that leads to syscall patching\n\n\n-----\n\nFirst, what we can see is an altered usage of the D/Invoke framework in the method MapDllandGetProcAddress().\nEach time this method is invoked, it will remap the specified library and obtain the desired function’s address.\nBefore returning the address of the desired function, pointer arithmetic is used to move the pointer by 4 bytes so it\npoints to the address of the syscall number. In this case, the “ntdll.dll” module gets remapped, returning the\naddress of the NT API routine NtWriteVirtualMemory altered by 4 bytes offset.\n\nFigure 27: Altered usage of the D/Invoke that returns the address pointing to the syscall number\n\nFigure 28:\n\nNtWriteVirtualMemory address altered by 4 bytes offset points to its syscall number\nThe remapping of the module is used as an AV-evasion and Anti-Debug technique, as it results in unhooking and\nremoving all set software breakpoints. The obtaining address of a certain native function is implemented via typical\nD/Invoke implementation – DynGetProcAddress(), which is responsible for in-memory parsing of the PE structure\nto find the address of the specified routine.\n\n\n-----\n\nFigure 29: Typical in-memory parsing of the PE structure implemented via D/Invoke\nNow back to the exciting part. As we can see in this case, DynGetProcAddress() is also used to find the address of\nNT API NtAddBootEntry, and we can call it a decoy routine. The decoy routine address will be used for syscall\npatching.\n\n\n-----\n\nFigure 30: Decoy routine NtAddBootEntry used for syscall patching\n\nGetting the address of the NtWriteVirtualMemory routine altered by 4 bytes offset (address of syscall\nnumber)\nGetting the address of the decoy routine NtAddBootEntry\nCopying 2 bytes from the altered address of NtWriteVirtualMemory (even though the syscall number\nis DWORD, these 2 bytes are enough and represent the syscall number of NtWriteVirtualMemory) to byte\nfield SyscallStub (this field contains syscall stub code)\nPatching address of NtAddBootEntry with byte field SyscallStub\n\nDisassembling the default value of the SyscallStub makes it even more apparent why exactly 2 bytes are getting\nreplaced with bytes from the altered address of the NtWriteVirtualMemory routine. These 2 bytes represent the\nsyscall number of certain real function to be called.\n\nFigure 31: Disassembling the default value of the byte field SyscallStub\nSimply said, once the NtWriteVirtualMemory function is called, the only thing we will see from user mode will be\nan invocation of NtAddBootEntry.\n\nWe can use WinDbg “kernel mode debugging” to verify the mentioned execution flow. We can see that NT\nAPI NtAddBootEntry with the original syscall number 0x6a (on our target system) is used as a patched decoy\nroutine. In the case where NtWriteVirtualMemory needs to be called, the syscall number of the decoy routine is\npatched with syscall number 0x3a (NtWriteVirtualMemory syscall number on our target system) and gets called.\n\n\n-----\n\nFigure 32: WinDbg “kernel mode debugging” shows the execution flow caused by syscall patching\n\n## Full technical analysis – new version of dotRunpeX\n\nFor the analysis of the new version of dotRunpeX, sample SHA256:\n“44a11146173db0663a23787bffbb120f3955bc33e60e73ecc798953e9b34b2f2” was used. This sample is a 64-bit\nexecutable file “.exe” written in .NET, protected by [KoiVM. The version information is the same as in the case of an](https://github.com/yck1509/KoiVM)\nolder version of dotRunpeX and is consistent across all samples we analyzed. We can notice the ProductName –\n```\nRunpeX.Stub.Framework again.\n\n```\nFigure 33: Consistent version information of the new dotRunpeX version\n[Right after opening the sample in dnSpyEx and leading to the entrypoint function – _sb() method, we can](https://github.com/dnSpyEx/dnSpy)\nimmediately confirm that this new version of dotRunpeX is protected by the KoiVM virtualizer. Despite the fact that\nmost of the IL code is virtualized, we can still spot invocation of P/Invoke defined method CreateProcess that is\nused in a way to create a process in a suspended state – typically used for code injection technique “Process\n**_Hollowing”._**\n\n\n-----\n\nFigure 34: Creation of suspended process as a part of the Process Hollowing technique\nAfter investigating more what was left lying around in .NET metadata, specifically in the ImplMap table, to find out\nwhat other methods are defined as P/Invoke and very likely used by this sample, we are getting surprisingly even\nmore exciting findings than in the case of the older version of dotRunpeX. Apparently, the sample will perform not\njust code injection but also loading and communicating with the driver.\n\nFigure 35: The ImplMap table – the new version of the dotRunpeX\n\n\n-----\n\nThe next that we immediately noticed is the usage of the same resource name as in the case of the older version\n```\nBIDEN_HARRIS_PERFECT_ASSHOLE – that contains an encrypted payload to be injected. The resource name was\n\n```\nconsistent across all samples we analyzed. Obviously, the decryption routine is hidden behind the code\nvirtualization, but an educative guess will lead us to a simple XOR decryption routine using a password expressing\nthe secret desires of the author – I_LOVE_HENTAIU2.\n\nFigure 36: Simple XOR decryption of the .NET resource using password “I_LOVE_HENTAIU2”\nUnfortunately, as dotRunpeX is still in high development and adding new features, the latest samples utilizing this\ninjector changed the decryption scheme (no more simple XOR) to omit static extraction of embedded payloads.\n\nAs we pointed out before, the IL code is protected by the KoiVM virtualizer, so to continue with our analysis, we\nneeded to come up with some approach to deal with the protected code and get something meaningful from that in\na reasonable time. First, what came to our mind was to use a publicly available open-source KoiVM de-virtualizer\n[called OldRod. This tool is fully workable for the vanilla version of KoiVM. It is even developed in a way that defeats](https://github.com/Washi1337/OldRod)\nsome simple modifications of the original version of KoiVM (such as signature modifications of the methods\nin VMEntry class or changes in the default #Koi stream name).\n\nUnfortunately for us, we are dealing with a customized version of KoiVM that modified the protector in a way that is\nnot so simple to defeat. The original implementation of KoiVM defines 119 constant variables that are used to\nvirtualize the code. These constants are used to define registers, flags, opcodes, etc. Assigned values of these\nconstants are used for the proper execution of the virtualized code and are also needed for the de-virtualization\nprocess.\n\n\n-----\n\nFigure 37: The original implementation of KoiVM defines 119 constants\nWhen using the vanilla version of KoiVM, the resulting constants appear in the compiled, protected sample inside\nthe Constants class as fields in the exact same order with ascending values of tokens. The order of constants and\ntheir corresponding tokens inside the compiled binary is something OldRod depends on.\n\nFigure 38: The OldRod source code – automatic detection of constants\nAlthough the OldRod tool is an absolute masterpiece and can deal with a custom order of constants when providing\na custom constants mapping via configuration file (--config option), finding out the correct mapping of those\nconstants could not be as simple as it sounds. Sometimes when a constant’s order is handmade change, it could\nbe not so hard to map them correctly by analyzing their usage in code. Unfortunately, in the case of dotRunpeX, we\ncan immediately see that values of those constants are affected by runtime arithmetic assignments (no problem to\ndefeat this programmatically), but even worse is that they are scrambled in a very effective way that makes the\ncorrect mapping hard enough to consider this approach as not usable for getting some results in a reasonable time.\n\n\n-----\n\nFigure 39: Runtime arithmetic assignments of scrambled constants\nEven though we pointed out several facts about the extreme hardness of devirtualization, with precise code\nanalysis and some hard moments during the constants mapping via their appropriate handlers, we were able to\nfully devirtualize the code. Despite the fully devirtualized code, we were still left with a non-fully runnable .NET\nAssembly that was still obfuscated with ConfuserEx obfuscator. To continue our madness, we were able to get rid\nof this obfuscation too.\n\nTo give a little spoiler about the functionality of the dotRunpeX injector and its use of procexp driver, fully\ndevirtualized and deobfuscated code related to driver routines can be seen below.\n\nDriver loading/unloading:\n\nFigure 40: Devirtualized and deobfuscated code responsible for loading/unloading the driver\nCommunication with procexp device:\n\n\n-----\n\nFigure 41: Devirtualized and deobfuscated code responsible for communication with procexp device\nThe process of devirtualization and deobfuscation is a subject to consider for its own blog post and won’t be\ncovered further.\n\nNormally, when it is impossible to devirtualize the code in a reasonable time, we are still left with few other options.\nThe first of the options, quite a common approach when dealing with virtualized code, is to go with dynamic\nanalysis using a debugger, DBI (Dynamic Binary Instrumentation), hooking, and WIN API tracing. As we are\ndealing with dotnet code, another approach to come out with could be some PoC using some knowledge from the\n.NET internals world. As researchers who love to bring something new to the community, we decided to combine\nboth of these approaches, which resulted in developing new tools that were approved to be very effective.\n\n[To get more information about the code functionality, we started with the dynamic analysis approach using x64dbg.](https://x64dbg.com/)\nAs we pointed out before, the ImplMap table containing P/Invoke-defined methods seems to be a good starting\npoint for setting breakpoints in the debugger. Automating the process of parsing out the P/Invoke defined methods\nand converting it to x64dbg script leads us to the first tool we developed, called “ImplMap2x64dbg”.\n\n### ImplMap2x64dbg\n\nPython script that uses [dnfile module to properly parse .NET executable files and their metadata. This tool creates](https://github.com/malwarefrank/dnfile)\nan x64dbg script for setting breakpoints on defined ImplMap (P/Invoke) methods of the .NET executable. This script\ncan be downloaded in the last section of the article.\n\n\n-----\n\n```\n p, y,\ndef Main():\n\n  if(len(sys.argv) != 2 or sys.argv[1] == '-h' or sys.argv[1] == '--help'):\n\n    print(\"Description: Creates x64dbg script for setting breakpoints on defined ImplMap (PInvoke)\nmethods of .NET executable\")\n\n    print(f\"Usage: {os.path.basename(sys.argv[0])} <filepath>\\n\")\n\n    sys.exit()\n\n  file_path = sys.argv[1]\n\n  script_path = file_path + \"_x64dbg.txt\"\n\n  dn_file = dnfile.dnPE(file_path)\n\n  if(dn_file.net is None or dn_file.net.metadata is None):\n\n    print(f\"{sys.argv[1]} is NOT a .NET executable !!!\\n\")\n\n    sys.exit()\n\n  if(dn_file.net.mdtables.ImplMap is None):\n\n    print(f\".NET executable '{sys.argv[1]}' has NO ImplMap !!!\\n\")\n\n    sys.exit()\n\n  # Getting all ImplMap methods and module scope\n\n  implmap_table = dn_file.net.mdtables.ImplMap.rows\n\n  implmap_modules = []\n\n  implmap_methods = []\n\n  [implmap_modules.append(row.ImportScope.row.Name.lower().replace(\".dll\", \"\")) for row in implmap_table\nif (row.ImportScope.row.Name.lower().replace(\".dll\", \"\") not in implmap_modules)]\n\n  [implmap_methods.append(row.ImportName) for row in implmap_table if (row.ImportName not in\nimplmap_methods)]\n\n  # Creation of x64dbg script\n\n  x64dbg_script = \"; Replace charset depending APIs - ex. CreateProcess -> CreateProcessA or\nCreateProcessW !!!\\n\"\n\n  for module in implmap_modules:\n\n    x64dbg_script += f\"loadlib {module}\\n\"\n\n  for method in implmap_methods:\n\n    x64dbg_script += f\"SetBPX {method}\\n\"\n\n  with open(script_path, \"wt\",encoding=\"utf-8\") as f_scr:f_scr.write(x64dbg_script)\n\n  print(f\"x64dbg script created: '{script_path}'\")\n\nif __name__ == '__main__':\n\n  Main()\n\n```\nProcessing our dotRunpeX sample with “ImplMap2x64dbg” will result in the x64dbg script:\n\n\n-----\n\n```\n; p p g\nloadlib kernel32\n\nloadlib ntdll\n\nloadlib user32\n\nloadlib advapi32\n\nSetBPX VirtualAllocEx\n\nSetBPX CreateProcessA\n\nSetBPX CreateProcessW\n\nSetBPX CreateRemoteThread\n\nSetBPX Wow64SetThreadContext\n\nSetBPX Wow64GetThreadContext\n\nSetBPX NtResumeThread\n\nSetBPX ZwUnmapViewOfSection\n\nSetBPX NtWriteVirtualMemory\n\nSetBPX MessageBoxA\n\nSetBPX MessageBoxW\n\nSetBPX GetModuleHandleA\n\nSetBPX GetModuleHandleW\n\nSetBPX FindWindowA\n\nSetBPX FindWindowW\n\nSetBPX GetProcAddress\n\nSetBPX GetFileAttributesA\n\nSetBPX GetFileAttributesW\n\nSetBPX ShowWindow\n\nSetBPX SetForegroundWindow\n\nSetBPX Wow64DisableWow64FsRedirection\n\nSetBPX Wow64RevertWow64FsRedirection\n\nSetBPX CreateFileA\n\nSetBPX CreateFileW\n\nSetBPX RtlInitUnicodeString\n\nSetBPX NtLoadDriver\n\nSetBPX NtUnloadDriver\n\nSetBPX OpenProcessToken\n\nSetBPX LookupPrivilegeValueA\n\nSetBPX LookupPrivilegeValueW\n\nSetBPX AdjustTokenPrivileges\n\nSetBPX CloseHandle\n\nSetBPX NtQuerySystemInformation\n\nSetBPX DeviceIoControl\n\nSetBPX GetProcessHeap\n\nSetBPX HeapFree\n\nSetBPX HeapAlloc\n\nSetBPX RtlCopyMemory\n\n```\nWe focused mainly on certain WIN/NT APIs such as CreateProcessW, NtWriteVirtualMemory,CreateFileA,\n```\nCreateFileW, NtLoadDriver, NtQuerySystemInformation, and DeviceIoControl as they are the interesting ones\n\n```\nrelated to driver and process injection routines.\n\nThe first interesting WIN API call we can see is CreateFileW which is used to create a file in\npath C:\\Users\\XXX\\AppData\\Local\\Temp\\Иисус.sys.\n\n\n-----\n\nFigure 42: CreateFileW used to create a file “Иисус.sys”\nIf we check the created file Иисус.sys (from the Russian language translated as “jesus.sys”), we will immediately\nfind out it is a valid Process Explorer driver, version 16.43.\n\nFigure 43: Created file “Иисус.sys” is a valid Process Explorer driver, version 16.43\nWe can see routine NtLoadDriver responsible for loading this driver where the argument points\nto DriverServiceName – \\Registry\\Machine\\System\\CurrentControlSet\\Services\\TaskKill that specifies a\npath to the driver’s registry key.\n\n\n-----\n\nFigure 44: NtLoadDriver used to load procexp driver via its associated registry key\n\nFigure 45: Content of the driver’s registry key “\\Registry\\Machine\\System\\CurrentControlSet\\Services\\TaskKill”\nConnecting to the process explorer device follows.\n\nFigure 46: Obtaining the handle of the process explorer device\nOne of the dotRunpeX AV-evasion techniques is killing a hardcoded list of Anti-Malware services with the help of a\nprocess explorer driver (procexp.sys). The reason behind the usage of process explorer driver is that the Anti[Malware service usually runs as a protected process, more specifically as PPL, to avoid disabling protection on the](https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-)\nsystem caused by malicious activity. It is possible to abuse vulnerable versions of the procexp driver to close object\nhandles of the protected process. Once enough handles are closed, the specific protected process will be killed. All\nsamples we analyzed were abusing version 16.43 of this driver which is also the latest version vulnerable to this\ntechnique.\n\nTo obtain information about object handles, dotRunpeX uses NT API NtQuerySystemInformation with\nspecified SystemInformationClass 0x10 that points to the undocumented\n[structure [SYSTEM_HANDLE_INFORMATION]. This way, it finds all handles that belong to the protected process.](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/handle.htm?tx=56))\n\nFigure 47: NtQuerySystemInformation used to obtain undocumented structure SYSTEM_HANDLE_INFORMATION\n\n\n-----\n\nTo process object handles of protected process, dotRunpeX uses WIN API DeviceIoControl to send IOCTL\ndirectly to the vulnerable procexp driver. The IOCTL “2201288708” (IOCTL_CLOSE_HANDLE) is in RDX register, and\nprocexp driver routine processing this request is responsible for closing certain object handle of the specified\nprocess, regardless of whether the specified process is protected or not. Once enough object handles are closed,\nthe Anti-Malware service is killed.\n\nFigure 48: DeviceIoControl used to send the IOCTL “2201288708” to close the object handle of the protected\nprocess\nWe could also see that register R8 (lpInBuffer) points to data required to close the object handle. This data\nstructure could be defined as follows:\n```\ntypedef struct _ioControl\n\n{\n\n  ULONGLONG ulPID;\n\n  PVOID lpObjectAddress;\n\n  ULONGLONG ulSize;\n\n  ULONGLONG ulHandle;\n\n} PROCEXP_DATA_EXCHANGE, *PPROCEXP_DATA_EXCHANGE;\n\n```\nLet’s compare the procexp driver version used by all samples of dotRunpeX (version 16.43 – compiled 2021-08-17)\nand the latest version of the procexp driver (version 17.02 – compiled 2022-11-10). We can immediately spot the\nadded patching code that is responsible for disabling the possibility of closing object handles of protected\nprocesses.\n\nFigure 49: Process Explorer driver version 16.43 vs. 17.02\n\n\n-----\n\nThis technique of closing object handles of protected processes using the process explorer driver is well\n[documented and part of an open-source project called Backstab. Process explorer drivers version 17.0+ are](https://github.com/Yaxser/Backstab)\nalready patched.\n\nAfter killing specific protected processes, Process Hollowing is what follows using WIN API CreateProcessW to start\nthe process as suspended (in this case C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe)\nand direct NT API NtWriteVirtualMemory to write embedded payload of dotRunpeX into the newly created remote\nprocess.\n\nIt turned out that with an approach of dynamic analysis that focused on the native layer and certain usage of\nWIN/NT APIs, we got some interesting findings of this virtualized dotnet injector that could be used for automation\nand mass processing:\n\nEach dotRunpeX sample has an embedded payload of a certain malware family to be injected\nEach dotRunpeX sample has an embedded procexp driver to kill protected processes\nThere is very likely some kind of config hidden behind the virtualized code that specifies the target process for\nProcess Hollowing, a protected process list to be killed (Anti-Malware services), and probably other\ninteresting configurable things.\n\nEncouraged by these findings, we can move forward to some automation using knowledge from the .NET internals\nworld. When we are talking about dotnet, we can immediately think of code being managed by .NET runtime. More\nthings are being managed, and among them is one very important for our further process, and that is so-called\n“Memory Management”. The types of memory in dotnet are stack and .NET heap. In the dotnet world, we do not\nneed to bother with memory allocation/deallocation because these routines are handled by .NET runtime and\ngarbage collector. Memory management of dotnet somehow needs to know what to allocate, where, and how; the\nsame goes for deallocation/freeing of memory. Allocation on the .NET heap occurs once we talk about reference\ntypes inheriting from System.Object (class, object, string…). These objects are saved on the .NET heap, and for\nthe purpose of their automatic management, they are accompanied by certain metadata information such as their\ntype, references, and size. Even better, the automatic memory deallocation of no longer referenced objects does\nnot occur immediately – the garbage collector takes care of this in some time intervals, which could be several\nminutes. Particular objects like “static objects” survive garbage collections and live till the application ends.\n\nThis means that if we could enumerate objects on the .NET heap, we could also get information related to their\ntypes and size that can serve for their appropriate reconstruction. Creating this kind of tool would be very likely\ntime-consuming, but luckily for us, there is already created dotnet process and crash dump introspection open[source library ClrMD Microsoft.Diagnostics.Runtime developed by Microsoft that could be used precisely for](https://github.com/microsoft/clrmd)\nobject reconstruction from .NET heap. Why is that so important?\n\nIn a certain moment of dotRunpeX execution, embedded payload, procexp driver, and some kind of config must\nappear in a decrypted state. Their content will likely be assigned to some object allocated on the .NET heap. For\nthese, we could expect byte array byte[] or string. That also means that if we could control the execution of\ndotRunpeX and suspend it in a state we assume to be the right moment for those object reconstructions, we would\nbe able to get all that we need in a decrypted state.\n\nOne of the right moments for suspending and introspecting the dotRunpeX process could be an invocation of WIN\nAPI CreateProcessW used for Process Hollowing. This was approved to be the correct assumption and led us to\ndevelop the hooking library “CProcessW_Hook” exactly for this purpose.\n\n## CProcessW_Hook\n\n[Native hooking library using minhook framework (The Minimalistic x86/x64 API Hooking Library for Windows). The](https://github.com/TsudaKageyu/minhook)\ncode provided below serves the purpose of hooking the WIN API function CreateProcessW, which is used in the\ndotRunpeX injector for process creation that is later used as a target for code injection (PE Hollowing). Once\n\n\n-----\n\nthe CreateProcessW function is hooked and called in the target process, the whole process gets suspended to\nintrospect. Certain process creations are filtered (powershell, conhost) as they can be spawned for other\nfunctionalities of dotRunpeX according to config (example modification of Windows Defender settings). We need to\nsuspend the process only in a state before performing code injection (where all required objects are already\ndecrypted on the .NET heap).\n\n\n-----\n\n```\n#include <string.h>\n\n#include \"pch.h\"\n\n#include \"MinHook.h\"\n\n#pragma warning(disable : 4996)\n\n#if defined _M_X64\n\n#pragma comment(lib, \"libMinHook.x64.lib\")\n\n#elif defined _M_IX86\n\n#pragma comment(lib, \"libMinHook.x86.lib\")\n\n#endif\n\ntypedef LONG (__stdcall* NTSUSPENDPROCESS)(HANDLE ProcessHandle);\n\ntypedef BOOL (__stdcall* CREATEPROCESSW)(LPCWSTR, LPCWSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES,\nBOOL, DWORD, LPVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION);\n\nCREATEPROCESSW fpCreateProcessW = NULL;\n\n__declspec(dllexport) void __cdecl Decoy()\n\n{\n\n  Sleep(1000);\n\n}\n\nint __stdcall DetourCreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES\nlpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD\ndwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo,\nLPPROCESS_INFORMATION lpProcessInformation)\n\n{\n\n  LPCWSTR ignoredProcess[2] = { L\"powershell\", L\"conhost\" };\n\n  for (int i = 0; i < 2; i++)\n\n  {\n\n    if (wcsstr(_wcslwr(lpApplicationName), ignoredProcess[i]))\n\n    {\n\n      return fpCreateProcessW(lpApplicationName, lpCommandLine, lpProcessAttributes,\nlpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,\nlpProcessInformation);\n\n    }\n\n  }\n\n  HMODULE hNtdll = GetModuleHandleA(\"ntdll.dll\");\n\n  if (!hNtdll)\n\n  {\n\n    ExitProcess(0);\n\n  }\n\n  NTSUSPENDPROCESS NtSuspendProcess = (NTSUSPENDPROCESS)GetProcAddress(hNtdll, \"NtSuspendProcess\");\n\n  if (!NtSuspendProcess)\n\n  {\n\n    CloseHandle(hNtdll);\n\n    ExitProcess(0);\n\n  }\n\n  HMODULE cProcess = GetCurrentProcess();\n\n  if (!cProcess)\n\n  {\n\n    CloseHandle(hNtdll);\n\n    ExitProcess(0);\n\n  }\n\n  NtSuspendProcess(cProcess);\n\n  ExitProcess(0);\n\n  return 1;\n\n}\n\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)\n\n{\n\n```\n\n-----\n\n```\n       ( _ _ _ )\n  {\n\n    case DLL_PROCESS_ATTACH:\n\n      if (MH_Initialize() != MH_OK)\n\n      {\n\n        return 1;\n\n      }\n\n      if (MH_CreateHook(&CreateProcessW, &DetourCreateProcessW, (LPVOID*)(&fpCreateProcessW)) !=\nMH_OK)\n\n      {\n\n        return 1;\n\n      }\n\n      if (MH_EnableHook(&CreateProcessW) != MH_OK)\n\n      {\n\n        return 1;\n\n      }\n\n    case DLL_THREAD_ATTACH:\n\n    case DLL_THREAD_DETACH:\n\n    case DLL_PROCESS_DETACH:\n\n      break;\n\n  }\n\n  return TRUE;\n\n}\n\n```\nWe could see that all hooking logic is executed right upon loading this library inside the function DllMain().\nAnother important thing to note is that we defined the export function Decoy(), which won’t be ever executed or\ncalled but is needed later on for our preinjection technique.\n\nWith the hooking library “CProcessW_Hook.dll” in its place, we can move on to create an injector and extractor.\nThis points to the main tool provided below – dotRunpeX extractor “Invoke-DotRunpeXextract”.\n\n## Invoke-DotRunpeXextract\n\nPowerShell module that enables the extraction of payload, procexp driver, and config from dotRunpeX. The tool is\nwritten in PowerShell scripting language using preinjection of native hooking library “CProcessW_Hook.dll”\n(using [AsmResolver) and .NET objects reconstruction from .NET heap (using ClrMD). It uses a dynamic approach](https://github.com/Washi1337/AsmResolver)\nfor extraction, so samples are executed in a managed way (use only in VM). Using PowerShell 7.3+, clrMD\nv2.2.343001 (net6.0), AsmResolver v5.0.0 (net6.0).\n\nWe provide two versions of this tool that can be downloaded along with the hooking library in the last section of this\narticle. One is created multi-threaded as a PowerShell module for the best performance and usage. The second\nversion of this tool is a single-threaded script with the same functionality that could be used for simple debugging\nand troubleshooting and can more easily serve to create several snippets with similar functionality.\n\nThe whole code of this PowerShell module is annotated and commented on in a way to be easy to understand its\ncore features. We will briefly describe the core functionality of this tool, like the preinjection technique of the\nhooking library using AsmResolver and implemented logic behind the extraction.\n\nAt first, this tool modifies the PE structure of dotRunpeX using AsmResolver. AsmResolver is well known for its\ncapability to inspect dotnet executables and their related metadata, but it also allows access to low-level structures\nof PE to modify them. These PE structure modifications are used to implement our so-called PoC technique for the\npurpose of dll preinjection to a 64-bit dotnet executable. We are talking about adding a new import entry for the\nnative hooking library into the .NET Assembly. Since dotRunpeX is a 64-bit executable, and it turned out that,\nunlike the 32-bit dotnet executables, the 64-bit ones don’t even have an import directory, we started building one\nfrom scratch right inside the function PatchBinaryWithDllInjection(). In this function, we can see that we are\ncreating new data sections, .idata and .data, where our newly built IDT (Import Directory Table) and IAT\n(Import Address Table) will be placed. To get our hooking library “CProcessW_Hook.dll” preinjected right upon\n\n\n-----\n\nprocess start and let the windows loader do for us the hard work, we are creating an import entry with exported\nfunction Decoy() that was defined in the hooking library. As we are dealing with dotnet and adding native import, IL\n**Only flag inside the .NET Directory is not true anymore and needs to be patched.**\n```\nfunction PatchBinaryWithDllInjection($pathToSample, $patchedSample, $dllHookingName)\n\n{\n\n  # Exported function name \"Decoy\" from hooking library will be used for Import Directory creation\n\n  $symbolNameToImport = [AsmResolver.PE.PEImage]::FromFile($dllHookingName).Exports.Entries[0].Name #\nDecoy\n\n  # We need to work with pefile layer to expose sections - creation of Import Directory and IAT\n\n  $pefile = [AsmResolver.PE.File.PEFile]::FromFile($pathToSample)\n\n  # Creation of Import Directory from scratch\n\n  $impDirBuff = [AsmResolver.PE.Imports.Builder.ImportDirectoryBuffer]::new($false)\n\n  $impModule = [AsmResolver.PE.Imports.ImportedModule]::new($dllHookingName)\n\n  $symbol = [AsmResolver.PE.Imports.ImportedSymbol]::new(0,$symbolNameToImport)\n\n  $impModule.Symbols.Add($symbol)\n\n  $impDirBuff.AddModule($impModule)\n\n  # Creation of \".idata\" section where Import Directory will be placed\n\n  $idataSection = [AsmResolver.PE.File.PESection]::new(\".idata\",\n[AsmResolver.PE.File.Headers.SectionFlags]::MemoryRead -bor\n[AsmResolver.PE.File.Headers.SectionFlags]::ContentInitializedData)\n\n  $idataSection.Contents = $impDirBuff\n\n  $pefile.Sections.Add($idataSection)\n\n  # Creation of \".data\" section where IAT will be placed\n\n  $dataSection = [AsmResolver.PE.File.PESection]::new(\".data\",\n[AsmResolver.PE.File.Headers.SectionFlags]::MemoryRead -bor\n[AsmResolver.PE.File.Headers.SectionFlags]::MemoryWrite -bor\n[AsmResolver.PE.File.Headers.SectionFlags]::ContentInitializedData)\n\n  $dataSection.Contents = $impDirBuff.ImportAddressDirectory\n\n  $pefile.Sections.Add($dataSection)\n\n  # Remove ASLR (no reloc)\n\n  $pefile.OptionalHeader.DllCharacteristics = $pefile.OptionalHeader.DllCharacteristics -bxor\n[AsmResolver.PE.File.Headers.DllCharacteristics]::DynamicBase\n\n  # Update offsets and RVA of newly created data sections (so we can work with them later on)\n\n  $pefile.UpdateHeaders()\n\n  # Update info about new data directories in context of pefile - Import Directory, IAT\n\n$pefile.OptionalHeader.DataDirectories[[AsmResolver.PE.File.Headers.DataDirectoryIndex]::ImportDirectory]\n= [AsmResolver.PE.File.Headers.DataDirectory]::new($idataSection.Rva, $idataSection.GetPhysicalSize())\n\n  $pefile.OptionalHeader.DataDirectories[[AsmResolver.PE.File.Headers.DataDirectoryIndex]::IatDirectory]\n= [AsmResolver.PE.File.Headers.DataDirectory]::new($dataSection.Rva, $dataSection.GetPhysicalSize())\n\n  $pefile.Write($patchedSample)\n\n  # We need to do some custom patching of IL only flag inside .NET Directory (it is easier than making\ncustom writer preserving all PE sections and meta) - we are adding native imports so IL only is not true\nanymore\n\n  $dotnetDirectoryRVA =\n$pefile.OptionalHeader.DataDirectories[[AsmResolver.PE.File.Headers.DataDirectoryIndex]::ClrDirectory].Virt\n\n  $dotnetDirectoryFileOffset = $pefile.RvaToFileOffset($dotnetDirectoryRVA)\n\n  $dotnetDirectoryILFlagsFileOffset = $dotnetDirectoryFileOffset + 16\n\n  $filestream = [System.IO.FileStream]::new($patchedSample, [System.IO.FileMode]::Open,\n[System.IO.FileAccess]::ReadWrite)\n\n  $filestream.Position = $dotnetDirectoryILFlagsFileOffset\n\n  $filestream.Write([byte[]]::new(4), 0, 4) # Wipe the IL only flags\n\n  $filestream.Close() \n\n}\n\n```\n\n-----\n\nA comparison of the dotRunpeX sample before and after the described modification of the PE structure can be\nseen in the picture below.\n\nFigure 50: PE structure of the dotRunpeX sample before and after modification used for dll preinjection\nNow, we get to the state where our modified binary could be executed. With the hooking library in its place, the\ndotRunpeX process gets suspended right during the call to WIN API CreateProcessW. This exact routine is\nimplemented in the function StartProcessWaitSuspended().\n```\nfunction StartProcessWaitSuspended($patchedSample)\n\n{\n\n  $process = [System.Diagnostics.Process]::Start($patchedSample)\n\n  while ($process.Threads.Where{$_.ThreadState -ne [System.Diagnostics.ThreadState]::Wait -and\n$_.WaitReason -ne [System.Diagnostics.ThreadWaitReason]::Suspended})\n\n  {\n\n    Start-Sleep -Milliseconds 500\n\n    $process.Refresh()\n\n  }\n\n  return $process \n\n}\n\n```\nOnce the process is suspended, it is ready to be introspected. The whole logic behind the introspection of the\ndotRunpeX process can be seen in the function GetPayloadAndConfig(). In this function, we use the clrMD library\nto attach to the desired process and enumerate all System.Byte[] objects that are currently allocated on the .NET\nheap. To reconstruct the payload intended to be injected, we have implemented some dummy logic to find byte\narray objects larger than 1KB and starting with the “MZ” header. Despite the fact how it sounds, it has proven to be\nenough to fulfill our needs.\n\nThe logic behind finding the object corresponding to the process explorer driver and config is slightly different. First\nof all, the procexp driver and constants related to the config are saved in the same object. We assume that this is a\nresult of the combination of usage KoiVM virtualizer and ConfuserEx obfuscator together as ConfuserEx usually\nputs defined constants to one blob of byte array and resolves them during the runtime once they are needed. After\nthe logic finds this kind of byte blob, it separates the process explorer driver and config and pushes the config for\nfurther processing.\n\n\n-----\n\n```\n        y g( p )\n{  # DataTarget is our suspended process\n\n  $dataTarget = [Microsoft.Diagnostics.Runtime.DataTarget]::AttachToProcess($process.Id, $false) \n\n  Start-Sleep -Seconds 1 # Better to wait for ClrMD - to properly initialize DataTarget\n\n  $clrInfo = $dataTarget.ClrVersions[0]\n\n  $clrRuntime = $clrInfo.CreateRuntime()\n\n  # Getting all byte array objects from .NET Heap and sort them by size descending\n\n  $objects = $clrRuntime.Heap.EnumerateObjects().ToArray().Where{$_.Type.Name -eq \"System.Byte[]\"} |\nSort-Object -Property Size -Descending\n\n  # Find payload to be injected - should be the largest byte array containing PE\n\n  $payload = @()\n\n  foreach ($object in $objects)\n\n  { \n\n    # Check if byte array possible valid PE\n\n    if($object.AsArray().Length -gt 1024)\n\n    {\n\n      if((Compare-Object ($object.AsArray().ReadValues[byte](0,2)) ([byte[]] 0x4d,0x5a)).Length -eq\n0)\n      {\n\n        $payload = $object.AsArray().ReadValues[byte](0, $object.AsArray().Length)\n\n        break\n\n      }\n\n    }\n\n  }\n\n  if(-not $payload){Write-Host \"Payload to be injected NOT found in\nsample:\"$process.MainModule.ModuleName\"!!!\" -ForegroundColor Red}\n\n  # Find procexp driver + config (first 8 bytes of byte array skipped -> should be related to procexp PE\nsize)\n\n  $procexpAndConfig = @()\n\n  foreach ($object in $objects)\n\n  { \n\n    # Check if byte array possible procexp PE and config\n\n    if($object.AsArray().Length -gt 1024)\n\n    {\n\n      if((Compare-Object ($object.AsArray().ReadValues[byte](8,2)) ([byte[]] 0x4d,0x5a)).Length -eq\n0)\n      {\n\n        $procexpAndConfig = $object.AsArray().ReadValues[byte](0, $object.AsArray().Length)\n\n        break\n\n      }\n\n    }\n\n  }\n\n  if(-not $procexpAndConfig)\n\n  {\n\n    Write-Host \"Procexp driver + config NOT found in sample:\"$process.MainModule.ModuleName\"!!!\" ForegroundColor Red\n\n    $procexp = $null\n\n    $config = $null\n\n    return $payload, $procexp, $config\n\n  } \n\n  # Process procexp and config\n\n  $procexpSize = [bitconverter]::ToInt32($procexpAndConfig[4..7], 0)\n\n  $procexp = $procexpAndConfig[8..($procexpSize+7)]\n\n  $config = $procexpAndConfig[($procexpSize +8)..$procexpAndConfig.Length]\n\n  return $payload, $procexp, $config\n\n}\n\n```\nThe so-called config is actually a bunch of constants where some of them serve as a configuration of dotRunpeX.\nThis config needs to be parsed in the function ParseConfig() as it appears to be in some kind of structure where\nevery string is preceded with its length and if needed, padded to have length divisible by 4, as shown in the picture\n\n\n-----\n\nbelow.\n\nFigure 51: Unparsed config structure\n```\nfunction ParseConfig($config)\n\n{\n\n  $memStream = [System.IO.MemoryStream]::new($config, $true)\n\n  $strLength = [byte[]]::new(4)\n\n  $parsedConfig = \"\"\n\n  while ($memStream.Position -lt $memStream.Length)\n\n  {\n\n    $memStream.Read($strLength, 0, 4) | Out-Null\n\n    $length = [bitconverter]::ToInt32($strLength, 0)\n\n    $buffer = [byte[]]::new($length)\n\n    $memStream.Read($buffer, 0, $length) | Out-Null\n\n    $parsedConfig += [System.Text.Encoding]::UTF8.GetString($buffer) + \"`n\"\n\n    if(($memStream.Position % 4) -ne 0)\n\n    {\n\n      $memStream.Position += 4 - ($memStream.Position % 4)\n\n    }\n\n  }\n\n  $memStream.Close()\n\n  return $parsedConfig\n\n}\n\n```\nOnce we have properly parsed the config, it is saved with extracted payload and process explorer driver, the\nsuspended process gets killed, and the modified dotRunpeX sample is removed.\n\nExample execution of “Invoke-DotRunpeXextract” and mass processing of samples could be seen below (2min\nGIF):\n\n\n-----\n\nFigure 52: Execution of “Invoke-DotRunpeXextract” (2min GIF)\n\nAs pointed out before, “Invoke-DotRunpeXextract” will produce a payload to be injected, procexp driver, and\nparsed constants values where some of them could be referred to as config. Example config file content for our\nanalyzed sample of the dotRunpeX:\n\n\n-----\n\n```\nTrue\n\nSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n\nC14615024653444192E5F79157E215D3\n\n\"\n\nI_LOVE_HENTAIU2\n\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe\n\nError\n\n2345RTProtect\n\n2345SafeCenterSvc\n\n2345SafeSvc\n\n2345SafeTray\n\nkxetray\n\nkxescore\n\nkxemain\n\nkwsprotect64\n\nkscan\n\nHipsTray\n\nHipsDaemon\n\n360sd\n\n360rp\n\nQQPCTray\n\nQQPCRTP\n\n360tray\n\n360leakfixer\n\n360Safe\n\nZhuDongFangYu\n\nMultiTip\n\nAvastSvc\n\nsched\n\navp\n\nMcSvHost\n\navconfig\n\nbdagent\n\nMsMpEng\n\nwireshark\n\nMpCmdRun\n\nndd32\n\nnod32\n\nnod32krn\n\neguiProxy\n\nekrn\n\nSoftware\\Classes\\ms-settings\\shell\\open\\command\n\nDelegateExecute\n\ncmd.exe\n\n/C computerdefaults.exe\n\nRun without emulation\n\nSelect * from Win32_ComputerSystem\n\nManufacturer\n\nmicrosoft corporation\n\nModel\n\nVIRTUAL\n\nvmware\n\nVirtualBox\n\nThis file can't run into Virtual Machines.\n\nroot\\CIMV2\n\nSELECT * FROM Win32_VideoController\n\nName\n\nVMware\n\nVBox\n\nRun using valid operating system\n\nSbieDll.dll\n\nUSER\n\nSANDBOX\n\n```\n\n-----\n\n```\nMALWARE\n\nSCHMIDTI\n\nCURRENTUSER\n\n\\VIRUS\n\nSAMPLE\n\nC:ile.exe\n\nAfx:400000:0\n\nHARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0\n\nIdentifier\n\nVBOX\n\nHARDWARE\\Description\\System\n\nSystemBiosVersion\n\nVideoBiosVersion\n\nVIRTUALBOX\n\nSOFTWARE\\Oracle\\VirtualBox Guest Additions\n\nnoValueButYesKey\n\nC:\\WINDOWS\\system32\\drivers\\VBoxMouse.sys\n\nVMWARE\n\nSOFTWARE\\VMware, Inc.\\VMware Tools\n\nHARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 1\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0\n\nHARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 2\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0\n\nSYSTEM\\ControlSet001\\Services\\Disk\\Enum\n\n0\n\nSYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\n\nDriverDesc\n\nSYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\Settings\n\nDevice Description\n\nInstallPath\n\nC:\\PROGRAM FILES\\VMWARE\\VMWARE TOOLS\\\n\nC:\\WINDOWS\\system32\\drivers\\vmmouse.sys\n\nC:\\WINDOWS\\system32\\drivers\\vmhgfs.sys\n\nkernel32.dll\n\nwine_get_unix_file_name\n\nQEMU\n\n\\\\.\\ROOT\\cimv2\n\nDescription\n\nVM Additions S3 Trio32/64\n\nS3 Trio32/64\n\nVirtualBox Graphics Adapter\n\nVMware SVGA II\n\nnoKey\n\nFatal 'Error\n\nC:\\windows\\system32\\cmd.exe\n\n/K \"fodhelper.exe\"\n\nC:\\windows\\temp\n\n\\\n\n.inf\n\nREPLACE_COMMAND_LINE\n\n/au\n\ncmstp\n\n{ENTER}\n\n[version]\n\nSignature=$chicago$\n\nAdvancedINF=2.5\n\n[DefaultInstall]\n\nCustomDestination=CustInstDestSectionAllUsers\n\nRunPreSetupCommands=RunPreSetupCommandsSection\n\n[RunPreSetupCommandsSection]\n\n; Commands Here will be run Before Setup Begins to install\n\nREPLACE_COMMAND_LINE\n\ntaskkill /IM cmstp.exe /F\n\n[CustInstDestSectionAllUsers]\n\n49000,49001=AllUSer_LDIDSection, 7\n\n```\n\n-----\n\n```\n[ _ ]\n\"HKLM\", \"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMMGR32.EXE\", \"ProfileInstallPath\",\n\"%UnexpectedError%\", \"\"\n\n[Strings]\n\nServiceName=\"CorpVPN\"\n\nShortSvcName=\"CorpVPN\"\n\nc:\\windows\\system32\\cmstp.exe\n\nWindows 1\n\nWindows 8\n\nWindows 7\n\nfodhelper\n\nSoftware\\Classes\\exefile\\shell\\open\\command\n\nslui\n\nSoftware\\Classes\\mscfile\\shell\\open\\command\n\neventvwr\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\n\nProductName\n\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Notifications\\Settings\\Windows.SystemToast.Secu\n\nEnabled\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\n\nEnableLUA\n\npowershell\n\nSoftware\\Classes\\Folder\\shell\\open\\command\n\nSOFTWARE\\Microsoft\\Windows Defender\\Exclusions\\Paths\n\nAdd-MpPreference -ExclusionPath \"\n\n\" -Force\n\nИисус.sys\n\n\\Registry\\Machine\\System\\CurrentControlSet\\Services\\TaskKill\n\nSystem\\CurrentControlSet\\Services\\TaskKill\n\n\\??\\\n\nType\n\nErrorControl\n\nStart\n\nImagePath\n\n\\\\.\\\n\nSeDebugPrivilege\n\nSeLoadDriverPrivilege\n\n\\KnownDlls\\\n\nntdll.dll\n\nZwOpenSection\n\nZwMapViewOfSection\n\nNtClose\n\nZwUnmapViewOfSection\n\nMZ\n_4\nBIDEN_HARRIS_PERFECT_ASSHOLE\n\n```\nWe can easily spot configuration strings related to persistence settings, resource name and its decryption key\n(where .NET resource contains payload to be injected), target binary for the payload to be injected in, Anti-Malware\nservice names to be killed, UAC bypass, Anti-VM, Anti-Sandbox, procexp driver installation path and its name, etc.\n\nWe provide two versions of this tool that can process just one sample or mass-process the directory of samples.\nFor the best performance, the multi-threaded PowerShell module is recommended use. Still, for troubleshooting,\nsimple modification, and easy debugging, we are also providing a single-threaded script with the same functionality\nas we expect soon some modification in dotRunpeX code where appropriate changes in the code of the tool or\nhooking library would be needed.\n\n## Conclusion\n\n\n-----\n\nBy monitoring this new threat for several months, we got deep insight into its evolution, delivery methods, and how\nit was abused to deliver a wide scale of different malware families.\n\nOver time, we consider dotRunpeX to be in high development adding new features on regular bases and getting\nmore popularity and attention every day. Because of the rising usage of this injector, we developed and provided\nseveral tools to automate the analysis of this virtualized dotnet code.\n\nSome of the developed tools described in this report introduced PoC methods and can serve for developing other\ntools with similar functionality. We showed how open-source libraries such as AsmResolver and clrMD could be\nused in a real-world example to support the research and to help with the reverse engineering of protected code.\n\nIn this report, we provided an in-depth analysis of both versions of the dotRunpeX injector, the similarities between\nthem, and described the main interesting techniques they use, such as abuse of the vulnerable process explorer\ndriver, code virtualization caused by the usage of KoiVM protector, modification of D/Invoke framework with decoy\nsyscall patching.\n\nOur analysis and conclusions are based on dozens of campaigns we spotted in the wild and hundreds of samples\nthat were mass processed.\n\nBecause of the high development of dotRunpeX, we believe that provided tools would need some modification\nsoon as a reaction to changes in dotRunpeX. Still, with provided source codes, it should be relatively easy to work\naround these changes for other researchers.\n\n**Check Point customers remain protected from the threats described in this blog, including all its**\nvariants. Check Point’s _[Threat Emulation](https://www.checkpoint.com/infinity/zero-day-protection/)_ _protects networks against unknown threats in web downloads and e-mail_\n_attachments. The Threat Emulation engine picks up malware at the initial phase before it enters the network. The_\n_engine quickly quarantines and runs the files in a virtual sandbox environment, which imitates a standard operating_\n_system, to discover malicious behavior at the exploit phase._\n\n_[Harmony Email & Office deploys between the inbox and its native security. The solution secures inbound,](https://www.checkpoint.com/harmony/anti-phishing/)_\n_outbound, and internal email from phishing attacks that evade platform-provided solutions and email gateways. It_\n_works with these other solutions and doesn’t require any MX record changes that broadcast security protocols to_\n_hackers._\n\n## IOCs\n\n\n**SHA256 Hash** **Version**\n\n\n**Malware family of**\n**embedded payload**\n\n\n1e7614f757d40a2f5e2f4bd5597d04878768a9c01aa5f9f23d6c87660f7f0fbc OLD Lokibot\n\n68ae2ee5ed7e793c1a49cbf1b0dd7f5a3de9cb783b51b0953880994a79037326 OLD Lokibot\n\n317e6817bba0f54e1547dd9acf24ee17a4cda1b97328cc69dc1ec16e11c258fc OLD Redline\n\n65cac67ed2a084beff373d6aba6f914b8cba0caceda254a857def1df12f5154b OLD SnakeKeylogger\n\n81763d8e3b42d07d76b0a74eda4e759981971635d62072c8da91251fc849b91e OLD SnakeKeylogger\n\n0e11704fcc3c36832ba98b80ea44a3013660d1ed3fb48158b982fed9f9050391 NEW AgentTesla\n\n0f9e27ec1ed021fd7375ca46f233c06b354d12d57aed44132208cd9308bfee11 NEW AgentTesla\n\n881a337aa85a4b01c08706ab941573c5dc9b76ea0e4e1c2693a9b4aa4453ec8c NEW AgentTesla\n\nfeae44d8927dd41feaed997b3dbf7b41933496d6285b79554b83e72ae8a045c4 NEW AgentTesla\n\n\n-----\n\n**SHA256 Hash** **Version**\n\n\n**Malware family of**\n**embedded payload**\n\n\n1c1fcc4133af77f07d0c0299d0320aa9f447748ebead74b429f73c44d950e38b NEW AgentTesla\n\n35c11f7315d2e5d04d783de4314d8cde2def382f1e3fc49ccc555337c54d63cc NEW AgentTesla\n\n4068637c121888476533a3bbb16bec6bc3b4f81f7b9de635ef3576d56dc54c75 NEW AgentTesla\n\n40df5a6e6dcadbe576ce4a8b01cfb82bf3f56a87bae674200e60814eab666c6d NEW AgentTesla\n\n8a0d6e40e545d40956194230f03608859f2a47420a9b11b199142641bc6419ee NEW AgentTesla\n\n7c3803c09a0370aa6484d8ad2f5690b96212d98e45fc8f9cb6022f87dff637fc NEW AgentTesla\n\n93e2ea6f021951369028b73637d9558c8baf3c99d9de1a2a60c1461cb9d571bf NEW AgentTesla\n\nd95298befdde567b31571d16f327840fa0f0dd9c54bf876531820910418a52b6 NEW AgentTesla\n\n149af913afd7eb2773386d14e88a46449cbc9096e0748cfbaa2e061b59525bf0 NEW AgentTesla\n\na73f134ab62a5c23a8c8bafabbfbd5e0408c826ba5418488639724708ec5ef28 NEW AgentTesla\n\naca4d6278f31f374262e0388d16ee6fdcdbbad8257374f1feaabf75b0ec23157 NEW AgentTesla\n\n50451fda27fd8569c7b32bfe82197b82a8637cac928164e1b091a389060e957e NEW AgentTesla\n\n9ed8eeb1db8909c96a958d91213093d2488dc172a8d22ba62657b9bfeb044fec NEW AgentTesla\n\n6c08c0654726c2f793b5191d5e7c74fdf3a2461118a45aa8527a0a30e3f256fd NEW AgentTesla\n\n283cd48dc1368b6852c2f3168bf7a78ad593df010d9a67ed1c938508da5de783 NEW AgentTesla\n\nb019a0535ca7466d7884825542ac6910fe037913118e1136dcac7e9ef3dc0dc9 NEW AgentTesla\n\nb1c9b356c50230629c4697b0527fd7a0fa8d6f0e8342a1eb5b5a4f90d8f0eb86 NEW AgentTesla\n\n5bbd9513f0872d23ca43dd553a63a12882be274fef983fab427721257d60eaec NEW AgentTesla\n\n9d9940b60809e3c10cd4540f8e589626a293244a999bea16c259f9712969a742 NEW AgentTesla\n\ncd4c821e329ec1f7bfe7ecd39a6020867348b722e8c84a05c7eb32f8d5a2f4db NEW AgentTesla\n\ncddf8b8da972cb2e560c70d01366f582445441864fcff884b8194eb6c21a768c NEW AgentTesla\n\n6c367333c677c2268df9deaff6ad4e711e73e53504aa1aa845bebfbfe635f1d2 NEW ArrowRAT\n\n5e3588e8ddebd61c2bd6dab4b87f601bd6a4857b33eb281cb5059c29cfe62b80 NEW AsyncRat\n\n244f2d4f3c34d00babef5f1765e91c0abda9dbd1d131fc93ecb48c91ecc801a8 NEW AsyncRat\n\n95793df9284fe35c0491e5cfa36bc8f49fd426ccdf35f5fe2f098e07d160a4dc NEW AveMaria/WarzoneRAT\n\n55ee7efcb3d1d2e0eac0ecadd651d6a299de82d94347ef9862bc981ae619532b NEW BitRAT\n\n13081992c0ef5c52c2b6224f3ff1ab38160bca9424e7c0470e0c175c920bdc9d NEW Cryptocurrency Stealer\n\n0daef2c2bf086312037ebc91beec0302a7e4d1750f260d02bf815bd13c611559 NEW Downloader\n\n331ad58c524100da7e459e5c3943e970414617f60b3ed0f1a74f3bf189aafea7 NEW Downloader\n\n44a11146173db0663a23787bffbb120f3955bc33e60e73ecc798953e9b34b2f2 NEW Downloader\n\n03fcbab82603df2858f7d6fefdb6ae3cc8e17393af6d44f24634d28fccf3f181 NEW Formbook\n\n\n-----\n\n**SHA256 Hash** **Version**\n\n\n**Malware family of**\n**embedded payload**\n\n\n373a86e36f7e808a1db263b4b49d2428df4a13686da7d77edba7a6dd63790232 NEW Formbook\n\n50ec8a9e59e1bcb0a41477e20f5bb809a80329d56e20cf99e93d756b9e0ceefc NEW Formbook\n\n41ea8f9a9f2a7aeb086dedf8e5855b0409f31e7793cbba615ca0498e47a72636 NEW Formbook\n\n76e129552a30fa5c914d9f946f40b2ec2bbbbeb4e5e2f324e70455725030e157 NEW Formbook\n\n8fa81f6341b342afa40b7dc76dd6e0a1874583d12ea04acf839251cb5ca61591 NEW Formbook\n\nae4f3b6c43d5ea8ee68d862362d4e8d7b317889eb9abead948a9b791ad9d7071 NEW Formbook\n\nb4c876d1797efbef614b44e52482c835c32e8ee020975a30fa2d25ed9cf8aa2b NEW Formbook\n\nd5eda02ff2f05d1e0d06a69018de463ab36497048a1ef2b69af93aa76ccfc07d NEW Formbook\n\nfa3a9fc2adf9d1ca812e0951e21bf72ba3ec9ceb1c0cf0bfc0171b6d4adadf83 NEW Formbook\n\n1f2ffabb3b89e6083ca5de70f5d718295c7a633c2d957da7c4469de059efde2c NEW Formbook\n\nbd133efea4b865f42eb05e0c92e3ab3b58ac087c0682ea9112b96596a7111ff6 NEW Formbook\n\ne6da2d860bd2d0e8b56737b4c8c47cdeea78a404cd0d6fa5a26cbb5ac7682d1d NEW Formbook\n\nd87a200a26d07a64272e93fb3ae8f8d9e4d34bdfedb0cf7c685a6c97912e967f NEW LgoogLoader\n\n7120cf1ad3fdcae7ba6956749a8988e8181837a05948b432cec6ae11229b1d12 NEW LgoogLoader\n\n304847c69875ec59995fbb453f8d1106f80c5eb380ae6b8676e76f5372290194 NEW NetWire\n\n25fbe0ff3274b4bc981fa6ec0459e9b95cec6397194e10ea6287bf4b899a9b07 NEW PrivateLoader\n\n1bc7fc0a4796f7780223b4f0bf8d6816b3721f0b52eedc0df9a32dc4ea4829e8 NEW PrivateLoader\n\n75236a06aadafc69cc5aa8032468869fb868a9a100b687f19c66be03410c2487 NEW PrivateLoader\n\nee0d55b9a2d03c5bea9f69f98b042ab7b3064366f335a8a53096387876bf48d7 NEW PrivateLoader\n\n8de23e90bac05911cbfb6b036c6808ce7c244e4e875cb7edcdb90f75e89e5476 NEW PrivateLoader\n\n10bbfa36ddd8ea6038e2071320ee84f7a9208a5be3a4dda448e83393cdf39a4d NEW PrivateLoader\n\nff72f619907a25f3d99f0c3aa84710c6ff6cb4c3fd8ebad14f85f96c6da49222 NEW PrivateLoader\n\n242e1c82269725c01108e52376be8ddad39ab29da49356d10e527af6d78058f5 NEW PrivateLoader\n\nae4d2054a6e1f9ba2c269eace61aac7259adb0645d18da82779717d83174837d NEW PrivateLoader\n\nbf7b127b1bb81b68439851386cd3d1600bb8b9ec56135e668a88062d913410dd NEW PrivateLoader\n\nb8bb071899ae7bd16a328c0998b3cd40261d61e564ac77f9bf3e495fab0ad267 NEW QuasarRAT\n\n17af8118607b9fc1f7b6aa82fd72f4fc115320d293e103dfe356706bb7c581b7 NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n366284c1a0577937c86744349ac47e6e578da500ada3deb857ff233d9851ee6b NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n3e50f0eaf02d12653d5f757372240adcb5c16a5ab647a667637ba4c50d37aaad NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n\n-----\n\n**SHA256 Hash** **Version**\n\n\n**Malware family of**\n**embedded payload**\n\n\n47849f610a30d72660b1725a0b18d78c5204257b3740641727bdcbfd1ebd466a NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n507f413ac42df115988df498a90fc1ae610cafb66cb30a3a7de53e71ec90e7cd NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n57f261cc442dd9a4f1cd4ffd281c9855f4f9a736abffaf539d9df2a6ea0dd409 NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n76eed1849d0a0474f9e0a58afcda2cc1ea7af316535b4b4b27ff810a162d4f8f NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n855b2e04c323a269d3731c093f0bc80ab3497a69ab8d2967847451a87f04fb0a NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n87134629723b2c6f4d0a74c35fdce89653471d9880b23f4faea6664ae151db0e NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n8bcc23ec881d61839fc57e8ec7425ac5ed625425fbf265fcb53ad73a73825b18 NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n9177ba0c649f08fa6367d04091a7672fedb82215b26e08346645544f0631ebfd NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n9246ed27032429f234888b2713529001344850c608cab9f5ab7274195d330bec NEW RecordBreaker –\nRaccoon Stealer 2.0\n\na487e959e59bc9500c43ac270eaf345eaf28173b07ed7dd82b2495aa19cdab88 NEW RecordBreaker –\nRaccoon Stealer 2.0\n\nada1679a193c9b17b206b3d9ff2a19d64c6c8c5f882a321381c9d5347a8b4b3e NEW RecordBreaker –\nRaccoon Stealer 2.0\n\nc1be6f792bd51d23d848e54cd217bdf9edcbb2b89df741190929f6fa327a10cb NEW RecordBreaker –\nRaccoon Stealer 2.0\n\ndb8ed3e6dd7e6818046e7ee1e9c6c91f98aa5ce3113b14fb1c85a50a45569b18 NEW RecordBreaker –\nRaccoon Stealer 2.0\n\nddae8737d7cc35a87274a26b886e6b48ae947aa849c3d7ecb84de6f6d553aa96 NEW RecordBreaker –\nRaccoon Stealer 2.0\n\nefa9a303af112ffb6737846755e3a995510fd65b6ced9032dc68cd7bbe4c307d NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n20b5c7f210320cf23a63ac7f76086a6e257dd0c248d77deff444cb3dcf624799 NEW RecordBreaker –\nRaccoon Stealer 2.0\n\nf0ee1ddb789207c2000f728f6adabbe344ded7cba0804926a7cfc53bdbbc54eb NEW RecordBreaker –\nRaccoon Stealer 2.0\n\nf440309e372551fb6ee00ecca71a70a1b8b7e077fe61b0687411147b582ab415 NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n21a570237cdacdb8c69679e59c4dba6aa05f123f9db7470ec34e2f4024c3646b NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n4e8bf8c770727a3b0f551adcff2716c941234708e679c868ce42532714a29d27 NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n\n-----\n\n**SHA256 Hash** **Version**\n\n\n**Malware family of**\n**embedded payload**\n\n\n3c0c55b4ce2d90448949980fbca1fa447832f67fb864472551513b6e4eff5304 NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n61b5b6a513be380d50282c1c8391a5362d746bd70506343d04bda3751c3b25de NEW RecordBreaker –\nRaccoon Stealer 2.0\n\na4d455f65bb4d2dde03a0686433b6d515c71b5655fa78b86a4f9bdae503c1295 NEW RecordBreaker –\nRaccoon Stealer 2.0\n\nc9d36fcce70893aa16a846b48009bbd8b46fc11c6821b750083a9c89669038cc NEW RecordBreaker –\nRaccoon Stealer 2.0\n\n04a1021d0880a4f13ed8693dfe65889a5f827fe5ee9369abbc00b58efc40e69b NEW Redline\n\n13eb08dda92356f21888d95a6611a46728dfcefcdf769e7edad1a70e958e5367 NEW Redline\n\n20330ec79f6c6edce8c3d87e3340aebc60f528d3751339e57437b178b9cb914d NEW Redline\n\n22962d59a066795696464868700fa7d3f735bfdb494a7a879fb54668a0ca3d46 NEW Redline\n\n2b1be3ea73921adde804b85e93817869556fa9919bf7a528639a796e27351755 NEW Redline\n\n301be47a8fefa749d904425b43ae459249e2b44ff62051f3a5529d6222259f42 NEW Redline\n\n410b032a8635fba6cc30f0c2049a53f93b98128388a4a7ce2c3a0bfb33591f9f NEW Redline\n\n43d49812cc723b3c24ca7048faa859800c7e303e074243e4348f65d34127367b NEW Redline\n\n47c765ad0baae96498e05e3f0984002cbce6b3f1bacd1cf238681a677c2f8036 NEW Redline\n\n482765b55aecbf24eb102f531afb6c8905ab7a058a447d217be70984f15b4573 NEW Redline\n\n50b7e742eea52e18cf908cd676b87c0f145ecc3ff9692b01c90c47750fe989a7 NEW Redline\n\n70a6d43a56d267aa4fdac5a96722a2ff05e2ac1cc9ba996d173f0b3252e09898 NEW Redline\n\n7263336f1ec49f936501c508a9edf072a81002e64e52a1ed0cafb1378bb07a2a NEW Redline\n\n770e7d287fe352f12757ebfbb4502b10f61001630d70ddf414157b12e1f5e9a3 NEW Redline\n\n87f5b4385a2a87229b6c448a3b4b19a7e75fe6bc607dffc0e1f860e9e4499eca NEW Redline\n\nadc5669dd1153111f4cc07714599145a775d8c260c1acae9c142280147d1793a NEW Redline\n\nb80b3dae21d54eb9ccde40b9ba728ba3d45a73e0fc91adae3d7c375208631527 NEW Redline\n\ne35547cfb6ae3fe18df6d887334952e7a38cc51a230f02c7f62a5fef083de7cf NEW Redline\n\nf570b6c46a5bb5a8757b1125c7d4b5d4aca2c7e9354ed1d34b78fd4f08280e30 NEW Redline\n\nf6aba045ca29ba39bbdcb2f8bde63efc971d138f88bf03aea2d13ddec88a0483 NEW Redline\n\nfefb4288cb41fcca85cd50653093d7b27c9c51769b03f72adf951c5a1f111ddf NEW Redline\n\nf79273a1efb664d81f68e808b9ec963bfeb79d63bd277108863d6ae3c4801a9e NEW Redline\n\n24c870202b3aedfcd28a8afb93b5212b791c265abd872ef94e44401d1ca309ad NEW Redline\n\n417c3f327c2d8b54ec72a5a89280fecb589a3e0b89c281bbc077d7de445cc76b NEW Redline\n\n948416d3aeae6f31df3341118a25a4231a7eed23b3db73a022e9da70734163c9 NEW Redline\n\n\n-----\n\n**SHA256 Hash** **Version**\n\n\n**Malware family of**\n**embedded payload**\n\n\n71cc196ad2103a1facd81f2b8bd985273f682019b2a88841d2f34ecc373d1d69 NEW Redline\n\n7bdb945f2dab863a299e26ab4c6dfb1e4f7321c38fe101224252d993495bc157 NEW Redline\n\n0bb4d022d6007fcaf1d0707b646063b4b66cf5177da6a1fc6c5d0fc217501d6f NEW Redline\n\n0e918ad3e7ad983ecf6c3238991c13a230acc897193e0ad360d2eeaab42bf078 NEW Redline\n\nf413dbf6764bc73ab94428831e0ce3fc0369856aa50c4f9c0f5948eac85d2d08 NEW Redline\n\n670a96324222e6bb02bd36c7e5b100fb5d52d2d59891bd9599b1a47438ac9578 NEW Redline\n\n9049d536e6da46b63c562197ab92f511d5f5e2883eb8bf29f72217282ae25772 NEW Redline\n\n116d81561faa8c8a9cf4fbc947e9eee11185f3960daead8179a968dea143bfd0 NEW Redline\n\n9984a21c06fea77e96ba410cffb99de530201ef0c74f3e8b38b3afd4fdf0b333 NEW Redline\n\nbcc80eabe068cbbe38fa37b58e67fee54af75fa9e8a1fc30d93b7d30886d05da NEW Redline\n\n202570439b32480e6df232977d5435be9be94822c75f89b09f571e5b03f8c9ab NEW Redline\n\n96b5ea21a2556486cebbed76711a8bbae42de1e97e3311213833c6567a4fbbdc NEW Redline\n\n35c53663294e5476315853228b4ae642f552c6c6b1253412a7f981c7ddf3d0b7 NEW Remcos\n\n8c451b84d9579b625a7821ad7ddcb87bdd665a9e6619eaecf6ab93cd190cf504 NEW Remcos\n\n7d8c18056e86a3b8c32b524f9de009ced61caf463abe1bca285fa305d4b5616a NEW Rhadamanthys\n\na2e9a2389faf04b67fbbd6fc71134860a145db7643d88ba312390493d5619302 NEW Rhadamanthys\n\n9f96e5bc9ffc9742cb10384566dc7fb232e0f0d633e643bd487b747b6e88f369 NEW Rhadamanthys\n\n71ecfddc7fe52a10bdf79c39cf9a1d911257ed0deee1bfef21386053bfe88110 NEW Rhadamanthys\n\n96e49a5ac188d49003b2fe77ad8a4c8866a94cc828dc6172d9a13a8c26e49b9b NEW Rhadamanthys\n\n5474d15059ca4213ab1c13fba25ab8ba38559cac7ec2ab336d2411b90eab1217 NEW SnakeKeylogger\n\neb2e2ac0f5f51d90fe90b63c3c385af155b2fee30bc3dc6309776b90c21320f5 NEW SnakeKeylogger\n\n02355d3fee5e217b25f9210ad0f6bacc3807b6ef1a59aa4d428c01017dcbcf28 NEW Vidar\n\n05f9553616bb5fdbf37bd4036c210929e08d7181de898c1bea1bdae7afb0766f NEW Vidar\n\n0c857501e3851072db666386136929c06bcf4c8d3160b41b7d82a3ce9afca1be NEW Vidar\n\n3418a369486e9bf2b57023dc0b02cb00f12a5214fca8bae20ff93586cc8c678a NEW Vidar\n\n363c46dfb252d7c40d9c3bb63bdc40c2eff0ce16c0c1b77f507d73058104c6e1 NEW Vidar\n\n4c17f7ee55f9bf6fa9acaeeb9574feab39ba4a3cccd4426dfa85aaf58b90ae73 NEW Vidar\n\n4d4f97f1621334e4075e0229265ac6c5da14754eff1378a7d77ea6d3821e8a33 NEW Vidar\n\n87b92fcd04f69f9c132c9f350dbb3686888a5e388b1f787f6a658f09582c0da6 NEW Vidar\n\n99e733391ac499e78e535a98551c4d27408abfad4e56fe4c46956636655df29c NEW Vidar\n\nb67bc78347918209973d633287c4e1f514a0917b8678c2cf2066ba80b2004f78 NEW Vidar\n\n\n-----\n\n**SHA256 Hash** **Version**\n\n\n**Malware family of**\n**embedded payload**\n\n\nc6e0a5e947e9f23cd0af6fa8bd44411a12212ab1de5007036926089800ac8692 NEW Vidar\n\ncb014704f53d5da64964c2b0bfc7e13bbdf389555294c6f6c98c2527f6406d6d NEW Vidar\n\nd55f6b273254d2be71991cdbdb288cc94a7bc715c4be7ad97c0e1625bc0f2696 NEW Vidar\n\nd6fd4a75e32f78817f84de3dcb9e3fd767f602b7da1edecd06391ff62a481571 NEW Vidar\n\ne56c525248b1f9201cddcf1802377a7157029e8935696d1a9d9169e1d0501fa4 NEW Vidar\n\ne6a2575c893868e3d8ea5982699c9c2b75a07b8ec092b0cb26d7b5c3c2640f33 NEW Vidar\n\nec875c5901e28a04b199f577b16a8ba6ac8c9ab7e90bc51a5809f668882ba54f NEW Vidar\n\nb4a57b62569ee1ccb1c2dae148488dc9e37d738f0fed4f0a6e144caeb910f546 NEW Vidar\n\nf9c25b4755ab54ff3f8d827b6422d43ed14dbd03fd4faa266348eee177f7957f NEW Vidar\n\nfa258b12d3f4ca1503379a4f6a800bdb1d589ef15ab8bfc20d452f70c8a0745c NEW Vidar\n\nfcc4c20c07fdf816b7cc6dfba34d42af827ecf01e9972f266ac395e54db028af NEW Vidar\n\na19cabf8ce0a8012dedbf65855981db1efa3b9773365554401a74bfb7a45490f NEW Vidar\n\n7f801c77fb61cc8d5c03e9fa3068163b595f5bf8c176628398bbbea5aa0a1b74 NEW Vidar\n\n63de4552312345e055236c82ecdc55c2bc8b3c37f363cb081f8f788b5203d759 NEW Vidar\n\n2478cd52847146b34cae6b768c794210838a3002a622ce61c2f90d075f6e0e65 NEW Vidar\n\nc5646cc9fe486f0644067fc294f83eb6a39ce6f28eea3708c9bf49e244acc0f9 NEW Vidar\n\nfc99e6083b1dcbe72fb818dbd53903f30c312731f2cfc8607f9d2bf2586be1ee NEW XWorm\n\n## Yara\n\n\n-----\n\n```\n    j _ _ p {\n  meta:\n\n    description = \"Detects new version of dotRunpeX - configurable .NET injector\"\n\n  author = \"Jiri Vinopal (jiriv)\"\n\n  date = \"2022-10-30\"\n\n  hash1 = \"373a86e36f7e808a1db263b4b49d2428df4a13686da7d77edba7a6dd63790232\" // injects Formbook\n\n    hash2 = \"41ea8f9a9f2a7aeb086dedf8e5855b0409f31e7793cbba615ca0498e47a72636\" // injects Formbook\n\n    hash3 = \"5e3588e8ddebd61c2bd6dab4b87f601bd6a4857b33eb281cb5059c29cfe62b80\" // injects AsyncRat\n\n    hash4 = \"8c451b84d9579b625a7821ad7ddcb87bdd665a9e6619eaecf6ab93cd190cf504\" // injects Remcos\n\n    hash5 = \"8fa81f6341b342afa40b7dc76dd6e0a1874583d12ea04acf839251cb5ca61591\" // injects Formbook\n\n    hash6 = \"cd4c821e329ec1f7bfe7ecd39a6020867348b722e8c84a05c7eb32f8d5a2f4db\" // injects AgentTesla\n\n    hash7 = \"fa8a67642514b69731c2ce6d9e980e2a9c9e409b3947f2c9909d81f6eac81452\" // injects AsyncRat\n\n    hash8 = \"eb2e2ac0f5f51d90fe90b63c3c385af155b2fee30bc3dc6309776b90c21320f5\" // injects\nSnakeKeylogger\n\n  strings:\n\n  // Used ImplMap imports (PInvoke)\n\n    $implmap1 = \"VirtualAllocEx\"\n\n    $implmap2 = \"CreateProcess\"\n\n    $implmap3 = \"CreateRemoteThread\"\n\n    $implmap4 = \"Wow64SetThreadContext\"\n\n    $implmap5 = \"Wow64GetThreadContext\"\n\n    $implmap6 = \"NtResumeThread\"\n\n    $implmap7 = \"ZwUnmapViewOfSection\"\n\n    $implmap8 = \"NtWriteVirtualMemory\"\n\n    $implmap9 = \"MessageBox\" // ImplMap not presented in all samples - maybe different versions?\n\n    $implmap10 = \"Wow64DisableWow64FsRedirection\"\n\n    $implmap11 = \"Wow64RevertWow64FsRedirection\"\n\n    $implmap12 = \"CreateFile\"\n\n    $implmap13 = \"RtlInitUnicodeString\"\n\n    $implmap14 = \"NtLoadDriver\"\n\n    $implmap15 = \"NtUnloadDriver\"\n\n    $implmap16 = \"OpenProcessToken\"\n\n    $implmap17 = \"LookupPrivilegeValue\"\n\n    $implmap18 = \"AdjustTokenPrivileges\"\n\n    $implmap19 = \"CloseHandle\"\n\n    $implmap20 = \"NtQuerySystemInformation\"\n\n    $implmap21 = \"DeviceIoControl\"\n\n    $implmap22 = \"GetProcessHeap\"\n\n    $implmap23 = \"HeapFree\"\n\n    $implmap24 = \"HeapAlloc\"\n\n    $implmap25 = \"GetProcAddress\"\n\n    $implmap26 = \"CopyMemory\" // ImplMap added by KoiVM Protector used by this injector\n\n    $modulerefKernel1 = \"Kernel32\"\n\n    $modulerefKernel2 = \"kernel32\"\n\n    $modulerefNtdll1 = \"Ntdll\"\n\n    $modulerefNtdll2 = \"ntdll\"\n\n    $modulerefAdvapi1 = \"Advapi32\"\n\n    $modulerefAdvapi2 = \"advapi32\"\n\n    $regPath = \"\\\\Registry\\\\Machine\\\\System\\\\CurrentControlSet\\\\Services\\\\TaskKill\" wide // Registry\npath for installing Sysinternals Procexp driver\n\n    $rsrcName = \"BIDEN_HARRIS_PERFECT_ASSHOLE\" wide\n\n    $koiVM1 = \"KoiVM\"\n\n    $koiVM2 = \"#Koi\"\n\n  condition:\n\n    uint16(0) == 0x5a4d and uint16(uint32(0x3c)) == 0x4550 and ($regPath or $rsrcName or 1 of\n($koiVM*)) and\n\n    24 of ($implmap*) and 1 of ($modulerefKernel*) and 1 of ($modulerefNtdll*) and 1 of\n($modulerefAdvapi*)\n\n}\n\n```\n\n-----\n\n```\n    j _ _ p _ {\n     meta:\n\n          description = \"Detects new and old version of dotRunpeX - configurable .NET injector\"\n\n  author = \"Jiri Vinopal (jiriv)\"\n\n  date = \"2022-10-30\"\n\n  hash1_New = \"373a86e36f7e808a1db263b4b49d2428df4a13686da7d77edba7a6dd63790232\" // injects Formbook\n\n          hash2_New = \"41ea8f9a9f2a7aeb086dedf8e5855b0409f31e7793cbba615ca0498e47a72636\" // injects\nFormbook\n\n          hash3_New = \"5e3588e8ddebd61c2bd6dab4b87f601bd6a4857b33eb281cb5059c29cfe62b80\" // injects\nAsyncRat\n\n          hash4_New = \"8c451b84d9579b625a7821ad7ddcb87bdd665a9e6619eaecf6ab93cd190cf504\" // injects\nRemcos\n\n          hash5_New = \"8fa81f6341b342afa40b7dc76dd6e0a1874583d12ea04acf839251cb5ca61591\" // injects\nFormbook\n\n          hash6_New = \"cd4c821e329ec1f7bfe7ecd39a6020867348b722e8c84a05c7eb32f8d5a2f4db\" // injects\nAgentTesla\n\n          hash7_New = \"fa8a67642514b69731c2ce6d9e980e2a9c9e409b3947f2c9909d81f6eac81452\" // injects\nAsyncRat\n\n          hash8_New = \"eb2e2ac0f5f51d90fe90b63c3c385af155b2fee30bc3dc6309776b90c21320f5\" // injects\nSnakeKeylogger\n\n          hash1_Old = \"1e7614f757d40a2f5e2f4bd5597d04878768a9c01aa5f9f23d6c87660f7f0fbc\" // injects\nLokibot\n\n          hash2_Old = \"317e6817bba0f54e1547dd9acf24ee17a4cda1b97328cc69dc1ec16e11c258fc\" // injects\nRedline\n\n          hash3_Old = \"65cac67ed2a084beff373d6aba6f914b8cba0caceda254a857def1df12f5154b\" // injects\nSnakeKeylogger\n\n          hash4_Old = \"68ae2ee5ed7e793c1a49cbf1b0dd7f5a3de9cb783b51b0953880994a79037326\" // injects\nLokibot\n\n          hash5_Old = \"81763d8e3b42d07d76b0a74eda4e759981971635d62072c8da91251fc849b91e\" // injects\nSnakeKeylogger\n\n     strings:\n\n     // Used ImplMap imports (PInvoke)\n\n          $implmap1 = \"VirtualAllocEx\"\n\n          $implmap2 = \"CreateProcess\"\n\n          $implmap3 = \"CreateRemoteThread\"\n\n          $implmap4 = \"Wow64SetThreadContext\"\n\n          $implmap5 = \"Wow64GetThreadContext\"\n\n          $implmap6 = \"RtlInitUnicodeString\"\n\n          $implmap7 = \"NtLoadDriver\"\n\n          $implmap8 = \"LoadLibrary\"\n\n          $implmap9 = \"VirtualProtect\"\n\n          $implmap10 = \"AdjustTokenPrivileges\"\n\n          $implmap11 = \"GetProcAddress\"\n\n          $modulerefKernel1 = \"Kernel32\"\n\n          $modulerefKernel2 = \"kernel32\"\n\n          $modulerefNtdll1 = \"Ntdll\"\n\n          $modulerefNtdll2 = \"ntdll\"\n\n          $regPath = \"\\\\Registry\\\\Machine\\\\System\\\\CurrentControlSet\\\\Services\\\\TaskKill\" wide //\nRegistry path for installing Sysinternals Procexp driver\n\n          $rsrcName = \"BIDEN_HARRIS_PERFECT_ASSHOLE\" wide\n\n          $koiVM1 = \"KoiVM\"\n\n          $koiVM2 = \"#Koi\"\n\n     condition:\n\n          uint16(0) == 0x5a4d and uint16(uint32(0x3c)) == 0x4550 and ($regPath or $rsrcName or 1 of\n($koiVM*)) and\n\n          9 of ($implmap*) and 1 of ($modulerefKernel*) and 1 of ($modulerefNtdll*)\n\n}\n\n## References\n\n```\n1. KoiVM protector: [https://github.com/yck1509/KoiVM](https://github.com/yck1509/KoiVM)\n2. Reflection in .NET: [https://learn.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection](https://learn.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection)\n\n\n-----\n\n3. P/Invoke: [https://learn.microsoft.com/en us/dotnet/standard/native interop/pinvoke](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke)\n4. D/Invoke: [https://github.com/TheWover/DInvoke](https://github.com/TheWover/DInvoke)\n5. Backstab: [https://github.com/Yaxser/Backstab](https://github.com/Yaxser/Backstab)\n6. MinHook: [https://github.com/TsudaKageyu/minhook](https://github.com/TsudaKageyu/minhook)\n7. ClrMD: [https://github.com/microsoft/clrmd](https://github.com/microsoft/clrmd)\n8. AsmResolver: [https://github.com/Washi1337/AsmResolver](https://github.com/Washi1337/AsmResolver)\n[9. OldRod: https://github.com/Washi1337/OldRod](https://github.com/Washi1337/OldRod)\n\n## Tools to Download\n\nGO UP\n[BACK TO ALL POSTS](https://research.checkpoint.com/latest-publications/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-03-15 - DotRunPEX - Demystifying New Virtualized .NET Injector used in the Wild.pdf"
    ],
    "report_names": [
        "2023-03-15 - DotRunPEX - Demystifying New Virtualized .NET Injector used in the Wild.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1680660565,
    "ts_updated_at": 1743041167,
    "ts_creation_date": 1680510808,
    "ts_modification_date": 1680510808,
    "files": {
        "pdf": "https://archive.orkl.eu/131b964a7220227226f4f9072cb39383e3ea932c.pdf",
        "text": "https://archive.orkl.eu/131b964a7220227226f4f9072cb39383e3ea932c.txt",
        "img": "https://archive.orkl.eu/131b964a7220227226f4f9072cb39383e3ea932c.jpg"
    }
}