{
    "id": "a20082a8-4cd3-4e64-9aea-ebc64c177a9e",
    "created_at": "2022-10-25T16:48:23.09259Z",
    "updated_at": "2025-03-27T02:05:46.901545Z",
    "deleted_at": null,
    "sha1_hash": "029fe6bbb89c82abff30c5c4e4d05c2a80e506e5",
    "title": "A Detailed Analysis of The Last Version of Conti Ransomware",
    "authors": "",
    "file_creation_date": "2021-10-18T16:20:13Z",
    "file_modification_date": "2021-10-18T12:22:32Z",
    "file_size": 20338414,
    "plain_text": "# A Detailed Analysis of The Last\n Version of Conti Ransomware\n\n### Prepared by:   LIFARS, LLC Date:  10/08/2021\n\n#### 1\n\n\n-----\n\n## EXECUTIVE SUMMARY \n\n\nConti ransomware has been sold as a RaaS (Ransomware as a Service) in underground forums\nand it’s usually deployed by other malware such as TrickBot and BazaLoader/BazarLoader. It can\nrun with one of the following parameters: “-p”, “-m”, “-size”, “-log” and “-nomutex”. A new mutex\ncalled “YUIOGHJKCVVBNMFGHJKTYQUWIETASKDHGZBDGSKL237782321344” can be created to\nensure that only one instance of ransomware is running at a single time. The malware has the\nability to only encrypt network shares (“-m net” parameter), local drives (“-m local” parameter),\nor both of them (“-m all” parameter). The volume shadow copies are deleted using wmic and\nCOM objects. The algorithm used to encrypt files is ChaCha8, with the key and nonce being\nencrypted using an RSA public key.\n\n\n-----\n\n## ANALYSIS AND FINDIGS\n\n\nSHA256: 4bfd58d4e4a6fe5e91b408bc190a24d352124902085f9c2da948ad7d79b72618\n\nThe malware obfuscates the stack strings and implements multiple custom algorithms to decrypt\nthem. An example of a decryption algorithm is shown below, along with the decrypted string:\n\nFigure 1\n\nFigure 2\n\nThe relevant APIs are imported dynamically at runtime using some hashing algorithms (the first\nparameter is a hash value; the second parameter is an offset). The return value is placed into the\nEAX register:\n\n\n-----\n\nFigure 3\n\nThe binary retrieves the command-line string for the process by calling the GetCommandLineW\nAPI:\n\nFigure 4\n\nCommandLineToArgvW is utilized to extract an array of pointers to the command line arguments,\nas shown in figure 5:\n\nFigure 5\n\nThe following strings have been decrypted using algorithms like the one presented in figure 1:\n\n\n-----\n\nFigure 6\nThe executable creates a mutex called\n“YUIOGHJKCVVBNMFGHJKTYQUWIETASKDHGZBDGSKL237782321344” (if the malware runs\nwith the “-nomutex” parameter, then no mutex is created):\n\nFigure 7\n\nGetNativeSystemInfo is used to retrieve information about the system:\n\nFigure 8\n\nThe malicious file creates 2 (which is the number of processors) threads that will handle the files\nencryption, as we’ll describe in the upcoming paragraphs:\n\n\n-----\n\nFigure 9\n\nThe executable takes a snapshot of all processes in the system by calling the\nCreateToolhelp32Snapshot routine (0x2 = TH32CS_SNAPPROCESS):\n\nFigure 10\n\nThe processes are enumerated using the Process32FirstW and Process32NextW APIs:\n\nFigure 11\n\nFigure 12\n\nThe malware searches for the “explorer.exe” process and saves its ID into a buffer for later use.\nThe CoInitializeEx function is utilized to initialize the COM library for use by the thread, as\nhighlighted below:\n\nFigure 13\n\n\n-----\n\nThe CoInitializeSecurity API is used to register security and set the default security values for the\ncurrent process (0x3 = RPC_C_IMP_LEVEL_IMPERSONATE):\n\nFigure 14\n\nThe malware uses COM objects and wmic in order to delete the volume shadow copies on the\nsystem. It calls the CoCreateInstance function with the CLSID {4590F812-1D3A-11D0-891F00AA004B2E24}, which creates an IWbemLocator object:\n\nFigure 15\n\nA new IWbemContext object is created with the CLSID {674B6698-EE92-11D0-AD7100C04FD8FDFF}:\n\nFigure 16\nThe ConnectServer method is utilized to connect to the “ROOT\\CIMV2” namespace:\n\n\n-----\n\nFigure 17\n\nThe binary sets the authentication information that is used to make calls on a proxy via a\nCoSetProxyBlanket API call (0xA = **RPC_C_AUTHN_WINNT,** 0x3 =\n**RPC_C_AUTHN_LEVEL_CALL, 0x3 = RPC_C_IMP_LEVEL_IMPERSONATE):**\n\nFigure 18\n\nThe following WQL (SQL for WMI) query is executed by the ransomware:\n\nFigure 19\n\nFor each volume shadow copy, the binary extracts its ID using the Get method:\n\n\n-----\n\nFigure 20\nThe following string that contains a process name with parameters is decrypted:\n\nFigure 21\nWow64DisableWow64FsRedirection is utilized to disable file system redirection for the current\nthread:\n\nFigure 22\n\nThe executable deletes each volume shadow copy that corresponds to the ID extracted above\nusing the CreateProcessW API (0x08000000 = CREATE_NO_WINDOW):\n\nFigure 23\n\nThe malware restores file system redirection by calling the Wow64RevertWow64FsRedirection\nroutine:\n\n\n-----\n\nFigure 24\n\nThe valid drives on the system are retrieved by calling the GetLogicalDriveStringsW function:\n\nFigure 25\n\nThere is a function call to WSAStartup that initiates the use of the Winsock DLL:\n\nFigure 26\n\nA new socket is created by the process (0x2 = **AF_INET, 0x1 =** **SOCK_STREAM, 0x6 =**\n**IPPROTO_TCP):**\n\nFigure 27\n\nThe malicious process calls the WSAIoctl function with the\n**SIO_GET_EXTENSION_FUNCTION_POINTER command code in order to invoke an**\nextension function, as shown in figure 28:\n\n\n-----\n\nFigure 28\n\nThe gethostname routine is utilized to retrieve the host name for the local computer:\n\nFigure 29\n\nThe malicious file retrieves host information that corresponds to the host extracted above:\n\nFigure 30\n\nThe CreateIoCompletionPort API is used to create an I/O (input/output) completion port that is\nnot yet associated with a file handle (0xFFFFFFFF = INVALID_HANDLE_VALUE):\n\nFigure 31\n\nThe ARP table is extracted by calling the GetIpNetTable routine, and the result is stored in a\nMIB_IPNETTABLE structure:\n\n\n-----\n\nFigure 32\n\nEach IP address extracted above is converted into a string (dotted-decimal format):\n\nFigure 33\n\nThe malware is only interested in local IP addresses because it compares every IP address with\nthe prefixes “172.”, “192.168.”, “10.” and “169.”. The binary creates 2 new threads via a function\ncall to CreateThread:\n\nFigure 34\n\nFigure 35\n\nPostQueuedCompletionStatus is utilized to send an I/O completion packet to the completion port\ncreated earlier (dwCompletionKey = 0x1):\n\n\n-----\n\nFigure 36\n\n\n## THREAD ACTIVITY – SUB_A7AF90 FUNCTION\n\n\nThe file creates a queue for timers (which are objects that allow the user to specify a function\nthat will be called at a particular time):\n\nFigure 37\n\nThe ransomware attempts to extract the I/O completion packet from the I/O completion port\n(sent by the main thread) by calling the GetQueuedCompletionStatus routine:\n\nFigure 38\n\nA new socket is created by calling the WSASocketW API (0x2 = **AF_INET, 0x1 =**\n**SOCK_STREAM, 0x6 = IPPROTO_TCP, 0x1 = WSA_FLAG_OVERLAPPED):**\n\nFigure 39\n\nThe bind routine associates the local address with the above socket:\n\n\n-----\n\nFigure 40\n\nCreateIoCompletionPort is utilized to associate the socket created above with the I/O completion\nport. After this operation is complete, the process can receive notifications of the completion of\nI/O operations involving the socket handle (CompletionKey = 0x2):\n\nFigure 41\n\nThe binary converts a port number (445) from network byte order to host byte order:\n\nFigure 42\n\nThe malware tries to connect to different IP addresses on port 445 (192.168.10.x and\n192.168.164.x) using the LPFN_CONNECTEX function, as described below:\n\nFigure 43\n\nThe CreateTimerQueueTimer routine is used to create a timer-queue timer, which expires at a\nspecific time (0x7530 = 30000ms = 30 seconds) and then a callback function is called:\n\n\n-----\n\nFigure 44\n\nThe setsockopt API is utilized to set the **SO_UPDATE_CONNECT_CONTEXT option, which**\nupdates the properties of the socket after a connection is established (0xFFFF = SOL_SOCKET,\n0x7010 = SO_UPDATE_CONNECT_CONTEXT):\n\nFigure 45\n\nThe file retrieves the SO_CONNECT_TIME option, which represents the number of seconds a\nsocket was connected (0xFFFF = SOL_SOCKET, 0x700C = SO_CONNECT_TIME):\n\nFigure 46\n\nWhether the sample has successfully established a connection to a particular IP address, then it\ncalls the WSAAddressToStringW routine to convert the components of that sockaddr structure\ninto a human-readable string:\n\nFigure 47\n\n\n-----\n\nPostQueuedCompletionStatus is utilized to send an I/O completion packet to the\ncompletion port created before (dwCompletionKey = 0x3):\n\nFigure 48\n\nThe binary shuts down send operations for the socket (0x1 = SD_SEND):\n\nFigure 49\n\n\n## THREAD ACTIVITY – SUB_A7A880 FUNCTION\n\n\nThe NetShareEnum function is utilized to retrieve information about the network shares available\non other computers:\n\nFigure 50\n\nSome strings that will be written in the log file (if logging mode is enabled) are also decrypted\nusing custom algorithms:\n\nFigure 51\n\n\n-----\n\nThe “ADMIN$” share will not be targeted by the malware (the others will be encrypted):\n\nFigure 52\n\n\n## THREAD ACTIVITY – SUB_A7C7D0 FUNCTION\n\n\nCryptAcquireContextA is used to obtain a handle to a key container within a CSP (0x18 =\n**PROV_RSA_AES, 0xF0000000 = CRYPT_VERIFYCONTEXT):**\n\nFigure 53\n\nAn RSA public key is imported via a CryptImportKey function call:\n\nFigure 54\n\nThe process creates a file called “readme.txt” in every folder that it encrypts (0x40000000 =\n**GENERIC_WRITE, 0x2 = CREATE_ALWAYS):**\n\n\n-----\n\nFigure 55\n\nThe following 4-byte values suggest that the encryption algorithm is a ChaCha cipher (Ref.\nhttps://arxiv.org/pdf/1907.11941.pdf):\n\nFigure 56\n\nThe encrypted content of the ransom note is decrypted using the ChaCha algorithm, and the file\nis populated by calling the WriteFile routine, as highlighted in figure 57.\n\nFigure 57\n\nThe files are enumerated in the targeted directory using the FindFirstFileW and FindNextFileW\nAPIs:\n\n\n-----\n\nFigure 58\n\nFigure 59\n\nThere is a comparison between the directory name and a list of directories that will be skipped\nby the ransomware:\n\nFigure 60\n\nThe PathIsDirectoryW routine is utilized to determine whether a path is a valid directory:\n\nFigure 61\n\nThe following files/files extensions will also be skipped by Conti:\n\nFigure 62\n\n\n-----\n\nThe sample descrypts the following DLL names: OleAut32.dll, Rstrtmgr.dll, Iphlpapi.dll,\nNetapi32.dll, Advapi32.dll, Kernel32.dll, Shell32.dll, Shlwapi.dll, ws2_32.dll, User32.dll, ntdll.dll,\nOle32.dll. The GetModuleHandleA function is utilized to retrieve a handle for these DLLs. The\nmalware generates 32 random bytes by calling the CryptGenRandom routine (this will be used as\nthe ChaCha key):\n\nFigure 63\n\nThere is also a call to CryptGenRandom that generates 8 random bytes, which will be used as the\nChaCha8 nonce (this is the moment when we can tell for sure that the encryption algorithm for\nfiles is ChaCha8):\n\nFigure 64\n\nThe ChaCha8 key and nonce are encrypted using the RSA public key:\n\nFigure 65\n\nThe ransomware retrieves file system attributes for the targeted file:\n\nFigure 66\n\n\n-----\n\nThe CreateFileW API is utilized to open the targeted file (0xC0000000 = **GENERIC_READ |**\n**GENERIC_WRITE, 0x3 = OPEN_EXISTING):**\n\nFigure 67\n\nThe malware comes with two hard-coded lists of file extensions that will be encrypted. It’s\nimportant to mention that if the file extension doesn’t belong to these lists, it will be partially\nencrypted using a different execution flow that will be explained later (the full lists are available\nin the Appendix):\n\nFigure 68\n\nFigure 69\n\nThe process writes the encrypted ChaCha8 key and nonce to the encrypted file:\n\n\n-----\n\nFigure 70\n\nThere are 3 different cases depending on the file size: small files (< 1MB), medium files (between\n1MB and 5MB), and large files (> 5MB). In the case of medium and large files, there exist 2 subcases depending on the file extension (if it belongs to the targeted lists or not). The following 10byte buffer that contains a marker (0x24) and the file size (0x2000) is appended to the encrypted\nfile:\n\nFigure 71\n\nThe binary reads the file content using the ReadFile function:\n\nFigure 72\n\nFigure 73\n\n\n-----\n\nThe content is encrypted using the ChaCha8 algorithm implemented by Conti:\n\nFigure 74\n\nA snippet of the ChaCha8 algorithm developed by the ransomware is presented in figure 75.\n\nFigure 75\n\nThe encrypted data is written to the file using the WriteFile API:\n\n\n-----\n\nFigure 76\n\nThe “.PSFUX” extension is added to the file name:\n\nFigure 77\n\nThe ransom note that is created in every encrypted directory is displayed below:\n\nFigure 78\n\nAn example of an encrypted file (file size < 1MB) is highlighted in the next 2 pictures:\n\n\n-----\n\nFigure 79\n\nFigure 80\nWhether the file size is between 1MB and 5MB and the extension is not in the targeted lists, the\nransomware only encrypts the first MB of the file, and the encrypted file has the following\nstructure:\n\n\n-----\n\nFigure 81\n\nWhether the file size is between 1MB and 5MB and the extension is in the targeted lists, the\nransomware encrypts the entire content, and the encrypted file has the following structure:\n\nFigure 82\n\n\n-----\n\nWhether the file size is greater than 5MB and the extension is not in the targeted lists, the\nransomware encrypts 5 chunks of (file size/100 * 10) bytes. In this case, this value is\n(0x500010/0x64 * 0xa) = 0x7FFF8 bytes (basically, the malware encrypts 0x7FFF8 bytes, then\nskips some bytes, and then encrypts 0x7FFF8 bytes again and so on). The structure of the\nencrypted file is presented below:\n\nFigure 83\n\nFigure 84\nWhether the file size is greater than 5MB and the extension is in the targeted lists, the\nransomware encrypts the entire content, and the encrypted file has the following structure:\n\n\n-----\n\nFigure 85\nWhen the malware runs with the “-log” parameter, then the list of actions is logged in a file:\n\nFigure 86\n\n\n-----\n\n## APPENDIX\n\n\nLists of targeted extensions:\n\n  - .4dd .4dl .accdb .accdc .accde .accdr .accdt .accft .adb .ade .adf .adp .arc .ora .alf .ask\n.btr .bdf .cat .cdb .ckp .cma .cpd .dacpac .dad .dadiagrams .daschema .db .db-shm .dbwal .db3 .dbc .dbf .dbs .dbt .dbv .dbx .dcb .dct .dcx .ddl .dlis .dp1 .dqy .dsk .dsn .dtsx\n.dxl .eco .ecx .edb .epim .exb .fcd .fdb .fic .fmp .fmp12 .fmpsl .fol .fp3 .fp4 .fp5 .fp7\n.fpt .frm .gdb .grdb .gwi .hdb .his .ib .idb .ihx .itdb .itw .jet .jtx .kdb .kexi .kexic .kexis\n.lgc .lwx .maf .maq .mar .mas .mav .mdb .mdf .mpd .mrg .mud .mwb .myd .ndf .nnt\n.nrmlib .ns2 .ns3 .ns4 .nsf .nv .nv2 .nwdb .nyf .odb .oqy .orx .owc .p96 .p97 .pan .pdb\n.pdm .pnz .qry .qvd .rbf .rctd .rod .rodx .rpd .rsd .sas7bdat .sbf .scx .sdb .sdc .sdf .sis\n.spq .sql .sqlite .sqlite3 .sqlitedb .te .temx .tmd .tps .trc .trm .udb .udl .usr .v12 .vis .vpd\n.vvv .wdb .wmdb .wrk .xdb .xld .xmlff .abcddb .abs .abx .accdw .adn .db2 .fm5 .hjt .icg\n.icr .kdb .lut .maw .mdn .mdt\n\n  - .vdi .vhd .vmdk .pvm .vmem .vmsn .vmsd .nvram .vmx .raw .qcow2 .subvol .bin .vsv\n.avhd .vmrs .vhdx .avdx .vmcx .iso\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://lifars.com/wp-content/uploads/2021/10/ContiRansomware_Whitepaper.pdf"
    ],
    "report_names": [
        "ContiRansomware_Whitepaper.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716503,
    "ts_updated_at": 1743041146,
    "ts_creation_date": 1634574013,
    "ts_modification_date": 1634559752,
    "files": {
        "pdf": "https://archive.orkl.eu/029fe6bbb89c82abff30c5c4e4d05c2a80e506e5.pdf",
        "text": "https://archive.orkl.eu/029fe6bbb89c82abff30c5c4e4d05c2a80e506e5.txt",
        "img": "https://archive.orkl.eu/029fe6bbb89c82abff30c5c4e4d05c2a80e506e5.jpg"
    }
}