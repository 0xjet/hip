{
    "id": "2ebc0867-be09-4c3d-9827-ebacc81fe256",
    "created_at": "2023-01-12T15:09:13.829972Z",
    "updated_at": "2025-03-27T02:14:02.479193Z",
    "deleted_at": null,
    "sha1_hash": "bdbfea2e0e23e34bbb55c25d0a3526c9f6b1aa2c",
    "title": "2021-01-20 - Emulation of Kernel Mode Rootkits With Speakeasy",
    "authors": "",
    "file_creation_date": "2022-05-27T23:14:17Z",
    "file_modification_date": "2022-05-27T23:14:17Z",
    "file_size": 93818,
    "plain_text": "# Emulation of Kernel Mode Rootkits With Speakeasy\n\n**[fireeye.com/blog/threat-research/2021/01/emulation-of-kernel-mode-rootkits-with-speakeasy.html](https://www.fireeye.com/blog/threat-research/2021/01/emulation-of-kernel-mode-rootkits-with-speakeasy.html)**\n\nThreat Research\n\nAndrew Davis\n\nJan 20, 2021\n\n10 mins read\n\nThreat Research\n\n[In August 2020, we released a blog post about how the Speakeasy emulation framework can](https://github.com/mandiant/speakeasy)\nbe used to emulate user mode malware such as shellcode. If you haven’t had a chance, give\nthe post a read today.\n\n\n-----\n\nIn addition to user mode emulation, Speakeasy also supports emulation of kernel mode\nWindows binaries. When malware authors employ kernel mode malware, it will often be in\nthe form of a device driver whose end goal is total compromise of an infected system. The\nmalware most often doesn’t interact with hardware and instead leverages kernel mode to\nfully compromise the system and remain hidden.\n\n**Challenges With Dynamically Analyzing Kernel Malware**\n\nIdeally, a kernel mode sample can be reversed statically using tools such as disassemblers.\nHowever, binary packers just as easily obfuscate kernel malware as they do user mode\nsamples. Additionally, static analysis is often expensive and time consuming. If our goal is to\nautomatically analyze many variants of the same malware family, it makes sense to\ndynamically analyze malicious driver samples.\n\nDynamic analysis of kernel mode malware can be more involved than with user mode\nsamples. In order to debug kernel malware, a proper environment needs to be created. This\nusually involves setting up two separate virtual machines as debugger and debugee. The\nmalware can then be loaded as an on-demand kernel service where the driver can be\ndebugged remotely with a tool such as WinDbg.\n\nSeveral sandbox style applications exist that use hooking or other monitoring techniques but\ntypically target user mode applications. Having similar sandbox monitoring work for kernel\nmode code would require deep system level hooks that would likely produce significant\nnoise.\n\n**Driver Emulation**\n\nEmulation has proven to be an effective analysis technique for malicious drivers. No custom\nsetup is required, and drivers can be emulated at scale. In addition, maximum code\ncoverage is easier to achieve than in a sandbox environment. Often, rootkits may expose\nmalicious functionality via I/O request packet (IRP) handlers (or other callbacks). On a\nnormal Windows system these routines are executed when other applications or devices\nsend input/output requests to the driver. This includes common tasks such as reading,\nwriting, or sending device I/O control (IOCTLs) to a driver to execute some type of\nfunctionality.\n\nUsing emulation, these entry points can be called directly with doped IRP packets in order to\nidentify as much functionality as possible in the rootkit. As we discussed in the first\nSpeakeasy blog post, additional entry points are emulated as they are discovered. A driver’s\nDriverMain entry point is responsible for initializing a function dispatch table that is called to\nhandle I/O requests. Speakeasy will attempt to emulate each of these functions after the\nmain entry point has completed by supplying a dummy IRP. Additionally, any system threads\nor work items that are created are sequentially emulated in order to get as much code\ncoverage as possible.\n\n\n-----\n\n**Emulating a Kernel Mode Implant**\n\nIn this blog post, we will show an example of Speakeasy’s effectiveness at emulating a real\nkernel mode implant family publicly named Winnti. This sample was chosen despite its age\nbecause it transparently implements some classic rootkit functionality. The goal of this post is\nnot to discuss the analysis of the malware itself as it is fairly antiquated. Rather, we will focus\non the events that are captured during emulation.\n\nThe Winnti sample we will be analyzing has SHA256 hash\nc465238c9da9c5ea5994fe9faf1b5835767210132db0ce9a79cb1195851a36fb and the\noriginal file name tcprelay.sys. For most of this post, we will be examining the emulation\nreport generated by Speakeasy. Note: many techniques employed by this 32-bit rootkit will\nnot work on modern 64-bit versions of Windows due to Kernel Patch Protection\n(PatchGuard) which protects against modification of critical kernel data structures.\n\nTo start, we will instruct Speakeasy to emulate the kernel driver using the command line\nshown in Figure 1. We instruct Speakeasy to create a full memory dump (using the “-d” flag)\nso we can acquire memory later. We supply the memory tracing flag (“-m”) which will log all\nmemory reads and writes performed by the malware. This is useful for detecting things like\nhooking and direct kernel object manipulation (DKOM).\n\n\n-----\n\nCommand line used to emulate the malicious driver\n\n\nFigure 1: Command line used to emulate the malicious driver\nSpeakeasy will then begin emulating the malware’s DriverEntry function. The entry point of a\ndriver is responsible for setting up passive callback routines that will service user mode I/O\nrequests as well as callbacks used for device addition, removal, and unloading. Reviewing\nthe emulation report for the malware’s DriverEntry function (identified in the JSON report with\nan “ep_type” of “entry_point”), shows that the malware finds the base address of the\nWindows kernel. The malware does this by using the ZwQuerySystemInformation API to\nlocate the base address for all kernel modules and then looking for one named\n“ntoskrnl.exe”. The malware then manually finds the address of the PsCreateSystemThread\nAPI. This is then used to spin up a system thread to perform its actual functionality. Figure 2\nshows the APIs called from the malware's entry point.\n\n\n-----\n\nKey functionality in the tcprelay.sys entry point\n\n\nFigure 2: Key functionality in the tcprelay.sys entry point\n\n**Hiding the Driver Object**\n\nThe malware attempts to hide itself before executing its main system thread. The malware\nfirst looks up the “DriverSection” field in its own DRIVER_OBJECT structure. This field holds\na linked list containing all loaded kernel modules and the malware attempts to unlink itself to\nhide from APIs that list loaded drivers. In the “mem_access” field in the Speakeasy report\nshown in Figure 3, we can see two memory writes to the DriverSection entries before and\nafter itself which will remove itself from the linked list.\n\n\n-----\n\nMemory write events representing the tcprelay.sys malware attempting to unlink\nitself in order to hide\n\nFigure 3: Memory write events representing the tcprelay.sys malware attempting to unlink\nitself in order to hide\n[As noted in the original Speakeasy blog post, when threads or other dynamic entry points](https://www.fireeye.com/resources/emulation-of-malicious-shellcode-with-speakeasy)\nare created at runtime, the framework will follow them for emulation. In this case, the\nmalware created a system thread and Speakeasy automatically emulated it.\n\nMoving on to the newly created thread (identified by an “ep_type” of “system_thread”), we\ncan see the malware begin its real functionality. The malware begins by enumerating all\nrunning processes on the host, looking for the service controller process named\nservices.exe. It's important to note that the process listing that gets returned to the emulated\nsamples is configurable via JSON config files supplied at runtime. For more information on\n[these configuration options please see the Speakeasy README on our GitHub repository.](https://github.com/mandiant/speakeasy)\nAn example of this configurable process listing is shown in Figure 4.\n\n\n-----\n\nProcess listing configuration field supplied to Speakeasy\n\n\nFigure 4: Process listing configuration field supplied to Speakeasy\n\n**Pivoting to User Mode**\n\nOnce the malware locates the services.exe process, it will attach to its process context and\nbegin inspecting user mode memory in order to locate the addresses of exported user mode\nfunctions. The malware does this so it can later inject an encoded, memory-resident DLL into\nthe services.exe process. Figure 5 shows the APIs used by the rootkit to resolve its user\nmode exports.\n\n\n-----\n\nLogged APIs used by tcprelay.sys rootkit to resolve exports for its user mode implant\n\n\nFigure 5: Logged APIs used by tcprelay.sys rootkit to resolve exports for its user mode\nimplant\nOnce the exported functions are resolved, the rootkit is ready to inject the user mode DLL\ncomponent. Next, the malware manually copies the in-memory DLL into the services.exe\nprocess address space. These memory write events are captured and shown in Figure 6.\n\n\n-----\n\nMemory write events captured while copying the user mode implant into\nservices.exe\n\nFigure 6: Memory write events captured while copying the user mode implant into\nservices.exe\nA common technique that rootkits use to execute user mode code involves a Windows\nfeature known as Asynchronous Procedure Calls (APC). APCs are functions that execute\nasynchronously within the context of a supplied thread. Using APCs allows kernel mode\napplications to queue code to run within a thread’s user mode context. Malware often wants\nto inject into user mode since much of the common functionality (such as network\ncommunication) within Windows can be more easily accessed. In addition, by running in user\nmode, there is less risk of being detected in the event of faulty code bug-checking the entire\nmachine.\n\nIn order to queue an APC to fire in user mode, the malware must locate a thread in an\n“alertable” state. Threads are said to be alertable when they relinquish their execution\nquantum to the kernel thread scheduler and notify the kernel that they are able to dispatch\n\n\n-----\n\nAPCs. The malware searches for threads within the services.exe process and once it detects\none that’s alertable it will allocate memory for the DLL to inject then queue an APC to\nexecute it.\n\nSpeakeasy emulates all kernel structures involved in this process, specifically the executive\nthread object (ETHREAD) structures that are allocated for every thread on a Windows\nsystem. Malware may attempt to grovel through this opaque structure to identify when a\nthread’s alertable flag is set (and therefore a valid candidate for an APC). Figure 7 shows the\nmemory read event that was logged when the Winnti malware manually parsed an\nETHREAD structure in the services.exe process to confirm it was alertable. At the time of\nthis writing, all threads within the emulator present themselves as alertable by default.\n\n\nEvent logged when the tcprelay.sys malware confirmed a thread was alertable\n\n\nFigure 7: Event logged when the tcprelay.sys malware confirmed a thread was alertable\n\n\n-----\n\nNext, the malware can execute any user mode code it wants using this thread object. The\nundocumented functions KeInitializeApc and KeInsertQueueApc will initialize and execute a\nuser mode APC respectively. Figure 8 shows the API set that the malware uses to inject a\nuser mode module into the services.exe process. The malware executes a shellcode stub as\nthe target of the APC that will then execute a loader for the injected DLL. All of this can be\nrecovered from the memory dump package and analyzed later.\n\n\nLogged APIs used by tcprelay.sys rootkit to inject into user mode via an APC\n\n\nFigure 8: Logged APIs used by tcprelay.sys rootkit to inject into user mode via an APC\n\n**Network Hooks**\n\nAfter injecting into user mode, the kernel component will attempt to install network\nobfuscation hooks (presumably to hide the user mode implant). Speakeasy tracks and tags\nall memory within the emulation space. In the context of kernel mode emulation, this includes\nall kernel objects (e.g. Driver and Device objects, and the kernel modules themselves).\n\n\n-----\n\nImmediately after we observe the malware inject its user mode implant, we see it begin to\nattempt to hook kernel components. This was confirmed during static analysis to be used for\nnetwork hiding.\n\nThe memory access section of the emulation report reveals that the malware modified the\nnetio.sys driver, specifically code within the exported function named\nNsiEnumerateObjectsAllParametersEx. This function is ultimately called when a user on the\nsystem runs the “netstat” command and it is likely that the malware is hooking this function in\norder to hide connected network ports on the infected system. This inline hook was identified\nby the event captured in Figure 9.\n\n\nInline function hook set by the malware to hide network connections\n\n\nFigure 9: Inline function hook set by the malware to hide network connections\nIn addition, the malware hooks the Tcpip driver object in order to accomplish additional\nnetwork hiding. Specifically, the malware hooks the IRP_MJ_DEVICE_CONTROL handler for\nthe Tcpip driver. User mode code may send IOCTL codes to this function when querying for\n\n\n-----\n\nactive connections. This type of hook can be easily identified with Speakeasy by looking for\nmemory writes to critical kernel objects as shown in Figure 10.\n\n\nMemory write event used to hook the Tcpip network driver\n\n\nFigure 10: Memory write event used to hook the Tcpip network driver\n\n**System Service Dispatch Table Hooks**\n\nFinally, the rootkit will attempt to hide itself using the nearly ancient technique of system\nservice dispatch table (SSDT) patching. Speakeasy allocates a fake SSDT so malware can\ninteract with it. The SSDT is a function table that exposes kernel functionality to user mode\ncode. The event in Figure 11 shows that the SSDT structure was modified at runtime.\n\n\n-----\n\nSSDT hook detected by Speakeasy\n\n\nFigure 11: SSDT hook detected by Speakeasy\nIf we look at the malware in IDA Pro, we can confirm that the malware patches the SSDT\nentry for the ZwQueryDirectoryFile and ZwEnumerateKey APIs that it uses to hide itself from\nfile system and registry analysis. The SSDT patch function is shown in Figure 12.\n\n\n-----\n\nFile hiding SSDT patching function shown in IDA Pro\n\n\nFigure 12: File hiding SSDT patching function shown in IDA Pro\nAfter setting up these hooks, the system thread will exit. The other entry points (such as the\nIRP handlers and DriverUnload routines) in the driver are less interesting and contain mostly\nboilerplate driver code.\n\n**Acquiring the Injected User Mode Implant**\n\nNow that we have a good idea what the driver does to hide itself on the system, we can use\nthe memory dumps created by Speakeasy to acquire the injected DLL discussed earlier.\nOpening the zip file we created at emulation time, we can find the memory tag referenced in\nFigure 6. We quickly confirm the memory block has a valid PE header and it successfully\nloads into IDA Pro as shown in Figure 13.\n\n\n-----\n\nInjected user mode DLL recovered from Speakeasy memory dump\n\n\nFigure 13: Injected user mode DLL recovered from Speakeasy memory dump\n\n**Conclusion**\n\nIn this blog post, we discussed how Speakeasy can be effective at automatically identifying\nrootkit activity from the kernel mode binary. Speakeasy can be used to quickly triage kernel\nbinaries that may otherwise be difficult to dynamically analyze. For more information and to\n[check out the code, head over to our GitHub repository.](https://github.com/mandiant/speakeasy)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-01-20 - Emulation of Kernel Mode Rootkits With Speakeasy.pdf"
    ],
    "report_names": [
        "2021-01-20 - Emulation of Kernel Mode Rootkits With Speakeasy.pdf"
    ],
    "threat_actors": [
        {
            "id": "4c68ccd0-caba-4189-9ead-86ac4c2d9b70",
            "created_at": "2024-05-01T02:03:07.930196Z",
            "updated_at": "2025-03-27T02:05:17.251237Z",
            "deleted_at": null,
            "main_name": "BRONZE ATLAS",
            "aliases": [
                "Axiom",
                "BARIUM ",
                "Blackfly ",
                "CTG-2633",
                "GREF",
                "Group 72 ",
                "Red Kelpie ",
                "TG-2633 ",
                "Wicked Panda ",
                "Winnti",
                "APT41 "
            ],
            "source_name": "Secureworks:BRONZE ATLAS",
            "tools": [
                " CCleaner v5.33 backdoor",
                " ChinaChopper",
                " Cobalt Strike",
                " Dicey MSDN",
                " ForkPlayground",
                " HUC Proxy Malware (Htran)",
                " Mimikatz",
                " PipeMon",
                " PlugX",
                " PortReuse",
                " Powershell Empire",
                " RCMD",
                " RbDoor",
                " SPEEDBOAT",
                " ShadowPad",
                " Sidewalk",
                " Speculoos",
                " TeamViewer",
                " Winnkit",
                " Winnti",
                " reg save",
                " vssadmin",
                "Acehash"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673536153,
    "ts_updated_at": 1743041642,
    "ts_creation_date": 1653693257,
    "ts_modification_date": 1653693257,
    "files": {
        "pdf": "https://archive.orkl.eu/bdbfea2e0e23e34bbb55c25d0a3526c9f6b1aa2c.pdf",
        "text": "https://archive.orkl.eu/bdbfea2e0e23e34bbb55c25d0a3526c9f6b1aa2c.txt",
        "img": "https://archive.orkl.eu/bdbfea2e0e23e34bbb55c25d0a3526c9f6b1aa2c.jpg"
    }
}