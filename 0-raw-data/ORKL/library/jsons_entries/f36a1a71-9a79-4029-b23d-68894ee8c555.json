{
    "id": "f36a1a71-9a79-4029-b23d-68894ee8c555",
    "created_at": "2023-01-12T15:01:03.492278Z",
    "updated_at": "2025-03-27T02:06:06.505636Z",
    "deleted_at": null,
    "sha1_hash": "57ad74d8e49eff2d9f26fa2f2c059c17b6ab7727",
    "title": "2020-06-25 - Zoom In- Emulating 'Exploit Purchase' in Simulated Targeted Attacks",
    "authors": "",
    "file_creation_date": "2022-05-28T19:12:13Z",
    "file_modification_date": "2022-05-28T19:12:13Z",
    "file_size": 92564,
    "plain_text": "# Zoom In: Emulating 'Exploit Purchase' in Simulated Targeted Attacks\n\n**[contextis.com/en/blog/zoom-in-simulated-targeted-attacks](https://www.contextis.com/en/blog/zoom-in-simulated-targeted-attacks)**\n\n[1. Home](https://www.contextis.com/en/)\n[2. Blog](https://www.contextis.com/en/blog)\n3. Zoom In: Emulating 'Exploit Purchase' in Simulated Targeted Attacks\n\nZoom In: Emulating 'Exploit Purchase' in Simulated Targeted Attacks\n\n[Context regularly perform Red Team and Simulated Attacker engagements for several](https://www.contextis.com/en/services/simulated-targeted-attacks-red-teaming)\nclients. These simulated attacks aim to uplift our client's ability to respond to real word\nadversaries. We perform these assessments by firstly identifying actionable intelligence on\nthe target, then formulate a plan of attack by mimicking the TTP’s of the many adversaries\nwe are actively tracking.\n\n### By Connor Scott\n\nSenior Consultant\n\n25 Jun 2020\n\n[Security,](https://www.contextis.com/blog/category/security) [Vulnerabilities and exploits,](https://www.contextis.com/blog/category/vulnerabilities-and-exploits) [Security assessment and testing](https://www.contextis.com/blog/category/security-assessment)\n\n## Introduction\n\nIn January, during a simulated attack engagement, Context obtained user level access to\nan internal network, however the compromised user account had limited access due to a\nhighly locked down environment. A path was identified within the network that would allow\nthe team to obtain privileged access, however it required a method of escalating privileges\non client workstations. The workstations all had the latest updates for both Windows 10 and\nWindows 7 and vendor patches were applied quickly, additionally there was minimal thirdparty software installed by default, limiting the potential attack surface. While assessing the\nexisting services on the system for avenues of privilege escalation, Zoom's Sharing Service\nwas identified on the shortlist of binaries to triage. After a review of the Zoom service binary,\na logic based Local Privilege Escalation vulnerability was identified. This zero-day\nvulnerability was exploited during the engagement and opened the compromise path\nleading directly to privileged network accounts.\n\n\n-----\n\nOn February 26, 2020, Context provided Zoom a detailed advisory and POC. The\nvulnerable version of the Zoom Sharing Service was 4.6.7. The issue, which only impacts\nWindows users, was fully resolved in Zoom release 5.0.4, which was released on May 24,\n2020.\n\nThe rest of this post contains technical details of the vulnerability and a detailed analysis of\nthe constraints enforced by the service.\n\n## Technical Details\n\nWhen performing a quick triage of a native binary (non .NET) executable for privilege\nescalation vectors, particularly service binaries, we look for two elements. The first element\nis an indication that the service executes code or reads/writes data to privileged areas, as\nservices generally run as the SYSTEM account, any sub processes or memory accesses\nalso inherit its privileged context. Looking at the Win32 API imports for function families\nsuch as CreateProcess, LoadLibrary, CreateFile or Registry can provide this indication. The\nsecond element is an indication that some form of interprocess communications (IPC) exist\nto control the service. Looking for Shared memory, File Mapping, Socket or Named Pipe\nfunctions in the imports can provide this indication. By importing CreateProcessAsUserW\nand CreateFileMappingW, the Zoom Sharing Service met these criteria and invited a more\nthorough look.\n\n_Note: all images and reverse engineering steps below were performed using GHIDRA on_\n_the following file:_\n\n**Name: CptService.exe**\n\n**FileVersion: 3.4.2019.0910**\n\n**MD5: 2a7a76fad78254d39d86504d0dd76dcf**\n\n**SHA256: 3c8eb269d2a128399146c13a9faf73c5ee3249b04df822a2c37e5e64fa4c6be9**\n\nAfter a session of reversing the CptService.exe binary we had a basic understanding of how\nthe relevant areas worked, in particular:\n\nThe shared file mapping details used for communicating between the user process\nand the service.\nThe expected data and message structure of the IPC.\nThe IPC read/action trigger.\nThe process execution constraints.\n\nCovering the reverse engineering of all these elements in one article would be quite long,\nso this article will focus on the part relevant to the vulnerability, i.e. the file execution\nconstraints. Reversing the shared file mapping IPC and the IPC read trigger may be\n\n\n-----\n\ncovered in future articles.\n\nIn short, the IPC flow can be triggered with the following steps:\n\nOpen the shared file mapping with the pattern\n\"Global\\ZOOM_CPTSERVICE_FILE_MAPPING\".\nWrite a structured IPC message.\nOpen the Zoom Sharing Service and send a user defined control code.\n\nThis will trigger the service to begin the processing of the message in the shared file\nmapping IPC buffer.\n\nAfter some initial tracing from the service entry point through IPC parsing functions we\neventually arrive at the function at offset 0x00401317, this function and its child functions\nhandle validation of the supplied IPC parameters. This is where will begin our walkthrough.\n\nLooking at the function graph, we can see a standard branching structure, where child\nfunctions are called, and if any of these functions fail, the whole function will return, and the\nprocess will not be executed. The interesting functions are called on lines 0x40133d,\n0x40134f, 0x40136a and 0x401376. As it is useful to understand the context of these\nfunctions to the overall vulnerability, we will summarise their functionality at a high level.\n\n1. 0x40133d - Called function appears to read data from the IPC Memory buffer and\n\nreturns a pointer if successful, or zero if it fails. We won't cover this in this blog, as the\ndetails aren’t really relevant to the issue found\n2. 0x40134f - Called function checks that the file exists and that the file permissions\n\nallow the requested operation to succeed. In this calling case, it just checks that the\nfile exists. We won't cover this in this blog, as the details aren’t really relevant to the\nissue found\n3. 0x40136a - Called function appears to perform validation of the specified executable\n\nfile and the DLLs that are imported by it. If we can return success from this function,\nwe can proceed to execute code.\n4. 0x401376 - Called function kills existing process in the target Windows Session with\n\nexecutable name matching the supplied filename then launches a new process using\nthe supplied executable filename. At this point there are no more verification checks,\nso we won't cover this in this blog\n\nIn relation to this service, if we can make our supplied file pass the signature and path\nvalidation, we can execute code as SYSTEM on the local machine. The vulnerability\nidentified in CVE-2020-9767 allows us to pass this validation and therefore execute\narbitrary code of our choosing. As the IPC mechanism is only available locally, this does not\npose a threat of direct remote code execution.\n\nIf you are interested in the low-level details of this function, continue reading below.\n\n\n-----\n\n### So you care to see how deep the rabbit hole goes?\n\nHaving identified that the function 0x404966, called at 0x40136a, performs validation of the\nsupplied executable, we can dig further into it to identify any issues that would allow us to\nbypass the validation or understand what validation constraints must be met. For ease of\nreference, from here on we will refer to this function as validate_exe.\n\nLooking at the function from a bird’s eye view we can see that there are many places where\nthe execution jumps to a code location that will zero the AL register before executing the\nepilog, which will effectively flag a failure of verification. There are two jumps that skip this\nexplicit zeroing of AL, allowing a successful result to be returned. These jumps are coloured\nblue above. The first is at 0x404a07 and explicitly sets AL to 1 before calling the epilog\ntherefore returning valid, the second is at 0x404acb, when the result from the function call\nat 0x404ab2 is moved into AL and then epilog is called returning true or false based on the\noutput of the function at 0x404651. These two paths give us the opportunity to return\nsuccessfully from the validate_exe function.\n\nAs neither of these blocks are at the start of the function, we will need to understand the\nconstraints imposed on the execution path to reach these blocks. Fortunately, for us both\nblocks share the same constraints until just before the first block so we get to kill two birds\nwith one stone.\n\nTo start with, we can see at line 0x40498a that EDI is set to the address of the filename in\nthe IPC packet and on the following line EBX is set to zero. Then at 0x404997, EDI (the\nfilename pointer) is compared against EBX (zero). If the result matches (EDI == 0), then we\nreturn zero from the function indicating it’s not a valid executable. So we now know that we\nneed to supply a filename in the IPC packet.\n\nIn the next block (0x40499f) we zero EAX, then compare AX (zero) with the word value\nstored at EDI (the filename pointer), effectively checking that the first character of the\nfilename is not a ‘\\0’ (null byte). Note a word comparison is used rather than a byte\ncomparison because the string is a wide (UTF-16) string. If the character is null, then we\nreturn zero from the function and it is not a valid executable. So now we know we need to\nsupply at least 1 byte in our filename.\n\nThe next 3 blocks (0x4049aa, 0x4049af and 0x4049b9) perform an inline wstrlen and\ncompare the result to 0x208. The first two blocks count the number of bytes in the string, by\nlooping over each wchar, loading it from the location of EAX into CX and comparing it to\nnull. It then increments EAX on each loop by two to account for the wchar. Finally, when CX\nis null, it breaks the loop and continues to the next block. The next block divides the number\nof bytes by 2 and compares to 0x208 (decimal 520). If the string is longer than that, the\n\n\n-----\n\nfunction will return zero indicating it is not a valid executable. So now we know that the\nfilename string must have one or more characters and 520 or fewer characters (not\nincluding the null byte).\n\nThe next block (0x4049c8) calls PathIsRelativeW with the supplied filename. This will return\ntrue (non-zero) if the supplied path is a relative path or zero if the path is an absolute path.\nIf the path is relative, then we return zero from the function and it is not a valid executable.\nSo we now know the path supplied in filepath must be absolute.\n\nWe will skip over the next blocks at 0x4049d7, 0x4049df and 0x4049e7, because the values\ndidn't appear to be directly relevant to our path hunting, although the result is passed into\nthe validate_file_signature function.\n\nThe next relevant block starts at 0x4049ea (highlighted) and involves a call at 0x4049ee to\nthe function at 0x4032c4, if that call returns zero we return zero from the validate_exe\nfunction and our executable is flagged as non-valid. To save time, we won't delve into this\nfunction, because there is a fair bit of code that checks the platform for WinTrust support\nand where it is supported, uses WinTrust to validate the Authenticode signature on the file\nat the supplied filepath. If it is valid, it checks the issuer of the certificate to ensure it was\nsigned by \"Zoom Video Communications, Inc.\". If the signature is invalid or the issuer does\nnot match, the function will return failure. On platforms that do not support WinTrust (before\n2003, XP) this function returns true in all cases. So now we know that the supplied\nexecutable must have a valid signature AND be signed by Zoom on recent operating\nsystems. This significantly limits the pool of options.\n\nFinally, we are at a block that can redirect execution to our first identified opportunity\n(highlighted green) to return non-zero from the validate_exe function we mentioned all so\nlong ago. We can see that the result of the function call to 0x402e4d at 0x004049fe is\nchecked, if it is non-zero, our first block of interest is executed and we will return 1, and\nvalid, from the validate_exe function. If it is zero, it will continue with further filepath checks.\nSo what does the function at 0x402e4d do? For the sake of this blog, we will save the\nminutiae. The function appears to get the full path of the current Windows install and checks\nthat it is contained within the supplied filepath string. If it is, it will return 1, if it is not it will\nreturn 0.\n\nSo to hit our return 1, valid, block, at this point we have the following constraints to meet:\n\nSupply an absolute filepath to an executable file that will be eventually executed\nThe supplied executable must have a valid Authenticode signature, and the Issuer\nmust be \"Zoom Video Communications, Inc.\"\nThe supplied file path must be in the Windows install directory, or have the absolute\nWindows install directory in its filepath\n\n\n-----\n\nInitially, these seem like challenging constraints, until two things are realised. Firstly, there\nare subfolders in the Windows install folder where users are able to write, for example\nC:\\Windows\\Temp. Secondly, Zoom provides a number of binaries that have valid\nAuthenticode signatures that we can use to pass this signature check. These signed\nexecutables load DLLs, so we can effectively use them to 'trampoline' execution to our\ncode.\n\nSo this could be one method to achieve code execution, but where is the fun in that? What\nif user write permissions in the Windows install directory are locked down? What if we want\nto execute from arbitrary folders, say for example C:\\Users\\Public\\Context for vanity\npurposes? To do this, we need to press on, which for the sake of brevity will be covered in a\nfuture blog.\n\n## Vendor Response\n\nThe identified vulnerability was disclosed to Zoom in late February 2020. Context and Zoom\nstaff followed [coordinated disclosure processes to confirm the issue was resolved and to](https://www.contextis.com/en/about-us/coordinated-disclosure)\nensure their respective clients using this software were protected.\n\nZoom’s advisory for this issue may be found at: https://support.zoom.us/hc/enus/articles/360044350792-Security-CVE-2020-9767.\n\nContext’s advisory for this issue may be found at:\n[https://www.contextis.com/en/resources/advisories/cve-2020-9767](https://www.contextis.com/en/resources/advisories/cve-2020-9767)\n\n## Mitigations\n\nThere are several recommendations to help mitigate this vulnerability and we welcome\nquestions and queries.\n\n### Update Zoom\n\nFirstly, as with all software we strongly recommend that any application be updated when\npossible. Given the current climate, updating via corporate deployment services may be\nmore difficult. As such, teams should be encouraged to update Zoom as well as any other\napplications directly on the Internet if applicable to their network architecture. Zoom 5.0.4\nwas verified to remediate this vulnerability and working with the Zoom security team, the\nunderlying flaws have been addressed. Later versions should also include these fixes.\n\nShould IT administrators be unable to upgrade Zoom to version 5.0.4 and above, there are\ntwo other options for mitigating this particular vulnerability.\n\n### Implement Application and DLL Whitelisting\n\n\n-----\n\nApplication and DLL whitelisting has proven to be an effective defence in depth measure to\ncombat the execution of untrusted executables and DLLs. When implementing an effective\napplication and DLL whitelisting program, ensure that folder allow rules such as\nC:\\Windows\\* are not included as users may write files to and execute files in subfolders of\nthis folder. In addition, a baseline should be performed capturing Zoom’s installed binaries\nand DLLs, these should be whitelisted, effectively restricting other unapproved software\nfrom piggybacking on execution flow.\n\n### Disable Zoom Sharing Service\n\nThrough testing in a laboratory environment and in conjunction with the client during the\nsimulated attack, stopping the ‘CptService/Zoom Sharing Service’ did not appear to have a\nnegative impact during general purpose use. Screen sharing, desktop controls and all other\nfunctionality appeared to function, as such it was the recommendation as an immediate\nremediation to disable this service. Upon further investigation and discussion with the Zoom\nSecurity team, this service was identified as being used to potentially share elevated\nwindows dialogs.\n\nGenerally, users sharing elevated windows would be initially privileged users and may\ninherit the integrity level when launching zoom (dependent on local security controls). As\nsuch, this service could be disabled with minimal impact to most of the user base and attack\nsurface immediately remediating this issue.\n\n### About Connor Scott\n\nSenior Consultant\n\nConnor is part of our Assurance team and is based in our Melbourne, Australia office, he\nspecialises in Red Teaming, Reverse Engineering, Software and Embedded Device\nVulnerability Research, Infrastructure Assessments and Code Reviews.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-25 - Zoom In- Emulating 'Exploit Purchase' in Simulated Targeted Attacks.pdf"
    ],
    "report_names": [
        "2020-06-25 - Zoom In- Emulating 'Exploit Purchase' in Simulated Targeted Attacks.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535663,
    "ts_updated_at": 1743041166,
    "ts_creation_date": 1653765133,
    "ts_modification_date": 1653765133,
    "files": {
        "pdf": "https://archive.orkl.eu/57ad74d8e49eff2d9f26fa2f2c059c17b6ab7727.pdf",
        "text": "https://archive.orkl.eu/57ad74d8e49eff2d9f26fa2f2c059c17b6ab7727.txt",
        "img": "https://archive.orkl.eu/57ad74d8e49eff2d9f26fa2f2c059c17b6ab7727.jpg"
    }
}