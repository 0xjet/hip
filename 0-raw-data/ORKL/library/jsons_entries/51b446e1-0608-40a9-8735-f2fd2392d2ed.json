{
    "id": "51b446e1-0608-40a9-8735-f2fd2392d2ed",
    "created_at": "2023-01-12T15:06:25.536076Z",
    "updated_at": "2025-03-27T02:05:53.938169Z",
    "deleted_at": null,
    "sha1_hash": "97b3b4133395aa95c39747a3cd2c71ff9a061ae4",
    "title": "2017-08-18 - Inside the Kronos malware – part 1",
    "authors": "",
    "file_creation_date": "2022-05-28T04:56:49Z",
    "file_modification_date": "2022-05-28T04:56:49Z",
    "file_size": 770542,
    "plain_text": "# Inside the Kronos malware – part 1\n\n**[blog.malwarebytes.com/cybercrime/2017/08/inside-kronos-malware/](https://blog.malwarebytes.com/cybercrime/2017/08/inside-kronos-malware/)**\n\nMalwarebytes Labs August 18, 2017\n\nRecently, a researcher nicknamed MalwareTech famous from stopping the WannaCry\nransomware got arrested for his alleged contribution to creating the Kronos banking\nmalware. We are still not having a clear picture whether the allegations are true or not – but\nlet’s have a look at Kronos itself.\n\n## Background\n\nThis malware has been first advertised on the black market since around June 2014, by an\nindividual nicknamed VinnyK, writing in Russian:\n\n\n-----\n\nSource: [https://twitter.com/x0rz/status/893191612662153216](https://twitter.com/x0rz/status/893191612662153216)\n\nThe full text of the advertisement, translated into English, has been included in the IBM’s\nSecurity Intelligence article.\n\n[We found Kronos being spread by various exploit kits, i.e. Sundown (more information here).](https://blog.malwarebytes.com/threat-analysis/2016/10/new-looking-sundown-ek-drops-smoke-loader-kronos-banker/)\nThe malware is being distributed up to now – some of the recent samples have been\n[captured about a month ago, dropped from Rig EK.](https://zerophagemalware.com/2017/07/14/rig-ek-delivers-kronos-banker/)\n\nNowadays, Kronos is often used for the purpose of downloading other malware. One of the\n[campaigns using Kronos as a downloader was described by Proofpoint.](https://www.proofpoint.com/us/threat-insight/post/kronos-banking-trojan-used-to-deliver-new-point-of-sale-malware)\n\n## Analyzed samples\n\nSamples from 2014:\n\n[01901882c4c01625fd2eeecdd7e6745a – first observed sample of Kronos (thanks to](https://www.virustotal.com/en/file/3bd4b8caf9ae975bd41dbee1f1719cf7be3efa4f52b8768aba30ba9a40569008/analysis/)\n[Kevin Beaumont)](https://twitter.com/GossiTheDog)\n_f085395253a40ce8ca077228c2322010 – sample from the_ [Lexsi article](https://www.lexsi.com/securityhub/overview-kronos-banking-malware-rootkit/?lang=en)\n\n[a81ba5f3c22e80c25763fe428c52c758 – Kronos (final payload)](https://virustotal.com/en/file/4181d8a4c2eda01094ca28d333a14b144641a5d529821b0083f61624422b25ed/analysis/1502307205/)\n\n[6c64c708ebe14c9675813bf38bc071cf – injlib-client.dll (module of Kronos)](https://virustotal.com/en/file/ea216cede2a1eff5d76a2f8258d4a89d822f45c3951c5a4734c16ce163153a8f/analysis/1502307222/)\n\n\n-----\n\nSample #1 (from 2016)\n\nSample #2 (from 2017):\n\n## Behavioral analysis\n\nAfter being run, Kronos installs itself in a new folder (%APPDATA%/Microsoft/[machine_specific GUID]):_\n\nThe dropped sample has a hidden attribute.\n\nPersistence is achieved with the help of a simple Run key:\n\nAt the beginning of the execution, the malware modifies the Firefox profile, overwriting user.js\nwith the following content:\n```\nuser_pref(\"network.cookie.cookieBehavior\", 0);\nuser_pref(\"privacy.clearOnShutdown.cookies\", false);\nuser_pref(\"security.warn_viewing_mixed\", false);\nuser_pref(\"security.warn_viewing_mixed.show_once\", false);\nuser_pref(\"security.warn_submit_insecure\", false);\nuser_pref(\"security.warn_submit_insecure.show_once\", false);\nuser_pref(\"app.update.auto\", false);\nuser_pref(\"browser.safebrowsing.enabled\", false);\nuser_pref(\"network.http.spdy.enabled\", false);\nuser_pref(\"network.http.spdy.enabled.v3\", false);\nuser_pref(\"network.http.spdy.enabled.v3-1\", false);\nuser_pref(\"network.http.spdy.allow-push\", false);\nuser_pref(\"network.http.spdy.coalesce-hostnames\", false);\nuser_pref(\"network.http.spdy.enabled.deps\", false);\nuser_pref(\"network.http.spdy.enabled.http2\", false);\nuser_pref(\"network.http.spdy.enabled.http2draft\", false);\nuser_pref(\"network.http.spdy.enforce-tls-profile\", false);\nuser_pref(\"security.csp.enable\", false);\n\n```\nThe new settings are supposed to give to the malware more control over the browser’s\nbehavior and downgrade the security settings. Then, the malware injects itself into svchost,\nand continues running from there. We can find it listening on local sockets.\n\n\n-----\n\n[It is worth noting, that Kronos deploys a simple userland rootkit, that hides the infected](https://blog.malwarebytes.com/threat-analysis/2016/12/simple-userland-rootkit-a-case-study/)\nprocess from the monitoring tools. So, the process running the main module may not be\nvisible. The rootkit is, however, not implemented in a very reliable way, and the effect of\nhiding does not always work.\n\nWhenever some browser is deployed. Kronos injects its module there and connects with the\nmain module, that runs inside the svchost process. Looking at the TCP connections\nestablished by the particular processes (i.e. using ProcessExplorer), we can see that a\nbrowser is paired with the infected svchost:\n\nThis trick is often used by banking trojans for the purpose of stealing data from the browser.\nThe module injected in the browser hooks the used API and steals the data. After that, it\nsends this data to the main module that process it further, and reports to the CnC.\n\n## Network communication\n\nThe analyzed sample was connecting to CnCs at two addresses:\n```\nhttp://springalove.at:80/noix/connect.php\nhttp://springahate.at:80/noix/connect.php\n\n```\nAt the time of analysis, each CnC was dead (sinkholed), but still, we could spot some\npatterns typical for this malware family.\n\n\n-----\n\nFirst, the malware sends a beacon that is 74 bytes long:\n\nThen, follows another chunk of data:\n\nIn both cases, we can see that the requests are obfuscated by XOR with a random\ncharacter. This is how the beacon looks after being XOR-decoded:\n\nWe can see that all the requests start from the same header, including the GUID specific to\nthe infected machine.\n\n\n-----\n\n[Detailed research about decrypting Kronos communication has been already described here.](https://www.lexsi.com/securityhub/kronos-decrypting-the-configuration-file-and-injects/?lang=en)\n\n## Inside\n\n**Interesting strings**\n\nLike most malware, Kronos is distributed packed by various packers/crypters. After\nunpacking the first layer, we get the malicious payload. We can easily identify Kronos by the\ntypical strings used:\n\nThere are more strings that are typical for this particular malware:\n\nThose strings are hashes used to dynamically load particular imported functions. Malware\nauthors use this method to obfuscate used API functions, and by this way, hide the real\nmission of their tool. Instead of loading function using its explicit name, they enumerate all\nimports in a particular DLL, calculate hashes of their names, and if the hash matches the\nhardcoded one, they load that function.\n\nAlthough the approach is common, the implementation seen in Kronos is not typical. Most\nmalware stores hashes in the form of DWORDs, while Kronos stores them as strings.\n\nInside the early samples of Kronos, we can find a path to the debug symbols, revealing the\nstructure of directories on the machine where the code was built. The following path was\nextracted from one of the Kronos samples observed in wild\n[(01901882c4c01625fd2eeecdd7e6745a):](https://www.virustotal.com/en/file/3bd4b8caf9ae975bd41dbee1f1719cf7be3efa4f52b8768aba30ba9a40569008/analysis/)\n```\nC:\\Users\\Root\\Desktop\\kronos\\VJF1\\Binaries\\Release\\VJF.1.pdb\n\n```\n[The PDB path can be also found in the DLL (6c64c708ebe14c9675813bf38bc071cf) that](https://virustotal.com/en/file/ea216cede2a1eff5d76a2f8258d4a89d822f45c3951c5a4734c16ce163153a8f/analysis/1502307222/)\nbelongs to the release of Kronos from 2014:\n\n\n-----\n\n```\nC:\\Users\\Root\\Downloads\\Kronos2\\VJF1\\Bot\\injlib\\bin\\injlib client Release\\injlib\nclient.pdb\n\n```\nThis module, injlib-client.dll, is the part injected into browsers. In the newer version of\nKronos, analogical DLL can be found, however, the PDB path is removed.\n\n**Injection into svchost**\n\nThe main module of Kronos injects itself into svchost (version from 2014 injects into explorer\ninstead). In order to achieve this initial injection, the malware uses a known technique,\ninvolving the following steps:\n\n1. creates the svchost process as suspended\n2. maps its sections into its own address space\n3. modifies the sections, adding its own code and patching the entry point in order to\n\nredirect the execution there\n4. resumes the suspended process, letting the injected code execute\n\nBelow, you can see the memory inside the infected svchost (in early versions, the injection\nwas targeting explorer). The malware is added in a new, virtual section – in the given\nexample, mapped as 0x70000:\n\nThis is how the patched entry point of svchost looks like – as we can see, execution is\nredirected to the address that lies inside the added section (injected malware):\n\nThe execution of the injected PE file starts in a different function now – at RVA 0x11AB0:\n\n\n-----\n\n– while the original Entry Point of the malware was at RVA 0x12F22:\n\nThe malware defends itself from the analysis, and in the case of the VM or debugger being\ndetected, the sample will crash soon after the injection.\n\n**Running sample from new Entry Point**\n\nThe main operations of the malware starts inside the injected module. This is how the new\nEntry Point looks like:\n\nThe main function is responsible for loading all the imports and then deploying the malicious\nactions.\n\n\n-----\n\nIf you are an analyst trying to run Kronos from that point of the execution, below you will find\nsome tips.\n\nThe first block of the function is responsible for filling the import table of the injected module.\nIf we want to run the sample from that point, rather than following it when it is injected, there\nare some important things to notice. First of all, the loader is supposed to fill some variables\ninside the injected executable, i.e. the variable module_base. Other functions will refer to\nthis, so, if it does not contain the valid value, the sample will crash. Also, the functions filling\nthe imports expects that the section .rdata (containing the chunks to be filled), is set as\nwritable. It will be set as writable in the case when the sample is injected because then, the\nfull PE is mapped in a memory region with RWX (read-write-execute) access rights.\nHowever, in the normal case – when the sample is run from the disk – it is not. That’s why, in\norder to pass this stage, we need to change the access rights to the section manually.\n\nAnother option is to run Kronos sample starting from the next block of the main function. This\nalso leads to successful execution, because in case if the sample is run from the disk rather\nthan injected, imports are filled by windows loader and doing it manually is just redundant.\n\n\n-----\n\nThe last issue to bypass is the defensive check, described below.\n\n**Defensive tricks**\n\nThe malware deploys defense by making several environment checks. The checks are pretty\nstandard – searching blacklisted processes, modules etc. The particular series of checks are\ncalled from inside one function, and results are stored as flags set in a dedicated variable:\n\nIf the debugger/VM is detected, the variable has a non-zero value. Further, the positive result\nof this check is used to make the malware crash, interrupting the analysis.\n\nThe crash is implemented by taking an execution path inappropriate to the architecture\nwhere the sample was deployed. The malware is a 32 bit PE file, but it has a bit different\nexecution paths, depending if it is deployed on 32 or 64-bit system. First, the malware\nfingerprints the system and sets the flag indicating the architecture:\n```\nDWORD is_system64_bit()\n{\n     DWORD flag = 0;\n     __asm {\n          xor eax, eax\n          mov ax, cs\n          shr eax, 5\n          mov flag, eax\n     };\n     return flag;\n}\n\n```\n_This trick uses observations about typical values of CS registry on different versions of_\n_[Windows (more information here). It is worth to note, that it covers most but not all the cases,](https://github.com/corkami/docs/blob/master/InitialValues.md)_\n_and due to this on some versions of Windows the malware may not run properly._\n\nIf the debugger/VM is detected, the flag indicating the architecture is being flipped:\n\n\n-----\n\nThat’s why the sample crashes on the next occasion when the architecture-specific path of\nexecution should be taken.\n\nFor example, if the sample is deployed on 64-bit machine, under Wow64, the syscall can be\nperformed by using the address pointed by FS:[0xC0]. But if the malware runs on a 32-bit\nmachine, the value pointed by FS:[0xC0] will be NULL, thus, calling it crashes the sample.\n\nThis way of interrupting analysis is smart – sample does not exit immediately after the\nVM/debugger is detected, and it makes it harder to find out what was the reason of the\ncrash.\n\n**Using raw syscalls**\n\n\n-----\n\nAs mentioned in the previous paragraph, Kronos uses raw syscalls. Syscall basically means\nan interface that allows calling some function implemented by kernel from the user mode.\nApplications usually use them via API exported by system DLLs (detailed explanation you\ncan find i.e. [on EvilSocket’s blog).](https://www.evilsocket.net/2014/02/11/on-windows-syscall-mechanism-and-syscall-numbers-extraction-methods/)\n\nThose API calls can be easily tapped by monitoring tools. That’s why, some malware, for the\nsake of being stealthier reads the syscalls numbers from the appropriate DLLs, and calls\nthem by it’s own code, without using the DLL as a proxy. This trick has been used i.e. by\n[Floki bot.](https://blog.malwarebytes.com/threat-analysis/2016/11/floki-bot-and-the-stealthy-dropper/)\n\nLet’s have a look how is it implemented in Kronos. First, it fetches appropriate numbers of\nthe syscalls from the system DLLs. As mentioned before, functions are identified by hashes\n[of their names (full mapping hash-to-function you can find in Lexsi report).](https://www.lexsi.com/securityhub/overview-kronos-banking-malware-rootkit/?lang=en)\n\nFor example:\n```\nB6F6X4A8R5D3A7C6 -> NtQuerySystemInformation\n\n```\nThe numbers of syscalls are stored in variables, xored with a constant. Fragment of the code\nresponsible for extracting raw syscalls from the DLL:\n\nIn order to use them further, for every used syscall Kronos implements its own wrapper\nfunction with an appropriate number of parameters. You can see an example below:\n\n\n-----\n\nThe EAX registry contains the number of the syscall. In the given example, it represents the\nfollowing function:\n```\n00000105 -> NtQuerySystemInformation\n\n```\nKronos uses raw syscalls to call the functions that are related to injections to other processes\nbecause they usually trigger alerts. Functions that are called by this way are listed below:\n```\nNtAllocateVirtualMemory\nNtCreateFile\nNtCreateSection\nNtGetContextThread\nNtOpenProcess\nNtProtectVirtualMemory\nNtQueryInformationProcess\nNtQuerySystemInformation\nNtResumeThread\nNtSetContextThread\nNtSetValueKey\n\n```\nIt matches the black market advertisement, stating: “The Trojan uses an undetected injection\n_[method” (source).](http://securityintelligence.com/the-father-of-zeus-kronos-malware-discovered/)_\n\n**Rootkit and the hooking engine**\n\nOne of the features that malware provides is a userland rootkit. Kronos hooks API of the\nprocesses so that they will not be able to notice its presence. The hooking is done by a\nspecially crafted block of the shellcode, that is implanted in each accessible running process.\n\nFirst, Kronos prepares the block of shellcode to be implanted. It fills all the necessary data:\naddresses of functions that are going to be used, and the data specific to the malware\ninstallation, that is intended to be hidden.\n\nThen, it searches through the running processes and tries to make injection wherever it is\npossible. Interestingly, explorer.exe and chrome.exe are omitted:\n\n\n-----\n\nThe shellcode is deployed in a new thread within the infected process:\n\nBelow you can see the shellocode inside the memory of the infected process:\n\nWhen it runs, it hooks the following functions in the address space of the infected process:\n\n\n-----\n\n```\nZwCreateFile\nNtOpenFile\nZwQueryDirectoryFile\nNtEnumerateValueKey\nRtlGetNativeSystemInformation\nNtSetValueKey\nZwDeleteValueKey\nZwQueryValueKey\nNtOpenProcess\n\n```\nThe interesting thing about this part of Kronos is its similarity with a hooking engine\n[described by MalwareTech on his blog in January 2015. Later, he](https://www.malwaretech.com/2015/01/inline-hooking-for-programmers-part-2.html) complained in his tweet,\nthat cybercriminals stolen and adopted his code. Looking at the hooking engine of Kronos we\ncan see a big overlap, that made us suspect that this part of Kronos could be indeed based\n[on his ideas. However, it turned out that this technique was described much earlier (i.e. here,](http://www.rohitab.com/discuss/topic/33771-patch-hook/?p=10062694)\n_//thanks to_ _[@xorsthings for the link ), and both authors learned it from other sources rather](https://twitter.com/xorsthings)_\nthan inventing it.\n\nLet’s have a look at the technique itself. During hooking, one may experience concurrency\nissues. If a half-overwritten function will start to be used by another thread, the application\nwill crash. To avoid this, it is best to install a hook by a single assembly instruction.\nMalwareTech’s engine used for this purpose an instruction lock cmpxch8b. Similar\nimplementation can be found in Kronos.\n\nThe hooking function used by Kronos takes two parameters – the address of the function to\nbe hooked, and the address of function used as a proxy. This is the fragment of the\nimplanted shellcode where the hooking function is being called:\n\n\n-----\n\nFirst, the hooking function searches the suitable place in the code of the attacked function,\nwhere the hook can be installed:\n\n\n-----\n\nThe above code is an equivalent of the following:\n\n[https://github.com/MalwareTech/BasicHook/blob/master/BasicHook/hook.cpp#L103](https://github.com/MalwareTech/BasicHook/blob/master/BasicHook/hook.cpp#L103)\n\nThen, it installs the hook:\n\n\n-----\n\nAs we can see, the used method of installing hook is almost identical to:\n\n[https://github.com/MalwareTech/BasicHook/blob/master/BasicHook/hook.cpp#L77](https://github.com/MalwareTech/BasicHook/blob/master/BasicHook/hook.cpp#L77)\n\nBelow you can see an example of Kronos hooking a function ZwResumeThread in the\nmemory of the attacked process. Instruction lock cmpxch8b is indeed used to overwrite the\nfunction’s beginning:\n\nAfter the hook installation, whenever the infected process calls the hooked function, the\nexecution is redirected to the proxy code inside the malicious module:\n\n\n-----\n\nThe hooking engine used in Kronos is overall more sophisticated. First of all, even the fact\nthat it is a shellcode not a PE file makes a difficulty level of implementing it higher. The\nauthor must have taken care of filling all the functions addresses by his own. But also, the\nauthor of Kronos shown some more experience in predicting possible real-life scenarios. For\nexample, he took additional care for checking if the code was not already hooked (i.e. by\nother Trojans or monitoring tools):\n\n**Attacking browsers**\n\nThe malware injects into a browser an additional module (injlib-client.dll). Below we can see\nan example of the DLL injected into Firefox address space:\n\n\n-----\n\nThe malware starts the injected module with the help of the injected shellcode:\n\nWe can see some API redirections added by the malware. Some of the functions imported by\nthe attacked browser are hooked so that all the data that passes through them is tapped by\nthe Kronos module.\n\nThe data that is being grabbed using the hooked browser API is then sent to the main\nmodule, that is coordinating malware’s work and reporting to the CnC server.\n\n## Conclusion\n\nAn overall look at the tricks used by Kronos shows that the author has a prior knowledge in\nimplementing malware solutions. The code is well obfuscated, and also uses various tricks\nthat requires understanding of some low-level workings of the operating system. The author\nnot only used interesting tricks, but also connected them together in a logical and fitting way.\nThe level of precision lead us to the hypothesis, that Kronos is the work of a mature\ndeveloper rather than an experimenting youngster\n\n\n-----\n\n[Malwarebytes users are protected against the Kronos malware.](https://www.malwarebytes.com/)\n\n## Appendix\n\n[“Overview of the Kronos banking malware rootkit” by Lexsi](https://www.lexsi.com/securityhub/overview-kronos-banking-malware-rootkit/?lang=en)\n\n[Decrypting the configuration](https://www.lexsi.com/securityhub/kronos-decrypting-the-configuration-file-and-injects/?lang=en)\n\nSee also:\n\n[Inside the Kronos malware – part 2](https://blog.malwarebytes.com/cybercrime/2017/08/inside-kronos-malware-p2/)\n\nThis video cannot be displayed because your Functional Cookies are currently disabled.\n[To enable them, please visit our privacy policy and search for the Cookies section. Select](https://www.malwarebytes.com/privacy/#how-we-collect-information)\n_“Click Here” to open the Privacy Preference Center and select “Functional Cookies” in the_\nmenu. You can switch the tab back to “Active” or disable by moving the tab to “Inactive.”\nClick “Save Settings.”\n\n_This was a guest post written by Hasherezade, an independent researcher and programmer_\n_with a strong interest in InfoSec. She loves going in details about malware and sharing threat_\n_[information with the community. Check her out on Twitter @hasherezade and her personal](https://twitter.com/hasherezade)_\n_[blog: https://hshrzd.wordpress.com.](https://hshrzd.wordpress.com/)_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-08-18 - Inside the Kronos malware – part 1.pdf"
    ],
    "report_names": [
        "2017-08-18 - Inside the Kronos malware – part 1.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535985,
    "ts_updated_at": 1743041153,
    "ts_creation_date": 1653713809,
    "ts_modification_date": 1653713809,
    "files": {
        "pdf": "https://archive.orkl.eu/97b3b4133395aa95c39747a3cd2c71ff9a061ae4.pdf",
        "text": "https://archive.orkl.eu/97b3b4133395aa95c39747a3cd2c71ff9a061ae4.txt",
        "img": "https://archive.orkl.eu/97b3b4133395aa95c39747a3cd2c71ff9a061ae4.jpg"
    }
}