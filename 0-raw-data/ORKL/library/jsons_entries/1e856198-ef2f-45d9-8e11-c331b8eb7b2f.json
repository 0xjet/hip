{
    "id": "1e856198-ef2f-45d9-8e11-c331b8eb7b2f",
    "created_at": "2022-10-25T16:48:20.590338Z",
    "updated_at": "2025-03-27T02:15:24.763251Z",
    "deleted_at": null,
    "sha1_hash": "71d7d34f8e7bfcc2848cc0bdfa252ecfb7fb08d9",
    "title": "",
    "authors": "",
    "file_creation_date": "2020-12-04T12:07:40Z",
    "file_modification_date": "2020-12-04T12:07:42Z",
    "file_size": 2352998,
    "plain_text": "# TRICKBOT NOW OFFERS ‘TRICKBOOT’: PERSIST, BRICK, PROFIT\n\n### Researchers discover a new module in the TrickBot toolset aimed at detecting UEFI / BIOS firmware vulnerabilities\n\n\n#### EXECUTIVE SUMMARY\n\n[Collaborative research between Advanced Intelligence (AdvIntel)](https://www.advanced-intel.com/)\nand Eclypsium has discovered that the TrickBot malware now has\nfunctionality designed to inspect the UEFI/BIOS firmware of targeted\nsystems. This new functionality, which we have dubbed “TrickBoot,”\nmakes use of readily available tools to check devices for well-known\nvulnerabilities that can allow attackers to read, write, or erase the UEFI/\nBIOS firmware of a device.\n\nAt the time of writing, our research uncovered TrickBot performing\nreconnaissance for firmware vulnerabilities. This activity sets the stage\nfor TrickBot operators to perform more active measures such as the\ninstallation of firmware implants and backdoors or the destruction\n(bricking) of a targeted device. It is quite possible that threat actors are\nalready exploiting these vulnerabilities against high-value targets. Similar\n[UEFI-focused threats have gone years before they have been detected.](https://eclypsium.com/2020/10/14/protecting-your-organizations-from-mosaicregressor-and-other-uefi-implants/)\nIndeed, this is precisely their value to attackers.\n\nThis marks a significant step in the evolution of TrickBot. Firmware level\nthreats carry unique strategic importance for attackers. By implanting\nmalicious code in firmware, attackers can ensure their code is the first\nto run. Bootkits allow an attacker to control how the operating system\nis booted or even directly modify the OS to gain complete control over\na system and subvert higher-layer security controls. UEFI level implants\nare powerful and stealthy. Since firmware is stored on the motherboard\nas opposed to the system drives, these threats can provide attackers\nwith ongoing persistence even if a system is re-imaged or a hard drive\nis replaced. Equally impactful, if firmware is used to brick a device,\nthe recovery scenarios are markedly different (and more difficult) than\nrecovery from the traditional file-system encryption that a ransomware\ncampaign like Ryuk, for example, would require.\n\n\nTrickBot has proven to be one of the most adaptable pieces of malware\ntoday, regularly incorporating new functionality to escalate privilege,\nspread to new devices, and maintain persistence on a host. The addition\nof UEFI functionality marks an important advance in this ongoing\nevolution by extending its focus beyond the operating system of the\ndevice to lower layers that are often not inspected by security products\nand researchers.\n\nGiven that the TrickBot group toolset has been used by some of the\nmost dangerous criminal, Russian, and North Korean actors to target\nhealthcare, finance, telecoms, education, and critical infrastructure, we\nview this development as critically important to both enterprise risk and\nnational security. Adversaries leveraging TrickBot now have an automated\nmeans to know which of their latest victim hosts are vulnerable to UEFI\nvulnerabilities, much like they added capabilities in 2017 to exploit\nEternalBlue and EternalRomance vulnerabilities.\n\n#### CONTENTS:\n\nTrickBot Background .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 2\n\nTrickBot Actor Insights .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 3\n\nDiscovery of New TrickBoot Functionality .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 4\nTechnical Analysis .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 4\n\nOverview of the Boot Process,\nSPI Controller, and UEFI Firmware .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 7\n\nTrickBoot Implications .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 7\n\nTrickBoot Technical Details .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 8\n\nMitigation .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 19\n\nConclusion .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  19\n\nTrickBoot IOCs .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  20\n\n\n-----\n\n#### TRICKBOT BACKGROUND\n\nTrickBot is a highly modular trojan that is particularly notable for its\nability to gain administrator privileges, spread within a network, and\ndeliver additional malware payloads. Originally identified in 2016,\nTrickBot was initially focused on stealing financial data and was\nconsidered a banking trojan. However, as the malware evolved, attackers\nquickly found that it was a valuable enabler in all types of malware\ncampaigns. Notably, TrickBot has been widely observed working in\n[conjunction with Emotet to deliver Ryuk ransomware.](https://www.youtube.com/watch?v=u1XvMcwdvgI&feature=youtu.be&t=310)\n\nTrickBot includes several key features that make it valuable for\npersistent malware campaigns. The tool is able to capture user and\n[admin credentials using Mimikatz and has incorporated UAC bypass](https://www.bleepingcomputer.com/news/security/trickbot-uses-a-new-windows-10-uac-bypass-to-launch-quietly/)\n[techniques to ensure it can run with administrator privileges on an](https://www.bleepingcomputer.com/news/security/trickbot-uses-a-new-windows-10-uac-bypass-to-launch-quietly/)\n\n\ninfected host without alerting the user. TrickBot also makes use of the\nEternalBlue exploit (MS17-010) to spread to additional hosts in the\nnetwork via SMB. These capabilities make TrickBot an ideal dropper for\nalmost any additional malware payload. By adding the ability to canvas\nvictim devices for specific UEFI/BIOS firmware vulnerabilities, TrickBot\nactors are able to target specific victims with firmware-level persistence\nthat survives re-imaging or even device bricking capability.\n\nThe following graphics show the last two months of active TrickBot\ninfections, peaking at up to 40,000 in a single day. Getting a footprint\nis not a challenge for TrickBot operators. Determining which victims\nare high-value targets and persisting in those environments to hit them\nagain later defines a large portion of the TrickBot toolset and frames the\nsignificance of this discovery.\n\n\n**Credit: AdvIntel**\n\n**Count**\n\n1—10,547.5\n\n10,547.5–21,094\n\n21,094–31,640.5\n\n31,640.5–42,187\n\n\n_The number of Active TrickBot infections globally, post-TrickBot take-down attempts by cyber vendors and US Cyber Command, based on ISP geo._\n\n\n**Credit: AdvIntel**\n\n\n-----\n\n#### TRICKBOT ACTOR INSIGHTS\n\nWhile TrickBot as a malware toolset has been used by a diverse set\nof actors, there is one group that drives the majority of its use and is\nworth providing insights on in the context of this research in order to\nemphasize how powerful and successful TrickBot-based campaigns are.\nThe group’s alias is “Overdose,” and they are the primary Platform-as-aService fraud group behind TrickBot campaigns, namely those that result\n\n**Bank Fraud**\n\n**Money Drops** **Wire Transfers** **Account**\n**Takeover**\n\nTheir most common attack chain largely begins via EMOTET malspam\ncampaigns, which then loads TrickBot and/or other loaders, and moves\nto attack tools like PowerShell Empire or Cobalt Strike to accomplish\nobjectives relative to the victim organization under attack. Often, at the\nend of the kill-chain, either Conti or Ryuk ransomware is deployed.\n\n[The same actor also uses LightBot, which is a set of PowerShell scripts](https://www.bleepingcomputer.com/news/security/lightbot-trickbot-s-new-reconnaissance-malware-for-high-value-targets/)\ndesigned to perform reconnaissance on victim networks, hardware, and\n\n\n[in Conti and Ryuk ransomware. The group has made at least $150m](https://www.bleepingcomputer.com/news/security/how-ryuk-ransomware-operators-made-34-million-from-one-victim/)\n[since 2018 and recently extracted ~$34m (2,200 BTC) from a single](https://www.bleepingcomputer.com/news/security/how-ryuk-ransomware-operators-made-34-million-from-one-victim/)\n[victim. This is the same group behind a spate of attacks on Healthcare](https://www.advanced-intel.com/post/anatomy-of-attack-inside-bazarbackdoor-to-ryuk-ransomware-one-group-via-cobalt-strike)\nvictims, including that of UHS. No direct attribution has been made\nas to their identity, other than they are Russian-speaking and Eastern\nEuropean. As can be seen in the graphic below, they participate in a\nnumber of criminal/fraud-related activities.\n\n**Data Theft** **Cryptomining**\n\n**Personal** **Financial**\n**Info Theft** **Info Theft**\n\n**Source: AdvIntel**\n\nsoftware, in order to hand-pick which are high-value targets. It is clear\nthat such actors would benefit greatly from including a UEFI level bootkit\nin their kill chain. They would survive system re-imagining efforts during\nthe recovery phase of a Ryuk or Conti event, and they would further their\nability to semi-permanently brick a device. This provides criminal actors\nmore leverage during ransom negotiation.\n\n\n-----\n\nWith this module, the TrickBot kill chain is primed with a list of\nvulnerable targets for firmware-level compromise. The malware authors\ncan leverage Emotet to malspam organizations and use TrickBoot to\nunderstand where and how to target the UEFI firmware. Ryuk and Conti\nmalware operators often offer to remove backdoors in an enterprise\nif the ransom is paid. With this new module, these actors can remove\nbackdoors like webshells, accounts, remote admin tools but keep a\ncovert UEFI implant on the system to leverage later.\n\n### Typical Trickbot Killchain\n\n**PowerShell Empire** **Conti Ransomware**\n\n**Trickbot Malware**\n\n**Source: AdvIntel** **Cobalt Strike** **Ryuk Ransomware**\n\n#### DISCOVERY OF NEW TRICKBOOT FUNCTIONALITY\n\nCollaborative research between Advanced Intelligence (AdvIntel) and\nEclypsium has discovered new TrickBot functionality capable of probing\nthe UEFI/BIOS firmware for nearly all Intel-based systems since 2014.\nThe new functionality, which we have dubbed “TrickBoot,” leverages\nreadily available tools to enable the following reconnaissance actions:\n\n**• \u0007Identify the device platform**\n\n**• \u0007Check the status of BIOS write protections for the SPI flash**\n\n**• \u0007Check for well-known vulnerabilities that can allow attackers to**\nread, write, or erase UEFI/BIOS firmware.\n\nThus far, the TrickBot module is only performing reconnaissance and\nhas not been seen modifying the firmware itself. However, the malware\nalready contains code to read, write, and erase firmware. These\nprimitives could be used to insert code to maintain persistence, as has\nbeen seen previously with the LoJax or MosaicRegressor. Attackers\n\n\ncould also simply erase the BIOS region to completely disable the\ndevice as part of a destructive attack or ransomware campaign. The\npossibilities are almost limitless.\n\nTrickBot has a history of reusing established tools and exploits such as\nMimikatz and EternalBlue, and the malware is taking a similar approach\nto achieving persistence. Specifically, TrickBoot uses the RwDrv.sys\ndriver from the popular RWEverything tool in order to interact with the\nSPI controller to check if the BIOS control register is unlocked and the\ncontents of the BIOS region can be modified. TrickBoot includes an\nobfuscated copy of RwDrv.sys embedded within the malware itself. It\ndrops the driver into the Windows directory, starts the RwDrv service, and\nthen makes DeviceIoControl calls to talk to the hardware.\n\nRWEverything (read-write everything) is a powerful tool that can allow\nan attacker to write to the firmware on virtually any device component,\nincluding the SPI controller that governs the system UEFI/BIOS. This\ncan allow an attacker to write malicious code to the system firmware,\nensuring that attacker code executes before the operating system while\nalso hiding the code outside of the system drives. These capabilities have\nbeen abused in the past as a way for attackers to maintain persistence\n[in firmware, most notably by the LoJax malware and the Slingshot APT](https://www.trendmicro.com/vinfo/us/security/news/cyber-attacks/lojax-uefi-rootkit-used-in-cyberespionage)\ncampaign. However, TrickBoot marks a significant expansion of these\ntechniques in the wild.\n\n#### TECHNICAL ANALYSIS\n\nAs is often the case with new TrickBot modules, the name “PermaDll” or\nthe original name as “user_platform_check.dll” caught the attention of\nAdvanced Intelligence researchers during the October 2020 discovery\nof the new TrickBot attack chain. “Perma,” sounding akin to “permanent,”\nwas intriguing enough on its own to want to understand this module’s role\nin TrickBot’s newest arsenal of loadable modules with the usual TrickBot\nexport modules. Initial analysis pointed to the possibility there might\nbe capabilities related to understanding whether a victim system’s UEFI\nfirmware could be attacked for purposes of persistence or destruction. A\njoint collaboration was started with Eclypsium to analyze this module and\nto put whatever was found into context for defenders. During the initial\ndiscovery of this new module on October 19, 2020, the team processed\nthe encoded “permaDll32”. They leveraged a custom-built AES encryption\nTrickBot module decrypter, which revealed the decoded module that\nbecame the subject of this in-depth analysis and discovery.\n\n\n-----\n\nIt took over five years for the industry to discover the use of Hacking Team’s VectorEDK UEFI implant code that was used in the wild as part of the\nMosaicRegressor campaign, despite the source code being readily available on github and even documented in its use. Given how active, well-resourced,\nand capable TrickBot authors are, we wanted to research, analyze, and expose whatever tooling they already have in place in order to allow organizations\nto prepare effective defenses more rapidly.\n\nThe malware module outputs “PCH” queries based on the string slicing obfuscation.\n\n\n-----\n\nThe “permaDll” module checks for administrator privileges with the output “Not Admin.”\n\n\n-----\n\n#### OVERVIEW OF THE BOOT PROCESS, SPI CONTROLLER, AND UEFI FIRMWARE\n\nThe boot process governs how a system and its components are\ninitialized and coordinates the loading of the operating system, making\nit one of the most fundamentally important aspects of security for any\ndevice. The code supporting the boot process is the first code executed\n[on a system and is likewise some of the most privileged code, requiring](https://eclypsium.com/2019/10/23/protecting-system-firmware-storage/)\n[protection even from privileged operating system (OS) code. If the boot](https://eclypsium.com/2019/10/23/protecting-system-firmware-storage/)\nprocess is compromised, attackers gain control over the OS itself and\nestablish ongoing persistence on the device even if the OS is reinstalled.\n\nThe boot process begins in the SPI flash memory chip that is built into\nthe motherboard of the device. The SPI contains the system’s BIOS,\nor more often, UEFI firmware, which has largely replaced BIOS as the\ndefault system firmware in modern systems. This UEFI firmware will\ncontrol the boot process and ultimately select the appropriate OS\nbootloader and execute the initial OS code before handing control over\nto the operating system itself.\n\nAll requests to the UEFI firmware stored in the SPI flash chip go through\nthe SPI controller, which is part of the Platform Controller Hub (PCH) on\nIntel platforms. This SPI controller includes access control mechanisms,\nwhich can be locked during the boot process in order to prevent\nunauthorized modification of the UEFI firmware stored in the SPI flash\nmemory chip. Modern systems are intended to enable these BIOS write\nprotections to prevent the firmware from being modified; however, these\nprotections are often not enabled or misconfigured. If the BIOS is not\nwrite-protected, attackers can easily modify the firmware or even delete\nit completely.\n\nMore broadly, any time an actor can write to SPI flash, there are a\nnumber of extremely useful things that can be accomplished from the\nattacker’s perspective:\n\n**• \u0007Bricking a device at the firmware level via a remote malware or**\nransomware campaign.\n\n**• \u0007Re-infecting a device that’s just been through a traditional system**\nrestore process.\n\n**• \u0007Bypassing or disabling security controls that OS and software**\nrely upon, such as virtualization and container-based security\nisolation, credentials isolation, software-based full-disk\nencryption, and other endpoint and identity protection controls.\n\n**• \u0007Chaining exploitation of other device components such as Intel**\nCSME/AMT firmware or Baseboard Management Controllers.\n\n**• \u0007Rolling back important firmware and microcode updates patching**\nhardware flaws like CPU transient execution vulnerabilities.\n\n.\n\n\n#### TRICKBOOT IMPLICATIONS\n\nThe TrickBot malware toolkit has a broad impact on national security.\nUsed by criminal, Russian, and North Korean actors, it is widely deployed\nand benefits from the most widespread malspam apparatus of our day:\nEmotet. In a single day in October, 40,000 active, fully compromised\ndevices were observed. Because it is offered only to the most vetted\nand well-funded actors, it has been forged into what can best be\ndescribed as an arsenal of capability, integrating powerful exploitation\ncapabilities like EternalBlue and EternalRomance to help it worm through\nnetworks and leveraging PowerShell to perform extremely effective\nreconnaissance to determine high-value targets. It does this with agility,\nstealth, and the ability to incorporate specific modules only as needed\nto accomplish campaign objectives without tipping its hat to defenders.\nOrganizations should note the following considerations when assessing\nthe impact of the new TrickBoot capability:\n\n**1. \u0007This new capability provides TrickBot operators a way to brick**\nany device it finds to be vulnerable. Recovering from corrupted\nUEFI firmware requires replacing or re-flashing the motherboard,\nwhich is more labor-intensive than simply re-imagining or\nreplacing a hard drive. The new TrickBoot module targets all\nIntel-based systems produced in recent years. While it looks for\na particular type of known vulnerability in how system firmware\nis protected in persistent SPI flash, UEFI is a very complex\nfirmware implementation with many vulnerabilities discovered\nin recent years, which makes the majority of the systems in use\ntoday susceptible to this threat.\n\n**2. \u0007Historically, TrickBot actors have needed to evade and persist**\nat the operating system level. But this has become a ‘race\nagainst time,’ as eventually today’s AV and EDR tools catch up\nto the actor at the OS layer. Once UEFI persistence is achieved,\nTrickBot operators can disable most of the OS level security\ncontrols, which then allows them to re-surface to a modified OS\nwith neutered endpoint protections and carry out objectives with\nunhurried time on their side.\n\n**3. \u0007Normally an actor wanting to gain UEFI level access needs**\nto plan, customize, and build attack tools to target a specific\nvictim environment. But with TrickBoot, actors can simply ‘land’\non tens of thousands of hosts per day and extract which of them\nare inside a high-value target organization and vulnerable to\nUEFI attacks.\n\n**4. \u0007Actors are going lower in the stack to avoid detection. The same**\nactors (APT28) behind the DNC hack in 2016 also deployed\nLoJax, a UEFI implant with a similar infection method and use\nof the same vulnerability this TrickBoot module looks for. The\ndifference here is that TrickBot’s modular automated approach,\n\n\n-----\n\nrobust infrastructure, and rapid mass-deployment capabilities\nbring a new level of scale to this trend. This scale allows threat\nactors to target verticals or portions of critical infrastructure with\ndestructive or espionage campaigns.\n\n**5. \u0007Most organizations and missions are not tooled to be able to**\ndetect, let alone mitigate, this class of firmware threat. It is\nprecisely, for this reason, that threat actors push further down\nthe stack. This means that as a nation, neither our proactive\nor reactive efforts are likely sufficient to get ahead of this\nnew threat. Our hope is that this discovery, research, and\nrecommended mitigations help elevate the awareness needed to\naddress this global threat head-on.\n\n#### TRICKBOOT TECHNICAL DETAILS\n\nBoth 32-bit and 64-bit versions of this new TrickBot module have been\nobserved so far.\n\nBoth versions appear to be functionally the same, but for this analysis,\nwe’ll be using addresses and code samples from the 32-bit version.\n\n**OBFUSCATION TECHNIQUES**\n\nTrickBot uses the string and library-call obfuscation library from\n[https://github.com/andrivet/ADVobfuscator, so most strings in the DLL](https://github.com/andrivet/ADVobfuscator)\nare obfuscated. This module does not use the library-call obfuscation,\n\n\nbut other TrickBot samples have been found to use that feature.\n\nRather than including obfuscated strings in the data section of the\nexecutable, all strings are encoded as inline instructions to write\nobfuscated strings to local stack frame buffers and then immediately\ndecode them at the time of use.\n\nSeveral variants of this obfuscation method are used within this sample,\nand each string has its own unique “key” value that is used to modify\neach byte of the string. Variants observed in this sample include:\n\n**• \u0007subtracting the key value from each byte**\n\n**• \u0007xoring the key value against each byte**\n\n**• \u0007adding the key value to the index into the string and xoring that**\nagainst each byte\n\nA fourth variant, which uses dec to subtract one from each byte, was\nalso found within the sample, but this is likely a compiler optimization of\nthe subtract case when the value of 1 was chosen as the random key at\ncompile time.\n\nSome previous TrickBot samples included this string-building and\ndeobfuscation code inline within each function everywhere obfuscated\nstrings are used, but this sample has many copies of the deobfuscation\nfunctions. Most are used to decode only a single string, but these can be reused when strings are the same length, and the same variant is being used.\n\n\n-----\n\nThe deobfuscation variants look like this:\n\n\n-----\n\nIn addition to the obfuscated strings, this sample includes a copy of the RwDrv.sys driver from RWEverything which is simply xored against a hardcoded\nvalue. This value is 0x75 in the 32-bit sample and 0x4E in the 64-bit sample. The function to decode the driver and drop it into the Windows directory is at\n0x10009F9D, and we’ll refer to it as “decode_and_drop_rwdrvsys.”\n\n\n**RWDRV.SYS KERNEL DRIVER AND OTHER PRIMITIVES**\n\nRwDrv.sys is a well-known kernel driver that acts as a privileged proxy\nto allow userspace applications to directly access hardware interfaces.\nIt has been used in the wild as part of attack campaigns such as\nLojax to talk to the SPI controller hardware in order to modify the\nUEFI firmware by inserting new UEFI modules and gain pre-boot code\nexecution and persistence.\n\nThis type of kernel driver is particularly dangerous because allowing user\nspace applications direct access to hardware interfaces can bypass\noperating security controls and gain privilege escalation, persistence, and\n[even brick the hardware itself. As part of a previous research effort, we](https://eclypsium.com/2019/08/10/screwed-drivers-signed-sealed-delivered/)\nidentified a large number of these signed drivers which can be used in\nthis type of attack scenario and which generally give malware operators\nthe ability to remotely perform firmware level attacks on victim hosts.\n\nAdditionally, 0x10009BFC, which we’ll refer to as “open_or_init_driver”\nis a helper function which calls decode_and_drop_rwdrvsys and also\nseveral other helper functions to load the driver, create a Windows\nservice, and open a handle to the RwDrv service.\n\nSince this sample doesn’t use the library-call obfuscation provided by\nADVobfuscator, all of the calls to DeviceIoControl are in-the-clear and\neasy to find. Thus, we can take a closer look at these functions and\ndeobfuscate the strings they contain.\n\nAs an example, 0x1000B167 contains the obfuscated string “uefi_expl_\nport_read() ERROR: Not initialized”. This code is from Dmytro Oleksiuk’s\n[fwexpl repository available at https://github.com/Cr4sh/fwexpl. In](https://github.com/Cr4sh/fwexpl)\nparticular, this sample includes functions from\n\n\n[https://github.com/Cr4sh/fwexpl/blob/master/src/libfwexpl/src/](https://github.com/Cr4sh/fwexpl/blob/master/src/libfwexpl/src/libfwexpl_rwdrv.cpp)\n[libfwexpl_rwdrv.cpp in order to use the RwDrv.sys driver to access](https://github.com/Cr4sh/fwexpl/blob/master/src/libfwexpl/src/libfwexpl_rwdrv.cpp)\nhardware interfaces.\n\n[The functions from libfwexpl_rwdrv.cpp which are included in this](https://github.com/Cr4sh/fwexpl/blob/master/src/libfwexpl/src/libfwexpl_rwdrv.cpp)\nTrickBot sample are:\n\n**0x1000B167 uefi_expl_port_read**\n\n**• \u0007Uses DeviceIoControl call to rwdrv.sys to read data from**\nhardware IO ports\n\n**• \u0007Supports reading 8-bit (ioctl 0x222810), 16-bit (ioctl 0x222818),**\nand 32-bit (ioctl 0x222820) values\n\n**0x1000B4AC uefi_expl_port_write**\n\n**• \u0007Uses DeviceIoControl call to rwdrv.sys to write data to hardware**\nIO ports\n\n**• \u0007Supports writing 8-bit (ioctl 0x222814), 16-bit (ioctl 0x22281c),**\nand 32-bit (ioctl 0x222824) values.\n\n**0x1000A4BA uefi_expl_phys_mem_read**\n\n**• \u0007Uses DeviceIoControl call to rwdrv.sys to read from physical**\nmemory addresses\n\n**• \u0007Can read data from arbitrary physical memory addresses via ioctl**\n0x222808\n\n**0x1000A973 uefi_expl_phys_mem_write**\n\n**• \u0007Uses DeviceIoControl call to rwdrv.sys to write to physical**\nmemory addresses\n\n**• \u0007Can write data to arbitrary physical memory addresses via ioctl**\n0x22280c\n\n\n-----\n\n**PLATFORM MODEL AND HARDWARE IDENTIFICATION**\n\nThe PCI access functions in the fwexpl repository require the user to\ncalculate the legacy PCI configuration address to be used rather than\ntaking bus, device, function and register arguments, so two additional\nhelper functions were added to make it easier to use:\n\n**0x1000A3FD pci_read_reg**\n\n**• \u0007Uses uefi_expl_port_write and uefi_expl_port_read to read PCI**\nregisters via legacy PCI Configuration Access Mechanism (ports\n0xCF8 and 0xCFC)\n\n**0x1000A45A pci_write_reg**\n\n**• \u0007Uses uefi_expl_port_write to write PCI registers via legacy PCI**\nConfiguration Access Mechanism (ports 0xCF8 and 0xCFC)\n\nBuilding on top of these hardware-access primitives, the sample contains\nadditional helper functions to perform a number of interesting operations\nsuch as 0x100093C7, which we’ll refer to as “identify_platform.”\n\nThis function uses pci_read_reg to read VendorID, DeviceID, and\nRevisionID fields from the CPU Root Complex (BDF 0:0.0) and Platform\nController Hub (PCH) LPC Interface (BDF 0:1F.0). Reading these allows\npermaDll32 to determine which specific model of CPU and PCH the\ndevice is running on.\n\npci_read_reg(0, 0, 0, 0, 2, &cpu_vid_did);\n\npci_read_reg(0, 0, 0, 8, 0, &cpu_rid);\n\npci_read_reg(0, 31, 0, 0, 2, &pch_vid_did);\n\npci_read_reg(0, 31, 0, 8, 0, &pch_rid);\n\nThe locations of registers for the SPI controller have changed over the\ngenerations of Intel PCH, and another function, 0x1000C00F, which we’ll\nrefer to as “pch_did_to_generation,” compares the PCH Device ID that\nwas read from the hardware against a collection of known DeviceID\nvalues to determine which generation of PCH the code is running on.\n\nGenerally, this malware will attempt to run on all Intel platforms. This\nset of device IDs is used to determine where to look for the BIOS\nControl register, the Flash Protected Range registers, and SPIBAR.\nThe set of device IDs it looks for covers client platforms from Skylake\nthrough Comet Lake and also the C620 Series of Server PCH. If the\ndevice ID is something not on this list, the malware will use the preSkylake register definitions. The tables of PCH Device IDs included in\nthis sample are the following:\n\n\n**0x1002402C 100 Series PCH DIDs (Skylake):**\n\n0xA143: Intel H110 (100 series) PCH\n0xA144: Intel H170 (100 series) PCH\n0xA145: Intel Z170 (100 series) PCH\n0xA146: Intel Q170 (100 series) PCH\n0xA147: Intel Q150 (100 series) PCH\n0xA148: Intel B150 (100 series) PCH\n0xA149: Intel C236 (100 series) PCH\n0xA14A: Intel C232 (100 series) PCH\n0xA14D: Intel CQM170 (100 series) PCH\n0xA14E: Intel HM170 (100 series) PCH\n0xA150: Intel CM236 (100 series) PCH\n0xA151: Intel QMS180 (100 series) PCH\n0xA152: Intel HM175 (100 series) PCH\n0xA153: Intel QM175 (100 series) PCH\n0xA154: Intel CM238 (100 series) PCH\n0xA155: Intel QMU185 (100 series) PCH\n0x9D43: PCH-U Baseline\n0x9D43: PCH-U Baseline\n\n**0x10024050 200 Series PCH DIDs (Kaby Lake):**\n\n0xA2C4: Intel H270 (200 series) PCH\n0xA2C5: Intel Z270 (200 series) PCH\n0xA2C6: Intel Q270 (200 series) PCH\n0xA2C7: Intel Q250 (200 series) PCH\n0xA2C8: Intel B250 (200 series) PCH\n0xA2C9: Intel Z370 (200 series) PCH\n0xA2D2: Intel X299 (200 series) PCH\n\n**0x10024060: 300 Series PCH DIDs (Coffee Lake):**\n\n0xA306: Intel Q370 (300 series) PCH\n0xA304: Intel H370 (300 series) PCH\n0xA305: Intel Z390 (300 series) PCH\n0xA308: Intel B360 (300 series) PCH\n0xA303: Intel H310 (300 series) PCH\n0xA30D: Intel HM370 (300 series) PCH\n0xA30C: Intel QM370 (300 series) PCH\n0xA30E: Intel CM246 (300 series) PCH\n0x9D4B: PCH-Y with iHDCP 2.2 Premium\n0x9D4E: PCH-U with iHDCP 2.2 Premium\n0x9D50: PCH-U with iHDCP 2.2 Base\n0x9D53: PCH-U Base\n0x9D56: PCH-Y Premium\n0x9D58: PCH-U Premium\n0x9D84: Intel 300 series On-Package PCH\n\n\n-----\n\n**0x10024080 400 Series PCH DIDs (Comet Lake):**\n\n0xA3C8: 400 series PCH B460\n0xA3DA: 400 series PCH H410\n0x068D: 400 series PCH (CML-H) HM470\n0x068E: 400 series PCH (CML-H) QM490\n0x069A: 400 series PCH (CML-H) H420E\n0x0284: Intel 400 series PCH-LP Prem-U\n0x0285: Intel 400 series PCH-LP Base-U\n0x3481: Intel 495 series PCH-LP U\n0x3482: Intel 495 series PCH-LP Prem-U\n0x3486: Intel 495 series PCH-LP Y\n0x3487: Intel 495 series PCH-LP Prem-Y\n\n**0x10024098 C620 Series Server PCH DIDs:**\n\n0xA1C1: Intel C621 (C620 series) PCH\n0xA1C2: Intel C622 (C620 series) PCH\n0xA1C3: Intel C624 (C620 series) PCH\n0xA1C4: Intel C625 (C620 series) PCH\n0xA1C5: Intel C626 (C620 series) PCH\n0xA1C6: Intel C627 (C620 series) PCH\n0xA1C7: Intel C628 (C620 series) PCH\n0xA1CA: Intel C629 (C620 series) PCH\n0xA242: Intel C624 (C620 series) PCH\n0xA243: Intel C627 (C620 series) PCH\n0xA244: Intel C621 (C620 series) PCH\n0xA245: Intel C627 (C620 series) PCH\n0xA246: Intel C628 (C620 series) PCH\n\n**TARGET-SPECIFIC HARDWARE RESOURCE CONFIGURATION**\n\nOnce the code has determined which generation of PCH it’s running\non, it uses the function at 0x1000C0A2, which we’ll refer to as\n“get_regs_from_generation” to know where to access these registers:\n\n**•** **\u0007SPIBAR (Base Address Register for MMIO access to SPI**\ncontroller registers)\n\n– \u0007This register is used to gain access to additional SPI\ncontroller MMIO registers beyond those in PCI Configuration\nSpace.\n\n**•** **\u0007BC (BIOS Control)**\n\n– \u0007This register contains write-protect and lock bits to control\naccess to the BIOS Region at the hardware level.\n\n\nThe code has two copies of the 400 Series PCH DID entries and checks\nthe current PCH DID against both, which appears to be a bug, but does\nnot cause functional problems.\n\n**0x100240B4 Copy of 400 Series PCH DIDs (Comet Lake):**\n\n0xA3C8: 400 series PCH B460\n0xA3DA: 400 series PCH H410\n0x068D: 400 series PCH (CML-H) HM470\n0x068E: 400 series PCH (CML-H) QM490\n0x069A: 400 series PCH (CML-H) H420E\n0x0284: Intel 400 series PCH-LP Prem-U\n0x0285: Intel 400 series PCH-LP Base-U\n0x3481: Intel 495 series PCH-LP U\n0x3482: Intel 495 series PCH-LP Prem-U\n0x3486: Intel 495 series PCH-LP Y\n0x3487: Intel 495 series PCH-LP Prem-Y\n\n**•** **\u0007PR0-PR4 (Flash Protected Ranges)**\n\n– \u0007These registers each contain Base, Limit, Write Protection\nEnable, and Read Protection Enable, which can be used to\nenforce additional access controls at a more granular level\nthan that provided by the BIOS Control register and the SPI\nFlash Descriptor.\n\nIf the TrickBot module is running on a PCH that was not included in\nthe set of lookup tables in pch_did_to_generation, this function uses a\npre-Skylake set of default values for the hardware-access operations\nthat follow.\n\nNow that the malware knows where to find these SPI controller registers,\nthere are some additional helper functions which can be used to check\nthe state of the BIOS Region protections and perform SPI operations to\nthe external flash chip:\n\n\n-----\n\n**0x1000948D read_bios_control_reg**\n\n**•** **\u0007This uses pci_read_reg to read and return the current value of the BIOS Control register**\n\n```\nunsigned long long read_bios_control_reg()\n{\n unsigned long long bc_value;\n bc_value = 0;\n if ( !pci_read_reg(reg_bc.bus,\n                    reg_bc.dev,\n                    reg_bc.func,\n                    reg_bc.reg,\n                    2,\n                    &bc_value) )\n  bc_value = 0;\n return bc_value;\n}\n\n```\n\n**0x10009386 is_bios_locked**\n\n**•** **\u0007This uses read_bios_control_reg to read the BIOS Control register and check if the Lock Enabled (LE) bit is set.**\n\n```\nbool is_bios_locked()\n{\n return (read_bios_control_reg() >> 1) & 1;\n}\n\n```\n\n**0x1000947E is_smm_bios_protection_enabled**\n\n**•** **\u0007This uses read_bios_control_reg to read the BIOS Control register and checks if the Enable InSMM.STS (EISS) bit, which was previously known**\nas SMM BIOS Write Protection (SMM_BWP), is set. When this bit is set, the BIOS region is not writable regardless of the state of the WPD (Write\nProtect Disable) bit, which is also in the BIOS Control register unless the process is running in System Management Mode and sets the InSMM.STS\nbit (0xFED30880[0]).\n\n**•** **\u0007One detail to keep in mind here is that even if the SMM Bios Write Protection bit is enabled, it doesn’t necessarily mean that it’s not possible to**\nwrite to the BIOS Region. There have been many issues with buggy SMI handlers that leave the system vulnerable during the firmware update\nprocess or enable arbitrary memory read/write as a “confused deputy”.\n\n```\nbool is_smm_bios_protection_enabled()\n{\n return (read_bios_control_reg() >> 5) & 1;\n}\n\n```\n\n-----\n\n**0x1000BA66 determine_spibar**\n\n**•** **\u0007This function uses pci_read_reg to read SPIBAR, which is the SPI Base Address Register, and points to the current physical address which is used**\nfor MMIO access to additional SPI controller registers.\n\n```\nvoid determine_spibar()\n{\n unsigned long long reg_value;\n reg_value = 0;\n pci_read_reg(reg_spibar.bus,\n                    reg_spibar.dev,\n                    reg_spibar.func,\n                    reg_spibar.reg,\n                    2,\n                    &reg_value);\n cur_spibar = reg_spibar.spibar_offset + (reg_value & reg_spibar.spibar_mask);\n}\n\n```\n\n**0x10009394 read_pr_reg**\n\n**•** **\u0007This function uses uefi_expl_phys_mem_read_qword to read the current contents of the requested Flash Protected Range register. This is used to**\ndetermine if additional protections have been enabled beyond that provided by the SPI Flash Descriptor and the BIOS Control register.\n\n```\nlong long read_pr_reg(unsigned char which_pr)\n{\n long long result;\n if ( which_pr <= 5 )\n  result = uefi_expl_phys_mem_read_qword(cur_spibar + pr_regs[which_pr]->reg);\n else\n  result = 0;\n return result;\n}\n\n```\n\n-----\n\n**0x1000B942 try_disable_bios_write_protection**\n\n**•** **\u0007This function checks if the BIOS Write Protection Disable (WPD) bit is set, tries to set it if it was previously unset, and reports the status to the caller.**\n\n**•** **\u0007Interestingly, there’s a bug here. This function tries to check if the EISS/SMM_BWP bit is set but incorrectly reads the BIOS Control register offset**\n(0xDC) from SPIBAR instead of from the LPC Interface (0:1F.0). This results in this code always thinking that the EISS/SMM_BWP bit is unset. It\nalso incorrectly attempts to set the WPD bit by writing to the BIOS Control register offset via SPIBAR in addition to PCI Config Space.\n\n–\u0007In Atom SoC platforms (Avoton, Cherrytrail, Baytrail, etc.), the BIOS Control register is in SPIBAR, but at a different offset (0xFC).\n\n```\nunsigned int try_disable_bios_write_protection()\n{\n unsigned int result;\n unsigned long long bc_val;\n // BUG HERE: Trying to read BIOS Control offset\n // from SPIBAR instead of PCI Config Space\n if ( uefi_expl_phys_mem_read_byte(cur_spibar + 0xDC) & 0x20 )\n  goto LABEL_10;\n // BUG HERE: Trying to write BIOS Control offset\n // via SPIBAR instead of PCI Config Space\n uefi_expl_phys_mem_write_byte_or_with_old(cur_spibar + 0xDC, 1u);\n bc_val = 0;\n // Read BIOS Control register and check if WPD bit is already set\n if ( pci_read_reg(reg_bc.bus,\n                reg_bc.dev,\n                reg_bc.func,\n                reg_bc.reg,\n                   2,\n                &bc_val) && !(bc_val & 1) )\n  // Try to set the WPD (Write Protect Disable) bit\n  // in BIOS Control register\n  pci_write_reg(\n   reg_bc.bus,\n   reg_bc.dev,\n   reg_bc.func,\n   reg_bc.reg,\n    2,\n   bc_val | 1);\n // Check if we were able to set the WPD bit\n pci_read_reg(reg_bc.bus,\n             reg_bc.dev,\n             reg_bc.func,\n             reg_bc.reg,\n               2,\n             &bc_val);\n if ( !(bc_val & 1) )\nLABEL_10:\n  result = 15;\n else\n  result = 0;\n return result;\n\n```\n\n-----\n\n**0x1000BA42 enable_bios_write_protection**\n\n**•** **\u0007This function attempts to set the BWP bit in the BIOS Control register but incorrectly writes to that offset via SPIBAR and not to the BC register in**\nPCI Configuration Space.\n\n```\nbool enable_bios_write_protection()\n{\n // BUG HERE: Trying to write BIOS Control offset via\n // SPIBAR instead of PCI Config Space\n return uefi_expl_phys_mem_clear_byte_with_mask(cur_spibar + 0xDC, 0xFE);\n}\n\n```\n\n**0x10009281 check_spi_protections**\n\n**•** **\u0007This function calls multiple helper functions such as read_bios_control_reg, is_bios_locked, is_smm_bios_protection_enabled, and try_disable_**\nbios_write_protection to try to enable writes to the SPI region and returns the result.\n\n**•** **\u0007It also uses read_pr_reg and read_from_bios_region to determine if the BIOS Region is not-readable, which is a less common occurrence.**\n\n\n-----\n\n**0x1000BFA0 wait_while_spi_cycle_in_progress**\n\n**•** **\u0007This function uses uefi_expl_phys_mem_dword to read the Hardware Sequencing Flash Status and Control (BIOS_HSFSTS_CTL) register to check**\nthe status of the SPI Cycle In Progress (H_SCIP) bit. This bit is set when the SPI hardware is currently processing a request.\n\n**0x1000BEF8 get_region_base_and_size**\n\n**•** **\u0007This function uses uefi_expl_phys_mem_read_dword to determine the Flash Linear Address (FLA) and size for the requested region by reading**\nthe FDOD (Flash Descriptor Observability Data) and Flash Region 0-6 (BIOS_FREGn) registers. This region configuration is stored in the SPI Flash\nDescriptor, which is the first 4096 bytes of the SPI chip contents.\n\n\n-----\n\n**0x1000BACD do_spi_operations**\n\n**•** **\u0007This is a large function that takes requests from other parts of the code and performs reads and writes to SPI controller registers using the uefi_**\nexpl_* primitives and other helper functions in order to perform the requested operation.\n\n**•** **\u0007The prototype for this function looks like this:**\n\n```\nunsigned int do_spi_operations(int region, int cycle_type, int data_offset, \n                            unsigned int data_size, void *buf_ptr);\n\n```\n\n\n**•** **\u0007The code supports the following types of SPI Flash Cycle requests:**\n\n\n\n- Read\n\n- Write\n\n- Erase\n\n- Read SFDP\n\n\n\n- Read JEDEC ID\n\n- Write Status\n\n- Read Status\n\n\n**0x1000BEDD read_from_spi_region**\n\n**•** **\u0007This is a helper function to make calls do_spi_operation with a hardcoded cycle_type of Read.**\n\n```\nunsigned int read_from_spi_region(int region, unsigned int data_offset, unsigned int\n  data_size, void *buf_ptr)\n{\n return do_spi_operations(region, spi_read, data_offset, data_size, buf_ptr);\n}\n\n```\n\n\n**•** **\u0007Of particular note, this module could be trivially changed to brick systems by changing the line above to:**\n\n```\nreturn do_spi_operations(region, spi_erase, 0, 0x1000000, 0);\n\n```\n\n\n**• This would result in the code erasing the BIOS region on any vulnerable systems.**\n\n**• \u0007Bricking a device at this level can require replacement of hardware in order to restore a system back to operation and is a much more invasive fix**\nthan replacing modular components like HDDs or memory, given it may require replacing the entire motherboard.\n\n\n-----\n\n**TEST FRAMEWORK AND STATUS REPORTING**\n\nBecause TrickBot uses a modular framework to allow new modules\nto be developed and deployed to targets, this sample includes some\ninfrastructure code to implement this framework, which is shared with\nprevious samples.\n\nThe main function where the module-specific operations start is at\n0x1000D663, which we’ll refer to as “permadll32_main_module”. This is\nthe main function for this module, which loads and initializes the RwDrv.\nsys driver by calling open_or_init_driver, determines the identity of the\nplatform (both CPU and PCH) by calling identify_platform, determines\nwhich register locations to use for this platform by calling get_regs_\nfrom_generation, checks if the SPI BIOS Region is writable by calling\ncheck_spi_protections, and returns the platform identity and if the SPI\nBIOS Region is writable back to the caller.\n\nAlthough this module appears only to identify the target hardware\nand determine if the BIOS region is writable, its code could be easily\nmodified to write to the SPI Flash to implant the system by modifying the\nfirmware or brick the system by erasing the BIOS Region entirely. This\ncould be automated via the use of an additional module to perform the\nattack after the reconnaissance has been completed by this module or\nvia ‘at-the-keyboard’ manual operations.\n\n#### MITIGATION\n\nGiven the popularity of TrickBot in the wild, it is important for security\nteams to ensure that their devices are not vulnerable and have not been\ncompromised. Firmware integrity checks are particularly important\nfor any device that is known to have been compromised by TrickBot.\nThe following steps can be performed with open-source tools such as\nCHIPSEC or via the Eclypsium platform.\n\n**• \u0007Check devices to ensure that BIOS write protections are enabled.**\n[See how in our Protecting System Firmware Storage blog.](https://eclypsium.com/2019/10/23/protecting-system-firmware-storage/)\nEclypsium customers can specifically look for systems with the\n“Missing BIOS Write Protection” vulnerability.\n\n**•** [�Verify firmware integrity by checking firmware hashes against](https://eclypsium.com/2020/10/14/protecting-your-organizations-from-mosaicregressor-and-other-uefi-implants/)\nknown good versions of firmware. Monitor firmware behavior for\nany signs of unknown implants or modifications.\n\n**• \u0007Update firmware to mitigate numerous vulnerabilities that have**\n[been discovered. See our blog on Firmware Updates for the](https://eclypsium.com/2020/05/14/tools-and-techniques-for-updating-enterprise-firmware/)\n[Enterprise for best practices.](https://eclypsium.com/2020/05/14/tools-and-techniques-for-updating-enterprise-firmware/)\n\n\n\n**• \u0007Incident Response (IR) teams performing host-level forensics on**\n[devices impacted by TrickBot should examine firmware as part of](https://eclypsium.com/2019/04/02/firmware-needs-to-be-part-of-your-incident-response-playbook/)\n[their playbook in order to ensure eradication and to gain hotwash](https://eclypsium.com/2019/04/02/firmware-needs-to-be-part-of-your-incident-response-playbook/)\ninsight into risks presented by adversaries targeting device\nfirmware in their specific environment.\n\n#### CONCLUSION\n\nGiven the size and scope of TrickBot, the discovery of a module\nspecifically targeting firmware is troubling. These threat actors\nare collecting targets that are verified to be vulnerable to firmware\nmodification, and one line of code could change this reconnaissance\nmodule into an attack function. Like other in-the-wild firmware attacks,\nTrickBot reused publicly available code to quickly and easily enable\nthese new firmware-level capabilities. At a time when geopolitical events\nand a global pandemic have upended life across the globe, TrickBot is\ndigging into the hidden area of firmware that is often overlooked. This\npresents a greater risk than ever before because the scale of TrickBot,\nwhich has previously brought highly disruptive ransomware, now brings\nfirmware attacks to many more organizations who are likely unprepared\nfor such techniques.\n\n\n-----\n\n#### TRICKBOOT IOCS\n\n\n**permaDll32 Hashes:**\n```\nmd5: 491115422a6b94dc952982e6914adc39\nsha1: 55803cb9fd62f69293f6de21f18fd82f3e3d1d68\nsha256: c1f1bc58456cff7413d7234e348d47a8acfdc9d019ae7a4aba1afc1b3ed55ffa\n\n```\n\n**permaDll32 (pre-decryption) Hashes:**\n```\nmd5: cef670f443d2335f44a1838463ea44ed\nsha1: 30aa28e6df66fe7b4ec643635df8187ede31db06\nsha256: c065e39ce4e90a5a966f76d9798cb5b962d51a3f35e3890f91047acfefa8c58e\n\n```\n\n**Note: The TrickBoot module includes an obfuscated copy of RwDrv.sys embedded inside it, but when this file is dropped into the Windows directory, it**\ncan be identified with the following IOCs.\n\n\n**Rwdrv.sys Hashes:**\n```\nmd5: 257483d5d8b268d0d679956c7acdf02d\nsha1: fbf8b0613a2f7039aeb9fa09bd3b40c8ff49ded2\nsha256: ea0b9eecf4ad5ec8c14aec13de7d661e7615018b1a3c65464bf5eca9bbf6ded3\n\n```\n\n-----\n\n**Yara Signature:**\n\n```\nrule crime_win32_perma_uefi_dll : Module\n{\nmeta:\n author = \"@VK_Intel | Advanced Intelligence\"\n description = \"Detects TrickBot Banking module permaDll\"\n md5 = \"491115422a6b94dc952982e6914adc39\"\nstrings:\n  $module_cfg = \"moduleconfig\"\n  $str_imp_01 = \"Start\"\n  $str_imp_02 = \"Control\"\n  $str_imp_03 = \"FreeBuffer\"\n  $str_imp_04 = \"Release\"\n  $module = \"user_platform_check.dll\"\n  $intro_routine = { 83 ec 40 8b ?? ?? ?? 53 8b ?? ?? ?? 55 33 ed a3 ?? ?? ?? ?? 8b ?? ?? ??\n56 57 89 ?? ?? ?? a3 ?? ?? ?? ?? 39 ?? ?? ?? ?? ?? 75 ?? 8d ?? ?? ?? 89 ?? ?? ?? 50 6a 40 8d\n?? ?? ?? ?? ?? 55 e8 ?? ?? ?? ?? 85 c0 78 ?? 8b ?? ?? ?? 85 ff 74 ?? 47 57 e8 ?? ?? ?? ?? 8b\nf0 59 85 f6 74 ?? 57 6a 00 56 e8 ?? ?? ?? ?? 83 c4 0c eb ??}\ncondition:\n6 of them\n}\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://eclypsium.com/wp-content/uploads/2020/12/TrickBot-Now-Offers-TrickBoot-Persist-Brick-Profit.pdf"
    ],
    "report_names": [
        "TrickBot-Now-Offers-TrickBoot-Persist-Brick-Profit.pdf"
    ],
    "threat_actors": [
        {
            "id": "a3687241-9876-477b-aa13-a7c368ffda58",
            "created_at": "2022-10-25T16:07:24.496902Z",
            "updated_at": "2025-03-27T02:02:10.256629Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "ETDA:Hacking Team",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "72aaa00d-4dcb-4f50-934c-326c84ca46e3",
            "created_at": "2023-01-06T13:46:38.995743Z",
            "updated_at": "2025-03-27T02:00:02.972623Z",
            "deleted_at": null,
            "main_name": "Slingshot",
            "aliases": [],
            "source_name": "MISPGALAXY:Slingshot",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "e90c06e4-e3e0-4f46-a3b5-17b84b31da62",
            "created_at": "2023-01-06T13:46:39.018236Z",
            "updated_at": "2025-03-27T02:00:02.978356Z",
            "deleted_at": null,
            "main_name": "Hacking Team",
            "aliases": [],
            "source_name": "MISPGALAXY:Hacking Team",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f55c7778-a41c-4fc6-a2e7-fa970c5295f2",
            "created_at": "2022-10-25T16:07:24.198891Z",
            "updated_at": "2025-03-27T02:02:10.138587Z",
            "deleted_at": null,
            "main_name": "Slingshot",
            "aliases": [],
            "source_name": "ETDA:Slingshot",
            "tools": [
                "Cahnadr",
                "GollumApp",
                "NDriver"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "e3767160-695d-4360-8b2e-d5274db3f7cd",
            "created_at": "2022-10-25T16:47:55.914348Z",
            "updated_at": "2025-03-27T02:05:17.411172Z",
            "deleted_at": null,
            "main_name": "IRON TWILIGHT",
            "aliases": [
                "ATK5 ",
                "Blue Athena ",
                "BlueDelta ",
                "FROZENLAKE ",
                "Fancy Bear ",
                "Fighting Ursa ",
                "Forest Blizzard ",
                "GRAPHITE ",
                "Group 74 ",
                "PawnStorm ",
                "STRONTIUM ",
                "Sednit ",
                "Snakemackerel ",
                "Sofacy ",
                "TG-4127 ",
                "Tsar Team ",
                "APT28 "
            ],
            "source_name": "Secureworks:IRON TWILIGHT",
            "tools": [
                " Downdelph",
                " Drovorub",
                " EVILTOSS",
                " HIDEDRV",
                " Headlace",
                " LoJack",
                " Powershell Empire",
                " SCONATO",
                " SEDUPLOADER",
                " SHARPFRONT",
                " Scaramouche",
                " Sedkit Exploit Kit",
                " Sofacy downloader",
                " X-Agent",
                " X-Tunnel",
                " Zebrocy",
                " reGeorg",
                "DEALERSCHOICE"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "730dfa6e-572d-473c-9267-ea1597d1a42b",
            "created_at": "2023-01-06T13:46:38.389985Z",
            "updated_at": "2025-03-27T02:00:02.821388Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "FROZENLAKE",
                "BlueDelta",
                "SNAKEMACKEREL",
                "TG-4127",
                "ITG05",
                "TA422",
                "Fancy Bear",
                "FANCY BEAR",
                "Sednit",
                "IRON TWILIGHT",
                "G0007",
                "Sofacy",
                "Forest Blizzard",
                "GruesomeLarch",
                "Pawn Storm",
                "Tsar Team",
                "STRONTIUM",
                "ATK5",
                "Blue Athena",
                "APT-C-20",
                "Group 74",
                "SIG40",
                "Grizzly Steppe",
                "Fighting Ursa",
                "T-APT-12",
                "UAC-0028"
            ],
            "source_name": "MISPGALAXY:APT28",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "ae320ed7-9a63-42ed-944b-44ada7313495",
            "created_at": "2022-10-25T15:50:23.671663Z",
            "updated_at": "2025-03-27T02:00:55.518748Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "APT28",
                "IRON TWILIGHT",
                "SNAKEMACKEREL",
                "Group 74",
                "Sednit",
                "Sofacy",
                "Pawn Storm",
                "Fancy Bear",
                "STRONTIUM",
                "Tsar Team",
                "Threat Group-4127",
                "TG-4127",
                "Forest Blizzard",
                "FROZENLAKE"
            ],
            "source_name": "MITRE:APT28",
            "tools": [
                "Wevtutil",
                "certutil",
                "Forfiles",
                "DealersChoice",
                "Mimikatz",
                "ADVSTORESHELL",
                "Komplex",
                "HIDEDRV",
                "JHUHUGIT",
                "Koadic",
                "Winexe",
                "XTunnel",
                "Drovorub",
                "CORESHELL",
                "OLDBAIT",
                "Downdelph",
                "XAgentOSX",
                "USBStealer",
                "Zebrocy",
                "Fysbis",
                "LoJax"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716500,
    "ts_updated_at": 1743041724,
    "ts_creation_date": 1607083660,
    "ts_modification_date": 1607083662,
    "files": {
        "pdf": "https://archive.orkl.eu/71d7d34f8e7bfcc2848cc0bdfa252ecfb7fb08d9.pdf",
        "text": "https://archive.orkl.eu/71d7d34f8e7bfcc2848cc0bdfa252ecfb7fb08d9.txt",
        "img": "https://archive.orkl.eu/71d7d34f8e7bfcc2848cc0bdfa252ecfb7fb08d9.jpg"
    }
}