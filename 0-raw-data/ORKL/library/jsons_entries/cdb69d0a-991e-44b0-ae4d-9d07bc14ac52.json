{
    "id": "cdb69d0a-991e-44b0-ae4d-9d07bc14ac52",
    "created_at": "2023-01-12T15:05:19.183184Z",
    "updated_at": "2025-03-27T02:05:28.731388Z",
    "deleted_at": null,
    "sha1_hash": "856b694aff5e53b4dc50a9cdc0f2afb8a0a88ad1",
    "title": "2021-06-14 - A Step-by-Step Analysis of a New Version of DarkSide Ransomware",
    "authors": "",
    "file_creation_date": "2022-05-27T23:03:59Z",
    "file_modification_date": "2022-05-27T23:03:59Z",
    "file_size": 9606769,
    "plain_text": "# A step-by-step analysis of a new version of Darkside Ransomware (v. 2.1.2.3)\n\n**[cybergeeks.tech/a-step-by-step-analysis-of-a-new-version-of-darkside-ransomware/](https://cybergeeks.tech/a-step-by-step-analysis-of-a-new-version-of-darkside-ransomware/)**\n\nSummary\n\nDarkside ransomware is the malware family responsible for the Colonial Pipeline attack on\nMay 7 2021 as described at https://www.zdnet.com/article/darkside-the-ransomware-groupresponsible-for-colonial-pipeline-cyberattack-explained/. The binary contains an encrypted\nconfiguration that will be decrypted using a custom algorithm, which reveals a 22-byte buffer\nthat describes different actions performed by the malware. These actions include: checking\nthe system language and avoiding to encrypt Russian language machines, deleting Shadow\ncopies, wiping Recycle Bin, ignore specific files, directories and file extensions, killing\nspecific processes, deleting specific services, etc. The ransomware can perform privilege\nescalation using the CMSTPLUA COM interface and achieves persistence by installing itself\nas a service. The files are encrypted using the custom Salsa20 implementation, with the\nSalsa20 matrix being encrypted by the public RSA key hard-coded in the binary. Darkside\nuses multithreading with I/O completion ports to communicate between the main thread and\nthe worker threads responsible for file encryptions. It’s important to mention that the process\ngenerates a random Salsa20 matrix using the RDRAND and RDSEED instructions, as\nopposed to earlier versions that use the RtlRandomEx function.\n\n**Analyst:** [@GeeksCyber](https://twitter.com/GeeksCyber)\n\nTechnical analysis\n\nSHA256:\n0A0C225F0E5EE941A79F2B7701F1285E4975A2859EB4D025D96D9E366E81ABB9\n\nThe malware comes with an encrypted configuration that is decrypted using a custom\nalgorithm:\n\n\n-----\n\nFigure 1\n\nThe custom decryption algorithm consists of 4 subtraction operations by 0x10101010 each\ntime and then some addition operations, as shown below:\n\n\n-----\n\nFigure 2\n\nFor each DLL to be loaded, there is a hash function that is applied to the DLL name, and the\n4-byte result is compared to hardcoded values:\n\n\n-----\n\nFigure 3\n\nFor example, the following value corresponds to kernel32.dll:\n\nFigure 4\n\n\n-----\n\nThe following DLLs are expected to be loaded: ntdll, kernel32, advapi32, user32, gdi32,\nole32, oleaut32, shell32, shlwapi, wininet, netapi32, wtsapi32, activeds, userenv, mpr,\nrstrtmgr. The process retrieves the address of multiple export functions based on similar\nhash values computed using the same algorithm:\n\nFigure 5\n\n\n-----\n\nThe decrypted configuration is presented below and is composed of the RSA-1024 exponent\n(0x010001 = 65537), 0x80-byte RSA-1024 modulus, victim UID, 22 configurations bytes (will\nbe detailed further on) and the aPLib-compressed configuration:\n\nFigure 6\n\nThe binary uses an aPLib-decompression algorithm to decrypt different strings. The following\nlist represents the directories to avoid in the encryption process:\n\nFigure 7\n\n\n-----\n\nThe following files will be ignored by the ransomware:\n\nFigure 8\n\nIf the file’s extension belongs to the following list, then the file will not be encrypted by the\nprocess:\n\nFigure 9\n\nThe binary intends to delete folders that contain the word “backup” in their name:\n\nFigure 10\n\nA feature not used by the malware would use the following strings decompressed as the\nother ones (our guess is that the actor would try to kill the SQL-related processes in order to\nencrypt databases):\n\nFigure 11\n\nThe following processes will not be terminated by the file:\n\n\n-----\n\nFigure 12\n\nIf a process name contains any of the following strings, it will be killed by the binary:\n\nFigure 13\n\nThere is also a list of services to be stopped and deleted, as shown in the figure below:\n\nFigure 14\n\nThe list of C2 servers is also obtained using the same algorithm:\n\nFigure 15\n\nThe process reveals a message that will be utilized to set a custom wallpaper that contains\nimportant instructions for the victim:\n\n\n-----\n\nFigure 16\n\nThe content of the ransom note is also written in the process memory, as shown in figure 17:\n\nFigure 17\n\nThe following table describes the actions that the malware takes depending on the\nconfiguration decrypted above:\n\nOffset Enabled Description\n\n0x00 Yes FAST encryption mode\n\n0x01 Yes Unknown (not used)\n\n0x02 No Attempt to log on as a user on the machine\n\n0x03 Yes Encrypt DRIVE_REMOVABLE, DRIVE_FIXED and DRIVE_REMOTE\ntype of drives\n\n0x04 Yes Retrieve the domain controllers and probably an attempt to spread\nfurther\n\n0x05 Yes Check system language and avoid the Russian language\n\n0x06 Yes Delete volume shadow copies\n\n0x07 Yes Delete files and folders from Recycle Bin\n\n\n-----\n\n0x08 No Self deletion\n\n0x09 Yes Ignore specific directories\n\n0x0a Yes Ignore specific files\n\n0x0b Yes Ignore specific file extensions\n\n0x0c Yes Wipe “backup” directories\n\n0x0d Yes Unknown (not used)\n\n0x0e Yes Kill specific processes\n\n0x0f Yes Stop and delete specific services\n\n0x10 Yes Set Desktop wallpaper\n\n0x11 Yes Drop ransom note\n\n0x12 Yes Change icon of new encrypted files\n\n0x13 Yes Create a mutex\n\n0x14 Yes Unknown (not used)\n\n0x15 Yes Communication with the C2 servers\n\nThe malware uses the NtQueryInstallUILanguage and NtQueryDefaultUILanguage APIs to\ndetermine the language of the system and compares the result with 0x419 (Russian\nlanguage identifier). If there is a match between these two values, then the malware exits:\n\n\n-----\n\nFigure 18\nThere is a call to the RegCreateKeyExW function, which is supposed to create (or open if it\nalready exists) the “Software\\Microsoft\\Cryptography” registry key, as follows:\n\n\n-----\n\nFigure 19\nThe malware extracts the “MachineGuid” value from the above registry key, as presented in\nthe next figure:\n\nFigure 20\n\nFigure 21\n\nA custom hashing algorithm that generates 8 lowercase hexadecimal characters is\nimplemented by the process (the “MachineGuid” value is the input, and the algorithm applies\n8 times):\n\nFigure 22\n\n\n-----\n\nFigure 23\n\nThe value computed above (let’s call it RansomPseudoValue) will be used in the following\nconstructions:\n\nService name: <RansomPseudoValue>\nService display name: <RansomPseudoValue>\nRansom note: README<RansomPseudoValue>.TXT\nWallpaper: %PROGRAMDATA%\\<RansomPseudoValue>.BMP\nEach encrypted file will have the following name: <Original filename>\n<RansomPseudoValue>\nIcon file: %PROGRAMDATA%\\<RansomPseudoValue>.ico\nRegistry key created: HKCR\\\n<RansomPseudoValue>\\DefaultIcon=%PROGRAMDATA%\\\n<RansomPseudoValue>.ico\n\nThe binary uses the SHTestTokenMembership API to verify if the user belongs to the\nAdministrators groups (0x220 = 544 in decimal):\n\nFigure 24\nWe’ll split the analysis into 3 different parts depending on the user’s privileges: low level\nprivileges, administrative privileges, and SYSTEM privileges.\n\n**Low Level privileges**\n\nThe malware attempts a UAC bypass that uses the CMSTPLUA COM interface as described\nat [https://gist.github.com/api0cradle/d4aaef39db0d845627d819b2b6b30512. It utilizes](https://gist.github.com/api0cradle/d4aaef39db0d845627d819b2b6b30512)\nZwOpenProcessToken to open the access token associated with the process (0x8 =\n**TOKEN_QUERY – required to query an access token):**\n\nFigure 25\nThe NtQueryInformationToken function is used to get the group accounts associated with the\ntoken (0x2 = TokenGroups) and it checks if the administrators group can be found in the\nTOKEN_GROUPS structure:\n\n\n-----\n\nFigure 26\nThere is a call to the CoInitialize routine in order to initialize the COM library on the current\nthread, as highlighted in figure 27:\n\nFigure 27\nAs presented so far, the binary uses a lot of lower level APIs (from ntdll). It allocates a new\nmemory area using the ZwAllocateVirtualMemory API (0x3000 = MEM_COMMIT |\n**MEM_RESERVE and 0x4 = PAGE_READWRITE):**\n\nFigure 28\nWe have encountered a call to an undocumented API function called\nLdrEnumerateLoadedModules:\n\nFigure 29\nThe file executes CoGetObject with the object name as Elevation:Administrator!new:\n**{3E5FC7F9-9A51-4367-9063-A120244FBEC7}, as highlighted below:**\n\n\n-----\n\nFigure 30\nBasically, it will relaunch the malware with SYSTEM privileges:\n\nFigure 31\n\nFigure 32\n**Administrative privileges**\n\nAs in the first case, the binary uses ZwOpenProcessToken to open the access token\nassociated with the process (0x8 = TOKEN_QUERY – required to query an access token):\n\nFigure 33\nThe NtQueryInformationToken API is utilized to retrieve the token’s user account (0x1 =\n**TokenUser):**\n\nFigure 34\nThe malicious process uses LookupAccountSidW to obtain the name of the account\nassociated with the SID provided as the input, as shown in figure 35:\n\n\n-----\n\nFigure 35\nThere are 3 different comparison operations that compare the domain name (the name of the\ncomputer in our case) with “NT AUTHORITY”, “AUTORITE NT” and “NT-AUTORITAT”\n(basically, it tries to determine if the user account is SYSTEM or not):\n\nFigure 36\n\n\n-----\n\nThe OpenSCManagerW routine is utilized to establish a connection to the service control\nmanager:\n\nFigure 37\nThe process tries to open a service called <RansomPseudoValue> (which doesn’t exist at\nthis time):\n\nFigure 38\nBecause the service doesn’t exist, it will be created by the malware for persistence purposes,\nas shown in the following pictures:\n\nFigure 39\n\n\n-----\n\nFigure 40\n\nThe newly created service is started, and the binary launches itself as a service:\n\nFigure 41\n**SYSTEM privileges**\n\nThe malicious binary can run with no arguments, one, two, or three arguments (these cases\nwill be described later on). As we can see below, it uses CommandLineToArgvW to obtain\npointers to the command line arguments (argv[0] is the executable name) + the number of\narguments:\n\n\n-----\n\nFigure 42\n\nThe WTSQueryUserToken API is utilized to obtain the primary access token of the logged-on\nuser specified by session 1:\n\nFigure 43\nOpenWindowStationW is used to open the “Winsta0” windows station (the interactive window\nstation), 0x40000 – WRITE_DAC – modify the DACL in the security descriptor for the object:\n\n\n-----\n\nFigure 44\nThe DACL (discretionary access control list) of the “Winsta0” windows station is modified by\ncalling the NtSetSecurityObject routine with the 0x4 = DACL_SECURITY_INFORMATION\nparameter:\n\nFigure 45\nThere is a call to OpenDesktopW that is utilized to open the “Default” desktop object with the\nargument 0x40081 = WRITE_DAC | DESKTOP_WRITEOBJECTS |\n**DESKTOP_READOBJECTS, as follows:**\n\nFigure 46\nThe DACL of the “Default” desktop object is modified by calling the\nNtSetSecurityObject function with the 0x4 = DACL_SECURITY_INFORMATION parameter:\n\nFigure 47\nThe malware creates a mutex called “Global\\4787658f1cc4202b8a15e05dd0323fde” (this\nvalue has been computed before this operation and represents a custom “hash” value of the\nmalware), which makes sure that there is only one instance of the ransomware running at a\ntime (if the mutex already exists, then the malware quits):\n\nFigure 48\n\n\n-----\n\nFigure 49\nThe ransomware forces the system not to enter sleep mode and not to turn off the display\nwhile the process is running, one of the parameters being 0x80000001 = ES_CONTINUOUS\n| ES_SYSTEM_REQUIRED:\n\nFigure 50\nThe file changes the privilege to SE_PRIVILEGE_ENABLED in order to enable the token’s\nprivileges (note the TOKEN_PRIVILEGES structure) by a function call to\nZwAdjustPrivilegesToken:\n\nFigure 51\nThe CreateThread API is used to create a new thread, as described in the next figure:\n\nFigure 52\nA list of valid drives on the system is extracted using the GetLogicalDriveStringsW routine:\n\nFigure 53\n\n\n-----\n\nThe ransomware is looking for DRIVE_REMOVABLE (0x2) and DRIVE_FIXED (0x3) drives,\nas highlighted in figure 54:\n\nFigure 54\n\nAll files and directories from Recycle Bin are deleted by the process. It starts to enumerate\nvia a FindFirstFileExW API call:\n\nFigure 55\nAs presented below, the files are deleted using the DeleteFileW function, and the directories\nare removed using the RemoveDirectoryW routine:\n\nFigure 56\n\n\n-----\n\nThe binary uses COM objects and WMI commands to delete volume shadow copies. It calls\nthe CoCreateInstance function to create a single object of the class IWbemLocator with the\nCLSID {dc12a687-737f-11cf-884d-00aa004b2e24} (Ref.\nhttps://forum.powerbasic.com/forum/user-to-user-discussions/source-code/25222-wmiwrapper-functions):\n\nFigure 57\nThere is also a new IWbemContext interface with the CLSID {44aca674-e8fc-11d0-a07c00c04fb68820} (Ref. https://docs.microsoft.com/en-us/openspecs/windows_protocols/mswmi/3485541f-6950-4e6d-98cb-1ed4bb143441) created via a CoCreateInstance function\ncall:\n\nFigure 58\nUsing the IWbemLocator object, the process calls the ConnectServer API to connect to the\nlocal “ROOT\\CIMV2” namespace and retrieves a pointer to a IWbemServices object, as\nfollows:\n\nFigure 59\nThere is a call to CoSetProxyBlanket performed by the ransomware, as described in the next\nfigure (0xA = RPC_C_AUTHN_WINNT – NTLMSSP, 0x3 = RPC_C_AUTHN_LEVEL_CALL\nand 0x3 = RPC_C_IMP_LEVEL_IMPERSONATE):\n\n\n-----\n\nFigure 60\nThe process executes the following SQL query “SELECT * FROM Win32_ShadowCopy” to\nobtain an enumerator of all shadow copies, and then it deletes each of the shadow copy\nobjects via the DeleteInstance method:\n\nFigure 61\nA list of all services and their status is retrieved by calling the EnumServicesStatusExW\nfunction (0x30 = SERVICE_WIN32, 0x3 = SERVICE_STATE_ALL):\n\nFigure 62\nEach service name is compared to the list that was decrypted at the beginning of the\nanalysis:\n\nFigure 63\nThe malware opens the targeted services by calling the OpenServiceW routine (0x10020 =\n**DELETE | SERVICE_STOP):**\n\n\n-----\n\nFigure 64\nEvery targeted service is stopped and deleted using ControlService and DeleteService, as\ndisplayed in figure 65:\n\nFigure 65\nThe NtQuerySystemInformation API returns an array of\n**SYSTEM_PROCESS_INFORMATION structures (one for each process running on the**\nsystem, 0x5 = SystemProcessInformation):\n\nFigure 66\nEach process name is compared to the list that was decrypted in the beginning, as displayed\nbelow:\n\nFigure 67\nFor every targeted process, the binary opens the process and terminates it and all of its\nthreads:\n\n\n-----\n\nFigure 68\n\nThe binary creates an ico file called <RansomPseudoValue>.ico, as displayed below:\n\nFigure 69\nA new registry key called <RansomPseudoValue> is created using the RegCreateKeyExW\nfunction, as shown in figure 70:\n\nFigure 70\nThe DefaultIcon subkey is created, and it specifies the path for the newly created ico file:\n\nFigure 71\n\n\n-----\n\nThe malware calls the SHChangeNotify routine to notify the shell to update its icon cache\n(0x08000000 = SHCNE_ASSOCCHANGED, 0x1000 = SHCNF_FLUSH):\n\nFigure 72\nA new file called %PROGRAMDATA%\\<RansomPseudoValue>.BMP is created using the\nCreateFileW function:\n\nFigure 73\nMoving forward, there is a registry key opened by calling the RegCreateKeyExW API, as\nshown in the next picture:\n\nFigure 74\nThe “WallPaper” value inside the registry key is changed to the location of the newly created\nBMP file:\n\nFigure 75\n\n\n-----\n\nAfter all of these activities, the Desktop has been changed to the following image:\n\nFigure 76\n**Thread activity – sub_4095AB**\n\nThe thread starts by decrypting the following information:\n\nFigure 77\n\nThe version of the Darkside ransomware is also decrypted and represents the latest version\nanalyzed in the wild (2.1.2.3):\n\nFigure 78\n\nAnother JSON structure is decrypted by the binary and will be used to collect data about the\nlocal machine:\n\nFigure 79\n\nOne more time, the process checks the type of the drives and is looking for\n**DRIVE_REMOVABLE (0x2), DRIVE_FIXED (0x3) and DRIVE_REMOTE (0x4):**\n\n\n-----\n\nFigure 80\n\nThe GetDiskFreeSpaceExW function is used to retrieve information about the targeted\ndrives, such as the total amount of space and the total amount of free space:\n\nFigure 81\nNtDuplicateToken is utilized to duplicate an existing token and to obtain a handle to a new\naccess token (0xC = TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY\nand 0x2 = TokenImpersonation):\n\nFigure 82\nThe thread’s impersonation token is changed via a call to the ZwSetInformationThread\nroutine, as shown in figure 83 (0x5 = ThreadImpersonationToken):\n\nFigure 83\n\n\n-----\n\nThe ransomware retrieves the username associated with the current thread, as well as the\nNetBIOS name of the local machine:\n\nFigure 84\n\nFigure 85\nThe current language of the machine is retrieved from the “LocaleName” value, as presented\nbelow:\n\nFigure 86\nNetGetJoinInformation is used to get the join status information for the local computer:\n\nFigure 87\nThe product name of Windows can be extracted by querying the “ProductName” value and\nthe Windows product ID can be extracted by querying the “ProductId” value, as shown in the\nfollowing pictures:\n\nFigure 88\n\n\n-----\n\nFigure 89\nThe malware constructs the following JSON, which contains data to be exfiltrated to the C2\nserver:\n\nFigure 90\n\nThe final data looks like in the following JSON form:\n\nFigure 91\n\nThe data from above is encrypted by a custom encryption algorithm:\n\n\n-----\n\nFigure 92\n\nFigure 93\n\nThe result of the encryption operation is base64-encoded, as shown below:\n\n\n-----\n\nFigure 94\n\n\nFigure 95\n\n\n-----\n\nThe following function is used to generate 2 random 4-byte values that will be utilized in the\nnetwork communications. It uses instructions such as RDRAND and RDSEED to generate\nrandom numbers (if these are supported), but we’ll provide a deeper understanding of it\nwhen we discuss file encryption (it’s also used to generate the Salsa20 matrix):\n\nFigure 96\nThe parameters of the network request have the following structure:\nrandom_number1=base64(encryptionresult)&random_number2=victim_uid:\n\n\n-----\n\nFigure 97\n\nThe InternetOpenW function is called using a user agent decrypted by the malware as a\nparameter:\n\nFigure 98\nInternetConnectW is utilized to connect to one of the C2 servers (baroquetees[.]com) on port\n443:\n\nFigure 99\nThe process creates an HTTP request handle using the HttpOpenRequestW routine, as\nshown in figure 100:\n\nFigure 100\n\n\n-----\n\nThere is also a call to the InternetSetOptionW API that is used to set the security flags for the\nhandle (0x1f = INTERNET_OPTION_SECURITY_FLAGS):\n\nFigure 101\nThe binary sends the POST request to the C2 server using HttpSendRequestW:\n\nFigure 102\n\nFigure 103\nThe status code returned by the server is retrieved using the HttpQueryInfoW API (0x13 =\n**HTTP_QUERY_STATUS_CODE):**\n\nFigure 104\nInterestingly, the ransomware doesn’t expect a 200 status code but a 500 (Internal Server\nError). If the status code isn’t 500, then the process repeats the steps described so far using\nthe second C2 server, rumahsia[.]com:\n\n\n-----\n\nFigure 105\n\nFigure 106\nThis last idea concludes our analysis of this thread. We continue to analyze the main thread.\n\nThe binary enumerates the volumes available on the machine and uses the CreateFileW\nroutine to open them:\n\n\n-----\n\nFigure 107\nDeviceIoControl is utilized to get information about the type, size, and nature of a disk\npartition (0x70048 = IOCTL_DISK_GET_PARTITION_INFO_EX):\n\nFigure 108\nA new thread is created by the file using CreateThread:\n\nFigure 109\n**Thread activity – sub_407558**\n\nThe only action the thread does is using the GetLogicalDriveStringsW API to retrieve the\nvalid drives on the local machine:\n\nFigure 110\nIf a volume doesn’t have a drive letter associated with it, then the ransomware does that\nusing the SetVolumeMountPointW API, as highlighted in the following picture:\n\nFigure 111\n\n\n-----\n\nThe malicious process targets the following types of drives –\n**DRIVE_REMOVABLE (0x2), DRIVE_FIXED (0x3) and DRIVE_REMOTE (0x4):**\n\nFigure 112\n\nThe CreateFileMappingW function is used to create a named file mapping object (name\n“Local\\\\job0-<Process Id>” means the object is created in the session namespace):\n\nFigure 113\nThe binary maps a view of the file mapping into the address space of the process by calling\nthe MapViewOfFile routine (0xf001f = FILE_MAP_ALL_ACCESS):\n\nFigure 114\nA named event object called “Local\\\\job0-<Process Id>-Event” is created by the binary:\n\nFigure 115\nThe ransomware launches itself with 3 parameters, and the new process will execute the\nencryption operations:\n\n\n-----\n\nFigure 116\nOpenMutexW is utilized to open a named mutex called “Global\\\\T-job0-<Process Id>” (which\ndoesn’t exist at this time) – 0x100000 = SYNCHRONIZE:\n\nFigure 117\nThe event object created earlier is opened by calling the OpenEventW API (0x1f0003 =\n**EVENT_ALL_ACCESS), as displayed in figure 118:**\n\nFigure 118\nThe file creates an I/O completion port that isn’t associated with a file handle, which will be\nused by the main thread to send data that will be encrypted to worker threads:\n\nFigure 119\nTwo different threads that will take care of the files’ encryption are created using the\nCreateThread routine:\n\n\n-----\n\nFigure 120\nThe ransom note README<RansomPseudoValue>.TXT is created and populated in every\ndirectory the malware encrypts:\n\nFigure 121\nThe process doesn’t encrypt some certain files, as displayed in the next figure:\n\nFigure 122\nA list of file extensions decrypted at the beginning of the execution is also excluded from the\nencryption process:\n\n\n-----\n\nFigure 123\nEvery targeted file is opened and read using the CreateFileW and ReadFile functions:\n\nFigure 124\n\nFigure 125\nThe file extension is changed to also include <RansomPseudoValue>, as shown below:\n\nFigure 126\nThere is a second function call to CreateIoCompletionPort that associates the existing I/O\ncompletion port with the FileHandle parameter:\n\nFigure 127\nThe RSA public exponent and the RSA modulus will be used in the encryption process of the\nSalsa20 matrix, as we’ll describe later on:\n\n\n-----\n\nFigure 128\nThe ransomware checks to see if the RDRAND and RDSEED instructions are supported by\nthe processor. If that’s the case, it will use one of them to generate 56 random bytes, and 8\nNULL bytes are added to the resulting buffer (Salsa20 matrix -> custom Salsa20\nimplementation). If none of these are supported, the malware uses the rdtsc instruction to\ngenerate deterministic timestamps that will provide a 64-byte Salsa20 matrix:\n\nFigure 129\n\n\n-----\n\nFigure 130\n\nThe thread poses a custom implementation of the RSA-1024 algorithm (it doesn’t rely on\nWindows APIs). Basically, the data d will produce a ciphertext = (d^exponent)%modulus. The\nraw modulus calculation is performed using addition and subtraction and part of the\nimplementation is presented in the following figures:\n\nFigure 131\n\n\n-----\n\nFigure 132\n\nThe Salsa20 matrix is encrypted using the custom RSA implementation, as shown in figure\n133:\n\nFigure 133\n\nThere is a custom “hash” function applied to the above encryption result, which produces a\n16-byte output:\n\n\n-----\n\nFigure 134\n\nThe file content that will be encrypted is appended to the buffer that will be sent to the worker\nthreads:\n\nFigure 135\n\nThe Salsa20 matrix is also added to the buffer, and it will be utilized by the worker threads to\nencrypt the files:\n\nFigure 136\n**Thread activity –** **sub_405E7C** **(File encryption)**\n\nThe file content is encrypted using a custom Salsa20 implementation and the ciphertext\noverwrites the plaintext in the buffer:\n\n\n-----\n\nFigure 137\n\n\nA snippet of the custom implementation is presented below:\n\n\n-----\n\nFigure 138\n\nThe encrypted content is written to the initial file, followed by the encrypted Salsa20 matrix\nand the hash value, as displayed in the following figures:\n\n\n-----\n\nFigure 139\n\nFigure 140\nThis last idea concludes our analysis of this thread. We continue to analyze the main thread.\n\nIf the current directory contains “backup”, then the malware deletes it:\n\nFigure 141\nThe main thread sends the buffer described above (which includes file content to be\nencrypted etc.) to the worker threads by calling the PostQueuedCompletionStatus routine:\n\nFigure 142\nWe’ve also identified a function that we believe it’s used to propagate the malware to domain\ncontrollers (we didn’t have one in our environment). It calls functions such as\nDsGetDcNameW, DsGetDcOpenW and DsGetDcNextW:\n\n\n-----\n\nFigure 143\nDarkside enumerates all network shares using the NetShareEnum API and encrypts each\none of them by the main encryption routine described so far:\n\n\n-----\n\n**Thread activity – sub_4096A4**\n\nThe following JSON is decrypted by the thread:\n\n\nFigure 144\n\nFigure 145\n\n\nThe file opens the following registry key by calling RegCreateKeyExW:\n\n\n-----\n\nFigure 146\nThe Product ID is retrieved again by calling the RegQueryValueExW function:\n\nFigure 147\nThe machine GUID is extracted from the registry and represents a unique identifier for the\nmachine:\n\nFigure 148\n\nFigure 149\nAfter the encryption finishes, the malware sends encryption statistics to the C2 server, such\nas: victim ID, uid, number of encrypted files, size of encrypted files, number of skipped files\nand elapsed time. The final JSON structure looks like the following:\n\n\n-----\n\nFigure 150\n\nAs already described so far regarding the C2 communication, the buffer is encrypted with a\ncustom algorithm and base64-encoded. The request sent to the C2 server is presented in\nthe next picture:\n\nFigure 151\nIf the self deletion feature would be enabled, Darkside would delete itself using\nShellExecuteW:\n\nFigure 152\n\nFigure 153\nAs we specified at the beginning of the analysis, the binary can run with different parameters:\n\n1 parameter: filename – only this file will be encrypted\n2 parameters: “-path” directory – only this directory will be encrypted\n3 parameters: “-work” worker0 job0-<Process Id> – this is spawned by the initial\nprocess, already described\n\n\n-----\n\nA particular case is handled by the ransomware differently when it deals with a shortcut file\n(.lnk file). Basically, the binary wants to extract the full path to the file from this link. It calls the\nCoCreateInstance API with the CLSID of {000214F9-0000-0000-C000-000000000046}\n(IShellLinkW interface):\n\nFigure 154\nUnfortunately, Scylla didn’t help us here and it couldn’t provide us the methods. We’ve found\nthat the next 2 function calls are used to extract the path of the file/directory:\n\nFigure 155\n\nFigure 156\nThe file extracted above is encrypted as usual:\n\nFigure 157\n\nReferences\n\n[MSDN: https://docs.microsoft.com/en-us/windows/win32/api/](https://docs.microsoft.com/en-us/windows/win32/api/)\n\nFakenet: [https://github.com/fireeye/flare-fakenet-ng](https://github.com/fireeye/flare-fakenet-ng)\n\nAny.run:\nhttps://any.run/report/0a0c225f0e5ee941a79f2b7701f1285e4975a2859eb4d025d96d9e366e\n81abb9/e7a712f5-961a-45b4-a7e5-a0f7196113a5\n\nVirusTotal:\nhttps://www.virustotal.com/gui/file/0a0c225f0e5ee941a79f2b7701f1285e4975a2859eb4d025\nd96d9e366e81abb9/detection\n\n\n-----\n\nAnalysis of Darkside Ransomware v1.8.6.2:\n[https://chuongdong.com/reverse%20engineering/2021/05/06/DarksideRansomware/](https://chuongdong.com/reverse%20engineering/2021/05/06/DarksideRansomware/)\n\nFireeye report: https://www.fireeye.com/blog/threat-research/2021/05/shining-a-light-ondarkside-ransomware-operations.html\n\n[https://gist.github.com/api0cradle/d4aaef39db0d845627d819b2b6b30512](https://gist.github.com/api0cradle/d4aaef39db0d845627d819b2b6b30512)\n\nhttps://forum.powerbasic.com/forum/user-to-user-discussions/source-code/25222-wmiwrapper-functions\n\nhttps://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmi/3485541f-69504e6d-98cb-1ed4bb143441\n\nINDICATORS OF COMPROMISE\n\nC2 domains: baroquetees[.]com, rumahsia[.]com\n\nSHA256:\n0A0C225F0E5EE941A79F2B7701F1285E4975A2859EB4D025D96D9E366E81ABB9\n\nCreated files: README<RansomPseudoValue>.TXT, %PROGRAMDATA%\\\n<RansomPseudoValue>.BMP, %PROGRAMDATA%\\<RansomPseudoValue>.ico\n\nService Name: <RansomPseudoValue>, Service display name: <RansomPseudoValue>\n\nRegistry key: HKCR\\<RansomPseudoValue>\\DefaultIcon=%PROGRAMDATA%\\\n<RansomPseudoValue>.ico\n\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:79.0) Gecko/20100101\nFirefox/80.0 (prone to False Positives)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-06-14 - A Step-by-Step Analysis of a New Version of DarkSide Ransomware.pdf"
    ],
    "report_names": [
        "2021-06-14 - A Step-by-Step Analysis of a New Version of DarkSide Ransomware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535919,
    "ts_updated_at": 1743041128,
    "ts_creation_date": 1653692639,
    "ts_modification_date": 1653692639,
    "files": {
        "pdf": "https://archive.orkl.eu/856b694aff5e53b4dc50a9cdc0f2afb8a0a88ad1.pdf",
        "text": "https://archive.orkl.eu/856b694aff5e53b4dc50a9cdc0f2afb8a0a88ad1.txt",
        "img": "https://archive.orkl.eu/856b694aff5e53b4dc50a9cdc0f2afb8a0a88ad1.jpg"
    }
}