{
    "id": "fb4ac24f-16b1-4746-bd78-1ebe51e0d58b",
    "created_at": "2023-05-06T02:09:53.66124Z",
    "updated_at": "2025-03-27T02:15:35.756665Z",
    "deleted_at": null,
    "sha1_hash": "5a01756c0276dd61b58c16689efe050adbefc147",
    "title": "2023-04-05 - Everything you need to know about the LummaC2 Stealer- Leveraging IDA Python and Unicorn to deobfuscate Windows API Hashing",
    "authors": "",
    "file_creation_date": "2023-05-05T01:53:40Z",
    "file_modification_date": "2023-05-05T01:53:40Z",
    "file_size": 1315431,
    "plain_text": "# Everything you need to know about the LummaC2 stealer: Leveraging IDA Python and Unicorn to deobfuscate Windows API Hashing\n\n**[outpost24.com/blog/everything-you-need-to-know-lummac2-stealer](https://outpost24.com/blog/everything-you-need-to-know-lummac2-stealer)**\n\nEverything you need to know about the LummaC2 stealer: Leveraging IDA Python and\nUnicorn to deobfuscate Windows API Hashing\n\n05.Apr.2023\n\nAlberto Marín, KrakenLabs Malware Sandbox Lead\n\n[Threat Intelligence](https://outpost24.com/blog?tags=335)\n\nIn this blog post, the KrakenLabs team will take a deep dive into a malware sample classified\nas LummaC2, an information stealer written in C language that has been sold in\nunderground forums since December 2022. We assess LummaC2’s primary workflow, its\ndifferent obfuscation techniques (like Windows API hashing and encoded strings) and how to\novercome them to effectively analyze the malware with ease. We will also analyze how\nnetworking communications with the C2 work and summarize LummaC2’s MITRE\nAdversarial Tactics, Techniques and Common Knowledge.\n\nThere is a huge spike in the popularity and use of information-stealing malware in\nunderground markets. With more stealing capabilities, simplified administration, and ability to\nremain undetected, stealers are available to anyone with basic computer knowledge. This is\nevident in the price evolution of different stealer malware families from 2018-2022. In a\n[recent report, Outpost24’s Threat Intelligence team, KrakenLabs, revealed a change in the](https://outpost24.com/resources/whitepapers/the-rising-threat-of-traffers)\npricing model with more bad actors offering subscription-based access to their malware,\ninstead of a single payment model.\n\nIn this blog post, the KrakenLabs team will take a deep dive into a malware sample classified\nas LummaC2, an information stealer written in C language that has been sold in\nunderground forums since December 2022. We assess LummaC2’s primary workflow, its\ndifferent obfuscation techniques (like Windows API hashing and encoded strings) and how to\n\n\n-----\n\novercome them to effectively analyze the malware with ease. We will also analyze how\nnetworking communications with the C2 work and summarize LummaC2’s MITRE\nAdversarial Tactics, Techniques and Common Knowledge.\n\nThis malware family is an evolution of its predecessor LummaC, developed by the same\n[threat actor, and sold since August 2022 on underground forums.](https://www.accenture.com/us-en/blogs/security/information-stealer-malware-on-dark-web?tlaAppCB)\n\n## New stealer for sale: LummaC2\n\nThe information stealer is offered for sale in several underground forums and via the official\nshop lumma[.]site by the threat actor \"Shamel\" using the alias “Lumma”, who is also\n[responsible for the sales of the 7.62mm stealer. Outpost24 KrakenLabs analysts have also](https://ke-la.com/information-stealers-a-new-landscape/)\nfound advertisements in other forums by the alias “LummaStealer”, which is presumably a\nreseller of the stealer.\n\nFigure 1. Dark Web Post for LummaC2 Stealer\n\nAs we will see in detail later, this malware targets crypto wallets, browser extensions, twofactor authentication (2FA) and steals sensitive information from the victim’s machine.\n\nLummaC2 is offered at the following prices depending on the features offered:\n\nExperienced US$250;\nProfessional US$500;\nCorporate account US$1,000.\n\n[An earlier version of the website seen in a screenshot on Cyble's article indicates that it was](https://blog.cyble.com/2023/01/06/lummac2-stealer-a-potent-threat-to-crypto-users/)\nalso possible to purchase the stealer and panel source code for a price of US$20,000.\n\n\n-----\n\nThe purchase of the stealer can be processed through the well-known cryptocurrency\nexchange Coinbase from a wide range of cryptocurrencies to choose from.\n\nFigure 2. Screenshot obtained from LummaC2 shop (information automatically translated\nfrom Russian to English).\n\n### Deobfuscating LummaC2\n\n**LummaC2 Windows API call Obfuscation**\n\n**LummaC2 makes use of API hashing, which is a common technique seen in malware in**\norder to hide their functionality from tools relying on static information and to obfuscate the\ncode, which makes it harder for an analyst to understand what the malware does.\n\nThe following picture shows an example of how Windows API calls are performed:\n\nFigure 3. Example of an obfuscated call to NtClose for LummaC2\n\n\n-----\n\nThe malware executes a function that receives a DLL name string in EDX register(e.g\n“ntdll.dll”) and an input hash (in ECX register). This function internally resolves\nkernel32!LoadLibraryA to load the desired .dll (in this case “ntdll.dll”) and proceeds to parse\nits Export Table. It hashes each export name until it finds one that matches the input hash.\nThis way it is able to resolve any Windows API Call, saving the address found in EAX\nregister as a result. Then a call eax instruction will finally execute the desired Windows API\ncall.\n\nFigure 4. LummaC2 parsing Export Table and hashing with MurmurHash2 to resolve\nWindows API calls\n\nThe hashing algorithm that LummaC2 uses to resolve Windows API calls is MurmurHash2\nwith 32 as seed value.\n\n\n-----\n\nFigure 5. Decompiled view (excerpt) of MurmurHash2 routine using 32 as seed value\n\n### Defeating LummaC2 Windows API call Obfuscation\n\nThe following lines are aimed at removing the call obfuscation scheme for LummaC2 now\nthat we know how it resolves Windows API calls. The idea is to automatically resolve all\nWindows API calls used in the code so that we have a better picture of the malware\ncapabilities without the need of debugging and entering in every single path the malware can\ntake to resolve all its possible calls.\n\nTo do so, we will generate a dictionary containing all the Windows API calls from a given set\nof Windows .dll files and their respective MurmurHash2. With this dictionary, we can then\nget every hash sent to the function resolving Windows Api calls and figure out which function\nis being resolved.\n\n**Preparing Windows API call hash dictionary**\n\nWe could try and find a public implementation or MurmurHash2 but it is possible that the\nalgorithm the malware uses may be altered in the future so that the standard implementation\n[does not work. For this reason, another good approach is to use Unicorn, as it allows us to](https://www.unicorn-engine.org/)\nemulate the exact instructions that the malware executes.\n\n**Unicorn**\n\nThe hashing routine is a “standalone” routine that we can extract easily from the binary and\ndoes not have any calls or jumps to other locations apart from the hashing routine itself.\nWhich means we can run this shellcode in an emulated environment without previous\n\n\n-----\n\npatching to ensure everything is linked properly (with the exception of the last return\ninstruction, which we should ignore for the emulation).\n\nIn this scenario, the malware hashing algorithm expects to have the string with the Windows\nAPI call in ECX register and the result hash (which we will read) is finally stored in EAX\nregister.\n\nFigure 6. Call graph view for LummaC2 MurmurHash2 implementation\n\nAs we now have all the data we need to emulate the binary, the last step for this part is to\nbuild the emulation environment for our code to run on. To accomplish this, we will use the\n[open-source Unicorn Engine.](https://www.unicorn-engine.org/)\n\nThe first thing we want to do is initializing Unicorn for the architecture we want to emulate\n(x86 architecture), and map some memory to use. Next, we will write our shellcode to our\nmemory space and initialize ECX pointing to our Export Name string. With all this in place,\nwe are ready to run emulation and read the resulting hash in EAX register afterwards.\n\nThe following Python function uses Unicorn to emulate the hashing algorithm LummaC2\nuses to resolve Windows API Calls:\n\n\n-----\n\n```\n  import unicorn\n\ndef emulate_murmurhash2(data, seed=32):\n\n  code =\n\"\\x56\\x57\\x8B\\xF9\\x8B\\xD7\\x8D\\x4A\\x01\\x8A\\x02\\x42\\x84\\xC0\\x75\\xF9\\x2B\\xD1\\x8B\\xF2\\x83\n\\xF6\\x20\\x83\\xFA\\x04\\x7C\\x4D\\x53\\x8B\\xDA\\xC1\\xEB\\x02\\x6B\\xC3\\xFC\\x03\\xD0\\x0F\\xB6\\x4F\\\nx03\\x0F\\xB6\\x47\\x02\\xC1\\xE1\\x08\\x0B\\xC8\\x69\\xF6\\x95\\xE9\\xD1\\x5B\\x0F\\xB6\\x47\\x01\\xC1\\x\nE1\\x08\\x0B\\xC8\\x0F\\xB6\\x07\\xC1\\xE1\\x08\\x83\\xC7\\x04\\x0B\\xC8\\x69\\xC9\\x95\\xE9\\xD1\\x5B\\x8\nB\\xC1\\xC1\\xE8\\x18\\x33\\xC1\\x69\\xC8\\x95\\xE9\\xD1\\x5B\\x33\\xF1\\x83\\xEB\\x01\\x75\\xBF\\x5B\\x83\n\\xEA\\x01\\x74\\x1C\\x83\\xEA\\x01\\x74\\x0E\\x83\\xEA\\x01\\x75\\x1D\\x0F\\xB6\\x47\\x02\\xC1\\xE0\\x10\\\nx33\\xF0\\x0F\\xB6\\x47\\x01\\xC1\\xE0\\x08\\x33\\xF0\\x0F\\xB6\\x07\\x33\\xC6\\x69\\xF0\\x95\\xE9\\xD1\\x\n5B\\x8B\\xC6\\xC1\\xE8\\x0D\\x33\\xC6\\x69\\xC8\\x95\\xE9\\xD1\\x5B\\x5F\\x5E\\x8B\\xC1\\xC1\\xE8\\x0F\\x3\n3\\xC1\"\n\n  CODE_OFFSET = 0x1000000\n\n  mu = unicorn.Uc(unicorn.UC_ARCH_X86, unicorn.UC_MODE_32)\n\n  mu.mem_map(CODE_OFFSET, 4*1024*1024)\n\n  mu.mem_write(CODE_OFFSET, code)\n\n  libname = 0x7000000\n\n  mu.mem_map(libname, 4*1024*1024)\n\n  mu.mem_write(libname, data)\n\n  stack_base = 0x00300000\n\n  stack_size = 0x00100000\n\n  mu.mem_map(stack_base, stack_size)\n\n  mu.mem_write(stack_base, b\"\\x00\" * stack_size)\n\n  mu.reg_write(unicorn.x86_const.UC_X86_REG_ESP, stack_base + 0x800)\n\n  mu.reg_write(unicorn.x86_const.UC_X86_REG_EBP, stack_base + 0x1000)\n\n  mu.reg_write(unicorn.x86_const.UC_X86_REG_ECX, libname)\n\n  mu.emu_start(CODE_OFFSET, CODE_OFFSET + len(code))\n\n  result = mu.reg_read(unicorn.x86_const.UC_X86_REG_EAX)\n\n  return result\n\n\n```\nWe can now easily write a script to walk through files inside a directory where we have\nWindows .dlls and, for each .dll, parse its Exports and calculate its MurmurHash2 using the\nprevious function. This could be an example of the implementation using pefile:\n\n\n-----\n\n```\n  import pefile\n\ndef dump_hash_dlls():\n\n  '''\n\n  This function uses pefile to get the export names from .dlls and apply the\nhashing\n\n  algorithm to them.\n\n  '''\n\n  dlls_dir = 'dlls/'  # Directory where we have Windows .DLL files\n\n  for (dirpath, dirnames, filenames) in os.walk(dlls_dir):\n\n    for filename in filenames:\n\n      if filename.endswith('.dll'):\n\n        pe = pefile.PE('{}'.format(dlls_dir+filename))\n\n        for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:\n\n          export_name = exp.name\n\n          if not export_name:\n\n            # \"Ignoring export without name...\"\n\n            continue\n\n          try:\n\n            export_hash = emulate_murmurhash2(export_name)\n\n          except Exception as err:\n\n            print 'Exception occurred while emulating murmurhash2 with\nexport_name: {}. Error: {} '.format(export_name, err)\n\n            continue\n\n\n```\nThe results can then be saved as we prefer. In this case, we need a Python dictionary that\nwe can use in IDA Python script when analyzing the malware. We can save the result\ndictionary in a .json file like the following one:\n\n\n-----\n\n```\n  {\n\n  \"1002323769\": \"kernel32_MoveFileTransactedA\",\n\n  \"1002333354\": \"ntdll_ZwSetTimer\",\n\n  \"1003390208\": \"ntdll_memmove_s\",\n\n  \"1003407985\": \"advapi32_LsaDelete\",\n\n  \"1004879971\": \"ntdll_NtReadOnlyEnlistment\",\n\n  \"100560003\": \"kernel32_GetThreadId\",\n\n  \"1006629348\": \"kernel32_ReadConsoleOutputW\",\n\n  \"1007338292\": \"kernel32_GetProcessPreferredUILanguages\",\n\n  \"1007695856\": \"user32_GetClassInfoExW\",\n\n  \"1008342899\": \"shell32_SHCreateStdEnumFmtEtc\",\n\n  \"1008627276\": \"advapi32_QueryTraceW\",\n\n  \"1008723271\": \"ntdll_NtDisableLastKnownGood\",\n\n  \"1009340263\": \"advapi32_RegSaveKeyW\",\n\n  \"1009496315\": \"kernel32_FlushViewOfFile\",\n\n  \"1009939290\": \"shlwapi_PathFindSuffixArrayW\",\n\n  \"101018728\": \"ntdll_ZwOpenTransactionManager\",\n\n  \"1010305366\": \"user32_SetWindowLongA\",\n\n  \"1010398495\": \"shlwapi_PathUnExpandEnvStringsW\",\n\n  \"101074275\": \"kernel32_EnumDateFormatsExW\",\n\n  \"1011639982\": \"user32_AppendMenuA\",\n\n  \"1012134009\": \"user32_CharToOemBuffW\",\n\n  \"1012436811\": \"ntdll_NtCreateNamedPipeFile\",\n\n  \"1013083577\": \"shell32_ShellExec_RunDLL\",\n\n  \"1014808818\": \"ntdll_NtUnmapViewOfSection\",\n\n  \"1016118817\": \"ntdll_NtQueryInformationThread\",\n\n  \"1017169715\": \"shell32_ILCloneFirst\",\n\n  \"1017424400\": \"user32_ReleaseCapture\",\n\n(…)\n\n\n```\n**Resolving obfuscated Windows API calls**\n\nNow that we have all the possible exports that the malware may use, it is time to create an\n**IDA Python script to help us reverse engineer LummaC2.**\n\nThis script is going to be divided in 2 parts. From one side, we are going to resolve every\nWindows API call (checking the hash set in ECX against our big dictionary) and create an\nIDA comment staying the final Windows API call being made. In the end, we will execute\nanother script while debugging LummaC2 to patch all these calls.\n\nThis will help us to easily understand how the malware operates and its capabilities to ease\nreverse engineering without the need of debugging and executing every possible path the\nmalware can take.\n\nThe first thing to do is to place our .json file (the one with the big Python dictionary storing all\nthe Windows API calls and respective hashes) in our analysis VMs where IDA Python script\nis going to be executed. Then the script must be able to read and save its contents for further\nanalysis:\n\n\n-----\n\n```\n  import json\n\nhashes_dict = {}\n\ndef setup(hashes_dict_file):\n\n  global hashes_dict\n\n  try:\n\n    with open(hashes_dict_file, 'rb') as fd:\n\n      hashes_dict = json.load(fd)\n\n  except Exception as err:\n\n    print 'Error while readning hashes dict. file: {}'.format(err)\n\n\n```\nNow that we have our dictionary ready. Let’s examine the different patterns that are used\nwhen resolving a Windows API call. We know that ECX register must have the hash, but this\ncan be achieved in the code through different ways:\n\nFigure 7. Example of different scenarios where Windows API call resolution is made\n\nAs we can see, in the end ECX always contains the hash to be resolved. However, the\ninstruction that sets the specified hash can move it into a different register before being in\nECX. The last two patterns use EDI and ESI registers respectively.\n\nWith this information, we should be able to go through all cross references to the call\n“ResolveApiByHash”, retrieve the hash being used and resolve the Windows API call using\nour big hash dictionary. The following Python function implements this. It only expects to\nreceive the address of the call “ResolveApiByHash” as its only argument.\n\n\n-----\n\n```\n  import idautils\n\nimport idc\n\ndef resolve_all_APIs(resolve_ea):\n\n  patches = []\n\n  total_apis_found = 0\n\n  total_apis_resolved = 0\n\n  global hashes_dict\n\n  if resolve_ea is None:\n\n    print('[!] Resolve failed.')\n\n    return\n\n  for ref in idautils.CodeRefsTo(resolve_ea, 1):\n\n    total_apis_found += 1\n\n    curr_ea = ref\n\n    API_hash = 0\n\n    for _ in range(30): # Search maximum the last 30 instructions before the call\nto ResolveApiByHash\n\n      prev_instruction_ea = idc.PrevHead(curr_ea)\n\n      instruction = idc.GetDisasm(prev_instruction_ea)\n\n      # Possible scenarios\n\n      '''\n\n      .text:0040214B B9 73 10 FF E8             mov   ecx,\n0E8FF1073h\n\n      .text:00402150 E8 7E 61 00 00             call  \nResolveApiByHashWrapper\n\n      or\n\n      .text:004074F6 BF 29 A1 D3 5F             mov   edi,\n5FD3A129h\n\n      .text:004074FB BA C8 4B 42 00             mov   edx,\noffset aWininet_dll ; \"wininet.dll\"\n\n      .text:00407500 8B CF                      mov  \necx, edi\n\n      .text:00407502 E8 CC 0D 00 00             call  \nResolveApiByHashWrapper\n\n      or\n\n      .text:00407D8C BE 30 E2 95 3D             mov   esi,\n3D95E230h\n\n```\n\n-----\n\n```\n      .text:00407D91 8B D3                     mov  \nedx, ebx\n\n      .text:00407D93 6A 00                     push  0\n\n      .text:00407D95 8B CE                     mov  \necx, esi\n\n      .text:00407D97 E8 37 05 00 00             call  \nResolveApiByHashWrapper\n\n      '''\n\n      instruction_cut = instruction.replace(' ', '')\n\n      if 'movecx' in instruction_cut or 'movedi' in instruction_cut or 'movesi'\nin instruction_cut:\n\n        API_hash = idc.GetOperandValue(prev_instruction_ea, 1)\n\n        if API_hash < 0x10:\n\n          # Avoid intermediate movs, when the target is in edi (e.g mov\necx, edi)\n\n          curr_ea = prev_instruction_ea\n\n          continue\n\n        API_hash_idx = str(API_hash)\n\n        if API_hash_idx in hashes_dict:\n\n          print('API hash: {} {} {}'.format(hex(prev_instruction_ea),\nhex(API_hash), hashes_dict[API_hash_idx]))\n\n          apicall = hashes_dict[API_hash_idx].split('_')[-1] #\n\"kernel32_AddAtomA\" -> \"AddAtomA\"\n\n          idc.MakeComm(ref, apicall)\n\n          patch_info = (ref, hashes_dict[API_hash_idx])\n\n          patches.append(patch_info)\n\n          total_apis_resolved += 1\n\n        else:\n\n          print(\"Hash not found!\")\n\n        break\n\n      curr_ea = prev_instruction_ea\n\n  print('Total APIs found: {} Total APIs resolved: {}'.format(total_apis_found,\ntotal_apis_resolved))\n\n  return patches\n\n\n\n```\n\n-----\n\n```\nsetup( c:\\murmurhash2_hashes_dict.json ) # Big Python dict. With hashes and export\nnames\n\npatches = resolve_all_APIs(0x004082D3) # Use address of “ResolveApiByHash”\n\n\n```\nThe return value is a list of tuples (addr, apicall) that we will use later to patch the binary.\nAfter executing the script, we can see how now we have comments for every Windows API\ncall resolution and have a better understanding of what the malware can do. We can also\nuse xref view to quickly see all the Windows API calls (with their resolved name as a\ncomment) the malware can use.\n\nFigure 8. Example of result from executing the previous script. Windows API calls are\ncommented now\n\n\n-----\n\nFigure 9. Cross-Referencing the Windows API resolution routine can help identifying\nmalware capabilities now\n\n**Patching the binary and removing obfuscation**\n\nThe last part of this script would allow us to patch the binary to remove all of LummaC2\nWindows API call obfuscation. This way we can focus only in the relevant instructions and\nhelp IDA decompiler to easily recognize the arguments that are being passed to these\nfunctions.\n\nWith the current implementation, we can easily see which Windows API calls are being used\n(as we have comments in every call that resolves a function). However, we still have many\nunnecessary instructions in the code, and the call is still being done with the instruction “call\neax”, which does not help us much with analysis, cross-referencing, etc.\n\nThe goal of the following Python function for IDA is to patch the “call ResolveApiByHash” for\nthe real Windows API call that is going to be called after resolution. From the previous script,\nwe have a list of tuples. Each element of the tuple consists of an address (where the call\nresolution is made) and the Windows API call that is going to be called.\n\n\n-----\n\n```\n  def patch_apicall_wrapper(patches):\n\n  total_apis_patched = 0\n\n  for item in patches:\n\n    # item : (addr, apicall) (e.g (0xCAFEBABE, \"kernel32_AddAtomA\"))\n\n    try:\n\n      addr = item[0]\n\n      apicall = item[1]\n\n      success_patch = patch_apicall(addr, apicall)\n\n      if success_patch:\n\n        total_apis_patched += 1\n\n    except Exception as err:\n\n      print('Error patching call: {}'.format(err))\n\n  print('Total APIs patched: {}'.format(total_apis_patched))\n\n```\nThe function “patch_apicall” is going to be the responsible for retrieving the address of a\nWindows API call and patching the “call ResolveApiByHash” for the call to the expected\nexport.\n\nOne drawback that we may find, is that we cannot resolve the address of an export from a\nWindows .dll that has not been loaded in the address space from the debugged process yet.\nTo overcome this issue, we can make use of IDA “Appcall” feature. With Appcall we can\nexecute LoadLibraryA to load any missing .dll so that we can resolve all exports just from\nthe Entry Point. (Otherwise, we would have to wait until the malware loads the library for the\nfirst time; which would not allow us to automate everything from the Entry Point as we are\ndoing now).\n\nOnce we have the address, we need to get the relative offset and then we can use 0xE8\nopcode with this relative offset to patch the call “ResolveApiByHash”. Finally, we append two\n**nop instructions after to overwrite the proceeding “call eax”.**\n\n\n-----\n\n```\n  def patch_apicall(addr, apicall):\n\n  '''\n\n  If it cannot be resolved, it is possible that the malware has not loaded the\nlibrary yet (for example, wininet.dll). In this case, we can force the load of the\nmodule using AppCall:\n\n  loadlib = Appcall.proto(\"kernel32_LoadLibraryA\", \"int __stdcall loadlib(const\nchar *fn);\")\n\n  hmod = loadlib(\"wininet.dll\")\n\n  '''\n\n  loadlib = Appcall.proto(\"kernel32_LoadLibraryA\", \"int __stdcall loadlib(const\nchar *fn);\")\n\n  print('apicall: {}'.format(apicall))\n\n  apiaddr = idc.LocByName(apicall)\n\n  if apiaddr == 0xFFFFFFFF:\n\n    hmod = loadlib('{}.dll'.format(apicall.split('_')[0]))\n\n    apiaddr = idc.LocByName(apicall)\n\n    if apiaddr == 0xFFFFFFFF:\n\n      return False\n\n  # At this point, apiaddr has the address of the Api call that we want. (e.g\n0x772AB880 for wininet_InternetOpenA)\n\n  rel_offset = (apiaddr - addr - 5) & 0xFFFFFFFF\n\n  idc.PatchDword(addr+1, rel_offset) # Patch “call ResolveApiByHash” -> “call\nInternetOpenA”\n\n  idc.PatchByte(addr+5, 0x90) # patch with nop\n\n  idc.PatchByte(addr+6, 0x90) # patch with nop\n\n  return\n\nsetup(\"c:\\murmurhash2_hashes_dict.json\") # Big Python dict. With hashes and export\nnames\n\npatches = resolve_all_APIs(0x004082D3) # Use address of “ResolveApiByHash”\n\npatch_apicall_wrapper(patches) # Patch the binary\n\n\n\n```\nWith this implementation, we have now patched all the calls to the real exports that the\nmalware wants to use. However, IDA has now trouble identifying and displaying properly the\narguments of the functions in the decompiler view. An example of this can be seen in the\nfollowing picture:\n\n\n-----\n\nFigure 10. Example before (left) and after (right) the script execution. Binary is patched to\ncall the real function\n\nFigure 11. Example of how arguments cannot be easily recognized at first by IDA decompiler\nyet\n\nThe last thing to do here is to remove the instructions related with the Windows API call\nresolution (registry operations used to move the .dll string and the hash). This way the\ndecompiler will show the arguments and everything as expected, while the code will look\nclean and show only the necessary instructions. This would be the final implementation of\nthe previous “patch_apicall” function:\n\n\n-----\n\n```\n  def patch_apicall(addr, apicall):\n\n  '''\n\n  If it cannot be resolved, it is possible that the malware has not loaded the\nlibrary yet (for example, wininet.dll). In this case, we can force the load of the\nmodule using AppCall:\n\n  loadlib = Appcall.proto(\"kernel32_LoadLibraryA\", \"int __stdcall loadlib(const\nchar *fn);\")\n\n  hmod = loadlib(\"wininet.dll\")\n\n  '''\n\n  loadlib = Appcall.proto(\"kernel32_LoadLibraryA\", \"int __stdcall loadlib(const\nchar *fn);\")\n\n  print('apicall: {}'.format(apicall))\n\n  apiaddr = idc.LocByName(apicall)\n\n  if apiaddr == 0xFFFFFFFF:\n\n    hmod = loadlib('{}.dll'.format(apicall.split('_')[0]))\n\n    apiaddr = idc.LocByName(apicall)\n\n    if apiaddr == 0xFFFFFFFF:\n\n      return False\n\n  # At this point, apiaddr has the address of the Api call that we want. (e.g\n0x772AB880 for wininet_InternetOpenA)\n\n  rel_offset = (apiaddr - addr - 5) & 0xFFFFFFFF\n\n  idc.PatchDword(addr+1, rel_offset) # Patch “call ResolveApiByHash” -> “call\nInternetOpenA”\n\n  idc.PatchByte(addr+5, 0x90) # patch with nop\n\n  idc.PatchByte(addr+6, 0x90) # patch with nop\n\n  curr_ea = addr\n\n  for _ in range(20): # Search maximum the last 20 instructions before the call to\nResolveApiByHash\n\n    prev_instruction_ea = idc.PrevHead(curr_ea)\n\n    instruction = idc.GetDisasm(prev_instruction_ea)\n\n    instruction_cut = instruction.replace(' ', '')\n\n    if 'movecx' in instruction_cut or \\\n\n      'movedx' in instruction_cut:\n\n      operand_type = idc.GetOpType(prev_instruction_ea, 1)\n\n      param = idc.GetOperandValue(prev_instruction_ea, 1)\n\n      # Only allow for:\n\n      # 1- General Register\n\n      # 2- Direct Memory reference (DATA)\n\n      # 5- Immediate Value\n\n```\n\n-----\n\n```\n      if operand_type not in [1, 2, 5]:\n\n        curr_ea = prev_instruction_ea\n\n        continue\n\n      if param < 0x10:\n\n        if not 'eax' in instruction_cut: # Avoid patching result from\nprevious calls\n\n          # This means the operand is a register (1-byte mov operation e.g\n8B CE mov   ecx, esi)\n\n          # NOP the instruction\n\n          PatchNops(prev_instruction_ea, 2)\n\n\n      else:\n\n        # This means the operand is 4-byte length (e.g B9 D6 3F B0 78 mov  \necx, 78B03FD6h)\n\n        PatchNops(prev_instruction_ea, 5)\n\n    curr_ea = prev_instruction_ea\n\n\n  return True\n\ndef PatchNops(addr, size):\n\n  for i in range(size):\n\n    print(\"Patching NOP at addr: {}\".format(hex(addr+i)))\n\n    idc.PatchByte(addr+i, 0x90) #patch with nop\n\n\nsetup(\"c:\\murmurhash2_hashes_dict.json\") # Big Python dict. With hashes and export\nnames\n\npatches = resolve_all_APIs(0x004082D3) # Use address of “ResolveApiByHash”\n\npatch_apicall_wrapper(patches) # Patch the binary\n\n\n```\nWith this in place, we can execute the script in a debugging session on Entry Point and\nremove most of the code related to Windows API call obfuscation while patching the binary\nto get an equivalent working sample easier to analyze and reverse engineer.\n\nThe following figure shows the result of patching the binary with our script:\n\n\n-----\n\nFigure 12. Example of how instructions related to Windows API call obfuscation have been\npatched with nops\n\nAs we can see, we only have relevant instructions in our disassembly (nop instructions have\npatched out Windows API call obfuscation scheme). And, as a result, it is easy for IDA\ndecompiler now to understand and properly display the arguments for our Windows API calls\nin the first attempt:\n\nFigure 13. Example before (up) and after (down) patching the binary with our last script.\n\nHere we have the main networking exfiltration routine before applying any of our scripts and\n**after patching the binary. As we can see, the result is a much clear and easy to understand**\nroutine:\n\n\n-----\n\nFigure 14. Decompiled view of Network Exfiltration routine without patching the binary\n\nFigure 15. Decompiled view of Network Exfiltration routine after patching the binary with our\nscript\n\n### Strings Obfuscation\n\n\n-----\n\nFigure 16. View of LummaC2 obfuscated strings in the binary\n\nLummaC2 “obfuscates” most of the strings used in the malware in order to evade detection.\nBy stripping every occurrence of “edx765” from a given string, we can easily get the original\none. Most of these strings are used to walk through sensitive files inside directories.\n\nAs it can be seen, the obfuscation method is very simple and for this reason, it is probable\nthat we see changes in this implementation in future versions of the malware.\n\n**LummaC2 Workflow**\n\nThe following diagram shows LummaC2 main workflow. This malware goes straight to the\npoint and only cares about exfiltrating stolen information. No persistence mechanisms are\nused and there is no control on how many malware instances can run at the same time. One\ndifference regarding many information stealers is that this malware family does not care\nabout the machine being infected, while others avoid infecting machines coming from the\nCommonwealth of Independent States.\n\n\n-----\n\nFigure 17. LummaC2 main workflow diagram\n\n**Information Gathering**\n\nLummaC2 gathers information from the victim system. This information is saved in a file\nnamed “System.txt” prior to zip compression and exfiltration. The information gathered\nfrom the infected machine includes the Username, Hardware ID, Screen Resolution and\n\n\n-----\n\nmore:\n\nFigure 18. System Information gathered from LummaC2\n\nThis information is obtained using the following Windows API calls respectively:\n\nGetComputerNameA\nGetUserNameA\nGetCurrentHwProfileA\nGetSystemMetrics\nGetSystemDefaultLocaleName\ncpuid\nGetPhysicallyInstalledSystemMemory\n\n**Steal Important Files**\n\nLummaC2 will also steal files from the victim machine and save them under “Important\nFiles/Profile”. What happens to be considered here an “important file” is actually every *.txt\nfile under %userprofile%. This is done in a recursive call that traverses %userprofile% with a\nmaximum recursion depth of 2 directories.\n\nFigure 19. LummaC2 code responsible for gathering system information and important files\n\n**Targeted Software**\n\nAfter gathering information from the infected machine and stealing important files, it\nproceeds to steal crypto wallets for Binance, Electrum and Ethereum (in this order). Once\nthis is finished it exfiltrates data (ZIP compressed) to the C2 and continues the stealing\nprocess.\n\n**Crypto Wallets**\n\n\n-----\n\nBinance\n\nElectrum\n\nEthereum\n\nTable 1. LummaC2 targeted Crypto Wallets\n\nAfter the first exfiltration to the Command and Control server, LummaC2 proceeds to steal\nrelevant Browsers information like Login Data, History, cookies, etc. Affected Browsers\nare:\n\n**Web Browsers**\n\nChrome\n\nChromium\n\nEdge\n\nKometa\n\nVivaldi\n\nBrave-Browser\n\nOpera Stable\n\nOpera GX Stable\n\nOpera Neon\n\nMozilla Firefox\n\nTable 2. LummaC2 targeted Web Browsers\n\n\n-----\n\nThe malware also targets Crypto Wallets and two-factor authentication (2FA) browser\n**extensions that may have been installed in the system. The following figure shows**\n**LummaC2 searching for these elements:**\n\nFigure 20. LummaC2 targeting Crypto Wallets and two-factor authentication (2FA)\nextensions\n\nThe following Crypto Wallets and two-factor authentication (2FA) extensions are targeted\nin LummaC2:\n\n**Crypto Wallet Extensions**\n\nMetamask BitApp Sollet Nash Extension\n\nTronLink iWlt Auro Hycon Lite Client\n\nRonnin Wallet Wombat Polymesh ZilPay\n\nBinance Chain Wallet MEW CX ICONex Coin98\n\nYoroi Guild Nabox Cyano\n\nNifty Saturn KHC Byone\n\n\n-----\n\nMath NeoLine Temple OneKey\n\nCoinbase Clover TezBox Leaf\n\nGuarda Liquality DAppPlay\n\nEQUAL Terra Station BitClip\n\nJaxx Liberty Keplr Steem Keychain\n\nTable 3. LummaC2 targeted Crypto Wallet extensions\n\n**Two-Factor Authentication (2FA) Extensions**\n\nAuthenticator\n\nAuthy\n\nEOS Authenticator\n\nGAuth Authenticator\n\nTrezor Password Manager\n\nTable 4. LummaC2 targeted two-factor authentication (2FA) extensions\n\n**Network Data Exfiltration**\n\nCommunication with the Command and Control server is one-way only. The malware does\nnot expect any response from its C2. As we can see from LummaC2 workflow diagram, the\nmalware contacts the C2 in different stealing phases. After each phase, stolen information is\nsent to the C2 ZIP compressed.\n\n\n-----\n\nFigure 21. LummaC2 HTTP POST request headers\n\nLummaC2 exfiltrates stolen information via HTTP POST request. These requests are made\nto the resource “/c2sock” and use multipart/form-data (combines one or more sets of data\ninto a single body, separated by boundaries) to upload a compressed ZIP file containing the\nstolen information along with more information (like the hardware id, obtained previously with\n**GetCurrentHwProfileA). The following figure shows the different set of data sent to the C2:**\n\nFigure 22. LummaC2 multipart/form-data fields used when exfiltrating information\n\nFirst field (highlighted one) is the filed with name “file”. This includes the ZIP compressed\nfile with sensitive information being exfiltrated.\n\nThe next field with name “hwid” contains the Hardware Id previously retrieved using\n**GetCurrentHwProfileA**\n\nThe field with name “pid” can be understood as “petition Id”. It is the number of the\nexfiltration attempt. As we saw earlier in the workflow diagram, LummaC2 can exfiltrate up to\n3 different times after each stealing phase. From the analyzed sample, we can only expect to\nsee values 1, 2 or 3, which means that if we detect LummaC2 networking activity with\ndifferent “petition Id” we will be dealing with a newer/updated version of the malware.\n\nFinally, the last field with name “lid” comes with the hardcoded value\n“xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx”. This is known as the “Lumma ID” and it can be\nunderstood as an identifier of the malware that may refer to the build or campaign id. This\nfield is also used when gathering system information (in the creation of “System.txt” file being\nexfiltrated).\n\n\n-----\n\nNetwork data being transmitted to the C2 can be recognized in the following figure, where an\nexcerpt of the first HTTP POST exfiltration request (request with “pid” equals 1) using\nmultipart/form-data is sending a ZIP compressed file:\n\nFigure 23. LummaC2 Hex view of HTTP POST request for exfiltration\n\n### MITRE ATT&CK\n\n**Tactic** **Technique ID** **Technique**\n\nDefense Evasion T1140 [Deobfuscate/Decode Files or Information](https://attack.mitre.org/techniques/T1140/)\n\nDefense Evasion T1027 [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027/)\n\nCredential Access T1539 [Steal Web Session Cookie](https://attack.mitre.org/techniques/T1539/)\n\nCredential Access T1555 [Credentials from Password Stores](https://attack.mitre.org/techniques/T1555/)\n\nCredential Access T1552 [Unsecured Credentials](https://attack.mitre.org/techniques/T1552/)\n\nDiscovery T1083 [File and Directory Discovery](https://attack.mitre.org/techniques/T1083/)\n\nDiscovery T1082 [System Information Discovery](https://attack.mitre.org/techniques/T1082/)\n\n\n-----\n\nDiscovery T1033 [System Owner/User Discovery](https://attack.mitre.org/techniques/T1033/)\n\nCollection T1560 [Archive Collected Data](https://attack.mitre.org/techniques/T1560/)\n\nCollection T1119 [Automated Collection](https://attack.mitre.org/techniques/T1119/)\n\nCollection T1005 [Data from Local System](https://attack.mitre.org/techniques/T1005/)\n\nExfiltration T1041 [Exfiltration over C2 Channel](https://attack.mitre.org/techniques/T1041/)\n\nExfiltration T1020 [Automated Exfiltration](https://attack.mitre.org/techniques/T1020/)\n\nCommand and Control T1071 [Application Layer Protocol](https://attack.mitre.org/techniques/T1071/)\n\nCommand and Control T1132 [Data Encoding](https://attack.mitre.org/techniques/T1132/)\n\nTable 5. LummaC2 MITRE ATT&CK matrix\n\n### Conclusion\n\nAs it has been shown, LummaC2 behaves similar to other information stealers. By capturing\nsensitive data from infected machines, including business credentials, it can do a lot of\ndamage. For example, compromised credentials can be used to achieve privilege escalation\n[and lateral movement. Compromised business accounts can also be used to send spam and](https://outpost24.com/blog/an-analysis-of-a-spam-distribution-botnet)\nfurther distribute the malware.\n\nThe fact the malware is being actively used in the wild indicates the professionalization in the\ndevelopment of these products. Bad actors are willing to pay for these tools because they\nprefer quality, and more features. In return, they expect to see more profit from the exfiltrated\ndata.\n\nOutpost24’s KrakenLabs will continue to analyze new malware samples as part of our Threat\nIntelligence solution, which can retrieve compromised credentials in real-time to prevent\nunauthorized access to your systems.\n\n### IOCs\n\n**Hash**\n\nLummaC2 sample:\n\n\n-----\n\n277d7f450268aeb4e7fe942f70a9df63aa429d703e9400370f0621a438e918bf\n\n**C2**\n\nLummaC2 Command and Control server:\n\n195[.]123[.]226[.]91\n\n### References\n\n“LummaC2 Stealer: A Potent Threat to Crypto Users”, January, 2023. [Online]. Available:\n[https://blog.cyble.com/2023/01/06/lummac2-stealer-a-potent-threat-to-crypto-users/](https://blog.cyble.com/2023/01/06/lummac2-stealer-a-potent-threat-to-crypto-users/)\n\n[Accessed March 20, 2023]\n\n“Popularity spikes for information stealer malware on the dark web”, December, 2022.\n\n[Online]. Available: https://www.accenture.com/us-en/blogs/security/information-stealermalware-on-dark-web [Accessed March 20, 2023]\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-04-05 - Everything you need to know about the LummaC2 Stealer- Leveraging IDA Python and Unicorn to deobfuscate Windows API Hashing.pdf"
    ],
    "report_names": [
        "2023-04-05 - Everything you need to know about the LummaC2 Stealer- Leveraging IDA Python and Unicorn to deobfuscate Windows API Hashing.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "9f101d9c-05ea-48b9-b6f1-168cd6d06d12",
            "created_at": "2023-01-06T13:46:39.396409Z",
            "updated_at": "2025-03-27T02:00:03.074969Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "CHROMIUM",
                "ControlX",
                "Red Dev 10",
                "RedHotel",
                "Red Scylla",
                "TAG-22",
                "BRONZE UNIVERSITY",
                "AQUATIC PANDA",
                "Charcoal Typhoon",
                "BountyGlad"
            ],
            "source_name": "MISPGALAXY:Earth Lusca",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "a66438a8-ebf6-4397-9ad5-ed07f93330aa",
            "created_at": "2022-10-25T16:47:55.919702Z",
            "updated_at": "2025-03-27T02:05:17.412024Z",
            "deleted_at": null,
            "main_name": "IRON VIKING",
            "aliases": [
                "ATK14 ",
                "BlackEnergy Group",
                "Blue Echidna ",
                "CTG-7263 ",
                "ELECTRUM ",
                "FROZENBARENTS ",
                "Hades/OlympicDestroyer ",
                "IRIDIUM ",
                "Qudedagh ",
                "Sandworm Team ",
                "Seashell Blizzard ",
                "TEMP.Noble ",
                "Telebots ",
                "Voodoo Bear ",
                "APT44 "
            ],
            "source_name": "Secureworks:IRON VIKING",
            "tools": [
                " BlackEnergy",
                " GCat",
                " GreyEnergy",
                " Industroyer",
                " KillDisk",
                " NotPetya",
                " PSCrypt",
                " TeleBot",
                " TeleDoor",
                " xData",
                "BadRabbit"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "b3e954e8-8bbb-46f3-84de-d6f12dc7e1a6",
            "created_at": "2022-10-25T15:50:23.339976Z",
            "updated_at": "2025-03-27T02:00:55.446795Z",
            "deleted_at": null,
            "main_name": "Sandworm Team",
            "aliases": [
                "Sandworm Team",
                "ELECTRUM",
                "Telebots",
                "IRON VIKING",
                "BlackEnergy (Group)",
                "Quedagh",
                "Voodoo Bear",
                "IRIDIUM",
                "Seashell Blizzard",
                "FROZENBARENTS",
                "APT44"
            ],
            "source_name": "MITRE:Sandworm Team",
            "tools": [
                "Bad Rabbit",
                "Mimikatz",
                "Exaramel for Linux",
                "Exaramel for Windows",
                "GreyEnergy",
                "PsExec",
                "Prestige",
                "P.A.S. Webshell",
                "VPNFilter",
                "Cyclops Blink",
                "SDelete",
                "AcidRain",
                "Industroyer",
                "Industroyer2",
                "BlackEnergy",
                "Cobalt Strike",
                "NotPetya",
                "KillDisk",
                "PoshC2",
                "Impacket",
                "Invoke-PSImage",
                "Olympic Destroyer"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "3a0be4ff-9074-4efd-98e4-47c6a62b14ad",
            "created_at": "2022-10-25T16:07:23.590051Z",
            "updated_at": "2025-03-27T02:02:09.878211Z",
            "deleted_at": null,
            "main_name": "Energetic Bear",
            "aliases": [
                "ATK 6",
                "Blue Kraken",
                "Crouching Yeti",
                "Dragonfly",
                "Electrum",
                "Energetic Bear",
                "Ghost Blizzard",
                "Group 24",
                "ITG15",
                "Iron Liberty",
                "Koala Team",
                "TG-4192"
            ],
            "source_name": "ETDA:Energetic Bear",
            "tools": [
                "Backdoor.Oldrea",
                "CRASHOVERRIDE",
                "Commix",
                "CrackMapExec",
                "CrashOverride",
                "Dirsearch",
                "Dorshel",
                "Fertger",
                "Fuerboos",
                "Goodor",
                "Havex",
                "Havex RAT",
                "Hello EK",
                "Heriplor",
                "Impacket",
                "Industroyer",
                "Karagany",
                "Karagny",
                "LightsOut 2.0",
                "LightsOut EK",
                "Listrix",
                "Oldrea",
                "PEACEPIPE",
                "PHPMailer",
                "PsExec",
                "SMBTrap",
                "Subbrute",
                "Sublist3r",
                "Sysmain",
                "Trojan.Karagany",
                "WSO",
                "Webshell by Orb",
                "Win32/Industroyer",
                "Wpscan",
                "nmap",
                "sqlmap",
                "xFrost"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "6abcc917-035c-4e9b-a53f-eaee636749c3",
            "created_at": "2022-10-25T16:07:23.565337Z",
            "updated_at": "2025-03-27T02:02:09.868522Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Bronze University",
                "Charcoal Typhoon",
                "Chromium",
                "Red Dev 10",
                "Red Scylla"
            ],
            "source_name": "ETDA:Earth Lusca",
            "tools": [
                "Agentemis",
                "AntSword",
                "BIOPASS",
                "BIOPASS RAT",
                "BadPotato",
                "Behinder",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "Doraemon",
                "FRP",
                "Fast Reverse Proxy",
                "FunnySwitch",
                "HUC Port Banner Scanner",
                "KTLVdoor",
                "Mimikatz",
                "NBTscan",
                "POISONPLUG.SHADOW",
                "PipeMon",
                "RbDoor",
                "RibDoor",
                "RouterGod",
                "SAMRID",
                "ShadowPad Winnti",
                "SprySOCKS",
                "WinRAR",
                "Winnti",
                "XShellGhost",
                "cobeacon",
                "fscan",
                "lcx",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "8941e146-3e7f-4b4e-9b66-c2da052ee6df",
            "created_at": "2023-01-06T13:46:38.402513Z",
            "updated_at": "2025-03-27T02:00:02.824555Z",
            "deleted_at": null,
            "main_name": "Sandworm",
            "aliases": [
                "G0034",
                "IRIDIUM",
                "Blue Echidna",
                "FROZENBARENTS",
                "Seashell Blizzard",
                "IRON VIKING",
                "ELECTRUM",
                "TeleBots",
                "UAC-0113",
                "UAC-0082",
                "APT44",
                "Quedagh",
                "VOODOO BEAR",
                "TEMP.Noble"
            ],
            "source_name": "MISPGALAXY:Sandworm",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d53593c3-2819-4af3-bf16-0c39edc64920",
            "created_at": "2022-10-27T08:27:13.212301Z",
            "updated_at": "2025-03-27T02:00:55.529662Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Earth Lusca",
                "TAG-22",
                "Charcoal Typhoon",
                "CHROMIUM",
                "ControlX"
            ],
            "source_name": "MITRE:Earth Lusca",
            "tools": [
                "Mimikatz",
                "PowerSploit",
                "Tasklist",
                "certutil",
                "Cobalt Strike",
                "Winnti for Linux",
                "Nltest",
                "NBTscan",
                "ShadowPad"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1683338993,
    "ts_updated_at": 1743041735,
    "ts_creation_date": 1683251620,
    "ts_modification_date": 1683251620,
    "files": {
        "pdf": "https://archive.orkl.eu/5a01756c0276dd61b58c16689efe050adbefc147.pdf",
        "text": "https://archive.orkl.eu/5a01756c0276dd61b58c16689efe050adbefc147.txt",
        "img": "https://archive.orkl.eu/5a01756c0276dd61b58c16689efe050adbefc147.jpg"
    }
}