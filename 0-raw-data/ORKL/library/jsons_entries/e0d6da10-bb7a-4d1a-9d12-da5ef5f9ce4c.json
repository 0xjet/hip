{
    "id": "e0d6da10-bb7a-4d1a-9d12-da5ef5f9ce4c",
    "created_at": "2023-01-12T15:01:12.648565Z",
    "updated_at": "2025-03-27T02:16:39.955581Z",
    "deleted_at": null,
    "sha1_hash": "3fe6b724cba9c888bdff8b2340519c31930720da",
    "title": "2022-09-22 - Raspberry Robin’s Roshtyak- A Little Lesson in Trickery",
    "authors": "",
    "file_creation_date": "2022-10-02T12:20:43Z",
    "file_modification_date": "2022-10-02T12:20:43Z",
    "file_size": 1200500,
    "plain_text": "# Raspberry Robin’s Roshtyak: A Little Lesson in Trickery\n\n**[decoded.avast.io/janvojtesek/raspberry-robins-roshtyak-a-little-lesson-in-trickery/](https://decoded.avast.io/janvojtesek/raspberry-robins-roshtyak-a-little-lesson-in-trickery/)**\n\nSeptember 22, 2022\n\nby [Jan VojtěšekSeptember 22, 202246 min read](https://decoded.avast.io/author/janvojtesek/)\n\nThere are various tricks malware authors use to make malware analysts’ jobs more difficult.\nThese tricks include obfuscation techniques to complicate reverse engineering, antisandbox techniques to evade sandboxes, packing to bypass static detection, and more.\n[Countless deceptive tricks used by various malware strains in-the-wild have been](https://anti-reversing.com/Downloads/Anti-Reversing/The_Ultimate_Anti-Reversing_Reference.pdf)\n[documented over the years. However, few of these tricks are implemented in a typical piece](https://evasions.checkpoint.com/)\nof malware, despite the many available tricks.\n\nThe subject of this blog post, a backdoor we dubbed Roshtyak, is not your typical piece of\nmalware. Roshtyak is full of tricks. Some are well-known, and some we have never seen\nbefore. From a technical perspective, the lengths Roshtyak takes to protect itself are\nextremely interesting. Roshtyak belongs to one of the best-protected malware strains we\nhave ever seen. We hope by publishing our research and analysis of the malware and its\nprotection tricks we will help fellow researchers recognize and respond to similar tricks, and\nharden their analysis environments, making them more resistant to the evasion techniques\ndescribed.\n\nRoshtyak is the DLL backdoor used by Raspberry Robin, a worm spreading through\ninfected removable drives. Raspberry Robin is extremely prevalent. We protected over\n550K of our users from the worm this year. Due to its high prevalence, it should be no\nsurprise that we aren’t the only ones taking note of Raspberry Robin.\n\n[Red Canary’s researchers published the first analysis of Raspberry Robin in May 2022. In](https://redcanary.com/blog/raspberry-robin/)\n[June, Symantec published a report describing a mining/clipboard hijacking operation, which](https://symantec-enterprise-blogs.security.com/blogs/threat-intelligence/clipminer-bitcoin-mining-hijacking)\nreportedly made the cybercriminals at least $1.7 million. Symantec did not link the malicious\noperation to Raspberry Robin. Nevertheless, we assess with high confidence that what they\nanalyzed was Raspberry Robin. This assessment is based on C&C overlaps, strong\nmalware similarity, and coinfections observed in our telemetry. [Cybereason,](https://www.cybereason.com/blog/threat-alert-raspberry-robin-worm-abuses-windows-installer-and-qnap-devices) [Microsoft, and](https://www.microsoft.com/security/blog/2022/05/09/ransomware-as-a-service-understanding-the-cybercrime-gig-economy-and-how-to-protect-yourself/#DEV-0206-DEV-0243)\n[Cisco published further reports in July/August 2022. Microsoft reported that Raspberry](https://blogs.cisco.com/security/raspberry-robin-highly-evasive-worm-spreads-over-external-disks)\n\n\n-----\n\nRobin infections led to DEV-0243 (a.k.a Evil Corp) pre-ransomware behavior. We could not\nconfirm this connection using our telemetry. Still, we find it reasonable to believe that the\nminer payload is not the only way Raspberry Robin infections are being monetized. Other\n[recent](https://securityintelligence.com/posts/raspberry-robin-worm-dridex-malware/) [reports also hint at a possible connection between Raspberry Robin and Evil Corp.](https://twitter.com/DTCERT/status/1565664874633564162)\n\n_A map showing the number of users Avast protected from Raspberry Robin_\nThere are many unknowns about Raspberry Robin, despite so many published reports.\nWhat are the ultimate objectives behind the malware? Who is responsible for Raspberry\nRobin? How did it become so prevalent? Unfortunately, we do not have answers to all these\nquestions. However, we can answer an important question we saw asked multiple times:\nWhat functionality is hidden inside the heavily obfuscated DLL (or Roshtyak as we call it)?\n[To answer this question, we fully reverse engineered a Roshtyak sample, and present our](https://www.virustotal.com/gui/file/1073d38346b39fb3d92f4cd814ea13d32ecf5b16c07c87560802343bd1605dfd)\nanalysis results in this blog post.\n\n## Overview\n\nRoshtyak is packed in as many as 14 protective layers, each heavily obfuscated and\nserving a specific purpose. Some artifacts suggest the layers were originally PE files but\nwere transformed into custom encrypted structures that only the previous layers know how\nto decrypt and load. Numerous anti-debugger, anti-sandbox, anti-VM, and anti-emulator\nchecks are sprinkled throughout the layers. If one of these checks successfully detects an\nanalysis environment, one of four actions are taken.\n\n\n-----\n\n1. The malware calls `TerminateProcess on itself to avoid exhibiting any further`\n\nmalicious behavior and to keep the subsequent layers encrypted.\n2. Roshtyak crashes on purpose. This has the same effect as terminating itself, but it\n\nmight not be immediately clear if the crash was intentional or because of a bug thanks\nto Roshtyak’s obfuscated nature.\n3. The malware enters an infinite loop on purpose. Since the loop itself is located in\n\nobfuscated code and spans thousands of instructions, it might be hard to determine if\nthe loop is doing something useful or not.\n4. The most interesting case is when the malware reacts to a successful check by\n\nunpacking and loading a fake payload. This happens in the eighth layer, which is\nloaded with dozens of anti-analysis checks. The result of each of these checks is used\nto modify the value of a global variable. There are two payloads encrypted in the data\nsection of the eighth layer: the real ninth layer and a fake payload. The real ninth layer\nwill get decrypted only if the global variable matches the expected value after all the\nchecks have been performed. If at least one check succeeded in detecting an analysis\nenvironment, the global variable’s value will differ from the expected value, causing\nRoshtyak to unpack and execute the fake payload instead.\n\n\n-----\n\n_Roshtyak’s obfuscation causes even relatively simple functions to grow into large_\n_proportions. This necessitates some custom deobfuscation tooling if one wants to reverse_\n_engineer it within a reasonable timeframe._\n[The fake payload is a BroAssist (a.k.a BrowserAssistant) adware sample. We believe this](https://www.virustotal.com/gui/file/b74d7ff45768a1ee6f267e895de3e46cca505edf205563ef3f7db827f38363b3)\nfake payload was intended to mislead malware analysts into thinking the sample is less\ninteresting than it really is. When a reverse engineer focuses on quickly unpacking a\nsample, it might look like the whole sample is “just” an obfuscated piece of adware (and a\nvery old one at that), which could cause the analyst to lose interest in digging deeper. And\nindeed, it turns out that these fake payload shenanigans can be very effective. As can be\nseen on the screenshot below, it fooled at least one researcher, who misattributed the\nRaspberry Robin worm, because of the fake BrowserAssistant payload.\n\n\n-----\n\n_A security researcher misattributing Raspberry Robin because of the fake payload. This is_\n_not to pick on anyone, we just want to show how easy it is to make a mistake like this given_\n_Roshtyak’s trickery and complexity._\n\n## The Bag of Tricks\n\nFor the sake of keeping this blog post (sort of) short and to the point, let’s get straight into\ndetailing some of the more interesting evasion techniques employed by Roshtyak.\n\n**Segment registers**\n\nEarly in the execution, Roshtyak prefers to use checks that do not require calling any\nimported functions. If one of these checks is successful, the sample can quietly exit without\ngenerating any suspicious API calls. Below is an example where Roshtyak checks the\nbehavior of the `gs segment register. The check is designed to be stealthy and the`\nsurrounding garbage instructions make it easy to overlook.\n\n\n-----\n\n_A stealthy detection of single-stepping. Only the_\n\n_underscored instructions are useful._\nThe first idea behind this check is to detect single-stepping. Before the above snippet, the\nvalue of `cx was initialized to` `2 . After the` `pop ecx instruction, Roshtyak checks if` `cx`\nis still equal to `2 . This would be the expected behavior because this value should`\npropagate through the stack and the `gs register under normal circumstances. However, a`\nsingle step event would reset the value of the `gs selector, which would result in a different`\nvalue getting popped into `ecx at the end.`\n\nBut there is more to this check. As a side effect of the two push/pop pairs above, the value\nof `gs is temporarily changed to` `2 . After this check, Roshtyak enters a loop, counting the`\nnumber of iterations until the value of `gs is no longer` `2 . The` `gs selector is also reset`\nafter a thread context switch, so the loop essentially counts the number of iterations until a\ncontext switch happens. Roshtyak repeats this procedure multiple times, averages out the\nresult, and checks that it belongs to a sensible range for a bare metal execution\nenvironment. If the sample runs under a hypervisor or in an emulator, the average number\nof iterations might fall outside of this range, which allows Roshtyak to detect undesirable\nexecution environments.\n\nRoshtyak also checks that the value of the `cs segment register is either` `0x1b or` `0x23 .`\nHere, `0x1b is the expected value when running on native x86 Windows, while` `0x23 is`\nthe expected value under WoW64.\n\n\n-----\n\n**APC injection through a random ntdll gadget**\n\nRoshtyak performs some of its functionality from separate processes. For example, when it\ncommunicates with its C&C server, it spawns a new innocent-looking process like\n```\nregsvr32.exe . Using shared sections, it injects its comms module into the address space\n\n```\nof the new process. The injected module is executed via APC injection, using\n```\nNtQueueApcThreadEx .\n\n```\nInterestingly, the `ApcRoutine argument (which marks the target routine to be scheduled`\nfor execution) does not point to the entry point of the injected module. Instead, it points to a\nseemingly random address inside `ntdll . Taking a closer look, we see this address was`\nnot chosen randomly but that Roshtyak scanned the code section of `ntdll for` `pop r32;`\n```\nret gadgets (excluding pop esp, because pivoting the stack would be undesirable) and\n\n```\npicked one at random to use as the `ApcRoutine .`\n\n_A random_ `pop r32; ret gadget used as the entry point for APC injection`\nLooking at the calling convention for the `ApcRoutine reveals what’s going on. The` `pop`\ninstruction makes the stack pointer point to the `SystemArgument1 parameter of`\n```\nNtQueueApcThreadEx and so the ret instruction effectively jumps to wherever\nSystemArgument1 is pointing. This means that by abusing this gadget, Roshtyak can treat\nSystemArgument1 as the entry point for the purpose of APC injection. This obfuscates the\n\n```\n\n-----\n\ncontrol flow and makes the `NtQueueApcThreadEx call look more legitimate. If someone`\nhooks this function and inspects the `ApcRoutine argument, the fact that it is pointing into`\nthe `ntdll code section might be enough to convince them that the call is not malicious.`\n\n**Checking read/write performance on write-combined memory**\n\nIn this next check, Roshtyak allocates a large memory buffer with the\n[PAGE_WRITECOMBINE flag. This flag is supposed to modify cache behavior to optimize](https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants#:~:text=the%20CreateFileMapping%20function.-,PAGE_WRITECOMBINE,-0x400)\nsequential write performance (at the expense of read performance and possibly memory\nordering). Roshtyak uses this to detect if it’s running on a physical machine. It conducts an\nexperiment where it first writes to the allocated buffer and then reads from the allocated\nbuffer, all while measuring the read/write performance using a separate thread as a counter.\nThis experiment is repeated 32 times and the check is passed only if write performance was\nat least six times higher than read performance most of the times. If the check fails,\nRoshtyak intentionally selects a wrong RC4 key, which results in failing to properly decrypt\nthe next layer.\n\n**Hiding shellcode from plain sight**\n\nThe injected shellcode is interestingly hidden, too. When Roshtyak prepares for code\ninjection, it first creates a large section and maps it into the current process as\n```\nPAGE_READWRITE . Then, it fills the section with random data and places the shellcode at a\n\n```\nrandom offset within the random data. Since the shellcode is just a relatively small loader\nfollowed by random-looking packed data, the whole section looks like random data.\n\n_A histogram of the bytes inside the shared section. Note that it looks almost random, the_\n_most suspicious sign is the slight overrepresentation of null bytes._\n\n\n-----\n\nThe section is then unmapped from the current process and mapped into the target\nprocess, where it is executed using the above-described APC injection technique. The\nrandom data was added in an attempt to conceal the existence of the shellcode. Judging\nonly from the memory dump of the target process, it might look like the section is full of\nrandom data and does not contain any valid executable code. Even if one suspects actual\nvalid code somewhere in the middle of the section, it will not be easy to find its exact\nlocation.\n\n_The start of the shellcode_\n\n_within the shared section. It might be hard to pinpoint the exact start address because it_\n_unconventionally starts on an odd_ `bt instruction.`\n\n**Ret2Kernel32**\n\nRoshtyak makes a point of cleaning up after itself. Whenever a certain string or piece of\nmemory is no longer needed, Roshtyak wipes and/or frees it in an attempt to destroy as\nmuch evidence as possible. The same holds for Roshtyak’s layers. Whenever one layer\nfinishes its job, it frees itself before passing execution onto the next layer. However, the\nlayer cannot just simply free itself directly. The whole process would crash if it called\n```\nVirtualFree on the region of memory it’s currently executing from.\n\n```\nRoshtyak, therefore, frees the layer through a ROP chain executed during layer transitions\nto avoid this problem. When a layer is about to exit, it constructs a ROP chain on the stack\nand returns into it. An example of such a ROP chain can be seen below. This chain starts\nby returning into `VirtualFree and` `UnmapViewOfFile to release the previous layer’s`\nmemory. Then, it returns into the next layer. The return address from the next layer is set to\n```\nRtlExitUserThread, to safeguard execution.\n\n```\n\n-----\n\nA simple ROP chain consisting of `VirtualFree ->` `UnmapViewOfFile -> next layer ->`\n\n```\nRtlExitUserThread\n\n```\n\n**MulDiv bug**\n\n[MulDiv is a function exported by](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-muldiv) `kernel32.dll, which takes three signed 32-bit integers`\nas arguments. It multiplies the first two arguments, divides the multiplication result by the\nthird argument, and returns the final result rounded to the nearest integer. While this might\n[seem like a simple enough function, there’s an ancient sign extension bug in Microsoft’s](https://devblogs.microsoft.com/oldnewthing/20120514-00/?p=7633)\nimplementation. This bug is sort of considered a feature now and might never get fixed.\n\nRoshtyak is aware of the bug and tests for its presence by calling `MulDiv(1,`\n```\n0x80000000, 0x80000000) . On real Windows machines, this triggers the bug and\nMulDiv erroneously returns 2, even though the correct return value should be 1,\n\n```\nbecause `(1 * -2147483648) / -2147483648 = 1 . This allows Roshtyak to detect`\n[emulators that do not replicate the bug. For example, this successfully detects Wine, which,](https://www.winehq.org/)\nfunnily enough, contains a different bug, which makes the above call return `0 .`\n\n**Tampering with return addresses stored on the stack**\n\nThere are also tricks designed to obfuscate function calls. As shown in the previous section,\nRoshtyak likes to call functions using the `ret instruction. This next trick is similar in that it`\nalso manipulates the stack so a `ret instruction can be used to jump to the desired`\naddress.\n\nTo achieve this, Roshtyak scans the current thread’s stack for pointers into the code section\nof one of the previous layers (unlike the other layers, this one was not freed using the ROP\nchain technique). It replaces all these pointers with the address it wants to call. Then it lets\nthe code return multiple times until a `ret instruction encounters one of the hijacked`\npointers, redirecting the execution to the desired address.\n\n**Exception-based checks**\n\nAdditionally, Roshtyak contains checks that set up a custom vectored exception handler\nand intentionally trigger various exceptions to ensure they all get handled as expected.\n\n\n-----\n\nRoshtyak sets up a vectored exception handler using\n```\nRtlAddVectoredExceptionHandler . This handler contains custom handlers for selected\n\n```\nexception codes. A top-level exception handler is also registered using\n```\nSetUnhandledExceptionFilter . This handler should not be called in the targeted\n\n```\nexecution environments (none of the intentionally triggered exceptions should fall through\nthe vectored exception handler). So this top-level handler just contains a single call to\n```\nTerminateProcess . Interestingly, Roshtyak also uses ZwSetInformationProcess to\n\n```\nset `SEM_FAILCRITICALERRORS using the` `ProcessDefaultHardErrorMode class. This`\nensures that even if the exception somehow is passed all the way to the default exception\nhandler, Windows would not show the standard error message box, which could alert the\nvictim that something suspicious is going on.\n\nWhen everything is set up, Roshtyak begins generating exceptions. The first exception is\ngenerated by a `popf instruction, directly followed by a` `cpuid instruction (shown below).`\nThe value popped by the `popf instruction was crafted to set the trap flag, which should, in`\nturn, raise a single-step exception. On a physical machine, the exception would trigger right\nafter the `cpuid instruction. Then, the custom vectored exception handler would take over`\nand move the instruction pointer away from the `C7 B2 opcodes, which mark an invalid`\ninstruction. However, under many hypervisors, the single-step exception would not be\nraised. This is because the `cpuid instruction forces a VM exit, which might delay the`\neffect of the trap flag. If that is the case, the processor will raise an illegal instruction\nexception when trying to execute the invalid opcodes. If the vectored exception handler\nencounters such an exception, it knows that it is running under a hypervisor. A variation of\n[this technique is described thoroughly in a blog post by Palo Alto Networks. Please refer to](https://unit42.paloaltonetworks.com/single-bit-trap-flag-intel-cpu/)\nit for more details.\n\n\n-----\n\nThe\n\nexception-based check using `popf and` `cpuid to detect hypervisors`\nAnother exception is generated using the two-byte `int 3 instruction ( CD 03 ). This`\ninstruction is followed by garbage opcodes. The `int 3 here raises a breakpoint`\nexception, which is handled by the vectored exception handler. The vectored exception\nhandler doesn’t really do anything to handle the exception, which is interesting. This is\nbecause by default, when Windows handles the two-byte `int 3 instruction, it will leave`\nthe instruction pointer in between the two instruction bytes, pointing to the `03 byte. When`\ndisassembled from this `03 byte, the garbage opcodes suddenly start making sense. We`\nbelieve this is a check against some overeager debuggers, which could “fix” the instruction\npointer to point after the `03 byte.`\n\nMoreover, the vectored exception handler checks the thread’s `CONTEXT and makes sure`\nthat registers `Dr0 through` `Dr3 are empty. If they are not, the process is being debugged`\nusing hardware breakpoints. While this check is relatively common in malware, the\n```\nCONTEXT is usually obtained using a call to a function like GetThreadContext . Here, the\n\n```\nmalware authors took advantage of `CONTEXT being passed as an argument to the`\nexception handler, so they did not need to call any additional API functions.\n\n**Large executable mappings**\n\nThis next check is interesting mostly because we are not sure what it’s really supposed to\ncheck (in other words, we’d be happy to hear your theories!). It starts with Roshtyak\ncreating a large `PAGE_EXECUTE_READWRITE mapping of size` `0x386F000 . Then it maps`\nthis mapping nine times into its own address space. After this, it memsets the mapping to\n0x42 (opcode for `inc edx ), except for the last six bytes, which are filled with four` `inc`\n```\necx instructions and jmp dword ptr [ecx] (see below). Next, it puts the nine base\n\n```\n\n-----\n\naddresses of the mapped views into an array, followed by an address of a single `ret`\ninstruction. Finally, it points `ecx into this array and calls the first mapped view, which`\nresults in all the mapped views being called sequentially until the final `ret instruction.`\nAfter the return, Roshtyak validates that `edx got incremented exactly` `0x1FBE6FCA times`\n( 9 * (0x386F000 - 6) ).\n\n_The_\n\n_end of the large mapped section. The_ `jmp dword ptr [ecx] instruction is supposed to`\n_jump to the start of the next mapped view._\nOur best guess is that this is yet another anti-emulator check. For example, in some\nemulators, mapped sections might not be fully implemented, so the instructions written into\none instance of the mapped view might not propagate to the other eight instances. Another\ntheory is the check could be done to request large amounts of memory that emulators might\nfail to provide. After all, the combined size of all the views is almost half of the standard 32bit user mode address space.\n\n**Detecting process suspension**\n\nThis trick abuses an undocumented thread creation flag in `NtCreateThreadEx to detect`\nwhen Roshtyak’s main process gets externally suspended (which could mean that a\ndebugger got attached). This flag essentially allows a thread to keep running even when\n```\nPsSuspendProcess gets called. This is coupled with another trick abusing the fact that the\n\n```\nthread suspend counter is a signed 8-bit value, which means that it maxes out at 127.\nRoshtyak spawns two threads, one of which keeps suspending the other one until the\nsuspend counter limit is reached. After this, the first thread keeps periodically suspending\nthe other one and checking if the call to `NtSuspendThread keeps failing with`\n```\nSTATUS_SUSPEND_COUNT_EXCEEDED . If it does not, the thread must have been externally\n\n```\n\n-----\n\nsuspended and resumed (which would leave the suspend counter at 126, so the next call to\n```\nNtSuspendThread would succeed). Not getting this error code would be suspicious\n\n```\nenough for Roshtyak to quit using `TerminateProcess . This entire technique is described`\n[in more detail in a blog post by Secret Club. We believe that’s where the authors of](https://secret.club/2021/01/04/thread-stuff.html)\nRoshtyak got this trick from. It’s also worth mentioning Roshtyak uses this technique only on\nWindows builds 18323 (19H1) and later because the undocumented thread creation flag\nwas not implemented on prior builds.\n\n**Indirect registry writes**\n\nRoshtyak performs many suspicious registry operations, for example, setting up the\n```\nRunOnce key for persistence. Since modifications to such keys are likely to be monitored,\n\n```\nRoshtyak attempts to circumvent the monitoring. It first generates a random registry key\nname and temporarily renames the `RunOnce key to the random name using`\n```\nZwRenameKey . Once renamed, Roshtyak adds a new persistence entry to the temporary\n\n```\nkey before finally renaming it back to `RunOnce . This method of writing to the registry can`\nbe easily detected, but it might bypass some simple hooking-based monitoring methods.\n\nSimilarly, there are multiple methods Roshtyak uses to delete files. Aside from the apparent\ncall to `NtDeleteFile, Roshtyak is able to effectively delete a file by setting`\n```\nFileDispositionInformation or FileRenameInformation in a call to\nZwSetInformationFile . However, unlike the registry modification method, this doesn’t\n\n```\nseem to be implemented in order to evade detection. Instead, Roshtyak will try these\nalternative methods if the initial call to `NtDelete file fails.`\n\n**Checking VBAWarnings**\n\nThe `VBAWarnings registry value controls how Microsoft Office behaves when a user`\nopens a document containing embedded VBA macros. If this value is `1 (meaning “Enable`\nall macros”), macros are executed by default, even without the need for any user\ninteraction. This is a common setting for sandboxes, which are designed to detonate\nmaldocs automatically. On the other hand, this setting is uncommon for regular users, who\ngenerally don’t go around changing random settings to make themselves more vulnerable\n(at least most of them don’t). Roshtyak therefore uses this check to differentiate between\nsandboxes and regular users and refuses to run further if the value of `VBAWarnings is` `1 .`\nInterestingly, this means that users, who for whatever reason have lowered their security\nthis way, are immune to Roshtyak.\n\n**Command line wiping**\n\nRoshtyak’s core is executed with very suspicious command lines, such as `RUNDLL32.EXE`\n```\nSHELL32.DLL,ShellExec_RunDLL REGSVR32.EXE -U /s \"C:\\Users\\\n<REDACTED>\\AppData\\Local\\Temp\\dpcw.etl.\" . These command lines don’t look\n\n```\nparticularly legitimate, so Roshtyak attempts to hide them during execution. It does this by\n\n\n-----\n\nwiping command line information collected from various sources. It starts by calling\n```\nGetCommandLineA and GetCommandLineW and wiping both of the returned strings. Then\n\n```\nit attempts to wipe the string pointed to by `PEB->ProcessParameters->CommandLine`\n(even if this points to a string that has already been wiped). Since Roshtyak is often running\nunder WoW64, it also calls `NtWow64QueryInformationProcess64 to obtain a pointer to`\n```\nPEB64 to wipe ProcessParameters->CommandLine obtained by traversing this “second”\n\n```\nPEB. While the wiping of the command lines was probably meant to make Roshtyak look\nmore legitimate, the complete absence of any command line is also highly unusual. This\n[was noticed by the Red Canary researchers in their blog post, where they proposed a](https://redcanary.com/blog/raspberry-robin/)\ndetection method based on these suspiciously empty command lines.\n\n_Roshtyak’s core process, as shown_\n\n_by Process Explorer. Note the suspiciously empty command line._\n\n**Additional tricks**\n\nAside from the techniques described so far, Roshtyak uses many less sophisticated tricks\nthat are commonly found in other malware as well. These include:\n\nHiding threads using `ThreadHideFromDebugger (and verifying that the threads`\nreally got hidden using `NtQueryInformationThread )`\nPatching `DbgBreakPoint in` `ntdll`\nDetecting user inactivity using `GetLastInputInfo`\nChecking fields from PEB ( BeingDebugged, `NtGlobalFlag )`\nChecking fields from `KUSER_SHARED_DATA ( KdDebuggerEnabled,`\n```\n   ActiveProcessorCount, NumberOfPhysicalPages )\n\n```\nChecking the names of all running processes (some are compared by hash, some by\npatterns, and some by character distribution)\nHashing the names of all loaded modules and checking them against a hardcoded\nblacklist\nVerifying the main process name is not too long and doesn’t match known names\nused in sandboxes\nUsing the `cpuid instruction to check hypervisor information and the processor brand`\n\n\n-----\n\nUsing poorly documented COM interfaces\nChecking the username and computername against a hardcoded blacklist\nChecking for the presence of known sandbox decoy files\nChecking MAC addresses of own adapters against a hardcoded blacklist\nChecking MAC addresses from the ARP table (using `GetBestRoute to populate it`\nand `GetIpNetTable to inspect it)`\nCalling `ZwQueryInformationProcess with` `ProcessDebugObjectHandle,`\n```\n   ProcessDebugFlags, and ProcessDebugPort\n\n```\nChecking `DeviceId of display devices (using` `EnumDisplayDevices )`\nChecking `ProductId of` `\\\\.\\PhysicalDrive0 (using`\n```\n   IOCTL_STORAGE_QUERY_PROPERTY )\n\n```\nChecking for virtual hard disks (using `NtQuerySystemInformation with`\n```\n   SystemVhdBootInformation )\n\n```\nChecking the raw SMBIOS firmware table (using `NtQuerySystemInformation with`\n```\n   SystemFirmwareTableInformation )\n\n```\nSetting up Defender exclusions (both for paths and processes)\nRemoving IFEO registry keys related to process names used by the malware\n\n## Obfuscation\n\nWe’ve shown many anti-analysis tricks that are designed to prevent Roshtyak from\ndetonating in undesirable execution environments. These tricks alone would be easy to\npatch or bypass. What makes analyzing Roshtyak especially lethal is the combination of all\nthese tricks with heavy obfuscation and multiple layers of packing. This makes it very\ndifficult to study the anti-analysis tricks statically and figure out how to pass all the checks in\norder to get Roshtyak to unpack itself. Furthermore, even the main payload received the\nsame obfuscation, which means that statically analyzing Roshtyak’s core functionality also\nrequires a great deal of deobfuscation.\n\nIn the rest of this section, we’ll go through the main obfuscation techniques used by\nRoshtyak.\n\n\n-----\n\n_A random code snippet from Roshtyak. As can be seen, the obfuscation makes the raw_\n_output of the Hex-Rays decompiler practically incomprehensible._\n\n**Control flow flattening**\n\nControl flow flattening is one of the most noticeable obfuscation techniques employed by\nRoshtyak. It is implemented in an unusual way, giving the control flow graphs of Roshtyak’s\nfunctions a unique look (see below). The goal of control flow flattening is to obscure control\nflow relations between individual code blocks.\n\nControl flow is directed by a 32-bit control variable, which tracks the execution state,\nidentifying the code block to be executed. This control variable is initialized at the start of\neach function to refer to the starting code block (which is frequently a `nop block). The`\ncontrol variable is then modified at the end of each code block to identify the next code\nblock that should be executed. The modification is performed using some arithmetic\ninstructions, such as `add,` `sub, or` `xor .`\n\nThere is a dispatcher using the control variable to route execution into the correct code\nblock. This dispatcher is made up of if/else blocks that are circularly linked into a loop. Each\ndispatcher block takes the control variable and masks it using arithmetic instructions to\ncheck if it should route execution into the code block that it is guarding. What’s interesting\nhere is there are multiple points of entry from the code blocks into the dispatcher loop,\ngiving the control flow graphs the jagged “sawblade” look in IDA.\n\n\n-----\n\nBranching is performed using a special code block containing an `imul instruction. It relies`\non the previous block to compute a branch flag. This branch flag is multiplied using the\n```\nimul instruction with a random constant, and the result is added, subbed, or xored to the\n\n```\nnew control variable. This means that after the branch block, the control variable will identify\none of the two possible succeeding code blocks, depending on the value that was\ncomputed for the branch flag.\n\nControl flow graph of a function obfuscated using control flow flattening\n\n**Function activation keys**\n\n\n-----\n\nRoshtyak s obfuscated functions expect an extra argument, which we call an activation key.\nThis activation key is used to decrypt all local constants, strings, variables, etc. If a function\nis called with a wrong activation key, the decryption results in garbage plaintext, which will\nmost likely cause Roshtyak to get stuck in an infinite loop inside the control flow dispatcher.\nThis is because all constants used by the dispatcher (the initial value of the control variable,\nthe masks used by the dispatcher guards, and the constants used to jump to the next code\nblock) are encrypted with the activation key. Without the correct activation key, the\ndispatcher simply does not know how to dispatch.\n\nReverse engineering a function is practically impossible without knowing the correct\nactivation key. All strings, buffers, and local variables/constants remain encrypted, all crossreferences are lost, and worse, there is no control flow information. Only individual code\nblocks remain, with no way to know how they relate to each other.\n\nEach obfuscated function has to be called from somewhere, which means the code calling\nthe function has to supply the correct activation key. However, obtaining the activation key\nis not that easy. First, call targets are also encrypted with activation keys, so it’s impossible\nto find where a function is called from without knowing the right activation keys. Second,\neven the supplied activation key is encrypted with the activation key of the calling function.\nAnd that activation key got encrypted with the activation key of the next calling function. And\nso on, recursively, all the way until the entry point function.\n\nThis brings us to how to deobfuscate the mess. The activation key of the entry point\nfunction must be there in plaintext. Using this activation key, it is possible to decrypt the call\ntargets and activation keys of functions that are called directly from this entry point function.\nApplying this method recursively allows us to reconstruct the full call graph along with the\nactivation keys of all the functions. The only exceptions would be functions that were never\ncalled and were left in by the compiler. These functions will probably remain a mystery, but\nsince the sample does not use them, they are not that important from a malware analyst’s\npoint of view.\n\n**Variable masking**\n\nSome variables are not stored in plaintext form but are masked using one or more\narithmetic instructions. This means that if Roshtyak is not actively using a variable, it keeps\nthe variable’s value in an obfuscated form. Whenever Roshtyak needs to use the variable, it\nhas to first unmask it before it can use it. Conversely, after Roshtyak uses the variable, it\nconverts it back into the masked form. This masking-based obfuscation method slightly\ncomplicates tracking variables during debugging and makes it harder to search memory for\na known variable value.\n\n**Loop transformations**\n\n\n-----\n\nRoshtyak is creative with some loop conditions. Instead of writing a loop like `for (int i`\n```\n= 0; i < 1690; i++), it transforms the loop into e.g. for (int32_t i = 0x06AB91EE;\ni != 0x70826068; i = i * -0x509FFFF + 0xEC891BB1) . While both loops will execute\n\n```\nexactly 1690 times, the second one is much harder to read. At first glance, it is not clear\nhow many iterations the second loop executes (and if it even terminates). Tracking the\nnumber of loop iterations during debugging is also much harder in the second case.\n\n**Packing**\n\nAs mentioned, Roshtyak’s core is hidden behind multiple layers of packing. While all the\nlayers look like they were originally compiled into PE files, all but the strictly necessary data\n(entry point, sections, imports, and relocations) were stripped away. Furthermore, Roshtyak\nsupports two custom formats for storing the stripped PE file information, and the layers take\nturns on what format they use. Additionally, parts of the custom formats are encrypted,\nsometimes using keys generated based on the results of various anti-analysis checks.\n\nThis makes it difficult to unpack Roshtyak’s layers statically into a standalone PE file. First,\none would have to reverse engineer the custom formats and figure out how to decrypt the\nencrypted parts. Then, one would have to reconstruct the PE header, the sections, the\nsection headers, and the import table (the relocation table doesn’t need to be reconstructed\nsince relocations can just be turned off). While this is all perfectly doable (and can be\n[simplified using libraries like LIEF), it might take a significant amount of time. Adding to this](https://lief-project.github.io/)\nthat the layers are sometimes interdependent, it might be easier to just analyze Roshtyak\ndynamically in memory.\n\n_A section header in one of the custom PE-like file formats:_ `raw_size corresponds to`\n```\nSizeOfRawData, raw_size + virtual_padding_size is effectively VirtualSize .\n\n```\n_There is no_ `VirtualAddress or` `PointerToRawData equivalent because the sections`\n_are loaded sequentially._\n\n**Other obfuscation techniques**\n\nIn addition to the above-described techniques, Roshtyak also uses other obfuscation\ntechniques, including:\n\n\n-----\n\nJunk instruction insertion\nImport hashing\nFrequent memory wiping\nMixed boolean-arithmetic obfuscation\nRedundant threading\nHeavy polymorphism\n\n## Core Functionality\n\nNow that we’ve described how Roshtyak protects itself, it might be interesting to also go\nover what it actually does. Roshtyak’s DLL is relatively large, over a megabyte, but its\nfunctionality is surprisingly simple once you eliminate all the obfuscation. Its main purpose\nis to download further payloads to execute. In addition, it does the usual evil malware stuff,\nnamely establishing persistence, escalating privileges, lateral movement, and exfiltrating\ninformation about the victim.\n\n**Persistence**\n\nRoshtyak first generates a random file name in `%SystemRoot%\\Temp and moves its DLL`\nimage there. The generated file name consists of two to eight random lowercase characters\nconcatenated with a random extension chosen from a hardcoded list. The PRNG used to\ngenerate this file name is seeded with the volume serial number of `C:\\ . The sample we`\nanalyzed hardcoded seven extensions ( .log, `.tmp,` `.loc,` `.dmp,` `.out,` `.ttf, and`\n```\n.etl ). We observed other extensions being used in other samples, suggesting this list is\n\n```\nsomewhat dynamic. With a small probability, Roshtyak will also use a randomly generated\nextension. Once fully constructed, the full path to the Roshtyak DLL might look like e.g.\n```\nC:\\Windows\\Temp\\wcdp.etl .\n\n```\nAfter the DLL image is moved to the new filesystem path, Roshtyak stomps its `Modified`\ntimestamp to the current system time. It then proceeds to set up a `RunOnce(Ex) registry`\nkey to actually establish persistence. The registry entry is created using the previously\ndescribed indirect registry write technique. The command inserted into the key might look\nas follows:\n```\nRUNDLL32.EXE SHELL32.DLL,ShellExec_RunDLL REGSVR32.EXE -U /s\n\"C:\\Windows\\Temp\\wcdp.etl.\"\n\n```\nThere are a couple of things to note here. First, `regsvr32 doesn’t care about the`\nextensions of the DLLs it loads, allowing Roshtyak to hide under an innocent-looking\nextension such as `.log . Second, the` `/s parameter puts` `regsvr32 into silent mode.`\nWithout it, `regsvr32 would complain that it did not find an export named`\n```\nDllUnregisterServer . Finally, notice the trailing period character at the end of the path.\n\n```\n[This period is removed during path normalization, so it practically has no effect on the](https://docs.microsoft.com/en-us/archive/blogs/jeremykuhne/path-normalization#trimming-characters)\ncommand. We are not exactly sure what the author’s original intention behind including this\n\n\n-----\n\nperiod character is. It looks like it could have been designed to trick some anti-malware\nsoftware into not being able to connect the persistence entry with the payload on the\nfilesystem.\n\nBy default, Roshtyak uses the\n```\nHKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce key for persistence.\n\n```\nHowever, under some circumstances (such as when it detects that Kaspersky is running by\nchecking for a process named `avp.exe ) the key`\n```\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx will be used instead.\n\n```\nThe `RunOnceEx key is capable of loading a DLL, so when using this key, Roshtyak`\nspecifies `shell32.dll directly, omitting the use` `rundll32 .`\n\nA `RunOnceEx persistence entry established by Roshtyak`\n\n**Privilege escalation**\n\nRoshtyak uses both UAC bypasses and regular EoP exploits in an attempt to elevate its\nprivileges. Unlike many other pieces of malware, which just blindly execute whatever UAC\nbypasses/exploits the authors could find, Roshtyak makes efforts to figure out if the\nprivilege escalation method is even likely to be successful. This was probably implemented\nto lower the chances of detection due to the unnecessary usage of incompatible\nbypasses/exploits. For UAC bypasses, this involves checking the\n```\nConsentPromptBehaviorAdmin and ConsentPromptBehaviorUser registry keys. For\n\n```\nEoP exploits, this is about checking the Windows build number and patch level.\n\nBesides checking the `ConsentPromptBehavior(Admin|User) keys, Roshtyak performs`\nother sanity checks to ensure that it should proceed with the UAC bypass. Namely, it\nchecks for admin privileges using `CheckTokenMembership with the SID` `S-1-5-32-544`\n( DOMAIN_ALIAS_RID_ADMINS ). It also inspects the value of the `DbgElevationEnabled`\nflag in `KUSER_SHARED_DATA.SharedDataFlags . This is an undocumented flag that is set if`\nUAC is enabled. Finally, there are AV checks for BitDefender (detected by the module\n```\natcuf32.dll ), Kaspersky (process avp.exe ), and our own Avast/AVG (module\naswhook.dll ). If one of these AVs is detected, Roshtyak avoids selected UAC bypass\n\n```\ntechniques, presumably the ones that might result in detection.\n\nAs for the actual UAC bypasses, there are two main methods implemented. The first is an\n[implementation of the aptly named ucmDccwCOM method from](https://github.com/hfiref0x/UACME/blob/c998cb1f1bafd36f566f17208b915dc48dda5edf/Source/Akagi/methods/hybrids.c#L877) [UACMe. Interestingly when](https://github.com/hfiref0x/UACME)\nthis method is executed, Roshtyak temporarily masquerades its process as\n\n\n-----\n\n`explorer.exe by overwriting` `FullDllName and` `BaseDllName in the` [_LDR_MODULE](http://undocumented.ntinternals.net/index.html?page=UserMode%2FStructures%2FLDR_MODULE.html)\nstructure corresponding to the main executable module. The payload launched by this\nmethod is a randomly named LNK file, dropped into `%TEMP% using the IShellLink COM`\ninterface. This LNK file is designed to relaunch the Roshtyak DLL, through LOLBins such as\n```\nadvpack or register-cimprovider .\n\n```\nThe second method is more of a UAC bypass framework than a specific bypass method,\nbecause multiple UAC bypass methods follow the same simple pattern: first registering\nsome specific shell open command and then executing an autoelevating Windows binary\n(which internally triggers the shell open command). For instance, a UAC bypass might be\naccomplished by writing a payload command to `HKCU\\Software\\Classes\\ms-`\n```\nsettings\\shell\\open\\command and then executing fodhelper.exe from\n%windir%\\system32 . Basically, the same bypass can be achieved by substituting the pair\nms-settings / fodhelper.exe with other pairs, such as mscfile / eventvwr.exe .\n\n```\nRoshtyak uses the following six pairs to bypass UAC:\n\n**Class** **Executable**\n```\n mscfile eventvwr.exe\n mscfile compmgmtlauncher.exe\n ms-settings fodhelper.exe\n ms-settings computerdefaults.exe\n Folder sdclt.exe\n Launcher.SystemSettings slui.exe\n\n```\n[Let’s now look at the kernel exploits (CVE-2020-1054 and](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2020-1054) [CVE-2021-1732) Roshtyak uses](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-1732)\nto escalate privileges. As is often the case in Roshtyak, these exploits are stored encrypted\nand are only decrypted on demand. Interestingly, once decrypted, the exploits turn out to be\nregular PE files with completely valid headers (unlike the other layers in Roshtyak, which\nare either in shellcode form or stored in a custom stripped PE format). Moreover, the\nexploits lack the obfuscation given to the rest of Roshtyak, so their code is immediately\ndecompilable, and only some basic string encryption is used. We don’t know why the\nattackers left these exploits so exposed, but it might be due to the difference in bitness.\nWhile Roshtyak itself is x86 code (most of the time running under WoW64), the exploits are\nx64 (which makes sense considering they exploit vulnerabilities in 64-bit code). It could be\nthat the obfuscation tools used by Roshtyak’s authors were designed to work on x86 and\nare not portable to x64.\n\n\n-----\n\n_Snippet from Roshtyak’s exploit for CVE-2020-1054, scanning through_ `IsMenu to find the`\n_offset to_ _[HMValidateHandle.](https://github.com/sam-b/windows_kernel_address_leaks/blob/master/HMValidateHandle/HMValidateHandle/HMValidateHandle.cpp)_\nTo execute the exploits, Roshtyak spawns (the AMD64 version of) `winver.exe and gets`\n[the exploit code to run there using the KernelCallbackTable injection method. Roshtyak’s](https://modexp.wordpress.com/2019/05/25/windows-injection-finspy/)\n[implementation of this injection method essentially matches a public PoC, with the biggest](https://github.com/odzhan/injection/blob/master/kct/kct.c)\ndifference being the usage of slightly different API functions due to the need for crosssubsystem injection (e.g. `NtWow64QueryInformationProcess64 instead of`\n```\nNtQueryInformationProcess or NtWow64ReadVirtualMemory64 instead of\nReadProcessMemory ). The code injected into winver.exe is not the exploit PE itself but\n\n```\nrather a slightly obfuscated shellcode, designed to load the exploit PE into memory.\n\nThe kernel exploits target certain unpatched versions of Windows. Specifically, CVE-20201054 is only used on Windows 7 systems where the revision number is not higher than\n```\n24552 . On the other hand, the exploit for CVE-2021-1732 runs on Windows 10, with the\n\n```\ntargeted build number range being from `16353 to` `19042 . Before exploiting CVE-2021-`\n1732, Roshtyak also scans through installed update packages to see if a patch for the\nvulnerability is installed. It does this by enumerating the registry keys under\n\n```\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Component Based\n\n```\n```\nServicing\\Packages and checking if the package for KB4601319 (or higher) is present.\n\n```\n**Lateral movement**\n\n[When it comes to lateral movement, Roshtyak simply uses the tried and tested PsExec tool.](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec)\nBefore executing PsExec, Roshtyak ensures it makes sense to run it by checking for a SID\n[matching the “well-known”](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-well_known_sid_type) `WinAccountDomainAdminsSid group. If domain admin rights`\nare not detected, Roshtyak skips its lateral movement phase entirely.\n\nRoshtyak attempts to get around detection by setting Defender exclusions, as PsExec is\noften flagged as a hacktool (for good reasons). It sets a path exclusion for `%TEMP% (where`\nit will drop PsExec and other files used for lateral movement). Later, it sets up a process\nexclusion for the exact path from which PsExec will be executed.\n\n\n-----\n\nWhile we would expect PsExec to be bundled inside Roshtyak, it turns out Roshtyak\ndownloads it on demand from\n```\nhttps://download.sysinternals[.]com/files/PSTools.zip . The downloaded zip\n\n```\narchive is dropped into `%TEMP% under a random name with the` `.zip extension. PsExec`\nis then unzipped from this archive using the Windows Shell COM interface\n( IShellDispatch ) into a randomly named `.exe file in` `%TEMP% .`\n\nThe payload to be executed by PsExec is a self-extracting package created by a tool called\n[IExpress. This is an archaic installer that’s part of Windows, which is probably why it’s used,](https://en.wikipedia.org/wiki/IExpress)\nsince Roshtyak can rely on it already being on the victim machine. The installer generation\n[is configured by a text file using the Self Extraction Directive (SED) syntax.](https://www.mdgx.com/INF_web/cdfinfo.htm)\n\n_Roshtyak’s IExpress configuration template_\n\nRoshtyak uses a SED configuration template with three placeholders ( %1, `%2, and` `%3 )`\nthat it substitutes with real values at runtime. As seen above, the configuration template\nwas written in mixed-case, which is frequently used in Raspberry Robin in general. Once\nthe SED configuration is prepared, it is written into a randomly named `.txt file in`\n```\n%TEMP% . Then, iexpress is invoked to generate the payload using a command such as\nC:\\Windows\\iexpress.exe /n /q <path_to_sed_config> . The generated payload is\n\n```\ndumped into a randomly named `.exe file in` `%TEMP%, as configured by the` `TargetName`\ndirective (placeholder `%1 ).`\n\nOnce the payload is generated, Roshtyak proceeds to actually run PsExec. There are two\nways Roshtyak can execute PsExec. The first one uses the command `<path_to_psexec>`\n```\n\\\\* -accepteula -c -d -s <path_to_payload> . Here, the \\\\* wildcard instructs\n\n```\nPsExec to run the payload on all computers in the current domain. Alternatively, Roshtyak\nmight run the command `<path_to_psexec> @<path_to_target_file> -accepteula -c`\n```\n-d -s <path_to_payload> . Here, the target_file is a text file containing a specific list\n\n```\nof computers to run the payload on. Roshtyak builds this list by enumerating Active\nDirectory objects using API functions exported from `activeds.dll .`\n\n\n-----\n\n**Profiling the victim**\n\nUSB worms tend to have a life of their own. Since their worming behavior is usually\ncompletely automated, the threat actor who initially deployed the worm doesn’t necessarily\nhave full control over where it spreads. This is why it’s important for threat actors to have\nthe worm beacon back to their C&C servers. With a beaconing mechanism in place, the\nthreat actor can be informed about all the machines under their control and can use this\nknowledge to manage the worm as a whole.\n\nThe outgoing beaconing messages typically contain some information about the infected\nmachine. This helps financially-motivated cybercriminals decide on how to best monetize\nthe infection. Roshtyak is no exception to this, and it collects a lot of information about each\ninfected victim. Roshtyak concatenates all the collected information into a large string, using\nsemicolons as delimiters. This large string is then exfiltrated to one of Roshtyak’s C&C\nservers. The exfiltrated pieces of information are listed below, in order of concatenation.\n\nExternal IP address (obtained during a Tor connectivity check)\nA string hardcoded into Roshtyak’s code, e.g. `AFF123 (we can’t be sure what’s the`\nmeaning behind this, but it looks like an affiliate ID)\nA 16-bit hash of the DLL’s PE header (with some fields zeroed out) xored with the\nlower 16 bits of its `TimeDateStamp . The` `TimeDateStamp appears to be specially`\ncrafted so that the xor results in a known value. This could function as a tamper check\nor a watermark.\nCreation timestamp of the `System Volume Information folder on the system drive`\nThe volume serial number of the system drive\nProcessor count ( GetActiveProcessorCount )\nIsWow64Process ( _PROCESS_EXTENDED_BASIC_INFORMATION.Flags & 2 )\nWindows version ( KUSER_SHARED_DATA.Nt(Major|Minor)Version )\nWindows product type ( KUSER_SHARED_DATA.NtProductType )\nWindows build number ( PEB.OSBuildNumber )\nLocal administrative privileges\n( ZwQueryInformationToken(TokenGroups) / CheckTokenMembership, check for\n```\n   DOMAIN_ALIAS_RID_ADMINS )\n\n```\nDomain administrative privileges (check for\n```\n   WinAccountDomainAdminsSid / WinAccountDomainUsersSid )\n\n```\nSystem time ( KUSER_SHARED_DATA.SystemTime )\nTime zone ( KUSER_SHARED_DATA.TimeZoneBias )\nSystem locale ( NtQueryDefaultLocale(0) )\nUser locale ( NtQueryDefaultLocale(1) )\nEnvironment variables ( username, `computername,` `userdomain,`\n```\n   userdnsdomain, and logonserver )\n\n```\nJava version ( GetFileVersionInfo(\"javaw.exe\") -> `VerQueryValue )`\nProcessor information ( cpuid to obtain the `Processor Brand String )`\n\n\n-----\n\nPath to the image of the main executable module\n( NtQueryVirtualMemory(MemorySectionName) )\nProduct ID and serial number of the main physical drive\n( DeviceIoControl(IOCTL_STORAGE_QUERY_PROPERTY, StorageDeviceProperty) )\nMAC address of the default gateway ( GetBestRoute -> `GetIpNetTable )`\nMAC addresses of all network adapters ( GetAdaptersInfo )\nInstalled antivirus software ( root\\securitycenter2 -> `SELECT * FROM`\n```\n   AntiVirusProduct )\n\n```\nDisplay device information ( DeviceId, `DeviceString,` `dmPelsWidth,`\n```\n   dmPelsHeight, dmDisplayFrequency ) ( EnumDisplayDevices ->\n   EnumDisplaySettings )\n\n```\nActive processes ( NtQuerySystemInformation(SystemProcessInformation) )\nScreenshot encoded in base64 ( gdi32 method)\n\n**Beaconing**\n\nOnce collected, Roshtyak sends the victim profile to one of its C&C servers. The profile is\nsent over the [Tor network, using a custom comms module Roshtyak injects into a newly](https://www.torproject.org/)\nspawned process. The C&C server processes the exfiltrated profile and might respond with\na shellcode payload for the core module to execute.\n\nLet’s now take a closer look at this whole process. It’s worth mentioning that before\ngenerating any malicious traffic, Roshtyak first performs a Tor connectivity check. This is\ndone by contacting 28 legitimate and well-known `.onion addresses in random order and`\nchecking if at least one of them responds. If none of them respond, Roshtyak doesn’t even\nattempt to contact its C&C, as it would most likely not get through to it anyway.\n\nAs for the actual C&C communication, Roshtyak contains 35 hardcoded V2 onion\naddresses (e.g. `ip2djbz3xidmkmkw:53148, see our` [IoC repository for the full list). Like](https://github.com/avast/ioc/tree/master/RaspberryRobin)\nduring the connectivity check, Roshtyak iterates through them in random order and\nattempts to contact each of them until one responds. Note that while V2 onion addresses\nare [officially deprecated in favor of V3 addresses (and the Tor Browser no longer supports](https://support.torproject.org/onionservices/v2-deprecation/)\nthem in its latest version) they still appear to be functional enough for Roshtyak’s nefarious\npurposes.\n\n\n-----\n\nRoshtyak’s hardcoded C&C addresses\nThe victim profile is sent in the URL path, appended to the V2 onion address, along with the\n```\n/ character. As the raw profile might contain characters forbidden for use in URLs, the\n\n```\nprofile is wrapped in a custom structure and encoded using Base64. The very first 0x10\nbytes of the custom structure serve as an encryption key, with the rest of the structure being\nencrypted. The custom structure also contains a 64-bit hash of the victim profile, which\npresumably serves as an integrity check. Interestingly, the custom structure might get its\nend padded with random bytes. Note that the full path could be pretty large, as it contains a\ndoubly Base64-encoded screenshot. The authors of Roshtyak were probably aware that the\nURL path is not suitable for sending large amounts of data and decided to cap the length of\nthe victim profile at 0x20000 bytes. If the screenshot makes the exfiltrated profile larger than\nthis limit, it isn’t included.\n\nWhen the full onion URL is constructed, Roshtyak goes ahead to launch its Tor comms\nmodule. It first spawns a dummy process to host the comms module. This dummy process\nis randomly chosen and can be one of `dllhost.exe,` `regsvr32.exe, or`\n```\nrundll32.exe . The comms module is injected into the newly spawned process using a\n\n```\nshared section, obfuscated through the previously described shellcode hiding technique.\nThe comms module is then executed via `NtQueueApcThreadEx, using the already`\ndiscussed ntdll gadget trick. The injected comms module is a custom build of an opensource Tor library packed in three additional protective shellcode layers.\n\nThe core module communicates with the comms module using shared sections as an IPC\nmechanism. Both modules synchronously use the same PRNG with the same seed\n( KUSER_SHARED_DATA.Cookie ) to generate the same section name. Both then map this\nnamed section into their respective address spaces and communicate with each other by\nreading/writing to it. The data read/written into the section is encrypted with RC4 (the key\nalso generated using the synchronized PRNGs).\n\n\n-----\n\nThe communication between the core module and the comms module follows a simple\nrequest/response pattern. The core module writes an encrypted onion URL (including the\nURL path to exfiltrate) into the shared section. The comms module then decrypts the URL\nand makes an HTTP request over Tor to it. The core module waits for the comms module to\nwrite the encrypted HTTP response back to the shared section. Once it’s there, the core\nmodule decrypts it and unwraps it from a custom format (which includes decrypting it yet\nagain and computing a hash to check the payload’s integrity). The decrypted payload might\ninclude a shellcode for the core module to execute. If the shellcode is present, the core\nmodule allocates a huge chunk of memory, hides the shellcode there using the shellcode\nhiding technique, and executes it in a new thread. This new thread is hidden using the\n```\nNtSetInformationThread -> ThreadHideFromDebugger technique (including a follow\n```\nup anti-hooking check using `NtGetInformationThread to confirm that the`\n```\nNtSetInformationThread call did indeed succeed).\n\n## Conclusion\n\n```\nIn this blog post, we took a technical deep dive into Roshtyak, the backdoor payload\nassociated with Raspberry Robin. The main focus was to describe how to deal with\nRoshtyak’s protection mechanisms. We showed some never-before-seen antidebugger/anti-sandbox/anti-VM tricks and discussed Roshtyak’s heavy obfuscation. We\nalso described Roshtyak’s core functionality. Specifically, we detailed how it establishes\npersistence, escalates privileges, moves laterally, and uses Tor to download further\npayloads.\n\nWe have to admit that reverse engineering Roshtyak was certainly no easy task. The\ncombination of heavy obfuscation and numerous advanced anti-analysis tricks made it a\nconsiderable challenge. Nick Harbour, if you’re looking for something to repurpose for next\nyear’s final Flare-On challenge, this might be it.\n\n### Indicators of Compromise (IoCs)\n\n[IoCs are available at https://github.com/avast/ioc/tree/master/RaspberryRobin.](https://github.com/avast/ioc/tree/master/RaspberryRobin)\n\n[Tagged asCVE-2020-1054,](https://decoded.avast.io/tag/cve-2020-1054/) [CVE-2021-1732,](https://decoded.avast.io/tag/cve-2021-1732/) [Rapsberry Robin,](https://decoded.avast.io/tag/rapsberry-robin/) [Roshtyak](https://decoded.avast.io/tag/roshtyak/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-22 - Raspberry Robin’s Roshtyak- A Little Lesson in Trickery.pdf"
    ],
    "report_names": [
        "2022-09-22 - Raspberry Robin’s Roshtyak- A Little Lesson in Trickery.pdf"
    ],
    "threat_actors": [
        {
            "id": "6c4f98b3-fe14-42d6-beaa-866395455e52",
            "created_at": "2023-01-06T13:46:39.169554Z",
            "updated_at": "2025-03-27T02:00:03.011739Z",
            "deleted_at": null,
            "main_name": "Evil Corp",
            "aliases": [
                "GOLD DRAKE"
            ],
            "source_name": "MISPGALAXY:Evil Corp",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "2864e40a-f233-4618-ac61-b03760a41cbb",
            "created_at": "2023-12-01T02:02:34.272108Z",
            "updated_at": "2025-03-27T02:02:10.209072Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "ETDA:WildCard",
            "tools": [
                "RustDown",
                "SysJoker"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "50068c14-343c-4491-b568-df41dd59551c",
            "created_at": "2022-10-25T15:50:23.253218Z",
            "updated_at": "2025-03-27T02:00:55.408128Z",
            "deleted_at": null,
            "main_name": "Indrik Spider",
            "aliases": [
                "Indrik Spider",
                "Evil Corp",
                "Manatee Tempest",
                "DEV-0243",
                "UNC2165"
            ],
            "source_name": "MITRE:Indrik Spider",
            "tools": [
                "Mimikatz",
                "PsExec",
                "Dridex",
                "WastedLocker",
                "BitPaymer",
                "Cobalt Strike"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "2eb5ae35-e3ae-4b76-a945-5e6c2cfc1942",
            "created_at": "2024-02-02T02:00:04.028297Z",
            "updated_at": "2025-03-27T02:00:03.292702Z",
            "deleted_at": null,
            "main_name": "Mustard Tempest",
            "aliases": [
                "DEV-0206",
                "Purple Vallhund"
            ],
            "source_name": "MISPGALAXY:Mustard Tempest",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "9806f226-935f-48eb-b138-6616c9bb9d69",
            "created_at": "2022-10-25T16:07:23.73153Z",
            "updated_at": "2025-03-27T02:02:09.950784Z",
            "deleted_at": null,
            "main_name": "Indrik Spider",
            "aliases": [
                "Blue Lelantos",
                "DEV-0243",
                "Evil Corp",
                "Gold Drake",
                "Gold Winter",
                "Manatee Tempest",
                "UNC2165"
            ],
            "source_name": "ETDA:Indrik Spider",
            "tools": [
                "Advanced Port Scanner",
                "Agentemis",
                "Babuk",
                "Babuk Locker",
                "Babyk",
                "BitPaymer",
                "Bugat",
                "Bugat v5",
                "Cobalt Strike",
                "CobaltStrike",
                "Cridex",
                "Dridex",
                "EmPyre",
                "EmpireProject",
                "FAKEUPDATES",
                "FakeUpdate",
                "Feodo",
                "FriedEx",
                "Hades",
                "IEncrypt",
                "LINK_MSIEXEC",
                "MEGAsync",
                "Macaw Locker",
                "Metasploit",
                "Mimikatz",
                "PayloadBIN",
                "Phoenix Locker",
                "PowerShell Empire",
                "PowerSploit",
                "PsExec",
                "QNAP-Worm",
                "Raspberry Robin",
                "RaspberryRobin",
                "SocGholish",
                "Vasa Locker",
                "WastedLoader",
                "WastedLocker",
                "cobeacon",
                "wp_encrypt"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "ebc139d2-7450-46f5-a9e4-e7d561133fa5",
            "created_at": "2024-04-24T02:00:49.453475Z",
            "updated_at": "2025-03-27T02:00:55.41974Z",
            "deleted_at": null,
            "main_name": "Mustard Tempest",
            "aliases": [
                "Mustard Tempest",
                "DEV-0206",
                "TA569",
                "GOLD PRELUDE",
                "UNC1543"
            ],
            "source_name": "MITRE:Mustard Tempest",
            "tools": [
                "SocGholish",
                "Cobalt Strike"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "b296f34c-c424-41da-98bf-90312a5df8ef",
            "created_at": "2024-06-19T02:03:08.027585Z",
            "updated_at": "2025-03-27T02:05:17.350153Z",
            "deleted_at": null,
            "main_name": "GOLD DRAKE",
            "aliases": [
                "Indrik Spider ",
                "Evil Corp"
            ],
            "source_name": "Secureworks:GOLD DRAKE",
            "tools": [
                " Cobalt Strike",
                " Covenant",
                " Donut",
                " Dridex",
                " Hades",
                " Koadic",
                " LockBit",
                " Macaw Locker",
                " Mimikatz",
                " Payload.Bin",
                " Phoenix CryptoLocker",
                " PowerSploit",
                " Powershell Empire",
                " SocGholish",
                " WastedLocker",
                "BitPaymer"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "256a6a2d-e8a2-4497-b399-628a7fad4b3e",
            "created_at": "2023-11-30T02:00:07.299845Z",
            "updated_at": "2025-03-27T02:00:03.257794Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "MISPGALAXY:WildCard",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535672,
    "ts_updated_at": 1743041799,
    "ts_creation_date": 1664713243,
    "ts_modification_date": 1664713243,
    "files": {
        "pdf": "https://archive.orkl.eu/3fe6b724cba9c888bdff8b2340519c31930720da.pdf",
        "text": "https://archive.orkl.eu/3fe6b724cba9c888bdff8b2340519c31930720da.txt",
        "img": "https://archive.orkl.eu/3fe6b724cba9c888bdff8b2340519c31930720da.jpg"
    }
}