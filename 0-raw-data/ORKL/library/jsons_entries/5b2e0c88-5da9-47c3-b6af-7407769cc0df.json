{
    "id": "5b2e0c88-5da9-47c3-b6af-7407769cc0df",
    "created_at": "2022-10-25T16:48:20.941351Z",
    "updated_at": "2025-03-27T02:06:03.508525Z",
    "deleted_at": null,
    "sha1_hash": "6c4fcf640dfbedbdddb724e69d0ed84319b0cf6e",
    "title": "Duqu 2.0: A Comparison To Duqu",
    "authors": "CrySyS Lab",
    "file_creation_date": "2015-06-10T15:36:43Z",
    "file_modification_date": "2015-06-10T15:36:43Z",
    "file_size": 1217942,
    "plain_text": "# Duqu 2.0:\n\n A comparison to Duqu\n\n##### v1.0 (10/Jun/2015)\n\n## Technical Report\n\n by\n\n#### CrySyS Lab\n\n http://www.crysys.hu/\n\n##### Budapest, 2015 Authors:\n\n Á\n\n\n-----\n\n## Findings in brief\n\nIn October 2011, we analyzed a new threat what we named Duqu, and we showed that it has\nclose relationships to the infamous Stuxnet attack.\n\nBy courtesy of Kaspersky Lab, in late May 2015 we received samples about a new threat, with\nthe hint that it might be related to the Duqu attacks; however, these new samples are from\n2014. We decided to carry out an individual research on the samples with the focus on the\nconnections between the original Duqu attack and the new threat, dubbed “Duqu 2.0”.\n\nAfter analyzing the samples received, we think, that the adversaries behind Duqu malware are\nback and active; while they modified their tools to be undetected by old methods, they also\nstrongly reused codes and ideas during their recent attacks. The numerous similarities that we\ndiscovered between Duqu and Duqu 2.0 include the following:\n\n  - Similar string decryption routines related to Anti-Virus product strings\n\n  - Similar methods, magic number, bug and file format related to files encrypted with\n\nAES by both threats\n\n  - Same non-standard CBC mode AES encryption used by both threats\n\n  - Extremely similar logging module with exactly the same magic numbers\n\n  - Similar C++-like coding and compiling style\n\nIn this report, we present supporting details and analysis for all the similarities listed above.\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 2\n\n\n-----\n\n## Table of contents\n\n1. Introduction ........................................................................................................................... 4\n\n1.1. Hashes of the analyzed samples .................................................................................... 6\n\n2. Similarities and differences ................................................................................................... 7\n\n2.1. General details ............................................................................................................... 7\n\n2.2. String decryption ............................................................................................................ 9\n\n2.3. AES encryption of the configuration file ...................................................................... 14\n\n2.4. Format of the (encrypted) configuration file ............................................................... 24\n\n2.5. Logging functions ......................................................................................................... 26\n\n2.6. Command & Control communication .......................................................................... 29\n\n2.7. DLL imports .................................................................................................................. 33\n\n3. Indicators of Compromise ................................................................................................... 34\n\n3.1. Detection based on communications .......................................................................... 34\n\n3.2. Yara rules to identify .................................................................................................... 36\n\n4. Conclusion ........................................................................................................................... 37\n\n5. References ........................................................................................................................... 37\n\n6. Contact Information ............................................................................................................ 39\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 3\n\n\n-----\n\n## 1.Introduction\n\nStuxnet is probably the most well-known malware of our times. Its fame stems from the facts\nthat it targeted a very specific industrial facility, namely a uranium enrichment plant in Iran, it\naimed at physical destruction of uranium centrifuges, and it apparently accomplished its\nmission successfully. In addition to all these characteristics, IT security experts also appreciate\nits technical sophistication and the zero-day exploits that it used. Stuxnet was also an alarm to\nthe developed world: it shed light on the capabilities of advanced attackers, and at the same\ntime, on the numerous weaknesses of our computing infrastructure. Putting these two\ntogether, people started to feel hopelessly vulnerable.\n\nYet, unfortunately, Stuxnet is not a unique example for a highly sophisticated targeted threat,\nbut there are numerous other pieces of malware of similar kind, including Duqu, Flame, Regin,\n_etc. Among those, Duqu is particularly interesting, not only because we discovered it back in_\n2011, but because our analysis pointed out that - while Duqu's objective is different - it has\nvery strong similarities to Stuxnet in terms of architecture, code, and methods to achieve\nstealthiness. Today, it is widely believed within the IT security community that Duqu was\ncreated by the same attackers who created Stuxnet.\n\nAnd now we have a new member of the same family! Last month, we received interesting\nsamples from Kaspersky Lab with a hint that they might be related to the Duqu samples of\n2011; however, these new samples are from 2014. Our common understanding was that it\nwould be interesting to figure out whether this new threat is indeed related to the old Duqu\nattack, and we in the CrySyS Lab should try to focus our analysis efforts on answering this\nquestion. It is important to emphasize that we did our analysis independently from Kaspersky\nLab: we did not read their preliminary report and they did not share any of their findings with\nus (apart from the samples that we received from them).\n\nThe analysis results performed by Kaspersky Lab can be read in the following report:\n```\n   https://securelist.com/blog/research/70504/the-mystery-of-duqu   2-0-a-sophisticated-cyberespionage-actor-returns/\n\n```\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 4\n\n\n-----\n\nIn this report, we present the results of our comparative analysis of the old version of Duqu\nand the new version, codenamed “Duqu 2.0”. We concentrate on the description of the\nrelevant similarities and differences we have found between the two malware samples.\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 5\n\n\n-----\n\n### 1.1. Hashes of the analyzed samples\n\nIn the table below, one can see the MD5 fingerprints of the two samples we have examined\nduring our initial analysis:\n\n**Sample hashes (MD5)** **Information**\n\n`c7c647a14cb1b8bc141b089775130834` main module\n\n`3f52ea949f2bd98f1e6ee4ea1320e80d` main module\n\n**Table 1 – Hashes (MD5) of the samples we have analyzed**\n\nThe first module will be referenced in this document with the name “c7c647”, and the second\nwith the name “3f52ea” according to the prefix of their MD5 hashes.\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 6\n\n|Sample hashes (MD5)|Information|\n|---|---|\n|c7c647a14cb1b8bc141b089775130834|main module|\n|3f52ea949f2bd98f1e6ee4ea1320e80d|main module|\n\n\n-----\n\n## 2. Similarities and differences\n\nIn the following chapter, we will discuss the most conspicuous similarities and differences we\nhave found between the main modules of Duqu and Duqu 2.0.\n\n### 2.1. General details\n\nBoth the two main modules of Duqu 2.0 we have analyzed (”c7c647” and ”3f52ea”) has 6\nexport functions which can be seen in the following figure:\n\n**Figure 1 – Structure of the first sample (“3f52ea”) – 6 export functions**\n\n**Figure 2 – Structure of the second sample (“c7c647”) – 6 export functions**\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 7\n\n\n-----\n\nThe new sample (both versions) is one big executable file that is linked by multiple modules.\nThe original Duqu had a main module that was divided into two sub-modules: an outside layer\nand an internal part. In one version, the internal part was stored in a specific compressed\nformat, while in another version, which we investigated at a Duqu victim, it was stored in\ncleartext in a resource data section of the main executable. The Duqu 2.0 version we\ninvestigated is different: everything is incorporated in the main executable, but there are still\nvisible marks showing that the malware is linked/compiled from multiple different parts,\nmodules.\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 8\n\n\n-----\n\n### 2.2. String decryption\n\nSome of the strings in Duqu 2.0 are obfuscated by XOR-based encryption. The actual routine\nused is printed below:\n```\n.text:10012F6D         test  ecx, ecx\n.text:10012F6F         jnz   short loc_10012F77\n.text:10012F71         xor   eax, eax\n.text:10012F73         mov   [edx], ax\n.text:10012F76         retn\n.text:10012F77 ; -------------------------------------------.text:10012F77\n.text:10012F77 loc_10012F77:     ;\n.text:10012F77         mov   eax, [ecx]\n.text:10012F79         push  esi\n.text:10012F7A         push  edi\n.text:10012F7B         mov   edi, 86F186F1h\n.text:10012F80         xor   esi, esi\n.text:10012F82         xor   eax, edi\n.text:10012F84         mov   [edx], eax\n.text:10012F86         cmp   ax, si\n.text:10012F89         jz   short loc_10012FA2\n.text:10012F8B         sub   ecx, edx\n.text:10012F8D\n.text:10012F8D loc_10012F8D:    ; \n.text:10012F8D         cmp   [edx+2], si\n.text:10012F91         jz   short loc_10012FA2\n.text:10012F93         add   edx, 4\n.text:10012F96         mov   eax, [ecx+edx]\n.text:10012F99         xor   eax, edi\n.text:10012F9B         mov   [edx], eax\n.text:10012F9D         cmp   ax, si\n.text:10012FA0         jnz   short loc_10012F8D\n\n```\n**Sample 1 – String decryption in Duqu 2.0 (assembly view)**\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 9\n\n\n-----\n\nThe decompiled version of the above assembly code can be seen in the following sample:\n```\nunsigned int __fastcall xor_sub_10012F6D(int encrstr, int a2)\n{\n unsigned int result; // eax@2\n int v3;       // ecx@4\n if ( encrstr )\n {\n  result = *(_DWORD *)encrstr ^ 0x86F186F1;\n  *(_DWORD *)a2 = result;\n  if ( (_WORD)result )\n  {\n   v3 = encrstr - a2;\n    do\n   {\n     if ( !*(_WORD *)(a2 + 2) )\n      break;\n    a2 += 4;\n    result = *(_DWORD *)(v3 + a2) ^ 0x86F186F1;\n    *(_DWORD *)a2 = result;\n   }\n    while ( (_WORD)result );\n  }\n }\n else\n {\n  result = 0;\n  *(_WORD *)a2 = 0;\n }\n return result;\n}\n\n```\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 10\n\n\n-----\n\n**Sample 2 – String decryptor from Duqu 2.0 (2014)**\n\nThe above string decryptor routine is a simple XOR decoder. It simply XORs consecutive 4-byte\nblocks of the encrypted string buffer, given by its pointer in the first parameter of the\nfunction, with a fixed 4-byte key (“0x86F186F1”). After the decryption of all consecutive 4byte blocks, the actual cleartext block is stored within the next 4 bytes of the output buffer,\npointed by parameter “a2”. The decrypted (cleartext) string is terminated with a “\\0”\ncharacter, and if the decryptor cycle reaches the end of the (cleartext) string, the cleartext\nstring will be pointed by the address stored in output argument “a2”.\n\nA closer look at the above C code reveals that the string decryptor routine actually has two\nparameters: “encrstr” and “a2”. First, the decryptor function checks if the input buffer (the\npointer of the encrypted string) points to a valid memory area (i.e., it does not contain NULL\nvalue). After that, the first 4 bytes of the encrypted string buffer is XORed with the key\n“0x86F186F1” and the result of the XOR operation is stored in variable “result”. The first\nDWORD (first 4 bytes) of the output buffer a2 is then populated by this resulting value\n(*(_DWORD *)a2 = result;). Therefore, the first 4 bytes of the output buffer will\ncontain the first 4 bytes of the cleartext string.\n\nIf the first two bytes (first WORD) of the current value stored in variable “result” contain ‘\\0’\ncharacters, the original cleartext string was an empty string and the resulting output buffer\nwill be populated by a zero value, stored on 2 bytes. If the first half of the actual decrypted\nblock (“result” variable) contains something else, the decryptor routine checks the second half\nof the block (“if ( !*(_WORD *)(a2 + 2) )”). If this WORD value is NULL, then\ndecryption will be ended and the output buffer will contain only one Unicode character with\ntwo closing ’\\0’ bytes.\n\nIf the first decrypted block doens’t contain zero character (generally this is the case), then the\ndecryption cycle continues with the next 4-byte encrypted block. The pointer of the output\nbuffer is incremeted by 4 bytes to be able to store the next cleartext block (”a2 += 4;”).\nAfter that, the following 4-byte block of the ”ciphertext” will be decrypted with the fixed\ndecryption key (“0x86F186F1”). The result is then stored within the next 4 bytes of the output\nbuffer. Now, the output buffer contains 2 blocks of the cleartext string.\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 11\n\n\n-----\n\nThe condition of the cycle checks if the decryption reached its end by checking the first half of\nthe current decrypted block. If it did not reached the end, then the cycle continues with the\ndecryption of the next input blocks, as described above. Before the decryption of each 4-byte\n”ciphertext” block, the routine also checks the second half of the previous cleartext block to\ndecide whether the decoded string is ended or not.\n\nThe original Duqu used a very similar string decryption routine, which we printed in the\nfollowing figure below. We can see that this routine is an exact copy of the previously\ndiscussed routine (variable ”a1” is analogous to ”encrstr” argument). The only difference\nbetween the Duqu 2.0 and Duqu string decryptor routines is that the XOR keys differ (in\nDuqu, the key is”0xB31FB31F”).\n\nWe can also see that the decompiled code of Duqu contains the decryptor routine in a more\ncompact manner (within a ”for” loop instead of a ”while”), but the two routines are\nessentially the same. For example, the two boundary checks in the Duqu 2.0 routine (”if (\n```\n!*(_WORD *)(a2 + 2) )” and ”while ( (_WORD)result );”) are analogous to\n\n```\nthe boundary check at the end of the ”for” loop in the Duqu routine (”if ( !(_WORD)v4\n```\n|| !*(_WORD *)(result + 2) )”). Similarly, the increment operation within the\n\n```\nhead of the for loop in the Duqu sample (”result += 4”) is analogous to the increment\noperation ”a2 += 4;” in the Duqu 2.0 sample.\n```\nint __cdecl b31f_decryptor_100020E7(int a1, int a2)\n{\n _DWORD *v2;   // edx@1\n int result;   // eax@2\n unsigned int v4; // edi@6\n v2 = (_DWORD *)a1;\n if ( a1 )\n {\n  for ( result = a2; ; result += 4 )\n  {\n   v4 = *v2 ^ 0xB31FB31F;\n   *(_DWORD *)result = v4;\n\n```\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 12\n\n\n-----\n\n|if ( !(_WORD)v4 || !*(_WORD *)(result + 2) ) break; ++v2; } } else { result = 0; *(_WORD *)a2 = 0; } return result; }|Col2|\n|---|---|\n\n\n**Sample 3 – String decryptor from original Duqu (from “cmi4432.pnf” file)**\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 13\n\n\n-----\n\n### 2.3. AES encryption of the configuration file\n\nThe analyzed main module of Duqu 2.0 and also the old Duqu sample reads configuration\ninformation from a special file. This configuration file is encrypted using the AES block cipher\nin CBC mode with a CTS-like (Ciphertext Stealing) encryption of the last two cleartext blocks.\nThe format of the configuration file will be discussed in details in the next chapter.\n\nBefore the encryption of the configuration file, an AES wrapper object is created. This C++\nobject represents the context (parameters) of the encryption. Therefore, it also stores the\ninitialization vector (IV) of the encryption, the key of the cipher and the data to be encrypted.\n\nThe structure of this object’s class can be seen in the upper part of the next screenshot:\n\n**Figure 3 – Attributes of the AES wrapper class and an AES object**\n\nAs we can see, the allocated memory area of an instance of the “aeswrapper” structure (class)\nstarts with a 16 bytes (128 bits) IV value (of course, the size of the IV equals the size of an AES\ninput block). It is followed by a 516-byte buffer (or other unused smaller attributes) which can\nstore the encryption key of the AES cipher. Size of this encryption key can be either 128, 192\nor 256 bits (16, 24 or 32 bytes). The last 4 bytes of the “aeswrapper” structure contains the\npointer to the data to be encrypted.\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 14\n\n\n-----\n\nIn addition to the attributes (IV, encryption key, pointer to a data buffer), the “aeswrapper”\nclass also contains methods. The most important methods are the “encrypt” and “initialize”\nfunctions. As the name shows, the initialize method initializes the context (parameters)\nof the encryption, therefore it sets the IV, key and data members of the “aeswrapper” object.\nThe IV is generated by “hand”, but the key is prepared from an initial key using the\n```\nprepare_key function. The encrypt method encrypts the data in the modified CBC-CTS\n```\nlike mode. The method uses an AES encryptor function. The nth_block method of the class\ngives back a pointer to the n-th block of the data to be encrypted. Finally, the “aeswrapper”\nclass uses the `last_block function to perform the CTS-like encryption mechanism at the`\nend. The function gives back a pointer not to the last partial (smaller than 16 bytes) input\nblock, but to the last 16 bytes of the input data buffer.\n\nThe implementation of AES prepare_key and encrypt methods are presumably copied\nfrom function libraries.\n\nThe figure above shows the structures (structures of class instances) which we identified and\nwhich are related to the encryption routine and the AES initialization, and the putative\nattributes of these structures (classes). Using these structures, the disassembled code can be\nmore readable.\n\nThere is another structure in addition to the “aeswrapper” class called “aes” on the\nscreenshot above. An instance of this class represents an AES encryptor object. It has probably\n3 attributes: key_schedule, precomputed and iteration_count.\n\nIn the following table, we can see the AES initialization routine (of the configuration file\nencryption) of the old Duqu (on the left) and the new Duqu 2.0 sample (on the right) at\nassembly code level. The decompiled code of the initialization function (for both malware\nsamples) can be seen in figure **Sample 6. The AES initialization function initializes the**\nmentioned “aeswrapper” object, it sets the data buffer, prepares the encryption key, and\nfinally, generates the IV based on the magic constant.\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 15\n\n\n-----\n\n|Duqu “netp” routine|Duqu 2.0 “c7c64” routine|\n|---|---|\n|seg000:0002EE95 sub_2EE95 proc near ; CODE XREF: sub_2D0A4+8Cp seg000:0002EE95 ; sub_2EE50+36p seg000:0002EE95 seg000:0002EE95 var_20 = byte ptr -20h seg000:0002EE95 seg000:0002EE95 push ebp seg000:0002EE96 mov ebp, esp seg000:0002EE98 sub esp, 20h seg000:0002EE9B push esi seg000:0002EE9C push edi seg000:0002EE9D mov [ebx+214h], eax seg000:0002EEA3 push 8 seg000:0002EEA5 pop ecx seg000:0002EEA6 lea eax, [ebp+var_20] seg000:0002EEA9 push eax seg000:0002EEAA lea eax, [ebx+10h] seg000:0002EEAD mov esi, 10034600h seg000:0002EEB2 lea edi, [ebp+var_20] seg000:0002EEB5 push eax seg000:0002EEB6 rep movsd seg000:0002EEB8 call AES1_sub_2F9B1 seg000:0002EEBD pop ecx seg000:0002EEBE pop ecx seg000:0002EEBF pop edi seg000:0002EEC0 xor eax, eax seg000:0002EEC2 pop esi seg000:0002EEC3 seg000:0002EEC3 loc_2EEC3: ; CODE XREF: sub_2EE95+3Dj seg000:0002EEC3 mov ecx, eax seg000:0002EEC5 xor ecx, 0DEADBABEh seg000:0002EECB mov [ebx+eax*4], ecx seg000:0002EECE inc eax seg000:0002EECF cmp eax, 4 seg000:0002EED2 jb short loc_2EEC3 seg000:0002EED4 mov eax, ebx seg000:0002EED6 leave seg000:0002EED7 retn seg000:0002EED7 sub_2EE95 endp|.text:1001551D sub_1001551D proc near ; CODE XREF: sub_10007A22+28p .text:1001551D ; sub_10007CB7+121p .text:1001551D .text:1001551D var_20 = byte ptr -20h .text:1001551D arg_0 = dword ptr 8 .text:1001551D arg_4 = dword ptr 0Ch .text:1001551D .text:1001551D push ebp .text:1001551E mov ebp, esp .text:10015520 mov eax, [ebp+arg_0] .text:10015523 lea edx, [ebp+var_20] .text:10015526 sub esp, 20h .text:10015529 push ebx .text:1001552A push esi .text:1001552B mov esi, [ebp+arg_4] .text:1001552E mov ebx, ecx .text:10015530 push edi .text:10015531 push 8 .text:10015533 pop ecx .text:10015534 mov [ebx+214h], eax .text:1001553A lea edi, [ebp+var_20] .text:1001553D rep movsd .text:1001553F push 100h .text:10015544 lea ecx, [ebx+10h] .text:10015547 call AES_1_sub_1001690A .text:1001554C pop ecx .text:1001554D xor ecx, ecx .text:1001554F .text:1001554F loc_1001554F: ; CODE XREF: sub_1001551D+40j .text:1001554F mov eax, ecx .text:10015551 xor eax, 248561EFh ; MAGIC! .text:10015556 mov [ebx+ecx*4], eax .text:10015559 inc ecx .text:1001555A cmp ecx, 4 .text:1001555D jb short loc_1001554F .text:1001555F pop edi .text:10015560 pop esi .text:10015561 mov eax, ebx .text:10015563 pop ebx .text:10015564 mov esp, ebp .text:10015566 pop ebp .text:10015567 retn 0Ch .text:10015567 sub_1001551D endp|\n\n\n**Sample 4 – IV generation routine comparison (assembly view) – magic constants**\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 16\n\n\n-----\n\nIn both cases, the highlighted part of the assembly code corresponds to the highlighted part\nof the initialization routines in the decompiled versions of the code, which can be seen in\nfigure Sample 6. The only difference between the highlighted parts is the values of the magic\nconstants (“0xDEADBABE” vs. “0x248561EF”) which are used for the generation of the 128-bit\ninitialization vectors. The mentioned AES initialization routines (and also the common\nencryption function) will be discussed later in this section in more details.\n\nWe also reverse engineered the encryption routine used by Duqu 2.0, which is illustrated in\nthe following block diagram:\n\n**Figure 4 – The applied config file encryption method used by the main module of Duqu 2.0 (and by the old**\n\n**Duqu sample)**\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 17\n\n\n-----\n\nWith the exception of the last two input blocks, consecutive blocks of the cleartext data are\nencrypted with the AES encryption algorithm in CBC mode. Accordingly, the first block of the\ninput data (”P[0]”) is XORed with a fixed initialization vector (named as ”Fixed IV” in the figure\nabove). This 128-bit initialization vector (IV) differs between the old Duqu and the new Duqu\n2.0 samples. The value of this IV is generated from a magic constant, as it can be seen in the\nhighlighted parts of the previous assembly code. As this magic constant is different in the old\nand new samples, the generated IV will also be different.\n\nThe result of the previously mentioned XOR operation gives the first input block of the AES\nencryption algorithm (“AES-256” is in use). The number 256 means that the AES algorithm has\n256-bit key size. The block size of the AES cipher is constant 128 bits (16 bytes). “E[0]” is the\nfirst output of the block cipher, so it will be the first encrypted block (“F[0]”).\n\nOutput of the block cipher (“E[0]”) is then XORed with the second input block (“P[1]”), and the\nresulting block will be encrypted with AES-256. This procedure continues until the encryption\nof the last but first block of the cleartext data.\n\nIf the size of the input data is an integer multiple of the block size of AES (i.e., 128 bits), then\nthe remaining last two blocks of the cleartext are encrypted in the same manner as the\nprevious input blocks. So, in this case, the whole encryption routine matches a simple CBC\nmode encryption.\n\nHowever, if the size of the input data is not an exact multiple of the AES block size, the last\npartial block of the input data needs padding to be completed to a full block. In case of Duqu\n2.0, the developers of the malware didn’t use padding in a traditional way. Instead, they use a\nCTS-like (Ciphertext Stealing) method. The essence of the method used by the encryption\nroutine is that a part of the last but first block of the input data is encrypted twice using AES.\n\nThe last but first block (”P[n-1]”) of the cleartext data is XORed with the previous ciphertext\nblock (”E[n-2]”) and encrypted with AES-256 as previously. The result of this operation is the\n”E[n-1]” output block. The ”E[n-1]” output block won’t be directly used as the (n-1)st\nciphertext block. Instead, the output ”E[n-1]” is splitted into two distinct parts: ”F[n-1]” and\nanother part which is then fed into the AES encryptor again.\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 18\n\n\n-----\n\nThe last cleartext partial block (”P[n]”) – which has size less than 16 bytes – is completed from\nits beginning to get a full AES input block. The data used for completing the last partial block is\ntaken from the end of the previous AES output block (”E[n-1]”). The resulting block will be fed\ninto the AES-256 cipher in the last step of the encryption process. The output of the last\ninvocation of the AES cipher will be the last ciphertext block (”F[n]”). The output of the last\nbut first invocation of the AES encryptor (”E[n-1]”) is split into two parts, and the first part of\nsize size_of_the_last_cleartext_block will be the (n-1)st ciphertext block (”F[n1]”).\n\nThe old Duqu samples used exactly the same encryption method. The decompiled code of the\nAES encryptor of Duqu can be seen in the following sample, and one can see that this code\nimplements the method we have just explained and illustrated in the block diagram of Figure\n8.\n```\nvoid aeswrapper::encrypt(aeswrapper *this)\n{\n unsigned __int8 *cursor, *first_block, *prev_encrypted_block, \n           *current_block, *last_block;\n int i, j, offset_to_iv, offset_to_previous_block;\n // First block\n cursor = aeswrapper::nth_block(this, 0);\n offset_to_iv = (char *)this - (char *)cursor;\n i = 16;\n do\n {\n   *cursor ^= cursor[offset_to_iv];  // Buffer overflow if data\n   ++cursor;              // is under 16 bytes\n   --i;\n }\n while ( i );\n first_block = aeswrapper::nth_block(this, 0);\n AES::encrypt(&this->aes, first_block, first_block);\n // Other full blocks\n j = 1;\n if ((this->data->vtable->length(this->data) & 0xFFFFFFF0) > 0x10)\n\n```\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 19\n\n\n-----\n\n|{ do { prev_encrypted_block = aeswrapper::nth_block(this, j - 1); cursor = aeswrapper::nth_block(this, j); offset_to_previous_block = prev_encrypted_block - cursor; i = 16; do { *cursor ^= cursor[offset_to_previous_block]; ++cursor; --i; } while ( i ); current_block = aeswrapper::nth_block(this, j); AES::encrypt(&this->aes, current_block, current_block); ++j; } while ( j < this->data->vtable->length(this->data) >> 4 ); } // Last block if ( this->data->vtable->length(this->data) & 0xF ) { last_block = aeswrapper::last_block(this); AES::encrypt(&this->aes, last_block, last_block); // Buffer underwrite // if data is under 16 // bytes } }|Col2|\n|---|---|\n\n\n**Sample 5 – Main file encryption routine (same in the new and old sample) with implementation bugs –**\n\n**highlighted (red comments)**\n\nThe next table compares the AES initialization routines of the old Duqu sample (upper part of\nthe table) and the main module of Duqu 2.0 (lower part of the table).\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 20\n\n\n-----\n\nFirst, the initialization routine copies the pointer of the input data buffer into the “data”\nmember of the “aeswrapper” object. The routine takes this pointer as its second parameter.\nThe first parameter is the pointer (reference) of the object instance, since in C++, the first\n(hidden) parameter of a (non-static) class method is always the pointer of the object, or in\nother words, the “this” pointer. In case of Duqu 2.0, the routine has a third parameter, the\npointer to the buffer containing the key.\n\nAfter that, the content of the “key” buffer (which is a global buffer in the first case) is copied\ninto the local “key_” buffer in both cases. Then the prepare_key method of the AES object\nprepares the final encryption key based on this key, and feeds it into the “aeswrapper” object.\nInvocation of the prepare_key method can also be seen in the assembly view (see Sample\n4.), the method is referred by the name `AES1_sub_2F9B1 in case of Duqu and`\n```\nAES_1_sub_1001690A in case of Duqu 2.0. In the Duqu 2.0 case, the function has one\n\n```\nmore parameter, as this can also be seen in the assembly view, and the length of the AES key\nis chosen as 256 bits.\n\nFinally, the remaining part of the code initializes the IV member of “aeswrapper” object. Every\nbyte of the IV is generated by XORing the index of the actual byte with a magic constant\n(“0xDEADBABE” and “0x248561EF”, respectively, in the two cases). Byte index starts from\nzero.\n```\naeswrapper *aeswrapper::initialize(aeswrapper *this, buffer *data)\n{\n unsigned int i;\n char key_[32];\n this->data = data;\n // Key is a constant global variable with fixed value\n qmemcpy(key_, key, sizeof(key_));\n // AES::prepare_key assumes that the key is always 256 bits\n AES::prepare_key(&this->aes, key_);\n i = 0;\n do\n {\n\n```\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 21\n\n\n-----\n\n|this->iv[i] = i ^ 0xDEADBABE; // Magic value ++i; } while ( i < 4 ); return this; }|Col2|\n|---|---|\n|aeswrapper *aeswrapper::initialize(aeswrapper *this, buffer *data, char *key ) { unsigned int i; char key_[32]; this->data = data; // Key is an argument qmemcpy(key_, key, sizeof(key_)); // AES::prepare_key takes a key_length argument, supports 128, 192, 256 AES::prepare_key(&this->aes, key_, 256); i = 0; do { this->iv[i] = i ^ 0x248561EF; // Magic value ++i; } while ( i < 4 ); return this; }||\n\n\n**Sample 6 – Old Duqu and new Duqu 2.0 encryption initialization routine with differences – highlighted (red**\n\n**comments)**\n\nAs we can see, there are only three small differences between the routines: the magic\nconstants used by the IV generation, the fact that in Duqu the key is a constant global variable\nwith fixed value while in Duqu 2.0 it is an argument of the initialization function, and finally,\nthe possible length of the key.\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 22\n\n\n-----\n\nIn case of Duqu, the prepare_key function assumes that the key is always 256 bits, while in\ncase of Duqu 2.0, the `prepare_key function takes the key length as an argument. Key`\nlength can be 128, 192 or 256 bits.\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 23\n\n\n-----\n\n### 2.4. Format of the (encrypted) configuration file\n\nUnder the encryption layer (which is identical in the new and old samples as described in the\nprevious section), the configuration file format of the new Duqu 2.0 samples is very similar to\nthe old Duqu config file format. For an overview, see Figure 5 below.\n\n**Figure 5 – File format found in Duqu (first diagram) and Duqu 2.0 (second diagram)**\n\n**(Rectangles always denote little endian 4 byte integers if not stated otherwise)**\n\nThe format is designed to hold _key-value pairs. The keys are always 4-byte long, and the_\nvalues can be of arbitrary size. We believe that the keys are timestamps and the values are\nconfiguration entries, although the file format could hold any other similarly structured\ninformation (e.g. configurations).\n\nThe old file format begins with 4 bytes whose value is undefined. In the serialization process,\nit is read from an uninitialized buffer, and it is ignored in the deserialization process. The new\nfile format does not have such a beginning byte sequence.\n\nThe main part of the file format is surrounded by 4 signature bytes at the beginning and at the\nend. The byte sequence in the old Duqu file format is 0x839172FF, and in the new Duqu 2.0\nversion, it is 0x7749CB4D.\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 24\n\n\n-----\n\nIn both cases, the next integer indicates the number of entries, followed by the entries\nthemselves.\n\nEach entry begins with a 4-byte key, and then the value. In the new format, the value always\nbegins with 13 bytes (that can be logically divided into four 4 byte integers and a 1 byte value:\n4+4+1+4+4), but in the old format, this is missing. Furthermore, the value contains a variable\nsize part in both formats. This is a length prefixed buffer that can hold arbitrary data.\n\nIn essence, the only difference between the Duqu and the Duqu 2.0 config file formats is the\npresence of the undefined 4 bytes at the beginning of the file in the old version, and the\npresence of the 13 additional value bytes in the new version.\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 25\n\n\n-----\n\n### 2.5. Logging functions\n\nWe’ve identified a characteristic logging function that is present in both Duqu and Duqu 2.0,\nand is used extensively in the networking (mainly HTTP handling) part of the code. The logging\nfunction itself is identical, and the data structure used for storing log entries is very similar.\n\nThe Duqu version of the data structure has embedded function pointers, while the Duqu 2.0\nversion uses a virtual function table like structure. The main difference from a C++ virtual\nfunction table is that the pointer to the table is the last field of the associated structure\ninstead of the first field (see Figure 6).\n\nIn general, change in the coding style can be seen all over the code. While Duqu uses object\noriented style that is similar, but not identical to what C++ compilers do, Duqu 2.0 moved\nmainly to “real” C++, but there are still deviations from the standard C++ style (like the\npreviously function table).\n\n**Figure 6 – Log entry structure and the associated virtual function table in Duqu and Duqu 2.0**\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 26\n\n\n-----\n\nBoth the Duqu and Duqu 2.0 avoids storing the messages logged through this function. In both\ncodebase, a “handle_log_entry” function is called after creating the log entry structure, but\nthis function throws the object away (frees the memory) and does not print or save it. The\nauthors probably used C/C++ macros to avoid detailed logging in release builds, but in this\ncase we still see the logging function invocation. In this case, the macro was probably placed\nin the function that should have printed the log message (handle_log_entry), and since this is\na virtual function, the compiler could not optimize out the function invocations directly.\n\nThe logging function is called equal times in the Duqu and the Duqu 2.0 samples, and the\ninvocation is always very similar (see Figure 7). The arguments are usually not strings\ndescribing the event directly, but 4 byte magic numbers. The logging function is invoked equal\ntimes, and the magic numbers are almost always identical in Duqu and Duqu 2.0.\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 27\n\n\n-----\n\n**Figure 7 – References to the logger function in Duqu and Duqu 2.0, and one of the invocations**\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 28\n\n\n-----\n\n### 2.6. Command & Control communication\n\nThe network communication methods used by Duqu 2.0 are described in the following list.\n\n**SocketServer1:**\n\nIn export function nr1, if in the config the \"startSockServer\" parameter is set,\nit will start a server accordingly\n\n**SocketServer2:**\n\nBinds between ports 17000 and 17100, can be configured to be client or server\n\n**GifServer:**\n\nWith Custom HTTP Server implementation, possibly based on SocketServer2\n\n**PipeComm:**\n\nPIPE or IPC communication, customizable network communication\n\n**HttpClient:**\n\nWinHTTP-based, simple client, uses \"COUNTRY=\" in cookie parameters,\n(standard HTTP client)\n\n**Table 2 – Network communication methods used by Duqu 2.0**\n\nDuqu has used a very unique user agent string when communicating over HTTP:\n```\n   Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.2.9)\n\n```\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 29\n\n\n-----\n\nIn contrast, Duqu 2.0 chooses user agent string randomly from a large set of often used values\nlisted in Sample 7.\n\nThe following list shows the browser agent strings found in Duqu 2.0:\n```\nMozilla/5.0 (Windows NT 5.1) AppleWebKit/535.6 (KHTML, like Gecko)\nChrome/16.0.897.0 Safari/535.6\nMozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;\nchromeframe/11.0.696.57)\nMozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.0; Trident/5.0;\nchromeframe/11.0.696.57)\nMozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; InfoPath.1;\nSV1; .NET CLR 3.8.36217; WOW64; en-US)\nMozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64;\nTrident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR\n3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\nMozilla/5.0 (Windows NT 6.2; WOW64; rv:15.0) Gecko/20120910144328\nFirefox/15.0.2\nMozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; SLCC2; .NET CLR\n2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0;\n.NET4.0C; .NET4.0E)\nMozilla/5.0 (Windows NT 6.1; rv:6.0) Gecko/20110814 Firefox/6.0\nMozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; .NET\nCLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\nMozilla/5.0 (compatible; MSIE 8.0; Windows NT 5.2; Trident/4.0; Media Center\nPC 4.0; SLCC1; .NET CLR 3.0.04320)\nMozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;\nFunWebProducts)\nMozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.15 (KHTML, like Gecko)\nChrome/24.0.1295.0 Safari/537.15\n\n```\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 30\n\n\n-----\n\n|Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/5.0) Mozilla/5.0 (Windows NT 6.1; rv:12.0) Gecko/20120403211507 Firefox/12.0 Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4 Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:5.0) Gecko/20110619 Firefox/5.0 Mozilla/5.0 (Windows; U; MSIE 7.0; Windows NT 6.0; en-US) Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SLCC1; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET CLR 1.1.4322) Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4325) Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/4.0; GTB7.4; InfoPath.1; SV1; .NET CLR 2.8.52393; WOW64; en-US) Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/16.0.912.77 Safari/535.7ad-imcjapan-syosyaman-xkgi3lqg03!wgz Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.1; FDM; .NET CLR 1.1.4322) Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2; .NET CLR 1.1.4322; .NET4.0C; Tablet PC 2.0) Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; GTB6.5; QQDownload 534; Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) ; SLCC2; .NET CLR 2.0.50727; Media Center PC 6.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729) Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.1; .NET CLR 1.1.4322) Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0) chromeframe/10.0.648.205 Mozilla/5.0 (Windows NT 6.1; rv:15.0) Gecko/20120716 Firefox/15.0a2 Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11 Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11 Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.26 Safari/537.11|Col2|\n|---|---|\n\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 31\n\n\n-----\n\n|Mozilla/5.0 (Windows NT 6.1; U; ru; rv:5.0.1.6) Gecko/20110501 Firefox/5.0.1 Firefox/5.0.1 Mozilla/5.0 (Windows NT 6.1.1; rv:5.0) Gecko/20100101 Firefox/5.0 Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 5.2; WOW64; .NET CLR 2.0.50727) Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0a2) Gecko/20110612 Firefox/6.0a2 Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0 Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.1.16) Gecko/20120427 Firefox/15.0a1 Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727) Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.17 Safari/537.11 Mozilla/5.0 (Windows NT 5.1; rv:6.0) Gecko/20100101 Firefox/6.0 FirePHP/0.6 Mozilla/4.0 (MSIE 6.0; Windows NT 5.1) Mozilla/5.0 (Windows NT 6.2; Win64; x64; rv:16.0.1) Gecko/20121011 Firefox/16.0.1 Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:5.0) Gecko/20100101 Firefox/5.0 Mozilla/5.0 (Windows NT 6.0; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.66 Safari/535.11 Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; c .NET CLR 3.0.04506; .NET CLR 3.5.30707; InfoPath.1; el-GR) Mozilla/5.0 (Windows NT 6.1; U;WOW64; de;rv:11.0) Gecko Firefox/11.0 Mozilla/3.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/5.0.1 Mozilla/5.0 (Windows; U; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727) Mozilla/5.0 (Windows NT 6.1; de;rv:12.0) Gecko/20120403211507 Firefox/12.0|Col2|\n|---|---|\n\n\n**Sample 7 –48 Browser agent strings in Duqu 2.0**\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 32\n\n\n-----\n\n### 2.7. DLL imports\n\nDuqu 2.0 uses more than one method to import functions from DLLs. One of the methods\nutilizes a hash method to represent function names as 4 byte integers. It iterates through all\nimportable function and finds the one whose function name hash matches the given hash.\nThis hash function uses a magic number. A very similar import method and hash function is\nused in Duqu and Duqu 2.0 although the magic numbers are different: 0x86F186F1 and\n0xB31FB31F. Note that even the inner structure of the magic numbers are similar (2x2 bytes).\n\n**Sample 8 – Hash function used for imports in Duqu and Duqu 2.0**\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 33\n\n\n-----\n\n## 3.Indicators of Compromise\n\n### 3.1. Detection based on communications\n\nThe malware can transmit information through HTTP traffic. It is most likely that one or more\ninfected computers can be proxy points towards the attacker, meaning that other infected\ncomputers communicate with these proxies. These proxies can act as HTTP or HTTPS servers.\nFor HTTPS, a self signed certificate is created by the malware itself. (Most likely by contacting\ngpl3.selfsigned.org). The Common Name (CN) field seems to be “*” in the created certificate.\nDuring data transfer, the malware uses <5 random numbers>.gif for file name and a\n843-byte GIF file + additional random bytes. The transmissions may be protected by AES.\n\nOne possible way to detect such transmission (if cleartext traffic is somehow available) to\ndetect the actual 843-byte GIF file. For the known two samples, this GIF portion was identical.\n\nThe actual image in hex dump is the following:\n```\n  00000000 47 49 46 38 39 61 0b 00 0b 00 70 00 00 21 f9 04 |GIF89a....p..!..|\n  00000010 01 00 00 fc 00 2c 00 00 00 00 0b 00 0b 00 87 00 |.....,..........|\n  00000020 00 00 00 00 33 00 00 66 00 00 99 00 00 cc 00 00 |....3..f........|\n  00000030 ff 00 2b 00 00 2b 33 00 2b 66 00 2b 99 00 2b cc |..+..+3.+f.+..+.|\n  00000040 00 2b ff 00 55 00 00 55 33 00 55 66 00 55 99 00 |.+..U..U3.Uf.U..|\n  00000050 55 cc 00 55 ff 00 80 00 00 80 33 00 80 66 00 80 |U..U......3..f..|\n  00000060 99 00 80 cc 00 80 ff 00 aa 00 00 aa 33 00 aa 66 |............3..f|\n  00000070 00 aa 99 00 aa cc 00 aa ff 00 d5 00 00 d5 33 00 |..............3.|\n  00000080 d5 66 00 d5 99 00 d5 cc 00 d5 ff 00 ff 00 00 ff |.f..............|\n  00000090 33 00 ff 66 00 ff 99 00 ff cc 00 ff ff 33 00 00 |3..f.........3..|\n  000000a0 33 00 33 33 00 66 33 00 99 33 00 cc 33 00 ff 33 |3.33.f3..3..3..3|\n  000000b0 2b 00 33 2b 33 33 2b 66 33 2b 99 33 2b cc 33 2b |+.3+33+f3+.3+.3+|\n  000000c0 ff 33 55 00 33 55 33 33 55 66 33 55 99 33 55 cc |.3U.3U33Uf3U.3U.|\n  000000d0 33 55 ff 33 80 00 33 80 33 33 80 66 33 80 99 33 |3U.3..3.33.f3..3|\n  000000e0 80 cc 33 80 ff 33 aa 00 33 aa 33 33 aa 66 33 aa |..3..3..3.33.f3.|\n  000000f0 99 33 aa cc 33 aa ff 33 d5 00 33 d5 33 33 d5 66 |.3..3..3..3.33.f|\n  00000100 33 d5 99 33 d5 cc 33 d5 ff 33 ff 00 33 ff 33 33 |3..3..3..3..3.33|\n  00000110 ff 66 33 ff 99 33 ff cc 33 ff ff 66 00 00 66 00 |.f3..3..3..f..f.|\n  00000120 33 66 00 66 66 00 99 66 00 cc 66 00 ff 66 2b 00 |3f.ff..f..f..f+.|\n  00000130 66 2b 33 66 2b 66 66 2b 99 66 2b cc 66 2b ff 66 |f+3f+ff+.f+.f+.f|\n  00000140 55 00 66 55 33 66 55 66 66 55 99 66 55 cc 66 55 |U.fU3fUffU.fU.fU|\n  00000150 ff 66 80 00 66 80 33 66 80 66 66 80 99 66 80 cc |.f..f.3f.ff..f..|\n  00000160 66 80 ff 66 aa 00 66 aa 33 66 aa 66 66 aa 99 66 |f..f..f.3f.ff..f|\n  00000170 aa cc 66 aa ff 66 d5 00 66 d5 33 66 d5 66 66 d5 |..f..f..f.3f.ff.|\n  00000180 99 66 d5 cc 66 d5 ff 66 ff 00 66 ff 33 66 ff 66 |.f..f..f..f.3f.f|\n\n```\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 34\n\n\n-----\n\n|00000190 66 ff 99 66 ff cc 66 ff ff 99 00 00 99 00 33 99 |f..f..f.......3.| 000001a0 00 66 99 00 99 99 00 cc 99 00 ff 99 2b 00 99 2b |.f..........+..+| 000001b0 33 99 2b 66 99 2b 99 99 2b cc 99 2b ff 99 55 00 |3.+f.+..+..+..U.| 000001c0 99 55 33 99 55 66 99 55 99 99 55 cc 99 55 ff 99 |.U3.Uf.U..U..U..| 000001d0 80 00 99 80 33 99 80 66 99 80 99 99 80 cc 99 80 |....3..f........| 000001e0 ff 99 aa 00 99 aa 33 99 aa 66 99 aa 99 99 aa cc |......3..f......| 000001f0 99 aa ff 99 d5 00 99 d5 33 99 d5 66 99 d5 99 99 |........3..f....| 00000200 d5 cc 99 d5 ff 99 ff 00 99 ff 33 99 ff 66 99 ff |..........3..f..| 00000210 99 99 ff cc 99 ff ff cc 00 00 cc 00 33 cc 00 66 |............3..f| 00000220 cc 00 99 cc 00 cc cc 00 ff cc 2b 00 cc 2b 33 cc |..........+..+3.| 00000230 2b 66 cc 2b 99 cc 2b cc cc 2b ff cc 55 00 cc 55 |+f.+..+..+..U..U| 00000240 33 cc 55 66 cc 55 99 cc 55 cc cc 55 ff cc 80 00 |3.Uf.U..U..U....| 00000250 cc 80 33 cc 80 66 cc 80 99 cc 80 cc cc 80 ff cc |..3..f..........| 00000260 aa 00 cc aa 33 cc aa 66 cc aa 99 cc aa cc cc aa |....3..f........| 00000270 ff cc d5 00 cc d5 33 cc d5 66 cc d5 99 cc d5 cc |......3..f......| 00000280 cc d5 ff cc ff 00 cc ff 33 cc ff 66 cc ff 99 cc |........3..f....| 00000290 ff cc cc ff ff ff 00 00 ff 00 33 ff 00 66 ff 00 |..........3..f..| 000002a0 99 ff 00 cc ff 00 ff ff 2b 00 ff 2b 33 ff 2b 66 |........+..+3.+f| 000002b0 ff 2b 99 ff 2b cc ff 2b ff ff 55 00 ff 55 33 ff |.+..+..+..U..U3.| 000002c0 55 66 ff 55 99 ff 55 cc ff 55 ff ff 80 00 ff 80 |Uf.U..U..U......| 000002d0 33 ff 80 66 ff 80 99 ff 80 cc ff 80 ff ff aa 00 |3..f............| 000002e0 ff aa 33 ff aa 66 ff aa 99 ff aa cc ff aa ff ff |..3..f..........| 000002f0 d5 00 ff d5 33 ff d5 66 ff d5 99 ff d5 cc ff d5 |....3..f........| 00000300 ff ff ff 00 ff ff 33 ff ff 66 ff ff 99 ff ff cc |......3..f......| 00000310 ff ff ff 00 00 00 00 00 00 00 00 00 00 00 00 08 |................| 00000320 28 00 ed 09 1c 48 50 20 3c 7b 07 13 22 5c 68 70 |(....HP <{..\"\\hp| 00000330 e0 41 87 0d 1f 2a 64 d8 b0 e2 c4 8b 10 09 4a 8c |.A...*d.......J.| 00000340 c8 10 63 c5 8f 1b 37 06 04 00 3b |..c...7...;| 0000034b|Col2|\n|---|---|\n\n\n**Sample 9 – Hexdump of the actual GIF image**\n\nThe image itself is a small picture, basic color is yellow and there are some orange dots in it:\n\n**Sample 10 – The actual GIF image**\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 35\n\n\n-----\n\n### 3.2. Yara rules to identify\n\nFor the main binary of the malware, we propose the following rules for detection:\n```\n rule duqu2\n {\n strings:\n $a = { 0F B6 C8 8B C1 0F AF C9 83 E0 ?? C1 E0 ?? 05 ?? ?? ?? ?? 0F\n AF D8 8B ?? ?? ?? 33 D9 }\n $b = { 0F 84 ?? ?? ?? ?? 0F B7 06 B9 ?? ?? ?? ?? 33 C1 3D ?? ?? ??\n ?? 0F 85 ?? ?? ?? ?? 8B }\n condition:\n any of them\n }\n\n```\n**Sample 11 – Yara rules for detection of Duqu 2.0**\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 36\n\n\n-----\n\n## 4.Conclusion\n\nWe’ve made an initial analysis to prove our claims that there is a strong connection between\nDuqu and Duqu 2.0 malwares. Our main goal was to highlight the most striking similarities and\ndifferences between the samples. Similarities shows that the developers of Duqu 2.0 have\nreused the code basis of the old Duqu specimens and the differences found in the binaries\nindicates that the developers of Duqu have modified their tools to avoid detections.\n\n## 5. References\n\n**[CrySySDuqu]**\n\n**CrySyS, Duqu: A Stuxnet-like malware found in the wild, v0.93 (14/Oct/2011)**\nhttp://www.crysys.hu/publications/files/bencsathPBF11duqu.pdf\n\n**[SymantecDuqu]**\n\n**Symantec, W32.Duqu: The precursor to the next Stuxnet, Version 1.4 (November 23,**\n2011)\nhttp://www.symantec.com/content/en/us/enterprise/media/security_response/white\npapers/w32_duqu_the_precursor_to_the_next_stuxnet.pdf\n\n**[KasperskyDuqu]**\n\n**Kaspersky Lab, Duqu: Steal Everything, Kaspersky Lab’s investigation - “The Mystery of**\nDuqu” in blogs\nhttp://www.kaspersky.com/about/press/major_malware_outbreaks/duqu\n\n**[SymantecDossier]**\n\n**Symantec, W32.Stuxnet Dossier, Version 1.4 (February 2011)**\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 37\n\n\n-----\n\nhttp://www.symantec.com/content/en/us/enterprise/media/security_response/white\npapers/w32_stuxnet_dossier.pdf\n\n**[KasperskyDuqu2.0]**\n\n**Kaspersky Lab, The Duqu 2.0: Technical Details, Version: 1.9.8 (2.June.2015)**\nhttps://securelist.com/blog/research/70504/the-mystery-of-duqu-2-0-a-sophisticatedcyberespionage-actor-returns/\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 38\n\n\n-----\n\n## 6. Contact Information\n\nQuestions and comments are welcome. The corresponding author is\nDr. Boldizsár Bencsáth\nbencsath@crysys.hu\n\nLaboratory of Cryptography and System Security\nCrySyS – http://www.crysys.hu/\nBudapest University of Technology and Economics\nDepartment of Telecommunications\n1117 Magyar Tudósok Krt. 2.\nBudapest, Hungary\n\nGPG BENCSATH Boldizsar <boldi@crysys.hu>\nKey ID 0x64CF6EFB\nFingerprint 286C A586 6311 36B3 2F94 B905 AFB7 C688 64CF 6EFB\n\nLaboratory of Cryptography and System Security (CrySyS)\nBudapest University of Technology and Economics\nwww.crysys.hu 39\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        },
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/yfoqrf6r0i0ih38pl0bmtud3ke0e6vhf",
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2015/2015.06.10.Duqu_2.0/duqu2_crysys.pdf",
        "https://papers.vx-underground.org/papers/ICS SCADA/Duqu/Duqu 2.0 - A comparison with Duqu.pdf"
    ],
    "report_names": [
        "duqu2_crysys",
        "Duqu 2.0 - A comparison with Duqu.pdf"
    ],
    "threat_actors": [
        {
            "id": "cf7fc640-acfe-41c4-9f3d-5515d53a3ffb",
            "created_at": "2023-01-06T13:46:38.228042Z",
            "updated_at": "2025-03-27T02:00:02.775905Z",
            "deleted_at": null,
            "main_name": "APT1",
            "aliases": [
                "GIF89a",
                "G0006",
                "PLA Unit 61398",
                "Group 3",
                "TG-8223",
                "Comment Group",
                "ShadyRAT",
                "COMMENT PANDA",
                "Comment Crew",
                "Byzantine Candor",
                "Brown Fox"
            ],
            "source_name": "MISPGALAXY:APT1",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "3aaf0755-5c9b-4612-9f0e-e266ef1bdb4b",
            "created_at": "2022-10-25T16:07:23.480196Z",
            "updated_at": "2025-03-27T02:02:09.826059Z",
            "deleted_at": null,
            "main_name": "Comment Crew",
            "aliases": [
                "APT 1",
                "BrownFox",
                "Byzantine Candor",
                "Byzantine Hades",
                "Comment Crew",
                "Comment Panda",
                "GIF89a",
                "Group 3",
                "Operation Oceansalt",
                "Operation Seasalt",
                "Operation Siesta",
                "Shanghai Group",
                "TG-8223"
            ],
            "source_name": "ETDA:Comment Crew",
            "tools": [
                "Auriga",
                "Cachedump",
                "Chymine",
                "CookieBag",
                "Darkmoon",
                "GDOCUPLOAD",
                "GLOOXMAIL",
                "GREENCAT",
                "Gen:Trojan.Heur.PT",
                "GetMail",
                "Hackfase",
                "Hacksfase",
                "Helauto",
                "Kurton",
                "LETSGO",
                "LIGHTBOLT",
                "LIGHTDART",
                "LOLBAS",
                "LOLBins",
                "LONGRUN",
                "Living off the Land",
                "Lslsass",
                "MAPIget",
                "ManItsMe",
                "Mimikatz",
                "MiniASP",
                "Oceansalt",
                "Pass-The-Hash Toolkit",
                "Poison Ivy",
                "ProcDump",
                "Riodrv",
                "SPIVY",
                "Seasalt",
                "ShadyRAT",
                "StarsyPound",
                "TROJAN.COOKIES",
                "TROJAN.FOXY",
                "TabMsgSQL",
                "Tarsip",
                "Trojan.GTALK",
                "WebC2",
                "WebC2-AdSpace",
                "WebC2-Ausov",
                "WebC2-Bolid",
                "WebC2-Cson",
                "WebC2-DIV",
                "WebC2-GreenCat",
                "WebC2-Head",
                "WebC2-Kt3",
                "WebC2-Qbp",
                "WebC2-Rave",
                "WebC2-Table",
                "WebC2-UGX",
                "WebC2-Yahoo",
                "Wordpress Bruteforcer",
                "bangat",
                "gsecdump",
                "pivy",
                "poisonivy",
                "pwdump",
                "zxdosml"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716500,
    "ts_updated_at": 1743041163,
    "ts_creation_date": 1433950603,
    "ts_modification_date": 1433950603,
    "files": {
        "pdf": "https://archive.orkl.eu/6c4fcf640dfbedbdddb724e69d0ed84319b0cf6e.pdf",
        "text": "https://archive.orkl.eu/6c4fcf640dfbedbdddb724e69d0ed84319b0cf6e.txt",
        "img": "https://archive.orkl.eu/6c4fcf640dfbedbdddb724e69d0ed84319b0cf6e.jpg"
    }
}