{
    "id": "b10f250b-4536-442d-bcee-0469f706c287",
    "created_at": "2023-01-12T15:08:24.948599Z",
    "updated_at": "2025-03-27T02:05:43.518341Z",
    "deleted_at": null,
    "sha1_hash": "47b54211e1243cb34f1e3b22ffa90b322db5eb3f",
    "title": "2018-09-06 - Dissecting DEloader malware with obfuscation",
    "authors": "",
    "file_creation_date": "2022-05-27T21:30:37Z",
    "file_modification_date": "2022-05-27T21:30:37Z",
    "file_size": 570164,
    "plain_text": "# Dissecting DEloader malware with obfuscation\n\n**[int0xcc.svbtle.com/dissecting-obfuscated-deloader-malware](https://int0xcc.svbtle.com/dissecting-obfuscated-deloader-malware)**\n\nSeptember 6, 2018\nDEloader is a loader malware which is mostly used to load Zeus banking trojan . It is a\nstealth malware designed to keep the payload hidden and encrypted in the memory . A\npayload is dynamically retrieved from a remote https server So far there have been 3\nversions of DEloader captured in the wild . Version 0x10E0700, 0x1050500h and\n**0x1120300h. More recently in version 0x1120300h they added code obfuscation**\n\nMain loader file is a DLL with export named as ‘start’ or ‘begin’ . These exports are called\nby packer . Essentially because this DLL is memory loaded image, imports and images are\nrelocated via the code in these exports\n\n\n-----\n\n-----\n\nEarlier version included a share file map as a marker for infection . Shared file mapping\nwould contain necessary information for the Deloader to run\n\nIf the mapping is found, the data from the map is fed to decoding algorithm which is based\non Rc4 and decodes using a fixed state buffer . This Algorithm is later used to decode buffer\ndownloaded from c2 .\n\n\n-----\n\nBuffer can be either downloaded from c2 or the previously saved one is extracted from\nregistry, which is later decoded using an embedded rc4 state buffer .\n\nC2’s are present in an embedded structure known baseconifg which consists configuration\nand c2’s address necessary for the loader to operate . In both the versions static config in\nencoded state\n\nIt can have single or multiple c2’s . Each of them is separated by a semi-colon ‘;’ .\nIn earlier versions c2 url was present as an encoded resource on a remote https server . And\nwas downloaded using a get HTTP/HTTPSs request\n\n\n-----\n\nHowever in the latest version, it includes a URL where encoded system internal data is\nposted and in return an encoded data buff is returned back .\n\nThis data is encoded with the same rc4state buffer extracted from static config embedded in\nthe binary .Depending upon an internal flag it could be compressed as well . The\ncompression algorithm used is unrv2b which happens to be the same one used in traditional\nZeus malware .Also integrity of data is checked against a CRC32 hash DWORD present at\nthe end of the data packet\n\nraw response can represented as\n```\nstruct RawResponse\n{\n    BYTE Data[len - 4];\n    DWORD CRC32Data;\n};\n struct \n{\n    __int64 DecompressionLength;\n    BYTE CompressedData[]\n};\n\n```\n\n-----\n\nAfter decompression data packet is arranged in a structure which consists of\n```\nstruct InternalC2Parsed\n{\n    unsigned int PlaceHolder = 0x1000000;\n    unsigned int Version; // 4\n    void *PEBuffer_32bit; \n    unsigned int PEBuffer_32bit_len; \n    void *PEBuffer_64bit; \n    unsigned int PEBuffer_64bit_len;\n    void *C2StructDecompressed; \n    int C2StructDecompressed_len; \n};\n\n```\nDepending upon the type of system a particular type of payload(32bit or 64bit ) payload in\ninjected in process memory . If the system happens to be 64bit, a well known technique\n“heavens gate” is used to inject to 64bit process from a 32 bit running process\n\n\n\nFollowing python script demonstrates the ability to decode and decompress\n\n\n-----\n\n```\n#!/usr/bin/env python\nimport ucl\ndef PRGA(S):\n  i = 0\n  j = 0\n  while True:\n    i = (i + 1) % 256\n    j = (j + S[i]) % 256\n    S[i], S[j] = S[j], S[i] # swap\n    K = S[(S[i] + S[j]) % 256]\n    yield K\nif __name__ == '__main__':\n  plaintext = open(\"Bindata\", \"rb\").read()\n  import array\n  keystream = [\n  0xD7, 0x81, 0x83, 0xA6, 0x59, 0x4B, 0x88, 0x32, 0xFB, 0x8D, 0x7A, 0x64, 0x08,\n0x9F, 0x6D, 0x01,\n  0x2C, 0xD8, 0x50, 0xCE, 0xA3, 0x4A, 0xF9, 0x21, 0x40, 0x91, 0xE4, 0x28, 0x22,\n0xAA, 0x41, 0x0D,\n  0x68, 0x44, 0xA7, 0xB8, 0xA5, 0xFE, 0x3A, 0x2F, 0x7C, 0xDA, 0x37, 0x94, 0x46,\n0x92, 0x86, 0x0A,\n  0x25, 0xEA, 0x45, 0xB1, 0xAE, 0x7B, 0xE2, 0x3F, 0xBC, 0x7D, 0x84, 0x9A, 0xE5,\n0x77, 0x0F, 0xA2,\n  0xDD, 0x1A, 0x5F, 0xFA, 0x78, 0x67, 0x12, 0x02, 0x03, 0x3B, 0x65, 0x62, 0xF5,\n0xBE, 0x8C, 0x27,\n  0x9D, 0x69, 0xA8, 0x56, 0x5E, 0xE6, 0x61, 0xFF, 0x72, 0x5C, 0x19, 0xD6, 0xD4,\n0x6A, 0x52, 0xD2,\n  0xDC, 0x55, 0xDF, 0x70, 0x18, 0x0C, 0xEE, 0x87, 0x95, 0x07, 0xA1, 0x05, 0xA4,\n0x5D, 0xE1, 0x06,\n  0xB0, 0xC0, 0x29, 0x80, 0x53, 0xE7, 0xE3, 0x93, 0x16, 0xF2, 0x1B, 0x96, 0xDB,\n0x90, 0xAC, 0xF6,\n  0x7E, 0x6F, 0xF1, 0x6C, 0xB6, 0xF4, 0x63, 0xB3, 0x8A, 0xC3, 0xFC, 0x8F, 0x1F,\n0x3D, 0x9C, 0x2B,\n  0xB9, 0xCB, 0x35, 0x2D, 0xA0, 0xC6, 0x74, 0xFD, 0xBF, 0x23, 0xEB, 0xB5, 0x89,\n0x82, 0x30, 0xBB,\n  0x0B, 0x76, 0x17, 0x4F, 0x4E, 0x1E, 0xD9, 0x58, 0x13, 0x6B, 0x26, 0x9E, 0xD0,\n0xE0, 0x48, 0xF0,\n  0x6E, 0xB4, 0x0E, 0xC4, 0xEC, 0x00, 0xD1, 0xCF, 0xC8, 0x7F, 0x20, 0x38, 0x79,\n0xCD, 0x49, 0xC7,\n  0x47, 0xED, 0x31, 0xCA, 0xC1, 0x39, 0xC9, 0x98, 0x1D, 0x33, 0x5A, 0x3E, 0x51,\n0x4C, 0x8B, 0x24,\n  0xB2, 0xB7, 0x4D, 0xE8, 0x54, 0xEF, 0x9B, 0xC5, 0x09, 0xF7, 0x2A, 0x3C, 0xBD,\n0x36, 0x71, 0x2E,\n  0x15, 0xF3, 0xA9, 0x60, 0x10, 0xAF, 0xC2, 0x73, 0x97, 0x34, 0x66, 0x99, 0x8E,\n0xDE, 0xAD, 0xAB,\n  0xBA, 0xF8, 0x11, 0xD5, 0x75, 0x43, 0x57, 0x04, 0xCC, 0xE9, 0x42, 0x85, 0x14,\n0x1C, 0x5B, 0xD3 \n]\n\n```\n\n-----\n\n```\n  arr array.array( B, keystream)\n  keystream = PRGA(arr)\n  import sys\n  finBuf = array.array(\"B\")\n  i = 0\n  for c in plaintext:\n    finBuf.append(ord(c) ^ keystream.next())\n    i = i + 1\n  open(\"FinalData.bin\", \"wb\").write(finBuf.tostring())\n\n```\nand to finally decomrpess the data we can use CTYPES to call the following subroutine in\npython\n[https://github.com/wt/coreboot/blob/master/payloads/bayou/nrv2b.c](https://github.com/wt/coreboot/blob/master/payloads/bayou/nrv2b.c)\n\n\n-----\n\n```\n#ifndef ENDIAN\n#define ENDIAN  0\n#endif\n#ifndef BITSIZE\n#define BITSIZE 32\n#endif\n#define GETBIT_8(bb, src, ilen) \\\n  (((bb = bb & 0x7f ? bb*2 : ((unsigned)src[ilen++]*2+1)) >> 8) & 1)\n#define GETBIT_LE16(bb, src, ilen) \\\n  (bb*=2,bb&0xffff ? (bb>>16)&1 : (ilen+=2,((bb=(src[ilen-2]+src[ilen1]*256)*2+1)>>16)&1))\n#define GETBIT_LE32(bb, src, ilen) \\\n  (bc > 0 ? ((bb>>--bc)&1) : (bc=31,\\\n  bb=*(const uint32_t *)((src)+ilen),ilen+=4,(bb>>31)&1))\n#if ENDIAN == 0 && BITSIZE == 8\n#define GETBIT(bb, src, ilen) GETBIT_8(bb, src, ilen)\n#endif\n#if ENDIAN == 0 && BITSIZE == 16\n#define GETBIT(bb, src, ilen) GETBIT_LE16(bb, src, ilen)\n#endif\n#if ENDIAN == 0 && BITSIZE == 32\n#define GETBIT(bb, src, ilen) GETBIT_LE32(bb, src, ilen)\n#endif\nstatic unsigned long unrv2b(uint8_t * src, uint8_t * dst, unsigned long *ilen_p)\n{\n    unsigned long ilen = 0, olen = 0, last_m_off = 1;\n    uint32_t bb = 0;\n    unsigned bc = 0;\n    const uint8_t *m_pos;\n    // skip length\n    src += 4;\n    /* FIXME: check olen with the length stored in first 4 bytes */\n    for (;;) {\n        unsigned int m_off, m_len;\n        while (GETBIT(bb, src, ilen)) {\n            dst[olen++] = src[ilen++];\n        }\n        m_off = 1;\n        do {\n            m_off = m_off * 2 + GETBIT(bb, src, ilen);\n        } while (!GETBIT(bb, src, ilen));\n        if (m_off == 2) {\n            m_off = last_m_off;\n        } else {\n            m_off = (m_off - 3) * 256 + src[ilen++];\n            if (m_off == 0xffffffffU)\n                break;\n            last_m_off = ++m_off;\n\n```\n\n-----\n\n```\n        }\n        m_len = GETBIT(bb, src, ilen);\n        m_len = m_len * 2 + GETBIT(bb, src, ilen);\n        if (m_len == 0) {\n            m_len++;\n            do {\n                m_len = m_len * 2 + GETBIT(bb, src, ilen);\n            } while (!GETBIT(bb, src, ilen));\n            m_len += 2;\n        }\n        m_len += (m_off > 0xd00);\n        m_pos = dst + olen - m_off;\n        dst[olen++] = *m_pos++;\n        do {\n            dst[olen++] = *m_pos++;\n        } while (--m_len > 0);\n    }\n    *ilen_p = ilen;\n    return olen;\n}\n\n```\nFinally after decoding and decompression a vaid PE file is obtained . A file size of 1.05MB.\n\n## Source code level obfuscation . #\n\n\n-----\n\nIn a more recent version 0x1120300h source code level obfuscation was added . This type of\nobfuscation is known as opaque predicates which makes the process of reverse engineering\nbit difficult . The basic Idea behind this technique is to include calculation based comparison\ninstruction which end with a conditional jump, which are not the part of the original code, but\nare the part of code path .\n\nIn the images below a comparison is shown between a CRC32() function in version\n**0x1120300h and an earlier version 0x1050500h. Which demonstrates the multiple junk**\ninstructs and paths added with inclusion of opaque predicates\n\nThis happens to be quite evident in the entropy comparison of the binary in whole .\n\nEven the downloaded payload which happens to be a version of traditional Zeus banking\nmalware is also obfuscated, which generally in its unpacked form is detected by most of\nthen antivirus scans, but due to code level obfuscation is marked clean by most of the major\n\n\n-----\n\nanti virus engines\n\nconclusion :\n\nDeloader is still under heavy development . DeLoader has consistently evolved since past\nfew years . With the addition of a hard obfuscation technique is it quite sure that the authors\nof deloader want to make this analysis hard and apparently makes it slip the anti virus filter .\nThe use of encryption and compression make the data sent around the command and\ncontrol server cryptic and hard to detect using a pattern . The payload which s mostly being\ndelivered is a financial malware, designed to steal banking credentials, which makes it clear\nthat authors are inclined towards monetization of injecting machines .\n\n13\n\nKudos\n\n13\n\nKudos\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-09-06 - Dissecting DEloader malware with obfuscation.pdf"
    ],
    "report_names": [
        "2018-09-06 - Dissecting DEloader malware with obfuscation.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536104,
    "ts_updated_at": 1743041143,
    "ts_creation_date": 1653687037,
    "ts_modification_date": 1653687037,
    "files": {
        "pdf": "https://archive.orkl.eu/47b54211e1243cb34f1e3b22ffa90b322db5eb3f.pdf",
        "text": "https://archive.orkl.eu/47b54211e1243cb34f1e3b22ffa90b322db5eb3f.txt",
        "img": "https://archive.orkl.eu/47b54211e1243cb34f1e3b22ffa90b322db5eb3f.jpg"
    }
}