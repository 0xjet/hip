{
    "id": "c9f67b90-de37-4867-9f5b-cebf258b405c",
    "created_at": "2023-01-12T15:02:11.901593Z",
    "updated_at": "2025-03-27T02:05:44.77847Z",
    "deleted_at": null,
    "sha1_hash": "8bb4a93c734cb4e68a88e1873de24a00146fc2e8",
    "title": "2020-06-21 - Deep Analysis of SmokeLoader",
    "authors": "",
    "file_creation_date": "2022-05-28T00:26:55Z",
    "file_modification_date": "2022-05-28T00:26:55Z",
    "file_size": 881131,
    "plain_text": "# Deep Analysis of SmokeLoader\n\n**n1ght-w0lf.github.io/malware analysis/smokeloader/**\n\n### Abdallah Elshinbary\n\nMalware Analysis & Reverse Engineering Adventures\n\n13 minute read\n\n\nJune 21, 2020\n\n\nSmokeLoader is a well known bot that is been around since 2011. It’s mainly used to drop other malware families.\nSmokeLoader has been under development and is constantly changing with multiple novel features added throughout the\nyears.\n\n```\nSample SHA256: fc20b03299b8ae91e72e104ee4f18e40125b2b061f1509d1c5b3f9fac3104934\n\n```\n\n-----\n\n## Stage 1\n\nThis stage starts off by allocating memory for `shellcode using` `LocalAlloc() (not VirtualAlloc), then it fills this`\nmemory with the shellcode (86 KB).\n\nNext, it changes the protection of the allocated memory region to `PAGE_EXECUTE_READWRITE using`\n```\nVirtualProtect(), then it writes the shellcode and executes it.\n\n## Shellcode\n\n```\nThe shellcode starts by getting the addresses of `LoadLibraryA and` `GetProcAddress to resolve APIs dynamically, but`\nfirst let’s see how it does that.\n\nFirst it passes some hash values to a sub-routine that returns the address of the requested function.\n\n\n-----\n\nAfter some digging, I found out that the algorithm for calculating the hashes is pretty simple.\n```\nint calc_hash(char* name) {\n  int x, hash = 0;\n  for(int i=0; i<strlen(name); i++) {\n    x = name[i] | 0x60;\n    hash = 2 * (x + hash);\n  }\n  return hash;\n}\n\n```\nThe shellcode uses `PEB traversal technique for finding a function.`\n\nProcess Environment Block (PEB) is a user-mode data structure that can be used by applications (and by extend\nby malware) to get information such as the list of loaded modules, process startup arguments, heap address among\nother useful capabilities.\n\nThe shellcode traverses the PEB structure at `FS[:30] and iterating through loaded modules to search for the requested`\nmodule (kernel32 in this case). It hashes the name of each module using the algorithm above and compares it with the\nsupplied hash.\n\nNext, it iterates over the export table of the module to find the requested function, similar to the previous step.\n\nThe next step is to resolve APIs using `LoadLibraryA and` `GetProcAddress, the shellcode uses stack strings to`\ncomplicate the analysis.\n\n\n-----\n\nHere is the list of imported functions:\n\nExpand to see more\nntdll.dll\nNtUnmapViewOfSection\nNtWriteVirtualMemory\nkernel32.dll\nCloseHandle\nCreateFileA\nCreateProcessA\nExitProcess\nGetCommandLineA\nGetFileAttributesA\nGetModuleFileNameA\nGetStartupInfoA\nGetThreadContext\nReadProcessMemory\nResumeThread\nSetThreadContext\nVirtualAlloc\nVirtualAllocEx\nVirtualFree\nVirtualProtectEx\nWaitForSingleObject\nWinExec\nWriteFile\nWriteProcessMemory\nuser32.dll\nCreateWindowExA\nDefWindowProcA\nGetMessageA\n\nGetMessageExtraInfo\n\n\n-----\n\nMessageBoxA\nPostMessageA\nRegisterClassExA\n\n## Process Hollowing\n\nThe shellcode creates a new processes of SmokeLoader in a suspended state.\n\nNext, it hollows out the memory at `0x400000 using` `ZwUnmapViewOfSection() and then allocates it again using`\n```\nVirtualAllocEx() with RWX permissions.\n\n```\nFinally, it writes the next stage executable to the allocated memory region using two calls to `ZwWriteVirtualMemory(),`\nthe first one to write the MZ header and the other for the rest of the executable.\n\n## Stage 2\n\nAfter dumping the second stage from memory, I got a warm welcome from SmokeLoader :(\n\n\n-----\n\nThis stage is full of anti analysis tricks, so let s dive in.\n\n## Opaque Predicates\n\nThe first anti-analysis trick is [Opaque Predicates, it’s a commonly used technique in program obfuscation, intended to add](https://en.wikipedia.org/wiki/Opaque_predicate)\ncomplexity to the control flow. There are many patterns of this technique so I will stick with the one used here.\n\nThis obfuscation simply takes an absolute jump (JMP) and transforms it into two conditional jumps (JZ/JNZ). Depending\non the value of the `Zero flag (ZF), the execution will follow the first or second branch.`\n\nHowever, disassemblers are tricked into thinking that there is a fall-through branch if the second jump is not taken (which\nis impossible as one of them must be taken) and tries to disassemble the unreachable instructions (often invalid) resulting\nin garbage code.\n\nThe deobfuscation is so simple, we just need to patch the first conditional jump to an absolute jump and nop out the\nsecond jump, we can use `IDAPython to achieve this:`\n```\nimport idc\nea = 0\nwhile True:\n  ea = min(idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, \"74 ? 75 ?\"), # JZ / JNZ\n       idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, \"75 ? 74 ?\")) # JNZ / JZ\n  if ea == idc.BADADDR:\n     break\n  idc.patch_byte(ea, 0xEB) # JMP\n  idc.patch_byte(ea+2, 0x90) # NOP\n  idc.patch_byte(ea+3, 0x90) # NOP\n\n## Anti Debugging\n\n```\nThis stage first checks `OSMajorVersion at PEB[0xA4] if it’s greater than 6 (Windows Vista and higher), it’s also`\nreading `BeingDebugged at PEB[0x2] to check for attached debuggers.`\n\nWhat’s interesting here is that these checks are used to calculate the return address. If the `OSMajroVersion is less`\nthan 6 or there’s an attached debugger, it will jump to an invalid memory location. That’s clever.\n\nAnother neat trick is that instead of using direct jumps, the code pushes the jump address stored at `eax into the stack`\nthen returns to it.\n\n\n-----\n\n## Encrypted Functions\n\nMost of the functions are encrypted. After deobfuscating the opaque predicates, I found the encryption function which is\npretty simple.\n\nThe function takes an offset and a size, it XORes the chunk at that offset with a single byte `(0xA6) .`\n\nWe can use `IDAPython again to decrypt the encrypted chunks:`\n```\nimport idc\nimport idautils\ndef xor_chunk(offset, n):\n     ea = 0x400000 + offset\n     for i in range(n):\n          byte = ord(idc.get_bytes(ea+i, 1))\n          byte ^= 0xA6\n          idc.patch_byte(ea+i, byte)\nxor_chunk_addr = 0x401294 # address of the xoring function\nfor xref in idautils.CodeRefsTo(xor_chunk_addr, 0):\n     mov_addr = list(idautils.CodeRefsTo(xref, 0))[0] - 5\n     n = idc.get_operand_value(mov_addr, 1)\n     offset = (xref + 5) - 0x400000\n     xor_chunk(offset, n)\n\n```\nAfter the decryption:\n\nOne thing to note here, SmokeLoader tries to keep as many encrypted code as possible. So once it’s done with the\ndecrypted functions, it encrypts it again.\n\n\n-----\n\n## Anti Hooking\n\nMany Sandboxes and Security Solutions hook user-land functions of `ntdll.dll to trace system calls. SmokeLoader`\ntries to evade this by using its own copy of ntdll. It copies `ntdll.dll to` `\"%TEMP%\\<hardcoded_name>.tmp\" then loads`\nit using `LdrLoadDll() and resolves its imports from it.`\n\n## Custom Imports\n\nSmokeLoader stores a hash table of its imports, it uses the same `PEB traversal technique explained earlier to walk`\nthrough the DLLs’ export table and compare the hash of each API name with the stored hashes.\n\nThe hashing function is an implementation of `djb2 hashing algorithms:`\n```\nint calc_hash(char *api_name) {\n     int hash=0x1505;\n     for(int i=0; i<=strlen(api_name); i++) // null byte included\n          hash = ((hash << 5) + hash) + api_name[i];\n     return hash;\n}\n\n```\nHere is a list of imported functions and their corresponding hashes:\n\nExpand to see more\nntdll.dll\n\nLdrLoadDll (0x64033f83)\n\nNtClose (0xfd507add)\n\nNtTerminateProcess (0xf779110f)\n\nRtlInitUnicodeString (0x60a350a9)\n\nRtlMoveMemory (0x845136e7)\n\n\n-----\n\nRtlZeroMemory (0x8a3d4cb0)\nkernel32.dll\nCopyFileW (0x306cceb7)\nCreateEventW (0xfd4027f2)\nCreateFileMappingW (0x5b3f901c)\nCreateThread (0x60277e71)\nDeleteFileW (0xb7e96d0f)\nExpandEnvironmentStringsW (0x057074bb)\nGetModuleFileNameA (0x8acccaed)\nGetModuleFileNameW (0x8acccdc3)\nGetModuleHandleA (0x9cbd2a58)\nGetSystemDirectoryA (0xaebc5060)\nGetTempFileNameW (0x9a376a33)\nGetTempPathW (0x7e28b9df)\nGetVolumeInformationA (0xf25ce6a4)\nLocalAlloc (0xeda647bb)\nLocalFree (0x742c61b2)\nMapViewOfFile (0x4db4c713)\nSleep (0xd156a5be)\nWaitForSingleObject (0x8681d8fa)\nlstrcatW (0x2ab51a99)\nlstrcmpA (0x2abb9b4b)\nuser32.dll\nEnumChildWindows (0x9a8897c9)\nEnumPropsA (0x8f0f57cf)\nGetForegroundWindow (0x5a6c9878)\nGetKeyboardLayoutList (0x04e9de30)\nGetShellWindow (0xd454e895)\nGetWindowThreadProcessId (0x576a5801)\nSendMessageA (0x41ecd315)\nSendNotifyMessageA (0xc6123bae)\nSetPropA (0x90bc10d3)\nwsprintfW (0x0bafd3f9)\nadvapi32.dll\nGetTokenInformation (0x696464ac)\nOpenProcessToken (0x74f5e377)\nshell32.dll\nShellExecuteExW (0xf8e40384)\nAnd here is the list of the imported functions from the copied ntdll (for anti-hooking):\n\nExpand to see more\n4DD3.tmp\nNtAllocateVirtualMemory (0x5a0c2ccc)\nNtCreateSection (0xd5f23ad0)\nNtEnumerateKey (0xb6306996)\nNtFreeVirtualMemory (0x2a6fa509)\nNtMapViewOfSection (0x870246aa)\nNtOpenKey (0xc29efe42)\nNtOpenProcess (0x507bcb58)\nNtQueryInformationProcess (0xd6d488a2)\nNtQueryKey (0xa9475346)\nNtQuerySystemInformation (0xb83de8a8)\nNtUnmapViewOfSection (0x8352aa4d)\nNtWriteVirtualMemory (0x546899d2)\nRtlDecompressBuffer (0xdeb36606)\n\n\n-----\n\ntowlower (0xf7660ba8)\nwcsstr (0xbb629f0b)\n\n## Anti VM\n\nSmokeLoader enumerates all the subkeys of these keys:\n\nSystem\\CurrentControlSet\\Enum\\IDE\nSystem\\CurrentControlSet\\Enum\\SCSI\n\nThen it transforms them into lowercase and searches for these strings in the enumerated keys names:\n\nqemu\nvirtio\nvmware\nvbox\nxen\n\nIf one of them is found, the binary exits.\n\n## Process Injection\n\n[SmokeLoader uses PROPagate injection method to inject the next stage into](http://www.hexacorn.com/blog/2017/10/26/propagate-a-new-code-injection-trick/) `explorer.exe .`\n\nFirst it decompresses the next stage using `RtlDecompressBuffer() .`\n\nThen there is a call to `NtOpenProcess() to open` `explorer.exe for the injection.`\n\n\n-----\n\nThe injection process starts by creating two shared sections between the current process and explorer process (one\nsection for the modified property and the other for the next stage’s code), then SmokeLoader maps the created sections\nto the current process and explorer process memory space (so any changes in the sections will be reflected in explorer\nprocess).\n\nNote that both sections have `\"RWX\" protection which might raise some red flags by security solutions.`\n\nWe can see that explorer got a handle to these two sections (this is similar to classic code injection but with much more\nstealth).\n\nSmokeLoader then writes the next stage to one of the sections and the modified property (which will call the next stage’s\ncode) to the other section.\n\n\n-----\n\nFinally, it sets the modified property using `SetPropA() and sends a message to explorer window using`\n```\nSendNotifyMessageA(), this will result in the injected code being executed in the context of explorer.exe .\n\n## Stage 3\n\n```\nThis is the final stage of SmokeLoader, it starts by doing some anti-analysis checks.\n\n## Checking Running Processes\n\nThis stage loops through the running process, it calculates each process name’s hash and compares it against some\nhardcoded hashes.\n\nHere is the algorithm for calculating the hash of a process name:\n```\nuint ROL(uint x, uint bits) {\n     return x<<bits | x>>(32-bits);\n}\nint calc_hash(char *proc_name) {\n     int hash = 0;\n     for(int i=0; i<strlen(proc_name); i++)\n          hash = (proc_name[i] & 0xDF) + ROL(hash ^ (proc_name[i] & 0xDF), 8);\n     return hash ^ 0xD781F33C;\n}\n\n```\nA quick guess and I could get the processes names:\n```\n0xD384255C → Autoruns.exe\n0x76BDCBAB → procexp.exe\n0xA159E6BE → procexp64.exe\n0x7E9CCCA5 → procmon.exe\n0xA24B8E63 → procmon64.exe\n0x63B3D1A4 → Tcpview.exe\n0xA28974F3 → Wireshark.exe\n0xA9B5F897 → ProcessHacker.exe\n0x6893EBAB → ollydbg.exe\n0xF5FD94B7 → x32dbg.exe\n0xCBFD99B0 → x64dbg.exe\n0x8993DEE5 → idaq.exe\n0x8993D8CF → idaw.exe\n0x8C083960 → idaq64.exe\n0xB6223960 → idaw64.exe\n\n```\nIf one of these processes is found to be running, `explorer.exe will exit.`\n\n## Encrypted Strings\n\nAll strings of this stage are encrypted using `RC4 and they are decrypted on demand. The RC4 key =` `0xFA5F66D7 .`\n\nThe encrypted strings are stored continuously in a big blob in this form:\n\n\n-----\n\nHere is a small script for decrypting these strings (I used Go because it has native support for RC4).\n```\npackage main\nimport (\n     \"fmt\"\n     \"io/ioutil\"\n     \"encoding/hex\"\n     \"crypto/rc4\"\n)\nvar RC4_KEY, _ = hex.DecodeString(\"FA5F66D7\")\nfunc rc4_decrypt(data []byte) {\n     cipher, _ := rc4.NewCipher(RC4_KEY)\n     cipher.XORKeyStream(data, data)\n     fmt.Printf(\"%s\\n\", data)\n}\nfunc main() {\n     data, _ := ioutil.ReadFile(\"dump\")\n     for i := 0; i < len(data); {\n          n := int(data[i])\n          rc4_decrypt(data[i+1:i+n+1])\n          i += n+1\n     }\n}\n\n```\nAnd here is the decrypted strings:\n\nExpand to see more\nhttp://www.msftncsi.com/ncsi.txt\n\nSoftware\\Microsoft\\Internet Explorer\n\nadvapi32.dll\n\nLocation:\n\nplugin_size\n\n\\explorer.exe\n\nuser32\n\nadvapi32\n\nurlmon\nole32\n\nwinhttp\n\nws2_32\n\ndnsapi\n\nsvcVersion\n\nVersion\n\n&lt?xml version=\"1.0\"?&gt&ltscriptlet&gt&ltregistration classid=\"{00000000-0000-0000-000000000000%04X}\"&gt&ltscript language=\"jscript\"&gt&lt!\n\n[CDATA[GetObject(\"winmgmts:Win32_Process\").Create(\"%ls\",null,null,null);]]&gt&lt/script&gt&lt/registration&gt&lt/scriptlet&gt\nS:(ML;;NW;;;LW)D:(A;;0x120083;;;WD)(A;;0x120083;;;AC)\n\n%s\\%hs\n\n%s%s\n\n\n-----\n\nregsvr32 /s %s\nregsvr32 /s /n /u /i:\"%s\" scrobj\n%APPDATA%\n%TEMP%\n.exe\n.dll\n:Zone.Identifier\nPOST\nContent-Type: application/x-www-form-urlencoded\nrunas\nHost: %s\nPT10M\n1999-11-30T00:00:00\nNvNgxUpdateCheckDaily_{%08X-%04X-%04X-%04X-%08X%04X}\nAccept: */*\nReferer: %S\n\n## Encrypted C2 Domains\n\nThe C2 domains are encrypted using simple XOR operations.\n\nThey are stored in a in this form:\n\n\n-----\n\nWe can easily decrypt the domains:\n```\ndef decrypt_c2(enc, key):\n     enc, key = bytes.fromhex(enc), bytes.fromhex(key)\n     dec = \"\"\n     for c in enc:\n          for i in key: c = c ^ i\n          dec += chr(c ^ 0xE4)\n     print(dec)\n# decrypt_c2(\"E7FBFBFFB5A0A0E2E0FCFBEAFCFBA2FCEAFDF9E6ECEABFBEBDBABFBAA1FDFAA0\", \"EFC11A5F\")\n# http://mostest-service012505.ru/\n\n## C2 Communications\n\n```\nSmokeLoader sleeps for 10 seconds (1000*10) before connecting to the Internet.\n\nFirst it queries `http://www.msftncsi.com/ncsi.txt (This URL is usually queried by Windows to determine if the`\ncomputer is connected to the Internet).\n\nIf there’s no response, it sleeps for `64 ms and queries it again until it receives a response.`\n\nThen SmokeLoader sends a `POST request to the C2 server. The payload is encrypted using` `RC4 before sending it.`\n\nThe `POST request returns a` `\"404 Not Found\" response but it contains a payload in the response body.`\n\nUnfortunately most of the C2 domains are down so I couldn’t proceed with the analysis, but I think that’s enough with\nSmokeLoader :)\n\n## IOCs\n\n**Hashes**\n\n\n-----\n\nSmokeLoader fc20b03299b8ae91e72e104ee4f18e40125b2b061f1509d1c5b3f9fac3104934\n\n**Files**\n\n%TEMP%\\4dd3.dll\n\n**C2 Domains**\n\nhttp://alltest-service012505[.]ru/\n\nhttp://besttest-service012505[.]ru/\n\nhttp://biotest-service012505[.]ru/\n\nhttp://clubtest-service012505[.]ru/\n\nhttp://domtest-service012505[.]ru/\nhttp://infotest-service012505[.]ru/\n\nhttp://kupitest-service012505[.]ru/\n\nhttp://megatest-service012505[.]ru/\n\nhttp://mirtest-service012505[.]ru/\n\nhttp://mostest-service012505[.]ru/\n\nhttp://mytest-service01242505[.]ru/\nhttp://mytest-service012505[.]ru/\n\nhttp://newtest-service012505[.]ru/\n\nhttp://proftest-service012505[.]ru/\n\nhttp://protest-01242505[.]tk/\n\nhttp://protest-01252505[.]ml/\n\nhttp://protest-01262505[.]ga/\n\nhttp://protest-01272505[.]cf/\n\nhttp://protest-01282505[.]gq/\n\nhttp://protest-01292505[.]com/\n\nhttp://protest-01302505[.]net/\n\nhttp://protest-01312505[.]org/\n\nhttp://protest-01322505[.]biz/\n\nhttp://protest-01332505[.]info/\n\nhttp://protest-01342505[.]eu/\n\nhttp://protest-01352505[.]nl/\n\nhttp://protest-01362505[.]mobi/\n\nhttp://protest-01372505[.]name/\n\nhttp://protest-01382505[.]me/\n\nhttp://protest-01392505[.]garden/\n\nhttp://protest-01402505[.]art/\n\nhttp://protest-01412505[.]band/\n\nhttp://protest-01422505[.]bargains/\n\nhttp://protest-01432505[.]bet/\n\nhttp://protest-01442505[.]blue/\n\nhttp://protest-01452505[.]business/\n\nhttp://protest-01462505[.]casa/\n\nhttp://protest-01472505[.]city/\n\nhttp://protest-01482505[.]click/\nhttp://protest-01492505[.]company/\n\nhttp://protest-01502505[.]futbol/\n\nhttp://protest-01512505[.]gallery/\n\nhttp://protest-01522505[.]game/\n\nhttp://protest-01532505[.]games/\n\nhttp://protest-01542505[.]graphics/\n\nhttp://protest-01552505[.]group/\n\nhttp://protest-02252505[.]ml/\n\nhttp://protest-02262505[.]ga/\n\n\n-----\n\nhttp://protest 02272505[.]cf/\nhttp://protest-02282505[.]gq/\nhttp://protest-03252505[.]ml/\nhttp://protest-03262505[.]ga/\nhttp://protest-03272505[.]cf/\nhttp://protest-03282505[.]gq/\nhttp://protest-05242505[.]tk/\nhttp://protest-06242505[.]tk/\nhttp://protest-service01242505[.]ru/\nhttp://protest-service012505[.]ru/\nhttp://rustest-service012505[.]ru/\nhttp://rutest-service01242505[.]ru/\nhttp://rutest-service012505[.]ru/\nhttp://shoptest-service012505[.]ru/\nhttp://supertest-service012505[.]ru/\nhttp://test-service01242505[.]ru/\nhttp://test-service012505[.]com/\nhttp://test-service012505[.]eu/\nhttp://test-service012505[.]fun/\nhttp://test-service012505[.]host/\nhttp://test-service012505[.]info/\nhttp://test-service012505[.]net/\nhttp://test-service012505[.]net2505[.]ru/\nhttp://test-service012505[.]online/\nhttp://test-service012505[.]org2505[.]ru/\nhttp://test-service012505[.]pp2505[.]ru/\nhttp://test-service012505[.]press/\nhttp://test-service012505[.]pro/\nhttp://test-service012505[.]pw/\nhttp://test-service012505[.]ru[.]com/\nhttp://test-service012505[.]site/\nhttp://test-service012505[.]space/\nhttp://test-service012505[.]store/\nhttp://test-service012505[.]su/\nhttp://test-service012505[.]tech/\nhttp://test-service012505[.]website/\nhttp://test-service012505[.]xyz/\nhttp://test-service01blog2505[.]ru/\nhttp://test-service01club2505[.]ru/\nhttp://test-service01forum2505[.]ru/\nhttp://test-service01info2505[.]ru/\nhttp://test-service01land2505[.]ru/\nhttp://test-service01life2505[.]ru/\nhttp://test-service01plus2505[.]ru/\nhttp://test-service01pro2505[.]ru/\nhttp://test-service01rus2505[.]ru/\nhttp://test-service01shop2505[.]ru/\nhttp://test-service01stroy2505[.]ru/\nhttp://test-service01torg2505[.]ru/\nhttp://toptest-service012505[.]ru/\nhttp://vsetest-service012505[.]ru/\n\n## References\n\n[https://www.cert.pl/en/news/single/dissecting-smoke-loader/](https://www.cert.pl/en/news/single/dissecting-smoke-loader/)\n\n\n-----\n\n[https://research.checkpoint.com/2019/2019 resurgence of smokeloader/](https://research.checkpoint.com/2019/2019-resurgence-of-smokeloader/)\n\n[https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb](https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb)\n\n[https://www.aldeid.com/wiki/PEB-Process-Environment-Block](https://www.aldeid.com/wiki/PEB-Process-Environment-Block)\n\n[http://www.hexacorn.com/blog/2017/10/26/propagate-a-new-code-injection-trick](http://www.hexacorn.com/blog/2017/10/26/propagate-a-new-code-injection-trick)\n\n[https://modexp.wordpress.com/2018/08/23/process-injection-propagate/](https://modexp.wordpress.com/2018/08/23/process-injection-propagate/)\n\n[https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpconnect#examples](https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpconnect#examples)\n\n[https://www.crowdstrike.com/blog/maze-ransomware-deobfuscation/](https://www.crowdstrike.com/blog/maze-ransomware-deobfuscation/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-21 - Deep Analysis of SmokeLoader.pdf"
    ],
    "report_names": [
        "2020-06-21 - Deep Analysis of SmokeLoader.pdf"
    ],
    "threat_actors": [
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535731,
    "ts_updated_at": 1743041144,
    "ts_creation_date": 1653697615,
    "ts_modification_date": 1653697615,
    "files": {
        "pdf": "https://archive.orkl.eu/8bb4a93c734cb4e68a88e1873de24a00146fc2e8.pdf",
        "text": "https://archive.orkl.eu/8bb4a93c734cb4e68a88e1873de24a00146fc2e8.txt",
        "img": "https://archive.orkl.eu/8bb4a93c734cb4e68a88e1873de24a00146fc2e8.jpg"
    }
}