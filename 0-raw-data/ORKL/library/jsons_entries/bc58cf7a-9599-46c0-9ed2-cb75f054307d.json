{
    "id": "bc58cf7a-9599-46c0-9ed2-cb75f054307d",
    "created_at": "2023-01-12T15:06:50.923492Z",
    "updated_at": "2025-03-27T02:09:07.999753Z",
    "deleted_at": null,
    "sha1_hash": "ef1a1866916d19c941f558a4426fdc1d3f56a30a",
    "title": "2022-05-19 - Rise in XorDdos- A deeper look at the stealthy DDoS malware targeting Linux devices",
    "authors": "",
    "file_creation_date": "2022-05-28T23:26:13Z",
    "file_modification_date": "2022-05-28T23:26:13Z",
    "file_size": 1826686,
    "plain_text": "# Rise in XorDdos: A deeper look at the stealthy DDoS malware targeting Linux devices\n\n**[microsoft.com/security/blog/2022/05/19/rise-in-xorddos-a-deeper-look-at-the-stealthy-ddos-malware-targeting-linux-devices/](https://www.microsoft.com/security/blog/2022/05/19/rise-in-xorddos-a-deeper-look-at-the-stealthy-ddos-malware-targeting-linux-devices/)**\n\nMay 19, 2022\n\nIn the last six months, we observed a 254% increase in activity from a Linux trojan called XorDdos. First discovered in 2014 by the\nresearch group MalwareMustDie, XorDdos was named after its denial-of-service-related activities on Linux endpoints and servers\nas well as its usage of XOR-based encryption for its communications.\n\nXorDdos depicts the trend of malware increasingly targeting Linux-based operating systems, which are commonly deployed on\ncloud infrastructures and Internet of Things (IoT) devices. By compromising IoT and other internet-connected devices, XorDdos\namasses botnets that can be used to carry out distributed denial-of-service (DDoS) attacks. Using a botnet to perform DDoS\n[attacks can potentially create significant disruptions, such as the 2.4 Tbps DDoS attack Microsoft mitigated in August 2021. DDoS](https://azure.microsoft.com/blog/business-as-usual-for-azure-customers-despite-24-tbps-ddos-attack/?ranMID=24542&ranEAID=TnL5HPStwNw&ranSiteID=TnL5HPStwNw-QrFhTcj5NHbS49DwTEAxiA&epi=TnL5HPStwNw-QrFhTcj5NHbS49DwTEAxiA&irgwc=1&OCID=AID2200057_aff_7593_1243925&tduid=%28ir__f1adpj9cvckf62kijydwmqedqu2xtltt90ejoqbv00%29%287593%29%281243925%29%28TnL5HPStwNw-QrFhTcj5NHbS49DwTEAxiA%29%28%29&irclickid=_f1adpj9cvckf62kijydwmqedqu2xtltt90ejoqbv00)\nattacks in and of themselves can be highly problematic for numerous reasons, but such attacks can also be used as cover to hide\nfurther malicious activities, like deploying malware and infiltrating target systems.\n\nBotnets can also be used to compromise other devices, and XorDdos is known for using Secure Shell (SSH) brute force attacks to\ngain remote control on target devices. SSH is one of the most common protocols in IT infrastructures and enables encrypted\ncommunications over insecure networks for remote system administration purposes, making it an attractive vector for attackers.\nOnce XorDdos identifies valid SSH credentials, it uses root privileges to run a script that downloads and installs XorDdos on the\ntarget device.\n\nXorDdos uses evasion and persistence mechanisms that allow its operations to remain robust and stealthy. Its evasion capabilities\ninclude obfuscating the malware’s activities, evading rule-based detection mechanisms and hash-based malicious file lookup, as\nwell as using anti-forensic techniques to break process tree-based analysis. We observed in recent campaigns that XorDdos hides\nmalicious activities from analysis by overwriting sensitive files with a null byte. It also includes various persistence mechanisms to\nsupport different Linux distributions.\n\n\n-----\n\nFigure 1. A typical attack vector for XorDdos malware\nXorDdos may further illustrate another trend observed in various platforms, in which malware is used to deliver other dangerous\nthreats. We found that devices first infected with XorDdos were later infected with additional malware such as the Tsunami\nbackdoor, which further deploys the XMRig coin miner. While we did not observe XorDdos directly installing and distributing\nsecondary payloads like Tsunami, it’s possible that the trojan is leveraged as a vector for follow-on activities.\n\n[Microsoft Defender for Endpoint protects against XorDdos by detecting and remediating the trojan’s multi-stage, modular attacks](https://www.microsoft.com/security/business/threat-protection/endpoint-defender?rtc=1)\nthroughout its entire attack chain and any potential follow-on activities on endpoints. In this blog post, we detail our in-depth\nanalysis of XorDdos to help defenders understand its techniques and protect their networks from this stealthy malware.\n\nThis blog post covers the following topics:\n\n## Initial access\n\nXorDdos propagates primarily via SSH brute force. It uses a malicious shell script to try various root credential combinations across\nthousands of servers until finding a match on a target Linux device. As a result, we see many failed sign-in attempts on devices\nsuccessfully infected by the malware:\n\nFigure 2. Failed\n\nsign-in attempts on a device affected by XorDdos\n\n\n-----\n\nOur analysis determined two of XorDdos methods for initial access. The first method involves copying a malicious ELF file to\ntemporary file storage /dev/shm and then running it. Files written at /dev/shm are deleted during system restart, thus concealing the\nsource of infection during forensic analysis.\n\nThe second method involves running a bash script that performs the following activities via the command line:\n\n1. Iterates the following folders to find a writable directory:\n\n/bin\n/home\n/root\n/tmp\n/usr\n/etc\n2. If a writable directory is found, changes the working directory to the discovered writable directory.\n3. Uses the curl command to download the ELF file payload from the remote location\n\n_hxxp://Ipv4PII_777789ffaa5b68638cdaea8ecfa10b24b326ed7d/1[.]txt and saves the file as ygljglkjgfg0._\n4. Changes the file mode to “executable”.\n5. Runs the ELF file payload.\n6. Moves and renames the Wget binary to evade rule-based detections triggered by malicious usage of the Wget binary. In this\n\ncase, it renames the Wget binary to good and moves the file to the following locations:\n\n_mv /usr/bin/wget /usr/bin/good_\n_mv /bin/wget /bin/good_\n7. Attempts to download the ELF file payload for a second time, now only using the file good and not the Wget binary.\n8. After running the ELF file, uses an anti-forensic technique that hides its past activity by overwriting the content of the following\n\nsensitive files with a newline character:\n\n**Sensitive File** **Description**\n\n/root/.bash_history Contains the commands that were run earlier\n\n/var/log/wtmp Contains login related record for users\n\n/var/log/btmp Contains record of failed login attempt\n\n/var/log/lastlog Contains the recent login information for users\n\n/var/log/secure Contains information related to security such as logs for authentication failure, sudo logins, and authorization\nprivileges\n\n/var/log/boot.log Contains information related to system boot and message logged via system startup processes\n\n/var/log/cron Contains information related to cron job launch, success and failure error logs\n\n/var/log/dmesg Contains information related to kernel ring buffer messages, hardware devices, drivers, etc.\n\n/var/log/firewalld Contains logs related to firewall activities\n\n/var/log/maillog Contains information related to a mail server running on the system\n\n/var/log/messages Contains generic system activity messages\n\n/var/log/spooler Contains messages from usenet\n\n/var/log/syslog Contains generic system activity messages\n\n/var/log/yum.log Contains the package logs related to installation\\remove\\update activities done via yum utility\n\n\n-----\n\nFigure 3. Remote\n\nbash script command used for initial access\nWhichever initial access method is used, the result is the same: the running of a malicious ELF file, which is the XorDdos malware.\nIn the next section, we do a deep dive into the XorDdos payload.\n\n## XorDdos payload analysis\n\nThe XorDdos payload we analyzed for this research is a 32-bit ELF file that was not stripped, meaning it contained debug symbols\nthat detailed the malware’s dedicated code for each of its activities. The inclusion of debug symbols makes it easier to debug and\nreverse engineer non-stripped binaries, as compared to stripped binaries that discard these symbols. In this case, the non-stripped\nbinary includes the following source-code file names associated with the symbol table entries as part of the .strtab section in the\nELF file:\n\ncrtstuff.c\nautorun.c\ncrc32.c\nencrypt.c\nexecpacket.c\nbuildnet.c\nhide.c\nhttp.c\nkill.c\n\n\n-----\n\nmain.c\nproc.c\nsocket.c\ntcp.c\nthread.c\nfindip.c\ndns.c\n\nThe above list of source-code file names indicate that the binary is programmed in C/C++ and that its code is modular.\n\n### Detection evasion capabilities\n\nXorDdos contains modules with specific functionalities to evade detection, as detailed below.\n\n**Daemon processes**\n\nA daemon process is a process that runs in the background rather than under the control of users and detaches itself from the\ncontrolling terminal, terminating only when the system is shut down. Similar to some Linux malware families, the XorDdos trojan\nuses daemon processes, as detailed below, to break process tree-based analysis:\n\n1. The malware calls the subroutine daemon(__nochdir, __noclose) to set itself as a background daemon process, which\n\ninternally calls fork() and setsid(). The fork() API creates a new child process with the same process group-id as the calling\nprocess.\n2. After the successful call to the fork() API, the parent stops itself by returning “EXIT_SUCCESS (0)”. The purpose is to ensure\n\nthat the child process is not a group process leader, which is a prerequisite for the setsid() API call to be successful. It then\ncalls setsid() to detach itself from the controlling terminal.\n3. The daemon subroutine also has a provision to change the directory to the root directory (“/“) if the first parameter __nochdir is\n\ncalled with a value equal to “0”. One reason for the daemon process to change the directory to the root partition (“/“)is\nbecause running the process from the mounted file system prevents unmounting unless the process is stopped.\n4. It passes the second parameter __noclose as “0” to redirect standard input, standard output, and standard error to /dev/null. It\n\ndoes this by calling dup2 on the file descriptor for /dev/null.\n5. The malware calls multiple signal APIs to ignore a possible signal from the controlling terminal and detach the current process\n\nfrom the standard stream and HangUp signals (SIGHUP) when the terminal session is disconnected. Performing this evasive\nsignal suppression helps stop the effects of standard libraries trying to write to standard output or standard error, or trying to\nread from standard input, which could stop the malware’s child process. The API signal() sets the disposition of the signal\nsignum to the handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined signal handler. In this\ncase, the second parameter is set to “SIG_IGN=1”, which ignores the signal corresponding to signum.\n\nFigure 4. Ignore\n\nsignals associated with the terminal-related operations\n**XOR-based encryption**\n\nAs its name suggests, XorDdos uses XOR-based encryption to obfuscate data. It calls the dec_conf function to decode encoded\nstrings using the XOR key “BB2FA36AAA9541F0”. The table below shows the decoded values of the obfuscated data used across\nthe malware’s various modules to conduct its activities.\n\n**Encrypted strings** **Decoded value**\n\nm7A4nQ_/nA /usr/bin/\n\nm [(n3 /bin/\n\n\n-----\n\nm6_6n3 /tmp/\n\nm4S4nAC/n&ZV\\x1aA/TB /var/run/gcc.pid\n\nm.[$n__#4%\\C\\x1aB]0 /lib/libudev.so\n\nm.[$n3 /lib/\n\nm4S4nAC/nA /var/run/\n\n!#Ff3VE.-7\\x17V[_ cat resolv.conf\n\n<Encrypted_Remote_URL> hxxp://aa.hostasa[.]org/config.rar\n\n**Process name spoofing**\n\nWhen a process is launched, arguments are provided to its main function as null-terminated strings, where the first argument is\nalways the process image path. To spoof its process name, XorDdos zeroes out all argument buffers while running and overrides its\nfirst argument buffer containing the image path with a fake command line, such as cat resolv.conf.\n\nFigure 5. Process\n\nname spoofing achieved by modifying memory associated with argument vectors.\n\nFigure 6. Output\n\nof the ‘ps -aef’ contains an entry for “cat resolv.conf”\n**Kernel rootkit**\n\nSome XorDdos samples install a kernel rootkit. A rootkit is a kernel module that hides the presence of malicious code by modifying\noperating systems data structures. The XorDdos kernel rootkit generally has following capabilities:\n\nProvide root access\nHide the kernel module\nHide the malware’s processes\n\n\n-----\n\nHide the malware s network connections and ports\n\nBased on the debug symbols found in the rootkit, it’s likely that XorDdos’ rootkit code was inspired by an open-source project\n[called rooty. The following table describes the symbols found in the rootkit and their corresponding functionalities:](https://github.com/jermeyyy/rooty)\n\n**Function name** **Description**\n\ngive_root Provides a root privilege by setting a new set of credentials and assigning its UID, GID to “0”\n\nmodule_hide Hides the rootkit kernel module\n\nmodule_show Unhides the rootkit kernel module\n\nget_udp_seq_show Hides the UDP4 connection by hooking /proc/net/udpHides the UDP6 connection by\nhooking /proc/net/udp6\n\nget_tcp_seq_show Hides the TCP4 connection by hooking /proc/net/tcpHides the TCP6 connection by hooking /proc/net/tcp6\n\nhide_udp4_port Adds a provided port to a list of hidden UDP4 ports\n\nunhide_udp4_port Deletes a provided port from a list of hidden UDP4 ports\n\nhide_udp6_port Adds a provided port to a list of hidden UDP6 ports\n\nunhide_udp6_port Deletes a provided port from a list of hidden UDP6 ports\n\nhide_tcp4_port Adds a provided port to a list of hidden TCP4 ports\n\nunhide_tcp4_port Deletes a provided port from a list of hidden TCP4 ports\n\nhide_tcp6_port Adds a provided port to a list of hidden TCP6 ports\n\nunhide_tcp6_port Deletes a provided port from a list of hidden TCP6 ports\n\nunhide_allz Iterates list of all hidden ports and deletes all entries\n\n**Process and port hiding**\n\nThe malware tries to hide its processes and ports using its kernel rootkit component. Hiding a process assists the malware in\nevading rule-based detections.\n\nThe /proc filesystem contains information related to all running processes. A user-mode process can get any process specific\ninformation by reading the /proc directory that contains the subdirectory for each running process on the system, such as:\n\n_/proc/7728 – Contains process-id (PID) 7728-related information_\n_/proc/698 – Contains PID 698-related information_\n\nRunning the strace -e open ps command checks the traces of the open call on /proc/$pid to fetch information on running processes\nas part of the ps command.\n```\n> strace -e open ps\nopen(“/proc/3922/status”, O_RDONLY)   = 6\nopen(“/proc/4324/stat”, O_RDONLY)    = 6\nopen(“/proc/4324/status”, O_RDONLY)   = 6\nopen(“/proc/5559/stat”, O_RDONLY)    = 6\nopen(“/proc/5559/status”, O_RDONLY)   = 6\nopen(“/proc/5960/stat”, O_RDONLY)    = 6\nopen(“/proc/5960/status”, O_RDONLY)   = 6\nopen(“/proc/5978/stat”, O_RDONLY)    = 6\nopen(“/proc/5978/status”, O_RDONLY)   = 6\n\n```\nIf the malware hides the $pid specific directory, it can conceal fetching the corresponding process from a user mode.\n\nIn this case, the malware has a provision for communicating with its rootkit component /proc/rs_dev by sending input and output\ncontrol (IOCTL) calls with additional information to take appropriate action. IOCTL is one way to communicate between the usermode service and kernel device driver. The malware uses the number “0x9748712” to uniquely identify its IOCTL calls from other\nIOCTL calls in the system.\n\nAlong with this number, it also passes an integer array. The first entry in the array corresponds to the command, and the second\nentry stores the value to act on such as $pid\n\n\n-----\n\n**Command** **Usage**\n\n0 Check if its rootkit driver is present\n\n1, 2 Hide or unhide <PID>\n\n3 Hide <port>\n\n### Persistence mechanisms\n\nXorDdos uses various persistence mechanisms to support different Linux distributions when automatically launching upon system\nstartup, as detailed below.\n\n**Init script**\n\nThe malware drops an init script at the location /etc/init.d. Init scripts are startup scripts used to run any program when the system\nstarts up. They follow the Linux Standard Base (LSB)-style header section to include default runlevels, descriptions, and\ndependencies.\n\nFigure 7. Content\n\nof the init script dropped at the location /etc/init.d/HFLgGwYfSC.elf\n**Cron script**\n\nThe malware creates a cron script at the location /etc/cron.hourly/gcc.sh.The cron script passes parameters with the following\ncontent:\n\nFigure 8. Content\n\nof the gcc.sh script\nIt then creates a /etc/crontab file to run /etc/cron.hourly/gcc.sh every three minutes:\n\nFigure 9. System\n\ncommand to delete the /etc/cron.hourly/gcc.sh entry from the /etc/crontab file and add a new entry\n\n\n-----\n\nFigure 10. The\n\ncontent of the file /etc/crontab\n**System V runlevel**\n\nA runlevel is a mode of init and the system that specifies what system services are operating for Unix System V-Style operating\nsystems. Runlevels contain a value, typically numbered zero through six, which each designate a different system configuration and\nallows access to a different combination of processes. Some system administrators set a system’s default runlevel according to\ntheir needs or use runlevels to identify which subsystems are working, such as whether the network is operational. The\n_/etc/rc<run_level> directory contains symbolic links (symlinks), which are soft links that point to the original file. These symlinks_\npoint to the scripts that should run at the specified runlevel.\n\nThe malware creates a symlink for the init script dropped at the location /etc/init.d/<base_file_name> with the directories associated\nwith runlevels 1 through 5 at /etc/rc<run_level>.d/S90<base_file_name> and /etc/rc.d/rc<run_level>.d/S90<base_file_name>.\n\nFigure 11.\n\nInstallation of rc.d directory’s symlink scripts with /etc/init.d/<base_file_name>\n**Auto-start services**\n\nThe malware runs a command to install startup services that automatically run XorDdos at boot. The malware’s LinuxExec_Argv2\nsubroutine runs the system API with the provided arguments.\n\nThe commands chkconfig –add <service_name> and update-rc.d then add a service that starts the daemon process at boot.\n\nFigure 12.\n\n_chkconfig and update-rc.d commands install the startup service_\n\n### Argument-based code-flow\n\nXorDdos has specific code paths corresponding to the number of arguments provided to the program. This flexibility makes its\noperation more robust and stealthy. The malware first runs without any argument and then later runs another instance with different\narguments, such as PIDs and fake commands, to perform capabilities like clean-up, spoofing, and persistence.\n\nBefore handling the argument-based control, it calls the readlink API with the first parameter as /proc/self/exe to fetch its full\nprocess path. The full path is used later to create auto-start service entries and read the file’s content.\n\nIn this section, we will cover the main tasks carried out as part of the different arguments provided:\n\n**1: Standard code path without any provided arguments**\n\nThis code path depicts the malware’s standard workflow, which is also the typical workflow where XorDdos runs as part of the\nentries created in system start-up locations.\n\nThe malware first checks whether it’s running from the locations /usr/bin/, /bin/, or /tmp/. If it’s not running from these locations, then\nit creates and copies itself using a 10-character string name on those locations, as well as /lib/ and /var/run/.\n\n\n-----\n\nIt also creates a copy of itself at the location /lib/libudev.so. To evade hash based malicious file lookup, it performs the following\nsteps, which modify the file hash to make every file unique:\n\nOpens the file for writing only\nCalls lseek (fd, 0, SEEK_END) to point at the last position in the file\nCreates a random 10-character string\nWrites the string at the end of the file with an additional null byte\n\nAfter modifying the file, it runs the binary, performs a double fork(), and deletes its file from the disk.\n\nFigure 13. The\n\nend of the malware file contains two random strings, ‘wieegnexuk’ and ‘yybrdajydg,’ indicating that the original malware binary was\nmodified twice\n**2: Clean-up code path**\n\nIn this code path, the malware runs with another argument provided as the PID, for example:\n\n_/usr/bin/jwvwvxoupv 4849_\n\nUsing the above example, the malware shares the 64-byte size memory segment with the IPC key “0xDA718716” to check for\nanother malware process provided as an argument. If not found, it runs its own binary without any argument and calls the fork() API\ntwice to make sure the grandchild process has no parent. This results in the grandchild process being adopted by the init process,\nwhich disconnects it from the process tree and acts as an anti-forensic technique.\n\nAdditionally, it performs the following tasks on a provided $pid:\n\nFetches the process file name corresponding to the provided $pid\nDeletes the file for the provided $pid\nDeletes the installed init services:\n\nDeletes /etc/init.d/<file_name>\nFor runlevels 1-5, unlinks and deletes /etc/rc<runlevel>.d/S90<file_name>\nPerforms the command chkconfig –del <file_name>\nPerforms the command update-rc.d <file_name> remove\nEnds the process that was provided as an argument.\n\n**3: Process name spoofing code path**\n\nThe malware spawns new dropped binaries with two additional arguments: a fake command line and its PIDs, for example:\n\n_/usr/bin/jwvwvxoupv “cat resolv.conf” 4849_\n_/usr/bin/jwvwvxoupv gnome-terminal 4849_\n_/usr/bin/jwvwvxoupv top 4849_\n_/usr/bin/jwvwvxoupv pwd 4849_\n_/usr/bin/kagbjahdic id 4849_\n\nThe fake commands can include:\n\n_cat resolv.conf_\n_netstat -an_\n_bash_\n_whoami_\n_id_\n_cd /etc_\n_ifconfig eth0_\n_ifconfig_\n_echo “find”_\n\n\n-----\n\n_uptime_\n_sh_\n_top_\n_gnome-terminal_\n_su_\n_netstat -antop_\n_grep “A”_\n_who_\n_ls -la_\n_pwd_\n_route -n_\n_ps -ef_\n_ls_\n_sleep 1_\n\nIn this code path, the malware uses process name spoofing to hide from the process tree by modifying its fake command line at\nruntime. It then hides its process by calling HidePidPort with command “1” and reads the content of the file on disk related to the\ncurrent process.\n\nIt then enters a five-second loop to perform the following checks:\n\nFetches the file name specific to the $pid provided as part of the third argument by calling the readlink API on /proc/$pid/exe.\nIf the readlink call fails, that likely indicates that the file on disk doesn’t exist. In this case, it:\n\nIntends to delete all service-related entries for the $pid but fails. This appears to be due to a code flaw that allows a\nzeroed-out buffer to be passed as a service name when the buffer is supposed to be filled from a successful readlink\nAPI call.\nCreates directories similar to the standard code path scenario.\nCalls the stat API for the file /lib/libudev.so. If the stat API returns a non-zero value, then it attempts to copy the content\nof the current process’s image-file fetched earlier to the following locations with a random name:\n\n_/usr/bin/_\n_/bin/_\n_/tmp/_\nCopies the /lib/libudev.so file to the same three directories listed above if the stat API call is successful on /lib/libudev.so.\nChanges the hash of the written or copied file and then runs it without passing any parameters.\nIf the readlink call is successful and returns the count of bytes copied, sleeps for one second and then loops for the remaining\ntime out of five seconds.\nUnhides the current process and the $pid that was provided as part of the third argument.\nDeletes the on-disk file for the current process.\n\n**4: Known locations code path without any provided arguments**\n\nThis code path is similar to the standard code path, with the main difference being that the malware runs from one of the following\nlocations:\n\n_/usr/bin/_\n_/bin/_\n_/tmp/_\n\nOnce it runs from one of these locations, the malware calls the following functions to perform various tasks:\n\n1. InstallSYS– The name suggests that this function is a wrapper that should deploy a rootkit driver, but it only zeroes-out two\n\nlocal arrays.\n\n\n-----\n\nFigure 14. Dummy\n\n_InstallSYS routine_\n\n1. AddService – Creates the persistent auto-start entries previously mentioned so that the malware runs when the system starts.\n2. HidePidPort – Hides the malware’s ports and processes.\n3. CheckLKM – Checks whether the rootkit device is active or not. It uses a similar IOCTL call with the number “0x9748712” and\n\ncommand “0” to find if the rootkit is active. If the rootkit is active, it uses the owner value “0xAD1473B8” and group value\n“0xAD1473B8” to change the ownership of dropped files with the function lchown(<filename>, 0xAD1473B8, 0xAD1473B8).\n4. decrypt_remotestr– Decodes remote URLs using the same XOR key, “BB2FA36AAA9541F0”, to decode config.rar and the\n\nother directories. After decoding the URLs, it adds them into a remote list, which is later used to communicate and fetch\ncommands from the command and control (C2) server:\n\nwww[.]enoan2107[.]com:3306\nwww[.]gzcfr5axf6[.]com:3306\n\n### Malicious activity threads\n\nAfter creating persistent entries, deleting evidence of its activities, and decoding config.rar, the malware initializes a\ncyclic redundancy check (CRC) table followed by an unnamed semaphore using the sem_init API. This semaphore is initialized with\napshared value set to “0”, making the resultant semaphore shared between all the threads. The semaphore is used to maintain\nconcurrency between threads accessing a shared object, such as kill_cfg data.\n\nThe malware then initializes three threads to perform malicious activities, such as stopping a process, creating a TCP connection,\nand retrieving kill_cfg data.\n\nFigure 15.\n\nSemaphore and malicious thread initialization\n**_kill_process_**\n\nThe kill_process thread performs the following tasks:\n\nDecodes encrypted strings\nFetches file stats for /var/run/gcc.pid or, if none exist, then creates the file\nFetches file stats for /lib/libudev.so or, if none exist, then creates the directory /lib and creates a copy of itself at the location\n_/lib/libudev.so_\nFetches the on disk file information associated with the current process; if it fails, then exits the loop and stops the current\nprocess\nReads the content from kill_cfg and performs the corresponding actions, like stopping the process or deleting files, based on\nthe matching specified keys in the configuration file, such as:\n\n_md5=_\n_filename=_\n_rmfile=_\n_denyip=_\n\n**_tcp_thread_**\n\n\n-----\n\nThe tcp_thread triggers the connection with the C2 server decoded earlier using decrypt_remotestr(). It performs the following\ntasks:\n\nReads the content of the file /var/run/gcc.pid to get a unique 32-byte magic string that identifies the device while connecting\nwith the C2 server; if the file doesn’t exist, then it creates the file and updates it with a random 32-byte string.\nCalculates the CRC header, including details of the device such as the magic string, OS release version, malware version,\nrootkit presence, memory stats, CPU information, and LAN speed.\nEncrypts the data and sends it to the C2 server.\nWaits to receive any of the following commands from the C2 server and then acts on the command using the exec_packet\nsubroutine.\n\n**Command** **Job**\n\n2 Stop\n\n3 Create a thread pool for launching DDoS attacks\n\n6 Download file\n\n7 Update file\n\n8 Send system information to the C2 server\n\n9 Get configuration file to stop processes\n\nFigure 16.\n\nCollection of system information\n**_daemon_get_killed_process_**\n\nThe daemon_get_killed_processthread downloads the kill_cfg data from the remote URL decoded earlier\n(hxxp://aa[.]hostasa[.]org/config[.]rar) and decrypts it using the same XOR key previously mentioned. It then sleeps for 30 minutes.\n\n\n-----\n\nFigure 17.\n\n_daemon_get_killed_process thread function fetches and decodes the kill_cfg data from the remote URL_\n\n### DDoS attack thread pool\n\nThe malware calls sysconf(_SC_NPROCESSORS_CONF) to fetch the number of processors in the device. It then creates threads\nwith twice the number of processors found on the device.\n\nInvoking each thread internally calls the thread routine threadwork. Using the global variable “g_stop” and commands received from\nthe C2 server, threadwork then sends crafted packets 65,535 times to perform a DDoS attack.\n\n**Command** **Function** **Job**\n\n0x4 fix_syn SYN flood attack\n\n0x5 fix_dns DNS attack\n\n0xA fix_ack ACK flood attack\n\n## Defending against Linux platform threats\n\nXorDdos’ modular nature provides attackers with a versatile trojan capable of infecting a variety of Linux system architectures. Its\nSSH brute force attacks are a relatively simple yet effective technique for gaining root access over a number of potential targets.\n\nAdept at stealing sensitive data, installing a rootkit device, using various evasion and persistence mechanisms, and performing\nDDoS attacks, XorDdos enables adversaries to create potentially significant disruptions on target systems. Moreover, XorDdos may\nbe used to bring in other dangerous threats or to provide a vector for follow-on activities.\n\nXorDdos and other threats targeting Linux devices emphasize how crucial it is to have security solutions with comprehensive\n[capabilities and complete visibility spanning numerous distributions of Linux operating systems. Microsoft Defender for Endpoint](https://www.microsoft.com/security/business/threat-protection/endpoint-defender?rtc=1)\n[offers such visibility and protection to catch these emerging threats with its next-generation antimalware and](https://docs.microsoft.com/microsoft-365/security/defender-endpoint/next-generation-protection?view=o365-worldwide) endpoint detection and\nresponse (EDR) capabilities. Leveraging threat intelligence from integrated threat data, including client and cloud heuristics,\nmachine learning models, memory scanning, and behavioral monitoring, Microsoft Defender for Endpoint can detect and remediate\nXorDdos and its multi-stage, modular attacks. This includes detecting and protecting against its use of a malicious shell script for\ninitial access, its drop-and-execution of binaries from a world-writable location, and any potential follow-on activities on endpoints.\n\nDefenders can apply the following mitigations to reduce the impact of this threat:\n\n[Encourage the use of Microsoft Edge—available on Linux and various platforms—or other web browsers that](https://www.microsoft.com/edge)\n[support Microsoft Defender SmartScreen, which identifies and blocks malicious websites, including phishing sites, scam sites,](https://docs.microsoft.com/deployedge/microsoft-edge-security-smartscreen)\nand sites that contain exploits and host malware.\nUse [device discovery to find unmanaged Linux devices on your network and onboard them to Microsoft Defender for](https://docs.microsoft.com/microsoft-365/security/defender-endpoint/device-discovery?view=o365-worldwide)\nEndpoint.\nTurn on [cloud-delivered protection in Microsoft Defender Antivirus or the equivalent for your antivirus product to use cloud-](https://docs.microsoft.com/microsoft-365/security/defender-endpoint/configure-block-at-first-sight-microsoft-defender-antivirus?view=o365-worldwide)\nbased machine learning protections that can block a huge majority of new and unknown variants.\n[Run EDR in block mode so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft](https://docs.microsoft.com/microsoft-365/security/defender-endpoint/edr-in-block-mode?view=o365-worldwide)\nantivirus doesn’t detect the threat or when Microsoft Defender Antivirus is running in passive mode.\n\n\n-----\n\n[Enable network protection to prevent applications or users from accessing malicious domains and other malicious content on](https://docs.microsoft.com/microsoft-365/security/defender-endpoint/enable-network-protection?view=o365-worldwide)\nthe internet.\n[Enable investigation and remediation in full automated mode to allow Microsoft Defender for Endpoint to take immediate](https://docs.microsoft.com/microsoft-365/security/defender-endpoint/automated-investigations?view=o365-worldwide)\naction on alerts to resolve breaches, significantly reducing alert volume.\n\nAs threats across all platforms continue to grow in number and sophistication, security solutions must be capable of providing\nadvanced protection on a wide range of devices, regardless of the operating system in use. Organizations will continue to face\nthreats from a variety of entry points across devices, so Microsoft continues to heavily invest in protecting all the major platforms\nand providing extensive capabilities that organizations needed to protect their networks and systems.\n\n### Detection details\n\nMicrosoft Defender for Endpoint detects and blocks XorDdos components and behavior as the following malware:\n\nDoS:Linux/Xorddos.A\nDoS:Linux/Xorddos!rfn\nTrojan:Linux/Xorddos\nTrojan:Linux/Xorddos.AA\nTrojan:Linux/Xorddos!rfn\nBehavior:Linux/Xorddos.A\n\nWhen XorDdos is detected on a device, Microsoft 365 Defender raises an alert, which shows the complete attack chain, including\nthe process tree, file information, user information, and prevention details.\n\nFigure 18.\n\nMicrosoft 365 Defender alert for detection of XorDdos malware\n\n\n-----\n\nThe timeline view displays all of the detection and prevention events associated with XorDdos, providing details such as the MITRE\nATT&CK techniques and tactics, remediation status, and event entities graph.\n\nFigure 19.\n\nMicrosoft 365 Defender timeline displaying that HFLgGwYfSC.elf was run from a world-writable directory and the remediation of\ndropped binaries\nEvents with the following titles indicate threat activity related to XorDdos:\n\nThe content of libudev.so was collected into libudev.so.6\nbash process performed System Information Discovery by invoking ifconfig\ngcc.sh was executed after being dropped by HFLgGwYfSC.elf\nA shell command was executed by crond\nSUID/SGID process unix_chkpwd executed\n\nFigure 20.\n\nMicrosoft 365 Defender timeline with an event on a suspicious shell command run by crond after it was dropped from\n_HFLgGwYfSC.elf_\n\n### Hunting queries\n\nTo locate malicious activity related to XorDdos activity, run the following advanced hunting queries in Microsoft 365 Defender or\nMicrosoft Defender Security Center:\n\n**Failed sign-ins**\n```\nDeviceLogonEvents\n| where InitiatingProcessFileName == \"sshd\"\n  and ActionType == \"LogonFailed\"\n| summarize count() by dayOfYear = datetime_part(\"dayOfYear\", Timestamp)\n| sort by dayOfYear \n| render linechart\n\n```\n**Creation of the XorDdos-specific dropped files**\n```\nDeviceFileEvents\n| extend FullPath=strcat(FolderPath, FileName)\n| where FullPath in (\"/etc/cron.hourly/gcc.sh\", \"/lib/libudev.so.6\", \"/lib/libudev.so\", \"/var/run/gcc.pid\")\n\n```\n**Command-line of malicious process**\n```\nDeviceProcessEvents\n| where ProcessCommandLine contains \"cat resolv.conf\"\n\n## Indicators\n\n```\n\n-----\n\n### File information\n\nFile name: HFLgGwYfSC.elf\n\nFile size: 611.22 KB (625889 bytes)\n\nClassification: DoS:Linux/Xorddos.A\n\nMD5: 2DC6225A9D104A950FB33A74DA262B93\n\nSha1: F05194FB2B3978611B99CFBF5E5F1DD44CD5E04B\n\nSha256: F2DF54EB827F3C733D481EBB167A5BC77C5AE39A6BDA7F340BB23B24DC9A4432\n\nFile type: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, for GNU/Linux 2.6.9, not\nstripped\n\n\nFirst submission in\nVT:\n\n### Dropped files\n\n\n2022-01-25 05:32:10 UTC\n\n\n**Dropped file path** **File type** **SHA-256**\n\n/etc/init.d/HFLgGwYfSC.elf Shell Script 6E506F32C6FB7B5D342D1382989AB191C6F21C2D311251D8F623814F468952CF\n\n/etc/cron.hourly/gcc.sh Shell Script CBB72E542E8F19240130FC9381C2351730D437D42926C6E68E056907C8456459\n\n/lib/libudev.so ELF F2DF54EB827F3C733D481EBB167A5BC77C5AE39A6BDA7F340BB23B24DC9A4432\n\n/run/gcc.pid Text 932FEEF3AB6FCCB3502F900619B1F87E1CB44A7ADAB48F2C927ECDD67FF6830A\n\n/usr/bin/djtctpzfdq ELF 53F062A93CF19AEAA2F8481B32118A31B658A126624ABB8A7D82237884F0A394\n\n/usr/bin/dmpyuitfoq ELF 798577202477C0C233D4AF51C4D8FB2F574DDB3C9D1D90325D359A84CB1BD51C\n\n/usr/bin/fdinprytpq ELF 2B4500987D50A24BA5C118F506F2507362D6B5C63C80B1984B4AE86641779FF3\n\n/usr/bin/jwvwvxoupv ELF 359C41DA1CBAE573D2C99F7DA9EEB03DF135F018F6C660B4E44FBD2B4DDECD39\n\n/usr/bin/kagbjahdic ELF E6C7EEE304DFC29B19012EF6D31848C0B5BB07362691E4E9633C8581F1C2D65B\n\n/usr/bin/kkldnszwvq ELF EF0A4C12D98DC0AD4DB86AADD641389C7219F57F15642ED35B4443DAF3FF8C1E\n\n/usr/bin/kndmhuqmah ELF B5FBA27A8E457C1AB6573C378171F057D151DC615D6A8D339195716FA9AC277A\n\n/usr/bin/qkxqoelrfa ELF D71EA3B98286D39A711B626F687F0D3FC852C3E3A05DE3F51450FB8F7BD2B0D7\n\n/usr/bin/sykhrxsazz ELF 9D6F115F31EE71089CC85B18852974E349C68FAD3276145DAFD0076951F32489\n\n/usr/bin/tcnszvmpqn ELF 360A6258DD66A3BA595A93896D9B55D22406D02E5C02100E5A18382C54E7D5CD\n\n/usr/bin/zalkpggsgh ELF DC2B1CEE161EBE90BE68561755D99E66F454AD80B27CEBE3D4773518AC45CBB7\n\n/usr/bin/zvcarxfquk ELF 175667933088FBEBCB62C8450993422CCC876495299173C646779A9E67501FF4\n\n/tmp/bin/3200 ELF(rootkit) C8F761D3EF7CD16EBE41042A0DAF901C2FDFFCE96C8E9E1FA0D422C6E31332EA\n\n### Download URLs\n\nwww[.]enoan2107[.]com:3306\nwww[.]gzcfr5axf6[.]com:3306\nhxxp://aa[.]hostasa[.]org/config.rar\n\n**_Ratnesh Pandey, Yevgeny Kulakov, and Jonathan Bar Or_**\n\n_Microsoft 365 Defender Research Team_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-05-19 - Rise in XorDdos- A deeper look at the stealthy DDoS malware targeting Linux devices.pdf"
    ],
    "report_names": [
        "2022-05-19 - Rise in XorDdos- A deeper look at the stealthy DDoS malware targeting Linux devices.pdf"
    ],
    "threat_actors": [
        {
            "id": "eb3f4e4d-2573-494d-9739-1be5141cf7b2",
            "created_at": "2022-10-25T16:07:24.471018Z",
            "updated_at": "2025-03-27T02:02:10.24394Z",
            "deleted_at": null,
            "main_name": "Cron",
            "aliases": [],
            "source_name": "ETDA:Cron",
            "tools": [
                "Catelites",
                "Catelites Bot",
                "CronBot",
                "TinyZBot"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536010,
    "ts_updated_at": 1743041347,
    "ts_creation_date": 1653780373,
    "ts_modification_date": 1653780373,
    "files": {
        "pdf": "https://archive.orkl.eu/ef1a1866916d19c941f558a4426fdc1d3f56a30a.pdf",
        "text": "https://archive.orkl.eu/ef1a1866916d19c941f558a4426fdc1d3f56a30a.txt",
        "img": "https://archive.orkl.eu/ef1a1866916d19c941f558a4426fdc1d3f56a30a.jpg"
    }
}