{
    "id": "1c949953-93ed-4b31-9f49-79dc04e98cc7",
    "created_at": "2023-01-12T15:09:47.335879Z",
    "updated_at": "2025-03-27T02:08:41.010423Z",
    "deleted_at": null,
    "sha1_hash": "3e58d16037f24d1fddf7131f01dfb08640f4cbad",
    "title": "2020-04-15 - How Analysing an AgentTesla Could Lead To Attackers Inbox - Part II",
    "authors": "",
    "file_creation_date": "2022-05-28T15:28:26Z",
    "file_modification_date": "2022-05-28T15:28:26Z",
    "file_size": 1160399,
    "plain_text": "# How Analysing an AgentTesla Could Lead To Attackers Inbox - Part II\n\n**[mrt4ntr4.github.io/How-Analysing-an-AgentTesla-Could-Lead-To-Attackers-Inbox-2/](https://mrt4ntr4.github.io/How-Analysing-an-AgentTesla-Could-Lead-To-Attackers-Inbox-2/)**\n\nSuraj Malhotra April 15, 2020\n\n[I hope you’ve read the Part I of this series.](https://mrt4ntr4.github.io/How-Analysing-an-AgentTesla-Gives-Access-To-Attackers-Inbox-1/)\n\nThere we discussed some techniques to do basic analysis, tested the sample on any.run and most importantly the\n“Decrypting Strings” part where we learned how it uses AES encrypted strings to evade some simple detections.\n\nSo Lets get started !!\n\n## Some Tidbits\n\nTo continue with where we left earlier, the next fcn called is tlg() and it copies the malware into the default temporary\nlocation as TMP#{Millisecond}.bin\n\nLater it starts to execute the fcn tkq.tjg in a thread.\n\n\n-----\n\nIt uses tkq.tjg to perform some registry key modifications usually for persistence and execute some system\ncommands.\nIt uses that temporary file it just created as well.\n\n## Stealing Credentials\n\nPS This is the core part of the series and its important to understand.\n\nSo, The next function to notice is kqe which returns a list.\n\nThe first statement gets the path to the AppData/Local.\n\n\n-----\n\nThen the execution is passed to zla.zgh with the location of Chrome concatenated with the AppData location.\n\nIt also concatenates \\Default\\Login Data and \\Login Data and saves those 2 results in a list.\n\nNext it looks whether the Directory User Data exists in the particular location.\n\nIf the directory is present, it iterates over it to find its subdirectories.\n\n\n-----\n\nAnd at last compares if the string Profile is present in any of the items in the directories list.\nBasically It checks if any subdirectory named Profile exists. This could be the case when I would have installed other\nbrowsers such as Firefox, etc.\n\nPS I only have only installed Chrome on my Victim VM and We’ll be only exploring the process of credential stealer in\ncase of Chrome.\n\nFinally It checks for the real Login Data file in both locations User Data\\Default\\, \\User Data\\ (from items of prev list)\nand if it exists it executes fcn. emx.\n\n\n-----\n\nNow vcx contains the content of the Login Data file.\n\nThe emx function is interesting.\n\nTBH I didn’t had any installation of Chrome on my VM but this function looks like it does a strict checking on the\ncontents of the Login Data file and I needed to get a legitimate one.\n\nSo First it wants the 52th byte in the file to be 0.\n\nThen it compares var vjl to 0.\n\nFor vjl we need to analyse eco fcn and I found out it just returns ‘arg2’ no. of bytes starting from ‘arg1’ index from vcx.\n```\n  public emx(string baseName)\n  {\n    this.vja = new byte[]{0,1,2,3,4,6,8,8,0,0};\n    if (File.Exists(baseName))\n    {\n      this.vcx = this.vcl(baseName); // vcx = file contents\n      if (this.vcx[52] != 0)\n      {\n        return;\n      }\n      this.vjo = checked((ushort)this.eco(16, 2)); // 2 chars from\n  vcx[16]\n      this.vjl = this.eco(56, 4);  // 4 chars from vcx[56]\n      if (decimal.Compare(new decimal(this.vjl), 0m) == 0)\n      {\n        this.vjl = 1UL;\n      }\n      this.ejo(100UL);\n    }\n  }\n\n```\n\n-----\n\nIf it succeeds and passes all of the checks, control is passed over to fcn ejo.\nThe ejo fcn is cool as I thought that it would execute sql queries over the Login Data file to get the credentials but\nthere is no need of doing this, we’ll see how :)\nFirst It creates an obj list with 5 elements and has main elements as item_name, item_type,sql_statement. These all\nfields are filled by taking strings from different indexes from the original Login Data file.\n\nAlso I don’t know why but ejo first adds data to the beginning 6 elements of vjb and then another loop adds 11\nelements to it and fills them.\n\n[View whole content of vjb here.](https://mrt4ntr4.github.io/files/MA/sample1/vjb.txt)\n\nNext It searches for vjb[2] element and extracts all the words within parantheses and splits them with ‘,’ as a delimiter\nfrom the sql_statement.\n\n\n-----\n\nThe resulting list looks like the following…\n\nAlso it strips the spaces which we can notice at the beginning now.\n\nNow the resulting list is copied into the vjh array.\n\nAfterwards it iterates over its elements, splits them with “ “ as a delimiter and then only keeps the first element.\n\nThe resulting array looks like the following..\n\n\n-----\n\nNow it initialises another array as vjg and has the structure from emx.emg.\n\nAs you can see below it has a single element with two fields as content & row_id. From this point I can guess that the\ncontent field is what we are looking for.\n\nAlso another variable array is initialised with the structure of emx.ema.\nIts elements have a size & type field.\n\nAnd it fills both of them with some calculations done on obj2 and obj4.\n\n\n-----\n\nAnd it iterates till an element with type > 9 exists in the array.\n\nSome of the elements are as follows..\n\nWe’ll see how is it used now.\n\nAfter this, it initialises the content field of vjg and we can see that it’ll have the same number of elements as of array.\nHmm.. Looks like some operation will be done on array.\n\nAnd Woah.. after some loops we can observe that it was successful in extracting some strings from the sqlite Login\n_Data file._\n\n\n-----\n\nNow lets dig into what happened with the array and what it did behind the scenes.\n\nSo the statement in the above screenshot looks like the following.\n```\n  this.vjg[num8 + num5].content[num13] = Encoding.Default.GetString(\n            this.vcx,\n            Convert.ToInt32(\n                decimal.Add(\n                  decimal.Add(\n                    new decimal(num6), new\n  decimal(num14)),\n                  new decimal(num15))),\n            (int)array[num13].size);\n\n```\nNow at this point we can utilise the Locals window to check the values of some variables including num8, num5,\nnum13, num6, num14, num15.\n\nI made some notes and added a watch over those variables.\n\nAs anybody can tell that num13 is the index of the content field but I noticed that num8, num5, num6, num14 remained\nthe same for every value of num13.\n\nSo its basically accessing data from a particular index which is (num6 + num14 + num15) out of which (num6 +\nnum14) is a constant, for me ie. 6797 so the only index to note is num15.\n\nAlso if you’d observe that array[x].size is what we previously initialised for every item in the array and its basically the\nstring length record.\n```\n  vjg[0].content[0x2] = (this.vcx, 6797 + num15, 0x8) \n  //\"username\" str\n  then num15 = 0x3e\n  vjg[0].content[0x3] = (this.vcx, 6797 + num15, 0xf) //username\n  then num15 = 0x46\n  vjg[0].content[0x4] = (this.vcx, 6797 + num15, 0x8) \n  //\"password\" str\n  num15 = 0x4e\n  vjg[0].content[0x5] = (this.vcx, 6797 + num15, 0x30) //password\n  num15 = 0x74\n  vjg[0].content[0x6] = (this.vcx, 6797 + num15, 0)\n\n```\nAfter the function ends we get to see every item in the locals.\n\n\n-----\n\nAhmm.. we get it on some functions as listed below. Now you know what to do.. Set a Breakpoint on them where they\nuse it this deadly API Call :)\n\nNow everybody knows there is only one way to decrypt that password from Login Data ie [CryptUnprotectData fcn Call.](https://docs.microsoft.com/en-us/windows/win32/api/dpapi/nf-dpapi-cryptunprotectdata)\nSo I searched for any references to where its used..\n\nAnd BoomYa we hit one of them and we can also see our encrypted password in the locals window. Now we can copy\nthe result from this call from this local by simply stepping into it.\n\n\n-----\n\nBut wait thats not it.. Sh*t It has a whole function to decrypt it too to which it has passed the result of unprotected data\nand our original encrypted password.\n\n[This was something new for me coz I’m not use to C# and the decryption function in C looks very different.](https://mrt4ntr4.github.io/files/MA/sample1/crackPass.c)\n\nWhat I can observe from this is that it uses AES_GCM mode but don’t know the use of BCRYPT here. (Maybe It is the\nonly one to include AES GCM Mode) ¯\\_(ツ)_/¯\n\n[And Then fortunately I found some reference which made my task easy.](https://stackoverflow.com/questions/60640302/system-security-cryptography-cryptographicexception-the-parameter-is-incorrect)\n\n[I was finally successful to implement this in python.](https://pycryptodome.readthedocs.io/en/latest/src/cipher/modern.html#gcm-mode)\n```\n  from Cryptodome.Cipher import AES\n  def dec(pwd, unproc_key):\n    auth_tag = pwd[-16:]\n    pwd = pwd.replace(auth_tag,'')\n    nonce, proc_pwd = pwd[3:15], pwd[15:]\n    cipher = AES.new(unproc_key, AES.MODE_GCM, nonce=nonce)\n    print cipher.decrypt_and_verify(proc_pwd,auth_tag)\n  pwd =\n  \"763130492BD2706140CDA41C2701F3B4C2B5153DE018BA5512897731F1A1BB7D7982AA2BF3DEA4B299145D88B040ED58\".decode('\n  hex')\n  unproc_key = \"2295D977B8F09202A4F8F7ACAF15C1B9EC411B126A0335208BE3DB8F14CA1551\".decode('hex')\n  dec(pwd, unproc_key)\n\n```\nMoving on, It creates another list zah where its elements have 3 fields named Item1, Item2 and Item3.\n\nHere,\n\nItem1 = Browser Name\n\nItem2 = Browser Data Location\n\nitem3 = bool if it exists (maybe)\n\n\n-----\n\nNext It checks if whether it exists or not similarly it checked the chrome location.\n\nBut now It doesn’t do anything (I don’t have Opera installed), instead I see the credentials from Chrome being added\nto a list. Now we have the decrypted password in it :)\n\nLater it continues to check for different browsers and some FTP Clients as well.\n\n\n-----\n\nAnd After adding some of the Browser Names & Location it checks for them in chunks.\nHere you can check it does the same process with Yandex Browser.\n\n## Communication through SMTP\n\nNow we know some part of how it carries out its stealthy process of stealing credentials from the browswers without\nany sql query. So I ended up searching for some functions which used the SMTP client responsible for sending the\ncredentials.\n\nAnd I found the only function which used it was tkq.tyx().\n\nLuckily It was not as obfuscated as I thought it to be.\n\n\n-----\n\nWe can clearly observe our system and browser information which its sending over.\nAlong with them we can also see the plaintext credentials of the author’s email account at yandex.ru which is used to\nsend it.\nAnd to no surprise, these credentials were working as we previously checked the any.run results.\n\nAlso The funny thing is that I had the credentials before this part of the blog as they were just decrypted using the\nsame process I explained.\n\nWe can view our browser credentials in memory dump and the message body is formatted as html.\n\n\n-----\n\nIt uses different classes such as mailMessage to construct the message body.\nAnd Finally It initializes some other variables such as..\nPort = 587 (default for SMTP)\nHost = yandex.ru,\nTo and From fields were the same…\n\nAnd when it sends over the data it deletes itself from the disk. I didn’t explore it that much and I wasn’t sure maybe it\nwas executed in a thread.\n\n## Thanks\n\n\n-----\n\nI hope this 2 part series was insightful and you guys enjoyed it. Well If you are reading this line you really liked it.\nTBH It really took a lot of work to put it all together including taking screenshots, and not to forget… opening the\nmalware again in dnspy.. everytime it removed itself.\n\nSee ya guys next time…\nTill then Take Care and make use of this Lockdown to learn new stuff.\nAlso Keep sharing your findings with the community.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-04-15 - How Analysing an AgentTesla Could Lead To Attackers Inbox - Part II.pdf"
    ],
    "report_names": [
        "2020-04-15 - How Analysing an AgentTesla Could Lead To Attackers Inbox - Part II.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536187,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1653751706,
    "ts_modification_date": 1653751706,
    "files": {
        "pdf": "https://archive.orkl.eu/3e58d16037f24d1fddf7131f01dfb08640f4cbad.pdf",
        "text": "https://archive.orkl.eu/3e58d16037f24d1fddf7131f01dfb08640f4cbad.txt",
        "img": "https://archive.orkl.eu/3e58d16037f24d1fddf7131f01dfb08640f4cbad.jpg"
    }
}