{
    "id": "427d408b-7c3f-43d2-b31d-c15f647a0762",
    "created_at": "2023-01-12T15:06:56.43661Z",
    "updated_at": "2025-03-27T02:05:46.958222Z",
    "deleted_at": null,
    "sha1_hash": "0da02ae87f769f7a47efb544105c60b10bbcc93d",
    "title": "2019-09-04 - FunkyBot- A New Android Malware Family Targeting Japan",
    "authors": "",
    "file_creation_date": "2022-05-28T00:24:19Z",
    "file_modification_date": "2022-05-28T00:24:19Z",
    "file_size": 171233,
    "plain_text": "# FunkyBot: A New Android Malware Family Targeting Japan\n\n**[fortinet.com/blog/threat-research/funkybot-malware-targets-japan.html](https://www.fortinet.com/blog/threat-research/funkybot-malware-targets-japan.html)**\n\nSeptember 4, 2019\n\n[Last year, FortiGuard Labs identified a malware campaign targeting Japanese users. The](https://www.fortinet.com/resources/cyberglossary/malware?utm_source=blog&utm_campaign=2021-q1-malware)\ncampaign impersonated a logistics company and deployed an Android malware called\n[FakeSpy.](https://www.fortinet.com/blog/threat-research/fakespy-comes-back--new-wave-hits-japan.html)\n\nWe have been monitoring these actors and the phishing websites they created, and recently\nwe noticed that they have started deploying a different Android payload.\n\nAs in their previous campaigns, this payload consists of a packer and a payload. However,\nboth of these are different from the ones we have encountered previously.\n\nIn the following blog, we will provide a deep analysis of both the packing mechanisms as well\nas the deployed payload, which to the best of our knowledge is a new malware family. It may\nhave been developed by the same people behind the campaign as a substitute for the toowell known FakeSpy malware family they have been using up to now. Based on logging\nstrings found in the persistence mechanism of the payload, as seen in figure 7, we have\ndecided to call this new malware family FunkyBot.\n\n\n-----\n\nWe will be analysing the following sample:\n\n152be211ecd21c8abfd7c687a5ca8a17906f589c59055516e5482ff3fcf42dbf\n\n## Packer\n\nThe Packer is made of two separate parts:\n\nJava code contained in the classes.dex file\nNative code contained in the libcsn.so file\n\n### Java Functions\n\nThe code of the packer in the sample we analysed was obfuscated. Luckily, after some\nsearching we were able to find an un-obfuscated version of the code, and we will be using\nthat.\n\nThe reference sample for the packer is the following:\n\nb4f3b7850c4332bcf85bbd64ebd6d837a3de64a03c1150cdd27e41599d2852b6\n\nThe first interesting function that is executed is _attachBaseContext(Context base). This\nfunction accesses the configuration file contained in the asset folder of the APK. In this case,\nit is a JSON file called ‘_dcfg_.data’, and it loads the following parameters:\n\n“size”: identifies the number of ‘.dex’ payloads that the packer has to generate\n“payloadType”: identifies where the encrypted data of the payload is located\n“isTestIn”: flag used for testing purposes\n“type”: identifies the kind of encryption used\n\nIn the samples we analysed, we found the following two configurations:\n\n_{\"size\":2,\"payloadType\":0,\"isTestIn\":\"0\",\"type\":3}_\n\n_{\"size\":2,\"payloadType\":1,\"isTestIn\":\"0\",\"type\":3}_\n\nThe packer determines which version of Android it is running on in order to generate the\nproper payload. It also goes the extra mile and generates some fake dex files to possibly\nconfuse malware analysts.\n\nFigure 1: Creation of fake Dex files\n\nIt then checks the ‘payloadType’ value, and if the value is equal to 1, it will copy the asset\ndata to another folder. Otherwise, it will proceed without moving anything, as it uses the\n_classes.dex file loaded in memory instead._\n\nFigure 2: Extraction of Dex encrypted file\n\n\n-----\n\n### JNI Functions\n\nThe Class JNITools declares a set of native functions that are contained in libcsn.so.\n\nFigure 3: JNITools native functions declaration\n\nThe native JNI_OnLoad function, which is run when the library is loaded, registers the native\nfunctions declared in JNITools, allowing them to be called differently than the usual scheme\nof Java_<className>_<FunctionName>, probably to make the reversing process harder.\n\nIf the value of the configuration variable ‘type’ is different from 0 (which means the payload\nneeds to be decrypted), the code accesses the folder /data/data/<appname>/app_csn0/ and\ncreates a folder ‘.unzip’ in it. Note that the name of the folder contains a dot as the first\ncharacter, making it invisible to a normal ls command.\n\nThe decryption routines are run on a file generated from the encrypted payload data. This\ndata is obtained from one of two sources, based on the value of ‘payloadType’:\n\n0: the ‘classes.dex’ file, containing all the executed code\n1: an asset file, in this case assets/csn-enc.data\n\nIn the first case, the packer accesses the /proc/<pid>/maps file to locate the memory where\nthe classes.dex file is loaded, and then looks for a specific set of characters in memory that\nidentify the beginning of the encrypted data. In this case, the magic word is `csn_`. When\nfound, it starts copying from that point onwards.\n\nFigure 4: Searching for Magic 'csn_'\n\nThe different values of the configuration variable ‘type’ correspond to different decryption\nroutines. The code supports the following values:\n\n0: No encryption\n2/3 : variations of XOR based decryption with the value `0x51` (81)\n\nFigure 5: Decrypt Switch\n\nIn the samples presented here, the configuration always had a value of 3, which corresponds\nto the following decryption function:\n\nFigure 6: Decryption 'type' 3\n\nThese routines then generate a ‘classes.dex’ payload file that is loaded by the ClassLoader.\n\n## Payload: FunkyBot\n\n\n-----\n\nIn the sample analysed, the payload consisted of two .dex files. One being a copy of the\noriginal legitimate application that the malware is impersonating, and the other being the\nmalicious code.\n\nThe payload is started by calling the method `runCode` class\n`com.wfk.injectplugin.EntryPoint` through Java reflection. This method starts\n`KeepAliceMain.start()`.\n\nFigure 7: EntryPoint\n\n### KeepAliceMain\n\nThis Class is used as persistence mechanism by the malware. It uses an open source library\nthat can be found on Github to keep the service alive on the device. It also allows the\nmalware to mute sounds from the device, even though in this specific instance this\nfunctionality is not used.\n\nThis class periodically re-launches the main service used by the malware to create a gRPC\nconnection to a remote server.\n\n### GRPC Client\n\nCommand and Communication Address\n\nThe server address is not hardcoded in the `classes.dex` file, but it is retrieved during\nexecution. The code executes the function `GprcsUtils.Regist_Server(String str)`, which calls\n`UrlTool.loadIPAddrFromIns()` to extract the C2 URL.\n\nFigure 8: Loaded IP from Instagram\n\nMuch like Anubis used to do with fake Telegram and Twitter accounts, this malware uses\nsocial media to obtain its C2: it downloads the webpage of a photo-less Instagram account. It\nthen extracts the biography field of this account and decodes it using Base64.\n\nFigure 9: Fake Instagram account\n\nFinally, the resulting string is decrypted using DES and a key is generated using the value\n`d2a57dc1d883fd21fb9951699df71cc7` as its seed (which happens to be the MD5 hash\ncorresponding to the word ‘app’), which can be seen in figure 8 under the String variable\nstr3.\n\nThe resulting URL is 149.28.24.166:11257 and the fake accounts have been reported to\nInstagram.\n\n### SMS Service\n\n\n-----\n\nAfter the connection to the server is started, the malware proceeds to collect and send the\nfollowing information about the device:\n\nIMEI\nIMSI\nPhone number\nList of contacts\n\nThe amount of exfiltrated information is relatively limited, especially when compared to\nbigger families like Anubis, Cerberus, or Hydra. However, like previous campaigns, it also\nfeatures aggressive spreading techniques.\n\nAfter having sent all of the device’s contacts to the C2, it waits for it to respond with a\ntelephone number and a message body to construct an SMS. This strategy has been used\nby multiple campaigns, including FakeSpy and MoqHao, to enable the malware to spread in\na worm-like fashion. It is logical to assume that this sample would do the same.\n\nIt is interesting to note that the malware identifies the provider of the SIM card and looks\nspecifically for a specific Japanese telecommunication provider. To do so, it checks the IMSI\n(International Mobile Subscriber Identity) value of the device. This value is composed of two\nhalves: the first identifies the provider, and the second is unique to the specific device.\n\nThe malware checks to see if the first half corresponds one of its listed values, which are all\nconnected to the aforementioned provider.\n\nFigure 10: Checking if the device is served by a specific provider\n\nAt the beginning, we thought the function was going to possibly be used for some targeted\naction towards the customers of this provider. Instead, if the function `is<Provider>()` returns\n_true, then the malware simply proceeds to increase the value controlling the maximum_\nnumber of SMS messages it allows itself to send.\n\nAfter some research, we concluded that this behaviour might just be because the provider\nenables customers to send free SMS messages to each other, increasing the amount of\ntraffic a single infected device is capable of generating before arousing suspicion.\n\nFinally, the malware is able to set itself as the default SMS handler application, and uses this\nto upload to the C2 all the received messages. This functionality can be very dangerous,\nconsidering that most banks currently use two-factor authentication through SMS.\n\n## Conclusion\n\nBy monitoring the campaign primarily targeting Japanese service providers, FortiGuard Labs\nwas able to identify this campaign and what, to the best of our knowledge, is a new malware\nfamily.\n\n\n-----\n\nDuring our analysis, we also encountered other samples that were not completely developed\nand lacked some of the functionalities discussed in this blogpost, suggesting that the\nmalware is currently under development and is being tested in the wild.\n\nThe capabilities of this family are limited at the moment, but the fact that we were able to find\ndifferent samples that showed significant improvement in the span of a few weeks shows\nthat this family should not be underestimated.\n\nFortiGuard Labs will continue to monitor this campaign as it evolves.\n\n-=FortiGuard Lion Team=\n## Solutions\n\nFortinet customers are protected against this malware by the following Signatures:\n\nPacker: Android/Agent.DDQ!tr\nPayload: Android/Funky.A!tr and Android/Funky.B!tr\n\n**Acknowledgements**\n\nI would like to thank Evgeny Ananin for his help in the research needed for this blogpost.\n\n### IOC List:\n\n**Packers:**\n\nb4f3b7850c4332bcf85bbd64ebd6d837a3de64a03c1150cdd27e41599d2852b6\n\n152be211ecd21c8abfd7c687a5ca8a17906f589c59055516e5482ff3fcf42dbf\n\n**Payloads:**\n\n02036825d69208612fd281b3d4fd9be06fc315addeac1fe8872eb2cc9f6f1fcd\n\nbeb6cb245f6597b6d2b9e9232774329b94f2eada5980a3cb28f9100cc161f4a4\n\n**CCs:**\n\n_149[.]28[.]24[.]166[:]11257_\n\n_108[.]61[.]187[.]156[:]11257_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-09-04 - FunkyBot- A New Android Malware Family Targeting Japan.pdf"
    ],
    "report_names": [
        "2019-09-04 - FunkyBot- A New Android Malware Family Targeting Japan.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536016,
    "ts_updated_at": 1743041146,
    "ts_creation_date": 1653697459,
    "ts_modification_date": 1653697459,
    "files": {
        "pdf": "https://archive.orkl.eu/0da02ae87f769f7a47efb544105c60b10bbcc93d.pdf",
        "text": "https://archive.orkl.eu/0da02ae87f769f7a47efb544105c60b10bbcc93d.txt",
        "img": "https://archive.orkl.eu/0da02ae87f769f7a47efb544105c60b10bbcc93d.jpg"
    }
}