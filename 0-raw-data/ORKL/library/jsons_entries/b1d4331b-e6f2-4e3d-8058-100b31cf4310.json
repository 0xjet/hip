{
    "id": "b1d4331b-e6f2-4e3d-8058-100b31cf4310",
    "created_at": "2023-01-12T15:09:35.759725Z",
    "updated_at": "2025-03-27T02:05:28.586131Z",
    "deleted_at": null,
    "sha1_hash": "845a21d0d38978467b104f0cdd0cac2ccd4f6b7a",
    "title": "2021-04-22 - Deep Analysis- FormBook New Variant Delivered in Phishing Campaign – Part II",
    "authors": "",
    "file_creation_date": "2022-05-29T10:46:47Z",
    "file_modification_date": "2022-05-29T10:46:47Z",
    "file_size": 677038,
    "plain_text": "# Deep Analysis: FormBook New Variant Delivered in Phishing Campaign – Part II\n\n**[fortinet.com/blog/threat-research/deep-analysis-formbook-new-variant-delivered-phishing-campaign-part-ii](https://www.fortinet.com/blog/threat-research/deep-analysis-formbook-new-variant-delivered-phishing-campaign-part-ii)**\n\nApril 21, 2021\n\n**[FortiGuard Labs Threat Research Report](https://www.fortinet.com/fortiguard/labs.html?utm_source=blog&utm_medium=campaign&utm_campaign=FortiGuardLabs)**\n\nAffected platforms: Microsoft Windows\n\nImpacted parties:  Windows Users\n\nImpact:          Collect Sensitive Information from Victim’s Devices\n\nSeverity level:     Critical\n\n[This is part II of a threat analysis series examining a phishing campaign that](https://www.fortinet.com/resources/cyberglossary/phishing?utm_source=blog&utm_campaign=phishing) [FortiGuard Labs](https://www.fortinet.com/fortiguard/labs?utm_source=blog&utm_campaign=fortiguard-labs)\ncaptured in our SPAM monitoring system. The sample we captured was attempting to deliver\n“FormBook” malware through a PowePoint document attached to an email. FormBook is a\nmalware designed to steal sensitive information from a victim’s device as well as to receive\ncontrol commands to perform additional malicious tasks on that device.\n\n\n-----\n\nIn the [Part I of my analysis, I explained how the VBA code in the PowerPoint file was used to](https://www.fortinet.com/blog/threat-research/deep-analysis-new-formbook-variant-delivered-phishing-campaign-part-I?utm_source=blog&utm_campaign=deep-analysis-new-formbook-variant-delivered-phishing-campaign-part-I)\ndownload a PowerShell file, how it extracts a .Net framework file, and how the FormBook\npayload file is processed through three .Net modules.\n\nIn this second part, we will examine what anti-analysis techniques FormBook performs, what\nWindows processes it focuses on, and how the FormBook malware running inside\nAddInProcess32.exe injects itself into a randomly-picked Window process. Furthermore, we\nwill see how FormBook injects itself into a number of target processes through the Windows\nprocess.\n\n## Payload File Runs in “AddInProcess32.exe”\n\n[As mentioned in part I of this analysis, a FormBook payload is injected into a newly-created](https://www.fortinet.com/blog/threat-research/deep-analysis-new-formbook-variant-delivered-phishing-campaign-part-I?utm_source=blog&utm_campaign=deep-analysis-new-formbook-variant-delivered-phishing-campaign-part-I)\nprocess, “AddInProcess32.exe”, and the relevant registers are set to point to the entry of the\n[injected FormBook. After that, the entry point is called after executing the API](https://www.fortinet.com/resources/cyberglossary/api-security?utm_source=blog&utm_campaign=api-security)\nResumeThread() by the AMe8 module—which is the point that I will start from in this post.\n\nThe payload file of the FormBook malware is a 32Bit Native Code PE file (an EXE file), not a\n.Net module. Figure 1.1 is a screenshot of the entry point function of FormBook.\n\nFigure 1.1 - The entry point function of the FormBook malware\n\n## Configuration Object and Anti-Analysis Techniques\n\n### Configuration Object:\n\nBefore discussing the FormBook main module, I need to introduce a global configuration\nobject (“ConfigObj”) or configuration block, which is frequently read and written throughout\nthe entire FormBook malware. It occupies 0xC9C bytes containing many configuration\noptions, such as:\n\nthe base addresses of FormBook, and many Dll modules (ntdll.dll, kernel32.dll,\nadvapi32.dll, etc.)\nencrypted Dll names like “kernel32.dll” and “advapi32.dll”, etc.\na “flag group” revealing whether FormBook is running in an analysis device\nmany encrypted blocks with string hash codes for retrieving APIs\nflags revealing if it is on a 32-bit or 64-bit platform\nmany API addresses (ExitProcess(), CreateProcessInternalW(), etc.)\nand so on\n\nFigure 2.1 is a screenshot of part of the ConfigObj in a memory view that had just been\ninitialized.\n\nFigure 2.1 - Memory view of part of ConfigObj\n\n\n-----\n\n### Anti-analysis Techniques Used by FormBook:\n\n1. Imported APIs are hidden:\n\nFigure 2.2 – Example of hidden APIs with their hash codes\n\nAll APIs are hidden from analysts in FormBook. They are retrieved by a special function with\nthe APIs’ name hash code. Some hash codes are given by constant value and some are\ndecrypted from ConfigObj.\n\nAs you can see, the code segment shown in Figure 2.2 is an example of obtaining two APIs\nvia the renamed function get_API_by_name_hashcode() with their name’s hash codes,\nwhich are 0C84882B8h => CoCreateInstance() and 44E954F9h => CreateDirectoryW().\n\n2. Duplicating the ntdll.dll module:\n\nntdll.dll is the kernel layer DLL on Windows that provides NT kernel APIs. FormBook deploys\na duplicated ntdll.dll in its memory offering kernel APIs function instead of the original one\nthat prevents researchers from identifying the APIs. Figure 2.3 shows the duplicated ntdll.dll\n(0x810000) at the upper and the originally-loaded ntdll.dll (0x77140000) at the bottom.\n\nFigure 2.3 – The duplicated ntdll.dll in Memory Map view\n\n3. Detecting whether it is running in an analysis environment:\n\nFormBook compares predefined hash codes in a list that is decrypted from ConfigObj with\nrunning process name’s hash code. It calls the API ZwQuerySystemInformation() with the\nparameter SystemProcessInformation to gather information about all running processes into\na link structure.\n\nIt then calculates the process name’s hash code one by one and compares it against those\npredefined hash codes. The process names corresponding to predefined hash codes are\nabout VMware, Virtual Box, Sandboxie, Parallels Desktop, and other analysis tools for\nmonitoring files, processes, and network and system registry events. Following is a list of\nthose processes.\n\nvmwareuser.exe, vmwareservice.exe, VBoxService.exe, VBoxTray.exe,\nsandboxiedcomlaunch.exe, sandboxierpcss.exe, procmon.exe, filemon.exe, wireshark.exe,\nNetMon.exe, prl_tools_service.exe, prl_cc.exe, vmtoolsd.exe, vmsrvc.exe, vmusrvc.exe,\npython.exe, perl.exe, regmon.exe\n\nIt also records any match results as a flag in the “flag group” of ConfigObj.\n\n4. Detecting file names, user names, path:\n\n\n-----\n\nIt then calculates the hash codes of strings that are retrieved from current process names\n(the process name may be renamed by researchers), user names (famous sandboxes use\nfixed user name), and the list of split strings of loaded modules’ path string (analysis tool’s\nmodules). It then checks these hash codes with the predefined hash codes in FormBook.\nThe result affects the “flag group”.\n\n5. Detect any debuggers:\n\nNext, it retrieves the API ZwQueryInformationProcess() from the duplicated ntdll.dll and calls\nit with different parameters to obtain SystemKernelDebuggerInformation data. This is used to\ncheck the kernel debugger and ProcessDebugPort data to identify a ring3 debugger. Figure\n2.4 displays the two parameters used to obtain debugger information.\n\nFigure 2.4 – Detecting the Kernel and Ring3 debugger\n\n6. Detect the time gap from executing instructions:\n\nThis detection has been disabled in this variant. It is used to determine if FormBook is being\ndebugged by comparing the gap time of executing ASM instructions > 300h (should be less\nthan 300h). It has hardcoded the value to 50h to disable this detection. It also records the\nresult in the “flag group” in ConfigObj.\n\n7. Encrypted key functions:\n\nThere are five segments of key functions that are encrypted and decrypted before injecting\ninto the target processes. The five segments are identified by five magic codes, which are\n48909090h, 49909090h, 4A909090h, 4B909090h, and 4C909090h.\n\n8. Using many undocumented APIs:\n\nFormBook uses many low level undocumented APIs, such as LdrGetProcedureAddress(),\nLdrLoadDll(), ZwOpenProcessToken(), ZwAdjustPrivilegesToken(), NtOpenProcessToken(),\nZwReadVirtualMemory(), RtlQueryEnvironmentVariable(),\nRtlDosPathNameToNtPathName_U(), ZwDelayException(), ZwQueueApcThread(), and so\non.\n\nThe so-called “Undocumented API” simply means the API is hidden to Windows users. You\nare unable to gain any official description for the API from MSDN.\n\nThere is a special function to check the result in “flag group” that is set in some detections.\nOnce one detection is triggered, it returns 0, otherwise it returns 1. Below is the pseudocode\nof this function, whose parameter is the ConfigObj. The flag group occupies the bytes from\noffset 40 (0x28) to 55 (0x37).\n\nInt __cdecl sub_407D50(unsigned char* pConfigObj)\n\n\n-----\n\n{\n\nreturn !*(pConfigObj + 41) && *(pConfigObj + 42) && *(pConfigObj + 43)\n\n&& !*(pConfigObj + 44) && !*(pConfigObj + 45) && *(pConfigObj + 46)\n\n&& !*(pConfigObj + 47) && *(pConfigObj + 48) && !*(pConfigObj + 49)\n\n&& *(pConfigObj + 50) && !*(pConfigObj + 51);\n\n}\n\nIf the result of the function is 0, it then exits the process without doing anything.\n\nYou cannot simply change the result (from 0 to 1) here to ignore detection and change the\ncode flow. The reason is that in the next step, the “flag group” (10H long) will be an RC4\nseed to generate RC4 keys to finally decrypt other data, like module names such as\n“kernel32.dll” and “advapi32.dll”. It could also fail to load these modules if the “flag group” is\nwrong.\n\n## The Outline of FormBook’s Tasks\n\nFigure 3.1 – Outline of what FormBook does on a victim’s device\n\nFigure 3.1, above, outlines most FormBook actions that are performed on a victim’s device.\nFormBook’s AddInProcess32.exe executable injects itself into a newly-created Windows\nprocess (like ipconfig.exe) that is created through Explorer.exe (steps 1, 2, and 3). Then,\nonce FormBook is inside the Windows process, it injects malicious code into target\nprocesses (FormBook focuses on 92 different target processes in total, including\n“iexplorer.exe”, “chrome.exe”, “skype.exe”, “outlook.exe”, “whatsapp.exe”, and so on) from\nwhich it steals victim inputs and clipboard data from time to time (step 4).\n\nIt also uses a large, shared memory section for storing stolen data gathered from the\nFormBook instance running inside target processes and the FormBook instance running in a\nWindows process (step 5).\n\nThe stolen data is then sent to its C2 server via the FormBook instance running inside\n“Explorer.exe” (step 6).\n\nI will elaborate on how it performs these actions in the rest of this blog.\n\n## Deploy FormBook Into a Windows Process via Explorer.exe\n\nThe FormBook payload running inside AddInProcess32.exe looks for Explorer.exe by\ncomparing the hash codes of running processes’ names, which it obtains by calling the API\nZwQuerySystemInformation() with the parameter 0x5 (SystemProcessInformation).\n\n\n-----\n\nThe hash code of explorer.exe is 19996921h. As you can see in Figure 4.1, it is an ASM\ncode snippet showing you how FormBook finds explorer.exe by comparing its hash code with\nthe hash code of other processes through a function that I call match_hashcode().\n\nOnce explorer.exe is matched, the function returns 1 and FormBook proceeds to the next\nstep. Otherwise, it retrieves the next running process name to match in a loop.\n\nFigure 4.1 – Code snippet comparing the explorer.exe hash code\n\nNext, FormBook opens the process handle of Explorer.exe, allocates memory to it, and then\ncopies the entire FormBook payload into that Explorer.exe memory. It then proceeds to\nexecute FormBook from the different entry point within a newly-started thread of\nExplorer.exe.\n\nTo do this, it calls a number of APIs, including ZwOpenProcess(), ZwCreateSection(),\nZwMapViewOfSection(), ZwOpenThread(), ZwSuspendThread(), ZwGetContextThread(),\nZwSetContextThread(), and ZwResumeThread().\n\nThe logic and features of the FormBook instance injected into Explorer.exe is very clear and\nsimple. It is to run a randomly selected Windows process (that locates at\n%Windir%\\system32\\) in suspended mode and return with the process status and\ninformation.\n\nThe Windows process name list is encrypted within ConfigObj (starting at offset +6Bh) and is\npicked by its index. It has thirty-eight such Windows process names in total (the string index\nrange is from 0x3 to 0x29), which are decrypted and listed below:\n\n\"svchost.exe\", \"msiexec.exe\", \"wuauclt.exe\", \"lsass.exe\", \"wlanext.exe\", \"msg.exe\",\n\"lsm.exe\", \"dwm.exe\", \"help.exe\", \"chkdsk.exe\", \"cmmon32.exe\", \"nbtstat.exe\",\n\"spoolsv.exe\", \"rdpclip.exe\", \"control.exe\", \"taskhost.exe\", \"rundll32.exe\", \"systray.exe\",\n\"audiodg.exe\", \"wininit.exe\", \"services.exe\", \"autochk.exe\", \"autoconv.exe\", \"autofmt.exe\",\n\"cmstp.exe\", \"colorcpl.exe\", \"cscript.exe\", \"explorer.exe\", \"WWAHost.exe\", \"ipconfig.exe\",\n\"msdt.exe\", \"mstsc.exe\", \"NAPSTAT.EXE\", \"netsh.exe\", \"NETSTAT.EXE\", \"raserver.exe\",\n\"wscript.exe\", \"wuapp.exe\", \"cmd.exe\".\n\nFigure 4.2 – Display of one decrypted Windows process in Explorer.exe\n\nFigure 4.2 shows its random function and decryption function, as well as a just-decrypted\nWindows process named “ipconfig.exe”, with the random string index 0x20. I will use\nipconfig.exe to explain how FormBook works with a Windows process.\n\nIt first calls the API CreateProcessInternalW() with the ipconfig.exe full path and\ndwCreationFlags parameter of 0x800000C, which means\n“CREATE_NO_WINDOW|CREATE_SUSPENDED|DETACHED_PROCESS”. This will then\nstart ipconfig.exe with no window and in suspended mode.\n\n\n-----\n\nThe FormBook instance in Explorer.exe will continue to collect the process information of\nipconfig.exe (such as its full path, the process ID, the thread ID, loaded base address, etc.)\nand return them to FormBook in AddInProcess32.exe. At this point, the work of FormBook\ninside Explorer.exe is done.\n\nWhy doesn’t it run the Windows process directly, rather than through Explorer.exe? In some\nanalysis tools, doing it this way shows that the Windows process (ipconfig.exe) was started\nfrom Explorer.exe, the same as normal processes started by the victim. This helps hide itself\nfrom analysts as well as the victim. Another trick it uses is that the processes are all\nWindows default processes, which makes it less likely for users and analysts to connect it to\na malware. As you can see in Figure 4.3 taken from the Explorer process, ipconfig.exe is\nrecognized under explorer.exe, which is the same as other processes, such as “notepad.exe”\nand “calc.exe”, which I opened by double clicking their icons.\n\nFigure 4.3 – ipconfig.exe is recognized under explorer.exe\n\nFormBook in AddInProcess32.exe then obtains the process information of the suspended\nipconfig.exe that is returned from Explorer.exe. It is then able to copy the FormBook payload\nfile into ipconfig.exe and modify its main thread’s entry point code to the new entry point of\nthe injected FormBook. It eventually calls the API ZwResumeThread() to resume\nipconfig.exe in order to execute FormBook’s malicious code. At the same time, it calls\nExitProcess() to terminate the lifetime of the FormBook instance injected into\nAddInProcess32.exe.\n\n## FormBook in Windows Process is Injected Into Target Processes\n\nThe injected FormBook instance running in a Windows process, like ipconfig.exe, takes the\ncontrol of maintaining its life on the victim’s device.\n\nFirst, it initializes its own ConfigObj and performs the detections that I explained earlier in the\nanti-analysis section.\n\nIt is then time for FormBook to decrypt five key functions that will be called within target\nprocesses after FormBook has been injected into them. It has a magic code for each of\nthese functions, which are 48909090h, 49909090h, 4A909090h, 4B909090h, and\n4C909090h.\n\nFormBook finds the encrypted code by searching the magic codes in the entire code section\nand then decrypts them using an RC4 algorithm. The RC4 decryption key is generated from\ndata in ConfigObj. Figure 5.1 shows the encrypted code for a key function for magic code\n48909090h on the left side, and the decrypted code on the right side.\n\nFigure 5.1 – Display of both encrypted and decrypted code for a key function\n\n\n-----\n\nThe five decrypted key functions are used to perform C2 relevant work, like decrypting the\nC2 host strings, loading network APIs, and communicating with C2 servers, etc.\n\nA function in FormBook focuses on filtering target processes from gathered current\nprocesses by calling the API ZwQuerySystemInformation() with the\nSystemProcessInformation parameter by comparing a process name’s hash code with the\npredefined hash codes in FormBook that are saved in ConfigObj. Once a process’s hash\ncode is matched with its predefined hash code, it initiates a function to inject FormBook into\nthe matched process and then executes code from different entry points set inline hooks for\nstealing data.\n\nFigure 5.2 shows a pseudocode of the code flow structure of how FormBook filters a target\nprocess and calls a function to inject FormBook into that process once the process name\nmatches a predefined hash code. FormBook performs this check every five seconds to better\ncover newly opened target processes.\n\nFigure 5.2 – Pseudocode of the code-flow finding target processes\n\nThere are a total of 92 predefined target processes in this variant of FormBook, which has an\nencrypted hash code list of process names saved in ConfigObj, starting at offset + 444h. I\nhaven’t yet defined all of the target process names by their hash codes. However, through\nmy analysis, I have identified most of the products the target processes belong to. They can\nbe divided into several categories based on their features, as shown below:\n\n**Web browsers:**\n\nGoogle Chrome, Microsoft IE and Edge, Mozilla Firefox, Opera Browser, Apple Safari, Torch\nBrowser, Maxthon Browser, SeaMonkey Browser, Avant Browser, Comodo Dragon and\nIceDragon, K-Meleon Browser, BlackHawk Browser, Cyberfox Browser, Vivaldi Browser,\nLunascape Browser, Epic Browser, Midori Browser, Pale Moon Browser, QtWeb Browser,\nFalkon Browser, UCBrowser, Waterfox Browser, and so on.\n\n**Email clients:**\n\nMicrosoft Outlook, Pocomail, Opera Mail, Tencent Foxmail, IncMail, Mozilla Thunderbird,\nGoogle Gmail Notifier Pro, and so on.\n\n**IM clients:**\n\nYahoo Messenger, ICQ, Pidgin, Trillian, Microsoft Skype, FaceBook WhatsApp, and so on.\n\n**FTP clients:**\n\nEstsoft ALFTP, NCH Classic FTP, Core Ftp, FAR Manager, FileZilla, FlashFXP, NCH Fling,\nFTP Voyager, WinSCP, and so on.\n\n\n-----\n\n**Others:**\n\nWindows Notepad and “Explorer.exe”.\n\nThe detailed target processes are\n\n\"iexplore.exe\", \"firefox.exe\", \"chrome.exe\", \"microsoftedgecp.exe\", \"opera.exe\", \"safari.exe\",\n\"torch.exe\", \"Maxthon.exe\", \"seamonkey.exe\", \"avant.exe\", \"dragon.exe\", \"icedragon.exe\",\n\"kmeleon.exe\", \"blackhawk.exe\", \"Cyberfox.exe\", \"Vivaldi.exe\", \"luna.exe\", \"Epic.exe\",\n\"Midori.exe\", \"palemoon.exe\", \"QtWeb.exe\", \"qupzilla.exe\", \"UCBrowser.exe\",\n\"Waterfox.exe\", \"notepad.exe\", \"explorer.exe\", \"outlook.exe\", \";poco.exe\", \"operamail.exe\",\n\"foxmail.exe\", \"incmail.exe\", \"thunderbird.exe\", \"Barca.exe\", \"gmailNotifierPro.exe\",\n\"yahoomessenger.exe\", \"icq.exe\", \"pidgin.exe\", \"Trillian.exe\", \"skype.exe\", \"WhatsApp.exe\",\n\"alftp.exe\", \"classicftp.exe\", \"coreftp.exe\", \"Far.exe\", \"filezilla.exe\", \"FlashFXP.exe\",\n\"fling.exe\", \"FTPVoyager.exe\", \"WinSCP.exe\".\n\nIt calls the API ZwOpenProcess() and then ZwCreateSection() to open a target process and\nthen create a section of memory in it. Next, it transfers the entire FormBook along with the\ndecrypted five key functions into the section. It then executes it from a new entry points\nwithin a newly-created thread in the target process.\n\n## Conclusion on Phishing Campaign\n\nIn this part II, I started my analysis from the point where the FormBook payload file is\ninjected into the AddInProcess32.exe process. At first, I introduced an important data\nstructure—Configuration Object—which holds the key configuration data that is used\nthroughout FormBook for whatever it is injected into. I then elaborated on the anti-analysis\ntechniques that FormBook performs, how it then selects a process from the thirty-nine\nWindows processes (like ipconfig.exe) it looks for, and then injects FormBook using\nExplorer.exe as a middle process. And finally, through my research on the hash codes of the\nprocess name, I was able to recover most of the target processes that FormBook is\ninterested in.\n\nIn the final part of this analysis, I will explain how FormBook establishes inline hooks on\nsome APIs inside target processes, what kind of data it can steal from a victim’s device, how\nthe stolen data is sent to the C2 server, what its control commands are able to do on a\nvictim’s machine, as well as the strategy used to have various FormBook instances work\ntogether across the Windows processes (ipconfig.exe), Explorer.exe, and target processes.\n\n## Fortinet Protections\n\nFortinet customers are already protected from this FormBook variant with FortiGuard’s Web\nFiltering and AntiVirus services, as follow:\n\n\n-----\n\nThe download URL launched from the PowerPoint sample is rated as **Malicious Websites**\nby the FortiGuard Web Filtering service.\n\nThe attached PowerPoint file is detected as “VBA/FormBook.C393!tr” and the “item3.jpg”\nfile is detected as \"MSIL/FormBook.ZXL!tr\" and blocked by the FortiGuard AntiVirus\nservice.\n\n[The FortiGuard AntiVirus service is supported by FortiGate,](https://www.fortinet.com/products/next-generation-firewall.html?utm_source=blog&utm_campaign=fortigate-main-page) [FortiMail, FortiClient,](https://www.fortinet.com/products/email-security/fortimail.html?utm_source=blog&utm_campaign=2018-q2-fortimail-main-page)\n[and FortiEDR. The Fortinet AntiVirus engine is a part of each of those solutions as well. As a](https://www.fortinet.com/products/endpoint-security/fortiedr.html?utm_source=blog&utm_campaign=fortiedr)\nresult, customers who have these products with up-to-date protections are protected.\n\n[Besides, FortiSandbox is able to detect the PowerPoint sample as malicious.](https://www.fortinet.com/products/sandbox/fortisandbox.html?utm_source=blog&utm_campaign=fortisandbox-main-page)\n\n[We also suggest our readers to go through the free NSE training --](https://training.fortinet.com/?utm_source=blog&utm_campaign=nse-institute) NSE 1 – Information\nSecurity Awareness, which has a module on Internet threats designed to help end users\nlearn how to identify and protect themselves from phishing attacks.\n\n_[Learn more about FortiGuard Labs threat research and the FortiGuard Security](https://www.fortinet.com/fortiguard/labs?utm_source=blog&utm_campaign=fortiguard-labs)_\n_[Subscriptions and Services portfolio.](https://www.fortinet.com/fortiguard/labs?tab=security-bundles&utm_source=blog&utm_campaign=security-bundles)_\n\n_Learn more about Fortinet’s_ _[free cybersecurity training initiative or about the Fortinet](https://www.fortinet.com/blog/business-and-technology/fortinet-offers-free-cybersecurity-training-courses?utm_source=blog&utm_campaign=free-cybersecurity-training-courses)_ _NSE_\n_Training program,_ _[Security Academy program, and](https://training.fortinet.com/local/staticpage/view.php?page=fnsa&utm_source=blog&utm_campaign=fnsa)_ _[Veterans program.](https://www.fortinet.com/corporate/careers/vets.html?utm_source=blog&utm_campaign=fortivet)_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-22 - Deep Analysis- FormBook New Variant Delivered in Phishing Campaign – Part II.pdf"
    ],
    "report_names": [
        "2021-04-22 - Deep Analysis- FormBook New Variant Delivered in Phishing Campaign – Part II.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536175,
    "ts_updated_at": 1743041128,
    "ts_creation_date": 1653821207,
    "ts_modification_date": 1653821207,
    "files": {
        "pdf": "https://archive.orkl.eu/845a21d0d38978467b104f0cdd0cac2ccd4f6b7a.pdf",
        "text": "https://archive.orkl.eu/845a21d0d38978467b104f0cdd0cac2ccd4f6b7a.txt",
        "img": "https://archive.orkl.eu/845a21d0d38978467b104f0cdd0cac2ccd4f6b7a.jpg"
    }
}