{
    "id": "b7f7f461-de81-45dd-99b9-d72482a2b68b",
    "created_at": "2022-10-25T16:48:15.296761Z",
    "updated_at": "2025-03-27T02:16:59.273644Z",
    "deleted_at": null,
    "sha1_hash": "dd71e034b730cc673712b1c34759f6d8a08e85d7",
    "title": "",
    "authors": "",
    "file_creation_date": "2020-10-12T13:25:30Z",
    "file_modification_date": "2020-10-12T13:25:32Z",
    "file_size": 1581812,
    "plain_text": "### Vol.100\n\n\n-----\n\n## Contents\n\n##### New Mirai Variant Targets IoT Devices\n\n Static Analysis of KiraV2 Malware 04\n\n Attack Flow 05\n\n Reset 07\n\n Prevent Reboot: Keep Alive 12\n\n Force Quit: Killer 14\n\n DDoS Attack 15\n\n Distribution Method 17\n\n Conclusion 23\n\n\n#### Report Vol.100 2020 Q3\n\n\n###### ASEC (AhnLab Security Emergency-response Center) is a global security response group consisting of\n\n malware analysts and security experts. This report is published by ASEC and focuses on the most significant\n\n security threats and latest security technologies to guard against such threats. For further details, please visit\n\n AhnLab, Inc.’s homepage (www.ahnlab.com).\n\n\n-----\n\n# New Mirai Variant Targets IoT Devices\n\n##### Mirai malware surfaced for the first time in 2016. It was notorious for infecting Internet of\n\n Things (IoT) devices across the globe and using botnets to launch distributed denial-of-service\n\n (DDoS) attacks. After the source code for Mirai was published, there was an influx of attackers\n\n using Mirai to infect IoT devices and perform DDoS attacks on their targets. And to this day,\n\n diverse variants of Mirai are still widely distributed online.\n\n The recent variants of Mirai that are being distributed has an additional remote code\n\n execution vulnerability than that of the previous source code. This is to secure the botnet by\n\n infecting more vulnerable IoT devices. In other words, it means that the recent variants of\n\n Mirai scan connectible devices for vulnerability and use remote code execution vulnerability\n\n to distribute the malware on vulnerable devices. Among the variants of Mirai, KiraV2 malware\n\n is one of the main variants that have a remote code execution vulnerability attack routine for\n\n mass distribution. KiravV2 has become an improved and enhanced version of Mirai malware\n\n when it comes to distribution methods.\n\n Due to the advent of COVID-19, employees working from home using remote devices\n\n are increasing in numbers. Following this trend, experts must pay close attention to Mirai\n\n malware, as its pool of potential targets have expanded. This analysis report will introduce the\n\n key characteristics and attack flow of KiraV2, a variant of Mirai malware. Also, a comparison of\n\n the two malware will be made based on the different attack flow.\n\n\n-----\n\n##### 1. Static Analysis of KiraV2 Malware\n\n KiraV2 malware removed unnecessary source codes from the original source code of Mirai\n\n and added a new routine to further distribute the malware. This malware also shows signature\n\n string name 'KiraV2,' as intended by the malware operator. However, recently various other\n\n non-Mirai malware that uses parts of Mirai’s source code, such as gafgyt, was also found.\n\n KiraV2’s overall features are very similar to that of Marai's. KiraV2 malware’s primary goal is to\n\n launch DDoS attacks. KiraV2 is equipped with various features to distribute itself to vulnerable\n\n IoT devices in order to acquire various botnets. It also uses the same routines used by Mirai\n\n and targets IoT devices with embedded Linux OS and busybox installed. For its vulnerability\n\n attack, KiraV2 mainly targets two types of devices: MVPower DVR with JAWS Web Server\n\n installed and Huawei routers.\n\n Commonly, Mirai malware uses telnet brute-force attacks, also known as telnet dictionary\n\n attacks, against vulnerable devices to obtain sensitive information, such as account\n\n information, to login and download malware from external sources. However, analysis on\n\n recently distributed variants revealed that Mirai's variants have the feature of spreading\n\n themselves to vulnerable devices using remote code execution vulnerability. Likewise, KiraV2\n\n also has an added remote code execution vulnerability attack routine for distribution.\n\n Typically, Windows OS installed in desktops and servers are based on x86 and x64 CPU\n\n architecture. To match this, malware that target Windows are created as executables in a PE\n\n format to target x86 and x64 architecture. However, embedded Linux installed in IoT devices\n\n support various CPU environments, and malware that target these environments must be able\n\n to target not only x86 and x64, but also various other architecture, such as arm, mips, m68,\n\n sparc, and sh4.\n\n\n-----\n\n##### To support these various architecture, Mirai uses uClibc cross compiler. To build a malware that\n\n targets Linux server and desktop environments, glibc is commonly used. However, since Mirai\n\n targets embedded Linux, uClibc-based cross compiler was used.\n\n Same goes for KiraV2; uClibc-based cross compiler was used to develop KiraV2. Current\n\n analysis sample is based on ELF binary of x86 architecture, but Mirai-type malware are cross\n compiled and spreads to other architecture, such as arms and mips.\n\n As mentioned above, along with their interaction with architecture and library, one of the\n\n key characteristics of an IoT malware is the way in which it was built. When building the\n\n library dynamically, the malware cannot run normally unless there is a dynamic library, such\n\n as the uClibc in the distribution target. Thus, most of the malware that targets IoT devices are\n\n distributed with static libraries.\n\n 2. Attack Flow\n\n Now, let's compare the execution method and attack flow of Mirai and it's variant, KiraV2. As\n\n shown in Figure 1, KiraV2’s attack flow has an added vulnerability distribution stage that does\n\n not exist in Mirai.\n\nFigure 1. Attack flow of KiraV2\n\n\n-----\n\n##### Key Features per Phase\n\n a. Bot\n\n .... a.1. Reset: Mirai and KiraV2 encode and store most of the strings, including the C&C server\n\n address, and decrypt the strings for future use. To do this, they first reset the encoded strings.\n\n There are also other routines in which the strings can be executed via the analysis disruption\n\n technique and daemon process.\n\n .... a.2. Keep Alive: Prevents system reboot via watchdog.\n\n .... a.3. Terminates Other Malware: Searches for process name and delete processes with\n\n specific names of the existing malware.\n\n .... a.4. Distributed Denial-of-Service Attack (DDoS): Supports various types of DDoS attacks,\n\n such as TCP Ack Flooding and UDP Flooding.\n\n .... a.5. Distribution: Launches dictionary attack on IoT devices with vulnerable account\n\n information (ID/PW). KiraV2 adds a distribution routine that uses remote code execution\n\n vulnerability in addition to Mirai’s distribution methods.\n\n b. C&C Server and DB Server\n\n .... b.1. C&C Server: Uses DB server to manage infected IoT servers. It can receive commands\n\n from attackers to perform DDoS attack commands on infected IoT devices.\n\n .... b.2. DB Server: Mirai uses DB server to manage various infected devices.\n\n c. Report Server and Loader\n\n .... c.1. Report Server: Sends key information, such as IP address of vulnerable IoT devices and\n\n account information, (ID/PW) received from the Bot to the Loader.\n\n .... c.2. Loader: Uses info on vulnerable IoT devices, received from report servers to login,\n\n download, and run additional malware. Original source code for Mirai uses wget, tftp, and\n\n echo to spread to other devices.\n\n\n-----\n\n##### Currently, KiraV2 can only secure the bot binary, but its operation method is similar to to that\n\n of Marai's. Because of this, it can be assumed that the C&C server DB server, report server and\n\n loader mechanism used by Mirai are also used by KiraV2.\n\n We went through KiraV2’s attack method using the attack flow chart of Figure 1. Now, let\n\n us take a closer look at the difference between Mirai and KiraV2 by going over the key\n\n characteristics of each malware per attack phase.\n\n 3. Reset\n\n 3.1. C&C Server Address\n\n Mirai hides the C&C address via anti-debugging technique using signal() function. signal()\n\n function is a function that is used to register handler function, which handles a specific signal.\n\n As shown in Figure 2, it registers function that returns the real C&C address as a handler\n\n for SIGTRAP signal. Afterward, to disrupt analysis, it acquires a fake C&C address. Before\n\n communicating with the C&C server, it uses raise() function to raise SIGTRAP signal and makes\n\n signal recipient invoke handler function, previously registered as signal() function, to return\n\n the real C&C address.\n\n By performing this action, even if the signal is raised via the raise() function during the\n\n analysis in the debugging environment, the signal will only be handled by the debugger and\n\n the handler function will remain hidden. If debugging is not involved, then Mirai normally\n\n executes the handler function that was previously registered to obtain the real C&C address.\n\nFigure 2. Registration of signal handler and fake C&C address\n\n\n-----\n\n##### KiraV2, on the other hand, uses the signal() function to register the handler for the SIGTRAP\n\n signal. However, instead of using the anti-debugging technique, which utilizes the raise()\n\n function, it directly importsthe hard-coded C&C address, as shown in Figure 3. It can be\n\n assumed that the developer of this malware did not consider the debugging routine realized\n\n in Mirai as a necessary feature. The C&C server address of KiraV2 malware is as follows:\n\n - C&C server address: 165.232.36[.]42:8985\n\nFigure 3. Hard-coded IP address\n\n##### 3.2. Anti-analysis Technique\n\n As explained in the previous section, KiraV2 and Mirai have different ways of approaching\n\n debugging techniques. On the other hand, they utilize the same anti-analysis technique of\n\n changing the process name. In order to check the process name, command ps can be used.\n\n Otherwise, procfs, which is a /proc file of Linux that contains process and system information\n\n can be looked up.\n\n The routine of changing process name is shown in Figure 4. It first creates a random data and\n\n changes the string located at argv[0] inside the memory of a process. Afterward, ‘ps’ command\n\n or ‘cat /proc/$pid/cmdline’ command result can be used to check the process name, which\n\n has been changed to a new value.\n\n\n-----\n\nFigure 4. Process name change routine\n\n##### The second method is using the prctl() function. The malware sets and sends PR_SET_NAME,\n\n which is an option for changing process name and random name as parameters of ‘prctl()’\n\n function. Afterwards, command results of process names, such as ‘cat /proc/$pid/comm’ and\n\n ‘cat /proc/$pid/stat,' changes to random values, as shown in Figure 5.\n\nFigure 5. Process names that have randomly changed values in “/root/Desktop/test”\n\n\n-----\n\n##### 3.3. Reset String\n\n Mirai encodes and stores most of the strings. It decodes them and uses them only when they\n\n are needed. The strings include the C&C server address/port no., report server address/port\n\n no. and strings used later on in the stage. KiraV2, on the other hand, encodes and stores port\n\n no. of the C&C server and report server, but does not encode server address. Instead, it stores\n\n them hard-coded. Along with the previously confirmed C&C server, the address of the report\n\n server is also hardcoded. Figure 6 is an encoding table of KiraV2.\n\nFigure 6. Encoding table\n\n1. 0x2319 11. /bin/busybox ps 21. /etc/resolv.conf 31. X19I239124UIU\n\n2. 0x2501 12. assword 22. nameserver 32. 14Fa\n\n3. KiraV2 13. ogin 23. /dev/watchdog 33. %s %s HTTP\n\n4. shell 14. enter 24. /dev/misc/watchdog 34. IuYgujeIgn\n\n5. enable 15. /proc/ 25. /dev/FTWDT101_watchdog 35. dlr.\n\n6. system 16. /exe 26. /dev/FTWDT101 watchdog 36. .arm\n\n7. sh 17. /fd 27. /dev/watchdog0 37. .mips\n\n8. /bin/busybox DEMONS 18. maps 28. /etc/default/watchdog 38. .mpsl\n\n9. DEMONS: applet not found 19. /proc/net/tcp 29. /sbin/watchdog 39. .x86_x64\n\n10. ncorrect 20. Tsource Engine Query 30. dvrHelper 40. .x86\n\n41. Etc. (Dummy data)\n\nTable 1. List of encoded data by number\n\n|11. /bin/busybox ps|21. /etc/resolv.conf|\n|---|---|\n|12. assword|22. nameserver|\n|13. ogin|23. /dev/watchdog|\n|14. enter|24. /dev/misc/watchdog|\n|15. /proc/|25. /dev/FTWDT101_watchdog|\n|16. /exe|26. /dev/FTWDT101 watchdog|\n|17. /fd|27. /dev/watchdog0|\n|18. maps|28. /etc/default/watchdog|\n|19. /proc/net/tcp|29. /sbin/watchdog|\n|20. Tsource Engine Query|30. dvrHelper|\n|||\n\n\n-----\n\n##### After using the string, it gets encoded back. This is an analysis disruption technique to prevent\n\n decoded strings from being checked even when dumping memory. The encoding routine is\n\n decoded via the same routine, as shown in Figure 7. This 4-byte key-value becomes XOR 1 byte\n\n at a time, so these strings are practically 1-byte XOR-encoded. The key here is 0xB33FD34D,\n\n but the key that encodes strings is 0x12 byte.\n\nFigure 7. Encoding algorithm\n\n##### 3.4. Standalone Execution\n\n Mirai and KiraV2 both use port numbers to execute standalone. Locally, the malware bind()\n\n port 9473 (0x2501), which is the port number for the local address. Whether other processes\n\n are currently using this port can be checked based on the result of this action. If failed, the\n\n malware assumes that the port is bound to other processes, and force terminates the process\n\n using this port number. If successful, the malware listen() and steals the port number.\n\n 3.5. Confirm Normal Execution\n\n If all the processes up to this point were normally run, Mirai prints ‘listening tun0’ string. The\n\n reason why original Mirai prints the string is because during distribution, telnet is used to\n\n execute the malware, and whether the bot was normally installed or not can be checked\n\n\n-----\n\n##### with the string it printed. In this regard, KiraV2 is just like Mirai except it prints ‘KiraV2’ string,\n\n designated by the attacker. This is the most unique aspect of KiraV2. This string is encoded and\n\n obtained after going through previously mentioned decoding function. Figure 8 shows the\n\n printed string and daemon of KiraV2.\n\nFigure 8. Printed KiraV2 string and daemon\n\n##### To to operate as a daemon process, KiraV2 performs fork(), authorizes new session, and close()\n\n STDIN, STDOUT, STDERR. Lastly, it runs these functions, periodically communicates with the\n\n C&C server, receives the command, and executes it. DDoS botnet receives DDoS attack targets,\n\n and attack techniques from the C&C server.\n\n 4. Prevent Reboot: Keep Alive\n\n Situation where IoT devices get unintentionally trapped inside an infinite loop do occur, and\n\n IoT devices use watchdog to prevent such issues. In an environment where watchdog timer\n\n is set, a routine where a program running in the system periodically resets counter value\n\n must be executed. If the system is in an undesirable situation, such as being trapped inside\n\n an infinite loop and no responses are taken, the timer count will reach its limit, resulting in\n\n watchdog rebooting the system and allowing the system to operate normally.\n\n\n-----\n\n##### Mirai deactivates this watchdog feature. Specifically, for /dev/watchdog and /dev/misc/\n\n watchdog, it gives WDIOC_SETOPTIONS (0x80045704) as parameter of ioctl() function and calls\n\n the function to deactivate watchdog, which prevents device from rebooting.\n\n As shown in Figure 9, KiraV2 additionally attempts to deactivate watchdog for /dev/\n\n FTWDT101_watchdog, /dev/FTWDT10 watchdog, /dev/watchdog0, /etc/default/watchdog, /\n\n sbin/watchdog. This means that KiraV2 targets more devices than Mirai does.\n\nFigure 9. Attempts to deactivate watchdog\n\n\n-----\n\n##### Additionally, after attempting to deactivate watchdog using WDIOC_SETOPTIONS (0x80045704),\n\n it visits iterations periodically as shown in Figure 10, gives WDIOC_KEEPALIVE (0x80045705) as a\n\n parameter of ioctl() function and calls the function to reset timer to prevent reboot.\n\nFigure 10. Watchdog timer reset iteration Figure 11. Name of target processes for force termination\n\n##### 5. Force Quit: Killer\n\n To deal with situation where IoT device is infected by another malware, Mirai looks up malware\n\n processes and force terminates matching ones. Q Bot and Zollard, were among the malware it\n\n targets. KiraV2, which was developed much later than Mirai, targets 321 IoT malware, including\n\n \"Tsunami,\" \"Owari,\" \"miori,\" \"Okami,\" and \"Omni,\" which are some of the malware that was\n\n previously distributed. Processes included in the targets, once names of these processes are\n\n found, all are force-terminated. Figure 11 shows the name of processes designated as a force\n\n termination target.\n\n\n-----\n\n##### 6. DDoS Attack\n\n Mirai malware has various DDoS attack functions stored, which is executed when the C&C\n\n server executes a DDoS attack against specific targets. Table 2 shows details regarding Marai's\n\n DDoS attack techniques.\n\nattack_udp_generic() UDP Flooding Attack.\n\nattack_udp_plain() UDP Flooding Attack Optimized for Speed.\n\nattack_udp_vse() VSE (Valve Source Engine) Query Flooding Attack Using UDP. Flooding TSource Engine Query in Game Server.\n\nattack_udp_dns() DNS Water Torture Attack.\n\nattack_tcp_syn() TCP SYN Flooding Attack.\n\nattack_tcp_ack() TCP ACK Flooding Attack.\n\nattack_tcp_stomp() TCP STOMP (Simple Text Oriented Messaging Protocol) Flooding Attack.\n\nattack_gre_ip() GRE (Generic Routing Encapsulation) IP Flooding Attack.\n\nattack_gre_eth() GRE Ethernet Flooding Attack.\n\nattacp_app_http() HTTP GET / POST Flooding Attack.\n\nTable 2. Mirai’s DDoS attack techniques\n\n##### DDoS attack functions defined in KiraV2 on the other hand, adds or removes certain attack\n\n methods, as shown in Table 3.\n\n\n-----\n\nTable 3. KiraV2’s DDoS attack techniques\n\nFigure 12. List of KiraV2’s DDoS functions\n\n##### Figure 12 shows KiraV2’s DDoS functions. Unlike other ordinary functions, attack_method_\n\n nudp() function is not a DDoS attack function, and it shows surprising similarity to that of the\n\n function introduced in the “UDP_BYPASS attack” section of the following analysis report.\n\n[Reference: https://www.trendmicro.com/en_us/research/19/l/DDoS-attacks-and-iot-exploits-new-activity-from-momentum\nBotnet.html]\n\n##### attack_method_nudp() function sends various service-related payloads, such as TeamSpeak,\n\n Ctrix, SNMPv3, SSDP, and RIP, to attack targets, as shown in Figure 13. All the payloads sent are\n\n\n-----\n\n##### packets with a purpose to check whether the services are operating in the target device. This\n\n means that when this function is called, packets that target each of the various services are\n\n repeatedly sent to target systems, and if matching services exist, the systems become loaded\n\n to handle the packets.\n\nFigure 13. Details of attack_method_nudp() function\n\n##### 7. Distribution Method\n\n Now, let's examine how the malware is being distributed. It may be one of the most important\n\n feature of all. Mirai first attempts to establish telnet communication with a random IP bandwidth.\n\n Afterward, it attempts to login by launching a dictionary attack that uses vulnerable password,\n\n such as “root / 12345,” and “admin / 1111,” targeting environment where telnet is installed. This\n\n shows that Mirai targets devices with vulnerable telnet account info.\n\n Upon successful login and confirming the installation of busybox, it sends IP and account info\n\n to the report server. Report server sends the result to loader, and loader uses this info to login\n\n and download additional malware.\n\n\n-----\n\n##### KiraV2 on the other hand, retains the distribution routine above as well as 2 additional\n\n vulnerability distribution features. It first uses sysconf(_SC_NPROCESSORS_ONLN) function to\n\n confirm the numbers of current CPU cores. If 2 or more CPU cores are found, it uses the telnet\n\n dictionary attack distribution method mentioned above. If there is only 1 CPU, it randomly\n\n selects one of the 2 vulnerability attacks and proceeds with the selected attack.\n\n###### Reference - Report Server and Loader\n\n AhnLab’s analysis sample is a bot, and information on the C&C server and report server were not found. But\n\n since the bot itself has a similar structure to Mirai, the original malware, it is assumed that the unconfirmed\n\n aspects also have a similar structure.\n\n When the bot from Mirai sends address and account info of vulnerable device to the report server, the\n\n report server sends the received info to loader. Loader is a feature that spreads the malware, and uses\n\n received address & account info to telnet login into a vulnerable device. After logging in, the 3 following\n\n methods are used to install Mirai.\n\n The first and the second method is using wget and tftp command provided by busybox. These are methods\n\n of using the commands that have external download features to download and run Mirai bot. The third\n\n method is using echo, and this is used when wget and tftp command cannot be used. It gives -ne with an\n\n option of echo command, and with parameter, designates and calls a small downloader malware payload\n\n that exists inside memory. Echo is a command to print strings, but in this case, it prints binary value,\n\n redirects the printed binary value to file path, creates a file, and then executes the created file.\n\n Malware that is created using echo is a small-sized downloader malware that only has the feature of\n\n externally downloading and running real bot. This method is the method of creating and running a\n\n downloader malware that is equipped with the external download feature like wget and ftp command. In\n\n an environment where programs, such as wget and ftp are non-existent, the malware can only use echo to\n\n send and create payload.\n\n\n-----\n\n##### 7.1. Telnet Dictionary Attack\n\n In this section, we will go over the telnet dictionary attack of KiraV2. Dictionary attack is near\n identical to the routine of Mirai. The difference is that it has a much smaller telnet account\n\n information list—that is used in dictionary attack—than Mirai, and that it uses ]DEMONS]\n\n strings rather than ]MIRAI] strings.\n\n Figure 14 shows account information used in telnet dictionary attack of KiraV2.\n\nFigure 14. Account info used in telnet dictionary attack\n\n( admin / admin ), ( root / vizxv), ( root / admin ), ( root / Zte521 ), ( default / 없음 ), ( default / OxhlwSG8 ), ( default / S2fGqNFs ), (\n\ndefault / lJwpbo6 ), ( support / support ), ( user / user ), ( guest / 12345 ), ( admin / 1234 ), ( root / hunt5759 ), ( root / 3ep5w2u )\n\nTable 4. List of ID/PW used in telnet dictionary attack\n\n##### Note that Mirai only targets IoT devices where busybox is installed. It performs telnet login for\n\n the target, and once logged in, it runs “/bin/busybox MIRAI” command. Since a program ‘MIRAI’\n\n normally does not exist in busybox, running the command will most likely result in printing of\n\n the result value ‘MIRAI: applet not found.’ Whether busybox is installed can be checked via this\n\n result value since a different value will be returned, if busybox is not installed in a device.\n\n\n-----\n\n###### Note - busybox\n\n IoT devices often use embedded Linux OS. Unlike desktop and Linux OS for server, it is challenging for\n\n embedded Linux to support diverse commands as its resources are limited. Therefore, all systems with\n\n embedded Linux environment have a utility program that supports Linux commands called busybox. User\n\n access this program to find necessary commands. Therefore, Mirai only targets environment where busybox\n\n is installed. If busybox is not installed, commands that are used to spread the malware following telnet\n\n connection are not supported and this can significantly affect the success of distribution.\n\n##### Figure 15 shows KiraV2’s routine that checks whether busybox is installed. In case of KiraV2,\n\n it runs ‘/bin/busybox DEMONS’ command instead of ‘/bin/busybox MIRAI’ command, and\n\n following this, the scan result value is ‘DEMONS: applet not found’ instead of ‘MIRAI: applet not\n\n found.’\n\nFigure 15. KiraV2’s routine that checks whether busybox is installed\n\n##### The final difference is that in Mirai, address and port no. of report server are encoded, but\n\n in KiraV2, just like C&C server, IP address of report server is hard-coded, and only port no. is\n\n encoded. Figure 16 shows KiraV2’s routine of finding report server address. To use IP address\n\n\n-----\n\n##### as parameter of function, it needs to be converted first. The attacker however, used this string\n\n without converting it. Because of this, the string’s address 0x08056e51 inside memory, or IP\n\n address “81.110.5.8” becomes the connection address instead of IP address “131.153.18.72.” It\n\n can be assumed that this is not an intentional trick, but rather, a developer’s mistake. KiraV2\n\n malware’s report server address is as follows:\n\n - The report server address assumed to be the attacker’s target: 131.153.18[.]72:9473\n\n - The actual report server address that the malware attempts to connect: 81.110.5[.]8:9473\n\nFigure 16. Routine to find report server address\n\n##### 7.2. CVE-2017-17215: Remote Command Execution Vulnerability\n\n CVE-2017-17215 vulnerability is a remote command execution vulnerability that exists in the\n\n Huawei router. This is a vulnerability that allows the attacker to send modified packet to the\n\n vulnerable device and execute the commands remotely.\n\nFigure 17. Packet used to attack the vulnerability in the Huawei router\n\n\n-----\n\n##### Figure 17 shows the real command and a part of the packet used to attack vulnerability of a\n\n Huawei router that causes the CVE-2017-17215 vulnerability. The command is quite explicit in\n\n that it uses wget of busybox to download malware from external source and executes it.\n\n Additionally, the characteristic of the device targeted for distribution can be checked via\n\n this command. Seeing how it uses busybox to run wget command, it can be assumed that\n\n busybox is installed by default in the target device. Furthermore, seeing that the extension\n\n of the malware downloaded via wget is mips, it can be assumed that the architecture of the\n\n device is mips. The current analysis sample is built based on x86 architecture, but analysis of\n\n mips malware of url showed that its feature is the same as the malware of x86 architecture,\n\n with the only difference being the architecture.\n\n The first action that bot performs when it is run in Mirai is self-deletion using unlink() function.\n\n However, KiraV2 does not have a self-deletion routine. Remote code execution routine instead\n\n shows that it runs command and deletes sample, not the binary.\n\n 7.3. JAWS Web Server Remote Command Execution Vulnerability\n\n JAWS Web Server remote command execution vulnerability is a remote command execution\n\n vulnerability that exists in devices related to MVPower DVR. Similar to CVE-2017-17215\n\n vulnerability mentioned above, it can execute certain commands remotely.\n\nFigure 18. Packet used to attack JAWS Web Server vulnerability\n\n\n-----\n\n##### Figure 18 shows a packet used to attack JAWS Web Server vulnerability. The difference from\n\n the previously mentioned vulnerability routine is that wget will be directly installed in the\n\n target device instead of busybox, and that the architecture of the downloaded binary is arm.\n\n Following this, it can be concluded that the sample built with ARM architecture has the same\n\n feature with the only difference being the architecture.\n\n 8. Conclusion\n\n IoT industry is rapidly growing and the number of IoT devices, such as DVR, router, and IP\n\n camera, are growing as well. Most of these devices are connected to the external network,\n\n which is being targeted by numerous threat actors for exploitation. Many of the devices are\n\n already infected, forming botnets and being exploited for DDoS attacks, which could be\n\n detrimental to IT infrastructures.\n\n To prevent these security threats from damaging devices, users must act soon. In other words,\n\n users must change the default ID and password, provided with the device purchase, to protect\n\n their data and login credentials. Furthermore, users must consistently update their IoT devices\n\n to the latest version to prevent vulnerability attacks.\n\n AhnLab’s anti-malware product, AhnLab V3, detects Mirai malware using the following alias:\n\n - Worm/Linux.Mirai.SE189\n\n\n-----\n\n#### Report Vol.100\n\nContributors **ASEC Researchers**\n\nEditor **Content Creatives Team**\n\nDesign **Design Team**\n\n\nPublisher **AhnLab, Inc.**\n\nWebsite **www.ahnlab.com**\n\nEmail **global.info@ahnlab.com**\n\n\nDisclosure to or reproduction for others without the specific written authorization of AhnLab is prohibited.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/Report/AhnLab/ASEC_REPORT_vol.100_ENG.pdf"
    ],
    "report_names": [
        "ASEC_REPORT_vol.100_ENG"
    ],
    "threat_actors": [
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716495,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1602509130,
    "ts_modification_date": 1602509132,
    "files": {
        "pdf": "https://archive.orkl.eu/dd71e034b730cc673712b1c34759f6d8a08e85d7.pdf",
        "text": "https://archive.orkl.eu/dd71e034b730cc673712b1c34759f6d8a08e85d7.txt",
        "img": "https://archive.orkl.eu/dd71e034b730cc673712b1c34759f6d8a08e85d7.jpg"
    }
}