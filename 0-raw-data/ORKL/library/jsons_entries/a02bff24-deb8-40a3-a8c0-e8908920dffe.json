{
    "id": "a02bff24-deb8-40a3-a8c0-e8908920dffe",
    "created_at": "2023-01-12T15:05:22.107446Z",
    "updated_at": "2025-03-27T02:05:39.598049Z",
    "deleted_at": null,
    "sha1_hash": "3ff78b09ccc6e7aa0f05b7e06f8b201235cca61a",
    "title": "2018-03-28 - Dissecting Olympic Destroyer ‚Äì a walk-through",
    "authors": "",
    "file_creation_date": "2022-05-28T16:00:05Z",
    "file_modification_date": "2022-05-28T16:00:05Z",
    "file_size": 450702,
    "plain_text": "# Dissecting Olympic Destroyer ‚Äì a walk-through\n\n**[cyber.wtf/2018/03/28/dissecting-olympic-destroyer-a-walk-through/](https://cyber.wtf/2018/03/28/dissecting-olympic-destroyer-a-walk-through/)**\n\n## Introduction\n\n\nMarch 28, 2018\n\n\nAfter a destructive cyber attack had hit this year‚Äôs olympics, the malware was quickly dubbed\n_Olympic Destroyer._ [Talos were fast to provide initial coverage. A malware explicitly designed](https://blog.talosintelligence.com/2018/02/olympic-destroyer.html)\nto sabotage the computer systems of the Olympic opening ceremony sounded very\ninteresting, but other duties were more pressing at that time, so analysis for pure curiosity\nhad to wait. A few weeks later I had some free evenings on my hands and decided to\ncombine a few interests of mine: Listening to music, consuming high quality whisky and\nanalyzing malware ‚Äì regrettably one of those things is frowned upon at work, and it‚Äôs not\nmalware analysis. üòâ\n\nI had most of the binaries reversed and already written up a few pages, when Kaspersky\nreleased an article with some more details than previously publicly known. Having finished\nmy work and focusing on the technical aspects of Olympic Destroyer, I think I can add\nseveral technical details about the malware. In the following expect plain and straight-forward\nbinary analysis and reverse engineering in the form of a walk-through.\n\nOlympic Destroyer comes in two types. The first one is a little bit simpler. It was discovered\nby Talos, who published it in their comprehensive blog post. One example of this type has\nthe Sha256 of edb1ff2521fb4bf748111f92786d260d40407a2e8463dcd24bb09f908ee13eb9.\n\n\n-----\n\nThe second type of the binary has, to the best of my knowledge, not yet been explicitly\nnamed, but it was implicitly analyzed by Kaspersky in their also very comprehensive blog\npost. One example has the Sha256 sum of\ne8349cfcc422310c259688b0226cb14f5196a6daad77b622405282aeac89ab06.\n\nIn the following blog post I will mainly describe the first type of Olympic Destroyer. At the end\nI will discuss the main differences between the two types, which revolve around the usage or\nnon-usage of the well-known tool PsExec.\n\n## The Orchestrator\n\nIn this part we will cover the innermost functionality of the Olympic Destroyer. As orientation\npoint we will use the main() function, from where on we will cover the single function calls\nstep by step. Luckily Olympic Destroyer runs single threaded ‚Äì except for the spreading\nfunctionality ‚Äì which makes it easier to follow the execution one call after another.\n\nThe analyzed orchestrator has a Sha256 of\nedb1ff2521fb4bf748111f92786d260d40407a2e8463dcd24bb09f908ee13eb9 and is\n0x1C6800 (~1.7MB) in size. A lot of this size is made up of five resources, whose role will be\nexplained later on. IDA detects 756 functions of which not even ten were automatically\nidentified by IDA FLIRT in version 6.9, which made the analysis more time consuming. IDA\nversion 6.95 seems to have a newer FLIRT database and a lot of functions are identified\nautomatically, as I realized way too late.\n\n## Configuration ‚Äì or not\n\nThe main() function is located at 0x004071E0. It creates a structure on the local stack, which\nI called ‚Äúconfig‚Äù when starting to reverse the binary. Over the time I discovered that it is\nmerely a state or a singleton data container ‚Äì nonetheless I kept the name ‚Äúconfig‚Äù for\nreasons of consistency. This structure is carried throughout many of the subsequent function\ncalls, most of the time in the form of thiscalls in the ecx register. You can find the whole\nstructure in the appendix section below.\n\nIt contains different type of data, like simple integers, which for example describe the bitness\nof the OS with either the value 32 or 64 by dynamically resolving and calling\n_IsWow64Process. Yes, the author(s) actually use full integers instead of encoding this_\ninformation in a simple bit ¬Ø\\_(„ÉÑ)_/¬Ø.\n\n\n-----\n\nDetecting the\n\nbitness of the system\nMore interesting are probably the different paths of files dropped to the filesystem during\nruntime, which are also stored in this structure. I will describe them when writing about the\nresources.\n\nAdditionally, we find some security related variables, like the security token information of the\ncurrent user, which is gathered by calling GetTokenInformation(TokenUser) and comparing\nthe result against ‚ÄúS-1-5-18‚Äù (Local System), ‚ÄúS-1-5-19‚Äù (NT Authority Local Service), and ‚ÄúS1-5-20‚Äù (NT Authority Network Service).\n\nMost important is probably the vector of objects, which contains domain names and domain\ncredentials, that are used to spread laterally through the network. More about this later on\nwhen I will cover the lateral movement.\n\nAfter the config structure is initialized in 0x00406390 by nulling its members, it is dynamically\nfilled with its respective values in the subsequent call to 0x00406500, where most of the\npreviously mentioned values and information is generated. From then on, the config is ready\nfor use and most values are only read instead of written ‚Äì except for the file paths, which are\ngenerated more or less randomly on the fly when used and of course the credential vector,\nwhich gets expanded a few calls later.\n\n## Magical Code Injections\n\nWith a call to 0x004066C0 Olympic Destroyer checks for the existence of two files, which it\nuses to mark and avoid multiple runs of itself:\n\n1. C:\\<MD5(Computer Name)>\n2. %SystemDrive%\\Users\\Public\\<MD5(Computer Name\\User Name)>\n\nIf one of those files is found, the function which I called ‚ÄúselfDeleteInjectBinary‚Äù at\n0x00405DD0 is executed. Most of this function is already described in Endgame‚Äôs blogpost\nat https://www.endgame.com/blog/technical-blog/stopping-olympic-destroyer-new-process\n\n-----\n\n[injection-insights, but somehow they either misinterpreted the feature, or missed the main](https://www.endgame.com/blog/technical-blog/stopping-olympic-destroyer-new-process-injection-insights)\npoint of the shellcode. I‚Äôm not sure what their intention was, but their blog post somehow\ndoes not say what the shellcode actually does ¬Ø\\_(„ÉÑ)_/¬Ø.\n\nOlympic Destroyer starts an invisible ‚Äúnotepad.exe‚Äù by using the flags\n_CREATE_NO_WINDOW in dwCreationFlags as well as STARTF_USESHOWWINDOW in_\n_StartupInfo.dwFlags and SW_HIDE in StartupInfo.wShowWindow before calling_\n_CreateProcessW._\n\nStarting an invisible Notepad\nThen it injects two blocks of data/code into the running notepad by calling VirtualAllocEx and\n_WriteProcessMemory. The first block contains addresses of APIs and the path to the current_\nexecutable, the second one is a shellcode which uses the addresses of the first block. By\ncalling CreateRemoteThread the execution of the shellcode within notepad is started.\n\nAfter this injection, the main process exits by calling ExitProcess while the execution of the\ninjected thread runs in the process space of notepad. But all the shellcode does, is a simple\ndelayed self-deletion mechanism:\n\nFirst it sleeps a configurable number of seconds. In our case it is five seconds. After that, the\nshellcode looks for the original path of Olympic Destroyer, which was passed by the first\ninjected memory block by checking GetFileAttributesW != INVALID_FILE_ATTRIBUTES.\nThen it tries to open the file with CreateFileW, gets the file size by calling GetFileSize and\nthen loops over the file size and calls WriteFile with always one zero byte until the whole file\nis overwritten with zeros. After closing the file handle, the file is finally deleted with DeleteFile\nand the shellcode calls ExitProcess to end its execution.\n\nTo sum it up: The code injection is simply a nulling and deletion mechanism to hide the\ntraces of the main binary.\n\n## Setting the markers for self-deletion\n\n\n-----\n\nThe two files, which mark multiple runs of Olympic Destroyer, mentioned in the previous\nparagraph, are then created:\n\nCreate infection markers\n\nDepending on the rights under which the binary is running, the markers in C:\\ and\n%COMMON_DOCUMENTS% are created. From then on, a second run of Olympic\nDestroyer will wipe the original executable.\n\n## Stealing credentials\n\nIn the following call to 0x004065A0, we will dive into a very important feature of Olympic\nDestroyer: The stealing of credentials from the current system, which are later used for\nlateral movement.\n\nOlympic Destroyer contains five resources of type ‚ÄúBIN‚Äù. All of those resources are\nencrypted with AES. The calculation of the key is hard coded in the binary and can be\ndescribed as a trivial MD5 hash of the string ‚Äú123‚Äù. This hash is then concatenated twice in\norder to reach a key length of 256 bits for the AES algorithm. The evaluation of whether\nthose shenanigans of symmetric cryptography with a hard coded key makes sense is left as\nan exercise for the reader. üôÇ\n\nWhen stealing the credentials, at first the resource 101 is decrypted, written to a more or less\nrandomly generated filename in %tmp%. ‚ÄúMore or less‚Äù because the algorithm is based on\ncalls to GetTickCount() with Sleeps in between the calls.\n\nAfter writing the decrypted resource to disk, a proper random string is generated by calling\n_CoCreateGuid. The GUID is then used as the name for a named pipe in the form \\\\.\\pipe\\,_\nwhich is created by calling CreateNamedPipeW and then used as inter process\ncommunication mechanism with the process, which is then started from the file written to\n%tmp%.\n\n### Resource 101\n\nWhen resource 101 is started, it also gets the name of the pipe to communicate with its\nparent process as well as the password ‚Äú123‚Äù as arguments. The main task of resource 101\nis to use the password to decrypt and execute another resource of type ‚ÄúBMP‚Äù embedded in\nthe file of resource 101 and send a buffer with stolen credentials to its parent process. So, it‚Äôs\na simple loader which transfers a buffer via IPC.\n\nThe BMP resource is a DLL called ‚ÄúBrowserPwd.dll‚Äù. This DLL is not written to disk but\nparsed and loaded in memory. It seems that its only purpose is to steal credentials from the\nbrowsers Internet Explorer, Firefox and Chrome. In order to work with Firefox and Chrome,\nan SQLite library is compiled into the DLL which makes up most of the DLL‚Äôs code\n\n\n-----\n\nFor Internet Explorer it uses COM to iterate over the browsers history and then reads\nall autocomplete passwords from the registry in Software\\Microsoft\\Internet\n_Explorer\\IntelliForms\\Storage2 and decrypts them using the WinAPI_\n_CryptUnprotectData._\nFor Firefox, the credentials are stolen from sqlite and logins.json. The nss3.dll from\nFirefox is used to decrypt the protected passwords.\nFor Chrome, the user‚Äôs database in [‚Ä¶]\\Application Data\\Google\\Chrome\\User\n_Data\\Default\\Login Data is copied temporarily and then the credentials are read and_\ndecrypted by calling the WinAPI CryptUnprotectData.\n\nAll stolen credentials are returned in a buffer which uses a special style of separating the\nsingle items. This buffer is constructed within the DLL and returned to its original loader,\nwhich is resource 101:\n\nStolen credentials are formatted in a certain way\nThis buffer is then sent from the loader via the named pipe to its parent process:\n\n\n-----\n\nThe loader of resource 101 uses the names pipe to transfer the buffer with the stolen\ncredentials\n\n### Resource 102 and 103\n\nAfter resource 101 was executed, a second attempt to steal credentials is started, in case\nthe current process could acquire debug privileges during initialization of the config object. In\ncase it has those right, depending on the architecture of the operating system, either\nresource 102 (x86) or 103 (x64) is started. Both executables have the same logic as\nresource 101 ‚Äì decrypt and load a DLL in memory, execute the DLL and return its buffer via\nIPC ‚Äì only the payload in form of their internal DLL, the resource of type ‚ÄúBMP‚Äù, is different.\nEverything else stays the same.\n\nSo, the question is, what are the DLLs in the resources of resource 102 and 103? For 103,\nthe x64 version, I did not look into it in order to save some time, but I assume it‚Äôs the very\nsame payload as in 102, only for x64 systems. For 102, which is an x86 binary, the loaded\ninternal DLL seems to be a custom version of the well-known penetration testing tool\nMimikatz, which, besides other nifty features, can dump credentials from a Windows system.\nI did not spend too much time in the analysis of this DLL, but a swift look (as in ‚Äú1-2 hours‚Äù),\ncompared with several matching functions, structures and strings from the original code of\nMimikatz are strong indicators that this DLL has actually Mimikatz‚Äô credential dumping\ncapability. This assumption was also verified by dynamic analysis, where the binary was\nactually stealing the credentials of my analysis machine. Additionally, the author(s) of\nOlympic Destroyer named this DLL ‚Äúkiwi86.dll‚Äù, which is a reference to the nickname\n‚Äúgentilkiwi‚Äù, who is the author of Mimikatz.\n\n\n-----\n\nAfter receiving the stolen credentials via the named pipes, Olympic Destroyer parses the\nreceived buffers and saves the credentials in its config structure. Then it returns its control\nflow to the main function.\n\n## Saving the Credentials ‚Äì Or how to build a network worm\n\nBack in the main function, right after stealing credentials from browsers and by the power of\nMimikatz, Olympic Destroyer creates a copy of itself in the %tmp% folder in 0x00404040. If\nthis copy succeeds, the copied file is modified in the next function call to 0x00401FB0. Here\nthe whole file is read into a buffer in the process‚Äô memory. Then this buffer is searched for\nthe byte marker 9E EC 87 D4 89 16 42 09 55 E2 74 E4 79 0B 42 4C. Those bytes mark the\nbeginning of the serialized credentials vector as an array:\n\nHex\n\ndump of Olympic Destroyer\nI tried to mark the single elements of the array in different colors to describe them, but it turns\nout my MS Paint skills are really bad. So, you‚Äôll just get a two pseudo structs defining what\nyou can see around the red marked bytes:\n\n_struct credentials_\n\n_{_\n_byte marker[16];_\n\n_WORD numberOfElements;_\n\n_CREDENTIAL credentialArray[numberOfElements];_\n\n_};_\n\n_struct CREDENTIAL_\n\n_{_\n_WORD lengthOfUsername;_\n\n_WORD lengthOfPassword;_\n\n_char userName[lengthOfUsername];_\n\n_char password[lengthOfPassword];_\n\n_}_\n\nIn our case there are 0x2C stolen credentials. The first block of credentials has a\n_username\\domain string of 0x1B bytes length and has a password of 0x0C bytes length._\nThen the second block of credentials follows, and so on.\n\n\n-----\n\nOnce Olympic Destroyer has located the array in its buffer, the array is written over with the\nserialized version of the current credentials vector of the config object. Then the executable\nmodified in memory is written back to disk in the %tmp% directory.\n\nIn other words: The list of credentials, which was present when Olympic Destroyer was\nexecuted first, is now updated with all credentials stolen during runtime.\n\n## Resource 104 and 105 ‚Äì Preparing the next steps\n\nAfter updating a copy of itself with all stolen credentials, the execution flow returns to the\nmain function where two consecutive calls to 0x00403F30 prepare the network spreading\nalgorithm and the destructive parts. Both calls take a resource name as a first parameter for\ninput and return a string with a path to a file. In this function Olympic Destroyer takes the\nsame decryption algorithm as previously described and decrypts the resources 104 and 105.\nBoth files are not yet executed but written to disk with a random filename in the %tmp%\nfolder.\n\nResource 104 is a simple copy of the well-known tool ‚ÄúPsExec‚Äù which can be used to\nexecute commands and files on remote computers. It will come into play when I describe the\nlateral movement.\n\nResource 105 though is the actual ‚ÄúDestroyer‚Äù of Olympic Destroyer.\n\n## Starting the Destroyer ‚Äì Fulfilling the real purpose\n\nAfter writing resource 104 and 105 to %tmp%, the function at 0x00404220 is called with the\npath to resource 105 as an argument. Here nothing magical happens. The file from the\nresource is simply executed without a visible window/console and the function returns:\n\n\n-----\n\nStarting an invisible process\nFrom here on the destroyer from resource 105 is running. It has its own chapter later on.\n\n## Lateral Movement\n\nOnce the destroyer part of Olympic Destroyer has been started in its own process, the main\nfunction calls 0x00406ED0 to start the network spreading routine.\n\nAt first two sanity checks are made by calling GetFileAttributesA in order to ensure that\nPsExec from resource 104 and the copy of Olympic Destroyer with the updated credentials\nlist in the %tmp% folder exist. If both checks pass, a list of potential targets within the local\nnetwork is built:\n\nWith a call to 0x00406DD0 Olympic Destroyer utilizes the GetIpNetTable API to enumerate\nall IPv4 addresses of the current ARP cache, thus getting all IP addresses the local machine\nhad access to ‚Äì considering ARP cache timeouts which can remove older entries, of course.\n\nThe list of IPv4 addresses is then passed to the function at 0x004054E0, along with a pointer\nto the config object as well as the path to PsExec and the updated copy of Olympic\nDestroyer in the %tmp% folder. I think it is noteworthy that passing both paths to the files in\n%tmp% is completely superfluous, since they are already a part of the config object, which is\nalso passed as argument.\n\nThe function at 0x004054E0 is the heart of the spreading algorithm:\n\nFirst, it reads the updated copy of Olympic Destroyer into memory. Then it initializes a new\nstructure with all information passed as arguments as well as some additional information,\nwhich is somehow not really used later on. After that it calls 0x00407680, where the\n\n\n-----\n\nspreading in the network begins:\nFor each IP address, a new thread is spawned, which starts at 0x00407D40. This thread\nthen loops over all credentials of the config object, trying to use WMI via COM objects in\norder to infect remote computers:\n\nRemote command execution\nThe first important function for that is at 0x004045D0 (called executeRemoteCmdline), which\ngets one IP and one pair of credentials as input, as well as one command line to execute on\nthe target machine ‚Äì outPtr is used to transport the return value. The whole function is a\nmess of COM calls, but I‚Äôll try to explain their meaning anyways. Words in italic are quotes\nfrom the binary:\n\nThis function creates a COM object of CLSID {4590F811-1D3A-11D0-891F-00AA004B2E24}\nand IID {dc12a687-737f-11cf-884d-00aa004b2e24} in order to remotely execute WMI\ncommands. Then a connection to \\\\\\root\\CIMV2 is created and the credentials are applied by\ncalling CoSetProxyBlanket. With the class Win32_Process and the function Create a\n_Commandline is executed on the remote computer. With ‚ÄúSelect * From_\n_Win32_ProcessStopTrace‚Äù the event for the termination of the remote process is registered_\nin order to read its ExitStatus code afterwards.\n\nThe executed command line is rather simple:\n\n_‚Äúcmd.exe /c (ping 0.0.0.0 > nul) && if exist %programdata%\\\\evtchk.txt (exit 5) else ( type nul_\n\n_> %programdata%\\\\evtchk.txt)‚Äù_\n\nWith the execution of ping a short delay is introduced, since the execution waits for ping to\nfail four times to ping the address 0.0.0.0. Then, in case the file %programdata%\\evtchk.txt\nexists on the target system, the execution returns the exit code five. Otherwise said file is\ncreated and the execution finishes with its standard error code of zero.\n\nThe return value of the remote command line is then read and is returned via outPtr as a\nfunction argument from 0x004045D0. Interestingly the outPtr is only written to in case of a\nsuccessful remote execution. All error cases leave the outPtr untouched. As the memory\naddress of the target of outPtr is initialized with zeros, the caller of 0x004045D0 is unable to\ndistinguish between an error during the remote code execution (e.g. because of false\ncredentials or an unavailable IP) and the successful write of %programdata%\\evtchk.txt file\non the remote machine. ¬Ø\\_(„ÉÑ)_/¬Ø\n\n\n-----\n\nAt 0x00404C30 the second interesting function (called\n_writeFileToRemoteRegistryAndExecuteCommandlineVbs) is located. It takes the target IP_\naddress as well as the credentials as input. It is very similar to the function 0x004045D0\ndescribed previously. The main difference is that by using the StdRegProv class and the\nfunction SetBinaryValue a registry key in HKEY_CURRENT_USER\\Environment with the\nname Data is created on the remote computer. The value of the registry key an executable\nfile, but interestingly it is not the copy of Olympic Destroyer with the updated credential list in\n%tmp%, as I would have expected, but it is the binary which is currently executed and thus\ndoes not contain any of the current system‚Äôs credentials:\n\nThe remote spreading algorithm spreads the wrong binary\nAfter the binary is written to the remote registry, the function at 0x00404C30 calls the\nfunction at 0x004044B0. Here the function Create of the COM class Win32_Process is used\nto remotely execute another command line. This command line is already known from the\nTalos blog post. For readability I pretty-printed the commands:\n\n\n-----\n\n_cmd.exe /c_\n_(_\n_echo strPath = Wscript.ScriptFullName_\n_& echo.Set FSO = CreateObject^(\\‚ÄùScripting.FileSystemObject\\‚Äù^)_\n_& echo.FSO.DeleteFile strPath, 1_\n_& echo.Set oReg = GetObject^(\\‚Äùwinmgmts:_\n_{impersonationLevel=impersonate}!\\\\\\\\.\\\\root\\\\default:StdRegProv\\‚Äù^)_\n_& echo.oReg.GetBinaryValue ^&H80000001, \\‚ÄùEnvironment\\‚Äù, \\‚ÄùData\\‚Äù, arrBytes_\n_& echo.Set writer =_\n_FSO.OpenTextFile^(\\‚Äù%ProgramData%\\\\%COMPUTERNAME%.exe\\‚Äù, 2, True^)_\n_& echo.For i = LBound^(arrBytes^) to UBound^(arrBytes^)_\n_& echo.s = s ^& Chr^(arrBytes^(i^)^)_\n_& echo.Next_\n_& echo.writer.write s_\n_& echo.writer.close_\n_) > %ProgramData%\\\\_wfrcmd.vbs && cscript.exe %ProgramData%\\\\_wfrcmd.vbs &&_\n_%ProgramData%\\\\%COMPUTERNAME%.exe_\n\nThe first set of echos outputs parts of a VB script, which are then written to\n_%ProgramData%\\_wfrcmd.vbs by using the redirect operator ‚Äú>‚Äù. Afterwards this file is_\nexecuted via the cscript interpreter before the executable\n_%ProgramData%\\%COMPUTERNAME%.exe is executed. This executable is created during_\nthe runtime of the newly created VB script, which basically just reads the executable stored\nin HKEY_CURRENT_USER\\Environment\\Data and writes it to\n_%ProgramData%\\%COMPUTERNAME%.exe._\n\nBack in 0x00405170, the function at 0x004045D0 (executeRemoteCmdline) is called a\nsecond time. This time it removes the file %programdata%\\evtchk.txt, which was previously\nchecked or created on the remote computer by executing the command line ‚Äúdel\n_%programdata%\\evtchk.txt‚Äù._\n\nTo state the obvious, in case it got lost in all the text: %programdata%\\evtchk.txt is intended\nas a mutex object on the remote computer, which marks that a remote infection is currently\nongoing. This avoids that two computers running Olympic Destroyer‚Äôs infection routine infect\nthe same target at the very same time. Yet, as this file is deleted right after the infection, it\ndoes not avoid multiple infections of the same target in general, but only in parallel.\n\nWhile all previously mentioned remote infection threads are running, the main thread waits\nfor their termination by calling WaitForMultipleObjects, where it waits for all spawned threads\nto finish.\n\nOnce all threads are finished and back in the function 0x00406ED0, the control flow enters a\nloop, which iterates over all credentials and passes them to the function at 0x00406780. This\nfunction also has the purpose of enumerating network targets. Once again COM objects are\n\n\n-----\n\ninvolved:\nOne main part of this function is the call to NetGetDCName, which gets the name of the\nprimary domain controller. This name is formatted into the string ‚Äú%s\\\\root\\\\directory\\\\LDAP‚Äù\nin order to use it with the same COM objects as before during the remote code execution\n(CLSID {4590F811-1D3A-11D0-891F-00AA004B2E24} and IID {dc12a687-737f-11cf-884d_00aa004b2e24}) by using the credentials, which are passed as function arguments. If_\neverything works so far, the statement ‚ÄúSELECT ds_cn FROM ds_computer‚Äù is executed in\norder to get all computer names from the current domain. Then, for each computer, by calling\n_GetAddrInfoW and ntohl the domain names are resolved to IPs. A vector of IPs is returned_\nfrom 0x00406780. The IPs are then passed to the already known function at 0x004054E0 in\norder to infect those computers remotely.\n\nWhen this IP enumeration and remote infection loop is finished, some objects and memory is\ncleaned up before the control flow returns back to the main function.\n\n## Self-Deletion ‚Äì Or how to hide your traces, well, at least one of the many‚Ä¶\n\nThe last step in the main function, before freeing the remaining objects and memory, is the\ncall to the already described function ‚ÄúselfDeleteInjectBinary‚Äù at 0x00405DD0. This time the\nsleep interval is only three instead of five seconds. So the spawned process tries to wipe the\nbinary of the parent process every three seconds until it succeeds. The control flow of\nOlympic Destroyer then leaves the main function and the process exits, which will make the\nwiping of the binary possible.\n\nI think it is noteworthy that none of the other dropped files are deleted. Everything in %tmp%\nremains and also all infection markers described previously are still there.\n\n## The Destroyer\n\nA big part of this component‚Äôs functionality can be described in one picture by looking at the\nmain function:\n\n\n-----\n\nDestroyer main function\nAfter giving itself the SeShutdownPrivilege and bluntly ignoring all potential erroneous API\ncalls, the Destroyer calls the function at 0x00401000 (‚ÄúexecProcAndWaitForTerminate‚Äù) five\ntimes in a row in order to:\n\n1. Delete all shadow copies without prompt to avoid restoring the system\n2. Silently delete all backups created by the tool wbadmin\n3. Ignore all failures during boot and avoid starting the recovery mode\n4. Clear system logs\n5. Clear security logs\n\nThen the function at 0x004012E8 (‚ÄúdeactivateAllActiveServices‚Äù) is called. The name in the\nscreenshot is already a spoiler of the actual functionality: All services of the local computer\nare disabled. This is done by iterating over all possible types of services by calling\n_EnumServicesStatusW with the dwServiceType parameter set to 0x13F and dwServiceState_\nto SERVICE_STATE_ALL, and then calling ChangeServiceConfigW(SERVICE_DISABLED)\nfor each service.\n\nIn combination with the previously disabled recovery mode and deleted backups, this bricks\nthe local system on the next boot.\n\nBack in the main function a thread is spawned which executes the function 0x004016BF\n(‚ÄúwiperThread‚Äù). The main thread then sleeps for a fixed single hour before shutting down\nthe system ‚Äì no matter what the wiper thread did or didn‚Äôt do in the meantime. Note that this\nmight also interrupt the spreading routine of Olympic Destroyer, which might still run.\n\nThe first thing the wiper thread does is setting its own thread priority to\n_THREAD_PRIORITY_TIME_CRITICAL in order to get as much CPU cycles as possible._\nThen it recursively iterates over all available network resources with the APIs\n_WNetOpenEnumW and WNetEnumResourceW. Each available resource is temporarily_\n\n\n-----\n\nmounted by calling WNetAddConnection2W(CONNECT_TEMPORARY), yet the parameters\nfor the username and password are set to zero, thus the current user‚Äôs credentials are used.\nIt is important to note that the stolen credentials are not used here. This decouples the\nDestroyer logically from its parent process.\nFor each successfully mounted resource the function at 0x00401441 is called.\nThis function is also best described with a screenshot:\n\nRemote\n\nwiping functionality\nThis function simply iterates recursively over all folders, starting at the mountpoint which is\nprovided as an argument, and then destroys each single file that it finds:\n\n1. Files equal or smaller to 1MB in size are completely written over with zeros\n2. For files bigger than 1MB only the first 4096 bytes are nulled. Yet for most files this\n\nshould be enough to render them useless\n\n\n-----\n\nThe wiper thread does not communicate with the main thread and there is no\nsynchronization in any way. No matter if the wiping already finished or not, the system is shut\ndown after one hour.\nIt might be a simple mistake to shut the system down after a fixed time: The wiping may not\nhave wiped everything it can reach, or it could have already finished and the local computer\nis still useable until the shutdown. Additionally the remote spreading could still be ongoing.\n\nYet, I think it is more likely that this feature is a well-planned and sophisticated time bomb:\nImagine Olympic Destroyer spreading through a network, wiping all it could wipe for one\nhour, when suddenly one system after another shuts down and is unable to boot.\n\n## Different types of Olympic Destroyer\n\nAs mentioned in the introduction, I found two different types of Olympic Destroyer. The\nsimpler type was described previously. The second type has the very same functionality, it\nonly adds a few more functions. Those additional functions have the purpose of extending\nthe spreading functionality of Olympic Destroyer by leveraging PsExec, which was written to\n%tmp% but then ignored by the simpler version.\n\n## Using PsExec\n\nThe additional function call is placed right after writing/checking the file\n_%programdata%\\evtchk.txt and before the spreading function which uses COM objects and_\nspreads the version of Olympic Destroyer which was not updated with the stolen credentials.\nThis bugged behavior of spreading the wrong binary over COM exists in both versions.\n\nThe additional call to PsExec is done in the following way:\n\nFormat string for\n\ncalling PsExec\nPsExec is started with several parameters:\n\nThe first three parameter identify the target computer and the credentials which are\napplied\nThen the dialogue to confirm the EULA of PsExec is skipped with ‚Äúaccepteula‚Äù\n‚Äú-d‚Äù runs PsExec in a non-interactive way, which means that the caller does not wait for\nPsExec to terminate\n\n\n-----\n\nWith -s the remote process is started with System rights (in case the credentials allow\nthat)\n‚Äú-c‚Äù and ‚Äú-f‚Äù specify that the actually executed file is copied to the target computer and\noverwritten in case it already exists\nThe last parameter is the remotely executed file, which is obviously Olympic Destroyer\n\nThis time the remotely executed binary is the copy of Olympic Destroyer in %tmp%, which\nwas updated with the credentials stolen during the current run.\n\nThe output buffer returned from PsExec is parsed for the string ‚Äústarted‚Äù, which indicates to\nOlympic Destroyer that its call was successful. A successful remote infection using PsExec\nbreaks the loop which iterates over the credentials for a fixed target computer. Thus the\ntarget is only infected once and the bugged COM infection is avoided.\n\n## A crippled worm and a capable worm\n\nThe simple version of Olympic Destroyer has some spreading functionality, although it is\nbroken in the sense that the wrong binary is spread through the network. By not spreading\nthe updated version of Olympic Destroyer, which contains the credentials stolen during the\nrun, it loses a crucial part of its spreading capability:\n\nAssume we have a computer ‚ÄúA‚Äù with a logged in user who has the rights which allow remote\nspreading of Olympic Destroyer. And a computer ‚ÄúB‚Äù, which is in reach of A, but where no\nuser is logged in. A third computer ‚ÄúC‚Äù is only reachable over B but not over A.\n\nIf the simple version of Olympic Destroyer is executed on computer A, it will use the stolen\ncredentials to infect computer B. But on computer B there are no credentials to steal, so it\nwon‚Äôt be able to infect computer C.\n\nIn other words: The simple version of Olympic Destroyer can only spread to computers which\nare ‚Äúone hop‚Äù in distance.\n\nYet, in most cases this should still be enough to infect a whole network, since a central\nDomain Controller is usually connected to most computers in the network.\n\nSpreading the more advanced version including the stolen credentials gives Olympic\nDestroyer even better worming capabilities, since it gathers more and more credentials as it\nspreads further and further through a network.\n\nIn the previous example computer C could be infected from computer B by using the\ncredentials stolen on computer A.\n\n## Crunching some numbers\n\nIn order to verify my findings with the two versions of Olympic Destroyer, I grabbed 36\ndifferent samples which are identified as Olympic Destroyer and compared their sets of\nstolen credentials. One sample had and empty list of credentials, so I discarded it.\n\n\n-----\n\nIt turns out that 23 of those samples are from the simple version type. All of them contained\nthe same set of credentials, which were already described by Talos. They are for the\ndomains g18.internal and Pyeongchang2018.com. All of the samples contained additional\ncredentials stolen from various sandbox systems and virtual machines of researchers, who\nprobably uploaded the files from the %tmp% folder to Virus Total during their analysis.\n\nI could not find a single sample which contained only a subset of the credentials stolen from\nthe g18.internal and Pyeongchang2018.com domains. If you strip the credentials from\nsandboxes and researchers, all 23 samples contain the same set of crendetials. This\nsupports the findings that the simple version of Olympic Destroyer has a broken spreading\nalgorithm.\n\nIn contrast to that, 12 samples of the total 36 are from the ATOS network with the domain\n_ww930, as partially described by Kaspersky. Apparently the more capable version of Olympic_\nDestroyer was spreading here, thus the differences in the list of credentials is bigger. The\nfirst pair of credentials in this set can be found in all 12 samples. But the rest of the\ncredentials is a mix stolen from different computers in the same network. We can see that\nthe worm took different paths when spreading though the network, acquiring the credentials\nof at least five different computers.\n\nAfter removing the credentials from researchers and sandboxes, we are left with five unique\nsets of credentials. If one subset of credentials is one letter, the sets can be described as A,\nAB, AC, AD and ADE. This shows that the more capable version of Olympic Destroyer\nactually inherits its list of stolen credentials to the infected systems.\nThe samples in question are:\n\n1942f14326f8ffa3afc83946ba9ec06abe983a211939f0e58362f85dd2a6b96a\n25089ec24167f3caa413a9e1965c7dfc661219f45305187070a1e360b03f869c\n6d7d35b4ce45fae4a048f7e371f23d1edc4c3b6998ab49febfd7d33f13b030a5\n9085926d0beacc97f65c86c207fa31183c5373e9a26fb0678fbcd26ab65d6e64\n90c956e8983116359662f8b82ae156b378d3fae02c07a18827b4c65f0b5fe9ef\n\nIt is likely that there are more samples out there which give a better picture of the way\nOlympic Destroyer wormed itself through the ATOS network.\n\n## PE timestamps\n\nAs the blog article of Kasperky has already shown, the author(s) of Olympic Destroyer had\nquite the fun in planting false flags. So, the compilation time stamps of the PE files should be\ntaken with a grain of salt, as they can be easily forged.\n\nNonetheless they provide an interesting picture.\n\nSimple version of Olympic Destroyer, PE time stamps ordered ascending:\n\n\n-----\n\nName Compilation Time Stamp Description\n\nResource 104 2016-06-28 18:43:09 Copy of PsExec\n\nResource 105 2017-12-27 09:03:48 Destroyer\n\nDLL in Resource 101 2017-12-27 11:44:17 Browser Password Stealer\n\nDLL in Resource 102 2017-12-27 11:44:21 Windows Account Password Stealer\n\nResource 101 2017-12-27 11:44:30 Loader for internal DLL\n\nResource 103 2017-12-27 11:44:35 Loader for internal x64 DLL\n\nResource 102 2017-12-27 11:44:40 Loader for internal DLL\n\nMain binary 2017-12-27 11:44:47 Olympic Destroyer\n\n(Note that I did not extract the time stamp for the DLL in the resource of resource 103)\n\nThe PE time stamps of the more complex version in ascending order:\n\nName Compilation Time Stamp Description\n\nResource 104 2016-06-28 18:43:09 Copy of PsExec\n\nResource 105 2017-12-27 09:03:48 Destroyer\n\nDLL in Resource 101 2017-12-27 11:38:53 Browser Password Stealer\n\nDLL in Resource 102 2017-12-27 11:38:58 Windows Account Password Stealer\n\nResource 101 2017-12-27 11:39:06 Loader for internal DLL\n\nResource 103 2017-12-27 11:39:11 Loader for internal x64 DLL\n\nResource 102 2017-12-27 11:39:17 Loader for internal DLL\n\nMain binary 2017-12-27 11:39:22 Olympic Destroyer\n\nSome of those values actually make sense, although they might have been crafted in order\nto do so. The DLLs which are resources of resource 101 and 102 have to be compiled before\nthey can be embedded as resources, so their time stamps come first. The same goes for all\nresource which are embedded in them main binary of Olympic Destroyer.\n\nPsExec in resource 104 is the original copy of PsExec, thus has the original time stamp.\n\nA time difference of four to nine seconds for each binary sounds realistic, given only a few\ndependencies on external libraries. Unfortunately, the compilation with the biggest external\ndependencies, the DLL in resource 101 where SQLite is used, seems to be the first binary in\nthe build chain. This is where I would have expected to see the biggest gaps in between the\n\n\n-----\n\ntime stamps. But as it is the start of the build chain, we cannot compare it to any binary built\nbefore it.\nBy looking at the gaps, we can also see that everything except the destroyer part seem to be\ncompiled in one block.\nAlso the more complex version of Olympic Destroyer seems to be compiled five minutes\nbefore the simpler version. Most probably the attacker(s) just compiled the first set of\nOlympic Destroyer, before commenting out the one function using PsExec (implicitly\nremoving all the used sub-functions), and then recompiled the whole set.\n\nIt is noteworthy to point out that both versions of Olympic Destroyer use the very same copy\nof the destroyer component. Not only the compilation time stamps are the same, but also\ntheir hash sums.\n\n## Summary\n\nThis article has shown the innermost working of the malware called Olympic Destroyer. We\nhave seen that by pure reverse engineering of the malware samples, a plethora of\ninformation can be obtained and deduced.\n\nThe analysis indicates that Olympic Destroyer consists of two completely independent parts:\nThe first one is a framework for network spreading using resource 101 to 104 in order to\nspread as fast and as far as possible in the local network. The second one is the destructive\ncomponent. Both parts work completely independent from each other. Resource 101 to 103\nhave a strong logical dependency on the main binary by receiving the decryption key as well\nas the name of the named pipe as arguments. And the main binary depends on the\ninformation returned from the resources 101 to 103 formatted in a certain way. In contrast to\nthat, the destroyer in resource 105 is only dropped and executed in a fire and forget manor.\nNo arguments, return values or status codes are exchanged.\n\nSo I think it is correct to state that everything except the destroyer is merely a vehicle in form\nof a spreading framework to deliver a payload. And the delivered payload is the destroyer. In\ntheory every other payload could be delivered by simply exchanging the resource 105.\n\nWe have also seen that Olympic Destroyer comes in two different versions, which have been\nspread in two different networks. The spreading algorithm differs in the way that credentials\nstolen on one system are not carried on to the next infected system in one version.\n\nIt is unknown to me why the differences exist. Reading the Kasperky article indicates that the\nattackers already had a strong foothold in the g18.internal and Pyeongchang2018.com\nnetwork. So it might have been enough to spread only one hop from the initial infected\nmachine. This decision could also be influenced by the defensive mechanisms employed at\nthe targeted network. A proper network monitoring tool should mark the execution of PsExec\nas red flag, which might have been the reason to remove this part of the spreading algorithm.\n\nThe analysis of stolen credentials in the network of ATOS indicates that the attackers had a\nweaker foothold in the network, since, juding by the samples I looked at, only two sets of\n\n\n-----\n\ncredentials were stolen on the initial infection (compared to 44 in the simpler variant). All\nother credentials were added during the spreading in the network. This weak foothold might\nhave been the cause to go with a more aggressive spreading algorithm.\n\n## Appendix\n\nConfig structure as used in Olympic Destroyer:\n\n_struct config_\n\n_{_\n_DWORD credentialsVectorStart;_\n\n_DWORD credentialsVectorEnd;_\n\n_DWORD credentialsVectorMaxSize;_\n\n_CRITICAL_SECTION critSect;_\n\n_WSADATA wsadata;_\n\n_char ressourceHpath[1024];_\n\n_char randomTempPath[1024];_\n\n_char ressourceIpath[1024];_\n\n_char selfModulePath[1024];_\n\n_char domainName[256];_\n\n_char accountName[256];_\n\n_char domainAndAccountName[256];_\n\n_char v13[256];_\n\n_DWORD bitness;_\n\n_DWORD bVersionGreaterEqualVista;_\n\n_DWORD bVersionSmallerEqualXP;_\n\n_DWORD bHasSelfDebugPrivs;_\n\n_DWORD bIsServiceOrAdmin;_\n\n_DWORD bIsUserAccount;_\n\n_};_\n\nHashes used for analysis:\n\n\n-----\n\n_edb1ff2521fb4bf748111f92786d260d40407a2e8463dcd24bb09f908ee13eb9_\n_01e640a91d32230cd3f45e1594177393415585dbeba9ddbd31be2139935058d3_\n_137148fe8223bc88661ac941ea1a648ad0fb6e49c359acd06781abd0a0493c01_\n_1942f14326f8ffa3afc83946ba9ec06abe983a211939f0e58362f85dd2a6b96a_\n_2239d109d7c01682c99a721d654643b7d8f4431887ecad6fb2d043dbdacfe226_\n_25089ec24167f3caa413a9e1965c7dfc661219f45305187070a1e360b03f869c_\n_254fbeb13f8d2dc36de3a3ffca653608d1b3420a20a20248d330500785b3945c_\n_2bcbb1c165a6e31e085306224de3410249df50742ca3af069d58c7fd75d2d8c4_\n_2bf9f3703b48bf1578a43479444107b33ff6ecea108b364fc73913a639c511d4_\n_2c28f3b297a990b9d7a7163bac57ab68228c66109bb7a593702e556cdd455cce_\n_3131a8208dc7441bf26592d7fed2ba5d9f9994e21d9b8396b4d2cda76a8a44d7_\n_36a65a47cc464aac45a5d27372ea3b3584726d354f0792b9a77bfbe0cd0558bd_\n_41a6d6f1dca75abc924960ee701b0df0e7adc8b7501ac4e2c00743d7266df7d3_\n_5181fe760f456719b0ec505370df0b38055a5a3b202e1d50948fc92383a61c18_\n_569fbe4f66fa09fb375fb87915da79dbafb1ef62d9a20849d1beea4eadb8e805_\n_5d85fba3ff021b35bfba30d5d56b957ef084d818778ff77550bcf65755aa7849_\n_5f37829988e827f05b42774db94e8a15e87e9de12e61b89c91bf5fddee90650c_\n_6d7d35b4ce45fae4a048f7e371f23d1edc4c3b6998ab49febfd7d33f13b030a5_\n_6f6e9dde888d2368c1c9973769a5ea76bbf634105ed4f8adf1e74624f39454ad_\n_725efe161b8d0024cd330e3a3da194b46d16be14d57392fbfdf1ea71415d67b1_\n_75fa1309be8fdca4a6df345a009b47938503d5227149838334581b08d40b7e2f_\n_9085926d0beacc97f65c86c207fa31183c5373e9a26fb0678fbcd26ab65d6e64_\n_90c956e8983116359662f8b82ae156b378d3fae02c07a18827b4c65f0b5fe9ef_\n_98d4f0e8f91d7f4f1a3058b1a30220e3460cc821be704acfcb7fa2eb0c88818c_\n_99ca9d41c2ea6a18436fbc173ce8f3e94b5a3d592d9e4fa978120d140d96aefa_\n_a9f66d9dd3fd0f977381e83c1379fe664f22ebdd5695258fc388465cd3749562_\n_af33d399d9cb8026d796daf95f5bda9da96bb021ad93c001a21aa38005f2faa7_\n_b30b4acf05898c8a6338f5df6c3df7d7f06df8e67ccd773ffd83b5b8acff4cb8_\n_bdfb1a9f59be657b5375689b357ef8e70e1e7332f52c2e79ab3be796e06858d1_\n_ca8be57bbd2f3169d0c1c4b5145e8f955ea69ddde701f94a2b29c661389b3aa2_\n_cc2b47bffc260d992c602dbdbce1fb2ed982df883956cad9beac1ee0784650f6_\n_d17d32048aae06ec60b693cd83e1cf184e8c2e4d1f0299a28423fdc624f56bb8_\n_d2e43c41acd40324813d51df99fa127b86d8e384671dcc77f748d86afc3993a5_\n_e2153c73ec9fd15dc8389523515a96c3477fce5503be78ff82ab3cc7e9386e83_\n_e4dd30d5d85c4aaf05e01d8f40fb0e01e4e8ba99e82ec58946c045ce53783bde_\n_e8349cfcc422310c259688b0226cb14f5196a6daad77b622405282aeac89ab06_\n_f99610f8e36eb65e75979ef3ea4b7382bfb0bf2b72191cefccaaa19283d23606_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-03-28 - Dissecting Olympic Destroyer ‚Äì a walk-through.pdf"
    ],
    "report_names": [
        "2018-03-28 - Dissecting Olympic Destroyer ‚Äì a walk-through.pdf"
    ],
    "threat_actors": [
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535922,
    "ts_updated_at": 1743041139,
    "ts_creation_date": 1653753605,
    "ts_modification_date": 1653753605,
    "files": {
        "pdf": "https://archive.orkl.eu/3ff78b09ccc6e7aa0f05b7e06f8b201235cca61a.pdf",
        "text": "https://archive.orkl.eu/3ff78b09ccc6e7aa0f05b7e06f8b201235cca61a.txt",
        "img": "https://archive.orkl.eu/3ff78b09ccc6e7aa0f05b7e06f8b201235cca61a.jpg"
    }
}