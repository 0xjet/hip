{
    "id": "c432e834-6b7e-4065-a8d7-78ac363c1b20",
    "created_at": "2023-01-12T15:07:34.562189Z",
    "updated_at": "2025-03-27T02:08:41.265543Z",
    "deleted_at": null,
    "sha1_hash": "85f837777c1e2dbf53688d1f2753c84455478807",
    "title": "2021-09-14 - More ProxyShell- Web Shells Lead to ZeroLogon and Application Impersonation Attacks",
    "authors": "",
    "file_creation_date": "2022-05-28T19:32:56Z",
    "file_modification_date": "2022-05-28T19:32:56Z",
    "file_size": 579963,
    "plain_text": "# More ProxyShell? Web Shells Lead to ZeroLogon and Application Impersonation Attacks\n\n**[fortinet.com/blog/threat-research/more-proxyshell-web-shells-lead-to-zerologon-and-application-impersonation-attacks](https://www.fortinet.com/blog/threat-research/more-proxyshell-web-shells-lead-to-zerologon-and-application-impersonation-attacks)**\n\nSeptember 14, 2021\n\n**[FortiGuard Labs Threat Research Report](https://www.fortinet.com/fortiguard/labs.html?utm_source=blog&utm_medium=campaign&utm_campaign=FortiGuardLabs)**\n\n**Affected platforms: Microsoft Exchange**\n\n**Impacted parties: Exchange Mailboxes**\n\n**Impact: Gives unauthorized users the ability to access and send emails from any user within the organization**\n\n**Severity level: Critical**\n\n_Special thanks to Angelo Cris Deveraturda, Wilson Agad, Llallum Victoria, Wil Vidal, Jared Betts, and Ken Evans._\n\n## Introduction of ProxyShell\n\nFortiGuard Labs recently discovered an unidentified threat actor leveraging ProxyShell exploits using techniques that have yet to\n[be reported. Multiple instances of FortiEDR had detected malicious DLLs in memory, and we uncovered these new techniques](https://www.fortinet.com/products/endpoint-security/fortiedr.html?utm_source=blog&utm_campaign=fortiedr)\nwhile consulting with one of the organizations that had been compromised by ProxyShell. Through active threat hunting, we were\nthen able to determine that other organizations had also been compromised.\n\nThe DLLs, which were previously unknown based on their SHA256 file hashes, were used to perform active reconnaissance,\n[obtain hashed passwords via Zerologon, and perform pass-the-hash authentication to establish persistence via Exchange](https://www.fortiguard.com/threat-signal-report/3680/zerologon-proof-of-concept-code-now-available-cve-2020-1472-windows-netlogon-elevation-of-privilege)\nApplication Impersonation. This blog intends to provide an analysis of these DLLs. We documented the malicious activity\n\n\n-----\n\nassociated with them by recreating the incidents in a lab environment. The goal is to help the public and future customers\ndetermine if they have related activity in their environment and take appropriate action.\n\n## Overview of ProxyShell Incidents\n\n[These events began around the time that ProxyShell hit the cyber news headlines. At first, they seemed to match what most](https://www.fortiguard.com/threat-signal-report/4093/vulnerable-microsoft-exchange-servers-actively-scanned-for-proxyshell)\norganizations were already reporting. Exploit details, from the directories to the types of web shells used, matched almost\nverbatim. The difference was when web shells performed post-exploitation activity via DLLs loaded into memory, which triggered\nevents within FortiEDR.\n\nFortiEDR detected these DLLs because they loaded into memory space allocated for vbc.exe, the Visual Basic Compiler for .NET\napplications, and were loaded from the w3wp.exe process, which is used to run Microsoft Exchange's Outlook Web Application.\nThis, along with FortiEDR's machine learning algorithm, determined that these files were likely malicious.\n\nThe figure below shows w3wp.exe injecting a thread into the vbc.exe process and accessing services on the Exchange server.\n\nFigure 1: w3wp.exe Injecting a remote thread and accessing services on an Exchange server\n\nNext, the web shells were used to connect to numerous domain controllers within the environment, and we found the Thor.dll file\nin memory. This DLL is used to authenticate to the domain, modify security permissions, create domain accounts, and add\naccounts to Exchange roles. I analyze the Thor.dll in detail later.\n\nFigure 2: w3wp.exe loading the Thor.dll into memory\n\nThe event shown in Figure 2 occurred just after an HTTP POST was sent to one of the web shells and seconds before a domain\naccount was created within the environment. A legitimate domain service account created the account within the organization. Of\nnote, when FortiEDR was in protection mode, all this activity was blocked. No domain accounts or further activity was seen in\nthose situations.\n\nAlso, the domain accounts for the other environments were never used for interactive authentication, which told us that the threat\nactor was likely interested in using the accounts later in this campaign. They also only had domain user access with no elevated\nprivileges, indicating they were not interested in using the accounts to perform administrative level tasks.\n\nTo fully understand what took place when these DLLs were loaded into memory, we analyzed their functionality and behavior,\nexplained in detail in the following section.\n\n## DLL Analysis\n\nThere was a total of 22 DLLs found in memory by FortiEDR during the time of these events. Not all were tagged as malicious, but\nFortiEDR captured them regardless as they were related to the malicious events. Fortunately, all these DLLs were .NET compiled,\nso decompiling them was relatively trivial.\n\nThe first thing that was captured was the original names of the DLLs.\n\nFigure 3: DLL Original DLL names when decompiled\n\nSome of the names appear to be randomly named; however, others are named overtly with their intended function. Further\nanalysis shows that the randomly named DLLs were loaders for the overtly named DLLs. This can be seen by looking within the\n\"xml()\" method of the decompiled code for each loader DLL.\n\nFigure 4: First portion of the xml() method to show loader functionality\n\nThe \"xml()\" method loads the base64 version of the DLL and calls a method within the DLL. In this example, it was the \"Elite\"\nmethod within the \"Axiomatic\" class.\n\nThe loader DLLs are also responsible for taking the output from the method calls and relaying it back to the web shell HTTP\nsession that it was called from so the threat actor will get the output results from the DLL execution. This provides the threat actor\nwith results from the HTTP session from which they interacted with the web shell.\n\nFigure 5: The method call for HTTP response\n\n\n-----\n\nBy using these method calls and linking them to the loaded DLLs, our team could recreate this activity using PowerShell. The\nresults are shown below and are broken down by each DLL, along with a screenshot showing the output sent back through the\nweb shell HTTP session.\n\n**_GetEcpWebConfigModule.dll_**\n\nThis DLL gets the Exchange Control Panel (ECP) Web.config file from the Exchange server. This gives the threat actor access to\n[some of the internal ECP configurations. More information about the web.config file can be found here.](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/web-config?view=aspnetcore-5.0)\n\nFigure 6: Output of executing GetEcpWebConfigModule.dll\n\n**_DomainGroups.dll_**\n\nThis DLL gets all the domain groups from Active Directory. This gives the threat actor information about the hierarchy of the\nenvironment in which they are working.\n\nFigure 7: Output of executing DomainGroups.dll\n\n**_DnsDump.dll_**\n\nThis DLL gets the DNS Type A entries, which can be used to target additional machines within the environment. It also provides\nthe threat actor with a forward and reverse lookup database when translating hostname to IP and vice-versa.\n\nFigure 8: Output of executing DnsDump.dll\n\n**_OrganizationManagement.dll_**\n\nThis DLL gets the list of users in the user group \"Organizational Management.\" Members within this group have the necessary\naccess on the Exchange server to create and/or modify roles and permissions.\n\nFigure 9: Output of executing OrganizationManagement.dll\n\n**_ExchangeServers.dll_**\n\nThis DLL gets the list of exchange servers within the domain so the threat actor can target other Exchange servers if needed.\nSome environments are set up in a hierarchy, where different roles of Exchange are on different servers. A threat actor would\nneed this information to know which servers to target.\n\nFigure 10: Output of executing ExchangeServers.dll\n\n**_DiskInfo.dll_**\n\nThis DLL gets information about the drives of the localhost. This information can be useful to the threat actor to determine which\nhard drive may contain Exchange databases.\n\nFigure 11: Output of executing DiskInfo.dll\n\n**_Computers.dll_**\n\nThis DLL gets a list of workstations within the domain, which gives the threat actor an idea of how large an environment is and a\ngood starting point for launching additional attacks.\n\nFigure 12: Output of executing Computers.dll\n\n**_SystemInfoModule.dll_**\n\nThis DLL gets information about the system, such as build name, hardware info, OS, etc. This provides the threat actor with the\nnecessary information to launch further exploitation attacks or maintain persistence and access.\n\nFigure 13: Output of executing SystemInfoModule.dll\n\n**_SystemService.dll_**\n\nThis DLL returns a list of services running on the local system, which gives the threat actor a list of security software present on\nthe system. For example, the threat actor may have to use bypass techniques to avoid certain types of security products.\n\n\n-----\n\nFigure 14: SystemService.dll\n\n**_Machine.Modules.ZerologonInterface.dll_**\n\nThis DLL reaches out to given domain controllers (passed as a parameter) to see if they're vulnerable to Zerologon, and if so,\nresponds with usernames and hashed passwords. It then restores the computer hash for the domain controller to its original state.\n[This is a documented method using Zerologon and can be read about more here under the section \"Case 2 – DC Password](https://www.kroll.com/en/insights/publications/cyber/cve-2020-1472-zerologon-exploit-detection-cheat-sheet)\nReset with Original Password Reestablished\".\n\nFigure 15: Output of executing Machine.Modules.ZerologonInterface.dll\n\n**_Thor.dll_**\n\nThis DLL attempts to authenticate with credentials from the previous Zerologon dump and create domain accounts attempting to\nmasquerade as healthmailbox accounts. It also creates a role-based access control (RBAC) assignment within Exchange that\ngives it the ApplicationImpersonation role built into Microsoft Exchange. This allows the actor to access and send email from any\nmailbox within the environment. Furthermore, it locks down the permissions of those objects.\n\nFigure 16: Output of executing Thor.dll and descriptions of output\n\nWe can also see the role assignment created within Exchange, along with the role type, \"ApplicationImpersonation\".\n\nFigure 17: Exchange role policy output with threat actor-created role\n\nFigure 18: ApplicationImpersonation role type added to a role\n\nApplicationImpersonation is meant to be used by service applications that need to access multiple mailboxes and \"act as\" the\nmailbox owner. However, in this case, it allows the attacker to retain access to the domain's mailboxes. More information about\nApplication Impersonation using EWS can be found on Microsoft's documentation page (https://docs.microsoft.com/enus/exchange/client-developer/exchange-web-services/impersonation-and-ews-in-exchange). This specific email compromise\ntechnique is rarely seen, and the intent behind this activity is still largely unknown as the threat actor wasn't seen using the\ncreated accounts to impersonate mailboxes in a victim's environment.\n\n## ProxyShell Conclusion\n\nFortiEDR was able to capture DLLs found in memory that had been executed via web shells created from ProxyShell\nvulnerabilities. In the situations where the DLLs were not blocked (simulation blocks), there was no follow-on activity, nor was an\nintent identified. But the threat actors were clearly interested in maintaining access to the organization's mailboxes using\ntechniques rarely used and largely undocumented.\n\n## Fortinet Protections\n\nFortiEDR detects and blocks (when enabled) the malicious DLLs seen in memory.\n\nAll payloads described are detected and blocked by the FortiGuard AntiVirus service.\n\n## IOCs\n\n**_SHA256 Hashes and DLLs_**\n\nComputers.dll EB4EF1B588AD5027409B4D6B5643E25E456B14A5175EFFCF866B31C2CCD35FC3\n\nDiskInfo.dll 2AF411EA82384F7C41954E5CE4755709E80DA75C57357D62208018137111DDD3\n\nDnsDump.dll F1E4E139EA33385E672A7EB35BF5B33570709FB004B5C6884D12610D28C94797\n\nDomainGroups.dll 3112BE27CB28AEDD9334567A0E24569EC3D5F75414539E17433E4B4F27AA9470\n\nExchangeServers.dll 5E0FE024A39D0AF4F045DC6770A00F4E9FFBAB1D71C68360331CF8A8BB16BC18\n\n\n-----\n\nGetEcpWebConfigModule.dll CDD79F442519B0F48DDC7A1A699DFCE8E597445975F84BFAC51A2F0BA80F1237\n\nMachine.Modules.ZerologonInterface.dll A46B18A07B1509B15EB7FC6CF876888DC780962A3F850DC3B3EE5C7FBBEE723C\n\nOrganizationManagement.dll 28D983C235F2C5420AE596CDC3AAEF65D953E76F935B73708DA8E47072ED66B8\n\nSystemInfoModule.dll FC73324432E7BB3FAAF08527E462D26D0E4B3D1095BF7CA09BA04DD5B4E71664\n\nSystemService.dll 4E8EA9B3261B49597EF6D37DD252B37CA2BD162713B900EA25A65CCDB9B98DE5\n\nThor.dll AFD7E5431E86BAA55A6FDCB8CE81F1E7EEA158BA388D08C59678789AF6FE7C0E\n\n_Table 1: Names and SHA256 Hashes for DLLs_\n\n**_Account Names_**\n\nHealthmailbox<random 7 alphanumeric characters>\n\n_Learn more about Fortinet’s_ _[FortiGuard Labs threat research and intelligence organization and the FortiGuard Security](https://www.fortinet.com/fortiguard/labs?utm_source=blog&utm_campaign=fortiguard-labs)_\n_[Subscriptions and Services portfolio.](https://www.fortinet.com/fortiguard/labs?tab=security-bundles&utm_source=blog&utm_campaign=security-bundles)_\n\n_Learn more about Fortinet’s_ _[free cybersecurity training, an initiative of Fortinet’s Training Advancement Agenda (TAA), or about](https://www.fortinet.com/training/cybersecurity-professionals?utm_source=blog&utm_medium=campaign&utm_campaign=Freetraininginitiative)_\n_the_ _[Fortinet Network Security Expert program, Security Academy program, and](https://training.fortinet.com/?utm_source=blog&utm_campaign=nse-institute)_ _[Veterans program. Learn more about FortiGuard](https://www.fortinet.com/corporate/careers/vets.html?utm_source=blog&utm_campaign=fortivet)_\n_[Labs global threat intelligence and research and the FortiGuard Security Subscriptions and Services portfolio.](https://www.fortinet.com/support/support-services/fortiguard-security-subscriptions/fortiguard-services-bundles.html?utm_source=blog&utm_campaign=fortiguard-service-bundles)_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-14 - More ProxyShell- Web Shells Lead to ZeroLogon and Application Impersonation Attacks.pdf"
    ],
    "report_names": [
        "2021-09-14 - More ProxyShell- Web Shells Lead to ZeroLogon and Application Impersonation Attacks.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536054,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1653766376,
    "ts_modification_date": 1653766376,
    "files": {
        "pdf": "https://archive.orkl.eu/85f837777c1e2dbf53688d1f2753c84455478807.pdf",
        "text": "https://archive.orkl.eu/85f837777c1e2dbf53688d1f2753c84455478807.txt",
        "img": "https://archive.orkl.eu/85f837777c1e2dbf53688d1f2753c84455478807.jpg"
    }
}