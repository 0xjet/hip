{
    "id": "8011c4be-76d7-4de7-8c91-8598dabc4200",
    "created_at": "2023-01-12T15:00:30.621647Z",
    "updated_at": "2025-03-27T02:05:59.549558Z",
    "deleted_at": null,
    "sha1_hash": "a5bdc9eabf763128d5e28882e5dd1ba38c3db234",
    "title": "2020-03-05 - [RE011] Unpack crypter của malware Netwire bằng x64dbg",
    "authors": "",
    "file_creation_date": "2022-05-28T17:35:04Z",
    "file_modification_date": "2022-05-28T17:35:04Z",
    "file_size": 3419007,
    "plain_text": "# [RE011] Unpack crypter của malware Netwire bằng x64dbg\n\n**[blog.vincss.net/2020/03/re011-unpack-crypter-cua-malware-netwire-bang-x64dbg.html](https://blog.vincss.net/2020/03/re011-unpack-crypter-cua-malware-netwire-bang-x64dbg.html)**\n\n_Gần đây, chúng tôi có tiếp cận một mẫu malware lạ. Kết quả trả về của sandbox cho thấy_\n_đây là một biến thể của dòng malware Netwire được pack bằng một loại crypter viết bằng_\n_VB6. Chúng tôi đã tiến hành phân tích mẫu này nhằm hiểu sâu về kỹ thuật của malware,_\n_đồng thời xây dựng thành tài liệu tham khảo cho những mẫu malware sử dụng kĩ thuật tương_\n_tự._\n\n## 1. Công cụ sử dụng\n\n 2. Thông tin cơ bản về sample\n\n**_File Hash (SHA-_**\n**_256): d381c5a5eeb46759bb5ebce67eb50cc61f91a75c204d6ec1c7750937f7f4c3f1_**\n\n[Nguồn:Any.run](http://any.run/)\n\n\n-----\n\nPhân tích sơ bộ bằng các chương trình PE Scanner cho thấy mã độc được viết bằng\n**Visual Basic 6.0**\n\n**_Hình 1. Kết quả scan bằng Exeinfo_**\n\n## 3. Phân tích crypter\n\nMột mẹo khi dịch ngược chương trình được biên dịch từ VB6 là sẽ có một loạt các lệnh\njump nhảy đến các function được viết trong chương trình. Như trong trường hợp này, các\nlệnh jump nằm ở địa chỉ 0x40DF3C. Có thể tìm các lệnh jump này bằng mẫu “81 6C 24 04\n**?? ?? ?? ?? E9”**\n\n**_Hình 2. Các lệnh jump đến function của VB6_**\n\nCó thể thấy mã độc chỉ có hai function chính. Chọn function tại địa chỉ 0x40E9DE để phân\ntích vì function này có kích thước lớn nhất. Tiếp tục trace dần sẽ tới một hàm call như sau:\n\n\n-----\n\n**_Hình 3. Lệnh call đến shellcode_**\n\nVới những ai đã quen với việc dịch ngược các chương trình được viết bằng VB6 sẽ nhận\nthấy điểm bất thường khi trong code của chương trình VB6 gọi thẳng đến một thanh ghi.\nTiếp tục debug vào lệnh call sẽ tới đoạn shellcode:\n\n**_Hình 4. Đoạn code cấp phát memory và chạy shellcode_**\n\nToàn bộ đoạn shellcode này đã được obfuscated. Tuy nhiên, kích thước của nó cũng khá\nnhỏ nên nếu trace dần từng bước và tổng hợp thông tin, chúng ta sẽ thấy shellcode thực\nhiện những bước sau:\n\n-    Gọi hàm VirtualAlloc để cấp phát bộ nhớ.\n\n-    Giải mã shellcode và copy vào vùng bộ nhớ vừa được cấp phát.\n\n-    Tiến hành gọi shellcode mới.\n\n\n-----\n\nTới đây, có thể dùng x64dbg để dump toàn bộ shellcode mới và tiến hành phân tích. Để\ndump shellcode, lựa chọn đoạn cần dump trong cửa sổ Hex, chuột phải và chọn Binary >\n**Save To a File:**\n\n**_Hình 5. Dump shellcode với x64dbg_**\n\nVới shellcode đã dump, có nhiều công cụ hỗ trợ để phân tích. Trong bài này, chúng tôi sử\ndụng jmp2it để load shellcode lên và debug bằng x64dbg. Chạy jmp2it với command như\nsau:\n\n“Jmp2it.exe shellcode.bin 0x0 pause”\n\nTiến hành attach x64dbg vào process jmp2it.exe để debug shellcode. Shellcode lúc này\nđược load ở địa chỉ 0x30000.\n\n\n-----\n\n**_Hình 6. Shellcode thực hiện tác vụ độc hại_**\n\nNhư trên hình, shellcode mới này cũng bị obfuscate. Lúc này, có hai lựa chọn:\n\n-    Trace từng lệnh để debug.\n\n-    Viết tool/script để deobfuscate đoạn shellcode.\n\nVì shellcode là khá lớn nên ở đây chúng tôi lựa chọn phương án viết script để thực hiện\ndeobfuscate đoạn shellcode này.\n\n### 3.1. Deobfuscate shellcode\n\nĐể viết được script thực hiện deobfuscate đoạn shellcode, chúng ta cần hiểu một số\npattern của đoạn shellcode. Ví dụ như sau:\n\n-    Pattern Push Reg/Pop Reg\n\n-    Pattern Inc Reg/Dec Reg\n\n-    Pattern Add Reg, Const/ Sub Reg, Const\n\n-    Pattern Push Reg/Xor Reg, Const/ Pop Reg\n\n-    Pattern CLD, CLC\n\n-    …\n\nCác pattern trên tương ứng với lệnh NOP. Sau khi xác định được các pattern này, dùng\n[python để viết script deobfuscate. Chi tiết script xem tại đây. Để sử dụng, lựa chọn đoạn](https://drive.google.com/file/d/1gc5Cs2zxElj13TJHc9Krgw1ERMkPLj0V/view)\nmã cần deobfuscate và chạy script.\n\n\n-----\n\n**_Hình 7. Trước và sau khi deobfuscated_**\n\n*Lưu ý: _script trên tạm thời bỏ qua tìm kiếm pattern 2 bytes vì pattern ngắn, không có hiệu_\n_quả nhiều trong việc obfuscate và rất dễ nhầm lẫn khi deobfuscate bằng cách_\n_search/replace byte pattern. Để xác định pattern 2 bytes một cách chính xác thì nên dùng_\n_pattern bằng asm. Hiện tại x64dbg chưa support tốt các pattern bằng asm._\n\n### 3.2. Heaven’s gate\n\nShellcode áp dụng kỹ thuật heaven’s gate[1] để làm rối trong quá trình debug. Đây là kỹ\nthuật thực thi mã từ x86 sang x64 bằng lệnh far jmp. Bằng cách đơn giản check ở địa chỉ\n**FS:[0xC0] để xem hệ thống có phải là x64 hay không? Nếu là x64, shellcode dùng kỹ**\nthuật heaven’s call. Để debug tiếp được trơn tru trên x86, chúng tôi tiến hành patch lệnh\nnhảy sau lệnh so sánh để \"lừa\" shellcode thực thi trên x86.\n\n**_Hình 8. Đoạn code thực thi Heaven’s gate_**\n\n### 3.3. Resolve API\n\nCó thểnói GetProcAddress là một API quan trọng đểshellcode có thểtìm và gọi các\n\n\n-----\n\nhàm API khác. Để tìm địa chỉ của hàm GetProcAddress cần có địa chỉ của kernel32.dll.\nShellcode ở trên sẽ tiến hành truy xuất tới PEB->Ldr->InMemoryOrderModuleList và lấy\nđịa chỉ của module tương ứng với tên kernel32.dll.\n\n**_Hình 9. Truy cập vào PEB lấy base tương ứng_**\n\nSau khi có địa chỉ của kernel32.dll, shellcode tiếp tục tìm địa chỉ của API bằng API hash.\nỞ đây hash được sử dụng là DJB hash và giá trị hash của hàm “GetProcAddress” là\n**0xCF31BB1F[2].**\n\n**_Hình 10. Đoạn code hash tên API và tiến hành so sánh_**\n\nDựa vào địa chỉ của kernel32.dll và API GetProcAddress, shellcode tiến hành resolve\nmột loạt các API sau:\n\n-    LoadLibraryA\n\n-    TerminateProcess\n\n-    EnumWindows\n\n\n-----\n\nZwProtectVirtualMemory\n\n-    DbgBreakPoint\n\n-    DbgUIRemoteBreakin\n\n### 3.4. Anti attach\n\nShellcode gọi hàm ZwProtectVirtualMemory để đặt quyền\n**PAGE_EXECUTE_READWRITE cho section .text của ntdll, sau đó tiến hành patch các**\nhàm API DbgBreakPoint và DbgUIRemoteBreakin để anti attach.\n\n**_Hình 11. Code patch hàm DbgBreakPoint thành NOP_**\n\n**_Hình 12. Code patch hàm DbgUIRemoteBreakin_**\n\n\n-----\n\n**_Hình 13. Trước và sau khi patch hàm DbgUIRemoteBreakin_**\n\n### 3.5. Restore hook/breakpoint tại các hàm Zw*/Nt*\n\nShellcode thực hiện scan pattern “B9 ?? ?? ?? ?? 8D 54 24 04” và “33 C9 8D 54 24 04”\ntrong code của thư viện ntdll. Đây là pattern nằm trong các hàm Zw*/Nt* gọi đến system\ncall. Sau khi tìm thấy pattern này, shellcode sẽ khôi phục lại 5 bytes đầu tiên của các hàm:\n\n\n-----\n\n**_Hình 14. Đoạn code search pattern_**\n\n**_Hình 15. Đoạn code khôi phục lại 5 byte đầu tiên của API_**\n\nMột điểm hay cần học ở kỹ thuật này là các hàm Zw*/Nt* có các system call number tăng\ndần theo luồng từ trên xuống dưới. Nhờ đặc điểm này, shellcode có thể khôi phục lại lệnh\n“mov eax, system call number” một cách chính xác:\n\n**_Hình 16. Pattern được khoanh màu đỏ và system call number được khoanh màu xanh_**\n\n_Bug: Nếu hàm API với system call number là 0 hoặc dòng lệnh “lea edx, dword ptr ss:_\n\n**_[esp+4]” bị thay đổi (hook, breakpoint,…), shellcode sẽ hủy toàn bộ system call number_**\n\n\n-----\n\n_của ntdll._\n\n### 3.6. Set hidden thread\n\nShellcode gọi hàm ZwSetInformationThread với tham số 0x11 để hide thread[3] trước\ndebugger:\n\n\n**_Hình 17. Đoạn mã shellcode set hidden thread_**\n\n### 3.7. Kiểm tra breakpoint\n\nShellcode sử dụng một hàm check trước khi gọi API. Nội dung hàm check như sau:\n\n-    Gọi NtGetThreadContext để check hardware breakpoint[3].\n\n-    Kiểm tra opcode 0xCC (int 3) để phát hiện software breakpoint[3].\n\n\n-----\n\n**_Hình 18. Code phát hiện hardware breakpoint_**\n\n**_Hình 19. Code phát hiện software breakpoint_**\n\n### 3.8. Create process và code injection\n\nCuối cùng shellcode thực hiện code injection bằng cách:\n\n-    Gọi CreateProcessInternalW với flag là CREATE_SUSPENDED.\n\n-    Gọi ZwUnmapViewOfSection với base là 0x400000.\n\n-    Sử dụng ZwCreateSection/NtMapViewOfSection để cấp phát bộ nhớ.\n\n-  Nếu ZwCreateSection/NtMapViewOfSection bị lỗi, chuyển sang dùng API\n**ZwAllocVirtualMemory để cấp phát bộ nhớ.**\n\n-    Gọi NtWriteVirtualMemory để inject shellcode mới vào bộ nhớ.\n\n- Cuối cùng gọi hàm NtSetThreadContext/NtSetThreadContext/ NtResumeThread để\nchạy shellcode và TerminateProcess để exit.\n\n### 3.9. Phân tích shellcode thứ hai\n\nĐoạn shellcode thứ hai thực chất là đoạn shellcode thứ nhất với config khác. Thay vì\ninject shellcode như đoạn shellcode thứ nhất, mục đích của đoạn shellcode này là tải về\npayload, decrypt và thực thi. Công việc chính nó thực hiện bao gồm:\n\n- Sử dụng hàm của thư viện wininet.dll để download payload từ địa chỉ\n**https://drive[.]google[.]com/uc?**\n**export=download&id=1zEuX2HZcVvTYp7wzGtD1IXOSVLTBWVUe**\n\n-  Giải mã payload và map vào memory để thực thi. Payload này có kích thước\n**0x1AA40, 40 bytes đầu tiên là phần header của payload.**\n\n\n-----\n\n**_Hình 20. Payload được decrypt trong memory_**\n\nDump toàn bộ với size là 0x1AA00 sẽ thu được payload cuối cùng là Netwire.\n\n### 3.10. Bonus\n\nKhi load payload Netwire đã dump bằng x64dbg và đặt breakpoint tại 0x409E8A, sẽ thu\nđược config đã decrypted:\n\n**_Hình 21. Config được decrypt trong memory_**\n\n### 4. Tài liệu tham khảo\n\nCác nguồn tham khảo được sử dụng làm tư liệu cho bài viết:\n\n---------------------------------**Để tiện theo dõi, chúng tôi cung cấp bài phân tích dưới dạng PDF:**\n\n**File Name: CSS-RD-ADV-200304-011_Unpack crypter của malware Netwire bằng**\nx64dbg.pdf\n**File Hash (SHA-**\n**256): 717efd6b8dd9a8a40ee34386311ab0f5689eb1f5f8fbd6df30b9cfdd8abe02c0**\n\n**Dang Dinh Phuong**\n**R&D Center - VinCSS (a member of Vingroup)**\n\n\n-----",
    "language": "VI",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-03-05 - [RE011] Unpack crypter của malware Netwire bằng x64dbg.pdf"
    ],
    "report_names": [
        "2020-03-05 - [RE011] Unpack crypter của malware Netwire bằng x64dbg.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535630,
    "ts_updated_at": 1743041159,
    "ts_creation_date": 1653759304,
    "ts_modification_date": 1653759304,
    "files": {
        "pdf": "https://archive.orkl.eu/a5bdc9eabf763128d5e28882e5dd1ba38c3db234.pdf",
        "text": "https://archive.orkl.eu/a5bdc9eabf763128d5e28882e5dd1ba38c3db234.txt",
        "img": "https://archive.orkl.eu/a5bdc9eabf763128d5e28882e5dd1ba38c3db234.jpg"
    }
}