{
    "id": "b8c1f86f-bde2-4b39-92fe-71a7112d65dd",
    "created_at": "2023-01-12T15:09:49.856049Z",
    "updated_at": "2025-03-27T02:05:44.361282Z",
    "deleted_at": null,
    "sha1_hash": "63dc4dd934e11a7a9b83d4ece61ff3db80c8d4c2",
    "title": "2021-04-22 - Binary Data Hiding in VB6 Executables",
    "authors": "",
    "file_creation_date": "2022-05-29T10:48:15Z",
    "file_modification_date": "2022-05-29T10:48:15Z",
    "file_size": 418655,
    "plain_text": "# Binary Data Hiding in VB6 Executables\n\n**[decoded.avast.io/davidzimmer/binary-data-hiding-in-vb6-executables/](https://decoded.avast.io/davidzimmer/binary-data-hiding-in-vb6-executables/)**\n\nby [David ZimmerApril 22, 20219 min read](https://decoded.avast.io/author/davidzimmer/)\n\n## Overview\n\n\nApril 22, 2021\n\n\nThis is part one in a series of posts that focus on understanding `Visual Basic 6.0`\n```\n(VB6) code, and the tactics and techniques both malware authors and researchers use\n\n```\naround it.\n\n## Abstract\n\nThis document is a running tally covering many of the various ways `VB6 malware can`\nembed binary data within an executable.\n\nThere are 4 main categories:\n\nstring based encodings\ndata hidden within the actual opcodes of the program\ndata hidden within parts of the `VB6` file format\ndata in or around normal `PE structures`\n\nOriginally I was only going to cover data hidden within the file format itself but for the sake\nof documentation I decided it is worth covering them all.\n\nData held within the file format is a special case which I find the most interesting. This is\nbecause it can be interspersed within a complex set of undocumented structures which\nwould require advanced knowledge and intricate parsing to detect. In this scenario it would\nbe hard to determine where the data is coming from or to even recognize that these buffers\nexist.\n\n## Resource Data\n\n\n-----\n\nThe first technique is the standard built into the language itself, namely loading data from\nthe resource section. `VB6 comes with an add-in that allows users to add a` `.RES file to`\nthe project. This file gets compiled into the resource section of the executable and allows\nfor binary data to be easily loaded.\n\nThis is a well known and standard technique.\n\n## Appended Data\n\nThis technique is very old and has been used from all manner of programming language. It\nwill be mentioned again for thoroughness and to link to a public implementation [1] that\nallows for simplified use.\n\n## Hex String Buffers\n\nIt is very common for malware to build up a string of hex characters that are later converted\nback to binary data. Conversion commonly includes various text manipulations such as\ndecryption or stripping junk character sequences. Extra character sequences are\ncommonly used to prevent automatic recognition of the data as a hex string by AV.\n\nIn the context of VB6, there are several limitations. The IDE only allows for a total of `1023`\ncharacters to be on a single line. VB’s line continuation syntax of `&_ is also limited to only`\n```\n25  lines. For these reasons you will often see large blocks of data embedded in the\n\n```\nfollowing format:\n\nIn a compiled binary each string fragment is held as an individual chunk which is easily\nidentifiable. A faster variant may hold each element in a string array so conglomeration\nonly occurs once.\n\n\n-----\n\nThis is a well known and standard technique. It is commonly found in `VBA,` `VB6 and`\nmalware written in many other languages. Line length limitations can not be bypassed\nthrough command line compilation.\n\n## Binary Data Within Images\n\nThere are multiple ways to embed lossless data into image formats. The most common will\nbe to embed the data directly within the structure of a `BITMAP image. Bitmaps can be`\nheld directly within `VB6 Image and Picture controls. Data embedded in this manner will be`\nheld in the `.FRX  form resource file before compilation. Once compiled it will be held in a`\nbinary property field for the target form element. Images created like this can be generated\nwith a special tool, and then embedded directly into the form using the IDE.\n\nThe following is a public sample[2] of data being extracted from such a bitmap\n\nExtracted images will display as a series of colored blocks and pixels of various colors.\nNote that this is not stenography.\n\nMany tools understand how to extract embedded images from binary files. Since the image\ndata still contains the `BITMAP header, parsing of the` `VB6 file format itself is not`\nnecessary. This technique is public and in common use. The data is often decrypted after it\nis extracted.\n\n## Chr Strings\n\nSimilar to obfuscations found in C malware, strings can be built up at runtime based on\nindividual byte values. A common example may look like the following:\n\n\n-----\n\nAt the asm level, this serves to break up each byte value and puts it inline with a bunch of\nopcodes preventing automatic detection or display with strings. For native VB6 code it will\nlook like the following:\n\nIn P-Code it will look like the following:\n\nThis is a well known and standard technique. It is commonly found in VBA as well as VB6\nmalware.\n\n## Numeric Arrays\n\nNumeric arrays are a fairly standard technique in malware that are used to break up the\nbinary data amongst the programs opcodes. This is similar to the Chr technique but can\nhold data in a more compact format. The most common data types used for this technique\nare `4 byte longs, and` `8 byte currency` types. The main advantage of this technique\nis that the data can be easily manipulated with math to decrypt it on the fly.\n\nNative:\n\n\n-----\n\nP-Code:\n\nNative:\n\nP-Code:\n\nThis technique is not as popular as the others, but does have a long history of use. I think\nthe first place I saw it was in Flash ActionScript exploits.\n\n## Form Properties\n\n\n-----\n\nForms and embedded GUI elements can contain compiled in data as part of their\nproperties. The most common attributes used are `Form.Caption,` `Textbox.Text, and`\nany element’s. Tag property.\n\nSince all of these properties are typically entered via the IDE, they are usually found to\ncontain ASCII only data that is later decoded to binary.\n\nDevelopers can however embed binary data directly into these properties using several\ntechniques.\n\nWhile there is way to hexedit raw data in the `.FRX` form resource file, this comes with\nlimitations such as not being able to handle embedded nulls. Another solution is inserting\nthe data post compilation. With this technique a large buffer is reserved consisting of ASCII\ntext that has start and end markers. An embedding tool can then be run on the compiled\nexecutable to fill in the buffer with true binary data.\n\nUsing form element properties to house text based data is a common practice and has\nbeen seen in `VBA,` `VB6, and even` `PDF scripts. Binary data embedded with a post`\nprocessing step has been observed in the wild. In both P-Code and Native, access to these\nproperties will be through `COM object` `VTable calls.`\n\nFrom the Semi-VBDecompiler source, each different control type (including `ActiveX ) has`\nits own parser for these compiled in property fields. Results will vary based on tool used if\nthey can display the data. Semi-Vbdecompiler has an option to dump property blobs to disk\nfor manual exploration. This may be required to reveal this type of embedded binary data.\n\n## UserControl Properties\n\nA special case for the above technique occurs with the built in `UserControl type. This`\ncontrol is used for hosting reusable visual elements and in `OCX creation. The control has`\ntwo events which are passed a `PropertyBag object of its internal binary settings. This`\nbinary data can be easily set in the IDE through property pages. This mechanism can be\nused to store any kind of binary data including entire file systems. A public example of this\ntechnique is available[3]. Embedded data will be held per instance of the `UserControl in`\nits properties on the host form.\n\n\n-----\n\n## Binary Strings\n\nCompiled `VB6 executables store internal strings with a length prefix. Similar to the form`\nproperties trick, these entries can be modified post compilation to contain arbitrary binary\ndata. In order to discern these data blobs from other binary data, in depth understanding\nand complex parsing of the `VB6 file format would have to occur.`\n\nThe longest string that can be embedded with this technique is limited by the line length in\nthe IDE which is `2042 bytes ( (1023 bytes – 2 for quotes) *2 for unicode ).`\n```\nVB6 malware can access these strings normally with no special loading procedure. As far\n\n```\nas its concerned the source was simply `str = “binary data” .`\n\nThe IDE can handle a number of unicode characters which can be embedded in the source\nfor compilation. Full binary data can be embedded using a post processing technique.\n\n## Error Line Numbers\n\nVB6 allows for developers to embed line numbers that can be accessed in the event of an\nerror to help determine its location. This error line number information is stored in a\nseparate table outside of the byte code stream.\n\nThe error line number can be accessed through the `Erl() function. VB6 is limited to`\n```\n0xFFFF line numbers per function, and line number values must be in the 0-0xFFFF\n\n```\nrange. Since the size of the embedded data is limited with this technique, short strings\nsuch as passwords and web addresses are the most likely use.\n\nWhen the code below is run, it will output the message “secret”\n\n\n-----\n\nAdvanced knowledge of the `VB6 file format would be required in order to discern this data`\nfrom other parts of the file. Embedded data is sequential and readable if not encoded in\nsome other way.\n\n## Function Bodies\n\nThe `AddressOf operator allows` `VB6 easy runtime access to the address of a public`\nfunction in a module. It is possible to include a dummy function that is filled with just\nplaceholder instructions to create a blank buffer within the `.text section of the`\nexecutable. This buffer can be easily loaded into a byte array with a `CopyMemory call. A`\nsimple post compilation embedding could be used to fill in the arbitrary data.\n\nFor P-Code compiles, `AddressOf returns the offset of a loader stub with a structure offset.`\nP-Code compiles would require several extra steps but would still be possible.\n\n## References\n\n[1] Embedded files appended to executable – theTrik:\n\n[https://github.com/thetrik/CEmbeddedFiles](https://github.com/thetrik/CEmbeddedFiles)\n\n[2] Embedding binary data in Bitmap images – theTrik:\n\nhttp://www.vbforums.com/showthread.php?885395-RESOLVED-Store-binary-data-in\nUserControl&p=5466661&viewfull=1#post5466661\n\n[3] UserControl binary data embedding – theTrik:\n\n[https://github.com/thetrik/ctlBinData](https://github.com/thetrik/ctlBinData)\n\n[Tagged ashidding,](https://decoded.avast.io/tag/hidding/) [malware,](https://decoded.avast.io/tag/malware/) [P-Code,](https://decoded.avast.io/tag/p-code/) [Research,](https://decoded.avast.io/tag/research/) [series,](https://decoded.avast.io/tag/series/) [VB](https://decoded.avast.io/tag/vb/)\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-04-22 - Binary Data Hiding in VB6 Executables.pdf"
    ],
    "report_names": [
        "2021-04-22 - Binary Data Hiding in VB6 Executables.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536189,
    "ts_updated_at": 1743041144,
    "ts_creation_date": 1653821295,
    "ts_modification_date": 1653821295,
    "files": {
        "pdf": "https://archive.orkl.eu/63dc4dd934e11a7a9b83d4ece61ff3db80c8d4c2.pdf",
        "text": "https://archive.orkl.eu/63dc4dd934e11a7a9b83d4ece61ff3db80c8d4c2.txt",
        "img": "https://archive.orkl.eu/63dc4dd934e11a7a9b83d4ece61ff3db80c8d4c2.jpg"
    }
}