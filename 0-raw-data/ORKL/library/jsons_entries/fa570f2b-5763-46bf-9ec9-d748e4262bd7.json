{
    "id": "fa570f2b-5763-46bf-9ec9-d748e4262bd7",
    "created_at": "2023-06-05T02:07:09.651586Z",
    "updated_at": "2025-03-27T02:05:32.764644Z",
    "deleted_at": null,
    "sha1_hash": "d5cfffe00febab427a4fdb17d2b73c10b737a45f",
    "title": "2023-05-09 - MetaStealer string decryption and DGA overview",
    "authors": "",
    "file_creation_date": "2023-06-04T12:41:35Z",
    "file_modification_date": "2023-06-04T12:41:35Z",
    "file_size": 194348,
    "plain_text": "# MetaStealer: String Decryption and DGA overview\n\n**[medium.com/walmartglobaltech/metastealer-string-decryption-and-dga-overview-5f38f76830cd](https://medium.com/walmartglobaltech/metastealer-string-decryption-and-dga-overview-5f38f76830cd)**\n\nJason Reaves May 9, 2023\n\n-\nBy: Jonathan McCay, Joshua Platt and Jason Reaves\n\nUnit42[1] recently tweeted about a campaign starting with a malicious email link that\ndownloads a OneNote file used to drop and execute MetaStealer. While investigating the\nMetaStealer sample[2], we noticed it attempts to connect to multiple domains that seemed to\nbe randomly named. After landing on the C2 routine, instead of decrypting a static list of\nservers, the sample used a domain generation algorithm[3], (DGA) to derive the list.\nPredominantly used as a fall back mechanism, a domain from the DGA can be registered to\ncommunicate when the primary C2s are not available. The use of a DGA as a primary\nmethod of contacting the threat actor’s infrastructure is interesting.\n\n**Sample:**\n\n**String Decryption:**\n\nOn top of the MetaStealer binary being highly obfuscated, the author inserted garbage code\nwhile also encoding the important onboard strings. The encoding used has been previously\nmentioned by NCC[4], but a lack of listing of the decoded strings in existing research was\nnoticed. The strings are organized as DWORD values and pushed onto the stack along with\nthe XOR key:\n\nThe PXOR instruction allows for using 64 bit(MMX) or 128 bit(XMM) length operands. In this\ncase, you can see that most of the DWORD values are the same. This is because the\nencoded strings are NULL padded to make the length fit. Ultimately, in the screen above, the\ndata is just XOR encoded:\n```\n>>> a = struct.pack('<IIII', 0x7D414F85, 0x677C8C64, 0x0AB4023C0, 0x0FF480D71)>>> b =\nstruct.pack('<IIII', 0x73837AB, 0x677C8C64, 0x0AB4023C0, 0x0FF480D71)>>> a =\nbytearray(a)>>> b = bytearray(b)>>> for i in range(len(a)):...  a[i] ^= b[i]...>>>\nabytearray(b'.xyz\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n\n```\n\n-----\n\nAttempting to decode all or the majority of the strings in an automatic manner would require\nfinding the relevant blocks of code. After some investigation, it seems longer strings use the\nVPXOR instruction, which can leverage 128 bit(XMM) or 256 bit(YMM) length operands.\n\nA quick and dirty way to decode strings is to find all the PXOR and VPXOR instructions and\nthen walk backwards to find all the DWORD stack loads to get most of the strings decoded.\n```\nrule_source = '''\nrule meta_s\n{\n\n  meta:\n    author = \"sysopfb\"\n  strings:\n    $snippet1 = {66 0? ef}\n    $snippet2 = {c5 ?? ef}\n  condition:\n    ($snippet1 or $snippet2)\n}\n'''\ndef yara_scan(raw_data, rule_name):\n  addresses = {}\n  yara_rules = yara.compile(source=rule_source)\n  matches = yara_rules.match(data=raw_data)\n  for match in matches:\n    if match.rule == 'meta_s':\n      for item in match.strings:\n        if item.identifier == rule_name:\n          addresses[item.identifier] = item.instances\n  return addresses\n\ndata = open(sys.argv[1], 'rb').read()\nret = []\nout = None\nlength_off = Falsesnippet = yara_scan(data, '$snippet1')prev_offset = 0for val in\nsnippet['$snippet1']: offset = val.offset test = data[prev_offset:offset] vals =\nre.findall(b'''\\xc7\\x85..\\xff\\xff....''',test) if vals != []: if len(vals) > 8: \ntemp = vals[-8:] else:  temp = vals try:  xdata = temp[0][-4:]  xdata += temp[1]\n[-4:]  xdata += temp[2][-4:]  xdata += temp[3][-4:]  xkey = temp[4][-4:]  xkey +=\ntemp[5][-4:]  xkey += temp[6][-4:]  xkey += temp[7][-4:]  xdata = bytearray(xdata)\nxkey = bytearray(xkey)  for i in range(len(xdata)):  xdata[i] ^= xkey[i] \nprint(b''.join(xdata.split(b'\\x00'))) except:  pass prev_offset = offset\n\n```\nThen repeating a similar approach for PVXOR but accounting for larger assortment of\nstrings, as previously mentioned this will only get a majority of the strings decoded but it is\nenough to determine that this stealer has much functionality including references to starting\nsocks, backconnect, punching holes in the firewall and detonating shellcode:\n\n\n-----\n\n**Decrypted Strings:**\n```\nsyschromefirefoxedgenotepadippasswordcmdinputFG StartedshellcodemodeResult:\nbc_addrportsocks started:1775uuid/api/client/newffoxdir=in\nversion.xyzokos_cryptencrypted_keyRtlGetVersionWindows 10Windows VistaWindows\n7Windows 8Windows\n8.1Proactionstatuspasswdloader_idfilesdurscriptFALSEtypetask_result/tasks/collectROOTn\nTypecmd.exemicrosoft\\\\windows/c \"echo start \"\" \"Failed to create task\ndefinitionaction=allow program=\"(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\Default\\\\Login\nData\\\\Default\\\\Web Data\n\n```\nA more exhaustive method for harvesting stack loaded and then decoded strings would be\nusing a CPU emulator similar to how we showed against BazaLoader[5] previously.\n\n**Domain Generation Algorithm:**\n\nAdditional domains the sample attempts to communicate with that appeared to be DGA.\n\n**IDA: Pushing seed, (0x1234) before calling DGA**\n\n**IDA: DGA Routine**\n\n**Converted to Python:**\n\nNow that the host names have been generated, the url can be built using the tld and uri from\nthe decrypted strings. An attempt to connect to each host will be made until a response is\nreceived. At the time of writing this, only one of the derived hostnames,\n(wgcuwcgociewewoo.xyz) would resolve. The ip it resolves to, (pictured below) also contains\nanother hostname that used to be active, (mmswgeewswyyywqk.xyz). Both of these domains\nare in the list derived by the DGA when using the seed value 0x1234. Going back further we\ncan find additional seed values being used at different time periods; 0xabc8, 0x9b2f, 0x7b2f,\n0xc17a, 0x2f73 and 0x4b9a.\n\nWhen KELA[6] first observed the threat actor “_META_” offering a new stealer, it was\nmarketed as having the same functionality and panel as RedLine[7] Stealer. After seeing\nreferences to backconnect, socks, and loader id’s in the decrypted strings, we can see that\nthe improvements made to this tool now offer more than just credential theft.\n\n## IOCs\n\n**Endpoint:**\n```\npowershell -inputformat none -outputformat none –NonInteractive -Command AddMpPreference -ExclusionExtension \"exe\"AppData\\Local\\Microsoft\\Windows\\hyperv.exehyper-v.ver\n\n```\n**Network:**\n\n\n-----\n\n```\nmmswgeewswyyywqk.xyz\nwgcuwcgociewewoo.xyz\nyiogqkksoyysqiky.xyz\nikuasuggwiewymsi.xyz\nuosqysascuwmqgyk.xyz\nuiouaqcqqcgueweg.xyz\nuawqgawkguwiqeyk.xyz\nkaewquswkswcmsim.xyz\naaycciywcgaqwkky.xyz\nmkgcsmogqewauaiw.xyz\n185.172.129.192\n185.203.116.71\n167.88.12.112\n[a-z]{16}.xyz:1775/api/client/new[a-z]{16}.xyz:1775/api/client/verify[a-z]\n{16}.xyz:1775/api/client_hello[a-z]{16}.xyz:1775/tasks/get_worker[a-z]\n{16}.xyz:1775/tasks/collect[a-z]{16}.xyz:1775/avast_update\n\n```\nFull DGA dump for every currently known seed can be found at:\n[https://github.com/sysopfb/open_mal_analysis_notes/tree/master/metastealer_dga](https://github.com/sysopfb/open_mal_analysis_notes/tree/master/metastealer_dga)\n\n## References\n\n1: [https://twitter.com/Unit42_Intel/status/1646940355936256000](https://twitter.com/Unit42_Intel/status/1646940355936256000)\n\n2:\nhttps://www.virustotal.com/gui/file/6cf8bfba1b221effcb1eccec0c91fb0906d0b8996932167f65\n4680cb3ac53aac\n\n3: [https://en.wikipedia.org/wiki/Domain_generation_algorithm](https://en.wikipedia.org/wiki/Domain_generation_algorithm)\n\n4: [https://research.nccgroup.com/2022/05/20/metastealer-filling-the-racoon-void/](https://research.nccgroup.com/2022/05/20/metastealer-filling-the-racoon-void/)\n\n5: https://medium.com/walmartglobaltech/decrypting-bazarloader-strings-with-a-unicorn15d2585272a9\n\n6: https://www.bleepingcomputer.com/news/security/new-blackguard-password-stealingmalware-sold-on-hacker-forums/\n\n7: https://www.proofpoint.com/us/blog/threat-insight/new-redline-stealer-distributed-usingcoronavirus-themed-email-campaign\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-05-09 - MetaStealer string decryption and DGA overview.pdf"
    ],
    "report_names": [
        "2023-05-09 - MetaStealer string decryption and DGA overview.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1685930829,
    "ts_updated_at": 1743041132,
    "ts_creation_date": 1685882495,
    "ts_modification_date": 1685882495,
    "files": {
        "pdf": "https://archive.orkl.eu/d5cfffe00febab427a4fdb17d2b73c10b737a45f.pdf",
        "text": "https://archive.orkl.eu/d5cfffe00febab427a4fdb17d2b73c10b737a45f.txt",
        "img": "https://archive.orkl.eu/d5cfffe00febab427a4fdb17d2b73c10b737a45f.jpg"
    }
}