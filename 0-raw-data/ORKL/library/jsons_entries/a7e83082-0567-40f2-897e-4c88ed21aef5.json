{
    "id": "a7e83082-0567-40f2-897e-4c88ed21aef5",
    "created_at": "2023-01-12T15:09:29.521291Z",
    "updated_at": "2025-03-27T02:09:18.71311Z",
    "deleted_at": null,
    "sha1_hash": "4b1ab4ec0efcd109806a2f02d73e083cbc0598d3",
    "title": "2021-03-01 - “Gootloader” expands its payload delivery options",
    "authors": "",
    "file_creation_date": "2022-05-28T21:41:54Z",
    "file_modification_date": "2022-05-28T21:41:54Z",
    "file_size": 1523191,
    "plain_text": "# “Gootloader” expands its payload delivery options\n\n**[news.sophos.com/en-us/2021/03/01/gootloader-expands-its-payload-delivery-options/](https://news.sophos.com/en-us/2021/03/01/gootloader-expands-its-payload-delivery-options/?cmp=30728)**\n\nMarch 1, 2021\n\nThe malware delivery method pioneered by the threat actors behind the REvil ransomware\nand the Gootkit banking Trojan has been enjoying a renaissance of late, as telemetry\nindicates that criminals are using the method to deploy an array of malware payloads in\n[South Korea,](https://asec.ahnlab.com/en/17211/) [Germany,](https://blog.malwarebytes.com/threat-analysis/2020/11/german-users-targeted-with-gootkit-banker-or-revil-ransomware/) [France, and across North America.](https://0x90909090.blogspot.com/2020/05/when-ransomware-does-seo.html)\n\nThe Gootkit malware family has been around more than half a decade – a mature Trojan with\nfunctionality centered around banking credential theft. In recent years, almost as much effort\nhas gone into improvement of its delivery method as has gone into the NodeJS-based\nmalware itself.\n\nIn the past, Sophos and other security experts have bundled the discussion of the malware\nitself with analysis of the delivery mechanism, but as this method has been adopted to\ndeliver a wider range of malicious code, we assert that this mechanism deserves scrutiny\n(and its own name), distinct from its payload, which is why we’ve decided to call it\n**Gootloader.**\n\nIn addition to the REvil and Gootkit payloads, Gootloader has been used most recently to\ndeliver the Kronos trojan and Cobalt Strike.\n\nIn its latest attempts to evade detection by endpoint security tools, Gootloader has moved as\nmuch of its infection infrastructure to a “fileless” methodology as possible. While it isn’t\ncompletely fileless, these techniques are effective at evading detection over a network – right\nup to the point where the malicious activity trips over behavioral detection rules.\n\n### Search engine deoptimization as root cause\n\nGootloader uses malicious search engine optimization (SEO) techniques to squirm into\nGoogle search results. The way it accomplishes this task deserves some discussion,\nbecause it centers as much around technology as human psychology.\n\n\n-----\n\nA malicious result that delivers Gootloader appears legitimate, even to Google\nTo accomplish this phase of the attack, the operators of Gootloader must maintain a network\nof servers hosting hacked, legitimate websites (we estimate roughly 400 such servers are in\noperation at any given time). The example shown above belongs to a legitimate business, a\nneonatal medical practice based in Canada. None of the site’s legitimate content has\nanything to do with real estate transactions – its doctors deliver babies – and yet it is the first\nresult to appear in a query about a very narrowly defined type of real estate agreement.\nGoogle itself indicates the result is not an ad, and they have known about the site for nearly\nseven years. To the end user, the entire thing looks on the up-and-up.\n\nWhen the visitor clicks through the link in this search result, they’re presented with another,\nvery specific page that seems to deliver the answer to their exact question, using precisely\nthe same wording as the search query (which sometimes comes across quite awkwardly).\n\n\n-----\n\nThese fake “message board” pages generated by Gootloader awkwardly repeat the search\nquery verbatim in multiple places on the page\nAnd if that same site visitor clicks the “direct download link” provided on this page, they\nreceive a .zip archive file with a filename that exactly matches the search query terms used\nin the initial search, which itself contains another file named in precisely the same way. This\n.js file is the initial infector, and the only stage of the infection at which a malicious file is\nwritten to the filesystem. Everything that happens after the target double-clicks this script\nruns entirely in memory, out of the reach of traditional endpoint protection tools.\n\nIn our experience, many of these hacked sites serving the fake message board are running a\nwell-known content management system, to which the threat actors make modifications that\nsubtly rewrite how the contents of the website are presented to certain visitors, based on\n\n\n-----\n\ncharacteristics of the individual visitors (including how they arrive on the hacked site).\n\nIt isn’t clear how the threat actors gain access to the backend of these sites, but historically,\nthese kinds of website compromises may be the result of any of a number of methods: The\nattackers may simply obtain the sites’ passwords from the Gootkit malware itself, or from any\nof a number of criminal markets that trade in stolen credentials, or by leveraging any of a\nnumber of security exploits in the plugins or add-ons of the CMS software. The operators of\nthe websites seem not to know their sites are being abused in this way.\n\nRegardless of how the attackers access the websites, what they do next is to insert a few\nadditional lines of code into the body of the web page. The elements where the attackers\ninject the code could be within one of the following div tags.\n\nThe modified code is a simple script tag that looks like this:\n\nThe server checks to see whether the conditions in which the page gets loaded meet the\ncriteria Gootloader has been looking for. Notably, the script appears to inspect the UserAgent string in the GET request header information to determine whether the visitor’s\ncomputer is running an operating system with the specific language/localization preferences\nthat the attackers have been targeting. It may also be using IP geolocation to determine\nwhether the person browsing the site is doing so from within the territory the attackers are\ntargeting.\n\nServer side, the attacker also checks whether the Referrer: header in the request indicates\nthe page was loaded after the victim clicked a Google search result. (Our tests indicated that\nother search engines were not targeted, or were not targeted as frequently – or successfully\n– as Google’s.) These kinds of checks make it more difficult for a website owner to identify\nthe problem with their own site.\n\nIn cases where the criteria is not met, the browser simply displays a normal-looking (but\nforged) web page, such as this blog post that starts out well, but spins into mostlyunintelligible word salad near the end:\n\n\n-----\n\nIf the right conditions are met (and there have been no previous visits to the website from the\nvisitor’s IP address), the malicious code running server-side redraws the page to give the\nvisitor the appearance that they have stumbled into a message board or blog comments area\nin which people are discussing precisely the same topic, using exactly the same terms the\nvictim used in their search.\n\nThese fake forum posts include what appears to be an authoritative post from a site\nadministrator offering a download of a document that purportedly gives the answer to the\nquestion raised by the search terms.\n\nInterestingly, these fake comments/message boards all share an identical appearance.\n\nIn these modified webpages, the page’s source code will contain a link to a file download on\nanother website. This download usually appears as a .zip archive that contains a single\n(malicious Javascript) document, which the visitor must unzip and then double-click before\n\n\n-----\n\nthe rest of the infection process may take place.\n\nThe parameter of the request also contains the search terms that led to the fake forum page,\nwhich the download site uses to construct a payload, on the fly, with a file name that matches\nthe original search terms. A quick survey of the filenames of samples we’ve collected give an\nindication of what the targets might have been searching for when they stumbled into\nGootloader’s malicious SEO trap.\n\nIn addition to the English-language payloads (targeting users in North America), malware\nrepositories contain a lot of Gootloader samples with filenames in German, French, and\nKorean, which appear to correspond to well-publicized campaigns targeting those countries.\nFor instance, here’s a variant of the fake forum targeting German-language speakers:\n\n\n-----\n\nAnd another example, in French, in which the search term exemple de dédicace à une amie\n(“example of dedication to a friend”) has been leveraged in both the title of the post and the\nlink to the Gootloader payload. Note that this “French” website uses English words as labels\nfor menu items and other elements. The fake page header typically displays the phrase\n“Questions And Answers.”\n\nAnd still another, in Korean. The Hangul translation reads “here is the download link” with the\nURL pointing to the same domain hosting Gootloader payloads that also target French and\nGerman speakers.\n\n\n-----\n\nThe similarity between the pages is unmistakable; All languages feature a “forum post” by a\nnew user with a five-petal flower as their user icon, and a reply from an account called Admin\nthat uses an hourglass icon. The text of the Google search query is repeated at the top of the\npage and within the fake “message board” posts.\n\nNeedless to say, it would be best if you avoid downloading files from pages that look identical\nto these.\n\n### First stage payloads: twice obfuscated\n\nGootloader’s initial payload is a .zip archive containing a file with a .js extension. Files with\nthe .js extension normally invoke the Windows Scripting Host (wscript.exe) when run.\n\nThis “first stage” script is the only component of the attack written to the filesystem. Because\nit’s the only one exposed to conventional AV scanning methods, the author has obfuscated\nthe script and added two layers of encryption to strings and data blobs related to the next\nstage of the attack.\n\n\n-----\n\nGootloader randomly generates variable names, and splits its decryption code into several\nsmall component functions. The first two lines of the code shown above, for example,\nperform two very minor tasks: one is a simple addition, the other is a string split function.\nSplitting them in this unexpected and unnecessary way complicates static analysis of the\nscript file.\n\nThis stage runs a block of data through the first decryption method, which outputs a second\nform of the data block that itself is obfuscated and encrypted, and contains embedded\nfunctions to decrypt itself. Only after it runs through this second decryption routine does the\nscript reveal its final instructions.\n\nThe obfuscation techniques have evolved over time. In the example shown above, the\nvariables are formed of random alphanumeric strings. Newer versions name the variables\nfrom randomly selected dictionary words, and may even include word-salad code\n“comments.”\n\nThe first stage script only exists to fetch the second stage code, cycling through three\ndifferent hardcoded web domains if necessary.\n\n\n-----\n\nThe decoded Gootloader Javascript taken from the initial file.\nGootloader even adds complications to the URL that retrieves the second stage: It appends\na unique parameter of random-looking characters (highlighted in yellow, above) and a\nrandom long number to the URL query string. The script shown above designates a “sleep”\nperiod of more than 22 seconds between some steps to slow down the process. And some\nGootloader scripts attempt to resolve the domain name(s) hosting the payloads from DNS\nbefore attempting to contact their C2, possibly as an anti-sandboxing measure.\n\n### Second-stage payload: Registry stuffing\n\nIf the first stage successfully contacts a C2, it receives a long string of numbers as a reply.\nThese numbers are the decimal (numeric) values that represent ASCII text characters, which\nthe first stage loads directly into memory, leaving no trace on the filesystem.\n\nThis stage contains a large blob of data that it, first, decodes from its numeric value into text,\nthen writes directly into a series of keys in the Windows Registry, under the HKCU\\Software\nhive. The key name varies from sample to sample.\n\n\n-----\n\nNext, this stage creates an autorun entry for a PowerShell script. This script, when run (at\nevery subsequent boot), decodes the contents of the Registry keys it wrote out in the\nprevious step. (It also names this autorun entry after the same string of random-looking text it\nused as a Registry key name.)\n\nBecause this next stage doesn’t completely execute until the next time the computer reboots,\nthe target may not actually discover the infection until some hours or even days later –\nwhenever they fully reboot Windows.\n\n### After a reboot: the final dominoes fall\n\nOnce the computer reboots, it triggers the PowerShell script to run, which starts a sequence\nof events culminating in Gootloader attempting to download its final payload. But Gootloader\nis not finished with its complications.\n\nThe current generation of Gootloader samples actually stores not one, but a pair of payloads\nin the Registry: a small C# executable, and a second executable that the first one decodes\nfrom the weird way it has been stored in the Registry.\n\n\n-----\n\nHere s the first payload, the C# executable, identifiable by its use of Windows MZ header\n(hexadecimal 4d5a) as the first two bytes.\n\nHere’s the second, and final, payload – counterintuitively, from its appearance, also an\nexecutable. In this case, the creator has encoded the numbers that make up the\nhexadecimal ASCII values as sequences of letters.\n\nThe secret decoder ring to parse this blob of data looks like this. The script runs the data in\nthe Registry keys through this substitution script, ends up with a hexadecimal representation\nof the second executable, then executes it (also directly into memory). Not all characters are\nsubstituted, so the first four bytes shown above, ydua, represent the 4d5a of the MZ header.\n\n\n-----\n\nThe script then executes the payload and, to give itself persistence after reboot, creates a\nRegistry run key that will execute the payload on the next startup (with the help of a\nPowerShell command):\n\nThis is the command registered by the registry loader. It serves as a failsafe mechanism for\nthe Gootloader infection process to survive a reboot.\n\n### dotNET injector with a twist\n\nThe final stage of the elaborate infection plan involves a dotNet injector. Executed either by\nthe registry loader or the failsafe PowerShell script, the result is the same: a simple .NET\nloader that contains the next stage, a Delphi-based loader malware, in the form of a data\nblob. Over time, this part of the infection process has evolved.\n\nAt first, the dotNET component simply decrypted the Delphi executable, which dropped and\nexecuted the eventual payload. Eventually, the attackers switched up the attack and added\nan intermediate step: The dotNET component would launch a benign application called\n**ImagingDevices.exe, an innocent system component installed by default on Windows**\noperating systems, then injected the Delphi executable into it using a process hollowing\ntechnique.\n\nThe most recent versions of the attack now involve the dotNET component writing out a\ndifferent, benign executable that belongs to a commercial software package called the\nEmbarcadero External Translation Manager to the file system (using as its filename the\nusername of the currently logged-in user). It then performs a process hollowing on that\nexecutable to load the Delphi component.\n\nIt performs this function by holding a copy of both the benign and the malicious payload\ninside of itself.\n\n\n-----\n\nThe first one (stored in the variable text2) is the benign application, digitally signed by its\npublisher. If the user of an infected computer suspects foul play, and investigates a program\nthat’s causing suspicious network traffic and/or high CPU load in the system, they would see\nwhat Windows considers a trusted application.\n\n\n-----\n\nIt drops and executes this clean application, then replaces the code in memory using\nprocess hollowing techniques with the contents of the second PE file (stored in the variable\n_text3)._\n\nThe Delphi loader contains the final payload – Kronos, REvil, Gootkit, or Cobalt Strike – in\nencrypted form. In those cases, the loader decrypts the payload, then uses its own PE loader\nto execute the payload in memory.\n\nThroughout the infection process, none of the malicious code is written to disk, maintaining\nthe fileless execution scheme right up to the end.\n\n### Cause and effect\n\nWhat does all this obfuscation, leaping from one scripting platform to another, and the most\nabsurdly, [Vizzini-grade complications of almost any malware distribution platform achieve?](https://www.imdb.com/title/tt0093779/characters/nm0001728)\n\nIf you’re an analyst, it might cost you a few hours of work to fully unpack and understand\neach stage of the attack. We haven’t even covered in this blog post all the possible variations\nwe’ve observed Gootloader using as final payload delivery methods, since it also might\ndeliver .net or Delphi-based code-injector executables, additional PowerShell scripts, or\nCobalt Strike modules.\n\nBut a criminal, ultimately, is just trying to buy a few minutes-to-hours of time remaining\nundetected to permit the attack to proceed without interference from endpoint protection\nsoftware. Instead of actively attacking the endpoint tools, as some malware distributors do,\nthe creators of Gootloader have traded the more aggressive approach for a technique that’s\ncloser to a massive setup of dominoes that conceal the end result.\n\n\n-----\n\nAt several points, it s possible for end users to avoid the infection, if they recognize the signs.\nThe problem is that, even trained people can easily be fooled by the chain of social\nengineering tricks Gootloader’s creators use. Script blockers like NoScript for Firefox could\nhelp a cautious web surfer remain safe by preventing the initial replacement of the hacked\nweb page to happen, but not everyone uses those tools (or finds them convenient or even\nintuitive). Even attentive users who are aware of the trick involving the fake forum page might\nnot recognize it until it’s too late.\n\nIn the end, it’s up to the search engines, whose algorithm the malware games to get a high\nsearch result, to address the initial attack vector. Users can be trained to do things like\nenable visible file suffixes in Windows, so they can see they’re clicking a file with a .js\nextension, but they can’t choose which search results appear near the top of the list or how\nthose sites get manipulated by threat actors.\n\n## Protection and indicators-of-compromise\n\nSophos Intercept X protects users by detecting undesirable actions and behaviors by\nmalware like Gootloader, such as the delivery of Cobalt Strike, or the use of its process\nhollowing techniques to inject malware onto a running system. Malicious javascript files may\nbe detected as AMSI/GootLdr-A, while the PowerShell components may be detected as\n**AMSI/Reflect-H or Exec_12a. Other behavioral detection rules may also block the infection**\nin the middle stages, before the final payload gets delivered.\n\n[Indicators of compromise for this analysis, including a Yara threat hunting rule that can help](https://github.com/sophoslabs/IoCs/blob/master/Troj-gootloader.yara)\nincident responders find similar Javascript files, have been posted to the SophosLabs\nGithub. Analysts who wish to execute samples of Gootkit or other Trojans in a test\n[environment may wish to consider using imaginaryC2, a Python tool created by Felix Weyne](https://www.github.com/felixweyne/imaginaryC2)\nto simulate the command-and-control communications responses that malware (including\nGootkit) expect to receive, without letting the malware reach the live internet.\n\n## Acknowledgments\n\nSophosLabs acknowledges the research contributions of Fraser Howard, Mark Loman, Peter\nMackenzie, Vikas Singh, and Feliz Weyne to this analysis and to the detection of Gootloader.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-03-01 - “Gootloader” expands its payload delivery options.pdf"
    ],
    "report_names": [
        "2021-03-01 - “Gootloader” expands its payload delivery options.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536169,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653774114,
    "ts_modification_date": 1653774114,
    "files": {
        "pdf": "https://archive.orkl.eu/4b1ab4ec0efcd109806a2f02d73e083cbc0598d3.pdf",
        "text": "https://archive.orkl.eu/4b1ab4ec0efcd109806a2f02d73e083cbc0598d3.txt",
        "img": "https://archive.orkl.eu/4b1ab4ec0efcd109806a2f02d73e083cbc0598d3.jpg"
    }
}