{
    "id": "a055e820-35b1-45f2-ae56-f20331c37126",
    "created_at": "2023-01-12T15:00:27.330645Z",
    "updated_at": "2025-03-27T02:05:23.248478Z",
    "deleted_at": null,
    "sha1_hash": "8361ea8fde408dbce1d4ca7a6e793ba5651947b4",
    "title": "2020-12-31 - Simplify Emotet parsing with Python and iced x86",
    "authors": "",
    "file_creation_date": "2022-05-27T22:27:23Z",
    "file_modification_date": "2022-05-27T22:27:23Z",
    "file_size": 2769989,
    "plain_text": "# Semplificare l’analisi di Emotet con Python e iced x86\n\n**[cert-agid.gov.it/news/malware/semplificare-lanalisi-di-emotet-con-python-e-iced-x86/](https://cert-agid.gov.it/news/malware/semplificare-lanalisi-di-emotet-con-python-e-iced-x86/)**\n\n#### 31/12/2020\n\n emotet In questi giorni l’Italia è interessata da campagne Emotet che fanno uso di payload offuscati che rendono l’analisi statica piuttosto tediosa. In questo caso infatti l’uso di un debugger non si rileva molto utile.\n La variante di Emotet analizzata impiega varie tecniche di offuscazione del codice, una di queste è nota come CFO (Control Flow Obfuscation); l’analisi con il debugger permette di ricostruire stringhe ed API utilizzate ma non aiuta ad avere una visione d’insieme del codice eseguito.\n\n In questo articolo vedremo come semplificare l’analisi di Emotet utilizzando Python e la libreria iced x86 per processare il codice offuscato di Emotet.\n\n Ma prima, introduciamo un po’ di contesto sul campione analizzato.\n\n## Macro, powershell e packer\n\n#### Il campione che abbiamo deciso di analizzare risale a qualche giorno fa.\n La catena di infezione ha inizio con un documento Word (pre 2007) con una macro malevola.\n\n Questa si presenta, come spesso accade, offuscata tramite l’utilizzo di linee di codice irrilevante.\n Si riporta di seguito un estratto.\n\n\n-----\n\n```\nFunction S619csvpd1v4xzk5kc(Xoyqcbzwjyi6tqiw0z)\n  GoTo GKsgQaAGE\nDim NmmcJMB As String 'POyDeJ\nOpen \"dVMtDJ.ecCLuZ.vNWxUB\" For Binary As 154\nOpen \"GmQlB.gLlkBCq.ohnmP\" For Binary As 154\nOpen \"asHdBA.RNUGfJo.UEIiMmoM\" For Binary As 154\nPut #154,, NmmcJMB\nClose #154\nGKsgQaAGE:\nGoTo fIjVkJj\nDim jFUMUmIIJ As String 'NskblDD\nOpen \"fRHrGnFp.uWltAIHCI.WYWvIWr\" For Binary As 146\nOpen \"qQeaRICAm.KgqZFRWRC.cuPrnUFxk\" For Binary As 146\nOpen \"ShUECDIR.otrtDOGBA.OugaBFHlJ\" For Binary As 146\nPut #146,, jFUMUmIIJ\nClose #146\nfIjVkJj:\nGoTo hTTQEJEAC\nDim OybSq As String 'kEafA\nOpen \"umMOXxmA.SfYuGDN.ueONFAEFD\" For Binary As 227\nOpen \"eIQhLAGS.forvJhMB.LGyFI\" For Binary As 227\nOpen \"TifoEDtFB.fukVJAvIS.dlciFGDA\" For Binary As 227\nPut #227,, OybSq\nClose #227\nhTTQEJEAC:\nHBYVV = \"\"\nS619csvpd1v4xzk5kc = HBYVV + VBA.Replace _\n(Xoyqcbzwjyi6tqiw0z, \"qq\" + \")(s2)\" + \"(\", W5ya1q1z48ltq3z_)\n  GoTo mJsZBCEFo\nDim jUDsXM As String 'gtpnJOwLd\nOpen \"myDIGCFHC.cgXWyuEFC.OybuGU\" For Binary As 131\nOpen \"EnJMG.KCVSIHB.BJiWBGLWG\" For Binary As 131\nOpen \"kfSFYoEHi.aXUIAvAP.dswKhikA\" For Binary As 131\nPut #131,, jUDsXM\nClose #131\nmJsZBCEFo:\nGoTo BOzmWI\nDim CJeaFB As String 'jtrvFEWLD\nOpen \"dfOYHJLF.uBXVkGE.ghpJGB\" For Binary As 124\nOpen \"MTfEVUDIQ.DlrvrPEB.PgggwwMD\" For Binary As 124\nOpen \"YHUtVQCI.AyvDaAH.JsZULCUu\" For Binary As 124\nPut #124,, CJeaFB\nClose #124\nBOzmWI:\nGoTo kPMjtUB\nDim eVbTfoFi As String 'xTUBS\nOpen \"eXoWdB.HSupDA.oXRxAS\" For Binary As 149\nOpen \"nmuAl.yeRQHDs.UqyoFI\" For Binary As 149\nOpen \"nzFmWEVE.ZFvEGsIFD.mjIMGVD\" For Binary As 149\nPut #149,, eVbTfoFi\nClose #149\nkPMjtUB:\nEnd Function\nFunction Tujor4m47ob()\nOn Error Resume Next\n\n```\n\n-----\n\n```\nsh2v T6dwlv_ivpoiq2.StoryRanges.Item(1)\n  GoTo aektCnFI\nDim jaJUkAFeG As String 'cwxgFSS\nOpen \"DbnKMvMAH.jHcdBADv.EGxUCAADs\" For Binary As 201\nOpen \"gQEGCB.HVmcrDI.zGpVIUABC\" For Binary As 201\nOpen \"shyujG.RFwdH.VPRoIX\" For Binary As 201\nPut #201,, jaJUkAFeG\nClose #201\naektCnFI:\nGoTo RtfzGtt\nDim WWCACxG As String 'mRJNaEGtF\nOpen \"vATeCIgJI.FpiaIJIiJ.MmplJ\" For Binary As 153\nOpen \"MOIhAmCn.UAJXCE.BwsiJS\" For Binary As 153\nOpen \"NpVFCB.MCDxG.UpDmKPxpp\" For Binary As 153\nPut #153,, WWCACxG\nClose #153\nRtfzGtt:\nGoTo QSISC\n\n#### Estratto del codice della macro di Emotet.\n\n### Codice superfluo\n\n#### Soffermandoci a leggere il codice è possibile osservare la ripetizione di un pattern in particolare: tutte le istruzioni per la scrittura di file (Open, Put, Close) sono inutili.\n Stesso discorso vale per i GoTo che puntano sempre verso l’etichetta successiva, risultando quindi inutili.\n Anche le dichiarazioni di variabile (Dim) sono inutili.\n\n Possiamo quindi semplificare il codice mediante una semplice sostituzione che rimuova le righe con le istruzioni Open, Put, Close, GoTo e le etichette.\n La seguente regex svolge proprio questo compito:\n\n```\n```\n^\\s(Open |Put |Close |GoTo |Dim |[A-Za-z]+:).$\n\n```\n\n#### (gli spazi nella regex sono rilevanti)\n\n Il risultato, una volta rimosse le linee superflue, è più compatto ed attaccabile.\n\n\n-----\n\n```\nFunction S619csvpd1v4xzk5kc(Xoyqcbzwjyi6tqiw0z)\nHBYVV = \"\"\nS619csvpd1v4xzk5kc = HBYVV + VBA.Replace _\n(Xoyqcbzwjyi6tqiw0z, \"qq\" + \")(s2)\" + \"(\", W5ya1q1z48ltq3z_)\nEnd Function\nFunction Tujor4m47ob()\nOn Error Resume Next\nsh2v = T6dwlv_ivpoiq2.StoryRanges.Item(1)\nsng2 = \"qq)(\" + \"s2)(pq\" + _\n \"q)(s2)(\"\nF7_if4svnte = \"qq)(s\" + _\n \"2)(roqq\" + \")(s2)(qq)(s2)(ceqq)(s2)\" + _\n \"(sqq)(s2)(sqq)(s2)(qq)(s2)(\"\nVbzhqcqh1pqco1e2_ = \"qq)(s2)(\" + \":wqq)(s2)(qq)(s\" + _\n \"2)(inqq)(s2)(3qq)(s\" + _\n \"2)(2qq)(s2)(_qq)(s2)(\"\nR67uawfvzvw = \"wqq)(s2\" + _\n \")(inqq)(s2)(mqq)(s\" + \"2)(gmqq)(s2)(tqq)(\" + \"s2)(qq)(s2)(\"\nKz1yuitvz3qu6xai = Kfo_8qx2w7l7x71 + ChrW(Hvsf68urunanusc + wdKeyS + A08llnuiz59xyw7)\n+ Pgjdd1yrw8qt\nNi1wsg2ja20x23qpzl = R67uawfvzvw + Kz1yuitvz3qu6xai + Vbzhqcqh1pqco1e2_ + sng2 +\nF7_if4svnte\nKltqgnwd4i8 = C0d4mc619_eaiuirzl(Ni1wsg2ja20x23qpzl)\nSet Bx9ystsny9ej4ynfne = CreateObject(Kltqgnwd4i8)\nWb0zemdl5ow9 = Mid(sh2v, (5), Len(sh2v))\nBx9ystsny9ej4ynfne.Create C0d4mc619_eaiuirzl(Wb0zemdl5ow9), Gge416y0ol9ajq,\nZ2vzndsnblr9xje7s\nEnd Function\nFunction C0d4mc619_eaiuirzl(Hcmfukntlsj04fj5x3)\nOn Error Resume Next\nH4k01s90g3qjf9v7e = (Hcmfukntlsj04fj5x3)\nIxl3ey6k7oiq4qmw8 = S619csvpd1v4xzk5kc(H4k01s90g3qjf9v7e)\nC0d4mc619_eaiuirzl = Ixl3ey6k7oiq4qmw8\nEnd Function\n\n#### Il codice della macro di Emotet, una volta rimosse le parti inutili.\n\n A questo punto è immediato osservare che il codice della macro si basa su:\n\n eliminazione della stringa qq)(s2)( payload contenuto nel documento ( T6dwlv_ivpoiq2.StoryRanges.Item(1) ) comando di esecuzione di quest’ultimo (comando generato concatenando gli string literal contenuti nella macro).\n\n Il payload è uno script powershell (codificato in base64), inserendo un carattere di fine linea, dopo ogni punto e virgola, otteniamo un codice già abbastanza leggibile.\n\n```\n\n-----\n\n#### Il codice del payload Powersell, di facile interpretazione. A questo punto risultano facilmente individuabili:\n\n le modalità di download ( Net.WebClient.DownloadFile ); i C2 (è interessante notare come i C2 fossero tutti siti WordPress compromessi); la modalità di esecuzione (tramite rundll32).\n\n Il file scaricato, come ci si aspetta, è una DLL che esportata una routine chiamata RunDLL.\n\n Una ricognizione con CFF Explorer rileva la presenza di una risorsa con dati binari e l’analisi con IDA mostra la presenza delle stringhe LdrAccessResource e LdrFindResource_U e di una chiamata a VirtualAlloc.\n\n Risulta quindi facile dedurre che abbiamo a che fare con un packer. Infatti, tenendo traccia del buffer allocato con VirtualAlloc si ottiene rapidamente il payload. Una nuova DLL.\n\n\n-----\n\n#### I componenti del packer. In alto a sinistra il codice che rileva l’accesso alla risorsa. In alto a destra il codice che alloca il buffer per il payload e lo decodifica. In basso la risorsa contente il payload codificato. La DLL ottenuta contiene il codice del malware Emotet e come vedremo presenta varie tecniche di offuscazione.\n\n## L’offuscazione di Emotet\n\n#### Navigando la DLL di Emotet con IDA si notano alcune tecniche di offuscazione, consideriamo ad esempio, la procedura riportata nella figura sotto.\n\n\n-----\n\n#### La procedura principale di Emotet. Da questa visione d’insieme è evidente la presenza di CFO. L’immagine sopra riportata racchiude quasi tutti i blocchi di codice della procedura principale di Emotet, dato l’elevato numero di blocchi non è possibile leggere il codice di ognuno, ma due di essi sono stati appositamente ingranditi per metterli in evidenza.\n Dalle istruzioni presenti in questi due blocchi, le quali confrontano il valore del registro ECX con una costante, si intuisce che siamo in presenza di CFO.\n\n Il valore del registro ECX – nota che il registro usato varia da procedura a procedura – contiene un numero (chiamiamolo token per comodità) che indica quale blocco di codice eseguire.\n Si tratta di un enorme switch implementato con tanti salti condizionali, anzichè con un jump table (che renderebbe l’analisi più semplice).\n Dopo l’esecuzione di ogni blocco di codice, un nuovo token viene messo in ECX per proseguire al prossimo blocco di codice utile.\n\n Uno dei nostri obiettivi è quello di trasformare la funzione sopra nella sua forma originale, mostrata qui sotto.\n\n\n-----\n\n#### La procedura principale di Emotet una\n\n\n#### volta rimossa l’offuscazione CFO.\n\n\n-----\n\n#### Oltre a CFO, questo campione di Emotet non importa nessuna API e la sezione dei dati è codificata. Infine, le costanti sono tutte create nello stack con una sequenza di istruzioni variabile ma più o meno fa uso delle stesse operazioni.\n\n Esempio di creazione della costante 513 nella variabile var_198 (poi mai usata). Vedremo come rimuovere, in parte, queste forme offuscazione.\n\n## Il lavoro sporco: PE, decodifica delle istruzioni e basic block\n\n#### Per poter manipolare il codice di Emotet è necessario effettuare un processo di reificazione del codice x86.\n\n Il primo obiettivo consiste nel poter manipolare le istruzioni x86. La decodifica e la codifica delle istruzioni x86 non è particolarmente complessa in sè, ovviamente è richiesta esperienza con il linguaggio assembly x86 e con la consultazione dei manuali Intel (di interesse è solo il volume 2), tutti prerequisiti base per affrontare l’analisi.\n\n\n-----\n\n#### Il formato generale delle istruzioni x86. La vera complessità nello scrivere codice per la decodifica (e codifica) delle istruzioni x86 sta nel fatto che il formato è variabile, i campi ModRM ed Immediate dipendono dal valore dell’Opcode (questo a sua volta ha lunghezza variabile) e di Opcode ve ne sono migliaia.\n Il formato delle istruzioni x86 è vecchio di 41 anni e la sua continua espansione da parte di Intel (e talvolta AMD) ha portato ad un zoo di istruzioni codificate tramite una serie di hack, al punto che la decodifica delle istruzioni è uno dei principali colli di bottiglia delle CPU x86 (il front-end richiede addirittura un passo di pre-decodifica per poter essere super-scalare).\n\n La decodifica può essere effettuata facilmente con delle tabelle di lookup, a patto di voler trascrivere le mappe fornite in appendice al volume 2 da Intel. Parliamo di centinaia di istruzioni, ognuna con più varianti (es: mov r32, rm32 e mov rm32, imm32 sono documentate sotto la voce MOV), per un totale che supera il migliaio.\n\n Abbiamo quindi deciso di usare una libreria già pronta. Questa deve permettere non solo la decodifica ma anche la codifica e l’alterazione delle istuzioni.\n La scelta è ricaduta su iced x86, una libreria (per lo più generata automaticamente) Rust, .NET e Python (linguaggio scelto dal Cert-AgID perchè gia predisposto).\n Iced x86 ha molte funzionalità utili, come la possibilità di determinare il modo in cui una funzione altera il flusso di esecuzione e vari metodi helper per la creazione e l’introspezione delle istruzioni.\n\n Con iced x86 le istruzioni x86 diventano oggetti python che possiamo mettere in una lista e modificare a piacere.\n La classe Encoder permette di ricodificare le istruzioni a qualsiasi indirizzo, permettendoci di lavorare con le istruzioni senza dover pensare a come sono codificate (la codifica di alcune istruzioni, tipo un salto near relativo, dipende dall’indirizzo dell’istruzione e dal target del salto).\n\n\n-----\n\n#### Prima di poter decodificare le istruzioni, è necessario trovarle. Per fare ciò ci serve processare il file PE della DLL di emotet e poi decodificare le istruzioni utilizzando la tecnica di descending.\n\n Esistono varie librerie Python per il parsing dei file PE (quella più famosa è pefile) ma più o meno tutte soffrono del tipico problema delle librerie Python: assenza di documentazione o documentazione limitata ad esempi che descrivono come muovere i primi passi.\n\n Dato che la struttura PE è molto semplice, abbiamo preferito scrivere una funzione per il parsing dei campi PE di interesse. In particolare ci serve conoscere: le varie sezioni, i vari allineamenti (su file ed in memoria), i nomi esportati, la sezione di codice e quella di dati (ricordate appositamente data la loro importanta), il base address dell’immagine ed infine l’ultimo RVA e offset usato (per aggiungere nuove sezioni) ed il minimo offset delle sezioni (per vedere se c’è posto per aggiungere nuove entry nella tabella delle sezioni).\n\n\n-----\n\n```\ndef read_dw(bytes, off 0):\n  return bytes[off] | (bytes[off+1] << 8) | (bytes[off+2] << 16) | (bytes[off+3]\n<< 24)\ndef read_w(bytes, off=0):\n  return bytes[off] | (bytes[off+1] << 8)\ndef write_dw(bytes, off=0, val=0):\n  bytes[off] = val & 0xff\n  bytes[off+1] = (val >> 8) & 0xff\n  bytes[off+2] = (val >> 16) & 0xff\n  bytes[off+3] = (val >> 24) & 0xff\ndef write_w(bytes, off=0, val=0):\n  bytes[off] = val & 0xff\n  bytes[off+1] = (val >> 8) & 0xff\ndef load_pe(filename, export = \"RunDLL\"):\n  with open(filename, \"rb\") as f:\n    dll = f.read()\n  if dll[0:2] != b'MZ':\n    raise ValueError(f\"{filename} doesn't have a valid MZ header.\")\n  pe_off = read_dw(dll, 0x3c)\n  if dll[pe_off:pe_off+4] != b'PE\\0\\0':\n    raise ValueError(f\"{filename} doesn't have a valid PE header.\")\n  n_sec = read_w(dll, pe_off+6)\n  size_opt = read_w(dll, pe_off + 0x14)\n  sec_table = pe_off + size_opt + 0x18\n  first_off = len(dll)\n  last_off = 0\n  last_rva = 0\n  code_rva = data_rva = None \n  secs = []\n  for x in range(n_sec):\n    cur_sec = sec_table + 0x28*x\n    cur_rva = read_dw(dll, cur_sec + 0xc)\n    cur_off = read_dw(dll, cur_sec + 0x14)\n    cur_size = read_dw(dll, cur_sec + 0x10)\n    cur_vsize = read_dw(dll, cur_sec + 0x8)\n    if dll[cur_sec : cur_sec+8] == b'.text\\0\\0\\0':\n      code_rva = cur_rva\n      code_off = cur_off\n      code_size = cur_size\n      code_vsize = cur_vsize\n    elif dll[cur_sec : cur_sec+8] == b'.data\\0\\0\\0':\n      data_rva = cur_rva\n      data_off = cur_off\n      data_size = cur_size\n\n```\n\n-----\n\n```\n      data_vsize cur_vsize\n    secs.append({\n      \"name\" : dll[cur_sec:cur_sec+8],\n      \"rva\": cur_rva,\n      \"off\": cur_off,\n      \"size\": cur_size,\n      \"vsize\": cur_vsize,\n    })\n    if cur_off + cur_size > last_off:\n      last_off = cur_off + cur_size \n    if first_off > cur_off:\n      first_off = cur_off\n    if cur_rva + cur_vsize > last_rva:\n      last_rva = cur_rva + cur_vsize\n    image_base = read_dw(dll, pe_off + 0x34)\n    entry_point = read_dw(dll, pe_off + 0x28)\n    file_align = read_dw(dll, pe_off + 0x3c)\n    sec_align = read_dw(dll, pe_off + 0x38)\n  if code_rva is None:\n    raise ValueError(f\"Cannot find the .text section in {filename}.\")\n  if data_rva is None:\n    raise ValueError(f\"Cannot find the .data section in {filename}.\")\n  def rva_to_off(rva):\n    for s in secs:\n      if rva >= s[\"rva\"] and rva < s[\"rva\"] + s[\"vsize\"]:\n        return rva - s[\"rva\"] + s[\"off\"]\n    return None \n  def read_cstr(data, off=0):\n    res = \"\"\n    while data[off] != 0:\n      res += chr(data[off])\n      off += 1\n    return res\n  n_dirs = read_dw(dll, pe_off + 0x74)\n  exp_rva = exp_size = exp_off = None \n  if n_dirs > 0:\n    exp_rva = read_dw(dll, pe_off + 0x78)\n    exp_size = read_dw(dll, pe_off + 0x7c)\n    exp_off = rva_to_off(exp_rva)\n  exports = []\n  if exp_off is not None:\n    n_names = read_dw(dll, exp_off + 0x18)\n    names = rva_to_off(read_dw(dll, exp_off + 0x20))\n    ordinals = rva_to_off(read_dw(dll, exp_off + 0x24))\n    addresses = rva_to_off(read_dw(dll, exp_off + 0x1c))\n\n```\n\n-----\n\n```\n    for i in range(n_names):\n      name = read_cstr(dll, rva_to_off(read_dw(dll, names + i * 4)))\n      ordinal = read_w(dll, ordinals + i * 2)\n      rva = read_dw(dll, addresses + ordinal * 4)\n      exports.append({\n        \"name\" : name,\n        \"rva\" : rva,\n        \"off\" : rva_to_off(rva)\n      })\n  return {\n    \"dll\": dll[:],\n    \"pe_off\": pe_off,\n    \"n_sec\": n_sec,\n    \"size_opt\": size_opt,\n    \"sec_table\": sec_table,\n    \"first_off\": first_off,\n    \"last_rva\": last_rva,\n    \"last_off\": last_off,\n    \"secs\": secs,\n    \"code\": {\n      \"rva\": code_rva,\n      \"off\": code_off,\n      \"size\": code_size,\n      \"vsize\": code_vsize,\n      \"data\": dll[code_off:code_off+code_size],\n    },\n    \"data\": {\n      \"rva\": data_rva,\n      \"off\": data_off,\n      \"size\": data_size,\n      \"vsize\": data_vsize,\n      \"data\": dll[data_off:data_off+data_size],\n    },\n    \"exp\": {\n      \"rva\": exp_rva,\n      \"size\": exp_size,\n      \"off\": exp_off,\n    },\n    \"image_base\" : image_base, \n    \"entry_point\" : entry_point,\n    \"file_align\" : file_align,\n    \"sec_align\" : sec_align,\n    \"exports\": exports,\n  }\n\n#### L’orribile codice utilizzato per il parsing PE. Notare che si tratta di codice prototipo, non usare in produzione a meno di non voler essere licenziati!\n\n Dopo il parsing PE abbiamo a disposizione tutte le informazioni per la decodifica delle istruzioni: il base address dell’immagine può essere sommato all’RVA della routine RunDLL (anch’esso recuperato nel parsing) per ottenere l’indirizzo in memoria del codice, l’RVA\n\n```\n\n-----\n\n#### stesso può essere usato insieme alle informazioni sulla sezione di codice per ottenere l’offset all’interno di questa dell’inizio della funzione.\n```\n#Load PE\ndll = load_pe(\"emotet.dll\")\n#Decode\nstart = dll[\"exports\"][0][\"rva\"] + dll[\"image_base\"]\nstart_f = descend_func(start, dll[\"code\"][\"data\"], start - dll[\"image_base\"] dll[\"code\"][\"rva\"])\n\n Parsing del PE di emotet e chiamata alla funzione di descending del codice del primo nome esportato.\n\n Chi programma in assembly sa bene che il codice è dati ed i dati sono codice, non vi è differenza sintattica tra i due. La decodifca delle istruzioni non può quindi procedere da un indirizzo in avanti perchè potremmo incorrere nella seguenti situazioni.\n\n Due situazioni problematiche per la decodifica sequenziale. Le frecce indicano i salti del codice.\n\n```\n\n-----\n\n#### Dobbiamo quindi adottare l approccio dei dissassemblatori descending (tipo IDA), i quali decodificano una serie di istruzioni fino alla prima istruzione di salto (escluse chiamate ma inclusi ritorni al chiamante, ovvero l’istruzione ret ). Questa serie di istruzioni, che per loro natura contengono al massimo un salto e solo come ultima istruzione, si chiama basic block (BB in breve).\n\n Un BB necessità di: una lista di istruzioni, un’indirizzo (un VA) di inizio che lo identifica univocamente (e che aiuta nel debug se posto uguale a quello reale determinato dal PE) e una lista di successori.\n\n Il nostro codice prototipo non gestisce salti indiretti e quindi si avranno, 0, 1 o 2 successori per ogni BB.\n\n Oltre a queste caratteristiche, torna utile salvare tutte le istruzioni chiamata individuate. Queste serviranno per scoprire altro codice da decodificare.\n\n Infine, per la ricodifica sono utili altri due campi: uno con il codice macchina generato dalla lista di istruzioni ed uno con l’offset (all’interno della nuova sezione di codice) in cui è rigenerato il codice del BB.\n\n\n-----\n\n```\nclass BasicBlock(object):\n  CACHE = {}\n  START_ADDRESS_FOR_DUPLICATES = -1\n  def __init__(self, start_address, insts = None):\n    self.start_address = start_address\n    self.insts = insts or []\n    self.nexts = []\n    self.update_len()\n    self.calls = []\n    self.splitted = False\n    self.encoded = None\n    self.offset = None\n    self._cfo_last_registers = None\n    BasicBlock.CACHE[self.start_address] = self\n  def duplicate(self):\n    dup = BasicBlock(BasicBlock.START_ADDRESS_FOR_DUPLICATES, self.insts.copy())\n    dup.nexts = self.nexts.copy()\n    dup.calls = self.calls.copy()\n    dup.splitted = self.splitted\n    dup.encoded = dup.offset = None\n    BasicBlock.START_ADDRESS_FOR_DUPLICATES -= 1\n    return dup\n  def update_len(self):\n    tot = 0\n    addr = self.start_address\n    encoder = Encoder(32)\n    for i in self.insts:\n      if i.len == 0:\n        ilen = encoder.encode(i, addr)\n        i.len = ilen\n      tot += i.len\n      addr += i.len\n    self.len = tot\n  #The address \"item\" is in this BB (but not at the very beginning or end)?\n  def __contains__(self, item):\n    return item > self.start_address and item < (self.start_address + self.len)\n  def add_inst(self, i):\n    self.insts.append(i)\n    self.len += i.len\n  def split_at(self, address):\n    old_len = address - self.start_address\n    if old_len == 0:\n      raise ValueError(\"Invalid split! Cannot split at the beginning of a BB.\")\n    if old_len == self.len:\n      raise ValueError(\"Invalid split! Cannot split at the end of a BB.\")\n    #print(f\"Splitting {hex(self.start_address)} at {hex(address)} (len:\n\n```\n\n-----\n\n```\n{hex(self.len)}) )\n    #print(\"Nexts before split: \" + str([hex(x.start_address) for x in\nself.nexts]))\n    tot = 0\n    for j, i in enumerate(self.insts):\n      if tot == old_len:\n        break \n      elif tot > old_len:\n        #print(f\"{hex(self.start_address)} + {hex(self.start_address +\nself.len)}\")\n        raise ValueError(f\"Invalid split address {hex(address)}!\")\n      tot += i.len\n    new_bb = BasicBlock(address, self.insts[j:])\n    self.len = old_len\n    self.insts = self.insts[:j]\n    new_bb.nexts = self.nexts \n    new_bb.splitted = self.splitted\n    self.splitted = True\n    self.nexts = [new_bb]\n    #print(f\"After: (len: {hex(self.len)})\")\n    #print(\"Nexts after split: \" + str([hex(x.start_address) for x in\nself.nexts]))\n    return new_bb\n  #Add a next to this BB, but if it's splitted, traverse its successors until the\nfirst\n  # non split block (this is necessary because during the descending of blocks with\ntwo\n  # successor, one branch may split the current BB and the other would attach to\nthe end of the\n  # now splitted block insead to the end of the block left after the splitting\naddress.)\n  def add_next(self, item):\n    #print(f\"Adding next {hex(item.start_address)} to {hex(self.start_address)}\")\n    last_bb = self\n    while last_bb.splitted:\n      #print(\"Skipping to next BB, this is splitted\")\n      last_bb = last_bb.nexts[0]\n    if item not in last_bb.nexts:\n      last_bb.nexts.append(item)\n  def iterate(self, cb, start):\n    bbs = [self]\n    done = []\n    while bbs:\n      bb = bbs.pop(0)\n      start += cb(bb)\n\n```\n\n-----\n\n```\n      done.append(bb)\n      bbs += [x for x in bb.nexts if x not in bbs and x != bb and x not in\ndone]\n    return start\n  def __str__(self):\n    def show_bb(bb):\n      formatter = Formatter(FormatterSyntax.NASM)\n      s = f\"loc_{hex(bb.start_address)}:\\n\"\n      for i in bb.insts:\n        s += f\"\\t{formatter.format(i)}\\n\"\n      s+= \"\\n\".join(map(lambda x: f\"\\t\\t->loc_{hex(x.start_address)}\",\nbb.nexts)) + \"\\n\"\n      return s\n    return self.iterate(show_bb, \"\")\n  def _show(self):\n    for n, i in enumerate(self.insts):\n      print(f\"({n}) {hex(i.ip)} {i:ns}\")\n\n#### La classe che rappresenta un BB. Anche qui il codice è stato scritto senza considerare i principi OOP o di stile. Il codice è molto grezzo ma intuitivo.\n\n Rimane aperta una questione spinosa, evidenziata dall’attributo splitted e dal metodo\nsplit_at della classe sopra.\n\n A volte un BB va diviso in due parti perchè un altro BB contiene un salto che atterra proprio nel mezzo del nostro BB. Questo succede quando i compilatori riusano del codice già generato. Sotto è evidenziato un esempio di un BB che è stato diviso (da IDA) a seguito di questa problematica. Si noti come i primi due BB non terminino con un’istruzione di salto.\n\n```\n\n-----\n\n#### Esempio di due BB, splitted, che non terminano con un’istruzione di salto. Essendo la destinazione di salti in altri BB, devono essere separati dal BB che li conteneva (quello in alto in questo caso). La gestione dello “splitting” dei BB è necessaria non solo per creare un corretto grafo di esecuzione (come fa IDA) ma anche perchè durante il descending di un BB con due successori è possibile che uno di questi finisca per dividere proprio il blocco in analisi. Quando l’altro ramo di esecuzione è processato, per determinare l’altro successore, senza\n\n\n-----\n\n#### adeguata gestione, questo viene attaccato al BB sbagliato. Quando viene chiesto di attaccare un successore ad un BB che risulta diviso, è necessario attaccarlo invece all’unico successore di questi (che a sua volta può essere diviso).\n\n Fatte queste considerazioni, il descending è poi piuttosto semplice: si decodifica ogni istruzione, inserendola nel BB corrente. Se si incontra un’istruzione ret (o un errore) terminiamo la procedura, se si incontra un’istruzione di salto, richiamiamo ricorsivamente il descending sulla destinazione del salto e attacchiamo il BB così ottenuto come successore di quello attuale. Nel caso di salti condizionali si hanno due possibili successori:\n\n uno è il fallthrough (ovvero la prossima istruzione, quando il salto non è preso); l’altro è il target del salto.\n\n Per convenzione, che va rispettata durante la ricodifica, il fallthrough è il primo successore della lista di successori di un BB.\n\n\n-----\n\n```\ndef descend_bb(start, code, offset):\n  #Already processed?\n  if start in BasicBlock.CACHE:\n    return BasicBlock.CACHE[start]\n  #In the middle of another BB (but not at its beginning)?\n  for _, bb in BasicBlock.CACHE.items():\n    if start in bb:\n      return bb.split_at(start)\n  #Descend the BB\n  decoder = Decoder(32, code[offset:])\n  decoder.ip = start\n  cur_bb = BasicBlock(start)\n  #print(f\"BB START: {hex(start)} (offset {hex(offset)})\")\n  #For each instruction\n  for i in decoder:\n    #Add it to the BB\n    cur_bb.add_inst(i)\n    #These instructions end the BB with no next BBs\n    if i.flow_control in [FlowControl.RETURN, FlowControl.EXCEPTION,\nFlowControl.INDIRECT_BRANCH]:\n      #print(f\"BB END: {hex(i.ip + i.len-1)}\")\n      return cur_bb\n    #These instructions are remembered for convenience but they don't influence\nthe building of the BB\n    elif i.flow_control in [FlowControl.CALL]:\n      #print(f\"FOUND CALL at {i.ip} to {i.near_branch_target}\")\n      cur_bb.calls.append(i)\n    #These instructions are ignored\n    elif i.flow_control in [FlowControl.NEXT, FlowControl.XBEGIN_XABORT_XEND,\nFlowControl.INTERRUPT, FlowControl.INDIRECT_CALL]:\n      pass \n    #These instructions end the BB with a single next BB\n    elif i.flow_control in [FlowControl.UNCONDITIONAL_BRANCH]:\n      target = i.near_branch_target\n      target_off = target-start+offset\n      #print(f\"BB END (UB): {hex(i.ip + i.len-1)}\")\n      #Descend from the target\n      cur_bb.add_next(descend_bb(target, code, target_off))\n      return cur_bb\n    #These instructions end the BB with two next BBs\n    elif i.flow_control in [FlowControl.CONDITIONAL_BRANCH]:\n      target = i.near_branch_target\n      target_off = target-start+offset\n      target_next = i.ip + i.len \n      target_next_off = target_next-start+offset\n\n```\n\n-----\n\n```\n      #print(f\"BB END (CB): {hex(i.ip + i.len-1)} - {len(cur_bb.insts)}\")\n      #First the fallthrough BB\n      cur_bb.add_next(descend_bb(target_next, code, target_next_off))\n      #Then the branching BB\n      cur_bb.add_next(descend_bb(target, code, target_off))\n      return cur_bb\n    else:\n      raise ValueError(\"Unhandled flow!\")\n\n#### La funzione di descending di un BB. A partire da un VA e relativo offset nella sezione di codice, crea il grado di esecuzione e ritorna il BB di inizio del suddetto grado.\n\n Si può notare, nel codice, l’utilizzo di un dizionario di cache. Questo dizionario mappa ogni indirizzo con l’eventuale BB a quell’indirizzo. Questa cache è necessaria per evitare di processare lo stesso indirizzo più volte (evitando cicli infiniti). E’ inoltre utile per scorrere tutti i BB processati (un’operazione che servirà in seguito).\n\n Con il descending abbiamo quasi finito. La procedura descend_bb (che forse era meglio includere nella class BasicBlock ) se utilizzata all’indirizzo di inizio di una procedura genera il grafo di esecuzione di questa e la lista di chiamate effettuate. E’ conveniente quindi creare una classe Function che tiene traccia del BB di inizio del grafo (detto head) e delle funzioni chiamate.\n\n```\n\n-----\n\n```\nclass Function(object):\n  CACHE = {}\n  def __init__(self, address, head = None):\n    self.address = address \n    self.head = head\n    self.callees = []\n    Function.CACHE[address] = self \n  def next_calls(self):\n    def collect_calls(bb):\n      calls = []\n      for c in bb.calls:\n        target = c.near_branch_target\n        if target not in calls: #target not in Function.CACHE and\n          calls.append(target)\n      return calls \n    return list(set(self.head.iterate(collect_calls, [])))\n  def linearize_bbs(self):\n    return list(set(self.head.iterate(lambda x: [x], [])))\n  def __str__(self):\n    return f\"sub_{hex(self.address)}:\\n\" + str(self.head)\ndef descend_func(start, code, offset):\n  if start in Function.CACHE:\n    return Function.CACHE[start]\n  f = Function(start, descend_bb(start, code, offset))\n  #print(f\"Next calls: {len(f.next_calls())}.\")\n  for c in f.next_calls():\n    f.callees.append(descend_func(c, code, c - start + offset))\n  return f \n\n#### Il codice per la reificazione delle funzioni si basa sul codice dei BB.\n\n Un’ultima nota: la classe BasicBlock contiene un metodo iterate che elenca tutti i BB raggiungibili da quello su cui è chiamato, rompendo i cicli infiniti (in pratica ogni BB è presente una ed una sola volta).\n\n A questo punto abbiamo uno strumento per l’analisi dell’esecuzione di codice x86. Possiamo modificare il codice processato inserendo e modificando istruzioni (una chiamata a update_len è necessaria dopo ogni modifica). Possiamo anche creare nuovi BB o ridefinire i collegamenti tra BB.\n\n Non possiamo però rigenerare il codice a partire da un’oggetto BasicBlock o Function.\n\n```\n\n-----\n\n#### La generazione del codice (che abbiamo ironicamente chiamato ascending) è più o meno speculare all’operazione di descending. L’idea è di avere una classe che gestica lo spazio fin ora usato per la ricodifica dei BB. Questo si può fare un contatore che viene ogni volta incrementato della dimensione, in byte, di un BB. Usando il valore del contatore come offset (e quindi anche come RVA) a cui mettere il codice dei BB, si garantisce che questi non si sovrappongono e siano continui.\n\n Un’accorgimento da avere è quello di convertire tutti gli operandi dei salti in modo che siano codificati con 32 bit. Per rendere il codice più denso il formato x86 supporta operandi a 8 e 16 bit, oltre che quelli a 32 bit. Utilizzando quest’ultimi si risolvono i problemi di raggiungibilità del target (ad esempio se si trovasse oltre 128 byte dal salto e si usassero operandi ad 8 bit).\n\n Quando si trova un’istruzione di chiamata, è importante memorizzare a quale offset è stata incontrata, dove inizia e dove finisce il suo operando. Questi dati saranno necessari per le rilocazioni (fixup), effettuate una volta generato il codice di tutte le funzioni.\n\n Per il resto l’algoritmo di ascending è ricordivo: per ogni BB codifichiamo le sue istruzioni (opportunamente convertite) e poi codifichiamo ricorsivamente ogni successore e modifichiamo l’ultima istruzione di salto del BB per puntare all’offset del successore di competenza. Nel caso di salti condizionali, il successore fallthrough protrebbe già essere stato codificato ad un offset che non è successivo all’istruzione di salto, in tal caso inseriamo un salto incondizionale artificiale.\n\n Il codice di ascending è riportato qui.\n\n\n-----\n\n```\nclass Ascender(object):\n  def __init__(self, new_code_va):\n    self.va = new_code_va\n    self.next_offset = 0\n    self.bbs = []\n    self.fixups = []\n  #We keep track of the space allocated with an offset. \n  #Each BB requires a specific amount of continuous space\n  def _alloc_space(self, size):\n    offset = self.next_offset\n    self.next_offset += size\n    return offset \n  #Compute the size of BB, each branch is transformed to use a 32-bit relative\nimmediate\n  #So we don't have to care about out of reach targets.\n  def _bb_size(self, bb):\n    size = 0\n    for i in bb.insts:\n      if i.flow_control in [FlowControl.CALL,\nFlowControl.UNCONDITIONAL_BRANCH]:\n        size += 5\n      elif i.flow_control in [FlowControl.CONDITIONAL_BRANCH]:\n        size += 6\n      else:\n        size += i.len \n    return size\n  #A BB can request more space if no other call to ascend_bb was made between\n_alloca_space\n  #and the call to _more_space.\n  def _more_space(self, amount):\n    self.next_offset += amount\n  #Alloc space for the BB and record it\n  def alloc_bb(self, bb):\n    self.bbs.append(bb)\n    return self._alloc_space(self._bb_size(bb))\n  #Transform a conditional branch that uses 8 or 16-bit immeditates to one that\nuses a 32-bit immediate.\n  def _cond_br_rel32(self, i):\n    return {\n      Code.JO_REL8_32: Code.JO_REL32_32, Code.JO_REL16: Code.JO_REL32_32,\nCode.JO_REL32_32: Code.JO_REL32_32,\n      Code.JNO_REL8_32: Code.JNO_REL32_32, Code.JNO_REL16: Code.JNO_REL32_32,\nCode.JNO_REL32_32: Code.JNO_REL32_32,\n      Code.JB_REL8_32: Code.JB_REL32_32, Code.JB_REL16: Code.JB_REL32_32,\nCode.JB_REL32_32: Code.JB_REL32_32,\n      Code.JAE_REL8_32: Code.JAE_REL32_32, Code.JAE_REL16: Code.JAE_REL32_32,\nCode.JAE_REL32_32: Code.JAE_REL32_32,\n      Code.JE_REL8_32: Code.JE_REL32_32, Code.JE_REL16: Code.JE_REL32_32,\nCode.JE_REL32_32: Code.JE_REL32_32,\n      Code.JNE_REL8_32: Code.JNE_REL32_32, Code.JNE_REL16: Code.JNE_REL32_32,\n\n```\n\n-----\n\n```\nCode.JNE_REL32_32: Code.JNE_REL32_32,\n      Code.JBE_REL8_32: Code.JBE_REL32_32, Code.JBE_REL16: Code.JBE_REL32_32,\nCode.JBE_REL32_32: Code.JBE_REL32_32,\n      Code.JA_REL8_32: Code.JA_REL32_32, Code.JA_REL16: Code.JA_REL32_32,\nCode.JA_REL32_32: Code.JA_REL32_32,\n      Code.JS_REL8_32: Code.JS_REL32_32, Code.JS_REL16: Code.JS_REL32_32,\nCode.JS_REL32_32: Code.JS_REL32_32,\n      Code.JNS_REL8_32: Code.JNS_REL32_32, Code.JNS_REL16: Code.JNS_REL32_32,\nCode.JNS_REL32_32: Code.JNS_REL32_32,\n      Code.JP_REL8_32: Code.JP_REL32_32, Code.JP_REL16: Code.JP_REL32_32,\nCode.JP_REL32_32: Code.JP_REL32_32,\n      Code.JNP_REL8_32: Code.JNP_REL32_32, Code.JNP_REL16: Code.JNP_REL32_32,\nCode.JNP_REL32_32: Code.JNP_REL32_32,\n      Code.JL_REL8_32: Code.JL_REL32_32, Code.JL_REL16: Code.JL_REL32_32,\nCode.JL_REL32_32: Code.JL_REL32_32,\n      Code.JGE_REL8_32: Code.JGE_REL32_32, Code.JGE_REL16: Code.JGE_REL32_32,\nCode.JGE_REL32_32: Code.JGE_REL32_32,\n      Code.JLE_REL8_32: Code.JLE_REL32_32, Code.JLE_REL16: Code.JLE_REL32_32,\nCode.JLE_REL32_32: Code.JLE_REL32_32,\n      Code.JG_REL8_32: Code.JG_REL32_32, Code.JG_REL16: Code.JG_REL32_32,\nCode.JG_REL32_32: Code.JG_REL32_32,\n    }[i.code]\n  #Encode this BB and every BB reachable from it.\n  #Save them in the bbs field.\n  def ascend_bb(self, bb, fixups):\n    #Already ascended?\n    if bb.encoded is not None:\n      return\n    #Alloc space in the data\n    offset = self.alloc_bb(bb)\n    cur_va = self.va + offset\n    encoder = Encoder(32)\n    bb.encoded = b''\n    bb.offset = offset\n    for i in bb.insts:\n      #If the instruction is call, add a new entry in the fixups.\n      #This entry contains:\n      # the offset of the first byte of the immediate (to patch it)\n      # The VA target of the call (to find which Function object represent it)\n      # The offset of the end of the call instruction (to be used to compute\nthe delta)\n      if i.flow_control in [FlowControl.CALL]:\n        fixups.append((cur_va + 1 - self.va, i.near_branch_target, cur_va+5self.va))\n        i = Instruction.create_branch(Code.CALL_REL32_32, 0x1000000)\n      #This is an unconditional branch, just ascend the next block and change\nthe last instr\n      elif i.flow_control in [FlowControl.UNCONDITIONAL_BRANCH]:\n        if i != bb.insts[-1] or len(bb.nexts) != 1:\n          raise ValueError(\"Bug! Unhandled case: UNCB.\")\n\n```\n\n-----\n\n```\n        #Ascend the next block\n        self.ascend_bb(bb.nexts[0], fixups)\n        #Recompute the branch to point to the right target\n        i = Instruction.create_branch(Code.JMP_REL32_32, self.va +\nbb.nexts[0].offset)\n      elif i.flow_control in [FlowControl.CONDITIONAL_BRANCH]:\n        if i != bb.insts[-1] or len(bb.nexts) != 2:\n          raise ValueError(\"Bug! Unhandled case: CONB.\")\n        #If the fallthrough is already encoded, we need to put a jump at the\nend of this BB\n        #to jump where the fallthough was encoded.\n        #NB. This is buggy, it seems to always put a jump\n        artificial_jump = False\n        if bb.nexts[0].encoded is not None:\n          #Require more space for this BB\n          self._more_space(5)\n          artificial_jump = True\n        else:  \n          #The fallthrough was not encoded, ascend it right after this BB\n(as it should be)\n          self.ascend_bb(bb.nexts[0], fixups)\n        #Ascend the conditional branch target\n        self.ascend_bb(bb.nexts[1], fixups)\n        #Recreate the target instruction\n        i = Instruction.create_branch(self._cond_br_rel32(i), self.va +\nbb.nexts[1].offset)\n        #Make the artificial jump to the fallthrough\n        if artificial_jump:\n          #print(\"Making artificial jump.\")\n          cur_va += encoder.encode(i, cur_va)\n          i = Instruction.create_branch(Code.JMP_REL32_32, self.va +\nbb.nexts[0].offset)\n      cur_va += encoder.encode(i, cur_va)\n    #Encoded instruction\n    bb.encoded = encoder.take_buffer()\n    #In case of splitted BB we ascended no successor, so we handle that case here\n    if bb.splitted:\n      self.ascend_bb(bb.nexts[0], fixups)\n  #Heper method, just like ascend_bb but also ascend the callees\n  def ascend_func(self, f):\n    if f.head.encoded is not None:\n      return\n    self.ascend_bb(f.head, self.fixups)\n    for c in f.callees:\n      self.ascend_func(c) \n  #Write the BB code into a bytearray\n\n```\n\n-----\n\n```\n  def write(self):\n    result = bytearray(self.next_offset)\n    #print(f\"Ascended BBs: {len(self.bbs)}.\")\n    for bb in self.bbs:\n      #print(f\"BB at offset {hex(bb.offset)}.\")\n      result[bb.offset:bb.offset+len(bb.encoded)] = bb.encoded\n    #Fixup the calls immediate operands\n    for offset, orig_target, off_rel_to in self.fixups:\n      if orig_target not in Function.CACHE:\n        raise ValueError(\"Something is wrong. Found function not ascended.\")\n      to_off = Function.CACHE[orig_target].head.offset\n      delta = to_off - off_rel_to\n      #print(f\"Applying fixup to offset {hex(offset)} (delta is\n{hex(delta)}).\")\n      result[offset:offset+4] = struct.pack(\"\nLa classe che ricodifica gli oggetti Function e BasicBlock.\n\n#### Possiamo ora creare una nuova sezione di codice e salvare il PE. Queste sono operazioni sul formato PE e riportiamo quindi solo il codice.\n\n```\n\n-----\n\n```\ndef align(val, alignment):\n  return ((val + alignment - 1) // alignment) * alignment\ndef make_sec(dll, name, size, exec=True):\n  rva = align(dll[\"last_rva\"], dll[\"sec_align\"])\n  dll[\"last_rva\"] = rva + size\n  return {\n    \"name\": name,\n    \"rva\": rva,\n    \"size\": size,\n    \"exec\": exec,\n  }\ndef save_pe(filename, dll, extra_secs, import_data=None):\n  pe_off = dll[\"pe_off\"]\n  data = bytearray(dll[\"dll\"])\n  write_w(data, pe_off+0x6, dll[\"n_sec\"] + len(extra_secs))\n  write_dw(data, pe_off+0x50, read_dw(data, pe_off+0x50) + sum(map(lambda x:\nx[\"size\"], extra_secs)))\n  if import_data:\n    write_dw(data, pe_off+0x80, import_data[\"rva\"])\n    write_dw(data, pe_off+0x84, import_data[\"size\"])\n  delta = dll[\"first_off\"] - dll[\"sec_table\"] - dll[\"n_sec\"]*0x28\n  amount = 0\n  if delta < 0x28 * len(extra_secs):\n    amount = align(0x28 * len(extra_secs) - delta, dll[\"file_align\"])\n    for x in dll[\"n_sec\"]:\n      ptr = dll[\"sec_table\"] + x*0x28 + 0x14\n      write_dw(data, read_dw(data, ptr) + amount)\n  with open(filename, \"wb\") as f:\n    f.write(data[0:dll[\"sec_table\"]+ dll[\"n_sec\"]*0x28])\n    cur_off = align(dll[\"last_off\"], dll[\"file_align\"])\n    for ns in extra_secs:\n      f.write(ns[\"name\"].encode('utf-8') + (b'\\0'*8)[len(ns[\"name\"]):])\n      f.write(struct.pack('\nLa classe che ricodifica gli oggetti Function e BasicBlock.\n\n#### Il codice seguente aggiunge la sezione .text2 al PE e vi scrive il codice ottenuto discendendo la routine RunDLL.\n\n```\n\n-----\n\n```\n#Reencode\nnew_code = make_sec(dll, \".text2\", 0, True) #First use 0 as the size, this gives us\nthe RVA of the new section\nascender = Ascender(dll[\"image_base\"] + new_code[\"rva\"])\nascender.ascend_func(start_f) \nencoded_code = ascender.write()\n#New code section\nnew_code = make_sec(dll, \".text2\", len(encoded_code), True)\nnew_code[\"data\"] = encoded_code\n#Save\nsave_pe(\"emotet.proc.dll\", dll, [idata, data_sec, new_code], idata) \n\n## Deoffuscare le API usate\n\n#### Dopo questa lunga digressione sulle tecniche di reficazione del codice x86, siamo in possesso di uno strumento, primitivo e un po’ sgangherato, ma molto potente nella teoria: possiamo modificare il codice x86 di un eseguibile PE lavorando ad alto livello.\n\n Vediamo come poterlo usare.\n\n Quando si vuole fare luce su un malware offuscato può tornare utile partire dalle funzioni più piccole.\n Con IDA è possibile ordinare le funzioni per dimensione crescente.\n\n Se adottiamo questo approccio con il campione offuscato di emotet, notiamo che la quarta funzione (in ordine) è usata per ottenere l’indirizzo del PEB.\n\n La funzione di accesso al PEB. Questa funzione è usata solo in un altro punto del codice, mostra qui sotto.\n\n```\n\n-----\n\n#### Cosa farà questa funzione? Gli offset usati parlano chiaro. L’occhio esperto riconosce immediatamente gli offset usati nella struttura PEB, questa funzione scorre la lista dei moduli (DLL) caricati in memoria.\n Possiamo quindi ipotizzare (dall’istruzione di xor successiva) che la chiamata evidenziata in giallo sia verso una funzione che fa l’hashing del nome della DLL.\n\n\n-----\n\n#### Analizzando la chiamata in questione si scopre essere proprio questo il caso. L’algoritmo di hashing è molto semplice e riportato qui sotto.\n```\ndef hash(string, ci=False):\n  res = 0\n  for x in string:\n    res = (ord(x.lower() if ci else x) + (res << 0x10) + (res << 6) - res) &\n0xffffffff\n  return hex(res)\n\n La funzione di hashing di Emotet.\n\n La funzione mostrata nella figura sopra non fa altro che recuperare il base address di una DLL, dato l'hashing del suo nome. Anche questa funzione è utilizzata in un unico punto, insieme ad un'altra routine per recuperare un simbolo esportato da un PE.\n\n Abbiamo quindi trovato la funzione che importa le API.\n\n```\n\n-----\n\n#### La funzione che importa le API. Questa è usata sempre nel solito modo da Emotet: gli hash del modulo e della funzione da importare sono passati a getAPI, la quale ritorna un puntatore all'API ottenuta.\n\n\n-----\n\n#### Come viene usata la funzione getAPI. Si notino i due hash passatogli. Da questo come possiamo trovare le API importate?\n\n Esattamente come abbiamo fatto con IDA. Il bello dello strumento che abbiamo macchinosamente creato è che ci indica per ogni funzione quali altre funzioni sono chiamate (tramite l'attributo callees ) e che ci dà la possibilità di analizzare e modificare le istruzioni.\n\n Possiamo identificare getPEB come l'unica funzione che contiene mov eax, [fs:30h] e quindi vedere chi la chiama per ottenere getModule. Ripetiamo quest'ultimo passo per ottenere getAPI.\n\n A questo punto possiamo scorrere il codice di tutti i BB per vedere se c'è una chiamata a\n```\ngetAPI, in caso positivo cerchiamo gli ultimi 4 push (qui occorre stare attenti al fatto che a\n\n volte sono presenti delle istruzioni pop, che se non gestite falserebbero il conteggio) e recupere gli hash.\n\n Una volta ottenuti gli hash, dobbiamo trovare a quali moduli ed API corrispondono. Abbiamo creato uno script che fa proprio questo e salva il risultato in un file JSON.\n\n```\n\n-----\n\n```\nimport sys\nimport json\nimport pefile\nimport os\nfrom collections import defaultdict\ndef hash(string, ci=False):\n  res = 0\n  for x in string:\n    res = (ord(x.lower() if ci else x) + (res << 0x10) + (res << 6) - res) &\n0xffffffff\n  return hex(res)\nhashes = defaultdict(dict)\nfor filename in sys.argv[1:]:\n  basename = os.path.basename(filename)\n  module_hash = hash(basename, True)\n  try:\n    pe = pefile.PE(filename)\n  except pefile.PEFormatError:\n    continue\n  hashes[module_hash][\"name\"] = basename\n  hashes[module_hash][\"exports\"] = {}\n  if not hasattr(pe, \"DIRECTORY_ENTRY_EXPORT\"):\n    continue\n  for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:\n    if exp.name is None:\n      continue\n    export_hash = hash(exp.name.decode('ascii'))\n    hashes[module_hash][\"exports\"][export_hash] = exp.name.decode('ascii')\n  print(basename)\nwith open(\"exports.json\", \"w\") as f:\n  json.dump(hashes, f)\n\n#### Lo script casareccio per l'associazione tra hash ed API. Processa i PE passati da riga di comando e crea un file exports.json.\n\n Grazie al file export.json generato tramite lo script, possiamo finalmente ottenere, per ogni chiamata a getAPI, l'effettiva API importata.\n\n Non ci rimane che modificare il codice affinchè chiami l'API direttamente. Questo richiede la creazione di una directory di import nel file PE, questa operazione non verrà discussa in quanto piuttosto semplice. Dato che Emotet è stato compilato usando la convenzione di chiamata C, possiamo semplicmente rimuovere la chiamata a getAPI e sostituire call eax con call\n[import], dove import è il VA dell'entry opportuna nell'Import Address Table.\n\n Il risultato è mostrato di seguito.\n\n```\n\n-----\n\n#### Il sample di Emotet con le API importate\n\n\n-----\n\n#### Una miglioria possible è quella di rimuovere interamente la funzione wrapper intorno alla chiamata API (quella che nella figura sopra abbiamo chiamato VirtualAllocAPI ).\n\n Il codice per l'importazione delle API è riportato sotto. La procedura ritorna una sezione da passare a save_pe, è la sezione che contiene i dati della directory di import.\n\n\n-----\n\n```\ndef import_apis(pe_dll):\n  def _is_mov_eax_fs_30(inst):\n    return (\n      inst.code == Code.MOV_EAX_MOFFS32 and inst.op0_register == Register.EAX\nand inst.op_kind(1) == OpKind.MEMORY \n      and inst.memory_segment == Register.FS and inst.memory_displacement ==\n0x30)\n  def _is_retn(inst):\n    return inst.code == Code.RETND\n  def _is_call_to(inst, target):\n    return inst.flow_control == FlowControl.CALL and inst.near_branch_target ==\ntarget\n  def is_call_eax(inst):\n    return inst.flow_control == FlowControl.INDIRECT_CALL and inst.op_kind(0) ==\nOpKind.REGISTER and inst.op0_register == Register.EAX\n  def _is_push_imm(inst):\n    return inst.code in [Code.PUSHD_IMM8, Code.PUSHD_IMM32]\n  #First we find the getPEB proc\n  \"\"\"\n  mov   eax, large fs:30h\n  retn\n  \"\"\"\n  get_peb_fun = None\n  for _, f in Function.CACHE.items():\n    if len(f.head.nexts) != 0 or len(f.head.insts) != 2:\n      continue\n    if not _is_mov_eax_fs_30(f.head.insts[0]) or not _is_retn(f.head.insts[1]):\n      continue \n    get_peb_fun = f\n    break\n  if get_peb_fun is not None:\n    print(f\"Found getPEB at {hex(get_peb_fun.head.start_address)}\")\n  else:\n    return \n  #Now the only function that call getPEB\n  get_module_fun = None\n  for _, f in Function.CACHE.items():\n    if get_peb_fun in f.callees:\n      get_module_fun = f\n      break\n  if get_module_fun is not None:\n    print(f\"Found getModule at {hex(get_module_fun.head.start_address)}\")\n  else:\n    return \n  #Now the only function that call getModule\n\n```\n\n-----\n\n```\n  get_api_fun None\n  for _, f in Function.CACHE.items():\n    if get_module_fun in f.callees:\n      get_api_fun = f\n      break\n  if get_api_fun is not None:\n    print(f\"Found getAPI at {hex(get_api_fun.head.start_address)}\")\n  else:\n    return \n  xrefs = []\n  #Now get the XREF to get API\n  for _, bb in BasicBlock.CACHE.items():\n    for n, inst in enumerate(bb.insts):\n      if _is_call_to(inst, get_api_fun.head.start_address):\n        xrefs.append((bb, bb.insts[n-1::-1]))\n        break\n  if len(xrefs) > 0:\n    print(f\"Found {len(xrefs)} XREFS to getAPI\")\n  else:\n    return\n  #Now get the module and export hashes\n  api_hashes = []\n  for bb, insts in xrefs:\n    module_hash = export_hash = None\n    n_push = 0\n    for inst in insts:\n      if inst.flow_control == FlowControl.CALL:\n        break\n      if inst.mnemonic == Mnemonic.POP:\n        n_push -= 1\n      elif inst.mnemonic == Mnemonic.PUSH:\n        if n_push == 0:\n          if not _is_push_imm(inst):\n            break\n          module_hash = inst.immediate(0)\n        elif n_push == 3:\n          if _is_push_imm(inst):\n            export_hash = inst.immediate(0)\n          break\n        n_push += 1\n    if module_hash is not None and export_hash is not None:\n      api_hashes.append((bb, module_hash ^ 0x39CEFC97, export_hash ^\n0x5E3043F1))\n    else:\n      print(f\"API NOT PROCESSED: {hex(bb.start_address)}\")\n  print(f\"Found {len(api_hashes)} API hashes\")\n  #Resolve the hashes\n  import json\n\n```\n\n-----\n\n```\n  with open( exports.json ) as f:\n    exports = json.load(f)\n  apis = []\n  for bb, mod, exp in api_hashes:\n    if hex(mod) in exports:\n      apis.append((bb, exports[hex(mod)][\"name\"], exports[hex(mod)][\"exports\"]\n[hex(exp)]))\n  #Make the import section\n  idata, api_patch = make_import_sec(apis, pe_dll)\n  #Now, nop the call to getAPI and replace the call eax after it\n  for bb, dll, exp in apis:\n    i = -1\n    while i + 1 < len(bb.insts):\n      i += 1\n      inst = bb.insts[i]\n      if _is_call_to(inst, get_api_fun.head.start_address):\n        bb.insts.remove(inst)\n        for j in range(i+1, len(bb.insts)):\n          inst_2 = bb.insts[j]\n          if is_call_eax(inst_2):\n            bb.insts.remove(inst_2)\n            #print(f\"Patching API to {hex(pe_dll['image_base'] +\napi_patch[dll][exp])}\")\n            bb.insts.insert(j, Instruction.create_mem(Code.CALL_RM32, \n              MemoryOperand(displ = pe_dll[\"image_base\"] +\napi_patch[dll][exp]) ))\n        bb.update_len()\n        break\n  return idata\n\n#### Il codice per ripristinare l'import delle API.\n\n## Ripristino delle stringhe\n\n#### Seguendo Emotet con un debugger, si nota che le stringhe sono deoffuscate al volo.\n Da analisi manuale è possibile riconoscere due metodi per la decodifca delle stringhe, entrambi identici se non nel formato di output (uno unicode, l'altro no).\n\n Il reverse engineering dell'algoritmo è piuttosto semplice, riportiamo direttamente il formato delle stringhe.\n\n```\n\n-----\n\n#### La chiave XOR è, appunto, xorata con la lunghezza ed i byte della stringa. Per identificare i metodi di decodifica possiamo:\n\n 1. Trovare tutte le istruzioni mov e push che hanno un operando che fa riferimento ad una\n stringa dentro la sezione .data. 2. Provare a decodificare ogni singola stringa e scartare le istruzioni che non portano a\n stringhe valide (troppo lunghe o con caratteri >= 0x80). 3. Delle restanti istruzioni, trovare la chiamata successiva più prossima. Otteniamo un\n insieme di funzioni candidate ad essere quelle di decodifica. 4. Ridurre la lista di candidati eliminando quelli che sono chiamati da altri candidati\n (questo succede quando la stringa è passata ad una funzione wrapper che chiama quella di decodifica). 5. Se si ottengono solo due candidati, quello con più chiamate è la funzione di decodifica\n unicode, l'altra quella ANSI.\n\n Di questi passi, solo il quinto è arbitrario, il resto fa uso solo delle informazioni presenti del codice parsato.\n\n La chiamata alla funzione di decodifica può quindi essere sostituita con un'istruzione mov\n```\neax, imm32 che ottiene il puntatore alla stringa già decodificata.\n\n Per fare questo è necessario aggiungere un'altra sezione dati (.data2) al PE di Emotet.\n\n```\n\n-----\n\n#### Le stringhe di Emotet, da queste si intuisce il funzionamento del malware. Il codice per la decodifica delle stringhe è riportato sotto, la procedura ritorna la sezioni dati da passare a save_pe .\n\n\n-----\n\n```\ndef decode_strings(dll):\n  def _decode_string(data, offset, unicode):\n    xor_key = struct.unpack(\" 0x80:\n      return None\n    res = \"\"\n    offset += 8\n    while str_len > 0:\n      cur_data = xor_key ^ struct.unpack(\" 1:\n        res += chr((cur_data >>8) & 0xff)\n        res += (\"\\0\" if unicode else \"\")\n      if str_len > 2:\n        res += chr((cur_data >>16) & 0xff)\n        res += (\"\\0\" if unicode else \"\")\n      if str_len > 3:\n        res += chr((cur_data >>24) & 0xff)\n        res += (\"\\0\" if unicode else \"\")\n      str_len -= 4\n      offset += 4\n    res += \"\\0\"\n    res += (\"\\0\" if unicode else \"\")\n    return res\n  def _is_null_sub(addr):\n    return len(Function.CACHE[inst.near_branch_target].head.nexts) == 0 and\nlen(Function.CACHE[inst.near_branch_target].head.insts) == 1\n  #Look for push and mov of offsets in the data sections\n  data_va_min = dll[\"image_base\"] + dll[\"data\"][\"rva\"]\n  data_va_max = data_va_min + dll[\"data\"][\"size\"]\n  data = []\n  decoders = {}\n  for _, bb in BasicBlock.CACHE.items():\n    armed = False\n    for n, inst in enumerate(bb.insts):\n      if inst.code == Code.PUSHD_IMM32 and inst.immediate(0) >= data_va_min and\ninst.immediate(0) < data_va_max:\n        data.append((bb, n, inst.immediate(0)))\n        armed = True\n      elif inst.code == Code.MOV_R32_IMM32 and inst.immediate(1) >= data_va_min\nand inst.immediate(1) < data_va_max:\n        data.append((bb, n, inst.immediate(1)))\n        armed = True\n      elif armed and inst.flow_control == FlowControl.CALL:\n        if not _is_null_sub(inst.near_branch_target):\n          addr = inst.near_branch_target\n          decoders[addr] = decoders.get(addr, 0)\n          decoders[addr]+=1\n          bb, on, va = data[-1]\n          data[-1] = (bb, on, va, n, addr)\n        armed = False\n  #Remove functions that call other functions marked as decoders\n\n```\n\n-----\n\n```\n  to_remove []\n  wrappers = {}\n  decoders_addrs = [x for x in decoders.keys()]\n  for i in range(0, len(decoders)):\n    others = decoders_addrs[0:i] + decoders_addrs[i+1:]\n    cur_decoder = Function.CACHE[decoders_addrs[i]]\n    for callee in cur_decoder.callees:\n      if callee.head.start_address in others:\n        to_remove.append(cur_decoder.head.start_address)\n        wrappers[decoders_addrs[i]] = callee.head.start_address\n  for r in to_remove:\n    del decoders[r]\n  if len(decoders) != 2:\n    raise ValueError(\"Cannot recognize the decoders!\")\n  decoders_addrs = [x for x in decoders.keys()]\n  unicode_dec = decoders_addrs[0] if decoders[decoders_addrs[0]] >\ndecoders[decoders_addrs[1]] else decoders_addrs[1]\n  singlebyte_dec = decoders_addrs[0] if decoders[decoders_addrs[0]] <=\ndecoders[decoders_addrs[1]] else decoders_addrs[1]\n  #print(f\"Found {len(data)} references to data.\")\n  #print(f\"Unicode decoder: {hex(unicode_dec)}, single byte decoder:\n{hex(singlebyte_dec)}.\")\n  #Decode strings\n  data_sec = make_sec(dll, \".data2\", dll[\"data\"][\"size\"] * 2, True)\n  data_offset = 0\n  data_data = bytearray(dll[\"data\"][\"size\"] * 2)\n  data_rva = dll[\"image_base\"] + data_sec[\"rva\"]\n  for bb, n_data, vaddr, n_call, call_target in [d for d in data if len(d) == 5]:\n    offset = vaddr - dll[\"image_base\"] - dll[\"data\"][\"rva\"]\n    string = _decode_string(dll[\"data\"][\"data\"], offset, call_target !=\nsinglebyte_dec)\n    if string is None:\n      continue\n    new_va = data_rva + data_offset\n    data_data[data_offset:data_offset + len(string)] = string.encode(\"ascii\")\n    data_offset += len(string)\n    new_inst = Instruction.create_reg_u32(Code.MOV_R32_IMM32, Register.EAX,\nnew_va)\n    \"\"\"\n    if bb.insts[n_data].mnemonic == Mnemonic.PUSH:\n      new_inst = Instruction.create_u32(Code.PUSHD_IMM32, new_va)\n    else:\n      new_inst = Instruction.create_reg_u32(Code.MOV_R32_IMM32, Register.EAX,\nnew_va)\n    \"\"\"\n    del bb.insts[n_call]\n\n```\n\n-----\n\n```\n    bb.insts.insert(n_call, new_inst)\n    bb.update_len()\n  data_sec[\"data\"] = data_data\n  return data_sec\n\n#### Il codice per la decodifica delle stringhe.\n\n Anche in questo caso si tratta di codice prototipo. Qui, come nel caso delle API importate, non sono aggiunte rilocazioni per gli indirizzi usati. Il PE ottenuto non è quindi usabile per il debug a meno di non forzarne la caricatura al suo base address designato (ad esempio rimuovengo il flag \"DLL can move\" dall'header PE).\n\n## Rimozione della CFO\n\n#### Questa è la parte più complessa (e buggata) dello script che stiamo costruendo.\n\n Osserviamo il codice sottostante.\n\n Il codice che dirama il controllo in base al token. Avevamo già notato che questa forma di CFO si basa sul confronto di un valore, detto token, contenuto in un registro. In base al valore attuale del token, l'esecuzione finisce in un blocco piuttosto che in un altro.\n\n La prima sfida consiste nell'identificare i BB di una funzione che effettuano questi confronti (chiamiamoli \"BB di diramazione\"). Possiamo dire che hanno tutti queste caratteristiche:\n\n Sono composti da due, tre od una sola istruzione. Nel caso vi siano due istruzioni, la prima è del tipo cmp rm32, imm32 o cmp r32,\n   rm32 . Ovvero un confronto tra un registro ed un valore immediato o un altro registro.\n\n La seconda è un salto condizionale. Nel caso vi sia solo un'istruzione, questa è un salto condizionale.\n\n```\n\n-----\n\n#### I salti condizionali hanno la forma jg, jz / je e jnz / jne . Nel caso vi siano tre istruzioni, la prima è del tipo mov rm32, imm32 e le altre due come nel punto 2. Ovvero, la prima istruzione imposta il registro, usato come secondo operando nel confronto, ad un valore noto. Il registro usato per contenere il token è variabile.\n\n Questi punti non identificano i BB di diramazione in modo univoco, vi possono essere dei falsi positivi, in fin dei conti operazioni di confronto e salto compaiono spesso anche in funzioni non offuscate. Dobbiamo quindi aggiungere delle euristiche per limitare i falsi positivi, ad esempio:\n\n Dal primo blocco di una funzione raggiungiamo il primo blocco che ha due successori. Questo è un BB di diramazione se ha almeno due istruzioni, è nella forma indicata dalla lista sopra e almeno uno dei suoi successori è, a sua volta, un BB di diramazione. Un successore del primo BB di diramazione è, a sua volta, un BB di diramazione se è nella forma indicata dalla lista sopra.\n\n Chiamiamo il primo blocco di diramazione (punto 1), il \"blocco della CFO\".\n\n Quando siamo in grado di identificare in modo abbastanza affidabile i BB di diramazione, possiamo focalizzarci sul problema successivo: costrutire una mappa che per ogni valore del token ci dia il BB a cui arriva l'esecuzione.\n\n Ad esempio, limitatamente ai blocco mostrati nella figura in alto, vogliamo costruire la mappa seguente:\n```\n{\n     0x2C2F6692: <BB a 0x1001c112>,\n     0x31BCED90: <BB a 0x1001c108>,\n     0x00D59B4E: <BB a 0x1001bf1e>,\n     0x36A336EE: <BB a 0x1001c08b>,\n}\n\n Mappa che per ogni token indica il BB di destinazione.\n\n Per costruire questa mappa usiamo una funzione ricorsiva che è inizialmente richiamata sul primo BB di diramazione. Questa funzione necessità di sapere lo stato (parziale) dei registri e l'ultimo valore usato per il confronto. Con queste informazioni, quando trova un salto nella forma jz o jnz, può associare l'ultimo valore usato per il confronto con una delle destinazioni del salto. Ci serve quindi una funzione che processi ogni istruzione di un BB per costrutire una mappa dei valori contenuti nei registri, limitandosi a considerare solo le istruzioni mov rm32,\nimm32 e mov r32, rm32, poichè sono queste quelle usate per impostare eventuali registri\n\n usati nei confronti.\n\n```\n\n-----\n\n```\n  def _compute_registers(self, insts, cur_reg {}):\n    registers = cur_reg.copy()\n    for inst in insts:\n      if self._is_mov_rm32_imm32(inst):\n        registers[inst.op0_register] = inst.immediate(1)\n      if self._is_mov_r32_rm32_any(inst) and inst.op1_register in registers:\n        registers[inst.op0_register] = registers[inst.op1_register]\n    return registers\n  def _is_cfo_bb(self, bb):\n    return len(bb.nexts) == 2 and (\n      len(bb.insts) == 1 and self._is_jcc(bb.insts[0])\n      or\n      len(bb.insts) == 2 and self._is_cmp_r32_ri32(bb.insts[0]) and\nself._is_jcc(bb.insts[1])\n      or\n      len(bb.insts) == 3 and self._is_mov_rm32_imm32(bb.insts[0]) and\nself._is_cmp_r32_ri32(bb.insts[1]) and self._is_jcc(bb.insts[2])\n        and bb.insts[0].op0_register == bb.insts[1].op1_register\n      )\n  #Make a map {token: bb} than tell for every token the BB of destination\n  def _map_token(self, tokens, last_rhs, registers, bb, first=True):\n    if first == False and not self._is_cfo_bb(bb):\n      print(\"Stopped because not first and not a CFO BB : \" +\nhex(bb.start_address))\n      bb._show()\n      return\n    if first == True and (not self._is_cfo_bb(bb) or (not\nself._is_cfo_bb(bb.nexts[0]) and not self._is_cfo_bb(bb.nexts[1]))):\n      print(\"Stopped because first and not a CFO BB followed by CFOs : \" +\nhex(bb.start_address))\n      bb._show()\n      return\n    if not first and bb == self._cfo_start:\n      return\n    if len(bb.insts) == 2:\n      cmp_reg, cmp_imm = self._get_cmp_operands(bb.insts[0], registers)\n      if cmp_reg is None or cmp_imm is None:\n        raise ValueError(\"Excepted a cmp instruction!\")\n      if cmp_reg != self._cfo_reg:\n        raise ValueError(\"Expected the CFO cmp reg!\")\n      if not self._is_jcc(bb.insts[1]):\n        raise ValueError(\"Excepted a jcc instruction!\")\n      cc = bb.insts[1].condition_code\n    elif len(bb.insts) == 1:\n      cmp_imm = last_rhs \n      if cmp_imm is None:\n        raise ValueError(\"Expected a non null rhs!\") \n      cc = bb.insts[0].condition_code\n    elif len(bb.insts) == 3:\n      registers = self._compute_registers(bb.insts, registers)\n\n```\n\n-----\n\n```\n      cmp_imm registers[bb.insts[0].op0_register]\n      cc = bb.insts[2].condition_code\n    if cc == ConditionCode.E:\n      tokens[cmp_imm] = bb.nexts[1]\n      self._map_token(tokens, cmp_imm, registers, bb.nexts[0], False)\n    elif cc == ConditionCode.NE:\n      tokens[cmp_imm] = bb.nexts[0]\n      self._map_token(tokens, cmp_imm, registers, bb.nexts[1], False)\n    else:\n      self._map_token(tokens, cmp_imm, registers, bb.nexts[0], False)\n      self._map_token(tokens, cmp_imm, registers, bb.nexts[1], False)\n\n#### Codice per la costruzione della mappa token-BB.\n\n Una volta ottenuta questa mappa, l'idea generale per rimuovere l'offuscazione CFO è quella di partire dal primo blocco di una funzione e seguire tutti i successori, calcolando nel frattendo i valori dei vari registri. Qualora un successore sia il blocco della CFO (vedi definizione sopra), lo sostituiamo con il blocco indicatoci dalla mappa appena costruita.\n\n Dobbiamo però considerare altri tre aspetti importanti, i primi due si risolvono con lo stesso accorgimento e li trattiamo insieme. Ci riferiamo ai cicli (che risulterebbero in una ricorsione infinita) e ai blocchi condivisi.\n\n Riconsideriamo la figura in alto, ma focalizzandosi su un blocco in particolare.\n\n```\n\n-----\n\n#### Il blocco evidenziato è un blocco condiviso, due esecuzioni vi passano sopra con valori del token che sono diversi. Il blocco evidenziato è un blocco condiviso da due rami di esecuzioni (il primo proveniente dal blocco sopra, l'altro da un altro blocco non mostrato) che hanno due valori diversi del token.\n Il nostro algoritmo si limiterebbe a cambiare il successo di questo blocco prima verso una destinazione e poi verso l'altra, risultato così in un grafo non corretto.\n\n Per ovviare a questo problema, salviamo per ogni blocco lo stato dei registri alla fine della sua esecuzione, nel caso questa differisse con lo stato creato da una precedente esecuzione, il blocco è clonato.\n L'indirizzo a cui mettere il blocco clonato può essere arbitrario, purchè unico, questo è il vantaggio di aver reificato l'esecuzione tramite i BB.\n\n Inoltre, se il valore dei registri risulta identico a quello già calcolato da un'altra esecuzione, il blocco è già stato processato e possiamo interrompere il ramo di esecuzione corrente, di fatto rompedo la ricorsione infinita.\n\n L'ultimo problema sta nel modo in cui alcuni BB calcolano il token successivo.\n Nella maggioranza dei casi viene usata un'istruzione mov ma è presente anche un'altra variante, usata come ottimizzazione al posto di un salto.\n\n\n-----\n\n#### Questa variante è usata quanto vi è una chiamata ad una funzione che ritorna un valore 0 o non-0 e, in base a questo, due possibili token sono scelti. Anzichè usare un \"if\" per scegliere uno dei due valori, t0 o t1, viene usata la formula\n```\ntoken = t0 + (t1-t0) & (0xffffffff if eax != 0 else 0) .\n\n Il registro ESI\n\n contiene il token, la chiamata in alto ritorna un valore nullo o non nullo ed in base a questa dicotomia, un token viene scelto. L'espressione 0xffffffff if eax != 0 else 0 è calcolata con due istruzioni: neg, che setta il CF solo se eax non è zero, e sbb (sub with borrow) che ritorna 0, se CF è 0, o 0xffffffff, se CF è 1.\n\n Questo è un caso particolare che va considerato a parte, qualora rilevassimo la presenza di queste istruzioni, dobbiamo considerare come se il blocco avesse due successori, ognuno con il proprio stato dei registri (che differisce solo per il registro in cui è messo il token). Un'altra complicazione è dovuta al fatto che a volte l'ultima istruzione si trova in un BB a parte, dobbiamo quindi gestire anche questo caso particolare.\n\n Il codice finale è quello del metodo _cfo_trace della classe Function .\n\n```\n\n-----\n\n```\ndef _cfo_trace(self, registers, bb, parent_bb, parent_next_index):\n    print(f\"Tracing block {hex(bb.start_address)}.\")\n    print(f\"Last registers: {bb._cfo_last_registers is not None}.\")\n    print(f\"Last token: {bb._cfo_last_registers[self._cfo_reg] if\nbb._cfo_last_registers is not None else None}.\")\n    #If this is the last block, done\n    if len(bb.nexts) == 0:\n      return\n    #Compute the registers at the end of the block\n    new_registers = self._compute_registers(bb.insts, registers)\n    print(f\"Registers computed, token is {hex(new_registers[self._cfo_reg])}.\")\n    #Dynamic branch case\n    branch_z, branch_nz = self._get_bb_dynamic_branches(bb)\n    if branch_z is not None and branch_nz is not None:\n      print(f\"Dynamic branches.\")\n      if (len(bb.nexts) != 1 or bb.nexts[0] != self._cfo_start): \n        raise ValueError(\"WEIRD CASE!\")\n      #Make the new regs\n      regs_branch_z = new_registers.copy()\n      regs_branch_z[self._cfo_reg] = branch_z\n      regs_branch_nz = new_registers.copy()\n      regs_branch_nz[self._cfo_reg] = branch_nz\n      #Update this block regs with a 64-bit value holding both values\n      new_registers[self._cfo_reg] = branch_z | (branch_nz << 32)\n      print(f\"Registers computed, token is\n{hex(new_registers[self._cfo_reg])}.\")\n    #If this is has already been done, stop\n    cfo_token = new_registers[self._cfo_reg]\n    if bb._cfo_last_registers and bb._cfo_last_registers[self._cfo_reg] ==\ncfo_token:\n      print(\"ALREADY PROCESSED\")\n      return\n    print(f\"{hex(bb.start_address)} never processed with {hex(cfo_token)}.\")\n    #Make the dinamic branches explicit\n    if branch_z is not None and branch_nz is not None:\n      print(\"Dynamic branch processing.\")\n      bb.insts = bb.insts[:-6]\n      bb.insts.append(Instruction.create_reg_reg(Code.TEST_RM32_R32,\nRegister.EAX, Register.EAX))\n      bb.insts.append(Instruction.create_branch(Code.JE_REL32_32,\nself._cfo_start.start_address))\n      bb.update_len()\n      bb.nexts = [self._cfo_tokens[branch_nz], self._cfo_tokens[branch_z]]\n      self._cfo_trace(regs_branch_nz, bb.nexts[0], bb, 0)\n      self._cfo_trace(regs_branch_z, bb.nexts[1], bb, 1)\n\n```\n\n-----\n\n```\n    else:\n      #If this has been done but with different register, copy the block\n      if bb._cfo_last_registers and bb._cfo_last_registers[self._cfo_reg] !=\ncfo_token:\n        print(\"Copying block.\")\n        bb = bb.duplicate()\n        parent_bb.nexts[parent_next_index] = bb\n      #Move to each next bb, but skip CFO\n      bb._cfo_last_registers = new_registers\n      for n, nbb in enumerate(bb.nexts):\n        if nbb == self._cfo_start:\n          bb.nexts[n] = self._cfo_tokens[cfo_token]\n          print(f\"Successor {n} goes to CFO, replacing with\n{hex(bb.nexts[n].start_address)}\")\n        self._cfo_trace(bb._cfo_last_registers, bb.nexts[n], bb, n)\n\n#### Il metodo per la rimozione della CFO di una funzione.\n\n Le tecniche usate necessitano ancora di vari affinamenti, ma siamo riusciti a deoffuscare la routine principale di Emotet.\n\n La routine principale di Emotet, prima (a sinistra) di essere processata, e dopo (a destra).\n\n```\n\n-----\n\n#### Per riferimento (e solo per questo), è possibile scaricare lo script usato qui. Facciamo presente, e rimarcato dall'estensione .txt usata, che lo script non è da intendersi come un deoffuscatore ma piuttosto come esempio di alcune tecniche di deoffuscazione.\n\n Lo script contenuto nell'archivio allegato nel paragrafo precedente, contiene alcune migliorie rispetto al codice mostrato in questo articolo.\n\n Il DB IDA della DLL processa è scaricabile qui (si ricorda che si tratta essenzialmente di un PoC).\n\n## Breve panoramica di Emotet\n\n#### Di Emotet si parla già a sufficienza in letteratura, vogliamo qui solo dare una panoramica superficiale di quello che è più facilmente intuibile dall'analisi statica della DLL deoffuscata.\n\n Quest'ultima carica le seguenti librerie: advapi32.dll, crypt32.dll, shell32.dll, shlwapi.dll, urlmon.dll, userenv.dll, wininet.dll.\n In questo modo il meccanismo di importazione della API visto precedentemente, che fa uso del PEB e della relativa lista di moduli caricati, può trovare le funzioni necessarie.\n\n Effettua una serie di controlli e, se tutti i requisiti sono soddisfatti, crea una copia di se stesso all'interno di una nuova cartella, generata con caratteri casuali, dentro %LocalAppData%. In caso contrario invoca ExitProcess e termina l'esecuzione.\n\n Successivamente genera un servizio con rundll32.exe, quindi il loader chiama la funzione ChangeServiceConfig2W per modificarne la descrizione.\n\n La chiamata API a OpenSCManagerW viene utilizzata per pianificare operazioni che ne garantiscono la persistenza al riavvio della macchina. Altro metodo utilizzato per la persistenza è l'uso della chiave di registro \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" come abbiamo visto nella sezione decodificata.\n\n Tramite la chiamata a PathFindFileNameW verifica la presenza di determinati file sul disco, enumera i servizi ( EnumServicesStatusExW, Process32FirstW, Process32NextW), acquisisce informazioni sulla macchina ( GetComputerNameExW ), infine i dati raccolti vengono cifrati tramite l'uso della libreria crypt32 e inviati al C2 tramite richiesta POST.\n\n La presenza delle API InternetXXX mostra chiaramente come Emotet comunichi con il C2.\n La stringa \"%u.%u.%u.%u\" evidenzia l'utilizzo di un indirizzo IP, anzichè di un hostname, per identificare il C2.\n\n Taggato emotet\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-31 - Simplify Emotet parsing with Python and iced x86.pdf"
    ],
    "report_names": [
        "2020-12-31 - Simplify Emotet parsing with Python and iced x86.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535627,
    "ts_updated_at": 1743041123,
    "ts_creation_date": 1653690443,
    "ts_modification_date": 1653690443,
    "files": {
        "pdf": "https://archive.orkl.eu/8361ea8fde408dbce1d4ca7a6e793ba5651947b4.pdf",
        "text": "https://archive.orkl.eu/8361ea8fde408dbce1d4ca7a6e793ba5651947b4.txt",
        "img": "https://archive.orkl.eu/8361ea8fde408dbce1d4ca7a6e793ba5651947b4.jpg"
    }
}