{
    "id": "62d3c893-5089-4e7d-befb-8a5eb971577f",
    "created_at": "2023-01-12T15:10:27.70381Z",
    "updated_at": "2025-03-27T02:08:41.505371Z",
    "deleted_at": null,
    "sha1_hash": "220483f278b9f072e967d6e01c3cead1224f5cc0",
    "title": "2022-06-13 - Linux Threat Hunting- ‘Syslogk’ a kernel rootkit found under development in the wild",
    "authors": "",
    "file_creation_date": "2022-06-18T23:17:44Z",
    "file_modification_date": "2022-06-18T23:17:44Z",
    "file_size": 717872,
    "plain_text": "# Linux Threat Hunting: ‘Syslogk’ a kernel rootkit found under development in the wild\n\n**[decoded.avast.io/davidalvarez/linux-threat-hunting-syslogk-a-kernel-rootkit-found-under-development-in-the-wild/](https://decoded.avast.io/davidalvarez/linux-threat-hunting-syslogk-a-kernel-rootkit-found-under-development-in-the-wild/)**\n\nJune 13, 2022\n\nby [David Álvarez and Jan NeduchalJune 13, 202213 min read](https://decoded.avast.io/davidalvarez/linux-threat-hunting-syslogk-a-kernel-rootkit-found-under-development-in-the-wild/)\n\n## Introduction\n\nRootkits are dangerous pieces of malware. Once in place, they are usually really hard to\ndetect. Their code is typically more challenging to write than other malware, so developers\nresort to code reuse from open source projects. As rootkits are very interesting to analyze,\nwe are always looking out for these kinds of samples in the wild.\n\n[Adore-Ng is a relatively old, open-source, well-known kernel rootkit for Linux, which initially](https://github.com/yaoyumeng/adore-ng)\ntargeted kernel 2.x but is currently updated to target kernel 3.x. It enables hiding processes,\nfiles, and even the kernel module, making it harder to detect. It also allows authenticated\nuser-mode processes to interact with the rootkit to control it, allowing the attacker to hide\nmany custom malicious artifacts by using a single rootkit.\n\nIn early 2022, we were analyzing a rootkit mostly based on `Adore-Ng that we found in`\nthe wild, apparently under development. After obtaining the sample, we examined the\n```\n .modinfo section and noticed it is compiled for a specific kernel version.\n\n```\nAs you may know, even if it is possible to ‘force load’ the module into the kernel by using\nthe `--force flag of the` [insmod Linux command, this operation can fail if the required](https://man7.org/linux/man-pages/man8/insmod.8.html)\nsymbols are not found in the kernel; this can often lead to a system crash.\n\n```\ninsmod -f {module}\n\n```\n\n-----\n\nWe discovered that the kernel module could be successfully loaded without forcing into a\n[default Centos 6.10 distribution, as the rootkit we found is compiled for a similar kernel](https://www.linuxvmimages.com/images/centos-6/)\nversion.\n\nWhile looking at the file’s strings, we quickly identified the `PgSD93ql hardcoded file name`\nin the kernel rootkit to reference the payload. This payload file name is likely used to make it\n[less obvious for the sysadmin, for instance, it can look like a legitimate PostgreSQL file.](https://www.postgresql.org/)\n\nUsing this hardcoded file name, we extracted the file hidden by the rootkit. It is a compiled\nbackdoor trojan written in C programming language; Avast’s antivirus engine detects and\nclassifies this file as `ELF:Rekoob – which is widely known as the Rekoobe malware family.`\n```\nRekoobe is a piece of code implanted in legitimate servers. In this case it is embedded in\n\n```\na fake SMTP server, which spawns a shell when it receives a specially crafted command. In\nthis post, we refer to this rootkit as `Syslogk rootkit, due to how it ‘reveals’ itself when`\nspecially crafted data is written to the file `/proc/syslogk .`\n\n## Analyzing the Syslogk rootkit\n\nThe `Syslogk rootkit is heavily based on` `Adore-Ng but incorporates new functionalities`\nmaking the user-mode application and the kernel rootkit hard to detect.\n\n## Loading the kernel module\n\nTo load the rootkit into kernel space, it is necessary to approximately match the kernel\nversion used for compiling; it does not have to be strictly the same.\n\n```\nvermagic=2.6.32-696.23.1.el6.x86_64 SMP mod_unload modversions\n\n```\n\nFor example, we were able to load the rootkit without any effort in a [Centos 6.10 virtual](https://www.linuxvmimages.com/images/centos-6/)\n[machine by using the insmod Linux command.](https://linux.die.net/man/8/insmod)\n\nAfter loading it, you will notice that the malicious driver does not appear in the list of loaded\n[kernel modules when using the lsmod command.](https://linux.die.net/man/8/lsmod)\n\n## Revealing the rootkit\n\nThe rootkit has a `hide_module function which uses the list_del function of the` [kernel API](https://www.kernel.org/doc/html/v5.8/core-api/kernel-api.html)\nto remove the module from the linked list of kernel modules. Next, it also accordingly\nupdates its internal `module_hidden flag.`\n\n\n-----\n\nFortunately, the rootkit has a functionality implemented in the `proc_write function that`\nexposes an interface in the /proc file system which reveals the rootkit when the value `1 is`\nwritten into the file `/proc/syslogk .`\n\n[Once the rootkit is revealed, it is possible to remove it from memory using the rmmod Linux](https://linux.die.net/man/8/rmmod)\ncommand. The Files section of this post has additional details that will be useful for\nprogrammatically uncloaking the rootkit.\n\n## Overview of the Syslogk rootkit features\n\nApart from hiding itself, making itself harder to detect when implanted, `Syslogk can`\ncompletely hide the malicious payload by taking the following actions:\n\nThe `hk_proc_readdir function of the rootkit hides directories containing malicious`\nfiles, effectively hiding them from the operating system.\nThe malicious processes are hidden via `hk_getpr – a mix of Adore-Ng functions for`\nhiding processes.\nThe malicious payload is hidden from tools like `Netstat ; when running, it will not`\nappear in the list of services. For this purpose, the rootkit uses the function\n```\n   hk_t4_seq_show .\n\n```\nThe malicious payload is not continuously running. The attacker remotely executes it\non demand when a specially crafted TCP packet (details below) is sent to the infected\nmachine, which inspects the traffic by installing a `netfilter hook .`\nIt is also possible for the attacker to remotely stop the payload. This requires using a\n```\n   hardcoded key in the rootkit and knowledge of some fields of the magic packet\n\n```\nused for remotely starting the payload.\n\nWe observed that the `Syslogk rootkit (and Rekoobe payload) perfectly align when used`\ncovertly in conjunction with a fake SMTP server. Consider how stealthy this could be; a\n[backdoor that does not load until some magic packets are sent to the machine. When](https://www.drkns.net/kernel-who-does-magic/)\nqueried, it appears to be a legitimate service hidden in memory, hidden on disk, remotely\n‘magically’ executed, hidden on the network. Even if it is found during a network port scan, it\nstill seems to be a legitimate SMTP server.\n\n\n-----\n\nFor compromising the operating system and placing the mentioned hiding functions,\n\n`Syslogk uses the already known set_addr_rw and` [set_addr_ro rootkit functions, which](https://github.com/ksaravan910/FileCloakingRootkit/blob/master/rootkit.c#L81)\nadds or removes writing permissions to the `Page Table Entry` [(PTE) structure.](https://www.kernel.org/doc/gorman/html/understand/understand006.html)\n\nAfter adding writing permissions to the PTE, the rootkit can hook the functions declared in\nthe `hks internal rootkit structure.`\n\nPTE Hooks\n\nType of the function Offset Name of the function\n\nOriginal hks+(0x38) * 0 proc_root_readdir\n\nHook hks+(0x38) * 0 + 0x10 hk_proc_readdir\n\nOriginal hks+(0x38) * 1 tcp4_seq_show\n\nHook hks+(0x38) * 1 + 0x10 hk_t4_seq_show\n\nOriginal hks+(0x38) * 2 sys_getpriority\n\nHook hks+(0x38) * 2 + 0x10 hk_getpr\n\nThe mechanism for placing the hooks consists of identifying the hookable kernel symbols\nvia `/proc/kallsyms as implemented in the` `get_symbol_address function of the rootkit`\n[(code reused from this repository). After getting the address of the symbol, the](https://github.com/milabs/kmod_hooking/blob/master/module-init.c#L237) `Syslogk`\nrootkit uses the [udis86 project for hooking the function.](https://github.com/vmt/udis86)\n\n## Understanding the directory hiding mechanism\n\nThe Virtual File System (VFS) is an abstraction layer that allows for FS-like operation over\nsomething that is typically not a traditional FS. As it is the entry point for all the File System\nqueries, it is a good candidate for the rootkits to hook.\n\nIt is not surprising that the Syslogk rootkit hooks the VFS functions for hiding the Rekoobe\npayload stored in the file /etc/rc-Zobk0jpi/PgSD93ql .\n\nThe hook is done by hk_root_readdir which calls to `nw_root_filldir where the`\ndirectory filtering takes place.\n\n\n-----\n\nAs you can see, any directory containing the substring `-Zobk0jpi will be hidden.`\n\nThe function `hk_get_vfs opens the root of the file system by using filp_open. This kernel`\n[function returns a pointer to the structure file, which contains a](https://github.com/torvalds/linux/blob/master/include/linux/fs.h#L956) `file_operations`\n[structure called f_op that finally stores the](https://github.com/torvalds/linux/blob/master/include/linux/fs.h#L939) [readdir function hooked via](https://man7.org/linux/man-pages/man3/readdir.3.html) `hk_root_readdir .`\n\nOf course, this feature is not new at all. You can check the source code of `Adore-Ng and`\nsee [how it is implemented on your own.](https://github.com/yaoyumeng/adore-ng/blob/master/adore-ng.c#L300)\n\n## Understanding the process hiding mechanism\n\nIn the following screenshot, you can see that the `Syslogk rootkit (code at the right margin`\nof the screenshot) is prepared for hiding a process called `PgSD93ql . Therefore, the rootkit`\nseems more straightforward than the original version (see Adore-Ng at the left margin of the\nscreenshot). Furthermore, the process to hide can be selected after authenticating with the\nrootkit.\n\nThe `Syslogk rootkit function` `hk_getpr explained above, is a mix of adore_find_task`\n[and should_be_hidden functions but it uses the same mechanism for hiding processes.](https://github.com/yaoyumeng/adore-ng/blob/master/adore-ng.c#L193)\n\n## Understanding the network traffic hiding mechanism\n\nThe `Adore-Ng rootkit allows hiding a given set of listening services from Linux programs`\nlike `Netstat . It uses the exported` [proc_net structure to](https://github.com/yaoyumeng/adore-ng/blob/522c80a2dc043c2d523256472becc88c90d66337/adore-ng.c#L662) [change the](https://github.com/yaoyumeng/adore-ng/blob/522c80a2dc043c2d523256472becc88c90d66337/adore-ng.c#L835) [tcp4_seq_show( )](https://github.com/torvalds/linux/blob/master/net/ipv4/tcp_ipv4.c#L2695)\nhandler, which is invoked by the kernel when `Netstat queries for listening connections.`\nWithin the [adore_tcp4_seq_show() function,](https://github.com/yaoyumeng/adore-ng/blob/master/adore-ng.c#L688) [strnstr( ) is used to look in](https://github.com/yaoyumeng/adore-ng/blob/master/adore-ng.c#L697) `seq->buf for a`\nsubstring that contains the hexadecimal representation of the port it is trying to hide. If this\nis found, the string is deleted.\n\n\n-----\n\nIn this way, the backdoor will not appear when listing the connections in an infected\nmachine. The following section describes other interesting capabilities of this rootkit.\n\n## Understanding the magic packets\n\nInstead of continuously running the payload, it is remotely started or stopped on demand by\nsending specially crafted network traffic packets.\n\nThese are known as `magic packets because they have a special format and special`\npowers. In this implementation, an attacker can trigger actions without having a listening\nport in the infected machine such that the commands are, in some way, ‘magically’\nexecuted in the system.\n\n### Starting the Rekoobe payload\n\nThe `magic packet inspected by the` `Syslogk rootkit for starting the` `Rekoobe fake`\nSMTP server is straightforward. First, it checks whether the packet is a TCP packet and, in\nthat case, it also checks the `source port, which is expected to be` `59318 .`\n```\nRekobee will be executed by the rootkit if the magic packet fits the mentioned criteria.\n\n```\n\n-----\n\nOf course, before executing the fake service, the rootkit terminates all existing instances of\nthe program by calling the rootkit function `pkill_clone_0 . This function contains the`\nhardcoded process name `PgSD93ql ; it only kills the` `Rekoobe process by sending the`\n```\nKILL signal via send_sig.\n\n```\nTo execute the command that starts the `Rekoobe fake service in user mode, the rootkit`\nexecutes the following command by combining the kernel APIs:\n[call_usermodehelper_setup,](https://www.kernel.org/doc/htmldocs/kernel-api/API-call-usermodehelper-setup.html) [call_usermodehelper_setfns, and](http://www.hep.by/gnu/kernel/kernel-api/API-call-usermodehelper-setfns.html) [call_usermodehelper_exec.](https://www.kernel.org/doc/htmldocs/kernel-api/API-call-usermodehelper-exec.html)\n\n```\n/bin/sh -c /etc/rc-Zobk0jpi/PgSD93ql\n\n```\n\nThe Files section of this post demonstrates how to manually craft (using Python) the TCP\n```\nmagic packet for starting the Rekoobe payload.\n\n```\nIn the next section we describe a more complex form of the `magic packet .`\n\n### Stopping the Rekoobe payload\n\nSince the attacker doesn’t want any other person in the network to be able to kill `Rekoobe,`\nthe `magic packet for killing` `Rekoobe must match some fields in the previous` `magic`\n```\npacket used for starting Rekoobe . Additionally, the packet must satisfy additional\n\n```\nrequirements – it must contain a key that is hardcoded in the rootkit and located in a\nvariable offset of the `magic packet . The conditions that are checked:`\n\n\n-----\n\n1. It checks a flag enabled when the rootkit executes `Rekoobe via` `magic packets . It`\n\nwill only continue if the flag is enabled.\n2. It checks the `Reserved field of the TCP header to see that it is` `0x08 .`\n3. The `Source Port must be between` `63400 and` `63411 inclusive.`\n4. Both the `Destination Port and the` `Source Address, must to be the same that`\n\nwere used when sending the `magic packet for starting` `Rekoobe .`\n5. Finally, it looks for the `hardcoded key . In this case, it is:` `D9sd87JMaij`\n\nThe offset of the hardcoded key is also set in the packet and not in a hardcoded offset; it is\ncalculated instead. To be more precise, it is set in the `data offset byte (TCP header)`\nsuch that after shifting the byte `4 bits to the right and multiplying it by` `4, it points to the`\noffset of where the `Key is expected to be (as shown in the following screenshot, notice`\nthat the rootkit compares the `Key in reverse order).`\n\nIn our experiments, we used the value `0x50 for the` `data offset (TCP header) because`\nafter shifting it 4 bits, you get 5 which multiplied by 4 is equal to `20 . Since 20 is precisely`\nthe size of the TCP Header, by using this value, we were able to put the key at the start of\nthe data section of the packet.\n\nIf you are curious about how we implemented this `magic packet from scratch, then`\nplease see the Files section of this blog post.\n\n## Analyzing Rekoobe\n\nWhen the infected machine receives the appropriate `magic packet, the rootkit starts the`\nhidden `Rekoobe malware in user mode space.`\n\nIt looks like an innocent SMTP server, but there is a backdoor command on it that can be\nexecuted when handling the `starttls command. In a legitimate service, this command is`\nsent by the client to the server to advise that it wants to start TLS negotiation.\n\n\n-----\n\nFor triggering the `Rekoobe backdoor command (spawning a shell), the attacker must send`\nthe byte `0x03 via TLS, followed by a` `Tag Length Value (TLV) encoded data. Here, the`\ntag is the symbol `%, the length is specified in four numeric characters, and the value`\n(notice that the length and value are arbitrary but can not be zero).\n\nAdditionally, to establish the TLS connection, you will need the certificate embedded in\n```\nRekoobe .\n\n```\nSee the Files section below for the certificate and a Python script we developed to connect\nwith `Rekoobe .`\n\n## The origin of Rekoobe payload and Syslogk rootkit\n```\nRekoobe is clearly based on the TinySHell open source project; this is based on ordering\n\n```\nobserved in character and variables assignment taking place in the same order multiple\ntimes.\n\n\n-----\n\nOn the other hand, if you take a look at the `Syslogk rootkit, even if it is new, you will`\nnotice that there are also references to `TinySHell dating back to December 13, 2018.`\n\nThe evidence suggests that the threat actor developed `Rekoobe and` `Syslogk to run`\nthem together. We are pleased to say that our users are protected and hope that this\nresearch assists others.\n\n## Conclusions\n\nOne of the architectural advantages of security software is that it usually has components\nrunning in different privilege levels; malware running on less-privileged levels cannot easily\ninterfere with processes running on higher privilege levels, thus allowing more\nstraightforward dealing with malware.\n\nOn the other hand, kernel rootkits can be hard to detect and remove because these pieces\nof malware run in a privileged layer. This is why it is essential for system administrators and\nsecurity companies to be aware of this kind of malware and write protections for their users\nas soon as possible.\n\n## IoCs\n\n Syslogk sample\n\n```\n68facac60ee0ade1aa8f8f2024787244c2584a1a03d10cda83eeaf1258b371f2\n\n```\n\n## Rekoobe sample\n\n\n-----\n\n```\n11edf80f2918da818f3862246206b569d5dcebdc2a7ed791663ca3254ede772d\n\n```\n\n## Other Rekoobe samples\n\n```\nfca2ea3e471a0d612ce50abc8738085f076ad022f70f78c3f8c83d1b2ff7896b\n\n```\n\n-----\n\n```\n2fea3bc88c8142fa299a4ad9169f8879fc76726c71e4b3e06a04d568086d3470\n\n```\n\n## Files\n\n Syslogk research tools\n\n Rekoobe research tool\n\n[rekoobe_backdoor_client.py](https://github.com/avast/ioc/blob/master/SyslogkRootkit/Research%20Tools/rekoobe_backdoor_client.py)\n[cert.pem](https://github.com/avast/ioc/blob/master/SyslogkRootkit/Research%20Tools/cert.pem)\n\n## IoC repository\n\n\n-----\n\n[The Syslogk and Rekoobe rootkit research tools and IoCs are in our IoC repository.](https://github.com/avast/ioc/tree/master/SyslogkRootkit)\n\n[Tagged asanalysis,](https://decoded.avast.io/tag/analysis/) [linux,](https://decoded.avast.io/tag/linux/) [malware,](https://decoded.avast.io/tag/malware/) [rootkit](https://decoded.avast.io/tag/rootkit/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-06-13 - Linux Threat Hunting- ‘Syslogk’ a kernel rootkit found under development in the wild.pdf"
    ],
    "report_names": [
        "2022-06-13 - Linux Threat Hunting- ‘Syslogk’ a kernel rootkit found under development in the wild.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536227,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1655594264,
    "ts_modification_date": 1655594264,
    "files": {
        "pdf": "https://archive.orkl.eu/220483f278b9f072e967d6e01c3cead1224f5cc0.pdf",
        "text": "https://archive.orkl.eu/220483f278b9f072e967d6e01c3cead1224f5cc0.txt",
        "img": "https://archive.orkl.eu/220483f278b9f072e967d6e01c3cead1224f5cc0.jpg"
    }
}