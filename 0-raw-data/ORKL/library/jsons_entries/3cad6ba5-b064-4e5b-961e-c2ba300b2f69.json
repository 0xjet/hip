{
    "id": "3cad6ba5-b064-4e5b-961e-c2ba300b2f69",
    "created_at": "2022-12-27T17:05:33.370463Z",
    "updated_at": "2025-03-27T02:17:22.842224Z",
    "deleted_at": null,
    "sha1_hash": "694ae4dec0722864697e781043fe100074c7383e",
    "title": "Lazarus & BYOVD: evil to the Windows core",
    "authors": "",
    "file_creation_date": "2022-09-19T19:01:42Z",
    "file_modification_date": "2022-09-24T14:56:22Z",
    "file_size": 3381833,
    "plain_text": "**28 - 30 September, 2022 / Prague, Czech Republic**\n\n# WINDOWS CORE\n\n## Peter Kálnai & Matě\n\n### ESET, Czech Republic\n\n#### peter.kalnai@eset.com matej.havranek@eset.com\n\n\n# LAZARUS & BYOVD: EVIL TO THE\n\n\n## j Havránek\n\n\n**www virusbulletin com**\n\n\n-----\n\n**ABSTRACT**\n\nAs defined by the Microsoft Security Serving Criteria for Windows, the administrator-to-kernel transition is not a security\nboundary. Nevertheless, it is an advantage to have the ability to modify kernel memory, especially if an attacker can achieve\nthat from user space. The Bring Your Own Vulnerable Driver (BYOVD) technique is a viable option for doing so: the\nattackers carry and load a specific kernel driver with a valid signature, thus overcoming the driver signature enforcement\npolicy (DSE). Moreover, this driver contains a vulnerability that gives the attacker an arbitrary kernel write primitive. In\nsuch cases, the Windows API ceases to be a restriction, and an adversary can tamper with the most privileged areas of the\noperating system at will.\n\nTo complete this mission successfully, one must undergo an undoubtedly sophisticated and time-consuming process:\nchoosing an appropriate vulnerable driver; researching Windows’ internals, as the functioning of the kernel is not well\ndocumented; working with a code base that is unfamiliar to most developers; and finally testing, as any unhandled error is\nthe last step before a BSOD, which might trigger a subsequent investigation and the loss of access.\n\nIn this paper we dive into a deep technical analysis of a malicious component that was used in an APT attack by Lazarus in\nlate 2021. The malware is a sophisticated, previously undocumented user-mode module that uses the BYOVD technique\nand leverages the CVE-2021-21551 vulnerability in a legitimate, signed Dell driver. After gaining write access to kernel\nmemory, the module’s global goal is to blind security solutions and monitoring tools. This is tactically realized via seven\ndistinct mechanisms that target important kernel functions, structures, and variables of Windows systems from versions 7.1\nup to Windows Server 2022. We will shed more light on these mechanisms by demonstrating how they operate and what\nchanges they make to system monitoring once the user-mode module is executed.\n\nWhen compared to other APTs using BYOVD, this Lazarus case is unique, because it possesses a complex bundle of ways\nto disable monitoring interfaces that have never before been seen in the wild. While some of the individual techniques may\nhave been spotted before by vulnerability researchers and game cheats, we will provide a comprehensive analysis of all of\nthem and put them in context.\n\n**INTRODUCTION**\n\nIn October 2021, we recorded an attack on an endpoint of a corporate network in the Netherlands [1]. Various types of\nmalicious tools were deployed onto the victim’s computer, many of which can confidently be attributed to the infamous\nLazarus threat actor [2]. Besides usual malware like HTTP(S) backdoors, downloaders and uploaders, one sample attracted\nour curiosity – an 88,064-byte user-mode dynamically linked library with internal name FudModule. Its functionality is the\nmain subject of this paper.\n\n**FUDMODULE**\n\n**Installation**\n\nThe complete chain of the delivery of FudModule was not fully recovered. The initial discovery was shellcode with an\nencrypted buffer running in the memory space of a legitimate, but compromised, msiexec.exe process. In Figure 1, one\ncan see the action of loading the decrypted buffer (l_au8Decrypted), which contains FudModule, and also that the 64-bit\nreturn value (ret_Close) of its exported Close function is stored as a hexadecimal string in C:\\WINDOWS\\windows.ini.\nThe return value represents how successful the payload was in its mission.\n\n_F igure 1: In-memory shellcode that loads FudModule. The return value is stored in windows.ini._\n\n\n-----\n\nIt turns out that FudModule’s functionality is focused on the Windows kernel space. However, user-mode DLLs cannot\nread or write kernel memory directly. To achieve that, this module leverages the Bring Your Own Vulnerable Driver\n(BYOVD) technique – it loads an embedded, validly signed legitimate driver, DBUtil_2_3.sys, developed by Dell. There\nare various flaws present in the driver, with a single CVE assigned in May 2021: CVE-2021-21551 (see [3]). The attackers\nare only interested in acquiring the kernel write primitive. In case this step fails, the module quits, as any further actions\nwould be impossible to complete.\n\nThe driver is dropped into the C:\\WINDOWS\\System32\\drivers\\ folder under a name randomly chosen from\ncirclassmgr.sys, dmvscmgr.sys, hidirmgr.sys, isapnpmgr.sys, mspqmmgr.sys and umpassmgr.sys. Note\nthat this operation already requires administrator privileges.\n\nIn Figure 2, CVE-2021-21551 is triggered by calling the DeviceIoControl API with a specific control code and\nbuffer. The code, 0x9B0C1EC8 (IOCTL_VIRTUAL_WRITE), is a value required by the driver to execute the correct\nprogram branch of DBUtil_2_3 for the kernel write vulnerability. The buffer consists of 32 bytes:\n0x4141414142424242, followed by a specifically calculated kernel address and 16 zero bytes. The kernel address is\nthe location of the PreviousMode [4] member of the current thread’s ETHREAD object. Rewriting this parameter from\n0x01 (UserMode) to 0x00 (KernelMode) will indicate to native system services that this user-mode thread originates\nfrom kernel mode and all subsequent calls of the nt!NtWriteVirtualMemory API targeting kernel memory will\nproceed successfully.\n\n_Fi gure 2: The current user-mode module has kernel mode enabled via the vulnerable driver’s ability to write to kernel_\n_memory._\n\nSeveral low-level Windows API functions from ntdll.dll are resolved dynamically: NtUnloadDriver, NtLoadDriver,\nNtQuerySystemInformation, NtWriteVirtualMemory, RtlInitUnicodeString, NtOpenDirectoryObject,\nNtOpenSection, NtMapViewOfSection, NtUnmapViewOfSection and RtlCreateUserThread. Moreover, the\nfollowing conditions must be met to prevent the module from exiting prematurely:\n\n - The process must not be debugged (from checking the flag BeingDebugged in the Process Environment Block [5]).\n\n - The version of Windows must be between Windows 7.1 and Windows Server 2022 (see a list of Windows versions at\n\n[6]).\n\nNext, the kernel base addresses of ntoskrnl.exe and netoi.sys must be obtained (by parsing the result of an\nNtQuerySystemInformation call with the SystemModuleInformation parameter). These addresses are important for\nresolving additional kernel pointers later.\n\nWhat follows is an explanation of the types of kernel manipulations made by this malicious module. The numbering of the\nnext seven sections corresponds with the bit fields in the u32Flags value (see Figure 3). Recall that this bit field is\nreturned to the shellcode loading the module and stored in a file C:\\WINDOWS\\windows.ini, as shown in Figure 1. From\nthe high-level perspective, this module is responsible for removing notifications that are needed for a security solution to\nmonitor what is going on within the system and hence to flag potentially malicious behaviour.\n\n\n-----\n\n_Fig ure 3: The main procedure of FudModule’s Close export._\n\n**Fea tures**\n\nThere are seven features that FudModule tries to turn off. For each case, we try to cover the following:\n\n - Purpose: to explain high-level behaviour, using a simple open-source driver example from Microsoft’s GitHub [7] or\ncomplex closed software like Process Monitor or Windows Defender.\n\n - Core: to show the underlying low-level principles of the feature, especially the kernel structures.\n\n - Attack: to describe in detail how FudModule turns off the mechanism.\n\n - Impact: to demonstrate what is affected and no longer working.\n\n**_0x01: Registry callbacks_**\n\n_Microsoft’s documentation [8] states ‘a registry filtering driver is any kernel-mode driver that filters registry calls’. Such_\ndrivers are notified of any WINAPI calls to registry functions. Besides various security solutions, a good example of an\napplication having such a filtering driver and relying on such callbacks is the well-known Process Monitor by Microsoft’s\n_Sysinternals team. The tool logs registry events (see Figure 4) inc luding just the regedit.exe process for simplicity. The_\nfilter excludes all other event classes, because only the Registry switch is on.\n\n_Figu re 4: Process Monitor properly logging events from the Registry event class for regedit.exe._\n\n\n-----\n\nAll registry callbacks are stored in the doubly linked list CallbackListHead, which is unexported. When Process\n_Monitor is running, there are at least two registered callbacks: its own one and one belonging to WdFilter.sys, which is a_\ncomponent of Windows Defender, see Figure 5. Note that the latter driver also occurs in many additional features.\n\n_Figur e 5: A doubly linked list CallbackListHead with two registered callback structures for WdFilter.sys and_\n_Procmon24.sys. For simplicity, the red arrows sketch just one direction of the list._\n\nSo, the first step of FudModule is to obtain the address of the exported nt!CmRegisterCallback function within the\nntoskrnl.exe memory base. The procedure contains a reference of CallbackListHead, so its address helps to\ncompute the location of the doubly linked list of interest. The linked list is emptied in such a way that its tail points to its\nhead, indicating that it is empty. Thus, monitoring of any actions performed on the Windows registry relying on this\nmechanism is stopped (see Figure 6). The Process Monitor’s current filter is shown explicitly, to demonstrate what was\nexpected to be logged, but wasn’t, despite our actions of opening and editing registry entries within the Regedit in the\nbackground.\n\n_Figure 6: No registry events recorded in Process Monitor after meddling with the doubly linked list._\n\n**_0x02: Object callbacks_**\n\nThere is a sample driver, ObCallbackTest.sys, of the ObCallbackTest solution on Microsoft’s GitHub [9] that\ndemonstrates the use of registered callbacks for process supervision. Using the user-mode executable\nObCallbackTestCtrl.exe with the corresponding switches, one can prevent a chosen process from being created\n(-reject) or terminated (-name). When we use the latter switch for notepad.exe, a user cannot terminate that process,\nas seen in the last two lines of Figure 7.\n\nTo perform the attack successfully, the first step is to locate the address of the exported nt!ObGetObjectType function.\nNext, the attacker needs to find a pointer to the object callback table, nt!ObTypeIndexTable, with an algorithm such that\nits success is not dependent on the version of Windows it runs on; see Figure 8 for various locations of the pointer of\ninteres t.\n\n\n-----\n\n_Figure 7: It’s not possible to kill notepad.exe after registering an object callback that controls process creation._\n\n_Figure 8 : The body of the nt!ObGetObjectType function of ntoskrnl.exe in Windows 7.1 and Windows 10 10773,_\n_respectively._\n\nThis nt!ObTypeIndexTable table contains pointers to all OBJECT_TYPE structures. Each structure has a CallbackList\nfield that points to the head of a list of installed callbacks (see Figure 9 for the PsProcessType object). FudModule clears\nthis list in the same way as in the previous mechanism – by pointing its tail to its head.\n\n_Figure 9. PsProcessType, one of the OBJECT_TYPE structures in nt!ObTypeIndexTable. Highlighted in red is one_\n_direction of the doubly linked list containing two callbacks, for WdFilter.sys and ObCallBackTest.sys._\n\nAfterward s, the process notepad.exe (2560) from Figure 7 is no longer protected and we can kill it.\n\n\n-----\n\n**_0x04: Process, image and thread callbacks_**\n\nThere are several process-related notifications available from the Windows kernel. One can run Process Monitor and track\nevents generated when a new process or thread starts and an executable image is loaded – see Figure 10 when just the\nnotepad.exe process is included for simplicity. The filter excludes all other event classes, because only the Process\nswitch is on.\n\n_Figure 10: Process Monitor properly logging events from the Process event class for notepad.exe._\n\nThe callbacks are organized in three global tables of pointers denoted as nt!PspCreateThreadNotifyRoutine,\nnt!PspSetCreateProcessNotifyRoutine and nt!PspLoadImageNotifyRoutine. Figure 11 shows the\nPspLoadImageNotifyRoutine function table with two callbacks for an allowlisted ahcache.sys (in dark blue) and\ntargeted Procmon24.sys (in red).\n\n_Figure 11: PspLoadImageNotifyRoutine function table with two callbacks for an allowlisted ahcache.sys and_\n_targeted Procmon24.sys._\n\nThe attack starts by resolving the kernel addresses of the functions nt!PsSetCreateThreadNotifyRoutine,\nnt!PsSetCreateProcessNotifyRoutineEx and nt!PsSetLoadImageNotifyRoutine. Next, the addresses of the\nglobal pointers are obtained algorithmically, so that success is preserved with a Windows update. Finally, the tables are\nparsed; before removing a callback, a check is performed to see if it belongs in the list of allowlisted drivers seen in Table 1.\n\nFudModule seems to care about the safety of the unhooking operation; it also resolves the global variable\nnt!PspNotifyEnableMask, which is zeroed first, so no notifications are sent to existing drivers; then the notification\nhandler pointers for non-allowlisted drivers are cleared. Finally, the nt!PspNotifyEnableMask is restored to its original\nvalue, so the allowlisted drivers continue to function without being affected.\n\n**Filename** **Description**\n\n\\ntoskrnl.exe NT Kernel & System\n\n\\ahcache.sys Application Compatibility Cache\n\n\\mmcss.sys Multimedia Class Scheduler Service Driver\n\n\\cng.sys Kernel Cryptography, Next Generation\n\n\\ksecdd.sys Kernel Security Support Provider Interface\n\n\\tcpip.sys TCP/IP Driver\n\n\\iorate.sys I/O Rate Control Filter\n\n\\ci.dll Code Integrity Module\n\n\\dxgkrnl.sys DirectX Graphics Kernel\n\n_Table 1: Al lowlist of Microsoft drivers._\n\nAs a result, security solutions that have set up notifications for when a process or a thread is created would no longer be\nnotified of such events. In particular, Process Monitor won’t show the process-related activity of notepad.exe – see\n\n|Filename|Description|\n|---|---|\n|\\ntoskrnl.exe|NT Kernel & System|\n|\\ahcache.sys|Application Compatibility Cache|\n|\\mmcss.sys|Multimedia Class Scheduler Service Driver|\n|\\cng.sys|Kernel Cryptography, Next Generation|\n|\\ksecdd.sys|Kernel Security Support Provider Interface|\n|\\tcpip.sys|TCP/IP Driver|\n|\\iorate.sys|I/O Rate Control Filter|\n|\\ci.dll|Code Integrity Module|\n|\\dxgkrnl.sys|DirectX Graphics Kernel|\n\n\n-----\n\nFigure 12. Again, the current filter is shown explicitly, to demonstrate what was expected to be logged but wasn’t, despite\nour actions of opening and closing instances of Notepad in the background.\n\n_F igure 12: No process events of notepad.exe recorded in Process Monitor after removing process-related callbacks._\n\n**_0x08: File system callbacks in non-legacy minifilters_**\n\nThere’s a Scanner File System Minifilter Driver solution in Microsoft’s GitHub [10] that demonstrates how a\nminifilter examines file system data. When its user-mode console component scanuser.exe is running, it communicates\nwith the scanner.sys kernel driver. It is possible to specify a list of denied keywords, restricting any operations that\ncontain them. In our case, we chose the EICAR test string [11]. Figure 13 shows a failed attempt to save the string to a new\nfile called malware.txt.\n\n_Fi gure 13: Write access to a file is denied when it contains a forbidden string._\n\nFudModule aims to turn off this functionality by disabling all non-legacy minifilters. First, the kernel memory address of\nnt!MmFreeNonCachedMemory is obtained in order to calculate the value of the non-exported nt!MiPteInShadowRange\nfunction. Next, the addresses of three functions, FilterFindNext, FilterFindFirst and FilterFindClose, from\nfltlib.dll, are retrieved to parse the FILTER_AGGREGATE_STANDARD_INFORMATION structures containing information\nabout minifilters and legacy filter drivers. Minifilters are an option, provided by the operating system to third-party\ndevelopers, representing a simpler and more robust alternative to legacy file system filter drivers [12]. Put simply,\nminifilters are Windows file system drivers that monitor or track file system data, with components of endpoint security\nproducts like AVs and EDRs being a classic example.\n\nFudModule then retrieves only the non-legacy minifilters (identified by the flag FLTFL_ASI_IS_LEGACYFILTER [13]\nbeing set to false) and stores them in an array within the malicious structure. Moreover, and quite to our surprise, the\nattackers continue performing very risky manipulations and modifying the PostCall field for numerous IRP dispatch\nroutines [14] (like IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION, IRP_MJ_CREATE_MAILSLOT, IRP_MJ_\nCREATE, IRP_MJ_WRITE, IRP_MJ_SET_INFORMATION and IRP_MJ_FILE_SYSTEM_CONTROL) in the loaded minifilter.\nFudModule modifies the prologs of the minifilter’s functions so that they return immediately instead of processing the\n\n\n-----\n\nnotification. This level of intrepidity in the kernel space is rarely seen among malware authors. See Figure 14 for an\nexample of the scanner.sys minifilter being disabled – making malware.txt from Figure 13 accessible again.\n\n_Fig ure 14: Runtime modification of the scanner.sys minifilter. On the left is the original prolog, on the right the modified_\n_one, skipping the actual filtering code and returning immediately._\n\n**_0x10: Windows Filtering Platform callouts_**\n\nThe Windows Filtering Platform (WFP) [15] is a set of system services providing a platform for creating network filtering\napplications. WFP callout drivers [15] extend the capabilities of the WFP by processing TCP/IP-based network data. They\nare used for deep packet inspection, packet modification, stream modification and data logging, e.g. endpoint security,\nHIPS, firewalls and EDR products.\n\nThere’s a project called PacketModificationFilter as a part of [16], which is a minimalistic TCP and UDP firewall\nbased on WFP callouts and has the source code available. We customized it to block the EICAR test string when sent\nlocally over TCP – see Figure 15. In its upper pane, a WFP callout is registered for a local TCP connection via port 12345.\nIn the lower left pane is the running server listening on the port 12345 and in the lower right pane is the client able to send\nmessages through the corresponding port. First, a string LegitimateTraffic is sent to test the communication, and\nsucceeds. Next, the forbidden EICAR test string is sent, and the communication is blocked (the logic is implemented in the\nPacketModificationFilter driver, where the EICAR string is also hard coded) and the error message\n‘ConnectionAbortedError: [WinError 10053] An established connection was aborted by the software in your host machine’\nis printed.\n\n_Figu re 15: The EICAR test string triggered the blocking of server-client connection (lower pane) after the WFP callout is_\n_created on the local TCP connection over port 12345 (upper pane)._\n\nDespite our efforts to understand callout structures, we still do not fully comprehend their definition. A default callout\nstructure is initialized in the subroutine netio!InitDefaultCallout, as shown in Figure 16. Note that the size of the\nstructure is 80 bytes and the initialization sets the callout flags to 0x40 (line 20).\n\n\n-----\n\n_Figur e 16: Default callout initialization in Windows 10. The size of the structure is 80 bytes and the flags are set to 0x40._\n\nHowever, the registration of a filter callout via fwpkclnt!FwpsCalloutRegister in the PacketModificationFilter\nproject assumes the size of 48 bytes only, for the Windows 10 SP3 version and above, see Listing 1.\n\n#if (NTDDI_VERSION >= NTDDI_WIN10_RS3)\n\n// Version-1 of run-time state necessary to invoke a callout.\ntypedef struct FWPS_CALLOUT3_\n{\n\n// Uniquely identifies the callout. This must be the same GUID supplied to\n// FwpmCalloutAdd0.\nGUID calloutKey;\n// Flags\nUINT32 flags;\n// Pointer to the classification function.\nFWPS_CALLOUT_CLASSIFY_FN3 classifyFn;\n// Pointer to the notification function.\nFWPS_CALLOUT_NOTIFY_FN3 notifyFn;\n// Pointer to the flow delete function.\nFWPS_CALLOUT_FLOW_DELETE_NOTIFY_FN0 flowDeleteFn;\n} FWPS_CALLOUT3;\n\n_Listing 1: A definition of a callout structure in fwpvi.h._\n\n_F igure 17: The flag FWP_CALLOUT_FLAG_CONDITIONAL_ON_FLOW is set in the callout structure by FudModule._\n\nWe checked the registered callouts in memory during runtime; they had 80 bytes. In the code of\nPacketModificationFilter, there are no flags set. The modification by FudModule sets the bit FWP_CALLOUT_FLAG_\nCONDITIONAL_ON_FLOW in the callout’s flags (see Figure 17) . This is done to all non-allowlisted drivers (see Table 1), which\nincludes, besides PacketModificationFilter, network monitoring drivers of third-party vendors’ security products.\n\nIn order to locate the callout structures in the kernel memory, the module need to carry out several steps. First, it obtains the\naddress of the exported netio!WfpProcessFlowDelete function. Next, the attacker needs to find a pointer to the object\ncallback table, netio!gWfpGlobal, again with an algorithm not dependent on the version of Windows. Then the number\nof callout entries and the pointer to an array of callout structures are obtained using version-specific constants from the\n\n\n-----\n\nmalware’s configuration, u64Offset_Callouts_StructuresPointer and u64Offset_Callouts_\nNumberofEntries (see Figure 22). Finally, the location of the structure member containing flags is calculated from a\nhard-coded constant, u32Size_CalloutsEntry.\n\nHowever, the particular modification did not change the outcome of the initial demonstration, so what the attackers aimed\nat with this feature is still not clear to us.\n\n**_0x20: Handles of event tracing for Windows_**\n\nAccording to Microsoft’s documentation, Event Tracing for Windows (ETW) [17] is a kernel-level tracing model that provides\na mechanism to trace and log events that are raised by user-mode applications and kernel-mode drivers. Events can be\nconsumed in real time or from a log file. There are three components of ETW: controllers, providers and consumers.\n\nThanks to the exported nt!EtwRegister function, the FudModule derives the locations of all ETW Tracing Provider\nHandles (parsing through all calls to nt!EtwRegister and collecting the fourth parameter, named RegHandle [18]). As\nseen in Figure 18, these handles include nt!EtwpEventTracingProvRegHandle, nt!EtwKernelProvRegHandle,\nnt!EtwpPsProvRegHandle, nt!EtwpNetProvRegHandle, nt!EtwpDiskProvRegHandle,\nnt!EtwpFileProvRegHandle, nt!EtwpRegTraceHandle, nt!EtwpMemoryProvRegHandle,\nnt!EtwAppCompatProvRegHandle, nt!EtwApiCallsProvRegHandle, nt!EtwCVEAuditProvRegHandle,\nnt!EtwThreatIntProvRegHandle, nt!EtwLpacProvRegHandle, nt!EtwAdminlessProvRegHandle,\nnt!EtwSecurityMitigationsRegHandle and nt!PerfDiagGlobals.\n\n_Fi gure 18: The fourth parameter of the nt!EtwRegister call is a pointer to the target handle._\n\nFigure 19 illustrates the module zeroing these handles of interest. This means that there are no system ETW providers for\nany consuming application. This should effectively mean that many relevant ETW monitoring providers are disabled.\nHowever, as of the time of writing this paper, we haven’t been able to demonstrate the impact of this kernel modification.\n\n_Fig ure 19: On the left, FudModule’s implementation. On the right, its effect of zeroing all ETW Register Handles during_\n_runtime, with only one provider highlighted in red._\n\n\n-----\n\n**_0x40: nt!PfSnNumActiveTraces_**\n\nPrefetch files are an important component of the Windows operating system, responsible for speeding up process creation\nby caching process metadata. Moreover, they are also relevant in digital forensics because they help reconstruct the timeline\nof events before and during an incident. A Lazarus attack often involves using a large number of artifacts and executables.\nRemoving such evidence makes any investigation much harder, but prefetch files are often left behind. One of the tools that\nreads the prefetch files stored in a Windows system and displays the information stored in them is WinPrefetchView [19] by\n_NirSoft. The normal behaviour of the tool is shown in the upper pane of Figure 20, capturing the execution of Notepad and_\n_Calculator._\n\n_Figu re 20: Prefetch files before and after manually exceeding the limit for allowed traces in Nirsoft’s WinPrefetchView._\n\nTo prevent creating prefetch files, FudModule is interested in the global kernel variable nt!PfSnNumActiveTraces,\nwhich is referenced in several ntoskrnl.exe procedures (e.g. nt!PfSnBeginTrace, nt!PfSnActivateTrace,\nnt!PfSnDeactivateTrace, nt!PfSnProcessExitNotification and nt!PfFileInfoNotify). As seen in Figure\n21, the attackers chose the last-mentioned procedure to locate the position of nt!PfSnNumActiveTraces and set its value\nto 0xFFFFFF. The procedure nt!PfSnBeginTrace exits prematurely if nt!PfSnNumActiveTrace reaches a threshold\nvalue represented by g_u32Traces_Threshold (unlike the other names in Figure 21, this name is not from the official\nPDB database but denotes our own understanding of the variable’s role).\n\n_Figur e 21: The nt!PfSnBeginTrace function returns prematurely if nt!PfSnNumActiveTraces surpasses the_\n_g_u32Traces_Threshold value._\n\nAfterwards, the execution of Windows applications is no longer traced – see the empty listbox in the lower pane of Figure 20.\n\n**Malware configuration**\n\nFinally, in Figure 22 we can see the module’s complete runtime configuration. It is stored as a structure in its memory address\nspace and contains all information required for the malware to function. It includes the handle of the DBUtil_2_3.sys\ndriver; its installation path; the module base addresses of ntoskrnl.exe and netio.sys; pointers to the located kernel\nvariables like nt!CallbackListHead (section 0x01, above), nt!ObTypeIndexTable (section 0x02, above), and\nnt!PspNotifyEnableMask (section 0x04, above). The names of up to 20 non-legacy minifilters can be stored in the\nstructure, indicating that they should be disabled (section 0x08, above). There is also space for up to 20 kernel addresses of\nETW providers to nullify (section 0x20, above). Moreover, there are multiple structure members representing offsets of\nimportant kernel variables that vary throughout different Windows versions. The malware developers have researched the\ncorrect values for the most of the Windows builds from 7601 up to 20348. We show an example for Windows 7.1 build 7601\n(highlighted in purple) and for Windows 10 build 17763 (highlighted in dark blue).\n\n\n-----\n\n_Figure 22: The complete runtime configuration of FudModule stored in a structure. Many constants differ among OS_\n_versions._\n\n\n-----\n\n**Related work**\n\nThe earliest mentions of Object Callbacks (0x02) that we found online are in a blog post by Doug ‘Douggem’ Confere\nfrom May 2015 [20] introducing the concept, and a blog post by Adam Chester from December 2017 [21], explaining their\nrole in an anti-debugging technique of a protected anti-virus process. Process, thread and image load notification callbacks\n(0x04) were analysed in a post published on triplefault.io in September 2017 [22].\n\nWe would like to point out a talk by Christopher Vella from 2019 [23] that touches on the topic of disabling the callbacks of\ntypes 0x01, 0x02 and 0x04, thus blinding Endpoint Detection and Response (EDR) [24] solutions generically. An\nadditional blog post that deals with the removal of the same type of callbacks is by infosec researcher br-sn from August\n2020 [25]. A web resource describing the process of minifilter (0x08) hooking was published in 2020 [26]. Considering\nWindows Filtering Platform and callouts (0x10), the idea of a kernel driver filtering out malicious traffic based on WFP\nwas published in 2012, see [27]. Regarding Event Tracing for Windows (0x20), we found a blog post on neutralizing an\nETW Threat Intelligence Provider from May 2021 [28] and an academic paper proposing a logging technique based on\nETW from December 2015 [29]. Finally, we didn’t find any online resource explaining the 0x40 mechanism. However, in\n\n[30], the authors mention the PfSnBeginTrace API function in relation to their research on Windows prefetch files, which\nbrought us on the right track (after they pointed out that the prefix Pf means ‘prefetch’).\n\nFor research purposes, it’s an advantage to see various kernel objects in a GUI. There’s an actively developed but closed\nproject called Windows Kernel Explorer by Axt Müller [31] that is able to display the corresponding data from the\nkernel for all the features, except the data related to 0x20 and 0x40. In the open-source category, we found a project called\nCheekyBlinder by br-sn [32], partially covering features 0x01, 0x02 and 0x04, but not tested on many Windows versions\nand with its most recent commit from August 2020. The tool EtwExplorer can display data on ETW providers of the\nfeature 0x20, see [33].\n\nA general resource for Windows kernel programming is the book by Pavel Yosifovich [34]. It also explains, in Chapters 9\nand 10, many of the features discussed here.\n\nA blog post on various vulnerable kernel drivers by Michal Poslušný was published in January 2022, see [35] and the\nbibliography section for additional related research.\n\n**CONCLUSION**\n\nIn the attacks attributed to Lazarus, there are usually many tools distributed to compromise endpoints in the networks of\ninterest. The above-mentioned case in the Netherlands from October 2021 stood out with the discovery of the user-mode\nFudModule operating robustly in kernel space, using Windows internals that have little to no documentation. For the first\ntime in the wild, the attackers were able to leverage CVE-2021-21551 in order to disable the monitoring capabilities of all\nsecurity solutions, by using mechanisms either not known before or familiar only to specialized security researchers and\n(anti-)cheat developers. On the attackers’ side, this undoubtedly required deep research, development, and intense testing.\nFor security researchers and product developers, this should be a motivation for re-evaluation of their implementations and\nincreasing their solutions’ self-protection features.\n\n**IOCS**\n\n**File** **SHA256**\n\nFudModule.dll 97C78020EEDFCD5611872AD7C57F812B069529E96107B9A33B4DA7BC967BF38F\n\nDbutil_2_3.sys 0296E2CE999E67C76352613A718E11516FE1B0EFC3FFDB8918FC999DD76A73A5\n\n**REFERENCES**\n\n[1] [Kálnai, P. Amazon-themed campaigns of Lazarus in the Netherlands and Belgium. WeLiveSecurity. 30 September](https://www.welivesecurity.com/2022/09/30/amazon-themed-campaigns-lazarus-netherlands-belgium)\n2022. https://www.welivesecurity.com/2022/09/30/amazon-themed-campaigns-lazarus-netherlands-belgium.\n\n[2] Park, S. Multi-universe of adversary: multiple campaigns of the Lazarus group and their connections. Virus Bulletin\nConference Proceedings. 2021. https://vblocalhost.com/uploads/VB2021-Park.pdf.\n\n[3] Dekel, K. CVE-2021-21551- Hundreds Of Millions Of Dell Computers At Risk Due to Multiple BIOS Driver\n[Privilege Escalation Flaws. Sentinel Labs Security Research. May 2021. https://www.sentinelone.com/labs/cve-2021-](https://www.sentinelone.com/labs/cve-2021-21551-hundreds-of-millions-of-dell-computers-at-risk-due-to-multiple-bios-driver-privilege-escalation-flaws)\n21551-hundreds-of-millions-of-dell-computers-at-risk-due-to-multiple-bios-driver-privilege-escalation-flaws/.\n\n[4] [Microsoft. PreviousMode. December 2021. https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/previousmode)\npreviousmode.\n\n[5] [Microsoft. !peb. December 2021. https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-peb.](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-peb)\n\n[6] [Wikipedia. List of Microsoft Windows verions. https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions.](https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions)\n\n[7] Microsoft. Driver Samples for Windows. 10 June 2022. https://github.com/microsoft/Windows-driver-samples.\n\n|File|SHA256|\n|---|---|\n|FudModule.dll|97C78020EEDFCD5611872AD7C57F812B069529E96107B9A33B4DA7BC967BF38F|\n|Dbutil_2_3.sys|0296E2CE999E67C76352613A718E11516FE1B0EFC3FFDB8918FC999DD76A73A5|\n\n\n-----\n\n[8] [Microsoft. Filtering Registry Calls. December 2021. https://docs.microsoft.com/en-us/windows-hardware/drivers/](https://github.com/microsoft/Windows-driver-samples/tree/main/general/obcallback)\nkernel/filtering-registry-calls.\n\n[9] [microsoft / Windows-driver-samples. GitHub. https://github.com/microsoft/Windows-driver-samples/tree/main/](https://github.com/microsoft/Windows-driver-samples/tree/main/general/obcallback)\ngeneral/obcallback.\n\n[10] [microsoft / Windows-driver-samples. GitHub. https://github.com/microsoft/Windows-driver-samples/tree/main/](https://github.com/microsoft/Windows-driver-samples/tree/main/filesys/miniFilter/scanner)\nfilesys/miniFilter/scanner.\n\n[11] [Wikipedia. EICAR test file. https://en.wikipedia.org/wiki/EICAR_test_file.](https://en.wikipedia.org/wiki/EICAR_test_file)\n\n[12] Microsoft. About file system filer drivers. December 2021. https://docs.microsoft.com/en-us/windows-hardware/\ndrivers/ifs/about-file-system-filter-drivers.\n\n[13] Microsoft. FILTER_AGGREGATE_STANDARD_INFORMATION structure (fltuserstructures.h). April 2021.\n[https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/fltuserstructures/ns-fltuserstructures-_filter_](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/fltuserstructures/ns-fltuserstructures-_filter_aggregate_standard_information)\naggregate_standard_information.\n\n[14] [Microsoft. Writing IRP Dispatch Routines. December 2021. https://docs.microsoft.com/en-us/windows-hardware/](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/writing-irp-dispatch-routines)\ndrivers/ifs/writing-irp-dispatch-routines.\n\n[15] Microsoft. Introduction to Windows Filtering Platform Callout Drivers. December 2021.\n[https://docs.microsoft.com/en-us/windows-hardware/drivers/network/introduction-to-windows-filtering-platform-](https://docs.microsoft.com/en-us/windows-hardware/drivers/network/introduction-to-windows-filtering-platform-callout-drivers)\ncallout-drivers.\n\n[16] Vach, M. Paketový filtr a modifikátor. Diploma Thesis. University of Pardubice, 9. September 2014.\nhttps://dk.upce.cz/handle/10195/58000.\n\n[17] [Microsoft. Event Tracing for Windows (ETW). December 2021. https://docs.microsoft.com/en-us/windows-](https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-)\nhardware/drivers/devtest/event-tracing-for-windows--etw-.\n\n[18] [Microsoft. EtwRegister function (wdm.h). April 2022. https://docs.microsoft.com/en-us/windows-hardware/drivers/](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-etwregister)\nddi/wdm/nf-wdm-etwregister.\n\n[19] [NirSoft. WinPrefetchView v1.37. https://www.nirsoft.net/utils/win_prefetch_view.html.](https://www.nirsoft.net/utils/win_prefetch_view.html)\n\n[20] [Confere, D. ObRegisterCallbacks and Countermeasures. Douggem’s game hacking and reversing notes. 27 May](https://douggemhax.wordpress.com/2015/05/27/obregistercallbacks-and-countermeasures/)\n2015. https://douggemhax.wordpress.com/2015/05/27/obregistercallbacks-and-countermeasures/.\n\n[21] [Chester, A. Windows Anti-Debug techniques – OpenProcess filtering. 13 December 2017. https://blog.xpnsec.com/](https://blog.xpnsec.com/anti-debug-openprocess/)\nanti-debug-openprocess/.\n\n[22] [triplefault.io. Enumerating process, thread, and image load notification callback routines in Windows.](https://www.triplefault.io/2017/09/enumerating-process-thread-and-image.html)\n17 September 2017. https://www.triplefault.io/2017/09/enumerating-process-thread-and-image.html.\n\n[23] [Vella, C. Reversing & bypassing EDRs. CrikeyCon, 2019. https://www.youtube.com/watch?v=85H4RvPGIX4.](https://www.youtube.com/watch?v=85H4RvPGIX4)\n\n[24] [Wikipedia. Endpoint detection and response. https://en.wikipedia.org/wiki/Endpoint_detection_and_response.](https://en.wikipedia.org/wiki/Endpoint_detection_and_response)\n\n[25] br-sn. Removing Kernel Callbacks Using Signed Drivers. GitHub. 2 August 2020. https://br-sn.github.io/\nRemoving-Kernel-Callbacks-Using-Signed-Drivers/.\n\n[26] Shamriz, A. Part 1: Fs Minifilter Hooking. 10 July 2020. https://aviadshamriz.medium.com/part-1-fs-minifilterhooking-7e743b042a9d.\n\n[27] [Govind, K.; Kumar Pandey, V.; Selvakumar, S. Pattern Programmable Kernel Filter for Bot Detection. Defence](https://publications.drdo.gov.in/ojs/index.php/dsj/article/view/1425)\nScience Journal 62.3 (2012): 174-179. https://publications.drdo.gov.in/ojs/index.php/dsj/article/view/1425.\n\n[28] [CNO Development Labs. Data Only Attack: Neutralizing EtwTi Provider. May 2021. https://public.cnotools.studio/](https://public.cnotools.studio/bring-your-own-vulnerable-kernel-driver-byovkd/exploits/data-only-attack-neutralizing-etwti-provider)\nbring-your-own-vulnerable-kernel-driver-byovkd/exploits/data-only-attack-neutralizing-etwti-provider.\n\n[29] Ma, S., et al. Accurate, Low Cost and Instrumentation-Free Security Audit Logging for Windows. Proceedings of\n[the 31st Annual Computer Security Applications Conference. Los Angeles, 2015. 401-410. https://dl.acm.org/doi/](https://dl.acm.org/doi/abs/10.1145/2818000.2818039)\nabs/10.1145/2818000.2818039.\n\n[30] Shashidhar, N.; Novak, D. Digital Forensic Analysis on Prefetch Files: Exploring the Forensic Potential of Prefetch\n[Files in the Windows Platform. International Journal of Information Security Science 4.2 (2015): 39-49.](https://www.ijiss.org/ijiss/index.php/ijiss/article/download/118/pdf_25)\nhttps://www.ijiss.org/ijiss/index.php/ijiss/article/download/118/pdf_25.\n\n[31] [Müller, A. Windows Kernel Explorer. 11 November 2021. https://github.com/AxtMueller/Windows-Kernel-Explorer.](https://github.com/AxtMueller/Windows-Kernel-Explorer)\n\n[32] [br-sn. CheekyBlinder. GitHub. 9 August 2020. https://github.com/br-sn/CheekyBlinder.](https://github.com/br-sn/CheekyBlinder)\n\n[33] [Yosifovich, P. EtwExplorer 0.39. 21 February 2019. https://github.com/zodiacon/EtwExplorer.](https://github.com/zodiacon/EtwExplorer)\n\n[34] [Yosifovich, P. Windows Kernel Programming. Lean Publishing, 2020. https://leanpub.com/windowskernelprogramming.](https://leanpub.com/windowskernelprogramming)\n\n[35] Poslušný, M. Signed kernel drivers – Unguarded gateway to Windows’ core. We Live Security. 11 January 2022.\n[https://www.welivesecurity.com/2022/01/11/signed-kernel-drivers-unguarded-gateway-windows-core/.](https://www.welivesecurity.com/2022/01/11/signed-kernel-drivers-unguarded-gateway-windows-core/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.virusbulletin.com/uploads/pdf/conference/vb2022/papers/VB2022-Lazarus-and-BYOVD-evil-to-the-Windows-core.pdf"
    ],
    "report_names": [
        "VB2022-Lazarus-and-BYOVD-evil-to-the-Windows-core.pdf"
    ],
    "threat_actors": [
        {
            "id": "32a223a8-3c79-4146-87c5-8557d38662ae",
            "created_at": "2022-10-25T15:50:23.703698Z",
            "updated_at": "2025-03-27T02:00:55.528031Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Lazarus Group",
                "Labyrinth Chollima",
                "HIDDEN COBRA",
                "Guardians of Peace",
                "NICKEL ACADEMY",
                "Diamond Sleet"
            ],
            "source_name": "MITRE:Lazarus Group",
            "tools": [
                "RawDisk",
                "Proxysvc",
                "BADCALL",
                "FALLCHILL",
                "WannaCry",
                "HOPLIGHT",
                "TYPEFRAME",
                "Dtrack",
                "HotCroissant",
                "HARDRAIN",
                "Dacls",
                "KEYMARBLE",
                "TAINTEDSCRIBE",
                "AuditCred",
                "netsh",
                "ECCENTRICBANDWAGON",
                "AppleJeus",
                "BLINDINGCAN",
                "ThreatNeedle",
                "Volgmer",
                "Cryptoistic",
                "RATANKBA",
                "Bankshot",
                "Torisma",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "9e767b38-12ae-4ef7-9878-5ce1701066d7",
            "created_at": "2024-05-01T02:03:08.131819Z",
            "updated_at": "2025-03-27T02:05:17.413497Z",
            "deleted_at": null,
            "main_name": "NICKEL ACADEMY",
            "aliases": [
                "COVELLITE ",
                "CTG-2460 ",
                "Diamond Sleet ",
                "Guardians of Peace",
                "HIDDEN COBRA ",
                "High Anonymous",
                "Labyrinth Chollima ",
                "NNPT Group",
                "New Romanic Cyber Army Team",
                "Temp.Hermit ",
                "The Lazarus Group ",
                "UNC577 ",
                "Who Am I?",
                "Whois Team",
                "ZINC ",
                "Black Artemis "
            ],
            "source_name": "Secureworks:NICKEL ACADEMY",
            "tools": [
                " DarkMessenger",
                " Destover",
                " Duuzer",
                " HOPLIGHT",
                " Joanap",
                " KorHigh",
                " LiveJinx",
                " Volgmer",
                "Brambul"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "8bc1a044-a23b-4904-903c-13f463605cb3",
            "created_at": "2024-05-01T02:03:08.136237Z",
            "updated_at": "2025-03-27T02:05:17.415795Z",
            "deleted_at": null,
            "main_name": "NICKEL GLADSTONE",
            "aliases": [
                "Bluenoroff ",
                "CTG-6459 ",
                "Citrine Sleet ",
                "HIDDEN COBRA ",
                "Lazarus Group",
                "Sapphire Sleet ",
                "Stardust Chollima ",
                "APT38 "
            ],
            "source_name": "Secureworks:NICKEL GLADSTONE",
            "tools": [
                " Bankshot",
                " CATCH22",
                " CCGC_Proxy",
                " Cur1Agent",
                " Ratankba",
                " Server_TrafficForwarder",
                " Wcry",
                "AlphaNC"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a2b92056-9378-4749-926b-7e10c4500dac",
            "created_at": "2023-01-06T13:46:38.430595Z",
            "updated_at": "2025-03-27T02:00:02.831633Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Operation DarkSeoul",
                "APT38",
                "ATK117",
                "DEV-1222",
                "G0032",
                "APT 38",
                "Stardust Chollima",
                "APT-C-26",
                "ATK3",
                "Diamond Sleet",
                "Hidden Cobra",
                "Unit 121",
                "Subgroup: Bluenoroff",
                "NICKEL GLADSTONE",
                "DEV-0139",
                "Andariel",
                "Operation Troy",
                "COVELLITE",
                "TA404",
                "Lazarus group",
                "Dark Seoul",
                "G0082",
                "NewRomanic Cyber Army Team",
                "Bluenoroff",
                "Appleworm",
                "Nickel Academy",
                "COPERNICIUM",
                "Hastati Group",
                "Bureau 121",
                "Operation AppleJeus",
                "Whois Hacking Team",
                "Citrine Sleet",
                "Sapphire Sleet",
                "Group 77",
                "Labyrinth Chollima",
                "Operation GhostSecret",
                "BeagleBoyz"
            ],
            "source_name": "MISPGALAXY:Lazarus Group",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f32df445-9fb4-4234-99e0-3561f6498e4e",
            "created_at": "2022-10-25T16:07:23.756373Z",
            "updated_at": "2025-03-27T02:02:09.966155Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "APT-C-26",
                "ATK 3",
                "Appleworm",
                "Citrine Sleet",
                "DEV-0139",
                "Diamond Sleet",
                "Gleaming Pisces",
                "Gods Apostles",
                "Gods Disciples",
                "Group 77",
                "Guardians of Peace",
                "Hastati Group",
                "Hidden Cobra",
                "ITG03",
                "Jade Sleet",
                "Labyrinth Chollima",
                "Lazarus Group",
                "NewRomanic Cyber Army Team",
                "Operation 99",
                "Operation AppleJeus",
                "Operation AppleJeus sequel",
                "Operation Blockbuster: Breach of Sony Pictures Entertainment",
                "Operation CryptoCore",
                "Operation Dream Job",
                "Operation Dream Magic",
                "Operation Flame",
                "Operation GhostSecret",
                "Operation In(ter)caption",
                "Operation LolZarus",
                "Operation Marstech Mayhem",
                "Operation No Pineapple!",
                "Operation North Star",
                "Operation Phantom Circuit",
                "Operation Sharpshooter",
                "Operation Ten Days of Rain / DarkSeoul",
                "Operation Troy",
                "SectorA01",
                "Slow Pisces",
                "TA404",
                "TraderTraitor",
                "UNC2970",
                "UNC4034",
                "UNC4736",
                "UNC4899",
                "UNC577",
                "Whois Hacking Team"
            ],
            "source_name": "ETDA:Lazarus Group",
            "tools": [
                "3CX Backdoor",
                "3Rat Client",
                "3proxy",
                "AIRDRY",
                "ARTFULPIE",
                "ATMDtrack",
                "AlphaNC",
                "Alreay",
                "Andaratm",
                "AngryRebel",
                "AppleJeus",
                "Aryan",
                "AuditCred",
                "BADCALL",
                "BISTROMATH",
                "BLINDINGCAN",
                "BTC Changer",
                "BUFFETLINE",
                "BanSwift",
                "Bankshot",
                "Bitrep",
                "Bitsran",
                "BlindToad",
                "Bookcode",
                "BootWreck",
                "BottomLoader",
                "Brambul",
                "BravoNC",
                "Breut",
                "COLDCAT",
                "COPPERHEDGE",
                "CROWDEDFLOUNDER",
                "Castov",
                "CheeseTray",
                "CleanToad",
                "ClientTraficForwarder",
                "CollectionRAT",
                "Concealment Troy",
                "Contopee",
                "CookieTime",
                "Cyruslish",
                "DAVESHELL",
                "DBLL Dropper",
                "DLRAT",
                "DRATzarus",
                "DRATzarus RAT",
                "Dacls",
                "Dacls RAT",
                "DarkComet",
                "DarkKomet",
                "DeltaCharlie",
                "DeltaNC",
                "Dembr",
                "Destover",
                "DoublePulsar",
                "Dozer",
                "Dtrack",
                "Duuzer",
                "DyePack",
                "ECCENTRICBANDWAGON",
                "ELECTRICFISH",
                "Escad",
                "EternalBlue",
                "FALLCHILL",
                "FYNLOS",
                "FallChill RAT",
                "Farfli",
                "Fimlis",
                "FoggyBrass",
                "FudModule",
                "Fynloski",
                "Gh0st RAT",
                "Ghost RAT",
                "Gopuram",
                "HARDRAIN",
                "HIDDEN COBRA RAT/Worm",
                "HLOADER",
                "HOOKSHOT",
                "HOPLIGHT",
                "HOTCROISSANT",
                "HOTWAX",
                "HTTP Troy",
                "Hawup",
                "Hawup RAT",
                "Hermes",
                "HotCroissant",
                "HotelAlfa",
                "Hotwax",
                "HtDnDownLoader",
                "Http Dr0pper",
                "ICONICSTEALER",
                "Joanap",
                "Jokra",
                "KANDYKORN",
                "KEYMARBLE",
                "Kaos",
                "KillDisk",
                "KillMBR",
                "Koredos",
                "Krademok",
                "LIGHTSHIFT",
                "LIGHTSHOW",
                "LOLBAS",
                "LOLBins",
                "Lazarus",
                "LightlessCan",
                "Living off the Land",
                "MATA",
                "MBRkiller",
                "MagicRAT",
                "Manuscrypt",
                "Mimail",
                "Mimikatz",
                "Moudour",
                "Mydoom",
                "Mydoor",
                "Mytob",
                "NACHOCHEESE",
                "NachoCheese",
                "NestEgg",
                "NickelLoader",
                "NineRAT",
                "Novarg",
                "NukeSped",
                "OpBlockBuster",
                "PCRat",
                "PEBBLEDASH",
                "PLANKWALK",
                "POOLRAT",
                "PSLogger",
                "PhanDoor",
                "Plink",
                "PondRAT",
                "PowerBrace",
                "PowerRatankba",
                "PowerShell RAT",
                "PowerSpritz",
                "PowerTask",
                "Preft",
                "ProcDump",
                "Proxysvc",
                "PuTTY Link",
                "QUICKRIDE",
                "QUICKRIDE.POWER",
                "Quickcafe",
                "QuiteRAT",
                "R-C1",
                "ROptimizer",
                "Ratabanka",
                "RatabankaPOS",
                "Ratankba",
                "RatankbaPOS",
                "RawDisk",
                "RedShawl",
                "Rifdoor",
                "Rising Sun",
                "Romeo-CoreOne",
                "RomeoAlfa",
                "RomeoBravo",
                "RomeoCharlie",
                "RomeoCore",
                "RomeoDelta",
                "RomeoEcho",
                "RomeoFoxtrot",
                "RomeoGolf",
                "RomeoHotel",
                "RomeoMike",
                "RomeoNovember",
                "RomeoWhiskey",
                "Romeos",
                "RustBucket",
                "SHADYCAT",
                "SHARPKNOT",
                "SIGFLIP",
                "SIMPLESEA",
                "SLICKSHOES",
                "SORRYBRUTE",
                "SUDDENICON",
                "SUGARLOADER",
                "SheepRAT",
                "SierraAlfa",
                "SierraBravo",
                "SierraCharlie",
                "SierraJuliett-MikeOne",
                "SierraJuliett-MikeTwo",
                "SimpleTea",
                "SimplexTea",
                "SmallTiger",
                "Stunnel",
                "TAINTEDSCRIBE",
                "TAXHAUL",
                "TFlower",
                "TOUCHKEY",
                "TOUCHMOVE",
                "TOUCHSHIFT",
                "TOUCHSHOT",
                "TWOPENCE",
                "TYPEFRAME",
                "Tdrop",
                "Tdrop2",
                "ThreatNeedle",
                "Tiger RAT",
                "TigerRAT",
                "Trojan Manuscript",
                "Troy",
                "TroyRAT",
                "VEILEDSIGNAL",
                "VHD",
                "VHD Ransomware",
                "VIVACIOUSGIFT",
                "VSingle",
                "ValeforBeta",
                "Volgmer",
                "Vyveva",
                "W1_RAT",
                "Wana Decrypt0r",
                "WanaCry",
                "WanaCrypt",
                "WanaCrypt0r",
                "WannaCry",
                "WannaCrypt",
                "WannaCryptor",
                "WbBot",
                "Wcry",
                "Win32/KillDisk.NBB",
                "Win32/KillDisk.NBC",
                "Win32/KillDisk.NBD",
                "Win32/KillDisk.NBH",
                "Win32/KillDisk.NBI",
                "WinorDLL64",
                "Winsec",
                "WolfRAT",
                "Wormhole",
                "YamaBot",
                "Yort",
                "ZetaNile",
                "concealment_troy",
                "http_troy",
                "httpdr0pper",
                "httpdropper",
                "klovbot",
                "sRDI"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1672160733,
    "ts_updated_at": 1743041842,
    "ts_creation_date": 1663614102,
    "ts_modification_date": 1664031382,
    "files": {
        "pdf": "https://archive.orkl.eu/694ae4dec0722864697e781043fe100074c7383e.pdf",
        "text": "https://archive.orkl.eu/694ae4dec0722864697e781043fe100074c7383e.txt",
        "img": "https://archive.orkl.eu/694ae4dec0722864697e781043fe100074c7383e.jpg"
    }
}