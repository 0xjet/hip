{
    "id": "58093a16-370e-4eef-846d-2c4d78785592",
    "created_at": "2022-11-09T02:04:03.387521Z",
    "updated_at": "2025-03-27T02:16:25.798191Z",
    "deleted_at": null,
    "sha1_hash": "e9c68ab39b06777eebbd0966f1ff98401b8e2819",
    "title": "Analyzing the Effectiveness of App Vetting Tools in the Enterprise",
    "authors": "",
    "file_creation_date": "2018-03-14T16:45:52Z",
    "file_modification_date": "2018-03-14T16:45:52Z",
    "file_size": 1453314,
    "plain_text": "The views, opinions and/or findings\ncontained in this report are those of The\nMITRE Corporation and should not be\nconstrued as an official government position,\npolicy, or decision, unless designated by\nother documentation.\n\n**©2016 The MITRE Corporation.**\n\n**Hampton, VA**\n\n**Approved for Public Release;**\n**Distribution Unlimited. Case**\n**Number 16-4772**\n\n\n# Analyzing the Effectiveness of App Vetting Tools in the Enterprise\n\n\nMTR16 02 42\n\nMITR E TE CHNI CA L R EPO RT\n\n\n-----\n\n## Executive Summary\n\nEnterprises invest significant resources in mobile application (hereafter “app”) vetting to\ndetermine whether apps are safe to deploy on mobile devices. App vetting seeks to identify\nsecurity vulnerabilities (usually inadvertent) and malicious or privacy violating (usually\ndeliberate) behaviors in apps. It generally involves a time- and labor-intensive effort, resulting in\nhigh costs and delays in approving apps for use. Additionally, mobile app developers often\noperate on a rapid development cycle, and manual vetting approaches cannot keep up with the\nreleases of new app versions.\n\nVarious use cases for enterprise vetting of mobile apps exist, including in-house developed apps\nfor enterprise use, in-house developed apps for public distribution, commercially developed apps\nfor enterprise use, and commercially developed apps for personal use on enterprise devices. Each\nof these approaches carries different risks. This report provides guidance to US Government and\ncommercial enterprises alike, on how to assess the feasibility of applying automated app vetting\ntools.\n\nTo do so, criteria has been created to evaluate the ability of the solutions to assess apps against\nmany of the requirements in the version 1.2 of the NIAP Protection Profile for Application\nSoftware (not all of the NIAP requirements can be automated). The MITRE team additionally\nused NIAP’s sample Mobile App Security Vetting Reciprocity Report[1], which describes useful\napp vetting results to report based on the NIAP PP requirements. MITRE suggests additional\ncriteria to cover broader app vetting tool capabilities (e.g., reputation analysis), threats against\nthe app vetting tool itself, and other common vulnerabilities or malicious behavior commonly\nobserved in apps but not directly addressed by the NIAP PP. These criteria do not represent an\nexhaustive list of every potential vulnerability or malicious behavior in apps. Rather, they cover\nmany common app issues to enable a baseline evaluation of vetting tool capabilities. Enterprises\nmay add criteria based on their specific needs and risks.\n\nOn the basis of the assessment criteria, the MITRE team developed or obtained several\nvulnerable and potentially malicious apps to use in assessing the ability of app vetting solutions.\nThe results from testing these apps provide a basic, high-level baseline for assessing app vetting\nsolution capabilities to address the criteria. The apps developed/selected do not exhibit every\npotential behavior that violates the criteria and thus the results do not ensure the ability of app\nvetting solutions to provide full code coverage. For example, vulnerable or malicious code could\nbe hidden behind a login prompt or other user interface element or behind a deliberately inserted\ntime delay before execution, or could make use of emulator detection to evade analysis. The\ntools may or may not detect these and other kinds of evasion techniques.\n\nMITRE conducted a market analysis of mobile app vetting tools and found 30 such commercial\nor open source offerings. The enclosed App Vetting Tools Market Analysis spreadsheet contains\nthe findings of the market analysis. Given the limited resources of time and funding, MITRE\nevaluated only those tools most likely to satisfy the largest number of identified criteria. As such,\nthe evaluation gave preference to tools that claimed conformance with the NIAP PP; the team\nalso looked to Gartner studies[23] to select top performers.\n\n1 https://github.com/commoncriteria/application/wiki/Schema\n2 Gartner’s Application Security Testing Magic Quadrant 2015\n3 Gartner’s Critical Capabilities for Application Security Testing 2015 – Mobile App Testing\n\n1\n\n\n-----\n\nThe tools evaluated were Android Lint (Included in Android Studio and Android SDK) and 8\nother commercial products that have been anonymized due to non-disclosure agreements\nbetween MITRE and their respective companies. The products are identified by Product 1 – 8.\n\nOverall, MITRE found that the best solutions generally employed a combination of static and\ndynamic analysis techniques. Static analysis techniques provide insights into the properties of the\napp and can detect many vulnerabilities, while dynamic analysis techniques reveal app behaviors\nthat only occur at runtime.\n\nSolution capabilities vary widely. Some solutions focus on traditional Java or other language\ncoding issues and have limited coverage of weaknesses specific to high-risk Android and iOS\nmobile apps. Other solutions have a strong focus on specific weaknesses that commonly occur in\nAndroid and iOS apps. Therefore, enterprises should carefully assess capabilities and choose the\nbest solution or solutions to meet their particular needs.\n\nSome solutions can identify both vulnerabilities and potentially malicious or privacy-violating\nbehaviors. However, in the solutions examined MITRE found that it would be trivial for a\nmalicious app to identify the presence of an analysis environment versus a typical mobile device\nbeing used by a real user, and to adapt its behavior accordingly to evade detection. Even the\nsolutions that use real mobile devices rather than emulators contain obvious indicators of an\nanalysis environment, such as the presence of the Xposed framework (Android) or the Cydia app\nstore (iOS) in the list of installed apps. Identifying vulnerabilities and identifying potentially\nmalicious behaviors represent different use cases, and robustly detecting malicious applications\nis very difficult.\n\n2\n\n\n-----\n\n## Acknowledgments\n\nThe authors would like to acknowledge the contributions to this report by Jay Vora, Gavin\nBlack, Sarah Ford, Dustin Hooven, Michael Schoenfeld and Rushi Purohit.\n\nThis technical data deliverable was developed using contract funds under Basic Contract No.\nW15P7T-13-C-A802.\n\niii\n\n\n-----\n\n## Table of Contents\n\n1 Introduction ............................................................................................................................. 1\n\n1.1 Background ...................................................................................................................... 1\n\n1.2 Document Structure ......................................................................................................... 1\n\n2 Mobile App Use Cases and Associated Risks ......................................................................... 3\n\n3 Evaluation Criteria for App Vetting Solutions ........................................................................ 7\n\n3.1 Evaluation Criteria ........................................................................................................... 7\n\n3.2 Test Cases ...................................................................................................................... 12\n\n4 Vulnerable and Potentially Malicious Test Apps .................................................................. 19\n\n4.1 Android Apps ................................................................................................................. 19\n\n4.1.1 UploadDataApp ....................................................................................................... 19\n\n4.1.2 Custom-class-loader ................................................................................................. 21\n\n4.1.3 Device Administrator Sample App .......................................................................... 22\n\n4.1.4 Android Vulnerability Test Suite ............................................................................. 22\n\n4.1.5 Subterfuge App ........................................................................................................ 22\n\n4.2 iOS App ......................................................................................................................... 23\n\n4.2.1 Acme Airlines .......................................................................................................... 23\n\n5 Tool Evaluation ..................................................................................................................... 25\n\n5.1 Vetting Tools Examined ................................................................................................ 25\n\n5.2 Findings ......................................................................................................................... 25\n\n6 Future Work .......................................................................................................................... 31\n\nAppendix A Android Platform Mitigations ............................................................................. A-1\n\nA.1 Access to Hardware Resources and Sensitive Information Repositories (NIAP App PP\nFDP_DEC_EXT.1.1 and FDP_DEC_EXT.1.2) .......................................................... A-1\n\nA.2 Sensitive Application Data / File Permissions (FDP_DAR_EXT.1.1 and\nFMT_CFG_EXT.1.2) .................................................................................................. A-3\n\nA.3 Network Communication (FDP_NET_EXT.1.1) / Protecting Data in Transit ............ A-4\n\nAppendix B NIAP Protection Profile Recommendations ....................................................... B-1\n\nAppendix C Tool Assessments................................................................................................ C-1\n\nC.1 Android Lint ................................................................................................................. C-1\n\nAppendix D Acronyms ............................................................................................................ D-1\n\ni\n\n\n-----\n\n## List of Figures\n\nFigure A-1. Android's Runtime Permissions .............................................................................. A-2\nFigure A-2. Old Android Permissions ........................................................................................ A-3\nFigure C-1. Android Lint Screenshot .......................................................................................... C-1\n\n\n-----\n\n## List of Tables\n\nTable 1. Primary App Vetting Focus Areas .................................................................................... 5\nTable 2. Mobile App Vetting Test Cases ...................................................................................... 12\nTable 3. Android Test Results ...................................................................................................... 27\nTable 4. iOS Test Results .............................................................................................................. 29\n\ni\n\n\n-----\n\n## 1 Introduction\n\n### 1.1 Background\n\nEnterprises invest significant resources in mobile application (hereafter “app”) vetting to\ndetermine whether apps are safe to deploy on mobile devices. App vetting seeks to identify\nsecurity vulnerabilities (usually inadvertent) and malicious or privacy violating (usually\ndeliberate) behaviors in apps. It generally involves a time- and labor-intensive effort, resulting in\nhigh costs and delays in approving apps for use. Additionally, mobile app developers often\noperate on a rapid development cycle, and manual vetting approaches cannot keep up with the\nreleases of new app versions.\n\nVarious use cases for enterprise vetting of mobile apps exist, including in-house developed apps\nfor enterprise use, in-house developed apps for public distribution, commercially developed apps\nfor enterprise use, and commercially developed apps for personal use on enterprise devices. Each\nof these approaches carries different risks. This report provides guidance to US Government and\nnon-government enterprises alike, on how to assess the feasibility of applying automated app\nvetting tools.\n\nNumerous vendors now provide automated app vetting tools (sometimes also known as app\nthreat intelligence or threat protection services) that run static and/or dynamic analysis tests on\napps to detect security vulnerabilities, maliciousness, or privacy-violating behaviors. These tools\nmay be provided as cloud-based services or as on-premises solutions. Many of the tools regularly\ncrawl commercial app stores, automatically analyzing new app versions using the vendors’\nevolving knowledge of mobile threats and making the analysis results available. Some can\nperform reputational analysis of apps and their developers based on intelligence information\ngathered from sources such as app stores and participating mobile devices. They may also\nprovide the ability to directly submit in-house apps for analysis that may not be present on the\nmainstream app stores. Leveraging these commercial offerings enables enterprises to streamline\napp vetting, decreasing the cost and time associated with analysis while potentially improving\nsecurity by staying up-to-date with emerging threats and app versions.\n\n### 1.2 Document Structure\n\nSection 2 of this report contains background on mobile app use cases and associated risks\naddressed during app vetting.\n\nSection 3 summarizes repeatable criteria suitable for assessing app vetting tools. The criteria are\nprimarily based on the National Information Assurance Partnership’s (NIAP’s) Protection Profile\n(PP) for Application Software v1.2,[4] which was adopted by the Federal CIO (Chief Information\nOfficer) Council as the source of app vetting criteria for government use. The PP contains\nrequirements intended to address both vulnerabilities and malicious or privacy violating\nbehavior. This section also details Android-specific and iOS-specific test cases to apply to app\nvetting tools.\n\nSection 4 describes sample Android and iOS apps that the MITRE research team developed or\nobtained that exhibit various vulnerabilities and suspicious behaviors aligned with the criteria\n\n4 https://www.niap-ccevs.org/pp/PP_APP_v1.2/\n\n1\n\n\n-----\n\ndescribed in section 3. These sample apps can be used to assess app vetting tools against the\ncriteria.\n\nSection 5 lists the anonymized tools that the team evaluated and the selection criteria that was\nused to select them, as well as high-level, aggregated conclusions from applying MITRE’s test\ncases to them.\n\nSection 6 poses future work possibilities.\n\n2\n\n\n-----\n\n## 2 Mobile App Use Cases and Associated Risks\n\nAs described above, mobile app vetting may include searches both for potentially exploitable\nvulnerabilities and for potentially malicious or privacy-violating behaviors. Each enterprise must\ndetermine its own acceptable level of risk when deciding on the necessary scope of security\nanalysis. However, MITRE recommends taking into account both the organization that\ndeveloped the app (in-house vs. external) as well as the planned use of the app (whether it will be\nused for enterprise purposes or not). In all cases, enterprises should also take into account the\nsecurity features provided by the mobile platform (operating system and other underlying ondevice technologies as well as broader ecosystem capabilities). Many mobile app analysis tools\ncan quickly perform a reputational analysis of the app and its developer, which in some\nenvironments may be sufficient to justify approving an app for use.\n\nApps developed in-house are less likely to contain intentionally malicious or privacy-violating\nfunctionality than external apps. Vetting of these apps can therefore focus primarily on searching\nfor security vulnerabilities. However, some level of risk of malicious or privacy violating\nbehavior may still exist: for example, third-party software libraries included in the app may\ninclude privacy-violating behaviors to enable targeted advertising that are not known to the app\ndeveloper. Similarly, if the enterprise outsourced all or part of development, it may not be aware\nof the full behavior of the app, yet might still be held responsible for the app’s behavior.\n\nIt is important to note that no known analysis tool can perform an exhaustive search for all\npossible vulnerabilities, maliciousness, or privacy-violating behavior. Enterprises should follow\nsecure software development practices when developing apps in-house and ensure they\nunderstand and mitigate any potential implications of using third-party libraries or outsourced\nsoftware development.\n\nPersonal apps are not intended to process enterprise data. Vetting of these apps can primarily\nfocus on searching for malicious or privacy-violating functionality, with a search for security\nvulnerabilities being less critical to the enterprise, because mobile device app sandboxes\ngenerally isolate the impact that exploitation of a single app would have on other apps on the\ndevice. However, some risk still exists that an attacker could use a vulnerable app as a vector to\nexploit the mobile device itself and gain access to enterprise data. Additionally, individual\nmobile device users would certainly be interested in the potential impact on their personal data of\nany vulnerabilities in personal apps.\n\n3\n\n\n-----\n\nTable 1 summarizes the recommended primary focus areas for app vetting based on application\ndeveloper and planned use of app.\n\n4\n\n\n-----\n\nCommercial personal use app Primary focus Less critical, but may still be\nnecessary\n\nEnterprises should take the properties provided by modern mobile platforms into account when\ndetermining the required scope of app vetting. The NIAP Protection Profile for Application\nSoftware takes many of these properties into account in its operating system-specific tests for\neach requirement. Mobile operating systems contain built-in security features designed to\nprovide protection from malicious behaviors, decrease the likelihood of vulnerabilities, and\ndecrease the impact of exploitation of vulnerabilities. Additionally, the broader mobile\necosystem provides protections as well.\n\nTypically, the operating system prohibits mobile apps from accessing data stored by other apps\nand from interfering with the behavior of other apps. Apps must request permission to access\nsensitive information repositories (e.g., contact list) and sensitive device hardware capabilities\n(e.g., microphone, camera, Global Positioning System [GPS]). The operating system also limits\napps’ ability to access other underlying device resources and services. For example, on Android,\nall apps must include a manifest file (AndroidManifest.xml) that defines the app’s permissions\nand other important properties, and the operating system enforces the contents of the manifest\nfile.\n\nIn an effort to reduce the presence of exploitable vulnerabilities, mobile operating systems\nprovide safe default behaviors in many cases. For example, https or other Transport Layer\nSecurity (TLS)-secured connections perform proper certificate validation by default, although\nthey are sometimes inadvertently overridden by individual apps to perform insecure behaviors.\nThe Network Security Configuration feature introduced in Android 7 (Nougat) and the App\nTransport Security feature introduced in iOS 9 will likely help app developers avoid many\ncommon network security mistakes.\n\nDevice or operating system-level features such as Android for Work, Samsung KNOX\nWorkspace, and Apple iOS-managed apps can be used to separate apps processing enterprise\ndata from those that do not. These features to some extent defend enterprise apps against\nvulnerabilities or malicious activities within apps that do not process enterprise data.\n\nThe broader mobile ecosystem also provides additional protections. For example, both Google\nand Apple screen apps submitted to their app stores for both vulnerabilities and harmful\nbehaviors, and have mechanisms in place to discourage installation of apps from other sources.\nGoogle gives details of its app security analysis process on pages 14–24 of its Android Security\n\n5\n\n|Table 1. Primary App Vetting Focus Areas|Col2|Col3|\n|---|---|---|\n|Malicious Functionality Security Vulnerabilities|||\n|In-house enterprise use app|Less critical, but may still be necessary|Primary focus|\n|In-house developed app for public distribution|Less critical, but may still be necessary|Primary focus|\n|Commercial enterprise use app|Both should be examined|Both should be examined|\n|Commercial personal use app|Primary focus|Less critical, but may still be necessary|\n\n\n-----\n\n2015 Year in Review report.[5] Google’s report also contains an overview of the Android mobile\necosystem security protections in general.\n\nAppendix A provides additional related information on mitigations provided by the mobile\nplatforms. Malicious apps can certainly attempt to exploit vulnerabilities in the operating system\nin order to escalate privileges and bypass these protections, but doing so involves significant\nextra effort, increased risk of detection, and decreased probability of success. The likelihood of\nsuccess varies between mobile platforms.\n\nOn the other hand, the mobile environment can exacerbate the impact of some app weaknesses.\nFor example, mobile devices are commonly used on unprotected public Wi-Fi networks, where\nan attacker can easily intercept or manipulate network communication. Therefore, enterprises\nmust generally treat data-in-transit issues such as use of plaintext network communication (for\ninstance, using http instead of https) or improperly configured network encryption (for instance,\ndisabling certificate validation) as critical issues to address.\n\n5\n\nhttp://static.googleusercontent.com/media/source.android.com/en//security/reports/Google_Android_Security_2015_Report_Fina\nl.pdf\n\n6\n\n\n-----\n\n## 3 Evaluation Criteria for App Vetting Solutions\n\n### 3.1 Evaluation Criteria\n\nThis section provides high-level criteria for enterprises to use in evaluating app vetting solutions.\nThis report presents criteria to evaluate the ability of the solutions to assess apps against many of\nthe requirements in the version 1.2 of the NIAP Protection Profile for Application Software (not\nall of the NIAP requirements can be automated). The MITRE team additionally used NIAP’s\nsample Mobile App Security Vetting Reciprocity Report[6], which describes useful app vetting\nresults to report based on the NIAP PP requirements. MITRE suggests additional criteria to\ncover broader app vetting tool capabilities (e.g., reputation analysis), threats against the app\nvetting tool itself, and other common vulnerabilities or malicious behavior commonly observed\nin apps but not directly addressed by the NIAP PP. These criteria do not represent an exhaustive\nlist of every potential vulnerability or malicious behavior in apps. Rather, they cover many\ncommon app issues to enable a baseline evaluation of vetting tool capabilities. Enterprises may\nadd criteria based on their specific needs and risks. The following list presents the recommended\ncriteria for evaluating app vetting solutions and identifies the relevant NIAP PP requirement if\none exists:\n\n1. Types of applications supported by the app vetting solution:\n\n  - A. Supported platforms: e.g., Android, iOS, Windows\n\n  - B. App source code required or not required\n\n  - C. What types of application code can be assessed? For example, on Android, can only the\nJava code be assessed, or can native code also be assessed? Are cross-platform app\ndevelopment frameworks supported (for example, Apache Cordova)?\n\n2. Ability to assess general risks associated with an app [This item can be skipped for in-house\ndeveloped apps]:\n\n  - A. Assess ability to assess the reputation of the app and its developer; for example:\n\n`o` Does the same app exist in mainstream app stores? How popular is it (determined by\n\nnumber of downloads and ratings)?\n\n`o` How many apps from the same developer exist in mainstream app stores? How\n\npopular are they? Have security issues been found in other apps from the same\ndeveloper?\n\n  - B. Are there indications that the app is repackaged/counterfeit? For example:\n\n`o` Does another app with the same name but from a different developer exist in\n\nmainstream app stores and/or is installed on a large number of mobile devices?\n\n3. Ability to detect potentially exploitable security vulnerabilities:\n\n  - A. Assess ability to identify failure to invoke an appropriate random number generator\nwhere needed.\n\n6 https://github.com/commoncriteria/application/wiki/Schema\n\n7\n\n\n-----\n\n`o` NIAP FCS_RBG_EXT.1.1\n\n- B. Assess ability to identify insecurely storing private keys, passwords, or related secret\nvalues.\n\n`o` NIAP FCS_STO_EXT.1.1\n\n- C. Assess ability to report data stored by the app, including whether the data is stored\nsecurely (e.g., in an appropriate storage location and with appropriate file permissions).\n\n`o` NIAP FDP_DAR_EXT.1.1 and FMT_CFG_EXT.1.2\n\n- D. Assess ability to report whether network communications use secure protocols (e.g.,\nHTTPS vs. HTTP) and any related security issues such as improper HTTPS/TLS certificate\nvalidation or hostname checking.\n\n`o` NIAP FTP_DIT_EXT.1.1, FCS_TLSC_EXT.1.1, FCS_TLSC_EXT.1.2,\n\nFCS_TLSC_EXT.1.3, FIA_X509_EXT.1.1\n\n- E. Assess ability to identify default credentials found within the app.\n\n`o` NIAP FMT_CFG_EXT.1.1\n\n- F. Assess ability to identify mapping of memory at explicit locations.\n\n`o` NIAP FPT_AEX_EXT.1.1\n\n- G. Assess ability to identify mapping of memory as both writable and executable.\n\n`o` NIAP FPT_AEX_EXT.1.2\n\n- H. Assess ability to determine whether the app successfully runs on the latest version of\nthe operating system (and hence is likely compatible with its security architecture).\n\n`o` NIAP FPT_AEX_EXT.1.3\n\n- J. Assess ability to determine whether the app places executable code in locations where\nthe code can be modified.\n\n`o` NIAP FPT_AEX_EXT.1.4\n\n- K. Assess ability to identify code compiled without stack-based buffer overflow protection\nenabled.\n\n`o` NIAP FPT_AEX_EXT.1.5\n\n- L. Assess ability to identify third-party libraries included in the app.\n\n`o` NIAP FPT_LIB_EXT.1.1\n\n- M. Assess ability to identify other common cryptographic implementation issues.\n\n- N. Assess ability to identify inter-process communication issues.\n\n`o` [Android only] Assess ability to identify app components (activities, services,\n\nbroadcast receivers, content providers) that are exported and could expose potential\nattack surface to other apps. Also assess ability to detect specific, common\ninterprocess communication issues such as vulnerable broadcast receivers for\n\n8\n\n\n-----\n\nprotected-broadcast action strings that do not properly check the received action string\n(see CWE-925 for more details).\n\n§ No directly applicable NIAP requirement.\n\n§ The MITRE team has regularly identified these issues in Android applications as\n\npart of its own research and code review activities.\n\n4. Ability to detect potentially malicious or privacy-violating behaviors:\n\n  - A. Assess ability to report hardware resources accessed by the app. Report permissions\nrequested by the app and/or actual operations performed.\n\n`o` NIAP FDP_DEC_EXT.1.1\n\n  - B. Assess ability to report sensitive information repositories accessed by the app. Report\npermissions requested by the app and/or actual operations performed.\n\n`o` NIAP FDP_DEC_EXT.1.2\n\n  - C. Assess ability to report all network communication performed by the app.\n\n`o` NIAP FDP_NET_EXT.1.1 (was FDP_DEC_EXT.1.4)\n\n  - D. Assess ability to determine whether the application attempts to update executable code\nafter installation.\n\n`o` NIAP FPT_TUD_EXT.1.4\n\n  - E. Assess ability to ensure the app only uses supported platform application programming\ninterfaces (APIs).\n\n`o` NIAP FPT_API_EXT.1.1\n\n  - F. Assess ability to determine whether the application code has been obfuscated or\notherwise deliberately implemented in a way that makes security analysis more difficult.\n\n`o` NIAP AVA_VAN.1.1C\n\n`o` NOTE: Some app vetting tools identify the lack of obfuscation as a security issue, e.g.,\n\nthey encourage the use of obfuscation—the opposite of what the NIAP App PP calls\nfor. The Open Web Application Security Project (OWASP) Mobile Security Project\nhas also called for the use of obfuscation. The MITRE team is not yet sure how to\nreconcile this contradiction. In some cases, it may be possible to use an un-obfuscated\ndebug version of the app for vetting purposes and a separate obfuscated version for the\nactual production-released app.\n\n  - G. Assess ability to identify known malicious code (e.g., operating system exploits) within\nthe application.\n\n`o` NIAP AVA_VAN.1.2E\n\n  - H. [Android only] Assess ability to identify attempts by the application to obtain device\nadministrator access.\n\n`o` No applicable NIAP requirement\n\n9\n\n\n-----\n\n`o` MITRE added this requirement because examples exist of malicious apps that request\n\nand then abuse device administrator access. For example, ransomware apps can abuse\ndevice administrator access to reset the device’s screen lock password and lock the\nuser out of his or her own device. One example is the Xbot family of malicious apps\nreported by Palo Alto Networks.[7]\n\n  - I. [iOS Only] Assess ability to identify Uniform Resource Locator (URL) scheme\nhijacking issues, where the app registers URL schemes that belong to other apps in order to\nhijack communications intended for that other app.\n\n`o` No directly applicable NIAP requirement\n\n5. Security of the app vetting tool itself:\n\n  - A. Ability to resist attempts by malicious apps to determine that they are running in an\nanalysis environment.\n\n  - B. [Cloud-based vetting solutions used by multiple tenants] Ability to refresh the\nenvironment after each app is analyzed so that sensitive data is not exposed to other apps\nunder analysis.\n\n  - C. Ability to resist persistent exploitation of the analysis environment by a malicious app.\n(MITRE did not actually test any tools against this requirement, but believes it should be\ntaken into consideration for future work.)\n\n6. Reporting capabilities:\n\n  - A. Ability to list output formats supported, e.g., JSON, XML, other machine-consumable\ndata format, XLS, PDF, etc.\n\n  - B. Ability to provide evidence (e.g., network packet captures, system call traces,\nscreenshots) that analysts can use to clarify or confirm reported information about apps.\n\n  - C. Ability to integrate with Enterprise Mobile Management/Mobile Device Management\n(EMM/MDM) systems to:\n\n`o` Automatically analyze apps installed on the enterprise’s mobile devices using the\n\nEMM/MDM system’s knowledge of device app inventory.\n\n`o` Respond when apps with issues are identified (e.g., alert an administrator, uninstall the\n\noffending app, limit device access to enterprise resources until the issue is resolved).\n\n7. Other iOS tests (Note: these are not specific to iOS only, but due to time constraints were not\nimplemented in the Android apps):\n\n  - A. Assess ability to find instances of unsanitized user input that could be used for a host of\nattacks, to include SQL injection and Cross-Site Scripting.\n\n  - B. Assess ability of the tool to detect time bomb attacks; e.g., execute code only 7 days\nafter installation.\n\n7 http://researchcenter.paloaltonetworks.com/2016/02/new-android-trojan-xbot-phishes-credit-cards-and-bank-accounts-encryptsdevices-for-ransom/\n\n10\n\n\n-----\n\nNote: MITRE did not include the following mandatory NIAP Protection Profile for Application\nSoftware Security Functional Requirements in the above criteria:\n\n  - FPR_ANO_EXT.1.1: Not automatable because typically app vetting tools have no\nobjective way to automatically distinguish personally identifiable (PII) from non-PII.\n\n  - FMT_MEC_EXT.1.1: Not automatable because typically app vetting tools have no\nautomated way to determine what constitutes a configuration option being stored or set\nthrough an improper mechanism.\n\n  - FMT_CFG_EXT.1.1: Not automatable.\n\n  - FMT_SMF.1.1: Not automatable.\n\n  - FPT_TUD_EXT.1.1: Not automatable.\n\n  - FPT_TUD_EXT.1.2: No test to perform on Android and iOS, as apps are always in the\nplatform-supported package manager format.\n\n  - FPT_TUD_EXT.1.3: Not automatable.\n\n  - FPT_TUD_EXT.1.5: Not automatable.\n\n  - FPT_TUD_EXT.1.6: No test to perform on Android and iOS, as apps are always signed.\n\nThe NIAP PP contains a number of optional and selection-based requirements. The MITRE team\ngenerally did not include those in the criteria listed above.\n\n11\n\n\n-----\n\n### 3.2 Test Cases\n\nTable 2 lists the test cases for Android and iOS.\n\n**Table 2. Mobile App Vetting Test Cases**\n\n**Assessment** **Test Case Goal** **Android Test Cases**\n**Criteria**\n\n2A. Ability Assess ability to Test a well-known\nto assess the determine the commercial app:\nreputation of reputation of the app Did the tool provide an\nthe app and and its developer.\nits developer.\n\nAssess ability to\n\n2B. determine whether\nIndications the app is counterfeit/ store, its popularity, its\nthat the app repackaged. reviews, etc.)?\nis counterfeit/\nrepackaged? commercial app:\n\n3A / NIAP Assess ability to UploadDataApp:\nFCS_RBG_E identify failure to\nXT.1.1 invoke an appropriate\n\nrandom number\ngenerator. appropriate practice of\n\n3B / NIAP Assess ability to UploadDataApp:\nFCS_STO_E identify passwords or Did the tool detect the\nXT.1.1 other sensitive data\n\nimproperly stored on\nthe device. directory?�\n\n�\nDid the tool detect the\n\ndirectory (/sdcard)?\n\nThis test would likely\n\nscan for.\n\n3C / NIAP Assess ability to\nFDP_DAR_ report data stored by\nEXT.1.1 and the app, including\nFMT_CFG_ whether it is stored\nEXT.1.2 securely (e.g., in an\n\n12\n\n|Col1|Table 2. Mobile App Vetting Test Cases|Col3|Col4|\n|---|---|---|---|\n|Assessment Criteria|Test Case Goal Android Test Cases iOS Test Cases|||\n|2A. Ability to assess the reputation of the app and its developer. 2B. Indications that the app is counterfeit/ repackaged?|Assess ability to determine the reputation of the app and its developer. Assess ability to determine whether the app is counterfeit/ repackaged.|Test a well-known commercial app: Did the tool provide an appropriate reputation result (based on information such as the presence of the same app in a mainstream app store, its popularity, its reviews, etc.)?|Test a well-known commercial app: Did the tool provide an appropriate reputation result (based on information such as the presence of the same app in a mainstream app store, its popularity, its reviews, etc.)?|\n|||Repackage a well-known commercial app: Did the tool report it as a counterfeit/repackaged app?|Repackage a well-known commercial app: Did the tool report it as a counterfeit/repackaged app?|\n|3A / NIAP FCS_RBG_E XT.1.1|Assess ability to identify failure to invoke an appropriate random number generator.|UploadDataApp: Did the tool detect the use of a static IV for AES-CBC encryption rather than the appropriate practice of generating a random IV?|AcmeAirlines: Did the tool detect the use of a static IV for AES-CBC encryption rather than the appropriate practice of generating a random IV?|\n|3B / NIAP FCS_STO_E XT.1.1|Assess ability to identify passwords or other sensitive data improperly stored on the device.|UploadDataApp: Did the tool detect the password value written to the app’s internal storage directory?\u0001 \u0001 Did the tool detect the password value written to the device’s external storage directory (/sdcard)? This test would likely require that the tool provide a mechanism to input tainted sensitive data values to then scan for.|AcmeAirlines: Did the tool detect the password value written to the app’s internal storage directory? This test would likely require that the tool provide a mechanism to input tainted sensitive data values to then scan for.|\n|3C / NIAP FDP_DAR_ EXT.1.1 and FMT_CFG_ EXT.1.2|Assess ability to report data stored by the app, including whether it is stored securely (e.g., in an|Did the tool report the files written to internal storage with deliberately insecure world-readable and world- writable file permissions?|Did the tool report files written to internal storage with NSFileProtectionNone or \"No Protection\"?|\n\n\n-----\n\n|Col1|appropriate directory and with appropriate file permissions).|Did the tool report the files written to external storage where they could be potentially accessed by other apps?|N/A|\n|---|---|---|---|\n|3D / NIAP FDP_DIT_E XT.1.1, FCS_TLSC_ EXT.1.1, FCS_TLSC_ EXT.1.2, FCS_TLSC_ EXT.1.3, FIA_X509_E XT.1.1|Assess ability to identify insecure network communication, including the use of plaintext protocols, improper certificate validation, or improper hostname checking.|Did the tool report the app’s network communication, including the destination address and port?|Did the tool report the app’s network communication, including the destination address and port?|\n|||Did the tool report the transmission of sensitive data in cleartext (the password used for HTTP Basic Authentication to the server)?|Did the tool report the transmission of sensitive data in cleartext (the password used for HTTP Basic Authentication to the server)?|\n|||Did the tool report that server certificate checking and hostname verification was disabled, making the app’s network communication susceptible to man-in-the-middle attacks?|Did the tool report that server certificate checking and hostname verification was disabled, making the app’s network communication susceptible to man-in-the- middle attacks?|\n|3E / NIAP FMT_CFG_ EXT.1.1|Assess ability to identify default credentials embedded in the application code.|UploadDataApp: Did the tool detect either the static AES key and IV embedded in the app and used for encryption, or the username and password embedded in the app and used for HTTP authentication?|Did the tool detect either the static AES key and IV embedded in the app and used for encryption, or the username and password embedded in the app and used for HTTP authentication?|\n|3F / NIAP FPT_AEX_E XT.1.1|Assess ability to identify mapping of memory at explicit locations.|Assess custom-class-loader. Did the tool detect that the app maps memory at an explicit address?|N/A|\n|3G / NIAP FPT_AEX_E XT.1.2|Assess ability to identify mapping of memory as both writable and executable.|Did the tool detect that the app maps memory with both write and execute permissions?|N/A|\n\n\n13\n\n\n-----\n\n|3H / NIAP FPT_AEX_E XT.1.3|Assess ability to determine whether the app properly leverages OS anti- exploitation capabilities where appropriate.|Assess any app: Was the tool able to identify whether the app could successfully start up on the latest released version of Android or is the tool able to successfully scan code written for the latest version of Android?|Assess any app: Was the tool able to identify whether the app could successfully start up on the latest released version of iOS? Note: iOS does not face the compatibility issues that Android does. MITRE has developed AcmeAirlines for the most current version of iOS so the test should be sufficient.|\n|---|---|---|---|\n|3J / NIAP FPT_AEX_E XT.1.4|Assess ability to determine whether the app places executable code in locations where the code can be modified.|Combine with test for 4D / NIAP FPT_TUD_EXT.1.4.|N/A|\n|3K / NIAP FPT_AEX_E XT.1.5|Assess ability to identify code compiled without stack-based buffer overflow protection enabled.|Custom-class-loader: Determine whether the lack of stack protection buffer overflow was identified.|N/A|\n|3L / NIAP FPT_LIB_E XT.1.1|Assess ability to identify third-party libraries included in the app.|Subterfuge app (APK available): Did the tool identify the presence of OpenSSL? Did it identify the version number (1.0.1o)? Did it identify relevant security issues (e.g., OpenSSL 1.0.1o is susceptible to CVE-2015- 1793)?|Acme Airlines: Did the tool show the use of iOS Libraries, Frameworks and Pods used? Did it report the use of JSPatch pod?|\n|3M / Ability to identify other crypto issues not addressed above|Assess ability to identify other crypto issues not addressed above.|Did the tool detect the use of AES in CBC mode without an accompanying authentication mechanism (e.g., MAC computation)?|Did the tool detect the use of AES in CBC mode without an accompanying authentication mechanism (e.g., MAC computation)?|\n\n\n14\n\n\n-----\n\n|3N Ability to identify inter- app communica- tion security issues|Assess ability to identify app components (activities, services, broadcast receivers, content providers) that are exported and could expose potential attack surface to other apps. Assess ability to identify vulnerable broadcast receivers for protected- broadcast action strings that do not properly check the received action string (CWE-925).|UploadDataApp: Did the tool detect that SendIntentService, LocationService, RecordIntentService, and InjectSMSService are exported and hence can be directly invoked by other apps on the device? UploadDataApp: Did the tool detect that SMSReceiver does not check the sender’s permission?|Acme Airlines: Did the tool show the user which URI schemes the app had registered? This will aid the evaluator in determining if a URI scheme is trying to be hijacked.|\n|---|---|---|---|\n|||UploadDataApp: Did the tool detect that BootReceiver does not check that the received intent’s action string matches the expected value of “android.intent.action.BOOT _COMPLETED”?|N/A|\n|4A / NIAP FDP_DEC_E XT.1.1 4B / NIAP FDP_DEC_E XT.1.2|Assess ability to report hardware resources accessed by the app. Report permissions requested by the app and/or actual operations performed. Assess ability to report sensitive information repositories accessed by the app (e.g., calendar, call logs, contact list/address book, system logs, photos). Report permissions requested by the app and/or actual operations performed.|Did the tool report the permissions requested by the app to hardware resources and sensitive information repositories?|Did the tool report the permissions requested by the app to hardware resources and sensitive information repositories?|\n|||Did the tool detect: - Audio recorded using microphone - GPS location gathered|Did the tool detect: - Audio recorded using microphone - GPS location gathered|\n|||Did the tool detect: - Contact list access - Call log access - IMEI access - Phone number access - Accessing names of all files in external storage - Accessing incoming SMS messages - Installed apps list - Sending all information described above over the network|Did the tool detect: -Contact list access -Installed apps list -Sending all information described above over the network|\n|4C / NIAP FDP_NET_E XT.1.1|Assess ability to report all network communication performed by the app.|Combine with test 3D – no need to report results in this row.|Combine with test 3D – no need to report results in this row.|\n\n\n15\n\n\n-----\n\n|4D / NIAP FPT_TUD_E XT.1.4|Assess ability to determine whether the application attempts to update executable code after installation.|custom-class-loader: Did the tool detect that the app downloads new Dalvik and native code from a remote server and executes it (secondary_dex.jar and libhello-jni.so)?|Did the tool report usage of JSPatch?|\n|---|---|---|---|\n|4E / NIAP FPT_API_E XT.1.1|Assess ability to ensure the application only uses supported platform APIs.|UploadDataApp: Did the tool detect the call (via reflection) to com.android.internal.telepho ny.GsmAlphabet.stringToGs m7BitPacked, which is an unsupported platform API?|Did the tool report the usage of a private API as demonstrated by using the allApplications selector from the LSApplicationWorkspace class?|\n|4F / NIAP AVA_VAN. 1.1C|Assess ability to determine whether the application code has been obfuscated or otherwise deliberately implemented in a way that makes security analysis more difficult.|Run one of the above apps through ProGuard or other obfuscation tool and determine if the app vetting tool identifies the use of obfuscation.|Run one of the above apps through PPiOS-Rename or other obfuscation tool and determine if the app vetting tool identifies the use of obfuscation.|\n|4G / NIAP AVA_VAN. 1.2E|Assess ability to identify known malicious code (e.g., OS exploits) within the application.|Did the tool identify NowSecure VTS app’s tests for known device vulnerabilities as potential malicious code?|N/A|\n|4H / Ability to identify attempts by the app to obtain device administrator access|Assess ability to identify attempts by the application to obtain device administrator access.|Device Admin sample app: Did the tool report the app’s use of device administrator access?|N/A|\n|5A / Ability to resist attempts by malicious apps to determine that they are running in an analysis environment|Assess ability to resist attempts by malicious apps to determine that they’re running in an analysis environment.|UploadDataApp: Examine the data collected for potential indicators of an analysis environment (e.g., OS version numbers, names of installed apps, device serial number, IMEI, phone number, etc.)|AcmeAirlines: Examine the data collected by for potential indicators of an analysis environment (e.g., OS version numbers, names of installed apps,, etc.) Did the tool report jailbreak detection of the app? Optional: making sure the ptrace and syscall functions are not commented out, see if the app crashes or the analysis does not proceed as expected.|\n\n\n16\n\n\n-----\n\n|5B / Ability to refresh environment after each app is analyzed so that sensitive data is not exposed to other apps under analysis|Assess ability of app analysis service (particularly cloud- based services) to protect information about other customers and apps.|UploadDataApp: Examine the data collected for indications of other apps that were previously analyzed. Data to examine includes the list of other currently installed apps as well as the contents of the external storage directory (typically /sdcard).|AcmeAirlines: Examine the data collected for indications of other apps that were previously analyzed. Data to examine includes the list of other currently installed apps as any other data left on the device (contacts, pictures, etc.).|\n|---|---|---|---|\n|6A / Ability to determine the output formats available for reporting||Examine product and list the available output formats.|Examine product and list the available output formats.|\n|6B / Ability to provide evidence (e.g., network packet captures, system call traces, screenshots) that analysts can use to clarify or confirm reported information about apps|Ability to provide evidence (e.g., network packet captures, system call traces, screenshots) that can be used by analysts to gain context around reported issues, e.g., to confirm the accuracy reported results, or to determine if the reported results present true risks given the app’s intended purpose.|Examine the output of the app vetting tool to determine if this information is provided.|Examine the output of the app vetting tool to determine if this information is provided.|\n|6C / Ability to determine enterprise integration capabilities.|Determine ability to integrate with other enterprise security systems - in particular, EMM/MDM systems - to gather relevant data and to enforce security policies.|Examine product and detail what EMM/MDM systems it is capable of integrating with (or available interfaces/APIs that could be used by an enterprise to implement such integration) and the level of integration (e.g., ability to gather app inventory from the EMM/MDM, ability to enforce compliance with enterprise app policies and respond to application-based threats through integration with the EMM/MDM).|Examine product and detail what EMM/MDM systems it is capable of integrating with (or available interfaces/APIs that could be used by an enterprise to implement such integration) and the level of integration (e.g., ability to gather app inventory from the EMM/MDM, ability to enforce compliance with enterprise app policies and respond to application-based threats through integration with the EMM/MDM).|\n\n\n17\n\n\n-----\n\n|7A / Ability to unsanitized input (iOS)|Col2|N/A|Demonstrating unsanitized user input that could be used for SQL injection or XSS.|\n|---|---|---|---|\n|7B / Ability to code coverage (iOS)||N/A|Load calendar entries 7 days after app install to see if the tool can find timed exploits. (complete code coverage)|\n\n\n18\n\n\n-----\n\n## 4 Vulnerable and Potentially Malicious Test Apps\n\nOn the basis of the assessment criteria described above, the MITRE team developed or obtained\nseveral vulnerable and potentially malicious apps to use in assessing the ability of app vetting\nsolutions. The subsections below describe these apps with reference to requirements in section 3,\nand, when applicable, to corresponding NIAP Application PP requirements.\n\nThe results from testing these apps provide a basic, high-level baseline for assessing app vetting\nsolution capabilities to address the criteria. The apps selected do not exhibit every potential\nbehavior that violates the criteria and thus the results do not ensure the ability of app vetting\nsolutions to provide full code coverage. For example, vulnerable or malicious code could be\nhidden behind a login prompt or other user interface element or behind a deliberately inserted\ntime delay before execution, or could make use of emulator detection to evade analysis. The\ntools may or may not detect these and other kinds of evasion techniques.\n\nSome of these applications have been approved for public release at MITRE or were found on\nthe open web. A collection of these applications are being maintained publicly here:\nhttps://github.com/mitre/vulnerable-mobile-apps. The UploadDataApp and AcmeAirlines app\nare currently in the public release process and will be uploaded to this location once approved.\n\n### 4.1 Android Apps\n\n#### 4.1.1 UploadDataApp\n\nThis app demonstrates the following vulnerabilities:\n\n  - Access to device hardware resources (4A / NIAP FDP_DEC_EXT.1.1) and to sensitive\ninformation repositories on the device (4B / NIAP FDP_DEC_EXT.1.2)\n\n  - Insecure writing of sensitive app data to device storage (3C / NIAP FDP_DAR_EXT.1.1\nand FMT_CFG_EXT.1.2), and insecure network communication (3D / NIAP\nFDP_DIT_EXT.1.1, FIA_X509_EXT.1.1, FCS_TLSC_EXT.1.2, FCS_TLSC_EXT.1.3, 4C /\nFDP_NET_EXT.1.1)\n\n  - Inclusion of default credentials (3E / NIAP FMT_CFG_EXT.1.1) and insecure storage of\ncredentials (3B / NIAP FCS_STO_EXT.1.1\n\n  - Failure to invoke an appropriate random number generator where needed (3A / NIAP\nFCS_RBG_EXT.1.1) and other inappropriate cryptographic practices (3M)\n\n  - Use of an unsupported platform API (4E / NIAP FPT_API_EXT.1.1).\n\nAt app start time, the app demonstrates it has established access to device hardware resources by\nattempting to activate the device microphone for 5 seconds and sending the recorded audio to a\nremote server. The app additionally attempts to gather the device’s physical location (e.g.,\nthrough GPS) and send the location data to a remote server. The app always attempts to obtain\nShort Message Service (SMS) messages received by the device and send them to a remote\nserver.\n\nAt start time, the app uses Android APIs to attempt to gather information from the device’s\nsensitive information repositories and send the gathered information to a remote server via\nHTTPS (it can also be configured to use HTTP). This information includes:\n\n19\n\n\n-----\n\n  - Whether the Android Debug Bridge (USB debugging) is on or off\n\n  - Whether installation of non-Google Play Store apps is allowed or disallowed\n\n  - The device’s Android ID, IMSI, IMEI, phone number, and IP addresses\n\n  - Names of all apps installed on the device\n\n  - Contact list entries\n\n  - Call logs\n\n  - Names of all files stored in external storage\n\nWhen HTTPS is used, the app deliberately disables checking of the server’s certificate and\nhostname, thus enabling an attacker to easily perform a man-in-the-middle attack to intercept or\nmanipulate communication. The app also sends some data to the same server using HTTP. HTTP\nprovides no cryptographic protection over the network, so interception or manipulation of\ncommunication is even simpler.\n\nVarious gathered data is written to internal storage with deliberately insecure file permissions\n(deliberately set to world readable and writable) or written to external storage (where it can be\nread or written by other apps through USB debugging, or potentially through physical access to\nthe device SD card if applicable).\n\nThe app contains a broadcast receiver called SMSReceiver used to gather SMS messages\nreceived by the device. The Android OS broadcasts received SMS messages to all broadcast\nreceivers with an intent-filter for “android.provider.Telephony.SMS_RECEIVED.” To test the\nability of app vetting tools to detect this commonly found vulnerability, SMSReceiver\ndeliberately fails to verify the permission of the sender and fails to check that the received\nintent’s action string actually matches “android.provider.Telephony.SMS_RECEIVED.”\nTherefore, a malicious app could inject fake SMS messages into UploadDataApp that were not\nactually received by the device.\n\nStarting in Android 6.0, checking the intent’s action string is sufficient, as\n“android.provider.Telephony.SMS_RECEIVED” was added to the list of protected broadcast\naction strings that can only be sent by the Android OS, not by third-party apps. Prior to Android\n6.0, the app must ensure that the sender holds “android.permission.BROADCAST_SMS.”\nBecause apps are generally designed to run on a diverse array of Android versions, as a best\npractice any broadcast receiver for the SMS_RECEIVED action string should ensure the sender\nholds the BROADCAST_SMS permission.\n\nThe app contains a broadcast receiver called BootReceiver containing an intent-filter for the\n“android.intent.action.BOOT_COMPLETED” action string. A broadcast intent containing this\naction string is sent at device startup time. In order to test the ability of app vetting tools to detect\na commonly found vulnerability, BootReceiver deliberately fails to check that the received\nintent’s action string actually matches “android.intent.action.BOOT_COMPLETED.” Therefore,\na malicious app could inject an intent and trigger the BootReceiver service’s functionality.\n\nThe app additionally deliberately exports services (SendIntentService, LocationService, and\nRecordIntentService) that are meant for internal use only to test the ability of app vetting tools to\ndetect this issue. Exporting these services introduces a security vulnerability by enabling other\napps resident on the device to invoke the services directly.\n\n20\n\n\n-----\n\nThe app embeds in its code a default username and password used for HTTP Basic\nAuthentication to a remote server. The app also writes the username and password value in the\nclear to a file in the app’s internal data directory and to a file in the device’s external storage\ndirectory (/sdcard). Storing cleartext passwords on the device, even in the app’s internal data\ndirectory, is generally considered poor security practice.\n\nThe app embeds in its code a default AES [Advanced Encryption Standard] key used to encrypt\ngathered data (the data is stored locally and transmitted to the remote server both in unencrypted\nand encrypted form). The app does not follow cryptographic best practices for AES-CBC\n\n[Cipher Block Chaining] encryption: it uses a static initialization vector (also embedded in the\ncode) instead of a randomly generated initialization vector, and the ciphertext is not\nauthenticated (no Message Authentication Code (MAC) operation is applied to it).\n\nThe app demonstrates use of an unsupported platform API by using reflection to invoke the\ninternal method com.android.internal.telephony.GsmAlphabet.stringToGsm7BitPacked.\n\nThe app’s behavior is triggered automatically at app start time. For future work, as a more\nsophisticated test of the ability of vetting solutions to analyze app behavior, the app could be\nmodified to delay its behavior for a set period of time or until triggered by a specific user\ninteraction.\n\n#### 4.1.2 Custom-class-loader\n\nThis app would allow a malicious app to potentially bypass app vetting by downloading and\nexecuting new code after installation time (3J / NIAP FPT_AEX_EXT.1.4 and 4D / NIAP\nFPT_TUD_EXT.1.4). Because the new code is not included in the distributed application\npackage, it will not be found through static analysis, but could potentially be found through\ndynamic analysis. An analysis solution might not identify the specifics of the malicious behavior\nin this case, since an adversary could dynamically adapt and target the downloaded code, causing\ndifferent payloads to be delivered to different endpoints. An analysis solution should at least be\nable to detect that the app executes dynamic code downloaded after installation time and report\nthe potential for abuse.\n\nAt app start time, this app connects to a remote server, downloads code, and then dynamically\nexecutes the downloaded code, both Dalvik (e.g., compiled Java) code and native code. The\ndefault downloaded code included in the public-released version of this app is benign. However,\nthe MITRE team also prepared an alternate version of the downloaded code that includes much\nof the behavior described above in the UploadDataApp in order to perform a more advanced test\nof the ability of vetting solutions to analyze malicious app behavior. As described in section 4.1,\nUploadDataApp’s malicious behavior is embedded in the compiled Android app package (APK)\nitself, where it can be detected through static analysis. With custom-class-loader, the malicious\nbehavior can be downloaded from a remote server at runtime and not actually be in the app\npackage itself, making it far more difficult for an analysis solution to detect the actual malicious\nbehavior.\n\nThe app can be configured to download the code over either HTTP or HTTPS. When HTTPS is\nused, checking of the server’s certificate and hostname is disabled by default (3D / NIAP\nFIA_X509_EXT.1.1, FCS_TLSC_EXT.1.2, FCS_TLSC_EXT.1.3 and 4C / NIAP\nFDC_DEC_EXT.1.4). The downloaded code is stored insecurely with world readable and\nwritable file permissions by default, enabling malicious apps to overwrite the code (3C / NIAP\n\n21\n\n\n-----\n\nFDP_DAR_EXT.1.1) and also allowing the code to be overwritten via other vectors such as the\nAndroid Debug Bridge.\n\nThe app also includes native code in a library (liblocal_jni.so) bundled in the APK. The native\ncode maps memory at an explicit address (3F / NIAP FPT_AEX_EXT.1.1) with both write and\nexecute permissions (3G / NIAP FPT_AEX_EXT.1.2) to demonstrate violation of those two\nNIAP App PP requirements. The native code is compiled with stack protections deliberately\ndisabled using the –fno-stack-protector compiler flag (3K / NIAP FPT_AEX_EXT.1.5).\n\n#### 4.1.3 Device Administrator Sample App\n\nThis sample app, extracted from the ApiDemos sample code in the Android Software\nDevelopment Kit (SDK), demonstrates the use of Android’s device administrator APIs (4H / no\ndirectly relevant NIAP requirement). Upon obtaining device administrator access (which\nrequires user approval), apps can perform sensitive operations such as setting device security\npolicies or wiping all apps and data stored on the device. Malicious Android apps have abused\ndevice administrator access in the past; for example, Lookout describes a ransomware family of\napps called ScarePakage[8] and as previously described in section 3, Palo Alto Networks identified\na family of Android malicious apps called Xbot.\n\n#### 4.1.4 Android Vulnerability Test Suite \n\nThis open source app, developed by NowSecure, assesses an Android device’s susceptibility to\nvarious well-known public vulnerabilities. Although it technically does not perform malicious\noperations, it performs various system calls or other suspicious-looking operations based on\npublic exploits (4G / NIAP AVA_VAN.1.2E). Examples of vulnerabilities that Android VTS\nchecks for include:\n\n  - CVE-2011 1149 / PSNeuter / Ashmem Exploit\n\n  - CVE-2013-6282 / put/get_user\n\n  - CVE-2014-3153 / Futex bug / Towelroot\n\n  - Jar Bug 13678484 / Android FakeID\n\n  - Samsung WifiCredService remote code execution\n\n  - Stagefright bugs\n\n  - StumpRoot\n\n  - X.509 Serialization bug\n\n  - ZipBug 8219321 / Masterkey\n\n#### 4.1.5 Subterfuge App\n\nThe Subterfuge app is a commercially available game. Version 493 of the app contains the\nOpenSSL version number 1.0.1o which is susceptible to CVE-2015-1793. It is used to see if the\napp vetting solutions are capable of identifying third party library use and if so, whether or not\n\n8 https://blog.lookout.com/blog/2014/07/16/scarepakage/ (Accessed 20 January 2016.)\n\n22\n\n\n-----\n\nthey list known vulnerabilities. This app was downloaded from the Play Store in binary format\nwithout source code available.\n\n### 4.2 iOS App\n\n#### 4.2.1 Acme Airlines\n\nThis app demonstrates a multitude of vulnerable or potentially malicious activities that trace\nback to the evaluation criteria in section 3 (aligned with the NIAP App PP but including\nadditional criteria not found in the PP). The app is meant to look like an electronic flight bag.\nThis app demonstrates:\n\n  - Access to device hardware resources (4A / NIAP FDP_DEC_EXT.1.1) and to sensitive\ninformation repositories on the device (4B / NIAP FDP_DEC_EXT.1.2).\n\n  - Insecure writing of sensitive application data to device storage (3C / NIAP\nFDP_DAR_EXT.1.1 and FMT_CFG_EXT.1.2), and insecure network communication (3D /\nNIAP FDP_DIT_EXT.1.1, FIA_X509_EXT.1.1, FCS_TLSC_EXT.1.2,\nFCS_TLSC_EXT.1.3, 4C / FDP_NET_EXT.1.1).\n\n  - Inclusion of default credentials (3E / NIAP FMT_CFG_EXT.1.1) and insecure storage of\ncredentials (3B / NIAP FCS_STO_EXT.1.1).\n\n  - Failure to invoke an appropriate random number generator where needed (3A / NIAP\nFCS_RBG_EXT.1.1) and other inappropriate cryptographic practices (3M).\n\n  - Use of an unsupported platform API (4E / NIAP FPT_API_EXT.1.1).\n\n  - The ability for a malicious app to potentially bypass app vetting by downloading and\nexecuting new code after installation time (3J / NIAP FPT_AEX_EXT.1.4 and 4D / NIAP\nFPT_TUD_EXT.1.4).\n\nAt app start time, the app demonstrates it has established access to device hardware resources by\nattempting to activate the device microphone for 5 seconds and sending the recorded audio to a\nremote server. It also uses iOS APIs to attempt to gather information from sensitive information\nrepositories on the device and send the gathered information to a remote server via HTTPS (it\ncan also be configured to use HTTP). This information includes the names of all apps installed\non the device and contact list entries.\n\nThe app additionally attempts to gather the device’s physical location (e.g., via GPS) once the\nuser has clicked on a “Map” navigation menu and to send the location data to a remote server.\n\nWhen HTTPS is used, the app deliberately disables checking of the server’s certificate and\nhostname, thus enabling an attacker to easily perform a man-in-the-middle attack to intercept or\nmanipulate communication. The app also sends some data to the same server using HTTP. HTTP\nprovides no cryptographic protection over the network, so interception or manipulation of\ncommunication is even simpler. The app deliberately disables iOS App Transport Security so\nthat it can disable HTTPS server certificate checking and so that it can use plaintext HTTP.\n\nThe app writes various gathered data to internal storage with deliberately insecure file\npermissions written using NSFileProtectionNone. The app also demonstrates Uniform Resource\nIdentifier (URI) scheme hijacking by registering URI schemes used by the Google Chrome iOS\napp. This results in links from within Google apps to open in the AcmeAirlines app instead of\n\n23\n\n\n-----\n\nthe Chrome app, which could be used by a malicious app to request credentials from a user as\ndetailed in this article from FireEye.[9]\n\nThe app embeds in its code a default username and password used for HTTP Basic\nAuthentication to the remote server. The app also writes the username and password value in the\nclear to a file in the app’s internal data directory.\n\nLike the UploadDataApp, this app similarly embeds in its code a default AES key used to\nencrypt gathered data which does not follow cryptographic best practices.\n\nAs a more sophisticated test of the ability of vetting solutions to analyze app behavior, the app\nhas a time-bomb that is triggered to execute seven days after installation. The first time the user\nruns the app seven days after installation, it will gather calendar entries on the device and send\nthem to the remote server.\n\nThis app also demonstrates the ability for a malicious app to potentially bypass Apple’s app\nvetting via mobile code. The app utilizes a third party library called JSPatch to download a\nJavaScript “hot patch” file. The JavaScript is then converted to Objective-C code and executed\nusing “method swizzling”. Method swizzling exploits the ability to change a method’s execution\nat runtime and can be used to modify an app’s behavior dynamically. The app downloads a\nJavaScript hot patch file that injects use of the allApplications selector from the\nLSApplicationWorkspace class, a private API call, to obtain a list of apps installed on the\ndevice[10]. This demonstrates how a bad actor could use hot patching to introduce functionality\nthat the App Store may not catch[11].\n\nThe iOS app does not address the following evaluation criteria items. For the reasons described\nin Appendix A.2, MITRE recommends that the iOS tests for these requirements be removed\nfrom the NIAP PP.\n\n  - 3F / NIAP FPT_AEX_EXT.1.1 – Assess ability to identify mapping of memory at explicit\nlocations\n\n  - 3G / NIAP FPT_AEX_EXT.1.2 – Assess ability to identify mapping of memory as both\nwritable and executable.\n\n  - 3K / NIAP FPT_AEX_EXT.1.5 – Assess ability to identify code compiled without stackbased buffer overflow protection enabled.\n\n9 https://www.fireeye.com/blog/threat-research/2015/02/ios_masque_attackre.html\n10 http://www.andreas-kurtz.de/2014/09/malicious-apps-ios8.html\n11 https://www.fireeye.com/blog/threat-research/2016/01/hot_or_not_the_bene.html\n\n24\n\n\n-----\n\n## 5 Tool Evaluation \n\nMITRE conducted a market analysis of mobile app vetting tools and found 30 such commercial\nor open source offerings. The enclosed App Vetting Tools Market Analysis spreadsheet contains\nthe findings of the market analysis. Given the limited resources of time and funding, MITRE\nevaluated only those tools most likely to satisfy the largest number of identified criteria. As such,\nthe evaluation gave preference to tools that claimed conformance with the NIAP PP; the team\nalso looked to Gartner reports[1213] to select top performers.\n\n### 5.1 Vetting Tools Examined\n\nThe tools evaluated were Android Lint (Included in Android Studio and Android SDK) and 8\nother commercial products that have been anonymized due to non-disclosure agreements\nbetween MITRE and their respective companies. The products are identified by Product 1 – 8.\nAppendix C contains more information about Android Lint.\n\n### 5.2 Findings\n\nOverall, MITRE found that the best solutions generally employed a combination of static and\ndynamic analysis techniques. Static analysis techniques provide insights into the properties of the\napp and can detect many vulnerabilities, while dynamic analysis techniques reveal app behaviors\nthat only occur at runtime.\n\nSolution capabilities vary widely. Some solutions focus on traditional Java or other language\ncoding issues and have limited coverage of weaknesses specific to high-risk Android and iOS\nmobile apps. Other solutions have a strong focus on specific weaknesses that commonly occur in\nAndroid and iOS apps. Therefore, enterprises should carefully assess capabilities and choose the\nbest solution or solutions to meet their particular needs.\n\nSome solutions can identify both vulnerabilities and potentially malicious or privacy-violating\nbehaviors. However, in the solutions examined MITRE found that it would be trivial for a\nmalicious app to identify the presence of an analysis environment versus a typical mobile device\nbeing used by a real user, and to adapt its behavior accordingly to evade detection. Even the\nsolutions that use real mobile devices rather than emulators contain obvious indicators of an\nanalysis environment, such as the presence of the Xposed framework (Android) or the Cydia app\nstore (iOS) in the list of installed apps. Identifying vulnerabilities and identifying potentially\nmalicious behaviors represent different use cases, and robustly detecting malicious applications\nis very difficult.\n\n12 Gartner’s Application Security Testing Magic Quadrant 2015\n13 Gartner’s Critical Capabilities for Application Security Testing 2015 – Mobile App Testing\n\n25\n\n\n-----\n\nTable 3 shows a stoplight chart comparing the criteria satisfied, partially satisfied, and not\nsatisfied by the Android tools.\n\n26\n\n\n-----\n\n**Table 3. Android Test Results**\n\n27\n\n\n-----\n\nTable 4 shows the comparable results for iOS.\n\n\n28\n\n\n-----\n\n**Table 4. iOS Test Results**\n\nDuring the analysis, MITRE found that tools rarely supported the following criteria described in\nSection 3:\n\n  - 3A / NIAP FCS_RBG_EXT.1.1 – supported by only one tool\n\n  - 3E / NIAP FMT_CFG_EXT.1.1 – supported by only two tools\n\n  - 3F / NIAP FPT_AEX_EXT.1.1 – supported by no tools\n\n  - 3G / NIAP FPT_AEX_EXT.1.2 – supported by no tools\n\n  - 3K / NIAP FPT_AEX_EXT.1.5 – supported only partially by one tool\n\n  - 3M / crypto issues – supported by no tools\n\n29\n\n\n-----\n\n- 4G / NIAP AVA_VAN.1.2E – supported only partially by one tool\n\n- 4H / Android Device Admin access – supported by only one tool\n\n- 5A / Detection of analysis environment – supported only partially by one tool on iOS only\n\n- 7B / Code coverage (iOS) – supported by no tools\n\n30\n\n\n-----\n\n## 6 Future Work\n\nFor future work in identifying potentially malicious apps, MITRE would like to explore the\ncapabilities of mobile app intelligence services that focus on examining the metadata associated\nwith each app rather than (or in addition to) the app’s code or behavior itself. These services\ngenerally have access to data from the mainstream app stores as well as from a large set of realworld mobile devices. This appears as #2 in the criteria described in section 3, but the MITRE\nteam did not have time to thoroughly examine product capabilities. Based on MITRE’s brief\nanalysis of capabilities, the team believes these services could provide a strong indication of the\nlikely risk associated with each app. Potential data items analyzed by these solutions could\ninclude:\n\n  - Does this particular app (e.g., with the same hash or developer certificate) exist in the\nmainstream app stores or not? If it does, how popular is it (how many downloads, and what\nare the overall review scores)?\n\n  - How many apps exist from the same developer in mainstream app stores? How popular\nare they? Have security issues been identified in other apps from the same developer?\n\n  - Do other apps exist (either in the mainstream app stores or on other mobile devices) with\nthe same name as the app but signed by different developers?\n\nMITRE has also outlined recommendations to NIAP detailing changes to the PP that streamline\nthe process. These are listed in Appendix B. Enterprises may be able to utilize these\nrecommendations to tailor their app vetting process, reducing unneeded manual inspection of\napps.\n\n31\n\n\n-----\n\n## Appendix A Android Platform Mitigations\n\nThe Android OS includes built-in mitigations that address parts of the vulnerable and malicious\nbehavior described above. The subsections below describe some of the mitigations. MITRE\ncould expand this section for future work, and recommends adding a section describing Apple\niOS built-in mitigations, many of which are described in Apple’s iOS Security Guide[14].\n\n### A.1 Access to Hardware Resources and Sensitive Information\n Repositories (NIAP App PP FDP_DEC_EXT.1.1 and FDP_DEC_EXT.1.2)\n\nAndroid apps must request permission to access device hardware resources and sensitive\ninformation repositories. If the application does not have permission, the operating system does\nnot allow access. These permission requests are placed in the application’s AndroidManifest.xml\nfile, which can be easily inspected by an app analysis solution. Analysts should ensure that\npermission requests are consistent with the purpose of the application.\n\nOn Android 6.0 (Marshmallow) and above, if the app targets API level 23 or higher (the\ntargetSdkVersion field in the app’s AndroidManifest.xml file), the app must additionally\nexplicitly request each permission from the user at runtime the first time the permission is\nrequired. On Android 6.0 and above devices, regardless of the targeted API level, the device user\ncan selectively disable individual app permissions at any time. As devices migrate to Android 6.0\nand above and apps migrate to API level 23 and above, it will become more difficult for\nmalicious applications to obtain improper permissions. More information about Android’s\nruntime permission capabilities can be found at:\n\n  - Android Developers web site: Requesting Permissions at Runtime\n\n`o` https://developer.android.com/training/permissions/requesting.html\n\n  - What’s new in Android security (M and N Version) Google I/O 2016 video\n\n`o` https://www.youtube.com/watch?v=XZzLjllizYs\n\nFigure A-1 shows screenshot examples of Android’s runtime permissions system. The screenshot\non the left shows an app[15] requesting a permission from the device user at runtime. The\nscreenshot on the right shows the device user’s ability to selectively disable or enable individual\napp permissions through the device settings.\n\n14 https://www.apple.com/business/docs/iOS_Security_Guide.pdf\n15 Google’s RuntimePermissions sample application, available at https://github.com/googlesamples/android-RuntimePermissions\n(retrieved 14 June 2016)\n\nA 1\n\n\n-----\n\n**Figure A-1. Android's Runtime Permissions**\n\nWhen the Google Play Store is used to install applications on Android versions prior to 6.0, or\nfor applications that do not target API level 23 or higher, it presents users at install-time with a\nlist of requested permissions. The user must either accept all of the requested permissions or\ndecline installation of the app. Figure A-2 provides an example of a permission request displayed\nby the Google Play Store at app installation time:\n\nA 2\n\n\n-----\n\n**Figure A-2. Old Android Permissions**\n\nSamsung KNOX Workspace and Android for Work can provide additional mitigations against\nundesired access to sensitive information repositories. These apps can divide the device into\nseparate personal and work-managed areas. They can give the user liberal control over the apps\nthat can be installed in the personal area, while the enterprise can maintain full control over app\ninstallation in the work-managed area. Depending on configured policy, each area could, for\nexample, be given its own contact list and calendar, with no ability to view the data in the other\narea. A malicious app running in the personal area of the device could not view the contact list\nand calendar in the work-managed area of the device.\n\n### A.2 Sensitive Application Data / File Permissions (FDP_DAR_EXT.1.1 and\n FMT_CFG_EXT.1.2)\n\nEach Android app has its own internal storage directory that by default cannot be accessed by\nother apps. Android has deprecated the ability to set insecure (world readable or world writable)\nfile permissions on files in internal storage since Android 4.2 (released in October 2012).\nStarting in Android N Developer Preview 2,[16] the ability to set insecure file permissions through\nAndroid SDK calls is prohibited for apps targeting Android N or above (an exception is thrown\nif such an attempt is made), and the app’s internal storage directory is given UNIX file\npermission 700 by default, preventing other apps from accessing its contents regardless of the\npermissions of individual files. Vulnerable apps can override these secure behaviors, but\ndeliberate effort is required.\n\nAs part of a previous research effort,[17] MITRE recommended to the Android Open Source\nProject that it enhance Android’s SELinux policies to strictly prohibit apps from reading or\nwriting other apps’ internal data regardless of file permission. This recommendation has not been\naccepted, but the Android N Developer Preview 2 changes constitute an important step toward\npotentially enabling this stricter behavior in a future Android release. MITRE additionally\nstrengthened the static analysis rules in the Android Software Development Kit (SDK)’s lint\n\n16 http://developer.android.com/preview/behavior-changes.html#permfilesys\n17 Additional details can be found at https://www.mitre.org/sites/default/files/publications/pr-160202-android-security-analysis-final-report.pdf\n\nA 3\n\n\n-----\n\nchecker to help developers or security assessors detect inadvertent setting of insecure file\npermissions by apps.\n\nApplications can still write to external storage, so care must be taken not to write sensitive data\nthere.\n\nSamsung KNOX Workspace and Android for Work can provide additional mitigations against\ninsecure file storage. These apps can divide the device into separate personal and work-managed\nareas. They can give the user liberal control over the apps that can be installed in the personal\narea, while the enterprise can maintain full control over app installation in the work-managed\narea. Starting with Android 6.0 (and potentially earlier on Samsung KNOX devices), SELinux\nmandatory access controls prohibit apps running in one area from accessing data in the other\narea, regardless of file permissions. These controls apply to both internal and external storage, as\nthe personal and work-managed areas are each given its own storage directory.\n\n### A.3 Network Communication (FDP_NET_EXT.1.1) / Protecting Data in\n Transit\n\nAndroid’s built-in TLS implementation defaults to secure practices; certificates are properly\nvalidated and hostnames are properly checked. However, app developers can inadvertently or\ndeliberately override these practices and introduce vulnerabilities.\n\nAndroid 6.0 introduced the “usesCleartextTraffic” flag in the AndroidManifest.xml file. It\ncurrently defaults to true. The app developer can explicitly set it to false if the app is not\nexpected to use any cleartext network protocols; the OS then makes a best effort to only allow\nuse of encrypted protocols such as TLS / HTTPS. However, as a best effort mechanism, this is\nnot foolproof, and is only enforced if a TLS / HTTPS implementation that explicitly checks the\nflag is used (such as the Android OS built-in APIs). The Android N Developer Preview takes this\ncapability further with the new Network Security Configuration feature[18] that enables apps to\ndeclare other data-in-transit security attributes; for example, to enable certificate pinning without\nthe need for the app developer to write custom error-prone TLS certificate validation code. More\ndetails can be found in a post at the Android Developers Blog[19] and in the “What’s new in\nAndroid security (M and N Version)” presentation at Google I/O 2016.[20]\n\n18 http://developer.android.com/preview/features/security-config.html\n19 https://android-developers.blogspot.com/2016/04/protecting-against-unintentional.html\n20 https://www.youtube.com/watch?v=XZzLjllizYs\n\nA 4\n\n\n-----\n\n## Appendix B NIAP Protection Profile Recommendations\n\nThis appendix details areas where the NIAP Protection Profile for Application Software\nrequirements could potentially be streamlined to better enable automation.\n\nFPT_TUD_EXT.1.3: Assess ability to determine that all traces of the application have been\ndeleted after uninstall.\n\nMITRE recommends removing this test for iOS apps. On iOS, this test may be impractical to\nperform, as it is not possible to search the entire filesystem without a jailbroken device.\nAdditionally, the test appears unnecessary on iOS, as the operating system should automatically\nremove the app’s data when the app is uninstalled.\n\nMITRE recommends skipping this test for any Android app that does not hold the\nWRITE_EXTERNAL_STORAGE permission. On Android, when an app is uninstalled, the\noperating system automatically deletes the app’s internal storage directory as well as the app’s\ndirectory on external storage, as described at\nhttp://developer.android.com/guide/topics/data/data-storage.html under the “Saving files that are\napp-private” section. The only other location to which apps are allowed to write is the general\nexternal storage (the /sdcard directory or its equivalent), and apps are only allowed to write there\nif they hold the WRITE_EXTERNAL_STORAGE permission.\n\nProposed Android text:\n\nFor Android, if the application’s AndroidManifest.xml file does not contain a <uses-permission>\nor <uses-permission-sdk-23> tag containing\nandroid:name=“android.permission.WRITE_EXTERNAL_STORAGE”, then it is not necessary\nto perform any tests for this requirement. If the AndroidManifest.xml does contain such a tag,\nthen the filesystem search can be limited to the device’s external storage directories.\n\nFPT_AEX_EXT.1.1: Assess ability to identify mapping of memory at explicit locations\n\nMITRE recommends removing this test from the NIAP App PP’s iOS Assurance Activity, as this\nvulnerability is unlikely to occur in an exploitable manner in iOS applications due to the\nprotections against placing executable code in heap memory, as described in the next item.\n\nFPT_AEX_EXT.1.2: Assess ability to identify mapping of memory as both writable and\nexecutable.\n\nMITRE recommends removing this test from the NIAP App PP’s iOS Assurance Activity, as this\nvulnerability is unlikely to occur in iOS applications due to protections in the iOS security\narchitecture. As described on page 20 of the May 2016 version of the iOS Security Guide,[21]\n“[m]emory pages marked as both writable and executable can only be used by apps under tightly\ncontrolled restrictions: The kernel checks for the presence of the Apple-only dynamic codesigning entitlement. Even then, only a single mmap call can be made to request an executable\nand writable page, which is given a randomized address. Safari uses this functionality for its\nJavaScript JIT compiler.”\n\nFPT_AEX_EXT.1.5: Assess ability to identify code compiled without stack-based buffer\noverflow protection enabled.\n\n21 https://www.apple.com/business/docs/iOS_Security_Guide.pdf (retrieved June 13, 2016)\n\nB 1\n\n\n-----\n\nMITRE recommends removing this test from the NIAP App PP’s iOS Assurance Activity.\nXcode, the development environment used by iOS app developers, compiles code with stack\nprotection enabled by default. In MITRE’s experimentations, the team could not find a way to\ndisable stack protection in Xcode.\n\nB 2\n\n\n-----\n\n## Appendix C Tool Assessments\n\n### C.1 Android Lint\n\nAndroid Lint is a free, open source tool primarily written by Google, and integrated into the SDK\nand Android Studio IDE. Given this integration into these environments commonly used by\nAndroid app developers, Android Lint enables app developers to easily find and correct issues\nearly in the app development lifecycle.\n\nAndroid Lint performs static analysis of apps (primarily Java source, Java bytecode, the\nAndroidManifest.xml, and app resource XML files) in search of both security-related and nonsecurity-related issues. MITRE contributed several new security checks to the tool as part of a\nFiscal Year 2015 research effort, described further in a separate publicly released technical\nreport.[22]\n\nAndroid Lint satisfied eight of the criteria in section 3 fully and one partially.\n\nFigure C-1 shows Android Lint’s integration into Android Studio. In the screenshot, Android\nLint identified an issue in the app’s TrustManager class that makes the app’s network\ncommunication susceptible to attack. The screenshot does not show the full reported details.\n\n**Figure C-1. Android Lint Screenshot**\n\n22 https://www.mitre.org/sites/default/files/publications/pr-16-0202-android-security-analysis-final-report.pdf\n\nC 1\n\n\n-----\n\n## Appendix D Acronyms\n\nAPI Application Programming Interface\n\nAPK Android app package\n\nCVE Common Vulnerabilities and Exposures\n\nDHS Department of Homeland Security\n\nDISA Defense Information Systems Agency\n\nEMM Enterprise Mobile Management\n\nFEDRAMP Federal Risk Authorization Management Program\n\nGPS Global Positioning System\n\nHTTP Hypertext Transfer Protocol\n\nHTTPS Hypertext Transfer Protocol Secure\n\nMDM Mobile Device Management\n\nMIT Massachusetts Institute of Technology\n\nNIAP National Information Assurance Partnership\n\nPP Protection Profile\n\nSDK Software Development Kit\n\nSMS Short Message Service\n\nTLS Transport Layer Security\n\nUI User Interface\n\nURI Uniform Resource Identifier\n\nD 1\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://www.mitre.org/sites/default/files/publications/pr-16-4772-analyzing-effectiveness-mobile-app-vetting-tools-report.pdf"
    ],
    "report_names": [
        "pr-16-4772-analyzing-effectiveness-mobile-app-vetting-tools-report.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1667959443,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1521045952,
    "ts_modification_date": 1521045952,
    "files": {
        "pdf": "https://archive.orkl.eu/e9c68ab39b06777eebbd0966f1ff98401b8e2819.pdf",
        "text": "https://archive.orkl.eu/e9c68ab39b06777eebbd0966f1ff98401b8e2819.txt",
        "img": "https://archive.orkl.eu/e9c68ab39b06777eebbd0966f1ff98401b8e2819.jpg"
    }
}