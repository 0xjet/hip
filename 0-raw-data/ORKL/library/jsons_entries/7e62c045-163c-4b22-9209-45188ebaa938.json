{
    "id": "7e62c045-163c-4b22-9209-45188ebaa938",
    "created_at": "2023-01-12T15:03:14.318361Z",
    "updated_at": "2025-03-27T02:06:13.515895Z",
    "deleted_at": null,
    "sha1_hash": "87fcd32c41a7ffa163322b2336b571378969783d",
    "title": "2016-04-28 - Research Spotlight- The Resurgence of Qbot",
    "authors": "",
    "file_creation_date": "2022-05-27T21:09:58Z",
    "file_modification_date": "2022-05-27T21:09:58Z",
    "file_size": 733666,
    "plain_text": "# Research Spotlight: The Resurgence of Qbot\n\n**[blog.talosintelligence.com/2016/04/qbot-on-the-rise.html](https://blog.talosintelligence.com/2016/04/qbot-on-the-rise.html)**\n\n_[The post was authored by Ben Baker.](https://blogs.cisco.com/author/benbaker)_\n\nQbot, AKA Qakbot, has been around for since at least 2008, but it recently experienced a\nlarge surge in development and deployments. Qbot primarily targets sensitive information\nlike banking credentials. Here we are unveiling recent changes to the malware that haven’t\nbeen made public yet.\n\nQbot’s primary means of infection is as a payload in browser exploit kits. Website\nadministrators often use FTP to access their servers, so Qbot attempts to steal FTP\ncredentials to add these servers to its malware hosting infrastructure. Qbot can also spread\nacross a network using SMB, which makes it very difficult to remove from an unprotected\nnetwork.\n\n## Packer\n\nQbot uses a packer that can change drastically between samples. The packer’s strings and\ncode blocks are randomized in ways that make it difficult to create a detection signature.\nRandomization is a common theme in Qbot since filenames, domain names, and encryption\nkeys are randomly generated.\n\n\n-----\n\nThankfully, the code obfuscation doesn’t complicate the behavior of the packer’s code. The\nunpacking code consistently built an entire PE file in memory (likely an MD5 match with the\noriginal unpacked executable), then used a custom loader to execute the unpacked file. The\nunpacked executable could be reliably extracted from memory when the loader called the\nWindows API VirtualProtect. Since the unpacking code uses VirtualProtect to enable\nexecution for the unpacked memory sections, it is possible to dump the unpacked code\nbefore it is given a chance to execute and infect the VM.\n\n[We took advantage of the packer’s predictability by using a Pykd script to debug each](https://pypi.python.org/pypi/pykd)\npacked file. We set a breakpoint on VirtualProtect, then scan the process’s memory to dump\nthe unpacked executable. We terminate the process before the unpacked code runs, so the\nVM shouldn’t need to be reverted between samples. This script unpacks multiple samples\nper second, enabling us to unpack large numbers of samples.\n\nWe analyzed 618 packed samples, which unpacked to 73 unique samples. Each sample is\npacked multiple different ways to make hash signatures less effective.\n\n## Installation\n\nOnce the packer finishes loading the unpacked executable in memory, Qbot checks to see if\nit has already been installed. If Qbot is not running from “%appdata%\\Microsoft\\\n\n[RandomName]\\ [RandomName].exe”, it copies itself there and executes the copy.\n\nQbot generates random strings by seeding a Mersenne Twister random number generator\nwith the CRC32 checksum of a string or SHA1 hash, then repeatedly generating random\nintegers to use as indices in an alphabet array to pick letters. The name of the install folder is\ngenerated using a seed generated from the ProductId (found in\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProductId),\nthe name of the computer (found via the Windows API GetComputerNameA), and the hard\ndrive serial number (found via the Windows API GetVolumeInformationA).\n\nQbot uses a deterministic string generator which makes it so the sample will always generate\nthe same filenames and mutexes if it’s run on the same computer. For example, if a sandbox\nuses static Product ID, Computer Name, and Volume serial numbers, the filenames will\nappear static even though they would be different for any other computer. This makes it\ndifficult to create generic IOCs for customers, but easy to create sandbox IOCs for identifying\nQbot.\n\nOnce Qbot is executed in its install directory, it executes a new instance of the Windows\nexecutable “Explorer.exe”. The injected process loads the resource “IDB_BITMAP1” which\ncontains a malicious DLL. The resource is decrypted using the first 20 bytes as an RC4 key.\n\n\n-----\n\nThe decrypted data contains the DLL in a compressed form, preceded by the SHA1 hash of\nthe compressed data.\n\n[The compression appears to be custom, but is similar to LZSS with offset-length pairs](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Storer%E2%80%93Szymanski)\npointing to bytes in the existing decompressed data as a dictionary. Files are broken into\ncompressed blocks, each starting with a 24 byte header in the form of:\n\nMagic Bytes[8]: “\\x61\\x6C\\xD3\\x1A\\x00\\x00\\x00\\x01”\nCompressed Data Size[4]\nCompressed Data CRC32[4]\nDecompressed Data Size[4]\nDecompressed Data CRC32[4]\n\nThe DLL is broken into 3 compressed blocks, which means Qbot checks 6 CRC32\nchecksums along with the SHA1 hash from when it was first decrypted. That’s a lot of error\nchecking just to load one DLL.\n\n### Logging\n\nQbot logs to an encrypted file in the install path. The log file can be identified as having a\nDLL extension, and a filename one letter short of the directory name where Qbot is installed\nin. For example, if Qbot is installed in “%appdata%\\Microsoft\\Oykyjxjx”, the log file will be\n“%appdata%\\Microsoft\\oykyjxjx\\oykyjxj.dll”. The log file is encrypted with an RC4 key\ngenerated by converting the folder name to lowercase, then taking the SHA1 hash of the\nresulting string.\n\n[We’ve created a short Python script for decrypting the log file so incident responders can get](https://blogs.cisco.com/wp-content/uploads/decryptLog.py_-1.txt)\nadditional information about infections. This will print out configuration information including\ninitial infection time and FTP exfil server information.\n\n\n-----\n\n### Updater\n\nQbot updates itself using an obfuscated script with the extension “.wpl”. This script attempts\nto download an encrypted executable hosted from numerous domains in URIs like\n\"http[:]//<maliciousdomain.com>/viewtopic.php\". The script hex decodes the server\nresponse, then uses the first 20 bytes as an RC4 key to decrypt the remaining bytes. The\ndecrypted buffer contains a 20-byte SHA1 hash, followed by the updated version of the Qbot\nexecutable.\n\n\n-----\n\n## Info Theft\n\nQbot primarily targets sensitive information like banking credentials. It does so by stealing\ndata like stored cookies or credentials, and by injecting code into web browsers to\nmanipulate live browsing sessions. Qbot lets malicious actors piggyback on the victim’s\nbrowsing sessions, enabling them to bypass security like simple implementations of twofactor authentication.\n\nQbot recently added Webinjects to its arsenal of info stealing techniques. Webinjects,\ncommonly associated with Zeus and Spyeye, make it easy to inject malicious javascript in\nbrowser sessions while logging or redirecting the victim’s activity. Webinjects can be very\npowerful, in some cases automating large banking transactions without any interaction from\nthe user.\n\n\n-----\n\nQbot contains code for parsing advanced Webinjects like automated transfers, but all 618\nQbot samples we analyzed simply redirected the browsers when the victim attempts to\nlogout of an online banking page. Stolen cookies and session tokens remain active for much\nlonger if the victim is unable to logout of the targeted sites.\n\nSample Qbot Webinject config:\n“set_url https://*.<BankDomain>.com/*logoff* GPR\nhttp://<MaliciousSite>/fakes/onlineserv_cm_logoff.html”\n\nIn this example of a Webinject, any hooked browser attempting to navigate to the logoff page\nfor the targeted bank would be intercepted. The “GPR” flags indicate GETs and POSTs will\nbe intercepted and Redirected to the malicious URL. This R flag seems to be rarely used by\nother malware that support Webinjects. Malware forum posts about Webinjects focus mainly\non injecting malicious code or simply logging HTTPS parameters like credentials.\n\n## Command and Control\n\n### FTP Exfil\n\nQbot exfiltrates data over FTP to a list of servers hardcoded in its config file. The exfil files\nare compressed, then RC4 encrypted with a randomly generated key, similar to how\nresources are encrypted inside the executables. I’m intentionally leaving out how to decrypt\nthese files, since disclosing that info could enable anyone to retrieve sensitive information\nstolen by Qbot.\n\nThe exfil files are uploaded to the FTP servers with file names like\n“article_covezh618946_1450458170.zip” where “article” is hard coded, “covezh618946” is\nrandomly generated, and 1450458170 is seconds since Linux Epoch (Dec 18, 2015 in this\ncase).\n\nThe decrypted exfil file contains a lot of information about the victim’s machine, a chunk of\nwhich is formed with a call to the function wvnsprintf using the format string:\n\n\n-----\n\next_ip=[%s] dnsname=[%s] hostname=[%s] user=[%s] domain=[%s] is_admin=[%s] os=\n\n[%s] qbot_version=[%s] install_time= %s] exe=[%s]\"\n\nThe qbot_version string is generated by a previous call to wvnsprintf using the format string\n\"%04x.%u\" with parameters that trace back to the first 2 DWORDs in the data section.\nExtracting these DWORDs directly proved to be an easy and consistent way to extract\nQbot’s version information without running the malware.\n\n### HTTP DGA\n\nQbot's DGA generates a string like \"2.mar.2016.00000001\" where 00000001 is constant and\nthe first digit is the tens digit of the day of the month (though 2 is also used for days 30 and\n31). This means there are only 3 DGA seeds for each month. Qbot gets the date by sending\nan innocent looking HTTP request to Google, and parsing the date from the HTTP 301\nresponse.\n\nThe date string is CRC32 checksummed and used as a seed for the Mersenne Twister\nrandom number generator, which Qbot uses to create a predictable list of domains. Qbot\ngenerates a list of 5 domains at a time, and randomly picks from them until it finds an active\ndomain. If none of the first set of domains are active, it will generate a new set and repeat as\nnecessary.\n\nQbot checks DNS responses for any strings containing \"sinkhole\" or \".csof.net\" and skips\nthose results. It also checks for monitoring tools like Wireshark, and will alter the seed if any\nare found. The altered seed causes the malware to generate a fake list of domains.\n\n## Evolution\n\nWe automated unpacking 618 Qbot samples via Pykd, then created Python scripts to decrypt\nand decompress the embedded resources. We extracted DLLs and config data, as well as\nQbot version information and Compile Times for each file. Compile times are often used to\nattribute malicious activity, though it is important to note compile times can be manipulated.\n\n\n-----\n\nQbot compile times show a surge of activity in January and February, when developers\nreleased multiple versions per day on at least 4 days during this period. Qbot’s authors\nappear to have stopped development on 3/08/2016, although their servers continued to host\nQbot executables packed as late as 3/25/2016.\n\n\n-----\n\nThis graph shows 132 unique compile timestamps showing time of day for each binary. The\nunpacked binaries all have compile times between 6am and 8pm GMT. This time distribution\nlooks more like a full-time job than a side project. The packed binaries have compile times\nwith a lot more variance, suggesting the packing is either done by another person with a\nmuch more flexible schedule or with the assistance of some kind of automation. Developing\nsource code requires a lot more experience than running a packing tool, so packing could be\ndone by less technically skilled members of the team.\n\nThe packed compile times mostly fall between 8am and 10pm GMT, 2 hours shifted from the\naverage work day for the unpacked samples. If the packing process was completely\nautomated, we would expect to see these compile times distributed more randomly (with\nsome binaries compiled between midnight and 6am) or with a predictable schedule such as\nonce a day at a specific time.\n\n55% of packed binaries have compile timestamps within the range of 2h3m and 2h6m after\ntheir unpacked counterparts. This consistency of time shift may mean these files were\npacked according to a very consistent process that takes just over 2 hours, or that the\ncomputer doing the packing could have its system clock off by 2 hours.\n\nThis graph shows the day of the week using offsets from Sunday (e.g. 1 = Monday, 2 =\nTuesday, etc.). The compile times for the unpacked binaries form a nice Monday-Friday work\n\n\n-----\n\nweek. Over this 17 week period, only one set of binaries was compiled during a weekend.\n\nThe packed binaries continue to show a much greater variance in compile times, with\nbinaries compiled on 6 Saturdays in a row. There is at least one packed binary compiled per\nday between Jan 27 and Feb 6, showing work on 11 consecutive days.\n\nWe also analyzed the Rich Headers associated with Qbot binaries. Rich Headers are\nundocumented sections in Visual Studio executables that contain information about the\ncompiler and linker version used to build the executable. Rich Headers can vary greatly\nbetween two seemingly identical development environments, so they may give clues into\nhow many computers are used in a development project.\n\nThe 154 unpacked binaries contained only 6 unique Rich Headers in, some of which were\nalmost identical and were likely caused by minor compiler updates on the same computer.\nThese headers suggest the unpacked binaries were compiled in 3 unique environments\n(likely different computers or Virtual Machines). The packed binaries contained 44 unique\nRich Headers, 35 of which seemed to be slight variants of the others. The packed binaries\nappear to be compiled from 9 unique environments, none of which matched the 3 Rich\nHeaders from the unpacked binaries.\n\nThe differences in these Rich Headers further supports the theory that packing is done on\ndifferent computers than the ones that develop and compile the main Qbot source code. The\nRich Header data suggests there are 12 unique environments for compiling and packing\nbinaries, which could give a hint to the size of the team developing and packing Qbot.\n\nDeveloping and maintaining malware and a malicious infrastructure requires a lot of time and\neffort. The malicious actors behind large scale crimeware like Qbot work as a team, and\napproach their nefarious activities as a full time job.\n\n## Coverage\n\nFor the most current rule information, please refer to your Defense Center, FireSIGHT\nManagement Center or Snort.org.\n\n\n-----\n\n[Advanced Malware Protection (AMP) is ideally suited to prevent the execution of the](https://www.cisco.com/c/en/us/support/security/amp-firepower-software-license/tsd-products-support-series-home.html)\nmalware used by these threat actors.\n\n[CWS or](https://www.cisco.com/c/en/us/products/security/cloud-web-security/index.html) [WSA web scanning prevents access to malicious websites and detects malware](https://www.cisco.com/c/en/us/products/security/web-security-appliance/index.html)\nused in these attacks.\n\n[The Network Security protection of IPS and](https://www.cisco.com/c/en/us/products/security/intrusion-prevention-system-ips/index.html) [NGFW have up-to-date signatures to detect](https://www.cisco.com/c/en/us/products/security/asa-next-generation-firewall-services/index.html)\nmalicious network activity by threat actors.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-04-28 - Research Spotlight- The Resurgence of Qbot.pdf"
    ],
    "report_names": [
        "2016-04-28 - Research Spotlight- The Resurgence of Qbot.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535794,
    "ts_updated_at": 1743041173,
    "ts_creation_date": 1653685798,
    "ts_modification_date": 1653685798,
    "files": {
        "pdf": "https://archive.orkl.eu/87fcd32c41a7ffa163322b2336b571378969783d.pdf",
        "text": "https://archive.orkl.eu/87fcd32c41a7ffa163322b2336b571378969783d.txt",
        "img": "https://archive.orkl.eu/87fcd32c41a7ffa163322b2336b571378969783d.jpg"
    }
}