{
    "id": "585da8eb-5058-4ce5-a50b-3a3d370a9071",
    "created_at": "2023-01-12T15:03:06.075349Z",
    "updated_at": "2025-03-27T02:05:40.745294Z",
    "deleted_at": null,
    "sha1_hash": "7799e6872e003521e072ef9f0cf1cbbe6757dc76",
    "title": "2018-11-05 - Data Talks- Deeper Down the Rabbit Hole- Second-Stage Attack and a Fileless Finale",
    "authors": "",
    "file_creation_date": "2022-05-28T21:36:04Z",
    "file_modification_date": "2022-05-28T21:36:04Z",
    "file_size": 1049582,
    "plain_text": "# Recent Posts\n\n**bromium.com/second-stage-attack-analysis/**\n\nNovember 5, 2018\n\n[HP Threat Research Blog • Data Talks: Deeper Down the Rabbit Hole: Second-Stage Attack](https://www.bromium.com/blog/)\nand a Fileless Finale\n\n## Data Talks: Deeper Down the Rabbit Hole: Second-Stage Attack and a Fileless Finale\n\n[In our last blog, “Following a Trail of Confusion: PowerShell in Malicious Office Documents”,](https://www.bromium.com/powershell-malicious-office-documents/)\nwe systematically unraveled multiple layers of obfuscation initiated by a weaponized firststage Microsoft Word document to reveal a surreptitious download script and a malicious\nsecond-stage binary file dropped onto the victim PC. For those who wish to follow the\nanalysis through to its conclusion, the sample MD5 is 6c8e800f14f927de051a3788083635e5\nand a VirusTotal report is [here.](https://www.virustotal.com/#/file/ee32c4e0a4b345029d8b0f5c6534fa9fc41e795cc937d3f3fd743dcb0a1cea35/detection)\n\n## Picking Up Where Word Drops Off\n\nSuppose the weaponized Word document was successful, bypassing all existing layered\ndefenses, and now the next stage begins. This is the native code program that is now\nrunning in memory, and with it come additional capabilities to compromise the host computer.\nAs with our previous analysis, we have to figure out what type of code obfuscation we’re\ndealing with it. With native code programs—portable executable (PE) files in the case of\nMicrosoft Windows—the first layer is usually packing. Packing is a well-known technique that\n\n\n-----\n\nessentially takes the malicious program and wraps it inside another program. You can think\nof it like a zip or another archive, where if we analyze the zip file, we won’t get any\ninformation about the content it contains.\n\n_Bromium Secure Platform shows the original malicious document, the request to retrieve this_\n_sample, and the process it invoked._\n\n## Signs of Packing\n\nBefore jumping right into IDA Pro and tackling the disassembly, it’s often worthwhile to\nperform initial static analysis of the PE file to get some ideas on packing and other potential\ncode obfuscation techniques. PE parsing utilities can be valuable for getting an initial look at\nthe characteristics of the file. Strings are a good first indicator, and the presence or lack of\nstrings can provide critical insight into the program. Strings are an important part of any\nprogram as they are routinely needed for such functionality as making HTTP requests,\nwriting files to disk, looking for processes, and creating files in the file system. Malware\nauthors will often attempt to obfuscate these strings, and an added benefit of packing is that\nthe strings are compressed and encrypted inside, obscuring their discovery. This sample\npresents some strings, but most of these come from the functions that it is importing. Outside\nof that, there are no further indicators such as command and control (C2) URLs or IPs,\nindications of file or process activity, or evidence of intended behavior such as a ransom\nnote.\n\n\n-----\n\n_Sample of strings output using strings utility_\n\nSections of the PE file are also worth investigating. Sections provide structure to the PE file\nfor such items as the executable code and hard-coded data. In addition, they may provide\nevidence of malware that is packed. There are usually two strong indicators: the name of the\nsection and the entropy of the section. Section names are arbitrary, but some packers use\nconsistent naming and allow for easier detection. Entropy is a measure of the randomness in\na sequence of bytes, which make up the content of the sections. This is usually measured on\na scale from zero to eight, with eight being the highest measure of entropy. Programs that\ncontain sections with high entropy are more suspect for packing and other obfuscation\ntechniques, since this garbled code tends to be more random and less deliberate.\n\n_Dumpbin output of PE file sections_\n\nWhile there are other indicators to consider, it appears this program is packed and will\nrequire deeper investigation.\n\n## PACKING ANALYSIS AND CODE OBFUSCATION\n\nNow we can turn to IDA Pro to start analyzing the code of this program. Upon loading the\nfile, IDA provides further indications that the sample is packed.\n\n\n-----\n\n_IDA Pro dialog indicating potential packing_\n\nThis program begins with a lot of instructions, most of them unnecessary. One way to try to\nfilter through this code is to see how the registers, variables, and functions are being used. In\nthis first code block, there are several function calls where the return value (in EAX) is being\nused in a compare/conditional jump combination. The conditional jump goes to loc_407257.\n\nIf we navigate to that location, we end up in an infinite loop. This is helpful, as we can now\nstart to visually filter out this noise and attempt to find the true purpose of this code. Since we\nsuspect that we are looking at purely packing code, we don’t want to spend a lot of time\nanalyzing how this code works but find the point at which it’s done. This will allow us to focus\non whatever is unpacked. With unpacking code, I’ve often found that you can concentrate on\nthe end of the functions and look for abnormal returns or control transfers. This function ends\nwith a function call, which is far from a normal epilogue.\n\nTracing into function sub_407027, we can investigate the code at the end. It appears there\nare two possible paths for it to go, both with unconventional methods of going there.\n\n\n-----\n\nThis function uses a technique of pushing a DWORD value onto the stack and then jumping\nto ESP. What is pushed onto the stack is actually an address: 0x4071B1. This technique has\nactually prevented IDA from identifying the correct location and continuing with disassembly.\nIf we go to that location manually, however, we can tell IDA to disassemble this code.\n\n_Unanalyzed JMP target_\n\n_Disassembled location 0x4071B1_\n\nOnce the data at this location is disassembled, we reveal a call instruction with a call target\nof dword_40A34C. The value of this DWORD is not hard-coded, which means it is populated\nduring runtime. Instead of continuing with static-analysis, we can now turn to WinDbg for\ndynamic analysis to see where this call goes.\n\n## Switching to Dynamic Analysis\n\nSetting a breakpoint on that call instruction reveals that the call target is to location\n_0x4071c4._\n\n\n-----\n\nSince IDA was unable to find this location during static analysis, it initially shows up as data\ninstead of instructions.\n\nInvoking IDA’s analysis reveals the disassembled instructions:\n\nIt’s easy to get lost in the assembly here and important to keep the big picture in mind. This\ncode is all likely unpacking code, so let’s analyze it a little further down to see how it ends.\nThere is a strange indirect call to ESI at 0x407244.\n\n\n-----\n\nIf we continue execution to this point, we can see where it intends to lead. In this case, it’s to\nan address not in the original image – 0x57000 for this run. This address will change, as it’s\na region of read-write-execute memory that is allocated during runtime.\n\nThis tells us that the previous code was responsible for not only allocating this memory, but\nalso for staging shellcode for execution. Using a tool like Process Hacker, we can extract this\nshellcode from memory and disassemble it.\n\n## Tracing the Shellcode\n\nFortunately, we know the entry point is at the beginning of the binary content from our\ndynamic analysis. Once this shellcode is disassembled, there will be a considerable amount\nof code to analyze. Let’s stick with the same approach we used to get here in the first place\nand analyze instructions toward the end of the shellcode. This shellcode ends with a\nPUSH/RET technique. The location the author wants to return to is pushed on the stack just\nbefore the return instruction.\n\n\n-----\n\nThis goes further into the shellcode. However, if we trace to the end of this code, there is a\n_jmp esi. ESI contains an address of 0x406FC0. This is a good sign, as it is taking execution_\nback to an address in the original address space of the program. But is it the same code? By\ncomparing the original data at the location to what is now in memory, a different result means\nthat unpacking could be complete.\n\nOriginal:\n\nIn memory:\n\n## The Plot Thickens\n\nUnfortunately, the malware is not yet ready to reveal what it is up to. Prior to performing a\ndeep technical analysis, automated dynamic analysis was used to understand as much of\nthis program’s behavior as possible. This malware makes a request to hxxps://real-estate_advisors[.win] and starts another process. This is likely the point at which the malware_\nreceives code for its true intended purpose. However, if we let the program run from this\npoint, the request isn’t made and no additional processes are created. Not only do we now\nknow that it’s not done unpacking/deobfuscating, it is also exhibiting anti-analysis techniques\nnot observed in our manual sandbox environment.\n\n\n-----\n\nLooking at the cross-reference graph from sub_406FC0, there is a considerable amount of\ncode. How do we overcome this mess? One method is to start by setting breakpoints on\nexpected. For example, CreateProcessA or InternetOpenURLA. Letting this code run ends in\na call to TerminateProcess, and in this case none of these breakpoints were hit. This could\nindicate a few things, including anti-analysis techniques. Instead of trying to analyze this\nfunction from the top-down, focusing on the call instructions towards the end of the function\nmay speed up analysis. Especially if this involves more unpacking, then the earlier function\ncalls will likely be for memory allocation and more unpacking, and the later function calls for\nexecuting the unpacked code. This function ends with three function calls and after\ninspecting them, the call to sub_5200 appears to be the most promising.\n\nAgain, we’re faced with a significant amount of code and a limited amount of time for\nanalysis, so let’s focus on the end of the function. Toward the end of this function is another\nindirect function call. These are usually interesting as they may indicate a dynamicallygenerated address.\n\n_Indirect function call at offset 0x5D65_\n\nAs it turns out, this is the call to ExitProcess, so somewhere before this call is not only any\nanti-analysis, but also the next stage of functionality.\n\nAfter spending some time analyzing this function, another promising location presents itself:\n\n\n-----\n\n_Call instruction to offset 0x51B0 at location 0x5C00_\n\nThis function is limited in functionality, but it ultimately proves to be the location responsible\nfor the next stage of this malware.\n\nThe call $+5 is a common shell code technique to get the address of the stack, as the call\ninstruction will push the address of the next instruction (add [esp+10h+var_10], 5) onto the\nstack and then add 5 to it. The push instruction will push the address 0x51D5 onto the stack,\nonce 5 is added to it the address that this function will return to is 0x51D6. This takes\nexecution to the first instruction after the return. Since IDA was not able to follow this logic,\nwe need to disassemble the code at this location.\n\n\n-----\n\nThere’s a call to DWORD_0, which actually represents the beginning of this section of code\n(.TEXT section). We can resume our dynamic analysis to continue to trace this code.\n\nSetting the appropriate breakpoints, I stopped at the RETF to ensure that my analysis of\nwhere this code was going to return to was correct.\n\nAnd the value on top of the stack is:\n\nHowever, if you trace into this RETF the program doesn’t go to the address we expect:\n\nWhat happened? Turns out, RETF takes two values off of the stack: one value for the\nsegment and a second value for the return address. Notice the PUSH 33h before the RETF,\nthis will force the CPU into 64-bit mode instead of 32-bit! Since I was using a 32-bit instance\nof WinDbg, I was getting unexpected results. Switching to a 64-bit instance of WinDbg allows\nus to trace into this RETF.\n\nIt’s a call to 0x401000. We have to go back to our original shellcode. IDA wasn’t able to find\na reference to this location, so the code was never disassembled. Keep in mind that I\nextracted this as shellcode from the .text section, so an offset of 0 is equivalent to a virtual\n\n\n-----\n\naddress of 0x401000. We also know something else that is very important–this is 64-bit\ncode. Opening this code with the 64-bit version of IDA gives us an accurate disassembly\nlisting.\n\n_Disassembled 64-bit shellcode, function graph, and call graph_\n\nOne of the first things to determine is if we can find any API calls. This code doesn’t have an\nextensive call graph, but one function, Sub_F90, stands out simply due to the number of\ntimes it is called.\n\n\n-----\n\n_Sub_F90 may be responsible for resolving APIs. Setting a breakpoint on this function allows_\nus to investigate the return value in the EAX register. Sure enough, they’re function pointers!\nSome of the more relevant ones are: NtAllocateVirtualMemory, NtWirteVirtualMemory, and\n_RtlCreateUserThread. Following these API calls, it eventually becomes clear that the code is_\nattempting to load a DLL via the CreateUserThread method. During execution, the DLL is\ncopied directly into memory and never touches disk! It’s unpacked purely in memory and\nthen loaded into the current process by the createthread call. As this is a “fileless” stage of\nthe attack, extracting this DLL from memory provides the opportunity to continue our\nanalysis.\n\n## Closer to the End\n\nThis DLL has only one export, which is DllEntryPoint (or DLLMain). This is called by the\nthread created in the previous stage, and it reveals yet another round of complicated code.\n\n\n-----\n\nSimilar to the last stage, I was able to identify the function responsible for resolving APIs. In\nthis code, sub_180011820 returns a function pointer in the RAX register.\n\nTracing this allows visibility into the different APIs being called, and that is where the majority\nof the anti-analysis is employed. For example, there is a call to CreateToolhelpSnapshot32,\nwhich is then used to look for evidence of sandbox/analysis processes. Each process name\nis converted to a multibyte string, changed to upper-case, and then used to create a CRC32\nchecksum. The checksum value is compared to a list of pre-computed values to avoid using\nany strings in the sample, a deliberate obfuscation technique used to avoid clear-text strings\nwhich are easily discovered.\n\n_Array of DWORD pre-computed checksum values_\n\n_R8 contains a pointer to pre-computed checksum and compared with dynamically computed_\n_checksum from process name in EBX_\n\nThis code also looks for manufacturer information through a call to\n_GetSystemFirmwareTable. Bypassing these checks allows the program to finally deliver its_\nintended payload—to make a request for another stage to hxxps://real-estate**_advisors[.win]/vwrdhrbisero/sqyeqten3/niejln3i/tag1h/luyb/45014rvw/4w5unn5vx4di.jpg!_**\n\n\n-----\n\nThis resource is retrieved from a command and control node and then is used to create yet\nanother process. However, this server has now gone offline, but not before its ultimate\npayload was categorized as a malicious banking trojan by the anti-malware community.\n\nhttps://www.virustotal.com/#/file/ee32c4e0a4b345029d8b0f5c6534fa9fc41e795cc937d3f3fd7\n43dcb0a1cea35/detection\n\nDespite all of the obfuscation and anti-analysis we have examined together—and the fact\nthat we utilized multiple tools to reveal the complete picture—every stage of this malware\n[would have been safely contained within the Bromium Secure Platform in an isolated micro-](https://www.bromium.com/our-tech/bromium-secure-platform/)\nvirtual machine. Detection failed to stop the initial stages of the attack, which gave the\nattacker complete freedom to place secondary payloads onto the victim’s PC. This one was a\nbanking trojan, but next time it could be something entirely different or completely new.\nAttackers never stop innovating—and they are always a step or two ahead of detectionfocused defenders—so consider application isolation and control using virtualization-based\nsecurity to protect your endpoints against whatever they come up with next.\n\nTags\n\n## About the Author\n\nDr Josh Stroschein\nCategories\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-11-05 - Data Talks- Deeper Down the Rabbit Hole- Second-Stage Attack and a Fileless Finale.pdf"
    ],
    "report_names": [
        "2018-11-05 - Data Talks- Deeper Down the Rabbit Hole- Second-Stage Attack and a Fileless Finale.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "b14cd6df-3108-4839-8a2d-52eb2f8ce9c8",
            "created_at": "2022-10-25T15:50:23.798666Z",
            "updated_at": "2025-03-27T02:00:55.549494Z",
            "deleted_at": null,
            "main_name": "WIRTE",
            "aliases": [
                "WIRTE"
            ],
            "source_name": "MITRE:WIRTE",
            "tools": [
                "LitePower",
                "Ferocious"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535786,
    "ts_updated_at": 1743041140,
    "ts_creation_date": 1653773764,
    "ts_modification_date": 1653773764,
    "files": {
        "pdf": "https://archive.orkl.eu/7799e6872e003521e072ef9f0cf1cbbe6757dc76.pdf",
        "text": "https://archive.orkl.eu/7799e6872e003521e072ef9f0cf1cbbe6757dc76.txt",
        "img": "https://archive.orkl.eu/7799e6872e003521e072ef9f0cf1cbbe6757dc76.jpg"
    }
}