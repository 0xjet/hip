{
    "id": "0f80d567-b2c3-4ea3-ae80-e1089ecfdbda",
    "created_at": "2023-01-12T14:59:24.703359Z",
    "updated_at": "2025-03-27T02:05:22.476439Z",
    "deleted_at": null,
    "sha1_hash": "e46c973a0c64337482e29eed77c27f1e534f507b",
    "title": "2022-03-02 - Conti's Source Code- Deep-Dive Into",
    "authors": "",
    "file_creation_date": "2022-05-27T22:52:47Z",
    "file_modification_date": "2022-05-27T22:52:47Z",
    "file_size": 2107680,
    "plain_text": "# CONTI’S SOURCE CODE: DEEP-DIVE INTO\n\n**[cluster25.io/2022/03/02/contis-source-code-deep-dive-into/](https://cluster25.io/2022/03/02/contis-source-code-deep-dive-into/)**\n\n## INTRODUCTION\n\n\nMarch 2, 2022\n\n\n-----\n\nOn 25.02.2022 cybercrime group Conti published the following statement on their shame\nblog:\n\nThe post was redacted several hours later with another one having more neutral tones,\ncondemning the war and disaffiliating itself with the government while however emphasizing\nsentiments against the west. The post retained its threats of retaliation against critical\ninfrastructure belonging to any Russia aggressor.\n\nAfter that on 28.02.2022, likely one of the Conti members (or just a Ukrainian security\nresearcher) published a first archive with internal valuable data and information belonging to\nthe whole collective. The action was probably a direct consequence of such a clear-cut\nstance by the group on the current situation between Russia and Ukraine. Among this\nmaterial there also appears to be an archive containing the source code of their ransomware\nof which we report a preliminary analysis.\n\n## INSIGHTS\n\n\n-----\n\n**ContiLocker is a ransomware developed by the Conti Ransomware Gang, a Russian-**\nspeaking criminal collective with suspected links with Russian security agencies. The project\nis developed in C++ on a Visual Studio 2015 version with Windows XP Nplatform toolset\n(v140_xp). The specified destination platform is the 10.0 (Windows10). The project structure\nis organized in different subfolder, where each one handle a specific module of the\nransomware (like the “locker” folder for the encryption operations).\n\nFor specific operations (like the encryption mechanism) this uses different concurrent threads\nhandled by the CreateIoCompletitionPort Windows API and different queues that are\nhandled by the GetQueuedCompletitionStatus and PostQueuedCompletitionStatus.\n\nThe WinMain function (main.cpp) starts with the dynamic resolution of the LoadLibraryA\nAPI through a manual inspection of the imported kernel32.dll (a manual implementation of\nthe GetProcAddress API).\n\nAfter that, the “API” module is invoked to execute an anti-DBI/anti-sandbox technique with\nthe purpose of disable all the possible hooking’s on known DLLs. In fact, the following DLLs\nare loaded through the just resolved LoadLibraryA API:\n\nkernel32.dll\nws2_32.dll\nadvapi32.dll\nntdll.dll\nrstrtmgr.dll\nole32.dll\noleaut32.dll\nnetapi32.dll\niphlpapi.dll\nshlwapi.dll\nshell32.dll\n\nFor each loaded DLL, the CreateFileMappingW and the MapViewOfFile are invoked to\naccess the mapped view into the address space of the calling process.\n\n\n-----\n\nThis view is used to manually access the NT header and the inner export directory. From the\nexport directory each address of the exported functions is extracted, and the first bytes of the\nexported function are checked to identify a possible JMP/NOP/RET instruction that identifies\nan external hook.\n\nIf the current function is hooked, the VirtualProtect and the RtlCopyMemory API are\ninvoked to overwrite the first bytes of the hooked function. Proceeding with the WinMain\nexecution, a mutex called “kjsidugidf99439” is created to check for possible concurrent\nexecutions of the same payload. If another thread has the ownership of the mutex, the\nexecution terminates here.\n\nAfter that, the command lines arguments are checked from the GetCommandLineW API.\n\nThis ransomware accepts the following command line arguments:\n\n-h: specifies a file that contains the IPv4 of hosts to scan for network/shares encryption\n(separated by \\n\\r);\n-p: specifies a file that contains the system path to scan for file encryption (separated\nby \\n\\r);\n-m: specifies the encryption mode\n“all”: encrypt both local and network files\n“local”: encrypt only local files\n“net”: encrypt only network files\n“backups”: not implemented\n-log: if contains the value “enabled”, logs the ransomware actions/errors on the local\nfile C:\\\\ CONTI_LOG.txt\n\n\n-----\n\nAfterwards, the GetNativeSystemInfo API is invoked to extract the number of processors\nand the “threadpool” module is used to instantiate number_of_processors * 2 threads\n(both for local and/or network encryption, based on the specified flags).\n\nEach thread allocates its own buffer for the upcoming encryption and initialize its own\ncryptography context through the CryptAcquireContextA API and an RSA public key.\n\nThen, each thread waits in an infinite loop for a task in the TaskList queue (shared by each\nthread and accessed by the EnterCriticalSection API). In case a new task is available, the\nfilename to encrypt is extracted from the task and, if the filename\n\ncorresponds to “stopmarker”, the thread execution is concluded.\n\nIn any other case, the “locker” module is invoked to encrypt the current file.\n\nThe encryption routine for a specific file starts with a random key generation (using the\n**CryptGetRandom API) of a 32-bytes key and another random generation of an 8-bytes IV.**\n\nSubsequently, the random key and the random IV are stored in a custom FIleInfo structure\nand the random key is encrypted using the RSA key previously decoded.\n\nBefore the encryption phase if the restart manager DLL is loaded (rstrtmgr.dll), the\n**RmStartSession, RmGetList and RmShutdown APIs are invoked to terminate each**\napplication that are using this specific resource or have a handle open on that\n\n\n-----\n\nresource.\n\nThen, based on the file extension, the file content is full encrypted or partially encrypted\n(20% encryption). In particular, the CheckForDataBases method is invoked to check for a\npossible full encryption against the following extensions:\n\n.4dd, .4dl, .accdb, .accdc, .accde, .accdr, .accdt, .accft, .adb, .ade, .adf, .adp, .arc, .ora,\n.alf, .ask, .btr, .bdf, .cat, .cdb, .ckp, .cma, .cpd, .dacpac, .dad, .dadiagrams, .daschema,\n.db, .db-shm, .db-wal, .db3, .dbc, .dbf, .dbs, .dbt, .dbv, .dbx, .dcb, .dct, .dcx, .ddl, .dlis,\n.dp1, .dqy, .dsk, .dsn, .dtsx, .dxl, .eco, .ecx, .edb, .epim, .exb, .fcd, .fdb, .fic, .fmp,\n.fmp12, .fmpsl, .fol, .fp3, .fp4, .fp5, .fp7, .fpt, .frm, .gdb, .grdb, .gwi, .hdb, .his, .ib, .idb,\n.ihx, .itdb, .itw, .jet, .jtx, .kdb, .kexi, .kexic, .kexis, .lgc, .lwx, .maf, .maq, .mar, .mas.mav,\n.mdb, .mdf, .mpd, .mrg, .mud, .mwb, .myd, .ndf, .nnt, .nrmlib, .ns2, .ns3,.ns4, .nsf, .nv,\n.nv2, .nwdb, .nyf, .odb, .ogy, .orx, .owc, .p96, .p97, .pan, .pdb, .p dm, .pnz, .qry, .qvd,\n.rbf, .rctd, .rod, .rodx, .rpd, .rsd, .sas7bdat, .sbf, .scx, .sdb, .sdc, .sdf, .sis, .spg, .sql,\n.sqlite, .sqlite3, .sqlitedb, .te, .temx, .tmd, .tps, .trc, .trm, .udb, .udl, .usr, .v12, .vis, .vpd,\n.vvv, .wdb, .wmdb, .wrk, .xdb, .xld, .xmlff, .abcddb, .abs, .abx, .accdw, .adn, .db2, .fm5,\n.hjt, .icg, .icr, .kdb, .lut, .maw, .mdn, .mdt\n\nOtherwise, the method CheckForVirtualMachines method is invoked to check for a possible\n20% partial encryption ((file_size / 100) * 7) against the following extensions:\n\nvdi, .vhd, .vmdk, .pvm, .vmem, .vmsn, .vmsd, .nvram, .vmx, .raw, .qcow2, .subvol, .bin,\n.vsv, .avhd, .vmrs, .vhdx, .avdx, .vmcx, .iso\n\nIn other cases, the following pattern is followed:\n\nIf the file size is lower than 1,04 GB: perform a full encryption.\nIf the file size is between 1,04 GB and 5,24 GB: perform a header encryption (encrypt\nonly the first 1048576 bytes).\n\n\n-----\n\nOtherwise perform a 50% partial encryption ((file_size / 100) 100).\n\nAfter chosen the encryption method, the first bytes of the file content are overwritten (before\nthe encryption) with the information about the encryption mode and the key used for\nencryption. Then, the file content is encrypted using the random key previously encrypted\nwith RSA and the file extension is changed to .EXTEN.\n\nNow let’s see how these threads are invoked from the enumeration methods returning to the\nWinMain execution.\n\nFirst, a COM bypass is used to delete the shadow copies from the Windows Management\n**Instrumentation (WMI).**\n\nIn details:\n\n1. The COM object is initialized through the CoInitializeEx API.\n2. The COM security levels are changed trough the CoInitializeSecurity API and the\n\nparameter cAuthSvc equals to -1 in order to disable the authentication.\n3. The CoCreateInstance API is used to locate the WMI trough the CLSID\n\n“CLSID_WbemLocator”.\n4. The WMI and the WQL (WMI Query Language) are accessed through the\n\n**IWbemLocator::ConnectServer method.**\n5. The WMI proxy security levels are changed through the CoSetProxyBlanket API in\n\norder to set the flag RPC_C_AUTHZ_NONE and avoid the authentication.\n6. The “SELECT * FROM Win32_ShadowCopy” query is invoked to identify the shadow\n\ncopies ID’s and a command-line execution is used to delete each shadow copy\n“cmd.exe /c C:\\\\Windows\\\\System32\\\\wbem\\\\WMIC.exe shadowcopy where\n**\\”ID=’%s’\\” delete”**\n\nFinally, the enumeration process starts. First, the file-system paths specified through the -p\nflag are iterated and for each path the ransomware note (R3ADM3.txt, not available in this\nleaked version) is dropped into the specified directory. After that, the APIs FindFirstFileW\nand FindNextFileW are used to iterate inside each directory ignoring the special files (like “.”\nor “..”).\n\n\n-----\n\nThe malware uses a whitelist for both directories and files to avoid the encryption of\nunnecessary data. The following directories names and file names are avoided during the\nenumeration process:\n\nDirectories: “tmp”, “winnt”, “temp”, “thumb”, “$Recycle.Bin”, “$RECYCLE.BIN”, “System\nVolume Information”, “Boot”, “Windows”, “Trend Micro”\nFiles: “.exe”, “.dll”, “.lnk”, “.sys”, “.msi”, “R3ADM3.txt”, “CONTI_LOG.txt”\n\nIf the file to encrypt is a directory, the described process is repeated recursively for all the\nsubdirectories and subfiles. Finally, the file to encrypt is passed to the first available thread\nfor the encryption process populating the TaskList queue. The following enumeration\ninspects all the logical drives of the infected system.\n\nIn fact, in addition to the paths specified by the -p flag, the GetLogicalDriveStringsW API is\nused to obtain the drives list. Then, for each logical drive, the root path is extracted, and the\nprevious process is repeated for each subdirectory and subfiles.\n\nThe last enumeration process is used to enumerate the shares of the infected Windows\nsystem. In fact, the NetShareEnum API is used to retrieve information about each shared\nresource. For each resource, if the resource represents a disk drive, a special share (e.g.,\n$IPC communications, ADMIN$ remote administrations, administrative shares) or a\ntemporary share the share path is extracted (e.g., \\\\\\\\$IP\\\\$SHARE_NAME).\n\nThen, each share path is used as a directory for the previously described process of\ndirectories and files encryption.\n\n\n-----\n\nAdditionally to the share enumeration, this ransomware presents a multi-thread component\nto scan for other IP’s in the reachable networks for a destructive lateral movement\nencryption. In particular, the WSAStartup and the WSAIoctl APIs are invoked to get a handler\nto LPFN_CONNECTEX for low-level binds and connections.\n\nThen, the GetIpNetTable API is invoked to recover the ARP table of the infected system. For\neach entry of the ARP table, the specified IPv4 addresses are checked against the following\nmasks:\n\n172.*\n192.168.*\n10.*\n169.*\n\nIf the current ARP IPv4 respect one of these masks, the IP subnet is extracted and added\ninto a subnet’s queue. From this enumeration, two concurrent threads are created. The first\nthread is responsible for subnet scanning: for each possible address (from .0 to .255) in each\nextracted subnet the malware tries a connection on that IP on the SMB port (445) using the\nTCP protocol. For each successful connection, this first thread saves the valid IP’s in a\nqueue and repeat the scan each 30 seconds.\n\nThe second thread wait for some valid IP in the IP’s queue and for each IP enumerate the\nshares using the NetShareEnum API repeating the process described for the share\nenumeration. The hexadecimal 0xFFFFFFFF is used as last IP address in the queue to kill\nboth threads and conclude the second and last part of the network enumeration.\n\n\n-----\n\nConcluding the ransomware execution, the WaitForSingleObject API is invoked on each\nthread to wait for the completion of encryption and enumeration operations before closing the\nmain process.\n\n## CONCLUSION\n\nThe Conti gang is one of the best known and most feared criminal organizations in the\ndigital world. The quantity and detail of the internal data that is gradually coming out about\nthe collective can certainly represent a real earthquake in the landscape of cyber threats. As\nfor the code, it appears to be very well modularized and managed. As we could have\nexpected its quality is certainly high.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-02 - Conti's Source Code- Deep-Dive Into.pdf"
    ],
    "report_names": [
        "2022-03-02 - Conti's Source Code- Deep-Dive Into.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535564,
    "ts_updated_at": 1743041122,
    "ts_creation_date": 1653691967,
    "ts_modification_date": 1653691967,
    "files": {
        "pdf": "https://archive.orkl.eu/e46c973a0c64337482e29eed77c27f1e534f507b.pdf",
        "text": "https://archive.orkl.eu/e46c973a0c64337482e29eed77c27f1e534f507b.txt",
        "img": "https://archive.orkl.eu/e46c973a0c64337482e29eed77c27f1e534f507b.jpg"
    }
}