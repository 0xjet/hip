{
    "id": "bc3480a1-8ae7-4ed3-89d8-f7cc415d854b",
    "created_at": "2023-06-05T02:07:01.178522Z",
    "updated_at": "2025-03-27T02:05:18.264744Z",
    "deleted_at": null,
    "sha1_hash": "7ad78939ff8347a5530f597d5ee91c48ce70e8ef",
    "title": "2023-05-17 - Deobfuscating the Latest GuLoader- Automating Analysis with Ghidra Scripting",
    "authors": "",
    "file_creation_date": "2023-06-04T13:02:55Z",
    "file_modification_date": "2023-06-04T13:02:55Z",
    "file_size": 195777,
    "plain_text": "# Deobfuscating the Latest GuLoader: Automating Analysis with Ghidra Scripting\n\n**any.run/cybersecurity-blog/deobfuscating-guloader/**\n\nElectron May 17, 2023\n\n[HomeMalware Analysis](https://any.run/cybersecurity-blog/)\nDeobfuscating the Latest GuLoader: Automating Analysis with Ghidra Scripting\nIn this article by [ANY.RUN analysts, we’ll discuss the GuLoader malware and how to deobfuscate its code using the Ghidra scripting engine.](https://any.run/?utm_source=anyrunblog&utm_medium=article&utm_campaign=guloader&utm_content=landing)\n\nWe will:\n\nIdentify obfuscated code patterns\nDevelop an algorithm to deobfuscate **and optimize these code patterns**\nWrite a script to semi-automate the code deobfuscation process.\n\nWe also detailed the obfuscation techniques for junior analysts. And mid-level and senior analysts will find strategies and tools for simplifying\nand deobfuscating GuLoader and other malware.\n\nWithout further ado, let’s get into the analysis.\n\n## Brief Overview of GuLoader\n\nGuLoader is a widely used malware loader known for its complex obfuscation techniques that make it difficult to analyze and detect.\n\nHere’s some general information about this threat:\n\n\n-----\n\nWe are going to examine a GuLoader sample with the first submission time 2023 03 28 and SHA256 hash:\n\n653519cb7879ba9389474ab6fb92ae69475ea3166167e3b9b1e4405e14506f5d\n\n[You can download the original sample from this link.](https://app.any.run/tasks/32c71b72-752a-4b70-bb6e-9557dc99708e?utm_source=anyrunblog&utm_medium=article&utm_campaign=privateloader&utm_content=task)\n\nFig. 1 – basic file information of the investigated\n\n_Guloader sample_\n\n### Clearing the way: Why Deobfuscating Code is Crucial Before Analysis?\n\nDeobfuscating code is an essential step in the process of malware analysis. When malware authors create their programs, they often use\nvarious obfuscation techniques to make it more difficult to understand and analyze their code.\n\nBy deobfuscating the code, analysts can gain a better understanding of the malware’s functionality, identify its capabilities, and develop\neffective mitigation strategies.\n\nConsider this picture where Guloader’s sophisticated assembly code is decompiled into ugly pseudo-code:\n\n\n-----\n\nFig.2 — Guloader’s sophisticated assembly code along with the decompilation result\nObfuscation used in the code makes it almost impossible to understand what’s going on. That’s why today we will focus on deobfuscation —\nit will help us gain a better understanding of Guloader’s behavior.\n\n[By the way, if you want to see more examples of analyzing obfuscated code, check out our deep dive into CryptBot.](https://any.run/cybersecurity-blog/cryptbot-infostealer-malware-analysis/)\n\n## Unpacking Guloader’s Shellcode\n\nUnpacking GuLoader’s shellcode is rather straightforward.\n\nStart by reaching the entry point of the malware. Once identified, set a breakpoint at the VirtualAllocEx function. This function is used to\nallocate memory for the GuLoader’s shellcode. The first break point should occur when the function finishes executing and the memory has\nbeen allocated.\n\n\n-----\n\nFig. 3 — allocated memory for the shellcode\nNote that the return address in the stack the ‘System.dll’ module — not the executable itself. This means that the malware brings this module\nwith itself.\n\nAt this point, set a hardware execution breakpoint at the first byte of the memory address returned in the EAX register. This will create a break\nat the first instruction of the shellcode.\n\nAfter setting this breakpoint, run the malware. When the breakpoint is hit, you will be at the first instruction of the shellcode.\n\n\n-----\n\nFig. 4 — shellcode’s entry point\nTo further analyze the shellcode, navigate to the memory map and create a dump of the memory region allocated by “VirtualAllocEx”. This\ndump can be loaded into a disassembler, allowing you to analyze the shellcode in more detail.\n\nIt is worth noting that, we used Windows 7 (x32) as our unpacking environment. Keep in mind that the algorithm will be slightly different for\nthe other OS versions. If you don’t have time or a suitable environment to unpack GuLoader shellcode by yourself, you can download an\n[archive with an already unpacked sample from our GitHub repository (password: infected).](https://github.com/anyrun/blog-scripts/blob/main/Scripts/GuLoader/dump.zip)\n\n## Identifying Obfuscated and Junk Code Patterns\n\nIn this section, we will search for junk and obfuscated code in GuLoader’s shellcode to use them as templates for deobfuscating and\noptimization techniques.\n\n### XMM instructions\n\nThere are many XMM instructions present in the code. They look chaotic and complicate the analysis process. We encountered them from\nthe first byte of the unpacked shellcode:\n\n\n-----\n\nFig. 5 — XMM instructions at the start of the shellcode\nthese instructions are quite effective at obfuscating the code, as they can break many emulation engines. That’s Because most of them are\nnot supported by default. We have tested Angr, Triton as well as Ghidra embedded engines – all of them failed.\n\n### Unconditional JMP instructions\n\nGuloader authors used lots of JMP instructions to divide the code into small blocks and connect them together. Not only does this technique\nmake the code more difficult to analyze, but it also prevents detection by antivirus software and other security tools. What’s more, jumping\nbetween these blocks can be quite tedious and annoying for analysts, especially when dealing with a large amount of code.\n\n\n-----\n\nFig. 6 — an\n\n_example of small blocks on the graph connected by JMP instructions_\n\n### Junk instructions\n\nThe GuLoader code contains junk assembly instructions, which are often incorporated as an extra layer of obfuscation to complicate its\nanalysis. These instructions have no practical function, generally leaving the value of registers, execution flow, or memory unchanged. Their\npurpose is to hinder analysis and obscure the genuine functionality of the code.\n\n\n-----\n\nFig.7 — an example of a junk instruction ‘OR’ Fig.\n\n7 —\nWe may highlight instructions that perform no operation (“NOP”, “FNOP”), and instructions that shift or rotate a value by zero bits (“SHL reg,\n0”; “ROL reg, 0”). Also, the code may contain instructions like “OR reg, 0”, “XOR reg, 0”, “CLD”, “WAIT” and others, which are equally\nuseless, making no impact on the code’s behavior.\n\n### Fake comparison instructions\n\nGuLoader code frequently utilizes fake comparison instructions for obfuscation. These instructions usually involve comparing a register or\nmemory location with a fixed value, like “CMP EAX, 0” or “TEST EDX, EDX”. Yet, the outcome of these comparisons isn’t applied in following\ninstructions, rendering the comparison pointless.\n\n\n-----\n\nFig. 8 — an example of a fake comparison instruction ‘TEST EDX, EDX’\n\n### Fake PUSHAD instructions\n\nThe use of fake “PUSHAD” instructions, when paired with a corresponding “POPAD” instruction, is another common obfuscation technique\nused in the GuLoader code.\n\nThese instructions can be used to temporarily modify the values of registers between the “PUSHAD“ and “POPAD” instructions. However, the\nfinal “POPAD” instruction restores all registers to their original values, effectively nullifying any modifications made by the code.\n\n\n-----\n\nFig. 9 — an example of a useless ‘pushad’ instruction combined with a ‘popad’\n\n### Fake PUSH instructions\n\nThe use of fake “PUSH” instructions is yet another obfuscation method that is rather similar to the previous one. These pairs of instructions\ninvolve pushing a value onto the stack and then immediately popping it off again.\n\nFor example, the code may include a “PUSH SS” instruction, followed by one or more instructions that modify the value of a particular register\nor memory location. However, when the corresponding “POP SS” instruction is executed, the content of the stack pointer is restored to its\noriginal value.\n\n\n-----\n\nFig. 10 — an example of a fake ‘PUSH’ instruction\n\n### Opaque predicates\n\nGuLoader code also incorporates opaque predicates to increase the difficulty in comprehending the code’s logic. These predicates are\nessentially conditional statements that consistently evaluate to either true or false. However, they are designed to be challenging to analyze\nor predict.\n\nFor example, the code may include a pair of instructions such as “MOV BL, 0xB6” and “CMP BL, 0xB6”, followed by a conditional jump\ninstruction such as “JNZ ADDR”. However, since the value being compared is the same as the value that was just moved into the register, the\ncomparison will always evaluate to false, making the conditional jump unnecessary and confusing.\n\n\n-----\n\nFig. 11 — opaque predicate that is always evaluates to false\n\n### Arithmetic Expressions\n\nObfuscated arithmetic expressions are one of the most interesting obfuscation methods used in GuLoader to make the actual arithmetic\noperations harder to understand. These expressions involve arithmetic instructions like addition, subtraction, and exclusive or, which are\nmixed with other obfuscation techniques such as fake comparisons, opaque predicates, and junk instructions.\n\nOne example of arithmetic obfuscation in GuLoader code is to move a constant value into a register and perform arithmetic operations on it:\n\n\n-----\n\nFig. 12 — an example of arithmetic obfuscation distributed between two small blocks\nAnother example is to push a constant value onto the stack and perform mathematical operations on the memory located on the stack:\n\n\n-----\n\nFig. 13 — an example of math operations on the top of the stack\n\n## Deobfuscating and Optimizing: Techniques and Strategies\n\nIn the previous sections, we’ve identified and discussed various obfuscation techniques often found in GuLoader, including:\n\nOpaque predicates\nObfuscated arithmetic expressions\nAnd junk instructions.\n\nNow, let’s focus on developing techniques and strategies to overcome these obfuscation methods and make the code easier to analyze.\n\nWhat’s more, we will show the state of the code before and after deobfuscation. You’ll see how using various deobfuscation techniques can\nrender the code more readable and simplified for analysis.\n\n### “Nopping” all XMM instructions\n\n\n-----\n\nAs previously noted, XMM instructions can complicate the analysis process due to their obfuscating impact on the code. Fortunately, our\nanalysis shows that all of the XMM instructions used in GuLoader are extraneous and don’t influence the code’s intended behavior. These\ninstructions are essentially pointless, as the outcome of their execution is never utilized.\n\nThe result of “Nopping” all XMM instructions can be seen in the following table:\n\nFig. 14 — the expected result of “nopping” all XMM instructions\nAnd here’s the achieved result of “Nopping” all XMM instructions in Ghidra:\n\n\n-----\n\nFig. 15 — “nopped” XMM instructions in Ghidra\n\n### Leaving Unconditional JMP Instructions Untouched\n\nWhen analyzing GuLoader, it can be tempting to remove unconditional JMP instructions to streamline the code and make it easier to read.\nBut, it requires a lot of time and effort.\n\nAdditionally, the disassembler in decompiled code can often do a good job of concatenating blocks and making the code more legible, even\nwith the presence of these unconditional jumps. Thus we decided to leave small blocks and not concatenate them.\n\n\n-----\n\nFig. 16 — two deobfuscated blocks on the graph without concatenation\n\n### “Nopping” Junk Instructions\n\nJunk instructions are those that do not affect the execution flow of the code and can be safely removed. One of the expected results of\n“nopping” all junk instructions is represented it the following table:\n\n\n-----\n\nFig. 17 — an expected result of “nopping” junk instructions\n\n### Defeating fake comparison instructions\n\nDealing with fake comparison instructions can be a bit more difficult than simply “nopping” junk instructions. Unlike junk instructions, we can’t\njust remove any comparison instruction we come across, because it may actually be needed for the code to function correctly. To handle this,\nwe need to carefully identify which comparisons are fake and can be removed.\n\nOne way to do this is to “mark” any comparison instruction we encounter, and then look for any subsequent instructions that may use the\nresult of the comparison. If no such instructions are found, we can safely replace the comparison instruction with a NOP. If we encounter a\nconditional jump or another instruction that may use the comparison result, we need to “unmark” the previous comparison so that it is not\nremoved.\n\nAn example of properly “nopping” out junk comparison instructions is illustrated in the following table. As shown, all comparison instructions\nexcept for “CMP EDX,0x0” have been removed:\n\n\n-----\n\nFig. 18 — an example of “nopping” fake-comparison instructions\n\n### Defeating fake PUSHAD instructions\n\nOur investigation revealed that all “PUSHAD” instructions used in the GuLoader code are useless. So, we simply nop the “PUSHAD” and\n“POPAD” instructions, and everything in between them:\n\n\n-----\n\nFig. 19 — an example of nopping everything between “PUSHAD” and “POPAD”\nNote that not all “POPAD” instructions found in the GuLoader code are junk. Some of them may not have a corresponding “PUSHAD”\ninstruction. In such cases, we leave the “POPAD” instruction untouched.\n\n### Defeating fake PUSH instructions\n\nCleaning up fake PUSH instructions is akin to handling fake PUSHAD instructions, but we need to make sure that the registers that are not\npushed remain unaffected.\n\n\n-----\n\nFig. 20 —an example of nopping “PUSH” and “POP” instructions\n\n### Opaque predicates\n\nOvercoming opaque predicates might appear challenging initially, as it requires “predicting” the jump condition. However, in our case, it’s\nrelatively straightforward because all discovered opaque predicates are situated within the “PUSHAD” and “POPAD” blocks. When\nprocessing “PUSHAD” blocks, we simply nullify all opaque predicates between the “PUSHAD” and the corresponding “POPAD” instruction.\n\n### Calculating Arithmetic Expressions\n\nTo deobfuscate the arithmetic expressions in Guloader, we follow a similar approach to the fake comparison instructions. We mark all “MOV”\ninstructions where the second argument is a scalar value and all “PUSH” instructions where the argument is a scalar too. When we encounter\nan arithmetic operation, we update the constant value in the first instruction and nop the current instruction. In this way, the first met\ninstruction will always have the result value, and the rest of the arithmetic instructions will be “nopped”.\n\nSee the following example with the optimized “MOV” operation:\n\n\n-----\n\nFig. 21 — optimizing “MOV” arithmetic operations\nHere is another example where we optimize “PUSH” instructions:\n\n\n-----\n\nFig. 22 — optimizing “PUSH” math operations\nIt’s important to be careful when dealing with the size of the operands – we need to ensure that we preserve the correct size when performing\nthe arithmetic operations.\n\n## Automating Malware Analysis with a Ghidra Script\n\nIn the earlier sections, we identified typical obfuscation techniques in GuLoader’s code and discussed various strategies to overcome them.\nIn this section, we provide a brief description of a script designed to semi-automate the deobfuscation process for GuLoader’s code.\n\nWe’ve developed a script that initiates from the chosen instruction, tracks calls and conditional jumps, simplifies, deobfuscates, and\ndisassembles the resulting code. The script avoids jumping over calls with a specific operand value because not all calls result in returns.\nThis script employs all the approaches we’ve discussed in previous chapters.\n\n\n-----\n\nFig. 23 — part of the script to deobfuscate GuLoader’s code\n[You can download this script from our GitHub repository and put it in Ghidra’s script folder. We recommend setting a hotkey for quick access.](https://github.com/anyrun/blog-scripts/blob/main/Scripts/GuLoader/GuDeobfuscator.py)\nSimply place the cursor over an interesting position (you could start from the 0x0 offset) and press the hotkey to see the deobfuscated code.\n\nFinally, let’s take a look at the pseudo-code of Guloader before and after using the deobfuscation script and compare them:\n\n\n-----\n\nFig. 24 — the 1 example of the code before deobfuscatingst\nAnd here is the same code after deobfuscation:\n\n\n-----\n\nFig. 25 — the same 1 example of the code, but after applying scriptst\nHere is another example of GuLoader’s code before and after applying our deobfuscation script. Here’s the before:\n\n\n-----\n\nFig. 26 — the 2nd example of obfuscated code, all doesn’t even fit on the screen\nAnd here it is after running the script:\n\n\n-----\n\nFig. 27 — the same 2nd example, but after applying the script\nAs you can see, the code is now significantly more readable. The obfuscated instructions have been eliminated, making the code flow easy to\ntrace.\n\nThis greatly simplifies the task for malware analysts trying to understand the malware’s behavior, making the whole analysis process\nconsiderably more efficient.\n\n## Limitations of the approach\n\nWhile the semi-automated deobfuscation method with Ghidra scripting is effective, there are several limitations to bear in mind.\n\n1. It’s possible that not all obfuscated code patterns in GuLoader have been identified, and new techniques may emerge in future versions\n\nof the malware.\n2. There is a chance of optimization errors, where some instructions might be wrongly identified as junk or obfuscated code, and are\n\nnulled or removed.\n3. The script may need adjustments or updates to handle different versions of GuLoader, as there might be changes in the obfuscation\n\ntechniques used.\n\n\n-----\n\n4. The script might not be able to identify all calls and jump destinations, particularly if they re dynamically generated or encoded.\n5. Writing and testing the script can demand a significant amount of time and effort, as it necessitates a thorough understanding of\n\nGuLoader’s code structure and obfuscation techniques.\n\nDespite these limitations, this approach remains a helpful tool for automating GuLoader code analysis and deobfuscation.\n\n## Wrapping up\n\nWe’ve explored one potential approach to deobfuscating GuLoader, which entails identifying common obfuscation patterns and neutralizing\nthem using various techniques.\n\nIt’s important to note that while this approach was specifically tailored for deobfuscating GuLoader, the same general techniques could be\napplied to other malware samples as well. However, bear in mind that each malware sample might have unique obfuscation techniques,\nnecessitating the development of specific optimization strategies.\n\nWant to read more content like this?\n\n[Learn how we analyzed the encryption and decription algorithms of PrivateLoader](https://any.run/cybersecurity-blog/privateloader-analyzing-the-encryption-and-decryption-of-a-modern-loader/)\nOr learn [how to extract LimeRat configuration](https://any.run/cybersecurity-blog/limerat-malware-analysis/)\n\n[10:48] Ivan\nSkladchikov\nElectron is a\n[malware analyst at](https://any.run/cybersecurity-blog/deobfuscating-guloader/)\nANY.RUN\n\n\nElectron\n\nMalware analyst at ANY.RUN\nat https://any.run/\n| + posts\nI'm a malware analyst. I love CTF, reversing, and pwn. Off-screen, I enjoy the simplicity of biking, walking, and hiking.\n\n[GuLoader](https://any.run/cybersecurity-blog/tag/guloader/) [malware analysis](https://any.run/cybersecurity-blog/tag/malware-analysis/)\n\nUser avatar\nElectron\nMalware analyst at ANY.RUN\nI'm a malware analyst. I love CTF, reversing, and pwn. Off-screen, I enjoy the simplicity of biking, walking, and hiking.\n[View all posts](https://any.run/cybersecurity-blog/authors/electron)\nWhat do you think about this post?\n\n16 answers\n\nAwful\nAverage\nGreat\n\nNo votes so far! Be the first to rate this post.\n\n3 comments\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-05-17 - Deobfuscating the Latest GuLoader- Automating Analysis with Ghidra Scripting.pdf"
    ],
    "report_names": [
        "2023-05-17 - Deobfuscating the Latest GuLoader- Automating Analysis with Ghidra Scripting.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1685930821,
    "ts_updated_at": 1743041118,
    "ts_creation_date": 1685883775,
    "ts_modification_date": 1685883775,
    "files": {
        "pdf": "https://archive.orkl.eu/7ad78939ff8347a5530f597d5ee91c48ce70e8ef.pdf",
        "text": "https://archive.orkl.eu/7ad78939ff8347a5530f597d5ee91c48ce70e8ef.txt",
        "img": "https://archive.orkl.eu/7ad78939ff8347a5530f597d5ee91c48ce70e8ef.jpg"
    }
}