{
    "id": "f69b96bf-a269-4d38-b986-e3dafe1f5ce0",
    "created_at": "2023-01-12T15:00:23.549098Z",
    "updated_at": "2025-03-27T02:16:39.929737Z",
    "deleted_at": null,
    "sha1_hash": "d5866f9ff9403efef730546649932580df8ef54d",
    "title": "2021-09-22 - BlackMatter Ransomware Analysis; The Dark Side Returns",
    "authors": "",
    "file_creation_date": "2022-05-28T16:46:37Z",
    "file_modification_date": "2022-05-28T16:46:37Z",
    "file_size": 110226,
    "plain_text": "# BlackMatter Ransomware Analysis; The Dark Side Returns\n\n**[mcafee.com/blogs/enterprise/blackmatter-ransomware-analysis-the-dark-side-returns/](https://www.mcafee.com/blogs/enterprise/blackmatter-ransomware-analysis-the-dark-side-returns/)**\n\n**ARCHIVED STORY**\n\nBy Alexandre Mundo and Marc Elias · September 22, 2021\n\nBlackMatter is a new ransomware threat discovered at the end of July 2021.\n\nThis malware started with a strong group of attacks and some advertising from its developers\n[that claims they take the best parts of other malware, such as GandCrab,](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/gandcrab-ransomware-puts-the-pinch-on-victims/) [LockBit and](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/tales-from-the-trenches-a-lockbit-ransomware-story)\n[DarkSide, despite also saying they are a new group of developers. We at McAfee Enterprise](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/darkside-ransomware-victims-sold-short/)\nAdvanced Threat Research (ATR), have serious doubts about this last statement as analysis\nshows the malware has a great deal in common with DarkSide, the malware associated with\nthe Colonial Pipeline attack which caught the attention of the US government and law\nenforcement agencies around the world.\n\nThe main goal of BlackMatter is to encrypt files in the infected computer and demand a\nransom for decrypting them. As with previous ransomware, the operators steal files and\nprivate information from compromised servers and request an additional ransom to not\npublish on the internet.\n\n## COVERAGE AND PROTECTION ADVICE\n\nMcAfee’s EPP solution covers BlackMatter ransomware with an array of prevention and\ndetection techniques.\n\nENS ATP provides behavioral content focusing on proactively detecting the threat while also\ndelivering known IoCs for both online and offline detections. For DAT based detections, the\nfamily will be reported as Ransom-BlackMatter!<hash>. ENS ATP adds 2 additional layers of\nprotection thanks to JTI rules that provide attack surface reduction for generic ransomware\nbehaviors and RealProtect (static and dynamic) with ML models targeting ransomware\nthreats.\n\nUpdates on indicators are pushed through GTI, and customers of Insights will find a threatprofile on this ransomware family that is updated when new and relevant information\nbecomes available.\n\n## TECHNICAL DETAILS\n\n\n-----\n\nBlackMatter is typically seen as an EXE program and, in special cases, as a DLL (Dynamic\nLibrary) for Windows. Linux machines can be affected with special versions of it too but in\nthis report, we will only be covering the Windows version.\n\nThis report will focus on version 1.2 of BlackMatter while also noting the important changes\nin the current version, 2.0.\n\nBlackMatter is programmed in C++ and has a size of 67Kb.\n\nFigure 1.2Information about the malware\n\n**Figure 1. Information about the malware**\nThe compile date of this sample is the 23rd of July 2021. While these dates can be altered,\nwe think it is correct; version 1.9 has a compile time of 12 August 2021 and the latest\nversion, 2.0, has a date four days later, on the 16th of August 2021. Is clear that the malware\ndevelopers are actively improving the code and making detection and analysis harder.\n\nThe first action performed by BlackMatter is preparation of some modules that will be needed\nlater to get the required functions of Windows.\n\nFigure 2. BlackMatter searching for functions\n\n**Figure 2. BlackMatter searching for functions**\nBlackMatter uses some tricks to try and make analysis harder and avoid debuggers. Instead\nof searching for module names it will check for hashes precalculated with a ROT13\nalgorithm. The modules needed are “kernel32.dll” and “ntdll.dll”. Both modules will try to get\nfunctions to reserve memory in the process heap. The APIs are searched using a\ncombination of the PEB (Process Environment Block) of the module and the EAT (Export\nTable Address) and enumerating all function names. With these names it will calculate the\ncustom hash and check against the target hashes.\n\nFigure 3. BlackMatter detecting a debugger\n\n**Figure 3. BlackMatter detecting a debugger**\nAt this point BlackMatter will make a special code to detect debuggers, checking the last 2\n“DWORDS” after the memory is reserved, searching for the bytes “0xABABABAB”. These\nbytes always exist when a process reserves memory in the heap and, if the heap has one\nspecial flag (that by default is set when a process is in a debugger), the malware will avoid\nsaving the pointer to the memory reserved so, in this case, the variables will keep a null\npointer.\n\nIn Windows operating systems the memory has different conditions based on whether a\nprogram is running in normal mode (as usual) or in debugging mode (a mode used by\nprogrammers, for example). In this case, when the memory is reserved to keep information,\nif it is in debugging mode, Windows will mark the end of this memory with a special value,\n\n\n-----\n\n0xABABABAB . BlackMatter checks for this value and, if found, the debugger is detected.\nTo avoid having it run normally it will destroy the function address that it gets before,\nmeaning it will crash, thus avoiding the execution.\n\nFigure 4. Preparing the protection stub function\n\n**Figure 4. Preparing the protection stub function**\nAfter this check it will create a special stub in the reserved memory which is very simple but\neffective in making analysis harder as the stub will need to be executed to see which function\nis called and executed.\n\nThis procedure will be done with all functions that will be needed; the hashes are saved\nhardcoded in the middle of the “.text” section in little structs as data. The end of each struct\nwill be recognized by a check against the “0xCCCCCCCC” value.\n\nFigure 5. Hashes of the functions needed\n\n**Figure 5. Hashes of the functions needed**\nThis behavior highlights that the BlackMatter developers know some tricks to make analysis\nharder, though it is simple to defeat both by patching the binary.\n\nAfter this, the ransomware will use another trick to avoid the use of debuggers. BlackMatter\nwill call the function “ZwSetInformationThread” with the class argument of 0x11 which will\nhide the calling thread from the debuggers.\n\nIf the malware executes it correctly and a debugger is attached, the debugging session will\nfinish immediately. This code is executed later in the threads that will be used to encrypt files.\n\nFigure 6. Another way to detect a debugger\n\n**Figure 6. Another way to detect a debugger**\nThe next action is to check if the user that launched the process belongs to the local group of\nAdministrators in the machine using the function “SHTestTokenMembership”. In the case that\nthe user belongs to the administrator group the code will continue normally but in other cases\nit will get the operating system version using the PEB (to avoid using API functions that can\nalter the version) and, if it is available, will open the process and check the token to see if\nthat belongs to the Administrators group.\n\nFigure 7. BlackMatter checking if it has administrator rights\n\n**Figure 7. BlackMatter checking if it has administrator rights**\nIn the case that the user does not belong to the Administrator group the process token will\nuse a clever trick to escalate privileges.\n\n\n-----\n\nThe first action is to prepare the string dllhost.exe and enumerate all modules loaded. For\neach module it will check one field in the initial structure that all executables have that keeps\nthe base memory address where it will be loaded (for example, kernel32.dll in 0x7fff0000)\nand will compare with its own base address. If it is equal, it will change its name in the PEB\nfields and the path and arguments path to “dllhost.exe” (in the case of the path and argument\npath to the SYSTEM32 folder, where the legitimate “dllhost.exe” exists). This trick is used to\ntry and mislead the user. For each module found it will check the base address of the module\nwith its own base address and, at that moment, will change the name of the module loaded,\nthe path, and arguments to mislead the user.\n\nFigure 8. Decryption of the string “dllhost.exe”\n\n**Figure 8. Decryption of the string “dllhost.exe”**\nThe process name will be “dllhost.exe” and the path will be the system directory of the victim\nmachine. This trick, besides not changing the name of the process in the TaskManager, can\nmake a debugger “think” that another binary is loaded and remove all breakpoints\n(depending on the debugger used).\n\nFigure 9. Changing the name and path in the PEB\n\n**Figure 9. Changing the name and path in the PEB**\nThe second action is to use one exploit using COM (Component Object Model) objects to try\nto elevate privileges before finishing its own instance using the “Terminate Process” function.\n\nFor detection, the module uses an undocumented function from NTDLL.DLL,\n“LoadedModulesLdrCallback” that lets the programmer set a function as a callback where it\ncan get the arguments and check the PEB. In this callback the malware will set the new\nUnicode strings using “RtlInitUnicodeString”; the strings are the path to “dllhost.exe” in the\nsystem folder and “dllhost.exe” as the image name.\n\nThe exploit used to bypass the UAC (User Access Control), which is public, uses the COM\ninterface of CMSTPLUA and the COM Elevation Moniker.\n\nIn the case that it has administrator rights or uses the exploit with success, it will continue\nmaking the new extension that will be used with the encrypted files. For this task it will read\nthe registry key of “Machine Guid” in the cryptographic key (HKEY LOCAL MACHINE).\n\nThis entry and value exist in all versions of Windows and is unique for the machine; with this\nvalue it will make a custom hash and get the final string of nine characters.\n\nFigure 10. Creating the new extension for the encrypted files\n\n**Figure 10. Creating the new extension for the encrypted files**\n\n\n-----\n\nNext, the malware will create the ransom note name and calculate the integrity hash of it.\nThe ransom note text is stored encrypted in the malware data. Usually the ransom note\nname is “%s.README.txt”, where the wildcard is filled with the new extension generated\npreviously.\n\nThe next step is to get privileges that will be needed later; BlackMatter tries to get many\nprivileges:\n\n -    SE_BACKUP_PRIVILEGE\n\n -    SE_DEBUG_PRIVILEGE, SE_IMPERSONATE_PRIVILEGE\n\n -    SE_INC_BASE_PRIORITY_PRIVILEGE\n\n -    SE_INCREASE_QUOTA_PRIVILEGE\n\n -    SE_INC_WORKING_SET_PRIVILEGE\n\n -    SE_MANAGE_VOLUME_PRIVILEGE\n\n -    SE_PROF_SINGLE_PROCESS_PRIVILEGE\n\n -    SE_RESTORE_PRIVILEGE\n\n -    SE_SECURITY_PRIVILEGE\n\n -    SE_SYSTEM_PROFILE_PRIVILEGE\n\n -    SE_TAKE_OWNERSHIP_PRIVILEGE\n\n -    SE_SHUTDOWN_PRIVILEGE\n\nFigure 11. Setting special privileges\n\n**Figure 11. Setting special privileges**\nAfter getting the privileges it will check if it has SYSTEM privileges, checking the token of its\nown process. If it is SYSTEM, it will get the appropriate user for logon with the function\n“WTSQueryUserToken”. This function only can be used if the caller has “SeTcbPrivilege”\nthat, by default, only SYSTEM has.\n\nFigure 12. Obtaining the token of the logged on user\n\n**Figure 12. Obtaining the token of the logged on user**\nAfter getting the token of the logged on user the malware will open the Windows station and\ndesktop.\n\nIn the case that it does not have SYSTEM permissions it will enumerate all processes in the\nsystem and try to duplicate the token from “explorer.exe” (the name is checked using a\nhardcoded hash), if it has rights it will continue normally, otherwise it will check again if the\n\n\n-----\n\ntoken that was duplicated has administrator rights.\n\nIn this case it will continue normally but in other cases it will check the operating system\nversion and the CPU (Central Processing Unit) mode (32- or 64- bits). This check is done\nusing the function “ZwQueryInformationProcess” with the class 0x1A\n(ProcessWow64Information).\n\nFigure 13. Checking if the operating system is 32- or 64-bits\n\n**Figure 13. Checking if the operating system is 32- or 64-bits**\nIn the case that the system is 32-bits it will decrypt one little shellcode that will inject in one\nprocess that will enumerate using the typical “CreateRemoteThread” function. This shellcode\nwill be used to get the token of the process and elevate privileges.\n\nIn the case that the system is 64-bits it will decrypt two different shellcodes and will execute\nthe first one that gets the second shellcode as an argument.\n\nFigure 14. BlackMatter preparing shellcodes to steal system token\n\n**Figure 14. BlackMatter preparing shellcodes to steal system token**\nThese shellcodes will allow BlackMatter to elevate privileges in a clean way.\n\nIs important to understand that to get the SYSTEM token BlackMatter will enumerate the\nprocesses and get “svchost.exe”, but not only will it check the name of the process, it will\nalso check that the process has the privilege “SeTcbPrivilege”. As only SYSTEM has it by\ndefault (and it is one permission that cannot be removed from this “user”) it will be that this\nprocess is running under SYSTEM and so it becomes the perfect target to attack with the\nshellcodes and steal the token that will be duplicated and set for BlackMatter.\n\nFigure 15.Checking if the target process is SYSTEM\n\n**Figure 15. Checking if the target process is SYSTEM**\nAfter this it will decrypt the configuration that it has embedded in one section. BlackMatter\nhas this configuration encrypted and encoded in base64.\n\nThis configuration has a remarkably similar structure to Darkside, offering another clear hint\nthat the developers are one and the same, despite their claims to the contrary.\n\nAfter decryption, the configuration can get this information:\n\n\n-----\n\n**RSA Key used to protect the Salsa20 keys used to encrypt the files.**\n**A 16-byte hex value that remarks the victim id.**\n**A 16-byte hex value that is the AES key that will be used to encrypt the**\n**information that will be sent to the C2.**\n**An 8/9-byte array with the behavior flags to control the ransomware behavior.**\n**A special array of DWORDs (values of 4 bytes each one) that keep the values**\n**to reach the critical points in the configuration.**\n**Different blocks encoded and, sometimes, encrypted again to offer the field**\n**more protection.**\n\nAfter getting the configuration and parsing it, BlackMatter will start checking if it needs to\nmake a login with some user that is in the configuration. In this case it will use the function\n“LogonUser” with the information of the user(s) that are kept in the configuration; this\ninformation has one user and one password: “test@enterprise.com:12345” where “test” is\nthe user, “@enterprise.com” is the domain and “12345” the password.\n\nThe next action will be to check with the flag to see if a mutex needs to be created to avoid\nhaving multiple instances.\n\nThis mutex is unique per machine and is based in the registry entry “MachineGuid” in the key\n“Cryptography”. If the system has this mutex already the malware will finish itself.\n\nMaking a vaccine with a mutex can sometimes be useful but not in this case as the\ndevelopers change the algorithm and only need to set the flag to false to avoid creating it.\n\nFigure 16. Creation of the mutex to avoid multiple instances\n\n**Figure 16. Creation of the mutex to avoid multiple instances**\nAfter, it will check if it needs to send information to the C2. If it does (usually, but not always)\nit will get information of the victim machine, such as username, computer name, size of the\nhard disks, and other information that is useful to the malware developers to know how many\nmachines are infected.\n\nThis information is encoded with base64 and encrypted with AES using the key in the\nconfiguration.\n\nFigure 17. Encrypted information sent to the C2\n\n**Figure 17. Encrypted information sent to the C2**\nThe C2 addresses are in the configuration (but not all samples have them, in this case the\nflag to send is false). The malware will try to connect to the C2 using a normal protocol or will\nuse SSL checking the initial “http” of the string.\n\nFigure 18. Get information of the victim machine and user\n\n**Figure 18 Get information of the victim machine and user**\n\n\n-----\n\nThe information is prepared in some strings decrypted from the malware and sent in a POST\nmessage.\n\nFigure 19. Choose to send by HTTP or HTTPS\n\n**Figure 19. Choose to send by HTTP or HTTPS**\nThe message has values to mislead checks and to try and hide the true information as\ngarbage. This “fake” data is calculated randomly.\n\nThe C2 returns garbage data but the malware will check if it starts and ends with the\ncharacters “{“ and “}”; if it does the malware will ignore sending the information to another\nC2.\n\nFigure 20. Checking for a reply from the C2 after sending\n\n**Figure 20. Checking for a reply from the C2 after sending**\nBlackMatter is a multithread application and the procedure to send data to the C2 is done by\na secondary thread.\n\nAfter that, BlackMatter will enumerate all units that are FIXED and REMOVABLE to destroy\nthe recycle bin contents. The malware makes it for each unit that has it and are the correct\ntype. One difference with DarkSide is that it has a flag for this behavior while BlackMatter\ndoes not.\n\nThe next action is to delete the shadow volumes using COM to try and avoid detection using\nthe normal programs to manage the shadow volumes. This differs with DarkSide that has a\nflag for this purpose.\n\nFigure 21. Destruction of the shadow volumes using COM\n\n**Figure 21. Destruction of the shadow volumes using COM**\nBlackMatter will check another flag and will enumerate all services based on one list in the\nconfiguration and will stop target services and delete them.\n\nThis behavior is the same as DarkSide.\n\nFigure 22. Stopping services and deleting them\n\n**Figure 22. Stopping services and deleting them**\nProcesses will be checked and terminated as with DarkSide, based on other configuration\nflags.\n\nAfter terminating the processes BlackMatter will stop the threads from entering suspension\nor hibernating if someone is using the computer to prevent either of those outcomes\noccurring when it is encrypting files. This is done using the function\n“ZwSetThreadExecutionState”.\n\n\n-----\n\nFigure 23. Preventing the machine being suspended or hibernated\n\n**Figure 23. Preventing the machine being suspended or hibernated**\nThe next action will be to enumerate all units, fixed and on the network, and create threads\nto encrypt the files. BlackMatter uses Salsa20 to encrypt some part of the file and will save a\nnew block in the end of the file, protected with the RSA key embedded in the configuration\nwith the Salsa20 keys used to encrypt it. This makes BlackMatter slower than many other\nransomwares.\n\nAfter the encryption it will send to the C2 all information about the encryption process, how\nmany files were crypted, how many files failed, and so on. This information is sent in the\nmanner previously described, but only if the config is set to true.\n\nFigure 24. Release of the mutex\n\n**Figure 24. Release of the mutex**\nIf one mutex was created in this moment it will be released. Later it will check the way that\nthe machine boots with the function “GetSystemMetrics”. If the boot was done in Safe Mode\nBlackMatter will set some keys for persistence in the registry for the next reboot and then\nattack the system, changing the desktop wallpaper.\n\nFigure 25. Determining whether the system boots in safe mode or normal mode\n\n**Figure 25. Determining whether the system boots in safe mode or normal mode**\nOf course, it will disable the safeboot options in the machine and reboot it (it is one of the\nreasons why it needs the privilege of shutdown).\n\nTo ensure it can launch in safe mode, the persistence key value with the path of the malware\nwill start with a ‘*’.\n\nFigure 26. Setting the persistance registry key\n\n**Figure 26. Setting the persistance registry key**\nIf the machine starts in the normal way, it will change the desktop wallpaper with an\nalternative generated in runtime with some text about the ransom note.\n\nFigure 27. BlackMatter makes the new wallpaper in runtime\n\n**Figure 27. BlackMatter makes the new wallpaper in runtime**\n\n## VERSIONS 1.9 AND 2.0\n\nThe new versions have some differences compared with versions 1.2 to 1.6:\n\n\n-----\n\nChanges in the stub generation code. Previously only one type of stub was used, but in\nmore recent versions several types of stubs are employed, with one chosen randomly\nper function. Anyways the stubs can be removed without any problem by patching the\nbinary.\nA new byte flag in the configuration that remarks if it needs to print the ransom note\nusing the available printer in the system. Very similar to Ryuk but instead BlackMatter\nuses APIs from “winspool.drv”.\nRemoved one C2 domain that was shut down by the provider.\n\nAdditional changes in version 2.0:\n\nThis version changes the crypto algorithm to protect the configuration making it more\ncomplex to decrypt it.\nRemoved the last C2 that was shut down by the provider.\nAdded a new C2 domain.\n\nThese changes suggest the developers are active on social media, with an interest in\nmalware and security researchers.\n\n## VACCINE\n\nUnlike some ransomware we’ve seen in the past, such as\n\n\n**Technique**\n**ID**\n\n\n**Technique**\n**Description**\n\n\n**Observable**\n\n\n[T1134](https://attack.mitre.org/techniques/T1134) Access Token\nManipulation\n\n[T1486](https://attack.mitre.org/techniques/T1486/) Data Encrypted\nfor Impact\n\n[T1083](https://attack.mitre.org/techniques/T1083/) File and Directory\nDiscovery\n\n[T1222.001](https://attack.mitre.org/techniques/T1222/001) Windows File and\nDirectory\nPermissions\nModification\n\n[T1562.001](https://attack.mitre.org/techniques/T1562/001) Disable or Modify\nTools\n\n\nBlackMatter accesses and manipulates different\nprocess tokens.\n\n\nBlackMatter stops services related to endpoint security\nsoftware.\n\n\nBlackMatter encrypts files using a custom Salsa20\nalgorithm and RSA.\n\n\nBlackMatter uses native functions to enumerate files\nand directories searching for targets to encrypt.\n\n\nBlackMatter executes the command icacls\n“<DriveLetter>:\\*” /grant Everyone: F /T /C /Q to grant\nfull access to the drive.\n\n\n[T1106](https://attack.mitre.org/techniques/T1106) Native API BlackMatter uses native API functions in all code.\n\n\n[T1057](https://attack.mitre.org/techniques/T1057/) Process\nDiscovery\n\n\nBlackMatter enumerates all processes to try to discover\nsecurity programs and terminate them.\n\n\n-----\n\n[T1489](https://attack.mitre.org/techniques/T1489) Service Stop BlackMatter stops services.\n\n[T1497.001](https://attack.mitre.org/techniques/T1497/001/) System Checks BlackMatter tries to detect debuggers, checking the\nmemory reserved in the heap.\n\n\n[T1135](https://attack.mitre.org/techniques/T1135/) Network Share\nDiscovery\n\n[T1082](https://attack.mitre.org/techniques/T1082/) System\nInformation\nDiscovery\n\n[T1592](https://attack.mitre.org/techniques/T1592/) Gather Victim\nHost Information\n\n\nBlackMatter will attempt to discover network shares by\nbuilding a UNC path in the following format for each\ndriver letter, from A to Z: \\\\<IP>\\<drive letter>$\n\n\nBlackMatter retrieves information about the user and\nmachine.\n\n\nBlackMatter uses functions to retrieve information about\nthe target system.\n\n\n[T1070](https://attack.mitre.org/techniques/T1070/) Valid Accounts BlackMatter uses valid accounts to logon to the victim\nnetwork.\n\n\n[T1547](https://attack.mitre.org/techniques/T1547/) Boot or Logon\nAutostart\nExecution\n\n\nBlackMatter installs persistence in the registry.\n\n\n[T1102](https://attack.mitre.org/techniques/T1102/) Query Registry BlackMatter queries the registry for information.\n\n\n[T1018](https://attack.mitre.org/techniques/T1018/) Remote System\nDiscovery\n\n\nBlackMatter enumerates remote machines in the\ndomain.\n\n\n[T1112](https://attack.mitre.org/techniques/T1112/) Modify Registry BlackMatter changes registry keys and values and sets\nnew ones.\n\n## CONCLUSION\n\nBlackMatter is a new threat in the ransomware field and its developers know full well how to\nuse it to attack their targets. The coding style is remarkably similar to DarkSide and, in our\nopinion, the people behind it are either the same or have a very close relationship.\n\nBlackMatter shares a lot of ideas, and to some degree code, with DarkSide:\n\nConfigurations are remarkably similar, especially with the last version of Darkside,\nbesides the change in the algorithm to protect it which, despite having less options,\nremains with the same structure. We do not think that the developers of BlackMatter\nachieved this similarity by reversing DarkSide as that level of coding skill would have\nallowed them to create an entirely new ransomware from the ground up. Also, the idea\nthat the DarkSide developers gave or sold the original code to them does not make any\nsense as it is an old product.\nDynamic functions are used in a similar way to DarkSide.\nIt uses the same compression algorithm for the configuration.\n\n\n-----\n\nThe victim id is kept in the same way as DarkSide.\n\nIt is important to keep your McAfee Enterprise products updated to the latest detections and\navoid insecure remote desktop connections, maintain secure passwords that are changed on\na regular basis, take precautions against phishing emails, and do not connect unnecessary\ndevices to the enterprise network.\n\nDespite some effective coding, mistakes have been made by the developers, allowing the\nprogram to be read, and a vaccine to be created, though we will stress again that it can\naffect other programs and is not a permanent solution and should be employed only if you\naccept the risks associated with it.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-22 - BlackMatter Ransomware Analysis; The Dark Side Returns.pdf"
    ],
    "report_names": [
        "2021-09-22 - BlackMatter Ransomware Analysis; The Dark Side Returns.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "2864e40a-f233-4618-ac61-b03760a41cbb",
            "created_at": "2023-12-01T02:02:34.272108Z",
            "updated_at": "2025-03-27T02:02:10.209072Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "ETDA:WildCard",
            "tools": [
                "RustDown",
                "SysJoker"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "256a6a2d-e8a2-4497-b399-628a7fad4b3e",
            "created_at": "2023-11-30T02:00:07.299845Z",
            "updated_at": "2025-03-27T02:00:03.257794Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "MISPGALAXY:WildCard",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535623,
    "ts_updated_at": 1743041799,
    "ts_creation_date": 1653756397,
    "ts_modification_date": 1653756397,
    "files": {
        "pdf": "https://archive.orkl.eu/d5866f9ff9403efef730546649932580df8ef54d.pdf",
        "text": "https://archive.orkl.eu/d5866f9ff9403efef730546649932580df8ef54d.txt",
        "img": "https://archive.orkl.eu/d5866f9ff9403efef730546649932580df8ef54d.jpg"
    }
}