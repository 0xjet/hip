{
    "id": "640724a7-757c-4cc9-8f4f-1cc011f48000",
    "created_at": "2023-01-12T15:01:45.987823Z",
    "updated_at": "2025-03-27T02:16:34.801779Z",
    "deleted_at": null,
    "sha1_hash": "3db22112e7bc1679530e35d7a430889ab51a507a",
    "title": "2021-09-27 - FoggyWeb- Targeted NOBELIUM malware leads to persistent backdoor",
    "authors": "",
    "file_creation_date": "2022-05-28T16:49:43Z",
    "file_modification_date": "2022-05-28T16:49:43Z",
    "file_size": 3837654,
    "plain_text": "# FoggyWeb: Targeted NOBELIUM malware leads to persistent backdoor\n\n**[microsoft.com/security/blog/2021/09/27/foggyweb-targeted-nobelium-malware-leads-to-persistent-backdoor/](https://www.microsoft.com/security/blog/2021/09/27/foggyweb-targeted-nobelium-malware-leads-to-persistent-backdoor/)**\n\nSeptember 27, 2021\n\nMicrosoft continues to work with partners and customers to track and expand our knowledge of the threat actor\nwe refer to as NOBELIUM, the actor behind the SUNBURST backdoor, TEARDROP malware, and related\ncomponents. As we stated before, we suspect that NOBELIUM can draw from significant operational resources\noften showcased in their campaigns, including custom-built malware and tools. In March 2021, we profiled\nNOBELIUM’s [GoldMax, GoldFinder, and Sibot malware, which it uses for layered persistence. We then followed](https://www.microsoft.com/security/blog/2021/03/04/goldmax-goldfinder-sibot-analyzing-nobelium-malware/)\nthat up with another post in May, when we analyzed the actor’s early-stage toolset comprising EnvyScout,\nBoomBox, NativeZone, and VaporRage.\n\nThis blog is another in-depth analysis of newly detected NOBELIUM malware: a post-exploitation backdoor that\nMicrosoft Threat Intelligence Center (MSTIC) refers to as FoggyWeb. As mentioned in previous blogs,\nNOBELIUM employs multiple tactics to pursue credential theft with the objective of gaining admin-level access to\n[Active Directory Federation Services (AD FS) servers. Once NOBELIUM obtains credentials and successfully](https://docs.microsoft.com/windows-server/identity/active-directory-federation-services)\ncompromises a server, the actor relies on that access to maintain persistence and deepen its infiltration using\nsophisticated malware and tools. NOBELIUM uses FoggyWeb to remotely exfiltrate the configuration database\n[of compromised AD FS servers, decrypted token-signing certificate, and](https://docs.microsoft.com/windows-server/identity/ad-fs/design/token-signing-certificates) [token-decryption certificate, as well as](https://docs.microsoft.com/windows-server/identity/ad-fs/design/certificate-requirements-for-federation-servers)\nto download and execute additional components. Use of FoggyWeb has been observed in the wild as early as\nApril 2021.\n\nMicrosoft has notified all customers observed being targeted or compromised by this activity. If you believe your\norganization has been compromised, we recommend that you\n\nAudit your on-premises and cloud infrastructure, including configuration, per-user and per-app settings,\nforwarding rules, and other changes the actor might have made to maintain their access\nRemove user and app access, review configurations for each, and re-issue new, strong credentials\nfollowing documented industry best practices.\n\n\n-----\n\nUse a [hardware security module (HSM) as described in securing AD FS servers to prevent the exfiltration](https://docs.microsoft.com/windows-server/identity/ad-fs/deployment/best-practices-securing-ad-fs#hardware-security-module-hsm)\nof secrets by FoggyWeb.\n\nMicrosoft security products have implemented detections and protections against this malware. Indicators of\ncompromise (IOCs), mitigation guidance, detection details, and hunting queries for Azure Sentinel and Microsoft\n365 Defender customers are provided at the end of this analysis and in the product portals. Active Directory\n[Federation Services (AD FS) servers run on-premises and customers can also follow detailed guidance on](https://docs.microsoft.com/en-us/windows-server/identity/active-directory-federation-services)\n[securing AD FS servers against attacks.](https://docs.microsoft.com/windows-server/identity/ad-fs/deployment/best-practices-securing-ad-fs)\n\n## FoggyWeb: Backdoor targeting AD FS\n\nFoggyWeb is a passive and highly targeted backdoor capable of remotely exfiltrating sensitive information from a\ncompromised AD FS server. It can also receive additional malicious components from a command-and-control\n(C2) server and execute them on the compromised server.\n\nAfter compromising an AD FS server, NOBELIUM was observed dropping the following two files on the system\n(administrative privileges are required to write these files to the folders listed below):\n\n_%WinDir%\\ADFS\\version.dll_\n_%WinDir%\\SystemResources\\Windows.Data.TimeZones\\pris\\Windows.Data.TimeZones.zh-PH.pri_\n\nFoggyWeb is stored in the encrypted file Windows.Data.TimeZones.zh-PH.pri, while the malicious file version.dll\ncan be described as its loader. The AD FS service executable Microsoft.IdentityServer.ServiceHost.exe loads\n[the said DLL file via the DLL search order hijacking technique that involves the core Common Language](https://attack.mitre.org/techniques/T1574/001/)\nRuntime (CLR) DLL files (described in detail in the FoggyWeb loader section). This loader is responsible for\nloading the encrypted FoggyWeb backdoor file and utilizing a custom Lightweight Encryption Algorithm (LEA)\nroutine to decrypt the backdoor in memory.\n\nAfter de-obfuscating the backdoor, the loader proceeds to load FoggyWeb in the execution context of the AD FS\napplication. The loader, an unmanaged application, leverages the CLR hosting interfaces and APIs to load the\nbackdoor, a managed DLL, in the same Application Domain within which the legitimate AD FS managed code is\nexecuted. This grants the backdoor access to the AD FS codebase and resources, including the AD FS\nconfiguration database (as it inherits the AD FS service account permissions required to access the configuration\ndatabase).\n\n\n-----\n\nWhen loaded, the FoggyWeb backdoor (originally named Microsoft.IdentityServer.WebExtension.dll by its\ndeveloper) functions as a passive and persistent backdoor that allows abuse of the Security Assertion Markup\nLanguage (SAML) token. The backdoor configures HTTP listeners for actor-defined URIs that mimic the\nstructure of the legitimate URIs used by the target’s AD FS deployment. The custom listeners passively monitor\nall incoming HTTP GET and POST requests sent to the AD FS server from the intranet/internet and intercept\nHTTP requests that match the custom URI patterns defined by the actor. This version of FoggyWeb configures\nlisteners for the following hardcoded URI patterns (which might vary per target):\n\nHTTP GET URI pattern:\n\n_/adfs/portal/images/theme/light01/profile.webp_\n_/adfs/portal/images/theme/light01/background.webp_\n_/adfs/portal/images/theme/light01/logo.webp_\nHTTP POST URI pattern:\n\n_/adfs/services/trust/2005/samlmixed/upload_\n\nEach HTTP GET/POST URI pattern above corresponds to a C2 command:\n\nWhen the AD FS server receives an HTTP GET request containing the URI pattern\n_/adfs/portal/images/theme/light01/profile.webp, the backdoor retrieves the token signing certificate of the_\ncompromised AD FS server and then obfuscates and returns the certificate to the issuer of the request.\nSimilarly, when the AD FS server receives an HTTP GET request containing the URI pattern\n_/adfs/portal/images/theme/light01/background.webp, the backdoor retrieves the token decryption_\n**_certificate of the compromised AD FS server and then obfuscates and returns the certificate to the issuer_**\nof the request.\nWhen the AD FS server receives an HTTP GET request containing the URI pattern\n_/adfs/portal/images/theme/light01/logo.webp, the backdoor retrieves the AD FS configuration data of the_\ncompromised server, obfuscates the data, and returns the obfuscated data to the issuer of the request.\nWhen the AD FS server receives an HTTP POST request containing the URI pattern\n_/adfs/services/trust/2005/samlmixed/upload, the backdoor treats the obfuscated and compressed POST_\ndata as either .NET assembly or source code. If assembly, the backdoor executes the assembly in the\nexecution context of the AD FS process. If source code, the backdoor dynamically compiles the source\ncode and proceeds to execute the resulting memory-resident assembly in the execution context of the AD\nFS process.\n\nThe diagram below illustrates the methodology used by the actor to communicate with the FoggyWeb backdoor\nlocated on a compromised internet-facing AD FS server.\n\n\n-----\n\nSince FoggyWeb runs in the context of the main AD FS process, it inherits the AD FS service account\npermissions required to access the AD FS configuration database. This contrasts with tools such as ADFSDump\nthat must be executed under the user context of the AD FS service account. Also, because FoggyWeb is loaded\ninto the same application domain as the AD FS managed code, it gains programmatical access to the legitimate\nAD FS classes, methods, properties, fields, objects, and components that are subsequently leveraged by\nFoggyWeb to facilitate its malicious operations. For example, this allows FoggyWeb to gain access to the AD FS\nconfiguration data without connecting to the WID named pipe or manually running SQL queries to retrieve\nconfiguration information (for example, to obtain the EncryptedPfx blob from the configuration data). FoggyWeb\nis also AD FS version-agnostic; it does not need to keep track of legacy versus modern configuration table\nnames and schemas, named pipe names, and other version-dependent properties of AD FS.\n\n### FoggyWeb loader\n\nThe file version.dll is a malicious loader responsible for loading an encrypted backdoor file from the file system,\ndecrypting the backdoor file, and loading it in memory. This malicious DLL, which shares a name with a\nlegitimate Windows DLL located in the %WinDir%\\System32\\ folder, is meant to be placed in the main AD FS\nfolder %WinDir%\\ADFS\\, where the AD FS service executable Microsoft.IdentityServer.ServiceHost.exe is\nlocated (for reasons described later in this section).\n\nWhen the AD FS service (adfssrv) is started, the service executable Microsoft.IdentityServer.ServiceHost.exe\ngets executed. As a .NET-based managed application, Microsoft.IdentityServer.ServiceHost.exe imports an\nunmanaged Windows DLL named mscoree.dll.\n\nThe file mscoree.dll dynamically loads another unmanaged Windows/CLR DLL named mscoreei.dll. As shown\nbelow, mscoreei.dll has a delay load import (Delay Import) named version.dll.\n\n\n-----\n\nNOBELIUM, with existing administrative permissions, was observed to drop a malicious loader named version.dll\nin the %WinDir%\\ADFS\\ folder where the AD FS service executable Microsoft.IdentityServer.ServiceHost.exe is\nlocated. Once the system or the AD FS service is restarted, Microsoft.IdentityServer.ServiceHost.exe loads\n_mscoree.dll, which in turn loads mscoreei.dll. As mentioned above, mscoreei.dll has a delay load import named_\n_version.dll. Once loaded, instead of loading the legitimate version.dll from the %WinDir%\\System32\\ folder_\n_mscoreei.dll loads the malicious version.dll planted by the attacker in %WinDir%\\ADFS\\ folder (referred to as_\n[DLL search order hijacking), as shown in the call stack below.](https://attack.mitre.org/techniques/T1574/001/)\n\nThe malicious loader version.dll behaves as a proxy for all legitimate version.dll export function calls. As shown\nbelow, it exports the same 17 function names as the legitimate version of version.dll.\n\n\n-----\n\nThe export functions of the malicious version.dll are all short stubs that call a single trampoline function labeled\n_TrampolineFunction, as seen in the screenshot below._\n\nBelow is a pseudocode for the trampoline function.\n\nThis trampoline function is responsible for the following:\n\nCalling a function (labeled as LoadDecryptExecuteBackdoor() by the analyst) to load a backdoor file from\nthe file system, and then decrypting and executing the file in memory\nTransferring execution to the initially called target function from the legitimate version of version.dll.\n\nThe trampoline function preserves the value of the arguments/registers intended for the function from the\nlegitimate version of version.dll by saving the value of certain CPU registers. It first pushes them onto the stack\nbefore calling the LoadDecryptExecuteBackdoor() function above and then restoring them before transferring\nexecution to the function from the legitimate version of version.dll.\n\n\n-----\n\nWhen called, LoadDecryptExecuteBackdoor() attempts to create a Windows event named {2783c149-77a7_5e51-0d83-ac0566daff96} to ensure that only one copy of the loader is actively running on the system. In a new_\nthread, it then checks if the following file is present (hardcoded path string):\n\n_C:\\Windows\\SystemResources\\Windows.Data.TimeZones\\pris\\Windows.Data.TimeZones.zh-PH.pri_\n\n_Windows.Data.TimeZones.zh-PH.pri is an encrypted backdoor file that is placed in the folder above. MSTIC_\nrefers to this backdoor file as FoggyWeb, and our analysis is in the next section.\n\n_Microsoft.IdentityServer.ServiceHost.exe in and of itself is an unmanaged Windows executable that is generated_\nwhen the high-level AD FS managed code is compiled. When executed, the unmanaged code inside\n_Microsoft.IdentityServer.ServiceHost.exe leverages Common Language Runtime (CLR) to run the managed AD_\nFS code within a virtual runtime environment. This virtual runtime environment is comprised of one or more\napplication domains, which provide a unit of isolation for the runtime environment and allow different applications\nto run inside separate containers within a process. The managed AD FS code is executed within an application\ndomain inside the virtual runtime environment.\n\nThe FoggyWeb backdoor (also a managed DLL) is intended to run alongside the legitimate AD FS code (that is,\nwithin the same application domain). This means that for the FoggyWeb loader to load the backdoor alongside\nthe AD FS code, it needs to gain access to the same application domain that the AD FS code is executed within.\nSince the FoggyWeb loader version.dll is an unmanaged application, it cannot directly access the virtual runtime\nenvironment that the managed AD FS code is executed within. The loader overcomes this limitation and loads\nthe backdoor alongside the AD FS code by leveraging the CLR hosting interfaces and APIs to access the virtual\nruntime environment within which the AD FS code is executed.\n\nThe loader performs the following high-level actions:\n\nEnumerate all CLRs loaded in the AD FS process Microsoft.IdentityServer.ServiceHost.exe\nFor each CLR, enumerate all running application domains and perform the following actions for each\ndomain:\n\nRead the contents of the following encrypted FoggyWeb backdoor file into memory:\n_C:\\Windows\\SystemResources\\Windows.Data.TimeZones\\pris\\Windows.Data.TimeZones.zh-PH.pri_\nDecrypt the encrypted FoggyWeb backdoor file using the Lightweight Encryption Algorithm (LEA).\nThe LEA-128 key schedule uses the following hardcoded master key to generate the round keys:\n\n\n-----\n\nAfter decrypting each 16-byte cipher block, the loader uses the following XOR key to decode each individual\ndecrypted/plaintext block:\n\nThis is equivalent to first LEA decrypting the entire file and then XOR decoding the decrypted data (instead of\ndecrypting and XOR decoding each individual 16-byte block).\n\nCreate a Safe Array and copy the decrypted FoggyWeb backdoor bytes to the array. It then calls the\n_Load() function for the current application domain to load the FoggyWeb DLL into the application_\ndomain. After the FoggyWeb DLL is loaded into the current application domain, the loader invokes\nthe following method from the DLL: Microsoft.IdentityServer.WebExtension.WebHost.\n\nAt this point in the execution cycle, the FoggyWeb DLL is loaded into one or more application domains where the\nlegitimate AD FS code is running. This means the backdoor code runs alongside the AD FS code with the same\naccess and permissions as the AD FS application. Because the backdoor is loaded in the same application\ndomain as the AD FS code, it gains programmatical access to the legitimate classes, methods, properties, fields,\nobjects, and components used by various AD FS modules to carry out their legitimate functionality. Such access\nallows the FoggyWeb backdoor to directly interact with the AD FS codebase (that is, not an external diskresident tool) and selectively invoke native AD FS methods needed to facilitate its malicious operations.\n\n### FoggyWeb backdoor\n\nThis malicious memory-resident DLL (originally named Microsoft.IdentityServer.WebExtension.dll by its\ndeveloper) functions as a backdoor targeting AD FS. It is loaded by the main AD FS service process\n_Microsoft.IdentityServer.ServiceHost.exe through a malicious loader component._\n\nWhen loaded, the backdoor starts an HTTP listener that listens for HTTP GET and POST requests containing\nthe following URI patterns:\n\nHTTP GET URI pattern: /adfs/portal/images/theme/light01/\nHTTP POST URI pattern: /adfs/services/trust/2005/samlmixed/upload\n\nAs shown below, the URI patterns are hardcoded in the backdoor and mimic the structure of the legitimate URIs\nused by the target’s AD FS deployment.\n\nOnce the backdoor receives an HTTP request that contains one of the URI patterns above, the listener proceeds\nto handle the request using either an HTTP GET or HTTP POST callback/handler method (ProcessGetRequest()\nand ProcessGetRequest(), respectively).\n\n\n-----\n\n**HTTP GET handler**\n\nThe incoming HTTP GET requests that contain the URI pattern /adfs/portal/images/theme/light01/ are handled\nby backdoor’s ProcessGetRequest() method.\n\nIf an incoming HTTP GET request is issued for a file/resource with the file extension of .webp, the\n_ProcessGetRequest() method proceeds to handle the request. Otherwise, the request is ignored by the_\nbackdoor. Also, if the requested file name matches one of the three hardcoded names below, the backdoor treats\nthe request as a C2 command issued by the attacker.\n\nThe following URL patterns are treated as C2 commands:\n\n_/adfs/portal/images/theme/light01/profile.webp_\n_/adfs/portal/images/theme/light01/background.webp_\n_/adfs/portal/images/theme/light01/logo.webp_\n\nThe first two C2 commands, profile.webp and background.webp (UrlGetFileNames[0] and UrlGetFileNames[1] in\nthe screenshot above), are handled by calling the backdoor’s Service.GetCertificate() method.\n\n\n-----\n\nAs the name suggests, this method is responsible for retrieving an AD FS certificate (either the token- signing or\nthe token encryption certificate, depending on the value of the certificateType parameter passed to the method)\nfrom the AD FS service configuration database.\n\n**_Analyst note: Refer to the Appendix for an in-depth analysis of the Service.GetCertificate() method and how it_**\n_obtains and decrypts either the token signing or encryption certificate._\n\nAs shown in the screenshot above, when the C2 command profile.webp (UrlGetFileNames[0]) is issued to the\nbackdoor (by issuing an HTTP GET request for the URI /adfs/portal/images/theme/light01/profile.webp), the\nbackdoor retrieves the token-signing certificate of the compromised AD FS server. Similarly, when the C2\ncommand background.webp (UrlGetFileNames[1]) is issued to the backdoor (by issuing an HTTP GET request\nfor the URI /adfs/portal/images/theme/light01/background.webp), the backdoor retrieves the token encryption\n**_certificate of the compromised AD FS server._**\n\nThe third C2 command, logo.webp (UrlGetFileNames[2]), is triggered by sending an HTTP GET request to the\nfollowing URI: /adfs/portal/images/theme/light01/logo.webp. The C2 command is handled by calling the\nbackdoor’s GetInfo() method.\n\nThe GetInfo() method is responsible for dumping the AD FS service configuration data of the compromised\nserver.\n\nAs shown above, the AD FS service configuration data is obtained via the ServiceSettingsData property, which\nretrieves the data from the AD FS service configuration database, Windows Internal Database (WID).\n\nBefore returning the output of the C2 commands (that is, the token-signing certificate, the token encryption\ncertificate, or the AD FS service configuration data) to the C2 in an HTTP 200 response, the backdoor first\nobfuscates the output by calling its method named GetWebpImage().\n\n\n-----\n\nThe GetWebpImage() method is in charge of masquerading the output of the C2 commands as a legitimate\nWebP file (by adding appropriate RIFF/WebP file header magic/fields) and encoding the resulting WebP file.\n\n_GetWebpImage() uses the following helper methods to create and encode the fake WebP file that contains the_\nC2 command output:\n\n_GetWebpImage() first invokes the Webp.GetFrame() method, which is responsible for compressing the_\noutput of the C2 command and copying the compressed version to a new array (0 padded to a multiple of\n32 bytes). The length of the compressed data is added as the first four bytes of the new array.\n\nTo compress the data, GetFrame() invokes the Common.Compress() method, which is used to compress the\ndata by leveraging the C# GZipStream compression class.\n\nFor demonstration purposes, assume the C2 command yields the following data (a 256-byte pseudo-randomly\ngenerated byte array).\n\n\n-----\n\nGiven the data above (that is, sample C2 command output), GetFrame() returns the following byte array.\n\nNext, GetWebpImage() invokes the Webp.GetWebpHeader() method, passing in the size of the byte array\nreturned by GetFrame() in the step above. GetWebpHeader() is responsible for creating and returning an\narray containing custom RIFF WebP file magic/header bytes.\n\nThe array variable above contains the following 32-byte hardcoded RIFF/WebP header bytes.\n\n\n-----\n\nIf the size of the array passed to GetWebpHeader() (returned by GetFrame()) exceeds 8,192 bytes, the bytes at\nindex 26 and 28 of the header bytes (initially set to 0x00) are replaced with 0x80. Otherwise, the bytes at index\n26 and 28 are replaced with 0x40, as shown below.\n\n_GetWebpHeader() then returns the custom RIFF/WebP header above to GetWebpImage()._\n\nNext, GetWebpImage() creates a new array by appending the custom RIFF/WebP header bytes returned\nby GetWebpHeader() to the array returned by GetFrame() (the array containing the compressed version of\nthe C2 command output).\n\n_GetWebpImage() calls the Common.ProtectData() method of the backdoor to encode the portion of the new_\narray that contains the compressed bytes (that is, it does not encode the custom RIFF/WebP header). As the\nsecond argument, GetWebpImage() passes the offset of the first compressed byte to ProtectData() (as shown in\nthe table above, 0x20 or 32 is the offset of the first compressed byte in this case). ProtectData() uses a dynamic\nXOR key and a custom XOR methodology to XOR encode the compressed data.\n\nInitially, the 12-byte hardcoded XOR key array contains the following (seed) bytes.\n\nAs shown in the screenshot above, each byte of compressed data is XOR’d with a byte from the XOR key array.\nThe first byte of the compressed data (0x17) is XOR’d with the XOR key byte located at offset 8 of the key array\n(0x77).\n\n\n-----\n\nAfter XOR ing the first byte of the compressed data with the XOR key byte located at offset 8 of the key array,\nthe XOR key byte itself gets overwritten with a new value.\n\nFor example, the XOR key byte located at offset 8 of the XOR key array (0x77) gets overwritten with 0xEE via\nthe following operations.\n\nThe second byte of the compressed data (0x01) is XOR’d with the XOR key byte located at offset 9 of the key\narray (33 % 12 = 9) and so on until the key rolls to the first byte of the XOR array (as mentioned above, the XOR\nkey bytes get overwritten after each encoding operation). Below is the XOR encoded version of the sample\ncompressed array.\n\nAfter the steps outlined above, GetWebpImage() returns the following sample data to the method that invokes it\nto obfuscate and conceal the output of each C2 command (ProcessGetRequest()).\n\nAs previously mentioned, ProcessGetRequest() returns the fake RIFF/WebP file generated above (containing\nstolen token-signing certificate, token encryption certificate, or the AD FS service configuration data) to the C2 in\nan HTTP 200 response.\n\nIf the backdoor cannot execute a C2 command successfully, it returns an HTTP 404 response to the C2 instead.\n\n**HTTP POST handler**\n\n\n-----\n\nIncoming HTTP POST requests that match the URI pattern /adfs/services/trust/2005/samlmixed/upload are\nhandled by the ProcessPostRequest() method.\n\nThis method ensures that the ContentType value of an incoming HTTP POST request ends with “xml” (caseinsensitive), and the HTTP POST data contains two XML elements named X509Certificate and SignatureValue\n(for example, a blob that starts with the string “<X509Certificate>” and ends with the string “</X509Certificate>”).\n\nIf the XML data contains the two elements, the backdoor performs the following actions:\n\nDecode the values of the SignatureValue and X509Certificate elements by first decoding the values using\nBase64 and then calling the Common.UprotectData() method on each decoded value.\n\nThe UprotectData() method treats the first two bytes of the Base64 decoded value as a two-byte XOR key. It\ninvokes the Common.ProtectData() method (covered in the previous section) on the rest of the data (that is, third\nbyte on) and then uses the two-byte XOR key to XOR decode the data returned by Common.ProtectData(). In\n\n\n-----\n\nother words, UprotectData() leverages Common.ProtectData() to remove the first layer of XOR encoding and\nthen another XOR routine to remove the second layer of XOR encoding applied to the data.\n\nInvoke the Service.ExecuteAssembly() method to handle the decoded SignatureValue and X509Certificate\nvalues. As shown below, the decoded X509Certificate value is the first GZip decompressed/inflated by\ncalling the Common.Decompress() method.\n\nIn a new thread, Service.ExecuteAssembly() calls Service.ExecuteAssemblyRoutine() method to handle the\ndata.\n\n_ExecuteAssemblyRoutine() checks if the decoded X509Certificate value starts with “MZ” (or the bytes 0x4D_\n_0x5A, the hexadecimal representation of the decimal numbers 77 and 90, as seen in the screenshot_\nbelow).\n\n\n-----\n\nIf the decoded X509Certificate value starts with MZ, the backdoor treats the decoded data as a .NET\nbased assembly/payload and proceeds to call its Service.ExecuteBinary() method to load and execute the\nDLL payload in memory. After loading the DLL in memory, ExecuteBinary() proceeds to invoke a specific\nmethod from the loaded DLL. The method name and parameters needed to invoke the method are\nsupplied to the backdoor within the decoded SignatureValue data.\n\nIf the decoded X509Certificate value does not start with MZ, the backdoor treats the decoded X509Certificate\nvalue as source code for a C#-based payload and calls its Service.ExecuteSource() method to dynamically\ncompile and execute the payload in memory.\n\nAfter handling the HTTP POST request containing the XML elements X509Certificate and SignatureValue, the\nbackdoor responds to the request with an HTTP 204 response code. If the HTTP POST does not have the\nelements mentioned above, the backdoor responds to the request with an HTTP 404 response code.\n\n## Appendix: Obtaining and decrypting AD FS tokens\n\nAs the name suggests, the Service.GetCertificate() method is responsible for retrieving an AD FS certificate\n(either the token- signing or the token encryption certificate, depending on the value of the certificateType\nparameter passed to the method) from the AD FS service configuration database.\n\nThe method performs the following actions to retrieve the desired certificate:\n\n\n-----\n\nInvoke another one of its methods named GetServiceSettingsDataProvider() to create an instance of type\n_Microsoft.IdentityServer.PolicyModel.Configuration.ServiceSettingsDataProvider from the already loaded_\nassembly Microsoft.IdentityServer.\n\nInvoke the GetServiceSettings() member/method of the above ServiceSettingsDataProvider instance to\nobtain the AD FS service configuration settings.\n\nObtain the value of the AD FS service settings (from the SecurityTokenService property), extract the value\nof the EncryptedPfx blob from the service settings, and decode the blob using Base64.\n\nInvoke another method named GetAssemblyByName() to enumerate all loaded assemblies by name and\nlocate the already loaded assembly Microsoft.IdentityServer.Service. This method retrieves the value of\ntwo fields named _state and _certificateProtector from an object of type\n_Microsoft.IdentityServer.Service.Configuration.AdministrationServiceState (from the_\n_Microsoft.IdentityServer.Service assembly)._\n\nThe AdministrationServiceState class/object contains configuration information necessary for the execution and\nhandling of client requests. The field _state is used to maintain the current state of the\n_AdministrationServiceState class/object (screenshot from Microsoft.IdentityServer.Service.dll)._\n\nThe AdministrationServiceState object (stored in the _state field) contains another field named\n__certificateProtector._\n\n\n-----\n\nThe field _certificateProtector stores an instance of the Data Protector class DkmDataProtector for Distributed\nKey Management (DKM). The DkmDataProtector class implements a method named Unprotect(), which\nultimately calls the Unprotect() method of DKM/IDKM (screenshot from Microsoft.IdentityServer.dll).\n\nThe DKM Unprotect() method inherits a method named Unprotect() from Microsoft.IdentityServer.Dkm.DKMBase\n(screenshot from Microsoft.IdentityServer.Dkm.dll).\n\nThe Unprotect() method from Microsoft.IdentityServer.Dkm.DKMBase (shown above) provides the functionality\nto decrypt the encrypted certificate (a PKCS12 object) stored in the EncryptedPfx blob.\n\nArmed with the knowledge about the availability of the Unprotect() method accessible via the\n__certificateProtector field, the backdoor invokes the Unprotect() method to decrypt the encrypted certificate_\nstored in the EncryptedPfx blob of the desired certificate type (either the AD FS token signing or encryption\ncertificate).\n\nA variant of the technique described in this Appendix was publicly presented by Douglas Bienstock and Austin\nBaker at the TROOPERS conference in 2019 (I am AD FS and so can you: Attacking Active Directory Federated\nServices). However, the method used by FoggyWeb differs from the publicly presented method, in that\nFoggyWeb leverages the _state and _certificateProtector fields from the AdministrationServiceState class/object\nto facilitate access to the Data Protector class DkmDataProtector (used to gain access to and invoke the\n_Unprotect() method)._\n\n## Indicators of compromise (IOCs)\n\n\n-----\n\n**Type** **Threat**\n**Name**\n\n\n**Threat**\n**Type**\n\n\n**Indicator**\n\n\nMD5 FoggyWeb Loader 5d5a1b4fafaf0451151d552d8eeb73ec\n\n\nSHA1\n\nSHA256\n\n\nFoggyWeb Loader c896ece073dd01191cbc1d462bc2f47161828a83\n\nFoggyWeb Loader 231b5517b583de102cde59630c3bf938155d17037162f663874e4662af2481b1\n\n\nMD5 FoggyWeb Backdoor\n(encrypted)\n\n\nSHA1\n\nSHA256\n\n\nFoggyWeb Backdoor\n(encrypted)\n\nFoggyWeb Backdoor\n(encrypted)\n\n\nMD5 FoggyWeb Backdoor\n(decrypted)\n\n\nSHA1\n\nSHA256\n\n\nFoggyWeb Backdoor\n(decrypted)\n\nFoggyWeb Backdoor\n(decrypted)\n\n\n9ff9401315d0f7258a9fcde0cfdef02b\n\n4597431f26424cb814c917168fa8d74d01ab7cd1\n\nda0be762bb785085d36aec80ef1697e25fb15414514768b3bcaf798dd9c9b169\n\ne9671d294ce41fe6dbb9637dc0157a88\n\n85cfeccbb48fd9f498d24711c66e458e0a80cc90\n\n568392bd815de9b677788addfc4fa4b0a5847464b9208d2093a8623bbecd81e6\n\n\n## Mitigations\n\nCustomers should review their AD FS Server configuration and implement changes to secure these systems\nfrom attacks:\n\n[Best Practices for securing AD FS and Web Application Proxy](https://docs.microsoft.com/windows-server/identity/ad-fs/deployment/best-practices-securing-ad-fs)\n\nWe strongly recommend for organizations to harden and secure AD FS deployments through the following best\npractices:\n\nEnsure only Active Directory Admins and AD FS Admins have admin rights to the AD FS system.\nReduce local Administrators’ group membership on all AD FS servers.\nRequire all cloud admins to use multi-factor authentication (MFA).\nEnsure minimal administration capability via agents.\nLimit on-network access via host firewall.\nEnsure AD FS Admins use Admin Workstations to protect their credentials.\nPlace AD FS server computer objects in a top-level OU that doesn’t also host other servers.\nEnsure that all GPOs that apply to AD FS servers apply only to them and not to any other servers. This\nlimits potential privilege escalation through GPO modification.\nEnsure that the installed certificates are protected against theft. Don’t store these on a share on the\nnetwork and set a calendar reminder to ensure they get renewed before expiring (expired certificate breaks\nfederation auth). Additionally, we recommend protecting signing keys or certificates in a hardware security\nmodule (HSM) attached to AD FS.\nSet logging to the highest level and send the AD FS (and security) logs to a SIEM to correlate with AD\nauthentication as well as Azure AD (or similar).\nRemove unnecessary protocols and Windows features.\n\n\n-----\n\nUse a long (>25 characters) and complex password for the AD FS service account. We recommend using\na [Group Managed Service Account (gMSA) as the service account, as it removes the need for managing](https://docs.microsoft.com/windows-server/security/group-managed-service-accounts/group-managed-service-accounts-overview)\nthe service account password over time by managing it automatically.\nUpdate to the latest AD FS version for security and logging improvements (as always, test first).\n[When federated with Azure AD follow the best practices for securing and](https://docs.microsoft.com/azure/active-directory/hybrid/how-to-connect-install-prerequisites#harden-your-azure-ad-connect-server) [monitoring the AD FS trust with](https://docs.microsoft.com/azure/active-directory/hybrid/how-to-connect-monitor-federation-changes)\nAzure AD.\n\n## Detections\n\nProtecting AD FS servers is key to mitigating NOBELIUM attacks. Detecting and blocking malware, attacker\nactivity, and other malicious artifacts on AD FS servers can break critical steps in known NOBELIUM attack\nchains. Microsoft Defender Antivirus detects the new NOBELIUM components discussed in this blog as the\nfollowing malware:\n\n**Loader: Trojan:Win32/FoggyWeb.A!dha**\n**Backdoor: Trojan:MSIL/FoggyWeb.A!dha**\n\n### Microsoft 365 Defender\n\nEndpoint detection and response (EDR) capabilities in Microsoft Defender for Endpoint detect malicious behavior\nrelated to this malware which is surfaced as alerts with the following titles:\n\nA suspicious DLL was loaded by the ADFS service\nSuspicious service launched\nSuspicious file dropped\n\n### Azure AD Identity Protection\n\nThis kind of attack can also be detected in the cloud using Azure AD Identity Protection. It is recommended that\nyou monitor the [Azure AD Identity Protection Risk detections report for the](https://docs.microsoft.com/azure/active-directory/identity-protection/overview-identity-protection) [“Token Issuer Anomaly” detection.](https://docs.microsoft.com/azure/active-directory/identity-protection/concept-identity-protection-risks#risk-types-and-detection)\nThis detection looks for anomalies in the SAML token presented to the Azure AD tenant.\n\n\n-----\n\n## Advanced hunting queries\n\n### Microsoft Defender for Endpoint\n\nTo locate related activity, run the following advanced hunting queries in Microsoft 365 Defender:\n```\nDeviceImageLoadEvents\n| where FolderPath has @\"C:\\Windows\\ADFS\"\n\n```\n```\n| where FileName has @\"version.dll\"\n\n```\n\n### Azure Sentinel\n\nAzure Sentinel customers can use the following detection queries to look for this activity:\n\nDetection query: https://github.com/Azure/AzureSentinel/tree/master/Detections/MultipleDataSources/Nobelium_FoggyWeb.yaml\n\n[Indicator file: https://github.com/Azure/Azure-Sentinel/tree/master/Sample%20Data/Feeds/FoggyWebIOC.csv](https://github.com/Azure/Azure-Sentinel/tree/master/Sample%20Data/Feeds/FoggyWebIOC.csv)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-27 - FoggyWeb- Targeted NOBELIUM malware leads to persistent backdoor.pdf"
    ],
    "report_names": [
        "2021-09-27 - FoggyWeb- Targeted NOBELIUM malware leads to persistent backdoor.pdf"
    ],
    "threat_actors": [
        {
            "id": "b43e5ea9-d8c8-4efa-b5bf-f1efb37174ba",
            "created_at": "2022-10-25T16:07:24.36191Z",
            "updated_at": "2025-03-27T02:02:10.1909Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "Dark Halo",
                "Nobelium",
                "SolarStorm",
                "StellarParticle",
                "UNC2452"
            ],
            "source_name": "ETDA:UNC2452",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "70872c3a-e788-4b55-a7d6-b2df52001ad0",
            "created_at": "2023-01-06T13:46:39.18401Z",
            "updated_at": "2025-03-27T02:00:03.01553Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "DarkHalo",
                "StellarParticle",
                "NOBELIUM",
                "Solar Phoenix",
                "Midnight Blizzard"
            ],
            "source_name": "MISPGALAXY:UNC2452",
            "tools": [
                "SNOWYAMBER",
                "HALFRIG",
                "QUARTERRIG"
            ],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "1d3f9dec-b033-48a5-8b1e-f67a29429e89",
            "created_at": "2022-10-25T15:50:23.739197Z",
            "updated_at": "2025-03-27T02:00:55.536417Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "UNC2452",
                "NOBELIUM",
                "StellarParticle",
                "Dark Halo"
            ],
            "source_name": "MITRE:UNC2452",
            "tools": [
                "Sibot",
                "Mimikatz",
                "Cobalt Strike",
                "AdFind",
                "GoldMax"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "a241a1ca-2bc9-450b-a07b-aae747ee2710",
            "created_at": "2024-06-19T02:03:08.150052Z",
            "updated_at": "2025-03-27T02:05:17.409596Z",
            "deleted_at": null,
            "main_name": "IRON RITUAL",
            "aliases": [
                "Blue Dev 5 ",
                "BlueBravo ",
                "Cloaked Ursa ",
                "CozyLarch ",
                "Dark Halo ",
                "Midnight Blizzard ",
                "NOBELIUM ",
                "StellarParticle ",
                "UNC2452 ",
                "APT29"
            ],
            "source_name": "Secureworks:IRON RITUAL",
            "tools": [
                " Cobalt Strike",
                " EnvyScout",
                " GoldFinder",
                " GoldMax",
                " NativeZone",
                " RAINDROP",
                " SUNBURST",
                " Sibot",
                " TEARDROP",
                " VaporRage",
                "Brute Ratel C4"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "20d3a08a-3b97-4b2f-90b8-92a89089a57a",
            "created_at": "2022-10-25T15:50:23.548494Z",
            "updated_at": "2025-03-27T02:00:55.49688Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "APT29",
                "IRON RITUAL",
                "IRON HEMLOCK",
                "NobleBaron",
                "Dark Halo",
                "NOBELIUM",
                "UNC2452",
                "YTTRIUM",
                "The Dukes",
                "Cozy Bear",
                "CozyDuke",
                "SolarStorm",
                "Blue Kitsune",
                "UNC3524",
                "Midnight Blizzard"
            ],
            "source_name": "MITRE:APT29",
            "tools": [
                "PinchDuke",
                "ROADTools",
                "WellMail",
                "CozyCar",
                "Mimikatz",
                "Tasklist",
                "OnionDuke",
                "FatDuke",
                "POSHSPY",
                "EnvyScout",
                "SoreFang",
                "GeminiDuke",
                "GoldMax",
                "FoggyWeb",
                "SDelete",
                "PolyglotDuke",
                "AADInternals",
                "MiniDuke",
                "SeaDuke",
                "Sibot",
                "RegDuke",
                "CloudDuke",
                "GoldFinder",
                "AdFind",
                "PsExec",
                "NativeZone",
                "Systeminfo",
                "ipconfig",
                "Impacket",
                "Cobalt Strike",
                "PowerDuke",
                "QUIETEXIT",
                "HAMMERTOSS",
                "BoomBox",
                "CosmicDuke",
                "WellMess",
                "VaporRage",
                "LiteDuke"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "46b3c0fc-fa0c-4d63-a38a-b33a524561fb",
            "created_at": "2023-01-06T13:46:38.393409Z",
            "updated_at": "2025-03-27T02:00:02.822155Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "The Dukes",
                "Minidionis",
                "Grizzly Steppe",
                "G0016",
                "Blue Kitsune",
                "BlueBravo",
                "SeaDuke",
                "Cloaked Ursa",
                "YTTRIUM",
                "ATK7",
                "Nobelium",
                "UAC-0029",
                "Group 100",
                "COZY BEAR",
                "IRON HEMLOCK",
                "TA421",
                "ITG11"
            ],
            "source_name": "MISPGALAXY:APT29",
            "tools": [
                "QUARTERRIG",
                "SNOWYAMBER",
                "HALFRIG"
            ],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f27790ff-4ee0-40a5-9c84-2b523a9d3270",
            "created_at": "2022-10-25T16:07:23.341684Z",
            "updated_at": "2025-03-27T02:02:09.74554Z",
            "deleted_at": null,
            "main_name": "APT 29",
            "aliases": [
                "APT 29",
                "ATK 7",
                "Blue Dev 5",
                "BlueBravo",
                "Cloaked Ursa",
                "CloudLook",
                "Cozy Bear",
                "Dark Halo",
                "Earth Koshchei",
                "Grizzly Steppe",
                "Group 100",
                "ITG11",
                "Iron Hemlock",
                "Iron Ritual",
                "Midnight Blizzard",
                "Minidionis",
                "Nobelium",
                "NobleBaron",
                "Operation Ghost",
                "Operation Office monkeys",
                "Operation StellarParticle",
                "SilverFish",
                "Solar Phoenix",
                "SolarStorm",
                "StellarParticle",
                "TEMP.Monkeys",
                "The Dukes",
                "UNC2452",
                "UNC3524",
                "Yttrium"
            ],
            "source_name": "ETDA:APT 29",
            "tools": [
                "7-Zip",
                "ATI-Agent",
                "AdFind",
                "Agentemis",
                "AtNow",
                "BEATDROP",
                "BotgenStudios",
                "CEELOADER",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobalt Strike",
                "CobaltStrike",
                "CosmicDuke",
                "Cozer",
                "CozyBear",
                "CozyCar",
                "CozyDuke",
                "Danfuan",
                "EnvyScout",
                "EuroAPT",
                "FatDuke",
                "FoggyWeb",
                "GeminiDuke",
                "Geppei",
                "GoldFinder",
                "GoldMax",
                "GraphDrop",
                "GraphicalNeutrino",
                "GraphicalProton",
                "HAMMERTOSS",
                "HammerDuke",
                "LOLBAS",
                "LOLBins",
                "LiteDuke",
                "Living off the Land",
                "MagicWeb",
                "Mimikatz",
                "MiniDionis",
                "MiniDuke",
                "NemesisGemina",
                "NetDuke",
                "OnionDuke",
                "POSHSPY",
                "PinchDuke",
                "PolyglotDuke",
                "PowerDuke",
                "QUIETEXIT",
                "ROOTSAW",
                "RegDuke",
                "Rubeus",
                "SNOWYAMBER",
                "SPICYBEAT",
                "SUNSHUTTLE",
                "SeaDaddy",
                "SeaDask",
                "SeaDesk",
                "SeaDuke",
                "Sharp-SMBExec",
                "SharpView",
                "Sibot",
                "Solorigate",
                "SoreFang",
                "TinyBaron",
                "WINELOADER",
                "WellMail",
                "WellMess",
                "cobeacon",
                "elf.wellmess",
                "reGeorg",
                "tDiscoverer"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535705,
    "ts_updated_at": 1743041794,
    "ts_creation_date": 1653756583,
    "ts_modification_date": 1653756583,
    "files": {
        "pdf": "https://archive.orkl.eu/3db22112e7bc1679530e35d7a430889ab51a507a.pdf",
        "text": "https://archive.orkl.eu/3db22112e7bc1679530e35d7a430889ab51a507a.txt",
        "img": "https://archive.orkl.eu/3db22112e7bc1679530e35d7a430889ab51a507a.jpg"
    }
}