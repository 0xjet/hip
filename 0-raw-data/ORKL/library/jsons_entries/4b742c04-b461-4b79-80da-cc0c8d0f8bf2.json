{
    "id": "4b742c04-b461-4b79-80da-cc0c8d0f8bf2",
    "created_at": "2023-01-12T15:05:22.929752Z",
    "updated_at": "2025-03-27T02:09:29.88627Z",
    "deleted_at": null,
    "sha1_hash": "82444384594e12c04720b5a0fc3d2c00d1688114",
    "title": "2016-08-05 - Smoke Loader – downloader with a smokescreen still alive",
    "authors": "",
    "file_creation_date": "2022-05-28T04:55:50Z",
    "file_modification_date": "2022-05-28T04:55:50Z",
    "file_size": 688959,
    "plain_text": "# Smoke Loader – downloader with a smokescreen still alive\n\n**[blog.malwarebytes.com/threat-analysis/2016/08/smoke-loader-downloader-with-a-smokescreen-still-alive/](https://blog.malwarebytes.com/threat-analysis/2016/08/smoke-loader-downloader-with-a-smokescreen-still-alive/)**\n\nMalwarebytes Labs August 5, 2016\n\n[This time we will have a look at another payload from recent RIG EK campaign. It is Smoke](https://blog.malwarebytes.com/threat-analysis/exploits-threat-analysis/2016/07/a-look-into-some-rig-exploit-kit-campaigns/)\nLoader (Dofoil), a bot created several years ago – one of its early versions was advertised on\n[the black market in 2011. Although there were some periods of time in which it was not seen](http://cyb3rsleuth.blogspot.com/2011/08/smoke-loader.html)\nfor quite a while, it doesn’t seems to plan retirement. The currently captured sample appears\nto be updated in 2015.\n\nThis small application is used to download other malware. What makes the bot interesting\nare various tricks that it uses for deception and self protection.\n\nWe will walk through the used techniques and compare the current sample with the older\none (from 2014).\n\n## Analyzed samples\n\nMain focus of this analysis is the below sample, which is dropped by Rig EK:\n\nThe above sample downloads:\n\nPayload:\n\n[f60ba6b9d5285b834d844450b4db11fd  – (it is an IRC bot, C&C: med-global-](https://www.virustotal.com/en/file/0eaf261f3e9bf710055f72a66826ff4d17fa37d24980d7dcac3f236f72e9d3fa/analysis/)\nfox[DOT]com)\n\nUpdated Smoke Loader:\n\nDuring the analysis it will be compared against the old sample, first seen in [September 2014](https://www.sophos.com/it-it/threat-center/threat-analyses/viruses-and-spyware/Troj~MSIL-AKN/detailed-analysis.aspx)\n\n## Behavioral analysis\n\nAfter being deployed, Smoke Loader inject itself into explorer.exe and deletes the original\nexecutable. We can see it making new connections from inside the explorer process.\n\n### Installation and updates\n\nSmoke Loader not only installs its original sample but also replaces it with a fresh version,\nwhich is downloaded from the C&C – path: http://<CnC address>/system32.exe. This\ntrick makes detection more difficult – updated samples are repacked by a different crypter,\nmay also have their set of C&Cs changed.\n\n\n-----\n\n_During the current analysis, the initial sample of Smoke Loader dropped the following one:_\n_[bc305b3260557f2be7f92cbbf9f82975](https://malwr.com/analysis/MzExZGY2YzU1ZjJjNGZiOTljMTEzMjYzMjkzOWI2ZWY/)_\n\nSample is saved in a hidden subfolder, located in %APPDATA%:\n\nSmoke Loaded adds its current sample and all other downloaded executables to the\nWindows registry. Names of the keys are randomly chosen among the names of existing\nentries:\n\n[This persistence method is pretty simple (comparing i.e. with Kovter), however there are](https://blog.malwarebytes.com/threat-analysis/2016/07/untangling-kovter/)\nsome countermeasures taken against detection of the main module. The timestamp of the\ndropped executable is changed, so that malware cannot be found by searching recently\nmodified files. Access to the file is blocked – performing reading or writing operations on it is\nnot possible.\n\n### Loading other executables\n\nDuring its presence in the system it keeps downloading additional modules – “plugins”. First,\nthe downloaded module is saved in %TEMP% under a random name and run. Then, it is\nmoved to %APPDATA%. Below, we can see that the payload established connection with its\nown separate C&C:\n\n\n-----\n\nThere is also a script in Autostart for deploying the payload:\n\n## Network communication\n\nTo make analysis of the traffic harder, along with communicating with the C&C bot generates\na lot of redundant traffic, sending requests to legitimate domains.\n\nThe current sample’s C&C addresses:\n\n**_[smoktruefalse.com](https://virustotal.com/en/domain/smoktruefalse.com/information/)_**\n**_[prince-of-persia24.ru](https://virustotal.com/en/domain/prince-of-persia24.ru/information/)_**\n\nTraffic is partially encrypted.\n\nIn the examples below, we can see how the bot downloads from the C&C other executables.\n\n1 – Updating the main bot with a new sample of Smoke Loader:\n\n\n-----\n\n2 – Downloading the additional payload (“plugin”):\n\n\n-----\n\n### Payload traffic\n\nSmoke Loader deploys the downloaded sample, so after some time we can see traffic\ngenerated by the payload (connecting to med-global-fox.com). By its characteristics, we\ncan conclude that this time the “plugin” is an IRC bot:\n\n## Inside\n\n[Like most of the malware, Smoke Loader is distributed packed by some crypter that provides](https://blog.malwarebytes.com/threat-analysis/2015/12/malware-crypters-the-deceptive-first-layer/)\nthe first layer of defense against detection.\n\nAfter removing the crypter layer, we can see the main Smoke Loader executable. However,\nmore unpacking needs to be done in order to reach the malicious core. For the sake of\nconvenience, I will refer to the code section of the unpacked sample as Stage#1. Its\nexecution starts in the Entry Point of the main executable and its role is to provide additional\nobfuscation. It also serves as a loader for the most important piece: Stage#2 – this is a DLL,\nunpacked to a dynamically allocated memory and run from there.\n\n### Stage#1\n\nInteresting feature of this bot is that often its executables have one section only and no\nimports. Below you can see the visualization of sections layout (Entry Point is marked red):\n\n\n-----\n\nCode at Entry Point is obfuscated and difficult to follow. It contains many redundant jumps,\nsometimes an address of a next jump is calculated on the fly – that’s why tools for static\nanalysis cannot resolve them. Also, to make analysis more difficult, the code modifies itself\nduring execution.\n\nThe initial routine decrypts selected parts of the code section using XOR with a hardcoded\nvalue:\n\nAnd then it it calls it:\n\nThis is not the only way Smoke Loader modifies itself. In the unpacked part, we can see\nsome more tricks. This code uses many tiny jumps followed by XOR and LODS instructions\nto modify and displace code after every few steps of execution. In between, junk instructions\nhave been added to make it less readable:\n\n\n-----\n\nThe bot loads all the necessary imports by its own. To achieve this goal, it deploys a variant\nof a popular method: searching function handles in the loaded modules by calculating\nchecksum of their names and comparing them with hardcoded values. First, a handle to the\n[loaded module is fetched with the help of Process Environment Block (PEB)*:](https://en.wikipedia.org/wiki/Process_Environment_Block)\n```\nMOV ESI, FS:[30] ; copy to ESI handle to PEB\nMOV ESI, DS:[ESI+0xC] ; struct _PEB_LDR_DATA *Ldr\nMOV ESI, DS:[ESI+0x1C] ; ESI = Flink = Ldr->InLoadOrderModuleList\nMOV EBP, DS:[ESI+0x8] ; EBP = Flink.DllBaseAddress\n\n```\n_[* read more about it here](http://www.rohitab.com/discuss/topic/35251-3-ways-to-get-address-base-kernel32-from-peb/)_\nBelow we can see the fragment of code that walks through exported functions of ntdll.dll\nsearching for a handle to the function: ZwAllocateVirtualMemory (using it’s checksum:\n0x976055C), and then saving the found handle in a variable:\n\n\n-----\n\nThanks to this trick Smoke Loader can operate without having any import table. (The same\nmethod is utilized by Stage#2 to fill its imports).\n\nThe stored handle is used to make an API call and allocate additional memory:\n\nIn this added memory space, Stage#2 is being unpacked. This new module is a PE file with\nheaders removed (it is a common anti-dumping technique). Below, you can see the part that\nwas erased at the beginning of the file (marked red):\n\n\n-----\n\nIf we add the missing part, we can parse it as a typical PE file. It turns out to be a DLL\nexporting one function. Exactly the same technique was used before by older versions of\nDofoil. In the past, the name of the module was Stub.dll and the exported function was\n_Works. Now the names are substituted by garbage._\n\nThis piece is loaded by the dedicated function inside Stage#1, that takes care of all the\nactions typically performed by the Windows Loader.\n\nFirst the unpacked content is in raw format (Size of Headers: 0x400, File Alignment: 0x200):\n\n\n-----\n\nThen, the same content is realigned to a virtual format (unit size: 0x1000):\n\nAnother subroutine parses and applies relocations. As we can see below, it is a typical\nrelocations table known from PE format. Entries are stored as a continuous array of WORDs:\n\n\n-----\n\nThe loader processes them one by one. First, it checks if the entry type is 32-bit field (by\n**TEST EAX,0x3000) – it is the only format supported in this case. Then, it fetches the**\nrelocation offset (AND EAX,0xFFF), gets the pointed address and performs calculation – by\nremoving old ImageBase (it’s value is hardcoded) and applying the new base – offset to the\ndynamically allocated memory where the unpacked code was copied).\n\nFinally execution flow can be redirected to the new code. Stage#1 calls the exported function\nform the Stage#2 DLL with three parameters.The first one is a string, different for each\nsample (this time it is “00018”):\n\nThe execution of Stage#2 starts inside the dynamically allocated section:\n\nAt this stage we can see some of the strings known from previous editions of Smoke Loader.\nString “2015” may suggest that this version has been written in 2015 (however, compilation\ntimestamp of the sample is more recent: 10-th June 2016).\n\n### Stage#2\n\n\n-----\n\nWhile the previous stage was just a preparation, at Stage#2 the malicious functions are\ndeployed. Its entry lies within the exported function that has the following header:\n```\nint __stdcall Work(char* sample_id, bool do_injection, char* file_path);\n\n```\nBasing on those parameters, the executable recognize its current state and the execution\npath to follow.\n\nBefore executing the real mission, the bot prepares a disguise – injecting its code into a\nlegitimate process – explorer.exe (more about it will be explained later). Whether this path\nshould be deployed or not, it is specified by the second parameter (denoted as do_injection).\n\nIf Stage#2 was called with do_injection flag set, it will inject the code into\n**_explorer.exe. Before doing so, the environment is checked for the presence of tools_**\nused for malware analysis. If any symptom is detected pointing that the sample is\nrunning in the controlled environment, application goes in the infinite sleep loop.\nIf Stage#2 was called with do_injection flag cleared, it starts proceeding to the main\n_path of execution, that includes connecting to the C&C and downloading malicious_\nmodules.\n\nIf the main path of execution has been chosen, the bot proceeds to communicate with its\nC&C server. It is a known fact that before making the connection to the real C&C it first\nchecks if the network is reachable. For the purpose of testing, it uses some non-malicious\naddress – in this case it is msn.com. As long as it gets no response, it keeps waiting and retrying:\n\n\n-----\n\nOnce it found the connection working, next it verifies whether or not the application is already\nrunning (using the mutex with a name unique for the particular machine).\n\n\n-----\n\nIf the mutex exist, program sends report to the C&C server and exits\nIf the mutex does not exist (program is not yet running), it installs itself and then starts\nthe main operations.\n\n## Injections to other processes\n\nThe older version was injecting the code alternatively to explorer.exe or svchost.exe.\nInjection to explorer.exe employed an interesting trick that triggered a lot of attention from\n[researchers. It is based on a PowerLoader injection technique (Shell_TrayWnd /](https://github.com/BreakingMalware/PowerLoaderEx)\n_NtQueueApcThread)._\n\nInjection to svchost.exe was just a fail-safe, and followed more classic way similar to this\none. Functions used:\n```\nCreateProcessInternalA\nNtCreateSection\nNtMapViewOfSection\nRtlMoveMemory\nNtUnmapViewOfSection\nNtQueueApcThread\nResumeThread\n\n```\n[The current version dropped that idea in favor for another method (similar to this one) –](https://github.com/hasherezade/snippets/tree/master/inject1)\nadding a new section to the remote process and copying its own code there. Functions used:\n```\nCreateProcessInternalA\nNtQueryInformationProcess\nReadProcessMemory\nNtCreateSection\nNtMapViewOfSection\nRtlMoveMemory\nNtUnmapViewOfSection\nResumeThread\n\n```\nNow the only target of the injection is explorer.exe.\n\nIt patches Entry Point of explorer and adds there a code redirecting to the newly added\nsection. That section contains the injected Stage#2 DLL along with a small loader (similar to\nthe one from Stage#1). Again, the loader prepares Stage#2 and deploys it – this time with\ndifferent parameters:\n\n\n-----\n\n## Communication protocol\n\nOld versions of Smoke Loader were using a very descriptive protocol, with commands\ndirectly pointing to the functionality. Below are the parameters used by the old version:\n```\ncmd=getload&login=\n&file=\n&run=ok\n&run=fail\n&sel=\n&ver=\n&bits=\n&doubles=1\n&personal=ok\n&removed=ok\n&admin=\n&hash=\n\n```\nIn the current version, the sent beacon looks different – parameters are separated by a\ndelimiter instead of following the typical, more lengthy key-value format:\n```\n\"2015#D2C0431D4351DCD46E75D663AA9911B1448D3B2B#00018#6.1#0#0#10001#0#\"\n\n```\nReading the beacon, we can confirm that the currently analyzed version is higher than the\nprevious one. The bot also sends its ID, which is generated based on the GUID of particular\nsystem and the parameter typical for the particular sample (i.e. “00018”).\n\nThe program also reports to the C&C if there was attempt to run it more than once (mutex\nlocked):\n```\n\"2015#D2C0431D4351DCD46E75D663AA9911B1448D3B2B#00018#6.1#0#0#10001#13#0\"\n\n## Conclusion\n\n```\nIn the past Smoke Loader was extensively distributed via spam. Now we encountered it\ncarried by an exploit kit.\n\n\n-----\n\nMany parts of the bot didn t changed over the years, making this malware easy to identify. It\nstill uses the same set of environment checks for its defense. Also, it waits for network\naccessibility in old style. The protocol used for its communication with the C&C is now less\ndescriptive – it doesn’t have so many keywords that identifies its performed actions. Like the\nprevious, traffic is encrypted. The core features also stayed the same and the main role of\nthis malware is to download and deploy other modules.\n\n## Appendix\n\n[http://stopmalvertising.com/rootkits/analysis-of-smoke-loader.html](http://stopmalvertising.com/rootkits/analysis-of-smoke-loader.html)\n\n[https://blog.fortinet.com/2014/11/12/the-rebirth-of-dofoil](https://blog.fortinet.com/2014/11/12/the-rebirth-of-dofoil)\n\n_This was a guest post written by Hasherezade, an independent researcher and programmer_\n_with a strong interest in InfoSec. She loves going in details about malware and sharing threat_\n_[information with the community. Check her out on Twitter @hasherezade and her personal](https://twitter.com/hasherezade)_\n_[blog: https://hshrzd.wordpress.com.](https://hshrzd.wordpress.com/)_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2016/2016-08-05 - Smoke Loader – downloader with a smokescreen still alive.pdf"
    ],
    "report_names": [
        "2016-08-05 - Smoke Loader – downloader with a smokescreen still alive.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535922,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653713750,
    "ts_modification_date": 1653713750,
    "files": {
        "pdf": "https://archive.orkl.eu/82444384594e12c04720b5a0fc3d2c00d1688114.pdf",
        "text": "https://archive.orkl.eu/82444384594e12c04720b5a0fc3d2c00d1688114.txt",
        "img": "https://archive.orkl.eu/82444384594e12c04720b5a0fc3d2c00d1688114.jpg"
    }
}