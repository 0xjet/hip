{
    "id": "43f34625-d082-4ae7-a88c-5e319640f6b7",
    "created_at": "2023-01-12T15:01:36.339201Z",
    "updated_at": "2025-03-27T02:05:44.280346Z",
    "deleted_at": null,
    "sha1_hash": "38e0d58a9b196220088b08ca9926f102e065ad69",
    "title": "2019-12-20 - Undressing the REvil",
    "authors": "",
    "file_creation_date": "2022-05-28T15:54:24Z",
    "file_modification_date": "2022-05-28T15:54:24Z",
    "file_size": 1917790,
    "plain_text": "# Undressing the REvil\n\n**[trustwave.com/en-us/resources/blogs/spiderlabs-blog/undressing-the-revil/](https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/undressing-the-revil/)**\n\nLoading...\n\nBlogs & Stories\n\n## SpiderLabs Blog\n\nAttracting more than a half-million annual readers, this is the security community's go-to\ndestination for technical breakdowns of the latest threats, critical vulnerability disclosures\nand cutting-edge research.\n\nContributors: Lloyd Macrohon and Rodel Mendrez\n\nRecently, we got a chance to investigate a REvil Ransomware sample from one of our DFIR\ninvestigations. During analysis, we encountered a few stumbling blocks that made the\ninvestigation a little tricky, namely unpacking and string deobfuscation. In this blog, we will\nshow how we manually unpacked the malware and then how we deobfuscated the strings\nused by the ransomware.\n\nThe particular sample we are going to investigate has the SHA256 Hash:\n6ff970f1502347acd2d00e7746e40fba48995abbe26271d13102753c55694078.\n\n\n-----\n\n## Manual Unpacking\n\nPackers are essentially tools that are used to compress a Portable Executable (PE) file.\nMany malware authors utilize packers with their malware to obfuscate and make it a bit\nharder to statically analyze code. If you want to learn more about packers, you can read our\nblog about this here: https://www.trustwave.com/en-us/resources/blogs/spiderlabsblog/basic-packers-easy-as-pie/\n\nWe began by trying to determine what packer was used by this malware. The “Detect It\nEasy” tool failed to identify the packer and no signature was found. It also found no packed\nPE sections. Interestingly the sample had non-standard section names. We also took note\nof the entry point at [RVA (relative virtual address) 0x9D58 which is within the .text section of](https://stackoverflow.com/questions/1868571/what-is-rva-and-va)\nthe PE file.\n\n\n-----\n\nFigure 1. An overview of the malware's PE header information\n\nDisassembling the executable, we can see right at the entry point the use of VirtualAlloc()\nAPI to allocate a new memory in the address space, then \"rep movsb\" opcode to copy data\nto the allocated memory, then, at the end of the function, is an opcode \"jmp eax\" that leads\nthe instruction pointer to a new entry point in the allocated memory space. Now that looks\ninteresting…\n\n\n-----\n\nHere is what the code looks like when decompiled in IdaPro:\n\n\n-----\n\n[Next, we dynamically analyze the file using x64dbg (a PE debugger tool) to see what’s](https://x64dbg.com/)\nbeing copied to the allocated memory. In the screenshot below, after calling VirtualAlloc()\nAPI, this instance allocated memory at the base address 0x1240000 (this memory address\nvaries in each run).\n\n\n-----\n\nBy dumping that memory address, we can visually monitor what has been copied to that\naddress. After the malware has copied the data to the memory address, it turns out that it\nwas the PE image of itself.\n\n\n-----\n\nHowever, the jmp eax we mentioned earlier - jumps to a new entry point at RVA 0x9EA0\n(virtual address is therefore - 0x1240000 (base address) + 0x9EA0 = 0x1249ea0):\n\n\n-----\n\nNext we follow that jump to virtual address 0x1249ea0, and yet again we encounter another\nVirtualAlloc() API call. So we dump the new allocated memory address and monitor it:\n\n\n-----\n\n-----\n\nThe malware then starts to decrypt a blob of data embedded in the PE file starting at RVA\n0x13DE2 and writes it to the allocated memory. That blob of packed data (at 0ffset\n0x13DE2) is within .text section of the PE file.\n\nAfter unpacking, another PE file is revealed. This time, it is the ultimate payload – a REvil\nRansomware. You will notice the new section names, and standing out is a non-standard\nsection name .raimo.\n\n\n-----\n\nWe can dump this unpacked PE image and manually fix the IAT (Import Address Table) so\nthat we can continue analyzing it statically. You can reconstruct and fix the IAT with Scylla\n[(this is available in x64dbg) or ImportRec.](https://tuts4you.com/download/415/)\n\n## Reversing Encrypted Strings\n\nNow that we have manually unpacked the file, we can statically analyze it. However,\nanother stumbling block is that it leverages string obfuscation to hide the nature of what it’s\ndoing. You can see in the screenshot below a bunch of cross-references – these are calls to\nthe decode_string function:\n\nThe encrypted strings are stored in parts of the binary. One part is a table of the encrypted\nstrings that the malware uses and another part is the ransomware configuration. Each\nfunction call to decode_string is preceded by its parameters, by passing them through the\n\n\n-----\n\nstack, these are: pointer to the output address, the key offset, key length and encoded data\nlength. We will follow this example:\n\nAt relative virtual address 0xF060 is the data table base address which we named as\n**encrypted_data_table which is 3048 bytes long. This is found in the .data section of the**\nPE image.\n\nFor this example, the encrypted data is at offset 0x91B from the base address of the data\ntable, or 0xF060 + 0x7B4\n\nAnd the following parameters are hardcoded:\n\noffset address (from the base address 0xf060) of the encrypted string: 0x7B4\nkey length: 0x0D (13 bytes)\nstring length: 0x13A (314 bytes)\n\nHere is the encrypted_data_table (truncated) after we re-based it to Zero:\n\n\n-----\n\nThe encrypted string block is therefore at 0x7B4:\n\n\n-----\n\nThe key is 13 bytes long :\n\n```\n[82 7D AE B7 37 35 9D 60 DA 8D DB CA E3]\n\n```\n\nAnd the encrypted string is 314 bytes long:\n```\n[0c 67 57 04 37 69 34 07 f7 16 37 33 30 88 ec e3\n 46 13 61 0d 75 d6 5b 0a 54 2a d5 7e 1d 32 9d 79\n c8 8c b9 e1 23 50 90 b5 6a 84 8b f9 80 16 9a 99\n 58 11 24 30 d1 ac 3f 5c b6 77 b0 14 37 ad 69 be\n 81 d6 ea b5 a8 2c f2 14 d4 74 13 6f 2b af 1f fa\n 28 e0 58 34 be 7c d7 2d 79 90 94 de 4a 01 13 71\n fa e6 36 ca 88 cd 3b 82 4d ac 63 02 1a e8 05 7e\n 71 44 3c 75 4a 60 93 2d 58 01 3a 24 98 b3 e5 7a\n 9b 3f 43 6f e2 3a 69 36 5b f4 a0 b1 2a dd ff 41\n 59 c3 77 88 c3 41 df 2a 4d ea d7 91 61 5a 53 98\n 1e df 56 da 4e ea e0 51 e8 8d 57 71 fc 90 79 23\n fd 36 0d 14 24 e5 30 4d a7 cf 23 06 c2 7a 2d 11\n 11 ea ec 3b cb 8d fc c0 06 5d 8c ff a2 82 d8 3a\n 0d 39 a5 4c 15 6f 53 93 e2 d4 35 55 5a f5 02 d8\n e3 a3 cb 2a 2b 4b 65 1f fc aa 14 20 a4 d5 ec 34\n 23 60 73 03 b4 65 ab e2 bd c4 cf 1f e7 37 24 b8\n 93 0a 16 b2 79 74 4e 30 3b ce b4 fe ac cf 3d fd\n 91 7f 96 c2 9f 6a 4c 5b fa fc d0 05 0e 36 14 75\n 19 24 dc 5c 7e 74 87 a4 9b 34 62 56 9d 4d e9 d2\n 12 c5 61 a8 67 e1 c8 5d 6e 6e]\n\n```\n\n-----\n\nReverse engineering the decryption code in the malware shows that it s actually just the\nstream cipher RC4. Code snippet below is the RC4 algorithm: initialize sbox and key\nscheduling\n\nCode snippet below is the actual decryption of data:\n\nAfter reversing this to C, it was pretty straightforward to convert it to Python so we could run\nit in IDA Pro\n\n\n-----\n\nThis now allows us to take the encrypted block above with the following parts:\n\nThis decodes a Unicode string as seen in the screenshot below:\n\nBecause each encoded string has its own unique key and variable length, it becomes\ncumbersome to decode every string. But fret not, at the end of this blog, we share the\nIDAPython script to aid you with the decoding process.\n\nThe second part of the obfuscated data is the ransomware configuration which basically\nuses the same RC4 algorithm. This encrypted configuration is stored in the non-standard\nnamed section called .raimo.\n\nIn the screenshot below we highlight the RC4 key\n“VNz47r3Wz2xT7DP1XqPa2MYcwUx8uRex”, the CRC hash of the encoded data which is\n0xB6C2E135, and the length of the data is 0x6B02 (27394 bytes).\n\n\n-----\n\nThe resulting decrypted configuration file looks like this:\n\nWhen we finally unpack the file and deobfuscate the string, the process of reversing the\ncode statically is so much easier. We won’t, however, go into further detail about the\nRansomware itself as there are very good analyses on this malware elsewhere, such as:\n[https://www.acronis.com/en-eu/articles/sodinokibi-ransomware/](https://www.acronis.com/en-eu/articles/sodinokibi-ransomware/)\n\nAs mentioned earlier, we also wrote an IDAPython script to help deobfuscate strings hidden\nby this malware which may aid in the analysis process. You can find it here:\n[https://github.com/bizdak/malware-analysis/blob/master/revil/revil.py](https://github.com/bizdak/malware-analysis/blob/master/revil/revil.py)\n\nDecoded string after running the IdaPython script:\n\n\n-----\n\nHappy reversing!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-12-20 - Undressing the REvil.pdf"
    ],
    "report_names": [
        "2019-12-20 - Undressing the REvil.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535696,
    "ts_updated_at": 1743041144,
    "ts_creation_date": 1653753264,
    "ts_modification_date": 1653753264,
    "files": {
        "pdf": "https://archive.orkl.eu/38e0d58a9b196220088b08ca9926f102e065ad69.pdf",
        "text": "https://archive.orkl.eu/38e0d58a9b196220088b08ca9926f102e065ad69.txt",
        "img": "https://archive.orkl.eu/38e0d58a9b196220088b08ca9926f102e065ad69.jpg"
    }
}