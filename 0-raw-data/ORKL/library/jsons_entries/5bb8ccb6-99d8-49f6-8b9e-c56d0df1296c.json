{
    "id": "5bb8ccb6-99d8-49f6-8b9e-c56d0df1296c",
    "created_at": "2022-10-25T16:48:24.627416Z",
    "updated_at": "2025-03-27T02:17:23.239899Z",
    "deleted_at": null,
    "sha1_hash": "5f86309e6544994a45536b0450cf1f5adef67296",
    "title": "",
    "authors": "",
    "file_creation_date": "0001-01-01T00:00:00Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 1692698,
    "plain_text": "-----\n\nNovetta is an advanced analytics company that extracts value from the increasing volume,\nvariety and velocity of data. By mastering scale and speed, our advanced analytics software and\n\nsolutions deliver the actionable insights needed to help our customers detect threat and fraud,\n\nprotect high value networks, and improve the bottom line.\n\nFor innovative solutions for today’s most mission-critical, advanced analytics\n\nchallenges, contact Novetta:\n\nPhone: (571) 282-3000 | www.novetta.com\n\n**www.OperationBlockbuster.com**\n\n\n-----\n\n# Table of\n Contents\n\n###### 1. Introduction....................................................................................4\n\n 2. Romeo-CoreOne Design Pattern.............................................5\n\n 3. [RAT] RomeoAlfa........................................................................ 12\n\n 4. [RAT] RomeoBravo..................................................................... 18\n\n 5. [RAT] RomeoCharlie..................................................................20\n\n 6. [RAT] RomeoDelta.....................................................................23\n\n 7. [RAT] RomeoEcho.......................................................................27\n\n 8. [RAT] RomeoFoxtrot..................................................................29\n\n 9. [RAT] RomeoGolf........................................................................ 31\n\n 10. [RAT] RomeoHotel....................................................................33\n\n 11. [RAT] RomeoMike......................................................................37\n\n 12. [RAT] RomeoNovember..........................................................39\n\n 13. [RAT] RomeoWhiskey (Winsec)............................................40\n\n13.1 RomeoWhiskey-One (Base Code)..............................................................41\n\n13.2 RomeoWhiskey-Two.........................................................................................45\n\n###### 14. [Spreader] SierraAlfa...............................................................50\n\n14.2 SierraAlfa-Two.....................................................................................................55\n\n###### 15. [Spreader] SierraBravo (Brambul)........................................56\n\n15.2 SierraBravo-Two.................................................................................................62\n\n###### 16. [Spreader] SierraCharlie.........................................................63\n\n 17. [P2P Staging] SierraJuliett-MikeOne (Joanap Mk I.)........64\n\n17.1.1 Crawler Channel................................................................................................ 67\n\n17.1.2 RAT Channel.......................................................................................................68\n\n17.1.3 Sync Channel..................................................................................................... 70\n\n17.2 Client Mode Thread........................................................................................... 73\n\n17.3 Known SierraJuliett-MikeOne Command Files.................................. 78\n\n###### 18. [P2P Staging] SierraJuliett-MikeTwo (Joanap Mk. II).......80\n\n 19. [Webserver] HotelAlfa............................................................. 81\n\n 20. Conclusion.................................................................................83\n\n\n-----\n\n|FIRST LEVEL IDENTIFIER|GENERAL CLASSIFICATION|\n|---|---|\n|Delta|DDoS|\n|Hotel|HTTP Server|\n|India|Installer|\n|Lima|Loader|\n|Kilo|Keylogger|\n|Papa|Proxy|\n|Romeo|RAT|\n|Sierra|Spreader|\n|Tango|Tool (Non-classed)|\n|Uniform|Uninstaller|\n|Whiskey|Destructive Malware (“Wiper”)|\n\n\n## 1. Introduction\n\nThis report details some of the technical findings of the Lazarus Group’s malware, observed\nby Novetta during Operation Blockbuster. We recommend reading the initial report prior to\nthe reverse engineering reports for more details on the Operation and the Lazarus Group.\nThis reverse engineering report looks at the RATs and staging malware found within the\nLazarus Group’s collection.\n\nA Remote Administration Tool (RAT), or Remote Administration Trojan, is a piece of malicious code that gives an attacker\ncontrol over certain aspects of the infected system. At a minimum, a RAT allows an attacker to execute commands on a\nvictim’s machine. A typical RAT also provides functionality to upload and download files from a victim’s computer as well.\nThe most common communication mode for a RAT is to act as a client to a remote server. The Lazarus Group employs a\nvariety of RATs that operate in both client mode and server mode. In server mode, a RAT waits for an incoming connection\nfrom a C2 client which requires the infected host to have a routable IP address and the ability to listen on a given port.\n\nThe naming scheme used by Novetta for the malware identified during Operation Blockbuster consists of at least two\nidentifiers which each identifier coming from the International Civil Aviation Organization (ICAO)’s phonetic alphabet,\ncommonly referred to as the NATO phonetic alphabet.[1] The first identifier specifies the general classification of the\nmalware family while the second identifier specifies the specific family within the larger general classification. For\nexample, RomeoAlfa specifies a RAT family identified as Alfa.\n\n**FIRST LEVEL IDENTIFIER** **GENERAL CLASSIFICATION**\n\nDelta DDoS\n\nHotel HTTP Server\n\nIndia Installer\n\nLima Loader\n\nKilo Keylogger\n\nPapa Proxy\n\nRomeo RAT\n\nSierra Spreader\n\nTango Tool (Non-classed)\n\nUniform Uninstaller\n\nWhiskey Destructive Malware (“Wiper”)\n\n**Table 1‑1: First Level Identifiers for the Lazarus Group Family Names and Their Classification Meanings**\n\nThere is no temporal component to the second level identifiers given to malware families. While generally the second identifiers\nare largely sequential (Alfa, Bravo, Charlie, and so on), the identifier does not indicate that one family came before another\nchronologically. Instead, the second level identifiers were assigned by the order Novetta discovered each particular family.\n\n1 [International Civil Aviation Organization. “Alphabet – Radiotelephony”. http://www.icao.int/Pages/AlphabetRadiotelephony.aspx Accessed 1 December 2015.](http://www.icao.int/Pages/AlphabetRadiotelephony.aspx)\n\n\n-----\n\n## 2. Romeo-CoreOne Design Pattern\n\nA large portion of the Lazarus Group’s RAT collection stems from a common core, Romeo-CoreOne (R-C1); the individual\nfamilies that use R-C1 need only provide the scaffolding to support the R-C1 code. At a minimum, each family that is built\nupon R-C1 must provide an interface to their specific communications abstraction and a method by which to activate the\nR-C1 functionality.\n\nThe general flow of execution for families that use R-C1 is as follows:\n\n1. Dynamically load API functions\n\n2. Perform any configuration management tasks that the family may require (e.g., loading the configuration, opening\n\nlistening ports, establishing persistence)\n\n3. Establish a communication channel with controlling endpoint\n\n4. Pass off the channel to the R-C1 component\n\nThere are five known families that are based on, or that incorporate, R-C1 (Figure 2-1): RomeoAlfa, RomeoBravo,\nRomeoCharlie, RomeoHotel, and RomeoNovember. In addition to the four families having commonality through the\nuse of R-C1, two of the families, RomeoAlfa and RomeoHotel, share the distinctive fake TLS communication scheme and\nuse the Caracachs encryption scheme as their underlying communication encryption. RomeoBravo, RomeoCharlie, and\nRomeoNovember use DNSCALC-style encoding for communication encryption.\n\n\n-----\n\n**DNSCALC-Encoded**\n**Comms**\n\nRomeoNovember RomeoBravo RomeoCharlie\n\n**Romeo-**\n**CoreOne**\n\nRomeoAlfa RomeoHotel\n\n**Caracachs-Encoded**\n**Comms**\n\n**Fake TLS**\n**Communication Scheme**\n\n**Figure 2-1: Romeo-Core1’s Relationship to RomeoAlfa, RomeoBravo, RomeoCharlie, RomeoHotel, and RomeoNovember and Their**\n**Communication Underpinnings**\n\n\n-----\n\nThere is significant overlap of the development periods between the different families that utilize R-C1, as seen in Figure\n2-2. Each family contains a core set of R-C1 commands, and within each family there is largely a consistency among the\nadditional commands that the families support. This indicates that the developer(s) of each family builds off the base of\nR-C1 but generally speaking do not share additional functionality across family boundaries.\n\nFeb. 2014\n\nMar. 2014\n\nApr. 2014\n\nMay 2014\n\nJune 2014\n\nJuly 2014\n\nAug. 2014 RomeoCharlie\n\nSept. 2014 RomeoHotel\n\nOct. 2014\n\nNov. 2014\n\nRomeoBravo\n\nDec. 2014\n\nJan. 2015\n\nFeb. 2015\n\nMar. 2015 RomeoAlfa\n\nRomeoNovember\n\nApr. 2015\n\nMay 2015\n\nJune 2015\n\nJuly 2015\n\nAug. 2015\n\nSept. 2015\n\nOct. 2015\n\nNov. 2015\n\n**Figure 2-2: Timeline of Observed Romeo-CoreOne Based Families**\n\nThe bulk of the R-C1’s functionality exists within the command processing function, which the developer(s) gave the\nname MessageThread. Within MessageThread the following tasks occur:\n\n1. Enter an infinite loop\n\n2. Wait for incoming data from controlling endpoint\n\n3. If the wait period (generally ranging from 1,200 to 36,000 seconds) for incoming data expires, exit the loop and\n\nRomeo-CoreOne\n\n4. Read a datagram containing the command identifier and any optional parameters for the requested command\n\n5. Using a case/switch statement, locate and then execute the appropriate command handler function for the requested\n\ncommand\n\n6. Repeat at the top of the loop until a disconnection command occurs or an error with any of the commands occurs,\n\nthen terminate the loop and exit Romeo-CoreOne\n\n\n-----\n\n|FOUND IN ONE OR MORE VARIANTS OF|Col2|Col3|Col4|Col5|COMMAND|DESCRIPTION|\n|---|---|---|---|---|---|---|\n|Alfa|Bravo|Charlie|Hotel|November|||\n|▲|▲|▲|▲|▲|Move File|Moves or renames a file.|\n|▲|▲|▲|▲|▲|Directory Statistics|Pulls the number of files and directories under the specified directory along with the total size in bytes of all files.|\n|▲|▲|▲|▲|▲|Enumerate Drives|Returns details about each logical drive including the bytes per sector and number of free sectors.|\n|▲|▲|▲|▲|▲|Enumerate Directory|Returns a directory listing for the specified directory using the specified file mask (e.g. “*.*”)|\n|▲|▲|▲|▲|▲|Write File|Writes a file supplied by the connected endpoint to disk.|\n|▲|▲|▲|▲|▲|Read File|Transfers a local file to the connected endpoint.|\n|△|▲|▲|▲||Upload Directory as Archive|Generates a ZIP archive file (stored in %TEMP% as DQ{random} or QB{random}) of the specified directory and its subdirectories’ contents then transfers the file to the connected endpoint. Uses the open source project Zip Utils1 to perform the archive.|\n|▲|▲|▲|▲|▲|Create Process|Starts a new process using the command line specified by the connected endpoint.|\n|▲|▲|▲|▲|▲|Secure Delete|Secure deletes the file specified by the connected endpoint.|\n|▲|▲|▲|▲|▲|Mimic Timestamp|Duplicates the timestamp of the file specified by the connected endpoint (source) onto the file (target) specified by the connected endpoint.|\n|▲|▲|▲|▲|▲|Execute Shell Command with Output Upload|Execute a command via the command line: cmd.exe /c {specified command} > {output file} 2>&1 The output file is a file located in the %TEMP% directory having the name PM{random number}.tmp or DM{random number}.tmp. The output file is read up to 60 times and transferred to the connected endpoint before being securely deleted.|\n|▲|▲|▲|▲|▲|Enumerate Processes|Returns a list of all running processes along with details about each process that includes the process’s name, PID, parent PID, start time, user’s name and domain, and the full path of the process’s executable.|\n|▲|▲|▲|▲|▲|Terminate Process|Terminates a process by PID. The PID can be specified as either a DWORD value or an ASCII string representation of the PID number.|\n\n\nThe number of commands offered by R-C1 has fluctuated slightly over time, with a handful of commands coming\nin and out of the available set. The order of the commands and basic structure of MessageThread has remained\nlargely constant, however. Table 2-1 identifies the commands that R-C1 supports and the families that implement those\ncommands. The fact that not all families support all of the R-C1 commands could be the result of new commands coming\ninto existence and older commands being retired over time, or the developer(s) cherry-picking the specific subset of\ncommands required for a particular family’s task. Additionally, not all variants of the same family necessarily support\nthe same set of commands. Those families who have differing command sets have a hollow symbol (△) instead of a solid\nsymbol (▲) to indicate the discontinuity between variants.\n\n**FOUND IN ONE OR MORE VARIANTS OF**\n\n**COMMAND** **DESCRIPTION**\nAlfa Bravo Charlie Hotel November\n\n        -        -        -        -        - Move File Moves or renames a file.\n\nPulls the number of files and directories under the\n\nDirectory\n\n        -        -        -        -        - specified directory along with the total size in bytes of all\nStatistics\n\nfiles.\n\nEnumerate Returns details about each logical drive including the\n\n        -        -        -        -        -\nDrives bytes per sector and number of free sectors.\n\nEnumerate Returns a directory listing for the specified directory using\n\n        -        -        -        -        -\nDirectory the specified file mask (e.g. “*.*”)\n\n        -        -        -        -        - Write File Writes a file supplied by the connected endpoint to disk.\n\n        -        -        -        -        - Read File Transfers a local file to the connected endpoint.\n\nGenerates a ZIP archive file (stored in %TEMP% as\n\nUpload `DQ{random} or QB{random}) of the specified directory`\n\n        -        -        -        - Directory as and its subdirectories’ contents then transfers the file to\n\nArchive the connected endpoint. Uses the open source project Zip\n\nUtils[1] to perform the archive.\n\nCreate Starts a new process using the command line specified\n\n        -        -        -        -        -\nProcess by the connected endpoint.\n\nSecure deletes the file specified by the connected\n\n        -        -        -        -        - Secure Delete\nendpoint.\n\nDuplicates the timestamp of the file specified by the\n\n_Mimic_\n\n        -        -        -        -        - connected endpoint (source) onto the file (target)\n_Timestamp_\n\nspecified by the connected endpoint.\n\nExecute a command via the command line:\n```\n                                   cmd.exe /c {specified command} > {output file} 2>&1\n\n```\n_Execute Shell_\n_Command_\n\n        -        -        -        -        - The output file is a file located in the %TEMP% directory\n\n_with Output_\n_Upload_ having the name PM{random number}.tmp or\n```\n                                   DM{random number}.tmp. The output file is read up to 60\n\n```\ntimes and transferred to the connected endpoint before\nbeing securely deleted.\n\nReturns a list of all running processes along with details\n\n_Enumerate_ about each process that includes the process’s name,\n\n        -        -        -        -        -\n_Processes_ PID, parent PID, start time, user’s name and domain, and\n\nthe full path of the process’s executable.\n\nTerminates a process by PID. The PID can be specified as\n\n_Terminate_\n\n        -        -        -        -        - either a DWORD value or an ASCII string representation\n_Process_\n\nof the PID number.\n\n**1**\n\n1 ljw1004. CodeProject. “Zip Utils - clean, elegant, simple, C++/Win32”. http://www.codeproject.com/Articles/7530/Zip-Utils-clean-elegant-simple-C-Win. 19 Sep 2012\n\n\n-----\n\n|FOUND IN ONE OR MORE VARIANTS OF|Col2|Col3|Col4|Col5|COMMAND|DESCRIPTION|\n|---|---|---|---|---|---|---|\n|Alfa|Bravo|Charlie|Hotel|November|||\n|||▲|||Change Listening Port|Changes the configured listening port and saves the information to the configuration before restarting the R-C1 component.|\n|▲|▲|▲|▲|▲|System Information|Returns details about the victim’s system, the malware’s configuration, specific flags indicating if several ports of interest are open, if the current user is running under Terminal Services, if the session’s screen saver is on, and the state of all terminal services sessions.|\n|▲|▲|▲|▲|▲|Change Directory|Changes the current working directory to the directory specified by the connected endpoint.|\n|▲|▲|▲|▲|▲|Port Knock|Returns the status of connection test to the network address/port specified by the connected endpoint.|\n|||▲|||Activate Proxy|Activates a relay between the R-C1 instance and the network address/port specified by the connected endpoint.|\n|▲|▲|▲|▲|▲|Send Status Value|Sends a status value (DWORD) to the connected endpoint.|\n|▲|▲|△|▲|▲|Disconnect|Cleanly disconnects the connection between the R-C1 instance and the connected endpoint.|\n|▲|▲||▲|▲|Get Config|Sends a copy of the current running configuration to the connected endpoint.|\n|▲|▲||▲|▲|Set Config|Receives a new running configuration from the connected endpoint.|\n|△|||▲||RunAs|Runs a process specified by the connected endpoint as the user specified by the connected endpoint.|\n|▲|||▲||NOP|No operation.|\n|△|||▲||Suicide|Removes the malware from the victim’s system and disconnects from the connected endpoint.|\n\n|OFFSET FROM BASE COMMAND NUMBER|Col2|Col3|Col4|Col5|COMMAND|\n|---|---|---|---|---|---|\n|Alfa|Bravo|Charlie|Hotel|November||\n|+0x00|+0x00|+0x00|+0x00|+0x00|Move File|\n|+0x01|+0x01|+0x01|+0x01|+0x01|Directory Statistics|\n|+0x02|+0x02|+0x02|+0x02|+0x02|Enumerate Drives|\n|+0x03|+0x03|+0x03|+0x03|+0x03|Enumerate Directory|\n|+0x04|+0x04|+0x04|+0x04|+0x04|Write File|\n|+0x05|+0x05|+0x05|+0x05|+0x05|Read File|\n\n\n**FOUND IN ONE OR MORE VARIANTS OF**\n\n**COMMAND** **DESCRIPTION**\nAlfa Bravo Charlie Hotel November\n\nChanges the configured listening port and saves the\n\n_Change_\n\n              - information to the configuration before restarting the\n_Listening Port_\n\nR-C1 component.\n\nReturns details about the victim’s system, the malware’s\nconfiguration, specific flags indicating if several ports\n\n_System_\n\n        -        -        -        -        - of interest are open, if the current user is running under\n_Information_\n\nTerminal Services, if the session’s screen saver is on, and\nthe state of all terminal services sessions.\n\n_Change_ Changes the current working directory to the directory\n\n        -        -        -        -        -\n_Directory_ specified by the connected endpoint.\n\nReturns the status of connection test to the network\n\n        -        -        -        -        - _Port Knock_\naddress/port specified by the connected endpoint.\n\nActivates a relay between the R-C1 instance and the\n\n              - _Activate Proxy_ network address/port specified by the connected\n\nendpoint.\n\n_Send Status_ Sends a status value (DWORD) to the connected\n\n        -        -        -        -        -\n_Value_ endpoint.\n\nCleanly disconnects the connection between the R-C1\n\n        -        -        -        -        - _Disconnect_\ninstance and the connected endpoint.\n\nSends a copy of the current running configuration to the\n\n        -        -        -        - _Get Config_\nconnected endpoint.\n\nReceives a new running configuration from the connected\n\n        -        -        -        - _Set Config_\nendpoint.\n\nRuns a process specified by the connected endpoint as\n\n        -        - _RunAs_\nthe user specified by the connected endpoint.\n\n        -        - _NOP_ No operation.\n\nRemoves the malware from the victim’s system and\n\n        -        - Suicide\ndisconnects from the connected endpoint.\n\n**Table 2-1: Romeo-CoreOne’s Supported Commands (in Their Identification Order) and the Families that Implement the Commands**\n\nThe numbering scheme for commands within R-C1 are generally consistent across the families that utilize the code.\nWhile the base number for the commands differs by family (and in some cases, by variants of a family), the sequence of\ncommands remains largely unchanged. For example, Move File is always the first command (base number + 0), Directory\n_Statistics is always the second command (base number + 1), and so on. Table 2-2 identifies the offset for each supported_\ncommand from the command base number for each family that uses R-C1.\n\n**OFFSET FROM BASE COMMAND NUMBER**\n\n**COMMAND**\nAlfa Bravo Charlie Hotel November\n\n+0x00 +0x00 +0x00 +0x00 +0x00 Move File\n\n+0x01 +0x01 +0x01 +0x01 +0x01 Directory Statistics\n\n+0x02 +0x02 +0x02 +0x02 +0x02 Enumerate Drives\n\n+0x03 +0x03 +0x03 +0x03 +0x03 Enumerate Directory\n\n+0x04 +0x04 +0x04 +0x04 +0x04 Write File\n\n+0x05 +0x05 +0x05 +0x05 +0x05 Read File\n\n\n-----\n\n|OFFSET FROM BASE COMMAND NUMBER|Col2|Col3|Col4|Col5|COMMAND|\n|---|---|---|---|---|---|\n|Alfa|Bravo|Charlie|Hotel|November||\n|+0x06|+0x06|+0x06|+0x06|-|Upload Directory as Archive|\n|+0x08|+0x08|+0x08|+0x08|+0x08|Create Process|\n|+0x09|+0x09|+0x09|+0x09|+0x09|Secure Delete|\n|+0x0A|+0x0A|+0x0A|+0x0A|+0x0A|Mimic Timestamp|\n|+0x0B|+0x0B|+0x0B|+0x0B|+0x0B|Execute Shell Command with Output Upload|\n|+0x0C|+0x0C|+0x0C|+0x0C|+0x0C|Enumerate Processes|\n|+0x0D|+0x0D|+0x0D|+0x0D|+0x0D|Terminate Process|\n|-|-|+0x0E|-|-|Change Listening Port|\n|+0x0E|+0x0E|+0x0F|+0x0E|+0x0E|System Information|\n|+0x0F|+0x0F|+0x10|+0x0F|+0x0F|Change Directory|\n|+0x10|+0x10|+0x11|+0x10|+0x10|Port Knock|\n|-|-|+0x12|-|-|Activate Proxy|\n|+0x12|+0x12|+0x14|+0x12|+0x12|Send Status Value|\n|+0x17|+0x17|+0x19|+0x17|+0x17|Disconnect|\n|+0x18|+0x18|-|+0x18|+0x18|Get Config|\n|+0x19|+0x19|-|+0x19|+0x19|Set Config|\n|+0x1A|-|-|+0x1A|-|RunAs|\n|+0x1B|-|-|+0x1B|-|NOP|\n|+0x1C|-|-|+0x1C|-|Suicide|\n\n\n**OFFSET FROM BASE COMMAND NUMBER**\n\n**COMMAND**\nAlfa Bravo Charlie Hotel November\n\n+0x06 +0x06 +0x06 +0x06         - Upload Directory as Archive\n\n+0x08 +0x08 +0x08 +0x08 +0x08 Create Process\n\n+0x09 +0x09 +0x09 +0x09 +0x09 Secure Delete\n\n+0x0A +0x0A +0x0A +0x0A +0x0A Mimic Timestamp\n\n+0x0B +0x0B +0x0B +0x0B +0x0B Execute Shell Command with Output Upload\n\n+0x0C +0x0C +0x0C +0x0C +0x0C Enumerate Processes\n\n+0x0D +0x0D +0x0D +0x0D +0x0D Terminate Process\n\n               -               - +0x0E               -               - Change Listening Port\n\n+0x0E +0x0E +0x0F +0x0E +0x0E System Information\n\n+0x0F +0x0F +0x10 +0x0F +0x0F Change Directory\n\n+0x10 +0x10 +0x11 +0x10 +0x10 Port Knock\n\n               -               - +0x12               -               - Activate Proxy\n\n+0x12 +0x12 +0x14 +0x12 +0x12 Send Status Value\n\n+0x17 +0x17 +0x19 +0x17 +0x17 Disconnect\n\n+0x18 +0x18          - +0x18 +0x18 Get Config\n\n+0x19 +0x19          - +0x19 +0x19 Set Config\n\n+0x1A         -         - +0x1A         - RunAs\n\n+0x1B         -         - +0x1B         - NOP\n\n+0x1C         -         - +0x1C         - Suicide\n\n**Table 2-2: Offset from Base Command Number of Commands for Romeo-CoreOne for RomeoAlfa, RomeoBravo, RomeoCharlie, RomeoHotel,**\n**and RomeoNovember**\n\nRomeoCharlie disrupts the overall consistency of the command-to-offset mapping between the various R-C1-based\nfamilies due to the introduction of the Change Listening Port and Activate Proxy commands. Despite the minor disruption\nof the number scheme, each family exhibits the same offsets between commands (ignoring the RomeoCharlie additions,\nof course). The consistency of the numbering scheme provides evidence to suggest that the developer(s) behind R-C1\ncustomize particular commands between families. The Suicide and RunAs commands found in RomeoHotel are\ntechnically available in RomeoAlfa but have been reduced to little more than NOP commands. It is possible to make this\nclaim based on the fact that the numbering scheme is consistent between families, both RomeoAlfa and RomeoHotel\nsupport commands at offset 0x1A (RunAs) and 0x1C (Suicide), and, despite their code being slightly different, they have\nthe same basic structure. Figure 2-3 illustrates how the code structure for RomeoHotel and RomeoAlfa are nearly identical\ndespite RomeoAlfa’s functional handicapping.\n\n\n-----\n\n|OFFSET FROM BASE COMMAND NUMBER|Col2|Col3|Col4|Col5|PURPOSE|\n|---|---|---|---|---|---|\n|Alfa|Bravo|Charlie|Hotel|November||\n|+0x07|+0x07|+0x07|+0x07|+0x07|Unknown|\n|+0x11|+0x11|+0x13|+0x11|+0x11|Unknown|\n|+0x13|+0x13|+0x15|+0x13|+0x13|Unknown (probably related to relaying)|\n|+0x14|+0x14|+0x16|+0x14|+0x14|Relay Status: Failure|\n|+0x15|+0x15|+0x17|+0x15|+0x15|Command Status: Success|\n|+0x16|+0x16|+0x18|+0x16|+0x16|Command Status: Failure|\n\n```\n          int Cmd_RunCommandAsUser(SOCKET s, LPWSTR lpCommandLine)\n          {\n           unsigned char b[4];\n           int result = ReceiveDataFromC2(s, b, 4, 1, 0);\n           if ( !result )\n           {\n            if ( RunCommandAsUser(s, lpCommandLine) )\n             result = SendResponseCodeToC2(s, 0x9751, 0);\n            else\n             result = SendResponseCodeToC2(s, 0x9750, 0);\n           }\n           return result;\n          }\n          int Cmd_RunCommandAsUser(SOCKET s)\n          {\n           unsigned char b[4];\n           int result = ReceiveDataFromC2(&g_fConnectToC2, s, b, 4, 1, 0);\n           if ( !result )\n           {\n            if ( returnZer0() )\n             result = SendResponseCodeToC2(&g_fConnectToC2, v1, 0x8751, 0);\n            else\n             result = SendResponseCodeToC2(&g_fConnectToC2, v1, 0x8750, 0);\n           }\n           return result;\n          }\n\n```\n**Figure 2-3: Comparison of the RunAs Command’s (offset +0x1A) Function in RomeoHotel (Upper) and RomeoAlfa (Lower)**\n\nTable 2-2 somewhat obscures an important trait of the numbering scheme used by R-C1. There are gaps within the\nnumber scheme that have significance. Many commands within R-C1 return a status code to indicate the success or\nfailure of a command which contributes to at least two of the gaps within the numbering scheme. R-C1 uses two numbers\nwithin the numbering scheme as the success and failure response codes as indicated in Table 2-3. There is evidence that\nPapaAlfa acts as a proxy for several R-C1-based families and as a result, at least one of the gaps in the number scheme is\nthe result of a PapaAlfa-based status code. The purpose or reasoning behind the remaining three gaps is currently unclear.\n\n**OFFSET FROM BASE COMMAND NUMBER**\n\n**PURPOSE**\nAlfa Bravo Charlie Hotel November\n\n+0x07 +0x07 +0x07 +0x07 +0x07 Unknown\n\n+0x11 +0x11 +0x13 +0x11 +0x11 Unknown\n\n+0x13 +0x13 +0x15 +0x13 +0x13 Unknown (probably related to relaying)\n\n+0x14 +0x14 +0x16 +0x14 +0x14 Relay Status: Failure\n\n+0x15 +0x15 +0x17 +0x15 +0x15 Command Status: Success\n\n+0x16 +0x16 +0x18 +0x16 +0x16 Command Status: Failure\n\n**Table 2-3: Romeo-CoreOne Numbering Gaps and Their Purpose**\n\n\n-----\n\n|FEATURE|ROMEOALFA-ONE|ROMEOALFA-TWO|\n|---|---|---|\n|Configuration initialization|Performed in WinMain|Performed in separate function, called by main|\n|Dynamic API loading string obfuscation|Space-Dot|Caracachs|\n|Romeo-CoreOne base command number|0x873B|0x8374|\n|Request Channel|0x6456|0x3594|\n|Configuration data structure size|728 bytes|2784 bytes|\n\n\n## 3. [RAT] RomeoAlfa\n\nRomeoAlfa is a client-mode RAT that utilizes the R-C1 framework and command set (see Section 2). There are two\nobserved variants, RomeoAlfa-One and RomeoAlfa-Two. Functionally, each variant performs the same basic operations\nand supports the same R-C1 command set. What differentiates the variants are subtle, but important, structural changes\nas defined in Table 3-1.\n\n**FEATURE** **ROMEOALFA-ONE** **ROMEOALFA-TWO**\n\nPerformed in separate function,\nConfiguration initialization Performed in WinMain\ncalled by main\n\nDynamic API loading string obfuscation Space-Dot Caracachs\n\nRomeo-CoreOne base command number 0x873B 0x8374\n\nRequest Channel 0x6456 0x3594\n\nConfiguration data structure size 728 bytes 2784 bytes\n\n**Table 3-1: Key Differences between RomeoAlfa-One and RomeoAlfa-Two**\n\nThe most apparent difference between RomeoAlfa-One and RomeoAlfa-Two is the configuration initialization\ncomponent of the RomeoAlfa scaffolding code. The initialization of the configuration in both RomeoAlfa variants is\nfunctionally identical as seen in Figure 3-1 and Figure 3-2. The difference between the two is the location of the code.\nWhile RomeoAlfa-One performs the initialization inline within the WinMain function, RomeoAlfa-Two has an entirely\nseparate function that is responsible not only for initializing the configuration parameters but also for dynamically\nloading the API functions.\n\n\n-----\n\n```\n          int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int\n          nShowCmd)\n          {\n\n```\n**wszC2Entry *p = (wszC2Entry *)&config;**\n```\n           do\n           {\n            wcscpy(p->c2, L\"0.0.0.0\");\n            ++p;\n           }\n\n```\n**while ( p < &config.field_190 );**\n**wcscpy(config arrwszC2s[0].c2, L\"203.131.222.102\");**\n**config.arrdwC2Ports[0] = 443;**\n**wcscpy(config.arrwszC2s[5].c2, L\"208.105.226.235\");**\n**config.arrdwC2Ports[5] = 443;**\n**config.dwSleepTimeBetweenReconnects = 60;**\n**config.field_2D0 = 0;**\n**config.dwStartupDelayInSeconds = 0;**\n**config.qwSysInfoPacketsSent = 0i64;**\n**config.dwConnectionAttemptsBeforeSleep = 5;**\n**srand(GetTickCount()^ time(0));**\n**config.initialRandomNumber = rand();**\n```\n           MoveTrojanToStartupFolder();\n           MainLoop(0);\n           log((char *)”---------------End--------------!\\n”);\n           return 0;\n          }\n\n```\n**Figure 3-1: RomeoAlfa-One’s WinMain with the Configuration Initialization Code Inline**\n\n\n-----\n\n```\n          int Initialize()\n          {\n\n```\n**LoadKernel32APIs();**\n**LoadWs2_32APIs();**\n```\n           LoadAdvapiAPIs();\n           LoadIphlpapiAPIs();\n\n```\n**if ( InitializeWinsock() )**\n```\n           {\n            return 1;\n           }\n           else\n           {\n\n```\n**wszC2Entry *p= &config.arrwszC2s[0];**\n```\n            do\n            {\n             wcscpy(p->c2, L\"0.0.0.0\");\n             ++p;\n            }\n\n```\n**while ( p < &config.field_190 );**\n**wcscpy(config.arrwszC2s[0].c2, L\"91.183.71.18\");**\n**config.arrdwC2Ports[0] = 443;**\n**wcscpy(config.arrwszC2s[3].c2, L\"160.218.101.125\");**\n**config.arrdwC2Ports[3] = 443;**\n**wcscpy(config.arrwszC2s[6].c2, L\"37.34.176.14\");**\n**config.arrdwC2Ports[6] = 443;**\n**config.dwSleepTimeBetweenReconnects = 60;**\n**config.field_AD0 = 0;**\n**config.field_ACC = 0;**\n**config.field_AC0 = 0;**\n**config.field_AC4 = 0;**\n**config.dwConnectionAttemptsBeforeSleep = 5;**\n**srand(GetTickCount() ^ time(0));**\n**config.field initialRandomNumber AB8 = rand();**\n**config.dwStartupDelayInSeconds = 0;**\n**config.field_ADC = 0;**\n```\n           }\n           return 0;\n          }\n\n```\n**Figure 3-2: RomeoAlfa-Two’s Configuration Initialization Function**\n\nThe size of the configuration data structure varies greatly between RomeoAlfa-One and RomeoAlfa-Two. Notably, the\nconfiguration data structure of RomeoAlfa-Two matches the configuration data structure of RomeoHotel (see Section 10).\nIn addition, the fields are identical, meaning that RomeoAlfa-Two and RomeoHotel use the same configuration. Yet, while\nthe data structure and fields are identical, RomeoAlfa-Two does not fully utilize all of the configuration data fields. The\nmost probable reason for this behavior is that RomeoAlfa-Two and RomeoHotel use a common code for the scaffolding\nsurrounding R-C1, but do not implement all of the same features.\n\nA noteworthy fact about the configuration’s initialization is the setup of the C2 server addresses. The configuration data\nstructure supports 10 different C2 servers for RomeoAlfa to randomly select when making a connection. The initialization\nsequence begins by first replacing all 10 entries with 0.0.0.0 to indicate the entry is invalid. Then the initialization\ncode replaces non-sequential entries with the actual C2 server IP addresses. This is interesting for two reasons: the\nconfiguration is hardcoded at compile time, meaning any changes to the configuration will not persist after a reboot, and\nthere are likely additional C2 servers that have been commented out in the source code that fill the missing gaps between\nC2 server IP addresses.\n\n\n-----\n\n|STATE VALUE|DESCRIPTION|\n|---|---|\n|1|Initialized state (only occurs prior to first C2 connection attempt)|\n|2|Sleep state|\n|3|Not used in RomeoAlfa|\n|4|Not used in RomeoAlfa|\n|5|Active state|\n\n\nRomeoAlfa maintains its persistence by locating itself within the Start Menu folder (CSIDL_STARTUP) or the All User’s\nStart Menu (CSIDL_COMMON_STARTUP) of the victim’s computer. After initializing the configuration data structure,\nRomeoAlfa moves its current running executable to the Start Menu directory via a call to MoveFile.\n\nRomeoAlfa randomly selects a C2 server from the ten possible server addresses within the configuration data structure\nand use the selected address to establish a connection. If the connection to the selected C2 server fails or the selected C2\nserver’s address is 0.0.0.0, a new C2 server is randomly selected and another attempt is made. If 10 unsuccessful attempts\nare made, RomeoAlfa sleeps for a defined period of time (as specified in the configuration data structure, typically set to\n60 seconds) before attempting the random C2 server selection and connection process again.\n\nOne of the most distinctive features of RomeoAlfa is the use of the fake TLS communication scheme to encrypt\nend-to-end communication as well as to obfuscate the nature of the communication. After successfully connecting to a\nC2 server, RomeoAlfa generates a seemingly legitimate TLS channel, complete with the appropriate handshake protocol\npackets. However, the malware ultimately uses an encryption method that is not supported by the TLS standard. This\nencryption method therefore blends in with legitimate TLS traffic while at the same time is immune to SSL/TLS man-in-\nthe-middle proxying that would reveal the plaintext of the communication.\n\nAfter establishing the fake TLS channel, RomeoAlfa exchanges a 12-byte datagram (through the fake TLS channel) with the\nC2 server as the first step in a two-part handshake. The datagram contains a channel identifier and the current connection\nstate of the RomeoAlfa instance (Table 3-2). The channel identifier corresponds to the channel identifiers found within\nPapaAlfa samples. The code for establishing the handshake (Figure 3-3) is the exact inverse of the handshake function found\nin PapaAlfa. This implies that RomeoAlfa (and, as explained in later sections, RomeoBravo and RomeoHotel) can interface\nwith a PapaAlfa instance, which in turn may be little more than a proxy point for the real C2 server. Regardless of the\npresence of PapaAlfa in the communication stream, the commands ultimately come from the C2 server.\n\n**STATE VALUE** **DESCRIPTION**\n\n1 Initialized state (only occurs prior to first C2 connection attempt)\n\n2 Sleep state\n\n3 Not used in RomeoAlfa\n\n4 Not used in RomeoAlfa\n\n5 Active state\n\n**Table 3-2: RomeoAlfa’s State Values**\n\n\n-----\n\n**int __thiscall EstablishHandshake(DWORD *pfConnectionStatus, SOCKET s, DWORD**\n**dwChannel, DWORD *pdwRequestorIP, DWORD *pdwRequestChannelReply, int dwClientState)**\n```\n          {\n           int result;\n           struct {\n            DWORD dwChannel;\n            DWORD dwIPAddress;\n            DWORD dwState;\n           } outgoing, incoming;\n           incoming.dwChannel = 0;\n           incoming.dwIPAddress = 0;\n           incoming.dwState = 0;\n           outgoing.dwIPAddress = 0;\n           outgoing.dwChannel = dwChannel;\n           outgoing.dwState = dwClientState;\n           if ( SendDataToC2(pfConnectionStatus, s, &outgoing, sizeof(outgoing), 1) )\n           {\n            result = 1;\n           }\n           else if ( ReceiveDataFromC2(pfConnectionStatus, s, &incoming, sizeof(incoming), 1, 0)\n          )\n           {\n            result = 1;\n           }\n           else\n           {\n\n```\n***pdwRequestorIP = incoming.dwIPAddress;**\n***pdwRequestChannelReply = incoming.dwChannelReply;**\n```\n            result = 0;\n           }\n           return result;\n          }\n\n```\n**Figure 3-3: RomeoAlfa’s Handshake Function**\n\nThe second half of the handshake consists of the C2 server responding with another 12-byte datagram\ncontaining RomeoAlfa’s external IP address (incoming.dwIPAddress) and a response to the requested channel\n(incoming.dwChannel), which is typically one value higher than the requested channel. The conclusion of the\nhandshake indicates a successful communication channel is established between the RomeoAlfa instance and the C2\nserver.\n\nWith the communication channel between RomeoAlfa and the C2 server established, the MessageThread of Romeo-\nCoreOne is activated. RomeoAlfa-One fully supports 19 of the R-C1 commands and partially supports three (RunAs,\n_Upload Directory as Archive, and Suicide), while RomeoAlfa-Two fully supports 20 and partially supports two (RunAs and_\n_Upload Directory as Archive). Table 3-3 identifies the commands that the RomeoAlfa variants support along with the_\ncommand identifiers for each command for each variant.\n\n\n-----\n\n|ROMEOALFA-ONE|ROMEOALFA-TWO|COMMAND|\n|---|---|---|\n|0x873B|0x8374|Move File|\n|0x873C|0x8375|Directory Statistics|\n|0x873D|0x8376|Enumerate Drives|\n|0x873E|0x8377|Enumerate Directory|\n|0x873F|0x8378|Write File|\n|0x8740|0x8379|Read File|\n|0x8741|0x837A|Upload Directory as Archive (Defunct)|\n|0x8743|0x837C|Create Process|\n|0x8744|0x837D|Secure Delete|\n|0x8745|0x837E|Mimic Timestamp|\n|0x8746|0x837F|Execute Shell Command with Output Upload|\n|0x8747|0x8380|Enumerate Processes|\n|0x8748|0x8381|Terminate Process|\n|0x8749|0x8382|System Information|\n|0x874A|0x8383|Change Directory|\n|0x874B|0x8384|Port Knock|\n|0x874D|0x8386|Send Status Value|\n|0x874F|0x8388|(RESPONSE CODE) Relay Status: Failure|\n|0x8750|0x8389|(RESPONSE CODE) Command Status: Success|\n|0x8751|0x838A|(RESPONSE CODE) Command Status: Failure|\n|0x8752|0x838B|Disconnect|\n|0x8753|0x838C|Get Config|\n|0x8754|0x838D|Set Config|\n|0x8755|0x838E|RunAs (Defunct)|\n|0x8756|0x838F|NOP|\n|0x8757|0x8390|Suicide (Defunct in RomeoAlfa-One)|\n\n\n**ROMEOALFA-ONE** **ROMEOALFA-TWO** **COMMAND**\n\n0x873B 0x8374 Move File\n\n0x873C 0x8375 Directory Statistics\n\n0x873D 0x8376 Enumerate Drives\n\n0x873E 0x8377 Enumerate Directory\n\n0x873F 0x8378 Write File\n\n0x8740 0x8379 Read File\n\n0x8741 0x837A Upload Directory as Archive (Defunct)\n\n0x8743 0x837C Create Process\n\n0x8744 0x837D Secure Delete\n\n0x8745 0x837E Mimic Timestamp\n\n0x8746 0x837F Execute Shell Command with Output Upload\n\n0x8747 0x8380 Enumerate Processes\n\n0x8748 0x8381 Terminate Process\n\n0x8749 0x8382 System Information\n\n0x874A 0x8383 Change Directory\n\n0x874B 0x8384 Port Knock\n\n0x874D 0x8386 Send Status Value\n\n0x874F 0x8388 (RESPONSE CODE) Relay Status: Failure\n\n0x8750 0x8389 (RESPONSE CODE) Command Status: Success\n\n0x8751 0x838A (RESPONSE CODE) Command Status: Failure\n\n0x8752 0x838B Disconnect\n\n0x8753 0x838C Get Config\n\n0x8754 0x838D Set Config\n\n0x8755 0x838E RunAs (Defunct)\n\n0x8756 0x838F NOP\n\n0x8757 0x8390 Suicide (Defunct in RomeoAlfa-One)\n\n**Table 3-3: RomeoAlfa Command Numbers (by Variant) and Their Descriptions**\n\nRomeoAlfa deviates from the R-C1 command norms for the RunAs, Upload Directory as Archive, and, in the case of\nRomeoAlfa-One variants, Suicide commands. The RunAs command is reduced to little more than a NOP by virtue of\nthe fact that the core component of the command is replaced with a function that will always return a positive status\nresponse, Command Status: Success, to the C2 server. Similarly, the Upload Directory as Archive command is reduced to a\ncommand that generates a temporary file name (starting with DQ in RomeoAlfa-One variants, and QB in RomeoAlfa-Two\nvariants) in the %TEMP% directory and then attempts to upload the file specified to the C2 server, an attempt that will\nmost likely fail. RomeoAlfa-One has disabled (by removal) the portion of the Suicide command that uninstalls or deletes\nthe RomeoAlfa malware from the victim’s system, leaving only the disconnection portion of the function intact.\n\n\n-----\n\n|STATE VALUE|DESCRIPTION|\n|---|---|\n|1|Initialized state (only occurs prior to first C2 connection attempt)|\n|2|Sleep state|\n|3|Post-connection activity event state|\n|4|Change in number of active terminal services sessions during post-connection activity state|\n|5|Active state|\n\n\n## 4. [RAT] RomeoBravo\n\nWith a striking resemblance to RomeoAlfa, RomeoBravo is a client-mode RAT based on R-C1 (see Section 2) that operates\nas either a service DLL or standalone executable. The most notable differences between RomeoAlfa and RomeoBravo are\nthe inclusion of an external configuration file and the use of DNSCALC-style encoding to obscure communication in\nplace of the fake TLS scheme.\n\nRomeoBravo is a service DLL and as such contains the necessary Windows service scaffolding code to operate as a\nlegitimate Windows service. In order to operate as a Windows service, RomeoBravo exports the function ServiceMain\nwhich contains the functionality to provide callback functions for handling service requests from the operating system.\n```\n       ServiceMain also contains dynamic API loading functions for API functions from kernel32.dll, ws2_32.dll,\n\n```\n**advapi32.dll, and iphlapi.dll using Space-Dot obfuscation for the API names. ServiceMain, upon establishing**\nthe necessary Windows service callback and setting the appropriate state for the service, spawns a new thread for the\nRomeoBravo functionality.\n\nRomeoBravo requires a configuration file in order to operate successfully. Located at %SYSDIR%\\tmsconfig.msi, the\nconfiguration file, is a 456-byte DNSCALC-style encoded file that contains up to 10 C2 server addresses and ports along\nwith 5 additional configuration fields. If the file is not found on the victim’s machine, the RomeoBravo thread will silently\nterminate.\n\nAfter loading the configuration, RomeoBravo randomly selects a C2 server address from the loaded configuration.\nRomeoBravo attempts to connect to the selected C2 server address if the address is not 0.0.0.0. If the connection to the\nC2 server fails or the randomly selected C2 server address is 0.0.0.0, a new C2 server is randomly selected and another\nattempt occurs. If 10 unsuccessful attempts to connect to a C2 server occurs, RomeoBravo sleeps for a defined period of\ntime (as specified in the configuration data structure) before attempting the random C2 server selection and connection\nprocess again.\n\nRomeoBravo performs the same 12-byte diagram handshake with the C2 server as described in the RomeoAlfa section (see\nFigure 3-3) in order to select the appropriate channel. The difference between RomeoAlfa’s implementation of the channel\nselection and RomeoBravo’s implementation is the exclusion of fake TLS and the inclusion of DNSCALC-style encoding\nfor the network traffic. RomeoBravo can potentially transmit additional states not found in RomeoAlfa (see Table 4-1). As\ndescribed previously in the RomeoAlfa section, RomeoBravo may interface with PapaAlfa instances instead of the actual\nC2 server issuing commands, but ultimately commands come from the controlling C2 server.\n\n**STATE VALUE** **DESCRIPTION**\n\n1 Initialized state (only occurs prior to first C2 connection attempt)\n\n2 Sleep state\n\n3 Post-connection activity event state\n\n4 Change in number of active terminal services sessions during post-connection activity state\n\n5 Active state\n\n**Table 4-1: RomeoBravo’s States**\n\n\n-----\n\n|COMMAND NUMBER|COMMAND|\n|---|---|\n|0x523B|Move File|\n|0x523C|Directory Statistics|\n|0x523D|Enumerate Drives|\n|0x523E|Enumerate Directory|\n|0x523F|Write File|\n|0x5240|Read File|\n|0x5241|Upload Directory as Archive|\n|0x5243|Create Process|\n|0x5244|Secure Delete|\n|0x5245|Mimic Timestamp|\n|0x5246|Execute Shell Command with Output Upload|\n|0x5247|Enumerate Processes|\n|0x5248|Terminate Process|\n|0x5249|System Information|\n|0x524A|Change Directory|\n|0x524B|Port Knock|\n|0x524E|Send Status|\n|0x5250|(RESPONSE CODE) Relay Status: Failure|\n|0x5251|(RESPONSE CODE) Command Status: Success|\n|0x5252|(RESPONSE CODE) Command Status: Failure|\n|0x5253|Disconnect|\n|0x5254|Get Config|\n|0x5255|Set Config|\n\n\nAfter establishing a communication channel between RomeoBravo and the C2 server, the MessageThread of R-C1 is\nactivated. RomeoBravo fully supports 20 commands from R-C1’s command set. Table 4-2 identifies the commands that the\nRomeoBravo supports along with the command identifiers for each command.\n\n**COMMAND NUMBER** **COMMAND**\n\n0x523B _Move File_\n\n0x523C _Directory Statistics_\n\n0x523D _Enumerate Drives_\n\n0x523E _Enumerate Directory_\n\n0x523F _Write File_\n\n0x5240 _Read File_\n\n0x5241 _Upload Directory as Archive_\n\n0x5243 _Create Process_\n\n0x5244 _Secure Delete_\n\n0x5245 _Mimic Timestamp_\n\n0x5246 _Execute Shell Command with Output Upload_\n\n0x5247 _Enumerate Processes_\n\n0x5248 _Terminate Process_\n\n0x5249 _System Information_\n\n0x524A _Change Directory_\n\n0x524B _Port Knock_\n\n0x524E _Send Status_\n\n0x5250 (RESPONSE CODE) Relay Status: Failure\n\n0x5251 (RESPONSE CODE) Command Status: Success\n\n0x5252 (RESPONSE CODE) Command Status: Failure\n\n0x5253 _Disconnect_\n\n0x5254 _Get Config_\n\n0x5255 _Set Config_\n\n**Table 4-2: RomeoBravo’s Supported Commands and Their Identifiers**\n\nThe code used by RomeoBravo’s implementation of R-C1 is nearly identical to that used by RomeoAlfa with the exception\nof the Secure Delete command. RomeoBravo’s Secure Delete implementation does not attempt to rename the targeted file\nwith a randomly generated name of equal size, as is normally done by the Lazarus Group, but instead generates a new\nfilename with the form TMP{random decimal number}.tmp and makes a call to MoveFile to rename the file. After\nthe file is renamed, the file is then deleted. This is a minor change in form from others that use the secure deletion\nfunctionality within the Lazarus Group, but it is a notable change that makes the particular implementation unique.\n\n\n-----\n\n|FEATURE|ROMEOCHARLIE-ONE|ROMEOCHARLIE-TWO|\n|---|---|---|\n|Dynamic APIs Loaded|114 Functions from 10 DLLs|103 Functions from 4 DLLs|\n|Start of Execution|ServiceMain|DllMain|\n|Configuration Location|HKLM\\SYSTEM\\CurrentControlSet\\ Control\\WMI\\Security\\xc123465- efff-87cc-37abcdef9|HKLM\\SYSTEM\\CurrentControlSet\\ Control\\WMI\\Security\\ffcf3465- efff-87cc-37abcdef9|\n|Startup Delay|0 Seconds|3 Seconds|\n|Romeo-CoreOne Commands|19|20|\n\n\n## 5. [RAT] RomeoCharlie\n\nWith observed compile dates going back to February 5, 2014, RomeoCharlie is one of the oldest R-C1-based RATs (see\nSection 2) in the Lazarus Group’s collection. A server-mode RAT, RomeoCharlie uses DNSCALC-style encoding for network\ncommunication and RSA encryption for client authentication. There are two observed variants, RomeoCharlie-One and\nRomeoCharlie-Two. The differences between the two are cosmetic in nature, as Table 5-1 illustrates:\n\n**FEATURE** **ROMEOCHARLIE-ONE** **ROMEOCHARLIE-TWO**\n\nDynamic APIs Loaded 114 Functions from 10 DLLs 103 Functions from 4 DLLs\n\nStart of Execution `ServiceMain` `DllMain`\n```\n                   HKLM\\SYSTEM\\CurrentControlSet\\ HKLM\\SYSTEM\\CurrentControlSet\\\n\n```\nConfiguration Location **Control\\WMI\\Security\\xc123465-** **Control\\WMI\\Security\\ffcf3465-**\n\n**efff-87cc-37abcdef9** **efff-87cc-37abcdef9**\n\nStartup Delay 0 Seconds 3 Seconds\n\nRomeo-CoreOne\n19 20\nCommands\n\n**Table 5-1: Key Differences between RomeoCharlie-One and RomeoCharlie-Two**\n\nRomeoCharlie-One operates as a service DLL that dictates that the binary must conform to the basic guidelines of a Windows\nservice – specifically, the export of the ServiceMain function. ServiceMain contains the necessary scaffolding code\nto ensure the Windows Services subsystem treats the binary as a legitimate service, but the function also contains several\ndynamic API loading functions for kernel32.dll, ws2_32.dll, advapi32.dll, oleaut32.dll, iphlpapi.dll,\n```\n       urlmon.dll, wininet.dll, user32.dll, shell32.dll, and shlwapi.dll. All said, RomeoCharlie-One loads 114\n\n```\ndifferent API functions into memory, but only 59 (approximately 52%) of these API functions are ever used by the malware.\nRomeoCharlie-One loads APIs from, but completely ignores, 6 of the 10 DLLs, indicating that the dynamic API loading\nfunctions are part of a larger library of code.\n\nRomeoCharlie-Two, on the other hand, does not require the complete Windows Services scaffolding as its sibling and\ntherefore does not export ServiceMain, nor does it even contain a ServiceMain-type function. Instead, execution of\nthe RomeoCharlie-Two code begins in DllMain as a newly generated thread. The RomeoCharlie-Two code begins with a\n3 second sleep delay before dynamically loading API functions from kernel32.dll, ws2_32.dll, advapi32.dll, and\n```\n       iphlpapi.dll. Of the 103 API functions that RomeoCharlie-Two loads, the malware uses 73 (approximately 71%) of the\n\n```\nfunctions, a dramatic increase from RomeoCharlie-One.\n\nBoth variants of RomeoCharlie begin, after the dynamic API loading, by loading their configuration from the registry\ninto memory. IndiaBravo-RomeoCharlie generates and stores the configuration for RomeoCharlie under the registry\nbranch HKLM\\SYSTEM\\CurrentControlSet\\Control\\WMI\\Security. The key under which the configuration\nresides varies by variant: RomeoCharlie-One’s configuration exists under xc123465-efff-87cc-37abcdef9, while\nRomeoCharlie-Two’s configuration exists under ffcf3465-efff-87cc-37abcdef9. Both configurations are the same\nsize (120 bytes) and contain a minimal amount of information: the listening port, the name of the service name under\nwhich the RomeoCharlie malware is running, the number of authenticated connections (from clients) that have occurred,\nand a 64-bit random value (presumably a unique identifier for the infection).\n\n\n-----\n\n|PARAMETER|VALUE|\n|---|---|\n|d|b076e0580463a202bad74cb9c1b85af3fb4d1be513ccca3ae 8b57d193be77b4ab63802b3216d3a80b008 27b693593a76be884f41b491ee1f6136b3755add91e2de9b0f5b3849d463fcd 7b9a3b6cd0744caf809f510 ee04ab3c714f53422d24f33361f75145b08286d2d7d99704684ed1d25fd5a9dc7b993f8e4d074234fd82d3|\n|n|11|\n\n\nWith the configuration of the RomeoCharlie variants loaded into memory, the differences between RomeoCharlie-One\nand RomeoCharlie-Two cease (save for one exception that will be explained). RomeoCharlie is a server-mode RAT and,\nas such, must establish a listening port. Before a listening port is established at the Winsock level, RomeoCharlie first\nopens a hole in the Windows Firewall to allow incoming connections on the desired listening port (as specified in the\nconfiguration). The task of opening a firewall port consists of constructing and then issuing the command line seen in\nFigure 5-1 via CreateProcess.\n\n**cmd.exe /c netsh firewall add portopening TCP <listening port number> \"adp\"**\n\n**Figure 5-1: RomeoCharlie-One’s Firewall Modification Command**\n\nThe command for opening the firewall is the exact same command (include the “adp” rule name) found in TangoAlfa and\nPapaAlfa. Not only is the command identical, but the method of constructing the command (Figure 5-2) is identical to the\nmethod used by both TangoAlfa and PapaAlfa.\n```\n          sprintf(szCommandLine, “%sd.e%sc n%ssh%srewa%s ad%s po%sop%sing T%s %d \\\"%s\\\"\", \"cm\", \"xe\n\n```\n**/\", \"et\", \" fi\", \"ll\", \"d\", \"rt\", \"en\", \"CP\", wPort, \"adp\")**\n\n**Figure 5-2: Code Snippet from RomeoCharlie-One used for the Construction of the Firewall Modification Command**\n\nIf RomeoCharlie is unable to execute the firewall command or bind a socket to the desired listening socket, the malware\nquietly stops executing. If, however, RomeoCharlie is successful in binding a listening socket and opening the firewall for\nthe socket, the malware enters an infinite loop that waits for incoming connections. For each incoming connection, a new\nthread is spawned for the R-C1 MessageThread to handle the client’s requests.\n\nUnlike other R-C1 based families, RomeoCharlie integrates the handshake/authentication phase into the\n```\n       MessageThread function. Additionally, this handshake/authentication phase is significantly more involved than\n\n```\nthe other R-C1 based families. The handshake begins by RomeoCharlie sending a 16-byte data structure to the client,\nconsisting of an 8-byte value containing the number of times RomeoCharlie has successfully authenticated clients\nfollowed by an 8-byte value containing the randomly generated number generated by IndiaBravo-RomeoCharlie at\ninstallation (a value that most likely is the unique identifier for the infection). The communication channel between\nRomeoCharlie and the client is obfuscated by DNSCALC-style encoding the data stream prior to transmission.\n\nThe client must send back a specially crafted 130-byte data blob. The data blob is RSA-encoded using an unknown private\nkey. RomeoCharlie decrypts the data blob using the parameters specified Table 5-2. The data blob, after decryption,\ncontains three fields: the letters a through z (lower case) as a NULL-terminated string, a NULL-terminated string\nrepresenting the number of times RomeoCharlie has successfully authenticated clients plus one, and a NULL-terminated\nstring representing the 8-byte unique infection identifier of the RomeoCharlie instance. If any of the three values do not\nmatch the expected values, the connection between the client and RomeoCharlie is terminated.\n\n**PARAMETER** **VALUE**\n\nb076e0580463a202bad74cb9c1b85af3fb4d1be513ccca3ae 8b57d193be77b4ab63802b3216d3a80b008\n\nd 27b693593a76be884f41b491ee1f6136b3755add91e2de9b0f5b3849d463fcd 7b9a3b6cd0744caf809f510\n\nee04ab3c714f53422d24f33361f75145b08286d2d7d99704684ed1d25fd5a9dc7b993f8e4d074234fd82d3\n\nn 11\n\n**Table 5-2: Components of the RSA Key RomeoCharlie Uses to Decrypt the Client’s Authentication Data Blob**\n\n\n-----\n\n|ROMEOCHARLIE-ONE|ROMEOCHARLIE-TWO|COMMAND|\n|---|---|---|\n|0x54B7|0x54B7|Move File|\n|0x54B8|0x54B8|Directory Statistics|\n|0x54B9|0x54B9|Enumerate Drives|\n|0x54BA|0x54BA|Enumerate Directory|\n|0x54BB|0x54BB|Write File|\n|0x54BC|0x54BC|Read File|\n|0x54BD|0x54BD|Upload Directory as Archive|\n|0x54BF|0x54BF|Create Process|\n|0x54C0|0x54C0|Secure Delete|\n|0x54C1|0x54C1|Mimic Timestamp|\n|0x54C2|0x54C2|Execute Shell Command with Output Upload|\n|0x54C3|0x54C3|Enumerate Processes|\n|0x54C4|0x54C4|Terminate Process|\n|0x54C5|0x54C5|Change Listening Port|\n|0x54C6|0x54C6|System Information|\n|0x54C7|0x54C7|Change Directory|\n|0x54C8|0x54C8|Port Knock|\n|0x54C9|0x54C9|Proxy|\n|0x54CB|0x54CB|Send Status|\n|0x54CD|0x54CD|(RESPONSE CODE) Relay Status: Failure|\n|0x54CE|0x54CE|(RESPONSE CODE) Command Status: Success|\n|0x54CF|0x54CF|(RESPONSE CODE) Command Status: Failure|\n||0x54D0|Disconnect|\n\n\nAfter establishing the authenticity of the client, MessageThread begins processing the incoming commands from the\nclient. The final distinction between the RomeoCharlie variants is the number of commands each variant fully supports.\nRomeoCharlie-One supports 19 commands, while RomeoCharlie-Two supports the same 19 commands plus the\n_Disconnect command. Table 5-1 lists the complete command sets for both variants._\n\n**ROMEOCHARLIE-ONE** **ROMEOCHARLIE-TWO** **COMMAND**\n\n0x54B7 0x54B7 _Move File_\n\n0x54B8 0x54B8 _Directory Statistics_\n\n0x54B9 0x54B9 _Enumerate Drives_\n\n0x54BA 0x54BA _Enumerate Directory_\n\n0x54BB 0x54BB _Write File_\n\n0x54BC 0x54BC _Read File_\n\n0x54BD 0x54BD _Upload Directory as Archive_\n\n0x54BF 0x54BF _Create Process_\n\n0x54C0 0x54C0 _Secure Delete_\n\n0x54C1 0x54C1 _Mimic Timestamp_\n\n0x54C2 0x54C2 _Execute Shell Command with Output Upload_\n\n0x54C3 0x54C3 _Enumerate Processes_\n\n0x54C4 0x54C4 _Terminate Process_\n\n0x54C5 0x54C5 _Change Listening Port_\n\n0x54C6 0x54C6 _System Information_\n\n0x54C7 0x54C7 _Change Directory_\n\n0x54C8 0x54C8 _Port Knock_\n\n0x54C9 0x54C9 _Proxy_\n\n0x54CB 0x54CB _Send Status_\n\n0x54CD 0x54CD (RESPONSE CODE) Relay Status: Failure\n\n0x54CE 0x54CE (RESPONSE CODE) Command Status: Success\n\n0x54CF 0x54CF (RESPONSE CODE) Command Status: Failure\n\n0x54D0 _Disconnect_\n\n**Table 5-3: RomeoCharlie Command Numbers (by Variant) and Their Descriptions**\n\nWithin the list of supported commands, there are two outliers not found in other R-C1 based families: Change Listening\n_Port and Proxy. The Change Listening Port command receives a new listening port to which the RomeoCharlie sample_\nshould bind, resulting in the malware updating and saving the configuration to the registry before terminating the\nconnection to the client. After the client disconnect, RomeoCharlie begins the process of establishing a new listening\nsocket (complete with changing the firewall settings and binding to the specified port) before waiting for new incoming\nclient connections.\n\nThe Proxy command receives an address from the client and attempts to connect to the computer at the address. If\nsuccessful, the Proxy command spawns two threads. The first thread simply relays any communication originating from\nthe client’s socket to the new endpoint, while the second thread relays any communication originating from the new\nendpoint to the client’s socket. There is no encryption or obfuscation applied to the communication going through the\nrelays. The Proxy command calls WaitForMultipleObjects to return before returning control to MessageThread.\n\n\n-----\n\n## 6. [RAT] RomeoDelta\n\nRomeoDelta is a RAT dropped by IndiaFoxtrot alongside DeltaBravo. In addition to being dropped alongside DeltaBravo,\nRomeoDelta contains a significant amount of code and artifact overlap with DeltaCharlie, indicating a shared\ndevelopment environment, if not a shared developer(s).\n\nOperating as a service DLL, RomeoDelta performs the necessary scaffolding required by Windows Services in order to\nappear as a legitimate service before spawning a thread that contains the core functionality of RomeoDelta. The core\nfunctionality begins by dynamically loading the necessary API functions (the names of which are obfuscated using\nSpace-Dot encoding). RomeoDelta then determines its exclusivity on the victim’s system by detecting the presence (or\nabsence) of Global\\WindowsUpdateTracing{number}.{number} , where the two {number} values change as the\nmalware has evolved over time. The first {number} is typically 0 with the second {number} incrementing over time as if to\nindicate a versioning system. The same type of mutex name is also found in IndiaFoxtrot.\n\nThe configuration file for RomeoDelta typically exists within a file named msxml13.xml (or msxml15.xml in later\nvariants of RomeoDelta). Encrypted using RC4, the configuration file is loaded and decrypted by RomeoDelta\nwith the most commonly observed passwords for the configuration file being BAISEO%$2fas9vQsfvx%$,\n**C!@I#%VJSIEOTQWPVz034vuA, and GetFileAttributesW.**\n\nThe configuration file contains three C2 server addresses (and their listening port numbers). After loading the\nconfiguration, RomeoDelta attempts to contact one of the C2 server addresses (in the order present in the configuration).\nThe connection process begins with RomeoDelta resolving the domain name of the C2 server. If the address resolves,\nthe IP address is XOR’d with 0x1AB9C2D8 in order to reveal the real address of the C2 server. RomeoDelta attempts to\ncontact the C2 server and, if successful, begins the handshake process. The handshake procedure is identical to that used\nby DeltaCharlie, consisting of a 16-byte authentication sequence involving the use of DNSCALC-style encoding. The\nfollowing sequence occurs during the handshake between RomeoDelta and the C2 server:\n\n1. RomeoDelta generates a random 16-byte buffer\n\n2. RomeoDelta encodes the bytes using DNSCALC-style encoding\n\n3. RomeoDelta sends the encoded buffer to the C2 server\n\n4. The C2 server replies with the original 16-bytes (before the DNSCALC-style encoding)\n\n5. RomeoDelta verifies the original 16-byte buffer and sends back a packet with the identifier of 0x611 to indicate a\n\nsuccessful handshake.\n\nThe handshake that RomeoDelta (as well as DeltaCharlie) employs has a striking similarity to the handshake procedure of\nSierraJuliett-MikeOne.\n\nAfter the handshake, RomeoDelta transmits a portion of the configuration to the C2 server. If the configuration of\nRomeoDelta does not contain a non-zero ID number, the malware transmits details of the victim’s system to the C2 server\nand the C2 server responds with an ID number.\n\nFor later variants of RomeoDelta, the malware will locate the directory containing the keylog files of KiloAlfa and proceed\nto decrypt the files. Once decrypted, RomeoDelta will generate a ZIP file with the contents of the keylog files, encrypt the\nfile using RC4, and transmit the file to the C2 server.\n\n\n-----\n\n|COMMAND ID|DESCRIPTION|\n|---|---|\n|0x58692AB8|Uploads victim’s system information to C2 server|\n|0x58692AB9|Open a listening port on the victim’s machine, sends the port number to the C2 server, waits up to 10 seconds for the C2 server to successfully connect to the port. C2 server responds with the status of the connect-back test.|\n|0x58692ABA|Writes the embedded file within the command file to the victim’s hard drive (in the %TEMP% directory with a name starting with gbl_) and executes the file via a call to CreateProcess.|\n|0x58692ABB|Opens a listening port (using the same technique as command 0x58692AB9) and performs a connect-back test. If the resulting response code from the C2 server is 0x611, either writes the file contained within the original command file or downloads a file from the URL specified in the command file. After the file is on the victim’s hard drive (in the %TEMP% directory with a name starting with gbl_), executes the file via a call to CreateProcess.|\n|0x58692ABC|Updates the 3rd DWORD in the configuration with a value specified in the command file.|\n|0x58692ABD|Updates the C2 server addresses within the configuration file via the values specified in the command file.|\n|0x58692ABE|Archives (in ZIP format) the specified directory, encrypts the ZIP file (saved as MSI{random}.LOG), and uploads the file to the C2 server. This command is not available in earlier versions of RomeoDelta.|\n\n\nCommands from the C2 server come in the form of command files. RomeoDelta downloads data from the C2 server and\nsaves the data to a temporary file beginning with FXSAPI in the %TEMP% directory. The structure of the command file is\nidentical to the structure of the DeltaCharlie command files, where bytes 4 through 132 contain a RSA encrypted data blob\nthat once decrypted with a public key (Figure 6-1) reveals the MD5 value of the data that follows the 132[nd] byte. The RSA\nfunctionality that RomeoDelta employs is the exact same code found in SierraJuliett-MikeOne. Only the public keys differ\nbetween the two families.\n\n**23805C8DB86385D315F2D4E43072EF0B432333834A2058DD5AFD0637D3681D5B79463AB2BA15ECE38BEB680B**\n**64C884F15AC2D8FDF4CB463634B4EB2725398C7AC51DA787526C5FDA235DA913C0C7E04B1A405BFEA4F63568**\n**E5B25B3D2636F4D50996BD1D2390EFDFEF636BB901D9C1C7128033CF0FE951AEBD303F3967527FD6**\n\n**Figure 6-1: RomeoDelta’s Public Key**\n\nThe data that follows the encrypted MD5 value is encrypted with RC4 using the password BAISEO%$2fas9vQsfvx%$.\nAfter decryption, the decrypted data is loaded into a buffer and the command file is deleted. An acknowledgment of the\ndecryption is sent to the C2 server by RomeoDelta before the command within the command file is handled.\n\nRomeoDelta supports a limited set of commands as identified in Table 6-1.\n\n**COMMAND ID** **DESCRIPTION**\n\n0x58692AB8 Uploads victim’s system information to C2 server\n\nOpen a listening port on the victim’s machine, sends the port number to the C2 server, waits up to 10\n\n0x58692AB9 seconds for the C2 server to successfully connect to the port. C2 server responds with the status of the\n\nconnect-back test.\n\nWrites the embedded file within the command file to the victim’s hard drive (in the %TEMP% directory with\n0x58692ABA\na name starting with gbl_) and executes the file via a call to CreateProcess.\n\nOpens a listening port (using the same technique as command 0x58692AB9) and performs a connect-back\ntest. If the resulting response code from the C2 server is 0x611, either writes the file contained within the\n\n0x58692ABB original command file or downloads a file from the URL specified in the command file. After the file is on\n\nthe victim’s hard drive (in the %TEMP% directory with a name starting with gbl_), executes the file via a\ncall to CreateProcess.\n\n0x58692ABC Updates the 3[rd] DWORD in the configuration with a value specified in the command file.\n\n0x58692ABD Updates the C2 server addresses within the configuration file via the values specified in the command file.\n\n0x58692ABE Archives (in ZIP format) the specified directory, encrypts the ZIP file (saved as MSI{random}.LOG), and\nuploads the file to the C2 server. This command is not available in earlier versions of RomeoDelta.\n\n\n-----\n\n|COMMAND ID|DESCRIPTION|\n|---|---|\n|0x58692ABF|For each user on the victim’s machine, copies the following directories and files into a ZIP archives with filenames beginning with A000. • User’s “Recent” folder • User’s “Favorites” folder • User’s Vandyke Software’s SecureCRT config folder2 • User’s FileZilla folder3 • User’s ESTsoft’s ALFTP folder4 • User’s NetSarang folder5 • User’s mRemoteNG folder6 • User’s Default.rdp file • User’s Desktop.lst file • User’s Documents.lst file Generate a directory listing for each user’s Desktop and My Documents directories in separate text files with names beginning with A000. The following commands are executed and their output saved to the files beginning with A000: • ipconfig -all • net view • net view /domain • netstat -ano • tasklist /svc • query user Once all of the data is archived into a ZIP file, encrypts the archive using RC4 and transmit to the C2 server. The command is also capable of looking for common Windows user profile directories in English, Italian, Spanish and Portuguese.|\n|0x58692AC0|For the service specified in the command file, renames the existing service DLL to wmdrmsdk.dat, and writes the file embedded within the command file to the victim’s hard drive using the name of the service’s DLL. This command is not available in earlier versions of RomeoDelta.|\n\n\n**COMMAND ID** **DESCRIPTION**\n\nFor each user on the victim’s machine, copies the following directories and files into a ZIP archives with\nfilenames beginning with A000.\n\n                    - User’s “Recent” folder\n\n                     - User’s “Favorites” folder\n\n                     - User’s Vandyke Software’s SecureCRT config folder[2 ]\n\n                        - User’s FileZilla folder[3]\n\n                      - User’s ESTsoft’s ALFTP folder[4]\n\n                      - User’s NetSarang folder[5]\n\n                    - User’s mRemoteNG folder[6]\n\n                      - User’s Default.rdp file\n\n                      - User’s Desktop.lst file\n\n                     - User’s Documents.lst file\n\n0x58692ABF\n\nGenerate a directory listing for each user’s Desktop and My Documents directories in separate text files\nwith names beginning with A000. The following commands are executed and their output saved to the files\nbeginning with A000:\n\n                            - **ipconfig -all**\n\n                            - `net view`\n\n                            - `net view /domain`\n\n                            - `netstat -ano`\n\n                            - **tasklist /svc**\n\n                            - **query user**\n\nOnce all of the data is archived into a ZIP file, encrypts the archive using RC4 and transmit to the C2 server.\n\nThe command is also capable of looking for common Windows user profile directories in English, Italian,\nSpanish and Portuguese.\n\nFor the service specified in the command file, renames the existing service DLL to wmdrmsdk.dat, and\n\n0x58692AC0 writes the file embedded within the command file to the victim’s hard drive using the name of the service’s\n\nDLL. This command is not available in earlier versions of RomeoDelta.\n\n**Table 6-1: RomeoDelta’s Supported Command**\n\n**2** **3** **4** **5** **6**\n\n[2 VanDyke Software. “VanDyke Software Products” https://www.vandyke.com/products/index.html Accessed 5 February 2016](https://www.vandyke.com/products/index.html)\n\n[3 FileZilla. “FileZilla – The Free FTP Solution”. https://filezilla-project.org/ Accessed 5 February 2016](https://filezilla-project.org/)\n\n[4 ESTsoft. “ALTools” http://www.estsoft.com/altools Accessed 5 February 2016](http://www.estsoft.com/altools)\n\n[5 Netsarang Computer. https://www.netsarang.com/ Accessed 5 February 2016](https://www.netsarang.com/)\n\n[6 mRemoteNG. “mRemoteNG” http://www.mremoteng.org/ Accessed 5 February 2016](http://www.mremoteng.org/)\n\n\n-----\n\nCommand 0x58692AB9, a NAT check, attempts to bind to the first available port from a list of ordered port numbers\n(Figure 6-2). As part of the test, RomeoDelta opens a hole in the victim’s host-based firewall by issuing the command seen\nin Figure 6-3. After the C2 server connects, the listening port is shutdown and the firewall rule is removed.\n\n**443, 110, 53, 80, 995, 25, 8080, 1816, 465, 1521, 3306, 1433, 3128, 109, 161, 444, 1080, 520,**\n**700, 1293, 1337, 2710, 3100, 3305, 3689, 11371, 1024, 1035, 1900, 2004, 2053, 1098, 3098,**\n**4343, 3024, 1058**\n\n**Figure 6-2: RomeoDelta’s Ordered Port List**\n\n**cmd.exe /c netsh advfirewall firewall add rule name=\"Windows Media Player Network**\n```\n         Sharing\" dir=in action=allow Protocol=TCP localport={PORT NUMBER}\n\n```\n**Figure 6-3: RomeoDelta’s Firewall Modification Command**\n\nAfter each command is received and executed, RomeoDelta sleeps for a period of time specified in the configuration file.\nThe interval between command are expressed in minutes, not seconds, indicating that the attackers using RomeoDelta\nare not likely issuing real-time commands, but rather strategic, predefined commands.\n\nIf a C2 server address fails to result in a connection between RomeoDelta and the C2 server, RomeoDelta sleeps for one\nhour before attempting the next C2 server address in the configuration. Again, this indicates that RomeoDelta is a tool\nthat is not for rapid, or even real-time, interaction, but rather slower, stealthier command interchange.\n\nLater versions of RomeoDelta introduce commands that pertain to long-term recon collection (specifically 0x58692ABF\nand 0x58692AC0). Coupling the slow command execution and C2 server interactions with the long-term collection\nfunctions, RomeoDelta is designed to be a data collection tool for longer running operations instead of rapid fire remote\nadministration.\n\n\n-----\n\n## 7. [RAT] RomeoEcho\n\nA stark departure from the design pattern found in Romeo-CoreOne-base families, RomeoEcho is a RAT that uses a more\ninteractive command shell format for command identification. The RomeoEcho samples begin within the DllMain\nfunction by attempting to create a mutex named “__mutex_set_cookie__”. If RomeoEcho is unable to create the\nmutex due to the error condition ERROR_ALREADY_EXISTS, indicating that the named mutex already exists, the DLL\nframework will not activate the RomeoEcho operational core.\n\nWhether activated by DllMain or WinMain (for the standalone executable sample), the operational core of RomeoEcho\nis the same. Upon activation, the core binds to a listening port on the victim’s computer. The port number varies per\nsamples with known port numbers being 1984, 4558, 2550, 3080, and 3579.\n\nWhen an incoming connection occurs, the first task the core performs is a handshake to establish the authenticity of the\nclient making the connection. The handshake protocol consists of the core sending a constant (0x18D1F71F) to the client\nin plaintext as a 4-byte (DWORD) data buffer. The client must respond with another constant (0xC46FF197) over the\nsame socket, also in plaintext, otherwise RomeoEcho terminates the connection with the client. The client then transmits\nanother 4-byte value to the core. This 4-byte value is the communications key for any further communication between\nthe client and the RomeoEcho instance.\n\nCommunication between the client and RomeoEcho, after the handshake, is encrypted using a bitwise roll, an XOR,\nand either an addition or a subtract operation (depending on the direction of the encryption). The communications key\ndictates the particulars of the transformation, as Figure 7-1 illustrates. The core of the transformation is an XOR/SUB or\nXOR/ADD in the same vein as the DNSCALC-style encoding.\n```\n          void DecryptBuffer(char *pvData, int dwLength)\n          {\n           for (int j = 0; j < dwLength; ++j )\n           {\n\n```\n**pvData[j] = (cryptoKey[1] ^ __ROL__(pvData[j], cryptoKey[2])) - cryptoKey[0];**\n```\n           }\n          }\n          void EncryptBuffer(char *pvData, int dwLength)\n          {\n           for ( int j = 0; j < dwLength; ++j )\n           {\n\n```\n**pvData[j] = __ROR1__( cryptoKey[1] ^ (cryptoKey[0] + pvData[j]), cryptoKey[2]);**\n```\n           }\n          }\n\n```\n**Figure 7-1: RomeoEcho’s Communication Decryption/Encryption Functions**\n\nWith the communications key established and the handshake complete, RomeoEcho’s core activates the communications\nloop function. RomeoEcho is single-threaded and does not spawn a new thread for incoming connections. As a result,\nonly one client can access a RomeoEcho-infected node at a time.\n\n\n-----\n\n|COMMAND IDENTIFIER|ARGUMENT COUNT|DESCRIPTION|\n|---|---|---|\n|_del|1|Securely deletes the file specified|\n|_dir|1|Returns the list of files and their attributes (flags, size, timestamps) in the specified directory.|\n|_exe|1|Executes the specified command line via WinExec|\n|_get|2|Transfers the specified file (first argument) from the victim’s machine to the client. The second argument is unused.|\n|_got|2|Transfers the specified file (first argument) from the victim’s machine to the client and then securely deletes the file on the victim’s computer. The second argument is unused.|\n|_quit|0|Terminates the session between the client and RomeoEcho.|\n|_put|2|Transfers a file from the client to the victim’s machine and saves the file at the specified location (second argument). The first argument is unused.|\n\n\nThe communications loop begins each loop by receiving a 4-byte (DWORD) value from the client specifying the size\nof the next packet that the client is to send. The client then sends the specified number of bytes to the RomeoEcho\ninstance. Effectively, RomeoEcho is using a datagram format found in many of the Lazarus Group’s families but at a much\nmore simplified level. The datagram received by RomeoEcho specifies the particular command to execute as an ASCII\nstring with the command and arguments delimitated by a pipe (|) characters. At its most basic, the format for incoming\ncommands is:\n\n{command name}|{optional arguments 1}|{optional argument 2}|{and so on}\n\nRomeoEcho supports seven commands, identified in Table 7-1.\n\n**COMMAND** **ARGUMENT**\n\n**DESCRIPTION**\n\n**IDENTIFIER** **COUNT**\n\n`_del` 1 Securely deletes the file specified\n\nReturns the list of files and their attributes (flags, size, timestamps) in the specified\n`_dir` 1 directory.\n\n`_exe` 1 Executes the specified command line via WinExec\n\nTransfers the specified file (first argument) from the victim’s machine to the client. The\n`_get` 2 second argument is unused.\n\nTransfers the specified file (first argument) from the victim’s machine to the client and\n`_got` 2 then securely deletes the file on the victim’s computer. The second argument is unused.\n\n**_quit** 0 Terminates the session between the client and RomeoEcho.\n\nTransfers a file from the client to the victim’s machine and saves the file at the specified\n`_put` 2 location (second argument). The first argument is unused.\n\n**Table 7-1:RomeoEcho’s Supported Commands**\n\nThe Windows operating system provides a variety of APIs for interfacing with the file system. The two most notable APIs\nare the Windows-native APIs (such as CreateFile, ReadFile, and WriteFile) and the POSIX APIs (such as _open,\n```\n       _read, and _write). RomeoEcho uses the POSIX API when dealing with a victim’s file system for the _get, _ got,\n\n```\nand _put commands. However, the _del command uses the Windows API primarily for the destruction of files. It\nis somewhat unusual for a developer to switch to a different API so abruptly, possibly suggesting that more than one\ndeveloper was responsible for the RomeoEcho source code.\n\nThe _del function deviates from the normal secure delete functionality found in many of the Lazarus Group’s families.\nThe _del command begins by determining the size of the file to destroy and then generating a heap of equal size.\nThe heap is then zeroed and written to the target file. The file is read into memory, in its entirety, and compared to the\nzeroed buffer to ensure the write was successful. The heap buffer is set to all 0xFF values and written to the target, and\nthe write is verified. The buffer is filled with cryptographically strong random data by calling CryptGenRandom from\nthe Microsoft cryptographic API and written to the target file, and the write is, again, verified. Finally, the heap buffer\nis again zeroed and written to the disk with one final verification that the write was successful. The deletion of the file\nconsists of calling the POSIX function _chsize to set the file’s size to 0 bytes, then calling DeviceIoControl with\n```\n       FSCTL_DELETE_OBJECT_ID to attempt to unlink the file from the file system, followed by calls to MoveFileExA and\n       DeleteFileA. The secure deletion functionality of RomeoEcho is thorough and exhibits coding styles contrary to the\n\n```\nlevel of sophistication found in other parts of the RomeoEcho code base.\n\n\n-----\n\n## 8. [RAT] RomeoFoxtrot\n\nOperating as a server mode RAT, RomeoFoxtrot uses a simple handshake to establish a connection and variant-dependent\nencryption to transfer data making the malware significantly less sophisticated from a network perspective than\nother members of the Romeo class. Despite the lack of network sophistication, RomeoFoxtrot provides a large number\nof commands to handle aspects of file management, process management, network proxying, and victim computer\ninformation enumeration.\n\nThere are two known variants of RomeoFoxtrot: RomeoFoxtrot-One and RomeoFoxtrot-Two. The RomeoFoxtrot\nfamily has been observed as the payload of the IndiaCharlie variants, with IndiaCharlie-One observed dropping\nRomeoFoxtrot-One and IndiaCharlie-Two observed dropping RomeoFoxtrot-Two. Functionally, the two variants are very\nsimilar with only two distinctions. The primary distinction is the inclusion of a configuration file for RomoeFoxtrot-Two\nthat specifies the listening port, while RomeoFoxtrot-One uses a hardcoded value. The second is a renumbering\nof command identifiers. Given the similarities, the remainder of this section will simply refer to them equally as\nRomeoFoxtrot unless a particular detail is specific to one variant over the other.\n\nUpon activation, RomeoFoxtrot generates a listening port on the victim’s system and spawns a new handler thread for all\nincoming connection, thereby allowing RomeoFoxtrot to handle multiple clients at once. When a new client connects,\na handshake procedure begins with the client sending a NULL-terminated string of POST HTTP REQUEST? and\nRomeoFoxtrot responding with RESPONSE 200 OK!!!. If the handshake fails, the connection and the handler threat\nterminate.\n\nAfter the handshake, RomeoFoxtrot enters a continual loop: waiting for a command from the client, executing\nthe command, and returning to a waiting state for more commands. The communication between the client and\nRomeoFoxtrot-Two is encrypted with RC4. The first 128 bytes of a datagram between RomeoFoxtrot-Two and the client\ncontain a 128-byte RC4 key if and only if the size of the datagram is larger than 128 bytes. Conversely, all communication\nbetween RomeoFoxtrot-One and the client is either in plaintext (for older versions of the variant) or encoded with a\nsimply XOR 0x81.\n\n\n-----\n\n|ROMEOFOXTROT-ONE COMMAND ID|ROMEOFOXTROT-TWO COMMAND ID|COMMAND DESCRIPTION|\n|---|---|---|\n|0x2010|0x2000A|Echoes the request packet back to the client with the size field set to 512 bytes.|\n|0x2020|0x30002|Uploads the specified file from the victim’s machine to the client.|\n||0x3000B|Uploads the specified directory’s files from the victim’s machine to the client.|\n|0x2030|0x30001|Writes the specified file at the specified location from the client to the victim’s machine|\n|0x2040|0x30005|Recursively deletes directory and its descendants|\n||0x3000A|Recursively secure deletes directory and its descendants|\n|0x2050|0x30006|Move or renames a file|\n|0x2060|0x30007|Mimics the timestamp of one file unto another file as specified by the client|\n|0x2080|0x30008|Creates the specified directory on the victim’s machine|\n||0x30009|Port knock on the specified endpoint.|\n|0x2090||Executes the specified command while piping the output of the command to a file on the victim’s machine. The file containing the output is uploaded to the client and deleted from the victim’s machine|\n|0x20C0, 0x20E0, 0x2180|0x20006, 0x2000B, 0x30004|Enumerates the processes on the victim’s machine|\n|0x20F0|0x20005|Returns information about the network interface cards (NICs) of the victim’s machine (up to 16 NICs) as an array of IP_ADAPTER_INFO structures.|\n|0x2100|0x20002|Returns the victim’s computer name to the client|\n|0x2110||Returns the output of the API function GetLocaleInfoA to the client.|\n||0x20003|Returns the output of the API function GetLocaleInfoW to the client.|\n|0x2120|0x20007|Returns the output of the API function GetVersionExA to the client.|\n|0x2130||Sends the DWORD 0x1000000 to the client.|\n||0x20008|Sends the DWORD 0x2000001 to the client.|\n|0x2150 0x2170|0x40001|Activates an interactive command shell on the victim’s computer with input and output piped to the client’s endpoint.|\n|0x2160|0x20009|Attempts to bind to the following ports on the victim’s machine in order to determine if the port is active or not: 3389, 443, 80, 53, 110, 8080, 1433, , 3306, 1521 A list of the ports that are in use is sent to the client or, if none of the desired ports are in use, returns “There aren`t open ports.”|\n|0x2310|0x20004|For each attached drive on the victim’s system, returns the volume’s name and its free space to the client.|\n|0x2320|0x2000C|Returns a file listing for the specified directory|\n||0x2000D|Changes the listening port of RomeoDelta and restarts the malware.|\n|0x2360|0x40002|Client supplies a list of endpoint that RomeoFoxtrot uses to attempt a connection using the client protocol for establishing a connection to a RomeoFoxtrot node. This effectively allows for the establishment of a proxy through one RomeoFoxtrot node to another.|\n\n\n**ROMEOFOXTROT-ONE** **ROMEOFOXTROT-TWO**\n\n**COMMAND DESCRIPTION**\n\n**COMMAND ID** **COMMAND ID**\n\nEchoes the request packet back to the client with the size field\n0x2010 0x2000A\nset to 512 bytes.\n\n0x2020 0x30002 Uploads the specified file from the victim’s machine to the client.\n\nUploads the specified directory’s files from the victim’s machine\n0x3000B\nto the client.\n\nWrites the specified file at the specified location from the client\n0x2030 0x30001\nto the victim’s machine\n\n0x2040 0x30005 Recursively deletes directory and its descendants\n\n0x3000A Recursively secure deletes directory and its descendants\n\n0x2050 0x30006 Move or renames a file\n\nMimics the timestamp of one file unto another file as specified by\n0x2060 0x30007\nthe client\n\n0x2080 0x30008 Creates the specified directory on the victim’s machine\n\n0x30009 Port knock on the specified endpoint.\n\nExecutes the specified command while piping the output of the\ncommand to a file on the victim’s machine. The file containing\n\n0x2090\n\nthe output is uploaded to the client and deleted from the victim’s\nmachine\n\n0x20C0, 0x20006,\n0x20E0, 0x2000B, Enumerates the processes on the victim’s machine\n0x2180 0x30004\n\nReturns information about the network interface cards (NICs) of\n\n0x20F0 0x20005 the victim’s machine (up to 16 NICs) as an array of\n```\n                                 IP_ADAPTER_INFO structures.\n\n```\n0x2100 0x20002 Returns the victim’s computer name to the client\n\n0x2110 Returns the output of the API function GetLocaleInfoA to\nthe client.\n\n0x20003 Returns the output of the API function GetLocaleInfoW to\nthe client.\n\n0x2120 0x20007 Returns the output of the API function GetVersionExA to the\nclient.\n\n0x2130 Sends the DWORD 0x1000000 to the client.\n\n0x20008 Sends the DWORD 0x2000001 to the client.\n\n0x2150 Activates an interactive command shell on the victim’s computer\n0x40001\n0x2170 with input and output piped to the client’s endpoint.\n\nAttempts to bind to the following ports on the victim’s machine in\norder to determine if the port is active or not:\n\n3389, 443, 80, 53, 110, 8080, 1433, , 3306, 1521\n\n0x2160 0x20009\n\nA list of the ports that are in use is sent to the client or, if none of\nthe desired ports are in use, returns “There aren`t open\n```\n                                 ports.”\n\n```\nFor each attached drive on the victim’s system, returns the\n0x2310 0x20004\nvolume’s name and its free space to the client.\n\n0x2320 0x2000C Returns a file listing for the specified directory\n\nChanges the listening port of RomeoDelta and restarts the\n0x2000D\nmalware.\n\nClient supplies a list of endpoint that RomeoFoxtrot uses to\nattempt a connection using the client protocol for establishing a\n\n0x2360 0x40002 connection to a RomeoFoxtrot node. This effectively allows for\n\nthe establishment of a proxy through one RomeoFoxtrot node to\nanother.\n\n**Table 8-1: RomeoFoxtrot Supported Commands and Their Identifiers**\n\n\n-----\n\n## 9. [RAT] RomeoGolf\n\nObserved as the payload of IndiaEcho and loaded by LimaBravo, RomeoGolf is a RAT with some similarity to the families\nderived from Romeo-CoreOne (see Section 2) and as RomeoFoxtrot-Two (see Section 8) in terms of the commands\nsupported. Structurally, however, RomeoGolf is a family unto its own.\n\nWhile capable of operating as a service DLL, the core functionality of RomeoGolf is activated out of the DllMain, not\nthe ServiceMain, export. Upon activation, RomeoGolf spawns a new thread that attempts to open a handle to the\nRomeoGolf binary and then calls the LockFile API function with that handle in order to prevent disruption of the\nRomeoGolf executable. The thread then goes into an infinite sleep.\n\nRomeoGolf is heavily object oriented and written in C++. With the exception of the file locking thread just mentioned,\nall of RomeoGolf’s functionality is contained within a single class. Within the class are two additional classes: a class for\nnetwork communication to and from the C2 server and a class containing the list of queued commands.\n\nRomeoGolf’s class contains a primary member function responsible for its operation (a function Novetta identifies as the\n```\n       Execute function). When the Execute function is called, it enters an infinite loop where the following tasks occur:\n\n```\n1. The configuration file (crkdf32.inf ) is loaded into memory. Failure to load the configuration results in a\n\none-minute delay before another attempt is made. RomeoGolf does not continue until the configuration file is loaded\nsuccessfully, and instead continues the cycle of attempted loads and sleeps.\n\n2. The unique identifier for the victim’s machine is checked within the configuration and, if found to be 0, is generated\n\nby using 4 calls of the rand() function to generate the necessary 64-bits of the identifier.\n\n3. A flag within the configuration is checked to determine if all the files and drives of the victim’s machine have been\n\nenumerated, and, if not, a new thread is generated (along with a signaling event) to perform the task.\n\n4. A flag within the configuration is checked to determine if the victim’s Terminal Service’s has been enumerated\n\nfor active users, and, if not, a new thread is generated (along with a signaling event) to perform the task. The\nenumeration lasts until at least one user logs in through either Terminal Services or the local console.\n\n5. The victim’s system information is gathered including the machine’s name, the victim’s username, the operating system,\n\nlocation information, the processor type, available memory size, and the IP addresses associated with the machine.\n\n6. A C2 server address is randomly selected from the configuration and an attempt to connect to the C2 server is made.\n\nUp to 10 attempts to contact a C2 server are made before the operation fails. Between each attempt to contact a C2\nserver, RomeoGolf sleeps for 1 minute.\n\n7. If a successful connection is made to a C2 server, a new thread is generated that sends a heartbeat signal to the C2\n\nserver every 1 minute. If after 10 attempts no connections are successful, RomeoGolf sleeps for a preconfigured\nperiod of time (measured in minutes) before looping back to Task #1.\n\n8. RomeoGolf receives commands from the C2 server and executes the appropriate handler for each command.\n\n9. After the command processing concludes, the connection to the C2 server is terminated, and any queued commands\n\nare purged.\n\n10. The last contact time within the configuration is updated, indicating the last time the malware contacted a C2\n\nserver, and the configuration is saved to disk.\n\n11. Loops back to Task #1.\n\n\n-----\n\n|COMMAND ID|DESCRIPTION|\n|---|---|\n|0x10001000|Returns information about the attached drives on the victim’s machine|\n|0x10001001|Enumerates the specific directory.|\n|0x10001002|Copies file (locally)|\n|0x10001003|Deletes the specified file|\n|0x10001004|Securely deletes the specified file|\n|0x10001005|Downloads a file from the C2 server.|\n|0x10001006|Uploads file|\n|0x10001007|Executes the supplied command line|\n|0x10001008|Mimics the file timestamp of the specified file unto another specified file.|\n|0x10001009|(missing)|\n|0x1000100A|Port knock.|\n|0x1000100B|Executes a command, pipes the output of the command to a file and uploads the file to the C2 server.|\n|0x1000100C|Disconnects from C2 server|\n|0x1000100D|Enumerates running processes.|\n|0x1000100E|Terminates a process.|\n|0x1000100F|(missing)|\n|0x10001010|Gets the statistics (directory count, total size, timestamps) of the specified directory.|\n|0x10001011|Uploads the current configuration to the C2 server.|\n|0x10001012|Updates the current configuration from the configuration received.|\n|0x10001013|ZIPs the contents of the specified directory (and its descendent directories) and uploads the file to the C2 server.|\n|0x10001014|Changes the startup delay time to match that of the current sleep delay between C2 connections.|\n|0x10001015|(missing)|\n|0x10001016|[STATUS CODE] Command successful|\n|0x10001017|[STATUS CODE] Command unsuccessful|\n\n\nTask #3 involves enumerating all of the files on the victim’s machine and retaining this information in the folder\n**%TEMP%\\Z802056. The enumeration task has similarities to the same task in RomeoHotel (see Section 10): not only are**\nthe files recursively enumerated, but also, if at least 5 GB of hard drive space is available on the victim’s system hard drive\n(typically C:), copies of enumerated files on removable devices (excluding CD/DVD drives) and file shares are retained.\n\nRomeoGolf utilizes fake TLS to encode the communication between itself and its C2 server. Unlike other Romeos,\nRomeoGolf does not use an additional handshake protocols over the fake TLS handshake. The C2 server can send a burst\nof commands to RomeoGolf. RomeoGolf reads command datagrams from the C2 server and places each command in a\nlinked-list of queued commands. The linked-list supports up to 10 queued commands. After the C2 server completes the\ntransfer of commands, RomeoGolf begins executing each command in order.\n\nThe command table (Table 9-1) has a striking similarity in both functionality and order to that of the R-C1-derived\nfamilies and RomeoFoxtrot-Two. Each command returns its result, if any, to the C2 server and uses a special command ID\nvalue to indicate the success or failure of the command in the same way as Romeo-CoreOne-derived families.\n\n**COMMAND ID** **DESCRIPTION**\n\n0x10001000 Returns information about the attached drives on the victim’s machine\n\n0x10001001 Enumerates the specific directory.\n\n0x10001002 Copies file (locally)\n\n0x10001003 Deletes the specified file\n\n0x10001004 Securely deletes the specified file\n\n0x10001005 Downloads a file from the C2 server.\n\n0x10001006 Uploads file\n\n0x10001007 Executes the supplied command line\n\n0x10001008 Mimics the file timestamp of the specified file unto another specified file.\n\n0x10001009 (missing)\n\n0x1000100A Port knock.\n\n0x1000100B Executes a command, pipes the output of the command to a file and uploads the file to the C2 server.\n\n0x1000100C Disconnects from C2 server\n\n0x1000100D Enumerates running processes.\n\n0x1000100E Terminates a process.\n\n0x1000100F (missing)\n\n0x10001010 Gets the statistics (directory count, total size, timestamps) of the specified directory.\n\n0x10001011 Uploads the current configuration to the C2 server.\n\n0x10001012 Updates the current configuration from the configuration received.\n\nZIPs the contents of the specified directory (and its descendent directories) and uploads the file to the C2\n0x10001013\nserver.\n\n0x10001014 Changes the startup delay time to match that of the current sleep delay between C2 connections.\n\n0x10001015 (missing)\n\n0x10001016 [STATUS CODE] Command successful\n\n0x10001017 [STATUS CODE] Command unsuccessful\n\n**Table 9-1: RomeoGolf’s Supported Commands and Their Identifiers**\n\n\n-----\n\n|COMMAND IDENTIFIER|COMMAND|\n|---|---|\n|0x973B|Move File|\n|0x973C|Directory Statistics|\n|0x973D|Enumerate Drives|\n|0x973E|Enumerate Directory|\n|0x973F|Write File|\n|0x9740|Read File|\n|0x9741|Upload Directory as Archive (Defunct)|\n|0x9743|Create Process|\n|0x9744|Secure Delete|\n|0x9745|Mimic Timestamp|\n|0x9746|Execute Shell Command with Output Upload|\n|0x9747|Enumerate Processes|\n\n\n## 10. [RAT] RomeoHotel\n\nWhile capable of running as a loaded DLL, observed RomeoHotel samples rely on LimaCharlie to load. RomeoHotel is a\nclient-mode RAT that utilizes R-C1 (Section 2) for its core command processing code. RomeoHotel is notable for having\nboth 32-bit and 64-bit samples, though there are functionally no differences between the variants other than their\nsupported architectures.\n\nRomeoHotel acts as a hybrid of RomeoAlfa-Two (Section 3) and RomeoCharlie-Two (Section 5). Structurally, RomeoHotel\nis nearly identical to RomeoCharlie-Two: RomeoHotel retains its configuration in the registry (specifically, the registry\nentry HKLM\\SYSTEM\\CurrentControlSet\\Control\\WMI\\Security\\zc62a465-efff-87cc-47cdcdefa), uses a\nstartup delay, and operates as a thread spawned out of DllMain.\n\nFunctionally, RomeoHotel is nearly identical to RomeoAlfa: RomeoHotel supports the same commands within the R-C1\nportion of itself, has an identical configuration data structure in both size and field meaning to that of RomeoAlfa-Two,\nand uses fake TLS for communication. RomeoHotel supports the same command set found in RomeoAlfa-Two, but\nsupports all commands fully, while RomeoAlfa-Two does not fully support all of its commands. For example, RomeoHotel\nsupports the RunAs command fully while the RomeoAlfa variants will accept the command but will perform not action as\na result of the instruction from the C2 server.\n\nThe numbering of commands between RomeoAlfa-One and RomeoHotel are exactly one-to-one with a 0x1000 offset, e.g.\n_Move File in RomeoAlfa-One is 0x873B and 0x973B in RomeoHotel. It is unclear if the offset between the two is indicative of a_\ngenerational shift, a coincidence of versioning, or a conscious decision by the developer(s). But the fact remains that given the\nsimilarities between the RomeoAlfa and RomeoHotel families, the one-to-one (with offset) of commands is eye catching.\n\nTable 10-1 lists RomeoHotel’s supported commands and their command identifiers.\n\n**COMMAND**\n**COMMAND**\n**IDENTIFIER**\n\n0x973B _Move File_\n\n0x973C _Directory Statistics_\n\n0x973D _Enumerate Drives_\n\n0x973E _Enumerate Directory_\n\n0x973F _Write File_\n\n0x9740 _Read File_\n\n0x9741 _Upload Directory as Archive (Defunct)_\n\n0x9743 _Create Process_\n\n0x9744 _Secure Delete_\n\n0x9745 _Mimic Timestamp_\n\n0x9746 _Execute Shell Command with Output Upload_\n\n0x9747 _Enumerate Processes_\n\n\n-----\n\n|COMMAND IDENTIFIER|COMMAND|\n|---|---|\n|0x9748|Terminate Process|\n|0x9749|System Information|\n|0x974A|Change Directory|\n|0x974B|Port Knock|\n|0x974D|Send Status Value|\n|0x974F|(RESPONSE CODE) Relay Status: Failure|\n|0x9750|(RESPONSE CODE) Command Status: Success|\n|0x9751|(RESPONSE CODE) Command Status: Failure|\n|0x9752|Disconnect|\n|0x9753|Get Config|\n|0x9754|Set Config|\n|0x9755|RunAs|\n|0x9756|NOP|\n|0x9757|Suicide|\n\n\n**COMMAND**\n**COMMAND**\n**IDENTIFIER**\n\n0x9748 _Terminate Process_\n\n0x9749 _System Information_\n\n0x974A _Change Directory_\n\n0x974B _Port Knock_\n\n0x974D _Send Status Value_\n\n0x974F (RESPONSE CODE) Relay Status: Failure\n\n0x9750 (RESPONSE CODE) Command Status: Success\n\n0x9751 (RESPONSE CODE) Command Status: Failure\n\n0x9752 _Disconnect_\n\n0x9753 _Get Config_\n\n0x9754 _Set Config_\n\n0x9755 _RunAs_\n\n0x9756 _NOP_\n\n0x9757 _Suicide_\n\n**Table 10-1: RomeoHotel’s Supported Commands and Their Identifiers**\n\nDespite the similarities between RomeoHotel and other Romeo-CoreOne-based families, there are key differences that\nmake RomeoHotel unique in the Lazarus Group’s collective. After loading the configuration from the registry and prior to\nthe startup sleep delay, the malware performs three tasks specific to RomeoHotel:\n\n1. Stop a service specified by the configuration and unload its DLL from memory by calling FreeLibrary.\n\n2. Run two commands specified by the configuration via CreateProcess calls.\n\n3. Spawn a new thread that loads two DLLs specified by the configuration after a 20 second sleep delay.\n\nA viable configuration was not observed in any identified samples, making it difficult to determine the intention of the\nthree tasks.\n\nThe sleep delay, hardcoded in RomeoCharlie-Two, is a configurable item specified by the configuration data structure.\nRomeoHotel enforces a maximum startup delay of 180 minutes (3 hours) by reducing any startup delay value to 180\nminutes. RomeoHotel also introduces a delay between successive C2 server connection attempts. Prior to attempting a\nconnection to a C2 server, RomeoHotel sleeps for 10 seconds.\n\nRomeoAlfa, RomeoBravo (see Section 4), RomeoCharlie, and RomeoNovember (see Section 12) each call a function that\nintroduces a sleep delay between endpoint connections. Evidence suggests that each of the families is using a neutered\nversion of the function found in RomeoHotel immediately after exiting the MessageThread function (Figure 10-1).\n\n\n-----\n\n```\n          void __cdecl PostConnectionActivities(int dwMaxDrives)\n          {\n\n```\n**wchar_t wszRootPath[6] = L\"::\\\\\";**\n**DWORD dwPrevDriveMask = GetLogicalDrives();**\n```\n           WTS_SESSION_INFO *pSessionInfos = 0;\n\n```\n**HMODULE hWtsapi32 = LoadLibraryA(\"Wtsapi32.dll\");**\n**pfnWTSEnumerateSessionsA = GetProcAddress(hWtsapi32,**\n```\n                                \"WTSEnumerateSessionsA\");\n           if ( pfnWTSEnumerateSessionsA )\n            pfnWTSEnumerateSessionsA(0, 0, 1, &pSessionInfos, &dwSessionCnt);\n           for ( i = 0; i < dwMaxDrives; ++i )\n           {\n\n```\n**DWORD dwDrivesMask = GetLogicalDrives();**\n**if ( dwDrivesMask > dwPrevDriveMask )**\n```\n            {\n\n```\n**DWORD dwDriveMaskDiff = dwDrivesMask - dwPrevDriveMask;**\n**g_connectionState = 3;**\n```\n             DWORD dwDriveIndex = 2;\n\n```\n**while ( !((dwDriveMaskDiff >> dwDriveIndex) & 1) )**\n```\n             {\n\n```\n**if ( ++dwDriveIndex >= 26 )**\n```\n               goto LABEL_10;\n             }\n             wszRootPath[0] = dwDriveIndex + 'A';\n          LABEL_10:\n             wprintf(L\"USB Volumn = %s\\r\\n\", wszRootPath);\n\n```\n**dwPostConnectionActivityMode = config.dwPostConnectionActivityMode;**\n**if ( config.dwPostConnectionActivityMode == 3**\n**|| config.dwPostConnectionActivityMode == 5**\n**|| config.dwPostConnectionActivityMode == 6 )**\n```\n             {\n              CreateThread(0, 0, DuplicateDirectoriesThread, wszRootPath, 0, 0);\n              Sleep(1000);\n\n```\n**dwPostConnectionActivityMode = config.dwPostConnectionActivityMode;**\n```\n             }\n             if ( dwPostConnectionActivityMode == 2\n               || dwPostConnectionActivityMode == 4\n\n```\n**|| dwPostConnectionActivityMode == 6 )**\n```\n             {\n              GetDrivesFileListAndSaveToFile(wszRootPath);\n\n```\n**dwPostConnectionActivityMode = config.dwPostConnectionActivityMode;**\n```\n             }\n             if ( dwPostConnectionActivityMode == 1\n               || dwPostConnectionActivityMode == 4\n               || dwPostConnectionActivityMode == 5 )\n\n```\n**break;**\n```\n            }\n\n```\n**dwPrevDriveMask = dwDrivesMask;**\n```\n            if ( pfnWTSEnumerateSessionsA )\n            {\n             pfnWTSEnumerateSessionsA(0, 0, 1, &pSessionInfos, &pdwActiveSessions);\n             if ( pdwActiveSessions > dwSessionCnt\n\n```\n**&& config.fAbortPostConnectionActivityOnNewTSSessions == 1 )**\n```\n             {\n              g_connectionState = 4;\n              return;\n             }\n             dwSessionCnt = pdwActiveSessions;\n            }\n\n```\n**Sleep(60000);**\n```\n           }\n          }\n\n```\n**Figure 10-1: RomeoHotel’s Post MessageThread/Disconnect Activity Function**\n\nThe function in Figure 10-1 enumerates the logical drives on the victim’s system and potentially performs up to three\ntasks based on the value set within the configuration data structure for each logical drive.\n\n\n-----\n\n|dwPostConnection ActivityModeValue|TASK PERFORMED|\n|---|---|\n|3, 5, or 6|If at least 5 GB of space is available on the system drive (e.g. C:), copy the contents of the logical drive to %TEMP%\\PAS02034\\{serial number of logical drive}\\temp.|\n|2, 4, or 6|Process a full list of all files on the logical drive in a text file stored at %TEMP%\\PAS02034\\{serial number of logical drive}\\{serial number of logical drive in hexadecimal}.dat|\n|1, 4, or 5|Stop processing additional logical drives|\n\n\n**dwPostConnection ActivityModeValue** **TASK PERFORMED**\n\nIf at least 5 GB of space is available on the system drive (e.g. C:), copy the\n\n3, 5, or 6 contents of the logical drive to %TEMP%\\PAS02034\\{serial number of logical\n\ndrive}\\temp.\n\nProcess a full list of all files on the logical drive in a text file stored at\n\n2, 4, or 6 **%TEMP%\\PAS02034\\{serial number of logical drive}\\{serial number of logical**\n\ndrive in hexadecimal}.dat\n\n1, 4, or 5 Stop processing additional logical drives\n\n**Table 10-2: Tasks RomeoHotel’s Post MessageThread Activity Function May Perform on Each Logical Drive**\n\nAt first glance, the behavior of the PostConnectionActivities function seems unusual, but it is, in actuality, a very\nclever method of storing the contents of removable drives such as USB drives, CD/DVD drives, and network shares that\nmay accessible on the victim’s computer for short and infrequent periods of time. What is curious, however, is why this\nfunctionality was excluded from other R-C1 based families.\n\n\n-----\n\n## 11. [RAT] RomeoMike\n\nA component of the reported Ten Days of Rain attacks, RomeoMike is a RAT with a very limited set of capabilities yet\nexhibits a great deal of functional and procedural similarity to SierraJuliett (see Section 17) and DeltaCharlie with regards\nto the way commands are processed through signed command files. RomeoMike is a service DLL that, after establishing\nthe scaffolding code to appear as a legitimate Windows service, begins by calling DialogBoxParam. The inclusion of the\n```\n       DialogBoxParam call is unusual due to the fact that the DialogFunc callback passed to DialogBoxParam simple\n\n```\nreturns 0 meaning that a modal dialogue, or any dialogue for that matter, will never appear.\n\nRomeoMike performs a dynamic API loading operation for iphlpapi.dll, kernel32.dll, ws2_32.dll,\n```\n       psapi.dll, and wtsapi32.dll. AES encryption is used for the obfuscation of the API names. After loading the\n\n```\nvarious API functions, the configuration file located at %SYSDIR%\\faultrep.dat is loaded into memory. The\nconfiguration file contains information related to the unique identifier for the particular instance of RomeoMike, the\nidentifier of the last command file executed (which will be explained shortly), a list of up to 10 C2 servers, and various\nother management artifacts.\n\nA new thread is generated by RomeoMike to handle the bulk of its functionality in order to free up the service’s thread\nand thus avoid appearing as a hung service. The new thread spawns another thread for the actual functionality of\nRomeoMike. This new thread contains an infinite loop that performs the following tasks:\n\n1. Determine if the last contact to the C2 was more than 3.6 hours ago, if not wait 20 minutes.\n\n2. Attempt to connect to a C2 server (using the list of C2 servers in sequence). If a connection cannot be made, sleep for\n\n20 minutes before trying the list again until a connection is successful.\n\n3. Send a DWORD (0x45196327) to the C2 server, read a DWORD from the C2 server and verify that the value sent and\n\nthe value received are the same. A failure at this stage results in a C2 retry after 20 minutes.\n\n4. Send an initial WORD (0x3000) to the C2 server.\n\n5. Send the (in order) the 64-bit identifier of the infection, the first DWORD of the configuration, and the DWORD of\n\nthe ID of the last command executed to the C2 server.\n\n6. Receive a series of files from the C2 server, storing each file in the %SYSDIR%\\111 directory with a random file\n\ntimestamp. For each file successfully received, send a WORD (0x0001) to the C2 server. Repeat until the server\nresponds with WORD 0xFFFF.\n\n7. Sleep for one second\n\n8. Disconnect from the C2 server.\n\n9. For each file in the %SYSDIR%\\111 directory, process the command file and execute the appropriate command hander.\n\n10. Update the last contact time and save the configuration to disk.\n\n11. A sleep of 20 minutes occurs.\n\n12. Repeat at step 1.\n\nStep #9 requires RomeoMike to load each file within the %SYSDIR%\\111 directory into memory in chunks. The first\nchunk read consists of 4 bytes. The first four bytes indicate the number of commands that the command file contains.\nFollowing the first 4 bytes, a 128-byte chunk is read into memory. Encrypted with a private RSA key, the 128-byte chunk\ncontains another header (the command header) which RomeoMike must decrypt with a public key (Figure 11-1).\n\n\n-----\n\n|OFFSET|SIZE|DESCRIPTION|\n|---|---|---|\n|0|2 Bytes (WORD)|Command Type|\n|2|16 Bytes|MD5 hash of the data the follows the command header|\n|18|2 Bytes|Unused|\n|20|4 Bytes (DWORD)|Size of the data the follows the command header|\n\n|COMMAND TYPE IDENTIFIER|DESCRIPTION|\n|---|---|\n|0x1001|Writes file to disk and executes the file via CreateProcess.|\n|0x1002|Loads an unknown module into memory and calls one of its exports, then write the file embedded in the command file to disk and executes the file via CreateProcess. As indicated in McAfee’s report,7 the name of the module and export are unknown as the decryption of the AES encrypted string results in unusable output. What is known about the module’s name is that it is up to 11 characters long plus a NULL-byte and what is known about the export’s name is that it is up to 19 characters long plus a NULL-byte.|\n|0x1003|Executes the supplied command line string via CreateProcess.|\n\n\n**5BEFBF9CE323994CA723C71EF91F3E6E1A233D56B8DA897B5E01D3AE3BB02E6552D66F9E7F9993DC35048811E7**\n**651E26CF16C5151E742093C30E865E4F2056738374A830FE47E14E4655AE58FA1B1C65D03DD61B19ED8294948D4**\n**87C75CC146D73A346-6DC190B313845FB2F303,253302E5E43273504B32F6B6B421EB66E249F1**\n\n**Figure 11-1: RomeoMike’s Public Key**\n\nEach command header is 24 bytes in size and contains the structure identified in Table 11-1. The command header defines\nthe type of command, the size of the data that follows the command header, and the MD5 hash of the data (prior to\ndecryption). The data that follows the command header is encrypted with RC4 requiring RomeoMike to decrypt the data\nprior to use.\n\n**OFFSET** **SIZE** **DESCRIPTION**\n\n0 2 Bytes (WORD) Command Type\n\n2 16 Bytes MD5 hash of the data the follows the command header\n\n18 2 Bytes Unused\n\n20 4 Bytes (DWORD) Size of the data the follows the command header\n\n**Table 11-1: RomeoMike’s Command Header Structure**\n\nIt is the responsibility of each command handler to verify the MD5 hash of the data within its section of the command. If\nthe MD5 hash fails, the command is considered invalid. RomeoMike supports three command types, all of which relate to\nthe execution of an additional binary. Table 11-2 lists the commands RomeoMike supports.\n\n**COMMAND TYPE**\n\n**DESCRIPTION**\n**IDENTIFIER**\n\n0x1001 Writes file to disk and executes the file via CreateProcess.\n\nLoads an unknown module into memory and calls one of its exports, then write the file embedded in\nthe command file to disk and executes the file via CreateProcess. As indicated in McAfee’s report,[7]\nthe name of the module and export are unknown as the decryption of the AES encrypted string results\n\n0x1002\n\nin unusable output. What is known about the module’s name is that it is up to 11 characters long plus\na NULL-byte and what is known about the export’s name is that it is up to 19 characters long plus a\nNULL-byte.\n\n0x1003 Executes the supplied command line string via CreateProcess.\n\n**Table 11-2: RomeoMike’s Support Commands**\n\nFor the first command header within a command file, an additional field exists. Prior to the first field in the command\nheader, a DWORD exists that provides the identification number of the command file. In much the same way SierraJuliett-\nMikeOne and DeltaCharlie do not execute commands that have a lower command number than the last command they\nexecute, RomeoMike ignores any command file with a lower command identifier number. [7]\n\n7 Ten Days of Rain: Expert analysis of distributed denial-of-service attacks targeting South Korea.” McAfee. 2011. http://www.mcafee.com/us/resources/white-papers/wp-10-days-of-rain.pdf\n\n\n-----\n\n## 12. [RAT] RomeoNovember\n\nRomeoNovember is a client-mode RAT that has a strong structural and familial relationship to both RomeoAlfa (see\nSection 3) and RomeoBravo (see Section 4). Romeo-CoreOne-based, structurally RomeoNovember is most like RomeoAlfa,\nas it operates as a standalone executable, constructs its configuration data structure from hardcoded values, and leverages\nthe same scaffolding for supporting R-C1.\n\nFunctionally, however, RomeoNovember is closer to RomeoBravo than RomeoAlfa. Like RomeoBravo, RomeoNovember\nuses DNSCALC-style encoding to obfuscate network communication instead of RomeoAlfa’s reliance on fake TLS. The\nsimilarity to RomeoBravo also extends to the use of the same base command number (0x523B) and channel ID (0x3456).\nThe commands within R-C1 supported by RomeoNovember are the nearly the same as those supported by RomeoBravo, to\nthe extent that RomeoNovember and RomeoBravo both implement the Secure Delete command with the same code. Only\nthe Upload Directory as Archive command is missing from RomeoNovember.\n\nRomeoNovember’s hybrid nature may indicate an active development period for the developer(s). Known\nsamples of RomeoNovember exist between March 13, 2015 and April 13, 2015, a period bookended by\nactive RomeoAlfa and RomeoBravo development. The first observed RomeoNovember sample (SHA256:\n6dab43a75647c20ac46c6f1cc65607dd4d7bb104e234b4f74f301e772e36ab9b) has a compile time that is 1 hour, 13 minutes\nafter the RomeoAlfa sample (SHA256: f46d277baf0bb8d63805ff51367d34a9cbdd7a0a1394ab384fbe12d98c8fc4b8) that\nmarks the beginning of the RomeoNovember life span.\n\n\n-----\n\n## 13. [RAT] RomeoWhiskey (Winsec)\n\nIn terms of sophistication and functionality, RomeoWhiskey is a mid-tier RAT. At its core, RomeoWhiskey provides the\nbasic functionality one would expect in a RAT: file transfer commands, program execution, basic intelligence gathering,\netcetera. Observed as early as May 2011, RomeoWhiskey, also known as Winsec, is one of the older family members used\nby the Lazarus Group, and, over the course of its lifetime, it has undergone at least one major revision. The first variant of\nRomeoWhiskey, RomeoWhiskey–One, has been observed with compile dates from May 2011 to late January/early February\n2012, while RomeoWhiskey-Two, the second variant, was compiled from late February 2012 until at least March 2014.\n\nRomeoWhiskey uses numerical constants to identify specific commands, reflective of the way RATs like the Romeo-\nCoreOne-based families (see Section 2) identify commands by unique numerical constants. There are two sets of\nconstants for identifying commands within the RomeoWhiskey samples that do not necessarily align with variant\nboundaries: command base 0x7D50 and command base 0x1E10. The different command identifier constants are interesting\nbecause they could lead to multiple conclusions:\n\n1. There were two developers (or development teams) working on RomeoWhiskey during its lifetime\n\n2. There were two users (or teams of users) of RomeoWhiskey\n\n3. A combination of 1 and 2\n\nIn addition, the authentication function uses a set of constants to calculate the appropriate authentication response\nvalues. There are three known sets of these cryptographical constants; two of the constants (identified as constants\n**0xA230 and 0x3230) align to command base 0x1E10, while the remaining cryptographical constant (0xF3C0) is only**\nfound in samples belonging to the command base 0x7D50 set. There is no overlap between the cryptographical constants\nsets and command base sets, meaning that at the very least there are two distinct sets of RomeoWhiskey.\n\nFrom a development perspective, the command base 0x7D50 set exists only in RomeoWhiskey-One variants while there is\nsome overlap between the two RomeoWhiskey variants for command base 0x1E10. The overlap for command base 0x1E10\noccurs in mid-May/early June 2011 when both base command sets are found within the RomeoWhiskey-One variant\nsample set. Once the RomeoWhiskey-One variant gives way to RomeoWhiskey-Two variant, the command base 0x7D50\nceases producing new binaries as there are no observed samples of RomeoWhiskey-Two using the command base 0x7D50\nconstants. The supported commands are largely similar, both for samples with command base 0x7D50 and those with\n_command base 0x1E10, but there are cases where one command base supports different functions than the other. The_\ncommands that command base 0x1E10 supports can be found in both variants of RomeoWhiskey.\n\nBoth observed variants of RomeoWhiskey operate as service DLL images. Beyond their basic form factor being the\nsame, the RomeoWhiskey-One variant is, for all intents and purposes, the base code for the RomeoWhiskey variants.\nRomeoWhiskey-Two expands on that core functionality by adding more advanced authentication as well as the concept of\nchannels. Therefore, it is easiest to understand the inner workings of the RomeoWhiskey variants by first understanding\nthe base code that is RomeoWhiskey-One before looking at the enhancements introduced by RomeoWhiskey-Two.\n\n\n-----\n\n#### 13.1 RomeoWhiskey-One (Base Code)\n\nBased on the premise that RomeoWhiskey-One is the base code for the entirety of the RomeoWhiskey samples, this\nsection will refer to RomeoWhiskey-One simply as RomeoWhiskey when addressing information that relates to both\nobserved variants. When a piece of information is specific to only the RomeoWhiskey-One variants, this section will use\nthe full name of RomeoWhiskey-One.\n\nRomeoWhiskey exports two functions in addition to the DllMain: ServiceMain and SecuritySetting.\nThe ServiceMain function provides the scaffolding necessary for a legitimate Windows service before calling\n```\n       CreateThread to activate the function housing the core functionality of RomeoWhiskey. The SecuritySetting\n\n```\nfunction is simply a wrapper to the function housing the core functionality of RomeoWhiskey. While both\n```\n       ServiceMain and SecuritySetting ultimately activate the core functionality of RomeoWhiskey, the distinction\n\n```\nbetween the two is that ServiceMain causes the core functionality to activate asynchronously to the calling process,\nwhile SecuritySetting does not return control to the calling process until the core functionality returns control.\n\nThe startup sequence for RomeoWhiskey is as follows:\n\n1. Dynamically load API functions\n\n2. Attempt to load the configuration file\n\n3. `bind to a listening port`\n\n4. Save the configuration\n\n5. Open a hole in the Windows firewall\n\n6. `listen for incoming connections`\n\n7. Perform the authentication handshake and spawn a handler thread if successful\n\n8. Repeat steps 6-8 indefinitely.\n\nThe functions that dynamically load API functions can be found in other Lazarus Group malware families with the function\nresponsible for loading the kernel32.dll API functions being identical to the same function used in IndiaWhiskey. The\n**kernel32.dll API loader function also generates the names of the RomeoWhiskey service, its service display name, its**\nservice description, and, most importantly for RomeoWhiskey, the name of the configuration file. The reuse of this code\nclearly ties the developer(s) of the IndiaWhiskey family to the developer(s) of the RomeoWhiskey family.\n\nRomeoWhiskey attempts to load the configuration file from %SYSDIR%\\dayipmr.tbl (for command base 0x7D50\nsamples) or %SYSDIR%\\ansi.nls (for command base 0x1E10 samples). The 240-byte file, if found, is read into memory and\ndecoded using DNSCALC-style. If the 101[st] byte is set to 1 then RomeoWhiskey will read the 4-byte value starting at the\n217[th] byte as a DWORD containing the listening port for the RomeoWhiskey instance.\n\nThe act of establishing the listening port is somewhat more involved than merely calling bind on a new socket. Situated\nwithin a loop that can iterate 30 times, the process of binding a listening port consists of first attempting to bind to the\nport specified in the configuration file, if it exists. Failing to bind on the specified port results in up to 4 additional bind\nattempts using the ports 173, 155, 129, and 192 (in that order). If RomeoWhiskey still hasn’t found a suitable port, the\nremaining iterations calculate a new potential listening port that is 1046 ports higher than the previous attempt (starting\nat an initial offset of 4). With a suitable listening port found, the configuration file is replaced with the new port value set,\nand the configuration file’s timestamp is set to match that of kernel32.dll’s timestamp.\n\n\n-----\n\nRomeoWhiskey requires that the victim’s system not block inbound access to the malware’s listening port. In order to\nmodify the victim’s Windows firewall and set an exception for inbound connections destined for the RomeoWhiskey port,\nRomeoWhiskey will add a new registry key under HKLM\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\\n**Parameters\\FirewallPolicy\\StandardProfile\\GloballyOpenPorts\\List. RomeoWhiskey names**\nthe new key {port number}:TCP and sets its value to {port number}:TCP:*:Enabled:Internet `Connection`\n```\n       Sharing(ICS).\n\n```\nFor incoming connections, RomeoWhiskey begins by authenticating the client through a handshaking protocol. The\nhandshake of RomeoWhiskey, Figure 13-1, starts by taking the current tick count of the victim’s computer, performing a\nseries of bitwise transformations, and sending the result to the client as a challenge value. The client has up to 30 seconds\nto respond with a 4-byte response. The response value is then decomposed using another series of bitwise transformations\nto ensure a particular result. If any of the steps of the handshake fails, the handshake function returns a positive result,\nand the connection to the client terminates by means of a socket disconnection function call.\n\n**int AuthenticationHandshake(SOCKET clientSkt)**\n```\n          {\n\n```\n**unsigned __int16 wChallengeSeed = GetTickCount();**\n**unsigned __int32 dwChallengeResponse = 0;**\n\n**if ( SendData(clientSkt,**\n**(wChallengeSeed << 16) | (wChallengeSeed >> 52) ^ 0xF3C0),**\n```\n                4, 1 )\n              return 1;\n\n```\n**if ( WaitForSocketRecv(clientSkt, 30) )**\n```\n              return 1;\n\n```\n**if ( RecvData(clientSkt, dwChallengeResponse, 4, 1) )**\n```\n                  return 1;\n\n```\n**return ((((dwChallengeResponse >> 16) & 0xFFFF) >> 52) ^ 0xF3C0) !=**\n```\n          (dwChallengeResponse & 0xFFFF);\n          }\n\n```\n**Figure 13-1: RomeoWhiskey-One’s Authentication Handshake Function for Command base 0x7D50 Samples**\n\nThe SendData and RecvData functions are common network data transmission functions found in a variety of\nfamilies within the Lazarus Group’s collection. These particular instances use DNSCALC-style encoding to obfuscate the\ndata as it traverses the network.\n\nAfter the authentication handshake completes, RomeoWhiskey spawns a new thread to handle the incoming requests\nfrom the client. Incoming requests consist of the client sending a modified version of a datagram specifying the command\nidentifier value (WORD), followed by the a 2-byte (WORD) value for the size of the payload, and then an optional payload\nvalue of up to 260 bytes. RomeoWhiskey uses the command identifier value to locate and execute the appropriate\ncommand handler. Table 13-1 lists the commands that RomeoWhiskey-One supports.\n\n\n-----\n\n|COMMAND NUMBER|Col2|DESCRIPTION|\n|---|---|---|\n|Command base 0x7D50|Command base 0x1E10||\n|0x7D50||Returns victim’s MAC address and computer name.|\n||0x1E11|Gets System Information. See VictimInfoPacket definition for details. This reports the malware as version “1.5”|\n|0x7D51|0x1E12|Returns the drive type (from GetDriveTypeA) for each logical drive on the victim’s computer.|\n|0x7D52|0x1E13|Enumerates the files in the specified directory.|\n|0x7D53|0x1E14|Enumerates the processes currently active on the victim’s computer. For each process, includes the process’s executable name and path, PID, the parent PID, and the timestamp of when the process was initially executed.|\n|0x7D54|0x1E15|Terminates a process by its PID, specified as either an ASCII string or a DWORD.|\n|0x7D55|0x1E18|Executes a new process using a supplied command line string.|\n|0x7D56|0x1E19|Deletes a specified file.|\n|0x7D57|0x1E20|Matches the timestamp of a specified file to the timestamp of kernel32.dll.|\n|0x7D58|0x1E21|Executes the supplied command line via the command shell (cmd.exe). The output of STDOUT (and, optionally, STDERR) are captured to a file in the %TEMP% directory. The file is read up to 60 times and transmitted to the client providing a pseudo-live stream of the output from the executed command.|\n|0x7D59|0x1E16|Disconnects. Returns a success response before terminating the connection to the client.|\n|0x7D5A|0x1E22|Changes the current working directory to the directory specified.|\n|0x7D5B|0x1E23|Uploads the contents of the specified file to the client.|\n|0x7D5C|0x1E24|Downloads a file from the client and saves the file at the location and name specified.|\n|0x7D5D|0x1E25|Returns the number of used and free bytes on the specified logical drive, as well as the drive’s name, serial number, and file system type.|\n|0x7D5E|0x1E26|Returns the creation, last accessed, and last write timestamps of the specified file along with the file size.|\n|0x7D5F||Returns the OSVERSIONINFOA data structure for the victim’s computer.|\n|0x7D60|0x1E17|Establishes a relay or proxy between the RomeoWhiskey-One instance and a specified endpoint. The relay uses the same authentication handshake function to authenticate the endpoint prior to activating the relay threads.|\n|0x7D61|0x1E27|[Response code] Success|\n|0x7D62|0x1E28|[Response code] Failure|\n|0x7D63|0x1E29|NOP. Returns invalid command status to the client|\n|0x7D64|0x1E30|[Response code] Invalid command requested.|\n\n\n**COMMAND NUMBER** **DESCRIPTION**\n\n_Command base_\n_Command base 0x7D50_\n_0x1E10_\n\n0x7D50 Returns victim’s MAC address and computer name.\n\n0x1E11 Gets System Information. See VictimInfoPacket definition for details.\nThis reports the malware as version “1.5”\n\n0x7D51 0x1E12 Returns the drive type (from GetDriveTypeA) for each logical drive on\nthe victim’s computer.\n\n0x7D52 0x1E13 Enumerates the files in the specified directory.\n\nEnumerates the processes currently active on the victim’s computer. For\n\n0x7D53 0x1E14 each process, includes the process’s executable name and path, PID, the\n\nparent PID, and the timestamp of when the process was initially executed.\n\nTerminates a process by its PID, specified as either an ASCII string or a\n0x7D54 0x1E15\nDWORD.\n\n0x7D55 0x1E18 Executes a new process using a supplied command line string.\n\n0x7D56 0x1E19 Deletes a specified file.\n\nMatches the timestamp of a specified file to the timestamp of\n0x7D57 0x1E20\n**kernel32.dll.**\n\nExecutes the supplied command line via the command shell (cmd.exe).\nThe output of STDOUT (and, optionally, STDERR) are captured to a file in\n\n0x7D58 0x1E21 the %TEMP% directory. The file is read up to 60 times and transmitted to\n\nthe client providing a pseudo-live stream of the output from the executed\ncommand.\n\nDisconnects. Returns a success response before terminating the\n0x7D59 0x1E16\nconnection to the client.\n\n0x7D5A 0x1E22 Changes the current working directory to the directory specified.\n\n0x7D5B 0x1E23 Uploads the contents of the specified file to the client.\n\nDownloads a file from the client and saves the file at the location and name\n0x7D5C 0x1E24\nspecified.\n\nReturns the number of used and free bytes on the specified logical drive, as\n0x7D5D 0x1E25\nwell as the drive’s name, serial number, and file system type.\n\nReturns the creation, last accessed, and last write timestamps of the\n0x7D5E 0x1E26\nspecified file along with the file size.\n\n0x7D5F Returns the OSVERSIONINFOA data structure for the victim’s computer.\n\nEstablishes a relay or proxy between the RomeoWhiskey-One instance and\n\n0x7D60 0x1E17 a specified endpoint. The relay uses the same authentication handshake\n\nfunction to authenticate the endpoint prior to activating the relay threads.\n\n0x7D61 0x1E27 [Response code] Success\n\n0x7D62 0x1E28 [Response code] Failure\n\n0x7D63 0x1E29 NOP. Returns invalid command status to the client\n\n0x7D64 0x1E30 [Response code] Invalid command requested.\n\n**Table 13-1: RomeoWhiskey-One’s Support Commands and their Command Identifier Values**\n\nMuch the same way Romeo-CoreOne uses specific numerical values to indicate success or failure of an operation,\nRomeoWhiskey uses 0x76D1 (for command base 0x7D50) or 0x1E27 (for command base 0x1E10) to indicate a successful\noperation and 0x7D62 (for command base 0x7D50) or 0x1E28 (for command base 0x1E10) for a failed operation.\n\n\n-----\n\n|OFFSET|SIZE|DESCRIPTION|\n|---|---|---|\n|0|32 Bytes|Computer name|\n|32|128 Bytes|Processor name (from registry key HKLM\\HARDWARE\\ DESCRIPTION\\System\\CentralProcessor\\0\\ ProcessorNameString)|\n|160|156 Bytes (OSVERSIONINFOEXA structure)|OS version information from GetVersionExA|\n|316|30 Bytes|First character to r if the service TermService is running. For each terminal session on the victim’s machine, either the character s is appended, if the session currently has an active screen saver (e.g. is idle), or e if the session has an active explorer.exe instance running.|\n|346|16 Bytes (FILETIME)|Victim’s login time|\n|354|6 bytes|MAC address of first NIC|\n|360|4 Bytes|Believed to indicate the version of WhiskeyRomeo (set to “1.5”)|\n|364|2 Bytes (WORD)|Total number of MBs on all logical hard drives (DRIVE_FIXED)|\n|366|2 Bytes (WORD)|Total number of free MBs on all logical hard drives (DRIVE_FIXED)|\n|368|4 Bytes (DWORD)|Interesting open ports bitmask. Bit 0 = port 3389, Bit 1 = port 80, Bit 2 = port 445, Bit 3 = 3306, Bit 4 = 1433|\n|372|5 Bytes|Unused|\n|377|2 Bytes (WORD)|Unused, explicitly set to 0|\n|379|1 Byte|Unused, explicitly set to 0|\n\n\nLargely, the commands supported by command base 0x7D50 and command base 0x1E10 are identical, with the exception\nof command types 0x7D50, 0x1E11 and 0x7D5F. The command base 0x1E10 essentially combines commands 0x7D50 and\n0x7D5F, from command base 0x7D50, into the command identified by 0x1E11. Command 0x1E11 generates a large data\nstructure (Table 13-2) with identifiable information about the victim’s computer.\n\n**OFFSET** **SIZE** **DESCRIPTION**\n\n0 32 Bytes Computer name\n\nProcessor name (from registry key HKLM\\HARDWARE\\\n\n32 128 Bytes `DESCRIPTION\\System\\CentralProcessor\\0\\`\n```\n                               ProcessorNameString)\n\n```\n156 Bytes (OSVERSIONINFOEXA\n160 structure) OS version information from GetVersionExA\n\nFirst character to r if the service TermService is running. For\n\n316 30 Bytes each terminal session on the victim’s machine, either the character s\n\nis appended, if the session currently has an active screen saver (e.g. is\nidle), or e if the session has an active explorer.exe instance running.\n\n346 16 Bytes (FILETIME) Victim’s login time\n\n354 6 bytes MAC address of first NIC\n\n360 4 Bytes Believed to indicate the version of WhiskeyRomeo (set to “1.5”)\n\n364 2 Bytes (WORD) Total number of MBs on all logical hard drives (DRIVE_FIXED)\n\n366 2 Bytes (WORD) Total number of free MBs on all logical hard drives (DRIVE_FIXED)\n\nInteresting open ports bitmask. Bit 0 = port 3389, Bit 1 = port 80, Bit\n368 4 Bytes (DWORD)\n2 = port 445, Bit 3 = 3306, Bit 4 = 1433\n\n372 5 Bytes Unused\n\n377 2 Bytes (WORD) Unused, explicitly set to 0\n\n379 1 Byte Unused, explicitly set to 0\n\n**Table 13-2: RomeoWhiskey Command Base 0x1E10 based VictimInfoPacket Data Structure**\n\nRomeoWhiskey continues to receive commands from the client until a command results in an error or the disconnect\ncommand is received from the client. RomeoWhiskey disconnects from the client by using the Lazarus Group’s standard\nsocket disconnection function.\n\n\n-----\n\n#### 13.2 RomeoWhiskey-Two\n\nRomeoWhiskey-Two expands on the base code established by RomeoWhiskey-One. However, observed samples use\nonly the command base 0x1E10 supported commands. The most noticeable differences between RomeoWhiskey-Two and\nRomeoWhiskey-One are the introduction of the concept of channels and the more advanced authentication that utilizes\nasymmetric encryption.\n\nRomeoWhiskey-Two adheres to the basic model outlined in the previous section, but introduces a few deviations to the\nstartup sequence:\n\n1. Determine exclusivity on the infected system\n\n2. Dynamically load API functions\n\n3. Attempt to load the configuration file\n\n4. `bind to a listening port`\n\n5. Save the configuration\n\n6. Open a hole in the Windows firewall\n\n7. Open a hole in the perimeter firewall using SSDT\n\n8. `listen for incoming connections`\n\n9. Spawn a handler thread\n\n10. Repeat steps 8-10 indefinitely.\n\nIn order to determine if only one instance of RomeoWhiskey-Two is active on a victim’s system at any given time,\nthe malware uses the somewhat common technique of creating a mutex with a specific name before calling\n```\n       WaitForSingleObject and determining the return code of the call. If the WaitForSingleObject call returns any\n\n```\nresult outside of WAIT_TIMEOUT, then RomeoWhiskey-Two assumes that only one instance of the malware is running\non the victim’s machine. The name of the mutex depends on whether or not the victim’s processor supports the CPUID\ncommand to retrieve processor info and feature bits. If the processor does not support the CPUID command for retrieving\nthe processor’s info and feature bits, the mutex is given the name Microsoft. Otherwise, the mutex is the hexadecimal\nrepresentation of the 32-bit info bits and the 32-bit feature bits concatenated together.\n\nRomeoWhiskey-Two stores the configuration in the file %WINDIR%\\tlvc.nls. The format of the configuration file is\nidentical to that of RomeoWhiskey-One and is encoded using the DNSCALC-style encoding scheme.\n\nThe task of determining a listening port is greatly simplified compared to RomeoWhiskey-One’s method. The attempt to\nbind to a listening port is limited to four attempts, first using the port defined in the configuration and, if unsuccessful,\nthen using three predefined port values (547, 133, and 117).\n\nIn order to allow inbound connections to the listening port, RomeoWhiskey-Two, like its predecessor, must open a hole\nin the Windows firewall. Instead of modifying the victim’s registry, RomeoWhiskey-Two will use the netsh command\nto adjust the firewall’s settings. The specific command that RomeoWhiskey-Two uses is Windows version specific as\nidentified in Table 13-3.\n\n\n-----\n\n|OS VERISON|COMMAND LINE|\n|---|---|\n|XP or older|cmd.exe /c netsh firewall add portopening protocol=tcp port={listening port} name=CoreNetworkingHTTPS|\n|Vista or newer|cmd.exe /c netsh advfirewall firewall add rule name=CoreNetworkingHTTPS dir=in action=allow Protocol=TCP localport={listening port}|\n\n|OFFSET|+0|+1|+2|+3|+4|+5|+6|+7|\n|---|---|---|---|---|---|---|---|---|\n|0|Random|Random|Random|Seed value (DWORD)||||Random|\n|8|Random|Challenge value (DWORD)||||Random|Random|Random|\n\n\n**OS VERISON** **COMMAND LINE**\n\n**cmd.exe /c netsh firewall** `add` `portopening protocol=tcp port={listening port}`\nXP or older\n**name=CoreNetworkingHTTPS**\n\n**cmd.exe /c netsh advfirewall firewall** `add` **rule name=CoreNetworkingHTTPS**\nVista or newer\n```\n                dir=in action=allow Protocol=TCP localport={listening port}\n\n```\n**Table 13-3: RomeoWhiskey-Two’s Firewall Modification Command Lines**\n\nRomeoWhiskey-Two’s developer(s) were not intent on modifying only the host-level firewall, as they actively try to\nmanipulate the perimeter firewall as well. By using the Simple Service Discovery Protocol (SSDP), RomeoWhiskey-Two\nattempts to determine the next hop between the infected machine and the Internet. If the local router responds with the\nURL for its UPnP interface, RomeoWhiskey-Two issues a series of Universal Plug and Play (UPnP) commands in order\nto map an external port on the firewall to the RomeoWhiskey-Two’s listening port and name the new mapping “DHCP\n```\n       Client”. The net effect, if successful, allows RomeoWhiskey-Two to tunnel a hole from the exterior of the firewall (the\n\n```\nInternet-facing interface) through to the RomeoWhiskey-Two instance. SSDP and UPnP configuration of firewalls is not\ncommon in larger networks, but rather is more likely to be found in a SOHO environment. This would indicate that either\nthe developer(s) of RomeoWhiskey-Two were unaware of the limitation of SSDP and UPnP in a corporate environment, or\nthat they were targeting smaller infrastructures.\n\nWhenever a new connection from a client occurs, RomeoWhiskey-Two immediately spawns a new thread to handle\nthe incoming requests. The generation of the new thread occurs prior to the authentication handshake, unlike\nRomeoWhiskey-One. The authentication handshake, meanwhile, is more evolved than the previously described function\nseen in Figure 13-1. RomeoWhiskey-Two generates a 16-byte buffer of random bytes before modifying the 3[rd] byte through\nthe 7[th] byte with the seed value and the 10[th] through 13[th] bytes with the challenge value as Figure 13-2 illustrates. The client\nhas 10 seconds to respond with another 16-byte buffer of which contains random data, a seed value and a challenge value\nin the same format. While the system, at face value, seems somewhat imposing, in actuality it is worthless for any form\nof cryptographic authentication. Both the request from the RomeoWhiskey-Two instance to the client and the client’s\nresponse contain all of the components necessary to generate a valid response. The challenge value is derived from the\nseed value by performing several bitwise XORs and shifts, and an addition as Figure 13-3 describes. Therefore, by supplying\nboth the seed and the challenge values, there is practically no value to the handshake other than to prove both sides know\nthe algorithm. Furthermore, a simple packet replay by the client would satisfy the handshake’s conditions.\n\n**OFFSET** **+0** **+1** **+2** **+3** **+4** **+5** **+6** **+7**\n\n0 Random Random Random Seed value (DWORD) Random\n\n8 Random Challenge value (DWORD) Random Random Random\n\n**Figure 13-2: RomeoWhiskey-Two’s Authentication Handshake Data Blob’s Format**\n\n\n-----\n\n**int Handshake(SOCKET s)**\n```\n          {\n           struct\n           {\n\n```\n**char r1[3];**\n**unsigned __int32 seed;**\n```\n           char r2[2];\n\n```\n**unsigned __int32 challenge;**\n**char r3[3]**\n**} pkt;**\n\n**srand(GetTickCount());**\n```\n           seed = rand() * rand();\n\n```\n**unsigned char *p = (unsigned char*)&pkt;**\n```\n           i = 0;\n           do\n\n```\n**p[i] = rand() % 256;**\n**while ( i < 16 );**\n\n**pkt.seed = seed;**\n**pkt.challenge = (((seed ^ 0x1A1E1C40u) >> 1) + 0x2E3E56E0) ^ 0xAF313230;**\n\n**if ( SendData(s, &pkt, sizeof(pkt), 1) )**\n```\n              return 1;\n\n```\n**if ( WaitForSocketRecv(s, 10) )**\n```\n              return 1;\n\n```\n**if ( RecvData(s, &pkt, sizeof(pkt), 1) )**\n```\n            return 1;\n\n```\n**return ((((pkt.seed ^ 0x1A1E1C40u) >> 1) + 0x2E3E56E0) ^ 0xAF313230) != pkt.challenge;**\n```\n          }\n\n```\n**Figure 13-3:RomeoWhiskey-Two’s Authentication Handshake Function**\n\nIf the handshake fails, RomeoWhiskey-Two shuts down the connection with the client using the socket disconnection\nfunction found in many of the Lazarus Group’s families. If the handshake is successful, however, RomeoWhiskey-Two\nexpects the client to transmit two bytes (WORD). The WORD that the client sends specifies the particular channel the\nclient is requesting. RomeoWhiskey-Two supports two channels: RAT (identified by 0xC8C8) and Proxy (identified by\n```\n       0x5A5A). Each channel dictates a different form of traffic and supported commands. For instance, the RAT channel\n\n```\npasses data in the previously mentioned datagram form, while the Proxy channel uses a different format entirely. This use\nof channels essentially allows RomeoWhiskey-Two to operate as two loosely coupled malware families at once.\n\nIf the client activates the RAT channel, RomeoWhiskey-Two sends a datagram of type 0x1E11 to the client before\nentering into another authentication phase. The RAT channel authentication phase is independent of the handshake\nauthentication process prior to entering the RAT channel and is based on the model of the handshake authentication\nfrom RomeoWhiskey-One. The RAT channel authentication, while similar to that of Figure 13-1, now involves asymmetric\nencryption using RSA public and private keys, specifically the public key found in SierraJuliett-MikeOne (see Section 17).\nAfter generating the challenge value through a series of bitwise shifts, XOR, and addition, RomeoWhiskey-Two encrypts\nthe 4-byte (DWORD) value using the same RSA transform function found in other Lazarus Group families, again most\nnotably SierraJuliett-MikeOne. After transmitting the encrypted value to the client, RomeoWhiskey-Two waits up to\n10 seconds for the client to respond. The client responds with a 4-byte (DWORD) value that must match the original\nchallenge value for the authentication to succeed. The implications of this is that only a client who possesses the private\nkey to decrypt the challenge value can access the RAT channel and its functionality.\n\nAfter the authentication phase is complete, RomeoWhiskey-Two’s RAT channel settles into the same pattern of receiving\na datagram and dispatching the appropriate handle for the command found within the datagram. RomeoWhiskey-Two\n\n\n-----\n\n|COMMAND NUMBER|DESCRIPTION|\n|---|---|\n|0x1E10|“Knock” on remote host port - Test if a connection is possible as the socket is immediately closed on success. Basically this is a port ping. Returns a success status if the port responses, otherwise returns a failure status.|\n|0x1E31|[Response code] RAT channel active acknowledgment|\n|0x1E32|[Response Code]|\n\n|OFFSET|SIZE|DESCRIPTION|\n|---|---|---|\n|0|80 Bytes [array of endpoints]|Array of 10 records consisting of an IP (DWORD), a port (WORD) and a 2-byte unused field. Each record specifies a possible next hop in the virtual circuit.|\n|80|4 Bytes (DWORD)|Next hop index in the array of hop records (offset 0)|\n|84|4 Bytes (DWORD)|Maximum hops|\n|88|4 Bytes (DWORD)|Final endpoint’s IP address (as DWORD)|\n|92|2 Bytes (DWORD)|Final endpoint’s port (as WORD)|\n|94|2 Bytes|Unused|\n|96|4 Bytes (DWORD)|Endpoint IP address (as DWORD)|\n|100|2 Bytes (WORD)|Endpoint port (as WORD)|\n|102|2 Bytes|Unused|\n|104|4 Bytes (DWORD)|Operations flags|\n|108|4 Bytes (DWORD)|Connection timeout|\n\n\nsupports all of the same commands as command base 0x1E10 in RomeoWhiskey-One with the exception that the\ncommand for establishing a proxy/relay between the malware and an endpoint (0x1E17) has been replaced by the Proxy\nchannel. RomeoWhiskey-Two’s RAT channel introduced a new command (0x1E10) and a new response code (0x1E31) as\nseen in Table 13-4.\n\n**COMMAND NUMBER** **DESCRIPTION**\n\n“Knock” on remote host port - Test if a connection is possible as the socket is immediately closed\n\n0x1E10 on success. Basically this is a port ping. Returns a success status if the port responses, otherwise\n\nreturns a failure status.\n\n0x1E31 [Response code] RAT channel active acknowledgment\n\n0x1E32 [Response Code]\n\n**Table 13-4: RomeoWhiskey-Two’s Additional Supported RAT Channel Commands and their Command Identifier Values**\n\nThe Proxy channel in RomeoWhiskey-Two allows for the construction of a ghost network on top of existing\ninfrastructure by linking RomeoWhiskey-Two infections to form virtual point-to-point sessions. After entering\nthe Proxy channel, the client transmits a 112-byte structure (Table 13-5) that defines the hops (up to 10) used by the\nvirtual connection in much the same way IP packets can specify Loose Source Routing or Strict Source Routing. The\nRomeoWhiskey-Two instance parses the Proxy channel command record sent by the client and determines the next hop,\nthen makes a connection to the endpoint. The command record generally specifies the route as a predefined sequence of\nRomeoWhiskey-Two nodes to use, but, if the operations flag (offset 104) is set to 0xC2672253, then the array of hops is\nused to randomly select the next node for the connection.\n\n**OFFSET** **SIZE** **DESCRIPTION**\n\n0 80 Bytes [array of Array of 10 records consisting of an IP (DWORD), a port (WORD) and a 2-byte unused\nendpoints] field. Each record specifies a possible next hop in the virtual circuit.\n\n80 4 Bytes (DWORD) Next hop index in the array of hop records (offset 0)\n\n84 4 Bytes (DWORD) Maximum hops\n\n88 4 Bytes (DWORD) Final endpoint’s IP address (as DWORD)\n\n92 2 Bytes (DWORD) Final endpoint’s port (as WORD)\n\n94 2 Bytes Unused\n\n96 4 Bytes (DWORD) Endpoint IP address (as DWORD)\n\n100 2 Bytes (WORD) Endpoint port (as WORD)\n\n102 2 Bytes Unused\n\n104 4 Bytes (DWORD) Operations flags\n\n108 4 Bytes (DWORD) Connection timeout\n\n**Table 13-5: RomeoWhiskey-Two’s Proxy Channel Command Record Data Structure**\n\nOnce the next hop has been determined by RomeoWhiskey-Two, a connection to the hop is made and the authentication\nhandshake is performed. Earlier in this section it was pointed out that the algorithm used by the authentication handshake\nultimately serves no value in terms of authentication. When viewed in the context of the Proxy channel, the method for the\nhandshake begins to make a bit more sense, since the same function for performing the handshake is used here to establish a\nconnection between one RomeoWhiskey-Two instance and another RomeoWhiskey-Two instance. Furthermore, taking into\nconsideration that the handshake is no longer providing any real form of authentication, the use of asymmetric cryptography\nfor the RAT channel’s authentication makes significantly more sense to the overall design of the malware.\n\n\n-----\n\nDepending on the position of the node receiving the command record within the overall virtual connection, the\nRomeoWhiskey-Two node requests either the RAT channel or the Proxy channel. The determination of which channel to\nuse is made based on the value of the final endpoint IP address (offset 88). If the virtual connection has reached the final\ndestination, then the RAT channel is opened, otherwise the Proxy channel is requested. With the appropriate channel\nestablished, RomeoWhiskey-Two activates two threads to handle the relaying of data from node to node, with each node\nresponsible for data in only one direction. It is worth noting that the relay threads transmit data without employing the\nencoding scheme found elsewhere within the RomeoWhiskey-Two communications.\n\n\n-----\n\n## 14. [Spreader] SierraAlfa\n\nA self-install service-based executable, SierraAlfa begins a chain of infection that ultimately leads to the potential\ndevastation of an entire network of computers. SierraAlfa is responsible for the distribution and activation of WhiskeyAlfa\non a victim’s network. The observed samples of SierraAlfa were clearly built specifically for the SPE attacks as they contain\ninfrastructure and account information specific to SPE’s networks.\n\nTwo variants have been observed: SierraAlfa-One and SierraAlfa-Two. SierraAlfa-One is the base model, while\nSierraAlfa-Two provides additional features to ensure the propagation of the malicious payload within.\n\n#### 14.1 SierraAlfa Base (SierraAlfa-One)\n\nSierraAlfa-One is the base upon which the other SierraAlfa variant is derived. There have been only two observed\nSierraAlfa samples (one for SierraAlfa-One and one for SierraAlfa-Two) in the wild. Given the very specific targeting and\nnature of their functionality, it is highly probably the SierraAlfa family is a one-off series. Given that SierraAlfa-One is the\nbase model, this section will refer to SierraAlfa-One simply as SierraAlfa. Unless otherwise noted in the following section,\nthe activities present in SierraAlfa-One are the same as SierraAlfa-Two in both design and execution.\n\nSierraAlfa, when activated, determines which, if any, command line arguments are present. If no command line\narguments are present, SierraAlfa relaunches itself using CreateProcess after adding –i to its command line. The –i\nargument causes SierraAlfa to install itself as a service. SierraAlfa also supports the –k argument, which causes SierraAlfa\nto operate as a standalone service. Any other command line arguments will result in a window appearing as seen in Figure\n14-1 (without the “About” dialog box which is shown to give a full perspective of the application). The window, and the\nresources within the SierraAlfa binary that produce the window, reveal that the developer(s) used the Visual C++ v6 “Hello\nWorld” template to create the basic application framework. Knowing that the title of the application, in this case Hello,\nis the same as the project name by default for the template, the original SierraAlfa project had the simple name of Hello.\n\n**Figure 14-1: SierraAlfa’s Window When Supplied an Invalid Command Line Argument**\n\n\n-----\n\nWhen activated with the –i command line argument in order to induce the service installation mode, SierraAlfa follows a\nvery simple series of steps to install the WinsSchMgmt service on the victim’s computer:\n\n1. Call CreateServiceW to add a new service (WinsSchMgmt) to the victim’s computer with the description “Windows\n```\n         Schedule Management Service” and set the command line argument for the service’s binary to –k. \n\n```\n2. Call ChangeServiceConfig2A to, again, set the description to “Windows Schedule Management\n```\n         Service”.\n\n```\n3. Call ChangeServiceConfig2A to set the on-failure retry modes.\n\n4. Open a handle to the new service and call StartServiceW to activate the service.\n\n5. Terminate silently.\n\nSierraAlfa does not attempt to move its binary prior to installing itself as a service on the victim’s computer. The inclusion\nof the –k argument for the service ensures that upon activation by the Windows Services system, SierraAlfa activates its\nservice handler. The service handler, aside from the normal Window services scaffolding, calls the function of SierraAlfa\nthat kicks off the propagation functionality of the malware.\n\nThe propagation functionality begins by dropping a file on the victim’s system and loading another into memory. The\npayload files of SierraAlfa are appended to the end of the SierraAlfa binary in a stacked fashion, preceded by a table of\ncontents data structure. The location for the start of the table of contents and the stacked files that follow is determined\nby the last 4 bytes (DWORD) of the SierraAlfa binary. The 4 bytes at the end of the binary define the distance from the\nbeginning of the binary to the beginning of the table of contents. The table of contents specifies both the actual size and\nthe compressed size for each of the payload components that SierraAlfa drops or loads. Figure 14-2 visualizes the format\nof the payload’s organization. The payload contains two files: a WhiskeyAlfa executable and a text file containing a list of\ntarget servers. The WhiskeyAlfa executable is always compressed with Zlib, while the target list may be either compressed\nusing Zlib or simply stored. If the decompressed size and the size of the target list are not equal, SierraAlfa assumes the\nlist is compressed and attempts to decompress the list in memory. Otherwise, the contents of the list are XOR’d with 0x67\nto reveal the original content.\n\nSierraAlfa’s Binary Image\n\nExecutable’s Size (decompressed) [DWORD]\n\nExecutable’s Size (in image) [DWORD]\n\nPayload Table of Contents Targets List’s Size (decompressed) [DWORD]\n\nTargets List’s Size (in image) [DWORD]\n\nExecutable Image\n\nTarget List’s Image\n\nOffset to Table of Contents[DWORD]\n\n**Figure 14-2: SierraAla’s Stacked Payload Layout**\n\n\n-----\n\nSierraAlfa saves the WhiskeyAlfa binary to disk as igfxtrayex.exe in the same directory as the running SierraAlfa\nimage and then immediately executes the binary by calling CreateProcess. The target list is parsed to extract target\ninformation and compromised accounts to use against the targets. The target list consists of two sections: a section\nspecifying the username and passwords for compromised accounts and a section containing target servers to infect.\nSierraAlfa parses the target information as a list of compromised accounts until it reaches a line containing only a hyphen,\nat which point it assumes the rest of the file contains the target hosts list.\n\nThe structure for the account information is as follows:\n```\n          domain\\username|password\n\n```\nThe structure for the target list is:\n```\n          hostname|IP1|IP2\n\n```\nThe hostname field specifies the Windows name of the computer, IP1 field specifies the first IP address of the computer,\nand the optional IP2 field specifies a second IP address for the server. The fact that the developer(s) allow for multiple\naddressing options for a target illustrates that the developer(s) took into consideration that an infected host may be\non different network segments than the target computer; as such, different routing and addressing methods may be\nnecessary in order to compromise a host. The use of multiple addressing options for a target shows both a sufficient level\nof reconnaissance within the victim’s network and a desire by the developer(s) to ensure as many compromised targets as\npossible with the least amount of attacker intervention.\n\nWith the WhiskeyAlfa executable dropped and executed, and the targeting information loaded, the task of distributing\nitself across the victim’s infrastructure begins. SierraAlfa maintains two lists: a list of targets (loaded by the previous step)\nand a list of hosts that it has already infected, or at the very least attempted to infect. Until the size of both lists becomes\nequal, indicating that all of the targeted hosts have been attacked, SierraAlfa attempts to infect up to 10 hosts at a time,\nwith each attack occurring in its own thread. When SierraAlfa reaches a thread saturation level (10 threads), SierraAlfa\nenters a tight loop that simply sleeps 100ms before checking to see if the current number of threads has fallen below 10.\nThis thread management system is effective but rudimentary, indicating that the developer(s) were not well versed in\nmultithreaded, asynchronous programming on Windows.\n\nThe selection of which host to attack at any given time is completely random. To avoid the duplication of effort that would\nstem from attacking a host that has already been attacked, the randomly selected hosts’ entries are checked to ensure they\nhave not already been used. If the host has already been attacked by the instance of SierraAlfa, a new host is randomly\nselected until a host is found that has not yet been attacked. This behavior would suggest that the longer SierraAlfa runs\nand attacks hosts, the longer the selection process will take. However, this methodology does allow for a better statistical\ncoverage model when viewed as a larger set of infected hosts all using the same targeting information that exists in\nthe same order. The randomization of which hosts to attack at any given point means that the probability of two hosts\nattacking the same sequence of targets in the same order is relatively low for a large enough data set. To that point, the\ntarget list within SierraAlfa-One contains over 20,000 target machines.\n\n\n-----\n\nFor each attack thread that SierraAlfa generates, the thread attempts to resolve the host name of the target, specified in\nthe target information’s hostname field. A determination is made as to whether or not the host is accessible and has an\navailable Windows share port open by attempting to connect to either port 445 or 139. If the thread is able to access either\nport, the thread randomly selects one of the username and password entries before performing the following tasks:\n\n1. Open a channel, via SMB, to the target host via a call to WNetAddConnection2A.\n\n2. If unable to access the admin$ share on the target host, create a service named RasMgrp{random number} on the\n\nvictim’s machine with the command line:\n\n**cmd.exe /q /c net share shared$=%SystemRoot% /GRANT:everyone,FULL**\n\n3. Randomly select the destination filename from one of the following names:\n```\n         • recdiscm32.exe\n         • taskhosts64.exe\n         • taskchg16.exe\n         • rdpshellex32.exe\n         • mobsynclm64.exe\n         • comon32.exe\n         • diskpartmg16.exe\n         • dpnsvr16.exe\n         • expandmn32.exe\n         • hwrcompsvc64.exe\n\n```\n4. Copy the SierraAlfa binary to the admin$\\syswow64 or shared$\\syswow64 (if unable to access the admin$\n\nshare) directory as the randomly selected filename (from #3)\n\n5. Copy the SierraAlfa binary to the admin$\\system32 or shared$\\system32 (if unable to access the admin$\n\nshare) directory as the randomly selected filename (from #3) and verify the copy was successful\n\n6. Set the timestamp of the newly copied executable to match the target host’s calc.exe’s timestamp.\n\n7. If #2 resulted in a new service, replace the service’s command line with\n\n**cmd.exe /q /c net share shared$ /delete**\n\nand restart the service\n\n8. Install and activate a new service named RasSecruity (note the misspelling of “Security”) with the command line\n\nset to the name of the newly installed binary in the system32 directory.\n\n9. If the service RasSecruity fails to activate, using the Windows Management Instrumentation Command-line\n\napplication wmic, attempt to start the SierraAlfa binary on the target system by calling CreateProcess with the\ncommand line\n\n\n-----\n\n|OFFSET|SIZE|DESCRIPTION|\n|---|---|---|\n|0|2 Byte (WORD)|Size of the data that follows (40)|\n|2|4 Bytes (DWORD)|IP address of the infected host (as 32-bit value)|\n|6|32 Bytes|Hostname of the infected host|\n|38|4 Bytes (DWORD)|Successful infection status (set to 1)|\n\n```\n           cmd.exe /c wmic.exe /node:”{name of target host}” /user:”{username}”\n\n           /password:”{password}” PROCESS CALL CREATE “{randomly selected name}” > {current thread ID}_\n\n```\n{current tick count}\n\nand parse the {current thread ID}_{current tick count} file to determine if the string ProcessId was found,\nindicating the process started successfully.\n\nIf any of the thread’s tasks fail, the thread disconnects from the target host by calling NetCancelConnection2A before\nattempting the tasks again using first the value of the IP1 field as the target host; if that is unsuccessful, the value of the\n_IP2 field is used, if present._\n\nIf the infection of the target host is successful, SierraAlfa sends a reporting data packet to one the hardcoded C2 servers\nchosen at random. Table 14-1 defines the structure of the reporting data packet. If the transmission to a particular C2\nserver is unsuccessful, a new C2 server is chosen from the list of hard coded C2 servers, and the transmission it attempted\nagain. SierraAlfa attempts to report the status of an infection up to three times before abandoning this endeavor.\n\n**OFFSET** **SIZE** **DESCRIPTION**\n\n0 2 Byte (WORD) Size of the data that follows (40)\n\n2 4 Bytes (DWORD) IP address of the infected host (as 32-bit value)\n\n6 32 Bytes Hostname of the infected host\n\n38 4 Bytes (DWORD) Successful infection status (set to 1)\n\n**Table 14-1: The Structure of the SierraAlf Reporting Data Packet**\n\nAfter the transmission of the report data (or if the infection was unsuccessful, after the disconnect from the infected\nhost), the thread decrements the global counter of active threads, thereby freeing up a new slot to allow a new infection\nthread to commence.\n\nOnce all attack operations have concluded, the SierraAlfa service remains in a running state but becomes idle.\n\n\n-----\n\n#### 14.2 SierraAlfa-Two\n\nSierraAlfa-Two has a compile time roughly two hours after the compile time of SierraAlfa-One. During the two hours\nbetween the variants, the developer(s) made several modifications:\n\n         - The status of an infection attempt is logged to net_ver.dat\n\n         - The command line argument –k results in SierraAlfa being run under the context of each user currently logged in to\n\nvictim machine through terminal services\n\n         - The propagation functionality is activated by supplying –s on the command line\n\nSierraAlfa-One contains the basic framework for recording infection status information, but it is not until SierraAlfa-Two\nthat the framework is fully completed by the developer(s) and utilized. At the conclusion of an attack thread,\nSierraAlfa-Two generates a string using the following form:\n\n{Target Hostname}|{Target’s IP Address}|{Infection Status}\n\nThe {Infection Status} field indicates whether an infection was successful (set to 1) or unsuccessful (set to 2). The targeting\ninformation within SierraAlfa-Two is significantly less involved than SierraAlfa-One. The target list contains only 58\nhosts, many of which do not have a host name but only an IP address, and all of which are routable on the Internet. From\nthis information, it would appear that SierraAlfa-Two was targeting network-facing, or firewall-exposed, targets only.\n\nThere is also the fact that the service that SierraAlfa installs does not immediately begin the propagation tasks, but\nrather targets the currently logged-in users of the victim host, another behavior change. The –k mode begins by calling\n```\n       WTSEnumerateSessionW to list the active terminal services sessions and, for each session found, the token of the user\n\n```\nis obtained and given to CreateProcessAsUser in order to run SierraAlfa-Two as the logged-in user. This method\ndoes not necessarily increase the likelihood of a successful infection, given that the infection mechanism uses a finite set\nof preconfigured username/password combinations that have no relationship to the user under which the new SierraAlfa\ninstances are running. It is therefore unclear why the developer(s) chose to add this method.\n\n\n-----\n\n## 15. [Spreader] SierraBravo (Brambul)\n\nSierraBravo, commonly known as Brambul, is a spreader that uses insecure user accounts to propagate its malware, and\nitself, across a both intra-connected and interconnected networks. SierraBravo operates as a standard executable, a service\nexecutable or, with some observed samples, as a service DLL.\n\nSierraBravo has had several variants over the course of its developmental lifespan. The primary focus of the SierraBravo\ncode base is the propagation of malware through unsecured or insecure network shares. Over time, the developer(s) of\nSierraBravo have added additional functions such as the ability to report to a C2 server the status of propagation. Despite a\ngeneral cohesive task of propagating malware and a common functionality for performing this task, it is necessary to split\nit into two variants, SierraBravo-One and SierraBravo-Two, due to some functional and structural differences that are\noutside the scope of normal malware evolution and refinement. SierraBravo-One represents the variants that operate as\neither a standalone or service executable, while SierraBravo-Two contains the samples that operate as a service DLL.\n\nDespite their structural differences, there are some commonalities between the variants:\n\n         - They rely on dynamic API loading with some, but not all, API function names encrypted using a variant of\n```\n         DecryptPassword from an open source malware known as rBot[8]\n\n```\n          - The IP ranges 10.0.0.0/8, 12.0.0.0/8, 127.0.0.0/8, 192.0.0.0/8, 198.0.0.0/8, 216.0.0.0/8 are excluded from any attack\n\n(SierraBravo-One also excluded 8.0.0.0/8)\n\n#### 15.1 SierraBravo-One\n\nThe first operation SierraBravo-One performs is the verification of its exclusivity on the victim’s system. By checking for\nthe presences of the named mutex Global\\\\FwtSqmSession106829323_S-1-5-19, SierraBravo-One can determine if\nit is the only instance of itself running on the victim’s machine. If a copy of the malware is already active, SierraBravo-One\ngenerates and executes a suicide script in order to remove the extraneous copy of itself.\n\nSierraBravo-One determines the number of command line arguments present at the time of activation. If at least\none command line argument is given and the first argument is -i, SierraBravo-One enters an installation mode.\nInstallation mode begins by verifying that there are 5 arguments on the command line. The five command line arguments\nSierraBravo-One expects are as follows:\n```\n         -i <max. number of attack threads> <timeout> <primary C2 server address> <prime C2 server port>\n\n```\nSierraBravo-One uses the command line arguments to construct a base configuration file which it saves to\n**%WINDIR%\\KB25468.dat and encrypts using RC4. A new directory is generated at %WINDIR%\\system, and the**\nSierraBravo-One binary copies itself to the directory under the name svchost.exe. Using the Windows Service\nAPI functions, SierraBravo generates a new service named Windows Filter Driver with the newly installed\n\n[8 “rbot6.6.rar crypt.cpp” http://read.pudn.com/downloads110/sourcecode/hack/scanner/454581/rBot_041504/crypt.cpp__.htm 14 April 2004.](http://read.pudn.com/downloads110/sourcecode/hack/scanner/454581/rBot_041504/crypt.cpp__.htm)\n\n\n-----\n\n```\n       svchost.exe binary being the target of the service. The Windows Filter Driver service is activated using the\n       StartService API function before a suicide script is generated (as msvcrt.bat) and executed to remove the original\n\n```\nSierraBravo-One binary from the victim’s system.\n\nWhen SierraBravo-One is activated as a standard executable with no command line arguments, the binary\neffectively activates as a service executable. When activated as a service executable, SierraBravo-One uses the\n```\n       StartServiceCtrlDispatcher API function to establish the service framework for the binary. After activating the\n\n```\nnecessary service framework to establish itself as a legitimate service on the victim’s computer, SierraBravo-One transfers\ncontrol to its core functionality.\n\nThe core functionality of SierraBravo-One is contained within two C++ classes and requires a minimal amount\nof scaffolding code in order to activate. Specifically, the dynamic loading of API functions, the loading of the\nconfiguration from %WINDIR%\\KB25468.dat into memory, and the activation of the Windows’s WinSock API. The two\nSierraBravo-One classes divide the tasks of running the attacks and managing the attacks. Novetta has given the class\nresponsible for running the attacks the identifier CSmbSpreader and given the class responsible for managing the\nattacks the name CBrambulManager.\n\nThe instantiation of the CSmbSpreader class object consists establishing a list of targets and configuration settings.\nThe file %WINDIR%\\KB25879.dat contains a list of targets queued from previous executions of SierraBravo-One and is\naugmented at startup by a list of local network IP addresses. The instantiation of the CBrambulManager class object is\nsignificantly less involved and only includes the establishment of a watchdog event (which will be explained shortly).\n\nAfter instantiating the two primary classes of SierraBravo-One, the malware activates CBrambulManager first by\ngenerating a new thread and calling the primary method within the class. The main member of CSmbSpreader is\nsimilarly activated within its own thread. At this point, the main thread of SierraBravo-One enters an infinite sleep.\n\nThe main member of CBrambulManager begins by generating a watchdog thread. The watchdog thread, as the name\nimplies, periodically (every 5 minutes, approximately) sets the watchdog event. This process repeat until SierraBravo-One\nterminates. The main member of CBrambulManager uses the watchdog as an indicator of when it should begin the\nfollowing set of tasks:\n\n1. Connect to the configured C2 server\n\n2. Transmit the current attack log (located at %SYSDIR%\\perfw06.dat) to the C2 server\n\n3. Generate new, random target IPs if instructed by the C2 server\n\n4. Receive additional targets from the C2 server\n\n5. [Optionally] Send a heartbeat to the C2 server.\n\nAfter performing the set of tasks, the main member of CBrambulManager resets the watchdog event and waits for the\nnext watchdog event to occur.\n\nWhat is important to note about the tasks of the main member of CBrambulManager is that SierraBravo-One\ndoes not only generate its own random targets, but it can also receive explicitly stated targets from a C2 server. If\nthe C2 server provides additional targets, SierraBravo-One does not send a heartbeat. Instead, the main member of\n`CBrambulManager` sleeps for 3 minutes before waiting for the next watchdog event to occur.\n\nCommunication with the C2 server is encrypted using a simple XOR 0x37. The handshake upon connect with the C2\nserver is a simple DWORD value exchange to verify that the encoding is symmetric between hosts. Such a simplistic\nencryption allows for easy decryption of communication between the C2 server and the infected host.\n\nIf a heartbeat that SierraBravo-One sends results in a failure to receive from the C2 server or if the server replies with\na 0 (after decryption), the main function of CBrambulManager begins the process of uninstalling and terminating\nSierraBravo-One. The configuration file, the target list file, and the attack log files are deleted, and the service under\n\n\n-----\n\nwhich SierraBravo-One exists is terminated and deleted. To complete the removal of SierraBravo-One, the malware\ngenerates and executes a suicide script before calling ExitProcess.\n\nThe main member of the CSmbSpreader class consists of an infinite loop that performs the following tasks until the\nSierraBravo-One process terminates:\n\n1. Wait until the number of attack threads is less than the maximum allowed thread count\n\n2. Convert the target IP from a binary number into a quad-dot string (e.g. 1.1.1.1)\n\n3. Generate a new attack thread for the target\n\n4. After 255 attack threads, save the current state of the targeting queue\n\n5. If the attack queue is empty, set the watchdog event\n\n6. Sleep for 1 second\n\nThe attack thread that SierraBravo-One generates for each new target begins by attempting to connect to the target\nvia Windows share (SMB). If successful, the domain and Windows OS type (e.g. Windows XP, Windows Vista, etc.) are\nobtained. The attack thread then attempts to bruteforce the Windows share by attempting a combination of the generated\nusername and password combinations. The generating of usernames centers around permutations of the username\n```\n       Administrator in two different languages (English and Spanish) combined with variations of the target’s reported\n\n```\ndomain name. The passwords that SierraBravo-One uses are generated from a list of 185 weak passwords, of which 11 are\nused as templates. If the password string contains %u, SierraBravo-One generates a new password where the %u substring\nhas been replaced with generated username. Table 15-1 lists the hardcoded passwords found within SierraBravo-One.\n\n\n-----\n\n```\n          %u 007 baseball Admin789&*(\n\n```\n**%u1234** **qazwsx** **1313** `Password`\n```\n          %u! root !@# 1password\n\n```\n`%u12` **!@#$%^&*** `88888` **password123**\n```\n          %u!@ 00000 shadow password.\n          %u2014 12 win 999999\n          %u1004 888 winxp 7777777\n          %u1! 1212 sunshine Admin\n          %u#1 dell gateway PASSWORD\n\n```\n**%u123** `abc` `harley` **adobe123**\n**%u123$%^** `manager` `internet` `princess`\n**112233** `88888888` **temp123** `azerty`\n**123456** **q1w2e3r4** `xp` **qwer1234**\n**123** **1q2w3e** `2007` **qwer1234!~**\n`admin` **54321** `admin!@#` **admin@123**\n**1234** `password1` `asdfg` **1qaz@wsx**\n`1` `aaa` **!@#$%^** `!!!!`\n`password` `home` **2003** `himself.51`\n`P@ssw0rd` **qazwsxedc** `trustno1` `elmismo.51`\n```\n          P@ssw0rd1 2010 golf Elmismo.51\n\n```\n`p@ssw0rd` `pass` **!@#$%^&** `ElMismo.51`\n```\n          0 computer 2112\n\n```\n**12345** **4321** `default`\n**1111qq** **qwert** **fish**\n**112233** **test123** `god`\n**QWER1234** `121212` `!`\n```\n          0000 secret 2005\n\n```\n**12345678** `iloveyou` **6969**\n**123456789** `asdf` `!@#$`\n`000000` `aa` **blank**\n```\n          a welcome foobar\n\n```\n**123123** `master` `owner`\n`1111` **compaq** `passwd`\n```\n          111 temp test1\n          111111 oracle xxxx\n\n```\n`guest` **1234qwer** `password!`\n**admin123** `abcd` `passw0rd`\n**qwerty** **q1w2e3** `passw0rd!`\n```\n          000 xxx p@ssw0rd!\n\n```\n**654321** `2008` **1234567890**\n**1234567** `7777` ***1234**\n**abc123** `cisco` **1q2w3e4**\n**321** **asdf123** **1qaz2wsx**\n`11` `asdfgh` **!@#123**\n`11111111` **q1w2e3r4t5** **admin!@#456**\n**1q2w3e4r** `zxcv` **Admin!@#456**\n`server` `00` **admin123$%^**\n`888888` `control` **Admin123$%^**\n`11111` **123abc** `rootroot`\n**123qwe** `2009` **87654321**\n`love` **backup** `2014`\n`super` **qwer** `win2012`\n`8888` **q1w2e3r4t5y6** **admin123!@#**\n`test` **win2003** **Admin123!@#**\n```\n          letmein 2002 admin789&*(\n\n```\n**Table 15-1: SierraBravo-One Password List (note that the entries in bold are template passwords)**\n\n\n-----\n\nWith a list of username and passwords ready for the specific target, the attack thread attempts to bruteforce the target.\nSierraBravo-One attempts to pull a list of valid usernames from the target host by calling the NetUserEnum API\nfunction. If successful, the bruteforcing process uses the names returned from NetUserEnum instead of the variations\nof Administrator. Regardless of which usernames list is used, the bruteforce process does not use the Windows SMB\nAPI functions but rather performs the SMB interaction manually through SMB packet crafting. For each username and\npassword combination, SierraBravo-One attempts to login to the target through the root Windows share (e.g. \\\\1.1.1.1)\nuntil a successful combination is found or the set of combinations is exhausted.\n\nIf successful in finding a vulnerable account on the targeted machine, SierraBravo-One attempts to install itself and its\npayload malware (typically, the payload malware is the instance of SierraJuliett-MikeOne running on the same machine as\nthe SierraBravo-One infection). The procedure for infecting a vulnerable machine is as follows:\n\n1. Connect to the root share on the targeted host using the username and password obtained from the bruteforcing\n\nprocess by using the Windows SMB API.\n\n2. Create a service on the targeted host as RPCEvent{random decimal number} with one of the following command\n\nlines in order to establish a new share named $adnim on the targeted machine. Note the misspelling of the new\nshare. The developer(s) specifically mislabeled the share to be close to the legit admin$ share. The use of the GRANT\nparameter occurs on targets who report their operating system as any value other than Windows 5.0, Windows\n`5.1, or Windows 2002` (e.g., non-Windows NT based computers).\n\n**cmd.exe /q /c net share adnim$=%SystemRoot% /GRANT:{username},FULL**\n\n**Figure 15-1: SierraBravo-One Share Command for Victims Using Windows 2000 or later**\n\n**cmd.exe /q /c net share adnim$=%SystemRoot%**\n\n**Figure 15-2: SierraBravo-One’s Share Command for Victims running Non-Windows NT Computers**\n\n3. Copy the payload malware to targeted host’s %SYSDIR% directory via the new adnim$ share.\n\n4. Reads the local SierraJuliett-MikeOne’s seed list file (mssscardprv.ax) to obtain the first IP and port in the list.\n\n5. Create a new service called HelpEvent{same random decimal number as step #2} with the command line seen in\n\nFigure 15-1 in order to activate the SierraJuliett-MikeOne payload on the targeted machine.\n```\n          cmd.exe /c {Binary Name} {IP of Seed Node} {Port of Seed Node}\n\n```\n**Figure 15-3: SierraBravo-One’s SierraJuliett-MikeOne Activation Command**\n\n6. The adnim$ share is deleted by issuing the command seen in Figure 15-4 under the same HelpEvent{...} service.\n\n**cmd.exe /q /c net share adnim$ /delete**\n\n**Figure 15-4: SierraBravo-One’s Command to Delete the Previously Established Share**\n\nAfter the installation (or attempted installation) of the SierraJuliett-MikeOne malware on the target machine,\nSierraBravo-One attempts to determine if the Windows Terminal Services port (3389) is accessible on the target. In order\nto make the accessibility determination, SierraBravo-One merely attempts to connect to the port. If the connection is\nsuccessful (without any data transfer), SierraBravo-One considers the port available.\n\n\n-----\n\n|OFFSET|SIZE|DESCRIPTION|\n|---|---|---|\n|0|4 Bytes (DWORD)|IP address of target|\n|4|1 Byte|Host attributes bitmask: bit 0 – infected successfully bit 4 – has Terminal Services port open|\n|5|1 Byte (Boolean)|Target successfully infected|\n|6|50 Bytes (NULL-terminated string)|Username used to access the target|\n|56|50 Bytes (NULL-terminated string)|Password used to access the target|\n|106|50 Bytes (NULL-terminated string)|Domain of the target|\n|156|100 Bytes (NULL-terminated string)|Windows OS version reported by SMB|\n\n\nSierraBravo-One retains a log of all successful attacks. Each log entry contains the fields illustrated in Table 15-2.\n\n**OFFSET** **SIZE** **DESCRIPTION**\n\n0 4 Bytes (DWORD) IP address of target\n\nHost attributes bitmask:\n\n4 1 Byte bit 0 – infected successfully\n\nbit 4 – has Terminal Services port open\n\n5 1 Byte (Boolean) Target successfully infected\n\n6 50 Bytes (NULL-terminated string) Username used to access the target\n\n56 50 Bytes (NULL-terminated string) Password used to access the target\n\n106 50 Bytes (NULL-terminated string) Domain of the target\n\n156 100 Bytes (NULL-terminated string) Windows OS version reported by SMB\n\n**Table 15-2: SierraBravo-One’s Attack Log Entry Structure**\n\nBefore saving the log entry to the log file, SierraBravo-One encrypts each log entry with RC4. The encryption key used for\nthe RC4 encryption is 118 bytes long and changes every 10 minutes. The generation of the RC4 keys involves the creation of a\nrandom 118-byte buffer and then the encryption of the 118-byte buffer using the same RSA public key found in SierraJuliett-\nMikeOne. The encrypted RC4 key is then saved to the attack log file followed immediately by the encrypted log entry.\n\nAfter performing an attack against a target, the resources of the attack thread are released and the global indicator of\nnumber of attack threads in use is decremented.\n\n\n-----\n\n#### 15.2 SierraBravo-Two\n\nSierraBravo-Two operates as service DLL with the primary entry point for the malware existing within the\n```\n       ServiceMain function. After establishing the scaffolding for a legitimate Windows service, SierraBravo-Two spawns\n\n```\na new thread to contain the core SierraBravo-Two functionality. At inception, the core of SierraBravo-Two attempts\nto verify if the named mutex PlatFormSDK2.1 exists on the victim’s system indicating at another instance of\nSierraBravo-Two is already active. If another instance is active, the malware terminates to avoid collisions.\n\nLike SierraBravo-One, SierraBravo-Two is heavily object oriented with the bulk of its functionality contained within\na single class object. Upon instantiation, the SierraBravo-Two class requires the maximum number of parallel attack\nthreads allowed, the filename of the malware to spread, and the number of seconds to wait for a response from a\ntargeted machine before aborting the attack. This information is used by the class as the basis for the configuration of\nthe SierraBravo-Two’s operation. During the class initialization process, the list of queued attack targets is loaded into\nmemory from the file %SYSDIR%\\KB25879.dat as well as an additional set of targets based on the local network’s IP\nrange (as determined by the configuration of the victim’s network cards).\n\nSierraBravo-Two performs the same attack against as a target as SierraBravo-One with the following modifications:\n\n         - The initial username list consists of Administrator in English, Spanish and French\n\n          - The SierraJuliett-MikeOne configuration/seed list file is also copied to the target\n\n         - The activation of SierraJuliett-MikeOne on the target machine does not include the {IP of Seed Node} or {Port of\n\nSeed Node} command line parameters\n\n          - A record of the compromise is not recorded locally, but an email of the event occurs instead\n\n          - After every 255 attacks, the current state of the attack queue is saved to disk.\n\n         - After the entirety of the attack queue is complete, the maximum of attack threads are generated with each thread\n\nmarked for randomly generating IP addresses to attack and then attacking said targets. Note that, as indicated\npreviously, some network ranges are excluded.\n\nThe most distinctive difference between SierraBravo-One and SierraBravo-Two is the use of email for alerting the\noperators to newly infected targets. For each target infected, SierraBravo-Two generates a thread to handle the generation\nand transmission of an email message via SMTP. The email addresses used by SierraBravo-Two for both the To: and\n```\n       From: fields change periodically, but the structure of the email is largely consistent. The message contains no body but\n\n```\nthe subject line provides all of the necessary information for an attacker. The subject is structured as follows:\n\n<ip in dotquad>|<domain>|<os version>|<username>|<password>|<response code from the infection\nattempt>|<flags>\n\nThe <flags> field, as in SierraBravo-One, provides details about the status of the infection (bit 0) and if Windows Terminal\nServices are accessible via port 3389 (bit 4).\n\n\n-----\n\n## 16. [Spreader] SierraCharlie\n\nSierraCharlie is a spreader that appears to target RDP as its vector for propagation. Novetta has not spent a significant\namount of time investigating the SierraCharlie family before publication, but the following characteristics of the malware\nfamily are known:\n\n1. The random IP generation code found in both SierraJuliett-MikeOne and SierraBravo can be found within\n\nSierraCharlie\n\n2. SierraCharlie, structurally speaking, is heavily object oriented (C++)\n\n3. The suicide script within SierraCharlie is consistent with other Lazarus Group malware families\n\n4. The propagation mechanism appears to focus on RDP\n\n5. At least one sample identifies the malware’s program name as “RDPBForce”\n\n6. At least two samples have two distinct version information entries with in the resource section with one entry in\n\nEnglish and the other in Korean.\n\n\n-----\n\n### 17. [P2P Staging] SierraJuliett-MikeOne (Joanap Mk I.)\n\nCommonly known as Joanap, SierraJuliett-MikeOne is a peer-to-peer (P2P) malware family that gives the Lazarus\nGroup the ability to rapidly establish a common program base across all infected machines as well as provide remote\nadministration functionality on each individual infection. SierraJuliett-MikeOne (SJM1) is the older sibling of\nSierraJuliett-MikeTwo (SJM2) (see Section 18). While both SJM1 and SJM2 perform essentially the same function and follow\nroughly the same communication protocols, the two do not constitute variants of one another in the sense that the term\nvariant has been established in this report. SJM1 and SJM2 have clearly different code bases, indicating they were most\nlikely developed independently of one another but based on a common design specification. It is the clear distinction\nbetween the two code bases that necessitates they fall into different families.\n\nThe samples within the SJM1 family are largely homogenous with each consecutive sample (based on compile time) having\nan average similarity 98.7% to its neighboring sample. Installed typically by IndiaJuliett, SJM1 operates as a svchost-\ndependent service DLL. The ServiceMain export does little more than provide the necessary scaffolding for SJM1\nto appear to be an active service. The core of SJM1 is activated when the DLL is loaded by svchost and calls DllMain.\n```\n       DllMain spins the core of SJM1 off into its own thread. Some later samples of SJM1 place an intermediate piece of code\n\n```\nbetween the DllMain and the core by having the newly generated thread call a function to call DialogBoxParamA\nwith the lpDialogFunc ultimately calling the core of SJM1. It is unclear why this small variation was introduced as it\nseems to serve no real purpose.\n\nThe core of SJM1 consists of three functions as Figure 17-1 illustrates. The first function initializes the SJM1 system. The\ninitialization function begins by performing dynamic API loading. The dynamic API loading functions within SJM1 use\nan AES implementation to decrypt the names of the API functions to load via GetProcAddress. The AES implementation,\nCRijndael, is a direct lift from a CodeProject project by George Anescu that he published in November, 2002.[9] The same\ndynamic API loading functions for the API functions from kernel32.dll, psapi.dll, and ws2_32.dll used by\nSJM1 can be found in RomeoFoxtrot (see Section 8) albeit with different AES keys. A strange feature of these dynamic API\nloading functions, in both SJM1 and RomeoFoxtrot, is that all but the ws2_32.dll functions use the same AES key, but\nfor some reason the Winsock API loading code uses a different key.\n\n**void SierraRomeoMikeOneCore()**\n```\n          {\n           if ( Initialize() )\n           {\n            if ( StartIncomingClientsHandler(0) )\n             StartP2PClientThread(0);\n           }\n          }\n\n```\n**Figure 17-1: SierraJuliett-MikeOne’s Core**\n\n[9 George Anescu. CodeProject. “A C++ Implementation of the Rijndael Encryption/Decryption method”. http://www.codeproject.com/Articles/1380/A-C-Implementation-of-the-Rijndael-Encryption-Decr 8 Nov 2002.](http://www.codeproject.com/Articles/1380/A-C-Implementation-of-the-Rijndael-Encryption-Decr)\n\n\n-----\n\n|OFFSET|SIZE|FIELD DESCRIPTION|\n|---|---|---|\n|0|4 Bytes (DWORD)|Node type|\n|4|4 Bytes (DWORD)|IP address of the first NIC of the victim’s system|\n|8|16 Bytes (SYSTEMTIME structure)|Internal timestamp of the configuration data|\n|24|6 Bytes|MAC Address of the first NIC of the victim’s system|\n|30|2 Bytes (WORD)|Checksum/hash of CPU’s ID value|\n|32|4 Bytes (DWORD)|Last command ID number|\n|36|2 Bytes (WORD)|Listening port number|\n|38|130 Bytes|Actor’s remarks/Campaign ID|\n|168|720 Bytes (30 NodeInfo structure array)|List of seed/known peer nodes (see Table 17-2 for details of the structure)|\n|888|260 Bytes|Unknown string|\n|1148|64 Bytes|Unknown string|\n|1212|64 Bytes|Unknown string|\n|1276|64 Bytes|Unknown string|\n|1340|4 Bytes (DWORD)|Zero if the SJM1 node is known to be behind a NAT and non-routable from the Internet|\n|1344|2 Bytes (WORD)|Counter indicating the number of times the node has connected to peers|\n\n\nThe Initialize function loads the current configuration file into memory from %SYSDIR%\\mssscardprv.ax. The\nconfiguration file contains a 1346-byte structure that contains the basic configuration information for SJM1 as well as the\n_seed list of known peer nodes. Table 17-1 details the structure of the configuration data. The node type field (offset 0) is_\ninitially set to 0x1000101 during the initialization phase of SJM1.\n\n**OFFSET** **SIZE** **FIELD DESCRIPTION**\n\n0 4 Bytes (DWORD) Node type\n\n4 4 Bytes (DWORD) IP address of the first NIC of the victim’s system\n\n16 Bytes (SYSTEMTIME\n8 Internal timestamp of the configuration data\nstructure)\n\n24 6 Bytes MAC Address of the first NIC of the victim’s system\n\n30 2 Bytes (WORD) Checksum/hash of CPU’s ID value\n\n32 4 Bytes (DWORD) Last command ID number\n\n36 2 Bytes (WORD) Listening port number\n\n38 130 Bytes Actor’s remarks/Campaign ID\n\n720 Bytes (30 NodeInfo\n168 List of seed/known peer nodes (see Table 17-2 for details of the structure)\nstructure array)\n\n888 260 Bytes Unknown string\n\n1148 64 Bytes Unknown string\n\n1212 64 Bytes Unknown string\n\n1276 64 Bytes Unknown string\n\nZero if the SJM1 node is known to be behind a NAT and non-routable from the\n1340 4 Bytes (DWORD)\nInternet\n\n1344 2 Bytes (WORD) Counter indicating the number of times the node has connected to peers\n\n**Table 17-1: Configuration Data Structure of SierraJuliett-MikeOne**\n\nIf the listening port field (offset 36) is set to 0, SJM1 will attempt to determine a valid listening port on the victim’s host.\nThe process for determining a listening consist of the following steps:\n\n1. Using a list of preferred listening ports, attempt to bind the port\n\n2. If the bind is successful, close the socket and return the port number, otherwise try the next preferred listening port\n\nuntil the list is exhausted or a viable port is found\n\n3. If the preferred listening port list is exhausted, attempt to find an available port, using the same method in steps 1\n\nand 2 above, for all ports between 1024 and 2047, inclusive.\n\nSJM1 has a list of 26 preferred listening ports. The list begins with more commonly found ports such as HTTPS, POP3,\nDNS, and HTTP and tappers off to more obscure ports. The preferred listening port list is, in order of preference:\n\n**443, 110, 53, 80, 995, 25, 8080, 1816, 465, 1521, 3306, 1433, 3128, 109, 161, 444, 1080, 520,**\n**700, 1293, 1337, 2710, 3100, 3305, 3689, 11371**\n\nWith SJM1 initialized, the malware calls the StartIncomingClientsHandler function to establish the server side\ncomponent of the P2P bot. The StartIncomingClientsHandler function begins by establishing a listening socket\n\n\n-----\n\non the configured listening port before spawning a thread to handle incoming connections from peer nodes. Section 17.1\nexplains the operations of the server mode thread.\n\nAfter StartIncomingClientsHandler returns, SJM1’s core calls the function StartP2PClientThread to activate\nthe client mode thread. After activating the client mode thread, StartP2PClientThread returns control to the core\nwhich in turn returns control to the loading application, in this case svchost. At this point, the SJM1 malware is running in\ntwo asynchronous threads so the service scaffolding of SJM1 is allowed to run by the Windows Services system.\n\n#### 17.1 Server Mode Thread\n\nThe service mode thread is an infinite loop that waits for incoming connections on the listening port and spawns a new\nthread to handle any connection. When a new peer node connects to another SJM1 node, an authentication phase begins.\nThe authentication between two SJM1 nodes begins by the connecting node (the client, in this case) transmitting a 4-byte\n(DWORD) value to the receiving node (the server). The value that the client sends to the server indicates the general class\nof node the client is: standard node (0x1000) or a super-node (0x1000000). The authentication changes depending on the\ntype of node connecting.\n\nA super-node transmits another 4-byte (DWORD) value that specifies the size of the next transmission. The next\ntransmission contains a buffer of data that has been encrypted by the super-node’s private key. SJM1 decrypts the data\nusing a hardcoded public key found within the SJM1’s .data section and the RSATransform function found in other\nLazarus Group families. A standard node, on the other hand, will simply transmit a 16-byte buffer of random bytes to the\nserver node. Both a super-node and a standard node will perform the initial data transmissions in cleartext.\n\nRegardless of the type of node attempting to authentication, the server node echoes back to the client the data the client\nsent to the server, with the exception that, in the case of a super-node, the data is now decrypted using the RSA transform.\nWhen the server sends the data to the client, the data is encrypted using RC4. For each buffer that SJM1 sends (in both\nserver mode and client mode), the data is encrypted with RC4 using the key in Figure 17-2.\n\n**0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0x11, 0x12, 0x13, 0x1A, 0xFF, 0xEE, 0x48**\n\n**Figure 17-2: SierraJuliett-MikeOne’s RC4 Key**\n\nThe Sbox within the RC4 implementation is reset after each buffer meaning that data boundaries are critical to avoid\ncorrupting the data stream. It also means that particularly short bursts of data are going to retain discernable patterns as\nthey traverse the network.\n\nThe client will then transmit a 30-byte string to the server (over the encrypted channel) if the server’s response was\ncorrect. The server compares the 30-byte string with the hardcoded string https://www.google.com/index.h and if\nthe two strings are identical, the authentication completes successfully. A misstep in any of the authentication steps will\nresult in the authentication failing and the channel being closed by the server.\n\nWhile the client can identify as a super-node, there is no advantage to do so as SJM1 do not grant additional access\nor privileges to any node that authenticates as a super-node. The authentication process, from the perspective of the\nnode in the server role, is purely a binary output: successful or unsuccessful. The authentication process does, however,\nensure that both sides of the conversation have the same communication key for the RC4 encryption and that both sides\nunderstand the basic protocol for communication. After the authentication sequence completes, all communications\nbetween the two nodes uses the RC4 encryption for data that traverses the network between them.\n\nFollow the authentication phase, the server mode expects the client to send a 2-byte (WORD) value that specifies the\nparticular channel the client wishes to access. SJM1 supports three different channels: crawler (0x2000), RAT (0x4000),\nsync (0x8000).\n\n\n-----\n\n|OFFSET|SIZE|FIELD DESCRIPTION|\n|---|---|---|\n|0|4 Bytes (DWORD)|IP address of node|\n|4|2 Bytes (WORD)|Listening port of node|\n|6|2 Bytes|Unused|\n|8|4 Bytes (DWORD)|Tracking field 1|\n|12|4 Bytes (DWORD)|Tracking field 2|\n|16|8 Bytes (VARIANTTIME)|Timestamp of the last time the node was contacted|\n\n\n###### 17.1.1 Crawler Channel\n\nThe crawler channel allows one node to quickly determine the node list of another node. By accessing the peer list of\na node, it is a simple process to enumerate all of the connected nodes of the SJM1 network that have Internet-facing,\nroutable interfaces.\n\nThe client node transmits a 6-byte data structure to the server node. The data structure consists of a 4-byte (DWORD)\nvalue specifying if the client node knows it is not behind a NAT device and thus Internet accessible followed by a 2-byte\n(WORD) value the defines the client’s own listening port number. If the value specifying if the client is accessible from\nthe Internet is 0, the server will attempt to connect to the client on the specified listening port. This allows the server to\ninform the client if it is behind a non-routable NAT device. The routability test begins by attempting to connect to the\nclient node on the specified listening port and then performing the authentication phase if the connection is successful.\nIf both of those events occur, then the client node is considerable routable, otherwise the node is considered inaccessible.\nThe status of the test is transmitted to the client over the original channel (which the client initiated) in the form of a\n4-byte (DWORD) value of either 1 (routable) or 0 (non-routable). If the routability test fails, it is repeated two more times.\nGiven that the routability test waits up to 30 seconds per test for a connection to the client node to succeed or timeout, a\nfull minute and a half may expire from the time the crawler channel is activated and the routability test completes.\n\nSJM1 maintains three lists of NodeInfo entries: a list of seed nodes (from the configuration file), a list of known nodes that\nthe SJM1 has either connected to or received from another node who connected to, and a list of client nodes that connected\nto the SJM1 node. The seed nodes list is limited to 30 NodeInfo entries, the known nodes list has a limit of 50 NodeInfo\nentries, and the list of client nodes that have connected to the SJM1 node has a maximum of 100 NodeInfo entries.\n\nA NodeInfo structure contains information about a particular node as Table 17-2 illustrates. The most important fields\nwithin the structure are the IP address of the node, the port upon which the node listens for incoming connections\nand the timestamp of the last time a node successfully connected to the node. The timestamp is recorded in the\n```\n       VARIANTTIME format which is essentially a floating point number (a double) that defines the number of days (the\n\n```\ninteger value) and partial days (the decimal value) since December 30, 1899 at midnight.[10] A value of 2.5 for instance,\nrepresents January 1, 1900 at noon.\n\n**OFFSET** **SIZE** **FIELD DESCRIPTION**\n\n0 4 Bytes (DWORD) IP address of node\n\n4 2 Bytes (WORD) Listening port of node\n\n6 2 Bytes Unused\n\n8 4 Bytes (DWORD) Tracking field 1\n\n12 4 Bytes (DWORD) Tracking field 2\n\n16 8 Bytes (VARIANTTIME) Timestamp of the last time the node was contacted\n\n**Table 17-2: SierraJuliett-MikeOne’s NodeInfo Data Structure**\n\nAt the completion of the routability test, the server node transmits it current time, in the VARIANTTIME format to the\nclient followed by the full array of 50 known nodes’s `NodeInfo entries. In order to prevent loops where a node connects`\nback to itself, prior to transmitting the known nodes entries the server node removes any NodeInfo entry for the client\nnode and replace the removed NodeInfo with an empty (all zeros) entry.\n\n[10 Microsoft. “SystemTimeToVariantTime function” https://msdn.microsoft.com/en-us/library/windows/desktop/ms221646(v=vs.85).aspx Accessed 7 December 2015.](https://msdn.microsoft.com/en-us/library/windows/desktop/ms221646(v=vs.85).aspx)\n\n\n-----\n\n|Authentication Crawler Channel Request (0x2000) {Behind NAT Status, Listening Port} Authentication (Server Initiated, New Socket) Routability Results (DWORD) Node’s Current Time (VARIANTTIME) Node’s “Known Nodes” List|Col2|\n|---|---|\n\n|OFFSET|SIZE|FIELD DESCRIPTION|\n|---|---|---|\n|0|4 Bytes (DWORD)|Size of the data transmission to follow|\n|4|2 Bytes (WORD)|Data type|\n|6|Variable|Optional payload data|\n\n\nAfter the server transmits the known nodes entries, the server again attempts to connect back to the client and\nauthentication in order to determine if the client has a routable interface. If the server is successful in the connect back,\nthe node is added to the list of known nodes if it does not already exist or, if the client is already in the known nodes list,\nits last contact time (field 16 of NodeInfo) is updated to reflect the current time. The process of adding or updating the\nclient node’s entry is repeated for the seed nodes list.\n\nThe server shuts down the channel and disconnect from the socket before terminating the thread handling the client’s\nconnection. Visually, the crawler channel’s communication is illustrated by Figure 17-3. In the illustration the gray arrows\nrepresent the client initiated socket and the direction of communication for each step while the red arrows represent the\nserver initiated connection back to the client during the routability test.\n\n###### Client Node Server Node\n\nAuthentication\n\nCrawler Channel Request (0x2000)\n\n{Behind NAT Status, Listening Port}\n\nAuthentication (Server Initiated, New Socket) Up to 3 Times\n\nRoutability Results (DWORD)\n\nNode’s Current Time (VARIANTTIME)\n\nNode’s “Known Nodes” List\n\n**Figure 17-3: Crawler Channel Communication Sequence**\n\n###### 17.1.2 RAT Channel\n\nThe RAT channel provides, as the name would imply, RAT capability to the SJM1 family. Unauthenticated outside of the\ninitial handshake between two nodes, the RAT channel support 21 different commands ranging from file management to\ndata exfiltration to process management to node management.\n\nOnce a client requests the RAT channel, the client must send a datagram specifying the command and arguments (if\nany) for the command. Datagrams, in the context of SJM1, are variable sized data structures that specify a data type (or\ncommand type) followed by optional unstructured data specific to the data type specified. The datagram structure (Table\n17-3) dictates that at a minimum a datagram is 6 bytes in size on the network.\n\n**OFFSET** **SIZE** **FIELD DESCRIPTION**\n\n0 4 Bytes (DWORD) Size of the data transmission to follow\n\n4 2 Bytes (WORD) Data type\n\n6 Variable Optional payload data\n\n**Table 17-3: SierraJuliett-MikeOne’s Datagram Structure**\n\n\n-----\n\n|COMMAND NUMBER|DESCRIPTION|\n|---|---|\n|0x4001|Echo. Receives another datagram from client then returns the same datagram to the client with the size field set to 512 bytes before sleeping for 1 second.|\n|0x4002|Retrieves the client list and known nodes list.|\n|0x4003|Sends Client Information. Sends the node’s ClientInfo and ClientInfoEx data in individual datagrams.|\n|0x4004|Attempts to connect to the specified endpoint. The first 4-bytes (DWORD) of the payload data specifies the IP address of the end point with the next 2-bytes (WORD) specifying the port number. If successful, return a datagram with the data type (offset 4) set to 1, otherwise the data type is set to 0 indicating the end point was unreachable.|\n|0x4005|Uploads a local file to the client. The payload data contains the full name and path of the file to transfer to the client.|\n|0x4006|Downloads a file from the client node. The payload data contains the destination filename and path starting at offset 3. Offset 1 of the payload data, if set, indicates if the file should be deleted if the download fails. The timestamp of the downloaded file is set to random date with the year set to 2 years prior to the current year.|\n|0x4007|NOP|\n|0x4008|Downloads a file from the client, executes the file, then deletes it. The filename is randomly generated as rundll{random number}.exe and given a random dates set two years prior to the current year.|\n|0x4009|NOP|\n|0x400A|Starts a process. The payload data contains the full command line to execute.|\n|0x400B|Set the actor’s remarks/campaign ID (offset 28) within the configuration data structure. The payload data contains the value for the field.|\n|0x400C|Deletes a file or directory (if the name specified is a directory). The payload data contains a string specifying the full name and path to the file or directory to delete.|\n|0x400D|Move (or rename) file. The datagram’s payload data for the command contains two null terminated strings with the first specifying the source file’s name and full path and the second string the new name and full path of the file.|\n|0x400E|Creates a directory. The datagram’s payload data contains a string specifying the full pathname of the new directory|\n|0x400F|Terminates process by name. The datagram’s payload data contains a string specifying the name of the process to terminate.|\n|0x4010|Resets the last command ID to 0|\n|0x4011|Deletes all command files under the %SYSDIR%\\1008 directory.|\n|0x4012|Replaces the first NodeInfo entry in the seed node list. The payload data contains first 16-bytes of the new NodeInfo structure.|\n|0x4013|Sets three configuration values (offsets 888, 1148, and 1212). The payload data of the datagram consists of three NULL-terminated strings, one for each value.|\n|0x4014|Variation on command 0x4002.|\n|0x4015|Pushes a command to all neighboring nodes.|\n\n\nThe transmission of a datagram is always a two-step process. SJM1 transmits the 4-byte size value first then transmits\nthe remainder of the datagram. This is important to understand because, as mentioned previously, the RC4 encryption\nis reset after each transmission meaning that same sized datagrams, but potentially with different data types and data\npayloads, will always send the same 4-byte initial transmission.\n\nThe RAT channel uses the data type field (offset 4) of the datagram as the command type the client is requesting. If the\ncommand type is a recognized value, the appropriate command function is called and, if required, the payload data is\npassed to the function. Table 17-4 lists the supported command types and their descriptions.\n\n**COMMAND NUMBER** **DESCRIPTION**\n\nEcho. Receives another datagram from client then returns the same datagram to the client with the\n0x4001\nsize field set to 512 bytes before sleeping for 1 second.\n\n0x4002 Retrieves the client list and known nodes list.\n\n0x4003 Sends Client Information. Sends the node’s ClientInfo and ClientInfoEx data in\nindividual datagrams.\n\nAttempts to connect to the specified endpoint. The first 4-bytes (DWORD) of the payload data\nspecifies the IP address of the end point with the next 2-bytes (WORD) specifying the port number.\n\n0x4004\n\nIf successful, return a datagram with the data type (offset 4) set to 1, otherwise the data type is set\nto 0 indicating the end point was unreachable.\n\nUploads a local file to the client. The payload data contains the full name and path of the file to\n0x4005\ntransfer to the client.\n\nDownloads a file from the client node. The payload data contains the destination filename and path\nstarting at offset 3. Offset 1 of the payload data, if set, indicates if the file should be deleted if the\n\n0x4006\n\ndownload fails. The timestamp of the downloaded file is set to random date with the year set to 2\nyears prior to the current year.\n\n0x4007 NOP\n\nDownloads a file from the client, executes the file, then deletes it. The filename is randomly\n\n0x4008 generated as rundll{random number}.exe and given a random dates set two years prior to the\n\ncurrent year.\n\n0x4009 NOP\n\n0x400A Starts a process. The payload data contains the full command line to execute.\n\nSet the actor’s remarks/campaign ID (offset 28) within the configuration data structure. The\n0x400B\npayload data contains the value for the field.\n\nDeletes a file or directory (if the name specified is a directory). The payload data contains a string\n0x400C\nspecifying the full name and path to the file or directory to delete.\n\nMove (or rename) file. The datagram’s payload data for the command contains two null terminated\n\n0x400D strings with the first specifying the source file’s name and full path and the second string the new\n\nname and full path of the file.\n\nCreates a directory. The datagram’s payload data contains a string specifying the full pathname of\n0x400E\nthe new directory\n\nTerminates process by name. The datagram’s payload data contains a string specifying the name\n0x400F\nof the process to terminate.\n\n0x4010 Resets the last command ID to 0\n\n0x4011 Deletes all command files under the %SYSDIR%\\1008 directory.\n\nReplaces the first NodeInfo entry in the seed node list. The payload data contains first 16-bytes\n0x4012\nof the new NodeInfo structure.\n\nSets three configuration values (offsets 888, 1148, and 1212). The payload data of the datagram\n0x4013\nconsists of three NULL-terminated strings, one for each value.\n\n0x4014 Variation on command 0x4002.\n\n0x4015 Pushes a command to all neighboring nodes.\n\n**Table 17-4: RAT Commands and Their Command Type Values Supported by SierraJuliett-MikeOne**\n\n\n-----\n\n|OFFSET|SIZE|FIELD DESCRIPTION|\n|---|---|---|\n|0|128 Bytes|Encrypted Command File Header (see Table 17-6)|\n|128|Variable but at least 4 Bytes (m)|Data header (see Table 17-7)|\n|m+4|4 Bytes (DWORD)|Size of data field|\n|m+132|Variable (n)|Data|\n|m+n+132|128 Bytes|(Optional) encrypted verification data|\n\n\nAfter the RAT channel processes the requested command, SJM1 terminates the connection between the client node and\nitself. Therefore, each time an attacker wishes to issue a command against a SJM1 node, the attacker much reconnect to\nthe node.\n\nThe inclusion of the RAT channel is somewhat unusual for several reasons. First, the channel is unauthenticated while,\nas presented in the sync channel discussion, there is a heavy use of asymmetric encryption to ensure command files are\nlegitimate and only producible by the Lazarus Group attackers. Secondly, the construction of the RAT channel appears\nalmost as if it were an afterthought of the developer(s) given that it requires constant reconnections to a node to issue\nmultiple commands. Lastly, the RAT channel is single node focused, while the rest of the functionality of SJM1 is geared\ntoward a hive or collective.\n\n###### 17.1.3 Sync Channel\n\nThe crawler channel and sync channel share the same handler function with the crawler channel being the basis for the\nsync channel’s operations. More to the point, the entirety of the crawler channel’s events occurs as a precursor to the sync\nchannel specific operations. Therefore, immediately following the transfer of the known nodes list to the client from the\nserver and the updating of the appropriate NodeInfo entries in the known nodes and seed nodes lists, the sync channel\nadds to or updates the client to the client nodes list.\n\nThe client sends two datagrams containing information about the client node to the server. The first datagram contains a\n```\n       ClientInfo data structure (see Table 17-8) describing aspects of the client node related to its basic properties such as IP\n\n```\naddress and listening port as well as its type. The second datagram contains a ClientInfoEx data structure (see Table\n17-9) that describes hardware and operating system level aspects of the node such as the OS version information, CPU\ndetails, and if particular ports of interest are open, among other details. If the size of the two datagram payloads matches\ntheir respective data structure sizes, the data structures are joined into a single data structure and stored within the list of\n_client nodes. If, however, the size of the ClientInfo data structure is incorrect, the ClientInfoEx transfer is aborted_\nby the server node.\n\nThe client node and the server node now begin the process of the client node synchronizing its command files. Command\nfiles are specifically formatted data files that SJM1 uses to transfer commands from node to node. The structure of a\ncommand file (Table 17-5) consists of a RSA encrypted header, the command’s data and its associated header in a cleartext\nheader, and an optional encrypted data blob containing the information necessary to verify the integrity of the entire\ncommand file.\n\n**OFFSET** **SIZE** **FIELD DESCRIPTION**\n\n0 128 Bytes Encrypted Command File Header (see Table 17-6)\n\n128 Variable but at least 4 Bytes (m) Data header (see Table 17-7)\n\nm+4 4 Bytes (DWORD) Size of data field\n\nm+132 Variable (n) Data\n\nm+n+132 128 Bytes (Optional) encrypted verification data\n\n**Table 17-5: SierraJuliett-MikeOne’s Command File Structure**\n\nThe first 128 bytes of a command file are encrypted using a private RSA key that presumably only belongs to the Lazarus\nGroup, as the key has not been found disclosed publicly. Underneath the RSA encryption lies the command file header\n(see Table 17-6) which species the type of command, an identifier for the command, the data/parameters of the command\nand the size of that data along with its header, and, optionally, the necessary information to verify the integrity of the\nentire command file along with the command’s data and the data’s associated header. The command ID field (offset 4)\nis particularly important as it allows SJM1 nodes to quickly determine if a particular command file has previously been\nexecuted based on a running counter of the last command ID executed (offset 32 of the node’s configuration data structure).\n\n\n-----\n\n|OFFSET|SIZE|FIELD DESCRIPTION|\n|---|---|---|\n|0|4 Bytes (DWORD)|Magic value (0xB4F4)|\n|4|4 Bytes (DWORD)|Command ID|\n|8|2 Bytes (WORD)|Command type|\n|10|2 Bytes (WORD)|Verify file flag|\n|12|4 Bytes (DWORD)|Data header size|\n\n|OFFSET|SIZE|FIELD DESCRIPTION|\n|---|---|---|\n|0|1 Byte|Unknown field, seemingly unused|\n|1|1 Byte|Activate command for node types less than 0x1000000|\n|2|1 Byte|Activate command for node types greater than or equal to 0x1000000|\n|3|Variable (NULL-terminated string)|Parameter string for command|\n\n\n**OFFSET** **SIZE** **FIELD DESCRIPTION**\n\n0 4 Bytes (DWORD) Magic value (0xB4F4)\n\n4 4 Bytes (DWORD) Command ID\n\n8 2 Bytes (WORD) Command type\n\n10 2 Bytes (WORD) Verify file flag\n\n12 4 Bytes (DWORD) Data header size\n\n**Table 17-6: SierraJuliett-MikeOne’s Command File Header**\n\nInterestingly, the data header, the size of the data portion, and the data portions of the command file are in cleartext. The\ndata header contains three byte fields followed by an optional NULL-terminated string. The data that follows the data\nheader contains the command specific data and varies in structure based on the command type.\n\n**OFFSET** **SIZE** **FIELD DESCRIPTION**\n\n0 1 Byte Unknown field, seemingly unused\n\n1 1 Byte Activate command for node types less than 0x1000000\n\n2 1 Byte Activate command for node types greater than or equal to 0x1000000\n\n3 Variable (NULL-terminated string) Parameter string for command\n\n**Table 17-7: SierraJuliett-MikeOne’s Command File’s Data Header**\n\nIf the verify file flag (offset 10 of the command file header) is non-zero, the last 128 bytes of the command file contains\nanother RSA private key encrypted data blob containing the MD5 hash of all of the bytes in the command up to, but not\nincluding, the last 128 bytes, which the client node can use to verify the integrity of the command file upon reception.\n\nTo perform the synchronization of command files from the server node to the client node, the client node transmits a\n4-byte (DWORD) value to the server node representing the last command ID that the client executed. The server node\nresponds with a 4-byte (DWORD) value containing its last command ID executed. The server node then enters a loop\npunctuated by calls to FindFirstFile/FindNextFile in order to enumerate all of the server’s stored command files\nfrom the %SYSDIR%\\1008 directory.\n\nFor each command file that the server node finds, the server node decrypts the command file’s header, verifies that the\ndecryption was successful by ensuring that offset 0 of the command file header is equal to 0xB4F4, and then compares\nthe command ID (offset 4) against the client’s last command ID. For any file that successfully decodes and has a value\ngreater than the last command ID reported by the client node, the server node sends a 4-byte value (DWORD) of\n```\n       0x00000010 to the client to indicate that a command file is inbound. The server then sends the command file to the\n\n```\nclient using a sequence of datagrams. The protocol for sending a file to or from a node is as follows:\n\n1. Transmit the entirety of the file in sequence of 4KB datagrams with the data type field set to 0x1111\n\n2. Conclude the transfer by sending a datagram with the data type field set to 0xFFFF.\n\nOnce all necessary command files, if any, have been sent to the client, the server terminates the synchronization operation\nby transmitting 4-bytes (DWORD) of 0x00000002 to the client, and the client acknowledges the synchronizations\nconclusion by replying with 4-bytes (DWORD) of 0x00000001. The server node terminates the communication channel\nwith the client.\n\nVisually, the sequence of events that make up the sync channel operations as viewed from the network perspective is\nillustrated in Figure 17-4.\n\n\n-----\n\n|Crawler Channel Activities SystemInfo Datagram SystemInfoEx Datagram Client’s Last Command ID (DWORD) Server’s Last Command ID (DWORD) Incoming File Tag (0x00000010) Command File Datagram Incoming File Tag (0x00000010) End of Command Files Tag (0x00000002) BACK to End of Command Files (0x00000001)|Col2|\n|---|---|\n\n\n###### Client Node Server Node\n\nCrawler Channel Activities\n\nSystemInfo Datagram\n\nSystemInfoEx Datagram\n\nClient’s Last Command ID (DWORD)\n\nServer’s Last Command ID (DWORD)\n\nIncoming File Tag (0x00000010)\n\nCommand File Datagram\n\nIncoming File Tag (0x00000010)\n\nEnd of Command Files Tag (0x00000002)\n\nBACK to End of Command Files (0x00000001)\n\n**Figure 17-4: Sync Channel Communication Activities**\n\n\n-----\n\n#### 17.2 Client Mode Thread\n\nThe client mode thread, as one would expect, is largely the reciprocal of the server mode thread. Effectively an endless\nloop of constantly connection to neighboring nodes, the client mode thread is responsible for synchronizing command\nfiles from the larger SJM1 botnet along with ensuring that the commands are bring properly executed.\n\nThe top of the endless loop begins with the client mode thread attempting to connect to a peer node. The client mode\nthread randomly selects a node from the seed nodes list and attempts to connect to the selected peer. If the connection is\nunsuccessful, a node from the known nodes list is randomly selected, and a connection is attempted. In the event that the\nconnection is also unsuccessful, the client mode thread sleeps for one minute before repeating the process again.\n\nWhen the client mode thread (in this context, making the SJM1 node the client node) attempts to locate a remote peer, it\ndoes so by connecting to the node to determine the validity of the IP and port information, as it immediately terminates\nthe connection if the connection is successful. Only after a node is validated as having an open port at the specified port\nnumber does the client node attempt to establish a lasting connection to the peer node. Once a connection has been\nestablished, the client initiates the authentication handshake. If the handshake fails, the connection is terminated, and\ncontrol returns to the top of the endless loop in order to find a new peer node.\n\nAfter the connection and authentication phase concludes, the client mode thread selects the appropriate channel based on\nits node type. If the node type, specified in the configuration file at offset 0, is greater than or equal to 0x1000000, then\nthe crawl channel (0x2000) is selected, and the node’s node type is set to 0x1000101. If the node’s node type is less than\n```\n       0x1000000, the client node requests the sync channel.\n\n```\nThe node type is adjusted periodically throughout the life span of a SJM1 node. Upon activation, the Initialize\nfunction specifies that the node’s node type is 0x1000101. As will be described later in this section, if during the\nroutability testing the peer node indicates that the client node is Internet-accessible, the node type is upgraded to\n```\n       0x101. While other values for the node type have been observed in the wild (most likely due to researchers attempting to\n\n```\ndistinguish themselves from legitimate SJM1 nodes), the SJM1 code supports only two node types:\n\n             - `0x101 for Internet-accessible (routable) nodes`\n\n             - `0x1000101 for NAT’d (non-routable) nodes`\n\nSince sync channel is built upon crawl channel, regardless of the node’s node type, the client node enters into the\nroutability test as described previously in Section 17.1.1. From the client node’s perspective, the routability test begins with\nthe client node transmitting a 6-byte data structure to the server node containing the 4-byte (DWORD) value and a 2-byte\n(WORD) value. The 4-byte value specifies if the client node knows it is behind a NAT device and thus non-routable, and\nthe 2-byte value defines the client node’s listening port number. If the client node has already identified it is not NAT’d\n(offset 1340 of the configuration file is non-zero), the routability test phase concludes. Otherwise, the client node waits for\nthe peer node to send a 4-byte (DWORD) value indicating if the client node’s listening port is Internet-accessible or not.\nThe response from the peer is recorded directly into the configuration file (at offset 1340).\n\nIn the event that the peer node indicates that the client node’s listening port is inaccessible, the client node terminates\nits server mode thread by shutting down its listening port, randomly selects a new listening port, and starts a new server\nmode thread. With a new server mode thread and listening port, the client node performs the routability test again. The\nprocess of shutting down the server mode thread and generating a new listening port can occur twice before the client\nnode concedes that it is inaccessible.\n\nThe results of the routability test may result in the node changing its node type. If a node is non-routable, its node type is\nset to 0x1000101, otherwise the node’s node type is adjusted to 0x101. After the routability test, the client node resets\nits routability status value (offset 1340 in the configuration file) back to 0, thereby forcing the routability test to commence\neach and every time it connects to a new peer node.\n\n\n-----\n\n|OFFSET|SIZE|FIELD DESCRIPTION|\n|---|---|---|\n|0|4 Bytes (DWORD)|IP address of node|\n|4|2 Bytes (WORD)|Listening port of node|\n|6|2 Bytes|Unused|\n|8|4 Bytes (DWORD)|Node’s tracking field 1|\n|12|4 Bytes (DWORD)|Node’s tracking field 2|\n|16|4 Bytes (DWORD)|Node’s type|\n|20|4 Bytes|Unused|\n|24|6 Bytes|MAC address|\n|30|2 Bytes|Unused|\n|32|16 Bytes (SYSTEMTIME structure)|Node’s activation time|\n|48|128 Bytes|Node’s actor remarks/campaign ID|\n\n\nThe client node receives the peer’s current time as an 8-byte value (a double) followed immediately by the peer’s\n50 known nodes list. The client node then calculates the difference between its local time and the server’s in order to\ndetermine the bias that must be applied when determining the age of any of the nodes the peer transmitted. Since the\npeer did successfully provide information, the peer is deemed a viable peer node to add to the client node’s seed list if it was\nnot there already by replacing the oldest node within the list. If the peer node is already within the client node’s seed list,\nthe last contact time is updated, thereby refreshing the node.\n\nThe client node scans the 50 nodes received from the peer node to determine which, if any, are newer than the client\nnode’s own seed list nodes. Each node has its timestamp recalculated by applying the bias value before determining if the\noldest node within the client’s seed list is newer than the received node. Should it turn out that the node is newer, the seed\n_list node is replaced. The process repeats for each of the 50 nodes. It is therefore entirely possible for a client node to have_\nall but one of its seed list entries replaced in full by a peer’s node list if the client node had lost contact with the SJM1 botnet\nfor a long enough period of time.\n\nIf the client node opens the sync channel instead of the crawl channel, the client node constructs and then transmits\nto the peer node via datagrams both the ClientInfo and ClientInfoEx data structures. The ClientInfo data\nstructure, as defined in Table 17-8, is the product of the client mode thread merging components of the configuration data\nstructure into the ClientInfo form.\n\n**OFFSET** **SIZE** **FIELD DESCRIPTION**\n\n0 4 Bytes (DWORD) IP address of node\n\n4 2 Bytes (WORD) Listening port of node\n\n6 2 Bytes Unused\n\n8 4 Bytes (DWORD) Node’s tracking field 1\n\n12 4 Bytes (DWORD) Node’s tracking field 2\n\n16 4 Bytes (DWORD) Node’s type\n\n20 4 Bytes Unused\n\n24 6 Bytes MAC address\n\n30 2 Bytes Unused\n\n32 16 Bytes (SYSTEMTIME structure) Node’s activation time\n\n48 128 Bytes Node’s actor remarks/campaign ID\n\n**Table 17-8: SierraJuliett-MikeOne’s ClientInfo Data Structure**\n\nThe ClientInfoEx data structure, Table 17-9, requires more processing to produce than its smaller sibling. The client\nmode thread leverages both Windows API functions such as GetLocaleInfo, GetVersionEx, GetComputerName,\nand GetDiskFreeSpaceEx as well as processor level instructions such as cpuid in order to construct the\n```\n       ClientInfoEx information. The interesting ports field (offset 280) is the product of determining if specific ports are\n\n```\nlistening for connections on the local machine, but not as a result of the SJM1 node listening on a given port. For example,\nif port 80 responds to a connect request, the interesting ports bitmask is set to indicate the port is listening. However, if\nthe SJM1 node is configured to listen on port 80, the bitmask field is not set.\n\n\n-----\n\n|OFFSET|SIZE|FIELD DESCRIPTION|\n|---|---|---|\n|0|64 Bytes|Computer name|\n|64|6 Bytes|MAC address|\n|70|2 Bytes|Unused|\n|72|64 Bytes|CPU brand (reported by CPUID)|\n|136|16 Bytes|CPU’s vendor ID (reported by CPUID)|\n|152|4 Bytes (DWORD)|CPU’s model and stepping (reported by CPUID)|\n|156|4 Bytes (DWORD)|CPU’s features bitmask (reported by CPUID)|\n|160|4 Bytes (DWORD)|CPU’s signature|\n|164|4 Bytes (DWORD)|Number of processors|\n|168|4 Bytes (DWORD)|CPU’s type|\n|172|4 Bytes (DWORD)|CPU’s clock speed|\n|176|64 Bytes|Computer’s locale string|\n|240|4 Bytes (DWORD)|OS’s major version|\n|244|4 Bytes (DWORD)|OS’s minor version|\n|248|4 Bytes (DWORD)|OS’s build number|\n|252|4 Bytes (DWORD)|OS’s platform ID|\n|256|16 Bytes (SYSTEMTIME structure)|Computer’s uptime|\n|272|8 Bytes (QWORD)|Total number of free bytes on the computer’s %WINDIR% hard drive|\n|280|1 Byte|Bitmask of interesting ports in use 0x01 – Port 80 0x02 – Port 3389 0x04 – Port 443|\n|281|1 Byte|Unused|\n|282|2 Bytes|Number of users on the computer in an idle state|\n|284|2 Bytes|Number of logged in users on the computer|\n|286|32 Bytes (16 WORDs)|Array of terminal server sessions’ connection states.|\n|318|2 Bytes|Unused|\n\n\n**OFFSET** **SIZE** **FIELD DESCRIPTION**\n\n0 64 Bytes Computer name\n\n64 6 Bytes MAC address\n\n70 2 Bytes Unused\n\n72 64 Bytes CPU brand (reported by CPUID)\n\n136 16 Bytes CPU’s vendor ID (reported by CPUID)\n\n152 4 Bytes (DWORD) CPU’s model and stepping (reported by CPUID)\n\n156 4 Bytes (DWORD) CPU’s features bitmask (reported by CPUID)\n\n160 4 Bytes (DWORD) CPU’s signature\n\n164 4 Bytes (DWORD) Number of processors\n\n168 4 Bytes (DWORD) CPU’s type\n\n172 4 Bytes (DWORD) CPU’s clock speed\n\n176 64 Bytes Computer’s locale string\n\n240 4 Bytes (DWORD) OS’s major version\n\n244 4 Bytes (DWORD) OS’s minor version\n\n248 4 Bytes (DWORD) OS’s build number\n\n252 4 Bytes (DWORD) OS’s platform ID\n\n256 16 Bytes (SYSTEMTIME structure) Computer’s uptime\n\n272 8 Bytes (QWORD) Total number of free bytes on the computer’s %WINDIR% hard drive\n\nBitmask of interesting ports in use\n0x01 – Port 80\n\n280 1 Byte\n\n0x02 – Port 3389\n0x04 – Port 443\n\n281 1 Byte Unused\n\n282 2 Bytes Number of users on the computer in an idle state\n\n284 2 Bytes Number of logged in users on the computer\n\n286 32 Bytes (16 WORDs) Array of terminal server sessions’ connection states.\n\n318 2 Bytes Unused\n\n**Table 17-9: SierraJuliett-MikeOne’s ClientInfoEx Data Structure**\n\nThe synchronization process begins by the client node sending its last command ID to the peer node and then receiving\nthe peer node’s last command ID. If the peer node has a last command ID that is larger than the client node’s, the client\nnode expects to receive an unknown number of command files from the peer as described previously in Section 17.1.3.\nImmediately prior to beginning the command file transfer, the client mode thread changes the last command ID in the\nnode’s configuration to match the value specified by the peer node.\n\nFor each command file the client node receives, the client mode thread saves the command file to the %SYSDIR%\\1008\ndirectory with a filename taking the pattern reg{4 digit value} before parsing the contents of the file. While the order of\nthe command IDs received by a node is indeterminate, the naming scheming has a definite order with each received file\nbeing stored with a file name one digit higher than the previous file. The timestamp of command files, when saved to disk,\nis set to a random date within 1 to 4 years from the current year.\n\n\n-----\n\n|COMMAND NUMBER|DESCRIPTION|\n|---|---|\n|0x4006|Downloads a file from the client node.|\n|0x4007|NOP|\n|0x4008|Executes the file within the data field, then deletes it.|\n|0x4009|NOP|\n|0x400A|Starts a process.|\n|0x400B|Set the actor’s remarks/campaign ID (offset 28) within the configuration data structure.|\n|0x400C|Deletes a file or directory (if the name specified is a directory).|\n|0x400D|Moves (or renames) file.|\n|0x400E|Creates a directory.|\n|0x400F|Terminates process by name.|\n|0x4010|Resets the last command ID to 0|\n|0x4011|Deletes all command files under the %SYSDIR%\\1008 directory.|\n|0x4012|Replaces the first NodeInfo entry in the seed node list.|\n|0x4013|Sets three configuration values (offsets 888, 1148, and 1212).|\n\n\nThe client mode thread begins the process of parsing a command file immediately after the file is saved to the node’s hard\ndrive. The encrypted command header (offset 0) is read into memory and decrypted using the public RSA key hard coded\nwithin the SJM1 binary. To verify successful decryption, the first field of the decrypted header (offset 0) is compared to\n```\n       0xB4F4. A memory buffer of the size specified by the data header size value (offset 12) is allocated and the contents of the\n\n```\ndata header are read into memory. SJM1 has the capability to selectively run commands based on the node type value.\nOffsets 1 and 2 within the data header specify the node types that will execute the given command within the command\nfile. If the data header specifies that the node’s node type is not to execute the command, the processing of the command\nfile concludes, and the next file, if any, is loaded and parsed.\n\nThe data portion of the command file, if the command type is not 0x4006, is saved to disk within the %SYSDIR%\\1008\ndirectory with a name of the form rundll{4 digit value}.exe. If the verify file flag (field 10 of the command header) is set,\nthe client thread reads all but the last 128 bytes of the command file into memory, performs a MD5 hash of the content,\ndecrypts the last 128 bytes of the command file to reveal the expected MD5 hash, and then compares the hash values. If\nthey do not match, the command file is considered invalid, and parsing of the file terminates. The client mode thread then\nmoves to the next command file. The fact that invalid command files are not removed from the command file directory\nmeans that invalid command files propagate throughout the SJM1 botnet, potentially leaving a considerable amount of\nnoise. This behavior was observed when the SJM1 botnet was enumerated in June 2015 by Novetta.\n\nThe client mode thread supports only a subset of the commands found within the RAT channel, but the command\nnumbers are identical to the list found in Table 17-4. The client mode supports the commands in Table 17-10.\n\n**COMMAND NUMBER** **DESCRIPTION**\n\n0x4006 Downloads a file from the client node.\n\n0x4007 NOP\n\n0x4008 Executes the file within the data field, then deletes it.\n\n0x4009 NOP\n\n0x400A Starts a process.\n\n0x400B Set the actor’s remarks/campaign ID (offset 28) within the configuration data structure.\n\n0x400C Deletes a file or directory (if the name specified is a directory).\n\n0x400D Moves (or renames) file.\n\n0x400E Creates a directory.\n\n0x400F Terminates process by name.\n\n0x4010 Resets the last command ID to 0\n\n0x4011 Deletes all command files under the %SYSDIR%\\1008 directory.\n\n0x4012 Replaces the first NodeInfo entry in the seed node list.\n\n0x4013 Sets three configuration values (offsets 888, 1148, and 1212).\n\n**Table 17-10: Client Mode Thread Supported Command Types**\n\nAfter the peer node transfers the last of the command files to the client node, the peer node sends a 4-byte (DWORD)\nvalue of 0x00000002 to the client node indicating the completion of the transfer. The client node only reads the\nlast byte (0x02) to determine if the transfer is complete but returns a 4-byte (DWORD) value of 0x00000001 as an\nacknowledgement of the completion of the transfer before disconnecting from the peer node.\n\nThere is no verification that a command’s execution is successful. Coupled with the fact that the node’s last command\nID is updated prior to receiving even the first command file from the peer node, this can lead to schisms within the SJM1\n\n\n-----\n\nbotnet. Take for example a new node joining the SJM1 botnet. A new node has a last command ID of 0. If the first peer that\nthe new node connects with were to have a last command ID of 65000, then the new node would immediately change its\nlast command ID to 65000 to match. If the transfer of command files is error-prone due to network instability and some\nor all of the command files fail to transfer correctly, the new node would still retain the last command ID value of 65000.\nGoing forward, when a node attempts to synchronize command files with the new node, the new node would report\n65000 as its last command ID but would provide an incomplete set of command files to the requesting node. This error\ncould therefore propagate unchecked throughout large sections of the SJM1 botnet.\n\nRegardless of the validity of command file transfer, once the client mode thread has disconnected from a peer, the thread\nenters a sleep period. The duration of the sleep varies depending on the number of times the client node has repeated the\nendless loop. The first 30 cycles through the loop will result in a sleep period of 30 minutes per cycle while any cycle after\nthe initial 30 will cause a 2-hour sleep.\n\n\n-----\n\n|COMMAND ID|SHA256 HASH OF COMMAND FILE’S DATA SECTION|\n|---|---|\n|2|9b03695ca0945995ec6e2bc31662c08b0f499998dcbcd51701bf03add19f1000|\n|10|e8d1d9d6bb13a06fc893323a05063c868ba237b8729c120271384382eb60ed41|\n|12|e8d1d9d6bb13a06fc893323a05063c868ba237b8729c120271384382eb60ed41|\n|200|2e20410ce8369572beee811f1898f6bc5c6782083aa1cc8e6dacc07b3fd392c9|\n|210|3ee8fa11b85ec7a3e1f3cf3cee2553f795c56610091e373d4a7df344a66ae35d|\n|300|7c55af4675cf0a3d173cb4e1b9282425c6e00b6ccfad1a1bcb0fddf29631461e|\n|1000|7c55af4675cf0a3d173cb4e1b9282425c6e00b6ccfad1a1bcb0fddf29631461e|\n|1010|7c55af4675cf0a3d173cb4e1b9282425c6e00b6ccfad1a1bcb0fddf29631461e|\n|1050|231af2bfa36b6b0d2e892fbba967062eb0b421ee4f7126709c51adb564d0c5a2|\n|1100|a64cb2496fb1ef1adf9b5473e664dc1d124634233dd76b4d8fb5aa8d970742b5|\n|1200|191e14e54cae4b33c077065b782a7161f0fd807a550a98fd1dac2db2b622c94c|\n|1205|f340bb3c2d175e027351319573ddc451b632defe9dc47bbc30eabf62f749fb46|\n|3000|f340bb3c2d175e027351319573ddc451b632defe9dc47bbc30eabf62f749fb46|\n|3500|1fd96cc95ec3f48e97cfcd08bb15d4dd30c11a5b582776dfa15f1a2e2b4ed94e|\n|3501|1200c02da0d6505a841f140f6d1947f1ae43a13664ec65b356b273c75f42713b|\n|8000|81c87a5a67963eab5193d342781e6b65604f7af74dd5cf7da960d20074da06b5|\n|8050|2d8e052bb93839dffe77b45be4418f64eeae35a7470a3c20827bae914dc1c7e4|\n|10000|6ce54331e126fd18c94e854a5e7fe3650a125cc83604f1a27a28f383e5193c07|\n|10000|c1820cc86b5cca32d9b09a191a9461552f1f4477d427270e7440bd9d03737a64|\n|10000|d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf|\n|10001|1dfe016ae106feb6112fd689faeaa1d61c19a911493a4201fb510551364f7247|\n|10010|5ccfbeba9aa0f05d2dd4006afd7769f2e186dd321b521617a469936de89aa9a7|\n|10010|1b78ffb5e6a6e3a98baf433d1932d8b3e4907acb1fd27501f799cb2966c1395e|\n|10011|1b78ffb5e6a6e3a98baf433d1932d8b3e4907acb1fd27501f799cb2966c1395e|\n|30000|d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf|\n|30001|d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf|\n|50000|d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf|\n|50001|d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf|\n|60000|d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf|\n|60001|d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf|\n|62001|d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf|\n\n\n#### 17.3 Known SierraJuliett-MikeOne Command Files\n\nIn mid-2015, the SJM1 botnet was enumerated by Novetta to determine the current state of the command file distribution.\nThe SJM1 botnet appears to be fractured and in disrepair. A large number of nodes have incomplete command file sets,\nextremely old (greater than 90 days) NodeInfo entries, or multiple corrupt command files. No single node appeared to\nhave a complete set of command files. It was possible, however, to reconstruct the majority of the command file set by\nenumerating all command files from all nodes and identify unique, valid command files. All command files contained\ncommands to execute a file contained within their data section. Table 17-11 maps the command ID to the embedded\nexecutable found within the command file’s data field. Table 17-12 maps the command ID to the compile date of and type\nof executable found within the data section.\n\n**COMMAND ID** **SHA256 HASH OF COMMAND FILE’S DATA SECTION**\n\n2 **9b03695ca0945995ec6e2bc31662c08b0f499998dcbcd51701bf03add19f1000**\n\n10 **e8d1d9d6bb13a06fc893323a05063c868ba237b8729c120271384382eb60ed41**\n\n12 **e8d1d9d6bb13a06fc893323a05063c868ba237b8729c120271384382eb60ed41**\n\n200 **2e20410ce8369572beee811f1898f6bc5c6782083aa1cc8e6dacc07b3fd392c9**\n\n210 **3ee8fa11b85ec7a3e1f3cf3cee2553f795c56610091e373d4a7df344a66ae35d**\n\n300 **7c55af4675cf0a3d173cb4e1b9282425c6e00b6ccfad1a1bcb0fddf29631461e**\n\n1000 **7c55af4675cf0a3d173cb4e1b9282425c6e00b6ccfad1a1bcb0fddf29631461e**\n\n1010 **7c55af4675cf0a3d173cb4e1b9282425c6e00b6ccfad1a1bcb0fddf29631461e**\n\n1050 **231af2bfa36b6b0d2e892fbba967062eb0b421ee4f7126709c51adb564d0c5a2**\n\n1100 **a64cb2496fb1ef1adf9b5473e664dc1d124634233dd76b4d8fb5aa8d970742b5**\n\n1200 **191e14e54cae4b33c077065b782a7161f0fd807a550a98fd1dac2db2b622c94c**\n\n1205 **f340bb3c2d175e027351319573ddc451b632defe9dc47bbc30eabf62f749fb46**\n\n3000 **f340bb3c2d175e027351319573ddc451b632defe9dc47bbc30eabf62f749fb46**\n\n3500 **1fd96cc95ec3f48e97cfcd08bb15d4dd30c11a5b582776dfa15f1a2e2b4ed94e**\n\n3501 **1200c02da0d6505a841f140f6d1947f1ae43a13664ec65b356b273c75f42713b**\n\n8000 **81c87a5a67963eab5193d342781e6b65604f7af74dd5cf7da960d20074da06b5**\n\n8050 **2d8e052bb93839dffe77b45be4418f64eeae35a7470a3c20827bae914dc1c7e4**\n\n10000 **6ce54331e126fd18c94e854a5e7fe3650a125cc83604f1a27a28f383e5193c07**\n\n10000 **c1820cc86b5cca32d9b09a191a9461552f1f4477d427270e7440bd9d03737a64**\n\n10000 **d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf**\n\n10001 **1dfe016ae106feb6112fd689faeaa1d61c19a911493a4201fb510551364f7247**\n\n10010 **5ccfbeba9aa0f05d2dd4006afd7769f2e186dd321b521617a469936de89aa9a7**\n\n10010 **1b78ffb5e6a6e3a98baf433d1932d8b3e4907acb1fd27501f799cb2966c1395e**\n\n10011 **1b78ffb5e6a6e3a98baf433d1932d8b3e4907acb1fd27501f799cb2966c1395e**\n\n30000 **d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf**\n\n30001 **d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf**\n\n50000 **d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf**\n\n50001 **d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf**\n\n60000 **d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf**\n\n60001 **d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf**\n\n62001 **d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf**\n\n**Table 17-11: Command IDs and the SHA256 of Their Dropped Files**\n\n\n-----\n\n|COMMAND ID|TYPE|COMPILATION DATE|NOTES|\n|---|---|---|---|\n|2|IndiaWhiskey|7/29/2011 6:29||\n|10|IndiaJuliett|7/26/2011 1:08|Installs SierraJuliett-MikeOne|\n|12|IndiaJuliett|7/26/2011 1:08|Installs SierraJuliett-MikeOne|\n|200|IndiaJuliett|8/23/2011 3:13|Installs IndiaJuliett and SierraBravo|\n|210|IndiaJuliett|9/14/2011 5:54|Installs IndiaJuliett|\n|300|IndiaJuliett|11/30/2011 1:55|Installs SierraJulietta-MikeTwo|\n|1000|IndiaJuliett|11/30/2011 1:55|Installs SierraJulietta-MikeTwo|\n|1010|IndiaJuliett|11/30/2011 1:55|Installs SierraJulietta-MikeTwo|\n|1050|IndiaJuliett|11/30/2011 16:34|Installs SierraJulietta-MikeTwo|\n|1100|IndiaJuliett|11/30/2011 17:06|Installs SierraJulietta-MikeTwo|\n|1200|IndiaJuliett|12/1/2011 12:24|Installs SierraJulietta-MikeTwo|\n|1205|UniformJuliett|12/4/2011 3:48||\n|3000|UniformJuliett|12/4/2011 3:48||\n|3500|IndiaJuliett|12/5/2011 10:42|Installs SierraJulietta-MikeTwo|\n|3501|IndiaJuliett|12/5/2011 12:18|Installs SierraJulietta-MikeTwo|\n|8000|IndiaJuliett|1/5/2012 4:02|Installs SierraJulietta-MikeTwo|\n|8050|TangoCharlie|1/8/2012 1:01||\n|10000|IndiaHotel|12/4/2012 7:30|Multiple valid hashes for the same command ID|\n|10000|IndiaHotel|4/3/2013 11:26|Multiple valid hashes for the same command ID|\n|10000|IndiaHotel|12/4/2012 7:30|Multiple valid hashes for the same command ID|\n|10001|IndiaHotel|4/3/2013 11:26||\n|10010|IndiaHotel|3/29/2012 15:23|Multiple valid hashes for the same ID|\n|10010|IndiaHotel|4/3/2012 0:29|Multiple valid hashes for the same ID|\n|10011|IndiaHotel|4/3/2012 0:29||\n|30000|IndiaHotel|12/4/2012 7:30||\n|30001|IndiaHotel|12/4/2012 7:30||\n|50000|IndiaHotel|12/4/2012 7:30||\n|50001|IndiaHotel|12/4/2012 7:30||\n|60000|IndiaHotel|12/4/2012 7:30||\n|60001|IndiaHotel|12/4/2012 7:30||\n|62001|IndiaHotel|12/4/2012 7:30||\n\n\n**COMMAND ID** **TYPE** **COMPILATION DATE** **NOTES**\n\n2 IndiaWhiskey 7/29/2011 6:29\n\n10 IndiaJuliett 7/26/2011 1:08 Installs SierraJuliett-MikeOne\n\n12 IndiaJuliett 7/26/2011 1:08 Installs SierraJuliett-MikeOne\n\n200 IndiaJuliett 8/23/2011 3:13 Installs IndiaJuliett and SierraBravo\n\n210 IndiaJuliett 9/14/2011 5:54 Installs IndiaJuliett\n\n300 IndiaJuliett 11/30/2011 1:55 Installs SierraJulietta-MikeTwo\n\n1000 IndiaJuliett 11/30/2011 1:55 Installs SierraJulietta-MikeTwo\n\n1010 IndiaJuliett 11/30/2011 1:55 Installs SierraJulietta-MikeTwo\n\n1050 IndiaJuliett 11/30/2011 16:34 Installs SierraJulietta-MikeTwo\n\n1100 IndiaJuliett 11/30/2011 17:06 Installs SierraJulietta-MikeTwo\n\n1200 IndiaJuliett 12/1/2011 12:24 Installs SierraJulietta-MikeTwo\n\n1205 UniformJuliett 12/4/2011 3:48\n\n3000 UniformJuliett 12/4/2011 3:48\n\n3500 IndiaJuliett 12/5/2011 10:42 Installs SierraJulietta-MikeTwo\n\n3501 IndiaJuliett 12/5/2011 12:18 Installs SierraJulietta-MikeTwo\n\n8000 IndiaJuliett 1/5/2012 4:02 Installs SierraJulietta-MikeTwo\n\n8050 TangoCharlie 1/8/2012 1:01\n\n10000 IndiaHotel 12/4/2012 7:30 Multiple valid hashes for the same command ID\n\n10000 IndiaHotel 4/3/2013 11:26 Multiple valid hashes for the same command ID\n\n10000 IndiaHotel 12/4/2012 7:30 Multiple valid hashes for the same command ID\n\n10001 IndiaHotel 4/3/2013 11:26\n\n10010 IndiaHotel 3/29/2012 15:23 Multiple valid hashes for the same ID\n\n10010 IndiaHotel 4/3/2012 0:29 Multiple valid hashes for the same ID\n\n10011 IndiaHotel 4/3/2012 0:29\n\n30000 IndiaHotel 12/4/2012 7:30\n\n30001 IndiaHotel 12/4/2012 7:30\n\n50000 IndiaHotel 12/4/2012 7:30\n\n50001 IndiaHotel 12/4/2012 7:30\n\n60000 IndiaHotel 12/4/2012 7:30\n\n60001 IndiaHotel 12/4/2012 7:30\n\n62001 IndiaHotel 12/4/2012 7:30\n\n**Table 17-12: Command File Payload Types and Their Compile Dates**\n\nTable 17-12 identifies some interesting irregularities within the command file set. For instance, there are three valid 10000\ncommand ID numbers and two valid 10010 command ID numbers. This would indicate that the attackers utilizing the\nSJM1 botnet introduced multiple files with the same command ID which would result in potential inconsistency in the\ncommands executed across the botnet. Command IDs 30000 and higher all distribute the same executable (an IndiaHotel\ninstaller). It is unclear why the attackers would continually redistribute the same executable.\n\nThe command file set does reveal a definite shift from SJM1 to SJM2. This is evidenced first by the fact that the IndiaJuliett\nfiles deployed across the botnet switch to the distribution of SJM2 instead of SJM1, and also by the fact that on two\ndifferent occasions the attackers drop and execute UniformJuliett binaries.\n\n\n-----\n\n### 18. [P2P Staging] SierraJuliett-MikeTwo (Joanap Mk. II)\n\nSierraJuliett-MikeTwo (SJM2) has an incredibly similar structure as SierraJuliett-MikeOne (SJM1) but has no code (at the\nbinary level) overlap. SJM2 is a complete rewrite of the concept seen with SJM1. Novetta observed the SJM2 malware as\nthe payload of several IndiaJuliett samples that were introduced by SJM1 during its operational run. Installed as a svchost-\ndependent service, SJM2’s binary is a DLL with the common ServiceMain function as its only export.\n\nOne of the most notable difference between SJM2 and SJM1 is the location of the configuration and seed list information.\nSJM2 stores its persistent data within the victim’s registry at two different locations: HKLM\\SOFTWARE\\Microsoft\\\n```\n       DbgJITDebugLaunchSetting\\00000000 for the configuration data and HKLM\\SOFTWARE\\\\Microsoft\\\n       DbgManagedDebugger\\00000000 for the peer list. The second most notable difference between the SierraJuliett\n\n```\nfamilies is the coding structure. Structurally, SJM2 differs from SJM1 by its heavy use of C++ instead of C. The bulk of the\nfunctionality of SJM2 is encapsulated in a set of C++ classes. While on the one hand the use of C++ classes provides clear\ndelineation between the malware’s various features, the use of C++ requires additional overhead for the developer. The\nimplementation of SJM2 through C++ class objects suggests the malware was written by a developer with a more academic\napproach to coding when compared to SJM1, which has a style suggesting a more task-centric developer.\n\nThe communication protocol of SJM2 is incompatible with the protocol of SJM1. The incompatibility between the two\nindicates that SJM2 is not an evolutionary enhancement of SJM1 but a separate entity that must maintain its own network.\n\n\n-----\n\n## 19. [Webserver] HotelAlfa\n\nHotelAlfa is a stripped down HTTP server that hosted the Guardians of Peace (GOP) hackers’ webpage announcing their\ndemands against SPE as well as the locations of the data that the GOP attackers stole. Consisting of only 4 functions,\nHotelAlfa is an extremely simple piece of code and is clearly created for a limited purpose.\n\nUpon activation, HotelAlfa attempts to bind a listening socket to port 80 on the victim’s machine. If port 80 is\nunavailable, HotelAlfa attempts to shutdown services (via a call to the API function StopService) in order to free up\nport 80 before attempting another bind operation. HotelAlfa attempts to stop the following services:\n\n             - **W3SVC – IIS service**\n```\n        • WMServer – Windows Media Service\n        • SSIS – SQL Server Integration Service\n        • SSRS – SQL Server Reporting Service\n        • MSDEPSVC – Web Deployment Agent Service\n\n```\nFor each incoming connection, HotelAlfa spins off a new thread to handle the request. The thread reads up to 4096\nbytes from the client and scans the response for specific keywords. The request from the client does not necessarily need\nto conform or comply with the HTTP request standard. Instead, the request merely must contain the appropriate file\nextension otherwise the default HTML page is returned. HotelAlfa responds to .wav and .jpg file extensions with the\nappropriate file.\n\nHotelAlfa only supplies three files to the client: an HTML page, a WAV sound file, and a JPG image. These files are stored\nwithin the HotelAlfa binary’s resource section under the RC_DATA branch. Each file is encoded with XOR 0x63, requiring\nHotelAlfa to decode each file prior to transmitting the data back to the requesting client. When HotelAlfa sends a\nresponse back to the client, the response does conform to the HTTP 1.1 standard.\n\n\n-----\n\n|RESOURCE NAME|FILE DETAILS|\n|---|---|\n|RSRC_HTML|HTML code for the #GOP webpage. Contains links to a warning to SPE along with URLs to leaked SPE data.|\n|RSRC_JPG|Background image for the #GOP webpage, seen here:|\n|RSRC_WAV|WAV sound file of gun shots that plays on the #GOP webpage in a loop.|\n\n\nTable 19-1 describes each of the three files that HotelAlfa returns to the requesting client.\n\n**RESOURCE NAME** **FILE DETAILS**\n\nHTML code for the #GOP webpage. Contains links to a warning to SPE along with URLs to leaked\nRSRC_HTML\nSPE data.\n\nBackground image for the #GOP webpage, seen here:\n\nRSRC_JPG\n\nRSRC_WAV WAV sound file of gun shots that plays on the #GOP webpage in a loop.\n\n**Table 19-1: The Locations within the Resource Section of HotelAlfa and the Description of the Various File the Malware Serves to Users**\n\n\n-----\n\n## 20. Conclusion\n\nThe Lazarus Group employs a variety of RATs and staging malware to conduct cyber operations, many of which contain\nsignificant code overlap that points to at least a shared development environment. The development of these families\nalso emphasizes the resources and organization of the Lazarus Group. The SierraJuliett families, for instance, provides\na common operating environment that effectively allows operators of any technical skill to access victim networks.\nAdditionally, the Romeo-CoreOne-based families essentially acts as a modular design platforms and further simplifies the\nprocess for developing custom, targeted, and effective RATs.\n\nWhile some members within the Romeo and Sierra groups may not implement sound authentication strategies, shift their\ndesign focus in abrupt and unusual manners, and fail to understand the pitfalls of distributed command networks, on the\nwhole the families within the Lazarus Group’s collection of RATs and staging malware perform their tasks with surprising\neffectiveness. As the maturity of the code base increases, so too does the effectiveness and design integrity of the malware\nfamilies employed by the Lazarus Group.\n\n\n-----\n\nMcLean, Virginia – Headquarters\n7921 Jones Branch Drive\n5th Floor\nMcLean, VA 22102\n\n**www.OperationBlockbuster.com**\n\nPhone: (571) 282-3000\nwww.novetta.com\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2016/2016.02.24.Operation_Blockbuster/Operation-Blockbuster-RAT-and-Staging-Report.pdf"
    ],
    "report_names": [
        "Operation-Blockbuster-RAT-and-Staging-Report"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "77b28afd-8187-4917-a453-1d5a279cb5e4",
            "created_at": "2022-10-25T15:50:23.768278Z",
            "updated_at": "2025-03-27T02:00:55.5423Z",
            "deleted_at": null,
            "main_name": "Inception",
            "aliases": [
                "Inception Framework",
                "Cloud Atlas"
            ],
            "source_name": "MITRE:Inception",
            "tools": [
                "PowerShower",
                "VBShower",
                "LaZagne"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d18fe42c-8407-4f96-aee0-a04e6dce219a",
            "created_at": "2023-01-06T13:46:38.275292Z",
            "updated_at": "2025-03-27T02:00:02.79092Z",
            "deleted_at": null,
            "main_name": "APT12",
            "aliases": [
                "Calc Team",
                "IXESHE",
                "BRONZE GLOBE",
                "BeeBus",
                "DynCalc",
                "DNSCalc",
                "Crimson Iron",
                "NUMBERED PANDA",
                "TG-2754",
                "Group 22"
            ],
            "source_name": "MISPGALAXY:APT12",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "6a660ea2-1118-404a-9f8f-f0d6a1e9f184",
            "created_at": "2022-10-25T15:50:23.685924Z",
            "updated_at": "2025-03-27T02:00:55.52357Z",
            "deleted_at": null,
            "main_name": "APT12",
            "aliases": [
                "APT12",
                "IXESHE",
                "DynCalc",
                "Numbered Panda",
                "DNSCALC"
            ],
            "source_name": "MITRE:APT12",
            "tools": [
                "Ixeshe",
                "RIPTIDE",
                "HTRAN"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "bbefc37d-475c-4d4d-b80b-7a55f896de82",
            "created_at": "2022-10-25T15:50:23.571783Z",
            "updated_at": "2025-03-27T02:00:55.502112Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "BRONZE BUTLER",
                "REDBALDKNIGHT"
            ],
            "source_name": "MITRE:BRONZE BUTLER",
            "tools": [
                "Mimikatz",
                "build_downer",
                "cmd",
                "ABK",
                "at",
                "BBK",
                "schtasks",
                "down_new",
                "Daserf",
                "ShadowPad",
                "Windows Credential Editor",
                "gsecdump"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "32a223a8-3c79-4146-87c5-8557d38662ae",
            "created_at": "2022-10-25T15:50:23.703698Z",
            "updated_at": "2025-03-27T02:00:55.528031Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Lazarus Group",
                "Labyrinth Chollima",
                "HIDDEN COBRA",
                "Guardians of Peace",
                "NICKEL ACADEMY",
                "Diamond Sleet"
            ],
            "source_name": "MITRE:Lazarus Group",
            "tools": [
                "RawDisk",
                "Proxysvc",
                "BADCALL",
                "FALLCHILL",
                "WannaCry",
                "HOPLIGHT",
                "TYPEFRAME",
                "Dtrack",
                "HotCroissant",
                "HARDRAIN",
                "Dacls",
                "KEYMARBLE",
                "TAINTEDSCRIBE",
                "AuditCred",
                "netsh",
                "ECCENTRICBANDWAGON",
                "AppleJeus",
                "BLINDINGCAN",
                "ThreatNeedle",
                "Volgmer",
                "Cryptoistic",
                "RATANKBA",
                "Bankshot",
                "Torisma",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "c5f79f58-db78-4cd7-88cf-c029a2199360",
            "created_at": "2022-10-25T16:07:23.325227Z",
            "updated_at": "2025-03-27T02:02:09.738383Z",
            "deleted_at": null,
            "main_name": "APT 12",
            "aliases": [
                "APT 12",
                "BeeBus",
                "Bronze Globe",
                "CTG-8223",
                "Calc Team",
                "Crimson Iron",
                "DNSCalc",
                "DynCALC",
                "Group 22",
                "Numbered Panda"
            ],
            "source_name": "ETDA:APT 12",
            "tools": [
                "AUMLIB",
                "ETUMBOT",
                "Exploz",
                "Graftor",
                "HIGHTIDE",
                "IHEATE",
                "IXESHE",
                "RIPTIDE",
                "RapidStealer",
                "Specfix",
                "THREEBYTE",
                "bbsinfo",
                "mswab",
                "yayih"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "9e767b38-12ae-4ef7-9878-5ce1701066d7",
            "created_at": "2024-05-01T02:03:08.131819Z",
            "updated_at": "2025-03-27T02:05:17.413497Z",
            "deleted_at": null,
            "main_name": "NICKEL ACADEMY",
            "aliases": [
                "COVELLITE ",
                "CTG-2460 ",
                "Diamond Sleet ",
                "Guardians of Peace",
                "HIDDEN COBRA ",
                "High Anonymous",
                "Labyrinth Chollima ",
                "NNPT Group",
                "New Romanic Cyber Army Team",
                "Temp.Hermit ",
                "The Lazarus Group ",
                "UNC577 ",
                "Who Am I?",
                "Whois Team",
                "ZINC ",
                "Black Artemis "
            ],
            "source_name": "Secureworks:NICKEL ACADEMY",
            "tools": [
                " DarkMessenger",
                " Destover",
                " Duuzer",
                " HOPLIGHT",
                " Joanap",
                " KorHigh",
                " LiveJinx",
                " Volgmer",
                "Brambul"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "8bc1a044-a23b-4904-903c-13f463605cb3",
            "created_at": "2024-05-01T02:03:08.136237Z",
            "updated_at": "2025-03-27T02:05:17.415795Z",
            "deleted_at": null,
            "main_name": "NICKEL GLADSTONE",
            "aliases": [
                "Bluenoroff ",
                "CTG-6459 ",
                "Citrine Sleet ",
                "HIDDEN COBRA ",
                "Lazarus Group",
                "Sapphire Sleet ",
                "Stardust Chollima ",
                "APT38 "
            ],
            "source_name": "Secureworks:NICKEL GLADSTONE",
            "tools": [
                " Bankshot",
                " CATCH22",
                " CCGC_Proxy",
                " Cur1Agent",
                " Ratankba",
                " Server_TrafficForwarder",
                " Wcry",
                "AlphaNC"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "e6e26922-3f4f-4243-9af5-cf9bea8b93bd",
            "created_at": "2022-10-25T16:47:55.577163Z",
            "updated_at": "2025-03-27T02:05:17.26824Z",
            "deleted_at": null,
            "main_name": "BRONZE GLOBE",
            "aliases": [
                "CTG-8223 ",
                "DNSCalc",
                "DyncCalc",
                "Numbered Panda ",
                "APT12 "
            ],
            "source_name": "Secureworks:BRONZE GLOBE",
            "tools": [
                " BeepService",
                " Etumbot",
                " Gh0st RAT",
                " Ixeshe",
                " Mswab",
                " RAdmin",
                " Seatran",
                " SvcInstaller",
                " Ziyang",
                "Badpuck"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a2b92056-9378-4749-926b-7e10c4500dac",
            "created_at": "2023-01-06T13:46:38.430595Z",
            "updated_at": "2025-03-27T02:00:02.831633Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Operation DarkSeoul",
                "APT38",
                "ATK117",
                "DEV-1222",
                "G0032",
                "APT 38",
                "Stardust Chollima",
                "APT-C-26",
                "ATK3",
                "Diamond Sleet",
                "Hidden Cobra",
                "Unit 121",
                "Subgroup: Bluenoroff",
                "NICKEL GLADSTONE",
                "DEV-0139",
                "Andariel",
                "Operation Troy",
                "COVELLITE",
                "TA404",
                "Lazarus group",
                "Dark Seoul",
                "G0082",
                "NewRomanic Cyber Army Team",
                "Bluenoroff",
                "Appleworm",
                "Nickel Academy",
                "COPERNICIUM",
                "Hastati Group",
                "Bureau 121",
                "Operation AppleJeus",
                "Whois Hacking Team",
                "Citrine Sleet",
                "Sapphire Sleet",
                "Group 77",
                "Labyrinth Chollima",
                "Operation GhostSecret",
                "BeagleBoyz"
            ],
            "source_name": "MISPGALAXY:Lazarus Group",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f32df445-9fb4-4234-99e0-3561f6498e4e",
            "created_at": "2022-10-25T16:07:23.756373Z",
            "updated_at": "2025-03-27T02:02:09.966155Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "APT-C-26",
                "ATK 3",
                "Appleworm",
                "Citrine Sleet",
                "DEV-0139",
                "Diamond Sleet",
                "Gleaming Pisces",
                "Gods Apostles",
                "Gods Disciples",
                "Group 77",
                "Guardians of Peace",
                "Hastati Group",
                "Hidden Cobra",
                "ITG03",
                "Jade Sleet",
                "Labyrinth Chollima",
                "Lazarus Group",
                "NewRomanic Cyber Army Team",
                "Operation 99",
                "Operation AppleJeus",
                "Operation AppleJeus sequel",
                "Operation Blockbuster: Breach of Sony Pictures Entertainment",
                "Operation CryptoCore",
                "Operation Dream Job",
                "Operation Dream Magic",
                "Operation Flame",
                "Operation GhostSecret",
                "Operation In(ter)caption",
                "Operation LolZarus",
                "Operation Marstech Mayhem",
                "Operation No Pineapple!",
                "Operation North Star",
                "Operation Phantom Circuit",
                "Operation Sharpshooter",
                "Operation Ten Days of Rain / DarkSeoul",
                "Operation Troy",
                "SectorA01",
                "Slow Pisces",
                "TA404",
                "TraderTraitor",
                "UNC2970",
                "UNC4034",
                "UNC4736",
                "UNC4899",
                "UNC577",
                "Whois Hacking Team"
            ],
            "source_name": "ETDA:Lazarus Group",
            "tools": [
                "3CX Backdoor",
                "3Rat Client",
                "3proxy",
                "AIRDRY",
                "ARTFULPIE",
                "ATMDtrack",
                "AlphaNC",
                "Alreay",
                "Andaratm",
                "AngryRebel",
                "AppleJeus",
                "Aryan",
                "AuditCred",
                "BADCALL",
                "BISTROMATH",
                "BLINDINGCAN",
                "BTC Changer",
                "BUFFETLINE",
                "BanSwift",
                "Bankshot",
                "Bitrep",
                "Bitsran",
                "BlindToad",
                "Bookcode",
                "BootWreck",
                "BottomLoader",
                "Brambul",
                "BravoNC",
                "Breut",
                "COLDCAT",
                "COPPERHEDGE",
                "CROWDEDFLOUNDER",
                "Castov",
                "CheeseTray",
                "CleanToad",
                "ClientTraficForwarder",
                "CollectionRAT",
                "Concealment Troy",
                "Contopee",
                "CookieTime",
                "Cyruslish",
                "DAVESHELL",
                "DBLL Dropper",
                "DLRAT",
                "DRATzarus",
                "DRATzarus RAT",
                "Dacls",
                "Dacls RAT",
                "DarkComet",
                "DarkKomet",
                "DeltaCharlie",
                "DeltaNC",
                "Dembr",
                "Destover",
                "DoublePulsar",
                "Dozer",
                "Dtrack",
                "Duuzer",
                "DyePack",
                "ECCENTRICBANDWAGON",
                "ELECTRICFISH",
                "Escad",
                "EternalBlue",
                "FALLCHILL",
                "FYNLOS",
                "FallChill RAT",
                "Farfli",
                "Fimlis",
                "FoggyBrass",
                "FudModule",
                "Fynloski",
                "Gh0st RAT",
                "Ghost RAT",
                "Gopuram",
                "HARDRAIN",
                "HIDDEN COBRA RAT/Worm",
                "HLOADER",
                "HOOKSHOT",
                "HOPLIGHT",
                "HOTCROISSANT",
                "HOTWAX",
                "HTTP Troy",
                "Hawup",
                "Hawup RAT",
                "Hermes",
                "HotCroissant",
                "HotelAlfa",
                "Hotwax",
                "HtDnDownLoader",
                "Http Dr0pper",
                "ICONICSTEALER",
                "Joanap",
                "Jokra",
                "KANDYKORN",
                "KEYMARBLE",
                "Kaos",
                "KillDisk",
                "KillMBR",
                "Koredos",
                "Krademok",
                "LIGHTSHIFT",
                "LIGHTSHOW",
                "LOLBAS",
                "LOLBins",
                "Lazarus",
                "LightlessCan",
                "Living off the Land",
                "MATA",
                "MBRkiller",
                "MagicRAT",
                "Manuscrypt",
                "Mimail",
                "Mimikatz",
                "Moudour",
                "Mydoom",
                "Mydoor",
                "Mytob",
                "NACHOCHEESE",
                "NachoCheese",
                "NestEgg",
                "NickelLoader",
                "NineRAT",
                "Novarg",
                "NukeSped",
                "OpBlockBuster",
                "PCRat",
                "PEBBLEDASH",
                "PLANKWALK",
                "POOLRAT",
                "PSLogger",
                "PhanDoor",
                "Plink",
                "PondRAT",
                "PowerBrace",
                "PowerRatankba",
                "PowerShell RAT",
                "PowerSpritz",
                "PowerTask",
                "Preft",
                "ProcDump",
                "Proxysvc",
                "PuTTY Link",
                "QUICKRIDE",
                "QUICKRIDE.POWER",
                "Quickcafe",
                "QuiteRAT",
                "R-C1",
                "ROptimizer",
                "Ratabanka",
                "RatabankaPOS",
                "Ratankba",
                "RatankbaPOS",
                "RawDisk",
                "RedShawl",
                "Rifdoor",
                "Rising Sun",
                "Romeo-CoreOne",
                "RomeoAlfa",
                "RomeoBravo",
                "RomeoCharlie",
                "RomeoCore",
                "RomeoDelta",
                "RomeoEcho",
                "RomeoFoxtrot",
                "RomeoGolf",
                "RomeoHotel",
                "RomeoMike",
                "RomeoNovember",
                "RomeoWhiskey",
                "Romeos",
                "RustBucket",
                "SHADYCAT",
                "SHARPKNOT",
                "SIGFLIP",
                "SIMPLESEA",
                "SLICKSHOES",
                "SORRYBRUTE",
                "SUDDENICON",
                "SUGARLOADER",
                "SheepRAT",
                "SierraAlfa",
                "SierraBravo",
                "SierraCharlie",
                "SierraJuliett-MikeOne",
                "SierraJuliett-MikeTwo",
                "SimpleTea",
                "SimplexTea",
                "SmallTiger",
                "Stunnel",
                "TAINTEDSCRIBE",
                "TAXHAUL",
                "TFlower",
                "TOUCHKEY",
                "TOUCHMOVE",
                "TOUCHSHIFT",
                "TOUCHSHOT",
                "TWOPENCE",
                "TYPEFRAME",
                "Tdrop",
                "Tdrop2",
                "ThreatNeedle",
                "Tiger RAT",
                "TigerRAT",
                "Trojan Manuscript",
                "Troy",
                "TroyRAT",
                "VEILEDSIGNAL",
                "VHD",
                "VHD Ransomware",
                "VIVACIOUSGIFT",
                "VSingle",
                "ValeforBeta",
                "Volgmer",
                "Vyveva",
                "W1_RAT",
                "Wana Decrypt0r",
                "WanaCry",
                "WanaCrypt",
                "WanaCrypt0r",
                "WannaCry",
                "WannaCrypt",
                "WannaCryptor",
                "WbBot",
                "Wcry",
                "Win32/KillDisk.NBB",
                "Win32/KillDisk.NBC",
                "Win32/KillDisk.NBD",
                "Win32/KillDisk.NBH",
                "Win32/KillDisk.NBI",
                "WinorDLL64",
                "Winsec",
                "WolfRAT",
                "Wormhole",
                "YamaBot",
                "Yort",
                "ZetaNile",
                "concealment_troy",
                "http_troy",
                "httpdr0pper",
                "httpdropper",
                "klovbot",
                "sRDI"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "c39b0fe6-5642-4717-9a05-9e94265e3e3a",
            "created_at": "2022-10-25T16:07:24.332084Z",
            "updated_at": "2025-03-27T02:02:10.175452Z",
            "deleted_at": null,
            "main_name": "Tonto Team",
            "aliases": [
                "Bronze Huntley",
                "CactusPete",
                "Earth Akhlut",
                "HartBeat",
                "Karma Panda",
                "LoneRanger",
                "Operation Bitter Biscuit",
                "TAG-74",
                "Tonto Team"
            ],
            "source_name": "ETDA:Tonto Team",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "Bioazih",
                "Bisonal",
                "CONIME",
                "Dexbia",
                "Korlia",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "Mimikatz",
                "POISONPLUG.SHADOW",
                "RoyalRoad",
                "ShadowPad Winnti",
                "XShellGhost"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716504,
    "ts_updated_at": 1743041843,
    "ts_creation_date": 0,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/5f86309e6544994a45536b0450cf1f5adef67296.pdf",
        "text": "https://archive.orkl.eu/5f86309e6544994a45536b0450cf1f5adef67296.txt",
        "img": "https://archive.orkl.eu/5f86309e6544994a45536b0450cf1f5adef67296.jpg"
    }
}