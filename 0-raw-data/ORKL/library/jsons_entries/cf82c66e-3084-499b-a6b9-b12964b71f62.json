{
    "id": "cf82c66e-3084-499b-a6b9-b12964b71f62",
    "created_at": "2023-01-12T15:05:54.928787Z",
    "updated_at": "2025-03-27T02:08:40.852201Z",
    "deleted_at": null,
    "sha1_hash": "dece0ed0f00f4eae82e826475765b25d27090437",
    "title": "2020-07-29 - Sodinokibi - REvil Malware Analysis",
    "authors": "",
    "file_creation_date": "2022-05-28T02:16:08Z",
    "file_modification_date": "2022-05-28T02:16:08Z",
    "file_size": 2161783,
    "plain_text": "# Sodinokibi / REvil Malware Analysis\n\n**blog.amossys.fr/sodinokibi-malware-analysis.html**\n\nThis article details the behavior of the Sodinokibi ransomware using static analysis with IDA Pro.\n\n\n-----\n\n## Introduction\n\nSodinokibi, also called REvil, is a ransomware active since april 2019. Older version have already been analysed, but Sodinokibi receives\n[frequent updates, tweaking its features and behavior. In this article we will be analysing a sample found during an Amossys CERT mission,](https://www.amossys.fr/fr/nos-prestations/cert/)\ncompiled in march 2020 according to the PE timestamp.\n\nThe purpose of this article is to detail how the malware works, and to provide reverse engineering tips when possible. No dynamic analysis\nwas conducted, as static reversing with IDA Pro proved sufficient.\n\n## Presentation of the malware\n\nSodinokibi is a \"Ransomware as a Service\" which means that the developers are not the one conducting attacks. Instead, they maintain a\nmanagement / payment infrastructure and give or sell the malware to customers. Thoses custormers are the one spreading the malware. For\neach ransom paid, developers get a percentage. This approach has many advantages: infections sources are multiplied, developers can focus\non the code and maintenance while customers can focus on attacking and infecting targets.\n\n[According to the cybersecurity blog Krebs on security, in june 2020, criminals behind Sodinokibi started selling stolen data if victims were not](https://krebsonsecurity.com/)\ninclined to pay the ransom .1 As data stealing features were not found in Sodinokibi, this lets suppose that infections are manual and targeted\nat already compromised system.\n\n## Sample information\n\n[We uploaded our sample to Virus Total to get signatures and information on the PE.](https://www.virustotal.com/)\n\nFigure 1: Virus Total score\n\nFigure 2: Sample Signatures\n\n## Obfuscated IAT\n\nRight after loading the PE into IDA, we notice that its imports table (IAT) is probably obfuscated. Two points can lead to this conclusion. First,\nIDA only detects 5 imported functions, which is way too few to do anything significant.\n\nFigure 3: IDA imports subview\nThen, the program calls dwords which do not seems to point to any valid function. Thoses dwords might be the obfuscated IAT.\n\nFigure 4: Unknown dwords calls\n\n\n-----\n\nFigure 5: Probable obfuscated IAT\nBefore being able to do anything, the malware has to deobfuscate its IAT. By looking into the first function we can spot the following loop,\nwhere `dword_40ff40 is a pointer to the start of the obfuscated IAT:`\n\nFigure 6: Deobfuscation loop\n```\nsub_406817 is used to resolve the unknown dwords into valid functions adresses. Here is how it works:\n\n```\nFigure 7: Dword resolution\n\n1. The obfuscated dword is transformed (with XOR and bit shifting). The new dword is splitted in 2. The 11 most significants bits designate\n\na DLL. The 21 least significant bits designate a function exported by this DLL\n2. The DLL corresponding to the 11 bits value is loaded into memory with the `LoadLibrary() function.`\n3. The name of each function exported by the library is hashed using a custom algorithm. The hash is compared to the 21 bits value. If they\n\nmatch, the obfuscated dword is replaced with the correct function address in memory.\n\nLet's see what all these steps look like in IDA Pro.\n\n## Hash transformation\n\nThe obfuscated dword (named `arg_iat_hash here) is tranformed with this line:`\n\nFigure 8: Obfuscated dword tranformation\n\n\n-----\n\n## Switch / Case\n\nHere, the switch / case statement is used to load a specific DLL depending on the `dll_hash variable. Switch / Case statements are often`\n\ncompiled to look like this:\n\nFigure 9: Compiled switch / case statement\nThe considered value (here `dll_hash ) get substracted and compared to 0 instead of being compared to direct values. Every compiler has its`\nown way to process conditional statements, but we have seen this one multiple times.\n\n## LoadLibrary()\n\nDLLs are loaded with the `LoadLibrary() function.`\n\nFigure 10: LoadLibrary() function hash\n```\nLoadLibrary() is exported by the Kernel32 library. So when LoadLibrary() itself needs to be resolved in the obfuscated IAT, Kernel32\n\n```\ncan not be loaded. Thanks to the few non-obfuscated functions (see Figure 3), Kernel32 is already loaded when the process starts up. When\n```\nLoadLibrary() must be resolved, the program looks into its Process Environment Block for loaded modules, and retrieve the adresse of\n\n```\nKernel32 with yet another hash mechanism.\n\nFigure 11: DLL retrieval from PEB structure\n\n\n-----\n\n## Function name and address resolution\n\nOnce the DLL address is known, the following code is executed:\n\nFigure 12: Unknown code\nThe offset 0x3C and 0x78 are noticeable for a PE file. 0x3C is the offset of the PE header and 0x78 is the offset of the\nIMAGE_DATA_DIRECTORY structure in this PE header. Data directories contain various information about the PE file. The first one (offset\n0x00 in the IMAGE_DATA_DIRECTORY) is the IMAGE_EXPORT_DIRECTORY, containing information about exported functions. Here is its\nlayout:\n```\nstruct _IMAGE_EXPORT_DIRECTORY\n{\n DWORD Characteristics;\n DWORD TimeDateStamp;\n WORD MajorVersion;\n WORD MinorVersion;\n DWORD Name;\n DWORD Base;\n DWORD NumberOfFunctions;\n DWORD NumberOfNames;\n DWORD AddressOfFunctions;\n DWORD AddressOfNames;\n DWORD AddressOfNameOrdinals;\n};\n\n```\nWe can import this structure in IDA and change the `v18 variable type. We now see which fields of the structure are accessed`\n\nFigure 13: Exported function access\nEach exported function name is then hashed and compared with the unknown hash. If they match, the unknown dword is replaced with the\ncorrect function address.\n\nFigure 14: Function hashes comparison\n\n## Function name hashing\n\nFunction names are hashed with the following code:\n\nFigure 15: Hash function\nThe `for loop as displayed by IDA decompiler may not be very clear. Here is an equivalent in python:`\n\n\n-----\n\n```\n result = 0x2B\n for c in fn_name:\n  result = ord(c) + 0x10F * result\n return result\n\n```\nThis hash function do not need to be very robust, as potential inputs are limited to function names from common DLL.\n\n## Automation\n\nNow that we understand the deobfuscation mechanism, we can rename every dword in the obfuscated IAT with the correct function name. The\n[OALabs team provides IDA scripts to automate this process especially for Sodinokibi. The first script2](https://oalabs.openanalysis.net/) builds hashes for functions in commonly\nused DLL. The second script3 compare every dword in the obfuscated IAT to the previously build hashes. If they match, the dword is renamed\nto the corresponding function name.\n\n\nAfter executing the scripts, functions are successfuly renamed. For exemple, here are dwords from Figure 4 resolved into `CreateMutexW()`\nand `RtlGetLastWin32Error() .`\n\nFigure 16: Resolved calls\n\n## Encrypted strings\n\nThe malware contains no meaningful strings. They might be obfuscated or encrypted. Let's take a look at the `CreateMutexW() call we just`\nresolved:\n\nFigure 17: Unknown mutex name\nHere, `v2 has to be a string containing the mutex name. It is only used in` `sub_4056E3(), a function that is called in many other places with`\n```\nunk_4101C0 as the first argument:\n\n```\nFigure 18: sub_4056E3 xrefs\nConsidering how frequently `sub_4056E3() is called, it is probably used to somehow initialize strings. By looking into it, we can find the`\nfollowing code:\n\n\n-----\n\nFigure 19: RC4 extract from binary\nWe notice two loops going from 0 to 255 (0x100 values). This scheme is characteristic of the RC4 encryption algorithm. Here is the equivalent\n[pseudo code taken from the RC4 Wikipedia page:](https://en.wikipedia.org/wiki/RC4)\n\nFigure 20: RC4 pseudocode\nRC4 needs to know the key, the data to encrypt or decrypt, and their respective size. We can rename `sub_4056E3() arguments as follow:`\n\nFigure 21: String decryption function arguments\n```\nunk_4101C0 (renamed ptr_to_enc_str ) is a pointer to a data blob containing encrypted strings and their decryption key. The next\n\n```\nargument is the offset to the key in the data blob. Then, the key and string sizes are given. The string offset in the blob is obtained by adding\nthe key offset and the key size. This means that the key and the corresponding string are adjacent in the data blob.\n\n## Automation\n\n[Here again, OAlabs provides a script4](https://oalabs.openanalysis.net/) to automate stings decryption. For each call to `sub_4056E3(), the script fetches the arguments and`\ndecrypt the string. The decrypted string is added as a comment next to the call. Here is the result for the mutex name:\n\nFigure 22: Decrypted mutex name\n\n## Concurrency checking\n\nIn the two previous parts (Obfuscated IAT and Encrypted Strings), we took as exemple a short snippet of code, where the malware opens a\nMutex and check if it already exist. This code is here to prevent two instances of the malware to run at the same time. Normally, the malware\nwas designed to prevent this, but if files get encrypted twice, the victim may not be able to recover them, even after paying the ransom.\nHowever, Sodinokibi authors seem to attach great importance to the data recovery rate. Here is a snippet of the payment instruction:\n\nIn Q2 2019, victims who paid for a decryptor recovered 92% of their encrypted data. This statistic varied dramatically depending on the\nransomware type.\n\nFor example, Ryuk ransomware has a relatively low data recovery rate, at ~ 87%, while Sodinokibi was close to 100%. \"\n\nNow you have a guarantee that your files will be returned 100 %.\n\nIf the malware has a low data recovery rate and acquires bad reputation, victims will be less inclined to pay, generating losses for the authors.\n\n\n-----\n\n## Privileges obtention\n\nThe malware needs administrators privileges to read and overwrite files on the system. Three tests are made to check if the malware has\nenough privileges:\n\nFigure 23: Privileges verification\nFirst, it checks if the Windows version is Windows XP or lower. Then, it checks if the process Token rights can be elevated or not. Finally, it\nchecks the process SID. If all of the tests fails (no administrator privileges), the malware will just spam the UAC prompt to get user consent:\n\nFigure 24: Infinit user consent request\nThe `ShellExecuteExW() function is used to execute a binary with given parameters. The` `runas command executes it as Administrator,`\nasking the user for consent. `ShellExecuteExW() is called in an infinite loop. An unaware user might say \"no\" multiple time before getting`\nannoyed and say \"yes\". Alternatively, the malware might be executed by an attacker already having administrator privileges on a compromised\nsystem.\n\n## Configuration\n\nAfter getting administrator privileges, the malware reads its JSON configuration. As the strings, the configuration is RC4 encrypted. It is\nembedded into a special section of the binary called `.11hix here. This name is probably changed with each version of the malware.`\n\nFigure 25: PE sections names\nHere are all the fields in our sample's configuration :\n\nFigure 26: JSON configuration fields\nOnce decrypted, the configuration is parsed to load all fields data into memory. It is very unlikely that the malware authors spent time\ndevelopping a JSON parser. They probably used an already existing solution. Lets search for commonly used parser:\n\n\n-----\n\nFigure 27: JSON Parser search\nTop 2 results are `cJSON and` `json-parser . We can see that those two parser have a different way to handle JSON data types.` `cJSON`\n[types are defined like this:](https://github.com/DaveGamble/cJSON/blob/master/cJSON.h#L88)\n```\n/* cJSON Types: */\n#define cJSON_Invalid (0)\n#define cJSON_False (1 << 0) //1\n#define cJSON_True  (1 << 1) //2\n#define cJSON_NULL  (1 << 2) //4\n#define cJSON_Number (1 << 3) //8\n#define cJSON_String (1 << 4) //16\n#define cJSON_Array (1 << 5) //32\n#define cJSON_Object (1 << 6) //64\n#define cJSON_Raw  (1 << 7) //128 /* raw json */\njson-parser types are defined in an enum like this:\ntypedef enum\n{\n  json_none,   //0\n  json_object,  //1\n  json_array,  //2\n  json_integer, //3\n  json_double,  //4\n  json_string,  //5\n  json_boolean, //6 \n  json_null   //7\n} json_type;\n\n```\nFor each configuration field, the malware seems to use a structure looking like this:\n```\nstruct mw_config_field\n{\n DWORD field_name;\n DWORD unknown;\n DWORD parse_function;\n};\n\n```\nThose structures are then stored in an array:\n\n\n-----\n\nFigure 28: Parsing strucutures array\nThe `unknown fields values are between 0 and 6. We can suppose that the unknown field corresponds to the json types from` `json-parser .`\nBy checking the type in IDA and in the configuration, we can confirm our supposition. For exemple, the `svc field is an array, both in the`\nconfiguration and in the IDA structure :\n\nFigure 29: svc array in configuration\n\nFigure 30: svc type in parsing structure\nNow that we have the parser source code, we can avoid wasting time reversing it in IDA.\n\n## Payment instructions\n\nThe payment instructions are base 64 encoded in the `nbody field of the configuration. Once decoded, we can see informations are missing :`\n\n\n-----\n\nFigure 31: Payment instruction excerpt\nThe three fields `UID,` `KEY and` `EXT are generated and replaced at run time.`\n\n## UID\n\nThe UID is the victim identifier, generated with the Windows volume serial number, and CPU attributes obtained with the `cpuid ASM`\ninstruction.\n\nFigure 32: UID generation\n\n## KEY\n\nThe KEY is a JSON dictionnary containing various information about the system, the user and the malware. The dictionnary is AES encrypted\nwith a key embedded in the binary, and base 64 encoded :\n\nFigure 33: KEY generation\n\nFigure 34: KEY base 64 encoding\n\n## EXT\n\nThe EXT is the file extension that will be added to encrypted files. It is a randomly generated string between 5 and 10 characters, containing\nnumbers and / or lowercase letters. The file extension is saved into a registry key to be used if the malware is executed multiple times.\n\n\n-----\n\n## Command line arguments\n\nThe malware accept 5 command line arguments.\n\nFigure 35: Command line argument parsing\nBy default, the malware will encrypt all files on local and shared network drives. The following arguments change this behavior :\n\nnolan : do not encrypt files on local drives\nnolocal : do not encrypt files on shared drives\npath : ignore local and network to only encrypt files in a specific path\n\nThe malware supports multiple encryption types:\n\nfast : only encrypt the first MB of each file\nfull : encrypt the whole file\n\nA third encryption type can be set in the configuration. We will come back to that later.\n\n## Region whitelisting\n\nThe malware will now verify that the infected system is not in a whitelisted region. To do so, it checks the system language and the keyboard\nlayout:\n\nFigure 36: System language whitelist\n\nFigure 37: Keyboard layout whitelist\nBoth the keyboard layout and the language need to be whitelisted for the malware to stop.\n\n## Persistence\n\n\n-----\n\ne a a e ay be te upted be o e be g ab e to e c ypt a es, e t e by a a t us, o by a use s utt g do t e p ocess o t e\nmachine. Supposedly to prevent this scenario, the malware registers itself in the `SOFTWAREMicrosoftWindowsCurrentVersionRun registry`\nkey to be relaunched at boot time. To pick up where it left off and avoid encrypting files multiple times, the malware saves some information in\nregistry keys. In particular, it saves the `EXT file extension, and intermediate secret keys, that are sadly not sufficient to decrypt files (more`\ndetails about encryption keys are given in the Keys management section).\n\nFigure 38: Registration in CurrentVersion\\Run key\nHowever, when finished, the malware deletes himself rendering the path in the registry key invalid.\n\nFigure 39: Registration for deletion\nFrom [MSDN Documentation:](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-movefileexw)\n\nIf dwFlags specifies MOVEFILE_DELAY_UNTIL_REBOOT and lpNewFileName is NULL, MoveFileEx registers the lpExistingFileName\nfile to be deleted when the system restarts.\n\n## Processes and sevices shutdown\n\nThe malware configuration contains a list of services and processes name ( svc and `prc fields). These services and processes are stopped`\nby the malware before files encryption. They usually are backup / snapshot services or antiviruses. They can also be database services like\nsql. By stopping these services, the databases files are no longer opened in other processes and can be encrypted.\n\nThe exact list may vary from samples to samples. As attacks are very targeted, we can assume that attackers adapt the configuration to suit\nthe victim system.\n\nIn addition to stopping services / processes, the malware also deletes shadow copies. Shadow copies are files or volumes snapshots made by\nthe Volume Snapshot Service (VSS) included in Windows.\n\nFor Windows versions over Windows XP, the following command is used :\n```\npowershell -e\nRwBlAHQALQBXAG0AaQBPAGIAagBlAGMAdAAgAFcAaQBuADMAMgBfAFMAaABhAGQAbwB3AGMAbwBwAHkAIAB8ACAARgBvAHIARQBhAGMAaAAtAE8AYgBqAGUA\n\n```\nOnce decoded :\n```\nGet-WmiObject Win32_Shadowcopy | ForEach-Object {$_.Delete();}\n\n```\n\nFor windows XP and below, the following command is used :\n```\ncmd.exe /c vssadmin.exe Delete Shadows /All /Quiet & bcdedit /set {default} recoveryenabled No & bcdedit /set\n{default} bootstatuspolicy ignoreallfailures\n\n## Files listing\n\n```\nBy default, the malware encrypt all local and network files. Depending on command line arguments, it can ignore local or network files, or\nignore both to only encrypt a given path.\n\nFigure 40: File listing options\n```\nmw_enum_path_files() is the function that recursively list all files in a given path. mw_enum_local_files() and\nmw_enum_network_resources() are used to list high level directories, and call mw_enum_path_files() .\n\n```\n\n-----\n\n## Local directories\n```\nmw_enum_local_files() brainlessly list all disks from A: to Z: . Each disk is sent to mw_enum_path_files() :\n\n```\nFigure 41: Local file listing\n\n## Network resources\n\nNetwork resources are listed with the `WNetOpenEnumW() and` `WNetEnumResourceW() functions. Resources of type` `RESOURCETYPE_DISK`\nare sent to `mw_enum_path_files() .`\n\nFigure 42: Network file listing\n\n## Specific directory listing\n\nAs we can see, both `mw_enum_local_files() and` `mw_enum_network_resources() call` `mw_enum_path_files() to recursively list files`\nin a given directory.\n\nThe malware configuration contains a whitelist of folders ( fld ), files ( fls ) and file extensions ( ext ) that must not be encrypted (like the\nwindows installation folder for exemple). Our sample's configuration was the following:\n```\n\"wht\": {\n  \"fld\": [\n   \"msocache\", \"intel\", \"$recycle.bin\", \"google\", \"perflogs\",\n   \"system volume information\", \"windows\", \"mozilla\", \"appdata\",\n   \"tor browser\", \"$windows.~ws\", \"application data\", \"$windows.~bt\",\n   \"boot\", \"windows.old\"\n  ],\n  \"fls\": [\n   \"bootsect.bak\", \"autorun.inf\", \"iconcache.db\", \"thumbs.db\", \"ntuser.ini\",\n   \"boot.ini\", \"bootfont.bin\", \"ntuser.dat\", \"ntuser.dat.log\", \"ntldr\",\n   \"desktop.ini\"\n  ],\n  \"ext\": [\n   \"com\", \"ani\", \"scr\", \"drv\", \"hta\", \"rom\", \"bin\", \"msc\", \"ps1\", \"diagpkg\",\n   \"shs\", \"adv\", \"msu\", \"cpl\", \"prf\", \"bat\", \"idx\", \"mpa\", \"cmd\", \"msi\",\n   \"mod\", \"ocx\", \"icns\", \"ics\", \"spl\", \"386\", \"lock\", \"sys\", \"rtp\", \"wpx\",\n   \"diagcab\", \"theme\", \"deskthemepack\", \"msp\", \"cab\", \"ldf\", \"nomedia\", \"icl\",\n   \"lnk\", \"cur\", \"dll\", \"nls\", \"themepack\", \"msstyles\", \"hlp\", \"key\", \"ico\",\n   \"exe\", \"diagcfg\"\n  ]\n },\nmw_enum_path_files() will start by checking if the given path is a whitelisted folder. If not, it proceeds by writing ransom instructions and\n\n```\nlisting items with `FindFirstFile() and` `FindNextFile() functions.`\n\nEach item found is ignored if on the whitelist. Otherwise, if the item is a folder, the ransom instructions are written in a text file named `{EXT}-`\n```\nreadme.txt . This name is defined in the nname field of the configuration. If the item is a file, it is encrypted.\n\n## Encryption parallelisation\n\n```\n[To shorten encryption time and take full advantage of the victim's calculation power, the malware uses \"I/O Completion Port\":](https://docs.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports)\n\n\n-----\n\n/O co p et o po ts p o de a e c e t t ead g ode o p ocess g u t p e asy c o ous /O equests o a u t p ocesso syste\nWhen a process creates an I/O completion port, the system creates an associated queue object for requests whose sole purpose is to\nservice these requests. Processes that handle many concurrent asynchronous I/O requests can do so more quickly and efficiently by\nusing I/O completion ports in conjunction with a pre-allocated thread pool than by creating threads at the time they receive an I/O\nrequest.\n\nThe IOCP API is composed of three functions :\n```\n   CreateIoCompletionPort() : called without or with a file handle, to respectively create a port or add a file to it;\n   GetQueuedCompletionStatus() : wait for a completion paquet to be posted to the port;\n   PostQueuedCompletionStatus() : post a completion paquet to the port. Completion paquet are also automatically posted when\n\n```\nsupported I/O operation are finished ( ReadFile(), `WriteFile(), etc...)`\n\nThe malware uses IOCP like this :\n\n1. The IOCP is created.\n2. A pool of threads is created.\n3. All threads wait an event with `GetQueuedCompletionStatus() .`\n4. When a file is found with `mw_enum_path_files(), it is added to the IOCP.`\n5. A completion paquet is posted with `PostQueuedCompletionStatus() to notify a thread that a file has to be encrypted.`\n\nHere is how a port and its threads are created :\n\nFigure 43: IOCP creation\n\nFigure 44: Thread pool creation\nWe can see that threads take an argument called `encryption_routine . This is a pointer to the encryption function that threads will execute.`\nIt starts with a call to `GetQueuedCompletionStatus() to wait for a file.`\n\nWhen a file is added to a completion port, a completion paquet is posted to trigger a thread :\n\nFigure 45: File addition to the IOCP\n\n## File encryption\n\nA file encryption is done in four steps.\n\n1. A 1 MB data block is read from the file (or the entire file if its size is less than 1 MB)\n2. The data block is encrypted and written back to the file. Depending on the encryption type, step 1 and 2 can be repeated multiple times.\n3. Metadata are added at the end of the file.\n4. The {EXT} extension is added to the file name.\n\nFigure 46: Encryption steps\n\n\n-----\n\n## Encryption types\n\nWe already presented encryption type full and fast, selectable from command line arguments. The encryption type can also be choosed from\nthe configuration with the `et field. Here, a third encryption type is available, which we will call mixed.`\n\nFor very long files, encrypting only the first MB leaves a lot of unencrypted data, but a full encryption would take too much time. The mixed\nencryption type allows to encrypt multiple blocks of 1 MB within a file, leaving some data between blocks unencrypted. The size of data left\nunencrypted between blocks is defined in the `spsize configuration field. The malware first read the encryption type from the configuration`\n( cfg_et ), but overwrites it if a command line argument is given.\n\nFigure 47: Encryption type selection\n\n## Encryption algorithms\n\nTo find out which encryption algorithm is used by the malware, we must look for known constants in the binary file (AES Sbox for exemple).\n[Various plugins and scripts were made to automate this search. A well known plugin is FindCrypt. If you don't want / can not install IDA plugins](https://github.com/polymorf/findcrypt-yara)\nor `yara-python,` [here is an alternative IDAPython only implementation we used for this analysis.](https://github.com/you0708/ida/tree/master/idapython_tools/findcrypt)\n\nThe script detect constants and rename them accordingly :\n\nFigure 48: FindCrypt output\n\nigure 49: Salsa20 and AES constants\nSalsa20 and AES constants are present in the binary. By studying these constants references, we find out that files are encrypted with\nSalsa20. For each file found in the `mw_enum_path_files() function, a Salsa20 Matrix is setted up with a unique encryption key, a unique IV,`\nand the Salsa20 constants.\n\nFigure 50: Salsa20 matrix preparation for file encryption\n\n## Processing structure\n\nOn the previous screenshot, you can see a `processing_info variable. It is a structure containing data about the file being encrypted. It is`\nused to transfer information between threads:\n\n\n-----\n\n```\n{\n DWORD ptrOverlapped;\n DWORD dword4;\n DWORD NbBytesProcessed_low;\n DWORD NbBytesProcessed_high;\n DWORD dword16;\n DWORD FileHandle;\n DWORD CurrentFileName;\n DWORD dword28;\n DWORD NbBytesToProcess_low;\n DWORD NbBytesToProcess_high;\n BYTE secret_1[88];\n BYTE secret_2[88];\n BYTE file_public_key[32];\n BYTE file_IV[8];\n DWORD file_public_key_crc;\n DWORD encryption_type;\n DWORD spsize;\n DWORD encrypted_null;\n salsa20_matrix salsa20_matrix;\n DWORD current_processing_step;\n DWORD next_processing_step;\n DWORD NbBytesToRead;\n BYTE EncryptionBuffer[4];\n};\n\n## Keys management\n\n```\nThe malware uses a complex key system to make the ransom payment mandatory for file recovery.\n\n## Session keys and encrypted keys\n\nWhen infecting a new victim, the malware starts by generating a session key pair with the Elliptic-Curve Diffie-Hellman (ECDH) algorithm. The\ncurve used is Curve25519.\n\nFigure 51: Session pair generation\nAn attacker's key which we will call `attackers_public_1 is stored in the` `pk configuration field.` `attackers_public_1 and a newly`\ngenerated `private_1 key are used with the ECDH algorithm to generate the` `shared_1 key. This shared key is used to encrypt`\n```\nsession_private with the AES algorithm.\n\n```\n\n-----\n\ngu e 5 sec et_ ge e at o\nThis exact same process is repeated to generate an `encrypted_2 key, but this time using an attackers key embedded in the binary file`\n( attackers_public_2 ).\n\nFigure 53: secret_2 generation\nThe `secret_1 and` `secret_2 data are saved in memory and in registry keys, as well as the` `session_public and`\n```\nattackers_public_1 keys. Other data or keys are freed from memory as they will not be used for file encryption.\n\n## File encryption keys and metadata\n\n```\nFor each file, a new key pair is generated. The new `file_private key and the` `session_public key are used with the ECDH algorithm to`\ngenerate the `file_encryption key. This key is used with the Salsa20 algorithm to encrypt the file content. Thus, each file is encrypted with`\na different key.\n\nFigure 54 File encryption\nMetadata are added at the end of every encrypted file :\n\n\n-----\n\nFigure 55: Encrypted file metadata\n\n## File decryption\n\nTo decrypt a file, one needs the metadata added at its end, and the private key corresponding to either `attackers_public_1 or`\n```\nattackers_public_2 . The decryption mechanism is supposedly the following:\n\n```\nFigure 56: File decryption\nThe attackers private keys are obviously unknown to us and victims. This is the keystone of Sodinokibi security, preventing victims to decrypt\nfiles without paying. This whole key management system also allows the malware to operate without having to communicate with a C2 server.\nWe did not have access to the decryption module, so this process is only a supposition we made based on other analysis, .5 6\n\n## Cryptographic library identification\n\n ECDH\n\nIn this part we wanted to explain how we understood that the binary was actually using ECDH to generate key pairs and shared keys.\n\nWe already knew where keys were generated. For exemple, here is the creation of the session keys, and encrypted keys :\n\n\n-----\n\ngu e 5 Sess o s eys a d e c ypted eys ge e at o\nBut when looking into `mw_generate_key_pair() sub-functions, the pseudocode quickly ended up looking like this :`\n\nFigure 58: Unreadable code\nHere, we searched some distinguishable elements allowing us to identify the algorithm, or better yet, the library used. We finally found a value\nthat seemed oddly specific. Exactly what we wanted :\n\nFigure 59: Oddly specific value\nAfter using different search terms, we finally got this result :\n\nFigure 60: Algorithm search\nWe successfuly identified the algorithm (ECDH). Can we find the exact library used? Let's look for implementation :\n\nFigure 61: Implementation search\nThe first result is a github repository in which we can find back our 121665 value :\n\n\n-----\n\nFigure 62: Curve25519-donna excerpt\nAnd comparing to what IDA gives us:\n\nFigure 63: Unknown pseudocode\nThe two codes have many similarities. We notice common `memcpy() and` `memset() calls. The` `fscalar_product() function implements`\na loop from 0 to 10 in the donna library. We find this loop in IDA too. It just seems to have been inlined by the compiler.\n\nWe can confidently say that the malware uses this library or a fork. The documentation gives instructions to generate key pairs :\n\nFigure 64: Curve25519-donna usage instructions\nWe can find these steps in the malware :\n\n\n-----\n\nFigure 65: Private key generation\n\nFigure 66: Public key generation\n\nFigure 67: Shared key generation\n\n## AES\n\nThanks to the FindCrypt script, we know that the malware uses T-Tables instead of SBoxes for AES encryption. We looked for AES\n[implementations using T-Tables. OpenSSL seemed like a good option, but some function calls and arguments were not matching.](https://github.com/openssl/openssl/tree/master/crypto/aes)\n\n## Server Communication\n\nWhen the `net configuration field is set to true, the malware will use the WinHTTP API to send the` `KEY data (see` Payment instructions) to a\nserver. Here, `KEY is not base 64 encoded.`\n\nThe configuration contains 1223 domain names in the `dmn field. For each domain, the malware will generate an URL and send the victim's`\n```\nKEY . Each url will have the following pattern :\nhttps://<domain>/<path1>/<path2>/<filename>.<ext> .\n   domain is the current domain.\n   path1 is randomly chosen between the following values:\n      wp-content, static, content, include, uploads, news, data, admin .\n   path2 is randomly chosen between the following values:\n      images, pictures, image, temp, tmp, graphic, assets, pics, game .\n   filename is a randomly generated strings composed of 1 to 9 pairs of lowercase letters.\n   ext is randomly chosen between the following values:\n      jpg, png, gif .\n\n```\nMany domains seem legitimate, but one or more could be compromised and used by the malware authors. The use of so many domains\nallows to hide which servers really belong to the attackers. Using a simple python script, we sent one POST request to a valid URL on all\ndomains. We received code `200 75 times and code` `404 784 times. Many server do not recognise the url and respond with error code`\n```\n404 . Thus, they can not receive data from the malware. With further tests we could continue reducing the list of potential malicious or\n\n```\ncompromised servers, but this is out of scope of this article.\n\n## Conclusion\n\nIn this article we explained what the Sodinokibi malware do, and how it operates. The sample analysed was found in march 2020.\n\nSodinokibi implements two obfuscation mechanism : IAT obfuscation and Strings encryption. While these mechanism do not prevent reverse\nengineering, they prevent antiviruses solutions to easily detect the threat.\n\nThe malware was spread via spam and phishing campaigns, but it was also manually executed by attackers on already compromised system.\nIndeed, it was designed to be adaptable to the victim's system with a JSON configuration and command line arguments.\n\nTo obtain administrator privileges, the malware will spam the UAC window for user consent. Then, it will stop services and processes listed in\nits configuration. These processes usually are antiviruses, databases, backup or snapshot solutions, etc.\n\nSodinokibi uses I/O Completion Port to parallelise file encryption, and make it as fast as possible. Files are encrypted with the Salsa20\nalgorithm, each with a unique encryption key. Encryption keys are protected with a complex key system, preventing file decryption without a\nprivate key owned by the attackers.\n\nThe malware can operate without contacting a C2 server, but if correctly configured, it will communicate a victim identification key to one or\nmultiple servers. These servers are hidden in a list of thousand of domains.\n\n\n-----\n\netect g Sod o b s ot easy S g atu es a e ot e ab e as t e a a e ca be eco p ed o eac ct a ous a es e t e\nconfiguration PE section or registry keys can be randomly generated at each compilation so they can not be used for detection either.\nFurthermore, the encryption process showed in this blogpost shows that's it's impossible to decrypt the files without paying the ransom.\n\n[If you are victim of a ransomware like this one, or if you encounter a security incident on your network, you can contact the CERT-Amossys to](https://www.amossys.fr/cert.php)\nhelp you manage and investigate it.\n\n## References\n\n[1. REvil Ransomware Gang Starts Auctioning Victim Data - Krebs on Security](https://krebsonsecurity.com/2020/06/revil-ransomware-gang-starts-auctioning-victim-data/) ↩\n\n[2. OAlabs IDA script for DLL functions hashing](https://gist.github.com/OALabs/94ff4fc02bf02d55a8161068cafd11c0) ↩\n\n[3. OAlabs IDA script for IAT deobfuscation](https://gist.github.com/OALabs/fc68ad4d63fd68c910f32d66fa5e981d) ↩\n\n[4. OALabs IDA script for strings decryption](https://gist.github.com/OALabs/04ef6b2d6203d162c5b3b0eefd49530c) ↩\n\n[5. Taking Deep Dive into Sodinokibi Ransomware Acronis.Com](https://www.acronis.com/en-us/articles/sodinokibi-ransomware/) ↩\n\n[6. “REvil Ransomware-as-a-Service – An Analysis of a Ransomware Affiliate Operation.” Intel 471’s Blog, 31 Mar. 2020](https://blog.intel471.com/2020/03/31/revil-ransomware-as-a-service-an-analysis-of-a-ransomware-affiliate-operation/) ↩\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-07-29 - Sodinokibi - REvil Malware Analysis.pdf"
    ],
    "report_names": [
        "2020-07-29 - Sodinokibi - REvil Malware Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535954,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653704168,
    "ts_modification_date": 1653704168,
    "files": {
        "pdf": "https://archive.orkl.eu/dece0ed0f00f4eae82e826475765b25d27090437.pdf",
        "text": "https://archive.orkl.eu/dece0ed0f00f4eae82e826475765b25d27090437.txt",
        "img": "https://archive.orkl.eu/dece0ed0f00f4eae82e826475765b25d27090437.jpg"
    }
}