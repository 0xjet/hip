{
    "id": "65e59d91-0618-4441-b8c2-6df1dd084cd5",
    "created_at": "2023-01-12T15:08:27.28755Z",
    "updated_at": "2025-03-27T02:05:52.324017Z",
    "deleted_at": null,
    "sha1_hash": "2432dbbd1141ea6d7e46ebe50ffc925322606356",
    "title": "Sequence Based Malware Detection",
    "authors": "",
    "file_creation_date": "2009-12-04T08:06:04Z",
    "file_modification_date": "2009-12-04T08:06:04Z",
    "file_size": 279221,
    "plain_text": "[See discussions, stats, and author profiles for this publication at: https://www.researchgate.net/publication/221566041](https://www.researchgate.net/publication/221566041_Idea_Opcode-Sequence-Based_Malware_Detection?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_2&_esc=publicationCoverPdf)\n\n## Idea: Opcode-Sequence-Based Malware Detection\n\n**Conference Paper · February 2010**\n\nDOI: 10.1007/978-3-642-11747-3_3 · Source: DBLP\n\n\nCITATIONS\n170\n\n**7 authors, including:**\n\n[Igor Santos](https://www.researchgate.net/profile/Igor-Santos-22?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_5&_esc=publicationCoverPdf)\n\n[University of Deusto](https://www.researchgate.net/institution/University-of-Deusto?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_6&_esc=publicationCoverPdf)\n\n**114** PUBLICATIONS **2,451** CITATIONS\n\n\nREADS\n2,568\n\n\n[Felix Brezo](https://www.researchgate.net/profile/Felix-Brezo?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_5&_esc=publicationCoverPdf)\n\n[University of Deusto](https://www.researchgate.net/institution/University-of-Deusto?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_6&_esc=publicationCoverPdf)\n\n**17** PUBLICATIONS **799** CITATIONS\n\n\n[SEE PROFILE](https://www.researchgate.net/profile/Igor-Santos-22?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_7&_esc=publicationCoverPdf)\n\n\n[SEE PROFILE](https://www.researchgate.net/profile/Felix-Brezo?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_7&_esc=publicationCoverPdf)\n\n\n[Borja Sanz](https://www.researchgate.net/profile/Borja-Sanz-3?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_5&_esc=publicationCoverPdf)\n\n[University of Deusto](https://www.researchgate.net/institution/University-of-Deusto?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_6&_esc=publicationCoverPdf)\n\n**59** PUBLICATIONS **931** CITATIONS\n\n\n[Carlos Laorden](https://www.researchgate.net/profile/Carlos-Laorden?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_5&_esc=publicationCoverPdf)\n\n[University of Deusto](https://www.researchgate.net/institution/University-of-Deusto?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_6&_esc=publicationCoverPdf)\n\n**47** PUBLICATIONS **1,005** CITATIONS\n\n\n[SEE PROFILE](https://www.researchgate.net/profile/Borja-Sanz-3?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_7&_esc=publicationCoverPdf)\n\n\n[SEE PROFILE](https://www.researchgate.net/profile/Carlos-Laorden?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_7&_esc=publicationCoverPdf)\n\n\n**Some of the authors of this publication are also working on these related projects:**\n\nSupervised Machine Learning for the Detection of Troll Profiles in Twitter Social Network: Application to a Real Case of Cyberbullying [View project](https://www.researchgate.net/project/Supervised-Machine-Learning-for-the-Detection-of-Troll-Profiles-in-Twitter-Social-Network-Application-to-a-Real-Case-of-Cyberbullying?enrichId=rgreq-51fcf54d5ac23f8269b221ca5e2a2e18-XXX&enrichSource=Y292ZXJQYWdlOzIyMTU2NjA0MTtBUzoxMDY1MjUzNDMzNTQ4ODNAMTQwMjQwOTAyOTM5Mg%3D%3D&el=1_x_9&_esc=publicationCoverPdf)\n\n\n-----\n\n# Idea: Opcode-sequence-based Malware Detection\n\nIgor Santos[1], Felix Brezo[1], Javier Nieves[1], Yoseba K. Penya[2], Borja Sanz[1],\nCarlos Laorden[1] and Pablo G. Bringas[1]\n\n1S3Lab, 2eNergy Lab\nUniversity of Deusto\nBilbao, Spain\n```\n     {isantos,felix.brezo,javier.nieves,yoseba.penya,borja.\n       sanz,claorden,pablo.garcia.bringas}@deusto.es\n\n```\n**Abstract. Malware is every malicious code that has the potential to**\nharm any computer or network. The amount of malware is increasing\nfaster every year and poses a serious security threat. Hence, malware\ndetection has become a critical topic in computer security. Currently,\nsignature-based detection is the most extended method within commercial antivirus. Although this method is still used on most popular commercial computer antivirus software, it can only achieve detection once\nthe virus has already caused damage and it is registered. Therefore, it\nfails to detect new variations of known malware. In this paper, we propose a new method to detect variants of known malware families. This\nmethod is based on the frequency of appearance of opcode sequences.\nFurthermore, we describe a method to mine the relevance of each opcode\nand, thereby, weigh each opcode sequence frequency. We show that this\nmethod provides an effective way to detect variants of known malware\nfamilies.\n\n**Key words: malware detection, computer security, machine learning**\n\n### 1 Introduction\n\nMalware (or malicious software) is every computer software that has harmful intentions, such as viruses, Trojan horses, spyware or Internet worms. The amount,\npower and variety of malware increases every year as well as its ability to avoid all\nkind of security barriers [1] due to, among other reasons, the growth of Internet.\nFurthermore, malware writers use code obfuscation techniques to disguise an\nalready known security threat from classic syntactic malware detectors. These\nfacts have led to a situation in which malware writers develop new viruses and\ndifferent ways for hiding their code, while researchers design new tools and strategies to detect them [2].\nGenerally, the classic method to detect malware relies on a signature database\n\n[3] (i.e. list of signatures). An example of a signature is a sequence of bytes that is\nalways present in a concrete malware file and within the files already infected by\nthat malware. In order to determine a file signature for a new malware executable\nand to finally find a proper solution for it, specialists have to wait until that\n\n\n-----\n\nnew malware instance has damaged several computers or networks. In this way,\nmalware is detected by comparing its bytes with that list of signatures. When a\nmatch is found the tested file will be identified as the malware instance it matches\nwith. This approach has proved to be effective when the threats are known in\nbeforehand, and it is the most extended solution within antivirus software.\nStill, upon a new malware appearance and until the corresponding file signature is obtained, mutations (i.e. aforementioned obfuscated variants) of the original malware may be released in the meanwhile. Therefore, already mentioned\nclassic signature-based malware detectors fail to detect those new variants [2].\nAgainst this background we advance the state of art in two main ways. First,\nwe address here a new method that is able to mine the relevance of an opcode\n(operational code) for detecting malicious behaviour. Specifically, we compute\nthe frequency with which the opcode appears in a collection of malware and\nin a collection of benign software and, hereafter, we calculate a discrimination\nratio based on statistics. In this way, we finally acquire a weight for each opcode.\nSecond, we propose a new method to compute similarity between two executable\nfiles that relies on opcode sequence frequency. We weigh this opcode sequence\nfrequency with the obtained opcode relevance to balance each sequence in the\nway how discriminant the composing opcodes are.\n\n### 2 Mining opcode relevance\n\nOpcodes (or operational codes) can act as a predictor for detecting obfuscated or\nmetamorphic malware [4]. Some of the opcodes (i.e. mov or push), however, have\na high frequency of appearance within malware and benign executables, therefore\nthe resultant similarity degree (if based on opcode frequency) between two files\ncan be somehow distorted. Hence, we propose a way to avoid this phenomenon\nand to give each opcode the relevance that it really has.\nIn this way, we have collected malware from the VxHeavens website [5] forming a malware dataset of 13189 malware executables. This dataset contains only\nPE executable files, and, more accurately, it is made up of different kind of malicious software (e.g. computer viruses, Trojan horses, spyware, etc ). For the\nbenign software dataset, we have collected 13000 executables from our computers. This benign dataset includes, for instance, word-processors, drawing tools,\nwindows games, internet browsers, pdf viewers and so on.\nWe accomplish the following steps for computing the relevance of each opcode. First, we disassemble the executables. In this step, we have used The New_Basic Assembler [6] as the main tool for obtaining the assembly files. Second,_\nusing the generated assembly files, we have built an opcode profile file. Specifically, this file contains a list with the operational code and the un-normalized\nfrequency within both datasets (i.e. benign software dataset and malicious software dataset). Finally, we compute the relevance of each opcode based on the\nfrequency with which it appears in both datasets. To this extent, we use Mutual\n\n� _p(x,y)_ �\n\n_Information [7], I(X; Y ) =_ [�]yϵY �xϵX _[p][(][x, y][) log]_ _p(x)·p(y)_ . Mutual informa\ntion is a measure that indicates how statistically dependant two variables are.\n\n\n-----\n\nIn our particular case, we define the two variables as each opcode frequency and\nwhether the instance is malware. In this way, X is the opcode frequency and\n_Y is the class of the file (i.e. malware or benign software), p(x, y) is the joint_\nprobability distribution function of X and Y, p(x) and p(y) are the marginal\nprobability distribution functions of X and Y .\nFurthermore, once we computed the mutual information between each opcode\nand the executable class (malware of benign software) and we sorted them, we\ncreated an opcode relevance file. Thereby, this list of opcode relevance can help\nus to achieve a more accurate detection of malware variations since we are able\nto weigh the similarity function using these calculated opcode relevance and\nreducing the noise that irrelevant opcodes can produce.\n\n### 3 Malware detection method\n\nIn order to detect both malware variants we extract the opcode sequences and\ntheir frequency of appearance. More accurately, we define a program ρ as a\nsequence of instructions I where ρ = (I1, I2, ..., In−1, In). An instruction is composed by an operational code (opcode) and a parameter or list of parameters. In\nthis way, we assume that a program is made up of opcodes. These opcodes can\ngather into several blocks that we call opcode sequences.\nMore accurately, we assume a program ρ as a set of ordered opcodes o,\n_ρ = (o1, o2, o3, o4, ..., on−1, on), where n is the number of instructions I of the_\nprogram ρ. A subgroup of opcodes is defined as an opcode sequence os where\n_os ⊆_ _ρ, and it is made up of opcodes o, os = (o1, o2, o3, ..., om−1, om), where m_\nis the length of the sequence of opcodes os.\nFirst of all, we choose the length of opcode sequences. Afterwards, we compute the frequency of appearance of each opcode sequence. Specifically, we use\n_term frequency [8], tfi,j =_ �nki,j[n][k,j][, that is a weight widely used in information]\n\nretrieval. More accurately, ni,j is the number of times the term ti,j (in our case\nopcode sequence) appears in a document d, and [�]k _[n][k,j][ is the total number]_\n\nof terms in the document d (in our case the total number of possible opcode\nsequences).\nFurther, we compute this measure for every possible opcode sequence of\na fixed length n, acquiring by doing so, a vector _[−→]v made up of frequencies_\nof opcode sequences S = (o1, o2, o3, ..., on−1, on). We weigh the frequency of\nappearance of this opcode sequence using the weights described in section 2. To\nthis extent, we define weighted term frequency (wtf ) as the result of weighting the\nrelevance of each opcode when calculating the term frequency. Specifically, we\ncompute it as the result of multiplying term frequency by the calculated weight\nof every opcode in the sequence. In this way, weight(o) is the calculated weight\nfor the opcode o and tfi,j is the term frequency measure for the given opcode\nsequence, wtfi,j = tfi,j · _oϵS_ _weight100_ (o) . Once we have calculated the weighted\n\n[�]\n\n_term frequency, we have the vector of weighted opcode sequence frequencies._ _[−→]v =_\n(wtf1, wtf2, wtf3, ..., wtfn−1, wtfn).\n\n\n-----\n\nWe have focused on detecting known malware variants in this method. In this\nway, what we want to provide is a similarity measure between two files. Once we\nextract the opcode sequences that will act as features, we have a proper representation of the files as two input vectors _[−→]v and_ _[−→]u of opcode sequences. Hereafter,_\nwe can calculate a similarity measure between those two vectors. In this way, we\nuse cosine similarity, sim([−→]v, _[−→]u ) = cos (θ) =_ _−→v ·−→u_\n_||[−→]v ||·||[−→]u ||_ [[9]. Therefore, we think]\nthat this measure will give a high result when two versions of the same malware\ninstance are compared.\n\n**Fig. 1. A histogram showing the obtained results in terms of frequency of similarity**\nratio for the comparison of malware instances with their variants for n=1\n\n**Fig. 2. A histogram showing the obtained results in terms of frequency of similarity**\nratio for the comparison of malware instances with benign executables for n=1\n\n\n-----\n\n**Fig. 3. A histogram showing the obtained results in terms of frequency of similarity**\nratio for the comparison of malware instances with their variants for n=2\n\n**Fig. 4. A histogram showing the obtained results in terms of frequency of similarity**\nratio for the comparison of malware instances with benign executables for n=2\n\n### 4 Experimental Results\n\nFor the following experiment, we have used two different datasets for testing the\nsystem: a malware dataset and a benign software one. First, we downloaded a big\nmalware collection from VxHeavens [5] website conformed by different malicious\ncode such as trojan horses, virus or worms. Specifically, we have used the next\nmalware families: Agobot, Bifrose, Kelvir, Netsky, Opanki and Protoride.\nWe have extracted the opcode sequences of a fixed length (n) with n = 1 and\n_n = 2 for each malware and some of its variants. Moreover, we have followed the_\nsame procedure for the benign software dataset. Hereafter, we have computed\nthe cosine similarity between each malware and its set of variants. Further, we\nhave computed the similarity of the malware instance with the whole benign\nsoftware dataset.\n\n\n-----\n\n**Fig. 5. A histogram showing the obtained results in terms of frequency of similarity**\nratio for the comparison of malware instances with their variants for n=1 and n=2\ncombined\n\nSpecifically, we have performed this process for every malware executable file\nwithin the dataset. For each malware family, we have randomly chosen one of\nits variants as the known instance and we have computed the cosine similarity\nbetween this variant and the other variants of that specific malware family.\nMoreover, we have performed the same procedure with a set of benign software\nin order to test the appearance of false positives.\nFig. 1 shows the obtained results of the comparison of malware families and\ntheir variants for an opcode sequence length n of 1. In this way, nearly every\nmalware variant achieved a similarity degree between 90% and 100%. Still, the\nresults obtained when comparing with the benign dataset (see Fig. 2) show that\nthe similarity degree is too high, thus, this opcode sequence length seems to be\nnot appropriate.\nFor an opcode sequence length of 2, the obtained results in terms of malware variant detection(see Fig. 3) show that the similarity degrees are more\ndistributed in frequencies, however, the majority of the variants achieved a relatively high results. In addition, Fig. 4 shows the obtained results for the benign\ndataset. In this way, the results are better for this opcode sequence length, being\nmore frequent the low similarity ratios.\nSummarizing, on one hand, for the obtained results in terms of similarity\ndegree for malware variant detection, the most frequent similarity degree is in\nthe 90-100% interval. Moreover, the similarity degree frequency decreases and so\nthe frequency does. Therefore, this method will be able to detect reliably a high\nnumber of malware variants after selecting the appropriate threshold of similarity\nratio for declaring an executable as malware variant. Nevertheless, some of the\nexecutables were packed and, thereby, there are several malware variants that\nwhen computing the similarity degree did not achieve a high similarity degree.\nStill, the similarity degrees between the two kind of sets (i.e. malware variants\nand benign software) are not different enough. Therefore, we decided to perform\n\n\n-----\n\n**Fig. 6. A histogram showing the obtained results in terms of frequency of similarity**\nratio for the comparison of malware instances with benign executables for n=1 and\nn=2 combined\n\nanother experiment where the different opcode sequence lengths are combined\n(n = 1 and n = 2). Figures 5 and 6 show the obtained results. In this way,\nthe malware variant similarity degrees remained quite high whilst the benign\nsimilarity degrees scrolled to lower results. On the other hand, for the obtained\nresults in terms of similarity degree when comparing the malware instances with\nthe benign dataset, as one may think in beforehand, the behaviour of the system\nyields to be nearly the opposite than when comparing it with its variants. In this\nway, the system achieved low similarity degrees in the majority of the cases of\nthe benign dataset. Hence, if we select a threshold that allows us to detect the\nmost number of malware variants as possible whilst the number of false positives\nis kept to 0, our method renders as a very useful tool to detect malware variants.\n\n### 5 Related Work\n\nThere has been a great concern regarding malware detection in the last years.\nGenerally, we can classify malware detection in static or dynamic approaches.\nStatic detectors obtain features for further analysis without executing them since\ndynamic detectors execute malware in a contained environment.\nIn this way, static analysis for malware detection can be focused on the binary\nexecutables [10] or in source code [11] like the method proposed in this paper.\nWith regard to the binary analysis of the executables, there has been an hectic\nactivity around the use of machine-learning techniques over byte-sequences. The\nfirst attempt of using non-overlapping sequence of bytes of a given length n as\nfeatures to train a machine-learning classifier was proposed by Schulz et al. [12].\nIn that approach the authors proposed a method using the printable ASCII\nstrings of the binary, tri-grams of bytes, the list of imported dynamically linked\nlibraries (DLL), the list of DLL functions imported and the number of functions\nfor each DLL. They applied multiple learning algorithms showing that multi\n\n-----\n\nNa¨ıve Bayes perform the best. Kolter et al. [13] improved the results obtained\nby Schulz et al. using n-grams (overlapping byte sequences) instead of nonoverlapping sequences. Their method used several algorithms and the best results\nwere achieved by a boosted decision tree. In a similar vein, a lot of work has\nbeen made over n-gram distributions of byte sequences and machine-learning\n\n[14]. Still, most of the features they used for the training of the classifiers can\nbe changed easily by simply changing the compiler since they focus on byte\ndistributions.\nMoreover, several approaches have been based in the so-called Control Flow\n_Graph Analysis. In this way, it is worth to mention the work of Christodescu_\nand Jha [2] that proposed a method based of Control Flow Analysis to handle\nobfuscations in malicious software. Lately, Christodescu et. at. [15] improved the\nprevious work including semantic-templates of malicious specifications. Nevertheless, the time resources they consume render them as not already full prepared\nto be adopted for antivirus vendors, although Control Flow Analysis techniques\nhave proved to obtain some very valuable information of malicious behaviours.\nDynamic analysis for malware detection, as aforementioned, runs a program\nin a contained environment and collects information about it. Despite they are\nlimited by one execution flow, they can overcome the main issue of static analysis: be sure that the code that will be executed is the one that is being analysed\n\n[16]. Therefore, these methods do not have to face obfuscations or in-memory\nmutation [17]. In this way, the safe environment can be based on a virtual machine [18] or based on DLL Injection and API Hooking [19].\n\n### 6 Conclusions and future work\n\nMalware detection has risen to become a topic of research and concern due to\nits increasing growth in past years. The classic signature methods that antivirus\nvendors have been using are no longer effective since the increasing number of\nnew malware renders them unuseful. Therefore, this technique has to be complemented with more complex methods that provide detection of malware variants,\nin an effort of detecting more malware instances with a single signature.\nIn this paper, we proposed a method detecting malware variants that relied\nin opcodes sequences in order to construct a vector representation of the executables. In this way, based upon some length sequences, the system was able\nto detect the malicious behaviour of malware variants. Specifically, experiments\nhave shown the following abilities of the system. First, the system was able to\nidentify malware variants. Second, it was able to distinguish benign executables.\nThe future development of this malware detection system is oriented in three\nmain directions. First, we will focus on facing packed executables using a hybrid\ndynamic-static approach. Second, we will expand the used features using even\nlonger sequences and more information like system calls. Finally, we will perform\nexperiments with a larger malware dataset.\n\n\n-----\n\n### References\n\n1. Karsperky-Labs: Kaspersky Security Bulletin: Statistics 2008 (2009)\n2. Christodorescu, M., Jha, S.: Static analysis of executables to detect malicious\npatterns. In: Proceedings of the 12th USENIX Security Symposium. (February\n2003) 169–186\n3. Morley, P.: Processing virus collections. In: Proceedings of the 2001 Virus Bulletin\nConference (VB2001), Virus Bulletin (2001) 129–134\n4. Bilar, D.: Opcodes as predictor for malware. International Journal of Electronic\nSecurity and Digital Forensics 1(2) (2007) 156–168\n5. VX heavens (2009) url: http://vx.netlux.org/ Last Accessed: Last accessed:\nSeptember 29th, 2009.\n6. NewBasic - An x86 Assembler/Disassembler for DOS\nhttp://www.frontiernet.net/ fys/newbasic.htm Last accessed: September 29th,\n2009.\n7. Peng, H., Long, F., Ding, C.: Feature selection based on mutual information: criteria of max-dependency, max-relevance, and min-redundancy. IEEE Transactions\non Pattern Analysis and Machine Intelligence (2005) 1226–1238\n8. McGill, M., Salton, G.: Introduction to modern information retrieval. McGraw-Hill\n(1983)\n9. Tata, S., Patel, J.: Estimating the Selectivity of tf-idf based Cosine Similarity\nPredicates. SIGMOD Record 36(2) (2007) 75–80\n10. Carrera, E., Erd´elyi, G.: Digital genome mapping–advanced binary malware analysis. In: Virus Bulletin Conference. (2004) 187–197\n11. Ashcraft, K., Engler, D.: Using programmer-written compiler extensions to catch\nsecurity holes. In: Proceedings of the 23[r]d IEEE Symposium on Security and\nPrivacy. (2002) 143–159\n12. Schultz, M., Eskin, E., Zadok, F., Stolfo, S.: Data mining methods for detection\nof new malicious executables. In: Proceedings of the 22[t]h IEEE Symposium on\nSecurity and Privacy. (2001) 38–49\n13. Kolter, J.Z., Maloof, M.A.: Learning to detect malicious executables in the wild.\nIn: Proceedings of the 10th ACM SIGKDD international conference on Knowledge\ndiscovery and data mining (KDD), New York, NY, USA, ACM (2004) 470–478\n14. Santos, I., Penya, Y., Devesa, J., Bringas, P.: N-Grams-based file signatures for\nmalware detection. In: Proceedings of the 11[th] International Conference on Enterprise Information Systems (ICEIS), Volume AIDSS. (2009) 317–320\n15. Christodorescu, M., Jha, S., Seshia, S., Song, D., Bryant, R.: Semantics-aware\nmalware detection. In: Proceedings of the 2005 IEEE Symposium on Security and\nPrivacy. (2005) 32–46\n16. Cavallaro, L., Saxena, P., Sekar, R.: On the limits of information flow techniques\nfor malware analysis and containment. Lecture Notes in Computer Science 5137\n(2008) 143–163\n17. Bayer, U., Moser, A., Kruegel, C., Kirda, E.: Dynamic analysis of malicious code.\nJournal in Computer Virology 2(1) (2006) 67–77\n18. King, S., Chen, P.: SubVirt: Implementing malware with virtual machines. In:\n2006 IEEE Symposium on Security and Privacy. (2006) 314–327\n19. Willems, C., Holz, T., Freiling, F.: Toward automated dynamic malware analysis\nusing cwsandbox. IEEE Security & Privacy 5(2) (2007) 32–39\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/AV Tech/Sequence Based Malware Detection.pdf"
    ],
    "report_names": [
        "Sequence Based Malware Detection.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536107,
    "ts_updated_at": 1743041152,
    "ts_creation_date": 1259913964,
    "ts_modification_date": 1259913964,
    "files": {
        "pdf": "https://archive.orkl.eu/2432dbbd1141ea6d7e46ebe50ffc925322606356.pdf",
        "text": "https://archive.orkl.eu/2432dbbd1141ea6d7e46ebe50ffc925322606356.txt",
        "img": "https://archive.orkl.eu/2432dbbd1141ea6d7e46ebe50ffc925322606356.jpg"
    }
}