{
    "id": "eb37ea5e-cb8d-4459-8a0b-c9ef78366cd2",
    "created_at": "2023-01-12T15:05:29.192589Z",
    "updated_at": "2025-03-27T02:06:06.731643Z",
    "deleted_at": null,
    "sha1_hash": "40fc71dcc2dd432e64b7b47c785e78a7ee838895",
    "title": "2019-01-15 - Analyzing COMmunication in Malware",
    "authors": "",
    "file_creation_date": "2022-05-25T14:13:18Z",
    "file_modification_date": "2022-05-25T14:13:18Z",
    "file_size": 588355,
    "plain_text": "# Analyzing COMmunication in Malware\n\n**[0ffset.net/reverse-engineering/analyzing-com-mechanisms-in-malware](https://www.0ffset.net/reverse-engineering/analyzing-com-mechanisms-in-malware/)**\n\n[0verfl0w_](https://www.0ffset.net/author/dan489400/)\n15th January 2019\n4 Comments\n\n\n15 January 2019\n\n\n[If you follow me on Twitter (@0verfl0w_), you may have noticed a while back that I was](https://twitter.com/0verfl0w_)\nanalyzing a sample of Ursnif/Gozi/ISFB (which I will refer to as ISFB) and was confused as\nto how it was able to communicate with its C2 servers through a separate process, without\n[injected DLL’s or process hollowing. I managed to locate a great article by Mandiant (here)](https://www.fireeye.com/blog/threat-research/2010/08/reversing-malware-command-control-sockets.html)\nfrom 2010 about how COM can be used to control a process, such as Internet Explorer, into\nperforming certain actions.\n\nIn this post, I will be exploring the COM mechanisms that the latest versions of ISFB utilize\nin order to contact the command and control servers stealthily. I do have quite a long post\ngoing up (hopefully) in the next couple of weeks that goes into detail about this specific\nstrain of ISFB, and the multiple unpacking stages it goes through before the final stage, so\nstay tuned for that!\n\n**What is exactly is COM?**\n\nAccording to Microsoft, “The Microsoft Component Object Model (COM) is a platform_independent, distributed, object-orientated system for creating binary software_\n_components.” To sum it up, COM allows programs to interact with each other through COM_\nobjects. This interaction can occur\n“within a single process, in other processes, and can even be on remote computers“, and\nthe language that the program was written in does not matter – as long as it is able to create\nstructures of pointers and call functions through those pointers, it is COM Compatible –\nmeaning languages like Visual Basic and Java can use COM. If you want to learn more about\n[COM, you can check out Microsoft’s own description and tutorials on it here.](https://docs.microsoft.com/en-us/windows/desktop/com/the-component-object-model)\n\nAs a result of the progression of technology, COM isn’t used as frequently anymore, and\ntherefore when an analyst comes across a piece of malware utilizing this unfamiliar\ncommunication method, it may be difficult to pinpoint what is happening, and how. Static\nanalysis is even more complex, unless you know what you are looking for – which is what\nthis article is about.\n\n**COM Mechanisms and its use in the ISFB Loader**\n\nSecond Stage Loader MD5: 5019f31005dba2b410b21c4743ef4e98\n\n\n-----\n\n[I have uploaded the first stage and dumped second stage loader to VirusBay, so that you](https://beta.virusbay.io/)\ncan follow the steps if you want to. I will be focusing on the second stage loader, as that is\nwhere the communication with the C2 occurs. I will be analyzing it statically using IDA,\nalthough you can do it dynamically as well.\n\nThe first giveaway that malware could be using COM functionality for communicating with\nit’s C2 server is a call to CoInitializeEx. Calling this function will initialize the COM library\nso that the calling thread can utilize it’s functionality. Taking a look at the flow of this\nsample, it is clear that if initializing the library fails, it will exit – hinting that it heavily relies\non the COM library being loaded successfully.\n\nOnce we have discovered it is initializing the COM library, we can search for calls to\n**CoCreateInstance, as this spawns an uninitialized object of the class associated with a**\nspecific CLSID, meaning you will notice a new process being spawned after you step over\nthis call. Whilst there are many cross references to CoCreateInstance in this sample, we are\nable to determine which one calls Internet Explorer based on the CLSID pushed before the\nfunction call. IDA will show you the CLSID based on how it looks in memory, and as a\nresult, we can find the corresponding object that is called. But how?\n\n\n-----\n\nThe CLSIDs of different objects are stored in the registry, and so whenever\nCoCreateInstance is called, the system checks the registry for the passed CLSID. From the\nimage above, we can tell that the CLSID being utilized is {0002DF01-0000-0000**C000-000000000046}, which we can lookup in the registry. You can find a list of all the**\navailable CSLIDs at HKEY_CLASSES_ROOT\\CLSID. Once the CLSID has been located,\nit should reveal what process is being created, and in this case it is Internet Explorer\n**(Ver 1). Moreover, the IE_riid that is being passed to the function informs us of the**\ninterface being used – in this case the riid being used is {EAB22AC1-30C1-11CF-A7EB**0000C05BAE0BE}, which when looked up in the registry reveals that it is the**\n**Microsoft Web Browser Version 1. When we google this riid, it comes up with results**\nfor the IWebBrowser interface.\n\nNow that we know for sure what instance is being created, we can look at what functions are\nbeing called. IDA Pro has a plugin called COM helper which will detect CLSIDs and alter the\nnames to resemble what they point to, however this isn’t possible in the free version, so you\nwould have to look it up in the registry. When looking at calls to COM functions in IDA, all\n\n\n-----\n\nyou would see is call dword ptr [ecx+2Ch], which doesn t tell you much unless you know\nthe functions inside out. That is why we have to create a structure in IDA that allows us to\nassign understandable functions to these pointers. Simply click on the Structures tab and\npress the INSERT Key to add a new structure. Then click Add Standard Structure. In\nthis case, we know Internet Explorer is being called, and a quick google search for\n“Controlling Internet Explorer using COM C” will show code on several pages referring to\n**IWebBrowser2, and so the Standard Structure we want to create is called**\n**IWebBrowser2Vtbl, which is possible to create using the free version of IDA Pro.**\nFurthermore, we know that IWebBrowser was being used as well, so we should also\ncreate a Standard Struct for that as well.\n\nOne way you can determine other interfaces that are being utilized is to simply look for calls\nto QueryInterface, as this retrieves pointers to all calls available in that Interface. This\nwill allow you to create the correct standard structures, and resolve the calls to these\nfunctions.\n\nThis standard structure will contain a list of functions exported by IWebBrowser2, and so\nwe can simply resolve any pointers to those functions, such as dword ptr [ecx+2Ch],\nwhich can be resolved to IWebBrowser2Vtbl.Navigate(). Dynamic analysis becomes\nquite important here, as you can then start matching up functions correctly, rather than\nassuming a pointer is pointing to a function in that struct.\n\n\n-----\n\nIf you were debugging this program, these functions would show up as\n**ObjectStublessClient, and sometimes you will have to rely on the pushed values to**\ndetermine what the function was doing. Once we have fully resolved most of the calls, we\ncan get an idea of what is happening:\n\nInstance of Internet Explorer is created using CoCreateInstance\nIWebBrowser2->Navigate() is called, passing the C2 URL and gathered data as\narguments. This will cause IE to navigate to that URL\nIWebBrowser2->get_ReadyState() is called, comparing the return value with 4\n(READYSTATE_COMPLETE) – if it is 4, the function will continue, otherwise it\nwill sleep for 500 milliseconds and retry the call.\nIWebBrowser2->get_Document() is called, which physically loads in the page that has\nbeen navigated to.\nIUnknown->QueryInterface() is called, passing the CLSID for IHTMLDocument2 to\nit.\nIUnknown->QueryInterface() is called, passing the CLSID for IHTMLElement to it.\nIHTMLDocument2->get_Body() is called, which returns a pointer to the website\nbody.\nIHTMLElement->get_OuterText() is called, which returns the raw data from the C2\nserver\nThe data is then decrypted and parsed by the malware\n\n\n-----\n\nCOM usage currently seems quite popular among malware authors, possibly due to the fact\nthat it is often undetected by several anti malware programs, as well as being able to remain\n[under the radar from unsuspecting researchers, such as myself – such as this post by](https://www.cybereason.com/blog/banking-trojan-delivered-by-lolbins-ramnit-trojan)\nNocturnus Research Team, which details how the banking trojan Ramnit utilizes COM API\nto create scheduled tasks, in an attempt to remain persistent.\n\nSo that brings an end to this brief post – but make sure to stay tuned for a much longer post\non reversing ISFB, sometime this month!\n\n## 4 Comments\n\nComments are closed.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-01-15 - Analyzing COMmunication in Malware.pdf"
    ],
    "report_names": [
        "2019-01-15 - Analyzing COMmunication in Malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535929,
    "ts_updated_at": 1743041166,
    "ts_creation_date": 1653487998,
    "ts_modification_date": 1653487998,
    "files": {
        "pdf": "https://archive.orkl.eu/40fc71dcc2dd432e64b7b47c785e78a7ee838895.pdf",
        "text": "https://archive.orkl.eu/40fc71dcc2dd432e64b7b47c785e78a7ee838895.txt",
        "img": "https://archive.orkl.eu/40fc71dcc2dd432e64b7b47c785e78a7ee838895.jpg"
    }
}