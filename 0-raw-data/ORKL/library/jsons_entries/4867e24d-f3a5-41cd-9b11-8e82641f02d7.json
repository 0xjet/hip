{
    "id": "4867e24d-f3a5-41cd-9b11-8e82641f02d7",
    "created_at": "2024-04-12T20:30:48.163504Z",
    "updated_at": "2025-03-27T02:16:37.04469Z",
    "deleted_at": null,
    "sha1_hash": "f7dec0767e7b20e7b720801fcf5e9c2e17b65574",
    "title": "VB2020 paper: Lightweight emulation based IOC extraction for Gafgyt botnets",
    "authors": "",
    "file_creation_date": "2020-08-28T12:56:41Z",
    "file_modification_date": "2020-08-28T12:58:45Z",
    "file_size": 2189606,
    "plain_text": "-----\n\n**ABSTRACT**\n\nThe long-established botnet family of Gafgyt is still very active today. While new C2 servers emerge quickly, they usually\nremain active for only a few days. To effectively fight such quickly emerging while short-lived families, quick IoC extraction\nis import. In this paper I will introduce how to extract IoCs for Gafgyt by exploiting its characteristic C2 loop and by\nlightweight emulating its initConnection function. The introduced methods can also be used for variant classification and\ntracking. To better understand how Mirai code is used in Gafgyt, some widely used Mirai code is also investigated.\n\n**1. INTRODUCTION**\n\nGafgyt, also known as BASHLITE and Qbot [1], was designed to infect Linux devices to launch DDoS attacks, with the\noriginal version found in 2014. In recent years, we have observed the proliferation of Gafgyt variants. While that proliferation\ncan mainly be explained by the fact that the Gafgyt source code was leaked in 2015, the success of Mirai, together with its\nleaked source and tens of thousands of off-the-shelf vulnerable IoT devices, might also have contributed a lot to that.\n\nOn the other hand, Gafgyt botnets are usually short lived. According to our data, most of the tracked C2 servers only\nremained active for a few days. Therefore, quick IoC extraction would play an important role in fighting against such\nquickly emerging while short-lived botnets. In this paper the IoCs refer to two kinds of information: 1) the C2 server and\nport; 2) the register message. While in early variants the C2 server and port are usually stored in strings, later variants\nusually binary encode them, which makes them more difficult to extract. As for the register message, this is the first\nmessage a bot sends to its C2 server after establishing a connection. Sometimes it’s also referred to as check-in, call-home\nor HELLO. With the register message, we can: 1) define an IDS/IPS rule to distinguish Gafgyt communication from real\nnetwork traffic; 2) track its variants.\n\nFor the extraction of IoCs, we first turned to the use of a sandbox. While in most cases this works, there exist issues of\nevasion, deployment, long run time, and security risks such as network scanning. The second solution is static analysis\nbased. It works as follows:\n\n1. IoC related code snippets are located using their signatures, e.g. YARA.\n\n2. The relevant instructions are parsed to get the wanted data.\n\nThis solution relies heavily on static code signatures. Since Gafgyt targets multiple processor architectures, when a new\nvariant emerges, different signatures for each CPU architecture have to be defined, which is both tedious and time\nconsuming, and may also lead to the signature explosion issue.\n\nOn the other hand, fixed patterns, both static and dynamic, exist in Gafgyt’s C2 communication-related code. More\nspecifically, there is a characteristic C2 communication code loop in Gafgyt that can be recognized using its static patterns.\nWith the C2 loop, both the IoC of the register message and the function needed for lightweight emulation to extract C2\ninformation can be directly checked. That finding inspired me to develop the hybrid solution that will be introduced in this\npaper. Basically, it works in two steps: 1) recognizing the C2 loop with its CFG patterns; 2) lightweight emulating the\ntarget function to extract the C2 server and port. Compared with the sandbox solution, it’s easy to deploy, and since only a\nsubset of code is executed, the runtime is greatly reduced. Compared with a purely static analysis-based solution, the\nsignature explosion issue is eliminated since only a relatively small number of behaviour patterns are needed.\n\nThe remainder of this paper is organized as follows: in Section 2, I introduce the C2 loop, including its patterns and\nrecognition; in Section 3, I introduce the behaviour patterns in initConnection and how to use them to lightweight emulate\ninitConnection to extract the C2 server and port; in Section 4 I investigate some widely used Mirai code in Gafgyt with\nMirai’s characteristic encrypted configurations.\n\nTo summarize, the contributions of this paper are as follows:\n\n - I summarize the fixed patterns in the Gafgyt C2 loop and behaviour patterns in connection establishment that can be\nused for IoC extraction and variant classification.\n\n - I demonstrate a solution for automatically extracting C2 information by lightweight emulating a specific function with\nits behaviour patterns.\n\nSince Gafgyt targets multiple processor architectures, the same source code is usually compiled into multiple binaries. For\nreasons of simplicity and efficiency, only samples for x86, x64, MIPS and ARM are considered.\n\nThe SHA256 hashes for the samples discussed in this paper are given in Appendix A.\n\n**2. THE C2 LOOP AND CONNECTION ESTABLISHMENT**\n\nIn DDoS purposed botnets, the C2 communications including establishing connection, registering with the C2 server, and\nreceiving and responding commands, are usually embedded in a code loop which is called the C2 loop in this paper. When\nanalysing a new botnet family or unknown sample, the C2 loop is a good entry for reverse engineering its C2 protocol and\nextracting IoCs. Furthermore, C2 loops are usually specific to their families, thus can be used for family recognition and\nvariant classification.\n\n\n-----\n\nIn Gafgyt, the C2 loop is in main(), with connection establishing, registering, and command receiving done in three\nfunctions. In the leaked source and some unstripped samples, as shown in Figure 1, those three functions are separately\nnamed as initConnection, sockprintf, and recvLine. In some variants they might have different names. For example,\nsockprintf is also known as botnetPrint, HackerPrint, HeliosPrint and socketSend. For the convenience of describing, I will\nuse initConnection, sockprintf, and recvLine to refer to them.\n\n_Figure 1: Gafgyt C2 loop (MD5= 5264b21d93ce4668c3f8aac823924c04)._\n\nFor simplicity, a text format of loop description is introduced. The C2 loop in Figure 1 can be represented as follows:\n\n\"[initConnection][] -> [getBuild, sockprintf][\"BUILD %s\"] -> [recvLine][] -> [][]\"\n\nCode blocks are connected with ‘->’. Since we only care about the called functions and referenced strings, each block is\nrepresented with two ‘[]’, with the first ‘[]’ enclosing the called functions while the second one encloses the referenced\nstrings.\n\nWith the C2 loop, both the register message and the initConnection function can be directly obtained. The register message\nin Figure 1 corresponds to ‘BUILD %s’. And the initConnection function can be taken from the first block for further\nemulation to extract the C2 server and port. However, as new variants continuously emerge, C2 loops also vary in forms, as\nshown by the following lines:\n\n\"[initConnection][] -> [jprintf][\"arch %s\", \"unknown\"] -> [recvLine][] -> [][]\"\n\n\"[initConnection][] -> [][] -> [recvLine][] -> [][]\"\n\n\"[echoconnection][] -> [][] -> [recvLine][] -> [][]\"\n\n\"[initConnection][] -> [sprintf, sockprintf][\"fftt:%s\"] -> [recvLine][] -> [][]\"\n\n\"[Connection, botkiller, recv_buf][] \"\n\nFor better loop detection, common C2 loops are summarized into six types based on their CFG patterns. For each type, a\nset of criteria are defined in terms of block number, called functions, and referenced strings. For example, the C2 loop\nshown in Figure 1 belongs to type 1. Its criteria are as follows:\n\n1. The loop is composed of four blocks.\n\n2. Only one function is called in the first block, which corresponds to initConnection.\n\n3. At least two functions are called in the second block.\n\n4. At least one string containing ‘%s’ is referenced in the second block.\n\n5. Only one function is called in the third block.\n\n\n-----\n\nAll six types of C2 loops, together with their criteria, are illustrated in Appendix B. Their coverage stats on all 116,677\nsamples are illustrated in Table 1.\n\n**Type** **Samples**\n\n1 93,140\n\n2 4,344\n\n3 17,418\n\n4 801\n\n5 333\n\n6 641\n\n_Table 1: C2 loop stats._\n\nC2 loop detection is done in the static analysis stage. It includes two steps: 1) finding all loops in main(); 2) checking each\nloop type with the criteria introduced in Appendix B. The static analysis can be achieved with common scriptable reverse\nengineering tools, e.g. IDA, radare2. In my solution, radare2 is used.\n\nIn step 2, CFG patterns alone may not be enough to determine the loop type because it’s common for similar loops to exist\nin main(). The register message and characteristic of initConnection are used to solve that problem due to their tight\nconnections with the C2 loop. While some widely used format strings such as ‘BUILD %s’, ‘fftt %s’, ‘arch %s’ can be\ndirectly used to check the register message, the fact that ‘%s’ always exists in the format string is used to heuristically\ndetect other unknown register messages.\n\nGafgyt is also characteristic in its initConnection function in terms of CFG patterns and dynamic behaviours. More on that\nwill be introduced in Section 3. For simplicity, the criteria for determining initConnection are as follows:\n\n1. block_number >= 3 and block_number <= 16.\n\n2. edge_number >= block_number and edge_number <= block_number + 5.\n\n3. called_functions >= 2.\n\n4. referenced_string_number > 0.\n\nThe above criteria must be used together with the target C2 loop CFG patterns. As an example, consider the second sample\nof type 2 illustrated in Appendix B. In total, 16 loops can be found in main(), as shown in Figure 2. In step 2, each loop will\nbe checked with the illustrated type in turn. When it comes to the loop of ‘[fcn.0804d14f][] -> [][] -> [fcn.08048a8e][] -> []\n\n[]’, only after the loop CFG patterns successfully match type 2 would the function of fcn.0804d14f in the first block be\nmatched with the above initConnection criteria.\n\n_Figure 2: Similar loops exist in main() (MD5= 0967a1ad0056ca664e064a59e9f263e1)._\n\n**3. LIGHTWEIGHT EMULATING INITCONNECTION**\n\nBasically, lightweight emulation (LWE for short) is a kind of dynamic analysis technique. It has a long history of being\nused in detecting shellcode in network data [2]. Different from shellcode detection, a code snippet from an executable file,\nor the initConnection function in this paper, becomes the emulation target. The emphasis here changes from detecting\nsuspicious behaviours, e.g. locating a system API or loading a system DLL, to making sure the relevant behaviours are\nproperly executed. While it looks a bit similar to sandbox-based dynamic analysis, the difference lies in the fact that in\nLWE only a subset of code needs to be executed, and there are usually a very limited number of system services provided,\nor even none at all. For these reasons, the issues of external code/data dependency usually exist in LWE. Except that\ninstruction-level analysis is a MUST to detect the relevant behaviours.\n\nIn this paper, the aim of the LWE is to extract the C2 server and port by emulating the initConnection function checked\nwith the C2 loop. The solution can be divided into three stages: pre-handling, emulation, and post analysis. In pre-handling,\nthe function is inspected at instruction level to replace all function calls with NOPs. The purpose of that is to remove\nexternal code dependency. In the meantime, the calling addresses are saved for function call checking during emulation.\n\n|Type|Samples|\n|---|---|\n|1|93,140|\n|2|4,344|\n|3|17,418|\n|4|801|\n|5|333|\n|6|641|\n\n\n-----\n\nIn stage 2, the unicorn open-source emulation engine is used. Two hooks are installed to detect function calls and memory\nwrites. The first is named ‘SingleStep’. It is installed with the UC_HOOK_CODE API, thus will get called every time an\ninstruction is to be executed. It’s responsible for two tasks:\n\n1. When detecting the PC of NOP’ed call instructions, SingleStep will generate a CALL event together with a pre-set\nnumber of parameters.\n\n2. When detecting the PC of code ending address or an address beyond the initConnection range, SingleStep will stop\nthe emulation.\n\nThe second hook is named ‘HookWrite’. It is installed with the UC_HOOK_MEM_WRITE API. When a memory write is\ndetected, HookWrite will be called. It will log the WRITE event together with the write address, size and value.\n\nAfter emulation finishes, the recorded events and the final memory snapshot will be handed to post analysis for C2\nextraction. The event formats for exchanging behaviour information between stages 2 and 3 are shown in Figure 4. For\nsimplicity, a fixed number, defaulted to six in my solution, of parameters are recorded for each function call. For a memory\nwrite event, the enclosed parameters stand separately for write address, size and value.\n\nThe real extraction is based on the initConnection function’s behaviour patterns. They are defined by the called functions\nand memory writes. A behaviour pattern has two layers of meaning: pattern matching and rule applying. When a function’s\nbehaviours match a specific type of initConnection behaviour pattern, that pattern’s rules will be applied on the behaviours\nto have data extracted. As an example, consider the unstripped version of initConnection shown in Figure 3. The C2 IP and\nport of ‘198.134.120.150:23’ are stored in a global variable named commServer. After they get parsed by calling strcpy,\n_strchr, and atol, a C2 socket is created and connectTimeout is called to initialize the real connection. Since the function call_\nto strchr is NOP’ed with value 0 returned, the block where atol is called will not be emulated. The final behaviours are\nshown in Figure 4. For simplicity, only four parameters are shown for each call.\n\n_Figure 3: An unstripped version of initConnection (MD5=00432f33fb3f5cc5377266a5439567bf)._\n\n_Figure 4: Recorded behaviours._\n\nTwo patterns can be concluded for behaviours in Figure 4: ‘cw4cccw4c’ and ‘call_memset, w4, call_strcpy, call_strchr,\ncall_socket, w4, call_connectTimeout’. The first pattern is a simplified version for fast matching. Only those successfully\nmatched with ‘cw4cccw4c’ will be checked with the second one, where every function can be heuristically determined with\nits characteristic parameters as follows:\n\n\n-----\n\n1. For memset, arg1 points to stack memory while arg2 holding 0 and arg3 usually hold a const of 0x1000.\n\n2. For strcpy, arg1 and arg2 point separately to stack and global memory.\n\n3. For strchr, arg1 points to stack memory while arg2 holding 0x3a, which stands for ‘:’.\n\n4. For socket, there are always parameters of (2, 1, 0), or (2, 2, 0) in the case of MIPS CPU.\n\n5. For connectTimeout, arg2 is equivalent to arg1 of strcpy and strchr.\n\nIf successfully matched, the C2 IP and port can be retrieved from global memory pointed to by strcpy’s arg2, which is\n0x080557c0 in Figure 4.\n\nSimilar to the C2 loop, different versions of initConnection functions exist. For better data extraction, they are summarized\ninto six types in terms of behaviour patterns, as illustrated in Appendix C. Except for data extraction, the concluded types\ncan also be used for variant tracking. For example, the initConnection shown in Figure 3 has a slightly mutated version, as\nshown in Figure 5.\n\nThe only difference is that in Figure 3 the C2 IP is read from global memory, while in Figure 5 it is dynamically generated\nby calling sprintf() with a format of ‘%d.%d.%d.%d’. They share the same CFG patterns and simplified behaviour patterns.\nIn Appendix C, the initConnection functions in Figure 3 and 7 separately belong to types 1 and 2. Those sorts of similarities\ncan also be found between types 4 and 5, where htonl() is called in type 4 for four-byte binary encoded C2 IP, while\ninet_addr() for string format C2 IP.\n\n_Figure 5: A slightly mutated version of initConnection in Figure 3 (MD5=001618368ffd8735837267d9763b0fa1)._\n\n_Figure 6: A type 6 initConnection which has complex CFG (MD5= 3cda17370a9c72120001c44fba76b442)._\n\n\n-----\n\nAs mentioned above, LWE in this paper only makes sure relevant operations get emulated. That is for consideration of\nsimplicity. As an example, consider the type 6 initConnection shown in Figure 6. Its CFG is so complex that it’s difficult to\nmake sure every block get emulated.\n\nHowever, further studies show the relevant operations are all located in the first block, as shown in Figure 7. What we need\nto do is to make sure the first block is properly emulated, which will greatly simplify things.\n\n_Figure 7: The first block of the initConnection function in Figure 6._\n\nFor those cases where relevant operations are deep inside a function which has complex CFG, the common solution is to\nonly emulate the most related block(s), not the whole function. Sometimes the emulation might be done multiple times for\nseparate code snippets. In summary, the design philosophy of LWE-based IoC extraction is simplicity and flexibility.\nEquipped with proper behaviour patterns, it can easily be applied to other botnet families.\n\n**4. MIRAI CODE IN GAFGYT**\n\nSince both target the same set of Linux devices and both have had their source leaked, the code sharing between Mirai and\nGafgyt is very common, especially in infection vectors and integrated exploits [3, 4]. While it might be difficult to figure\nout every piece of shared code from Mirai in a Gafgyt sample, in most cases it’s possible to check the widely used Mirai\ncode in a Gafgyt sample with Mirai’s characteristic encrypted configurations that are tightly connected with features\nincluding scanning, killer, random string generation, and attacking [5]. When other botnet authors decide to borrow code\nfrom Mirai, the configuration-related data and code usually have to be copied together because it’s difficult to separate\nthem from the really wanted features. Those traces make it possible to research how Mirai code is used in Gafgyt by\nstudying the extracted configurations.\n\nIn summary, Mirai configurations have been successfully extracted from 3,700 Gafgyt samples with the automatic\nconfiguration extraction scheme introduced in [6]. They are grouped in the combination of item count, total size, and\nbranch name, with the stats illustrated in Table 2.\n\nIn Mirai, each configuration is numbered and is used in a manner of ‘unlock-retrieve-relock’, as shown in Figure 8.\nTherefore, the heavily used items can be figured out by tracking the related functions, e.g. table_retrieve_val.\n\n_Figure 8: Mirai ‘unlock-retrieve-relock’ style of configuration referencing._\n\n\n-----\n\n|Items_size_branch|samples|\n|---|---|\n|36_412_KYTON|3,346|\n|39_437|188|\n|39_417|63|\n|36_431_KYTON|36|\n|36_428_Reaper|14|\n|23_312_REKAI|14|\n|4_80|6|\n|23_283_REKAI|5|\n|24_394_REKAI|3|\n|15_201_ROOT|3|\n|24_302|2|\n|10_118|2|\n|34_384_KYTON|1|\n|22_296_REKAI|1|\n\n\n_Table 2: Stats of Mirai configurations in 3,700 Gafgyt samples._\n\nPopular groups of configurations in Table 2 have been manually investigated. The key findings are summarized as follows:\n\n1. Each group of samples shares the same configuration usage patterns. In most cases they can be classified as the\nsame variant.\n\n2. It’s strange that in the largest group of 36_412_KYTON, only one configuration item is used for random string\ngeneration, which has an index of 0x26 in Figure 9.\n\n3. The groups of 39_437, 39_417, 36_431_KYTON and 36_428_Reaper are very similar in both content and\nconfiguration referencing patterns. The configurations are widely used in scanner, killer, and random string\ngeneration. The four groups of samples are probably derived from the same code branch.\n\n_Figure 9: Extracted configurations for 36_412_KYTON._\n\n\n-----\n\n**5. CONCLUSION**\n\nI have introduced how to extract the IoCs of Gafgyt’s register message and C2 by detecting its characteristic C2 loop and\nlightweight emulating the initConnection function. The C2 loop and initConnection function can also be used for variant\ntracking and classification. Meanwhile, using the techniques introduced in Section 2 and 3, new samples beyond the types\nillustrated in Appendix B and C can also be analysed.\n\nI also introduced the general ideas of LWE-based data extraction. Compared with sandbox-based dynamic analysis, a\nLWE-based solution is easier to deploy and more flexible. Equipped with new behaviour patterns, LWE-based data\nextraction can also be applied to other botnet families.\n\nFinally, I investigated the widely used Mirai code in Gafgyt by extracting Mirai characteristic encrypted configurations. It\nshows Mirai code can be tracked by analysing its configuration. The tracked code also helps to classify Gafgyt variants.\n\n**REFERENCES**\n\n[1] BASHLITE, https://malware.wikia.org/wiki/BASHLITE.\n\n[2] libemu – x86 Shellcode Emulation, http://libemu.carnivore.it/.\n\n[3] Tweets by @0xrb, https://twitter.com/0xrb.\n\n[4] Tweets by @bad_packets, https://twitter.com/bad_packets.\n\n[5] Mirai source code. https://github.com/jgamblin/Mirai-Source-Code/tree/master/mirai.\n\n[6] Liu, Y.; Wang, H. Tracking Mirai Variants. Proceedings of the Virus Bulletin International Conference 2018.\nhttps://www.virusbulletin.com/virusbulletin/2018/12/vb2018-paper-tracking-mirai-variants/.\n\n**APPENDIX A: SHA256 OF SAMPLES**\n\nMD5 hash: 00b310f837972e972d12dea0661302f3\nSHA-256 hash: 14b626834274d346f67e04849a5409c8710bfccc2cb718dbcc4995fab5e451fb\n\nMD5 hash: 02cc10ebf07c6f70b3437340bec1a265\nSHA-256 hash: 372a4b0f5a347fb8d6642c88aa89793fd5efe71d577db619d8a7ddab18133311\n\nMD5 hash: 08e57e7ed679df8cd9891f596ba8d8ca\nSHA-256 hash: 4e5759b33d3be016bf6f58cb080539f83085a7c51c451d15bce9aadf99773cb2\n\nMD5 hash: 0967a1ad0056ca664e064a59e9f263e1\nSHA-256 hash: 68c20f82fe5385458a9fc6539b2dd5928ea34d039c182218292d224e61be8d1a\n\nMD5 hash: 0000e22a5cd366b112a0f1112c565ac7\nSHA-256 hash: b5b7effe9052e9e1669ed6a14c72ecd20080ee0d57d8d3e4759061d75f7e5c09\n\nMD5 hash: 00037f246c41482b7175201c515e2a1c\nSHA-256 hash: a2d787f4d0d46a88778d31498c5f2ce49e981fa6201ebc4223d7079c7bb86e7c\n\nMD5 hash: 0003d90a31eb72caf045ea7f622d4dc5\nSHA-256 hash: d4238cf7504d41bd11ebbbaec60bea6a2b9d8d136325bfbb498df4f0b3ab215f\n\nMD5 hash: 000a6673dcde7dfd646fdc946a3e305f\nSHA-256 hash: 92abff4b88db8fcdb9936f29a101c800b3d3402b7ce6c313a2149e23df76dc6f\n\nMD5 hash: 001618368ffd8735837267d9763b0fa1\nSHA-256 hash: 51caa96d031214644e1ebf7604983f4da4eb95c95a4efd4f8967319780bb1fa3\n\nMD5 hash: 00432f33fb3f5cc5377266a5439567bf\nSHA-256 hash: a30c66532a7e54fa8484c0ef36d93a6ffa14cb923981254846e73db9a444e95f\n\nMD5 hash: 005cec5d3928f5c5534f4b46989029a8\nSHA-256 hash: 811e56ef2dc70b5b44c94b292248ee25cf44a51f99751755febd2bb34d92a3aa\n\nMD5 hash: 05536b105070a1aeb6ceeee4dd5043c8\nSHA-256 hash: 9ef45c92c861014ff3011e2ad7b774c62a878893530b6da5603cf0b79517fe9e\n\n\n-----\n\nMD5 hash: 056470bb9476d108d8042a5b5c70d1b9\nSHA-256 hash: 5dfa3c6d09679fde54184c34d8f0d11fbafe5bb3d4b301cded60cf7b55a61d1b\n\nMD5 hash: 09501d91c5adccc72c1884a5d931eb9c\nSHA-256 hash: 4e5e86ed730ff2ced1753798f9f184e316f831dd75f64001653e1b4ac00b7763\n\nMD5 hash: 0a115b05c9508672068c82c52e538028\nSHA-256 hash: a6051ce614dabba21e510a8013dc8580d427c86ca50a9b73501e3fe0b524dc04\n\nMD5 hash: 142c0e7d864fa156b4622062cca27f8d\nSHA-256 hash: 608a455651e6fbba5caeedf71e29e4731f01d38e20dd0acd074052bfc0e00d53\n\nMD5 hash: 23c0f0ea828c65b3e2502c9cfc24f91f\nSHA-256 hash: 77193fb6262e7f8908f45aba9b1c9bc3aa7d997830aef6254665457430d72eb4\n\nMD5 hash: 3cda17370a9c72120001c44fba76b442\nSHA-256 hash: a3b38780263a927af94692c752d834df6b739e1621f1652e677d6541a0529c14\n\nMD5 hash: 44e8a1908f234eb43ef081652d17e8a0\nSHA-256 hash: fb64c45838237be9ff218a0d96e9f16985013e75e72b9802d3428084e53176af\n\nMD5 hash: d5a54f8d85dd2e653ef4ce1533e0cc9c\nSHA-256 hash: 41c8961f18e54973a11e3ae34b4bbd8a889a69655eaa0d6907adb63e11c0466e\n\nMD5 hash: 5264b21d93ce4668c3f8aac823924c04\nSHA-256 hash: 55e2e2c8f4c24c83f3f9d7eda7b3a3c4c85879bc4326cc27e901bc651dd518db\n\n**APPENDIX B: SIX TYPES OF C2 LOOPS**\n\n**Type 1**\n\nCriteria:\n\n1. There are four blocks included in the loop.\n\n2. Only one function is called in the first block.\n\n3. At least two functions are called in the second block.\n\n4. At least one string is referenced in the second block.\n\n5. Only one function is called in the third block.\n\nExample 1: MD5=0000e22a5cd366b112a0f1112c565ac7, mips32\n\n\"[initConnection][] -> [getBuild, sockprintf][\"mips\", \"arch %s\"] -> [recvLine][] -> [][]\"\n\nExample 2: MD5=000a6673dcde7dfd646fdc946a3e305f, x86\n\n\"[fcn.0804d08d][] -> [fcn.0804d3cb, fcn.0804882a][\"BUILD %s\"] -> [fcn.0804916b][] -> [][]\"\n\n**Type 2**\n\nCriteria:\n\n1. There are four blocks included in the loop.\n\n2. Only one function is called in the first block, and it must match the initConnection criterion.\n\n3. No functions and strings are referenced in the second block.\n\n4. Only one function is called in the third block.\n\nExample 1: MD5=0003d90a31eb72caf045ea7f622d4dc5, arm32\n\n\"[initConnection][] -> [][] -> [recvLine][] -> [puts][\"LINK CLOSED\"]\"\n\nExample 2: MD5= 0967a1ad0056ca664e064a59e9f263e1, x86\n\n\"[fcn.0804d14f][] -> [][] -> [fcn.08048a8e][] -> [][]\"\n\n\n-----\n\n**Type 3**\n\nCriteria:\n\n1. There are three blocks.\n\n2. Only one functions is called per block.\n\n3. The function called in the second block must match the initConnection criterion.\n\nExample 1: MD5=00037f246c41482b7175201c515e2a1c, arm32\n\n\"[fork][] -> [initConnection][] -> [sleep][]\"\n\nExample 2: MD5= 02cc10ebf07c6f70b3437340bec1a265, x86\n\n\"[fcn.0804db3c][] -> [fcn.0804d16b][] -> [fcn.08050b60][]\"\n\n**Type 4**\n\nCriteria:\n\n1. There is a string of ‘fftt:%s’ referenced in the loop.\n\n2. There must be functions called in the first or second block, and there must be one function matching the\ninitConnection criterion.\n\nExample 1: MD5=005cec5d3928f5c5534f4b46989029a8, arm32\n\n\"[initConnection][] -> [sprintf, sockprintf][\"fftt:%s\"] -> [recvLine][] -> [][]\"\n\nExample 2: MD5= 00b310f837972e972d12dea0661302f3, arm32\n\n\"[][] -> [fcn.00009a8c][] -> [][\"fftt:\"] -> [fcn.0000c5c0, fcn.0000c4e0][\"idk\"] -> [fcn.00009f24]\n\n[] -> [fcn.0000ae70][]\"\n\nExample 3: MD5=0a115b05c9508672068c82c52e538028, x64\n\n\"[fcn.004003f1][] -> [fcn.00403420, fcn.00400a3a, fcn.00401c0b][\"fftt:%s\"] -> [fcn.004030c8][] ->\n\n[][]\"\n\n**Type 5**\n\nCriteria:\n\n1. There is only one block.\n\n2. At least one function is called in the first block, and one of them must match the initConnection criterion.\n\nExample 1: MD5=23c0f0ea828c65b3e2502c9cfc24f91f, x64\n\n\"[Connection,recv_buf][]\"\n\nExample 2: MD5= 08e57e7ed679df8cd9891f596ba8d8ca, arm32\n\n\"[Connection, botkiller, recv_buf][]\"\n\nExample 3: MD5=142c0e7d864fa156b4622062cca27f8d, x64\n\n\"[fcn.00404420][]\"\n\n**Type 6**\n\nCriteria:\n\n1. It does not match types 1 to 5.\n\n2. At least one string containing ‘%s’ is referenced in the loop.\n\n3. At least one of the called functions matches initConnection.\n\nExample 1: MD5=056470bb9476d108d8042a5b5c70d1b9, arm32\n\n\"[initConnection][] -> [][] -> [__GI_strchr][] -> [getDistro, access][\"/etc/ssh/\"] -> [access]\n\n[\"/etc/dropbear/\"] -> [__GI_asprintf][\"ARM4\", \"AUTH %s %s %s.%s %d %s %s %s\", \"1.7.9\"] ->\n\n[sockprintf, free][] -> [recvLine][]\"\n\nExample 2: MD5=05536b105070a1aeb6ceeee4dd5043c8, x86\n\n\"[initConnection][] -> [getBuild, sockprintf][\"unknown\", \"arch %s\"] -> [sockprintf][\"unknown\",\n\"Multiple Processors Detected: Starting Scanners %s\"] -> [][] -> [recvLine][] -> [][]\"\n\n\n-----\n\nExample 3: MD5=09501d91c5adccc72c1884a5d931eb9c, x86\n\n\"[fcn.08048f40][] -> [fcn.0804e0bf][\"22\", \"/usr/bin/python\"] -> [fcn.0804e0bf][\"/usr/bin/\npython3\"] -> [fcn.0804e0bf][\"/usr/bin/perl\"] -> [fcn.0804e0bf][\"/usr/sbin/telnetd\"] -> []\n\n[\"Unknown Port\"] -> [fcn.0804f5a8, fcn.08048d40][\"x86_32\", \"[0m[[36mKanashi[0m][[36m%s[0m]\n\n[36m:[0m[[36m%s[0m] [36m>[0m [[36m%s[0m]\"] -> [fcn.08048750][]\"\n\n**APPENDIX C: SIX TYPES OF INITCONNECTION**\n\n**Type 1**\n\nMD5= 00432f33fb3f5cc5377266a5439567bf, x86\n\nSimplified pattern: ‘cw4cccw4c’\n\nBehaviour pattern: ‘call_memset, w4, call_strcpy, call_strchr, call_socket, w4, call_connectTimeout’\n\nStatic pattern: blocs=11, edges=14, called_functions=7, strs=[“198.134.120.150:23”]\n\nExtraction rules:\n\nReading global memory pointed by arg2 of strcpy() to get the string format of ‘C2:port’\n\n**Type 2**\n\nMD5= 001618368ffd8735837267d9763b0fa1, x64\n\nSimplified pattern: ‘cw4cccw4c’\n\nBehaviour pattern: ‘call_memset, w4, call_sprintf, call_strchr, call_socket, w4, call_connectTimeout’\n\nStatic pattern: blocs=11, edges=14, called_functions =7, strs=[“%d.%d.%d.%d”]\n\nExtraction rules:\n\n1. IP is generated by concatenating arg3 to arg6 of sprintf with the format of ‘%d.%d.%d.%d’.\n\n2. Port is read from arg3 of connectTimeout.\n\n**Type 3**\n\nMD5= 3cda17370a9c72120001c44fba76b442, arm32\n\nSimplified pattern: ‘cccw4cccc’\n\nBehaviour pattern: ‘call_fcntl, call_fcntl, call_socket, w4, call_inet_addr, call_connect’\n\nStatic pattern: blocs=10, edges=14, called_functions =7, strs=[“167.71.33.152”]\n\nExtraction rules:\n\n1. C2 IP is read from the global memory pointed to by arg of inet_addr.\n\n2. Port is read from the memory pointed to by arg2 of connect() according to the definition of struct sockaddr.\n\n**Type 4**\n\nMD5= 44e8a1908f234eb43ef081652d17e8a0, x64\n\nSimplified pattern: ‘cccw4cccc’\n\nBehaviour pattern: ‘call_fcntl, call_fcntl, call_socket, w4, call_htons, call_htonl, call_connect, call_puts’\n\nStatic pattern: blocs=4, edges=4, called_functions =7, strs=[“Unable To Connect! ”, “Succesfully Connected! ”]\n\nExtraction rules:\n\n1. C2 IP is read from arg1 of htonl(), while port from arg1 of htons().\n\n**Type 5**\n\nMD5= d5a54f8d85dd2e653ef4ce1533e0cc9c, x86\n\nSimplified pattern: ‘cccw4cccc’\n\nBehaviour pattern: ‘call_fcntl, call_fcntl, call_socket, w4, call_htons, call_inet_addr, call_connect, call_puts’\n\nStatic pattern: blocs=4, edges=4, called_functions =7, strs=[“Unable To Connect! ”, “Succesfully Connected! ”]\n\n\n-----\n\nExtraction rules:\n\n1. C2 IP is read from arg1 of inet_addr(), while port from arg1 of htons.\n\n**Type 6**\n\nMD5= 3cda17370a9c72120001c44fba76b442, arm32\n\nSimplified pattern: ‘cccw4ccc’\n\nBehaviour pattern: ‘call_fcntl, call_fcntl, call_socket, w4, call_inet_addr, call_connect’\n\nStatic pattern: blocs=10, edges=14, called_functions =7, strs=[“167.71.33.152”]\n\nExtraction rules:\n\n1. C2 IP is read from the global memory pointed to by arg of inet_addr.\n\n2. Port is read from the memory pointed to by arg2 of connect() according to the definition of struct sockaddr.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://vb2020.vblocalhost.com/uploads/VB2020-Liu.pdf"
    ],
    "report_names": [
        "VB2020-Liu.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f0bccc3d-ad77-49c4-8dfd-8a8a8d6fba26",
            "created_at": "2024-05-01T02:03:08.134022Z",
            "updated_at": "2025-03-27T02:05:17.415028Z",
            "deleted_at": null,
            "main_name": "NICKEL FOXCROFT",
            "aliases": [
                "Group 123 ",
                "Moldy Pisces ",
                "RICOCHET CHOLLIMA ",
                "Reaper ",
                "ScarCruft ",
                "APT37 "
            ],
            "source_name": "Secureworks:NICKEL FOXCROFT",
            "tools": [
                "ROKRAT"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "9b02c527-5077-489e-9a80-5d88947fddab",
            "created_at": "2022-10-25T16:07:24.103499Z",
            "updated_at": "2025-03-27T02:02:10.108504Z",
            "deleted_at": null,
            "main_name": "Reaper",
            "aliases": [
                "APT 37",
                "ATK 4",
                "Cerium",
                "Crooked Pisces",
                "Geumseong121",
                "Group 123",
                "ITG10",
                "InkySquid",
                "Moldy Pisces",
                "Opal Sleet",
                "Operation Are You Happy?",
                "Operation Battle Cruiser",
                "Operation Black Banner",
                "Operation Daybreak",
                "Operation Dragon messenger",
                "Operation Erebus",
                "Operation Evil New Year",
                "Operation Evil New Year 2018",
                "Operation Fractured Block",
                "Operation Fractured Statue",
                "Operation FreeMilk",
                "Operation Golden Bird",
                "Operation Golden Time",
                "Operation High Expert",
                "Operation Holiday Wiper",
                "Operation Korean Sword",
                "Operation North Korean Human Right",
                "Operation Onezero",
                "Operation Rocket Man",
                "Operation SHROUDED#SLEEP",
                "Operation STARK#MULE",
                "Operation STIFF#BIZON",
                "Operation Spy Cloud",
                "Operation Star Cruiser",
                "Osmium",
                "Red Eyes",
                "Ricochet Chollima",
                "Ruby Sleet",
                "ScarCruft",
                "TA-RedAnt",
                "TEMP.Reaper",
                "Venus 121"
            ],
            "source_name": "ETDA:Reaper",
            "tools": [
                "Agentemis",
                "BLUELIGHT",
                "Backdoor.APT.POORAIM",
                "CARROTBALL",
                "CARROTBAT",
                "CORALDECK",
                "Cobalt Strike",
                "CobaltStrike",
                "DOGCALL",
                "Erebus",
                "Exploit.APT.RICECURRY",
                "Final1stSpy",
                "Freenki Loader",
                "GELCAPSULE",
                "GOLDBACKDOOR",
                "GreezeBackdoor",
                "HAPPYWORK",
                "JinhoSpy",
                "KARAE",
                "KevDroid",
                "Konni",
                "MILKDROP",
                "N1stAgent",
                "NavRAT",
                "Nokki",
                "Oceansalt",
                "POORAIM",
                "PoohMilk",
                "PoohMilk Loader",
                "RICECURRY",
                "RUHAPPY",
                "RokRAT",
                "SHUTTERSPEED",
                "SLOWDRIFT",
                "SOUNDWAVE",
                "SYSCON",
                "Sanny",
                "ScarCruft",
                "StarCruft",
                "Syscon",
                "VeilShell",
                "WINERACK",
                "ZUMKONG",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1712953848,
    "ts_updated_at": 1743041797,
    "ts_creation_date": 1598619401,
    "ts_modification_date": 1598619525,
    "files": {
        "pdf": "https://archive.orkl.eu/f7dec0767e7b20e7b720801fcf5e9c2e17b65574.pdf",
        "text": "https://archive.orkl.eu/f7dec0767e7b20e7b720801fcf5e9c2e17b65574.txt",
        "img": "https://archive.orkl.eu/f7dec0767e7b20e7b720801fcf5e9c2e17b65574.jpg"
    }
}