{
    "id": "1e6b3f5f-153e-4217-96ec-e18aaebea6b9",
    "created_at": "2023-01-12T15:07:27.119181Z",
    "updated_at": "2025-03-27T02:12:11.06757Z",
    "deleted_at": null,
    "sha1_hash": "1fba4cdfd10a9d9512a02df8b82db9483ffa065c",
    "title": "2014-07-18 - Bird's nest",
    "authors": "",
    "file_creation_date": "2022-05-27T19:01:25Z",
    "file_modification_date": "2022-05-27T19:01:25Z",
    "file_size": 235211,
    "plain_text": "# Bird's nest\n\n**virusbulletin.com/virusbulletin/2014/08/bird-s-nest**\n\n2014-07-18\n\n### Raul Alvarez\n\nFortinet, Canada Editor: Martijn Grooten\n**Abstract**\n\nUsually, prepending viruses are relatively easy to clean and remove – just cut off the\nprepended virus and, in theory, the host file should be restored. However, in the case of\nprepending file infector Neshta, simply cutting the virus off will not do the job. Raul Alvarez\ntakes a close look at Neshta, and at why it can't be removed as simply as other prepending\ninfectors.\n\nOne of the ways in which file infectors are categorized is by how they attach themselves to\nthe host file. The categories are: cavity, appending and prepending. A cavity virus infects a\nfile by attaching itself to the available spaces in the host file, while an appending virus\nattaches its code at the end of the file, and of course, a prepending virus can be seen at the\nbeginning of the victim file.\n\nUsually, prepending viruses are easier to clean and remove from the infected file than the\nother types – just cut off the prepended virus and, in theory, the host file should be restored.\n\nHowever, in the case of prepending file infector Neshta, simply cutting the virus off will not do\nthe job. In this article, we will take a closer look at Neshta, and at why it can’t be removed as\nsimply as other prepending infectors. Neshta is not new, yet we are still finding samples of it\nin the wild.\n\n## Simple decryption\n\nBefore we go into the details of how Neshta prepends its code to a host file, let’s look into\nsome of its initialization routines.\n\nNeshta decrypts some of its encrypted data using a simple decryption algorithm. The\nalgorithm has a loop that decrypts each byte using the following routine:\n\nA variable is multiplied by 0x8088405 using signed integer multiplication. (The initial\nvalue of the variable is the counter, which is the number of bytes to decrypt.)\n\n\n-----\n\nThe product of the multiplication, plus 1, is saved as the next value of the variable for\nthe next itera-tion.\n\nThe same product is multiplied by 0xFF to produce the decrypted byte, which is in the\nDL register.\n\nThe byte in the DL register is copied into the AL register, then it is XORed to the\nencrypted byte to get the equivalent decrypted version (see Figure 1).\n\nThe decryption algorithm is used several times to obtain the following relevant strings: ‘3582490’, ‘exe’ and ‘*.*’.\n\n**Figure 1. Decryption.**\n\n[(Click here to view a larger version of Figure 1.)](https://www.virusbulletin.com/uploads/images/figures/2014/07/Neshta-1-large.jpg)\n\n## Preparing the %temp% folder\n\nThe malware opens a copy of itself using a combination of the GetModuleFileNameA and\nCreateFileA APIs. Note that the file consists of the virus component and the host file. Then,\nNeshta extracts 41,472 (0xA200) bytes of the virus component by reading it into memory\nusing the ReadFile API.\n\n\n-----\n\nThis is followed by getting the size of the infected file using the FindFirstFileA API. This is an\nunusual method, since the malware could just use a simple call to the GetFileSize API.\nAlthough the method works, the resulting WIN32_FIND_DATA structure contains the size of\nthe file as well as other information.\n\nNext, Neshta gets the %temp% folder name using a call to the GetTempPathA API. This is\nfollowed by concatenating one of the decrypted strings, ‘3582-490’, to the temporary folder,\nproducing the pathname ‘%temp%\\3582-490’. The malware checks if the pathname exists by\ncalling the GetFileAttributesA API. If it doesn’t, it creates the pathname using the\nCreateDirectoryA API.\n\nThis is followed by concatenating another decrypted string, ‘*.*’, producing ‘%temp%\\3582490\\*.*’. Using a combination of the FindFirstFileA and FindNextFileA APIs, the malware\nattempts to list all the files found in the ‘%temp%\\3582-490\\’ folder, and tries to delete them\none by one, using the DeleteFileA API.\n\n## Restoring the host file\n\nAfter deleting all possible files that can be found in the ‘%temp%\\3582-490\\’ folder, the\nmalware extracts the filename of the current module from the result of the call to the\nGetModuleFileNameA API. The extracted filename, such as ‘calc.exe’, is concatenated to\nthe ‘%temp%\\3582-490\\’ folder, producing ‘%temp%\\3582-490\\calc.exe’. (Assuming that the\ncurrent module is the infected version of the file, calc.exe.)\n\nThis is followed by creating ‘%temp%\\3582-490\\calc.exe’ using the CreateFileA API with\nGENERIC_WRITE access in preparation for restoring the clean version of the host file.\n\nFocusing back on the infected module, Neshta gets the file size of the infected calc.exe\nusing the GetFileSize API, and subtracts 41,472 (0xA200) bytes from it. The difference is\nused to set the file pointer to the last 41,472 bytes of the infected file. This is followed by\nreading 41,472 (0xA200) bytes of data from the file into the stack memory.\n\nUsing the same decryption algorithm as discussed earlier, the malware decrypts the first\n1,000 (0x3E8) bytes of the recently read data. Instead of using the counter, the malware\nuses the value 0x5A4D77D7 as a seed (see Figure 1).\n\nIt is worth mentioning that the first 1,000 (0x3E8) bytes are the only encrypted data in the\nhost file. These bytes comprise the MZ/PE header of the original host file.\n\nAfter the decryption, Neshta writes the 41,472 (0xA200) bytes to the ‘%temp%\\3582490\\calc.exe’ file, including the decrypted header.\n\nTo read the second block, the malware sets the file pointer 41,472 bytes from the beginning\nof the infected file using the SetFilePointer API (basically skipping over the virus component).\nThen it calculates the size of the remaining content of the host file (calc.exe), and reads it\n\n\n-----\n\ninto an allocated section of virtual memory using the ReadFile API. Finally, it writes the\nsecond block to the ‘%temp%\\3582-490\\calc.exe’ file. Then the handles for both files –\ninfected and restored – are closed using the CloseHandle API.\n\nThe restored ‘%temp%\\3582-490\\calc.exe’ file is an exact copy of the original clean file\n(calc.exe). Note that calc.exe is just one example of a file infected by Neshta. If another\ninfected file, such as notepad.exe, is executed, it will also be restored in the ‘%temp%\\3582490\\’ folder for this variant of the malware.\n\nNeshta executes the host file from the ‘%temp%\\3582-490\\’ folder to avoid raising suspicion\nthat the file is infected, using a call to the ShellExecuteA API.\n\n## Hosting svchost\n\nAfter restoring and executing the host file, Neshta gets the ‘%windows%’ folder name by\ncalling the GetWindowsDirectoryA API. Then, using the same decryption algorithm, the\nmalware generates the string ‘svchost.com’ and concatenates it to the Windows folder name,\nproducing ‘%windows%\\svchost.com’. Then, it checks whether ‘%windows%\\svchost.com’\nexists using the GetFileAttributesA API. If it does, the malware deletes the file using the\nDeleteFileA API.\n\nAfter making sure that the ‘%windows%\\svchost.com’ file does not exist, the malware\ncreates it using a call to the CreateFileA API with GENERIC_WRITE access.\n\nThe malware reads the virus component of the infected file into memory, as discussed\nearlier. These bytes are written to the ‘%windows%\\svchost.com’ file using the WriteFile API.\nThen, to finalize the routine, the malware closes the handle of the file using the CloseHandle\nAPI.\n\nThe file ‘%windows%\\svchost.com’ is now an exact copy of the virus.\n\n## Modifying the shell key\n\nAfter dropping the virus component as svchost.com, the malware generates the string\n‘exefile\\shell\\open\\command’ using the same decryption algorithm. Then it opens the registry\nkey ‘HKEY_CLASSES_ROOT\\exefile\\shell\\open\\command’ using the RegOpenKeyExA API.\nAfterwards, another string, ‘\"%1\" %*’, is generated using the same decryption algorithm.\n\nThis is followed by setting the registry key\n‘HKEY_CLASSES_ROOT\\exefile\\shell\\open\\command’ with ‘C:\\WINDOWS\\svchost.com\n\"%1\" %*’ as the data value using the RegSetValueExA API.\n\nIn a normal system installation, if the key\n‘HKEY_CLASSES_ROOT\\exefile\\shell\\open\\command’ is missing or corrupted, any attempt\nto execute an application will not work, and an error message will be displayed, as shown in\n\n\n-----\n\nFigure 2.\n\n**Figure 2. In a normal system installation, an error message will be displayed when**\n**attempting to execute an application if the**\n**‘HKEY_CLASSES_ROOT\\exefile\\shell\\open\\command’ key is corrupted or missing.**\n\nHowever, a system infected with Neshta will have the modified registry key\n‘HKEY_CLASSES_ROOT\\exefile\\shell\\open\\command’ with ‘C:\\WINDOWS\\svchost.com\n\"%1\" %*’. Since C:\\WINDOWS\\svchost.com is the virus itself, an application will run, with the\nvirus becoming the parent process and the .exe file the child process. This is a unique\nmethod to make sure that the malware will run even after restarting the system.\n\n## Creating a mutex\n\nAnother pass to the decryption algorithm reveals the string ‘MutexPolesskayaGlush*.*’,\nwhich is used as the name of a mutex created using a call to the CreateMutexA API. This is\nused to avoid running multiple instances of the malware.\n\n## Infecting removable drives\n\nAfter creating the mutex, Neshta searches for available drives for infection. It lists the\navailable logical drives in the system using the GetLogicalDriveStringsA API. Using the\nGetDriveTypeA API, it skips the infection routine for the CD-ROM drive, drive ‘A’ and drive\n‘B’.\n\nWith the exception of the list of drives to avoid, the malware tries to infect the executable files\nfound on any attached removable drives (such as USB flash drives), all connected hard\ndisks, and mapped network shared folders.\n\n\n-----\n\nThe malware traverses each folder in each drive searching for executable files for possible\ninfection.\n\n## Skipping unwanted folders\n\nIf an executable file with the ‘.exe’ extension name is found, Neshta gets its equivalent short\npath name using the GetShortPathNameA API. The short path name is the MS DOS-style\nnaming convention. It has 8:3 form, where eight is the number of characters in the filename\nand three is the number of characters in the extension name.\n\nThis is followed by getting the ‘%windows%’ folder name using the GetWindowsDirectoryA\nAPI. The malware skips the infection routine if the current short path name of the victim file\ncontains the ‘%windows%’ folder name. It also skips the infection routine if the victim file is\ninside the ‘%temp%’ folder and if the path name of the victim file contains ‘PROGRA~1’ (the\nshort name for ‘Program Files’).\n\nWhen the path name has passed the filtering, it gets the size of the victim file using the\nFindFirstFileA API. The file size is taken from the resulting WIN32_FIND_DATA structure.\nConsidering the file size, Neshta also skips the infection routine if the size is less than or\nequal to 41,472 (0xA200) bytes, or greater than 10,000,000 (0x989680) bytes.\n\nThe following section discusses how the malware determines whether the victim is already\ninfected or not.\n\n## Avoiding reinfection\n\nInitially, Neshta opens the victim file using the CreateFileA API. Then it sets the file pointer\n1,000 (0x3E8) bytes from the beginning of the file. Afterwards, it reads 256 (0x100) bytes\ninto memory using the ReadFile API, and closes the file using the CloseHandle API.\n\nTo avoid reinfection, the malware compares the 256 (0x100) bytes of the data read from the\nvictim file against the virus component’s data from the memory. If these bytes match, the\nmalware will skip the infection routine.\n\n## Infection routine\n\nOnce the victim file has passed through all the necessary filtering, it is ready for infection.\nThe first thing the malware does is to get the attributes of the victim file using the\nGetFileAttributesA API. If the file has an attribute of FILE_ATTRIBUTE_READONLY, the\nmalware sets it back to 0, using the SetFileAttributesA API.\n\nUsing a series of calls to the ExtractIconA, GetIconInfo, GetObjectA, and DeleteObject APIs,\nthe malware copies the icon used by the victim file into memory as part of the virus\ncomponent.\n\n\n-----\n\nSince Neshta is a prepending file infector, the first 41,472 (0xA200) bytes of each infected\nfile belongs to the virus. A different block of data near the end of the virus component is a\ncopy of the icon of the infected host file.\n\nThis is followed by opening the victim file with GENERIC_READ | GENERIC_WRITE access\nusing the CreateFileA API. The malware reads the first two bytes and checks whether the file\nis a valid executable file by checking for the string ‘MZ’. Then, it sets the file pointer to the\nbeginning of the file using the SetFilePointer API.\n\nThen, Neshta reads the first 41,472 (0xA200) bytes of the victim file using the ReadFile API.\nUsing the encryption/decryption algorithm discussed earlier, the malware encrypts the first\n1,000 (0x3E8) bytes of the recently read data, with the constant value 0x5A4D77D7 as a\nseed. Note that this is the same seed as was used to restore the original host file from the\nprevious infection.\n\nA regular prepending virus pushes the content of the victim file down to the end of the file,\nand places the virus component at the very beginning. However, instead of pushing the\noriginal bytes down, Neshta overwrites the first 41,472 (0xA200) bytes of the victim file with\nthe virus component, using a combination of the SetFilePointer (to move the pointer to the\nbeginning of the victim file) and WriteFile APIs.\n\nAfterwards, the malware sets the file pointer to the end of the victim file and writes another\n41,472 (0xA200) bytes of data, once again using a combination of the SetFilePointer (to\nmove the pointer to the end of the victim file) and WriteFile APIs.\n\nThe data written at the end of the host file includes the newly encrypted 1,000 header bytes\nand the rest of the first 41,472 (0xA200) bytes of the victim file. These bytes are the original\ncontent taken from the beginning of the file which were overwritten with the virus component.\n\nTo finalize the infection routine, the malware closes the handle of the now infected file.\n\nFinally, the malware traverses each folder in every selected drive to look for executable files\nto infect. After infecting all possible files, the malware terminates the current process. Note\nthat the restored host executable file is still running, thus the malware only terminates the\nvirus component’s execution.\n\n## Wrap up\n\nAt first glance, Neshta looks like a simple prepending file infector. Detection of this malware\nis fairly easy since it is not polymorphic or metamorphic. In terms of cleaning, the encrypted\nheader should be restored first and copied to the beginning of the infected file.\n\nHowever, closer inspection of its malicious code reveals that Neshta is tricky in nature. It has\nembedded garbage code that works as a normal collection of instructions that are used\nthroughout the virus body. It also uses several linked function calls that only perform simple\n\n\n-----\n\ntasks.\n\nAs simple as it looks, one of the goals of the malware is to deter researchers from performing\ncode analysis. In this regard, even a piece of malware with a strong encryption algorithm\nmay seem easier to analyse than Neshta, as once the algorithm is broken down, analysis is\nstraightforward.\n\nIn the end, as the old adage says, ‘Patience is a virtue’.\n\n## Latest articles:\n\n### Cryptojacking on the fly: TeamTNT using NVIDIA drivers to mine cryptocurrency\n\nTeamTNT is known for attacking insecure and vulnerable Kubernetes deployments in order\nto infiltrate organizations’ dedicated environments and transform them into attack\nlaunchpads. In this article Aditya Sood presents a new module introduced by…\n\n### Collector-stealer: a Russian origin credential and information extractor\n\nCollector-stealer, a piece of malware of Russian origin, is heavily used on the Internet to\nexfiltrate sensitive data from end-user systems and store it in its C&C panels. In this article,\nresearchers Aditya K Sood and Rohit Chaturvedi present a 360…\n\n### Fighting Fire with Fire\n\nIn 1989, Joe Wells encountered his first virus: Jerusalem. He disassembled the virus, and\nfrom that moment onward, was intrigued by the properties of these small pieces of selfreplicating code. Joe Wells was an expert on computer viruses, was partly…\n\n### Run your malicious VBA macros anywhere!\n\nKurt Natvig wanted to understand whether it’s possible to recompile VBA macros to another\nlanguage, which could then easily be ‘run’ on any gateway, thus revealing a sample’s true\nnature in a safe manner. In this article he explains how he recompiled…\n\n### Dissecting the design and vulnerabilities in AZORult C&C panels\n\nAditya K Sood looks at the command-and-control (C&C) design of the AZORult malware,\ndiscussing his team's findings related to the C&C design and some security issues they\nidentified during the research.\n\n\n-----\n\n[Bulletin Archive](https://www.virusbulletin.com/virusbulletin/archive)\n\n_Copyright © 2014 Virus Bulletin_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2014/2014-07-18 - Bird's nest.pdf"
    ],
    "report_names": [
        "2014-07-18 - Bird's nest.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f809bfcb-b200-4988-80a8-be78ef6a52ef",
            "created_at": "2023-01-06T13:46:39.186988Z",
            "updated_at": "2025-03-27T02:00:03.016358Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "Adept Libra"
            ],
            "source_name": "MISPGALAXY:TeamTNT",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "c3ca592f-0669-49bd-ab5c-310007ab2fb4",
            "created_at": "2022-10-25T15:50:23.334495Z",
            "updated_at": "2025-03-27T02:00:55.445098Z",
            "deleted_at": null,
            "main_name": "TeamTNT",
            "aliases": [
                "TeamTNT"
            ],
            "source_name": "MITRE:TeamTNT",
            "tools": [
                "Peirates",
                "MimiPenguin",
                "LaZagne",
                "Hildegard"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536047,
    "ts_updated_at": 1743041531,
    "ts_creation_date": 1653678085,
    "ts_modification_date": 1653678085,
    "files": {
        "pdf": "https://archive.orkl.eu/1fba4cdfd10a9d9512a02df8b82db9483ffa065c.pdf",
        "text": "https://archive.orkl.eu/1fba4cdfd10a9d9512a02df8b82db9483ffa065c.txt",
        "img": "https://archive.orkl.eu/1fba4cdfd10a9d9512a02df8b82db9483ffa065c.jpg"
    }
}