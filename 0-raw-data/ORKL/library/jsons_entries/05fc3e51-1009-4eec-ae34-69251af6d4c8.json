{
    "id": "05fc3e51-1009-4eec-ae34-69251af6d4c8",
    "created_at": "2023-01-12T15:07:16.444622Z",
    "updated_at": "2025-03-27T02:13:29.311946Z",
    "deleted_at": null,
    "sha1_hash": "c6545bbbd6ca561d8847a033fe8f13d2838f1daa",
    "title": "2022-04-27 - The chronicles of Bumblebee- The Hook, the Bee, and the Trickbot connection",
    "authors": "",
    "file_creation_date": "2022-05-28T19:02:40Z",
    "file_modification_date": "2022-05-28T19:02:40Z",
    "file_size": 2290440,
    "plain_text": "# The chronicles of Bumblebee: The Hook, the Bee, and the Trickbot connection\n\n**[elis531989.medium.com/the-chronicles-of-bumblebee-the-hook-the-bee-and-the-trickbot-connection-686379311056](https://elis531989.medium.com/the-chronicles-of-bumblebee-the-hook-the-bee-and-the-trickbot-connection-686379311056)**\n\nEli Salem April 27, 2022\n\n[Eli Salem](https://elis531989.medium.com/?source=post_page-----686379311056--------------------------------)\n\nApr 27\n\n\n17 min read\n\nIn late March 2022, a new malware dubbed “Bumblebee” was discovered, and reported to be\ndistributed in phishing campaigns containing ISO files which eventually drop DLL files that\ncontained the Bumblebee malware itself.[1][3].\n\n\n-----\n\nThis malware deployment technique is not new, and several other malware has already been\nobserved using it, most notably: BazarLoader, and IcedID[3]. Also, similar to the\naforementioned malware, Bumblebee too was observed delivering the Cobalt-Strike\nframework.\n\nFrom a threat research perspective, what makes this malware interesting is the fact that it\nwas associated with the Conti ransomware group as one of the group's threat loaders[1].\nIn the past, the traditional loaders of Conti were Trickbot, Bazarloader, and Emotet, so it was\nquite intriguing to inspect this malware closely.\n\nIn this article, I will present a code analysis of the Bumblebee malware, obviously, due to the\nmalware's large size I will not cover everything, and will focus on the parts that I think are the\nmost interesting in terms of capabilities.\nAlso, one of my favorite topics in malware research is the ways of malware to avoid\ndetection, so I will put more emphasis on this subject as well.\n\nLastly, I divided the entire article into three parts, the table of contents is the following:\n\n1.\n2.\n3.\n\n## PART 1\n\n The Hook: Unpacking the bumblebee’s crypter\n\nHash: a9c8b7c411571700e6ea03e4e48ddb896a33e53e\n\n\n-----\n\nBumblebee dropper as seen in PEstudio\nThe initial dropper of Bumblebee is a 64bit file, with relatively high entropy which indicates a\npossibly obfuscated \\ encrypted content that will be decrypted in runtime.\n\nThe DLL itself contains two export functions: InternalJob and SetPath. Also, the file’s internal\nname appears to be “lodqcbw041xd9.dll”.\n\nBumblebee dropper exports and internal name in PE-Bear\n\n## Unpacking mechanism\n\n\n-----\n\nOnce we enter the loader s main function, we see that it is unique, and does not look like any\ncommon crypters that can be found in Conti’s loaders (such as Emotet or Bazarloader).\n\nBumblebee loader\\crypter main\nAs we open the loader in IDA, we see that the majority of the PE in the IDA navigator has the\nolive color which means unexplored bytes. This is common when there is some content in\nthe PE that needs to be decrypted during runtime.\n\nBumblebee loader unexplored bytes\n**Tip: During my analysis, I disabled the file’s ASLR to match the addresses in IDA and Xdbg,**\nthis is super helpful and saves a lot of time.\n\nTo do so, open the file in CFF explorer, and then:\n\n1. Click Optional Header\n2. Go to DllCharacteristics\n3. Remove the V from “DLL can move”\n\n\n-----\n\nDisabling ASLR\nNext, we can see that the DllEntryPoint is an empty export function, so we will want to\nredirect our execution flow to one of the working export functions, for this case, we will\nchoose “SetPath”.\n\nTo redirect the flow, do the following:\n\n1. In IDA \\ PE-Bear, copy the address of the required export function\n2. In Xdbg, right click on RIP\n3. Click on “Modify Value”\n4. Paste the address of the export function\n\n\n-----\n\nChanging the address\nAfter clicking OK we will find ourselves at the beginning of the export function. This trick can\nbe used in any other malware the executed via designated export function\n\nBumblebee SetPath\nFrom a reverse engineer perspective, the crypter is an inconvenient binary to inspect, and\nthere are not many “quick wins” we can gather just by looking at it, however, this crypter is\nunique in today's landscape so I will focus on the areas I found are the most interesting.\n\nFirst, the crypter will start with a traditional unpacking activity, in the function sub_180003490\nthere are two other functions:\n\n1. - which will allocate virtual memory using (this function will happen multiple times\n\nduring the crypter unpacking)\n2. - Which gets an embedded content and writes it into the newly allocated memory\n\n\n-----\n\nBumblebee loader\\crypter main\nThen, the function sub_180002FF4 will be executed to do the following:\n\n1. Allocate new virtual memory using the same function.\n2. Manipulate the content from the first allocated buffer and write the output into the newly\n\nallocated memory\n\nBumblebee loader\\crypter main\nThe next step will be the function sub_180004180, this function will do the following:\n\n1. It executes a function named that will allocate multiple virtual memories using the\n\nalready mentioned .\n2. Call the function named that will use the virtual memory that was allocated in, do\n\nadditional manipulations, and eventually writes an unpacked MZ into the last allocated\nbuffer from the function .\n\n\n-----\n\nBumblebee loader\\crypter main\nWhen looking statically in the function sub_180003CE, the loop that will write the unpacked\nfile will be the following:\n\nBumblebee loader payload decryption\nAnd when observing dynamically, it will look like the following:\n\nBumblebee loader payload decryption\nIn the end, we get an allocated memory with Read-Write permissions with an unpacked\npayload inside.\n\n\n-----\n\nBumblebee loader payload decrypted in process hacker\nUntil now, everything that is observed are things that are pretty much common in other\nloaders \\ crypters, however, we still have two unsolved questions:\n\n1. The code section of the payload does not have Execute permission, so it cant run.\n2. What makes this loader special?\n\n## Enters the hook\n\nThe loader will enter a function called sub_180001000, this function will create inline\nhooks[5] that will ignite the chain of events that will lead to the code execution.\n\n\n-----\n\nBumblebee loader payload decryption\nAs we enter, we notice something interesting, the loader assign functions to a memory\naddress, then it will call another function named sub_100025EC.\n\nAssign functions to addresses\nThis function will do the following:\n\n1. Get Ntdll handle with\n2. Get the address of\n3. Get the address of\n4. Get the address of\n5. Return the data\n\n\n-----\n\nGetting NT functions\nTo observe it dynamically, we can just go to the debugger and step over the functions\nthemselves.\n\nGetting NT functions\nAfter exiting sub_100025EC, our attention will go to a function named sub_1800037C4. This\nfunction will be responsible to install a hook in the aforementioned NT functions.\n\nIt will do it in the following way:\n\n1. Call to change the protection of the area it wants to write into to be writeable\n2. Call that will take as arguments:1. The function to write into 2. The content it wants to\n\nwrite3. The size\n3. Call to change the protection again to not be writeable\n\n\n-----\n\nSetting hook\nEventually, this activity will occur inside a loop to install the hooks in each of the NT\nfunctions. The hook that will be installed will be the functions that have been assigned to\nmemory addresses at the beginning of the larger function.\n\n1. for NtMapViewOfSection\n2. for NtOpenFile\n3. for NtCreateSection\n\nIf we wanted to observe the changes dynamically we have two options, the first one is to just\nobserve it in the debugger by step over sub_180002978\n\nHooked NT functions\nAnother option is to use the took Hollow hunter[6] with the “/hooks” as an argument. Then,\nwe will have a .tag file from the hooked DLL (if found of course)\n\n\n-----\n\nView hooks using hollow hunter\nAnd when we open this file with a text editor we could see the indication of who are the\nhooked function, and where the hook itself lies.\n\nView hooks using hollow hunter\nTo summarize the hooking procedure, it will look like this:\n\n\n-----\n\nBumblebee loader install hook mechanism\n\n## Executing the code\n\nAfter we finish setting the hooks, we will head to the function sub_1800013A0\n\nBumblebee loader\\crypter main\nThis function will attempt to execute the DLL “GdiPlus.dll” using the API call LoadLibrary,\nwith SetPath as an export function.\n\nLoadLibrary loading GdiPlus.dll\n\nLoadLibrary loading GdiPlus.dll\n**Q: Why does the malware even want to use GdiPlus.dll?**\n\n**A: It doesn't.**\n\n**Q: So why the need to load it?**\n**A: Because it is not loaded (wait what?!)**\n\nThe malware will attempt to use some (and unique) custom unpacking:\n\n1. When loads a DLL file, it uses internally the hooked NT function as part of its internal\n\nactivity.\n2. The malware chooses a DLL that is not loaded yet.\n\n\n-----\n\n3. will get a file handle of\n4. will create a section for the file handle of\n\nHowever, here is when things become tricky, when the LoadLibrary will try to use\n_MapViewOfSection to map the GdiPlus.dll section, the hook function of MapViewOfSection_\n(sub_180001D4C) will do the following:\n\n1. It will use to create a new section with READ-WRITE-EXECUTE permissions, without\n\nany file handle to associate it with.\n2. It will write the unpacked malicious content into this section\n3. It returns NTSTATUS_SUCCESS to the so it will seem to it as if was mapped\n\nsuccessfully.\n\nHooked NtMapViewOfSection mechanism\nThe result will be an unpacked bumblebee malware that resides in the RWX section and is\nassociated with GdiPlus.dll. Interestingly, the GdiPlus.dll is considered a relocated DLL in\nProcess hacker.\n\n\n-----\n\nRelocated module point to RWX section\n\n## Bumblebee dropper high lever summary\n\nIf we want to look at all the dropper unpacking mechanism steps in a high-level overview and\nsummarize them into three steps, it will look like this:\n\n\n-----\n\nBumblebee dropper overview\n\n## PART 2\n\n The bee: Investigating the bumblebee’s payload\n\n\n-----\n\nUnpacked Bumblebee payload\nThe unpacked malware is a large 64-bit file with quite high entropy.\n\nThis file appears to be the core component of the Bumblebee malware. It features many\ntraditional capabilities we would expect from malware, such as internet communication, file\nmanipulation, collecting user information, cryptography libraries, etc.\n\nIn my article I will not cover this file as much because of scoping decisions, however, some\ninteresting code parts to mention are:\n\n## Stolen anti-analysis code\n\nAs with many malware, Bumblebee also has anti-analysis tricks, however, the majority of\nthem are grouped in one large function. Also, During my observation, I notice that additional\nanti-analysis checks have been added as time goes by, which indicates a quick evolving\nmalware or that the authors are still in the “testing the waters” phase.\n\nIn addition, this entire anti-analysis function code is taken from the GitHub page of the “alkhaser project”[7]. For good measure, I will show some examples.\n\n**Searching for processes**\n\nThe malware will search for multiple tools that are being used for dynamic and static\nmalware analysis tools. The malware will iterate through the processes using\n_CreateToolHelp32Snapshot._\n\n\n-----\n\nSearching for processes in Bumblebee\nAs said, this code is the exact code found in the al-khaser project.\n\n\n-----\n\nal-khaser source code\nThe malware also attempts to detect any kind of virtualization environment with the detection\nof their processes, it varies from Vmware to Vbox processes.\n\nSearching for Vmware processes in Bumblebee\n**Searching registry keys**\n\n\n-----\n\nThe malware will attempt to search for designated registry keys that indicate any kind of\nvirtual environment from multiple products.\n\nSearching for Vmware registry key in Bumblebee\n**Searching file paths**\n\nThe malware will search for file paths that can indicate any kind of virtual environment.\n\nSearching for VBOX files in Bumblebee\nAt this point, it will be useless to continue writing the anti-analysis capabilities, so for those\nwho want to see all, please visit the al-khaser project GitHub page.\n\n## Executing processes\n\nAmong the malware, capabilities are to execute Rundll.exe to run the DLL with the\nInternalJob as an export function using Wscript.\n\n\n-----\n\nExecuting Wscript\nAlso, the malware can use PowerShell to perform further activities\n\nExecuting PowerShell\n\n## The little ones inside the flask\n\nOne of the most interesting things about the Bumblebee core component is the fact that it\ncontains two DLL files inside of him.\n\n\n-----\n\nTwo hidden DLL files inside the unpacked Bumblebee\nBoth of these files have the same internal name RapportGP.dll (which is also used by the\nsecurity company Trusteer)\n\nBumblebee hooking DLL aka RapportGP.dll\nThe two DLL files are completely identical except for the fact that one of them is 32-bit and\nthe other is 64-bit.\n\n## PART 3: The shadow of Trickbot- Investigating the hooking DLL\n\nIn the last part, I will investigate the RapportGP.dll, as said, there are two versions: 32\\64 bit,\nand for my analysis, I will focus only on the 32 bit.\n\nThe main concept behind RapportGP.dll is hooking, and the entire module’s mechanism is\nsupporting this activity.\n\n## Check for existing hooks\n\n\n-----\n\nOne of the first activities of the module occurs in a function named _sub_100060C0, in_\ngeneral, this function will be responsible to check if there is any hooked function from a list of\npre-determined functions.\n\nInside sub_100060C0, the chain of events that leads to this is the following:\n\n1. A handle to,,, obtained\n2. The requested DLL’s path obtained\n3. A call to the function made to get a copy of that stored in the allocated memory\n4. The arguments are sent to another function named\n\n1. RapportGP.dll checking and disabling existing hooks\nThe functions it wants to check are:\n\nIn Ntdll.dll\n\n\n-----\n\nRapportGP.dll list of Ntdll functions to check\nIn Kernel32.dll\n\n\n-----\n\nRapportGP.dll list of Kernel32 functions to check\nIn Kernelbase.dll\n\nRapportGP.dll list of Kernelbase functions to check\nIn Advapi32.dll\n\n\n-----\n\nRapportGP.dll list of Advapi32 functions to check\nIn sub_10005B90, the module path of the requested DLL file will be mapped to memory and\nwill be sent to an additional function named “sub_10005D40” that will deal with the actual\nchecking.\n\n2. RapportGP.dll checking and disabling existing hooks\nAs for the checks themselves, it is quite simple:\n\n1. The malware iterate through the export functions of the legitimate DLL file that was\n\nmapped to memory by the process when it loads.\n2. The malware will check if the name is one of the function names it wants to check\n3. Once found, the malware calls that checks for hooks evidence in the DLL that was\n\nmapped by the process loader\n4. The malware will do the same for the DLL that was mapped by the malware itself (in ).\n5. If no hooks are found, it will continue to iterate\n\n\n-----\n\n3. RapportGP.dll checking and disabling existing hooks\nAnd if there is an indication of hooks, the malware does the following\n\n1. Get information about the original function\n2. It will change the protection\n3. Check if it's writable\n4. Write the content of the mapped function to the original function. In this way, it restores\n\nit to the state it should be if there are no hooks.\n\n\n-----\n\n4. RapportGP.dll checking and disabling existing hooks\nIf we wanted to observe this activity dynamically, all we need to do is to change the bytes\nfrom the beginning of one of the functions the malware wants to check. For example, let's\ntake NtCreateFile.\n\n1. Original function at 775222C0\n2. The function that mapped by the malware at 02E022C0\n\n5. RapportGP.dll checking and disabling existing hooks\nWhen looking in the dump, we can see that their code is exactly the same\n\n\n-----\n\n6. RapportGP.dll checking and disabling existing hooks\nLet's change the first byte of the original to have an E9 opcode (jump)\n\n7. RapportGP.dll checking and disabling existing hooks\nNow, if we will try to debug dynamically, we will be able to get to the last part of the code.\n\n8. RapportGP.dll checking and disabling existing hooks\nAfter stepping over memset, we can see that the E9 byte no longer exists and the original\nfunction returned to its normal state.\n\n9. RapportGP.dll checking and disabling existing hooks\nAt a very high level, the process eventually looks like this:\n\n\n-----\n\n10. RapportGP.dll checking and disabling existing hooks\n\n## Setting the hooks\n\nAfter checking that there are no other hooks, the malware turns to set its own hooks. The\nmalware will have two kinds of hooks for different purposes.\n\n## First hooks: Disable Exceptions\n\nThe malware will set a hook on the function RaiseFailFastException which is located in\nkernel32.dll and api-ms-win-core-errorhandling-l1–1–2.dll.\n\nThe function that will be triggered will be empty, therefore no exception will be triggered.\n\nRapportGP.dll hooks to disable exceptions\n\n## Second hooks: Further code execution\n\n\n-----\n\nThe malware will use the same technique the bumblebee loader did. It will first get the\naddresses of the function ZwMapViewOfSection, ZwOpenSection, ZwCreateSection,\n_ZwOpenFile, ZwClose, and LdrLoadDll._\n\nRapportGP.dll second hooks\nAnd similar to the Bumblebee’s loader, it will first set the hook, and then will call LdrLoadDll\nwhich is the lower lever equivalent of LoadLibrary to load the module “wups.dll”, which will\ntrigger the chain of events we already discussed in the Bumblebee loader part.\n\nRapportGP.dll second hooks\n\n## The Trickbot hooking engine\n\nAlthough both hooks are doing completely different things, the hooks’ installation mechanism\nis the same. Interestingly, this mechanism is also the same as the web-inject module of\nTrickbot.\n\n\n-----\n\nBumblebee’s RapportGP.dll vs Trickbot’s web-inject module\nAs with many ex-bankers that use hooking such as Panda, Trickbot, and Qbot, their hooking\ncode is based on the Zeus leak, however, each of them has its flavor and changes and\nTrickbot is no different.\n\nIn the Trickbot web-inject hooking mechanism, which has already been documented[8], when\ncreating the inline hooking “trampoline” there is the following evasion technique:\n\n1. Trickbot writes 35 bytes of NOPS (0x90)\n2. Add the traditional function prologue\n3. Write the jump to the targeted function at the end of the NOPS\n\n\n-----\n\nTrickbot’s web-inject module evasion technique\nAs we debug Bumblebee, we notice it uses the same unique evasion as well (adjusted for\nthe API calls it wants to hook). So for example when hooking the ZwMapViewOfSection,\nwhich instantiates a Syscall, it will look like this.\n\nBumblebee’s RapportGP.dll evasion technique\nAnd when targeting the user-mode functions RaiseFailFastException, it will look exactly like\nin Trickbot.\n\n\n-----\n\nBumblebee’s RapportGP.dll evasion technique\n\n## Static differences and code evolution\n\nWhen inspecting the entire code flow graph of the hook installation function, we can see a\nstriking similarity between Bumblebee’s RapportGP.dll and Trickbot’s web-inject module.\n\n\n-----\n\nBumblebee’s RapportGP.dll vs Trickbot’s web-inject module install hook functions\nInterestingly, although the actual functionality is the same, we might think that statically\neverything is the same, even the sub-functions inside the hooking installation function. Funny\nenough, this is not the case.\n\nAs mentioned above, in the hooking installation function, one function is responsible for\ndoing checks and return size (Please see the image above).\n\n1. In Trickbot its\n2. In Bumblebee its\n\nHowever, when inspecting their code and code flow statically, this is how they both look like\n\n\n-----\n\nBumblebee’s RapportGP.dll vs Trickbot’s web-inject module- same functionality, different flow\nObviously, in Bumblebee, the authors have decided to use Control-flow-flattening[9] to\nobfuscate the entire flow of the function. For those of you who are not familiar with this\nobfuscation technique, I strongly recommend the following video[10].\n\nIn addition, inside each of these functions (sub_10001650 in Trickbot, sub_10002870 in\nBumblebee) there are 3 functions (one of them is memset), and the Control-flow-flattening\nconcept continues in Bumblebee inside them as well.\n\nFor example, here are another two functions that act the same dynamically:\n\n\n-----\n\nBumblebee’s RapportGP.dll vs Trickbot’s web-inject module- same functionality, different flow\nWhen observing the two functions in Bindiff flow graphs, we could see some similarities.\n\n\n-----\n\nBumblebee’s RapportGP.dll vs Trickbot’s web-inject module-Bindiff\n\n## Additional similarities\n\nIn both modules, there are other functions that are not completely identical by code,\nhowever they serve the same functionality\n\n\n-----\n\n**Example_1**\n\nBefore entering the hooking functions, both Trickbot and Bumblebee attempt to use\nLoadLibrary and get the address of the function it wants to hook.\n\nThe difference is that in Trickbot it explicitly writes “Kernel32.dll” and in Bumblebee it gets the\nDLL’s name from the caller function.\n\nBumblebee’s RapportGP.dll vs Trickbot’s web-inject module- same functionality, a different\napproach\n**Example_2**\n\nThe call for the hooking activity looks very similar as well\n\n\n-----\n\nBumblebee’s RapportGP.dll vs Trickbot’s web-inject module\n**Example_3**\n\nOutside the hooking, the Bumblebee’s hooking module starts with getting the process handle\nand eventually duplicating a thread handle, whereas, the Trickbot’s module starts with getting\nthe process handle and duplicating the token. Again, the same objective, in a different way.\n\n## Customize flattened RC4\n\nAnother interesting activity lies inside the hooked ZwMapViewOfSection function. The hook\nappears to use a customize RC4 obfuscated with the Control-flow-flattening technique.\n\n\n-----\n\nCustom RC4 with CFF obfuscation\n\n## RapportGP.dll High-level summary\n\nWhen trying to summarize the entire file behavior, it eventually is the following:\n\n\n-----\n\nRapportGP.dll overall activity\n\n## Conclusion\n\nThe bumblebee malware is a very interesting piece of code, and to perform their objectives,\nthe authors show a high level of creativity and innovation.\n\nThe interesting similarities between the Bumblebee hooking DLL and the Trickbot’s webinject DLL raise questions and speculations.\n\nOn one hand, the similarities are not strong enough to deduce that the authors of Bumblebee\nand Trickbot are the same, on the other hand, it is not far-fetched to assume that the authors\nof Bumblebee have the source code of the Trickbot’s web-inject module.\n\nIn any case, the authors took an already proven and working code and evolve it to be less\ndetectable to AV products, and challenging to security researchers.\n\n\n-----\n\n## References\n\n[1] [https://blog.google/threat-analysis-group/exposing-initial-access-broker-ties-conti/](https://blog.google/threat-analysis-group/exposing-initial-access-broker-ties-conti/)\n\n[2] [https://twitter.com/Unit42_Intel/status/1512146449345171459](https://twitter.com/Unit42_Intel/status/1512146449345171459)\n\n[3] [https://www.cynet.com/orion-threat-alert-flight-of-the-bumblebee/](https://www.cynet.com/orion-threat-alert-flight-of-the-bumblebee/)\n\n[4] [https://github.com/hasherezade/pe-bear-releases](https://github.com/hasherezade/pe-bear-releases)\n\n[5] [https://youtu.be/9efJ8_ukxlY?t=2](https://youtu.be/9efJ8_ukxlY?t=2)\n\n[6] [https://github.com/hasherezade/hollows_hunter](https://github.com/hasherezade/hollows_hunter)\n\n[7] [https://github.com/LordNoteworthy/al-khaser/tree/master/al-khaser](https://github.com/LordNoteworthy/al-khaser/tree/master/al-khaser)\n\n[8] https://www.sentinelone.com/labs/how-trickbot-malware-hooking-engine-targets-windows10-browsers/\n\n[9] [https://blog.jscrambler.com/jscrambler-101-control-flow-flattening](https://blog.jscrambler.com/jscrambler-101-control-flow-flattening)\n\n[10] [https://youtu.be/SulC2l1Dvbo](https://youtu.be/SulC2l1Dvbo)\n\n## IOC\n\nbumblebee_dropper: 4a35fa2f0903f7ba73ac21564a5a0e2a25374e10\n\nbumblebee_malware: 5dbb3bbc57653c348be7778628ed0ef11ffef35d\n\nbumblebee_rapportgp: 5c8f7465ba67138e58d3ca61e4346e31c2b799d8\n\nTrickbot web-inject module: 0785D0C5600D9C096B75CC4465BE79D456F60594\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-27 - The chronicles of Bumblebee- The Hook, the Bee, and the Trickbot connection.pdf"
    ],
    "report_names": [
        "2022-04-27 - The chronicles of Bumblebee- The Hook, the Bee, and the Trickbot connection.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f4f16213-7a22-4527-aecb-b964c64c2c46",
            "created_at": "2024-06-19T02:03:08.090932Z",
            "updated_at": "2025-03-27T02:05:17.387119Z",
            "deleted_at": null,
            "main_name": "GOLD NIAGARA",
            "aliases": [
                "Carbanak",
                "Carbon Spider ",
                "FIN7 ",
                "Navigator ",
                "Sangria Tempest ",
                "TelePort Crew ",
                "Calcium "
            ],
            "source_name": "Secureworks:GOLD NIAGARA",
            "tools": [
                " Carbanak",
                " Cobalt Strike",
                " DICELOADER",
                " DRIFTPIN",
                " GGLDR",
                " GRIFFON",
                " JSSLoader",
                " Meterpreter",
                " OFFTRACK",
                " PILLOWMINT",
                " POWERTRASH",
                " SUPERSOFT",
                " TAKEOUT",
                " TinyMet",
                "Bateleur"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673536036,
    "ts_updated_at": 1743041609,
    "ts_creation_date": 1653764560,
    "ts_modification_date": 1653764560,
    "files": {
        "pdf": "https://archive.orkl.eu/c6545bbbd6ca561d8847a033fe8f13d2838f1daa.pdf",
        "text": "https://archive.orkl.eu/c6545bbbd6ca561d8847a033fe8f13d2838f1daa.txt",
        "img": "https://archive.orkl.eu/c6545bbbd6ca561d8847a033fe8f13d2838f1daa.jpg"
    }
}