{
    "id": "ebb01999-baac-46b1-a2f5-7f3ff3631027",
    "created_at": "2022-10-25T16:48:24.178347Z",
    "updated_at": "2025-03-27T02:05:45.173707Z",
    "deleted_at": null,
    "sha1_hash": "25721217548ed812173d49e7d59abd68dbdc4e9b",
    "title": "Analysis Results of Zeus.Variant.Panda",
    "authors": "",
    "file_creation_date": "2017-07-28T13:13:55Z",
    "file_modification_date": "2017-07-28T13:13:55Z",
    "file_size": 367800,
    "plain_text": "# ADVANCED ANALYTICS\n\n\n### Analysis Results of Zeus.Variant.Panda\n\n#### Luca Ebach\n\nAnalysis Report. June 22, 2017\n\nG DATA Advanced Analytics GmbH\nG DATA Campus Â· KÃ¶nigsallee 178\nD-44799 Bochum, Germany\n\n\n-----\n\n## Contents\n\n1 Introduction 2\n\n2 Overview 3\n2.1 General Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n2.2 Execution Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n\n3 Anti-Detection and Anti-Reverse-Engineering Techniques 6\n3.1 Malware Startup Checks . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n3.1.1 Debug support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n3.1.2 Language checks . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n3.1.3 Anti analysis check . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n3.2 Windows API Imports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n3.3 Crypted Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n3.4 Cryptography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n3.4.1 Random Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n3.4.2 Cryptography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n3.4.3 Hashing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n\n4 Configuration 13\n4.1 Bot ID . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n4.2 Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n4.2.1 Base Config . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n4.2.2 Local Config (PeSettings) . . . . . . . . . . . . . . . . . . . . . . . 14\n4.2.3 Dynamic Config . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n4.2.4 Local Settings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n4.3 Bot Update . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n4.4 Configuration Update . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n\n5 Payload and Persistence 20\n5.1 Persistence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n5.2 HTTP Grabber and Injector . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n5.3 Process Injection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n5.4 API Hooking Technique . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n5.5 Hooks and Browser Manipulation . . . . . . . . . . . . . . . . . . . . . . . 22\n5.5.1 Internet Explorer . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n5.5.2 Mozilla Firefox . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n5.5.3 Google Chrome . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n5.5.4 User Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n\n\n-----\n\nContents 1\n\n5.6 Plug-in ability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n5.7 Webfilters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n5.8 Remote Script . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n5.9 System Report . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n\n6 Conclusion 30\n\n\n-----\n\n## 1 Introduction\n\nAside from ransomware attacks, banking trojans are also a very dangerous type of malware. They do not have destructive behaviour in the first place, so their presence on a\nvictimâ€™s system might not be detected for quite an amount of time if the victim has no\nproper antivirus product installed. Since Panda is possibly among the most dangerous\nfamilies of banking trojans, we decided to do a comprehensive analysis of a recent sample\nof Panda.\nIn this paper we focus on the analysis of the binary part of a Zeus.Panda malware\nsample. For a detailed analysis of the actual webinject behaviour and the communication\nflow between infected machines and the automatic transfer systemâ€™s server, please refer\nto our blogposts[1 2] by Manuel KÃ¶rber-Bilgard and Karsten Tellmann.\n\n1\n[https://cyber.wtf/2017/02/03/zeus-panda-webinjects-a-case-study/](https://cyber.wtf/2017/02/03/zeus-panda-webinjects-a-case-study/)\n2\n[https://cyber.wtf/2017/03/13/zeus-panda-webinjects-dont-trust-your-eyes/](https://cyber.wtf/2017/03/13/zeus-panda-webinjects-dont-trust-your-eyes/)\n\n\n-----\n\n## 2 Overview\n\n#### 2.1 General Information\n\nThe original Zeus banking trojanâ€™s source code was leaked in 2011 and since then several\nindependent threat actors have used the source code as a basis for new variants of the\nmalware. One of the most prolific and advanced of these variants is the Zeus.Panda\nbanking trojan which we will analyse in this white paper. Zeus.Panda targets Windows\noperating systems from WinXP through Windows 10 and is typically spread through\nphishing mail campaigns, but proliferation through drive-by exploits has been seen.\nThe sample analyzed in this whitepaper is:\n\nMD5\n\nPacked: e005c4009c22e0f73fcdaeba99bd0075\nUnpacked: 655f65b1b08621dfcb2603b59fca05bc\n\nSHA1\n\nPacked: 6f5c186baa0d69799c250769052236b8bcfb13a1\nUnpacked: 88782d3b74067d405e56f0a5e9b92e3fdb77dcd8\n\nSHA256\n\nPacked: d037723b90acb9d5a283d54b833e171e913f6fa7f44dd6d996d0cecae9595d0b\nUnpacked: bd956b2e81731874995b9b92e20f75dbf67ac5f12f9daa194525e1b673c7f83c\n\nSize\n\nPacked: 252 KB\nUnpacked: 140 KB\n\nNumber of Functions\n\n538\n\nIOCs (Filesystem)\n\nPanda tries to find a directory underneath %APPDATA%\\Roaming that\n\n_âˆ™_ is empty,\n\n_âˆ™_ has a path that is at least 140 characters long,\n\n_âˆ™_ does not contain either of microsoft or firefox, and\n\n_âˆ™_ is as deep in the directory tree as possible\n\nIn our analysis environment, Panda ended up in %APPDATA%\\Roaming\\Sun\\Java.\nIn the directory, Panda creates four files with random file extensions. We discovered\n\n\n-----\n\n2.2 Execution Flow 4\n\nDesktop (create shortcut).exe (malware executable), Control Panel.cyd (dynamic config file, section 4.2.3), Desktop.ysq (report file, section 5.9), and Notepad.kix\n(localconfig file, section 4.2.2).\n\nIOCs (Registry)\n\nAside from writing some files to disk, Panda also uses some registry keys to store\ndata. All the registry keys used by Panda are located in the HKCU\\Software\\Microsoft\nkey. The names of the keys are random and in our system we observed Ivoc (regDynamicConfig), Kounhu (regLocalConfig), and Useglugy (regLocalSettings). See\nsection 4.2.2 for a more detailed description of the configuration. Additionally,\nPanda creates a new entry within the HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\nregistry key which is used to start the malware as soon as the infected user logs\ninto its account.\n\nIOCs (other)\n\nInternally, Panda uses several mutexes and events to synchronize between the\ncontrolling process and the client instances in the browsers. The names of these\nobjects are fixed on the local system but are different for any other system. Although, the names are 32-character hexadecimal strings in either case. Example:\n4A0000002571569EA477E09F768C1A07\n\n#### 2.2 Execution Flow\n\nFigure 2.1 gives an overview of the control flow of Zeus.Panda. Each step will be described in detail in the coming chapters.\n\n\n-----\n\n2.2 Execution Flow 5\n\nFigure 2.1: Control flow of the malware executable.\n\n\n-----\n\n## 3 Anti-Detection and Anti-Reverse-Engineering Techniques\n\n#### 3.1 Malware Startup Checks\n\nBefore installing the malware executable in the victimâ€™s system, Panda performs several\nchecks to verify that it runs in a sane environment.\n\n##### 3.1.1 Debug support\n\nThe first check verifies the integrity of a .dbg file. If the file is present on the file system,\nit has the same name as the executable. The .dbg file contains encrypted JSON data 3.4\nof the form\n\n{\n\n\"data\": \"[data]\",\n\"sign\": \"[signature]\"\n}\n\nAfter reading the content of the file, Panda hashes the data part of the JSON object using SHA1 through the Windows Crypt API. Afterwards, it uses CryptVerifySignature\nto check the calculated hash against the content of the sign field using a static public\nkey from the executable. If the signature is not valid, Panda removes itself from the\nsystem. If the signature check is passed, Panda will bypass the subsequent anti-analysis\ncode.\n\n##### 3.1.2 Language checks\n\nOnce the debug support check is passed, Panda checks the current keyboard layout\nagainst a predefined list of layouts. In the sample I analyzed, the list contained 0x419,\n0x422, 0x423, 0x43f which stand for russian, ukrainian, belarusian, and kazakh, respectively. If either of those matches the current keyboard layout, Panda removes itself from\nthe victimâ€™s PC.\n\n##### 3.1.3 Anti analysis check\n\nThe last step of the pre-run checks is a rather long list of checks for debug and analysis\ntools. Some of these tools are antiquated such as SoftIce where support stopped long\nbefore Windows XP which is the least recent operating system supported by Panda.\nOther of the tools such as IDA Pro and Immunity Debugger remain popular tools with\n\n\n-----\n\n3.1 Malware Startup Checks 7\n\nmalware analysts. If any of these tools are present Panda aborts execution and removes\nitself. To identify analysis tools Panda uses four different types of tests:\n\nfile\n\nuse CreateFile with OPEN_EXISTING flag to check if a file/device exists\n\nmutex\n\nuse OpenMutex to try to open an existing mutex\n\nrunning process\n\nuse CreateToolhelp32Snapshot to get the list of currently running processses and\ncheck if any of them contains a given string\n\nregistry key\n\nuse RegOpenKey to check if a registry key exists or check a registry key if it contains\na given value\n\nThe full list contains checks for 23 tools and is shown in the table at the end of the section.\nIf either of those tests fails, Panda stops to installing and removes itself from the system.\nAlthough, these checks can be skipped using -f as a command line parameter at the\nstart of the malware.\n\naut2exe\n\nprocess aut2exe running\n\nBochs\n\nregistry key HKLM\\HARDWARE\\Description\\System\\SystemBiosVersion contains\nBOCHS\n\nExecute\n\nfile C:\\\\execute.exe exists\n\nFrz\n\nmutex with name Frz_State exists\n\nIDA Pro\n\nprocess idaq running\n\nImmunityDBG\n\nprocess immunity running\n\nPerl\n\nprocess perl running\n\nPopupKiller\n\nfile C:\\popupkiller.exe exists\n\nprl\n\nOne of:\n\n\n-----\n\n3.1 Malware Startup Checks 8\n\n_âˆ™_ file \\\\.\\prl_pv exists\n\n_âˆ™_ file \\\\.\\prl_tg exists\n\n_âˆ™_ file \\\\.\\prl_time exists\n\nProcessExplorer\n\nprocess procexp running\n\nProcessMonitor\n\nprocess procmon running\n\nProcessHacker\n\nprocess processhacker running\n\nPython\n\nprocess python running\n\nRegshot\n\nprocess regshot running\n\nSandboxie\n\nOne of:\n\n_âˆ™_ SbieDll.dll can be loaded by LoadLibraryA\n\n_âˆ™_ mutex Sandboxie_SingleInstanceMutex_Control exists\n\nSoftICE\n\nOne of:\n\n_âˆ™_ file \\\\.\\SICE exists\n\n_âˆ™_ file \\\\.\\SIWVID exists\n\n_âˆ™_ file \\\\.\\SIWDEBUG exists\n\n_âˆ™_ file \\\\.\\NTICE exists\n\n_âˆ™_ file \\\\.\\REGVXG exists\n\n_âˆ™_ file \\\\.\\FILEVXG exists\n\n_âˆ™_ file \\\\.\\REGSYS exists\n\n_âˆ™_ file \\\\.\\FILEM exists\n\n_âˆ™_ file \\\\.\\TRW exists\n\n_âˆ™_ file \\\\.\\ICEXT exists\n\nStimulator\n\nfile C:\\stimulator.exe exists\n\nVirtualBox\n\nOne of:\n\n\n-----\n\n3.1 Malware Startup Checks 9\n\n_âˆ™_ file \\\\.\\VBoxGuest exists\n\n_âˆ™_ file \\\\.\\VBoxMouse exists\n\n_âˆ™_ file \\\\.\\VBoxVideo exists\n\n_âˆ™_ file \\\\.\\VBoxMiniRdrDN exists\n\n_âˆ™_ file \\\\.\\VBoxMiniRdDN exists\n\n_âˆ™_ file \\\\.\\VBoxTrayIPC exists\n\n_âˆ™_ registry key HKLM\\SOFTWARE\\Oracle\\VirtualBox Guest Additions exists\n\n_âˆ™_ registry key HKLM\\HARDWARE\\ACPI\\DSDT\\VBOX__ exists\n\nVirtualPC\n\nOne of:\n\n_âˆ™_ mutex MicrosoftVirtualPC7UserServiceMakeSureWeâ€™reTheOnlyOneMutex\nexists\n\n_âˆ™_ file \\\\.\\VirtualMachineServices exists\n\nVMware\n\nOne of:\n\n_âˆ™_ file \\\\.\\HGFS exists\n\n_âˆ™_ file \\\\.\\vmci exists\n\n_âˆ™_ registry key HKLM\\SOFTWARE\\VMware Inc.\\VMware Tools exists\n\nWine\n\nOne of:\n\n_âˆ™_ kernel32.dll contains â€wine_get_unix_file_name\" function\n\n_âˆ™_ registry key HKLM\\Software\\WINE exists\n\n_âˆ™_ registry key HKCU\\Software\\WINE exists\n\nWireshark\n\nOne of:\n\n_âˆ™_ file \\\\.\\NPF_NdisWanIp exists\n\n_âˆ™_ process wireshark running\n\nHypervisor\n\nOne of:\n\n_âˆ™_ check if hypervisor bit of CPU is set\n\n_âˆ™_ file \\\\.\\VmGenerationCounter exists\n\n\n-----\n\n3.2 Windows API Imports 10\n\nFunction Resolve(Module, FunctionID)\n{\n\nFor exportName in Module.Exports\n{\n\nIf (CRC32(exportName) == FunctionID)\n{\n\nReturn AddressOfFunction(exportName)\n}\n}\n}\n\nFunction Import(ModuleID, FunctionID)\n{\n\nIf (FunctionID not in cache)\n{\n\nModule := DecryptName(ModuleID)\nIf (Module is not loaded)\n{\n\nLoadLibrary(Module)\n}\ncache[functionID] := Resolve(Module, FunctionID)\n}\n\nReturn cache[functionID]\n}\n\nListing 3.1: Pseudocode describing the implementation of the Windows API import\nfunction.\n\n#### 3.2 Windows API Imports\n\nTo harden itself against static analysis, Panda avoids importing Windows API functions\ndirectly. Instead, it uses LoadLibrary and parses the export directory of libraries. It\ncreates a CRC32 hash of each export name and compares it to a hardcoded CRC32 of\nthe name of the desired import. If the two match, the function address from the export\ndirectory of the library is used. In case of forwarded exports Panda reverts to import\nthe function by using the GetProcAddress API. A simplified pseudo code of the import\nfunction is shown in listing 3.1. The actual implementation is a bit more complicated,\nbut this should give an overview of how it works.\nThere are exceptions however. It seems that some imports are, by accident, left in\nthe binary. Fortunately, this includes functions like LoadLibrary and GetProcAddress\nwhich lowered the difficulty of the static analysis since we were able to determine the\nimport function shortly after the start of the analysis. Also, calls to the Heap* functions (Alloc, Free, ReAlloc, Create, Destroy) and also a single call to Sleep are not\nimported using the custom import functions.\n\n#### 3.3 Crypted Strings\n\nMost strings an analyst might come across during the analysis process are encrypted.\nThis hinders an analyst from using strings to determine the purpose of some functions.\n\n\n-----\n\n3.4 Cryptography 11\n\nstruct cryptEntry {\n\nchar key;\nchar unused;\nshort length;\nconst char* data;\n}\n\nListing 3.2: The layout of an entry in the list of encrypted strings.\n\nPanda decrypts the strings on the fly whenever a string is needed. The decryption\nroutine for the i-th string is rather simple:\n\n_ğ‘œğ‘¢ğ‘¡ğ‘ğ‘¢ğ‘¡[ğ‘ğ‘œğ‘ ] = ğ‘ğ‘œğ‘ _ _âŠ•_ _ğ‘ğ‘Ÿğ‘¦ğ‘ğ‘¡ğ‘’ğ‘‘ğ‘†ğ‘¡ğ‘Ÿğ‘–ğ‘›ğ‘”ğ‘ [ğ‘–].ğ‘‘ğ‘ğ‘¡ğ‘[ğ‘ğ‘œğ‘ ] âŠ•âˆ¼ğ‘ğ‘Ÿğ‘¦ğ‘ğ‘¡ğ‘’ğ‘‘ğ‘†ğ‘¡ğ‘Ÿğ‘–ğ‘›ğ‘”ğ‘ [ğ‘–].ğ‘˜ğ‘’ğ‘¦_\n\nAll encrypted strings are referenced in a large static array of structures in the readonly section of the binary. Each entry is a structure of type cryptEntry (see listing 3.2)\nwhich consists of the key character, the length of the encrpyted string, and a pointer to\nthe actual encrypted string. The decryption function then takes the index of the to-bedecrypted string in the array of structs, extracts the key, length, and string pointer from\nit and than decrypts the strings into a given buffer. Depending on how this function\nis used, it either decrypts the strings onto the stack (if the function is directly called)\nor the string is encrypted into the heap if any of the intermediate function is called.\nDuring the analysis we used the IDAPython plugin idaemu (frontend for UnicornEngine\nfor use in IDA Pro) to emulate the encryption function for all possible string indexes\nand annotated the IDA database accordingly.\n\n#### 3.4 Cryptography\n\n##### 3.4.1 Random Numbers\n\nInstead of using WinAPI functions to generate random numbers, Panda uses the Mersenne\nTwister MT 19937 to generate random numbers. Panda provides internal API functions\nto generate single numbers or buffers with support for upper and lower bounds for the\nnumbers.\n\n##### 3.4.2 Cryptography\n\nAdditionally, Panda uses a set of cryptographic algorithms to encrypt and hash sensitive\ndata to prevent analysis and manipulation of the data. For example, Panda encrypts\nalmost all settings and configuration values in memory. The algorithms used are AES\nand RC4. Both of them are used either with a hardcoded or with a dynamic key (which\nis generated during the first run of the malware). Interestingly, both AES and RC4 share\nthe same dynamic binary key material.\n\nRC4 (static key)\n\n_âˆ™_ parts of the basic config that are double encrypted\n\n\n-----\n\n3.4 Cryptography 12\n\n_âˆ™_ PeSettings in the extended file attributes of the malware executable (see section 4.2.2)\n\n_âˆ™_ object name generation (RC4 is used for scrambling there, no cryptographic\npurpose)\n\n_âˆ™_ encrypted data in dynamic config (e. g. backconnect IPs and ports for Vnc\nand Socks)\n\nRC4 (dynamic key)\n\n_âˆ™_ local settings (see section 4.2.4)\n\n_âˆ™_ report data that is temporarily stored on disk until it is submitted to the\ncommand-and-control server\n\nAES (static key)\n\n_âˆ™_ base config decryption (see section 4.2.1)\n\n_âˆ™_ internal public key decryption\n\n_âˆ™_ decryption of delay-loaded binary modules\n\n_âˆ™_ communication with command-and-control server\n\nAES (dynamic key)\n\n_âˆ™_ registry data (dynamic config, local config; see section 4.2.3 and 4.2.2)\n\n##### 3.4.3 Hashing\n\nAside from encrypting data, Panda also uses some cryptographic hash functions.\n\nSHA256\n\n_âˆ™_ DGA hostname generation (see section 4.4)\n\n_âˆ™_ bot ID (see section 4.1)\n\n_âˆ™_ object name generation\n\n_âˆ™_ integrity check of AES encrypted data sent by the command-and-control\nserver\n\nSHA1\n\n_âˆ™_ signature verification of the binary module data sent by the command-andcontrol server\n\n\n-----\n\n## 4 Configuration\n\n#### 4.1 Bot ID\n\nTo be able to track and control each malware instance in the botnet, Panda generates a\nunique bot id. The bot id is a 32-byte hex string that can be described as\n\n_ğµğ‘œğ‘¡ğ¼ğ·_ _â†_ _ğ»ğ‘’ğ‘¥ğ‘†ğ‘¡ğ‘Ÿğ‘–ğ‘›ğ‘”(ğ‘†ğ»ğ´256(ğ‘ğ‘œğ‘šğ‘ğ‘¢ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘ğ‘šğ‘’||ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ğ·ğ‘ğ‘¡ğ‘’||ğ‘ğ‘Ÿğ‘œğ‘‘ğ‘¢ğ‘ğ‘¡ğ¼ğ‘‘||ğ‘£ğ‘’ğ‘Ÿğ‘ ğ‘–ğ‘œğ‘›ğ¼ğ‘›ğ‘“ğ‘œ))_\n\nwhere\n\ncomputerName\n\nlocal computer name, fallback to â€unknownâ€ if error in GetComputerNameW\n\ninstallDate\n\ncontent of registry key HKLM\\Software\\Microsoft\\Windows NT\\Current Version\\InstallDate\n\nproductId\n\nCRC32 sum of the content of the registry key HKLM\\Software\\Microsoft\\Windows\nNT\\Current Version\\DigitalProductId; fallback to 0 if failed getting key value\n\nversionInfo\n\nCRC32 sum of OSVERSIONINFOEXW where everything from (and including) szCSDVersion is zeroed out (szCSDVersion, wServicePackMajor, wServicePackMinor,\nwSuiteMask, wProductType, wReserved); fallback to CRC32 sum of sizeof(OSVERSIONINFOEXW)\nzeroes\n\nApart from identifying the bot, the bot id is also used as part of the algorithm that\ngenerates kernel object names (mutexes, window class names, event names, etc).\n\n#### 4.2 Configuration\n\nPanda uses three different types of configurations: base, local, and dynamic. Each type\nof config has its own special purpose and is not available through static analysis â€“ except\nfor the base config.\n\n##### 4.2.1 Base Config\n\nFor the initial configuration and the first connections to the command-and-control server,\nPanda contains a static base config with default settings for the most important configuration values. This includes the following values:\n\n\n-----\n\n4.2 Configuration 14\n\ndwDelayConfig\n\ndelay in minutes how long to wait until malware starts to get the initial dynamic\nconfig\n\ndwRc4KeyLength\n\nlength of the binary RC4 key\n\nszwDGAConfigUrls\n\nlist of URLs suffixes for the DGA (see section 4.4)\n\nrc4Key\n\nbinary RC4 key, used to encrypt the PeSettings\n\ndwDGAConfigUrlsLength\n\nlength of szwDGAConfigUrls\n\nszwInitialCnCHosts\n\nan encrypted, null-separated list of strings for initial command-and-control domains\n\ndwWaitAfterProcessInfection\n\ndelay in minutes how long to wait for the core process to be initialized\n\ndwCnCUrlCount\n\nnumber of command-and-control domains in szwInitialCncHosts\n\ndwCheckConfigDelay\n\ndelay in minutes for next dynamic config check\n\n##### 4.2.2 Local Config (PeSettings)\n\nThe local config the data that is shared by all instances of the Panda malware on the\nlocal system and is generated only once at the first start of the malware and is then\npersisted in the malware executable using Extended File Attributes. The values of the\nPeSettings structure are as follows:\n\ndwStructSize\n\nthe size of the structure\n\nszwBotId\n\nthe ID of the bot that is used to identify the client against the backend server (see\nsection 4.1)\n\nguid\n\nthe GUID of the local system; if the malware is executed again after the first start, it\nrecalculates the guid and checks if it matches the one from the PeSettings. If this is\nnot the case, Panda aborts its execution. This can be used to check if the malware\nwas moved to another PC after it was started once (e.g. copying a persisted sample\n\n\n-----\n\n4.2 Configuration 15\n\nof the malware from a victimâ€™s computer to an analysis environment of a malware\nanalyst)\n\nrc4BinKey\n\nthis RC4 key is used to encrypt all data that goes to the registry keys (e.g. a\nbackup of the currently used dynamic config)\n\ndwInfectionId\n\na random number identifying the current infection\n\nszwCoreFile, szwReportFile, szwDynConfigFile, szwLocalConfigFile\n\nfiles on the local filesystem; szwCoreFile is the name of the malware executable;\nszwReportFile contains the path to the file where Panda temporarily stores the\nreport data until they are sent to the server; szwDynConfigFile points to the\nfile where the dynamic config is backed up on the filesystem; szwLocalConfigFile\ncontains the file where the local config is stored\n\nregKey\n\na random registry key name\n\nregDynamicConfig\n\nthe name of the registry key that contains the backup of the current dynamic config\n\nregLocalConfig\n\nthe name of the registry key containing a backup of the local PeSettings\n\nregLocalSettings\n\nthe name of the registry key that is used to store the local settings into (e.g. IDs\nof socks and VNC modules)\n\n##### 4.2.3 Dynamic Config\n\nThe first thing Panda does after initializing and injecting into its run-time host process is\nto download a dynamic config from its command-and-control server. This configuration\nis created by the command-and-control server on demand and can change at any time.\nThis allows the malware operator to maintain his control capabillity even in the event\nthat the static configured command and control server is shut down. But especially the\ndynamic configuration is interesting for malware analysts because it contains the URLs\nand/or IP addresses of the ATS server(s).\nPanda uses its built-in JSON parser to parse the dynamic configuration. The malware\nmakes use of the following values:\n\ncreated\n\nthe creation date of the config; used to check if the downloaded one is newer than\nthe local one\n\nbotnet\n\nthe name of the botnet the client is part of\n\n\n-----\n\n4.2 Configuration 16\n\ncheck_config\n\ntime in seconds when to check for the next dynamic config\n\nsend_report\n\ntime in seconds when to send the next system report\n\ncheck_update\n\ntime in seconds when to check for the next client update\n\nurl_config\n\nthe url from where to download the next dynamic config\n\nurl_webinjects\n\nthe url from where to download the webinjects\n\nurl_update\n\nthe url for the bot update\n\nurl_plugin_vnc32\n\nthe url for the VNC32 module\n\nurl_plugin_vnc64\n\nthe url for the VNC64 module\n\nurl_plugin_vnc_backserver\n\nthe URL/IP address where the VNC module should connect to\n\nurl_plugin_grabber\n\nthe url for the http grabber module\n\nurl_plugin_backsocks\n\nthe url for the backconnect socks proxy module\n\nurl_plugin_backsocks_backserver\n\nthe URL/IP address where the socks backconnect proxy should connect to\n\nreserved\n\nencrypted data, from the context of the use of the data it seems that this is a list\nof fallback URLs for the download of the dynamic config (see section 4.4)\n\ngrabber_pause\n\ntime in minutes how long to wait until starting the grabber module\n\nThere are some additional configuration values that can be provided which are not\ndirectly used by the sample, but probably used in one of the modules:\n\ngrab_softlist/grab_pass/grab_form/grab_cert/grab_cookie/grab_del_cookie/grab_del_cache\n\nflags denoting whether the grabber module should grab specific data or to delete\nsome data (cookies, cache)\n\n\n-----\n\n4.2 Configuration 17\n\ndgaconfigs\n\nthe url for the DGA config file; the DGA config file contains a list of URL suffixes\nwhich are appended to a generated string from where the bot will try to download\nthe next dynamic configuration\n\nwebfilters\n\na list of URL masks where Panda can take special actions (see section 5.7)\n\nwebinjects\n\nURLs, payloads, and location descriptions for the webinjects\n\n##### 4.2.4 Local Settings\n\nAdditionally, Panda stores some run-time settings in a structure called LocalSettings by\nthe malware authors. These settings are not meant to control the behaviour of the bot, it\nis more like a temporary data store of values that are client specific and need to be kept\neven after the malware is restarted (e. g. because of a system reboot). The structure\ncontains the following values:\n\ndwModuleStartFlags\n\nbitmap denoting which of the modules has been started\n\ndwGrabberFlags\n\nbitmap denoting which of the http grabber features has been enabled\n\ndwPandaAntivirusFound\n\nset to 1 if Panda Antivirus was found, changes the behaviour of the bot update\n\ndwHashSet\n\nbitmap denoting which of the hashes has been set\n\nszConfigId, szWebinjectsId, szUpdateId, szGrabberId, szVnc32Id, szVnc64Id, szBacksocksId\n65-byte buffers to store the hashes of the respective files/modules\n\ndwCurrentUrlIdx\n\nthe index of the currently used update URL in the list fallback URLs\n\ndwUrlRetryCount\n\nthe retry count of the URL specified by dwCurrentUrlIdx ; maximum value is set\nin the base config\n\nwBacksocksBackserverPort\n\nthe port of the server of the backconnect socks proxy\n\nwVncBackserverPort\n\nthe port of the server of the backconnect vnc module\n\n\n-----\n\n4.3 Bot Update 18\n\n#### 4.3 Bot Update\n\nOnce persisted in the victimâ€™s system, Panda is able to update the malware executable by\nits own. In the usual case, Panda therefore downloads the new executable to a temporary\nfile. The file is located in the directory returned by GetTempPathW. The name of the\nfile is of the form updXXXXXXXX.exe where XXXXXXXX is the hexadecimal representation\nof a 4-byte random number. After writing the file and applying the PeSettings to the\nExtended File Attributes, the â€updateâ€ is executed using CreateProcessW with -f as an\nargument flag. This triggers the â€updateâ€ functionality of the bot so that all necessary\nsettings are copied over to the new executable.\nIn the case of having Panda Antivirus present in the system, Panda overwrites the\nold malware executable in place and directly copies over the local settings instead of\ncreating and executing a temporary file.\n\n#### 4.4 Configuration Update\n\nOne of the first things Panda does after initializing itself and persisting in the system is\nto download a dynamic configuration from the command-and-control server. To do so,\nPandaâ€™s base configuration (see section 4.2.1) contains a list of URLs from where to get\nthe initial dynamic configuration. If the command-and-control server is already taken\ndown at the time of checking, Panda cannot download a dynamic configuration and fails\nto exfiltrate any information. It still hooks all functions and gathers data (keystrokes,\netc) but these information will never leave the system until the bot is able to download\na (new) dynamic configuration.\nThe download routine for the dynamic configuration uses three different ways to get a\ndynamic configuration. First, it tries to get a dynamic configuration file from the URL\nprovided in url_config in the old dynamic config. Of course, this only works if Panda\nalready received a dynamic config once. If it did not receive a dynamic config at that\npoint, it tries to get a configuration file from each of the command-and-control domains\nof the base config.\nIn case Panda is not able to download the dynamic config using the URL from the\nurl_config field and the fallback command-and-control hosts (the malware allows for 5\nfailed retries for each of the domains), Panda takes the encrypted data from the reserved\nfield, decrypts it, and tries to download a dynamic config from one of the URLs of that\ndata.\nIf Panda is still not able to get a dynamic config at that point, it uses a domain\ngeneration algorithm to generate a possible hostname. Therefore, it takes the current\nsystem timestamp and modifies it a way that it stays the same for three days (set msec,\nsec, minute, hour to zero and subtract (ğ‘‘ğ‘ğ‘¦ğ‘‚ğ‘“ğ‘€ğ‘œğ‘›ğ‘¡â„ mod 3) * ğ‘ ğ‘’ğ‘ğ‘ ğ‘ƒğ‘’ğ‘Ÿğ·ğ‘ğ‘¦ seconds\nfrom it). Then, Panda takes the built-in RC4 key to initialize a RC4 state and xores the\ntimestamp onto it (first 8 bytes xor with plain timestamp, second 8 bytes with binary\ninverted timestamp) and calculates the SHA256 sum of the RC4 state. The result is\nthen converted to a hex string and is used as the first part of the generated domain. The\n\n\n-----\n\n4.4 Configuration Update 19\n\nsecond part of the domain is one of the domain suffixes from the base config and looks\nlike â€XX.tld/filename.extâ€ for the sample I analyzed. But the suffix can change and is\nnot bound to any special requirements except for that it needs to make a valid domain\nfrom the generated name.\n\n\n-----\n\n## 5 Payload and Persistence\n\n#### 5.1 Persistence\n\nAs part of the initialization procedure, Panda tries to persist in the following manner:\nFirst, it finds a suitable folder for the malware executable to reside in. In our case, it\nchose %APPDATA%\\Sun\\Java. It then moved the malware executable from the desktop\nto that folder and renamed it to Desktop (Create Shortcut).exe. Panda also creates\nthree extra files with random file extensions which will be later used to temporarily store\ndata. After moving the malware executable to the new folder, Panda adds a new value\nto the HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run registry key.This ensures that the malware is executed each time the infected user logs into the system.\nAdditionally, it writes the initial PeSettings to Desktop (Create Shortcut).exe (see\nsection 4.2.2).\n\n#### 5.2 HTTP Grabber and Injector\n\nSince Panda is a banking trojan, its main purpose is to steal money from a victimâ€™s\nbank account and to grab login credentials for the bank accounts (and possibly other\nweb services) wherever possible. A crucial part of its activity therefore is to intercept\nthe web traffic of the victimâ€™s web browser(s) and to manipulate the content of the web\npage that is displayed in the browser. In order to achieve these goals Panda uses process\ninjection (section 5.3) and API hooking (section 5.4). To know which web pages should\nbe manipulated, Panda receives a list of URL masks and corresponding inject data. The\ninject data consist of the actual inject (script inclusion from attacker-controlled web\nserver) and a description of the position where the inject has to be placed in the website.\nThe included script is actually only a loader that loads the second stage of the inject\nwhich then communicates with the Panda web backend and does further modifications\nto the web page.\nBut there is a problem: todayâ€™s web browser implement a feature called contentsecurity policy. With (one of) the CSP header(s) sent by the web server, a website\nowner can tell the browser in detail, from where to load e.g. additional JavaScript code.\nCorrectly configured, this hinders Panda to retrieve the second stage loader because it\nis loaded from a different web server. But since Panda is a man-in-the-browser malware,\nit can remove those headers from the server response and the browser will retrieve the\nloader.\nAdditionally, Panda removes the TE and If-Modified-Since headers from the request\nif the hijacked process is either Firefox or Chrome. This has two implications: web\n\n\n-----\n\n5.2 HTTP Grabber and Injector 21\n\nservers will never send responses that have another transfer encoding than chunked (or\nno transfer encoding at all) and the server will always send a response that contains a\nHTTP response body. If Panda would not remove the If-Modified-Since header, a\nweb server might send a response with a 304 status code and no response body content.\nUsually, this instructs the browser to use a cached version of the web page because the\npage content did not change since the last request (the time of the last request is specified\nin the If-Modified-Since header field). But since Panda intercepts web traffic between\nthe raw socket and the handling of the browser, it cannot inject the malicious code into\nthe response body because the web server never sent some. So, Panda must ensure that\nthe web server sends a response body to be able to execute its injects. This can be\nachieved by removing the If-Modified-Since header and thereby simulating a fresh\nrequest to the web server.\nAnother thing Panda needs to take care of is Accept-Encodings. If the web server\nsends encoded data (e.g. gzipâ€™ed), Panda will need to decode it to be able to analyze\nthe response and maybe inject code. To avoid this, Panda simply changes (or adds) the\nAccept-Encoding request header to contain only identity which tells the web server to\nonly send plain responses without any encoding at all.\nSince Panda uses URL masks to detect which pages it should inject code into, it might\nhappen that the masks match pages that do not contain valid HTML data (e.g. pictures,\ndocuments). In order to avoid those files, Panda checks the server response for specific\nContent-Types. Only if a valid content type is specified in the response header Panda\ntries to find injection points in the data. Valid content types are:\n\n_âˆ™_ text/\n\n_âˆ™_ application/x-javascript\n\n_âˆ™_ application/javascript\n\n_âˆ™_ application/xml\n\n_âˆ™_ application/xhtml+xml\n\n_âˆ™_ application/octet-stream\n\n_âˆ™_ application/json\n\nPanda does not only inject data into web pages, it already grabs data at that point. If\nPanda finds any Authentication headers in the request, it checks for basic authentication\nand extracts username and password from it and adds it to the report. Additionally,\nPanda can extract all request data from GET and POST requests and reports them to the\ncommand-and-control server.\nFor a more detailed analysis on how the actual webinjects work and what the communication with the ATS looks like, please see our blogposts by Manuel KÃ¶rber-Bilgard\nand Karsten Tellmann[1 2]\n\n1\nhttps://cyber.wtf/2017/02/03/zeus-panda-webinjects-a-case-study/\n2\nhttps://cyber.wtf/2017/03/13/zeus-panda-webinjects-dont-trust-your-eyes/\n\n\n-----\n\n5.3 Process Injection 22\n\n#### 5.3 Process Injection\n\nTo apply its hooks, Panda needs to be part of each specific process space it wants to\nhook the functions in. In order to inject itself into the right process, Panda checks if the\ncurrent targeted process fulfills some requirements:\n\n_âˆ™_ targeted process id Ì¸= current process id (â†’ avoid injecting into its own process)\n\n_âˆ™_ targeted process owner = current process owner (â†’ avoid permission violation)\n\n_âˆ™_ the targeted process name must be one of: firefox.exe, chrome.exe, iexplore.exe,\npanda.exe, MicrosoftEdge.exe, or MicrosoftEdgeCP.exe\n\nIf all of those requirements are given, Panda injects itself into the process. This is\ndone by allocating a virtual memory buffer of sufficient size in the target process using\nVirtualAllocEx. It then needs to relocate the copied binary because the old module\nbase is most probably not the same it is in the remote one. If the relocation succeeded,\nPanda writes itself into that freshly allocated memory section. Afterwards, Panda copies\nover run-time data that has been modified by the infecting process during initialization\nand which is needed by the injected code.\nAfter Panda successfully wrote all data into the address space of the targeted process,\nit creates a thread in this process. The thread continues to install the hooks and all\nexecute all other necessary functions.\n\n#### 5.4 API Hooking Technique\n\nAs described in sections 5.5.1, 5.5.2, 5.5.3, and 5.5.4, Panda uses a hot-patch like function\noverriding method to hook its desired functions. Therefore, Panda overwrites the first 5\nbytes of the function to contain a jump to its hook function. Because Panda needs to call\nthe original function after doing its work in the hook function, it saves the overwritten\ninstructions in a temporary buffer. For this purpose Panda has a built-in instruction\nlength decoder. It then redirects the internal function resolver cache to point to that\narea (a so-called trampoline). Probably Panda does this to prevent an infinite recursion\nwhen the hook calls the hooked function. Interestingly, Panda searches itâ€™s own IAT for\nhooked functions. However, as Panda has replaced importing through the IAT with the\nimport resolver function (for most functions including all hooked functions) this has no\npurpose.\n\n#### 5.5 Hooks and Browser Manipulation\n\nAfter Panda successfully injected into its target processses (see section 5.3), it starts\nhooking all necessary functions to provide banking trojan capabillities. The detailed\ntechnique is described in section 5.4 so this section focuses on the individual browser\nand how Panda implements its malicious activities.\n\n\n-----\n\n5.5 Hooks and Browser Manipulation 23\n\nFigure 5.1: Flowgraph of the process infection thread.\n\n##### 5.5.1 Internet Explorer\n\nSince Internet Explorer is a browser made by Microsoft, it vastly depends on functions\nfrom the Windows API and has no dependencies on third-party DLLs that need to be\nconsidered when hooking Internet Explorer. The actual hooks are done by overwriting\nsome bytes in the function prologue (see section 5.4). The list of functions hooked by\nPanda is as follows:\n\n_âˆ™_ wininet!HttpSendRequestW\n\n_âˆ™_ wininet!HttpSendRequestA\n\n_âˆ™_ wininet!HttpSendRequestExW\n\n_âˆ™_ wininet!HttpSendRequestExA\n\n_âˆ™_ wininet!InternetReadFile\n\n_âˆ™_ wininet!InternetReadFileExW\n\n_âˆ™_ wininet!InternetReadFileExA\n\n\n-----\n\n5.5 Hooks and Browser Manipulation 24\n\n_âˆ™_ wininet!InternetQueryDataAvailabe\n\n_âˆ™_ wininet!InternetCloseHandle\n\n_âˆ™_ wininet!HttpOpenRequestW\n\n_âˆ™_ wininet!HttpOpenRequestA\n\n_âˆ™_ wininet!HttpQueryInfoA\n\n_âˆ™_ wininet!InternetConnectW\n\n_âˆ™_ wininet!InternetConnectA\n\n_âˆ™_ wininet!InternetWriteFile\n\nAdditionally, Panda disables the phishing filter to avoid triggering it with the web injects,\nthrough modifying the following registry keys:\n\n_âˆ™_ HKCU\\Software\\Microsoft\\Internet Explorer\\PhishingFilter\\Enabled\n\n_âˆ™_ HKCU\\Software\\Microsoft\\Internet Explorer\\PhishingFilter\\EnabledV8\n\n_âˆ™_ HKCU\\Software\\Microsoft\\Internet Explorer\\PhishingFilter\\EnabledV9\n\nAnd it sets several internet zone policies to allow in order to get access to cookies and\nenable cross site script includes:\n\n_âˆ™_ URLACTION_CROSS_DOMAIN_DATA\n\n_âˆ™_ URLACTION_HTML_MIXED_CONTENT\n\n_âˆ™_ URLACTION_COOKIES\n\n_âˆ™_ URLACTION_COOKIES_ENABLED\n\n_âˆ™_ URLACTION_COOKIES_SESSION\n\n_âˆ™_ URLACTION_COOKIES_THIRD_PARTY\n\n_âˆ™_ URLACTION_COOKIES_SESSION_THIRD_PARTY\n\nAnd finally it disables the â€œbad certificateâ€ warning by modifying the registry key\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\WarnonBadCertRecving\n\n\n-----\n\n5.5 Hooks and Browser Manipulation 25\n\n##### 5.5.2 Mozilla Firefox\n\nAs described in section 5.5.3, Firefox uses a dynamically linked NSPR4.dll. This lowers\nthe bounds for the malware to hook all necessary functions. Panda hooks the functions\nPR_Close, PR_Read, PR_Write, and PR_Poll by overwriting some bytes in the function\nprologue like it does for all Windows API hooks (see section 5.4).\nSimilarly to Internet Explorer, Panda modifies the user preferences the better fit the\nneeds of the malware. In the case of Firefox, it walks through the profiles directory of\nFirefoxâ€™s settings directory (%APPDATA%\\Mozilla\\Firefox) and sets the following user\npreferences to false:\n\n_âˆ™_ privacy.clearOnShutdown.cookies\n\n_âˆ™_ security.warn_viewing_mixed\n\n_âˆ™_ security.warn_viewing_mixed.show_once\n\n_âˆ™_ security.warn_submit_insecure\n\n_âˆ™_ security.warn_submit_insecure.show_once\n\n_âˆ™_ security.warn_entering_secure\n\n_âˆ™_ security.warn_entering_weak\n\n_âˆ™_ security.warn_leaving_secure\n\n_âˆ™_ network.http.spdy.enabled\n\n_âˆ™_ network.http.spdy.enabled.v2\n\n_âˆ™_ network.http.spdy.enabled.v3\n\n##### 5.5.3 Google Chrome\n\nHooking Googleâ€™s Chrome browser is different compared to Firefox or Internet Explorer,\nbecause Chrome uses functions from both the Windows API and Mozillaâ€™s NSPR4 library. The Windows API functions are as described in section 5.4. The difference\nbetween hooking Firefox and Chrome is that Chrome has a statically linked nspr4.dll\ninstead of a dynamically linked one like Firefox has. Unfortunately, this has the consequence that one is not able to use GetProcAddress to get the address of the function and\nto overwrite some bytes at that address. However, Chrome internally uses a global struct\nof function pointers pointing to the actual functions. A pointer to this struct is shipped\nwith each connection that is made by the browser. Panda tries to find the global struct\nand overwrites the function pointers in that specific struct to hook Chromeâ€™s NSPR4\nfunctions. The list of hooked functions (including Window API function) is as follows:\n\n_âˆ™_ PR_Write (NSPR4 overwrite)\n\n\n-----\n\n5.6 Plug-in ability 26\n\n_âˆ™_ PR_Read (NSPR4 overwrite)\n\n_âˆ™_ PR_Close (NSPR4 overwrite)\n\n_âˆ™_ closesocket (WinAPI-Hook)\n\n_âˆ™_ WSARecv (WinAPI-Hook)\n\n_âˆ™_ WSASend (WinAPI-Hook)\n\n_âˆ™_ recv (WinAPI-Hook)\n\n##### 5.5.4 User Functions\n\nIn addition to the MITB hooks, Panda can also take screenshots, logs keyboard input,\nand watches for clipboard pastes.\nTo be able to log keyboard input, Panda hooks TranslateMessage for each process\nit is injected into. It then checks each windows message for WM_KEYDOWN and logs the\n(unicode) character representation of the pressed key. Additionally, Panda listens for\nWM_MOUSEBUTTONDOWN events and triggers a screenshot for each of the next 100 mouse\nclicks if a corresponding webfilter was triggered previously (see section 5.7 for a description of the webfilters).\nAdditionally, Panda hooks GetClipboardData. Hooking this specific function allows\nthe malware authors to capture passwords that are not typed by the user but instead\nare pasted into the form fields in the browser (e. g. because the passwords are saved in\na file on disk or because the user uses a password manager).\n\n#### 5.6 Plug-in ability\n\nThe Panda malware has the ability to dynamically load malware modules from web\nresources and to execute them in-place. This makes Panda a very flexible malware that\ncan be retrofitted for other purposes.\nTechnically, they re-implemented LoadLibrary without the need of having the actual\nlibrary on disk. First, the malware allocates enough space for the loaded DLL in the\nvirtual memory of its process using VirtualAlloc. Afterwards, Panda section-wise\ncopies the DLL into the previously allocated block of memory. Because DLLs are position\nindependent, the third step is to relocate the sections. To achieve that, Panda walks\nthrough the relocation table (.reloc section) and resolves the required relocations by\napplying the base of the corresponding section to it. Panda also needs to resolve the\nimports of the module. The list of imports can be shortly described as a \"what-where\"\nlist. For each of the entries in the list, Panda uses LoadLibrary and GetProcAddress to\nresolve the address of the imported function and writes it to the corresponding entry in\nthe list. Finally, it calls the DllMain function of the loaded library to hand over control\nto the initialization function of the DLL.\nPanda uses this technique to dynamically load its HttpGrabber, Socks proxy, and\nVNC server modules into the current process space.\n\n\n-----\n\n5.7 Webfilters 27\n\n#### 5.7 Webfilters\n\nPanda implements a feature that is called â€œwebfiltersâ€ by the malware authors. Although,\nâ€œfiltersâ€ is not the correct term from my point of view. Consider !http://*microsoft.com*\nas an example for such a webfilter. The first character obviously does not belong to the\nactual URL although it should be clear that the exclamation mark stands for something\nlike â€œnotâ€. The position of the exclamation mark can be called â€œactionâ€ and is followed\nby the actual URL which can contain asterisks as placeholders for â€œany charactersâ€. The\nfull list of actions is as follows:\n\nP\n\nreport request content if request type is POST\n\nË†\n\nblock access to website and report the request content\n\n| (pipe symbol)\nduring my analysis I was not yet able to determine what this is used for\n\n@\n\ntakes a screenshot (500x500 pixels) on each of the next 100 mouse clicks (at max)\n\n!\n\ndonâ€™t write a report or analyze the data\n\n#\n\ntakes a screenshot (fullscreen) on each of the next 100 mouse clicks (at max)\n\n%\n\ntrigger the start of the VNC module (if not already started)\n\n&\n\ntrigger the start of the socks proxy module (if not already started)\n\n#### 5.8 Remote Script\n\nIn addition to the automatic information gathering, Panda provides a script-like interface\nwhere it can take several commands and performs actions on the victimâ€™s PC accordingly.\nUnfortunately, the script commands are hashed using CRC32 before comparing to the\nlist of handlers so that we were not able to tell the names of the commands. But\nnevertheless we were able to determine the purpose of the commands by looking at their\nrespective handlers. The possible actions the remote script can trigger, are:\n\nset shutdown flag\n\nshutdown PC after the script finished\n\nset maintenance shutdown flag\n\nshutdown PC in â€œminor maintenanceâ€ mode\n\n\n-----\n\n5.8 Remote Script 28\n\nuninstall\n\nremoves the bot from the PC\n\nupdate bot\n\n(force) updates the binary executable of the bot\n\nupdate config\n\n(force) updates the botâ€™s dynamic configuration\n\nblock or unblock webinjects\n\nallows for disabling or enabling certain webinjects\n\nlist files matching a given path pattern\n\nsearches the local file system for all files matching the pattern and adds the list to\nthe report\n\nread files matching a given path pattern\n\nsearches the local file system for all files matching the pattern and adds the content\nof the files to the report\n\nremove a local file\n\ndeletes a file from the local file system\n\nexecute remote file\n\ndownloads and executes an arbitrary file\n\nblock or unblock a given URL\n\nallows for blocking or unblocking a given URL so that the user can (or cannot)\nopen the page in the browser\n\nenable HttpGrabber features\n\ngrab passwords, forms, certificates, cookies (1+2), delete cookies (1+2), softlist,\ndelete cache\n\nstart VNC module\n\n(force) starts the VNC module\n\nstart VNC module and set a flag in the local settings\n\n(force) start the VNC module and sets the appropriate flag in the local settings\n\nstart socks module\n\n(force) starts the Socks proxy module\n\nstart socks module and set a flag in the local settings\n\n(force) starts the Socks proxy module and sets the approriate flag in the local\nsettings\n\n\n-----\n\n5.9 System Report 29\n\n#### 5.9 System Report\n\nEach time Panda communicates with the command-and-control server, it sends status\ninformation about the bot back to the command-and-control server. The exact information depend on the type of the message sent to the server. But there are five groups of\ninformation that can be sent:\n\nSYSINFO_TIME\n\n_âˆ™_ current system time (UTC)\n\nSYSINFO_USER\n\n_âˆ™_ the name of the process executable where the control process resides in\n\n_âˆ™_ the current system user\n\nSYSINFO_BOTVERSION\n\n_âˆ™_ bot ID\n\n_âˆ™_ the botnet the client is part of\n\n_âˆ™_ the version of the bot\n\nSYSINFO_OS\n\n_âˆ™_ system version (e. g. 6.1 for Windows 7)\n\n_âˆ™_ service pack number\n\n_âˆ™_ build id\n\n_âˆ™_ architecture (32/64 bit)\n\n_âˆ™_ server edition?\n\n_âˆ™_ default ui language\n\nSYSINFO_MISC\n\n_âˆ™_ network latency\n\n_âˆ™_ localized time\n\n_âˆ™_ computer name\n\n_âˆ™_ installed antivirus, antispyware, and firewall products\n\n\n-----\n\n## 6 Conclusion\n\nPanda must be considered to be among the more advanced types of malware. The code\nbasis is large and sports a number of features not found in less sophisticated malware.\nThese features include extensive anti-analysis code and an advanced hooking framework\nin which Panda brings, among other things, its own instruction length decoder. The\ncode seems to be mature and the quality of the code appears to be above the average\nfor malware.\nThe main purpose of Panda is to serve as a bankning trojan. Therefore its author\nequipped the malware with sophisticated capabilities and supports all major browsers\nin the Windows ecosystem. However, Panda shows significant flexibility allowing it to\nbe used for other malicous purposes. For example, Panda implements a modifiable\nconfiguration that can be changed at any time by the attacker. Additionally, Panda is\nable to spy on user activity, provides a remotely accessible scripting language, and has\nthe abillity to load a VNC server and a SOCKS proxy module to provide additional\nremote access features to the attacker.\nThus, the Panda trojan family remains a considerable threat even six years after the\nZeus source was made public.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        },
        {
            "id": "6fc23d14-23a6-4870-8fad-b291b182596f",
            "created_at": "2022-10-25T16:07:18.480113Z",
            "updated_at": "2022-10-25T16:07:18.480113Z",
            "deleted_at": null,
            "name": "ETDA",
            "url": "https://apt.etda.or.th",
            "description": "Threat Group Cards: A Threat Actor Encyclopedia",
            "reports": null
        },
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://cyberwtf.files.wordpress.com/2017/07/panda-whitepaper.pdf"
    ],
    "report_names": [
        "panda-whitepaper.pdf"
    ],
    "threat_actors": [
        {
            "id": "2f07a03f-eb1f-47c8-a8e9-a1a00f2ec253",
            "created_at": "2022-10-25T16:07:24.277669Z",
            "updated_at": "2025-03-27T02:02:10.157972Z",
            "deleted_at": null,
            "main_name": "TA428",
            "aliases": [
                "Operation LagTime IT",
                "Operation StealthyTrident",
                "ThunderCats"
            ],
            "source_name": "ETDA:TA428",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "Agent.dhwf",
                "Albaniiutas",
                "BlueTraveller",
                "Chymine",
                "Cotx RAT",
                "CoughingDown",
                "Darkmoon",
                "Destroy RAT",
                "DestroyRAT",
                "Gen:Trojan.Heur.PT",
                "Kaba",
                "Korplug",
                "LuckyBack",
                "PhantomNet",
                "PlugX",
                "Poison Ivy",
                "RedDelta",
                "RoyalRoad",
                "SManager",
                "SPIVY",
                "Sogu",
                "TIGERPLUG",
                "TManger",
                "TVT",
                "Thoper",
                "Xamtrav",
                "pivy",
                "poisonivy"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716504,
    "ts_updated_at": 1743041145,
    "ts_creation_date": 1501247635,
    "ts_modification_date": 1501247635,
    "files": {
        "pdf": "https://archive.orkl.eu/25721217548ed812173d49e7d59abd68dbdc4e9b.pdf",
        "text": "https://archive.orkl.eu/25721217548ed812173d49e7d59abd68dbdc4e9b.txt",
        "img": "https://archive.orkl.eu/25721217548ed812173d49e7d59abd68dbdc4e9b.jpg"
    }
}