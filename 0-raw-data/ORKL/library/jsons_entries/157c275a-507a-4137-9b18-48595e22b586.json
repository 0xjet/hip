{
    "id": "157c275a-507a-4137-9b18-48595e22b586",
    "created_at": "2023-01-12T15:06:59.892567Z",
    "updated_at": "2025-03-27T02:13:07.857178Z",
    "deleted_at": null,
    "sha1_hash": "d41cd3a40217598ffb6f0bfdeeccbf90bb2a025b",
    "title": "2022-03-19 - LockBit Ransomware v2.0",
    "authors": "",
    "file_creation_date": "2022-05-27T23:24:56Z",
    "file_modification_date": "2022-05-27T23:24:56Z",
    "file_size": 6042652,
    "plain_text": "# LockBit Ransomware v2.0\n\n**[chuongdong.com/reverse engineering/2022/03/19/LockbitRansomware/](https://chuongdong.com/reverse%20engineering/2022/03/19/LockbitRansomware/)**\n\nChuong Dong March 19, 2022\n\n[Reverse Engineering · 19 Mar 2022](http://10.10.0.46/categories/#reverse%20engineering)\n\n## LockBit CTI\n\nOn 4 February 2022, the FBI issued FLASH security advisory on Indicators of Compromise (IOCs)\nassociated with LockBit 2.0 ransomware, one of the most active ransomware groups in the current\ncybercrime ecosystem.\n\nThe LockBit gang (aka Bitwise Spider) are the developers of the LockBit Ransomware-as-a-Service\n(RaaS). LockBit ransomware first appeared in September 2019 and in June 2021, the group rebranded to\n**LockBit 2.0, like several other families did in 2021. LockBit 2.0 has been responsible for various high-**\nprofile attacks in 2021, including victims such as Accenture, following the launch of a marketing\ncampaign to recruit new affiliates in mid-2021. The rebranded version of LockBit includes several new\nfeatures, including self-propagation, removal of shadow copies, bypass User Account Control (UAC),\nESXi support, and the printing of ransom notes via printers detected on the victim’s network. The group\nalso prides itself on having the fastest encryption on the ransomware market. This is because it uses a\nmultithreaded approach in encryption and only partially encrypts the files, as only 4 KB of data is\nencrypted per file.\n\n**LockBit 2.0 is represented on the Russian-speaking cybercrime forums as “LockBitSupp” on multiple**\nsites, including RAMP, Exploit[.]in, and XSS[.]is, where they recruit affiliates and advertises its RaaS.\n**LockBit has grown to become the leading group for the highest number of victims published to its**\ndarknet leak site after overtaking Conti in early 2022. Prior to encryption, Lockbit affiliates can use the\nStealBit application obtained directly from the Lockbit panel to exfiltrate specific file types. The desired\nfile types can be configured by the affiliate to tailor the attack to the victim. The affiliate configures the\napplication to target a desired file path, and, upon execution, the tool copies the files to an attackercontrolled server using http. Due to the nature of the affiliate model, some attackers use other data theft\navailable tools such as Rclone and MEGAsync to achieve the same results. Lockbit 2.0 actors also use\ncloud file sharing services including, privatlab[.]net, anonfiles[.]com, sendspace[.]com, fex[.]net,\ntransfer[.]sh, and send.exploit[.]in to send data stolen from victim networks.\n\nAll credits in this part goes to Equinix’s [Will Thomas for the awesome intel on the ransomware group!](https://twitter.com/BushidoToken)\n\n## Overview\n\nThis report is my brief analysis for the LockBit Ransomware v2.0.\n\nIn the analysis, I cover all of LockBit’s ransomware functionalities. However, I left out details about some\nfunctionalities because I was really lazy and burned out by the time I finished analyzing lol.\n\n**LockBit uses a hybrid-cryptography scheme of Libsodium’s XSalsa20-Poly1305-Blake2b-Curve25519**\nand AES-128-CBC to encrypt files. The malware’s configuration is XOR-encrypted and stored in static\nmemory Like REvil and BlackMatter LockBit’s child threads use a shared structure to divide the\n\n\n-----\n\nencryption work into multiple states while encrypting a file.\n\nWith the elaborated multithreading architecture, LockBit’s performance is relatively fast compared to\nmost ransomware in the field.\n\n_Figure 1: LockBit Leak Site._\n\n**LockBit is definitely the most sophisticated ransomware I have taken a look at, and it was a lot of fun**\nanalyzing and figuring it out.\n\nMy analysis is 96% based on static analysis in IDA because I am unfortunately too lazy for dynamic\nanalysis. Therefore, this report only covers what I see in the code and how I understand them. Enjoy!\n\n## IOCS\n\n[The sample I used is a 32-bit Windows executable. Huge shoutout to vx-underground for sharing it.](https://twitter.com/vxunderground)\n\n**MD5: 63dcf75ad743b292e4a6cd067ffc2c18**\n\n**SHA256: 9feed0c7fa8c1d32390e1c168051267df61f11b048ec62aa5b8e66f60e8083af**\n\n**Sample:**\nhttps://bazaar.abuse.ch/sample/9feed0c7fa8c1d32390e1c168051267df61f11b048ec62aa5b8e66f60e8083af/\n\n\n-----\n\n_Figure 2: LockBit Victim Portal._\n\n## Ransom Note\n\nThe content of the ransom note is XOR-encrypted in LockBit’s executable, which is dynamically\ndecrypted once and written to the ransom note file in every directory.\n\nThe ransom note filename is Restore-My-Files.txt.\n\n_Figure 3: LockBit Ransom Note._\n\n## Static Code Analysis\n\n Anti-Analysis: Anti-Debug Check\n\nAt the beginning of the entry point function, LOCKBIT checks the NtGlobalFlag field in the Process\n**Control Block (PEB) to detect if the malware process is being debugged.**\n\nThis is done by comparing the field’s value to 0x70, which indicates that the flags\n**FLG_HEAP_ENABLE_TAIL_CHECK, FLG_HEAP_ENABLE_FREE_CHECK,**\n**FLG_HEAP_VALIDATE_PARAMETERS are set.**\n\n\n-----\n\nIf the process is being debugged, the malware hangs indefinitely.\n\n_Figure 4: Anti-Debug Check._\n\n## Anti-Analysis: Stack String\n\nMost important strings in LockBit’s executable are encoded and stored as a stack string. Before being\nused, they are decoded dynamically through some simple computation such as addition, subtraction, or\nXOR-ing.\n\n_Figure 5: Stack String Obfuscation._\n\n## Anti-Analysis: Inline Dynamic API Resolving\n\nLike most major ransomware, LockBit resolves APIs dynamically to make static analysis harder, but\nunlike many, LockBit inlines the entire resolving process, making the decompiled code much larger to\nanalyze.\n\n\n-----\n\nFirst, to resolve these APIs dynamically, their respective libraries need to be loaded in memory initially.\nSince Kernel32 is already loaded from LockBit’s few imports, the malware locates it and resolves\n**LoadLibraryA to load others in memory.**\n\n_Figure 6: Stack String Obfuscation._\n\nAfter retrieving LoadLibraryA, LockBit resolves each DLL’s name is resolved as a stack string and calls\n**LoadLibraryA to load it in memory.**\n\nBelow is the list of the loaded libraries.\n\n_gdiplus.dll, ws2_32.dll, shell32.dll, advapi32.dll, user32.dll, ole32.dll, netapi32.dll, gpredit.dll,_\n_oleaut32.dll, shlwapi.dll, msvcrt.dll, activeds.dll, gdiplus.dll, mpr.dll, bcrypt.dll, crypt32.dll,_\n_iphlpapi.dll, wtsapi32.dll, win32u.dll, Comdlg32.dll, cryptbase.dll, combase.dll, winspool.drv_\n\nWhen retrieving an API address from memory, the malware first locates its DLL’s base by iterating the\nPEB’s loader module linked list and checks the library name of each entry. Each name (in lowercase) is\nhashed using FNV1A and compared to a hard-coded hash, and the corresponding DLL base is returned.\n\n\n-----\n\n_Figure 7: Locating DLL Base._\n\nUsing the DLL base, LockBit accesses its export directory table and iterates through the name of each\nexport API. For each API’s name, the malware converts its characters to lower case and hash it with\n**FNV1A. The final hash is compared against a target hash, and if the hashes match, the malware**\nretrieves the address of the API’s name ordinals and uses that to index into the export table’s\n**AddressOfFunctions array to return the target API address.**\n\n\n-----\n\n_Figure 8: Iterating Through Export Directory Table._\n\n_Figure 9: Retrieving Target API’s Address._\n\nFor most of the APIs used throughout the executable, this process is completely inline every time, which\nsignificantly increases the amount of compiled code we need to look at. LockBit stores the resolved DLL\nbases and APIs in global memory to reuse them, so despite having a larger static code, the number of\ndynamic instructions is about the same compared to if this process is not inline. This makes reverse\nengineering the sample a bit more annoying while not compromising the performance of the code itself.\n\n## Computer Language Check\n\nLike a lot of ransomwares, LockBit checks the system’s languages to avoids encrypting machines in\nRussia and nearby countries.\n\n\n-----\n\nThe malware resolves GetSystemDefaultUILanguage and GetUserDefaultUILanguage and call them\nto check if the system or user default UI language is in the list to avoid below.\n\nAzerbaijani (Cyrillic, Azerbaijan), Azerbaijani (Latin, Azerbaijan), Armenian (Armenia), Belarusian\n(Belarus), Georgian (Georgia), Kazakh (Kazakhstan), Kyrgyz (Kyrgyzstan), Russian (Moldova),\nRussian (Russia), Tajik (Cyrillic, Tajikistan), Turkmen (Turkmenistan), Uzbek (Cyrillic, Uzbekistan),\nUzbek (Latin, Uzbekistan), Ukrainian (Ukraine)\n\n_Figure 10: Checking Blacklist Languages._\n\nIf the user or system UI language is blacklisted, the malware resolves ExitProcess and calls it to\nterminates itself immediately.\n\n\n-----\n\n_Figure 11: Terminating If Language Is Blacklisted._\n\n## Denying Access To Ransomware Process\n\nAfter loading all required libraries into memory, LockBit attempts to restrict access to its own process by\nmodifying its own access control list.\n\nFirst, it resolves and calls NtOpenProcess to get a handle to the current ransomware process. Then, the\nmalware resolves and calls GetSecurityInfo to retrieve the process’s security descriptor ACL.\n\n\n-----\n\n_Figure 12: Retrieving Process’s Security Descriptor ACL._\n\nNext, LockBit resolves and calls RtlAllocateAndInitializeSid to allocate and initialize an SID with the\nauthority of SECURITY_WORLD_SID_AUTHORITY for the EVERYONE group. It then calls\n**RtlQueryInformationAcl and RtlLengthSid to retrieve the process’s ACL length, calculates the size of a**\nnew ACL and allocate a virtual buffer for it. After creating the buffer, LockBit calls RtlCreateAcl to create\nthat new ACL and calls RtlAddAccessDeniedAce to add an ACCESS_DENIED access control entry\n(ACE) to this ACL for the EVERYONE group using the newly created SID above.\n\n_Figure 13: Creating A New ACL With Denied Access For EVERYONE Group._\n\nFinally, LockBit calls RtlGetAce to iterate through each ACE in the ransomware process’s ACL and\n**RtlAddAce to add the ACEs into the new ACL. After all the ACEs have been added to the new ACL, the**\nmalware calls SetSecurityInfo to set the new ACL to its own running process, which denies access from\n\n\n-----\n\neveryone to itself.\n\n_Figure 14: Populating & Setting New ACL To Current Process._\n\n## Default Error & Privilege Setting\n\nLockBit calls NtSetInformationProcess to set the current process’s default hard error mode to these 3\nflags.\n\n**SEM_FAILCRITICALERRORS: The system does not display the critical-error-handler message**\nbox and sends the error to the calling process.\n**SEM_NOGPFAULTERRORBOX: The system does not display the Windows Error Reporting**\ndialog.\n**SEM_NOALIGNMENTFAULTEXCEPT: The system automatically fixes alignment faults.**\n\nIt also calls RtlAdjustPrivilege to enable the SE_TAKE_OWNERSHIP_PRIVILEGE privilege to be able\nto later take ownership of files during encryption.\n\n_Figure 15: Default Error & Privilege Setting._\n\n## Configuration Decryption\n\n**LockBit’s configuration is divided into two different parts, which are data and flags.**\n\n\n-----\n\nThe data part is encoded and stored statically in the executable, which contains the following fields.\n\nEMF file 1: Contain the vector graphic for the text “ALL YOUR IMPORTANT FILES ARE STOLEN\nAND ENCRYPTED”\nEMF file 2: Contain the vector graphic for the text “LOCKBIT 2.0”\nBlender Pro Medium TTF file\nProxima Nova TTF file\nLockBit text PNG\nLockBit icon PNG\nLockBit icon large PNG\nProcess list: list of processes to terminate, each separated by a comma\nService list: list of services to stop, each separated by a comma\n\n_Figure 16: Decoding Configuration Data._\n\nThe decoding process is quite simple since it’s just XOR-ing each encoded byte with 0x5F.\n\n_Figure 17: Configuration Decoding Algorithm._\n\n\n-----\n\n[You can find the files listed above here.](https://github.com/cdong1012/IDAPython-Malware-Scripts/tree/master/Lockbit/lockbit_dropped_files)\n\nBelow is the process and service to terminate lists.\n\nProcess list:\n```\n   wxServer,wxServerView,sqlmangr,RAgui,supervise,Culture,Defwatch,winword,QBW32,QBDBMgr,qbupda\n    Cloud,Adobe Desktop Service,CoreSync,Adobe CEF,Helper,node,AdobeIPCBroker,sync   taskbar,sync   worker,InputPersonalization,AdobeCollabSync,BrCtrlCntr,BrCcUxSys,SimplyConnectionManager,Sim\n   exp-engine   service,TeamViewer_Service,TeamViewer,tv_w32,tv_x64,TitanV,Ssms,notepad,RdrCEF,sam,oracle,oc\n\n```\nService list:\n```\n   wrapper,DefWatch,ccEvtMgr,ccSetMgr,SavRoam,Sqlservr,sqlagent,sqladhlp,Culserver,RTVscan,sqlb\n    msmdsrv,tomcat6,zhudongfangyu,vmware-usbarbitator64,vmware   converter,dbsrv12,dbeng8,MSSQL$MICROSOFT##WID,MSSQL$VEEAMSQL2012,SQLAgent$VEEAMSQL2012,SQLBr\n   Exchange,MSSQL$MICROSOFT##SSEE,MSSQL$SBSMONITORING,MSSQL$SHAREPOINT,MSSQLFDLauncher$SBSMONIT\n\n```\nBecause the service/process names are separated by commas, the malware allocates a separate array\nin virtual memory to contain pointers to each name by copying the name into this new array for easy\naccess.\n\nThe process list is also parsed into two different arrays of pointers, one for storing the names as normal\nASCII strings and one for storing them as wide strings.\n\n_Figure 18: Parsing Lists of Processes & Services To Terminate_\n\n\n-----\n\nThe flags part of the configuration is stored in an array of bytes. Each byte corresponds to a specific\nexecution flag that LockBit checks for. The flag is enabled if the corresponding byte is 0xFF, and it’s\ndisabled if the corresponding byte is 0xAA.\n\n_Figure 19: Configuration Flags._\n\nBelow are the flags and their order in the array.\n\n**Index 0: Disable UAC bypass**\n**Index 1: Enable self deletion**\n**Index 2: Enable logging**\n**Index 3: Enable network traversal for file encryption**\n**Index 4, 5, 6: If all 3 are set, set group policies for Active Directory**\n**Index 7: Set registry for LockBit’s extension default icon**\n**Index 8: Print ransom note to network printer**\n\n## Privilege Escalation & Relaunch\n\nIn its first attempt, LockBit tries to privilege escalate if the user that runs the ransomware process is a\nservice account.\n\nFirst, the malware resolves NtOpenProcessToken and calls it to retrieve a handle for its own process’s\ntoken. Next, it calls GetTokenInformation using that token handle to retrieve information about the user\nassociated with that token.\n\n\n-----\n\n_Figure 20: Privilege Escalation: Retrieving Token & User Information._\n\nNext, LockBit calls AllocateAndInitializeSid to create an SID with S-1-5-18 as the SID identifier\nauthority, which is an SID of a service account that is used by the operating system. It then calls\n**EqualSid to compare the current user’s SID with the service account SID to check if the current user is a**\nservice account.\n\n\n-----\n\n_Figure 21: Privilege Escalation: Checking Service Account Privilege._\n\nIf the current user account is a service account, LockBit begins to escalate itself.\n\nFirst, it calls LoadLibraryA to load “Wtsapi32.dll” into memory and calls GetProcAddress to retrieve\nthe address of WTSQueryUserToken. Then, it calls GetModuleFileNameW to retrieve a full path to its\nown ransomware executable.\n\n_Figure 22: Privilege Escalation: Retrieving Path Of Ransomware Executable._\n\nNext, the malware calls WTSQueryUserToken with the session ID of\n**INTERNAL_TS_ACTIVE_CONSOLE_ID (0x7FFE02D8) to retrieve the primary access token for the**\nactive Terminal Services console session. If this function fails, the malware calls CreateProcessW to\nrelaunch its own executable as an interactive process with “winsta0\\default” as the default interactive\nsession.\n\n_Figure 23: Privilege Escalation: Unable To Get Active Terminal Services Console Session & Relaunching._\n\n\n-----\n\nIf the WTSQueryUserToken call is executed successfully, LockBit calls DuplicateTokenEx to duplicate\nthe Terminal Services console token and uses that duplicate token to create an elevated process to\nlaunch itself through CreateProcessAsUserW.\n\n_Figure 24: Privilege Escalation: Impersonating Active Terminal Services Console & Escalating._\n\nOnce the new process is spawned, the malware process calls ExitProcess to terminate itself.\n\n## Logging\n\nIf the configuration flag at index 2 is set, LockBit logs its process in a separately running window.\n\nThe malware spawns a thread to manually set up the UI for the window through a lot of Bitmap\nshenanigans, but I won’t cover how it does that because I’m too burned out as I’m writing this blog lol.\n\nThe log window setup function first calls GetModuleHandleW to retrieve the handle of the running\nexecutable. Next, the malware populates a WNDCLASSEXW structure using this handle as the instance\nof the logging window. The window procedure field of the structure is set to a function that will handle\nlogging communication between the main ransomware process and the window. Again, I won’t cover this\nsince I do indeed value my mental health!\n\n\n-----\n\n_Figure 25: Logging: Setting Up Logging Window Structure._\n\nAfter finishing populating the WNDCLASSEXW structure, the malware calls RegisterClassExW to\nregisters the window class and calls CreateWindowExW to create the logging window with\n**“LockBit_2_0_Ransom” as the class name and “LockBit 2.0 Ransom” as the window name.**\n\n_Figure 26: Logging: Creating Logging Window._\n\nAfter creating the window, LockBit calls ShowWindow with the SW_HIDE flag to hide it and\n**UpdateWindow to update this change.**\n\n\n-----\n\n_Figure 27: Logging: Auto Hiding Logging Window._\n\nTo be able to display this window manually, LockBit developers add a call to RegisterHotKey to register\nthe Shift + F1 combination with the hot key ID of 1, which will communicate with the window process to\ncall ShowWindow with the SW_SHOW flag to display itself. There is also another call to\n**RegisterHotKey to register the F1 key with the hot key ID of 2, which will hide the logging window if it’s**\ndisplayed.\n\n\n-----\n\n_Figure 28: Logging: Registering Hot Keys to Hide/Unhide Logging Window._\n\nEach time the main thread wants to display a logging message, it calls a function that internally calls\n**SendMessageA to send that message to the logging window.**\n\n_Figure 29: Logging: Main Thread Sending Logging Messages._\n\nBelow is the UI of the logging window.\n\n\n-----\n\n_Figure 30-31: Logging: General UI._\n\n## Command-line Arguments\n\n**LockBit can run with or without command-line arguments.**\n\nCommand-line arguments can come in the form of a path to a file or a folder to be processed. Execution\nis terminated once the target file/folder are encrypted.\n\n## Masquerade Explorer & UAC Bypass\n\nBefore performing UAC bypass, LockBit first checks if it has admin privilege. This is done by calling\n**NtOpenProcessToken to retrieve the handle for the ransomware process’s token and**\n**NtQueryInformationToken to retrieve the token’s elevation information and return if the token is**\nelevated.\n\n\n-----\n\n_Figure 32: Checking Admin Privilege._\n\nIf the process is elevated or the configuration flag at index 0 is set, UAC bypass is skipped.\n\nTo begin UAC bypass, the malware checks if the process is in the administrator group. It calls\n**NtOpenProcessToken to retrieve a handle to the current process and CreateWellKnownSid to create**\nan SID with type WinBuiltinAdministratorsSid.\n\n\n-----\n\n_Figure 33: Creating Admin SID._\n\nNext, LockBit calls CheckTokenMembership to check if the current process is a member of the admin\nSID group, then UAC bypass is skipped.\n\nIf the current process is not a member of the group, the malware calls NtQueryInformationToken to\nretrieve a handle to a token that is linked with the current process and calls CheckTokenMembership\nagain to check if the linked token is a member of the admin SID group.\n\n_Figure 34: Checking Token Membership For Admin Group._\n\nIf the token is in the admin group, the malware masquerades explorer.exe to bypass UAC.\n\nFirst, it calls NtAllocateVirtualMemory to allocate a virtual buffer and writes the Windows directory path\nappended by ”\\explorer.exe” in.\n\n_Figure 35, 36: Allocating & Populating Explorer Path._\n\n\n-----\n\nNext, LockBit calls RtlInitUnicodeString to convert the Explorer path to a unicode string and writes it in\nthe process’s image path name. It also makes another call to RtlInitUnicodeString to convert\n**“explorer.exe” to a unicode and writes it in the process’s command-line.**\n\n_Figure 37: Modifies Process’s Image Path & Command-line._\n\nThen, the malware calls RtlReleasePebLock to release the PEB lock and\n**LdrEnumerateLoadedModules to enumerate all loaded modules in memory and calls a function to find**\nand masquerade explorer.exe.\n\n_Figure 38: Enumerates To Find & Masquerade Explorer._\n\nFor each loaded module, the callback function checks if the module’s base address is the same as\n**LockBit base address to find the data table entry corresponding to the malware process in memory.**\n\nIf the context of the callback function is to masquerade Explorer, the function stores LockBit’s full name\nand base name into global variables to later restore them. Then, the full Explorer path is used as the new\nfull executable name for LockBit’s data table entry.\n\n_Figure 39: Module Enumerate Callback Function._\n\nFinally, the function calls RtlInitUnicodeString to write the full Explorer path to LockBit’s entry’s full DLL\nname and “explorer.exe” as the base DLL name, which now masquerades the LockBit process as an\nExplorer process.\n\n\n-----\n\n_Figure 40: Masquerading LockBit As Explorer._\n\nMasquerading as Explorer, LockBit starts performing UAC bypass.\n\nIt first resolves the address of CoInitializeEx and CoUninitialize by calling GetProcAddress. Then, the\nmalware calls CoInitializeEx to initializes the COM library for apartment-threaded object concurrency.\n\n_Figure 41: Initializing COM Library._\n\nThen, LockBit basically performs UAC bypass using ColorDataProxy/CCMLuaUtil COM interfaces.\n[The source code of this technique can be viewed here, so I won’t dive into it.](https://github.com/hfiref0x/UACME/blob/92e84a734c4719a9067f4e9c8cb0e263ae4e06af/Source/Akagi/methods/hybrids.c#L877)\n\n## Run-once Mutant\n\n**LockBit avoids having multiple ransomware instances running at once by checking for a specific mutant**\nobject.\n\nFirst, it decodes the following stack string “\\BaseNamedObjects\\{\\%02X%02X%02X%02X-%02X%02X**%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X}” and calls wsprintfW to write the**\nformatted data into a buffer. Each formatted field corresponds to a byte at a specific index of LockBit’s\nhard-coded public key.\n\n\n-----\n\n_Figure 42: Populating Mutant Name._\n\n**LockBit then calls RtlInitUnicodeString to convert the mutant name into a Unicode string and**\n**NtCreateMutant to try opening a mutant with the specified name. If the result is**\n**STATUS_OBJECT_NAME_COLLISION, the malware terminates by calling ExitProcess to avoid having**\nmultiple running instances.\n\n_Figure 43: Opening Mutant & Checking For Name Collision._\n\n## Setting Group Policy For Active Directory\n\n### Checking If Running On Primary Domain Controller\n\nIf the malware process has admin privilege, the OS version is Windows Vista and above, and any of the\nconfiguration flags at index 4, 5, 6 is set, LockBit tries to create and set new group policies for other\nhosts through Active Directory.\n\nFirst, LockBit checks if it’s currently executed on a primary domain controller. It calls\n**GetComputerNameW to retrieve the NetBIOS name of the local computer that it’s running on.**\n\n\n-----\n\n_Figure 44: Group Policy: Retrieving PC Name._\n\nThen, the malware calls NetGetDCName to retrieve the name of the primary domain controller and\n**lstrcmpiW to compare the local PC name with that DC name.**\n\n_Figure 45: Group Policy: Checking If PC Is The Primary Domain Controller._\n\n### Retrieving DNS Domain Name\n\nIf LockBit is running on the domain controller, it tries to retrieve the DNS domain name. First, the\nmalware calls NtOpenProcessToken to get the handle to the process’s token and\n**NtQueryInformationToken_1 to retrieve information about the user corresponding to that token.**\n\n\n-----\n\n_Figure 46: Group Policy: Retrieving User Information._\n\nNext, LockBit calls GetWindowsAccountDomainSid to retrieve the SID of the domain of the user’s\nSID. It then calls CreateWellKnownSid to create an SID for the user’s domain admin group and\n**CheckTokenMembership to check if the user has elevated privilege.**\n\n_Figure 47: Group Policy: Checking Admin Privilege._\n\nIf the user has admin privilege, LockBit calls GetComputerNameExW to retrieve the name of the DNS\ndomain of the local computer.\n\n\n-----\n\n_Figure 48: Group Policy: Retrieving DNS Domain Name._\n\n### Retrieving Domain Account Admin Name\n\nAfter doing the usual NtOpenProcessToken and NtQueryInformationToken routine to retrieve admin\nuser token information, LockBit calls LookupAccountSidW to look up the admin’s account name and\ndomain name.\n\n_Figure 49: Group Policy: Retrieving Admin User Account & Domain Names._\n\nTo get the full domain admin name, LockBit resolves the stack string ”//” and builds the name with the\nformat ”<domain name>//<account name>”\n\n### COM Retrieve IGroupPolicyObject Interface\n\nTo retrieve the IGroupPolicyObject Interface, LockBit resolves and calls CoCreateInstance with the\nCLSID {EA502722-A23D-11D1-A7D3-0000F87571E3} and IID {EA502723-A23D-11d1-A7D3**0000F87571E3}.**\n\n\n-----\n\n_Figure 50: Group Policy: Retrieve IGroupPolicyObject Interface._\n\n### Connect To Active Directory Domain\n\nTo connect to the AD domain, LockBit first generates the LDAP display name for the Group Policy\nObject (GPO) by resolving the stack string “%02X%02X%02X%02X%02X%02X%02X” and formats it\nwith values from its public key.\n\n_Figure 51: Group Policy: Building LDAP Display Name For GPO._\n\nNext, the malware manually extracts two domain components from the DNS domain name and formats\nthe string “LDAP://<Domain Controller name>.<DNS domain name>/DC=<Domain component\n**1>,DC=<Domain Component 2>”. This string is used as the AD domain name when LockBit calls the**\nmethod IGroupPolicyObject::New to create the GPO. Then, it calls IGroupPolicyObject::GetName to\nget the GUID corresponding to the created GPO.\n\n\n-----\n\n_Figure 52: Group Policy: Creating GPO._\n\nNext, LockBit builds the Active Directory path by formatting the string “LDAP://DC=<Domain\n**component 1>,DC=<Domain Component 2>”.**\n\n_Figure 53: Group Policy: Building Active Directory Path._\n\n**LockBit also builds the GPO path by formatting the string “LDAP://CN=<GPO**\n**GUID>,CN=Policies,CN=System,DC=<Domain component 1>,DC=<Domain Component 2>”**\n\nFinally, the Active Directory path and the GPO path are used to call CreateGPOLink to connect the GPO\nto the specified Active Directory domain.\n\n_Figure 54: Group Policy: Connecting GPO To Active Directory Domain._\n\n### Setting GPO’s attributes\n\nTo modify the GPO to inject LockBit’s custom policies, it first needs to update the object’s client-side\nextensions (CSEs). This requires setting the GPO’s attributes gPCMachineExtensionNames and\n**gPCUserExtensionNames.**\n\nFirst, given the GPO’s path, LockBit calls ADsGetObject to retrieve an object of the IADs interface\ncorresponding to the GPO using the IID {FD8256D0-FD15-11CE-ABC4-02608C9E7553}.\n\n\n-----\n\n_Figure 55: Group Policy: Retrieving IADs Object._\n\nNext, to set the GPO’s gPCMachineExtensionNames attribute, LockBit creates a VARIANT structure\ncontaining the following extension pairs for the desired GPO modification.\n```\n[{00000000-0000-0000-0000-000000000000}{BFCBBEB0-9DF4-4C0C-A728-434EA66A0373}{CC5746A9-9B74-4BE5AE2E-64379C86E0E4}]\n[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F72-3407-48AE-BA88-E8213C6761F1}]\n[{6A4C88C6-C502-4F74-8F60-2CB23EDC24E2}{BFCBBEB0-9DF4-4C0C-A728-434EA66A0373}]\n[{91FBB303-0CD5-4055-BF42-E512A681B325}{CC5746A9-9B74-4BE5-AE2E-64379C86E0E4}]\n\n```\n_Figure 56: Group Policy: Populating gPCMachineExtensionNames Variant._\n\nNext, it resolves the stack string “gPCMachineExtensionNames” and calls IADs::Put to set the value\nof the gPCMachineExtensionNames for the GPO to the value in the VARIANT structure.\n\n\n-----\n\n_Figure 57: Group Policy: Setting GPO’s gPCMachineExtensionNames Attribute._\n\nSimilarly, LockBit sets the GPO’s gPCUserExtensionNames attribute with the following extension pairs.\n```\n[{00000000-0000-0000-0000-000000000000}{3BAE7E51-E3F4-41D0-853D-9BB9FD47605F}{CAB54552-DEEA-4691817E-ED4A4D1AFC72}]\n[{7150F9BF-48AD-4DA4-A49C-29EF4A8369BA}{3BAE7E51-E3F4-41D0-853D-9BB9FD47605F}]\n[{AADCED64-746C-4633-A97C-D61349046527}{CAB54552-DEEA-4691-817E-ED4A4D1AFC72}]\n\n```\n_Figure 58: Group Policy: Setting GPO’s gPCUserExtensionNames Attribute._\n\nThe malware also sets the GPO’s versionNumber attribute to “2621892”.\n\n_Figure 59: Group Policy: Setting GPO’s versionNumber Attribute._\n\n### Updating GPT.INI\n\nNext, LockBit locates the root GPO GUID directory that contains a file called “GPT.ini. By updating the\n**Version property inside this file, LockBit can signal to gpupdate that there is a new modification to apply**\nthe new settings.\n\nFirst, using the IGroupPolicyObject object, the malware calls IGroupPolicyObject::GetFileSysPath to\nretrieve the root GPO GUID directory. It also calls IGroupPolicyObject::GetDisplayName to get the\nGPO’s display name.\n\n_Figure 60: Group Policy: Retrieving Root GPO Directory & Display Name._\n\nNext, LockBit resolves the stack string “GPT.INI” and appends it to the root directory by calling\n**PathAppendW. Using this GPT.INI path, the malware calls CreateFileW to get the handle to that file.**\n\n\n-----\n\n_Figure 61: Group Policy: Retrieving The Handle To GPT.INI._\n\nThen, the malware formats the following string and converts it into multibyte string by calling\n**WideCharToMultiByte.**\n```\n[General]\nVersion=2621892\ndisplayName=<GPO display name>\n\n```\n\n-----\n\n_Figure 62, 63: Group Policy: Generating New GPT.INI Content._\n\nFinally, LockBit calls WriteFile to write the updated content into the GPO’s GPT.INI file to signal\n**gpupdate.**\n\n_Figure 64: Group Policy: Writing New GPT.INI Content._\n\n### Updating the GPO Folder\n\nThe next part is for LockBit to drop group policy XML files into the GPO’s Machine Preferences folder\n(<GPO GUID>\\MACHINE\\Preferences) on the domain controller machine.\n\nThese files specify new group policies for the Domain Controller to push out to the network. Below is the\nlist of these files and their destinations:\n\n**<GPO GUID>\\MACHINE\\Preferences\\NetworkShares\\NetworkShares.xml**\n**<GPO GUID>\\MACHINE\\Preferences\\Services\\Services.xml**\n**<GPO GUID>\\MACHINE\\Preferences\\Files\\Files.xml**\n**<GPO GUID>\\MACHINE\\Preferences\\ScheduledTasks\\ScheduledTasks.xml:**\nC:\\Windows\\System32\\taskkill.exe</Command>/IM #proc_name for each process in\nWIDESTR_PROCESSES_EXE_LIST # /F\n**<GPO GUID>\\MACHINE\\Registry.pol**\n**<GPO GUID>\\MACHINE\\comment.cmtx**\n\nFirst, the NetworkShares.xml below is formatted to define a network share for each drive on the network\nhosts once the Domain Controller pushes it out. This will share all each host’s drives on the network for\n**LockBit to encrypt them.**\n\n\n-----\n\n```\n ?xml version 1.0 encoding UTF 8 ? \n<NetworkShareSettings clsid=\"{520870D8-A6E7-47e8-A8D8-E6A4E76EAEC2}\">\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_D\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_D\" path=\"D:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_E\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_E\" path=\"E:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_F\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_F\" path=\"F:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_G\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_G\" path=\"G:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_H\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_H\" path=\"H:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_I\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_I\" path=\"I:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_J\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_J\" path=\"J:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_K\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_K\" path=\"K:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_L\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_L\" path=\"L:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_M\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_M\" path=\"M:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_N\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_N\" path=\"N:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_O\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_O\" path=\"O:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n\n```\n\n-----\n\n```\n  NetShare clsid {2888C5E7 94FC 4739 90AA 2C1536D68BC0} image 2 name %%ComputerName%%_P \nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_P\" path=\"P:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_Q\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_Q\" path=\"Q:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_R\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_R\" path=\"R:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_S\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_S\" path=\"S:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_T\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_T\" path=\"T:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_U\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_U\" path=\"U:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_V\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_V\" path=\"V:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_W\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_W\" path=\"W:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_X\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_X\" path=\"X:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_Y\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_Y\" path=\"Y:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n  <NetShare clsid=\"{2888C5E7-94FC-4739-90AA-2C1536D68BC0}\" image=\"2\" name=\"%%ComputerName%%_Z\"\nchanged=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" name=\"%%ComputerName%%_Z\" path=\"Z:\" comment=\"\" allRegular=\"0\"\nallHidden=\"0\" allAdminDrive=\"0\" limitUsers=\"NO_CHANGE\" abe=\"NO_CHANGE\" />\n  </NetShare>\n</NetworkShareSettings>\n\n```\nNext, the Services.xml below is formatted to add policies to stop and disable certain services on the AD\nhosts. The list of stopped services are:\n\n\n-----\n\n```\n SQLPBDMS, SQLPBENGINE, MSSQLFDLauncher, SQLSERVERAGENT, MSSQLServerOLAPService, \n\"SSASTELEMETRY\", \"SQLBrowser\", \"SQL Server Distributed Replay Client\", \n\"SQL Server Distributed Replay Controller\", \"MsDtsServer150\", \"SSISTELEMETRY150\", \n\"SSISScaleOutMaster150\", \"SSISScaleOutWorker150\", \"MSSQLLaunchpad\", \"SQLWriter\", \"SQLTELEMETRY\",\n\"MSSQLSERVER\"\n\n```\n\n-----\n\n```\n ?xml version 1.0 encoding UTF 8 ? \n<NTServices clsid=\"{2CFB484A-4E96-4b5d-A0B6-093D2F91E6AE}\">\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"SQLPBDMS\" image=\"4\"\nchanged=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"SQLPBDMS\" serviceAction=\"STOP\" timeout=\"30\"\n/>\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"SQLPBENGINE\" image=\"4\"\nchanged=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"SQLPBENGINE\" serviceAction=\"STOP\"\ntimeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"MSSQLFDLauncher\" image=\"4\"\nchanged=\"%s\" uid=\"%s\" userContext=\"0\" removePolicy=\"0\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"MSSQLFDLauncher\" serviceAction=\"STOP\"\ntimeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"SQLSERVERAGENT\" image=\"4\"\nchanged=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"SQLSERVERAGENT\" serviceAction=\"STOP\"\ntimeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"MSSQLServerOLAPService\"\nimage=\"4\" changed=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"MSSQLServerOLAPService\"\nserviceAction=\"STOP\" timeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"SSASTELEMETRY\" image=\"4\"\nchanged=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"SSASTELEMETRY\" serviceAction=\"STOP\"\ntimeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"SQLBrowser\" image=\"4\"\nchanged=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"SQLBrowser\" serviceAction=\"STOP\"\ntimeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"SQL Server Distributed Replay\nClient\" image=\"4\" changed=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"SQL Server Distributed Replay Client\"\nserviceAction=\"STOP\" timeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"SQL Server Distributed Replay\nController\" image=\"4\" changed=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"SQL Server Distributed Replay Controller\"\nserviceAction=\"STOP\" timeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"MsDtsServer150\" image=\"4\"\nchanged=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"MsDtsServer150\" serviceAction=\"STOP\"\ntimeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"SSISTELEMETRY150\" image=\"4\"\nchanged=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"SSISTELEMETRY150\" serviceAction=\"STOP\"\ntimeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"SSISScaleOutMaster150\"\nimage=\"4\" changed=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"SSISScaleOutMaster150\" serviceAction=\"STOP\"\ntimeout=\"30\" />\n  </NTService>\n\n```\n\n-----\n\n```\n  NTService clsid {AB6F0B67 341F 4e51 92F9 005FBFBA1A43} name SSISScaleOutWorker150 \nimage=\"4\" changed=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"SSISScaleOutWorker150\" serviceAction=\"STOP\"\ntimeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"MSSQLLaunchpad\" image=\"4\"\nchanged=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"MSSQLLaunchpad\" serviceAction=\"STOP\"\ntimeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"SQLWriter\" image=\"4\"\nchanged=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"SQLWriter\" serviceAction=\"STOP\"\ntimeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"SQLTELEMETRY\" image=\"4\"\nchanged=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"SQLTELEMETRY\" serviceAction=\"STOP\"\ntimeout=\"30\" />\n  </NTService>\n  <NTService clsid=\"{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}\" name=\"MSSQLSERVER\" image=\"4\"\nchanged=\"%s\" uid=\"%s\" disabled=\"0\">\n   <Properties startupType=\"DISABLED\" serviceName=\"MSSQLSERVER\" serviceAction=\"STOP\"\ntimeout=\"60\" />\n  </NTService>\n</NTServices>\n\n```\nBefore dropping the Files.xml file, LockBit self-propagates to the Domain Controller’s SYSVOL folder.\n\nFirst, the malware calls GetModuleFileNameW to get its own executable path and builds the following\nnew path.\n```\n%SystemRoot%\\SYSVOL_DFSR\\sysvol\\<Domain DNS name>\\siripts\n\n```\nThen, it calls CopyFileW to copy its executable to this siripts file. Since SYSVOL is a directory for all\npublic Active Directory files, the malicious executable is now accessible to all hosts on the network\ndomain.\n\n_Figure 65 66: Group Policy: Propagating Self To SYSVOL._\n\nFinally, LockBit formats and drops the Files.xml file below. The fromPath field’s value is formatted to\nthe executable path in the SYSVOL folder, and the targetPath field’s value is set to\n**%%DesktopDir%%\\%02X%02X%02X.exe, which is formatted using LockBit’s public key. Ultimately,**\nthis file’s policy is dropping the malicious executable from the Domain Controller’s SYSVOL directory to\nevery network host’s Desktop directory.\n\n\n-----\n\n_Figure 67: Group Policy: Generating Desktop Drop Path._\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Files clsid=\"{215B2E53-57CE-475c-80FE-9EEC14635851}\">\n  <File clsid=\"{50BE44C8-567A-4ed1-B1D0-9234FE1F38AF}\" name=\"%s\" status=\"%s\" image=\"2\"\nbypassErrors=\"1\" changed=\"%s\" uid=\"%s\">\n   <Properties action=\"U\" fromPath=\"%s\" targetPath=\"%s\" readOnly=\"0\" archive=\"1\" hidden=\"0\"\nsuppress=\"0\" />\n  </File>\n</Files>\n\n```\nThe raw ScheduledTasks.xml content is documented below. This file contains the policy to terminate\nthe specified processes in the configuration’s process list.\n\n\n-----\n\n```\n ?xml version 1.0 encoding UTF 8 ? \n<ScheduledTasks clsid=\"{CC63F200-7309-4ba0-B154-A71CD118DBCC}\">\n  <TaskV2 clsid=\"{D8896631-B747-47a7-84A6-C155337F3BC8}\" name=\"%s\" image=\"2\" changed=\"%s\"\nuid=\"%s\">\n   <Properties action=\"U\" name=\"%s\" runAs=\"%s\" logonType=\"InteractiveToken\">\n     <Task version=\"1.2\">\n      <RegistrationInfo>\n        <Author>%s</Author>\n        <Description />\n      </RegistrationInfo>\n      <Principals>\n        <Principal id=\"Author\">\n         <UserId>%s</UserId>\n         <LogonType>InteractiveToken</LogonType>\n         <RunLevel>HighestAvailable</RunLevel>\n        </Principal>\n      </Principals>\n      <Settings>\n        <IdleSettings>\n         <Duration>PT10M</Duration>\n         <WaitTimeout>PT1H</WaitTimeout>\n         <StopOnIdleEnd>false</StopOnIdleEnd>\n         <RestartOnIdle>false</RestartOnIdle>\n        </IdleSettings>\n        <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>\n        <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>\n        <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>\n        <AllowHardTerminate>true</AllowHardTerminate>\n        <AllowStartOnDemand>true</AllowStartOnDemand>\n        <Enabled>true</Enabled>\n        <Hidden>false</Hidden>\n        <ExecutionTimeLimit>P3D</ExecutionTimeLimit>\n        <Priority>7</Priority>\n      </Settings>\n      <Triggers>\n        <RegistrationTrigger>\n         <Enabled>true</Enabled>\n         %s\n        </RegistrationTrigger>\n      </Triggers>\n      <Actions Context=\"Author\">%s</Actions>\n     </Task>\n   </Properties>\n  </TaskV2>\n</ScheduledTasks>\n\n```\n**LockBit formats this to execute a taskkill.exe for each of the process in the configuration’s process list.**\nThis is done through crafting these tags and include them in the main ScheduledTasks.xml file where\nthe “Process_Name” field is the name of the process to be terminated.\n```\n<Exec><Command>C:\\Windows\\System32\\taskkill.exe</Command><Arguments>/IM \"Process_Name\"\n/F</Arguments></Exec>\n\n```\nFinally, LockBit drops the [Registry.pol file and the comment.cmtx file below.](https://github.com/cdong1012/IDAPython-Malware-Scripts/blob/master/Lockbit/lockbit_dropped_files/Registry.pol)\n\n\n-----\n\n```\n ?xml version 1.0 encoding UTF 8 ? \n<policyComments xmlns=\"http://www.microsoft.com/GroupPolicy/CommentDefinitions\"\nxmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchemainstance\" revision=\"1.0\" schemaVersion=\"1.0\">\n  <policyNamespaces>\n   <using prefix=\"ns0\" namespace=\"Microsoft.Policies.WindowsDefender\" />\n  </policyNamespaces>\n  <comments>\n   <admTemplate />\n  </comments>\n  <resources minRequiredRevision=\"1.0\">\n   <stringTable />\n  </resources>\n</policyComments>\n\n```\nThe Registry.pol contains the following list of registry paths and the values to configure them.\n\n**Software\\Policies\\Microsoft\\Windows Defender\\DisableAntiSpyware: True**\n**Software\\Policies\\Microsoft\\Windows Defender\\Real-Time**\n**Protection\\DisableRealtimeMonitoring: True**\n**Software\\Policies\\Microsoft\\Windows Defender\\Spynet\\SubmitSamplesConsent: Never send**\n**Software\\Policies\\Microsoft\\Windows**\n**Defender\\Threats\\Threats_ThreatSeverityDefaultAction: Enabled**\n**Software\\Policies\\Microsoft\\Windows Defender\\Threats\\ThreatSeverityDefaultAction\\Low:**\nIgnored\n**Software\\Policies\\Microsoft\\Windows**\n**Defender\\Threats\\ThreatSeverityDefaultAction\\Medium: Ignored**\n**Software\\Policies\\Microsoft\\Windows Defender\\Threats\\ThreatSeverityDefaultAction\\High:**\nIgnored\n**Software\\Policies\\Microsoft\\Windows Defender\\Threats\\ThreatSeverityDefaultAction\\Severe:**\nIgnored\n**Software\\Policies\\Microsoft\\Windows Defender\\UX Configuration\\Notification_Suppress:**\nEnabled\n\nThese following registry configurations disable Windows Defender features such as anti-spyware, realtime protection, submitting samples to Microsoft servers, default actions, and displaying notification on all\nnetwork hosts.\n\n### Forcing GPUpdate On All Hosts Through PowerShell\n\nAfter adding these new policies, LockBit calls Sleep to wait for 1 minute for the changes to be applied\nbefore creating a process to invoke gpupdate.exe to run on these network hosts.\n\nFirst, using an IADs object from the Domain Controller’s rootDSE, the malware calls IADs::Get to\nretrieve the default naming context to retrieve the name of the Active Directory domain.\n\n\n-----\n\n_Figure 68: Group Policy: Retrieving AD Domain Name._\n\nNext, LockBit formats the following command where the search base is set to the Active Directory\ndomain name. This Powershell command search through all computers on the Active Directory domain,\nand for each found, it force-invokes GPUpdate on that host to apply the new Group Policy changes. The\nmalware launches this command by calling CreateProcessW.\n```\npowershell.exe -Command \"Get-ADComputer -filter * -Searchbase '%s' | foreach{ Invoke-GPUpdate computer $_.name -force -RandomDelayInMinutes 0}\n\n```\n_Figure 69: Group Policy: Launching Powershell Command To Force GPUpdate._\n\n### Forcing GPUpdate On All Hosts Manually\n\n\n-----\n\nIf the above fails, LockBit attempts to force running GPUpdate manually.\n\nAfter retrieving the name of the Active Directory domain, the malware appends it to “LDAP://” to build\nthe full domain path and calls ADsOpenObject to retrieve an IDirectorySearch object to perform\nqueries on AD hosts.\n\n_Figure 70: Group Policy: Getting IDirectorySearch Object._\n\nNext, LockBit calls IDirectorySearch::SetSearchPreference to set the search preference to\n**ADS_SEARCHPREF_SEARCH_SCOPE and IDirectorySearch::ExecuteSearch to search for the**\nname of each computer in the AD domain.\n\n_Figure 71, 72: Group Policy: Executing AD Search For PC Names._\n\nNext, LockBit calls GetFirstRow and GetNextRow to iterate through each row of the search result. For\neach row, it calls GetNextColumnName and GetColumn to get the data from each column of that row.\nThe malware accesses the DNString field in each named column to retrieve a Distinguished Name (DN)\nof a network host in the domain. Given the host name, LockBit calls CreateThread to launch a thread to\nmanually execute GPUpdate and force the host to restart.\n\n\n-----\n\n_Figure 73, 74: Group Policy: Enumerating AD Hosts’ Distinguished Name._\n\nThe thread function only executes if the malware is currently running on a Domain Controller.\n\nFirst, LockBit calls CoCreateInstance to retrieve an ITaskService object and calls\n**ITaskService::Connect to establish a connection to the network host using its DN.**\n\n_Figure 75, 76: Group Policy: Connecting To AD Hosts._\n\n\n-----\n\nNext, it calls ITaskService::GetFolder to retrieve an ITaskFolder objet corresponding to a folder of\nregistered tasks and calls ITaskFolder::DeleteTask to delete any existing task for this specific host.\n\n**LockBit then calls ITaskService::NewTask to create a new task for the network host.**\n\n_Figure 77: Group Policy: Creating New Task._\n\nAfter retrieving the IPrincipal object, the malware calls IPrincipal::put_LogonType to set the task to be\nstarted in the user’s interactive logon session. It also calls IPrincipal::put_RunLevel to set the task to\nrun with the least privileges.\n\n_Figure 78: Group Policy: Setting Task Properties._\n\nAfter retrieving the ITaskDefinition object, LockBit calls ITaskDefinition::get_Triggers to retrieve an\n**ITriggerCollection object. It then calls ITriggerCollection::Create to create a new trigger for the task**\nwhich is triggered when the task is registered.\n\n_Figure 79: Group Policy: Creating Trigger For Task._\n\nUsing the ITaskDefinition object, the malware also calls ITaskDefinition::get_Actions to retrieve an\n**IActionCollection object. It then calls IActionCollection::Create to create a new action for the task**\nspecifying that it is an executable action.\n\n_Figure 80: Group Policy: Creating Executable Action For Task._\n\nNext, using the action object IExecAction, LockBit calls IExecAction::put_Path to set the path of the\nexecutable action to “gpupdate exe”\n\n\n-----\n\n_Figure 81: Group Policy: Setting Action Path To gpupdate.exe._\n\nNext, it calls IExecAction::put_Arguments to put “/force” the executable’s argument,\n**ITaskFolder::RegisterTaskDefinition to register the task’s definition, and IRegisteredTask::Run to run**\nthe task immediately.\n\n_Figure 82: Group Policy: Registering & Force-Running GPUpdate Task._\n\nThis will run GPUpdate on the network host immediately and whenever someone is logging into the host,\nwhich will then apply the Group Policy changes from the Domain Controller.\n\nFinally, LockBit forces the network host to restart itself.\n\nIt does this by calling CoCreateInstance to retrieve an IWbemLocator object. Using the object, it calls\n**IWbemLocator::ConnectServer to connect to ”\\\\<AD Host Name>\\ROOT\\CIMV2”.**\n\n\n-----\n\n_Figure 83: Group Policy: Connecting To Host’s ROOT\\CIMV2 Namespace._\n\nNext, the malware calls IWbemServices::GetObjectA to retrieve an IWbemClassObject object\ncorresponding to all Win32 processes on the network host. Using this object, it calls\n**IWbemClassObject::GetMethod to retrieve an IWbemClassObject object corresponding to a method**\nto create processes. Then, it calls IWbemClassObject::SpawnInstance to create a new instance of the\nprocess creation method.\n\n_Figure 84: Group Policy: Process Creation Method._\n\nFinally, it resolves the stack string “cmd.exe /c “shutdown.exe /r /f /t 0”“, calls\n**IWbemClassObject::Put with the property name “CommandLine”, and IWbemServices::ExecMethod**\nto execute the process creation method to spawn a command-line process to execute the command\nabove.\n\nThis command forces running applications to close without warning users and restarts the computer after\nshutting down immediately.\n\n\n-----\n\n_Figure 85: Group Policy: Executing Command To Restart._\n\n## Persistence Registry\n\nPrior to executing encryption routines, LockBit sets up persistence through the registry in case the\nmalware gets interrupted by the system shutting down midway through.\n\nFirst, the malware resolves the stack string “SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run”\nand calls RegCreateKeyExA to get the handle to this registry key.\n\n_Figure 86: Retrieving Persistence Registry Key Handle._\n\nFirst, the malware resolves the stack string ”{\\%02X%02X%02X%02X-%02X%02X-%02X%02X**%02X%02X-%02X%02X%02X%02X%02X%02X}” and formats it using its public key. This formatted**\nstring will be used as the value name to set up the persistence registry key.\n\n\n-----\n\n_Figure 87: Generating Persistence Registry Key Value Name._\n\nNext, the malware calls RegQueryValueExW to retrieve the data at the registry key above. If this is\nsuccessful, LockBit tests to see if the data is correct by calling lstrcmpiW to compare it with the\nmalware executable path. If retrieving the data fails because the registry value has not been set or the\ndata inside is incorrect, the malware calls RegSetValueExW to set the data to its own path to establish\npersistence.\n\n_Figure 88: Establishing Persistence Through Registry._\n\nOnce the encryption is finished, the malware removes this persistence key by calling RegDeleteValueW\nto prevent itself from running again if the user decides to restart their encrypted machine.\n\n_Figure 89: Removing Persistence Registry Key Post-Encryption._\n\n## Set LockBit Default Icon\n\n\n-----\n\nBecause all files encrypted by LockBit have the extension .lockbit, the malware attempts to change the\nregistry to set up the default icon for this extension using an embedded icon file in memory. This is only\nexecuted when the malware has admin privilege and the configuration flag at index 7 is set.\n\n_Figure 90: LockBit Default Icon For .lockbit Extension._\n\nFirst, LockBit resolves the stack string ”\\??\\C:\\windows\\system32\\%02X%02X%02X.ico” and formats\nit using its public key.\n\n\n-----\n\n_Figure 91: Generating Icon File Path._\n\nNext, using this file path, the malware calls NtCreateFile to retrieve a handle to this file in the System32\nfolder. It also calls NtWriteFile to write the embedded icon file content into this file.\n\n_Figure 92: Writing Icon File._\n\n**LockBit then resolves the stack string “\\Registry\\Machine\\Software\\Classes\\.lockbit” and calls**\n**NtCreateKey to create this registry key corresponding to the “.lockbit” extension.**\n\n_Figure 93: Creating .lockbit Extension Registry Key._\n\nIf the registry key above is created sucessfully, LockBit resolves the stack string\n**“\\Registry\\Machine\\Software\\Classes\\.lockbit\\DefaultIcon” string, calls NtCreateKey to create this**\nregistry key, and calls NtSetValueKey to set the data of the DefaultIcon value to the icon file path in\nSystem32.\n\n\n-----\n\n_Figure 94: Creating & Setting .lockbit Extension DefaultIcon Registry Key._\n\nFinally, LockBit resolves and calls SHChangeNotify with the event ID SHCNE_ASSOCCHANGED to\nnotify the system that a file type association has changed, which updates all files with extension .lockbit\nto have this particular icon.\n\n_Figure 95: Notifying & Applying Icon Change._\n\n## Pre-Encryption System Clean-Up\n\nBefore launching a thread to perform pre-encryption system clean-up, LockBit attempts to gain\n**SeDebugPrivilege privilege. This privilege allows the malware to debug and freely access other**\nprocesses in the system.\n\n\n-----\n\nFirst, it calls NtOpenProcessToken to retrieve its own process token, LookupPrivilegeValueA to\nretrieve the locally unique identifier (LUID) of the SeDebugPrivilege privilege, and\n**NtAdjustPrivilegesToken to give itself that privilege.**\n\n_Figure 96: Setting SeDebugPrivilege Privilege._\n\n### Stopping Services\n\nPrior to stopping all services in the configuration’s service list, LockBit resolves and calls\n**Wow64DisableWow64FsRedirection to disables file system redirection. Then, it calls**\n**OpenSCManagerA to retrieve a service control manager handle. With the handle, LockBit iterates**\nthrough the configuration’s service list and calls OpenServiceA to retrieve a handle to each service.\n\n_Figure 97: Retrieving Each Target Service Handle._\n\nNext, LockBit calls QueryServiceStatusEx to query the service’s process’s status. If the state of the\nservice is SERVICE STOPPED it moves on to the next service in the list\n\n\n-----\n\n_Figure 98: Checking If Service Is Already Stopped._\n\nIf the service’s status is SERVICE_STOP_PENDING, LockBit calculates the time sleep based on the\nwait hint and wait until the pending status is over. After the Sleep call, the malware calls\n**QueryServiceStatus to check if the service is stopped.**\n\n_Figure 99: Processing Service’s Stop Pending Status._\n\n**LockBit does not wait forever if the SERVICE_STOP_PENDING status persists. It calls GetTickCount**\nat the beginning and when every time it checks for the SERVICE_STOPPED signal onward. If the time\ndifference (timeout) is greater than 30 seconds, the malware moves on to the next service.\n\n\n-----\n\n_Figure 100: Max Timeout For Service Processing._\n\nIf the service’s status is not SERVICE_STOP_PENDING or SERVICE_STOPPED, LockBit attempts to\nstop it.\n\nFirst, the malware tries to stop all dependent services of the target service. It does this by calling\n**EnumDependentServicesA on the service handle to retrieve an ENUM_SERVICE_STATUSA array for**\nall of the dependent services.\n\n_Figure 101: Begins Dependent Services Enumeration._\n\n\n-----\n\nFor each dependent service, LockBit calls OpenServiceA with its name to retrieve its handle from the\nservice control manager. Then, it calls ControlService to send a SERVICE_CONTROL_STOP signal to\nstop the dependent service. After sending the signal, LockBit goes through the same status checking\nprocedure above to ensure each dependent service is fully stopped before moving on.\n\n_Figure 102, 103: Stopping Dependent Services._\n\nFinally, LockBit calls ControlService to send a SERVICE_CONTROL_STOP signal to stop the main\nservice.\n\n_Figure 104: Stopping Main Service._\n\n### Terminating Processes\n\nTo terminate all processes in the configuration’s process list, LockBit calls CreateToolhelp32Snapshot\nto get a snapshot handle to all system’s processes.\n\n_Figure 105: Retrieving Process Snapshot Handle._\n\nNext, the malware calls Process32First and Process32Next with the snapshot handle to enumerate\nthrough all processes in the system. For each process, it calls PathRemoveExtensionA to remove the\nprocess’s file extension and lstrcmpiA to compare the process’s name to each in the configuration’s\nprocess list. If the process’s name is in the list, LockBit calls a function to terminate it.\n\n\n-----\n\n_Figure 106: Retrieving Process Snapshot Handle._\n\nTo terminate a process, LockBit calls CreateToolhelp32Snapshot to get a snapshot handle and\n**Process32First/Process32Next to enumerate all processes. For each found process, the malware**\ncompares the process ID with the target’s ID to find the target process. LockBit then calls OpenProcess\nwith the target process ID to retrieve a handle to the process and calls NtTerminateProcess to terminate\nit.\n\n_Figure 107, 108: Terminating Each Target Process._\n\n### Deleting Backups\n\nTo delete shadow copies, LockBit first resolves the following string.\n```\n/c vssadmin delete shadows /all /quiet & wmic shadowcopy delete & bcdedit /set {default}\nbootstatuspolicy ignoreallfailures & bcdedit /set {default} recoveryenabled no\n\n```\nThen, it passes the appropriate fields to ShellExecuteA to launch that command with cmd.exe. This\ncommand uses vssadmin and wmic to delete all shadow copies and bcdedit to disable file recovery.\n\n\n-----\n\n_Figure 109: Launching Cmd.exe Command To Delete Backups Through ShellExecuteA._\n\nNext, LockBit resolves the following stack strings in an array of strings.\n```\n- /c vssadmin Delete Shadows /All /Quiet\n- /c bcdedit /set {default} recoveryenabled No\n- /c bcdedit /set {default} bootstatuspolicy ignoreallfailures\n- /c wmic SHADOWCOPY /nointeractive\n- /c wevtutil cl security\n- /c wevtutil cl system\n- /c wevtutil cl application\n\n```\nFinally, it iterates through this array and calls CreateProcessA to launch these commands from\n**cmd.exe. Besude the commands already ran before, the wevtutil commands clear all events from the**\nsecurity, system, and application logs.\n\n_Figure 110: Launching Cmd.exe Command To Delete Backups Through CreateProcessA._\n\n## Printing Ransom Note To Printers\n\nIf the configuration flag at index 8 is set, the malware attempts to print the ransom note on the printers\nthat the machine is connected to.\n\n\n-----\n\nTo print the ransom note to physical printers, LockBit first calls EnumPrintersW to retrieve an\nenumerator for printer’s information. Using the enumerator to enumerate printer names, the malware\ncalls a function to print the ransom note to each printer.\n\n_Figure 111: Enumerating & Printing Ransom Note On All Printers._\n\nThe internal function resolves the two strings “Microsoft Print to PDF” and “Microsoft XPS Document\n**Writer”, calls lstrcmpiW to compare them with the printer’s name. If the printer’s name is one of those**\ntwo, the function exits, and the ransom note is not printed. This is to avoid printing the ransom note to a\nfile on the system and only print the note to physical printers that the machine is connected to.\n\n_Figure 111: Avoiding Print-to-file Drivers._\n\nNext, LockBit populates a DOC_INFO_1 with the printer’s name and the printing data type as “RAW”.\nThen, it calls StartDocPrinter to notify the print spooler that a document is to be spooled for printing and\n**StartPagePrinter to notify the spooler that a page is about to be printed.**\n\n\n-----\n\n_Figure 113, 114, 115: Notifying Print Spooler About The Print Job._\n\nFinally, LockBit calls WritePrinter to print the ransom note physically on the printer.\n\n_Figure 116: Printing Ransom Note On Printer._\n\n## Setup Wallpaper\n\nTo setup the wallpaper on the victim’s machine, the malware first does some bitmap shenanigan to\ngenerate the wallpaper image with texts to notify the victim that their files have been encrypted. Because\nthe function to generate this bitmap manually is almost as annoying as the function to set up the logging\nwindow UI, I will simply say that this is some voodoo witchcraft stuff and pretend like the wallpaper is\nmagically generated in this analysis!\n\nAfter creating the wallpaper image, LockBit calls GetTempPathW and GetTempFileNameW to retrieve\na path to a temporary file in the %TEMP% folder.\n\n\n-----\n\n_Figure 117: Generating A Temp Path For Storing The Wallpaper._\n\nWith the wallpaper bitmap object, the malware calls GdipSaveImageToFile to save the bitmap image to\nthe temporary file using a Bitmap decoder.\n\nNext, LockBit resolves the string “Control Panel\\Desktop” and calls RegOpenKeyA to retrieve a\nregistry key handle of that name. With the registry key handle, it calls RegSetValueExA to set the\nwallpaper style to “2” and the TileWallpaper property to “0”.\n\n_Figure 118, 119, 120: Setting Registry For Wallpaper Properties._\n\n\n-----\n\nFinally, the malware calls SystemParametersInfoW to set the desktop wallpaper to the wallpaper stored\nthat the temporary path appended by “.bmp”.\n\n_Figure 121: Setting Desktop Wallpaper._\n\nBelow is the generated Bitmap wallpaper.\n\n_Figure 122: Setting Desktop Wallpaper._\n\n## Dropping Ransom HTML Application File\n\nBeside dropping ransom notes and changing the desktop’s wallpaper, LockBit also drops an HTML\nApplication (HTA) file on the system and sets up the registry keys to open the file whenever an encrypted\nfile with the .lockbit extension is ran.\n\nFirst, the malware generate the full path to drop the file to by calling SHGetFolderPathW to retrieve the\nfolder’s current path and appends “\\LockBit_Ransomware.hta” to the end.\n\n\n-----\n\n_Figure 123: Retrieving Full HTA Path._\n\nThe entire content of the HTA file is resolved as a stack string, so IDA and the decompiler have trouble\ndisplaying this function. This kinda suck because I have to patch it over in order to be able to analyze the\nrest of the function.\n\n_Figure 124: HTA File Encoded Content Being Pushed To The Stack._\n\nAfter resolving the file’s content, LockBit calls CreateFileW to create the HTA file at the path and calls\n**WriteFile to write to it.**\n\n\n-----\n\n_Figure 125: Dropping HTA File._\n\nNext, the malware sets up registry keys to open the HTA file whenever an encrypted file with the .lockbit\nextension is ran.\n\nFirst, LockBit resolves the following strings and calls NtCreateKey to create the registry keys\ncorresponding to them.\n```\n\\Registry\\Machine\\Software\\Classes\\Lockbit\n\\Registry\\Machine\\Software\\Classes\\Lockbit\\DefaultIcon\n\\Registry\\Machine\\Software\\Classes\\Lockbit\\shell\n\\Registry\\Machine\\Software\\Classes\\Lockbit\\shell\\Open\n\\Registry\\Machine\\Software\\Classes\\Lockbit\\shell\\Open\\Command\n\n```\nFor the DefaultIcon registry key, the malware resolves the path to the icon file similarly to the Set LockBit\nDefault Icon section and sets it to the value of the registry key.\n\nNext, it resolves the string “C:\\Windows\\system32\\mshta.exe” “%s”“ which contains the command to\nexecute mshta.exe, a Windows executable used to execute HTA files, and formats it with the dropped\nHTA file path. The malware then calls NtSetValueKey to set this string to the data of the\n**\\Registry\\Machine\\Software\\Classes\\Lockbit\\shell\\Open\\Command registry key. With this, whenever**\na file with the .lockbit extension is ran, the mshta.exe will automatically open the dropped HTA file.\n\n\n-----\n\n_Figure 126: Setting Registry Keys To Launch HTA File._\n\nBelow is the dropped HTA file.\n\n_Figure 127: HTA File Content._\n\n**LockBit also sets the persistence for the file to be ran every time the system boots up. The malware**\ndoes this by resolving the registry path “SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run” and\nsets its key “{2C5F9FCC-F266-43F6-BFD7-838DAE269E11}” to the HTA file path.\n\n## File Encryption\n\n### Mounting Volumes on Drives\n\nPrior to file encryption, LockBit calls FindFirstVolumeW and FindNextVolumeW to enumerate through\nvolumes on the victim’s machine.\n\n\n-----\n\n_Figure 128: Volumes Enumeration._\n\nFor each found volume name, the malware calls GetVolumePathNamesForVolumeNameW to retrieves\na list of drive letters and mounted folder paths for the specified volume. It also calls GetDriveTypeW to\ncheck the volume’s type. LockBit avoids mounting the volume if its type is not DRIVE_REMOVABLE\nand DRIVE_FIXED or if it has more than 4 mounted folder paths.\n\n_Figure 129, 130: Checking Volume To Mount._\n\nNext, LockBit resolves and formats the string “%s\\bootmgr” with the volume name to retrieve the\nbootmgr path for the specified volume. It calls CreateFileW with the OPEN_EXISTING flag to check if the\nvolume has a bootmgr file and skips it if it does not.\n\n\n-----\n\n_Figure 131: Checking Volume’s Bootmgr File._\n\nThe malware then iterates through each drive path using the format string “%C:\" and formats it with a\ndrive letter from Z down to A every time. For each drive path, the malware tries calling\n**SetVolumeMountPointW to mount the volume to a specific drive letter and stops once it successfully**\nmounts the volume on one.\n\n_Figure 132: Mounting Volumes To A Specific Drive._\n\n### Cryptography & Multithreading Initialization\n\nBecause LockBit uses Libsodium for public-key cryptography, we don’t really need to analyze most of\nthe crypto initialization because it’s just a mess. It’s a lot quicker to just recognize specific Libsodium’s\nfunctions once we encounter them.\n\n\n-----\n\n_Figure 133: Libsodium Cryptography Initialization._\n\nFor the function to generate random data, LockBit tries to load bcrypt.dll in memory with\n**LoadLibraryA, and if that suceeds, it will use BCryptGenRandom for the RNG function. If not, the**\nmalware just uses CryptGenRandom for it.\n\n\n-----\n\n_Figure 134: Determining RNG Function._\n\nNext, LockBit resolves and formats the string “SOFTWARE\\%02X%02X%02X%02X%02X%02X%02X”\nwith its public key. This is then uses as the registry key name to later store the victim’s cryptographic\nkeys.\n\n\n-----\n\n_Figure 135, 136: Resolving LockBit Cryptographic Registry Key._\n\nIf the RegCreateKeyExW fails, LockBit skips setting the crypto registry key on the victim machine.\n\nFirst, the malware calls Libsodium’s crypto_box_keypair to randomly generate a 32-byte private key\nand the corresponding 32-byte public key for the victim. Next, it encrypts the 64-byte buffer containing the\nvictim’s public and private key using Libsodium’s crypto_box_easy function and wipes the victim’s\nprivate key from memory.\n\n_Figure 137: Generating & Encrypting Victim’s Public & Private Key._\n\nThe encryption routine is shown below. For each encryption, a public-private key pair is generated using\nthe same algorithm as above, and for the sake of simplicity, we’ll call this the encrypted box’s publicprivate key pair. The malware then generates the nonce for the crypto_box_easy function by hashing\nthe box public key appended by the first 8 bytes of the given public key, and it calls the\n**crypto_box_easy function to encrypt the given data using the box private key and the given public key.**\n\n\n-----\n\n_Figure 138: Calling Libsodium’s crypto_box_easy Authenticated Encryption Function._\n\nThe encrypted result is returned in the following format:\n```\nstruct encrypted_box {\n  byte box_public_key[0x20];\n  byte box_encrypted_data[input_size + 0x10];\n}\n\n```\nIn this case, the box’s encrypted data stores the encrypted victim’s public-private key pair, and we will call\nthis the session box. For this, LockBit’s decryptor can call Libsodium’s crypto_box_open_easy\nfunction using their private key and the box public key to decrypt its encrypted data. Of course, the nonce\ngeneration during decryption is simple too because LockBit has access to both its own public key and\nthe box public key.\n\nIf the registry key above is created/opened successfully, LockBit does not generate and encrypt these\nkeys. Instead, it calls RegQueryValueExA to query them into memory. The session box is stored in the\n**“Private” key’s data and the victim’s public key is stored in the “Public” key’s data if they exist.**\n\n\n-----\n\n_Figure 139: Retrieving Session Box & Victim’s Public Key From Registry._\n\nIf querying the registry fails, the malware generates the victim’s public-private key pair, encrypts them,\nand calls RegSetValueExA to set the appropriate registry keys.\n\n\n-----\n\n_Figure 140: Generating Cryptographic Keys & Setting Registry._\n\nAfter setting up the cryptographic keys, LockBit initializes its multithreading setup for encryption. It calls\n**NtCreateIoCompletion to create an I/O completion port and CreateThread to spawn child threads for**\nencryption. The number of child threads is equal to the number of processors on the system that it\nretrieves from the PEB.\n\nFor each child thread, the malware calculates its affinity mask using its index in the thread array. With the\nmask, LockBit calls NtSetInformationThread to set the processor affinity mask for the specific child\nthread. This registers a binding the child thread to one specific CPU, so that the thread will only execute\non that designated processor. This provides cache affinity to the child thread to have warm cache which\ntremendously reduces cache misses and increases performance when the child thread is scheduled to\nrun.\n\n\n-----\n\n_Figure 141: Multithreading Setup._\n\nThe functionality of the child thread function is discussed in the later Child Thread section.\n\n### Traversing Local Drive\n\nTo traverse through all local drives, LockBit calls GetLogicalDrives to retrieves a bitmask representing\nthe currently available disk drives. Using the bitmask, the malware checks each bit to skip processing\ndrives that are not available.\n\n_Figure 142: Searching For Available Disk Drives._\n\nFor each available drive, the malware calls GetDriveTypeW to check and avoid drives whose type is not\n**DRIVE_FIXED, DRIVE_REMOVABLE, and DRIVE_RAMDISK.**\n\n\n-----\n\n_Figure 143: Checking Drive Types._\n\nNext, after resolving each drive’s name, LockBit spawns a thread to traverse it. The thread handle is\nadded to a global thread array structure for cleaning up afterward.\n\n_Figure 144: Spawning Threads To Traverse Drives._\n\nTo traverse each drive, the malware first compares the drive name to “tsclient” and “Microsoft\n**Terminal Services” to avoid processing these. Drives that have been traversed have their name added**\nto a global array, so for each new drive to be processed, LockBit iterates through this array and checks if\nthe drive’s name is in there to avoid traversing any drive multiple times.\n\n_Figure 145: Avoiding Traversing Drives Multiple Times._\n\nBefore traversing a drive, the malware formats the string “%s\\%02X%02X%02X%02X.lock” with its\npublic key to generate a file name with the .lock extension in the target drive. Because this file being in a\ndrive used as a sign that the drive is being encrypted, LockBit calls CreateFileW to try creating this file\n\n\n-----\n\nin the target drive. If the file already exists, the malware s thread just exits immediately to avoid having\nmultiple threads encrypting a file at once.\n\n_Figure 146, 167: Creating .lock File To Enforce One Encryption Thread Per Drive._\n\nOnce the drive is ready to be encrypted, the malware adds it to the global drive array so other threads\ncan later ignore it.\n\n_Figure 148: Adding Drive Name To Processed Drive Array._\n\nIt also calls SHEmptyRecycleBinW to remove all files in the drive’s Recycle Bin folder and\n**GetDiskFreeSpaceW to retrieve memory information about the drive to send to the logging window.**\nAlso, the number of bytes per sector retrieved from the function is used as the block size for encrypting\nfile.\n\n\n-----\n\nTo traverse the drive, LockBit calls FindFirstFileExW and FindNextFileW to enumerate through all\nfiles/folders in the drive. It first avoids the filenames ”.” and .., which corresponds to the drive’s current\nand parent directory.\n\n_Figure 149: Drive Enumeration._\n\nIf the malware finds a subfolder inside with the FILE_ATTRIBUTE_DIRECTORY type, it calls\n**CharLowerW and compares the folder’s name in lower case with the following names to avoid**\nencrypting.\n```\n$Windows.~bt, intel, msocache, $recycle.bin, $windows.~ws, tor browser, boot, windows nt, \nmsbuild, microsoft, all users, system volume information, perflog, google, application data, \nwindows, windows.old, appdata, mozilla, microsoft.net, microsoft shared, internet explorer, \ncommon files, opera, windows journal, windows defender, windowsapp, windowspowershell, usoshared,\nwindows security, windows photo viewer\n\n```\n\n-----\n\n_Figure 150: Blacklisting Folder Names._\n\nIf the folder name is valid, LockBit calls the traversing function on the folder to recursively traversing it.\n\n_Figure 151: Recursive Folder Traversal._\n\nIf a file whose type is not FILE_ATTRIBUTE_SYSTEM is encountered, LockBit compares its extension\nwith the following extensions to avoid encrypting.\n```\n.386, .cmd, .ani, .adv, .msi, .msp, .com, .nls, .ocx, .mpa, .cpl, .mod, .hta, \n.prf, .rtp, .rpd, .bin, .hlp, .shs, .drv, .wpx, .bat, .rom, .msc, .spl, .msu, \n.ics, .key, .exe, .dll, .lnk, .ico, .hlp, .sys, .drv, .cur, .idx, .ini, .reg, \n.mp3, .mp4, .apk, .ttf, .otf, .fon, .fnt, .dmp, .tmp, .pif, .wav, .wma, .dmg, \n.iso, .app, .ipa, .xex, .wad, .msu, .icns, .lock, .lockbit, .theme, .diagcfg, \n.diagcab, .diagpkg, .msstyles, .gadget, .woff, .part, .sfcache, .winmd\n\n```\n\n-----\n\n_Figure 152: Blacklisting Extensions._\n\n**LockBit also avoids encrypting the file if its name is in the following file list.**\n```\nntldr, ntuser.dat.log, bootsect.bak, autorun.inf, thumbs.db, iconcache.db, restore-my-files.txt\n\n```\nIf the file’s attribute is FILE_ATTRIBUTE_READONLY, LockBit calls SetFileAttributesW to set it to\n**FILE_ATTRIBUTE_NORMAL to be able to encrypt data and write to it. Finally, it calls a function to set up**\nthe file structure to be sent to child threads to encrypt via I/O completion port.\n\n_Figure 153: Setting File’s Attribute & Setting Up Shared File Structure._\n\nBelow is a rough recreation of the shared file structure, which is exactly 24656 bytes in size.\n\n\n-----\n\n```\nstruct __declspec(align(8)) LOCKBIT_FILE_STRUCT\n{\n byte AES_IV[16];\n byte AES_key[16];\n uint64_t file_size;\n uint32_t block_size;\n uint32_t chunk_count;\n HANDLE file_handle;\n UNICODE_STRING file_NT_path_name;\n DWORD chunk_size;\n LARGE_INTEGER last_chunk_offset;\n DWORD number_of_chunks_allocated;\n DWORD unk2;\n LOCKBIT_CHUNK_STRUCT chunk_structs[512];\n};\n\n```\nFirst, because each file is encrypted in chunks, the malware calculates the size of the chunks based on\nthe block size (which is also the number of bytes per sector). If the block size is not retrieved\nsuccessfully, the default block size is set to 512 bytes.\n\n_Figure 154: Calculating Chunk Size._\n\nNext, LockBit appends the encrypted extension “.lockbit” to the end of the filename and calls\n**RtlDosPathNameToNtPathName to set the path name in the file structure’s file_NT_path_name field.**\n\nIt also calls NtCreateFile to retrieve a file handle to the target file to set the structure’s file_handle field,\nand if that fails, the malware attempts to terminate any processes that is using the file.\n\n\n-----\n\n_Figure 155: Retrieving File Handle._\n\nTo terminate file owners, LockBit calls NtOpenFile to retrieve the file handle and calls\n**NtQueryInformationFile to query the file information class FileProcessIdsUsingFileInformation to**\nretrieve a list of IDs for processes that are accessing the file. LockBit calls NtQuerySystemInformation\nto query all running processes on the system and iterates through each until it finds processes that\naccesses the file.\n\n\n-----\n\n_Figure 156, 157: Enumerating To Find File Owners._\n\nFor each of those proccess, the malware retrieves its executable name, hashes it with ROR13, and\ncompares it to a list of process hashes to avoid.\n\n\n-----\n\n_Figure 158: Enumerating To Find File Owners._\n\nBelow is the list of hashes to avoid terminating.\n```\n0x2C99BB9E, 0xE3040AC3, 0xDFF94C0E, 0x230D4C0F, 0xEDFFA2DF, 0x7679DAD9, 0xDFD4E1B0, 0x2C03BAC0,\n0xB2E7021A, 0xA2DB72B9, 0x2BC94C0F, 0x6C916B9F, 0x5FC881AB, 0x6318437E, 0x32FB431E, 0xEEF7FBA3,\n0x3CE08834, 0x4A00E40D, 0x86059875, 0x728CB221, 0x5E2D07A0, 0x2903F2AF, 0x33FB126D, 0x6895E8E4,\n0x39DB8E34\n\n```\nNow I can sit here and bruteforce to try and guess what process each of these hashes corresponds to,\nbut [you know what they say.](https://www.youtube.com/watch?v=6gLMSf4afzo)\n\nIf the hash of the process’s name is not in the list above, LockBit retrieves its ID and calls\n**NtTerminateProcess to terminate it.**\n\n_Figure 159: Terminating Each File Owner Process._\n\nNext, the malware calls NtCreateFile to try and retrieving the file handle again. After doing this\nsuccessfully, LockBit calls NtSetInformationFile with the information class FileCompletionInformation\nto associate the file’s shared structure with the I/O completion port to communicate with the child threads.\n\n_Figure 160: Associating File Shared Structure With I/O Completion Port._\n\nIt also sets up the structure’s file_size, chunk_size, block_size fields. Because the last chunk being\nwritten will contain the LockBit’s file footer, the malware also calculates the appropriate\n**last_chunk_offset field and the final encrypted file size. It also calls NtSetInformationFile to set the file**\ninformation class FileEndOfFileInformation to the new file size.\n\n\n-----\n\n_Figure 161: Calculating Chunking Information For The File Structure._\n\nIf the file size is too large (greater than 0x8000000000000000 bytes) or too small (less than the chunk\nsize), the structure’s chunk_size field is set to the entire file size and the chunk_count field is set to 1.\nThis means for these files, LockBit reads the entire file into 1 chunk and encrypts it.\n\n_Figure 162: Checking For Full File Encryption Scenarios._\n\nFor the rest of the files, the chunk_count field is also sets to 1, which means LockBit only encrypts the\nfirst chunks for other files. However, for files that are categorized by LockBit as large files, this field is\nmodified based on its extension and size.\n\nThe following extensions are categorized as large file extensions.\n```\n.rar, .zip, .ckp, .db3, .dbf, .dbc, .dbs, .dbt, .dbv, .frm, .mdf, .mrg, \n.mwb, .myd, .ndf, .qry, .sdb, .sdf, .sql, .tmd, .wdb, .bz2, .tgz, .lzo, \n.db, .7z, .sqlite, .accdb, .sqlite3, .sqlitedb, .db-shm, .db-wal, .dacpac, .zipx, .lzma\n\n```\nFor these files, if the file size is less than the chunk size, the file is ignored and only the first chunk is\nencrypted. If the file size is larger than the chunk size, below is the ranges of file size and their\ncorresponding chunk count.\n\nchunk_size -> 0x100000 bytes: 2 chunks\n0x100000 -> 0x600000 bytes: 4 chunks\n0x600000 -> 0x3200000 bytes: 16 chunks\n0x3200000 -> 0x6400000 bytes: 32 chunks\n0x6400000 -> 0x1F400000 bytes: 64 chunks\n0x1F400000 -> 0x80000000 bytes: 128 chunks\n0x80000000 -> 0x300000000 bytes: 256 chunks\n\n\n-----\n\n0x300000000 bytes or above: 512 chunks\n\n_Figure 163: Calculating The Number Of Chunks For Large Files._\n\nNext, LockBit populates the LOCKBIT_CHUNK_STRUCT structures in the file structure’s\n**chunk_structs field. The number of chunk structures populated is equal to the number of chunk count**\ncalculated above.\n```\nstruct __declspec(align(8)) LOCKBIT_CHUNK_STRUCT\n{\n DWORD crypt_state;\n PIO_STATUS_BLOCK chunk_IoStatusBlock;\n DWORD unk;\n byte AES_IV[20];\n LARGE_INTEGER byte_offset;\n byte *chunk_buffer;\n DWORD chunk_size;\n};\n\n```\nFirst, the malware calls the RNG function to randomly generate a 16-byte AES key and 16-byte AES IV\nand writes them in the file structure’s AES_IV and AES_key field. For each chunk structure to be\npopulated, LockBit copies the file structure’s AES IV into its AES_IV field. It also calls\n**NtAllocateVirtualMemory to allocate a virtual memory buffer with the size of the chunk size and sets the**\n**chunk_buffer field to the buffer’s pointer. The malware then writes the file offset to start reading data into**\nthis particular chunk at byte_offset, and this offset is incremented by 1MB for every chunk. This means\nthat LockBit only encrypts one chunk for every 1 MB in the file.\n\n\n-----\n\n_Figure 164: Populating Chunk Structures._\n\nFor each chunk structure populated, LockBit calls NtReadFile to read the file data at the offset specified\nby the byte_offset with the size specified by the chunk_size field into the virtual buffer at the\n**chunk_buffer field. After these calls, each chunk contains the appropriate file chunk for the child threads**\nto encrypt and write back to the file. Also, when LockBit fires this file I/O operation by calling\n**NtReadFile, it takes in the chunk structure as the APC context for the entry added to the main I/O**\ncompletion object.\n\n\n-----\n\n_Figure 165: I/O Operation To Read File Data Into Chunks._\n\n**LockBit also renames the file before encrypting it. The malware does this by populating a**\n**FILE_RENAME_INFORMATION with the encrypted filename and calls NtSetInformationFile with the**\ninformation class FileRenameInformation.\n\n_Figure 166: Renaming File To Contain .lockbit Extension._\n\nFor congestion control among the working threads, LockBit keeps track of the number of files that are\nactively processed in a global variable. If there are more than 1000 files being processed at a time, the\nmalware calls Sleep and spins until that number goes down.\n\n_Figure 167: Encryption Congestion Control._\n\nFinally, the file structure is delivered to the child threads through the NtSetInformationFile call with the\ninformation class FileCompletionInformation.\n\n\n-----\n\n_Figure 168: Sending Populated File Structure To Child Threads._\n\nOnce the drive is fully traversed, LockBit calls DeleteFileW to delete the .lock file in the drive.\n\n### Child Thread\n\nUpon being created, each child thread spins on the NtRemoveIoCompletion calls until it can remove an\nentry from the I/O completion port. Once this is done successfully, LockBit’s thread receives the file\nshared structure as the key context and the chunk structure as the APC context that comes with the\nspecific I/O operation.\n\n_Figure 169: Child Thread: Waiting To Receive A Shared File Structure & Chunk Structure._\n\nBecause each malware thread receives and processes one chunk at a time through the I/O completion\nport, the work is divided evenly among all threads. The encryption process is divided into multiple\ndifferent states, and LockBit executes the encryption routine depending on the chunk structure’s\n**crypt_state field.**\n\n**Encryption State 1**\n\nIf the crypt_state field is 1, LockBit encrypts the data in the chunk buffer using AES-CBC. The AES key\nis retrieved from the file structure’s AES_key field and the AES_IV is retrieved from the chunk structure.\n\n\n-----\n\n_Figure 170: Child Thread State 1: Encrypting Chunk Data Using AES-CBC._\n\nNext, if the file size is greater than the chunk size, the malware sets the chunk’s next state to 4. Else, the\nfile size is less than the chunk size, which means all data is fully encrypted. In this case, LockBit\ngenerates a file footer and appends it to the end of the chunk. Below is my recreated structure for this file\nfooter.\n\n\n-----\n\n```\nstruct LOCKBIT_FILE_FOOTER_STRUCT\n{\n  struct file_box {\n    byte file_public_key[0x20];\n    struct encrypted_file_data {\n      byte AES_IV[16];\n      byte AES_key[16];\n      uint64_t file_size;\n      uint32_t block_size;\n      uint32_t chunk_count;\n      byte encryption_padding[0x10];\n    } encrypted_file_box;\n  } file_box;\n  struct session_box {\n    byte session_public_key[0x20];\n    struct encrypted_session_data {\n      byte victim_public_key[0x20];\n      byte victim_private_key[0x20];\n      byte encryption_padding[0x10];\n    } encrypted_session_data;\n  } session_box;\n  byte LockBit_public_key_noncegen[0x8];\n  byte victim_public_key_noncegen[0x8];\n};\n\n```\nFirst, using Libsodium’s crypto_box_easy function, LockBit encrypts the AES IV, AES key, file size,\nblock size, and chunk count data in the file shared structure using the victim’s public key. Next, it adds the\nsession box to the file footer, which contains the public key to decrypt the session box data and the\nencrypted victim’s public-private key pair. Finally, the malware adds the first 8 bytes of its own public key\n(for session box’s nonce generation) and the first 8 bytes of the victim’s public key (for file box’s nonce\ngeneration). It then sets the chunk’s next state to 2.\n\n_Figure 171: Child Thread State 1: Generating File Footer._\n\nOnce the chunk data has been fully processed and written to, the malware calls NtWriteFile to fire an I/O\noperation to write the chunk data to the file at the chunk’s specific offset. It also passes the chunk\nstructure back in as the APC context so other child threads can retrieve it from the I/O completion port for\nthe next state.\n\n\n-----\n\n_Figure 172: Child Thread State 1: Writing Encrypted Data To File._\n\nWith this file footer setup, LockBit can decrypt each file by first decrypting the session box using its own\nprivate key and the session box’s public key. It then can use the victim’s private key and the file box’s\npublic key to decrypt the file box to get the AES key and IV to decrypt the file data.\n\n**Encryption State 2**\n\nBy viewing the number_of_chunks_allocated field in the file’s shared structure, LockBit can check to\nsee if the chunk being processed is the last chunk. If they are, the malware calls NtSetInformationFile\nwith the information class FileRenameInformation to rename the file with the encrypted .lockbit\nextension.\n\nFinally, the number_of_chunks_allocated field is decremented, and LockBit iterates through all chunk\nstructures in the file shared structure and free the virtual memory buffers inside.\n\n\n-----\n\n_Figure 173, 174: Child Thread State 2: Renaming File & Cleaning Up Chunks._\n\nTo wrap up the file encryption, the malware increments the COMPLETED_FILE_NUM global variable\nand decrements the ACTIVE_FILE_BEING_PROCESSED global variable. It calls NtClose to close the\nfile handle, RtlFreeUnicodeString to free the filename buffer, and NtFreeVirtualMemory to free the\nfile’s shared structure.\n\n\n-----\n\n_Figure 175: Child Thread State 2: Wrapping Up Encryption._\n\n**Encryption State 3**\n\nThis state just cleans up the chunk structures and file structure before wrapping up the encryption similar\nto state 2. This state is solely used for cleaning up the ransom note structure. More details is discussed in\nthe Dropping Ransom Note section.\n\n_Figure 176: Child Thread State 3: Cleaning Structures For Ransom Note._\n\n**Encryption State 4**\n\n**LockBit transitions into state 4 when the file size is greater than the chunk size, so there might be more**\nthan 1 chunk being processed in the file.\n\n\n-----\n\nIt performs similar tasks to state 2, where it checks if the encryption is done to rename the file. The\nmalware thread also cleans up the structures similar to state 2 and wraps up the encryption there.\n\n_Figure 177: Child Thread State 4: Renaming File & Wrapping Up Encryption._\n\nIf the current chunk is the last chunk to process, LockBit generates the file footer, writes it to the end of\nthe chunk buffer, and calls NtWriteFile to write the data to the file. The chunk’s next state is set to 2 to\nclean up the encryption.\n\n_Figure 178: Child Thread State 4: Writing File Footer & Transitioning To State 2._\n\nIf the encryption is not done and there are still more chunks to be encrypted, the child thread moves on to\nwait for for other chunks to come by calling NtRemoveIoCompletion\n\n\n-----\n\n### Traversing Network Hosts\n\nIf the configuration flag at index 3 is set, LockBit create threads to traverse and encrypt other network\nhosts and network drives from the victim’s machine.\n\n**Scanning For Live Hosts**\n\n**LockBit first calls socket to create an IPv4 TCP socket. Using the socket handle, it calls WSAIoctl with**\nthe GUID “{0x25a207b9,0x0ddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}” to retrieve\nthe LPFN_CONNECTEX function’s address.\n\n_Figure 179, 180: Retrieving LPFN_CONNECTEX function._\n\nNext, it calls GetAdaptersInfo to retrieve adapter information for the local computer. Using the\n**IP_ADAPTER_INFO structure it gets, the malware calls inet_addr to convert the computer’s IP address**\nand the IP mask into long values in IP network order. LockBit retrieves the base address of the network\nby performing a bitwise AND operation on these values. Also, by flipping all the bits on the mask and ORing it with the machine’s IP address, LockBit also retrieves the broadcast address of the network.\n\n\n-----\n\n_Figure 181, 182, 183, 184, 185: Retrieving Network Base Address & Broadcast Address._\n\nTo scan the network, LockBit iterates from the network base address up to the broadcast address by\nincrementing the network address value each time. For each of these addresses, the malware tries to\nconnect to it through port 135 and 445. If the connection is successful, it tries to encrypt these network\nhosts.\n\n_Figure 186: Iterating To Scan Network._\n\nFor each address, LockBit builds the following socket structure.\n```\nstruct __declspec(align(4)) SOCKET_STRUCT\n{\n OVERLAPPED overlapped;\n HANDLE socket_event;\n HANDLE socket_wait_object_handle;\n int enable_traversal;\n SOCKET socket;\n sockaddr_in target_addr;\n int cleaned_flag; // 1 == not cleaned\n};\n\n```\nIt populates this structure by calling socket to create an IPv4 TCP socket and sets that to the socket\nfield and calling bind to bind the socket to the local machine. It then calls CreateEventW to create an\nevent handle for the socket to set it to the socket_event field and calls NtSetInformationFile with the\ninformation class FileCompletionInformation to associate the socket structure with an I/O completion\nport. And finally, it populates the target_addr with the appropriate port and the target’s IP address.\n\n\n-----\n\n_Figure 187, 188, 189, 190: Populating Socket Shared Structure._\n\nNext, the malware calls RegisterWaitForSingleObject to register an event handle for when the socket’s\nevent is signaled. The event handler is just a wrapper for CancelIoEx, which cancels all I/O operations\nfor the current process. Finally, it calls LPFN_CONNECTEX to perform an I/O operation to create a\nconnection to the network host. If the network host is not alive and the function fails to execute, LockBit\ncleans up the structure and moves on to test another host.\n\n\n-----\n\n_Figure 191: Connecting To Remote Host._\n\n**Launching Threads To Traverse Live Hosts’ Network Shares**\n\nPrior to scanning the network, LockBit calls NtCreateIoCompletion to create an I/O completion object\nfor communication on network host encryption. It also calls CreateThread to create threads that will spin\non this I/O completion object to receive a specific network host to traverse and encrypt.\n\n_Figure 192: Creating Threads To Traverse Network Hosts._\n\nThe child thread has an infinite while loop to call NtRemoveIoCompletion and wait until it receives a\nsocket structure when the parent thread makes the call to LPFN_CONNECTEX for a specific network\nhost.\n\n_Figure 193: Waiting To Receive Socket Structure For Network Host._\n\n\n-----\n\nFor each network host received, it calls WSAAddressToStringW to convert the host s address to a string\nand traverses through network shares on it.\n\n_Figure 194: Traversing Network Host._\n\nTo traverse through network shares on a host, the malware first calls WNetAddConnection2W to\nestablish a direct connection to the host and NetShareEnum to retrieve information about its shared\nresources. For each shared resource, the malware formats the following path ”\\<host address>\\\n**<shared resource name>” and calls the traversal function from the Traversing Local Drive section to**\ntraverse and encrypt it.\n\n_Figure 195, 196: Traversing & Encrypting Network Hosts’ Shared Resources._\n\n### Traversing Network Drives\n\nAfter encrypting shared resources on network hosts, LockBit also traverses and encrypts remote drives\non the victim’s machine.\n\n**Impersonation Process With The Same Authentication ID**\n\n\n-----\n\n**LockBit spawns a thread to encrypt remote drives while impersonating a process with the same**\nauthentication ID.\n\nIt impersonates by calling NtQueryInformationToken to query the elevation type of the current process’s\ntoken to check if it is elevated. If it is, the malware calls NtQueryInformationToken to retrieve a handle\nto another token that is linked to this elevated token and the linked token’s authentication ID.\n\n_Figure 197: Retrieving Linked Token._\n\nFor the given authentication ID, the malware calls CreateToolhelp32Snapshot to get a snapshot handle\nof all processes on the system. It calls Process32FirstW and Process32NextW to enumerate through\nall processes. For each process, LockBit calls OpenProcess using the process’s ID to retrieve the\nprocess handle and NtQueryInformationToken to retrieve the process’s authentication ID. It\nenumerates until finding a process with the same authentication ID as the linked token above.\n\n\n-----\n\n_Figure 198: Enumerating To Find Process With The Same Authentication ID._\n\nOnce found, LockBit calls DuplicateToken to duplicate and impersonate the target process’s token and\n**SetThreadToken to set the duplicated token to its own process.**\n\n_Figure 199, 200: Impersonating Process With The Same Authentication ID._\n\nAfter impersonating, LockBit begins to traverse through all network drives on the system. It enumerates\nthrough drives by calling GetLogicalDrives and performs a bit test on each bit to only find drives that\nexists on the system. For each of these drives, the malware calls WNetGetConnectionW to retrieve the\ndrive’s network path and creates a thread to traverse it.\n\n\n-----\n\n_Figure 201, 202, 203: Enumerating Network Drives._\n\nThe function for traversing this is basically just a wrapper for the traversal function from the Traversing\nLocal Drive section.\n\n\n-----\n\n_Figure 204: Traversing & Encrypting Network Drives._\n\n**Impersonation Shell Process Window**\n\n**LockBit also spawns a thread to encrypt remote drives while impersonating as the shell process window.**\n\nFirst, it calls GetShellWindow to retrieves a handle to the Shell’s desktop window and\n**GetWindowThreadProcessId to get the process’s ID. Next, it calls OpenProcess to retrieve the**\nprocess’s handle using its ID and NtOpenProcessToken to retrieve the process’s token.\n\n\n-----\n\n_Figure 205, 206, 207: Retrieving Shell Process’s Token._\n\nFinally, to impersonate this process, LockBit calls DuplicateToken to duplicate the process’s token and\n**SetThreadToken to set the duplicated token to its own process.**\n\n_Figure 208, 209: Impersonating As Shell Process._\n\nThe rest of the network drive traversal routine is the same as documented above.\n\n### Dropping Ransom Note\n\nThe ransom note is dropped during the parent’s thread traversal routine in Traversing Local Drive.\n**LockBit first generates the ransom note path in the folder by appending ”\\Restore-My-Files.txt” after**\nthe folder path.\n\n_Figure 210: Generating Ransom Note Path._\n\n\n-----\n\nIf the ransom note does not exist in the folder yet, LockBit creates a shared file structure and populates\nit with the ransom note path. The malware also calls NtCreateFile to create the ransom note and\n**NtSetInformationFile to associate the file structure with the I/O completion object.**\n\n_Figure 211, 212: Setting Up Ransom Note Shared File Structure._\n\nAfter populating a chunk structure with the ransom note content and sets the chunk’s next state to 3, it\ncalls NtWriteFile to write the content into the ransom note. This will add an entry to the I/O completion\nobject, where one child thread will receive and cleans up the ransom note’s chunk and file structure.\n\n\n-----\n\n_Figure 213: Dropping Ransom Note In Directory._\n\nIf the ransom note already exists in the directory, this step is skipped.\n\n## Self-Deletion\n\nAfter finishing file encryption, LockBit deletes itself if the configuration flag at index 1 is set.\n\nIt first resolves the stack string ” /C ping 127.0.0.7 -n 3 > Nul & fsutil file setZeroData offset=0\n**length=524288 “%s” & Del /f /q “%s”“ and formats this with its own executable path.**\n\n_Figure 214: Building Self-deletion Command._\n\nThis command pings localhost with 3 echo Request messages to delay and wait for the malware to finish\nexecuting, executes fsutil to empty the malware’s executable, and force-delete the file in quiet mode.\n\n**LockBit also calls MoveFileExW to set itself to be deleted after the system reboots.**\n\n_Figure 215: Setting Self To Be Deleted After Reboot._\n\nFinally, the malware calls ShellExecuteExW to execute the command above to delete itself.\n\n\n-----\n\n_Figure 216: Executing Command To Delete Self._\n\n## References\n\nhttps://asec.ahnlab.com/en/17147/\n\nhttps://news.sophos.com/en-us/2020/04/24/lockbit-ransomware-borrows-tricks-to-keep-up-with-revil-andmaze/\n\nhttps://www.trustedsec.com/blog/weaponizing-group-policy-objects-access/\n\nhttps://www.bleepingcomputer.com/news/security/lockbit-ransomware-now-encrypts-windows-domainsusing-group-policies/\n\nhttps://devblogs.microsoft.com/oldnewthing/20080314-00/?p=23113\n\nhttps://www.ic3.gov/Media/News/2022/220204.pdf\n\nhttps://www.crowdstrike.com/blog/how-crowdstrike-prevents-volume-shadow-tampering-by-lockbitransomware/\n\nhttps://talos-intelligencesite.s3.amazonaws.com/production/document_files/files/000/095/481/original/010421_LockBit_Interview.pdf\n\nhttps://www.prodaft.com/m/reports/LockBit_Case_Report___TLPWHITE.pdf\n\nhttps://www.cyber.gov.au/acsc/view-all-content/advisories/2021-006-acsc-ransomware-profile-lockbit-20\n\n\n-----\n\nhttps://symantec-enterprise-blogs.security.com/blogs/threat-intelligence/ransomware-trends-lockbitsodinokibi\n\nhttps://libsodium.gitbook.io/doc/public-key_cryptography/authenticated_encryption\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-19 - LockBit Ransomware v2.0.pdf"
    ],
    "report_names": [
        "2022-03-19 - LockBit Ransomware v2.0.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f5bf6853-3f6e-452c-a7b7-8f81c9a27476",
            "created_at": "2023-01-06T13:46:38.677391Z",
            "updated_at": "2025-03-27T02:00:02.889755Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "MISPGALAXY:Careto",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "0fc739cf-0b82-48bf-9f7d-398a200b59b5",
            "created_at": "2022-10-25T16:07:23.797925Z",
            "updated_at": "2025-03-27T02:02:09.983353Z",
            "deleted_at": null,
            "main_name": "LockBit Gang",
            "aliases": [
                "Bitwise Spider",
                "Operation Cronos"
            ],
            "source_name": "ETDA:LockBit Gang",
            "tools": [
                "3AM",
                "ABCD Ransomware",
                "CrackMapExec",
                "EmPyre",
                "EmpireProject",
                "LockBit",
                "LockBit Black",
                "Mimikatz",
                "PowerShell Empire",
                "PsExec",
                "Syrphid"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "3940f08b-39aa-492c-8699-86bfe515fa70",
            "created_at": "2023-01-06T13:46:39.470535Z",
            "updated_at": "2025-03-27T02:00:03.101867Z",
            "deleted_at": null,
            "main_name": "BITWISE SPIDER",
            "aliases": [],
            "source_name": "MISPGALAXY:BITWISE SPIDER",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673536019,
    "ts_updated_at": 1743041587,
    "ts_creation_date": 1653693896,
    "ts_modification_date": 1653693896,
    "files": {
        "pdf": "https://archive.orkl.eu/d41cd3a40217598ffb6f0bfdeeccbf90bb2a025b.pdf",
        "text": "https://archive.orkl.eu/d41cd3a40217598ffb6f0bfdeeccbf90bb2a025b.txt",
        "img": "https://archive.orkl.eu/d41cd3a40217598ffb6f0bfdeeccbf90bb2a025b.jpg"
    }
}