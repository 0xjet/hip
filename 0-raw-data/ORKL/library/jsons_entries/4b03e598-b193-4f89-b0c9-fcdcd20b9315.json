{
    "id": "4b03e598-b193-4f89-b0c9-fcdcd20b9315",
    "created_at": "2023-01-12T14:59:37.62539Z",
    "updated_at": "2025-03-27T02:09:18.060649Z",
    "deleted_at": null,
    "sha1_hash": "8af41fdddd7e3e0cb14466ca641b76d9ae9df91c",
    "title": "2022-03-09 - BokBot Technical Analysis",
    "authors": "",
    "file_creation_date": "2022-05-29T01:34:56Z",
    "file_modification_date": "2022-05-29T01:34:56Z",
    "file_size": 181058,
    "plain_text": "# BokBot Technical Analysis\n\n**nikpx.github.io/malware/analysis/2022/03/09/BokBot**\n\nMar 09, 2022 xors\n\n## Executive Summary\n\nBokBot, also known as IcedID, was among one of the most active malware families in 2021\nand has been known for loading different types of payloads such as Cobalt Strike for\nexample. BokBot has previously been linked to ‘NeverQuest’[1] and over the years it has\ngone through various code changes.\n\nThe following article presents the findings of analysis conducted on samples which appeared\nin December 2021. Furthermore, the analysis focuses on the main module and its network\ncommunication features and functionality. Overall, BokBot has the typical features that you\nwould expect from a banking trojan. Specifically, BokBot presents the following features that\nare notable:\n\n1. Functionality to intercept local credentials and web-form data stored in the browser\n\nalong with inserting Web-Injects to specific pages in order to capture login credentials\nas they are entered.\n2. Offers the operator(s) various commands to control the compromised host.\n3. Network support for both HTTP(S) and network sockets.\n4. Unlike previous versions, debug messages have been removed.\n\n## Technical Analysis\n\nThe following sub-sections present the findings of the analysis of the main module of BokBot.\n\n## Methodology and Approach\n\nThe biggest obstacle in analysing BokBot was the way in which the loader loads and\nexecutes the main module. BokBot’s main module runs, in memory, as pure shellcode. As a\nresult, dumping the decrypted component and running it directly in a debugger was not an\noption. Furthermore, if we consider that binary strings and Windows API functions are loaded\nat runtime, similar obstacles are met during static analysis too.\n\nTo workaround the above issues, different methods were used. Initially, the Unicorn engine\nwas used to execute and debug certain functions; this was useful to confirm that the strings\ndecryption algorithm has been correctly converted to Python for example. In cases where\n\n\n-----\n\nthis was not possible, a debug session was started by breaking at the entry point of the main\nmodule and moving on from there to selected addresses.\n\nThe static analysis issues were easier to solve. Upon breaking at the entry point of the main\nmodule, the resolved Windows API addresses and their associated (BokBot) addresses were\ncollected and then mapped to IDA. Lastly, the strings were decrypted by converting the\ndecryption routine to an IDAPython script (see ‘Strings/Configuration Encryption’ section).\n\n## Anti-Analysis\n\nAs with many other malicious binaries, anti-analysis techniques are employed to make the\nanalysis harder. The following methods were observed:\n\n1. Calculation of execution time between two addresses. This is repeated 15 times and\n\naims to detect emulation or debugging presence (step over). Fortunately, even though\nthis mechanism can be easily defeated, this code is present only in one function.\n2. Execution of CPUID instruction to get information about the host’s processor. By\n\npassing the parameter 0x40000000, stored in EAX, to the CPUID instruction, the\nvendor ID is returned. Then BokBot checks if it matches any of the following patterns:\n\n1. VMwa\n2. XenV\n3. Micr\n4. KVMK\n5. lrp\n6. Vbox\n\nIf any of the above techniques are triggered, Bokbot will continue anyway but inform the\ncommand-and-control server.\n\nRegarding BokBot’s behavior in case of anti-analysis identification, the only difference, at\nleast from a binary perspective, appears to be in the execution of ‘BackConnect’ functionality\n(described in the Network Communication section); specifically in this case the operator(s)\nshould issue the feature. Otherwise it executes the ‘BackConnect’ functionality as normal in\na new thread.\n\n## Strings/Configuration Encryption\n\nBokBot keeps its binary strings in an encrypted format with each string being decrypted only\nwhen it is about to be used. An IDAPython script that automates the decryption process is\navailable on GitHub.\n\nLikewise, BokBot’s configuration is encrypted, with the configuration being stored in the\n‘.data’ section of the loader. The main module obtains a pointer to this section by reading a\nparameter passed into it by the loader. It is important to note that this parameter stores\n\n\n-----\n\nseveral pieces of important information including:\n\n1. BokBot’s loader file path\n2. Flag that indicates the file type (DLL or EXE)\n3. Pointer to encrypted configuration\n\nWith this, it is able to decrypt the configuration; a Python script to replicate this is available\non GitHub. A notable mention with regards to the configuration is that BokBot, unlike some\nother families, keeps it in a decrypted state for the entire execution time. This can be an\nimportant factor either for writing a memory configuration dumper or to obtain the\nconfiguration as fast as possible during an IR engagement through memory image analysis.\n\nLastly, it should be noted that unlike previous versions, debug strings appear to have been\nremoved.\n\n## Persistence\n\nBokBot supports two methods to add persistence on the compromised host. First, BokBot\ncopies its downloader to the user’s Roaming directory (%APPDATA% environment variable)\nand attempts to create a scheduled task to run it. If this fails, BokBot proceeds to use its\nsecond method, which adds a new value in the ‘Run’ registry key of the current user\n(HKEY_CURRENT_USER).\n\n_Note: In both cases, the scheduled task and the registry key names are randomly generated._\n_In addition, BokBot’s encrypted main module file (DAT file) is added as a parameter of the_\n_downloader. This is an important artefact from an incident response perspective whilst_\n_analysing suspicious registry keys or scheduled tasks._\n\n## Browser Interception\n\nOne of the core features of BokBot is its ability to intercept browser information. BokBot is\ncapable of targeting the most commonly used browsers including Chrome and Firefox. Upon\ndetecting a browser process, BokBot binds to a random port (calculated based on the\ngenerated bot ID), creates a self-signed certificate and waits for new events.\n\nBokBot uses the same decryption routine as for the configuration to decrypt the appropriate\nshellcode, supporting both x86 and x64, and injects it into the browser process. The role of\nthe injected shellcode is to hook Windows API functions that are used during the\ntransmission of network data. This is an approach that many malware families have followed\nfor years in order to intercept data before any encryption is applied.\n\nWith the appropriate shellcode injected into the browser’s process and the (BokBot) server\nrunning, BokBot is capable of intercepting sensitive data (man-in-the-middle).\n\n\n-----\n\n## Data Storage\n\nBokBot stores necessary data such as web-injects in the registry of the compromised host.\nThe key is located at\nHKEY_CURRENT_USER\\Software\\Classes\\CLSID\\Random_Key_Name, where\nRandom_Key_Name is generated based on an MD5 hash value derived from the bot ID and\na custom hashing algorithm.\n\n## Network communication\n\nBokBot supports a variety of network commands. Since it supports both HTTP(S) and\nnetwork sockets, this section has been separated into two parts.\n\n### HTTP Communication\n\nUpon execution, BokBot starts communicating to the command-and-control server via\nHTTP(S) requests. BokBot starts by sending a POST request in order to check if there are\nany commands to execute. The request contains host information such as Operating system\nversion along with a generated bot ID. The bot ID is included in the headers of each request,\nsee Table 1 for a brief description of headers. The initial request body includes the following\ninformation:\n\n1. MAC Address\n2. Compromised host name\n3. Domain name that the compromised host belongs\n4. Boolean value indicating the BokBot access privileges\n5. Boolean value indicating presence of anti-analysis software\n6. Windows build version\n7. NETBIOS Name\n8. Boolean value indicating the BokBot process integrity level\n\n**Header**\n**Name** **Description**\n\nAuthorization Contains various information of BokBot such as the bot and downloader\nIDs along with the bot’s version.\n\nCookie Contains runtime information of BokBot such as any errors while obtaining\na handle of the downloader.\n\n_Table 1: HTTP Headers_\n\nOnce the command-and-control server receives the request, it replies with a set of command\nIDs that BokBot should execute (Figure 1).\n\n\n-----\n\n_Figure 1: Commands To Execute_\n\nThe way in which BokBot matches the received commands with its appropriate function is\ninteresting. BokBot stores an array of DWORD values representing the command ID,\nfollowed by an array of encoded function pointers. Upon receiving and parsing the\ncommands list, BokBot loops through the commands array and if any matches, it decodes\nthe appropriate function pointer. The encoding/decoding process is as follows (Python\nformat):\n```\nror = lambda val, r_bits, max_bits: \\\n  ((val & (2**max_bits-1)) >> r_bits%max_bits) | \\\n  (val << (max_bits-(r_bits%max_bits)) & (2**max_bits-1))\nrol = lambda val, r_bits, max_bits: \\\n  (val << r_bits%max_bits) & (2**max_bits-1) | \\\n  ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))\nmax_bits = 64\n#Encodes function address 0x000002442432D450\nencoded_function = ror(0x000002442432D450 ^ 0x123456789ABCDEF,7,64)\ndecoded_function_address = hex(rol(encoded_function,7,64) ^ 0x123456789ABCDEF)\n\n```\nThe below table summarises the identified BokBot HTTP commands (Table 2).\n\n**Command**\n**ID** **Description**\n\n0x4C52201 Requests an updated version of BokBot main module from the commandand-control server. Once received, BokBot is restarted. The incoming\nupdated version is decrypted with the same algorithm used to decrypt the\nBokBot configuration with the only difference being the encryption key,\nwhich is derived from the bot ID.\n\n0x345ABA9 Requests an updated list of BokBot servers domains. Configuration is\ndecrypted with the same algorithm used to decrypt the BokBot configuration\nwith the only difference being the encryption key, which is derived from the\nbot ID.\n\n\n-----\n\n**Command**\n**ID** **Description**\n\n0x1F95C7A Requests an updated version of BokBot downloader from the commandand-control server. Once received, BokBot invokes its persistence methods\nagain. Then it restarts itself.\n\n0x17300E2 Updates the BokBot configuration key ‘sys’.\n\n0x1E4290D Updates BokBot web-injects.\n\n0x22E9E49 Triggers network beacon thread to send a beacon message to the server.\n\n0x13CFAD5 Updates the period time of network beacon thread.\n\n0x377218A Reads BokBot log file.\n\n0x274FF95 Sets a value in the BokBot registry key to specify what type of data BokBot\nshould log.\n\n0x59E8E82 Creates new specified registry key and sets data to it.\n\n0x589BEA9 Reads the data of a specified registry key.\n\n0x3702792 Deletes registry key.\n\n0x2C9101D Enumerates processes and sends them to the command-and-control\nserver.\n\n0x2B0C92C Executes system commands in the compromised host. This can include\nfiles and PowerShell scripts too.\n\n0x2617262 Injects shellcode into a new process.\n\n0x47A7AA5 Issues ‘BackConnect’ feature (described in the Network Communication\nsection).\n\n0x3ABD5C5 Get files list located in the desktop path.\n\n0x5AEEE0D Runs system credentials stealer.\n\n0x2AF7C33 Runs browser cookie stealer. A temporary file is created to store the\ncollected data.\n\n0x0D128D1 Reads a file and sends its content to the command-and-control server.\n\n0x4577C59 Searches for a file and reads its content. Then its contents are sent to the\ncommand-and-control server.\n\n0x172261B Collects system information of the compromised host by executing various\ncommands(See Table 3 in Appendix)\n\n\n-----\n\n_Table 2: BokBot HTTP Commands_\n\n_Note: Commands 0x2B0C92C and 0x2617262 support two different UAC bypass methods._\n_The first method abuses the executable file ‘fodhelper.exe’ [2] and the second method uses_\n_the executable file ‘eventvwr.exe’ [3]. Requests from the server that involve an update to_\n_either a configuration or executable file are verified using a hard-coded public RSA key._\n\nAfter executing a command, BokBot compresses the data using the Zlib library and removes\nthe first two bytes ‘0x78 0x9c’. Then, it constructs a POST request with a specific URI (each\ncommand has its own URI parameters hard-coded) and sends it to the server (Figure 2).\n\n_Figure 2: BokBot sending collected processes names to the server_\n\n### Sockets (BackConnect)\n\nThe ‘BackConnect’ functionality provides the operator(s) an additional set of available\ncommands and uses the same command-and-control server as before. Upon successful\nconnection to the server, BokBot registers a handler and waits for data. Note: The used port\n_number is 443._\n\nAt this point BokBot will perform a different set of actions depending on the status of the\nconnection. For example, if there is a connection time-out then it sends a request to the\nserver with command ID 2 (proceeds to internal command dispatcher) and waits again for\nnew data. In general, BokBot uses the following structure when sending socket data:\n```\n#pragma pack(push, 1)\nstruct BC_Send_Data\n{\n BYTE CMD_ID;\n BYTE Connection_Status;\n BYTE Connection_Counter;\n WORD Error_Code;\n DWORD New_Received_Socket_IP;\n};\n#pragma pack(pop)\n\n```\nThe above packet is added to another structure, which BokBot uses as a header, in an\nencrypted format. The data is encrypted using a bitwise XOR operation with the random key\nbeing stored in the packet header (see structure below).\n\n\n-----\n\n```\n#pragma pack(push, 1)\nstruct BC_Send_Data_Header\n{\n BYTE Encoded_ID; // ID | 0x80\n BYTE Encoded_Packet_Size_In_Buffer; // Size | 0x80\n DWORD XOR_Key; // Random generated\n BYTE Encrypted_Command_Data[];\n};\n#pragma pack(pop)\n\n```\n_Note: If the command’s size is greater than 126 bytes then the structure’s fields are different_\n_but the concept remains the same._\n\nConsidering the above information, the important functionalities of the Back-Connect feature\nare triggered once data is received. The data is decrypted either using a bitwise XOR\noperation, using the key stored in the packet header structure, or by using the\n```\nDecryptMessage API function. The decryption method selection is based on an integer flag\n\n```\nthat is initialised during the connection.\n\nNext, BokBot checks if the first byte of the encrypted network packet matches any of the\nbelow values:\n\n2 - Proceeds to internal command dispatcher.\n8 – Returns unsuccessful error code.\n9 – Sends a request with command ID 10 along with the decrypted data.\n10 – More data is available and has not been read.\n\nIn the first case (value 2), BokBot proceeds to its internal command dispatcher and performs\nanother check of the first byte (command ID) of the decrypted data with the following values:\n\n1 – Adds a new IP to communicate with - in this case, a connection is made to the port\nnumber 8080.\n2 – Sends request with command ID 2 to the server - this is the same request packet\nas in the time-out case.\n4 – Executes a command from Table 2 - command ID is specified in the packet.\n\nRegarding command ID 1, BokBot creates a new thread for each new received IP address\nthat it should connect to. Furthermore, after connecting to the new IP address, BokBot sends\na request with command ID 0. It should be noted that the structure of the requests and\nreplies are different compared to previous cases:\n\n\n-----\n\n```\n#pragma pack(push, 1)\nstruct BackConnect_Packet\n{\n DWORD Verify_Value; // Used to verify the server. Set to 0x974F014A\n BYTE Command_ID;\n DWORD Bot_ID;\n DWORD Key; // Downloader ID. Used in the executed file \n};\n#pragma pack(pop)\n\n```\nThen, the server replies with the same data structure. The available command IDs are:\n\n1 – Changes connection timer.\n3 – Sets connection timer to 60 seconds.\n4 – Downloads and executes a file from the server - in case of error, sends command\nID 2 to the server.\n5 – Decrypts embedded VNC module and injects it into a new instance of ‘DllHost.exe’.\n\nThroughout the connection session, BokBot sends a command with ID 1 as a beacon to the\nserver, waiting for new data.\n\n## References\n\n1. https://blog.fox-it.com/2018/08/09/bokbot-the-rebirth-of-a-banker/\n2. https://pentestlab.blog/2017/06/07/uac-bypass-fodhelper/\n3. https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry\nhijacking/\n\n## Appendix\n\n1. https://github.com/nikpx/BokBot/blob/master/Bokbot_IDA_Decrypt_Strings_2022.py\n2. https://github.com/nikpx/BokBot/blob/master/Config_Network_Data_Decrypt.py\n\n**Command** **Description**\n\n\nWMIC /Node:localhost /Namespace:\\root\\SecurityCenter2\nPath AntiVirusProduct Get * /Format:List\n\n\nCollects installed AntiVirus products\n\n\nipconfig /all Collects network\nconfiguration/information\n\nsysteminfo Operating system\ninformation\n\nnet config workstation Collects workstation\nsettings\n\nnltest /domain_trusts Collects trusted domains\n\n\n-----\n\n**Command** **Description**\n\nnltest /domain_trusts /all_trusts Collects all trusted\ndomains\n\nnet view /all /domain Collects all domain\nnetwork shares\n\nnet view /all Collects all network\nshares\n\nnet group “Domain Admins” /domain Collects domain admins\nusernames\n\n_Table 3: Commands to collect system information_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-03-09 - BokBot Technical Analysis.pdf"
    ],
    "report_names": [
        "2022-03-09 - BokBot Technical Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535577,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653788096,
    "ts_modification_date": 1653788096,
    "files": {
        "pdf": "https://archive.orkl.eu/8af41fdddd7e3e0cb14466ca641b76d9ae9df91c.pdf",
        "text": "https://archive.orkl.eu/8af41fdddd7e3e0cb14466ca641b76d9ae9df91c.txt",
        "img": "https://archive.orkl.eu/8af41fdddd7e3e0cb14466ca641b76d9ae9df91c.jpg"
    }
}