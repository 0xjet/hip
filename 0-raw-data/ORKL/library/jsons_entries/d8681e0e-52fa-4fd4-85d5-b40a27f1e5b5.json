{
    "id": "d8681e0e-52fa-4fd4-85d5-b40a27f1e5b5",
    "created_at": "2023-01-12T14:59:59.789893Z",
    "updated_at": "2025-03-27T02:05:19.830155Z",
    "deleted_at": null,
    "sha1_hash": "8ada8a08082497850a58beb0d6c1e795bbf6aa59",
    "title": "2021-09-21 - Using Zeek to track communication state",
    "authors": "",
    "file_creation_date": "2022-05-27T23:21:57Z",
    "file_modification_date": "2022-05-27T23:21:57Z",
    "file_size": 1407555,
    "plain_text": "# Using Zeek to track communication state\n\n**[corelight.com/blog/using-zeek-to-track-communication-state](https://corelight.com/blog/using-zeek-to-track-communication-state)**\n\n\n-----\n\n[Home ›› Using Zeek to track communication state](https://corelight.com/blog)\nSeptember 21, 2021 by [Paul Dokas](https://corelight.com/blog/author/paul-dokas)\n\n\n-----\n\nOne of [Zeek s greatest strengths is its ability to deeply inspect packet streams that are fed](https://zeek.org/)\ninto it. It is adept not only at identifying network protocols but also parsing them to extract\nlarge amounts of useful information. There is another strength that is often overlooked: Zeek\nnot only extracts information from individual packets of network sessions, it also provides a\nvery flexible and useful way to track state across the lifetime of network sessions. This is\nparticularly useful when examining network protocols such as Server Message Block (SMB)\nthat rely on the endpoint devices to track the state of their conversation.\n\n[To illustrate this point, here is a Zeek script for detecting attempts to exercise the PetitPotam](https://github.com/corelight/PetitPotam/blob/master/scripts/main.zeek)\nexploits. We will walk through how this works in this blog post.\nThe [PetitPotam exploit offers an opportunity to illustrate the power of Zeek for tracking the](https://us-cert.cisa.gov/ncas/current-activity/2021/07/27/microsoft-releases-guidance-mitigating-petitpotam-ntlm-relay)\n[state of network conversations over their lifetime. PetitPotam abuses EFS DCERPC](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-efsr/08796ba8-01c8-4872-9221-1000ec2eff31)\n[functions to trigger an NTLM relay attack that can be used to gain elevated privileges in a](https://en.hackndo.com/ntlm-relay/)\nWindows AD domain. The exploit takes place inside of an SMB session that involves several\nphases that must be tracked: the negotiation of the session’s parameters, an authentication,\none or more RPC function calls, and their matching responses. As a result, detecting this\nexploit requires tracking the state of several network protocols over the lifetime of their\nsessions. There is no single packet or portion of the ongoing conversation that contains\neverything necessary for detection.\n\nFirst, let’s examine the different parts of a successful PetitPotam exploitation, and then we’ll\nsee how Zeek tracks the state of the network protocols for us to enable the detection\nprocess.\n\nPetitPotam exploitation works by abusing the lack of sufficient permission checking when\ncalling EFS DCERPC functions on remote Windows systems. In most cases, calling a\nremote DCERPC function occurs over an SMB session, so each exploitation starts by\nnegotiating the SMB session’s parameters. Zeek takes care of tracking the state of each\nSMB session and its associated TCP session for us out of the box by storing much of what it\nknows for later use. This information is stored inside of the record that Zeek keeps for each\nnetwork connection that it sees. By tradition, the connection record is referred to by the\nvariable `c, and additional information about each connection is stored in sub-variables`\ndelimited by the $ operator. For example, additional information about the current state of\neach SMB session is stored in `c$smb_state . Figure 1 shows a small portion of the`\ninformation that Zeek has recorded about an SMB read operation from\n```\n\\\\192.168.0.85\\IPC$ (Note: this snippet is paired down for readability; there is a lot more\n\n```\n[information available in](https://docs.zeek.org/en/master/scripts/base/protocols/smb/main.zeek.html#type-SMB::CmdInfo) `c$smb_state ). What you need to know is that Zeek is tracking this`\ntype of information for us across the lifetime of each SMB session. As each SMB session\nprogresses, Zeek will add or update values to this subrecord so that it represents a summary\nof the SMB session’s current state.\n\n\n-----\n\nFigure 1\n\nThe next step in detecting a PetitPotam exploit is to dissect the DCERPC function calls that\nride on top of the SMB session, and look for signs of someone attempting to trigger an NTLM\nrelay by making an EFS function call. Again, Zeek takes care of most of these details for us\nby treating DCERPC as just another network layer above SMB. Also like the SMB sessions,\nZeek stores state information about the current DCERPC call or response in several places\nwithin the `c variable. In the case of DCERPC, this state information is stored in`\n```\nc$dce_rpc, c$dce_rpc_state, and c$dce_rpc_backing .\n\n```\nUnfortunately, the DCERPC protocol’s multiplexed nature makes it more difficult to analyze\nthan other protocols. Function calls and responses do not need to be sequential; they can be\ninterleaved and sometimes even out of order. That is, inside of a single SMB session, there\ncan be more than one DCERPC function call active at the same time awaiting a response. To\nadd to the complexity, DCERPC requires a separate bind action within the SMB session that\nselects the family of functions that will be called. This means that a single remote function\ncall will require a bind action, a function call, and a response, all of which will appear in\nseparate portions of the TCP session.\n\nThankfully, Zeek tracks all of these details for us. Consider Figures 2, 3, and 4 below which\nshow the bind, call, and response sequence of packets that exist during an attempt to trigger\nthe PetitPotam exploit. Prior to this, the attacker (192.16.0.15) has negotiated an SMB2\nsession with the victim (192.168.0.85). In Figure 2, the attacker binds to the DCERPC\n\n\n-----\n\nendpoint `c681d488-d850-11d0-8c52-00c04fd90f7e, which is associated with the`\n[Windows Encrypted File System DCERPC functions (see the line near the bottom of Figure](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-efsr/08796ba8-01c8-4872-9221-1000ec2eff31)\n2 that is highlighted in blue).\n\n\n-----\n\nFigure 2\n\n\n-----\n\nNext, the attacker tells the victim that it wants to call the [EfsRpcOpenFileRaw function, which](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-efsr/ccc4fb75-1c86-41d7-bbc4-b278ec13bfb8)\nhas the operation number 0. This is visible as the `Opnum value on the line near the bottom`\nof Figure 3, again highlighted in blue.\n\n\n-----\n\nFigure 3\n\n\n-----\n\nFinally, when the victim host has finished executing the EfsRpcOpenFileRaw function, it\nsends back a response with a return value, which in this case is `0x00000035, per Figure 4.`\n\n\n-----\n\nFigure 4\n\nThe only guarantees offered by DCERPC are that these three calls will be in that order within\na single SMB session. There may be other function calls and responses interspersed\nbetween them which could result in the different stages of the PetitPotam exploit being more\nbroadly spread across an SMB session and intermixed with other, legitimate, SMB\noperations.\n\nZeek, however, takes care of keeping track of the state of each DCERPC bind, function call,\nand response for us out of the box. By the time the response to the function call is finally\nseen on the network, Zeek has bundled up all of this information for us in\n```\nc$dce_rpc_backing . See Figure 5.\n\n```\nFigure 5\n\nThe only part still missing is the index number ( 34359743200 ), which is the reference\nnumber for the open DCERPC call associated with this response. Zeek again takes care of\n[the tracking details for us by passing this value to the dce_rpc_response event as the value](https://docs.zeek.org/en/v4.1.0/scripts/base/bif/plugins/Zeek_DCE_RPC.events.bif.zeek.html#id-dce_rpc_response)\nof the argument `fid .`\n\nWe now have everything we need to detect attempts to trigger a PetitPotam exploit. Since\nZeek has taken care of the task of tracking and collecting information through the lifetime of\nthe DCERPC session, we only need to capture DCERPC response events by writing a\n\n\n-----\n\nhandler for the `dce_rpc_response_stub event. Using the` `fid argument passed into the`\nevent handler, we can extract the DCERPC endpoint UUID, and the name of the function\ncalled from the saved state. Then, by comparing the DCERPC endpoint against those that\nare abused by the PetitPotam exploits, and by examining the function’s return code we will\nnotify the analysts in near real time that a possible exploit attempt has occurred and whether\nit appears to have been successful or not.\n\n_By Paul Dokas, Director of Corelight Labs_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-21 - Using Zeek to track communication state.pdf"
    ],
    "report_names": [
        "2021-09-21 - Using Zeek to track communication state.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535599,
    "ts_updated_at": 1743041119,
    "ts_creation_date": 1653693717,
    "ts_modification_date": 1653693717,
    "files": {
        "pdf": "https://archive.orkl.eu/8ada8a08082497850a58beb0d6c1e795bbf6aa59.pdf",
        "text": "https://archive.orkl.eu/8ada8a08082497850a58beb0d6c1e795bbf6aa59.txt",
        "img": "https://archive.orkl.eu/8ada8a08082497850a58beb0d6c1e795bbf6aa59.jpg"
    }
}