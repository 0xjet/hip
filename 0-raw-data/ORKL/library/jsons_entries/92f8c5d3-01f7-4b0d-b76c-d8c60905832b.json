{
    "id": "92f8c5d3-01f7-4b0d-b76c-d8c60905832b",
    "created_at": "2023-01-12T15:09:15.470963Z",
    "updated_at": "2025-03-27T02:06:04.329209Z",
    "deleted_at": null,
    "sha1_hash": "6bc9f5e3951cefb084b80479df9e6fa3ea9d5a5a",
    "title": "2021-01-24 - Catching Debuggers with Section Hashing",
    "authors": "",
    "file_creation_date": "2022-05-28T04:01:08Z",
    "file_modification_date": "2022-05-28T04:01:08Z",
    "file_size": 559310,
    "plain_text": "# Catching Debuggers with Section Hashing\n\n**[malwareandstuff.com/catching-debuggers-with-section-hashing/](https://malwareandstuff.com/catching-debuggers-with-section-hashing/)**\n\n[Published by hackingump on January 24, 2021](https://malwareandstuff.com/author/klopsch/)\n\n\nJanuary 24, 2021\n\n\nAs a Reverse Engineer, you will always have to deal with various anti analysis measures.\nThe amount of possibilities to hamper our work is endless. Not only you will have to deal with\ncode obfuscation to hinder your static analysis, but also tricks to prevent you from debugging\nthe software you want to dig deeper into. I want to present you `Section Hashing today.`\n\nI will begin by explaining how software breakpoints work internally and then give you an\nexample of a `Section Hashing implementation.`\n\n## Debuggers – How software breakpoints work\n\nWhen you set a breakpoint in your favourite debugger at a specific instruction, the debugger\nsoftware will replace it temporarily with another instruction, which causes a fault or an\ninterrupt. On x86, this is very often the `INT 3 instruction, which is the opcode` `0xCC . We`\ncan examine how this looks like in RAM.\n\n\n-----\n\nWe open `x32dbg.exe and debug a 32 bit PE and set a breakpoint near the entry point.`\n\nDisassembly\n\nview of debugged program\nWhen setting a breakpoint, you will see the original instruction instead of the patched one in\nthe debugger. However, we can examine the same memory page in RAM with\nProcessHacker.\n\n\n-----\n\nCode\n\nsection in RAM during debug session\nIn volatile memory, the byte `33 changed to` `CC, which will cause the program to halt when`\nreached. This software interrupt will then be handled by the debugger and the code will be\nreplaced again.\n\n## Catching Breakpoints with Section Hashing\n\nAfter explaining how software breakpoints work, I’ll get to the real topic of this article now. We\nwill move to the Linux world now for this example.\n\nA software breakpoint is actually nothing else than a code modification of the executable\nmemory section in RAM. Once a breakpoint is set, the `.text section will be modified. A`\nvery known technique to catch such breakpoints in RAM is called `Section Hashing .`\n\n\n-----\n\nAuthors can embed the hash of the .text section in the binary. Upon execution, they use the\nsame algorithm to generate a new hash from the .text section. If a software breakpoint is set,\nthe hash will differ from the embedded hash. An example implementation can look like this:\n\nExample implementation of Section Hashing\nIn this case, a hash of the .text section is generated. Afterwards it is used to influence the\ngeneration of the flag. If a software breakpoint is set during execution, a wrong hash will be\ngenerated.\n\nThis is a simple example of `Section Hashing . In combination with code obfuscation and`\nother anti analysis measurements, it can be very hard to spot this technique. It is also\noccasionally used by commercial packers.\n\n## Defeating Section Hashing\n\nThere are multiple ways to defeat this technique, some of them could be:\n\nPatching instructions\nUsing hardware breakpoints\n\nInstead of modifying the code in Random Access Memory, in x86 hardware breakpoints use\ndedicated registers to halt the execution. Hardware Breakpoints are still detectable.\n\n\n-----\n\nIn Windows, the program can fetch the `CONTEXT via` `GetThreadContext to see if the`\ndebugging registers are used. A great example on how this is implemented can be found\n[here[1]. If you are interested in trying to defeat it by yourself, you can try to beat the](https://www.codeproject.com/Articles/30815/An-Anti-Reverse-Engineering-Guide)\n```\nSection Hashing technique by yourself at root-me.org[2].\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-01-24 - Catching Debuggers with Section Hashing.pdf"
    ],
    "report_names": [
        "2021-01-24 - Catching Debuggers with Section Hashing.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536155,
    "ts_updated_at": 1743041164,
    "ts_creation_date": 1653710468,
    "ts_modification_date": 1653710468,
    "files": {
        "pdf": "https://archive.orkl.eu/6bc9f5e3951cefb084b80479df9e6fa3ea9d5a5a.pdf",
        "text": "https://archive.orkl.eu/6bc9f5e3951cefb084b80479df9e6fa3ea9d5a5a.txt",
        "img": "https://archive.orkl.eu/6bc9f5e3951cefb084b80479df9e6fa3ea9d5a5a.jpg"
    }
}