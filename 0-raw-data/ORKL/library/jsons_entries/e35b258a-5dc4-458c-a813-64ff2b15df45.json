{
    "id": "e35b258a-5dc4-458c-a813-64ff2b15df45",
    "created_at": "2022-10-25T16:48:19.962115Z",
    "updated_at": "2025-03-27T02:11:55.510302Z",
    "deleted_at": null,
    "sha1_hash": "4bfa7e0065fdcedaee712fcf08200bc0233aea09",
    "title": "JPCERT/CC Blog: Decrypting Strings in Emdivi",
    "authors": "",
    "file_creation_date": "2015-11-20T09:43:42Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 256541,
    "plain_text": "**[« A Volatility Plugin Created for Detecting Malware Used in Targeted Attacks | Main](http://blog.jpcert.or.jp/2015/11/a-volatility-plugin-created-for-detecting-malware-used-in-targeted-attacks.html)**\n\n**Nov 19, 2015**\n\n# Decrypting Strings in Emdivi\n\n**Hello, this is You ‘Tsuru’ Nakatsuru at Analysis Center.**\n\n**As introduced in the previous blog post, my colleagues presented on the attacks arising**\n**[in Japan at CODE BLUE 2015, entitled “Revealing the Attack Operations Targeting](http://codeblue.jp/2015/en/)**\n**Japan”.**\n\n**In this entry, I will introduce the details of an IDAPython script**\n**“emdivi_string_decryptor.py”, which JPCERT/CC developed to analyse Emdivi, a remote**\n**control malware. The script was also introduced in our presentation at CODE BLUE 2015.**\n**Please utilize the script along with the codes, etc., that are already published on**\n**JPCERT/CC’s GitHub account.**\n\n**JPCERTCC/aa-tools · GitHub**\n**[https://github.com/JPCERTCC/aa-tools](https://github.com/JPCERTCC/aa-tools)**\n\n**Encrypted Strings within Emdivi**\n\n**Emdivi encrypts strings such as URLs that they connect to and stores them in itself.**\n**Depending on the sample, encrypted strings are Base64-encoded and stored as in Figure**\n**1, or in other cases, just saved in an encrypted binary format.**\n\n**Figure 1: Encrypted strings encoded with Base64**\n\n**In the incident analysis phase, these encrypted strings need to be decrypted in order to**\n**identify information such as URLs that the malware connects to, etc. For this purpose,**\n**JPCERT/CC developed emdivi_string_decryptor.py.**\n\n**Analysis on Emdivi’s Decryption Process**\n\n**Emdivi runs the following process in order to decrypt the strings in itself.**\n\n**Upon its startup, it calculates the key for decryption, based on the following string**\n**information:**\n\n**The sample’s version strings**\n\n**e.g. t17.08.26..3340.4444**\n\n**Random long strings in the sample**\n\n**e.g. jp5cQEhSR7xMEdv1JOjh5eKGsMxSCAE5M57CijC8VgN1KMbBvP9**\n**(Omitted hereafter)**\n\n**It then combines these strings with Base64 encode, MD5 hash value calculation and**\n**others to calculate the decryption key as in Figure 2. Depending on Emdivi’s version, it**\n**sometimes combines addition and other arithmetic process for this calculation.**\n\n\n**R** **E** **C** **E** **N**\n\n**Decrypting Strings in Emdivi**\n\n**[A Volatility Plugin Created for Detecting](http://blog.jpcert.or.jp/2015/11/a-volatility-plugin-created-for-detecting-malware-used-in-targeted-attacks.html)**\n**Malware Used in Targeted Attacks**\n\n**Emdivi and the Rise of Targeted Attacks**\n**in Japan**\n\n**The 5th CERT-RO Annual International**\n**[Conference in Bucharest and Latest](http://blog.jpcert.or.jp/2015/10/the-5th-cert-ro-annual-international-conference-in-bucharest-and-latest-cyber-security-trends-in-romania.html)**\n**Cyber Security Trends in Romania**\n\n**APCERT Annual General Meeting and**\n**Conference 2015 in Kuala Lumpur**\n\n**VPN Servers Altered by Attacker Leading**\n**[to Scanbox, a Reconnaissance](http://blog.jpcert.or.jp/2015/09/vpn-servers-altered-by-attacker-leading-to-scanbox-a-reconnaissance-framework.html)**\n**Framework**\n\n**Enhanced Protected Mode in Internet**\n**Explorer**\n\n**PoisonIvy adapts to communicate**\n**through Authentication Proxies**\n\n**[The 27th FIRST Annual Conference in](http://blog.jpcert.or.jp/2015/07/the-27th-first-annual-conference-in-berlin.html)**\n**Berlin**\n\n**[Protected Mode in Internet Explorer](http://blog.jpcert.or.jp/2015/07/protected-mode-in-internet-explorer.html)**\n\n**C** **A** **T** **E** **G**\n\n**[#APCERT](http://blog.jpcert.or.jp/apcert/)** **[#FIRST](http://blog.jpcert.or.jp/first/)** **[#Incident management](http://blog.jpcert.or.jp/incident_management/)**\n## #JPCERT news #Threats\n**[#Trends in Japan](http://blog.jpcert.or.jp/trends/)** **[#Tsubame](http://blog.jpcert.or.jp/tsubame/)**\n**[#Vulnerabilities](http://blog.jpcert.or.jp/vulnerabilities/)** **[Africa](http://blog.jpcert.or.jp/africa/)** **[India](http://blog.jpcert.or.jp/india/)**\n**[Indonesia](http://blog.jpcert.or.jp/indonesia/)** **[Laos](http://blog.jpcert.or.jp/laos/)** **[Mongolia](http://blog.jpcert.or.jp/mongolia/)** **[Myanmar](http://blog.jpcert.or.jp/myanmar/)**\n**[Pacific Islands](http://blog.jpcert.or.jp/pac/)** **[Sri Lanka](http://blog.jpcert.or.jp/srilanka/)** **[Thailand](http://blog.jpcert.or.jp/thai/)**\n\n**A** **C** **C** **E** **S**\n\n**[A Volatility Plugin Created for Detecting](http://blog.jpcert.or.jp/2015/11/a-volatility-plugin-created-for-detecting-malware-used-in-targeted-attacks.html)**\n**Malware Used in Targeted Attacks**\n\n**Emdivi and the Rise of Targeted Attacks**\n**in Japan**\n\n**Analysis of a Recent PlugX Variant - “P2P**\n**PlugX”**\n\n**[A New UAC Bypass Method that Dridex](http://blog.jpcert.or.jp/2015/02/a-new-uac-bypass-method-that-dridex-uses.html)**\n**Uses**\n\n**Decrypting Strings in Emdivi**\n\n**The 5th CERT-RO Annual International**\n**[Conference in Bucharest and Latest](http://blog.jpcert.or.jp/2015/10/the-5th-cert-ro-annual-international-conference-in-bucharest-and-latest-cyber-security-trends-in-romania.html)**\n**Cyber Security Trends in Romania**\n\n**[APCERT Annual General Meeting and](http://blog.jpcert.or.jp/2015/10/apcert-annual-general-meeting-and-conference-2015-in-kuala-lumpur.html)**\n**Conference 2015 in Kuala Lumpur**\n\n**VPN Servers Altered by Attacker Leading**\n**[to Scanbox, a Reconnaissance](http://blog.jpcert.or.jp/2015/09/vpn-servers-altered-by-attacker-leading-to-scanbox-a-reconnaissance-framework.html)**\n**Framework**\n\n**[PoisonIvy adapts to communicate](http://blog.jpcert.or.jp/2015/07/poisonivy-adapts-to-communicate-through-authentication-proxies.html)**\n**through Authentication Proxies**\n\n**Fiddler Core's insecure Default flag may**\n**lead to Open Proxy Issue**\n\n**L** **I** **N** **K** **S**\n\n**[JPCERT homepage](http://www.jpcert.or.jp/english/)**\n\n**[Follow us @jpcert_en](http://twitter.com/jpcert_en)**\n\n\n-----\n\n**Figure 2: Calculated decryption key**\n\n**Using the decryption key calculated here, Emdivi performs decryption just before it uses**\n**the strings. Processes related to the encryption are implemented as classes. Figure 3**\n**shows information of those classes.**\n\n**Figure 3: Encryption related classes defined within Emdivi**\n\n**Many samples of Emdivi use XxTEA as in Figure 3, but we have confirmed that some**\n**versions use AES. Also, there are some versions that switch the encryption and**\n**decryption process, and we have seen that some use XxTEA encryption process for**\n**decryption.**\n\n**After analysing various samples of Emdivi, we were able to summarise the method for the**\n**decryption key calculation and the decryption process as in Chart 1 below. For details of**\n**the decryption key generation process, please refer to the source codes of**\n**emdivi_string_decryptor.py.**\n\n**Table 1: Decryption process for each Emdivi version**\n\n**t19 and t20 mid** **t20 early and late**\n**t17**\n\n**versions** **versions**\n\n**XxTEA**\n**Decryption process** **XxTEA Encryption** **AES Encryption**\n**Decryption**\n\n**MD5(** **scanf(**\n\n**MD5(base64(ver))** **\"%x%x%x%x\",**\n\n**Method to calculate decryption** **Inc_Add(ver17_key)**\n**key** **+** **Inc_Add(ver17_key)** **[:24]**\n\n**MD5(key_string))** **)**\n\n**Before Using emdivi_string_decryptor.py**\n\n**Since emdivi_string_decryptor.py is an IDAPython script, it requires disassembler IDA for**\n**execution. Also, the version string used when calculating the decryption key is required**\n**for string decryption.**\n\n**Before actually using the tool, you have to obtain the version string from the memory or**\n**communication data.**\n\n**If you are obtaining the string from the memory, execute Emdivi in an analysis**\n**environment and then search for the string in the memory by using debugger, etc. You do**\n**not have to worry about virtual environment detection, since the version string is**\n**generated before the detection process.**\n\n**If you are obtaining the version string from the communication data, you would need to**\n**decode that data. For decoding, you can use emdivi_postdata_decoder.py which is also**\n**made public together with emdivi_string_decryptor.py. Here below is what you will see**\n**when executing by giving the data you want to decode to emdivi_postdata_decoder.py’s**\n**argument.**\n\n\n**A** **R** **C** **H** **I**\n\n**[November 2015](http://blog.jpcert.or.jp/2015/11/)**\n\n**[October 2015](http://blog.jpcert.or.jp/2015/10/)**\n\n**[September 2015](http://blog.jpcert.or.jp/2015/09/)**\n\n**[August 2015](http://blog.jpcert.or.jp/2015/08/)**\n\n**[July 2015](http://blog.jpcert.or.jp/2015/07/)**\n\n**[June 2015](http://blog.jpcert.or.jp/2015/06/)**\n\n**[May 2015](http://blog.jpcert.or.jp/2015/05/)**\n\n**[April 2015](http://blog.jpcert.or.jp/2015/04/)**\n\n**[March 2015](http://blog.jpcert.or.jp/2015/03/)**\n\n**[February 2015](http://blog.jpcert.or.jp/2015/02/)**\n\n**[More...](http://blog.jpcert.or.jp/archives.html)**\n\n**C** **A** **T** **E** **G**\n\n**[#APCERT](http://blog.jpcert.or.jp/apcert/)**\n\n**[#FIRST](http://blog.jpcert.or.jp/first/)**\n\n**[#Incident management](http://blog.jpcert.or.jp/incident_management/)**\n\n**[#JPCERT news](http://blog.jpcert.or.jp/jpcert_news/)**\n\n**[#Threats](http://blog.jpcert.or.jp/threats/)**\n\n**[#Trends in Japan](http://blog.jpcert.or.jp/trends/)**\n\n**[#Tsubame](http://blog.jpcert.or.jp/tsubame/)**\n\n**[#Vulnerabilities](http://blog.jpcert.or.jp/vulnerabilities/)**\n\n**[Africa](http://blog.jpcert.or.jp/africa/)**\n\n**[India](http://blog.jpcert.or.jp/india/)**\n\n**[Indonesia](http://blog.jpcert.or.jp/indonesia/)**\n\n**[Laos](http://blog.jpcert.or.jp/laos/)**\n\n**[Mongolia](http://blog.jpcert.or.jp/mongolia/)**\n\n**[Myanmar](http://blog.jpcert.or.jp/myanmar/)**\n\n**[Pacific Islands](http://blog.jpcert.or.jp/pac/)**\n\n**[Sri Lanka](http://blog.jpcert.or.jp/srilanka/)**\n\n**[Thailand](http://blog.jpcert.or.jp/thai/)**\n\n|Col1|t17|t19 and t20 mid versions|t20 early and late versions|\n|---|---|---|---|\n|Decryption process|XxTEA Decryption|XxTEA Encryption|AES Encryption|\n|Method to calculate decryption key|MD5( MD5(base64(ver)) + MD5(key_string))|scanf( \"%x%x%x%x\", Inc_Add(ver17_key) )|Inc_Add(ver17_key) [:24]|\n\n\n-----\n\n**r13ftV     ->   win7_32JP_SP1-IE11*968**\n**\"yhmsuRvo\"   ->   \"1\"**\n**\"date\" ->   \"9v3r: t17.08.26..3340.4444   |    NT: 6.1.7601  [ja-JP]**\n**|    MEM: 2048M   |    GMT(9)\"**\n\n\n**Please note that the version string included in the communication data may be different**\n**from the string required for the decryption. Therefore, we recommend obtaining the string**\n**from the memory.**\n\n**Executing emdivi_string_decryptor.py**\n\n**If you have obtained the version string, you are all set. Load the target Emdivi into IDA,**\n**and execute emdivi_string_decryptor.py. Then, it will process as follows:**\n\n**1. Input version string**\n**2. Calculate decryption key**\n**3. Search for encrypted string**\n**4. Decrypt string**\n**5. Output results and insert comments in the corresponding section**\n\n**Upon execution of emdivi_string_decryptor.py, the following dialog box appears to input**\n**the version string.**\n\n**Figure 4: Dialog box to input version string**\n\n**After you input the version string, the tool will display the decrypted string in the console,**\n**and it will be inserted as a comment to where the encrypted string is stored. This is shown**\n**in Figure 5.**\n\n**Figure 5: Screenshot after executing emdivi_string_decryptor.py**\n\n**Now you can obtain various information including URLs that the malware connects to.**\n**Based on these and other related pieces of information, JPCERT/CC coordinates and**\n**handles incidents caused by attack operations involving Emdivi.**\n\n**In Summary**\n\n**We hope that the scripts that we made public will contribute in dealing with the attacks**\n**relating to Emdivi, and in improving malware analysis techniques.**\n\n**A blog entry by Kaspersky (see Reference) has revealed that a few versions of Emdivi**\n**use the infected users’ SID. Unfortunately, the current version of**\n**emdivi_string_decryptor.py is not yet adapted to input SID. Furthermore, it is possible that**\n**new versions of Emdivi with other encryption methods may emerge in the future. We**\n**welcome any pull requests on GitHub.**\n\n**Thanks for reading.**\n\n**-You Nakatsuru**\n\n\n-----\n\n**p** **g** **y**\n**apt/**\n\n**[Posted on Nov 19, 2015 in #JPCERT news, #Threats, #Trends in Japan | Permalink](http://blog.jpcert.or.jp/jpcert_news/)**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2015/2015.11.19.decrypting-strings-in-emdivi/ecrypting-strings-in-emdivi.pdf"
    ],
    "report_names": [
        "ecrypting-strings-in-emdivi"
    ],
    "threat_actors": [
        {
            "id": "c92de6de-9538-43e5-9190-9da092194884",
            "created_at": "2022-10-25T16:07:23.411024Z",
            "updated_at": "2025-03-27T02:02:09.785868Z",
            "deleted_at": null,
            "main_name": "Blue Termite",
            "aliases": [
                "Blue Termite",
                "Cloudy Omega"
            ],
            "source_name": "ETDA:Blue Termite",
            "tools": [
                "Emdivi",
                "Newsripper"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "48782737-377b-47b4-aff0-87424208a643",
            "created_at": "2023-01-06T13:46:38.569144Z",
            "updated_at": "2025-03-27T02:00:02.863397Z",
            "deleted_at": null,
            "main_name": "Blue Termite",
            "aliases": [
                "Cloudy Omega",
                "Emdivi"
            ],
            "source_name": "MISPGALAXY:Blue Termite",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716499,
    "ts_updated_at": 1743041515,
    "ts_creation_date": 1448012622,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/4bfa7e0065fdcedaee712fcf08200bc0233aea09.pdf",
        "text": "https://archive.orkl.eu/4bfa7e0065fdcedaee712fcf08200bc0233aea09.txt",
        "img": "https://archive.orkl.eu/4bfa7e0065fdcedaee712fcf08200bc0233aea09.jpg"
    }
}