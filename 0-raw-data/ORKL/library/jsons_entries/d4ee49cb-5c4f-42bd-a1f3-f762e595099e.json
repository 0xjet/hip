{
    "id": "d4ee49cb-5c4f-42bd-a1f3-f762e595099e",
    "created_at": "2023-01-12T15:07:11.196364Z",
    "updated_at": "2025-03-27T02:05:36.57682Z",
    "deleted_at": null,
    "sha1_hash": "6dc24d65b78c854803f32fd673f49823459d7647",
    "title": "Maelstrom EDR Kernel Callbacks Hooks and Call Stacks",
    "authors": "",
    "file_creation_date": "2022-07-12T23:56:28Z",
    "file_modification_date": "2022-07-12T23:56:28Z",
    "file_size": 2332253,
    "plain_text": "# Maelstrom: EDR Kernel Callbacks, Hooks, and Call Stacks\n\n**[pre.empt.dev/posts/maelstrom-edr-kernel-callbacks-hooks-and-callstacks](https://pre.empt.dev/posts/maelstrom-edr-kernel-callbacks-hooks-and-callstacks/)**\n\n## Introduction\n\nTo recap the series so far, we've gone from looking at the high level purposes and intentions\nof a Command and Control Server (C2) in general to designing and implementing our first\niteration of our implant and server. If you've been following along, you might think you've\nwritten a C2...\n\nThis is a common mindset. In our experience, getting to this point does not require much\n_sophistication. All of our previous work could easily be achieved (and has been achieved!)_\nusing C#, Python, Go, in an evening's worth of frenetic caffeine-fuelled typing. Leading\nfeatures of C2s can often be linked to pretty old solved concepts and patterns from software\nengineering, such as thread management, handling idle processes, and ensuring correction\nexecution and program flow.\n\nBut as we found when writing our various C2s, and as numerous other offensive developers\nhave found when writing their own implants and servers, once you have the code working\nand you can get a pingback, you stop running your implant on your development computer\nand try it on a second computer. This is where the questions start creeping in. Questions like\n\"Why can't I access remote files?\", \"Why can I make outbound requests over this protocol,\nbut not this?\", \"Why does this command just fail with no explanation\", and for the cynical\nself-doubter with enough imposter syndrome \"Why isn't Defender stopping me from doing\n_this?\"._\n\nThis, personally, is the post we were looking forward to writing. It's going to be a discussion,\nwith a few examples, of increasing common behaviours within environments with active\nendpoint protection. In 2022, implants face far more scrutiny - the implant and C2 operator\nmust to be prepared to face or evade this scrutiny, and the defender must be aware of how it\nworks so that it can be used to the best of its ability.\n\nWhilst writing this, we also want to clear up the 'it avoids <insert company here> EDR'\ntweets. Just because the implant is able to execute, doesn't mean that Endpoint Protection is\nblind to it - it can mean that, but we want to demonstrate some techniques these solutions\nuse to identify malicious behaviour and raise the suspicion of an implant.\n\nIn a nutshell, proof of execution is not proof of evasion.\n\n## Objectives\n\n\n-----\n\nThis post will cover:\n\n[Setting up The Hunting ELK](https://github.com/Cyb3rWard0g/HELK)\nReviewing three ways EDRs can detect or block malicious execution:\n\nKernel Callbacks\nHooking\nThread Call Stacks\n\nBy the end of this post, we will have covered how modern EDRs can protect against malicious\nimplants, and how these protections can be bypassed. We will move from having an implant\nwhich technically works to an awareness of how to write an implant which actually starts to\nwork, and can achieve the goals of an operator.\n\nAs we've said many times, we are not creating an operational C2. The output from this series\nis poorly written and riddled with flaws - it only does enough to act as a broken proof-ofconcept of the specific items we discuss in this series to avoid this code from being used by\nbad actors. For this same reason, we are trying to avoid discussing Red Team operational\ntactics in this series. However, as we go on, it will become obvious why blending in with the\n[compromised users typical behaviour will work. This is something that xpn has discussed on](https://twitter.com/_xpn_)\nTwitter:\n\nFind Confluence, read Confluence.. become the employee!\n\n— Adam Chester (@_xpn_) [January 22, 2022](https://twitter.com/_xpn_/status/1484970081046126594?ref_src=twsrc%5Etfw)\n\n[If your implant has been flagged by EDR, querying NetSessionEnum on every AD-joined](https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/)\ncomputer to find active sessions is probably not typical user behaviour. You likely will not\nknow your implant has been flagged until it stops responding. From here, it's a race until\n[your implant is uploaded to VirusTotal and you have to go back to the drawing board.](https://virustotal.com/)\n\nWe will be referring to the following programs a lot during this blog:\n\n[The Hunting ELK (HELK): HELK is an Elastic stack best summarised by themselves:](https://github.com/Cyb3rWard0g/HELK)\n\nThe Hunting ELK or simply the HELK is one of the first open source hunt platforms with\nadvanced analytics capabilities such as SQL declarative language, graphing, structured\nstreaming, and even machine learning via Jupyter notebooks and Apache Spark over an ELK\nstack.\n\nThis project was developed primarily for research, but due to its flexible design and core\ncomponents, it can be deployed in larger environments with the right configurations and\nscalable infrastructure.\n\n[PreEmpt: A pseudo-EDR which has the capability to digest EtwTi, memory scanners,](https://mez0.cc/projects/preempt/)\nhooks, and so on. Although, this is not public but code will be shared when necessary.\n\n\n-----\n\nThese two tools will allow us to generate proof-of-concept data when required.\n\n## Important Concepts\n\nSimilar to [Maelstrom: Writing a C2 Implant, we want to have a section dedicated to clearing](https://pre.empt.dev/posts/maelstrom-the-implant/)\nup some topics we feel need some background before moving on.\n\n### What do we mean by Endpoint Detection and Response\n\nEndpoint Detection and Response (EDR) software goes by a number of different acronyms,\nand there may well be distinctions between different companies programs and their\nfunctionality. For the sake of simplicity, we are call all programs that are limited to scanning\nfiles on disk statically \"anti-virus\", and all programs that go further and scan device memory,\nlook at the behaviour of programs while they are running, and responding to threats as they\nhappen \"EDR\"s. These may be called various names, including XDR, MDR, or just plain AV.\n\nThroughout this series, as we have done so far, we will be sticking with \"EDR\".\n\nA good overview of this is CrowdStrike's post \"What is Endpoint Detection and Response\n(EDR)\":\n\nEndpoint Detection and Response (EDR), also referred to as endpoint detection and threat\nresponse (EDTR), is an endpoint security solution that continuously monitors end-user devices\nto detect and respond to cyber threats like ransomware and malware.\n\n[Coined by Gartner’s Anton Chuvakin, EDR is defined as a solution that “records and stores](https://www.gartner.com/reviews/market/endpoint-detection-and-response-solutions)\nendpoint-system-level behaviors, uses various data analytics techniques to detect suspicious\nsystem behavior, provides contextual information, blocks malicious activity, and provides\nremediation suggestions to restore affected systems.”\n\nBecause it's relevant to this post, the next section will look at EDR architecture and\ncomparing EDR behaviours across the various vendors. Without going hugely off-topic, we\nwon't look at a number of also relevant areas, such as how Anti-Virus works, how disk-based\nprotection may work to also stymie your implant execution (if you're still running on disk),\nand how AV and EDR actually goes about scanning files and their behaviours while they are\ndoing so. Turns out, that's like, a whole field of study.\n\n### Common EDR Architecture\n\nWhen discussing endpoint protection, it may help to be somewhat familiar with their\n[architecture. The Symantec EDR Architecture looks something like this:](https://pre.empt.dev/posts/maelstrom-edr-kernel-callbacks-hooks-and-callstacks/Symantec%20EDR%20architecture)\n\n\n-----\n\n[A similar approach can be seen for Defender for Endpoint. Essentially, a device with the](https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/onboarding-endpoint-manager?view=o365-worldwide)\nproduct installed will have an agent which can consist of several drivers and processes, which\ngather telemetry from various aspects of the machine. Through this post and the next, we will\ngo over a few of those.\n\nAs an aside, in a Windows environment, Microsoft inherently have an edge here. While this is\n[currently aimed at \"Large Enterprise\" customers (or at least, we assume, given their price point](https://azure.microsoft.com/en-gb/pricing/details/defender-for-cloud/)\nfor Azure!), Microsoft's Defender and new Defender MDE can both access Microsoft's\nknowledge of ... their own operating system, but also influence the development of new\noperating system functionality. Long-term, it wouldn't be a surprise to see Microsoft Defender\nMDE impact the EDR market in a similar way that Microsoft Defender impacted the anti-virus\nmarket.\n\nThe general gist of all EDR is that telemetry from the agent is sent to the cloud where it's run\nthrough various sandboxes and other test devices, and its behaviour can be further analysed\nby machine and human operators.\n\n\n-----\n\nFor the excessively curious reader, the following links go in to more detail about specific\nvendor approaches to EDR architecture:\n\n### Briefly Reviewing and Comparing EDR Behaviour at a High Level\n\nWithout going hugely off-topic, just as how not every red team assessment is a red team, not\nevery EDR is an EDR.\n\n[The following \"Gartner Magic Quadrant\", from](https://www.gartner.com/en/research/methodologies/magic-quadrants-research) [Gartner's May 2021 Report roughly maps out](https://www.gartner.com/reviews/market/endpoint-detection-and-response-solutions)\n[the EDR landscape. It's worth noting that CrowdStrike's hire of Alex Ionescu (a maintainer](https://www.crowdstrike.com/blog/author/alex-ionescu/)\n[for the Kernel in ReactOS) demonstrates that the current best-in-class EDR's heavily leverage](https://reactos.org/)\nknowledge of internal Windows functionality to maximise their performance:\n\n\n-----\n\nWith so much of EDR functionality relying on implementing the methods we will discuss\nhere such as custom-written direct behaviours like kernel callbacks and hooking, being able\nto quickly implement new Microsoft Windows features and develop your own custom ways of\nreliably interacting with and interrupting malicious processes seems to be the distinguishing\nfeature of a modern EDR from its peers.\n\nAnother metric that EDR Vendors tend to use, especially because the reports are made so\n[public, is the Mitre Enginuity. The](https://mitre-engenuity.org/) [Attack Evaluations is described as thus:](https://mitre-engenuity.org/attackevaluations/)\n\n\n-----\n\nThe MITRE Engenuity ATT&CK® Evaluations (Evals) program brings together product and\nservice providers with MITRE experts to collaborate in evaluating security solutions. The Evals\nprocess applies a [systematic methodology using a threat-informed purple teaming approach to](https://attackevals.mitre-engenuity.org/methodology-overview)\ncapture critical context around a solution’s ability to detect or protect against known adversary\nbehavior as defined by the ATT&CK knowledge base. Results from each evaluation are\nthoroughly documented and openly published.\n\n[For example, with SentinelOne, their results can be seen in: SentinelOne Overview. The](https://sentinelone.com/)\noverview goes through APT scenarios and marks whether or not the technique was detected\nand can be used as a tracker for its \"effectiveness\". However, some have expressed feelings\nonline that this is not a thorough way to determine the effectiveness of the product.\n\nWhen looking at EDRs from a purchasing perspective, there are a few methods of\ndetermining effectiveness and we wanted to briefly highlight them here. The main thing to\nconsider is that some vendors do not necessarily provide more functionality than an antivirus. As with any product, ensure that you purchase the right solution for your businesses\nneeds.\n\n### User-land and Kernel-land\n\nWhen discussing the kernel and user-land model, the following architectural image familiar\nto any Computer Science graduate will be used:\n\nA big majority of user activity will occur at ring 3, User Mode, surprisingly the Kernel\noperates within Kernel Mode.\n\n\n-----\n\n[For more information on this, see Windows Programming/User Mode vs Kernel Mode. A](https://en.wikibooks.org/wiki/Windows_Programming/User_Mode_vs_Kernel_Mode)\nworthwhile note is that cross-over between user mode and kernel mode can and does\nhappen. The following definitions from the previous link summarise the differences between\nthese layers:\n\n_Ring 0 (also known as kernel mode) has full access to every resource. It is the mode in_\nwhich the Windows kernel runs.\nRings 1 and 2 can be customized with levels of access but are generally unused unless\nthere are virtual machines running.\n_Ring 3 (also known as user mode) has restricted access to resources._\n\nAgain, to save this post from being longer than it already is, see the Overview of Windows\nComponents documentation for more detail on the following diagram. However, its simply\nshowing the Windows architecture from processes, services, etc, crossing over to the Kernel.\nWe will cover more on this shortly.\n\n\n-----\n\n[Applications that use the WinAPI will traverse through to the Native API (NTAPI) which](https://en.wikipedia.org/wiki/Native_API)\noperates within Kernel Mode.\n\nAs an example, API Monitor can be used to look at the calls being executed:\n\n\n-----\n\nThe above shows `CreateThread being called and then, subsequently,` `NtCreateThreadEx`\nbeing called shortly after.\n\nWhen a function within KERNEL32.DLL is called, for example `CreateThread, it will make`\n[a subsequent call to the NTAPI equivalent in NTDLL.DLL. For example, CreateThread calls](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread)\n[NtCreateThreadEx. This function will then fill RAX register with the System Service Number](https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtCreateThread.html)\n[(SSN). Finally, NTDLL.dll will then issue a SYSENTER instruction. This will then cause the](https://web.archive.org/web/20210618080941/http://qcd.phys.cmu.edu/QCDcluster/intel/vtune/reference/vc311.htm)\nprocessor to switch to kernel mode, and jumps to a predefined function, called the System\n[Service Dispatcher. The following image is from Rootkits: Subverting the Windows Kernel, in](https://www.oreilly.com/library/view/rootkits-subverting-the/0321294319/)\n[the section on Userland Hooks:](https://flylib.com/books/en/1.242.1.47/1/)\n\n### Drivers\n\nA driver is a software component of Windows which allows the operating system and device\n[to communicate with each other. Here is an example from What is a driver?:](https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/what-is-a-driver-)\n\n\n-----\n\nFor example, suppose an application needs to read some data from a device. The application\ncalls a function implemented by the operating system, and the operating system calls a function\nimplemented by the driver. The driver, which was written by the same company that designed\nand manufactured the device, knows how to communicate with the device hardware to get the\ndata. After the driver gets the data from the device, it returns the data to the operating system,\nwhich returns it to the application.\n\nIn the case of Endpoint Protection, there are a few reasons why drivers are useful:\n\n[The use of Callback Objects which allows for a function to be called if an action occurs.](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/callback-objects)\n[For example, later on we will see the usage of PsSetLoadImageNotifyRoutine which is](https://pre.empt.dev/posts/maelstrom-edr-kernel-callbacks-hooks-and-callstacks/PsSetLoadImageNotifyRoutine)\nthe call-back object for DLLs being loaded.\nAccess to privileged information from Event Tracing for Windows Threat Intelligence\nwhich is only accessible from the Kernel with an ELAM Driver.\n\n### Hooks\n\n**DISCLAIMER: Before moving on, we highly recommend watching** REcon 2015 - Hooking\nNirvana (Alex Ionescu)\nPlease come back to this post after.\n\nAnother common feature of EDR's are the Userland Hooking DLLs. Typically, these are\nloaded into a process on creation, and are used to proxy WinAPI Calls through themselves to\nassess the usage, then redirect onto whichever DLL is being used. As an example, if\n```\nVirtualAlloc was being used, the flow would look something like this:\n\n```\n\n-----\n\nA hook allows for function instrumentation by intercepting WinAPI calls, by placing a `jmp`\ninstruction in place of the function address. This `jmp will redirect the flow of a call. We will`\ntake a look at this in action in the following section. By hooking a function call, it gives the\nauthor the ability to:\n\nAssess arguments\nAllowing Execution\nBlocking Execution\n\nThis isn't an exhaustive list, but should serve to demonstrate the functionality which we will\nbe coming across most when running our implants.\n\nExamples of this in use are:\n\n[Understanding and Bypassing AMSI: Bypass AMSI by hooking the](https://x64sec.sh/understanding-and-bypassing-amsi/) `AmsiScanBuffer`\ncall\n[RDPThief: Intercept and read credentials from RDP](https://github.com/0x09AL/RdpThief)\n[Windows API Hooking: Redirect](https://www.ired.team/offensive-security/code-injection-process-injection/how-to-hook-windows-api-using-c++) `MessageBoxA`\n[Import Address Table (IAT) Hooking: Redirect](https://www.ired.team/offensive-security/code-injection-process-injection/import-adress-table-iat-hooking) `MessageBoxA`\n[Intercepting Logon Credentials by Hooking msv1_0!SpAcceptCredentials: Intercept](https://www.ired.team/offensive-security/credential-access-and-credential-dumping/intercepting-logon-credentials-by-hooking-msv1_0-spacceptcredentials)\nand read credentials from `msv1_0!SpAcceptCredentials`\n\n\n-----\n\n[Protecting the Heap: Encryption & Hooks: Hook](https://mez0.cc/posts/protecting-the-heap/) [RtlAllocateHeap,](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlallocateheap) [RtlReAllocateHeap](http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FMemory%20Management%2FHeap%20Memory%2FRtlReAllocateHeap.html)\n[and RtlFreeHeap to monitor heap allocations](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlfreeheap)\n[LdrLoadDll Hook: Prevent DLLs being loaded](https://gist.github.com/bats3c/59932dfa1f5bb23dd36071119b91af0f)\n\n## Hunting ELK\n\nTo access our kernel callbacks without having to write all of that intimidating logic from\nscratch, we will be using [the] Hunting ELK (HELK):\n\nThe Hunting ELK or simply the HELK is one of the first open source hunt platforms with\nadvanced analytics capabilities such as SQL declarative language, graphing, structured\nstreaming, and even machine learning via Jupyter notebooks and Apache Spark over an ELK\nstack. This project was developed primarily for research, but due to its flexible design and core\ncomponents, it can be deployed in larger environments with the right configurations and\nscalable infrastructure.\n\n[We also use the following script is used from Exploring DLL Loads, Links, and Execution to](https://mez0.cc/posts/exploring-dll-loads/)\nsearch through the `Sysmon logs:`\n```\nparam (\n\n  [string]$Loader = \"\",\n\n  [string]$dll = \"\"\n\n )\n\n$eventId = 7\n\n$logName = \"Microsoft-Windows-Sysmon/Operational\"\n\n$Yesterday = (Get-Date).AddHours(-1)\n\n$events = Get-WinEvent -FilterHashtable @{logname=$logName; id=$eventId ;StartTime =\n$Yesterday;}\n\nforeach($event in $events)\n\n{\n\n  $msg = $event.Message.ToString()\n\n  $image = ($msg|Select-String -Pattern 'Image:.*').Matches.Value.Replace(\"Image:\n\", \"\")\n\n  $imageLoaded = ($msg|Select-String -Pattern\n'ImageLoaded:.*').Matches.Value.Replace(\"ImageLoaded: \", \"\")\n\n  if($image.ToLower().contains($Loader.ToLower()) -And\n$imageLoaded.ToLower().Contains($dll.ToLower()))\n\n  {\n\n    Write-Host Image Loaded $imageLoaded\n\n  }\n\n}\n\n\n## Kernel Callbacks\n\n```\n[Kernel Callbacks, according to Microsoft:](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/callback-objects)\n\n\n-----\n\nThe kernel s callback mechanism provides a general way for drivers to request and provide\nnotification when certain conditions are satisfied.\n\nEssentially, they allow drivers to receive and handle notifications for specific events. From\n[veil-ivy/block_create_process.cpp, here is an implementation of using the](https://gist.github.com/veil-ivy/f736ad22dbc388ca88cbf47ef8ebf69e)\n```\nPsSetLoadImageNotifyRoutine Callback to BLOCK process creation:\n\n```\n\n-----\n\n```\n#include <ntddk.h>\n\n#define BLOCK_PROCESS \"notepad.exe\"\n\nstatic OB_CALLBACK_REGISTRATION obcallback_registration;\n\nstatic OB_OPERATION_REGISTRATION oboperation_callback;\n\n#define PROCESS_CREATE_THREAD (0x0002)\n\n#define PROCESS_CREATE_PROCESS (0x0080)\n\n#define PROCESS_TERMINATE   (0x0001)\n\n#define PROCESS_VM_WRITE    (0x0020)\n\n#define PROCESS_VM_READ    (0x0010)\n\n#define PROCESS_VM_OPERATION  (0x0008)\n\n#define PROCESS_SUSPEND_RESUME (0x0800)\n\nstatic PVOID registry = NULL;\n\nstatic UNICODE_STRING altitude = RTL_CONSTANT_STRING(L\"300000\");\n\n//1: kd > dt nt!_EPROCESS ImageFileName\n\n//+ 0x5a8 ImageFileName : [15] UChar\n\nstatic const unsigned int imagefilename_offset = 0x5a8;\n\nauto drv_unload(PDRIVER_OBJECT DriverObject) {\n\n  UNREFERENCED_PARAMETER(DriverObject);\n\n  ObUnRegisterCallbacks(registry);\n\n}\n\nOB_PREOP_CALLBACK_STATUS\n\nPreOperationCallback(\n\n  _In_ PVOID RegistrationContext,\n\n  _Inout_ POB_PRE_OPERATION_INFORMATION PreInfo\n\n) {\n\n  UNREFERENCED_PARAMETER(RegistrationContext);\n\n  if (strcmp(BLOCK_PROCESS, (char*)PreInfo->Object + imagefilename_offset) == 0) {\n\n    if ((PreInfo->Operation == OB_OPERATION_HANDLE_CREATE))\n\n    {\n\n      if ((PreInfo->Parameters->CreateHandleInformation.OriginalDesiredAccess &\nPROCESS_TERMINATE) == PROCESS_TERMINATE)\n\n      {\n\n        PreInfo->Parameters->CreateHandleInformation.DesiredAccess &=\n~PROCESS_TERMINATE;\n\n      }\n\n      if ((PreInfo->Parameters->CreateHandleInformation.OriginalDesiredAccess &\nPROCESS_VM_READ) == PROCESS_VM_READ)\n\n      {\n\n        PreInfo->Parameters->CreateHandleInformation.DesiredAccess &=\n~PROCESS_VM_READ;\n\n      }\n\n      if ((PreInfo->Parameters->CreateHandleInformation.OriginalDesiredAccess &\nPROCESS_VM_OPERATION) == PROCESS_VM_OPERATION)\n\n      {\n\n        PreInfo->Parameters->CreateHandleInformation.DesiredAccess &=\n~PROCESS_VM_OPERATION;\n\n      }\n\n\n```\n\n-----\n\n```\n      if ((PreInfo >Parameters >CreateHandleInformation.OriginalDesiredAccess &\nPROCESS_VM_WRITE) == PROCESS_VM_WRITE)\n\n      {\n\n        PreInfo->Parameters->CreateHandleInformation.DesiredAccess &=\n~PROCESS_VM_WRITE;\n\n      }\n\n    }\n\n  }\n\n  return OB_PREOP_SUCCESS;\n\n}\n\nVOID\n\nPostOperationCallback(\n\n  _In_ PVOID RegistrationContext,\n\n  _In_ POB_POST_OPERATION_INFORMATION PostInfo\n\n)\n\n{\n\n  UNREFERENCED_PARAMETER(RegistrationContext);\n\n  UNREFERENCED_PARAMETER(PostInfo);\n\n}\n\nextern \"C\" auto DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING\nRegistryPath) -> NTSTATUS {\n\n  UNREFERENCED_PARAMETER(RegistryPath);\n\n  DriverObject->DriverUnload = drv_unload;\n\n  auto status = STATUS_SUCCESS;\n\n  static OB_CALLBACK_REGISTRATION ob_callback_register;\n\n  static OB_OPERATION_REGISTRATION oboperation_registration;\n\n  oboperation_registration.Operations = OB_OPERATION_HANDLE_CREATE;\n\n  oboperation_registration.ObjectType = PsProcessType;\n\n  oboperation_registration.PreOperation = PreOperationCallback;\n\n  oboperation_registration.PostOperation = PostOperationCallback;\n\n  ob_callback_register.Altitude = altitude;\n\n  ob_callback_register.Version = OB_FLT_REGISTRATION_VERSION;\n\n  ob_callback_register.OperationRegistrationCount = 1;\n\n  ob_callback_register.OperationRegistration = &oboperation_registration;\n\n  status = ObRegisterCallbacks(&ob_callback_register, &registry);\n\n  if (!NT_SUCCESS(status)) {\n    DbgPrint(\"failed to register callback: %x \\r\\n\",status);\n\n  }\n\n  return status;\n\n}\n\n```\nIn this instance, `ObRegisterCallbacks is being used to block the creation of` `notepad .`\nAn Endpoint Protection solution may not use it in this way, but its very likely this type of\ncallback will be used as telemetry to determine if malicious activity is occurring.\n\n[In this section, we are going to discuss PsSetLoadImageNotifyRoutine. This callback is](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetloadimagenotifyroutine)\nresponsible for exactly what it says: Sending a notification when an image is loaded into a\n[process. For an example implementation, see Subscribing to Process Creation, Thread](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/subscribing-to-process-creation-thread-creation-and-image-load-notifications-from-a-kernel-driver#code)\n\n\n-----\n\n[Creation and Image Load Notifications from a Kernel Driver.](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/subscribing-to-process-creation-thread-creation-and-image-load-notifications-from-a-kernel-driver#code)\n\n### Triggering the callback\n\nTo understand how `PsSetLoadImageNotifyRoutine works, we need to determine what its`\ntrigger is.\n\nAssuming the following code:\n```\n#include <windows.h>\n\n#include <stdio.h>\n\nint main()\n\n{\n\n  HMODULE hModule = LoadLibraryA(\"winhttp.dll\");\n\n  printf(\"WinHTTP: 0x%p\\n\", hModule);\n\n  return 0;\n\n}\n\n\n```\nWhen `LoadLibraryA is called, the function registers a callback to notify the driver than this`\nhas happened. In order to see this log in HELK, we use the script we mentioned earlier on.\n\nIf we filter for `main.exe, which is the above code, we can see the` `winhttp.dll loaded:`\n\nIn Elastic, we can also use the following KQL:\n```\nprocess_name : \"main.exe\" and event_id: 7 and ImageLoaded: winhttp.dll\n\nevent_original_message holds the whole log:\n\n```\n\n-----\n\n```\nImage loaded:\n\nRuleName: \nUtcTime: 2022-04-29 18:50:10.780\n\nProcessGuid: {3ebcda8b-3362-626c-a200-000000004f00}\n\nProcessId: 6716\n\nImage: C:\\Users\\admin\\Desktop\\main.exe\n\nImageLoaded: C:\\Windows\\System32\\winhttp.dll\n\nFileVersion: 10.0.19041.1620 (WinBuild.160101.0800)\n\nDescription: Windows HTTP Services\n\nProduct: Microsoft® Windows® Operating System\n\nCompany: Microsoft Corporation\nOriginalFileName: winhttp.dll\n\nHashes:\nSHA1=4F2A9BB575D38DBDC8DBB25A82BDF1AC0C41E78C,MD5=FB2B6347C25118C3AE19E9903C85B451,SHA\n\nSigned: true\n\nSignature: Microsoft Windows\n\nSignatureStatus: Valid\n\nUser: PUNCTURE\\admin\n\n```\n[To see what this is doing, we can float through the ReactOS source code:](https://doxygen.reactos.org/index.html)\n\nThis is good to get some familiarity with how this would work. However, in Bypassing Image\nLoad Kernel Callbacks, by [batsec, identifies that the trigger is in NtCreateSection call which is](https://twitter.com/_batsec_)\nthen called in the `LdrpCreateDllSection . So, we don't need to spend too much time`\ndebugging to find this.\n\n### Spoofing Loads\n\nIn the article from batsec, they show that the aforementioned events can be spammed with\nthe following code:\n\n\n-----\n\n```\n#include <stdio.h>\n\n#include <windows.h>\n\n#include <winternl.h>\n\n#define DLL_TO_FAKE_LOAD L\"\\\\??\\\\C:\\\\windows\\\\system32\\\\calc.exe\"\n\nBOOL FakeImageLoad()\n\n{\n\n  HANDLE hFile;\n\n  SIZE_T stSize = 0;\n\n  NTSTATUS ntStatus = 0;\n\n  UNICODE_STRING objectName;\n\n  HANDLE SectionHandle = NULL;\n\n  PVOID BaseAddress = NULL;\n\n  IO_STATUS_BLOCK IoStatusBlock;\n\n  OBJECT_ATTRIBUTES objectAttributes = { 0 };\n\n  RtlInitUnicodeString(\n\n    &objectName,\n\n    DLL_TO_FAKE_LOAD\n\n  );\n\n  InitializeObjectAttributes(\n\n    &objectAttributes,\n\n    &objectName,\n\n    OBJ_CASE_INSENSITIVE,\n\n    NULL,\n\n    NULL\n\n  );\n\n  ntStatus = NtOpenFile(\n\n    &hFile,\n\n    0x100021,\n\n    &objectAttributes,\n\n    &IoStatusBlock,\n\n    5,\n\n    0x60\n\n  );\n\n  ntStatus = NtCreateSection(\n\n    &SectionHandle,\n\n    0xd,\n\n    NULL,\n\n    NULL,\n\n    0x10,\n\n    SEC_IMAGE,\n\n    hFile\n\n  );\n\n  ntStatus = NtMapViewOfSection(\n\n    SectionHandle,\n\n    (HANDLE)0xFFFFFFFFFFFFFFFF,\n\n```\n\n-----\n\n```\n    &BaseAddress,\n\n    NULL,\n\n    NULL,\n\n    NULL,\n\n    &stSize,\n\n    0x1,\n\n    0x800000,\n\n    0x80\n\n  );\n\n  NtClose(SectionHandle);\n\n}\n\nint main()\n\n{\n\n  for (INT i = 0; i < 10000; i++)\n\n  {\n\n    FakeImageLoad();\n\n  }\n\n  return 0;\n\n}\n\n```\nThe following screenshot is also from that blog post:\n\nbatsec identified that by making the call to `NtCreateSection, the event can be spammed`\nwhilst not actually loading a DLL. Similarly, the spoof can be somewhat\n[weaponised/manipulated to do other things by updating the LDR_DATA_TABLE_ENTRY](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntldr/ldr_data_table_entry.htm)\nstruct:\n\n\n-----\n\n```\ntypedef struct _LDR_DATA_TABLE_ENTRY {\n\n  LIST_ENTRY InLoadOrderLinks;\n\n  LIST_ENTRY InMemoryOrderModuleList;\n\n  LIST_ENTRY InInitializationOrderModuleList;\n\n  PVOID DllBase;\n\n  PVOID EntryPoint;\n\n  ULONG SizeOfImage;\n\n  UNICODE_STRING FullDllName;\n\n  UNICODE_STRING BaseDllName;\n\n  ULONG Flags;\n\n  USHORT LoadCount;\n\n  USHORT TlsIndex;\n\n  union {\n\n    LIST_ENTRY HashLinks;\n\n    struct\n\n    {\n\n      PVOID SectionPointer;\n\n      ULONG CheckSum;\n\n    };\n\n  };\n\n  union {\n\n    ULONG TimeDateStamp;\n\n    PVOID LoadedImports;\n\n  };\n\n  PVOID EntryPointActivationContext;\n\n  PVOID PatchInformation;\n\n} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;\n\n```\nIn this example, we will use `CertEnroll.dll for no reason at all:`\n```\nUNICODE_STRING uFullPath;\n\nUNICODE_STRING uFileName;\n\nWCHAR* dllPath = L\"C:\\\\Windows\\\\System32\\\\CertEnroll.dll\";\n\nWCHAR* dllName = L\"CertEnroll.dll\";\n\nRtlInitUnicodeString(&uFullPath, dllPath);\n\nRtlInitUnicodeString(&uFileName, dllName);\n\n\n```\nNow we just need to step through the struct and fill out the required information.\n\nLoad Time:\n```\nstatus = NtQuerySystemTime(&pLdrEntry2->LoadTime);\n\n\n```\n[Load Reason (LDR_DLL_LOAD_REASON):](https://github.com/processhacker/phnt/blob/461f7b6462bb4c81452757232eaaa41b16be59a4/ntldr.h#L87)\n```\npLdrEntry2->LoadReason = LoadReasonDynamicLoad;\n\n\n```\nBecause the Loader needs a module base address, we'll just load shellcode for\n```\n   CALC.EXE here (we'll discuss this part more afterwards):\n\n```\n\n-----\n\n```\nSIZE_T bufSz sizeof(buf);\n\nLPVOID pAddress = VirtualAllocEx(hProcess, 0, bufSz, MEM_COMMIT | MEM_RESERVE,\nPAGE_READWRITE);\n\nmemcpy(pAddress, buf, sizeof(buf));\n\n```\n[Hashed Base Name (RtlHashUnicodeString):](https://pre.empt.dev/posts/maelstrom-edr-kernel-callbacks-hooks-and-callstacks/RtlHashUnicodeString)\n```\npLdrEntry2->BaseNameHashValue = UnicodeToHash(uFileName, FALSE);\n\n\n```\nFill out the rest of the struct:\n```\npLdrEntry2->ImageDll = TRUE;\n\npLdrEntry2->LoadNotificationsSent = TRUE;\n\npLdrEntry2->EntryProcessed = TRUE;\n\npLdrEntry2->InLegacyLists = TRUE;\n\npLdrEntry2->InIndexes = TRUE;\n\npLdrEntry2->ProcessAttachCalled = TRUE;\n\npLdrEntry2->InExceptionTable = FALSE;\n\npLdrEntry2->OriginalBase = (ULONG_PTR)pAddress;\n\npLdrEntry2->DllBase = pAddress;\n\npLdrEntry2->SizeOfImage = 6969;\n\npLdrEntry2->TimeDateStamp = 0;\n\npLdrEntry2->BaseDllName = uFileName;\n\npLdrEntry2->FullDllName = uFullPath;\n\npLdrEntry2->ObsoleteLoadCount = 1;\n\npLdrEntry2->Flags = LDRP_IMAGE_DLL | LDRP_ENTRY_INSERTED | LDRP_ENTRY_PROCESSED |\nLDRP_PROCESS_ATTACH_CALLED;\n\n\n```\nComplete the `DdagNode struct:`\n\n\n-----\n\n```\npLdrEntry2 >DdagNode (PLDR_DDAG_NODE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,\nsizeof(LDR_DDAG_NODE));\n\nif (!pLdrEntry2->DdagNode)\n\n{\n\n  return -1;\n\n}\n\npLdrEntry2->NodeModuleLink.Flink = &pLdrEntry2->DdagNode->Modules;\n\npLdrEntry2->NodeModuleLink.Blink = &pLdrEntry2->DdagNode->Modules;\n\npLdrEntry2->DdagNode->Modules.Flink = &pLdrEntry2->NodeModuleLink;\n\npLdrEntry2->DdagNode->Modules.Blink = &pLdrEntry2->NodeModuleLink;\n\npLdrEntry2->DdagNode->State = LdrModulesReadyToRun;\n\npLdrEntry2->DdagNode->LoadCount = 1;\n\n```\nHere is it in action:\n\nIn the above, `CertEnroll.dll can be seen loaded in the` `spoof-load.exe process.`\nRemember, this is not loaded. The only thing that happened here is that a string for that DLL\nwas passed in. We then told the loader than the base address of the DLL is that of the\nshellcode:\n\n\n-----\n\nLooking at this technique, there are two obvious use cases:\n\nTie the implant base address (C2IMPLANT.REFLECTIVE.DLL) to a legitimate DLL\n(ADVAP32.DLL) causing it to appear less suspicious\nRemove an IOC Library (WinHTTP.DLL) by loading ADVAPI32.DLL but pointing it to\na WinHTTP.DLL base address.\n\n### Bypassing the Callback\n\nWe aren't going to reinvent the wheel here, its explained wonderfully in Bypassing Image\nLoad Kernel Callbacks. Essentially, to cause the callback to not trigger, a full loader needs to\n[be rewritten. The conclusion to that research was DarkLoadLibrary:](https://github.com/bats3c/DarkLoadLibrary)\n\nIn essence, `DarkLoadLibrary is an implementation of` `LoadLibrary that will not trigger`\nimage load events. It also has a ton of extra features that will make life easier during malware\ndevelopment.\n\n[A proof-of-concept usage of this library was taken from DLL Shenanigans.](https://github.com/mez-0/pantry/tree/main/cpp/dll-shenanigans)\n\nLet's inspect it:\n\n\n-----\n\nThen the above 3 commands are ran:\n```\n   dark-loader uses the LOAD_LOCAL_FILE flag to load a disk from disk, as\n   LoadLibraryA does.\n\n```\nThe Image Load logs are searched for Kernel32 to make sure logs were found.\nwinhttp.dll was searched, and nothing returned\n\nTo avoid the call to `NtCreateSection which was identified to be registering the callback,`\nthe section mapping is done with `NtAllocateVirtualMemory or` `VirtualAlloc, as seen`\n[in MapSections().](https://github.com/bats3c/DarkLoadLibrary/blob/047a0b0bf1d655470e0c70e247352bba1a748cbc/DarkLoadLibrary/src/ldrutils.c#L26)\n\n### Kernel Callback Conclusion\n\nObviously, `PsSetLoadImageNotifyRoutine is not the only callback, and there are quite a`\n[few other callbacks readily available. Kernel Callback Functions has a (non-comprehensive!)](https://codemachine.com/articles/kernel_callback_functions.html)\nlist:\n\n\n-----\n\n```\nPsSetCreateProcessNotifyRoutineEx()\n\n```\n\nOne that would be powerful would be `PsSetCreateProcessNotifyRoutineEx() as the`\nnotification for process creation would be crippling for system telemetry. At the time of\nwriting, we are not aware of any research in this space. Although to be totally honest, we\nhaven't looked.\n\n## Hooking and Process Instrumentation\n\nIn this section, we are going to look at some popular, but elementary, hooking techniques.\n\n### Hooking Example\n\nLets look at two examples before looking into some libraries - Manual Hooks in x86 and\nNtSetProcessInformation Callbacks.\n\n**Manual Hooks (x86)**\n\n[Using Windows API Hooking as a x86 example (easier to demonstrate), we can adapt the](https://www.ired.team/offensive-security/code-injection-process-injection/how-to-hook-windows-api-using-c++)\ncode to look something like this:\n\n\n-----\n\n```\n#include <windows.h>\n\n#include <stdio.h>\n\n#define BYTES_REQUIRED 6\n\nint __stdcall HookedMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT\nuType)\n\n{\n\n  printf(\"\\n[ HOOKED MESSAGEBOXA ]\\n\");\n\n  printf(\"-> Arguments:\\n\");\n\n  printf(\" 1. lpText: %s\\n\", lpText);\n\n  printf(\" 2. lpCaption: %s\\n\", lpCaption);\n\n  printf(\" 3. uType: %ld\\n\", uType);\n\n  return 1;\n\n}\n\nvoid PrintHexA(char* data, int sz)\n\n{\n\n  printf(\" -> \");\n\n  for (int i = 0; i < sz; i++)\n\n  {\n\n    printf(\"\\\\x%02hhX\", data[i]);\n\n  }\n\n  printf(\"\\n\");\n\n}\n\nint main()\n\n{\n\n  SIZE_T lpNumberOfBytesRead = 0;\n\n  HMODULE hModule = nullptr;\n\n  FARPROC pMessageBoxAFunc = nullptr;\n\n  char pMessageBoxABytes[BYTES_REQUIRED] = {};\n\n  void* pHookedMessageBoxFunc = &HookedMessageBoxA;\n\n  hModule = LoadLibraryA(\"user32.dll\");\n\n  if (!hModule)\n\n  {\n\n    return -1;\n\n  }\n\n  pMessageBoxAFunc = GetProcAddress(hModule, \"MessageBoxA\");\n\n  printf(\"-> Original MessageBoxA: 0x%p\\n\", pMessageBoxAFunc);\n\n  if (ReadProcessMemory(GetCurrentProcess(), pMessageBoxAFunc, pMessageBoxABytes,\nBYTES_REQUIRED, &lpNumberOfBytesRead) == FALSE)\n\n  {\n\n    printf(\"[!] ReadProcessMemory: %ld\\n\", GetLastError());\n\n    return -1;\n\n```\n\n-----\n\n```\n  }\n\n  printf(\"-> MessageBoxA Hex:\\n\");\n\n  PrintHexA(pMessageBoxABytes, BYTES_REQUIRED);\n\n  printf(\"-> Hooked MessageBoxA: 0x%p\\n\", pHookedMessageBoxFunc);\n\n  char patch[BYTES_REQUIRED] = { 0 };\n\n  memcpy_s(patch, 1, \"\\x68\", 1);\n\n  memcpy_s(patch + 1, 4, &pHookedMessageBoxFunc, 4);\n\n  memcpy_s(patch + 5, 1, \"\\xC3\", 1);\n\n  printf(\"-> Patch Hex:\\n\");\n\n  PrintHexA(patch, BYTES_REQUIRED);\n\n  if (WriteProcessMemory(GetCurrentProcess(), (LPVOID)pMessageBoxAFunc, patch,\nsizeof(patch), &lpNumberOfBytesRead) == FALSE)\n\n  {\n\n    printf(\"[!] WriteProcessMemory: %ld\\n\", GetLastError());\n\n    return -1;\n\n  }\n\n  MessageBoxA(NULL, \"AAAAA\", \"BBBBB\", MB_OK);\n\n  return 0;\n\n}\n\n```\nLets walk through this...\n\nFirst off, `MessageBoxA is in` `User32.dll so we load that:`\n```\nhModule = LoadLibraryA(\"user32.dll\");\n\nif (!hModule)\n\n{\n\n  return -1;\n\n}\n\n\n```\nNext, we need the address of `USER32!MessageBoxA :`\n```\npMessageBoxAFunc = GetProcAddress(hModule, \"MessageBoxA\");\n\n\n```\nWith that address, the bytes can now be read:\n```\nif (ReadProcessMemory(GetCurrentProcess(), pMessageBoxAFunc, pMessageBoxABytes,\nBYTES_REQUIRED, &lpNumberOfBytesRead) == FALSE)\n\n{\n\n  printf(\"[!] ReadProcessMemory: %ld\\n\", GetLastError());\n\n  return -1;\n\n}\n\n```\n\n-----\n\nThis will read the first 6 bytes of the function call which will later be updated to hold a `push`\nto the new function, resulting in a `jmp .`\n\nThe bytes:\n```\n\\x8B\\xFF\\x55\\x8B\\xEC\\x83\n\n\n```\nNow, the patch needs to be built. This is done like so:\n```\nchar patch[BYTES_REQUIRED] = { 0 };\n\nmemcpy_s(patch, 1, \"\\x68\", 1);\n\nmemcpy_s(patch + 1, 4, &pHookedMessageBoxFunc, 4);\n\nmemcpy_s(patch + 5, 1, \"\\xC3\", 1);\n\n\n```\nThe hex produced from this:\n```\n\\x68\\x12\\x12\\xBD\\x00\\xC3\n\n\n```\n[Using defuse.ca to disassemble this, the above can be translated into Assembly:](https://defuse.ca/online-x86-assembler.htm)\n```\n0: 68 12 12 bd 00     push  0xbd1212\n\n5: c3           ret\n\n\n```\nNote that `0x00BD1212 being pushed is the address of the function we want to jump to`\nINSTEAD of the USER32!MessageBoxA call:\n```\nvoid* pHookedMessageBoxFunc = &HookedMessageBoxA;\n\n\n```\nAt this point, the patch is prepared. It's going to replace the first 6 bytes with a `push to the`\nnew address.\n\nThe next thing is to actually write this new address in:\n```\nif (WriteProcessMemory(GetCurrentProcess(), (LPVOID)pMessageBoxAFunc, patch,\nsizeof(patch), &lpNumberOfBytesRead) == FALSE)\n\n{\n\n  printf(\"[!] WriteProcessMemory: %ld\\n\", GetLastError());\n\n  return -1;\n\n}\n\n\n```\nThen, in the disassembly:\n```\n00BB1212 jmp     HookedMessageBoxA (0BB1A80h)\n\n\n```\nA `jmp is added to jump to the new function. Allowing this to run calls the hooked function`\nand the arguments are printed:\n\n\n-----\n\n```\nint __stdcall HookedMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT\nuType)\n\n{\n\n  printf(\"\\n[ HOOKED MESSAGEBOXA ]\\n\");\n\n  printf(\"-> Arguments:\\n\");\n\n  printf(\" 1. lpText: %s\\n\", lpText);\n\n  printf(\" 2. lpCaption: %s\\n\", lpCaption);\n\n  printf(\" 3. uType: %ld\\n\", uType);\n\n  return 1;\n\n}\n\n```\nRunning it:\n\n**NtSetProcessInformation Callbacks**\n\nSetting up the callback is straight forward:\n\n\n-----\n\n```\nPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION InstrumentationCallbackInfo;\n\nInstrumentationCallbackInfo.Version = 0;\n\nInstrumentationCallbackInfo.Reserved = 0;\n\nInstrumentationCallbackInfo.Callback = CALLBACK_FUNCTION_GOES_HERE;\n\nHANDLE hProcess = (HANDLE)-1;\n\nHMODULE hNtdll = GetModuleHandleA(\"ntdll\");\n\nif (hNtdll == nullptr)\n\n{\n\n  return FALSE;\n\n}\n\n_NtSetInformationProcess pNtSetInformationProcess =\nreinterpret_cast<_NtSetInformationProcess>(GetProcAddress(hNtdll,\n\"NtSetInformationProcess\"));\n\nif (pNtSetInformationProcess == nullptr)\n\n{\n\n  return FALSE;\n\n}\n\n\nNTSTATUS Status = pNtSetInformationProcess(hProcess,\n(PROCESS_INFORMATION_CLASS)ProcessInstrumentationCallback,\n&InstrumentationCallbackInfo, sizeof(InstrumentationCallbackInfo));\n\nif (NT_SUCCESS(Status))\n\n{\n\n  return TRUE;\n\n}\n\nelse\n\n{\n\n  return FALSE;\n\n}\n\n```\nWhere the callback function is included as follows:\n```\nInstrumentationCallbackInfo.Callback = CALLBACK_FUNCTION_GOES_HERE;\n\nCALLBACK_FUNCTION_GOES_HERE is a function to use as the callback and then\nProcessInstrumentationCallback is:\n#define ProcessInstrumentationCallback 0x28\n\n\n```\nAn additional point is that by setting the callback to `NULL, any callbacks sent will be`\n[removed. This was documented by modexp in Bypassing User-Mode Hooks and Direct](https://twitter.com/modexpblog)\nInvocation of System Calls for Red Teams.\n\n[This talk was then built on by Secrary and again in Secrary's blog Hooking via](https://github.com/secrary/)\nInstrumentationCallback. The original code from Alex Ionescu can be found in the\n[HookingNirvana repo.](https://github.com/ionescu007/HookingNirvana)\n\n\n-----\n\nBorrowing the hooks from Secrary gives access to the function and return value, giving us the\nfollowing Assembly:\n```\n.code\n\nPUBLIC asmCallback\n\nEXTERN Hook:PROC\n\nasmCallback PROC\n\n  push rax ; return value\n\n  push rcx\n\n  push RBX\n\n  push RBP\n\n  push RDI\n\n  push RSI\n\n  push RSP\n\n  push R12\n\n  push R13\n\n  push R14\n\n  push R15\n\n  ; without this it crashes :)\n\n  sub rsp, 1000h\n\n  mov rdx, rax\n\n  mov rcx, r10\n\n  call Hook\n\n  add rsp, 1000h\n\n  pop R15\n\n  pop R14\n\n  pop R13\n\n  pop R12\n\n  pop RSP\n\n  pop RSI\n\n  pop RDI\n\n  pop RBP\n\n  pop RBX\n\n  pop rcx\n\n  pop rax\n\n  jmp R10\n\nasmCallback ENDP\n\nend\n\n\n```\n**Hook:\nWith the assembly written, we also need to write the function called by the assembly,**\nallowing us to take in all of the provided registers and return their function names:\n\n\n-----\n\n```\nDWORD64 counter 0;\n\nbool flag = false;\n\nEXTERN_C VOID Hook(DWORD64 R10, DWORD64 RAX/* ... */) {\n\n  // This flag is there for prevent recursion\n\n  if (!flag)\n\n  {\n\n    flag = true;\n\n    counter++;\n\n    CHAR buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME] = { 0 };\n\n    PSYMBOL_INFO pSymbol = (PSYMBOL_INFO)buffer;\n\n    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n\n    pSymbol->MaxNameLen = MAX_SYM_NAME;\n\n    DWORD64 Displacement;\n\n    // MSDN: Retrieves symbol information for the specified address.\n\n    BOOLEAN result = SymFromAddr(GetCurrentProcess(), R10, &Displacement,\npSymbol);\n\n    if (result) {\n\n      printf(\"%s => 0x%llx\\n\", pSymbol->Name, RAX);\n\n    }\n\n    flag = false;\n\n  }\n\n}\n\n```\nThen, in `main,` [SymInitialize is called, then the instrumentation is set:](http://10.10.0.46/data-production/pdf_1657670184_c18fe6.html)\n```\nint main()\n\n{\n\n  SymSetOptions(SYMOPT_UNDNAME);\n\n  SymInitialize(GetCurrentProcess(), NULL, TRUE);\n\n  SetInstrumentationCallback();\n\n  return 0;\n\n}\n\n\n```\nRunning this completed example, we can now see all of the function names and return codes:\n\nThe hook could be updated to get access to the arguments for a full analysis, but we didn't\nfeel the need to look into that for this initial proof-of-concept.\n\nOne final mention for this technique is that it can be used to enumerate the the System\n[Service Number (SSN) for a given function call. This was documented by Paranoid Ninja in](https://twitter.com/NinjaParanoid)\n[EtwTi-Syscall-Hook and Release v0.8 - Warfare Tactics, where the hook is significantly](https://github.com/paranoidninja/EtwTi-Syscall-Hook)\nsmaller (at the cost of doing far less):\n\n\n-----\n\n```\nVOID HuntSyscall(ULONG_PTR\nReturnAddress, ULONG_PTR\nretSyscallPtr) {\n\n  PVOID ImageBase = ((EtwPPEB)\n(((_EtwPTEB)(NtCurrentTeb()>ProcessEnvironmentBlock))))>ImageBaseAddress;\n\n  PIMAGE_NT_HEADERS NtHeaders =\nRtlImageNtHeader(ImageBase);\n\n  if (ReturnAddress >=\n(ULONG_PTR)ImageBase &&\nReturnAddress <\n(ULONG_PTR)ImageBase + NtHeaders>OptionalHeader.SizeOfImage) {\n\n    printf(\"[+] Syscall\ndetected: Return address: 0x%X \nSyscall value: 0x%X\\n\",\nReturnAddress, retSyscallPtr);\n\n  }\n\n}\n\n```\nAnd its companion assembly:\n```\nsection .text\n\nextern HuntSyscall\n\nglobal hookedCallback\n\nhookedCallback:\n\n  push rcx\n\n  push rdx\n\n  mov rdx, [r10-0x10]\n\n  call HuntSyscall\n\n  pop rdx\n\n  pop rcx\n\n  ret\n\n\n### Bypassing Userland Hooks\n\n```\nBack in 2019 [Cneelis published Red Team Tactics: Combining Direct System Calls and sRDI](https://twitter.com/Cneelis)\n[to bypass AV/EDR which had a subsequent release of SysWhispers:](https://github.com/jthuraisamy/SysWhispers)\n\n\n-----\n\nSysWhispers provides red teamers the ability to generate header/ASM pairs for any system call\nin the core kernel image (ntoskrnl.exe). The headers will also include the necessary type\ndefinitions.\n\nThen [modexp provided an update which corrected a shortcoming with version 1 and gave us](https://twitter.com/modexpblog)\n[SysWhispers2:](https://github.com/jthuraisamy/SysWhispers2)\n\nThe specific implementation in SysWhispers2 is a variation of @modexpblog’s code. One\ndifference is that the function name hashes are randomized on each generation. [@ElephantSe4l,](https://twitter.com/ElephantSe4l)\n[who had published this technique earlier, has another](https://www.crummie5.club/freshycalls/) [implementation based in C++17 which is](https://github.com/crummie5/FreshyCalls)\nalso worth checking out.\n\n[The main change is the introduction of base.c which is a result of Bypassing User-Mode](https://github.com/jthuraisamy/SysWhispers2/blob/main/data/base.c)\nHooks and Direct Invocation of System Calls for Red Teams.\n\nAnd again, [KlezVirus produced SysWhispers3:](https://twitter.com/KlezVirus)\n\nThe usage is pretty similar to [SysWhispers2, with the following exceptions:](https://github.com/jthuraisamy/SysWhispers2)\n\nIt also supports x86/WoW64\nIt supports syscalls instruction replacement with an EGG (to be dynamically replaced)\nIt supports direct jumps to syscalls in x86/x64 mode (in WOW64 it's almost standard)\nIt supports direct jumps to random syscalls (borrowing [@ElephantSeal's idea)](https://twitter.com/ElephantSe4l/status/1488464546746540042)\n\nA better explanation of these features are better outlined i the blog post SysWhispers is dead,\nlong live SysWhispers!\n\nThis is just one suite of SysCall techniques, there's a whole other technique based on Heavens\nGate.\n\n[See Gatekeeping Syscalls for a breakdown on these different techniques.](https://mez0.cc/posts/gatekeeping-syscalls/)\n\nEVEN THEN! There are more:\n\n[FreshyCalls](https://github.com/crummie5/FreshyCalls)\n[EtwTi-Syscall-Hook](https://github.com/paranoidninja/EtwTi-Syscall-Hook)\n[FireWalker](https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/)\n\nRECAP!\n\nWith the ability to transition into Kernel-Mode, we have the ability to go unseen by the Userland hooks. So, lets build something.\n\n[For our example, we are going to use MinHook:](https://github.com/TsudaKageyu/minhook)\n\nThe Minimalistic x86/x64 API Hooking Library for Windows\n\n\n-----\n\n**The DLL**\n\nSo, this is going to be a DLL which gets loaded into a process and then hooks functionality\nand makes some decision based on its behaviour. Here is `DllMain :`\n```\nBOOL APIENTRY DllMain(HINSTANCE hInst, DWORD reason, LPVOID reserved)\n\n{\n\n  switch (reason)\n\n  {\n\n  case DLL_PROCESS_ATTACH:\n\n  {\n\n    HANDLE hThread = CreateThread(nullptr, 0, SetupHooks, nullptr, 0, nullptr);\n\n    if (hThread != nullptr) {\n\n      CloseHandle(hThread);\n\n    }\n\n    break;\n\n  }\n\n  case DLL_PROCESS_DETACH:\n\n    break;\n\n  }\n\n  return TRUE;\n\n}\n\n\n```\nWhen a `DLL_PROCESS_ATTACH is the load reason, then we create a new thread and point it`\nat our \"main\" function. This is where we initialise minhook, and set up some hooks:\n\n\n-----\n\n```\nDWORD WINAPI SetupHooks(LPVOID param)\n\n{\n\n  MH_STATUS status;\n\n  if (MH_Initialize() != MH_OK) {\n\n    return -1;\n\n  }\n\n  status = MH_CreateHookApi(\n\n    L\"ntdll\",\n\n    \"NtAllocateVirtualMemory\",\n\n    NtAllocateVirtualMemory_Hook,\n\n    reinterpret_cast<LPVOID*>(&pNtAllocateVirtualMemory_Original)\n\n  );\n\n  status = MH_CreateHookApi(\n\n    L\"ntdll\",\n\n    \"NtProtectVirtualMemory\",\n\n    NtProtectVirtualMemory_Hook,\n\n    reinterpret_cast<LPVOID*>(&pNtProtectVirtualMemory_Original)\n\n  );\n\n  status = MH_CreateHookApi(\n\n    L\"ntdll\",\n\n    \"NtWriteVirtualMemory\",\n\n    NtWriteVirtualMemory_Hook,\n\n    reinterpret_cast<LPVOID*>(&pNtWriteVirtualMemory_Original)\n\n  );\n\n  status = MH_EnableHook(MH_ALL_HOOKS);\n\n  return status;\n\n}\n\nMH_Initialize() is a mandatory call, so we start with that. Next, we create 3 hooks:\n   NtAllocateVirtualMemory\n   NtProtectVirtualMemory\n   NtWriteVirtualMemory\n\n```\nHooks are created with the `MH_CreateHookApi() call:`\n```\nMH_STATUS WINAPI MH_CreateHookApi(LPCWSTR pszModule, LPCSTR pszProcName, LPVOID\npDetour, LPVOID *ppOriginal);\n\n\n```\nTo create a hook, 4 things are needed:\n\nModule Name\nFunction Name\nFunction to \"replace\" the desired function\n\n\n-----\n\nSomewhere to store the original function address\n\nBelow is an example:\n```\nMH_STATUS status = MH_CreateHookApi(\n\n  L\"ntdll\",\n\n  \"NtAllocateVirtualMemory\",\n\n  NtAllocateVirtualMemory_Hook,\n\n  reinterpret_cast<LPVOID*>(&pNtAllocateVirtualMemory_Original)\n\n);\nNtAllocateVirtualMemory_Hook() is the function used to replace the original function:\nNTSTATUS NTAPI NtAllocateVirtualMemory_Hook(IN HANDLE ProcessHandle, IN OUT PVOID*\nBaseAddress, IN ULONG_PTR ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG\nAllocationType, IN ULONG Protect)\n\n{\n\n  if (Protect == PAGE_EXECUTE_READWRITE)\n\n  {\n\n    printf(\"[INTERCEPTOR]: RWX Allocation Detected in %ld (0x%p)\\n\",\nGetProcessId(ProcessHandle), ProcessHandle);\n\n    if (BLOCKING)\n\n    {\n\n      return 5;\n\n    }\n\n    else\n\n    {\n\n      return pNtAllocateVirtualMemory_Original(ProcessHandle, BaseAddress,\nZeroBits, RegionSize, AllocationType, Protect);\n\n    }\n\n  }\n\n  else\n\n  {\n\n    return pNtAllocateVirtualMemory_Original(ProcessHandle, BaseAddress,\nZeroBits, RegionSize, AllocationType, Protect);\n\n  }\n\n}\n\n\n```\nThe function is declared exactly the same as `typedef for the function:`\n```\ntypedef NTSTATUS(NTAPI* _NtAllocateVirtualMemory)(IN HANDLE ProcessHandle, IN OUT\nPVOID* BaseAddress, IN ULONG_PTR ZeroBits, IN OUT PSIZE_T RegionSize, IN ULONG\nAllocationType, IN ULONG Protect);\n\n\n```\nThis is so that there are no issues with typing between hooks.\n\nIn the `NtAllocateVirtualMemory_Hook function, the only thing we are checking here is if`\nthe protection type is `PAGE_EXECUTE_READWRITE,` `RWX, because this is commonly a sign of`\nmalicious activity (COMMONLY). If it matches, we just print that we found something.\n\n\n-----\n\nThen, we have a concept of blocking. This simply means that if `BLOCKING is true, then it`\nreturns. If its false, then we return the pointer to the original function, allowing the function\nto execute as the user expects.\n\nIn `NtProtectVirtualMemory, we just check for changes to` `PAGE_EXECUTE_READ as this is`\nthe common protection type to avoid RWX allocations:\n```\nNTSTATUS NTAPI NtProtectVirtualMemory_Hook(IN HANDLE ProcessHandle, IN OUT PVOID*\nBaseAddress, IN OUT PULONG NumberOfBytesToProtect, IN ULONG NewAccessProtection, OUT\nPULONG OldAccessProtection) {\n\n  if (NewAccessProtection == PAGE_EXECUTE_READ) {\n\n    printf(\"[INTERCEPTOR]: Detected move to RX in %ld (0x%p)\\n\",\nGetProcessId(ProcessHandle), ProcessHandle);\n\n    if (BLOCKING)\n\n    {\n\n      return 5;\n\n    }\n\n    else\n\n    {\n\n      return pNtProtectVirtualMemory_Original(ProcessHandle, BaseAddress,\nNumberOfBytesToProtect, NewAccessProtection, OldAccessProtection);\n\n    }\n\n  }\n\n  else\n\n  {\n\n    return pNtProtectVirtualMemory_Original(ProcessHandle, BaseAddress,\nNumberOfBytesToProtect, NewAccessProtection, OldAccessProtection);\n\n  }\n\n\n```\nIn `NtWriteVirtualMemory, no additional checks are made:`\n```\nNTSTATUS NTAPI NtWriteVirtualMemory_Hook(IN HANDLE ProcessHandle, IN PVOID\nBaseAddress, IN PVOID Buffer, IN SIZE_T NumberOfBytesToWrite, OUT PSIZE_T\nNumberOfBytesWritten OPTIONAL)\n\n{\n\n  printf(\"[INTERCEPTOR]: Detected write of %I64u in %ld (0x%p)\\n\",\nNumberOfBytesToWrite, GetProcessId(ProcessHandle), ProcessHandle);\n\n  if (BLOCKING)\n\n  {\n\n    return 5;\n\n  }\n\n  else\n\n  {\n\n    return pNtWriteVirtualMemory_Original(ProcessHandle, BaseAddress, Buffer,\nNumberOfBytesToWrite, NumberOfBytesWritten);\n\n  }\n\n}\n\n\n```\n**The Loader**\n\n\n-----\n\nIn this instance, we have a PE which just calls `LoadLibraryA on the DLL, and then runs a`\nfake injection:\n```\n#include <Windows.h>\n\n#include <stdio.h>\n\nint main()\n\n{\n\n  HMODULE hModule = LoadLibraryA(\"Interceptor.dll\");\n\n  if (hModule == nullptr)\n\n  {\n\n    printf(\"[LOADER] [LOADER] Failed to load: %ld\\n\", GetLastError());\n\n    return -1;\n\n  }\n\n  printf(\"[LOADER] Interceptor.dll: 0x%p\\n\", hModule);\n\n  Sleep(3000);\n\n  CHAR buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n  LPVOID pAddress = VirtualAlloc(nullptr, 8, MEM_COMMIT | MEM_RESERVE,\nPAGE_EXECUTE_READWRITE);\n\n  if (pAddress == nullptr)\n\n  {\n\n    printf(\"[LOADER] VirtualAlloc: %ld\\n\", GetLastError());\n\n    return -1;\n\n  }\n\n  printf(\"[LOADER] Base: 0x%p\\n\", pAddress);\n\n  if (WriteProcessMemory((HANDLE)-1, pAddress, buf, sizeof buf, nullptr) == FALSE)\n\n  {\n\n    printf(\"[LOADER] WriteProcessMemory: %ld\\n\", GetLastError());\n\n    return -1;\n\n  }\n\n  printf(\"[LOADER] Wrote!\\n\");\n\n  if (VirtualProtect(pAddress, sizeof buf, PAGE_EXECUTE_READ, nullptr) == FALSE)\n\n  {\n\n    printf(\"[LOADER] VirtualProtect: %ld\\n\", GetLastError());\n\n    return -1;\n\n  }\n\n  printf(\"[LOADER] Protected!\\n\");\n\n  return 0;\n\n}\n\n\n```\n**Detecting Functionality**\n\nRunning this shows the calls being detected (in a non-blocking mode):\n\n\n-----\n\nIn the screenshot, we can see:\n\nMoves to RX\nRWX Allocations\nWrites of 8 bytes\n\nThis is everything we planned on detecting. So, how would a bypass work here? Well, because\nof a lot of community development, its quite easy in practice. But before that, we need to\ndiscuss User-land and Kernel-land.\n\n**Bypassing the User-land hooks**\n\n[For this example, we are going to use Tartarus Gate. All we have to do is make this one call in](https://github.com/trickster0/TartarusGate)\n```\nwmain :\nLoadLibraryA(\"Interceptor.dll\");\n\n\n```\nAnd then change the payload in `Payload :`\n```\nunsigned char payload[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00 };\n\n\n```\nChecking the loaded modules:\n\n\n-----\n\nThe DLL is loaded..\n\nRunning it, and setting a breakpoint on the thread creation because the payload is junk:\n\nThe above shows minhook being initialised, and then the hooks being enabled. Between this,\nthere is a move to RX. However, it happens before the hooks are set up. So this is likely either\nminhook, or CRT doing something. We did not take the time to check this out.\n\n### Hooking and Process Instrumentation Conclusion\n\nAs we've stated, this isn't a comprehensive review of every potential technique. Another\n[which might specifically be worth exploring is Vectored Exception Handling (VEH). Two](https://docs.microsoft.com/en-us/windows/win32/debug/vectored-exception-handling)\n[examples of this are ethicalchaos's post on In-Process Patchless AMSI Bypass and](https://ethicalchaos.dev/)\n[Countercept's CallStackSpoofer.](https://www.withsecure.com/gb-en/solutions/managed-services/countercept)\n\nAs with Kernel callbacks, this is a live field of study and there's far more to be explored than\nwe have time or space in this post.\n\n## Thread Call Stacks\n\n[Another component of a process which gets interrogated is via the Threads Call Stack. As](https://docs.microsoft.com/en-us/windows/win32/procthread/about-processes-and-threads)\n[detailed in Viewing the Call Stack in WinDbg, the Call Stack is defined as:](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/calls-window)\n\n\n-----\n\nThe call stack is the chain of function calls that have led to the current location of the program\ncounter. The top function on the call stack is the current function, the next function is the\nfunction that called the current function, and so on. The call stack that is displayed is based on\nthe current program counter, unless you change the register context. For more information about\nhow to change the register context, see [Changing Contexts.](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/changing-contexts)\n\nAs the call stack can help determine the intention of a thread, it often undergoes scrutiny to\ndetermine its validity. In this section, we want to demonstrate how the call stack can be used\nto determine malicious behaviour (in a rudimentary example), and then discuss the offensive\nstrategy for handling this.\n\nHere, we have a an implant in Vulpes:\n\nIf we look at the processes (10792) threads, we can see a bunch of threads starting at the\n[elusive TpReleaseCleanupGroupMembers:](https://processhacker.sourceforge.io/doc/nttp_8h.html#afdd240c1c6b4713fdcc5e4701371e04f)\n\nThis is quite common amongst processes, here is an example of `chrome.exe :`\n\n\n-----\n\nAnd then `RuntimeBroker.exe :`\n\n\n-----\n\nThis is a good side-note for attackers. If the implant in question is reliant on masquarading\nas something else, then this needs to be considered. For example, if the implant is operating\nout of browsers such as chrome, then the HTTP should be handled the same way, and then\nentry-point and call stack of the thread should be mimicked.\n\nBack to the Vulpes implant, the call stack is primarily `TpReleaseCleanupGroupMembers`\nwhich is fine. However, if we go through some of the threads, here is the thread responsible\nfor WinHTTP:\n\nAnd here is a generic thread started by the process:\n\n\n-----\n\nThere are a few others, but lets focus on the second example because this is a call stack for a\nthread that will be found in a lot of processes. Lets look at how to programmatically read the\nthread stack and how a spoofed thread base address can look suspicious.\n\nHere is the entry point:\n```\nint main()\n\n{\n\n  DWORD dwProcessId = 10792;\n\n  DWORD dwSussThread = 1996;\n\n  DWORD dwNormalThread = 26084;\n\n  HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);\n\n  SymInitialize(hProcess, NULL, TRUE);\n\n  StackWalkThread(hProcess, dwSussThread);\n\n  SymCleanup(hProcess);\n\n}\n\n\n```\nIn the above, we have two thread IDs.\n```\n   1996 : The spoofed thread\n   26084 : A somewhat normal stack\n\n```\nWith that, we need to write a function to enumerate the call stack of the thread. We can do\nthat with the following code:\n\n\n-----\n\n```\nvoid StackWalkThread(HANDLE hProcess, DWORD dwThreadId)\n\n{\n\n  STACKFRAME64 frame = { 0 };\n\n  CONTEXT context   = { 0 };\n\n  int idx       = 0;\n\n  HANDLE hThread = OpenThread(MAXIMUM_ALLOWED, FALSE, dwThreadId);\n\n  if (!hThread) return;\n\n  context.ContextFlags = CONTEXT_FULL;\n\n  if (GetThreadContext(hThread, &context) == FALSE) return;\n\n  frame.AddrPC.Offset = context.Rip;\n\n  frame.AddrPC.Mode = AddrModeFlat;\n\n  frame.AddrStack.Offset = context.Rsp;\n\n  frame.AddrStack.Mode = AddrModeFlat;\n\n  frame.AddrFrame.Offset = context.Rbp;\n\n  frame.AddrFrame.Mode = AddrModeFlat;\n\n\n  printf(\"# Thread: %ld\\n\\n\", dwThreadId);\n\n  while (StackWalk64(IMAGE_FILE_MACHINE_AMD64, hProcess, hThread, &frame, &context,\nNULL, SymFunctionTableAccess64, SymGetModuleBase64, NULL))\n\n  {\n\n    DWORD64 moduleBase = SymGetModuleBase64(hProcess, frame.AddrPC.Offset);\n\n    DWORD64 offset = 0;\n\n    char symbolBuff[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)] = { 0 };\n\n    PSYMBOL_INFO symbol = (PSYMBOL_INFO)symbolBuff;\n\n    symbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n\n    symbol->MaxNameLen = MAX_SYM_NAME;\n\n    if (SymFromAddr(hProcess, frame.AddrPC.Offset, &offset, symbol))\n\n    {\n\n      printf(\n\n        \"\\\\_ Frame %d\\n\"\n\n        \" |_ Name: %s\\n\"\n\n        \" |_ Address: 0x%p\\n\\n\",\n\n        idx,\n\n        symbol->Name,\n\n        symbol->Address\n\n      );\n\n      idx++;\n\n    }\n\n  }\n\n}\n\n```\n[From the DbgHelp library, we are using:](https://docs.microsoft.com/en-us/windows/win32/debug/debug-help-library)\n\n\n-----\n\n[StackWalk64: Obtains a stack trace.](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-stackwalk64)\n[SyGetModuleBase64: Retrieves the base address of the module that contains the](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symgetmodulebase64)\nspecified address.\n[SymFromAddr: Retrieves symbol information for the specified address.](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symfromaddr)\n\nPointing the code to the normal thread stack:\n\nThis matches what we saw earlier on.\nChanging this to point to the bad\nthread:\n\nThis now shows a different thread stack\nwe haven't seen so far. Looking at frame\n[3, its CreateTimeQueueTimer which](https://docs.microsoft.com/en-us/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-createtimerqueuetimer)\nwas described as the sleep obfuscation\ntechnique in:\n\nAs a disclaimer, this technique has full\n[kudos to Peter Winter-Smith.](https://twitter.com/peterwintrsmith)\n\nSo, programmatically, its easy to find\nout the callstack of a thread. Let's\nexpand this into something completely\nrudimentary that we can start to work\nwith.\n\nFirst, we'll define a hard-coded list of expected\nfunctions that we saw earlier on that we can use\nas an integrity check:\n```\nstd::vector < std::string > expected = {\n\n \"ZwWaitForWorkViaWorkerFactory\",\n\n \"TpReleaseCleanupGroupMembers\",\n\n \"BaseThreadInitThunk\",\n\n \"RtlUserThreadStart\"\n\n};\n\n```\nAnd then an empty one, to track everything we\nfind:\n```\nstd::vector<std::string> found;\n\n\n```\nNow, instead of just printing, lets add all the symbol names into a vector:\n\n\n-----\n\n```\nwhile (StackWalk64(IMAGE_FILE_MACHINE_AMD64, hProcess, hThread, &frame, &context,\nNULL, SymFunctionTableAccess64, SymGetModuleBase64, NULL))\n\n{\n\n  DWORD64 moduleBase = SymGetModuleBase64(hProcess, frame.AddrPC.Offset);\n\n  DWORD64 offset = 0;\n\n  char symbolBuff[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)] = { 0 };\n\n  PSYMBOL_INFO symbol = (PSYMBOL_INFO)symbolBuff;\n\n  symbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n\n  symbol->MaxNameLen = MAX_SYM_NAME;\n\n  if (SymFromAddr(hProcess, frame.AddrPC.Offset, &offset, symbol))\n\n  {\n\n    found.push_back(symbol->Name);\n\n    printf(\n\n      \"\\\\_ Frame %d\\n\"\n\n      \" |_ Name: %s\\n\"\n\n      \" |_ Address: 0x%p\\n\\n\",\n\n      idx,\n\n      symbol->Name,\n\n      symbol->Address\n\n    );\n\n    idx++;\n\n  }\n\n}\n\n```\nOnce the code has ran, and found all the symbols, lets see if the vectors match:\n```\nif (std::equal(expected.begin(), expected.end(), found.begin()))\n\n{\n\n  printf(\"[ CLEAN ]\\n\");\n\n}\n\nelse\n\n{\n\n  printf(\"[ DIRTY ]\\n\");\n\n}\n\n\n```\nPointing this at the good thread:\n\nWe get the `CLEAN message. And then the dirty thread:`\n\nObviously, this code isn't production ready and the nuances of writing this kind of logic\nproperly is extremely challenging. However, it is something that some EDR vendors are\nstarting to pick up. Given the increase into research to confuse and blind endpoint\nprotection, this is a good technique to have in the arsenal for both the blue and red teams.\n\nSpeaking of red teams, research into correcting this thread-mishap has already been ongoing.\n\n\n-----\n\nThis technique was first popularized by\n[Peter Winter-Smith, who is a common](https://twitter.com/peterwintrsmith)\nreoccurrence in this space, and then\n[reinterpreted by mgeeky in](https://twitter.com/mariuszbit)\n[ThreadStackSpoofer. However, this proof-](https://github.com/mgeeky/ThreadStackSpoofer)\nof-concept sets the return address to 0,\nremoving references to memory addresses\nfor shellcode injection.\n\nThis is an example implementation for\n_Thread Stack Spoofing technique aiming_\nto evade Malware Analysts, AVs and\nEDRs looking for references to\nshellcode's frames in an examined\nthread's call stack. The idea is to hide\nreferences to the shellcode on thread's\ncall stack thus masquerading allocations\ncontaining malware's code.\n\nIf we remove the sleep masking from Vulpes,\nhere is how the call stack looks:\n\n\n-----\n\nThe technique would aim to mask these addresses by storing the return address into a\nvariable, setting the return address to 0, and then restoring the return address.\n\nFor a quick code example from the above repository:\n```\nvoid WINAPI MySleep(DWORD _dwMilliseconds)\n\n{\n\n  [...]\n\n  auto overwrite = (PULONG_PTR)_AddressOfReturnAddress();\n\n  const auto origReturnAddress = *overwrite;\n\n  *overwrite = 0;\n\n  [...]\n\n  *overwrite = origReturnAddress;\n\n}\n\n\n```\n[In a more recent project, CallStackSpoofer by William Burgess was produced to take this a](https://github.com/countercept/CallStackSpoofer)\nstep further and fully mask the stack.\n\n[See: Spoofing Call Stacks to confused EDRs](https://labs.withsecure.com/blog/spoofing-call-stacks-to-confuse-edrs)\n\nBy using predefined vectors of stacks, the project is able to mimic:\n\nWMI\nRPC\nSVCHost\n\n[An example of a predefined vector for WMI:](https://github.com/countercept/CallStackSpoofer/blob/076672e29ee68086a607d9f0bde2cd22754c3ac1/VulcanRaven/VulcanRaven.cpp#L119)\n\n\n-----\n\n```\nstd::vector<StackFrame> wmiCallStack\n\n{\n\n  StackFrame(L\"C:\\\\Windows\\\\SYSTEM32\\\\kernelbase.dll\", 0x2c13e, 0, FALSE),\n\nStackFrame(L\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\CorperfmonExt.dll\",\n0xc669, 0, TRUE),\n\nStackFrame(L\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\CorperfmonExt.dll\",\n0xc71b, 0, FALSE),\n\nStackFrame(L\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\CorperfmonExt.dll\",\n0x2fde, 0, FALSE),\n\nStackFrame(L\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\CorperfmonExt.dll\",\n0x2b9e, 0, FALSE),\n\nStackFrame(L\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\CorperfmonExt.dll\",\n0x2659, 0, FALSE),\n\nStackFrame(L\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\CorperfmonExt.dll\",\n0x11b6, 0, FALSE),\n\nStackFrame(L\"C:\\\\Windows\\\\Microsoft.NET\\\\Framework64\\\\v4.0.30319\\\\CorperfmonExt.dll\",\n0xc144, 0, FALSE),\n\n  StackFrame(L\"C:\\\\Windows\\\\SYSTEM32\\\\kernel32.dll\", 0x17034, 0, FALSE),\n\n  StackFrame(L\"C:\\\\Windows\\\\SYSTEM32\\\\ntdll.dll\", 0x52651, 0, FALSE),\n\n};\n\n```\nBy implementing this type of technique, it will make it extremely difficult to implement the\ncallstack integrity checking we showed earlier (granted our demo was hard-coded values, but\nthe point still stands).\n\n## Conclusion\n\nThis was a fairly long post in which we tried to provide some clarity into the mechanisms\nEDRs can use to not only identify malicious activity, but prevent it. Along the way we've\ndiscussed common pitfalls and some enhancements that can be made to protect against the\nbypasses.\n\nWhilst doing this, we've tried to shed more light onto the 'X bypasses EDR' narrative in\nwhich, yes, the beacon might have comeback but there is likely logs of the activity.\n\nThe next episode will look at ETW and AMSI!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/AV Tech/Maelstrom EDR Kernel Callbacks Hooks and Call Stacks.pdf"
    ],
    "report_names": [
        "Maelstrom EDR Kernel Callbacks Hooks and Call Stacks.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536031,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1657670188,
    "ts_modification_date": 1657670188,
    "files": {
        "pdf": "https://archive.orkl.eu/6dc24d65b78c854803f32fd673f49823459d7647.pdf",
        "text": "https://archive.orkl.eu/6dc24d65b78c854803f32fd673f49823459d7647.txt",
        "img": "https://archive.orkl.eu/6dc24d65b78c854803f32fd673f49823459d7647.jpg"
    }
}