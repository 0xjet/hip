{
    "id": "5ab33b36-8284-486e-be6b-5e7fc59966f3",
    "created_at": "2023-05-06T02:09:11.184112Z",
    "updated_at": "2025-03-27T02:09:29.619893Z",
    "deleted_at": null,
    "sha1_hash": "364bd754656f2cb471781bfae3dd1b5af5b29bfa",
    "title": "2023-04-10 - Redline Stealer - Static Analysis and C2 Extraction",
    "authors": "",
    "file_creation_date": "2023-05-05T01:55:42Z",
    "file_modification_date": "2023-05-05T01:55:42Z",
    "file_size": 7827991,
    "plain_text": "# Redline Stealer - Static Analysis and C2 Extraction\n\n**[embee-research.ghost.io/redline-stealer-basic-static-analysis-and-c2-extraction/](https://embee-research.ghost.io/redline-stealer-basic-static-analysis-and-c2-extraction/)**\n\nMatthew April 10, 2023\n\n[Ghidra\nFeatured](https://embee-research.ghost.io/tag/ghidra/)\nDeep dive analysis of a redline stealer sample. I will use manual analysis to extract C2\ninformation using a combination of Ghidra and x32dbg\n\nDeep-dive analysis of a packed Redline Stealer sample. Utilising manual analysis and semiautomated string decryption to extract C2 information and ultimately identify the malware.\n\n\n-----\n\nIn this write-up, I intentionally try to touch on as many concepts as possible in order to\ndemonstrate practical applications and hopefully provide a better learning experience for the\nreader.\n\n**Quick Caveat**\n\n_[I realized after the initial post that this sample is actually Amadey Bot. The analysis and](https://malpedia.caad.fkie.fraunhofer.de/details/win.amadey?ref=embee-research.ghost.io)_\n_RE techniques remain equally relevant, but the sample is not actually Redline as the_\n_title suggests :)_\n\n[(There is a second file in the .cab which contains Redline Stealer, which may explain](https://malpedia.caad.fkie.fraunhofer.de/details/win.redline_stealer?ref=embee-research.ghost.io)\nwhy the initial file was semi-incorrectly marked as Redline)\n\nI was able to determine this by researching the decrypted strings that are detailed at\nthe end of the post.\n\nIf you're interested in how to use decrypted strings to identify or confirm a malware\nfamily. Jump to the bonus section \"Utilising Decrypted Strings To Identify the Malware\n_Family\" of this blog._\n\n### Link Sample\n\n[The initial file can be downloaded from Malware Bazaar with SHA256: .](https://bazaar.abuse.ch/sample/449d9e29d49dea9697c9a84bb7cc68b50343014d9e14667875a83cade9adbc60/?ref=embee-research.ghost.io)\n```\n449d9e29d49dea9697c9a84bb7cc68b50343014d9e14667875a83cade9adbc60\n\n## Analysis Summary\n\n```\nFeel free to jump to certain sections if you are already comfortable with some of these\nconcepts.\n\nSaving the file and extracting the initial .exe\nUsing Entropy to identify that the initial .exe is packed\nUsing a debugger to manually unpack the first payload\nInitial analysis of the unpacked payload\nIdentifying interesting strings and imports\nStatic Analysis to establish context of interesting strings and imports\nUtilising a debugger to analyse the String Decryption function\nAutomating the String Decryption using X32dbg\nUtilising Decrypted strings to identify the malware family.\n\n## Actual Analysis\n\nThe analysis can kick off by downloading the above file and transferring it into a safe\n[analysis machine. (I strongly recommend and personally use FLARE-VM for analysis)](https://www.mandiant.com/resources/blog/flare-vm-the-windows-malware?ref=embee-research.ghost.io)\n\n\n-----\n\nThe file can be extracted with the password infected.\n\nUnzipping the file with the password \"infected\"\nAfter successful extraction - [detect-it-easy can be used to perform an initial analysis of the](https://www.youtube.com/watch?v=FB_e1mIhykk&ref=embee-research.ghost.io)\nfile.\n\nThis reveals that the file is a 32 bit executable. Which in this case is actually a Microsoft\nCabinet file. This is essentially a .zip that can be executed as a .exe file.\n\nInitial Malware Analysis using Detect-it-easy\nThe file is similar enough to a .zip that 7-zip is able to extract the contents of the file just\nlike a regular zip file.\n\nI was able to use 7zip to extract the contents, creating two new exe's in the process. These\nare si684017.exe and un007241.exe in the screenshot below.\n\n\n-----\n\nAdditional files after extracting initial .cab.\nFor now, I'll focus on the si684017.exe file.\n\n## Initial Executable File\n\nThe initial is file recognized as a 32-bit exe file by detect-it-easy.\n\nInterestingly - it was not a .NET as most [Infostealers generally are. This means that the](https://www.malwarebytes.com/blog/threats/info-stealers?ref=embee-research.ghost.io)\nusual DnSpy won't be applicable here.\n\n[(Check out my analysis of dcrat for tips on using Dnspy)](https://embee-research.ghost.io/dcrat-manual-de-obfuscation/)\n\nInitial file analysis using Detect-it-easy\n[During initial analysis, I always want to determine if the file is potentially a packed loader](https://www.oreilly.com/library/view/practical-malware-analysis/9781593272906/ch02s04.html?ref=embee-research.ghost.io)\nrather than a final payload. If I have reason to suspect a packed payload, I typically focus on\nunpacking rather than strings or other static analysis.\n\nA packed sample will typically contain areas of significantly high entropy.\n\n\n-----\n\nTo determine areas of entropy - I utilized the Entropy Graph feature within Detect-it-easy.\n\nMalware Entropy Analysis Using Detect-it-easy\nThis revealed a very area of high entropy within the file. This is a strong indicator that the file\nis a packed loader and not the final payload.\n\nIn situations like this - I proceed to focus on unpacking the file.\n\nSince this is a \"regular\" exe file and not a .NET-based file - I proceeded to unpack the file\nusing X32dbg.\n\n## Unpacking Using X32dbg\n\nWhen a standard-exe-based loader unpacks a file, it typically uses a combination of\n```\nVirtualAlloc, VirtualProtect and CreateThread. These functions allow the malware to\n\n```\nallocate new sections of memory that can be used to store and execute the unpacked\npayload.\n\n\n-----\n\nAdvanced malware will heavily obfuscate these functions and/or avoid using them\ncompletely. But in 90% of cases - the previously mentioned functions are relevant.\n\n(Check out my [blog on API hashing for how this obfuscation can be done)](https://www.huntress.com/blog/hackers-no-hashing-randomizing-api-hashes-to-evade-cobalt-strike-shellcode-detection?ref=embee-research.ghost.io)\n\nIn most malware - We can set breakpoints on the VirtualAlloc and VirtualProtect\n[function calls and monitor the results using Hardware Breakpoints . This will alert when the](https://stackoverflow.com/questions/8878716/what-is-the-difference-between-hardware-and-software-breakpoints?ref=embee-research.ghost.io)\nnewly allocated buffer is accessed, from there it is generally simple to obtain the decoded\npayload.\n\nTo summarise this:\n\nIdentify a Function of Interest (In this case VirtualAlloc)\nCreate a breakpoint to monitor VirtualAlloc\nObtain the Memory Buffer created by VirtualAlloc\nUse a Hardware Breakpoint - to alert when the new memory buffer is accessed\nAllow the malware to execute until the buffer is filled\nSave the buffer to a file\n\nI've previously written a thread on how to use Hardware Breakpoints to unpack Cobalt Strike\nLoaders. You can check it out [here.](https://twitter.com/embee_research/status/1568910991244820481?lang=en&ref=embee-research.ghost.io)\n\n### Loading the File into X32dbg\n\n[To initiate this process - I dragged the file into a debugger (x32dbg) and allowed the file to](https://x64dbg.com/?ref=embee-research.ghost.io)\n[execute until the Entry Point. This can be done by loading the file and once clicking the F9](https://stackoverflow.com/questions/3745672/about-the-entry-point-of-pe-in-windows?ref=embee-research.ghost.io)\nbutton.\n\nViewing the Entrypoint using a Debugger (x32dbg)\n\n### Creating The Breakpoints\n\n\n-----\n\nBreakpoints were then required in order to inspect the appropriate VirtualAlloc function.\n\nNote that in this case - the primary interest is in the output (or return value) of\n```\n  VirtualAlloc. The relevance of this is that we care about the data at the \"end\" of the\n\n```\nbreakpoint, and not at the moment where the breakpoint is hit.\n\nIf that's confusing then let's just see it in action (it's always confusing the first dozen times)\n\nSet two breakpoints using the following commands\n```\nbp VirtualAlloc, bp VirtualProtect\n\n```\nSetting a breakpoint on VirtualAlloc using x32dbg\nHit F9 (Continue) again, allowing the malware to execute until a breakpoint is hit.\n\nA breakpoint is immediately hit on the VirtualAlloc function\n\nTriggering a breakpoint on VirtualAlloc\nThe primary purpose of VirtualAlloc is to allocate memory and return an address to the\nnewly allocated buffer. This newly allocated memory is contained in the EAX register when\nthe function is completed.\n\nTLDR: Since I'm only interested in that buffer - I utilized the Execute Until Return or\n```\nCTRL+F9 to jump straight to the end of the function and obtain the result.\n\n```\n\n-----\n\nHow to \"Execute Until Return\"\n\nusing x32dbg\nAllowing the malware to Execute Until Return - provides an EAX register containing the\naddress of the memory buffer to be used by the malware.\n\n\n-----\n\nViewing the memory buffer returned by VirtualAlloc\n\nThere is nothing particularly special about EAX, it is just the standard register used for\nreturning the results of a function.\n\nTo learn more about EAX and calling conventions - there's a great video on that from\n[OALABS.](https://www.youtube.com/watch?v=9lzW0I9_cpY&ref=embee-research.ghost.io)\n\nTo monitor the buffer returned by VirtualAlloc, Right-Click on the returned address\n```\n02250000 address and select Follow in Dump.\n\n```\nThis will cause the bottom-left window to display the newly-allocated memory.\n\nThe buffer of memory currently contains all 00's, as nothing has used or written to the buffer\nyet.\n\nUsing x32dbg (Follow In Dump) to view the contents of a memory buffer\n\n\n-----\n\nIt is important to be notified when that buffer of 00 s is no longer a buffer of 00 s.\n\nTo achieve this - A hardware breakpoint can be applied on the first byte of the newly\nallocated buffer.\n\nSetting a Hardware Breakpoint Using x32dbg\n\nSuccessful\n\ncreation of a Hardware Breakpoint\nOnce the hardware breakpoint is set - the malware can continue to execute using the F9\nbutton.\n\nThe Hardware Breakpoint will immediately be triggered.\n\n\n-----\n\nTriggering a Hardware Breakpoint using X32dbg\nOnce this happens, use CTRL+F9 (Execute Until Return, aka \"just finish what you're doing\nnow, but don't do anything else\") to allow the malware to continue writing to the buffer without\nactually executing it.\n\n(Utilising CTRL+F9 will cause the malware to stop at the end of the current function preventing the execution of the rest of the malware)\n\nOnce the current function is finished - the buffer will look something like this.\n\nIdentifying a Memory Buffer containing Shellcode\nUnfortunately - the first buffer does not contain an unpacked PE file. It does contain a large\nbuffer of shellcode which is used to unpack the next section using another VirtualAlloc.\n\n\n-----\n\nIf the file was sucessfully unpacked - it would typically look something more akin to this\n\nIdentifying an unpacked PE file in a memory buffer\n\nIn this case there is only shellcode in the buffer. You can typically determine that the buffer is\nshellcode by the presence of the EB (jmp) byte. You can also confirm suspected shellcode by\ninspecting the instruction using Right-Click -> Follow in Disassembler.\n\nIf the code disassembles without errors (No glaring red sections) - it is highly likely to be\nshellcode.\n\nUsing x32dbg to validate shellcode contained in a memory buffer\nAt this stage - the shellcode could be dumped into a file for further analysis.\n\nHowever, It is often better to allow the shellcode to execute. Malicious actions taken by the\nshellcode will often trigger the same breakpoints intended for the \"original\" malware.\n\n## Obtaining The Unpacked Payload\n\nHitting F9 (Continue) to allow the malware to execute - another breakpoint is hit on\n```\nVirtualAlloc\n\n```\n\n-----\n\nViewing VirtualAlloc function in a debugger (x32dbg)\nUsing the same trick of Execute Until Return, Select EAX and Right-Click -> Follow\n```\nin Dump, the second allocated buffer can be obtained.\n\n```\nUsing x32dbg to locate another memory buffer returned by VirtualAlloc\nAnother Hardware Breakpoint will need to be set at the start of the buffer.\n\n\n-----\n\nCreating another Hardware Breakpoint on the memory address\nAllowing the malware to continue to execute - the hardware breakpoint is hit. This time\ncontaining a promising M. (First half on an [MZ header)](https://subscription.packtpub.com/book/security/9781789610789/4/ch04lvl1sec57/mz-header?ref=embee-research.ghost.io)\n\n(Side note that my debugger suddenly crashed here and had to be restarted - hence the\nslight change of address in future screenshots)\n\n\n-----\n\nMemory buffer - potentially containing an unpacked pe-file payload\nAllowing the malware to continue to execute - A complete MZ/PE file can be found. At this\npoint, the unpacked file has been successfully loaded into memory.\n\nA complete Pe-file written to the memory buffer\n**Saving the Unpacked File**\n\nTo save the unpacked file - Right-Click on the start address and select Follow in Memory\n```\nMap\n\n```\n\n-----\n\nHow\n\n\n-----\n\nto save a memory buffer using x32dbg\nThis will reveal the location where the buffer was allocated. The entire memory buffer can\nthen be saved by using Right-Click and Dump Memory to File\n\nUsing Memory Map to save a specific memory section in x32dbg\n\nThe final\n\nbutton used to dump the memory to a file using x32dbg\nThe file can now be saved as unpacked.bin (or any other file name of choosing)\n\nSpecifying a name for the unpacked file\n\n## Initial Analysis - Unpacked Payload\n\nThe file is a 32-bit executable with no (recognized) packers or obfuscation.\n\n\n-----\n\nInitial analysis of suspected unpacked payload using detect-it-easy\n\nThe entropy graph does not contain any areas of significantly high or flat entropy suggesting that the file is not packed and does not contain any additional payloads.\n\n\n-----\n\nAdditional Entropy Analysis - Suggesting no hidden payloads - No significant areas of\nentropy\nSince this was potentially a final payload - I checked the strings for any unobfuscated\ninformation.\n\nThis revealed some base64 encoded data - but I wasn't able to successfully decode it.\n\n\n-----\n\nThe base64 encoding has likely been combined with additional obfuscation.\n\nBase64 Encoded Strings contained within the malware file\nFailing to decode the \"base64\"\n\nCyberchef - Failure to decode the base64 strings - signs of additional obfuscation\n\n\n-----\n\n## Import Analysis\n\nImported functions are an additional valuable source of information. Especially for suspected\nunpacked files.\n\nThe imported functions referenced capability that suggested the file can download data and\nmake internet connections.\n\nSince these functions need C2 information in order to work, this is a good sign that the C2\nconfig may be contained within this file.\n\nMalware Import Analysis Using Detect-it-easy\n\n## Ghidra Analysis\n\nAt this point I decided to analyze the file further using Ghidra. My plan was to utilise Ghidra\nto gather more information on the suspicious imports related to c2 connections\n```\nInternetReadFile, InternetConnectA, HttpSendRequestA etc.\n\n```\nIn addition to this - I wanted to investigate the suspicious \"base64\" strings identified with\ndetect-it-easy.\n\nTo investigate both - I intended to utilise cross references or X-refs to observe where the\nstrings and imports were used throughout the code. From here I hoped to find arguments\npassed to the internet functions (hopefully containing a C2), or to find the logic behind the\nfunction that accesses the base64 encoded strings.\n\n\n-----\n\nTo Summarise - My plan was to Utilise Ghidra to...\n\nInvestigate the suspicious strings - which function are they passed to? what does that\nfunction do with them? Can I trace the input and output of that function?\nInvestigate Suspicious Imports - Check where the imports were used, and what\narguments were being passed. Can I set a breakpoint and view the decrypted C2's?\n\n### String Searching with Ghidra\n\nI took the first approach first, using Ghidra to search for strings within the file.\n\nSearching for Strings Using Ghidra\nBy filtering on ==, I was quickly able to narrow the results down to the previously identified\nbase64 strings. This was not all relevant strings but was a solid starting point.\n\n\n-----\n\nLocating base64 strings using Ghidra\nI double clicked on one of the larger strings, taking me to it's reference within the file.\n\nFrom here I could hit CTRL+SHIFT+F to find references to this string. Alternatively you could\n```\nRight Click -> References -> Show References to Address\n\n```\nUsing Ghidra to locate Cross-references from strings\nClicking on the one available reference - reveals an undefined function acting upon the\nstring.\n\n\n-----\n\nEncountering an Undefined Function in Ghidra\nBy clicking on the first address of the function and hitting F, we can define a function at the\ncurrent address.\n\nDefining a Function in Ghidra\nAfter defining a function - the decompiler output now looks much cleaner.\n\nViewing a new function in Ghidra - an obfuscated string can be seen\nFrom here we can enter the function at FUN_00414550 and investigate.\n\nThe function contains a bunch of c++ looking junk which was difficult to analyse - so I\ndecided to take a slightly different approach.\n\n\n-----\n\nViewing a suspicious function using Ghidra\nI checked the number of cross references on the FUN_00414550 function. A high number of\ncross references would indicate that the function is responsible for decoding more than just\nthis encoded string.\n\nIf the same function is used for all string related decryption, then perhaps a debugger and a\nbreakpoint is the better approach.\n\nAt minimum - a debugger will at least confirm the theory that this function is related to string\ndecryption.\n\n## String Decryption Via X32dbg\n\nI decided to investigate the string decryption using X32dbg.\n\nTo do this - I would need to set a breakpoint on the function that I suspected was responsible\nfor string decryption.\n\nAttempting to copy-and-paste the address directly from Ghidra will likely result in an error as\nthe addresses may not align.\n\n### Syncing Addresses with Ghidra and X32dbg\n\n\n-----\n\nTo Sync the Addresses between Ghidra and X32dbg. We need to find the base of our current\nfile. This can be found in the memory map and in this case is 003e0000. Although it may be\ndifferent for you.\n\nHow to identify a base address in a debugger (x32dbg)\nFrom here we can select the memory map within Ghidra.\n\nHow to use Ghidra to Sync a Memory Address\nThen select the Home button\n\nUsing Ghidra to Sync memory address with x32dbg\nand set the base address according to what was obtained with x32dbg.\n\n\n-----\n\nUsing Ghidra to sync a memory address with x32dbg\nFrom here, the address of the suspected-string-decryption function will be updated\naccordingly and be in-sync with x32dbg.\n\nString Decryption Function in Ghidra with Updated Memory Address\nThe new function address is 003f4550 . This value can be used to create a breakpoint inside\nof x32dbg.\n\nUpdated Memory Address in Ghidra\n\n\n-----\n\nCommand for\n\ncreating a breakpoint on a known suspicious function\nThe breakpoint is then hit with an argument of j hl#A\n\nBeginning of a suspicious function in x32dbg\nAllowing the malware to Execute Until Return will retrieve the result of the function. In this\ncase it was a large hex string that was pretty uninteresting.\n\nEnd of a suspicious function - viewing the returned value - possible decoded string\nHowever, Clicking F9 or Continue will cause the Decryption code to be hit again.\n\nSadly, this again revealed some largely uninteresting strings\n\n\n-----\n\nI eventually realised that this function was not used to decode the final strings. But was\nrather to obtain copies of the same base64 obfuscated strings that were previously found.\n\nAt this point I experimented with the Suspicious imports, but could not reliably trace them\nback to a function that would obtain the decrypted c2's .\n\nHowever - I did get lucky and was able to locate an interesting function towards the main\nmalware function of the code.\n\nThis function was located at 003d29b0.\n\n## Locating Main\n\nI was able to locate main by browsing to the EntryPoint.\n\n\n-----\n\nAttempting to locate the main function in Ghidra - Starting from Entry Point\n\nAttempting to locate the main function using Ghidra\n\n\n-----\n\nSuccessfully finding the main function within Ghidra\n\nIdentifying a possible string decryption function in Ghidra\nWhen this function is executed - a base64 encoded value is passed as an argument.\n\n\n-----\n\nBase64 Function Arguments viewed in a debugger.\nExecuting until the end of the function - A value is obtained which the malware used to\ncreate a folder in the users temp directory.\n\nObtaining a decoded value using x32dbg\nThe next call to this function - took a base64 encoded argument and returned a file name\nthat the malware was copied into.\n\nA second encoded value in eax- viewed in x32dbg\n\n\n-----\n\nA decoded filename - located using return addresses in x32dbg\nAt a location of 003e9870 - was a function responsible for checking the location of the current\nrunning file.\n\nIf the location did not match C:\\\\users\\\\\n```\n<user>\\\\appdata\\\\local\\\\temp\\\\595f021478\\\\oneetx.exe - then the malware would\n\n```\nterminate.\n\nHere we can see the return value from the function.\n\nAs well as the outgoing function calls in the Ghidra Function Tree.\n\n\n-----\n\nViewing the Function Tree Using Ghidra\nAfter the directory check is performed - the malware enters FUN_003e7b70 attempts to\ncreates a mutex with a value of 006700e5a2ab05704bbb0c589b88924d\n\n\n-----\n\n-----\n\nBy breaking on CreateMutexA - The value of 006700e5a2ab05704bbb0c589b88924d can be seen\nas an argument.\n\nIf the mutex creation returned a value of 0xb7 (Already Exists) - then the malware would\nterminate itself.\n\n## Bypassing Anti-Something Checks\n\nThese two checks on the file path and Mutex can function as pseudo anti-debug checks. In\norder to continue analysis, they needed to either be patched or bypassed.\n\nIn order to bypass the file path check - I allowed the malware to execute inside the analysis\nVM and copy itself to the correct folder. I then opened the new file inside the debugger.\n\n_Alternatively - You could have patched or nop'd the function. but I found that just moving it to_\n_the expected folder worked fine._\n\n\n-----\n\nOnce the new file was loaded - I updated the base address in Ghidra to match the new\naddress in x32dbg.\n\nOnce I updated the base address - I set a breakpoint on CreateMutexA and the suspected\ndecryption function FUN_XXXX29b0\n\nOnce I hit the breakpoint on CreateMutexA - I stepped out of the function using Execute\n```\nUntil Return and then Step Over twice.\n\n```\nThis allowed me to see the return value of b7 from the GetLastError function. When I\nallowed the malware to continue to run - it quickly terminated itself without hitting the\ndecryption breakpoint.\n\nTo fix this - I used Edit to patch the return value to be B6 instead.\n\n\n-----\n\nPatching a return value using X32dbg\nUpon running the malware - The decryption function was hit again.\n\nFollowing the return of the decryption function using Exeute Until Return revealed a pretty\nboring \\\\ character.\n\nBut allowing it to hit a few more times - it eventually returned a value of Startup which was\npretty interesting.\n\nHitting again revealed a registry path of\n```\nSOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\n\n```\nEventually some more interesting values were returned. Including a partial command likely\nused to create persistence.\n\n\n-----\n\nAs well as some possible signs of enumeration\n\nEventually - The names of some security products was also observed. Likely the malware\nwas scanning for the presence of these tools.\n\n### C2 Information\n\nAllowing the decryption function to continue to execute and hit our breakpoint. We can\neventually observe C2 information.\n\n**Automating the Decryption - Kinda**\n\n\n-----\n\nEventually the constant breakpoint + execute until return combination got tiring. So I decided\nto try and automate it using a Conditional Breakpoint and Log.\n\nTo do this - I allowed the malware to execute until the end of a decryption function.\n\nAnd then created a Conditional Breakpoint that would log any string contained at eax, then\ncontinue execution.\n\nSettiing a Conditional Breakpoint (and logging a value) using X32dbg\nAllowing the malware to continue to execute. I could observe the decoded values printed to\nthe log menu of x32dbg.\n\n\n-----\n\nSuccessfully using conditional breakpoints to decode a malware sample.\nThis revealed some c2 information - referencing an IP with 1/87 detections as of 2023/04/10\n\nThe full list of decoded strings can be found here.\n\n\n-----\n\n```\n & SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\n\n &\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\ComputerName\\\\ComputerName\"\n\n &\"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\"\n\n &\"abcdefghijklmnopqrstuvwxyz0123456789-_\"\n\n &\"/Create /SC MINUTE /MO 1 /TN \"\n\n &\"/plays/chapter/index.php\"\n\n &\"GetNativeSystemInfo\"\n\n &\"cred.dll|clip.dll|\"\n\n \"77[.]91[.]124[.]207\"\n\n \"Panda Security\"\n\n \"AVAST Software\"\n\n \"Kaspersky Lab\"\n\n \"ProgramData\\\\\"\n\n \"ComputerName\"\n\n \"CurrentBuild\"\n\n \"kernel32.dll\"\n\n \"Bitdefender\"\n\n \"Doctor Web\"\n\n \"https://\"\n\n \"Plugins/\"\n\n \"SCHTASKS\"\n\n \"http://\"\n\n \" /TR \\\"\"\n\n \"Startup\"\n\n \"Comodo\"\n\n \"Sophos\"\n\n \"Norton\"\n\n \"Avira\"\n\n \"\\\" /F\"\n\n L\"\\\\¬=\"\n\n \"POST\"\n\n \"&vs=\"\n\n \"3.70\"\n\n \"&sd=\"\n\n \"&os=\"\n\n \"&bi=\"\n\n \"&ar=\"\n\n \"&pc=\"\n\n \"&un=\"\n\n \"&dm=\"\n\n \"&av=\"\n\n \"&lv=\"\n\n \"&og=\"\n\n \"ESET\"\n\n \"dll\"\n\n \"<c>\"\n\n \"id=\"\n\n \"AVG\"\n\n ???\n\n### Bonus: Utilising Decrypted Strings To Identify the Malware Family\n\n```\n\n-----\n\nThis section was not in the original blog, but was later added when I was informed by\nanother researcher that the malware might not be Redline.\n\nI then revisited my analysis and determined that the sample was Amadey Bot.\n\nI was able to determine this mostly by researching (googling) the decrypted strings.\n\nI thought it would be useful for others to see what this process looked like :)\n\nDecrypted strings are not just useful for C2 information. They are equally as useful for\nidentifying the malware that you are analyzing.\n\nUnless you are analyzing the latest and greatest APT malware, your sample has likely been\nanalyzed and publically documented before. You'd be surprised how much you can\n[determine using Google and the \"intext\" operator. (Essentially it forces all search results to](https://www.googleguide.com/advanced_operators_reference.html?ref=embee-research.ghost.io)\ncontain your query string, significantly reducing unrelated content)\n\nFrom decrypted strings, try to pick something specific.\n\nFor example, the following decrypted string &\"cred.dll|clip.dll|\" can be used to craft a\nGoogle query of intext:clip.dll intext:cred.dll malware.\n\nThis returns 7 results that reference a combination of Redline Stealer and Amadey Bot.\n\nThe first link contains IOC's from an Amadey Bot sample, which align closely with the sample\nanalysed in this blog.\n\n\n-----\n\nIn the second link - An additional Amadey sample is analysed with the exact same filename\nas this one. Albeit with a different C2 server.\n\nAt this point - I would have moderate confidence that the sample is Amadey Bot.\n\nFor additional confirmation, I would typically google this family and see if any TTP's are the\nsame or at least similar.\n\n[I googled Amadey Bot Analysis and discovered this blog from AhnLab.com.](https://asec.ahnlab.com/en/36634/?ref=embee-research.ghost.io)\n\n\n-----\n\nThe Ahnsec blog details an extremely similar installation path and strings.\n\nThe [Ahnsec Blog also references a list of AV products that are enumerated by Amadey Bot.](https://asec.ahnlab.com/en/36634/?ref=embee-research.ghost.io)\n\n\n-----\n\nCoincidentally, almost all of those strings were contained in our sample\n\n\n-----\n\nThe [Ahnsec blog also references specific parameters that are sent in POST requests made](https://asec.ahnlab.com/en/36634/?ref=embee-research.ghost.io)\nby Amadey Bot.\n\n\n-----\n\nCoincidentally, almost all of those same fields (first column) are referenced in our decrypted\nstrings.\n\nSince POST request parameters are pretty specific - Was confident my sample was actually\nAmadey bot.\n\n\n-----\n\n[At this point, I also reviewed a second blog from Blackberry. Which confirmed much of the](https://blogs.blackberry.com/en/2020/01/threat-spotlight-amadey-bot?ref=embee-research.ghost.io)\n[same analysis as AhnSec.](https://asec.ahnlab.com/en/36634/?ref=embee-research.ghost.io)\n\nAt this point, I was comfortable re-classifying the malware as Amadey bot.\n\n(I also learned not to blindly follow tags from Malware Reps)\n\n## Conclusion and Recommendations\n\nAt this point I'm going to conclude the analysis as we have successfully located the C2\ninformation and identified the malware family. In a real life situation, this analysis could serve\nmultiple purposes.\n\nDecrypted strings can be googled to aid in malware identification.\nDecrypted strings contain commands and process names that can be used for\nprocess-based hunting\nDecrypted Strings contain URL structure which can used to hunt or develop detection\nrules for proxy logs.\nDecrypted Strings contain an IP that could be used to identify infected machines.\nDecrypted Strings can be used to enhance a Ghidra or IDA database - enhancing the\ndecompiler output and leading to better RE analysis.\n\n\n-----\n\nBetter automation could be used to make a config extractor - useful for a threat\nintel/analysis pipeline. (Replacing x32dbg with Dumpulator would be a great way to do\nthis)\n+ lots of fun :D\n\n## Virustotal\n\nAt the time of this analysis (2023/04/10) - There is only 1/87 detections for the C2 on\nVirustotal\n\n## Decoded Strings\n\nA full list of strings obtained using the log function of x32dbg.\n\n(Noting that these are in order of length and not location of occurrence.)\n\n\n-----\n\n```\n & SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\User Shell Folders\n\n &\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\ComputerName\\\\ComputerName\"\n\n &\"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\"\n\n &\"abcdefghijklmnopqrstuvwxyz0123456789-_\"\n\n &\"/Create /SC MINUTE /MO 1 /TN \"\n\n &\"/plays/chapter/index.php\"\n\n &\"GetNativeSystemInfo\"\n\n &\"cred.dll|clip.dll|\"\n\n \"77[.]91[.]124[.]207\"\n\n \"Panda Security\"\n\n \"AVAST Software\"\n\n \"Kaspersky Lab\"\n\n \"ProgramData\\\\\"\n\n \"ComputerName\"\n\n \"CurrentBuild\"\n\n \"kernel32.dll\"\n\n \"Bitdefender\"\n\n \"Doctor Web\"\n\n \"https://\"\n\n \"Plugins/\"\n\n \"SCHTASKS\"\n\n \"http://\"\n\n \" /TR \\\"\"\n\n \"Startup\"\n\n \"Comodo\"\n\n \"Sophos\"\n\n \"Norton\"\n\n \"Avira\"\n\n \"\\\" /F\"\n\n L\"\\\\¬=\"\n\n \"POST\"\n\n \"&vs=\"\n\n \"3.70\"\n\n \"&sd=\"\n\n \"&os=\"\n\n \"&bi=\"\n\n \"&ar=\"\n\n \"&pc=\"\n\n \"&un=\"\n\n \"&dm=\"\n\n \"&av=\"\n\n \"&lv=\"\n\n \"&og=\"\n\n \"ESET\"\n\n \"dll\"\n\n \"<c>\"\n\n \"id=\"\n\n \"AVG\"\n\n ???\n\n## Useful Links\n\n```\n\n-----\n\n[AhnSec Labs - Blog on Amadey Stealer](https://asec.ahnlab.com/en/36634/?ref=embee-research.ghost.io)\n[Blackberry Blog - Amadey Bot Analysis](https://blogs.blackberry.com/en/2020/01/threat-spotlight-amadey-bot?ref=embee-research.ghost.io)\nMandiant - [Repo for Flare VM Install](https://github.com/mandiant/flare-vm?ref=embee-research.ghost.io)\n[X32dbg Documentation - Conditional Breakpoints in X32dbg](https://help.x64dbg.com/en/latest/introduction/ConditionalBreakpoint.html?ref=embee-research.ghost.io)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-04-10 - Redline Stealer - Static Analysis and C2 Extraction.pdf"
    ],
    "report_names": [
        "2023-04-10 - Redline Stealer - Static Analysis and C2 Extraction.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1683338951,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1683251742,
    "ts_modification_date": 1683251742,
    "files": {
        "pdf": "https://archive.orkl.eu/364bd754656f2cb471781bfae3dd1b5af5b29bfa.pdf",
        "text": "https://archive.orkl.eu/364bd754656f2cb471781bfae3dd1b5af5b29bfa.txt",
        "img": "https://archive.orkl.eu/364bd754656f2cb471781bfae3dd1b5af5b29bfa.jpg"
    }
}