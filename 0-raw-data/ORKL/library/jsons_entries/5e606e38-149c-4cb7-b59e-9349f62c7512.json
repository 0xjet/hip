{
    "id": "5e606e38-149c-4cb7-b59e-9349f62c7512",
    "created_at": "2023-01-12T15:09:28.147463Z",
    "updated_at": "2025-03-27T02:16:25.630835Z",
    "deleted_at": null,
    "sha1_hash": "a77336d8597398df7de9e1f46a2beb76504e04d7",
    "title": "2022-01-31 - Analyzing Malware with Hooks, Stomps and Return-addresses",
    "authors": "",
    "file_creation_date": "2022-05-28T17:28:47Z",
    "file_modification_date": "2022-05-28T17:28:47Z",
    "file_size": 1453901,
    "plain_text": "# Analyzing Malware with Hooks, Stomps and Return- addresses\n\n**[cyberark.com/resources/threat-research/analyzing-malware-with-hooks-stomps-and-return-addresses-2](https://www.cyberark.com/resources/threat-research/analyzing-malware-with-hooks-stomps-and-return-addresses-2)**\n\nJanuary 31, 2022\n\n## Table of Contents\n\n[1. Introduction](https://www.arashparsa.com/p/b366c4ae-e90a-401b-98e8-e70b8189eeaf/#introduction)\n[2. The First Detection](https://www.arashparsa.com/p/b366c4ae-e90a-401b-98e8-e70b8189eeaf/#firstdetect)\n[3. The Module Stomp Bypass](https://www.arashparsa.com/p/b366c4ae-e90a-401b-98e8-e70b8189eeaf/#stomp)\n[4. The Module Stomp Detection](https://www.arashparsa.com/p/b366c4ae-e90a-401b-98e8-e70b8189eeaf/#stompdetect)\n[5. Final Thoughts](https://www.arashparsa.com/p/b366c4ae-e90a-401b-98e8-e70b8189eeaf/#thoughts)\n\n## Introduction\n\nThis is the second post in my series and with this post we will focus on malware and some of\ntheir relevant detections. This post will focus on an interesting observation I made when\ncreating my heap encryption and how this could be leveraged to detect arbitrary shellcode as\nwell as tools like cobalt strike, how those detections could be bypassed and even newer\ndetections can be made.\n\n[Sample code of a POC can be found here: https://github.com/waldo-irc/MalMemDetect](https://github.com/waldo-irc/MalMemDetect)\n\n## The First Detection\n\n\n-----\n\nIf you recall [in the first post, our method at targeting Cobalt Strikes heap allocations was to](https://www.cyberark.com/resources/threat-research-blog/hook-heaps-and-live-free)\nhook the process space and manage all allocations made by essentially what was a module\nwith no name. Here is the code we had used as a refresher:\n```\n#include \n#pragma intrinsic(_ReturnAddress)\nGlobalThreadId = GetCurrentThreadId(); We get the thread Id of our dropper!\nHookedHeapAlloc (Arg1, Arg2, Arg3) {\n  LPVOID pointerToEncrypt = OldHeapAlloc(Arg1, Arg2, Arg3);\n  if (GlobalThreadId == GetCurrentThreadId()) { // If the calling ThreadId matches\nour initial thread id then continue\n     HMODULE hModule;\n     char lpBaseName[256];\n          if (::GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n(LPCSTR)_ReturnAddress(), &hModule) == 1) {\n          ::GetModuleBaseNameA(GetCurrentProcess(), hModule, lpBaseName,\nsizeof(lpBaseName));\n     }\n    std::string modName = lpBaseName;\n    std::transform(modName.begin(), modName.end(), modName.begin(),\n        [](unsigned char c) { return std::tolower(c); });\n    if (modName.find(\"dll\") == std::string::npos && modName.find(\"exe\") ==\nstd::string::npos) {\n           // Insert pointerToEncrypt variable into a list\n    }\n  }\n}\n\n```\nThe magic lines lie here:\n```\nif (::GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n(LPCSTR)_ReturnAddress(), &hModule) == 1) {\n     ::GetModuleBaseNameA(GetCurrentProcess(), hModule, lpBaseName,\nsizeof(lpBaseName));\n}\n\n```\nWhat we are trying to do here is take the current address our function will be returning to and\nattempting to resolve it to a module name using the function GetModuleHandleExA with the\nargument GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS. With this flag the\nimplication is the address we are passing is: “an address in the module”\n(https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapigetmodulehandleexa). The module name will get returned and stored in the lpBaseName\nvariable.\n\n\n-----\n\nWith the case of our thread – targeted heap encryption – this function actually returns\nnothing, as it cannot resolve the return address to a module! This also means lpBaseName\nends up containing nothing.\n\nAs always, let’s see what this looks like in our debugger. First, we’ll start with a legitimate\ncall. I’ve gone ahead and hooked HeapAlloc using MinHook\n[(https://github.com/TsudaKageyu/minhook) and am tracing the return address of all callers.](https://github.com/TsudaKageyu/minhook)\nLet’s see who the first function to call our hooked malloc is:\n\n_fig 1. Usage of _ReturnAddress intrinsic_\n\nHere we can see within our code we use the Visual C++ _ReturnAddress() intrinsic\n[(https://docs.microsoft.com/en-us/cpp/intrinsics/returnaddress?view=msvc-160) and store the](https://docs.microsoft.com/en-us/cpp/intrinsics/returnaddress?view=msvc-160)\nvalue in a variable named “data”. We then pass this variable to GetModuleHandleExA in\norder to resolve the module name we will be returning to.\n\n_fig 2. Return address value_\n\nTaking a look at data we can see it seems to have stored a valid address. Now let’s look at\nthis address in our disassembler.\n\n\n-----\n\n_fig 3. Return address location_\n\nAs you can see we are right at that “mov rbx,rax” instruction at the end of the screenshot\nbased on the address. That means when our hooked function completes, this is where it will\nreturn, and we can further validate this as the correct assembly instruction we will return to\nas right before this is a call to RtlAllocateHeap, our hooked function! Using this we now know\nwe are in the function LdrpGetNewTlsVector, that our hooked RtlAllocateHeap was just ran,\nand on completion, it’ll continue within LdrpGetNewTlsVector right after the call as usual. If\nwe attempt to identify what module this function comes from, we can clearly see it is from\nntdll.dll.\n\n_fig 4. Return address module resolved_\n\nThis works because the function maps to a DLL we appear to have loaded from\ndisk. Because of this, Windows knows how to identify what module the function comes from.\nWhat about our shellcode though? Let’s see what that looks like.\n\n_fig 5. Shellcode return address and failed resolution_\n\n\n-----\n\nSo our base name is empty because the function fails to resolve the address to a\nmodule. Let’s see what that address looks like in the disassembler:\n\n_fig 6. Shellcode return address location_\n\nThere’s our address at “test rax,rax”. We actually know this is our shellcode based on the\naddress:\n\n\n-----\n\n_fig 7. Shellcode in process hacker_\n\n_fig 8. Shellcode region in process hacker_\n\nWithin process hacker we can see our MZ header and that the location we are returning to is\nwithin the address space of our shellcode. We can also see unlike other modules like\nntdll.dll, in ProcessHacker the “use” column is empty for our shellcode:\n\n_fig 9. Use section for shellcode is empty_\n\n\n-----\n\n_fig 10. Use section for DLLs is filled_\n\nThis is because our arbitrarily allocated memory does not map to anything on disk. Because\nof this, when we attempt to resolve the return address to a module we get nothing returned\nas a result.\n\nThat being said, we can see instances of RWX memory that don’t map to disk in processes\nthat use JIT compilers such as C# and browser processes as well. You can see in stage 3 of\nthe Managed Execution Process (https://docs.microsoft.com/enus/dotnet/standard/managed-execution-process) that an additional compiler takes the C#\ncode a user creates and turns it into native code (which means our C# IL now becomes\nnative assembly). For this process to take place a RWX region needs to be allocated for it to\nbe able to write the new code and also be able to execute it. We can see these RWX regions\nin C# processes with ProcessHacker.\n\n\n-----\n\n_fig 11. JIIT Compiler RWX sections_\n\nAbove you can see a small sample of these RWX sections within my\nMicrosoft.ServiceHug.Controller.exe process. This means that in theory we could see false\npositives from JIT compiler-based languages that run any of our hooked functions from these\nmemory regions. Additionally, this means these sorts of processes can also be great spaces\nto hide your RWX malware, as Private Commit RWX regions are otherwise considered\nsuspicious (as we have executable memory that doesn’t map to anything on disk).\n\nOutside of blending in with JIT processes though, let’s discuss another simple bypass to this,\none that exists within Cobalt Strikes own C2 profile even.\n\n## The Module Stomp Bypass\n\n\n-----\n\nIf we think back to the original detection, we were able to observe executablememory calling\nour hooked functions that couldn’t resolve to any module name. A first thought may be “what\nis a mechanism to bypass this” as one must exist. Several exist in fact, but we can start with\na simple one, a mechanism called “Module Stomping” (https://www.forrestorr.net/post/malicious-memory-artifacts-part-i-dll-hollowing as well as\nhttps://www.ired.team/offensive-security/code-injection-process-injection/modulestomping-dllhollowing-shellcode-injection).\n\nWhat this technique effectively does is load a DLL that our process doesn’t currently have\nloaded and hollow out its memory regions to contain the data for a malicious DLL of ours\ninstead. This would make it so all our calls now appear to be coming from this legitimate\nmodule!\n\nThe section in your malleable C2 profile (for Cobalt Strike) that you would have to edit is the\nfollowing:\n```\nset allocator \"VirtualAlloc\"; # HeapAlloc,MapViewOfFile, and VirtualAlloc. \n# Ask the x86 ReflectiveLoader to load the specified library and overwrite\n# its space instead of allocating memory with VirtualAlloc.\n# Only works with VirtualAlloc\nset module_x86 \"xpsservices.dll\";\nset module_x64 \"xpsservices.dll\";\n\n```\nThese settings can be observed in the old reference profile here:\n[https://github.com/rsmudge/Malleable-C2-Profiles/blob/master/normal/reference.profile. By](https://github.com/rsmudge/Malleable-C2-Profiles/blob/master/normal/reference.profile)\nchanging your allocator to “VirtualAlloc” and enabling the set module_x86 and x64 settings\nyou can now allocate your Cobalt Strike payload to arbitrary modules you load instead of\narbitrarily allocated executable memory space.\n\nLet’s change the setting and see what this looks like. We will simply run an unstaged Cobalt\nStrike EXE and observe for this experiment.\n\n\n-----\n\n_fig 12. Cobalt Strike module stomp_\n\nLet’s go ahead and run this with our module name resolver and see what it looks like. Since\nthe name should always resolve, now we will change the logic a bit to monitor only\nxpsservices.dll.\n\n\n-----\n\n_fig 13. New code to monitor xpsservices_\n\n_fig 14. Name resolved properly_\n\nHere we can see the new stomped DLL calling our hooked malloc, and that our code can\nsuccessfully resolve calls to this module. If we look at the print statements, we would also\nsee all the calls – from anything that doesn’t map to modules that have disappeared.\n\n\n-----\n\n_fig 15. Only module callers_\n\nAnd finally, we can see in the above screenshot that no callers without module names are\nobserved anymore as all of Cobalt Strike’s calls now map to a module on disk, a simple\nbypass. So now we ask if this technique can be detected as well, and of course, there’s a\nfew ways.\n\n## The Module Stomp Detection\n\nThere are several detections, but we will delve into two here for module stomping. One is\ndue to a side effect of how Cobalt Strike implements module stomping as well as general\nIOCs that can be observed when module stomping is performed.\n\nThe first is a detection created by Slaeryan\n[(https://github.com/slaeryan/DetectCobaltStomp). In short, this detection works because a](https://github.com/slaeryan/DetectCobaltStomp)\nside effect of Cobalt Strike’s implementation is that when loaded in memory, the region\nappears to be marked as a EXE internally and not a DLL. For those that don’t have cobalt\n\n\n-----\n\nstrike, he also created a tool to mimic the implementation for people to play with and observe\nthe detection. I won’t go into this one too much as he already has a POC and discusses this\ndetection.\n\nThe other detection is a much more basic one. Within any executable file, the section where\nexecutable code lives is the .TEXT section. If we walk the .TEXT section of a DLL on disk\nand compare it to the .TEXT section of its equivalent offload in memory the sections in theory\nshould always match, as the code should not change unless the file is polymorphic. The\ncode for this is fairly basic.\n```\nHMODULE lphModule[1024];\nDWORD lpcbNeeded;\n// Get a handle to the process.\nHANDLE = hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |\n     PROCESS_VM_READ,\n     FALSE, processID);\n// Get a list of all the modules in this process.\nif (EnumProcessModules(hProcess, lphModule, sizeof(lphModule), &lpcbNeeded))\n{\n     for (i = 0; i < (lpcbNeeded / sizeof(HMODULE)); i++)\n     {\n          char szModName[MAX_PATH];\n          // Get the full path to the module's file.\n          if (K32GetModuleFileNameExA(hProcess, lphModule[i], szModName,\n              sizeof(szModName) / sizeof(char)))\n          {\n              // Do stuff\n          }\n     }\n}\n\n```\nHere we simply start by iterating every module in the process.\n\n\n-----\n\n```\n// Get file Bytes\nFILE* pFile;\nlong lSize;\n//SIZE_T lSize;\nBYTE* buffer;\nsize_t result;\npFile = fopen(szModName, \"rb\");\n// obtain file size:\nfseek(pFile, 0, SEEK_END);\nlSize = ftell(pFile);\nrewind(pFile);\n// allocate memory to contain the whole file:\nbuffer = (BYTE*)malloc(sizeof(BYTE) * lSize);\n// copy the file into the buffer:\nresult = fread(buffer, 1, lSize, pFile);\nfclose(pFile);\nBYTE* buff;\nbuff = (BYTE*)malloc(sizeof(BYTE) * lSize);\n_ReadProcessMemory(hProcess, lphModule[i], buff, lSize, NULL);\nPIMAGE_NT_HEADERS64 NtHeader = ImageNtHeader(buff);\nPIMAGE_SECTION_HEADER Section = IMAGE_FIRST_SECTION(NtHeader);\nWORD NumSections = NtHeader->FileHeader.NumberOfSections;\nfor (WORD i = 0; i < NumSections; i++) { std::string\nsecName(reinterpret_cast(Section->Name), 5);\n     if (secName.find(\".text\") != std::string::npos) {\n          break;\n     }\n     Section++;\n}\n\n```\nWe then load the relevant module file on disk and store the bytes for comparing memory in\nthe var buffer. We then also read from the base address of the module located in\n“lphModule[i]” and store all the bytes within the var buff. We then enumerate all the sections\nin the loaded module until we find the .TEXT section and break the loop. At this point the\n“Section” variable will contain all our relevant section data.\n\nTo be able to match the on-disk file to the one in memory we need to use the Section offsets\nto find the .TEXT section location on disk and in memory. This actually will not match\n(usually). The offset to the .TEXT section in memory generally gets relocated down a page,\n4096 bytes. The offset to the section on disk is usually 1024 bytes in comparison. But we say\nusually so we of course will simply use “Section->PointerToRawData” to get the offset on\ndisk and “Section->VirtualAddress” to get its offloaded address in memory to be 100% sure.\n```\nLPBYTE txtSectionFile = buffer + Section->PointerToRawData;\nLPBYTE txtSectionMem = buff + Section->VirtualAddress;\n\n```\nAt this point all you’d have to do is compare each memory region byte for byte and make\nsure they match.\n\n\n-----\n\n```\nint inconsistencies 0;\nfor (int i = 0; i < Section->SizeOfRawData; i++) {\n     if ((char*)txtSectionFile[i] != (char*)txtSectionMem[i]) {\n          inconsistencies++;\n     }\n}\n\n```\nNow of course we need to account for things like hooks and such, as we know many AV and\nEDR will perform hooks, we know these will provide false positives. As a result we take the\namount of the differences and if it’s greater than a certain number only then do we get\nconcerned.\n```\nif (inconsistencies > 10000) {\n     printf(\"FOUND DLL HOLLOW.\\nNOW MONITORING: %s with %f changes found. %f%%\nOverall\\n\\n\", szModName, inconsistencies, icPercent);\n     CHAR* log = (CHAR*)malloc(256);\n     snprintf(log, 255, \"FOUND DLL HOLLOW.\\nNOW MONITORING: %s with %f changes\nfound. %f%% Overall\\n\\n\", szModName, inconsistencies, icPercent);\n     LogDetected(&log);\n     free(log);\n     std::string moduleName(szModName, sizeof(szModName) / sizeof(char));\n     std::transform(moduleName.begin(), moduleName.end(), moduleName.begin(),\n          [](unsigned char c) { return tolower(c); });\n     dllMonitor = moduleName;\n     break;\n}\n\n```\nWe arbitrarily pick 10,000 as our amount, simply because we know it’ll certainly be a larger\nnumber than any number of hooks any utility would alter for the hooks, as well as being small\nenough as we know most raw malware payloads at least are much bigger. This should\nreduce false positives substantially while finding any altered DLLs in memory. The only\ncaveat to this would be additional false positives from polymorphic DLLs who alter\nthemselves in memory.\n\nLet’s run our new detector against our Cobalt Strike payload and the hollowed DLL and\nobserve the results.\n\n\n-----\n\n_fig 16. DLL Hollow Detection_\n\nHere we can see a few false positives from our own hooks actually, where we alter five bytes\nto the prologue of each function, two functions being altered in each DLL. Finally at the end\nwe can see our hollowed xpsservices.dll and the detection is observed with over 300k bytes\naltered.\n\nLet’s go ahead and turn our tool into a DLL and inject it into everything to observe false\npositives:\n\nBy injecting into everything and logging all data to files we can observe our detection:\n\n\n-----\n\n_fig 17. Detection_\n\nBUT! Interestingly enough we do observe one false positive on what appears to be a\npolymorphic DLL after all…\n\n_fig 18. False positive_\n\nUnfortunately not enough bytes are altered to be useful for a hollow target though!\n\nHow do you bypass this detection? Now the simple obvious solution is to restore the DLL\nbytes (per [https://twitter.com/solomonsklash‘s idea) on sleep to prevent this sort of detection](https://twitter.com/solomonsklash)\nand next steps would be hooking those calls and detecting the restores, if possible, or the\nconstant file reads etc. As we all know, cybersecurity is a never-ending cat and mouse.\n\n## Final Thoughts\n\nAs red teamers work on malware, often we make discoveries that can lead to new detections\ntoo. These observations can be tremendously useful to the community while also pushing\nresearchers to the cutting edge and forcing them to think outside of the box if they’d like this\ngame to continue longer.\n\n\n-----\n\nAs we ve seen above, we find detections, make bypasses, find more detections — and the\ngame will never end. Hopefully some interesting new insights could be made to make our\ndefensive industry far more robust overall, as we work together towards a goal of secure\ninternet usage.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-31 - Analyzing Malware with Hooks, Stomps and Return-addresses.pdf"
    ],
    "report_names": [
        "2022-01-31 - Analyzing Malware with Hooks, Stomps and Return-addresses.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536168,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653758927,
    "ts_modification_date": 1653758927,
    "files": {
        "pdf": "https://archive.orkl.eu/a77336d8597398df7de9e1f46a2beb76504e04d7.pdf",
        "text": "https://archive.orkl.eu/a77336d8597398df7de9e1f46a2beb76504e04d7.txt",
        "img": "https://archive.orkl.eu/a77336d8597398df7de9e1f46a2beb76504e04d7.jpg"
    }
}