{
    "id": "ee05af9c-cbb3-446e-b2ab-609dc7e6890b",
    "created_at": "2022-10-25T16:48:11.800342Z",
    "updated_at": "2025-03-27T02:05:37.594506Z",
    "deleted_at": null,
    "sha1_hash": "e0f70a9fac33a317678f675b03fd0cdc168bf0c9",
    "title": "",
    "authors": "",
    "file_creation_date": "2021-01-27T23:03:38Z",
    "file_modification_date": "2021-01-28T19:11:50Z",
    "file_size": 40564486,
    "plain_text": "# Malware Analysis at Scale\n\n#### ~ Defeating EMOTET by Ghidra ~\n\n###### 株式会社サイバーディフェンス研究所 中島将太\n\n トレンドマイクロ株式会社 原弘明\n\n\n-----\n\n#### > whoami\n\n###### Shota Nakajima\n\n Hiroaki Hara\n\n\nØ 株式会社サイバーディフェンス研究所でマルウ\nェア解析、インシデントレスポンス業務、脅威\n情報の収集・分析業務に従事。\n\nØ JSAC、HITCON CMT、AVAR、CPRCon、Black\nHat EUROPE Arsenal、CodeBlue BlueBoxなど\nで発表経験あり。\n\n###### Shota Nakajima Ø 技術系同⼈サークルAllsafeのプロデューサー。\n\nØ トレンドマイクロ株式会社にて、マルウェア\n解析やインシデントレスポンス、スレットリ\nサーチなどに従事。\n\nØ 技術系同⼈サークルAllsafeの澤村・スペンサ\nー・英梨々(アートディレクター) 。\n\n###### Hiroaki Hara\n\n\n-----\n\n#### Malware Analysis at Scale\n\n###### テーマ: いかにして楽に解析を終わらせるか\n\nn 解析者の現状として、次のような課題がある\n\nü 静的解析は時間がかかり、根本的につらい\n\nü 膨⼤な数のマルウェアを解析する必要がある\n\nü ⼿動での解析は現実的に不可能\n\n###### 解析の⾃動化（スケ ルする解析）をめざす\n\n\n###### テーマ: いかにして楽に解析を終わらせるか\n\nn 解析者の現状として、次のような課題がある\n\nü 静的解析は時間がかかり、根本的につらい\n\nü 膨⼤な数のマルウェアを解析する必要がある\n\nü ⼿動での解析は現実的に不可能\n\n\n-----\n\n#### Target\n\n\nn マルウェア解析経験者\n\n      - C⾔語、アセンブリ⾔語を理解している\n\n      - Windowsのプログラミングについて知識がある\n\n      - IDA, Ghidraを使ってマルウェアの静的解析をしたことがある\n\nn Pythonでのプログラミング経験を有する者\n\n      - Pythonの基本的な⽂法がわかる\n\n\n-----\n\n###### TABLE OF CONTENTS\n\n\n###### TABLE OF CONTENTS\n\n 01 Basic of Ghidra\n\nn Ghidra Usage\n\nn Ghidra Script\n\n###### 02 Automated Analysis of EMOTET\n\nn Surface Analysis\n\nn API Hashing and Dynamic Call\n\nn Decrypt strings\n\nn Config Structure Analysis\n\n\n-----\n\n## 01\n# Basic of Ghidra\n\n\n-----\n\n#### What is Ghidra?\n\n\n###### ソフトウェアリバースエンジニアリングツールセット\n\n    - 2019年にNSAによってOpen Source Softwareとして公開\n\n      - https://github.com/NationalSecurityAgency/ghidra\n\n    - フリーでありながら、豊富な機能を提供\n\n\n-----\n\n#### Ghidra's Basic Features\n\n\n複数ユーザによる共同作業を\nサポ ト\n\n\nGDB/WinDBGをバックエンド\nとしたデバ グ機能を提供\n\n\n#### Ghidra's Basic Features\n\n###### Disassembler/Decompiler Ghidra Script Ghidra Extension\n\n多様なアーキテクチャに対応した Ghidraの各種機能をスクリプト ⾃作プラグインによる\nディスアセンブラに加え、 (Java/Python)から利⽤可能 機能拡張をサポート\n擬似C⾔語へ変換するデコンパイラ機能\n\n###### Headless Analyzer Ghidra Server Debugger\n\nCLI経由での操作 複数ユーザによる共同作業を GDB/WinDBGをバックエンド\n\n\n-----\n\n# Ghidra Usage\n\n\n-----\n\n#### Code Browser\n\nProgram Tree\n\n - セクション名など\nを表⽰\n\nSource Tree\n\n - インポート/エクス\nポート関数、関数\n名、クラス名など\nなどを列挙\n\nData Type Manager\n\n- 独⾃構造体などの\nデータ型を管理\n\n\n###### Console\n\n\nListing View\n\nDecompile View\n\n                                    - ディスアセンブル・データを表⽰\n\n                                                                - Listing Viewのデコンパイル結果を表⽰\n\nProgram Tree\n\n  - セクション名など\nを表⽰\n\nSource Tree\n\n  - インポート/エクス\nポート関数、関数\n名、クラス名など\nなどを列挙\n\nData Type Manager\n\n  - 独⾃構造体などの\n\n###### Console\n\n\n-----\n\n#### Other Windows\n\nn Bookmarks\n\n             \nn Bytes\n\n             - HEXエディタ\n\nn Defined Strings\n\n             \nn Function Graph\n\n             \nn Python\n\n             - Pythonインタプリタの起動\n\nn Script Manager\n\n\nn Bookmarks\n\n                - 特定のアドレスに対し、名前をつけてブックマークとして保存\n\nn Bytes\n\n                - HEXエディタ\n\nn Defined Strings\n\n                - プログラム内で定義された可読⽂字列\n\nn Function Graph\n\n                - ディスアセンブル結果をグラフ形式で表⽰\n\nn Python\n\n                - Pythonインタプリタの起動\n\nn Script Manager\n\n\n-----\n\n#### Name\n\n\nn Ghidraではバイナリのロード時に⾃動解析して関数や変数に名前を付ける\n\n      - 関数(FUN_*)\n\n      - ⽂字列(s_*)\n\n      - ローカル変数(local_*)\n\n      - 変数(*Var*)\n\n\n-----\n\n#### Change Name\n\n\nn リネームして解析結果を反映することで、Ghidraを読みやすくしていく\n\nn 右クリックメニューから選択\n\n\n-----\n\n#### Change Function Signature\n\n\nn 関数の定義を変更する\n\n\n-----\n\n#### XREF(Cross References)\n\n\nn データの参照元の表⽰\n\n\n-----\n\n#### Change Data Type\n\n\nn 関数や変数の型の変更\n\n      - 右クリックメニューから選択\n\n\n-----\n\n# Ghidra Script\n\n\n-----\n\n#### Ghidra Script\n\n\n###### Ghidraの各種操作を⾃動化・効率化する機能\n\nn こんなことができる\n\nü バイト列の検索やコメントの付与など、⼿動作業の⾃動化\n\nü ⼤量のファイルのインポート・解析処理など、反復作業の⾃動化\n\nü 暗号化されたデータや⽂字列の復号など、解析の⾃動化\n\nü エミュレータによる実⾏\n\n\n-----\n\n#### Ghidra API\n\n\nn スクリプトからGhidraの機能にアクセスするためのAPI\n\nn JavaとPython (Jython2.7) で実装が可能\n\n###### Python実装の例\n\n\n-----\n\n#### Type of Ghidra API\n\n\nn Ghidra APIは⼤きく3つに分類でき、次のような階層構造になっている\n\n      - ほとんどの場合でFlatProgram API/Script API さえ理解していれば事⾜りる\n\n      - なにか必要な機能があったらまずはFlatProgramAPIのドキュメントを検索する\n\n###### High Layer Script API\n\nhttps://ghidra.re/ghidra_docs/api/ghidra/app/script/GhidraScript.html\n###### FlatProgram API\n\nhttps://ghidra.re/ghidra_docs/api/ghidra/program/flatapi/FlatProgramAPI.html\n###### Program API\n Low Layer\n\nhttps://ghidra.re/ghidra_docs/api/ghidra/program/model/listing/Program.html\n\n\n-----\n\n#### Script Manager\n\n\nn Ghidra Scriptの実⾏や管理を⾏う機能\n\nScript Managerの起動⼿順\n\n\n-----\n\n#### Built in Python Interpreter\n\n\nn ビルトインのPythonインタプリタが提供されている\n\n         - メニューの「Window」> 「Python」で起動\n\n\n-----\n\n#### Why Interpreter?\n\n\n###### 検証のためのトライアンドエラーに便利\n\n#### Test\n Write Code\n Analysis\n\n\n-----\n\n#### Why Interpreter? Pt.1\n\n\nn 変数内部のデータを都度確認しながら処理を記述できる\n\n\n-----\n\n#### Why Interpreter? Pt.2\n\n\nn コード補完してくれる\n\n          - ⼊⼒中にTabを押すと利⽤可能なメソッドを表⽰してくれる\n\n\n-----\n\n#### Why Interpreter? Pt.3\n\n\n**← Listingインター**\n**フェイスの実装**\n\nn APIのヘルプが参照できる **クラスだとわかる**\n\n         - help に参照したいオブジェクトを渡す\n\nインターフェイス名がわかれば検索できる\n\n**←公開メソッドの**\n**シグネチャ**\n\n\n-----\n\n#### Interpreter Tips import\n\n\nn 複数⾏にわたるペーストができないので、関数などがコピー＆ペーストできない\n\nn なので、使いたい関数やクラスをスクリプト内で定義しておき、import する\n\n         - import で読み込めるファイルはScript Directories配下に存在しているファイルのみなので、\n今回はC:¥Ghidra¥ghidra_scripts配下に配置する\n\n         - Script Directoriesに登録された別フォルダに同名のファイルが存在するとエラーの原因になるので、\nユニークにする\n\n**←get_all_functions関数が**\n**現在の名前空間に存在しない**\n**のでエラー**\n\n\n-----\n\n#### Interpreter Tips import\n\n\nn ただし、そのままだとインポートされたスクリプト側からGhidra APIを参照できないので、次の\n###### import⽂を必ずスクリプトの最初に記述しておく！（重要）\n\n\n-----\n\n#### Interpreter Tips reload\n\n\nn すでにimport済みのスクリプトを編集した後再度importするには、reload を使う\n\n     - 例えば、⼀度importしたがエラーが出たのでスクリプト内の関数を書き換えた場合など\n\n     - Pythonは⼀度importしたコードをコンパイルしてキャッシュしているので、importだけでは更新が反映さ\nれないのが原因\n\n###### 編集された関数\n\n ←この後のタイミングで編集\n\n ←reloadで編集を反映\n\n\n-----\n\n#### Interpreter Tips reload\n\n\nn ただし、from name import * でimportしている場合、↓のようにsys.module['name']を\n###### reloadしてから再インポートする必要がある\n\n 編集された関数\n\n ←この後のタイミングで編集\n\n ←reload\n\n ←再インポート\n\n\n-----\n\n#### Headless Analyzer\n\n\n###### CLIからGhidra Scriptを操作するための機能\n\nn ユーザインタラクションが不要なので、バッチ処理が可能\n\nn バッチ処理により、ファイルのインポートや解析処理の⾃動化が可能\n\n\n-----\n\n# Ghidra API Quick Reference\n\n\n-----\n\n#### FlatProgramAPI Class\n\n\n###### Program APIのラッパークラス\n\n      - https://ghidra.re/ghidra_docs/api/ghidra/program/flatapi/FlatProgramAPI.html\n\n###### Fields\n\nn protected Program currentProgram\n\n° 現在読み込んでいるプログラムに関する様々な情報を保持\nするフィールド, Program APIを提供する\n\nMethods\n\nn Address[] findBytes(Address start, java.lang.String byteString, n Instruction getInstructionBefore(Address address)\nint matchLimit) ° 指定したaddressの⼀つ⼿前（低位アドレス）の命令を取得, ⼀つ先（⾼位\n\nアドレス）の命令を取得するgetInstructionAfterもある\n\n° 指定したバイト列（Python2では⽂字列と同じ）を検索してヒットしたアド\nレス⼀覧を返す\n\nn Function getFunctionContaining(Address address)\n\nn byte[] getBytes(Address address, int length) ° 指定したaddressを含む関数を取得\n\n° 指定したaddressから指定したlength分をバイト列として取得\n\nn Reference[] getReferencesTo(Address address)\n\nn Function getFirstFunction() ° 指定したaddressの参照元（=addressを参照しているオブジェクト）⼀覧を\n\n取得\n\n\n-----\n\n##### 01. Address Manipulation\n\n\n##### 01. Address Manipulation\n\nn Address toAddr(int offset)\n\nn Address toAddr(long offset)\n\nn Address toAddr(String address)\n\n° 指定した値をAddressオブジェクトに変換\n\n###### 数値や⽂字列をAddressオブジェクトに変換し、⽐較\n\n\n-----\n\n#### Address Interface\n\n\n###### アドレスを表現するインターフェイス\n\n      - https://ghidra.re/ghidra_docs/api/ghidra/program/model/address/Address.html\n\n###### Methods\n\nn Address add(long displacement)\n\n° アドレスを引数displacementのサイズ分加算し、\n新しいAddressを返す オフセット値の取得\n\nn boolean equals(java.lang.Object o)\n\n° 引数oとアドレスを⽐較\n\nn long getOffset()\n\n° アドレスのオフセットをlongで返す\n\nn Address next()\n\n\n-----\n\n##### 02. Binary Manipulation\n\n\n##### 02. Binary Manipulation\n\nn byte[] getBytes(Address address, int length)\n\n° 指定したaddressから指定したlength分をバイト列として取得\n\nn int getInt(Address address)\n\n° 指定したaddressから4バイトをintとして取得\n\n###### 特定のアドレスから、指定したサイズ分バイト列の読み出し\n\n\n-----\n\n##### 03. Search\n\n\n##### 03. Search\n\nn Address find(java.lang.String text) n Address[] findBytes(Address start,\n\njava.lang.String byteString, int matchLimit)\n\n° プログラム内のコメントやラベル、コードユニットのやオペラン\nドなどから、引数のtextで与えられた⽂字列を検索 ° 引数startで指定したアドレス以降のメモリから、byteStringで指定\n\n° 最初にマッチした結果のアドレスが返される された値を検索\n\n° このメソッドは、byteStringで正規表現を使うことも可能、例えば\n\nn Address find(Address start, byte[] values) 任意の4バイトをマッチさせたい場合「.{4}」といった表現を使⽤可能\n\n° 第1引数にAddressオブジェクトが渡されると、引数startで指定し\nたアドレス以降のプログラムのメモリからvalueで指定したバイト\n列を検索し、最初にマッチした結果のアドレスを1つだけ返す\n\n° 正規表現はサポートされていない\n\n###### レジスタへの MOV命令を検索\n\n\n-----\n\n##### 04. Function Manipulation\n\n\n##### 04. Function Manipulation\n\nn Function getFirstFunction() n Function getFunctionBefore(Address address)\n\n° 現在のプログラムの最初の関数オブジェクトを取得 ° 引数addressで指定したアドレスで始まる関数の前の関数オブジ\n\nェクトを取得\n\nn Function getFunctionAt(Address entryPoint)\n\nn Function getFunctionContaining(Address address)\n\n° 引数entryPointで指定したアドレスから始まる関数オブジェクト\nを取得 ° 引数addressで指定したアドレスが関数のアドレスレンジに含ま\n\nれる場合、その関数オブジェクトを取得\n\nn Function getFunctionAfter(Address address)\n\n° 引数addressで指定したアドレスで始まる関数の次の関数オブジ\nェクトを取得\n\n###### プログラム内の 全関数を列挙\n\n\n-----\n\n#### Function Interface\n\n\n###### 関数を表現するインターフェイス\n\n      - https://ghidra.re/ghidra_docs/api/ghidra/program/model/listing/Function.html\n\n###### Methods\n\nn Address getEntryPoint()\n\n° 関数のエントリーポイント（先頭アドレス）を取得\n\nn java.lang.String getName()\n\n° 関数の名前を取得\n\nn Parameter[] getParameters()\n\n° 関数の引数をParameterオブジェクトで取得\n\n\n-----\n\n##### 05. Instruction Manipulation\n\n\n##### 05. Instruction Manipulation\n\nn Instruction getFirstInstruction(Function function)\n\n° 引数functionで指定した関数オブジェクトに含まれる、最初の命\n令を取得\n\nn Instruction getInstructionAt(Address address)\n\n###### 特定の関数内の全ての命令を取得\n\n° 引数addressで指定したアドレスの命令を取得\n\nn Instruction getInstructionAfter(Instruction\ninstruction)\n\n° 引数instructionで指定した命令の次（⾼位アドレス）の命令を取\n得\n\nn Instruction getInstructionBefore(Instruction\ninstruction)\n\n° 引数instructionで指定した命令の1つ前（低位アドレス）の命令\nを取得\n\n° 関数呼び出しを⾏うCALL 命令に対する引数をたどる際などに利\n⽤可能\n\n\n-----\n\n#### Instruction Interface\n\n\n###### 命令を表現するインターフェイス\n\n       - https://ghidra.re/ghidra_docs/api/ghidra/program/model/listing/Function.html\n\n###### Methods\n\nn java.lang.Object[] getOpObjects(int opIndex)\n\n° 命令に渡されているオペランドのうち、opIndexで指定されたインデックスのオブジェクト（Address, Scalar\nなど）⼀覧を取得\n\nn java.lang.String getMnemonicString()\n\n° 正確にはCodeUnitインターフェイスのメソッド\n\n° 命令のニーモニックを⽂字列として取得\n\nn PcodeOp[] getPcode()\n\n° 命令をP-Codeという中間表現に変換\n\nn Register getRegister(int opIndex)\n\n\n-----\n\n##### 06. Reference Manipulation\n\n\n##### 06. Reference Manipulation\n\n###### Ghidraはデータやコードなどのオブジェクト間の関係性を「参照」という情報として保持\n\n後方参照\n\nn Reference[] getReferencesTo(Address address)\n\n° 引数addressで指定したアドレスへの参照を持つコードユニッ\nトのアドレス⼀覧を取得\n\n° つまり、後⽅参照（クロスリファレンス）を取得\n\nn Reference[] getReferencesFrom(Address address)\n\n\n-----\n\n#### Reference Interface\n\n\n###### 参照を表現するインターフェイス\n\n      - https://ghidra.re/ghidra_docs/api/ghidra/program/model/symbol/Reference.html\n\n###### Methods\n\nn Address getFromAddress()\n\n° 参照しているコードのアドレス、つまり後⽅参照のアドレスを取得\n\nn Address getToAddress()\n\n° 参照の「宛先」アドレス、つまり前⽅参照のアドレスを取得\n\nn RefType getReferenceType()\n\n° 参照のタイプを取得\n\n° 参照タイプ: https://ghidra.re/ghidra_docs/api/ghidra/program/model/symbol/RefType.html\n\n\n-----\n\n## 02\n# Automated Analysis of EMOTET\n\n\n-----\n\n#### Goals of Malware Analysis\n\n\n###### 「解析」といっても⽬的（期待されるアウトプット）はさまざま\n\n不正かどうかの判定、およびマルウェアのファミリ名やカテゴリを\n\n###### Detection 特定する。この作業により、マルウェアの⽬的や関連する攻撃者を\n\n認識することができる（可能性がある）。\n\n###### Indicator of ネットワークやホスト内において、侵害の有無を判断するための情\n\n報を特定する。作成されるファイル名やレジストリ名、通信先情報\n\n今回は通信先情報\n\n###### Compromise などが該当する。\n\n**の抽出を⽬的とする**\n\nマルウェアの挙動・機能を含む解析レポート。Detection/IoCを含\n\n###### Report み、マルウェアの⽬的や背後の攻撃者について⾔及する。主に顧客\n\n向けに⽂章で記述される。\n\n\n-----\n\n#### EMOTET\n\n\nn 近年猛威をふるう、情報窃取兼\n###### ダウンローダー型マルウェア\n\n      - ⼤量のスパム経由で配布されるこ\nとが知られている NICTによるEMOTETスパムの着信数推移\n\n      - Human Operated Ransomware\nの起点となることもある\n\nn とにかく数が多い\n\n      - ⼤量の亜種が短時間で配布される\n\n      - かつそれぞれの検体が⼤量の\nC&C通信先をもつ\n\nhttps://blog.nicter.jp/2020/10/emotet-mail-202007-202009/\n\n\n-----\n\n#### How EMOTET works\n\n\n###### EMOTET EMOTET Macro PowerShell Spam (Loader) (Payload)\n\nメール経由で侵⼊ マクロ付き PowerShellが Rundll32.exe C&Cサーバから\nドキュメント 実⾏され、 経由で実⾏される ペイロードを取得し、\n\nEMOTET (Loader) をDL オンメモリで実⾏される\n\n\n-----\n\n#### Analysis Steps\n\n\n###### ü どうや て⾃動抽出するか？\n\n\n###### 以下のような点を解析によって明らかにし、スクリプトに落とし込む\n\n Anti- Config Packed? Analysis? Embeded?\n\n ü パックされているか？ ü ⽂字列は難読化・暗号化 ü C&Cサーバなどの情報は\n されているか？ どこに/どのような形式で\n ü パッカーのロジック\n 格納されているか？\n ü 鍵は？\n\n\n-----\n\n##### Determine Packing Logic and Do Unpack\n\n\n##### Determine Packing Logic and Do Unpack\n\n###### 他の多くのマルウェアと同じく、EMOTETもパックされており、メモリ上で ペイロードが復号されて実⾏される\n\n（ある時期の）EMOTETのアンパックロジック\n\n\n-----\n\n##### Determine Packing Logic and Do Unpack\n\n###### アンパックの⼿法はさまざま\n\nn **⼿動アンパック**\n\n   - デバッガーを使ってアンパック\n\n   - 実⾏後、マルウェア⾃⾝によってアンパックされた\n###### 領域をダンプ\n\nn **ツールによるアンパック**\n\n   - マルウェアを実⾏、メモリ上からアンパック後の領\n###### 域を機械的に抽出\n\nü PE-SIEVE / Hollows Hunter\n\nn **⾃動アンパック**\n\n   - ツールの⾃動実⾏\n\n\n##### Determine Packing Logic and Do Unpack\n\n###### アンパックの⼿法はさまざま\n\nn **⼿動アンパック**\n\n      - デバッガーを使ってアンパック\n\n      - 実⾏後、マルウェア⾃⾝によってアンパックされた\n###### 領域をダンプ\n\nn **ツールによるアンパック**\n\n      - マルウェアを実⾏、メモリ上からアンパック後の領\n###### 域を機械的に抽出\n\nü PE-SIEVE / Hollows Hunter\n\nn **⾃動アンパック**\n\n      - ツールの⾃動実⾏\n\n\n-----\n\n#### Hunter\n\n\n#### Hunter\n\nn パックされたEMOTETを実⾏し、Hollows Hunterでアンパック後のEMOTETをダンプ\n\nn 具体的な⼿順はAppendixを参照\n\n\n-----\n\n#### Unpacked EMOTET\n\n\nn 本ワークショップでは、アンパック済みのEMOTETを使⽤します\n\n###### メイン解析⽤\n\n ⽐較⽤\n\n\n-----\n\n# Step 1: Surface Analysis\n\n\n-----\n\n#### Resources\n\n\nn 使⽤するサンプル等はJSAC参加者にのみSlackで共有済み\n\nC:¥Ghidra¥ghidra_scripts配下が\n以下のような構成になっていればOK\n\nn 共有されたzipを展開し、以下⼿順を実施\n\n**1.** **scripts: 配下のファイルをC:¥Ghidra¥ghidra_scripts配下に**\nコピー\n\n         - scripts¥answers: 演習の回答なので、極⼒⾒ない\n\n**2.** **emotet.dll.gzf: Ghidraにドラッグ＆ドロップでインポート**\n\n**3.** **emotet-2.dll.gzf: Ghidraにドラッグ＆ドロップでインポ**\n\n**4.** **winapi_32.gdt: C:¥Ghidra直下にコピー**\n\n\n-----\n\n#### Setup (sample)\n\n\nn 配布したemotet.dll.gzfをGhidraの既存プロジェクトにドラッグ&ドロップしてインポート\n\n      - 途中ポップアップが出たら「OK」\n\n\n-----\n\n#### Setup (GDT)\n\n\nロード完了後、winapi_32を\n右クリックして\n\nn Ghidraの標準型データにはwininet.h、winhttp.hのAPI情報がない\n\nApply Function Data Types\n\n      - Data Type Managerでwinapi_32.gdtをロード\n\n配布したファイルに含まれる\nwinapi_32.gdtをロード\n\n   - タンを押してOpen File Archive\n\n\n-----\n\n#### Setup (scripts)\n\n\n###### スクリプトの設置\n\nn 以下スクリプトがC:¥Ghidra¥ghidra_scripts配下にコピーされているか念のため確認\n\n1. utils.py: 演習等で再利⽤可能なユーティリティ関数群\n\n2. search_hash_not_impl.py: 演習⽤⽳あきスクリプト\n\n3. make_hash_db.py: APIハッシュ⽤DB作成スクリプト\n\n4. db.json: APIハッシュ⽤DB\n\n5. emulator.py: エミュレータを使ったハッシュ計算スクリプト\n\n6. decrypt_string_stage1_not_impl.py: 演習⽤⽳あきスクリプト\n\n7. decrypt_string_stage2_not_impl.py: 演習⽤⽳あきスクリプト\n\n8. extract_c2_stage1_not_impl.py: 演習⽤⽳あきスクリプト\n\n9. extract_c2_stage2_not_impl.py: 演習⽤⽳あきスクリプト\n\n\n-----\n\n#### Exports Functions\n\n\nn DLL verのEmotetはrundll32.exeを使ってエクスポートされた関数から実⾏される\n\n\n-----\n\n#### Brief Analysis (code)\n\n\nn Garbage Code n Control Flow Flatting\n\n       - 実⾏に影響を及ぼさない無駄なコード       - Control Flow Obfuscationの⼿法\n\n       - Ghidraのデコンパイラがいい感じに端折       - 直感的に命令フローが識別しづらい\nってくれる\n\n\n-----\n\n#### Brief Analysis (API/strings)\n\n\nn アンパック後のEMOTETは n APIに関連する⽂字列もなし\n###### Import Tableが空 ○ API含む⽂字列が暗号化・難読化されている\n\n      - 動的にAPIを解決している可能性 可能性 🥺\n\n\n-----\n\n#### Where to start?\n\n\nutils.pyに定義済みのget_func_xref_count関数を実⾏し、\n呼び出し回数の多い関数を列挙\n\nn APIの動的解決や⽂字列の\n###### 復号に使⽤されている関数 は実⾏時に何度も呼び出さ れる\n\nn そのため、まずは各関数\n###### が呼び出されている回数を 調べて、呼び出し回数が多 い関数をみていくことにす る\n\n\n-----\n\n###### FUN_10017e12\n\n\nn 最も多く呼び出されてい\n###### る関数\n\nn RETするだけのジャンク\n###### 関数\n\nn 「 _ 」など適当な名前\n###### に変えておく\n\n\n-----\n\n###### FUN_10007d5b\n\n\n###### FUN_10007d5bの呼び出し例 (@0x10017e02)\n\nn 2番⽬に多く呼び出され\n###### ている関数\n\nn 4つの引数を受け取るが、\n###### 実際は第⼆引数は未使⽤\n\nn DAT_1001fa20はグロー\n###### バル変数の配列\n\n**各要素が4バイトの配列？**\n\n**第⼀引数は配列のインデックス**\n\n\n-----\n\n###### FUN_10007d5b\n\n|BEFORE|AFTER (name)|AFTER (type)|\n|---|---|---|\n|DAT_1001fa20|g_array|int[0x64]|\n|param_1|index|N/A|\n|param_2|_|N/A|\n|param_3|hex_value1|N/A|\n|param_4|hex_value2|N/A|\n\n\nn 変数名・型名の変更\n\n###### 少し⾒やすくしたFUN_10007d5b\n\n BEFORE AFTER AFTER (name) (type)\n\nDAT_1001fa20 g_array int[0x64]\n\nparam_1 index N/A\n\nparam_2 _ N/A\n\nparam_3 hex_value1 N/A\n\nparam_4 hex_value2 N/A\n\n\n-----\n\n# Step 2: API Hashing and Dynamic Call\n\n\n-----\n\n#### How Windows APIs are resolved\n\n\nFARPROC MessageBoxA = GetProcAddress(LoadLibraryA(\"user32.dll\"), \"MessageBoxA\");\nM B A(NULL \"H ll ld\" \"H ll \" MB OK)\n\n\nn **暗黙的な解決**\n\n      - コンパイル時に、必要なAPIがインポートテーブルに定義され、実⾏時にOSが暗黙的にDLLをロードし、\nAPIを解決する\n\n      - 普通にコンパイルするとこの⽅法で解決される\n\nn **明⽰的な解決（動的API解決）**\n\n      - LoadLibrary / GetProcAddress を⽤いて実⾏時に動的にAPIを呼び出す\n\n      - API名から簡単に利⽤するAPIが識別されてしまう\n\nMessageBoxAを明⽰的に解決して呼び出す例\n\nFARPROC MessageBoxA = GetProcAddress(LoadLibraryA(\"user32.dll\"), \"MessageBoxA\");\n\n\n-----\n\n#### API Hashing\n\n\nn 動的にWindows APIを解決する際に⽤いられる耐解析⼿法の⼀つ\n\nn 既知、もしくは独⾃実装のハッシュ関数でAPI名をハッシュ化して保持しておき、実⾏時に、\n###### エクスポートされたAPI名を列挙してハッシュ関数の計算結果が同じAPIを動的に呼び出す\n\n例: CRC32を使⽤してAPI名をハッシュ化し、実⾏時に⽐較して動的に解決\n\n###### コンパイル時 実⾏時\n CRC32\n\n CRC32\n ReadFile 0xD0B7641A\n\n CreateFileA 0x553B5C78 kernel32.dll WriteFile 0x3E5BC8E3\n\n擬似コード CreateFileA **0x553B5C78**\n\n\n-----\n\n###### FUN_10004ae6\n\n\nn FUN_10002b48の呼び出し\n\n    - in_FS_OFFSET (=FSレジスタ)\nへのアクセス\n\n    - x86 の場合、FSレジスタには\nTEB (Thread Environment\nBlock) へのポインタが格納さ\nれている\n\nn FUN_100180eaの呼び出し\n\n\n-----\n\n##### Process Environment Block\n\n\n##### Process Environment Block\n\nn **Thread Environment Block (TEB)**\n\n      - 現在のスレッドに関する情報を保持する構造体 FSレジスタ経由でTEBにアクセスし、\n\nそこからPEBにアクセスしている\n\n      - FSセグメントレジスタからアクセス可能\n(x86 Windowsにおいて)\n\nn **Process Environment Block (PEB)**\n\n      - 現在のプロセスに関する情報を保持する構造体\n\nØ プロセスに読み込まれているDLLや、\n\nヒープの状態、実⾏ファイルの情報など\n\n      - TEB構造体のオフセット0x30からアクセス可能\n\n\n-----\n\n##### Process Environment Block\n\n\n##### Process Environment Block\n\n\n-----\n\n#### Apply Structure\n\n\nn PEB構造体を事前定義したヘッダファイルをGhidraにインポート(すでに適⽤済み)\n\n      - File > 「Parse C Source」> win_internal.hを選択>「Parse to Program」\n\n\n-----\n\n###### FUN_10002b48\n\n|BEFORE|AFTER (name)|AFTER (type)|\n|---|---|---|\n|FUN_10002b48|get_peb|PEB *|\n|in_FS_OFFSET|teb|TEB *|\n\n\nn PEBのポインタを取得する関数\n\n     - in_FS_OFFSETをAuto Create Structure\n\n###### BEFORE AFTER AFTER (name) (type)\n\nFUN_10002b48 get_peb PEB *\n\nin_FS_OFFSET teb TEB *\n\n\n-----\n\n###### FUN_10004ae6\n\n|iVar1|peb|PEB *|\n|---|---|---|\n|puVar3|current_module_entry|LDR_DATA_TABLE_ENTRY *|\n|puVar4|next_module_entry|LDR_DATA_TABLE_ENTRY *|\n\n|Col1|Col2|\n|---|---|\n||戻り値をXORして引数と⽐較|\n\n\niVar1 peb PEB *\n\npuVar3 current_module_entry LDR_DATA_TABLE_ENTRY *\n\npuVar4 next_module_entry LDR_DATA_TABLE_ENTRY *\n\nn 読み込まれているDLLの\n###### ベースネームを列挙し、 FUN_100180eaに渡して いる\n\nn FUN_100180eaの戻り値\n###### を0x1fc325daとXOR\n\n**プロセスに読み込まれているDLLの列挙**\n\nn その結果を引数の値と\n###### ⽐較\n\n**DLLのベースネーム（ファイル名）を渡している**\n\n**戻り値をXORして引数と⽐較**\n\n\n-----\n\n###### FUN_100180ea\n\n\n1. この関数はハッシュ関数です、\nアルゴリズムを解析してくだ\nさい\n\n2. 実際はFUN_100180eaの戻り\n値を0x1fc325daとXORして\n⽐較していました。よって、\n次のように、DLLベースネ\nームとXOR鍵の⼊⼒を受け付\nけて適切なハッシュ値を返す\n関数(calc_hash)をGhidra\nScriptで実装してください\n\n\n-----\n\n###### FUN_100180ea\n\n\nn BaseDllName.Bufferの\n###### 型はwchar_t * (=unsingned short *)\n\nn 1バイトずつ以下処理\n\n      - ⼤⽂字ASCII（0x40 < x <\n0x5b）の場合、⼩⽂字\n(+0x20)に変更\n\n      - 結果を状態(iVar2)に加算\nし、0x1003fを乗算\n\nn 結果のint値を返す\n\n\n-----\n\n###### FUN_100180ea\n\n\nn DLLベースネームとXOR鍵を受け取り、ハッシュ値を返す関数\n\n\n-----\n\n###### FUN_10004ae6\n\n|param_1|hashed_dllname|N/A|\n|---|---|---|\n|uVar1|hashed|N/A|\n|FUN_10004ae6|find_lib|N/A|\n\n\nparam_1 hashed_dllname N/A\n\nuVar1 hashed N/A\n\nn calc_hash_case_insensit FUN_10004ae6 find_lib N/A\nive関数の呼び出し元に戻る\n\nn これまでの結果から、DLL名\nをハッシュ化した値を受け取\nり、ロード済みDLLの中から\n該当するDLLを探してベース\nアドレスを返す関数だとわか\nる\n\n     - ベースアドレス: メモリに\nロードされているDLLのPE\nヘッダへのポインタ\n\nn 関数名を「find_lib」に\n###### 変えておく\n\n\n-----\n\n#### PE Header Overview\n\n\n###### Windows実⾏可能形式(PE)の ファイルフォーマット\n\nn 実⾏ファイルに関する様々な\n情報を保持している\n\n     - **Export Table**\n\nØ エクスポート関数⼀覧\n\n     - **Import Table**\n\nØ 使⽤するAPI⼀覧\n\n\n-----\n\n###### FUN_10012794\n\n\n###### なにもわからない\n\n\n-----\n\n###### FUN_10012794\n\nn エクスポート関数の⼀覧を保持する\nエクスポートテーブルにアクセスしている\n\n型を適⽤すると都度変数名が変わってしまうので、変更”前”\n\nBEFORE AFTER (name) AFTER (type)\n\nparam_2 base_address N/A\n\nparam_4 hashed_api N/A\n\niVar1 nt_headers IMAGE_NT_HEADER32 *\n\npcVar8 export_table IMAGE_EXPORT_DIRECTORY *\n\niVar2 functions_rva N/A\n\niVar3 names_rva N/A\n\niVar4 ordinals_rva N/A\n\nuVar5 value N/A\n\nuVar6 i N/A\n\n|BEFORE|AFTER (name)|AFTER (type)|\n|---|---|---|\n|param_2|base_address|N/A|\n|param_4|hashed_api|N/A|\n|iVar1|nt_headers|IMAGE_NT_HEADER32 *|\n|pcVar8|export_table|IMAGE_EXPORT_DIRECTORY *|\n|iVar2|functions_rva|N/A|\n|iVar3|names_rva|N/A|\n|iVar4|ordinals_rva|N/A|\n|uVar5|value|N/A|\n\n\n**DLLのベースアドレス、つまり**\n**IMAGE_DOS_HEADERへの** **OptionalHeader.DataDirectoryは**\n\nn エクスポート関数の⼀覧を保持する **ポインタが引数に渡されている** **さまざまなデータを格納する連想配列で**\nエクスポートテーブルにアクセスしている **インデックス0にはExport Tableへの**\n\n**オフセットが格納されている**\n\n型を適⽤すると都度変数名が変わってしまうので、変更”前”の変数名で表記\n\n**エクスポート関数のRVAの配列**\n\nBEFORE AFTER (name) AFTER (type) **エクスポート関数名のRVAの配列**\n\n**エクスポート関数の序数のRVAの配列**\n\nparam_2 base_address N/A **エクスポート関数名を列挙**\n\nparam_4 hashed_api N/A\n\niVar1 nt_headers IMAGE_NT_HEADER32 *\n\n**エクスポート関数のアドレスを取得**\n\npcVar8 export_table IMAGE_EXPORT_DIRECTORY *\n\n**エクスポート関数のアドレスが**\n\niVar2 functions_rva N/A\n\n**フォワードされたものか確認**\n\niVar3 names_rva N/A\n\niVar4 ordinals_rva N/A\n\nuVar5 value N/A\n\n\n-----\n\n###### FUN_10012794\n\nn 列挙したエクスポート関数\n###### をFUN_1000df50に渡す\n\nn 戻り値を0x5a80eaeとXOR\n\nn XORした結果を第四引数と\n###### ⽐較\n\nn 合致した場合、対象APIの\n###### アドレスを返す\n\nn Export ForwardされたAPIは\n###### 別途APIを解決\n\n※ f dと\n\n\nn 列挙したエクスポート関数\n###### をFUN_1000df50に渡す\n\nn 戻り値を0x5a80eaeとXOR\n\nn XORした結果を第四引数と\n###### ⽐較\n\nn 合致した場合、対象APIの\n###### アドレスを返す\n\nn Export ForwardされたAPIは\n###### 別途APIを解決\n\n\n-----\n\n###### FUN_1000df50\n\n\nn API名が渡される関数\n\nn ほぼ\n###### calc_hash_case_insen sitiveと同じ（⼩⽂字 変換処理がない）\n\n\n-----\n\n#### Calcurate Hash\n\n\nFUN_10012794関数内にハードコードされたXOR鍵\n\nn Pythonで実装\n\n呼び出し元の例 (@0x10017e02) 合致している\n\n\n-----\n\n#### (Advanced) Calcurate Hash by Emulator\n\nn アルゴリズムの実装がわからなくても、Emulatorで実⾏してしまうことも可能\n\n###### 1. （エミュレータ内の）ECXに⽂字列を格納（=引数に渡す）\n\n 2. 0x1001285aから0x10012864まで実⾏\n\n 3. EAXに格納されている値（=ハッシュ化済みの⽂字列）を取得\n\n\nn アルゴリズムの実装がわからなくても、Emulatorで実⾏してしまうことも可能\n\n###### 1. （エミュレータ内の）ECXに⽂字列を格納（=引数に渡す）\n\n 2. 0x1001285aから0x10012864まで実⾏\n\n 3. EAXに格納されている値（=ハッシュ化済みの⽂字列）を取得\n\n\n-----\n\n###### emulator.py\n\n\nn Ghidraが提供している\n###### EmulatorHelperクラス を使⽤し、エミュレータ を実装\n\n\n-----\n\n#### (Advanced) Calcurate Hash by Emulator\n\n\n###### GhidraのEmulatorでハッシュ関数をエミュレート\n\n 実際に渡されているハッシュ値\n\n\n-----\n\n###### FUN_10007d5b\n\n|BEFORE|AFTER (name)|\n|---|---|\n|FUN_10007d5b|resolve_api|\n|FUN_10004ae6|find_lib|\n|FUN_10012794|find_api|\n\n|BEFORE|AFTER (name)|\n|---|---|\n|param_1|index|\n|param_2|hashed_dll_name|\n|param_3|hashed_api_name|\n|g_array|g_api_table|\n|pcVar1|api|\n\n\n###### BEFORE AFTER (name) BEFORE AFTER (name)\n\nparam_1 index FUN_10007d5b resolve_api\n\n###### 引数のハッシュ値をもとに param_2 hashed_dll_name FUN_10004ae6 find_lib APIを動的解決し、グローバ param_3 hashed_api_name FUN_10012794 find_api ル変数にキャッシュ\n\ng_array g_api_table\n\npcVar1 api\n\n\n-----\n\n#### Anti API Hashing\n\n###### プログラム内のハッシュ値⼀覧を取得し、API名を逆解決してコメントをつけたい\n\n1. Hash DBの作成\n\n1. API Hashに使⽤するXOR鍵を特定\n\n2. System32配下の主要なDLLのエクスポート関数名をハッシュ化\n\n2. ハッシュ値とDBを突合\n\n1. スタックに積まれているスカラー値を全て取得\n\n2. Hash DBに登録済みのハッシュ値と突合\n\n3. コメントをつける\n\n1 呼び出されるAPI名をコ ド上にコメント\n\n\n###### プログラム内のハッシュ値⼀覧を取得し、API名を逆解決してコメントをつけたい\n\n1. Hash DBの作成\n\n1. API Hashに使⽤するXOR鍵を特定\n\n2. System32配下の主要なDLLのエクスポート関数名をハッシュ化\n\n2. ハッシュ値とDBを突合\n\n1. スタックに積まれているスカラー値を全て取得\n\n2. Hash DBに登録済みのハッシュ値と突合\n\n3. コメントをつける\n\n\n-----\n\n#### Create Hash DB\n\n\n###### make_hash_db.py\n\nn %windir%¥System32¥*.dll\n###### (今回は簡略化のため⼀部 DLLのみ)に定義されている エクスポート関数を列挙\n\nn 検体内にハードコードされて\n###### いたXOR鍵で関数名をエンコ ードし、↓形式のjsonで格納\n\n     - _<HASH>: <ORIG_NAME>_\n\n\n-----\n\n#### Create Hash DB\n\n\n###### make_hash_db.py\n\nn 出⼒されたdb.json\n\n\n-----\n\n#### Lookup Hashes\n\n\n###### Decompile View at FUN_10017d5a\n\nn DLL名とAPI名のハッシ\n###### ュ値はresolve_api関数 の引数に渡されている\n\nn 値はスタック経由で渡さ\n###### れている\n\nn 雑だが、PUSH命令の引 Listing View at FUN_10017d5a\n###### 数に渡されているスカラ ー値が取得できればよさ そう\n\n\n-----\n\n#### Lookup Hashes\n\n\nn プログラム内の全命令を列挙\n\nn PUSH命令の引数に渡された\nスカラー値を取得\n\nn 値をDB内のハッシュ値と⽐\n較\n\nn 合致したらコメント・ブック\nマークをつける\n\n\n-----\n\n#### Lookup Hashes\n\n\n###### 演習\n\n\nn 与えられた命令がスカラー値をPUSHするものかチェックする関数を実装し、\nsearch_hash_not_impl.pyを完成させてください\n\n###### search_hash_not_impl.py\n\n\n-----\n\n#### Lookup Hashes\n\n\n###### 演習\n\n\nn 与えられた命令がスカラー値をPUSHするものかチェックする関数を実装し、\nsearch_hash_not_impl.pyを完成させてください\n\nn ヒント:\n\n     - inst.getMnemonicString()\n\n     - Inst.getOpObjects()\n\n###### search_hash_not_impl.py\n\n\n-----\n\n#### Lookup Hashes\n\n\n###### 演習\n\n\nn 与えられた命令がスカラー値をPUSHするものかチェックする関数を実装し、\nsearch_hash_not_impl.pyを完成させてください\n\n###### 実装したsearch_hash.py\n\n\n-----\n\n#### Run Ghidra Script\n\n\nn Script Managerで実⾏\n\n１. Script Manager起動\n\n３. 参照するDBを指定（make_hash_db.pyで作成したjson）\n\n２. スクリプト名を検索して実⾏\n\n\n-----\n\n#### Run Ghidra Script\n\n\nコンソールに実⾏結果が表⽰されている\n\n※コメントが表⽰されない場合、\nEdit > Tool Options > Decompiler > Display の\n\nAPI名・DLL名のコメントがついている 「Display EOL Comments」が有効化されていない可能性\n\n\n-----\n\n#### Other API Hash Search Script\n\n\nn EMOTETは、ハッシュ関数に使⽤されるXOR鍵が検体ごとに異なるため、検体ごとにDBを作成\n###### する必要があるが、既知のアルゴリズムが使⽤されている場合は、既成のDBを使⽤してルック アップすれば、ハッシュ関数の詳細をしらなくてもAPI Hashを解決できる場合がある\n\n      - shellcode_hash_search.py (Ghidra)\n\n         - https://github.com/AllsafeCyberSecurity/ghidra_scripts/blob/master/shellcode_hash_search.\npy\n\n      - shellcode_hashes_search_plugin.py (IDA)\n\n         - [https://github.com/fireeye/flare-ida/tree/master/shellcode_hashes](https://github.com/fireeye/flare-ida/tree/master/shellcode_hashes)\n\n\n-----\n\n# Step 3: Decrypt Strings\n\n\n-----\n\n#### Defined Strings\n\n\nn アンパック後のEMOTETには、不正活動に関連する可読⽂字列が存在しない\n\nn ⽂字列も暗号化・難読化されている可能性がある\n\nWindow > Defined Strings から\nプログラム内の可読⽂字列を表⽰できる\n\n\n-----\n\n#### Where is Decryption Function?\n\n\nn ⽂字列が暗号化されている場合、実⾏時に復号関数が呼び出されているはず\n\nn 復号関数は何度も呼び出されているはず\n\n**なにもしない関数**\n**resolve_api関数**\n\n**メモリ確保関数**\n**メモリ解放関数**\n\n**メモリ解放関数のラッパー**\n\n**？？？**\n\n\n-----\n\n###### FUN_1000732d\n\n\n###### 演習\n\n\n###### ⽐較的複雑な関数\n\n1. ロジックを解析してください\n\nü 17~24、35~50⾏に集中する\nといいかも\n\n2. 復号スクリプト\ndecrypt_string_stage1_not\n_impl.pyのdecrypt_string関\n数を実装してください\n\n\n-----\n\n###### FUN_1000732d\n\n\n###### ⾒やすくするヒント①\n\nn オフセットでアクセスされ\n###### ている場合、構造体を使⽤ param_2を右クリック> Auto Create Structure している可能性がある\n\nn Ghidraは独⾃構造体を⾃動\n###### で識別できない\n\nn Auto Create Structureで\n###### 構造体を⾃動定義し、指定\n\n変更後\n\n###### した変数に適⽤できる\n\n\n-----\n\n###### FUN_1000732d\n\n\n###### ⾒やすくするヒント②\n\nn 同じレジスタが異なる⽤途 **uVar8を右クリック>**\n\n**Split Out As New Variable**\n\n###### で使いまわされている場合、 変数名が付けづらい問題\n\nn Split Out As New Variable\n###### で変数を分割すると⾒やす くなる\n\n**後者がuVar9として再定義された**\n\n\n-----\n\n###### FUN_1000732d\n\n1. 第２引数に、「暗号化された⽂字列に関す\nる情報を保持する構造体」へのポインタが\n渡されている\n\n    - オフセット+0: XOR鍵\n\n    - オフセット+4: XOR鍵でエンコードされた、\n復号後⽂字列のサイズ\n\n    - オフセット+8: 暗号データ\n\n2. 4バイトで割り切れるサイズに調整\n\n3. 復号⽂字列を格納するために、\n②のサイズ*2バイト分のバッファ確保\n\n4. enc_dataがemptyでないかチェック\n\n5. 復号処理\n\n1. 4バイトを1チャンクとして処理\n2. 4バイト分ポインタを進める\n3. XOR鍵でデコード\n4. 下位バイトから順にバッファにコピー\n\n\n###### ❶\n\n ❷\n\n1. 第２引数に、「暗号化された⽂字列に関す\nる情報を保持する構造体」へのポインタが **❸**\n渡されている\n\n         - オフセット+0: XOR鍵\n\n         - オフセット+4: XOR鍵でエンコードされた、\n復号後⽂字列のサイズ **❹**\n\n         - オフセット+8: 暗号データ\n\n2. 4バイトで割り切れるサイズに調整\n\n3. 復号⽂字列を格納するために、 **❺-❶**\n\n**❺-❷**\n\n②のサイズ*2バイト分のバッファ確保\n\n**❺-❸**\n\n4. enc_dataがemptyでないかチェック\n\n5. 復号処理\n\n**❺-❹**\n\n1. 4バイトを1チャンクとして処理\n2. 4バイト分ポインタを進める\n3. XOR鍵でデコード **❺-❺**\n4. 下位バイトから順にバッファにコピー\n\n\n-----\n\n#### String Decryption Algorithm\n\n\nn 先頭4バイトがXOR鍵（keyと\nする）\n\nn オフセット+4から4バイトが\nXORされた（平⽂の）サイズ\n（xored_lengthとする）\n\nn key ^ xored_length が平⽂のサ\nイズとなる（orig_lengthとす\nる）\n\nn オフセット+8以降から\norig_length分が暗号⽂\n\n\n-----\n\n#### Decrypt Strings: Logic\n\n|Col1|key|Col3|\n|---|---|---|\n||||\n|xored_length|||\n||enc||\n\n\n暗号⽂字列のデータはEDX経由で復号関数 (FUN_1000732d) に渡されている\n\n解析結果をもとにGhidra Scriptで復号処理を実装\n\n**key**\n\n**xored_length**\n\n**enc**\n\n\n-----\n\n#### Decrypt Strings: Logic\n\n\nn ⽳埋め部分を実装\n\n実装したdecrypt_string_stage1.pyのdecrypt_string関数\n\n\n-----\n\n#### Decrypt Strings: How to get arguments?\n\n\nn ここまでで、暗号データ FUN_1000732dの参照元を辿ると、EDX経由でアドレスが渡されている\n###### のアドレスがわかれば⽂ 字列を復号できることが わかった\n\nn 暗号データのアドレスは\n###### EDXレジスタ経由で復号 関数（FUN_1000732d） の第２引数として渡され ている\n\n\n-----\n\n#### Decrypt Strings: How to get arguments?\n\n\n###### ただし、例外もある\n\nn FUN_1000732dの「呼び出し元の関数の引数」として\n###### アドレスが渡されているケース\n\nn 本来は対応すべきだが、今回は無視することにする\n\n**暗号データのアドレスが呼び出し元関数の**\n**引数として渡されている**\n\n\n-----\n\n#### Decrypt Strings: How to get arguments?\n\n\nn 復号関数（FUN_1000732d）の\n###### 呼び出し元の直前の命令を取 得し、EDXにMOVされている アドレスを取得\n\nn 特定のアドレスの直前の命令\n###### を取得するためのユーティリ ティ関数\n\nEDXにMOVしてる命令だけフィルター\n\n###### get_instructions_beforeが utils.pyに定義済み\n\n\n-----\n\n#### Decrypt Strings: Assemble codes\n\n\nn 復号関数のアドレスはとりあえずハードコードしておく\n\ndecrypt_string_stage1.pyのmain関数\n\n\n-----\n\n#### Decrypt Strings: Run\n\n\n復号後の⽂字列がコメントされている\n\nn Script Manager経由で\n###### decrypt_string_stage1.pyを実⾏\n\n実⾏結果はコンソールに出⼒される\nWindow > Bookmark からもコメントを確認できる\n\n\n-----\n\n#### Decrypt Strings Stage2\n\nn 復号関数のアドレスは常に固定とは限らない\n\nn 復号関数を都度⼿動で解析して特定していては⾃動化の意味がない\n\n###### 複数サンプルを解析し、 復号関数内の共通する特徴的な命令列を⾒つけ出し、 それをもとに復号関数を⾃動特定する\n\n 本演習は自主学習にします。\n\n A di に課題と解法が書いてあるので興味のある方はトライしてみてください\n\n\nn 復号関数のアドレスは常に固定とは限らない\n\nn 復号関数を都度⼿動で解析して特定していては⾃動化の意味がない\n\n###### 複数サンプルを解析し、 復号関数内の共通する特徴的な命令列を⾒つけ出し、 それをもとに復号関数を⾃動特定する\n\n 本演習は自主学習にします。\n\n\n-----\n\n# Step 4: Config Structure Analysis\n\n\n-----\n\n#### Config Structure Analysis\n\n\nn EMOTETは通信先を検体内にハードコードしている\n\nn 通信関連のAPIを辿り、ハードコードされた通信先情報の取得を試みる\n\nBookmarksから、search_hash.pyでみつけた\n通信関連のAPIを確認できる\n\n\n-----\n\n#### Find Hostname & Port\n\nn InternetConnectW API\n\nn InternetConnectWを呼び出\n###### しているFUN_10002b4fの第 七引数にホスト名、第４引数 にポート番号が渡されている\n\n\nn InternetConnectW API\n\npcVar1をRetype Variableで\nInternetConnectW *型に変更した後、\n引数名や型を⼿動で変更する\n\nn InternetConnectWを呼び出\n###### しているFUN_10002b4fの第 七引数にホスト名、第４引数\n\n\n-----\n\n#### Find Hostname & Port\n\nn call_internetconnectw\n（FUN_10002b4f）の呼び出し\n元を辿ると、FUN_1000f70cが\n呼び出していることがわかる\n\nn ホスト名が渡されている第七引\n数は、FUN_1000f70cの第引数\nから渡されている\n\nn ポート番号が渡されている第４\n引数には、in_stack_00000024\nという変数が渡されている\n\n   - 実際はポート番号も\nFUN_1000f70cの引数として渡さ\nれているのだが、Ghidraが関数の\n解析に失敗していて、解釈がおか\nしくな ている\n\n\nFUN_1000f70c内でcall_internetconnectwを呼び出している部分\n\nn call_internetconnectw **↓ポート番号**\n（FUN_10002b4f）の呼び出し\n\n**ホスト名→**\n\n元を辿ると、FUN_1000f70cが\n呼び出していることがわかる\n\ncall_internetconnectwに渡されているホスト名はFUN_1000f70cの第⼆引数から渡される\n\nn ホスト名が渡されている第七引\n数は、FUN_1000f70cの第引数\nから渡されている\n\nn ポート番号が渡されている第４\n引数には、in_stack_00000024\nという変数が渡されている\n\n     - 実際はポート番号も\nFUN_1000f70cの引数として渡さ\nれているのだが、Ghidraが関数の\n解析に失敗していて、解釈がおか\n\n\n-----\n\n#### Fix Function: FUN_1000f70c\n\n\nn FUN_1000f70cの引数の解釈にGhidraが失敗している\n\nn そのため、Edit Function Signatureで引数の数を調整する\n\nFUN_1000f70cの呼び出し元を⾒てみると FUN_1000f70cを右クリック> Edit Function Signatureで編集\nECX, EDX, PUSH*9で引数を渡している Add Parameterで引数の数が合計11になるまで追加\n\n\n-----\n\n#### Fix Function: FUN_1000f70c\n\n\nn 正しく引数の数を調整すると、FUN_1000f70cの第１１引数にポート番号が渡され、\n###### call_internetconnectwの第４引数に渡されていることがわかる\n\nn FUN_1000f70cの呼び出し元でも引数が反映されている（名前は⼿動で変更）\n\n\n-----\n\n###### FUN_10007e95\n\n\nportがアサインされている箇所\n\nn FUN_1000f70cを呼び出して\n###### いる関数がFUN_10007e95\n\nn portへのアサインは⾒える\n###### が、hostnameがどこからア サインされているかわから ない\n\nn ポート番号はDAT_1001fa08 DAT_1001fa08に対し、Create Auto Structureで構造体定義\n###### からのオフセット0x24+0x4 に格納されている\n\n     - → 構造体として定義してお\nく\n\n\n-----\n\n###### FUN_10017f0f\n\n\nIPアドレスのようなフォ マット⽂字列が渡される\n\n\nn フォーマット⽂字列を第１１\n引数として受け取る\n\n     - IPアドレスのようなフォーマ\nット\n\nn FUN_10017f0fは、実質\n_snwprintfを呼び出すだけ\n\n\n-----\n\n###### Fix Function: FUN_10017f0f\n\n\nn ⼀⾒問題ないようだが、実は呼び出し 関数シグネチャ修正後、変数名・型を変更した結果\n\n（param_2とextraout_EDXは実際同⼀だが、変数名が同期されず、今回は無視）\n\n規約と引数の数が間違っている\n\n     - __cdecl -> __fastcall\n\n     - 引数の数-> 14\n\nEdit Function Signatureで修正\n\n\n-----\n\n#### Config Structure\n\n|第２オクテット|Col2|\n|---|---|\n|第３オクテット||\n|||\n|クテット||\n\n\nn call_snwprintfでホスト名（IP）が⽣成されることがわかった\n\nn IPアドレスの各オクテットがcall_snwprintfの引数に渡されている\n\nn ここまでの情報から、0x1001fa08には次のような構造体へのポインタが存在していると推測できる\n\nü オフセット+0x24にはIPアドレスへのポインタが格納されているはず\n\nü IPアドレスはリトルエンディアンの4バイト（1オクテット1バイト）\n\nü また、オフセット+0x24+0x4にポート番号が格納されているはず\n\n**第２オクテット**\n\n**第３オクテット**\n\n**第１オクテット**\n\n**第４オクテット**\n\n\n-----\n\n#### Config Structure\n\n\nData Type Manager > emotet.dll 右クリック> New > Structure でC2Infoを新規作成し、\n次にPTR_1001fa08を右クリック> Edit Data Type からオフセット36をC2Info*に変更\n\n\n###### typedef struct { ... // at offset 0x24 C2Info *c2; } Config;\n\n\nData Type Manager > emotet.dll 右クリック> New > Structure でC2Infoを新規作成し、\n次にPTR_1001fa08を右クリック> Edit Data Type からオフセット36をC2Info*に変更\n\nn ここまでの情報をまとめて、\n###### 次のような構造体を定義\n\n擬似構造体\n\n###### typedef struct {\n byte ip_address[4]; WORD port; } C2Info;\n\n typedef struct { ... // at offset 0x24 C2Info *c2; } Config;\n\n\n-----\n\n#### Config Structure\n\n\nn 構造体が適⽤されると⾒やすくなる\n\nn ここで⽣成されたIPアドレスとポート番号が、先ほど解析したFUN_1000f70cに渡され、通信が\n###### 発⽣する\n\nn つまり、これらのIPアドレスとポート番号がC&Cサーバの情報となることがわかる\n\n\n-----\n\n#### Config Structure\n\n\ng_configの参照元⼀覧を確認すると、\n\nn g_config(PTR_1001fa08)\n\nWRITEしているのは0x100e258の⼀箇所のみ\n\n###### はポインタを保持するだけ のグローバル変数なので、 Config構造体の実態への ポインタは実⾏時に格納さ れる\n\nn では、いつ・どこで初期化\n###### されるのか？\n\n\n-----\n\n###### FUN_1000e10b\n\n\nConfig構造体をアップデ トした後のコ ド\n\n\nConfig\n\n###### Config構造体を初期化する関数\n\n1. Config構造体⽤のバッファ\n###### を確保し、g_configへポイ ンタをコピー\n ❶\n\n2. DAT_1001f000からC2Info\n\n###### ❷\n 構造体のポインタをコピー\n ❸\n\n3. DAT_1001f000には、1要素\n###### あたり8バイトの配列が格 納されている\n\n\n-----\n\n###### FUN_1000e10b\n\n\n編集後のFUN_1000e10b\n\nn 現在C2Info構造体は6バイトなので、（使⽤⽤\n途は不明だが）2バイト分追加しておく\n\nn DAT_1001f000(g_c2info_array)をRetype\nGlobalし、C2Info構造体の配列として定義\n\n\n-----\n\n#### Array of C2Info\n\n\nn DAT_1001f000(g_c2inf\n###### o_array) にはIPアドレ C2Info ス、ポート番号が平⽂で 格納されている\n\nn このデータをパースすれ\n###### ば通信先情報を取得でき そう\n\n**ip_address**\n\n**port**\n\n**C2Info** **ip_address**\n\n**port**\n\n**C2Info**\n**ip_address**\n\n\n-----\n\n#### Protocol of Connection\n\n\n###### IPとポートは判明したが、プロトコル(HTTP/HTTPS)は？\n\nn HTTPSを使う場合、WinInet系APIではHttpOpenRequestのdwFlagsで\n###### INTERNET_FLAG_SECURE(0x800000)が指定される\n\nHttpOpenRequestの関数シグネチャ\n\n\n-----\n\n#### Protocol of Connection\n\n\n###### HttpOpenRequestWの呼び出し元を辿ると、INTERNET_FLAG_SECURE(0x800000)のビットは ⽴っていないので、プロトコルはHTTPが使⽤されることがわかる\n\n\n-----\n\n#### Extract C2 in Action\n\n\nextract_c2_stage1_not_impl.py\nのparse_single_configを実装し **C2Info**\nてください\n\nn アドレス0x1001f000以降に存\n在しているIPアドレスとポート\nを以下形式で出⼒する\n\n     - http://<ip-address>:<port> **ip_address**\n\n**port**\n\n**C2Info** **ip_address**\n\n**port**\n\n**C2Info**\n**ip_address**\n\n\n-----\n\n#### Extract C2 in Action\n\n\n1. g_c2info_arrayの先頭アドレスか\nら処理を進める\n\n2. 先頭4バイトをIPアドレス、オフセッ\nト+4から2バイトをポート番号とし\nてパース\n\n3. 8バイト(C2Info構造体のサイズ)分\nアドレスを進める\n\n\n-----\n\n#### Extract C2 Stage2\n\n\nn コンフィグのアドレスは常に固定とは限らない\n\nn コンフィグのアドレスを都度⼿動で解析・特定していては⾃動化の意味がない\n\n###### 複数サンプルを解析し、コンフィグ初期化関数内で 共通する特徴的な命令列を⾒つけ出し、 それをもとにコンフィグのアドレスを⾃動特定する\n\n\n-----\n\n#### How to compare samples?\n\n\n###### Version Tracking\n\nn 2つのバイナリの差分を解析するGhidraの機能\n\n      - パッチの差分解析\n\n      - 共通する命令列の可視化\n差分表⽰の例\n\n\n-----\n\n#### Version Tracking: Main Window\n\n\nn Version Trackingで、関数を⽐較したりする際に使⽤するウィンドウ\n\nn 最初はなにも表⽰されない\n\nGhidraのプロジェクト画⾯から開く Version Tracking Windowの初期画⾯\n\n\n-----\n\n#### Version Tracking: Session\n\n\n###### バイナリの⽐較結果をSessionという情報として保持\n\nn Sessionの作成⼿順\n\n1. Version Tracking Window > [Create a new Version Tracking Session]\n\n2. Source ProgramとDestination Programを指定\n\n3. [Run Precondition Checks]を実⾏\n\n###### ❶\n\n ❷\n\n ❸\n\n\n-----\n\n#### Version Tracking: Compare Functions\n\n\nVersion Tracking Functionsを使うと、⽐較したい関数を⼊⼒すると差分が可視化できる\n\n(emotet.dllの0x1000e10bとemotet-2.dllの0x1001a094の⽐較例)\n\n**ブルー: ⼀致していない**\nコードユニット\n\n**グレー: 部分的に⼀致し**\nていないコードユニット\n\n**グリーン: バイト列、ニ**\nーモニック、オペランド\nのいずれかが異なってい\nる箇所\n\n\n-----\n\n#### Decrypt Strings Stage2: Find Function\n\n\n###### 演習\n\n\n###### extract_c2_stage2_not_impl.pyのfind_config_addrssを実装する\n\n1. Version Trackingで複数サンプルの命令列を⽐較\n\n           - Source -> emotet.dll: 0x1000e10b (Version Tracking Functionsで検索するときは0xをとる)\n\n           - Destination -> emotet-2.dll: 0x1001a094 (Version Tracking Functionsで検索するときは0xをとる)\n\n2. 共通する“特徴的な”命令列を特定\n\n3. 特徴的な命令列を含む関数⼀覧をスクリプトで取得\n\nextract_c2_stage2_not_impl.pyのfind_config_addrss\n\n\n-----\n\n#### Decrypt Strings Stage2: Find Function\n\n\nn Version Trackingで複数サンプル内の命令列を⽐較\n\nn 共通する特徴的な命令列を特定する\n\nたとえばこのあたり\n\nデコンパイル結果\n\n\n-----\n\n#### Decrypt Strings Stage2: Find Function\n\n\nn 特徴的な命令列を検索し、それの命令の引数に渡されているアドレスを取得\n\n      - Address[] findBytes(Address start, java.lang.String byteString, int matchLimit)\n\nØ 正規表現をつかった検索が可能\n\n      - Instruction getInstructionAt(Address address)\n\nØ 引数addressで指定したアドレスの命令を取得\n\n**レジスタや変数など、コンパイラ等によ**\n**って可変なものは「.」(任意の⼀⽂字) に**\n**して⼀般化する**\n\n\n-----\n\n#### Decrypt Strings Stage2: Fully Automated\n\n\nfind_config_addressを実装したextract_c2_stage2.pyとして emotet.dllおよびemotet-2.dllで⾃動抽出が可能に\n保存して実⾏\n\n\n-----\n\n# Summary\n\n\n-----\n\n#### Ghidra Script for EMOTET\n\n\n1. APIハッシュの突合\n\n      - search_hash.py\n\n2. ⽂字列の復号\n\n      - decrypt_string_stage1.py\n\n3. C&C情報の抽出\n\n      - extract_c2_stage1.py\n\n      - extract_c2_stage2.py\n\n\n-----\n\n#### (Advanced) It s Automatic!\n\n\nn extract_c2_stage2.pyをHeadless対応したanalyzer.pyを\n###### Headless Analyzerで実⾏すればバッチ処理も可能 出⼒されたresolt.json (抜粋)\n\nHeadless AnalyzerでCLI経由でanalyzer.pyを実⾏\n\n\n-----\n\n#### Conclusion\n\n\nn 解析⾃体を⽬的とするのではなく、⾃動化を⽬的にするとスケールする\n\nn 解析コードの共有により、知識をサイロ化させない・再利⽤可能にする\n\n      - 解析結果だけでなく、再利⽤可能なコードとして共有する（Analysis as a Code）\n\n      - Ghidra Scriptは誰でも再利⽤可能なので、有効な選択肢の⼀つ\n\n      - 解析者にもGithubificationが広がると、コミュニティ全体の能⼒が向上する\n\nØ The Githubification of InfoSec: https://medium.com/@johnlatwc/the-githubification-of-infosec-\nafbdbfaad1d1\n\n\n-----\n\ncontact: @PINKSAWTOOTH\n\n\n### THANKS!\n\nif you have any, please let us know, friend.\n\ncontact: @PINKSAWTOOTH\n\n\n-----\n\n###### CREDITS\n\n            - Ghidra Logo by NSA\n\n           - Presentation template by Slidesgo\n\n           - Icons by Flaticon\n\n           - Twemoji by Twitter, Inc and other contributors is licensed under CC-BY 4.0\n\n           - Allsafe Logo inspired by Mr.Robot\n\n\n-----\n\n# Appendix\n\n\n-----\n\n# Homework: Decrypt Strings Stage 2\n\n\n-----\n\n#### Decrypt Strings Stage2\n\n\nn 復号関数のアドレスは常に固定とは限らない\n\nn 復号関数を都度⼿動で解析して特定していては⾃動化の意味がない\n\n###### 複数サンプルを解析し、 復号関数内の共通する特徴的な命令列を⾒つけ出し、 それをもとに復号関数を⾃動特定する\n\n\n-----\n\n#### Decrypt Strings Stage2: Find Function\n\n\n###### 演習\n\n\n###### decrypt_string_stage2_not_impl.pyのfind_decrypt_string_funcを実装する\n\n1. Version Trackingで複数サンプルの命令列を⽐較\n\n           - Source -> emotet.dll: 0x1000732d (Version Tracking Functionsで検索するときは0xをとる)\n\n           - Destination -> emotet-2.dll: 0x10006aba (Version Tracking Functionsで検索するときは0xをとる)\n\n2. 共通する“特徴的な”命令列を特定\n\n3. 特徴的な命令列を含む関数⼀覧をスクリプトで取得\n\ndecrypt_string_stage2_not_impl.pyのfind_decrypt_string_func\n\n\n-----\n\n#### Decrypt Strings Stage2: Find Function\n\n\nn Version Trackingで複数サンプル内の命令列を⽐較\n\nn 共通する特徴的な命令列を特定する\n\nたとえばこのあたり\n\nデコンパイル結果\n\n\n-----\n\n#### Decrypt Strings Stage2: Find Function\n\n\nn 特徴的な命令列を検索し、それらの命令列を含んでいる関数⼀覧を取得\n\n      - Address[] findBytes(Address start, java.lang.String byteString, int matchLimit)\n\nØ 正規表現をつかった検索が可能\n\n      - Function getFunctionContaining(Address address)\n\nØ 指定したアドレスを含む関数を取得\n\n**レジスタや変数など、コンパイラ等によって**\n**可変なものは「.」(任意の⼀⽂字) にして⼀般化する**\n\n\n-----\n\n#### Decrypt Strings Stage2: Fully Automated\n\n\n実装したスクリプトをdecrypt_string_stage2.pyとして保存して実⾏\n\n複数の復号関数を⾒つけ、\n引数に渡されている⽂字列を復号している\n\n\n-----\n\n# How to get unpacked samples by yourself\n\n\n-----\n\n##### samples by yourself\n\n\n##### samples by yourself\n\nn 必要なもの\n\n      - 仮想環境（VMWare/VirtualBox/Hyper-V等）\n\n      - Windows OS（ゲストOS）\n\n      - ANY.RUNアカウント\n\n      - Process Explorer / Process Monitor (なくても可)\n\n      - Hollow Hunter\n\n         - [https://github.com/hasherezade/hollows_hunter/release](https://github.com/hasherezade/hollows_hunter/release)\n\nn **以後の作業は全て構築した仮想環境内でおこなう**\n\n\n-----\n\n##### samples by yourself\n\n\n##### samples by yourself\n\n###### 以下ANY.RUNのページを開き、実⾏されているDLLをダウンロード\n\nn urcwzowo.xck (=packed emotet.dll) MD5:19b0124f2e4f223113bb11a84765a6c3\n\n      - [https://app.any.run/tasks/4060b18e-8132-42c0-a0bc-65f398d6bfb2/](https://app.any.run/tasks/4060b18e-8132-42c0-a0bc-65f398d6bfb2/)\n\nn eclh.gfk (=packed emotet-2.dll) MD5:714cdae2b20896e72d92e28dc831b81b\n\n      - [https://app.any.run/tasks/b9be3b5e-368d-4248-87c2-e06b3d66769e/](https://app.any.run/tasks/b9be3b5e-368d-4248-87c2-e06b3d66769e/)\n\n\n-----\n\n##### samples by yourself\n\n\n##### samples by yourself\n\n###### 仮想環境を外部接続不可な状態にし、EMOTETを適切な引数で実⾏\n\n このとき、Process ExplorerやProcess Hackerなどで実⾏された rundll32.exeのプロセスシーケンスを確認しておく\n\n\n-----\n\n##### samples by yourself\n\n\n##### samples by yourself\n\n###### 実⾏後5-10秒ほど待機し、⼦プロセスのPIDをHollows Hunterに渡して実⾏\n\nn 成功すると実⾏フォルダ配下にprocess_<PID>フォルダが作成され、中にアンパック後のEMOTETのDLLが\n保存される\n\n\n-----",
    "language": "JA",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://jsac.jpcert.or.jp/archive/2021/pdf/JSAC2021_workshop_malware-analysis_jp.pdf"
    ],
    "report_names": [
        "JSAC2021_workshop_malware-analysis_jp.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716491,
    "ts_updated_at": 1743041137,
    "ts_creation_date": 1611788618,
    "ts_modification_date": 1611861110,
    "files": {
        "pdf": "https://archive.orkl.eu/e0f70a9fac33a317678f675b03fd0cdc168bf0c9.pdf",
        "text": "https://archive.orkl.eu/e0f70a9fac33a317678f675b03fd0cdc168bf0c9.txt",
        "img": "https://archive.orkl.eu/e0f70a9fac33a317678f675b03fd0cdc168bf0c9.jpg"
    }
}