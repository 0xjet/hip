{
    "id": "dc2feb42-8d71-4c58-82fa-fb485e66e8cd",
    "created_at": "2023-01-12T15:07:12.044181Z",
    "updated_at": "2025-03-27T02:05:59.324622Z",
    "deleted_at": null,
    "sha1_hash": "271182944ae579abac45046f8fc0faf3f30b3723",
    "title": "2020-03-30 - An old enemy – Diving into QBot part 1",
    "authors": "",
    "file_creation_date": "2022-05-28T04:00:49Z",
    "file_modification_date": "2022-05-28T04:00:49Z",
    "file_size": 731371,
    "plain_text": "# An old enemy – Diving into QBot part 1\n\n**[malwareandstuff.com/an-old-enemy-diving-into-qbot-part-1/](https://malwareandstuff.com/an-old-enemy-diving-into-qbot-part-1/)**\n\n[Published by hackingump on March 30, 2020](https://malwareandstuff.com/author/klopsch/)\n\n\nMarch 30, 2020\n\n\n-----\n\n[While checking out the Triage Sandbox[1] I stumbled across upon QBot which I ve seen](https://tria.ge/)\n[already plenty of times at work at GData Cyberdefense AG[2]. This time I wanted to take a](https://www.gdata.de/)\ncloser look at the sample myself.\nThe first part of this blog article dives deep into how the packer works.\n\nTriage sandbox overview of the analysed sample\n\n## Quick summary\n\nThe packer used by this sample first allocates virtual memory and fills it with chunks of bytes\nfrom its `.text section.`\n\nAfter jumping into this allocated area, the address of `GetProcAddress` [[3] is determined by](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)\nlooping over the export table of `KernelBase.dll . This function is then used to load further`\ndependencies.\n\nNext another temporary memory is allocated, filled with decrypted code and replaces the\ncode we started with. Finally the sample jumps back to the now decrypted payload and\nexecutes it.\n\n## 1 – Allocating VirtualAlloc\n\nVirtualAlloc routine captured in IDA\n\nThe first step itself does not decrypt any code, however it writes bytes in `0x64 chunks into`\nvirtual memory `2304 times` `(0x38400 / 0x64) . The position of these chunks are`\ncalculated loop after loop and do not lie linear in the memory.\n\n\n-----\n\n## 2 – Loading dependencies\n\nOnce the virtual memory is allocated we can dump the code and load it into IDA to analyse it.\nAfter returning the base address of the `KernelBase.dll, the offset to the`\n```\nGetProcAddress function is determined by iterating over the export table.\n\n```\n\n-----\n\nSome\n\n\nexported functions of `KernelBase.dll`\nExplaining this behaviour in pseudo code makes it clearer:\n```\nfunc = \"GetProcAddress\";\nsymbols = getSymbols()\nfor symbol in symbol:\n    if symbol == func:\n       return getOffsetToFunc(symbol)\n\n```\n\n-----\n\nSearching for GetProcAddress in the debugger\nWith `GetProcAddress the location of` `LoadLibrary is returned. By using these two`\nfunctions the packer is now able to write offsets of needed library functions into memory.\n\n## 3 – Decrypt the code\n\nIn the third step the actual payload is being prepared. `VirtualAlloc` [[4] sets up another](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)\nmemory area which is used to hold decrypted code temporarily. After the decryption is\nfinished a fully unpacked PE file lies now in memory. The PE sections we started with are\nzero’ed and replaced with the new decrypted sections.\n\nSome exported functions are still missing. In order to determine their position the same trick\nis used which I already explained in the second step. This time though, different libraries are\nused.\n\n\n-----\n\nDetermining position of final dependencies\n\n## 4 – Returning to the payload\n\nAll that is left now is to return to the unpacked sample via return instruction because the\nreturn address is still written onto the stack.\n\n\n-----\n\nReturn back to where we started at\n\n\n-----\n\nGraph overview of start func packed\n\n## 5 – IoCs\n\n\nGraph overview of start func unpacked\n\n\nSample\nSHA256\n\n\nc23c9580f06fdc862df3d80fb8dc398b666e01a523f06ffa8935a95dce4ff8f4\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-03-30 - An old enemy – Diving into QBot part 1.pdf"
    ],
    "report_names": [
        "2020-03-30 - An old enemy – Diving into QBot part 1.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536032,
    "ts_updated_at": 1743041159,
    "ts_creation_date": 1653710449,
    "ts_modification_date": 1653710449,
    "files": {
        "pdf": "https://archive.orkl.eu/271182944ae579abac45046f8fc0faf3f30b3723.pdf",
        "text": "https://archive.orkl.eu/271182944ae579abac45046f8fc0faf3f30b3723.txt",
        "img": "https://archive.orkl.eu/271182944ae579abac45046f8fc0faf3f30b3723.jpg"
    }
}