{
    "id": "0fa76688-579f-4e9d-829b-cce5e1649827",
    "created_at": "2023-01-12T15:06:47.897522Z",
    "updated_at": "2025-03-27T02:06:00.860661Z",
    "deleted_at": null,
    "sha1_hash": "f47979583152514911e76b3bbbc543d854e9372a",
    "title": "2020-06-10 - Unpacking Smokeloader and Reconstructing PE Programatically using LIEF",
    "authors": "",
    "file_creation_date": "2022-05-27T19:01:18Z",
    "file_modification_date": "2022-05-27T19:01:18Z",
    "file_size": 542492,
    "plain_text": "# Unpacking Smokeloader and Reconstructing PE Programatically using LIEF\n\n**m.alvar.es/2020/06/unpacking-smokeloader-and.html**\n\nThis article holds notes on my experience unpacking a Smokeloader 2020 sample. The unpacked payload is further used\nfor composing a valid PE file. The outcome is a PE32 executable containing clean code ready for reversing.\n\nFirst things first, here is the sample used in this research:\n\nSize _308.17 KB (315568 bytes)_\n\nType PE32 executable for MS Windows (GUI) Intel 80386 32-bit\n\nFirst seen 2020-03-06 21:45:11\n\nmd5 c067e0a2d7fc6092bb77abc7f7156b60\n\nsha1 52f68073caec0fd424c7cbaaed5f5221d7103d20\n\nsha256 25959cfe4619126ab554d3111b875218f1dbfadd79eed1ed0f6a8c1900fa36e0\n\n[You can find it in VirusTotal [1].](https://www.virustotal.com/gui/file/25959cfe4619126ab554d3111b875218f1dbfadd79eed1ed0f6a8c1900fa36e0/details)\n\nThis sample does regular already documented Smokeloader checks before unpacking the main payload, such as:\n\n[checks if the process is running in the context of a debugger using \"kernel32.isDebuggerPresent\" function [2];](https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent)\nmakes a copy of ntdll.dll, loads it and uses it instead. This technique helps to evade some sandboxes and has been\n[described already in this article here [3];](https://malwareandstuff.com/examining-smokeloaders-anti-hooking-technique/)\nlooks for specific patterns in registry keys to check if the sample is running under a virtualised environment.\n\nIt also performs a small profiling of the hosting machine in order to decide which payload to inject. Smokeloader has\nspecific code for both main architectures x86 and x64. In this article, we gonna unpack the x86 payload of the above\nmentioned sample.\n\n_Smokeloader has been using various techniques to inject its final payload into the user file management process_\n\"explorer.exe\". The sample analysed uses RtlCreateUserThread approach in order to copy the final payload to the targeted\n[process. This injection method is better described in this Endgame/Elastic article [4].](https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process)\n\nSo our game plan is:\n\n1. pause execution before the unpacked payload is executed by \"explorer.exe\";\n2. transplant this code to a dummy PE shell;\n3. fix PE header values and section boundaries;\n4. patching Smokeloader code preamble;\n5. test unpacked Smokeloader PE;\n[6. how to do all this programatically using LIEF [5].](https://github.com/lief-project/LIEF)\n\n**1.0 - FETCHING MAIN PAYLOAD**\n\n_Smokeloader 1st stage decompresses its payload using ntdll.RtlDecompressBuffer_ [[6] after few anti-analysis checks](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtldecompressbuffer)\ndescribed above. It does not call this function from the initially loaded ntdll.dll but from a copy of it loaded afterwards. So\nbreakpoints should be set after the binary loads the copy of ntdll.dll. Figure 01 presents a screenshot of this specific\ncode IDA.\n\n\n-----\n\nFigure 01: Smokeloader first stage decompression code\n\nThis code allocates a buffer with 0x2D000 bytes using ZwAllocateVirtualMemory which stores the main decompressed\n[payload [7]. This code is still transformed before being injected into \"explorer.exe\". The following steps are performed](https://www.virustotal.com/gui/file/756dd799c8195b98f295baa210ac1807f7d1d86de2736f559c76ce1c7816d0ee/detection)\nduring injection:\n\nfetches explorer.exe PID by calling GetShellWindow and GetWindowThreadProcessId;\nsections and maps are created in the current and remote processes using ZwCreateSection and\n_ZwMapViewOfSection;_\nmain payload is copied to local section and reflected in the remote section;\ndata section is created in the remote process for holding parameters and dynamically created Import Table;\nA new thread is created in the remote process by invoking RtlCreateUserThread.\n\nSo, at this point, you could ask me: what is the relevance of describing all these call names to the final goal of this article?\nthe answer is: so you can reproduce exactly what I'm describing in here. :D\n\nNext step is setting up a break point in RtlCreateUserThread (from the copy of ntdll.dll) and dump the final payload. It is\nalso necessary to take note of few important addresses: (i) entry point of the thread created in the remote processes and\n(ii) base addresses for injected code in virtual process.\n\nFigure 02 shows a screenshot of IDApro showing the call to RtlCreateUserThread (where we should pause the execution).\n\nFigure 02: Call to RtlCreateUserThread after injecting code into remote process\n\nBy stoping the execution on this call we can collect all data we need to move on to the next step:\n\n**Base address code** _0x02060000_\n\n**Base address data** _0x00B60000_\n\n\n-----\n\n**Data payload** _[a01751fb6eb3f19d9b010818bbecc23c [8]](https://www.virustotal.com/gui/file/787c762f7384dc8f427f76fb313e3bc248b09516a917426a533ed295bf1b593b/detection)_\n\n**Code payload** _[2547231b4ae82ea9e395fb0c8a308982 [9]](https://www.virustotal.com/gui/file/3cae0d6a80a716b1c823e1f4011b3d07c4b3475a894751006874729d2145bbcf/detection)_\n\n**Code entry point** _0x02061734_\n\nCode payload is the final unpacked Smokeloader code adjusted to run on Virtual Address with base equal to 0x02060000.\nThe created thread receives the base address of the data segment (0x00B60000) as parameter\n(\"StartParameter\" parameter of \"RtlCreateUserThread\" call).\n\n**2.0 - TRANSPLANTING PAYLOAD TO PE**\n\n_Smokeloader loads all resources necessary to its execution dynamically. This article_ [here [10] describes how Smokeloader](http://security.neurolabs.club/2019/10/dynamic-imports-and-working-around.html)\nbuilds up its import table and how to prepare patch an IDB to overcome this technique before starting reversing. So this\nmain payload does not need any specific setup of imports.\n\n[In this section we will use 010 Hex Editor [11] to transplant a PE header from a random executable. 010 Hex Editor has a](https://www.sweetscape.com/010editor/)\n[PE format template [12]. Although any other valid PE32 binary could be used in this experiment, we used a PE header](https://www.sweetscape.com/010editor/repository/templates/file_info.php?file=EXE.bt)\n[extracted from an executable listed in this Sotirov's blog post [13][14].](http://www.phreedom.org/research/tinype/)\n\n_Smokeloader code payload has 0x1000 null bytes at offset zero, so we copied the first 0x1000 bytes containing the PE_\nheader from tinype.exe to this region.\n\nCoincidently, .text section will be already pointing to the beginning of the our payload at offset 0x1000. Probably the\nmalware author just wiped out the PE header before creating the payload and left the null bytes there. Next step is to paste\nall 20480 bytes (0x5000) of our data payload in the offset 0x4400.\n\nFigure 03 shows the new layout of our binary containing the PE header in the beginning followed by 0x3400 bytes of code\npayload (at offset 0x1000) and finally 0x5000 bytes of data from our data payload (at offset 0x4400).\n\nFigure 03: Initial layout of new handcrafted PE binary\n\n**3.0 - FIXING PE HEADERS**\n\nIt is time to adjust our implanted PE header manually using 010 Hex Editor. At this point, all fields in this header are still set\n[up according \"tinype.exe\". From now on, we gonna use this schematic as reference to PE header internal structures [15].](https://upload.wikimedia.org/wikipedia/commons/1/1b/Portable_Executable_32_bit_Structure_in_SVG_fixed.svg)\n\nThe first adjustment is to change the number of sections to 2 for holding code and data. This field is located in the\n\"COFFHeader.NumberOfSections\". Now our binary will list only 2 sections named \".text\" and \".rdata\" we can rename this\nsecond one to \".data\" by changing \"SectionHeaders[1].Name\".\n\nNext step is make sure that both sections have correct permissions. \"SectionHeaders[0].Characteristics\" (\".text\") should\nhave CODE, EXECUTE and READ flags active and \"SectionHeaders[1].Characteristics\" (\".data\") should have the\n\n\n-----\n\n_INITIALIZED_DATA, READ and WRITE flags active. Still on SectionHeaders, we can setup the bounds and virtual_\naddresses. \"SectionHeaders[0].SizeOfRawData\" should be set to 0x3400 (13312 Bytes),\n\"SectionHeaders[0].PointerToRawData\" should be set to \"0x1000\" and finally \"SectionHeaders[0].VirtualAddress\" should\nbe set to 0x1000. For \"SectionHeaders[1]\" (\".data\") we gonna set \"SizeOfRawData\" to 0x5000, \"PointerToRawData\" to\n_0x4400 and \"VirtualAddress\" to 0x5000. These changes means that these sections will be mapped in memory in_\nbase_address (defined in the OptionalHeader) shifted by each section Virtual Addresses offset. There is an Union inside\nthese section headers called \"PhysicalAddress\" and \"VirtualSize\", these fields should hold the same value as\n\"SizeofRawData\".\n\nFigure 04 shows a diagram of a Section header. Each section in the binary has an instance of this header associated to it.\n\nFigure 04: PE Section Header\n\nNow we need to adjust few fields in the Optional Header. In this header we will need to change the following fields:\n\nImageBase Virtual Address where binary will be mapped 0x02060000\n\nSizeOfCode size of .text section 0x3400 bytes\n\nSizeOfInitializedData size of .text and .data sections together 0x8400 bytes\n\nAddressOfEntryPoint offset of the entry point code 0x1734\n\nBaseOfCode .text section Virtual Address 0x1000\n\nBaseOfData .data section Virtual Address 0x5000\n\nSectionAlignment Virtual Addresses have to be multiple of this value 0x1000\n\nFileAlignment file offsets have to be multiple of this value 0x200\n\nSizeOfImage total size of binary headers + sections 0x9400\n\nChecksum [PE file checksum - use PE Explorer [16] or Hiew [17] to calculate this value](http://www.heaventools.com/) -------\n\"ImageBase\" has to match the base of the code section we dumped from \"explorer.exe\" (0x02060000). As we will not\nexport or import anything all \"Data Directories\" inside the Optional Header can be zeroed as well.\n\nSummarising the whole process:\n\n1. Transplanting PE header from a dummy PE;\n2. Fix sections sizes, boundaries, permissions and Virtual Addresses in SectionHeaders;\n3. Setup section contents;\n4. Setup Optional Header fields;\n5. Setup PE checksum;\n\n[Here is the version of our binary after following up all steps described above [18]. This binary is a valid executable and we](https://www.virustotal.com/gui/file/3e474e495e11716f6eab40ee3c353602da2683dbefd900f6d90dfcedff2fa93d)\ncan load it in any debugger or disassembly but we still need to change one last thing before call it a valid unpacked\n_Smokeloader sample._\n\n**4 0** **PATCHING BINARY**\n\n\n-----\n\nFigure 05 shows our reconstructed PE loaded in IDApro paused on the correct Entry Point.\n\nFigure 05 - Reconstructed PE paused on Entry Point\n\nWe can notice that the entry point function receives an argument (0x02061737) and loads it into ECX and then calls\nanother function located in 0x02061743 which is just below the current function. This argument is the address of the data\nsegment. This data segment will be used for various tasks during Smokeloader execution including holding the dynamically\ncreated import table.\n\nIf we execute this file without a valid value in ECX it will break when the main payload tries to write into the data segment\n(invalid address in ECX). Figure 06 shows what happens when we try to execute our binary the way it is right now.\n\nFigure 06 - Access Violation exception when executing unpatched reconstructed binary\n\nThe plan now is to patch this binary to load the correct address of the data segment into ECX before calling\n\"sub_2061743\". Since both functions are consecutive and the function on top does not do much - we gonna replace all 15\nbytes of this function (0x02061743 - 0x02061734). Figure 07 shows the new patched code.\n\n\n-----\n\nFigure 07 - Code after patching\n\nIn this new code the entry point remains the same. We can see that we loaded ECX with the address of the data segment\nby using the push and pop instructions and then we filled the rest of the remaining bytes with NOP (0x90). We can see the\nbeginning of the second function at the same address as before (0x02061743). Of course there are many ways to achieve\nthis same result but this was the simplest approach we could think of.\n\nThe final step is to update the PE checksum field inside the Optional Header again and we will have a fully unpacked\n_[Smokeloader sample. Here are the last version of our reconstructed binary [19]:](https://www.virustotal.com/gui/file/cd42f017913034d527d90a84feebcde015e714baa03714c83f80608555e52386/detection)_\n\nFile name new_pe_patched.bin\n\nFile type PE32 executable for MS Windows (console) Intel 80386 32-bit\n\nSize 37888 bytes\n\nmd5 f401109ae24aaf47dce75266ffc049f8\n\nsha1 49e7ed68b9569e0e987da71b3c678974d8ed7c81\n\nsha256 cd42f017913034d527d90a84feebcde015e714baa03714c83f80608555e52386\n\n**5.0 - TESTING RECONSTRUCTED PE**\n\n[For testing our branding new reconstructed PE we ran it into Cuckoo sandbox [20] to analyse its behaviour [21]. As we can](https://www.capesandbox.com/)\nsee in figure 08 and 09, the binary was executed properly and we got it checking in and contacting its controllers.\n\n\n-----\n\nFigure 08 - Reconstructed sample connecting back to Controllers\n\nFigure 09 - List of API calls intercepted by Cuckoo\n\nAs we can see we got the sample connecting back to three controller URLs and many pages of intercepted API calls in the\nbehavioural analysis. This is an indication that our unpacked and reconstructed Smokeloader sample is functional.\n\n**6.0 - DOING IT ALL PROGRAMATICALLY**\n\nSo far we described how to unpack Smokeloader main payload and how to manually reconstruct a valid PE file out of this.\nNow we will automate what we did manually by transplanting a PE header from a dummy binary (\"tinype.exe\"). The Python\nlibrary used in this experiment is LIEF [[5]. We extended this example called \"Create a PE from scratch\" they have in their](https://github.com/lief-project/LIEF)\n[official documentation [22].](https://lief.quarkslab.com/doc/latest/tutorials/02_pe_from_scratch.html)\n\nThe following code does exactly the same as the manual approach but using LIEF.\n\nThe final binary generated by LIEF is:\n\nFile name unpacked_smokeloader.exe\n\nFile type PE32 executable for MS Windows (console) Intel 80386 32-bit\n\nSize _34816 bytes_\n\nmd5 a0aebc61bc89208be0585eca4d1ed00c\n\nsha1 ea2f3c914dec6bb36832abc313b3fce826cdecb0\n\nsha256 0247de510507792fcbf425fab9dbbc2f067c25dc7e4e80a958d1ebfb0505f6e6\n\n[We uploaded it for testing to Virustotal [23] and CAPE sandbox [24] and is a valid unpacked Smokeloader PE32](https://www.virustotal.com/gui/file/0247de510507792fcbf425fab9dbbc2f067c25dc7e4e80a958d1ebfb0505f6e6)\nexecutable.\n\n\n-----\n\n**REFERENCES:**\n\n[1] https://www.virustotal.com/gui/file/25959cfe4619126ab554d3111b875218f1dbfadd79eed1ed0f6a8c1900fa36e0/details\n\n[2] https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent\n\n[3] https://malwareandstuff.com/examining-smokeloaders-anti-hooking-technique/\n\n[4] https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process\n\n[5] https://github.com/lief-project/LIEF\n\n[6] https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtldecompressbuffer\n\n[7] https://www.virustotal.com/gui/file/756dd799c8195b98f295baa210ac1807f7d1d86de2736f559c76ce1c7816d0ee/detection\n\n[8] https://www.virustotal.com/gui/file/787c762f7384dc8f427f76fb313e3bc248b09516a917426a533ed295bf1b593b/detection\n\n[9] https://www.virustotal.com/gui/file/3cae0d6a80a716b1c823e1f4011b3d07c4b3475a894751006874729d2145bbcf/detection\n\n[10] http://security.neurolabs.club/2019/10/dynamic-imports-and-working-around.html\n\n[11] https://www.sweetscape.com/010editor/\n\n[12] https://www.sweetscape.com/010editor/repository/templates/file_info.php?file=EXE.bt\n\n[13] http://www.phreedom.org/research/tinype/\n\n[14]\nhttps://www.virustotal.com/gui/file/718b03e878080c34f4a51c7243bb60024c7734f23d5715d6b97a5a4d54d7a630/detection\n\n[15] https://upload.wikimedia.org/wikipedia/commons/1/1b/Portable_Executable_32_bit_Structure_in_SVG_fixed.svg\n\n[16] http://www.heaventools.com/\n\n[17] http://www.hiew.ru/\n\n[18] https://www.virustotal.com/gui/file/3e474e495e11716f6eab40ee3c353602da2683dbefd900f6d90dfcedff2fa93d\n\n[19] https://www.virustotal.com/gui/file/cd42f017913034d527d90a84feebcde015e714baa03714c83f80608555e52386/detection\n\n[20] https://www.capesandbox.com/\n\n[21] https://www.capesandbox.com/analysis/7521/#behavior\n\n[22] https://lief.quarkslab.com/doc/latest/tutorials/02_pe_from_scratch.html\n\n[23] https://www.virustotal.com/gui/file/0247de510507792fcbf425fab9dbbc2f067c25dc7e4e80a958d1ebfb0505f6e6\n\n[24] https://www.capesandbox.com/analysis/7643/\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-10 - Unpacking Smokeloader and Reconstructing PE Programatically using LIEF.pdf"
    ],
    "report_names": [
        "2020-06-10 - Unpacking Smokeloader and Reconstructing PE Programatically using LIEF.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536007,
    "ts_updated_at": 1743041160,
    "ts_creation_date": 1653678078,
    "ts_modification_date": 1653678078,
    "files": {
        "pdf": "https://archive.orkl.eu/f47979583152514911e76b3bbbc543d854e9372a.pdf",
        "text": "https://archive.orkl.eu/f47979583152514911e76b3bbbc543d854e9372a.txt",
        "img": "https://archive.orkl.eu/f47979583152514911e76b3bbbc543d854e9372a.jpg"
    }
}