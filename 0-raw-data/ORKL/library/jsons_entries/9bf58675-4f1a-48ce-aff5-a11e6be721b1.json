{
    "id": "9bf58675-4f1a-48ce-aff5-a11e6be721b1",
    "created_at": "2022-10-25T16:48:13.282491Z",
    "updated_at": "2025-03-27T02:05:33.726458Z",
    "deleted_at": null,
    "sha1_hash": "dc1818de10caed1a88a38e53817120354b04ebc2",
    "title": "Trickbot report - S2 Grupo",
    "authors": "",
    "file_creation_date": "2017-07-04T10:24:15Z",
    "file_modification_date": "2017-07-04T10:24:15Z",
    "file_size": 3472322,
    "plain_text": "#### REPORT\n\n\n#### 06/2017\n\n\n## S2 Grupo de Innovación en\n\n### Procesos Organizativos\n\n\n-----\n\n###### INDEX\n\n\n###### INDEX\n\n\n**_1._** **_INTRODUCTION ................................................................................................................ 3_**\n\n**_2._** **_INFECTION PROCESS ..................................................................................................... 5_**\n\n**_3._** **_TECHNICAL CHARACTERISTICS................................................................................. 6_**\n\n**_4._** **_MODULE LOADING SYSTEM ...................................................................................... 13_**\n\n**_5._** **_NETWORK CONNECTIONS .......................................................................................... 21_**\n\n6. **_ENCRYPTION MECHANISM ......................................................................................... 25_**\n\n**_7._** **_IPC MECHANISM (Inter-Process Communication) ................................................ 29_**\n\n**_8._** **_RELATED FILES.............................................................................................................. 32_**\n\n**_9._** **_DETECTION ...................................................................................................................... 33_**\n\n**_10._** **_DISINFECTION ............................................................................................................. 35_**\n\n**_11._** **_ATTACKER INFORMATION ...................................................................................... 36_**\n\n**_12._** **_REFERENCES ............................................................................................................. 38_**\n\n**_13._** **_AUTHORS ..................................................................................................................... 38_**\n\n\n-----\n\n###### 1. INTRODUCTION\n\n\nThis document contains a review of the latest versions of a Trojan family known as\n\n**“Trickbot/TrickLoader”.** It is a bank-type Trojan that steals credentials and bank details\n\nfrom infected users. Although its main objective and behavior is focused on online\n\nbanking users, being a modular Trojan, it has capabilities that attackers could use for\n\nother purposes, such as document exfiltration.\n\nYou can find a lot of documentation regarding the logic and origins of this malware; part\n\nof this report is based on information from some of them in order to contrast it with the\n\nlogic of the latest versions and to be able to observe its evolution and new functionalities.\n\nAll sources for which information has been obtained can be found in the references\n\n\nsection.\n\n\nIt should be noted that the report starts with and relies mainly on the analyses carried\n\nout by **@hasherezade** and by **Xiaopeng Zhang** (Fortinet). Based on these analyses, an\n\nattempt was made to compare whether in the last versions some aspect had changed\n\nand to deepen in the mechanisms not described until the moment.\n\n\n**In summary, Trickbot has the following capabilities:**\n\n\nIt loads the code into the system\n\nIt creates a replica of itself in the %APPDATA%\n\nIt applies persistence techniques\n\nIt collects sensitive information\n\nIt injects code into other applications to control the information they handle\n\nIt exfiltrates the information you get to your Command and Control server\n\n\n-----\n\nDuring the completion of this report the S2 Grupo Malware Laboratory worked with the\n\nsamples that match the following MD5 hashes:\n\n**1000005_Trickbot_Loader.exe** **a50c5c844578e563b402daf19289f71f**\n\n**1000005_Trickbot_bot32.exe** 28661ea73413822c3b5b7de1bef0b246\n\n**1000010_Trickbot_Loader.exe** 218613f0f1d2780f08e754be9e6f8c64\n\n**1000010_Trickbot_bot32.exe** 135e4fa98e2ba7086133690dbd631785\n\n**1000014_Trickbot_Loader.exe** e054eaae756d31a4f6e30cc74b2e51dd\n\n**1000014_Trickbot_bot32.exe** 719578c91b4985d1f955f6adb688314f\n\n**1000016_Trickbot_Loader.exe** 132c4338cdc46a0a286abf574d68e2e0\n\n**1000016_Trickbot_bot32.exe** e8e7b0a8f274cad7bdaedd5a91b5164d\n\nAs you can see in the previous image, four different versions of Trickbot. Each one of\n\nthem consists of its loader and its final payload for 32-bit systems; although there is also\n\nthe 64-bit version of all, it was not the subject of the analysis performed.\n\n|1000005_Trickbot_Loader.exe|a50c5c844578e563b402daf19289f71f|\n|---|---|\n|1000005_Trickbot_bot32.exe|28661ea73413822c3b5b7de1bef0b246|\n|1000010_Trickbot_Loader.exe|218613f0f1d2780f08e754be9e6f8c64|\n|1000010_Trickbot_bot32.exe|135e4fa98e2ba7086133690dbd631785|\n|1000014_Trickbot_Loader.exe|e054eaae756d31a4f6e30cc74b2e51dd|\n|1000014_Trickbot_bot32.exe|719578c91b4985d1f955f6adb688314f|\n|1000016_Trickbot_Loader.exe|132c4338cdc46a0a286abf574d68e2e0|\n|1000016_Trickbot_bot32.exe|e8e7b0a8f274cad7bdaedd5a91b5164d|\n\n\n-----\n\n###### 2. INFECTION PROCESS\n\n\n###### 2.\n\n\nThe main route of infection of this malware occurs through a Word document with macros\n\nthat arrives attached in an email or through an exploited vulnerability by an ExploitKit.\n\n\nThe infection follows this order of execution:\n\n\nA Trickbot sample is downloaded from a compromised domain in the%\nAPPDATA% folder and executed\n\nIt creates a scheduled task on the system that provides persistence\n\nIt creates two files (\"client_id\" and \"group_tag\") in the same directory, one with a\nunique ID of the infected host and one with the ID of the current infection\ncampaign or version of the configuration.\n\nIt contacts with an external IP obtaining domain, among other things to test the\nconnectivity and send it to your command and control servers (C2 from now).\n\nIt contacts one of its C2 servers to get malware updates, modules that perform\nmost of the malware logic and various configuration files.\n\nAfter all this, it begins to execute or inject in different processes its modules that\nare responsible for collecting information of the system and browsing credentials\nespecially of online banking.\n\n\n-----\n\n###### 3. TECHNICAL CHARACTERISTICS \n\n\nThe main executable of **Trickbot** is usually packaged with its own **“packer”, which**\n\nobfuscates the functionality of the executable and prevents generic signatures from\n\nbeing generated from the content itself, seeing that for each version the packer causes\n\nthe code to vary completely. After unpacking one can see how the number of functions\n\nof the executable increases greatly, as it now reflects the functionality of the malicious\n\nprogram:\n\n**Packed** **Unpacked**\n\n\n-----\n\nAfter the \"unpack\" the first stage of this malware is obtained, known as \"Loader\". This\n\nexecutable is responsible for verifying the architecture of the system and depending on\n\nwhether it is a 32 or 64 bit computer, it loads the \"bot\" from its resources, corresponding\n\nto that architecture. The \"bot\" is the executable that takes care of the last stage of\n\n\ninfection and contains all the basic malware logic.\n\n\nIn the first versions, the resources contained in the Loader were easily recognizable\n\nbecause they had descriptive names, as they identified the two versions of the Bot and\n\na Loader to correctly load the 64-bit. In the latest versions they began to put non\n\ndescriptive names so as to make it difficult to identify them:\n\n|V10 de Trickbot|V14 de Trickbot|V16 de Trickbot|\n|---|---|---|\n||||\n\n\nThese resources, consists on executable files (PE) encrypted with the AES CBC\n\nalgorithm, so after extracting them they still need to be decrypted or otherwise can be\n\nextracted from memory after running the Loader and waiting for it to perform the\n\n\ndecryption itself and load them in RAM.\n\n\nAfter loading the corresponding bot, it starts executing the main logic of this threat:\n\n\nIt first checks its location on the system, and if it is not found in% APPDATA% it copies\n\nitself to this location, starts executing its replica in that folder and ends the current\n\n\nprocess.\n\n\nAs a persistence technique, it uses scheduled system tasks rather than registry keys as\n\nis often the case in other samples of malware. Previous versions of Trickbot, in all cases\n\ncreated a single programmed task called \"bot\" and made sure that every minute was\n\nlaunched to keep running on the system.\n\n\n-----\n\nIn the latest versions, if it is executed with administrator permissions in addition to the\n\npreviously mentioned task, which it has called \"Drives update\", it creates another one\n\n\nthat executes it when any user logs in, called \"AplicationsCheckVersion\"\n\n\nIts next action is to check if it has all the configuration files with which it usually works:\n\n\nIf it does not find them, it generates them from information obtained in the system and\n\n\nthe resources of the bot, which consist of an encrypted configuration file (CONFIG) and\n\n\na key to verify the signature of the configuration and modules (KEY).\n\n\nIn this case there have been no changes in the names of these resources to date,\n\nalthough it is likely that in future iterations we will see how they eliminate these names\n\n\nas in the case of Loader resources.\n\n\nIn the first run of Trickbot on the computer generates a file called \"client_id\" that contains\n\na token or user ID, which identifies the current host.\n\n\n-----\n\n**Trickbot** obtains it’s configuration from a file in a disk with the name config.conf or from\n\nthe resources of its own binary. This configuration will be decrypted, and after decryption\n\nit can be seen that it contains the version of the malware itself, a campaign code or\n\nversion of the configuration, the addresses of several of its main C2s, and the list of\n\nmodules that it must download and run automatically from any of its C2s.\n\nIt then checks the connectivity by making a request to an external domain that reports\n\nthe victim's IP esternal address, this domain comes from a list contained inside the\n\n\nmalware and which have been increasing during the different version updates.\n\n\n**Version 7**\n\n\n-----\n\n**Version 14**\n\nIf it receives the response it expects from this request, it starts contacting the C2s it has\n\nobtained from its configuration to start reporting information on the new victim, check for\n\n\nupdates, and receive new modules that expand its capabilities.\n\n\nIn normal configurations, after making certain requests with different commands that\n\nreport host information to one of the C2s in its configuration, it obtains the IP of a specific\n\n\nserver from which it can download new modules through port 447/tcp.\n\n\nAll downloads of configurations and modules are encrypted with the same algorithm\n\n(AES CBC) and all the files are saved encrypted to the disk. After updating and\n\ndownloading the configurations and modules that it has in the configuration, it decrypts\n\nand maps the first module in the memory of its own process, \"systeminfo\", which is\n\nresponsible for collecting information such as OS version, CPU type, the amount of RAM,\n\n\nthe users of the system and the list of installed programs and services:\n\n\n-----\n\nThen it loads the injectDll32 module together with its configuration files:\n\n\nOnce this module is loaded, in case the user visits one of the websites listed in the\n\nconfiguration files (such as * cey-ebanking.com / CLKCCM / *) of this module, it captures\n\n\nthe relevant browsing data and sends them to their C2:\n\n\n-----\n\nAs discussed in the DevCentral report, version 9 of **trickbot,** a new module was added\n\nto the Trickbot toolset called \"mailsearcher\". Then in the case of being in the\n\nconfiguration will also be loaded into the victim system. The order in which the modules\n\nare loaded will depend on the configuration file.\n\n\"mailsearcher\" is responsible for searching all the files of each disk connected to the\n\nsystem and comparing the extensions of the files with the following list:\n\nThis module reports itself to a specific C2 that it obtains from its own configuration:\n\nThe URI of the request is different from the one used by the \"core\" of Trickbot, since in\n\nthis case it has the structure \"[IP]/[group_id]/[client_id]/send/\" and uses its own User\nAgent \"KEFIR ! \"Which makes it much more independent than the other modules found\n\nto date.\n\nWhat is seen in this section describes the actions performed by Trickbot after its first\n\nexecution. From this moment Trickbot enters a loop where from time to time it checks if\n\nthere is a new configuration and if there are new versions of the malware or of some of\n\nthe modules. In addition, within the same loop, it performs reports with the information it\n\ncollects.\n\n\n-----\n\n###### 4. MODULE LOADING SYSTEM\n\n\nDuring the analysis it has been observed that **Trickbot** uses events to control the\n\nexecution flows between the core and the modules. In addition, the core performs the\n\nresolution of the Windows APIs of the modules. Let's see how this core communication\n\nsystem works with the modules.\n\nFirst it creates a svchost.exe child process suspended with the CreateProcessW\n\nfunction:\n\nLater with the CreateEventW function, it creates three events that will be used to manage\n\nthe waits and communications between the main executable (Trickbot) and the svchost\n\nchild process.\n\n\n-----\n\nOnce it has the handlers of the three events, using VirtualAllocEx and\n\nWriteProcessMemory it injects in the suspended svchost process 32 bytes of data like\n\n\nthe following:\n\n\nThe first three groups of 4 Bytes (in red boxes) represent the identifiers of events that\n\nhave created trickbot previously and that will use for their communication, in this case\n\n4, 8 and C respectively.\n\nThe following 5 groups of 4 Bytes (in purple boxes) represent the offsets in the memory\n\n\nitself of the svchost process, from the following functions of the kernel32.dll library:\n\n\nSignalObjectAndWait\n\nWaitForSingleObject\n\nCloseHandle\n\nExitProcess\n\nResetEvent\n\nUsing the same injection method, it loads its own function into another offset of the\n\nsvchost memory that will be used as the intermediary between Trickbot and the module\n\ncode.\n\n\n-----\n\nThis feature is one of the most characteristic details of the **Trickbot** module\n\n\nmanagement.\n\n\nIt is in charge of keeping itself waiting for orders from the main process. These come as\n\noffsets from functions within the memory of the svchost process itself and parameters\n\nwith which to call them. This information is obtained through scripts in its own memory\n\n\nby Trickbot as detailed in the previous case.\n\n\nMost of its logic consists of a loop that starts and ends in code zones with a **blue**\n\nbackground; after the first instructions, in case of detecting a problem with the process,\n\nit enters the area marked in red that closes the handlers of the events and the process\n\n\nitself.\n\n\n-----\n\nIn case everything goes correctly, the zone in which it enters consists of a switch, marked\n\nin green. Depending on the number of parameters needed by the function to call, enter\n\n\none of the blank zones.\n\n\nIn the case of the following screenshot, if the number of parameters (which it has loaded\n\nin edx) coincides with 9, it enters a zone with nine calls to \"push edx\" with which it is\n\nloading parameters in the stack extracted from consecutive offsets after eax. Finally, it\n\nmakes a call to ecx, where it has loaded the first offset of eax in the fourth instruction of\n\n\nthis zone and that corresponds to the position of a function.\n\n\nIn the next screenshot you can see an example of calling a function like this and the\n\n\nstatus of the registers during the execution.\n\n\nTo manage the wait between the parent and child process, Trickbot uses the events it\n\n\ncreated before the injections into the process.\n\n\nUsing these events, when it reaches the last zone of the loop (in the previous screenshot\n\nmarked with blue background) it contains two calls that correspond to a ResetEvent that\n\n\nnotifies Trickbot that it has reached the end of the loop:\n\n\n-----\n\nAnd a call after SignalObjectAndWait, to which it passes the IDs of two events. This\n\nfunction leaves the process suspended waiting for Trickbot to do a ResetEvent of the\n\nevent in this case with ID 4, which means that it has loaded the new parameters into the\n\n\nmemory for the next iteration of the loop:\n\n\nBefore starting the execution of this process, it injects in the Entry Point of svchost, four\n\nlines that redirect the flow of the main thread to the previous function, passing it as a\n\n\nparameter, the 32 bytes of data injected at the beginning:\n\n\nAfter preparing all that, it calls ResumeThread and the process goes into execution.\n\n\n-----\n\nDuring the first iterations of the loop, Trickbot maps one of the modules in the process\n\nmemory, section by section:\n\nIn the next iteration, using the data that the parent process has passed to it, it loads all\n\nthe DLLs required by the newly loaded module with LoadLibrary and the functions of\n\n\nthese that it will need with GetProcAddress.\n\n\nFinally it calls an initialization function of its own module, which writes the \"Success\"\n\nstring in one of the memory zones edited by Trickbot, in case everything is correct.\n\nFrom this point, this last iteration is suspended with the call to SignalObjectAndWait,\n\nwaiting for Trickbot to require, for example, the reporting information of said module.\n\nFrom the main process side, you can see how it contains a function to call the different\n\nfunctions that export each of its modules. These functions are those that each module\n\nexports, since the modules are DLL's and as such they export functions to be used by\n\nthe core. To date these functions have not been changed in any of the versions and\n\nthese are Start, Control, Freebuffer and Release.\n\n\n-----\n\n-----\n\nTo make the transfer of information to the module, after passing through the area of the\n\nfunction which it wants to call, it performs a WriteProcessMemory of the data in question\n\n\nand calls ResetEvent for the module to start working.\n\n\n-----\n\n###### 5. NETWORK CONNECTIONS\n\n\nFor communications with its C2S, this malware uses HTTPS requests, which\n\ncomplicates the identification of its traffic by means of tools like NIDS to use, since that\n\n\ntraffic is encrypted.\n\n\nUsually these communications are done through port 443, although not always, since\n\nfrom the first versions, it began to use port 447 of some specific C2 to download the\n\n\nmodules.\n\n\nA differentiating element of its traffic is its User-Agent, since at first it identified it perfectly:\n\n\nit used the chain TrickLoader in all its requests:\n\n\nIn intermediate versions of the same it became somewhat less obvious, but maintained\n\n\nan unusual structure and easy to detect, becoming the \"Xmaker\" chain:\n\n\nIn recent versions, as another of the changes clearly aimed at making this malware less\n\n\ndetectable, the authors have begun to use a much more generic User Agent:\n\n\nThe requests are formed in such a way that a great amount of the information that reports\n\nto C2 goes in the URI, being the majority of these requests of type GET, excepting more\n\n\nextensive shipments of information collected by its modules, that it sends by POST.\n\n\n-----\n\nAmong the data that contains the URIs of the requests, you can find the identifier of the\n\ncurrent campaign and the user ID that it saves in the two files that it generates along with\n\nthe executable, in the first stages of its execution. You can also find a number that\n\nidentifies the order that it is sending to the C2 so that it can differentiate what it is\n\nrequesting or reporting to it, and later different extra data related to the command in\n\n\nquestion.\n\n\nFrom what we have analyzed and from information obtained from different external\n\nanalyses, we have created the following table with a summary of the functionality of each\n\n\norder that we identified.\n\n|ID|Col2|Col3|\n|---|---|---|\n|0|URI|/[group_id]/[client_id]/0/[version de windows]/[idioma del sistema]/[ip externa]/[sha256]/[key de sesión]/|\n||Description|Report with basic information about the client.|\n|1|URI|/[group_id]/[client_id]/1/[key de sesión]/|\n||Description|Keep alive.|\n|5|URI|/[group_id]/[client_id]/5/[modulo/configuración]/|\n||Description|Download of a module or configuration of a module.|\n\n\n-----\n\nEverything points to a command related to the mailsearcher module. What we\nhave seen is that it performs POST requests with multipart content. It aims to\nbe an exfiltration command, but that is still being verified.\n\n|10|URI|/[group_id]/[client_id]/10/62/[key de sesión]/1/|\n|---|---|---|\n||Description|Start of module.|\n|14|URI|/[group_id]/[client_id]/14/[key de sesión]/[value]/0/|\n||Description|Report with information on errors, checks, and other information|\n|23|URI|/[group_id]/[client_id]/23/[config ver]/|\n||Description|Base configuration update|\n|25|URI|/[group_id]/[client_id]/25/[key de sesión]/|\n||Description|Bot update|\n|60|URI|/[group_id]/[client_id]/60/|\n||Description|Traffic report captured by the injectDll module|\n|63|URI|/[group_id]/[client_id]/63/[module name]/[module command]/[result - base64]/[root tag of output XML]/|\n||Description|Systeminfo o injectDll Report|\n|64|URI|-|\n||Description|Everything points to a command related to the mailsearcher module. What we have seen is that it performs POST requests with multipart content. It aims to be an exfiltration command, but that is still being verified.|\n\n\nFrom the Trickbot code, you can see how in one of its functions it contains the switch\n\nthat is in charge of directing the execution flow that generates these requests depending\n\non the command. In the following image you can see this code for one of its older\n\nversions (Version 1000005):\n\n\nAnalyzing the same function of one of the most recent versions (Version 1000010), we\n\n\ncan see how they have added an extra option after the last one, which corresponded to\n\n\nthe command with number 63, and which is accessed with a new command number\n\n\n64:\n\n\n-----\n\nThe functions that are executed from passing through this new area of code (command\n\nnumber 64) are very similar to those of the command 63, so it is probably also a\n\ncommand to perform reporting. The appearance of this new command (64) coincides in\n\ntime with the appearance of the new module \"mailsearcher\", so everything indicates\n\nthat these are related.\n\nAfter the execution of the sample corresponding to version 14 in a controlled\n\nenvironment, we analyzed its traffic flow which shows a good part of the behavior of the\n\n\nexecution of this malware.\n\n\n_The first part of the requests has been omitted to simplify commands._\n\n\n-----\n\n###### 6. ENCRYPTION MECHANISM\n\n\n###### 6.\n\n\nIn the great work done by **malwarebytes (@hasherezade)** it is detailed that the\n\nencryption algorithm used by Trickbot is AES CBC 256 bits. Also in the same entry on\n\nthis subject we are told that the first DWORD is about the size of the data. In addition,\n\n**@hasherezade** offers resources after its research to decipher both the configurations as\n\nthe modules, which makes it easier to understand Trickbot and its evolution.\n\nBased on this information and visualizing how the content is decrypted, it is easy to\n\nperform the reverse process and build a script or modify the one made by hasherezade,\n\nto provide us with the ability to encrypt configurations modified by us to more easily\n\nmanipulate **Trickbot execution flows. The implementation of the encryption function**\n\nwould be as simple as:\n\nTo perform this process we can start from a configuration that we get encrypted and with\n\nthe **@hasherezade** script we can decrypt it. Once decrypted, we can modify it, as in the\n\nfollowing example where we add the local IP address 11.11.11.1:443 (ip of the laboratory\n\nenvironment) and load the module “mailsearcher”. With this we expect it to use the IP\n\n11.11.11.1:443 as command and control and load the module \"mailsearcher\" which\n\ndoes not usually come by default.\n\n\nAfter modifying it with a hexadecimal editor we would have the following:\n\n\n-----\n\nAfter the first 8 bytes is when the configuration data starts as such. In these first 8 bytes,\n\nit will be where Trickbot will look for the size of the data that will come next. In the case\n\nof example that corresponds to the value 02 00 (in the image it is upside down, 00 02),\n\nthis would be 0x200 bytes. If we select the dataset we will see that it has just the right\n\nsize of 0x200 bytes:\n\nTherefore, after modifying the information we must set the first bytes to tell Trickbot the\n\nexact size of the data. Then we encrypt with the function we have called aes_encrypt().\n\nWith this we will have a new configuration that will not yet be fully functional.\n\nThe reason it does not work is because Trickbot, after the encrypted data, places the\n\n**hash signature of the data. Therefore if we modify the content of the configuration we**\n\nhave to calculate the signature of the data since it verifies it after reading the\n\nconfiguration. To calculate the hash signature of the data that it has just read it uses the\n\nKEY that comes in the binary resources. We will see below how it loads the resources\n\n\nkey:\n\n\n-----\n\nThen it will execute the function LoadResource () and we will see in EAX the value where\n\n\nthe KEY will be:\n\n\nThis is what the key in the resources looks like (you will see that the presented binary\n\ndoes not have the typical CONFIG resource of version 14 of Trickbot, this is to force it to\n\nread the configuration of the config.conf file. This is not necessary but we have done it\n\n\nso that you can change the configuration in a simpler way):\n\n\nAnd we shall see that this is the key that imports the function BCryptImportKeyPair()\n\n\nwhen it does the push eax. The value of EAX is equal to 0x004B90E8, which as we\n\ncan see in the hexadecimal view corresponds to the key that was in the resources:\n\n\n-----\n\nAfter importing the key, it uses the BcryptVerifySignature() function to do the signature\n\n\nverification.\n\n\nThe other key that Trickbot uses is, as we have mentioned to decrypt the configuration\n\nand the modules, and we will see how it is imported by the function of the API\n\nCryptImportKey():\n\nAt this point we have two options: or modify the program execution flow so that the\n\nverification process will always tell us that the signature is correct or to replicate the\n\nprocess of signing the hash of the data that Trickbot performs. For simplicity we have\n\nchosen to modify the execution flow of the binary so that it does not need to be properly\n\nsigned.\n\n\n-----\n\n###### 7. IPC MECHANISM (Inter-Process Communication) \n\nOne of the interesting aspects of this malware is how it retrieves the information from the\n\nmodules. It uses ReadProcessMemory over the child processes it has created. Below\n\nwe will see the example where Trickbot (the core) reads what the systeminfo module\n\nreturns. If we stop in one of the ReadProcessMemory that we have identified, we see\n\nthat it passes the handle of the remote process (3D0) as a parameter:\n\n\nIn the following image we will see better how the 3D0 handler corresponds to the child\n\n\n###### 7. IPC\n\n\nprocess svchost.exe:\n\n\n-----\n\nWe can see the PID of the parent and child process here:\n\nThe memory address it wants to read (lpBaseaddress) is 0x2866f0, as we can see in\n\nthe ECX register of the ReadProcessMemory() image. As we have already said it wants\n\nto read it from the remote process svchost (handler 3D0) and at that moment what\n\n\ncontains that memory address is:\n\n\n-----\n\nWe can see in 0x2866f0 (230000 + 566f0) that the information is collected by the module\n\nand that the core is accessing it. In this case, this information will be sent to C2 using the\n\n63 command. We have seen an example of how the Trickbot core and the \"systeminfo\"\n\n\nmodule have exchanged the information.\n\n\n-----\n\n###### 8. RELATED FILES\n\n\nThe analyzed samples of **Trickbot to date have always been installed in the user’s**\n\n%APPDATA% folder who executes it first. In this folder it copies itself and creates 2 files:\n\n**client_id:** It contains an infected user ID generated from system data.\n\n**group_tag:** A campaign code which is in the internal configuration that can be\n\nfound encrypted in the resources of the executable, once unpacked, along with\n\nthe decryption key.\n\nApart from these files, if it has connectivity, it will download an updated configuration that\n\nwill be saved as encrypted \"config.conf\" in the same folder, and will create a \"Modules\"\n\n\nfolder.\n\n\nIn the folder called Modules it will download the modules that contain its encrypted\n\nconfiguration files, and folders with the configuration files of some of the modules. The\n\nfolders with the configurations of each module will have names following the pattern:\n\n\n\"<module name>_config\".\n\n\nWhen it obtains administration permissions, it copies itself to the folder:\n\n\nC:\\Windows\\System32\\config\\systemprofile\\AppData\\Roaming\n\n\nAfter executing this action, it removes the executable from the Roaming folder of the\n\n\ninitial user, leaving the modules and configurations intact.\n\n\n-----\n\n###### 9. DETECTION\n\n\n###### 9. DETECTION\n\n\nFirst, manually, you can find the files mentioned in section 8 in the folder: %APPDATA%,\n\nthe only case that can vary is the main executable that can be found with different names\n\n\ndepending on their origin, since the others to date have not changed at any time.\n\n\nDepending on the scenario, you can also find one or two tasks called \"bot\" or \"Drivers\n\nupdate\", and \"AplicationsCheckVersion\", which will execute an application in the%\n\n\nAPPDATA% directory every minute and when you log in respectively.\n\n\nDuring its execution, it is easier to detect it among processes running on 32-bit\n\ncomputers, because it keeps the executable name replicated in % appdata%. On the\n\nother hand, 64-bit computers use the Microsoft svchost.exe process to hide when run by\n\na normal system user. In the case of being invoked by the persistence task with SYSTEM\n\n\npermissions, it behaves the same as in 32-bit systems.\n\n\nFor automatic detection, there are no NIDS rules that can detect it through your traffic so\n\n\nfar, since the fact that it is encrypted by SSL complicates it to a greater extent.\n\n\nYara rules have been developed to detect it in memory, since the executable comes\n\npackaged with different types of systems for each campaign and version, preventing a\n\n\ncommon rule.\n\n\n-----\n\nThe rules for detection in memory are as follows:\n\n\nrule MALW_mailsercher_trickbot_module :\nTrojan\n{\nmeta:\nauthor = \"Marc Salinas @Bondey_m\"\ndescription = \" Detects mailsearcher\nmodule from Trickbot Trojan\"\n\nstrings:\n$str_mails_01 = \"mailsearcher\"\n$str_mails_02 = \"handler\"\n$str_mails_03 = \"conf\"\n$str_mails_04 = \"ctl\"\n$str_mails_05 = \"SetConf\"\n$str_mails_06 = \"file\"\n$str_mails_07 = \"needinfo\"\n$str_mails_08 = \"mailconf\"\n\ncondition:\nall of ($str_mails_*)\n}\n\n|rule MALW_trickbot_bankBot : Trojan { meta: author = \"Marc Salinas @Bondey_m\" description = \"Detects Trickbot Banking Trojan\" strings: $str_trick_01 = \"moduleconfig\" $str_trick_02 = \"Start\" $str_trick_03 = \"Control\" $str_trick_04 = \"FreeBuffer\" $str_trick_05 = \"Release\" condition: all of ($str_trick_*) }|rule MALW_systeminfo_trickbot_module : Trojan { meta: author = \"Marc Salinas @Bondey_m\" description = \"Detects systeminfo module from Trickbot Trojan\" strings: $str_systeminf_01 = \"<program>\" $str_systeminf_02 = \"<service>\" $str_systeminf_03 = \"</systeminfo>\" $str_systeminf_04 = \"GetSystemInfo.pdb\" $str_systeminf_05 = \"</autostart>\" $str_systeminf_06 = \"</moduleconfig>\" condition: all of ($str_ systeminf_*) }|\n|---|---|\n|rule MALW_dllinject_trickbot_module : Trojan { meta: author = \"Marc Salinas @Bondey_m\" description = \" Detects dllinject module from Trickbot Trojan\" strings: $str_dllinj_01 = \"user_pref(\" $str_dllinj_02 = \"<ignore_mask>\" $str_dllinj_03 = \"<require_header>\" $str_dllinj_04 = \"</dinj>\" condition: all of ($str_ dllinj_*) }|rule MALW_mailsercher_trickbot_module : Trojan { meta: author = \"Marc Salinas @Bondey_m\" description = \" Detects mailsearcher module from Trickbot Trojan\" strings: $str_mails_01 = \"mailsearcher\" $str_mails_02 = \"handler\" $str_mails_03 = \"conf\" $str_mails_04 = \"ctl\" $str_mails_05 = \"SetConf\" $str_mails_06 = \"file\" $str_mails_07 = \"needinfo\" $str_mails_08 = \"mailconf\" condition: all of ($str_mails_*) }|\n\n\n-----\n\n###### 10. DISINFECTION\n\n\nTaking into account the detection process, in case of finding traces of this threat in the\n\nsystem and that none of our system protection measures are able to detect or disinfect\n\n\nit, the ideal steps for disinfection would be to:\n\n\n\n- Eliminate the task that is executed every minute, so that it does not restart the\n\n\nexecution of the malware.\n\n\n\n- Complete the Trickbot process with the task manager or with an application\n\n\nsuch as ProcessExplorer.\n\n\n\n- Browse to the% APPDATA% folder where it is installed, to delete the main\n\n\nTrickbot executable and then the three files (\"user_id\", \"group_tag\" and\n\n\n\"config.conf\") and the Modules folder.\n\n\n\n- Browse to the SYSTEM user's APPDATA folder\n\n(C:\\Windows\\System32\\config\\systemprofile\\AppData\\Roaming) to delete the\n\n\nsame files from the SYSTEM user.\n\n\nWith this, we would have completely eliminated this threat from the system, although it\n\nwould be advisable to review that the task of persistence has not been restored in case\n\nthat just in the period of time between eliminating it and closing the process, it would\n\nhave been in the early stages of execution its and would have replaced it, although it\n\n\nwould not be dangerous as it could not find the executable in the system.\n\n\nOn the other hand, in cases where the infection has been through an ExploitKit, it is likely\n\nthat in addition to Trickbot, our system is infected with other types of malware, since\n\nthey usually do not install a single sample, so performing analyses with different tools\n\n\nwould be recommended, reaching formatting in sensitive cases.\n\n\n-----\n\n###### 11. ATTACKER INFORMATION\n\n\nFor the Trickbot infrastructure, as **@hasherezade** mentioned in its post in the blog of\n\n**Malwarebytes, the IPs of its C2 correspond to devices such as Routers or IP Cameras**\n\n(all tested with ARM processors) distributed by many different countries and in all the\n\ncases that we analyzed belonging to ISP of each of the countries that we will see below.\n\n\nThe distribution of C2 countries (based on the configurations collected) is shown in the\n\n\nfollowing chart where you can see how the United States and China stand out:\n\n\n-----\n\nMost affected systems have an access web interface such as the following:\n\nAnd in case of access by https to the URL formed by one of the Trickbot commands,\n\nthe certificate that it shows us, is still the same as in the first versions analyzed in the\n\n\npost mentioned above:\n\n\n-----\n\n###### 12. REFERENCES\n\n\n**_https://blog.fortinet.com/2016/12/06/deep-analysis-of-the-online-banking-botnet-_**\n**_trickbot_**\n\n**_http://www.threatgeek.com/2016/10/trickbot-the-dyre-connection.html_**\n\n**_https://www.infosecurity-magazine.com/blogs/rig-ek-dropping-trickbot-trojan/_**\n\n**_https://devcentral.f5.com/articles/is-xmaker-the-new-trickloader-24372_**\n\n**_https://blog.malwarebytes.com/threat-analysis/2016/10/trick-bot-dyrezas-successor/_**\n\n**_https://fraudwatchinternational.com/malware/trickbot-malware-works/_**\n\n**_https://msdn.microsoft.com/en-_**\n**_us/library/windows/desktop/ms682425%28v=vs.85%29.aspx_**\n\n**_https://msdn.microsoft.com/en-_**\n**_us/library/windows/desktop/aa366890%28v=vs.85%29.aspx_**\n\n**_https://msdn.microsoft.com/es-_**\n**_es/library/windows/desktop/ms681674%28v=vs.85%29.aspx_**\n\n**_https://msdn.microsoft.com/es-_**\n**_es/library/windows/desktop/ms682437%28v=vs.85%29.aspx_**\n\n\n###### 13. AUTHORS\n\n\n\n###### • Marc Salinas\n • José Miguel Holguín\n\n\n-----\n\nRamiro de Maeztu 7, bajo\n46022 Valencia\nT. (+34) 963 110 300\nF. (+34) 963 106 086\n\nOrense, 85. Ed. Lexington\n28020 Madrid\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://www.securityartwork.es/wp-content/uploads/2017/07/Trickbot-report-S2-Grupo.pdf"
    ],
    "report_names": [
        "Trickbot-report-S2-Grupo.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716493,
    "ts_updated_at": 1743041133,
    "ts_creation_date": 1499163855,
    "ts_modification_date": 1499163855,
    "files": {
        "pdf": "https://archive.orkl.eu/dc1818de10caed1a88a38e53817120354b04ebc2.pdf",
        "text": "https://archive.orkl.eu/dc1818de10caed1a88a38e53817120354b04ebc2.txt",
        "img": "https://archive.orkl.eu/dc1818de10caed1a88a38e53817120354b04ebc2.jpg"
    }
}