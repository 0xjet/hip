{
    "id": "47b8112b-20b5-4eae-b330-2ac2b2642f47",
    "created_at": "2023-01-12T15:05:53.594894Z",
    "updated_at": "2025-03-27T02:16:25.487221Z",
    "deleted_at": null,
    "sha1_hash": "8c764ddc1169fafcf5f5ac4e73a06af751d75cbc",
    "title": "2021-08-11 - DirtyMoe- Rootkit Driver",
    "authors": "",
    "file_creation_date": "2022-05-27T22:37:29Z",
    "file_modification_date": "2022-05-27T22:37:29Z",
    "file_size": 603343,
    "plain_text": "# DirtyMoe: Rootkit Driver\n\n**decoded.avast.io/martinchlumecky/dirtymoe-rootkit-driver/**\n\nby [Martin ChlumeckýAugust 11, 202138 min read](https://decoded.avast.io/author/martinchlumecky/)\n\n**Abstract**\n\n\nAugust 11, 2021\n\n\nIn the first post [DirtyMoe: Introduction and General Overview of Modularized Malware, we have](https://decoded.avast.io/martinchlumecky/dirtymoe-1/)\ndescribed one of the complex and sophisticated malware called DirtyMoe. The main observed\nroles of the malware are Cryptojacking and DDoS attacks that are still popular. There is no doubt\nthat malware has been released for profit, and all evidence points to Chinese territory. In most\ncases, the PurpleFox campaign is used to exploit vulnerable systems where the exploit gains the\nhighest privileges and installs the malware via the MSI installer. In short, the installer misuses\nWindows System Event Notification Service (SENS) for the malware deployment. At the end of\nthe deployment, two processes (workers) execute malicious activities received from wellconcealed C&C servers.\n\n[As we mentioned in the first post, every good malware must implement a set of protection, anti-](https://decoded.avast.io/martinchlumecky/dirtymoe-1/)\nforensics, anti-tracking, and anti-debugging techniques. One of the most used techniques for\nhiding malicious activity is using rootkits. In general, the main goal of the rootkits is to hide itself\nand other modules of the hosted malware on the kernel layer. The rootkits are potent tools but\ncarry a high risk of being detected because the rootkits work in the kernel-mode, and each\ncritical bug leads to BSoD.\n\nThe primary aim of this next article is to analyze rootkit techniques that DirtyMoe uses. The main\npart of this study examines the functionality of a DirtyMoe driver, aiming to provide complex\ninformation about the driver in terms of static and dynamic analysis. The key techniques of the\nDirtyMoe rootkit can be listed as follows: the driver can hide itself and other malware activities on\nkernel and user mode. Moreover, the driver can execute commands received from the usermode under the kernel privileges. Another significant aspect of the driver is an injection of an\narbitrary DLL file into targeted processes. Last but not least is the driver’s functionality that\ncensors the file system content. In the same way, we describe the refined routine that deploys\nthe driver into the kernel and which anti-forensic method the malware authors used.\n\n\n-----\n\nAnother essential point of this research is the investigation of the driver s meta-data, which\nshowed that the driver is code-signed with the certificates that have been stolen and revoked in\nthe past. However, the certificates are widespread in the wild and are misused in other malicious\nsoftware in the present.\n\nFinally, the last part summarises the rootkit functionally and draws together the key findings of\ndigital certificates, making a link between DirtyMoe and other malicious software. In addition, we\ndiscuss the implementation level and sources of the used rootkit techniques.\n\n## 1. Sample\n\nThe subject of this research is a sample with SHA-256:\n\n```\nAABA7DB353EB9400E3471EAAA1CF0105F6D1FAB0CE63F1A2665C8BA0E8963A05\n\n```\n\nThe sample is a windows driver that DirtyMoe drops on the system startup.\n\n_Note: VirusTotal keeps a record of 44 of 71 AV engines (62 %) which detect the samples as_\n_malicious. On the other hand, the DirtyMoe DLL file is detected by 86 % of registered AVs._\n_Therefore, the detection coverage is sufficient since the driver is dumped from the DLL file._\n\n**Basic Information**\n\nFile Type: Portable Executable 64\nFile Info: Microsoft Visual C++ 8.0 (Driver)\nFile Size: 116.04 KB (118824 bytes)\nDigital Signature: Shanghai Yulian Software Technology Co., Ltd. (上海域联软件技术有限公\n司)\n\n**Imports**\n\nThe driver imports two libraries `FltMgr and` `ntosrnl . Table 1 summarizes the most`\nsuspicious methods from the driver’s point.\n\n**Routine** **Description**\n\n`FltSetCallbackDataDirty` A minifilter driver’s pre or post operation calls the routine to\nindicate that it has modified the contents of the callback\ndata structure.\n\n`FltGetRequestorProcessId` Routine returns the process ID for the process requested\nfor a given I/O operation.\n\n`FltRegisterFilter` FltRegisterFilter registers a minifilter driver.\n\n`ZwDeleteValueKey` Routines delete, set, query, and open registry entries in\n\n`ZwSetValueKey` kernel-mode.\n```\n ZwQueryValueKey\n ZwOpenKey\n\n```\n`ZwTerminateProcess` Routine terminates a process and all of its threads in\nkernel-mode.\n\n`ZwQueryInformationProcess` Retrieves information about the specified process.\n\n\n-----\n\n`MmGetSystemRoutineAddress` Returns a pointer to a function specified by a routine\nparameter.\n\n`ZwAllocateVirtualMemory` Reserves a range of application-accessible virtual\naddresses in the specified process in kernel-mode.\n\n**Table 1. Kernel methods imported by the DirtyMoe driver**\nAt first glance, the driver looks up kernel routine via `MmGetSystemRoutineAddress() as a form`\nof obfuscation since the string table contains routine names operating with `VirtualMemory ;`\ne.g., `ZwProtectVirtualMemory(),` `ZwReadVirtualMemory(),` `ZwWriteVirtualMemory() .`\nThe kernel-routine `ZwQueryInformationProcess() and strings such as` `services.exe,`\n```\nwinlogon.exe point out that the rootkit probably works with kernel structures of the critical\n\n```\nwindows processes.\n\n## 2. DirtyMoe Driver Analysis\n\nThe DirtyMoe driver does not execute any specific malware activities. However, it provides a\nwide scale of rootkit and backdoor techniques. The driver has been designed as a service\nsupport system for the DirtyMoe service in the user-mode.\n\nThe driver can perform actions originally needed with high privileges, such as writing a file into\nthe system folder, writing to the system registry, killing an arbitrary process, etc. The malware in\nthe user-mode just sends a defined control code, and data to the driver and it provides higher\nprivilege actions.\n\nFurther, the malware can use the driver to hide some records helping to mask malicious\nactivities. The driver affects the system registry, and can conceal arbitrary keys. Moreover, the\nsystem process `services.exe is patched in its memory, and the driver can exclude arbitrary`\nservices from the list of running services. Additionally, the driver modifies the kernel structures\nrecording loaded drivers, so the malware can choose which driver is visible or not. Therefore, the\nmalware is active, but the system and user cannot list the malware records using standard API\ncalls to enumerate the system registry, services, or loaded drivers. The malware can also hide\nrequisite files stored in the file system since the driver implements a mechanism of the minifilter.\nConsequently, if a user requests a record from the file system, the driver catches this request\nand can affect the query result that is passed to the user.\n\nThe driverconsists of 10 main functionalities as Table 2 illustrates.\n\n**Function** **Description**\n\n\nDriver\nEntry\n\nStart\nRoutine\n\n\nroutine called by the kernel when the driver is loaded.\n\nis run as a kernel thread restoring the driver configuration from the system\nregistry.\n\n\n-----\n\nDevice\nControl\n\nMinifilter\nDriver\n\nThread\nNotification\n\nCallback of\nNTFS\nDriver\n\nRegistry\nHiding\n\nService\nHiding\n\nDriver\nHiding\n\nDriver\nUnload\n\n\nprocesses system-defined I/O control codes (IOCTLs) controlling the driver from\nthe user-mode.\n\nroutine completes processing for one or more types of I/O operations;\n_QueryDirectory in this case. In other words, the routine filters folder_\nenumerations.\n\nroutine registers a driver-supplied callback that is notified when a new thread is\ncreated.\n\nwraps the original callback of the NTFS driver for `IRP_MJ_CREATE major`\nfunction.\n\nis hook method provides registry key hiding.\n\nis a routine hiding a defined service.\n\nis a routine hiding a defined driver.\n\nroutine is called by kernel when the driver is unloaded.\n\n\n**Table 2. Main driver functionality**\nMost of the implemented functionalities are available as public samples on internet forums. The\nlevel of programming skills is different for each driver functionality. It seems that the driver author\nmerged the public samples in most cases. Therefore, the driver contains a few bugs and unused\ncode. The driver is still in development, and we will probably find other versions in the wild.\n\n## 2.1 Driver Entry\n\nThe Driver Entry is the first routine that is called by the kernel after driver loading. The driver\ninitializes a large number of global variables for the proper operation of the driver. Firstly, the\ndriver detects the OS version and setups required offsets for further malicious use. Secondly, the\nvariable for pointing of the driver image is initialized. The driver image is used for hiding a driver.\nThe driver also associates the following major functions:\n\n1. `IRP_MJ_CREATE,` `IRP_MJ_CLOSE – no interest action,`\n2. `IRP_MJ_DEVICE_CONTROL – used for driver configuration and control,`\n3. `IRP_MJ_SHUTDOWN – writes malware-defined data into the disk and registry.`\n\nThe Driver Entry creates a symbolic link to the driver and tries to associate it with other malicious\nmonitoring or filtering callbacks. The first one is a minifilter activated by the\n```\nFltRegisterFilter() method registering the FltPostOperation() ; it filters access to the\n\n```\nsystem drives and allows it to hide files and directories.\n\n\n-----\n\nFurther, the initialization method swaps a major function `IRP_MJ_CREATE for`\n```\n\\FileSystem\\Ntfs driver. So, each API call of CreateFile() or a kernel-mode function\nIoCreateFile() can be monitored and affected by the malicious MalNtfsCreatCallback()\n\n```\ncallback.\n\nAnother Driver Entry method sets a callback method using\n```\nPsSetCreateThreadNotifyRoutine() . The NotifyRoutine() monitors a kernel process\n\n```\ncreation, and the malware can inject malicious code into newly created processes/threads.\n\nFinally, the driver tries to restore its configuration from the system registry.\n\n## 2.2 Start Routine\n\nThe Start Routine is run as a kernel system thread created in the Driver Entry routine. The Start\n_Routine writes the driver version into the SYSTEM registry as follows:_\n\nKey: `HKLM\\SYSTEM\\CurrentControlSet\\Control\\WinApi\\WinDeviceVer`\nValue: `20161122`\n\nIf the following `SOFTWARE registry key is present, the driver loads artifacts needed for the`\nprocess injecting:\n\n```\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\Secure\n\n```\n\nThe last part of Start Routine loads the rest of the necessary entries from the registry. The\ncomplete list of the system registry is documented in Appendix A.\n\n## 2.3 Device Control\n\nThe device control is a mechanism for controlling a loaded driver. A driver receives the\n```\nIRP_MJ_DEVICE_CONTROL I/O control code (IOCTL) if a user-mode thread calls Win32 API\n\n```\n`DeviceIoControl() ; visit` [1] for more information. The user-mode application sends\n```\nIRP_MJ_DEVICE_CONTROL directly to a specific device driver. The driver then performs the\n\n```\ncorresponding operation. Therefore, malicious user-mode applications can control the driver via\nthis mechanism.\n\nThe driver supports approx. 60 control codes. We divided the control codes into 3 basic groups:\n**controlling, inserting, and setting.**\n\n**Controlling**\n\nThere are 9 main control codes invoking driver functionality from the user-mode. The following\n**Table 3 summarizes controlling IOCTL that can be sent by malware using the Win32 API.**\n\n**IOCTL** **Description**\n\n0x222C80 The driver accepts other IOCTLs only if the driver is activated. Malware in the\nuser-mode can activate the driver by sending this IOCTL and authorization code\nequal `0xB6C7C230 .`\n\n\n-----\n\n0x2224C0 The malware sends data which the driver writes to the system registry. A key,\nvalue, and data type are set by Setting control codes.\n_used variable: regKey, regValue, regData, regType_\n\n0x222960 This IOCTL clears all data stored by the driver.\n_used variable: see Settingand Insertingvariables_\n\n0x2227EC If the malware needs to hide a specific driver, the driver adds a specific driver\nname to the\n_listBaseDllName and hides it using Driver Hiding._\n\n0x2227E8 The driver adds the name of the registry key to the WinDeviceAddress list and\nhides this key\nusing Registry Hiding.\n_used variable: WinDeviceAddress_\n\n0x2227F0 The driver hides a given service defined by the name of the DLL image. The\nname is inserted into the listServices variable, and the Service Hiding technique\nhides the service in the system.\n\n0x2227DC If the malware wants to deactivate the Registry Hiding, the driver restores the\noriginal kernel\n```\n        GetCellRoutine() .\n\n```\n0x222004 The malware sends a process ID that wants to terminate. The driver calls kernel\nfunction\n```\n        ZwTerminateProcess() and terminates the process and all of its threads\n\n```\nregardless of malware privileges.\n\n0x2224C8 The malware sends data which driver writes to the file defined by filePath\nvariable; see Setting control codes\n_used variable: filePath, fileData_\n\n**Table 3. Controlling IOCTLs**\n**Inserting**\n\nThere are 11 control codes inserting items into white/blacklists. The following Table 4\nsummarizes variables and their purpose.\n\n\n**White/Black**\n**list**\n\nRegistry\nHIVE\n\nProcess\nImage File\nName\n\n\n**Variable** **Purpose**\n\nWinDeviceAddress Defines a list of registry entries that the malware wants\nto hide in the system.\n\nWinDeviceMaker Represents a whitelist of processes defined by process\n_image file name. It is used in_ Callback of NTFS Driver,\nand grants access to the NTFS file systems. Further, it\noperates in Minifilter Driver and prevents hiding files\ndefined in the WinDeviceNumber variable. The last use\nis in Registry Hiding; the malware does not hide\nregistry keys for the whitelisted processes.\n\n\n-----\n\nWinDeviceMakerB Defines a whitelist of processes defined by process\n_image file name. It is used in_ Callback of NTFS Driver,\nand grants access to the NTFS file systems.\n\nWinDeviceMakerOnly Specifies a blacklist of processes defined by the\n_process image file name. It is used in_ Callback of\nNTFS Driver and refuses access to the NTFS file\nsystems.\n\n\nFile names\n(full path)\n\nFile names\n(containing\n_number)_\n\n\nWinDeviceName\nWinDeviceNameB\n\n\nWinDeviceNameOnly Defines a blacklist of files that should be denied access\nby Callback of NTFS Driver. It is used in combination\nwith WinDeviceMakerOnly. So, if a file is on the\nblacklist and a requesting process is also blacklisted,\nthe driver refuses access to the file.\n\nWinDeviceNumber Defines a list of files that should be hidden in the\nsystem by Minifilter Driver. The malware uses a name\nconvention as follows: `[A-Z][a-z][0-9]+\\.[a-z]`\n```\n            {3} . So, a file name includes a number.\n\n```\n\nDetermines a whitelist of files that should be granted\naccess by Callback of NTFS Driver. It is used in\ncombination with WinDeviceMaker and\n_WinDeviceMakerB. So, if a file is on the whitelist and a_\nrequested process is also whitelisted, the driver grants\naccess to the file.\n\n\nProcess ID ListProcessId1 Defines a list of processes requiring access to NTFS\nfile systems. The malware does not restrict the access\nfor these processes; see Callback of NTFS Driver.\n\nListProcessId2 The same purpose as ListProcessId1. Additionally, it is\nused as the whitelist for the registry hiding, so the\ndriver does not restrict access. The Minifilter Driver\ndoes not limit processes in this list.\n\n\nDriver\nnames\n\nService\nnames\n\n\nlistBaseDllName Defines a list of drivers that should be hidden in the\nsystem;\nsee Driver Hiding.\n\nlistServices Specifies a list of services that should be hidden in the\nsystem;\nsee Service Hiding.\n\n\n**Table 4. White and Black lists**\n**Setting**\n\nThe setting control codes store scalar values as a global variable. The following Table 5\nsummarizes and groups these variables and their purpose.\n\n**Function** **Variable** **Description**\n\n\n-----\n\nFile Writing\n(Shutdown)\n\nRegistry\nWriting\n(Shutdown)\n\nFile Data\nWriting\n\nRegistry\nWriting\n\nUnknow\n(unused)\n\n\nfilename1_for_ShutDown\ndata1_for_ShutDown\n\nfilename2_for_ShutDown\ndata2_for_ShutDown\n\nregKey1_shutdown\nregValue1_shutdown\nregData1_shutdown\nregType1\n\nregKey2_shutdown\nregValue2_shutdown\nregData2_shutdown\nregType2\n\n\nregKey\nregValue\nregType\n\ndwWinDevicePathA\ndwWinDeviceDataA\n\ndwWinDevicePathB\ndwWinDeviceDataB\n\n\nDefines a file name and data for the first file written\nduring the driver shutdown.\n\nDefines a file name and data for the second file\nwritten during the driver shutdown.\n\nSpecifies the first registry key path, value name,\ndata, and type (REG_BINARY, REG_DWORD,\nREG_SZ, etc.) written during the driver shutdown.\n\nSpecifies the second registry key path, value name,\ndata, and type (REG_BINARY, REG_DWORD,\nREG_SZ, etc.) written during the driver shutdown.\n\n\nfilePath Determines filename which will be used to write\ndata;\nsee **ControllingIOCTL** `0x2224C8 .`\n\n\nSpecifies registry key path, value name, and type\n(REG_BINARY, REG_DWORD, REG_SZ, etc.);\nsee **ControllingIOCTL** `0x2224C0 .`\n\nKeeps a path and data for file A.\n\nKeeps a path and data for file B.\n\n\n**Table 5. Global driver variables**\nThe following Table 6 summarizes variables used for the process injection; see Thread\nNotification.\n\n**Function** **Variable** **Description**\n\n\nProcess\nto Inject\n\nDLL to\nInject\n\n\ndwWinDriverMaker2\ndwWinDriverMaker2_2\n\ndwWinDriverMaker1\ndwWinDriverMaker1_2\n\ndwWinDriverPath1\ndwWinDriverDataA\n\ndwWinDriverPath1_2\ndwWinDriverDataA_2\n\ndwWinDriverPath2\ndwWinDriverDataB\n\n\nDefines two command-line arguments. If a process with\none of the arguments is created, the driver should inject\nthe process.\n\nDefines two process names that should be injected if the\nprocess is created.\n\nSpecifies a file name and data for the process injection\ndefined by dwWinDriverMaker2 or dwWinDriverMaker1.\n\nDefines a file name and data for the process injection\ndefined by dwWinDriverMaker2_2 or\n_dwWinDriverMaker1_2._\n\nKeeps a file name and data for the process injection\ndefined by dwWinDriverMaker2 or dwWinDriverMaker1.\n\n\n-----\n\ndwWinDriverPath2_2\ndwWinDriverDataB_2\n\n**Table 6. Injection variables**\n\n## 2.4 Minifilter Driver\n\n\nSpecifies a file name and data for the process injection\ndefined by dwWinDriverMaker2_2 or\n_dwWinDriverMaker1_2._\n\n\nThe minifilter driver is registered in the Driver Entry routine using the `FltRegisterFilter()`\nmethod. One of the method arguments defines configuration ( FLT_REGISTRATION ) and\ncallback methods ( FLT_OPERATION_REGISTRATION ). If the QueryDirectory system request is\ninvoked, the malware driver catches this request and processes it by its `FltPostOperation() .`\n\nThe `FltPostOperation() method can modify a result of the QueryDirectory operations (IRP).`\nIn fact, the malware driver can affect (hide, insert, modify) a directory enumeration. So, some\napplications in the user-mode may not see the actual image of the requested directory.\n\nThe driver affects the QueryDirectory results only if a requested process is not present in\nwhitelists. There are two whitelists. The first whitelists (Process ID and File names) cause that\nthe QueryDirectory results are not modified if the process ID or process image file name,\nrequesting the given I/O operation (QueryDirectory), is present in the whitelists. It represents\nmalware processes that should have access to the file system without restriction. The further\nwhitelist is called WinDeviceNumber, defining a set of suffixes. The `FltPostOperation()`\niterates each item of the QueryDirectory. If the enumerated item name has a suffix defined in the\nwhitelist, the driver removes the item from the QueryDirectory results. It ensures that the\nwhitelisted files are not visible for non-malware processes [2]. So, the driver can easily hide an\narbitrary directory/file for the user-mode applications, including `explorer.exe . The name of`\nthe WinDeviceNumber whitelist is probably derived from malware file names, e.g,\n\n`Ke145057.xsl, since the suffix is a number; see` Appendix B.\n\n## 2.5 Callback of NTFS Driver\n\nWhen the driver is loaded, the Driver Entry routine modifies the system driver for the NTFS\nfilesystem. The original callback method for the `IRP_MJ_CREATE major function is replaced by a`\nmalicious callback `MalNtfsCreatCallback() as Figure 1 illustrates. The malicious callback`\ndetermines what should gain access and what should not.\n\n\n-----\n\n**Figure 1. Rewrite IRP_MJ_CREATE callback of the regular NTFS driver**\nThe malicious callback is active only if the Minifilter Driver registration has been done and the\noriginal callback has been replaced. There are whitelists and one blacklist. The whitelists store\ninformation about allowed process image names, process ID, and allowed files. If the process\nrequesting the disk access is whitelisted, then the requested file must also be on the white list. It\nis double protection. The blacklist is focused on processing image names. Therefore, the\nblacklisted processes are denied access to the file system. Figure 2 demonstrates the\nwhitelisting of processes. If a process is on the whitelist, the driver calls the original callback;\notherwise, the request ends with access denied.\n\n**Figure 2. Grant access to whitelisted processes**\nIn general, if the malicious callback determines that the requesting process is authorized to\naccess the file system, the driver calls the original `IRP_MJ_CREATE major function. If not, the`\ndriver finishes the request as `STATUS_ACCESS_DENIED .`\n\n## 2.6 Registry Hiding\n\nThe driver can hide a given registry key. Each manipulation with a registry key is hooked by the\nkernel method `GetCellRoutine() . The configuration manager assigns a control block for each`\nopen registry key. The control block ( CM_KEY_CONTROL_BLOCK ) structure keeps all control\nblocks in a hash table to quickly search for existing control blocks. The `GetCellRoutine()`\n\n\n-----\n\nhook method computes a memory address of a requested key. Therefore, if the malware driver\ntakes control over the `GetCellRoutine(), the driver can filter which registry keys will be`\nvisible; more precisely, which keys will be searched in the hash table.\n\nThe malware driver finds an address of the original `GetCellRoutine() and replaces it with its`\nown malicious hook method, `MalGetCellRoutine() . The driver uses well-documented`\nimplementation [3, 4]. It just goes through kernel structures obtained via the `ZwOpenKey()`\nkernel call. Then, the driver looks for `CM_KEY_CONTROL_BLOCK, and its associated HHIVE`\nstructured correspond with the requested key. The HHIVE structure contains a pointer to the\n```\nGetCellRoutine() method, which the driver replaces; see Figure 3.\n\n```\n**Figure 3. Overwriting GetCellRoutine**\nThis method’s pitfall is that offsets of looked structure, variable, or method are specific for each\nwindows version or build. So, the driver must determine on which Windows version the driver\nruns.\n\nThe `MalGetCellRoutine() hook method performs 3 basic operations as follow:`\n\n1. The driver calls the original kernel `GetCellRoutine() method.`\n2. Checks whitelists for a requested registry key.\n3. Catches or releases the requested registry key according to the whitelist check.\n\n**Registry Key Hiding**\n\nThe hiding technique uses a simple principle. The driver iterates across a whole HIVE of a\nrequested key. If the driver finds a registry key to hide, it returns the last registry key of the\niterated HIVE. When the interaction is at the end of the HIVE, the driver does not return the last\nkey since it was returned before, but it just returns NULL, which ends the HIVE searching.\n\n\n-----\n\nThe consequence of this principle is that if the driver wants to hide more than one key, the driver\nreturns the last key of the searched HIVE more times. So, the final results of the registry query\ncan contain duplicate keys.\n\n**Whitelisting**\n\nThe `services.exe and` `System services are whitelisted by default, and there is no restriction.`\nWhitelisted process image names are also without any registry access restriction.\n\nA decision-making mechanism is more complicated for Windows 10. The driver hides the\nrequest key only for `regedit.exe application if the Windows 10 build is 14393 (July 2016) or`\n15063 (March 2017).\n\n## 2.7 Thread Notification\n\nThe main purpose of the Thread Notification is to inject malicious code into created threads. The\ndriver registers a thread notification routine via `PsSetCreateThreadNotifyRoutine() during`\nthe Device Entry initialization. The routine registers a callback which is subsequently notified\nwhen a new thread is created or deleted. The suspicious callback\n( PCREATE_THREAD_NOTIFY_ROUTINE ) `NotifyRoutine() takes three arguments: ProcessID,`\n_ThreadID, and Create flag. The driver affects only threads in which Create flag is set to TRUE,_\nso only newly created threads.\n\nThe whitelisting is focused on two aspects. The first one is an image name, and the second one\nis command-line arguments of a created thread. The image name is stored in WinDriverMaker1,\nand arguments are stored as a checksum in the WinDriverMaker2 variable. The driver is\ndesigned to inject only two processes defined by a process name and two processes defined by\n_command line arguments. There are no whitelists, just 4 global variables._\n\n2.7.1 Kernel Method Lookup\n\nThe successful injection of the malicious code requires several kernel methods. The driver does\nnot call these methods directly due to detection techniques, and it tries to obfuscate the required\nmethod. The driver requires the following kernel methods: `ZwReadVirtualMemory,`\n```\nZwWriteVirtualMemory, ZwQueryVirtualMemory, ZwProtectVirtualMemory,\nNtTestAlert, LdrLoadDll\n\n```\nThe kernel methods are needed for successful thread injection because the driver needs to\nread/write process data of an injected thread, including program instruction.\n\n**Virtual Memory Method Lookup**\n\nThe driver gets the address of the `ZwAllocateVirtualMemory() method. As Figure 4`\nillustrates, all lookup methods are consecutively located after `ZwAllocateVirtualMemory()`\nmethod in `ntdll.dll .`\n\n\n-----\n\n**Figure 4. Code segment of ntdll.dll with VirtualMemory methods**\nThe driver starts to inspect the code segments from the address of the\n```\nZwAllocateVirtualMemory() and looks up for instructions representing the constant move to\neax (e.g. mov eax, ??h ). It identifies the VirtualMemory methods; see Table 7 for\n\n```\nconstants.\n\n**Constant** **Method**\n\n0x18 `ZwAllocateVirtualMemory`\n\n0x23 `ZwQueryVirtualMemory`\n\n0x3A `NtWriteVirtualMemory`\n\n0x50 `ZwProtectVirtualMemory`\n\n**Table 7. Constants of Virtual Memory methods for Windows 10 (64 bit)**\nWhen an appropriate constants is found, the final address of a lookup method is calculated as\nfollow:\n```\nmethod_address = constant_address - alignment_constant ;\n\n```\nwhere `alignment_constant helps to point to the start of the looked-up method.`\n\nThe steps to find methods can be summarized as follow:\n\n1. Get the address of `ZwAllocateVirtualMemory(), which is not suspected in terms of`\n\ndetection.\n\n\n-----\n\n2. Each sought method contains a specific constant on a specific address\n\n( constant_address ).\n3. If the `constant_address is found, another specific offset ( alignment_constant ) is`\n\nsubtracted;\nthe `alignment_constant` is specific for each Windows version.\n\nThe exact implementation of the Virtual Memory Method Lookup method is shown in Figure 5.\n\n**Figure 5. Implementation of the lookup routine searching for the kernel VirtualMemory methods**\nThe success of this obfuscation depends on the Window version identification. We found one\nWindows 7 version which returns different methods than the malware wants; namely,\n```\nZwCompressKey(), ZwCommitEnlistment(), ZwCreateNamedPipeFile(),\nZwAlpcDeleteSectionView() .\n\n```\nThe `alignment_constant is derived from the current Windows version during the driver`\ninitialization; see the Driver Entry routine.\n\n\n-----\n\n**NtTestAlert and LdrLoadDll Lookup**\n\nA different approach is used for getting `NtTestAlert() and` `LdrLoadDll() routines. The`\ndriver attaches to the `winlogon.exe process and gets the pointer to the kernel structure`\n```\nPEB_LDR_DATA containing PE header and imports of all processes in the system. If the import\n\n```\ntable includes a required method, then the driver extracts the base address, which is the entry\npoint to the sought routine.\n\n2.7.2 Process Injection\n\nThe aim of the process injection is to load a defined DLL library into a new thread via kernel\nfunction `LdrLoadDll() . The process injection is slightly different for x86 and x64 OS versions.`\n\nThe x64 OS version abuses the original `NtTestAlert() routine, which checks the thread’s`\nAPC queue. The APC (Asynchronous Procedure Call) is a technique to queue a job to be done\nin the context of a specific thread. It is called periodically. The driver rewrites the instructions of\nthe `NtTestAlert() which jumps to the entry point of the malicious code.`\n\n**Modification of NtTestAlert Code**\n\nThe first step to the process injection is to find free memory for a code cave. The driver finds the\nfree memory near the `NtTestAlert() routine address. The code cave includes a shellcode as`\n**Figure 6. demonstrates.**\n\n**Figure 6. Malicious payload overwriting the original NtTestAlert() routine**\nThe shellcode prepares a parameter ( code_cave address) for the malicious code and then\njumps into it. The original `NtTestAlert() address is moved into` `rax because the malicious`\ncode ends by the return instruction, and therefore the original `NtTestAlert() is invoked.`\nFinally, `rdx contains the jump address, where the driver injected the malicious code. The next`\nitem of the code cave is a path to the DLL file, which shall be loaded into the injected process.\nOther items of the code cave are the original address and original code instructions of the\n```\nNtTestAlert() .\n\n```\nThe driver writes the malicious code into the address defined in `dll_loading_shellcode . The`\noriginal instructions of `NtTestAlert() are rewritten with the instruction which just jumps to the`\nshellcode. It causes that when the `NtTestAlert() is called, the shellcode is activated and`\njumps into the malicious code.\n\n**Malicious Code x64**\n\n\n-----\n\nThe malicious code for x64 is simple. Firstly, it recovers the original instruction of the rewritten\n```\nNtTestAlert() code. Secondly, the code invokes the found LdrLoadDll() method and\n\n```\nloads appropriate DLL into the address space of the injected process. Finally, the code executes\nthe return instruction and jumps back to the original `NtTestAlert() function.`\n\nThe x86 OS version abuses the entry point of the injected process directly. The procedure is very\nsimilar to the x64 injection, and the x86 malicious code is also identical to the x64 version.\nHowever, the x86 malicious code needs to find a 32bit variant of the `LdrLoadDll() method. It`\nuses the similar technique described above (NtTestAlert and LdrLoadDll Lookup).\n\n## 2.8 Service Hiding\n\nWindows uses the Services Control Manager (SCM) to manage the system services. The\nexecutable of SCM is `services.exe . This program runs at the system startup and performs`\nseveral functions, such as running, ending, and interacting with system services. The SCM\nprocess also keeps all run services in an undocumented service record ( SERVICE_RECORD )\nstructure.\n\nThe driver must patch the service record to hide a required service. Firstly, the driver must find\nthe process `services.exe and attach it to this one via` `KeStackAttachProcess() . The`\nmalware author defined a byte sequence which the driver looks for in the process memory to find\nthe service record. The `services.exe keeps all run services as a linked list of`\n\n`SERVICE_RECORD` [5]. The malware driver iterates this list and unlinks required services defined\nby listServices whitelist; see Table 4.\n\nThe used byte sequence for Windows 2000, XP, Vista, and Windows 7 is as follows: `{45 3B E5`\n```\n74 40 48 8D 0D} . There is another byte sequence {48 83 3D ?? ?? ?? ?? ?? 48 8D 0D}\n\n```\nthat is never used because it is bound to the Windows version that the malware driver has never\nidentified; maybe in development.\n\nThe hidden services cannot be detected using PowerShell command `Get-Service, Windows`\nTask Manager, Process Explorer, etc. However, started services are logged via Windows Event\nLog. Therefore, we can enumerate all regular services and all logged services. Then, we can\ncreate differences to find hidden services.\n\n## 2.9 Driver Hiding\n\nThe driver is able to hide itself or another malicious driver based on the IOCTL from the usermode. The [Driver Entry is initiated by a parameter representing a driver object (DRIVER_OBJECT)](https://www.nirsoft.net/kernel_struct/vista/DRIVER_OBJECT.html)\nof the loaded driver image. The driver object contains an officially undocumented item called a\ndriver section. The `LDR_DATA_TABLE_ENTRY kernel structure stores information about the loaded`\ndriver, such as base/entry point address, image name, image size, etc. The driver section points\nto `LDR_DATA_TABLE_ENTRY as a double-linked list representing all loaded drivers in the system.`\n\n\n-----\n\nWhen a user-mode application lists all loaded drivers, the kernel enumerates the double-linked\nlist of the `LDR_DATA_TABLE_ENTRY structure. The malware driver iterates the whole list and`\nunlinks items (drivers) that should be hidden. Therefore, the kernel loses pointers to the hidden\ndrivers and cannot enumerate all loaded drivers [6].\n\n## 2.10 Driver Unload\n\nThe Driver Unload function contains suspicious code, but it seems to be never used in this\nversion. The rest of the unload functionality executes standard procedure to unload the driver\nfrom the system.\n\n## 3. Loading Driver During Boot\n\nThe DirtyMoe service loads the malicious driver. A driver image is not permanently stored on a\ndisk since the service always extracts, loads, and deletes the driver images on the service\nstartup. The secondary service aim is to eliminate evidence about driver loading and eventually\ncomplicate a forensic analysis. The service aspires to camouflage registry and disk activity. The\nDirtyMoe service is registered as follows:\n```\nService name: Ms<volume_id>App ; e.g., MsE3947328App\nRegistry key: HKLM\\SYSTEM\\CurrentControlSet\\services\\<service_name>\nImagePath: %SystemRoot%\\system32\\svchost.exe -k netsvcs\nServiceDll: C:\\Windows\\System32\\<service_name>.dll, ServiceMain\nServiceType: SERVICE_WIN32_SHARE_PROCESS\nServiceStart: SERVICE_AUTO_START\n\n## 3.1 Registry Operation\n\n```\nOn startup, the service creates a registry record, describing the malicious driver to load; see\nfollowing example:\n```\nRegistry key: HKLM\\SYSTEM\\CurrentControlSet\\services\\dump_E3947328\nImagePath: \\??\\C:\\Windows\\System32\\drivers\\dump_LSI_FC.sys\nDisplayName: dump_E3947328\n\n```\nAt first glance, it is evident that `ImagePath does not reflect` `DisplayName, which is the`\nWindows common naming convention. Moreover, `ImagePath prefixed with` `dump_ string is`\nused for virtual drivers (loaded only in memory) managing the memory dump during the\nWindows crash. The malware tries to use the virtual driver name convention not to be so\nconspicuous. The principle of the Dump Memory using the virtual drivers is described in [7, 8].\n```\nImagePath values are different from each windows reboot, but it always abuses the name of\n\n```\nthe system native driver; see a few instances collected during windows boot: `dump_ACPI.sys,`\n```\ndump_RASPPPOE.sys, dump_LSI_FC.sys, dump_USBPRINT.sys, dump_VOLMGR.sys,\ndump_INTELPPM.sys, dump_PARTMGR.sys\n\n## 3.2 Driver Loading\n\n```\n\n-----\n\nWhen the registry entry is ready, the DirtyMoe service dumps the driver into the file defined by\n```\nImagePath . Then, the service loads the driver via ZwLoadDriver() .\n\n## 3.3 Evidence Cleanup\n\n```\nWhen the driver is loaded either successfully or unsuccessfully, the DirtyMoe service starts to\nmask various malicious components to protect the whole malware hierarchy.\n\nThe DirtyMoe service removes the registry key representing the loaded driver; see Registry\nOperation. Further, the loaded driver hides the malware services, as the Service Hiding section\ndescribes. Registry entries related to the driver are removed via the API call. Therefore, a\nforensics track can be found in the SYSTEM registry HIVE, located in\n```\n%SystemRoot%\\system32\\config\\SYSTEM . The API call just removes a relevant HIVE pointer,\n\n```\nbut unreferenced data is still present in the HIVE stored on the disk. Hence, we can read\n[removed registry entries via RegistryExplorer.](https://ericzimmerman.github.io/#!index.md)\n\nThe loaded driver also removes the dumped ( dump_ prefix) driver file. We were not able to\nrestore this file via tools enabling recovery of deleted files, but it was extracted directly from the\nservice DLL file.\n\n**Capturing driver image and register keys**\n\nThe malware service is responsible for the driver loading and cleans up of loading evidence. We\nput a breakpoint into the `nt!IopLoadDriver() kernel method, which is reached if a process`\nwants to load a driver into the system. We waited for the wanted driver, and then we listed all the\nsystem processes. The corresponding service ( svchost.exe ) has a call stack that contains the\nkernel call for driver loading, but the corresponding service has been killed by EIP registry\nmodifying. The process (service) was killed, and the whole Windows ended in BSoD. Windows\nmade a crash dump, so the file system caches have been flushed, and the malicious service did\nnot finish the cleanup in time. Therefore, we were able to mount a volume and read all wanted\ndata.\n\n## 3.4 Forensic Traces\n\nAlthough the DirtyMoe service takes great pains to cover up the malicious activities, there are a\nfew aspects that help identify the malware.\n\nThe DirtyMoe service and loaded driver itself are hidden; however, the Windows Event Log\nsystem records information about started services. Therefore, we can get additional information\nsuch as ProcessID and ThreadID of all services, including the hidden services.\n\nWinDbg connected to the Windows kernel can display all loaded modules using the `lm`\ncommand. The module list can uncover non-virtual drivers with prefix `dump_ and identify the`\nmalicious drivers.\n\n\n-----\n\nOffline connected volume can provide the DLL library of the services and other supporting files,\nwhich are unfortunately encrypted and obfuscated with VMProtect. Finally, the offline SYSTEM\nregistry stores records of the DirtyMoe service.\n\n## 4. Certificates\n\nWindows Vista and later versions of Windows require that loaded drivers must be code-signed.\nThe digital code-signature should verify the identity and integrity of the driver vendor [9].\nHowever, Windows does not check the current status of all certificates signing a Windows driver.\nSo, if one of the certificates in the path is expired or revoked, the driver is still loaded into the\nsystem. We will not discuss why Windows loads drivers with invalid certificates since this topic is\nreally wide. The backward compatibility but also a potential impact on the kernel implementation\nplay a role.\n\nDirtyMoe drivers are signed with three certificates as follow:\n\n**Beijing Kate Zhanhong Technology Co.,Ltd.**\n\nValid From: 28-Nov-2013 (2:00:00)\n\nValid To: 29-Nov-2014 (1:59:59)\n\nSN: 3C5883BD1DBCD582AD41C8778E4F56D9\n\nThumbprint: 02A8DC8B4AEAD80E77B333D61E35B40FBBB010A0\n\nRevocation Status: Revoked on 22-May- 2014 (9:28:59)\n\n**Beijing Founder Apabi Technology Limited**\n\nValid From: 22-May-2018 (2:00:00)\n\nValid To: 29-May-2019 (14:00:00)\n\nSN: 06B7AA2C37C0876CCB0378D895D71041\n\nThumbprint: 8564928AA4FBC4BBECF65B402503B2BE3DC60D4D\n\nRevocation Status: Revoked on 22-May- 2018 (2:00:01)\n\n**Shanghai Yulian Software Technology Co., Ltd. (上海域联软件技术有限公司)**\n\nValid From: 23-Mar-2011 (2:00:00)\n\nValid To: 23-Mar-2012 (1:59:59)\n\nSN: 5F78149EB4F75EB17404A8143AAEAED7\n\nThumbprint: 31E5380E1E0E1DD841F0C1741B38556B252E6231\n\nRevocation Status: Revoked on 18-Apr- 2011 (10:42:04)\n\nThe certificates have been revoked by their certification authorities, and they are registered as\nstolen, leaked, misuse, etc. [10]. Although all certificates have been revoked in the past,\nWindows loads these drivers successfully because the root certificate authorities are marked as\ntrusted.\n\n## 5. Summarization and Discussion\n\nWe summarize the main functionality of the DirtyMoe driver. We discuss the quality of the driver\nimplementation, anti-forensic mechanisms, and stolen certificates for successful driver loading.\n\n\n-----\n\n## 5.1 Main Functionality\n\n**Authorization**\n\nThe driver is controlled via IOCTL codes which are sent by malware processes in the user-mode.\nHowever, the driver implements the authorization instrument, which verifies that the IOCTLs are\nsent by authenticated processes. Therefore, not all processes can communicate with the driver.\n\n**Affecting the Filesystem**\n\nIf a rootkit is in the kernel, it can do “anything”. The DirtyMoe driver registers itself in the filter\nmanager and begins to influence the results of filesystem I/O operations; in fact, it begins to filter\nthe content of the filesystem. Furthermore, the driver replaces the `NtfsCreatCallback()`\ncallback function of the NTFS driver, so the driver can determine who should gain access and\nwhat should not get to the filesystem.\n\n**Thread Monitoring and Code injection**\n\nThe DirtyMoe driver enrolls a malicious routine which is invoked if the system creates a new\nthread. The malicious routine abuses the APC kernel mechanism to execute the malicious code.\nIt loads arbitrary DLL into the new thread.\n\n**Registry Hiding**\n\nThis technique abuses the kernel hook method that indexes registry keys in HIVE. The code\nexecution of the hook method is redirected to the malicious routine so that the driver can control\nthe indexing of registry keys. Actually, the driver can select which keys will be indexed or not.\n\n**Service and Driver Hiding**\n\nPatching of specific kernel structures causes that certain API functions do not enumerate all\nsystem services or loaded drivers. Windows services and drivers are stored as a double-linked\nlist in the kernel. The driver corrupts the kernel structures so that malicious services and drivers\nare unlinked from these structures. Consequently, if the kernel iterates these structures for the\npurpose of enumeration, the malicious items are skipped.\n\n## 5.2 Anti-Forensic Technique\n\nAs we mentioned above, the driver is able to hide itself. But before driver loading, the DirtyMoe\nservice must register the driver in the registry and dump the driver into the file. When the driver is\nloaded, the DirtyMoe service deletes all registry entries related to the driver loading. The driver\ndeletes its own file from the file system through the kernel-mode. Therefore, the driver is loaded\nin the memory, but its file is gone.\n\nThe DirtyMoe service removes the registry entries via standard API calls. We can restore this\ndata from the physical storage since the API calls only remove the pointer from HIVE. The\ndumped driver file is never physically stored on the disk drive because its size is too small and is\npresent only in cache memory. Accordingly, the file is removed from the cache before cache\nflushing to the disk, so we cannot restore the file from the physical disk.\n\n## 5.3 Discussion\n\n\n-----\n\nThe whole driver serves as an all-in-one super rootkit package. Any malware can register itself in\nthe driver if knowing the authorization code. After successful registration, the malware can use a\nwide range of driver functionality. Hypothetically, the authorization code is hardcoded, and the\ndriver’s name can be derived so we can communicate with the driver and stop it.\n\nThe system loads the driver via the DirtyMoe service within a few seconds. Moreover, the driver\nfile is never present in the file system physically, only in the cache. The driver is loaded via the\nAPI call, and the DirtyMoe service keeps a handler of the driver file, so the file manipulation with\nthe driver file is limited. However, the driver removes its own file using kernel-call. Therefore, the\ndriver file is removed from the file system cache, and the driver handler is still relevant, with the\ndifference that the driver file does not exist, including its forensic traces.\n\nThe DirtyMoe malware is written using Delphi in most cases. Naturally, the driver is coded in\nnative C. The code style of the driver and the rest of the malware is very different. We analyzed\nthat most of the driver functionalities are downloaded from internet forums as public samples.\nEach implementation part of the driver is also written in a different style. The malware authors\nhave merged individual rootkit functionality into one kit. They also merged known bugs, so the\ndriver shows a few significant symptoms of driver presence in the system. The authors needed\nto adapt the functionality of the public samples to their purpose, but that has been done in a very\ndilettante way. It seems that the malware authors are familiar only with Delphi.\n\nFinally, the code-signature certificates that are used have been revoked in the middle of their\nvalidity period. However, the certificates are still widely used for code signing, so the private keys\nof the certificates have probably been stolen or leaked. In addition, the stolen certificates have\nbeen signed by the certification authority which Microsoft trusts, so the certificates signed in this\nway can be successfully loaded into the system despite their revocation. Moreover, the trend in\nthe use of certificates is growing, and predictions show that it will continue to grow in the future.\nWe will analyze the problems of the code-signature certificates in the future post.\n\n## 6. Conclusion\n\nDirtyMoe driver is an advanced piece of rootkit that DirtyMoe uses to effectively hide malicious\nactivity on host systems. This research was undertaken to inspect the rootkit functionally of the\nDirtyMoe driver and evaluate the impact on infected systems. This study set out to investigate\nand present the analysis of the DirtyMoe driver, namely its functionality, the ability to conceal,\ndeployment, and code-signature.\n\nThe research has shown that the driver provides key functionalities to hide malicious processes,\nservices, and registry keys. Another dangerous action of the driver is the injection of malicious\ncode into newly created processes. Moreover, the driver also implements the minifilter, which\nmonitors and affects I/O operations on the file system. Therefore, the content of the file system is\nfiltered, and appropriate files/directories can be hidden for users. An implication of this finding is\nthat malware itself and its artifacts are hidden even for AVs. More importantly, the driver\n\n\n-----\n\nimplements another anti-forensic technique which removes the driver s evidence from disk and\nregistry immediately after driver loading. However, a few traces can be found on the victim’s\nmachines.\n\nThis study has provided the first comprehensive review of the driver that protects and serves\neach malware service and process of the DirtyMoe malware. The scope of this study was limited\nin terms of driver functionality. However, further experimental investigations are needed to hunt\nout and investigate other samples that have been signed by the revoked certificates. Because of\nthis, the malware author can be traced and identified using thus abused certificates.\n\n## IoCs\n\n**Samples (SHA-256)**\n```\n550F8D092AFCD1D08AC63D9BEE9E7400E5C174B9C64D551A2AD19AD19C0126B1\nAABA7DB353EB9400E3471EAAA1CF0105F6D1FAB0CE63F1A2665C8BA0E8963A05\nB3B5FFF57040C801A4392DA2AF83F4BF6200C575AA4A64AB9A135B58AA516080\nCB95EF8809A89056968B669E038BA84F708DF26ADD18CE4F5F31A5C9338188F9\nEB29EDD6211836E6D1877A1658E648BEB749091CE7D459DBD82DC57C84BC52B1\n\n## References\n\n```\n[1] [Kernel-Mode Driver Architecture](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/irp-mj-device-control)\n\n[2] [Driver to Hide Processes and Files](https://www.codeproject.com/Articles/32744/Driver-to-Hide-Processes-and-Files)\n\n[3] [A piece of code to hide registry entries](http://pstgroup.blogspot.com/2007/07/tips.html)\n\n[4] [Hidden](https://github.com/JKornev/hidden)\n\n[5] [Opening Hacker’s Door](https://blogs.blackberry.com/en/2017/10/threat-spotlight-opening-hackers-door)\n\n[6] [Hiding loaded driver with DKOM](http://www.rohitab.com/discuss/topic/41522-hiding-loaded-driver-with-dkom)\n\n[7] [Crashdmp-ster Diving the Windows 8 Crash Dump Stack](https://crashdmp.files.wordpress.com/2013/05/cfp-whitepaper.pdf)\n\n[8] [Ghost drivers named dump_*.sys](https://devblogs.microsoft.com/oldnewthing/20160913-00/?p=94305)\n\n[9] [Driver Signing](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/driver-signing)\n\n[10] [Australian web hosts hit with a Manic Menagerie of malware](https://www.zdnet.com/article/australian-web-hosts-hit-with-a-manic-menagerie-of-malware)\n\n## Appendix A\n\n**Registry entries used in the** **Start Routine**\n```\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDeviceAddress\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDeviceNumber\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDeviceId\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDeviceName\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDeviceNameB\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDeviceNameOnly\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDriverMaker1\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDriverMaker1_2\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDriverMaker2\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDriverMaker2_2\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDevicePathA\n\n```\n\n-----\n\n```\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDevicePathB\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDriverPath1\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDriverPath1_2\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDriverPath2\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDriverPath2_2\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDeviceDataA\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDeviceDataB\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDriverDataA\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDriverDataA_2\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDriverDataB\n\\\\Registry\\\\Machine\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WinApi\\\\WinDriverDataB_2\n\n## Appendix B\n\n```\n**Example of registry entries configuring the driver**\n\nKey: `ControlSet001\\Control\\WinApi`\n\nValue: `WinDeviceAddress`\n\nData: `Ms312B9050App ;`\n\nValue: `WinDeviceNumber`\n\nData:\n```\n\\WINDOWS\\AppPatch\\Ke601169.xsl;\n\\WINDOWS\\AppPatch\\Ke237043.xsl;\n\\WINDOWS\\AppPatch\\Ke311799.xsl;\n\\WINDOWS\\AppPatch\\Ke119163.xsl;\n\\WINDOWS\\AppPatch\\Ke531580.xsl;\n\\WINDOWS\\AppPatch\\Ke856583.xsl;\n\\WINDOWS\\AppPatch\\Ke999860.xsl;\n\\WINDOWS\\AppPatch\\Ke410472.xsl;\n\\WINDOWS\\AppPatch\\Ke673389.xsl;\n\\WINDOWS\\AppPatch\\Ke687417.xsl;\n\\WINDOWS\\AppPatch\\Ke689468.xsl;\n\\WINDOWS\\AppPatch\\Ac312B9050.sdb;\n\\WINDOWS\\System32\\Ms312B9050App.dll;\n\n```\nValue: `WinDeviceName`\n\nData:\n\n```\nC:\\WINDOWS\\AppPatch\\Ac312B9050.sdb;\n\n```\n```\nC:\\WINDOWS\\System32\\Ms312B9050App.dll;\n\n```\n\nValue: `WinDeviceId`\n\nData: `dump_FDC.sys ;`\n\n[Tagged asDirtyMoe,](https://decoded.avast.io/tag/dirtymoe/) [Rootkit,](https://decoded.avast.io/tag/rootkit/) [series](https://decoded.avast.io/tag/series/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-08-11 - DirtyMoe- Rootkit Driver.pdf"
    ],
    "report_names": [
        "2021-08-11 - DirtyMoe- Rootkit Driver.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535953,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653691049,
    "ts_modification_date": 1653691049,
    "files": {
        "pdf": "https://archive.orkl.eu/8c764ddc1169fafcf5f5ac4e73a06af751d75cbc.pdf",
        "text": "https://archive.orkl.eu/8c764ddc1169fafcf5f5ac4e73a06af751d75cbc.txt",
        "img": "https://archive.orkl.eu/8c764ddc1169fafcf5f5ac4e73a06af751d75cbc.jpg"
    }
}