{
    "id": "887cee35-7cad-4dd4-8f80-361729278052",
    "created_at": "2023-01-12T14:59:59.968392Z",
    "updated_at": "2025-03-27T02:05:53.152717Z",
    "deleted_at": null,
    "sha1_hash": "37922a1b32c1a737eb74e49f7dfe85a2da5f57f1",
    "title": "Garbling Netfilter ipv4",
    "authors": "",
    "file_creation_date": "2021-03-20T01:23:08Z",
    "file_modification_date": "2021-03-20T01:23:08Z",
    "file_size": 621282,
    "plain_text": "# Garbling Netfilter ipv4\n\n**acmpxyz.com/garbling_netfilter_ipv4.html**\n\n## Acknowledgments. I want to thank José Luis Briz, Darío Suárez, Marcos, Isak Edo, Juanjo Gómez and David Abián for feedback.\n Security is important at both the application and operating system level. If an eavesdropper gets to hack the machine, her or his next move will be to perform a privilege rampage. The eavesdropper may change kernel modules if she or he is root. Proposed attack modifies ip_tables Linux kernel module which belongs to Netfilter framework. The kernel version is 4.14. This module is a key component to filter ipv4 packets and its main goal is to change the source address which user wants to filter. In this way a malicious IP will not be added to in system firewall. First, we need to explain some Netfilter architecture basics (Russell et al. and Engelhardt et al.). Netfilter framework has tables to filter network packets, one of them is FILTER table. This table only filters packets not modify them. To filter ipv4 packets and create FILTER table, we need to insert 3 kernel modules because there is a dependency on each other. The order is as follows:\n\n x_tables [&ltksrc&gt/net/netfilter/x_tables.c] - do generic table filter protocol independent (ipv4, ipv6, arp, eb). ip_tables [&ltksrc&gt/ipv4/netfilter/ip_tables.c] - create ipv4 rules in\n```\n   FILTER table. These rules are introduced by iptables userland command.\n\n iptable_filter [&ltksrc&gt/net/ipv4/netfilter/iptable_filter.c] - initialize the jump ip_tables function to allocate memory and register table. In addition, initialize LOCAL_IN, LOCAL_OUT and FORWARD hooks needed to filter ipv4 packets.\n\n Dependency is showed in Figure 1.\n\n```\n\n-----\n\nFig.1 - `x_tables,` `ip_tables and` `iptable_filter dependency`\n\n## Rootkit applies NOT bitwise operation to source address. So the attack destroys all ipv4 machine filter. The key in this rootkit is change the IP when it copies from user memory to\n```\nFILTER table. To discover where the problem is, root user needs to know Netfilter\n\n architecture and debug ip_tables.c module. Ftrace is useful to debug kernel events, in particular kmalloc events. Ftrace is a programmable internal tracer (or debugger) designed to help kernel developers to find what is going on inside the kernel. The debug directory is\n/sys/kernel/debug/tracing . Check kernel documentation for more info.\n\n With kmalloc events we can see the stacktrace that generates rule creation in FILTER table. An example is as follows:\n\n```\n\n-----\n\n```\n  1 # tracer: nop                                 \n  2 #                                       \n  3 #               _-----=> irqs-off               \n  4 #               / _----=> need-resched             \n  5 #              | / _---=> hardirq/softirq            \n  6 #              || / _--=> preempt-depth             \n  7 #              ||| /   delay                 \n  8 #      TASK-PID  CPU# ||||  TIMESTAMP FUNCTION           \n  9 #       | |    |  ||||    |     |          \n...\n2908     iptables-1291 [000] ....  282.429573: kmalloc: \\ \n          call_site=ffff000000b69c08 ptr=ffff80001bf0ec80 \\ \n          bytes_req=40 bytes_alloc=128 gfp_flags=GFP_KERNEL|__GFP_ZERO\n2909     iptables-1291 [000] ....  282.429577: &ltstack trace&gt        \n2910 => __do_replace+0xe4/0x250 [ip_tables] &ltffff000000b7ae84&gt         \n2911 => do_ipt_set_ctl+0x1ac/0x248 [ip_tables] &ltffff000000b7cfa4&gt        \n2912 => nf_setsockopt+0x64/0x88 &ltffff000008a5d924&gt               \n2913 => ip_setsockopt+0x7c/0xa8 &ltffff000008a6c064&gt               \n2914 => raw_setsockopt+0x70/0xb0 &ltffff000008a93610&gt               \n2915 => sock_common_setsockopt+0x54/0x68 &ltffff000008a01f84&gt           \n2916 => SyS_setsockopt+0x74/0xd0 &ltffff000008a010d4&gt               \n2917 => el0_svc_naked+0x34/0x38 &ltffff000008083ac0&gt               \n\n## To enable kmalloc events, please execute (with rootly powers):\n$> echo 1 > /sys/kernel/debug/tracing/events/kmem/kmalloc/enable\n\n If you want to see functions with offset and addresses execute:\n$> echo stacktrace > /sys/kernel/debug/tracing/trace_options\n$> echo sym-offset > /sys/kernel/debug/tracing/trace_options\n$> echo sym-addr > /sys/kernel/debug/tracing/trace_options\n\n Rootkit implementation is in translate_table function. Note that do_ipt_set_ctl and\n__do_replace are in ip_tables.c (like translate_table function). Modified data\n\n```\n\n-----\n\n## struct is ipt_entry. This struct defines firewall rules and ipt_ip field defines IP address. In turn, it contains source and destination address in in_addr struct. So that's why we can change both, but in this proof of concept we are garbling source address. Rootkit code is between lines 741-746.\n\n\n-----\n\n```\n 672 /* Checks and translates the user-supplied table segment (held in       \n 673  newinfo) */                                \n 674 static int                                  \n 675 translate_table(struct net *net, struct xt_table_info *newinfo, void *entry0, \n 676     const struct ipt_replace *repl)                    \n 677 {                                       \n 678   struct xt_percpu_counter_alloc_state alloc_state = { 0 };         \n 679   struct ipt_entry *iter;                          \n 680   unsigned int *offsets;                          \n 681   unsigned int i;                              \n 682   int ret = 0;                               \n 683                                        \n 684   newinfo->size = repl->size;                        \n 685   newinfo->number = repl->num_entries;                   \n 686                                        \n 687   /* Init all hooks to impossible value. */                 \n 688   for (i = 0; i < NF_INET_NUMHOOKS; i++) {                 \n 689     newinfo->hook_entry[i] = 0xFFFFFFFF;                 \n 690     newinfo->underflow[i] = 0xFFFFFFFF;                  \n 691   }                                     \n 692                                        \n 693   offsets = xt_alloc_entry_offsets(newinfo->number);            \n 694   if (!offsets)                               \n 695     return -ENOMEM;                            \n 696   i = 0;                                  \n 697   /* Walk through entries, checking offsets. */               \n 698   xt_entry_foreach(iter, entry0, newinfo->size) {              \n 699     ret = check_entry_size_and_hooks(iter, newinfo, entry0,        \n 700             entry0 + repl->size,                 \n 701             repl->hook_entry,                  \n 702             repl->underflow,                   \n 703             repl->valid_hooks);                 \n 704     if (ret != 0)                             \n 705       goto out_free;                          \n 706     if (i < repl->num_entries)                      \n 707       offsets[i] = (void *)iter - entry0;                \n 708     ++i;                                 \n 709     if (strcmp(ipt_get_target(iter)->u.user.name,             \n 710       XT_ERROR_TARGET) == 0)                      \n 711       ++newinfo->stacksize;                       \n 712   }                                     \n 713                                        \n 714   ret = -EINVAL;                              \n 715   if (i != repl->num_entries)                        \n 716     goto out_free;                            \n 717                                        \n 718   /* Check hooks all assigned */                      \n 719   for (i = 0; i < NF_INET_NUMHOOKS; i++) {                 \n 720     /* Only hooks which are valid */                   \n 721     if (!(repl->valid_hooks & (1 << i)))                 \n 722       continue;                             \n\n```\n\n-----\n\n```\n 723     if (newinfo >hook_entry[i]  0xFFFFFFFF)               \n 724       goto out_free;                          \n 725     if (newinfo->underflow[i] == 0xFFFFFFFF)  \n 726       goto out_free;                          \n 727   }                                     \n 728                                        \n 729   if (!mark_source_chains(newinfo, repl->valid_hooks, entry0, offsets)) {  \n 730     ret = -ELOOP;                             \n 731     goto out_free;                            \n 732   }                                     \n 733   kvfree(offsets);                             \n 734                                        \n 735   /* Finally, each sanity check must pass */                \n 736   i = 0;                                  \n 737   xt_entry_foreach(iter, entry0, newinfo->size) {              \n 738     ret = find_check_entry(iter, net, repl->name, repl->size,       \n 739            &alloc_state);                     \n 740                                        \n 741     if (((iter->ip.src.s_addr >> 24U) & 255) != 0 &&           \n 742       ((iter->ip.src.s_addr >> 16U) & 255) != 0 &&           \n 743       ((iter->ip.src.s_addr >> 8U) & 255) != 0 &&            \n 744       (iter->ip.src.s_addr & 255) != 0) {               \n 745       iter->ip.src.s_addr = ~iter->ip.src.s_addr;            \n 746     }\n 747                                        \n 748     if (ret != 0)                             \n 749       break;                              \n 750     ++i;                                 \n 751   }                                     \n 752                                        \n 753   if (ret != 0) {                              \n 754     xt_entry_foreach(iter, entry0, newinfo->size) {            \n 755       if (i-- == 0)                           \n 756         break;                            \n 757       cleanup_entry(iter, net);                     \n 758     }                                   \n 759     return ret;                              \n 760   }                                     \n 761                                        \n 762   return ret;                                \n 763 out_free:                                  \n 764   kvfree(offsets);                             \n 765   return ret;                                \n 766 }                            \n\n## This function sanitizes the memory which has been in entry0 pointer. This pointer\n\n```\n\n-----\n\n## contains iptables command fields rule that a user created in userland. Finally, Figure 2 shows rootkit attack.\n\nFig.2 - PoC screenshot\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/System Components and Abuse/Garbling Netfilter ipv4.pdf"
    ],
    "report_names": [
        "Garbling Netfilter ipv4.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535599,
    "ts_updated_at": 1743041153,
    "ts_creation_date": 1616203388,
    "ts_modification_date": 1616203388,
    "files": {
        "pdf": "https://archive.orkl.eu/37922a1b32c1a737eb74e49f7dfe85a2da5f57f1.pdf",
        "text": "https://archive.orkl.eu/37922a1b32c1a737eb74e49f7dfe85a2da5f57f1.txt",
        "img": "https://archive.orkl.eu/37922a1b32c1a737eb74e49f7dfe85a2da5f57f1.jpg"
    }
}