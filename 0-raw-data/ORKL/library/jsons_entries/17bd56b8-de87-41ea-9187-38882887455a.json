{
    "id": "17bd56b8-de87-41ea-9187-38882887455a",
    "created_at": "2023-01-12T14:59:43.438874Z",
    "updated_at": "2025-03-27T02:05:51.69474Z",
    "deleted_at": null,
    "sha1_hash": "ca912f3f40ad110b764e476ec66c01ab9bc5ac75",
    "title": "2022-04-25 - [RE026] A Deep Dive into Zloader - the Silent Night",
    "authors": "",
    "file_creation_date": "2022-05-28T15:24:14Z",
    "file_modification_date": "2022-05-28T15:24:14Z",
    "file_size": 5317773,
    "plain_text": "# [RE026] A Deep Dive into Zloader - the Silent Night\n\n**[blog.vincss.net/2022/04/re026-a-deep-dive-into-zloader-the-silent-night.html](https://blog.vincss.net/2022/04/re026-a-deep-dive-into-zloader-the-silent-night.html)**\n\n## 1. Overview\n\nZloader, a notorious banking trojan also known as Terdot or Zbot. This trojan was first\ndiscovered in 2016, and over time its distribution number has also continuously increased.\nThe Zloader's code is said to be built on the leaked source code of the famous ZeuS\nmalware. In 2011, when source code of ZeuS was made public and since then, it has been\nused in various malicious code samples.\n\nZloader has all the standard functionality of a trojan such as being able to fetch information\nfrom browsers, stealing cookies and passwords, capturing screenshots, etc. and for making\nanalysis difficult, it applies advanced techniques, including code obfuscation and string\n[encryption, masking Windows APIs call. Recently, CheckPoint expert published an analysis](https://research.checkpoint.com/2022/can-you-trust-a-files-digital-signature-new-zloader-campaign-exploits-microsofts-signature-verification-putting-users-at-risk/)\nof a Zloader distribution campaign whereby the infection exploited Microsoft's digital\nsignature checking process. In addition, Zloader has also recently partnered with different\n[ransomware gangs are Ryuk and Egregor. This can indicate that the actors behind this](https://www.phishlabs.com/blog/surge-in-zloader-attacks-observed/)\nmalware are still looking for different ways to upgrade it to bypass the defenses. Here is the\n[ranking of Zloader according to the rating from the AnyRun site:](https://any.run/malware-trends/zloader)\n\n_Source:_ _[https://any.run/malware-trends/zloader](https://any.run/malware-trends/zloader)_\n\nMost recently, multiple telecommunication providers and cybersecurity firms worldwide\npartnered with Microsoft's security researchers throughout the investigative effort, including\nESET, Black Lotus Labs, Palo Alto Networks' Unit 42, and Avast. They took legal and\ntechnical steps to [disrupt the ZLoader botnet, seizing control of 65 domains that were used](https://blogs.microsoft.com/on-the-issues/2022/04/13/zloader-botnet-disrupted-malware-ukraine/)\nto control and communicate with the infected hosts.\n\nIn this article, we will provide detailed analysis and techniques that Zloader uses, including:\n\nHow to unpack to dump Zloader Core Dll.\nThe technique that Zloader makes difficult as well as time consuming in the analysis\nprocess.\nDecrypt strings used by Zloader by using both IDAPython and AppCall methods.\nApply AppCall to recover the Windows API calls.\n\n\n-----\n\nProcess Injection technique that Zloader uses to inject into the msiexec.exe process.\nDecrypt configuration information related to C2s addresses.\nHow Zloader collects and saves information in the Registry.\nThe Persistence technique.\n\nThe analyzed sample used in the article:\n[034f61d86de99210eb32a2dca27a3ad883f54750c46cdec4fcc53050b2f716eb](https://www.virustotal.com/gui/file/034f61d86de99210eb32a2dca27a3ad883f54750c46cdec4fcc53050b2f716eb)\n\n## 2. Unpacking Zloader Core Dll\n\nFirst, check the sample with Nauz File Detector:\n\nBy collecting and combining information about sections from ExeInfo, entropy in DiE as well\nas the size of the DLL file, we can confirm that this DLL is packed:\n\n\n-----\n\nFor unpacking, use x64dbg to load Dll file, set a bp NtAllocateVirtualMemory. Then,\nmodify the breakpoint's condition as follows:\n\nExecute with F9 and wait until the breakpoint is hit (after about 1126120 hits):\n\n\n-----\n\nFollowing the allocated memory regions, after the 3rd hit, the core Dll of Zloader will be\nunpacked:\n\nDump this Dll to disk, the file has MD5: 9b5589fcd123a3533584a62956f2231b.\n\n\n-----\n\n## 3. Anti-analysis\n\nTo consume time of the analyst, Zloader uses meaningless functions, or rewrites functions\nthat look very complicated but only to perform simple tasks such as AND, OR, XOR, ADD,\n**SUB, etc.**\n\nFor example, a function that does a meaningless task, however it can cause a delay in\nexecution in a sandbox environment:\n\nFunctions that perform AND, OR operations:\n\n\n-----\n\n## 4. Decrypt wide string\n\n 4.1. Use IDAPython\n\nAll strings that the core DLL uses are encrypted. The wide string decoder function will take\ntwo parameters as input:\n\n**First parameter: the address containing the encrypted string.**\n**Second parameter: the address where the string is stored after decoding.**\n\nThe pseudocode at the f_zl_decrypt_wstring decryption function looks confusing, but if we\nlook closely, the function performs a simple xor loop with the decryption key is \"PgtrIPF**2ftOj00Ox\":**\n\n\n-----\n\nBased on the above pseudocode, the python code that performs decryption as follows:\n\nWith the help of IDAPython, we can automate the whole process of string decoding and add\nannotations at the decryption functions in IDA for further analysis. The entire python code is\nas follows:\n\n\n-----\n\nThe results before and after the script execution will make the analysis easier:\n\n\n-----\n\n## 4.2. Use IDA AppCall\n\nIf you don't have time to dig into the decryption implementation of the function, or when the\nalgorithm is too complex, we can use IDA's useful feature known as AppCall, to help decrypt\nthe data. Basically, Appcall is a mechanism used to call functions inside the debugged\nprogram from the IDA debugger. Before applying AppCall, the first thing is to given a function\nwith a correct prototype. For example, the function f_zl_decrypt_wstring has the following\nprotoype:\n\n**wchar_t *__cdecl f_zl_decrypt_wstring(wchar_t *encString, wchar_t *decString);**\n\nNote again that in order to use AppCall, the program must be debugged. As shown below,\nIDA is stopping at the breakpoint set at DllEntryPoint:\n\n\n-----\n\nThen execute the below python script to decode and add comments related to decoded\nstrings at the functions:\n\nThe final result should be similar to the image below:\n\n\n-----\n\n## 5. Decrypt ansi string\n\n 5.1. Use IDAPython\n\nBesides the function to decode wide strings, Zloader also uses the function to decode ansi\nstrings. This function also accepts two arguments:\n\n**First parameter: the address containing the encrypted string.**\n**Second parameter: the address where the string is stored after decoding.**\n\nSimilar to the above f_zl_decrypt_wstring function, the pseudocode of the\n**f_zl_decrypt_string function looks quite messy, but it still uses an xor loop to decrypt with**\nthe decryption key still \"PgtrIPF-2ftOj00Ox\":\n\n\n-----\n\nHere is the full python code to automate the whole process of decoding strings and adding\ncomments at functions:\n\n\n-----\n\nThe results before and after the script execution\n\n\n-----\n\n## 5.2. Use IDA AppCall\n\nTo use AppCall, same as above, need to define correctly the prototype for the\n**f_zl_decrypt_string function as follows: char *__cdecl f_zl_decrypt_string(char**\n***encString, char *decString);**\n\nSlightly modified the script used for decoding the wide strings above:\n\n\n-----\n\nResult after running the script:\n\n## 6. List of Dlls used by Zloader\n\n\n-----\n\nIn the list of strings decrypted by the f_zl_decrypt_string function above, there is a string\nafter the decryption that is quite meaningless. Going to this address, after diving into it I\nnoticed that the first parameter passed to the function is an array containing the addresses of\nthe encrypted strings. Based on the corresponding index value of the array will access the\naddress containing the corresponding encrypted string:\n\nGoing to the g_ptr_enc_dll_str array (renamed above) will see a list of addresses as shown\nbelow:\n\nModify the script to decode the specific Dll strings, the results obtained when executing the\nscript are as follows:\n\n\n-----\n\nTo summarize, we have a list of indexes corresponding to the DLLs that Zloader can use to\nretrieve the addresses of APIs:\n\n**Index** **Dll Name**\n\n0 kernel32.dll\n\n1 user32.dll\n\n2 ntdll.dll\n\n3 shlwapi.dll\n\n4 iphlpapi.dll\n\n5 urlmon.dll\n\n6 ws2_32.dll\n\n7 crypt32.dll\n\n8 shell32.dll\n\n9 advapi32.dll\n\n10 gdiplus.dll\n\n11 gdi32.dll\n\n12 ole32.dll\n\n13 psapi.dll\n\n14 cabinet.dll\n\n15 imagehlp.dll\n\n\n-----\n\n16 netapi32.dll\n\n17 wtsapi32.dll\n\n18 mpr.dll\n\n19 wininet.dll\n\n20 userenv.dll\n\n21 bcrypt.dll\n\n## 7. Dynamic APIs resolve\n\nSimilar to other advanced malwareâ€¦ Zloader will also get the address of API function(s)\nthrough searching by pre-computed hash value based on API function name.\n\nAs shown in the above figure, the f_zl_resolve_api_func_ex function takes two parameters:\n\n(1): The first parameter is dll_index. Based on this parameter, the function will decode\nthe name of the corresponding Dll, then call the LoadLibraryA function to get the base\naddress of this Dll.\n\n\n-----\n\n(2): The second parameter is pre_api_hash. This parameter is the pre-computed hash\nof the API function name. The function f_zl_resolve_api_func_ex will call\n**f_zl_resolve_api_func to retrieve the corresponding API address:**\n\nThe pseudocode at the f_zl_resolve_api_func function as follows:\n\nThe entire pseudocode of the function that performs the hash calculation by the API function\nname is as follows:\n\n\n-----\n\nBased on the above pseudocode, re-implement using Python code as follows:\n\nResults when using the above function to find API functions corresponding to hash values\nhash 0xFDA8B77, 0xB1C1FE3, 0x8ADF2D1:\n\nWith all the above analysis results, it is possible to write an IDAPython script to recover all\nthe APIs that Zloader uses. However, to avoid having to dig into Zloader's hashing algorithm\nfor each analysis, here I will use AppCall to do this task. The python code that uses AppCall\nis as follows:\n\n\n-----\n\nNote, Zloader has many areas of code that call to the f_zl_resolve_api_func_ex function,\nbut there will be areas of code that do not have any reference to it and that area has not\nbeen defined as a complete function. Therefore, to be able to run the above script, it is\nnecessary to create functions for those first. The final result after executing the script will be\nas follows:\n\n\n-----\n\nHowever, as shown in the figure there are still places where the API function can't be\nrecovered, that's because Zloader has performed the previous calculation of the dll_index\nand pre_api_hash values and saved them in the register. After that, call the\n**f_zl_resolve_api_func_ex function:**\n\n## 8. Process Injection Technique\n\nZloader, when executed, will inject Core Dll into the msiexec.exe process. The whole\nprocess is as follows:\n\n\n-----\n\nUse the CreateProcessA API function to create the msiexec.exe process in the\n**SUSPENDED state.**\n\nGet SizeOfImage value of Zloader Dll being loaded by rundll32.exe/regsvr32.exe.\nUse the VirtualAllocEx API function to allocate new memory inside the msiexec.exe\nprocess:\n\nAllocate heap memory, copy the entire contents of the Dll into this heap:\n\nGenerate a random number and use it to encrypt the entire payload stored in the heap:\n\n\n-----\n\nUse the WriteProcessMemory API function to write the entire encrypted payload from\nthe heap to the previously allocated memory in the msiexec.exe process:\n\n\n-----\n\nContinue to use the VirtualAllocEx API function to allocate a second memory region\nhas size of region are 66 bytes in the msiexec.exe process. This memory region will\nbe used to decrypt the entire encrypted Dll above. Update the STARTUPINFO\nstructure created by the CreateProcessA function before, the data here are the\nassembly code that will be used to decrypt the encrypted Dll. Then, call the\n**WriteProcessMemory function to write the updated contents of STARTUPINFO to the**\nnewly created memory region.\n\n\n-----\n\nFinally, use the GetThreadContext, SetThreadContext, ResumeThread or\n**CreateRemoteThread API functions to execute the msiexec.exe process. At this**\npoint, the entry point executed at msiexec.exe will be the memory region that\ncontaining the code to perform the decrypting mission:\n\nAfter decrypting the entire Zloader Dll, it will jump to the RVA address of 0xF270 (File\noffset: 0xE670) to execute the main tasks of the malware:\n\n\n-----\n\n## 9. Decrypt Zloader config\n\nThe configuration info of the Zloader has been encrypted and stored in the .rdata section.\nThe decrypt function takes two parameters are the encrypted configuration data and the key\nused to decrypt:\n\nInside the function f_zl_decrypt_config will use the RC4 algorithm to decrypt the data:\n\nWith the analyzed results, we can use IDAPython code below to perform the decoding:\n\n\n-----\n\nResult after executing the script:\n\n## 10. Collect and save configuration in Registry\n\n\n-----\n\nWhen first executed, Zloader will collect information about the victim including\n**volume_GUID, Computer_Name, Windows version, Install Date, create random folders**\nat %APPDATA%, generate a random registry key at\n**HKEY_CURRENT_USER\\Software\\Microsoft, then encrypt all relevant information and**\nsave it in the created registry:\n\nThe information stored in the registry is similar to the following:\n\nTo decrypt the data stored in the above Registry, use the decoded embedded RC4 key\nabove. With the support of CyberChef, we can easily decrypt data as follows below:\n\n\n-----\n\n## 11. Persistence technique\n\nZloader reads the entire contents of the core Dll from disk into the memory region, then\nwrites to a random dll in a directory created above at %APPDATA%:\n\nCreate persistence key at\n**HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run:**\n\n\n-----\n\n## 12. References\n\n_[Click here for Vietnamese version.](https://blog.vincss.net/2022/04/re026-a-deep-dive-into-zloader-the-silent-night-vie.html)_\n\n**Tran Trung Kien (aka m4n0w4r)**\n\n**Malware Analysis Expert**\n\n**R&D Center - VinCSS (a member of Vingroup)**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-04-25 - [RE026] A Deep Dive into Zloader - the Silent Night.pdf"
    ],
    "report_names": [
        "2022-04-25 - [RE026] A Deep Dive into Zloader - the Silent Night.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535583,
    "ts_updated_at": 1743041151,
    "ts_creation_date": 1653751454,
    "ts_modification_date": 1653751454,
    "files": {
        "pdf": "https://archive.orkl.eu/ca912f3f40ad110b764e476ec66c01ab9bc5ac75.pdf",
        "text": "https://archive.orkl.eu/ca912f3f40ad110b764e476ec66c01ab9bc5ac75.txt",
        "img": "https://archive.orkl.eu/ca912f3f40ad110b764e476ec66c01ab9bc5ac75.jpg"
    }
}