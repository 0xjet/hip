{
    "id": "f738ab02-138c-4d69-af25-f898fff1de4e",
    "created_at": "2023-01-12T15:05:34.070972Z",
    "updated_at": "2025-03-27T02:08:40.937974Z",
    "deleted_at": null,
    "sha1_hash": "7b1a4cf4d53048c32a784d618976358653ef1bbf",
    "title": "2022-02-15 - Analysis of Microsoft CVE-2022-21907",
    "authors": "",
    "file_creation_date": "2022-05-28T05:11:30Z",
    "file_modification_date": "2022-05-28T05:11:30Z",
    "file_size": 231916,
    "plain_text": "# Analysis of Microsoft CVE-2022-21907\n\n**[fortinet.com/blog/threat-research/analysis-of-microsoft-cve-2022-21907](https://www.fortinet.com/blog/threat-research/analysis-of-microsoft-cve-2022-21907)**\n\nThreat Research\n\nBy [Tim Lau | February 15, 2022](https://www.fortinet.com/blog/search?author=Tim+Lau)\n\n\nFebruary 15, 2022\n\n\nOn January 11, 2022 Microsoft released a patch for CVE-2022-21907 as part of Microsoft’sth\nPatch Tuesday. CVE-2022-21907 attracted special attentions from industry insiders due to\nthe claim that the vulnerability is worm-able. In this analysis we will look at the cause of the\nvulnerability and how attackers can exploit it.\n\n**Affected Platforms: Windows Server 2022, Windows Server 2019, Windows 10**\n\n**Impacted Users: Any organization with affected Windows system**\n\n**Impact: Denial of service to affected systems**\n\n**Severity Level: High**\n\n\n-----\n\nCVE-2022-21907 is a remote code execution vulnerability in Windows Internet Information\nServices (IIS) component. More specifically, it affects the kernel module inside http.sys that\nhandles most of the IIS core operations. At a minimum, the vulnerability can lead to denial of\nservice conditions on the victim’s machine by crashing the operating system. It might also be\npossible to combine this vulnerability with another vulnerability to enable remote code\nexecution.\n\nWe used Windows 2022 Server 10.0.20348.143 as the base of our analysis. IIS is also\npresent on Windows 10. We also looked at the Windows 10 (2H 2021) http.sys and\nconfirmed that the same vulnerable code path exists. However, since IIS is not enabled by\ndefault on Windows 10, the chance of Windows 10 systems being exploited is significantly\nless.\n\nFirst, we performed a binary differential between the vulnerable http.sys and the patched\nhttp.sys (10.0.20348.469). The program Bindiff compared the two binary files and highlighted\nthe functions that have been modified. While a few functions were heavily modified, we were\ninterested in two particular functions—http!UlpAllocateFastTracker() and\nhttp!UlFastSendHttpResponse() .\n\n(As an aside, we did our initial analysis on Windows 10 http.sys, and these two functions are\nthe only ones patched on Windows 10.)\n\nIn http!UlpAllocateFastTracker(), we see the following differences:\n\nFigure 1: Differences between the original (top) and the patched function (bottom)\n\nOne curious thing to note is that memset() is called twice to zero out the buffer: once for a\nhardcoded first 0x1e0 bytes of the buffer, and the other starting at 0x2e for 0x50 bytes.\n\nFigure 2: memset(value = 0, size=0x1e0)\n\nFigure 3: memset(value = 0, size=0x50)\n\nThe difference between these two memset() calls is that memset(0x1e0) is for a freshly\nallocated buffer from nt!ExAllocatePool3(), and memset(0x50) is for buffers from both\nnt!ExAllocatePool3() and ExpInterlockedPopEntrySList(). (Internally, it uses a Windows\nsingle-linked list structure LIST_ENTRY, basically reusing previously allocated buffers.)\n\nIf we only look at the modifications to http!UlpAllocateFastTracker(), we can deduce that the\nnon-zero entries in the buffer (let’s call it a Tracker) might cause some unpleasant side\neffects. Furthermore, since the buffer can be allocated directly from nt!ExAllocatePool3(), if\nthe system is experiencing memory pressure it’s possible to spray attacker-controlled data\ninto the memory and have the attacker-controlled data show up in the newly-minted Tracker\nbuffer.\n\n\n-----\n\nThe fact that memset() is called twice to the same Tracker buffer is also curious. Apparently,\nthe developer felt that it was necessary to zero-out a particular segment of the Tracker (from\n0x2E-0x7E), even if the buffer was retrieved from a LookAside link list (where the initial\nallocation would have already zeroed out all the attacker-controlled data). This means that\nwhatever non-zero value that triggers the bug, it should be inside the 0x2e-0x7e part of the\nTracker structure.\n\nAt this point, we have a few ideas we can try. First, we need to know under what conditions\nhttp!UlpAllocateFastTracker() would be called. This turns out to be very easy to determine. A\nsingle command in Ghidra (Find References to UlpAllocateFastTracker) or IDA (Jump to\nxref) both show that only one function in http.sys could call UlpAllocateFastTracker().\n\nFigure 4: Two calls to http!UlpAllocateFastTacker()\n\nAfter writing some python scripts blasting HTTP requests to IIS, we determined that\nhttp!UlFastSendHttpResponse() does what its name suggests—the function is responsible\nfor sending an http response back to the client. The Tracker object we saw earlier is a\nstructure that keeps track of various states and pointers related to that response. When we\nsnoop around, we can even find the response data in one of the pointers.\n\nFigure 5: A Tracker object and the corresponding response data\n\nAfter we determined how to access the initialization code, we decided to ‘help’ the exploit by\npre-writing a non-zero value to Tracker. Using Windbg, pykd and some python scripting, we\nmanaged to inject pre-determined values into the part of Tracker that are likely to be affected\nbefore http!UlpAllocateFastTracker() returns.\n\nSadly, no matter how much we ran our ‘fuzzer’, the test system remained stable and\nresponsive. We did, however, noticed that most of the calls to http!UlpAllocateFastTracker()\nwere from UlFastSendHttpResponse+0x2F0 (>90%), and only a few allocation calls were\nmade from UlpAllocateFastTracker+0xe99. We did a bindiff on\nhttp!UlFastSendHttpResponse() on Windows 10’s http.sys and there’s a gigantic code\nchange.\n\nFigure 6: Comparison between the patched http!UlFastSendHttpResponse() and the original\nhttp!UlFastSendHttpResponse()\n\nAt this point we were unable to trigger the crash so we took to Twitter to look for a POC.\n\n## The Crash\n\nArmed with a new PoC, we resumed our analysis (this time on the Windows 2022 Server)\nand we soon discovered the cause of the crash that was being patched.\n\n\n-----\n\nThe crash happens at the end of the clean up phrase of http!UlFastSendHttpResponse(),\nwith a call to nt!MmUnampLockedPages() that tries to access invalid memory.\n\nFigure 7: A stack trace of the crash\n\nAccording to Microsoft, nt!MmUnmapLockedPages() is a Windows kernel routine that\nreleases a mapping between a virtual memory address and a physical memory address. The\nmapping is described by a kernel structure called the Memory Descriptor List (MDL).\n\nFigure 8: Function signature of MmUnmapLockedPages()\n\nWhen we set a breakpoint on the call to nt!MmUnmapLockedPages() we started to see all\nsorts of invalid memory addresses being passed in as the BaseAddress (virtual memory\naddress).\n\nFigure 9: Invalid arguments for MmUnmapLockedPages()\n\nBut now the question became, what did the PoC do differently to trigger the vulnerability? To\nget to the bottom of this, we needed to decompile http!UlFastSendHttpResponse() and look\nat the code.\n\nFigure 10: Decompiled vulnerable code\n\nWe were able to immediately make some guesses. We could see that the pointer v19 is\nfreed by UlpFreeFastTracker(). This told us that v19 is the pointer to the Tracker buffer.\nIndeed, when we scrolled up and checked the two calls to http!UlpAllocateFastTracker(), we\ncould see that v19 is the return value from that function.\n\nFigure 11: v19 as the returned Tracker object\n\nAt the same time, we knew the second argument for MmUnmapLockedPages() is the MDL\nstruct. If we check the definition of MDL (http.sys uses an internal struct definition of MDL,\nbut it’s the same as the kernel’s), we could see that the 0x00a field is the MdlFlags, and that\nthe routine checked to see if the flag’s 0 bit is 1. Finally, the 0x018 (24 in decimal) field isth\nthe MappedSystemVa.\n\nFigure 12: MDL definition\n\nAs an aside, according to wdm.h from Windows SDK, 0x0001 is\nMDL_MAPPED_TO_SYSTEM_VA, ie. the memory mapping described by this MDL is valid.\n\nFigure 13: MdlFlags bit field definition from Windows SDK\n\nWith these two pieces of information, we were able to construct the pseudo-code\nFigure 14: Pseudo-code of vulnerable code. The analysis will call Tracker->80 as ‘some_mdl’\nfrom now on\n\n\n-----\n\nSo, looking back at our initial guess, it was pretty good. We guessed that Tracker s 0x2e0x7e needed to be non-zero, and indeed, the 0x50 pointer does have to be non-zero for this\nif statement to go through.\n\nSo now, we have four new questions, ranked from the most to the least obvious:\n\n1. Can we control the ‘some_mdl’ MDL struct data?\n2. What is Tracker->member_0x50?\n3. Why can the PoC reach this code when our driver couldn’t?\n4. Is remote code execution possible?\n\n## Can we control the ‘some_mdl’ MDL struct data?\n\nIt turns out that, yes, the attacker does have control of the bytes in the MDL in certain\nsituations! We went back to http!UlpAllocateFastTracker() and stepped through every single\nline of instruction, and while there are multiple MDL pointers in Tracker, the MDL at offset\n0x80 is never initialized. The allocation routine simply picks sequential memory spaces after\nTracker’s struct location and has the Tracker’s MDL pointers point to these addresses. This\nmakes sense, as when nt!ExAllocatePool3() is called, the bytes requested are much larger\nthan the deduced size of the Tracker struct (Remember that the patched memset() only\nwrites 0s to the first 0x1e0 of the buffer.)\n\nFigure 15: nt!ExAllocatePool3() allocated 0xc85 bytes of buffer\n\nFigure 16: http!UlInitializeFastTrackerPool() assigning addresses to Tracker pointers\n\nWe know that 0x68, 0x70, 0x88, and 0x80 are all MDL pointers (via IDA heuristics), but only\n0x68 is initialized with MmBuildMdlForNonPagedPool() in the initialization routine.\n\nFigure 17: Tracker->0x68 pointer being initialized as a valid MDL object\n\nOnce control is returned to http!UlFastSendHttpResponse(), additional MDLs are eventually\ninitialized. However, the PoC discovered a code path where the initialization is skipped, with\ndisastrous consequences.\n\n## What is Tracker->member_0x50?\n\nWe tried to dive deeper into the code to figure out what member_0x50 does, but the object is\ncreated outside of http!UlFastSendHttpResponse(), and was passed-by-reference to the\nroutine as a pointer argument.\n\nSince the code assumes that if member_0x50 is valid then some_mdl should also be valid,\nperhaps the MDL’s memory range is the backing storage for member_0x50, and both\nelements should be valid (or be invalid) together.\n\n\n-----\n\nDuring our testing, however, the argument that leads to member_0x50 is always null with\nboth our driver and the PoC. We decided to leave it at that.\n\n## Why can the PoC reach this code when our driver couldn’t?\n\nAs mentioned before, we need the execution to take a path that would not initialize\nsome_mdl. The PoC takes advantage of this by sending identical malformed HTTP packets\nin quick succession.\n\nThere are two calls to http!UlpAllocateFastTracker(). The first call is used more than 90% of\nthe time. Once the Tracker structure is allocated, http!UlFastSendHttpResponse() takes over\nand continues the struct initialization process. Most importantly, during the process the\nmember_0x50 element is zero-ed out, thus ensuring the bug would never be executed\nduring normal execution.\n\nFigure 18: member_0x50 pointer is zeroed out\n\nHowever, when IIS receives multiple malformed packets in quick succession, a different code\npath is taken. According to our code analysis, IIS eventually abandons its (our guess)\ncaching mechanisms. In particular, while the first call to http!UlpAllocateFastTracker() still\nhappens, the allocated Tracker structure is quickly deallocated.\n\nWe are not sure why, but during the first call, a single value at Tracker->0x148 changes from\n0x14 (in previous calls) to 0x0, which causes the new Tracker structure to be deallocated,\nand a call to http!UlpAllocateFastTracker() is made with a different second argument.\n\nFigure 19: First call, 0x200\n\nFigure 20: Second call, 0x0\n\n(By the way, judging from the code and the PDB (program database), two other variables\n“UlH3ExtraHeaderCount” and “_UX_DUO_COLLECTION” are used to determine the value.\nIf anyone knows what these variables do, please let us know.)\n\nAfter the second allocation, a call is made to http!UlGenerateFixedHeaders(). However, the\ncall is cut short. The sixth argument to http!UlGenerateFixedHeaders()—the same 0x0\n(normally 0x200) variable as the allocation call, causes an early check fail, resulting in an\nerror code 0xC000000D and a quick return.\n\nFigure 21: The 0x0 value in the argument makes http!UlGenerateFixedHeaders() returns\nwith an error\n\nAfter the routine returns with the error code, the execution skips most of the\nhttp!UlFastSendHttpResponse() and goes straight to cleanup phrase. As part of the cleanup,\nthe vulnerable call to nt!MmUnmapLockedPages() is made, and the system crashes.\n\n\n-----\n\nAs we said earlier, a malformed HTTP packet is needed to trigger this bug. We then\nwondered if other forms of malformed HTTP packets would also work. To our surprise,\nalmost all our test samples would crash the system. This poses a serious issue as there are\npotentially many ways to attack the victim system.\n\n## Is remote code execution possible?\n\nSince we have control of mapping any attacker-controlled memory, there is a risk of remote\ncode execution. Constructing such a remote code execution, however, would require more\nresearch into what the Tracker fields do. The attacker would need to spray the memory with\nfake MDLs and fake Tracker pointers (this might require another vulnerability that leaks the\nkernel address info) or take advantage of the fact that there are other fields in Tracker that\nare also not initialized properly.\n\nWe tried to combine the PoC with our driver program to spray the kernel memory with\nattacker-controlled data. However, the probability of the sprayed content being reallocated\nagain and showing up in the vulnerable code is rather low; A successful remote code\nexecution chain might require a more accurate way to spray the memory.\n\nBased on this analysis, we at FortiGuard have modified our IPS signatures to account for\npotential malicious traffic.\n\n## Conclusion\n\nDue to the claim that the CVE is wormable, initially there was concerns that CVE-202221907 could potentially have a high impact. However, the combination that IIS is seldom\nenable on Windows 10, and the fact that the attacker does not have a direct way to create\nread or write primitives into kernel memory, lessen the risk somewhat.\n\n## Fortinet Protections\n\nForiGuard IPS protects against all known exploits associated with the CVE with the following\nsignature:\n\nMS.Windows.HTTP.Protocol.Stack.CVE-2022-21907.Code.Execution\n\nHowever, due to the unpredictable nature of malformed HTTP packets, we strongly urge\norganizations to apply the corresponding patches as quickly as possible to avoid service\ndisruption. FortiGuard Labs will continue to monitor the CVE and apply new\ncountermeasures when necessary.\n\n## Appendix:\n\n[https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-21907](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-21907)\n\n[https://twitter com/wdormann/status/1488148028317917186](https://twitter.com/wdormann/status/1488148028317917186)\n\n\n-----\n\nhttps://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdmmmunmaplockedpages\n\n## Related Posts\n\nCopyright © 2022 Fortinet, Inc. All Rights Reserved\n\n[Terms of ServicesPrivacy Policy](https://www.fortinet.com/corporate/about-us/legal.html)\n| Cookie Settings\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-02-15 - Analysis of Microsoft CVE-2022-21907.pdf"
    ],
    "report_names": [
        "2022-02-15 - Analysis of Microsoft CVE-2022-21907.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535934,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1653714690,
    "ts_modification_date": 1653714690,
    "files": {
        "pdf": "https://archive.orkl.eu/7b1a4cf4d53048c32a784d618976358653ef1bbf.pdf",
        "text": "https://archive.orkl.eu/7b1a4cf4d53048c32a784d618976358653ef1bbf.txt",
        "img": "https://archive.orkl.eu/7b1a4cf4d53048c32a784d618976358653ef1bbf.jpg"
    }
}