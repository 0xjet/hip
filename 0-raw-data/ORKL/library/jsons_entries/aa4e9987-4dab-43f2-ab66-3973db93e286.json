{
    "id": "aa4e9987-4dab-43f2-ab66-3973db93e286",
    "created_at": "2023-01-12T14:59:44.82917Z",
    "updated_at": "2025-03-27T02:08:33.37635Z",
    "deleted_at": null,
    "sha1_hash": "b637c5c57f2ad84e5bfa6230b1f1c0e55ceaac1d",
    "title": "2022-09-28 - Investigating Web Shells",
    "authors": "",
    "file_creation_date": "2022-10-02T12:25:54Z",
    "file_modification_date": "2022-10-02T12:25:54Z",
    "file_size": 2170151,
    "plain_text": "# Investigating Web Shells\n\n**blog.gigamon.com/2022/09/28/investigating-web-shells/**\n\n[Threat Research / September 28, 2022](https://blog.gigamon.com/category/threat-research/)\n\n\nSeptember 28, 2022\n\n\nPavle Culum &nbsp Roman\n\nKroshinsky &nbsp\nA web shell is an internet-accessible malicious file implanted in a victim web server’s file\nsystem that enables an attacker to execute commands by visiting a web page. Once placed\non a compromised web server, it allows an attacker to perform remote command execution\nto the operating system running on the host machine. The web shell provides the attacker\nwith a form of persistence in the compromised system and the potential to further pivot\nthrough the network to compromise hosts and data that may not otherwise be externally\naccessible.\n\nSuccess of a targeted cyber attack is often directly related to the efficacy of the initial access\nto the victim’s environment and how well it can be leveraged. Threat groups who establish\ntheir initial access through the exploitation of a web application vulnerability often opt to use\nweb shells to further facilitate their ability to operate efficiently within the context of the\nfoothold system.\n\nIn this article, we will look at common web shell functionality, encryption, and obfuscation\ntechniques, as well as several web shell management frameworks. Next, we will explore\ndetection and investigation opportunities, followed by an example of reversing the\nobfuscation or encryption scheme of an example web shell. Finally, we will discuss proactive\ninfrastructure protection measures that reduce the likelihood of successful web shell activity\nagainst managed systems.\n\n## Web Shell Functionality\n\nMany web application programming languages implement functions such as `exec(),`\n```\neval(), system(), and os(), or process strings as syntax with special characters\n\n```\n(such as “`” or backtick in the case of PHP) that can be used to execute system commands\n\n\n-----\n\nIn cyber attacks, threat groups abuse this functionality by smuggling these default functions\nand commands via web shells, allowing for remote tasking and code execution. The scope\nand breadth of code execution are arbitrary and only limited by the capabilities of the\nunderlying victim server operating system shell.\n\nSome of the common post-installation reconnaissance commands that attackers initially use\ninclude:\n```\n   whoami\n   netstat\n   ip route or route print\n   ls –latr or dir\n   uname –a or systeminfo\n   ifconfig or ipconfig\n\n```\nThis set of commands allows the attackers to get their bearings within the victim system and\nunderstand what kind of privileges are available from the perspective of the compromised\nserver. Additionally, attackers gain the ability to discover what applications and data reside\non the local file system and perform additional reconnaissance to determine their next action\nin relation to escalating access or moving laterally to another host.\n\nFigure 1. Simple PHP web shell example.\n\nFigure 2. Simple ASPX web shell example.\n\nFigure 3. Simple JSP web shell example.\nWhile attackers may opt to upload new files to the compromised web servers to enable web\nshell functionality, they may also append web shell functionality and code to an existing\nresource hosted on the server. An attacker may prefer this action to avoid raising potential\nsuspicion in the event that file creation events are monitored.\n\nComplicating matters further, an attacker may identify a web application parameter that is\nalready being used as input inside of one of these risky default functions (a web form or an\ninteractive application), thereby facilitating web shell functionality without requiring the\nattacker to upload a backdoor to the victim server. While this approach has the downside of\n\n\n-----\n\nhaving the remote tasking input and output flowing across the network without any\nobfuscation (allowing for potential detection by monitoring services), this capability would be\nused briefly to graduate remote access to a more covert method.\n\nWeb shell behavior is highly dependent on the configuration of the compromised web\nservice. Rather than opening a new service on the network, like a traditional bind implant\n(which would be relatively simple to detect and alert on), web shells most often use the\npreexisting HTTP(S) service already hosted on the victim system to facilitate backdoor\naccess. For example, if the web service is hosted on HTTP 80/TCP, the web shell will be\naccessible via HTTP 80/TCP. However, if the web service is hosted on HTTPS 443/TCP, the\nweb shell will also use 443/TCP and inherit any existing SSL/TLS configuration, including\nusing the legitimate victim web application SSL/TLS certificate and all associated metadata\nfor connections flowing to the web shell. This is one of the reasons why web shells have the\npotential to go undetected for a longer duration compared to other types of implants. They\nare simply buried too deep in the daily HTTP noise.\n\nTo avoid detection, threat actors rely on obfuscation techniques which are commonly chained\ntogether in order to hide the true functionality of the web shell. These techniques are often\nused in combination and include, but are not limited to:\n\nString rotations\nArray segmentation\nHex encoding\nBase64 encoding\nCompression\nWhitespace removal\n\nMany web shells observed in the wild also encrypt the remote command input and output\nthrough hard-coded pre-shared keys. While code obfuscation or encryption isn’t a new\nconcept in the context of cyber attacks, it introduces an additional layer of challenge when it\ncomes to detecting and investigating web shell implants.\n\n## Web Shell Management Frameworks\n\nThe desire to enhance and automate tradecraft has led to development of various fully\nfeatured web shell management frameworks alongside continuous improvements and\nautomation functionality. Table 1 lists some of the publicly available web shell management\nframeworks which have been used in the more recent events.\n\n**Web Shell Framework** **Source**\n\nAntSword https://github.com/AntSwordProject/antSword\n\n\n-----\n\nBehinder https://github.com/rebeyond/Behinder\n\nGodzilla https://github.com/BeichenDream/Godzilla\n\n_Table 1. Public web shell management frameworks._\n\nWhile some frameworks are relatively simple scripts, others come with a myriad of\nfunctionality, ease-of-use elements, and modular capabilities. This makes web shells\nextremely potent as a threat vector and provides attackers with a multitude of options during\ntheir attack.\n\nThe figures below demonstrate sample HTTP requests and responses for web shell\ninteractions using these frameworks:\n\n\n-----\n\nFigure 4. Godzilla web shell POST request and response. (Click image for larger size.)\n\n\n-----\n\nFigure 5. Behinder web shell POST request. (Click image for larger size.)\n\nFigure 6. Behinder web shell server response. (Click for larger size.)\n\n\n-----\n\nFigure 7. AntSword web shell POST request and response. (Click image for larger size.)\nIf the attack objective requires access to other systems beyond the compromised web\nserver, the attacker can use the web shell to relay subsequent interactions to other systems\nof interest. To increase the pace of killchain execution, an attacker may use the web shell to\nestablish SOCKS tunneling capabilities that can facilitate subsequent access to specific\nnetworked applications and resources internal to the organization.\n\n## Detection and Investigation\n\nIn previous sections, we discussed how input provided during an HTTP client request can\ncontain malicious instructions. Therefore, a key element of network-based web shell\ndetection is to identify the presence of operating system commands associated with\nadministrative/situational awareness operations within the contents of inbound web traffic\nflows.\n\nThere are several inherent challenges in detecting and investigating web shells that analysts\nshould be aware of. The heavy use of layered obfuscation techniques can evade static\nsignature-based detections with relative ease while also making it challenging for the\nanalysts to perform manual analysis on PCAPs and web logs. Additionally, web shells are\npassive implants and don’t require regular “keep-alives” with the C2 infrastructure, further\navoiding pattern-based detection mechanisms.\n\nTo increase probability and confidence in web shell detection efforts, analysts should look for\na combination of potentially suspicious sets of events relating to inbound HTTP(S) flows. For\nexample, tracking access attempts to specific web pages without valid referrers or historic\nprecedents, unique or never-before-seen user agents, or anomalous GET/POST requests\nflowing to a web server without a corresponding set of prior activity.\n\nWeb shell detection techniques greatly benefit from statistical and anomaly-based analytics.\nTo enable this effort, an organization must first gain comprehensive visibility into web traffic\npatterns and build a baseline of aggregated network traffic flows. In this case specifically,\nHTTP traffic and associated telemetry is key to detecting anomalies which could potentially\n\n\n-----\n\ncorrespond to web shell interaction by comparing expected inputs (baseline data) versus\nabuse of dynamic content on a web application. When used in conjunction with an\nunderstanding of adversary techniques and operations, powerful, intelligence-informed\nmodels can flag potential web shell activity in victim networks.\n\nAnother approach involves tracking each unique URI observed within inbound flows, the\ntheory being that if a web shell were to be planted onto an external facing asset into a net**new file, interaction with the web shell would transit using an endpoint or URI that had not**\npreviously existed and would be visited by less than a handful of source IP addresses over a\nset period of time. On the other hand, in cases where the attacker opts to implant web shell\nfunctionality to an existing file, the focus of the analysis should be on validating the contents\nof the existing files and cross referencing them against URI traffic patterns to those\nresources. Analysts can also pivot on any identified source IP addresses associated with\naccess to a previously unknown URI to determine if subsequent traffic remains limited to the\nsuspected web shell URI or if there are other requests to legitimate pages on the destination\nserver or other servers on the perimeter.\n\n## Web Shell Deobfuscation\n\nWhen investigating suspected web shell implants and network traffic, analysts benefit from\n[rapidly testing decryption schemes with the aid of tools such as Cyberchef. The following is](https://gchq.github.io/CyberChef/)\nan example of analysis of the default Behinder web shell template. Behinder web shell\naccepts attacker input from HTTP POST requests. Attacker input is shaped by the Behinder\nclient to be a valid class written in the syntax of the target web server, in this case PHP.\n\n\n-----\n\nFigure\n\n8. Behinder web shell sample. (Click image for larger size.)\nTo recover attacker instructions from network traffic requires recovery of the hardcoded preshared key from the web shell script. In this case, the default AES key supplied by the\nsource code is “ e45e329feb5d925b ” (first 16 characters of the MD5 hash of the\n“ rebeyond ” string). The contents are base64 encoded before being AES encrypted, so the\nstring must be decoded prior to the encryption key being used:\n\n\n-----\n\nFigure 9. Decoding and decrypting the obfuscated string. (Click image for larger size.)\nDeobfuscating the string reveals the arbitrary instructions passed to the server as a PHP\nclass. Operator instructions to the web shell are encoded inside of the `$cmd parameter:`\n\nFigure 10. Contents of the deobfuscated function. (Click image for larger size.)\nThe value of the `cmd parameter is base64 decoded before being evaluated. In the case of`\nour example, the command “ Y2QgL3Zhci93d3cvaHRtbC87d2hvYW1p ” decodes to `cd`\n```\n/var/www/html/;whoami:\n\n```\n\n-----\n\nFigure 11. Decoded system command. (Click image for larger size.)\nWhile obfuscation techniques can mask the contents of a script, in cases where TLS is not\nbeing used, the query responses from the server will be displayed in plain text via the web\nlogs and PCAPs. To remain stealthy under these conditions, attackers opt to also encrypt\ntheir web shell responses using the same hardcoded pre-shared key. Successfully\ndeobfuscating the script explains what the script is capable of. However, obtaining the preshared key can be further used to understand what input was issued and what output was\nproduced from a compromised asset. This information can be leveraged in the event that a\npacket capture or HTTP application content logs of the event are generated and made\navailable to the analysts.\n\n## Proactive Infrastructure Protection\n\nIn terms of web server hardening, there are a few measures that can be taken to limit the\nfunctionality of potentially implanted web shells. Web applications should avoid using\ndangerous operations and methods including, but not limited to: `exec(),` `eval(), or`\n```\nos(), especially when processing user-provided input, such as form fields or cookies.\n\n```\nRobust input validation and sanitization best practices, such as OWASP Proactive Control\nC5: Validate all Inputs, should be followed and implemented during the software\ndevelopment life cycle (SDLC), as well as validated periodically through recurring application\nsecurity testing.\n\nInvestigating potential and detecting actual web shell activity requires maturity within the\nsecurity organization, including, but not limited to, timely access to:\n\n[An up-to-date, accurate hardware inventory](https://www.cisecurity.org/controls/inventory-and-control-of-enterprise-assets)\n[An up-to-date, accurate software inventory](https://www.cisecurity.org/controls/inventory-and-control-of-software-assets)\nNetwork traffic flow logs for traffic to and from any zone that hosts web applications and\nservices\nWeb server logs\n\n\n-----\n\nRetention of web server logs for future analysis can especially be valuable in cases where\nthe deployed network or security stack lacks SSL visibility.\n\nDue to the polymorphic nature of web shell scripts, blocking based on known-bad\nhashes/strings may be of limited effectiveness. Individual organizations may benefit more\nfrom deploying and baselining high-risk assets, including web servers, with file integrity\nmonitoring (FIM) solutions.\n\n## Conclusion\n\nOnce an adversary achieves initial access to a web server, deploying one or multiple web\nshells has been observed to be a common next step in the attack lifecycle. Organizations\ncan gain insight into potential web shell activity by analyzing highly available NetFlow data.\nThe network profile of client interaction with a web server when searching for an attack\nvector is distinct from interaction with a web shell that has been successfully operationalized.\nThese network profiles can be observed within network metadata regardless of the\nobfuscation and encryption schemes used by the attacker.\n\nCombining these investigative techniques alongside proactively employing infrastructure\nhardening measures, organizations can detect and eliminate web shell attacks in their\nearliest stages.\n\n**Featured Webinars**\n\n[Hear from our experts on the latest trends and best practices to optimize your network](https://www.gigamon.com/resources/resource-library/webinar-hub.html?intcid=blog)\nvisibility and analysis.\n\nCONTINUE THE DISCUSSION\n\nPeople are talking about this in the Gigamon Community’s [ThreatINSIGHT group.](https://community.gigamon.com/gigamoncp/s/group/0F95Y000000NtoTSAS/threatinsight)\n\n**Share your thoughts today**\n\n[NDR Resource](https://blog.gigamon.com/tag/ndr-resource/)\n\n## RELATED CONTENT\n\nREPORT\n\n2022 Ransomware Defense Report\n\n\n-----\n\nGET YOUR COPY\n\nWEBINAR\n\nThreatINSIGHT: Eliminating Adversaries’ Dwell Time Advantage\n\nWATCH ON DEMAND\n\nWEBINAR\n\nSANS 2022 Cloud Security Survey\n\nWATCH ON DEMAND\n\nREPORT\n\nGigamon ThreatINSIGHT Guided-SaaS Network Detection and Response\n\nGET YOUR COPY\n\nOLDER ARTICLE\n\n[Modern IT Architectures: Moving Beyond Network Visibility](https://blog.gigamon.com/2022/09/22/modern-it-architectures-moving-beyond-network-visibility/)\nNEWER ARTICLE\n\n[Definitive Guide to Hybrid Clouds, Chapter 1: Navigating the Hybrid Cloud Journey](https://blog.gigamon.com/2022/09/30/definitive-guide-to-hybrid-clouds-chapter-1-navigating-the-hybrid-cloud-journey/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-28 - Investigating Web Shells.pdf"
    ],
    "report_names": [
        "2022-09-28 - Investigating Web Shells.pdf"
    ],
    "threat_actors": [
        {
            "id": "5d2bd376-fcdc-4c6a-bc2c-17ebbb5b81a4",
            "created_at": "2022-10-25T16:07:23.667223Z",
            "updated_at": "2025-03-27T02:02:09.916086Z",
            "deleted_at": null,
            "main_name": "GCHQ",
            "aliases": [
                "Government Communications Headquarters",
                "Operation Socialist"
            ],
            "source_name": "ETDA:GCHQ",
            "tools": [
                "Prax",
                "Regin",
                "WarriorPride"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535584,
    "ts_updated_at": 1743041313,
    "ts_creation_date": 1664713554,
    "ts_modification_date": 1664713554,
    "files": {
        "pdf": "https://archive.orkl.eu/b637c5c57f2ad84e5bfa6230b1f1c0e55ceaac1d.pdf",
        "text": "https://archive.orkl.eu/b637c5c57f2ad84e5bfa6230b1f1c0e55ceaac1d.txt",
        "img": "https://archive.orkl.eu/b637c5c57f2ad84e5bfa6230b1f1c0e55ceaac1d.jpg"
    }
}