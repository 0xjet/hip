{
    "id": "f474f819-3be4-42c3-a13a-1cbe67f2f799",
    "created_at": "2023-01-12T14:58:51.210563Z",
    "updated_at": "2025-03-27T02:06:02.766902Z",
    "deleted_at": null,
    "sha1_hash": "85f8e1abf95df54f0338739946dbb888935e9047",
    "title": "2018-03-02 - Tales of a Threat Hunter 2 Following the trace of WMI Backdoors & other nastiness",
    "authors": "",
    "file_creation_date": "2022-05-27T23:12:15Z",
    "file_modification_date": "2022-05-27T23:12:15Z",
    "file_size": 596255,
    "plain_text": "# Tales of a Threat Hunter 2\n\n**eideon.com/2018-03-02-THL03-WMIBackdoors/**\n\n[About Me](https://www.eideon.com/aboutme)\n\n## What is WMI?\n\nWMI is Microsoft’s implementation of WBEM (Web Based Enterprise Management) which is\n[based on CIM and allows for the remote management of multiple system components in](http://www.dmtf.org/standards/cim)\nWindows environments WMI is used on a daily basis by sysadmins across large domains\n\n\n-----\n\ndue to its flexibility and scalability. Easy to deploy, scripts that leverage WMI can be seen\neverywhere. Unfortunately, as with everything that is widely deployed, has “remote”\ncapabilities and runs on “windows”: the dark force is strong around it (just for fun: MS17010).\n\nIt is known that WMI can be abused in many ways to either gather information, make\nchanges and create persistence mechanisms. An excellent article by Matt Graeber\n[(@mattifestation) called](https://twitter.com/mattifestation?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor) Abusing Windows Management Instrumentation (WMI) to Build a\nPersistent, Asyncronous, and Fileless Backdoor was an eye opener for many of us in the\ncybersec world. We knew this was possible, but forgot how flexible it was. The main\nstrength of WMI persistence is its stealthiness and effectiveness. When a command is\nexecuted by WMI as a result of “evil” the only thing you will see is WmiPrvse.exe as the\nprocess. Distinguishing a valid system action from an invalid one is very hard under these\ncircumstances. In other words, WMI persistence defeats non-repudiation!\n\nWhat I will cover here are different methods for detecting WMI persistence that you could\nleverage within your network to hunt for this treat.\n\n## Understanding WMI Persistence\n\nFirst, rather than re-inventing the wheel, I will link here below the sources that I consulted to\nlearn more about WMI:\n\nMatt Graeber’s article (mentioned above)\n[Pentestarmoury article “Creeping on Users with WMI Events” by Sw4mp_f0x. He also](https://pentestarmoury.com/2016/07/13/151/)\ndeveloped PowerLurk (see below)\n[Permanent WMI Subscriptions](https://learn-powershell.net/2013/08/14/powershell-and-events-permanent-wmi-event-subscriptions/)\n[Derbycon 2015 presentation by Matt](https://www.youtube.com/watch?v=HJLCvBq3oms)\n\n## How does a WMI persistent object look like?\n\nLet’s use two scripts that allow us to easily create a malicious persistence without having to\ndo it step by step (have a look at the PS files to understand all the bits and pieces involved),\nnamely:\n\n[PowerLurk by Sw4mp_f0x](https://github.com/Sw4mpf0x/PowerLurk/blob/master/PowerLurk.ps1)\n[WMI Persistence Template Gist by Matt G.](https://gist.github.com/mattifestation/e55843eef6c263608206)\nAlternatively, you can also use an adaptation of Matt’s work by n0pe-sled WMIPersistence.ps1\n\n## WMI Persistence Template by Matt G.\n\n\n-----\n\nWe tweaked some of the parameters in the script to make sure the timer event launches\nevery minute and that no cleanup is performed at the end. After launching it, we can inspect\nthe newly created Event Consumers/Filters/Bindings as follows:\n\n**EventFilter**\n```\nGet-WmiObject -Namespace root\\subscription -Class __EventFilter\n\n```\nResult:\n```\n__GENUS     : 2\n__CLASS     : __EventFilter\n__SUPERCLASS   : __IndicationRelated\n__DYNASTY    : __SystemClass\n__RELPATH    : __EventFilter.Name=\"TimerTrigger\"\n__PROPERTY_COUNT : 6\n__DERIVATION   : {__IndicationRelated, __SystemClass}\n__SERVER     : W10B1\n__NAMESPACE   : ROOT\\subscription\n__PATH      : \\\\W10B1\\ROOT\\subscription:__EventFilter.Name=\"TimerTrigger\"\nCreatorSID    : {1, 5, 0, 0...}\nEventAccess   : \nEventNamespace  : root/cimv2\nName       : TimerTrigger\n**Query      : SELECT * FROM __TimerEvent WHERE TimerID = 'PayloadTrigger'**\nQueryLanguage  : WQL\nPSComputerName  : W10B1\n\n```\n**EventConsumer**\n```\nGet-WmiObject -Namespace root\\subscription -Class __EventConsumer\n\n```\nResult: [snip]\n```\n__GENUS        : 2\n__CLASS        : CommandLineEventConsumer\n__SUPERCLASS     : __EventConsumer\n__DYNASTY       : __SystemClass\n__RELPATH       : CommandLineEventConsumer.Name=\"ExecuteEvilPowerShell\"\n__PROPERTY_COUNT   : 27\n__DERIVATION     : {__EventConsumer, __IndicationRelated, __SystemClass}\n__SERVER       : W10B1\n__NAMESPACE      : ROOT\\subscription\n__PATH        :\n\\\\W10B1\\ROOT\\subscription:CommandLineEventConsumer.Name=\"ExecuteEvilPowerShell\"\n**CommandLineTemplate  : powershell.exe -NoP -C \"iex\n([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String((Get-ItemProperty Path HKLM:\\SOFTWARE\\PayloadKey -Name PayloadValue).PayloadValue)))\"**\n\n```\n**FilterToConsumerBinding**\n```\nGet-WmiObject -Namespace root\\subscription -Class __FilterToConsumerBinding\n\n```\n\n-----\n\nResult: [snip]\n```\n__NAMESPACE       : ROOT\\subscription\n**__PATH         :\n\\\\W10B1\\ROOT\\subscription:__FilterToConsumerBinding.Consumer=\"CommandLineEventConsume\n**Consumer        : CommandLineEventConsumer.Name=\"ExecuteEvilPowerShell\"**\nCreatorSID       : {1, 5, 0, 0...}\nDeliverSynchronously  : False\nDeliveryQoS       : \n**Filter         : __EventFilter.Name=\"TimerTrigger\"**\n\n```\nAs we can observe, this persistence is based off a Timer intrinsic Event type. If you\nlaunched it and head to C:\\ you will see the payload_result.txt file as per the script:\n```\n$TimerArgs = @{\n  IntervalBetweenEvents = ([UInt32] 6000) # 6000 ms == 1 min\n  SkipIfPassed = $False\n  TimerId = $TimerName\n}\n$Payload = {\n  # Prep your raw beacon stager along with Invoke-Shellcode here\n  \"Owned at $(Get-Date)\" | Out-File C:\\payload_result.txt\n}\n\n```\nLet’s look at the persistent registry key generated by the script via `Invoke-WmiMethod -`\n```\nNamespace root/default -Class StdRegProv -Name CreateKey -ArgumentList\n@($HiveVal, $PayloadKey) (creating the Registry Key) & Invoke-WmiMethod Namespace root/default -Class StdRegProv -Name SetStringValue -ArgumentList\n@($HiveVal, $PayloadKey, $EncodedPayload, $PayloadValue) (storing the payload\n\n```\n_value inside the key)_\n```\nPS C:\\Windows\\system32> Get-ItemProperty 'HKLM:\\SOFTWARE\\PayloadKey'\nPayloadValue :\nDQAKACAAIAAgACAAIwAgAFAAcgBlAHAAIAB5AG8AdQByACAAcgBhAHcAIABiAGUAYQBjAG8AbgAgAHMAdABhA\nPSPath    :\nMicrosoft.PowerShell.Core\\Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\PayloadKey\nPSParentPath : Microsoft.PowerShell.Core\\Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\nPSChildName : PayloadKey\nPSDrive   : HKLM\nPSProvider  : Microsoft.PowerShell.Core\\Registry\n\n```\n\n-----\n\nAlternatively:\n\nWe can observe the BASE64 ciphered payload (hold on to this, as it will become one of our\ndetection artifacts later).\n\nNow let’s throw in that juicy iex keyword to the Splunk mix and see what it comes up with:\n```\nQuery: WmiPrvse OR powershell AND \"iex\" (NOT *google* NOT splunk NOT\nTargetImage=*powershell* NOT TargetImage=*wmiprvse* NOT\nTargetImage=*chrome* NOT TargetImage=*vmware* NOT EventCode=600) | reverse\n| table _time, EventCode, Message\n\n```\nWe start observing some other interesting events popping up here. Disregarding Sysmon\nEventCode 20 (belongs to the new 6.10 version) which will be dissected later, we can see\n**5861 (Source: Microsoft-Windows-WMI-Activity/Operational), 400 (Source: Windows**\n_Powershell / Message: Engine state is changed from None to Available)1_ and 403\n(Source: Windows Powershell / Message: Engine state is changed from Available to\n**Stopped) .2** All of them are standard Windows Events, I haven’t “enabled” anything in\nparticular here. I’m just farming what the OS already gives you by default.\n\n\nThe interesting thing about all these events is that they all reveal the powershell code used\nas payload: `powershell.exe -NoP -C iex`\n```\n([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String((Get\n```\n\n-----\n\n```\nItemProperty -Path HKLM:\\SOFTWARE\\PayloadKey -Name\n\n```\n`PayloadValue).PayloadValue)))` _― ―_\n\nMost interesting of them all is Event 5861, which is giving us a lot of information about the\npersistence, namely the Binding itself.\n\n## WMI Persistence via PowerLurk by Sw4mpf0x\n\nWe can reproduce the same Timer Triggered Event as above with more ease with this great\nscript which allows for a lot of flexibility.\n```\nRegister-MaliciousWMIEvent -EventName MaliciousWMIEvent -LocalScriptBlock {InvokeExpression -Command \"cmd /c calc.exe\"} -Trigger Interval -IntervalPeriod 60 -TimerId\nMaliciousTimer\n\n```\nthis will simply start calc every 60 seconds and we can see the timer event\n```\n__GENUS        : 2\n__CLASS        : __IntervalTimerInstruction\n__SUPERCLASS     : __TimerInstruction\n__DYNASTY       : __SystemClass\n__RELPATH       : __IntervalTimerInstruction.TimerId=\"MaliciousTimer\"\n__PROPERTY_COUNT   : 3\n__DERIVATION     : {__TimerInstruction, __EventGenerator, __IndicationRelated,\n__SystemClass}\n__SERVER       : W10B1\n__NAMESPACE      : ROOT\\cimv2\n__PATH        :\n**\\\\W10B1\\ROOT\\cimv2:__IntervalTimerInstruction.TimerId=\"MaliciousTimer\"**\nIntervalBetweenEvents : 60000\nSkipIfPassed     : False\nTimerId        : MaliciousTimer\nPSComputerName    : W10B1\n\n```\nLet’s go ahead and remove it though:\n```\nGet-WMIObject -Namespace root\\Subscription -Class __FilterToConsumerBinding |\nRemove-WmiObject -Verbose\nGet-WMIObject -Namespace root\\Subscription -Class __EventFilter | Remove-WmiObject Verbose\nGet-WMIObject -Namespace root\\Subscription -Class __EventConsumer | Remove-WmiObject\n-Verbose\nGet-WmiObject -Class __IntervalTimerInstruction | Remove-WmiObject -Verbose\n\n```\nWe can do many more things, but this post is mainly about how to detect such sneaky\npersistence mechanisms, so let’s go ahead and grab our majestic free install of Splunk\nEnterprise with a 60 day trial and let’s make use of our best friend Sysmon the Great.\n\n## WMI Persistence Detection\n\n\n-----\n\nFor the purposes of this test, I ve used a log all approach with Sysmon, you can find a\n[sample config file here (Threat Hunting Ecosystem as a Code is my next project, don’t look](https://github.com/darkquasar/THL/blob/master/Templates/SysmonConfig-LogAll.xml)\nat it yet, it’s ugly!)\n\nSo let’s go ahead and create a new TimerEvent and see what our logs come up with. We\nshall use the following search:\n```\nLogName=Microsoft-Windows-WMI-Activity/Operational AND NOT EventCode=5858 AND NOT\n\"sysmon\"\n\n```\n1. First thing we notice is that Windows already comes with a default “WMI-Event\n\nDetector” which is Event Id 5860 in the Microsoft-Windows-WMI-Activity/Operational\nLog\n\n2. Second, becase I am running Powershell v5, Script Block Auditing is enabled by\n\ndefault, hence, the malicious script was also captured:\n\n\n-----\n\n3. We also notice via another Event Id 5860 that some application with the Process Id\n\n2024 issued a query to the WMI provider:\n\nWho is this guy?\n```\nPS C:\\WINDOWS\\system32> Get-Process -Id 2024\nHandles NPM(K)  PM(K)   WS(K)   CPU(s)   Id SI ProcessName        \n------- ------  -----   -----   ------   -- -- -----------        \n  425   20  22676   21804   174.56  2024  0 Sysmon64   \n\n```\n**Note: TL;DR. Well it seems that the new capability added by Sysmon to monitor WMI**\nEvents (SYSMON EVENT ID 19 & 20 & 21 : WMI EVENT MONITORING [WmiEvent]) is\nnothing else but a few queries issued to the WMI service which are then reported back to\ntheir own log space (Sysmon/Operational). Essentially sysmon is registering itself here as a\n_subscriber for intrinsic events. This pretty much means Sysmon is duplicating on effort here,_\nsince Windows already comes with native events to detect WMI operations. It doesn’t mean\nthough that this feature is plain redundant, since our logging architecture could be simplified\nby just looking at Sysmon events rather than having to fork to Windows native events for\nWMI. Anyway, let’s keep digging shall we ;)\n\nThe only problem we noticed here is that, for Timer-based WMI Events, sysmon wasn’t\n**generating any logs. So you need to monitor Windows Event Id 5859/5861 if you want to**\n_catch those. ― ―_\n\nWhat would happen if we create a script event consumer?\n```\n$script = @’\nSet objFSO=CreateObject(\"Scripting.FileSystemObject\")\noutFile=\"c:\\test\\log.txt\"\nSet objFile = objFSO.CreateTextFile(outFile,True)\nobjFile.Write \"%TargetInstance.ProcessName% started at PID\n%TargetInstance.ProcessId%\" & vbCrLf\nobjFile.Close\n‘@\nRegister-MaliciousWmiEvent -EventName CalcMalicious -PermanentScript $script Trigger ProcessStart -ProcessName notepad.exe -ScriptingEngine VBScript\n\n```\n\n-----\n\nAs we can observe, this pretty handy Windows Event Id 5861 provides all the information\npertaining to the FilterToConsumerBinding, the EventConsumer and EventFilter\n\nWe also observe Windows Event Id 5859 showing the EventFilter which is effectively\nregistered in the NotificationQueue:\n```\nLogName=Microsoft-Windows-WMI-Activity/Operational\nSourceName=Microsoft-Windows-WMI-Activity\nEventCode=5859\nEventType=0\nType=Information\nComputerName=W10B1\nUser=NOT_TRANSLATED\nSid=S-1-5-18\nSidType=0\nTaskCategory=The operation completed successfully.\nOpCode=Info\nRecordNumber=321\nKeywords=None\nMessage=Namespace = //./root/CIMV2; NotificationQuery = SELECT * FROM\nWin32_ProcessStartTrace WHERE ProcessName='notepad.exe'; OwnerName = S-1-5-212876542525-3899777576-1000537697-1001; HostProcessID = 972; Provider= WMI Kernel\nTrace Event Provider, queryID = 0; PossibleCause = Permanent\n\n```\nAnd one other small but important piece of information is the presence of Event Id 5857\nwhich is telling us who the provider is (an executable) whose task is to carry out the actions\ndetermined in the EventConsumer class:\n\n\n-----\n\n```\nLogName Microsoft Windows WMI Activity/Operational\nSourceName=Microsoft-Windows-WMI-Activity\nEventCode=5857\nEventType=0\nType=Information\nComputerName=W10B1\nUser=NOT_TRANSLATED\nSid=S-1-5-18\nSidType=0\nTaskCategory=The operation completed successfully.\nOpCode=Info\nRecordNumber=322\nKeywords=None\nMessage=ActiveScriptEventConsumer provider started with result code 0x0. HostProcess\n= wmiprvse.exe; ProcessID = 972; ProviderPath =\n%SystemRoot%\\system32\\wbem\\scrcons.exe\n\n```\nLet’s commit that to memory for a second:\n**%SystemRoot%\\system32\\wbem\\scrcons.exe. What the event is telling us is the**\nexecutable in charge of running our script. Riding the Google brave horses I was able to\nobtain good answers from the Internet Elders: https://msdn.microsoft.com/enus/library/aa940177(v=winembedded.5).aspx Here it says that these are the handlers for\ncommon event consumers:\n```\n  Scrcons.exe. ActiveScriptEventConsumer\n  Smtpcons.dll. SMTPEventConsumer\n  Wbemcons.dll. CommandLineEventConsumer, NTEventLogEventConsumer,\nLogFileEventConsumer\n\n```\nSo essentially, even if you are NOT monitoring for either Sysmon Events 19, 20 & 21 or\nWindows native Events in the WMI/Operational space Ids 5857, 5859, 5860 & 5861, you\ncan still detect the presence of potentially malicious WMI persistence by leveraging the\nevent consumer handlers listed above. Let’s ask Sysmon for Scrcons.exe\n\n\n-----\n\nNow what a surprise! you would be expeting that WmiPrvse.exe would start scrcons.exe,\ninstead it’s this regular non-profit bloke svchost.exe. Sysmon is even providing us with the\nname `Description: WMI Standard Event Consumer - scripting Looking for further`\nclues of scrcons.exe returns a Sysmon Event Id 11 (File Created) event where our little\nfriend created a file.\n\n\n-----\n\nIf we were expecting to see this file, written to disk by wscript.exe we will be disappointed ―\n_―_\n\nThis time though, Sysmon seems to have noticed that a malicious event subscription was\ncreated and here we have it:\n```\nGet-WinEvent -FilterHashtable @{logname=\"Microsoft-WindowsSysmon/Operational\";id=20} | Select-Object -ExpandProperty Message\nWmiEventConsumer activity detected:\nEventType: WmiConsumerEvent\nUtcTime: 2018-03-02 14:17:53.442\nOperation: Created\nUser: W10B1\\Artanis\nName: \"CalcMalicious\"\nType: Script\nDestination: \"Set\nobjFSO=CreateObject(\\\"Scripting.FileSystemObject\\\")\\noutFile=\\\"c:\\\\test\\\\log.txt\\\"\\nS\n objFile = objFSO.Cre\nateTextFile(outFile,True)\\nobjFile.Write \\\"%TargetInstance.ProcessName% started at\nPID %TargetInstance.ProcessId%\\\" & vbCrLf\\no\nbjFile.Close\"\n\n```\nIf you are using Sysmon events to monitor for WMI event subscriptions, you only need to\ncapture the results of Event Id 19 as it will display the event consumer which is were the\njuicy information is that allows us to discriminate benign from malicious.\n\n\n-----\n\nWhat happens if we instead create a CommandLine Event Subscription instead of a Script\nbased one? The command would look like this with PowerLurk:\n```\nRegister-MaliciousWmiEvent -EventName LogCalc1 -PermanentCommand “cmd.exe /c msg\nArtanis This is Persistence!” -Trigger ProcessStart -ProcessName calculator.exe\n\n```\nThis time, instead of scrcons.exe we shall see wbemcons.dll as the event handler, and\ninstead of a process being a child of another process we shall see WmiPrvse.exe loading\n_wbemcons.dll. In all my experimental hunts I can assure you that the presence of_\n_wbemcons.dll being loaded as a module by WmiPrvse.exe is extremely rare, so do pay_\nattention to those if you are not monitoring WMI/Operational native Windows events.\n\nI will leave it as an exercise to the reader to investigate which events are generated by\ncreating a CommandLine Event Consumer.\n\n## What about DFIR?\n\nIt happens to be the case that any permanent event subscription gets written to a WMI\ndatabase file called OBJECTS.DATA that can be located here:\n\nC:\\Windows\\System32\\wbem\\Repository\\OBJECTS.DATA\nC:\\Windows\\System32\\wbem\\Repository\\FS\\OBJECTS.DATA\n\nIt turns out that the information pertaining WMI event subscriptions can be located there in\nplain text. The file has a binary format and its structure, AFAIK, is undocumented. However,\nthere are a few out there that were brave enough to come up with some cool python scripts\nthat make use of `The Sword of RegEx The Great and Meticulous that allow for`\nparsing of these files, namely:\n\nhttps://github.com/darkquasar/WMI_Persistence (developed by me)\nhttps://github.com/davidpany/WMI_Forensics (David Pany script)\nhttps://github.com/fireeye/flare-wmi (a few scripts by FireEye analysts)\n\nSo even if you are (well… luckily after reading this post “were”) not collecting any WMI\ntelemetry data in your environment, you can still go out there and hunt for these threats by\ncollecting all the OBJECTS.DATA files in your hosts. The scripts listed above allow for easy\nparsing of a folder full of these files so the heavy lifting will be on the collecting side of\nthings ;)\n\n## Detection Logics & Lessons Learned\n\nYou may think that WMI fileless persistence and malware execution mechanisms are a very\nlow risk threat thus spending business cycles into creating a detection for this drops way\ndown the list of priorities. It is, however, an extremely easy to detect tactic and if your\n\n\n-----\n\npriority list is not packed with threat scenarios like this one then you are not putting together\na proper list!\n\nWe all know looking at detailed TTPs is a tedious process, but only by adopting a systemic\napproach you will be able to extend your detection & prevention surface. It’s an ants work,\nmixed with that of a dragon ― ―\n\n## So, to summarize\n\n**Monitor** **Detect** **Suited for**\n\n\nSysmon Event Id 11 (File Write) where\n“Image” is\n“C:\\WINDOWS\\system32\\wbem\\scrcons.exe”.\n\nSysmon Event Id 1 where “ParentImage” is\nC:\\Windows\\System32\\svchost.exe AND\nImage is\n“C:\\WINDOWS\\system32\\wbem\\scrcons.exe”.\nAlternatively Windows Security Log Event ID\n4688 (Process Created) can also be\nmonitored.\n\nSysmon Event Id 7 where “Image” is\nC:\\Windows\\System32\\wbem\\WmiPrvSE.exe\nAND “ImageLoaded” contains\n“wbemcons.dll”.\n\nWindows Event Id 5859 in WMIActivity/Operational\n\n\nSuspicious\nfiles written by\nthe script\nevent\nconsumer\nhandler\n\nInstances of\nan Active\nScript Event\nConsumer\nWMI\nPersistence\n\nInstances of\nan Active\nCommandLine\nEvent\nConsumer\nPersistence\n\nSuspicious\nEvent\nConsumers\n\n\nEnvironments with\nSysmon monitoring\n\nWhen you are not\nmonitoring Windows\nnative WMI/Operational\nevents OR,when a\nmalicious actor\ndisabled native\nwindows event logging\nand you have another\ntechnology in place (for\nexample EDR)\n\nWhen you are not\nmonitoring Windows\nnative WMI/Operational\nevents,OR,when a\nmalicious actor\ndisabled native\nwindows event logging\nand you,have another\ntechnology in place (for\nexample EDR)\n\nEnvironments with no\nSysmon monitoring\nusing solely native\nWindows Events OR for\nIntrinsic Timer Events\n(Sysmon doesn’t catch\nthose!)\n\n\n-----\n\n**Monitor** **Detect** **Suited for**\n\n\nWindows Event Id 5861 in WMIActivity/Operational\n\n\nSuspicious\nEvent Filters\n\n\nEnvironments with no\nSysmon monitoring\nusing solely native\nWindows Events OR for\nIntrinsic Timer Events\n(Sysmon doesn’t catch\nthose!)\n\n\nHopefully in my next post I will resume the Mimikatz one and then I will jump into\nMeterpreter detections ;)\n\n## Changes to your Sysmon Config\n\nWe will add a tag for the new event that has a pretty tight condition: it will only collect WMI\nevents when they are created. This way, the FP ratio is reduced to a minimum, but as a\ntrade off you need to be really paying attention and treat Alarms pertaining to these events\nas critical always.\n```\n<!--SYSMON EVENT ID 19,20,21 : WMIEvent-->\n<WmiEvent onmatch=\"include\">\n     <Operation condition=\"is\">Created</Operation>\n</WmiEvent>\n\n## Some references\n\n```\n[Malware using WMI Persistence: WMIGhost / Actors:](https://secrary.com/ReversingMalware/WMIGhost/) [APT29POSHSPY](https://www.fireeye.com/blog/threat-research/2017/03/dissecting_one_ofap.html)\n[Yeap, cryptominers WMI’ing the [email protected]# out of Browsers](http://blog.trendmicro.com/trendlabs-security-intelligence/cryptocurrency-miner-uses-wmi-eternalblue-spread-filelessly/)\nThis dude man! [mattifestation](https://twitter.com/mattifestation/status/899646620148539397)\nList of modules involved in each WMI event https://msdn.microsoft.com/enus/library/aa940177(v=winembedded.5).aspx\nhttps://msdn.microsoft.com/en-us/library/aa392282(v=vs.85).aspx This explains how\nto create an NTEventLogEventConsumer class and how to setup one of its properties\n(insertionstrings) to a string. It also does this via MOF and compiling the MOF. The\nMOF then is embedded in OBJECTS.DATA. WMIPers is not parsing the\n“_EventConsumer” for these events very well, must look into that. The interesting\nthing though is that you could store anything in those “strings”, why not a payload?\nhttps://msdn.microsoft.com/en-us/library/aa393016(v=vs.85).aspx Ability to register\nEventConsumers and EventFilters can be restricted by setting the EventAccess\nattribute of the EventFilter instance.\n\narrivederci my friends, wine and fettuccine awaits!\n\n**EventCode 400 sample contents**\n\n\n-----\n\n```\n09/19/2017 11:44:22 PM\nLogName=Windows PowerShell\nSourceName=PowerShell\nEventCode=400\nEventType=4\nType=Information\nComputerName=W10B1\nTaskCategory=Engine Lifecycle\nOpCode=Info\nRecordNumber=56\nKeywords=Classic\nMessage=Engine state is changed from None to Available. \nDetails: \n     NewEngineState=Available\n     PreviousEngineState=None\n     SequenceNumber=13\n     HostName=ConsoleHost\n     HostVersion=5.1.14393.206\n     HostId=9ebd19fb-d695-44ec-a9b1-51d48db8b1ef\n     HostApplication=powershell.exe -NoP -C iex\n([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String((Get-ItemProperty Path HKLM:\\SOFTWARE\\PayloadKey -Name PayloadValue).PayloadValue)))\n     EngineVersion=5.1.14393.206\n     RunspaceId=0a4191f5-9ee9-417b-9ebe-fbb73aa20b37\n     PipelineId=\n     CommandName=\n     CommandType=\n     ScriptName=\n     CommandPath=\n     CommandLine=\n\n```\n**EventCode 403 sample contents**\n\n\n-----\n\n```\n09/19/2017 11:44:23 PM\nLogName=Windows PowerShell\nSourceName=PowerShell\nEventCode=403\nEventType=4\nType=Information\nComputerName=W10B1\nTaskCategory=Engine Lifecycle\nOpCode=Info\nRecordNumber=57\nKeywords=Classic\nMessage=Engine state is changed from Available to Stopped. \nDetails: \n     NewEngineState=Stopped\n     PreviousEngineState=Available\n     SequenceNumber=15\n     HostName=ConsoleHost\n     HostVersion=5.1.14393.206\n     HostId=9ebd19fb-d695-44ec-a9b1-51d48db8b1ef\n     HostApplication=powershell.exe -NoP -C iex\n([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String((Get-ItemProperty Path HKLM:\\SOFTWARE\\PayloadKey -Name PayloadValue).PayloadValue)))\n     EngineVersion=5.1.14393.206\n     RunspaceId=0a4191f5-9ee9-417b-9ebe-fbb73aa20b37\n     PipelineId=\n     CommandName=\n     CommandType=\n     ScriptName=\n     CommandPath=\n     CommandLine=\n\n```\n1. EventCode 400 sample contents: ↩\n\n2. EventCode 403 sample contents: ↩\n\nTags: threat hunting, hunting, wmi, windows management instrumentation, backdoor,\npersistene, siem, ioc, splunk, elk, darkquasar, volatility\n\n[← Previous Post](https://www.eideon.com/2017-10-15-THL02-Events_Threats_Incidents/)\n[Next Post →](https://www.eideon.com/2018-11-10-THL04-AwesomeKB/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-03-02 - Tales of a Threat Hunter 2 Following the trace of WMI Backdoors & other nastiness.pdf"
    ],
    "report_names": [
        "2018-03-02 - Tales of a Threat Hunter 2 Following the trace of WMI Backdoors & other nastiness.pdf"
    ],
    "threat_actors": [
        {
            "id": "dcba8e2b-93e0-4d6e-a15f-5c44faebc3b1",
            "created_at": "2022-10-25T16:07:23.816991Z",
            "updated_at": "2025-03-27T02:02:09.991944Z",
            "deleted_at": null,
            "main_name": "Lurk",
            "aliases": [],
            "source_name": "ETDA:Lurk",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535531,
    "ts_updated_at": 1743041162,
    "ts_creation_date": 1653693135,
    "ts_modification_date": 1653693135,
    "files": {
        "pdf": "https://archive.orkl.eu/85f8e1abf95df54f0338739946dbb888935e9047.pdf",
        "text": "https://archive.orkl.eu/85f8e1abf95df54f0338739946dbb888935e9047.txt",
        "img": "https://archive.orkl.eu/85f8e1abf95df54f0338739946dbb888935e9047.jpg"
    }
}