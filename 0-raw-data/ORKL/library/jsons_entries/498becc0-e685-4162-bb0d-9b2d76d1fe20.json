{
    "id": "498becc0-e685-4162-bb0d-9b2d76d1fe20",
    "created_at": "2023-03-03T02:05:26.180659Z",
    "updated_at": "2025-03-27T02:05:52.43432Z",
    "deleted_at": null,
    "sha1_hash": "2562e47cda34bb0116f2d6fa811ad5b9156b2676",
    "title": "2023-01-29 - Hiding In PlainSight - Indirect Syscall is Dead! Long Live Custom Call Stacks",
    "authors": "",
    "file_creation_date": "2023-03-01T09:33:59Z",
    "file_modification_date": "2023-03-01T09:33:59Z",
    "file_size": 683043,
    "plain_text": "# Hiding In PlainSight - Indirect Syscall is Dead! Long Live Custom Call Stacks\n\n**0xdarkvortex.dev/hiding-in-plainsight/**\n\nPosted on 29 Jan 2023 by Paranoid Ninja\n\nNOTE: This is a PART II blog on Stack Tracing evasion. PART I can be found **_[here.](https://0xdarkvortex.dev/proxying-dll-loads-for-hiding-etwti-stack-tracing/)_**\n\nThis is the second part of the blog I wrote 3 days back on proxying DLL loads to hide\nsuspicious stack traces leading to a user allocated RX region. I wonâ€™t be going in depth on\nhow stack works, because I already covered that in the previous blog which can be accessed\nfrom the above link. We previously saw that we can manipulate the call and jmp instructions\nto request windows callbacks into calling LoadLibrary API call. However, stack tracing\ndetections go far beyond just hunting DLL loads. When you inject a reflective DLL into local\nor remote process, you have to call API calls such as VirtualAllocEx/VirtualProtectEx\nwhich indirectly calls NtAllocateVirtualMemory/NtProtectVirtualMemory. However, when\nyou check the call stack of the legitimate API calls, you will notice that WINAPIs like\n```\nVirtualAlloc/VirtualProtect are mostly called by non-windows DLL functions. Majority of\n\n```\nwindows DLLs will call NtAllocateVirtualMemory/NtProtectVirtualMemory directly. Below\nis a quick example of the callstack for NtProtectVirtualMemory when you call\n```\nRtlAllocateHeap.\n\n```\nThis means that since ntdll.dll is not dependent on any other DLL, all functions in ntdll which\nrequire playing around with permissions for memory regions will call the NTAPIs directly.\nThus, it means that if we are able to reroute our NtAllocateVirtualMemory call via a clean\nstack from ntdll.dll itself, we wont have to worry about detections at all. Most red teams rely\non indirect syscalls to avoid detections. In case of indirect syscalls, you simply jump to the\naddress of syscall instruction after carefully creating the stack, but the issue here is that\nindirect syscalls will only change the return address for the syscall instruction in ntdll.dll.\n\n\n-----\n\n```\nReturn Address in this case is the location where the syscall instruction needs to return to,\n\n```\nafter the syscall is complete. But the rest of the stack below the return address will still be\nsuspicious as they emerge out from the RX region. If an EDR checks the full stack of the\nNTAPI, it can easily identify that the return address eventually reaches back to the user\nallocated RX region. This means, a return address to ntdll.dll region, but stack originating\nfrom RX region is a 100% anomaly with zero chances of being a false positive. This is an\neasy win for EDRs who utilize ETW for syscall tracing in the kernel.\n\nThus in order to evade this, I spent some time reversing several ntdll.dll functions and found\nthat with a little bit of assembly knowledge and how windows callbacks work, we should be\nable to manipulate the callback into calling any NTAPI function. For this blog, we will take an\n[example of NtAllocateVirtualMemory and we will pick the code from our part I blog and](https://github.com/paranoidninja/Proxy-DLL-Loads)\nmodify it. We will take an example of the same API TpAllocWork which can execute a call\nback function. But instead of passing on a pointer to a string like we did in the case of Dll\nProxying, we will pass on a pointer to a structure this time. We will also avoid any global\nvariables this time by making sure all the necessary information goes within the struct as we\ncannot have global variables when we write our shellcodes. The definition of\n```\nNtAllocateVirtualMemory as per msdn is:\n__kernel_entry NTSYSCALLAPI NTSTATUS NtAllocateVirtualMemory(\n\n [in]   HANDLE  ProcessHandle,\n\n [in, out] PVOID   *BaseAddress,\n\n [in]   ULONG_PTR ZeroBits,\n\n [in, out] PSIZE_T  RegionSize,\n\n [in]   ULONG   AllocationType,\n\n [in]   ULONG   Protect\n\n);\n\n```\nThis means, we need to pass on a pointer for NtAllocateVirtualMemory and its arguments\ninside a structure to the callback so that our callback can extract these information from the\nstructure and execute it. We will ignore the arguments which stay static such as ULONG_PTR\n```\nZeroBits which is always zero and ULONG AllocationType which is always\nMEM_RESERVE|MEM_COMMIT which in hex is 0x3000. Thus adding in the remaining arguments,\n\n```\nthe structure will look like this:\n```\ntypedef struct _NTALLOCATEVIRTUALMEMORY_ARGS {\n\n  UINT_PTR pNtAllocateVirtualMemory;  // pointer to NtAllocateVirtualMemory - rax\n\n  HANDLE hProcess;           // HANDLE ProcessHandle - rcx\n\n  PVOID* address;           // PVOID *BaseAddress - rdx; ULONG_PTR\nZeroBits - 0 - r8\n\n  PSIZE_T size;            // PSIZE_T RegionSize - r9; ULONG\nAllocationType - MEM_RESERVE|MEM_COMMIT = 3000 - stack pointer\n\n  ULONG permissions;          // ULONG Protect - PAGE_EXECUTE_READ - 0x20\n- stack pointer\n\n} NTALLOCATEVIRTUALMEMORY_ARGS, *PNTALLOCATEVIRTUALMEMORY_ARGS;\n\n```\n\n-----\n\nWe will then initialize the structure with the required arguments and pass it as a pointer to\n```\nTpAllocWork and call our function WorkCallback which is written in assembly.\n\n```\n\n-----\n\n```\n#include <windows.h>\n\n#include <stdio.h>\n\ntypedef NTSTATUS (NTAPI* TPALLOCWORK)(PTP_WORK* ptpWrk, PTP_WORK_CALLBACK\npfnwkCallback, PVOID OptionalArg, PTP_CALLBACK_ENVIRON CallbackEnvironment);\n\ntypedef VOID (NTAPI* TPPOSTWORK)(PTP_WORK);\n\ntypedef VOID (NTAPI* TPRELEASEWORK)(PTP_WORK);\n\ntypedef struct _NTALLOCATEVIRTUALMEMORY_ARGS {\n\n  UINT_PTR pNtAllocateVirtualMemory;  // pointer to NtAllocateVirtualMemory - rax\n\n  HANDLE hProcess;           // HANDLE ProcessHandle - rcx\n\n  PVOID* address;           // PVOID *BaseAddress - rdx; ULONG_PTR\nZeroBits - 0 - r8\n\n  PSIZE_T size;            // PSIZE_T RegionSize - r9; ULONG\nAllocationType - MEM_RESERVE|MEM_COMMIT = 3000 - stack pointer\n\n  ULONG permissions;          // ULONG Protect - PAGE_EXECUTE_READ - 0x20\n- stack pointer\n\n} NTALLOCATEVIRTUALMEMORY_ARGS, *PNTALLOCATEVIRTUALMEMORY_ARGS;\n\nextern VOID CALLBACK WorkCallback(PTP_CALLBACK_INSTANCE Instance, PVOID Context,\nPTP_WORK Work);\n\nint main() {\n\n  LPVOID allocatedAddress = NULL;\n\n  SIZE_T allocatedsize = 0x1000;\n\n  NTALLOCATEVIRTUALMEMORY_ARGS ntAllocateVirtualMemoryArgs = { 0 };\n\n  ntAllocateVirtualMemoryArgs.pNtAllocateVirtualMemory = (UINT_PTR)\nGetProcAddress(GetModuleHandleA(\"ntdll\"), \"NtAllocateVirtualMemory\");\n\n  ntAllocateVirtualMemoryArgs.hProcess = (HANDLE)-1;\n\n  ntAllocateVirtualMemoryArgs.address = &allocatedAddress;\n\n  ntAllocateVirtualMemoryArgs.size = &allocatedsize;\n\n  ntAllocateVirtualMemoryArgs.permissions = PAGE_EXECUTE_READ;\n\n  FARPROC pTpAllocWork = GetProcAddress(GetModuleHandleA(\"ntdll\"), \"TpAllocWork\");\n\n  FARPROC pTpPostWork = GetProcAddress(GetModuleHandleA(\"ntdll\"), \"TpPostWork\");\n\n  FARPROC pTpReleaseWork = GetProcAddress(GetModuleHandleA(\"ntdll\"),\n\"TpReleaseWork\");\n\n  PTP_WORK WorkReturn = NULL;\n\n  ((TPALLOCWORK)pTpAllocWork)(&WorkReturn, (PTP_WORK_CALLBACK)WorkCallback,\n&ntAllocateVirtualMemoryArgs, NULL);\n\n  ((TPPOSTWORK)pTpPostWork)(WorkReturn);\n\n  ((TPRELEASEWORK)pTpReleaseWork)(WorkReturn);\n\n  WaitForSingleObject((HANDLE)-1, 0x1000);\n\n  printf(\"allocatedAddress: %p\\n\", allocatedAddress);\n\n  getchar();\n\n  return 0;\n\n}\n\n```\n\n-----\n\nNow this is where things get interesting. In case of DLL proxy, we executed LoadLibrary\nwith only one argument i.e. the name of the DLL to load which is passed on to the RCX\nregister. But in the case of NtAllocateVirtualMemory, we have a total of 6 arguments. This\nmeans the first four arguments go into the fastcall registers i.e. RCX, RDX, R8 and R9.\nHowever, the remaining two arguments will have to be pushed to stack after allocating some\nhoming space for our 4 registers. Make note that our top of the stack currently contains the\nreturn value for an internal NTAPI function TppWorkpExecuteCallback at 0ffset 0x130. This\nis how the callstack looks like when the callback function WorkCallback is called.\n\nNow heres the catch. If you modify the top of the stack where the return address lies, add the\nhoming space for the 4 registers and add arguments to it, the whole stack frame will go for a\ntoss and mess up stack unwinding. Thus we have to modify the stack without changing the\nstack frame itself, but by only changing the values within the stack frame. Each stack frame\nstarts and ends at the blue line shown in the image above. Our stack frame for\n```\nTppWorkpExecuteCallback has enough space within itself to hold 6 arguments. So our next\n\n```\nstep is to extract the data from our NTALLOCATEVIRTUALMEMORY_ARGS structure and move it to\nthe respective registers and stack. When we call TpAllocWork, we pass on the pointer to\n```\nNTALLOCATEVIRTUALMEMORY_ARGS structure to the WorkCallback function, this means our\n\n```\npointer to the structure should be in the RDX register now. Each value in our structure is of 8\nbytes (for x64, for x86 it would be 4 bytes). So, we will extract these QWORD values from\nthe structure and move it to RCX, RDX, R8, R9 and the remaining values on stack after\nadjusting the homing space. The calling convention for x64 functions in windows as per the\n[msdn documentation would be:](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170)\n\n\n-----\n\n```\n__kernel_entry NTSYSCALLAPI NTSTATUS NtAllocateVirtualMemory(\n\n [in]   HANDLE  ProcessHandle, // goes into rcx\n\n [in, out] PVOID   *BaseAddress,  // goes into rdx\n\n [in]   ULONG_PTR ZeroBits,    // goes into r8\n\n [in, out] PSIZE_T  RegionSize,   // goes into r9\n\n [in]   ULONG   AllocationType, // goes to stack after adjusting homing space\nfor 4 arguments\n\n [in]   ULONG   Protect     // goes to stack below the 5th argument after\nadjusting homing space for 4 arguments\n\n);\n\n```\nConvering this logic to assembly would look like:\n```\nsection .text\n\nglobal WorkCallback\n\nWorkCallback:\n\n  mov rbx, rdx        ; backing up the struct as we are going to stomp rdx\n\n  mov rax, [rbx]       ; NtAllocateVirtualMemory\n\n  mov rcx, [rbx + 0x8]    ; HANDLE ProcessHandle\n\n  mov rdx, [rbx + 0x10]    ; PVOID *BaseAddress\n\n  xor r8, r8         ; ULONG_PTR ZeroBits\n\n  mov r9, [rbx + 0x18]    ; PSIZE_T RegionSize\n\n  mov r10, [rbx + 0x20]    ; ULONG Protect\n\n  mov [rsp+0x30], r10     ; stack pointer for 6th arg\n\n  mov r10, 0x3000       ; ULONG AllocationType\n\n  mov [rsp+0x28], r10     ; stack pointer for 5th arg\n\n  jmp rax\n\n\n```\nTo explain the above code:\n\nWe first backup our pointer to the structure residing in the RDX register into the RBX\nregister. We are doing this because we are going to stomp the RDX register with the\nsecond argument of NtAllocateVirtualMemory when we call it\nWe move the first 8 bytes from the address in RBX register (struct\n```\n   NTALLOCATEVIRTUALMEMORY_ARGS i.e UINT_PTR pNtAllocateVirtualMemory) to rax\n\n```\nregister where we will jump to later after adjusting the arguments\nWe move the second set of 8 bytes (HANDLE hProcess) from the structure to RCX\nWe move the third set of 8 bytes i.e. pointer to a NULL pointer (PVOID* address)\nstored in the structure into RDX. This is where our allocated address will be written by\n```\n   NtAllocateVirtualMemory\n\n```\nWe zero out the R8 register for the ULONG_PTR ZeroBits argument\n\n\n-----\n\nWe move the 6th argument i.e the last argument which should go to the bottom of all\narguments (ULONG Protect i.e. PAGE permissions) to r10 and then move it to offset\n```\n   0x30 from top of the stack pointer.\n\n```\nTop of the stack pointer = RSP = Return address of TppWorkpExecuteCallback\nwhich is 8 bytes\nHoming space size for 4 arguments = 4x8 = 32 bytes\nSpace for the 5th argument = 8 bytes\nThus 32+8 = 40 = 0x28 (this is where the second last 5th argument will go)\nThus 32+8+8 = 48 = 0x30 (this is where the last 6th argument will go)\nWe finally move the 5th argument value (ULONG AllocationType) i.e. 0x3000 ```\n   MEM_COMMIT|MEM_RESERVE to the R10 register and then push it to offset 0x28 from the\n\n```\nRSP\n\nCompiling it all together, this is what it looks like before jumping to\n```\nNtAllocateVirtualMemory:\n\n```\nThe disassembled code shows the asm instructions we wrote. The current instruction\npointer is just after adjusting the stack and before jumping to\n```\n   NtAllocateVirtualMemory\n\n```\nThe registers show the arguments for NtAllocateVirtualMemory\nThe Dump shows the NTALLOCATEVIRTUALMEMORY_ARGS structure in memory. Each 8\nbyte memory block is an object relating to the contents of the strucutre\nThe stack shows the adjusted stack for NtAllocateVirtualMemory\n\nAnd a quick look at the stack after the execute of NtAllocateVirtualMemory shows a valid\ncallstack which can be unwinded perfectly. You can also see that the syscall for\n```\nNtAllocateVirtualMemory returned zero which means the call was successful.\n\n```\n\n-----\n\nThe stack is as clear as crystal again with no signs of anything malevolent. Make note that\nthis is not stacking spooing, because in our case the stack is being unwinded fully without\ncrashing. There are many more such API calls which can be used for proxying various\nfunctions; which I will leave it out to the readers to use their own creativity. The upcoming\nrelease of BRc4 will use something similar but with different set of API calls which are fully\nundocumented and will be under a different payload option called as stealth++. The full\n[code for this can be found in my github repository.](https://github.com/paranoidninja/Proxy-Function-Calls-For-ETwTI)\n\n[Tagged with: red-team](https://0xdarkvortex.dev/tags/red-team/) [blogs](https://0xdarkvortex.dev/tags/blogs/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-01-29 - Hiding In PlainSight - Indirect Syscall is Dead! Long Live Custom Call Stacks.pdf"
    ],
    "report_names": [
        "2023-01-29 - Hiding In PlainSight - Indirect Syscall is Dead! Long Live Custom Call Stacks.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1677809126,
    "ts_updated_at": 1743041152,
    "ts_creation_date": 1677663239,
    "ts_modification_date": 1677663239,
    "files": {
        "pdf": "https://archive.orkl.eu/2562e47cda34bb0116f2d6fa811ad5b9156b2676.pdf",
        "text": "https://archive.orkl.eu/2562e47cda34bb0116f2d6fa811ad5b9156b2676.txt",
        "img": "https://archive.orkl.eu/2562e47cda34bb0116f2d6fa811ad5b9156b2676.jpg"
    }
}