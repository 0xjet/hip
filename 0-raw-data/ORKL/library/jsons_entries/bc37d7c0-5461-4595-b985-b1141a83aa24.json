{
    "id": "bc37d7c0-5461-4595-b985-b1141a83aa24",
    "created_at": "2022-10-25T16:48:19.080569Z",
    "updated_at": "2025-03-27T02:09:30.45934Z",
    "deleted_at": null,
    "sha1_hash": "f6199ae7db7a2adfc28fa8b751fec7a88639fca2",
    "title": "",
    "authors": "",
    "file_creation_date": "2020-04-08T06:24:35Z",
    "file_modification_date": "2020-04-08T06:24:35Z",
    "file_size": 907587,
    "plain_text": "# New Ursnif Campaign: A Shift from PowerShell to Mshta\n\n**zscaler.com/blogs/research/new-ursnif-campaign-shift-powershell-mshta**\n\nPublished on: April 07, 2020 Authored by: Sahil Antil Kumar Pranjal Shukla\n\nRecently, we saw the start of a campaign featuring a new multistage payload distribution technique for the well-known banking Ttojan named Ursnif (aka Gozi\naka Dreambot). The malware has been around for a long time and remains active leveraging new distribution techniques. In this blog, we will analyze one of\nthe recent campaigns.\n\nThis new campaign began on March 24, 2020. The malware is being distributed with the name info_03_24.doc, which is quite similar to one of its 2019\nmalware distribution campaigns (info_07_.{date}.doc). Moreover, the final payload delivery URLs available during the time of analysis were all registered on\nthe same date and around the same time frame (2020-03-24 T12:00:00Z), which is a strong indicator of the beginning of a new campaign.\n\n## Multistage\n\nFor a long time malware authors have been trying to distribute malware in multiple stages. This helps the main malware evade detection in the early stages so\nthat it can be delivered in the last stage. This is the case with Ursnif. It is being delivered in three stages:\n\nVBA macro [doc] --------------> HTML [mshta]---------------> DLL [regsvr32]\n\n(Stage 1)                (Stage 2)              (Stage 3)\n\n## Why mshta?\n\nOne of the reasons malware authors try to switch to new delivery methods is to bypass security defenses, leave fewer footprints, and blend with existing\nsystem noise on the victim's machine. This seems to be the reason for using mshta in this new campaigndespite using PowerShell as the second-stage\npayload in the past.\n\n**A brief description of mshta**\n\nMshta.exe is a utility that executes Microsoft HTML Applications (HTAs). HTAs are stand-alone applications that execute using the same models and\ntechnologies of Internet Explorer, but outside of the browser. Adversaries can use mshta.exe to proxy execution of malicious .hta files and JavaScript or\nVBScript through a trusted Windows utility. Mshta.exe can be used to bypass application whitelisting solutions, which do not account for its potential use, and\ndigital certificate validation. Since mshta.exe executes outside of Internet Explorer's security context, it also bypasses browser security settings.\n\n## Doc file analysis [First stage]\n\nAs mentioned earlier, the malware's initial payload was being delivered via document files with the name info_03_24.doc during the time of our analysis. The\ndocument didn’t contain any exploits but used macro code to drop the second-stage payload. The macro code is obfuscatedbut doesn’t seem to contain\nany anti-checks.\n\n**VBA macro code analysis**\n\nThe VBA macro code contains one form and three modules.\n\n**Form [frm]: This contains a textbox whose valueproperty contains the second stage payload to be dropped.**\n\n**Module1 [a7kcX]: This contains an AutoOpen and final macro code execution routine.**\n\n**Module2 [aDbCyK]: This is the file creation and string decoder routine.**\n\n**Module3 [axmNj]: This contains string generation and the main routine.**\n\n_Figure 1: Form and modules in the VBA macro code._\n\nExecution of macro code begins from the AutoOpen routine, which is executed every time you open the document.\nThe AutoOpen routine, in turn, calls the main routine, which performs the following operations:\n\n1. Obtain the required strings from three string-generator routines.\n2. Copy the mshta.exe code to microsoft.com (possibly to reduce footprints).\n3. Write the second stage payload to index.html.\n4. Execute the index.html with microsoft.com.\n\n\n-----\n\n_Figure 2: String generators and the main routine._\n\n## Index.html analysis [Second stage]\n\nThe index.html file is obfuscated with garbage code and random variable names. After removal of the obfuscation, the file comes out containing the following\ncode components:\n\n**HTML code: This defines a paragraph element, which contains some ASCII data to be used later.**\n\n**JavaScript: This contains static string variables and the custom decoder**\n\n**ActiveX: This is used for file system access, downloading final payload and executing it.**\n\nUpon execution of index.html with microsoft.com [mshta.exe], the JavaScript and ActiveX code gets executed to perform the following operations:\n\n1. Create a shell object with ActiveX\n2. Read the paragraph element containing ASCII data using the innerHTML property\n3. Write the read content to the registry key: \"HKEY_CURRENT_USER\\\\Software\\\\test1\\\\mykey”\n4. Read the newly created registry key value\n5. Delete the registry key\n6. Pass the read content to the decoder routine\n7. Create a new function object where the function body is decoded ASCII data and it takes two arguments as the inputs, namely ‘u’ and ‘c’\n8. Call the newly created function with u=“261636e223b616f6a7d3c6f3078607e2e65676271647f2572746e657b6f2d6f636e28647\n\n27f627a7c6f687f2f2a307474786” and c=0\n\n\n-----\n\n_Figure 3: The deobfuscated index.html_\n\n## Decoded ASCII data analysis\n\nThe decoded ASCII data is another JavaScript and ActiveX code snippet, which is also obfuscatedusing garbage code and random variable names. Upon\nremoval of the obfuscation, it turns out to be performing the following operations:\n\n1. Create an XMLHTTP object, stream object, and shell object using ActiveX.\n2. Get the path %temp% and append index.dll (the final payload filename) to it.\n3. Decode the ‘u’ variable earlier passed as an argument, which turns out to be the final payload URL.\n4. Send a GET request to the decoded URL.\n5. If the response status is 200 and the operation is complete, it saves the downloaded data to the index.dll file created earlier.\n6. Execute the downloaded DLL using regsvr32.\n\n\n-----\n\n_Figure 4: Decoded and deobfuscated ASCII data_\n\n## Index.dll (third and final stage)\n\nThe index.dll turns out to be the final and main payload, which is Ursnif. The DLL is executed using regsvr32 as it doesn’t contain any export functions and the\nmalicious code is present within the DllMain routine itself.\n\n_Note: rundll32 is generally used to execute DLLs, and regsvr32 is mainly meant for COM DLLs. Since no exports are present in this case, we can use regsvr32_\n_to execute the DllMain routine, which again might be a good way to reduce footprints or even avoid them due to the unpopularity of regsvr32 among malware._\n_If this is not the case, then only the malware author knows._\n\n## Conclusion\n\nThe banking Trojan Ursnif (aka Gozi aka Dreambot) is not new, and it continually resurfaces with new distribution techniques. It appears to be back in a form\ndesigned to leave fewer footprints and avoid detection while trying to steal victim's data. The Zscaler ThreatLabZ team will continue to observe this new\nversion of Ursnif to help keep our customers safe and to monitor whether it returns in another form.\n\n## Newly registered campaign domains\n\nhxxp://xolzrorth[.]com\n\nhxxp://grumnoud[.]com\n\nhxxp://gandael6[.]com\n\nhxxp://chersoicryss[.]com\n\n## Payload URLs\n\nhxxp://xolzrorth[.]com/kundru/targen.php?l=zoak2.cab\n\nhxxp://grumnoud[.]com/kundru/targen.php?l=zoak4.cab\n\nhxxp://gandael6[.]com/kundru/targen.php?l=zoak6.cab\n\n\n-----\n\nhxxp://chersoicryss[.]com/kundru/targen.php?l=zoak2.cab\n\n## Download URL:\n\ndoc-00-2odocs.googleusercontent[.]com/docs/securesc/97lq9pt3pod9mpumel15kp2j33hcurr8/c560lkciidvhh4viucof3ludaoief0m5/1585069725000/11599430631386789056/11599430\n39p5i0k7i0r?e=download&authuser=0&nonce=ua6b0u4p5r3mq&user=11599430631386789056&hash=irhbu94ms0nq978q6ipge2kgosjdll3a\n\n## MD5:\n\n8212E2522300EF99B03DFA18437FCA40\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2020/2020.04.07_New_Ursnif_Campaign/New%20Ursnif%20campaign_%20a%20shift%20from%20PowerShell%20to%20Mshta.pdf"
    ],
    "report_names": [
        "New Ursnif campaign_ a shift from PowerShell to Mshta"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716499,
    "ts_updated_at": 1743041370,
    "ts_creation_date": 1586327075,
    "ts_modification_date": 1586327075,
    "files": {
        "pdf": "https://archive.orkl.eu/f6199ae7db7a2adfc28fa8b751fec7a88639fca2.pdf",
        "text": "https://archive.orkl.eu/f6199ae7db7a2adfc28fa8b751fec7a88639fca2.txt",
        "img": "https://archive.orkl.eu/f6199ae7db7a2adfc28fa8b751fec7a88639fca2.jpg"
    }
}