{
    "id": "52ce5ea8-8b3c-4c96-98d6-adae0f87b089",
    "created_at": "2023-01-12T15:10:06.339803Z",
    "updated_at": "2025-03-27T02:05:36.897445Z",
    "deleted_at": null,
    "sha1_hash": "4dfaabdefe46e3b337f8c25c4f17d79dfd84e89c",
    "title": "2021-08-04 - Understanding BlackMatter's API Hashing",
    "authors": "",
    "file_creation_date": "2022-05-28T02:11:08Z",
    "file_modification_date": "2022-05-28T02:11:08Z",
    "file_size": 546646,
    "plain_text": "# Understanding BlackMatter's API Hashing\n\n**[blog.digital-investigations.info/2021-08-05-understanding-blackmatters-api-hashing.html](https://blog.digital-investigations.info/2021-08-05-understanding-blackmatters-api-hashing.html)**\n\n04 Aug 2021\n\n## tl;dr:\n\n[The ransomware BlackMatter aims at stepping into the void, which was left by REvil’s and](https://malpedia.caad.fkie.fraunhofer.de/details/win.revil)\n[DarkSide’s (temporary) retreat. At this point in time this new ransomware seems to pose a](https://malpedia.caad.fkie.fraunhofer.de/details/win.darkside)\nserious threat. In this blogpost BlackMatter’s API hashing mechanism is described in detail\nand a Ghidra-script is supplied 1 to aid future analyses.\n\n**The API hashing algorithm: To calculate the API hashes for function names, each and**\nevery character is added up, while a binary rotation to the right by 13 bits is performed in\neach iteration. The hash of the housing module, which was calculated in the same manner\nbefore, serves as a seed value for the respective hash.\n\n**Storing addresses: Notably, BlackMatter does not store the function addresses in clear**\nafter resolving them. Instead it uses an array of “trampoline-pointers”, which point to small,\ndynamically allocated assembly blocks (12 bytes in size), which perform the XOR-decoding\nof the encoded version of the respective function address, that was placed in there during\nimport resolution and call it afterwards.\n\n## Motivation\n\n\nA new ransomware gang named BlackMatter appeared in July 2021 and started to recruit\naffiliates at the underground forums Exploit and XSS2 . They fill the void, which is left by\n[DarkSide’s shutdown after the Colonial Pipeline attack3](https://malpedia.caad.fkie.fraunhofer.de/details/win.darkside) and [REvil’s disappearing in the mid](https://malpedia.caad.fkie.fraunhofer.de/details/win.revil)\nof July after pwning Kaseya .4\n\nOn the 2nd of August 2021 an interview of D. Smilyanets (The Record) with the alleged\nthreat actor behind BlackMatter was published .5 Within this interview, the actor states, that\n[he is neither the successor of DarkSide nor](https://malpedia.caad.fkie.fraunhofer.de/details/win.darkside) [REvil, instead he proclaims, that BlackMatter](https://malpedia.caad.fkie.fraunhofer.de/details/win.revil)\n[tries to unify the best of the ransomwares LockBit,](https://malpedia.caad.fkie.fraunhofer.de/details/win.lockbit) [REvil and](https://malpedia.caad.fkie.fraunhofer.de/details/win.revil) [DarkSide, which all have their](https://malpedia.caad.fkie.fraunhofer.de/details/win.darkside)\nindividual strengths in the opinion of the alleged actor behind “the new ransomware on the\nblock”.\n\nAt this point in time it seems to be a valid assumption, that BlackMatter will keep the DFIRcommunity and the law enforcement agencies busy for the next few weeks, therefore initial\nanalyses might be helpful to get to know the threat imposed by this probably rebranded\nactor.\n\n\n-----\n\n## Scope\n\nFor this analysis the BlackMatter-sample with SHA256\n```\n7f6dd0ca03f04b64024e86a72a6d7cfab6abccc2173b85896fc4b431990a5984\n\n```\nwas used. It has a compilation timestamp of 23rd of July 2021 20:51:18 UTC and was\n[published on the 2nd of August 2021 at MalwareBazaar .6](https://bazaar.abuse.ch/)\n\nThis blog post deals with the API hashing found in this sample and shows a way to defeat it\nwith the help of Ghidra scripting. Resolving the hidden imports, is the main prerequisite for a\nstatic analysis of BlackMatter-binaries. However, further steps, like the decoding of its\neventually available config data, are not in scope of this blog post.\n\n## Findings\n\nDirectly after the entry point of the executable, the function at address `00405e5c, which is`\nresponsible for initializing the import resolution is called, as the following figure of the\ndecompiled code illustrates.\n\n\n-----\n\nFigure 1: Decompilation of the setup function at `00405e5c, which kicks off the import`\nresolution\nAt l. 10 and l. 15 of this function the actual import resolution is started by calling another\nfunction at `0040581d, named` `resolveHashedImport in the figure above. In this function`\nall the heavy lifting required to resolve symbols is performed, e.g. the loaded modules are\ntraversed in memory by utilizing the doubly-linked list named `InLoadOrderModuleList of`\nthe `PEB_LDR_DATA -struct and so on.`\n\n\n-----\n\nThe goal of those initial calls is to retrieve `HeapCreate and` `HeapAlloc (l. 10 and 15) at`\nfirst. This is only possible since the called function at `0040581d ensures that`\n```\nLoadLibraryA and GetProcAddress are loaded on the first invocation by recursive calls\n\n```\nto itself, as it is shown in the following figure exemplary for `LoadLibraryA .`\n\nFigure 2: Recursive call from within `0040581d to load` `LoadLibraryA on the first`\ninvocation\nSo how is the hash, which is passed to the function called at `00405844 calculated by`\n_BlackMatter?_\n\n### Hash calculation\n\nFor the calculation of the API hash each character is added up one by another. In each\niteration a seeded ROR-13-operation is performed, as the following figure illustrates.\n\n\n-----\n\nFigure 3: Algorithm to calculate the API hash\nBecause of the fact, that the hash of the module name is used as a seed, a two step process\nhas to be employed to construct the final API hash for a single function.\n\nFirst, the module name is hashed in a similar manner with a seed of 0. This happens in the\nfunction at `004010bb, which is not shown here. It is looped over the characters, which are`\ntransformed to lower case. In each iteration a rotation by 13 bits of the dword value resulting\nfrom the previous iteration is performed and the current character value is added. This leads\nto the following Python implementation:\n```\ndef calc_mod_hash(modname):\n  mask = 0xFFFFFFFF\n  h = 0\n  for c in modname + \"\\x00\":\n    cc = ord(c)\n    if (0x40 < cc and cc < 0x5b):\n      cc = (cc | 0x20) & mask\n    h = (h >> 0xd) | (h << 0x13)\n    h = (h + cc) & mask\n  return h\n\n```\n\n-----\n\nThe resulting hash of the module name is then used as a seed for the similar but simpler\nfunction presented at fig. 3, which finally calculates the actual function hash. The following\nPython code shows the logic found in this function at `00401096 :`\n```\ndef calc_func_hash(modhash, funcname):\n  mask = 0xFFFFFFFF\n  h = modhash\n  for c in funcname + \"\\x00\":\n    cc = ord(c)\n    h = (h >> 0xd) | (h << 0x13)\n    h = (h + cc) & mask\n  return h\n\n```\n**_Note: It is important to add the nullbyte, so that for a function name of n characters, n+1_**\n_ROR-operations are performed.7_\n\nIn summary this leads to the following calculation of a function hash as it is used by\n_BlackMatter:_\n```\ndef get_api_hash(modname, funcname):\n  return calc_func_hash(calc_mod_hash(modname), funcname)\n\n```\nLet’s test it:\n```\nmn = \"kernel32.dll\"\nfn = \"GetProcAddress\"\nprint(hex(get_api_hash(mn, fn)))\nmn = \"kernel32.dll\"\nfn = \"LoadLibraryA\"\nprint(hex(get_api_hash(mn, fn)))\n#+Result\n: 0xbb93705c\n: 0x27d05eb2\n\n```\nIndeed, both hashes can be found in the binary, as fig. 3 shows:\n\nFigure 4: Function hashes of `LoadLibraryA and` `GetProcAdress`\n\n\n-----\n\nActually only `0x5d6015f ^ 0x22065fed, wich results in` `0x27d05eb2 can be found, since`\nall API hashes are stored XORed with `0x22065fed and are XORed again with this value`\nbefore a comparison with the calculated hash.\n\n### (Re)storing imports\n\nAfter the a/m and absolutely required functions like `HeapAlloc,` `LoadLibraryA, etc. have`\nbeen loaded. BlackMatter resolves blocks of hashed functions stored as dwords in global\nmemory (2nd arg to function )8 and stores pointers to dynamically allocated “structs” in global\nmemory as well (1st arg to function )9 :\n\n\nFigure 5: Resolving array of hashes (here for Kernel32.dll)\nLine 18 in fig. 1 already showed this code in a decompiled representation.\n\nFig. 6 shows the decompilation of the called function beginning at `00405a86 . Within there,`\nit is looped over the array of function hashes until the value `0xCCCCCCCC is reached. This`\nserves as an indicator of the end of the list of function hashes, so the loop stops in l. 19,\nwhen this value is read.\n\n\n-----\n\nFigure 6: Storing XORed function address with Assembly instructions\nLine 29 ff. looks very interesting here. To further complicate analysis, BlackMatter does not\nstore the function address itself in the result array. Instead it stores a pointer to 12 bytes of\ndynamically allocated memory. In these 12 bytes it does not store the function address in\nclear. Instead the results of XOR-operations (here XORed with `0x22065fed ) are stored`\ntogether with assembly instructions to decode the real function address on the fly, when the\nfunction is called as fig. 6 suggests.\n\nSo the global array of pointers which is passed as a buffer to hold the results of the import\nresolution (e.g. l. 18 ff. in fig. 1 and fig. 5) acts as trampoline, so that on each call, it is\njumped to a 12 byte “function-struct”, which is comprised of the following opcode sequence\non the heap, where the questionmarks resemble the XORed-function address in question:\n```\nB8 ?? ?? ?? ?? 35 ED 5F 06 22 E0 FF\n\n```\n\n-----\n\nUpon execution, these instructions load the XORed-function address into EAX and perform\nthe XOR-operation again to reverse it and to finally call the decoded function address, so\nthat the actual libary-call is performed without storing the function-addresses in memory.\n\n### Import resolution with Ghidra scripting\n\nThe labelling of the a/m “trampoline-pointers”, whose call ultimately leads to the execution of\nthe a/m opcode-sequence should be automated with Ghidra’s scripting capabilities. To\naccomplish this, have a look at the following Java-code in my Gist:\n\nhttps://gist.github.com/jgru/c58851bde4ee4778d83c84babb2f69d1#fileblackmatterapihashing-java\n\n[Note, that this Ghidra-script is based on L. Wallenborn’s and](https://twitter.com/larsborn) [J. Hüttenhain’s template](https://twitter.com/huettenhain)\ncode10. (Thank you guys for your invaluable teaching!)\n\nUpon execution the script asks for the name of the resolving function (the one called in fig.\n5), which takes the two pointers to global memory regions (here at `00405a86 ). In the next`\nGUI-dialog, that pops up, the XOR-key has to be specified (here `0x22065fed ). Afterwards`\nyou have to choose the file, containing the precomputed hashes, which should be used for\nname resolution. This list can be found at my Gist as well:\n\nhttps://gist.github.com/jgru/c58851bde4ee4778d83c84babb2f69d1#file-blackmatter_apihash-json\n\nIf you stumble upon a BlackMatter-sample, that uses the same ROR-13-hashing, this script\nmight help to get you started quickly with the analysis.\n\n## Conclusion\n\nThis blog post detailed the API-hashing mechanism employed by the new ransomware\n_BlackMatter._\n\nTo hash a function name, BlackMatter employs a seeded ROR13 in an iterative manner. That\nis a rotation of the dword by 13 bits to the right. The name of the housing module, hashed in\nthe same way, but with an initial value of 0, is used as a seed for this trivial hashing\nalgorithm. It has to be noted, that due to the implementation with a do-while-loop, for a\nfunction name of length n (terminating zero-byte excluded) n+1 ROR-operations will be\nperformed. The API hashes are initially stored as dwords in global arrays XORed with\n```\n0x22065fed .\n\n```\nInterestingly, the imported function addresses are stored in a dynamically allocated memory\nregion. To further complicate analysis, BlackMatter does not store the function address itself,\nbut the result of an XOR-operation (here again XORed with `0x22065fed ) together with`\n\n\n-----\n\nassembly instructions to decode it on the fly, when the function is called by a pointer to this\nmemory location housing these instructions.\n\nDuring the import resolution-routine at `00405a86, which is called multiple times with`\ndifferent arrays of API hashes, pointers to those opcode-sequences are stored in a global\narray, which is then referenced for executing the single functions, when needed.\n\nIf you have any notes, errata, hints, feedback, etc., please send a mail to\n```\nca473c19fd9b81c045094121827b3548 at digital-investigations.info .\n\n```\n[Tags:](https://blog.digital-investigations.info/tags.html) [TI](https://blog.digital-investigations.info/tag-ti.html) [REM](https://blog.digital-investigations.info/tag-rem.html)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-08-04 - Understanding BlackMatter's API Hashing.pdf"
    ],
    "report_names": [
        "2021-08-04 - Understanding BlackMatter's API Hashing.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536206,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1653703868,
    "ts_modification_date": 1653703868,
    "files": {
        "pdf": "https://archive.orkl.eu/4dfaabdefe46e3b337f8c25c4f17d79dfd84e89c.pdf",
        "text": "https://archive.orkl.eu/4dfaabdefe46e3b337f8c25c4f17d79dfd84e89c.txt",
        "img": "https://archive.orkl.eu/4dfaabdefe46e3b337f8c25c4f17d79dfd84e89c.jpg"
    }
}