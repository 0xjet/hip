{
    "id": "bcda1f18-c154-4334-9694-201a91f2b9d5",
    "created_at": "2022-10-25T16:48:16.333177Z",
    "updated_at": "2025-03-27T02:05:35.443245Z",
    "deleted_at": null,
    "sha1_hash": "b36210fbdd48447cc39ec77e317f1f3ec43b8ae6",
    "title": "",
    "authors": "",
    "file_creation_date": "2019-04-23T02:05:19Z",
    "file_modification_date": "2019-04-23T02:05:19Z",
    "file_size": 317277,
    "plain_text": "# Reversing malware in a custom format: Hidden Bee elements\n\n**[blog.malwarebytes.com/threat-analysis/2018/08/reversing-malware-in-a-custom-format-hidden-bee-elements](https://blog.malwarebytes.com/threat-analysis/2018/08/reversing-malware-in-a-custom-format-hidden-bee-elements/)**\n\nPosted: August 30, 2018 by hasherezade August 30, 2018\n\nMalware can be made of many components. Often, we encounter macros and scripts that work as\nmalicious downloaders. Some functionalities can also be achieved by position-independent code—socalled shellcode. But when it comes to more complex elements or core modules, we almost take it for\ngranted that it will be a PE file that is a native Windows executable format.\n\nThe reason for this is simple: It is much easier to provide complex functionality within a PE file than within a\nshellcode. PE format has a well-defined structure, allowing for much more flexibility. We have certain\nheaders that define what imports should be loaded and where, as well as how the relocations should be\napplied. This is a default format generated when we compile applications for Windows, and its structure is\nthen used by Windows Loader to load and execute our application. Even when the malware authors write\ncustom loaders, they are mostly for the PE format.\n\nHowever, sometimes we find exceptions. Last time, when we analyzed payloads related to Hidden Bee\n(dropped by the Underminer exploit kit), we noticed something unusual. There were two payloads dropped\nthat didn’t follow the PE format. Yet, their structure looked well organized and more complex than we\nusually encounter dealing with pieces of shellcode. We decided to take a closer look and discovered that\nthe authors of this malware actually created their own executable format, following a consistent structure.\n\n## Overview\n\nThe first payload: [b3eb576e02849218867caefaa0412ccd (with .wasm extension, imitating Web Assembly)](https://www.virustotal.com/#/file/76b70f1dfd64958fca7ab3e18fffe6d551474c2b25aaa9515181dec6ae112895/details)\nis a loader, downloading and unpacking a Cabinet file:\n\n\n-----\n\nThe second payload: [11310b509f8bf86daa5577758e9d1eb5, unpacked from the Cabinet:](https://www.virustotal.com/#/file/c1a6df241239359731c671203925a8265cf82a0c8c20c94d57a6a1ed09dec289/details)\n\nWe can see at first that in contrast to most shellcodes, it does not start from a code, but from some\nheaders. Comparing both modules, we can see that the header has the same structure in both cases.\n\n## Headers\n\nWe took a closer look to decipher the meaning of particular fields in the header.\n\nThe first DWORD: 0x10000301 is the same in both. We didn’t find this number corresponding to any of the\npieces within the module. So, we assume it is a magic number that makes an identifier of this format.\n\nNext, two WORDs are offsets to elements related to loading the imports. The first one (0x18) points to the\nlist of DLLs. The second block (0x60) looks more mysterious at first. Its meaning can be understood when\nwe load the module in IDA. We can see the cross-references to those fields:\n\n\n-----\n\nWe see that they are used as IAT—they are supposed to be filled with the addresses to the imported\nfunctions:\n\nThe next value is a DWORD (0x2A62). If we follow it in IDA, we see that it leads to the beginning of a new\nfunction:\n\nThis function is not referenced by any other functions so we can suspect that it is the program’s Entry Point.\n\nThe meaning of the next value (0x509C) is easy to guess because it is the same as the size of the full\nmodule.\n\nThen, we have the last two DWORDs of the header. The second DWORD (0x4D78) leads to the structure\nthat is very similar to the PE’s relocations. We can guess that it must be a relocation table of the module,\nand the previous DWORD specifies its size.\n\n\n-----\n\nThis is how we were able to reconstruct the full header:\n\ntypedef struct {\nDWORD magic;\n\nWORD dll_list;\nWORD iat;\nDWORD ep;\nDWORD mod_size;\n\nDWORD relocs_size;\nDWORD relocs;\n} t_bee_hdr;\n\n## Imports\n\nAs we know from the header, the list of the DLLs starts at the offset 0x18. We can see that each of the\nDLL’s names are prepended with a number:\n\nThe numbers are not corresponding with a DLL name: In two different modules, the same DLL had different\nnumbers assigned. But if we sum up all the numbers, we find that their total sum is the same as the number\nof DWORDs in the IAT. So, we can make an educated guess that those numbers are specifying how many\nfunctions will be imported from a particular DLL.\n\nWe can describe it as the following structure (where the name’s length is not specified):\n\ntypedef struct {\nWORD func_count;\nchar name;\n} t_dll_name;\n\nThen, the IAT comes as a list of DWORDs:\n\n\n-----\n\nIt is common in malware that when the function’s names are not given as an explicit string, they are\nimported by checksum. The same is done in this case. Guessing the appropriate function that was used for\ncalculating the checksum can be more difficult. Fortunately, we found it in the loader component:\n\nDWORD checksum(char *func_name)\n{\nDWORD result = 0x1505;\nwhile ( *func_name )\nresult = *func_name++ + 33 * result;\nreturn result;\n}\n\nKnowing that we paired appropriate checksums with the function’s names:\n\nOnce the address of the function is retrieved, it is stored\nin the IAT in place of the checksum.\n\n## Relocations\n\nCreating a relocation table is simple. It consists of the list of DWORDs that are identifying the offsets of the\nplaces in the code to which we should add the base where the module has been loaded. Without\nrelocations applied, the module will crash (so, it is not position-independent like a typical shellcode).\n\n\n-----\n\n## Comparison to PE format\n\nWhile the PE format is complex, with a variety of headers, this one contains only essentials. Most of the\ninformation that is usually stored in a PE header is completely omitted here.\n\nYou can see a PE format visualized by Ange Albertini [here.](https://raw.githubusercontent.com/corkami/pics/master/binary/PE101.png)\n\nCompare it with the visualization of the currently analyzed format:\n\n## Static analysis\n\n\n-----\n\nWe can load this code into IDA as a blob of raw code. However, we will be missing important information.\nDue to the fact that the file doesn’t follow a PE structure, and its import table is non-standard, we will have\na hard time understanding which API calls are being made at which offset. To solve this problem, I made a\ntool that resolves hashes into function names and generates a TAG file to mark the offsets where each\nfunction’s address is going to be filled.\n\nThose tags can be loaded into IDA using an [IFL plugin:](https://github.com/hasherezade/ida_ifl)\n\nHaving all the API functions tagged, it is much easier to understand which actions are performed by the\nmodule. Here, for example, we can see that it will be establishing the connection with the C2 server:\n\n## Dynamic analysis\n\n\n-----\n\nThis format is custom, so it is not supported by the typical tools for analysis. However, after understanding\nit, we can write our own tools, such as the parser for the headers and loader that will help to run this format\nand analyze it dynamically.\n\nIn contrast to PE, the module doesn’t have any sections. So, we need to load it in a continuous memory\nregion with RWX (read-write-execute) access. Walking through the relocations list, we will add the value of\nthe base at which the module was loaded to the listed addresses. Then, we have to resolve the imported\nfunctions by their hashes and fill the addresses in the thunks. After preparing the stage, it just needs to\njump at the Entry Point of the module. We will load the prepared loader under the debugger and follow to\nthe entry point of the loaded module.\n\n## Simple but rare\n\nThe elements described here are pretty simple—they serve as a first stage of the full malware package,\ndownloading other pieces and injecting them into processes. However, what makes them interesting is the\nfact that their authors have shown some creativity and decided to invent a custom format that is less\ncomplex than a full-fledged PE, but goes a step further than a typical piece of shellcode.\n\nSuch module, in contrast to independent shellcode, is not self-sufficient and cannot be loaded in a trivial\nway, but must be parsed first. Given the fact that the format is custom, it is not supported by existing tools.\nThis is where programming skills come in handy for a malware analyst.\n\nFortunately, fully custom formats are rather uncommon in the malware world; usually, authors rely heavily\non existing formats, from time to time corrupting or customizing selected parts of PE headers.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2018/2018.08.30.Hidden_Bee_Custom_format/Reversing%20malware%20in%20a%20custom%20format_%20Hidden%20Bee%20elements.pdf"
    ],
    "report_names": [
        "Reversing malware in a custom format_ Hidden Bee elements"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716496,
    "ts_updated_at": 1743041135,
    "ts_creation_date": 1555985119,
    "ts_modification_date": 1555985119,
    "files": {
        "pdf": "https://archive.orkl.eu/b36210fbdd48447cc39ec77e317f1f3ec43b8ae6.pdf",
        "text": "https://archive.orkl.eu/b36210fbdd48447cc39ec77e317f1f3ec43b8ae6.txt",
        "img": "https://archive.orkl.eu/b36210fbdd48447cc39ec77e317f1f3ec43b8ae6.jpg"
    }
}