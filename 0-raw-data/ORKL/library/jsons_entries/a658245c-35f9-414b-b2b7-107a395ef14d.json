{
    "id": "a658245c-35f9-414b-b2b7-107a395ef14d",
    "created_at": "2023-01-12T15:04:10.851644Z",
    "updated_at": "2025-03-27T02:16:21.021575Z",
    "deleted_at": null,
    "sha1_hash": "ceb4a205e7724d0e27796c7ca02b08fd7fb10526",
    "title": "2022-08-12 - The Swan Song for Driver Signature Enforcement Tampering",
    "authors": "",
    "file_creation_date": "2022-09-01T10:22:41Z",
    "file_modification_date": "2022-09-01T10:22:41Z",
    "file_size": 290341,
    "plain_text": "# The Swan Song for Driver Signature Enforcement Tampering\n\n**[fortinet.com/blog/threat-research/driver-signature-enforcement-tampering](https://www.fortinet.com/blog/threat-research/driver-signature-enforcement-tampering)**\n\n## Preface\n\n\nAugust 12, 2022\n\n\nCode Integrity is a threat protection feature first introduced by Microsoft over 15 years ago.\nOn x64-based versions of Windows, kernel-mode drivers must be digitally signed and\nchecked each time they are loaded into memory. This is also referred to as Driver Signature\nEnforcement (DSE). Detecting whether an unsigned driver or system file is being loaded into\nthe kernel, or whether a system file has been modified, possibly by malicious software that\nruns with administrative permissions, improves the security of the operating system.\n\nTo overcome these restrictions, attackers use valid digital certificates, either issued to them\nor stolen, or they disable DSE during runtime. Obtaining a certificate is primarily a logistical\nobstacle but tampering, on the other hand, is purely a technical challenge.\n\n\n-----\n\nDespite the efforts Microsoft dedicated to address this issue in recent years and the range of\nsolutions provided by them, there’s been a clear increase in cases of attacks leveraging the\nwell-known DSE tampering method. This motivated us to look deeper into the issue.\n\nIn this blog, we share the results of our research - details of two more methods for DSE\ntampering and how defenders might cope with this matter as long as this attack surface\nhasn't been eliminated.\n\n## DSE Implementation\n\n[An old blog post by j00ru, a security researcher from Google’s Project Zero, provides a high-](https://j00ru.vexillium.org/2010/06/insight-into-the-driver-signature-enforcement/)\nlevel overview of Code Integrity implementation in Windows 7.\n\nntoskrnl.exe works with an additional kernel library, CI.dll (Code Integrity). At the operating\nsystem initialization phase, the kernel sets nt!g_CiEnabled and invokes CI!CiInitialize routine\nwith a pointer to the nt!g_CiCallbacks structure to initialize CI.dll. It, in turn, sets\nCI!g_CiOptions and fills the addresses of CI!CiValidateImageHeader,\nCI!CiValidateImageData, and CI!CiQueryInformation callbacks before returning to the kernel.\n\nTo use the callbacks, wrapper functions exist for each of them in ntoskrnl.exe. They check\nthat nt!g_CiEnabled is set to TRUE, that the appropriate callback is not NULL, and then call\nit.\n\nWhen the kernel loads a driver, execution goes through nt!MmLoadSystemImage to\nnt!MmCreateSection and eventually to the nt!MiValidateImageHeader routine. From there,\nthe nt!SeValidateImageHeader and nt!SeValidateImageData wrappers are invoked in order.\nEach callback is expected to return zero on success or a non-zero value otherwise.\n\nFigure 1: Call stack on driver load\n\nThe book “Rootkits and Bootkits: Reversing Modern Malware and Next Generation Threats”\n[(pages 76-78) covers implementation changes in Windows 8: the nt!g_CiEnabled variable](https://books.google.co.il/books?id=NVv6DwAAQBAJ&lpg=PP1&dq=Rootkits+and+Bootkits:+Reversing+Modern+Malware+and+Next+Generation+Threats&pg=PA76&redir_esc=y#v=onepage&q&f=false)\nwas removed, so the DSE state is determined solely by CI!g_CiOptions, and more callbacks\nwere added to the interface that CI.dll supplies. Another change not described in the book is\nthat if the validate header succeeds, then validate data callback will not be called.\n\nOn Windows 8.1, the symbol name of the callbacks structure was changed to\nnt!SeCiCallbacks.\n\n### Kernel-Mode Signing Policy\n\nExcept for the cryptographic validity of the signature, Microsoft enforces that signing\n[certificates can only be issued by cross-certificate supporting CAs. This thwarts attackers](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/cross-certificates-for-kernel-mode-code-signing#cross-certificates-overview)\nfrom simply installing their own CA certificate on every machine.\n\n\n-----\n\nBeginning with Windows 10 Redstone (August 2016), the driver signing policy changed,\nrequiring a second signature by Microsoft itself. This is done via a web portal where\ndevelopers upload their signed binaries to send them to Microsoft. From an attacker’s\nperspective, this means simply handing out your payload to the defenders, which is the\n[opposite of what they usually want. There is at least one documented case where this new](https://www.gdatasoftware.com/blog/microsoft-signed-a-malicious-netfilter-rootkit)\nmeasure didn’t stop a threat actor.\n\n### Kernel Patch Protection\n\nKPP, or PatchGuard, first introduced in 2005, is a feature of x64 editions of Windows that\nprevents patching the kernel. \"Patching the kernel\" refers to modifying the code of\nntoskrnl.exe and other critical system drivers and data structures (SSDT, IDT, GDT, etc.).\n\nIt works by periodically checking that these protected areas have not been modified. A\nBSOD will be triggered if a modification is detected, essentially stopping the system.\nPatchGuard is updated with each new Windows release, making it very difficult for attackers\nto develop a universal bypass technique for all versions.\n\nThe callbacks structure in ntoskrnl.exe and the CI!g_CiOptions variable are protected by\nPatchGuard starting with Windows 8 and 8.1, respectively.\n\n## DSE Tampering in the Wild\n\nThough j00ru concluded that overwriting private symbols like nt!g_CiEnabled or\nCI!g_CiOptions might be relatively hard, this was the exact direction attackers chose to go.\nThe infamous Turla APT is known to have developed such a technique, and security\nresearchers reverse-engineered and published their code for it.\n\nThese private symbols are located by simple pattern matching, with hardly any changes\nbetween all Windows versions. Attackers overwrite the flags and quickly proceed to load\ntheir unsigned drivers. Once the loading procedure is finished, they restore the flags to their\noriginal state. Restrictions that PatchGuard imposes don’t prevent these momentary\nchanges, and as they are short-lived, the odds are they won’t be detected either.\n\nThe common practice for attackers to get a write primitive is by leveraging 3 -party driversrd\nwith vulnerabilities (or just poorly written code) that break security boundaries between the\nuser and the kernel-mode code. Attackers usually bring such a driver with them rather than\nrelying on one to be found running on the target machine. The considered tradeoff is first\ngetting administrative privileges in user-mode and, in return, having a portable and\nsustainable capability even after patching.\n\n## Microsoft’s Solutions\n\nIn light of this critical attack path, Microsoft tackled the problem in three ways:\n\n\n-----\n\n1. Reducing the attack vector - an immediate solution using driver blocklist to make it\n\nharder to gain the write primitive.\n2. Reducing the attack surface - an intermediate solution to prevent changes to\n\nCI!g_CiOptions variable using Kernel Data Protection.\n3. Eliminating the attack surface - a long-term solution to prevent any code from running\n\nin the kernel without first being validated by HyperVisor-protected Code Integrity\n(HVCI).\n\n### Virtualization-based Security\n\nVBS uses hardware virtualization features to create and isolate a secure region of memory\nfrom the normal operating system. Windows can use this \"virtual secure mode\" to host a\nnumber of security solutions, providing them with significantly increased protection from\nvulnerabilities in the operating system and preventing the use of malicious exploits that\nattempt to defeat protections. This architecture was first introduced in the initial Windows 10\nrelease.\n\nIn VBS environments, privileges are set according to Virtual Trust Levels (VTLs). The normal\nNT kernel runs in a virtualized environment, called VTL0, while the secure kernel runs in an\nenvironment called VTL1.\n\nVirtual memory management uses the Secondary Layer Address Translation (SLAT) page\ntables. The processor translates an initial virtual address, called Guest Virtual Address\n(GVA), to an intermediate physical address, called Guest Physical Address (GPA). This\ntranslation is still managed by the Guest OS page tables. The intermediate physical address\nneeds to be translated by the processor to a Machine Physical Address, also known as a\nHost Physical Address (HPA) or System Physical Address (SPA), with the SLAT page tables\nthe hypervisor maintains.\n\nFigure 2: Regular PTE along SLAT PTE highlighted differences\n\nOn x86 architecture, SLAT PTEs (Page Table Entries) handle permissions differently from\nregular PTEs: read\\write permissions are separate, execute permission needs to be explicitly\nset, and can be granted only for ring 0 (kernel-mode). The hypervisor uses SLAT page tables\nto enforce the isolation between VTLs and have them accessible for VTL1, so the secure\nkernel uses them to implement VBS features, while the hypervisor itself doesn’t implement\nany code/logic for the features themselves.\n\n### HyperVisor-protected Code Integrity\n\nHVCI, originally called Device Guard, was released with the introduction of VBS. It is another\nlayer of integrity enforcement.\n\n\n-----\n\nUpon loading a new driver, the secure kernel is also triggered and uses its own instance of\ncode integrity library, SKCI.dll (Secure Kernel Code Integrity). The digital signature is\nvalidated and checked to be authorized within the current policy in the Secure World (VTL1).\nOnly then are executable and non-writable permissions applied to the SLAT page table for\nthe corresponding GPAs. As a result, the NT kernel (VTL0) can't modify any previously\nloaded code or run any new code without using the secure kernel in the process.\n\nFigure 3: Disassembly of SkciInialize and its own CiOptions variable in SKCI.dll from\nWindows 10\n\n### Kernel Data Protection\n\nKDP is intended to protect drivers and software running in the Windows kernel (i.e., the OS\n[code itself) against data-driven attacks. It was first introduced in Windows 10 20H1.](https://www.microsoft.com/security/blog/2020/07/08/introducing-kernel-data-protection-a-new-platform-security-technology-for-preventing-data-corruption/)\n\nWith KDP, software running in kernel-mode can protect read-only memory statically (a\nsection of its own image) or dynamically (pool memory that can be initialized only once).\nKDP only establishes write protections in VTL1 for the GPAs backing a protected memory\nregion using the SLAT page tables for the hypervisor to enforce. This way, no software\nrunning in the NT kernel (VTL0) can have the permissions needed to change the memory.\n\nKDP does not enforce how the GVA range mapping of a protected region is translated.\nBased on the developer’s blog, KDP currently only periodically verifies that protected\nmemory regions translate to the appropriate GPA.\n\nStarting with Windows 11, CI.dll was opted to harden itself using static KDP\n(MmProtectDriverSection API), having all relevant CI policy variables placed in a separate\nsection named “CiPolicy”.\n\nFigure 4: Disassembly of CiInitializePolicy and CiPolicy section in CI.dll from Windows 11\n\n### Drivers Blocklist\n\nThis is enforced via Windows Defender Application Control (WDAC) or HVCI policy.\nAccording to several publications several third-party security product vendors have also\n[adopted this practice. The latest blocklist can be found here.](https://github.com/MicrosoftDocs/windows-itpro-docs/blob/public/windows/security/threat-protection/windows-defender-application-control/microsoft-recommended-driver-block-rules.md)\n\nBlocklisting denies easy access to a kernel write primitive for attackers. Although it’s quite\neffective, it is not a proactive measure – only previously discovered drivers can be handled.\nHence, this mitigation is ineffective against zero-day vulnerabilities in drivers, and defenders\nmust continuously chase after them, always remaining one step behind the attackers.\n\n## New Tradecraft\n\n\n-----\n\nFrom the description above, a keen reader could see that without HVCI enabled, it might be\npossible to tamper with DSE without any code patching.\n\n**Method I - “Page Swapping”**\n\nJust because writing to CI!CiOptions is no longer possible doesn't mean its value can’t\nchange. The variable is still being accessed by a virtual address and the translation process\nto a physical address takes place each time. So, we’ll change the translation result instead.\n\nBy swapping the physical pages from a KDP-protected page to one we own, we regain\ncomplete control over the memory. Swapping a GPA merely means changing the PFN (Page\nFrame Number) in the PTE (Page Table Entry), which essentially is just another pointer.\n\nWe can calculate the virtual address of the PTE for any given virtual address and avoid\ntraversing all the page tables each time. The page tables reside in a region of virtual memory\n[that the Windows Kernel uses to manage the paging structures, called “PTE Space”. PTE](https://www.reactos.org/wiki/Techwiki:Memory_Layout#AMD64)\nBase is randomized by KASLR (Kernel Address Space Layout Randomization), starting with\n[Windows 10 Redstone. In previous research, we showed a reliable method to find it.](https://web.archive.org/web/20191028184211/https:/cdn2.hubspot.net/hubfs/487909/Turning%20(Page)%20Tables_Slides.pdf)\n\nPerforming this method requires kernel read and memory allocation primitives in addition to\nwrite. The following is a step-by-step implementation in C pseudocode:\n\nFigure 5: C pseudocode for Page Swapping.\n\nIt’s possible to use a page from user-space and so a kernel memory allocation primitive\nbecomes redundant. In the case of CI.dll, it’s possible to use the default values of the\nvariables rather than copying the page. As a result, the number of reads from kernel space is\nsignificantly minimized as only the handful of necessary reads of PTEs are left.\n\n**Method II - “Callback Swapping”**\n\nFor a moment, it looked like KDP raised the bar against DSE tampering since Page\nSwapping also requires a kernel read primitive. We looked again at how CI.dll and\nntoskrnl.exe integrate, and then we thought, “why even get to a point CI.dll is used? Let’s just\nhave our own callback instead of CI!CiValidateImageHeader”.\n\nFigure 6: Illustration of Callback Swapping concept\n\nOur PoC demonstrates that finding all the necessary addresses is feasible without reading\nany kernel space data. The general details follow:\n\nFirst, locate the callback structure in ntoskrnl.exe. The structure is passed as a parameter to\nCI!CiInitialize, so we can obtain its address from that call. The kernel calls the function only\nonce, so we look for a CALL or JMP instruction that uses its import table entry. Once you find\n\n\n-----\n\nthe call site, walk back to an assignment of register for a parameter pointing to uninitialized\nmemory in the “.data” section.\n\nFigure 7: Disassembly of SepInitializeCodeIntegrity and SeCiCallbacks in ntoskrnl.exe from\nWindows 11\n\nNext, look for a replacement callback function to use. We need a function that does not take\nparameters and returns zero. Fortunately, ntoskrnl.exe has a few exported functions that fit\nthis bill, like FsRtlSyncVolumes or ZwFlushInstructionCache, so a simple call to\nGetProcAddress takes care of that.\n\nLastly, find the original callback function(s) to be restored. The callbacks are set in the\nstructure by CI!CipInitialize, so it will have references to all of them. All the callbacks are set\nin a single basic block of code across all Windows builds. Search for this pattern of\ninstructions, seen in figure 8, and extract the offsets from the lea instructions. To validate that\nthe offsets actually lead to functions, traverse the PE’s Exception Directory to look for a\nRUNTIME_FUNCTION entry with the same start address.\n\nFigure 8: Disassembly of CipInitialize in CI.dll from Windows 11\n\nKDP protection is bypassed “by design” as ntoskrnl.exe hasn’t opted in with the callbacks\nstructure. Another advantage to changing the callbacks is that the tampering is not visible\nthrough the [documented query system information API.](https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation#systemcodeintegrityinformation)\n\nWhile resolving the addresses might take a few more lines of code, it is done in userspace,\nso only a kernel write primitive is required - the same as in the current well-known DSE\ntampering method. Although PoC has writes of 8 bytes (size of a 64-bit pointer) to kernelspace, this number can be reduced by looking for callback targets in CI.dll instead. While\npreparing this blog, Adam Chester from TrustedSec [released his work on the subject, where](https://www.trustedsec.com/blog/g_cioptions-in-a-virtualized-world/)\nhe chose an alternative approach to finding the original callback by scanning for a binary\nsignature he created.\n\n## Conclusion\n\n### Mitigation\n\nHVCI covers all tampering methods as it performs its own validation when a driver is being\nloaded. Despite HVCI being available for many years now, it has been turned on by default\non new Windows installations only recently. With this understanding, we tried to come up\nwith an alternative.\n\nWe tried to find a way to confirm the state of DSE during driver loading. Moreover, one that\nwill support blocking of the procedure. How to get visibility of the state of DSE should be\nevident at this point - defenders can just leverage the same strategies attackers use to find\n\n\n-----\n\nthe internal variables. After all, it has proven to be stable.\n\nConsidering that a tampered state can only last for short moments, assuming the system\nstate is valid when we start running is sound. At this point, a copy of the internal variables will\nbe kept.\n\nThere are a few options to intercept driver loading:\n\n1. Place a hook in userspace on NtLoadDriver API.\n2. Use registry callbacks to monitor operations on a driver’s registry key path.\n3. Use file system minifilter callback for creation of section for a driver’s file\n\n(IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION).\n\nTo know if a callback is triggered as part of driver loading, it needs to check that the current\nprocess is SYSTEM and the call stack originated from ntoskrnl.exe and not any other driver.\n\nOnce driver loading is intercepted, DSE tampering is detected by checking any variables for\nchanges. At this point, prevention could be done simply by blocking the I\\O request with an\nerror status code or restoring the variables to their saved state.\n\n### Final Thoughts\n\nIn this blog, we covered how Microsoft attempts to protect DSE on runtime and presented\ntwo new methods to tamper with it and successfully load unsigned drivers.\n\nWhile HVCI provides the utmost robust solution, we shared an additional approach to detect\nand protect against DSE tampering on runtime. Using the same premises as attackers can\npan out to be more successful than the rest of the existing protections.\n\nExecuting code in kernel mode will remain attractive for attackers as it’s usually a\nsteppingstone to compromising higher privileged elements on the machine, such as the\nhypervisor, UEFI, and SMM, or beating endpoint security products. It’s possible that we might\nsee a shift in TTPs, where attackers move to use more kernel 1-day exploits for unpatched\nvulnerabilities due to driver blocklisting.\n\nAs hardware-assisted security capabilities become more common, along with the efforts\nMicrosoft dedicates to utilizing them, leveraging DSE tampering by threat actors will likely\nfade out in the foreseeable future. Nevertheless, misconfigured and legacy systems will\nremain to a degree, so this avenue of attack won’t be made entirely obsolete. Therefore, we\nurge defenders to adopt the proposed solution in this blog.\n\n### Fortinet Solutions\n\n\n-----\n\nFortiEDR detects and blocks these methods out-of-the-box without any prior knowledge or\nspecial configuration using its post-execution prevention engine to identify malicious\nactivities, as seen in figure 9.\n\nFigure 9: FortiEDR blocks driver loading when DSE was tampered with.\n\n### Appendix A: Additional References\n\n_[Learn more about Fortinet’s FortiGuard Labs threat research and intelligence organization](https://www.fortinet.com/fortiguard/labs?utm_source=blog&utm_campaign=fortiguard-labs)_\n_[and the FortiGuard Security Subscriptions and Services portfolio.](https://www.fortinet.com/fortiguard/labs?tab=security-bundles&utm_source=blog&utm_campaign=security-bundles)_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-12 - The Swan Song for Driver Signature Enforcement Tampering.pdf"
    ],
    "report_names": [
        "2022-08-12 - The Swan Song for Driver Signature Enforcement Tampering.pdf"
    ],
    "threat_actors": [
        {
            "id": "a97cf06d-c2e2-4771-99a2-c9dee0d6a0ac",
            "created_at": "2022-10-25T16:07:24.349252Z",
            "updated_at": "2025-03-27T02:02:10.184406Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "ATK 13",
                "Belugasturgeon",
                "Blue Python",
                "CTG-8875",
                "Group 88",
                "ITG12",
                "Iron Hunter",
                "Krypton",
                "Makersmark",
                "Operation Epic Turla",
                "Operation Moonlight Maze",
                "Operation Penguin Turla",
                "Operation Satellite Turla",
                "Operation Skipper Turla",
                "Operation Turla Mosquito",
                "Operation WITCHCOVEN",
                "Pacifier APT",
                "Pensive Ursa",
                "Popeye",
                "SIG15",
                "SIG2",
                "SIG23",
                "Secret Blizzard",
                "TAG-0530",
                "Turla",
                "UNC4210",
                "Venomous Bear",
                "Waterbug"
            ],
            "source_name": "ETDA:Turla",
            "tools": [
                "ASPXSpy",
                "ASPXTool",
                "ATI-Agent",
                "AdobeARM",
                "Agent.BTZ",
                "Agent.DNE",
                "BigBoss",
                "COMpfun",
                "Chinch",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobra Carbon System",
                "ComRAT",
                "DoublePulsar",
                "EmPyre",
                "EmpireProject",
                "Epic Turla",
                "EternalBlue",
                "EternalRomance",
                "GoldenSky",
                "Group Policy Results Tool",
                "HTML5 Encoding",
                "HyperStack",
                "IcedCoffee",
                "IronNetInjector",
                "KSL0T",
                "Kapushka",
                "Kazuar",
                "KopiLuwak",
                "Kotel",
                "LOLBAS",
                "LOLBins",
                "LightNeuron",
                "Living off the Land",
                "Maintools.js",
                "Metasploit",
                "Meterpreter",
                "MiamiBeach",
                "Mimikatz",
                "MiniDionis",
                "Minit",
                "NBTscan",
                "NETTRANS",
                "NETVulture",
                "Neptun",
                "NetFlash",
                "NewPass",
                "Outlook Backdoor",
                "Penquin Turla",
                "Pfinet",
                "PowerShell Empire",
                "PowerShellRunner",
                "PowerShellRunner-based RPC backdoor",
                "PowerStallion",
                "PsExec",
                "PyFlash",
                "QUIETCANARY",
                "Reductor RAT",
                "RocketMan",
                "SMBTouch",
                "SScan",
                "Satellite Turla",
                "SilentMoon",
                "Sun rootkit",
                "TTNG",
                "TadjMakhal",
                "Tavdig",
                "TinyTurla",
                "TinyTurla Next Generation",
                "TinyTurla-NG",
                "Topinambour",
                "Tunnus",
                "Turla",
                "Turla SilentMoon",
                "TurlaChopper",
                "Uroburos",
                "Urouros",
                "WCE",
                "WITCHCOVEN",
                "WhiteAtlas",
                "WhiteBear",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "Wipbot",
                "WorldCupSec",
                "XTRANS",
                "certutil",
                "certutil.exe",
                "gpresult",
                "nbtscan",
                "nbtstat",
                "pwdump"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "8aaa5515-92dd-448d-bb20-3a253f4f8854",
            "created_at": "2024-06-19T02:03:08.147099Z",
            "updated_at": "2025-03-27T02:05:17.408118Z",
            "deleted_at": null,
            "main_name": "IRON HUNTER",
            "aliases": [
                "Belugasturgeon ",
                "Blue Python ",
                "CTG-8875 ",
                "ITG12 ",
                "KRYPTON ",
                "MAKERSMARK ",
                "Pensive Ursa ",
                "Secret Blizzard ",
                "Turla",
                "UAC-0003 ",
                "UAC-0024 ",
                "UNC4210 ",
                "Venomous Bear ",
                "Waterbug ",
                "ATK13 "
            ],
            "source_name": "Secureworks:IRON HUNTER",
            "tools": [
                " ComRAT",
                " Kazuar",
                " KopiLuwak",
                " LightNeuron",
                " Mosquito",
                " Nautilus",
                " Neuron",
                " Penquin",
                " PoisonFrog",
                " PyFlash",
                " Skipper",
                " Snake",
                " Tavdig",
                " TinyTurla",
                " Tunnus",
                "Carbon-DLL"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a97fee0d-af4b-4661-ae17-858925438fc4",
            "created_at": "2023-01-06T13:46:38.396415Z",
            "updated_at": "2025-03-27T02:00:02.823045Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Uroburos",
                "Hippo Team",
                "Pacifier APT",
                "MAKERSMARK",
                "ATK13",
                "UAC-0003",
                "IRON HUNTER",
                "Waterbug",
                "TAG_0530",
                "KRYPTON",
                "Popeye",
                "SIG23",
                "UAC-0144",
                "G0010",
                "Blue Python",
                "VENOMOUS Bear",
                "Group 88",
                "Pfinet",
                "ITG12",
                "UNC4210",
                "Secret Blizzard",
                "UAC-0024"
            ],
            "source_name": "MISPGALAXY:Turla",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d11c89bb-1640-45fa-8322-6f4e4053d7f3",
            "created_at": "2022-10-25T15:50:23.509601Z",
            "updated_at": "2025-03-27T02:00:55.487991Z",
            "deleted_at": null,
            "main_name": "Turla",
            "aliases": [
                "Turla",
                "IRON HUNTER",
                "Group 88",
                "Waterbug",
                "WhiteBear",
                "Krypton",
                "Venomous Bear",
                "Secret Blizzard",
                "BELUGASTURGEON"
            ],
            "source_name": "MITRE:Turla",
            "tools": [
                "PsExec",
                "nbtstat",
                "ComRAT",
                "netstat",
                "certutil",
                "KOPILUWAK",
                "IronNetInjector",
                "LunarWeb",
                "Arp",
                "Uroburos",
                "PowerStallion",
                "Kazuar",
                "Systeminfo",
                "LightNeuron",
                "Mimikatz",
                "Tasklist",
                "LunarMail",
                "HyperStack",
                "NBTscan",
                "TinyTurla",
                "Penquin",
                "LunarLoader"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535850,
    "ts_updated_at": 1743041781,
    "ts_creation_date": 1662027761,
    "ts_modification_date": 1662027761,
    "files": {
        "pdf": "https://archive.orkl.eu/ceb4a205e7724d0e27796c7ca02b08fd7fb10526.pdf",
        "text": "https://archive.orkl.eu/ceb4a205e7724d0e27796c7ca02b08fd7fb10526.txt",
        "img": "https://archive.orkl.eu/ceb4a205e7724d0e27796c7ca02b08fd7fb10526.jpg"
    }
}