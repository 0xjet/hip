{
    "id": "d4ca41fa-835d-43fd-89fe-8c8a060fa0ea",
    "created_at": "2023-01-12T15:08:08.364765Z",
    "updated_at": "2025-03-27T02:05:52.419329Z",
    "deleted_at": null,
    "sha1_hash": "0b9998f65791d50e3c90b77def69898ab505c319",
    "title": "2021-05-23 - MountLocker Ransomware",
    "authors": "",
    "file_creation_date": "2022-05-27T23:23:55Z",
    "file_modification_date": "2022-05-27T23:23:55Z",
    "file_size": 1784124,
    "plain_text": "# MountLocker Ransomware\n\n**[chuongdong.com/reverse engineering/2021/05/23/MountLockerRansomware/](https://chuongdong.com/reverse%20engineering/2021/05/23/MountLockerRansomware/)**\n\nChuong Dong May 23, 2021\n\n[Reverse Engineering · 23 May 2021](https://chuongdong.com/categories/#reverse%20engineering)\n\n## Overview\n\nThis is my report for a MountLocker Ransomware v5.0 sample, which is used by XingLocker\nransomware group.\n\nThis ransomware uses a hybrid-cryptography scheme of RSA-2048 and ChaCha20 to encrypt files and\nprotect its keys. Unlike other ransomware, MountLocker encrypts all of the ChaCha20 keys with a global\n**ChaCha20 key before encrypting this global key with its RSA-2048 public key. The encrypted global key**\nand the corresponding encrypted ChaCha20 key are appended at the end of each encrypted file.\n\nThis version includes a new worm feature that lets it self-propagate to other PCs on the network using\n**IDirectorySearch and IWbemServices COM interfaces.**\n\n**MountLocker has a sophisticated multithreading scheme, but its performance suffers from thread**\nstarvation due to recursive file traversal.\n\nI won’t waste my time explaining why recursive file traversal is terrible anymore cause I have made my\n[points through the last few reports. Please feel free to check out my Darkside analysis if you want to](https://chuongdong.com/reverse%20engineering/2021/05/06/DarksideRansomware/)\nbetter understand the theory behind it!\n\n\n-----\n\n_Figure 1: XingLocker Ransomware leak site._\n\n## IOCS\n\nThis v5.0 sample is a 64-bit .exe file.\n\n**MD5: 3808f21e56dede99bc914d90aeabe47a**\n\n**SHA256: 4a5ac3c6f8383cc33c795804ba5f7f5553c029bbb4a6d28f1e4d8fb5107902c1**\n\n**Sample:**\nhttps://bazaar.abuse.ch/sample/4a5ac3c6f8383cc33c795804ba5f7f5553c029bbb4a6d28f1e4d8fb5107902c1/\n\n\n-----\n\n_Figure 2: VirusTotal information._\n\n## Ransom Note\n\nThe ransom note is written in HTML format and is dropped into RecoveryManual.html files on the\nsystem.\n\nThe client ID embedded inside the ransom note is generated from the victim’s computer name and a\nhard-coded string in memory.\n\n\n-----\n\n_Figure 3: MountLocker ransom note._\n\n## Performance\n\n**MountLocker has pretty average performance and does not fully utitlize the machine’s processing power.**\n\n_Figure 4: ANY.RUN sandbox result._\n\n## Static Code Analysis\n\n\n-----\n\n### Command Line Parameters\n\n**MountLocker can be ran with or without command line parameters. The ransomware first checks and**\nparse the given parameters to modify its functionalities accordingly.\n\n_Figure 5: Parsing command line parameters._\n\nBelow is the list of arguments that can be supplied by the operators:\n\n**Argument** **Description**\n\n/LOGIN= Network username (for network encryption and worm)\n\n/PASSWORD= Network password (for network encryption and worm)\n\n/CONSOLE Logging through console\n\n/NODEL No self-deletion\n\n/NOKILL No service and process killing\n\n/NOLOG No logging through file (this is hard-coded to be FALSE in this sample)\n\n/SHAREALL Encrypting all shared resources (except ”\\ADMIN$”)\n\n/NETWORK **Worm network type:**\n\n        - w = Windows Management Instrumentation (WMI)\n\n         - s = service (requires ADMIN creds)\n\n         - others = unknown or default\n\n/PARAMS= Command line parameters to launch executable with on other PCs (worm)\n\n\n-----\n\n**Argument** **Description**\n\n/TARGET= Path to a file or a directory to be encrypted specifically\n_There can be multiple target arguments_\n\n/FAST= Buffer size for fast encryption (default: 0x10000000 bytes)\n\n/MIN= Minimum file size to encrypt (default: 0 bytes)\n\n/MAX= Maximum file size to encrypt (default: 0 bytes)\n\n/FULLPD Does not avoid encrypting Program Files, Program Files (x86)\n**ProgramData, and SQL**\n\n/MARKER= Marker file name to drop in each encrypted drive\n\n/NOLOCK= **Avoid encrypting:**\n\n          - L: Local\n\n         - N: Network\n\n         - S: Network shared resources\n\n### Logging\n\nThe ransomware has two different ways to log its operations, and each can be enabled through setting\nthe command line arguments /CONSOLE to 1 and /NOLOG to 0.\n\nIn this particular sample, /NOLOG flag’s value is hard-coded to be 0, so it always records and drops a log\nfile on the victim’s system.\n\nWhen the /NOLOG flag is 0, MountLocker extracts the current executable’s file path, append .log to the\nend, and use that as the log file path.\n\n_Figure 6: Creating log file in current directory._\n\nWhen the /CONSOLE flag is 1, MountLocker will also log through console standard output stream. It\ncalls AllocConsole and GetStdHandle(STD_OUTPUT_HANDLE) to allocate the console and get a\nhandle to the standard output stream.\n\nTo write to this console, it calls WriteConsoleW with this handle.\n\n\n-----\n\n_Figure 7: Creating log file in current directory._\n\nThe beginning of the log tells us the version of the specific MountLocker sample, and in this case, the\nversion is 5.0.\n\nIt also extracts and records information about the victim’s system such as the number of processors, total\nsystem memory, Windows version, system architecture, …\n\n_Figure 8: Logging system information._\n\nAll file and network operations (enumeration, skipping, encrypting, error) are recorded this way.\n\n\n-----\n\n_Figure 9: MountLocker log file._\n\n### Terminating Services\n\nIf the /NETWORK argument is not provided, the malware will run in local mode.\n\nIn this mode, if the /NOKILL argument is 0, it enumerates and kills all services with these strings in their\nname.\n```\n\"SQL\", \"database\", \"msexchange\"\n\n```\nFirst, it calls OpenSCManagerA to obtain a handle to the service control manager and calls\n**EnumServicesStatusA to enumerate all Win32 services with status SERVICE_ACTIVE.**\n\n\n-----\n\n_Figure 10: Enumerating through all active services._\n\nIf a service contains any of the three strings above, MountLocker will terminate it by calling\n**OpenServiceA to obtain a service control handle and calling ControlService to send a control stop**\ncode. It then continuously loops until the service’s state is SERVICE_CONTROL_STOP to make sure the\nservice is fully terminated.\n\n_Figure 11: Sending control stop code to terminate service._\n\n### Terminating Processes\n\nIf it’s running in local mode and the /NOKILL argument is 0, MountLocker will enumerate and kill all\nprocesses with these strings in their name.\n\n\n-----\n\n```\n s tesq e e, sq age t e e, sq b o se e e, sq te e e, o ac e e e, ocssd e e,\n\"dbsnmp.exe\", \"synctime.exe\", \"agntsvc.exe\", \"isqlplussvc.exe\", \"xfssvccon.exe\", \"sqlservr.exe\", \n\"mydesktopservice.exe\", \"ocautoupds.exe\", \"encsvc.exe\", \"firefoxconfig.exe\", \"tbirdconfig.exe\", \n\"mydesktopqos.exe\", \"ocomm.exe\", \"mysqld.exe\", \"mysqld-nt.exe\", \"mysqld-opt.exe\", \"dbeng50.exe\", \n\"sqbcoreservice.exe\", \"excel.exe\", \"infopath.exe\", \"msaccess.exe\", \"mspub.exe\", \"onenote.exe\", \n\"outlook.exe\", \"powerpnt.exe\", \"sqlservr.exe\", \"thebat.exe\", \"steam.exe\", \"thebat64.exe\",\n\"thunderbird.exe\", \n\"visio.exe\", \"winword.exe\", \"wordpad.exe\", \"QBW32.exe\", \"QBW64.exe\", \"ipython.exe\",\n\"wpython.exe\", \n\"python.exe\", \"dumpcap.exe\", \"procmon.exe\", \"procmon64.exe\", \"procexp.exe\", \"procexp64.exe\"\n\n```\nThe ransomware first calls ZwQuerySystemInformation with the information class of\n_SystemProcessInformation to get an array of SYSTEM_PROCESS_INFORMATION structures. It_\nenumerates through each running process, avoids its own process, and starts terminating processes in\nthe kill list.\n\n_Figure 12: Enumerating through all active processes._\n\nTo check and kill a process, it loops through the PROCESS_TO_KILL list and compares the process\nname. If the process name is in the list, it calls OpenProcess to get the handle of that process and\nterminates it using TerminateProcess.\n\n\n-----\n\n_Figure 13: Terminating processes that are in the kill list._\n\n### Generating Global ChaCha20 Key\n\nNext, it randomly generates the global ChaCha20 key. The randomization is done through calling the\n**rdtsc instruction to get the processor time stamp and xoring its least significant byte to generate each**\nbyte in the key.\n\nAfter generating the global key, the ransomware copies the key to another global buffer in memory and\nencrypts this new buffer using the hard-coded RSA-2048 key.\n\n\n-----\n\n_Figure 14: Randomly generate global ChaCha20 key and encrypt it with RSA-2048._\n\n**MountLocker later uses this global ChaCha20 key to encrypt and protect its ChaCha20 keys instead of**\nusing RSA-2048. Since RSA-2048 encryption is only performed once, there is some performance\nadvantage with this hybrid-cryptography scheme since RSA is quite slow compared to ChaCha20.\n\n### Encryption\n\n**Creating Encrypting Threads**\n\nDespite having different schemes for different drive types and targets, the encryption functionality is pretty\nmuch the same.\n\n**MountLocker has a specific function that takes in a drive/file name to encrypt and a function to**\nenumerate through it as parameters.\n\nThis function first passes the enumerating function and the target name to a custom structure before\nspawning a thread to begin the encryption.\n\nThis thread acts as the main thread in the encryption, which recursively enumerates and provides files for\nchildren threads to encrypt.\n\n\n-----\n\n_Figure 15: Spawning main thread._\n\nThe main thread function calls CreateEventA to create an event handler for each child thread to later\nsend them file information through calling SetEvent.\n\nOnly 2 children worker threads are spawned, and these threads loops and waits to receive files from the\nmain thread to encrypt. The main thread will begin feeding them files by calling the enumeration function\nin the custom structure above and enumerating through the target folder.\n\n\n-----\n\n_Figure 16: Main thread spawning children threads and starting file enumeration._\n\n**Children Worker Threads**\n\nOnce spawned, each worker thread receives a shared structure with the main thread, and it constantly\nloops to check for the encrypt signal is 1 in this shared structure.\n\nDue to synchronization through sharing a common structure among threads, the child thread calls\n**_InterlockedExchange to atomically extract the encrypt signal to check if it’s allowed to encrypt.**\n\nAs it finds files to encrypt, the main thread adds the file name to the shared structure and sets the encrypt\nsignal for the child thread to process that file.\n\n_Figure 17: Child thread waiting for encrypt signal to encrypt files._\n\nAfter receiving the file information, the worker thread creates a structure to store file information such as\nfilename, encrypted filename, file handle, file size, …\n\nIt will then checks to see if it has priviledge to open the file and retrieve the file size.\n\n\n-----\n\n_Figure 18: Checking if file can be opened._\n\nNext, it randomly generates the file’s ChaCha20 key and appends it to the file structure above. The\nrandomization is done through calling the rdtsc instruction similar to the global ChaCha20 key\ngeneration.\n\n_Figure 19: Randomly generating ChaCha20 key for each file._\n\nAfter generating the ChaCha20 file key, the worker thread creates a 313-byte buffer that stores the file\nmarker string “lock2” in little endian, the fast encryption size, the encrypted ChaCha20 global key, and\nthe encrypted ChaCha20 file key. This buffer is appended at the end of the to-be-encrypted file.\n\n\n-----\n\n_Figure 20: Generating key buffer and writing it at the end of the file._\n\nHere is the layout of the key buffer at the end of an encrypted file.\n\n_Figure 21: Key buffer layout._\n\nFile encryption is pretty standard. The worker thread encrypts a 0x100000-byte chunk at a time until it has\nencrypted FAST_CRYPT_SIZE bytes or ran out of bytes to encrypt.\n\nIt uses ReadFile to read file content into a buffer, encrypts it using the ChaCha20 file key, and writes it\nback using WriteFile. Because encryption is performed on the same file, SetFilePointerEx is called to\nadjust the file pointer after reading and writing.\n\n_Figure 22: ChaCha20 File Encryption._\n\nI won’t analyze the ChaCha20 function cause MountLocker basically just uses this CRYPTOGAMS\nlibrary by OpenSSL.\n\n\n-----\n\n**Main Thread Enumeration**\n\n**MountLocker uses the same function for file traversal for network drives, network shares, and local**\ndrives.\n\nBefore traversing a drive, the ransomware checks if a marker file name is provided from the /MARKER=\ncommand line argument. If it is, MountLocker creates an empty file with this marker file name in the tobe-encrypted drive before enumerating it. This is mainly for marking which drive has been encrypted.\n\n_Figure 23: Creating drive marker file._\n\nTo enumerate through folders, MountLocker calls FindFirstFileW and FindNextFileW. When\nenumerating through network servers, it will use WNetOpenEnumW and WNetEnumResourceW\ninstead.\n\n\n-----\n\n_Figure 24: Recursive file traversal._\n\nThe ransomware also calls a function to checks if it should encrypt each file/folder that it finds.\n\nWhen processing a folder, the checking function will check for the following things. If any of these is true,\nthe folder is skipped.\n```\n - If folder name is \".\" or \"..\"\n - If folder name is in the FOLDER_TO_AVOID list\n - If folder name is \"Program Files\", \"Program Files (x86)\", \"ProgramData\", or \"SQL\"\n - If calling CreateFileW on the folder fails.\n - If folder's reparse tag is not IO_REPARSE_TAG_MOUNT_POINT (folder is a mount point) \n or IO_REPARSE_TAG_SYMLINK (folder is a symbolic link)\\\n - If folder name is in a share name format\n - If folder is a mount point and is visible\n\n```\nBelow is the FOLDER_TO_AVOID list.\n```\n\":\\\\Windows\\\\\", \":\\\\System Volume Information\\\\\", \":\\\\$RECYCLE.BIN\\\\\", \":\\\\SYSTEM.SAV\",\n\":\\\\WINNT\", \n\":\\\\$WINDOWS.~BT\\\\\", \":\\\\Windows.old\\\\\", \":\\\\PerfLog\\\\\", \":\\\\Boot\",\n\":\\\\ProgramData\\\\Microsoft\\\\\", \n\":\\\\ProgramData\\\\Packages\\\\\", \"$\\\\Windows\\\\\", \"$\\\\System Volume Information\\\\\",\n\"$\\\\$RECYCLE.BIN\\\\\", \n\"$\\\\SYSTEM.SAV\", \"$\\\\WINNT\", \"$\\\\$WINDOWS.~BT\\\\\", \"$\\\\Windows.old\\\\\", \"$\\\\PerfLog\\\\\", \"$\\\\Boot\", \n\"$\\\\ProgramData\\\\Microsoft\\\\\", \"$\\\\ProgramData\\\\Packages\\\\\", \"\\\\WindowsApps\\\\\",\n\"\\\\Microsoft\\\\Windows\\\\\", \n\"\\\\Local\\\\Packages\\\\\", \"\\\\Windows Defender\", \"\\\\microsoft shared\\\\\", \"\\\\Google\\\\Chrome\\\\\",\n\"\\\\Mozilla Firefox\\\\\", \n\"\\\\Mozilla\\\\Firefox\\\\\", \"\\\\Internet Explorer\\\\\", \"\\\\MicrosoftEdge\\\\\", \"\\\\Tor Browser\\\\\",\n\"\\\\AppData\\\\Local\\\\Temp\\\\\"\n\n```\n\n-----\n\nIf the folder is valid and there is no ransom note file in the folder yet, MountLocker will drop a ransom\nnote in the folder.\n\n_Figure 25: Dropping ransom note._\n\nWhen processing a file, the checking function checks for the following things. If any of these is true, the\nfile is skipped.\n```\n - If file size is less than MIN_CRYPT_SIZE (if MIN_CRYPT_SIZE is provided)\n or if file size is larger than MAX_CRYPT_SIZE (if MAX_CRYPT_SIZE is provided)\n - If file name is \"RecoveryManual.html\", \"bootmgr\", or has the encrypted file extension.\n - If file extension is in the EXTENSION_TO_AVOID list\n\n```\nBelow is the EXTENSION_TO_AVOID list.\n```\n\"exe\", \"dll\", \"sys\", \"msi\", \"mui\", \"inf\", \"cat\", \"bat\", \"cmd\", \"ps1\", \"vbs\", \"ttf\", \"fon\", \"lnk\"\n\n```\nIf the file is valid, the ransomware’s main thread will populate the shared file structure with the file name\nfor its worker thread to encrypt.\n\nBecause of synchronization concerns, the main thread also has to call WaitForSingleObject and\n**_InterlockedExchange to wait until it has access to the shared structure.**\n\nAfter populating the file structure, it calls SetEvent to signal the event for worker threads to encrypt.\n\n\n-----\n\n_Figure 26: Calling SetEvent to signal file encryption._\n\n### Worm Property\n\nSimilar to WannaCry and Ryuk, this MountLocker sample is a combination of ransomware and worm\nwith the ability to self-propagate to other hosts in the network.\n\nUnlike WannaCry, this ransomware does not use any fancy 0-day but instead just COM interfaces such\nas IDirectorySearch and IWbemServices to spread and execute itself.\n\n**MountLocker has this structure that is shared among all worm threads.**\n```\nstruct WORM_STRUCT\n{\n _QWORD function; // function to launch ransomware remotely\n _QWORD func_param; // function's parameter\n HANDLE hEvent; // worm event\n HANDLE hSemaphore; // worm semaphore\n};\n\n```\nFirst, memory is allocated for this structure, and the event handle and semaphore handle are created.\nThe ransomware launching function and its parameter is originally left to be null initially.\n\n**MountLocker creates 8 threads to execute this worm property.**\n\n_Figure 27: Populating worm struct and creating worm threads._\n\nEach of these threads waits for the event to be signal by the main thread before calling the worm function\nto execute the ransomware remotely. The main thread will set this worm function accordingly before\nsignalling the event.\n\n\n-----\n\n_Figure 28: Worm worker threads._\n\nAfter creating these worker threads, the main thread begins enumerating the Windows domain that the\ncurrent host is in.\n\nThis is accomplished through calling NetGetDCName to get the name of the primary domain controller\nand append this name after the string “LDAP://”.\n\n_Figure 29: Building LDAP path._\n\n[Lightweight Directory Access Protocol (LDAP) is a protocol to communicate and query several different](https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol)\ntypes of directories, and in this case, MountLocker uses it to make Active Directory query requests to the\nprimary domain controller.\n\nIt calls ADsOpenObject with the newly built ADsPath string and provides the credential (username and\npassword) from the /LOGIN= and /PASSWORD= arguments. The RIID provided is {109BA8EC-92F0**11D0-A790-00C04FD8D5A8}, and through this call, the ransomware retrieves the IDirectorySearch**\ninterface.\n\n[This trick to query IDirectorySearch is previously used by Trickbot as explained by Vitali here.](https://www.vkremez.com/2017/12/lets-learn-introducing-new-trickbot.html)\n\n\n-----\n\n_Figure 30: Querying IDirectorySearch interface._\n\nThis interface can be used to execute a search for all domain controllers through its\n**IDirectorySearch::ExecuteSearch function which return an ADs search handle.**\n\n**MountLocker calls IDirectorySearch::GetFirstRow and IDirectorySearch::GetNextRow to enumerate**\nthrough all the searches, passing each search into a function to extract its domain controller information.\n\n_Figure 31: Enumerating through ADs searches to extract domain controller information._\n\n\n-----\n\nFor each of these search handles, MountLocker then calls IDirectorySearch::GetColumn with the\ncolumn name “name” to retrieve the corresponding ADS_SEARCH_COLUMN structure at this row.\n\nThis structure contains an array of ADSVALUE structures, and each of these structures contains a DN\nstring of a directory service object in the Active Directory. This Distinguished Name (DN) string is basically\na name to identify another PC in the network.\n\n_Figure 32: Extracting all DN string of other PCs in the network._\n\nWhen a DN string of a PC is extracted, it’s passed into a function where the ransomware will use it as the\nfunction parameter in the WORM_STRUCT structure. The structure’s function is set to a specific function\nthat drops and launches the sample remotely. SetEvent is called to execute this function after the\n**WORM_STRUCT structure is fully populated.**\n\n_Figure 33: Setting up WORM_STRUCT and signal the worm event._\n\n**Worm Dropping Function**\n\nFirst, the worm thread will try to establish a connection to the remote target PC by calling\n**WNetAddConnection2W and provice the username and password from the /LOGIN= and**\n**/PASSWORD= arguments.**\n\n\n-----\n\n_Figure 34: Establishing connection with remote PC._\n\nNext, memory is allocated for a custom structure. I just call this WORM_REMOTE_STRUCT.\n```\nstruct WORM_REMOTE_STRUCT\n{\n LPCWSTR rem_exe_path; // remote executable path\n CHAR *launch_exe_cmd; // command line to launch executable\n CHAR *PC_name; // remote PC name\n CHAR *elevated_PC_path; // Elevated PC path to launch executable\n DWORD API_result; // result value\n DWORD last_error; // last error value\n CHAR *exe_name; // executable name\n};\n\n```\nIt then populates this structure. The executable name is a number retrieved from GetTickCount, and the\npath on the host to drop the ransomware is set to “C:\\ProgramData”.\n\n_Figure 35: Populating WORM_REMOTE_STRUCT._\n\nThe drop_ransomware function checks if the DN string contains either of the share names with higher\npriviledge ”\\ADMIN$“ and ”\\IPC$“. If it does, then MountLocker uses that as the main path in the\ncommand to launch the executable. If it doesn’t, then it just uses the normal path.\n\nThe ransomware sample is set to be launched with the /NOLOG parameter and any arguments provided\nin the original /PARAMS= argument.\n\nFinally, it drops the ransomware on the target PC by calling CopyFileW.\n\n\n-----\n\n_Figure 36: Dropping the ransomware on the target PC._\n\nNot only does MountLocker drops the ransomware executable on the target PC but it also enumerates\nthrough the PC’s shared resources in the PC’s network by calling NetShareEnum. After finding the path\nto each shared resource, the ransomware calls drop_ransomware to drop the executable in the shared\nresource’s system.\n\n_Figure 37: Dropping the ransomware on the target PC’s shared resources._\n\n\n-----\n\n**Worm Launching Function**\n\n**MountLocker has two different ways to launch the executable on the remote host.**\n\nIf the /NETWORK argument provided is s, it launches the executable through a service.\n\nFirst, this full cmd.exe command is built.\n```\ncmd.exe /c start \"ransomware_path PARAMS_VALUE /NOLOG\"\n\n```\nThen, the ransomware calls OpenSCManagerW to establish a connection to the service control manager\non the target PC. Using this handle, it calls CreateServiceW with the command above as its\n_lpBinaryPathName parameter to create a service handle and calls StartServiceW to launch it._\n\n_Figure 38: Launching ransomware on remote host using Service._\n\nIf the /NETWORK argument provided is w, it launches the executable through Windows Management\n**Instrumentation (WMI).**\n\nFirst, MountLocker retrieves the IWbemServices interface. This is done by calling CoCreateInstance\nwith the CLSID {4590F811-1D3A-11D0-891F-00AA004B2E24} to retrieve an IWbemLocator object.\n\nUsing this IWbemLocator object, it calls the IWbemLocator::ConnectServer to connect with the PC’s\n**ROOT\\CIMV2 namespace and obtain an IWbemServices object.**\n\n\n-----\n\n_Figure 39: Connecting to ROOT\\CIMV2 namespace through COM objects._\n\nFrom here, MountLocker sets up an appropriate SEC_WINNT_AUTH_IDENTITY_A structure with the\ngiven username and password. It then calls CoSetProxyBlanket to set the authentication information for\nthis IWbemServices object.\n\n_Figure 40: Setting the authentication information for the IWbemServices object._\n\nUsing this IWbemServices object, the ransomware calls the IWbemServices::GetObjectA function with\nthe “Win32_Process” path to get IWbemClassObject object corresponding to Windows32 processes.\n\nNext, using this “Win32_Process” object, it then calls the IWbemClassObject::GetMethod function with\nthe “Create” method name to get an IWbemClassObject object corresponding to the method to create a\nprocess.\n\n\n-----\n\nWith this method object, it calls the IWbemClassObject::SpawnInstance to create a new instance of the\nclass.\n\n_Figure 41: Retrieving the COM object to create a Windows32 process._\n\nSince the Win32_Process::Create requires a valid value for the command line in-parameter to execute\nproperly, MountLocker calls the IWbemClassObject::Put function to set the value of the command line\nto the launching command that it has built above.\n\n_Figure 42: Setting valid value for command line in-parameter._\n\nFinally, it calls IWbemServices::ExecMethod to create a Win32 process running the “cmd.exe”\ncommand above. It also checks to see if the new process is created successfully or not by checking if the\nprocess’s ID is changed through calling IWbemClassObject::Get.\n\n\n-----\n\n_Figure 43: Launching ransomware remotely using Win32_Process::Create._\n\nIf any of these steps to drop and launch the executable fails, MountLocker just resorts to using\n**WNetOpenEnumW and WNetEnumResourceW to enumerate through the victim’s network and drops**\nthe ransomware in a similar fashion.\n\n### Self-Deletion\n\nIf the /NODEL argument is set to 0, MountLocker will delete its own executable.\n\nFirst, it creates a .bat file in the TEMP folder with a random name from GetTickCount.\n\nIt writes this command into this .bat file, which clears Read-only, System, and Hidden file attribute from\nthe ransomware executable, forces deletes the executable quietly if it exists, and deletes the bat file.\n```\nattrib -s -r -h %1\n:l\ndel /F /Q %1\nif exist %1 goto l\ndel %0\n\n```\nNext, MountLocker builds the command line string to execute the .bat file with the executable path as\nthe parameter and finally calls CreateProcessW to delete itself.\n\n\n-----\n\n_Figure 44: Self-deletion._\n\n## YARA rule\n```\nrule MountLocker5_0 {\n     meta:\n          description = \"YARA rule for MountLocker v5.0\"\n          reference =\n\"http://chuongdong.com/reverse%20engineering/2021/05/23/MountLockerRansomware/\"\n          author = \"@cPeterr\"\n          tlp = \"white\"\n     strings:\n          $worm_str = \"========== WORM ==========\" wide\n          $ransom_note_str = \".ReadManual.%0.8X\" wide\n          $version_str = \"5.0\" wide\n          $chacha_str = \"ChaCha20 for x86_64, CRYPTOGAMS by <appro@openssl.org>\"\n          $chacha_const = \"expand 32-byte k\"\n          $lock_str = \"[OK] locker.file > time=%0.3f size=%0.3f KB speed=%\" wide\n          $bat_str = \"attrib -s -r -h %1\"\n          $IDirectorySearch_RIID = { EC A8 9B 10 F0 92 D0 11 A7 90 00 C0 4F D8 D5 A8 }\n     condition:\n          uint16(0) == 0x5a4d and all of them\n}\n\n References\n\n```\nhttps://blogs.blackberry.com/en/2020/12/mountlocker-ransomware-as-a-service-offers-double-extortioncapabilities-to-affiliates\n\nhttps://zawadidone.nl/2020/11/26/mount-locker-ransomware-analysis.html\n\nhttps://www.vkremez.com/2017/12/lets-learn-introducing-new-trickbot.html\n\nhttps://github.com/Finch4/Malware-Analysis-Reports/tree/main/MountLocker\n\nhttps://github.com/dot-asm/cryptogams/blob/master/x86_64/chacha-x86_64.pl\n\n\n-----\n\nhttps://www.bleepingcomputer.com/news/security/mountlocker-ransomware-uses-windows-api-to-wormthrough-networks/\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-05-23 - MountLocker Ransomware.pdf"
    ],
    "report_names": [
        "2021-05-23 - MountLocker Ransomware.pdf"
    ],
    "threat_actors": [
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673536088,
    "ts_updated_at": 1743041152,
    "ts_creation_date": 1653693835,
    "ts_modification_date": 1653693835,
    "files": {
        "pdf": "https://archive.orkl.eu/0b9998f65791d50e3c90b77def69898ab505c319.pdf",
        "text": "https://archive.orkl.eu/0b9998f65791d50e3c90b77def69898ab505c319.txt",
        "img": "https://archive.orkl.eu/0b9998f65791d50e3c90b77def69898ab505c319.jpg"
    }
}