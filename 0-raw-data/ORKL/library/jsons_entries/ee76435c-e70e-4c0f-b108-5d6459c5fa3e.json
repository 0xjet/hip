{
    "id": "ee76435c-e70e-4c0f-b108-5d6459c5fa3e",
    "created_at": "2023-01-12T15:02:18.257714Z",
    "updated_at": "2025-03-27T02:08:00.166985Z",
    "deleted_at": null,
    "sha1_hash": "1bf68b4f2ade9f383a725030c1e37147679c6944",
    "title": "2019-08-06 - Clipsa – Multipurpose password stealer",
    "authors": "",
    "file_creation_date": "2022-05-28T18:57:49Z",
    "file_modification_date": "2022-05-28T18:57:49Z",
    "file_size": 796107,
    "plain_text": "# Clipsa – Multipurpose password stealer\n\n**decoded.avast.io/janrubin/clipsa-multipurpose-password-stealer/**\n\nby [Jan RubínAugust 6, 201932 min read](https://decoded.avast.io/author/janrubin/)\n\n## High level overview\n\n\nAugust 6, 2019\n\n\nClipsa is a multipurpose password stealer, written in Visual Basic, focusing on stealing cryptocurrencies,\nbrute-forcing and stealing administrator credentials from unsecured WordPress websites, replacing\ncrypto-addresses present in a clipboard, and mining cryptocurrencies on infected machines. Several\nversions of Clipsa also deploy an XMRig coinminer to make even more money from infected computers.\n\nClipsa spreads as a malicious executable file, likely disguised as codec pack installers for media players.\nOnce on an infected device, Clipsa can perform multiple actions, such as searching for cryptowallet\naddresses present in victims’ clipboards to then replace the addresses victims want to send money to with\nwallet addresses owned by the bad actors behind Clipsa. Furthermore, Clipsa is capable of searching for\nand stealing `wallet.dat files, and installing a cryptocurrency miner.`\n\nAdditionally, Clipsa uses infected PCs to crawl the internet for vulnerable WordPress sites. Once it finds a\nvulnerable site, it attempts to brute-force its way into the site, sending the valid login credentials to\nClipsa’s C&C servers. While we cannot say for sure, we believe the bad actors behind Clipsa steal further\ndata from the breached sites. We also suspect they use the infected sites as secondary C&C servers to\nhost download links for miners, or to upload and store stolen data.\n\n## Campaign overview\n\nWe estimate that the attack vector is most likely malicious codec pack installers for media players ( Ultra\n```\nXVid Codec Pack.exe or Installer_x86-x64_89006.exe ). Users who try to install these codecs for\n\n```\ntheir media players inadvertently download malicious installers instead of clean ones. Once users begin\nthe installation process, they deploy Clipsa on their machines and the malware immediately starts its\nmalicious behavior.\n\nThe campaign is most prevalent in India, where Avast has blocked more than 43,000 Clipsa infection\nattempts, protecting more than 28,000 users in India from the malware. We have also observed higher\ninfection attempt rates in the Philippines, where Avast protected more than 15,000 users from Clipsa and\nin Brazil, protecting more than 13,000 users. In total, Avast protected more than 253,000 users more than\n360,000 times, since August 1, 2018. We protect all our users against Clipsa and all of its components.\n\n\n-----\n\n_Map illustrating the countries Clipsa has targeted from August 2018 – July 2019_\n\n_Graph illustrating Clipsa’s spread in time (hits)_\n\n## Analysis\n\nClipsa uses a single executable binary with several parameters (command line arguments). The\nparameters distinguish program phases which run as separate processes, simultaneously. Each phase\nfocuses on a different functionality and is started by Clipsa’s initialization process, which does not have\nany parameters.\n\nClipsa uses these parameters for phases:\n\n1. No parameters\n\n2. `--CLIPS`\n\n3. `--CLIPSS`\n\n4. `--WALLS`\n\n5. `--PARSE`\n\n6. `--BRUTE`\n\nPhases 2-4 are designed to steal data from users, focusing on crypto-wallet related data. Phases 5 and 6\nfocus on finding vulnerable WordPress websites and stealing their administrative credentials. We will\nfocus on each of these phases in the rest of this analysis.\n\n\n-----\n\n## The parameterless phase\n\nWhen the malware is run on an infected machine, the program intuitively starts without any parameters.\nThis phase allows Clipsa to install and hide itself on the system. Then it continues by initializing other\nphases that perform malicious actions.\n\n### Pre-installation\n\nIn the pre-installation phase, Clipsa creates a message dialog box which makes it look like some kind of a\nsetup process. However, this dialog box (see figure below) is actually just a disguise, so the user thinks\nthe codec pack they downloaded is being installed. The truth is the dialog box only displays randomly\ngenerated numbers (incrementally summed) and prints the sum. Clipsa also adds a random sleep\nbetween increments, making the process look natural.\n\n_Figure illustrating the setup progress as a disguise_\n\nAfter the sum 99% is reached, the process closes the dialog. During the imaginary setup process, the\nmalware performs no malicious nor useful actions. We believe the purpose of this behavior is to delay the\nactual malicious process, thus avoiding detection in auto-sandboxing tools.\n\nAfter the imaginary setup is finished, Clipsa checks whether Task Manager is running using Windows\nManagement Instrumentation (WMI):\n\n```\nSelect * from Win32_Process WHERE Name = 'taskmgr.exe'\n\n```\n\nAnd if it is running, terminates the program to avoid user detection.\n\n### Installation\n\nClipsa then copies itself to the `%APPDATA%\\Roaming directory. The specific folders and binaries are`\nnamed depending on the version of Clipsa. One of the newer versions copies itself to:\n\n```\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\condlg.exe\n\n```\n```\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\zcondlg.exe\n\n```\n\nSome older versions were located in:\n\n```\nC:\\Users\\user\\AppData\\Roaming\\WinSys\\coresys.exe\n\n```\n```\nC:\\Users\\user\\AppData\\Roaming\\WinSys\\xcoresys.exe\n\n```\n\nFrom now on, we will only consider the newer version which uses the `AudioDG path, along with C&C`\nserver `poly.ufxtools[.]com . For further details about the other C&C servers, see the C&C servers`\nsection, below.\n\nDuring the installation process, additional directories and files are created as well:\n```\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\log.dat\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\obj\\\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\udb\\\n\n```\nAdditionally, the path to `condlg.exe is added to registry autorun, assuring the malware’s persistence:`\n\n```\nHCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\11f86284\n\n```\n\n-----\n\nThe registry key name `11f86284 is created from the first four bytes of a SHA-256 hash, which was`\ncomputed from the `H3c7K4c5:H3c7K4c5 hard coded string. Note that we will see the string` `H3c7K4c5`\nmany times during the analysis – mostly in the encryption functions.\n\nFurthermore, a new process `condlg.exe is created (without parameters), which serves as a dropper`\nand also starts other malicious phases. This process is, however, started from the hidden folder AudioDG\nand this is exactly how Clipsa knows it is already installed on the system.\n\nLast but not least, the initial Clipsa process is doomed to end. Even when the entire Clipsa installation\nprocess is successful, the malware displays an error message to the users, to make the users believe the\ncodec installation failed, making them think nothing was installed:\n\n_Figure illustrating an invoked error message at the end of_\n\n_Clipsa’s successful installation_\n\n**The condlg.dll file**\n\nDuring the installation process, Clipsa checks for the presence of an additional file in the directory from\nwhich the user executed the malware. This file is usually named `65923_VTS.vob or` `setup.dll .`\nHowever, it is neither a multimedia container nor a library. The file is an encrypted text file that is\ndecrypted by Clipsa and it is saved to a new file:\n\n```\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\condlg.dll\n\n```\n\nThe file holds several thousand Bitcoin addresses. As we will see later, this file will be used in the CLIPS\nphase during which crypto-wallet addresses are replaced in the clipboard. However, its presence is\noptional and Clipsa is fully functional without it.\n\nNote that the names of the original files follow the assumption that Clipsa is served disguised as codec\npack installers for media players.\n\nThe decryption process is very straightforward. Clipsa loads the file and XORs each byte with a current\nindex in the byte array modulo 0xFF:\n\n### Coinmining\n\nOnce Clipsa is successfully installed on the system, it uses the process `condlg.exe to harvest`\ninformation about the infected system (like OS version, serial number, username) and sends the\ninformation to the `poly.ufxtools[.]com file repository. This step also serves as a heartbeat, identifying`\nwhether the server is still alive. The actual data takes on this form:\n\n```\nxxxxxxxx|PING|OS version|0|0|0|0|0|0|0|0\n\n```\n\nwhere the first column is the first four bytes of a SHA-256 hash calculated from the drive’s (where the\nmalware is located) serial number in the decadic form and username creating a fingerprint for the user\n\n\n-----\n\nThe third column is an OS version in plaintext, followed by a sequence of numbers parsed from the\n```\nAudioDG\\log.dat file (implicitly zeroes). More information about the log file can be found at the end of\n\n```\nour analysis in the logging subsection.\n\nIf `poly.ufxtools[.]com is alive, the malware proceeds with downloading and executing an XMRig`\ncoinminer. The download is performed using this request:\n```\npoly.ufxtools[.]com/wp-content/plugins/WPSystem/dl.php?a=d\n\n```\nand the file is named as the first four bytes of a SHA-256 hash calculated from a randomly generated\nfloating point number between 0-1 (rounded to 7 digits after the decimal point):\n\n```\nC:\\Users\\user\\AppData\\Local\\Temp\\xxxxxxxx.exe\n\n```\n\nThis coinminer uses several layers of obfuscation. At first, its Base64-encoded overlay is decoded,\ncreating a new PowerShell script. This script decodes a GZIP file from another Base64-encoded string.\nThis archive is unpacked and a slightly obfuscated final script is created. This final script then decodes a\nfew additional Base64 strings and one of them is the XMRig binary, which is executed afterwards.\n\n**Files 65923_VTS.asx and setup.bin**\n\nLast but not least, Clipsa checks whether the user’s localization matches any of the locales in this hard\ncoded list:\n```\nARE,AUS,AUT,BEL,BGR,CAN,CHE,CHN,CYP,CZE,DEU,DNK,ESP,EST,FIN,FRA,GBR,GEO,HKG,HUN,\nIDN,IRL,ISR,ITA,JPN,KOR,LUX,LVA,MAC,MCO,MYS,NLD,NOR,NZL,PHL,POL,PRT,QAT,SAU,SGP,\n\n```\n```\nSVK,SVN,SWE,SWZ,THA,TUR,TWN,USA\n\n```\n\nIf the user’s locale does not match any of the locales in the hard coded list, Clipsa attempts to find two\nadditional files in the directory from which the malware was started:\n\n```\n65923_VTS.asx\n\n```\n```\nsetup.bin\n\n```\n\nIf one of these files is present, Clipsa copies it into the local temporary folder:\n\n```\nC:\\Users\\user\\AppData\\Local\\Temp\\xxxxxxxx.exe\n\n```\n\nwhere `xxxxxxxx are four random bytes generated with the same random generator mentioned above in`\nthe coinmining subsection. After the file is copied, it is executed as well. Note that only one of these files is\nexpected to be found, because it is actually one file with two name variants. Clipsa doesn’t contain this file\ndirectly in its binary. It is, however, very likely that some installers do contain this file and it is dropped\nalong with Clipsa. During our analysis, we didn’t encounter this file bundled in Clipsa installers. We did,\nhowever, discover it through other sources.\n\nThe file `65923_VTS.asx is yet another coinminer. It mines the Monero cryptocurrency, sending the`\nmoney to the address:\n\n```\n49Y3XrW9mPtAqVDmFjAWNXF5X8sEgTS23Sa6ZVvJwFEEMa5rG7Yt3zaDY2TKH1sfChjPkUqYpygyKNVy\n\n```\n```\nhPguXU1f4WGFp2f\n\n```\n\nin a pool:\n\n```\npool.supportxmr[.]com\n\n```\n\nThe miner uses several anti-debugging techniques, few obfuscations, and persistence actions. Some of\nthe samples we found were inside a crypter, too.\n\nTo mention some of the coinminer properties, the coinminer is always copied and renamed into a new\nlocation:\n\n```\nC:\\Users\\user\\AppData\\Roaming\\Host\\svchost.exe\n\n```\n\nimmediately after execution (thus, the file `Temp\\xxxxxxxx.exe is truly temporary) and a new process is`\n\n\n-----\n\ncreated from this location. This confuses the user to think the coinminer is a legitimate Windows process.\nFurthermore, it writes autorun entries into registry and it also registers itself into Task Scheduler with a\nsomewhat ironic name, using the following command:\n```\ncmd.exe /c SCHTASKS /Create /SC MINUTE /MO 2 /TN \"Microsoft Malware Protection\nCommand Line Utility\" /TR \"C:\\Users\\user\\AppData\\Roaming\\Host\\svchost.exe\"\n\n```\nThe coinminer also uses multithreading, where one of the threads periodically checks the following list of\nactive processes:\n```\ntaskmgr.exe\nprocexp64.exe\nprocexp.exe\nprocesshacker.exe\nprocmon.exe\nwireshark.exe\nvnc.exe\nanvir.exe\n\n```\nand these opened windows:\n```\nProcess Hacker [%s\\%s]\nProcess Hacker [%s\\%s]+ (Administrator)\nProcess Explorer - Sysinternals: www.sysinternals.com [%s\\%s]\n\n```\nwhere the strings `%s are respectively:`\n```\n%USERNAME%\n%COMPUTERNAME%\n\n```\nIf any of these windows or processes are found, the coinminer pauses its actions. This is done to\npersuade the user that nothing is wrong with their computer.\n\n### The OK download\n\nAfter the coinminer is downloaded and executed, Clipsa downloads an additional file from the URL:\n\n```\npoly.ufxtools[.]com/wp-content/plugins/WPSystem/ok.php\n\n```\n\nto a path:\n\n```\nC:\\Users\\user\\AppData\\Local\\Temp\\xxxxxxxx.log\n\n```\n\nHowever, during our analysis, this URL was returning 0 bytes and we could not verify the purpose of the\nfile because of this.\n\n**The tsk.dat file**\n\nAfter a heartbeat with information about the user’s system is returned, Clipsa performs a request:\n\n```\npoly.ufxtools[.]com/wp-content/plugins/WPSystem/dl.php?a=i\n\n```\n\nDuring our analysis, this request returned a string `ogirejsorg584erg4sgef which represents a “task”`\nfrom the C&C server.\n\nThe task is saved to a new file:\n\n```\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\tsk.dat\n\n```\n\nThis file contains information about the C&C from which the request was received and also the task. Both\nvalues are hashed using SHA-256 (only the first four bytes are used) and prefixed by hard coded letters\n```\nP and T :\nPf66ef67b\nTf8ab7df4\n\n```\nWhere `f66ef67b is calculated from` `http[:]//poly.ufxtools[.]com (without safety brackets) and`\n```\nf8ab7df4 is calculated from the task string ogirejsorg584erg4sgef .\n\n```\n\n-----\n\n### Initialization of phases\n\nAt this stage, Clipsa performs the initialization of phases which are started one by one. For this purpose,\nthe binary `zcondlg.exe is used. Clipsa starts processes with these parameters, which run`\nsimultaneously:\n\n```\nzcondlg.exe --CLIPS\n\n```\n```\nzcondlg.exe --CLIPSS\n\n```\n```\nzcondlg.exe --PARSE\nzcondlg.exe --BRUTE\nzcondlg.exe --WALLS\n\n```\nAfter this initialization, the process `condlg.exe is not terminated. Instead, it creates a new BRUTE`\nprocess every 10 seconds. These new processes are used as “brute-force workers” who take on new\nbrute-force jobs and try to gain administrative login credentials of WordPress websites (see the BRUTE\nphase for details).\n\n**The bool.scan file**\n\nAfter the WALLS phase is started (parameter `--WALLS ), a file` `bool.scan is created:`\n\n```\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\bool.scan\n\n```\n\nThis file is empty and serves as a check whether this phase was started or not. This prevents Clipsa from\nrepeatedly scanning the entire disk for crypto-wallets.\n\n## The CLIPS phase\n\nThis phase is dedicated to modifying the user’s clipboard. The clipboard is continuously checked and\nvalidated if its contents match Bitcoin (BTC) or Ethereum (ETH) address formats. If an address in the\ncorrect format is found, Clipsa replaces the address with the most similar BTC address from a predefined\nlist. This serves as an easy way of stealing money from users when they, for example, copy and paste\ntheir own crypto-wallet address to a friend, effectively misleading the user to send money elsewhere.\n\n### Replacing wallet addresses\n\nBefore the actual replacement process begins, Clipsa checks the existence of a file\n\n```\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\condlg.dll\n\n```\n\nThis file, however, is a text file and we could see its decryption process in the condlg.dll file subsection. If\nthe file exists, the malware reads its content and compares it with the BTC wallet address below:\n\n```\n111u5Bbmz7gmaf2NXVyciTjCfdfqejzWm\n\n```\n\nThis address is the first address in the `condlg.dll file, thus Clipsa checks if the file contains valid`\ncontent. If it does, Clipsa uses this huge list of addresses in the selection process.\n\nIf a valid Ethereum address is found instead in the clipboard, it is exclusively replaced by:\n\n```\n0x4966DB520B0680fC19df5d7774cA96F42E6aBD4F\n\n```\n\nThis means that no other ETH address is used and the selection process is omitted.\n\nDuring our analysis, the total amount of ETH received in this wallet was 55.059107 ETH (at the time of\npublishing this was ~12,632.76 USD). Note that since some funds could have come from other sources,\nthe total amount does not necessarily reflect the actual amount of cryptocurrencies stolen by Clipsa.\n\nIf the file `condlg.dll is not found or it has different contents, Clipsa decrypts two different lists of BTC`\nwallets. These two lists are then concatenated, creating a list with 2,000 valid BTC addresses (see A.1\nBTC addresses list (2000)). Details about received funds to the BTC addresses can be found in\nsubsection received funds at the end of this analysis.\n\n\n-----\n\nFrom this list, themost similaraddress is selected and is used as a replacement if a valid BTC address is\nfound in the user’s clipboard.\n\nA complete list of available BTC addresses used by Clipsa can be found in A.2 BTC addresses list\n(complete).\n\n**Selection process**\n\nThe selection process is designed in two stages. In the first stage, the algorithm selects a sublist from the\nBTC addresses, depending on whether the original address starts with a number, 1 or 3. All the other\naddresses from the list are omitted. Note that BTC addresses match this regular expression: `[13][a-km-`\n```\nzA-HJ-NP-Z1-9]{25,34} .\n\n```\nIn the second stage, a specific algorithm is used. It compares two BTC addresses (the original one and\nthe selected one from the sublist), calculating a similarity index `SI which is a distance between the two`\nstrings. The similarity index changes depending on the compared bytes of both strings where the outer\nbytes have a greater influence on the similarity index and the middle one the lowest. The bytes are\ncompared from both sides of the addresses.\n\nThis calculation can be represented by the equation listed below:\n\nwhere `n is a desired calculation length from the beginning of the string and from the end of the string,`\n```\ni is an index in the string and v is a value representing a match strength:\nv=0 when the bytes match\nv=1 when the bytes match case insensitive\nv=2 when the bytes don’t match\n\n```\nFrom this definition, we can see that the wallet with the lowest `SI is selected from the sublist.`\n\nLast but not least, note that Clipsa uses `n=2 as a parameter for calculating the` `SI value, effectively`\nchecking only the first two and last two bytes for similarity comparison. The selection process described\nabove makes sense, because users are more likely to notice the change in the first and last `n`\ncharacters.\n\n### Saving the result\n\nWhen the address in the clipboard is successfully replaced, Clipsa creates a new file:\n\n```\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\rep.dat\n\n```\n\nThis file contains encrypted information about what address was replaced by which address. This\ninformation is represented by the string in the following format:\n\n```\npattern|original address|new address\n\n```\n\nwhere `pattern is a randomly selected string:` `1,2 or` `2,1 . However, if the wallet address is the ETH`\naddress, `pattern is set to a letter` `E . It is unclear why Clipsa chooses between the strings` `1,2 and`\n```\n2,1 . In our opinion, it would be sufficient to add, for example, a prefix B and omit the “obfuscation”.\n\n```\nIn a later stage, the file `rep.dat is then used in` the CLIPSS phase as a log data which is sent to the\nC&C server.\n\n### String encryption\n\n\n-----\n\nAs mentioned above, the string saved in the `rep.dat file is encrypted. Furthermore, almost all the`\nstrings found in the Clipsa binaries are encrypted as well. This encryption process is actually the same\none the malware author used to obfuscate strings in Clipsa. Clipsa contains several types of custom\nencryption/decryption functions. This function, however, is the most prevalent.\n\nA custom encryption function is designed to achieve the string encryption. To explain the process properly,\nlet’s first look at the decryption function in Python code below:\n\nThe string `encrypted is the input for this decryption function. Note that this string always contains only`\nvalid ASCII values.\n\nThe encryption function has, however, a bit of a different approach. It takes the to-be-encrypted plaintext\nand converts it to hexadecimal form. After that, it selects two random letters from the predefined alphabet:\n```\nabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\n\n```\nThese two bytes ( xx ) are then appended to the string `H3c7K4c5xx and Clipsa tries to decrypt it.`\nConsider it as a single step of the decrypt function listed above. If the desired output is equal to the\nplaintext, the two bytes are considered valid and they are saved as a ciphertext. This process repeats, as\nlong as all bytes of the ciphertext are generated and can be correctly decrypted to plaintext. Thus, the\nwhole process of encryption is not deterministic, i.e. one plaintext can be encrypted to multiple\nciphertexts.\n\nFor example, let’s take the replacement of the hard coded Ethereum address to the same address,\nrepresented as the string below:\n```\nE|0x4966DB520B0680fC19df5d7774cA96F42E6aBD4F|0x4966DB520B0680fC19df5d7774cA96F42\nE6aBD4F\n\n```\nThe encrypted output might look like this:\n```\nIZZNRwqRnwWUdb56NoutldDWpJkJl4s6OCWOQV9Ur5Brz1ctf3GUm0SDjq52BuoxPRY4PB9hGDmu5lVc\nH6R0Ng0Qg4AFk2gT4xHSakkEtxrWXfBgnwnAllIruQlLGOJlt0LKLLIwgw3fjaSIng3losV8l4cfs6xq\nWgUwmPEDN7oSGG3NZSmLDHqlLFsKthuTJqpQD8kZN7meKeafK5SD0bHK48yuFcWuElwZldwuV3S6RM7A\nngcWOXSfy2bmvS4Sj9015auLkziW2uBJqs5t4XFUZAfmrUH04hsyUyDPKMBHH6pQTPAK3aS6bmcqxf1A\n9RTuLT5IWdlGS1oVq6QFfcUl3AKR\n\n## The CLIPSS phase\n\n```\nThe CLIPSS phase is closely entangled with the CLIPS phase. It continually searches for the `rep.dat`\nfile. When it is found, Clipsa decrypts its contents (see string encryption for details) and parses the values.\nIf the file is not found or has invalid (e.g. empty) content, the process sleeps for one second and then\n\n\n-----\n\nrepeats.\n\nAfter that, the malware creates a new string that contains five values separated by pipes:\n```\nfingerprint|REPL|type|original address|replaced address\n\n```\nWhere `fingerprint is created as the first four bytes of a SHA-256 hash calculated from the user’s`\nserial number (in decimal form) and computer name, `type is a “type” of the address ( E for Ethereum`\nor a random string `1,2 or` `2,1 for BTC). The` `original address and the` `replaced address`\nrepresent the user’s and attacker’s addresses respectively.\n\nAfter this plaintext string is created, it is once again encrypted and Clipsa attempts to upload it to the\n```\npoly.ufxtools[.]com C&C server. After the upload is completed, the malware deletes the contents of\n\n```\nthe `rep.dat file and repeats the entire process (i.e. waits for new content).`\n\n## The WALLS phase\n\nThe WALLS phase is designed to find `wallet.dat files on the disk (hence the name). Note that`\n```\nwallet.dat is a typical filename for cryptocurrency wallets. Stealing this file effectively results in\n\n```\n[stealing money from this wallet. Furthermore, Clipsa also finds all text files ( *.txt ) which contain bip-39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)\npatterns. If any such files are present, they are encrypted by RC4 stream cipher and sent to the\n```\npoly.ufxtools[.]com file repository.\n\n```\nHowever, not all filesystem directories are searched. The malware recursively scans the whole filesystem,\nexcluding only a list of predefined locations (separated by pipes):\n\n```\n\\AppData|\\Boot|\\PerfLogs|\\Program Files|\\Temporary|\\AMD\\|\\Dell\\|\\HP\\|\\Intel\\|\n\n```\n```\nHeroOnline|iTunes|FIFA|League|MineCraft|nDoors|SmileGate|Steam|TwelveSky|WarRock\n\n```\n\n### File encryption (RC4)\n\nAs mentioned before, when the file of interest is found, Clipsa encrypts its contents. This is done by RC4\nstream cipher.\n\nFirst of all, Clipsa hashes a hard coded string `H3c7K4c5 using SHA-256 and uses the output as a key`\nwith a key length of 32 bytes:\n\n```\n4d7b290afaa14d86b4cf64fc5bcca8de99536196ee5a18f963d51f26d7956775\n\n```\n\nThe rest of the cipher follows a typical RC4 implementation.\n\n### Saving the result – wallet.dat\n\nAfter the content of the file is encrypted, two new files are created. The encrypted content is written into a\nfile with the extension `.data.bin . The second file contains a plaintext path to the file whose contents`\nwere stolen and its extension is `.path.bin . Furthermore, both files have a name created from two`\nhashes, separated by a dot. The first hash is created from the user’s fingerprint (see the CLIPSS phase\nfor details). The second hash is calculated from the absolute path to the stolen file – only the first two\nbytes are used:\n```\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\xxxxxxxx.yyyy.data.bin\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\xxxxxxxx.yyyy.path.bin\n\n```\nClipsa then tries to upload these files to the `poly.ufxtools[.]com C&C server:`\n\n```\npoly.ufxtools[.]com/wp-content/plugins/WPSecurity/up.php\n\n```\n\n### Saving the result – text files\n\n\n-----\n\nAs previously mentioned, Clipsa also focuses on text files that contain words with specific patterns. These\npatterns form [bip-39 mnemonic seed recovery phrases (or “mnemonic word sequences”) which are used](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)\nas a seed for a pseudo-random generator. If a user knows the seed, they can deterministically generate\nthe same wallet keys that were generated when the user first created their wallet. Thus, Clipsa in this\nphase actually focuses on stealing mnemonic word sequences to crack cryptocurrency wallets.\n\n**Selecting the correct text files**\n\nEven though each `wallet.dat file is stolen, only text files with maximum length of 32,771 bytes are`\nselected. Furthermore, after the contents of these text files are truncated and all redundant spaces are\nremoved, the contents have to match specific patterns from the list below:\n```\n#WWWWWWWWWWWW#\n#WWWWWWWWWWWWN\nNWWWWWWWWWWWW#\nNWWWWWWWWWWWWN\n#NWNWNWNWNWNWNWNWNWNWNWNW#\n#NWNWNWNWNWNWNWNWNWNWNWNWN\nNNWNWNWNWNWNWNWNWNWNWNWNW#\nNNWNWNWNWNWNWNWNWNWNWNWNWN\n\n```\nThese patterns are made up of letters. Each letter represents a word (string which is delimited by space\n(0x20)). There are three types of letters:\n```\nN – Number (decadic)\n\n```\n`W – Word from` [bip-39 word list](https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt)\n```\n# – Unknown word\n\n```\n[Thus, every word from the text file is tested to check whether the word is in the bip-39 word list. This is](https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt)\ndone by matching every word from the file content against a hard coded encrypted word list (see\ndecryption of word list (bip-39) below). If a word matches, the character `#,` `N, or` `W is appended to a`\nnew pattern. After the new pattern is finished and if it matches any of the patterns listed above, the file is\ncopied, its contents encrypted, and uploaded.\n\n**Saving text files on disk**\n\nSaving the selected text files is very similar to the stolen `wallet.dat files. Instead of using the`\nextension `.bin, an extension` `.txt is used:`\n```\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\xxxxxxxx.yyyy.data.txt\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\xxxxxxxx.yyyy.path.txt\n\n```\nNote that after the files are successfully uploaded, they are then deleted from this location.\n\n### Decryption of word list (bip-39)\n\nThe decryption process of the word list is very straightforward. The cipher is a simple substitution which\nuses a lookup table and a ciphertext.\n\nFor the word list, this lookup table is given:\n\n```\nJyBhjP0OSI3qVQn!U4ZlvK5zsfDEdgTRx%XaF|br6YA1u87Li2mpkWNtecoGCwM9H\n\n```\n\nwhile using this alphabet:\n\n```\n0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ|!%\n\n```\n\nHere is a decryption of the beginning of the ciphertext (truncated) to plaintext:\n\n\n-----\n\n```\n3q3zQszM3qZKZgXM3qKnM3qsTgM3qsRnM\nabandon|ability|able|about|above|\n\n```\nFor the whole word list in plaintext, see B.1 Word list (bip-39).\n\n[Note that this list exactly matches the bip-39 word list for generating mnemonic phrases for crypto wallets.](https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt)\n\n## The PARSE phase\n\nIn the PARSE phase, Clipsa decrypts a hard coded word list. From this list, it selects particular keywords\nwhich are used by Google and Bing search engines. Every site from the search engine results page is\nparsed and saved into separate files on the disk in obfuscated representation.\n\n### Keywords selection\n\nBefore the random selection of the keywords begins, Clipsa uses a hard coded string:\n\n```\nw1|w2|w1 w2|w2 w1|w1 and w2|w1 at w2|w1 but w2|w1 else w2|w1 for w2|w1 if w2|\n\n```\n```\nw1 in w2|w1 of w2|w1 or w2|w1 with w2\n\n```\n\nWe can look at this string as a list of patterns (separated by pipes) which is used for searching in search\nengines. A random pattern from this string is selected. The words `w1 and` `w2 are then replaced by`\nrandomly selected words from the word list. Thus, even though both `w1 and` `w2 are selected, the`\nmalware can skip one of them (depending on the used pattern).\n\n### Parsing\n\nWhen the keyword pattern is selected, it is inserted into Google search:\n\n```\nhttps://www.google.com/search?q=PATTERN&start=0&num=100\n\n```\n\nwhere `PATTERN could, for example, be` `abandon in above .`\n\nIf the Google search request is unsuccessful, the malware tries an additional request using Bing:\n\n```\nhttps://www.bing.com/search?q=PATTERN&first=0&count=50\n\n```\n\nIf a valid response is received, Clipsa parses all URLs present in all `<cite> HTML tags and simplifies`\nthem by removing `http,` `https,` `<strong> tags, and any text after the domain name. Furthermore,`\nthe malware hashes the URLs using SHA-256 and creates a new directory structure in the\n```\nAudioDG\\udb\\ folder. It takes the first two bytes from the calculated hash for a folder name and a file\n\n```\nname (hexadecimal):\n```\nAudioDG\\udb\\xx\\xx.dat\n\n```\nand the file `xx.dat contains additional two bytes of the hash. This way, Clipsa knows which URLs were`\nparsed and it omits any duplicities found on the search result page.\n\nAll these unique URLs are then continually visited by new requests:\n\n```\nhttp(s)://website.example/xmlrpc.php\n\n```\n\nIf the `xmlrpc.php file is accessible on the WordPress server, the page returns:`\n\n```\nXML-RPC server accepts POST requests only\n\n```\n\nand Clipsa tries to access\n\n```\nhttp(s)://website.example/wp-login.php\n\n```\n\nas well, attempting to confirm that it is indeed a WordPress server with a login page.\n\nAt this point, Clipsa attempts to get the WordPress site’s admin username. To achieve this, the malware\nexecutes a simple HTTP request for user enumeration (exploiting a weak configuration of the WordPress\nsite):\n\n```\nhttp(s)://website.example/?author=1\n\n```\n\n-----\n\nwhich will often redirect the URL to:\n```\nhttp(s)://website.example/author/admin/\n\n```\nwhere `admin is the first username on the WordPress server, which is usually the admin’s username`\n(ID=1). Note that it usually matches admin literally, too…\n\nHowever, Clipsa does not extract information from the new URL, but it instead parses the redirected site\ncontents and searches for the following pattern:\n```\nhref=\"http(s)://website.example/author/admin/feed/\"\n\n```\nwhere the `admin is extracted.`\n\nIf Clipsa successfully retrieves the admin’s username, the whole PARSE phase is considered successful\nand the malware creates an additional file in the `AudioDG\\obj\\ subdirectory. The file is named using the`\nfirst four bytes of the SHA-256 hash calculated from the URL address and it serves as a log file and a\n“brute-force job” for the BRUTE phase. The file contains four values separated by pipes and we will refer\nto it as the `URL file for simplicity:`\n```\nwww.website.example|admin’s name|0|0\n\n```\nAs we will see later in the BRUTE phase, the last two columns are actually the “number of brute-force\nattempts” and an “epoch time from the last brute-force attempt”, respectively.\n\n## The BRUTE phase\n\nThe BRUTE phase serves a single purpose: Brute-force its way into the administrative privileges of the\nWordPress website and send brute-forced credentials to the `poly.ufxtools[.]com file repository.`\n\nHowever, it is strictly bound to the PARSE phase, because it uses the `URL file created at the end of its`\nlast successful run. Note that a new process ( --BRUTE ) is created every 10 seconds, effectively\nparallelizing the brute-force process.\n\n### Parsing the URL file and login credentials\n\nClipsa selects a random `URL file from the` `\\obj\\ subdirectory. This file also has to have a timestamp`\n(the last column in the file) lower than the present date. Clipsa then parses the file, retrieving the to-bebrute-forced URL and admin’s username.\n\nAfter the `admin’s username is retrieved, Clipsa uses three additional values as usernames:`\n\n```\n%domain%\n\n```\n```\ntest\n\n```\n\nwhere `%domain% is replaced with the current to-be-brute-forced domain. The rest of the strings are hard`\ncoded (and they match common usernames).\n\nMoreover, the malware decrypts a list of frequently used passwords. It uses a simple substitution cipher\n(which actually uses the same lookup table as in the WALLS phase) to retrieve the list. For the full list of\npasswords in plaintext, see C.1 Passwords list in the appendix.\n\nHowever, this password list is not complete. As we can see, the list starts with these two columns:\n```\n!|%domain%\n\n```\nThe first column (exclamation mark) is replaced with the `admin’s username and` `%domain% is replaced`\nwith the current to-be-brute-forced domain. The rest of the password list is kept as is.\n\n### Brute-forcing\n\n\n-----\n\nBefore the brute-forcing begins, Clipsa increases the penultimate number in the `URL file by one`\n(number of brute-force attempts) and replaces the last number by the current timestamp (from epoch),\nindicating a new brute-force attempt.\n\nAfter all these preparations are finished, Clipsa begins to brute-force. First, it creates a XML-RPC request\nfor the `xmlrpc.php file:`\n```\n<methodCall>\n  <methodName>wp.getUsersBlogs</methodName>\n  <params>\n    <param>\n      <value>\n        <string>admin</string>\n      </value>\n    </param>\n    <param>\n      <value>\n        <string>password</string>\n      </value>\n    </param>\n  </params>\n</methodCall>\n\n```\nwhere `admin and` `password are filled in according to the selected username and the selected`\npassword (from the list).\n\nIf the attempt to retrieve the `UserBlogs is successful, the response should contain a string` `isAdmin . If`\nXML-RPC is enabled and poorly configured, an attacker can use the request above to obtain the\nresponse with the confirmation of the credentials. With the verbose response, Clipsa knows the\ncredentials are valid and the brute-forcing is successful. If not, the next password is selected and Clipsa\ntries again.\n\nWhen Clipsa successfully brute-forces its way into a WordPress admin account, it creates a string with all\nthe information it obtained in the process:\n```\nfingerprint|GOOD|www.website.example|admin’s username|password\n\n```\nThis string is then encrypted and uploaded to the `poly.ufxtools[.]com file repository.`\n\n## Logging\n\nAs we marginally mentioned in the beginning of the analysis, Clipsa creates and uses an additional file:\n\n```\nC:\\Users\\user\\AppData\\Roaming\\AudioDG\\log.dat\n\n```\n\nThis file is used for logging purposes, which the malware author can use to debug Clipsa and obtain\nstatistics.\n\nThe file contains eight columns, separated by pipes. Each column holds a different piece of information.\nAt the beginning, when the file is created, it is empty, meaning all the columns are filled with zeros:\n\n```\n0|0|0|0|0|0|0|0\n\n```\n\nA curious observer could find out that the file is actually created with 10 columns (all zeros). However,\nthese additional columns are removed after the first write into the log.\n\n\n-----\n\nThis file is then continually filled after each successful functionality iteration. Depending on the phase in\nwhich the functionality is located, the specific column is modified. In the table below, we present which\nphase affects which column(s):\n\n**Phase name** **Column in the log file**\n\nPARSE 1, 2, 3, 6\n\nBRUTE 4, 5, 6\n\nCLIPS 7\n\nWALLS 8\n\nCLIPSS None. Functionality of this phase is not logged.\n\nNow, let’s break down what these numbers mean, exactly, based on Clipsa phases, which we explained\nearlier:\n1. Number of parsed URLs\n2. Number of XML-RPC requests (a check whether the site is a WordPress site or not)\n3. Number of author requests (attempts to retrieve the admin’s username)\n4. Number of brute-force tries\n5. Number of successfully brute-forced sites (obtained administrative credentials)\n6. Current count of files in `\\obj directory`\n7. Number of replaced crypto-wallet addresses\n8. Number of stolen `wallet.dat files or` `.txt files with mnemonic phrases`\n\nNote that the contents of the `log.dat file are sent to the C&C server with every heartbeat, which is`\nperformed after Clipsa is started (and after the successful installation).\n\n### Received funds\n\nIn this subsection, we will present a brief overview of the amount of money received in all the BTC\naddresses available in Clipsa. The list contains 9,412 addresses in total (including the `65923_VTS.vob`\nfile, alias `condlg.dll ) and can be found in the A.2 BTC addresses list (complete).`\n\nHowever, until our analysis, only 117 of all the addresses received funds. We will stick to these addresses\nhere. For a complete list of addresses sorted by received amounts, see A.3 BTC addresses list (sorted\namounts).\n\nDuring our analysis, a maximum of 0.3511 BTC (which at the time of publishing was ~4,111.70 USD) was\nreceived at the address `1HKbDo1PeKPDcRzxCinvahTpusbHywEK3o in just one transaction. The minimum`\nvalue received was 0.00001 BTC (which at the time of publishing was ~0.12 USD) at the addresses\n```\n1BY59mYV1nqmkcUjbVPA4mzK52CuPipn2N and 13DmqnVDh9EwKoJdGCjkad4ZNQUKwiTnAV .\n\n```\nIn the figure below, we illustrate the amounts of the top BTC addresses:\n\n\n-----\n\n_Figure illustrating received BTC funds – top 117 addresses (sorted)_\nFurthermore, we can see that only a few addresses received larger amounts of BTC. This is illustrated in\nthe histogram below:\n\n\n-----\n\n_Histogram illustrating a distribution of wallets depending on received funds_\nNow, let’s see how the money got to these crypto-wallets from August 2018, to July 2019. We listed all the\nincoming transactions to all of the 117 addresses and summarized the values. We didn’t find any direct\nincome loops that would make the following graph inaccurate.\n\n\n-----\n\n_Figure illustrating the received BTC funds – top 117 addresses (over time)_\n\n## C&C servers\n\nDuring this analysis, we described only one C&C server:\n\n```\npoly.ufxtools[.]com\n\n```\n\nThis approach was to simplify the description of how Clipsa works. The selection of the C&C addresses is\nactually done by reading multiple hard coded addresses from the memory, but of the several addresses\nonly one or very few of them is the C&C server address. Each of these addresses is visited, and if the\nserver responds correctly, Clipsa knows it is the C&C. For example, the entire list of addresses in the\nanalysed Clipsa sample is:\n```\npoly.ufxtools[.]com\nindustriatempo.com[.]br\nrobertholeon[.]com\ndeluxesingles[.]com\nnaijafacemodel[.]com\nwww.quanttum[.]trade\nwww.blinov-house[.]ru\nssgoldtravel[.]com\nwww.greenbrands[.]ir\nnew.datance[.]com\n\n```\n\n-----\n\nFurthermore, these sites are randomly permuted before every server interaction (e.g. an upload of stolen\nfiles). This is performed to obfuscate the network communication by randomness and non-malicious\nrequests/responses.\n\nMoreover, the list of addresses above is only an example. Nearly every Clipsa sample carries a different\nset of addresses that sometimes contain completely different C&C addresses.\n\nWithout further ado, here is a full list of active C&C servers that we encountered during our analysis:\n```\nhttp[:]//besttipsfor[.]com\nhttp[:]//chila[.]store\nhttp[:]//globaleventscrc[.]com\nhttp[:]//ionix.co[.]id\nhttp[:]//mahmya[.]com\nhttp[:]//mohanchandran[.]com\nhttp[:]//mutolarahsap[.]com\nhttp[:]//northkabbadi[.]com\nhttp[:]//poly.ufxtools[.]com\nhttp[:]//raiz[.]ec\nhttp[:]//rhsgroup[.]ma\nhttp[:]//robinhurtnamibia[.]com\nhttp[:]//sloneczna10tka[.]pl\nhttp[:]//stepinwatchcenter[.]se\nhttp[:]//topfinsignals[.]com\nhttp[:]//tripindiabycar[.]com\nhttp[:]//videotroisquart[.]net\nhttp[:]//wbbministries[.]org\n\n## Indicators of Compromise (IoC)\n\n```\n**File name** **Hash**\n\ncondlg.exe 2922662802EED0D2300C3646A7A9AE73209F71B37AB94B25E6DF57F6AED7F23E\n\n65923_VTS.vob FD552E4BBAEA7A4D15DBE2D185843DBA05700F33EDFF3E05D1CCE4A5429575E5\n\ncondlg.dll A65923D0B245F391AE27508C19AC1CFDE7B52A7074898DA375389E4E6C7D3AE1\n\n\nXMRig miner\n(C&C)\n\n\nB56E30DFD5AED33E5113BD886194DD76919865E49F5B7069305034F6E0699EF5\n\n\n65923_VTS.asx F26E5CA286C20312989E6BF35E26BEA3049C704471FF68404B0EC4DE7A8A6D42\n\n## Appendix\n\n A. The CLIPS phase\n\n**A.1 BTC addresses list (2000)**\n\n[https://github.com/avast/ioc/blob/master/Clipsa/appendix_files/btc_addresses_2000.txt](https://github.com/avast/ioc/blob/master/Clipsa/appendix_files/btc_addresses_2000.txt)\n\n**A.2 BTC addresses list (complete)**\n\n[https://github.com/avast/ioc/blob/master/Clipsa/appendix files/btc addresses complete.txt](https://github.com/avast/ioc/blob/master/Clipsa/appendix_files/btc_addresses_complete.txt)\n\n\n-----\n\n**A.3 BTC addresses list (sorted amounts)**\n\n[https://github.com/avast/ioc/blob/master/Clipsa/appendix_files/btc_addresses_sorted.txt](https://github.com/avast/ioc/blob/master/Clipsa/appendix_files/btc_addresses_sorted.txt)\n\n## B. The PARSE phase\n\n**B.1 Word list (bip-39)**\n\n[https://github.com/avast/ioc/blob/master/Clipsa/appendix_files/word_list.txt](https://github.com/avast/ioc/blob/master/Clipsa/appendix_files/word_list.txt)\n\n## C. The BRUTE phase\n\n**C.1 Passwords list**\n\n[https://github.com/avast/ioc/blob/master/Clipsa/appendix_files/password_list.txt](https://github.com/avast/ioc/blob/master/Clipsa/appendix_files/password_list.txt)\n\n## D. C&C servers\n\n**D.1 C&C servers list**\n\n[https://github.com/avast/ioc/blob/master/Clipsa/appendix_files/cnc_servers_all.txt](https://github.com/avast/ioc/blob/master/Clipsa/appendix_files/cnc_servers_all.txt)\n\n[Tagged ascryptomining,](https://decoded.avast.io/tag/cryptomining/) [malware,](https://decoded.avast.io/tag/malware/) [stealer,](https://decoded.avast.io/tag/stealer/) [wordpress](https://decoded.avast.io/tag/wordpress/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-08-06 - Clipsa – Multipurpose password stealer.pdf"
    ],
    "report_names": [
        "2019-08-06 - Clipsa – Multipurpose password stealer.pdf"
    ],
    "threat_actors": [
        {
            "id": "b740943a-da51-4133-855b-df29822531ea",
            "created_at": "2022-10-25T15:50:23.604126Z",
            "updated_at": "2025-03-27T02:00:55.505366Z",
            "deleted_at": null,
            "main_name": "Equation",
            "aliases": [
                "Equation"
            ],
            "source_name": "MITRE:Equation",
            "tools": null,
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535738,
    "ts_updated_at": 1743041280,
    "ts_creation_date": 1653764269,
    "ts_modification_date": 1653764269,
    "files": {
        "pdf": "https://archive.orkl.eu/1bf68b4f2ade9f383a725030c1e37147679c6944.pdf",
        "text": "https://archive.orkl.eu/1bf68b4f2ade9f383a725030c1e37147679c6944.txt",
        "img": "https://archive.orkl.eu/1bf68b4f2ade9f383a725030c1e37147679c6944.jpg"
    }
}