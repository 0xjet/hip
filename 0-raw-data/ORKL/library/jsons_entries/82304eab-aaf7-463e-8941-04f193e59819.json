{
    "id": "82304eab-aaf7-463e-8941-04f193e59819",
    "created_at": "2023-01-12T15:05:17.186091Z",
    "updated_at": "2025-03-27T02:06:12.951481Z",
    "deleted_at": null,
    "sha1_hash": "549e19d5050574d7def825b56aa40b0126b068a8",
    "title": "2020-06-09 - CobaltStrikeParser",
    "authors": "",
    "file_creation_date": "2022-05-28T04:46:56Z",
    "file_modification_date": "2022-05-28T04:46:56Z",
    "file_size": 140574,
    "plain_text": "# CobaltStrikeParser/parse_beacon_config.py at master · Sentinel-One/CobaltStrikeParser · GitHub\n\n**[github.com/Sentinel-One/CobaltStrikeParser/blob/master/parse_beacon_config.py](https://github.com/Sentinel-One/CobaltStrikeParser/blob/master/parse_beacon_config.py)**\n\nSentinel-One\n\n#!/usr/bin/python3\n\n'''\n\nParses CobaltStrike Beacon's configuration from PE file or memory dump.\n\nBy Gal Kristal from SentinelOne (gkristal.w@gmail.com) @gal_kristal\n\nInspired by https://github.com/JPCERTCC/aa-tools/blob/master/cobaltstrikescan.py\n\nTODO:\n\n1. Parse headers modifiers\n\n2. Dynamic size parsing\n\n'''\n\nfrom beacon_utils import *\n\nfrom struct import unpack, unpack_from\n\n\n-----\n\nfrom socket import inet_ntoa\n\nfrom collections import OrderedDict\n\nfrom netstruct import unpack as netunpack\n\nimport argparse\n\nimport io\n\nimport re\n\nimport pefile\n\nimport os\n\nimport hashlib\n\nfrom io import BytesIO\n\nTHRESHOLD = 1100\n\nCOLUMN_WIDTH = 35\n\nSUPPORTED_VERSIONS = (3, 4)\n\nSILENT_CONFIGS = ['PublicKey', 'ProcInject_Stub', 'smbFrameHeader',\n'tcpFrameHeader', 'SpawnTo']\n\ndef _cli_print(msg, end='\\n'):\n\nif __name__ == '__main__':\n\nprint(msg, end=end)\n\nclass confConsts:\n\nMAX_SETTINGS = 64\n\nTYPE_NONE = 0\n\nTYPE_SHORT = 1\n\nTYPE_INT = 2\n\nTYPE_STR = 3\n\nSTART_PATTERNS = {\n\n\n-----\n\n3: b'\\x69\\x68\\x69\\x68\\x69\\x6b..\\x69\\x6b\\x69\\x68\\x69\\x6b..\\x69\\x6a',\n\n4: b'\\x2e\\x2f\\x2e\\x2f\\x2e\\x2c..\\x2e\\x2c\\x2e\\x2f\\x2e\\x2c..\\x2e'\n\n}\n\nSTART_PATTERN_DECODED =\nb'\\x00\\x01\\x00\\x01\\x00\\x02..\\x00\\x02\\x00\\x01\\x00\\x02..\\x00'\n\nCONFIG_SIZE = 4096\n\nXORBYTES = {\n\n3: 0x69,\n\n4: 0x2e\n\n}\n\nclass packedSetting:\n\ndef __init__(self, pos, datatype, length=0, isBlob=False, isHeaders=False,\nisIpAddress=False, isBool=False, isDate=False, boolFalseValue=0,\nisProcInjectTransform=False, isMalleableStream=False, hashBlob=False, enum=None,\nmask=None):\n\nself.pos = pos\n\nself.datatype = datatype\n\nself.is_blob = isBlob\n\nself.is_headers = isHeaders\n\nself.is_ipaddress = isIpAddress\n\nself.is_bool = isBool\n\nself.is_date = isDate\n\nself.is_malleable_stream = isMalleableStream\n\nself.bool_false_value = boolFalseValue\n\nself.is_transform = isProcInjectTransform\n\nself.hashBlob = hashBlob\n\nself.enum = enum\n\n\n-----\n\nself.mask = mask\n\nself.transform_get = None\n\nself.transform_post = None\n\nif datatype == confConsts.TYPE_STR and length == 0:\n\nraise(Exception(\"if datatype is TYPE_STR then length must not be 0\"))\n\nself.length = length\n\nif datatype == confConsts.TYPE_SHORT:\n\nself.length = 2\n\nelif datatype == confConsts.TYPE_INT:\n\nself.length = 4\n\ndef binary_repr(self):\n\n\"\"\"\n\nParam number - Type - Length - Value\n\n\"\"\"\n\nself_repr = bytearray(6)\n\nself_repr[1] = self.pos\n\nself_repr[3] = self.datatype\n\nself_repr[4:6] = self.length.to_bytes(2, 'big')\n\nreturn self_repr\n\ndef parse_transformdata(self, data):\n\n'''\n\nArgs:\n\ndata (bytes): Raw communication transforam data\n\nReturns:\n\n\n-----\n\ndict: Dict of transform commands that should be convenient for communication forging\n\n'''\n\ndio = io.BytesIO(data)\n\ntrans = {'ConstHeaders':[], 'ConstParams': [], 'Metadata': [], 'SessionId': [], 'Output': []}\n\ncurrent_category = 'Constants'\n\n# TODO: replace all magic numbers here with enum\n\nwhile True:\n\ntstep = read_dword_be(dio)\n\nif tstep == 7:\n\nname = read_dword_be(dio)\n\nif self.pos == 12: # GET\n\ncurrent_category = 'Metadata'\n\nelse: # POST\n\ncurrent_category = 'SessionId' if name == 0 else 'Output'\n\nelif tstep in (1, 2, 5, 6):\n\nlength = read_dword_be(dio)\n\nstep_data = dio.read(length).decode()\n\ntrans[current_category].append(BeaconSettings.TSTEPS[tstep] + ' \"' + step_data + '\"')\n\nelif tstep in (10, 16, 9):\n\nlength = read_dword_be(dio)\n\nstep_data = dio.read(length).decode()\n\nif tstep == 9:\n\ntrans['ConstParams'].append(step_data)\n\nelse:\n\ntrans['ConstHeaders'].append(step_data)\n\n\n-----\n\nelif tstep in (3, 4, 13, 8, 11, 12, 15):\n\ntrans[current_category].append(BeaconSettings.TSTEPS[tstep])\n\nelse:\n\nbreak\n\nif self.pos == 12:\n\nself.transform_get = trans\n\nelse:\n\nself.transform_post = trans\n\nreturn trans\n\ndef pretty_repr(self, full_config_data):\n\ndata_offset = full_config_data.find(self.binary_repr())\n\nif data_offset < 0 and self.datatype == confConsts.TYPE_STR:\n\nself.length = 16\n\nwhile self.length < 2048:\n\ndata_offset = full_config_data.find(self.binary_repr())\n\nif data_offset > 0:\n\nbreak\n\nself.length *= 2\n\nif data_offset < 0:\n\nreturn 'Not Found'\n\nrepr_len = len(self.binary_repr())\n\nconf_data = full_config_data[data_offset + repr_len : data_offset + repr_len + self.length]\n\nif self.datatype == confConsts.TYPE_SHORT:\n\nconf_data = unpack('>H', conf_data)[0]\n\n\n-----\n\nif self.is_bool:\n\nret = 'False' if conf_data == self.bool_false_value else 'True'\n\nreturn ret\n\nelif self.enum:\n\nreturn self.enum[conf_data]\n\nelif self.mask:\n\nret_arr = []\n\nfor k,v in self.mask.items():\n\nif k == 0 and k == conf_data:\n\nret_arr.append(v)\n\nif k & conf_data:\n\nret_arr.append(v)\n\nreturn ret_arr\n\nelse:\n\nreturn conf_data\n\nelif self.datatype == confConsts.TYPE_INT:\n\nif self.is_ipaddress:\n\nreturn inet_ntoa(conf_data)\n\nelse:\n\nconf_data = unpack('>i', conf_data)[0]\n\nif self.is_date and conf_data != 0:\n\nfulldate = str(conf_data)\n\nreturn \"%s-%s-%s\" % (fulldate[0:4], fulldate[4:6], fulldate[6:])\n\nreturn conf_data\n\nif self.is_blob:\n\n\n-----\n\nif self.enum != None:\n\nret_arr = []\n\ni = 0\n\nwhile i < len(conf_data):\n\nv = conf_data[i]\n\nif v == 0:\n\nreturn ret_arr\n\nv = self.enum[v]\n\nif v:\n\nret_arr.append(v)\n\ni+=1\n\n# Only EXECUTE_TYPE for now\n\nelse:\n\n# Skipping unknown short value in the start\n\nstring1 = netunpack(b'I$', conf_data[i+3:])[0].decode()\n\nstring2 = netunpack(b'I$', conf_data[i+3+4+len(string1):])[0].decode()\n\nret_arr.append(\"%s:%s\" % (string1.strip('\\x00'),string2.strip('\\x00')))\n\ni += len(string1) + len(string2) + 11\n\nif self.is_transform:\n\nif conf_data == bytes(len(conf_data)):\n\nreturn 'Empty'\n\nret_arr = []\n\nprepend_length = unpack('>I', conf_data[0:4])[0]\n\nprepend = conf_data[4 : 4+prepend_length]\n\nappend_length_offset = prepend_length + 4\n\n\n-----\n\nappend_length = unpack('>I', conf_data[append_length_offset :\nappend_length_offset+4])[0]\n\nappend = conf_data[append_length_offset+4 : append_length_offset+4+append_length]\n\nret_arr.append(prepend)\n\nret_arr.append(append if append_length < 256 and append != bytes(append_length)\nelse 'Empty')\n\nreturn ret_arr\n\nif self.is_malleable_stream:\n\nprog = []\n\nfh = io.BytesIO(conf_data)\n\nwhile True:\n\nop = read_dword_be(fh)\n\nif not op:\n\nbreak\n\nif op == 1:\n\nl = read_dword_be(fh)\n\nprog.append(\"Remove %d bytes from the end\" % l)\n\nelif op == 2:\n\nl = read_dword_be(fh)\n\nprog.append(\"Remove %d bytes from the beginning\" % l)\n\nelif op == 3:\n\nprog.append(\"Base64 decode\")\n\nelif op == 8:\n\nprog.append(\"NetBIOS decode 'a'\")\n\nelif op == 11:\n\nprog.append(\"NetBIOS decode 'A'\")\n\nelif op == 13:\n\n\n-----\n\nprog.append(\"Base64 URL-safe decode\")\n\nelif op == 15:\n\nprog.append(\"XOR mask w/ random key\")\n\nconf_data = prog\n\nif self.hashBlob:\n\nconf_data = conf_data.strip(b'\\x00')\n\nconf_data = hashlib.md5(conf_data).hexdigest()\n\nreturn conf_data\n\nif self.is_headers:\n\nreturn self.parse_transformdata(conf_data)\n\nconf_data = conf_data.strip(b'\\x00').decode()\n\nreturn conf_data\n\nclass BeaconSettings:\n\nBEACON_TYPE = {0x0: \"HTTP\", 0x1: \"Hybrid HTTP DNS\", 0x2: \"SMB\", 0x4: \"TCP\",\n0x8: \"HTTPS\", 0x10: \"Bind TCP\"}\n\nACCESS_TYPE = {0x0: \"Use proxy server (manual)\", 0x1: \"Use direct connection\", 0x2:\n\"Use IE settings\", 0x4: \"Use proxy server (credentials)\"}\n\nEXECUTE_TYPE = {0x1: \"CreateThread\", 0x2: \"SetThreadContext\", 0x3:\n\"CreateRemoteThread\", 0x4: \"RtlCreateUserThread\", 0x5: \"NtQueueApcThread\", 0x6:\nNone, 0x7: None, 0x8: \"NtQueueApcThread-s\"}\n\nALLOCATION_FUNCTIONS = {0: \"VirtualAllocEx\", 1: \"NtMapViewOfSection\"}\n\nTSTEPS = {1: \"append\", 2: \"prepend\", 3: \"base64\", 4: \"print\", 5: \"parameter\", 6:\n\"header\", 7: \"build\", 8: \"netbios\", 9: \"const_parameter\", 10: \"const_header\", 11:\n\"netbiosu\", 12: \"uri_append\", 13: \"base64url\", 14: \"strrep\", 15: \"mask\", 16:\n\"const_host_header\"}\n\n\n-----\n\nROTATE_STRATEGY = [\"round-robin\", \"random\", \"failover\", \"failover-5x\", \"failover-50x\",\n\"failover-100x\", \"failover-1m\", \"failover-5m\", \"failover-15m\", \"failover-30m\", \"failover-1h\",\n\"failover-3h\", \"failover-6h\", \"failover-12h\", \"failover-1d\", \"rotate-1m\", \"rotate-5m\", \"rotate15m\", \"rotate-30m\", \"rotate-1h\", \"rotate-3h\", \"rotate-6h\", \"rotate-12h\", \"rotate-1d\" ]\n\ndef __init__(self, version):\n\nif version not in SUPPORTED_VERSIONS:\n\n_cli_print(\"Error: Only supports version 3 and 4, not %d\" % version)\n\nreturn\n\nself.version = version\n\nself.settings = OrderedDict()\n\nself.init()\n\ndef init(self):\n\nself.settings['BeaconType'] = packedSetting(1, confConsts.TYPE_SHORT,\nmask=self.BEACON_TYPE)\n\nself.settings['Port'] = packedSetting(2, confConsts.TYPE_SHORT)\n\nself.settings['SleepTime'] = packedSetting(3, confConsts.TYPE_INT)\n\nself.settings['MaxGetSize'] = packedSetting(4, confConsts.TYPE_INT)\n\nself.settings['Jitter'] = packedSetting(5, confConsts.TYPE_SHORT)\n\nself.settings['MaxDNS'] = packedSetting(6, confConsts.TYPE_SHORT)\n\n# Silenced config\n\nself.settings['PublicKey'] = packedSetting(7, confConsts.TYPE_STR, 256, isBlob=True)\n\nself.settings['PublicKey_MD5'] = packedSetting(7, confConsts.TYPE_STR, 256,\nisBlob=True, hashBlob=True)\n\nself.settings['C2Server'] = packedSetting(8, confConsts.TYPE_STR, 256)\n\nself.settings['UserAgent'] = packedSetting(9, confConsts.TYPE_STR, 128)\n\n# TODO: Concat with C2Server?\n\nself.settings['HttpPostUri'] = packedSetting(10, confConsts.TYPE_STR, 64)\n\n\n-----\n\n# This is how the server transforms its communication to the beacon\n\n# ref: https://www.cobaltstrike.com/help-malleable-c2 |\nhttps://usualsuspect.re/article/cobalt-strikes-malleable-c2-under-the-hood\n\n# TODO: Switch to isHeaders parser logic\n\nself.settings['Malleable_C2_Instructions'] = packedSetting(11, confConsts.TYPE_STR,\n256, isBlob=True,isMalleableStream=True)\n\n# This is the way the beacon transforms its communication to the server\n\n# TODO: Change name to HttpGet_Client and HttpPost_Client\n\nself.settings['HttpGet_Metadata'] = packedSetting(12, confConsts.TYPE_STR, 256,\nisHeaders=True)\n\nself.settings['HttpPost_Metadata'] = packedSetting(13, confConsts.TYPE_STR, 256,\nisHeaders=True)\n\nself.settings['SpawnTo'] = packedSetting(14, confConsts.TYPE_STR, 16, isBlob=True)\n\nself.settings['PipeName'] = packedSetting(15, confConsts.TYPE_STR, 128)\n\n# Options 16-18 are deprecated in 3.4\n\nself.settings['DNS_Idle'] = packedSetting(19, confConsts.TYPE_INT, isIpAddress=True)\n\nself.settings['DNS_Sleep'] = packedSetting(20, confConsts.TYPE_INT)\n\n# Options 21-25 are for SSHAgent\n\nself.settings['SSH_Host'] = packedSetting(21, confConsts.TYPE_STR, 256)\n\nself.settings['SSH_Port'] = packedSetting(22, confConsts.TYPE_SHORT)\n\nself.settings['SSH_Username'] = packedSetting(23, confConsts.TYPE_STR, 128)\n\nself.settings['SSH_Password_Plaintext'] = packedSetting(24, confConsts.TYPE_STR,\n128)\n\nself.settings['SSH_Password_Pubkey'] = packedSetting(25, confConsts.TYPE_STR,\n6144)\n\nself.settings['SSH_Banner'] = packedSetting(54, confConsts.TYPE_STR, 128)\n\nself.settings['HttpGet_Verb'] = packedSetting(26, confConsts.TYPE_STR, 16)\n\nself.settings['HttpPost_Verb'] = packedSetting(27, confConsts.TYPE_STR, 16)\n\n\n-----\n\nself.settings['HttpPostChunk'] = packedSetting(28, confConsts.TYPE_INT)\n\nself.settings['Spawnto_x86'] = packedSetting(29, confConsts.TYPE_STR, 64)\n\nself.settings['Spawnto_x64'] = packedSetting(30, confConsts.TYPE_STR, 64)\n\n# Whether the beacon encrypts his communication, should be always on (1) in beacon 4\n\nself.settings['CryptoScheme'] = packedSetting(31, confConsts.TYPE_SHORT)\n\nself.settings['Proxy_Config'] = packedSetting(32, confConsts.TYPE_STR, 128)\n\nself.settings['Proxy_User'] = packedSetting(33, confConsts.TYPE_STR, 64)\n\nself.settings['Proxy_Password'] = packedSetting(34, confConsts.TYPE_STR, 64)\n\nself.settings['Proxy_Behavior'] = packedSetting(35, confConsts.TYPE_SHORT,\nenum=self.ACCESS_TYPE)\n\n# Option 36 is deprecated in beacon < 4.5\n\nself.settings['Watermark_Hash'] = packedSetting(36, confConsts.TYPE_STR, 32)\n\nself.settings['Watermark'] = packedSetting(37, confConsts.TYPE_INT)\n\nself.settings['bStageCleanup'] = packedSetting(38, confConsts.TYPE_SHORT,\nisBool=True)\n\nself.settings['bCFGCaution'] = packedSetting(39, confConsts.TYPE_SHORT,\nisBool=True)\n\nself.settings['KillDate'] = packedSetting(40, confConsts.TYPE_INT, isDate=True)\n\n# Inner parameter, does not seem interesting so silencing\n\n#self.settings['textSectionEnd (0 if !sleep_mask)'] = packedSetting(41,\nconfConsts.TYPE_INT)\n\n#TODO: dynamic size parsing\n\n#self.settings['ObfuscateSectionsInfo'] = packedSetting(42, confConsts.TYPE_STR, %d,\nisBlob=True)\n\nself.settings['bProcInject_StartRWX'] = packedSetting(43, confConsts.TYPE_SHORT,\nisBool=True, boolFalseValue=4)\n\nself.settings['bProcInject_UseRWX'] = packedSetting(44, confConsts.TYPE_SHORT,\nisBool=True, boolFalseValue=32)\n\nself.settings['bProcInject_MinAllocSize'] = packedSetting(45, confConsts.TYPE_INT)\n\n\n-----\n\nself.settings['ProcInject_PrependAppend_x86'] = packedSetting(46,\nconfConsts.TYPE_STR, 256, isBlob=True, isProcInjectTransform=True)\n\nself.settings['ProcInject_PrependAppend_x64'] = packedSetting(47,\nconfConsts.TYPE_STR, 256, isBlob=True, isProcInjectTransform=True)\n\nself.settings['ProcInject_Execute'] = packedSetting(51, confConsts.TYPE_STR, 128,\nisBlob=True, enum=self.EXECUTE_TYPE)\n\n# If True then allocation is using NtMapViewOfSection\n\nself.settings['ProcInject_AllocationMethod'] = packedSetting(52,\nconfConsts.TYPE_SHORT, enum=self.ALLOCATION_FUNCTIONS)\n\n# Unknown data, silenced for now\n\nself.settings['ProcInject_Stub'] = packedSetting(53, confConsts.TYPE_STR, 16,\nisBlob=True)\n\nself.settings['bUsesCookies'] = packedSetting(50, confConsts.TYPE_SHORT,\nisBool=True)\n\nself.settings['HostHeader'] = packedSetting(54, confConsts.TYPE_STR, 128)\n\n# Silenced as I've yet to test it on a sample with those options\n\nself.settings['smbFrameHeader'] = packedSetting(57, confConsts.TYPE_STR, 128,\nisBlob=True)\n\nself.settings['tcpFrameHeader'] = packedSetting(58, confConsts.TYPE_STR, 128,\nisBlob=True)\n\nself.settings['headersToRemove'] = packedSetting(59, confConsts.TYPE_STR, 64)\n\n# DNS Beacon\n\nself.settings['DNS_Beaconing'] = packedSetting(60, confConsts.TYPE_STR, 33)\n\nself.settings['DNS_get_TypeA'] = packedSetting(61, confConsts.TYPE_STR, 33)\n\nself.settings['DNS_get_TypeAAAA'] = packedSetting(62, confConsts.TYPE_STR, 33)\n\nself.settings['DNS_get_TypeTXT'] = packedSetting(63, confConsts.TYPE_STR, 33)\n\nself.settings['DNS_put_metadata'] = packedSetting(64, confConsts.TYPE_STR, 33)\n\nself.settings['DNS_put_output'] = packedSetting(65, confConsts.TYPE_STR, 33)\n\nself.settings['DNS_resolver'] = packedSetting(66, confConsts.TYPE_STR, 15)\n\n\n-----\n\nself.settings['DNS_strategy'] = packedSetting(67, confConsts.TYPE_SHORT,\nenum=self.ROTATE_STRATEGY)\n\nself.settings['DNS_strategy_rotate_seconds'] = packedSetting(68,\nconfConsts.TYPE_INT)\n\nself.settings['DNS_strategy_fail_x'] = packedSetting(69, confConsts.TYPE_INT)\n\nself.settings['DNS_strategy_fail_seconds'] = packedSetting(70, confConsts.TYPE_INT)\n\n# Retry settings (CS 4.5+ only)\n\nself.settings['Retry_Max_Attempts'] = packedSetting(71, confConsts.TYPE_INT)\n\nself.settings['Retry_Increase_Attempts'] = packedSetting(72, confConsts.TYPE_INT)\n\nself.settings['Retry_Duration'] = packedSetting(73, confConsts.TYPE_INT)\n\nclass cobaltstrikeConfig:\n\ndef __init__(self, f):\n\n'''\n\nf: file path or file-like object\n\n'''\n\nself.data = None\n\nif isinstance(f, str):\n\nwith open(f, 'rb') as fobj:\n\nself.data = fobj.read()\n\nelse:\n\nself.data = f.read()\n\n\"\"\"Parse the CobaltStrike configuration\"\"\"\n\n@staticmethod\n\ndef decode_config(cfg_blob, version):\n\nreturn bytes([cfg_offset ^ confConsts.XORBYTES[version] for cfg_offset in cfg_blob])\n\n\n-----\n\ndef _parse_config(self, version, quiet=False, as_json=False):\n\n'''\n\nParses beacon's configuration from beacon PE or memory dump.\n\nReturns json of config is found; else it returns None.\n\n:int version: Try a specific version (3 or 4), or leave None to try both of them\n\n:bool quiet: Whether to print missing or empty settings\n\n:bool as_json: Whether to dump as json\n\n'''\n\nre_start_match = re.search(confConsts.START_PATTERNS[version], self.data)\n\nre_start_decoded_match = re.search(confConsts.START_PATTERN_DECODED,\nself.data)\n\nif not re_start_match and not re_start_decoded_match:\n\nreturn None\n\nencoded_config_offset = re_start_match.start() if re_start_match else -1\n\ndecoded_config_offset = re_start_decoded_match.start() if re_start_decoded_match\nelse -1\n\nif encoded_config_offset >= 0:\n\nfull_config_data = cobaltstrikeConfig.decode_config(self.data[encoded_config_offset :\nencoded_config_offset + confConsts.CONFIG_SIZE], version=version)\n\nelse:\n\nfull_config_data = self.data[decoded_config_offset : decoded_config_offset +\nconfConsts.CONFIG_SIZE]\n\nparsed_config = {}\n\nsettings = BeaconSettings(version).settings.items()\n\nfor conf_name, packed_conf in settings:\n\nparsed_setting = packed_conf.pretty_repr(full_config_data)\n\n\n-----\n\nparsed_config[conf_name] = parsed_setting\n\nif as_json:\n\ncontinue\n\nif conf_name in SILENT_CONFIGS:\n\ncontinue\n\nif parsed_setting == 'Not Found' and quiet:\n\ncontinue\n\nconf_type = type(parsed_setting)\n\nif conf_type in (str, int, bytes):\n\nif quiet and conf_type == str and parsed_setting.strip() == '':\n\ncontinue\n\n_cli_print(\"{: <{width}} - {val}\".format(conf_name, width=COLUMN_WIDTH-3,\nval=parsed_setting))\n\nelif parsed_setting == []:\n\nif quiet:\n\ncontinue\n\n_cli_print(\"{: <{width}} - {val}\".format(conf_name, width=COLUMN_WIDTH-3,\nval='Empty'))\n\nelif conf_type == dict: # the beautifulest code\n\nconf_data = []\n\nfor k in parsed_setting.keys():\n\nif parsed_setting[k]:\n\nconf_data.append(k)\n\nfor v in parsed_setting[k]:\n\nconf_data.append('\\t' + v)\n\n\n-----\n\nif not conf_data:\n\ncontinue\n\n_cli_print(\"{: <{width}} - {val}\".format(conf_name, width=COLUMN_WIDTH-3,\nval=conf_data[0]))\n\nfor val in conf_data[1:]:\n\n_cli_print(' ' * COLUMN_WIDTH, end='')\n\n_cli_print(val)\n\nelif conf_type == list: # list\n\n_cli_print(\"{: <{width}} - {val}\".format(conf_name, width=COLUMN_WIDTH-3,\nval=parsed_setting[0]))\n\nfor val in parsed_setting[1:]:\n\n_cli_print(' ' * COLUMN_WIDTH, end='')\n\n_cli_print(val)\n\nif as_json:\n\n_cli_print(json.dumps(parsed_config, cls=Base64Encoder))\n\nreturn parsed_config\n\ndef parse_config(self, version=None, quiet=False, as_json=False):\n\n'''\n\nParses beacon's configuration from beacon PE or memory dump\n\nReturns json of config is found; else it returns None.\n\n:int version: Try a specific version (3 or 4), or leave None to try both of them\n\n:bool quiet: Whether to print missing or empty settings\n\n:bool as_json: Whether to dump as json\n\n'''\n\nif not version:\n\n\n-----\n\nfor ver in SUPPORTED_VERSIONS:\n\nparsed = self._parse_config(version=ver, quiet=quiet, as_json=as_json)\n\nif parsed:\n\nreturn parsed\n\nelse:\n\nreturn self._parse_config(version=version, quiet=quiet, as_json=as_json)\n\nreturn None\n\ndef parse_encrypted_config_non_pe(self, version=None, quiet=False, as_json=False):\n\nself.data = decrypt_beacon(self.data)\n\nreturn self.parse_config(version=version, quiet=quiet, as_json=as_json)\n\ndef parse_encrypted_config(self, version=None, quiet=False, as_json=False):\n\n'''\n\nParses beacon's configuration from stager dll or memory dump\n\nReturns json of config is found; else it returns None.\n\n:bool quiet: Whether to print missing settings\n\n:bool as_json: Whether to dump as json\n\n'''\n\ntry:\n\npe = pefile.PE(data=self.data)\n\nexcept pefile.PEFormatError:\n\nreturn self.parse_encrypted_config_non_pe(version=version, quiet=quiet,\nas_json=as_json)\n\ndata_sections = [s for s in pe.sections if s.Name.find(b'.data') != -1]\n\nif not data_sections:\n\n\n-----\n\n_cli_print(\"Failed to find .data section\")\n\nreturn False\n\ndata = data_sections[0].get_data()\n\noffset = 0\n\nkey_found = False\n\nwhile offset < len(data):\n\nkey = data[offset:offset+4]\n\nif key != bytes(4):\n\nif data.count(key) >= THRESHOLD:\n\nkey_found = True\n\nsize = int.from_bytes(data[offset-4:offset], 'little')\n\nencrypted_data_offset = offset+16 - (offset % 16)\n\nbreak\n\noffset += 4\n\nif not key_found:\n\nreturn False\n\n# decrypt\n\nenc_data = data[encrypted_data_offset:encrypted_data_offset+size]\n\ndec_data = []\n\nfor i,c in enumerate(enc_data):\n\ndec_data.append(c ^ key[i % 4])\n\ndec_data = bytes(dec_data)\n\nself.data = dec_data\n\nreturn self.parse_config(version=version, quiet=quiet, as_json=as_json)\n\n\n-----\n\nif __name__ == '__main__':\n\nparser = argparse.ArgumentParser(description=\"Parses CobaltStrike Beacon's\nconfiguration from PE, memory dump or URL.\")\n\nparser.add_argument(\"beacon\", help=\"This can be a file path or a url (if started with\nhttp/s)\")\n\nparser.add_argument(\"--json\", help=\"Print as json\", action=\"store_true\", default=False)\n\nparser.add_argument(\"--quiet\", help=\"Do not print missing or empty settings\",\naction=\"store_true\", default=False)\n\nparser.add_argument(\"--version\", help=\"Try as specific cobalt version (3 or 4). If not\nspecified, tries both.\", type=int)\n\nargs = parser.parse_args()\n\nif os.path.isfile(args.beacon):\n\nif cobaltstrikeConfig(args.beacon).parse_config(version=args.version, quiet=args.quiet,\nas_json=args.json) or \\\n\ncobaltstrikeConfig(args.beacon).parse_encrypted_config(version=args.version,\nquiet=args.quiet, as_json=args.json):\n\nexit(0)\n\nelif args.beacon.lower().startswith('http'):\n\nx86_beacon_data = get_beacon_data(args.beacon, 'x86')\n\nx64_beacon_data = get_beacon_data(args.beacon, 'x64')\n\nif not x86_beacon_data and not x64_beacon_data:\n\nprint(\"[-] Failed to find any beacon configuration\")\n\nexit(1)\n\nconf_data = x86_beacon_data or x64_beacon_data\n\nif cobaltstrikeConfig(BytesIO(conf_data)).parse_config(version=args.version,\nquiet=args.quiet, as_json=args.json) or \\\n\ncobaltstrikeConfig(BytesIO(conf_data)).parse_encrypted_config(version=args.version,\nquiet=args.quiet, as_json=args.json):\n\n\n-----\n\nexit(0)\n\nelse:\n\nprint(\"[-] Target path is not an existing file or a C2 URL\")\n\nexit(1)\n\nprint(\"[-] Failed to find any beacon configuration\")\n\nexit(1)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-09 - CobaltStrikeParser.pdf"
    ],
    "report_names": [
        "2020-06-09 - CobaltStrikeParser.pdf"
    ],
    "threat_actors": [
        {
            "id": "b43e5ea9-d8c8-4efa-b5bf-f1efb37174ba",
            "created_at": "2022-10-25T16:07:24.36191Z",
            "updated_at": "2025-03-27T02:02:10.1909Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "Dark Halo",
                "Nobelium",
                "SolarStorm",
                "StellarParticle",
                "UNC2452"
            ],
            "source_name": "ETDA:UNC2452",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f27790ff-4ee0-40a5-9c84-2b523a9d3270",
            "created_at": "2022-10-25T16:07:23.341684Z",
            "updated_at": "2025-03-27T02:02:09.74554Z",
            "deleted_at": null,
            "main_name": "APT 29",
            "aliases": [
                "APT 29",
                "ATK 7",
                "Blue Dev 5",
                "BlueBravo",
                "Cloaked Ursa",
                "CloudLook",
                "Cozy Bear",
                "Dark Halo",
                "Earth Koshchei",
                "Grizzly Steppe",
                "Group 100",
                "ITG11",
                "Iron Hemlock",
                "Iron Ritual",
                "Midnight Blizzard",
                "Minidionis",
                "Nobelium",
                "NobleBaron",
                "Operation Ghost",
                "Operation Office monkeys",
                "Operation StellarParticle",
                "SilverFish",
                "Solar Phoenix",
                "SolarStorm",
                "StellarParticle",
                "TEMP.Monkeys",
                "The Dukes",
                "UNC2452",
                "UNC3524",
                "Yttrium"
            ],
            "source_name": "ETDA:APT 29",
            "tools": [
                "7-Zip",
                "ATI-Agent",
                "AdFind",
                "Agentemis",
                "AtNow",
                "BEATDROP",
                "BotgenStudios",
                "CEELOADER",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobalt Strike",
                "CobaltStrike",
                "CosmicDuke",
                "Cozer",
                "CozyBear",
                "CozyCar",
                "CozyDuke",
                "Danfuan",
                "EnvyScout",
                "EuroAPT",
                "FatDuke",
                "FoggyWeb",
                "GeminiDuke",
                "Geppei",
                "GoldFinder",
                "GoldMax",
                "GraphDrop",
                "GraphicalNeutrino",
                "GraphicalProton",
                "HAMMERTOSS",
                "HammerDuke",
                "LOLBAS",
                "LOLBins",
                "LiteDuke",
                "Living off the Land",
                "MagicWeb",
                "Mimikatz",
                "MiniDionis",
                "MiniDuke",
                "NemesisGemina",
                "NetDuke",
                "OnionDuke",
                "POSHSPY",
                "PinchDuke",
                "PolyglotDuke",
                "PowerDuke",
                "QUIETEXIT",
                "ROOTSAW",
                "RegDuke",
                "Rubeus",
                "SNOWYAMBER",
                "SPICYBEAT",
                "SUNSHUTTLE",
                "SeaDaddy",
                "SeaDask",
                "SeaDesk",
                "SeaDuke",
                "Sharp-SMBExec",
                "SharpView",
                "Sibot",
                "Solorigate",
                "SoreFang",
                "TinyBaron",
                "WINELOADER",
                "WellMail",
                "WellMess",
                "cobeacon",
                "elf.wellmess",
                "reGeorg",
                "tDiscoverer"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535917,
    "ts_updated_at": 1743041172,
    "ts_creation_date": 1653713216,
    "ts_modification_date": 1653713216,
    "files": {
        "pdf": "https://archive.orkl.eu/549e19d5050574d7def825b56aa40b0126b068a8.pdf",
        "text": "https://archive.orkl.eu/549e19d5050574d7def825b56aa40b0126b068a8.txt",
        "img": "https://archive.orkl.eu/549e19d5050574d7def825b56aa40b0126b068a8.jpg"
    }
}