{
    "id": "076a34c5-3d75-46f7-8cbf-851f285aa93b",
    "created_at": "2023-01-12T15:00:04.07023Z",
    "updated_at": "2025-03-27T02:05:21.862593Z",
    "deleted_at": null,
    "sha1_hash": "bd3f00b8d59b5b5f12d92cfd7fa303ae6543e7b5",
    "title": "2017-01-26 - Deep Analysis of Android Rootnik Malware Using Advanced Anti-Debug and Anti-Hook, Part II- Analysis of The Scope of Java",
    "authors": "",
    "file_creation_date": "2022-05-28T15:20:55Z",
    "file_modification_date": "2022-05-28T15:20:55Z",
    "file_size": 2400551,
    "plain_text": "# Deep Analysis of Android Rootnik Malware Using Advanced Anti-Debug and Anti-Hook, Part II: Analysis of The Scope of Java\n\n**blog.fortinet.com/2017/01/26/deep-analysis-of-android-rootnik-malware-using-advanced-anti-debug-and-anti-hook-**\npart-ii-analysis-of-the-scope-of-java\n\nJanuary 26, 2017\n\nIn [part I of this blog we finished the analysis of the native layer and got the decrypted](https://blog.fortinet.com/2017/01/24/deep-analysis-of-android-rootnik-malware-using-advanced-anti-debug-and-anti-hook-part-i-debugging-in-the-scope-of-native-layer)\nsecondary dex file. Here in part II we will continue to analyze it. For the sake of continuity, we\nwill maintain continuous section and figure numbers from part I of the blog.\n\n### IV. The secondary dex file\n\nThe following is the decrypted file, which is a jar format file. It is loaded dynamically as the\nsecondary dex via multidex scheme.\n\n\n-----\n\nFigure 25. The decrypted secondary apk file containing the dex file\n\nAfter decompressing the file “decrypt.dump,” you can now see a file named “classes.dex”\nlocated in the folder.\n\nNext, let’s analyze the classes.dex.\n\n\n-----\n\nFigure 27. Decompile the secondary dex file and AndroidManifest.xml file\n\nFrom above figure, we can see that classes.dex is the main logic of the malware app named\n“file Helper”\n\nThe following is the function “onCreate” in class com.sd.clip.activity. FileManagerActivity.\n\nFigure 28. The function onCreate in class FileManagerActivity\n\nFigure 29. The function initadv()\n\n\n-----\n\nFigure 30. The class Nws\n\nThe function getStart in class Nws is then used to start the service com.hg.mer.PG. The\nfollowing is the definition of class PG.\n\nFigure 31. The service class com.hg.mer.PG\n\nAfter the function startService() is invoked, the function onCreate() is then invoked, followed\nby invoking the function onHandleIntent(). In the above figure, we marked four lines of the\nkey code in red, and then analyzed them in order.\n\n**1. readDex()**\n\nThe following is the snippet code in function readDex().\n\n\n-----\n\nFigure 32. The function readDex()\n\nBased on my analysis, the class Sheu is a base64 implementation class, so the result of\nSheu.decode(\"S0suYmlu\") is the string “KK.bin”. Next, the program opens the file KK.bin in\nits assets folder and reads its content to extract some useful info.\n\nThe following is the file content of KK.bin:\n\n\n-----\n\nFigure 33. The file KK.bin in folder assets\n\nThe program could extract some content from the end of the KK.bin file. There are seven\nstrings there encoded using base64 that are stored in an array list. The function getAppid() is\nthen used to decode these strings.\n\nFigure 34. The function getAppid()\n\nThe result of decoding these seven strings is shown below:\n\n_Pls.Kbin: wddex.jar_\n\n_Pls.OI: xdt_\n\n_Pls.PL: com.svq.cvo.Rtow_\n\n_Pls.Jr: getDex_\n\n_Pls.Wv: sgdex_\n\n_Pls.As: dos.jar_\n\n_Pls.NQ: KK.bin_\n\n**2 .dxfile()**\n\nThe following is the code snippet of the function dxfile().\n\n\n-----\n\nFigure 35. The function dxfile()\n\n\n-----\n\nFigure 36. The function UnZipFolder()\n\nThe function Pls.UnZipFolder() extracts the encrypted content from KK.bin. The content\nstarts at offset 0x20 and ends at offset 0x1CDB in the file KK.bin, and then is saved as\n/data/data/com.web.sdfile/files/wddex.jar. Its content is encrypted using the DES algorithm.\n\nIn the function dxfile() the program decrypts the file contents of\n/data/data/com.web.sdfile/files/wddex.jar to file /data/data/com.web.sdfile/app_sgdex/dos.jar.\n\n**3 .DexClassLoader()**\n\nIts constructor is shown below:\n\nIn this invocation, the value of dexPath is “/data/data/com.web.sdfile/app_sgdex/dos.jar,” and\nthe value of optimizedDirectory is “/data/data/com.web.sdfile/app_xdt.”\n\nThis function loads classes from the .jar and .apk files containing a classes.dex entry. This\nfunction can be used to execute code not installed as part of an application. The optimized\ndex files are written in the file dos.dex in the folder data/data/com.web.sdfile/app_xdt.\n\nAfter loading classes from /data/data/com.web.sdfile/app_sgdex/dos.jar, the program deletes\nthis file.\n\n**4. Invoke getDex() method in class com.svq.cvo.Rtow dynamically.**\n\nNext, let’s examine dos.dex.\n\nFigure 37. Decompile the dex file dos.dex\n\n\n-----\n\nThe following is the function getDex in class com.svq.cvo.Rtow:\n\nFigure 38. The function getDex in class com.svq.cvo.Rtow\n\nFigure 39. The constructor of class Dwol\n\nIn the constructor of class com.kdw.xoa.Dwol, a new file mda.ico is created in folder\n/data/data/com.web.sdfile/files/. It then invokes the function downloadFile to download a\npayload from remote server http://gt[.]rogsob[.]com/stmp/ad.png, and saves it as\n\n\n-----\n\n/data/data/com.web.sdfile/files/mda.ico. The payload is encrypted using the DES algorithm.\n\n……\n\nFigure 40. The function downloadFile\n\nFigure 41. The function initData()\n\nThe following is the definition of the function silentInstall.\n\n\n-----\n\nFigure 42. The function silentInstall\n\nThe five parts marked in red in order are explained below.\n\n1. The function dxfile of class Dwol is used to decrypt the payload\n\n/data/data/com.web.sdfile/files/mda.ico. The decrypted payload is saved as\n/data/data/com.web.sdfile/app_snex/dkt.jar.\n2. The function upZipFile of class Ngss is used to decompress the decrypted payload\n\ndkt.jar into the folder /data/data/com.web.sdfile/files/. It contains the following files:\n\n\n-----\n\nFigure 43. The payload files\n\n1. After decompressing, it deletes the files /data/data/com.web.sdfile/app_snex/dkt.jar and\n\n/data/data/com.web.sdfile/files/mda.ico, and deletes the directory\n/data/data/com.web.sdfile/app_snex/.\n2. Renames the file classes.dex to wsh.jar in folder /data/data/com.web.sdfile/files/.\n3. Dynamically loads classes from /data/data/com.web.sdfile/files/wsh.jar, and the\n\noptimized directory app_outdex stores the dex cache file as wsh.dex.\n4. Invokes the function getDex in class com.rootdex.MainActivity.\n\nNext, we will look deep into the wsh.dex, which mainly executes the root tool to root the\ndevice and install the application in the system app folder.\n\nFigure 44. The decomple the dex file wsh.dex\n\nThe following is the definition of the function getDex of class com.rootdex.MainActivity.\n\n\n-----\n\nFigure 45. The function getDex in class com.rootdex.MainActivity\n\n1. The function GetActive is used to collect device information and send it to the remote\n\nserver. The URL of remote server is http://grs[.]gowdsy[.]com:8092/active.do . The\nfollowing is a capture of the traffic:\n\nFigure 46. The traffic of sending collected info to remote server\n\n1. Checks if some files exist in folder /data/data/com.web.sdfile/files/ and adds their file\n\nname into an array list it is preparing for the next step of rooting the device.\n2. Executes rooting tools on the device.\n\nNext, the function HandleRoot() is invoked in function run().\n\nFigure 47. The function HandleRoot()\n\nThe following is a key code snippet of the function copyRootFile.\n\n\n-----\n\nFigure 48. The function copyRootFile\n\nIn this function, there are four steps.\n\n1. FileUtil.dxfile() is used to decrypt the file /data/data/com.web.sdfile/files/png.ico and\n\nsave it as the file /data/data/com.web.sdfile/app_dex/.do.\n2. FileUtil.UnZip() is used to decompress the file /data/data/com.web.sdfile/app_dex/.do\n\ninto folder /data/data/com.web.sdfile/.rtt, which is a hidden system folder that contains\nsix ELF executables, as shown below. It includes four root exploits r1,r2,r3,r4.\n\nFigure 49. The root exploit executables\n\n1. It deletes the decrypted root tools /data/data/com.web.sdfile/app_dex/.do and folder\n\n/data/data/com.web.sdfile/app_dex.\n\n\n-----\n\n2. It then creates a new file, psneuter.js, in folder /data/data/com.web.sdfile/files/. Its\n\ncontents are shown below.\n\nFigure 50. The file psneuter.js\n\nThe function hanleOriMiddle is invoked in function executeRootAct. The following are four\ncode snippets used to execute root exploits via a shell command:\n\nFigure 51. Execute root exploits via shell command\n\nAfter investigating these executable files, I found that r3 is the MTK root scheme from the\n[dashi root tool, the exploits method in r4 comes from one exploit(CVE-2013-6282) of the](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-6282)\n[open source project android-rooting-tools, and the exploit method in r2 is the CVE-2012-](https://github.com/android-rooting-tools/android_run_root_shell)\n\n\n-----\n\n[6422 which is a root exploit on Samsung Exynos.](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-6422)\n\nThe function hanleOriMiddle executes root exploits and some commands via a shell\ncommand. All executed shell commands are shown below:\n\nFigure 52. All commands executed when rooting device\n\nAfter successfully gaining root access, the script named psneuter.js is executed with super\nuser privilege. The main purpose of this script is to install root privilege applications in folder\n/system/priv-app/.\n\nLater, we will investigate these two new APK files. To avoid being caught by common users,\nthese two apps have no icons on a victim’s device after being installed.\n\nAdditionally, the other script named rsh is then executed via a shell command.\n\nFigure 53. Execute the script rsh via shell command\n\nThe script rsh is different, based on the Build.MANUFACTURER property. The script is\nshown below.\n\n\n-----\n\nFigure 54. The script rsh(1)\n\nFigure 55. The script rsh(2)\n\n### V. How BSetting.apk works\n\n\n-----\n\nAs shown in Figure 50, abc.apk was dropped in the folder /system/priv-app/ and renamed to\nBSetting.apk, and BSetting.apk was installed via pm.\n\nBSetting.apk serves as a remote control service, and it fetches tasks from the remote server\nand performs them.\n\nThis app runs in the background and does not have a launcher icon on the device. The\nfollowing is the app information.\n\n\n-----\n\nFigure 55. App info of BSetting.apk\n\nThe app disguises itself as an Android sync service. The decompiled structure of the apk file\nis shown below:\n\nFigure 56. Decompiled abc.apk\n\nFigure 57. The AndroidMainfest.xml in abc.apk\n\nThe BroadcastReceiver com.sfy.oyr.R performs the main logic of this app.\n\n\n-----\n\nFigure 58. The class R\n\nThe program first decrypts jif.png in the folder assets. It’s a dex file, and the program uses\njava reflection to load class and invoke some methods.\n\nWe decompiled the decrypted dex file, as shown below:\n\nFigure 59. Decompile classes.dex\n\nThe function launchTancTask in class ADService is used to fetch tasks from the remote\nserver and perform them.\n\n\n-----\n\nFigure 60. Fetching a task from the remote server\n\nThe traffic from fetching the task is shown below. The remote server has two domains. One\nis the main domain grs[.]gowdsy[.]com, and the other is backup domain grs[.]rogsob[.]com.\nThe response from the remote server is an xml file that contains the type of task, the url used\nto push porn, the url of the downloading apk, and the type of app to install, etc.\n\nFigure 61. The traffic of fetching the task from the remote server\n\nDepending on the type of task fetched, the app executes the task in a different way. The\nfollowing is the key code snippet:\n\n\n-----\n\nFigure 62. Execute the task depending on the type of task\n\nThe remote control service is capable of performing multiple malicious behaviors, including\nbut not limited to the following:\n\n1. Uninstall app\n\nIt uses the utility “pm uninstall” of android system to uninstall app.\n\nFigure 63. Execute pm uninstall to uninstall app via shell command\n\n1. Push porn\n\nThe following are some screenshots for pushed porn.\n\n\n-----\n\n-----\n\n-----\n\n-----\n\nFigure 64. Porn pushed to the device by the app\n\n1. Create a shortcut on the home screen\n\nThe shortcuts found contain porn, hot app, hot video, etc. The following is the code snippet\nand some screenshots of the shortcuts created.\n\n\n-----\n\nFigure 65. The snippet of creating the shortcut on home screen\n\n\n-----\n\n-----\n\nFigure 66. Shortcuts on home screen\n\n1. App and ad promotion\n\nIn addition to gaining root privileges on the device, the rootnik malware promotes apps and\nads to generate revenue for its creator. Its app and ad promotion is especially aggressive\nand annoying to the user.\n\nThe following are some screenshots of its app promotion:\n\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\n-----\n\nFigure 67. App and ad promotion\n\n1. Normal app installation and silent app installation\n\nThe malware uses different ways to install an app, depending on the type of task that has\nbeen fetched. The following is the code snippet of a normal app installation that has a userinterface view during the installation process.\n\nFigure 68. Normal app installation\n\nThe app uses the utility “pm install -r” of the Android system to silently install non-system\napps while it drops APK files into the folder /system/priv-app/ to install system apps.\n\n\n-----\n\nFigure 69. Silent non-system app installation\n\nIn the folder /data/app/ we found that some apk files (including, but not limited to the\nfollowing) had been installed.\n\nFigure 70. Apps installed in the folder /data/app/ by the malware\n\nFigure 71.Command to install system app\n\nIn the folder /system/priv-app/ we found that some apk files (including, but not limited to the\nfollowing) had also been installed.\n\nFigure 72. Apps installed in folder /system/priv-app/ by the malware\n\n\n-----\n\n1. Push notification\n\nThe malware pushes a notification and induces the user to click it to open the URL in a\nbrowser.\n\nThe following is the code snippet of the pushed notification.\n\nFigure 73. Snippet of pushed notification\n\n\n-----\n\nFigure 74. Push notifications used by the malware\n\n1. Download files\n\n\n-----\n\nWe found that there are many files and folders downloaded in folder /sdcard/. They include\napk files, jar files, pictures, log files, etc.These files are generated by the installed apps, and\nsome of them perform malicious behaviors.\n\nFigure 75. The files and folders dowonloaded in folder /sdcard/\n\n## Solution\n\nThe malware sample is detected by Fortinet Antivirus signature Android/Rootnik.PAC!tr.\n\nThe traffic communicating with remote C2 server can be detected by Fortinet IPS signature\nAndroid.Rootnik.Malware.C2.\n\n## Summary\n\nFrom the analysis above, we can see that the rootnik malware is very powerful and uses\nvery advanced anti-debugging and anti-hooking techniques to prevent reversing engineering,\nand different types of encryption for files and strings. Additionally, it also uses a multidex\nscheme to dynamically load and install the secondary dex file that is the main logic of this\nmalware. The malware uses some open-sourced Android root exploit tools and the MTK\nroot scheme from dashi root tool to gain root access on the Android device. After\nsuccessfully gaining root privileges on the device, the rootnik malware can perform a variety\nof malicious, including app and ad promotion, pushing porn, creating shortcuts on the home\nscreen, silent app installation, and pushing notifications, etc.\n\n## Appendix\n\n\n-----\n\n### Rootnik Malware Sample\n\n**Package Name: com.web.sdfile**\n\nSHA256:\nE5E22B357893BC15A50DC35B702DD5FCDFEAFC6FFEC7DAA0D313C724D72EC854\n\nAdditional APK files dropped into system partition by Rootnik malware\n\n**Package Name: com.br.srd**\n\nSHA256:\nE2BDCFE5796CD377D41F3DA3838865AB062EA7AF9E1E4424B1E34EB084ABEC4A\n\n**Package Name: com.oyws.pdu**\n\nSHA256:\nCEE6584CD2E01FAB5F075F94AF2A0CE024ED5E4F2D52E3DC39F7655C736A7232\n\n### C&C Server\n\ngt[.]rogsob[.]com\n\ngrs[.]gowdsy[.]com:\n\nqj[.]hoyebs[.]com\n\nqj[.]hoyow[.]com\n\ngt[.]yepodjr[.]com\n\n_Sign up for weekly Fortinet FortiGuard Labs Threat Intelligence Briefs and stay on top of the_\n_newest emerging threats._\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-01-26 - Deep Analysis of Android Rootnik Malware Using Advanced Anti-Debug and Anti-Hook, Part II- Analysis of The Scope of Java.pdf"
    ],
    "report_names": [
        "2017-01-26 - Deep Analysis of Android Rootnik Malware Using Advanced Anti-Debug and Anti-Hook, Part II- Analysis of The Scope of Java.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535604,
    "ts_updated_at": 1743041121,
    "ts_creation_date": 1653751255,
    "ts_modification_date": 1653751255,
    "files": {
        "pdf": "https://archive.orkl.eu/bd3f00b8d59b5b5f12d92cfd7fa303ae6543e7b5.pdf",
        "text": "https://archive.orkl.eu/bd3f00b8d59b5b5f12d92cfd7fa303ae6543e7b5.txt",
        "img": "https://archive.orkl.eu/bd3f00b8d59b5b5f12d92cfd7fa303ae6543e7b5.jpg"
    }
}