{
    "id": "db67e54b-ecf0-4c28-99b9-3fd4d07c6c61",
    "created_at": "2023-05-06T02:08:26.927115Z",
    "updated_at": "2025-03-27T02:09:18.237823Z",
    "deleted_at": null,
    "sha1_hash": "197cbaf4f4c656d2dd51ea69f3e480139a3e43f7",
    "title": "2023-04-20 - An analysis of syscall usage in Cobalt Strike Beacons",
    "authors": "",
    "file_creation_date": "2023-05-05T02:00:23Z",
    "file_modification_date": "2023-05-05T02:00:23Z",
    "file_size": 2649161,
    "plain_text": "# Malware-Analysis/Indirect Syscalls.md at main · dodo- sec/Malware-Analysis · GitHub\n\n**[github.com/dodo-sec/Malware-Analysis/blob/main/Cobalt Strike/Indirect Syscalls.md](https://github.com/dodo-sec/Malware-Analysis/blob/main/Cobalt%20Strike/Indirect%20Syscalls.md)**\n\ndodo-sec\n\nmain\n\n## Name already in use\n\nA tag already exists with the provided branch name. Many Git commands accept both\ntag and branch names, so creating this branch may cause unexpected behavior. Are\nyou sure you want to create this branch?\n\n**1\ncontributor**\n\n### Users who have contributed to this file\n\n## An analysis of syscall usage in Cobalt Strike Beacons\n\n[Thanks to the suggestion of my good friend Nat (0xDISREL), I spent the](https://twitter.com/0xDISREL)\nlast week digging into a Cobalt Strike beacon made with the latest leaked\nbuilder. His idea was to analyze and understand how CS approached\nsyscalls.\n\n## Sample\n\nThis analysis was conducted in an x64 bit payload with the hash\n```\n     020b20098f808301cad6025fe7e2f93fa9f3d0cc5d3d0190f27cf0cd374bcf0\n     4, generated by the recently leaked 4.8 version of Cobalt Strike. It's\n\n```\n[publicly available for download in unpacme. I will not go over unpacking](https://unpac.me/)\nthe sample for the sake of brevity, but doing so is pretty straightforward\nand shouldn't present any problems.\n\n## A quick refresher\n\n\n-----\n\nBefore we get to the actual reversing, let s get a quick refresher on what\nsystem calls look like under Windows.\n\nAccording to calling convention, arguments are setup in the appropriate\nregisters before the instruction SYSCALL is executed, handling execution to\nthe Kernel. One of such arguments is the code for the system call (in the\npicture above, it's passed via the eax register). These system calls reside\nin ntdll and provide evasion benefits by allowing you to avoid calling APIs\nthat are likely hooked by AV/EDR.\n\n## How Cobalt Strike does it\n\nDuring the first steps of analysis of the unpacked payload we'll come\nacross references to qwords and calls to registers.\n\n\n-----\n\nInspecting said qwords will lead us to the .data section, where they don't\nhold any values (yet).\n\nInspecting other references to these addresses will land us in a function\nthat looks a lot like an import by hash routine - there are repeated calls to\nthe same function, each time passing a different hexadecimal value and a\n```\n.data section address among its arguments.\n\n```\n\n-----\n\nCase closed then, the empty qwords would receive pointers to the\nresolved API functions, right? All that's left is to identify the hashing\nalgorithm and start renaming things? Well, not quite. This write-up is not\ncalled \"analyzing import by hash\", after all.\n\nLet's take a look at the function that's called before all the hashes start\nshowing up. I've named it mw_prepare_indirect_syscalls.\n\n\n-----\n\n### Preparing system calls\n\nThe first part of it is run of the mill PEB walking and PE parsing to get\nnames of exported functions. Note also that there is a check of\n```\nIMAGE_EXPORT_DIRECTORY.Name against ntdll.dll very slightly\n\n```\nobfuscated (it's just written backwards and split over three cmp\ninstructions). This tells us the author is only interested in ntdll. That makes\nsense, considering they're after syscalls. There is a memset, to which we'll\ncome back later.\n\nThe next block of code will check the function name for the prefixes Ki and\nZw.If either prefix matches there is a call to the hashing function, which is a\n```\nROR 8 ADD algorithm that iterates over each word and uses 0x52964EE9 as\n\n```\na hardcoded XOR key.\n\n\n-----\n\nA function starting with Ki will only be used if its hash matches\n```\n0x8DCD4499; on a 22H2 version of Windows 10 I couldn't find an export\n\n```\nfrom ntdll that matched such value. This routine then will act on at most\none function starting with Ki and all starting with Zw. Appropriate values\nwill populate a structure whose address was supplied to\n```\nmw_prepare_indirect_syscalls - I've decided to call it\nsyscalls_organized_by_hash. It is described below.\nstruct syscalls_organized_by_hash {\n\nDWORD function_hash;\n\nDWORD ntdll_address_of_function;\n\nQWORD ptr_to_function_syscall_block;\n\n};\nfunction_hash is the calculated hash for the exported function; ntdll\naddress of function is an address to the function's code as pointed to\n\n```\nby IMAGE_EXPORT_DIRECTORY.AddressOfFunctions;\n```\nptr_to_function_syscall_block is a pointer to the system call gadget\n\n```\nrelated to said function, which resides in ntdll.dll memory. Remember the\n```\nmemset call earlier? It's used to zero that structure out. The r13 register\n\n```\n\n-----\n\npoints to it, and the additions at each address confirm the size of each\nstruct member. After all the Zw prefixed functions are placed in the\nstructure, an algorithm will sort their positions according to the\n```\nntdll_address_of_function, from lowest to highest. After this is done,\n\n```\nthe struct will contain the hashes, addresses of functions in the ntdll\nexecutable and pointers to the syscall gadgets for all functions with a Zw\nprefix, sorted in ascending order according to the\n```\nntdll_address_of_function values.\n\n### Setting up the syscalls structure\n\n```\nGoing back to the function that resembled import by hash with what we've\nlearned, we can see the that mw_get_indirect_syscalls_by_hash is\nsupplied the syscalls_organized_by_hash, alongside the hash and a\npointer to those empty qwords. After using the hashing algorithm to\ngenerate enums from ntdll exports, we can solve the hashes to see which\nAPIs they intended to get the syscall code blocks to.\n```\nmw_get_indirect_syscalls_by_hash works by looking for the supplied\n\n```\nhash in the syscalls_organized_by_hash structure. Once that is found, it\nwill retrieve the pointer to the syscall code block and call a function that\nvalidates said block - mw_validate_syscall_codeblock.\n\nThe way the verification works is simple. It will loop through the\n```\nsyscalls_organized_by_hash struct (they are actually organized by\n\n```\nascending order of ntdll_address_of_function, but I didn't know that\nback when I created the structure) until it finds the supplied hash. The\n\n\n-----\n\nfunctions are organized inside ntdll by ascending order of syscall codes - a\nfunction that uses code 0x1 is succeeded by one that uses code 0x2 and\nso forth. Because of this, once a hash is found the counter in edi will be\nequal to the syscall code. The validation function checks for the op codes\nof the SYSCALL and RET instructions.\n\nOnce the desired entry is found, a new structure (which I've named\n```\nsyscalls) will receive a pointer to the syscall code block, a pointer to the\nSYSCALL instruction and the value of the syscall code. Although the code is\n\n```\na dword, I've made all members of struct qwords for convenience (that way\nI don't need to create a member for padding between different syscalls\nentries). The struct is as follows:\n\n\n-----\n\n```\nstruct syscalls {\n\nQWORD ptr_to_syscall_block;\n\nQWORD ptr_to_syscall_instruction;\n\nQWORD syscall_code;\n\n};\n\n```\nNow all that's left is use that model to generate the structure that will result\nfrom setting up the syscalls and apply it to the range of qwords that are\npassed to the mw_get_indirect_syscalls_by_hash function. Following\ncross-references to each member will lead us to places where the\nstructure is used in the beacon code.\n\n### Syscall usage\n\n\n-----\n\nLet s take a wrapper function used to get thread context as an example.\n\nAccording to the value in a dword I've named use_syscalls_flag, the\nbeacon will take one of three possible approaches.\n\nIf the flag is equal to 1, it will call the desired syscall block directly;\nthis means getting the correct code into eax is handled by the ntdll\ncode.\nIf the flag is equal to 2, it will call a function responsible for getting\nthe appropriate code from syscall.syscall_code into eax and\njumping to the SYSCALL instruction.\nIf the flag is neither 1 or 2, it will simply call an API instead.\n\nIf a syscall is made by either method, the code will return 1 in eax.\nOtherwise, it returns the result from the standard API that was called. The\npresence of the flag leads me to think all beacons will have the\nmechanisms for handling syscalls. Choosing to use indirect syscalls in the\nbuilder would simply set the appropriate flag(s) in the binary, instead of\nproducing a payload that doesn't handle syscalls at all.\n\n## Acknowledgements\n\n[Nat for suggesting looking into this in the first place and providing me with](https://twitter.com/0xDISREL)\na beacon I could reverse.\n\n\n-----\n\n[Duchy for pointing out how to quickly unpack a beacon and for general](https://twitter.com/DuchyRE)\nhelp regarding structures created and used by the payload.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-04-20 - An analysis of syscall usage in Cobalt Strike Beacons.pdf"
    ],
    "report_names": [
        "2023-04-20 - An analysis of syscall usage in Cobalt Strike Beacons.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1683338906,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1683252023,
    "ts_modification_date": 1683252023,
    "files": {
        "pdf": "https://archive.orkl.eu/197cbaf4f4c656d2dd51ea69f3e480139a3e43f7.pdf",
        "text": "https://archive.orkl.eu/197cbaf4f4c656d2dd51ea69f3e480139a3e43f7.txt",
        "img": "https://archive.orkl.eu/197cbaf4f4c656d2dd51ea69f3e480139a3e43f7.jpg"
    }
}