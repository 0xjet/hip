{
    "id": "9e0dc83c-2b96-42de-8a2d-b01e3f58dc0f",
    "created_at": "2023-01-12T15:10:50.579674Z",
    "updated_at": "2025-03-27T02:05:50.964991Z",
    "deleted_at": null,
    "sha1_hash": "9daea27775e51cec2d3ba9c12e7e745bb72f5fa6",
    "title": "2019-07-22 - A Deep Dive Into IcedID Malware- Part III - Analysis of Child Processes",
    "authors": "",
    "file_creation_date": "2022-05-28T15:21:07Z",
    "file_modification_date": "2022-05-28T15:21:07Z",
    "file_size": 266134,
    "plain_text": "# A Deep Dive Into IcedID Malware: Part III - Analysis of Child Processes\n\n**[fortinet.com/blog/threat-research/deep-dive-icedid-malware-analysis-of-child-processes.html](https://www.fortinet.com/blog/threat-research/deep-dive-icedid-malware-analysis-of-child-processes.html)**\n\nJuly 22, 2019\n\nThreat Research\n\nBy [Kai Lu | July 22, 2019](https://www.fortinet.com/blog/search?author=Kai+Lu)\n**_FortiGuard Labs Threat Analysis Report Series_**\n\nIn [Part II of this blog series, we identified three child processes that were created by the](https://www.fortinet.com/blog/threat-research/icedid-malware-analysis-part-two.html)\nIcedID malware. In Part III below, we’ll provide a deep analysis of those child processes.\n\nLet’s get started!\n\n**0x01 Child process A (entry offset: 0x168E)**\n\nThis first child process is primarily responsible for performing web injection in browsers and\nacting as a proxy to inspect and manipulate traffic. It can also hook key functions in\nbrowsers.\n\nThe following is the pseudo code of the entry point.\n\nFigure 1. The pseudo code of the entry point in the trampoline code\n\n\n-----\n\nIn this function, the process first unhooks the RtlExitUserProcess API and then loads a\nnumber of dynamic libraries. The function sub_0x1A9F() is the core function.\n\nFigure 2. The core function sub_0x1A9F()\n\nHere’s a list of the key functionalities of this function.\n\n1.   Build a C2 server list\n\n2.   Create a thread to set IPC with file mapping technique\n\n3.   Create a thread and then call the QueueUserAPC function to add a user-mode\nasynchronous procedure call (APC) object to the APC queue of the specified thread. In APC,\nit can read the DAT config file, decrypt it with an RC4 key, and then decompress the data as\nfollows.\n\nFigure 3. The decrypted web injection DAT config file\n\nThis DAT config file is used for performing web injections. It uses a Magic number, “zeus”.\nIcedID then uses a customized algorithm to decode the content. The following is the\ndecompressed data.\n\nFigure 4. The decompressed data of web injection\n\n4. Add self-signed certificate into the certificate store and then create a proxy server which is\nbound to 127.0.0.1 on TCP port 61420. Next, it calls the RegisterWaitForSingleObject\nfunction to register a WSA (Windows Socket API) event handler, then uses the socket of the\ninitialized proxy server to handle all connect, send, and receive network requests.\n\nFigure 5. Proxy server handles network requests\n\nAdditionally, in order to perform a MiTM attack on SSL connections, the proxy server has to\ngenerate a certificate and add it into the cert store. The following is that implementation.\n\nFigure 6. Adding a self-signed cert into the cert store\n\nWe can also see that this svchost.exe child process is listening on TCP port 61420.\n\n5. Create a thread to perform code injection into the browser. The following is the thread\nfunction of the browser code injection.\n\nFigure 7. The browser injection function\n\nIt uses the ZwQuerySystemInformation function to gather a list of all current running\nprocesses. If a browser process is found, it performs code injection into the browser process\nand sets up a hook on the ZwWaitForSingleObject function. The following is the function that\n\n\n-----\n\nchecks to see if a running process is a browser process. It first generates a hash with the\nprocess name using a specified algorithm. Then, it compares the hash with the given hash of\nfour browsers: Firefox, Edge, IE, and Chrome.\n\nFigure 8. Checking the hash of the process name\n\nBefore performing its code injection, it first checks to see if this process is running on 64 bits\nby calling the IsWow64Process function. It then performs a code injection into the browser\nprocess, and depending on the process bits version, it calls the corresponding hook function\nto set up a hook on the ZwWaitForSingleObject function.\n\nFigure 9. Process injection and setting up a hook in a browser\n\nHere we will use Firefox to demonstrate how it performs its process injection and sets up a\nhook.\n\nFigure 10. Process injection into Firefox\n\nIt sets up a hook on the ZwWaitForSingleObject API in the Firefox process as follows.\n\nFigure 11. Hooked ZwWaitForSingleObject function\n\nWhen Firefox calls the ZwWaitForSingleObject function, it jumps to the trampoline code. The\nentry point of trampoline code is at offset 0x1856 from the injected memory region.\n\nLet’s take a closer look at the trampoline code (offset:0x1856).\n\nIn this trampoline code, it first unhooks the ZwWaitForSingleObject API. Then it sets up a\nhook on the SSL_AuthCertificateHook API (in nss3.dll for Firefox.) The\nnss3.SSL_AuthCertificateHook function specifies a certificate authentication callback\nfunction that is called to authenticate an incoming certificate.\n\nThe following is the hooked nss3.SSL_AuthCertificateHook function.\n\nFigure 12. The hooked nss3.SSL_AuthCertificateHook function\n\nIt configures the nss3.SSL_AuthCertificateHook function to always return SECSuccess.\n\n_Note that it can set up a hook for browser-specific functions depending on the type of_\n_browser. However, we won’t be providing details for any other browsers in this blog._\n\nNext, it continues to set up a hook on the connect API in ws2_32.dll. The following is the\nhooked connect API.\n\nFigure 13. The hooked connect API in ws2_32.dll\n\nThe following is the pseudo code of the trampoline code for the hooked connect API.\n\n\n-----\n\nFigure 14. The pseudo code of the trampoline code for the hooked connect API\n\nOnce the connect function returns 0 (the connection has succeeded), it sends 12 bytes of\ndata to proxy server 127.0.0.1:61420, which was created in this svchost.exe child process.\nThe captured traffic is shown in Figure 15.\n\nFigure 15. Brower sends 12 bytes of data to proxy server\n\nThe structure of these 12 bytes consists of four parts, as follows:\n\n_0x00: Unknown_\n\n_0x04: Target website’s IP address_\n\n_0x08: Port_\n\n_0x0A: Browser type_\n\n**0x02 Child Process B (entry offset: 0x1E0A)**\n\nThis second child process is used to communicate with the C2 server. It will attempt to send\nan HTTP request to the C2 server via WebSocket, as follows.\n\nFigure 16. Requesting data from the C2 via WebSocket\n\nIt also communicates with the parent svchost.exe process using a mapping file technique.\nAnd, depending on the shared info, it may attempt to make network requests to a C2 server\nover SSL, and then create a new process, perform code injections, and set up a hook on the\nRtlExitUserProcess function.\n\n**0x03 Child Process C (entry offset: 0x10DF)**\n\nThis process communicates with the parent svchost.exe process by using a mapping file\ntechnique. It is also able to perform some registry operations.\n\n**0x04 Solution**\n\nThis malicious PE file has been detected as “W32/Kryptik.GTSU!tr” by the FortiGuard\nAntiVirus service.\n\nThe C2 server list has been rated as “Malicious Websites” by the FortiGuard WebFilter\nservice.\n\n**0x05 Conclusion**\n\n\n-----\n\nIn this series of posts, I have provided a detailed analysis of a new IcedID malware sample.\nThe entire detailed analysis is divided into three parts. The first two part are available here:\n[Part I: Unpacking, Hooking, and Process Injection and](https://www.fortinet.com/blog/threat-research/icedid-malware-analysis-part-one.html) Part II: Analysis of the Core IcedID\nPayload (Parent Process).\n\nIcedID is a sophisticated and complicated banking trojan that performs web injection in\nbrowsers and acts as proxy to inspect and manipulate traffic. It is designed to steal\ninformation – such as credentials – from victims and then send that stolen information to\nattacker-controlled servers. To accomplish this, IcedID uses a large number of hooking and\nprocess injection techniques, and it also disguises itself as several svchost.exe processes,\nwhich we examined in this deep dive analysis series.\n\n_[Learn more about FortiGuard Labs and the FortiGuard Security Services portfolio.](https://www.fortinet.com/fortiguard/threat-intelligence/threat-research.html?utm_source=nreleaseblog&utm_campaign=2018-q2-fortiguardlabs-cta)_ _Sign_\n_up for our weekly FortiGuard Threat Brief._\n\n_[Read about the FortiGuard Security Rating Service, which provides security audits and best](https://www.fortinet.com/support-and-training/support-services/fortiguard-security-subscriptions/security-rating.html?utm_source=blog&utm_campaign=2018-blog-security-rating-service)_\n_practices._\n\n## Related Posts\n\nCopyright © 2022 Fortinet, Inc. All Rights Reserved\n\n[Terms of ServicesPrivacy Policy](https://www.fortinet.com/corporate/about-us/legal.html)\n| Cookie Settings\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-07-22 - A Deep Dive Into IcedID Malware- Part III - Analysis of Child Processes.pdf"
    ],
    "report_names": [
        "2019-07-22 - A Deep Dive Into IcedID Malware- Part III - Analysis of Child Processes.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536250,
    "ts_updated_at": 1743041150,
    "ts_creation_date": 1653751267,
    "ts_modification_date": 1653751267,
    "files": {
        "pdf": "https://archive.orkl.eu/9daea27775e51cec2d3ba9c12e7e745bb72f5fa6.pdf",
        "text": "https://archive.orkl.eu/9daea27775e51cec2d3ba9c12e7e745bb72f5fa6.txt",
        "img": "https://archive.orkl.eu/9daea27775e51cec2d3ba9c12e7e745bb72f5fa6.jpg"
    }
}