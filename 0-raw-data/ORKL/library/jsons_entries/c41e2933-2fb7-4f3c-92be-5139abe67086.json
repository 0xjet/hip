{
    "id": "c41e2933-2fb7-4f3c-92be-5139abe67086",
    "created_at": "2023-01-12T15:00:30.189149Z",
    "updated_at": "2025-03-27T02:14:05.075021Z",
    "deleted_at": null,
    "sha1_hash": "5f141a75a25459c89f74dd3173e9f7730b73306c",
    "title": "2022-09-09 - BUGHATCH Malware Analysis",
    "authors": "",
    "file_creation_date": "2022-10-02T12:02:32Z",
    "file_modification_date": "2022-10-02T12:02:32Z",
    "file_size": 4084876,
    "plain_text": "# BUGHATCH Malware Analysis\n\n**elastic.co/security-labs/bughatch-malware-analysis**\n\n_Malware analysis of the BUGHATCH downloader._\n\nBy\n\nSalim Bitam\n\n09 September 2022\n\n## Key takeaways\n\nElastic Security Labs is releasing a BUGHATCH malware analysis report from a recent\n[campaign](https://www.elastic.co/security-labs/cuba-ransomware-campaign-analysis)\nThis report covers detailed code analysis, network communication protocols, command\nhandling, and observed TTPs\n[From this research we produced a YARA rule to detect the BUGHATCH downloader](https://github.com/elastic/protections-artifacts/blob/main/yara/rules/Windows_Trojan_Bughatch.yar)\n\n## Preamble\n\n\n-----\n\nBUGHATCH is an implant of a custom C2 deployed during the CUBA ransomware campaigns\nwe observed in February of 2022, this tool was most likely built by the threat actor themselves\nas it was not used previously.\n\nBUGHATCH is capable of downloading and executing commands and arbitrary code, it gives\nthe operator the freedom to execute payloads with different techniques like reflection,\nshellcode execution, system command execution, and so on. The samples we have seen\nwere not obfuscated and were deployed using a custom obfuscated in-memory dropper\n[written in PowerShell and referred to as TERMITE by Mandiant.](https://www.mandiant.com/resources/unc2596-cuba-ransomware)\n\nIn this document, we will go through the execution flow of BUGHATCH highlighting its\nfunctionalities and code execution techniques, a YARA rule and the MITRE ATT&CK mapping\ncan be found in the appendix.\n\nIn this analysis we will describe the following:\n\nToken adjustment\nInformation collection\nThreading and thread synchronization\nNetwork communication protocol\nCommand handling\n\nAdditional BUGHATCH resources\n\nFor information on the CUBA ransomware campaign and associated malware analysis, check\nout our blog posts detailing this:\n\n## Static analysis\n\n**SHA256** F1325F8A55164E904A4B183186F44F815693A008A9445D2606215A232658C3CF\n\n**File Size** 35840 bytes\n\n\n**File**\n**Type:**\n\n\nWin32 executable\n\n\n**Signed?** No\n\n**Packer?** No\n\n**Compiler** Visual Studio 2017 - 15.5.0 preview 2\n\n\n-----\n\n**Compile**\n**Time**\n\n\nSun Feb 06 21:05:18 2022 | UTC\n\n\n**Entropy** 6.109\n\n### Sections\n\n**Name** **Virtual**\n\n**Address**\n\n\n**Virtual**\n**Size**\n\n\n**Raw**\n**Size**\n\n\n**Entropy** **MD5**\n\n\n.text 0x1000 0x6000 0x5400 5.933 A6E30CCF838569781703C943F18DC3F5\n\n.rdata 0x7000 0x3000 0x2A00 6.217 9D9AD1251943ECACE81644A7AC320B3C\n\n.data 0xA000 0x1000 0x400 1.163 B983B8EB258220628BE2A88CA44286B4\n\n.reloc 0xB000 0x424 0x600 5.235 39324A58D79FC5B8910CBD9AFBF1A6CB\n\n## Code analysis\n\nBUGHATCH is an in-memory implant loaded by an obfuscated PowerShell script that decodes\nand executes an embedded shellcode blob in its allocated memory space using common\nWindows APIs (VirtualAlloc, CreateThread, WaitForSingleObject).\n\nThe PowerShell loader uses inline C# to load APIs needed for shellcode injection as seen in\nthe following pseudocode.\n\n\n-----\n\nPseudocode PowerShell inline C#\nThe PowerShell script is obfuscated with random functions and variable names and contains\nthe shellcode in a reverse-Base64 format.\n\nPseudocode embedded shellcode in Base64 format\nThe script first decodes the reverse-Base64 encoded data, then allocates a memory region\nwith VirtualAlloc before copying the shellcode into it. Finally, the script executes the\nshellcode by creating a new thread with the CreateThread API.\n\nPseudocode PowerShell creates a new thread to execute the shellcode\nThe shellcode downloads another shellcode blob and the encrypted PE implant from the C2\nserver, this second shellcode decrypts and reflectively loads the PE malware.\n\nThis section dives deeper into the BUGHATCH execution flow, threading and encryption\nimplementation, communication protocol with C2, and finally supported commands and\npayload execution techniques implemented.\n\nThe following is a diagram summarizing the execution flow of the implant:\n\n\n-----\n\nExecution flow diagram of BUGHATCH\n\n\n-----\n\nPseudocode of the main function\n\n### Token adjustment\n\nThe implant starts by elevating permissions using the SeDebugPrivilege method, enabling\nthe malware to access and read the memory of other processes. It leverages common\nWindows APIs to achieve this as shown in the pseudocode below:\n\n\n-----\n\n### Information collection\n\nThe malware collects host-based information used to fingerprint the infected system, this\ninformation will be stored in a custom structure that will be 2-byte XOR encrypted and sent to\nthe C2 server in an HTTP POST request.\n\nThe following lists the collected information:\n\nCurrent value of the performance counter\nNetwork information\nSystem information\nToken information\nDomain and Username of the current process\nCurrent process path\n\n**Current value of the performance counter**\n\nUsing the QueryPerformanceCounter API, it collects the amount of time since the system\nwas last booted. This value will be used to compute the 2-byte XOR encryption key to encrypt\ncommunications between the implant and the C2 server, a detailed analysis of the encryption\nimplementation will follow.\n\n\n-----\n\nPseudocode QueryPerformanceCounter function\n\n**Network information**\n\nIt collects the addresses of network interfaces connected to the infected machine by using the\n**GetIpAddrTable Windows API.**\n\nPseudocode collecting interface addresses\n\n**System information**\n\nBUGHATCH collects key system information which includes:\n\nWindows major release, minor release, and build number\nProcessor architecture (either 32-bit or 64-bit)\nComputer name\n\n\n-----\n\nPseudocode collecting system information\n\n**Token information**\n\nThe agent proceeds to collect the current process token group membership, it invokes the\n**AllocateAndInitializeSid API followed by the CheckTokenMembership API, concatenating**\nthe [SDDL SID strings for every group the process token is part of. While not unique to](https://docs.microsoft.com/en-us/windows/win32/secauthz/sid-strings)\nBUGHATCH, this is detected by Elastic's Enumeration of Privileged Local Groups\nMembership detection rule.\n\nPseudocode collecting token group membership information\n\n\n-----\n\n**Domain and username of the current process**\n\nThe malware opens a handle to the current process with OpenProcessToken and gets the\nstructure that contains the user account of the token with GetTokenInformation. It then\nretrieves the username and domain of the user account with the LookupAccountSidW API\nand concatenates the 2 strings in the following format: DOMAIN\\USERNAME.\n\n**Current process path**\n\nFinally, it collects the current process path with GetModuleFileNameW. The malware then\nencrypts the entire populated structure with a simple 2-byte XOR algorithm, this encryption\nimplementation is detailed later in the report.\n\n## Threading and thread synchronization\n\nThe implant is multithreaded; it uses two different linked lists, one is filled with the commands\nreceived from the C2 server and the other is filled with the output of the commands executed.\n\nIt spawns 5 worker threads, each handling a command received from the C2 server by\naccessing the appropriate linked list using the CriticalSection object. The main process’\nthread also retrieves the command's output from the second linked list using the\n\n\n-----\n\n**CriticalSection object for synchronization purposes, to avoid any race conditions.**\n\nPseudocode of the thread creation function\n\n## Network communication protocol\n\nIn this section we will detail:\n\nBase communication protocol\nEncryption implementation\n\nThe implant we analyzed uses HTTP(S) for communications. On top of the SSL encryption of\nthe protocol, the malware and C2 encrypt the data with a 2-byte XOR key computed by the\nmalware for each new session. The values to compute the 2-byte XOR key are prepended at\nthe beginning of the base protocol packet which the server extracts to decrypt/encrypt\ncommands.\n\nWhen launched, the malware will first send an HTTP POST request to the C2 server\ncontaining all the collected information extracted from the victim’s machine, the C2 then\nresponds with the operator’s command if available, or else the agent sleeps for 60 seconds.\nAfter executing the command and only if the output of the executed command is available, the\nmalware will send a POST request containing both the collected information and the\ncommand’s output, otherwise, it sends the collected information and waits for new commands.\n\n\n-----\n\nExample of an implant HTTP POST request to an emulated C2 server\n\n### Base communication protocol\n\nThe author(s) of BUGHATCH implemented a custom network protocol, the following is the\nsyntax that the agent and server use for their communication:\n\nBUGHATCH agent and server communications\n\n**XOR key values: The values to compute the 2-byte XOR encryption key used to**\nencrypt the rest of the data\n**Separator: A static value (0x389D3AB7) that separates Msg chunks, example: the**\nserver can send different instructions in the same HTTP request separated by the\n**Separator**\n**Chunk length: Is the length of the Msg, Separator and Chunk length**\n**Msg: Is the message to be sent, the message differs from the agent to the server.**\n\nWe will dive deeper into the encapsulation of the Msg for both the agent and the server.\n\nPseudocode extracting commands according to the separator value\n\n### Encryption implementation\n\nThe malware uses 2-byte XOR encryption when communicating with the C&C server; a 2-byte\nXOR key is generated and computed by the implant for every session with the C2 server.\n\n\n-----\n\nThe agent uses two DWORD values returned by QueryPerformanceCounter API as stated\nearlier, it then computes a 2-byte XOR key by XOR-encoding the DWORD values and then\nmultiplying and adding hardcoded values. The following is a Python pseudocode of how the\nKEY is computed:\n```\ntmp = (PerformanceCount[0] ^ PerformanceCount[1]) & 0xFFFFFFFF\n\nXorKey = (0x343FD * tmp + 0x269EC3)& 0xFFFFFFFF\n\nXorKey = p16(XorKey >> 16).ljust(2, b'\\x00')\n\n```\nPseudocode of the encryption implementation\n\n## Command handling\n\nIn this section, we will dive deeper into the functionalities implemented in the agent and their\nrespective Msg structure that will be encapsulated in the base communication protocol\nstructure as mentioned previously.\n\nOnce the working threads are started, the main thread will continue beaconing to the C2\nserver to retrieve commands. The main loop is made up of the following:\n\nSend POST request\nDecrypt the received command and add it to the linked list\nSleep for 60 seconds\n\n\n-----\n\nA working thread will first execute the RemoveEntryRecvLinkedList function that accesses\nand retrieves the data sent by the C2 server from the linked list.\n\nPseudocode retrieves data sent by the C2\nThe thread will then de-encapsulate the data received from the C2 and extract the\n**Msg(Command). The malware implements different functionalities according to a command**\nflag, the table below illustrates the functionalities of each command:\n\nCommand FLAG Description\n\n1 Group functions related to code and command execution\n\n2 Group functions related to utilities like impersonation and migration\n\n3 Process injection of a PE file in a suspended child process\n\n### Command 1\n\nThis command gives access to functionalities related to payload execution, from DLL to PE\nexecutable to PowerShell and cmd scripts.\n\nSome of the sub-commands use pipes to redirect the standard input/output of the child\nprocess, which enables the attacker to execute payloads and retrieve its output, for example,\nPowerShell or Mimikatz, etc…\n\nThe following is the list of sub commands:\n\n\n-----\n\nSub\nCommand\nFlag\n\n\nFunction Name Functionality description\n\n\n2 **ReflectivelyExecutePERemote** Reflectively loads PE files in a child process\nand redirects its standard input output, the\noutput will be sent to the operator C2 server\n\n3 **DropPEDiskExecute** Drops a PE file to disk and executes it, the\nexecution output is then sent to the\noperator’s C2 server\n\n4 **SelfShellcodeExecute** Executes a shellcode in the same process\n\n5 **RemoteShellcodeExecute** Executes a shellcode in a suspended\nspawned child process\n\n6 **ExecuteCmd** Executes a CMD script/command\n\n7 **ExecutePowershell** Executes a Powershell script/command\n\n9 **ReflectivelyLoadDllRemote** Executes a DLL reflectively in a remote\nprocess using CreateRemoteThread API\n\nThe following is the structure that is used by the above commands:\n```\nstruct ExecutePayloadCommandStruct\n\n{\n\n DWORD commandFlag;\n\n DWORD field_0;\n\n DWORD subCommandFlag_1;\n\n DWORD readPipeTimeOut_2;\n\n DWORD payloadSize_3;\n\n DWORD commandLineArgumentSize_4;\n\n DWORD STDINDataSize_5;\n\n CHAR payload_cmdline_stdin[n];\n\n};Read more\n\n```\n**commandFlag: Indicates the command**\n**subCommandFlag: Indicates the subcommand**\n**readPipeTimeOut: Indicates the timeout for reading the output of child processes from**\na pipe\n**payloadSize: Indicates the payload size**\n\n\n-----\n\n**commandLineArgumentSize: Indicates length of the command line arguments when**\nexecuting the payload, example a PE binary\n**STDINDataSize: Indicates the length of the standard input data that will be sent to the**\nchild process\n**Payload_cmdline_stdin: Can contain the payload PE file for example, its command**\nline arguments and the standard input data that will be forwarded to the child process,\nthe malware knows the beginning and end of each of these using their respective length.\n\n**ReflectivelyExecutePERemote**\n\nThe agent reflectively loads PE binaries in the memory space of a created process in a\nsuspended state (either cmd.exe or svchost.exe). The agent leverages anonymous\n(unnamed) pipes within Windows to redirect the created child process's standard input and\noutput handles. It first creates an anonymous pipe that will be used to retrieve the output of\nthe created process, then the pipe handles are specified in the STARTUPINFO structure of\nthe child process.\n\nPseudocode for anonymous pipe creation\nAfter creating the suspended process, the malware allocates a large memory block to write\nshellcode and a XOR encrypted PE file.\n\nThe shellcode will 2-byte XOR decrypt and load the embedded PE similar to (Command 3).\nThis command can load 64bit and 32bit binaries, each architecture has its own shellcode PE\nloader, after injecting the shellcode it will point the instruction pointer of the child process’s\nthread to the shellcode and resume the thread.\n\n\n-----\n\nPseudocode of Reflective Loading PE into child processes\nThe following is an example of a packet captured from our custom emulated C2 server, we\ncan see the structure discussed earlier on the left side and the packet bytes on the right side,\nfor each command implemented in the malware, a packet example will be given.\n\nExample of a ReflectivelyExecutePERemote command received from an emulated C2\n\n**DropPEDiskExecute**\n\nWith this subcommand, the operator can drop a PE file on disk and execute it. The agent has\n3 different implementations depending on the PE file type, GUI Application, CUI (Console\nApplication), or a DLL.\n\nFor CUI binaries, the malware first generates a random path in the temporary folder and\nwrites the PE file to it using CreateFileA and WriteFile API.\n\n\n-----\n\nPseudocode\n\nwriting payload to disk\nIt then creates a process of the dropped binary file as a child process by redirecting its\nstandard input and output handles; after execution of the payload the output is sent to the\noperator’s C2 server.\n\nFor GUI PE binaries, the agent simply writes it to disk and executes it directly with\n**CreateProcessA API.**\n\nAnd lastly, for DLL PE files, the malware first writes the DLL to a randomly generated path in\nthe temporary folder, then uses c:\\windows\\system32\\rundll32.exe or\n**c:\\windows\\syswow64\\rundll32.exe (depending on the architecture of the DLL) to run either**\nan exported function specified by the operator or the function start if no export functions were\nspecified.\n\nPseudocode running the payload dropped by DropPEDiskExecute function\n\n\n-----\n\nExample of a SelfShellcodeExecute command received from an emulated C2\n\n**SelfShellcodeExecute**\n\nThis subcommand tasks the agent to execute shellcode in its own memory space by\nallocating a memory region using VirtualAlloc API and then copying the shellcode to it, the\nshellcode is executed by creating a thread using CreateThread API.\n\nPseudocode of SelfShellcodeExecute command\n\nExample of a SelfShellcodeExecute command received from an emulated C2\n\n**RemoteShellcodeExecute**\n\nThis sub-command can be used to execute a 32-bit or a 64-bit position independent shellcode\nin another process memory space.\n\nSimilarly to the SpawnAgent subcommand, the malware creates a suspended svchost.exe\nprocess with CreateProcessA API, allocates a memory region for the shellcode sent by the\nC2 server with VirtualAllocEx, and writes to it with WriteProcessMemory, it then sets the\nsuspended thread instruction pointer to point to the injected shellcode with\n**SetThreadContext and finally it will resume the thread with ResumeThread to execute the**\npayload.\n\n\n-----\n\nPseudocode writes\n\nshellcode to remote process\n\nPseudocode set EIP of child process using SetThreadContext\n\nExample of a RemoteShellcodeExecute command received from an emulated C2\n\n**ExecuteCmd and ExecutePowershell**\n\nAn operator can execute PowerShell scripts or CMD scripts in the infected machine, the\nmalware can either write the script to a file in the temporary folder with a randomly generated\nname as follow: TEMP<digits>.PS1 for PowerShell or TEMP<digits>.CMD for a Command\nshell. The malware then passes parameters to it if specified by the malicious actor and\nexecutes it, the malware uses named pipes to retrieve the output of the PowerShell process.\n\n\n-----\n\nPseudocode of ExecuteCmd command\n\nExample of an ExecutePowershell command received from an emulated C2\n\n**ReflectivelyLoadDllRemote**\n\nExecute reflectively a 32-bit or 64-bit DLL in a process created in a suspended state, the\nfollowing summarizes the execution flow:\n\nCheck if the PE file is a 32 or 64-bit DLL\nCreate a suspended svchost.exe process\nAllocate memory for the DLL and the parameter for the DLL if specified by the C2\ncommand with the VirtualAllocEx API\nWrite to the remotely allocated memory withthe WriteProcessMemory API the DLL and\nthe parameter if specified\nCreate a remote thread to execute the injected DLL with the CreateRemoteThread API\n\n\n-----\n\nPseudocode of a ReflectivelyLoadDllRemote command\n\nExample of a ReflectivelyLoadDllRemote command received from an emulated C2\n\n### Command 2\n\nThe command 2 has multiple sub functionalities as shown in the command table above,\naccording to a subCommandFlag the malware can do 6 different operations as follows:\n\nSub Command Flag Function Name Functionality description\n\n1 ExitProcess Exit process\n\n2 SelfDeleteExitProcess Self delete and exit process\n\n3 SpawnAgent64 Spawn 64-bit agent\n\n\n-----\n\n4 SpawnAgent32 Spawn 32-bit agent\n\n0x1001 ImpersonateToken Impersonate explorer\n\n0x1002 MigrateC2 Change C2 config\n\nThe following is the structure that is used by the above commands:\n```\nstruct ImpersonateReplicateStruct\n\n{\n\n int subCommandFlag;\n\n int impersonateExplorerToken;\n\n char padding[16];\n\n __int16 isParameterSet;\n\n WCHAR w_parameters[n];\n\n};\n\n```\n**ExitProcess**\n\nCalls the ExitProcess(0) API to terminate.\n\nExample of an ExitProcess command received from an emulated C2\n\n**SelfDeleteExitProcess**\n\nThe agent gets the PATH of the current process with GetModuleFileNameA and then\nexecutes the following command to self-delete: cmd.exe /c del FILEPATH >> NUL using\n**CreateProcessA then simply exit the process with ExitProcess(0).**\n\nExample of a SelfDeleteExitProcess command received from an emulated C2\n\n**SpawnAgent64 and SpawnAgent32**\n\nWhen subcommands 3 or 4 are specified, the malware will spawn another agent on the same\nmachine depending on the subcommand sent by the C2, as shown in the table above.\n\nThe malware first retrieves the C2 IP address embedded in it, it will then do an HTTP GET\nrequest to download a packed agent in shellcode format, in the sample we analyzed\n**/Agent32.bin URI is for the 32-bit agent, and /Agent64.bin is for 64-bit the agent.**\n\n\n-----\n\nPseudocode spawning another agent\nThe malware then creates a suspended svchost.exe process with CreateProcessA API,\nwrites the agent shellcode to the process, sets its instruction pointer to point to the injected\nshellcode with SetThreadContext, and finally it will resume the thread with ResumeThread\nto execute the injected payload.\n\nExample of a SpawnAgent32 command received from an emulated C2\n\n**ImpersonateToken**\n\nThis subcommand is specific to process tokens; an attacker can either impersonate the\n**explorer.exe token or create a token from credentials (Domain\\Username, Password) sent by**\nthe C2 to spawn another instance of the current process.\n\nPseudocode ImpersonateToken command\nIt will first check if the current process is a local system account or local service account or\nnetwork service account by testing whether the given process token is a member of the group\nwith the specified RID (SECURITY LOCAL SYSTEM RID,\n\n\n-----\n\n**SECURITY_LOCAL_SERVICE_RID, SECURITY_NETWORK_SERVICE_RID) respectively.**\n\nPseudocode check token group membership\nThen depending if the operator specified credentials or not, the malware will first call\n**LogonUserW with the Domain\\User and password to create a token then it will spawn**\nanother instance of the current process with this token.\n\nPseudocode LogonUserW to create a token\nIf not, the implant will impersonate the explore.exe process by duplicating its token with\n**DuplicateTokenEx and then spawn the current process with the duplicated token if no**\ncredentials are specified.\n\nExample of an ImpersonateToken command received from an emulated C2\n\n**MigrateC2**\n\nThe operator can migrate the implant to another C2 server by specifying the subcommand\n**0x1001 with the IP address of the new C2.**\n\nPseudocode migrating the implant\n\n\n-----\n\nExample of a MigrateC2 command received from an emulated C2\n\n### Command 3\n\nWhen command 3 is received the malware will reflectively load a PE file embedded as\npayload in the C&C request in another process's memory space, the following is an overview\nof the execution:\n\nDetermine the type and architecture of the PE file\nCreate a suspended process\nAllocate a large memory in the suspended process\nWrite a shellcode in the allocated memory that will locate, decrypt and reflectively load\nthe PE file\n2-byte XOR encrypt the PE file and append it after the shellcode\nSet the EIP context of the suspended process to execute the shellcode\n\nThe shellcode will then reflectively load the PE file\n\nPseudocode for Command 3's main logic\nThe agent first parses the PE file received from the C2 server to determine the type and\narchitecture of the PE file.\n\n\n-----\n\nPseudocode determines the PE file architecture\nAnd according to this information, a Windows signed executable will be chosen to inject into.\n\nIf the PE file is CUI (Console User Interface), the malware will choose cmd.exe, however, if it\nis GUI (Graphical User Interface) or a DLL PE file it will choose svchost.exe.\n\n\n-----\n\nOptions for malware to inject into\nThe malware will then create a suspended process with CreateProcessA API (either\n**cmd.exe or svchost.exe) and allocate a large amount of memory with VirtualAllocEx in the**\ncreated process, it will then copy a position independent shellcode stored in the .rdata section\nto the newly allocated memory that is responsible for locating according to a specific tag the\nappended PE file, decrypt it and reflectively load it in memory.\n\nThen it appends after the shellcode a 12 bytes structure composed of a tag, the size of the PE\nfile, and a 2-byte XOR key.\n\nIt will then 2-byte XOR encrypt the PE file and append it after the structure, the following is an\noverview of the written data to the allocated memory:\n\nSHELLCODE TAG PE SIZE 2-byte XOR KEY 2-byte XOR encrypted PE file\n\n\n-----\n\nPseudocode write shellcode and PE to child process\nThe agent will then set the thread context with SetThreadContext and point the instruction\npointer of the suspended process to the shellcode then it will simply resume the execution\nwith ResumeThread.\n\nThe shellcode will first locate the 2-byte XOR encrypted PE file according to the tag value\n(0x80706050), it will then 2-byte XOR decrypt it and load it reflectively on the same process\nmemory.\n\n## Observed adversary tactics and techniques\n\nElastic uses the MITRE ATT&CK framework to document common tactics, techniques, and\nprocedures that advanced persistent threats use against enterprise networks.\n\n## Detections\n\n### Detection rules\n\nThe following detection rule was observed during the analysis of the BUGHATCH sample.\nThis rule is not exclusive to BUGHATCH activity.\n\n[Enumeration of Privileged Local Groups Membership](https://www.elastic.co/guide/en/security/current/enumeration-of-privileged-local-groups-membership.html#enumeration-of-privileged-local-groups-membership)\n\n### YARA rule\n\n[Elastic Security has created a YARA rule to identify this activity.](https://github.com/elastic/protections-artifacts/blob/main/yara/rules/Windows_Trojan_Bughatch.yar)\n\n\n-----\n\n```\nrule Windows_Trojan_BUGHATCH {\n\n  meta:\n\n    author = “Elastic Security”\n\n    creation_date = \"2022-05-09\"\n\n    last_modified = \"2022-06-09\"\n\n    license = “Elastic License v2”\n\n    os = \"Windows\"\n\n    arch = \"x86\"\n\n    category_type = \"Trojan\"\n\n    family = \"BUGHATCH\"\n\n    threat_name = \"Windows.Trojan.BUGHATCH\"\n\n    reference_sample =\n\"b495456a2239f3ba48e43ef295d6c00066473d6a7991051e1705a48746e8051f\"    \n\n  strings:\n\n  $a1 = { 8B 45 ?? 33 D2 B9 A7 00 00 00 F7 F1 85 D2 75 ?? B8 01 00 00 00 EB 33 C0 }\n\n  $a2 = { 8B 45 ?? 0F B7 48 04 81 F9 64 86 00 00 75 3B 8B 55 ?? 0F B7 42 16 25 00 20\n00 00 ?? ?? B8 06 00 00 00 EB ?? }\n\n  $a3 = { 69 4D 10 FD 43 03 00 81 C1 C3 9E 26 00 89 4D 10 8B 55 FC 8B 45 F8 0F B7 0C\n50 8B 55 10 C1 EA 10 81 E2 FF FF 00 00 33 CA 8B 45 FC 8B 55 F8 66 89 0C 42 }\n\n   $c1 = \"-windowstyle hidden -executionpolicy bypass -file\"\n\n   $c2 = \"C:\\\\Windows\\\\SysWOW64\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe\"\n\n   $c3 = \"ReflectiveLoader\"\n\n   $c4 = \"\\\\Sysnative\\\\\"\n\n   $c5 = \"TEMP%u.CMD\"\n\n   $c6 = \"TEMP%u.PS1\"\n\n   $c7 = \"\\\\TEMP%d.%s\"\n\n   $c8 = \"NtSetContextThread\"\n\n   $c9 = \"NtResumeThread\"\n\n  condition:\n\n    any of ($a*) or 6 of ($c*)\n\n}Read more\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-09 - BUGHATCH Malware Analysis.pdf"
    ],
    "report_names": [
        "2022-09-09 - BUGHATCH Malware Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "d58052ba-978b-4775-985a-26ed8e64f98c",
            "created_at": "2023-09-07T02:02:48.069895Z",
            "updated_at": "2025-03-27T02:02:10.181465Z",
            "deleted_at": null,
            "main_name": "Tropical Scorpius",
            "aliases": [
                "DEV-0978",
                "RomCom",
                "Storm-0978",
                "Tropical Scorpius",
                "UNC2596",
                "Void Rabisu"
            ],
            "source_name": "ETDA:Tropical Scorpius",
            "tools": [
                "COLDDRAW",
                "Cuba",
                "Industrial Spy",
                "PEAPOD",
                "ROMCOM",
                "ROMCOM RAT",
                "SingleCamper",
                "SnipBot"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "4f56bb34-098d-43f6-a0e8-99616116c3ea",
            "created_at": "2024-06-19T02:03:08.048835Z",
            "updated_at": "2025-03-27T02:05:17.365266Z",
            "deleted_at": null,
            "main_name": "GOLD FLAMINGO",
            "aliases": [
                "Tropical Scorpius ",
                "UAC-0132 ",
                "UAC-0132 ",
                "UNC2596 ",
                "Void Rabisu ",
                "REF9019 "
            ],
            "source_name": "Secureworks:GOLD FLAMINGO",
            "tools": [
                " Cobalt Strike",
                " Cuba",
                " Meterpreter",
                " Mimikatz",
                " ROMCOM RAT",
                "Chanitor"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535630,
    "ts_updated_at": 1743041645,
    "ts_creation_date": 1664712152,
    "ts_modification_date": 1664712152,
    "files": {
        "pdf": "https://archive.orkl.eu/5f141a75a25459c89f74dd3173e9f7730b73306c.pdf",
        "text": "https://archive.orkl.eu/5f141a75a25459c89f74dd3173e9f7730b73306c.txt",
        "img": "https://archive.orkl.eu/5f141a75a25459c89f74dd3173e9f7730b73306c.jpg"
    }
}