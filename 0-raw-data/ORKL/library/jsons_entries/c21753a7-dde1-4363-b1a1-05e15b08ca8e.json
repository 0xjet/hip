{
    "id": "c21753a7-dde1-4363-b1a1-05e15b08ca8e",
    "created_at": "2023-01-12T15:04:24.816193Z",
    "updated_at": "2025-03-27T02:05:39.994339Z",
    "deleted_at": null,
    "sha1_hash": "13cbb459ec96c069495b418e98f6d2c59261c7c0",
    "title": "2021-05-12 - Writing a VB6 P-Code Debugger",
    "authors": "",
    "file_creation_date": "2022-05-29T10:48:22Z",
    "file_modification_date": "2022-05-29T10:48:22Z",
    "file_size": 362121,
    "plain_text": "# Writing a VB6 P-Code Debugger\n\n**[decoded.avast.io/davidzimmer/writing-a-vb6-p-code-debugger/](https://decoded.avast.io/davidzimmer/writing-a-vb6-p-code-debugger/)**\n\nby [David ZimmerMay 12, 202110 min read](https://decoded.avast.io/author/davidzimmer/)\n\n## Background\n\n\nMay 12, 2021\n\n\nIn this article we are going to discuss how to write a debugger for `VB6 P-code . This has`\nbeen something I have always wanted to do ever since I first saw the `WKTVBDE P-Code`\n```\nDebugger written by Mr Silver and Mr Snow back in the early 2000’s\n\n```\nThere was something kind of magical about that debugger when I first saw it. It was early in\nmy career, I loved programming in `VB6, and reversing it was a mysterious dark art.`\n\nWhile on sabbatical I finally I found the time to sit down and study the topic in depth. I am\nnow sharing what I discovered along the way.\n\nThis article will build heavily on the previous paper titled VB P-Code Disassembly[1]. In this\npaper we detailed how the run time processes `P-Code and transfers execution between`\nthe different handlers.\n\nIt is this execution flow that we will target to gain control with our debugger.\n\nAn example of the debugger architecture detailed in this paper can be found in the free\n[vbdec pcode disassembler and debugger](http://sandsprite.com/vbdec/)\n\n## Probing\n\nWhen I started researching this topic I wanted to first examine what a process running\nwithin the WKTVBDE P-Code debugger looked like.\n\nA test `P-Code executable was placed alongside a copy of the` `VB runtime with debug`\nsymbols[2]. The executable was launched under `WKTVBDE and then a native debugger`\nwas attached\n\n\n-----\n\nExamining the `P-Code function pointer tables at` `0x66106D14 revealed all the pointers`\nhad been patched to a single function inside the `WKTVBDE.dll`\n\nThis gives us our first hint at how they implemented their debugger. It is also worth noting at\nthis point that the `WKTVBDE debugger runs entirely within the process being debugged,`\nGUI and all!\n\nTo start the debugger, you run loader.exe and specify your target executable. It will then\nstart the process and inject the `WKTVBDE.dll` within it. Once loaded `WKTVBDE.dll will`\nhook the entire base `P-Code handler table with its own function giving it first access to`\nwhatever P-Code is about to execute.\n\nThe debugger also contains:\n\na `P-Code disassembler`\nability to parse all of the nested `VB internal structures`\nability to list all code objects and control events (like on timer or button click)\n\nThis is in addition to the normal debugger UI actions such as data dumping, breakpoint\nmanagement, stack display etc.\n\nThis is A LOT of complex code to run as an injection dll. Debugging all of this would have\nbeen quite a lot of work for sure.\n\nWith a basic idea of how the debugger operated, I began searching the web to find any\nother information I could. I was happy to find an old article by `Mr Silver on` `Woodmann`\n[that I have mirrored for posterity [3].](https://decoded.avast.io/wp-admin/post.php?post=3136&action=edit#ref)\n\nIn this article `Mr Silver lays out the history of their efforts in writing a` `P-Code debugger`\nand gives a template of the hook function they used. This was a very interesting read and\ngave me a good place to start.\n\n## Design Considerations:\n\nLooking forward there were some design considerations I wanted to change in this\narchitecture.\n\nThe first change would be that I would want to move all of the structure parsing,\ndisassembler engine, and user interface code into its own stand alone process. These are\ncomplicated tasks and would be very hard to debug as a `DLL injection .`\n\n\n-----\n\nTo accomplish this task we need an easy to use, stable inter-process communication\n( IPC ) technique that is inherently synchronous. My favorite technique in this category is\nusing `Windows Messages which automatically cause the external process to wait until the`\nwindow procedure has completed before it returns.\n\nI have used this technique extensively to stall malware after it unpacks itself [4]. I have even\nwired it up to a `Javascript engine that interfaces with a remote instance of` `IDA` [5].\n\nThis design will give us the opportunity to freely write and debug the file format parsing,\ndisassembly engine, and user interface code completely independent of the debugger core.\n\nAt this point debugger integration essentially becomes an add on capability of the\ndisassembler. The injection dll now only has to intercept execution and communicate with\nthe main interface.\n\nFor the remainder of this paper we will assume that a fully operational disassembler has\nalready been created and only focus on the debugger specific details.\n\nFor discussions on how to implement a disassembler and a reference implementation on\nstructure parsing please refer to the previous paper [1].\n\n## Implementation\n\nWith sufficient information now in hand it was time to start experimenting with gaining\ncontrol over the execution flow.\n\nOur first task is figuring out how to hook the `P-Code function pointer table. Before we can`\nhook it, we actually need to be able to find it first! This can be accomplished in several\nways. From the `WKTVBDE` authors paper it sounds like they progressed in three main\nstages. First they started with a manually patched copy of the `VB run time and the`\nmodified dll referenced in the import table.\n\nSecond they then progressed to a single supported copy of the run time with hard coded\noffsets to patch. A loader now injecting the debugger dll into the target process. Finally they\nadded the ability to dynamically locate and patch the table regardless of run time version.\n\nThis is a good experimental progression which they detail in depth. The second stage is\nreadily accessible to anyone who can understand this paper and will work sufficiently well. I\nwill leave the details of injection and hooking as an exercise to the reader.\n\nThe basic steps are:\n\nset the memory writable\ncopy the original function pointer table\nreplace original handlers with your own hook procedures\n\n\n-----\n\nThe published sample also made use of self modifying code, which we will seek to avoid. To\nget around this we will introduce individual hook stubs, 1 per table, to record some\nadditional data.\n\nBefore we get into the individual hook stubs, we notice they stored some run time/state\ninformation in a global structure. We will expand on this with the following:\n\n\n-----\n\nFrom the hooking code you will notice that all of the base opcodes in the first table\n(excluding lead byte handlers) all received the same hook. The `Lead_X bytes at the end`\neach received their own procedure.\n\nBelow shows samples of the hook handlers for the first two tables. The other 4 follow the\nsame pattern:\n\nThe hooks for each individual table configure the global `VM structure fields for current lead`\nbyte and table base. The real meat of the implementation now starts in the universal hook\nprocedure.\n\n\n-----\n\nIn the main `PCodeHookProc you will notice that we call out to another function defined as:`\n```\nvoid NotifyUI() .\n\n```\nIt is in this function where we do things like check for breakpoints, handle single stepping\netc. This function then uses the synchronous `IPC to talk to the out of process debugger`\nuser interface.\n\n\n-----\n\nThe debugger UI will receive the step notification and then go into a wait loop until the user\ngives a step/go/stop command. This has the effect of freezing the debugee until the\n```\nSendMessage handler returns. You can find a sample implementation of this in the\n\n```\n`SysAnalyzer ApiLogger source` [6].\n\nThe reason we call out to another function from `PCodeHookProc is because it is written as`\na naked function in assembler. Once free from this we can now easily implement more\ncomplex logic in C.\n\n## Further steps:\n\nOnce all of the hooks are implemented you still need a way to exercise control over the\ndebuggee. When the code is being remotely frozen, the remote GUI is actually still free to\nsend the frozen process new commands over a separate `IPC back channel.`\n\nIn this manner you can manage breakpoints, change step modes, and implement lookup\nservices through runtime exports such as `rtcTypeName .`\n\nThe hook dll can also patch in custom opcodes. The code below adds our own one byte\n\n`NOP` instruction at unused `slot 0x01`\n\nAs hinted at in the comments, features such as live patching of the current opcode, and\n“Set New Origin Here” type features are both possible. These are implemented by the\ndebugger doing direct `WriteProcessMemory calls to the global` `VM struct. The address of`\nthis structure was disclosed in initialization messages at startup.\n\n## Conclusion\n\nWriting a `P-Code debugger is a very interesting concept. It is something that I personally`\nwanted to do for the better part of 20 years.\n\n\n-----\n\nOnce you see all the moving parts up close it is not quite as daunting as it may seem at first\nglance.\n\nHaving a working `P-Code debugger is also a foundational step to learning how the` `P-`\n```\nCode instruction set really works. Being able to watch VB6 P-code run live with integrated\n\n```\nstack diffing and data viewer tools is very instructive. Single stepping at this level of\ngranularity gives you a much clearer, higher level overview of what is going on.\n\nWhile the hook code itself is technically challenging, there are substantial tasks required up\nfront just to get you into the game.\n\nPrerequisites for this include:\n\naccurate parsing of an undocumented file format\na solid disassembly engine for an undocumented `P-Code instruction set`\nuser interface that allows for easy data display and debugger control\n\nFor a reverse engineer, a project such as this is like candy. There are so many aspects to\nanalyze and work on. So many undocumented things to explore. A puzzle with a thousand\npieces.\n\nWhat capabilities can be squeezed out of it? How much more is there to discover?\n\nFor me it is a pretty fascinating journey that also brings me closer to the language that I\nlove. Hopefully these articles will inspire others and enable them to explore as well.\n\n[1] – [VB P-Code Disassembly](https://decoded.avast.io/davidzimmer/vb6-p-code-disassembly/)\n\n[2] – [VB6 runtime with symbols (MD5: EEBEB73979D0AD3C74B248EBF1B6E770)](http://sandsprite.com/vb-reversing/files/msvbvm60.zip)\n\n[3] – [VB P-code Information by Mr Silver](http://sandsprite.com/vb-reversing/files/VB%20P-code%20Information%20by%20Mr%20Silver.html)\n\n[4] – [ApiLogger – Breaking into Malware](http://sandsprite.com/blogs/index.php?uid=7&pid=272&year=2013)\n\n[5] – [IDA JScript](http://sandsprite.com//blogs/index.php?uid=7&pid=361)\n\n[6] – [SysAnalyzer ApiLogger – freeze remote process](https://github.com/dzzie/SysAnalyzer/blob/master/source/injector/Form2.frm#L1280)\n\n[Tagged asdebugger,](https://decoded.avast.io/tag/debugger/) [P-Code,](https://decoded.avast.io/tag/p-code/) [Research,](https://decoded.avast.io/tag/research/) [series,](https://decoded.avast.io/tag/series/) [VB](https://decoded.avast.io/tag/vb/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-05-12 - Writing a VB6 P-Code Debugger.pdf"
    ],
    "report_names": [
        "2021-05-12 - Writing a VB6 P-Code Debugger.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535864,
    "ts_updated_at": 1743041139,
    "ts_creation_date": 1653821302,
    "ts_modification_date": 1653821302,
    "files": {
        "pdf": "https://archive.orkl.eu/13cbb459ec96c069495b418e98f6d2c59261c7c0.pdf",
        "text": "https://archive.orkl.eu/13cbb459ec96c069495b418e98f6d2c59261c7c0.txt",
        "img": "https://archive.orkl.eu/13cbb459ec96c069495b418e98f6d2c59261c7c0.jpg"
    }
}