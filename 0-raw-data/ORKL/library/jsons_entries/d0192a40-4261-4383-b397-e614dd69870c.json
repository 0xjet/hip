{
    "id": "d0192a40-4261-4383-b397-e614dd69870c",
    "created_at": "2023-01-12T15:10:17.61577Z",
    "updated_at": "2025-03-27T02:05:59.040089Z",
    "deleted_at": null,
    "sha1_hash": "3f133c00fc10ac4dc703322dc0146bdd24d062f1",
    "title": "2022-06-27 - Unpacking a JsonPacker-packed sample",
    "authors": "",
    "file_creation_date": "2022-08-18T04:01:24Z",
    "file_modification_date": "2022-08-18T04:01:24Z",
    "file_size": 1569172,
    "plain_text": "# Unpacking a JsonPacker-packed sample\n\n**[cryptax.medium.com/unpacking-a-jsonpacker-packed-sample-4038e12119f5](https://cryptax.medium.com/unpacking-a-jsonpacker-packed-sample-4038e12119f5)**\n\n@cryptax June 27, 2022\n\n[@cryptax](https://cryptax.medium.com/?source=post_page-----4038e12119f5--------------------------------)\n\nJun 27\n\n\n5 min read\n\nWith students of mine, we built a static unpacker (short of public name, I named it\n‚ÄúJsonPacker‚Äù in APKiD). Unfortunately, the static unpacker doesn‚Äôt work for the sample and\nthe students are in for a quick patch before their defense in a few days. Lol. I‚Äôm sure they\nhate me üòÅ The sha256 of the sample is\n```\n2877b27f1b6c7db466351618dda4f05d6a15e9a26028f3fc064fa144ec3a1850, and it dates\n\n```\nback to February 2022.\n\n## Quickly spot the encrypted json filename in the code\n\nThere are many classes, and obfuscated names, so at first it could be a bit disorientating to\nfind the right spot. But I‚Äôve unpacked such samples dozens of time: just search for the class\nwith `attachBaseContext (which is a method found in classes which derive from`\n```\nApplication and which is called at ‚Äúthe very beginning‚Äù).\n\n```\nHead to class CToKhLqQwJbTrQrKg :)\nIn there, head to the object fields which get their initial value in the constructor. Spot the json\nfile `hq.json .`\n\n\n-----\n\nThe encrypted payload is inside hq.json. I like to rename the field to something more\nmeaningful :)\n\n## Spot the place where the file is dynamically loaded\n\nFor such samples, just look where `DexClassLoader is used. I like to use the detailed report`\nof [DroidLysis for that.](http://github.com/cryptax/droidlysis)\n\nDexClassLoader is used in a single place:\nABeJgOnNtJpIcNgRxUkDwXcIwNyTzCyFxXhUsZsWxQuShDpLkUiRyWn\n\n\n-----\n\nGo to that class, and search for `DexClassLoader, you find method` `rigidmiddle .`\n\nThis method loads dynamically the decrypted payload stored on the filesystem in ‚Äúfilename‚Äù\nNow, work your way up to who calls this method, using cross-references:\n```\n   tailcreek\n   guessextra\n   aerobicneutral\n   attachBaseContext : the call to aeronicneutral is at the end of the image below.\n\n```\nParts of code of attachBaseContext. There is lots of junk code. The payload filename is used\n3 times in this screenshots: loadover, ceilingnice, aerobicneutral\n\n## Spot where payload decryption occurs\n```\n   loadover constructs the absolute path of the filename.\n   ceilingnice decrypts the file\n   aerobicneutral loads the decrypted file.\n\n```\n\n-----\n\nIn `ceilingnice, let s follow the calls to the decryption algorithm:`\n```\n   allrather\n   orcharddecide\n\n```\nMethod `orcharddecide loads the asset:`\n\nFirst, the code retrieves an AssetManager. Then it opens the encrypted payload asset. The\ninput stream is the encrypted payload, the output stream will be stored in the location of\nabsolutepath\nThen it reads the asset, decrypts it (this happens inside `futureinherit ), unzips the result`\nand writes it to the output stream.\n\nThis part of code (inside orcharddecide) decrypts the assets and unzips the result.\n```\nfutureinherit calls ratherbanana . It takes an encrypted byte array as input and\n\n```\nreturns a decrypted byte array.\n\n## Understanding the preparation of the key\n```\nratherbanana reads a fixed string (‚ÄúIanj‚Äù for this sample), and I assume it is the key. It\n\n```\nconverts the string to a byte array, then converts it to an integer array in `nomineesign .`\n\nStill lots of junk code. Prepare the decryption key.\n\n\n-----\n\nThe code of `nomineesign is not very long but requires close attention to remove junk code`\n(but not too much: the loop initializing the `convertedkey table is not junk!), and de-`\nobfuscate code.\n\nThe line with StrictMath.hypot is obfuscated.\nFor example, the lign with `hypot is interesting:`\n```\nint cv = (int)StrictMath.hypot(this.timeone('d', 0x1E681L, convertedkey, index),\n0.0);\ntimeone actually returns the index-th byte of convertedkey, i.e\nconvertedkey[index] .\nhypot computes square root of ( convertedkey[index]¬≤ + 0¬≤ ). As 0¬≤ = 0, the variable cv\n\n```\nwill simply receive the value of `convertedkey[index] .`\n\nIn the end, the algorithm boils down to this:\n```\nprivate void swap(int a, int b, int[] array) {\n    int tmp = array[a];\n    array[a]=array[b];\n    array[b]=tmp;\n}\n  private int[] convert_key(byte[] key) {    int[] convertedkey = new\nint[0x100];    int i;    for(i = 0; i < 256; ++i) {      \nconvertedkey[i] = i; // init    }    int j = 0;    int k = 0;    \nwhile(j < 0x100) {      int cv = convertedkey[j];      k =\n(k+cv+key[j%key.length]+0x100) % 0x100;      swap(j, k, convertedkey); //\nswap values      ++j;    }    return convertedkey;}\n\n## Decryption algorithm\n\n```\nThe next step is to understand the decryption algorithm in itself. Actually, there is lots of junk\ncode that can be removed. To start, I focus on where the encrypted input byte array is used.\n```\ndecrypted[i] = this.motionavoid(Math.round(v0_6) ^ encrypted[i]);\n\n```\n\n-----\n\nThe method motionavoid is there just for obfuscation: it merely returns its argument. Also,\nobviously, we only have integers, so Math.round is useless. So, we have `decrypted[i] =`\n```\nv0_6 ^ encrypted[i]; . A few lines above, we have v0_6 : int v0_6 = ckey[(v15 +\nv0_5) % 0x100]; . A few lines above, we have v15 and v0_5 :\nint v15 = this.timeone('b', 5222L, ckey, HMoEsEkXySsLhTyCkZlChSoBfFlPk.counter); //\nckey[counter]this.GfnxRHLRQuDY_713808 = this.KfYicpzIQMgk_598597 * 0x12FC3 +\nthis.RMSmhfBNuxnA_506561 - 50009; // junkint v0_5 = this.timeone('z', 0x179161L,\nckey, v14); // ckey[v14]\n\n```\nThe method `timeone only uses the last two arguments: a table and an index, and returns`\n```\ntable[index] value. Quite strangely, v15 uses a static integer that I have renamed\ncounter . I search where this counter is used:\n\n```\nThe first use basically increments the counter, making sure it remains below 0x100. Then,\ncounter is put in v2 and swapped with another value (energyalmost is a method that\nperforms byte swap). Finally, v15 gets the value of the ckey[counter]\nI work out that `int v15 = ckey[counter]; .`\n\nAs for `v0_5, we have` `v0_5 = ckey[v14] and` `v14 is yet another static counter:` `int`\n```\nv14 = HMoEsEkXySsLhTyCkZlChSoBfFlPk.other_counter; . Same, I search where this\n\n```\nother counter is used, and it‚Äôs basically the same: an increment modulus 0x100, a swap and\n```\nckey[other_counter] . That‚Äôs it! We have all elements to decrypt! The algorithm boils\n\n```\ndown to this:\n\n\n-----\n\nSimplified decryption method. For this sample, the initial key is Ianj . The encrypted byte\narray is the contents of hq.json. I added a length argument because actually in my code the\nhq.json is read into a bigger array, and we only need to decrypt up to the length of hq.json\nfile.\n_Note: the code above uses static variables counter and other_counter, but actually it works_\n_fine with local variables, and probably would be easier to read with local ones._\n\n## Decrypt the payload\n\nTo the key + decryption algorithm, we just need to add something to read `hq.json and`\nwrite to another file. Then, we can unpack!\n\nStatic unpacker works fine :) Hurray!\nThe decrypted file is a Zip file (this was expected: remember that `orcharddecide unzips`\nthe result): inside, there is a `classes.dex` (sha256:\n```\ndae52bbee7f709fae9d91e06229c35b46d4559677f26152d4327fc1601d181be ). It is the\n\n```\npayload of the Xenomorph malware.\n\n## Which class/method does the malware load dynamically?\n\nBefore we decompile this payload, we need to know which method is called. The manifest\nshows the main activity is `com.sniff.sibling.MainActivity . This class is not present in`\nthe wrapping apk‚Ä¶ so it must be in the payload! This will be automatically called by Android\nas soon as it‚Äôs time to launch the main activity.\n\nThe main activity is indeed found in the payload\n\n\n-----\n\nWe ve had enough for a single blog post, but the payload, similarly to many Android botnets,\nuses the Accessibility Services API to overlay windows of given applications.\n\n‚Äî Cryptax\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-06-27 - Unpacking a JsonPacker-packed sample.pdf"
    ],
    "report_names": [
        "2022-06-27 - Unpacking a JsonPacker-packed sample.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536217,
    "ts_updated_at": 1743041159,
    "ts_creation_date": 1660795284,
    "ts_modification_date": 1660795284,
    "files": {
        "pdf": "https://archive.orkl.eu/3f133c00fc10ac4dc703322dc0146bdd24d062f1.pdf",
        "text": "https://archive.orkl.eu/3f133c00fc10ac4dc703322dc0146bdd24d062f1.txt",
        "img": "https://archive.orkl.eu/3f133c00fc10ac4dc703322dc0146bdd24d062f1.jpg"
    }
}