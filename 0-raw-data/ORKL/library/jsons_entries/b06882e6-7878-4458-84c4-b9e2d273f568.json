{
    "id": "b06882e6-7878-4458-84c4-b9e2d273f568",
    "created_at": "2023-01-12T15:06:23.11172Z",
    "updated_at": "2025-03-27T02:16:25.848535Z",
    "deleted_at": null,
    "sha1_hash": "d08e355e459a4fe0ae632fdcfffc13cbe6acb6f2",
    "title": "2021-02-03 - D√©j√† vu-lnerability A Year in Review of 0-days Exploited In-The-Wild in 2020",
    "authors": "",
    "file_creation_date": "2022-05-28T19:56:37Z",
    "file_modification_date": "2022-05-28T19:56:37Z",
    "file_size": 142693,
    "plain_text": "# D√©j√† vu-lnerability\n\n**[googleprojectzero.blogspot.com/2021/02/deja-vu-lnerability.html](https://googleprojectzero.blogspot.com/2021/02/deja-vu-lnerability.html)**\n\nA Year in Review of 0-days Exploited In-The-Wild in 2020\n\nPosted by Maddie Stone, Project Zero\n\n2020 was a year full of 0-day exploits. Many of the Internet‚Äôs most popular browsers had\ntheir moment in the spotlight. Memory corruption is still the name of the game and how the\nvast majority of detected 0-days are getting in. While we tried new methods of 0-day\ndetection with modest success, 2020 showed us that there is still a long way to go in\ndetecting these 0-day exploits in-the-wild. But what may be the most notable fact is that 25%\nof the 0-days detected in 2020 are closely related to previously publicly disclosed\nvulnerabilities. In other words, 1 out of every 4 detected 0-day exploits could potentially have\nbeen avoided if a more thorough investigation and patching effort were explored. Across the\nindustry, incomplete patches ‚Äî patches that don‚Äôt correctly and comprehensively fix the root\ncause of a vulnerability ‚Äî allow attackers to use 0-days against users with less effort.\n\nSince mid-2019, Project Zero has dedicated an effort specifically to track, analyze, and learn\nfrom 0-days that are actively exploited in-the-wild. For the last 6 years, Project Zero‚Äôs mission\nhas been to ‚Äúmake 0-day hard‚Äù. From that came the goal of our in-the-wild program: ‚ÄúLearn\nfrom 0-days exploited in-the-wild in order to make 0-day hard.‚Äù In order to ensure our work is\nactually making it harder to exploit 0-days, we need to understand how 0-days\nare actually being used. Continuously pushing forward the public‚Äôs understanding of 0-day\nexploitation is only helpful when it doesn‚Äôt diverge from the ‚Äúprivate state-of-the-art‚Äù, what\nattackers are doing and are capable of.\n\nOver the last 18 months, we‚Äôve learned a lot about the active exploitation of 0-days and our\n[work has matured and evolved with it. For the 2nd year in a row, we‚Äôre publishing a ‚ÄúYear in](https://googleprojectzero.blogspot.com/2020/07/detection-deficit-year-in-review-of-0.html)\nReview‚Äù report of the previous year‚Äôs detected 0-day exploits. The goal of this report is not to\ndetail each individual exploit, but instead to analyze the exploits from the year as a group,\nlooking for trends, gaps, lessons learned, successes, etc. If you‚Äôre interested in each\n[individual exploit‚Äôs analysis, please check out our root cause analyses.](https://googleprojectzero.blogspot.com/p/rca.html)\n\nWhen looking at the 24 0-days detected in-the-wild in 2020, there‚Äôs an undeniable\nconclusion: increasing investment in correct and comprehensive patches is a huge\nopportunity for our industry to impact attackers using 0-days.\n\nA correct patch is one that fixes a bug with complete accuracy, meaning the patch no longer\nallows any exploitation of the vulnerability. A comprehensive patch applies that fix\neverywhere that it needs to be applied, covering all of the variants. We consider a patch to\nbe complete only when it is both correct and comprehensive. When exploiting a single\n\n\n-----\n\nvulnerability or bug, there are often multiple ways to trigger the vulnerability, or multiple paths\nto access it. Many times we‚Äôre seeing vendors block only the path that is shown in the proofof-concept or exploit sample, rather than fixing the vulnerability as a whole, which would\nblock all of the paths. Similarly, security researchers are often reporting bugs without\nfollowing up on how the patch works and exploring related attacks.\n\nWhile the idea that incomplete patches are making it easier for attackers to exploit 0-days\nmay be uncomfortable, the converse of this conclusion can give us hope. We have a clear\npath toward making 0-days harder. If more vulnerabilities are patched correctly and\ncomprehensively, it will be harder for attackers to exploit 0-days.\n\n## This vulnerability looks familiar ü§î\n\nAs stated in the introduction, 2020 included 0-day exploits that are similar to ones we‚Äôve\nseen before. 6 of 24 0-days exploits detected in-the-wild are closely related to publicly\ndisclosed vulnerabilities. Some of these 0-day exploits only had to change a line or two of\ncode to have a new working 0-day exploit. This section explains how each of these 6 actively\nexploited 0-days are related to a previously seen vulnerability. We‚Äôre taking the time to detail\neach and show the minimal differences between the vulnerabilities to demonstrate that once\nyou understand one of the vulnerabilities, it‚Äôs much easier to then exploit another.\n\n\nProduct Vulnerability\nexploited in-thewild\n\n\nVariant of...\n\n\nMicrosoft Internet Explorer CVE-2020-0674 CVE-2018-8653* CVE-20191367* CVE-2019-1429*\n\nMozilla Firefox CVE-2020-6820 [Mozilla Bug 1507180](https://bugzilla.mozilla.org/show_bug.cgi?id=1507180)\n\nGoogle Chrome CVE-2020-6572 CVE-2019-5870\n\nCVE-2019-13695\n\nMicrosoft Windows CVE-2020-0986 CVE-2019-0880*\n\nGoogle Chrome/Freetype CVE-2020-15999 CVE-2014-9665\n\nApple Safari CVE-2020-27930 CVE-2015-0093\n\n\n-----\n\n - vulnerability was also exploited inthe-wild in previous years\n\n## Internet Explorer JScript CVE-2020-0674\n\nCVE-2020-0674 is the fourth vulnerability that‚Äôs been exploited in this bug class in 2 years.\nThe other three vulnerabilities are CVE-2018-8653, CVE-2019-1367, and CVE-2019-1429. In\nthe [2019 year-in-review we devoted a section to these vulnerabilities. Google‚Äôs Threat](https://googleprojectzero.blogspot.com/2020/07/detection-deficit-year-in-review-of-0.html)\nAnalysis Group attributed all four exploits to the same threat actor. It bears repeating, the\nsame actor exploited similar vulnerabilities four separate times. For all four exploits, the\nattacker used the same vulnerability type and the same exact exploitation method. Fixing\nthese vulnerabilities comprehensively the first time would have caused attackers to work\nharder or find new 0-days.\n\nJScript is the legacy Javascript engine in Internet Explorer. While it‚Äôs legacy, by default it is\nstill enabled in Internet Explorer 11, which is a built-in feature of Windows 10 computers. The\nbug class, or type of vulnerability, is that a specific JScript object, a variable (uses the VAR\nstruct), is not tracked by the garbage collector. I‚Äôve included the code to trigger each of the\nfour vulnerabilities below to demonstrate how similar they are. Ivan Fratric from Project Zero\nwrote all of the included code that triggers the four vulnerabilities.\n\n### CVE-2018-8653\n\n[In December 2018, it was discovered that CVE-2018-8653 was being actively exploited. In](https://msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8653)\nthis vulnerability, the this variable is not tracked by the garbage collector in the\n[isPrototypeof callback. McAfee also wrote a write-up going through each step of this exploit.](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/ie-scripting-flaw-still-a-threat-to-unpatched-systems-analyzing-cve-2018-8653/)\n\nvar objs = new Array();\n\nvar refs = new Array();\n\nvar dummyObj = new Object();\n\nfunction getFreeRef()\n\n{\n\n// 5. delete prototype objects as well as ordinary objects\n\nfor ( var i = 0; i < 10000; i++ ) {\n\nobjs[i] = 1;\n\n}\n\n\n-----\n\nCollectGarbage();\n\nfor ( var i = 0; i < 200; i++ )\n\n{\n\nrefs[i].prototype = 1;\n\n}\n\n// 6. Garbage collector frees unused variable blocks.\n\n// This includes the one holding the \"this\" variable\n\nCollectGarbage();\n\n// 7. Boom\n\nalert(this);\n\n}\n\n// 1. create \"special\" objects for which isPrototypeOf can be invoked\n\nfor ( var i = 0; i < 200; i++ ) {\n\nvar arr = new Array({ prototype: {} });\n\nvar e = new Enumerator(arr);\n\nrefs[i] = e.item();\n\n}\n\n// 2. create a bunch of ordinary objects\n\nfor ( var i = 0; i < 10000; i++ ) {\n\nobjs[i] = new Object();\n\n}\n\n// 3. create objects to serve as prototypes and set up callbacks\n\nfor ( var i = 0; i < 200; i++ ) {\n\nrefs[i].prototype = {};\n\nrefs[i].prototype.isPrototypeOf = getFreeRef;\n\n}\n\n// 4. calls isPrototypeOf. This sets up refs[100].prototype as \"this\" variable\n\n// During callback, the \"this\" variable won't be tracked by the Garbage collector\n\n\n-----\n\n// use different index if this doesn t work\n\ndummyObj instanceof refs[100];\n\n### CVE-2019-1367\n\n[In September 2019, CVE-2019-1367 was detected as exploited in-the-wild. This is the same](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-1367)\nvulnerability type as CVE-2018-8653: a JScript variable object is not tracked by the garbage\ncollector. This time though the variables that are not tracked are in the arguments array in\nthe Array.sort callback.\n\nvar spray = new Array();\n\nfunction F() {\n\n// 2. Create a bunch of objects\n\nfor (var i = 0; i < 20000; i++) spray[i] = new Object();\n\n// 3. Store a reference to one of them in the arguments array\n\n//  The arguments array isn't tracked by garbage collector\n\narguments[0] = spray[5000];\n\n// 4. Delete the objects and call the garbage collector\n\n//  All JSCript variables get reclaimed...\n\nfor (var i = 0; i < 20000; i++) spray[i] = 1;\n\nCollectGarbage();\n\n// 5. But we still have reference to one of them in the\n\n//  arguments array\n\nalert(arguments[0]);\n\n}\n\n// 1. Call sort with a custom callback\n\n[1,2].sort(F);\n\n### CVE-2019-1429\n\n\n-----\n\nThe CVE-2019-1367 patch did not actually fix the vulnerability triggered by the proof-ofconcept above and exploited in the in-the-wild. The proof-of-concept for CVE-2019-1367 still\nworked even after the CVE-2019-1367 patch was applied!\n\nIn November 2019, Microsoft released another patch to address this gap. CVE-20191429 addressed the shortcomings of the CVE-2019-1367 and also fixed a variant. The\nvariant is that the variables in the arguments array are not tracked by the garbage collector in\nthe toJson callback rather than the Array.sort callback. The only difference between the\nvariant triggers is the highlighted lines. Instead of calling the Array.sort callback, we call the\ntoJSON callback.\n\nvar spray = new Array();\n\nfunction F() {\n\n// 2. Create a bunch of objects\n\nfor (var i = 0; i < 20000; i++) spray[i] = new Object();\n\n// 3. Store a reference to one of them in the arguments array\n\n//  The arguments array isn't tracked by garbage collector\n\narguments[0] = spray[5000];\n\n// 4. Delete the objects and call the garbage collector\n\n//  All JSCript variables get reclaimed...\n\nfor (var i = 0; i < 20000; i++) spray[i] = 1;\n\nCollectGarbage();\n\n// 5. But we still have reference to one of them in the\n\n//  arguments array\n\nalert(arguments[0]);\n\n}\n\n+ // 1. Cause toJSON callback to fire\n\n+ var o = {toJSON:F}\n\n+ JSON.stringify(o);\n\n - // 1. Call sort with a custom callback\n\n - [1,2].sort(F);\n\n\n-----\n\n### CVE-2020-0674\n\n[In January 2020, CVE-2020-0674 was detected as exploited in-the-wild. The vulnerability is](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0674)\nthat the named arguments are not tracked by the garbage collector in the Array.sort callback.\nThe only changes required to the trigger for CVE-2019-1367 is to change the references to\narguments[] to one of the arguments named in the function definition. For example, we\nreplaced any instances of arguments[0] with arg1.\n\nvar spray = new Array();\n\n+ function F(arg1, arg2) {\n\n - function F() {\n\n// 2. Create a bunch of objects\n\nfor (var i = 0; i < 20000; i++) spray[i] = new Object();\n\n// 3. Store a reference to one of them in one of the named arguments\n\n//  The named arguments aren't tracked by garbage collector\n\n+  arg1 = spray[5000];\n\n -  arguments[0] = spray[5000];\n\n// 4. Delete the objects and call the garbage collector\n\n//  All JScript variables get reclaimed...\n\nfor (var i = 0; i < 20000; i++) spray[i] = 1;\n\nCollectGarbage();\n\n// 5. But we still have reference to one of them in\n\n//  a named argument\n\n+  alert(arg1);\n\n -  alert(arguments[0]);\n\n}\n\n// 1. Call sort with a custom callback\n\n[1,2].sort(F);\n\n### CVE-2020-0968\n\n\n-----\n\nUnfortunately CVE-2020-0674 was not the end of this story, even though it was the fourth\nvulnerability of this type to be exploited in-the-wild. In April 2020, Microsoft patched CVE2020-0968, another Internet Explorer JScript vulnerability. When the bulletin was first\nreleased, it was designated as exploited in-the-wild, but the following day, Microsoft changed\nthis field to say it was not exploited in-the-wild (see the revisions section at the bottom of the\n[advisory).](https://msrc.microsoft.com/update-guide/en-us/vulnerability/CVE-2020-0968)\n\nvar spray = new Array();\n\nfunction f1() {\n\nalert('callback 1');\n\nreturn spray[6000];\n\n}\n\nfunction f2() {\n\nalert('callback 2');\n\nspray = null;\n\nCollectGarbage();\n\nreturn 'a'\n\n}\n\nfunction boom() {\n\nvar e = o1;\n\nvar d = o2;\n\n// 3. the first callback (e.toString) happens\n\n//  it returns one of the string variables\n\n//  which is stored in a temporary variable\n\n//  on the stack, not tracked by garbage collector\n\n// 4. Second callback (d.toString) happens\n\n//  There, string variables get freed\n\n//  and the space reclaimed\n\n// 5. Crash happens when attempting to access\n\n//  string content of the temporary variable\n\n\n-----\n\nvar b = e + d;\n\nalert(b);\n\n}\n\n// 1. create two objects with toString callbacks\n\nvar o1 = { toString: f1 };\n\nvar o2 = { toString: f2 };\n\n// 2. create a bunch of string variables\n\nfor (var a = 0; a < 20000; a++) {\n\nspray[a] = \"aaa\";\n\n}\n\nboom();\n\nIn addition to the vulnerabilities themselves being very similar, the attacker used the same\nexploit method for each of the four 0-day exploits. This provided a type of ‚Äúplug and play‚Äù\nquality to their 0-day development which would have reduced the amount of work required\nfor each new 0-day exploit.\n\n## Firefox CVE-2020-6820\n\n[Mozilla patched CVE-2020-6820 in Firefox with an out-of-band security update in April 2020.](https://www.mozilla.org/en-US/security/advisories/mfsa2020-11/)\nIt is a use-after-free in the Cache subsystem.\n\nCVE-2020-6820 is a use-after-free of the CacheStreamControlParent when closing its last\nopen read stream. The read stream is the response returned to the context process from a\ncache query. If the close or abort command is received while any read streams are still open,\nit triggers StreamList::CloseAll. If the StreamControl (must be the Parent which lives in the\nbrowser process in order to get the use-after-free in the browser process; the Child would\nonly provide in renderer) still has ReadStreams when StreamList::CloseAll is called, then this\nwill cause the CacheStreamControlParent to be freed. The mId member of the\nCacheStreamControl parent is then subsequently accessed, causing the use-after-free.\n\nThe execution patch for CVE-2020-6820 is:\n\n\n-----\n\nStreamList::CloseAll ‚Üê Patched function\n\nCacheStreamControlParent::CloseAll\n\nCacheStreamControlParent::NotifyCloseAll\n\nStreamControl::CloseAllReadStreams\n\nFor each stream:\n\nReadStream::Inner::CloseStream\n\nReadStream::Inner::Close\n\nReadStream::Inner::NoteClosed\n\n‚Ä¶\n\nStreamControl::NoteClosed\n\nStreamControl::ForgetReadStream\n\nCacheStreamControlParent/Child::NoteClosedAfterForget\n\nCacheStreamControlParent::RecvNoteClosed\n\nStreamList::NoteClosed\n\nIf StreamList is empty && mStreamControl:\n\nCacheStreamControlParent::Shutdown\n\nSend__delete(this) ‚Üê FREED HERE!\n\nPCacheStreamControlParent::SendCloseAll ‚Üê Used here in call to Id()\n\nCVE-2020-6820 is a variant of an internally found Mozilla vulnerability, [Bug 1507180.](https://bugzilla.mozilla.org/show_bug.cgi?id=1507180)\n[1507180 was discovered in November 2018 and patched in December 2019. 1507180 is a](https://hg.mozilla.org/mozilla-central/rev/cdf525897bff)\nuse-after-free of the ReadStream in mReadStreamList in StreamList::CloseAll. While it was\npatched in December, [an explanatory comment for why the December 2019 patch was](https://hg.mozilla.org/mozilla-central/rev/25beb671c14a)\nneeded was added in early March 2020.\n\nFor 150718 the execution path was the same as for CVE-2020-6820 except that the the useafter-free occurred earlier, in StreamControl::CloseAllReadStreams rather than a few calls\n‚Äúhigher‚Äù in StreamList::CloseAll.\n\nIn my personal opinion, I have doubts about whether or not this vulnerability was actually\n[exploited in-the-wild. As far as we know, no one (including myself or Mozilla engineers [1,](https://bugzilla.mozilla.org/show_bug.cgi?id=1626728#c15) [2]),](https://bugzilla.mozilla.org/show_bug.cgi?id=1507180#c10)\nhas found a way to trigger this exploit without shutting down the process. Therefore,\n\n\n-----\n\nexploiting this vulnerability doesn t seem very practical. However, because it was marked as\n[exploited in-the-wild in the advisory, it remains in our in-the-wild tracking spreadsheet and](https://docs.google.com/spreadsheets/d/1lkNJ0uQwbeC1ZTRrxdtuPLCIl7mlUreoKfSIgajnSyY/edit#gid=1869060786)\nthus included in this list.\n\n## Chrome for Android CVE-2020-6572\n\n[CVE-2020-6572 is use-after-free in](https://chromereleases.googleblog.com/2020/04/stable-channel-update-for-desktop_7.html)\nMediaCodecAudioDecoder::~MediaCodecAudioDecoder(). This is Android-specific code that\nuses Android's media decoding APIs to support playback of DRM-protected media on\nAndroid. The root of this use-after-free is that a `unique_ptr` is assigned to another, going out\nof scope which means it can be deleted, while at the same time a raw pointer from the\noriginally referenced object isn't updated.\n\nMore specifically, MediaCodecAudioDecoder::Initialize doesn't reset\nmedia_crypto_context_ if media_crypto_ has been previously set. This can occur if\nMediaCodecAudioDecoder::Initialize is called twice, which is explicitly supported. This is\nproblematic when the second initialization uses a different CDM than the first one. Each\nCDM owns the media_crypto_context_ object, and the CDM itself (cdm_context_ref_) is a\n`unique_ptr`. Once the new CDM is set, the old CDM loses a reference and may be\ndestructed. However, MediaCodecAudioDecoder still holds a raw pointer to\nmedia_crypto_context_ from the old CDM since it wasn't updated, which results in the useafter-free on media_crypto_context_ (for example, in\nMediaCodecAudioDecoder::~MediaCodecAudioDecoder).\n\nThis vulnerability that was exploited in-the-wild was reported in April 2020. 7 months prior, in\nSeptember 2019, Man Yue Mo of Semmle [reported a very similar vulnerability,](https://bugs.chromium.org/p/chromium/issues/detail?id=1004730) CVE-201913695. CVE-2019-13695 is also a use-after-free on a dangling media_crypto_context_ in\nMojoAudioDecoderService after releasing the cdm_context_ref_. This vulnerability is\nessentially the same bug as CVE-2020-6572, it‚Äôs just triggered by an error path after\ninitializing MojoAudioDecoderService twice rather than by reinitializing the\nMediaCodecAudioDecoder.\n\nIn addition, in August 2019, Guang Gong of Alpha Team, Qihoo 360 reported another similar\n[vulnerability in the same component. The vulnerability is where the CDM could be registered](https://bugs.chromium.org/p/chromium/issues/detail?id=999311)\ntwice (e.g. MojoCdmService::Initialize could be called twice) leading to use-after-free. When\nMojoCdmService::Initialize was called twice there would be two map entries in\ncdm_services_, but only one would be removed upon destruction, and the other was left\n[dangling. This vulnerability is CVE-2019-5870. Guang Gong used this vulnerability as a part](https://chromereleases.googleblog.com/2019/09/stable-channel-update-for-desktop.html)\nof an Android exploit chain. He presented on this exploit chain at Blackhat USA 2020,\n[‚ÄúTiYunZong: An Exploit Chain to Remotely Root Modern Android Devices‚Äù.](https://github.com/secmob/TiYunZong-An-Exploit-Chain-to-Remotely-Root-Modern-Android-Devices/blob/master/us-20-Gong-TiYunZong-An-Exploit-Chain-to-Remotely-Root-Modern-Android-Devices-wp.pdf)\n\nWhile one could argue that the vulnerability from Guang Gong is not a variant of the\nvulnerability exploited in-the-wild, it was at the very least an early indicator that the Mojo\n[CDM code for Android had life-cycle issues and needed a closer look. This was noted in the](https://bugs.chromium.org/p/chromium/issues/detail?id=999311#c8)\n\n\n-----\n\n[issue tracker for CVE-2019-5870 and then brought up again after Man Yue Mo reported](https://bugs.chromium.org/p/chromium/issues/detail?id=999311#c8)\nCVE-2019-13695.\n\n## Windows splwow64 CVE-2020-0986\n\n[CVE-2020-0986 is an arbitrary pointer dereference in Windows splwow64. Splwow64 is](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0986)\nexecuted any time a 32-bit application wants to print a document. It runs as a Medium\nintegrity process. Internet Explorer runs as a 32-bit application and a Low integrity\nprocess. Internet Explorer can send LPC messages to splwow64. CVE-2020-0986 allows an\nattacker in the Internet Explorer process to control all three arguments to a memcpy call in\nthe more privileged splwow64 address space. The only difference between CVE-2020-0986\n[and CVE-2019-0880, which was also exploited in-the-wild, is that CVE-2019-0880 exploited](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0880)\nthe memcpy by sending message type 0x75 and CVE-2020-0986 exploits it by sending\nmessage type 0x6D.\n\nFrom this [great write-up from ByteRaptors on CVE-2019-0880 the pseudo code that allows](https://byteraptors.github.io/windows/exploitation/2020/05/24/sandboxescape.html)\nthe controlling of the memcpy is:\n\nvoid GdiPrinterThunk(LPVOID firstAddress, LPVOID secondAddress, LPVOID\nthirdAddress)\n\n{\n\n...\n\nif(*((BYTE*)(firstAddress + 0x4)) == 0x75){\n\nULONG64 memcpyDestinationAddress = *((ULONG64*)(firstAddress + 0x20));\n\nif(memcpyDestinationAddress != NULL){\n\nULONG64 sourceAddress = *((ULONG64*)(firstAddress + 0x18));\n\nDWORD copySize = *((DWORD*)(firstAddress + 0x28));\n\nmemcpy(memcpyDestinationAddress,sourceAddress,copySize);\n\n}\n\n}\n\n...\n\n}\n\nThe equivalent pseudocode for CVE-2020-0986 is below. Only the message type (0x75 to\n0x6D) and the offsets of the controlled memcpy arguments changed as highlighted below.\n\n\n-----\n\nvoid GdiPrinterThunk(LPVOID msgSend, LPVOID msgReply, LPVOID arg3)\n\n{\n\n...\n\nif(*((BYTE*)(msgSend + 0x4)) == 0x6D){\n\n...\n\nULONG64 srcAddress = **((ULONG64 **)(msgSend + 0xA));\n\nif(srcAddress != NULL){\n\nDWORD copySize = *((DWORD*)(msgSend + 0x40));\n\nif(copySize <= 0x1FFFE) {\n\nULONG64 destAddress = *((ULONG64*)(msgSend + 0xB));\n\nmemcpy(destAddress,sourceAddress,copySize);\n\n}\n\n}\n\n...\n\n}\n\nIn addition to CVE-2020-0986 being a trivial variant of a previous in-the-wild vulnerability,\nCVE-2020-0986 was also not patched completely and the vulnerability was still exploitable\neven after the patch was applied. This is detailed in the ‚ÄúExploited 0-days not properly fixed‚Äù\nsection below.\n\n## Freetype CVE-2020-15999\n\nIn October 2020, Project Zero discovered multiple exploit chains being used in the wild. The\nexploit chains targeted iPhone, Android, and Windows users, but they all shared the same\nFreetype RCE to exploit the Chrome renderer, [CVE-2020-15999.](https://chromereleases.googleblog.com/2020/10/stable-channel-update-for-desktop_20.html) The vulnerability is a heap\nbuffer overflow in the Load_SBit_Png function. The vulnerability was being triggered by an\ninteger truncation. `Load_SBit_Png` processes PNG images embedded in fonts. The image\nwidth and height are stored in the PNG header as 32-bit integers. Freetype then truncated\nthem to 16-bit integers. This truncated value was used to calculate the bitmap size and the\nbacking buffer is allocated to that size. However, the original 32-bit width and height values\nof the bitmap are used when reading the bitmap into its backing buffer, thus causing the\nbuffer overflow.\n\n\n-----\n\n[In November 2014, Project Zero team member Mateusz Jurczyk reported CVE-2014-9665 to](https://bugs.chromium.org/p/project-zero/issues/detail?id=168)\nFreetype. CVE-2014-9665 is also a heap buffer overflow in the Load_SBit_Png function. This\none was triggered differently though. In CVE-2014-9665, when calculating the bitmap size,\nthe size variable is vulnerable to an integer overflow causing the backing buffer to be too\nsmall.\n\n[To patch CVE-2014-9665, Freetype added a check to the rows and width prior to calculating](http://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/sfnt/pngshim.c?id=54abd22891bd51ef8b533b24df53b3019b5cee81)\nthe size as shown below.\n\nif ( populate_map_and_metrics )\n\n{\n\nFT_Long size;\n\nmetrics->width = (FT_Int)imgWidth;\n\nmetrics->height = (FT_Int)imgHeight;\n\nmap->width   = metrics->width;\n\nmap->rows    = metrics->height;\n\nmap->pixel_mode = FT_PIXEL_MODE_BGRA;\n\nmap->pitch   = map->width * 4;\n\nmap->num_grays = 256;\n\n+   /* reject too large bitmaps similarly to the rasterizer */\n\n+   if ( map->rows > 0x7FFF || map->width > 0x7FFF )\n\n+   {\n\n+    error = FT_THROW( Array_Too_Large );\n\n+    goto DestroyExit;\n\n+   }\n\nsize = map->rows * map->pitch; <- overflow size\n\nerror = ft_glyphslot_alloc_bitmap( slot, size );\n\nif ( error )\n\ngoto DestroyExit;\n\n}\n\n\n-----\n\nTo patch CVE-2020-15999, the vulnerability exploited in the wild in 2020, this check was\nmoved up earlier in the `Load_Sbit_Png` function and changed to `imgHeight` and\n`imgWidth`, the width and height values that are included in the header of the PNG.\n\nif ( populate_map_and_metrics )\n\n{\n\n+   /* reject too large bitmaps similarly to the rasterizer */\n\n+   if ( imgWidth > 0x7FFF || imgHeight > 0x7FFF )\n\n+   {\n\n+    error = FT_THROW( Array_Too_Large );\n\n+    goto DestroyExit;\n\n+   }\n\n+\n\nmetrics->width = (FT_UShort)imgWidth;\n\nmetrics->height = (FT_UShort)imgHeight;\n\nmap->width   = metrics->width;\n\nmap->rows    = metrics->height;\n\nmap->pixel_mode = FT_PIXEL_MODE_BGRA;\n\nmap->pitch   = map->width * 4;\n\nmap->num_grays = 256;\n\n -   /* reject too large bitmaps similarly to the rasterizer */\n\n -   if ( map->rows > 0x7FFF || map->width > 0x7FFF )\n\n -   {\n\n -    error = FT_THROW( Array_Too_Large );\n\n -    goto DestroyExit;\n\n -   }\n\n[...]\n\nTo summarize:\n\n\n-----\n\nCVE-2014-9665 caused a buffer overflow by overflowing the size field in the size =\nmap->rows * map->pitch; calculation.\nCVE-2020-15999 caused a buffer overflow by truncating metrics->width and metrics>height which are then used to calculate the size field, thus causing the size field to be\ntoo small.\n\nA fix for the root cause of the buffer overflow in November 2014 would have been to bounds\ncheck imgWidth and imgHeight prior to any assignments to an unsigned short. Including the\nbounds check of the height and widths from the PNG headers early would have prevented\nboth manners of triggering this buffer overflow.\n\n## Apple Safari CVE-2020-27930\n\nThis vulnerability is slightly different than the rest in that while it‚Äôs still a variant, it‚Äôs not clear\nthat by current disclosure norms, one would have necessarily expected Apple to have picked\nup the patch. Apple and Microsoft both forked the Adobe Type Manager code over 20\nyears ago. Due to the forks, there‚Äôs no true ‚Äúupstream‚Äù. However when vulnerabilities were\nreported in Microsoft‚Äôs, Apple‚Äôs, or Adobe‚Äôs fork, there is a possibility (though no guarantee)\nthat it was also in the others.\n\nCVE-2020-27930 vulnerability was used in an exploit chain for iOS. The variant, CVE-20150993, was reported to Microsoft in November 2014. In CVE-2015-0993, the vulnerability is in\nthe blend operator in Microsoft‚Äôs implementation of Adobe‚Äôs Type 1/2 Charstring Font\nFormat. The blend operation takes n + 1 parameters. The vulnerability is that it did not\nvalidate or handle correctly when n is negative, allowing the font to arbitrarily read and write\non the native interpreter stack.\n\n[CVE-2020-27930, the vulnerability exploited in-the-wild in 2020, is very similar. The](https://support.apple.com/en-us/HT211929)\nvulnerability this time is in the callothersubr operator in Apple‚Äôs implementation of Adobe‚Äôs\nType 1 Charstring Font Format. In the same way as the vulnerability reported in November\n2014, callothersubr expects n arguments from the stack. However, the function did not\nvalidate nor handle correctly negative values of n, leading to the same outcome of arbitrary\nstack read/write.\n\nSix years after the original vulnerability was reported, a similar vulnerability was exploited in\na different project. This presents an interesting question: How do related, but separate,\nprojects stay up-to-date on security vulnerabilities that likely exist in their fork of a common\ncode base? There‚Äôs little doubt that reviewing the vulnerability Microsoft fixed in 2015 would\nhelp the attackers discover this vulnerability in Apple.\n\n## Exploited 0-days not properly fixed‚Ä¶ üò≠\n\nThree vulnerabilities that were exploited in-the-wild were not properly fixed after they were\nreported to the vendor.\n\n\n-----\n\nProduct Vulnerability that was\nexploited in-the-wild\n\n\n2nd patch\n\n\nInternet Explorer CVE-2020-0674 CVE-2020-0968\n\nGoogle Chrome CVE-2019-13764* CVE-2020-6383\n\nMicrosoft Windows CVE-2020-0986 CVE-202017008/CVE-20211648\n\n - when CVE-2019-13764 was patched, it\nwas not known to be exploited in-the-wild\n\n## Internet Explorer JScript CVE-2020-0674\n\nIn the section above, we detailed the timeline of the Internet Explorer JScript vulnerabilities\nthat were exploited in-the-wild. After the most recent vulnerability, CVE-2020-0674, was\nexploited in January 2020, it still didn‚Äôt comprehensively fix all of the variants. Microsoft\npatched [CVE-2020-0968 in April 2020. We show the trigger in the section above.](https://msrc.microsoft.com/update-guide/en-us/vulnerability/CVE-2020-0968)\n\n## Google Chrome CVE-2019-13674\n\n[CVE-2019-13674 in Chrome is an interesting case. When it was patched in November 2019,](https://chromereleases.googleblog.com/2019/12/stable-channel-update-for-desktop.html)\nit was not known to be exploited in-the-wild. Instead, it was reported by security researchers\nSoyeon Park and Wen Xu. Three months later, in February 2020, Sergei Glazunov of Project\nZero discovered that it was exploited in-the-wild, and may have been exploited as a 0-day\nprior to the patch. When Sergei realized it had already been patched, he decided to look a\nlittle closer at the patch. That‚Äôs when he realized that the patch didn‚Äôt fix all of the paths to\ntrigger the vulnerability. To read about the vulnerability and the subsequent patches in\n[greater detail, check out Sergei‚Äôs blog post, ‚ÄúChrome Infinity Bug‚Äù.](https://googleprojectzero.blogspot.com/2021/01/in-wild-series-chrome-infinity-bug.html)\n\nTo summarize, the vulnerability is a type confusion in Chrome‚Äôs v8 Javascript engine. The\nissue is in the function that is designed to compute the type of induction variables, the\nvariable that gets increased or decreased by a fixed amount in each iteration of a loop, such\nas a for loop. The algorithm works only on v8‚Äôs integer type though. The integer type in v8\nincludes a few special values, +Infinity and -Infinity. -0 and NaN do not belong to the integer\ntype though. Another interesting aspect to v8‚Äôs integer type is that it is not closed under\naddition meaning that adding two integers doesn‚Äôt always result in an integer. An example of\nthis is +Infinity + -Infinity = NaN.\n\n\n-----\n\nTherefore, the following line is sufficient to trigger CVE-2019-13674. Note that this line will\nnot show any observable crash effects and the road to making this vulnerability exploitable is\n[quite long, check out this blog post if you‚Äôre interested!](https://googleprojectzero.blogspot.com/)\n\nfor (var i = -Infinity; i < 0; i += Infinity) { }\n\n[The patch that Chrome released for this vulnerability added an explicit check for the](https://chromium.googlesource.com/v8/v8.git/+/b8b6075021ade0969c6b8de9459cd34163f7dbe1)\nNaN case. But the patch made an assumption that leads to it being insufficient: that the loop\nvariable can only become NaN if the sum or difference of the initial value of the variable and\nthe increment is NaN. The issue is that the value of the increment can change inside the loop\nbody. Therefore the following trigger would still work even after the patch was applied.\n\nvar increment = -Infinity;\n\nvar k = 0;\n\n// The initial loop value is 0 and the increment is -Infinity.\n\n// This is permissible because 0 + -Infinity = -Infinity, an integer.\n\nfor (var i = 0; i < 1; i += increment) {\n\nif (i == -Infinity) {\n\n// Once the initial variable equals -Infinity (one loop through)\n\n// the increment is changed to +Infinity. -Infinity + +Infinity = NaN\n\nincrement = +Infinity;\n\n}\n\nif (++k > 10) {\n\nbreak;\n\n}\n\n}\n\nTo ‚Äúrevive‚Äù the entire exploit, the attacker only needed to change a couple of lines in the\ntrigger to have another working 0-day. [This incomplete fix was reported to Chrome in](https://bugs.chromium.org/p/chromium/issues/detail?id=1051017)\n[February 2020. This patch was more conservative: it bailed as soon as the type detected](https://chromium.googlesource.com/v8/v8.git/+/a2e971c56d1c46f7c71ccaf33057057308cc8484)\nthat increment can be +Infinity or -Infinity.\n\n\n-----\n\nUnfortunately, this patch introduced an additional security vulnerability, which allowed for a\n[wider choice of possible ‚Äútype confusions‚Äù. Again, check out Sergei‚Äôs blog post if you‚Äôre](https://googleprojectzero.blogspot.com/2021/01/in-wild-series-chrome-infinity-bug.html)\ninterested in more details.\n\nThis is an example where the exploit is found after the bug was initially reported by security\nresearchers. As an aside, I think this shows why it‚Äôs important to work towards ‚Äúcorrect &\ncomprehensive‚Äù patches in general, not just vulnerabilities known to be exploited in-the-wild.\nThe security industry [knows there is a detection gap in our ability to detect 0-days exploited](https://googleprojectzero.blogspot.com/2020/07/detection-deficit-year-in-review-of-0.html)\nin-the-wild. We don‚Äôt find and detect all exploited 0-days and we certainly don‚Äôt find them all\nin a timely manner.\n\n## Windows splwow64 CVE-2020-0986\n\nThis vulnerability has already been discussed in the previous section on variants. After\n[Kaspersky reported that CVE-2020-0986 was actively exploited as a 0-day, I began](https://securelist.com/operation-powerfall-cve-2020-0986-and-variants/98329/)\nperforming root cause analysis and variant analysis on the vulnerability. The vulnerability was\n[patched in June 2020, but it was only disclosed as exploited in-the-wild in August 2020.](https://securelist.com/ie-and-windows-zero-day-operation-powerfall/97976/)\n\nMicrosoft‚Äôs patch for CVE-2020-0986 replaced the raw pointers that an attacker could\npreviously send through the LPC message, with offsets. This didn‚Äôt fix the root cause\nvulnerability, just changed how an attacker would trigger the vulnerability. This issue was\nreported to Microsoft in September 2020, including a working trigger. Microsoft released a\nmore complete patch for the vulnerability in January 2021, four months later. This new patch\nchecks that all memcpy operations are only reading from and copying into the buffer of the\nmessage.\n\n## Correct and comprehensive patches\n\nWe‚Äôve detailed how six 0-days that were exploited in-the-wild in 2020 were closely related to\nvulnerabilities that had been seen previously. We also showed how three vulnerabilities that\nwere exploited in-the-wild were either not fixed correctly or not fixed comprehensively when\npatched this year.\n\nWhen 0-day exploits are detected in-the-wild, it‚Äôs the failure case for an attacker. It‚Äôs a gift for\nus security defenders to learn as much as we can and take actions to ensure that that vector\ncan‚Äôt be used again. The goal is to force attackers to start from scratch each time we detect\none of their exploits: they‚Äôre forced to discover a whole new vulnerability, they have to invest\nthe time in learning and analyzing a new attack surface, they must develop a brand new\nexploitation method. To do that, we need correct and comprehensive fixes.\n\nBeing able to correctly and comprehensively patch isn't just flicking a switch: it requires\ninvestment, prioritization, and planning. It also requires developing a patching process that\nbalances both protecting users quickly and ensuring it is comprehensive, which can at times\n\n\n-----\n\nbe in tension. While we expect that none of this will come as a surprise to security teams in\nan organization, this analysis is a good reminder that there is still more work to be done.\n\nExactly what investments are likely required depends on each unique situation, but we see\nsome common themes around staffing/resourcing, incentive structures, process maturity,\nautomation/testing, release cadence, and partnerships.\n\nWhile the aim is that one day all vulnerabilities will be fixed correctly and comprehensively,\neach step we take in that direction will make it harder for attackers to exploit 0-days.\n\nIn 2021, Project Zero will continue completing root cause and variant analyses for\nvulnerabilities reported as in-the-wild. We will also be looking over the patches for these\nexploited vulnerabilities with more scrutiny. We hope to also expand our work into variant\nanalysis work on other vulnerabilities as well. We hope more researchers will join us in this\nwork. (If you‚Äôre an aspiring vulnerability researcher, variant analysis could be a great way to\nbegin building your skills! Here are two conference talks on the topic: my talk at BluehatIL\n2020 and [Ki Chan Ahn at OffensiveCon 2020.)](https://www.youtube.com/watch?v=fTNzylTMYks)\n\nIn addition, we would really like to work more closely with vendors on patches and\nmitigations prior to the patch being released. We often have ideas of how issues can be\naddressed. Early collaboration and offering feedback during the patch design and\nimplementation process is good for everyone. Researchers and vendors alike can save time,\nresources, and energy by working together, rather than patch diffing a binary after release\nand realizing the vulnerability was not completely fixed.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-02-03 - D√©j√† vu-lnerability A Year in Review of 0-days Exploited In-The-Wild in 2020.pdf"
    ],
    "report_names": [
        "2021-02-03 - D√©j√† vu-lnerability A Year in Review of 0-days Exploited In-The-Wild in 2020.pdf"
    ],
    "threat_actors": [
        {
            "id": "9f101d9c-05ea-48b9-b6f1-168cd6d06d12",
            "created_at": "2023-01-06T13:46:39.396409Z",
            "updated_at": "2025-03-27T02:00:03.074969Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "CHROMIUM",
                "ControlX",
                "Red Dev 10",
                "RedHotel",
                "Red Scylla",
                "TAG-22",
                "BRONZE UNIVERSITY",
                "AQUATIC PANDA",
                "Charcoal Typhoon",
                "BountyGlad"
            ],
            "source_name": "MISPGALAXY:Earth Lusca",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "6abcc917-035c-4e9b-a53f-eaee636749c3",
            "created_at": "2022-10-25T16:07:23.565337Z",
            "updated_at": "2025-03-27T02:02:09.868522Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Bronze University",
                "Charcoal Typhoon",
                "Chromium",
                "Red Dev 10",
                "Red Scylla"
            ],
            "source_name": "ETDA:Earth Lusca",
            "tools": [
                "Agentemis",
                "AntSword",
                "BIOPASS",
                "BIOPASS RAT",
                "BadPotato",
                "Behinder",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "Doraemon",
                "FRP",
                "Fast Reverse Proxy",
                "FunnySwitch",
                "HUC Port Banner Scanner",
                "KTLVdoor",
                "Mimikatz",
                "NBTscan",
                "POISONPLUG.SHADOW",
                "PipeMon",
                "RbDoor",
                "RibDoor",
                "RouterGod",
                "SAMRID",
                "ShadowPad Winnti",
                "SprySOCKS",
                "WinRAR",
                "Winnti",
                "XShellGhost",
                "cobeacon",
                "fscan",
                "lcx",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d53593c3-2819-4af3-bf16-0c39edc64920",
            "created_at": "2022-10-27T08:27:13.212301Z",
            "updated_at": "2025-03-27T02:00:55.529662Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Earth Lusca",
                "TAG-22",
                "Charcoal Typhoon",
                "CHROMIUM",
                "ControlX"
            ],
            "source_name": "MITRE:Earth Lusca",
            "tools": [
                "Mimikatz",
                "PowerSploit",
                "Tasklist",
                "certutil",
                "Cobalt Strike",
                "Winnti for Linux",
                "Nltest",
                "NBTscan",
                "ShadowPad"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "c0cedde3-5a9b-430f-9b77-e6568307205e",
            "created_at": "2022-10-25T16:07:23.528994Z",
            "updated_at": "2025-03-27T02:02:09.847683Z",
            "deleted_at": null,
            "main_name": "DarkHotel",
            "aliases": [
                "APT-C-06",
                "ATK 52",
                "CTG-1948",
                "Dubnium",
                "Fallout Team",
                "Higaisa",
                "Luder",
                "Operation DarkHotel",
                "Operation Daybreak",
                "Operation Inexsmar",
                "Operation PowerFall",
                "Operation The Gh0st Remains the Same",
                "SIG25",
                "Shadow Crane",
                "T-APT-02",
                "Tungsten Bridge",
                "Zigzag Hail"
            ],
            "source_name": "ETDA:DarkHotel",
            "tools": [
                "Asruex",
                "DarkHotel",
                "DmaUp3.exe",
                "GreezeBackdoor",
                "Karba",
                "Nemain",
                "Nemim",
                "Ramsay",
                "Retro",
                "Tapaoux",
                "Trojan.Win32.Karba.e",
                "Virus.Win32.Pioneer.dx",
                "igfxext.exe",
                "msieckc.exe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535983,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653767797,
    "ts_modification_date": 1653767797,
    "files": {
        "pdf": "https://archive.orkl.eu/d08e355e459a4fe0ae632fdcfffc13cbe6acb6f2.pdf",
        "text": "https://archive.orkl.eu/d08e355e459a4fe0ae632fdcfffc13cbe6acb6f2.txt",
        "img": "https://archive.orkl.eu/d08e355e459a4fe0ae632fdcfffc13cbe6acb6f2.jpg"
    }
}