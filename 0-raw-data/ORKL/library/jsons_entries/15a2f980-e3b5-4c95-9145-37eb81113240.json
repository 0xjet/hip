{
    "id": "15a2f980-e3b5-4c95-9145-37eb81113240",
    "created_at": "2023-04-05T02:08:18.450126Z",
    "updated_at": "2025-03-27T02:15:02.661406Z",
    "deleted_at": null,
    "sha1_hash": "877c2da04c2938abe9597ffd7ef436ac258c64b0",
    "title": "2023-02-21 - Direct Kernel Object Manipulation (DKOM) Attacks on ETW Providers",
    "authors": "",
    "file_creation_date": "2023-04-03T08:48:01Z",
    "file_modification_date": "2023-04-03T08:48:01Z",
    "file_size": 7832794,
    "plain_text": "# Direct Kernel Object Manipulation (DKOM) Attacks on ETW Providers\n\n**[securityintelligence.com/posts/direct-kernel-object-manipulation-attacks-etw-providers/](https://securityintelligence.com/posts/direct-kernel-object-manipulation-attacks-etw-providers/)**\n\n[Home&nbsp/&nbsp&nbspSoftware Vulnerabilities](https://securityintelligence.com/)\n\n[Software Vulnerabilities\nFebruary 21, 2023](https://securityintelligence.com/category/x-force/software-vulnerabilities/)\nBy [Ruben Boonen\n17 min read](https://securityintelligence.com/author/ruben-boonen/)\n\n## Overview\n\nIn this post, IBM Security X-Force Red offensive hackers analyze how attackers, with\nelevated privileges, can use their access to stage Windows Kernel post-exploitation\ncapabilities. Over the last few years, public accounts have increasingly shown that less\nsophisticated attackers are using this technique to achieve their objectives. It is therefore\nimportant that we put a spotlight on this capability and learn more about its potential impact.\nSpecifically, in this post, we will evaluate how Kernel post-exploitation can be used to blind\nETW sensors and tie that back to malware samples identified in-the-wild last year.\n\n## Intro\n\n\n-----\n\nOver time, security mitigations and detection telemetry on Windows have improved\nsubstantially. When these capabilities are combined with well-configured Endpoint Detection\n& Response (EDR) solutions, they can represent a non-trivial barrier to post-exploitation.\nAttackers face a constant cost to develop and iterate on tactics, techniques, and procedures\n(TTPs) to avoid detection heuristics. On the Adversary Simulation team at IBM Security XForce, we face this same issue. Our team is tasked with simulating advanced threat\ncapabilities in some of the largest and most hardened environments. The combination of\ncomplex fine-tuned security solutions and well-trained Security Operations Center (SOC)\nteams can be very taxing on tradecraft. In some cases, the use of a specific TTP is made\ncompletely obsolete in the span of three to four months (usually tied to specific technology\nstacks).\n\nAttackers may choose to leverage code execution in the Windows Kernel to tamper with\nsome of these protections or to avoid a number of user-land sensors entirely. The first\n[published demonstration of such a capability was in 1999 in Phrack Magazine. In the](http://phrack.org/issues/55/5.html)\nintervening years there have been a number of reported cases where Threat Actors (TAs)\nhave used Kernel rootkits for post-exploitation. Some older examples include the Derusbi\nFamily and the [Lamberts Toolkit.](https://securelist.com/unraveling-the-lamberts-toolkit/77990/)\n\nTraditionally these types of capabilities have mostly been limited to advanced TAs. In recent\nyears, however, we have seen more commodity attackers use Bring Your Own Vulnerable\nDriver (BYOVD) exploitation primitives to facilitate actions on endpoint. In some instances,\n[these techniques have been quite primitive, limited to simple tasks, but there have also been](https://www.trendmicro.com/en_us/research/22/h/ransomware-actor-abuses-genshin-impact-anti-cheat-driver-to-kill-antivirus.html)\n[more capable demonstrations.](https://news.sophos.com/en-us/2022/10/04/blackbyte-ransomware-returns/)\n\n[At the end of September 2022, researches from ESET released a white-paper about such a](https://www.virusbulletin.com/conference/vb2022/abstracts/lazarus-byovd-evil-windows-core/)\n[Kernel capability used by the Lazarus TA in a number of attacks against entities in Belgium](https://attack.mitre.org/groups/G0032/)\nand the Netherlands for the purpose of data exfiltration. This paper lays out a number of\nDirect Kernel Object Manipulation (DKOM) primitives that the payload uses to blind OS / AV /\nEDR telemetry. The available public research on these techniques is sparse. Gaining a more\nthorough understanding of Kernel post-exploitation tradecraft is critical for defense. A classic,\nnaïve, argument often heard is that an attacker with elevated privileges can do anything so\nwhy should we model capabilities in that scenario? This is a weak stance. Defenders need to\nunderstand what capabilities an attacker has when they are elevated, which data sources\nremain reliable (and which don’t), what containment options exist and how advanced\ntechniques could be detected (even if capabilities to perform those detections don’t exist). In\n[this post I will focus specifically on patching Kernel Event Tracing for Windows (ETW)](https://learn.microsoft.com/en-us/windows/win32/etw/about-event-tracing)\nstructures to render providers either ineffective or inoperable. I will provide some background\non this technique, analyze how an attacker may manipulate Kernel ETW structures, and get\ninto some of the mechanics of finding these structures. Finally, I will review how this\ntechnique was implemented by Lazarus in their payload.\n\n\n-----\n\n## ETW DKOM\n\nETW is a high-speed tracing facility built into the Windows operating system. It enables\nlogging of events and system activities by applications, drivers, and the operating system,\nproviding detailed visibility into system behavior for debugging, performance analysis, and\nsecurity diagnostics.\n\nIn this section, I will give a high-level overview of Kernel ETW and its associated attack\nsurface. This will be helpful to have a better understanding of the mechanics involved in\nmanipulating ETW providers and the associated effects of those manipulations.\n\n### Kernel ETW Attack Surface\n\n[Researchers from Binarly gave a talk at](https://www.binarly.io/) [BHEU 2021, which discussed the general attack](https://www.blackhat.com/eu-21/briefings/schedule/index.html#veni-no-vidi-no-vici-attacks-on-etw-blind-edr-sensors-24842)\nsurface of ETW on Windows. An overview of the threat model is pictured below.\n\n_Figure 1 – Veni, No Vidi, No Vici: Attacks on ETW Blind EDR Sensors (Binarly)_\n\nIn this post, we focus on the Kernel space attack surface.\n\n\n-----\n\n_Figure 2 – Veni, No Vidi, No Vici: Attacks on ETW Blind EDR Sensors (Binarly)_\n\nThis post considers only attacks within the first attack category shown in “Figure 2”, where\ntracing is either disabled or altered in some way.\n\nAs a cautionary note, when considering opaque structures on Windows it is always important\nto remember that these are subject to change, and in fact frequently do change across\nWindows versions. This is especially important when clobbering Kernel data, as mistakes will\nlikely result in a Blue Screen of Death (BSoD), roll safe!\n\n**Initialization**\n\n[Kernel providers are registered using nt!EtwRegister, a function exported by ntoskrnl. A](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-etwregister)\ndecompiled version of the function can be seen below.\n\n\n-----\n\n_Figure 3 – nt!EtwRegister decompilation_\n\nFull initialization happens within the inner EtwpRegisterKMProvider function but there are\ntwo main takeaways here:\n\nThe ProviderId is a pointer to a 16-byte GUID. This GUID is static across operating\nsystems so it can be used to identify the provider that is being initialized.\nThe RegHandle is a memory address that receives a pointer to an\n__ETW_REG_ENTRY structure on a successful call. This data structure and some of its_\nnested properties provide avenues to manipulate the ETW provider as per the research\nfrom Binarly.\n\nLet’s briefly list out the structures that Binarly highlighted on their slide in Figure 2.\n\n**ETW_REG_ENTRY**\n\nA full 64-bit listing of the _ETW_REG_ENTRY structure is shown below. Added details are\navailable on Geoff Chappell’s blog [here. This structure can also be further explored on the](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/etwp/etw_reg_entry/index.htm)\n[Vergilius Project.](https://www.vergiliusproject.com/kernels/x64/Windows%2011/22H2%20(2022%20Update)/_ETW_REG_ENTRY)\n\n_// 0x70 bytes (sizeof)_\n\n_// Win11 22H2 10.0.22621.382_\n\nstruct _ETW_REG_ENTRY\n\n{\nstruct _LIST_ENTRY RegList;              //0x0\n\nstruct _LIST_ENTRY GroupRegList;           //0x10\n\nstruct _ETW_GUID_ENTRY* GuidEntry;          //0x20\n\n\n-----\n\nstruct _ETW_GUID_ENTRY GroupEntry;          //0x28\nunion\n\n{\n\nstruct _ETW_REPLY_QUEUE* ReplyQueue;       //0x30\n\nstruct _ETW_QUEUE_ENTRY* ReplySlot[4];      //0x30\n\nstruct\n\n{\n\nVOID* Caller;                 //0x30\n\nULONG SessionId;               //0x38\n\n};\n};\n\nunion\n\n{\n\nstruct _EPROCESS* Process;            //0x50\n\nVOID* CallbackContext;              //0x50\n\n};\n\nVOID* Callback;                    //0x58\n\nUSHORT Index;                     //0x60\n\nunion\n\n{\n\nUSHORT Flags;                   //0x62\n\nstruct\n\n{\n\nUSHORT DbgKernelRegistration:1;        //0x62\n\nUSHORT DbgUserRegistration:1;         //0x62\n\nUSHORT DbgReplyRegistration:1;        //0x62\n\nUSHORT DbgClassicRegistration:1;       //0x62\n\nUSHORT DbgSessionSpaceRegistration:1;     //0x62\n\nUSHORT DbgModernRegistration:1;        //0x62\n\nUSHORT DbgClosed:1;              //0x62\n\nUSHORT DbgInserted:1;             //0x62\n\nUSHORT DbgWow64:1;              //0x62\n\nUSHORT DbgUseDescriptorType:1;        //0x62\n\nUSHORT DbgDropProviderTraits:1;        //0x62\n\n};\n};\n\nUCHAR EnableMask;                   //0x64\n\nUCHAR GroupEnableMask;                //0x65\n\nUCHAR HostEnableMask;                 //0x66\n\nUCHAR HostGroupEnableMask;              //0x67\n\nstruct _ETW_PROVIDER_TRAITS* Traits;         //0x68\n\n};\n\n\n-----\n\n**ETW_GUID_ENTRY**\n\nOne of the nested entries within _ETW_REG_ENTRY is GuidEntry, which is an\n__ETW_GUID_ENTRY structure. More information about this undocumented structure can be_\n[found on Geoff Chappell’s blog here and on the Vergilius Project.](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/etwp/etw_guid_entry.htm)\n\n_// 0x1a8 bytes (sizeof)_\n\n_// Win11 22H2 10.0.22621.382_\n\nstruct _ETW_GUID_ENTRY\n\n{\nstruct _LIST_ENTRY GuidList;             //0x0\n\nstruct _LIST_ENTRY SiloGuidList;           //0x10\n\nvolatile LONGLONG RefCount;              //0x20\n\nstruct _GUID Guid;                  //0x28\n\nstruct _LIST_ENTRY RegListHead;            //0x38\n\nVOID* SecurityDescriptor;               //0x48\n\nunion\n\n{\n\nstruct _ETW_LAST_ENABLE_INFO LastEnable;     //0x50\n\nULONGLONG MatchId;                //0x50\n\n};\n\nstruct _TRACE_ENABLE_INFO ProviderEnableInfo;     //0x60\n\nstruct _TRACE_ENABLE_INFO EnableInfo[8];       //0x80\n\nstruct _ETW_FILTER_HEADER* FilterData;        //0x180\n\nstruct _ETW_SILODRIVERSTATE* SiloState;        //0x188\n\nstruct _ETW_GUID_ENTRY* HostEntry;          //0x190\n\nstruct _EX_PUSH_LOCK Lock;              //0x198\n\nstruct _ETHREAD* LockOwner;              //0x1a0\n\n};\n\n**TRACE_ENABLE_INFO**\n\nFinally, one of the nested entries within _ETW_GUID_ENTRY is ProviderEnableInfo which is\na _TRACE_ENABLE_INFO structure. For more information about the elements of this data\nstructure, you can refer to [Microsoft’s official documentation and the](https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-trace_enable_info) [Vergilius Project. The](https://www.vergiliusproject.com/kernels/x64/Windows%2011/22H2%20(2022%20Update)/_TRACE_ENABLE_INFO)\nsettings in this structure directly affect the operation and capabilities of the provider.\n\n_// 0x20 bytes (sizeof)_\n\n_// Win11 22H2 10.0.22621.382_\n\nstruct _TRACE_ENABLE_INFO\n\n{\nULONG IsEnabled;                    //0x0\n\nUCHAR Level;                      //0x4\n\n\n-----\n\nUCHAR Reserved1;                    //0x5\nUSHORT LoggerId;                    //0x6\n\nULONG EnableProperty;                 //0x8\n\nULONG Reserved2;                    //0xc\n\nULONGLONG MatchAnyKeyword;               //0x10\n\nULONGLONG MatchAllKeyword;               //0x18\n\n};\n\n**Understanding Registration Handle Usage**\n\nWhile some theoretical background is good, it is always best to look at concrete example\nusage to gain a deeper understanding of a topic. Let us briefly consider an example. Most\ncritical Kernel ETW providers are initialized within, nt!EtwpInitialize, which is not exported.\nLooking within this function reveals about fifteen providers.\n\n_Figure 4 – nt!EtwpInitialize partial decompilation_\n\nTaking the Microsoft-Windows-Threat-Intelligence (EtwTi) entry as an example, we can\ncheck the global ThreatIntProviderGuid parameter to recover the GUID for this provider.\n\n_Figure 5 – EtwTi Provider GUID_\n\n\n-----\n\nSearching this GUID online will immediately reveal that we were able to recover the correct\nvalue (f4e1897c-bb5d-5668-f1d8-040f4d8dd344).\n\nLet’s look at an instance where the registration handle parameter,\n_EtwThreatIntProvRegHandle, is used and analyze how it is used. One place where the_\nhandle is referenced is nt!EtwTiLogDriverObjectUnLoad. From the name of this function, we\ncan intuit that it is meant to generate events when a driver object is unloaded by the Kernel.\n\n_Figure 6 – nt!EtwTiLogDriverUnload decompilation_\n\nThe nt!EtwEventEnabled and nt!EtwProviderEnabled functions are both called here passing\nin the registration handle as one of the arguments. Let’s look at one of these sub-functions to\nunderstand more about what is going on.\n\n\n-----\n\n_Figure 7 – nt!EtwProviderEnable decompilation_\n\nAdmittedly this is a bit difficult to follow. However, the pointer arithmetic is not especially\nimportant. Instead, let’s focus on how this function processes the registration handle. It\nappears that the function validates a number of properties of the _ETW_REG_ENTRY\nstructure and its sub-structures such as the GuidEntry property.\n\nstruct _ETW_REG_ENTRY\n\n{\n…\n\nstruct _ETW_GUID_ENTRY* GuidEntry;          //0x20\n\n…\n\n}\n\nAnd the GuidEntry->ProviderEnableInfo property.\n\n\n-----\n\nstruct _ETW_GUID_ENTRY\n{\n…\n\nstruct _TRACE_ENABLE_INFO ProviderEnableInfo;     //0x60\n\n…\n\n}\n\nThe function then goes into similar level-based checks. Finally, the function returns true or\nfalse to indicate if a provider is enabled for event logging at a specified level and keyword.\n[More details are available using Microsoft’s official documentation.](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-etwproviderenabled)\n\nWe can see that when a provider is accessed through its registration handle the integrity of\nthose structures become very important to the operation of the provider. Conversely, if an\nattacker was able to manipulate those structures, they could influence the control flow of the\ncaller to drop or eliminate events from being recorded.\n\n**Attacking Registration Handles**\n\nLooking back at Binarly’s stated attack surface and leaning on our light analysis, we can\nposit some strategies to disrupt event collection.\n\nAn attacker can NULL the _ETW_REG_ENTRY pointer. Any functions referencing the\nregistration handle would then assume that the provider had not been initialized.\nAn attacker can NULL the _ETW_REG_ENTRY->GuidEntry->ProviderEnableInfo\npointer. This should effectively disable the provider’s collection capabilities as\n_ProviderEnableInfo is a pointer to a _TRACE_ENABLE_INFO structure which outlines_\nhow the provider is supposed to operate.\n\n\n-----\n\nAn attacker can overwrite properties of the _ETW_REG_ENTRY->GuidEntry>ProviderEnableInfo [data structure to tamper with the configuration of the provider.](https://learn.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-trace_enable_info)\n\n_IsEnabled: Set to 1 to enable receiving events from the provider or to adjust the_\nsettings used when receiving events from the provider. Set to 0 to disable\nreceiving events from the provider.\n_Level: A value that indicates the maximum level of events that you want the_\nprovider to write. The provider typically writes an event if the event’s level is less\nthan or equal to this value, in addition to meeting the MatchAnyKeyword and\n_MatchAllKeyword criteria._\n_MatchAnyKeyword: 64-bit bitmask of keywords that determine the categories of_\nevents that you want the provider to write. The provider typically writes an event if\nthe event’s keyword bits match any of the bits set in this value or if the event has\nno keyword bits set, in addition to meeting the Level and MatchAllKeyword\ncriteria.\n_MatchAllKeyword: 64-bit bitmask of keywords that restricts the events that you_\nwant the provider to write. The provider typically writes an event if the event’s\nkeyword bits match all of the bits set in this value or if the event has no keyword\nbits set, in addition to meeting the Level and MatchAnyKeyword criteria.\n\n## Kernel Search Tradecraft\n\nWe have a good idea now of what a DKOM attack on ETW looks like. Let’s assume that the\nattacker has a vulnerability that grants a Kernel Read / Write primitive, as the Lazarus\nmalware does in this case by loading a vulnerable driver. What is missing is a way to find\nthese registration handles.\n\nI will outline two main techniques to find these handles and show the variant of one that is\nused by Lazarus in their Kernel payload.\n\n### Medium Integrity Level (MedIL) KASLR Bypass\n\nFirst, it may be prudent to explain that while there is Kernel ASLR, this is not a security\nboundary for local attackers if they can execute code at MedIL or higher. There are many\nways to leak Kernel pointers that are only restricted in sandbox or LowIL scenarios. For\n[some background you can have a look at I Got 99 Problems But a Kernel Pointer Ain’t One](https://recon.cx/2013/slides/Recon2013-Alex%20Ionescu-I%20got%2099%20problems%20but%20a%20kernel%20pointer%20ain't%20one.pdf)\nby Alex Ionescu, many of these techniques are still applicable today.\n\nThe tool of choice here is ntdll!NtQuerySystemInformation with the\n_SystemModuleInformation class:_\n\ninternal static UInt32 SystemModuleInformation = 0xB;\n\n\n-----\n\n[DllImport( ntdll.dll )]\ninternal static extern UInt32 NtQuerySystemInformation(\n\nUInt32 SystemInformationClass,\n\nIntPtr SystemInformation,\n\nUInt32 SystemInformationLength,\n\nref UInt32 ReturnLength);\n\nThis function returns the live base address of all modules loaded in Kernel space. At that\npoint, it is possible to parse those modules on disk and convert raw file offsets to relative\nvirtual addresses and vice versa.\n\npublic static UInt64 RvaToFileOffset(UInt64 rva,\nList<SearchTypeData.IMAGE_SECTION_HEADER> sections)\n\n{\nforeach (SearchTypeData.IMAGE_SECTION_HEADER section in sections)\n\n{\n\nif (rva >= section.VirtualAddress && rva < section.VirtualAddress + section.VirtualSize)\n\n{\n\nreturn (rva – section.VirtualAddress + section.PtrToRawData);\n\n}\n\n}\n\nreturn 0;\n}\n\npublic static UInt64 FileOffsetToRVA(UInt64 fileOffset,\nList<SearchTypeData.IMAGE_SECTION_HEADER> sections)\n\n{\nforeach (SearchTypeData.IMAGE_SECTION_HEADER section in sections)\n\n{\n\nif (fileOffset >= section.PtrToRawData && fileOffset < (section.PtrToRawData +\nsection.SizeOfRawData))\n\n{\n\nreturn (fileOffset – section.PtrToRawData) + section.VirtualAddress;\n\n}\n\n}\n\nreturn 0;\n}\n\nAn attacker can also load these modules into their user-land process using standard load\nlibrary API calls (e.g., ntdll!LdrLoadDll). Doing so would avoid complications of converting file\noffsets to RVA’s and back. However, from an operational security (OpSec) point of view this\nis not ideal as it can generate more detection telemetry.\n\n\n-----\n\n### Method 1: Gadget Chains\n\nWhere possible, this is the technique that I prefer because it makes leaks more portable\nacross module versions because they are less affected by patch changes. The downside is\nthat you are reliant on a gadget chains existing for the object you want to leak.\n\nConsidering ETW registration handles, let’s take Microsoft-Windows-Threat-Intelligence as\nan example. Below you can see the full call to nt!EtwRegister.\n\n_Figure 8 – nt!EtwRegister full CALL disassembly_\n\nHere we want to leak the pointer to the registration handle, EtwThreatIntProvRegHandle. As\nseen loaded into param_4 on the first line of Figure 8. This pointer resolves to a global within\nthe .data section of the Kernel module. Since this call occurs in an un-exported function, we\nare not able to leak its address directly. Instead, we have to look where this global is\nreferenced and see if it is used in a function whose address are able to leak.\n\n\n-----\n\n_Figure 9 – nt!EtwThreatIntProvRegHandle references_\n\nExploring some of these entries quickly reveals a candidate in nt!KeInsertQueueApc.\n\n\n-----\n\n_Figure 10 – nt!KeInsertQueueApc partial decompilation_\n\nThis is a great candidate for a few reasons:\n\n_nt!KeInsertQueueApc is an exported function. This means we can leak its live address_\nusing a KASLR bypass. Then we can use our Kernel vulnerability to read data at that\naddress.\nThe global is used at the start of the function. This is very helpful because it means we\nmost likely won’t need to construct complex instruction parsing logic to find it.\n\nLooking at the assembly shows the following layout.\n\n\n-----\n\n_Figure 11 – nt!KeInsertQueueApc partial disassembly_\n\nLeaking this registration handle then becomes straightforward. We read out an array of bytes\nusing our vulnerability, and search for the first mov R10 instruction to calculate the relative\nvirtual offset of the global variable. The calculation would be something like this:\n\nInt32 pOffset = Marshal.ReadInt32((IntPtr)(pBuff.ToInt64() + i + 3));\n\nhEtwTi = (IntPtr)(pOffset + i + 7 + oKeInsertQueueApc.pAddress.ToInt64());\n\nWith the registration handle, it is then possible to access the _ETW_REG_ENTRY data\nstructure.\n\nIn general, such gadget chains can be used to leak a variety of Kernel data structures.\nHowever, it is worth pointing out that it is not always possible to find such gadget chains and\nsometimes gadget chains may have multiple complex stages. For example, a possible\ngadget chain to leak page directory entry (PDE) constants could look like this.\n\nMmUnloadSystemImage -> MiUnloadSystemImage -> MiGetPdeAddress\n\nIn fact, a cursory analysis of ETW registration handles revealed that most do not have\nsuitable gadget chains which can be used as described above.\n\n\n-----\n\n### Method 2: Memory Scanning\n\nThe other main option to leak these ETW registration handles is to use memory scanning,\neither from live Kernel memory or from a module on disk. Remember that when scanning\nmodules on disk it is possible to convert file offsets to RVAs.\n\nThis approach consists of identifying unique byte patterns, scanning for those patterns, and\nfinally performing some operations at offsets of the pattern match. Let’s take another look at\n_nt!EtwpInitialize to understand this better:_\n\n_Figure 12 – nt!EtwpInitialize partial decompilation_\n\n\n-----\n\nAll fifteen of the calls to nt!EtwRegister are mostly bunched together in this function. The\nmain strategy here is to find a unique pattern that appears before the first call to\n_nt!EtwRegister and a second pattern that appears after the last call to nt!EtwRegister. This is_\nnot too complex. One trick that can be used to improve portability is to create a pattern\nscanner that is able to handle wild card byte strings. This is a task left to the reader.\n\nOnce a start and stop index have been identified, it is possible to look at all the instructions\nin-between.\n\nPotential CALL instructions can be identified based on the opcode for CALL which is\n_0xe8._\nSubsequently, a DWORD sized read is used to calculate the relative offset of the\npotential CALL instruction.\nThis offset is then added to the relative address of the CALL and incremented by five\n(the size of the assembly instruction).\nFinally, this new value can be compared to nt!EtwRegister to find all valid CALL\nlocations.\n\n\n-----\n\nOnce all CALL instructions have been found it is possible to search backward and extract the\nfunction arguments, first the GUID that identifies the ETW provider and second, the address\nof the registration handle. With this information in hand we are able to perform informed\nDKOM attacks on the registration handles to affect the operation of the identified providers.\n\n## Lazarus ETW Patching\n\n[I obtained a sample of the FudModle DLL mentioned in the ESET whitepaper and analyzed](https://securityintelligence.com/cloud/virusbulletin.com/uploads/pdf/conference/vb2022/papers/VB2022-Lazarus-and-BYOVD-evil-to-the-Windows-core.pdf)\nit. This DLL loads a signed vulnerable Dell driver (from an inline XOR encoded resource) and\nthen pilots the driver to patch many Kernel structures in order to limit telemetry on the host.\n\n_Figure 13 – Lazarus FudModule hash_\n\nAs the final part of this post, I want to review the strategy that Lazarus uses to find Kernel\nETW registration handles. It is a variation on the scanning method we discussed above.\n\nAt the start of the search function, Lazarus resolves nt!EtwRegister and uses this address to\nstart the scan.\n\n_Figure 14 – Lazarus FudModule partial ETW search decompilation_\n\n\n-----\n\nThis decision is a bit strange because it relies on where that function exists in relation to\nwhere the function gets called. The relative position of a function in a module may vary from\nversion to version since new code may be introduced, removed, or altered. However,\nbecause of the way modules are compiled, it is expected that functions maintain a relatively\nstable order. One assumes this is a search speed optimization.\n\nWhen looking for references to nt!EtwRegister in ntoskrnl it appears that not many entries\nare missed using this technique. Lazarus may also have performed additional analysis to\ndetermine that the missed entries are not important or otherwise don’t need to be patched.\nThe missed entries are highlighted below. Employing this strategy allows Lazarus to skip\n_0x7b1de0 bytes while performing the scan which may be a non-trivial amount if the scanner_\nis slow.\n\n\n-----\n\n_Figure 15 – Instances of calls to nt!EtwRegister_\n\nAdditionally, when starting the scan, the first five matches are skipped before starting to\nrecord registration handles. Part of the search function is shown below.\n\n\n-----\n\n_Figure 16 – Lazarus FudModule partial ETW search decompilation_\n\nThe code is a bit obtuse, but we get the plot highlights. The code looks for calls to\n_nt!EtwRegister, extracts the registration handle, converts this handle to the live address_\nusing a KASLR bypass, and stores the pointer in an array set aside for this purpose within a\nmalware configuration structure (allocated on initialization).\n\nFinally, let’s have a look at what Lazarus does to disable these providers.\n\n\n-----\n\n_Figure 17 – Lazarus FudModule NULL ETW registration handles_\n\nThis mostly makes sense, what Lazarus does here is leak the global variable we saw earlier\nand then overwrite the pointer at that address with NULL. This effectively erases the\nreference to the _ETW_REG_ENTRY data structure if it exists.\n\nI am not completely happy with the tradecraft shown for a few reasons:\n\nThe payload does not capture provider GUID’s so it can’t make any intelligent decisions\nas to whether it should or should not overwrite the provider registration handle.\nThe decision to start scanning at an offset inside ntoskrnl seems questionable because\nthe offset of the scan may vary depending on the version of ntoskrnl.\nArbitrarily skipping the first 5 matches seems equally questionable. There may be\nstrategic reasons for this decision but a better approach is to first collect all providers\nand then use some programmatic logic to filter the results.\n\n\n-----\n\nOverwriting the pointer to _ETW_REG_ENTRY should work but this technique is a bit\nobvious. It would be better to overwrite properties of _ETW_REG_ENTRY or\n__ETW_GUID_ENTRY or _TRACE_ENABLE_INFO._\n\nI re-implemented this technique for science; however, I made some adjustments to the\ntradecraft.\n\nA speed optimized search algorithm is used to find all 0xe8 bytes in ntoskrnl.\nAfterward, some post-processing is done to determine which of those are valid CALL\ninstructions and their respective destinations.\nNot all calls to nt!EtwRegister are useful because sometimes the function is called with\na dynamic argument for the registration handle. Because of this, some extra logic is\nneeded to filter the remaining calls.\nFinally, all GUID’s are resolved to their human readable form and the registration\nhandles are enumerated.\n\nOverall, after adjustments, the above technique is clearly the best way to perform this type of\nenumeration. Since search time is negligible with optimized algorithms, it makes sense to\nscan the entire module on disk and then use some additional post-scan logic to filter out\nresults.\n\n## ETW DKOM Impact\n\nIt is prudent to briefly evaluate how impactful such an attack could be. When provider data is\nreduced or eliminated entirely there is a loss of information, but at the same time not all\nproviders signal security-sensitive events.\n\nSome subset of these providers, however, are security-sensitive. The most obvious example\nof this is Microsoft-Windows-Threat-Intelligence (EtwTi) which is a core data source for\nMicrosoft Defender Advanced Threat Protection (MDATP) which is now called Defender for\nEndpoint (it’s all very confusing). It should be noted that access to this provider is heavily\n[restricted, only Early Launch Anti Malware (ELAM) drivers are able to register to this](https://learn.microsoft.com/en-us/windows-hardware/drivers/install/early-launch-antimalware)\nprovider. Equally, user-land processes receiving these events must have a protected status\n(ProtectedLight / Antimalware) and be signed with the same certificate as the ELAM driver.\n\nUsing [EtwExplorer it is possible to get a better idea of what types of information this provider](https://github.com/zodiacon/EtwExplorer)\ncan signal.\n\n\n-----\n\n_Figure 18 – ETW Explorer_\n\nThe XML manifest is too large to include here in its entirety, but one event is shown below to\ngive an idea of the types of data which can be suppressed using DKOM.\n\n\n-----\n\n_Figure 19 – EtwTi partial XML manifest_\n\n## Conclusion\n\nThe Kernel has been and continues to be an important, contested, area where Microsoft and\nthird-party providers need to make efforts to safeguard the integrity of the operating system.\nData corruption in the Kernel is not only a feature of post-exploitation but also a central\ncomponent in Kernel exploit development. Microsoft has made a lot of progress in this area\n[already with the introduction of Virtualization Based Security (VBS) and one of its](https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-vbs)\n[components like Kernel Data Protection (KDP).](https://www.microsoft.com/en-us/security/blog/2020/07/08/introducing-kernel-data-protection-a-new-platform-security-technology-for-preventing-data-corruption/#:~:text=Kernel%20Data%20Protection%20(KDP)%20is,%2Dbased%20security%20(VBS).)\n\n\n-----\n\nConsumers of the Windows operating system, in turn, need to ensure that they take\nadvantage of these advances to impose as much cost as possible on would-be attackers.\n[Windows Defender Application Control (WDAC) can be used to ensure VBS safeguards are](https://learn.microsoft.com/en-gb/windows/security/threat-protection/windows-defender-application-control/wdac-wizard-create-base-policy)\nin place and that policies exist which prohibit loading potentially dangerous drivers.\n\nThese efforts are all the more important as we increasingly see commodity TAs leverage\nBYOVD attacks to perform DKOM in Kernel space.\n\n## Additional References\n\n[Veni, No Vidi, No Vici: Attacks on ETW Blind EDR Sensors (BHEU 2021 Slides) – here](https://i.blackhat.com/EU-21/Wednesday/EU-21-Teodorescu-Veni-No-Vidi-No-Vici-Attacks-On-ETW-Blind-EDRs.pdf)\nVeni, No Vidi, No Vici: Attacks on ETW Blind EDR Sensors (BHEU 2021 Video) – [here](https://www.youtube.com/watch?v=wZG0h1q7fMg)\n[Advancing Windows Security (BlueHat Shanghai 2019) – here](https://github.com/dwizzzle/Presentations/blob/master/Bluehat%20Shanghai%20-%20Advancing%20Windows%20Security.pdf)\n[Exploiting a “Simple” Vulnerability – In 35 Easy Steps or Less! – here](https://windows-internals.com/exploiting-a-simple-vulnerability-in-35-easy-steps-or-less/)\n[Exploiting a “Simple” Vulnerability – Part 1.5 – The Info Leak – here](https://windows-internals.com/exploiting-a-simple-vulnerability-part-1-5-the-info-leak/)\n[Introduction to Threat Intelligence ETW – here](https://undev.ninja/introduction-to-threat-intelligence-etw/)\n[TelemetrySourcerer – here](https://github.com/jthuraisamy/TelemetrySourcerer)\nData Only Attack: Neutralizing EtwTi Provider – [here](https://public.cnotools.studio/bring-your-own-vulnerable-kernel-driver-byovkd/exploits/data-only-attack-neutralizing-etwti-provider)\nWDAC Policy Wizard – [here](https://webapp-wdac-wizard.azurewebsites.net/)\n\n_[Learn more about X-Force Red here. Schedule a no-cost consult with X-Force here.](https://www.ibm.com/services/offensive-security)_\n\n[Ruben Boonen](https://securityintelligence.com/author/ruben-boonen/)\nSenior Managing Security Consultant, Adversary Services, IBM X-Force\n\nRuben Boonen is a contributor for SecurityIntelligence.\n\nPOPULAR\n\n\n-----\n\n[Intelligence & Analytics February 21, 2023](https://securityintelligence.com/category/topics/security-intelligence-analytics/)\n\n## Backdoor Deployment and Ransomware: Top Threats Identified in X- Force Threat Intelligence Index 2023\n\n4 min read - Discover how threat actors are waging attacks and how to proactively protect\nyour organization with top findings from the 2023 X-Force Threat Intelligence Index.\n\n\n-----\n\n-----\n\n-----\n\n### More from Software Vulnerabilities\n\n\n-----\n\n-----\n\nAnalysis and insights from hundreds of the brightest minds in the cybersecurity industry to\nhelp you prove compliance, grow business and stop threats.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-02-21 - Direct Kernel Object Manipulation (DKOM) Attacks on ETW Providers.pdf"
    ],
    "report_names": [
        "2023-02-21 - Direct Kernel Object Manipulation (DKOM) Attacks on ETW Providers.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "23dfc9f5-1862-4510-a6ae-53d8e51f17b1",
            "created_at": "2024-05-01T02:03:08.146025Z",
            "updated_at": "2025-03-27T02:05:17.420497Z",
            "deleted_at": null,
            "main_name": "PLATINUM TERMINAL",
            "aliases": [
                "Longhorn ",
                "The Lamberts ",
                "Vault7 ",
                "APT-C-39 "
            ],
            "source_name": "Secureworks:PLATINUM TERMINAL",
            "tools": [
                " Assassin",
                " Marble Framework",
                "AfterMidnight"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "e993faab-f941-4561-bd87-7c33d609a4fc",
            "created_at": "2022-10-25T16:07:23.460301Z",
            "updated_at": "2025-03-27T02:02:09.814816Z",
            "deleted_at": null,
            "main_name": "Longhorn",
            "aliases": [
                "APT-C-39",
                "Platinum Terminal",
                "The Lamberts"
            ],
            "source_name": "ETDA:Longhorn",
            "tools": [
                "Black Lambert",
                "Blue Lambert",
                "Corentry",
                "Cyan Lambert",
                "Fluxwire",
                "Gray Lambert",
                "Green Lambert",
                "Magenta Lambert",
                "Pink Lambert",
                "Plexor",
                "Purple Lambert",
                "Silver Lambert",
                "Violet Lambert",
                "White Lambert"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "4e453d66-9ecd-47d9-b63a-32fa5450f071",
            "created_at": "2024-06-19T02:03:08.077075Z",
            "updated_at": "2025-03-27T02:05:17.381141Z",
            "deleted_at": null,
            "main_name": "GOLD LOTUS",
            "aliases": [
                "Hecamede ",
                "BlackByte"
            ],
            "source_name": "Secureworks:GOLD LOTUS",
            "tools": [
                " Cobalt Strike",
                " ExByte",
                " MEGA",
                " RDP",
                " SoftPerfect Network Scanner",
                "BlackByte"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a2b92056-9378-4749-926b-7e10c4500dac",
            "created_at": "2023-01-06T13:46:38.430595Z",
            "updated_at": "2025-03-27T02:00:02.831633Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Operation DarkSeoul",
                "APT38",
                "ATK117",
                "DEV-1222",
                "G0032",
                "APT 38",
                "Stardust Chollima",
                "APT-C-26",
                "ATK3",
                "Diamond Sleet",
                "Hidden Cobra",
                "Unit 121",
                "Subgroup: Bluenoroff",
                "NICKEL GLADSTONE",
                "DEV-0139",
                "Andariel",
                "Operation Troy",
                "COVELLITE",
                "TA404",
                "Lazarus group",
                "Dark Seoul",
                "G0082",
                "NewRomanic Cyber Army Team",
                "Bluenoroff",
                "Appleworm",
                "Nickel Academy",
                "COPERNICIUM",
                "Hastati Group",
                "Bureau 121",
                "Operation AppleJeus",
                "Whois Hacking Team",
                "Citrine Sleet",
                "Sapphire Sleet",
                "Group 77",
                "Labyrinth Chollima",
                "Operation GhostSecret",
                "BeagleBoyz"
            ],
            "source_name": "MISPGALAXY:Lazarus Group",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "70db80bd-31b7-4581-accb-914cd8252913",
            "created_at": "2023-01-06T13:46:38.57727Z",
            "updated_at": "2025-03-27T02:00:02.865012Z",
            "deleted_at": null,
            "main_name": "Longhorn",
            "aliases": [
                "the Lamberts",
                "APT-C-39",
                "PLATINUM TERMINAL"
            ],
            "source_name": "MISPGALAXY:Longhorn",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1680660498,
    "ts_updated_at": 1743041702,
    "ts_creation_date": 1680511681,
    "ts_modification_date": 1680511681,
    "files": {
        "pdf": "https://archive.orkl.eu/877c2da04c2938abe9597ffd7ef436ac258c64b0.pdf",
        "text": "https://archive.orkl.eu/877c2da04c2938abe9597ffd7ef436ac258c64b0.txt",
        "img": "https://archive.orkl.eu/877c2da04c2938abe9597ffd7ef436ac258c64b0.jpg"
    }
}