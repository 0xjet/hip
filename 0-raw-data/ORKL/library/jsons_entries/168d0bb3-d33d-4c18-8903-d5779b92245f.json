{
    "id": "168d0bb3-d33d-4c18-8903-d5779b92245f",
    "created_at": "2023-01-12T15:10:03.298653Z",
    "updated_at": "2025-03-27T02:05:32.568804Z",
    "deleted_at": null,
    "sha1_hash": "97960e4cb15166aff9e8faea67d991e127175009",
    "title": "2015-11-10 - Talking to Dridex (part 0) – inside the dropper",
    "authors": "",
    "file_creation_date": "2022-05-27T22:31:33Z",
    "file_modification_date": "2022-05-27T22:31:33Z",
    "file_size": 107769,
    "plain_text": "# Talking to Dridex (part 0) – inside the dropper\n\n**cert.pl/en/news/single/talking-dridex-part-0-inside-the-dropper/**\n\n## Intro\n\nDridex mostly comes to us as spam which contains a .doc with some macros, responsible for\ndownloading a dropper. One can quickly analyze it using oledump.py and looking through vbscript, or\nnaturally, just try to run it in a sandbox and obtain the dropped files.\n\n## CFG extraction\n\nAfter unpacking the rather mundane packer, lets get into the juicy parts. We are presented with a\nsmall stage1 dropper, which looks rather basic.\n\nThe purpose of the dropper is to download the main binary from C&C and inject it to explorer, plus\nsome generic initialization stuff.\n\nFirst lets take a look how to find C&C addresses. In older samples there was a PE section called\n.sdata and it contained xored xml-document with all of the interesting data,\n\n&lt;config botnet=\"301\"&gt;\n\n&lt;server_list&gt;\n\n85.25.238.9:8843\n\n91.142.221.195:5445\n\n46.37.1.88:473\n\n&lt;/server_list&gt;\n\n&lt;/config&gt;\n\nAbout a week ago that changed. There is no more .sdata – data sits in plain sight somewhere in\nmemory, structured as follows:\n\nstruct cfg_t {\n\nint field_0;\n\nunsigned __int16 botnet;\n\nunsigned __int8 count;\n\nchar unknown;\n\nip_addr cnc[count];\n\n};\n\nstruct ip_addr {\n\nchar ipaddr[4];\n\n__int16 port;\n\n\n-----\n\n};\n\n[view raw](https://gist.github.com/mak/894eaa9a6fc5df0aee88/raw/0cedbd0328782f044c64234ad9268fba17760ac4/cfg_struct.h) [cfg_struct.h hosted with ❤ by](https://gist.github.com/mak/894eaa9a6fc5df0aee88#file-cfg_struct-h) [GitHub](https://github.com/)\nUsing a yara signature like this:\n```\n $new_get_cnc = { E8 [4] BE [4] 8D ?? 5B 83 C4 1C 0F [3] 08 0F [3] 09 0F [3] 0A 0F [3] 0B 0F\n[3] 0C }\n\n```\nwe can easily locate address where it is used and pull out that data.\n\n### First encounter with C&C\n\nOk, now we have to find code that calls those addresses. After going back-and-forth between\nreferences we stumble across this function:\n\nHere is a little digression, if you don’t know this already: Dridex uses encoded strings and a run-time\napi resolving to make our life harder. Fortunately nothing fancy, a simple xor:\n\ndef dridex_decode_name(addr,idx,delm=“\\x00“):\n\naddr += 8; tmp = ‘‘; j = 0\n\nxkey = GetManyBytes(addr,8)\n\n\n-----\n\nfor i in range(idx+1):\n\ntmp = ‘‘\n\nwhile not tmp.endswith(delm):\n\ntmp += chr(ord(xkey[j%8]) ^ Byte(addr+8+j))\n\nj+=1\n\nreturn tmp.strip(delm)\n\n[view raw](https://gist.github.com/mak/dccb5f579a3d1e0b0180/raw/8d157a3a8bf0c1e49423631454837e57a562cfa9/dridex_decode.py) [dridex_decode.py hosted with ❤ by](https://gist.github.com/mak/dccb5f579a3d1e0b0180#file-dridex_decode-py) [GitHub](https://github.com/)\nBack to business. Despite what’s often reported, the first communication is not encrypted with xor as\ndescribed in other articles, but with RC4. Keys are stored somewhere in binary encoded as any other\nstring. They are different per botnet but otherwise don’t seem to change that often. For botnet 220 the\nkey is:\n```\nub9sKhcvsePZXuFC4HRw8KjFSIVUxsdAJXFyVP3Acl7HYL9KQBzETBzFvk2FlxeHZFBljIPps21W\n\n```\nArmed with C&C addresses and key, we can create a message. Fortunately, the Dridex authors were\nkind enough not to use any fancy binary format, just plain xml (sometimes gziped but we got to that\npart later…) and the message looks something like this:\n\n<loader>\n\n<get_module unique=”%s” botnet=”%d” system=”23128″ name=”%s” bit=”32″/>\n\n<soft><![CDATA[]]></soft>\n\n</loader>\n\nwhere “unique” is a bot name, created as follows:\n\n“botnet” is a 2 bytes value hidden in config, and the name corresponds to a request we’d like to do.\n\n\n-----\n\nThe most basic request is list which obtains a list of nodes.\n\nAfter decrypting the response, using RC4 with the same key, we got something like this, base64encoded string is copied without decoding and dealt with in the next stage.\n\n<root>\n<module name=”list”>\nApts4+yozUR8Nbcan9dOya6yFIq6mxfdnJjlydF+uAELwWrIEIcvQIkk1mPURXr25/IwtnDW9l4s36C1\n0iL0O6H3sJ1xhnUvcLN7ccjZU+RNySaj6YYSALvTBcGfNreUusy1ESLHKscAq4LJqzNy3UoB6fHLyJkU\nLKhVFpKnogyKQEt4lctDeIpAS3iKQwb3205JWYYEZMwTJQEzS9B29XQK6aa1VsPxFd31tsa7IPRFldSb\ndDgUVQmVq35rDX5nJNAfOYttztqNC8etW0oDIxrkEzMJedOrGIIvAnMUtdjDeIouPdceNNhiLzkGY3q6\ngQoV8pwkCQsSrwltmFOmbyW9l6Vx+XWBiD8wOROQS3iK\n</module>\n<root>\n\nThe next command is `bot` and is responsible for downloading main dll\n\n1 <root><module name=”bot”>base64-string</module></root>\n\nThere is no rocket science here, base64-encoded string is being decoded and loaded into memory,\nwhat is interesting in this case is how it is done.\n\n### Loader\n\nIt is normal in the malware world to apply an extra layer of protection to files stored in the local\nsystem. For example Tinba additionally xors it’s configuration file with bot id. But a non-written rule of\nhow most malware works, is that every code is passed through memory in clear text. As one can\nguess this not the case here.\n\nIndeed, Dridex’es method of injecting into another process is quite nice. It consists of two stub\nloaders. The first is responsible of decoding real payload (again just xor), while the second is used as\na simple pe-loader which makes it possible to run PE files without syscalls like LoadLibrary or\nCreateProcess.\n\n\n-----\n\nThis is clearly visible in any memory tracer,\n\n[37ceca4ac82d0ade9bac811217590ecd.bin – 3980][3952]called[pre] NtOpenProcess(1212) = 1276 –\nC:\\WINDOWS\\Explorer.EXE\n…\n\n[37ceca4ac82d0ade9bac811217590ecd.bin – 3980][3952]called[pre]\nNtWriteVirtualMemory(Explorer.EXE,1fe0000,459264) src: 932e90\n…\n\n[37ceca4ac82d0ade9bac811217590ecd.bin – 3980][3952]called[pre]\nNtWriteVirtualMemory(Explorer.EXE,b20000,2552) src: 12f348\n…\n\n[37ceca4ac82d0ade9bac811217590ecd.bin – 3980][3952]called[pre]\nNtWriteVirtualMemory(Explorer.EXE,b209f8,2460) sr c: 415020\n…\n\n[37ceca4ac82d0ade9bac811217590ecd.bin – 3980][3952]called[post]\nNtAllocateVirtualMemoryx(SELF,1900000,12288,MEM_COMMIT|MEM_RESERVE, RWX — )\n\n[37ceca4ac82d0ade9bac811217590ecd.bin – 3980][3952]called[post]\nNtAllocateVirtualMemoryx(SELF,1910000,65536,MEM_COMMIT, RW- — )\n\nWhat is important with further analysis is that it relays quite heavily on loader metadata, which is\nsomehow modeled to resemble a legit PE – which obviously it is not, as it missed almost every PE\ncharacteristic besides the typical MZ-PE signature.\n\n0000000: 4d5a 0000 0000 0000 0000 0000 0000 0000 MZ…………..\n0000010: 0000 0000 0000 0000 0000 0000 0000 0000 …………….\n0000020: 0000 0000 0000 0000 0000 0000 0000 0000 …………….\n0000030: 0000 0000 0000 0000 0000 0000 4000 0000 …………@…\n0000040: 5045 0000 0000 0000 0000 0000 0000 0000 PE…………..\n0000050: 0000 0000 0000 0000 0000 0000 0000 0000 …………….\n0000060: 0000 0000 0000 0000 0000 0000 0000 0000 …………….\n0000070: 0000 0000 0000 0000 0000 0000 0000 0000 …………….\n0000080: 0000 0000 0000 0000 0000 0000 0000 0000 …………….\n0000090: 0000 0000 0000 0000 0000 0000 0000 0000 …………….\n00000a0: 0000 0000 0000 0000 0000 0000 0000 0000 …………….\n\nMain dll is obviously packed – however I leave that challenge to the reader as a homework, as this is\nthe end of introduction. Cya in the next part!\nmak\n\nsample used,\n\n1 37ceca4ac82d0ade9bac811217590ecd\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2015/2015-11-10 - Talking to Dridex (part 0) – inside the dropper.pdf"
    ],
    "report_names": [
        "2015-11-10 - Talking to Dridex (part 0) – inside the dropper.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536203,
    "ts_updated_at": 1743041132,
    "ts_creation_date": 1653690693,
    "ts_modification_date": 1653690693,
    "files": {
        "pdf": "https://archive.orkl.eu/97960e4cb15166aff9e8faea67d991e127175009.pdf",
        "text": "https://archive.orkl.eu/97960e4cb15166aff9e8faea67d991e127175009.txt",
        "img": "https://archive.orkl.eu/97960e4cb15166aff9e8faea67d991e127175009.jpg"
    }
}