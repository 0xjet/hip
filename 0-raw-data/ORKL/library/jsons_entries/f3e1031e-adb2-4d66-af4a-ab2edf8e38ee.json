{
    "id": "f3e1031e-adb2-4d66-af4a-ab2edf8e38ee",
    "created_at": "2023-01-12T15:10:26.67993Z",
    "updated_at": "2025-03-27T02:05:30.191251Z",
    "deleted_at": null,
    "sha1_hash": "eb3519263e19d6b14c4902ffa8ee3d071a7b4189",
    "title": "2019-12-20 - Unveiling JsOutProx- A New Enterprise Grade Implant",
    "authors": "",
    "file_creation_date": "2022-05-28T00:38:06Z",
    "file_modification_date": "2022-05-28T00:38:06Z",
    "file_size": 120618,
    "plain_text": "# Unveiling JsOutProx: A New Enterprise Grade Implant\n\n**[blog.yoroi.company/research/unveiling-jsoutprox-a-new-enterprise-grade-implant/](https://blog.yoroi.company/research/unveiling-jsoutprox-a-new-enterprise-grade-implant/)**\n\nDecember 20, 2019\n\n12/20/2019\n\n## Introduction\n\nDuring our threat intelligence source monitoring operations, we spotted a new sophisticated\nmalware implant that seems to be unrelated to mainstream cyber weapons. In fact, the\nrecovered sample raised many interrogatives into the malware research community due to\nthe extensive usage of obfuscation anti-reverse techniques, hardening the investigative\nefforts.\n\nFor this reason, we decided to dig into this piece of malware and figure out its inner secrets,\nuncovering a modular architecture with advanced offensive capabilities, such as the\npresence of functionalities able to deal with multi factor authentication (MFA).\n\n## Technical Analysis\n\nHash 6bf0d9a7ca91f27a708c793832b0c7b6e3bc4c3b511e8b30e3d1ca2e3e2b90a7\n\nThreat JsOutProx\n\n\nBrief\nDescription\n\n\nMalicious JS file\n\n\nSsdeep 12288:9jAtRUr07Jo0W9vrd6ye8hKaVimlc+/eHFca7\n+mJO1Za6D4aYQZdV81u34YYbga0:RAO07JbAvrsype6lZTv\n\nTable 1. Sample information\n\n\n-----\n\nThe starting point is a Javascript file containing more than ten thousand lines of heavily\nobfuscated code.\n\nThe first line of this file embeds a huge array of Base64 encoded elements, but its raw\ndecoding led only to other incomprehensible data, evidencing the presence of a more\ncomplex layer of protection.\n\nFigure 1. Array with Base64 encoded elements.\nNavigating the code, we identified a series of instructions resembling a sort of initialization\nthat grabbed our attention. The function “t_ey” is used as deobfuscation function for some of\nthe string chucks preconfigured into the “t_ep” array, enabling us to recover some cleartext.\n\nThis initial code cleanup revealed interesting information such as some of the static\nconfiguration initialized during the initial malware execution stages. Among these info, we\nrecovered also its remote C2 address 91.189.180.199, operated by “ServeTheWorld”, an\nNorwegian provider renting his servers in Oslo, and a particular tag reporting the name\n_“JsOutProx”. Extremely characteristic._\n\nFigure 2. Initialization of basic malware information.\nContinuing to analyze the code, we reconstructed the approach used by the attacker to\nobfuscate the payload: all the necessary information has been encrypted, splitted, and then\nencoded in Base64 chunks stored into different structures named as “ta”, “t_ep”, “t_eq”.\n\nFigure 3. Other structures containing Base64 data.\nAs anticipated before, thanks to the decoding routine “t_ey” it is possible to retrieve at\nruntime the cleartext code to reify the structure of the malware, stored in the “t_fT” object\nvisible in the next figure.\n\nFigure 4. Core structure of the malware.\nThe structure contains objects and functions used by the malware to pursue its malicious\nactions. In many cases we noticed a naming correspondence between couples of objects, for\nexample between “Outlook” and “OutlookPlugin”, or “Proxy” and “ProxyPlugin” objects. This\nindicates the malware has a modular structure containing specific plugins able to perform a\nwide range of actions, such as exfiltrate data by populating the associated object. For\nexample, the \"OutlookPlugin\" is able to steal information about emails and contacts and it\ndoes that by filling the Outlook object shown in the previous figure.\n\nEach plugin embeds an obfuscated function named “receive”, which has the purpose to\nperform the specific action. This function name is constant and represent a sort of common\ninterface between malware modules.\n\nFigure 5. “receive” function into “InfoPlugin”.\n\n### Check-in and Command List\n\n\n-----\n\nOnce created the main structure, the first function ran by the malware is init . It is designed\nto create an identification string for the victim machine, gathering from system information\nand storing them into the “t_fT[“ID”]” variable.\n\nAs visible the next picture, the identification string is composed using the computer name,\nusername, OS version. Then, an additional suffix will be appended to it containing the\ncurrent action the malware is performing. In this specific case it is “ping”, a sort of heartbeat\nto make sure the command and control services is up and running.\n\nFigure 6. Creation of victim ID.\nThen, the malware moves in an endless loop in which it invokes the “receive” function every\n5 seconds. Substantially, this function is an interface that allows the attacker to interact with\nthe implant.\n\nThe malware, in fact, connects to the C2 and retrieves a string indicating the next command\nto execute into the “np[0x0]” variable. It has many capabilities and it able to handle a\ncomplete infection life-cycle. It can update itself, restart itself, execute another JavaScript\ncode, other VB scripts and even remove its traces.\n\nFigure 7. Switch structure with supported commands.\nSumming up, the analyzed version of the implant supports the following actions:\n\n**Command** **Action**\n\nupd Update the implant\n\nrst Restart the implant\n\nl32 Start another process with the same script\n\ndcn Kill the implant\n\nrbt Reboot the machine\n\nshd Shutdown the machine\n\nlgf ??\n\nejs Evaluate Javascript code\n\nepg ??\n\nevb Execute VisualBasic code\n\nidn ??\n\nsdn Load a .NET dll\n\nuis Uninstall the implant\n\n\n-----\n\nins Install the implant\n\nint.g Send the sleep time to C2\n\nint.s Update the sleep time\n\nTable 2. Supported commands.\n\nAdditionally, the default case of the main loop structure includes a series of IF-Else\nevaluating the received string in order to check for specific prefixes. Each prefix is associated\nto a plugin module.\n\nFigure 8. Invocation of plugins.\nAnalyzing this selection chain was possible to reconstruct the full list of supported plugin for\nthis version of the implant.\n\n**Command** **Plugin**\n\npr ProcessPlugin\n\ncl ClipboardPlugin\n\nfi FilePlugin\n\nlb LibraryPlugin\n\ndo DownloadPlugin\n\nsc ScreenPlugin\n\nou OutlookPlugin\n\npx ProxyPlugin\n\ncn ShellPlugin\n\ntk TokensPlugin\n\nin InfoPlugin\n\nds DnsPlugin\n\npm PromptPlugin\n\nTable 3. Malware’s plugins.\n\nAt this point, all the attention moves on understand what the functions and the plugins do\nand how they work. So, we provide, in the next paragraphs, a brief view of the most\ninteresting functions and plugins.\n\n\n-----\n\n**Persistency**\n\nBy the way, to ensure its survival after reboot, the malware writes a copy of the initial JS\nscript into the “%appdata%” and “%temp%” folder, setting the persistence on the system\nthrough the popular “HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run” registry key.\n\nFigure 9. Setting of persistence.\n\n### Plugin Modules\n\nThe number of supported plugin indicates the malware is pretty mature and extremely\ndangerous. Some of these supported plugins encode standard functionalities of many\nRAT and recon malware, but some of them hides interesting and even uncommon features.\n\n**The “Process” Plugin**\n\nThe ProcessPlugin is able to manipulate other processes running in the system. It can kill\nthem by PID and by name, create new processes through WSH or WMI and also collect a\n**memory dump of a specific process. This is an uncommon feature for a common malware,**\nit might indicate operators behind its command and controls could have analytical skills in\norder to investigate the surrounding environment, or also exfiltrate data through memory\nscraping.\n\nFigure 10. Part of ProcessPlugin code.\n\n**The “Dns” Plugin**\n\nThe DnsPlugin handles the machine’s DNS configuration. It can send to the C2 the current\nconfiguration and also set a new one, just like visible in the following screen.\n\nFigure 11. Part of DnsPlugin code.\n\n**The “Token” Plugin and the Object SymantecVIP**\n\nThis plugin is particularly interesting. The name refers to the exfiltration of some type of\ntoken. However, the plugin is specifically designed for the theft of SymantecVIP One Time\n**Password, the multifactor authentication technology used in enterprise grade Single-Sign-**\nOn services adopted in many corporate environments.\n\nFigure 12. Part of TokenPlugin code.\n\n**The “Outlook” Plugin**\n\nInstead, the OutlookPlugin weaponize the implant with common information stealing\ncapabilities enabling the attackers to gather account information and contact list.\n\nThe interesting part of this plugin is that it is the only one info-stealing plugin embedded in\nthe malware\n\n\n-----\n\nCommodity malware typically include support to multiple email clients, web browsers and ftp\nclients, but this one just handle Outlook: the de facto standard email client installed in the\nmajority of enterprise environment.\n\nFigure 13. Part of OutlookPlugin code.\n\n**The “Prompt” Plugin**\n\nAnother interesting functionality is provided by the PromptPlugin. It empowers the attacker to\npresent his victim a custom message prompt provided by the command and control server.\n\nFigure 14. Part of PromptPlugin code.\n\n### The Bridge Between JS and .NET\n\nAll the JavaScript plugins seem to be only an high-level interface used by the attacker to\ncommunicate with his implant. Digging into the code to search for the implementation of the\nplugins, we come across another mysterious component named “DotUtil” which seems to be\nthe link between the JavaScript interface and the implementation of the actual operations.\n\nAlso, digging the JS code, a method called “hasDotnet” made us wondering about the\nexistence of additional .NET artifacts which may hide the implementation of some of the\nabove-mentioned functionalities. Moreover, this method contains references to the download\nand the memory loading of an instance of a “DotUtil” module.\n\nFigure 15. Part of DotUtil module.\nDynamically analyzing the malware, we were able to intercept the download of a .NET DLL\ncalled “libDotJs.dll”. Analyzing it, we discover a complete mapping between the functions\nimplemented in it and the ones declared into “DotUtil” component.\n\nFigure 16. Mapping between DotUtil and .NET DLL.\nFrom a wider perspective, we can assert with a good confidence that the implant is\ncomposed of at least two different layers: the JavaScript interface, delivered to the target\nmachine as first stage and subject to continuous changes to lower its detectability, providing\nthe core mechanism to ensure a flexible access to the target machine, and an advanced\nfunctional layer leveraging .NET dependencies.\n\nFigure 17. Macro perspective of the malware composition.\n\n## Conclusion\n\nThe complexity and the engineering grade of this threat, dubbed JsOutProx, are an element\nof uniqueness in the current panorama. It is a toolkit with peculiar remote access capabilities.\nFrom an architectural point of view, JsOutProx contains all the function prototypes inside the\ncore engine and could be remotely extended at run time.\n\n\n-----\n\nThe implementation of its functionalities has been decoupled from the JavaScript core using\nshared interfaces realized through the “dotUtil” class, the loader of its NET plugins. These\nclasses are provided remotely through serialization, this decoupling provides a malleable\nmodular implementation enabling the implant operators to a versatile code management.\n\nAnother relevant aspect of JsOutProxy is the capability to deal with SymantecVIP\ntechnology. This led us to think that, this implant, has been designed to hit High-Value\ntargets. Also, this new threat appears emerging during these days, it has never been publicly\nseen before this December and it is probably still under development.\n\nCybaze-Yoroi Zlab will continue to actively hunt for it.\n\n### Indicator of Compromise\n\nHashes:\n\n6bf0d9a7ca91f27a708c793832b0c7b6e3bc4c3b511e8b30e3d1ca2e3e2b90a7\naf10e6d1e3a3b4ed1d5524da25b782a4deddbd14d04e259f13dd1502d43b3045\n\nC2:\n\n91.189.180.199:9989\n\n### Yara Rules\n```\nrule JsOutProx_Dec_2019{\n     meta:\n     description = \"Yara Rule for JsOutProx\"\n     author = \"Cybaze Zlab_Yoroi\"\n     last_updated = \"2019-12-19\"\n     tlp = \"white\"\n     category = \"informational\"\n     strings:\n     $re1 = /,'([0-9a-zA-Z])+=',/\n     $re2 = /[a-zA-Z]{1}_[a-zA-Z]{2}\\[0x/\n     $a1 = \"WScript\"\n     $a2 = \"0x\"\n  condition:\n     $re1 and $a1 and #a2>20000 and #re2>1000\n}\n\n```\n_This blog post was authored by Antonio Farina, Luca Mella and Antonio Pirozzi of Cybaze-_\n_Yoroi Z-LAB_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-12-20 - Unveiling JsOutProx- A New Enterprise Grade Implant.pdf"
    ],
    "report_names": [
        "2019-12-20 - Unveiling JsOutProx- A New Enterprise Grade Implant.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536226,
    "ts_updated_at": 1743041130,
    "ts_creation_date": 1653698286,
    "ts_modification_date": 1653698286,
    "files": {
        "pdf": "https://archive.orkl.eu/eb3519263e19d6b14c4902ffa8ee3d071a7b4189.pdf",
        "text": "https://archive.orkl.eu/eb3519263e19d6b14c4902ffa8ee3d071a7b4189.txt",
        "img": "https://archive.orkl.eu/eb3519263e19d6b14c4902ffa8ee3d071a7b4189.jpg"
    }
}