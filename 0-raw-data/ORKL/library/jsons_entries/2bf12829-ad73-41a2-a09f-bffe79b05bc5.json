{
    "id": "2bf12829-ad73-41a2-a09f-bffe79b05bc5",
    "created_at": "2022-10-25T16:48:21.08208Z",
    "updated_at": "2025-03-27T02:16:59.132994Z",
    "deleted_at": null,
    "sha1_hash": "40eea4af36401e29bd67feb0540e57772b5ca3c4",
    "title": "MAR-17-352-01 HatMan - Safety System Targeted Malware (Update B)",
    "authors": "",
    "file_creation_date": "2019-03-01T08:31:09Z",
    "file_modification_date": "2019-03-05T17:36:35Z",
    "file_size": 374523,
    "plain_text": "MAR-17-352-01\n\n###  Malware Analysis February 27, 2019\n\n\n# MAR-17-352-01 HatMan—Safety System Targeted Malware (Update B)\n\n\n## CONTENTS\n\nKey Takeaways .............................. 1\n\nOverview ........................................ 2\n\nAcknowledgements ........................ 2\n\nA Note on Terms ............................ 2\n\nAnalysis .......................................... 2\n\nTechnical Details ............................ 6\n\nImplications .................................. 18\n\nDetection/Mitigation ...................... 19\n\nContact Information ...................... 20\n\nFeedback ..................................... 20\n\nAppendix A: YARA Signature ....... 21\n\n\n## KEY TAKEAWAYS\n\n\n\n\n\n\nThe report discusses the components and capabilities of\nHatMan malware, also known as TRITON and TRISIS. This\nreport also provides information for industrial control systems\nowner and operators about detection and recommendations\nfor potential mitigations.\n[This report is an update to the HatMan–Safety System](https://edit.ics-cert.us-cert.gov/sites/default/files/documents/MAR-17-352-01%20HatMan%20-%20Safety%20System%20Targeted%20Malware%20%28Update%20A%29.PDF)\n[Targeted Malware (Update A) published on April 10, 2018.](https://edit.ics-cert.us-cert.gov/sites/default/files/documents/MAR-17-352-01%20HatMan%20-%20Safety%20System%20Targeted%20Malware%20%28Update%20A%29.PDF)\n\n\nDISCLAIMER: This report is provided “as is” for informational purposes only. The Department of Homeland Security (DHS) does not provide any warranties\nof any kind regarding any information within. DHS does not endorse any commercial product or service referenced in this advisory or otherwise. This\ndocument is distributed as TLP:WHITE: Disclosure is not limited. Sources may use TLP:WHITE when information carries minimal or no foreseeable risk of\nmisuse, in accordance with applicable rules and procedures for public release. Subject to standard copyright rules, TLP:WHITE information may be\ndistributed without restriction. For more information on the Traffic Light Protocol, see https://www.us-cert.gov/tlp.\n\n\n-----\n\n## OVERVIEW\n\n[This malware analysis report is an update to the report titled MAR-17-352-01 HatMan – Safety](https://edit.ics-cert.us-cert.gov/sites/default/files/documents/MAR-17-352-01%20HatMan%20-%20Safety%20System%20Targeted%20Malware%20%28Update%20A%29.PDF)\n[System Targeted Malware (Update A)](https://edit.ics-cert.us-cert.gov/sites/default/files/documents/MAR-17-352-01%20HatMan%20-%20Safety%20System%20Targeted%20Malware%20%28Update%20A%29.PDF) that was published April 10, 2018, on the Cybersecurity\nand Infrastructure Security Agency’s (CISA) ICS-CERT website. This report, MAR-17-352-01\nHatMan – Safety System Targeted Malware (Update B), contains an updated YARA signature to\nidentify a custom, Windows-based remote deployment tool that threat actors may have used.\n\nThe HatMan malware, also known as TRITON and TRISIS, affects Triconex Tricon safety\ncontrollers by modifying in-memory firmware to add additional programming. The extra\nfunctionality allows an attacker to read/modify memory contents and execute arbitrary code on\ndemand through receiving specially-crafted network packets. HatMan consists of two pieces: a\nPC-based component to communicate with the safety controller and a malicious binary component\nthat is downloaded to the controller. Safety controllers are used in a large number of environments,\nand the capacity to disable, inhibit, or modify the ability of a process to fail safely could result in\nphysical consequences. This report discusses the components and capabilities of the malware\nand potential mitigations.\n\n## ACKNOWLEDGEMENTS\n\nThis Analysis Report is the product of collaboration between several groups, including Schneider\nElectric, the producer of Triconex Tricon safety controllers.\n\n## A NOTE ON TERMS\n\nThis document uses the terms “Triconex” and “Tricon” frequently throughout. For clarity,\n“Triconex” refers to the overall product line produced by Schneider Electric, whereas “Tricon”\nrefers to the actual safety system hardware.\n\n## ANALYSIS\n\nHatMan follows Stuxnet and Industroyer/CrashOverride in specifically targeting devices found in\nindustrial control system (ICS) environments, but the malware surpasses both forerunners with\nthe ability to directly interact with, remotely control, and compromise a safety system—a nearly\nunprecedented feat. This section will discuss the malware’s context, components, and\ncapabilities at a reasonably high level. The Technical Details section provides a deeper dive into\nthe inner workings of the malware.\n\n### Vulnerable Systems\n\nTriconex MP3008 main processor modules running firmware versions 10.0–10.4 are vulnerable\nto HatMan. Based on testing, versions earlier or later than this are not vulnerable to the analyzed\nmalware sample as is; however, it is not known whether adjustments to the malware or\nexploitation of a different vulnerability might lead to a successful compromise of other versions of\nthe firmware. This version of the hardware uses an MPC860 PowerPC processor, whereas\nnewer Triconex safety systems are ARM-based. This means that a different version of the\nmalware would be required to target newer Tricons.\n\n\n-----\n\n### Context: What are Safety Systems?\n\nSafety systems—also known as safety instrumented systems (SIS) or safety programmable logic\ncontrollers (PLCs)—are specialized hardware, similar to traditional PLCs, with a strong emphasis\non reliability and predictable failure. Unlike traditional PLCs, safety PLCs often have redundant\ncomponents such as multiple main processors, watchdog capabilities to self-diagnose\nanomalies, and robust failure detection on inputs and outputs. Safety PLCs are used to provide a\nway for a process to safely shut down when it has encountered unsafe operating conditions and\nto provide a high degree of safety and reliability, with important monitoring capabilities for\nprocess engineers. Though designed never to fail, safety PLCs are also designed such that,\nwere one to fail, it would fail in a predictable manner so that the worst-case scenario is known\nand planned for ahead of time.\n\n### Overview of Operation\n\nPrior to discussing the individual components of the HatMan malware, it is worthwhile to provide\na brief, high-level overview of how an attacker would utilize HatMan to compromise a safety\ncontroller. Figure 1 shows the overall sequence of events of these two operations.\n\nThreat Actor Python Controller Injector Implant\n\nRuns script\n\nConnects to controller\n\nRequests system state\n\nSystem state\n\nSets argument\n\nAppends injector\n\nRuns program\n\nChecks system state\n\nRepeat\n\nEscalates privileges\n\nRequests system state\n\nWrites payload\n\nSystem state\n\nEnables payload\n\nReverts privileges\n\nState matches\n\nOverwrites injector\n\nRuns script\n\nConnects to controller\n\nMay repeat\n\nSends malicious command Triggers implant\n\nReads memory or Writes memory or Executes code\n\nReturns response Return packet contains result\n\n_Figure 1: Overall flow of HatMan malware_\n\n|Runs script|Col2|Col3|Connects to controller Requests system state System state Sets argument Appends injector|Col5|Col6|Col7|Col8|Col9|Col10|Col11|Col12|Col13|\n|---|---|---|---|---|---|---|---|---|---|---|---|---|\n||||||||||||||\n||||||||Runs program Checks system state Escalates privileges Writes payload||||||\n|||||Repeat|||||||||\n|||||System state|||Enables payload Reverts privileges||||||\n|||||State matches Overwrites injector|||||||||\n|Runs script|||||||||||||\n||||||||||||||\n||||||||||||||\n||||||||Triggers||implant memory or Executes code||||\n||||||||Reads memory or Writes Return packet||||||\n||||||||||contains result||||\n||||||||||||||\n||||||||||||||\n||||||||||||||\n\n\n-----\n\nThe threat actor’s first step—after having compromised a computer within the safety network—is\nto execute the main HatMan Python script (script_test.py, compiled into trilog.exe) that\nleverages a custom implementation of an internal TriStation (TS) protocol (library.zip). This\nscript, in turn, connects to the controller, gathers some information about the system state, then\nbegins the attack. It first sets an argument for the injector, then downloads a combination of the\ninjector and implant to the device as a new program for the controller to run. The script then\nperiodically checks the system state to determine whether the injector has completed.\n\nConcurrently, the injector begins executing automatically on the controller. It begins by verifying\nthat the controller looks like it is able to be compromised through several tests that exercise the\nvulnerability the injector leverages. Once it has done enough testing, the injector uses the\nvulnerability to escalate its privileges on the device, write the implant into the in-memory firmware\nregion, enable the implant, and revert its privileges. The injector then reports that it has finished.\n\nThe Python script, seeing that the injector has completed its execution, overwrites the program\nslot that it had used for the injector with a “dummy” program and exits. At this point, the controller\nhas been fully compromised.\n\nThe threat actor can now exercise the capabilities of the HatMan implant—a remote access\nTrojan (RAT) capable of reading and writing memory and executing arbitrary code. Because the\nsame Python implementation of the TS protocol includes functions for utilizing the HatMan\nimplant, the attacker would only need to use a similar script to connect to the controller and\nmanipulate it. By utilizing the three functions HatMan provides as building blocks, the attacker\ncan then freely modify the controller’s programming.\n\n### Components\n\nHatMan consists of two parts: a more traditional PC-based component that interacts with the\nsafety PLCs and a binary component that compromises the end device when downloaded. Files\nrelated to these components could appear on a workstation or similar device and might mimic\nlegitimate TS software paths and filenames.\n\nThe PC-based component consists of three pieces in the form observed:\n\n  - An executable that programs a Tricon device without the TS software,\n\n  - A native shellcode program that injects a payload into the in-memory copy of the Tricon\nfirmware, and\n\n  - A native shellcode payload that performs malicious actions.\n\n#### Reprogramming the Safety PLC\n\nIn its current iteration, the HatMan component that programs a Tricon is written entirely in\nPython, although nothing would preclude these being written in a different language. The\nmodules that implement the communication protocol and other supporting components are found\nin a separate file—library.zip—while the main script that employs this functionality is\ncompiled into a standalone Windows executable—trilog.exe.\n\nThis Python script communicates using four Python modules—TsBase, TsLow, TsHi, and\n```\nTS_cnames—that collectively implement the TS network protocol via UDP 1502; this is the\n\n```\n\n-----\n\nprotocol that the TS software uses to communicate with Triconex safety PLCs. Although this\nprotocol is undocumented, it is similar to the officially documented user application Triconex\nSystem Access Application (TSAA) protocol, used for reading and writing data points from a\nthird-party program. Due to this, it could feasibly have been reverse engineered from knowledge\nof the TSAA protocol, other manufacturers’ documentation, and studying traffic between the\nprogramming workstation and safety PLC. In addition, this protocol does not require any\nauthentication or encryption, although access control lists (ACLs) may be configured on the PLC.\nThe Python script is also capable of autodetecting Triconex controllers on the network by\nsending a specific UDP broadcast packet over port 1502.\n\nIn addition to their implementation of the TS protocol, the Python modules expose a set of\nmethods to interact with the compromised safety PLC. These send specially-crafted network\ncommands to pass messages to the implant in order to read and write memory or execute\narbitrary code. These commands may be sent from any device on the safety network and will be\naccepted by the compromised controller, regardless of key switch position.\n\nThe script embedded in trilog.exe connects to a TCM (Tricon Communication Module) using\nan IP address provided as an argument. Once it establishes a connection, it tries to determine if\nthe Tricon could be compromised. This is accomplished by checking the current state of the\ndevice, then downloading a small PowerPC program (PresetStatus) to the Tricon that, when\nexecuted, sets an argument or “control value” in the Tricon’s memory. If the control value was\nsuccessfully set, the script constructs a malicious program—comprised of the injector\n(inject.bin) and implant (imain.bin)—that it downloads to the controller. Once this program\nhas finished running, the script checks whether or not the injector succeeded. Regardless of\noutcome, the script cleans up after itself before finishing.\n\nThis script does not interact with the command modified by the malicious payload, but it is\nfeasible and likely that a separate script was used to actually utilize the RAT functionality of the\ncompromised safety controller as needed.\n\n#### The Malicious Payload\n\nThe malicious shellcode is split into two separate pieces—inject.bin and imain.bin. The\nformer is a less specific generic code that handles injecting a payload into the in-memory running\ncopy of the firmware, while the latter is the payload that actually provides the additional malicious\nfunctionality. Both binary components are PowerPC machine code—the same as the controller’s\nfirmware and any user programs.\n\nThe injector masquerades as a standard compiled PowerPC program for the Tricon. It uses the\ncontrol value written by the PresetStatus program in several ways: as an input argument; as a\nstep counter to track execution progress; and as a field for writing debug information.\n\nDuring each cycle, the injector is run, branching based on the step value stored in the control\nfield. It begins by waiting a number of cycles (or seconds, since each cycle is usually a second)\nbased on the control value. It then checks to ensure the vulnerability it intends on exploiting is\navailable. The final step exploits the vulnerability to gain supervisor permissions, then copies the\n\n\n-----\n\npayload into memory, patches a RAM/ROM consistency check, changes the jump table entry for\na specific TS protocol command to the address of the copied payload, and returns.\n\nOnce the injector has finished running, it will have modified the address of the handler for a\nspecific TS protocol command such that, when that command is received, the payload may be\nexecuted instead of normal processing.\n\nThe second component of the malicious program—the payload, imain.bin—is designed to take\na specific TS protocol command, look for a specially-crafted packet body, and perform custom\nactions on demand. A threat actor can use imain.bin to read and write memory on the safety\ncontroller and execute code at an arbitrary address within the firmware. In addition, if the\nmemory address it writes to is within the firmware region, the malicious payload disables address\ntranslation, writes the code at the provided address, flushes the instruction cache, and reenables address translation. This allows the malware to change the running firmware; however,\nchanges will be persistent only in memory and will be lost when the device is reset fully.\n\n## TECHNICAL DETAILS\n\nThis section presents a deeper analysis of the HatMan malware, providing a much more\nextensive look into the technical details. This malware is highly sophisticated and involves a\nnumber of distinct components. Several of these components have already been extensively\ndiscussed elsewhere, but other components have not received the same amount of\nconsideration. Table 1 provides the set of components that will be discussed, the relationship\nbetween them, and the associated SHA-1 hash for each. These components are described in the\nfollowing sections.\n\n_Table 1: SHA-1 Hashes_\n\n|Filename|Description|SHA-1 Hash|\n|---|---|---|\n|library.zip|Module archive|1dd89871c4f8eca7a42642bf4c5ec2aa7688fd5c|\n|TsLow.pyc|Protocol impl.|a6357a8792e68b05690a9736bc3051cba4b43227|\n|TsBase.pyc|Protocol impl.|d6e997a4b6a54d1aeedb646731f3b0893aee4b82|\n|TsHi.pyc|Protocol impl.|66d39af5d61507cf7ea29e4b213f8d7dc9598bed|\n|TS_cnames.pyc|Protocol impl.|97e785e92b416638c3a584ffbfce9f8f0434a5fd|\n|crc.pyc|Support module|2262362200aa28b0eead1348cb6fda3b6c83ae01|\n|sh.pyc|Support module|25dd6785b941ffe6085dd5b4dbded37e1077e222|\n|trilog.exe|Compiled Python|dc81f383624955e0c0441734f9f1dabfe03f373c|\n|PresetStatus|PPC Tricon program|78265509956028b34a9cb44d8df1fcc7d0690be2|\n|dummy|PPC Tricon program|1c7769053cfd6dd3466b69988744353b3abee013|\n|inject.bin|PPC Tricon program|f403292f6cb315c84f84f6c51490e2e8cd03c686|\n|imain.bin|PPC shellcode|b47ad4840089247b058121e95732beb82e6311d0|\n\n\n-----\n\n### Module Archive\n```\nlibrary.zip contains a number of compiled Python modules (.pyc files); these are generated\n\n```\nduring normal execution of the Python interpreter. Use of the compiled modules, instead of the\nsource code, may have been to help obscure its purpose. The large majority of the files\ncontained within this archive are standard Python libraries, but there are a few exceptions (see\ntable 1 above). Collectively, these can be treated as the TS protocol implementation.\n\n#### TriStation Protocol Implementation\n\nThe four compiled Python files beginning with “TS” collectively implement the TS protocol.\n```\nTsLow.pyc, TsBase.pyc, and TsHi.pyc each implement successively higher-level portions.\nTsLow implements the lowest-level functionality—UDP, TCM, and TS packet building, sending,\n\n```\nreceiving, and parsing. The rest of the functionality is built upon this base.\n```\nTsBase uses the TS packet capabilities of TsLow to perform individual actions on the controllers,\n\n```\nsuch as downloading and uploading programs, retrieving device status, and running programs.\n```\nTsHi abstracts the individual actions of TsBase to provide simple ways of performing\n\n```\ncomplicated tasks, such as appending a program, uploading one or more programs or functions,\nretrieving the program table, and interpreting returned status structures.\n\nThe final module—TS_cnames—provides string representations of a number of different features\nof the TS protocol, including message and error codes, key position states, and other values\nreturned by the status functions\n\n#### Cyclic Redundancy Check Support Module\n```\ncrc.pyc implements or imports a number of standard Cyclic Redundancy Check (CRC)\n\n```\nfunctions and includes input and polynomial pairs for several different standards, including\nModbus and XMODEM. The inclusion of the extra CRC functions is interesting, since the TS\nprotocol does not use them.\n\n#### Assorted Support Module\n```\nsh.pyc provides a few utility functions for flipping endianness and printing out binary data with a\n\n```\nhexadecimal representation. It is not especially interesting, but is a custom module that can be\ntied to the HatMan malware.\n\n\n-----\n\n|script_test.py Set Arguments preset_status Run Program inject/imain Set program arguments Append injector Get CP status Yes Arguments were set? No Program still running/valid? No Cleanup Yes No Program Control field appended? changed? No Yes Yes Overwrite with dummy Still running (step <15)? No Yes Exit|Col2|\n|---|---|\n|Set Arguments preset_status Set program arguments Yes Arguments were set? No|Run Program inject/imain Append injector Get CP status Program still running/valid? No Yes Control field changed? No Yes Still running (step <15)? No Yes|\n|||\n|Cleanup No Program appended? Yes Overwrite with dummy Exit||\n\n\nYes\n\nArguments\nwere set?\n\n\nControl field\nchanged?\nNo\n\n\nNo\n\nProgram\nappended?\n\n\nExit\n\n\nOverwrite with dummy\n\n\nGet CP status\n\n\n_Figure 2: Python driver operation_\n\n### Python Executable \n```\ntrilog.exe uses the functionality provided by library.zip to communicate with and infect a\n\n```\nTricon controller. This Windows executable is a Python script—script_test.py—compiled to\nrun standalone. The diagram in figure 2 shows the normal operation of this script.\n\nWhen the script begins, it attempts to append (essentially download) an embedded PowerPC\nblob (PresetStatus, discussed in Control Value Setting section) to the target Tricon’s program\nlist. This program, when executed by the Tricon, writes a hard-coded value into the control\nprogram memory region; this value serves both as the argument to and status for the program\nthat is uploaded later. Once the program has been appended and executed, the script attempts\nto see if the program ran successfully by retrieving the value it wrote to confirm that it changed to\nthe new value; if it does not match, the script terminates, as it is unable to operate on this\ncontroller. If the value matches, execution moves on to the malicious section.\n\nUpon success, the script builds the combined payload (discussed in the Appending Programs\nsection), appends it to the controller, and checks to see if execution was successful. This check\nconsists of verifying that the program still flags as valid and is running, checking to see if the\ncontrol field has changed, and, if so, checking that the recorded step is less than 15 (0xF)—the\n“stopped” value. At most, the script will check 4,096 times without the control field changing\nbefore exiting.\n\nOnce the script has finished running the malicious payload, it attempts to clean up after itself by\noverwriting the malicious payload with a “dummy” program that does, quite literally, nothing.\n\n\nProgram still\nrunning/valid?\nNo\n\n```\n  script_test.py\n\n```\n\nAppend injector\n\n\n-----\n\n#### Combined Payload\n\nThe malicious program that is downloaded to the Tricon consists of the following: the injector\n(inject.bin); the length of the payload (the length of imain.bin plus eight); the first marker\n(0x00001234); the payload (imain.bin); the same length again; and the second marker\n(0x0056789A). Figure 3 shows the overall structure of the program.\n\n```\n0 n\n\n```\nInjector Payload size Marker: Payload Payload size Marker:\n`inject.bin` + 8 `0x00001234` `imain.bin` + 8 `0x0056789A`\n\nPayload size + 8\n\n|Injector inject.bin|Payload size + 8|Marker: 0x00001234|Payload imain.bin|Payload size + 8|Marker: 0x0056789A|\n|---|---|---|---|---|---|\n\n\nInjector\n```\n inject.bin\n\n```\n\nMarker:\n```\n 0x00001234\n\n```\n\nPayload size\n+ 8\n\n\n_Figure 3: Layout of payload_\n\n#### Appending Programs\n\nThis section refers to the concept of “appending” a program to the controller. This is a very\nsimplified term for the much more complicated sequence of actions the Python modules take to\nadd a program to a running controller—more complicated than just allocating a new program and\nwriting its contents. The diagram in figure 4 provides an in-depth look at how this is\naccomplished.\n\nThere are two ways of providing new programming to a Tricon—either via a “download all” or a\n“download changes.” The former is used to download all of the user control application to the\nTricon, whereas the latter allows a number of changes to be pushed without requiring the entirety\nof the application to be redownloaded. There are several differences worth noting:\n\n  - A “download all” requires the application on the controller to be stopped, while a\n“download changes” may be executed while the application is running.\n\n  - Programs may only be deleted via a “download all,” although they may be fully\noverwritten during a “download changes.”\n\nWhen the “append” action is called, the Python function first checks to ensure that the controller\nis in a state that it knows can have a program appended to it; this includes checking the key\nstate, ensuring the current programming is valid, and seeing if the user-provided logic on the\nTricon is running. The function then checks if any programs are currently being downloaded and,\nif desired, can cancel them.\n\nThe Python function then counts the number of programs and functions on the controller and\ntries to retrieve the final program in the program list. If this is successful, execution continues\nwith attempting to allocate or write the program slot using “download changes.”\n\nThe function attempts to append the program three times, stopping once it has succeeded;\nhowever, during testing, any more than a single attempt to write the program resulted in at least\none main processor faulting. Each attempt consists of trying to start downloading changes,\nchecking to see if the final program has a custom CRC appended to it (allocating a new program\nslot if it does not), and trying to write the program. If the write is successful, execution continues.\n\n\nPayload size\n+ 8\n\n\nMarker:\n```\n 0x0056789A\n\n```\n\n-----\n\n|Col1|Col2|Append Program|Col4|Col5|\n|---|---|---|---|---|\n|No Is key set to program? Yes No Tried download Force start? Yes three times? No No Yes Is program valid? Run program Start download changes Yes Wait for program to start No No Download Is program changes running? allowed? Exception Yes Yes occured? Yes Already No Yes Final program No downloading has CRC? program? Return Success Yes No Allocate new program No Force download? Write program Yes Cancel download No Success? Upload dummy program Count programs/functions Yes Run program No Yes Success No Can read Yes confirmed? final program and Wait for program to start function? Cancel download Return Failure|||||\n\n\nIs key set\nto program?\n\n\nIs program\nrunning?\n\n\nForce download?\n\n\nException\noccured?\n\n\nFinal program\nhas CRC?\n\n\nNo\n\nSuccess?\n\n\nTried download\nthree times?\n\n\nReturn Success\n\n\nCount programs/functions\n\n\nUpload dummy program\n\n\nReturn Failure\n\n\nWait for program to start\n\n\nAllocate new program\n\n\nWrite program\n\n\n_Figure 4: Complete append operation_\n\nIf the program was appended and successfully run—with a “run” command if desired, otherwise\nby waiting for the changes to take effect—the function returns success. If the append was\nattempted but failed, the function attempts to cancel the download then returns failure. If the\nappend was successful, but an exception occurred when it ran, the function overwrites the\nprogram slot with the “dummy” program and returns failure.\n\nIt is worth noting that generally the same program slot is always used by the Python component\nof the malware—it is appended the first time a malicious program is downloaded and overwritten\n\n\nIs program\nvalid?\n\n\nCan read\nfinal program and\nfunction?\n\n\nNo Download\n\nchanges\nallowed?\n\n\nAppend Program\n\n\nRun program\n\n\nRun program\n\n\nCancel download\n\n\n-----\n\nany subsequent times. Specifically, this is to say that so long as the final program slot is marked\nby the custom CRC appended to the program, it will continue to be used by the malware. If\nanother program were to be appended without this checksum (such as via the TS software), the\nmalware would allocate a new program slot to use.\n\nIn addition, it is also important to note that all of these actions—first appending, then\noverwriting—do not require a “download all” to occur, only a “download changes”; however,\ndeleting a program requires a “download all” action. This is likely the reason why the script\noverwrites its program slot with a dummy program, rather than deleting it altogether.\n\n#### Control Value Setting\n\nThe program control value is set by a small PowerPC program that searches memory for two\nknown values; this is also known as “egg-hunting.”\n\nFigure 5 details the operation of this component. The program is run each cycle as it is added to\nthe program table on the Tricon; this has the side effect that, so long as this program is resident\non the controller, the field will be set repeatedly until the Python component overwrites that\nprogram slot. When the program runs, it starts at the beginning of the control program region of\nmemory and walks, 4 bytes at a time, until it either reaches the egg (two consecutive, constant\nvalues) or the end of the search region. If the program finds the values, it writes the hard-coded\ncontrol value into an address at a constant offset after the location of the egg.\n\nPython\n\nFirmware\n```\n                                                      script_test.py\n\n```\nHard-codes value\n\nRuns each cycle\n\n(before download)\n\n`PresetStatus` Pointer to start address\n\nYes\n\nIncrement pointer Does egg match? Write control field\n\nNo\n\nNo Yes\nEnd of region? Stop\n\nReturn\n\n_Figure 5: Control value setting program_\n\nInterestingly, the actual injector refers to this address by a constant address rather than egghunting; it is not clear why PresetStatus searches for this address rather than just referencing it\ndirectly. This could possibly be an additional check to see whether or not the system can be\ninfected—if the control value is not set correctly, the implant would not work. It also could\nindicate that the PresetStatus program was written at an earlier stage of development when it\nwas not yet known that that value was always at the same offset in vulnerable firmware.\n\n\nEnd of region?\n\n\nFirmware\n\n```\n   PresetStatus\n\n```\n\nIncrement pointer\n\n\nWrite control field\n\n\n-----\n\n### Injector/Implant\n\nThe combined program that the trilog.exe sends to the Tricon controller is a custom PowerPC\ninjection program that exploits a vulnerability in the device firmware to escalate privileges then\ndisables a firmware RAM/ROM consistency check, injects a payload (imain.bin) into the\nfirmware memory region, and changes a jump table entry to point to the added code. Each of\nthese—the injector, the vulnerability, and the implant—will be discussed in this section.\n\nThe end result of the injector executing is that the functionality of the payload will be available via\na compromised network command (part of the TS protocol), providing the functionality of a\nrudimentary RAT—reading and writing memory and executing arbitrary code—to an attacker on\nany device on the safety network, regardless of key switch position.\n\n#### Control Value\n\nThroughout this section, there will be repeated references to a “control value.” This is the value\nstored by the PresetStatus PowerPC program and essentially controls the execution flow of the\ninjector. The address of this value is within the structure handed back from the TS protocol “get\ncontrol program status” command. As the injector runs, it uses this control field several ways: as\nan input argument that specifies the number of cycles to idle before attempting to inject the\npayload; as a step counter to track/control execution progress; and as a field for writing debug\ninformation upon failure. This allows an attacker to monitor and debug the injector as it runs.\n\n#### Injector\n\nThe diagram in figure 6 shows the overall operation of the injector, inject.bin; the actual\noperation is somewhat more complex, but this provides a simplified discussion that covers the\nimportant points. This diagram also shows how the different components of the injector interact\nwith the control field that was set previously.\n\nControl Unused Counter Step Error Value Step Fin\n\nFirmware Field Input `0x` `000` `0800` `1` Result `0x` `000000` `0` `F`\n\nRuns each\ncycle\n\n>0\n\nDecrement counter\n\n1 Wait for a preset number of\n\n`inject.bin` Check counter\n\nseconds before infecting\n\nIncrement step\n\n=0\n\n2 Use exploit to verify MSR is\n\nYes\n\nstored at expected address\n\nIncrement step\n\nCheck step Success?\n\n3 Verify exploit copies data as Set error step/value\nNo\n\nDefault expected given custom input\nReturn\n\n4 Inject imain.bin\nStop Finalize control value\n\nInto firmware area\n\n_Figure 6: Operation of the injector_\n\n|0x|000|0800|1|\n|---|---|---|---|\n\n|Input|Unused Counter Step 0x 000 0800 1|\n|---|---|\n\n|Col1|Use exploit to verify MSR is stored at expected address|Col3|\n|---|---|---|\n\n|Result|Error Value Step Fin 0x 000000 0 F|Col3|Col4|Col5|Col6|Col7|Col8|\n|---|---|---|---|---|---|---|---|\n||0x||000000||0||F|\n|||||||||\n|||||||||\n||Decre|||ment co||unter||\n|||||||||\n||Incr|||ement s||tep||\n|||||||||\n||Incr|||ement s||tep||\n|||||||||\n\n|Col1|Verify exploit copies data as expected given custom input|Col3|\n|---|---|---|\n\n|Col1|Inject imain.bin Into firmware area|Col3|\n|---|---|---|\n\n\nCheck counter\n\n\nCheck step\n\n\nVerify exploit copies data as\nexpected given custom input\n\n\nWait for a preset number of\nseconds before infecting\n\n\nStop\n\n\nIncrement step\n\n\nIncrement step\n\n```\n   inject.bin\n\n```\n\nInput\n\n```\n 000000\n\n```\n```\n 000\n\n```\n```\n F\n\n```\n```\n 1\n\n```\n\n-----\n\nMuch like the PresetStatus program, the injector is executed by the firmware once each cycle.\nThe injector is written in a manner conducive to that—the current step of its execution is saved\ninto the final nibble of the control value and it branches based on the current step.\n\nThe first step simply waits a number of cycles (or seconds, as one cycle is normally equivalent to\none second), decrementing the counter passed in as part of the argument set by PresetStatus.\nOnce this counter reaches zero, it increments the step value.\n\nThe second step uses a partial implementation of the exploit to verify that the value of the\nmachine state register (MSR) is stored at the expected address within the context of a system\ncall. MSR controls privileges, endianness, address translation, and other low-level processor\nfeatures. This has been shown to fail on non-vulnerable versions of the MP3008 firmware. If it is\nsuccessful, it increments the step value again; otherwise, it marks failure and saves the value\nthat was copied into the control value for debugging purposes.\n\nThe third step again uses a similar partial implementation of the exploit to verify that the\nvulnerable system call behaves as expected—verifying that both input and output structures may\nbe controlled by putting a known, 2-byte value into the input and checking to see if it is copied\ninto the output structure. On success, it increments the step value, otherwise it marks a failure.\n\nThe fourth step actually performs the injection of the payload (imain.bin) into the firmware\nregion, using the full version of the exploit. This will be discussed in more depth later. Once this\nhas completed, the control value will have been finalized.\n\n#### Injection Process\n\nThe diagram in figure 7 shows the operation of the actual injection process. While this does not\nspecifically cover every single instruction, it shows the general flow of operation in enough detail\nto provide an accurate description of the checks and actions taken.\n\nThis function is executed as part of the injector (step 4 in figure 6). Once this stage has been\nreached, the vulnerability of the firmware has been confirmed and the control value should\nindicate that the current step is four and no error has occurred. The “steps” indicated in the\ndiagram correspond to the value stored into the second-to-lowest nibble (mask 0xF0), where the\nlowest nibble is set to 15 (0x0F) throughout this function.\n\n  - **Step 5—the first step—uses the exploit to enable supervisor privileges and disable**\ninstruction and data caching via MSR. This allows the rest of the code to function,\nincluding reading from and writing to the firmware region.\n\n  - **Step 6 disables external interrupts, likely to prevent any other code from interrupting the**\nchanges that are being made to the system, then checks that an instruction that branches\non the result of a RAM/ROM consistency check may be patched (the patching will occur\nduring step 12). Assuming success, it will continue.\n\n  - **Step 7 verifies that the jump table entry that will be patched in step 12 has the expected**\nvalue (the address of the default case branch).\n\n  - **Step 8 verifies that the appended payload (see Figure 3 for how the injector and payload**\nare combined) appears to be in place by checking for the boundary markers.\n\n\n-----\n\n  - **Step 9 first determines where to place the payload within the firmware region based on a**\nconstant value stored as part of the firmware, then checks to see if a previous payload\nexists leading up to that location in memory; if one does, it is zeroed out.\n\n  - **Step 10 ensures that the payload has content, and that the area to put the payload (the**\narea leading up to the target address) is empty of any non-zero bytes. If it is empty, this is\nwhere the payload will be placed, and execution will continue to step 11; otherwise,\nexecution branches to step thirteen.\n\n  - **Step 13 checks to see if the payload will fit at the target address rather than leading up to**\nthe target address; if it will, the new destination is at the target address and execution\ncontinues at step 11.\n\n  - **Step 11 actually copies the payload into the in-memory firmware region at the previously**\ndetermined destination.\n\n  - **Step 12 patches the jump table entry for the overridden network command, patches a**\nmemory consistency check, then flushes the instruction cache so that changes made to\nfirmware code immediately take effect.\n\n  - Finally, the function re-enables external interrupts and restores the system state to how it\nwas prior to the exploit having been triggered.\n\nOnce this code executes successfully, the implant (imain.bin) will have been copied to an area\nwithin the in-memory firmware region and patched such that a specific network command will\ntrigger the malicious code being called rather than the default behavior.\n\nIn addition, a specific RAM/ROM consistency check will have been patched (during step 12) that\nprevents a fault from occurring when the firmware region does not match the ROM image that\nwas loaded. Without patching this check, the injector would not be able to write the payload into\nthe firmware region or modify the jump table to point to it without faulting the device.\n\n\n-----\n\n|Col1|Col2|Col3|Col4|Col5|\n|---|---|---|---|---|\n|Inject imain.bin Into firmware area Step 9 Step 13 Step 5 Exploit! Get target address Payload fits after address? Unset user flag, IC/DC No Address is valid? No Target = after address Step 6 Yes Disable interrupts No Step 11 Existing payload? Copy payload into FW Can patch RAM check? No Yes Yes Zero out payload Step 12 Patch jumptable entry Step 7 Patch RAM check Can patch Step 10 jumptable? No Payload Yes length valid? Flush instruction cache Yes Step 8 Finalize No Enable interrupts Payload Destination is valid? Is empty? No Yes Yes Restore system state||Inject imain.bin Into firmware area|||\n\n\nCan patch\nRAM check?\n\nNo\n\n\nPayload\nis valid?\nNo\n\n\nNo\n\nExisting payload?\n\n\nNo\n\nDestination\nIs empty?\n\nYes\n\n\nInject imain.bin\nInto firmware area\n\n\nZero out payload\n\n\nCopy payload into FW\n\n\nPatch RAM check\n\n\nDisable interrupts\n\n\nRestore system state\n\n\n_Figure 7: Full injection process_\n\n#### Vulnerability\n\nThe previously-unknown vulnerability affecting Tricon MP3008 firmware versions 10.0–10.4\nallows an insecurely-written system call to be exploited to achieve an arbitrary 2-byte write\nprimitive, which is then used to gain supervisor privileges. There are a number of factors that\ncontribute to this system call being exploitable:\n\n  - The system call directly reads from three memory addresses from the control program\narea without any verification. Because these are userspace addresses, they may be\nwritten by a hand-crafted PowerPC program, such as the injector.\n\n  - The system call has few side-effects; it is designed to return information about the state\nof a firmware-level feature. This means that the userspace pointers may be changed for\nthe duration of the system call such that they still appear “valid” (do not cause any out-ofbounds accesses) and will not fault the device.\n\n\nCan patch\njumptable?\n\nNo\n\n\nPayload\nlength valid?\n\n\nUnset user flag, IC/DC\n\n\nPatch jumptable entry\n\n\nEnable interrupts\n\n\n-----\n\n  - The input values to the system call may be controlled such that the value that is written to\nthe output structure is the same as that passed in. This allows a specific 2-byte value to\nbe copied from one of the input structures into one of the output pointers.\n\n  - No checking is performed on the output addresses to ensure the pointers do not refer to\nthe firmware region or other protected areas. This allows for data to be written to normally\nimmutable and privileged regions.\n\nWhen the system call is triggered (via the sc instruction), the processor automatically saves the\ncurrent MSR contents—which includes the user/supervisor flag, among a variety of other\nthings—into the SRR1 register. The firmware implementation of the system call then saves this\nSRR1 register into a predictable address. When the system call returns, this stored SRR1\nregister is restored, moved back into the MSR, and execution resumes at the instruction after the\n```\nsc instruction.\n\n```\nExploiting the vulnerability allows the attacker to write 2 bytes into the location of the stored\nSRR1 register, replacing it with another valid but different MSR value. When the system call\nreturns, the modified MSR is restored, giving the attacker supervisor access and disabling the\ninstruction and data caches. Once the attacker has finished their desired actions, the system\nstate is restored by performing a “manual” system call—jumping to the address of the system call\nhandler, rather than using the sc instruction.\n\n#### Implant\n\nThe implant, in many ways, is far more straightforward than the injector. This code is run when\nthe compromised TS protocol command is received and provides RAT-like functionality. Most\nimportantly, it allows an actor to read and write memory—including within the in-memory\nfirmware region—and execute arbitrary code regardless of the key switch position, including\n“RUN.” This allows an actor to effect changes on the controller while it is in full operation, not just\nwhile it is being reprogrammed. Figure 8 shows the control flow of this component.\n\n\n-----\n\n249\n\nPacket looks\ncorrect?\n\n\n23\n\nPacket looks\ncorrect?\n\n\n65\n\nPacket looks\ncorrect?\n\n\nYes\n\nWrite in\nfirmware area?\n\n\nNo\n\nSubcommand\nvalue?\n\n\nBranch to original code\n\n\nHand packet back\n\n\nResp. length = 0x0\n\n\nCopy memory to packet\n\n\nResp. length = 0xA\n\n\nDisable addr. translation\n\n\nEnable addr. translation\n\n```\n    imain.bin\n\n```\n\n_Figure 8: Operation of implant_\n\nStructurally, this component is not laid out like a function; instead, it is written to replace a branch\nin a jump table. This means that it has a few differences from the rest of the code, such as it not\nhaving the same initial setup code (register/stack saving, etc.) and it branching to the default\ncase at the end of execution without setting a return address. This also means that some\nregisters are set prior to execution, as they would be for the other branches of the jump table—\nagain reinforcing that this is not an entire function.\n\nWhen execution is transferred from the firmware, the implant begins by getting the address of the\npacket currently being processed. It then checks to see whether the “MP” is either 255 (0xFF), or\nequal to a byte stored in memory. It is not clear what “MP” means in this context—this is how the\nPython module names the optional argument that gets written into the packet. If the value\nmatches, the implant then checks to see if the subcommand value stored in the packet is a\nknown value—one of 23, 65, or 249, telling it to read memory, write memory, or execute.\n\n  - The subcommand 23 (read memory) takes two arguments: the memory address to read\nfrom and the size of the read. When it is triggered, the implant performs some checks on\nthe rest of the packet to ensure that the two arguments it needs are present, verifies that\nthe read size is greater than 0 and less than or equal to 1,024, then copies memory into\nthe response packet based on the input arguments. The packet response size is based\non the amount of data read.\n\n  - The subcommand 65 (write memory) takes two arguments: the memory address to write\nto and the data to write. This command is the most complicated of the three. When it is\ntriggered, the implant checks to make sure the arguments are present, ensures that there\n\n\nYes\n\nAddress in\nfirmware area?\n\n\nWrite size\nwithin bounds?\n\n\nFirmware\n\n\nBranch to address\n\n\nCopy to memory\n\n\nFlush instruction cache\n\n\n-----\n\nis a non-zero amount of data to write, then checks to see whether the write is within the\nfirmware memory region.\n```\n   o If the write is in a userspace region, the implant simply writes the provided data to the\n\n```\nmemory address specified.\n```\n   o If the write is in the firmware region, the implant goes through a more complicated\n\n```\nprocess to ensure that the code being written has no chance of being executed during\nthe write, and that the changes take effect immediately. To accomplish this, it disables\naddress translation/caching and external interrupts, copies the provided data to the\naddress specified, and flushes the instruction cache, then re-enables address\ntranslation/caching. It is worth noting that this is very similar to what the exploit does\nto write to the firmware region.\n\n  - The subcommand 249 (execute) takes a single argument: the address to call. When this\ncommand is triggered, the implant checks that the packet contains an address and that\nthe provided address is within the firmware region, then calls that address.\n\nOnce the subcommand has finished executing, the implant builds the response packet using a\nlength determined by the subcommand and a fixed response code, and branches back to the\noriginal default jump table case, finishing its execution.\n\nAlthough this is a fairly simplistic RAT, an attacker can use these primitives to build much more\ncomplicated actions. For example, an attacker could execute arbitrary code on a Tricon by\nreading memory to figure out where to place the custom function and return value, writing the\ncustom code to an empty location, executing at the address of the shellcode, storing a return\nvalue elsewhere in memory; and reading memory to extract the return value. This was proven\nduring testing with a modified version of the implant that had known bugs fixed, providing firsthand evidence that this capability is very real.\n\n## IMPLICATIONS\n\nWhile it is safe to say that HatMan is a valuable tool for ICS reconnaissance, it is likely designed\nas part of a multi-pronged attack that collectively would degrade industrial processes, or worse.\nWere both the process and the safety systems to be degraded simultaneously, persons,\nproperty, and/or the environment could suffer physical harm—barring the presence of additional\nsafety mechanisms.\n\nDue to the unique nature of each facility, there is no way for CISA to assess the impact of this\nmalware on an individual plant. Thus, CISA strongly advises that individual asset owners assess\nthe impact of a compromise on their safety systems. Facility owners and operators should\ndiscuss the impact of a safety system compromise and consider adding contingencies to their\ncontinuity of operations planning for impacts associated with such a compromise at their facility.\n\nThe construction of the different HatMan components indicates significant knowledge about ICS\nenvironments—specifically Tricon controllers—and an extended development lifecycle to refine\nsuch an advanced attack. In addition, it is very likely that an additional component or a separate\npiece of malware has been developed to impact a control system in tandem with a HatMan\nattack on the safety system. Although there may be theories as to what this might look like—\n\n\n-----\n\nconsidering the areas in which Triconex equipment is used—this piece of the puzzle has not yet\nbeen revealed.\n\nIt is also worth considering the possibility of other threat actors moving into this attack space.\nBecause the HatMan samples have been made public—some files are on VirusTotal and many\nhave been made available on other sites—it is very likely that both researchers and other threat\nactors alike are doing their own analysis. In particular, the components made available could\nallow another party to build a similar attack, or to use it as a basis for attacks on other systems.\nTo this end, the security of all safety systems, not just Triconex controllers, should be\nconsidered.\n\nOne of the library files—crc.pyc—also poses an interesting conundrum. Based on its contents,\nit appears that this file was either built for interaction with other ICS systems, or part of an\nunknown project that dealt with ICS equipment. Although CISA cannot substantiate such a claim\nwithout hard evidence, one could, in the worst case, interpret this as proof of development of\nanother “prong” of the HatMan attack on both control and safety systems.\n\n## DETECTION AND MITIGATION\n\nSchneider Electric has provided an updated security bulletin [1] describing a method for detecting—\nand removing—the HatMan malware.\n\nIn addition, a YARA rule that matches the three binary components—trilog.exe, inject.bin,\nand imain.bin—is included in Appendix A. This is not a reliable method for detection, as the\nfiles may or may not be present on any workstation, and such a rule cannot be used on a Tricon\ncontroller itself; however, it could be useful for detection with agent-based detection systems or\nfor scanning for artifacts.\n\nA number of vendors that provide solutions for detecting anomalies through passive network\nscanning have added the capability to detect the network traffic generated by the HatMan\nmalware. Although this may not specifically prevent an attack, it would allow for an early warning\nthat the malware might exist on a particular network or safety system.\n\nIt is worth noting that the onboard security features of Triconex hardware do not serve as\neffective prevention/mitigation. The ACLs that are available are solely based on IP address,\nmeaning that an attacker could still use the programming workstation to compromise the safety\ndevice. Later Triconex devices have X.509 signing for programming, but this is also not a\nbulletproof mitigation strategy, as it is entirely feasible for the authors to update their script to\nemploy these certificates—resident on the programming workstation—to sign any updates they\npush, circumventing the measure. At best, this would be a stop-gap measure.\n\nUltimately, the best mitigation strategy for this malware—and others of the same sort—is to\nemploy defense in depth and follow any relevant best practices. Rather than solely attempting to\nprotect vulnerable targets—such as the Triconex devices targeted by HatMan—one prevents an\nattacker from ever reaching them.\n\n1 [https://www.schneider-electric.com/ww/en/download/document/SEVD-2017-347-01](https://www.schneider-electric.com/ww/en/download/document/SEVD-2017-347-01)\n\n\n-----\n\n## CONTACT INFORMATION\n\nRecipients of this report are encouraged to contribute any additional information that they may\nhave related to this threat. For any questions related to this report, please reach out to:\n\n  - Phone: +1-703-235-8832\n\n  - Email: NCCICCustomerService@hq.dhs.gov\n\n## FEEDBACK\n\nDHS strives to make this report a valuable tool for our partners and welcomes feedback on how\nthis publication could be improved. You can help by answering a few short questions about this\n[report at the following URL: https://www.us-cert.gov/forms/feedback.](https://www.us-cert.gov/forms/feedback)\n\n\n-----\n\n## APPENDIX A: YARA SIGNATURE\n\nThe following is a YARA rule that matches the binary components of the HatMan malware. This\n[rule is also available on the ICS-CERT website.](https://ics-cert.us-cert.gov/sites/default/files/file_attach/MAR-17-352-01B.yara)\n```\n/*\n* DESCRIPTION: Yara rules to match the known binary components of the HatMan\n* malware targeting Triconex safety controllers. Any matching\n* components should hit using the \"hatman\" rule in addition to a\n* more specific \"hatman_*\" rule.\n* AUTHOR: DHS/NCCIC/ICS-CERT\n*/\n/* Private rules that are used at the end in the public rules. */\nprivate rule hatman_filesize {\n  condition:\n    filesize < 350KB\n}\nprivate rule hatman_setstatus : APT unknown_attribution hatman RAT {\n  strings:\n\n```\n```\n$preset = { 80 00 40 3c 00 00 62 80 40 00 80 3c 40 20 03 7c\n\n```\n```\n           ?? ?? 82 40 04 00 62 80 60 00 80 3c 40 20 03 7c\n           ?? ?? 82 40 ?? ?? 42 38  }\n  condition:\n    hatman_filesize and $preset\n}\nprivate rule hatman_memcpy : hatman {\n  strings:\n\n```\n```\n$memcpy_be = { 7c a9 03 a6 38 84 ff ff 38 63 ff ff 8c a4 00 01\n\n```\n```\n             9c a3 00 01 42 00 ff f8 4e 80 00 20      }\n    $memcpy_le = { a6 03 a9 7c ff ff 84 38 ff ff 63 38 01 00 a4 8c\n             01 00 a3 9c f8 ff 00 42 20 00 80 4e      }\n  condition:\n    hatman_filesize and ($memcpy_be or $memcpy_le)\n}\nprivate rule hatman_dividers : hatman {\n  strings:\n    $div1 = { 9a 78 56 00 }\n    $div2 = { 34 12 00 00 }\n  condition:\n    hatman_filesize and $div1 and $div2\n}\nprivate rule hatman_nullsub : hatman {\n  strings:\n    $nullsub = { ff ff 60 38 02 00 00 44 20 00 80 4e }\n  condition:\n    hatman_filesize and $nullsub\n}\n\n```\n\n-----\n\n```\nprivate rule hatman_origaddr : hatman {\n  strings:\n    $oaddr_be = { 3c 60 00 03 60 63 96 f4 4e 80 00 20 }\n    $oaddr_le = { 03 00 60 3c f4 96 63 60 20 00 80 4e }\n  condition:\n    hatman_filesize and ($oaddr_be or $oaddr_le)\n}\nprivate rule hatman_origcode : hatman {\n  strings:\n    $ocode_be = { 3c 00 00 03 60 00 a0 b0 7c 09 03 a6 4e 80 04 20 }\n    $ocode_le = { 03 00 00 3c b0 a0 00 60 a6 03 09 7c 20 04 80 4e }\n  condition:\n    hatman_filesize and ($ocode_be or $ocode_le)\n}\nprivate rule hatman_mftmsr : hatman {\n  strings:\n    $mfmsr_be = { 7c 63 00 a6 }\n    $mfmsr_le = { a6 00 63 7c }\n    $mtmsr_be = { 7c 63 01 24 }\n    $mtmsr_le = { 24 01 63 7c }\n  condition:\n    hatman_filesize and (($mfmsr_be and $mtmsr_be) or ($mfmsr_le and $mtmsr_le))\n}\nprivate rule hatman_loadoff : hatman {\n  strings:\n    $loadoff_be = { 80 60 00 04 48 00 ?? ?? 70 60 ff ff 28 00 00 00\n            40 82 ?? ?? 28 03 00 00 41 82 ?? ??       }\n    $loadoff_le = { 04 00 60 80 ?? ?? 00 48 ff ff 60 70 00 00 00 28\n            ?? ?? 82 40 00 00 03 28 ?? ?? 82 41       }\n  condition:\n    hatman_filesize and ($loadoff_be or $loadoff_le)\n}\nprivate rule hatman_injector_int : hatman {\n  condition:\n    hatman_filesize and hatman_memcpy and hatman_origaddr and hatman_loadoff\n}\nprivate rule hatman_payload_int : hatman {\n  condition:\n    hatman_filesize and hatman_memcpy and hatman_origcode and hatman_mftmsr\n}\n/* Actual public rules to match using the private rules. */\nrule hatman_compiled_python : hatman {\n  condition:\n    hatman_nullsub and hatman_setstatus and hatman_dividers\n}\nrule hatman_injector : APT unknown_attribution hatman RAT {\n\n```\n\n-----\n\n```\n  condition:\n\n```\n```\n    hatman_injector_int and not hatman_payload_int\n}\nrule hatman_payload : APT unknown_attribution hatman RAT {\n  condition:\n    hatman_payload_int and not hatman_injector_int\n}\nrule hatman_combined : APT unknown_attribution hatman RAT {\n  condition:\n    hatman_injector_int and hatman_payload_int and hatman_dividers\n}\nrule hatman : APT unknown_attribution hatman RAT {\n  meta:\n    author = \"DHS/NCCIC/ICS-CERT\"\n    description = \"Matches the known samples of the HatMan malware.\"\n  condition:\n\n```\n```\nhatman_compiled_python or hatman_injector or\n\n```\n```\n         hatman_payload or hatman_combined\n}\nrule hatman_netexec : hatman {\n  strings:\n    $a1 = \"=signal\" wide\n    $a2 = { 43 00 6f 00 6d 00 53 00 70 00 65 00 63 00 00 00\n         20 00 3e 00 3e 00 20 00 4e 00 55 00 4c 00 00 00 }\n    $a3 = { 6a 00 6a 00 6a 00 6a 0a 6a 32 e8 [4] 85 c0 }\n    $c = { 6a 0d 6a 36 [0-2] e8}\n  condition:\n\n```\n```\n    hatman_filesize and all of ($a*) and #c > 3\n\n```\n}\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        },
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://us-cert.cisa.gov/sites/default/files/documents/MAR-17-352-01%20HatMan%20-%20Safety%20System%20Targeted%20Malware%20%28Update%20B%29.pdf",
        "https://papers.vx-underground.org/papers/ICS SCADA/Other/DHS-CISA - MAR-17-352-01 HatMan - Safety System Targeted Malware (Update B).pdf"
    ],
    "report_names": [
        "MAR-17-352-01%20HatMan%20-%20Safety%20System%20Targeted%20Malware%20%28Update%20B%29.pdf",
        "DHS-CISA - MAR-17-352-01 HatMan - Safety System Targeted Malware (Update B).pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f9806b99-e392-46f1-9c13-885e376b239f",
            "created_at": "2023-01-06T13:46:39.431871Z",
            "updated_at": "2025-03-27T02:00:03.08926Z",
            "deleted_at": null,
            "main_name": "Watchdog",
            "aliases": [
                "Thief Libra"
            ],
            "source_name": "MISPGALAXY:Watchdog",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1666716501,
    "ts_updated_at": 1743041819,
    "ts_creation_date": 1551429069,
    "ts_modification_date": 1551807395,
    "files": {
        "pdf": "https://archive.orkl.eu/40eea4af36401e29bd67feb0540e57772b5ca3c4.pdf",
        "text": "https://archive.orkl.eu/40eea4af36401e29bd67feb0540e57772b5ca3c4.txt",
        "img": "https://archive.orkl.eu/40eea4af36401e29bd67feb0540e57772b5ca3c4.jpg"
    }
}