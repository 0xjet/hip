{
    "id": "bd622ecf-9de2-475e-bafc-2c398e4d515c",
    "created_at": "2023-02-02T02:08:07.039938Z",
    "updated_at": "2025-03-27T02:06:12.317282Z",
    "deleted_at": null,
    "sha1_hash": "78ba6c69a942202ce180b1a0bfd8d53d7d784b58",
    "title": "2023-01-29 - Petya-Not Petya Ransomware Analysis",
    "authors": "",
    "file_creation_date": "2023-02-01T07:55:25Z",
    "file_modification_date": "2023-02-01T07:55:25Z",
    "file_size": 216462,
    "plain_text": "# Petya/Not Petya Ransomware:\n\n**[medium.com/@Ilandu/petya-not-petya-ransomware-9619cbbb0786](https://medium.com/@Ilandu/petya-not-petya-ransomware-9619cbbb0786)**\n\nIlan Duhin January 30, 2023\n\n[Ilan Duhin](https://medium.com/@Ilandu?source=post_page-----9619cbbb0786--------------------------------)\n\nJan 30\n\n\n7 min read\n\nWriter: Ilan Duhin\n\n## Executive Summary:\n\nPetya is a family of encrypting malware that targets OS of windows to infect MBR (master\nboot record) to execute payload that encrypt a hard drive’s file system table.\n\nPetya spread over the network by using the exploit MS17–010 Vulnerability known as\n**EternalBlue. It also spreads by stealing user names & passwords and spreading across**\nnetwork shares.\n\n**Static Analysis:**\n\nwhen I opened the ransomware in IDA, it started at the 10007D39 address with the function\nDLLEntryPoint, so although the file extension is .exe, I guess it is actually DLL.\n\n\n-----\n\n**PeStudio: in the indicators tab we see two of them that can suspicious to me.**\n\nThe date of that specified is, probably our suspicious payload\nIn the Imports tab, I will be looking for interesting api calls that I want to investigate later in\nIDA/Debugger to see which values they contain.\n\nit means that the new process that is created, in the security context of the calling process. If\nthe calling process is impersonating another user, the new process uses the token for calling\nprocess.\nBoth of them is used to grab the TokenSessionId for terminal service sessions.\n\nIt works like that: a new thread is created in suspended mode. The impersonated token\nreplace the current thread token with SetThreadToken and the thread is resumed. This\nthread is then used to execute the SMB RCE as the impersonated user.\n\nis used to connect to a server by using default credentials for the impersonated token and\nthen cancel the connection.\nThe function that encrypts data. In our situation, I guess it would try to encrypt the MFT\nbecause it is ransomware.\nIn the Library tab, I checked which library the ransomware import and which function it\nexports. In picture below I see many import DLL which give me a clue that the binary isn’t\n**packed.**\n\nThe interesting libraries I focus on them is:\n\n- Crypt32.dll — will use possibly crypto functions.\n\n- Advapi32.dll — probably will be responsible for restarting the OS system (I guess because\nthe ransomware wants to reboot the machine after she encrypts all files).\n\n- Shlwapi.dll — function that works for strings & filesystems paths.\n\n- Ws2_32.dll — it contains windows sockets api, I guess for setting up some sockets.\n\nAnother way to find interesting things about ransomware is by reading her string. To do this I\nuse BinText.\n\nThe strings are readable strings & useful output which means it’s not packed!\n\nthe file extension that the ransom will be looking for.\nthe messages that will show on the victim screen\n\n**Dynamic Analysis:**\n\nAs we see at static analysis that needs to face with DLL, I try to run it with Rundll32 at the\n**Entry point and see what happens.**\n\n\n-----\n\nHow do we know what the Entry point argument is? Well, one of the suspicious strings that I\nfound was: the string is described that the ransomware is run by rundll32 as a child\n**process with the #1 argument (which is the first value in library).**\n\nAlso when dropping the dll into IDA, at the Export tab we can see there is one export\nfunction that we should run.\n\nrunning the ransomware with the first function of export tab\nWe see in Process Hacker that the dll running by cmd & rundll32 that we use earlier.\n\n**Double-clicking on rundll32.exe, memory & strings tab we see interesting strings that**\nrunning in the memory:\n\nWhen we enter into task scheduler itself we see the task really created and ready to run.\n\nMapping . It means that the ransom wants to gain access to the physical disk and encrypts\nthe so the file system will not be readable.\nThe string below describe that\nIn simple words, our sample leaves no trace.\n\nWhen the victim’s computer will reboot the Petya will We will see it later after restarting our\nVM.\nThe messages that show up on victim’s screen.\nIn addition, I have opened the Procmon earlier with a number of filters to capture interesting\nprocesses like:\n\nOperation is\nProcess name is\nProcess Name contains\n\nAnd this is what we got!\n\nWe saw that the ransomware created a scheduled task to shut down the infected\n**machine at a specific time, and created tmp file “181E.tmp” in the**\n**AppData\\Local\\Temp path.**\n\nIt seems that the malware try to connect to\nIDA:\n\n- One of the thing I am doing when I dropped the file into IDA is to look on top of the scale. It\nindicates an interview of the situation of the code. For example, the olive color is an\n**unexplored code, and the pink one is external** **symbols that can indicate to us if our**\nsample using external DLL libraries. (Basically it’s a table that shows us memory location of\nevery symbol — API calls of the malware code)\n\n\n-----\n\n- The second thing I always look in the imports tab. Very important because we see which\nAPI calls the malware use.\n\nFor example, as we see in static analysis of the API call of WNetAddConnection2w, we can\nsee her references of her by pressing ”x” and maybe also our malware connection by\ndisabling the ASLR & set BP.\n\nExtension files that are targeted by the ransomware (you can find it in the )\nmalware “overwrites” the MBR. it pushes a file his name “Physicaldrive0” with a number of\narguments it including himself and then it goes to the DeviceControl function (I guess to\n**specify the device driver).**\n\nWhen we double clicking on the file, we see the interesting arguments it pushes.\n\nAnother interesting thing is one of the arguments that DeviceControl includes and this is\n:hDrive. its argument that gives a handle on the driver and retrieves information about the\nphysical disk, file, thread, etc.\n\n## Network Enumeration:\n\nAfter the malware get ComputerNameExW and before she created CreateThread we can\nsee condition (jz) with a very interesting argument that calls IpStratAddress which is the\nbeginning of rebuilding the SMB protocol.\n\nIf we go down little bit (after the thread creation) we see two calls to functions.\n\nIn the first one, we see a pushing argument like GetExtendedTcpTable which means\n“retrieve a list of TCP endpoints”. In other words get tcp connection of the local machine.\n\nIn the second, we see GetIpNetTable which means “give me your local network ip”.\n\nThe enumeration of SMB staring with the API call GetAdaptersInfo. The goal of this call is\nto get subnetmask of all network interfaces like workstations/servers. At the end of the call,\nwe have conditions which means jump if not zero to API call which retrieves inetaddr and\ncloses the socket or jumps to API call LocalFree which checks the free space on disk and\ngive clue if it is a server or either workstation.\n\nIt checks it with NetServerGetInfo api call.\n\nWhen we dive into the call of “Check_If_Server_Or_Not” we see three arguments that’s\n**pushed into the call of NetServerGetInfo (bufptr, level, servername).**\n\nThe first parameter contains 65h object which is equal to 101 in decimal. (just search in\ngoogle “how much is 0x65 in hexadecimal”).\n\n\n-----\n\nThe second one is empty which means equal to 0.\n\nFrom MSDN: bufptr is points to a server 101 info structure.\n\n** So 101 for me is the action of the malware return servername, type, and infrastructure. I\n**recommend describing this by inserting a comment (“;”).**\n\nSource: https://docs.microsoft.com/en-us/windows/win32/api/lmserver/ns-lmserverserver_info_101\n\n## Conclusion & Activities:\n\n- Dropped files\n\n- Token impersonation\n\n- Network node enumeration\n\n- SMB copy and remote execution\n\n- SMBv1 exploitation via EternalBlue\n\n- Recon and write malware to admin$ on the remote target\n\n- MBR ransomware\n\n- Physical drive manipulation\n\n- MFT encryption\n\n- System shutdown\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-01-29 - Petya-Not Petya Ransomware Analysis.pdf"
    ],
    "report_names": [
        "2023-01-29 - Petya-Not Petya Ransomware Analysis.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1675303687,
    "ts_updated_at": 1743041172,
    "ts_creation_date": 1675238125,
    "ts_modification_date": 1675238125,
    "files": {
        "pdf": "https://archive.orkl.eu/78ba6c69a942202ce180b1a0bfd8d53d7d784b58.pdf",
        "text": "https://archive.orkl.eu/78ba6c69a942202ce180b1a0bfd8d53d7d784b58.txt",
        "img": "https://archive.orkl.eu/78ba6c69a942202ce180b1a0bfd8d53d7d784b58.jpg"
    }
}