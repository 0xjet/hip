{
    "id": "feb4d083-79a1-4421-9a0a-1c5e66b6f95f",
    "created_at": "2023-01-12T14:59:52.944208Z",
    "updated_at": "2025-03-27T02:05:19.519972Z",
    "deleted_at": null,
    "sha1_hash": "c5e22fd158244c3964f1dc236a1236fd538ff772",
    "title": "2022-09-21 - Native function and Assembly Code Invocation",
    "authors": "",
    "file_creation_date": "2022-10-02T12:22:38Z",
    "file_modification_date": "2022-10-02T12:22:38Z",
    "file_size": 2802893,
    "plain_text": "# Native function and Assembly Code Invocation\n\n**[research.checkpoint.com/2022/native-function-and-assembly-code-invocation/](https://research.checkpoint.com/2022/native-function-and-assembly-code-invocation/)**\n\nSeptember 21, 2022\n**Author: Jiri Vinopal**\n\n## Introduction\n\n\nSeptember 21, 2022\n\n\nFor a reverse engineer, the ability to directly call a function from the analyzed binary can be a\nshortcut that bypasses a lot of grief. While in some cases it is just possible to understand the\nfunction logic and reimplement it in a higher-level language, this is not always feasible, and it\nbecomes less feasible the more the logic of the original function is fragile and sophisticated.\nThis is an especially sore issue when dealing with custom hashing and encryption — a single\noff-by-one error somewhere in the computation will cause complete divergence of the final\noutput, and is a mighty chore to debug.\n\nIn this article, we walk through 3 different ways to make this “shortcut” happen, and invoke\nfunctions directly from assembly. We first cover the [IDA Appcall feature which is natively](https://hex-rays.com/blog/introducing-the-appcall-feature-in-ida-pro-5-6/)\nsupported by IDA Pro, and can be used directly using IDAPython. We then demonstrate how\n[to achieve the same feat using Dumpulator; and finally, we will show how to get that result](https://github.com/mrexodia/dumpulator)\n[using emulation with Unicorn Engine. The practical example used in this article is based on](https://github.com/unicorn-engine/unicorn)\n[the “tweaked” SHA1 hashing algorithm implemented by a sample of the MiniDuke malware.](https://attack.mitre.org/software/S0051/)\n\n\n-----\n\n## Modified SHA1 Hashing algorithm implemented by MiniDuke\n\nThe modified SHA1 algorithm in the `MiniDuke sample is used to create a per-system`\nencryption key for the malware configuration. The buffer to be hashed contains the current\ncomputer name concatenated with DWORDs of all interface descriptions, e.g. `'DESKTOP-`\n```\nROAC4IJ\\x00MicrWAN WAN MicrWAN MicrWAN InteWAN InteWAN Inte' . This function\n\n```\n( SHA1Hash ) uses the same constants as the original SHA1 for both the initial digest and\nintermediate stages, but produces different outputs.\n\nFigure 1: MiniDuke SHA1Hash function constants\nSince the constants used are all the same in the original and modified SHA1, the difference\nmust occur somewhere in one of the function’s 1,241 assembly instructions. We cannot say\nwhether this tweak was introduced intentionally but the fact remains that malware authors\nare growing fonder of inserting “surprises” like this, and it falls to analysts to deal with them.\nTo do so, we must first understand in what form the function expects its input and produces\nits output.\n\nAs it turns out, the Duke-SHA1 assembly uses a custom calling convention where the length\nof buffer to be hashed is passed in the `ecx register and the address of the buffer itself in`\n```\nedi . A value is technically also passed in eax but this value is identically 0xffffffff\n\n```\nwhenever the executable invokes the function, and we can treat it as a constant for our\npurposes. Interestingly, the malware also sets the buffer length ( ecx ) to `0x40 every time it`\ninvokes this function, effectively hashing only the first `0x40 bytes of the buffer.`\n\n\n-----\n\nFigure 2: SHA1Hash\n\nfunction arguments\nThe resulting 160-bit SHA1 hash value is returned in 5 dwords in registers (from high dword\nto low: `eax,` `edx,` `ebx,` `ecx,` `esi ). For example, the buffer` `DESKTOP-`\n```\nROAC4IJ\\x00MicrWAN WAN MicrWAN MicrWAN InteWAN InteWAN Inte has a Duke-SHA1\n\n```\nvalue of `1851fff77f0957d1d690a32f31df2c32a1a84af7, returned as` `EAX:0x1851fff7`\n```\nEDX:0x7f0957d1 EBX:0xd690a32f ECX:0x31df2c32 ESI:0xa1a84af7 .\n\n```\nFigure 3: Example produced SHA1 Hash of buffer\nAs explained before, hunting down the exact place(s) where the logic of SHA1 and DukeSHA1 diverge and then reimplementing Duke-SHA1 in Python is an excellent way to waste a\nday, and possibly a week. Instead, we will use several approaches to “plug into” the\nfunction’s calling convention and invoke it directly.\n\n## IDA – Appcall\n```\nAppcall is a feature of IDA Pro which allows IDA Python scripts to call functions inside the\n\n```\ndebugged program as if they were built-in functions. This is very convenient, but it also\nsuffers from the typical curse of convenient solutions, which is a very sharp spike in difficulty\nof application when the use case gets somewhat unusual or complex. Alas, such is the case\nhere: while passing a buffer length in `ecx and a buffer in` `edi is par for the course, the`\n160-bit return value split across 5 registers is not your typical form of function output, and\nAppcall requires some creative coercion to cooperate with what we want it to do here.\n\n\n-----\n\nWe proceed by creating a custom structure `struc_SHA1HASH which holds the values of 5`\nregisters, and is used as a return type of the function prototype:\n```\nSTRUCT_NAME = \"struc_SHA1HASH\"\n\n# ------------------Struct Creation -----------------\nsid = idc.get_struc_id(STRUCT_NAME)\n\nif (sid != -1):\n\n  idc.del_struc(sid)\n\nsid = idc.add_struc(-1, STRUCT_NAME, 0)\n\nidc.add_struc_member(sid, \"_EAX_\", -1, idc.FF_DWORD, -1, 4)\n\nidc.add_struc_member(sid, \"_EDX_\", -1, idc.FF_DWORD, -1, 4)\n\nidc.add_struc_member(sid, \"_EBX_\", -1, idc.FF_DWORD, -1, 4)\n\nidc.add_struc_member(sid, \"_ECX_\", -1, idc.FF_DWORD, -1, 4)\n\nidc.add_struc_member(sid, \"_ESI_\", -1, idc.FF_DWORD, -1, 4)\n\n\n```\nFigure 4: IDA\n\nStructure Window – “struc_SHA1HASH”\nNow with the structure definition in place, we are poised to invoke the magic incantation that\nwill allow Appcall to interface with this function prototype, as seen in the `PROTO value`\nbelow.\n```\n# ------------------Initialization -----------------\nFUNC_NAME = \"SHA1Hash\"\n\nSTRUCT_NAME = \"struc_SHA1HASH\"\n\nPROTO = \"{:s} __usercall {:s}@<0:eax, 4:edx, 8:ebx, 12:ecx, 16:esi>(int\n[email protected]<ecx>, const [email protected]<eax>, BYTE *[email protected]\n<edi>);\".format(STRUCT_NAME, FUNC_NAME) # specify prototype of SHA1Hash function\nSHA1BUFF_LEN = 0x40\n\nCONSTVAL = 0xffffffff\n\n\n```\nAs IDA Appcall relies on the debugger, to invoke this logic we first need to write a script that\nwill start the debugger, make required adjustments to the stack and do other required\nhousekeeping.\n\n\n-----\n\n```\n#  Setting + Starting Debugger\nidc.load_debugger(\"win32\",0)         # select Local Windows Debugger\n\nidc.set_debugger_options(idc.DOPT_ENTRY_BPT) # break on program entry point\n\nidc.start_process(\"\",\"\",\"\")         # start process with default options\n\nidc.wait_for_next_event(idc.WFNE_SUSP, 3)  # waits until process get suspended on\nentrypoint\n\neip = idc.get_reg_value(\"eip\")        # get EIP\n\nidc.run_to(eip + 0x1d)            # let the stack adjust itself (execute\nfew instructions)\n\nidc.wait_for_next_event(idc.WFNE_SUSP, 3)  # waits until process get suspended\nafter stack adjustment\n\n```\nFigure 5: IDA View – Stack adjusting\nUsing Appcall is the last step, and there are several ways to utilize it to call functions. We can\ncall the function directly without specifying a prototype, but this highly relies on a properly\ntyped function in IDA’s IDB. The second way is to create a callable object from the function\nname and a defined prototype. This way we can call a function with a specific prototype, no\nmatter what type is set in the IDB, as shown below:\n```\nSHA1Hash = Appcall.proto(FUNC_NAME, PROTO)  # creating callable object\n\ninBuff = Appcall.byref(b'DESKTOP-ROAC4IJ\\x00MicrWAN WAN MicrWAN MicrWAN InteWAN\nInteWAN Inte')\n\nbuffLen = SHA1BUFF_LEN\n\nconst = CONSTVAL\n\nretValue = SHA1Hash(buffLen, const, inBuff)\n\neax = malduck.DWORD(retValue._EAX_)\n\nedx = malduck.DWORD(retValue._EDX_)\n\nebx = malduck.DWORD(retValue._EBX_)\n\necx = malduck.DWORD(retValue._ECX_)\n\nesi = malduck.DWORD(retValue._ESI_)\n\n\n```\nThe full script to call Duke-SHA1 using Appcall is reproduced below.\n\n\n-----\n\n```\n# IDAPython script to demonstrate Appcall feature on modified SHA1 Hashing algorithm\nimplemented by MiniDuke malware sample\n\n# SHA1 HASH is stored in EAX, EDX, EBX, ECX, ESI (return values)\n\n# SHA1 HASH Arguments -> ECX = 0x40 (buffLen), EAX = 0xFFFFFFFF (const), EDI = BYTE\n*buffer (buffer)\n\nimport idc, malduck\n\nfrom idaapi import Appcall\n\n# ------------------Initialization -----------------\nFUNC_NAME = \"SHA1Hash\"\n\nSTRUCT_NAME = \"struc_SHA1HASH\"\n\nPROTO = \"{:s} __usercall {:s}@<0:eax, 4:edx, 8:ebx, 12:ecx, 16:esi>(int\n[email protected]<ecx>, const [email protected]<eax>, BYTE *[email protected]\n<edi>);\".format(STRUCT_NAME, FUNC_NAME) # specify prototype of SHA1Hash function\nSHA1BUFF_LEN = 0x40\n\nCONSTVAL = 0xffffffff\n\n# ------------------Struct Creation -----------------\nsid = idc.get_struc_id(STRUCT_NAME)\n\nif (sid != -1):\n\n  idc.del_struc(sid)\n\nsid = idc.add_struc(-1, STRUCT_NAME, 0)\n\nidc.add_struc_member(sid, \"_EAX_\", -1, idc.FF_DWORD, -1, 4)\n\nidc.add_struc_member(sid, \"_EDX_\", -1, idc.FF_DWORD, -1, 4)\n\nidc.add_struc_member(sid, \"_EBX_\", -1, idc.FF_DWORD, -1, 4)\n\nidc.add_struc_member(sid, \"_ECX_\", -1, idc.FF_DWORD, -1, 4)\n\nidc.add_struc_member(sid, \"_ESI_\", -1, idc.FF_DWORD, -1, 4)\n\n# ------------------ Setting + Starting Debugger -----------------\nidc.load_debugger(\"win32\",0)         # select Local Windows Debugger\n\nidc.set_debugger_options(idc.DOPT_ENTRY_BPT) # break on program entry point\n\nidc.start_process(\"\",\"\",\"\")         # start process with default options\n\nidc.wait_for_next_event(idc.WFNE_SUSP, 3)  # waits until process get suspended on\nentrypoint\n\neip = idc.get_reg_value(\"eip\")        # get EIP\n\nidc.run_to(eip + 0x1d)            # let the stack adjust itself (execute\nfew instructions)\n\nidc.wait_for_next_event(idc.WFNE_SUSP, 3)  # waits until process get suspended\nafter stack adjustment\n\n# ------------------ Arguments + Execution -----------------\nSHA1Hash = Appcall.proto(FUNC_NAME, PROTO)  # creating callable object\n\ninBuff = Appcall.byref(b'DESKTOP-ROAC4IJ\\x00MicrWAN WAN MicrWAN MicrWAN InteWAN\nInteWAN Inte')\n\nbuffLen = SHA1BUFF_LEN\n\nconst = CONSTVAL\n\nretValue = SHA1Hash(buffLen, const, inBuff)\n\neax = malduck.DWORD(retValue._EAX_)\n\nedx = malduck.DWORD(retValue._EDX_)\n\nebx = malduck.DWORD(retValue._EBX_)\n\n```\n\n-----\n\n```\necx malduck.DWORD(retValue._ECX_)\n\nesi = malduck.DWORD(retValue._ESI_)\n\n# ------------------ RESULTS -----------------\nprint(\"SHA1 HASH RET VALUES: EAX:0x%x EDX:0x%x EBX:0x%x ECX:0x%x ESI:0x%x\" % (eax,\nedx, ebx, ecx, esi))\n\n# ------------------ Exiting Debugger -----------------\nidc.exit_process()\n\n```\nAnd some sample output:\n\nFigure 6: Script execution – “IDA Appcall” producing the same SHA1 Hash values as the\nMiniDuke sample\nThe above is fine if we just want to use the invoked function as a black box, but sometimes\nwe may want access to registry values in a specific state of execution, and specifying the\nprototype as above is something of a chore. Happily, both these downsides can be mitigated,\nas we will see below.\n\nAs IDA Appcall relies on the debugger and can be invoked right from IDAPython, we can\ninvoke Appcall from the debugger and gain more granular control over its execution. For\nexample, we can make Appcall hand control back to the debugger during execution by\nsetting a special option for Appcall – `APPCALL_MANUAL .`\n\n\n-----\n\n```\n#  Arguments + Execution\nSHA1Hash = Appcall.proto(FUNC_NAME, PROTO)  # creating callable object\n\nSHA1Hash.options = Appcall.APPCALL_MANUAL  # APPCALL_MANUAL option will cause the\ndebugger to break on function entry and gives the control to debugger\n\ninBuff = Appcall.byref(b'DESKTOP-ROAC4IJ\\x00MicrWAN WAN MicrWAN MicrWAN InteWAN\nInteWAN Inte')\n\nbuffLen = SHA1BUFF_LEN\n\nconst = CONSTVAL\n\nSHA1Hash(buffLen, const, inBuff)       # invoking Appcall and breaking on\nfunction entry (SHA1Hash)\n\n```\nThis way we can make use of Appcall to prepare arguments, allocate a buffer and later\nrestore the previous execution context. We can also avoid specifying the structure type for\nthe return value (type it as `void ) as this will be handled by the debugger. There are more`\nways to get the return values of the function, so as we are now controlling the debugger, we\ncan use (for example) a conditional breakpoint to print desired values in a specific state of\nexecution (such as on return).\n```\n# ------------------Set conditional BP on Return -----------------\ndef SetCondBPonRet():\n\n  cond = \"\"\"import idc\n\nprint(\"SHA1 HASH RET VALUES: EAX:0x%x EDX:0x%x EBX:0x%x ECX:0x%x ESI:0x%x\" %\n(idc.get_reg_value(\"eax\"), idc.get_reg_value(\"edx\"), idc.get_reg_value(\"ebx\"),\nidc.get_reg_value(\"ecx\"), idc.get_reg_value(\"esi\")))\n\nreturn True\n\n\"\"\"\n\n  func = idaapi.get_func(idc.get_name_ea_simple(FUNC_NAME))\n\n  bpt = idaapi.bpt_t()\n\n  bpt.ea = idc.prev_head(func.end_ea)   # last instruction in function -> should\nbe return\n\n  bpt.enabled = True\n\n  bpt.type = idc.BPT_SOFT\n\n  bpt.elang = 'Python'\n\n  bpt.condition = cond           # with script code in condition we can\nget or log any values we want\n\n  idc.add_bpt(bpt)\n\n  return bpt                # return breakpoint object -> will be\ndeleted later on\n\n\n```\nWe can restore the previous state (before Appcall invocation) at any desired moment of\nexecution by calling `cleanup_appcall() . So in our case, right after hitting the conditional`\nbreakpoint.\n\n\n-----\n\n```\nSHA1Hash(buffLen, const, inBuff)       # invoking Appcall and breaking on\nfunction entry (SHA1Hash)\n\nidc.wait_for_next_event(idc.WFNE_SUSP, 3)\n\nidaapi.continue_process()          # debugger has control now so continue\nto hit the new conditional breakpoint\n\nidc.wait_for_next_event(idc.WFNE_SUSP, 3)\n\nidc.del_bpt(bpt.ea)             # deleting the previously created\nconditional breakpoint\n\nAppcall.cleanup_appcall()          # clean Appcall after hitting the\nconditional breakpoint -> return\n\n```\nThe full script is reproduced below.\n\n\n-----\n\n```\n# IDAPython script to demonstrate Appcall feature on modified SHA1 Hashing algorithm\nimplemented by MiniDuke malware sample\n\n# SHA1 HASH is stored in EAX, EDX, EBX, ECX, ESI (return values)\n\n# SHA1 HASH Arguments -> ECX = 0x40 (buffLen), EAX = 0xFFFFFFFF (const), EDI = BYTE\n*buffer (buffer)\n\nimport idc, idaapi\n\nfrom idaapi import Appcall\n\n# ------------------ Initialization -----------------\nFUNC_NAME = \"SHA1Hash\"\n\nPROTO = \"void __usercall {:s}(int [email protected]<ecx>, const [email protected]\n<eax>, BYTE *[email protected]<edi>);\".format(FUNC_NAME) # specify prototype of\nSHA1Hash function\n\nSHA1BUFF_LEN = 0x40\n\nCONSTVAL = 0xffffffff\n\n# ------------------Set conditional BP on Return -----------------\ndef SetCondBPonRet():\n\n  cond = \"\"\"import idc\n\nprint(\"SHA1 HASH RET VALUES: EAX:0x%x EDX:0x%x EBX:0x%x ECX:0x%x ESI:0x%x\" %\n(idc.get_reg_value(\"eax\"), idc.get_reg_value(\"edx\"), idc.get_reg_value(\"ebx\"),\nidc.get_reg_value(\"ecx\"), idc.get_reg_value(\"esi\")))\n\nreturn True\n\n\"\"\"\n\n  func = idaapi.get_func(idc.get_name_ea_simple(FUNC_NAME))\n\n  bpt = idaapi.bpt_t()\n\n  bpt.ea = idc.prev_head(func.end_ea)   # last instruction in function -> should\nbe return\n\n  bpt.enabled = True\n\n  bpt.type = idc.BPT_SOFT\n\n  bpt.elang = 'Python'\n\n  bpt.condition = cond           # with script code in condition we can\nget or log any values we want\n\n  idc.add_bpt(bpt)\n\n  return bpt                # return breakpoint object -> will be\ndeleted later on\n\n# ------------------ Setting + Starting Debugger -----------------\nidc.load_debugger(\"win32\",0)         # select Local Windows Debugger\n\nidc.set_debugger_options(idc.DOPT_ENTRY_BPT) # break on program entry point\n\nbpt = SetCondBPonRet()            # setting the conditional breakpoint on\nfunction return\n\nidc.start_process(\"\",\"\",\"\")         # start process with default options\n\nidc.wait_for_next_event(idc.WFNE_SUSP, 3)  # waits until process get suspended on\nentrypoint\n\neip = idc.get_reg_value(\"eip\")        # get EIP\n\nidc.run_to(eip + 0x1d)            # let the stack adjust itself (execute\nfew instructions)\n\nidc.wait_for_next_event(idc.WFNE_SUSP, 3)  # waits until process get suspended\nafter stack adjustment\n\n\n```\n\n-----\n\n```\n#  Arguments + Execution\nSHA1Hash = Appcall.proto(FUNC_NAME, PROTO)  # creating callable object\n\nSHA1Hash.options = Appcall.APPCALL_MANUAL  # APPCALL_MANUAL option will cause the\ndebugger to break on function entry and gives the control to debugger\n\ninBuff = Appcall.byref(b'DESKTOP-ROAC4IJ\\x00MicrWAN WAN MicrWAN MicrWAN InteWAN\nInteWAN Inte')\n\nbuffLen = SHA1BUFF_LEN\n\nconst = CONSTVAL\n\nSHA1Hash(buffLen, const, inBuff)       # invoking Appcall and breaking on\nfunction entry (SHA1Hash)\n\nidc.wait_for_next_event(idc.WFNE_SUSP, 3)\n\nidaapi.continue_process()          # debugger has control now so continue\nto hit the new conditional breakpoint\n\nidc.wait_for_next_event(idc.WFNE_SUSP, 3)\n\nidc.del_bpt(bpt.ea)             # deleting the previously created\nconditional breakpoint\n\nAppcall.cleanup_appcall()          # clean Appcall after hitting the\nconditional breakpoint -> return\n\n# ------------------ Exiting Debugger -----------------\nidc.exit_process()\n\n## Dumpulator\n\n```\n[Dumpulator is a python library that assists with code emulation in minidump files. The core](https://docs.microsoft.com/en-us/windows/win32/debug/minidump-files)\n[emulation engine of dumpulator is based on Unicorn Engine, but a relatively unique feature](https://github.com/unicorn-engine/unicorn)\namong other similar tools is that the entire process memory is available. This brings a\nperformance improvement (emulating large parts of analyzed binary without leaving\nUnicorn), as well as making life more convenient if we can time the memory dump to when\nthe program context (stack, etc) required to call the function is already in place. Additionally,\nonly syscalls have to be emulated to provide a realistic Windows environment (since\neverything actually is a legitimate process environment).\n\nA minidump of the desired process could be captured with many tools (x64dbg –\nMiniDumpPlugin, [Process Explorer,](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer) [Process Hacker, Task Manager) or with the Windows](https://processhacker.sourceforge.io/nightly.php)\n[API ( MiniDumpWriteDump). We can use the x64dbg – MiniDumpPlugin to create a](https://docs.microsoft.com/en-us/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump)\nminidump in a state where almost all in the process is already set for SHA1 Hash creation,\nright before the `SHA1Hash function call. Note that timing the dump this way is not`\n_necessary, as the environment can be set up manually in dumpulator after taking the dump;_\nit is just convenient.\n\n\n-----\n\nFigure 7: Creation of minidump using “x64dbg – MiniDumpPlugin”\nDumpulator not only has access to the entire dumped process memory but can also allocate\nadditional memory, read memory, write to memory, read registry values, and write registry\nvalues. In other words, anything that an emulator can do. There is also a possibility to\nimplement system calls so code using them can be emulated.\n\nTo invoke Duke-SHA1 via Dumpulator, we need to specify the address of the function which\nwill be called in `minidump and its arguments. In this case, the address of` `SHA1Hash is`\n```\n0x407108 .\n\n```\nFigure 8: Opening produced minidump in IDA\n\n\n-----\n\nAs we do not want to use already set values in the current state of minidump, we define our\nown argument values for the function. We can even allocate a new buffer which will be used\nas a buffer to be hashed. The decidedly elegant code to do this is shown below.\n```\n# Python script to demonstrate dumpulator on modified SHA1 Hashing algorithm\nimplemented by MiniDuke malware sample\n\n# SHA1 HASH is stored in EAX, EDX, EBX, ECX, ESI (return values)\n\n# SHA1 HASH Arguments -> ECX = 0x40 (buffLen), EAX = 0xFFFFFFFF (const), EDI = BYTE\n*buffer (buffer)\n\nfrom dumpulator import Dumpulator\n\n# ------------------Initialization -----------------\nFUNC_ADDR = 0x407108      # address of SHA1Hash function in MiniDuke\n\nSHA1BUFF_LEN = 0x40\n\nCONSTVAL = 0xffffffff\n\n# ------------------ Setting + Starting Dumpulator -----------------\ndp = Dumpulator(\"miniduke.dmp\", quiet=True)\n\ninBuff = b'DESKTOP-ROAC4IJ\\x00MicrWAN WAN MicrWAN MicrWAN InteWAN InteWAN Inte'\n\nbufferAddr = dp.allocate(64)\n\ndp.write(bufferAddr, inBuff)\n\n#dp.regs.ecx = SHA1BUFF_LEN   # possible to set the registers here\n\n#dp.regs.eax = CONSTVAL\n\n#dp.regs.edi = bufferAddr\n\n#dp.call(FUNC_ADDR)\n\ndp.call(FUNC_ADDR, regs= {\"eax\": CONSTVAL, \"ecx\": SHA1BUFF_LEN, \"edi\": bufferAddr})\n\n# ------------------ RESULTS -----------------\nprint(\"SHA1 HASH RET VALUES: EAX:0x%x EDX:0x%x EBX:0x%x ECX:0x%x ESI:0x%x\" %\n(dp.regs.eax, dp.regs.edx, dp.regs.ebx, dp.regs.ecx, dp.regs.esi))\n\n\n```\nExecution of this script will produce correct Duke-SHA1 values.\n\nFigure 9: Script execution – “Dumpulator” producing the same SHA1 Hash values as the\nMiniDuke sample\n\n\n-----\n\n## Emulation – Unicorn Engine\n\nFor the emulation approach, we can use any kind of CPU emulator (ex. Qiling, Speakeasy,\netc.) which is able to emulate x86 assembly and has bindings for Python language. As we do\nnot need any higher abstraction level (Syscalls, API functions) we can use the one which\n[most of the others are based on – Unicorn Engine.](https://github.com/unicorn-engine/unicorn)\n\nUnicorn is a lightweight, multi-platform, multi-architecture CPU emulator framework, based\non QEMU, which is implemented in pure C language with bindings for many other\nlanguages. We will be using Python bindings. Our goal is to create an independent function\n```\nSHA1Hash which can be called like any other ordinary function in Python, producing the\n\n```\nsame SHA1 hashes as the original one in MiniDuke. The idea behind the implementation we\nuse is pretty straightforward — we simply extract the opcode bytes of the function and use\nthem via the CPU emulation.\n\nExtracting all bytes of original function opcodes can be done simply via IDAPython or using\nIDA→Edit→Export Data.\n```\n# IDAPython - extracting opcode bytes of SHA1Hash function\n\nimport idaapi, idc\n\nSHA1HashAddr = idc.get_name_ea_simple(\"SHA1Hash\")\n\nSHA1Hash = idaapi.get_func(SHA1HashAddr)\n\nSHA1HASH_OPCODE = idaapi.get_bytes(SHA1Hash.start_ea, SHA1Hash.size())\n\nSHA1HASH_OPCODE.hex()\n\n# Output: '0f6ec589cb8dad74a3[...]'\n\n```\n\n-----\n\nFigure 10: Using IDA “Export data” dialog to export opcode bytes of SHA1Hash function\nAs in the previous approaches, we need to set up the context for execution. In this case this\nmeans preparing arguments for the function, and setting addresses for our extracted\nopcodes and input buffer.\n```\n# ------------------Initialization -----------------\n# remove \"retn\" instruction from SHA1Hash function opcodes or ->\nUC_ERR_FETCH_UNMAPPED -> no ret address on stack\n\nSHA1HASH_OPCODE = b\"\\x0f\\x6e\\xc5\\x89\\xcb\\x8d\\xad\\x74\\xa3...........................\"\n\nOPCODE_ADDRESS = 0x400000\n\nSHA1BUFF_LEN = 0x40\n\nCONSTVAL = 0xffffffff\n\nBUFFERADDR = OPCODE_ADDRESS + 0x200000\n\n\n```\nNote that the last `retn instruction should be deleted from the extracted opcode listing in`\norder to not transfer back execution to the return address on the stack, and the stack frame\nshould be manually set up by specifying values for `ebp and` `esp . All these things are`\nshown in the final Python script below.\n\n\n-----\n\n```\n# Python script to demonstrate Unicorn emulator on modified SHA1 Hashing algorithm\nimplemented by MiniDuke malware sample\n\n# SHA1 HASH is stored in EAX, EDX, EBX, ECX, ESI (return values)\n\n# SHA1 HASH Arguments -> ECX = 0x40 (buffLen), EAX = 0xFFFFFFFF (const), EDI = BYTE\n*buffer (buffer)\n\nfrom unicorn import *\n\nfrom unicorn.x86_const import *\n\ndef GetMinidukeSHA1(inBuff:bytes) -> Uc:\n\n  # ------------------Initialization -----------------\n  # remove \"retn\" instruction from SHA1Hash function opcodes or ->\nUC_ERR_FETCH_UNMAPPED -> no ret address on stack\n\n  SHA1HASH_OPCODE =\nb\"\\x0f\\x6e\\xc5\\x89\\xcb\\x8d\\xad\\x74\\xa3...........................\"\n\n  OPCODE_ADDRESS = 0x400000\n\n  SHA1BUFF_LEN = 0x40\n\n  CONSTVAL = 0xffffffff\n\n  BUFFERADDR = OPCODE_ADDRESS + 0x200000\n\n  # ------------------ Setting + Starting Emulator -----------------\n  try:\n\n    mu = Uc(UC_ARCH_X86, UC_MODE_32)                    # set\nEMU architecture and mode\n\n    mu.mem_map(OPCODE_ADDRESS, 0x200000, UC_PROT_ALL)            # map\nmemory for SHA1Hash function opcodes, stack etc.\n\n    mu.mem_write(OPCODE_ADDRESS, SHA1HASH_OPCODE)              #\nwrite opcodes to memory\n\n    mu.mem_map(BUFFERADDR, 0x1000, UC_PROT_ALL)               # map\nmemory for input to be hashed\n\n    mu.mem_write(BUFFERADDR, inBuff)                    #\nwrite input bytes to memory\n\n    mu.reg_write(UC_X86_REG_ESP, OPCODE_ADDRESS + 0x100000)         #\ninitialize stack (ESP)\n\n    mu.reg_write(UC_X86_REG_EBP, OPCODE_ADDRESS + 0x100000)         #\ninitialize frame pointer (EBP)\n\n    mu.reg_write(UC_X86_REG_EAX, CONSTVAL)                 # set\nEAX register (argument) -> CONSTVAL\n\n    mu.reg_write(UC_X86_REG_ECX, SHA1BUFF_LEN)               # set\nECX register (argument) -> SHA1BUFF_LEN\n\n    mu.reg_write(UC_X86_REG_EDI, BUFFERADDR)                # set\nEDI register (argument) -> BUFFERADDR to be hashed\n\n    mu.emu_start(OPCODE_ADDRESS, OPCODE_ADDRESS + len(SHA1HASH_OPCODE))   #\nstart emulation of opcodes\n\n    return mu\n\n  except UcError as e:\n\n    print(\"ERROR: %s\" % e)\n\n# ------------------ RESULTS -----------------\ninBuff = b'DESKTOP-ROAC4IJ\\x00MicrWAN WAN MicrWAN MicrWAN InteWAN InteWAN Inte'\n\n```\n\n-----\n\n```\nmu GetMinidukeSHA1(inBuff)\n\nprint(\"SHA1 HASH RET VALUES: EAX:0x%x EDX:0x%x EBX:0x%x ECX:0x%x ESI:0x%x\" %\n(mu.reg_read(UC_X86_REG_EAX), mu.reg_read(UC_X86_REG_EDX),\nmu.reg_read(UC_X86_REG_EBX), mu.reg_read(UC_X86_REG_ECX),\nmu.reg_read(UC_X86_REG_ESI)))\n\n```\nThe script output can be seen below.\n\nFigure 11: Script execution – “Unicorn Engine” producing the same SHA1 Hash values as\nthe MiniDuke sample\n\n## Conclusion\n\nAll the above-described methods for direct invocation of assembly have their advantages\nand disadvantages. We were particularly impressed by the easy-to-use Dumpulator which is\nfree, fast to implement, and highly effective. It is well suited for writing universal string\ndecryptors, config extractors, and other contexts where many different logic fragments have\nto be called in sequence while preserving a hard-to-set-up context.\n\nThe IDA Appcall feature is one of the best solutions in situations where we would like to\nenrich the IDA database directly with results produced by the invocation of a specific\nfunction. Syscalls could be a part of such a function as Appcall is usually used in real\nexecution environments – using a debugger. One of the greatest things about Appcall is the\nfast and easy context restoration. As Appcall relies on a debugger and could be used\ntogether with IDAPython scripting, it could even in theory be used as a basis for a fuzzer,\nfeeding random input to functions in order to discover unexpected behavior (i.e. bugs),\nthough the performance overhead might make this approach not very practical.\n\n\n-----\n\nUsing pure emulation via Unicorn Engine is a universal solution for the independent\nimplementation of specific functionality. With this approach, it is possible to take a part of the\ncode as-is and use it with no connection to the original sample. This method does not rely on\na runnable sample and there is no problem to re-implement functionality for just a part of the\ncode. This approach may be harder to implement for functions that are not a contiguous,\neasily-dumpable block of code. For part of code where APIs or syscalls occur, or the\nexecution context is much harder to set up, the previously mentioned methods are usually a\npreferable choice.\n\n## Pros and Cons Summary\n\n### IDA Appcall\n\nPROS:\n\nNatively supported by IDA\nPossible to use with `IDAPython right in the context of IDA.`\nNatively understands higher abstraction layer so Windows APIs and syscalls can be a\npart of the invoked function.\nCan be used on corrupted code/file with `Bochs emulator` `IDB emulate feature (non-`\nrunnable sample).\nThe combination of the `Appcall feature and scriptable debugger is very powerful,`\ngiving us full control at any moment of Appcall execution.\n\nCONS:\n\nPrototypes of more sophisticated functions using custom calling conventions\n( __usercall ) are harder to implement.\nInvoked assembly needs to be a function, not just part of code.\n\n### Dumpulator\n\nPROS:\n\nVery easy-to-use. Code making use of it is Pythonic and fast to implement.\nIf a minidump is obtained in a state where all context is already set, with no need to\nmap memory or set things like a stack, frame pointer, or even arguments, Dumpulator\ncan leverage this to de-clutter the invocation code even further.\nUnderstands the higher abstraction layer and allows use of syscalls (though some may\nneed to be implemented manually).\nEnables lower access level to modify the context in a similar way to usual emulation.\nCan be used to emulate part of code (does not have to be a function)\n\nCONS:\n\n\n-----\n\nRequires a minidump of the desired process to be worked on, which in turn requires a\nrunnable binary sample.\n\n### Emulation – Unicorn Engine\n\nPROS:\n\nThe most independent solution, requires only the interesting assembly code.\nLow access level to set and modify context.\nCan be used to emulate part of code fully independently. Allows free modification and\npatching of instructions on the fly.\n\nCONS:\n\nHarder to map memory and set the context of the emulation engine correctly.\nNo out-of-the-box access to higher abstraction layer and system calls.\n\n## References\n\n### IDA – Appcall\n\n[https://hex-rays.com/blog/introducing-the-appcall-feature-in-ida-pro-5-6/](https://hex-rays.com/blog/introducing-the-appcall-feature-in-ida-pro-5-6/)\n\n[https://hex-rays.com/blog/practical-appcall-examples/](https://hex-rays.com/blog/practical-appcall-examples/)\n\n[https://www.hex-rays.com/wp-content/uploads/2019/12/debugging_appcall.pdf](https://www.hex-rays.com/wp-content/uploads/2019/12/debugging_appcall.pdf)\n\n### Dumpulator\n\n[https://github.com/mrexodia/dumpulator](https://github.com/mrexodia/dumpulator)\n\n[https://github.com/mrexodia/MiniDumpPlugin](https://github.com/mrexodia/MiniDumpPlugin)\n\n### Unicorn Engine\n\n[https://github.com/unicorn-engine/unicorn](https://github.com/unicorn-engine/unicorn)\n\n[https://github.com/unicorn-engine/unicorn/tree/master/bindings/python](https://github.com/unicorn-engine/unicorn/tree/master/bindings/python)\n\n### Samples + Scripts (password:infected)\n\n[1. Original MiniDuke sample: VirusTotal,](https://www.virustotal.com/gui/file/364ebe4f568a0b1c2217fa90e04b4712cdefcda363d99630c39a7b10cf249581) [miniduke_original.7z](https://research.checkpoint.com/wp-content/uploads/2022/09/miniduke_original.7z)\n[2. Unpacked MiniDuke sample: miniduke_unpacked.7z](https://research.checkpoint.com/wp-content/uploads/2022/09/miniduke_unpacked.7z)\n[3. MiniDuke minidump: miniduke_minidump.7z](https://research.checkpoint.com/wp-content/uploads/2022/09/miniduke_minidump.7z)\n[4. All scripts mentioned in the article: IDAPython_PythonScripts.7z](https://research.checkpoint.com/wp-content/uploads/2022/09/IDAPython_PythonScripts.7z)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-21 - Native function and Assembly Code Invocation.pdf"
    ],
    "report_names": [
        "2022-09-21 - Native function and Assembly Code Invocation.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535592,
    "ts_updated_at": 1743041119,
    "ts_creation_date": 1664713358,
    "ts_modification_date": 1664713358,
    "files": {
        "pdf": "https://archive.orkl.eu/c5e22fd158244c3964f1dc236a1236fd538ff772.pdf",
        "text": "https://archive.orkl.eu/c5e22fd158244c3964f1dc236a1236fd538ff772.txt",
        "img": "https://archive.orkl.eu/c5e22fd158244c3964f1dc236a1236fd538ff772.jpg"
    }
}