{
    "id": "831a61fd-5353-46fb-8790-bea532a55f3b",
    "created_at": "2023-01-12T15:08:50.736064Z",
    "updated_at": "2025-03-27T02:06:03.239716Z",
    "deleted_at": null,
    "sha1_hash": "f718a25bf58cbd5a7818467bbfc31ce66d637d22",
    "title": "2017-02-24 - Necurs Proxy Module With DDOS Features",
    "authors": "",
    "file_creation_date": "2022-05-28T15:21:37Z",
    "file_modification_date": "2022-05-28T15:21:37Z",
    "file_size": 2574152,
    "plain_text": "# Necurs Proxy Module With DDOS Features\n\n**[bitsighttech.com/blog/necurs-proxy-module-with-ddos-features](https://www.bitsighttech.com/blog/necurs-proxy-module-with-ddos-features)**\n\nWritten by Sofia Luis February 24, 2017 Share Facebook Twitter LinkedIn\n\nNecurs is a malware that is mainly known for sending large spam campaigns, most notably\nthe Locky ransomware. However, Necurs is not only a spambot, it is a modular piece of\nmalware that is composed of a main bot module, a userland rootkit and it can dynamically\nload additional modules.\n\nHaving been around for a few years, this malware has been subject to a lot of great research\nthat has covered many of its aspects [including](https://www.virusbulletin.com/virusbulletin/2014/04/curse-necurs-part-1) [the](https://www.virusbulletin.com/virusbulletin/2014/05/curse-necurs-part-2) [rootkit,](https://www.virusbulletin.com/virusbulletin/2014/06/curse-necurs-part-3) [the DGA,](https://www.johannesbader.ch/2015/02/the-dgas-of-necurs/) the communication\nprotocol and the spam module. However, there has not been much public information on any\nmodules loaded by Necurs besides the spam module.\n\nAbout six months ago we noticed that besides the usual port 80 communications, a Necurs\ninfected system was communicating with a set of IPs on a different port using, what\nappeared to be, a different protocol. The following image shows an example of this network\ntraffic.\n\n\n-----\n\nRecently, while decrypting the C2 communication of the a Necurs bot, we observed a request\nto load two different modules, each with a different parameter list. The following is the\ndecrypted translation of the modules section of the C2 response:\n\nThe first one was the spam module for which Necurs is most known, and the parameters are\nthe C2 addresses from which it can receive new spam campaigns. The second one was an\nunknown module and, judging by the parameter values, it was the one responsible for the\ncommunication we were seeing to port 5222.\n\n\n-----\n\nWe noticed this module in September 2016 and the compilation timestamp on the module is\n“Aug 23 2016”, which suggests the module started being used around then. However, it is\npossible that another version of the same module had been deployed before, without being\nnoticed.\n\nWe downloaded the module and reverse engineered it to try to understand exactly what it\nwas. At first look, it seemed to be a simple SOCKS/HTTP proxy module, but as we looked at\nthe commands the bot would accept from the C2 we realized that there was an additional\ncommand, that would cause the bot to start making HTTP or UDP requests to an arbitrary\ntarget in an endless loop, in a way that could only be explained as a DDOS attack. This is\nparticularly interesting considering the size of the Necurs botnets (the largest one, where this\nmodule was being loaded, has over 1 million active infections each 24 hours, we blogged\nabout it [here). A botnet this big can likely produce a very powerfull DDOS attack.](http://blog.anubisnetworks.com/blog/monitoring-necurs-the-tip-of-the-iceberg)\n\nPlease notice that we have not seen Necurs being used for DDOS attacks, we simply\nsaw that it has that capability in one of the modules that it has been loading.\n\nThe rest of this post contains the results of a technical analysis of this module, detailing its\nC2 protocol, the SOCKS/HTTP proxy features, and the DDOS attack features.\n\n## MODULE TECHNICAL ANALISYS\n\n### Module start/initialization\n\nOnce the module is loaded by the bot, it performs the following initialization actions:\n\nParses the parameters and stores them in an internal list of C2 addresses;\n**Fills a memory structure (see botsettings struct definition below) with:**\n\n**The BotID - Generated through gathering unique system characteristics;**\n**The internal IP address - Obtained by checking the outbound sockets IP**\naddress when connecting to google.com;\n**The external IP address - Obtained trough HTTP from ipv4.icanhazip.com or**\ncheckip.dyndns.org;\n**The available bandwidth - Obtained by measuring the download speed of the**\nWindows 7 Service Pack 1 file from microsoft;\n**The (socks/http) proxy service port - The port of the service listening on a**\nrandom port above 1024;\n**Checks if the system is behind NAT - By checking if the outbound socket IP is not a**\nlocal address and that it matches the external IP;\nIf the system is not behind NAT, the bot starts a SOCKS/HTTP proxy service listening\non a random port above 1024.\n\nThe botsettings struct can be defined as follows:\n\n\n-----\n\n### C2 communication protocol\n\nAfter initialization, the bot will enter the main C2 connection loop, where it will attempt to\nconnect to the current C2 every 10 seconds, unless instructed otherwise. If the connection to\nthe current C2 fails, it will fetch another from the address list and try again.\n\nThe communication protocol is binary and encrypted/obfuscated using a custom algorithm.\nMessages to, and from, the server have a very similar structure (see struct botmsg and\n_c2msg definitions below) and contain the following data:_\n\n**Key - A 32 bit encryption key;**\n**Encrypted header - A header structure (see struct botmsgheader and c2msgheader**\ndefinitions below), encrypted with the key and containing:\n\n**Message type - A byte that defines the type of message/command being sent;**\n**Payload length - The length of the payload being sent;**\n**Header hash - A hash of the first bytes of the message (key, msgtype, unknown**\nand datalength);\n**Data hash - A hash of the payload, used for integrity checking;**\n**Encrypted payload - An array of data being sent, encrypted with the reverse value of**\nthe key.\n\n\n-----\n\nThere are three types of messages sent by the bot to the C2, that can be distinguished by\nthe msgtype byte in the header:\n\n**Beacon (msgtype 0) - This is the main message that is sent by the bot every 10**\nseconds. It sends the botsettingsstruct described previously as a payload;\n**Connectivity check (msgtype 1) - This is a simple dummy message that contains no**\ndata besides the encrypted message header. It is sent in case a timeout occurs to the\ncurrent C2 to make sure it is no longer available;\n**Proxybackconnect (msgtype 2) - This message is sent in case the bot receives the**\ncommand to start a socks backconnect. This will start a connection to the C2 that will\nbe reused for the SOCKS/HTTP proxy connection, proceeding as if it had been initiated\nby the proxy client.\n\nAs a response to the beacon, there are also three types of messages (or commands) sent by\nthe C2 to the bot, that can be distinguished by the msgtype byte in the header:\n\n**Start Proxybackconnect (msgtype 1) - This command tells the bot to start a**\n_backconnect proxy session by sending a proxybackconnect message from the bot to_\nthe C2. This connection’s socket will be reused and allows the bot to be used as a\nproxy even behind a firewall and without establishing a direct connection to it;\n**Sleep (msgtype 2) - This will cause the bot to sleep for 5 minutes;**\n\n\n-----\n\n**Start DDOS (msgtype 5) - This command will start a DDOS attack against the target**\nspecified in the message payload using one of two available attack modes:\n\n**HTTPFlood: If the first bytes of the message payload are the string “http:/”, the**\nbot will start an HTTP flood attack against the target;\n**UDPFlood: If the first bytes of the message payload are not the string “http:/”,**\nthe bot will start an UDP flood attack against the target.\n\n### Proxy features\n\nThe SOCKS/HTTP proxy service and command, allows the botnet owners to use the\ncompromised bots as proxies (HTTP, SOCKSv4 and SOCKSv5 protocols), relaying\nconnections through them in two modes of operation (direct proxy and proxy backconnect).\n\nIn direct proxy mode, the client connects to the proxy service, which will forward the\ncommunication to the destination, as in the following image:\n\nThis is only possible if the bot is not protected behind NAT or a firewall, which is not the case\nin the vast majority of the botnet.\n\nIn proxy backconnect mode, the client connects to the proxy controller, that will then obtain\nan outbound proxy from a pool of available proxies and relay the connection through it. The\nfollowing diagram illustrates the system:\n\n\n-----\n\nThere are several advantages to this operation mode. The main ones being that it works\neven if the infected system is behind NAT and it will allow a connection to internal network\nresources as if it came from the infected machine. Another common use for these kind of\nproxies is to have a constantly changing IP address, by constantly and automatically\nchanging the bot serving as proxy.\n\nTaking a brief view at how this is implemented, the following image shows part of the function\nthat processes the C2 commands.\n\n\n-----\n\nIn case the bot receives a startproxybackconnect command (msgtype 1), the bot will send a\n_proxybackconnect message to the C2 (msgtype 2) and then the same socket that is used in_\nthe C2 communication (globalsocket) to the startprocessincoming function that does the\nactual proxying work. This means that the same connection used for C2 communication will\nthen be used to proxy the connections.\n\nThe processincomming function reads 2 bytes from the incoming connection (direct or\nthrough backconnect) and checks if the first has the value 5 (Socks v5 protocol), 4 (Socks v4\nprotocol) or if it is alphanumeric (HTTP Proxy). It then calls the appropriate function that does\nthe actual proxying work for each of the supported protocols.\n\n\n-----\n\n### DDOS attack features\n\nPossibly the most interesting, and unexpected, feature of this module is the DDOS attack\nmode. The module contains two very basic DDOS attack modes, that don’t have special\nfeatures like origin IP address spoofing or amplification techniques. However, given the size\nof the Necurs botnets (more than 1M IP/24 hours in the largest botnet), even the most basic\ntechniques should produce a very powerful attack.\n\nTaking a brief look at how it is implemented, if the bot receives the startDDOS command\n(msgtype 5) the payload portion of message is parsed looking for the string “http:/”. If it is\nfound, the HTTPflood function is called, if not, the UDPFlood function is called, as shown in\n\n\n-----\n\nthe following image:\n\n\n-----\n\n## HTTP Flood attack mode\n\nThe HTTP attack works by starting 16 threads that perform an endless loop of HTTP\nrequests. The following images show the 16 threads being queued and the section of the\ncode that sends the HTTP request:\n\n\n-----\n\nThe HTTP request is built using the following format string:\n\n\n-----\n\n## UDP Flood attack mode\n\nThe UDP flood attack works by repeatedly sending a random payload with size between 128\nand 1024 bytes. The function contains a 0.1 second sleep that may be triggered depending\non the available bandwidth (calculated during bot initialization), possibly to avoid losing\n\n\n-----\n\naccess to the bot during a DDOS attack. The following image shows the UDPFlood main\nloop:\n\n## Conclusion\n\nAlthough known mainly for its spam module, Necurs is a modular malware that can be used\nfor many different purposes. In this blog post we detailed a module that adds SOCKS/HTTP\nproxy and DDOS capabilities to this malware. Although we have not seen Necurs being used\nto perform DDOS attacks, this capability is currently deployed in the infected systems and\ntaking into account the size of the botnet it could produce a powerful attack.\n\n\n-----\n\n## References\n\nFor more information about the Necurs Botnet, check out the following links:\n\n[https://www.virusbulletin.com/virusbulletin/2014/04/curse-necurs-part-1](https://www.virusbulletin.com/virusbulletin/2014/04/curse-necurs-part-1)\n[https://www.virusbulletin.com/virusbulletin/2014/05/curse-necurs-part-2](https://www.virusbulletin.com/virusbulletin/2014/05/curse-necurs-part-2)\n[https://www.virusbulletin.com/virusbulletin/2014/06/curse-necurs-part-3](https://www.virusbulletin.com/virusbulletin/2014/06/curse-necurs-part-3)\n[https://www.johannesbader.ch/2015/02/the-dgas-of-necurs/](https://www.johannesbader.ch/2015/02/the-dgas-of-necurs/)\n[http://www.malwaretech.com/2016/02/necursp2p-hybrid-peer-to-peer-necurs.html](http://www.malwaretech.com/2016/02/necursp2p-hybrid-peer-to-peer-necurs.html)\n[https://www.cert.pl/en/news/single/necurs-hybrid-spam-botnet/](https://www.cert.pl/en/news/single/necurs-hybrid-spam-botnet/)\n\n### Analysed module sample:\n\nf3aeafe50880cb9dd584b3669800c017de561f8f9654440f62c51319fda0e970\n\n## Get the Weekly Cybersecurity Newsletter\n\nSubscribe to get security news and industry ratings updates in your inbox.\n\nRead more\nBy checking this box, I consent to sharing this information with BitSight Technologies,\nInc. to receive email and phone communications for sales and marketing purposes as\n[described in our privacy policy. I understand I may unsubscribe at any time.](https://www.bitsight.com/privacy-policy)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-02-24 - Necurs Proxy Module With DDOS Features.pdf"
    ],
    "report_names": [
        "2017-02-24 - Necurs Proxy Module With DDOS Features.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536130,
    "ts_updated_at": 1743041163,
    "ts_creation_date": 1653751297,
    "ts_modification_date": 1653751297,
    "files": {
        "pdf": "https://archive.orkl.eu/f718a25bf58cbd5a7818467bbfc31ce66d637d22.pdf",
        "text": "https://archive.orkl.eu/f718a25bf58cbd5a7818467bbfc31ce66d637d22.txt",
        "img": "https://archive.orkl.eu/f718a25bf58cbd5a7818467bbfc31ce66d637d22.jpg"
    }
}