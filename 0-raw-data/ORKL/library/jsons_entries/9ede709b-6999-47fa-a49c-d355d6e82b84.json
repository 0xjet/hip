{
    "id": "9ede709b-6999-47fa-a49c-d355d6e82b84",
    "created_at": "2023-01-12T15:02:32.269386Z",
    "updated_at": "2025-03-27T02:05:26.701869Z",
    "deleted_at": null,
    "sha1_hash": "70006720ecaa4547dcbb7c82501cc2662645f8ab",
    "title": "2022-12-19 - Malware Analysis- GuLoader Dissection Reveals New Anti-Analysis Techniques and Code Injection Redundancy",
    "authors": "",
    "file_creation_date": "2022-12-29T00:40:18Z",
    "file_modification_date": "2022-12-29T00:40:18Z",
    "file_size": 998516,
    "plain_text": "# GuLoader Dissection Reveals New Anti-Analysis\n\n**[crowdstrike.com/blog/guloader-dissection-reveals-new-anti-analysis-techniques-and-code-injection-redundancy/](https://www.crowdstrike.com/blog/guloader-dissection-reveals-new-anti-analysis-techniques-and-code-injection-redundancy/)**\n\nSarang Sonawane - Donato Onofri December 19, 2022\n\nGuLoader is an advanced malware downloader that uses a polymorphic shellcode\nloader to dodge traditional security solutions\nCrowdStrike researchers expose complete GuLoader behavior by mapping all\nembedded DJB2 hash values for every API used by the malware\nNew shellcode anti-analysis technique attempts to thwart researchers and hostile\nenvironments by scanning entire process memory for any virtual machine (VM)-related\nstrings\nNew redundant code injection mechanism means to ensure code execution by using\ninline assembly to bypass user mode hooks from security solutions\n\nCrowdStrike analyzes malware to augment the behavior and machine learning-based\ndetection and protection capabilities built into the CrowdStrike Falcon platform to deliver®\nautomated, world-class protection to customers.\n\nGuLoader has been known to employ a significant number of anti-analysis techniques,\nmaking detection and protection challenging for other security solutions.\n\n\n-----\n\nIn dissecting GuLoader s shellcode, CrowdStrike revealed a new anti-analysis technique\nmeant to detect if the malware is running in a hostile environment by scanning the entire\nprocess memory for any Virtual Machine (VM)-related strings. To bypass GuLoader’s antidebugging evasion mechanisms, we found and described two new working methods for\npatching debugger instructions meant to detect the presence of debugging tools used by\nresearchers for analysis.\n\nThis analysis includes what we believe is the first-ever mapping of all remaining DJB2 hash\nvalues for every API used by the GuLoader malware, revealing the first-ever complete view\ninto the malware’s behavior and how it interacts with the victim’s machine.\n\n**See for yourself how the industry-leading CrowdStrike Falcon platform protects**\n**against modern threats like GuLoader.** **[Start your 15-day free trial today.](https://go.crowdstrike.com/try-falcon-prevent.html)**\n\n## The Evolution of GuLoader\n\nGuLoader was first spotted in 2019 as a file downloader that was used to distribute remote\naccess trojans (RATs) such as AgentTesla, FormBook, Nanocore, NETWIRE and the\nParallax RAT.\n\nThese early versions of GuLoader were distributed via spam email campaigns containing\narchived attachments containing the malware in executable form. In 2020, CrowdStrike\n[published a detailed analysis of GuLoader in which a significant number of DJB2 hash](https://www.crowdstrike.com/blog/guloader-malware-analysis/)\nvalues were mapped, revealing some of the APIs abused by the malware.\n\nRecent variants started using an updated delivery mechanism where the payload is delivered\nvia a Visual Basic Script (VBS) file. GuLoader also started employing advanced anti-analysis\ntechniques to evade detection, such as anti-debug, anti-sandbox, anti-VM and anti-detection\nto make analysis difficult.\n\nBy analyzing the new GuLoader samples, we’re able to reveal and understand every antianalysis and evasion technique being employed and paint a complete picture of the\nmalware’s behavior.\n\n## GuLoader’s Multistage Deployment\n\nThe recent GuLoader sample exhibits a multistage deployment:\n\n**The first stage involves using a VBS dropper file to drop a second-stage packed**\npayload into a registry key. It then uses a PowerShell script to execute and unpack the\nsecond stage payload from the registry key within memory.\n**The** **second stage payload performs all anti-analysis routines (described**\nbelow), creates a Windows process (e.g., an ieinstal.exe) and injects the same\nshellcode into the new process.\n\n\n-----\n\n**The third stage reimplements all the anti-analysis techniques, downloads the final**\npayload from a remote server and executes it on the victim’s machine.\n\n[Existing public research on GuLoader’s multistage deployment has extensively covered a](https://www.crowdstrike.com/blog/guloader-malware-analysis/)\nwide range of anti-evasion techniques and behaviors. We used this as a starting point to\nfurther our analysis.\n\n### VBScript\n\nThe VBScript contains two main arrays. One of them is the shellcode present in hex format\nthat will be injected into memory and the second is a Base64-encrypted PowerShell script.\n\nFor persistence, this shellcode is then added to the Registry Key\n(HKEY_CURRENT_USER\\SOFTWARE\\TYMPANIESI) by the VBScript.\n\nAnother variable “MEDITABU” with Base64 content is being merged and after decoding it\nforms a PowerShell script.\n\n### PowerShell Script\n\nThe PowerShell script adds a Microsoft .NET class to a PowerShell session using Add-Type\n-typedefinition. It then reads the shellcode from the registry entry created by the VBScript\nand loads the shellcode into the virtually allocated memory space using the API\nZwAllocateVirtualMemory and RtlMoveMemory. After that, the shellcode is launched inside\npowershell.exe using the API Callwindowprocw function.\n\nThe first 40 bytes of the shellcode are executable assembly instructions and the remaining\nbytes are encrypted. The first 40 bytes are responsible for decrypting the remaining part of\nthe code, then the execution flow jumps into the decrypted part. During the next stage, the\nshellcode replaces the first 40 hex bytes with a no operation (NOP) instruction. This is done\nto avoid re-debugging of the code.\n\nInitially, the shellcode traverses the process environment block (PEB) structure and fetches\nNtdll to tap into exported NTAPI functions. The rest of the DLLs are loaded by using\nLoadLibrary. As [previously covered by CrowdStrike, GuLoader uses the DJB2 algorithm to](https://www.crowdstrike.com/blog/guloader-malware-analysis/)\nload APIs. The assembly code for DJB2 traverses through export functions of the required\nDLLs one by one, calculates the DJB2 hashes for each export API and then compares those\n[with the hardcoded hash value. We covered the DJB2 algorithm in a previous blog post.](https://www.crowdstrike.com/blog/guloader-malware-analysis/)\n\n## Anti-Analysis Techniques\n\nThe shellcode employs several anti-analysis and anti-debugging tricks at every step of\nexecution, throwing an error message if the shellcode detects any known analysis of\ndebugging mechanisms.\n\n\n-----\n\n### Anti-Debugging\n\n**GuLoader uses a vectored exception handler (VEH) to throw off researchers and make**\ndisassembly and debugging difficult by disrupting the normal flow of code execution to point\nthe control flow to incorrect paths, raising exceptions that jump to other instructions. To add\nthe exception, the shellcode uses the RtlAddVectoredExcepitionHandler API function.\n\nFigure 1. Vector Exception Handler function (click to enlarge)\n\nGuLoader performs a series of anti-debugging and anti-disassembling checks to detect the\npresence of breakpoints, usually associated with researchers analyzing its code execution\nflow.\n\nFor example, it extracts information from EXCEPTION_RECORD when it hits INT3 (0xCC)\ninstruction and then it checks ExceptionCode from it. To determine if the VEH routine has\nbeen triggered by an INT3 instruction, it will check if the value matches 0x80000003 (e.g.,\nEXCEPTION_BREAKPOINT). It then retrieves the DR registers from CONTEXT_RECORD\nto check if there are any HARDWARE breakpoints and it also checks the EIP (Extended\nInstruction Pointer) to see if it is equal to 0xCC Looking for software breakpoints GuLoader\n\n\n-----\n\nalso checks for the presence of other 0xCC instructions in code and terminates execution if\nfound (shown in Figure 1). If everything is as expected, the malware performs an XOR\noperation on the next byte after EIP and then replaces the EIP on CONTEXT with the new\nvalue, ensuring the execution flow will reach the correct address.\n\nTo bypass this check, to automatically jump to the next real address and avoid the VEH\nroutine, we can use the following statement, inside the “command window” present at the\nbottom of x32 debugger, when the debugger reaches INT3 instruction (here the XOR value\ninside VEH was 0x40; it may be different in other samples):\n```\neip=((ReadByte(eip+1)^0x40)+eip)\n\n```\nTo avoid step-by-step replacement in the debugger, the following script can also be used to\npatch all of the INT3 instructions by replacing them with a JUMP to the real execution flow\n(copy the script below in the x32dbg “Script” tab):\n```\ncall loop\n\nloop:\n\nmov $a, 0\n\nfindasm “int3”\n\ncmp $result, $a\n\nje exit\n\nmov $temp, ref.addr($a)\n\nmov $i, 0x40\n\nxor [$temp+1], $i\n\nsub [$temp+1], 2\n\n1:[$temp] = 0xEB\n\njmp loop\n\nexit:\n\nret\n\n```\n**Breakpoint checks on APIs are performed before calling every API and if found, the**\nshellcode terminates.\n\n**Using the NtsetInformationThread API is also an anti-debugging technique. The DJB2**\nalgorithm loads the NtsetInformationThread API and passes the second parameter as 11\n(corresponding to ThreadHideFromDebugger), which will crash the process when it runs\nfrom inside a debugger.\n\n**Anti-debugging via NtQueryInformationProcess enables GuLoader to check the**\npresence of a remote debugger in its process. Our sample leverages the\nNtQueryInformationProcess API, by specifying ProcessDebugPort (0x7) as the second\nparameter. The loader checks for non-zero return values, which means the process is being\ndebugged.\n\n\n-----\n\n**Anti-debugging via DbgBreakPoint and DbgUiRemoteBreakin allows GuLoader to patch**\ntwo APIs in memory by leveraging the NtProtectVirtualMemory API to mark it writable for\ntheir addresses:\n\nDbgBreakPoint — by replacing with a NOP instruction\nDbgUiRemoteBreakin — by replacing with a random instruction\n\n**DJB2** **API Name**\n\n4a082415 DbgBreakPoint\n\n880bb688 DbgUiRemoteBreakin\n\n### Anti-Virtual Machine\n\nWhat’s different from previously analyzed GuLoader variants is that this shellcode performs\n**memory scanning for VMware-related string checks on every memory page from the**\nentire process memory. GuLoader uses NtQueryVirtualMemory API to scan the entire\nmemory of the process to check if there are any Virtual Machine (VM)-related strings\npresent.\n\nFigure 2. Pseudocode showing how the Virtual Memory is scanned and how the Djb2 algorithm is\n\nused (click to enlarge)\n\n\n-----\n\nThis is implemented by calling API NtQueryVirtualMemory with the handle 0xffffffff (current\nprocess) to iteratively retrieve the base address of every page. The fourth parameter of this\nAPI is the MemoryInformation structure which contains information about a range of pages in\nthe virtual address space of a process. A similar technique has been implemented in the past\non [VMDE project by hfiref0x, in which the author searches in memory for “Sandboxie”](https://github.com/hfiref0x/VMDE/blob/master/src/vmde/detect.c#L679)\nartifacts strings; in this case GuLoader searches for virtualization software traces.\n\nIf it finds any of the DJB2 values for a series of strings (i.e., VMSwitchUserControlClass,\nVM3DService Hidden Window, VMDisplayChangeControlClass, vmtoolsdControlWndClass,\netc.), the shellcode throws an error message that it is running under a virtual environment\nand then terminates execution.\n\n**Using CPUID and rdtsc is a very common anti-debugging trick that involves using the read**\ntime-stamp counter (rdtsc) instruction to determine how many CPU ticks took place since the\nprocessor was reset. This is used as a timing check comparing the time required to execute\ntwo rdtsc instructions and then calling the CPUID instruction with EAX =1 to retrieve the\nprocess information, returning the output in the ECX registry. If the thirty-first bit of ECX is\nset, it is used as that the shellcode is running inside a potentially hostile environment (virtual\nmachine).\n\nThe use of the EnumWindows function is also a popular anti-VM technique generally used\nto enumerate all top-level windows on the screen by passing the handle to each window.\nThis API is used in the shellcode, counting the number of open windows inside the callback\nfunction. If the number is lower than 12, it will call the API TerminateProcess.\n\n**Enumerating device drivers also falls under the anti-VM category. GuLoader uses**\nEnumDeviceDriver from (psapi.dll) and checks the presence of specific drivers and triggers\nan error if found. Shellcode fetches and calls two APIs from its DJB2 values — DADA7345\nand CDAFD506, respectively EnumDeviceDriver and GetDeviceDriverBasename — to\nenumerate driver names. Every enumerated driver name’s DJB2 hash value is calculated.\nThese hash values are then compared with hard-coded DJB2 hash values, which are\nactually VM-related device drivers.\n\n**DJB2 Value** **Strings**\n\n9ba8433a vmmouse.sys\n\nd5360503 vm3dmp_loader.sys\n\nD8FB0271 vm3dmp.sys\n\n52eb67f8 vmusbmouse.sys\n\nAfter bypassing all of the above tricks consecutively, it then loads addresses of several APIs\nas show in the table below:\n\n\n-----\n\n**DJB2 Value** **API Name**\n\nc4835d68 NtsetContextthread\n\nC45db42d NtWriteVirtualMemory\n\nD05D0AFC ZwCreateSection\n\nC101ddb2 NtMapViewOfSection\n\n3b640034 NtsetInformationProcess\n\n8ad0acb1 NtOpenFile\n\nDe797b11 NtClose\n\n2334ac18 NtResumeThread\n\n1a45d798 NtCreateThreadEx\n\n9688DA44 CreateProcessInternalW\n\n**Scanning and enumerating installed software is a technique GuLoader uses to check for**\nvirtualization software installed as part of its anti-sandbox/anti-VM mechanism by loading\nAPIs that match the DJB2 hash values 55fbd1cd (MsiGetProductInfoA) and AD5448\n(MsiEnumProductsA). The shellcode enumerates the products using API\nMsiGetProductInfoA and checks if they match with a list of known software.\n\n**Service enumeration using the OpenScManager API establishes a connection to the**\nservice control manager on the machine and opens the specified service control manager\ndatabase. It then enumerates service control manager database services using\nEnumServicesStatusA.\n\n### Process Hollowing\n\n[Process hollowing is a technique of executing arbitrary code in the address space of a](https://attack.mitre.org/techniques/T1055/012/)\nseparate live process by creating a process in a suspended state then unmapping/hollowing\nits memory, which can then be replaced with malicious code. In this case, the malware does\nnot unmap an already mapped section on the remote process, but tries to add a new section\nand write the injected shellcode into it.\n\nThe below steps are followed for injection:\n\n1. The shellcode first creates a suspended process by calling CreateProcessInternal.\n\n2. It then calls NtOpenFile on \\\\??\\\\C:\\\\Windows\\\\syswow64\\\\iertutil.dll.\n\n3. It does NtCreateSection on that file, where it will inject its malicious shellcode.\n\n\n-----\n\n4. It then maps that section via NtMapViewofSection on the suspended process. If this\n**injection technique fails, it uses the following redundancy method:**\n\na. NtAllocateVirtualMemory by invoking the inline assembly instructions (without calling\nntdll.dll, to bypass AV/EDR User Mode hooks) of that function, using the following assembly\nstub:\n```\nmov eax,18             \n\nmov edx,ntdll.77178850   \n\ncall edx             \n\nret 18 \n\n```\nIt uses NtWriteProcessMemory to copy the same shellcode onto that virtually allocated\naddress.\n\n5. It then uses API NtGetContextThread on remote thread of suspended process, by\nspecifying the following flags to retrieve the registry values of that thread:\n\ni. CONTEXT_CONTROL to retrieve the registers ESP, EIP, FLAGS, BP\n\nii. CONTEXT_INTEGER to retrieve the registers AX, BX, CX, DX, SI, DI\n\niii. CONTEXT_SEGMENTS to retrieve the registers DS, ES, FS, GS\n\n6. The retrieved CONTEXT is used to manipulate registers by calling the NTAPI\n```\nNtSetContextThread to set the EAX register to the address of shellcode (EIP points to\nRtlUserThreadStart, which will jump to new EAX).\n\n```\n7. Finally, the malware calls the native API NtResumeThread to resume the process and\nexecute the shellcode in the new process.\n\n## Final Shellcode\n\nAfter injection, the shellcode re-executes all the anti-analysis steps mentioned above, and\nthen decrypts the URL to retrieve the last payload from\nhttps[:]//biropem[.]papuabaratprov[.]go[.]id/bin_fXZOFMVq248[.]bin. It loads the API to\nmanage the internet connection and connects to a URL to download the first level of\npayload, which then gets decrypted by the shellcode and results in dropping the Remcos\nmalware.\n\n**DJB2** **API Name**\n\nC6e89145 InternetOpenA\n\n9f39811c InternetSetOptionA\n\n\n-----\n\n292652cc InternetOpenUrlA\n\nF978A052 InternetReadFile\n\n71167D2C InternetCloseHandle\n\n## How the CrowdStrike Falcon Platform Protects Against GuLoader\n\nClick to enlarge\n\nGuLoader remains a dangerous threat that’s been constantly evolving with new methods to\nevade detection. The Falcon platform uses behavior-based detection capabilities to\nautomatically detect and prevent GuLoader early in the attack chain by identifying the initial\nVBScript loader, preventing its execution.\n\nThis recent analysis performed by CrowdStrike on GuLoader now offers a complete picture\nof all the DJB2 hash values used for APIs. This type of threat research enables CrowdStrike\nto leverage expert human intelligence and augment its machine learning and behavior-based\ndetection capabilities to stop breaches.\n\n## Indicators of Compromise (IOCs)\n\n**File** **SHA256**\n```\n GuLoader f75cefc70404640cf823fe419af6f9841c3cfee17a9fdbe332da251d0964e17f\n\n## Appendix\n\n```\nThe following table contains the complete list of additional DJB2 hash values for APIs as\nused by GuLoader.\n\n\n-----\n\n**DJB2 Value** **API Name**\n\nDADA7345 EnumDeviceDriver\n\nCDAFD506 GetDeviceDriverBasename\n\nc4835d68 NtsetContextthread\n\nC45db42d NtWriteVirtualMemory\n\nD05D0AFC ZwCreateSection\n\nC101ddb2 NtMapViewOfSection\n\n3b640034 NtsetInformationProcess\n\n8ad0acb1 NtOpenFile\n\nDe797b11 NtClose\n\n2334ac18 NtResumeThread\n\n1a45d798 NtCreateThreadEx\n\n9688DA44 CreateProcessInternalW\n\n55fbd1cd MsiGetProductInfoA\n\nAD5448 MsiEnumProductsA\n\n4a082415 DbgBreakPoint\n\n880bb688 DbgUiRemoteBreakin\n\nC6e89145 InternetOpenA\n\n9f39811c InternetSetOptionA\n\n292652cc InternetOpenUrlA\n\nF978A052 InternetReadFile\n\n71167D2C InternetCloseHandle\n\n## Additional Resources\n\n_[Learn how the powerful CrowdStrike Falcon®](https://www.crowdstrike.com/endpoint-security-products/falcon-platform/)_ _platform provides comprehensive_\n_protection across your organization, workers and data, wherever they are located._\n_[Get a full-featured free trial of CrowdStrike Falcon Prevent™](https://www.crowdstrike.com/resources/free-trials/try-falcon-prevent/)_ _and see for yourself how_\n_true next-gen AV performs against today’s most sophisticated threats._\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-12-19 - Malware Analysis- GuLoader Dissection Reveals New Anti-Analysis Techniques and Code Injection Redundancy.pdf"
    ],
    "report_names": [
        "2022-12-19 - Malware Analysis- GuLoader Dissection Reveals New Anti-Analysis Techniques and Code Injection Redundancy.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535752,
    "ts_updated_at": 1743041126,
    "ts_creation_date": 1672274418,
    "ts_modification_date": 1672274418,
    "files": {
        "pdf": "https://archive.orkl.eu/70006720ecaa4547dcbb7c82501cc2662645f8ab.pdf",
        "text": "https://archive.orkl.eu/70006720ecaa4547dcbb7c82501cc2662645f8ab.txt",
        "img": "https://archive.orkl.eu/70006720ecaa4547dcbb7c82501cc2662645f8ab.jpg"
    }
}