{
    "id": "492d7b53-6e3b-49fc-99d4-f6988ec3e588",
    "created_at": "2023-06-05T02:07:02.82867Z",
    "updated_at": "2025-03-27T02:06:12.873283Z",
    "deleted_at": null,
    "sha1_hash": "bf8e9965b443d38ae7fa2b5021b5b25a701c8e81",
    "title": "2023-05-18 - Looking Closer at BPF Bytecode in BPFDoor",
    "authors": "",
    "file_creation_date": "2023-06-04T12:50:51Z",
    "file_modification_date": "2023-06-04T12:50:51Z",
    "file_size": 3936433,
    "plain_text": "# Looking Closer at BPF Bytecode in BPFDoor\n\n**nikhilh-20.github.io/blog/cbpf_bpfdoor/**\n\n## Metadata\n\nSHA256: afa8a32ec29a31f152ba20a30eb483520fe50f2dce6c9aa9135d88f7c9c511d7\n\n[Malware Bazaar link](https://bazaar.abuse.ch/sample/afa8a32ec29a31f152ba20a30eb483520fe50f2dce6c9aa9135d88f7c9c511d7)\n\n## Table of Contents\n\n Family Introduction\n\nBPFDoor is a backdoor targeting Linux-based systems. It leverages Berkeley Packet Filter\n(BPF) technology that exists natively in Linux kernels since v2.1.75. By using low-level BPFbased packet filtering, it is able to bypass local firewalls and stealthily receive network traffic\nfrom its C2.\n\n## BPF Introduction\n\n### The Need for BPF\n\nAn operating system (OS) abstracts away the hardware. For example, user-space programs\nrunning on the OS do not directly interact with networking-related hardware. They do so via\nAPIs exposed by the OS. On Linux, these are called system calls or syscalls, in short. This\nkind of a design results in a clear demarcation between the user-space and kernel-space.\n\nConsider a single network packet that reaches the kernel. A user-space packet filtering\nprogram wants to look at it. In this case, the contents of the entire packet needs to be copied\ninto user-space memory for it to be accessible by the user-space program. This incurs a cost\nin performance and can be expected to be significant on high-traffic systems.\n\nWith the introduction of BPF in Linux kernel v2.1.75, packet filtering can occur in kernelspace. A user-space application such as tcpdump could provide a filtering program (aka BPF\nprogram) which would be compiled and run completely in kernel-space in a register-based\nVM. This avoids the performance cost of copying the network packet into user-space.\n\n### Stability in BPF\n\nTo avoid instability in kernel-space, an arbitrary BPF program cannot be provided. A number\nof checks are performed by the BPF in-kernel verifier. This includes tests such as verifying\nthat the BPF program terminates, registers are initialized and the program does not contain\n\n\n-----\n\nany loops that could cause the kernel to lock up. A BPF program can successfully be loaded\nand executed only after it is verified.\n\n### eBPF vs cBPF\n\nThe original BPF, also called classic BPF (cBPF), was designed for capturing and filtering\nnetwork packets that matched specific rules.\n\nLinux kernel v3.15 then introduced extended BPF (eBPF) which was more versatile and\npowerful. It had a larger instruction set, leveraged 64-bit registers and more number of them.\nIt could also be leveraged for carrying out system performance analysis.\n```\ntcpdump, a user-space network packet analyzer, generates cBPF bytecode but it is then\n\n```\ntranslated to eBPF bytecode in recent kernels. The following is an example of cBPF\ninstructions generated by tcpdump when capturing TCP traffic on port 80. I’ve also added the\nC-style bytecode equivalent (-dd option in tcpdump) for each instruction.\n```\n$ sudo tcpdump -i wlp4s0 -d \"tcp port 80\"\n\n(000) ldh   [12]               # { 0x28, 0, 0, 0x0000000c }\n\n(001) jeq   #0x86dd     jt 2  jf 8   # { 0x15, 0, 6, 0x000086dd }\n\n(002) ldb   [20]               # { 0x30, 0, 0, 0x00000014 }\n\n(003) jeq   #0x6       jt 4  jf 19  # { 0x15, 0, 15, 0x00000006 }\n\n(004) ldh   [54]               # { 0x28, 0, 0, 0x00000036 }\n\n(005) jeq   #0x50      jt 18 jf 6   # { 0x15, 12, 0, 0x00000050 }\n\n(006) ldh   [56]               # { 0x28, 0, 0, 0x00000038 }\n\n(007) jeq   #0x50      jt 18 jf 19  # { 0x15, 10, 11, 0x00000050 }\n\n(008) jeq   #0x800      jt 9  jf 19  # { 0x15, 0, 10, 0x00000800 }\n\n(009) ldb   [23]               # { 0x30, 0, 0, 0x00000017 }\n\n(010) jeq   #0x6       jt 11 jf 19  # { 0x15, 0, 8, 0x00000006 }\n\n(011) ldh   [20]               # { 0x28, 0, 0, 0x00000014 }\n\n(012) jset   #0x1fff     jt 19 jf 13  # { 0x45, 6, 0, 0x00001fff }\n\n(013) ldxb   4*([14]&0xf)           # { 0xb1, 0, 0, 0x0000000e }\n\n(014) ldh   [x + 14]             # { 0x48, 0, 0, 0x0000000e }\n\n(015) jeq   #0x50      jt 18 jf 16  # { 0x15, 2, 0, 0x00000050 }\n\n(016) ldh   [x + 16]             # { 0x48, 0, 0, 0x00000010 }\n\n(017) jeq   #0x50      jt 18 jf 19  # { 0x15, 0, 1, 0x00000050 }\n\n(018) ret   #262144             # { 0x6, 0, 0, 0x00040000 }\n\n(019) ret   #0                # { 0x6, 0, 0, 0x00000000 }\n\n\n## Studying the BPF Bytecode in BPFDoor\n\n### Building Capstone\n\n```\n[Given BPF bytecode, we can use capstone to disassemble it. It supports the disassembly of](https://github.com/capstone-engine/capstone)\nboth cBPF and eBPF bytecode. Building capstone from source is simple.\n\n\n-----\n\n```\n$ git clone recursive https://github.com/capstone engine/capstone\n\nCloning into 'capstone'...\n\nremote: Enumerating objects: 32768, done.\n\nremote: Counting objects: 100% (1765/1765), done.\n\nremote: Compressing objects: 100% (544/544), done.\n\nremote: Total 32768 (delta 1267), reused 1649 (delta 1206), pack-reused 31003\n\nReceiving objects: 100% (32768/32768), 50.82 MiB | 18.05 MiB/s, done.\n\nResolving deltas: 100% (23271/23271), done.\n\n$ cd capstone\n\n$ ./make.sh\n\n$ cd bindings/python/\n\n$ sudo make install\n\n$ pip freeze | grep capstone\n\ncapstone==5.0.0rc2\n\n### Disassembling BPF Bytecode\n\n```\nThe following snap shows the existence of cBPF bytecode of length 240 bytes in the\nBPFDoor sample. The cBPF program is applied on the socket using a call to setsockopt\nwith SO_ATTACH_FILTER option and a pointer to the cBPF bytecode.\n\n\n-----\n\n```\n$ xxd c 8 g 1 bpf.o\n\n00000000: 28 00 00 00 0c 00 00 00 (.......\n\n00000008: 15 00 00 09 dd 86 00 00 ........\n\n00000010: 30 00 00 00 14 00 00 00 0.......\n\n00000018: 15 00 00 02 06 00 00 00 ........\n\n00000020: 28 00 00 00 38 00 00 00 (...8...\n\n00000028: 15 00 16 0d 50 00 00 00 ....P...\n\n00000030: 15 00 16 00 2c 00 00 00 ....,...\n\n00000038: 15 00 01 00 84 00 00 00 ........\n\n00000040: 15 00 00 14 11 00 00 00 ........\n\n00000048: 28 00 00 00 38 00 00 00 (...8...\n\n00000050: 15 00 11 10 bb 01 00 00 ........\n\n00000058: 15 00 00 11 00 08 00 00 ........\n\n00000060: 30 00 00 00 17 00 00 00 0.......\n\n00000068: 15 00 00 06 06 00 00 00 ........\n\n00000070: 28 00 00 00 14 00 00 00 (.......\n\n00000078: 45 00 0d 00 ff 1f 00 00 E.......\n\n00000080: b1 00 00 00 0e 00 00 00 ........\n\n00000088: 48 00 00 00 10 00 00 00 H.......\n\n00000090: 15 00 09 00 50 00 00 00 ....P...\n\n00000098: 15 00 08 07 bb 01 00 00 ........\n\n000000a0: 15 00 01 00 84 00 00 00 ........\n\n000000a8: 15 00 00 07 11 00 00 00 ........\n\n000000b0: 28 00 00 00 14 00 00 00 (.......\n\n000000b8: 45 00 05 00 ff 1f 00 00 E.......\n\n000000c0: b1 00 00 00 0e 00 00 00 ........\n\n000000c8: 48 00 00 00 10 00 00 00 H.......\n\n000000d0: 15 00 01 00 bb 01 00 00 ........\n\n000000d8: 15 00 00 01 16 00 00 00 ........\n\n000000e0: 06 00 00 00 00 00 04 00 ........\n\n000000e8: 06 00 00 00 00 00 00 00 ........\n\n```\nA BPF instruction is 8 bytes in length. I’ve formatted the above hex dump so that each line\nrepresents a cBPF instruction. capstone can be used to disassemble this bytecode.\n\n\n-----\n\n```\nIn [1]: from capstone import\n\nIn [2]: md = Cs(CS_ARCH_BPF, CS_MODE_BPF_CLASSIC)\n\nIn [3]: with open(\"bpf.o\", \"rb\") as ff:\n\n  ...:   data = ff.read()\n\n  ...: linenum = 0\n\n  ...: for i in md.disasm(data, 0):\n\n  ...:   print(f\"{j}: {i.mnemonic} {i.op_str}\")\n\n  ...:   linenum += 1\n\n0: ldh [0xc]\n\n1: jeq 0x86dd, +0x0, +0x9\n\n2: ldb [0x14]\n\n3: jeq 0x6, +0x0, +0x2\n\n4: ldh [0x38]\n\n5: jeq 0x50, +0x16, +0xd\n\n6: jeq 0x2c, +0x16, +0x0\n\n7: jeq 0x84, +0x1, +0x0\n\n8: jeq 0x11, +0x0, +0x14\n\n9: ldh [0x38]\n\n10: jeq 0x1bb, +0x11, +0x10\n\n11: jeq 0x800, +0x0, +0x11\n\n12: ldb [0x17]\n\n13: jeq 0x6, +0x0, +0x6\n\n14: ldh [0x14]\n\n15: jset 0x1fff, +0xd, +0x0\n\ncapstone failed to disassemble the 17 instruction. This corresponds to the cBPF bytecode:th\nb1 00 00 00 0e 00 00 00\n\n```\nLooking at the cBPF bytecode generated by tcpdump earlier (see eBPF vs cBPF section),\nthe above bytecode corresponds to the following instruction. Perhaps, capstone is not yet\naware of this bytecode-instruction mapping.\n```\nldxb   4*([14]&0xf)\n\n\n```\nI removed the above ldxb instruction-specific bytecode from the hex dump, disassembled\nthe remaining bytecode using capstone and then added the ldxb instruction at the\nappropriate position in the instruction sequence.\n\n\n-----\n\n```\n0: ldh [0xc]\n\n1: jeq 0x86dd, +0x0, +0x9\n\n2: ldb [0x14]\n\n3: jeq 0x6, +0x0, +0x2\n\n4: ldh [0x38]\n\n5: jeq 0x50, +0x16, +0xd\n\n6: jeq 0x2c, +0x16, +0x0\n\n7: jeq 0x84, +0x1, +0x0\n\n8: jeq 0x11, +0x0, +0x14\n\n9: ldh [0x38]\n\n10: jeq 0x1bb, +0x11, +0x10\n\n11: jeq 0x800, +0x0, +0x11\n\n12: ldb [0x17]\n\n13: jeq 0x6, +0x0, +0x6\n\n14: ldh [0x14]\n\n15: jset 0x1fff, +0xd, +0x0\n\n16: ldxb 4*([14]&0xf)\n\n17: ldh [x+0x10]\n\n18: jeq 0x50, +0x9, +0x0\n\n19: jeq 0x1bb, +0x8, +0x7\n\n20: jeq 0x84, +0x1, +0x0\n\n21: jeq 0x11, +0x0, +0x7\n\n22: ldh [0x14]\n\n23: jset 0x1fff, +0x5, +0x0\n\n24: ldxb 4*([14]&0xf)\n\n25: ldh [x+0x10]\n\n26: jeq 0x1bb, +0x1, +0x0\n\n27: jeq 0x16, +0x0, +0x1\n\n28: ret 0x40000\n\n29: ret 0x0\n\n### Interpreting BPFDoor’s BPF Bytecode\n\n```\nBPFDoor attaches the cBPF program to a AF_PACKET socket. So, packet filtering occurs at\nlayer 2 of the network stack. Let’s look at each instruction line-by-line.\n```\n0: ldh [0xc]\n\n```\n\n-----\n\n```\n1: jeq 0x86dd, +0x0, +0x9\n\n2: ldb [0x14]\n\n```\n\n-----\n\n```\n3: jeq 0x6, +0x0, +0x2\n\n4: ldh [0x38]\n\n```\n\n-----\n\n```\n5: jeq 0x50, +0x16, +0xd\n\n```\nIf the previously loaded value at line 4 matches 0x50, control jumps to line 28 (relative offset\n```\n0x16) else it jumps to line 19 (relative offset 0xd). This instruction checks if the destination\n\n```\nport number is 80.\n```\n6: jeq 0x2c, +0x16, +0x0\n\n7: jeq 0x84, +0x1, +0x0\n\n```\n\n-----\n\n```\n8: jeq 0x11, +0x0, +0x14\n\n9: ldh [0x38]\n\n```\n\n-----\n\n```\n10: jeq 0x1bb, +0x11, +0x10\n\n```\nIf the previously loaded value at line 9 matches 0x1bb, control jumps to line 28 (relative offset\n```\n0x11) else it jumps to line 27 (relative offset 0x10). This instruction checks if the destination\n\n```\nport number is 443\n```\n11: jeq 0x800, +0x0, +0x11\n\n12: ldb [0x17]\n\n```\n\n-----\n\n```\n13: jeq 0x6, +0x0, +0x6\n\n14: ldh [0x14]\n\n```\n\n-----\n\n```\n15: jset 0x1fff, +0xd, +0x0\n\n```\nThis instruction performs a bitwise AND operation between the previously loaded value at\nline 14 and 0x1fff. If the result is non-zero, control jumps to line 29 (relative offset 0xd) else\nline 16 (relative offset 0). This instruction basically looks at the value of the Fragment Offset\nfield. If it is non-zero, control jumps to line 29 else line 16.\n```\n16: ldxb 4*([14]&0xf)\n\n17: ldh [x+0x10]\n\n```\n\n-----\n\n```\n18: jeq 0x50, +0x9, +0x0\n\n```\nIf the previously loaded value at line 17 matches 0x50, control jumps to line 28 (relative offset\n```\n0x9) else it jumps to line 19 (relative offset 0). This instruction checks if the destination port\n\n```\nnumber is 80.\n```\n19: jeq 0x1bb, +0x8, +0x7\n\n\n```\nIf the previously loaded value at line 17 matches 0x1bb, control jumps to line 28 (relative\noffset 0x8) else it jumps to line 27 (relative offset 0x7). This instruction checks if the\ndestination port number is 443.\n```\n20: jeq 0x84, +0x1, +0x0\n\n21: jeq 0x11, +0x0, +0x7\n\n```\n\n-----\n\n```\n22: ldh [0x14]\n\n23: jset 0x1fff, +0x5, +0x0\n\n```\nThis instruction performs a bitwise AND operation between the previously loaded value at\nline 14 and 0x1fff. If the result is non-zero, control jumps to line 29 (relative offset 0x5) else\nline 24 (relative offset 0). This instruction basically looks at the value of the Fragment Offset\nfield. If it is non-zero, control jumps to line 29 else line 24.\n```\n24: ldxb 4*([14]&0xf)\n\n```\n\n-----\n\n```\n25: ldh [x+0x10]\n\n26: jeq 0x1bb, +0x1, +0x0\n\n```\nIf the previously loaded value at line 25 matches 0x1bb, control jumps to line 28 (relative\noffset 0x1) else it jumps to line 27 (relative offset 0). This instruction checks if the destination\nport number is 443.\n```\n27: jeq 0x16, +0x0, +0x1\n\n```\n\n-----\n\nIf the previously loaded value matches 0x16, control jumps to line 28 (relative offset 0) else it\njumps to line 29 (relative offset 0x1). This instruction checks if the destination port number is\n22.\n```\n28: ret 0x40000\n\n\n```\nA non-zero return indicates a packet match.\n```\n29: ret 0x0\n\n\n```\nA zero return indicates a packet no-match.\n\n## Summary\n\nBPFDoor’s cBPF bytecode filters according to the following rules:\n\nMatch only on IPv4 or IPv6 packets.\nMatch only on TCP traffic on ports 80, 443 and 22. In case of IPv4, don’t match on\nfragmented packets. There is no TCP fragmentation over IPv6.\nMatch only on UDP/SCTP traffic on ports 443 and 22. In both IPv4 and IPv6 don’t\nmatch on fragmented packets.\n\nI think DeepInstinct’s [blog about BPFDoor missed to point out that UDP traffic on only ports](https://www.deepinstinct.com/blog/bpfdoor-malware-evolves-stealthy-sniffing-backdoor-ups-its-game)\n443 and 22 are captured and not port 80.\n```\nBPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP\ntraffic coming through ports 22 (ssh), 80 (http), and 443 (https).\n\n\n```\nThe flowchart below shows the overall control flow of the BPF program:\n\n\n-----\n\n## References\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-05-18 - Looking Closer at BPF Bytecode in BPFDoor.pdf"
    ],
    "report_names": [
        "2023-05-18 - Looking Closer at BPF Bytecode in BPFDoor.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1685930822,
    "ts_updated_at": 1743041172,
    "ts_creation_date": 1685883051,
    "ts_modification_date": 1685883051,
    "files": {
        "pdf": "https://archive.orkl.eu/bf8e9965b443d38ae7fa2b5021b5b25a701c8e81.pdf",
        "text": "https://archive.orkl.eu/bf8e9965b443d38ae7fa2b5021b5b25a701c8e81.txt",
        "img": "https://archive.orkl.eu/bf8e9965b443d38ae7fa2b5021b5b25a701c8e81.jpg"
    }
}