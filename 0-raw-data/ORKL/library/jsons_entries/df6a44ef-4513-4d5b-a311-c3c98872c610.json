{
    "id": "df6a44ef-4513-4d5b-a311-c3c98872c610",
    "created_at": "2022-10-27T08:36:10.059028Z",
    "updated_at": "2025-03-27T02:05:53.622786Z",
    "deleted_at": null,
    "sha1_hash": "aee91a10ea1743bfa62e8af22f2634ad98105c3b",
    "title": "Installer Package Scripting",
    "authors": "",
    "file_creation_date": "2019-07-07T17:55:09Z",
    "file_modification_date": "2019-07-07T17:55:09Z",
    "file_size": 22999204,
    "plain_text": "#### Installer Package\n Scripting\n\nMaking your deployments easier, one !# at a time\n\n\n###### Before we get started, there’s two things I’d like to mention. The first is that, all of the sides, speakers’ notes and the demos are available for download and I’ll be providing a link at the end of the talk. I tend to be one of those folks who can’t keep up with the speaker and take notes at the same time, so for those folks in the same situation, no need to take notes. Everything I’m covering is going to be available for download.\n\n\n-----\n\n###### You should:\n\n### •[Know the basics of writing ]\n\n###### scripts.\n\n### •[Know the basics of building ]\n\n###### an installer package.\n\n\n###### To set some expectations management for this session, my assumption is that folks here already know the basics of how to write scripts and build an installer package. We’re going to be discussing how to build on that foundation to solve problems.\n\n\n-----\n\n###### Now, installer packages are pretty great. They’re one of Apple’s two recommended ways to install software, with the other method being dragging and dropping a self-contained application into place.\n\n\n-----\n\n###### Installer Package Advantages\n\n### •[Permissions Control ]\n •[File location control ]\n •[May not require logged-in user ]\n •[Can run scripts as part of the installation ]\n\n###### process\n\n\n###### I personally believe installer packages are the superior installation method. You can control the permissions on the installed files. You can control where the installed files are placed. When properly built, a package can be installed with nobody logged in. Last, but not least, you can run scripts as part of the installation process.\n\n\n-----\n\n###### Another advantage, outside of the package itself, is that every Mac management system I’ve run into yet has the ability to install an installer package. For folks who have to support multiple management systems, this common ability means you can build one package and be confident that it will deploy the same regardless of the management system used to install it.\n\n\n-----\n\n#### Using Scripts\n\n\n###### However, the real magic of using installer packages happens when you start using scripts as part of the installation process.\n\n\n-----\n\nPHP\n\nJavaScript Ruby\n\nShell Perl\n\nPython\n\n###### Many More!\n\n\n###### What languages can you use? Well, if a client Mac supports a language, the Installer tool should be able to support running scripts written in that language on that client.\n\n\n-----\n\n```\n#!/bin/bash\n\n```\n\n###### Probably the most common form is going to be shell scripting using the bash shell, though, so that’s what I’m going to focus on.\n\n\n-----\n\n###### From there, your scripting options are going to depend on whether you’re using a bundle-style package or a flat package.\n\n\n-----\n\n##### Bundle-style package scripts\n\nNAME HOW USED\n\n**preflight** **Preflight scripts are run before files are being installed. If the script does not return an exit status of 0, Installer will cancel the installation.**\n\n**Preinstall scripts are run before files are being installed and after the preflight script if one is defined.**\n\n**preinstall** This script is run only if the component is being installed for the first time. If the script does not return\n\n|NAME|HOW USED|\n|---|---|\n|preflight|Preflight scripts are run before files are being installed. If the script does not return an exit status of 0, Installer will cancel the installation.|\n|preinstall|Preinstall scripts are run before files are being installed and after the preflight script if one is defined. This script is run only if the component is being installed for the first time. If the script does not return an exit status of 0, Installer will cancel the installation.|\n|preupgrade|Preupgrade scripts are run before files are being installed and after the preflight script if one is defined. This script is run only if the component has been previously installed. If the script does not return 0, Installer will cancel the installation.|\n|postinstall|Postinstall scripts are run after files have been installed and before the postfligt script if one is defined. This script is run only if the component is being installed for the first time. If the script does not return 0, Installer will declare the installation failed.|\n|postupgrade|Postupgrade scripts are run after files have been installed and before the postfligt script if one is defined. This script is run only if the component has been previously installed. If the script does not return an exit status of 0, Installer will declare the installation failed.|\n|postflight|Postflight scripts are run after files have been installed. If the script does not return an exit status of 0, Installer will declare the installation failed.|\n\n\nThis script is run only if the component is being installed for the first time. If the script does not return\n\n\ndefined. This script is run only if the component has been previously installed. If the script does not\n\n\nscripts are run before files are being installed. If the script does not return an exit status of\n\n\nscripts are run after files have been installed. If the script does not return an exit status of\n\n\nscripts are run after files have been installed and before the postfligt script if one is\n\n\nreturn an exit status of 0, Installer will declare the installation failed.\n\n\nan exit status of 0, Installer will cancel the installation.\n\n\nreturn 0, Installer will cancel the installation.\n\n\n**postupgrade**\n\n\n**postinstall**\n\n\n**preinstall**\n\n\nHOW USED\n\n\n**Preupgrade**\n\n\n**Postinstall**\n\n\n**Preinstall**\n\n\n###### Bundle-style installer packages are created as a Mac OS X bundle that contains scripts and a description of the package requirements and behavior. As part of creating a bundle-style package, you can define scripts that will be executed before or after the installation. Normally, there are six types of scripts can be used in a bundle-style package.\n\n\ndefined. This script is run only if the component is being installed for the first time. If the script does\n\n\nscripts are run before files are being installed and after the preflight script if one is defined.\n\n\nscripts are run before files are being installed and after the preflight script if one is\n\n\n0, Installer will declare the installation failed.\n\n\n**preupgrade**\n\n\n**preflight**\n\n\n**Postflight**\n\n\nNAME\n\n\n-----\n\n##### Bundle-style package scripts\n\n|NAME|HOW USED|\n|---|---|\n|preflight|Preflight scripts are run before files are being installed. If the script does not return an exit status of 0, Installer will cancel the installation.|\n|postflight|Postflight scripts are run after files have been installed. If the script does not return an exit status of 0, Installer will declare the installation failed.|\n\n\nscripts are run before files are being installed. If the script does not return an exit status of\n\n\n0, Installer will declare the installation failed.\n\n\n**postflight**\n\n\nHOW USED\n\n\n**Preflight**\n\n\n###### However, most of the time you’ll be using these two types. Preflight scripts get run before files are installed and postflight scripts run after files are installed. The other types of scripts only apply in specific defined circumstances which may not apply to your package.\n\n\nscripts are run after files have been installed. If the script does not return an exit status of\n\n\n**preflight**\n\n\nNAME\n\n\n-----\n\n###### Bundle-style ⇢ Flat package \n\n|BUNDLE-STYLE SCRIPT NAME|Col2|FLAT SCRIPT NAME|\n|---|---|---|\n|preflight|=|preinstall|\n|postflight|=|postinstall|\n\n\n###### Category Mapping\n\n\n###### Bundle-style\n\n\nFLAT SCRIPT NAME\n\n\n**postflight**\n\n\n**preflight**\n\n\n=\n\n\n###### When Apple created the flat package format, they simplified the script options and made only two script options available. The bundle-style post/preinstall and pre/postupdate script options were removed. Apple retained the concept of pre- and postflight scripts, but Apple renamed those script categories to preinstall and postinstall to make their functions more clear.\n\n\n###### Flat package \n\n\n**postinstall**\n\n\n###### ⇢\n\n\n-----\n\n##### Scripts must return an exit status of zero\n\n\n###### A commonality between scripts used in bundle-style and flat packages are that the scripts must return an exit status of zero or else Installer will report failure.\n\n\n##### Scripts must return an exit status of zero\n\n\n-----\n\n##### Scripts must return an exit status of zero\n```\n     #!/bin/bash\n     if [[ -f \"/path/to/file\" ]]; then\n       /usr/sbin/do_something \"/path/to/file\"\n     fi\n     exit 0\n\n```\n\n##### Scripts must return an exit status of zero\n\n\n###### If you're building a shell script for an installer package, one way to ensure that the script returns a status of zero is by adding \"exit 0\" to the end of your script.\n\n\n-----\n\n##### Installer Script Variables\n\n|VARIABLE|Col2|WHAT’S REFERENCED|\n|---|---|---|\n|$0|=|returns the path to the script|\n|$1|=|returns the path to the package|\n|$2|=|returns the target location (for example: /Applications)|\n|$3|=|returns the target volume (for example: / Volumes/Macintosh HD)|\n\n\n##### Installer Script Variables\n\n\nreturns the path to the package\n\n\nreturns the path to the script\n\n\nexample: /Applications)\n\n\nVARIABLE\n\n\n**$2**\n\n\n**$1**\n\n\n=\n\n\n=\n\n\n###### When building a script for use with an installer package, it's helpful to know that the Installer application can automatically pass along information to the script using variables. The ones shown on the screen are for shell scripts.\n\n\nreturns the target volume (for example: /\n\n\nVolumes/Macintosh HD)\n\n\n**$0**\n\n\n=\n\n\n-----\n\n##### Using Installer Script Variables\n```\n  #!/bin/bash\n  # Detects if /Users is present. If /Users is present,\n  # the chflags command will unhide it\n  if [[ -d \"$3/Users\" ]]; then\n   chflags nohidden \"$3/Users\"\n  fi\n  # Detects if /Users/Shared is present. If /Users/Shared is present, \n  # the chflags command will unhide it\n  if [[ -d \"$3/Users/Shared\" ]]; then\n   chflags nohidden \"$3/Users/Shared\"\n  fi\n  exit 0\n\n```\n\n##### Using Installer Script Variables\n\n\n###### Here’s an example of using the dollar sign three variable in an installer script. In this case, we’re able to take advantage of the Installer telling us which drive the package is being installed on to have our script run actions on the targeted drive.\n\n One thing that’s important to know is the closest set of variables to the script is going to win. If your system management tool assigns dollar sign 3 to something different than Installer does, the Installer-assigned meaning will be used by the script inside the package.\n\n\n-----\n\n###### So, big deal right? I can use scripts as part of installer packages. Great. Why have a session about this?\n\n\n-----\n\n### •[Fix other installation scripts ]\n •[Install software which uses a ]\n\n###### third-party installer\n\n### •[Deploy custom configurations ]\n •[Run scripts without installing ]\n\n###### files\n\n\n###### There are lots of cool ways to use installer scripts. You can use them to fix problems in other people’s installer scripts, install software which doesn’t use any of Apple’s recommended installation methods, deploy configuration files for other installers, and you can even build an installer package which is only a delivery mechanism for scripts.\n\n\n-----\n\n##### Free Packaging Tools\n\n**Iceberg** **Packages**\n\n##### The Luggage munkipkg\n\n\n##### Free Packaging Tools\n\n\n##### munkipkg\n\n\n**Iceberg**\n\n\n###### For your packaging needs, there are a number of free tools available. I personally use Stéphane Sudre’s Iceberg and Packages for when I need to manually create a package, but try them all out and use the one that works best for you. Iceberg builds bundle-style installer packages, while Packages builds flat packages.\n\n If you need to use source control for your packaging, I recommend using either Munkipkg or The Luggage. Both are free open source tools which allow packages to be built in a consistent and repeatable way using source files and scripts. In the case of the The Luggage, this was a tool originally created by Joe Block, who had written a tool when he worked at Google which used makefiles to generate installers. This allowed the other members of his group to easily review installer package changes before they were put into production. When Joe left Google, he wanted to have a similar tool available, so he wrote and open-sourced The Luggage.\n\n Jamf’s Composer is also an available tool for creating packages, and it includes a handy feature for taking \"before\" and \"after\" snapshots of your system, where you make the initial snapshot, install your software, then take a second snapshot once the installation is finished. Composer will then generate a list of the files and directories that changed and use those changes to generate a package. The main reason it’s not up on this slide is that it isn’t free. It is available for purchase from Jamf and is also included as part of Jamf’s Jamf Pro Suite.\n\n\n##### The Luggage\n\n\n**Packages**\n\n\n-----\n\n##### Free Packaging Tools\n\n AutoPkg\n\n###### https://youtu.be/BI10WWrgG2A\n\n\n##### AutoPkg\n\n\n###### To further automate your packaging, there is another open source tool called AutoPkg. AutoPkg is hugely useful because it’s designed to automate the tasks one would normally perform manually to prepare third-party software for deployment.\n\n For those not familiar with AutoPkg, there was a great introductory talk by Anthony Reimer from the University of Calgary this past summer at the Penn State MacAdmins Conference. The talk was posted to YouTube and the link is available at the bottom of the screen.\n\n\n##### Free Packaging Tools\n\n\n-----\n\n##### AutoPkg\n\n**•** **[Downloading an application and/or updates for it, usually ]**\n\n**via a web browser**\n\n**•** **[Extracting them from a multitude of archive formats ]**\n\n**•** **[Adding site-specific configuration ]**\n\n**•** **[Adding sane versioning information ]**\n\n**•** **[\"Fixing\" poorly-written installer scripts ]**\n\n**•** **[Saving these modifications back to a compressed disk ]**\n\n**image or installer package**\n\n**•** **[Importing these into a software distribution system like ]**\n\n**Munki, Jamf Pro, FileWave, etc.**\n\n**•** **[Customizing the associated metadata for such a system ]**\n\n**with site-specific data, post-installation scripts, version**\n**info or other metadata**\n\n\n##### AutoPkg\n\n\n###### While this talk is going to focus on manually building packages to solve specific problems using installer scripts, I want to mention AutoPkg because it often allows you to solve the same problems in a consistent and repeatable fashion, with the added bonus of also automating the download of the applications you need to package.\n\n In many cases, I will solve a packaging problem first by manually building and testing a package. Then I will write a recipe file for AutoPkg to automate the building of that same package. For those not familiar with AutoPkg and how it works, a recipe is an XML file which describes a sequence of tasks for AutoPkg to run. These tasks can include downloading some piece of software, building an installer package for that software, and then importing the newly- created installer package into your Mac software management tool.\n\n To help illustrate this, I'll be discussing some examples later of how I first solved a problem with manual packaging then later turned it into an AutoPkg recipe.\n\n\n-----\n\n##### Fixing Other Installation Scripts\n\n\n###### To give some practical examples, let’s look at how a vendor’s installer package didn’t cover all the possible deployment scenarios and how you can use your own script to fix it. For this scenario, we’ll be working with the Citrix Workspace installer.\n\n\n##### Fixing Other Installation Scripts\n\n\n-----\n\n###### The Workspace installer package provided by Citrix runs both a preinstall and postinstall script.\n\n\n-----\n\n**LOG_FILE_PATH=\"$HOME/Library/Logs/ReceiverInstall.log\"**\n\n\n###### As part of the postinstall script, one of the script variables references HOME. HOME is a variable which is set at login to be the path name for the user’s home directory. Citrix’s working assumption is that someone will be logged in when Citrix Workspace is installed.\n\n\n-----\n\n##### Scripts must return an exit status of zero\n\n\n###### However, there will be times when nobody is logged in. In these cases, an error will be generated and the script will return an exit status other than zero. One thing to remember is that installation scripts must return an exit status of zero or else Installer will report failure.\n\n\n##### Scripts must return an exit status of zero\n\n\n-----\n\n###### How to fix this? By avoiding the error condition. We can do this by writing a script that does three tasks: 1. Verifying that the Citrix-built installer is available at a location defined by the script. 2. If the installer is present, making sure HOME always returns a valid result by resetting HOME to be a value\n controlled by the script. 3. Running the Citrix-built installer while using the updated HOME value.\n\n\n-----\n\n###### First step is verifying that the installer is available at the script’s defined location.\n\n\n-----\n\n###### Next step is trying make sure we match the Citrix installer’s assumption if at all possible. We do that by first figuring out if there’s a logged-in user.\n\n\n-----\n\n###### After that, figure out the location of the logged-in user’s home folder.\n\n\n-----\n\n###### Next step is setting the HOME value to match the path of the logged-in user’s home folder. This matches the default behavior of the HOME variable, so it matches the assumptions Citrix made when building their installer.\n\n\n-----\n\n###### Here’s where we set HOME to always return a value even in those conditions where the Citrix-built installer would error. If a logged-in user can’t be determined, HOME is set to use the var root directory, which is the home directory of the root user on macOS.\n\n\n-----\n\n###### Last step, the script runs the Citrix-built installer. Now that the script is setting the HOME value to be valid in all conditions, the Citrix-built installer should not error.\n\n\n-----\n\n# +\n\n\n###### Let’s put all of this together into a package. To do this, I’ll be using the script I just described as a postinstall script, a copy of the the latest Citrix Workspace installer and the Packages app to create the package.\n\n\n-----\n\n###### First step is to open the Packages app and set up a raw package project.\n\n\n-----\n\n###### Next, we name it and define where the Packages project file will be stored. In this case, I’m naming the package as Citrix Workspace and storing the project files in a Citrix Workspace directory in my home folder.\n\n\n-----\n\n###### In the Project pane, the main thing I’m checking here is the name to make sure it’s right. As long as that’s correct, there’s no need to change anything here from the defaults.\n\n\n-----\n\n###### In the Settings pane, we want to require the admin password for installation and on successful installation, we don’t want to do anything else.\n\n\n-----\n\n###### In the Payload pane, we’re not changing anything from the defaults.\n\n\n-----\n\n###### In the scripts pane, we need to add the Citrix-built installer under additional resources and add the postinstall script to the post- installation section.\n\n\n-----\n\n###### “These resources can be used by the \n pre and post-installation scripts”\n\n\n###### The reason why we add the Citrix installer to the additional resources section is because Packages will store those resources in the same location as it stores the pre and post install scripts. This allows our script to be able to access the Citrix-built Workspaces installer.\n\n\n-----\n\n-----\n\n###### Once the package is built, you can test it by deploying it onto a Mac while that Mac is at the login screen with nobody logged-in. It should install successfully where previously you would have received an error.\n\n\n-----\n\n**https://github.com/autopkg/rtrouton-recipes/blob/master/CitrixWorkspace/**\n\n**CitrixWorkspace.pkg.recipe**\n\n\n###### For those who want to automate this process using AutoPkg, I have written a Citrix Workspace package recipe to create a package just like the one we’ve been talking about. It’s available on GitHub via the address shown on the screen and uses the same postinstall script that I’ve described.\n\n\n-----\n\n###### Install software which uses \n\n\n###### a third-party installer\n\n\n###### There are also vendors who prefer to use installers which don’t use any of Apple’s supported methods. These can be challenging, but you can still package these if you can run the provided installer from the command line. For this scenario, we’ll be working with the Adobe Creative Cloud Desktop app installer.\n\n\n###### Install software which uses \n\n\n-----\n\n###### Adobe goes their own way most of the time when it comes to installers and the Creative Cloud Desktop app for macOS is a good example. It uses an Adobe-developed installer and in no way leverages either of Apple’s supported installation methods.\n\n\n-----\n\n###### That said, Adobe did include a way to run a silent install from the command line.\n\n\n**/path/to/Install.app/Contents/MacOS/Install --mode=silent**\n\n\n-----\n\n-----\n\n###### With this information, we can build a script which does two tasks: 1. Identify the directory that the script is running from. The Adobe installer will be placed in the same directory. 2. Running the Adobe installer using the silent install mode.\n\n\n-----\n\n###### First step is identifying the script’s location.\n\n\n-----\n\n###### Second is running the installer, using the location information to provide the path to the installer.\n\n\n-----\n\n# +\n\n\n###### Now that we have that, let’s put all of this together into a package. To do this, I’ll be using the script I just described as a postinstall script, a copy of the the latest Adobe Creative Cloud Desktop installer, the installer’s support directories and the Packages app to create the package.\n\n\n-----\n\n###### First step is to open the Packages app and set up a raw package project.\n\n\n-----\n\n###### Next, we name it and define where the Packages project file will be stored. In this case, I’m naming the package as Adobe Creative Cloud Desktop Installer and storing the project files in a Adobe Creative Cloud Desktop Installer directory in my home folder.\n\n\n-----\n\n###### In the Project pane, the main thing I’m checking here is the name to make sure it’s right. As long as that’s correct, there’s no need to change anything here from the defaults.\n\n\n-----\n\n###### In the Settings pane, we want to require the admin password for installation and on successful installation, we don’t want to do anything else.\n\n\n-----\n\n###### In the Payload pane, we’re not changing anything from the defaults.\n\n\n-----\n\n###### In the scripts pane, we need to add the Adobe installer and its support directories under additional resources and add the postinstall script to the post-installation section. As mentioned during the Citrix Workspace installer, placing things in additional resources means they can be referenced by pre and post installation scripts.\n\n\n-----\n\n-----\n\n###### Once the package is built, you can test it by deploying it onto a Mac that doesn’t have the Adobe Creative Cloud Desktop app installed and verify that the desktop app installs correctly.\n\n\n-----\n\n-----\n\n**https://github.com/autopkg/rtrouton-recipes/blob/master/AdobeCreativeCloud/**\n\n**AdobeCreativeCloudInstaller.pkg.recipe**\n\n\n###### For those who want to automate this process using AutoPkg, I have written a Adobe Creative Cloud Desktop app package recipe to create a package just like the one we’ve been talking about. It’s available on GitHub via the address shown on the screen and uses the same postinstall script that I’ve described.\n\n\n-----\n\n##### Deploy Custom Configurations\n\n\n###### You can also use scripts to help deploy a custom software configuration. In many cases, vendors will support placing a configuration file in the same directory as their installer.\n\n An example of this is F5 Network’s VPN client. When the F5 installer detects a file with a certain name in the same directory as the installer, it uses the contents of that file to install the VPN configuration along with the software.\n\n\n##### Deploy Custom Configurations\n\n\n-----\n\n##### Filename: config_tmp.f5c\n\n\n###### The file in question is an XML document configured and named as shown on the screen. You normally shouldn’t have to worry about creating this file, as your VPN admin should be able to provide it to you.\n\n\n-----\n\n###### A check for a file with the specified name is included as part of a postinstall script included with the F5 VPN installer. The script assumes that the installer and configuration file are located in the same directory. If the configuration file is found, the installer copies it into Library Application Support F5Networks so that the VPN software can detect and use it.\n\n\n-----\n\n###### Once we have both the configuration file and the VPN installer, we can write a script that does three tasks:\n\n 1. Verifying that the configuration file is available at a location defined by the script. 2. Verifying that the VPN installer is available at the same location. 3. Running the VPN installer and verifying it ran successfully.\n\n\n-----\n\n# +\n\n\n###### Now that we have that, let’s put all of this together into a package. To do this, I’ll be using the script I just described as a postinstall script, a copy of the the latest F5 VPN installer, the configuration file and the Packages app to create the package.\n\n\n-----\n\n###### The process is going to be pretty much identical to our previous examples. First step is to open the Packages app and set up a raw package project.\n\n\n-----\n\n###### Next, we name it and define where the Packages project file will be stored. In this case, I’m naming the package as F5 VPN Installer and storing the project files in a F5 VPN Installer directory in my home folder.\n\n\n-----\n\n###### In the Project pane, the main thing I’m checking here is the name to make sure it’s right. As long as that’s correct, there’s no need to change anything here from the defaults.\n\n\n-----\n\n###### In the Settings pane, we want to require the admin password for installation and on successful installation, we don’t want to do anything else.\n\n\n-----\n\n###### In the Payload pane, we’re not changing anything from the defaults.\n\n\n-----\n\n###### In the scripts pane, we need to add the F5 installer and the configuration file under additional resources and add the postinstall script to the post-installation section. As mentioned during the previous examples, placing things in additional resources means they can be referenced by pre and post installation scripts.\n\n\n-----\n\n-----\n\n###### Once the package is built, you can test it by deploying it onto a Mac that doesn’t have the F5 VPN installed and verify that the VPN installs correctly and is configured with the desired setup.\n\n\n-----\n\n-----\n\n###### Run scripts without installing files\n\n\n###### The final area I want to talk about is one of my favorites, where you can use an installer package as a delivery mechanism for scripts. No files get installed in this case because the only thing in the installer package is the script.\n\n\n###### Run scripts without installing files\n\n\n-----\n\n##### Payload-free packages\n\n\n###### Payload-free packages is Apple’s term to describe installer packages that install no files and which have been built only to run scripts. As with other installer packages, there are two kinds of payload-free installer packages, bundle-style and flat.\n\n\n##### Payload-free packages\n\n\n-----\n\n###### Building payload-free packages\n with pkgbuild\n\n**http://www.manpagez.com/man/1/pkgbuild/**\n\n\n###### with pkgbuild\n\n\n###### Apple has built support into its command line pkgbuild tool, which is used to build flat installer packages.\n\n\n###### Building payload-free packages\n\n\n-----\n\n###### Building payload-free packages\n with pkgbuild\n\n pkgbuild --identifier com.identifier.here \\\n --nopayload \\  --scripts /path/to/scripts \\  /path/to/package_name_here.pkg\n\n\n###### Building payload-free packages\n\n\n###### The no payload option tells pkgbuild that the package being built will contain only scripts\n\n\n###### with pkgbuild\n\n\n-----\n\n###### Let’s take a look at how this works by turning the following script into a payload-free package.\n\n\n-----\n\n###### We’ll start by saving the script inside a directory named scripts as an executable file named postinstall. Not postinstall dot sh, just postinstall. The name must be right or Installer won’t recognize it.\n\n The reason for the scripts directory is that pkgbuild's scripts option is set to look for a directory with scripts inside, rather than specifying the scripts themselves.\n\n\n-----\n\n**pkgbuild --identifier com.company.sysdiagnose \\**\n\n**--nopayload \\**\n**--scripts /path/to/scripts \\**\n**/path/to/sysdiagnose_gathering.pkg**\n\n\n###### Once the scripts directory is set up and the postinstall script saved inside it, running the following command with root privileges will build a payload-free package and store it in the designated location.\n\n\n-----\n\n###### Once the package is built, you can hand it off to whatever or whoever needs it and they’ll be able to execute the script without knowing anything more than how to install a package.\n\n\n-----\n\n###### Hang on, where's the \n version number?\n\n pkgbuild --identifier com.identifier.here \\\n --nopayload \\  --scripts /path/to/scripts \\  /path/to/package_name_here.pkg\n\n\n###### Hang on, where's the \n\n\n###### For those familiar with pkgbuild, you may think I've left something out - The version number. Actually, I didn't leave it out. When you're building payload-free packages using the nopayload option, the version number isn't required. How come?\n\n\n###### version number?\n\n\n-----\n\n###### Payload-free flat packages may\n\n\n###### not leave installer receipts\n\n\n###### When building a payload-free package with Apple’s pkgbuild tool using the nopayload flag, no receipt is left behind. No receipt, no need for a version number.\n\n\n###### Payload-free flat packages may\n\n\n-----\n\n###### Payload-free flat packages may\n\n\n###### not leave installer receipts\n\n\n###### When I filed a bug on this, Apple said that this was intended behavior for payload-free packages built using pkgbuild's nopayload option. In Apple’s opinion, payload-free packages are a convenient bag for scripts.\n\n Any other type of package will leave behind a receipt, including a bundle-style payload-free package.\n\n Why is this important? If your systems management tools relies on receipts to tell whether a payload-free package has been installed, a payload-free package that leaves no receipt behind means that your management tool won’t be able to tell that it’s been installed. This may result in the payload-free package and its associated script being run repeatedly on your managed machine.\n\n\n###### Payload-free flat packages may\n\n\n-----\n\n###### Making payload-free flat packages\n which leave installer receipts\n\n pkgbuild --identifier com.identifier.here \\\n --root /path/to/empty_directory \\  --scripts /path/to/scripts --version 1.0 \\\n /path/to/package_name_here.pkg\n\n\n###### Making payload-free flat packages\n\n\n###### However, you can make a package with pkgbuild that, while not technically payload-free, will act just like one. The key is to create an empty directory and set pkgbuild’s –root option to look there for files. pkgbuild’s –root option is used to tell pkgbuild which files to package, but since there will be no files in an empty directory, the package will install no files on the destination Mac. However, it will leave behind a receipt.\n\n\n###### which leave installer receipts\n\n\n-----\n\n-----\n\n**https://github.com/rtrouton/payload-free_package_printer_generator**\n\n\n###### Payload-Free Package Printer Generator\n\n\n###### Another tool I've developed is a script used to build payload-free packages, where the package sets up a printer with a desired configuration.\n\n\n-----\n\n###### Payload-Free Package Printer Generator\n\n\n\n**•** **[-n: Name of the print queue. May not contain spaces, tabs, # or / characters. (required) ]**\n\n**•** **[-l: The physical location of the printer. Examples may include Reception Desk, ]**\n\n**Librarian's Office or Second Floor, Room 2C456 (optional)**\n\n**•** **[-d: The printer name which is displayed in the Printers & Scanners pane of System ]**\n\n**Preferences, as well as in the print dialogue boxes. (required)**\n\n**•** **[-a: The IP or DNS address of the printer. Protocol must be specified as part of the ]**\n\n**address (for example, use lpd://ip.address.goes.here or lpd://dns.address.goes.here for**\n**LPR printing.) (required)**\n\n**•** **[-p: Name of the driver f][i][le in /Library/Printers/PPDs/Contents/Resources/. This must ]**\n\n**use the full path to the drive (starting with /Library). (required)**\n\n**•** **[-1: Specify first printer option. (optional) ]**\n\n**•** **[-2: Specify second printer option. (optional) ]**\n\n**•** **[-3: Specify third printer option. (optional) ]**\n\n**•** **[-4: Specify fourth printer option. (optional) ]**\n\n**•** **[-5: Specify fifth printer option. (optional) ]**\n\n**•** **[-6: Specify sixth printer option. (optional) ]**\n\n**•** **[-7: Specify seventh printer option. (optional) ]**\n\n**•** **[-8: Specify eighth printer option. (optional) ]**\n\n**•** **[-9: Specify ninth printer option. (optional) ]**\n\n**•** **[-c: Name of the Apple Developer ID Installer certificate being used to sign the payload-]**\n\n**free package. Certificate name should be formatted like Developer ID Installer: Your**\n**Name or Developer ID Installer: Your Name (F487797D). (optional)**\n\n\n###### This script has a number of options, including an option to sign the payload-free package using an Apple Developer certificate. Signing the package would enable the package to be posted somewhere for download and get past Gatekeeper.\n\n\n-----\n\n###### •[-n: ][ReceptionDeskBrotherLaserPrinter]\n •[-l: ][Reception Desk ]\n •[-d: ][Reception Desk Brother Laser Printer]\n •[-a: ][lpd://192.168.1.121]\n •[-p: ][\"/Library/Printers/PPDs/Contents/]\n Resources/Brother DCP-L2540DW series CUPS.gz\"\n\n\n###### While this tool has a lot of options, you may only need to use a few of them to set up a printer. Let's take a look at how this works using only these options.\n\n\n-----\n\n###### /path/to/payload-free_package_printer_generator.sh \\ \n -n ReceptionDeskBrotherLaserPrinter \\ \n -l \"Reception Desk\" \\ -d \"Reception Desk Brother Laser Printer\" \\\n -a lpd://192.168.1.121 \\  -p \"/Library/Printers/PPDs/Contents/Resources/Brother\n DCP-L2540DW series CUPS.gz\"\n\n\n###### Here's how the command to run the script would look. I have it broken up into separate lines for clarity, normally this would all be on one line.\n\n\n-----\n\n-----\n\n###### The build process covered up the Terminal window, but here's the output you should see.\n\n\n-----\n\n-----\n\n##### Examining Scripts\n\n**Suspicious**\n\n**Pacifist**\n**Package**\n\n##### pkgutil\n\n\n##### Examining Scripts\n\n\n**Suspicious**\n\n\n**Pacifist**\n\n\n###### Now that you’ve seen how you can use scripts, how can you check out existing installer package scripts to see what they’re doing? There’s a few tools that can help you out. There’s Apple’s pkgutil command line tool, Pacifist and Suspicious Package. pkgutil and Suspicious Package are both free while Pacifist is shareware with a free trial period. Since both are free with no strings attached, let’s look at pkgutil and Suspicious Package.\n\n\n**Package**\n\n\n-----\n\n###### Expanding packages with pkgutil\n\n pkgutil --expand \\ /path/to/package_name_here.pkg \\ \n /path/to/directory_goes_here\n\n\n###### Expanding packages with pkgutil\n\n\n###### pkgutil doesn’t directly examine scripts for you, but it expands the contents of an installer package into a directory. From there, you can examine the scripts included with the package.\n\n\n-----\n\n###### pkgutil doesn’t directly examine scripts for you, but it expands the contents of an installer package into a directory. From there, you can examine the scripts included with the package.\n\n\n-----\n\n##### Suspicious Package\n\n\n###### Suspicious Package is a phenomenally useful tool, for reasons that will be shown in a second. It’ll check out an installer package for you, show you its contents and even warn you if there’s problems.\n\n\n##### Suspicious Package\n\n\n-----\n\n-----\n\n##### Useful Links\n\nUnderstanding Payload-Free Packages: https://\nderflounder.wordpress.com/2014/06/01/understandingpayload-free-packages/\n\nCreating payload-free packages with pkgbuild: https://\nderflounder.wordpress.com/2012/08/15/creating-payload-freepackages-with-pkgbuild/\n\nApple Developer Software Delivery Legacy Guide: http://\ntinyurl.com/hze8pr8\n\nFlat Package Format - The missing documentation: http://\ns.sudre.free.fr/Stuff/Ivanhoe/FLAT.html\n\n\nderflounder.wordpress.com/2012/08/15/creating-payload-free-\n\n\nFlat Package Format - The missing documentation:\n\n\nCreating payload-free packages with pkgbuild: https://\n\n\n##### Useful Links\n\n\npackages-with-pkgbuild/\n\n\ntinyurl.com/hze8pr8\n\n\nhttp://\n\n\n-----\n\n##### Useful Links\n\nPreparing EndNote X8 for deployment using AutoPkg: https://\nderflounder.wordpress.com/2016/11/15/preparing-endnote-x8for-deployment-using-autopkg/\n\nCreating a DNAStar Lasergene 13.x installer: https://\nderflounder.wordpress.com/2016/03/17/creating-a-dnastarlasergene-13-x-installer/\n\nDeploying a pre-configured Junos Pulse VPN client on OS X:\nhttps://derflounder.wordpress.com/2015/03/13/deploying-apre-confgured-junos-pulse-vpn-client-on-os-x/i\n\nRepackaging the LabVIEW 2013 Pro installer: https://\nderflounder.wordpress.com/2013/12/06/repackaging-thelabview-2013-pro-installer/\n\n\nderflounder.wordpress.com/2016/11/15/preparing-endnote-x8-\n\n\nDeploying a pre-configured Junos Pulse VPN client on OS X:\n\n\nderflounder.wordpress.com/2013/12/06/repackaging-the-\n\n\npre-confgured-junos-pulse-vpn-client-on-os-x/i\n\n\nCreating a DNAStar Lasergene 13.x installer:\n\n\nfor-deployment-using-autopkg/\n\n\nlasergene-13-x-installer/\n\n\nhttps://\n\n\n-----\n\n##### Useful Links\n\nPacifist: https://charlessoft.com\n\nSuspicious Package: https://mothersruin.com/software/\nSuspiciousPackage/\n\nIceberg: http://s.sudre.free.fr/Software/Iceberg.html\n\nPackages: http://s.sudre.free.fr/Software/Packages/\nabout.html\n\nThe Luggage: http://luggage.apesseekingknowledge.net\n\n\nhttp://s.sudre.free.fr/Software/Iceberg.html\n\n\nhttp://s.sudre.free.fr/Software/Packages/\n\n\n##### Useful Links\n\n\nSuspicious Package:\n\n\nThe Luggage:\n\n\nabout.html\n\n\nPacifist:\n\n\n-----\n\n##### Useful Links\n\nMunkiPkg: https://github.com/munki/munki-pkg\n\nJamf Composer: https://www.jamf.com/products/jamfcomposer/\n\nPayload-Free Package Creator: https://github.com/rtrouton/\nPayload-Free-Package-Creator\n\n\nrtrouton/payload-free_package_printer_generator\n\n\nhttps://www.jamf.com/products/jamf-\n\n\n##### Useful Links\n\n\nPayload-Free-Package-Creator\n\n\nhttps://github.com/\n\n\ncomposer/\n\n\n-----\n\n# Downloads\n\n###### PDF available from the following link:\n\n https://tinyurl.com/PSUMacAdmins2019PDF\n\n Keynote slides available from the\n following link:\n\n\n# Downloads\n\n\n###### Keynote slides available from the\n\n\n###### https://tinyurl.com/PSUMacAdmins2019PDF\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://cpb-us-e1.wpmucdn.com/sites.psu.edu/dist/4/24696/files/2019/07/psumac2019-345-Installer-Package-Scripting-Making-your-deployments-easier-one-at-a-time.pdf"
    ],
    "report_names": [
        "psumac2019-345-Installer-Package-Scripting-Making-your-deployments-easier-one-at-a-time.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1666859770,
    "ts_updated_at": 1743041153,
    "ts_creation_date": 1562522109,
    "ts_modification_date": 1562522109,
    "files": {
        "pdf": "https://archive.orkl.eu/aee91a10ea1743bfa62e8af22f2634ad98105c3b.pdf",
        "text": "https://archive.orkl.eu/aee91a10ea1743bfa62e8af22f2634ad98105c3b.txt",
        "img": "https://archive.orkl.eu/aee91a10ea1743bfa62e8af22f2634ad98105c3b.jpg"
    }
}