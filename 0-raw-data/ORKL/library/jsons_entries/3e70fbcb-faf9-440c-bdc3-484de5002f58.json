{
    "id": "3e70fbcb-faf9-440c-bdc3-484de5002f58",
    "created_at": "2023-01-12T15:06:07.528467Z",
    "updated_at": "2025-03-27T02:05:27.614695Z",
    "deleted_at": null,
    "sha1_hash": "b4b06c82271490b7bf844c7d4b4d2ef598811550",
    "title": "2021-06-15 - What you need to know about Process Ghosting, a new executable image tampering attack",
    "authors": "",
    "file_creation_date": "2022-05-28T05:07:55Z",
    "file_modification_date": "2022-05-28T05:07:55Z",
    "file_size": 600445,
    "plain_text": "# What you need to know about Process Ghosting, a new executable image tampering attack\n\n**[elastic.co/blog/process-ghosting-a-new-executable-image-tampering-attack](https://www.elastic.co/blog/process-ghosting-a-new-executable-image-tampering-attack)**\n\nJune 15, 2021\n\n[15 Juni 2021Tech Topics](https://www.elastic.co/blog/category/technical-topics)\n\nBy\n[Gabriel Landau](https://www.elastic.co/blog/author/gabriel-landau)\nShare\n\nSecurity teams defending Windows environments often rely on anti-malware products as a\nfirst line of defense against malicious executables. Microsoft provides security vendors with\nthe ability to register callbacks that will be invoked upon the creation of processes on the\n[system. Driver developers can call APIs such as PsSetCreateProcessNotifyRoutineEx to](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutineex)\nreceive such events.\n\nDespite the name, PsSetCreateProcessNotifyRoutineEx callbacks are not actually invoked\nupon the creation of processes, but rather upon the creation of the first threads within those\nprocesses. This creates a gap between when a process is created and when security\nproducts are notified of its creation. It also gives malware authors a window to tamper with\n\n\n-----\n\nthe backing executable before security products can scan it. Recent examples of such\n[tampering attacks include Process Doppelgänging and](https://attack.mitre.org/techniques/T1055/013/) [Process Herpaderping, which abuse](https://github.com/jxy-s/herpaderping#process-herpaderping)\nthis behavior to evade security products.\n\nThis blog describes a new executable image tampering attack similar to, but distinct from,\nDoppelgänging and Herpaderping. With this technique, an attacker can write a piece of\nmalware to disk in such a way that it’s difficult to scan or delete it — and where it then\nexecutes the deleted malware as though it were a regular file on disk. This technique does\nnot involve code injection, process hollowing, or Transactional NTFS (TxF).\n\n## The birth of a process\n\nWindows Task Manager shows a list of processes running on the system. Each of these\nprocesses is associated with an executable file on disk, such as svchost.exe. This is\nbecause Windows launches processes from executable files, usually ending with an EXE\nfile extension.\n\n\n-----\n\nIt s important to note that processes are not executables, and executables are not\nprocesses. In the example Task Manager above, there are multiple processes launched\nfrom RuntimeBroker.exe and svchost.exe.\n\nTo launch a new process, a series of steps must occur. In modern versions of Windows,\nthey are typically performed in the kernel by NtCreateUserProcess — however, the\nindividual component APIs (NtCreateProcessEx etc) are still exposed and functional for\nbackwards compatibility purposes. These steps are:\n\n1. Open a handle to the executable to launch.  Example: hFile =\n\nCreateFile(“C:\\Windows\\System32\\svchost.exe”)2\n2. Create an “image” section for the file. A section maps a file, or a portion of a file, into\n\nmemory. An image section is a special type of section that corresponds to Portable\nExecutable (PE) files, and can only be created from PE (EXE, DLL, etc) files.\nExample: hSection = NtCreateSection(hFile, SEC_IMAGE)\n3. Create a process using the image section.  Example: hProcess =\n\nNtCreateProcessEx(hSection)\n4. Assign process arguments and environment variables.  Example:\n\nCreateEnvironmentBlock/NtWriteVirtualMemory\n5. Create a thread to execute in the process.  Example: NtCreateThreadEx\n\nHere is what that looks like in Process Monitor:\n\nexplorer.exe launching notepad.exe, as seen in Process Monitor\nProcesses are launched from executables, but some of the data within the executable file is\nmodified as it is mapped into a process. To account for these modifications, the Windows\nmemory manager caches image sections at the time of their creation. This means that\n**image sections can deviate from their executable files.**\n\n## Scanning processes for malware\n\n\n-----\n\nMicrosoft provides security vendors with the ability to register callbacks that will be invoked\nupon the creation of processes and threads on the system. Driver developers can call APIs\nsuch as [PsSetCreateProcessNotifyRoutineEx and](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutineex) [PsSetCreateThreadNotifyRoutineEx to](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreatethreadnotifyroutineex)\nreceive such events.\n\nDespite the name, PsSetCreateProcessNotifyRoutineEx callbacks are not actually invoked\nupon the creation of processes, but rather upon the creation of the first threads within those\nprocesses. This creates a gap between when a process is created and when security\nproducts are notified of its creation. It also gives malware authors a window to tamper with\nthe backing file and section before security products can scan them.\n\n[Note how the undocumented process creation API NtCreateProcess takes a section, not](http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FProcess%2FNtCreateProcess.html)\nfile, handle:\n```\nNTSYSCALLAPI\nNTSTATUS\nNTAPI\nNtCreateProcess(\n  _Out_ PHANDLE ProcessHandle,\n  _In_ ACCESS_MASK DesiredAccess,\n  _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,\n  _In_ HANDLE ParentProcess,\n  _In_ BOOLEAN InheritObjectTable,\n  _In_opt_ HANDLE SectionHandle,\n  _In_opt_ HANDLE DebugPort,\n  _In_opt_ HANDLE ExceptionPort\n  );\n\n```\nWhen a process is launched, security products are provided with the following information\nabout the process being launched:\n```\ntypedef struct _PS_CREATE_NOTIFY_INFO {\n SIZE_T       Size;\n union {\n  ULONG Flags;\n  struct {\n   ULONG FileOpenNameAvailable : 1;\n   ULONG IsSubsystemProcess : 1;\n   ULONG Reserved : 30;\n  };\n };\n HANDLE       ParentProcessId;\n CLIENT_ID      CreatingThreadId;\n struct _FILE_OBJECT *FileObject;\n PCUNICODE_STRING  ImageFileName;\n PCUNICODE_STRING  CommandLine;\n NTSTATUS      CreationStatus;\n} PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;\n\n```\n\n-----\n\nOf interest is the FILE_OBJECT, which is the kernel object corresponding to the HANDLE\npassed to NtCreateSection in the previous section. This FILE_OBJECT typically\ncorresponds to a file on disk, which can be scanned for malware.\n\nSecurity products may also use filesystem minifilter callbacks, which receive notifications\nwhen files are created, interacted with, or closed. The system impact of scanning every\nsingle read and write operation can be significant, so files are typically scanned upon open\nand close for performance reasons.\n\nThere are other potential security product interception points that we will not discuss here.\nSee [this talk for more information.](https://youtu.be/XmWOj-cfixs?t=719)\n\n## Prior work\n\n### Process Doppelgänging\n\nWindows Transactional NTFS (TxF) is a mechanism that allows an application to perform a\nseries of filesystem operations as a single atomic transaction, which is then either\ncommitted or rolled back. Files can exist within a transaction that, if rolled back, is never\nvisible to the underlying filesystem. Using TxF, it is possible to create an image section from\na file within a transaction, then roll back that transaction. It is possible to create a process\nfrom such image sections.\n\n### Process Herpaderping\n\nAfter creating the image section, Process Herpaderping uses the existing file handle to\noverwrite the executable with a decoy PE. While this leaves the decoy on disk, it is different\nfrom the one running in memory. The decoy remains on disk throughout the life of the\npayload process.\n\n### Process Reimaging\n\nProcess Reimaging exploits a cache synchronization issue in the Windows kernel, causing\na mismatch between an executable file’s path and the path reported for image sections\ncreated from that executable. By loading a DLL at a decoy path, unloading it, then loading it\nfrom a new path, various Windows APIs will return the old path. This can fool security\nproducts into looking for loaded images at the wrong path.\n\n## Ghosting a process\n\nWe can build upon Doppelgänging and Herpaderping to run executables that have already\nbeen deleted. There are several ways to delete a file on Windows, including:[3]\n\n\n-----\n\n[Create a new file over the old one with the FILE_SUPERSEDE or](https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile) [CREATE_ALWAYS](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew)\nflags set.\nSet the [FILE_DELETE_ON_CLOSE or](https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile) [FILE_FLAG_DELETE_ON_CLOSE flags](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew)\nwhen creating or opening the file.\n[Set the DeleteFile field in the FILE_DISPOSITION_INFORMATION structure to TRUE](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-_file_disposition_information)\n[when invoking the FileDispositionInformation file information class via](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntsetinformationfile)\n[NtSetInformationFile.](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntsetinformationfile)\n\nWindows attempts to prevent mapped executables from being modified. Once a file is\nmapped into an image section, attempts to open it with FILE_WRITE_DATA (to modify it)\nwill fail with ERROR_SHARING_VIOLATION. Deletion attempts via\nFILE_DELETE_ON_CLOSE/FILE_FLAG_DELETE_ON_CLOSE fail with\nERROR_SHARING_VIOLATION. NtSetInformationFile(FileDispositionInformation) requires\nthe DELETE access right. Even though the DELETE access right is granted to files mapped\nto image sections, NtSetInformationFile(FileDispositionInformation) fails with\nSTATUS_CANNOT_DELETE. Deletion attempts via\nFILE_SUPERCEDE/CREATE_ALWAYS fail with ACCESS_DENIED.\n\nAn important note, however, is that this deletion restriction only comes into effect once the\nexecutable is mapped into an image section. This means that it is possible to create a file,\nmark it for deletion, map it to an image section, close the file handle to complete the\ndeletion, then create a process from the now-fileless section. This is Process Ghosting.\n\nThe attack flow is:\n\n1. Create a file\n2. Put the file into a delete-pending state using\n\n[NtSetInformationFile(FileDispositionInformation). Note: Attempting to use](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwsetinformationfile)\nFILE_DELETE_ON_CLOSE instead will not delete the file.\n3. Write the payload executable to the file. The content isn’t persisted because the file is\n\nalready delete-pending. The delete-pending state also blocks external file-open\nattempts.\n4. Create an image section for the file.\n5. Close the delete-pending handle, deleting the file.\n6. Create a process using the image section.\n7. Assign process arguments and environment variables.\n8. Create a thread to execute in the process.\n\n\n-----\n\nAntivirus callbacks are invoked upon thread creation, which occurs after the file is deleted.\nAttempts to open the file or perform I/O on the deleted file will fail with\nSTATUS_FILE_DELETED. Attempts to open the file before deletion is complete will fail with\nSTATUS_DELETE_PENDING.\n\nThis type of tampering can be applied to DLLs as well, because DLLs are mapped image\nsections.\n\n### Demo\n\nThe video below shows Windows Defender detecting and blocking execution of a\nPotentially Unwanted Program (PUP), Windows Credential Editor, which can be used by\nattackers for lateral movement. It then shows how Ghosting interferes with Defender’s\nability to scan and block the PUP.\n\nExamining system activity during the demo, we can see Defender initially attempting to\nopen the payload executable to scan it, but failing because the file is in a delete-pending\nstate. Later attempts to open it fail because the file has already been deleted. The payload\n(ghost.exe) executes without issue.\n\n\n-----\n\n### Detection\n\n[Elastic Security detects a variety of process image tampering techniques including](https://www.elastic.co/security)\nDoppelgänging, Herpaderping, and Ghosting. It does this by checking the FILE_OBJECT\nfor abnormalities during the process creation callback. These are reported in process\ncreation events under process.Ext.defense_evasions.\n\n## Comparing techniques\n\n[Building upon a useful table from the Process Herpaderping documentation, we can](https://github.com/jxy-s/herpaderping#comparison)\ncompare the basic API flow across the various techniques:\n\nType Technique\n\nHollowing map -> modify section -> execute\n\n\n-----\n\nDoppelgänging transact -> write -> map -> rollback -> execute\n\nHerpaderping write -> map -> modify -> execute -> close\n\nGhosting delete pending -> write -> map -> close(delete) -> execute\n\n## Conclusion\n\nIn this blog, we surveyed the state of the art in Windows executable image tampering\nattacks, then disclosed a new such attack. We then demonstrated this attack bypassing\ncommon security software, and showed how to detect it using freely available software.\n\nTo find threats like process tampering in your environment, install the latest version of\n[Elastic Security on Elastic Cloud, and be sure to take advantage of our quick start training](https://www.elastic.co/security)\nto set yourself up for success. Happy hunting!\n\n**_[Responsible disclosure: We filed a bug report with MSRC on 2021-05-06, including a](https://msrc.microsoft.com/)_**\n_draft of this blog post, a demonstration video, and source code for a PoC. They responded_\n_on 2021-05-10 indicating that this does not meet their bar for servicing, per_\n_[https://aka.ms/windowscriteria.](https://aka.ms/windowscriteria)_\n\n## References\n\n1. With some exceptions, such as the System and Registry processes.\n\n2. These examples are pseudocode.\n\n3. [https://go.microsoft.com/fwlink/?LinkId=140636 Page 32, \"File Deletion Semantics\"](https://go.microsoft.com/fwlink/?LinkId=140636)\n\n**We're hiring**\n\nWork for a global, distributed team where finding someone like you is just a Zoom\nmeeting away. Flexible work with impact? Development opportunities from the start?\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-06-15 - What you need to know about Process Ghosting, a new executable image tampering attack.pdf"
    ],
    "report_names": [
        "2021-06-15 - What you need to know about Process Ghosting, a new executable image tampering attack.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535967,
    "ts_updated_at": 1743041127,
    "ts_creation_date": 1653714475,
    "ts_modification_date": 1653714475,
    "files": {
        "pdf": "https://archive.orkl.eu/b4b06c82271490b7bf844c7d4b4d2ef598811550.pdf",
        "text": "https://archive.orkl.eu/b4b06c82271490b7bf844c7d4b4d2ef598811550.txt",
        "img": "https://archive.orkl.eu/b4b06c82271490b7bf844c7d4b4d2ef598811550.jpg"
    }
}