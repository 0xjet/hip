{
    "id": "d89e7f33-a94c-4408-8ead-fd8d549c3f46",
    "created_at": "2022-10-25T16:48:15.222087Z",
    "updated_at": "2025-03-27T02:16:25.959296Z",
    "deleted_at": null,
    "sha1_hash": "353ff92759248416c3a3a5cd980b5deb43a86c5c",
    "title": "",
    "authors": "",
    "file_creation_date": "2013-03-05T12:11:18Z",
    "file_modification_date": "2013-03-05T12:11:18Z",
    "file_size": 143454,
    "plain_text": "# DroidChameleon: Evaluating Android Anti-malware against Transformation Attacks\n\n## Vaibhav Rastogi, Yan Chen, and Xuxian Jiang[†]\n\n### Northwestern University, [†]North Carolina State University vrastogi@u.northwestern.edu, ychen@northwestern.edu, jiang@cs.ncsu.edu\n\n\n## ABSTRACT\n\nMobile malware threats (e.g., on Android) have recently become a\nreal concern. In this paper, we evaluate the state-of-the-art commercial mobile anti-malware products for Android and test how\nresistant they are against various common obfuscation techniques\n(even with known malware). Such an evaluation is important for\nnot only measuring the available defense against mobile malware\nthreats but also proposing effective, next-generation solutions. We\ndeveloped DroidChameleon, a systematic framework with various\ntransformation techniques, and used it for our study. Our results on\nten popular commercial anti-malware applications for Android are\nworrisome: none of these tools is resistant against common malware transformation techniques. Moreover, the transformations are\nsimple in most cases and anti-malware tools make little effort to\nprovide transformation-resilient detection. Finally, in the light of\nour results, we propose possible remedies for improving the current state of malware detection on mobile devices.\n\n## Categories and Subject Descriptors\n\nD.4.6 [Operating Systems]: Security and Protection—Invasive soft_ware (e.g., viruses, worms, Trojan horses)_\n\n## General Terms\n\nSecurity\n\n## Keywords\n\nMobile; malware; anti-malware; Android\n\n## 1. INTRODUCTION\nMobile computing devices such as smartphones and tablets are\nbecoming increasingly popular. Unfortunately, this popularity attracts malware authors too. It has been reported that on Android,\nthe most popular smartphone platform [11], malware has constantly\nbeen on the rise [13]. With the growth of malware, the platform has\nalso seen an evolution of anti-malware tools, with a range of free\nand paid offerings now available in the official Android app market,\nGoogle Play.\nIn this paper, we aim to evaluate the efficacy of anti-malware\ntools on Android in the face of various evasion techniques. For\n\nPermission to make digital or hard copies of all or part of this work for\npersonal or classroom use is granted without fee provided that copies are\nnot made or distributed for profit or commercial advantage and that copies\nbear this notice and the full citation on the first page. To copy otherwise, to\nrepublish, to post on servers or to redistribute to lists, requires prior specific\npermission and/or a fee.\n_ASIA CCS’13, May 8–10, 2013, Hangzhou, China._\nCopyright 2013 ACM 978-1-4503-1767-2/13/05 ...$15.00.\n\n\nexample, polymorphism is used to evade detection tools by transforming a malware in different forms (“morphs”) but with the same\ncode. Metamorphism is another common technique that can mutate\ncode so that it no longer remains the same but still has the same behavior. For ease of presentation, we use the term polymorphism in\nthis paper to represent both obfuscation techniques. In addition, we\nuse the term ‘transformation’ broadly, to refer to various polymorphic or metamorphic changes.\nPolymorphic attacks have long been a plague for traditional desktop and server systems. While there exist earlier studies on the effectiveness of anti-malware tools on PCs [8], our domain of study\nis different in that we exclusively focus on mobile devices like\nsmartphones, which require different ways for anti-malware design. Also, malware on mobile devices have recently escalated\ntheir evolution but the capabilities of existing anti-malware tools\nare largely not yet understood. In the meantime, simple forms of\npolymorphic attacks have already been seen in the wild [26].\nTo evaluate existing anti-malware software, we develop a systematic framework called DroidChameleon with several common\ntransformation techniques that may be used to transform Android\napplications automatically. Some of these transformations are highly\nspecific to the Android platform only. Based on the framework,\nwe pass known malware samples (from different families) through\nthese transformations to generate new variants of malware, which\nare verified to possess the originals’ malicious functionality. We\nuse these variants to evaluate the effectiveness and robustness of\npopular anti-malware tools.\nOur results on ten popular anti-malware products, some of which\neven claim resistance against malware transformations, show that\nall the anti-malware products used in our study have little protection against common transformation techniques. Our results also\ngive insights about detection models used in existing anti-malware\nand their capabilities, thus shedding light on possible ways for their\nimprovements. We hope that our findings work as a wake-up call\nand motivation for the community to improve the current state of\nmobile malware detection.\nTo summarize, this paper makes the following contributions.\n\n_• We systematically evaluate anti-malware products for Android_\nregarding their resistance against various transformation techniques in known malware. For this purpose, we developed DroidChameleon, a systematic framework with various transformation techniques to facilitate anti-malware evaluation.\n\n_• We have implemented a prototype of DroidChameleon and used_\nit to evaluate ten popular anti-malware products for Android.\nOur findings show that all of them are vulnerable to common\nevasion techniques. Moreover, we find that 90% of the signatures studied do not require static analysis of bytecode.\n\n_• Based on our evaluation results, we also explore possible ways_\nto improve current anti-malware solutions. Specifically, we point\n\n\n-----\n\nout that Android eases developing advanced detection techniques\nbecause much code is high-level bytecodes rather than native\ncodes. Furthermore, certain platform support can be enlisted to\ncope with advanced transformations.\n\n## 2. BACKGROUND\nAndroid is an operating system for mobile devices such as smartphones and tablets. It is based on the Linux kernel and provides a\nmiddleware implementing subsystems such as telephony, window\nmanagement, management of communication with and between\napplications, managing application lifecycle, and so on.\nApplications are programmed primarily in Java though the programmers are allowed to do native programming via JNI (Java native interface). Instead of running Java bytecode, Android runs\nDalvik bytecode, which is produced from Java bytecode. In Dalvik,\ninstead of having multiple .class files as in the case of Java, all\nthe classes are packed together in a single .dex file.\nAndroid applications are made of four types of components, namely\nactivities, services, broadcast receivers, and content providers. These\napplication components are implemented as classes in application\ncode and are declared in the AndroidManifest (see next paragraph).\nThe Android middleware interacts with the application through these\ncomponents.\nAndroid application packages are jar files containing the application bytecode as a classes.dex file, any native code libraries,\napplication resources such as images, config files and so on, and a\nmanifest, called AndroidManifest. It is a binary XML file, which\ndeclares the application package name, a string that is supposed to\nbe unique to an application, and the different components in the application. It also declares other things (such as application permissions) which are not so relevant to the present work. The AndroidManifest is written in human readable XML and is transformed to\nbinary XML during application build.\nOnly digitally signed applications may be installed on an Android device. Signing keys are usually owned by individual developers and not by a central authority, and there is no chain of trust.\nAll third party applications run unprivileged on Android.\n\n## 3. FRAMEWORK DESIGN\nIn this work, we focus on the evaluation of anti-malware products for Android. Specifically, we attempt to deduce the kind of\nsignatures that these products use to detect malware and how resistant these signatures are against changes in the malware binaries.\nIn this paper, we generally use the term transformation to denote\nsemantics preserving changes to a program. Since we are dealing\nwith malware, we only care about the interested semantics such as\nsending SMS message to a premium number and not things like\nchange of application name in the system logs.\nIn this work, we develop several different kinds of transformations that may be applied to malware samples while preserving their\nmalicious behavior. Each malware sample undergoes one or more\ntransformations and then passes through the anti-malware tools.\nThe detection results are then collected and used to make deductions about the detection strengths of these anti-malware tools.\nWe classify our transformations as trivial (which do not require\ncode level changes or changes to meta-data stored in AndroidManifest), those which result in variants that can still be detected by\nadvanced static analyses involving data-flow and control-flow analysis (DSA), and those which can render malware undetectable by\nstatic analysis (NSA). In the rest of this section, we describe the different kinds of transformations that we have in the DroidChameleon\nframework. Where appropriate we give examples, using original\n\n\nand transformed code. Transformations for Dalvik bytecode are\ngiven in Smali (as in Listing 1), an intuitive assembly language for\nDalvik bytecode.\n\nconst-string v10, \"profile\"\nconst-string v11, \"mount -o remount rw system\\nexit\\n\"\ninvoke-static {v10, v11}, Lcom/android/root/Setting;->\n\nrunRootCommand(Ljava/lang/String;Ljava/lang/String;)\nLjava/lang/String;\nmove-result-object v7\n\nListing 1: A code fragment from DroidDream malware\n\n## 3.1 Trivial Transformations\nTrivial transformations do not require code-level changes or changes\nto meta-data stored in AndroidManifest. These transformations are\nmeant to defeat signatures based on whole files (or a part of file\nthat changes simply by reorganizing file sections) or the key used\nto sign an application package. We have the following two transformations for this purpose.\n**Repacking. Recall that Android packages are signed jar files. These**\nmay be unzipped with the regular zip utilities and then repacked\nagain with tools offered in the Android SDK. Once repacked, applications are signed with custom keys (the original developer keys\nare not available). Detection signatures that match the developer\nkeys or a checksum of the entire application package are rendered\nineffective by this transformation. Note that this transformation applies to Android applications only; there is no counterpart in general on traditional Desktop operating systems although the malware\nin the latter are known to use sophisticated packers for the purpose\nof evading anti-malware tools.\n**Disassembling and Reassembling. The compiled Dalvik byte-**\ncode in classes.dex of the application package may be disassembled and then reassembled back again. The various items in a\ndex file may be arranged or represented in different ways and thus a\ncompiled program may be represented in more than one form. Signatures that match the whole classes.dex are beaten by this\ntransformation. Signatures that depend on the order of different\nitems in the dex file will also likely break with this transformation.\nSimilar assembling/disassembling also applies to the resources in\nan Android package and to the conversion of AndroidManifest between binary and human readable formats.\n\n## 3.2 Transformation Attacks Detectable by Static Analysis (DSA)\nThe application of DSA transformations does not break all types\nof static analysis. Specifically, forms of analysis that describe the\nsemantics, such as data flows are still possible. Only simpler checks\nsuch as string matching or matching API calls may be thwarted.\n**Changing Package Name. Every application is identified by a**\npackage name unique to the application. This name is defined in\nthe package’s AndroidManifest. We change the package name in a\ngiven malicious application to another name.\n**Identifier Renaming. Most class, method, and field identifiers in**\nbytecode can be renamed. We note that several free obfuscation\ntools such as ProGuard [5] provide identifier renaming. Listing 2\npresents an example transformation for code in Listing 1.\n\nconst-string v10, \"profile\"\nconst-string v11, \"mount -o remount rw system\\nexit\\n\"\ninvoke-static {v10, v11}, Lcom/hxbvgH/IWNcZs/jFAbKo;->\n\naxDnBL(Ljava/lang/String;Ljava/lang/String;)Ljava/\nlang/String;\nmove-result-object v7\n\nListing 2: Code in Listing 1 after identifier renaming\n\n\n-----\n\n**Data Encryption. The dex files contain all the strings and array**\ndata that have been used in the code. These strings and arrays may\nbe used to develop signatures against malware. To beat such signatures we can keep these in encrypted form. Listing 3 shows code in\nListing 1, transformed by string encryption.\n\nconst-string v10, \"qspgjmf\"\ninvoke-static {v10}, Lcom/EncryptString;->applyCaesar(\n\nLjava/lang/String;)Ljava/lang/String;\nmove-result-object v10\nconst-string v11, \"npvou!.p!sfnpvou!sx!tztufn]ofyju]o\"\ninvoke-static {v11}, Lcom/EncryptString;->applyCaesar(\n\nLjava/lang/String;)Ljava/lang/String;\nmove-result-object v11\ninvoke-static {v10, v11}, Lcom/android/root/Setting;->\n\nrunRootCommand(Ljava/lang/String;Ljava/lang/String;)\nLjava/lang/String;\nmove-result-object v7\n\nListing 3: Code in Listing 1 after string encryption. Strings are encoded\nwith a Caesar cipher of shift +1.\n\n**Call Indirections. This transformation can be seen as a simple**\nway to manipulate call graph of the application to defeat automatic\nmatching. Given a method call, the call is converted to a call to\na previously non-existing method that then calls the method in the\noriginal call. This can be done for all calls, those going out into\nframework libraries as well as those within the application code.\nThis transformation may be seen as trivial function outlining (see\nfunction outlining below).\n**Code Reordering. Code reordering reorders the instructions in**\nthe methods of a program. This transformation is accomplished by\nreordering the instructions and inserting goto instructions to preserve the runtime execution sequence of the instructions. Listing 4\nshows an example reordering.\n\ngoto :i_1\n:i_3\ninvoke-static {v10, v11}, Lcom/android/root/Setting;->\n\nrunRootCommand(Ljava/lang/String;Ljava/lang/String;)\nLjava/lang/String;\nmove-result-object v7\ngoto :i_4 # next instruction\n:i_2\nconst-string v11, \"mount -o remount rw system\\nexit\\n\"\ngoto :i_3\n:i_1\nconst-string v10, \"profile\"\ngoto :i_2\n\nListing 4: Code in Listing 1 reverse ordered\n\n**Junk Code Insertion. These transformations introduce code se-**\nquences that are executed but do not affect rest of the program. Detection based on analyzing instruction (or opcode) sequences may\nbe defeated by junk code insertion. Junk code may constitute simple nop sequences or more sophisticated sequences and branches\nthat actually have no effect on the semantics.\n**Encrypting Payloads and Native Exploits. In Android, native**\ncode is usually made available as libraries accessed via JNI. However, some malware such as DroidDream also pack native code exploits meant to run from a command line in non-standard locations\nin the application package. All such files may be stored encrypted\nin the application package and be decrypted at runtime. Certain\nmalware such as DroidDream also carry payload applications that\nare installed once the system has been compromised. These payloads may also be stored encrypted. We categorize payload and exploit encryption as DSA because signature based static detection is\nstill possible based on the main application’s bytecode. These are\neasily implemented and have been seen in practice as well (e.g.,\nDroidKungFu malware uses encrypted exploit).\n\n\n**Function Outlining and Inlining. In function outlining, a func-**\ntion is broken down into several smaller functions. Function inlining involves replacing a function call with the entire function body.\nThese are typical compiler optimization techniques. However, outlining and inlining can be used for call graph obfuscation also.\n**Other Simple Transformations. There are a few other transfor-**\nmations as well, specific to Android. Debug information, such as\nsource file names, local and parameter variable names, and source\nline numbers may be stripped off. Moreover, non-code files and\nresources contained in Android packages may be renamed or modified.\n**Composite Transformations. Any of the above transformations**\nmay be combined with one another to generate stronger obfuscations. While compositions are not commutative, anti-malware\ndetection results should be agnostic to the order of application of\ntransformations for the cases discussed above.\n\n## 3.3 Transformation Attacks Non-Detectable by Static Analysis (NSA)\nThese transformations can break all kinds of static analysis. Some\nencoding or encryption is typically required so that no static analysis scheme can infer parts of the code. Parts of the encryption keys\nmay even be fetched remotely. In this scenario, interpreting or emulating the code (i.e., dynamic analysis) is still possible but static\nanalysis becomes infeasible.\n**Reflection. The Java reflection API allows a program to invoke a**\nmethod by using the name of the methods. We can convert any\nmethod call into a call to that method via reflection. This makes\nit difficult to analyze statically which method is being called. A\nsubsequent encryption of the method name can make it impossible\nfor any static analysis to recover the call.\n**Bytecode encryption. Code encryption tries to make the code un-**\navailable for static analysis. The relevant piece of the application\ncode is stored in an encrypted form and is decrypted at runtime\nvia a decryption routine. Code encryption has long been used in\npolymorphic viruses; the only code available to signature based\nantivirus applications remains the decryption routine, which is typically obfuscated. To accomplish this the majority of the malware\ncode may be stored in an encrypted dex file that is decrypted and\nloaded dynamically through a user-defined class loader.\n\n## 4. IMPLEMENTATION\nApart from function outlining and inlining, we applied all other\nDroidChameleon transformations to the malware samples. We have\nimplemented most of the transformations so that they may be applied automatically to the application. Automation implies that the\nmalware authors can generate polymorphic malware at a very fast\npace.\nWe utilize the Smali/Baksmali [6] and its companion tool Apktool [1] for our implementation. Our code-level transformations\nare implemented over Smali. Moreover, disassembling and assembling transformation uses Apktool. This has the effect of repacking,\nchanging the order and representation of items in the classes.dex\nfile, and changing the AndroidManifest (while preserving the semantics of it). All other transformations in our implementation\n(apart from repacking) make use of Apktool to unpack/repack application packages.\n\n## 5. RESULTS\nWe begin by describing our anti-malware and malware dataset,\nfollowed by our methodology, and then discuss our findings. We\n\n\n-----\n\nTable 1: Anti-malware products evaluated. All tools collected in February 2013.\n\n**Vendor** **Product** **Package name** **Version** **# downloads**\nAVG Antivirus Free com.antivirus 3.1 50M-100M\nSymantec Norton Mobile Security com.symantec.mobilesecurity 3.3.0.892 5M-10M\nLookout Lookout Mobile Security com.lookout 8.7.1-EDC6DFS 10M-50M\nESET ESET Mobile Security com.eset.ems 1.1.995.1221 500K-1M\nDr. Web Dr. Web anti-virus Light com.drweb 7.00.3 10M-50M\nKaspersky Kaspersky Mobile Security com.kms 9.36.28 1M-5M\nTrend micro Mobile Security Personal Ed. com.trendmicro.tmmspersonal 2.6.2 100K-500K\nESTSoft ALYac Android com.estsoft.alyac 1.3.5.2 5M-10M\nZoner Zoner Antivirus Free com.zoner.android.antivirus 1.7.2 1M-5M\nWebroot Webroot Security & Antivirus com.webroot.security 3.1.0.4547 500K-1M\n\nTable 2: Malware samples used for testing anti-malware tools\n\n**Family** **Package name** **SHA-1 code** **Date found** **Remarks**\n\ncom.droiddream. bowling- 72adcf43e5f945ca9f72\nDroidDream 03/2011 Root exploit\ntime 064b81dc0062007f0fbf\n\n1317d996682f4ae4cce6 Information exfiltration; bot-like\nGeinimi com.sgg.spp 10/2011\n0d90c43fe3e674f60c22 capabilities\n\norg.me.androidappli- 1e993b0632d5bc6f0741\nFakeplayer 08/2010 SMS trojan\ncation1 0ee31e41dd316435d997\n\ncom.android.vending. sec- bc2dedad0507a916604f Information exfiltration; bot-like\nBgserv 03/2011\ntool.v1 86167a9fa306939e2080 capabilities; SMS trojan\n\n508353d18cb9f5544b1e Root exploit; SMS trojan packed\nBaseBridge com.keji.unclear 05/2011\nd1cf7ef8a0b6a5552414 as payload\n\ncom.crazyapps.angry. bee2661a4e4b347b5cd2\nPlankton 06/2011 Dynamic code loading\nbirds.rio.unlocker a58f7c4b17bcc3efd550\n\nTable 3: Key to Table 4. Transformations coded with\n\nMalware\nsample single letters are trivial transformations. All others are\n\nDSA. We did not need NSA transformations to thwart\nanti-malware tools.\n\n\nStop\n\nIf all transformations done\ngo to B else continue on A\n\n_No_ Stop after getting\n\nall results on B\n\nIf all transformations done\ngo to C else continue on B\n\n_No_\n\nStop\n\nFail\n\n\nCode Technique\n\nP Repack\nA Dissassemble & assemble\nRP Rename package\nEE Encrypt native exploit or payload\nRI Rename identifiers\nRF Rename files\nED Encrypt strings and array data\nCR Reorder code\nCI Call indirection\nJN Insert junk code\n\nAll transformations contain P\nAll transformations except P contain A\n\n\nFigure 1: Evaluating anti-malware\n\nevaluated ten anti-malware tools, which are listed in Table 1. We\nselected the most popular products; in addition, we included Kaspersky, ESET, and Trend Micro, which were then not very popular but\nare well established vendors in the security industry. We had to\nomit a couple of products in the most popular list because they\nwould fail to identify many original, unmodified malware samples\nwe tested. All the products were downloaded directly from the official Android app market, Google Play, in February 2013.\nOur malware set is summarized in Table 2. We used a few criteria\nfor choosing malware samples. First, all the anti-malware tools being evaluated should detect the original samples. Second, the malware samples should be sufficiently old so that signatures against\nthem are well stabilized. All the samples in our set were discovered\nin or before October 2011. All the samples are publicly available\non Contagio Minidump [22]. Finally, as seen in the table, the set\nspans over multiple malware kinds, from root exploits to information stealing.\nAs has already been discussed, we transform malware samples\nusing various techniques discussed in Section 3 and pass them through\nanti-malware tools we evaluate. Our methodology is depicted in\nFigure 1. For every malware-antimalware pair, we begin testing\nwith trivial transformations and then proceed with transformations\n\n\nthat are more complex. Each transformation is applied to a malware sample (of course, some like exploit encryption apply only in\ncertain cases) and the transformed sample is passed through antimalware. If detection breaks with trivial transformations, we stop\n(all DSA and NSA transformations also result in trivial transformations). Next, we apply all the DSA transformations. If detection\nstill does not break, we apply combinations of DSA transformations. In general there is no well-defined order in which transformations should be applied (in some cases a heuristic works; for\nexample, malware that include native exploits are likely to be detected based on those exploits). Fortunately, in our study, we did\nnot need to apply combinations of more than two transformations to\nbreak detection. When applying combinations of transformations,\nwe stopped when detection broke.\nOur results with all the malware samples are summarized in Table 4. This table gives the minimal transformations necessary to\nevade detection for malware-anti-malware pairs. For example, DroidDream requires both exploit encryption and call indirection to evade\nDr. Web’s detection. These minimal transformations also give insight into what kind of detection signatures are being used. We next\ndescribe our key findings in the light of the detection results.\n\n\n-----\n\nTable 4: Evaluation summary. Please see Table 3 for key. ‘+’ indicates the composition of two transformations.\n\nDroidDream Geinimi Fakeplayer Bgserv BaseBridge Plankton\nAVG RP RI RP + RI RI RI RP + RI\nSymantec RI RI RP + RI RI + ED ED P\nLookout P RI + ED RP + RI RI + ED EE + ED RI\nESET RI + EE ED RI RI EE + ED RI + ED\nDr. Web EE + CI CI CI CI EE + CI CI\nKaspersky EE + ED RI RI RI + ED EE + ED A\nTrend M. EE + RF RI A A EE + RF A\nESTSoft RP RP RP RP RP RP\nZoner A RI A A A RI\nWebroot RI RI RP RI RP RI\n\n\n**Finding 1 All the studied anti-malware products are vulnera-**\n_ble to common transformations. All the transformations appear-_\ning in Table 4 are easy to develop and apply, redefine only certain syntactic properties of the malware, and are common ways\nto transform malware. Transformations like identifier renaming\nand data encryption are easily available using free and commercial tools [4, 5]. Exploit and payload encryption is also easy to\nachieve. Such transformations may already be seen in the wild in\ncurrent malware, e.g., Geinimi variants have encrypted strings [19]\nand DroidKungFu malware uses encrypted exploit code [3].\nWe found that only Dr. Web uses a somewhat more sophisticated\nalgorithm for detection. Our findings indicate that the general detection scheme of Dr. Web is as follows. The set of method calls\nfrom every method is obtained. These sets are then used as signatures and the detection phase consists of matching these sets against\nsets obtained from the sample under test.\n**Finding 2 At least 43% signatures are not based on code-level**\n_artifacts. That is, these are based on file names, checksums (or_\nbinary sequences) or information easily obtained by the PackageManager API. We also found all AVG signatures to be derived from\nthe content of AndroidManifest only (and hence that of the PackageManager API). Changing component names in AndroidManifest while keeping the code same was sufficient to break AVG’s\ndetection.\n**Finding 3 90% of signatures do not require static analysis of**\n_bytecode. Only one of ten anti-malware tools was found to be us-_\n_ing static analysis._ Names of classes, methods, and fields, and\nall the strings and array data are stored in the classes.dex file\nas they are and hence can be obtained by content matching. The\nonly signatures requiring static analysis of bytecode are those of\nDr. Web because it extracts API calls made in various methods.\n\n## 6. DEFENSES\n\n 6.1 Semantics-based Malware Detection\nWe point out that owing to the use of bytecodes, which contain high-level structural information, analyses of Android applications becomes much simpler than those of native binaries. Hence,\nsemantics-based detection schemes could prove especially helpful\nin the case of Android. For example, Christodorescu et al. [9] describe a technique for semantics based detection. Their algorithms\nare based on unifying nodes in a given program with nodes in a signature template (nodes may be understood as abstract instructions),\nwhile preserving def-use paths described in the template. Since this\ntechnique is based on data flows rather than a superficial property\nof the program such as certain strings or names of methods being\ndefined or called, it is not vulnerable to any of the transformations\n(all of which are trivial or DSA) that show up in Table 4.\nSemantics-based detection is quite challenging for native codes;\ntheir analyses frequently encounters issues such as missing information on function boundaries, pointer aliasing, and so on [16, 25].\n\n\nBytecodes, on the other hand, preserve much of the source-level\ninformation, thus easing analysis. We therefore believe that antimalware tools have greater incentive to implement semantic analysis techniques on Android bytecodes than they had for developing\nthese for native code.\n\n## 6.2 Support from Platform\nNote that the use of code encryption and reflection (NSA transformations) can still defeat the above scheme. Code encryption\ndoes not leave much visible code on which signatures can be developed. The use of reflection simply hides away the edges in the\ncall graph. If the method names used for reflective invocations are\nencrypted, these edges are rendered completely opaque to static\nanalysis. Furthermore, it is possible to use function outlining to\nthwart any forms of intra-procedural analysis as well. Owing to\nthese limitations, the use of dynamic monitoring is essential.\nRecall that anti-malware tools in Android are unprivileged third\nparty applications. This impedes many different kinds of dynamic\nmonitoring that may enhance malware detection. We believe special platform support for anti-malware applications is essential to\ndetect malware amongst stock Android applications. This can help\nmalware detection in several ways. For example, a common way to\nbreak evasion by code encryption is to scan the memory at runtime.\nThe Android runtime could provide all the classes loaded using\nuser-defined class loaders to the anti-malware application. Once\nthe classes are loaded, they are already decrypted and anti-malware\ntools can analyze them easily.\nGoogle Bouncer performs offline dynamic analysis for malware\ndetection [18]. Such scanning however has its own problems, ranging from detection of the dynamic environment to the malicious activity not getting triggered in the limited time for which the analysis\nruns; Bouncer is no exception to this [21, 27]. We therefore believe\noffline emulation must be supplemented by strong static analysis or\nreal-time dynamic monitoring.\n\n## 7. RELATED WORK\n\n**Evaluating Anti-malware Tools. Zheng et al. [28] also studied**\nthe robustness of anti-malware against Android malware recently.\nThey implement a subset of our transformations, use them to generate several malware variants, and test these on VirusTotal, a webservice that tests submitted samples against over 40 anti-virus products. Their results however only show the change in overall detection percentages as the transformations are applied. Our results are\nmuch stronger in that we can show that all anti-malware tools actually succumb for all malware samples tested. Moreover, we also\ndeduce the weaknesses and strengths of some of the products.\nChristodorescu and Jha [8] conducted a study similar to ours on\ndesktop anti-malware applications nine years ago. They also arrived at the conclusion that these applications have low resilience\nagainst malware obfuscation. Our study is based on Android antimalware, and we include several aspects in our study that are unique\n\n\n-----\n\nto Android. Furthermore, our study comes after much research on\nobfuscation resilient detection, and we would expect the proposed\ntechniques to be readily integrated into new commercial products.\nFinally, our study is orthogonal to studies about completeness of\ndetection of anti-malware tools such as those by AV-Test.org [2].\n**Obfuscation Techniques. Collberg et al. [12] review and propose**\ndifferent types of obfuscations. DroidChameleon provides only a\nfew of the transformations proposed by them. Nonetheless, the set\nof transformations provided in DroidChameleon is comprehensive\nin the sense that they can break typical static detection techniques\nused by anti-malware. Off-the-shelf tools like Proguard [5] and\nKlassmaster [4] provide renaming of classes and class members,\nflow obfuscation, and string encryption. While the goal of these\ntools is to evade manual reverse engineering, we aim at thwarting\nanalysis by automatic tools.\n**Obfuscated Malware Detection. Obfuscation resilient detection**\nis based on semantics rather than syntac. As discussed earlier,\nChristodorescu et al. [9] present one such technique. Christodorescu et al. [10] and Fredrikson et al. [14] attempt to generate semantics based signatures by mining malicious behavior automatically. Kolbitsch et al. [17] also propose similar techniques. The\nlast three works are for behavior-based detection and use different\nbehavior representations such as data dependence graphs and information flows between system calls. Due to lower privileges for\nanti-malware tools on Android, these approaches cannot directly\napply to these tools presently.\n**Smartphone Malware Research. Many works have been done**\ntowards discovery and characterization of smartphone malware [7,\n15, 20, 23, 24, 29, 30]. Our work is distinct from these as we try to\nevaluate the efficacy of existing tools against transformed malware.\n\n## 8. CONCLUSION\nWe evaluated ten anti-malware products on Android for their\nresilience against malware transformations. To facilitate this, we\ndeveloped DroidChameleon, a systematic framework with various\ntransformation techniques. Our findings show that all the antimalware products evaluated are susceptible to common evasion\ntechniques. Finally, we explored possible ways to improve the current situation and develop next-generation solutions.\nWe refer the interested readers to http://list.cs.northwestern.edu/mobile\nfor further information about this work, such as more detailed technical reports.\n\n## References\n\n[1] Android-apktool: A tool for reengineering Android apk files.\nhttp://code.google.com/p/android-apktool/.\n\n[2] Test: Malware Protection for Android, March 2012.\nhttp://www.av-test.org/en/tests/android/.\n\n[3] DroidKungFu. http://www.csc.ncsu.edu/faculty/jiang/DroidKungFu.html.\n\n[4] Zelix Klassmaster. http://www.zelix.com/klassmaster/.\n\n[5] ProGuard. http://proguard.sourceforge.net/.\n\n[6] Smali: An assembler/disassembler for Android’s dex format\n. http://code.google.com/p/smali/.\n\n[7] I. Burguera, U. Zurutuza, and S. Nadjm-Tehrani. Crowdroid:\nbehavior-based malware detection system for android. In\n_Proceedings of the 1st ACM workshop on Security and_\n_privacy in smartphones and mobile devices, 2011._\n\n[8] M. Christodorescu and S. Jha. Testing malware detectors. In\n_Proceedings of the ACM SIGSOFT international symposium_\n_on Software testing and analysis, 2004._\n\n[9] M. Christodorescu, S. Jha, S. Seshia, D. Song, and\nR. Bryant. Semantics-aware malware detection. In Security\n_and Privacy, 2005 IEEE Symposium on, 2005._\n\n\n\n[10] M. Christodorescu, S. Jha, and C. Kruegel. Mining\nspecifications of malicious behavior. In Proceedings of the\n_the 6th ACM ESEC-FSE, 2007._\n\n[11] CNET, February 2013. http://news.cnet.com/8301-1035_3-5756940294/android-ios-combine-for-91-percent-of-market/.\n\n[12] C. Collberg, C. Thomborson, and D. Low. A taxonomy of\nobfuscating transformations. Technical report, Department\nof Computer Science, The University of Auckland, New\nZealand, 1997.\n\n[13] F-Secure. Mobile Threat Report Q3 2012.\nhttp://www.f-secure.com/static/doc/labs_global/Research/Mobile%20Threat%\n20Report%20Q3%202012.pdf.\n\n[14] M. Fredrikson, S. Jha, M. Christodorescu, R. Sailer, and\nX. Yan. Synthesizing near-optimal malware specifications\nfrom suspicious behaviors. In Security and Privacy (SP),\n_2010 IEEE Symposium on, 2010._\n\n[15] M. Grace, Y. Zhou, Q. Zhang, S. Zou, and X. Jiang.\nRiskranker: scalable and accurate zero-day android malware\ndetection. In Proceedings of the 10th international\n_conference on Mobile systems, applications, and services,_\nMobiSys ’12, 2012.\n\n[16] L. Harris and B. Miller. Practical analysis of stripped binary\ncode. ACM SIGARCH Computer Architecture News, 33(5):\n63–68, 2005.\n\n[17] C. Kolbitsch, P. Comparetti, C. Kruegel, E. Kirda, X. Zhou,\nand X. Wang. Effective and efficient malware detection at\nthe end host. In Proceedings of the 18th conference on\n_USENIX security symposium, 2009._\n\n[18] H. Lockheimer. Android and security, February 2012.\nhttp://googlemobile.blogspot.com/2012/02/android-and-security.html.\n\n[19] Lookout. Geinimi Trojan Technical Analysis. http:\n//blog.mylookout.com/blog/2011/01/07/geinimi-trojan-technical-analysis/.\n\n[20] Y. Nadji, J. Giffin, and P. Traynor. Automated remote repair\nfor mobile malware. In Proceedings of the 27th Annual\n_Computer Security Applications Conference, 2011._\n\n[21] J. Oberheide. Dissecting android’s bouncer, June 2012.\nhttps://blog.duosecurity.com/2012/06/dissecting-androids-bouncer/.\n\n[22] M. Parkour. Contagio Mobile. Mobile Malware Mini Dump.\nhttp://contagiominidump.blogspot.com/.\n\n[23] H. Peng, C. Gates, B. Sarma, N. Li, Y. Qi, R. Potharaju,\nC. Nita-Rotaru, and I. Molloy. Using probabilistic generative\nmodels for ranking risks of android apps. In Proceedings of\n_the 2012 ACM conference on Computer and communications_\n_security, 2012._\n\n[24] V. Rastogi, Y. Chen, and W. Enck. AppsPlayground:\nAutomatic Security Analysis of Smartphone Applications. In\n_Proceedings of ACM CODASPY 2013, February 2013._\n\n[25] P. Saxena, R. Sekar, and V. Puranik. Efficient fine-grained\nbinary instrumentationwith applications to taint-tracking. In\n_Proceedings of the 6th annual IEEE/ACM international_\n_symposium on Code generation and optimization, 2008._\n\n[26] Symantec. Server-side Polymorphic Android Applications.\nhttp://www.symantec.com/connect/blogs/server-side-polymorphic-androidapplications.\n\n[27] R. Whitwam. Circumventing Google’s Bouncer, Android’s\nanti-malware system, June 2012.\nhttp://www.extremetech.com/computing/130424-circumventing-googlesbouncer-androids-anti-malware-system.\n\n[28] M. Zheng, P. Lee, and J. Lui. Adam: An automatic and\nextensible platform to stress test android anti-virus systems.\n_DIMVA, July 2012._\n\n[29] Y. Zhou and X. Jiang. Dissecting android malware:\nCharacterization and evolution. Security and Privacy, IEEE\n_Symposium on, 2012._\n\n[30] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang. Hey, you, get off\nof my market: Detecting malicious apps in official and\nalternative android markets. In Proceedings of the 19th\n_Network and Distributed System Security Symposium, 2012._\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "http://pages.cs.wisc.edu/~vrastogi/static/papers/rcj13b.pdf"
    ],
    "report_names": [
        "rcj13b.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1666716495,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1362485478,
    "ts_modification_date": 1362485478,
    "files": {
        "pdf": "https://archive.orkl.eu/353ff92759248416c3a3a5cd980b5deb43a86c5c.pdf",
        "text": "https://archive.orkl.eu/353ff92759248416c3a3a5cd980b5deb43a86c5c.txt",
        "img": "https://archive.orkl.eu/353ff92759248416c3a3a5cd980b5deb43a86c5c.jpg"
    }
}