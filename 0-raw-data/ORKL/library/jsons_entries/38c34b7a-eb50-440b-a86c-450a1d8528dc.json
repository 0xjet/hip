{
    "id": "38c34b7a-eb50-440b-a86c-450a1d8528dc",
    "created_at": "2023-01-12T15:00:01.767782Z",
    "updated_at": "2025-03-27T02:09:18.690385Z",
    "deleted_at": null,
    "sha1_hash": "3f39b3988988397d872c04e9009bd6b32145bf54",
    "title": "2021-09-06 - Quick analysis CobaltStrike loader and shellcode",
    "authors": "",
    "file_creation_date": "2022-05-28T15:23:43Z",
    "file_modification_date": "2022-05-28T15:23:43Z",
    "file_size": 519309,
    "plain_text": "# Quick analysis CobaltStrike loader and shellcode\n\n**[kienmanowar.wordpress.com/2021/09/06/quick-analysis-cobaltstrike-loader-and-shellcode/](https://kienmanowar.wordpress.com/2021/09/06/quick-analysis-cobaltstrike-loader-and-shellcode/)**\n\nSeptember 6, 2021\n\n## I saw this hash\n\n### 2569cc660d2ae0102aa74c98d78bb9409ded24101a0eeec15af29d59917265f3 shared at\n## malwareresearchgroup.slack.com. It was submitted to VT at 2021-09-01 19:47:50 and 37 security vendors flagged this file as malicious.\n\n1. Analyze loader\n\n## This loader is 64-bit Dll, compiled by MinGW and has one exported function:\n\n With the help of IDA, we can see the ServiceMain function will spawn a new thread (I renamed to f_spawn_shellcode_thread ):\n\n The f_spawn_shellcode_thread function does the following tasks:\n\n Init xor_key is “ jKfXmEkWYshKkZdPhJYS ” Allocate heap buffer for storing encrypted shellcode bytes and assign values to this buffer based on the global byte array has been declared from the beginning.\n\n\n-----\n\n## Peform loop to decode the shellcode. Spawn new thread to execute the decoded shellcode.\n\n I wrote a short script to do shellcode extraction for later analysis:\n\n\n-----\n\n```\nimport sys\nimport pefile\nxor_key = \"jKfXmEkWYshKkZdPhJYS\"\ndef decode_sc(data, key):\n  key_len = len(key)\n  data_len = len(data)\n  decrypted = bytearray(data_len) \n  for i in range(0, data_len):\n    decrypted[i] = data[i] ^ key[i%key_len]\n  print(\"Decode Done!\")\n  return decrypted\ndef extract_sc(input_file):\n  encrypted_sc = []\n  try:\n    print(\"\\r\\nFile: \" + input_file)\n    pe = pefile.PE(input_file)\n    for section in pe.sections:\n      if b'.rdata\\x00\\x00' in section.Name:\n        rdata_section = bytearray(section.get_data())\n    size = 0    \n    for i in rdata_section:\n      if rdata_section[size] == 0x00 and rdata_section[size+1] == 0x00:\n        break\n      else:\n        size += 1\n    print(\"Encrypted bytes size: \" + str(size - 24) + \" bytes\")\n    encrypted_bytes = rdata_section[24:size+1]\n    for i in range(len(encrypted_bytes)):\n      if ((i & 1) == 0):\n        encrypted_sc.append(encrypted_bytes[i])\n    key = xor_key.encode('ascii')\n    decrypted_sc = decode_sc(encrypted_sc, key)\n    with open(sys.argv[1]+\"-decrypted\", \"wb\") as out_file:\n      out_file.write(decrypted_sc)\n    print(\"Shellcode extracted at \" + sys.argv[1]+\"-decrypted!\\r\\n\")    \n    print(\"Extract Shellcode Done!\")\n  except Exception as e:\n    print(\"Error: \" + str(e))\nif __name__ == '__main__':\n  if len(sys.argv) == 2:\n    extract_sc(sys.argv[1])\n\n```\n\n-----\n\n```\n  else:\n    print(\"Usage: cobalt_extract_sc.py <cobalt_loader_dll>\")\n\n## After run script, I got the shellcode like the figure bellow:\n\n```\n2. Analyze shellcode\n\n## If we load the raw shellcode into IDA and convert to asm code, it will look like the figure bellow. At the first beginning of this code, we can see the pattern code that shellcode use to locate the fields of PEB structure. This makes me think that it will use PEB to looking up the addresses of the API functions in the Dll used by shelllcode.\n\n\n-----\n\n## Go into sub_D2, the first statement assigns the return address to the rbp register. And we know that this address is 0xA (push r9) . Then we see the string value ‘ wininet ’ is load to r14 register at 0xD5 . We see a value is assigned to the r10 ( 726774Ch;\n\n### 726774Ch ) register and following is a call to the address pointed by the rbp register. At\n## that time, I think these are hash values related to api functions, shellcode will perform calculations to compare with these values from which to get the related API address.\n\n\n-----\n\n## For the convenience of analysis and debugging, I converted the shellcode to an exe. Finally, I got the following pseudocode related to finding the address of the API function and calling API through jmp rax command:\n\n Based on the above pseudocode, we can see that the shellcode will calculate two hash values, the first value is based on the name of the Dll, the second value is based on the name of the API function of that Dll. These two values are added together and compared with the pre-computed hash value.\n\n You can write scripts to recover API functions or to save time, I always use shellcode_hashes_search_plugin.py of FLARE Team. Details can be found in this article. Final result after using the plugin:\n\n\n-----\n\n```\nshellcode_hash: Starting up\n[INFO] Starting up (shellcode_hash_search:run)\nshellcode_hash: Processing current segment only: 0x140001000 - 0x140003000\n[INFO] Processing current segment only: 0x140001000 - 0x140003000\n(shellcode_hash_search:processCode)\nshellcode_hash: 0x1400020e7: ror13AddHash32AddDll:0x0726774c\nkernel32.dll!LoadLibraryA\n[INFO] 0x1400020e7: ror13AddHash32AddDll:0x0726774c kernel32.dll!LoadLibraryA\n(shellcode_hash_search:lookForOpArgs)\nshellcode_hash: 0x1400020ff: ror13AddHash32AddDll:0xa779563a\nwininet.dll!InternetOpenA\n[INFO] 0x1400020ff: ror13AddHash32AddDll:0xa779563a wininet.dll!InternetOpenA\n(shellcode_hash_search:lookForOpArgs)\nshellcode_hash: 0x140002121: ror13AddHash32AddDll:0xc69f8957\nwininet.dll!InternetConnectA\n[INFO] 0x140002121: ror13AddHash32AddDll:0xc69f8957 wininet.dll!InternetConnectA\n(shellcode_hash_search:lookForOpArgs)\nshellcode_hash: 0x140002140: ror13AddHash32AddDll:0x3b2e55eb\nwininet.dll!HttpOpenRequestA\n[INFO] 0x140002140: ror13AddHash32AddDll:0x3b2e55eb wininet.dll!HttpOpenRequestA\n(shellcode_hash_search:lookForOpArgs)\nshellcode_hash: 0x14000216a: ror13AddHash32AddDll:0x869e4675\nwininet.dll!InternetSetOptionA\n[INFO] 0x14000216a: ror13AddHash32AddDll:0x869e4675 wininet.dll!InternetSetOptionA\n(shellcode_hash_search:lookForOpArgs)\nshellcode_hash: 0x140002184: ror13AddHash32AddDll:0x7b18062d\nwininet.dll!HttpSendRequestA\n[INFO] 0x140002184: ror13AddHash32AddDll:0x7b18062d wininet.dll!HttpSendRequestA\n(shellcode_hash_search:lookForOpArgs)\nshellcode_hash: 0x140002329: ror13AddHash32AddDll:0x56a2b5f0 kernel32.dll!ExitProcess\n[INFO] 0x140002329: ror13AddHash32AddDll:0x56a2b5f0 kernel32.dll!ExitProcess\n(shellcode_hash_search:lookForOpArgs)\nshellcode_hash: 0x140002345: ror13AddHash32AddDll:0xe553a458\nkernel32.dll!VirtualAlloc\n[INFO] 0x140002345: ror13AddHash32AddDll:0xe553a458 kernel32.dll!VirtualAlloc\n(shellcode_hash_search:lookForOpArgs)\nshellcode_hash: 0x140002363: ror13AddHash32AddDll:0xe2899612\nwininet.dll!InternetReadFile\n[INFO] 0x140002363: ror13AddHash32AddDll:0xe2899612 wininet.dll!InternetReadFile\n(shellcode_hash_search:lookForOpArgs)\nshellcode_hash: Done\n[INFO] Done (shellcode_hash_search:run)\n\n```\n\n-----\n\n## At this point, we can do debugging for further analysis, however, for quickly I use hasherezade’s tiny_tracer tool to trace the shellcode:\n\n\n-----\n\n## End!\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-09-06 - Quick analysis CobaltStrike loader and shellcode.pdf"
    ],
    "report_names": [
        "2021-09-06 - Quick analysis CobaltStrike loader and shellcode.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535601,
    "ts_updated_at": 1743041358,
    "ts_creation_date": 1653751423,
    "ts_modification_date": 1653751423,
    "files": {
        "pdf": "https://archive.orkl.eu/3f39b3988988397d872c04e9009bd6b32145bf54.pdf",
        "text": "https://archive.orkl.eu/3f39b3988988397d872c04e9009bd6b32145bf54.txt",
        "img": "https://archive.orkl.eu/3f39b3988988397d872c04e9009bd6b32145bf54.jpg"
    }
}