{
    "id": "b2a23943-73ae-48b0-848e-993a05c16637",
    "created_at": "2023-01-12T15:05:20.567103Z",
    "updated_at": "2025-03-27T02:05:25.826689Z",
    "deleted_at": null,
    "sha1_hash": "d49aa03ffe7bd7ffff7eed98c8e4a3e2bedcb997",
    "title": "2020-12-19 - [RE017-2] Phân tích kỹ thuật dòng mã độc mới được sử dụng để tấn công chuỗi cung ứng nhắm vào Ban Cơ yếu Chính phủ Việt Nam của nhóm tin tặc Panda Trung Quốc (Phần 2)",
    "authors": "",
    "file_creation_date": "2022-05-28T16:56:11Z",
    "file_modification_date": "2022-05-28T16:56:11Z",
    "file_size": 2277135,
    "plain_text": "# [RE017-2] Phân tích kỹ thuật dòng mã độc mới được sử dụng để tấn công chuỗi cung ứng nhắm vào Ban Cơ yếu Chính phủ Việt Nam của nhóm tin tặc Panda Trung Quốc (Phần 2)\n\n**blog.vincss.net/2020/12/re017-2-phan-tich-ky-thuat-dong-ma-doc-moi-co-nhieu-dau-hieu-lien-quan-toi-nhom-tin-tac-**\nPanda.html\n\n**Static analysis code của eToken với IDA**\n\nTiếp tục với phần trước, như đã đề cập chúng ta chỉ có RTTI của class type_info, lớp root\ncủa RTTI.\n\n_Hình 1. Thông tin RTTI của class type_info_\n\nPhần phân tích sẽ trình bày chi tiết cách xác định các class, tái tạo code của malware này,\nđồng thời chia sẻ kinh nghiệm áp dụng khi phân tích các malwares/files có dùng MFC.\n\nCác plugin cần dùng:\n\n**ClassInformer của Simabus**\n**HexRaysCodeXplorer của Matrosov**\n**MFC_Helper (tự phát triển)**\n\nMã nguồn C++ của MFC các bạn có thể tìm trong thư mục src\\mfc của bộ cài đặt Visual\nStudio. Do MFC4.2 (MFC của VS6) đã rất cũ nên có thể tìm trên Github. Chúng tôi tham\n[khảo tại đây. Về biểu đồ quan hệ của các class của MFC (Hierarchy Chart), các bạn có thể](https://github.com/dblock/msiext/tree/master/externals/WinDDK/7600.16385.1/inc/mfc42)\n[xem tại đường link này.](https://docs.microsoft.com/en-us/cpp/mfc/hierarchy-chart?view=msvc-160)\n\nBa file dlls quan trọng để diffing/compare với các malware dùng MFC, ví dụ trong mẫu\n**eToken này, là mfc42.dll, mfc42d.dll, mfco42d.dll. Các bạn tìm và tải luôn cả debug**\nsymbol file (.pdb) đúng của các dlls các bạn có. Quan trọng nhất là mfc42d.dll (debug\n_build), vì .pdb của nó sẽ chứa đầy đủ thông tin về các types, enumes, classes, vtables của_\n\n\n-----\n\ncác class của MFC. Chúng ta export local types từ mfc42d.dll thành file .h, rồi import vào\nidb database của chúng ta. Parse C++ của IDA còn lỗi, không parse được template syntax\n“<>” nên ta tìm và thay thế các cặp “<” và “>” thành “_” trong các file .h.\n\nMở song song mfc42d.dll trong IDA mới cùng với IDA đang phân tích malware, thực hiện\ncopy name, type của các classes, functions từ mfc42d.dll qua. Như đã nói, malware này là\nmột MFC Dialog application, nên chúng ta sẽ chắc chắn có các class sau trong malware:\n**CObject, CCmdTarget, CWinThread, CWnd, CDialog. Theo quy tắc đặt tên tự động của**\nMFC Wizard, chúng ta đã có các class với tên sau: CVVSupApp (kế thừa từ CWinApp),\n**CAboutDlg (dialog About, resID = 100), CVVSupDlg( dialog chính, resID = 102).**\n\nKết quả scan vtables, classes của hai plugin ClassInformer và HexRaysCodeXplorer.\n\n_Hình 2. Kết quả scan vtables, classes_\n\nDùng MFC_Helper scan CRuntimeClass, phát hiện ra đúng như dự đoán, CVVSupDlg có\n**CRuntimeClass và thêm một class khác: CVVSupDlgAutoProxy. Chứng tỏ tin tặc khi chạy**\nMFC Wizard, đã bấm chọn support OLE Control.\n\n_Hình 3. Kết quả sau khi chạy MFC_Helper nhận diện được các class_\n\nDựa vào hàm import CWinApp::GetRuntimeClass, xác định được CVVSupApp vtable, và\n\n\n-----\n\ndựa vào CDialog::GetRuntimeClass chúng ta xác định được hai vtable của hai dialog còn\nlại. Nhưng dialog là About, dialog nào là malware dialog. Xác định hết các internal structures\ncủa MFX như AFX_MSGMAP, AFX_DISPMAP, AFX_INTERFACEMAP…\nSử dụng tính năng Xref to các lệnh call CDialog constructor: void __thiscall\n**CDialog::CDialog(CDialog *this, unsigned int nIDTemplate, CWnd *pParentWnd),**\n**nIDTemplate chính là resID của dialog, chúng ta xác định được vtable của CAboutDlg và**\n**CMalwareDlg. Do CMalwareDlg không có CRuntimeClass và RTTI nên tạm đặt tên như**\nvậy. Tin tặc khi build đã xóa đi dòng DECLARE_DYNAMIC_CREATE của hai class này và\nclass CVVSupApp.\n\n_Hình 4. Xác định được vtable của của CAboutDlg và CMalwareDlg_\n\nCây quan hệ các class của malware này được vẽ lại như sau:\n\n\n-----\n\n_Hinh 5. Cây quan hệ các class của malware_\n\nCopy tên các hàm, type, function type, parameter… từ các class mẹ tương ứng của các\nclass trên, đúng thứ tự trong vtable, xác định được các hàm MFC Wizard sinh ra và các hàm\ntin tặc đã viết.\n\n\n-----\n\n_Hình 6. Kết quả sau khi copy tên các hàm, type, function type, parameter_\n\nMọi ứng dụng MFC đều có một biến toàn cục là theApp, thuộc class chính CXXXApp kế\nthừa từ CWinApp. Trong trường hợp malware này là: CVVSupApp theApp; Biến toàn cục\nnày được khởi tạo bởi C RTL trong hàm start, gọi trước main/WinMain, thuộc table\n**__xc_a. Các hàm trong table này gọi sau các hàm khởi tạo của C RTL trong __xi_a. Các**\ntable này là param truyền cho hàm internal _initterm của C RTL.\n\n_Hình 7. Biến toàn cục theApp trong ứng dụng MFC_\n\nLưu đồ khởi tạo và thực thi một ứng dụng của MFC như sau:\n\n\n-----\n\n_Hình 8. Lưu đồ khởi tạo và thực thi một ứng dụng của MFC_\n\nHàm CVVSupApp::InitInstance cũng là code thông thường mà MFC wizard tạo ra\n\n_Hình 9. Hàm CVVSupApp::InitInstance_\n\nConstructor của CVVSupDlg: void CVVSupDlg::CVVSupDlg() cũng là code thông thường\ncủa MFC Wizard tạo ra. Nhưng trong CVVSupDlg::OnInitDialog, là hàm được gọi từ\n**CVVSupDlg::DoModal(), ta thấy ngay, ở cuối đoạn code mà MFC Wizard sinh ra,**\n**CMalwareDlg được khởi tạo và show, sau đó malware thoát cưỡng chế exit(0) ngay.**\n\n\n-----\n\n_Hình 10. CMalwareDlg được khởi tạo và show_\n\nGiá trị 129 chính là resID của dialog CMalwareDlg, và sizeof(CMalwareDlg) = 0x290, lớn\nhơn size của CDialog mẹ. Chứng tỏ CMalwareDlg được tin tặc thêm vào một số data\nmember. Qua phân tích, chúng tôi đã tái tạo lại được các data member của CMalwareDlg:\n\n_Hình 11. Tạo lại các data member của CMalwareDlg_\n\nConstructor CMalwareDlg::CMalwareDlg làm các công việc khởi tạo sau. Để ý vào đoạn\ncopy chuỗi “192.168” vào field m_szMask:\n\n\n-----\n\n_Hình 12. Đoạn code copy chuỗi “192.168” vào field m_szMask_\n\nKhi được show, CMalwareDlg::OnInitDialog sẽ được gọi, và hàm chính quan trọng để thực\nthi nhiệm vụ của malware được call ở đây:\n\n_Hình 13. Hàm chính Infect sẽ thực thi nhiệm vụ của malware_\n\nHàm Infect (chúng tôi đặt tên) tương đối dài, nên được trình bày thông qua lưu đồ dưới:\n\n\n-----\n\n_Hình 14. Lưu đồ thực thi của hàm Infect_\n\nChúng ta sẽ đi vào chi tiết từng hàm con quan trọng được hàm Infect của class\n**CMalwareDlg gọi. Hàm UserIsAdmin, dùng API IsUserAdmin() của shell32.dll:**\n\n\n-----\n\n_Hình 15. Hàm UserIsAdmin_\n\nHàm GetSomeAPIAddrs là một hàm dư thừa, các con trỏ hàm được lấy mà hoàn toàn\nkhông dùng tới. Chúng tôi đoán đây có thể là một code cũ.\n\n\n-----\n\n_Hình 16. Hàm GetSomeAPIAddrs_\n\nHàm Base64Decode cũng giống như các hàm Base64 decode khác, chỉ khác một điểm là\nbảng Base64 code table lại được tin tặc copy vào một char arrary m_szBase64Table và truy\nxuất từ đây. Sau khi được giải mã Base64, ServiceName ban đầu là\n“TmV0QmlvcyBNZXNzYWdlciBSZWdpc3Rlcg==” sẽ là \"NetBios Messager Register\".\n**ServiceDescription ban đầu**\n“TmV0QmlvcyBjb21tdW5pY2F0aW9uIGJldHdlZW4gc3lzdGVtIGNvbXBvbmVudHMu” sẽ\nlà \"NetBios communication between system components.\"\n\nHàm ExtractCabFile là hàm global, không thuộc class CMalwareDlg. Chú ý ở điểm là file\nđược tạo ra với attribute là hidden.\n\n_Hình 17. Hàm ExtractCabFile_\n\nFile .cab được nhúng hoàn toàn trong .data section, size = 94874 (0x1729A). Tức tin tặc đã\nkhai báo tương đương sau: “static BYTE g_abCabFile[] = { 0xXXXX, 0xYYYY };” (không\ncó const nên sẽ nằm ở .data section). Trích xuất vùng đó ra, ta có một file .cab chứa một\nfile bên trong, tên là smanager_ssl.dll, ngày add vào cab là 26/04/2020 – 23:11 UTC, ngày\nbuild 26.04.2020 15:11:24 UTC.\n\n\n-----\n\n_Hình 18. File .cab được nhúng chứa file smanager_ssl.dll_\n\nFile smanager_ssl.dll (tức netapi32.dll) sẽ được phân tích trong phần tiếp theo vì nó\ntương đối phức tạp.\n\n_Hình 19. Hàm RunExtrac32Exe_\n\nHàm ExecuteAndWait cũng là hàm global, dùng API ShellExecuteExA để gọi và chờ tới\nkhi thực thi xong.\n\n\n-----\n\n_Hình 20. Hàm ExecuteAndWait_\n\nConfig của Proxy trên máy victim được tin tặc định nghĩa qua một struct như hình,\n**PROXY_TYPE là một enum:**\n\n_Hình 21. struct PROXY_CONFIG_\n\nHàm ReadProxyConfig sẽ đọc từ registry của nạn nhân trước, nếu không có sẽ đọc từ file\n**pref.js của Firefox. Hiện chúng tôi vẫn chưa rõ tại sao tin tặc lại cố đọc từ Firefox, có thể**\nchúng đã thực hiện các hoạt động tìm hiểu trước để biết về các trình duyệt web được dùng\nphổ biến ở mục tiêu.\n\n\n-----\n\n_Hình 22. Hàm ReadProxyConfig_\n\nHàm ReadProxyConfigFromRegistry hơi dài nên ở đây chỉ nêu các đoạn quan trọng:\n\n_Hình 23. Nhiệm vụ chính của hàm ReadProxyConfigFromRegistry_\n\n\n-----\n\nHàm ReadProxyConfigFromFireFox rất dài nên chúng tôi sẽ không đề cập chi tiết ở đây.\nHàm UpdateFile dùng hàm tương đương memsearh để tìm một chuỗi trong nội dung file,\nvà C&C Info sẽ được ghi vào tại vị trí tìm ra. Trong trường hợp malware này thì chuỗi mask\nlà “192.168”.\n\n_Hình 24. Hàm UpdateFile dùng hàm tương đương memsearh để tìm một chuỗi_\n\nChúng tôi đã tái tạo lại struct của C&C Info như sau:\n\n_Hình 25. struct của C&C Info_\n\nVà C&C info đã được tin tặc hard-coded ngay trong code:\n\n\n-----\n\n_Hình 26. Thông tin C&C được hard-coded trong code của mã độc_\n\nNội dung của file smanager_ssl.dll* (netapi32.dll**) nguyên gốc và sau khi được update từ\n**g_CCInfo structure qua:**\n\n_Hình 27. Nội dung của file smanager_ssl.dll (netapi32.dll) trước và sau khi được update_\n\nHàm để load file đã extract lên và tạo Scheduler Task:\n\n\n-----\n\n_Hình 28. Hàm LoadDllAndCreateSchedulerTask để load file đã extract lên và tạo_\n\n_Scheduler Task_\n\nSau đó, nếu malware được khởi chạy với quyền admin, nó sẽ đăng ký như một ServiceDll,\nvới name đã đề cập ở trên, Service registry key được chọn ngẫu nhiên từ một table gồm\nmười phần tử, và được nối thêm “Ex” vào. Các chuỗi đó gồm: “Winmads”, “Winrs”,\n“Vsssvr”, “PlugSvr”, “WaRpc”, “GuiSvr”, “WlanSvr”, “DisSvr”, “MediaSvr”, “NvdiaSvr”.\nSau khi nối thêm Ex bằng hàm sprintf, thì registry key trên máy victim được tạo dưới nhánh\n**HKLM\\ SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost sẽ là một trong các**\nchuỗi sau: “WinmadsEx”, “WinrsEx”, “VsssvrEx”, “PlugSvrEx”, “WaRpcEx”, “GuiSvrEx”,\n“WlanSvrEx”, “DisSvrEx”, “MediaSvrEx”, “NvdiaSvrEx”.\n\nDo hàm cũng tương đối dài nên ở đây chỉ trình bày các điểm chính:\n\n\n-----\n\n_Hình 29. Tạo registry key trên máy victim_\n\n_Hình 30. Tạo service trên máy victim_\n\n\n-----\n\nHàm RegistryCall là hàm tin tặc tự viết, nó là hàm toàn cục, cũng chỉ làm các nhiệm vụ thao\ntác với Registry. Theo góc nhìn của chúng tôi, phong cách lập trình của tin tặc cực kỳ lộn\nxộn và không thống nhất (cũng có thể đây là cách họ cố tình tạo nhiễu), đã gây nhiều khó\nkhăn cho chúng tôi trong quá trình phân tích. Sau khi đăng ký như một service Dll xong, hàm\n**Infect hoàn tất và return. Malware sẽ thoát do lệnh gọi exit(0) ở OnInitDialog đã nói ở trên**\n\nChúng tôi sẽ cung cấp file .xml chứa thông tin phân tích trên IDA để những ai quan tâm tới\nmã độc này có thể sử dụng để import vào lại IDA và Ghidra bằng plugin xml_importer.py\ncủa Ghidra.\n\nCác IOCs của mã độc đã được phân tích rõ trong bài viết. Các bạn có thể tự viết file .bat\nhay script bằng PowerShell, VBS… để tìm và gỡ bỏ malware này trên các máy của các nạn\nnhân.\n\n**Note:**\n\n***smanager_ssl.dll gốc:**\n\nMD5: C11E25278417F985CC968C1E361A0FB0\nSHA256:\nF659B269FBE4128588F7A2FA4D6022CC74E508D28EEE05C5AFF26CC23B7BD1A5\n\n****netapi32.dll (tức smanager_ssl.dll đã cập nhật CCInfo):**\n\nMD5: 43CE409C21CAD2EF41C9E1725CA12CEA\nSHA256:\n6C1DB6C3D32C921858A4272E8CC7D78280B46BAD20A1DE23833CBE2956EEBF75\n\n(Còn tiếp...)\n\n**Trương Quốc Ngân (aka HTC)**\n\n**Chuyên gia Phân tích mã độc - VinCSS (a member of Vingroup)**\n\n\n-----",
    "language": "VI",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-19 - [RE017-2] Phân tích kỹ thuật dòng mã độc mới được sử dụng để tấn công chuỗi cung ứng nhắm vào Ban Cơ yếu Chính phủ Việt Nam của nhóm tin tặc Panda Trung Quốc (Phần 2).pdf"
    ],
    "report_names": [
        "2020-12-19 - [RE017-2] Phân tích kỹ thuật dòng mã độc mới được sử dụng để tấn công chuỗi cung ứng nhắm vào Ban Cơ yếu Chính phủ Việt Nam của nhóm tin tặc Panda Trung Quốc (Phần 2).pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535920,
    "ts_updated_at": 1743041125,
    "ts_creation_date": 1653756971,
    "ts_modification_date": 1653756971,
    "files": {
        "pdf": "https://archive.orkl.eu/d49aa03ffe7bd7ffff7eed98c8e4a3e2bedcb997.pdf",
        "text": "https://archive.orkl.eu/d49aa03ffe7bd7ffff7eed98c8e4a3e2bedcb997.txt",
        "img": "https://archive.orkl.eu/d49aa03ffe7bd7ffff7eed98c8e4a3e2bedcb997.jpg"
    }
}