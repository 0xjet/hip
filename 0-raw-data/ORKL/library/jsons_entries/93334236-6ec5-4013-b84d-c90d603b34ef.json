{
    "id": "93334236-6ec5-4013-b84d-c90d603b34ef",
    "created_at": "2023-01-12T15:01:16.911654Z",
    "updated_at": "2025-03-27T02:06:08.648246Z",
    "deleted_at": null,
    "sha1_hash": "a1fee95800a311d6de684b2149f5bb9b525e2e78",
    "title": "2020-06-27 - Quick analysis note about GuLoader (or CloudEyE)",
    "authors": "",
    "file_creation_date": "2022-05-28T15:23:26Z",
    "file_modification_date": "2022-05-28T15:23:26Z",
    "file_size": 1344088,
    "plain_text": "# Quick analysis note about GuLoader (or CloudEyE)\n\n**[kienmanowar.wordpress.com/2020/06/27/quick-analysis-note-about-guloader-or-cloudeye/](https://kienmanowar.wordpress.com/2020/06/27/quick-analysis-note-about-guloader-or-cloudeye/)**\n\nJune 27, 2020\n\nRecently, I’ve supported a foreign friend on Twitter during the analysis one of GuLoader (or\n[CloudEyE) variant sample. Although, he have read these articles (1,](https://research.checkpoint.com/2020/guloader-cloudeye/) [2) but still stuck and I](https://blog.vincss.net/2020/05/re014-guloader-antivm-techniques.html)\nknow that feeling.\n\nThe discussion between us was quite long, finally I sent him my quick analysis so that he can\nread and follow. Now, I put the analysis that we discussed on this blog hoping it will help\nothers like him.\n\n## 1. Get the GuLoader’s shellcode\n\nGuLoader uses VirtualAlloc api for allocating a new memory section and drop shellcode to\nthe allocated memory.\n\n\n-----\n\nCall to VirtualAlloc:\n\nFill shellcode to the allocated buffer:\n\nContinue trace, will jump to the shellcode. This shellcode may vary with each sample:\n\n\n-----\n\n## 2. Debug shellcode for finding the next payload URL\n\nThis shellcode uses Heaven’s Gate technique to execute on x64 environment. You can\n[read more about this technique that I wrote here. Preferably, you should debug GuLoader on](https://blog.vincss.net/2020/06/re015-heavens-gate-mot-ki-thuat-cu-nhung-hieu-qua.html)\n_32bit Windows_ _VM._\n\nPatch to bypass anti-VM:\n\nBreak on call to EnumWindows (patch if need to bypass call to **TerminateProcess):**\n\n\n-----\n\nBreak on call to ZwProtectVirtualMemory (need to patch to bypass anti-attach):\n\nBreak on call to ZwSetInformationThread for hidding thread (need to patch 0xC3\n_when trace into this call or nop this call):_\n\nDirectly, below will usually be the sub function that call to the CPUID command, nop\nthis call:\n\n\n-----\n\nCall to get process command line:\n\nCall to shellcode main proc, need to trace into this func:\n\nThis shellcode main proc will do:\n\n_ Get RegAsm’s path (ex: C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\RegAsm.exe)\n\n_ Call to kernel32.CreateProcessInternalW to create RegAsm.exe in suspended state:\n\n_ Get msvbvm60.dll‘s path (ex: C:\\Windows\\system32\\msvbvm60.dll) and then replace to\n_\\??\\C:\\Windows\\system32\\msvbvm60.dll_\n\n_ Call to ntdll.ZwOpenFile\n\n_ Call to ntdll.ZwCreateSection with FileHandle of msvbvm60.dll (ex: File,\nC:\\Windows\\System32\\msvbvm60.dll, 0x190)\n\n_ Call to ntdll.ZwMapViewOfSection with SectionHandle of msvbvm60.dll and\n_ProcessHandle of RegAsm.exe suspended process. For mapping msvbvm60.dll:_\n\n\n-----\n\n_ Allocate RWX memory section on RegAsm.exe suspended process:\n\n_ Then call ZwWriteVirtualMemory for writing the 2nd shellcode to the allocated buffer at\n**RegAsm process. The 2nd shellcode same as the 1 shellcode, but its main task is tost**\ndecode the URL and download the final payload.\n\n\n-----\n\n_ After that it calls ZwGetContextThread, ZwSetContextThread and then\n**ZwResumeThread. So RegAsm process will return to the normal state and execute the 2**\nshellcode to download the final payload.\n\n\nnd\n\n\nFor debugging the 2nd shellcode, use ProcessHacker to change bytes of 2nd shellcode\nto 0xEB 0xFE (must restore to orginal bytes later. The original bytes is 0xFC 0x81):\n\nLet’s trace over ZwResumeThread:\n\nOpen new debugger and attach RegAsm. F9 then F12, stop at the EB FE. Change\nback to the original bytes:\n\nDebug the 2nd shellcode will locate the code decode the URL. For example: Stack ss:\n\n_[0056F848]=008D1A2C, (ASCII_\n_“hxxps://www.mediafire.com/file/kgwo4t43b5831fj/origin_geyiApZvCe4.bin/file”)_\n\n\n-----\n\nSometimes, the mediafire / google drive link was blocked by CloudFlare, so need to\nmanually download and save it. Then let’s the shellcode resolve the wininet_api\n**funcs, use these apis for downloading the CloudFlare’s content. It will check the size of**\ndownloaded content is equal to 0x4B600 (in this case). Must patch to let’s it think you\nhave downloaded the right binary. Then you trace into the func that will decrypt\npayload. My trick is replace the CloudFlare content with the content of encrypted\npayload. Here is the loop it try to find 2 bytes that decrypt 2 bytes of payload to MZ\nsignature\n\nThen build the xor_key_buffer, buffer length is 0x270 bytes:\n\n\n-----\n\nAfter decrypt loop, get the final payload. It can be a Trojans (RAT) or malware that\nsteals information such as Agent Tesla, FormBook, NanoCore RAT, Netwire RAT,\n_Remcos RAT, …_\n\n\n-----\n\nEnd!\n\nm4n0w4r\n\n_Hopefully, in the future, if I have the opportunity to go to Singapore, I will meet him !!_\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-06-27 - Quick analysis note about GuLoader (or CloudEyE).pdf"
    ],
    "report_names": [
        "2020-06-27 - Quick analysis note about GuLoader (or CloudEyE).pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535676,
    "ts_updated_at": 1743041168,
    "ts_creation_date": 1653751406,
    "ts_modification_date": 1653751406,
    "files": {
        "pdf": "https://archive.orkl.eu/a1fee95800a311d6de684b2149f5bb9b525e2e78.pdf",
        "text": "https://archive.orkl.eu/a1fee95800a311d6de684b2149f5bb9b525e2e78.txt",
        "img": "https://archive.orkl.eu/a1fee95800a311d6de684b2149f5bb9b525e2e78.jpg"
    }
}