{
    "id": "b8a9b14c-e8de-47df-aa71-5e64f50ccefd",
    "created_at": "2023-05-06T02:08:32.493738Z",
    "updated_at": "2025-03-27T02:09:20.737959Z",
    "deleted_at": null,
    "sha1_hash": "454030649f2f6e213a5a53b335cc3f6f8ef8e55e",
    "title": "2023-04-18 - Raspberry Robin- Anti-Evasion How-To & Exploit Analysis",
    "authors": "",
    "file_creation_date": "2023-05-05T02:02:26Z",
    "file_modification_date": "2023-05-05T02:02:26Z",
    "file_size": 909099,
    "plain_text": "# Raspberry Robin: Anti-Evasion How-To & Exploit Analysis\n\n**[research.checkpoint.com/2023/raspberry-robin-anti-evasion-how-to-exploit-analysis/](https://research.checkpoint.com/2023/raspberry-robin-anti-evasion-how-to-exploit-analysis/)**\n\nResearch by: Shavit Yosef\n\n## Introduction\n\n\nApril 18, 2023\n\n\nDuring the last year, Raspberry Robin has evolved to be one of the most distributed malware\ncurrently active. During this time, it is likely to be used by many actors to distribute their own\nmalware such as IcedID, Clop ransomware and more.\n\nOver time, malware has continued to evolve and escalate the game of cat and mouse.\nRaspberry Robin, however, has taken this game to the next level with a great number of\nunique tricks and evasions.\n\nIn this research, we examine Raspberry Robin as an example of identifying and evading\ndifferent evasions. We discovered some unique and innovative methods and analyzed the\ntwo exploits used by Raspberry Robin to gain higher privileges showing that it also has\ncapabilities in the exploiting area.\n\n\n-----\n\nAnti-debugging and other evasions can be exhausting, and even more when it comes to\nsuch obfuscation methods and volume of methods as Raspberry Robin implements. This\nresearch aims to show plenty of methods with explanations of how they work and how to\nevade those evasions.\n\n## Raspberry Robin Overview\n\nRaspberry Robin belongs to the rapidly growing club of malware that really doesn’t want to\nbe run on any VM. It added various evasions in many stages which makes the debugging of\nthis malware a living hell.\n\nRaspberry Robin emerged, last May and was first analyzed by Red Canary. Raspberry Robin\n[was technically well-documented by previous work, see for example avast’s report.](https://decoded.avast.io/janvojtesek/raspberry-robins-roshtyak-a-little-lesson-in-trickery/#shellcode_hiding)\n\nThe malware has several entry vectors which lead to the main sample. The most prevalent\none is via an LNK disguised as a thumb drive or a network share which\nlaunches msiexec.exe that downloads the main component.\n\nThis main component is packed with 14 different layers (some of them are identical), while\nsome of them contain evasions and some of them do not. Those stages are stored in\nmemory in a custom format being unpacked and run without the headers section. This\nmakes it difficult to unpack Raspberry Robin layers statically into a standalone PE file.\nUnderstanding the custom format and how the loading of each stage works is doable but can\nbe exhausting and it probably will be simpler to just analyze the stages dynamically.\n\nThe code in all of the stages is heavily obfuscated, including the main payload itself. What\nmakes the obfuscation even harder, is that Raspberry Robin functions expect an argument\nthat is being used to decrypt all the variables and constants the functions need. The initial\nargument is hardcoded and then every function gets an argument based on the initial one.\nThis is also important for the flow as the malware uses those variables in order to decide\nwhich block of logic to run now. That means, that jumping to a function without knowing the\nreal argument will result in faults.\n\nRaspberry Robin has different ways of how it behaves in case of detecting it is not running\non a real victim’s computer:\n\nTerminate the process\nEnters infinite loop\nCause a crash – such as in the fifth stage where it uses a different RC4 key to decrypt\nthe next stage in case the malware detects it is not running on a physical machine.\n\n\n-----\n\nThe most diabolical one – Raspberry Robin decrypts a fake new stage instead the real\none, which results in another 3 layers of packers until a fake loader. This loader was\nmentioned in several blogposts and it loads samples from a domain hardcoded inside.\nThe fake loader can be monitored by detecting that the malware tries to\nquery HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Media\\Active. Many fake payloads\nwere seen in the wild such as BroAssist and other .NET backdoors.\n\nFigure 1 – Raspberry Robin’s fake payload\n\n## Evasions walkthrough\n\nAs we mentioned, Raspberry Robin has various evasion tricks, we decided to take some of\nthem and elaborate on what those evasions try to check and how to avoid them not only for\nRaspberry Robin but also for other malware which can use those evasions as well. We\n[recommend reading our evasions and](https://evasions.checkpoint.com/) [anti-debug encyclopedias for information about many](https://anti-debug.checkpoint.com/)\nother techniques.\n\nFirst, we highly recommend using several anti-anti-debug libraries to skip many of the\n[evasions with ease. A good example of one would be ScyllaHide. ScyllaHide is an open-](https://github.com/x64dbg/ScyllaHide)\nsource anti-Anti-Debug library for user-mode evasions. It supports various debuggers such\nas x64dbg, IDA debugger and OllyDbg. If you desire a kernel-mode plugin then you\n[have titanhide which hooks Nt* kernel functions using SSDT table hooks.](https://github.com/mrexodia/titanhide)\n\n\n-----\n\nFigure 2 –\n\nScyllaHide’s options bar\nAnother thing recommended before starting to work on malware these days is checking if\nyour working machine can be detected easily by malware. For this case, there are many\n[solutions such as our own tool – InviZzzible which helping assessing the virtual environment](https://github.com/CheckPointSW/InviZzzible)\n[against a variety of evasions and al-khaser project.](https://github.com/LordNoteworthy/al-khaser)\n\n## Raspberry Robin evasions\n\n### PEB checks – Anti Debug\n\nSpecial flags in system tables, which dwell in process memory and which an operation\nsystem sets, can be used to indicate that the process is being debugged. Raspberry Robin\nchecks some of them.\n\nFirst, it inspects two flags in the PEB (Process Environment Block) which is a structure that\nholds data about the current process. Those flags are:\n```\n   BeingDebugged – Indicates whether the specified process is currently being debugged\n\n```\nand can be also queried with the API IsDebuggerPresent\n\n\n-----\n\n```\n   NtGlobalFlag – A flag that is 0 by default but if a process was created by a debugger\n\n```\nthen the following flags will be set:\n\nFLG_HEAP_ENABLE_TAIL_CHECK (0x10)\nFLG_HEAP_ENABLE_FREE_CHECK (0x20)\nFLG_HEAP_VALIDATE_PARAMETERS (0x40)\n\nExample code:\n```\nmov eax, fs:[30h] ; get PEB, in 64-bit it is in gs:[60h]\n\ncmp byte ptr [eax+2], 0 ; checking BeingDebugged flag\n\njne being_debugged\n\nmov al, [eax+68h] ; checking NtGlobalFlag\n\nand al, 70h\n\ncmp al, 70h ; (FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK |\nFLG_HEAP_VALIDATE_PARAMETERS)\n\njz being_debugged\n\n```\n**Mitigations**\n\nUsing ScyllaHide or any other Anti-Debug plugin setting those flags to 0. You can also edit\nthose bytes yourself when you start debugging.\n\n### KUSER_SHARED_DATA check – Anti Debug\n\nIt also inspects a flag in KUSER_SHARED_DATA – a structure that provides a quick mechanism\nto obtain frequently needed global data from the kernel without involving user-kernel mode\nswitching using system calls or interrupts. The structure is mapped at a fixed, hardcoded\naddress on both kernel and user sides 0x7FFE0000 on 32-bit and 0xFFFFF78000000000 on\n64-bit. The flag that is checked is KdDebuggerEnabled that returns TRUE if a kernel\ndebugger is connected/enabled.\n```\nmov eax, 0x7ffe0000 ; KUSER_SHARED_DATA structure address\n\ncmp byte ptr [eax+0x2d4], 0 ; checking KdDebuggerEnabled flag\n\njne being_debugged\n\n```\n**Mitigations**\n\nYou can patch it manually, also a draft code for patching kdcom.dll (kernel debugger) so it\n[will not be detected was issued here.](https://gist.github.com/anonymous/b5024c25634fc36e699cd9d041224531)\n\n### User name and Computer name check – Anti VM\n\nUsual hosts have meaningful and non-standard usernames/computer names. Particular\nvirtual environments assign some predefined names to default users as well as computer\nnames.\n\n\n-----\n\nRaspberry Robin checks the username and computer name against a list of known default\nnames given by VMs and analysts. Usually, those values are queried\nby GetComputerNameA and GetUserNameA but Raspberry Robin queries them differently. It\nfinds the environment variables through PEB ->\n```\nProcessParameters(RTL_USER_PROCESS_PARAMETERS) -> Environment and then loops\n\n```\nthrough the environment block looking for the USERNAME and COMPUTERNAME\nvariables.\n\n\n-----\n\n```\n.data\n\nusername db 255 dup(0) ; buffer to hold the username\n\nmsg db \"Username: \", 0\n\n.code\n\nstart:\n\n  ; Get a pointer to the PEB\n\n  mov eax, fs:[30h]\n\n  ; Get a pointer to the ProcessParameters member of the PEB\n\n  mov eax, [eax + 0x10]\n\n  ; Get a pointer to the Environment member of the ProcessParameters structure\n  mov eax, [eax + 0x48]\n\n  ; Loop through the environment block looking for the USERNAME variable\n\nnext_var:\n\n  ; Read a null-terminated string from the environment block\n\n  lodsb\n\n  ; Check if the string is empty (i.e., end of environment block)\n\n  test al, al\n\n  jz end_env\n\n  ; Check if the string starts with \"USERNAME=\"\n\n  cmp byte ptr [esi], 'U'\n\n  jne next_var\n\n  cmp dword ptr [esi+1], 'SER'\n\n  jne next_var\n\n  cmp dword ptr [esi+5], 'NAME'\n\n  jne next_var\n\n  cmp byte ptr [esi+9], '='\n\n  jne next_var\n\n  ; Copy the value of the USERNAME variable into the username buffer\n\n  mov edi, offset username\n\n  lea esi, [esi+10]\n\n  rep movsb\n\nend_env:\n\n  ; Print the username to the console\n\n  invoke StdOut, offset msg\n\n  invoke StdOut, offset username\n\n  ; Exit the program\n\n  invoke ExitProcess, 0\n\n; Define the Win32 API functions\n\nStdOut   equ <GetStdHandle, WriteFile>\n\n      extern StdOut :PROC\n\nExitProcess equ <GetProcAddress, GetModuleHandle, 0>\n\n      extern ExitProcess :PROC\n\n```\n**Mitigations**\n\nChange the Computer name and User name of your machine to non-suspicious values.\n\n### Process name & full path – Anti Debug and Anti VM\n\n\n-----\n\nSome Virtual environments launch executables from specific paths. Moreover, some\ndebuggers have default names for their DLL loaders such as x64dbg’s DLL loader.\n\nRaspberry Robin queries for the name of the process’ main module as well as its full path.\n\nFigure 3 – BaseDllName check\nTo circumvent this evasion, use rundll32.exe to debug Raspberry Robin even if you use\nx64dbg.\n\n### Number of active CPUs – Anti-Sandbox\n\nAnalysis environments usually have a Low CPU core count. This information can be queried\nfrom the PEB (NumberOfProcessors) or using the GetSystemInfo API.\n\nRaspberry Robin checks if there are fewer than 2 active processors. It does that by\nquerying ActiveProcessorCount from the KUSER_SHARED_DATA structure.\n```\nmov eax, 0x7ffe0000 ; KUSER_SHARED_DATA structure fixed address\n\ncmp byte ptr [eax+0x3c0], 2 ; checking ActiveProcessorCount\n\njb being_debugged\n\n```\n**Mitigations**\n\nTo circumvent this evasion in an analysis environment, configure the virtual machine to\nAssign two or more cores for Virtual Machine. As an alternative solution,\npatch/hook NtCreateThread to assign a specific core for each new thread.\n\nFor example on VMware Workstation Pro:\n\n\n-----\n\nFigure 4\n\n– Number of processors in VMWare\n\n### Memory pages – Anti Sandbox\n\nToo little memory on a system in the current day and age might mean a low-performance\nsystem that the authors are not interested in, or are suspecting to be an analysis\nenvironment.\n\nRaspberry Robin checks for how many physical memory pages are available in the system\nby querying NumberOfPhysicalPages from the KUSER_SHARED_DATA which is unique as most\nmalware checks this by calling the API GetMemoryStatusEx.\n\nOnce met with too few pages, a flag is raised. The threshold is 204800 pages (800 MB)\nwhich is pretty low for personal computers. The standard amount for this kind of computer is\naround 8-16 GB of RAM.\n```\n mov eax, 0x7ffe0000 ; KUSER_SHARED_DATA structure address\n\n cmp byte ptr [eax+0x2e8], 0x32000 ; checking NumberOfPhysicalPages\n\n jbe being_debugged\n\n```\nFigure\n\n5 – Number of physical pages check\nPatch NumberOfPhysicalPages in KUSER_SHARED_DATA or just assign more RAM for your VM.\n\n\n-----\n\n### Mac address Check – Anti VM\n\nVendors of different virtual environments hard-code some values as MAC addresses for their\nproducts — due to this fact such environments may be detected via checking the properties\nof appropriate objects.\n\nRaspberry Robin not only compares its own adapter info with a list of blacklisted addresses\nbut also compares the addresses in its ARP table. It does that by first populating it\nwith GetBestRoute API and then getting the table info using GetIpNetTable.\n```\nint check_mac_vendor(char * mac_vendor) {\n\n  unsigned long alist_size = 0, ret;\n\n  ret = GetAdaptersAddresses(AF_UNSPEC, 0, 0, 0, &alist_size);\n\n  if (ret == ERROR_BUFFER_OVERFLOW) {\n\n    IP_ADAPTER_ADDRESSES* palist =\n(IP_ADAPTER_ADDRESSES*)LocalAlloc(LMEM_ZEROINIT,\n\nalist_size);\n\n    void * palist_free = palist;\n\n    if (palist) {\n\n      GetAdaptersAddresses(AF_UNSPEC, 0, 0, palist, &alist_size);\n\n      char mac[6]={0};\n\n      while (palist){\n\n        if (palist->PhysicalAddressLength == 0x6) {\n\n          memcpy(mac, palist->PhysicalAddress, 0x6);\n\n          if (!memcmp(mac_vendor, mac, 3)) { /* First 3 bytes are the same\n*/\n            LocalFree(palist_free);\n\n            return TRUE;\n\n          }\n\n        }\n\n        palist = palist->Next;\n\n      }\n\n      LocalFree(palist_free);\n\n    }\n\n  }\n\n  return FALSE;\n\n}\n\n```\n**Mitigations**\n\nChange your machine’s MAC address to a non-default address.\n\n### CPUID checks – Anti VM\n\n\n-----\n\nThe CPUID instruction is an assembly instruction that returns processor identification and\nfeatures information to the EBX, ECX and EDX registers based on the value in the EAX\nregister.\n\nRaspberry Robin uses the CPUID instruction for several checks\n\n**EAX = 0x40000000 – returns Vendor ID which Raspberry Robin compares to default**\nIDs given in known virtual machine’s such as Microsoft hv (Hyper-V)\nor VMwareVMware (VMware)\n```\n  push ebx\n\n  ; nullify output registers\n\n  xor ebx, ebx\n\n  xor ecx, ecx\n\n  xor edx, edx\n\n  mov eax, 0x40000000 ; call cpuid with argument in EAX\n\n  cpuid\n\n  mov edi, vendor_id   ; store vendor_id ptr to destination\n\n  ; move string parts to destination\n\n  mov eax, ebx \n\n  stosd\n\n  mov eax, ecx\n\n  stosd\n\n  mov eax, edx\n\n  stosd\n\n  ; now check this against the different strings connected to VMs\n\n```\n**EAX = 0x1 – returns a set of feature flags These flags indicate the CPU’s capabilities**\nand features, such as whether it supports MMX, SSE, or AVX instructions, as well as\ninformation about the CPU’s stepping, model, and family. One of the flags is in the 31st\nbit in ECX which indicates whether the program is being run in Hypervisor.\n```\n  xor ecx, ecx  \n\n  mov eax, 1 // sets EAX to 1\n\n  cpuid\n\n  bt ecx, 31 // set CF equal to 31st bit in ECX\n\n  setc al // set AL to the value of CF\n\n    test eax, eax\n\n    jne being_debugged\n\n```\n**Mitigations**\n\nDifferent VM solutions have different ways of how to modify CPUID and CPU features. For\nexample, in VMWare you can edit the configuration file (.vmx) and add the following lines:\n\n\n-----\n\ncpuid.40000000.ecx = 0000:0000:0000:0000:0000:0000:0000:0000\ncpuid.40000000.edx = “0000:0000:0000:0000:0000:0000:0000:0000” – for the first\n(EAX = 0X40000000) check\ncpuid.1.ecx = ”0—:—-:—-:—-:—-:—-:—-:—-” – for the Hypervisor (EAX = 1) check\n\n### PEB module enumeration – Anti Debug and Anti Sandbox\n\nUsing the PEB, a program can enumerate the modules loaded in its memory by iterating\nthrough the list of modules stored in the PEB’s “Ldr” (Loader) data structure. Each module in\nthe list contains information such as its base address, entry point, and size, which can be\nused to analyze the module and its contents.\n\nRaspberry Robin uses that technique to check if blacklisted applications that inject their\nmodule into processes (hashed) name exists in the hardcoded blacklist. Those modules can\nbe sandbox-related or anti-anti-debug libraries such as ScyllaHide.\n\n**Mitigations**\n\nTo circumvent this evasion, the following options are available:\n\nDon’t load foreign modules into the process of the malware.\nLoad your foreign module of choice and then unlink it from the PEB, or use a different\nmethod to load it, such as manual mapping.\n\n\n-----\n\n```\n// Unlinking specific module from PEB s InMemoryOrderModuleList\n\nbool unlink()\n\n{\n\n  HMODULE mod = nullptr;\n\n  if(!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |\n\nGET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n\n                          reinterpret_cast<LPCSTR>\n(&unlink), &mod))\n\n  {\n\n    return false;\n\n  }\n\n  wchar_t module_name[MAX_PATH];\n\n  if(GetModuleFileNameW(mod, module_name, sizeof(module_name)))\n\n  {\n\n    return false;\n\n  }\n\n  #ifdef _WIN64  auto peb = reinterpret_cast<PEB*>(__readgsqword(0x60));\n\n  #else  auto peb = reinterpret_cast<PEB*>(__readfsdword(0x30));\n\n  #endif  for(auto peb_link = peb->Ldr->InMemoryOrderModuleList.Flink; peb_link\n!=\n\n                  &peb->Ldr->InMemoryOrderModuleList; peb_link =\npeb_link->Flink)\n\n  {\n\n    if(::wcscmp(reinterpret_cast<LDR_DATA_TABLE_ENTRY*>(peb_link)>FullDllName.Buffer,\n\n                     module_name) == 0)\n\n    {\n\n      peb_link->Flink->Blink = peb_link->Blink;\n\n      peb_link->Blink->Flink = peb_link->Flink;\n\n      return true;\n\n    }\n\n  }\n\n  return false;\n\n### MulDiv – Anti Wine\n\n```\nThe MulDiv [API is being called with specific arguments (MulDiv(1, 0x80000000,](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-muldiv)\n```\n0x80000000)) which should logically return 1 – however, due to a bug with the ancient\n\n```\nimplementation on Windows, it returns 2.\n\nRaspberry Robin uses this check in order to detect Wine which for some reason returns 0\n(even the latest version, as of today). There are more known evasion methods to detect\nWine like the good old check of searching for the existence of one of Wine’s exclusive APIs\nsuch as kernel32.dll!wine_get_unix_file_name or ntdll.dll!wine_get_host_version).\n\nHere is an example of comparing the execution using the Windows implementation\nof MulDiv, a logically correct implementation (which is not backward compatible), and Wine’s\nC++ implementation.\n\n\n-----\n\nFigure 6 – MulDiv implementations\nIf Using Wine, hook MulDiv to return 2 or modify the implementation as it works in Windows.\n\n### Devices detections – Anti VM\n\nVirtual environments emulate hardware devices and display devices and leave specific\ntraces in their descriptions – which may be queried and the conclusion about non-host OS\nmade.\n\nRaspberry Robin tries to evade by checking the ProductID of \\\\.\\PhysicalDrive0 and\nDeviceIDs of the display devices and comparing them to a list of blacklisted known names.\n\n\n-----\n\n```\nbool GetHDDVendorId(std::string& outVendorId) {\n\n  HANDLE hDevice = CreateFileA(_T(\"\\\\\\\\.\\\\PhysicalDrive0\"),\n\n                 0,\n\n                 FILE_SHARE_READ | FILE_SHARE_WRITE,\n\n                 0,\n\n                 OPEN_EXISTING,\n\n                 0,\n\n                 0);\n\n  STORAGE_PROPERTY_QUERY storage_property_query = {};\n\n  storage_property_query.PropertyId = StorageDeviceProperty;\n\n  storage_property_query.QueryType = PropertyStandardQuery;\n\n  STORAGE_DESCRIPTOR_HEADER storage_descriptor_header = {};\n\n  DWORD BytesReturned = 0;\n\n  DeviceIoControl(hDevice, IOCTL_STORAGE_QUERY_PROPERTY,\n\n             &storage_property_query, sizeof(storage_property_query),\n\n             &storage_descriptor_header,\nsizeof(storage_descriptor_header),\n\n             &BytesReturned);\n\n  std::vector<char> buff(storage_descriptor_header.Size);\n//_STORAGE_DEVICE_DESCRIPTOR\n\n  DeviceIoControl(hDevice, IOCTL_STORAGE_QUERY_PROPERTY,\n\n             &storage_property_query, sizeof(storage_property_query),\n\n             buff.data(), buff.size(), 0);\n\n  STORAGE_DEVICE_DESCRIPTOR* device_descriptor =\n(STORAGE_DEVICE_DESCRIPTOR*)buff.data();\n\n  if (device_descriptor->VendorIdOffset){\n\n    outVendorId = &buff[device_descriptor->VendorIdOffset];\n\n  }\n\n}\n\n```\n**Mitigations**\n\nTo circumvent this evasion you can hook DeviceIoControl or rename HDD so that it will not\nbe detected by specific strings\n\n### Firmware tables – Anti VM\n\nThere are special memory areas used by OS that contain specific artifacts if OS is run under\na virtual environment. These memory areas may be dumped using different methods\ndepending on the OS version.\n\nFirmware tables are retrieved via SYSTEM_FIRMWARE_TABLE_INFORMATION object. In our case,\nRaspberry Robin checks if specific strings are present in Raw SMBIOS Firmware Table. It\ndoes that by\n\n\n-----\n\ncalling NtQuerySystemInformation with SystemFirmwareTableInformation argument (76).\n```\n// First, SYSTEM_FIRMWARE_TABLE_INFORMATION object is initialized in the following\nway:\n\nSYSTEM_FIRMWARE_TABLE_INFORMATION *sfti =\n\n  (PSYSTEM_FIRMWARE_TABLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,\n\n   Length);\n\nsfti->Action = SystemFirmwareTable_Get; // 1\n\nsfti->ProviderSignature = 'RSMB'; // raw SMBIOS\n\nsfti->TableID = 0;\n\nsfti->TableBufferLength = Length;\n\n// Then initialized SYSTEM_FIRMWARE_TABLE_INFORMATION object is used as an argument\nfor\n\n// the system information call in the following way in order to dump raw firmware\ntable:\n\nNtQuerySystemInformation(\n\n  SystemFirmwareTableInformation, // 76\n\n  sfti,\n\n  Length,\n\n  &Length);\n\n```\n**Mitigations**\n\nTo circumvent this evasion hook NtQuerySystemInformation for\nretrieving SystemFirmwareTableInformation class and parse the SFTI structure for\nprovided field values.\n\n### Vectored Exception Filter – Anti Debug\n\nVectored exception handler (VEH) is a Windows operating system feature that allows\nprograms to register a callback function to handle certain types of exceptions that occur\nduring program execution. It is an extension of Structured Exception Handling (SEH) and it is\nbeing called for unhandled exceptions regardless of the exception’s location.\n\nThen, every time those exceptions are triggered the exception handler will be called. But\nwhen a debugger is attached to a program, it becomes the exception handler for the\nprogram’s exceptions, which allows it to intercept and handle exceptions before they are\nhandled by the program’s normal exception-handling mechanism. That means that if the\nprogram is running under a debugger, the custom filter won’t be called and the exception will\nbe passed to the debugger.\n\nRaspberry Robin adds a handler using RtlAddVectoredExceptionHandler and then\ndeliberately causes exceptions (such as in the above assembly instruction part) to verify if\nthe control passed to the handler which means further that the process running without a\ndebugger.\n\n\n-----\n\n```\ninclude win32ax.inc\n\ninvoke RtlAddVectoredExceptionHandler, not_debugged\n\nint 3\n\njmp being_debugged\n\nnot_debugged:\n\n    ; continue the process...\n\nbeing_debugged:\n\n    invoke ExitProcess,0\n\n```\n**Mitigations**\n\nTo circumvent this evasion, you can\n[patch KiUserExceptionDispatcher which ScyllaHide implements. Also, you can patch the](https://github.com/x64dbg/ScyllaHide)\nopcodes which cause the exception.\n\n### Hardware breakpoints – Anti Debug\n\nHardware breakpoints are implemented using dedicated hardware resources within the CPU,\nincluding registers that are used to store the parameters for the breakpoints. Debug Address\nRegisters (DR0-DR3) are among those registers and they are used to store the memory\naddresses or data values that the breakpoints are set on.\n\nDR0-DR3 can be retrieved from the thread context structure. If they contain non-zero values,\nit may mean that the process is executed under a debugger and a hardware breakpoint was\nset.\n\nRaspberry Robin uses the fact of having the CONTEXT structure that is given as an\nargument to the exception handler and inspects it. This is without using the\nAPI GetThreadContext which is more commonly used to query the context structure.\n\nFigure 7 – Hardware breakpoints check\nTo circumvent this evasion you can hook GetThreadContext and modify debug registers or\nin our case as it happens in VEH we can again hook KiUserExceptionDispatcher.\n\n### Assembly Instructions – Anti Debug\n\nThere are some techniques are intended to detect a debugger presence based on how\ndebuggers behave when the CPU executes a certain instruction.\n\nRaspberry Robin uses some of them in different execution stages:\n\n\n-----\n\n**POPF and CPUID**\n\nTo detect the use of a VM in a sandbox, malware could check the behavior of the CPU after\nthe trap flag is set. The trap flag is a flag bit in the processor’s flags register that is used for\ndebugging purposes. When the Trap Flag is set, the processor enters a single-step mode,\nwhich causes it to execute only one instruction at a time and then generate a debug\nexception.\n\nFigure 8 – raising\n\nthe POPF and CPUID exception\nIn our case, The popfinstruction pops the top value from the stack and loads it into the flags\nregister. Based on the value on the stack that has the Trap Flag bit set, the processor enters\na single-step mode (SINGLE_STEP_EXCEPTION) after executing the next instruction.\n\nBut the next instruction is cpuid which behaves differently in VM. When in a physical\nmachine, this exception stops the CPU execution to allow the contents of the registers and\nmemory location to be examined by the exception handler after thecpuid instruction which\nmoves away the instruction pointer from the next bytes. In a VM, executing cpuid will result\nin a VM exit. During the VM exit the hypervisor will carry out its usual tasks of emulating the\nbehaviors of the cpuid instruction which will make the Trap Flag be delayed and the code\nexecution will continue to the next instruction with the C7 B2 bytes. This results in an\nexception because of an illegal instruction exception.\n\nThe vectored exception handler we mentioned above checks for this type of exception\n(Illegal instruction) and if it encounters such an exception, Raspberry Robin knows it runs\nunder a VM.\n\n**Stack Segment Reigster**\n\nThe trick relies on the fact that certain instructions cause all of the interrupts to be disabled\nwhile executing the next instruction. This is happening using the following code:\n```\npush ss\n\npop ss\n\npushf\n\ntest byte ptr [esp+1], 1\n\njnz being debugged\n\n```\n\n-----\n\nThe register ss is called the Stack Segment and is a special-purpose register that stores the\nsegment address of the current stack.\n\nLoading the ss (Stack segment) register clears interrupts to allow the next instruction to load\nthe esp register without the risk of stack corruption. However, there is no requirement that\nthe next instruction loads anything into the esp register.\n\nIf a debugger is being used to single-step through the code, then the Trap Flag will be set in\nthe EFLAGS image. This is typically not visible because the Trap Flag will be cleared in the\nEFLAGS image after each debugger event is delivered. However, if the flags are saved to\nthe stack using the pushf instruction before the debugger event is delivered, then the Trap\nFlag will become visible. Therefore, comparing the flag on the stack can tell us whether the\nsample is being debugged.\n\n**INT 3**\n```\nINT3 is an interruption that is used as a software breakpoint. Without a debugger present,\n\n```\nafter getting to the INT3 instruction, the exception EXCEPTION_BREAKPOINT(0x80000003) is\ngenerated and an exception handler will be called. If the debugger is present, the control\nwon’t be given to the exception handler but to the debugger itself.\n\nBesides the short form of INT3 instruction (CC opcode), there is also a long form of this\ninstruction: CD 03 opcode.\n\nWhen the exception EXCEPTION_BREAKPOINT occurs, Windows decrements the EIP register\nto the assumed location of the CC opcode and passes the control to the exception handler. In\nthe case of the long form of the INT3 instruction, EIP will point to the middle of the instruction\n(means to the 03 byte). Therefore, EIP should be edited in the exception handler if we want\nto continue execution after the INT3 instruction (otherwise we’ll most likely get\nan EXCEPTION_ACCESS_VIOLATION exception). If not, we can neglect the instruction pointer\nmodification.\n```\nbool IsDebugged()\n\n{\n\n  __try\n\n  {\n\n    __asm int 3;\n\n    return true;\n\n  }\n\n  __except(EXCEPTION_EXECUTE_HANDLER)\n\n  {\n\n    return false;\n\n  }\n\n}\n\n```\n**Mitigations**\n\n\n-----\n\nThe best way to mitigate all the following checks is to find those methods and patch them\nwith NOP instructions.\n\n### Thread hiding – Anti Debug\n\nIn Windows 2000, a new class of thread information was added to the\nAPI NtSetInformationThread – ThreadHideFromDebugger. It was added because when you\nattach a debugger to a remote process a new thread is created. If this was just a normal\nthread the debugger would be caught in an endless loop as it attempted to stop its own\nexecution.\n\nSo behind the scenes when the debugging thread is created Windows calls\nNtSetInformationThread with the ThreadHideFromDebugger flag set (1). This way the\nprocess can be debugged and a deadlock prevented. Allowing code execution to continue as\nnormal.\n\nIf this flag is set for a thread, then that thread stops sending notifications about debug\nevents. These events include breakpoints and notifications about program completion. Due\nto this flag, the debugger cannot see the thread and is now unable to trap these events.\n\nRaspberry Robin enables the flag on newly spawned threads and then queries this\ninformation again using the API NtQueryInformationThread to check if the flag was set.\n```\nbool HideFromDebugger(HANDLE hThread) {\n\n  int status;\n\n  int lHideThread = 1;\n\n  // ThreadHideFromDebugger = 0x11\n\n  status = NtSetInformationThread(hThread, ThreadHideFromDebugger, 0, 0);\n\n  // check if the thread is hidden\n\n status = NtQueryInformationThread(hThread, ThreadHideFromDebugger,\n&ThreadInformation, 1u, 0);\n\n  return status\n\n}\n\n```\n**Mitigations**\n\nTo circumvent this evasion you need to hook NtSetInformationThread. In our case, you\nalso need to hook NtQueryInformationThread.\n\n### NtQueryInformationProcess flags – Anti Debug\n\nThe API NtQueryInformationProcess can retrieve a different kind of information from a\nprocess. It accepts a ProcessInformationClass parameter which specifies the information\nyou want to get and defines the output type of the ProcessInformation parameter.\n\nRaspberry Robin uses this API in order to query the following values:\n\n\n-----\n\nProcessDebugPort (ProcessInformationClass = 7) – returns the port number of the\ndebugger for the process.\n\nProcessDebugFlags (ProcessInformationClass = 0x1f) – returns the inverse value of\nthe field NoDebugInherit which is a boolean value that determines whether child\nprocesses inherit the debugging privileges of their parent process. This flag resides in\nthe EPROCESS object.\n\nProcessDebugObjectHandle (ProcessInformationClass = 0x1e) – returns a handle to a\nkernel object that can be used to attach a debugging object to a process, allowing a\ndebugger to control the process and access its memory and state. When a process is\ncreated, it does not have a debugging object associated with it by default. However, a\ndebugger can use the API OpenProcess with the DEBUG_ONLY_THIS_PROCESS or\nDEBUG_PROCESS flags to create a ProcessDebugObjectHandle for the process.\n\nFigure 11 – NtQueryInformationProcess flags checks\n**Mitigations**\n\nTo circumvent this evasion hook NtQueryInformationProcess and set the following values\nin return buffers:\n\n0 (or any value except -1) in the case of ProcessDebugPort\nA non-zero value in the case of ProcessDebugFlags\n0 in the case of ProcessDebugObjectHandle\n\n### DbgBreakPoint patch – Anti Debug\n```\nDbgBreakPoint is the API called when a debugger attaches to a running process. It allows\n\n```\nthe debugger to gain control because an exception is raised which it can intercept. The API\nhas the following implementation:\n```\ncc int3\n\nc3 ret\n\n```\nby replacing the first byte (int3 = 0xcc) with a ret (0xc3) instruction, the debugger won’t break\nin and the thread will exit.\n\n\n-----\n\n```\nvoid Patch_DbgBreakPoint()\n\n{\n\n  HMODULE hNtdll = GetModuleHandleA(\"ntdll.dll\");\n\n  if (!hNtdll)\n\n    return;\n\n  FARPROC pDbgBreakPoint = GetProcAddress(hNtdll, \"DbgBreakPoint\");\n\n  if (!pDbgBreakPoint)\n\n    return;\n\n  DWORD dwOldProtect;\n\n  if (!VirtualProtect(pDbgBreakPoint, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))\n\n    return;\n\n  *(PBYTE)pDbgBreakPoint = (BYTE)0xC3; // ret\n\n}\n\n```\n**Mitigations**\n\nTo circumvent this evasion, you can patch DbgBreakPoint back after the modification (can\nbe as part of hooking VirtualProtect).\n\n### Process Suspension detection – Anti Debug\n\nThis evasion depends on having the thread creation\nflag THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE (name given by researcher) that\nMicrosoft added into 19H1. This flag makes the thread ignore any PsSuspendProcess API\nbeing called.\n\nRaspberry Robin uses this flag for a cool trick. It creates two threads with this flag, one of\nwhich keeps suspending the other one until the suspend counter limit which is 127 is\nreached (suspend count is a signed 8-bit value).\n\nWhen you get to the limit, every call for PsSuspendProcess doesn’t increment the suspend\ncounter and returns STATUS_SUSPEND_COUNT_EXCEEDED. But what happens if someone\ncalls NtResumeProcess? It decrements the suspend count! So when someone decides to\nsuspend and resume the thread, they’ll actually leave the count in a state it wasn’t previously\nin. Therefore, Raspberry Robin calls periodically to NtSuspendThread and if it succeeds and\nincrements the counter it means that the thread has been externally suspended and\nresumed and is being debugged.\n\n**Mitigations**\n\nTo circumvent this evasion, you can hook NtCreateThread to omit\nthe THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZEIt flag.\n\n### VBAWarnings check – Anti Sandbox\n\n\n-----\n\nYou all know the Enable all macros prompt in Office documents. It means the macros can\nbe executed without any user interaction. This behavior is common for sandboxes.\n\nRaspberry Robin uses that in order to check if it is running on a sandbox checking the flag in\nthe registry keys SOFTWARE\\Microsoft\\Office\\\n```\n<version>\\Word\\Security\\VBAWarnings while the version is between 12.0 to 19.0.\n\n```\n**Mitigations**\n\nTo circumvent this evasion disable this flag or hook SHGetValueW or other registry query APIs\nsuch asRegQueryValueExA.\n\n## Main stage tricks\n\nRaspberry Robin not only has numerous evasions but also some really nice tricks of how not\nbeing detected by security solutions.\n\n### IFEO Removal\n\nThis technique involves modifying the Image File Execution Options (IFEO) registry key,\nwhich is used by the Windows operating system to set debugging options for executable\nfiles. When an executable file is launched, the operating system checks the corresponding\nIFEO registry key for any specified debugging options. If the key exists, the operating system\nlaunches the specified debugger instead of the executable file.\n\nWhat Raspberry Robin does is remove the registry keys for the following files so they will run\ninstead of the debugger:\n\nrundll32.exe\nregsvr32.exe\ndllhost.exe\nmsiexec.exe\nodbcconf.exe\nregasm.exe\nregsvcs.exe\ninstallutil.exe\nexplorer.exe\n\n### Windows Defender Exclusion List\n\nRaspberry Robin tries to evade Windows Defender by adding its processes and paths to its\nexclusion list by adding the values to the registry\nkeys: HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\n\n\n-----\n\n```\nDefender\\Exclusions\\Paths and HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\nDefender\\Exclusions\\Processes.\n\n### Persistence trick\n\n```\nRaspberry Robin Creates a file with a random name and extension and puts it\nin %TEMP% directory. Then, the malware writes the\ncommand shell32.dll|ShellExec_RunDLLA|REGSVR32.EXE -U /s \"C:\\Windows\\Temp\n```\n<generated_file_name>.” to RunOnce or RunOnceEx key but with a twist.\n\n```\nRaspberry Robin tries to evade security solutions by first generating a random registry key\ninside HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion and renaming the RunOnce key\nto this random name. Then add the new value to this random key before renaming it back\nto RunOnce.\n\nNow that we’ve covered the various evasive tactics, let’s shift our focus to the exploits used\nby the malware.\n\n## Privilege escalation\n\nRaspberry Robin has several ways of how it elevates its privileges – two UAC methods,\nwhich were covered in avast’s blogpost and two 1-days EoP exploits. Raspberry Robin only\nruns those methods only in case this malware really needs them. Those checks including:\n\nProcess’s SID isS-1-5-32-544(DOMAIN_ALIAS_RID_ADMIN)\nThe integrity level is 0x3000 (high integrity) or 0x2000 (medium integrity)\nIf consent by user or admin is required –\n```\n   HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\ConsentPro\n   mptBehaviorUser/Admin\n\n```\nIf the time of the last input event (calling to GetLastInput) is in the last hour.\n\nBelow we drill down into the EoP exploits used by the malware.\n\nThe malware contains 2 exploits, which are embedded and encrypted by RC4 in memory.\nEach exploit is suitable for different versions of windows which increases the odds of the\nmalware elevating its privileges on a random victim’s machine.\n\n[Both exploits are 64-bit and packed with the same packer known as Donut Loader. The](https://github.com/TheWover/donut)\n[packer is injected as a shellcode with KernelCallbackTable injection as copied from the open-](https://modexp.wordpress.com/2019/05/25/windows-injection-finspy/)\n[source POC. The exploits are injected into winver.exe which is also added to the Windows](https://github.com/odzhan/injection/blob/master/kct/kct.c)\nDefender excluded list.\n\nThe exploits share code such as the encryption scheme of loops of math expressions for\ntheir strings (such as class names and loaded modules).\n\n\n-----\n\n### CVE-2020-1054\n\n**[CVE-2020-1054 is Win32k Elevation of Privilege Vulnerability reported by Check Point](https://cpr-zero.checkpoint.com/vulns/cprid-2153/)**\nResearch. The vulnerability is out of bounds write in win32k and it was used by different\nExploit kits in the past. The exploit has some similarities to open-source GitHub POCs but\nwe haven’t found one that surely is the base for this implementation. The exploit is only used\nby Raspberry Robin on Windows 7 systems where the revision number is not higher\nthan 24552 (It gets the build number through the BuildLabEx registry key).\n\n### Versioning Decisions\n\nDepends on the environment variable that Raspberry Robin’s main module sets. This\nvariable means what kind of Windows 7 we have (with patches or not – for different offsets).\nThe exploit uses this variable in order to decide 2 offsets:\n```\n   xleft_offset – 0x900 or 0x8c0\n   oob_offset – 0x238 or 0x240\n\n### HMValidateHandle Wrapper\n\n```\nGets the HMValidateHandle from searching inside the IsMenu code for 0xe8 opcode. It\nsearches in the first 0x20 bytes for this opcode.\n\nFigure 12\n\n– Getting HMValidateHandle address\n\n### Privilege Elevation\n\n\n-----\n\nThe exploit uses a shellcode, different than the ones in GitHub doing the same replacing of\nthe process’s token. This shellcode is invoked by sending a message after the API\nSetBitmapBits\n\n### Naming\n\nThe name of the window used in this exploit is “#32272” so it can’t be used for hunting as it’s\npretty known and used in many places.\n\n### Token Swap\n\nIn the shellcode, it is pretty straightforward:\n\nWe search for the target process – using the target PID\nWe search for SYSTEM – using a PID of 4\nWe update our pointer to point at SYSTEM’s token\n\nFigure 13 – Token swapping in kernel shellcode\n\n### CVE-2021-1732\n\n\n-----\n\n**CVE-2021-1732 is a win32k window object type confusion leading to an OOB (out-of-**\nbounds) write. It was used as a 0-day in the wild by Bitter APT and written by Moses – also\n[known as Exodus Intelligence. We found some resemble to an open source POC in both the](https://github.com/exploitblizzard/Windows-Privilege-Escalation-CVE-2021-1732/blob/main/CVE-2021-1732/CVE-2021-1732.cpp)\nflow and how to restore windows after changing the token but also some differences.\n\nCVE-2021-1732 runs on Windows 10, with the targeted build number range being\n[from 16353 to 19042. For the second exploit, it also checks if the package KB4601319 of the](https://support.microsoft.com/en-us/topic/february-9-2021-kb4601319-os-builds-19041-804-and-19042-804-87fc8417-4a81-0ebb-5baa-40cfab2fbfde)\npatch is present.\n\n### Versioning Decisions\n\nQuerying OSBuildNumber from the PEB in order to decide on a number of offsets (some of\nthem are 0x40 different from real offset due to the type of read primitive):\n\nBuild number greater than 19041\n\n**offset_ActiveProcessLinks = 0x448**\n**offset_token = 0x4b8**\n**offset_UniqueProcessId = 0x400**\nBuild number greater than 18362 but less than 19041\n\n**offset_ActiveProcessLinks = 0x2f0**\n**offset_token = 0x360**\n**offset_UniqueProcessId = 0x2a8**\nBuild number greater than 15063 but less than 18362\n\n**offset_ActiveProcessLinks = 0x2e8**\n**offset_token = 0x358**\n**offset_UniqueProcessId = 0x2a0**\nBuild number less than 15063\n\n**offset_ActiveProcessLinks = 0x2f0**\n**offset_token = 0x358**\n**offset_UniqueProcessId = 0x2a8**\n\nThis is pretty weird because the check inside RaspberryRobin is that the version is\nbetween 16353 to 19042\n\n### HMValidateHandle Wrapper\n\nAs in CVE-2020-1054, it gets the HMValidateHandle from searching inside the IsMenu code\nfor 0xe8 opcode. It searches in the first 0x20 bytes for this opcode. This function is identical\nto the same function in the other exploit.\n\n### Naming\n\nRegistering class with the name: “helper_cls” and then registering (spray handles)\nwindows from this class with the name: “helper”.\n\n\n-----\n\n### Privilege Elevation\n\nThe exploit uses Arbitrary-Read & Arbitrary-Write exploit primitives, based on the\nvulnerability feature in conjunction with GetMenuBarInfo and Call SetWindowLong to write\ndata to the address of the kernel-space desktop heap.\n\n### Token Swap\n\nScanning the EPROCESS.ActiveProcessLinks until finding the System process (PID = 4) and\nour process (equal our PID) using an Arbitrary-Read / Arbitrary-Write exploit primitives. It\nthen writes the process’s token address to wndMax.pExtraBytes and then writes to this\naddress the system token.\n\nFigure 14 – Token Swap using the exploit primitives\n\n### Notable info\n\nThe exploit gets the ETHREAD structure using the\nAPI NtQuerySystemInformation with SystemExtendedHandleInformation and\niterates SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX for handles until getting the one with the\nthread ID as the running thread.\n\n## Conclusion\n\nAnti-debugging and other evasions can be pretty exhausting, and even more when it comes\nto such obfuscation methods and volume of methods as Raspberry Robin implements. We\nshowed plenty of methods with explanations of how they work and how to evade those\nevasions. Raspberry Robin implemented other cool tricks and exploits showing that he also\nhas capabilities in the exploiting area. Unfortunately, the world of evasions is only getting\nharder and more creative, so buckle up and pray that somebody already encountered this\nevasion before you.\n\n**Check Point Customers remain protected against the threat described in this**\n**research.**\n\n\n-----\n\n**Check Point** **[Threat Emulation provides Comprehensive coverage of attack tactics,](https://www.checkpoint.com/infinity/zero-day-protection/)**\n**file-types, and operating systems, and has developed and deployed a signatures**\n**named “Trojan.Wins.RaspberryRobin” to detect and protect our customers against the**\n**malware described in this blog.**\n\nGO UP\n[BACK TO ALL POSTS](https://research.checkpoint.com/latest-publications/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-04-18 - Raspberry Robin- Anti-Evasion How-To & Exploit Analysis.pdf"
    ],
    "report_names": [
        "2023-04-18 - Raspberry Robin- Anti-Evasion How-To & Exploit Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "bf6cb670-bb69-473f-a220-97ac713fd081",
            "created_at": "2022-10-25T16:07:23.395205Z",
            "updated_at": "2025-03-27T02:02:09.777308Z",
            "deleted_at": null,
            "main_name": "Bitter",
            "aliases": [
                "T-APT-17",
                "TA397"
            ],
            "source_name": "ETDA:Bitter",
            "tools": [
                "Artra Downloader",
                "ArtraDownloader",
                "Bitter RAT",
                "BitterRAT",
                "Dracarys"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "655f7d0b-7ea6-4950-b272-969ab7c27a4b",
            "created_at": "2022-10-27T08:27:13.133291Z",
            "updated_at": "2025-03-27T02:00:55.490812Z",
            "deleted_at": null,
            "main_name": "BITTER",
            "aliases": [
                "T-APT-17"
            ],
            "source_name": "MITRE:BITTER",
            "tools": [
                "ZxxZ"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1683338912,
    "ts_updated_at": 1743041360,
    "ts_creation_date": 1683252146,
    "ts_modification_date": 1683252146,
    "files": {
        "pdf": "https://archive.orkl.eu/454030649f2f6e213a5a53b335cc3f6f8ef8e55e.pdf",
        "text": "https://archive.orkl.eu/454030649f2f6e213a5a53b335cc3f6f8ef8e55e.txt",
        "img": "https://archive.orkl.eu/454030649f2f6e213a5a53b335cc3f6f8ef8e55e.jpg"
    }
}