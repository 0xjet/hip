{
    "id": "adc3b6d1-8ebf-450c-9bd4-96b90e3090ed",
    "created_at": "2023-01-12T15:05:21.720068Z",
    "updated_at": "2025-03-27T02:05:40.729053Z",
    "deleted_at": null,
    "sha1_hash": "f6074b8e3c9ec8a4681b0916823e2b7f1da90b3b",
    "title": "2021-06-26 - MODeflattener - Miasm's OLLVM Deflattener",
    "authors": "",
    "file_creation_date": "2022-05-28T15:28:49Z",
    "file_modification_date": "2022-05-28T15:28:49Z",
    "file_size": 429732,
    "plain_text": "# MODeflattener - Miasm's OLLVM Deflattener\n\n**mrt4ntr4.github.io/MODeflattener/**\n\nSuraj Malhotra June 25, 2021\n\n[So recently a challenge(Layers) from](https://mrt4ntr4.github.io/files/modeflattener/layers-729d7c2b1e12d9598e9bf6bc247ce0ba.zip) [3kCTF featured control flow flattening using OLLVM.](https://ctftime.org/event/1317)\nAlthough I did know about control flow flattening I hadn’t encountered it personally. And as\nI’ve been experimenting with miasm for the past few days I thought of developing a tool to\ndeal with it.\n\n## Control Flow Flattenning\n\nControl flow flattening is an interesting and clever technique to make a reverse engineer’s\nday difficult. It basically puts all the basic blocks in a function at the same level and destroys\nthe control flow. It then uses a dispatcher to reconstruct the control flow along with a\ncontrol/state variable which is updated at the end of each block.\n\nThe following illustration depicts various parts of a flattened function.\n\n\n-----\n\nVarious obfuscators employ their own version of control flow flattening transformations :\n\n[OLLVM](https://github.com/obfuscator-llvm/obfuscator/wiki/Control-Flow-Flattening)\n[Tigress](http://tigress.cs.arizona.edu/transformPage/docs/flatten/index.html)\n[Hellscape](https://github.com/meme/hellscape#flattening)\n\nCAUTION : Only Static Analysis used !\n\nAs we are primarly focusing on OLLVM for now we can just use some static analysis\ntechniques to deobfuscate it, but for developing a universal tool to deal with this kind of\nobfuscation we need to look more into dynamic approaches.\n\n_[For example, this looks interesting.](https://essay.utwente.nl/67522/1/Scrinzi_MA_SCS.pdf)_\n\n## Getting Flattening Information\n\n\n-----\n\nTo start off, we need to identify the relevant blocks and the dispatcher. To find the dispatcher\nwe need to first find the pre-dispatcher. This is because we rely on the fact that the predispatcher has the maximum number of predecessors, it is easy to identify. Later we can just\nget the first successor of the pre-dispatcher to get the dispatcher, easy!\n```\n  def get_cff_info(asmcfg):\n    preds = {}\n    for blk in asmcfg.blocks:\n      offset = asmcfg.loc_db.get_location_offset(blk.loc_key)\n      preds[offset] = asmcfg.predecessors(blk.loc_key)\n    pre_dispatcher = sorted(preds, key=lambda key: len(preds[key]), reverse=True)\n  [0]\n    dispatcher =\n  asmcfg.successors(asmcfg.loc_db.get_offset_location(pre_dispatcher))[0]\n    dispatcher = asmcfg.loc_db.get_location_offset(dispatcher)\n\n```\nAlso we now already have the relevant blocks as they are just the predecessors to the predispatcher we just found!\n\n## State Variable\n\nThe state variable is responsible for maintaining the control flow in the flattened function.\n\nThe state variable is always initialized before the dispatcher and is used in the first line of the\ndispatcher. We can use this information to get the state variable automatically.\n\n## Relevant Blocks\n\nThe blocks that are aligned at the same level in the disassembly graph and include the\nuseful code are known as relevant blocks. These blocks update the value of the state\nvariable at the very end\n\n\n-----\n\n**Note: Currently we also add the tail of the backbone to our relevant blocks as we are just**\ndepending on the predecessors of the pre-dispatcher. Basically the tail is used if the state\nvariable value doesn’t satisfy any condition in the backbone. It doesn’t update the state\nvariable and only has a jump to pre-dispatcher. So if we don’t find any code related to\nmodification of the state variable in a relevant block we mark this as tail.\n\nHaving most of the information we can now proceed with deflattening the flow.\nBasically we have two types of relevant blocks:\n\n**Simple**\nBlock without any conditions, so the state variable is always updated with the same\nvalue. Only one instruction is used to modify the state variable.\n\n**Conditional**\nBlocks with conditional statements and loops. Here the state variable could have two\npossible values depending on whether the condition results in a true or false. These\noften end with a `cmov instruction. Several instructions are used to modify the state`\nvariable.\n\n## Use of SSA Expressions\n\nWe further simplify the IR to SSA to deal with the conditional relevant blocks.\n\nWe only make use of `do_propagate_expressions ssa simplification pass.`\n\n\n-----\n\n```\n  head = loc_db.get_offset_location(addr)\n  ssa_simplifier = IRCFGSimplifierSSA(lifter)\n  ssa = ssa_simplifier.ircfg_to_ssa(ircfg,\n  head)\n  ssa_simplifier.do_propagate_expressions(ssa,\n  head)\n\n```\nIn the SSA form we observe a Phi operation which basically means that one of the variables\narriving from different predeccesors is chosen depending on which path the control flow took.\n\n\n-----\n\nIn the above example we observe that if the condition is true the state variable is assigned\nthe value = 0x7A3F9928 (RCX.4) and if false value = 0x30110039 (RCX.2).\n\nWe get the block where the phi variables are assigned using the following code and then get\ntheir values from those blocks.\n```\n  if irblock_has_phi(irblock):\n    for dst, sources in viewitems(irblock[0]):\n      phi_vars = sources.args\n      parent_blks =\n  get_phi_sources_parent_block(\n        ircfg,\n        irblock.loc_key,\n        phi_vars\n      )\n\n```\nWe get the following information from a relevant block:\n```\n  0x401a9d: {'cond': 'CMOVB',\n       'false_next':\n  0x30110039,\n       'true_next':\n  0x7a3f9928}\n\n```\nNow we need to iterate over the backbone blocks and get their destinations if it includes\ncondition regarding any of the possible state variable values. We can map these to the\noriginal state variable values and make use of it to correct the flow.\n```\n  if isinstance(arg, ExprInt):\n    if int(arg) in val_list:\n      cmp_val = int(arg)\n      var, locs = irblock[-1].items()[0]\n      true_dst =\n  main_ircfg.loc_db.get_location_offset(locs.src1.loc_key)\n      backbone[hex(cmp_val)] = hex(true_dst)\n\n```\nAfter resolving these values from the backbone, the final result looks like this.\n```\n  0x401a9d: {'cond': 'CMOVB',\n       'false_next':\n  0x401bb0,\n       'true_next':\n  0x401af5}\n\n```\n\n-----\n\n## Removing Useless Instructions\n\nModeflattener finds the addresses to nop out using the def-use graph for the state variable.\nThis is one of the data flow analysis feature provided by miasm. This algorithm returns all the\ninstructions affecting the state variable and therefore we call these as useless instructions.\n[Read more about it here](https://miasm.re/blog/2017/02/03/data_flow_analysis_depgraph.html)\n\nThe state variable is always located in one of the leaves in the graph, we can easily get all of\nits parents using the following code.\n```\n  def find_state_var_usedefs(ircfg, search_var):\n    var_addrs = set()\n    reachings = ReachingDefinitions(ircfg)\n    digraph = DiGraphDefUse(reachings)\n    for leaf in digraph.leaves():\n      if leaf.var == search_var:\n        for x in (digraph.reachable_parents(leaf)):\n          var_addrs.add(ircfg.get_block(x.label)\n  [x.index].instr.offset)\n    return var_addrs\n\n## Patching and Reconstructing the Control Flow\n\n```\nWhile cleaning these useless instructions we have to keep in mind that the call instructions\nwill get affected by this as they are based on relative offsets.\n\nWe can fix it using the following code :\n\n\n-----\n\n```\n  rel = lambda addr, patch_addr: hex(addr - patch_addr)\n  for instr in instrs:\n    #omitting useless instructions\n    if instr.offset not in nop_addrs:\n      if instr.is_subcall():\n        #generate asm for fixed calls with relative addrs\n        patch_addr = start_addr + len(final_patch)\n        tgt =\n  loc_db.get_location_offset(instr.args[0].loc_key)\n        call_patch_str = \"CALL %s\" % rel(tgt, patch_addr)\n        call_patch = asmb(call_patch_str, loc_db)\n        final_patch += call_patch\n      else:\n        #add the original bytes\n        final_patch += instr.b\n\n```\nAt last we need to generate a patch for jumps and reconstruct the control flow.\n\nFor a simple relevant block we only need a single patch.\n```\n  asmb = lambda patch_str, loc_db: mn_x86.asm(mn_x86.fromstring(patch_str, loc_db,\n  32))[0]\n  patch_addr = start_addr + len(final_patch)\n  n_addr = link['next']\n  patch = \"JMP %s\" % rel(n_addr, patch_addr)\n  jmp_patches = asmb(patch, loc_db)\n\n```\nWe have two instruction patches for a conditional relevant block. We replace the conditional\nmove with a conditional jump to the true address and add another jump in succession to the\nfalse address.\n```\n  t_addr = link['true_next']\n  f_addr = link['false_next']\n  jcc = link['cond'].replace('CMOV', 'J')\n  patch1_str = \"%s %s\" % (jcc, rel(t_addr,\n  patch_addr))\n  jmp_patches += asmb(patch1_str, loc_db)\n  patch_addr += len(jmp_patches)\n  patch2_str = \"JMP %s\" % (rel(f_addr,\n  patch_addr))\n  jmp_patches += asmb(patch2_str, loc_db)\n\n```\n\n-----\n\nWe can nop out the backbone as it is useless now.\n```\n  backbone_start, backbone_end = dispatcher, tail.offset +\n  tail.l\n  nop_len = backbone_end - backbone_start\n  patches[backbone_start] = b\"\\x90\" * nop_len\n\n## Final Results\n\n Graph View\n\n F5 View\n\n```\n\n-----\n\n## Get MODeflattener\n\nI’ve open sourced the tool on my github. I’ve added some samples to test it as well. Try\nit out!\n\n[https://github.com/mrT4ntr4/MODeflattener](https://github.com/mrT4ntr4/MODeflattener)\n\n## Bonus\n\n[Tim Blazytko’s flattening heuristic script](https://gist.github.com/mrphrazer/da32217f231e1dd842986f94aa6d9d37)\n\nWhile disassembling the specified function we can look out for other functions used by\nit and can make use of this script to automatically detect whether it is a flattened one\nand try to deobfuscate it. This has already been integrated into the tool!\n\n[nop-hider idapython script](https://gist.github.com/JusticeRage/795badf81fe59454963a06070d132b06)\n\nThis script hides the nop instructions from IDA graph view as the backbone is\nconverted into a long nop chain after deobfuscation.\n\n## References\n\n[Dissecting LLVM Obfuscator - RPISEC](https://rpis.ec/blog/dissection-llvm-obfuscator-p1/)\n[Automated Detection of Control-flow Flattening - Tim Blazytko](https://synthesis.to/2021/03/03/flattening_detection.html)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-06-26 - MODeflattener - Miasm's OLLVM Deflattener.pdf"
    ],
    "report_names": [
        "2021-06-26 - MODeflattener - Miasm's OLLVM Deflattener.pdf"
    ],
    "threat_actors": [
        {
            "id": "79e95381-8008-48dc-b981-fd66e1c46ca6",
            "created_at": "2022-10-25T16:07:24.110478Z",
            "updated_at": "2025-03-27T02:02:10.110353Z",
            "deleted_at": null,
            "main_name": "RedCurl",
            "aliases": [
                "Earth Kapre",
                "Red Wolf"
            ],
            "source_name": "ETDA:RedCurl",
            "tools": [
                "Impacket",
                "LaZagne"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535921,
    "ts_updated_at": 1743041140,
    "ts_creation_date": 1653751729,
    "ts_modification_date": 1653751729,
    "files": {
        "pdf": "https://archive.orkl.eu/f6074b8e3c9ec8a4681b0916823e2b7f1da90b3b.pdf",
        "text": "https://archive.orkl.eu/f6074b8e3c9ec8a4681b0916823e2b7f1da90b3b.txt",
        "img": "https://archive.orkl.eu/f6074b8e3c9ec8a4681b0916823e2b7f1da90b3b.jpg"
    }
}