{
    "id": "62762dab-3bcb-4131-9ac7-9d46a5f7df6c",
    "created_at": "2023-01-12T15:09:14.624977Z",
    "updated_at": "2025-03-27T02:05:51.982278Z",
    "deleted_at": null,
    "sha1_hash": "079426b8b5bbe8163b7befd08808c421e9c54bc4",
    "title": "2022-08-07 - Config Extractor per DanaBot (PARTE 1)",
    "authors": "",
    "file_creation_date": "2022-09-01T10:30:35Z",
    "file_modification_date": "2022-09-01T10:30:35Z",
    "file_size": 3590736,
    "plain_text": "# Config Extractor per DanaBot (PARTE 1)\n\n**[malverse.it/costruiamo-un-config-extractor-per-danabot-parte-1](https://malverse.it/costruiamo-un-config-extractor-per-danabot-parte-1)**\n\n## Introduzione\n\nCiao a tutti, oggi volevo analizzare la sfida bi-settimanale lanciata di Daniel di Zero2Auto che\nconsiste questa volta nel scrivere un Config Extractor che funzioni per le diverse versioni di\n**DanaBot, un malware scritto in Delphi.**\n\nDa [Malpedia:](https://malpedia.caad.fkie.fraunhofer.de/details/win.danabot)\n\n_Proofpoints describes DanaBot as the latest example of malware focused on_\n_persistence and stealing useful information that can later be monetized rather than_\n_demanding an immediate ransom from victims. The social engineering in the low-_\n_volume DanaBot campaigns we have observed so far has been well-crafted, again_\n_pointing to a renewed focus on ‚Äúquality over quantity‚Äù in email-based threats._\n_DanaBot‚Äôs modular nature enables it to download additional components, increasing_\n_the flexibility and robust stealing and remote monitoring capabilities of this banker._\n\nCi vengono forniti questi quattro link, che ci permettono di ottenere diverse versioni del\nsample:\n\n[Logicamente possiamo ottenere altri sample classificati come Danabot, ad esempio qui e](https://tria.ge/s/family:danabot)\n[qui.](https://any.run/malware-trends/danabot)\n\nIn particolare, in questo post analizzeremo tre sample (MD5:\n**6b448c6851f3235c9b3d0c24353c480f, 5c0be4a5273dec6b3ebb180a90f337f2,**\n**611c2bf7aa7bb62e90f3a92f3682c0b5), realizzando un semplice script per estrarre gli IP del**\n\n\n-----\n\nC&C; nei prossimi post analizzeremo come avviene la comunicazione con il C&C,\nindentificheremo le funzioni di cifratura, estrarremo la chiave RSA e realizzeremo lo script\nfinale che funziona sui diversi sample forniti.\n\nPartiremo da analizzare il primo sample, si tratta del Main Component di DanaBot,\nsuccessivamente analizzeremo dei sample pi√π complessi che contengono al loro interno il\nMain Component.\n\n## Analisi Main Component Danabot\n\nPartiamo analizzando il primo sample (MD5: 6b448c6851f3235c9b3d0c24353c480f); si\ntratta del Main Component di DanaBot, sviluppato in Delphi ed esporta diverse funzioni (f0,\nf1, ‚Ä¶, f9):\n\nDIE rileva che si tratta di una DLL scritta in Delphi\n\n\n-----\n\nFunzioni esportate dalla DLL\n\nAnalizzando la funzione F0, dopo la decifratura di diverse stringhe e la creazione di un altro\nthread, troviamo la creazione di un thread che contiene diverse chiamate per effettuare\noperazioni con i socket (per chi volesse maggiori informazioni sul funzionamento dei socket\n[pu√≤ consultare questa ottima guida); tracciando i parametri passati a queste funzioni,](http://www.lia.deis.unibo.it/Courses/RetiLA/RetiLA_06-07/materiale/lezioni/sockcx2.pdf)\nriusciamo ad ottenere dove effettivamente avviene la creazione del config.\n\nCreazione del Thread principale che si occupa di comunicare con il C&C\nLa funzione che ci interessa attualmente √® inet_addr, essendo che ha come parametro l‚ÄôIP\nin formato dotted-decimal; in realt√† non troveremo l‚ÄôIP direttamente in questo formato, ma\nl‚ÄôIP in formato decimale verr√† prima convertito con una semplice funzione che ho rinominato\n**IntToIP e poi passato a inet_addr:**\n\n\n-----\n\nOperazioni con i socket\n\ne conversione dell‚ÄôIP da int\nIl primo parametro della funzione IntToIP √® un parametro a sua volta della funzione padre,\nquindi analizzo le chiamate a questa funzione (solo una) e traccio tale valore; viene\nreferenziato solo in due funzioni e in particolare una √® interessante perch√© come parametro\nha una variabile globale:\n\nFunzione che accede in scrittura al Config\n\n\n-----\n\nQuesta variabile √® acceduta da diverse funzioni, in particolare una di queste effettua la\nscrittura in questa zona di memoria; essendo che non contiene dati, viene quindi popolata in\nruntime, avvio quindi il debugger e confermo che questa zona di memoria contiene proprio il\nconfig (inizia con 3C e termina con 4E):\n\nConfig\n\nottenuto con il debugger\nConfermata che fosse questa la funzione che costruisce il config, trovo infatti a un certo\npunto una variabile globale che contiene i diversi IP:\n\nIP in formato int\nVediamo quindi un primo script specifico per questo sample, che poi verr√† generalizzato per\nsupportare i vari sample. In questo caso ho effettuato una regex sullo specifico move nella\nfunzione di Config Builder per ottenere l‚Äôindirizzo specifico che contiene i diversi IP del C&C.\n\n\n-----\n\n```\nimport pefile, ipaddress, binascii, re, struct\n\npe = None\n\nimageBase = None\n\n\ndef GetRVA(va):\n\n  return pe.get_offset_from_rva(va - imageBase)\n\n\ndef GetVA(raw):\n\n  return imageBase + pe.get_rva_from_offset(raw)\n\n\ndef main():\n\n  global pe, imageBase\n\n  filename = \"sample3\"\n\n  with open(filename, 'rb') as sample:\n\n    data = bytearray(sample.read())    \n\n  pe = pefile.PE(filename)\n\n  imageBase = pe.OPTIONAL_HEADER.ImageBase\n\n  copy_operation = b'\\xa1\\x68\\x57\\x54\\x00'\n\n  for m in re.compile(copy_operation).finditer(data):   \n\n    addrStart = int(hex(struct.unpack(\"<L\", data[m.start() + 1:m.start() + 1 +\n4])[0]), 16)\n\n  for i in range(10):\n\n    start = int(hex(addrStart + i*4),16)\n\n    end = int(hex(addrStart + (i+1)*4),16)\n\n    ip = binascii.hexlify(data[GetRVA(start):GetRVA(end)])\n\n    print(str(ipaddress.IPv4Address(int(ip, 16))))\n\n\nif __name__ == \"__main__\":\n\n  main()\n\n\n```\nLo script ci permette di ottenere i diversi IP utilizzati dal malware come C&C:\n\n\n-----\n\n243.127.43.6\n64.126.175.2\n\n130.15.230.152\n\n74.99.136.192\n\n244.14.226.35\n\n95.179.168.37\n\n51.129.76.8\n\n151.210.85.159\n\n45.76.123.177\n\n75.57.14.121\n\n## Analisi Loader Danabot\n\nNel secondo sample (MD5: 611c2bf7aa7bb62e90f3a92f3682c0b5) abbiamo un VBS script\nmolto offuscato:\n\nDropper VBS offuscato\nUna volta avviato si ottengono due messaggi:\n\nPrimo messaggio dello script\n\nSecondo messaggio dello script\n\n\n-----\n\nLo script salva la DLL yvNdiXKm.txt in TEMP e avvia la funzione F0, che in realt√† non viene\nesportata dalla DLL e quindi viene avviato l‚Äôentry:\n\nIl VBS estrae la\n\nDLL in temp e la avvia\n\nRundll32 avvia la\n\nfunzione F0 della DLL (entry)\nEffettuiamo una prima analisi del sample con Resource Hacker, PE Studio e Detect It Easy:\n\n\n-----\n\nIl sample risulta packed\n\nLe pochi capability trovate da capa confermano sia un packer\n\n\n-----\n\nLa DLL √® composta da diversi form\n\nPath con riferimenti alla guerra e Russia\nAnalizzando questa DLL non trovo le funzioni socket viste in precedenza essendo il packer;\nmetto come breakpoint le funzioni VirtualProtect, VirtualAlloc e CreateThread. Viene\nraggiunto VirtualProtect e all‚Äôindirizzo base_address + 0x115f50 √® presente la shellcode,\nche viene copiata dall‚Äôindirizzo base_address + 0xdaaa0:\n\nCopia della shellcode cifrata\n\n\n-----\n\nIn particolare, la decifratura della shellcode √® molto semplice, infatti nonostante siano\npresente molto operazioni, viene solo modificata da una operazione, che aggiunge per ogni\n4 byte il valore 0x1828308 e questa somma viene fatta per 0x0135910C volte:\n\nDecifratura della shellcode\n\nEsecuzione della shellcode attraverso RET\nDopo la decifratura viene avviata la shellcode che si occupa di decifrare la restante\nshellcode:\n\n\n-----\n\nIl\n\nloop di decryption che decifra la restante shellcode e le funzioni della nuova DLL\n\nControl Flow prima e dopo la decifratura\nSuccessivamente avviene qualcosa di molto interessante, la shellcode cambia i i permessi\ndella varie sezioni con VirtualProtect in scrittura (0x4) riscrivendo parte di queste e quella in\n.data in execution (0x40); questa tecnica si chiama Reflective DLL Loading e consiste nel\ncaricare direttamente la DLL dalla memoria senza passare dal disco.\n\nPermessi iniziali della DLL\n\nCambio dei permessi in scrittura\n\nCambio dei permessi in esecuzione\n\n\n-----\n\nRiferimento a Delphi\nSuccessivamente viene eseguito CreateThread, passando come indirizzo un indirizzo\npresente in .data, ricordiamo decifrato in precedenza dalla shellcode.\n\nCreazione del thread con la\n\nfunzione decifrata dalla shellcode\nInseriamo nuovamente come breakpoint la funzione connect e otteniamo la funzione dove si\neffettua la connessione al C&C:\n\n\n-----\n\nAnche questa volta vediamo che il config inizia con 3C e termina con 4E ma il terzo e il\nquarto byte sono differenti rispetto al config precedente:\n\nConfig ottenuto con il debugger\nHo iniziato quindi a tracciare le diverse VirtualAlloc per capire dove effettivamente fosse il\nconfig; a un certo punto viene allocata una zona di memoria e il suo indirizzo salvato in\n\n**[ebx+631549] e questo puntatore viene utilizzato per effettuare diverse operazioni sul PE**\nper deoffuscarlo:\n\nVirtualAlloc\n\nalloca la zona di memoria per il PE\n\n\n-----\n\nDeobfuscation del PE tramite decifratura e decompressione\nLa prima funzione che viene eseguita estrae il PE offuscato copiando il contenuto in EDI; il\nPE offuscato si trova nell‚Äôindirizzo di memoria base_address + 0xbecc.\n\n\n-----\n\nFunzione che copia il PE offuscato da ESI in EDI\n\nPE Offuscato ottenuto staticamente\n\n\n-----\n\nQuesto PE compresso viene decifrato da una semplice funzione:\n\nFunzione che decifra il PE\nPer quanto riguarda la decompressione, la funzione prende un sottoinsieme di byte dalla\nzona di memoria puntata da ESI e li trasferisce nella zona di memoria puntata da EDI\nattraverso movsb, stosb e lodsb; per chi volesse approfondire come funziona il\n[trasferimento attraverso queste istruzioni si pu√≤ leggere l‚Äôottimo articolo presente qui. In](http://www.salvorosta.it/low/sk.php?TP=1&TI=lods-stos-movs&MH=Mhor0&MV=Masm386&FR=&CP=asm386/asm386-08.php)\n[particolare, il PE √® compresso con APLib (la signature del PE √® M8Z) e successivamente](https://gist.github.com/securitygab/fef72a0c1bdb6ad0e3d9226f14c3fa1c)\n[possiamo utilizzare quindi l‚Äôottimo tool di herrcore.](https://github.com/herrcore/aplib-ripper)\n\nFunzione che si occupa di decomprimere il PE\n\n\n-----\n\nFunction Graph della funzione che si occupa della decompressione del PE\nAl ritorno della funzione in EDX avremo il puntatore al PE completamente deoffuscato, dove\ninfatti troviamo gli IP estratti in precedenza:\n\nPE completamente deoffuscato zona di memoria puntata da EDX\n\nHeader della nuova DLL estratta corrisponde a Delphi 3\n\nRicerca dell‚ÄôIP nell‚Äôarea di\n\nmemoria puntata da EDX\nQuesto PE viene poi utilizzato per sovrascrivere le attuali sezioni come visto in precedenza.\n\n\n-----\n\nNella seconda parte dell articolo realizzer√≤ un video per vedere praticamente questa parte\ntramite debugger per poi scrivere lo script che si occupa in automatico di rimuovere i diversi\nlayer di obfuscation; per ora, a scopo ‚Äúdidattico‚Äù, possiamo effettuare il dump della DLL e\nproseguire; dopo aver effettuato il fixing con Shylla, forzo la decompilazione nella sezione\n.data ed ecco la funzione di Decryption Config, simile al primo sample che abbiamo ottenuto:\n\nConfig Builder\n\nCaratteristiche nuova DLL sovrascritta dalla shellcode\nE anche questa volta otteniamo la lista degli IP come variabili globali:\n\n\n-----\n\nIP del C&C in formato int\nPossiamo facilmente cambiare l‚Äôespressione regolare dell‚Äôoperazione di copy\n(\\xa1\\x68\\x47\\x00\\x02) per ottenere:\n\n181.63.44.194\n\n207.148.83.108\n\n45.77.40.71\n\n87.115.138.169\n\n24.229.48.7\n\n116.111.206.27\n\n45.196.143.203\n\n218.65.3.199\n\n131.59.110.186\n\n113.81.97.96\n\nVediamo come adattare ora lo script precedente per farlo funzionare per i due sample visti\nfino ad ora, iniziamo ad analizzare le due funzioni di Config Builder; dovendo generalizzare\nnella regex la destination essendo l‚Äôindirizzo dove son presenti gli IP diversi, mantenendo\nsolo come statica la source (registro EAX) otteniamo un numero molto elevato di MOV, √®\nnecessario quindi rendere pi√π specifica la regex.\n\nDopo il primo MOV vediamo che √® presente un altro MOV che salva il valore di EAX in\nun‚Äôaltra variabile globale.\n\n\n-----\n\nMOV del primo sample\n\nMOV del secondo sample\n\nInoltre all‚Äôinizio della funzione sono presenti delle inizializzazioni di registri quasi uguali (si\nnoti che questa parte non √® strettamente necessaria, infatti anche rimuovendo il regex per\nquesta parte lo script funziona comunque essendo che la prima modifica gi√† permette di\nottenere solo quell‚Äôindirizzo):\n\nOperazioni del\n\nprimo sample\n\nOperazioni\n\ndel secondo sample\nDopo queste due considerazioni la regex diventa quindi:\n```\nheader = b'\\x64\\xff\\x30\\x64\\x89\\x20\\x33\\xc0\\x89\\x45.'\n\ncopy_operation = b'\\xa1\\x68...\\xa3\\xc1...'\n\nregex = header + copy_operation\n\n```\nProvando il nuovo script funziona su entrambi i sample:\n\nIP decifrati\n\n\n-----\n\nSi noti che questo script funziona solo sul Main Loader di DanaBot; nel prossimo post\nvedremo come aggiornare lo script per farlo funzionare direttamente sul dropper (vbs, exe) e\nautomatizzare la decifratura effettuata dalla shellcode.\n\n## Analisi secondo Loader\n\nIniziamo ora l‚Äôanalisi del terzo sample (MD5: 5c0be4a5273dec6b3ebb180a90f337f2),\nquesta volta √® un EXE sviluppato in C:\n\nIn questo caso l‚ÄôEXE si occupa di estrarre la DLL nella cartella corrente e avviarla; questa\nDLL a sua volta avvia la stessa DLL passando un parametro casuale (quindi verr√† avviato in\nrealt√† l‚Äôentry); infatti come possiamo vedere oltre gli export canonici essendo una DLL scritta\nin Delphi, non abbiamo altro:\n\n\n-----\n\nApplico la conoscenza precedente cercando riferimenti a socket, non trovando niente.\n\nSospetto quindi che in realt√† sia un packer e tramite il debugger allora analizzo le varie\nchiamate VirtualAlloc, VirtualProtect e CreateThread si vede come in realt√† la DLL abbia\nal suo interno un‚Äôaltra DLL, questa volta con un export FunDLLData:\n\nIn questa DLL invece si trovano i riferimenti alla comunicazione tramite socket e tracciando i\n\n\n-----\n\nparametri passati riusciamo a raggiungere il Config Builder:\n\nPer questo post √® tutto, nei prossimi continueremo l‚Äôanalisi, analizzeremo le altre\ninformazioni presenti nel config, estrarremo la chiave RSA utilizzata per la comunicazione e\ngeneralizzeremo lo script per i restanti sample üôÇ Per qualunque consiglio o richiesta,\nscrivete pure nei commenti, grazie! üôÇ\n\n_Si ringrazia bleepingcomputer.com per l‚Äôimmagine di copertina_\n\nShare this content:\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-07 - Config Extractor per DanaBot (PARTE 1).pdf"
    ],
    "report_names": [
        "2022-08-07 - Config Extractor per DanaBot (PARTE 1).pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536154,
    "ts_updated_at": 1743041151,
    "ts_creation_date": 1662028235,
    "ts_modification_date": 1662028235,
    "files": {
        "pdf": "https://archive.orkl.eu/079426b8b5bbe8163b7befd08808c421e9c54bc4.pdf",
        "text": "https://archive.orkl.eu/079426b8b5bbe8163b7befd08808c421e9c54bc4.txt",
        "img": "https://archive.orkl.eu/079426b8b5bbe8163b7befd08808c421e9c54bc4.jpg"
    }
}