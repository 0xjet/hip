{
    "id": "693bf99f-8e10-470f-9cad-d9cd7552654d",
    "created_at": "2022-10-25T16:48:13.274355Z",
    "updated_at": "2025-03-27T02:17:05.701589Z",
    "deleted_at": null,
    "sha1_hash": "3eee6ce4ab8508de1b06b8c54a333b95985dca23",
    "title": "Malicious Activity Report - Deep Analysis of a Recent Lokibot Attack",
    "authors": "",
    "file_creation_date": "2021-12-08T19:58:28Z",
    "file_modification_date": "2021-12-08T12:04:16Z",
    "file_size": 4040492,
    "plain_text": "**MALICIOUS ACTIVITY REPORT**\n\n# Deep Analysis of a Recent Lokibot Attack\n\n\n## 17 November 2021 Author: Gaetano Pellegrino\n\n\n-----\n\n### Table of Contents\n\n**1. Purpose** **3**\n\n**2. Overview** **3**\n\n**3. The Attack Chain** **5**\n\n**4. The NSIS installer** **7**\n\n**5. The Loader** **9**\n\n**6. Encrypted Lokibot** **15**\n\n**7. Lokibot** **16**\n\n7.1. Attribution via section .x 18\n\n7.2. Heaven’s Gate 19\n\n7.3. API hashing 20\n7.3.1. DLL resolution 21\n7.3.2. API resolution 23\n7.3.3. The hash function 24\n\n7.4. A vaccine against Lokibot 25\n\n7.5. The failed persistence 28\n\n7.6. Exfiltration 35\n7.6.1. Data gathering 35\n7.6.2. Data exfiltration 39\n\n7.7. Lokibot’s relationship with the C&C server 48\n\n**Appendix A: Targeted applications** **53**\n\nBrowsers 53\n\nEmail applications 53\n\nFTP applications 53\n\nSSH applications 54\n\nPassword management applications 54\n\nMiscellaneous 54\n\n**Appendix B: Source code for the vaccine against Lokibot** **55**\n\n**Appendix C: A List of Lokibot modules** **59**\n\n**Bibliography** **62**\n\n**Endnotes** **63**\n\n\n-----\n\n### 1. Purpose\n\nAs an infostealer, Lokibot can extract and then exfiltrate sensitive information from many popular applications. Although\nLokibot was discovered back in 2015, it is still being distributed and is a serious threat to consumers and organizations.\n\nThe purpose of this report is to\n\n1. Provide a fresh and detailed view of the Lokibot attack chain: from the email attachment to the Lokibot malware\n\nitself\n\n2. Explain the capabilities and purpose of each artifact involved in the attack\n\n3. Describe how Lokibot uses process hollowing, API hashing, various obfuscation algorithms, and other\n\ntechniques to thwart analysis and avoid detection\n\n4. Release a body of knowledge and tools, such as the source code for a Lokibot vaccine, that would enhance the\n\ndetection and prevention of this menace\n\n### 2. Overview\nLokibot was first seen on May 3, 2015, when a hacker nicknamed Lokistov or Carter published a sales announcement\nfor Lokibot (Any.Run 2015). At that time, Lokibot’s focus was limited to attacking cryptocurrency wallets (Hoang, 2019).\nSome researchers believe Lokibot’s original codebase was stolen from the author and resold at a lower price. Others\nthink that the malware was patched by some actor who had no access to the source code; having fully analyzed a\nrecent sample, we at Infoblox share this view.\n\nNowadays, Lokibot is an information-stealing malware with the keylogging capability and application-specific functions\nfor targeting popular web browsers, FTP clients, email applications, password management tools, and even poker game\nplatforms. Variants of Lokibot seem to have functions tailored to specific applications, but the malware’s overall\nstructure has not changed much over the last few years. What has changed are the early stages of the attack chain:\nLokibot’s capability to be extracted from an attached ISO image (Singh, 2019), downloaded from a link in a PDF\ndocument (Zhang and Liu, 2017), installed via a document by exploiting a vulnerability in Microsoft Office (Co and\nSison, 2018), or delivered as a .NET executable via an NSIS installer (Hoang 2019 and Remillano et al., 2020).\nHowever, in the case reported by Remillano et al. (2020), the attack chain was less sophisticated, because the installer\ndropped the executable directly into the file system. As shown by Muhammad and Hunterbrink (2021), recent Lokibot\nattacks are more sophisticated, have more stages, and apply obfuscation techniques.\n\nLokibot has been discussed in great detail in Pantazopoulos (2017). Our goal here is to add to this body of knowledge\nby providing a fresh and exhaustive overview of the entire Lokibot attack chain for a campaign that occurred in early\nJune 2021. In that campaign, we observed the following main techniques at various stages of the attack:\n\n_Table 1. ATT&CK matrix for the entire Lokibot chain analyzed in this report_\n\n|MITRE ATT&CK ID|Technique|Description|\n|---|---|---|\n|T1566|Phishing|Lokibot is usually delivered via email, with mass propagation campaigns.|\n|T1204.002|User Execution: Malicious File|Lokibot is usually executed through malicious documents, AutoIt scripts, and Windows installers.|\n\n\n-----\n\n|T1071.001|Application Layer Protocol: Web Protocols|Lokibot uses the HTTP to communicate with the command and control (C&C).|\n|---|---|---|\n|T1564.001|Hide Artifacts: Hidden Files and Directories|Lokibot creates several files in a hidden directory. It is also capable of moving itself into a hidden directory as part of the persistence- setting process.|\n|T1027|Obfuscated Files or Information|Lokibot is usually protected by at least one obfuscation technique.|\n|T1027.002|Obfuscated Files or Information: Software Packing|Lokibot may be protected by at least one form of the packing algorithm.|\n|T1055.012|Process Injection: Process Hollowing|It has been reported that Lokibot uses the Process Hollowing technique to inject itself into other processes.|\n|T1082|System Information Discovery|Lokibot has the capability of getting the architecture, screen resolution, operating system version, and other system information.|\n|T1016|System Network Configuration Discovery|Lokibot has the capability of getting the domain name of the computer it infected.|\n|T1033|System Owner/User Discovery|Lokibot has the capability of getting the username of a logged-in user.|\n|T1560.002|Archive Collected Data: Archive via Library|Lokibot is capable of compressing the stolen data before sending it to the C&C. This report discusses a sample by using aPLib, a freeware compression library, to compress the stolen data prior to its exfiltration.|\n|T1005|Data from Local System|Lokibot looks for specific files and attempts to exfiltrate them.|\n|T1555|Credentials from Password Stores|Lokibot is capable of stealing passwords from FTP clients, email clients, and other applications.|\n|T1555.003|Credentials from Password Stores: Credentials from Web Browsers|Lokibot is capable of stealing passwords saved by a variety of browsers.|\n|T1041|Exfiltration Over C&C Channel|Lokibot exfiltrates stolen information via a C&C channel.|\n\n\n-----\n\n### 3. The Attack Chain\n\nSince June 2021, the Infoblox Global Intelligence Analytics team has observed a significant increase in the number of\ncampaigns delivering Lokibot malware. The campaigns are still targeting Italy, Greece, China, Vietnam, Argentina, and\nother countries. This section provides an overview of the entire attack chain used in these campaigns. Each subsequent\nsection focuses on a separate link in the attack chain.\n\nThe attack chain starts as an email with an attached compressed RAR archive (a feature of all Lokibot campaigns we\nhave studied) and campaign-specific body text similar to the following:\n\n\nCan you please let us know when the invoice no. 2215301 will be paid?\nAccording to our account department we're yet to receive your payment.\n\nThanks.\n\nI wish you a nice day!\n\nBest Regards\n\n**[REDACTED]**\n\nPurchasing Department\n\n**[REDACTED] S.p.A.**\n\nPhone:+39 051 [REDACTED]\n\nMobile: +39 333 [REDACTED]\n\nFax: + 39 051 [REDACTED]\n\nEmail: [REDACTED]@[REDACTED]\n\nLa presente e-mail è inviata dall'Impresa [REDACTED] S.p.A. che opera secondo i principi di liceità e trasparenza a\ntutela della riservatezza,delle libertà, della dignità e dei diritti degli interessati ai sensi del GDPR 679/16 EU. Il suo\ncontenuto è strettamente confidenziale e riservato al destinatario che dovrà trattarne il contenuto secondo i medesimi\nprincipi. Qualora si ritenga di aver ricevuto erroneamente la presente comunicazione, Vi invitiamo a darcene pronta\ncomunicazione all'indirizzo amministrazione@[REDACTED] e a provvedere alla distruzione del suo contenuto.\nInformativa privacy e privacy policy aziendale sono consultabili presso le apposite sezioni del sito web aziendale\n\n**[REDACTED]**\n\n_P__ Save a tree. Don't print this e-mail unless it's really necessary.\n\n\nIn this case, the threat actor sent spoofed corporate emails. The sender’s name, phone numbers, and other information\n(redacted in the example) belonged to an employee of the attacked corporation, (an Italian mobile banking company,\nand were probably obtained from the data blackmarket or from previous attacks. The attachment is a Windows\nexecutable masked as a PDF file and named “invoice no. XXXXXXX·pdf.rar”, where XXXXXXX is a number and “·pdf”\n\n\n-----\n\n(notice the centered dot) is a fake extension. Because Windows hides the file extension by default, the victim does not\nsee “.exe”. The executable is a Windows installer generated with a legitimate tool, Nullsoft Scriptable Install System\n(NSIS), henceforth referred to as the NSIS installer.\n\n_Figure 1. The Lokibot attack chain_\n\nOnce opened, the NSIS installer decompresses and drops two files with randomly generated names, in this case\ncgttxpglckz and a01jkkyi4ridof2orcun, into the file system. cgttxpglckz contains shellcode that (1) the NSIS installer\nloads into memory and executes and that (2) consists of what is commonly known as a stub: a piece of code\nresponsible for decrypting further code and executing it. The code decrypted by the stub uses process hollowing to\nload, decrypt, and inject a01jkkyi4ridof2orcun into a newly spawned process. Although the encrypted\na01jkkyi4ridof2orcun contains binary data without any apparent meaning, decryption reveals its true content: a sample\nof Lokibot malware. For the rest of this report, we will refer to cgttxpglckz as the Loader and to a01jkkyi4ridof2orcun as\nthe Encrypted Lokibot.\n\nIn the last link of the chain, Lokibot runs an array of functions each targeting specific applications with the goal of\nharvesting files that contain sensitive information.\n\n\n-----\n\n### 4. The NSIS installer\n\nThreat actors password-protect email attachments. However, in several Lokibot campaigns we observed in June 2021,\n[no password was required to open the archive, because it contained an NSIS](https://nsis.sourceforge.io/Main_Page) installer: a legitimate, open-source utility\nfor creating installers for Windows applications. NSIS ships with a scripting language that lets clients define and control\nalmost every aspect of installation, including uncompressing a file included in the installation bundle.\n\nThe adoption of an NSIS installer early in the attack confers several time-saving benefits. First, NSIS installers provide a\ncompression layer, which helps the artifacts escape detection by anti-malware. Second, the victim does not need to\ntype a password to run the malware. These factors reduce the time gap between the download and opening of the\nattachment, and this leaves the victim less time to realize that the attachment is suspicious and should not be run.\n\nDespite these advantages, the actors still have to grapple with the appearance of the executable. Figure 2 shows that\nthe actors tried but failed to completely hide the attachment’s type: a PE32 portable executable. They tried to mask the\nexecutable as a PDF, and Windows’ default configuration for hiding file extensions helped, but that was not enough.\n\n_Figure 2. Desktop icon of the NSIS installer_\n\nFor this reason, the icon appeared as a typical executable and looked suspicious to most users.\n\nAs already mentioned, NSIS comes with a scripting language that allows the clients to define many aspects of the\ninstallation procedure. To generate an installer for their application, the actors collect all necessary files, write an\n\n[NSIS].nsi script, and let NSIS interpret it. The output of the interpretation process is the actual installer for the\napplication.\n\nWe extracted the [NISIS].nsi script from Invoice·pdf.exe. Although most of the extract is junk code, two parts are useful.\nThe first part lies at the very beginning of the script, where the Lempel Ziv Markov chain compression Algorithm (LZMA)\nis set for the files included in the installation bundle. Figure 3 shows the evidence of the actor’s intention to compress\nthe artifacts with LZMA.\n\n_Figure 3. The [NISIS].nsi script sets LZMA compression for all files in the installation bundle_\n\nThe second relevant part of the script pertains the overriding of the .onGUIInit callback:\n\n\n-----\n\n_Figure 4. The.onGUIInit callback_\n\nNSIS defines several callback functions that clients can overwrite to customize some aspects of the installation process.\nOne of those functions is .onGUIInit, which is called every time the installer is launched to initialize the graphical user\ninterface (GUI).[1] In this particular case, the actor overwrote the .onGUIInit function to implement a behavior that had\nnothing to do with GUI settings. The function helps understand which files belong to the installation bundle: the Loader\nand the Encrypted Lokibot. We know this because their names are arguments of two consecutive calls to the File\ncommand, which is responsible for extracting files.[2] The installer drops those files into the temp directory as a\nconsequence of the InstallDir $TEMP directive, which is not shown in the two reported excerpts of the [NSIS].nsi\nscript. We will discuss those files and their roles in the dedicated sections that follow.\n\nAfter dropping the files, the installer allocates a memory buffer of 46611 bytes by invoking the Alloc API exposed by the\nsystem library. The purpose of this buffer becomes clear after we look at the following three calls to the kernel32\nlibrary’s APIs:\n\n  - CreateFile[3] is called to open the Loader file. It opens the file with the desired access GENERIC_READ\n(0x80000000), and it stores the resulting file handle in the r10 register.\n\n  - VirtualProtect[4] is called to set the protection option PAGE_EXECUTE_READWRITE (0x40) to the previously\nallocated memory buffer. We know this by observing that (1) the output of the Alloc API is stored in the r4\nregister after the Pop $4 instruction is called and (2) VirtualProtect is invoked with the r4 register as its\nlpAddress argument.\n\n\n-----\n\n  - ReadFile[5] is invoked to move the Loader file’s contents into the buffer, because its first argument is the r10\nregistry storing that file handle and because the destination buffer is held by the r4 register. Indeed, the size of\nthe Loader file is exactly the same as that of the allocated buffer.\n\nThe last relevant part of .onGUIInit deals with the invocation of whatever has just been read from the file. That\ninvocation happens by jumping to the address stored in the r4 register and by invoking System::Call::$4().\nTherefore, we can conclude that Invoice·pdf.exe acts as a dropper and launcher for the subsequent stages of the attack\nvector. In the next section, we discuss the content of the Loader file.\n\n### 5. The Loader\n\nWe know that the NSIS installer drops the cgttxpglckza file into the temp directory; because the file name appears to be\nrandomly generated, we call this file the Loader. We also know that the same installer loads the Loader into memory,\nasks for execution privileges for the memory page where it has been loaded, and eventually tries to execute the\ncontent. In this section, we clarify the role of the Loader in the attack chain.\n\n```\ndef decrypt(encrypted_buffer: bytearray) -> bytearray:\n    decrypted_buffer = []\n    for encrypted_byte in encrypted_buffer:\n       decrypted_byte = encrypted_byte\n       decrypted_byte -= 1\n       decrypted_byte ^= 0x5a\n       decrypted_byte += 0xc1\n       decrypted_byte -= 1\n       decrypted_byte -= 0xd\n       decrypted_byte += 0x31\n       decrypted_byte ^= 0x18\n       decrypted_byte += 0xf\n       decrypted_byte -= 0x2f\n       decrypted_byte ^= 0xcd\n       decrypted_byte ^= 0x4a\n       decrypted_byte += 1\n       decrypted_byte -= 0x2f\n       decrypted_byte ^= 0xb1\n       decrypted_byte ^= 0x48\n       decrypted_byte += 0x72\n       decrypted_byte -= 3\n       decrypted_byte -= 0x46\n       decrypted_byte += 0x77\n       decrypted_byte += 0xe5\n       decrypted_buffer.append(decrypted_byte & 0xff)\n    return bytearray(decrypted_buffer)\n\n```\n\nThe file contains binary data that consists of the shellcode for x86 processors. The original shellcode has three relevant\nparts, which do the following:\n\n1. Load a byte array of 6685 integers into memory.\n\n\n-----\n\n2. Scan that array and apply a composite transformation to each of its elements. This transformation—based on\n\nXOR, addition, subtraction, decrement, and increment operations—has the goal of decrypting a shellcode\npayload. We have reverse-engineered the decryption function and propose a Python translation in the code\nsnippet above.\n\n3. Jump to the newly decrypted payload:\n\n_Figure 5. The Lokibot loader decrypts and executes a shellcode fragment_\n\nThe decrypted payload contains shellcode for x86 processors. One of the functions initially called by the payload\nretrieves the memory address of the kernel32 library. Here is that function’s entire code:\n\n```\n000016c4 55 PUSH    EBP\n000016c5 8b ec      MOV    EBP, ESP\n; After this instruction, EAX contains the address\n; of the _PEB (Process Environment Block) structure for\n; the current process.\n000016c7 64 a1 30 MOV    EAX, FS:[0x30]\n; After this instruction, EAX contains the address\n; of the _PEB_LDR_DATA structure.\n000016cd 8b 40 0c    MOV    EAX, dword ptr [EAX + 0xc]\n; After this instruction, EAX contains the address\n; of InLoadOrderModuleList. This double-linked list\n; contains the loaded modules for the current process.\n000016d0 8b 40 0c    MOV    EAX, dword ptr [EAX + 0xc]\n000016d3 8b 00 MOV    EAX, dword ptr [EAX]\n000016d5 8b 00 MOV    EAX, dword ptr [EAX]\n; After this instruction, EAX contains the base address\n\n```\n\n-----\n\n```\n; of the first module loaded by the current process.\n; The first module loaded by any process is always kernel32.dll.\n000016d7 8b 40 18 MOV    EAX, dword ptr [EAX + 0x18]; The first module loaded by any process is\n\n```\nalways kernel32.dll.\n000016d7 8b 40 18 MOV    EAX, dword ptr [EAX + 0x18]\n\n```\n000016da 5d       POP    EBP\n000016db c3       RET\n\n```\n\nEssentially, the function finds the library address via the Process Environment Block (PEB) structure[6] for the currently\nrunning process. Upon accessing the PEB structure, the function finds the list of loaded modules via the\n_PEB_LDR_DATA structure.[7] Indeed, the kernel32 library is the first element within the InLoadOrderModuleList field of\nthat structure: a double-linked list of loaded modules sorted by loading order. Once the payload has retrieved the\nlibrary’s location, it looks for the address of several exported functions. To start iterating over all the names exported by\nthe library, which are retrieved by parsing the PE header, the export resolution algorithm requires the library base\naddress (in this case kernel32) and a numerical hash. For each exported name, the resolution algorithm computes a\nhash by using a custom hashing function. If the computed hash is equal to the hash provided to the export-resolution\nalgorithm, then it retrieves the memory address for that export from the PE header and eventually returns it to the caller.\n\nThe following code snippet shows a Python equivalent of the resolution algorithm that we reverse-engineered:\n\n```\ndef resolve_export(library_base_address: int, name_hash: int) -> int:\n  # The memory location of the pe_header structure\n  pe_header = library_base_address + 0x3c\n  # The memory location of exports_table\n  exports_table = pe_header + 0x78\n  # The memory location of the library export names\n  # An array of char pointers (null-terminated strings)\n  names = exports_table + 0x20\n  # The memory location of the library export addresses\n  # An array of Relative Virtual Addresses (RAVs)\n  addresses = export_table + 0x1c\n  i = 0\n  while True:\n    # The memory location of the number of export names\n    # included in the export table\n    names_size = exports_table + 0x18\n    if i >= names_size:\n       return 0\n    # A call to the custom hash function\n    candidate_name_hash = hash_name(names[i])\n\n```\n\n-----\n\n```\n    if candidate_name_hash == name_hash:\n       return addresses[i]\n    i += 1\n  return 0\n\n```\n\nThe following code snippet shows a Python equivalent of the custom hashing function implemented in the payload. As\nwe will discuss in section 7.3, API hashing, by showing another and more complex example, API hashing is an antianalysis technique used by malware developers to hide the detail about which library exports are invoked in the code.\n\n```\ndef hash_name(name: str) -> int:\n  name_hash = 0x2326\n  for c in name:\n    current_hash = name_hash\n    current_hash <<= 0x5\n    current_hash += name_hash\n    # ord() returns the ASCII code given a char (“c”)\n    current_hash += ord(c)\n    name_hash = current_hash & 0xffffffff\n  return name_hash\n\n```\n\nTo better understand functionality, we de-hashed the function calls that occur on the payload. From that analysis, we\nconcluded that the payload’s behavior can be summarized in three stages:\n\n1. The payload loads the Encrypted Lokibot file into memory. This file is dropped by the NSIS installer into the\n\ntemp directory.\n\n2. The payload decrypts this file, which turns out to be a Lokibot executable.\n\n3. The payload spawns a new process, injects the executable into its memory space, and starts it.\n\nThe table below provides the details of each step implemented in the payload. The two highlighted entries correspond\nto the only steps not implemented by a library call. Instead, they are implemented by the two functions coded by the\nmalware developer and discussed in sections 6, Encrypted Lokibot, and 7, Lokibot.\n\n_Table 2. The shellcode payload’s behavior, step by step_\n\n|Step|Function|Annotations|\n|---|---|---|\n|1|LoadLibraryW|With this call, the payload loads the shlwapi library to get its address. This address is eventually used to resolve some of the library exports, such as PathAppendW.|\n|2|VirtualAlloc|This call is made to allocate a memory buffer of 450 MiBs (approximately 472 MBs). This buffer is not used, but the rest of the second-level code will get executed if and only if this call succeeds.|\n|3|GetTempPathW|This call gets the path of the temp directory.|\n\n\n-----\n\n|4|PathAppendW|This call concatenates the path to the temp directory (see step 3) with the string “a01jkkyi4ridof2orcun” which is the name of the Encrypted Lokibot file. This is the path to the other file dropped by the NSIS installer.|\n|---|---|---|\n|5|CreateFileW|This call opens the Encrypted Lokibot file with the desired access GENERIC_READ. The payload expects this file to exist on the file system, because it tries to open it with the OPEN_EXISTING option. If the file does not exist, then this call returns an error. Furthermore, if this call does not succeed, then none of the steps that follow get executed.|\n|6|GetFileSize|This call gets the size, in bytes, of the Encrypted Lokibot file. The steps that follow this call are executed if and only if it does not return an error.|\n|7|VirtualAlloc|This call allocates a memory buffer of 104 KiBs (approximately 106 KB), which is the size of the Encrypted Lokibot file. The steps that follow this call are executed if and only if it succeeds.|\n|8|ReadFile|This call reads the content of the Encrypted Lokibot file and loads it into the memory buffer allocated in step 7. The steps that follow this call get executed if and only if it succeeds.|\n|9|DecryptLokibot|This function decrypts the Encrypted Lokibot in memory. Once this is done, the buffer allocated in step 7 will contain a fully functional PE file of Lokibot. For more information about this artifact, see section 7, Lokibot. For more information about the decryption procedure, see section 6, Encrypted Lokibot.|\n|10|InjectLokibot|This function spawns a new process, injects the Lokibot executable into its memory space, and starts the executable. The injection technique is well known as process hollowing. The steps that follow this call are executed if and only if this call fails.|\n|11|GetModuleFileN ame|This call gets the full path to the currently running process, because it is called with a NULL hModule as its first argument.|\n|12|Sleep|This call suspends the execution of the running process for three seconds.|\n|13|GetCommandLi neW|This call retrieves the command-line string for the currently running process.|\n|14|CreateProcess|This call spawns a new process with the same path and command-line string as those of the currently running process.|\n|15|ExitProcess|This call stops the current process and is made if and only if the CreateProcess call in step 14 fails.|\n|16|VirtualFree|This call frees the memory allocated in step 2.|\n|17|ExitProcess|This call stops the current process.|\n\n\nAs stated in the table, the injection function InjectLokibot implements process hollowing.[8] In the very first part of this\nfunction, all API calls are dehashed by calling the API-resolution algorithm and the locator of the library’s base address.\nAfter obtaining the memory addresses of those calls, the injection function creates a new process by invoking the\n\n\n-----\n\nCreateProcessW API, which is exposed by the kernel32 library. Figure 6 shows that the new process executable\ncorresponds to the NSIS installer. InjectLokibot provides both of the following as arguments to CreateProcessW:\n\n  - the current process’s executable path, which is obtained by invoking GetModuleFileName with a NULL\nhModule argument\n\n  - the current process’s command line, which is obtained by invoking GetCommandLineW\n\nFigure 6 shows that the process is created in a suspended state. The sixth argument in CreateProcessW, namely the\ncreation flags, is 0x08000004 which corresponds to the combination of CREATE_NO_WINDOW and\nCREATE_SUSPENDED. The creation of a process in a suspended state is a well-known indicator of process hollowing.\n\n_Figure 6. Process hollowing: a new process is created in a suspended state_\n\nWith the process in a suspended state, the injection function:\n\n1. Gets the main thread-execution context by calling the GetThreadContext API, and stores it in a local variable\n\n2. Reads the base address of the suspended process by invoking the ReadProcessMemory API\n\n3. Unmaps the memory of the suspended process by calling the NtUnmapViewOfSection API and by providing\n\nthe just-read memory address as the second argument\n\n4. Creates a new section by invoking the NtCreateSection API\n\n5. Invokes the NtMapViewOfSection API multiple times with the same arguments, to create a writable view of the\n\njust-created section; the permission set for this view is PAGE_EXECUTE_READWRITE (0x40)\n\n6. Writes the Lokibot executable into the hollowed-out process; this copies the executable by calling the\n\nundocumented API NtWriteVirtualMemory\n\n7. Uses SetThreadContext to set the thread context to the value saved in step 1\n\n8. Calls NtResumeThread; this lets the new process break the suspended state and run independently of the\n\nparent process\n\n9. Terminates the parent by calling the TerminateThread API\n\nLokibot implements process hollowing in many of its instances (Hoang, 2019). In this case, process hollowing is\nimplemented by the Loader rather than the Lokibot executable. The advantage of this method is that the unencrypted\nform of the executable is never hosted on the file system, and that helps it evade common antivirus products. One flaw\nof this method is that the persistence is compromised, because the executable is never placed on the file system. As we\nwill see in section 7, Lokibot, this is not the only flaw in the procedure used by Lokibot to set persistence.\n\n\n-----\n\n### 6. Encrypted Lokibot\n\nWe know that the NSIS Installer drops file a01jkkyi4ridof2orcun into the temp directory. We also know that the Loader\nloads a01jkkyi4ridof2orcun into memory and decrypts it. This section focuses on a01jkkyi4ridof2orcun, which we have\ndubbed Encrypted Lokibot, and on the procedure used to decrypt it. Figure 7 shows a portion of the Encrypted Lokibot\ncontent.\n\n_Figure 7. The Lokibot executable (initial part) in its encrypted form_\n\nThe file contains binary data without any evident meaning. However, after the decryption, Encrypted Lokibot will contain\na well-formed portable executable for the Lokibot malware. Section 7, Lokibot, discusses the capabilities of such an\nartifact. Lokibot decryption is implemented in a dedicated function, which expects (1) a memory buffer that contains the\nentire file and (2) the first key, 81687d7815174c2ba54304545bc506aa, together with its size, 32 bits. Lokibot decrypts\nthe file by updating the provided memory buffer byte by byte.\n\n1. The decryption function does the following:It initializes two buffers of 256 integers each. One of the buffers is a\n\nsecond key used for the decryption.\n\n2. It constructs the second key by starting from the two buffers allocated in the first step.\n\n3. It decrypts the file by looping over each byte of the Encrypted Lokibot file and applying a composite\n\ntransformation that involves two XOR operations with elements of the two keys.\n\nWe reverse-engineered and translated the entire function to Python code:\n\n```\ndef decrypt(payload: bytearray, key_1: bytearray, key_1_size: int) -> None:\n    k = 0\n    l = 0\n    key_2, buffer = [], []\n    # first loop: buffer initialization\n    i = 0\n    while i < 256:\n       key_2.append(i)\n       buffer.append(key_1[i % key_1_size])\n       i += 1\n    # second loop: construct the second key\n    i = 0\n    while i < 256:\n       k = (key_2[i] + k + buffer[i]) & 0x800000ff\n       if k < 0:\n           k = ((k - 1) | 0xffffff00) + 1\n       temp = key_2[k]\n       key_2[k] = key_2[i] \n       key_2[i] = temp\n       i += 1\n\n```\n\n-----\n\n```\n# third loop: decrypt the payload\nk = 0\nj = 0\nwhile j < 106496:\n    i = (i + 1) & 0x800000ff\n    if i < 0:\n       i = ((i - 1) | 0xffffff00) + 1\n    k = (key_2[i] + k) & 0x800000ff\n    if k < 0:\n       k = ((k - 1) | 0xffffff00) + 1\n    temp = key_2[k]\n    key_2[k] = key_2[i]\n    key_2[i] = temp\n    l = (key_2[i] + key_2[k]) & 0x800000ff\n    if l < 0:\n       l = ((l - 1) | 0xffffff00) + 1\n    payload[j] ^= key_1[j % key_1_size]\n    payload[j] ^= key_2[l]\n    j += 1\nreturn\n\n```\n\nHere is a part of the decrypted Encrypted Lokibot file:\n\n_Figure 8. The Lokibot executable (initial part) after the decryption_\n\n### 7. Lokibot\n\nThe fourth artifact is the final payload of the attack chain and is a 32-bit portable executable (PE32) compatible with 32bit as well 64-bit Microsoft Windows operating systems. As stated earlier, the unencrypted form of this executable is\nnever saved in the file system; only its encrypted form, the Encrypted Lokibot file, is saved in the file system. This\nsection analyzes this executable.\n\nThe presence of a Rich Header suggests that PE32 has been developed in Visual Studio. The Rich Header section\ncontains information about the build and the compilation suite. This information is stored as an XOR-encrypted array of\nelements, each referring to a specific product within the Visual Studio suite. In the case of Lokibot, the Rich Header\nreveals that the following tools are used:\n\n\n-----\n\n_Table 3. Building and compilation suite (source: Rich Header)_\n\nProduct Build\n\nUtc1500_C Visual Studio 2008\n\nImplib710 Visual Studio 2003\n\nMasm710 Visual Studio 2003\n\nUtc1800_LTCG_CPP Visual Studio 2013\n\nImport (old) Visual Studio\n\nMasm900 Visual Studio 2008\n\nImport Visual Studio\n\nImplib900 Visual Studio 2008\n\nUtc1800_CPP Visual Studio 2013\n\nLinker1200 Visual Studio 2013\n\nThis suggests that the artifact has been coded in C++. The building suite seems to date no earlier than 2013, and the\ncompilation timestamp dates back to June 23, 2016, 16:04:21 UTC. Although the builders might have tampered with the\nmeta information, it is possible the sample was built many years ago and is still being distributed.\n\nThe overall and per-section levels of entropy are not high enough to suggest the presence of packed code:\n\n_Table 4. Entropy per section_\n\nOverall entropy 6.053856\n\nSection “.text” entropy 6.492048\n\nSection “.rdata” entropy 4.255999\n\nSection “.data” entropy 0.321716\n\nSection “.x” entropy 0.209392\n\nHowever, the Import Table and Import Address Table (IAT) are small and that may indicate the intention of protecting\nthe executable from static analysis techniques. The Import Table contains only four libraries (ws2_32.dll, kernel32.dll,\nole32.dll, and oleaut32.dll), and the IAT contains only the following 19 calls:\n\n_Table 5. APIs declared in the Import Address Table_\n\n|Product|Build|\n|---|---|\n|Utc1500_C|Visual Studio 2008|\n|Implib710|Visual Studio 2003|\n|Masm710|Visual Studio 2003|\n|Utc1800_LTCG_CPP|Visual Studio 2013|\n|Import (old)|Visual Studio|\n|Masm900|Visual Studio 2008|\n|Import|Visual Studio|\n|Implib900|Visual Studio 2008|\n|Utc1800_CPP|Visual Studio 2013|\n|Linker1200|Visual Studio 2013|\n\n|Overall entropy|6.053856|\n|---|---|\n|Section “.text” entropy|6.492048|\n|Section “.rdata” entropy|4.255999|\n|Section “.data” entropy|0.321716|\n|Section “.x” entropy|0.209392|\n\n|Call|DLL|\n|---|---|\n|getaddrinfo|ws2_32.dll|\n|freeaddrinfo|ws2_32.dll|\n|closesocket|ws2_32.dll|\n\n\n-----\n\n|WSAStartup|ws2_32.dll|\n|---|---|\n|socket|ws2_32.dll|\n|send|ws2_32.dll|\n|recv|ws2_32.dll|\n|connect|ws2_32.dll|\n|GetProcessHeap|kernel32.dll|\n|HeapFree|kernel32.dll|\n|HeapAlloc|kernel32.dll|\n|SetLastError|kernel32.dll|\n|GetLastError|kernel32.dll|\n|CoCreateInstance|ole32.dll|\n|CoInitialize|ole32.dll|\n|CoUninitialize|ole32.dll|\n|VariantInit|oleaut32.dll|\n|SysFreeString|oleaut32.dll|\n|SysAllocString|oleaut32.dll|\n\n\nThe calls included in the ws2_32.dll library are particularly interesting because they are invoked by Lokibot to implement\na socket-based C&C communication channel.\n\n#### 7.1. Attribution via section .x\n\nA characteristic of this sample is section label .x: an unusual but well-known signature for Lokibot; see an example in\nHoang, 2019. Section .x is exactly 8 KB in size and contains the encrypted C&C URL as well as the code responsible\nfor its decryption. The URL decryption algorithm consists of a bytewise XOR with the 0xFF key:\n\n```\n004a0016 bb ff ff    MOV EBX, 0xdddfffff\n004a001b be 74 00 MOV ESI, XORED_C2_URL                \n004a0020 90 NOP\n004a0021 90 NOP\n004a0022 90 NOP\n004a0023 90 NOP\n           LAB_004a0024                  XREF[1]:   004a002e(j) \n004a0024 30 1e      XOR byte ptr [ESI]=>XORED_C2_URL, BL\n004a0026 46 INC ESI\n004a0027 90 NOP\n004a0028 90 NOP\n004a0029 90 NOP\n004a002a 90 NOP\n004a002b 80 3e 00 CMP byte ptr [ESI]=>STRING_TERMINATOR, 0x0\n004a002e 75 f4      JNZ    LAB_004a0024\n\n```\n\n-----\n\nThe C&C URL for the analyzed sample is stored from offset 0x18074 to offset 0x1809C. We were able to extract and\ndecrypt it, to produce hxxp://173[.]208[.]204[.]37/k[.]php/SczbkxCQZQyVr. The section’s uncommon name, consistent\nsize across the years, and the C&C URL encryption based on a 0xFF XOR-ring key, compelled us to develop a YARA\nrule:\n\n```\nrule lokibot {\n    meta:\n        description = \"Lokibot detection rule based on .x section and C&C decoding\"\n        author = \"gpellegrino@infoblox.com\"\n    strings:\n        $c2decoding = {BB FF FF DF DD BE 74 00 4A 00 90 90 90 90 30 1E}\n    condition:\n        uint16(0) == 0x5A4D\n        and filesize < 105KB\n        and uint16(0x260) == 0x782E\n        and uint16(0x270) == 0x2000\n        and $c2decoding in (uint32(0x274)..uint32(0x274)+0x2000)\n}\n\n```\n\nThanks to that rule, we discovered that 62 additional samples were submitted on VirusTotal from April 2021 to early July\n2021.\n\n#### 7.2. Heaven’s Gate\n\nThe malware implements the well-known Heaven's Gate technique to evade antivirus detection on Windows systems\nolder than Windows 10. Heaven’s Gate was first reported by Biv in 2009 and has since been discussed by Unterbrink\nand Brumaghin (2019), Ionescu (2015), and other researchers. Since the introduction of the 64-bit versions of Windows\nXP, a 32-bit process can run in native 64-bit systems thanks to the WoW64 subsystem: a virtualized 32-bit environment\nrunning inside a 64-bit operating system. WoW64 executes a 32-bit process in a sandbox and isolates it from the outer\n64-bit environment. However, Heaven’s Gate allows for a process to escape the WoW64 sandbox and lets it execute\nnative 64-bit code. A malware would try to escape the WoW64 subsystem because antivirus software might not hook\ncalls to 64-bit libraries that are made from 32-bit processes.\n\nThe code snippet below shows one of the four instances of the Heaven’s Gate technique we observed in the sample\nunder analysis. In the sample, segment 0x33 is pushed onto the stack first, and then the address where the x64 code\nresides. The RETF (return far) instruction makes use of the pushed values to direct the execution out of the x86\nsandbox of the running process.\n\n```\n004072fa 6a 33 PUSH 0x33 ; x64 segment selector\n004072fc e8 00 00 CALL    $ + 5 ; pushes address 0x407301 on the stack\n00407301 83 04 24 05 ADD    [ESP + 0x48 + var_48], 5 ; sets the address to 0x00407306\n00407305 cb       RETF ; jump to the x64 code starting at 0x00407306\n...\n...\n... \n00407358 e8 00 00 CALL    $ + 5 ; pushes address 0x0040735D on the stack\n0040735d c7 44 24 MOV dword ptr [ESP + 0x4], 0x23 ; x86 segment selector\n\n```\n\n-----\n\n```\n00407365 83 04 24 0d ADD dword ptr [ESP], 0xd ; sets the address to 0x0040736A\n00407369 cb       RETF ; jump to x86 code starting at 0x0040736A\n\n```\n\nIn the bottom part, the similar jump back to the x86 code is accomplished by pushing the 0x23 segment onto the stack\nand the address where the 32-bit code resides. As for the previous switch, the RETF instruction will make use of the\npushed values to redirect the execution into the 32-bit land.\n\nHeaven’s Gate is effective only on versions of Windows that preceded Windows 10. Windows 10 introduced the socalled Control Flow Guard feature, which enforces compilation as well as runtime controls, some of them addressing the\nHeaven's Gate, on any indirect call. This might strengthen the hypothesis (formulated while we analyzed the Rich\nHeader) that the executable is old. Another possibility is that those code regions were copied from some older\ncodebase.\n\n#### 7.3. API hashing\n\nBecause malware analysis takes time, the reverse-engineering efforts must be limited to small portions of malware\ncode. Selecting the right parts of code and omitting irrelevant ones saves time and resources for truly impactful\nactivities: persistence setting, exploitation, and analyzing the parts of code that expose relevant functionalities of\nmalware. A common way to quickly understand what a portion of code does is to check which API functions it invokes.\nUnfortunately, the anti-analysis technique of API hashing can hinder this process by obfuscating API function calls\nmentioned in the code. The code snippet below is an example of the Lokibot API hashing technique:\n\n```\n00405eff 55 PUSH    EBP\n00405f00 8b ec      MOV    EBP, ESP\n00405f02 5d       POP    EBP\n00405f03 e9 1c fa    JMP    LAB_00405924\n...\n...\n...\n           LAB_00405924 \n00405924 55 PUSH    EBP\n00405925 8b ec      MOV    EBP, ESP\n00405927 6a 00 PUSH 0x0\n00405929 6a 00 PUSH 0x0\n0040592b 68 d4 5b    PUSH 0xd6865bd4 ; hash for the StrStrW API call\n00405930 6a 02 PUSH 0x2 ; DLL identifier for shlwapi.dll\n00405932 e8 ae d8    CALL    getApiByDllIdAndApiHash\n00405937 ff 75 0c    PUSH    dword ptr [EBP + param_2] ; second argument to StrStr\n0040593a ff 75 08 PUSH    dword ptr [EBP + param_1] ; first argument to StrStr\n0040593d ff d0      CALL    EAX ; implicit call to StrStrW\n0040593f 5d       POP    EBP\n00405940 c3       RET\n\n```\n\nThe code invokes the StrStrW API function included in the shlwapi DLL, but there is no mention of this API call in the\ncode. Instead, there is an invocation of function getApiByDllIdAndApiHash, which accepts four arguments, only the first\ntwo of which are meaningful:\n\n  - the DLL identifier: 2 in the code snippet\n\n  - the API hash: 0xd6865bd4 in the code snippet\n\n\n-----\n\ngetApiByDllIdAndApiHash uses these arguments to find and return the address where StrStrW API has been loaded.\nThis address is stored in the EAX register and called at the very end. To protect almost all API invocations made by the\nsample, this schema is replicated many times.\n\nAPI hashing schema consists of two steps:\n\n1. Obtain the memory address of a DLL, starting from a numerical DLL identifier.\n\n2. Use the obtained DLL address and a hash to obtain the memory address of the API function. This step starts if,\n\nand only if, step 1 was successful.\n\nWe will discuss these two steps then the function for calculating a hash.\n\n##### 7.3.1. DLL resolution\n\nThe first step of the API hashing schema consists of two special cases and a general case. The two special cases are\nhandled the same way and refer to two specific DLLs: kernel32 with identifier 0, and ntdll with identifier 1. In both cases,\nthe DLL identifier is associated with a hash specific to each DLL: 0xf96af9ce for kernel32, and 0xefd4f033 for ntdll. The\nhash is then passed to a function responsible for iterating through all loaded DLLs, extracting a DLL name, computing\nthe hash of that name, and checking whether that hash matches the one provided to the function. If there is a match,\nthe function returns the DLL memory address; otherwise, it returns NULL.\n\nThe code snippet below shows how Lokibot gathers the relevant information, namely the DLL name and the DLL\nmemory address, from the loaded modules. Lokibot parses the Process Environment Block (PEB) structure for the\ncurrent process and then reaches _PEB_LDR_DATA_STRUCTURE,[9] which contains the loaded DLLs. Within\n_PEB_LDR_DATA_STRUCTURE, the sample accesses InLoadOrderModuleList, which is a double-linked list that\ncontains an element for each loaded DLL. The list is sorted by loading order.\n\n```\n00403187 64 a1 30 MOV    EAX, FS:[0x30] ; address of the _PEB structure\n0040318d 89 45 fc    MOV    dword ptr [EBP + local_8], EAX\n00403190 8b 45 fc    MOV    EAX, dword ptr [EBP + local_8]\n; address of the _PEB_LDR_DATA structure\n00403193 8b 40 0c    MOV    EAX, dword ptr [EAX + 0xc]\n00403196 8b 58 0c    MOV    EBX, dword ptr [EAX + 0xc] ; address of the\nInLoadOrderModuleList\n00403199 8b f3 MOV    ESI, EBX\n           LAB_0040319b ; start of the loop on the loaded DLLs\n; base address of the DLL (DllBase)\n0040319b 8b 46 18 MOV    EAX, dword ptr [ESI + 0x18] \n; address of the full DLL name (FullDllName)\n0040319e ff 76 28 PUSH    dword ptr [ESI + 0x28] \n...\n...\n...\n\n```\n\nkernel32 and ntdll will both be in this list, for any process, because these libraries include fundamental APIs for\nexecuting any program. Each element in InLoadOrderModuleList is of type _LDR_DATA_TABLE_ENTRY and contains,\namong many fields, the DLL address DllBase and the full name of DLL, FullDllName, which is the path to the DLL on\ndisk. The code snippet below shows the first part of _LDR_DATA_TABLE_ENTRY as it is defined in the ntdll library:\n\n\n-----\n\n```\n_LDR_DATA_TABLE_ENTRY\n  +0x000 InLoadOrderLinks : _LIST_ENTRY\n  +0x008 InMemoryOrderLinks : _LIST_ENTRY\n  +0x010 InInitializationOrderLinks : _LIST_ENTRY\n  +0x018 DllBase     : Ptr32 Void\n  +0x01c EntryPoint    : Ptr32 Void\n  +0x020 SizeOfImage   : Uint4B\n  +0x024 FullDllName   : _UNICODE_STRING\n  +0x02c BaseDllName   : _UNICODE_STRING\n  +0x034 FlagGroup    : [4] UChar\n\n```\n\nThe DllBase field is located at offset 0x18. The FullDllName field is located at offset 0x24, which appears to be\nunaligned with the offset accessed by the malware, 0x28. However, we need to consider that FullDllName is of type\n_UNICODE_STRING:[10] a structure that contains two additional integer fields before the actual string buffer, at relative\noffset 0x4. Therefore, when the malware tries to access offset 0x28 within _LDR_DATA_TABLE_ENTRY, it is actually\ntrying to access the string buffer located four bytes after the starting address of FullDllName:\n\n_Figure 9. Part of the array that contains the names of some DLLs used by Lokibot_\n\nThe general case regards 11 additional DLLs whose API functions the malware will attempt to call. On all those\noccasions, the DLL identifier is not mapped to any hash but is, instead, mapped to an index of a memory buffer that\ncontains the DLL names of those 11 DLLs. The DLL names are encoded in the UTF-16 little endian, and the buffer is\nfilled every time the DLL resolution function is invoked. The code snippet shows the part of the buffer that contains the\nDLL names as they appear in the debugger. After the DLL name associated with the provided identifier is obtained, it is\nused to invoke the LoadLibraryW API, which is exposed by the kernel32 module. The API loads the requested DLL and\nreturns its handle. The invocation of LoadLibraryW is again protected by the API hashing procedure, which is called\nrecursively. However, because LoadLibraryW is exposed by kernel32, the DLL resolution falls into one of the\naforementioned special cases, and the recursion stops after a single step.\n\nHere is the complete mapping between DLL identifiers and DLL names. Curiously enough, two identifiers point to the\nsame DLL (gdi32).\n\n\n-----\n\n_Table 6. Mapping between DLL identifiers and DLL names_\n\nDLL identifier DLL name\n\n0 kernel32\n\n1 ntdll\n\n2 shlwapi\n\n3 CRYPT32\n\n4 WININET\n\n5 urlmon\n\n6 NETAPI32\n\n7 WS2_32\n\n8 user32\n\n9 ADVAPI32\n\n10 SHELL32\n\n11 gdiplus\n\n12 gdi32\n\n13 ole32\n\n14 gdi32\n\n##### 7.3.2. API resolution\n\nIn this step, the API hashing schema requires the address of a DLL and a hash to find the address of an API. The inner\nworkings of the API resolution algorithm are similar to those of the algorithm used for the special cases of kernel32 and\nntdll in the first step. That is, the function implemented in this step iterates through the table of DLL name pointers. The\ntable is part of the PE export table that contains the array of the exported names. For each name in the table, the\nfunction computes the hash of the name and compares the result with the hash provided as an argument. If the two\nhashes match, the function returns the address of the matching export by calling the GetProcAddress API.\n\nGetProcAddress is not directly invoked, because it is hidden by the API hashing technique. Because GetProcAddress is\nexposed by the kernel32 library, the resolution falls into one of the special cases described at the beginning of section\n7.3, API hashing. If the function cannot find any match for the provided hash, then it returns NULL. The following code\nsnippet clarifies how the APIresolution function gathers API names:\n\n|DLL identifier|DLL name|\n|---|---|\n|0|kernel32|\n|1|ntdll|\n|2|shlwapi|\n|3|CRYPT32|\n|4|WININET|\n|5|urlmon|\n|6|NETAPI32|\n|7|WS2_32|\n|8|user32|\n|9|ADVAPI32|\n|10|SHELL32|\n|11|gdiplus|\n|12|gdi32|\n|13|ole32|\n|14|gdi32|\n\n```\n004030d2 8b 7d 08 MOV    EDI, dword ptr [EBP + param_1] ; DLL’s base address\n004030d5 33 db      XOR    EBX, EBX\n004030d7 c1 e8 10    SHR    EAX, 0x10\n004030da 8b 57 3c    MOV    EDX, dword ptr [EDI + 0x3c] ; start of the PE header\n\n```\n\n-----\n\n```\n004030dd 89 55 f4 MOV    dword ptr [EBP + local_10], EDX\n; The following instruction computes the offset of the export table in the PE header\n004030e0 8b 74 3a 78 MOV    ESI, dword ptr [EDX + EDI*0x1 + 0x78]\n; The following instruction computes the address of the export table\n004030e4 03 f7 ADD    ESI, EDI \n...\n...\n...\n; The following instruction computes the offset of the AddressOfNames field in the export table\n004030f3 8b 4e 20 MOV    ECX, dword ptr [ESI + 0x20]\n004030f6 8b 46 24 MOV    EAX, dword ptr [ESI + 0x24]\n; The following instruction computes the address of the AddressOfNames field in the export table\n004030f9 03 cf      ADD    ECX, EDI\n\n```\n\nIn the code above, the EDI register holds the DLL address as it was passed to the APIresolution function. The EDX\nregister holds the information placed at offset 0x3c from the DLL base address; that offset is where the PE header\nstarts. The ESI register holds the offset coming out of the summation of the PE header, the DLL base address, and\n0x78. Because 0x78 is the offset of the export table, the ESI register will contain the offset to that table, starting from the\nbeginning of the DLL. After the summation between the contents of the ESI and EDI registers, ESI will hold the memory\naddress of the export table. Because offset 0x20 within the export table points to the AddressOfNames array, the\nsummation between the ECX and EDI registers at the last line will produce the address of that array. As already\nmentioned, this array will get scanned to fetch the names of all API functions exported by the DLL.\n\n##### 7.3.3. The hash function\n\n```\ndef custom_hash(name: str, length: int) -> int:\n  name_hash = 0xffffffff\n  i = 0\n  while length != 0:\n    length -= 1\n    name_hash ^= ord(name[i])\n    i += 1\n    j = 8\n    while True:\n       if (name_hash & 0xff) & 1:\n        name_hash ^= 0x4358ad54\n      name_hash >>= 1\n      j -= 1\n       if j == 0:\n         break\n  return ~name_hash & 0xffffffff\n\n```\n\nBoth stages of the API hashing schema rely on the same custom hashing function to compute DLL names and hashes\nof API function names at runtime. We reverse-engineered and converted the hashing function into Python code:\n\n\n-----\n\nAlthough the hashing function does not vary, there is some difference in how it is used within the two steps of the\nprocess. As the code snippet shows, the number of iterations of the outer loop depends on what we call the length\nargument. When the DLL name is being hashed, in the special case of kernel32 and ntdll, the provided length argument\nis doubled. The reason for this lies in how those DLL names are encoded in memory. Because kernel32 and ntdll\nnames are encoded in UTF16 little endian, the characters in those strings are padded with NULL (0x00) symbols.\nTherefore, the length argument is set to two times the string length. The same does not hold for the API calls; as shown\nin the following sample taken at debugging time, these calls are encoded in UTF-8.\n\n_Figure 10. API names are encoded in UTF-8_\n\nWhen the hash function is invoked at the second stage of API hashing resolution, the length argument is just set to the\nstring length.\n\n#### 7.4. A vaccine against Lokibot\n\nOne of Lokibot’s very first moves is to check for the existence of a specific mutex. If this mutex already exists, then\nLokibot quits immediately, to avoid having multiple instances of the malware running on the same system. This check is\nimplemented in two consecutive steps:\n\n1. Lokibot invokes the CreateMutexW API, exposed by kernel32.\n\n2. Lokibot invokes the GetLastError API to determine whether an error of type ERROR_ALREADY_EXISTS was\n\nraised.\n\nThe implementation of this behavior is reported in the code snippet below. The 0xb7 value, checked at the end of the\nsnippet, corresponds to the ERROR_ALREADY_EXISTS error,[11] which indeed is raised by CreateMutexW whenever\nthe requested mutex already exists:\n\n```\n00413982 e8 10 04    CALL    getMutexLabel\n00413987 53 PUSH    EBX\n00413988 53 PUSH    EBX\n00413989 68 f4 7d    PUSH 0xcf167df4 ; hash for CreateMutexW\n0041398e 53 PUSH    EBX\n\n```\n\n-----\n\n```\n0041398f 8b f0 MOV    ESI, EAX\n; API-hashing protection for CreateMutexW\n00413991 e8 4f f8    CALL    getApiByDllIdAndHash\n00413996 56 PUSH    ESI\n00413997 33 f6      XOR    ESI, ESI\n00413999 46       INC    ESI\n0041399a 56 PUSH    ESI\n0041399b 53 PUSH    EBX\n0041399c ff d0      CALL    EAX\n0041399e ff 15 10    CALL    dword ptr [->KERNEL32.DLL::GetLastError]\n; check whether the error code is ERROR_ALREADY_EXISTS (0xb7)\n004139a4 3d b7 00 CMP    EAX, 0xb7\n004139a9 75 07      JNZ    LAB_004139b2\n004139ab 53 PUSH    EBX\n004139ac e8 d0 01    CALL    exitProcess\n004139b1 59 POP    ECX\n\n```\n\nThe mutex label requested by Lokibot is generated by the function we refer to as getMutexLabel. This function is\ndeterministic in its way of generating the mutex label starting from the machine GUID. The machine GUID is a string\ncreated by Windows at installation time and is unique for each machine. The machine GUID has the following format:\nXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX where X is an hex digit (X may have the following values: 0, 1, 2, 3,\n4, 5, 6, 7, 8, 9, a, b, c, d, e, f). The GUID is stored as a value for the SOFTWARE\\Microsoft\\Cryptography\\MachineGuid\nregistry key.\n\nAfter extracting the machine GUID by calling APIs RegOpenKeyExA and RegQueryValueExA, the Lokibot computes its\nMD5 hash by calling APIs CryptAcquireContextW, CryptCreateHash, and CryptGetHashParam, which are exposed by\nDLL ADVAPI32 and protected by the API-hashing technique discussed earlier. We know that the end goal is to obtain\nthe MD5 hash, because CryptCreateHash is invoked with the CALG_MD5 constant as the Algid argument.[12] Here is a\ncode snippet for CryptCreateHash:\n\n```\n; the invocation of CryptCreateHash API is protected by the API hashing \n; technique described in section 7.3, API hashing\n004038c0 e8 20 f9    CALL    getApiByDllIdAndHash\n004038c5 8d 4d fc    LEA    ECX=>local_8, [EBP + -0x4]\n004038c8 51 PUSH    ECX\n004038c9 6a 00 PUSH 0x0\n004038cb 6a 00 PUSH 0x0\n004038cd 68 03 80 PUSH 0x8003 ; CALG_MD5 Algid argument\n004038d2 56 PUSH    ESI\n004038d3 ff d0      CALL    EAX ; a call to CryptCreateHash\n\n```\n\nMD5 of the machine GUID is manipulated by upper-casing all its characters, encoding it in UTF8, and truncating it at the\n24[th] character. Encoding is accomplished by invoking the function MultiByteToWideChar, which is exposed by kernel32\nDLL. For example, assume the GUID for a hypothetical machine is b8400c54-53cb-4b8d-ae87-eeb55841773a. The\nMD5 hash of that GUID is 9efd2ea6da53da851313f31cd3db8399; after applying the transformations, the hash is\n\n\n-----\n\nconverted into string 9EFD2EA6DA53DA851313F31C and will be the label for the mutex that this variant of Lokibot will\ncheck on the hypothetical machine.\n\nBecause the mutex label is computed deterministically, we can create it after we determine a machine GUID. Moreover,\nwe can create the mutex before Lokibot runs on a particular machine! That will automatically protect the machine\nagainst the threat posed by this malware. Indeed, when Lokibot runs on a machine and tries to create the mutex, it will\ncatch ERROR_ALREADY_EXISTS and eventually terminate the execution.\n\nTo demonstrate this line of defense, we developed a Proof of Concept (PoC) called Lokibot Vaccine, in Appendix B.\nLokibot Vaccine reads the machine GUID and creates the mutex label by following the process used by Lokibot.\nFurthermore, Lokibot Vaccine tries to push the mutex by calling CreateMutex. If it finds that the mutex has already been\nset by another process, then it will conclude that a Lokibot sample is already running on the system; otherwise, it will\ncreate the mutex. From that moment onward, potential Lokibot samples that use the mutex as an infection marker will\nhave no chance to expose their malicious behavior, because after calling API CreateMutexEx, they will get\nERROR_ALREADY_EXIST.\n\n_Figure 11. The result of running vaccinator.exe on a system where lokibot.exe is running_\n\nFigure 12 shows what happens when the PoC is running on a system and a Lokibot sample is launched. As can be\nseen from the API monitoring for the lokibot process, shown in the right part of the figure, the malware just reads the\nmachine GUID and then exits.\n\n\n-----\n\n_Figure 12. Lokibot immediately terminates when launched on a system running Lokibot Vaccine_\n\nThe complete source code for the PoC is provided in Appendix B.\n\n#### 7.5. The failed persistence\n\nPersistence denotes the actions that enable a piece of malware to run again after the system reboots. This Lokibot\nvariant tries to set persistence by following a series of stages, but it fails. The analysis of this failure provides support for\nthe hypothesis of Lokibot being edited by a second actor who had no access to the original source code.\n\nLokibot attempts to set persistence by\n\n1. Generating the persistence directory’s name\n\n2. Creating the persistence directory\n\n3. Moving the Lokibot executable into the persistence directory\n\n4. Renaming the executable\n\n5. Decrypting the registry-based persistence subkey (RunKey)\n\n6. Setting the subkey to the path of the Lokibot executable\n\n7. Altering both the Lokibot executable and the persistence directory attributes to hide them and make them more\n\ndifficult to remove\n\nWe will now go through these stages in more detail. Lokibot moves, creates, and maintains three files during its\nexecution:\n\n  - a database that contains the hashes of all exfiltrated bundles of files (see section 7.4.2, Data exfiltration)\n\n  - a lock (.lck) file created to prevent concurrent access to shared resources\n\n  - the Lokibot executable moved when persistence is being set\n\nAll three files are located in a directory that we call the persistence directory. Lokibot creates it as a subdirectory of\n%APPDATA%, whose address it obtains by calling API SHGetFolderPathW, which is exposed by the SHELL32 library.\nSHGetFolderPathW is a deprecated API used to give access to many standard Windows directories, each univocally\n\n\n-----\n\nidentified by the corresponding CSIDL constant. Lokibot calls SHGetFolderPathW with the CSIDL argument set to 0x1a,\nwhich corresponds to %APPDATA%:[13]\n\n```\n; in the setPersistence function:\n;-------------------------------00412b56 6a 1a      PUSH 0x1a ; CLSID for the %APPDATA% directory\n; generate the path for the persistence folder\n00412b58 e8 f9 14    CALL    getFolderPath\n; in the getFolderPath function:\n;--------------------------00404077 83 c4 0c    ADD    ESP, 0xc\n0040407a 57 PUSH    EDI\n0040407b 57 PUSH    EDI\n0040407c 68 52 18 PUSH 0xc7f71852 ; hash for the SHGetFolderPathW API\n00404081 6a 0a      PUSH 0xa\n00404083 e8 5d f1    CALL    getApiByDllIdAndHash ; API-hashing resolution\n00404088 56 PUSH    ESI\n00404089 57 PUSH    EDI\n0040408a 57 PUSH    EDI\n; param_1 is the CLSID for %APPDATA% as it was passed;\n; by the setPersistence function\n0040408b ff 75 08 PUSH    dword ptr [EBP + param_1]\n0040408e 57 PUSH    EDI\n0040408f ff d0      CALL    EAX ; a call to SHGetFolderPathW\n\n```\n\nLokibot creates the persistence directory’s name by invoking the getMutexLabel function (see section 7.4, A vaccine\nagainst Lokibot). This function returns a label after hashing the machine GUID. The persistence directory’s name will be\nthat label’s substring from character 8 to character 13. To illustrate, for label 9EFD2EA6DA53DA851313F31C, the\ndirectory’s name will be 6DA53D.\n\nLokibot then calls API CreateDirectoryW to create a persistence directory and then calls API MoveFileExW to move the\nexecutable from its current position to the directory:\n\n\n-----\n\n```\n; EDI register contains the persistence directory path.\n00412c04 57 PUSH    EDI \n; CreateDirectoryW function is called via API hashing.\n00412c05 e8 58 10    CALL    CreateDirectoryW_wrapper\n00412c0a 59 POP    ECX\n00412c0b 85 c0      TEST    EAX, EAX\n00412c0d 74 34      JZ     LAB_00412c43\n; ESI register contains the current position of the Lokibot executable.\n00412c0f 56 PUSH    ESI\n; EBX register contains the destination position of the Lokibot executable.\n00412c10 53 PUSH    EBX\n; MoveFileExW function is called via API hashing.\n00412c11 e8 90 14    CALL    MoveFileExW_wrapper\n00412c16 59 POP    ECX\n00412c17 59 POP    ECX\n; Check the exitus of the MoveFileExW call.\n00412c18 85 c0      TEST    EAX, EAX\n00412c1a 75 0b      JNZ    LAB_00412c27\n; If moving the file fails, then copy it.\n; In this case EAX register contains 0. By pushing it as the third\n; argument to CopyFileW, Lokibot is overwriting the destination.\n00412c1c 50 PUSH    EAX\n00412c1d 56 PUSH    ESI\n00412c1e 53 PUSH    EBX\n; CopyFileW function is called via API hashing.\n00412c1f e8 35 10    CALL    CopyFileW_wrapper\n\n```\n\nIf MoveFileExW returns an error, then Lokibot copies the executable by invoking API CopyFileW. (SHGetFolderPathW,\nCreateDirectoryW, and MoveFileExW are all exposed by the kernel32 library). After moving or copying the executable,\nLokibot renames it. The new name for the executable is again obtained from the label returned by the call to\ngetMutexLabel. Actually, the executable name will be the label substring from character 8 to character 13. To illustrate,\nfor label 9EFD2EA6DA53DA851313F31C, the executable’s name will be DA8513.exe.\n\nTo gain persistence, Lokibot sets a persistence registry key to point to the malware’s executable. The registry key\nconsists of a root-key and a sub-key. Common registry sub-keys for enabling persistence are\n\\Software\\Microsoft\\Windows\\CurrentVersion\\Run, RunOnce, RunServices, and RunServicesOnce. The sub-key is\nhardcoded into the binary in an encrypted form; we know this because Lokibot decrypts it by invoking functions\nCryptAcquireContextW, CryptImportKey, CryptSetKeyParam, and CryptDecrypt, which are exported by the ADVAPI32\nlibrary. Those invocations are protected by the API-hashing technique described in section 7.3, API hashing. When we\ninspect the PUBLICKEYSTRUC[14] BLOB passed as the second argument to the CryptImportKey function, we can see\nthat the subkey is encrypted by 3DES:\n\n\n-----\n\n_Figure 13. The PUBLICKEYSTRUC blob as it looks in the debugger_\n\nThis table shows the PUBLICKEYSTRUC BLOB that was found by using the debugger.\n\n_Table 7. PUBLICKEYSTRUC blob’s structure_\n\nField Value Annotation\n\nbType 08 PLAINTEXTKEYBLOB value that indicates a session key\n\nbVersion 02 Contains the version number of the key BLOB format\n\nreserved 0000 Reserved and set to 0\n\nIndicates that the encryption is 3DES (Constant\naiKeyAlg 03 66 00 00\nCALG_3DES value for ALG_ID)\n\nencryptedKeyLength 18 00 00 00 Size of the encrypted key, in this case 24 bits (0x18)\n\nC7 A4 37 D0 2C AD D3\n43 20 E9 D0 6C 89 E8 78\n\nencryptedKey Encrypted key\n\n6C FA F6 BD B2 29 E2\nF2 9E\n\nThe encrypted registry sub-key is stored from file offsets 0x17410 and 0x17440. Inspecting the result of CryptDecrypt\nclarifies that the sub-key corresponds to a persistence point. The following screenshot taken from the debugger shows\n\\Software\\Microsoft\\Windows\\CurrentVersion\\Run:\n\n_Figure 14. A correct persistence key is decrypted by Lokibot_\n\n|Field|Value|Annotation|\n|---|---|---|\n|bType|08|PLAINTEXTKEYBLOB value that indicates a session key|\n|bVersion|02|Contains the version number of the key BLOB format|\n|reserved|0000|Reserved and set to 0|\n|aiKeyAlg|03 66 00 00|Indicates that the encryption is 3DES (Constant CALG_3DES value for ALG_ID)|\n|encryptedKeyLength|18 00 00 00|Size of the encrypted key, in this case 24 bits (0x18)|\n|encryptedKey|C7 A4 37 D0 2C AD D3 43 20 E9 D0 6C 89 E8 78 6C FA F6 BD B2 29 E2 F2 9E|Encrypted key|\n\n\n-----\n\nIf the malware returned that registry sub-key, it would obtain persistence on the infected system. However, right after\nthe call to CryptDecrypt, there is a jump instruction leading to section .x (see section 7.1, Attribution via section .x),\nwhere the buffer that contains the registry subkey gets overwritten with the encoded C&C URL. Eventually, Lokibot\nencodes this buffer to UTF-8 by calling the function MultiByteToWideChar, which is exposed by the kernel32 library.\nNow, the registry sub-key contains nonsense characters:\n\n_Figure 15. The buffer that contains the persistence key is overwritten with nonsense characters_\n\nWe do not know why the code has a jump to .x even though a correct registry sub-key has been decrypted. However,\nwe believe that this modification was made later, by an actor other than the original developer of Lokibot. The actor\nwanted to make Lokibot non-persistent and, having no access to the original source code, implemented this mechanism\nto sabotage the original persistence setting.\n\nAfter decrypting the registry’s sub-key part, Lokibot has everything it needs to set persistence in the registry. It invokes\nAPI SHRegSetPathW (exposed by the shlwapi library) with the first argument as 0x80000001 or 0x80000002, which\ncorresponds to the registry root key HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE:\n\n_Figure 16. The registry key set by Lokibot in its failed persistence attempt_\n\n```\n00412c92 56 PUSH    ESI\n00412c93 57 PUSH    EDI\n00412c94 e8 24 34    CALL    isCallerBuiltinAdmin\n00412c99 6a 0c      PUSH 0xc\n00412c9b 59 POP    ECX\n00412c9c be 10 88 MOV    ESI, DAT_00418810 \n; The return value of isCallerBuiltinAdmin is stored at location [EBP + 0x8].\n00412ca1 89 45 08 MOV    dword ptr [EBP + 0x8], EAX\n...\n...\n...\n00412cea 6a 00 PUSH 0x0 ; fifth unused argument of SHRegSetPathW\n; After the following instruction, ECX will contain 0x0.\n00412cec 33 c9      XOR    ECX, ECX \n; [EBP + 0x8] contains 0x1 if the user running Lokibot is\n; a built-in admin. Otherwise, it contains 0x0. Therefore, the following\n; comparison will set the zero flag in the latter case.\n00412cee 39 4d 08 CMP    dword ptr [EBP + 0x8], ECX\n\n```\n\n-----\n\n```\n00412cf1 53 PUSH    EBX ; EBX contains the path to Lokibot\n; The location [EBP + param_2] contains the key name to be set.\n00412cf2 ff 75 0c    PUSH    dword ptr [EBP + param_2]\n; The following instruction sets the lowest part of the ECX register to 0x1\n; if and only if the Zero flag is set.\n00412cf5 0f 95 c1    SETNZ   CL\n; 0x80000001 corresponds to HKEY_CURRENT_USER. However, if the ECX register\n; contains 0x1, after the following instruction, it will contain\n; 0x80000002, which corresponds to HKEY_LOCAL_MACHINE.\n00412cf8 81 c1 01 ADD    ECX, 0x80000001\n00412cfe 56 PUSH    ESI ; subkey path\n00412cff 51 PUSH    ECX ; root key\n; the function thiSHRegSetPathW_wrapper implements the API hashing \n;protection described in section 7.3, API hashing.\n00412d00 e8 45 fb    CALL    SHRegSetPathW_wrapper\n\n```\n00412d00 e8 45 fb CALL    SHRegSetPathW_wrapper\n\n\nWhich argument gets passed to SHRegSetPathW depends on the output of the function we label isCallerBuiltinAdmin.\nIf the calling user is a built-in administrator for the system, the function returns 0x1; otherwise, it returns 0x0. Because\nthe output of isCallerBuiltinAdmin is added to 0x80000001, the root registry key will be HKEY_LOCAL_MACHINE if the\nuser is an administrator and HKEY_CURRENT_USER otherwise. Had the persistence sub-key been set to a correct\npersistence location, by using the root key HKEY_LOCAL_MACHINE, then Lokibot would have set its persistence for all\nusers who have access to the compromised system, not only for a single user.\n\nThe other arguments passed to SHRegSetPathW are the sub-key path decrypted at the previous stage, the key name\nthat corresponds to the persistence directory name, and the path to the Lokibot executable. The last argument passed\nto SHRegSetPathW is an unused one and is set to 0x0. Here is the result of the registry key set when a non-admin user\nruns Lokibot:\n\nThe root key does not correspond to a proper persistence point, but the data field points to the malware executable.\nLokibot’s inability to set a persistence is a known fact; Hoang (2019) already reported about this behavior for a different\nsample.\n\nisCallerBuiltinAdmin calls two functions exposed by the ADVAPI32 library: AllocateAndInitializeSid and\nCheckTokenMembership. AllocateAndInitializeSid allocates a Security IDentifier (SID) with two sub-authorities:\nSECURITY_BUILTIN_DOMAIN_RID (0x20) and DOMAIN_ALIAS_RID_ADMINS (0x220).[15] CheckTokenMembership\nchecks whether a SID is enabled in an access token. Since the TokenHandle[16] argument is NULL,\nCheckTokenMembership is going to test the access token for the calling thread. The code snippet below shows the call\nto AllocateAndInitializeSid in isCallerBuiltinAdmin function.\n\n\n-----\n\n```\n004060cc 53 PUSH    EBX\n004060cd 53 PUSH    EBX\n; hash value for AllocateAndInitializeSid\n004060ce 68 70 c4 PUSH 0xf3a0c470\n004060d3 6a 09 PUSH 0x9 ; DLL identifier for ADVAPI32 library\n004060d5 89 5d f0 MOV    dword ptr [EBP + local_14], EBX\n; the call to AllocateAndInitializeSid API is protected by \n; the API hashing technique described in section 7.3, API hashing\n004060d8 e8 08 d1    CALL    getApiByDllIdAndHash\n004060dd 8d 4d f8    LEA    ECX=>local_c, [EBP + -0x8]\n004060e0 51 PUSH    ECX\n004060e1 53 PUSH    EBX\n004060e2 53 PUSH    EBX\n004060e3 53 PUSH    EBX\n004060e4 53 PUSH    EBX\n004060e5 53 PUSH    EBX\n004060e6 53 PUSH    EBX\n; 0x220 corresponds to sub-authority SECURITY_BUILTIN_DOMAIN_RID.\n004060e7 68 20 02 PUSH 0x220\n; 0x20 corresponds to sub-authority DOMAIN_ALIAS_RID_ADMINS.\n004060ec 6a 20 PUSH 0x20\n004060ee 6a 02 PUSH 0x2\n004060f0 8d 4d f0    LEA    ECX=>local_14, [EBP + -0x10]\n004060f3 51 PUSH    ECX\n004060f4 ff d0      CALL    EAX ; a call to AllocateAndInitializeSid\n\n```\n\nThe result of the call to CheckTokenMembership is eventually returned to the caller by isCallerBuiltinAdmin. The return\nvalue is set to NULL (0x0) if an error occurred in one of the two mentioned API calls.\n\n```\n0040427d 55 PUSH    EBP\n0040427e 8b ec      MOV    EBP, ESP\n00404280 33 c0      XOR    EAX, EAX\n00404282 50 PUSH    EAX\n00404283 50 PUSH    EAX\n00404284 68 6e 88 PUSH 0xcac5886e ; a hash for SetFileAttributesW\n; EAX contains 0x0, the identifier for the kernel32 library.\n00404289 50 PUSH    EAX\n; SetFileAttributesW function is called via API hashing.\n0040428a e8 56 ef    CALL    getApiByDllIdAndHash\n; 0x2006 is a combination of the following:\n; - FILE_ATTRIBUTE_NOT_CONTENT_INDEXED (0x2000)\n; - FILE_ATTRIBUTE_HIDDEN (0x2)\n; - FILE_ATTRIBUTE_SYSTEM (0x4)\n0040428f 68 06 20 PUSH 0x2006\n\n```\n\n-----\n\n```\n; param_1 contains the file path.\n00404294 ff 75 08 PUSH    dword ptr [EBP + param_1]\n00404297 ff d0      CALL    EAX\n\n```\n\nIn the last step of attempting to establish persistence, Lokibot changes some attributes for both the persistence\ndirectory and the moved executable, by calling API SetFileAttributesW (which is exposed by the kernel32 library) twice:\nonce for the directory, and once for the executable file. The attributes being set by SetFileAttributesW are\nFILE_ATTRIBUTE_NOT_CONTENT_INDEXED, FILE_ATTRIBUTE_HIDDEN, and FILE_ATTRIBUTE_SYSTEM:[17]\n\n```\n0040427d 55 PUSH    EBP\n0040427e 8b ec      MOV    EBP, ESP\n00404280 33 c0      XOR    EAX, EAX\n00404282 50 PUSH    EAX\n00404283 50 PUSH    EAX\n00404284 68 6e 88 PUSH 0xcac5886e ; a hash for SetFileAttributesW\n; EAX contains 0x0, the identifier for the kernel32 library.\n00404289 50 PUSH    EAX\n; the call to SetFileAttributesW API is protected by the \n; API hashing technique described in section 7.3, API hashing\n0040428a e8 56 ef    CALL    getApiByDllIdAndHash\n; 0x2006 is a combination of the following:\n; - FILE_ATTRIBUTE_NOT_CONTENT_INDEXED (0x2000)\n; - FILE_ATTRIBUTE_HIDDEN (0x2)\n; - FILE_ATTRIBUTE_SYSTEM (0x4)\n0040428f 68 06 20 PUSH 0x2006\n; param_1 contains the file path.\n00404294 ff 75 08 PUSH    dword ptr [EBP + param_1]\n00404297 ff d0      CALL    EAX\n\n```\n\nUsing the combination of these attributes ensures that users cannot search for those files, because they (1) are not\nindexed by the indexing services operating in Windows, (2) are declared hidden and are, therefore, not searchable by\nname, (3) are marked as being used by the OS and are, therefore, (4) harder to delete.\n\n#### 7.6. Exfiltration\n\nAs an infostealer, Lokibot can exfiltrate configuration files, Windows credentials, images, password databases, and\nother sensitive data. Lokibot tries to accomplish this by first harvesting and preparing the data for exfiltration and then\nby sending the bundled data via the C&C channel. This section discusses both stages.\n\n##### 7.6.1. Data gathering\n\nTo gather data, Lokibot invokes a function we call exfiltrateData, whose first step is to allocate, via API HeapAlloc, a\nglobal variable that contains a buffer of 5000 bytes:\n\n\n-----\n\n```\n; start of function exfiltrateData\n00413003 55 PUSH    EBP\n00413004 8b ec      MOV    EBP, ESP\n00413006 81 ec 28 SUB    ESP, 0x328\n0041300c 68 88 13 PUSH 0x1388 ; the buffer is 5000 bytes big\n00413011 e8 a9 26    CALL    allocateBuffer\n; The following instruction assigns the buffer we have just allocated\n; to the global variable EXFILTRATED_DATA_BUFFER.\n00413016 a3 e8 fd    MOV    [EXFILTRATED_DATA_BUFFER], EAX\n\n```\n\nThis global buffer will be filled with the data gathered by various functions called modules: for this variant, 101 modules\nwill gather data from specific applications. In general, each module targets a specific application, but some modules are\ndesigned to target multiple applications. The modules are identified by a numeric ID, and that allows the attackers to\nunderstand which module harvested a particular portion of the exfiltrated data. A complete list of the modules shipped\nwith this variant, together with the applications they target, is listed in Appendix C.\n\nIf exfiltrateData successfully allocates a buffer, it builds two arrays of 101 elements each. The first array contains the\nIDs for all modules, and the second array contains the addresses of the modules’ functions. The arrays are aligned:\neach element of each array refers to the same module.\n\nThe grabData function iterates over both arrays and calls runModule for each element. In the code snippet below,\nrunModule expects two arguments: the module ID and the module address for the current element.\n\n```\n; Function: exfiltrateData\n;---------------------------------------------------------------------------------...\n...\n...\n; In function grabData, after the arrays are allocated,\n; the following loop calls runModule at each iteration:\n00413626 33 ff      XOR    EDI, EDI ; Now, the EDI register contains 0x0.\n...\n...\n...\n00413638 8b f7 MOV    ESI, EDI ; initializes ESI register to 0x0\n...\n...\n...\n; ESI is the loop’s index. It is initialized at 0x0 and incremented at each iteration.\n; EBP + 0xfffffcd8 points to the module identifiers (IDs) array.\n; EBP + 0xfffffe6c points to the module addresses array.\nLAB_004137a6 \n004137a6 ff b4 35 PUSH    dword ptr [EBP + ESI*0x1 + 0xfffffe6c]\n004137ad ff b4 35 PUSH    dword ptr [EBP + ESI*0x1 + 0xfffffcd8]\n004137b4 e8 32 f8    CALL    runModule\n; increment ESI by 0x4 to let it point to the next element of both arrays:\n\n```\n\n-----\n\n```\n004137b9 83 c6 04 ADD    ESI, 0x4\n; loop exit condition: if ESI is greater than or equal to 0x194 (=404)\n; Because each memory address is 4 bytes in size, the loop iterates 101 times, which is the size of\nboth arrays.\n004137bc 81 fe 94 CMP    ESI, 0x194\n004137c2 72 e2      JC     LAB_004137a6\n...\n...\n...\n\n```\n\nThis code snippet shows the entire runModule function:\n\n```\n; Function: runModule\n;---------------------------------------------------------------------------------; functionId and functionAddress are the two arguments passed to runModule.\n00412feb 55 PUSH    EBP\n00412fec 8b ec      MOV    EBP, ESP\n00412fee 83 7d 0c 00 CMP    dword ptr [EBP + functionAddress], 0x0\n00412ff2 74 0b      JZ     LAB_00412fff\n00412ff4 8b 45 08 MOV    EAX, dword ptr [EBP + functionId]\n; The identifier of the module being called is assigned to the\n; global variable GATHERING_MODULE_ID.\n00412ff7 a3 ec fd    MOV    [GATHERING_MODULE_ID], EAX\n; a call to the module\n00412ffc ff 55 0c    CALL    dword ptr [EBP + functionAddress]\nLAB_00412fff\n00412fff 5d       POP    EBP\n00413000 c2 08 00    RET    0x8\n\n```\n\nrunModule sets a global variable that contains the ID of the module being launched, and right after that, runModule\njumps to the module address. The module responsible for stealing Windows credentials is invoked not in this loop but\nafter the loop terminates. In any case, the procedure is the same: both the module ID and the module address are\nprovided to the runModule, which then calls the module.\n\nAs an example, we will consider the module that targets a widely used FTP application, FileZilla.[18] The module’s code\nconsists of four consecutive invocations of the same function, grabFile. This function expects three arguments: a path\npattern, a folder index, and a file tag. The path pattern is a string that contains an incomplete path to a file the module is\ninterested in. The path is incomplete because it contains a placeholder for the root directory, %s. The FileZilla module\nconsiders the four path patterns mentioned in the first column of the following table:\n\n_Table 8. The path patterns considered by the FileZilla module_\n\n|Path-Pattern|Folder Index|Resolved Path|\n|---|---|---|\n|\"%s\\\\FileZilla\\\\Filezilla.xml\"|5|%PROGRAMFILES%\\FileZilla\\Filezilla.xml|\n\n\n-----\n\n|\"%s\\\\FileZilla\\\\filezilla.xml\"|0|%APPDATA%\\FileZilla\\filezilla.xml|\n|---|---|---|\n|\"%s\\\\FileZilla\\\\recentservers.xml\"|0|%APPDATA%\\FileZilla\\recentservers.xml|\n|\"%s\\\\FileZilla\\\\sitemanager.xml\"|0|%APPDATA%\\FileZilla\\sitemanager.xml|\n\n\nThe folder index is a number passed to grabFile, which uses this number to resolve the root directory according to a\nmapping that associates the folder indexes to CSIDL[19] constants. The mapping is hardcoded in a series of nested IF\nstatements or a switch/case construct. As an example, consider the code snippet below. For the first invocation of\ngrabFile, the folder index is 5 and is mapped to the 0x26 CSIDL constant, which corresponds to the special folder\n%PROGRAMFILES%. getFolderPath uses the CSIDL constant to obtain the absolute path by internally invoking the\ndeprecated API SHGetFolderPathW. Finally, the composePath function internally invokes the wvsprintfW API to replace\n%s (the placeholder within the path pattern) with the content of %PROGRAMFILES%.\n\n```\nLAB_004121f2\n; This case checks whether the folderIndex argument is 0x5\n004121f2 66 83 f8 05 CMP    AX, 0x5\n004121f6 75 04      JNZ    LAB_004121fc\n; If folderIndex is equal to 0x5, then push the CSIDL constant\n; for the special directory %PROGRAMFILES% to the top of the stack.\n004121f8 6a 26 PUSH 0x26 ; CSIDL constant for %PROGRAMFILES%\n004121fa eb d0      JMP    LAB_004121cc\n...\n...\n...\nLAB_004121cc\n004121cc 8b f9      MOV    EDI, ECX\n; Function getFolderPath expects a CSIDL constant as its unique argument.\n; Internally, it calls API SHGetFolderPathW to get the absolute path for\n; the requested special directory.\n004121ce e8 83 1e    CALL    getFolderPath\n004121d3 eb 4d      JMP    LAB_00412222\n...\n...\n...\nLAB_00412223\n00412223 8b f0 MOV    ESI, AX\n00412225 85 f6      TEST    ESI, ESI\n00412227 74 39      JZ     LAB_00412262\n00412229 56 PUSH    ESI\n0041222a ff 75 08 PUSH    dword ptr [EBP + pathPattern]\n; Function composePath replaces the placeholder in pathPattern\n; with the absolute path to the selected special directory, which is stored\n; in the ESI register.\n0041222d e8 3d 39    CALL    composePath\n\n```\n\nOnce a path for a specific file has been resolved, grabFile checks for the presence of that file in the file system. If\ngrabFile finds the file, it reads the file’s content and updates the global buffer of the stolen data by appending the\nfollowing to the global buffer:\n\n1. the module ID for the currently running module\n\n\n-----\n\n2. the file tag\n\n3. the file size\n\n4. and, eventually, the file content\n\nThe developer intended to store the module ID as an indication of which module was responsible for exfiltrating each\nfile. The figure below shows the parts of the stolen filezilla.xml file together with the other fields; 0x1C, namely 28, is the\nidentifier for the FileZilla module.\n\n_Figure 17. The buffer that contains all the files collected by Lokibot is structured with some meta-information_\n\nSo far, we have not addressed the meaning of the file tag. We know that grabFile writes this tag to the buffer, but we\nhave not found other functions that access it. In the FileZilla module, Filezilla.xml (see the table above) is the only file\nwhere the tag is set to zero; in each of the other three files, the tag is set to 1. However, because we have seen other\nmodules set the file tag to different numeric values, we speculate that the C&C server processes the tag in a moduledependent manner.\n\n##### 7.6.2. Data exfiltration\n\nExfiltration is implemented in the exfiltrateBuffer function, which is called by the exfiltrateData function. exfiltrateBuffer\nexpects six arguments, of which only the first two and the last one are important. The first argument is the global buffer\nof the stolen data assembled by various modules, the second argument is the buffer’s size, and the last argument is the\nflag that dictates whether the stolen data is to be compressed. exfiltrateBuffer prepares a network packet with the stolen\ndata and sends it to the C&C server. In this section, we shed light on how exfiltrateBuffer works.\n\nFirst, exfiltrateBuffer creates the so-called hash log. Within the persistence directory, Lokibot stores its executable and\nother files, one of which has the .hdb extension and is a binary log of the exported content. This log stores the hash of\nall exfiltrated buffers and is used to ensure that Lokibot does not export the same buffer more than once. exfiltrateBuffer\n(1) computes the hash for the buffer by invoking a custom hashing function and then (2) checks whether the hash is in\n\n\n-----\n\nthe log. If it is, then exfiltrateBuffer returns without exfiltrating anything; otherwise, it ships the buffer to the C&C server\nand appends the hash to the hash log. The following code snippet is a Python equivalent of the custom hashing function\n\nused by Lokibot:\n\n```\ndef custom_hash(buffer: List[int], hash_initial_seed: int) -> int:\n buffer_hash = ~hash_initial_seed\n for i in range(len(buffer)):\n  buffer_hash ^= buffer[i]\n  for _ in range(8):\n   if buffer_hash & 0x1:\n    buffer_hash ^= 0xe8677835\n   buffer_hash = logical_right_shift(buffer_hash, 1)\n return ~buffer_hash & 0xffffffff\n\n```\n\nEssentially, the function expects a memory buffer and a seed to be used for initializing the hash being computed. Figure\n18 shows the hash of an exfiltrated buffer stored in the EAX register as the output of the hashing function. Figure 19\nshows the same hash written to the hash log. The hash log is updated with the new hash only after a successful\nexfiltration.\n\n_Figure 18. The hash value for a buffer exfiltrated by Lokibot_\n\nFigure 19. The same hash value, this time written to the hash log\n\nAs already mentioned, the sixth argument passed to exfiltrateBuffer is interesting because it is the flag controlling the\ncompression of the stolen data buffer. If this flag is active, Lokibot compresses the buffer by using aPLib:[20] a freeware\ncompression library. The following figures show the buffer before (Figure 20) and after (Figure 21) the invocation of the\n\n\n-----\n\ncompression function. It is still possible to recognize parts of the original content within the compressed data, probably\ndue to the weak compression algorithm.\n\n_Figure 20. A Lokibot-targeted file before it is compressed with aPLib_\n\n_Figure 21. The same file after it is compressed_\n\nAfter creating the hash log, exfiltrateBuffer prepares the data for exfiltration, by sending an HTTP POST request to the\nC&C server. The request’s payload is binary and contains not only the exfiltrated data but also a rich set of information\nabout the infected system. The table below describes how Lokibot sets various fields to assemble a payload. All API\nfunctions mentioned in the table are protected by the API-hashing anti-analysis technique discussed in section 7.3, API\n_hashing._\n\n\n-----\n\n_Table 9. Structure of Lokibot’s data-exfiltration payload_\n\n|Payload Field|Size (bytes)|Description|\n|---|---|---|\n|0|0x2|This field is set to 0x12, which corresponds to the malware version 1.8 (Pantazopoulos, 2017).|\n|1|0x2|This field is set to 0x27. According to Pantazopoulos (2017), it is a constant that indicates the payload’s type. That value is “Stolen Application/Credential Data”.|\n|2|0x2|This is the encoding flag. If the flag is active, then the string in field 4 will be UNICODE encoded; otherwise, it will be ASCII encoded.|\n|3|0x4|This is the size of the string in field 4.|\n|4|variable|This is the Binary ID. This string identifies the binary. In the analyzed sample, the value is “ckav.ru”. Another common value is “XXXXX11111” (Pantazopoulos, 2017).|\n|5|0x2|This is the encoding flag. If the flag is active, then the string in field 7 will be UNICODE encoded; otherwise, it will be ASCII encoded.|\n|6|0x4|This is the size of the string in field 7.|\n|7|variable|This is the computer name and is returned by API GetComputerNameW.|\n|8|0x2|This is the encoding flag. If the flag is active, then the string in field 10 will be UNICODE encoded; otherwise, it will be ASCII encoded.|\n|9|0x4|This is the size of the string in field 10.|\n|10|variable|This is the domain name and is obtained by invoking APIs GetTokenInformation and LookupAccountSidW on the current thread token or process token. When invoked on the thread, the token is obtained by invoking APIs GetCurrentThread and OpenThreadToken. When invoked on the process, the token is obtained by invoking APIs GetCurrentProcess and OpenProcessToken.|\n|11|0x4|This is the screen resolution’s height and is obtained by invoking APIs GetDesktopWindow and GetWindowRect.|\n|12|0x4|This is the screen resolution’s width and is obtained by invoking APIs GetDesktopWindow and GetWindowRect.|\n|13|0x2|This flag indicates whether the current user is a local admin, and it is obtained by invoking APIs GetUserNameW and NetUserGetInfo.|\n|14|0x2|This flag indicates whether the current user is a built-in admin: the first account created when the operating system is installed. This information is obtained by invoking APIs AllocateAndInitializeSid and CheckTokenMembership.|\n|15|0x2|This flag indicates whether the system’s architecture is Intel Itanium: that is, whether the infected system has a 64-bit architecture. This information is obtained by invoking API GetNativeSystemInfo.|\n\n\n-----\n\n|16|0x2|We could not find a reasonable explanation for this field, which seems to contain a random value. According to Pantazopoulos (2017), this could be a bugged field filled with random memory leftovers.|\n|---|---|---|\n|17|0x2|This is the major version number of the operating system. This value is obtained by invoking API RtlGetVersion and accessing the second field in structure OSVERSIONINFOEXW.21|\n|18|0x2|This is the minor version number of the operating system. This value is obtained by invoking API RtlGetVersion and accessing the third field in structure OSVERSIONINFOEXW.|\n|19|0x2|This is the product type. It contains additional information about the operating system and is obtained by invoking API RtlGetVersion and accessing the tenth field in structure OSVERSIONINFOEXW.|\n|20|0x2|This is the first packet flag. It is activated only after the first packet has been sent to the C&C server. This field will be set to 0x0 the first time a packet is sent to the C&C. This behavior is not persistent: that is, the first packet sent after a rerun of Lokibot will have this field set to 0x0.|\n|21|0x2|This compression flag indicates whether the exfiltrated data is being compressed.|\n|22|0x2|According to Pantazopoulos (2017), this field could be a placeholder for the compression type or other meta-information about compression. This field is set to 0x0.|\n|23|0x2|According to Pantazopoulos (2017), this field could be a placeholder for the compression type or other meta-information about compression. This field is set to 0x0.|\n|24|0x2|According to Pantazopoulos (2017), this field could be a placeholder for the compression type or other meta-information about compression. This field is set to 0x0.|\n|25|0x4|This is the original size of the stolen data. By “original,” we mean the size before a possible compression.|\n|26|0x2|This is the encoding flag. If the flag is active, then the string in field 28 will be UNICODE encoded; otherwise, the string will be ASCII encoded.|\n|27|0x4|This is the size of the string in field 28.|\n|28|variable|This is the mutex label. It is a string obtained by calling the getMutexLabel function, described in section 7.4, A vaccine against Lokibot.|\n|29|variable|This buffer of stolen data is compressed by invoking the aPLib library.|\n\n\nOnce the payload has been assembled, Lokibot decrypts the C&C URL as described in section 7.1, Attribution via\n_section .x and then decrypts the HTTP headers. The decryption function expects a single numeric argument, which will_\nspecify which group of headers the function is to decrypt. The code contains three calls to this function: the first call has\nargument 2, the second has argument 0, and the third has argument 1. The first call decrypts the User Agent header,\nwhich is a well-known network indicator associated to Lokibot:\n\n\n-----\n\n```\nMozilla/4.08 (Charon; Inferno)\n\n```\n\nThe second call decrypts the first group of HTTP headers:\n\n```\nPOST %s HTTP/1.0\nUser-Agent: %s\nHost: %s\nAccept: */*\nContent-Type: application/octet-stream\nContent-Encoding: binary\n\n```\n\nThe first %s placeholder is replaced with the full C&C URL, the second with the User Agent string, and the third with the\nC&C IP address.\n\nThe last call decrypts the second group of HTTP headers:\n\n```\n%sContent-Key: %X\nContent-Length: %i\nConnection: close\n\n```\n\n%s is replaced with the string that contains the first group of headers. %X is replaced with twice the hash of the first\ngroup of headers. The hash is computed by invoking the custom_hash function described earlier. %i is replaced with\nthe original (pre-compression) size of the buffer of stolen data. All three parts of the HTTP headers—the user agent and\nthe first and second groups—are decrypted by one function, decryptHttpHeaders:\n\n```\n# seed is the string “KOSFKF”; here, it is represented as a list of bytes.\ndef generate_decryption_key(seed: List[int]) -> List[int]:\n    key = [i for i in range(256)]\n    j = 0\n    for i in range(256):\n       key[i] ^= seed[j]\n       j = (j + 1) % len(seed)\n    return key\n\n```\n\n-----\n\nThe function takes one argument, the selector in the array, and starts by building an array of three-byte sequences,\nwhich are the encrypted three parts of the HTTP headers. The decryption algorithm is divided into two steps. The first\nstep generates the decryption key, which is always the same for all headers and is generated from a string seed. The\nseed is the string “KOSFKF” and created at runtime, to ensure it does not get used as an indicator for static signatures.\nThe decryption key is an array of 256 bytes. The code snippet shown above is a Python equivalent for the decryption\nkey–generation algorithm implemented in the sample. The following figure shows the decryption key in the memory\nbuffer:\n\n_Figure 22. The key used by Lokibot to decrypt the HTTP headers_\n\nThe second step applies an XOR algorithm to each byte of the encrypted headers. The following two figures show the\nbuffer that contains the encrypted User Agent and the same buffer after the decryption algorithm was applied:\n\n\n-----\n\n_Figure 23. The User Agent header before the decryption_\n\nFigure 24. The User Agent header after the decryption\n\nAfter decrypting the HTTP headers, Lokibot establishes a connection to the C&C server by calling some socket-related\nAPIs exposed by the ws2_32 library. More precisely, Lokibot calls APIs getaddrinfo, socket, and then connect.\nThese calls are clearly visible in the code, and there is no API-hashing protection in place for them. The result of those\ncalls is an opened socket ready to be used to communicate with the C&C server.\n\nThe actual communication happens via two consecutive calls for the send API: the first call sends the HTTP headers,\nand the second call sends the payload described in table 9. The figure below shows the first part of an HTTP\nconversation between an infected host and the C&C server; the conversation was captured in a laboratory environment.\nThe payload is binary, but the computer name, the binary ID, and other strings can still be distinguished.\n\n\n-----\n\n_Figure 25. Part of a conversation between a host infected by Lokibot and the C&C server from the infected host’s side_\n\n\n-----\n\n#### 7.7. Lokibot’s relationship with the C&C server\n\nLokibot is capable of receiving commands via the C&C channel and executing them on the infected system. The\ncommunication protocol sees Lokibot initiating the communication by asking for commands from the C&C server. In\nLokibot, this functionality is implemented similarly to data exfiltration. First, Lokibot assembles the command request\npayload: a 700-byte buffer with a structure that is mostly the same as the structure of the data-exfiltration payload. The\ntable below describes each field of the command request payload. The packet structure requires fewer fields than\nrequired by the data-exfiltration payload; one of the reasons is there is no stolen information to send.\n\n_Table 10. Lokibot’s command request payload structure_\n\n|Field|Size (bytes)|Description|\n|---|---|---|\n|0|0x2|This field is set to 0x12, which corresponds to the malware version 1.8 (Pantazopoulos, 2017).|\n|1|0x2|This field is set to 0x28. According to Pantazopoulos (2017), it is a constant that indicates the payload’s type. That value is “Request C2 Commands”.|\n|2|0x2|If this encoding flag is active, then the string in field 4 will be UNICODE encoded; otherwise, the string will be ASCII encoded.|\n|3|0x4|This is the size of the string in field 4.|\n|4|variable|This string identifies the binary. In the analyzed sample, the value is “ckav.ru”. Another common value is “XXXXX11111” (Pantazopoulos, 2017).|\n|5|0x2|If this encoding flag is active, then the string in field 7 will be UNICODE encoded; otherwise, the string will be ASCII encoded.|\n|6|0x4|This is the size of the string in field 7.|\n|7|variable|This is the computer name and is the output of API GetComputerNameW.|\n|8|0x2|If this encoding flag is active, then the string in field 10 will be UNICODE encoded; otherwise, the string will be ASCII encoded.|\n|9|0x4|This is the size of the string in field 10.|\n|10|variable|This is the domain name, and it is obtained by invoking APIs GetTokenInformation and LookupAccountSidW on the current thread token or process token. When invoked on the thread, the token is obtained by invoking APIs GetCurrentThread and OpenThreadToken. When invoked on the process, the token is obtained by invoking APIs GetCurrentProcess and OpenProcessToken.|\n|11|0x4|This is the screen resolution’s height, and it is obtained by invoking APIs GetDesktopWindow and GetWindowRect APIs.|\n|12|0x4|This is the screen resolution’s width, and it is obtained by invoking APIs GetDesktopWindow and GetWindowRect.|\n\n\n-----\n\n|13|0x2|This flag indicates whether the current user is a local admin, and it is obtained by invoking APIs GetUserNameW and NetUserGetInfo.|\n|---|---|---|\n|14|0x2|This flag indicates whether the current user is a built-in admin: the first account created when the operating system is installed. This information is obtained by invoking APIs AllocateAndInitializeSid and CheckTokenMembership.|\n|15|0x2|This flag indicates whether the system’s architecture is Intel Itanium: that is, whether the infected system has a 64-bit architecture. This information is obtained by invoking API GetNativeSystemInfo.|\n|16|0x2|We could not find a reasonable explanation for this field, which seems to contain a random value. According to Pantazopoulos (2017), this could be a bugged field filled with random memory leftovers.|\n|17|0x2|This is the major version number of the operating system. This value is obtained by invoking API RtlGetVersion and accessing the second field in structure OSVERSIONINFOEXW.22|\n|18|0x2|This is the minor version number of the operating system. This value is obtained by invoking API RtlGetVersion and accessing the third field in structure OSVERSIONINFOEXW.|\n|19|0x2|This is the product type. It contains additional information about the operating system, and it is obtained by invoking API RtlGetVersion and accessing the tenth field in structure OSVERSIONINFOEXW.|\n|20|variable|This is the mutex label. It is a string obtained by calling the function getMutexLabel, described in section 7.4, A vaccine against Lokibot.|\n\n\nAfter assembling the command request payload, Lokibot enters a loop. At each iteration, it sends to the C&C the\npayload as an HTTP POST request in the same manner it sends the exfiltrated data. Namely, it recurs to the socketbased APIs exposed by the ws2_32 library: getaddrinfo, socket, connect, and send. The payload is shipped by\ncalling the send API twice: first to transmit the HTTP headers, and then to transmit the payload. As for data exfiltration,\nthe HTTP headers are decrypted at runtime, with a two-staged XOR-based algorithm described in sections 7.6,\n_Exfiltration, and 7.6.2, Data exfiltration. After sending the request to the C&C server, Lokibot spawns a thread for_\nhandling the response. Between two iterations of the loop, the Sleep API exposed by the kernel32 library is called and\npassed 60,000 milliseconds as its only argument. Therefore, we can conclude that Lokibot asks for commands every\nminute. The code snippet below shows the final part of the loop, the part where Lokibot resolves API CreateThread,\ninvokes it, and then calls Sleep.\n\n```\n00412f39 53 PUSH    EBX\n00412f3a 53 PUSH    EBX\n00412f3b 68 62 41 PUSH 0xfcae4162 ; a hash for API CreateThread \n; EBX contains 0, which is the ID for the kernel32 library.\n00412f40 53 PUSH    EBX \n; the CreateThread API is protected by the API hashing technique described in section 7.3, API\nhashing\n00412f41 e8 9f 02 CALL    getApiByDllIdAndHash\n\n```\n\n-----\n\n```\n00412f46 8d 4d fc    LEA    ECX=>local_8, [EBP + -0x4]\n00412f49 51 PUSH    ECX\n00412f4a 53 PUSH    EBX\n00412f4b 56 PUSH    ESI\n; threadBody is the function executed by the thread being instantiated\n00412f4c 68 9a 28 PUSH    threadBody\n00412f51 53 PUSH    EBX\n00412f52 53 PUSH    EBX\n00412f53 ff d0      CALL    EAX ; actual call to CreateThread\n           LAB_00412f55\n00412f55 68 60 ea    PUSH 0xea60 ; this value corresponds to 600000\n00412f5a 90 NOP\n; the following wrapper function implements the API hashing protection for the Sleep API.\n; We describe the API hashing technique in section 7.3, API hashing.\n; This wrapper functuon is also responsible for calling the Sleep API.\n00412f5b e8 64 38 CALL    SleepWrapper \n00412f60 59 POP    ECX\n00412f61 eb b4      JMP    LAB_00412f17 ; jump back to the start of the loop\n\n```\n\nThe threadBody function is responsible for handling the C&C server’s response to the command request issued by the\nmalware itself. Reverse-engineering the threadBody function helped us understand what the C&C response to the\ncommand request should contain. The payload structure for the C&C response has two parts: a header that contains\nmeta-information for parsing the rest of the payload, and a body that contains the command list together with the\nrequired arguments. The following table describes the structure of the payload header: the fields, their size, and their\nmeaning.\n\n\n-----\n\n_Table 11. The header part of the C&C response_\n\nField Size Description\n\nResponse payload separator: 0x0d\\0x0a0x0d\\0x0a. This sequence corresponds to the\nchar sequence \\r\\n\\r\\n. The malware uses this sequence to separate the headers\n\n0 0x4\n\nsection from the payload section within the C&C response. The malware does not\nparse any response header.\n\nPayload size. This field is used to check whether the C&C server returned some\n\n1 0x4 command. If this value is less than or equal to 8, then the malware does not even try\n\nto parse the payload.\n\n2 0x4 Insignificant value\n\n3 0x4 The size of the command list included in the C&C response\n\n_Table 12. The payload part of the C&C response_\n\nField Size Description\n\n1 0x4 Insignificant value\n\nCommand type. The accepted values are:\n0x0: download and run an executable\n0x1: download and load a DLL\n0x2: download and load a DLL\n0x8: delete an HDB file\n\n2 0x4\n\n0xa: exfiltrate stolen data\n0xe: exit\n0xf: update Lokibot, and execute it\n0x10: change the polling frequency of command requests\n0x11: delete Lokibot, and exit\n\n3 0x4 Insignificant value\n\n4 0x4 Length of the string in field 5\n\nCommand argument\nThis is a string, usually a URI. However, when field 2 is 0x10 (change the polling\n\n5 variable\n\nfrequency), this field is an integer and represents the delay, in milliseconds, between\ntwo consecutive requests.\n\nThe payload that follows the header consists of a list of command records. A command record contains the fields shown\nin the table above, and the command type is probably of greatest interest because it helps us understand other\ncapabilities of the malware, such as downloading and running executables. This functionality is implemented by\nproviding the download URL as the command argument: the fifth field in the command record structure. Download is\nperformed by calling API URLDownloadToFileW, exposed by the urlmon library. Execution is performed by calling API\n\n|Field|Size|Description|\n|---|---|---|\n|0|0x4|Response payload separator: 0x0d\\0x0a0x0d\\0x0a. This sequence corresponds to the char sequence \\r\\n\\r\\n. The malware uses this sequence to separate the headers section from the payload section within the C&C response. The malware does not parse any response header.|\n|1|0x4|Payload size. This field is used to check whether the C&C server returned some command. If this value is less than or equal to 8, then the malware does not even try to parse the payload.|\n|2|0x4|Insignificant value|\n|3|0x4|The size of the command list included in the C&C response|\n\n|Field|Size|Description|\n|---|---|---|\n|1|0x4|Insignificant value|\n|2|0x4|Command type. The accepted values are: 0x0: download and run an executable 0x1: download and load a DLL 0x2: download and load a DLL 0x8: delete an HDB file 0xa: exfiltrate stolen data 0xe: exit 0xf: update Lokibot, and execute it 0x10: change the polling frequency of command requests 0x11: delete Lokibot, and exit|\n|3|0x4|Insignificant value|\n|4|0x4|Length of the string in field 5|\n|5|variable|Command argument This is a string, usually a URI. However, when field 2 is 0x10 (change the polling frequency), this field is an integer and represents the delay, in milliseconds, between two consecutive requests.|\n\n\n-----\n\nCreateProcessW (kernel32). The calls to URLDownloadToFileW and CreateProcessW are protected by the APIhashing technique described in section 7.3, API hashing. In contrast to other analyses of Lokibot malware\n(Pantazopoulos, 2017), our analysis did not find any specific modules implementing a keylogger within the analyzed\nsample.\n\n\n-----\n\n### Appendix A: Targeted applications\n\nThis section enumerates all applications targeted by the Lokibot malware sample analyzed in section 7, Lokibot. By\ntargeted, we mean that the malware looks for at least one resource placed in a subdirectory of a particular application.\nThe applications are listed by typology, with a final list collecting a few outliers that do not fit into any of the previous\ntypologies.\n\n#### Browsers\n\n360 Secure Browser Epic Browser K-Meleon Torch\n\nBlackHawk Chromodo Mustang Superbird\n\nChrome Cyberfox Nichrome Titan Browser\n\nChromePlus Falkon Opera Vivaldi Browser\n\nChrome SxS Firefox Orbitum Waterfox\n\nChromium Flock (2011) Pale Moon Yandex Browser\n\nCitrio IceDragon Qt Web Browser\n\nCốc Cốc Internet Explorer RockMelt\n\nComodo Dragon Iridium Seamonkey\n\nCoowon Lunascape Sleipnir\n\n#### Email applications\n\nBecky Opera Mail Thunderbird\n\nCheckMail Outlook Trojita\n\nFossaMail Pocomail TrulyMail\n\nFoxmail Postbox yMail\n\nGmail Notifier Pro Softwarenetz Mail\n\nIncredimail Spark\n\n|Browsers|Col2|Col3|Col4|\n|---|---|---|---|\n|360 Secure Browser|Epic Browser|K-Meleon|Torch|\n|BlackHawk|Chromodo|Mustang|Superbird|\n|Chrome|Cyberfox|Nichrome|Titan Browser|\n|ChromePlus|Falkon|Opera|Vivaldi Browser|\n|Chrome SxS|Firefox|Orbitum|Waterfox|\n|Chromium|Flock (2011)|Pale Moon|Yandex Browser|\n|Citrio|IceDragon|Qt Web Browser||\n|Cốc Cốc|Internet Explorer|RockMelt||\n|Comodo Dragon|Iridium|Seamonkey||\n|Coowon|Lunascape|Sleipnir||\n\n|Email applications|Col2|Col3|\n|---|---|---|\n|Becky|Opera Mail|Thunderbird|\n|CheckMail|Outlook|Trojita|\n|FossaMail|Pocomail|TrulyMail|\n|Foxmail|Postbox|yMail|\n|Gmail Notifier Pro|Softwarenetz Mail||\n|Incredimail|Spark||\n\n|FTP applications|Col2|Col3|Col4|\n|---|---|---|---|\n|32bit FTP|FlashFXP|JaSFTP|SmartFTP|\n|AbleFTP|Fling|LinasFTP|Staff-FTP|\n|ALFTP|Fresh FTP|MyFTP|Steed|\n|BitKinex|FTPBox|NetFile|UltraFXP|\n|BlazeFtp|FTPGetter|nexus file|WinFtp|\n|Classic FTP|FTPInfo|NovaFTP|WinSCP|\n|Cyberduck|FTP Navigator|NppFTP|WS_FTP|\n|DeluxeFTP|FTP Now|Odin Secure FTP Expert|XFTP|\n|||||\n|Easy FTP|FTPShell|SecureFX||\n|FileZilla|goftp|Sherrod FTP||\n\n\n-----\n\nKiTTY SuperPutty\n\n#### Password management applications\n\n1Password mSecure\n\nEnpass RoboForm\n\nKeePass\n\n#### Miscellaneous\n\nApplication Main functionality\n\nAutomize Task scheduling\n\nExpanDrive Cloud storage\n\nFar Manager File manager\n\nFullSync File synchronization and backup\n\nFull Tilt Poker Poker gaming platform\n\nNetDrive Mapping of drives\n\nNoteFly Annotation\n\nNotezilla Annotation\n\nPidgin Chat client\n\nPokerStars Poker gaming platform\n\nSFTP Drive Remote file system mounter\n\nSunbird Calendar application\n\nSyncovery Backup utility\n\nTotal Commander File manager\n\nTo-Do Desklist Creation of to-do notes\n\nVisual Studio Software development\n\n|SSH applications|Col2|\n|---|---|\n|Bitwise SSH|PuTTY|\n|KiTTY|SuperPutty|\n\n|Password management applications|Col2|\n|---|---|\n|1Password|mSecure|\n|Enpass|RoboForm|\n|KeePass||\n\n|Miscellaneous|Col2|\n|---|---|\n|Application|Main functionality|\n|Automize|Task scheduling|\n|ExpanDrive|Cloud storage|\n|Far Manager|File manager|\n|FullSync|File synchronization and backup|\n|Full Tilt Poker|Poker gaming platform|\n|NetDrive|Mapping of drives|\n|NoteFly|Annotation|\n|Notezilla|Annotation|\n|Pidgin|Chat client|\n|PokerStars|Poker gaming platform|\n|SFTP Drive|Remote file system mounter|\n|Sunbird|Calendar application|\n|Syncovery|Backup utility|\n|Total Commander|File manager|\n|To-Do Desklist|Creation of to-do notes|\n|Visual Studio|Software development|\n\n\n-----\n\n### Appendix B: Source code for the vaccine against Lokibot\n\nThis section lists the source code for the Lokibot vaccine: namely, a PoC for testing a mutex-based defense measure\nagainst Lokibot. The code has been compiled and tested on the 64-bit Windows 10.\n\n```\n#include <windows.h>\n#include <stdio.h>\n#include <string.h>\nint getMD5(char * word, char * md5){\n  HCRYPTPROV csp;\n  HCRYPTHASH hashObject;\n  unsigned char byteHash[127];\n    DWORD byteHashLength = 16;\n  int returnValue;\n  returnValue = CryptAcquireContextW(\n    &csp,\n    NULL,\n    NULL,\n    PROV_RSA_FULL,\n    CRYPT_VERIFYCONTEXT\n  );\n  if (returnValue == 0)\n    return FALSE;\n  returnValue = CryptCreateHash(\n    csp,\n    CALG_MD5,\n    NULL,\n    NULL,\n    &hashObject\n  );\n  if (returnValue == FALSE){\n    CryptReleaseContext(csp, 0);\n    return NULL;\n  }\n  returnValue = CryptHashData(\n    hashObject,\n    (BYTE *) word,\n    strlen(word),\n    0\n  );\n  if (returnValue == FALSE){\n    CryptReleaseContext(csp, 0);\n\n```\n\n-----\n\n```\n    return FALSE;\n  }\n  returnValue = CryptGetHashParam(\n    hashObject,\n\n```\n```\n    HP_HASHVAL,\n    byteHash,\n    &byteHashLength,\n    0\n  );\n  if (returnValue == FALSE){\n    CryptDestroyHash(hashObject);\n    CryptReleaseContext(csp, 0);\n    return FALSE;\n  }\n  // transforming the digest in a uppercased string\n    char md5Char[10];\n    for (int i = 0; i < 16; i++) {\n       sprintf(md5Char, \"%.2x\", byteHash[i]);\n       strcat(md5, md5Char);\n    }\n  CryptDestroyHash(hashObject);\n  CryptReleaseContext(csp, 0);\n  return TRUE;\n}\nint getMutexName(char * mutexName) {\n  HKEY cryptographyKey;\n  int returnValue;\n  char machineGuid[255];\n  int machineGuidLength = 255;\n  returnValue = RegOpenKeyExA(\n    HKEY_LOCAL_MACHINE,\n    \"SOFTWARE\\\\Microsoft\\\\Cryptography\",\n    0,\n    KEY_READ | KEY_WOW64_64KEY,\n    &cryptographyKey\n  );\n  if (returnValue != ERROR_SUCCESS) \n    return FALSE;  \n  returnValue = RegQueryValueExA(\n    cryptographyKey,\n    \"MachineGuid\",\n    NULL,\n\n```\n\n-----\n\n```\n    NULL,\n    (LPBYTE) machineGuid,\n    (LPDWORD) &machineGuidLength\n  );\n  if (returnValue != ERROR_SUCCESS){\n    RegCloseKey(cryptographyKey);\n    return FALSE;\n  }\n  if (getMD5(machineGuid, mutexName) == FALSE){\n    RegCloseKey(cryptographyKey);\n    return FALSE;\n  }\n  // uppercasing the MD5 string, and truncating it at the 24th character\n  for (int i = 0; i < strlen(mutexName); i++)\n    mutexName[i] = toupper(mutexName[i]);\n  mutexName[24] = 0;\n  RegCloseKey(cryptographyKey);\n  return TRUE;  \n}\nint main(void) {\n  char mutexName[255] = \"\";\n  int returnValue;\n  HANDLE mutexHandle;\n  DWORD errorCode;\n  // getting the mutex name\n  returnValue = getMutexName(mutexName);\n  if (returnValue == FALSE)\n    return 1;\n  // creating the mutex\n  mutexHandle = CreateMutexA( \n    NULL,\n    FALSE,\n    mutexName\n  );\n  errorCode = GetLastError();\n  if (errorCode == ERROR_ALREADY_EXISTS | errorCode == ERROR_ACCESS_DENIED){\n    MessageBox(\n       NULL,\n      (LPCTSTR) \"POZOR! Lokibot malware is running on your system!\",\n      (LPCTSTR) \"Lokibot Vaccine\",\n      MB_ICONWARNING\n\n```\n\n-----\n\n```\n    );\n    // cleaning the house\n    if (mutexHandle != NULL)\n      CloseHandle(mutexHandle);\n    return 3;\n  }\n  // keeping the mutex locked\n\n```\n```\n  MessageBox(\n    NULL,\n    (LPCTSTR) \"Your system is protected unless you close this message\",\n    (LPCTSTR) \"Lokibot Vaccine\",\n    MB_ICONINFORMATION\n  );\n  if (mutexHandle != NULL)\n    // cleaning the house\n    CloseHandle(mutexHandle);\n  return 0;\n}\n\n```\n\n-----\n\n### Appendix C: A List of Lokibot modules\n\nThe following table lists all modules implemented in the Lokibot sample analyzed in section 7, Lokibot. Each module is\nresponsible for gathering data—namely, file contents or registry values—for one or more targeted applications. Each\nmodule is unequivocally identified by a numerical identifier: Module ID. The module identifiers are not consecutive, and\na module—namely module 26, which targets Total Commander—is included twice in the list.\n\n|Module ID|Targeted applications|\n|---|---|\n|1|Safari|\n|2|K-Meleon|\n|3|Flock|\n|4|Firefox|\n|5|SeaMonkey|\n|6|Opera|\n|7|IceDragon|\n|8|Windows Credentials Manager|\n|9|Opera Stable, Opera Next, Chromium|\n|12|Many Browsers. Examples: Comodo Dragon, Chrome, Titan Browser|\n|26|Total Commander|\n|26|Total Commander|\n|27|FlashFXP|\n|28|FileZilla|\n|29|Kitty|\n|30|Far Manager|\n|31|SuperPutty|\n|32|Cyberduck|\n|33|Thunderbird|\n|34|Pidgin|\n|35|Bitwise SSH|\n|36|NovaFTP|\n|37|NetDrive|\n|38|NppFTP|\n|39|FTPShell|\n|40|Sherrod FTP|\n|41|MyFTP|\n|42|FTPBox|\n|43|FTPInfo|\n|44|LinasFTP|\n|45|Fullsync|\n|46|nexus file|\n\n\n-----\n\n|47|JaSFTP|\n|---|---|\n|48|FTP Now Looks for an FTP Now configuration in the Program Files folder|\n|49|XFTP|\n|50|Easy FTP|\n|51|goftp|\n|52|NetFile|\n|53|BlazeFTP|\n|54|Staff-FTP|\n|55|DeluxeFTP|\n|56|ALFTP|\n|57|FTPGetter|\n|58|WS_FTP|\n|59|Full Tilt Poker|\n|60|PokerStars|\n|61|AbleFTP|\n|62|Automize|\n|63|SFTP Drive|\n|64|Looks for the site.xml file in the user's personal folder|\n|65|ExpanDrive|\n|66|Steed|\n|67|Looks for .vnc files in the Documents as well as APPDATA folders|\n|68|mSecure|\n|69|Syncovery|\n|70|SmartFTP|\n|71|Fresh FTP|\n|72|BitKinex|\n|73|UltraFXP|\n|74|FTP Now Looks for the FTP Now configuration in the APPDATA folder|\n|75|SecureFX|\n|76|Odin Secure FTP Expert|\n|77|Fling|\n|78|Classic FTP|\n|79|BlackHawk|\n|80|Lunascape|\n|81|QtWeb|\n|82|Falkon|\n|84|Foxmail|\n|85|Pocomail|\n\n\n-----\n\n|86|Incredimail|\n|---|---|\n|87|WinSCP|\n|88|Gmail Notifier Pro|\n|89|CheckMail|\n|90|Softwarenetz Mail|\n|91|Opera Mail|\n|92|Postbox|\n|93|Cyberfox|\n|94|Pale Moon|\n|95|FossaMail|\n|96|Becky|\n|97|Winchips|\n|98|Outlook|\n|99|YMail|\n|100|Trojita|\n|101|TrulyMail|\n|102|Visual Studio Looks for sln files in the APPDATA and Documents folders|\n|103|To-Do Desklist|\n|104|Sticky Notes Looks for png and rtf files in the APPDATA\\stickies\\images folder|\n|105|NoteFly|\n|106|Notezilla|\n|107|StickyNotes Looks for the APPDATA\\Microsoft\\Sticky Notes\\Stickynotes.snt file|\n|108|WinFtp|\n|109|32Bit FTP|\n|121|Windows Credentials|\n|122|FTP Navigator|\n|124|KeyPass|\n|125|Enpass|\n|126|WaterFox|\n|127|RoboForm|\n|128|1Password|\n|129|Winbox|\n|||\n\n\n-----\n\n### Bibliography\n\nAny.Run. 2015 Malware Trends: Lokibot\nhttps://any.run/malware-trends/lokibot\n\nBiv, Roy G. 2009. Heaven's Gate: 64-bit code in 32-bit file\nhttps://github.com/darkspik3/Valhalla-ezines/blob/master/Valhalla%20%231/articles/HEAVEN.TXT\n\nCo, Martin, and Gilbert Sison. 2018. Attack Using Windows Installer Leads to LokiBot\nhttps://www.trendmicro.com/en_us/research/18/b/attack-using-windows-installer-msiexec-exe-leads-lokibot.html\n\nHoang, Minh. 2019. Infoblox. Malicious Activity Report: Elements of Lokibot Infostealer\nhttps://insights.infoblox.com/threat-intelligence-reports/threat-intelligence--22\n\nIonescu, Alex. 2015. Closing “Heaven’s Gate”\nhttp://www.alex-ionescu.com/?p=300\n\nMuhammad, Irshad, and Holger Hunterbrink. 2021. A Deep Dive into Lokibot Infection Chain\nhttps://blog.talosintelligence.com/2021/01/a-deep-dive-into-lokibot-infection-chain.html\n\nPantazopoulos, Rob. 2017. Loki-Bot: Information Stealer, Keylogger, & More!\nhttps://www.sans.org/reading-room/whitepapers/malicious/loki-bot-information-stealer-keylogger-more-37850\n\nPoslušný, Michal, and Peter Kálnai. 2020. Virus Bulletin. Rich Headers: leveraging this mysterious artifact of the PE\nformat\nhttps://www.virusbulletin.com/virusbulletin/2020/01/vb2019-paper-rich-headers-leveraging-mysterious-artifact-pe-format/\n\nRemillano, Augusto, Mohammed Malubay, and Arvin Roy Macaraeg. 2020. LokiBot Impersonates Popular Game\n_Launcher_\n[https://www.trendmicro.com/en_us/research/20/b/lokibot-impersonates-popular-game-launcher-and-drops-compiled-c-](https://www.trendmicro.com/en_us/research/20/b/lokibot-impersonates-popular-game-launcher-and-drops-compiled-c-code-file.html)\ncode-file.html\n\nSingh, Abhinav. 2019. LokiBot & NanoCore being distributed via ISO disk image files\nhttps://www.netskope.com/blog/lokibot-nanocore-iso-disk-image-files\n\nUnterbrink, Holger, and Edmund Brumaghin. 2019. RATs and stealers rush through “Heaven’s Gate” with new loader\nhttps://blog.talosintelligence.com/2019/07/rats-and-stealers-rush-through-heavens.html\n\nZhang, Xiaopeng, and Hua Liu. 2017. New Loki Variant Being Spread via PDF File\nhttps://www.fortinet.com/blog/threat-research/new-loki-variant-being-spread-via-pdf-file\n\n\n-----\n\n### Endnotes\n\n1. https://nsis.sourceforge.io/Docs/Chapter4.html#fileformat\n\n2. https://nsis.sourceforge.io/Docs/Chapter4.html#file\n\n3. https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea\n\n4. https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect\n\n5. https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile\n\n6. PEB structure (winternl.h)\n\n7. PEB_LDR_DATA structure (winternl.h)\n\n8. https://attack.mitre.org/techniques/T1055/012/\n\n9. https://docs.microsoft.com/en-gb/windows/win32/api/winternl/ns-winternl-peb_ldr_data?redirectedfrom=MSDN\n\n10. https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_unicode_string\n\n11. https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499\n12. For details about the Algid arguments possible for CryptCreateHash, go here.\n\n13. https://docs.microsoft.com/en-us/windows/win32/shell/csidl\n\n14. https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-publickeystruc\n\n15. https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-allocateandinitializesid\n\n16. https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-checktokenmembership\n\n17. https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfileattributesw\n\n18. https://filezilla-project.org/\n\n19. https://docs.microsoft.com/en-us/windows/win32/shell/csidl\n\n20. https://ibsensoftware.com/products_aPLib.html\n\n21. https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_osversioninfoexw\n\n22. https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_osversioninfoexw\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://www.infoblox.com/wp-content/uploads/infoblox-whitepaper-deep-analysis-of-a-recent-lokibot-attack.pdf"
    ],
    "report_names": [
        "infoblox-whitepaper-deep-analysis-of-a-recent-lokibot-attack.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "75455540-2f6e-467c-9225-8fe670e50c47",
            "created_at": "2022-10-25T16:07:23.740266Z",
            "updated_at": "2025-03-27T02:02:09.955585Z",
            "deleted_at": null,
            "main_name": "Iridium",
            "aliases": [],
            "source_name": "ETDA:Iridium",
            "tools": [
                "CHINACHOPPER",
                "China Chopper",
                "LazyCat",
                "Powerkatz",
                "SinoChopper",
                "reGeorg"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "0661a292-80f3-420b-9951-a50e03c831c0",
            "created_at": "2023-01-06T13:46:38.928796Z",
            "updated_at": "2025-03-27T02:00:02.953963Z",
            "deleted_at": null,
            "main_name": "IRIDIUM",
            "aliases": [],
            "source_name": "MISPGALAXY:IRIDIUM",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "9f101d9c-05ea-48b9-b6f1-168cd6d06d12",
            "created_at": "2023-01-06T13:46:39.396409Z",
            "updated_at": "2025-03-27T02:00:03.074969Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "CHROMIUM",
                "ControlX",
                "Red Dev 10",
                "RedHotel",
                "Red Scylla",
                "TAG-22",
                "BRONZE UNIVERSITY",
                "AQUATIC PANDA",
                "Charcoal Typhoon",
                "BountyGlad"
            ],
            "source_name": "MISPGALAXY:Earth Lusca",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "a66438a8-ebf6-4397-9ad5-ed07f93330aa",
            "created_at": "2022-10-25T16:47:55.919702Z",
            "updated_at": "2025-03-27T02:05:17.412024Z",
            "deleted_at": null,
            "main_name": "IRON VIKING",
            "aliases": [
                "ATK14 ",
                "BlackEnergy Group",
                "Blue Echidna ",
                "CTG-7263 ",
                "ELECTRUM ",
                "FROZENBARENTS ",
                "Hades/OlympicDestroyer ",
                "IRIDIUM ",
                "Qudedagh ",
                "Sandworm Team ",
                "Seashell Blizzard ",
                "TEMP.Noble ",
                "Telebots ",
                "Voodoo Bear ",
                "APT44 "
            ],
            "source_name": "Secureworks:IRON VIKING",
            "tools": [
                " BlackEnergy",
                " GCat",
                " GreyEnergy",
                " Industroyer",
                " KillDisk",
                " NotPetya",
                " PSCrypt",
                " TeleBot",
                " TeleDoor",
                " xData",
                "BadRabbit"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "b3e954e8-8bbb-46f3-84de-d6f12dc7e1a6",
            "created_at": "2022-10-25T15:50:23.339976Z",
            "updated_at": "2025-03-27T02:00:55.446795Z",
            "deleted_at": null,
            "main_name": "Sandworm Team",
            "aliases": [
                "Sandworm Team",
                "ELECTRUM",
                "Telebots",
                "IRON VIKING",
                "BlackEnergy (Group)",
                "Quedagh",
                "Voodoo Bear",
                "IRIDIUM",
                "Seashell Blizzard",
                "FROZENBARENTS",
                "APT44"
            ],
            "source_name": "MITRE:Sandworm Team",
            "tools": [
                "Bad Rabbit",
                "Mimikatz",
                "Exaramel for Linux",
                "Exaramel for Windows",
                "GreyEnergy",
                "PsExec",
                "Prestige",
                "P.A.S. Webshell",
                "VPNFilter",
                "Cyclops Blink",
                "SDelete",
                "AcidRain",
                "Industroyer",
                "Industroyer2",
                "BlackEnergy",
                "Cobalt Strike",
                "NotPetya",
                "KillDisk",
                "PoshC2",
                "Impacket",
                "Invoke-PSImage",
                "Olympic Destroyer"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "6abcc917-035c-4e9b-a53f-eaee636749c3",
            "created_at": "2022-10-25T16:07:23.565337Z",
            "updated_at": "2025-03-27T02:02:09.868522Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Bronze University",
                "Charcoal Typhoon",
                "Chromium",
                "Red Dev 10",
                "Red Scylla"
            ],
            "source_name": "ETDA:Earth Lusca",
            "tools": [
                "Agentemis",
                "AntSword",
                "BIOPASS",
                "BIOPASS RAT",
                "BadPotato",
                "Behinder",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "Doraemon",
                "FRP",
                "Fast Reverse Proxy",
                "FunnySwitch",
                "HUC Port Banner Scanner",
                "KTLVdoor",
                "Mimikatz",
                "NBTscan",
                "POISONPLUG.SHADOW",
                "PipeMon",
                "RbDoor",
                "RibDoor",
                "RouterGod",
                "SAMRID",
                "ShadowPad Winnti",
                "SprySOCKS",
                "WinRAR",
                "Winnti",
                "XShellGhost",
                "cobeacon",
                "fscan",
                "lcx",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f4f16213-7a22-4527-aecb-b964c64c2c46",
            "created_at": "2024-06-19T02:03:08.090932Z",
            "updated_at": "2025-03-27T02:05:17.387119Z",
            "deleted_at": null,
            "main_name": "GOLD NIAGARA",
            "aliases": [
                "Carbanak",
                "Carbon Spider ",
                "FIN7 ",
                "Navigator ",
                "Sangria Tempest ",
                "TelePort Crew ",
                "Calcium "
            ],
            "source_name": "Secureworks:GOLD NIAGARA",
            "tools": [
                " Carbanak",
                " Cobalt Strike",
                " DICELOADER",
                " DRIFTPIN",
                " GGLDR",
                " GRIFFON",
                " JSSLoader",
                " Meterpreter",
                " OFFTRACK",
                " PILLOWMINT",
                " POWERTRASH",
                " SUPERSOFT",
                " TAKEOUT",
                " TinyMet",
                "Bateleur"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "8941e146-3e7f-4b4e-9b66-c2da052ee6df",
            "created_at": "2023-01-06T13:46:38.402513Z",
            "updated_at": "2025-03-27T02:00:02.824555Z",
            "deleted_at": null,
            "main_name": "Sandworm",
            "aliases": [
                "G0034",
                "IRIDIUM",
                "Blue Echidna",
                "FROZENBARENTS",
                "Seashell Blizzard",
                "IRON VIKING",
                "ELECTRUM",
                "TeleBots",
                "UAC-0113",
                "UAC-0082",
                "APT44",
                "Quedagh",
                "VOODOO BEAR",
                "TEMP.Noble"
            ],
            "source_name": "MISPGALAXY:Sandworm",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d53593c3-2819-4af3-bf16-0c39edc64920",
            "created_at": "2022-10-27T08:27:13.212301Z",
            "updated_at": "2025-03-27T02:00:55.529662Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Earth Lusca",
                "TAG-22",
                "Charcoal Typhoon",
                "CHROMIUM",
                "ControlX"
            ],
            "source_name": "MITRE:Earth Lusca",
            "tools": [
                "Mimikatz",
                "PowerSploit",
                "Tasklist",
                "certutil",
                "Cobalt Strike",
                "Winnti for Linux",
                "Nltest",
                "NBTscan",
                "ShadowPad"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "d85adfe3-e1c3-40b0-b8bb-d1bacadc4d82",
            "created_at": "2022-10-25T16:07:23.619566Z",
            "updated_at": "2025-03-27T02:02:09.890982Z",
            "deleted_at": null,
            "main_name": "FIN7",
            "aliases": [
                "APT-C-11",
                "ATK 32",
                "Gold Niagara",
                "ITG14",
                "TAG-CR1"
            ],
            "source_name": "ETDA:FIN7",
            "tools": [
                "7Logger",
                "Agentemis",
                "Anunak",
                "Astra",
                "BIOLOAD",
                "BIRDWATCH",
                "Bateleur",
                "Boostwrite",
                "CROWVIEW",
                "Carbanak",
                "Cobalt Strike",
                "CobaltStrike",
                "DICELOADER",
                "DNSMessenger",
                "FOWLGAZE",
                "HALFBAKED",
                "JSSLoader",
                "KillACK",
                "LOADOUT",
                "Lizar",
                "Meterpreter",
                "Mimikatz",
                "POWERPLANT",
                "POWERSOURCE",
                "RDFSNIFFER",
                "SQLRAT",
                "Sekur",
                "Sekur RAT",
                "TEXTMATE",
                "Tirion",
                "VB Flash",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "7bd810cb-d674-4763-86eb-2cc182d24ea0",
            "created_at": "2022-10-25T16:07:24.1537Z",
            "updated_at": "2025-03-27T02:02:10.126127Z",
            "deleted_at": null,
            "main_name": "Sandworm Team",
            "aliases": [
                "APT 44",
                "ATK 14",
                "BE2",
                "Blue Echidna",
                "CTG-7263",
                "FROZENBARENTS",
                "IRIDIUM",
                "Iron Viking",
                "Quedagh",
                "Sandworm",
                "Sandworm Team",
                "Seashell Blizzard",
                "TEMP.Noble",
                "UAC-0082",
                "UAC-0113",
                "UAC-0125",
                "UAC-0133",
                "Voodoo Bear"
            ],
            "source_name": "ETDA:Sandworm Team",
            "tools": [
                "AWFULSHRED",
                "ArguePatch",
                "BIASBOAT",
                "Black Energy",
                "BlackEnergy",
                "CaddyWiper",
                "Colibri Loader",
                "Cyclops Blink",
                "CyclopsBlink",
                "DCRat",
                "DarkCrystal RAT",
                "Fobushell",
                "GOSSIPFLOW",
                "Gcat",
                "IcyWell",
                "Industroyer2",
                "JaguarBlade",
                "JuicyPotato",
                "Kapeka",
                "KillDisk.NCX",
                "LOADGRIP",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "ORCSHRED",
                "P.A.S.",
                "PassKillDisk",
                "Pitvotnacci",
                "PsList",
                "QUEUESEED",
                "RansomBoggs",
                "RottenPotato",
                "SOLOSHRED",
                "SwiftSlicer",
                "VPNFilter",
                "Warzone",
                "Warzone RAT",
                "Weevly"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716493,
    "ts_updated_at": 1743041825,
    "ts_creation_date": 1638993508,
    "ts_modification_date": 1638965056,
    "files": {
        "pdf": "https://archive.orkl.eu/3eee6ce4ab8508de1b06b8c54a333b95985dca23.pdf",
        "text": "https://archive.orkl.eu/3eee6ce4ab8508de1b06b8c54a333b95985dca23.txt",
        "img": "https://archive.orkl.eu/3eee6ce4ab8508de1b06b8c54a333b95985dca23.jpg"
    }
}