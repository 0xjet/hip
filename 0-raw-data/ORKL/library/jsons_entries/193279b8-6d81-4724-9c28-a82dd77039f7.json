{
    "id": "193279b8-6d81-4724-9c28-a82dd77039f7",
    "created_at": "2023-01-12T15:07:00.764058Z",
    "updated_at": "2025-03-27T02:15:35.657929Z",
    "deleted_at": null,
    "sha1_hash": "af420ea4d7b749d673d7f2aaefc637e4612e3925",
    "title": "2021-07-19 - FickerStealer- A New Rust Player in the Market",
    "authors": "",
    "file_creation_date": "2022-05-27T22:55:42Z",
    "file_modification_date": "2022-05-27T22:55:42Z",
    "file_size": 1569600,
    "plain_text": "# FickerStealer: A New Rust Player in the Market\n\n**[cyberark.com/resources/threat-research-blog/fickerstealer-a-new-rust-player-in-the-market](https://www.cyberark.com/resources/threat-research-blog/fickerstealer-a-new-rust-player-in-the-market)**\n\nJuly 19, 2021\n\nThis blog introduces a new information stealer, written in Rust and interestingly named\n**FickerStealer. In this blog post, we provide an in-depth analysis of this new threat and its**\nobfuscation techniques, including an IDAPython deobfuscator script.\n\n## Background\n\nFickerStealer is an exceptional information stealer, first seen in the wild in August 2020. This\ninfo-stealer was sold on underground forums as a MaaS (Malware-as-a-service) by a seller\nnamed @ficker (@ficker_sup on Telegram). The average price of an information stealer is\n$200, and it varies depending on their additional capabilities and the subscription time for the\nservice. The price for FickerStealer cost ranges between $90 up to $900, and it only\ndepends on the subscription time to the service.\n\n\n-----\n\nFigure 1: FickerStealer post on a known Russian forum\n\nOnce a buyer purchases the Ficker service, an “on-prem” package will be provided, including\nthe C2 server setup (called Panel) and the stealer executable (called Build). After the\npurchase, the buyer is required to specify what the C2 server’s address will be, so the\nmalware author (the seller) will configure the malware (build) to communicate with the\nattacker’s C2 server.\n\nOne of the more surprising things about FickerStealer is that it’s written in Rust and\nAssembly. Rust language isn’t a natural choice for malware developers. While it is very fast\nand memory-efficient and runs on embedded devices, developers might take a longer time to\nlearn Rust because of its complexities. The advantages of this programming language are\nnot utilized to their fullest when building malware, except that it’s difficult to reverse engineer\nit. Because of that, there are few known malware families written in Rust, so it was a bit\nsurprising to find a new Rust infostealer.\n\nFickerStealer has quickly gained popularity among cybercriminals on underground forums\nbecause of its attractive price and interesting and different methodology as an information\nstealer (we will dive into that later). The malware received many good reviews from\ncustomers. For example: “I use it for targeted attacks, in a couple of months the\n**_product showed itself at its best, I recommend.” It even received an excellent review_**\nfrom some known underground forum moderators — the dream of every malware author.\n\nFigure 2: Part of the forum moderator review (translated from Russian)\n\n\n-----\n\nThe malware is used to steal sensitive information, including login credentials, credit card\n**information, cryptocurrency wallets** **and browser information from applications such as**\nWinSCP, Discord, Google Chrome, Electrum, etc. It does all that by implementing a different\napproach than other stealers (we’ll cover it later). Additionally, FickerStealer can function as\na File Grabber and collect additional files from the compromised machine, and it can act as\na Downloader to download and execute several second-stage malware.\n\n## Delivery Methods – Malware Distribution\n\nWe noticed that FickerStealer is primarily delivered by two different methods: Exploit kit –\n**RigEK and Malspam – Hancitor.**\n\n**RigEK –The victims enter a malicious/compromised website. The malicious website**\nacts as a gate that can perform some checks of the user characteristics, like host\nmachine, GeoIP, user-agent, etc. In case this type of user is targeted, the user is\nredirected to the RigEK landing page.\n\nThe landing page scans and profiles the victim’s browser and checks if it is vulnerable\nto any of the exploit kit vulnerabilities (most of them are 1-day vulnerabilities). In case\nthe browser is vulnerable, the landing page executes the exploit to load the malware\npayload.\n**Hancitor – Malicious spam campaigns have proven to be an efficient infection vector.**\nThe malware is delivered via targeted phishing emails with malicious macro-based\ndocuments attached. The macro drops the Hancitor loader, which then injects the final\npayload using process hollowing. It’s worth mentioning that we found many samples of\nFickerStealer that Hancitor delivers. If you are interested in more information about\n[Hancitor, you should check Binary Defense’s blog.](https://www.binarydefense.com/analysis-of-hancitor-when-boring-begets-beacon/)\n\nFigure 3: Hancitor loading Ficker payload in a sandbox environment\n\n## Technical Overview\n\nAs we mentioned earlier, Ficker is written in Rust, making the analysis complex and\nchallenging because it’s compiled differently than C/C++ language. On top of that, the Ficker\nexecutable is also heavily obfuscated.\n\n\n-----\n\nFikcerStealer s main objective, like all credential theft malware, is to gather as much\nsensitive information as possible. Before we dive into analyzing FickerStealer‘s features, the\nfollowing are the main diffrencess between Ficker and other stealers:\n\nFicker doesn’t have dependencies. It doesn’t need to download/load other DLLs like\n_dll, nss3.dll on runtime to fulfill its stealing capabilities._\nThe communication channel with the C2 server is encrypted/obfuscated from the\nclient-side, unlike most stealers that rely on HTTP protocol and send the data as plain\ntext.\nFicker sends the stolen data after each successful stealing operation and by doing\nthat, it doesn’t write any logs/files to disk. Other stealers write the stolen data to some\ntemp folder, compress it and send it as a zip file to the C2 server. In addition, Ficker\nsends the sensitive Mozilla browser data to the C2 server and decrypts it on the\n**server-side.**\nThe Downloader feature can download and execute several PE files, including\n**executing malicious executables and loading DLLs.**\n\nFicker tries to make its malware more reliable and stealthier than other stealers.\n\n\n-----\n\nFigure 4: Malware flow\n\n## In-depth Analysis\n\nAs far as we know, the first Rust malware was spotted in the wild in 2016. So far, we haven’t\nheard about many Rust malware families or any trend of writing malware in Rust among\nmalware developers as we have seen lately with Golang. Most of the Rust malware we\n[stumbled upon, like Telebots backdoor, contains Rust debug information, which makes](https://www.welivesecurity.com/2018/10/11/new-telebots-backdoor-linking-industroyer-notpetya/)\nour life easier while analyzing those Rust samples. Unfortunataley, in our case, the debug\ninformation of our FickerStealer sample is stripped out, making the analysis more difficult.\n\n\n-----\n\nAs you can probably guess, we began by opening it in IDA, and we noticed that there are no\nsymbols for Rust functions (or any developer functions). In addition, we could easily tell that\nthe sample was heavily obfuscated: all the strings are encrypted; it uses many dynamic calls;\nand most of the functions are just wrappers on wrappers with minor modifications.\n\nFigure 5: Part of Ficker’s WinMain function\n\nLet’s see how we approached the task of dissecting the malware.\n\n\n-----\n\nOur mindset was to first map the malware by finding its strings, as that would reveal the\nmalware’s functionality and allow us to make educated guesses about what a snippet of\ncode or function does.\n\n### Strings Obfuscation\n\nThe problem is that all Ficker’s strings are obfuscated, including API function names, C2\nserver address, mutex name, sensitive and targeted file names, etc. As mentioned, revealing\nthose strings can shed some light on the malware capabilities and IoCs.\n\nWhile analyzing Ficker’s string decryption process, we found that Ficker doesn’t decrypt all\n[the strings at once like Oski Stealer does. It decrypts each string at a different location on](https://www.cyberark.com/resources/threat-research-blog/meet-oski-stealer-an-in-depth-analysis-of-the-popular-credential-stealer)\nruntime just before it uses it. Therefore, we had to find the string decryption function and\n**find every call to it.**\n\nAlso, while going over the malware, we noticed many dynamic calls, so we started\ndebugging it. Ficker tries to hide its call to the string decryption function (string_decrypt) by\nobfuscating the function address. It calculates the function’s address by using different\ninstructions and different offsets. In figure 6 (highlighted with red boxes), you can see a\nsimple dynamic call to string_decrypt using short and straightforward obfuscation (which is\nnot the case in most calls to string_decrypt).\n\nFigure 6: Obfuscated call to string_decrypt function\n\nIn our case, the string decryption function is at 0x42572C (0x431192 + 0xFFFF459A). Our\nnext step is finding where the function is called; however, when we checked the xrefs for this\nfunction, we saw that it had no references.\n\n\n-----\n\nFigure 7: string_dercypt function has no references\n\nWe believe there are two reasons for this:\n\n1. The malware calls this function dynamically in an obfuscated way, as we saw earlier, or\n2. It has other string decryption routines (which is not likely.)\n\nBefore digging into this issue, let’s focus on the string_decrypt function.\n\n**String Decryption Function**\n\nThe string decryption function receives three arguments: a destination pointer to write the\n**decrypted string, the string length and the pointer to the obfuscated string.**\n\nThe obfuscated string has a pretty simple structure. The first four bytes are the key for the\ndecryption algorithm, and the rest of the bytes (as the size of the string length argument) are\nthe encrypted string.\n\nAfter delving deeper into the function, we noticed a few things:\n\n1. The pointer for the obfuscated string is also obfuscated; the pointer is not the one for\n\nthe “real” structure (that we described before).\n2. The function first calculates the “real” address and retrieves the encrypted string and\n\nthe decryption key.\n3. After getting the “real” structure, the function implements the decryption algorithm.\n\nThe function uses a hardcoded constant to calculate the address of the “real” string\nstructure. As much as we know — and at the time of writing this blog post — this constant\nremains the same in all Ficker’s samples. It’s 0x25.\n\nThe address of the structure is calculated in this way:\n\nenc_struc = obf_addr + string_dec_const * str_len – 4.\n\nFor example, the function gets the address 0x436FF8 (obf_addr) and the length of the\ndecrypted string which is 0x06 (str_len). Eventually, we’ll get the address 0x437494 that\nholds the “real” string structure for Pidgin.\n\nAfter getting the “real” address, the function decrypts the string using a simple decryption\nalgorithm.\n\nWe wrote an IDAPython script that simulates the string_decrypt function, including the\ndecryption algorithm.\n\n\n-----\n\nFigure 8: IDAPython script for string_decrypt function\n\nAfter writing a script that can decrypt any string, we just need to find where it’s called and\nwhat the parameters are for each call (on every location).\n\nIt sounds like a great mission for an IDAPython script! If you remember, we noted that it is\nmore likely that string_decrypt will be called on runtime.\n\nLet’s break our mission into tasks:\n\n1. Find all dynamic calls in the binary — find all call instructions with some register (e.g.,\n\ncall eax).\n2. Calculate the address in the register (can be obfuscated) and compare the calculated\n\naddress to string_decrypt function’s address.\n3. Get the function arguments’ values (string length, pointer to obfuscated string\n\nstructure), which can also be obfuscated.\n4. Use our IDAPython str_decrypt function to decrypt the string (figure 8).\n\nThe interesting part is how we can deal with Ficker’s obfuscation. Ficker mostly uses\nobfuscation techniques like calculating the data, using useless instructions and pushingpopping data.\n\nTo deal with that, we wrote two IDAPython functions get_value, get_ref.\n\nThe primary function (get_value) is a recursive function, which gets the instruction’s address\nas an argument and returns the value used on this instruction, e.g., the address of push ebx\nwill return the value ebx holds.\n\n\n-----\n\nBut a question comes to mind: How can we find it? We use the get_ref function that gets this\ninstruction’s address and the operand index as arguments and returns the first reference to\nthe given operand.\n\nThe get_value function first identifies the instruction (call, mov, lea, add instruction, etc.’).\nTherefore, we can tell that it knows which operand may contain the data and checks this\noperand’s type if it is mem_addr or imm_value. These types of operand indicate if it’s a piece\nof data that’s stored as part of the instruction itself instead of being in a memory location or a\nregister. In case the operand holds any value (mem_addr/imm_value), the function will return\nthis value. Otherwise, the function gets a reference to this operand by calling get_ref and\nthen it calls recursively to itself with the new instruction’s address. The recursive function\nbreaks when it finds mem_addr/imm_value.\n\nLet’s see how it works with an example. The goal here is to find the address for the call on\n0x415C6A:\n```\n.text:00415C51         lea   eax, loc_4342CA+2\n.text:00415C57         lea   ecx, unk_437BEF\n.text:00415C5D         mov   [edi], eax\n.text:00415C5F         mov   eax, 0FFFF1460h\n.text:00415C64         add   eax, [edi]\n.text:00415C66         push  ecx\n.text:00415C67         push  21h ; '!'\n.text:00415C69         push  esi\n.text:00415C6A         call  eax\n\n```\nCode Snippet 1: Disassembly snippet from Ficker’s binary\n\nWe call our recursive function with the address 0x415C6A to find the address of eax. The\nfunction checks the type of the relevant operand (in this case, the first one because it’s a call\ninstruction). The operand is a register, which is not a mem_addr/imm_value. Therefore, the\nfunction searches for a reference to this operand (eax). The function calls itself with the new\naddress of the reference, 0x415C64.\n\nAnd again, it checks the type of both operands because it add instruction and searches a\nreference for both operands (eax and edi). After the function finds those registers’ values\nrecursively, it finally will return the sum of them.\n\n**Ficker Deobfuscator: An IDAPython script**\n\nYou can find our IDAPython deobfuscator in our Malware Research repository —\nFickerStealer.\n\nWe gathered all those parts together and added more functionalities into one IDAPython\nscript. The script defeats Ficker’s obfuscation and decrypts all the strings along the binary\nthat Ficker uses.\n\n\n-----\n\n1. The script finds the decryption function address by searching (using pattern-based) the\n\nstring’s decryption algorithm.\n2. It obtains the addresses of all dynamic calls in the binary, and for each one,\n\ndeobfuscate the address on the call instruction and compares it to the decryption\nfunction address.\n3. It gets the arguments (by stack) of the string decryption call; the string decryption\n\nfunction gets three arguments (destination pointer, string length and a pointer to the\nobfuscated string.)\n4. It gets the data that the arguments should hold.\n5. Deobfuscate the string using the function get_obf_string, which gets the pointer for the\n\nobfuscated string and the string length.\n6. This function returns the decrypted string.\n\nFigure 9: FickerStealer’s deobfuscator usage\n\nThe script also sets a reference to string_decrypt function, adds a comment with the\ndecrypted string and dumps all the data to a JSON file.\n\nAnd now, having collected the fruits of our labor, our deobfuscator script was able to identify\n191 calls to the string decryption function (string_decrypt) and to decrypt 182 strings in this\nsample.\n\n\n-----\n\nFigure 10: References for string_decrypt function\n\nFinally, after we got all Ficker’s strings, we have an idea about what most functions and code\nparts do, so we can now move forward.\n\n### C2 server communication\n\n**Establishing Connection**\n\nFicker holds the address and port for the C2 server as an encrypted string, IP:PORT, which\ncan be easily identified by running the IDAPython script. The string can be an IP address or\ndomain name, and if the C2 address is a domain name, the malware tries to resolve it until it\nsucceeds.\n\nThe malware communicates with the C2 server over TCP. It creates a TCP socket to the C2\nserver by using the IP address and the port. After the connection is established, Ficker calls\nto recv function twice. First, it receives two bytes that indicate the data size it needs to\nallocate. It then allocates this memory and receives the data from the C2 server.\n\nThe received data is the Grabber rules configuration of the C2 server and contains a list of\nGrabber rules configured by the attacker. We will focus on this section on the Grabber part.\n\nAfter getting the grabber rules sent as plaintext, Ficker sends some hardcoded value\n0x0C000F0A0B0A0B0A (not encrypted) to the C2. We assume that this hardcoded value\nindicates that the connection was established successfully and the configuration has been\nreceived.\n\n\n-----\n\nFigure 11: Send the hardcoded value\n\nThe last part of this connection establishing method is sending the address of the C2 server\nencrypted/obfuscated using a function we named send_enc_data.\n\n**Sending Data to C2**\n\nFickerStealer has a singular method for sending the data to the C2 server, and it does it in an\nencrypted/obfuscated way. Using this method makes the network analysis of this malware a\nlittle bit more difficult and stealthier than sending the data as plaintext like most of the\nstealers.\n\nThe function send_enc_data gets two arguments: a pointer to the data and an index flag.\nThe index flag indicates the data type used by the C2 server. This function first “encrypts” the\ndata using simple XOR rotation with one byte XOR key: 0x0A. So far, we noticed the XOR\nbyte is the same in all Ficker’s samples.\n\nAfter encrypting the data and before sending it, Ficker creates a packet for sending the data:\n\n4 bytes: the size of the encrypted data,\n\n1 byte: the index flag\n\nX bytes: the encrypted data\n\nFinally, Ficker sends this data to the C2 server in two separate requests.\n\n\n-----\n\nFigure 12: The simple XOR rotation and sending the first packet\n\nAs we mentioned earlier, the index flag indicates the data type sent to the C2 server. We\ncheck the xrefs of this function, and we found out it is called from 13 different locations and\ngets 12 different values of the index flag argument, from 0x00 to 0x0B.\n\nBy setting a conditional breakpoint on the entry of this function, we could dump the plaintext\ndata and the index flag on every call. By correlating these parameters, we figured out what\neach index flag value represents.\n\n**Index Flag value** **Data type**\n\n**0x00** Chromium-based browsers\n\n**0x01** Mozilla-based browsers\n\n**0x02** FTP clients\n\n|Index Flag value|Data type|\n|---|---|\n|0x00|Chromium-based browsers|\n|0x01|Mozilla-based browsers|\n\n\n-----\n\n|Index Flag value|Data type|\n|---|---|\n|0x03|Grabber files|\n|0x04|Screenshots|\n|0x05|System information|\n|0x06|Cryptocurrency wallets|\n|0x07|Hardware ID|\n|0x08|Others (Desktop clients)|\n|0x09|C2 address and port|\n|0x0A|poppush – Downloader command|\n|0x0B|Victim public IP|\n\n\nTable 1: Mapped index flag values\n\n### Stealing Capabilities\n\nMost applications store confidential information in various files/registry keys, and most of the\ninformation stealers have a hardcoded list of known/default locations where the sensitive file\nis located for each targeted application. Ficker’s methodology of stealing sensitive\ninformation from files is quite different from other stealers.\n\nFicker doesn’t have this typical path list for each application. It recursively searches a unique\nfile that belongs to the targeted application from a starting location (path). This recursive\nsearch is implemented by a function we named find_file. The function gets a path (starting\nlocation) and the sensitive file’s name to search, which can also be a regex expression. The\nfunction returns a list of all the locations where the file was found under the starting location.\nThis method allows Ficker to find the application folder containing the sensitive files without\nknowing exactly where they are stored (the application may be installed on a different\nlocation) — and without having all those suspicious strings.\n\n**Mozilla-based applications**\n\nFirst, Ficker calls to find_file with the full path of %appdata% and the file name cookies.sqlite\n— a file used by Mozilla-based application that stores web cookies. By doing that, it gets a\nlist of all profile folders for every installed Mozilla-based application. After it finds every\nsensitive folder, it moves to the next step: stealing the data. Ficker steals the user’s saved\n**login credentials, cookies, and autocomplete history. All those sensitive files are under**\nthe locations Ficker found at the first step.\n\n\n-----\n\nThe main difference for stealing Mozilla-based applications information is the way in which\nFicker steals the user’s saved credentials. Most of the stealers parse the login.json file and\ndecrypt the confidential information by getting the decryption key from other known database\nfiles (key4.db, cert9.db, or key3.db, cert8.db for older versions). Instead of parsing the\ncredentials file and dealing with the decryption part, Ficker sends those files to the C2 server,\nand the server does all the parsing and decrypting work of these credentials. Our guess here\nis that Ficker does this to run without having any dependencies like nss3.dll and to appear\nless suspicious.\n\nIn the case of data that doesn’t require decryption operations, such as the autocomplete and\ncookies data, Ficker parses it on the victim’s side and then sends the data to the C2 server.\n\n**Chromium-based browsers**\n\nFicker employs a similar methodology to steal Chromium-based data like it used to steal\nfrom Mozilla-based applications.\n\nTo begin with, Ficker decrypts five strings that will be starting locations: %appdata%,\n%localappdata%, %userprofile%\\Desktop, %userprofile%\\Documents,\n%USERPROFILE%\\Local Settings\\Application Data. It also decrypts the string Login Data,\nthe DB file name used by Chromium-based browsers that stores saved credentials. By\nsearching this file under those starting locations, Ficker gets all Chromium-based browsers\nusers’ profile folders.\n\nFigure 13: The folder found by find_file\n\nFor each user’s profile folder, it extracts the user’s master key from the Local State file by\nparsing this JSON file and getting the value of encrypted_key. This value is Base64 encoded\nand encrypted using DPAPI; hence, Ficker decodes this value and decrypts it using\nCryptUnprotectData. This key is used to decrypt confidential information that Chromiumbased browsers save in their SQLite database files.\n\nFor each existing profile in the browser, Ficker targets the Login Data, Cookies, and Web\nData SQLite DB files in order to steal the user’s saved login credentials, cookies, and\n**autocomplete history.**\n\n\n-----\n\nOne of the exciting things about SQLite database files is that Ficker parses those files and\n**extracts the sensitive data independently. As we mentioned earlier, Ficker doesn’t have**\nany dependencies like most of the stealers, which download or drop some dlls like sqlite3.dll\nthat make their job easier. It is common to see information stealers using sqlite3.dll’s\nexported functions to extract sensitive data using SQL queries. For instance, getting the\nuser’s saved credentials from Login Data using this query: SELECT origin_url,\nusername_value, password_value FROM logins.\n\nHowever, Ficker doesn’t use any SQL query to extract the sensitive data from the DB files. It\ngoes over the [SQLite3 database file format and extracts the sensitive file by parsing the DB](https://www.sqlite.org/fileformat.html)\nfile.\n\n**Cryptocurrency wallets**\n\nLike most information stealers, Ficker also steals crypto wallets. It doesn’t target every crypto\nwallet application, but it does target the more popular ones. For every wallet application,\nFicker decrypts the application folder location and the sensitive file name (e.g., *.wallet).\nAfter getting the location of those files using find_file, Ficker reads those files into memory\nand sends all the data to the C2 server.\n\nThe targeted applications are Bitcoin, Jaxx, Exodus, Atomic, Electrum, Zcash, Bytecoin,\nEthreum, Monero, Litecoin, and Dash.\n\n**System information**\n\nFicker gathers information and takes a screenshot of the compromised machine. When it\nfinishes collecting this information, it gathers all the data together and sends it to the C2\nserver.\n\nMoreover, Ficker collects basic information about the machine like the location of the running\nexecutable, OS version, hardware and graphic information, system time zone and language.\nIn addition, it lists all the running process and their PIDs, as well as the installed applications\non the victim’s machine.\n\n\n-----\n\nFigure 14: Collected system information\n\n### Grabber\n\nFickerStealer has a grabber feature that allows the attacker to collect any files from the\nvictim’s machine and send those to the C2 server. This feature is configurable, and the\nattacker can enable or disable it from the C2 panel. When the malware establishes its\nconnection to the C2 server (as we covered earlier), it gets the Grabber’s configuration from\nthe C2 server.\n\nThe received data contains a list of Grabber rules. Each rule has the start location and its\nmask; the mask can be a regex or file name, so the malware searches for files by the mask\nunder the start location recursively.\n\n\n-----\n\nFigure 15: The received Grabber’s configuration\n\nThe structure of the Grabber configuration looks like Code Snippet 2:\n```\nstruct rule{\n     int path_len;\n     char* startFolder; #size of path_len\n     int mask_len;\n     char* mask; #size of mask_len\n     char end_flag;\n};\nstruct grabberRules{\n     int rules_num;\n     rule* rule_list; #size of rules_num\n};\n\n```\nCode Snippet 2: Grabber configuration structure\n\nWe wrote a simple python script that parses this data by this structure. We noticed that\nattackers mainly focus on searching other cryptocurrency wallets in different locations,\npassword manager confidential information and password files. For instance,\npath:%userprofile%\\Documents, mask:*.kdbx targets KDBX files, which are used by\nKeePass and usually refer to the KeePass Password Database. You can check our IoCs\n[page in our Malware Research Repository to find more examples of Grabber’s rules.](https://github.com/cyberark/malware-research/tree/master/FickerStealer)\n\n### Downloader\n\nAfter Ficker steals as much data as possible, it moves for its last feature, which is the\nLoader. Ficker can download and execute several second-stage malware that can be done\nby running executables or loading DLLs.\n\nThe attacker can enable/disable the downloader feature from the C2 panel. The panel of the\nmalware also allows setting checks prior to downloading the second stage malware —\nchecking some of the victim’s characteristics like GeoIP, stolen credentials type, etc.\n\n\n-----\n\nBefore receiving the second stage malware from the C2 server, Ficker sends a command to\nthe C2 server- poppush.\n\nThe malware first decrypts the string poppush and then sends it to the C2 server by using\nsend_enc_data function. We assume that this string/magic commands the C2 server to\nreturn the second-stage malware data.\n\nFigure 16: Downloader communication\n\nAs we can see in figure 16, the malware sends the XORred poppush string, and it receives a\ndata structure from the C2 server.\n\nThe first four bytes are the data size, so Ficker first receives only four bytes and then\nallocates a new memory buffer for the Downloader data. The next four bytes indicate the\nnumber of binaries that received from the C2 server. In the communication with the C2\nserver above, we can see it’s configured to download two binaries. The next four bytes\nindicate the first binary size, which is right after these four bytes.\n\nAfter receiving the second-stage malware, Ficker generates a random name for each binary\nand gets the Temp folder of the current user. Ficker decrypts the binary’s extension string,\nwhich can be .exe or .dll depending on the binary type. Then it concatenates all those three\nstrings into a valid file path – %temp%+random+decrypted_exetension, e.g.,\n_C:\\Users\\win10\\AppData\\Local\\Temp\\1606398000688.exe. After that, Ficker writes the_\nbinary data to this path.\n\nThe last part of this feature is executing the second stage malware. Ficker uses\nCreateProcess to run an executable, and it uses LoadLibraryA to load a DLL.\n\n## Conclusion\n\nWe foresee an expanding number of opportunities for FickerStealer among cybercriminals\nbecause of its efficiency and differentiation from other stealers, such as its stealing\nmethodology and being written in Rust\n\n\n-----\n\nFicker has all the capabilities that cybercriminals look for in information stealers. Moreover,\nFicker uses different obfuscation techniques and because it’s written in Rust, it makes the\nanalysis of the malware more difficult — leading us to one of our main conclusions. Our first\nstrategy to “map” the malware by finding its strings paid off because it saved us time\nanalyzing the sample. By doing that, we could eventually understand any part of the malware\nquite quickly and focus only on the features that interest us without digging into the malware.\n\nCredential-theft malware will always be a popular resource used by adversaries. Even\nthough information stealers might not be the most sophisticated malware, they are still\neffective enough to cause significant damage to organizations and individuals.\n\nTo defend against these threats, organizations can use an endpoint protection solution like\nCyberArk Endpoint Privilege Manager, combine it with fundamental security awareness,\ndeploy MFA and use of strong and unique passwords to further mitigate risk.\n\n## Appendix A: Targeted Applications\n\n### Targeted Applications\n\nAll Mozilla-based browsers and Thunderbird\n\nAll Chromium-based browsers\n\nCryptocurrency wallets application: Bitcoin, Jaxx, Exodus, Atomic, Electrum, Zcash,\nBytecoin, Ethreum, Monero, Litecoin, and Dash.\n\nWindows Vault\n\nFTP clients: WinSCP, FileZilla\n\nDicscord, Pidgin\n\nSteam\n\n## Appendix B: IoCs & YARA Rule\n\n### Hashes\n\na4113ccb55e06e783b6cb213647614f039aa7dbb454baa338459ccf37897ebd6\n\n25fe7dd7a49dac5706ac0772f8baf415e7b554e68d904bc2e026ac2cb4848527\n\n6029558794981d135cf41756c3e2de0cb4b08f1533a7dcd945b2ac9ff02535bf\n\ned635f60d1cc542377ea9f0b0723f19fe998a8eb6319373a1a3177066d5d4816\n\n\n-----\n\n382055f0fca8a6172846236a2a9031ce9103359673b4b13e1c4c04bc1861d941\n\n94e60de577c84625da69f785ffe7e24c889bfa6923dc7b017c21e8a313e4e8e1\n\n25fe7dd7a49dac5706ac0772f8baf415e7b554e68d904bc2e026ac2cb4848527\n\n5a904972e7ce7ef0b9484daa3eee9860ece27845692ca5750d2b80b24acd6a8f\n\n6029558794981d135cf41756c3e2de0cb4b08f1533a7dcd945b2ac9ff02535bf\n\nb00121c90392716403386a4d407015430e121eced0603af7dc0c8a996a61cb5f\n\ne5ac51cbaab11a34c180417118933758ceae64d5fbbc00ebf210e6664963082c\n\n4abf05cd0f538e42237328617711752687faddfe314afe5adf07a24155305df5\n\n### C2 servers\n\n45.141.84[.]139:80\n\n195.154.168[.]132:81\n\nsweyblidian[.]com:80\n\nmamkindomen[.]info:80\n\n93.115.22[.]72:80\n\n95.217.5[.]249:80\n\n139.59.66[.]32:81\n\n### Yara Rule\n\n[FickerStealer Yara Rule](https://github.com/cyberark/malware-research/blob/master/FickerStealer/Ficker_Stealer.yar)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-07-19 - FickerStealer- A New Rust Player in the Market.pdf"
    ],
    "report_names": [
        "2021-07-19 - FickerStealer- A New Rust Player in the Market.pdf"
    ],
    "threat_actors": [
        {
            "id": "67bf0462-41a3-4da5-b876-187e9ef7c375",
            "created_at": "2022-10-25T16:07:23.44832Z",
            "updated_at": "2025-03-27T02:02:09.806007Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "Careto",
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "ETDA:Careto",
            "tools": [
                "Careto"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "f5bf6853-3f6e-452c-a7b7-8f81c9a27476",
            "created_at": "2023-01-06T13:46:38.677391Z",
            "updated_at": "2025-03-27T02:00:02.889755Z",
            "deleted_at": null,
            "main_name": "Careto",
            "aliases": [
                "The Mask",
                "Ugly Face"
            ],
            "source_name": "MISPGALAXY:Careto",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "9f101d9c-05ea-48b9-b6f1-168cd6d06d12",
            "created_at": "2023-01-06T13:46:39.396409Z",
            "updated_at": "2025-03-27T02:00:03.074969Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "CHROMIUM",
                "ControlX",
                "Red Dev 10",
                "RedHotel",
                "Red Scylla",
                "TAG-22",
                "BRONZE UNIVERSITY",
                "AQUATIC PANDA",
                "Charcoal Typhoon",
                "BountyGlad"
            ],
            "source_name": "MISPGALAXY:Earth Lusca",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "a66438a8-ebf6-4397-9ad5-ed07f93330aa",
            "created_at": "2022-10-25T16:47:55.919702Z",
            "updated_at": "2025-03-27T02:05:17.412024Z",
            "deleted_at": null,
            "main_name": "IRON VIKING",
            "aliases": [
                "ATK14 ",
                "BlackEnergy Group",
                "Blue Echidna ",
                "CTG-7263 ",
                "ELECTRUM ",
                "FROZENBARENTS ",
                "Hades/OlympicDestroyer ",
                "IRIDIUM ",
                "Qudedagh ",
                "Sandworm Team ",
                "Seashell Blizzard ",
                "TEMP.Noble ",
                "Telebots ",
                "Voodoo Bear ",
                "APT44 "
            ],
            "source_name": "Secureworks:IRON VIKING",
            "tools": [
                " BlackEnergy",
                " GCat",
                " GreyEnergy",
                " Industroyer",
                " KillDisk",
                " NotPetya",
                " PSCrypt",
                " TeleBot",
                " TeleDoor",
                " xData",
                "BadRabbit"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "b3e954e8-8bbb-46f3-84de-d6f12dc7e1a6",
            "created_at": "2022-10-25T15:50:23.339976Z",
            "updated_at": "2025-03-27T02:00:55.446795Z",
            "deleted_at": null,
            "main_name": "Sandworm Team",
            "aliases": [
                "Sandworm Team",
                "ELECTRUM",
                "Telebots",
                "IRON VIKING",
                "BlackEnergy (Group)",
                "Quedagh",
                "Voodoo Bear",
                "IRIDIUM",
                "Seashell Blizzard",
                "FROZENBARENTS",
                "APT44"
            ],
            "source_name": "MITRE:Sandworm Team",
            "tools": [
                "Bad Rabbit",
                "Mimikatz",
                "Exaramel for Linux",
                "Exaramel for Windows",
                "GreyEnergy",
                "PsExec",
                "Prestige",
                "P.A.S. Webshell",
                "VPNFilter",
                "Cyclops Blink",
                "SDelete",
                "AcidRain",
                "Industroyer",
                "Industroyer2",
                "BlackEnergy",
                "Cobalt Strike",
                "NotPetya",
                "KillDisk",
                "PoshC2",
                "Impacket",
                "Invoke-PSImage",
                "Olympic Destroyer"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "3a0be4ff-9074-4efd-98e4-47c6a62b14ad",
            "created_at": "2022-10-25T16:07:23.590051Z",
            "updated_at": "2025-03-27T02:02:09.878211Z",
            "deleted_at": null,
            "main_name": "Energetic Bear",
            "aliases": [
                "ATK 6",
                "Blue Kraken",
                "Crouching Yeti",
                "Dragonfly",
                "Electrum",
                "Energetic Bear",
                "Ghost Blizzard",
                "Group 24",
                "ITG15",
                "Iron Liberty",
                "Koala Team",
                "TG-4192"
            ],
            "source_name": "ETDA:Energetic Bear",
            "tools": [
                "Backdoor.Oldrea",
                "CRASHOVERRIDE",
                "Commix",
                "CrackMapExec",
                "CrashOverride",
                "Dirsearch",
                "Dorshel",
                "Fertger",
                "Fuerboos",
                "Goodor",
                "Havex",
                "Havex RAT",
                "Hello EK",
                "Heriplor",
                "Impacket",
                "Industroyer",
                "Karagany",
                "Karagny",
                "LightsOut 2.0",
                "LightsOut EK",
                "Listrix",
                "Oldrea",
                "PEACEPIPE",
                "PHPMailer",
                "PsExec",
                "SMBTrap",
                "Subbrute",
                "Sublist3r",
                "Sysmain",
                "Trojan.Karagany",
                "WSO",
                "Webshell by Orb",
                "Win32/Industroyer",
                "Wpscan",
                "nmap",
                "sqlmap",
                "xFrost"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "6abcc917-035c-4e9b-a53f-eaee636749c3",
            "created_at": "2022-10-25T16:07:23.565337Z",
            "updated_at": "2025-03-27T02:02:09.868522Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Bronze University",
                "Charcoal Typhoon",
                "Chromium",
                "Red Dev 10",
                "Red Scylla"
            ],
            "source_name": "ETDA:Earth Lusca",
            "tools": [
                "Agentemis",
                "AntSword",
                "BIOPASS",
                "BIOPASS RAT",
                "BadPotato",
                "Behinder",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "Doraemon",
                "FRP",
                "Fast Reverse Proxy",
                "FunnySwitch",
                "HUC Port Banner Scanner",
                "KTLVdoor",
                "Mimikatz",
                "NBTscan",
                "POISONPLUG.SHADOW",
                "PipeMon",
                "RbDoor",
                "RibDoor",
                "RouterGod",
                "SAMRID",
                "ShadowPad Winnti",
                "SprySOCKS",
                "WinRAR",
                "Winnti",
                "XShellGhost",
                "cobeacon",
                "fscan",
                "lcx",
                "nbtscan"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "39842197-944a-49fd-9bec-eafa1807e0ea",
            "created_at": "2022-10-25T16:07:24.310589Z",
            "updated_at": "2025-03-27T02:02:10.167471Z",
            "deleted_at": null,
            "main_name": "TeleBots",
            "aliases": [],
            "source_name": "ETDA:TeleBots",
            "tools": [
                "BadRabbit",
                "Black Energy",
                "BlackEnergy",
                "CredRaptor",
                "Diskcoder.C",
                "EternalPetya",
                "ExPetr",
                "Exaramel",
                "FakeTC",
                "Felixroot",
                "GreyEnergy",
                "GreyEnergy mini",
                "KillDisk",
                "LOLBAS",
                "LOLBins",
                "Living off the Land",
                "NonPetya",
                "NotPetya",
                "Nyetya",
                "Petna",
                "Petrwrap",
                "Pnyetya",
                "TeleBot",
                "TeleDoor",
                "Win32/KillDisk.NBB",
                "Win32/KillDisk.NBC",
                "Win32/KillDisk.NBD",
                "Win32/KillDisk.NBH",
                "Win32/KillDisk.NBI",
                "nPetya"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "8941e146-3e7f-4b4e-9b66-c2da052ee6df",
            "created_at": "2023-01-06T13:46:38.402513Z",
            "updated_at": "2025-03-27T02:00:02.824555Z",
            "deleted_at": null,
            "main_name": "Sandworm",
            "aliases": [
                "G0034",
                "IRIDIUM",
                "Blue Echidna",
                "FROZENBARENTS",
                "Seashell Blizzard",
                "IRON VIKING",
                "ELECTRUM",
                "TeleBots",
                "UAC-0113",
                "UAC-0082",
                "APT44",
                "Quedagh",
                "VOODOO BEAR",
                "TEMP.Noble"
            ],
            "source_name": "MISPGALAXY:Sandworm",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d53593c3-2819-4af3-bf16-0c39edc64920",
            "created_at": "2022-10-27T08:27:13.212301Z",
            "updated_at": "2025-03-27T02:00:55.529662Z",
            "deleted_at": null,
            "main_name": "Earth Lusca",
            "aliases": [
                "Earth Lusca",
                "TAG-22",
                "Charcoal Typhoon",
                "CHROMIUM",
                "ControlX"
            ],
            "source_name": "MITRE:Earth Lusca",
            "tools": [
                "Mimikatz",
                "PowerSploit",
                "Tasklist",
                "certutil",
                "Cobalt Strike",
                "Winnti for Linux",
                "Nltest",
                "NBTscan",
                "ShadowPad"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536020,
    "ts_updated_at": 1743041735,
    "ts_creation_date": 1653692142,
    "ts_modification_date": 1653692142,
    "files": {
        "pdf": "https://archive.orkl.eu/af420ea4d7b749d673d7f2aaefc637e4612e3925.pdf",
        "text": "https://archive.orkl.eu/af420ea4d7b749d673d7f2aaefc637e4612e3925.txt",
        "img": "https://archive.orkl.eu/af420ea4d7b749d673d7f2aaefc637e4612e3925.jpg"
    }
}