{
    "id": "0892de26-6a14-4496-8c56-fc02f9467948",
    "created_at": "2023-01-12T14:59:10.556282Z",
    "updated_at": "2025-03-27T02:06:11.201188Z",
    "deleted_at": null,
    "sha1_hash": "6f1e56227c3dbd652ce8d837497230690f298caf",
    "title": "2016-08-05 - Smoke Loader – downloader with a smokescreen still alive",
    "authors": "",
    "file_creation_date": "2016-08-29T18:17:33Z",
    "file_modification_date": "2016-08-29T13:32:06Z",
    "file_size": 1437063,
    "plain_text": "# CyberX Threat Intelligence\n\n## Rockwell Automation MicroLogix\n Remote Code Execution\n\n**COYPRIGHTS ©2015, CyberX Israel Ltd.**\n\nThis document contains proprietary and confidential information. Any unauthorized\nreproduction, use or disclosure of this material, or any part thereof, is strictly prohibited.\nThis document is solely for the use by CyberX Israel Ltd. This work is protected under the\n\ncopyright laws. All rights reserved.\n\n\n-----\n\n### Contents\nIntroduction ............................................................................................................................................ 3\n\nAbstract ................................................................................................................................................... 3\n\nPreparation.............................................................................................................................................. 4\n\nBefore Diving In ....................................................................................................................................... 4\n\nPort 80 - HTTP Server .......................................................................................................................... 4\n\nPort 44818 – EtherNet/IP .................................................................................................................... 5\n\nGetting to know the firmware ................................................................................................................. 5\n\nCustom Firmware .................................................................................................................................... 5\n\nDumping the memory ............................................................................................................................. 8\n\nReversing the HTTP server....................................................................................................................... 9\n\nMapping potential vulnerable functions ................................................................................................. 9\n\nValidating the function’s vulnerability ..................................................................................................... 9\n\nAppendix A .................................................................................................. Error! Bookmark not defined.\n\nMemory dump code for custom firmware .............................................. Error! Bookmark not defined.\n\nPOC Python Exploit .................................................................................. Error! Bookmark not defined.\n\n\n-----\n\n### Introduction\nServing customers worldwide, CyberX enables real-time detection of cyber and operational incidents\nby providing complete visibility into operational networks. As part of the research and development\nefforts backing its flagship technology, CyberX has created its Industrial Threat Intelligence capabilities.\n\nThe CyberX Threat Intelligence team has discovered numerous zero-day vulnerabilities in\nProgrammable Logical Controllers (PLCs) and industrial equipment, ranging from Denial-of-Service\n(DOS) to remote code execution.\n\nCyberX is a member of the [Industrial Internet Consortium](http://www.industrialinternetconsortium.org/) (IIC) and [ICS-ISAC](http://ics-isac.org/) and was recognized by\n[Gartner as a Cool Vendor in Security for Technology and Service Providers, 2015.](http://cyberx-labs.com/gartner-cool-vendor-2015/)\n\n### Abstract\nThis document details the research that led to the finding of a remote code execution vulnerability on\nthe Allen-Bradley MicroLogix family of controllers from Rockwell Automation.\n\nThe vulnerability has been [acknowledged by the Department of Homeland Security, and received CVSS](https://ics-cert.us-cert.gov/advisories/ICSA-15-300-03)\nv3 base score of 9.8. Part of the innovative work described in this document, which includes the\ncreation of a custom firmware, was also presented in the [2015 ICS Cyber Security Conference in Atlanta.](http://www.icscybersecurityconference.com/)\nMajor part of the interest exhibited was due to the distinct nature of the research, arising when its\nresults are compared to past vulnerabilities found in Rockwell Automation’s equipment\n\nThe document focuses on Allen-Bradley MicroLogix 1100. However, the vulnerability also relates to\nMicroLogix 1400. These controllers are used for every type of control application worldwide, rendering\nthe impact of this research extensive.\n\n\n-----\n\n### Preparation\nOur target protocol was EtherNet/IP, as it has been\nthe focal point for numerous customers. This led us\nto research the Allen-Bradley MicroLogix 1100.\n\nWhen choosing a research target it is important to\ncheck the cost-effectiveness of its firmware\navailability.\nSome vendors do not offer firmware updates, which\nmeans that we would need to extract the firmware\nout of the flash. This process is time consuming and\nnot effective.\n\nHowever, the firmware for ML1100 was easily\navailable on the official vendor site.\n\nAlthough this PLC is almost 10 years old, the latest firmware update was in 2014. Hence, we had to\nverify that the latest firmware version is installed on our device.\n\n### Before Diving In\nThe next step is to study everything we can about the device, in order to make the next steps easier.\nConnecting it with a simple RJ45 and port scanning it gives us some interesting information.\n\n#### Port 80 - HTTP Server\n\nThe HTTP server is thin and contains statistics about the device, a user management page and some\nuser defined pages.\n\nThe port may be fingerprinted by the HTTP Header Server, which its unique value is A-B WWW/0.1.\nUsually custom server headers might be an indication for a custom HTTP implementation.\n\n\n-----\n\n#### Port 44818 – EtherNet/IP\nThis port is interesting because of the information it discloses.\n```\nProduct name: 1763-L16AWA B/14.00\nVendor ID: Rockwell Automation/Allen-Bradley\nSerial number: [DWORD]\nDevice type: Communications Adapter\nDevice IP: 192.168.90.90\n\n```\nThe product name consists of the catalog number and the firmware version. For example, our catalog\nnumber is 1763-L16AWA which is ML1100, and the firmware version is B/14.00 which is version 14, the\nlatest firmware.\n\n### Getting to know the firmware\nWe have extracted the file ML1100_R03R14_Os.bin from the flashing utility and decided to scan it with\nbinwalk. The scan did not yield any significant results due to the fact that the image is a one large binary\nblob.\n\nThe next step was to determine the CPU type which this firmware runs on. Although Allen-Bradley\nstates in their official documentation that the CPU architecture is unique and proprietary, a quick search\non the internet revealed it is a ColdFire v2 CPU.\n\nLoading it into IDA Pro with the ColdFire CPU configuration and instructing IDA to disassemble from the\nfirst instruction, showed us that the firmware starts with a JMP opcode.\n\nBecause we did not provide the real loading offset, IDA could not analyze the image.\nThe flashing utility also includes a file by the name ML1100_R03R14_Os.nvs. This is a configuration file\ncontaining the value StartingLocation = 0x00008000, which is the real ROM offset.\nTo determine the RAM offset and size, we looked into the offsets referenced by the disassembled\nopcodes, and chose values that cover their ranges.\n\n### Custom Firmware\nTo better understand the firmware workings and to develop a working remote code execution exploit,\nwe had to get a better overview of the memory. Since we could not find any memory leak vulnerabilities\nwe have decided to create a custom firmware. This firmware shall allow us to dump memory.\n\n\n-----\n\nThe first attempt to patch and upload the firmware was not successful. This is due to the boot firmware\nreturning an error, stating that we tried to upload a corrupted firmware. We have assumed that some\nchecksum algorithm exists.\n\nThere are many kinds of checksums, so first we had to figure out whether the checksum is position\ndependent like CRC/MD5, or just a regular checksum that sums all the bytes or their LSB or anything\nsimilar to that. In order to test this we used the latest firmware and swapped 2 bytes of code. Uploading\nit to the device was successful. This led us to the conclusion that the error checking algorithm is position\nindependent.\n\nNow that we know this is just a plain old checksum algorithm, we started to study the header.\nBy comparing several firmware images we noticed the changes between them and how they affect the\nbytes in the header. We concluded there are 2 checksums, one for the header and one for everything\nelse.\n\nThe first noticeable change is the version. The byte 0xE means its firmware version 14.\n\nBy changing only these bytes the firmware will not be accepted, which mean they are included in a\nchecksum.\n\n\n-----\n\nThis gave us the ability to tweak the header. Below is a firmware with a nonexistent version 99:\n\nFiguring out the checksum algorithm for the whole file is very problematic, since it requires guessing\nthe fields that should be summed. Therefore we tried another approach.\n\n\n-----\n\nFirst we defined where the code starts:\n\nThen we made the following assumption:\n```\n       [Global checksum] = [Header fields checksum] + [Code area checksum]\n\n```\nThis means that patching the code area affects the global checksum. So instead of trying to find out\nwhich algorithm is needed to calculate the global checksum, we calculated once the whole code area\nchecksum, and for every patch we applied we simply modified a few bytes in order to make sure the\nnew checksum has the same value as the original.\n\nThis process allows us to maintain the same checksum as before, and to successfully upload the patched\nfirmware image.\n\n### Dumping the memory\nIn order to achieve our goal of dumping the memory, we have chosen to modify an HTTP page handler.\n\n\n-----\n\nChoosing a page handler will allow us to make sure the device boots and works properly, and to trigger\nthe execution of our code only upon the sending of an HTTP request. This method has proven itself\nbeneficial for debugging purposes, since it allows us to make sure that in case our custom patch is not\nstable it will crash only at that point.\n\nAnother important issue to note about the patching is the necessity to use only a limited set of\ninstructions. While this appears to be a standard ColdFire CPU, the instruction set lacks a large amount\nof instructions, probably due to optimization. This caused our custom patch to fail. In order to overcome\nthis issue, we have made sure we use only instructions that were observed in the original image.\n\nPatching the page handler was comprised of stripping out of all of its functionality, and replacing it with\nour code. This code takes the first key and value from the HTTP arguments, converts it to 2x32 bit\nintegers, and dumps all the memory between these two resulting integers.\n\n### Reversing the HTTP server\nThe HTTP server is a proprietary implementation by Allen-Bradley. A noticeable issue is a strong\nindicator for secure code development due to the limitation of size of almost all input buffers.\n\n### Mapping potential vulnerable functions\nIn order to facilitate the process of mapping potential vulnerable functions, we have decided to write\nIDA python scripts to map the functions under the HTTP parsing tree code that may cause a buffer\noverflow vulnerability.\n\nThe script that found the vulnerability did it by traversing the HTTP parsing code tree and mapping all\nthe copy patterns in that tree.\n\n### Validating the function’s vulnerability\nIn order for a function to be vulnerable to buffer overflow, it has to copy certain amount of data into a\nsmaller buffer. The function we decided to focus on is responsible for parsing authorization digest\nheader inside the authentication function.\n\n\n-----\n\nNow that we know which function is vulnerable to buffer overflow, we can send some non-existent\naddresses and see how the device crashes. However, crashing the device is not enough to prove that\nit is possible to cause code execution.\n\nAlthough there might be other ways, the easiest way to send our shellcode along with the exploit was\nto place it in the URI as an argument, since all of the arguments are parsed and placed into a constant\naddress in the memory. The shellcode we have written prints the word “ CyberX “ as part of the PLC’s\nmenu. The images below display the PLC’s menu before and after the execution of our exploit.\n\n\n-----\n\nBefore running the POC\n\nAfter running the POC\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/ICS SCADA/ICS Vulnerabilities/Rockwell Automation MicroLogix Remote Code Execution.pdf"
    ],
    "report_names": [
        "Rockwell Automation MicroLogix Remote Code Execution.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535550,
    "ts_updated_at": 1743041171,
    "ts_creation_date": 1472494653,
    "ts_modification_date": 1472477526,
    "files": {
        "pdf": "https://archive.orkl.eu/6f1e56227c3dbd652ce8d837497230690f298caf.pdf",
        "text": "https://archive.orkl.eu/6f1e56227c3dbd652ce8d837497230690f298caf.txt",
        "img": "https://archive.orkl.eu/6f1e56227c3dbd652ce8d837497230690f298caf.jpg"
    }
}