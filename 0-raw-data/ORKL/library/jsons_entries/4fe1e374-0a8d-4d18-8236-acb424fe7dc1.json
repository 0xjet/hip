{
    "id": "4fe1e374-0a8d-4d18-8236-acb424fe7dc1",
    "created_at": "2023-01-12T15:02:46.340725Z",
    "updated_at": "2025-03-27T02:05:31.516806Z",
    "deleted_at": null,
    "sha1_hash": "06d772cabbd14699e6d75d524e53024512e3405e",
    "title": "2020-12-07 - Commodity .NET Packers use Embedded Images to Hide Payloads",
    "authors": "",
    "file_creation_date": "2022-05-28T22:09:20Z",
    "file_modification_date": "2022-05-28T22:09:20Z",
    "file_size": 2313397,
    "plain_text": "# Commodity .NET Packers use Embedded Images to Hide Payloads\n\n**[proofpoint.com/us/blog/threat-insight/commodity-net-packers-use-embedded-images-hide-payloads](https://www.proofpoint.com/us/blog/threat-insight/commodity-net-packers-use-embedded-images-hide-payloads)**\n\n\nDecember 2, 2020\n\n\n-----\n\n[Blog](https://www.proofpoint.com/us/blog)\n[Threat Insight](https://www.proofpoint.com/us/blog/threat-insight)\nCommodity .NET Packers use Embedded Images to Hide Payloads\n\nDecember 07, 2020 Proofpoint Threat Research Team\n\n\n-----\n\nost a a e s d st buted pac ed o typ ca y a e ecutab e co ta g code to e ade a t us detect o a d sa dbo es be o e\nextracting and executing the intended payload.\n\nThere are many commodity packers written in Microsoft .NET, usually but not always containing malware also written in .NET.\n\nWe discuss two prevalent such packers used to distribute a wide variety of malware but hiding the intended payload in images.\n\n## Steganography\n\nSteganography is the technique of sending hidden messages in apparently innocent forms. For hiding data in images, the main techniques\nare:\n\nStore the hidden data at the end of an image file\nStore the hidden data within the image metadata (e.g., EXIF)\nStore the hidden data within the actual pixel data\n\nTo be truly \"hidden\" the latter would arguably mean using only the least significant bits of the data so that the image appears \"normal\" when\nrendered.\n\nThe packers discussed here generally use the entire image pixel data so aren't truly \"hidden\"; if they were displayed, the images would appear\nrandom.\n\n## \"CyaX\" packer\n\nIn this packer, the .NET executable contains a square PNG image in a .NET resource, which is typically a large proportion of the whole file\nsize.\n\nThe image can be decoded to an intermediate executable, which contains a .NET resource which in turn can be decoded to the payload.\nSometimes the intermediate executable uses an additional commodity packer such as ConfuserEx or .NET Reactor.\n\nDetails\n\nThe first stage payload is decoded from the Blue, Green, Red, and Alpha (BGRA) channels taking pixels in columns. Some versions use Red,\nGreen, and Blue (RGB) channels instead.\n\nFor example, in sample SHA256 - 026b38e8eb0e4f505dc5601246143e7e77bbd2630b91df50622e7a14e0728675:\n\n_Figure 1: Image taken from sample SHA256: 026b38e8eb0e4f505dc5601246143e7e77bbd2630b91df50622e7a14e0728675_\n\nUsing channels BGRA from the image we get data starting:\n\n\n-----\n\nIn general, the extracted data is then XORed with a short XOR key or the first 16 bytes of the data and possibly decompressed with gzip,\nyielding an intermediate stage .NET executable.\n\nFor the above sample, the XOR key is (in hex) \"74 43 74 17 74 02 74 23 74\", which gives the executable:\n\nThis intermediate stage is often itself packed with ConfuserEx, but after unpacking that, it contains a .NET resource which contains the\npayload, typically XORed with two keys:, a short (often truncated Unicode) one, followed by a 16-byte key stored at the start of the resulting\nfile.\n\nIn the above sample, the intermediate executable is packed with .NET Reactor. After deobfuscation with a tool such\nas [de4dot, the deobfuscated executable contains a resource \"2EJp1.resources\" which starts:](https://github.com/de4dot/de4dot%22%20/)\n\nXORing with key \"00 77 00 55 00 6c 00 59 00 71 00 79 00 4e\" (\"wUlYqyNZJIbjVN\" in Unicode, truncated to half the length):\n\nand then XORing with the first 16 bytes of the result gives the payload, Agent Tesla (a prevalent information stealer) in this case:\n\n\n-----\n\nIn some early versions of this packer, this .NET resource was named \"CyaX_Sharp.Properties.Resources.resources\" hence the name we have\ngiven to this packer family.\n\n## Gzip variant\n\nAs mentioned above, some samples use the Red, Green, and Blue (RGB) channels, and some compress the intermediate executable\nwith gzip.\n\nFor example, in sample SHA256 - 083521fa4522245adc968b1b7dd18da29b193fd41572114c9d7dd927918234ea:\n\n_Figure 2: Image taken from sample SHA256: 083521fa4522245adc968b1b7dd18da29b193fd41572114c9d7dd927918234ea_\n\nthe image uses RGB channels which decode to:\n\nXORing with key (in hex) \"24 04 33\" gives:\n\n\n-----\n\nwhich is a 4-byte DWORD containing the uncompressed file size, followed by a gzip-ed file, starting with a 10-byte gzip header, which\ndecompresses to the intermediate .NET executable:\n\nThis contains a .NET resource \"d2o6x4FhIdl.resources\" starting:\n\nwhich when XORed with keys \"00 66 00 43 00 73 00 6b 00 62 00 67 00\" (\"fCskbgkLbLArI\" in Unicode, truncated) and then \"07 2e 8c d5 50 23\n1b e3 be be 38 4f 0f 4b 8d ca\" gives:\n\nwhich contains the payload, Agent Tesla again.\n\n## Steganographic variant \n\nIn a [recent variation of this packer, the first stage payload is actually stored in a second PNG image extracted from the least significant bits of](https://blog.morphisec.com/agent-tesla-a-day-in-a-life-of-ir)\nthe Red, Green, and Blue channels in the first image, taking pixels in rows (so \"proper\" steganography in this case). The intermediate stage\n.NET executable is then extracted from the Blue, Green, Red, and Alpha channels of the second image with pixels taken in columns, without\nXOR this time.\n\nFor example, in sample SHA256 – 04794ec7e7eb5c6611aada660fb1716a91e01503fb4703c7d2f2099c089c9017:\n\n\n-----\n\n_Figure 3: Image taken from sample SHA256: 04794ec7e7eb5c6611aada660fb1716a91e01503fb4703c7d2f2099c089c9017_\n\nthe image has RGB channels and, taking pixels by rows first rather than columns, leads to:\n\n(There is also an Alpha channel, with all values set to 0xff.)\n\nTaking groups of 8 bytes and then the least significant bits in reverse order gives us (for example \"ff 01 00 ff 01 00 fe 01\" -> \"10011011\" ->\n0x9b):\n\nThis is a file size stored in a DWORD (0x1e09b) followed by the second PNG image. Using BGRA and columns first, this decodes to:\n\n\n-----\n\nwhich contains a .NET resource \"biGzxmYEphCl\":\n\nwhich when XORed with \"4c 00 6b 00 74 00 79 00 54 00 65 00 66 00 65 00\" (\"LktyTefe\" in Unicode):\n\ngives the payload, which in this case is Remcos RAT.\n\n## \"Hectobmp\" packer\n\nIn this packer, the .NET executable contains typically several hundred small images in .NET resources, which each contain a part of the\npayload and need to be reassembled in the correct order.\n\nEarlier versions used the BMP file format, and later versions have switched to using PNG. The name we have given to this packer comes from\n\"hecto-\" from the metric system prefix for a hundred.\n\n## Details\n\n\n-----\n\n_Figure 4: .NET resources list (from ILSpy)_\n\nFor example, in sample SHA256 – 0091c6bdceecf3e0143b4eaaefca1cd56cbfdfc55f99c167f9dd1f3a48928bb5:\n\n_Figure 5: First image taken from sample SHA256: 0091c6bdceecf3e0143b4eaaefca1cd56cbfdfc55f99c167f9dd1f3a48928bb5_\n\nwhich contains 135 images, the first image decodes, using Green, Red and Blue channels, rows first, to:\n\n\n-----\n\nThis includes the start of a Windows executable.\n\nThe size of the chunk extracted from each image is stored in the first four bytes (DWORD), 0x30d in this case, less 15, and the required chunk\nof data starts at the 6th byte.\n\nThe chunks need to be assembled in numerical order of the resource names, which is different from the alphabetical order they appear in the\nfile which is:\n\nand the order they are referenced in the .NET metadata which is:\n\n\n-----\n\nThe reassembled payload in this case is Loki Bot Stealer.\n\nIn the following sample, SHA256 – 09c8cbd9cdfda1fcb7c6a051887213dc3e3ccf00a5877eca3d3e374f077b98d5, the images are BMPs and\nthe first one looks like:\n\n_Figure 6: Image taken from sample SHA256: 09c8cbd9cdfda1fcb7c6a051887213dc3e3ccf00a5877eca3d3e374f077b98d5_\n\nThe image decodes to the following, with chunk size highlighted in green, chunk data highlighted in yellow and blue:\n\n\n-----\n\nIn this case, when assembled from the images, the payload is compressed using zlib Deflate, starting at byte 0xb0, highlighted in blue.\n\nDecompressing gives:\n\nwhich again is Agent Tesla in this case.\n\n## Conclusion\n\nGenerally, packers have different features that allow them to circumvent detection mechanisms by appearing as benign files, being difficult to\nreverse engineer, or incorporating sandbox evasion techniques. In this blog we've looked at two packers which use embedded images to hide\nthe payload, one using a single image and the other using hundreds of them. These are just a few of the many tools threat actors have at their\ndisposal to aid in distributing malware, collecting sensitive information, and gaining unauthorized access to systems.\n\n**IOCs**\n\n**IOC** **Type** **Description**\n\n026b38e8eb0e4f505dc5601246143e7e77bbd2630b91df50622e7a14e0728675 SHA256 CyaX PNG sample with channels BGRA\n\nc8c79ba04ab76c96db913f05b4b5bab36e7e0148fd72148df170a4be94d879a3 SHA256 Agent Tesla payload in\n026b38e8eb0e4f505dc5601246143e7e77bbd2630b\n\n083521fa4522245adc968b1b7dd18da29b193fd41572114c9d7dd927918234ea SHA256 CyaX PNG sample with gzipped data\n\na6f7edd2654412c25d7c565cb5b52e1382799a8b86d6bc44e965b554f6344618 SHA256 Agent Tesla payload in\n083521fa4522245adc968b1b7dd18da29b193fd415\n\n04794ec7e7eb5c6611aada660fb1716a91e01503fb4703c7d2f2099c089c9017 SHA256 CyaX PNG sample with double steganography\n\n\n-----\n\n6d9c861bf6f1495a4bddc7c745eb5b504692b4d6eae31e89453f0829760b1b90 SHA256 Remcos RAT payload in\n04794ec7e7eb5c6611aada660fb1716a91e01503fb4\n\n0091c6bdceecf3e0143b4eaaefca1cd56cbfdfc55f99c167f9dd1f3a48928bb5 SHA256 Hectobmp sample with PNGs\n\n1180c158968faaf0a4951e9a0c59996f0fb29cdad9443aa2097efb5bc7f123f4 SHA256 Loki Bot payload in\n0091c6bdceecf3e0143b4eaaefca1cd56cbfdfc55f99\n\n09c8cbd9cdfda1fcb7c6a051887213dc3e3ccf00a5877eca3d3e374f077b98d5 SHA256 Hectobmp sample with BMPs\n\nc3b85d8291281d73cfdd8373cb2b32cdc4c3a602233f99ab3cbbd34bd4e3c99b SHA256 Agent Tesla payload in\n09c8cbd9cdfda1fcb7c6a051887213dc3e3ccf00a587\n\n**References**\n\n[De4dot](https://github.com/de4dot/de4dot)\n\n[ILSpy](https://github.com/icsharpcode/ILSpy)\n\n[Agent Tesla: A day in a life of IR, Full description of an Agent Tesla campaign using CyaX packer (steganographic variant)](https://blog.morphisec.com/agent-tesla-a-day-in-a-life-of-ir)\n\nSubscribe to the Proofpoint Blog\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-07 - Commodity .NET Packers use Embedded Images to Hide Payloads.pdf"
    ],
    "report_names": [
        "2020-12-07 - Commodity .NET Packers use Embedded Images to Hide Payloads.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535766,
    "ts_updated_at": 1743041131,
    "ts_creation_date": 1653775760,
    "ts_modification_date": 1653775760,
    "files": {
        "pdf": "https://archive.orkl.eu/06d772cabbd14699e6d75d524e53024512e3405e.pdf",
        "text": "https://archive.orkl.eu/06d772cabbd14699e6d75d524e53024512e3405e.txt",
        "img": "https://archive.orkl.eu/06d772cabbd14699e6d75d524e53024512e3405e.jpg"
    }
}