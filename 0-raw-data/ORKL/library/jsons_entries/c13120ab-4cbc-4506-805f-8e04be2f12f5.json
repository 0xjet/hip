{
    "id": "c13120ab-4cbc-4506-805f-8e04be2f12f5",
    "created_at": "2023-01-12T15:10:18.004934Z",
    "updated_at": "2025-03-27T02:05:30.912126Z",
    "deleted_at": null,
    "sha1_hash": "f7a7f0c17cee5a485a48e05a57c6f99c9c6b4108",
    "title": "2020-08-19 - Performing Kerberoasting without SPNs",
    "authors": "",
    "file_creation_date": "2022-05-28T19:28:23Z",
    "file_modification_date": "2022-05-28T19:28:23Z",
    "file_size": 1623587,
    "plain_text": "# Kerberoasting without SPNs\n\n**swarm.ptsecurity.com/kerberoasting-without-spns/**\n\nArseniy Sharoglazov August 19, 2020\n\n## Author\n\n[Arseniy Sharoglazov](https://swarm.ptsecurity.com/author/arseniy-sharoglazov/)\nPenetration Testing Expert\n\n[_mohemiv](https://twitter.com/_mohemiv)\n\n**Service principal names (SPNs) are records in an Active Directory (AD) database that**\nshow which services are registered to which accounts:\n\nAn example of an account that has SPNs\n\n\n-----\n\nIf an account has an SPN or multiple SPNs, you can request a service ticket to one of these\nSPNs via Kerberos, and since a part of the service ticket will be encrypted with the key\nderived from the account’s password, you will be able to brute force this password offline.\nThis is how Kerberoasting works.\n\nThere is a way to perform the Kerberoasting attack without knowing SPNs of the target\nservices. I’ll show how it could be done, how it works, and when it could be useful.\n\n## Kerberos Basics\n\nKerberos is an open source binary protocol based on the ASN.1 format. The core of\nKerberos is key distribution center (KDC) services, which use 88/tcp and 88/udp ports. In the\nActive Directory environment they are installed on each of the domain controllers.\n\nLet’s run the GetUserSPNs.py tool from Impacket to demonstrate how Kerberoasting works:\n\nPerforming the Kerberoasting attack in a lab environment\nFirst, the tool connects to LDAP, and finds users which have SPNs and which are not\nmachine accounts. Every machine account in the AD has a bunch of SPNs, but their service\ntickets are not brute-forceable because machine accounts have passwords that are 240\nbytes long.\n\n\n-----\n\nThen, the tool connects to a KDC, and for each of the discovered accounts gets a service\nticket using one of its SPNs. In our example only one account was discovered, and the tool\nchosed “MSSQLSvc/sp-sql:1433” SPN to request a ticket.\n\nIt’s not important whether chosen services are functioning; the existence of an SPN in the\nAD database is sufficient for the attack.\n\nHere is the traffic dump of this GetUserSPNs.py launch, so now we can examine all the\ndescribed stages in detail:\n\nTraffic dump of the Kerberoasting attack\n\n## How clients get TGTs\n\nEach client must authenticate to the KDC and obtain a ticket-granting ticket (TGT), which will\nallow them to ask for any number of service tickets going forward.\n\nThis mechanism is used to reduce the number of needed authentications, and there is no\nway to bypass it and request a service ticket without having a TGT.\n\n**Unauthenticated AS-REQ / Preauth Request**\n\nAS-REQ packets serve to ask for TGTs.\n\nIn AS-REQ clients specify the special “krbtgt/DomainFQDN” SPN in the sname field, and the\nprincipal name of the account to which the TGT is being requested for in the cname field:\n\n\n-----\n\nContent of the unauthenticated AS-REQ packet (#7)\nThe first AS-REQ packet is sent without authentication data to maintain backwards\ncompatibility. It will succeed only if the DONT_REQ_PREAUTH flag in the Active Directory\nfor the target account is set.\n\nThe response for AS-REQs should contain a structure that is encrypted and signed with the\nkey derived from the client account’s password, so if AS-REQs worked without any\nauthentication, anyone would be able to brute force anyone else’s password offline.\n\nThis is called an ASREPRoasting attack, and in Impacket it can be performed by the\nGetNPUsers.py script:\n\nPerforming an ASREPRoasting attack using GetNPUsers.py from Impacket\nOne application of ASREPRoasting is Targeted Kerberoasting. It relies on intentionally\nsetting the DONT_REQ_PREAUTH flag for accounts you control in the AD, and getting their\n_$krb5asrep$ hashes_\n\n\n-----\n\nSince the Administrator account we used doesn t have the DONT_REQ_PREAUTH flag\nset, the KDC sent a KRB-ERR packet to the client with the KRB_PREAUTH_REQURED\nerror. This packet is called Preauth Request.\n\nContent of the KRB-ERR packet (#8)\nIf the “Administrator” account didn’t exist, we would get the\nKDC_ERR_C_PRINCIPAL_UNKNOWN error. This is the feature that is used in Kerberos\nUser Enumeration attacks.\n\n**Authenticated AS-REQ**\n\nLet’s examine the next AS-REQ packet:\n\n\n-----\n\nContent of the authenticated AS-REQ packet (#9)\nThe next AS-REQ is basically the same request as the first one, but it contains data which\ncould authorize the client. This data is a special structure that contains the current\ntimestamp, and this structure is encrypted and signed with the key derived from the\naccount’s password.\n\nKeys derived from account’s passwords are known as Kerberos Keys, and they’re calculated\ndifferently depending on the utilized encryption algorithm:\n\nAES-128 and AES-256: the key is calculated from the PBKDF2 hash of the password\nRC4: the key is calculated from the NT hash of the password (always used with the\nPass-The-Hash attack)\nDES: the key is calculated directly from the password\n\nUsing a client principal name in the request, the KDC tries to look up the client’s account in\nthe AD database, extract its precalculated Kerberos keys, and verify the client’s identity.\n\n**AS-REP**\n\nAfter the KDC verifies the client’s identity, it sends an AS-REP packet that contains data the\nclient can construct a TGT memory object from:\n\n\n-----\n\nContent of the AS-REP packet (#10)\nThe TGT itself is encrypted and signed with the kerberos key of the krbtgt account, so it’s\nintended to be unpacked only on KDC sides. It contains a session key, metadata, and the\nclient’s Privileged Attribute Certificate (PAC). A PAC includes the client’s name, security\nidentifier (SID), and groups.\n\nIn order for a client to use a TGT, it needs to construct a TGT memory object, which will\ncontain the TGT itself, its session key, and all the metadata. Clients extract the session key\nfrom the part of an AS-REP that is encrypted by their keys.\n\n## How clients get Service Tickets\n\nAfter a client constructs a TGT memory object, it can ask for any number of service tickets\nusing TGS-REQ packets. The KDC will respond with TGS-REP packets when these\nrequests are accepted.\n\n**TGS-REQ**\n\nA TGS-REQ contains a service principal name that the ticket is requesting for, a TGT, and a\nstructure encrypted with the TGT session key and containing the current timestamp:\n\n\n-----\n\nContent of the TGS-REQ packet (#11)\nWhen the KDC receives a TGS-REQ, it decrypts the TGT, extracts the session key, and\nchecks the client’s identity.\n\n**TGS-REP**\n\nTGS-REP packets are used to transfer service tickets to KDC clients.\n\nAfter the KDC verifies the client’s identity, the following steps are happening:\n\n1. The KDC checks if the TGT is still valid according to the decrypted timestamps;\n2. If more than 15 minutes have passed since the TGT was issued, the KDC recalculates\n\nthe decrypted PAC, and check if the client has not been disabled in the Active\nDirectory;\n3. The KDC looks up an account that the sent service principal name is resolving to;\n4. The KDC extracts the kerberos key of the discovered account;\n\n\n-----\n\n5. The KDC constructs a service ticket, which consists of the PAC and the service ticket\n\nsession key; the service ticket is encrypted and signed with the service account’s\nkerberos key;\n6. The KDC creates a structure with the service ticket session key and encrypts and signs\n\nit with the TGT session key.\n\nBoth the service ticket and the structure with the service ticket session key are included in\nthe TGS-REP packet:\n\nContent of the TGS-REP packet (#12)\nThe encrypted part of the service ticket is the part that is brute forced in the Kerberoasting\nattack.\n\n## Exploring formats of Principal Names\n\nLet’s examine principal names in the AS-REQ packet we gathered before:\n\n\n-----\n\nAn example\n\nof principal names in Kerberos traffic\nClient principal names are passed in cname fields, and service principal names are sent in\nsname fields. All principal names are accompanied by an integer called the principal name\ntype.\n\nPrincipal names are usually split by the “/” character into a sequence of strings. For example,\nthe principal name krbtgt/CONTOSO.COM in Kerberos traffic consists of two strings: krbtgt\nand CONTOSO.COM.\n\nAccording to [RFC 4120, cname and sname fields have different purposes, but the structure](https://tools.ietf.org/html/rfc4120)\nof these fields is identical:\n```\nKDC-REQ-BODY  ::= SEQUENCE {\n kdc-options [0] KDCOptions,\n cname    [1] PrincipalName OPTIONAL\n realm    [2] Realm\n sname    [3] PrincipalName OPTIONAL,\n ...\n}\nPrincipalName  ::= SEQUENCE {\n name-type  [0] Int32,\n name-string [1] SEQUENCE OF KerberosString\n}\nKerberosString ::= GeneralString (IA5String)\n\n```\n\n-----\n\nThe identical structure of cname and sname fields caught my attention, and I decided to test\ndifferent options of their usage in the Kerberos protocol.\n\n## The Kerberos Secret\n\nIt was discovered that Windows KDC services treat cname and sname fields by the same\nfunction set, and it’s irrelevant which format of a principal name you choose at any given\ntime.\n\n**All Principal Names that resolve to the same account are equal**\n\nIf you have an SPN value in a Kerberos packet, you can substitute it to the SAM Account\nName (SAN) value of the account the SPN belongs, and nothing will break:\n\nAn example of a TGT-REQ packet with a SAN\nThis way you can perform the Kerberoasting attack without knowing any SPN of the target\naccount. But the existence of at least one SPN for the target account will continue to be\nneeded.\n\n## Bonus: Revisiting S4U and AnySPN attacks\n\nI examined Impacket source code, and I found two interesting places which are closely\nrelated to the discovered technique, but not related to Kerberoasting.\n\n**S4U2Self and S4U2Proxy Requests with SAM Account Names**\n\n\n-----\n\nLet s try to abuse Resource-Based Constrained Delegation using getST.py form Impacket:\n\nAn example of abusing Resource-Based Constrained Delegation using Impacket\nHere we have the “user01” account that has the “http/test” SPN and privileges to delegate\naccess to any SPN of the “SRV02$” account.\n\n[According to the specification (S4USelf KRB_TGT_REQ,](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/36a72c74-7995-4cba-a2d2-6c9471a2a6af) [S4U2Proxy KRB_TGS_REQ), the](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/ddb2cafd-1f01-4834-b52a-d4a5b34cd960)\nuser01’s service should use its SPN in S4U2Self and S4U2Proxy requests. However, you\ncan see that Impacket uses SANs in such requests:\n\n\n-----\n\nTraffic Dump of Impacket’s S4U2Self request\nThese requests don’t comply with the specification, but succeed because Windows KDCs\nare insensitive to given principal name formats.\n\n**AnySPN Attack**\n\nImpacket implements a thing called AnySPN attack. This attack tries to modify the SPN in\nthe given service ticket file, when it’s different from the target service SPN:\n\n\n-----\n\nPerforming the AnySPN attack using Impacket\n[Alberto Solino wrote an excellent article Kerberos Delegation, SPNs and More explaining](https://www.secureauth.com/blog/kerberos-delegation-spns-and-more/)\nhow it works.\n\nHere is the main section from this article:\n\nA fragment of Alberto Solino’s article\nBriefly, Benjamin Delpy, Ben Campbell and Alberto Solino noticed that a service ticket for\nService A on Host A might work for Service B on Host A.\n\nActually, if we decrypt any service ticket’s encrypted part, we will see that it doesn’t contain\nany SPNs:\n\n\n-----\n\nDecrypting the service ticket’s encrypted part using the service account’s password\n\nPrinting the information contained in the service ticket’s encrypted part\n\n\n-----\n\nThe service ticket s encrypted part contains only the ticket s session key, the metadata, and\nthe authenticating user’s PAC. The service ticket’s SPN is contained in the unencrypted and\nunsigned part of the protocol, and it may simply not be taken into account by the client.\n\n**A Service Ticket is valid for all services run by its service account**\n\nSo, if you wondered which SPN a service ticket is issued to when it’s requested without an\nSPN, now you know that the service ticket just don’t contain any.\n\n## Bonus: Playing with Principal Name Types\n\nThe structure of cname and sname fields contain an integer called Principal Name Type.\nThe RFC 4120 specification defines 9 possible values for it:\n\n[An excerpt from RFC 4120: 6.2. Principal Names](https://tools.ietf.org/html/rfc4120#page-99)\nI’ve done some research, and I’ve created a table with the actual Principal Name Types\nvalues and their meanings in Windows:\n\n**Name Type** **Value** **Meaning**\n\nNT-UNKNOWN 0 Represents SPN and SAN formats\n\n\n-----\n\nNT-PRINCIPAL 1 Equal to NT-UNKNOWN\n\nNT-SRV-INST 2 Equal to NT-UNKNOWN\n\nNT-SRV-HST 3 Equal to NT-UNKNOWN\n\nNT-SRV-XHST 4 Represents SPN format\n\nNT-UID 5 Not supported\n\nNT-X500-PRINCIPAL 6 Represents DN format\n\nNT-SMTP-NAME 7 Equal to NT-UNKNOWN\n\nNT-ENTERPRISE 10 Represents UPN, SAN and multiple\nDomainName+SAN formats\n\nNT-MS-PRINCIPAL -128 Represents SAN and multiple DomainName+SAN\nformats\n\n\nNT-MS-PRINCIPALAND-ID\n\nNT-ENT-PRINCIPALAND-ID\n\n\n-129 Equal to NT-MS-PRINCIPAL\n\n-130 Equal to NT-X500-PRINCIPAL\n\n- Equal to NT-UNKNOWN\n\n\nI found NT-ENTERPRISE type more valuable than the commonly used NT-UNKNOWN one.\nIt supports the following bunch of name formats:\n\nuserPrincipalName\nsAMAccountName\nsAMAccountName@DomainNetBIOSName\nsAMAccountName@DomainFQDN\nDomainNetBIOSName\\sAMAccountName\nDomainFQDN\\sAMAccountName\n\nNote that if you use the SRV01 string as a sAMAccountName, and the SRV01 account does\nnot exist, and the SRV01$ account exists, this name will be treated as a principal name of\nthe SRV01$ account.\n\nOther interesting Principal Name Types is NT-X500-PRINCIPAL. It supports DNs in the RFC\n1779 structure. Here are three examples of how the same Active Directory object can be\nwritten in this structure:\n```\nCN=SQL ADMIN,OU=LAB Users,DC=CONTOSO,DC=COM\nCN=\"SQL ADMIN\";OU=\"LAB Users\";DC=\"CONTOSO\";DC=\"COM\"\nOID.2.5.4.3=SQL ADMIN,OU=LAB Users,DC=CONTOSO,DC=COM\n\n```\n\n-----\n\nUnfortunately, the NT-X500-PRINCIPAL type is not supported across forest trusts.\n\n## The Technique’s Application in Kerberoasting\n\nI’ve added the usage of NT-ENTERPRISE and NT-MS-PRINCIPAL types to Impacket’s\nGetUserSPNs.py. Let’s see three common scenarios when these changes are necessary for\nKerberoasting to succeed.\n\n**Kerberoasting with no access to LDAP**\n\nYou might find yourself in a situation where you have access to a KDC service, you have an\naccount list obtained (for example, via a RID cycling attack), and you don’t have SPNs.\n\nSince you no longer need SPNs, you can request service tickets just by a user list using the\nnew -userfile option:\n\nPerforming Kerberoasting by a user list using the new GetUserSPNs.py\nThe -userfile option utilizes the NT-ENTERPRISE type to look up accountd from the specified\nfile.\n\n**Kerberoasting accounts with incorrect SPNs**\n\nThere are two types of SPNs for which KDCs prohibit returning tickets:\n\nWrong syntax SPNs\nDuplicate SPNs, i.e. when the same SPN values are assigned to multiple accounts\n\nIf a KDC finds that one of these is the case, it returns the\nKDC_ERR_S_PRINCIPAL_UNKNOWN error as if the passed SPN didn’t exist:\n\n\n-----\n\nKerberoasting an account with an incorrect SPN\nThe new GetUserSPNs.py wraps the account list from LDAP to NT-MS-PRINCIPAL type and\ndoesn’t utilize SPNs, so you will get the hashes even from misconstrued SPNs:\n\nKerberoasting an account with an incorrect SPN using the new GetUserSPNs.py\nInternally the “DomainFQDN\\sAMAccountName” format is utilized, and the “\\” character is\nchanged to “/” in the output to comply the username with the Impacket format and prevent its\nescaping in other tools.\n\n**Kerberoasting accounts with NetBIOS Name SPNs via Forest Trusts**\n\nWhen you ask for a service ticket for an SPN from another domain, and this SPN has a\nhostname in a NetBIOS name format, your KDC won’t be able to find the target service:\n\nKerberoasting an account with a NetBIOS Name SPN via a Forest Trust\n\n\n-----\n\nWith the new GetUserSPNs.py file you will never get the\nKDC_ERR_S_PRINCIPAL_UNKNOWN for such services:\n\nKerberoasting an account with a NetBIOS Name SPN via a Forest Trust using the new\nGetUserSPNs.py\n\n## Afterwords\n\nI hope you found the information about requesting service tickets without specifying SPNs\nuseful, and the description of the Kerberos protocol and the “Bonus: Revisiting S4U and\nAnySPN attacks” section helpful as well.\n\nBelow is the list of tools which currently support described in the article techniques.\n\n**Impacket**\n\nThe updated GetUserSPNs.py script is available in the official Impacket repository:\n[https://github.com/SecureAuthCorp/impacket](https://github.com/SecureAuthCorp/impacket)\n\nThanks [@agsolino for merging!](https://twitter.com/agsolino)\n\n**Rubeus**\n\n[Charlie Clark (@exploitph) added the support of NT-ENTERPRISE principals to Rubeus:](https://twitter.com/exploitph)\n[PR#60](https://github.com/GhostPack/Rubeus/pull/60)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-08-19 - Performing Kerberoasting without SPNs.pdf"
    ],
    "report_names": [
        "2020-08-19 - Performing Kerberoasting without SPNs.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536218,
    "ts_updated_at": 1743041130,
    "ts_creation_date": 1653766103,
    "ts_modification_date": 1653766103,
    "files": {
        "pdf": "https://archive.orkl.eu/f7a7f0c17cee5a485a48e05a57c6f99c9c6b4108.pdf",
        "text": "https://archive.orkl.eu/f7a7f0c17cee5a485a48e05a57c6f99c9c6b4108.txt",
        "img": "https://archive.orkl.eu/f7a7f0c17cee5a485a48e05a57c6f99c9c6b4108.jpg"
    }
}