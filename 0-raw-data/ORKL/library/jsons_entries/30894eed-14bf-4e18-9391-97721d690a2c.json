{
    "id": "30894eed-14bf-4e18-9391-97721d690a2c",
    "created_at": "2022-12-07T02:08:17.570474Z",
    "updated_at": "2025-03-27T02:16:34.987662Z",
    "deleted_at": null,
    "sha1_hash": "7f9b8506b73078f6b437f402197deadcb15e46e3",
    "title": "",
    "authors": "",
    "file_creation_date": "2022-12-07T01:10:20Z",
    "file_modification_date": "2022-12-07T01:10:20Z",
    "file_size": 1675324,
    "plain_text": "# Blowing Cobalt Strike Out of the Water With Memory Analysis\n\n**[unit42.paloaltonetworks.com/cobalt-strike-memory-analysis](https://unit42.paloaltonetworks.com/cobalt-strike-memory-analysis/)**\n\nDecember 2, 2022\n\n[By Dominik Reichel, Esmid Idrizovic and Bob Jung](https://unit42.paloaltonetworks.com/author/dominik-reichel/)\n\nDecember 2, 2022 at 6:00 AM\n\n[Category: Malware](https://unit42.paloaltonetworks.com/category/malware-2/)\n\n[Tags: Cloud-Delivered Security Services, Cobalt Strike, Cortex XDR, Evasive Malware,](https://unit42.paloaltonetworks.com/tag/cloud-delivered-security-services/)\n[KoboldLoader, LithiumLoader, MagnetLoader, Sandbox, WildFire](https://unit42.paloaltonetworks.com/tag/koboldloader/)\n\n[This post is also available in: 日本語 (Japanese)](https://unit42.paloaltonetworks.jp/cobalt-strike-memory-analysis/)\n\n## Executive Summary\n\nUnit 42 researchers examine several malware samples that incorporate Cobalt Strike\ncomponents, and discuss some of the ways that we catch these samples by analyzing\nartifacts from the deltas in process memory at key points of execution. We will also\ndiscuss the evasion tactics used by these threats, and other issues that make their analysis\nproblematic.\n\n[Cobalt Strike is a clear example of the type of evasive malware that has been a thorn in the](https://www.cobaltstrike.com/)\nside of detection engines for many years. It is one of the most well-known adversary\nsimulation frameworks for red team operations. However, it’s not only popular among\nred teams, but it is also abused by many threat actors for malicious purposes.\n\n\n-----\n\nAlthough the toolkit is only sold to trusted entities to conduct realistic security tests, due\nto source code leaks, its various components have inevitably found their way into the\narsenal of malicious actors ranging from ransomware groups to state actors. Malware\n[authors abusing Cobalt Strike even played a role in the infamous SolarWinds incident in](https://unit42.paloaltonetworks.com/solarstorm-supply-chain-attack-timeline/)\n2020.\n\nRelated Unit 42 Topics [Cobalt Strike, Sandbox](https://unit42.paloaltonetworks.com/tag/cobalt-strike/)\n\n## Table of Contents\n\nOverview of Cobalt Strike\nKoboldLoader SMB Beacon\nIn-Memory Evasion\nMagnetLoader\nLithiumLoader\nLithiumLoader Detection Issues\nCatching Cobalt Strike Through Analyzing Its Memory\nAutomatic Payload Extraction\nFunction Pointer Data\nOS Structure Modifications\nPage Permissions\nConclusion\nIndicators of Compromise\nAppendix\n\n## Overview of Cobalt Strike\n\nThe main driver for the proliferation of Cobalt Strike is that it is very good at what it does.\nIt was designed from the ground up to help red teams armor their payloads to stay ahead\nof security vendors, and it regularly introduces new evasion techniques to try to maintain\nthis edge.\n\nOne of the main advantages of Cobalt Strike is that it mainly operates in memory once the\ninitial loader is executed. This situation poses a problem for detection when the payload is\nstatically armored, exists only in memory and refuses to execute. This is a challenge to\nmany security software products, as scanning memory is anything but easy.\n\nIn many cases, Cobalt Strike is a natural choice for gaining an initial footprint in a\ntargeted network. A threat actor can use a builder with numerous deployment and\nobfuscation options to create the final payload based on a customizable template.\n\nThis payload is typically embedded into a file loader in encrypted or encoded form. When\nthe file loader is executed by a victim, it decrypts/decodes the payload into memory and\nruns it. As the payload is present in memory in its original form, it can be detected easily\ndue to some specific characteristics.\n\n\n-----\n\nAs malware researchers, we often see potentially interesting malicious samples that turn\nout to just be loaders for Cobalt Strike. It’s also often unclear if a loader was created by a\nred team or a real malicious actor, thus making attribution even more challenging.\n\nIn the next few sections, we’re going to take a closer look into three different Cobalt Strike\nloaders that were detected out of the box by a new hypervisor based sandbox we designed\nto allow us to analyze artifacts in memory. Each sample loads a different implant type,\nnamely an SMB, HTTPS and stager beacon. We dubbed these Cobalt Strike loaders\nKoboldLoader, MagnetLoader and LithiumLoader. We will also discuss some of the\nmethods we can use to detect these payloads.\n\n## KoboldLoader SMB Beacon\n\nThe sample we’re looking at was detected during a customer incident.\n\nSHA256: 7ccf0bbd0350e7dbe91706279d1a7704fe72dcec74257d4dc35852fcc65ba292\n\nThis 64-bit KoboldLoader executable uses various known tricks to try to bypass\nsandboxes and to make the analysis process more time consuming.\n\nTo bypass sandboxes that hook only high-level user mode functions, it solely calls native\nAPI functions. To make the analyst's life harder, it dynamically resolves the functions by\nhash instead of using plain text strings. The malware contains code to call the following\nfunctions:\n\nNtCreateSection\nNtMapViewOfSection\nNtCreateFile (unused)\nNtAllocateVirtualMemory (unused)\nRtlCreateProcessParameters\nRtlCreateUserProcess\nRtlCreateUserThread\nRtlExitUserProcess\n\nThe malware creates two separate tables of function hash/address pairs. One table\ncontains one pair for all native functions, while the second table only pairs for Nt*\nfunctions.\n\nFor the Rtl* functions that were used, it loops through the first table and searches for the\nfunction hash to get the function address. For the Nt* functions that were used, it loops\nthrough the second table and simultaneously increases a counter variable.\n\nWhen the hash is found, it takes the counter value that is the system call number of the\ncorresponding native function, and it enters a custom syscall stub. This effectively\nbypasses many sandboxes, even if the lower level native functions are hooked instead of\nthe high-level ones.\n\n\n-----\n\nThe overall loader functionality is relatively simple and uses mapping injection to run the\npayload. It spawns a child process of the Windows tool sethc.exe, creates a new section\nand maps the decrypted Cobalt Strike beacon loader into it. The final execution of the\nCobalt Strike loader that in turn loads an SMB beacon happens by calling\nRtlCreateUserThread.\n\nYou can find the decrypted beacon configuration data in the Appendix section.\n\n### In-Memory Evasion\n\nWith our new hypervisor-based sandbox, we were able to detect the decrypted Cobalt\n[Strike SMB beacon in memory. This beacon loader even uses some in-memory evasion](https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/malleable-c2-extend_pe-memory-indicators.htm#_Toc65482856)\nfeatures that create a strange sort of chimeric file. While it’s actually a DLL, the “MZ''\nmagic PE bytes and subsequent DOS header are overwritten with a small loader shellcode\nas shown in Figure 1.\n\nFigure 1. Disassembled Cobalt Strike beacon loader shellcode.\n\nThe shellcode loader jumps to the exported function DllCanUnloadNow, which prepares\nthe SMB beacon module in memory. To do this, it first loads the Windows pla.dll library\nand zeroes out a chunk of bytes inside its code section (.text). It then writes the beacon\nfile into this blob and fixes the import address table, thus creating an executable memory\nmodule.\n\nDuring the analysis of the file, we could figure out some of the in-memory evasion\nfeatures that were used, as shown in Table 1.\n\n\n**Evasion**\n**feature** **Description**\n\nallocator Set how beacon's ReflectiveLoader allocates memory\nfor the agent. Options are: HeapAlloc, MapViewOfFile\nand VirtualAlloc.\n\ncleanup Ask beacon to attempt to free memory associated with\nthe reflective DLL package that initialized it.\n\n\n**Used in**\n**our**\n**sample**\n\nNo\n\nYes\n\n\n-----\n\nmagic_mz_x64 Override the first bytes (MZ header included) of\nbeacon's reflective DLL. Valid x86 instructions are\nrequired. Follow instructions that change CPU state with\ninstructions that undo the change.\n\nmagic_pe Override the PE character marker used by beacon's\nReflectiveLoader with another value.\n\nmodule_x64 Ask the x86 reflective loader to load the specified library\nand overwrite its space instead of allocating memory\nwith VirtualAlloc.\n\nobfuscate Obfuscate the reflective DLL’s import table, overwrite\nunused header content, and ask ReflectiveLoader to\ncopy beacon to new memory without its DLL headers.\n\nsleep_mask Obfuscate beacon and its heap, in-memory, prior to\nsleeping.\n\nsmartinject Use embedded function pointer hints to bootstrap\nbeacon agent without walking kernel32 Export Address\nTable (EAT).\n\nstomppe Ask ReflectiveLoader to stomp MZ, PE and e_lfanew\nvalues after it loads beacon payload.\n\nuserwx Ask ReflectiveLoader to use or avoid read, write or\nexecute (RWX) permissions for Beacon DLL in memory.\n\n_Table 1. Cobalt Strike evasion techniques that were used._\n\n\nYes\n\nNo\n\nYes\n\nYes\n\nNo\n\nNo\n\nNo\n\nNo\n\n\nTo sum up, the beacon loader and the beacon itself are the same file. Parts of the PE\nheader are used for a shellcode that jumps to an exported function, which in turn creates\na module of itself inside a Windows DLL. Finally, the shellcode jumps to the entry point\nof the beacon module to execute it in memory.\n\nAs discussed, there is no way for us to detect this beacon of our KoboldLoader sample\nsuccessfully unless we can peer inside memory during execution.\n\n## MagnetLoader\n\nThe second loader we will look into is a 64-bit DLL that imitates a legitimate library.\n\nSHA256: 6c328aa7e0903702358de31a388026652e82920109e7d34bb25acdc88f07a5e0\n\nThis MagnetLoader sample tries to look like the Windows file mscms.dll in a few ways, by\nusing the following similar features:\n\nThe same file description\nAn export table with many of the same function names\nAlmost identical resources\n\n\n-----\n\nA very similar mutex\n\nThese features are also shown in Figure 2, where the malware file is contrasted with the\nvalid mscml.dll.\n\nFigure 2. Comparison of file description, export table and resources of MagnetLoader (left) and\n\nmscml.dll (right) as seen with EXE Explorer.\n\nMagnetLoader not only tries to mimic the legitimate Windows library statically, but also\nat runtime.\n\nAll of the exported functions of MagnetLoader internally call the same main malware\nroutine. When one of them is called, the DLL entry point is run first. In the entry point,\nthe malware loads the original mscms.dll and it resolves all the functions it fakes.\n\nThe addresses of these original functions are stored and called after a fake method is\nexecuted. Thus, whenever an exported function of MagnetLoader is called, it runs the\nmain malware routine and afterward calls the original function in mscms.dll.\n\nThe main malware routine is relatively simple. It first creates a mutex named\nSM0:220:304:WilStaging_02_p1h that looks very similar to the original one created by\nmscms.dll.\n\nThe Cobalt Strike beacon loader gets decrypted into a memory buffer and executed with\nthe help of a known trick. Instead of calling the beacon loader directly, the loader uses the\nWindows API function EnumChildWindows to run it.\n\nThis function contains three parameters, one of which is a callback function. This\nparameter can be abused by malware to indirectly call an address via the callback\nfunction and thus conceal the execution flow.\n\n\n-----\n\nYou can also find the decrypted beacon configuration data in the Appendix section.\n\n## LithiumLoader\n\nThis last Cobalt Strike sample is part of a DLL side-loading chain where a custom installer\nfor a type of security software was used. DLL side-loading is a technique that hijacks a\nlegitimate application to run a separate, malicious DLL.\n\nSHA256: 8129bd45466c2676b248c08bb0efcd9ccc8b684abf3435e290fcf4739c0a439f\n\nThis 32-bit LithiumLoader DLL is part of a custom attacker-created Fortinet VPN\ninstallation package submitted to VirusTotal as FortiClientVPN_windows.exe (SHA256:\na1239c93d43d657056e60f6694a73d9ae0fb304cb6c1b47ee2b38376ec21c786).\n\nThe FortiVPN.exe file is not malicious or compromised. Because the file is signed,\nattackers used it to evade antivirus detection.\n\nThe installer is a self-extracting RAR archive that contains the following files:\n\n**File name** **Description**\n\nFortiVPN.exe Legit signed FortiClient VPN Online installer v7.0.1.83\n\nGUP.exe [Legit signed WinGup for Notepad++ tool v5.2.1.0](https://wingup.org/)\n\ngup.xml WinGup config file\n\nlibcurl.dll LithiumLoader\n\n_Table 2a. FortiClientVPN_windows.exe file contents._\n\nThe self-extracting script commands are as follows:\n\nTable 2b. List of self-extracting script commands.\n\nWhen the installer is run, all files get silently dropped to the local %AppData% folder and\nboth executable files get started. While the FortiClient VPN installer executes, the\nWinGup tool side-loads the libcurl.dll LithiumLoader malware. The malware does so\nbecause it imports the following functions from a legit copy of the libcurl library as shown\nin Figure 3.:\n\n\n-----\n\nFigure 3. Import address table of WinGup.exe.\n\nThis threat also tries to add the %AppData% folder path to the exclusion list in Windows\nDefender via PowerShell.\n\nOn the startup of GUP.exe, the malicious libcurl.dll file is loaded into the process space as\nit statically imports the functions shown in Figure 3, above. While all four libcurl\nfunctions are run, only curl_easy_cleanup contains a malicious routine that was injected\nwhile compiling a new version of the library. Thus, we’re not dealing with a patched\nversion of the legitimate DLL. This is a cleaner solution that doesn’t break the code after\nthe inserted malicious routine, as is often seen in other malware.\n\n[This curl_easy_cleanup function usually contains only one subroutine (Curl_close) and](https://curl.se/libcurl/c/curl_easy_cleanup.html)\n[has no return value (as shown in its source code on GitHub). The altered function is as](https://github.com/curl/curl/blob/2610142139d14265ed9acf9ed83cdf73d6bb4d05/lib/easy.c#L727)\nshown in Figure 4.\n\nFigure 4. Modified curl_easy_cleanup export function of libcurl.dll.\n\nThe load_shellcode function decrypts the shellcode via XOR and key 0xA as shown in\nFigure 5.\n\n\n-----\n\nFigure 5. Shellcode loader function load_shellcode().\n\nThis function runs the Cobalt Strike stager shellcode indirectly via EnumSystemGeoID\ninstead of directly jumping to it. This Windows API function has three parameters, the\nlast one of which is a callback function abused by LithiumLoader.\n\nThe Cobalt Strike stager shellcode is borrowed from Metasploit and is the reverse HTTP\nshell payload, which uses the following API functions:\n\nLoadLibrary\nInternetOpenA\nInternetConnectA\nHttpOpenRequestA\nInternetSetOptionA\nHttpSendRequestA\nGetDesktopWindow\nInternetErrorDlg\nVirtualAllocStub\nInternetReadFile\n\nThe shellcode connects to the IP address of a university in Thailand.\n\n### LithiumLoader Detection Issues\n\nAt the time of writing this analysis, the Cobalt Strike beacon payload was no longer\navailable. Without a payload or any actionable information in the execution report of API\ncalls, it’s often challenging for a sandbox to determine whether the sample is malicious.\nThis sample doesn’t have any functionality that can be classified as malicious per se.\n\n\n-----\n\n## Catching Cobalt Strike Through Analyzing Its Memory\n\nIn all three of these examples there are some common detection challenges. These\nsamples do not execute in normal sandbox environments. But as we discussed, there is a\nwealth of information that we can use for detection if we look inside memory during\nexecution, like function pointers, decoded stages of the loader, and other artifacts.\n\nFor many years now, it has been standard practice for sandbox systems to instrument and\nobserve the activity of executing programs. If our team has learned anything over the\nyears, it’s that this alone is not enough for highly evasive malware. This is why we’ve been\nworking hard the past few years on figuring out how we can add more thorough\nprocessing for this type of highly evasive malware.\n\nFor accurate detection, one of the key features we’ve found to address highly evasive\nmalware is that we need to look at memory as samples execute in addition to using the\nsystem API to get a better understanding of what’s happening.\n\nFigure 6. High level Advanced WildFire detection strategy.\n\n\n-----\n\nWe’ve found that, in malware detection, it’s useful to look at the deltas in memory at key\npoints of execution to extract meaningful information and artifacts. As our system\nprocesses a vast number of samples, there have been a lot of challenges to make this work\nat scale. However, a lot of clever engineering built on top of our flagship custom\nhypervisor tailored for malware analysis has helped make this idea a reality.\n\nIn these next few sections, we will detail some of the main types of data that we are\ncurrently collecting from memory to aid detection. This data can be utilized by both our\nanalysts for manual signatures as well as machine learning pipelines, which we’ll be\ndiscussing in a future post.\n\nAlthough we are focusing on memory here, we are by no means suggesting that\ninstrumenting and logging API calls are not useful for detection. Our belief is that\nbringing execution logs and memory analysis data together creates a sum greater than its\nparts.\n\n### Automatic Payload Extraction\n\nAs previously discussed, it is increasingly common for malware authors to obfuscate their\ninitial payloads. While using executable packers that can compress and obfuscate files to\naccomplish this is nothing new, it becomes problematic when it’s used in combination\nwith evasion strategies, because there is no static or dynamic data that’s useful for an\naccurate detection.\n\nThere are infinite combinations of strategies for encoding, compressing, encrypting or\ndownloading additional stages for execution. The ability to craft signatures for these\npayloads is obviously an important way that our analysts can catch lots of different\nmalware components from frameworks like Cobalt Strike. If we can catch them in\nmemory, it ultimately doesn’t matter if the malware decides not to execute.\n\nThe following simplified diagram in Figure 7 shows an example of what we might see in a\ncouple of stages that were never present in the initial executable file.\n\nFigure 7. Typical stages we might see in a packed malware executable.\n\n\n-----\n\nOn the left side of the diagram, we see an example of a shellcode stage. Although the term\n“shellcode” was originally coined for hand crafted assembly utilized in exploits to pop a\nshell on a target system, the word has evolved to encompass any blobs of custom\nassembly written for nefarious purposes. Some malware stages are blobs of custom\nassembly with no discernable executable structure. A common pattern for malware\nauthors taking this approach is to dynamically resolve all of the function pointers into a\ntable for ease of access.\n\nOn the right side of the diagram, we see that the later stage is an example of a well-formed\nexecutable. Some malware stages or payloads are well-formed executables. These can be\nloaded by the OS via the system API, or the malware author might use their own PE\nloader if they’re trying to be stealthy in avoiding calling any APIs to do this for them.\n\n### Function Pointer Data\n\nAnother rich set of data we can pull from memory that we’ve begun to use for detection is\ndynamically resolved function pointers, as shown in Figure 8. Malware authors learned\nlong ago that if they explicitly call out all of the WINAPI functions they plan to use in the\nimport table, it can be used against them. It is now standard practice to hide the functions\nthat will be used by the malware or any of its stages.\n\nShellcode hashing is another common stealthy strategy used to resolve pointers for\nfunctions without needing their string.\n\nFigure 8. Examples of dynamically resolved WINAPI pointers we might see in a memory segment.\n\n\n-----\n\nIn Advanced WildFire we have begun to selectively search for and use this information\nabout which WINAPI function pointers were resolved in our detection logic.\n\n### OS Structure Modifications\n\nAnother useful source of detection data we’ve found from analyzing memory is to look for\nany changes to Windows bookkeeping structures (Malware authors love to mess with\nthese!). These structures are important for the OS to maintain state about the process,\nsuch as what libraries have been loaded, where the executable image was loaded, and\nvarious other characteristics about the process that the OS might need to know later.\nGiven that many of these fields should never be modified, it’s often useful to keep track of\nwhen and how malware samples are manipulating them.\n\nThe diagram in Figure 9 shows how a sample might unhook a module it loaded from the\nLDR Module list. Unhooking a module would mean that there is no longer a record that\nthe module exists. So, for example, after doing this the Task Manager in Windows would\nno longer list it.\n\nThis diagram represents only one of many different OS Structure modifications we’ve\nseen, but it shows that there are many different types of OS structure modifications that\nare useful for the malware detection problem.\n\nFigure 9. An example of how a module might be unhooked from the LDR Modules List.\n\n\n-----\n\n### Page Permissions\n\nFinally, another useful source of detection data is a full log of all changes made to page\npermissions. Authors of packed malware often need to change memory permissions in\norder to properly load and execute further stages. Understanding which pages of memory\nhad their permissions changed often provides important insights into where code was\nloaded and executed, which can be useful for detection.\n\n## Conclusion\n\nAlthough Cobalt Strike has been around for some years, detecting it is still a challenge to\nmany security software providers. That is because this tool works mostly in memory and\ndoesn’t touch the disk much, other than with the initial loader.\n\nWe’ve looked into three new loaders and showed how they can be detected using a variety\nof techniques. These detection techniques are available within our new hypervisor based\nsandbox.\n\nFigure 10 illustrates our detection reasons for KoboldLoader.\n\nFigure 10. Internal KoboldLoader sample analysis report.\n\nPalo Alto Networks customers receive protections from these threats:\n\n\n-----\n\n[Advanced WildFire identifies the Cobalt Strike loaders and beacons as malicious.](https://www.paloaltonetworks.com/products/secure-the-network/wildfire)\n[Cortex XDR protects endpoints and identifies the loaders as malicious.](https://www.paloaltonetworks.com/cortex/cortex-xdr)\n\n## Indicators of Compromise\n\n**KoboldLoader**\n\n7ccf0bbd0350e7dbe91706279d1a7704fe72dcec74257d4dc35852fcc65ba292\n6ffedd98d36f7c16cdab51866093960fe387fe6fd47e4e3848e721fd42e11221\nfc4b842b4f6a87df3292e8634eefc935657edf78021b79f9763548c74a4d62b8\n062aad51906b7b9f6e8f38feea00ee319de0a542a3902840a7d1ded459b28b8d\na221c7f70652f4cc2c76c2f475f40e9384a749acd1f0dbaefd1a0c5eb95598d2\n\n**MagnetLoader**\n\n6c328aa7e0903702358de31a388026652e82920109e7d34bb25acdc88f07a5e0\n\n**LithiumLoader**\n\n8129bd45466c2676b248c08bb0efcd9ccc8b684abf3435e290fcf4739c0a439f\n82dcf67dc5d3960f94c203d4f62a37af7066be6a4851ec2b07528d5f0230a355\n\n**LithiumLoader Installer**\n\na1239c93d43d657056e60f6694a73d9ae0fb304cb6c1b47ee2b38376ec21c786\ncbaf79fb116bf2e529dd35cf1d396aa44cb6fcfa6d8082356f7d384594155596\n\n## Appendix\n\n**KoboldLoader beacon configuration data:**\n\nBeaconType - SMB\nPort - 4444\nSleepTime - 10000\nMaxGetSize - 1048576\nJitter - 0\nMaxDNS - 0\nPublicKey_MD5 - 633dc5c9b3e859b56af5edf71a178590\nC2Server UserAgent HttpPostUri Malleable_C2_Instructions - Empty\nPipeName - \\\\.\\pipe\\servicepipe.zo9keez4weechei8johR.0521cc13\nDNS_Idle - Not Found\nDNS_Sleep - Not Found\nSSH_Host - Not Found\nSSH Port - Not Found\n\n\n-----\n\nSSH_Username - Not Found\nSSH_Password_Plaintext - Not Found\nSSH_Password_Pubkey - Not Found\nSSH_Banner - Not Found\nHttpGet_Verb - Not Found\nHttpPost_Verb - Not Found\nHttpPostChunk - Not Found\nSpawnto_x86 - %windir%\\syswow64\\dfrgui.exe\nSpawnto_x64 - %windir%\\sysnative\\dfrgui.exe\nCryptoScheme - 0\nProxy_Config - Not Found\nProxy_User - Not Found\nProxy_Password - Not Found\nProxy_Behavior - Not Found\nWatermark_Hash - Not Found\nWatermark - 666\nbStageCleanup - True\nbCFGCaution - True\nKillDate - 0\nbProcInject_StartRWX - True\nbProcInject_UseRWX - False\nbProcInject_MinAllocSize - 35485\nProcInject_PrependAppend_x86 - b'\\x90\\x90\\x90\\x90\\x90\\x90\\x90'\nb'\\x90\\x90\\x90\\x90\\x90\\x90\\x90'\nProcInject_PrependAppend_x64 - b'\\x90\\x90\\x90\\x90\\x90\\x90\\x90'\nb'\\x90\\x90\\x90\\x90\\x90\\x90\\x90'\nProcInject_Execute - ntdll.dll:RtlUserThreadStart\nNtQueueApcThread\nNtQueueApcThread-s\nSetThreadContext\nRtlCreateUserThread\nkernel32.dll:LoadLibraryA\nProcInject_AllocationMethod - NtMapViewOfSection\nbUsesCookies - Not Found\nHostHeader - Not Found\nheadersToRemove - Not Found\nDNS_Beaconing - Not Found\nDNS_get_TypeA - Not Found\nDNS_get_TypeAAAA - Not Found\nDNS_get_TypeTXT - Not Found\nDNS_put_metadata - Not Found\nDNS_put_output - Not Found\nDNS_resolver - Not Found\nDNS strategy - Not Found\n\n\n-----\n\nDNS_strategy_rotate_seconds - Not Found\nDNS_strategy_fail_x - Not Found\nDNS_strategy_fail_seconds - Not Found\nRetry_Max_Attempts - Not Found\nRetry_Increase_Attempts - Not Found\nRetry_Duration - Not Found\n\n**MagnetLoader beacon configuration data:**\n\nBeaconType - HTTPS\nPort - 443\nSleepTime - 3600000\nMaxGetSize - 1402498\nJitter - 70\nMaxDNS - Not Found\nPublicKey_MD5 - 965fe5c869f3eea5e211fa7ee12130d3\nC2Server - tileservice-weather.azureedge[.]net,/en-au/livetile/front/\nUserAgent - Microsoft-WebDAV-MiniRedir/10.0.19042\nHttpPostUri - /en-CA/livetile/preinstall\nMalleable_C2_Instructions - Remove 1380 bytes from the end\nRemove 3016 bytes from the beginning\nBase64 URL-safe decode\nHttpGet_Metadata - ConstHeaders\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nCache-Control: max-age=0\nConnection: keep-alive\nHost: tileservice-weather.azureedge[.]net\nOrigin: https://tile-service-weather.azureedge[.]net\nReferer: https://tile-service.weather.microsoft[.]com/\nMetadata\nbase64url\nappend \"/45.40,72.73\"\nuri_append\nHttpPost_Metadata - ConstHeaders\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nCache-Control: max-age=0\nConnection: keep-alive\nHost: tileservice-weather.azureedge[.]net\nOrigin: https://tile-service-weather.azureedge[.]net\nReferer: https://tile-service.weather.microsoft[.]com/\nConstParams\nregion=CA\nSessionId\nbase64url\n\n\n-----\n\nparameter \"appid\"\nOutput\nbase64\nprint\nPipeName - Not Found\nDNS_Idle - Not Found\nDNS_Sleep - Not Found\nSSH_Host - Not Found\nSSH_Port - Not Found\nSSH_Username - Not Found\nSSH_Password_Plaintext - Not Found\nSSH_Password_Pubkey - Not Found\nSSH_Banner HttpGet_Verb - GET\nHttpPost_Verb - POST\nHttpPostChunk - 0\nSpawnto_x86 - %windir%\\syswow64\\conhost.exe\nSpawnto_x64 - %windir%\\sysnative\\conhost.exe\nCryptoScheme - 0\nProxy_Config - Not Found\nProxy_User - Not Found\nProxy_Password - Not Found\nProxy_Behavior - Use IE settings\nWatermark_Hash - Not Found\nWatermark - 1700806454\nbStageCleanup - True\nbCFGCaution - False\nKillDate - 0\nbProcInject_StartRWX - False\nbProcInject_UseRWX - False\nbProcInject_MinAllocSize - 17500\nProcInject_PrependAppend_x86 - b'\\x90\\x90'\nEmpty\nProcInject_PrependAppend_x64 - b'\\x90\\x90'\nEmpty\nProcInject_Execute - CreateThread\nSetThreadContext\nProcInject_AllocationMethod - NtMapViewOfSection\nbUsesCookies - False\nHostHeader headersToRemove - Not Found\nDNS_Beaconing - Not Found\nDNS_get_TypeA - Not Found\nDNS get TypeAAAA - Not Found\n\n\n-----\n\nDNS_get_TypeTXT - Not Found\nDNS_put_metadata - Not Found\nDNS_put_output - Not Found\nDNS_resolver - Not Found\nDNS_strategy - round-robin\nDNS_strategy_rotate_seconds - -1\nDNS_strategy_fail_x - -1\nDNS_strategy_fail_seconds - -1\nRetry_Max_Attempts - Not Found\nRetry_Increase_Attempts - Not Found\nRetry_Duration - Not Found\n\n[To decrypt the configuration data we used SentinelOne’s Cobalt Strike Parser.](https://github.com/Sentinel-One/CobaltStrikeParser)\n\n## Additional Resources\n\n[EXE Explorer](https://www.mitec.cz/exe.html)\n[Cobalt Strike Parser](https://github.com/Sentinel-One/CobaltStrikeParser)\n\n_Updated December 6, 2022, at 9:05 a.m. PT._\n\n**Get updates from Palo Alto Networks!**\n\nSign up to receive the latest news, cyber threat intelligence and research from us\n\n[By submitting this form, you agree to our Terms of Use and acknowledge our Privacy](https://www.paloaltonetworks.com/legal-notices/terms-of-use)\nStatement.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "5d2b9e7f-cf43-4b54-ba18-065aa3003611",
            "created_at": "2022-10-25T16:06:24.199525Z",
            "updated_at": "2022-10-25T16:06:24.199525Z",
            "deleted_at": null,
            "name": "CyberMonitor",
            "url": "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections",
            "description": "APT & Cybercriminals Campaign Collection",
            "reports": null
        },
        {
            "id": "4e039bf8-7239-4999-8ec0-eb202d1465af",
            "created_at": "2022-12-04T11:19:36.52593Z",
            "updated_at": "2022-12-04T11:19:36.52593Z",
            "deleted_at": null,
            "name": "ORKL",
            "url": "https://github.com/ORKL/library",
            "description": "ORKL Community Contributed Content",
            "reports": null
        }
    ],
    "references": [
        "https://github.com/CyberMonitor/APT_CyberCriminal_Campagin_Collections/raw/master/2022/2022.12.02.Cobalt_Strike_Out_of_the_Water/Blowing%20Cobalt%20Strike%20Out%20of%20the%20Water%20With%20Memory%20Analysis.pdf"
    ],
    "report_names": [
        "Blowing Cobalt Strike Out of the Water With Memory Analysis"
    ],
    "threat_actors": [
        {
            "id": "b43e5ea9-d8c8-4efa-b5bf-f1efb37174ba",
            "created_at": "2022-10-25T16:07:24.36191Z",
            "updated_at": "2025-03-27T02:02:10.1909Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "Dark Halo",
                "Nobelium",
                "SolarStorm",
                "StellarParticle",
                "UNC2452"
            ],
            "source_name": "ETDA:UNC2452",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "20d3a08a-3b97-4b2f-90b8-92a89089a57a",
            "created_at": "2022-10-25T15:50:23.548494Z",
            "updated_at": "2025-03-27T02:00:55.49688Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "APT29",
                "IRON RITUAL",
                "IRON HEMLOCK",
                "NobleBaron",
                "Dark Halo",
                "NOBELIUM",
                "UNC2452",
                "YTTRIUM",
                "The Dukes",
                "Cozy Bear",
                "CozyDuke",
                "SolarStorm",
                "Blue Kitsune",
                "UNC3524",
                "Midnight Blizzard"
            ],
            "source_name": "MITRE:APT29",
            "tools": [
                "PinchDuke",
                "ROADTools",
                "WellMail",
                "CozyCar",
                "Mimikatz",
                "Tasklist",
                "OnionDuke",
                "FatDuke",
                "POSHSPY",
                "EnvyScout",
                "SoreFang",
                "GeminiDuke",
                "GoldMax",
                "FoggyWeb",
                "SDelete",
                "PolyglotDuke",
                "AADInternals",
                "MiniDuke",
                "SeaDuke",
                "Sibot",
                "RegDuke",
                "CloudDuke",
                "GoldFinder",
                "AdFind",
                "PsExec",
                "NativeZone",
                "Systeminfo",
                "ipconfig",
                "Impacket",
                "Cobalt Strike",
                "PowerDuke",
                "QUIETEXIT",
                "HAMMERTOSS",
                "BoomBox",
                "CosmicDuke",
                "WellMess",
                "VaporRage",
                "LiteDuke"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f27790ff-4ee0-40a5-9c84-2b523a9d3270",
            "created_at": "2022-10-25T16:07:23.341684Z",
            "updated_at": "2025-03-27T02:02:09.74554Z",
            "deleted_at": null,
            "main_name": "APT 29",
            "aliases": [
                "APT 29",
                "ATK 7",
                "Blue Dev 5",
                "BlueBravo",
                "Cloaked Ursa",
                "CloudLook",
                "Cozy Bear",
                "Dark Halo",
                "Earth Koshchei",
                "Grizzly Steppe",
                "Group 100",
                "ITG11",
                "Iron Hemlock",
                "Iron Ritual",
                "Midnight Blizzard",
                "Minidionis",
                "Nobelium",
                "NobleBaron",
                "Operation Ghost",
                "Operation Office monkeys",
                "Operation StellarParticle",
                "SilverFish",
                "Solar Phoenix",
                "SolarStorm",
                "StellarParticle",
                "TEMP.Monkeys",
                "The Dukes",
                "UNC2452",
                "UNC3524",
                "Yttrium"
            ],
            "source_name": "ETDA:APT 29",
            "tools": [
                "7-Zip",
                "ATI-Agent",
                "AdFind",
                "Agentemis",
                "AtNow",
                "BEATDROP",
                "BotgenStudios",
                "CEELOADER",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobalt Strike",
                "CobaltStrike",
                "CosmicDuke",
                "Cozer",
                "CozyBear",
                "CozyCar",
                "CozyDuke",
                "Danfuan",
                "EnvyScout",
                "EuroAPT",
                "FatDuke",
                "FoggyWeb",
                "GeminiDuke",
                "Geppei",
                "GoldFinder",
                "GoldMax",
                "GraphDrop",
                "GraphicalNeutrino",
                "GraphicalProton",
                "HAMMERTOSS",
                "HammerDuke",
                "LOLBAS",
                "LOLBins",
                "LiteDuke",
                "Living off the Land",
                "MagicWeb",
                "Mimikatz",
                "MiniDionis",
                "MiniDuke",
                "NemesisGemina",
                "NetDuke",
                "OnionDuke",
                "POSHSPY",
                "PinchDuke",
                "PolyglotDuke",
                "PowerDuke",
                "QUIETEXIT",
                "ROOTSAW",
                "RegDuke",
                "Rubeus",
                "SNOWYAMBER",
                "SPICYBEAT",
                "SUNSHUTTLE",
                "SeaDaddy",
                "SeaDask",
                "SeaDesk",
                "SeaDuke",
                "Sharp-SMBExec",
                "SharpView",
                "Sibot",
                "Solorigate",
                "SoreFang",
                "TinyBaron",
                "WINELOADER",
                "WellMail",
                "WellMess",
                "cobeacon",
                "elf.wellmess",
                "reGeorg",
                "tDiscoverer"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1670378897,
    "ts_updated_at": 1743041794,
    "ts_creation_date": 1670375420,
    "ts_modification_date": 1670375420,
    "files": {
        "pdf": "https://archive.orkl.eu/7f9b8506b73078f6b437f402197deadcb15e46e3.pdf",
        "text": "https://archive.orkl.eu/7f9b8506b73078f6b437f402197deadcb15e46e3.txt",
        "img": "https://archive.orkl.eu/7f9b8506b73078f6b437f402197deadcb15e46e3.jpg"
    }
}