{
    "id": "83b3aee6-231f-411e-9a07-75ecfedb2158",
    "created_at": "2023-01-12T15:07:55.908272Z",
    "updated_at": "2025-03-27T02:05:55.799585Z",
    "deleted_at": null,
    "sha1_hash": "f362d2b58944f2acbbf2e410d29c08a2f203f02d",
    "title": "2017-08-23 - Deep Analysis of New Poison Ivy Variant",
    "authors": "",
    "file_creation_date": "2022-05-29T10:40:49Z",
    "file_modification_date": "2022-05-29T10:40:49Z",
    "file_size": 898263,
    "plain_text": "# Deep Analysis of New Poison Ivy Variant\n\n**[blog.fortinet.com/2017/08/23/deep-analysis-of-new-poison-ivy-variant](http://blog.fortinet.com/2017/08/23/deep-analysis-of-new-poison-ivy-variant)**\n\nThreat Research\n\n\nAugust 23, 2017\n\n\nBy [Xiaopeng Zhang | August 23, 2017](http://blog.fortinet.com/blog/search?author=Xiaopeng+Zhang)\nRecently, the [FortiGuard Labs research team observed that a new variant of Poison Ivy was](https://fortiguard.com/)\nbeing spread through a compromised PowerPoint file. We captured a PowerPoint file named\nPayment_Advice.ppsx, which is in OOXML format. Once the victim opens this file using the\nMS PowerPoint program, the malicious code contained in the file is executed. It downloads\n[the Poison Ivy malware onto the victim’s computer and then launches it. In this blog, I’ll show](https://www.fortinet.com/fortiguard/threat-intelligence/threat-research.html)\nthe details of how this happens, what techniques are used by this malware, as well as what it\ndoes to the victim’s computer.\n\n## The PowerPoint Sample\n\nFigure 1 shows a screenshot of when the ppsx file is opened.\n\n\n-----\n\n_Figure 1. Open Payment_Advice.ppsx_\n\nAs you can see, the ppsx file is played automatically. The “ppsx” extension stands for\n“PowerPoint Show,” which opens the file in presentation mode. This allows the malicious\ncode to be executed automatically. The warning message box alerts the user that it might run\nan unsafe external program. Usually, the implied content of the document beguiles the user\ninto pressing the Enable button.\n\nLet’s take a look at the malicious code embedded inside this PowerPoint file.\n\nOOXML file is a zip format file. By decompressing this file we can see the file/folder\nstructure, shown below.\n\n\n-----\n\n_Figure 2. PPSX file structure_\n\nGoing into its .\\ppt\\slides\\ subfolder, slide1.xml is the slide automatically shown in Figure 1.\nThe file “.\\_rels\\slide1.xml.rels” is the relationship file where the resources used in slide1.xml\nare defined. In slide1.xml, I found the xml code:\n\n.\n\nThis means that when the user's mouse hovers over this element, something named “rId2” in\nslide1.xml.rels file is executed.\n\nFigure 3 shows the relationship between them.\n\n\n-----\n\n_Figure 3. The code defined in “rId2”_\n\n## Being Added into the Startup Group\n\nThe code defined in “rId2” uses an echo command of cmd.exe to output vbs codes into the\nThumbs.vbs file in the “Startup” folder of the Start menu. This allows the Thumbs.vbs file to\nbe executed when the victim’s system starts. We’ll take a look at the content of this\nThumb.vbs file below.\n\n\n-----\n\n_Figure 4. Thumb.vbs in the Startup folder and its content_\n\n## The Downloaded File\n\nThumbs.vbs downloads a file from hxxp://203.248.116.182/images/Thumbs.bmp and runs it\nusing msiexec.exe. As you may know, msiexec.exe is the Microsoft Windows Installer\nprogram, which is the default handler of .MSI files. Msiexec.exe can be used to\ninstall/uninstall/update software on Windows. The MSI file is an Installer Package. It contains\na PE file (in a stream) that is executed when it’s loaded by msiexec.exe. This PE file could be\nreplaced with malware to bypass any AV software detection. We have also observed that\nmore and more malware authors have started using this method to run their malware. The\nMSI file is in the Microsoft OLE Compound File format. In Figure 5 we can see the\ndownloaded Thumbs.bmp file content in the DocFile Viewer.\n\n\n-----\n\n_Figure 5. The downloaded Thumb.bmp in DocFile viewer_\n\nNext, I’m going to extract this PE file from the stream into a file (exported_thumbs). By\nchecking with a PE analysis tool, we can see that it’s a 64-bit .Net program. This means that\nthis malware only afftects 64bit Windows.\n\n## Analyzing the .Net code and Running It\n\nAfter putting this extracted file into dnSpy to be analyzed, we can see the entry function\n_Main(), as shown in Figure 6._\n\n\n-----\n\n_Figure 6. Main function_\n\nIt then calls the rGHDcvkN.Exec() function in Main(), which contains a huge array. Actually,\nthe data in the array is the code that is executed as a thread function by a newly-created\nthread.\n\nFigure 7 clearly shows how the code in the array is executed.\n\n\n-----\n\n_Figure 7. .Net program runs a thread to execute the code in a huge array_\n\nIf the code is run on a 64-bit platform, IntPtr.Size is 8. So the huge array is passed to array3.\nIt then allocates memory buffer by calling rGHDcvkN.VirtualAlloc() and copies the code from\narray3 into the new memory by calling Marshal.Copy(). It eventually calls\n_rGHDcvkN.CreateThread() to run the code up._\n\nI started the .Net program in the debugger, and set a breakpoint on CreateThread API to see\nwhat the array code would do when it’s hit. Per my analysis of the array code, it is a kind of\nloader. Its main purpose is to dynamically load the main part of the malware code from the\nmemory space into a newly-allocated memory buffer. It then repairs any relocation issues\naccording to the new base address and repairs APIs’ offset for the main part code. Finally,\nthe main code’s entry function is called.\n\n\n-----\n\n## Anti-Analysis Techniques\n\n1. All APIs are hidden. They are restored when being called. The snippet below is the\n\nhidden CreateRemoteThread call.\n```\nsub_1B0E6122 proc near   \n  mov  rax, 0FFFFFFFF88E23B10h\n  neg  rax\n  jmp  rax ;; CreateRemoteThread\nsub_1B0E6122 endp\n\n```\n1. All strings are encrypted. They are decrypted before using. For example, this is the\n\nencrypted “ntdll” string.\n```\n  unk_1AFD538C db 54h, 0B2h, 9Bh, 0F1h, 47h, 0Ch ; ==> \"ntdll\"\n\n```\n1. It runs a thread (I named it ThreadFun6) to check if the API has been set as a\n\nbreakpoint. If yes, it calls TerminateProcess in another thread to exit the process\nimmediately. The thread function checks all APIs in the following modules: “ntdll”,\n“kernel32”, “kernelbase” and “user32”. In Figure 8, you can see how this works:\n\n\n-----\n\n_Figure 8. Checking for breakpoints on exported APIs in “ntdll”_\n\n1. It runs a thread to check if any analysis tools are running. It does this by creating\n\nspecially named pipes that are created by some analysis tools. For example,\n“\\\\.\\Regmon” for registry monitor tool RegMon; “\\\\.\\FileMon” for local file monitor tool\nFileMon; “\\\\.\\NTICE” for SoftIce, so on.\n\nIf one of the named pipes cannot be created, it means one of the analysis tools is running. It\nthen exits process soon thereafter.\n\n\n-----\n\n1. It then goes through all the running program windows to check if any windows class\n\nname contains a special string to determine if an analysis tool is running. For example,\n“WinDbgFrameClass” is Windbg main window’s class name. This check runs in a\nthread as well (I named it as Threadfun3). Below, Figure 9 shows how this thread\nfunction works.\n\n_Figure 9. Check Windows’ Class Name_\n\n1. By checking to see if the “Wireshark-is-running-{…}” named mutex object exists (by\n\ncalling OpenMutex), it could implement anti-WireShark.\n2. By calling the API “IsDebuggerPresent”, it can check to see ] if this process is running\n\nin a debugger (returns with 1). It’s a kind of anti-debugging check. It also checks how\nmuch time is spent by calling IsDebuggerPresent. If the time is more than 1000ms, it\nmeans that the process runs in a debugger or VM, and it then exits the process.\n\nThese are all the ways that this malware performs anti-analysis. Most of these checks run in\ntheir own threads, and are called every second. It then exits the process if any check is\nmatched.\n\nTo continue the analysis of this malware, we have to first skip these checks. We can\ndynamically modify its code to do so. For example, changing “IsDebuggerPresent”’s return\nvalue as 0 allows us to bypass the running-in-debugger detection.\n\n## Generating A Magic String from a Decrypted String\n\nBy decrypting three strings and putting them together, we get the magic string \"Poison Ivy\nC++\", which will be saved in a global variable qword_1B0E4A10. From the code snippet\nbelow you can see how it makes this string.\n\n\n-----\n\n_Figure 10. Generating the magic string_\n\n## Hiding Key-functions in Six Different Modules\n\nIt next loads several modules from its encrypted data. It creates a doubly-linked list, which is\nused to save and manage these loaded modules. There are many export functions from\neach of these modules that achieve the malware’s main work. In this way, it’s also a\nchallenge for dynamic debugging. The variable qword_1AFE45D0 saves the header of that\ndoubly-linked list. Each object in the list has the structure below:\n```\n+00H pointer to previous object in the list\n+08H pointer to next object in the list\n+18H for Critical Section object use\n+28H the base address of the module this object is related to\n+30H pointer to export function table\n\n```\nIt then decrypts and decompresses six modules one by one, and adds each of them into the\ndoubly-linked list. Figure 11 shows a code snippet from decrypting these six modules.\n\n\n-----\n\n_Figure 11. Decrypting and decompressing modules_\n\nEach module has an Initialization function (like DllMain function for Dll files) that is called\nonce the module is completely decrypted and decompressed. Three of these modules have\nan anti-analysis ability similar to the one I described in the Anti-Analysis section above. So to\ncontinue the analysis of this malware, I needed to modify their codes to bypass their\ndetection function.\n\nAfter that it calls the export functions of those modules. It decrypts the configuration data\nfrom the buffer at unk_1AFE3DA0. This configuration data is decrypted many times during\nthe process running, and it tells the malware how to work. I’ll talk more about the\nconfiguration data in a later section.\n\nThe malware then picks a string from the configuration data, which is\n“%windir%\\system32\\svchost.exe”. It later calls CreatProcess to run svchost.exe, and then\ninjects some code and data from malware memory into the newly-created svchost.exe. It\nfinally calls the injected code and exits its current process. The malware’s further work is now\ndone in the svchost.exe side.\n\n## Starting over in SVCHOST.exe\n\nThrough my analysis I could see that the injected codes and data represent the entire\nmalware. It all starts over again in the svchost.exe process. Everything I have reviewed\nabout is repeated in svchost.exe. For example, executing the anti-analysis detection code,\n\n\n-----\n\ngetting the magic string, creating a doubly-linked list, decrypting six modules and adding\nthem into the doubly-linked list, and so on.\n\nIt then goes to different code branch when executing the instruction 01736C2 cmp dword ptr\n\n[rdi+0Ch], 1 in module2. [rdi+0ch] is a flag that was passed when the entire code was\ninitialized. When the flag is 0, it takes the code branch to run svchost.exe and inject code in\nit; when it’s 1, it takes the code branch to connect to the C&C server. Before the injected\ncode in svchost.exe is executed, the flag is set to 1. Figure 12 shows the code branches.\n\n_Figure 12. Snippet of code branches_\n\n## Obtaining the C&C Server from PasteBin\n\n[The C&C server’s IP addresses and ports are encrypted and saved on the PasteBin website.](https://www.fortinet.com/products/security-subscriptions/ipreputation-antibot.html)\nPasteBin is a text code sharing website. A registered user can paste text code on it in order\nto share the text content to everyone. The malware author created 4 such pages, and put the\nC&C server IP addresses and ports there. Do you remember when I talked previously about\nencrypted configuration data? It contains the 4 PasteBin URLs. They are\n```\nhxxps://pastebin.com/Xhpmhhuy\nhxxps://pastebin.com/m3TPwxQs\nhxxps://pastebin.com/D8A2azM8\nhxxps://pastebin.com/KQAxvdvJ\n\n```\nFigure 13 shows the decrypted configuration data.\n\n\n-----\n\n_Figure 13. Decrypted configuration data_\n\nIf you access any one of these URLs, you will find there are normal Python codes on it. The\nencrypted server IP address and port are hidden in the normal python code. Let’s take a\nlook.\n\nWhile looking at the main function you will find the code below:\n\n_win32serviceutil.HandleCommandLine({65YbRI+gEtvlZpo0qw6CrNdWDoev}), the data_\nbetween “{“ and “}”, is the encrypted IP address and port. See Figure 14 for more\ninformation.\n\n\n-----\n\n_Figure 14. Encrypted C&C IP address and Port on PasteBin_\n\nLet’s see what we can see after decryption in Figure 15.\n\n\n-----\n\n_Figure 15. Decrypted IP address and Port_\n\nFrom Figure 15, we can determine that the decrypted C&C server IP address is\n172.104.100.53 and the Port is 1BBH i.e. 443. It should be noted that the IP addresses and\nPorts on the four pages are not the same. The author of this malware can update these IP\naddresses and Ports by simply updating the python codes on the four PasteBin pages.\n\n## Communicating with the C&C server\n\nThe malware starts connecting and sending data to its C&C server once it gets the IP\naddress and Port. All the packets traveling between the malware and its server are\nencrypted using a private algorithm. The structure of the packet is like this: (the first 14H\nbytes is the header part, from 14H on is the data part)\n```\n+00 4 bytes are a key for encryption or decryption.\n+04 4 byte, are the packet command.\n+0c 4 bytes is the length in bytes of the data portion of the packet.\n+14 4 bytes. From this point on is the real data.\n\n```\n\n-----\n\nOnce the malware has connected to the server, it first sends a 30001 command, and the\nserver replies with command “30003”. The command “30003” requests the client to collect\nthe victim’s system information. Once the malware receives this command, it calls tons of\nAPIs to collect the system information.\n\nIt gathers the system's current usage of both physical and virtual memory by calling\nGlobalmemoryStatusEx.\nIt gets the CPU speed from the system registry from\n“HKLM\\HARDWARE\\DESCRIPTION\\SYSTEM\\CENTRALPROCESSOR\\0\\~MHz\".\nIt gets the free disk space of all partitions by calling GetDiskFreeSpaceExA.\nIt gets the CPU architecture by calling GetNativeSysstemInfo.\nIt collects display settings by calling EnumDisplaySetting.\nIt collects file information from kernel32.dll.\nIt gets the current computer name and user name by calling GetComputerName and\nGetUserName.\nIt also gets the System time by calling GetSystemTime, and the system version by\ncalling GetVersionEx.\nFinally, it copies the svchost.exe’s full path and a constant string, “PasteBin83”, which\nis from the decrypted configuration data (see Figure 13 again).\n\nIn Figure 16 you can see the collected system information before encryption. Figure 17\nshows the data after encryption as it’s about to be sent to the C&C server. The first four bytes\nare used to encrypt or decrypt the following data.\n\n_Figure 16. Collected information from the victim’s system_\n\n\n-----\n\n_Figure 17. Encrypted system information from victim’s system_\n\nFrom my analysis during the malware runtime, I could determine that the malware keeps\nobtaining the C&C server’s IP address from PasteBin and communicating with the C&C\nserver in an infinite loop (by calling Sleep(1000) to suspend the execution).\n\nSo far, I only saw that the commands “030001” and “030003” are used. I’ll continue to\nmonitor and analyze the malware’s behavior to see what else it will do.\n\n## Solution\n\nThe FortiGuard Antivirus service has detected the files \"Payment_Advice.ppsx\" as\nMSOFFICE/PoisonIvy.A!tr.dldr and \"Thumbs.bmp\" as MSOFFICE/PoisonIvy.A!tr.\n\n## IOC\n\n**URL:**\n\nhxxp://203.248.116.182/images/Thumbs.bmp\n\n**Sample SHA-256 hashes:**\n\nPayment_Advice.ppsx\n\n\n-----\n\nE7931270A89035125E6E6655C04FEE00798C4C2D15846947E41DF6BBA36C75AE\n\nThumbs.bmp\n\nA3E8ECF21D2A8046D385160CA7E291390E3C962A7107B06D338C357002D2C2D9\n\n_[Sign up for weekly Fortinet FortiGuard Labs Threat Intelligence Briefs and stay on top of the](http://ftnt.net/2iT7Mcp%C2%A0)_\n_newest emerging threats._\n\n## Related Posts\n\nCopyright © 2022 Fortinet, Inc. All Rights Reserved\n\n[Terms of ServicesPrivacy Policy](https://www.fortinet.com/corporate/about-us/legal.html)\n| Cookie Settings\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-08-23 - Deep Analysis of New Poison Ivy Variant.pdf"
    ],
    "report_names": [
        "2017-08-23 - Deep Analysis of New Poison Ivy Variant.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536075,
    "ts_updated_at": 1743041155,
    "ts_creation_date": 1653820849,
    "ts_modification_date": 1653820849,
    "files": {
        "pdf": "https://archive.orkl.eu/f362d2b58944f2acbbf2e410d29c08a2f203f02d.pdf",
        "text": "https://archive.orkl.eu/f362d2b58944f2acbbf2e410d29c08a2f203f02d.txt",
        "img": "https://archive.orkl.eu/f362d2b58944f2acbbf2e410d29c08a2f203f02d.jpg"
    }
}