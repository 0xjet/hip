{
    "id": "bf704629-792a-4fcf-b291-3a02078e38d7",
    "created_at": "2023-01-12T15:03:36.394327Z",
    "updated_at": "2025-03-27T02:16:26.594056Z",
    "deleted_at": null,
    "sha1_hash": "1e3b4832997a3ad71ca164b1a5d5c884e74fcb96",
    "title": "2017-11-17 - [Part 1] - Analysing the New Linux-AES.DDoS IoT Malware",
    "authors": "",
    "file_creation_date": "2022-07-02T23:19:45Z",
    "file_modification_date": "2022-07-02T23:19:45Z",
    "file_size": 507112,
    "plain_text": "# LloydLabs - [Part 1] - Analysing the new Linux/AES.DDoS IoT malware\n\n**blog.syscall.party/post/aes-ddos-analysis-part-1/**\n\n[Part 1] - Analysing the new Linux/AES.DDoS IoT malware\n\n[● 19 Nov 2017](https://blog.syscall.party/post/aes-ddos-analysis-part-1/)\n\nAs the title suggests this is a bot which is spread by brute forcing SSH daemons and\nexploiting IoT devices using an array of exploits — this malware is mainly distributed by a\nChinese actor who is familiar with C++ and C constructs, however the knowledge of C++ by\nthis threat actor only extends to using the `std::string class in C++. This bot was being`\ndistributed a few years ago just for x86_64 targets, this has changed along with some key\nfundementals of the bot. It’s started to target embedded systems, which is why I thought I\nwould cover it again. Linux/AES.DDoS is programmed in C++, we can see this due to the\nfact that all of the symbols are exported and C++ constructs are used.\n\nWe are going to be using:\n\n[gdb-peda: https://github.com/longld/peda](https://github.com/longld/peda)\n[BinaryNinja: https://binary.ninja/](https://binary.ninja/)\nltrace: [https://linux.die.net/man/1/ltrace](https://linux.die.net/man/1/ltrace)\nradare2: [http://rada.re/r/](http://rada.re/r/)\n\n## A look at the file..\n\nIf we run ‘file’ on the executable we get:\n```\nELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked,\nfor GNU/Linux 2.6.14, not stripped.\n\n```\nSo, we’re working with an ELF (which is the COFF for UNIX systems) and it’s 32 bit. It’s\narchitecture is of type ARM and all of the libraries its using are statically linked — this is\nnormal behaviour of an IoT bot to have its libc linked as many systems will have incomplete\nor sometimes even broken libraries. So, instead of dynamically linking the executable, they\nare statically linked. Since its not stripped, this means that the analysis will be a lot easier as\nwe have meaningful names in relation to objects in the executable. For some strange\nreason, the executable was compiled on a 12 year old version of the Linux kernel — this\ncould indicate to us that the malware was compiled on an IoT device or just has an extremely\nold computer.\n\n\n-----\n\nMD5: `125679536fd4dd82106482ea1b4c1726`\n\nSHA1: `6caf6a6cf1bc03a038e878431db54c2127bfc2c1`\n\n## A quick rundown on ARM\n\nARM is 32 bit by design, so all of our registers are 32 bit wide. In ARM, the standard calling\nconvention is to place the arguments into `r0 - r3 . That’s only four registers though, if there`\nare more than three arguments then we place the rest of the arguments on the stack. We\nhave 15 registers to play with though, they all serve a special purpose.\n\nr0, r1, r2, r3 are used for passing arguments, r0 usually also holds the return value of\nroutines.\nr4, r5, r6, r7, r8, r9 are used internally within routines to store variables.\nr10 holds the limit for the current stack.\nr11 holds the stack frame pointer.\nr12 can also be used as a variable within routines, however there is no guarantee that\nthis register will remain unchanged by the caller.\nr13 holds the stack pointer (SP).\nr14 is the link register, which points back to the caller.\nr15 holds the program counter.\n\nNice, so now you’re an ARM expert we can continue.. ;)\n\n## Dive into main(..)..\n\nAs soon as the malware boots from the original entry-point `main which is at` `0x13DEC . We`\nuse `rabin2 to find the original entry point by doing` `rabin2 -s kfts | grep \"type=FUNC`\n```\nname=main\" . Which gives us the following output:\nvaddr=0x00013dec paddr=0x0000bdec ord=5366 fwd=NONE sz=688 bind=GLOBAL type=FUNC\nname=main\n\n\n```\nNice! The executable isn’t packed. The main method then branches to function named\n```\nget_executable_name which reads the symlink /proc/self/exe via readlink(..) .\n\n```\nWhen reading this symlink internally from our process it will return the location from that our\nexecutable is running from. We can see from the disassembly that we create a type of\n```\nstd::string and copy from the char array containing the path of the current executable.\n\n```\nThis is then used and passed into the function used for persistence.\n\n\n-----\n\nWe then either check if we re running or add to startup. In the `check_running procedure`\nwe do a call to `ps -e then sleep for two seconds; we then get the output from the`\ncommand and check to see if the current executable name exists in the output. If it does, we\ncontinue to branch to `exit with an exit code of 0 (which is placed into r0) which will`\neffectively shut-down the process. If not, we then go onto persistence. So, if we’re already\nrunning, we effectively exit the process.\n\n## Persistence\n\nPersistence is achieved by the malware by adding to `/etc/rc.local and the`\n```\n/etc/init.d/boot.local files (in the auto_boot function); however before it overwrites\n\n```\nthis file it first checks to see if it has already done so. The `/etc/rc.local will execute`\ncertain commands after all of the systems’ services have started. The way that this is\nachieved is somewhat amateur as the malware constructs a shell command and then uses\nthe `system function to execute them (which in theory just calls the exec and hangs for a`\nreturn code from the callee).\n\nA string is formatted and the `sed program is called which writes to the file in question (there`\nare several string operations, such as `sed -i -e '2 i%s/%s' /etc/rc.local is`\nformatted for example). This is then passed to `system, as described above. The buffer`\nused in all of these formatting operations is at the virtual address `0x9F48 and has a size of`\n300 bytes. Technically, since the input is un-sanitized we could manipulate the path that the\nmalware resides in and utilise a format string exploit. We could therefore manipulate the\nstack; read local variables, overwrite addresses etc. This is the only persistence method\nused by the bot.\n\n## Information harvesting\n\n\n-----\n\nThe process then forks itself and breaks away from its parent by calling `setsid(..) . All of`\nthe file descriptors are also closed which are inherited from the parent (0-3). A thread is then\ncreated to call the `SendInfo function which collects information such as the number of`\nCPUs in the system; the network speed; the amount of load on the system CPUs; the local\naddress of the network adapter.\n\nThis routine then calls the subroutine `get_occupy . We can see that we calculate the load`\naverage by iterating over all the CPUs in the system. We can see that `r3 is being used for`\nthe counter for this loop, then the `blt instruction is executed which branches if the first`\noperand is less than the second. In x86, this is the equivalent of `jle . Please note in earlier`\nversions of this malware a thread used to be created to `backdoorA, however not anymore.`\n\nThe way the malware gets information regarding the network adapter is reading the\n```\n/proc/net/dev file. It then seeks to the start of the file; and parses it to get the local IP\n\n```\naddress from the default adapter.\n\nWhat I found strange about this sample of malware is that it created statistics which had no\nreal meaning, for example it would create a random value and use it as the network speed.\nIn the subroutine `fake_net_speed we can see` `srandom is seeded with` `time — we`\npass the first parameter ‘0’ into `time as we have no structure to fill (usually, a pointer to`\n```\ntime_t would be passed into this function). We then move the result of time into r3 ;\n\n```\nthen back into `r0 to be a parameter for` `srandom — this is most likely the compiler being`\nstrange for some reason or another.\n\n\n-----\n\nThe value generated by this call is then used in a `sprintf statement to create a string`\nwhich represents the network speed in mega bytes per second (apparently). This is super\nweird, the malware is creating a fake network speed for some reason.. the only conclusion I\ncan come to regarding this is that someone has hired a programmer and they have failed to\nimplement this feature — so they’re faking it to their client/boss etc.\n\nThese values are then sent within this subroutine to the main C2..\n\n## Communication Initialisation\n\nAfter all of these operations we finally come to the main core of the bot; the part where it\nconnects to the C2 and receives commands. The procedure `ConnectServer (which is at`\n```\n0xCA1C ) is called from the main body of the function, this then branches to\nServerConnectCli ( 0xB5BC ) which returns a socket to the C2 server. The global variable\nMainSocket is then set to this value. Diving into ServerConnectCli ..\nServerConnectCli starts by creating a socket of protocol type TCP, if this operation is not\n\n```\nsuccessful then the assembly branches off to a subroutine at `0xB654 which displays the`\nerror by calling the `perror(..) function to display a human readable error.`\n\nFor those of you familiar with C, this is like doing:\n```\nr0 = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\n```\nThe port that we are going to connect to is partly obfuscated by the author. The original\nnumber is loaded into the register `r3 . We then shift this value by 16 bytes ( 0x10 ) to the`\nleft (we can see this being done in the `lsl instruction. We then shift is again to the right by`\n16 bytes. Then again, this may of have been put in there by the compiler. I’ve put the\nassembly down below so you can see clearly whats happening.\n```\nmov r3, r0\n\nstrh r3, [r3, #0x104]\n\nlsl r3, r3, #0x10 // shift r3 RIGHT by 0x10\n\nlrl r3, r3, #0x10 // shift r3 LEFT by 0x10\n\nmov r0, r3\n\nbl htons\n\n```\nCould look at it this way in pseudocode..\n```\nr3 = ((r3 << 0x10) >> 0x10)\n\n```\n\n-----\n\nThe bot has a symbol named `AnalysisAddress at at` `0xB1B8, at first sight one may think`\nthis is to divert the attention of researchers — but all this subroutine does is setup a\n```\nhostent struct (http://man7.org/linux/man-pages/man3/gethostbyname.3.html) which we’ll\n\n```\nuse later on for the connection. We pass in the first parameter in the register ‘r0’ from the\nlocation `0xC1FC8 which has the value of` `61.147.91.53 . We put the return value os`\n```\ngethostbyname into register r3 then preform some arithmetic on it.\n\n```\nThe malware does two calls to `setsockopt, passing the` `IP_DROP_SOURCE_MEMBERSHIP`\nflag and the After the above has completed the the malware does a call to `connect to`\nmake an initial connection to the C2 server and then does a mixture of `select and`\n```\ngetsockopt calls on the socket to ensure that the non-blocking socket has successfully\n\n```\nconnected. If the connection is not successful the malware will close the socket and exit.\n\nOnce we have a working socket returned from ServerConnectCli we then set the value of the\nglobal variable MainSocket to the return value. The malware then goes on to getting more\nstatistics from the infected box. First of all, it grabs the username from the user running the\nexecutable which is placed into ‘r11’. We can see that if the ‘uname’ call fails then “Unknown”\nwill be copied into the destination buffer which originally resided in r11, else if it is successful,\nwill branch to `0xCA8C .`\n\nMore information is gathered about the infected host via the `GetCpuInfo function. Although`\nthis is self explanatory I’ll explain it anyways. The virtual file `/proc/cpuinfo is opened and`\nread in WORDs until an EOF (-1) is hit whilst reading the file chunk by chunk — then\n```\nfclose is called to free up the opened file. The number of CPUs is then passed back out\n\n```\nfrom this method and the clock speed in MHz too.\n\nThe malware then calls `sysinfo(..) and reads into the struct (also named` `sysinfo )`\nwhich is originally located in r3. We then read several members of this struct, such as the\ntotal amount of swap, total amount of RAM etc.. this is all then formatted and output into a\nstring.\n\n\n-----\n\nWe can see here that the threat actor seems to be joking about by using the string Hacker ..\nthe string to be format is: `VERSONEX:Linux-%s|%d|%d MHz|%dMB|%dMB|%s — you’ve spelt`\n‘version’ wrong Mr Threat Actor. It’s very strange here that `sprintf was used before rather`\nthan `snprintf (which helps mitigate buffer overflows/format string exploits to an extent as`\nthe function knows the length of the buffer). Programmers will usually be inclined to use one\nnaturally over the other, this indicates to myself there may be more than one programmer\nwhom is contributing to this malware.\n\nIn the control flow we can then see that we try to then send this information on ‘MainSocket’,\nif the send is not successful (so, if we send 0) we branch to another subroutine and close the\nsocket.\n\nFor those not familiar with ARM, the `beq instruction basically says if the flag is set that they`\nare equal then jump to address `0xCBD4 . This subroutine simply closes the socket, as said`\nbefore. We then move onto `select, if this call is successful thence move onto reading data`\nfrom the C2. We then read data from the C2, but first, we zero out the buffer that we are\nusing and have a maximum size of `0x1380 that we want to receive. Again, if this is not`\nsuccessful it then prints an error message and branches to a subroutine which closes the\nsocket and cleans up.\n\n## Conclusion, so far..\n\nIt is obvious so far that this malware has been programmed by more than one author. We\ncan also see so far that the author has experience in socket programming. The author is also\nusing pascal case (LikeThis) and names certain functions such as `GetCpuInfo – this could`\nin turn indicate to us that the author is used to programming on Windows.\n\nThis is the end of this section, we will now move onto the details about the attack methods\nand what else the bot can be commanded to do.\n\n[malware](https://blog.syscall.party/tags#malware-ref) [iot](https://blog.syscall.party/tags#iot-ref)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-11-17 - [Part 1] - Analysing the New Linux-AES.DDoS IoT Malware.pdf"
    ],
    "report_names": [
        "2017-11-17 - [Part 1] - Analysing the New Linux-AES.DDoS IoT Malware.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673535816,
    "ts_updated_at": 1743041786,
    "ts_creation_date": 1656803985,
    "ts_modification_date": 1656803985,
    "files": {
        "pdf": "https://archive.orkl.eu/1e3b4832997a3ad71ca164b1a5d5c884e74fcb96.pdf",
        "text": "https://archive.orkl.eu/1e3b4832997a3ad71ca164b1a5d5c884e74fcb96.txt",
        "img": "https://archive.orkl.eu/1e3b4832997a3ad71ca164b1a5d5c884e74fcb96.jpg"
    }
}