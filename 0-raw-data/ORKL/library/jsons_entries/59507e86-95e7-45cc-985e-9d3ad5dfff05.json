{
    "id": "59507e86-95e7-45cc-985e-9d3ad5dfff05",
    "created_at": "2023-01-12T15:10:32.581431Z",
    "updated_at": "2025-03-27T02:05:45.971637Z",
    "deleted_at": null,
    "sha1_hash": "a471627dd31bd39e6ee5943e4ff4c355a6ff2ade",
    "title": "2022-09-18 - Raccoon back with new claws!",
    "authors": "",
    "file_creation_date": "2022-10-02T12:12:55Z",
    "file_modification_date": "2022-10-02T12:12:55Z",
    "file_size": 1562319,
    "plain_text": "# Raccoon back with new claws!\n\n**[labs.k7computing.com/index.php/raccoon-back-with-new-claws/](https://labs.k7computing.com/index.php/raccoon-back-with-new-claws/)**\n\nBy Rahul R July 18, 2022\n\nRaccoon infostealer was first released in April 2019, the initial Version1(V1) was\ndistributed in telegram groups and other forums as Malware-as-a-service (MaaS). The\n[detailed blog on V1 can be seen here. Now the stealer has been updated with new](https://labs.k7computing.com/index.php/raccoon-the-info-stealer/)\nfeatures, and comes packed with Commercial packers. It has a stealthy way of gaining\ninformation from the system using Windows API’s. This blog discusses in depth on the\nVersion2(V2) of Racoon Stealer and its method to obtain the information.\n\nThe Stealer is usually downloaded when a user tries to download cracked software, thus\nthe malware is added with around 400MB of junk in the overlay along with an invalid digital\nsignature from AVG.\n\n**Analysis**\n\nThe sample is around 417MB disguises itself as Windows File System Proxy, has an\ninvalid digital Signature and comes packed with VMProtect. The analysis is based on the\nunpacked binary.\n\n\n-----\n\nFigure 1: Sample\n\nVersion Information\n\n**Dynamic API Resolving**\n\nThe malware begins with resolving the required API’s dynamically through LoadLibrary\nand GetProcAddress.\n\n\n-----\n\nFigure 2:\n\nDynamic API resolving procedure\nIt uses LoadLibrary to get the handles of kernel32.dll, shell32.dll, user32.dll, advapi32.dll,\nwininet.dll, ole32.dll, crypt32.dll and pass on the returned handle as an argument to\nLoadLibrary to the get the address of the required WinAPI and stores them at a memory\noffset.\n\n**String Decryption**\n\nThe sample uses the RC4 algorithm for decrypting the base64 strings stored in binary. At\nfirst the string is base64 decoded using CryptStringToBinary API passing the dwFlags\nargument as CRYPT_STRING_BASE64(0x1).\n\n\n-----\n\nFigure 3: Base64 decode using\n\nCryptStringToBinaryA\nThe decoded base64 string is saved in a variable and it is passed as an argument to the\nfunction which RC4 decrypts the string using the hardcoded symmetric key\n“edinayarossiya”(“United Russia” – a political party in Russia)\n\nFigure 4: String decryption procedure\nComplete list of strings decrypted is listed in Appendix A.\n\n**Retrieve C2 URL**\n\n\n-----\n\nThe binary uses the same string decryption method discussed above to retrieve the C2\nURL. For the decryption of the C2 it uses a different hardcoded RC4 symmetric key\n“b616297870490e1028b141f53eb3afe8” which is later used as config ID when initial\ninformation is sent.\n\nFigure 5: Decryption of Command and control server\n\n**Checks system locale**\n\nThe malware then proceeds to check the locale of the system using\n\nGetUserDefaultLocaleName API, and checks the returned string with a dword from virtual\naddress 0x40E000. In this variant, this locale check does not affect the behaviour of the\nmalware. Usually threat actors opt for an option for excluding victims from certain\ngeolocale. Seems like the threat actors here have that option but are not using it.\n\n\n-----\n\nFigure 6: Get Locale of Execution system\n\n**Checks mutex**\n\nThe malware checks for a mutex with name “8724643052”, if not, then creates one. If the\nmutex exists then it kills itself to stop itself from running multiple times.\n\n\n-----\n\nFigure 7: Malware checks if Mutex Exists\n\n**Checks for system privilege**\n\nThe malware retrieves the Current Process access token and compares it to the SID of\n**NTAuthority\\System(“S-1-5-18”). If it matches it executes the function to enumerate the**\nactive process list.\n\nFigure 8: Check System Privilege\n\n\n-----\n\nSimilar to locale check, there is no change in behaviour\n\nlist if it has System privilege\n\n**Gather Initial Information**\n\n\nFigure 9: Enumerate process\n\n\nThe malware initially collects machine GUID, username and sends it to C2 and awaits\nresponse from C2 for further information gathering.\n\nMachine GUID is obtained from the registry key\n“HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Cryptography” under “MachineGUID”\n\nThe malware sends the initial information to C2 in the following syntax\n\n**machineId=<machineGUID>|<username>&configid=<RC4_key used to decrypt C2>**\n\n**Sends initial collected data**\n\nAfter converting the collected initial data into Unicode string. It sends a POST request to\nthe decrypted C2 using an unusual User-Agent String “record”. The data is sent in form\ndata format.\n\n\n-----\n\nFigure 10: Procedure to send request to C2 and wait for response\n\nFigure 11: Request sent to C2\nAfter making the request the connection handle is kept open until it receives a data\nresponse. It waits for the POST response until the size of response is greater than 64\nbytes.\n\n**Process C2 Response**\n\n\n-----\n\nFigure 12: C2 response\nThe C2 response contains the urls of the dlls which are needed to collect detailed\ninformation\n\nA GET request is made to download all the Dll and it is saved in the APPDATA_LOCAL\nfolder.The path to APPDATA_LOCAL is retrieved using the API SHGetFolderPath with\nCSIDL passed as “CSIDL_LOCAL_APPDATA”(0x1c)..If the response doesn’t have the\nString “Token” in it the malware kills itself.\n\n**Collect detailed information**\n\nAfter downloading the required dlls, it changes the current working directory and adds the\npath to the APPDATA_LOCAL directory to “PATH” Environment Variable using\nSetEnvironmentVariableW.\n\n**System Info.txt**\n\nThe malware first collects the system information and sends it as a POST request to the\nC2. Let us see what and how the system information is collected using WinAPI.\n\n**Locale : The malware collects the current locale using the API GetLocaleInfoW**\n\n**TimeZone : Timezone is retrieved using API GetTimeZoneInformation**\n\n\n-----\n\nFigure 13: collection of Locale and TimeZone using API\n\n**Product Name : Windows version is retrieved by querying the registry key**\n**“HKEY_LOCAL_MACHINE\\software\\microsoft\\windows nt\\currentversion\\” and**\ndata “ProductName”\n\nFigure 14: retrieve productname from registry\n\n**Architecture : The malware checks if SYSWOW64 directory exists on the system, if**\nit is unavailable it considers the architecture as 32bit, else architecture is 64bit.\n\n\n-----\n\nFigure 15: Find\n\nsystem architecture\n\n**Processor : The processor information is obtained with the usage of ASM instruction**\n“CPUID”(CPU Identification).\n\n**RAM : The Exact amount of physical storage is retrieved using the API**\nGlobalMemoryStatusEx,which returns the “LPMEMORYSTATUSEX” structure. From\nthe returned structure the malware takes the field “ullTotalPhys” and right shift by 20\nbits to convert it into MB.\n\n\n-----\n\nFigure 16: Get RAM information\n\n**Display height and width : Display height and width is obtained using the API**\n“GetSystemMetrics” by passing the argument 0x0(SM_CXSCREEN) to retrieve width\nand 0x1(SM_CYSCREEN) to get height.\n\n**Display Devices : The display enumerated and saved using the API**\n“EnumDisplayDevicesW”\n\nScreen dimension and display devices could be checked at the server if the malware is\nexecuted in a VM or sandbox.\n\n\n-----\n\nFigure 17: Get Display information\n\n**List of Installed Products : The complete list of products which are installed are**\nobtained by looping through all the subkeys under\n“HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall”\n\nAll the collected information about the System is sent immediately to the C2 without saving\nit to a file.\n\n**Cookies.txt**\n\nAfter collecting all the information related to system, it proceeds to collect browser saved\npasswords, credit card details and cookies using the following dll\n\n1. Sqlite3.dll – to collect login id and passwords from chrome(ium) based browsers\n2. mozglue.dll/nss3.dll – to collects login id and passwords from firefox\n\nThe following queries are used to query the required information.\n\nSELECT origin_url, username_value, password_value FROM logins\nSELECT host_key, path, is_secure, expires_utc, name, encrypted_value FROM\ncookies\nSELECT name, value FROM autofill\nSELECT host, path, isSecure, expiry, name, value FROM moz_cookies\nSELECT fieldname, value FROM moz_formhistory\n\n\n-----\n\nSELECT name_on_card, card_number_encrypted, expiration_month,\nexpiration_year FROM credit_cards\n\nThe Stealer even has the capability to collect the crypto wallets if found on the system and\nsends all the collected information to C2 immediately.\n\n**Captures screenshot**\n\nA series of Windows API is used to capture the screenshot of the infected machine, and is\n[sent to C2. The flow is similar to the example code given by microsoft here.](https://docs.microsoft.com/en-us/windows/win32/gdi/capturing-an-image)\n\n**Cleanup**\n\nThe malware deletes all the files which are downloaded from the internet, after the\ninformation is sent to C2.\n\nFigure 18: Cleanup\n\nActivity\nWe strongly recommend not to download any cracked software to get infected with\nmalware.\n\n\n-----\n\nWe at K7 Labs provide detection against latest threats and also for this newer variant of\nRacoon Stealer. Users are advised to use a reliable security product such as “K7 Total\n**Security” and keep it up-to-date so as to safeguard their devices.**\n\n**Indicators of Compromise(IOC)**\n\n**File Name** **Hash** **K7 Detection Name**\n\nlaunchctl.exe b0bc998182378e73e2847975cc6f7eb3 Trojan ( 005690671 )\n\n**C2**\n\nhxxp://www[.]retro-rave[.]xyz\n\n**IP**\n\n51.195.166[.]184\n\n**User-Agent**\n\nrecord\n\n**Appendix : Strings Decrypted during Runtime ( Using RC4 key: “edinayarossiya” )**\n\ntlgrm_\n\news_\n\ngrbr_\n\n%s  TRUE  %s  %s  %s  %s  %s\n\nURL:%s\n\nUSR:%s\n\nPASS:%s\n\n%d) %s\n\n– Locale: %s\n\n– OS: %s\n\n– RAM: %d MB\n\n– Time zone: %c%ld minutes from GMT\n\n\n-----\n\n– Display size: %dx%d\n\n%d\n\n– Architecture: x%d\n\n– CPU: %s (%d cores)\n\n– Display Devices:\n\n%s\n\nformhistory.sqlite\n\n\\*\n\nlogins.json\n\n\\autofill.txt\n\n\\cookies.txt\n\n\\passwords.txt\n\n*/*\n\nContent-Type: application/x-www-form-urlencoded; charset=utf-8\n\nContent-Type: multipart/form-data; boundary=\n\nContent-Type: text/plain;\n\nUser Data\n\nwallets\n\nwlts_\n\nldr_\n\nscrnsht_\n\nsstmnfo_\n\ntoken:\n\nnss3.dll\n\nsqlite3 dll\n\n\n-----\n\nSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\n\nPATH\n\nProductName\n\nWeb Data\n\nsqlite3_prepare_v2\n\nsqlite3_open16\n\nsqlite3_close\n\nsqlite3_step\n\nsqlite3_finalize\n\nsqlite3_column_text16\n\nsqlite3_column_bytes16\n\nsqlite3_column_blob\n\nSELECT origin_url, username_value, password_value FROM logins\n\nSELECT host_key, path, is_secure, expires_utc, name, encrypted_value FROM cookies\n\nSELECT name, value FROM autofill\n\npera\n\nStable\n\nSELECT host, path, isSecure, expiry, name, value FROM moz_cookies\n\nSELECT fieldname, value FROM moz_formhistory\n\ncookies.sqlite\n\nmachineId=\n\n&configId=\n\n“encrypted_key”:”\n\nstats_version”:”\n\nContent-Type: application/x-object\n\n\n-----\n\nContent-Disposition: form-data; name= file ; filename=\n\nGET\n\nPOST\n\nLow\n\nMachineGuid\n\nimage/jpeg\n\nGdiPlus.dll\n\nGdi32.dll\n\nGdiplusStartup\n\nGdipDisposeImage\n\nGdipGetImageEncoders\n\nGdipGetImageEncodersSize\n\nGdipCreateBitmapFromHBITMAP\n\nGdipSaveImageToFile\n\nBitBlt\n\nCreateCompatibleDC\n\nDeleteObject\n\nGetObjectW\n\nSelectObject\n\nSetStretchBltMode\n\nStretchBlt\n\nSELECT name_on_card, card_number_encrypted, expiration_month, expiration_year\nFROM credit_cards\n\nNUM:%s\n\nHOLDER:%s\n\n\n-----\n\nEXP:%s/%s\n\n\\CC.txt\n\nNSS_Init\n\nNSS_Shutdown\n\nPK11_GetInternalKeySlot\n\nPK11_FreeSlot\n\nPK11_Authenticate\n\nPK11SDR_Decrypt\n\nSECITEM_FreeItem\n\nhostname”:”\n\n“,”httpRealm”:\n\nencryptedUsername”:”\n\n“,”encryptedPassword”:”\n\n“,”guid”:\n\nProfiles\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-18 - Raccoon back with new claws!.pdf"
    ],
    "report_names": [
        "2022-09-18 - Raccoon back with new claws!.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536232,
    "ts_updated_at": 1743041145,
    "ts_creation_date": 1664712775,
    "ts_modification_date": 1664712775,
    "files": {
        "pdf": "https://archive.orkl.eu/a471627dd31bd39e6ee5943e4ff4c355a6ff2ade.pdf",
        "text": "https://archive.orkl.eu/a471627dd31bd39e6ee5943e4ff4c355a6ff2ade.txt",
        "img": "https://archive.orkl.eu/a471627dd31bd39e6ee5943e4ff4c355a6ff2ade.jpg"
    }
}