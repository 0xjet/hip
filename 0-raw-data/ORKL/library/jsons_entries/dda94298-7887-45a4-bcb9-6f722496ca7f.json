{
    "id": "dda94298-7887-45a4-bcb9-6f722496ca7f",
    "created_at": "2023-01-12T15:02:24.731221Z",
    "updated_at": "2025-03-27T02:14:38.656012Z",
    "deleted_at": null,
    "sha1_hash": "c8dabe17be95cd75dd1b10fc36fbae340cb80134",
    "title": "2020-12-15 - Reverse engineering KPOT v2.0 Stealer",
    "authors": "",
    "file_creation_date": "2022-05-29T01:13:17Z",
    "file_modification_date": "2022-05-29T01:13:17Z",
    "file_size": 6712045,
    "plain_text": "# Reverse engineering KPOT v2.0 Stealer\n\n**[github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/blob/main/kpot2/KPOT.md](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/blob/main/kpot2/KPOT.md)**\n\nDump-GUY\n\nmain\n\n## Malware-analysis-and-Reverse-engineering/kpot2/KPOT.md\n\nCannot retrieve contributors at this time\n\nKPOT Stealer is a “stealer” malware that focuses on exfiltrating account\ninformation and other data from web browsers, instant messengers, email,\nVPN, RDP, FTP, cryptocurrency, and gaming software.\n\n[Sample:[Virustotal]](https://www.virustotal.com/gui/file/67f8302a2fd28d15f62d6d20d748bfe350334e5353cbdef112bd1f8231b5599d/detection)\n\nAt first it is usually good to start with a little recon about this sample. For\nthis purpose, I usually use browser extension called “Mitaka”\n\n[[https://github.com/ninoseki/mitaka]. This is very useful browser extension](https://github.com/ninoseki/mitaka)\nfor IOC OSINT search.\n\n\n-----\n\nTo be more sure about first assumption that it could be a “kpot” stealer, it is\nalso good to perform a YARA scanning on this sample. I prefer YARA rules\n[from Malpedia. [https://malpedia.caad.fkie.fraunhofer.de/]](https://malpedia.caad.fkie.fraunhofer.de/)\n\nSo where to start? Usually one of my first questions is: “Is it packed or\nsomehow encrypted?”\n\nI would not be covering the whole – not so interesting static analysis of file,\nbut only focusing on the IAT of the sample and entropy which usually\nunhide that the sample is packed.\n\nWell in this case it looks like deterministic signatures cannot identify some\nwell-known packer.\n\n\n-----\n\nLet s try something what works almost every time. Another picture is more\nthan words.\n\nYou can see that the sample has only 4 imports and the entropy of the .text\ncode section is too high – packed.\n\nSo for now we know that we have to deal with sample which is some kind\nof stealer and it is probably encrypted or packed.\n\n## Let’s start Reversing !!!\n\nAfter throwing the sample to IDA, we can clearly see that in the start\n(entrypoint) there are 4 functions which should be in our interest.\n\n\n-----\n\nYou can see also unresolved calls like call dword_4151C0 – these calls\nare pointing to some location in .data section which is now empty and\nprobably gets filled with addresses later.\n\nSo we have almost no imports and plenty of unresolved calls. Let’s start\nwith the 4 interesting functions mentioned before.\n\nFirst function is sub_404477 – this function is not interesting at all. It is only\nclearing 20 bytes in memory for call LoadUserProfileW.\n\nSo let’s continue to another call sub_4042FC. This function is locating PEB\nexactly ProcessHeap and saving it to location dword_415224.\n\nWe can confirm it in windbg where we can easily parse PEB structure.\n\n\n-----\n\nMove to the next function sub_4058FB. This function is the most\ninteresting where string decryption and API resolving happens.\n\nAt first, we will focus on the function sub_40C8F5 which you can see is\nreferenced from 69 locations.\n\nWe can see this function (sub_40C8F5) in the picture below. It looks like\nsome basic xor cipher. It also looks like that decompiler has some hard\ntime to produce us more pretty code so we help him.\n\n\n-----\n\nSo first of all, we check the arguments to this function and retype it\ncorrectly. Function sub_40C8F5 takes 2 arguments, where the first one is\nsome hardcoded unsigned _int8 which looks like some kind of index and\nthe second one is a pointer to stack address.\n\nFrom the decompiler view we can see that the second argument is actually\npointer to BYTE. If we set the types and names of variables correctly we\ncan see better but not the best results.\n\nFor better results, we must check also the nullsub_1 which is not a\nfunction but address to array of structures. Let’s undefine the nullsub_1\nfirstly.\n\n\n-----\n\nYou can see that the index variable is used for pointing to the specific\nstructure which would be probably 8bytes in size. We can confirm it when\nwe check the address .text:00401288 where we can see another 183\nstructures – 8 bytes in size.\n\nWhen we check the address .text:00401288, it looks like the first BYTE\nvalue “C3” is used as xor key, second BYTE value could be unidentified\n(undefined), the WORD “0013” looks like length of string which will be\nxored and the last DWORD (00403594) is the address where our\nencrypted string is located. Let’s check that address (403594) if our\nassumption is correct and if there is some kind of encrypted string with\nlength 13h (19).\n\nOur first assumption was correct so let’s create a structure and apply it as\narray of structures.\n\nTo apply our created structure “Decrypt_string_Struct” simply navigate to\nlocation 00401288 and press ALT+Q and choose newly created structure.\n\n\n-----\n\nConvert the structure to array with array size = 183.\n\nAnd now we are ready to check our better decompiled function\nString_Decrypt1. Below is comparing of decompiled function\nString_Decrypt1 before and after modification.\n\n\n-----\n\nSo this algorithm is very basic: First argument to this function is index of\nthe structure in array and second argument is location on stack where the\ndecrypted string is saved.\n\nKey (BYTE) from the structure is xored with each BYTE in the location\n(Encrypted_string_pointer) from our indexed structure, till it reaches the\nlength of encrypted string.\n\nLet’s quickly confirm it for the first structure in array with python.\n\nWe were correct and obtained our first IOC.\n\nBefore jumping to IDAPython we forgot something. If you remember the\nfunction String_Decrypt1 was referenced from 69 locations but our array of\nstructures contains 183 members.\n\n\n-----\n\nSo we could check Xreferences to our array of structures if we could find\nanother String_DecryptX function.\n\nWe were right, there is another one. Quick checking that function\n(sub_40C929) revealed that it is basically the same as function\nString_Decrypt1. So we rename it to String_Decrypt2.\n\nNow when we found both functions referencing our array of structures, we\ncan jump to IDAPython and write a decryptor.\n\nThe final decryptor could be something, what will find all location from\nwhere our 2 string-decrypting functions (String_Decrypt1, String_Decrypt2)\nare called. After it finds these locations it will grab the first argument as our\n“INDEX” to structure, find and parse the structure[index]. This will serve us\nfor decrypting the current string so we could insert a comment to location\nfrom where the string-decrypt function was called.\n\n\n-----\n\nDuring the creating of decryptor, I found one quite tricky problem with\nlocating the first argument value “INDEX” for our (String_Decrypt1,\nString_Decrypt2) functions. You can see it on the picture below where I let\nIDA with little help from IDAPython to print assembly line for all previous\ninstruction before our functions (String_Decrypt1, String_Decrypt2) get\ncalled. The script part is self-explanatory.\n\nYou can find script “Find_previous_instruction.py” here\n\n[[Find_previous_instruction.py].](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/blob/main/kpot2/IDAPython_scripts/Find_previous_instruction.py)\n\nWe must deal with locating the first argument during the string-decryptor\nimplementation. In the picture below is the string-decryptor script in\nIDAPython for the “String_Decrypt1” function.\n\n\n-----\n\nString-decryptor script for the “String_Decrypt2” function is little different\nonly in area of searching and extracting the first argument VALUE (index)\nto function String_Decrypt2.\n\nYou can find both scripts for decrypting functions (String_Decrypt1,\nString_Decrypt2) here [Decrypt_KPOT_Strings1.py,\nDecrypt_KPOT_Strings2.py].\n\nAfter running these scripts, we get commented all location from where\n(String_Decrypt1, String_Decrypt2) are called with decrypted strings in\nboth assembly view and decompile view.\n\n\n-----\n\nIn Output window we could see some information like: String_Decrypt1\nfunction address, count of references and for each processed reference is\nshown - current index value, current structure in hex, current xor KEY,\nlength of encrypted string, address where the encrypted string is located\nand finally decrypted string.\n\nAs we are now able to see decrypted strings we are getting some ideas\nabout functionality of this sample. As you can see we were able to get 211\nlocations with decrypted strings. Some of them are referencing the same\nstring. We can clearly say that this sample is some kind of credential,\ncryptocurrency stealer…\n\n\n-----\n\nSo for now strings are decrypted and we can continue to resolve API calls.\n\nWe will continue with our string-decrypting and API resolving function\nsub_4058FB to see what is going on next. We can see that there will be\nprobably some kind of API name hashing which after matching hash of API\nname, the address of the API function will be saved to the hardcoded\nmemory location. In the picture below we can see the stack preparation for\nthe API name hashing and resolving.\n\nAfter the stack is prepared two functions get called. Let’s check the first\nfunction sub_406936.\n\n\n-----\n\nThe function sub_406936 is basically parsing PEB structure and loading\nbase address of the kernel32.dll module. You can easily confirm it with\nhelp of IDA _PEB struct or windbg as in the pictures below. It is finding the\nPEB structure, _PEB_LDR_DATA where it finds first member in\nInLoadOrderModuleList which is our sample kpot2.exe. After that, it finds a\nlocation of the third loaded module (kernel32.dll) and extracts the base\naddress. This base address of kernel32.dll is passed to the next function\nsub_4045DC so it will be used to find addresses of export functions.\n\nWe can move to the next function sub_4045DC which is responsible for\nfinding address of LoadLibraryA API function from kernel32.dll module.\n\nThis function (sub_4045DC) is not responsible only for finding address of\nLoadLibraryA but it is able to find API address via hash value of its name\nand base address of module as arguments.\n\nSo we can clearly rename it as function “Find_api_via_HASH”. With a little\nhelp with tool like PEbear [https://github.com/hasherezade/pe-bearreleases] we could properly annotate the function sub_4045DC \n\n-----\n\nFind_api_via_HASH . In this case where arguments to the function are\nkernel32.dll base address and API name hash 0x822FC0FA\n(LoadLibraryA), it is parsing kernel32.dll and searching for export function\nname which hash is 0x822FC0FA.\n\nWe can focus more on the function Api_hashing_func later.\n\nOf course we can save some time and let IDA help you with defaultly\ndefined structs for PE. But I personally think that it is a needed skill to\nunderstand and be able to parse PE manually.\n\n\n-----\n\nSo let´s jump to the function Api_hashing_func (0x403E1C) which you\ncould see in the picture below is implementing some probably modified\nversion of well-known hashing algorithm.\n\nWe could use a little help to find out what hash algorithm is implemented\n[from another excellent tool Capa [https://github.com/fireeye/capa]. This](https://github.com/fireeye/capa)\ngives us a hint that it could be hashing algorithm of type murmur3. We will\ncome back to this hashing algorithm later.\n\n\n-----\n\nSo for now, we have more information and can come back and continue\nwith function sub_4058FB - picture below which I populated with all known\ninfo. You can see that some another dlls are loaded and also another\nfunction sub_40694A is called.\n\nFunction sub_40694A is parsing PEB where it returns ntdll.dll base\naddress.\n\nSo we can continue and finally reach the interesting part.\n\nIn the picture below, we can see the last part of sub_4058FB which we can\nclearly rename now as “String_Api_Decrypt”. This last part as you can see\nis responsible for resolving all API functions and saving them to .data\nsection in memory. All these resolved API functions addresses are later in\ncode referenced. You can see that there is a loop which is looping through\nall API name hashes saved on stack before and calling\nFind_api_via_HASH.\n\n\n-----\n\nSo now we have more options to obtain and populate all resolved API\nfunctions in our code. One of the option is to implement murmur3 hashing\nalgorithm and with help of IDAPython, find all API function name hashes to\nprocess it with our algorithm. As we did some IDAPython scripting before\nand I want to show you different methods you can only see that our\nassumption about murmur3 hashing algorithm is right in the pictures\nbelow:\n\nAccording to our annotated code – the hash of API function name\nLoadLibraryA is 0x822FC0FA\n\nWe are also able to find out that murmur3 is using Seed value\n0x5BCFB733 by examining the code in function Api_hashing_func\n(0x403E1C).\n\n\n-----\n\nTo verify that it is really murmur3 hashing algorithm with seed\n0x5BCFB733:\n\nOur assumption about hashing algorithm is right so move next.\n\nThe another option to obtain and populate all resolved API functions in our\ncode is to debug the sample kpot2 and after API functions addresses get\nresolved, apply plugin Scylla to reconstruct IAT – this sometimes does not\nwork well. Option we will use and which I am finding more interesting and\nin this case perfectly suitable is to use tool “apiscout”\n\n[[https://github.com/danielplohmann/apiscout]. This tool is extremely useful](https://github.com/danielplohmann/apiscout)\nin situation like this.\n\nWhen we have all information about how the API resolving works, we\ncould let the sample populate the resolved API function addresses in\ndebugger, dump the process from memory and after that, we need\nsomething what is able to find in our dumped memory all populated API\nfunction addresses and annotate it for us. This is the time when apiscout\ncomes to save the situation.\n\nOne of the feature of apiscout is creating of database of all API functions\n(exports of module). We can let the apiscout build the database from all\ndlls on our system or we can select only some of them. It is basically\nparsing all modules exports and creating database with information like\nname of API function, VA, ASLR offset etc…\n\nLet’s start with dumping our kpot2.exe process from memory in debugger\nlike x64dbg after it populates the resolved API function addresses. We put\na breakpoint after the call sub_4058FB - “String_Api_Decrypt” and dump\nthe process. To find location of this function in debugger easily, do not\nforget to disable ASLR in the optional header of kpot2.exe.\n\n\n-----\n\nLocating our sub_4058FB - “String_Api_Decrypt function.\n\nDumping the kpot2.exe process from memory with plugin OllyDumpEx.\n\nConfirmation in IDA that all referenced API addresses are already\npopulated in our kpot2 process dump “kpot2_dump.bin”:\n\n\n-----\n\nApiscout is able to work also on system with ASLR enabled but in case we\nwant to choose apiscout option to ignore ASLR, we must disable the ASLR\nbefore we perform the process dump of kpot2.exe – find registry key:\n\n[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session\nManager\\Memory Management]\n\nCreate a new dword value: “MoveImages” = dword:00000000 (without\nquote)\n\nRestart system.\n\nIf we do not want to create database of all dlls from our system, first of all\nwe should find and copy to some location all dlls which is our sample\nkpot2.exe loading and processing:\n\nWe can see this information in debugger from where we can copy the\nwhole table to .txt file:\n\n\n-----\n\nExtract dlls path with some regex, editors etc…\n\nTo copy all dlls from provided paths with powershell:\n\nNow when we have all our needed dlls we start with apiscout –\n“DatabaseBuilder.py” to create our database.\n\nNow when we have build our kpot2_DB.json, before we apply it to our\npreviously created process dump file in IDA “kpot2_dump.bin”, we can\nverify that apiscout is able to find all API functions in our dump according\nto kpot2_DB.json. For this purpose, we use apiscout tool “scout.py” as you\ncan see in the picture below.\n\n\n-----\n\nWe can see that apiscout was successful and there is more – something\ncalled “WinApi1024 vector”. Basically speaking it is something like\nImpHash on steroids. You can read more about Apivector here:\n\n[[https://byte-atlas.blogspot.com/2018/04/apivectors.html]. As we get](https://byte-atlas.blogspot.com/2018/04/apivectors.html)\nWinApi1024 vector of our kpot2_dump.bin calculated, we can use it\nagainst big database maintained on Malpedia which is covering big\namount of well-known malware families\n\n[[https://malpedia.caad.fkie.fraunhofer.de/apiqr/]. We can see that our](https://malpedia.caad.fkie.fraunhofer.de/apiqr/)\nWinApi1024 vector is matched 100% with family “win.kpot_stealer” below.\n\nTo apply all previously annotated names of functions from previous IDA\ndatabase file to our newly created kpot2 process dump “kpot2_dump.bin”,\nwe could use IDA plugin called “rizzo”\n\n[[https://github.com/tacnetsol/ida/tree/master/plugins/rizzo].](https://github.com/tacnetsol/ida/tree/master/plugins/rizzo)\n\n\n-----\n\nAfter that, previously created IDAPython scripts for decrypting strings must\nbe run again (Decrypt_KPOT_Strings1.py, Decrypt_KPOT_Strings2.py)\n\n[[View here]](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/tree/main/kpot2/IDAPython_scripts)\n\nNow we are almost in the same state with “kpot2_dump.bin” as we were in\nthe original sample.\n\nLet’s continue to apply our created database kpot2_DB.json to process\ndump kpot2_dump.bin in context of IDA. We will use apiscout IDAPython\nscript “ida_scout.py” for that.\n\nIn the next window choose all of the found APIs and click “Annotate”.\n\n\n-----\n\nAfter apiscout is done we can check the results – all referenced API\naddresses are annotated with their names and type.\n\n\n-----\n\nNow we are in state were we have all strings decrypted, all API function\ncalls resolved and annotated so we are ready to benefit from it in analysis.\n\nThe analysis of the sample is now a simply task so for brevity, I will show\nonly some of functions. Capabilities of the functions are now usually selfexplanatory.\n\nsub_40CB02 - is clearly \"Namecoin\" cryptocurrency stealer:\n\nsub_4101AB – ping + delete main module (kpot2.exe) always called\nbefore exit().\n\nWe can also easily rename wrapped functions when we have all API\nfunctions resolved:\n\n\n-----\n\nsub_40D5B3 - WinSCP 2 sessions information stealer.\n\n## Conclusion:\n\nKpot2 stealer is able to exfiltrate account information and other data from\nweb browsers, instant messengers, email, VPN, RDP, FTP, cryptocurrency,\nand gaming software.\n\nMost of them:\n\nFirefox, Internet Explorer, cryptocurrency: (Ethereum, Electrum, Namecoin,\nMonero) Wallets - Jaxx Liberty, Exodus, TotalCommander FTP, FileZilla,\nWinSCP 2, Ipswitch ws_ftp, Battle.net, Steam, Skype, Telegram,\nDiscordapp, Pidgin, Psi, Outlook, RDP, NordVPN, EarthVPN.\n\nIt is almost impossible to cover all of stealing/exfiltrating functions here and\nit wasn't even my intention. I wanted to cover some tricky techniques\nduring reversing and hope that anybody could find something from this\nanalysis useful or even interesting.\n\n\n-----\n\nIf you find it useful and want to share it on your blog or somewhere else,\nyou can, just let me know if you would like to get it in better format for\nsharing.\n\nThank you to everybody who was able to read it to the end.\n\n## Author:\n\n[[Twitter]](https://twitter.com/vinopaljiri)\n\n[[Github]](https://github.com/Dump-GUY)\n\n## Download:\n\n[[Download PDF]](https://github.com/Dump-GUY/Malware-analysis-and-Reverse-engineering/blob/main/kpot2/KPOT.pdf)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-15 - Reverse engineering KPOT v2.0 Stealer.pdf"
    ],
    "report_names": [
        "2020-12-15 - Reverse engineering KPOT v2.0 Stealer.pdf"
    ],
    "threat_actors": [
        {
            "id": "a66438a8-ebf6-4397-9ad5-ed07f93330aa",
            "created_at": "2022-10-25T16:47:55.919702Z",
            "updated_at": "2025-03-27T02:05:17.412024Z",
            "deleted_at": null,
            "main_name": "IRON VIKING",
            "aliases": [
                "ATK14 ",
                "BlackEnergy Group",
                "Blue Echidna ",
                "CTG-7263 ",
                "ELECTRUM ",
                "FROZENBARENTS ",
                "Hades/OlympicDestroyer ",
                "IRIDIUM ",
                "Qudedagh ",
                "Sandworm Team ",
                "Seashell Blizzard ",
                "TEMP.Noble ",
                "Telebots ",
                "Voodoo Bear ",
                "APT44 "
            ],
            "source_name": "Secureworks:IRON VIKING",
            "tools": [
                " BlackEnergy",
                " GCat",
                " GreyEnergy",
                " Industroyer",
                " KillDisk",
                " NotPetya",
                " PSCrypt",
                " TeleBot",
                " TeleDoor",
                " xData",
                "BadRabbit"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "b3e954e8-8bbb-46f3-84de-d6f12dc7e1a6",
            "created_at": "2022-10-25T15:50:23.339976Z",
            "updated_at": "2025-03-27T02:00:55.446795Z",
            "deleted_at": null,
            "main_name": "Sandworm Team",
            "aliases": [
                "Sandworm Team",
                "ELECTRUM",
                "Telebots",
                "IRON VIKING",
                "BlackEnergy (Group)",
                "Quedagh",
                "Voodoo Bear",
                "IRIDIUM",
                "Seashell Blizzard",
                "FROZENBARENTS",
                "APT44"
            ],
            "source_name": "MITRE:Sandworm Team",
            "tools": [
                "Bad Rabbit",
                "Mimikatz",
                "Exaramel for Linux",
                "Exaramel for Windows",
                "GreyEnergy",
                "PsExec",
                "Prestige",
                "P.A.S. Webshell",
                "VPNFilter",
                "Cyclops Blink",
                "SDelete",
                "AcidRain",
                "Industroyer",
                "Industroyer2",
                "BlackEnergy",
                "Cobalt Strike",
                "NotPetya",
                "KillDisk",
                "PoshC2",
                "Impacket",
                "Invoke-PSImage",
                "Olympic Destroyer"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "3a0be4ff-9074-4efd-98e4-47c6a62b14ad",
            "created_at": "2022-10-25T16:07:23.590051Z",
            "updated_at": "2025-03-27T02:02:09.878211Z",
            "deleted_at": null,
            "main_name": "Energetic Bear",
            "aliases": [
                "ATK 6",
                "Blue Kraken",
                "Crouching Yeti",
                "Dragonfly",
                "Electrum",
                "Energetic Bear",
                "Ghost Blizzard",
                "Group 24",
                "ITG15",
                "Iron Liberty",
                "Koala Team",
                "TG-4192"
            ],
            "source_name": "ETDA:Energetic Bear",
            "tools": [
                "Backdoor.Oldrea",
                "CRASHOVERRIDE",
                "Commix",
                "CrackMapExec",
                "CrashOverride",
                "Dirsearch",
                "Dorshel",
                "Fertger",
                "Fuerboos",
                "Goodor",
                "Havex",
                "Havex RAT",
                "Hello EK",
                "Heriplor",
                "Impacket",
                "Industroyer",
                "Karagany",
                "Karagny",
                "LightsOut 2.0",
                "LightsOut EK",
                "Listrix",
                "Oldrea",
                "PEACEPIPE",
                "PHPMailer",
                "PsExec",
                "SMBTrap",
                "Subbrute",
                "Sublist3r",
                "Sysmain",
                "Trojan.Karagany",
                "WSO",
                "Webshell by Orb",
                "Win32/Industroyer",
                "Wpscan",
                "nmap",
                "sqlmap",
                "xFrost"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "8941e146-3e7f-4b4e-9b66-c2da052ee6df",
            "created_at": "2023-01-06T13:46:38.402513Z",
            "updated_at": "2025-03-27T02:00:02.824555Z",
            "deleted_at": null,
            "main_name": "Sandworm",
            "aliases": [
                "G0034",
                "IRIDIUM",
                "Blue Echidna",
                "FROZENBARENTS",
                "Seashell Blizzard",
                "IRON VIKING",
                "ELECTRUM",
                "TeleBots",
                "UAC-0113",
                "UAC-0082",
                "APT44",
                "Quedagh",
                "VOODOO BEAR",
                "TEMP.Noble"
            ],
            "source_name": "MISPGALAXY:Sandworm",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535744,
    "ts_updated_at": 1743041678,
    "ts_creation_date": 1653786797,
    "ts_modification_date": 1653786797,
    "files": {
        "pdf": "https://archive.orkl.eu/c8dabe17be95cd75dd1b10fc36fbae340cb80134.pdf",
        "text": "https://archive.orkl.eu/c8dabe17be95cd75dd1b10fc36fbae340cb80134.txt",
        "img": "https://archive.orkl.eu/c8dabe17be95cd75dd1b10fc36fbae340cb80134.jpg"
    }
}