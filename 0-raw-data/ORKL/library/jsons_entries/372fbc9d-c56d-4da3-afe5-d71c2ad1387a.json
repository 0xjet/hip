{
    "id": "372fbc9d-c56d-4da3-afe5-d71c2ad1387a",
    "created_at": "2023-01-12T15:08:05.597229Z",
    "updated_at": "2025-03-27T02:06:07.97745Z",
    "deleted_at": null,
    "sha1_hash": "e08b32472fc5c59a9ac5405fa0aeb1685d4f5e35",
    "title": "2017-01-04 - Exposing an AV-Disabling Driver Just in Time for Lunch",
    "authors": "",
    "file_creation_date": "2022-05-28T03:51:34Z",
    "file_modification_date": "2022-05-28T03:51:34Z",
    "file_size": 1255699,
    "plain_text": "# Exposing an AV-Disabling Driver Just in Time for Lunch\n\n**[securityintelligence.com/exposing-av-disabling-drivers-just-in-time-for-lunch/](https://securityintelligence.com/exposing-av-disabling-drivers-just-in-time-for-lunch/)**\n\nJanuary 4, 2017\n\n[Home&nbsp/](https://securityintelligence.com/) [Advanced Threats](https://securityintelligence.com/category/x-force/threats/)\nExposing an AV-Disabling Driver Just in Time for Lunch\n\n\n-----\n\n[Advanced Threats January 4, 2017](https://securityintelligence.com/category/x-force/threats/)\nBy [Lior Keshet 8 min read](https://securityintelligence.com/author/lior-keshet/)\nThe [IBM X-Force Security Research team detected a malicious AV-disabling driver while](https://www.ibm.com/security/xforce/research.html)\n[investigating new remote overlay malware attacking banks in Brazil. The AV-disabling driver](https://securityintelligence.com/media/ibm-x-force-special-report-2016-rio-olympics-threat-landscape/)\nis part of a financial malware designed to empty infected victims’ bank accounts. What a way\nto start my morning.\n\n## Decoding an AV-Disabling Driver\n\nIt’s 9:00 a.m. and I’ve yet to have my coffee. Where do I start?\n\nWhen trying to understand what an unknown piece of software does, there are two main\napproaches: the dynamic approach, whereby we execute the code using tools such as\n[sysinternals and a debugger to see what it does; and the static approach, whereby we](https://technet.microsoft.com/en-us/sysinternals/bb545021.aspx)\nexamine the code using a disassembler or decompiler.\n\nIn this case, the malware is part of actual attacks, and time is of the essence. My goal is to\nunderstand exactly what this malicious driver does as quickly as possible and, ultimately,\nreduce mean time to detection and response. Since this particular driver doesn’t contain a\nlarge amount of code, I decide to start with the static approach.\n\n## Disassembly\n\nBy now, two good things have already happened. First, I have my coffee in hand. Second, I\nhave acquired an open instance of Interactive Disassembler (IDA) Pro to analyze a piece of\ncode I’ve never seen before.\n\n\n-----\n\nThe first thing I notice is the scarcity of functions. With only a dozen to examine, maybe I ll\nhave time for lunch today.\n\nAt this point, it’s a good idea to look at the list of imported functions and strings for clues\nregarding the software’s functionality. The strings don’t look promising in this case:\n\nThe imports, however, are a different story:\n\nHere I found the malware’s string creation and conversion (ASCII to Unicode) functions and,\nmore interestingly, registry-writing functions. Malware authors use various methods to hide\nthe malware’s list of imports, so we must account for the additional functions that may not\nappear in the screenshot above.\n\nSince the code is so short, I decided to start at the beginning, the DriverEntry.\n\nThe first function call is compiler-generated and related to the security cookie. This isn’t\ninteresting, so I skip forward:\n\nWe can see in the figure above that this function calls sub_4011EA several times, each time\nwith a different parameter between 1 and 5.\n\n## Function Overview\n\nLet’s take a moment to inspect the call graph, starting at sub_4011EA:\n\nWe see that sub_401160 uses the registry-writing functions. Let’s check what exactly is\nbeing written. While we’re at it, let’s rename that function to something more meaningful:\nWrite_To_Registry.\n\nSince assembly code tends to be longer and harder to grasp, I’ll use IDA’s [Hex-Rays plugin,](https://www.hex-rays.com/index.shtml)\nwhich translates the assembly to a C syntax code. This will significantly decrease the amount\nof code that is shown. Keep in mind, however, that the generated code isn’t always accurate.\n\n\n-----\n\nAs shown above, Hex-Rays did a near-perfect job translating the code. Now we can easily\nunderstand what’s going on, with a little help from Microsoft’s Developer Network (MSDN)\ndocumentation. It seems the AV-disabling driver tries to access a specific registry key, which\nit receives as a parameter. If that key exists, the AV-disabling driver tries to write it into a\nvalue, which IDA identifies as ValueName. The data to be written, as we can see in the\nprevious image, is “4.”\n\nBut why only a near-perfect job? Note that the parameter the function receives is shown as\nan object type of HANDLE, but it is cast to a Unicode string at the very first line of code. To\nan experienced researcher, this doesn’t make any sense. From a quick look at the\nObjectAttributes documentation from MSDN, we find that ObjectName indeed points to a\nstring. On the other hand, a HANDLE is a numerical value and casting it into a string, once\nagain, doesn’t make sense.\n\nSo what’s going on here? It looks like IDA misdetected the types.\n\n## Advancing Backwards\n\nAt this point, there are two pivotal questions:\n\n1. Where does the ObjectName parameter come from?\n2. Where does the ValueName come from?\n\nTo answer the first question, we’ll take a step back and look at the function that calls the\nfunction we just examined, which I renamed Write_To_Registry:\n\nThe parameter we’re interested in from the above screenshot, UnicodeString, originated from\nsub_4010EA. This is also the function that determines our ValueName from the previous\nfigure. Now we can answer the above questions by examining a single function. This is great\nnews because I’m getting hungry.\n\nThe function sub_4010EA gets two parameters: a1 and a2. a2 is a pointer to a string, and\nbased on the calls to this function that we’ve seen previously, we can tell it’s actually an\noutput parameter.\n\nThe first part of the function is a loop that runs 0x1a7 times and fills a buffer with values\ntaken from a different buffer after having each byte XORed by 0x8. This is simple decryption.\nByte_403357 is used as a flag that signals whether the decryption already happened,\nverifying the XOR operation doesn’t happen more than once.\n\n## A Binary Blob\n\n\n-----\n\nI extracted the binary buffer and decrypted it. This is the result:\n\nThe code seems to contain two parts. The first, in blue, looks like binary data. The second, in\nred, starts in the last line of the first part and looks like encrypted data.\n\nAnother look at sub_4010EA reveals that the buffer we see here is passed to sub_401000,\nand so is the parameter a1. The result of sub_401000 will be returned to sub_4010EA within\nv3, which will then be passed to the output parameter a2, which, fortunately, is the value\nwe’re interested in.\n\nAt this point, I am tempted to change my approach. I can execute the driver within a virtual\nmachine (VM), connect with a kernel debugger and examine the return values of\nsub_401000. I’m not sure which approach is quicker, so I decide to stick with the static\napproach, at least for now.\n\n## Sub_401000\n\nThe next function, sub_401000, is a little more complicated. First, let’s look at how it’s being\ncalled:\n\nIt receives a1 from before, the XORed buffer and a constant — in this case, 1.\n\nThe marked code above shows a search for the a2 parameter within a loop, which advances\nby seven with each iteration. At this point, I don’t want to get into the parsing process of the\nbinary data since it may consume too much time. So what’s next?\n\nInside the first loop, v9 marks where in the buffer we found the parameter. At the end of this\nfunction, we see calls to two additional functions, the second of which receives data from the\nXORed buffer at an offset that depends on the value of v9.\n\n## An Educated Guess\n\n[I’m guessing the two function calls, sub_4010EA and sub_401000, are related to encryption](https://securityintelligence.com/living-in-the-past-business-encryption-needs-to-get-with-the-times-or-get-hacked/)\nor decryption.\n\nLet’s look at the first one:\n\n\n-----\n\nThe top, marked part is an initialization of an array of length 256 (0x100), when each\nmember of the array gets a value equal to its index. In other words, a[i] = i. Given this reality\nand the fact that the decryption consists of two functions, I strongly suspect the calls are\n[related to RC4 encryption.](https://securityintelligence.com/news/why-the-browser-industry-is-collectively-saying-goodbye-to-rc4-next-year/)\n\nAnother look at the clock tells me it’s 11:30. If my intuition is wrong, this research is going to\ntake a while longer. Again, I consider switching to the dynamic approach, but I decide to give\nthe static method one last shot. I’ll assume the calls do, in fact, indicate RC4 encryption and\nre-examine sub_401000 to understand what exactly is being decrypted and with what key.\n\nI changed the names of the variables in this function to fit the RC4 theory:\n\nThe key looks to be 8 bytes long. I follow the variable to where it’s stored and find the part\nwhere the key is generated:\n\nThe code iterates the first 8 bytes of the XORed buff and derives the RC4 key by XORing\neach byte with 0x8. Note that the key length here is 8, which fits what we just saw.\n\nWe are left to determine what is being decrypted. Again, it will take a while to answer this\nquestion accurately. What we do know, or can at least guess, is that some parts of the\nXORed_buff are being decrypted using RC4 with a key that we already have.\n\n## One Last Shortcut\n\nTo save time, I decided not to check what exactly is being decrypted. Instead, I would simply\ntry to decrypt everything. RC4 is a stream cipher, so the decryption of each character\ndepends on the cipher’s current state. To decrypt everything, I’ll have to first decrypt the\nbuffer starting at each character up to 0x1A7 options.\n\nThe code looks something like this:\n\nThe outer loop starts at the end of the key, which is located at the start of the XORed buffer,\nand iterates the rest of the buffer. The internal loop performs RC4 decryption.\n\n[As I expected, the result contains a lot of garbage data, but it also contains plenty of](https://securityintelligence.com/machine-learning-threat-analytics-boost-bust/)\nmeaningful stuff:\n\nThere are, in fact, five such strings; each one corresponds to a different antivirus (AV)\nsolution. The path within the string represents the location of the AV’s driver service.\n\n\n-----\n\n## One Step Backward, Two Steps Forward\n\nLet’s go back and look at the first function, overwrite_AV_reg_service, which is called five\ntimes with parameters of 1–5:\n\nThe function gets an argument, decrypts the corresponding string from the encrypted buffer\nusing the get_string function and writes data into the decrypted registry path using\nset_registry_value.\n\n## Piecing the Puzzle\n\nNow that we know what the driver’s different functions do, we can look at the function call\ngraph once again:\n\nThe first function, main_func, is called five times with parameters of 1–5. For each\nparameter, get_string decrypts a different AV-related path. Then, set_registry_if_key_exists\noverwrites the registry path of that AV’s driver and prevents it from being loaded into the\nsystem.\n\n## Disable AV, Reload Without Resistance\n\nWe also noticed that the malware using this driver causes the system to reboot after\ninstalling the driver. This causes the targeted AV software not to be loaded after the system\nrestores, enabling the malware to execute without disturbance.\n\nThe driver performs this action because the user-mode code can’t overwrite AV registry data;\nit employs self-protections to prevent exactly that. However, when executed by a driver,\nwhich can carry out more actions on a deeper privilege level, it is much harder to prevent\nsuch actions.\n\nAnd that’s it. We now know what the driver does, and I even have a few minutes to spare for\nlunch!\n\n## Final Disclaimers\n\nWhen deciding between the dynamic and static approaches, I chose the latter method\nbecause it allowed me to understand how everything works internally. By dynamically\nobtaining the strings, I could learn what the driver does but not exactly how it does it.\n\nI conducted most of my research without using Hex-Rays due to the plugin’s inherent\ninaccuracies. I showed code mostly using Hex-Rays, however, for the sake of\napproachability.\n\n\n-----\n\nFinally, in truth, I am allowed to eat my lunch even if I do not complete a given task in the\nmorning — and I don’t always show up for work at 9:00 a.m. sharp.\n\nDriver MD5: 48b872f91f1ff3f96594bf480ebf3dcc\n\n[Read the white paper: How to outsmart Fraudsters with Cognitive Fraud Detection](https://www-01.ibm.com/marketing/iwm/dre/signup?source=mrs-form-9451&S_PKG=ov54550)\n\n[Lior Keshet](https://securityintelligence.com/author/lior-keshet/)\nMalware Research Technical Lead, IBM Trusteer\n\nLior is a malware research technical lead at IBM Security's Trusteer's group. He has been a\ncore member of the Trusteer cybercrime labs for the past four yea...\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-01-04 - Exposing an AV-Disabling Driver Just in Time for Lunch.pdf"
    ],
    "report_names": [
        "2017-01-04 - Exposing an AV-Disabling Driver Just in Time for Lunch.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536085,
    "ts_updated_at": 1743041167,
    "ts_creation_date": 1653709894,
    "ts_modification_date": 1653709894,
    "files": {
        "pdf": "https://archive.orkl.eu/e08b32472fc5c59a9ac5405fa0aeb1685d4f5e35.pdf",
        "text": "https://archive.orkl.eu/e08b32472fc5c59a9ac5405fa0aeb1685d4f5e35.txt",
        "img": "https://archive.orkl.eu/e08b32472fc5c59a9ac5405fa0aeb1685d4f5e35.jpg"
    }
}