{
    "id": "234bbf70-ed55-4943-bc88-8c39d7a727cc",
    "created_at": "2023-01-12T15:02:26.248315Z",
    "updated_at": "2025-03-27T02:06:13.599733Z",
    "deleted_at": null,
    "sha1_hash": "55be97c29f046434173587e3d5c59a0411f83909",
    "title": "2021-10-28 - DECAF Ransomware- A New Golang Threat Makes Its Appearance",
    "authors": "",
    "file_creation_date": "2022-05-27T22:55:47Z",
    "file_modification_date": "2022-05-27T22:55:47Z",
    "file_size": 1437952,
    "plain_text": "# DECAF Ransomware: A New Golang Threat Makes Its Appearance\n\n**[blog.morphisec.com/decaf-ransomware-a-new-golang-threat-makes-its-appearance](https://blog.morphisec.com/decaf-ransomware-a-new-golang-threat-makes-its-appearance)**\n\nPosted by [Hido Cohen & Michael Dereviashkin on October 28, 2021](https://blog.morphisec.com/author/hido-cohen-michael-dereviashkin)\n\n[Tweet](https://twitter.com/share)\n\n\n-----\n\nThe Go language is becoming increasingly popular among threat actors, with attacks\nstarting to appear in 2019\nMorphisec Labs has tracked a new Golang-based (1.17) ransomware variant that\nappeared starting in late September and continued development through October\nMorphisec recommends organizations update their breach prevention strategies to\ninclude the risk of Golang-based ransomware\n\n## Introduction\n\nRansomware written in the Go language is quickly becoming more popular among threat\nactors. These include Babuk, Hive, and HelloKitty, as well as many other threats written in\nGolang. “Go” is a statically typed, object-oriented, cross-platform programming language\nintroduced by Google. The abstraction and the support for multiple platforms is an advantage\nfor many developers and also a disadvantage for security vendors who attempt to create\nsignatures for malicious executable malware, which comes with all the dependent libraries\nbuilt-in.\n\nMorphisec Labs has identified a new strain of ransomware, implemented in Go 1.17 and\nnamed DECAF. The first version, which includes symbols and test assertion, was identified in\nlate September. The attackers very quickly stripped the original alpha version, added\nadditional functionality, and uploaded this stub version to verify its detection score. Within a\nweek they had deployed a fully weaponized version on a customer site.\n\n\n-----\n\n**Golang 1.17 introduces additional complexity to analyze the application flow due to a**\n**modification in how parameters are being passed to functions, this is a great example**\n**of how the attackers are becoming extremely agile in utilizing the latest technology.**\n\nThe blog post that follows will cover in great detail the different debug and pre-release\nversions of the new ransomware strain, as well as how the threat actor successfully encrypts\ntheir target.\n\n## Technical Introduction\n\nAs has been described in the introduction, we have identified the delivery of the DECAF\nransomware on one of our customer’s sites. It is only following a detailed investigation that\nwe successfully found a trail that leads us to a debug version of the ransomware, which also\nincluded symbols. In the first technical part, we will go into great detail about the functionality\nof this debug version step by step. In the second part of the blog, we will identify the updates\nintroduced to the pre-release version. We are aware of more updated versions that have\nbeen deployed during the last two weeks.\n\n## Technical Analysis\n\nFigure 1: The attack chain of the Golang ransomware\n\n### Setting up\n\n\n-----\n\nThe initialization phase sets up the data required for the ransomware’s malicious activity.\n\nThe malware starts by parsing a command-line argument, --path, which represents the root\ndirectory where the ransomware will start recursively encrypting files.\n\nFigure 2: Parsing --path parameter\n\nNext, the malware creates an Encryptor object structure:\n\nEncrypted file prefix - each encrypted file header starts with special “magic” prefix,\n0xDADFEEDBABEDECAF\nDECAF file extension - .decaf\nFile extension length\nAttacker’s Public key - initialize and parse the embedded PKCS1 public key (see IOCs\nsection)\n\n\n-----\n\nFigure 3: Initializing the encrypter with relevant data\n\nMany ransomwares implement file filtering mechanisms for several purposes. Controls to\navoid double encrypting the same file and avoiding the wrecking of the victim’s operating\nsystem for payment.\n\nDECAF is no different and also uses a files filtering mechanism. It ignores:\n\n1. .decaf extension files\n2. README.txt files\n3. Embedded blacklists of files, folders, and extensions\n\nFor that task, the attacker created a FileUtils class which has a pointer to README.txt string\n(the name of the ransomware notification file) and the relevant functions. One of the\nfunctions inside FileUtils is Init(). This function is responsible for building blacklists for files,\nfolders, and file extensions (the list’s content can be found in the Appendix section).\n\n\n-----\n\nFigure 4:\n\nBuilding files filters and optional paths\n\nThe next step is figuring out which directories the malware should encrypt. It checks if --path\nhas value and if not calls to FileUtils.ListDriverRootPaths()as shown in the figure above.\n\nLooking inside ListDriverRootPaths, we can see that the malware iterates over the possible\ndrives and searches for drives with a type that is NOT a DRIVE_CDROM.\n\n\n-----\n\nFigure 5:\n\n\nDrive bitmask iteration\n\n\n-----\n\nFigure 6: Adding drives excluding DRIVE_CDROM type to the slice\n\nThe last thing that the malware does in this phase is to create a WMI object for future use.\nWe’ll go over its functionality when we show the mechanism used to delete files.\n\n### Let’s Encrypt Some Files\n\nThe encryption phase starts by adding the attacker’s email into the ransom note.\n\nFigure 7: Creating the formatted ransom note string\n\nAs you may know, one of the biggest challenges ransomware authors face when developing\nransomware is encryption performance. The malware needs to encrypt as many files as\npossible, as fast as possible.\n\nThe author of DECAF chose the multi-goroutine (Go’s thread “equivalent”) method. It creates\nseveral encryption goroutines which wait for messages from the main routine. The message\ncontains the file path that it has to encrypt.\n\n\n-----\n\nFigure 8: Creating a communication channel and 4 Go Routines\n\nEach EncWorker waits to receive a new file path to encrypt from the channel. The file paths\ncome from the function FileUtils.ListFilesToEnc, which enumerates the files of the given\ndirectory and applies filtering according to the blacklists, README.txt, and .decaf extension.\n\n\n-----\n\nFigure 9: The main goroutine sends file paths after filtering and skipping symlinks\n\nFigure 10: check arg_file_path for symlink\n\n**Encryption Worker**\n\nmain_EncWorker_func1 is the function responsible for the encryption task. It listens for new\nfile paths, calls the file encryption function, deletes the original file after it is encrypted, and\ncreates a README.txt file inside each directory.\n\n\n-----\n\nFigure 11: main_EncWorker_func1 functionality\n\nOnce the file path has been received, the function calls Encryptor.E for encrypting the file.\n\nThe encryption routine is as follows:\n\nChecks if the file size is smaller than 4GB\n\n\n-----\n\nFigure 12: File\n\nsize check\n\nSets up the cryptographic algorithms\n\nDECAF uses AES-CBC-128 with a randomly generated encryption key and initial\nvector\nEach file is encrypted with a different symmetric encryption key\nThe file’s encryption key is encrypted using the attacker’s public key\n\n\n-----\n\nFigure 13: Encryption key and IV\n\nciphertext, err := EncryptOAEP(sha256.New(), aes_key, public_key, G_Reader, 0x10)\n\nThe next thing is to open the source (original file) and target (encrypted file) files. The\nmalware opens the original file with OF_READWRITE permission and creates a new target\nfile with .decaf extension.\n\n\n-----\n\nFigure 14: Open original and target files\n\nThe attacker needs to be able to decrypt all files in case someone pays the demanded\nransom to maintain its credibility. To do that, the attacker creates a special header for each\nfile that contains the relevant data for decryption.\n\nEncrypted file format:\n\n{\nFilePrefix // Encrypted files identifier\nFileSize // Reconstrcut the real file size after it has encrypted\n\nCBC_IV // Shared between encryption and decryption\nEncrypyedKeyLength\nEncryptedKey // Required for decrypting the enc_key using the attacker's private key\nEncrypyedData\n}\n\n<code: go>\n\n\n-----\n\nFigure 15: Encrypted file format\n\nThe file content is divided into chunks, where each chunk is 0x10 bytes. We wrote simple\npseudocode which represents the content encryption’s logic:\n\n1. Read 0x10 bytes from the original file\n2. If it’s EOF, end.\n3. If less than 0x10 bytes read, add random padding and create 0x10 bytes block\n4. Encrypt the data\n5. Write the encrypted data to the target file\n\n\n-----\n\nfuncEncryptFileContent()\n\n// ...\n\n// More initialization explained above\n\nsymmetricKey := rand.Reader.Read(0x10)\n\ninitialVector := rand.Reader.Read(0x10)\n\nhFile := os.OpenFile(\"<file_path>\", O_RDWR, 0)\n\nhTargetFile := os.OpenFile(\"<file_path>.decaf\", o_RDWR | O_CREATE | O_TRUNC,\n0x1B6)\n\nfileReader := bufio.NewReader(hFile)\n\nfileWriter := bufio.NewWriter(hFile)\n\nplaintext := make([]byte, 0x10)\n\nciphertext := make([]byte, 0x10)\n\n// Read until there's nothing to read\n\n_, err := io.ReadAtLeast(fileReader, plaintext, 0x10)\n\nwhile err != io.EOF {\n\nif err == io.ErrUnexpectedEOF {\n\n// Add random padding\n\npadLen := aes.BlockSize - len(inBytes)%aes.BlockSize\n\npadding := make([]byte, padLen)\n\n_, err = rand.Reader.Read(padding)\n\npadding[0] = byte(padLen)\n\nplaintext = append(padding, plaintext...)\n\nplaintextLen := len(plaintext)\n\n}\n\nblock, err := aes.NewCipher(symmetricKey)\n\ncfb := cipher.NewCBCEncrypter(block, initialVector)\n\ncfb.CryptBlocks(ciphertext[aes.BlockSize:], plaintext)\n\nfileWriter.Write(ciphertext)\n\n}\n\n}\n\nWe can assume that the author chose to divide the data into such small chunks as a way to\nevade detection by Anti-Ransomware solutions that monitor for large data chunk\nencryptions.\n\n**Original File Wiping**\n\nOnce the ransomware has created the encrypted file it needs to delete the original file and\neliminate the target’s ability to recover the file.\n\nFirst, the malware deletes the file using the WMI object created in the initialization phase.\nWe’ve reconstructed the malware’s WMI usage in the following pseudocode:\n\n\n-----\n\n1. The malware connects to the local WMI s ROOT\\\\CIMV2 namespace for executing\n\ncommands\n2. Once the file is encrypted, the malware queries for the CIM_DataFile object according\n\nto the file’s path\n3. It counts the results and iterates over the items\n4. For each item, it invokes the Delete function\n\nfunc DeleteFileUsingWMI() {\nole.CoInitialize(0)\n\nunknown, _ := oleutil.CreateObject(\"WbemScripting.SWbemLocator\")\n\nwmi, _ := unknown.QueryInterface(ole.IID_IDispatch)\n\nserviceRaw, _ := oleutil.CallMethod(wmi, \"ConnectServer\")\n\nservice := serviceRaw.ToIDispatch()\n\n// ...\n// File encryption\n// ...\n\n// result is a SWBemObjectSet\nresultRaw, _ := oleutil.CallMethod(service, \"ExecQuery\",  \"SELECT * FROM\nCIM_DataFile where name=\"<file_path>\"\")\nresult := resultRaw.ToIDispatch()\ncountVar, _ := oleutil.GetProperty(result, \"Count\")\ncount := int(countVar.Val)\nfor i :=0; i < count; i++ {\n// Each item is CIM_DataFile object\n\nitemRaw, _ := oleutil.CallMethod(result, \"ItemIndex\", i)\n\nitem := itemRaw.ToIDispatch()\noleutil.CallMethod(item, \"Delete\")\n}\n}\n\nNow the last thing left is to remove the recovery ability on the infected system. For that,\nDECAF utilizes cipher.exe, similarly to other ransomware (e.g., LockerGoga and\nMegaCortex).\n\nDECAF iterates over the directories it needs to encrypt and calls cipher.exe with a /w:\n<directory_path>. This option overwrites (“wipes”) deleted data and, as a result, eliminates\nthe ability to recover the file.\n\n\n-----\n\nFigure 16: Wiping delete data inside the directory\n\n## Debug VS Pre-Release\n\nThe difference between the two versions of the same ransomware is that the pre-release\nvariant is stripped of symbols, strings and function names are obfuscated.\n\nWe assumed that the second version is a Pre-Released version due to the Protonmail used\nin the ransom note, which is filled with a placeholder instead of a real email address.\n\nFigure 17: Email address in the ransom note of the Pre-Release version\n\n### Time for comparison\n\n Go Version\n\n\n-----\n\nLet s take a look at the code from runtime.schedinit that contains the variable buildVersion.\nThis variable points to the Golang version that has been used, at least in the case that the\nsymbols are present and not stripped.\n\nFigure 18: Go version comparison\n\nIt’s worth mentioning that Go 1.17 implements a new way of passing function arguments and\nresults using registers instead of the stack. Because of this, reverse engineering Golang\ncould become messy for newcomers.\n\nhttps://golang.org/doc/go1.17#compiler\n\n### Public key\n\nFigure 19: Public key comparison\n\n### Strings Obfuscation\n\nThe ransomware uses string obfuscation in its Pre-Release version. Strings are being deobfuscated on runtime while utilizing different custom de-obfuscation functions.\n\nFor example, the initialization of the `Encryptor` object’s decaf extension attribute:\n\nFigure 20: .decaf extension deobfuscation\n\nAnother example could be seen while deleting the original file. The WMI query used in the\nDebug version was embedded into the binary while in the Pre-Release version it was stored\nencrypted. Before calling the delete function, the malware executes the decryption function\n\n\n-----\n\nand reveals the real WMI query, as we saw in the Debug version.\n\nFigure 21: WMI query resolving\n\n## Conclusion\n\nThe development of DECAF continues to this day, showing that ransomware groups\nconstantly innovate their attacks. That the attack is written in Golang is further proof of this\ntrend toward innovation among the adversary community; threat actors are forever making\nchanges and adding new capabilities to evade the detection-centric solutions that\npredominate in the market.\n\nCompanies need to adopt prevention-first strategies, such as the ones Morphisec provides,\nto ensure that they stand a chance at protecting their critical systems from further attacks.\nMorphisec Labs will continue to track the development of the DECAF ransomware and report\nany further developments that we uncover.\n\n## IOCs\n\n### Debug Version Public Key\n\n-----BEGIN RSA PUBLIC KEY----\nMIIBCgKCAQEAv+D8WLstRCGExBNfcsd8iYvvBajk1wxLbHgteWQCtXWqr7VDaBD8\nSEVez9LQVDvUNdHmRK+8n/JtkJ2vuPwBfb8IxZJ7sXsk/Zt1eoE7tZYUtKTZwazl\n1zNbTR8Ocftkj3LW57atj+nTEUues7RkauWkXAlJckGXON4LXTI63QFleOmF0+C+\nxoRkw3MibdQhePLZFm9eczZAmYqU875iBAQ5krsmvG10FU+2VVKmwAXfD9EUiuQ0\n\nZQPwayA0ubYuMmayj6SE7OlQzYuPQJzj6vYjMOnalCoe3yEu6Km35moYDcBN9p9f\nv36lPX2Mlq20tYiuGKcGSMeT7y/fmO9joQIDAQAB\n\n-----END RSA PUBLIC KEY----\n### Pre-Release Version Public Key\n\n\n-----\n\n-----BEGIN RSA PUBLIC KEY----\nMIIBCgKCAQEAq4k1Hdb1THrzBBeO184knCbBKr03apfXqlOkSdtHSJgfyIqJPGxl\n\n/cFisJmVXR3/t4e9FbLsEIuTp9PJTciomHfr5CgCQzhnAZ0AvjGBaWP6KpCyfDns\n\nybruyKqygaWpZSAnzRdB+TAku5iqy8q1VwnN57QBltro0YJZ8enKZRTlczmtjeOp\n\nB/xuTOuDjmUSNiGyijWBVfYk7sVXl/lQ8taXr36xPWhMIG0EqRVrFV+cavS7Z4va\n\nyXmcf55NkpMGKKY8uqvwb4aLIKabek2nUWBgNgSOtqBLLL2A2bY/5s0GJ/VV+EmI\n\nX7/zI+FceU+dcNX/ir0ujP4ys4m/jjZD4wIDAQAB\n\n-----END RSA PUBLIC KEY----\n### Hashes\n\n**Pre-release**\n\n5da2a2ebe9959e6ac21683a8950055309eb34544962c02ed564e0deaf83c9477\n\n**Debug**\n\n98272cada9caf84c31d70fdc3705e95ef73cb4a5c507e2cf3caee1893a7a6f63\n\n## Appendix\n\n### Files blacklist\n\nbootfont.bin\n\nboot.ini\n\nntuser.dat\n\ndesktop.ini\n\niconcache.db\n\nntldr\n\nntuser.dat.log\n\nthumbs.db\n\nbootsect.bak\n\nntuser.ini\n\nautorun.inf\n\nbootnxt\n\nbootmgr\n\n### Directories blacklist\n\n\n-----\n\nintel\n\nprogram files (x86)\n\nprogram files\n\nmsocache\n\n$recycle.bin\n\n$windows.~ws\n\ntor browser\n\nboot\n\nsystem volume information\n\nperflogs\n\ngoogle\n\napplication data\n\nwindows\n\nprogramdata\n\nwindows.old\n\nappdata\n\nmozilla\n\n### Extensions blacklist\n\n.themepack .shs       .prf\n\n.ldf    .drv       .dll\n\n.scr    .wpx       .nomedia\n\n.icl    .deskthemepack  .idx\n\n.386    .bat       .tmp\n\n.cmd    .rom       .pdb\n\n.ani    .msc       .lib\n.adv    .lnk       .class\n.theme   .cab\n\n.msi    .spl\n\n.rtp   .ps1\n\n.diagcfg .msu\n\n.msstyles .ics\n\n.bin   .key\n\n.hlp   .msp\n\n[Contact SalesInquire via Azure](http://10.10.0.46/mailto:sales@morphisec.com)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-10-28 - DECAF Ransomware- A New Golang Threat Makes Its Appearance.pdf"
    ],
    "report_names": [
        "2021-10-28 - DECAF Ransomware- A New Golang Threat Makes Its Appearance.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535746,
    "ts_updated_at": 1743041173,
    "ts_creation_date": 1653692147,
    "ts_modification_date": 1653692147,
    "files": {
        "pdf": "https://archive.orkl.eu/55be97c29f046434173587e3d5c59a0411f83909.pdf",
        "text": "https://archive.orkl.eu/55be97c29f046434173587e3d5c59a0411f83909.txt",
        "img": "https://archive.orkl.eu/55be97c29f046434173587e3d5c59a0411f83909.jpg"
    }
}