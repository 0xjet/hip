{
    "id": "a045cc46-dce6-404e-81b2-1da616344484",
    "created_at": "2023-01-12T15:05:23.304386Z",
    "updated_at": "2025-03-27T02:16:01.089857Z",
    "deleted_at": null,
    "sha1_hash": "1c174f0a674bbc55181a8346ba2ab8cb1953eb15",
    "title": "2022-01-06 - Rook Ransomware Analysis",
    "authors": "",
    "file_creation_date": "2022-05-27T23:24:41Z",
    "file_modification_date": "2022-05-27T23:24:41Z",
    "file_size": 1992862,
    "plain_text": "# Rook Ransomware | Chuong Dong\n\n**[chuongdong.com/reverse engineering/2022/01/06/RookRansomware/](https://chuongdong.com/reverse%20engineering/2022/01/06/RookRansomware/)**\n\nChuong Dong January 6, 2022\n\n[Reverse Engineering · 06 Jan 2022](https://chuongdong.com/categories/#reverse%20engineering)\n\n## Rook Ransomware\n\n Contents\n\n Overview\n\nThis is my analysis for ROOK Ransomware.\n\n**ROOK is a relatively new ransomware that has been coming up in the last few months. With**\nthe [Mbed TLS library, the malware uses a hybrid cryptography scheme to encrypt files using](https://github.com/ARMmbed/mbedtls)\nAES and protect its keys with RSA-2048.\n\nFor execution speed, ROOK is quite fast since it uses a decently good method of\nmultithreading with two global lists for file and directory traversal.\n\nAs it has been claimed by other researchers, ROOK borrows some of the code from the\nleaked BABUK source code. To be more specific, the ROOK developers copied and pasted\nthe code for services & processes termination as well as deleting shadow copies. ROOK’s\nmultithreading approach is a reimplementation and an upgrade from that of BABUK version\n**3, which is now more efficient for directory traversal.**\n\nHowever, unlike BABUK devs who are big fans of using ECDH curves and eSTREAM\nportfolio Profile 1 ciphers such as ChaCha and HC-128 for hybrid-encryption, ROOK devs\nstick with the traditional choice of RSA and AES.\n\n\n-----\n\n_Figure 1: ROOK Leak Site._\n\n## IOCS\n\nThe analyzed sample is a 64-bit Windows executable.\n\n**MD5: 6d87be9212a1a0e92e58e1ed94c589f9**\n\n**SHA256: c2d46d256b8f9490c9599eea11ecef19fde7d4fdd2dea93604cee3cea8e172ac**\n\n**Sample:** [MalwareBazaar](https://bazaar.abuse.ch/sample/c2d46d256b8f9490c9599eea11ecef19fde7d4fdd2dea93604cee3cea8e172ac/)\n\n\n-----\n\n_Figure 2: VirusTotal Result._\n\n## Ransom Note\n\nThe content of the default ransom note is stored in plaintext in ROOK’s executable.\n\n**ROOK’s ransom note filename is “HowToRestoreYourFiles.txt”, which is really similar to**\n**BABUK’s “How To Restore Your Files.txt”.**\n\n\n-----\n\n_Figure 3: ROOK s Ransom Note._\n\n## Static Code Analysis\n\n RSA Key Generation\n\nThe first thing ROOK does upon execution is setting up the RSA keys for asymmetric\nencryption.\n\nFirst, the malware initializes a CTR_DRBG [context using the Mbed TLS library, which is](https://tls.mbed.org/api/structmbedtls__ctr__drbg__context.html)\nused to build a pseudo-RNG to later randomly generate AES keys.\n\n_Figure 4: CTR_DRBG Initialization._\n\nNext, it calls [mbedtls_pk_parse_public_key to parse the TA’s RSA public key into a](https://tls.mbed.org/api/pk_8h.html#ade680bf8e87df7ccc3bb36b52e43972b)\n**mbedtls_pk_context struct. The ROOK’s public key context is then extracted from the**\n**pk_ctx field on the newly populated mbedtls_pk_context struct.**\n\nBelow is the raw content of the public key.\n```\n-----BEGIN PUBLIC KEY----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4g06WvN+BRr9GeeOkZ4y\nnnK1uHreCPZyEsc43g3ftVXqsq2Kbdy7Z+XORqxmBi8D5nhDfw3eHRzH8wpcUos3\nszWKyJLOeKhN6DM5M4FppD8hyuKDTcgsa70Nhapc1Oyjfh3kf3Kc/2CUhnPYEzHe\nfHN3yOq9wxOVGc1S+bcTM3ez8gRuv0fB9ao2bJM0pKJphYq5dNkT0p2Ty923n+yZ\nAOKELIWwwyOQgyfiv8ZwkdPL+UbNQq2dYZEWa1qSsGgN2655hvvD/pH/bggAFEqm\nOybQFnRcdG9Fja9m/ZVp7jBYuX+4FaFq3DjD0oW/7imboVsEqcx7l7ym4tiKCz57\nMwIDAQAB\n-----END PUBLIC KEY----\n```\n\n-----\n\n_Figure 5: Parsing ROOK’s RSA Public Key._\n\n**ROOK then calls RegCreateKeyExW to open the subkey Software in**\n**HKEY_CURRENT_USER. Using that, it calls RegQueryValueExW to check if the registry**\nvalue RookPublicKey exists in there. If it does not, the malware generates a public-private\nkey pair for the victim.\n\n\n-----\n\n_Figure 6, 7: Querying From Registry & Generating Victim Public-Private Key Pair._\n\nNext, ROOK encrypts the victim’s RSA private key using its own public key context.\n\n\n-----\n\n_Figure 8: Encrypting Victim Private Key Using TA’s Public Key._\n\nThe victim’s public key and encrypted private key are consecutively stored in the registry at\nthe value RookPublicKey and RookPrivateKey.\n\nIf the victim’s public key was already generated before and the malware can query it directly\nfrom registry, the victim’s encrypted private key is pulled from the registry value\n**RookPrivateKey.**\n\nFinally, the malware calls mbedtls_pk_parse_public_key to retrieve the victim’s public key\ncontext and wipes the victim’s raw private key from memory.\n\n\n-----\n\n_Figure 9: Writing Keys to Registry & Cleaning Up._\n\n## Anti-Detection: Alternate Data Streams\n\n**Alternate Data Streams (ADS) is a file attribute on the NT File System (NTFS) which was**\ndesigned for compatibility with Macintosh Hierarchical File System (HFS).\n\nFor normal files, there is typically one primary data stream that is known as the unnamed\ndata stream since its name is an empty string. However, ADS allows files to have more than\none data stream, with any stream with a name being considered alternate.\n\nBecause alternate data streams are hidden from Windows Explorer and the dir command\non the command-line, they are a sneaky way to hide external executable from a seemingly\nharmless file.\n\nTo evade detection, ROOK uses ADS to hides its own executable. First, it calls\n**GetModuleFileNameW with a NULL handle to retrieve its own executable path.**\n\nIt then calls CreateFileW to retrieve its own handle and SetFileInformationByHandle to\nrename the file with a data stream named “:ask”. This ultimately puts the entire executable\ninto the alternate “:ask” data stream, leaving an empty file on the primary stream.\n\n\n-----\n\n_Figure 10: Moving Executable to Data Stream._\n\nPausing the execution after the handle is released using the call to CloseHandle, we can\nexamine how it looks in the system.\n\nBy running the command “dir /r”, we can examine what changes to the executable file.\n\nTo test this, I use two copies of the ROOK sample and have the ro0k.mal_ one hide itself in\nthe “:ask” data stream. As we can see in the command-line, that file shows up empty, but its\nalternate data stream contains the full malicious executable.\n\n_Figure 11: Examining Alternate Data Stream In Command-Line._\n\nAfter doing this, the ransomware file will appear as empty in the file system until the end of\nexecution.\n\nAfter hiding itself, ROOK also calls SetFileInformationByHandle again to set the file to be\ndeleted once all handles are closed at the end.\n\n\n-----\n\n_Figure 12: Set Up File for Self-Deletion._\n\n## Command-line Arguments\n\n**ROOK can run with or without command-line arguments.**\n\nBelow is the list of arguments that can be supplied by the operator.\n\n**Argument** **Description**\n\n**-debug <log_filename>** Enable logging to the specified log file\n\n**-shares <share_list>** List of network shares to be traversed\n\n**-paths <drive_list>** List of local & network drives to be traversed\n\n## Logging\n\nWhen the debug argument is provided on the command-line, ROOK enables debugging and\ncalls CreateFileW to create the log file to later log into.\n\nIt also calls InitializeCriticalSection to initialize a critical section to prevent multiple threads\nfrom writing into the log file at the same time.\n\n_Figure 13: Logging Initialization._\n\n## Stopping Services\n\nFor stopping services, ROOK borrows this part from the leaked BABUK source code.\n\nThe malware first calls GetTickCount to get a tick count prior to stopping services. It then\ncalls OpenSCManagerA to retrieve a service control manager handle.\n\n\n-----\n\n_Figure 14: Retrieving Service Control Manager._\n\nNext, it iterates through a hard-coded list containing services to be stopped. For each of\nthese service, the malware calls OpenServiceA to retrieve the service’s handle and\n**QueryServiceStatusEx to query and checks if the service state is**\n**SERVICE_STOP_PENDING.**\n\nIf it is not, ROOK calls EnumDependentServicesA to enumerate through all dependent\nservices of the target service and stop them.\n\n_Figure 15: Iterating Through Service Stop List._\n\nFor each dependent service, the malware calls OpenServiceA to retrieve its handle and\n**ControlService to send a control stop code to stop it. It also sleeps and calls**\n**QueryServiceStatusEx to wait until the service’s state is fully stopped.**\n\n\n-----\n\n_Figure 16: Stopping Dependent Services._\n\nAfter stopping all dependent services, ROOK calls ControlService send a control stop code\nto the main service and continuosly checks until the service is fully stopped.\n\n_Figure 17: Stopping Target Services._\n\nFor stopping all services, the maximum timeout is 30000ms or 30 seconds from the original\ntick count. If it takes more than 30 seconds to stop services, the malware aborts and exits\nthe function.\n\nBelow is the list of services that are stopped.\n```\n\"memtas\", \"mepocs\", \"vss\", \"sql\", \"svc$\", \"veeam\", \"backup\", \"GxVss\", \"GxBlr\",\n\"GxFWD\", \"GxCVD\", \"GxCIMgr\", \"DefWatch\", \"ccEvtMgr\", \"ccSetMgr\", \"SavRoam\",\n\"RTVscan\", \"QBFCService\", \"QBIDPService\", \"Intuit.QuickBooks.FCS\",\n\"QBCFMonitorService\", \"AcrSch2Svc\", \"AcronisAgent\", \"CASAD2DWebSvc\", \"CAARCUpdateSvc\"\n\n## Terminating Processes\n\n```\nThis part of code is also copied and pasted from the BABUK source code.\n\n\n-----\n\n**ROOK calls CreateToolhelp32Snapshot to retrieve a snapshot of all processes and threads**\nin the system. It then calls Process32FirstW and Process32NextW to enumerate through\nthe snapshot.\n\nFor each process whose name is in the list of processes to be terminated, the malware calls\n**OpenProcess to retrieve the process’s handle and TerminateProcess to terminate it.**\n\n_Figure 18: Stopping Target Services._\n\nBelow is the list of processes that are stopped.\n```\n\"sql.exe\", \"oracle.exe\", \"ocssd.exe\", \"dbsnmp.exe\", \"visio.exe\", \"winword.exe\",\n\"wordpad.exe\", \"notepad.exe\", \"excel.exe\", \"onenote.exe\", \"outlook.exe\",\n\"synctime.exe\", \"agntsvc.exe\", \"isqlplussvc.exe\", \"xfssvccon.exe\",\n\"mydesktopservice.exe\", \"ocautoupds.exe\", \"encsvc.exe\", \"firefox.exe\",\n\"tbirdconfig.exe\", \"mydesktopqos.exe\", \"ocomm.exe\", \"dbeng50.exe\",\n\"sqbcoreservice.exe\", \"infopath.exe\", \"msaccess.exe\", \"mspub.exe\", \"powerpnt.exe\",\n\"steam.exe\", \"thebat.exe\", \"thunderbird.exe\"\n\n## Deleting Shadow Copies\n\n```\n\n-----\n\nThis part of code is also copied and pasted from the BABUK source code.\n\n**ROOK first checks if its process is running under a 64-bit processor by calling**\n**IsWow64Process.**\n\n_Figure 19: Checking Process Architecture._\n\nIf it is, the malware calls Wow64DisableWow64FsRedirection to disable file system\nredirection for its process.\n\nThen it executes ShellExecuteW to launch the following command in the command line to\ndelete all shadow copies in the system.\n```\nvssadmin.exe delete shadows /all /quiet\n\n```\nFinally, if the malware’s process is running under a 64-bit architecture, it calls\n**Wow64RevertWow64FsRedirection to enable file system redirection.**\n\n\n-----\n\n_Figure 20: Deleting Shadow Copies._\n\n## Multithreading Setup\n\nPrior to encrypting files, ROOK sets up its own multithreading system.\n\nInitially, it calls GetSystemInfo to retrieve the number of processors in the system.\n\nThe multithreading structure is divided into two parts: file encryption and directory\nenumeration.\n\nFor file encryption, the malware calculates the maximum number of files to be encrypted by\nmultiple threads at the same time is 24 times the number of processors. It then calls\n**HeapAlloc to allocate a global array to store the files that are set to be encrypted and**\n**CreateSemaphoreA to create 2 semaphores that are used for synchronization among**\nthreads that access the file array. Finally, it also calls InitializeCriticalSection to initialize a\ncritical section that allows one thread to add or remove a file from the global array at a time.\n\n\n-----\n\n_Figure 21: Threading Setup for File Encryption._\n\nFor directory enumeration, the malware calculates the maximum number of directories to be\nenumerated by multiple threads at the same time is 6 times the number of processors. It also\ncreates a global array, 2 semaphores, and a critical section like to the file encryption part\nabove.\n\n_Figure 22: Threading Setup for Directory Enumeration._\n\nNext, the malware calls HeapAlloc to allocate two arrays to store child thread handles, one\nfor file encryption and the other for directory enumeration.\n\n**ROOK then calls CreateThread to spawn threads for double the number of processors for**\neach thread array. The functionalities of these threads are later discussed in the Child\nThread section.\n\n\n-----\n\n_Figure 23: Spawning Child Threads._\n\n## Network Resource Traversal\n\nWhen the command-line argument “-paths” or “-shares” is not provided, ROOK recursively\ntraverses through all resources in the network.\n\nThe malware calls WNetOpenEnumW to retrieve an enumeration handle for all network\nresources and WNetEnumResourceW to enumerate through them.\n\nFor each network resource, if it’s a container for other resources that can also be\nenumerated, ROOK recursively passes it back to the current function to traverse it.\n\nIf the resource is just a normal and connectable directory, the malware passes it into a\nrecursive function to traverse it, which will be discussed in the Drives Traversal section.\n\n\n-----\n\n_Figure 24: Traversing Network Resources._\n\n## Drives Traversal\n\nWhen the command-line argument “-paths” is provided, ROOK specifically enumerates\nthem and exits upon completion.\n\nThe argument can come in the form of a list of paths, each separated by a comma. Instead\nof a normal directory path, ROOK also accepts a two-character string of a drive letter\nfollowed by a colon as a path to a drive.\n\n\n-----\n\n_Figure 25: Parsing “-paths” Command-Line Argument._\n\nWhen traversing a drive, ROOK builds the following drive path.\n```\n\\\\\\\\?\\\\<drive_letter>:\n\n```\nWith the path, the malware checks and avoids enumerating the drive if it’s a CD-ROM drive.\n\nIf the drive type is a remote drive, ROOK calls WNetGetConnectionW to retrieve the remote\nname of the drive and passes it to be traversed by the recursive_traverse_dir function.\n\nIf the drive type is not remote drive and CD-ROM drive, the malware simply passes it to the\n**recursive_traverse_dir function.**\n\nIn the recursive_traverse_dir function, ROOK begins by executing two nested while loop.\nThe first one loops and waits until the END_ACCESS_DIR_SEMAPHORE semaphore’s\ncount is reduced to zero, and its state is nonsignaled. When this happens, it means every\ndirectory in the global directory list is already traversed and no thread is extracting from it.\n\nWhile waiting for this, the inner while loop waits until the\n**BEGIN_ACCESS_FILE_SEMAPHORE semaphore is signaled, which allows the current**\nprocess to access the global file list. After obtaining the ownership of the critical section for\n\n\n-----\n\nthe global file list using EnterCriticalSection, ROOK extracts the file at the current index,\nincrements the index, and encrypts it. The file encryption routine is later discussed at the File\nEncryption section.\n\n_Figure 27: Waiting for Directory List to Be Cleared & Encrypting File in the Meantime._\n\nInstead of just looping and waiting for the directory list to be cleared, ROOK extracts and\nencrypts files in the global file list during the wait time to increase efficiency and avoids\nwasting computing resources. This makes the overall enumeration and encryption process\nquite fast.\n\nNext, the malware calls EnterCriticalSection to obtain the ownership of the global directory\nlist and adds the directory path to be traversed in. Then, it calls ReleaseSemaphore to\nrelease the BEGIN_ACCESS_DIR_SEMAPHORE semaphore, which increments its count\nby one and signals other threads that another directory is available to be enumerated.\n\n\n-----\n\n_Figure 28: Adding Directory to Global List & Signaling for Enumeration._\n\nThen, the function begins enumerating the directory for all its sub-directories. ROOK builds\nthe path **“\\\\\\*\"** and passes it to **FindFirstFileW** to start the enumeration.\n\n_Figure 29: Enumerating Directory for Sub-Directories._\n\nFor each sub-directory found, the malware checks if the filename is not in the list of files and\ndirectories to avoid. If it’s not, the sub-directory full path is constructed and passed back to\n**recursive_traverse_dir to be recursively traversed.**\n\nBelow is the list of files and directories to avoid.\n```\n<log_filename>, \"Mozilla Firefox\", \"$Recycle.Bin\", \"ProgramData\", \"All Users\",\n\"autorun.inf\", \"boot.ini\", \"bootfont.bin\", \"bootsect.bak\", \"bootmgr\", \"bootmgr.efi\",\n\"bootmgfw.efi\", \"desktop.ini\", \"iconcache.db\", \"ntldr\", \"ntuser.dat\",\n\"ntuser.dat.log\", \"ntuser.ini\", \"thumbs.db\", \"Program Files\", \"Program Files (x86)\",\n\"AppData\", \"Boot\", \"Windows\", \"Windows.old\", \"Tor Browser\", \"Internet Explorer\",\n\"Google\", \"Opera\", \"Opera Software\", \"Mozilla\", \"#recycle\", \"..\", \".\"\n\n```\n\n-----\n\n_Figure 30: Recursively Traversing All Sub-Directories._\n\nIf the command-line argument “-paths” is not provided, ROOK manually mounts all drives\nthat have no volume mounted and traverses through all of them.\n\nFirst, it builds a list of all drive letters and iterates through it to find drives with type\n**DRIVE_NO_ROOT_DIR. Those drives are then added to the end of the list.**\n\n\n-----\n\n_Figure 31: Finding Drives with an Invalid Root Path._\n\nNext, ROOK calls FindFirstVolumeW and FindNextVolumeW to scan for available volumes\nin the system. For each volume, the malware calls\n**GetVolumePathNamesForVolumeNameW to retrieve the volume GUID path and**\n**SetVolumeMountPointW to set the path as the root path for the next no-root drive in the list.**\n\n_Figure 32: Mounting All Unmounted Drives._\n\nFinally, the malware calls GetLogicalDrives to iterate through all the drives in the system\nand traverse them.\n\n_Figure 33: Traversing All Mounted Drives._\n\n## Shares Traversal\n\nWhen the command-line argument “-shares” is provided, ROOK specifically enumerates\nthem and exits upon completion.\n\n\n-----\n\nThe argument can come in the form of a list of network server paths, which each separated\nby a comma.\n\n_Figure 34: Parsing “-shares” Command-Line Argument._\n\nTo traverse each share server, the malware calls NetShareEnum to retrieve information\nabout each shared resource on it.\n\nFor each shared resource, if its type is not a special share reserved for interprocess\ncommunication (IPC$) or remote administration of the server (ADMIN$), the shared resource\nis skipped.\n\nIf the share name is “ADMIN$”, the malware builds the path **”\\\\\\\\ADMIN\\$\"** and passes it\nto **recursive_traverse_dir** to be traversed.\n\n\n-----\n\n_Figure 35: Traversing Shared Resources._\n\n## Child Thread\n\nFor the spawn child threads, they have two different modes of execution depending on the\nflag passed in as parameter.\n\nIf the flag is 1, the thread will process a directory from the global directory list.\n\nFirst, it enters a nested while loop like the one we have seen earlier. The first loop waits until\nthe BEGIN_ACCESS_DIR_SEMAPHORE semaphore enters a nonsignaled state, which\nmeans no thread is adding to the directory list.\n\nWhile waiting for that, ROOK efficiently waits to retrieve access to the global file list, extract a\nfile, and encrypts it similar to the previous nested while loop.\n\n\n-----\n\n_Figure 36: Waiting for Global Directory List Access._\n\nAfter the directory list is full, the malware obtains ownership of the list’s critical section,\nextracts a directory out, and begins traversing it for sub-files.\n\n_Figure 37: Extracting Directory & Enumerating for Sub-Files._\n\nFor the enumeration, ROOK first builds a path to a ransom note file in the directory, calls\n**CreateFileW to create it and WriteFile to write the ransom note content to it.**\n\nBelow is the raw content of the ransom note.\n\n\n-----\n\n```\n       Welcome. Again.\n[+]Whats Happen?[+]\nYour files are encrypted,and currently unavailable. You can check it: all files on\nyou computer has expansion robet.\nBy the way,everything is possible to recover (restore), but you need to follow our\ninstructions. Otherwise, you cant return your data (NEVER).\n[+] What guarantees?[+]\nIts just a business. We absolutely do not care about you and your deals, except\ngetting benefits. If we do not do our work and liabilities - nobody will not\ncooperate with us. Its not in our interests.\nTo check the file capacity, please send 3 files not larger than 1M to us, and we will\nprove that we are capable of restoring.\nIf you will not cooperate with our service - for us, its does not matter. But you\nwill lose your time and data,cause just we have the private key. In practise - time\nis much more valuable than money.\nIf we find that a security vendor or law enforcement agency pretends to be you to\nnegotiate with us, we will directly destroy the private key and no longer provide you\nwith decryption services.\nYou have 3 days to contact us for negotiation. Within 3 days, we will provide a 50%\ndiscount. If the discount service is not provided for more than 3 days, the files\nwill be leaked to our onion network. Every more than 3 days will increase the number\nof leaked files.\nPlease use the company email to contact us, otherwise we will not reply.\n[+] How to get access on website?[+] \nYou have two ways:\n1) [Recommended] Using a TOR browser!\n     a) Download and install TOR browser from this site:hxxps://torproject[.]org/\n     b) Open our website:<redacted>[.]onion\n2) Our mail box:\n     a)<redacted>@onionmail[.]org\n     b)<redacted>@onionmail[.]org\n     c)If the mailbox fails or is taken over, please open Onion Network to check\nthe new mailbox\n----------------------------------------------------------------------------------------------!!!DANGER!!!\nDONT try to change files by yourself, DONT use any third party software for restoring\nyour data or antivirus solutions - its may entail damge of the private key and, as\nresult, The Loss all data.\n!!!!!!!\nAGAIN: Its in your interests to get your files back. From our side, we (the best\n\n```\n\n-----\n\n```\nspecialists) make everything for restoring, please should not interfere.\n!!!!!!!\nONE MORE TIME: Security vendors and law enforcement agencies, please be aware that\nattacks on us will make us even stronger.\n!!!!!!!\n\n```\n_Figure 38: Dropping Ransom Note._\n\nNext, it builds the path **“\\\\*\"** and passes it to **FindFirstFileW** to begin enumerating\nthrough files in the directory.\n\n_Figure 39: Enumerating Files in Directory._\n\nFor each found file, ROOK checks to make sure its name is not in the files and directories to\navoid list and is not HowToRestoreYourFiles.txt.\n\n\n-----\n\n_Figure 40: Checking for Invalid Filenames._\n\n**ROOK also skips the file if its extension is “.exe”, “.dll”, or “.Rook”. After checking, the**\nmalware enters a nested while loop to wait until no thread can add to the global file list and\nextracts files to encrypt during the wait time.\n\nAfter getting access to the file list, ROOK calls EnterCriticalSection to obtain the ownership\nof the file list’s critical section and adds the subfile to the list.\n\n\n-----\n\n_Figure 41: Adding Subfile to Global File List._\n\nIf the flag from parameter is 1, the child thread will continuously encrypt files from the global\ndirectory list until the list is completely empty.\n\n_Figure 42: Iterating & Encrypting Files in Global List._\n\n## File Encryption\n\n\n-----\n\nPrior to file encryption, ROOK calls SetFileAttributesW to set the file attribute to normal.\n\nIt builds the following path **“.Rook\"** and calls **MoveFileExW** to change the file name to\nhave the encrypted extension **.Rook**.\n\n_Figure 43: Adding Encrypted Extension._\n\nNext, the malware calls CreateFileW to retrieve the file handle for the target and begins the\nencryption.\n\nFirst, it uses the Mbed TLS CTR_DRBG context to generates a random 16-byte AES key.\n\n_Figure 44: Randomly Generating AES Key for File._\n\nNext, ROOK populates the following structures for the file footer.\n\n\n-----\n\n```\nstruct ROOK_FILE_FOOTER\n{\n LARGE_INTEGER file_size;\n ROOK_CRYPT_METADATA metadata;\n};\nstruct ROOK_CRYPT_METADATA\n{\n _QWORD encrypted_chunk_count;\n _QWORD unk;\n BYTE AES_key_encrypted_by_my_public[256];\n BYTE my_private_key_encrypted_by_Rook_public[2304];\n};\n\n```\nThe malware begins by calling GetFileSizeEx to retrieve the size of the file and store it in the\nfile footer. It then uses the victim’s RSA public key to encrypt the AES key and store it in the\nmetadata’s AES_key_encrypted_by_my_public field.\n\n_Figure 45: Encrypting AES Key Using Victim’s Public Key._\n\nNext, it copies the victim’s private key that is encrypted using ROOK’s public key during RSA\nKey Generation into the metadata’s my_private_key_encrypted_by_Rook_public field.\n\n\n-----\n\n_Figure 46: Writing Victim’s Encrypted Private Key into File Footer._\n\nIf the file size is greater than 0x80000 bytes, the malware reads and encrypts at most three\n0x80000-byte chunks at the beginning of the file using AES-128 ECB.\n\n_Figure 47: Encrypting Files Larger Than 0x80000 Bytes._\n\nIf the file size is less than 0x80000 bytes or is between 0x80000 and 0x180000 bytes, the\nentire file will be encrypted.\n\n\n-----\n\n_Figure 48: Calculating & Encrypting the Last Chunk That Is Less Than 0x80000 Bytes._\n\nFinally, the file footer is written to the end of the file, which ends the encryption routine.\n\n_Figure 49: Writing File Footer._\n\nIf ROOK is unable to open the file prior to encryption, the malware attempts to terminate the\nfile owner’s process.\n\nIt first calls RmStartSession to starts a new Restart Manager session and\n**WideCharToMultiByte to convert the file path to a multibyte buffer.**\n\n\n-----\n\n_Figure 50: Starting A Restart Manager Session._\n\nUsing that session handle, the malware calls RmRegisterResources to register the target\nfile as a resource to the RM.\n\n_Figure 51: Registering Target File as a Resource._\n\n\n-----\n\nNext, it calls RmGetList to get a list of all applications that are using the file. For each of\nthese applications, if the application’s type is Windows Explorer or a critical process, it is\nskipped.\n\nThen, ROOK checks to make sure the application is not its own ransomware process\nthrough the process IDs. Finally, it calls OpenProcess to retrieve the process’s handle and\nterminate it using TerminateProcess.\n\n_Figure 52: Terminating File Owners._\n\nAfter terminating all processes that are using the file, ROOK passes it back in to be\nencrypted.\n\n_Figure 53: Setting Up File to Be Encrypted Again._\n\n## References\n\nhttps://infosecwriteups.com/alternate-data-streams-ads-54b144a831f1\n\nhttps://www.sentinelone.com/labs/new-rook-ransomware-feeds-off-the-code-of-babuk/\n\n\n-----\n\nhttps://chuongdong.com/reverse%20engineering/2021/01/03/BabukRansomware/\n\nhttps://chuongdong.com/reverse%20engineering/2021/01/16/BabukRansomware-v3/\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-06 - Rook Ransomware Analysis.pdf"
    ],
    "report_names": [
        "2022-01-06 - Rook Ransomware Analysis.pdf"
    ],
    "threat_actors": [
        {
            "id": "f8dddd06-da24-4184-9e24-4c22bdd1cbbf",
            "created_at": "2023-01-06T13:46:38.626906Z",
            "updated_at": "2025-03-27T02:00:02.877001Z",
            "deleted_at": null,
            "main_name": "Tick",
            "aliases": [
                "Stalker Taurus",
                "PLA Unit 61419",
                "Nian",
                "BRONZE BUTLER",
                "REDBALDKNIGHT",
                "STALKER PANDA",
                "G0060"
            ],
            "source_name": "MISPGALAXY:Tick",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "d4e7cd9a-2290-4f89-a645-85b9a46d004b",
            "created_at": "2022-10-25T16:07:23.419513Z",
            "updated_at": "2025-03-27T02:02:09.790389Z",
            "deleted_at": null,
            "main_name": "Bronze Butler",
            "aliases": [
                "Bronze Butler",
                "CTG-2006",
                "Operation ENDTRADE",
                "RedBaldNight",
                "Stalker Panda",
                "Stalker Taurus",
                "TEMP.Tick",
                "Tick"
            ],
            "source_name": "ETDA:Bronze Butler",
            "tools": [
                "8.t Dropper",
                "8.t RTF exploit builder",
                "8t_dropper",
                "9002 RAT",
                "AngryRebel",
                "Blogspot",
                "Daserf",
                "Datper",
                "Elirks",
                "Farfli",
                "Gh0st RAT",
                "Ghost RAT",
                "HOMEUNIX",
                "HidraQ",
                "HomamDownloader",
                "Homux",
                "Hydraq",
                "Lilith",
                "Lilith RAT",
                "McRAT",
                "MdmBot",
                "Mimikatz",
                "Minzen",
                "Moudour",
                "Muirim",
                "Mydoor",
                "Nioupale",
                "PCRat",
                "POISONPLUG.SHADOW",
                "Roarur",
                "RoyalRoad",
                "ShadowPad Winnti",
                "ShadowWali",
                "ShadowWalker",
                "SymonLoader",
                "WCE",
                "Wali",
                "Windows Credential Editor",
                "Windows Credentials Editor",
                "XShellGhost",
                "XXMM",
                "gsecdump",
                "rarstar"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "bf0489c5-1c07-41e6-91c9-855ad96ccc6a",
            "created_at": "2022-10-25T16:47:55.541639Z",
            "updated_at": "2025-03-27T02:05:17.253496Z",
            "deleted_at": null,
            "main_name": "BRONZE BUTLER",
            "aliases": [
                "Daserf",
                "Stalker Panda ",
                "Tick ",
                "CTG-2006 "
            ],
            "source_name": "Secureworks:BRONZE BUTLER",
            "tools": [
                " DGet",
                " Daserf",
                " Datper",
                " Gofarer",
                " MSGet",
                " Mimikatz",
                " RarStar",
                " Screen Capture Tool",
                " ShadowPad",
                " T-SMB",
                " WinRAR",
                " Windows Credential Editor",
                " gsecdump",
                " xmm downloader",
                " xxmm",
                "ABK"
            ],
            "source_id": "Secureworks",
            "reports": null
        }
    ],
    "ts_created_at": 1673535923,
    "ts_updated_at": 1743041761,
    "ts_creation_date": 1653693881,
    "ts_modification_date": 1653693881,
    "files": {
        "pdf": "https://archive.orkl.eu/1c174f0a674bbc55181a8346ba2ab8cb1953eb15.pdf",
        "text": "https://archive.orkl.eu/1c174f0a674bbc55181a8346ba2ab8cb1953eb15.txt",
        "img": "https://archive.orkl.eu/1c174f0a674bbc55181a8346ba2ab8cb1953eb15.jpg"
    }
}