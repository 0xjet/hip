{
    "id": "24f2fd53-8dac-4a38-b37a-875bff72bb63",
    "created_at": "2023-01-12T15:07:51.482929Z",
    "updated_at": "2025-03-27T02:05:36.916466Z",
    "deleted_at": null,
    "sha1_hash": "b39eba883146dbf9307cad4e6164112f8b8d591f",
    "title": "2019-06-16 - A Deep Dive Into IcedID Malware- Part II - Analysis of the Core IcedID Payload (Parent Process)",
    "authors": "",
    "file_creation_date": "2022-05-28T15:21:02Z",
    "file_modification_date": "2022-05-28T15:21:02Z",
    "file_size": 385005,
    "plain_text": "# A Deep Dive Into IcedID Malware: Part II - Analysis of the Core IcedID Payload (Parent Process)\n\n**[fortinet.com/blog/threat-research/icedid-malware-analysis-part-two.html](https://www.fortinet.com/blog/threat-research/icedid-malware-analysis-part-two.html)**\n\nJuly 16, 2019\n\nThreat Research\n\nBy [Kai Lu | July 16, 2019](https://www.fortinet.com/blog/search?author=Kai+Lu)\n_FortiGuard Labs Threat Analysis Report Series_\n\nIn [part I of this blog series, I demonstrated how to unpack the IcedID malware, hooking and](https://www.fortinet.com/blog/threat-research/icedid-malware-analysis-part-one.html)\nprocess injection techniques used by IcedID, as well as how to execute the IcedID payload. In\nthis part below, let’s take a closer look at the core payload.\n\n## 0x01 Overview Of The Payload\n\nThe following is the entry point of the payload. It first unhooks the function RtlExitUserProcess.\nThe core function is implemented in the function sub_0x27FE(). Once the core module is\nexecuted successfully, the program is entering into an infinite loop that ensures the svchost.exe\nprocess does not exit.\n\nFigure 1. The entry point of the payload\n\nNext, let’s look at the function sub_0x27FE().\n\nFigure 2. The function sub_0x27FE()\n\nIn the next sections, I will show you what the function does.\n\n## 0x02 Two Injected Memory Regions\n\n\n-----\n\n[As you can see in Figure 15 of Part I, there are two injected memory regions into svchost.exe](https://www.fortinet.com/blog/threat-research/icedid-malware-analysis-part-one.html)\nprocess. The first one is a data segment whose size is 8KB. This segment stores several system\nAPI’s addresses at the beginning, encrypted C2 server list as well as other useful info.\n\nThe following is the system API’s addresses. The program can invoke them indirectly by\ninstructions like “call [base_addr + offset]”. The way of indirectly calling system API is tricky to\nstatic analysis.\n\nFigure 3. The system API’s addresses stored in the injected memory region\n\nThe following is these corresponding API’s names for the addresses above.\n\nFigure 4. These system API’s names\n\nAdditionally, it stores the encrypted C2 server list at offset 0x350.\n\nFigure 5. The encrypted C2 server list\n\nThe second memory region has three segments (one code segment and two data segments).\nThe core function of the payload is implemented in the code segment.\n\n## 0x03 Communication With C2 Server\n\nLet’s first look at how to get the C2 server list. As shown in Figure 5, the encrypted data are 256\nbytes. And the decrypted data is shown in Figure 6.\n\nFigure 6. The C2 server list\n\nWe can get the initial C2 server list.\n\n_albarthurst[.]pro_\n\n_mozambiquest[.]pw_\n\n_ransmittend[.]club_\n\n_summerch[.]xyz_\n\nIcedID uses the WinHTTP APIs to communicate with C2 servers. It sends a request and receives\nthe response over HTTPS. We can intercept the HTTPS traffic via Fiddler. But before using it, we\nhave to set WinHTTP’s Proxy. On Windows Vista and later, we need to use an elevated (admin)\ncommand prompt to call netsh like the following. The detailed instructions please refer to\n[https://www.telerik.com/blogs/using-fiddler-with-winhttp.](https://www.telerik.com/blogs/using-fiddler-with-winhttp)\n\nFigure 7. Set WinHTTP’s Proxy\n\nThe following is the decrypted HTTPS traffic IcedID sent in Fiddler.\n\nFigure 8. The decrypted HTTPS traffic IcedID sent in the initial stage\n\n\n-----\n\nIn the initial stage, IcedID could send a HTTP request over SSL to the C2 server. Then it parses\nthe response and continues to send 7 HTTP requests over SSL to download seven .DAT config\nfiles. Next, let’s dive into the URL parameters of the HTTP POST request. I highlighted some key\nitems.\n\nFigure 9. The HTTP POST request’s URL parameters\n\nThe first one is the Bot ID which is also used as RC4 key to encrypt the original .DAT config files.\nThe parameter ‘r’ indicates the version of IcedID. Its version number is 108 in this sample.\nRegarding the RC4 key generation algorithm, I will unveil its details in next section.\n\n## 0x04 RC4 Key Generation Algorithm\n\nThe function sub_0x29E2 is used to generate the RC4 key whose size is 4 in bytes.\n\nFigure 10. The RC4 key generation algorithm\n\nThe RC4 key is stored at offset 0x74A8 from starting address of the second injected memory\nregion. Then the RC4 key is also copied to the buffer at offset 0x74B8.\n\n## 0x05 Multiple Threads For Cooperative Work\n\nIcedID could create multiple threads to perform different tasks. Based on my analysis, there are\nfive child threads created by invoking the function CreateThread. Some threads are always\nrunning, the others would exit after completing their tasks depending on the received C2\ncommand. Here I list their thread functions below.\n\n### Thread 1 - Thread Function 0x2601\n\nThis thread function is mainly responsible for the initial communication with C2 server, handling\nthe HTTP response, as well as downloading the .DAT config files or other types of files\ndepending on the HTTP response and storing them into the corresponding folders. The following\nis the pseudo code of this thread function.\n\nFigure 11. The thread function 0x2601\n\nIn this infinite loop, it waits until the specified object is in the signaled state or the time-out interval\n(here it’s 5 minutes) elapses. Then it generates the URL parameters and HTTP request body.\nNext, it could communicate with C2 server over HTTPS. Finally, it handles the HTTP response\nand continues to download the .DAT config files or other files depending on the parsing result of\nthe HTTP response. This thread doesn’t exit and is always running to communicate with the C2\nserver.\n\nWhen IcedID is executed at the first time, the initial communication traffic is shown below.\n\nFigure 12. The initial communication with C2 server\n\n\n-----\n\nAs shown in Figure 12, the response is a multiple-line message. Each line is a C2 command\nconsisting of three parts that are separated by a semicolon. The malware could call the\ncorresponding handler function to complete specific task based on the C2 command number.\nThe first part represents the event ID, the second part represents the index of handler function,\nthe third part represents the parameter passed to the handler function. The following is the call\nto handler function.\n\nFigure 13. The call to handler function and all handler’s addresses\n\nIn this IcedID sample, it supports 18 different types of C2 commands.\n\n### Thread 2 - Thread Function 0x5599\n\nThis thread function is responsible for downloading .DAT config file and other types of files (such\nas executable file) from C2 server, and saving these data into the local files. For .DAT config files,\nthe HTTP response body is encrypted twice by RC4 algorithm with two different keys. Let’s take\na closer look at the encryption process. The following is the HTTP response from C2 server.\n\nFigure 14. Two-layer RC4 encryption process on HTTP response body\n\nAs shown in Figure 14, the first 8 bytes in the HTTP response body is the first layer’s RC4 key.\nThe length of second RC4 key is 4 in bytes. Its generation algorithm refers to the section “RC4\n**_key generation algorithm”._**\n\n### Thread 3 - Thread Function 0x2E59\n\nThis thread function is responsible for copying the IcedID PE file into \"C:\\ProgramData\\\n{0CD48D26-D226-4D28-9E39-3D2840658FD3}\\{8CD48D26-D226-4D28-9E3A3D2844658FD3}\\qgbjaykqtsu.exe\" and scheduling a task at logon. The name of the sub-directory\nmay differ on different compromised machines. The scheduled task is shown below.\n\nFigure 15. Schedule a task at logon\n\n### Thread 4 - Thread Function 0x1F9B\n\nThis thread function is responsible for communicating with C2 server. This thread is created in\nthe handler function which handles the C2 command 17 in Figure 13.\n\n### Thread 5 - Thread Function 0x52FC\n\nThis thread function is responsible for creating three new svchost.exe child processes and\ninjecting code into these processes’ space.\n\nFigure 16. The thread function 0x52fc\n\nAs shown in Figure 16, IcedID creates the svchost.exe child process with parameter\nCREATE_SUSPENDED. The primary thread of the new process would be in a suspended state,\nand the newly created process does not run until the ResumeThread function is called. Before\n\n\n-----\n\nresuming the primary thread, IcedID performs the code injection into the new process space.\nAfter that, it calls the ResumeThread function. The pseudo code of the injected code is shown in\nFigure 17.\n\nFigure 17. Inject code into svchost.ext child process\n\nIn the injection function, it first allocates three memory regions into the remote process space.\nThen it decrypts the injected code from DAT config file. Next, it performs the code injection into\nprevious allocated three memory regions. Finally, it sets up a hook at RtlExitUserProcess API in\nthe remote process space. Next, let’s continue to analyze which DAT config file is injected into\nthe corresponding child process.\n\n**1.**\n**yxuvgoshgc.dat(748961aabd75b85ee602e5f6d70322b281930349fbc98ad5c638104a759eba0b)**\n\nThis DAT config file is injected into the child process 1 like the following. There are three memory\nregions to be injected into the child process 1. The first one is the injected code segment. The\nsecond one is a data segment including several system API’s addresses and updated C2 server\nlist. The third one is a PE file.\n\nFigure 18. Injected svchost.exe child process 1\n\nThe hooked RtlExitUserProcess in child process 1 is shown below. When the RtlExitUserProcess\nfunction is called, it jumps to 0x210DF(offset:0x10DF) to execute the payload.\n\nFigure 19. Hooked RtlExitUserProcess in svchost.exe child process 1\n\n**2. uvgbwwwjcc.dat(b1d9d9bb617463a1cef665322949b29ad23ebfee2892908385b30cd739c163ce)**\n\nThis DAT config file is injected into the child process 2 like the following. There are three memory\nregions to be injected into the child process 2. The first one is the injected code segment. The\nsecond one is a data segment including several system API’s addresses and updated C2 server\nlist. The third one is a data segment.\n\nFigure 20. Injected svchost.exe child process 2\n\nThe hooked RtlExitUserProcess in child process 2 is shown below. When the RtlExitUserProcess\nfunction is called, it jumps to 0x21E0A(offset:0x1E0A) to execute the payload.\n\nFigure 21. Hooked RtlExitUserProcess in svchost.exe child process 2\n\n3. encziczibc.dat(672440151cd67a20bccc5c9f9f66f7d091098b0bd2a087eeac79af1f11bf3403)\n\nThis DAT config file is injected into the child process 3 like the following. There are three memory\nregions to be injected into the child process 3. The first one is the injected code segment. The\nsecond one is a data segment including several system API’s addresses and updated C2 server\nlist. The third one is a data segment.\n\n\n-----\n\nFigure 22. Injected svchost.exe child process 3\n\nThe hooked RtlExitUserProcess in child process 3 is shown below. When the RtlExitUserProcess\nfunction is called, it jumps to 0x11168E(offset:0x168E) to execute the payload.\n\nFigure 23. Hooked RtlExitUserProcess in svchost.exe child process 3\n\nRegarding how these three child processes work internally, I will continue to analyze it in part III.\n\n## 0x06 Persistent Payload And File Write Operations\n\nWe observed some file write operations like the following. It puts the persistent payload into a\nspecific folder. And it also puts seven .DAT config files into the folder\n“C:\\ProgramData\\cmrreaykdkq”. The sub-directory name might differ in different compromised\nsystems.\n\nFigure 24. The file write operations of persistent payload and DAT config files\n\nThe following table lists the detailed description of these DAT config files.\n\nTable 1. The detailed description of DAT config files\n\n## 0x07 Signature Verification\n\nIcedID can do signature verification of the payload. It first decrypts the C2 server config\nfile(alofykqgeb.dat) with RC4 key (see “RC4 key generation algorithm” section). The decrypted\ndata buffer is shown below. This buffer has three parts. The first 8 bytes is the original RC4 key.\nThe subsequent 0x80 bytes of data is the signature data to be verified. The third part is the\nupdated C2 server list.\n\nFigure 25. Decrypt data in alofykqgeb.dat\n\nNext, it decrypts the buffer of hard-coded RSA public key with XOR operation.\n\nFigure 26. The hard-coded RSA public key which is encrypted and RSA public key\n\nThen, it calls CryptVerifySignatureW function to verify the signature.\n\nFigure 27. Call CryptVerifySignatureW function to verify the signature\n\n## 0x08 Solution\n\nThis malicious PE file has been detected as “W32/Kryptik.GTSU!tr” by the FortiGuard AntiVirus\nservice.\n\nThe C2 server list has been rated as “Malicious Websites” by the FortiGuard WebFilter service.\n\n## 0x09 Conclusion\n\n\n-----\n\nWe have walked through what the svchost.exe parent process does internally. It includes how\nIcedID communicates with C2 server, RC4 key generation algorithm, the code injection process,\nwhat the multiple threads do in detail, signature verification, etc.\n\nIn the next [blog, I will provide a deep analysis of these three svchost.exe child processes.](https://www.fortinet.com/blog/threat-research/deep-dive-icedid-malware-analysis-of-child-processes.html)\n\n## Reference\n\n**SHA256**\n\nalofykqgeb.dat(00040d021a4813f11ba580ad76c669144ae787b8b93c6a3559e6662301d3be72)\n\nencziczibc.dat(672440151cd67a20bccc5c9f9f66f7d091098b0bd2a087eeac79af1f11bf3403)\nkdkdkqtfdb.dat(9bfb66621cf27f086f8db9e8761841fd0aff3a0a6348988324b408319639b9b8)\n\nuvgbwwwjcc.dat(b1d9d9bb617463a1cef665322949b29ad23ebfee2892908385b30cd739c163ce)\n\nwjalosuiec.dat(29d47ddb05381dd591c77c5eee62236cfc7120b1719d6e40f29872e9c9b53a0c)\n\nyxuvgoshcb.dat(24818652fd0031b3a1626da35068ec868d8d3b9635cb011677188cf73bc3eb5a)\n\nyxuvgoshgc.dat(748961aabd75b85ee602e5f6d70322b281930349fbc98ad5c638104a759eba0b)\n\n**C2 Server**\n\nalbarthurst[.]pro\n\nmozambiquest[.]pw\n\nransmittend[.]club\n\nsummerch[.]xyz\n\nethracial[.]pw\n\nsaudienter[.]pw\n\ngoodinzone[.]at\n\nforsynanchyv[.]com\n\nhipponexunam[.]org\n\nchardiop[.]club\n\nparenessed[.]icu\n\nmechangerous[.]space\n\nexchangests[.]xyz\n\nhydrylater[.]online\n\ncarlsbadenomise[.]top\n\nwagenstead[.]xyz\n\n_[Learn more about FortiGuard Labs and the FortiGuard Security Services portfolio.](https://www.fortinet.com/fortiguard/threat-intelligence/threat-research.html?utm_source=nreleaseblog&utm_campaign=2018-q2-fortiguardlabs-cta)_ _[Sign up for our](https://www.fortinet.com/fortiguard/threat-intelligence/threat-research.html?utm_source=nreleaseblog&utm_campaign=2018-q2-fortiguardlabs-cta)_\n_weekly FortiGuard Threat Brief._\n\n_[Read about the FortiGuard Security Rating Service, which provides security audits and best](https://www.fortinet.com/support-and-training/support-services/fortiguard-security-subscriptions/security-rating.html?utm_source=blog&utm_campaign=2018-blog-security-rating-service)_\n_practices._\n\n### Related Posts\n\nCopyright © 2022 Fortinet, Inc. All Rights Reserved\n\n\n-----\n\n[Terms of ServicesPrivacy Policy](https://www.fortinet.com/corporate/about-us/legal.html)\n| Cookie Settings\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-06-16 - A Deep Dive Into IcedID Malware- Part II - Analysis of the Core IcedID Payload (Parent Process).pdf"
    ],
    "report_names": [
        "2019-06-16 - A Deep Dive Into IcedID Malware- Part II - Analysis of the Core IcedID Payload (Parent Process).pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536071,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1653751262,
    "ts_modification_date": 1653751262,
    "files": {
        "pdf": "https://archive.orkl.eu/b39eba883146dbf9307cad4e6164112f8b8d591f.pdf",
        "text": "https://archive.orkl.eu/b39eba883146dbf9307cad4e6164112f8b8d591f.txt",
        "img": "https://archive.orkl.eu/b39eba883146dbf9307cad4e6164112f8b8d591f.jpg"
    }
}