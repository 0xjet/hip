{
    "id": "1c583c31-3748-4d95-8582-50e3ddee7647",
    "created_at": "2023-01-12T15:10:04.213977Z",
    "updated_at": "2025-03-27T02:16:25.587737Z",
    "deleted_at": null,
    "sha1_hash": "708a3cf8f8f80835dd08c95ab4b1898faf89244c",
    "title": "2021-05-19 - Binary Reuse of VB6 P-Code Functions",
    "authors": "",
    "file_creation_date": "2022-05-29T10:48:24Z",
    "file_modification_date": "2022-05-29T10:48:24Z",
    "file_size": 920748,
    "plain_text": "# Binary Reuse of VB6 P-Code Functions\n\n**[decoded.avast.io/davidzimmer/reusing-vb6-p-code-functions/](https://decoded.avast.io/davidzimmer/reusing-vb6-p-code-functions/)**\n\nby [David ZimmerMay 19, 202117 min read](https://decoded.avast.io/author/davidzimmer/)\n\n\nMay 19, 2021\n\n\nReusing binary code from malware is one of my favorite topics. Binary re-engineering and\nbeing able to bend compiled code to your will is really just an amazing skill. There is also\nsomething poetic about taking malware decryption routines and making them serve you.\n\nOver the years this topic has come up again and again. Previous articles have included\nemit based rips [1], exe to dll conversion [2], emulator based approaches [3], and even\nconverting malware into an `IPC based decoder service [4].`\n\nThe above are all native code manipulations which makes them something you can work\nwith directly. Easy to disassemble, easy to debug, easy to patch. (Easy being a relative term\nof course :))\n\nLately I have been working on `VB6 P-Code, and developing a P-Code debugger. One goal`\nI had was to find a way to call a P-Code function, ripped from a malware, with my own\narguments. It is very powerful to be able to harness existing code without having to recreate\nit (including all of its nuances.)\n\nIs this even possible with P-Code? As it turns out, it is possible, and I am going to show you\nhow.\n\nThe distilled knowledge below is small slice of what was unraveled during an 8 month\nresearch project into the VB6 runtime and P-code instruction set.\n\nThis paper includes 11 code samples which showcase a wide variety of scenarios utilizing\nthis technique [5].\n\n**Note on offsets**\n\nIn several places throughout this paper there may be VB runtime offsets presented. All\noffsets are to a reference copy with `md5: EEBEB73979D0AD3C74B248EBF1B6E770` [6].\n\n\n-----\n\nMicrosoft was kind enough to publish debug symbols for this build including those for the PCode engine handlers.\n\n**Barriers to entry**\nThe `VB6 runtime was designed to load executables, dlls, and ocx controls in an`\nundocumented format. This format contains many complex interlinked structures that layout\nembedded forms, class structures, dependencies etc. During startup the runtime itself also\nrequires certain initialization steps to occur as it prepares itself for use.\n\nIf we wish to execute `P-Code buffers out of the context of a` `VB6 host executable there`\nare several hurdles we must overcome:\n\n## VB Runtime Initialization\n\nStandard runtime initialization for executables takes place through the `ThunRTMain export.`\nThis is the primary entry point for loading a `VB6 executable. This function takes 1`\nargument that is the address of the top level `VB Header structure. This structure contains`\nthe full complex hierarchy of everything else within.\n\nWhile we can utilize this path for our needs, there are easier ways to go about it. Starting\nfrom `ThunRTMain can also create some problems on process termination so we will avoid`\nit.\n\nIn 2003 when exploring VB6’s ability to generate standard dlls I found a second path to\nruntime initialization through the `CreateIExprSrvObj export.`\n\nThis export is simple to call and automatically performs the majority of runtime initialization.\nSome `TLS structure fields however are left out. In testing, most things operate fine. The`\nonly errors discovered occur when trying to use native VB file commands, `MsgBox or the`\nbuilt in `App object.`\n\nWith a little extra leg work it has been found that the `TLS structures can be manually`\ncompleted to regain access to most of this native functionality.\n\nFinally if the P-Code buffer creates `COM objects, a manual call to` `CoInitilize must also`\nbe performed.\n\n## Replicating basic object structures\n\nOnce `CreateIExprSrvObj has been executed, we can call into P-Code streams as many`\ntimes as we want from our loader code. Structure initialization is minimal and only requires\nthe following fields:\n\n\n-----\n\nIf the P-Code routines utilize global variables then the `codeObj.aModulePublic field will`\nalso have to be set to a writable block of memory. This has been demonstrated in the\n```\nglobalVar and complex_globals examples. We can even pre-initialize these variables\n\n```\nhere if we desire.\n\nIn addition to filling out these primary structures, we also have to recreate the constant pool\nas expected by the specific P-Code. Finally we must also update a structure field in the PCode to point to our current object Info structure.\n\nWhile this may sound complex, there is a generator utility which automatically does all of\nthe work for you in the majority of cases. A more detailed explanation of the following code\nwill be presented in later sections.\n\n## Finding an entrypoint to transition into P-Code execution\n\nExecution of the VB6 P-Code occurs by calling the `ProcCallEngine export of the VB`\nruntime. The stub below is the same mechanism used internally by VB compiled\napplications to transfer execution between sub functions.\n\n\n-----\n\nThe `offset_sub_main argument moved into` `EDX is the address of the target P-Code`\nfunctions trailing structure that defines attributes of the function. We will discuss this\nstructure in the following sections.\n\nThe asm stub above shows the default scenario of calling a P-Code function with no\narguments. A video showing this running in a debugger is available [7].\n\nIn the `decrypt_test example we explore how to call a ripped function with a complex`\nprototype and a `Variant return value. This example demonstrates reusing an extracted`\nP-Code decoder from a malware executable. Here we can call the extracted P-Code\nfunction passing it our own data:\n\n\n-----\n\n## Understanding P-Code function layout\n\nP-Code functions in compiled executables are linked by a structure that trails the actual\nbyte code. This structure is called `RTMI in the VB runtime symbols and the reversing`\ncommunity has taken to it as `ProcDscInfo . A partial excerpt of this structure is shown`\nbelow:\n\n\n-----\n\nWhen we rip a P-Code function from a compiled binary, we must also extract the configured\n```\nRTMI structure. ProcCallEngine requires this information in order to run a P-Code\n\n```\nroutine successfully.\n\nWhen we relocate the P-Code block outside of the target binary, we must also update the\nlink to our new object Info table.\n\nThis is what is being set in the generated code:\n\nHere the `rc4 buffer contains the entire ripped function, starting with the P-Code and then`\nfollowed by the `RTMI structure which starts at offset` `0x3e4 . We then patch in the`\naddress of our manually filled out object Info into the `RTMI.pObjTable field. Once this is`\ncomplete, the P-Code is ready for execution.\n\n### Code Generation\n\nWhen developing a method such as this, we must start with known quantities. For our\npurposes we are writing our own test code which is done normally in the VB6 Integrated\nDevelopment Environment. This code is then extracted using a utility which generates the C\nor VB6 source necessary to execute it independently.\n\nThe generator tool we are using in this paper is the free `VBDec` [8] P-Code debugger.\n\nWhile exploring this technique, the sample code has been optimized to follow several\nconventions for clarity. For this research all code samples were ripped from functions in a\nsingle module. This design was chosen so that all sub function access occurs through the\n```\nImpAdCall * opcodes which draw directly against function pointers in the const pool.\n\n```\nCode taken from instanced form or class compilation units would require support to\nreplicate `VTable layouts for the` `*Vcall opcodes. While this can be done I will leave that`\nas future work for now.\n\nSamples are available that make extensive use of callbacks to integrate tightly with the host\ncode. This is useful for integrating debug output through the C host in a simple manner.\n\nCallbacks are accessed through the standard VB API `Declare syntax which is a core part`\nof the language and is well documented. Below are examples of sending both numeric and\nstring debug info from the P-Code to the host.\n\n\n-----\n\nGiving VB direct access to the host functions, is as simple as setting their address in the\ncorresponding constant pool slot.\n\nRipping functions with `VBDec is simple. Simply right click on the function in the left hand`\n```\ntreeview and choose the Rip menu option. VBDec will generate all of the embedding\n\n```\ndata for you. Multiple functions can be ripped at once by right clicking on the top level\nmodule name.\n\nA corresponding const pool will also be auto-generated along with stubs to update the\nobject Info pointers and `asm stubs to call interlinked sub functions.`\n\nOnce extraction/generation is complete it is left up to the developer to integrate the data into\none of the sample frameworks provided.\n\nA spectrum of samples are provided ranging from very simple, to quite complex. Samples\ninclude:\n\n\n-----\n\nSample Description\n\n`firstTest` simple addition test\n\n`globalVar` global variables test\n\n`structs` passing structs from C to P-Ccode\n\n`two_funcs` interlink two P-Code functions\n\n`ConstPool` test decoding a binary const pool entry\n\n`lateBinding` late bind sapi voice example\n\n`earlyBinding` early bind sapi voice example\n\n`decrypt_test` P-Code decryptor w/ complex prototype\n\n`Variant Data` C host returns variant types from callback to P-Code.\n\n`benchmark` RC4 benchmarking apps in C/P-Code code and straight C\n\n### Understanding the Const Pool\n\nEach compilation unit such as a module, class, form etc gets its own constant pool which is\nshared for all of the functions in that file. Pool entries are built up on demand as the file is\nprocessed by the compiler from top to bottom.\n\nThe constant pool can contain several types of entries such as:\n\nstring values ( BSTRs specifically)\nVB method native call stubs\nAPI import native call stubs\n```\n   COM GUIDs\n   COM CLSID / IID pairs held in COMDEF structures\n   CodeObject base offsets (not applicable to our work here)\n\n```\ninternal runtime `COM objects filled out at startup (not supported)`\n```\nVBDec is capable of automatically deciphering these entries and figuring out what they\n\n```\nrepresent. Once the correct type has been determined, it can generate the C or VB source\nnecessary to fill out the const pool in the host code. The constant pool viewer form allows\nyou to manually view these entries.\n\n\n-----\n\nIn testing it has been performing extremely well outputting complete const pools which\nrequire little to no modification.\n\nFor callback integration with the host, if you use `“dummy” as the dll name, it will`\nautomatically be assumed as a host callback. Otherwise it will be translated literally as a\n```\nLoadLibrary/GetProcAddress call.\n\n```\nSome const pool entries may show up as Unknown. When you click on a specific entry the\nraw data at that offset will be loaded into the lower textbox. If this data shows all `00 00 00`\n```\n00’s then this is a reference to an internal VB runtime COM object that would normally be\n\n```\nset to a live instance at initialization.\n\nThis has been seen when using the `App Object. Normally this would be set` `@6601802F`\ninside `_TipRegAppObject function of the runtime on initialization. These types of entries`\nare not currently supported using this technique (and would not make sense in our context\nanyways.)\n\nInterlinked sub functions are supported. A corresponding native stub will be generated\nalong with an entry in the const pool for it.\n\nEarly binding and late binding to `COM objects is also supported. Late binding is done`\nentirely through strings in the const pool. For early binding you will seen a `COMDEF`\nstructure and `CLSID / IID data automatically generated.`\n\nThe following is taken from the early binding sample which loads the `Sapi.SpVoice` `COM`\nobject.\n\n\n-----\n\nGeneration of this code is generally automatic by `VBDec but there may be times where the`\ntool can not automatically detect which kind of const pool entry is being specified. In these\ncases you may have to manually explore the const pool and extract the data yourself.\n\nIn the above scenario the file data at the const pool address may look similar to the\nfollowing:\n\nIf we visualize this as a `COMDEF structure we can see the values` `0, 0x401230,`\n```\n0x401240, 0 . Looking at the file offsets for these virtual addresses we find the GUIDs\n\n```\ngiven above.\n\nString entries are held as `BSTRs, which is a length prefixed unicode string. Since we are in`\ncomplete control of the const pool, and `BSTRs can encapsulate binary data. It is possible`\nto include encrypted strings directly in the const pool using `SysAllocStringByteLen . The`\n```\nbinary_ConstPool * samples demonstrate this technique. You can also dynamically swap\n\n```\nout const pool entries to change functionality as the P-Code runs. An example of this is\nfound in the early bind sample\n\n\n-----\n\n**Note: It is important to use the** `SysAlloc` string functions to get real `BSTR s for const`\npool entries. As the strings get used by the runtime, it may try to realloc or release them.\n\n### Extended TLS Initialization\n\nThe VB6 runtime stores several key structures in `Thread Local Storage (TLS) . Several`\nfunctions of the runtime require these structures to be initialized. These structures are\ncritical for VB error handling routines and can also come into play for file access functions.\n\nBelow is the code for the `rtcGetErl export. This function retrieves the user specified`\nerror line number associated with the last exception that occurred.\n\nFrom this snippet of code we can see that the runtime stores the `TLS slot value at offset`\n```\n66110000 . Once the actual memory address is retrieved with TlsGetValue The\n\n```\nstructure field `0x98 is then returned as the stored last error line number. In this manner we`\ncan begin to understand the meaning of the various structure offsets.\n\nEven without a full analysis of the complete `0xA8 byte structure we can compare the`\nvalues seen between a fully initialized process with those initialized through the\n```\nCreateIExprSrvObj export.\n\n```\nOnce diffed 2 main empty slots are observed which normally point to other allocations.\n\nfield `0x18 – normally set` `@ 66015B25 in` `EbSetContextWorkerThread`\nfield `0x48 – normally set` `@ 66018081 in` `RegAppObjectOfProject`\n\nField `0x48 is used for access to the internal VB App.` `COM object. This object does not`\nmake sense to use in our scenario and does not trigger any exceptions if left blank. If we\nhad to replicate the `COM object for compatibility with existing code we could however insert`\na dummy object.\n\nThe allocation at offset `0x18 is only required if we wish to use built in VB file operation`\ncommands or the `MsgBox function.`\n\nIf demanded for compatibility with ripped code, It was interesting to see if a manual\nallocation would allow the runtime to operate properly.\n\nThe following code was created to dynamically lookup the `TLS slot value, retrieve the`\n```\ntlsEbthread memory offset and then manually link in a new allocation to the missing\n\n```\n\n-----\n\nOnce the above code was integrated full access was restored to the native VB file access\nfunctions. Again this extended initialization is not always required.\n\n### Debugging integration’s\n\nWhen testing this technique it is best to start with your own code that you control. This way\nyou can get familiar with it and develop a feel for working with (and recognizing) the\ndifferent function prototypes.\n\nThe first step is to write and debug your VB6 code as normal in the VB6 IDE. In preparation\nfor running as a byte buffer, you can then pepper the VB code with progress callbacks to\nAPI Declare routines which normally access C dll exports.. You don’t actually have to write\nthe dll, but you can. The calls are identical when hosted internally from a native C loader (or\neven a VB hosted Addressof callback routine).\n\n\n-----\n\nIf you are calling into a P-Code function with a specific prototype, this is the trickiest part of\nthe integration. Samples are available which pass in `int,` `structures,` `references,`\n```\nVariants, bools and byte arrays . You will have to be very aware if arguments are\n\n```\nbeing passed in `ByVal, or the default` `ByRef (pointers).`\n\nAlso pay attention to the function return types. If no argument/return type is defined, it\ndefaults to a `COM Variant. VB functions receive variant return values by pushing an extra`\nempty one onto the stack before calling the function. Simple numeric return values are\npassed back in `EAX as normal.`\n\nWhen interacting with callbacks make sure the callbacks are defined as `__stdcall . All of`\nthe standard VB6 <–> C development knowledge applies. You can cut your teeth on these\nrules by working with standard C dlls and debugging in Visual Studio from the dll side while\nlaunching a VB6 exe host.\n\nWhen in doubt you can create simple tests to debug just the function prototypes. For the\ncomplex prototype decryptor sample given above, I had the VB6 `sub main() code call`\nthe `rc4 function with expected parameters to test it in its natural environment. I could then`\ndebug the VB6 executable to watch the exact stack parameters passed to develop more\ninsight into how to replicate it manually from my C loader.\n\nThis can be done with a native debugger by setting a breakpoint `@6610664E on the`\n```\nImpAdCallFPR4 handler in the VB runtime. Here you could examine the stack before entry\n\n```\ninto the target P-Code function. VBDec’s P-Code debugger is also convenient for this task.\n\nWhen debugging it is best to have the reference copy of the VB runtime in the same\ndirectory as the target executable so that all of your offsets line up with your runtime\ndisassembly with debug symbols. If you use `IDA as your debugger, start with the`\ndisassembly of the VB runtime and set the target executable in the debugger options. Asm\nfocused debuggers such as `Olly or` `x64dbg are highly recommended over Visual Studio`\nwhich is primarily based around source code debugging.\n\n## Conclusion:\n\nWhen working on malware analysis it is a common task to have to interoperate with various\ntypes of custom decoding routines. There are multiple approaches to this. One can sit down\nand reverse engineer the entire routine and make sure your code is 100% compatible, or\nyou can try to explore rip based techniques.\n\nRipping decoders is a fairly common task in my personal playbook. While researching the\ninternals of the VB runtime it was a natural inquiry for me to see if the same concept could\nbe applied to P-Code functions.\n\n\n-----\n\nWith some experimentation, and a suitable generator, this technique has proven stable and\nrelatively easy to implement. These experiments have also deepened my insights into how\nthe various structures are used by the runtime and my appreciation for how tightly VB6 can\nintegrate with C code.\n\nHopefully this information will give you a new arrow to add to your quiver, or at least have\nbeen an interesting ride.\n\n[1] [Emit based rip](http://sandsprite.com/blogs/index.php?uid=7&pid=403)\n\n[2] [Using an exe as a dll](http://sandsprite.com/CodeStuff/Using_an_exe_as_a_dll.html)\n\n[3] [Running byte blobs in scdbg](http://sandsprite.com/blogs/index.php?uid=7&pid=177)\n\n[4] [Malware IPC decoder service](http://sandsprite.com/blogs/index.php?uid=7&pid=366)\n\n[5] [Code samples](https://github.com/avast/ioc/tree/master/VB-Research)\n\n[6] [VB6 runtime with symbols](http://sandsprite.com/vb-reversing/files/msvbvm60.zip)\n\n[7] [VB6 internals video](http://sandsprite.com/blogs/index.php?uid=7&pid=485)\n\n[8] [VBDec P-Code Debugger](http://sandsprite.com/vbdec/)\n\n[Tagged asP-Code,](https://decoded.avast.io/tag/p-code/) [Research,](https://decoded.avast.io/tag/research/) [series,](https://decoded.avast.io/tag/series/) [VB](https://decoded.avast.io/tag/vb/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-05-19 - Binary Reuse of VB6 P-Code Functions.pdf"
    ],
    "report_names": [
        "2021-05-19 - Binary Reuse of VB6 P-Code Functions.pdf"
    ],
    "threat_actors": [
        {
            "id": "75108fc1-7f6a-450e-b024-10284f3f62bb",
            "created_at": "2024-11-01T02:00:52.756877Z",
            "updated_at": "2025-03-27T02:00:55.544216Z",
            "deleted_at": null,
            "main_name": "Play",
            "aliases": null,
            "source_name": "MITRE:Play",
            "tools": [
                "Nltest",
                "AdFind",
                "PsExec",
                "Wevtutil",
                "Cobalt Strike",
                "Playcrypt",
                "Mimikatz"
            ],
            "source_id": "MITRE",
            "reports": null
        }
    ],
    "ts_created_at": 1673536204,
    "ts_updated_at": 1743041785,
    "ts_creation_date": 1653821304,
    "ts_modification_date": 1653821304,
    "files": {
        "pdf": "https://archive.orkl.eu/708a3cf8f8f80835dd08c95ab4b1898faf89244c.pdf",
        "text": "https://archive.orkl.eu/708a3cf8f8f80835dd08c95ab4b1898faf89244c.txt",
        "img": "https://archive.orkl.eu/708a3cf8f8f80835dd08c95ab4b1898faf89244c.jpg"
    }
}