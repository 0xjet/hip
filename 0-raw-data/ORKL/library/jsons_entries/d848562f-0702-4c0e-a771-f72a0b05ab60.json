{
    "id": "d848562f-0702-4c0e-a771-f72a0b05ab60",
    "created_at": "2023-02-11T02:08:27.558982Z",
    "updated_at": "2025-03-27T02:05:51.788477Z",
    "deleted_at": null,
    "sha1_hash": "aaa6dcdd891d74567c325365ed70d11d269da8e9",
    "title": "2023-02-10 - Forensic Log-Based Detection of Keystroke Injection BadUSB Attacks",
    "authors": "",
    "file_creation_date": "2023-02-10T01:16:43Z",
    "file_modification_date": "2023-02-10T01:16:43Z",
    "file_size": 2388864,
    "plain_text": "## Forensic Log-Based Detection for Keystroke Injection BadUSB Attacks\n\n#### immediate\n\n\n#### February 10, 2023\n\n\nGeorgios Karantzas, BSc Student, Department of Informatics, University of\nPiraeus, Greece\n\n**Abstract**\n\n\nThis document describes an experiment with main purpose to detect\nBadUSB attacks that utilize external HID (Human Interaction Device)\n”gadgets” to inject keystrokes and acquire remote code execution. One of\nthe main goals, is to detect such activity based on behavioral factors and\nallow everyone with a basic set of cognitive capabilities,regardless of the\nuser being a human or a computer, to identify anomalous speed related\nindicators but also correlate such speed changes with other elements such\nas commonly malicious processes like ”powershell” processes being called\nin close proximity timing-wise, PnP device events occurring,and long keyboard ”sleeps” along with ”Lock Key” abuse correlated with driver images\nloaded.\n\n### 1 Introduction\n\n\nFor our detection purposes, we need to consume events that will be coming\ndirectly from low level components of the Windows OS. We decided to take\ninto consideration older publications such as abuse of USB2 and USB3 ETW\nproviders and leverage such a provider as a ”keylogger” (Microsoft-Windows_USB-USBPORT and Microsoft-Windows-USB-UCX ). Due to technical repro-_\nduction issues, however, and due to the facts that logging to a file would be\nsynchronous and direct but also after seeing that some amount of customization would be needed capture-wise, we decided to utilize upper filters for one\nof the main parts of the proof-of-concept implementation. Those keyboard captures should be accompanied by a timestamp to give us an idea of how far they\nare from each other and whether the keystroke ratio represents a human user.\nThe second part, can easily be accomplished via ETW barring its asynchronicity, buffer-based system limitations such as flushing logs all together along with\nmixing of events, that will not cause any issue for us as long as timestamps\nand data are not corrupt. A final note to keep in mind with such encounters is\n\n1\n\n\n-----\n\nthat privacy of the data need to be taken seriously, in our case we only need to\nknow if the key was pressed and if it was a ”Lock” key, if it wasn’t it shouldn’t\nbe transmited through file writes or ETW from the driver to usermode.A past\nexample to avoid was HP Synaptics keylogger distribution. Finally, cognitive\ncapabilities will be needed given the product of the POC will be log-related and\nthrough looking at it as a timeline, one will understand the anomalies between\na human typing normally speed-wise and a device typing abnormally fast and\nlaunching potentially malicious processes and components.\n\n### 2 Malicious BadUSB Attacks Today\n\nThe most well-known BadUSB attack vector is probably the commercial ”RuberDucky” which initially started as a sysadmin gadget to automate mundane\ntasks. This platform evolved into the most notorious attacker gadget with a series of community-backed payloads whose main capabilities include dual usage as\na USB Stick, data exfiltration, HID Interaction (Keystroke Injection) and even\nits own scripting language, DuckyScript. This is backed by a USB2.0 hardware\ninterface and support for USB-c. Some of the most advanced features include,\ncopying payload to itself, ”OUT endpoint” usage via ”Lock Keys” ”spamming”,\nKeystroke Reflection and even features like VendorID and ProductID spoofing.\nFor the purposes of this experiment, our ”go-to” tool is going to be the RubberDucky’s latest version as of this writing and various payloads will be employed\nacross all our experiments but mainly, one launching powershell to dump credential files. In most of the real-life cases powershell or other LoLBins will be\nused to run code and files will be dropped and executed. We should keep in\nmind the evasion features as they may avoid ”hardcoded” detections but also\nin the case of sleeps, abnormally alter the keystroke timeline and introduce a\ncognitive anomaly.\n\n### 3 Event Tracing for Windows and its Drawbacks\n\nAs discussed previously, one of our main source of information will be ETW.\nInitially introduced as a debugging feature, ETW gained a lot of attention due to\nthe facts that it was easily usable, had a large amount of default and 3-rd party\nproviders, Microsoft Introduced Patch-Guard-compliant Kernel API hooks with\nit and in general could provide easily vast amounts of telemetry from usermode\nand kernelmode providers. Although it may sound tempting, this mechanism\nis simply not a silver bullet for all kinds of detections and telemetry ingestion.\nBelow you can find a table of the drawbacks and positive aspects of ETW.\n\n2\n\n\n-----\n\n|Pros|Cons|\n|---|---|\n|Vast Amount Of Telemetry Flavors|Buffer Based|\n|API Monitoring|Buffers May Flood and Degrade Consumption|\n|Pre-structured Network Monitoring|Asynchronous|\n|Easy to Deploy and Consume|Events May and Will be Missed by Design|\n|Callstacks Provided|Timing Attacks|\n|-|Out of Order Events|\n|-|Performance Overhead|\n\n\nTo further elaborate, we should consider a hypothetical example of what\nis ”bad” usage of the mechanism. Supposing we would like to monitor local\nmemory modifications such as allocation and re-protections and even scanning\nmemory for possibly malicious patterns and PIC (position independent code),\nbelow are a few empirical consequences faced when dealing with real-life production that can reduce effectiveness and make one’s life more difficult. We\nshould keep in mind that for such an experiment ETWTI is used.\n\n  - Reading from a process that exited and its PID (Process Identified) was\nre-issued as the event came ”late”.\n\n  - Attempting to find a module in-memory that is not already loaded or was\nremoved during a short timeframe, excluding NTDLL which is a standardized case due to both its nature of existing always and Known DLLs\nbehavior in terms of position. This whole situation may cause access violations given the unstable and non-synchronous way loaded modules are\nkept track of.\n\n  - Performance impact and overwhelming produced load of data to be analyzed given APIs monitored may be used by the Windows loader and\ncause massive overhead and difficulties.\n\n  - Applications that reside inside the main application such as additional\nplugins and anti-exploit agents may increase overhead even more.\n\nSumming up the purposes of the mechanism, one should think twice before\nselecting ETW for its task by considering whether timely fashion of the event\nprocessing is of critical importance to them. Regarding the practical implementation, in order to avoid needless development overhead and also avoid APIs\nlike ”Tdh*” etc., we will reside to using ”KrabsEtw”, which provides a slick\nOOP wrapper around ETW libraries and allows for easy consumption of events\nform various providers, including the trace sessions of the ”Kernel Logger” and\nalso parsing them effectively along with special properties that may need to be\npassed such as obtaining stacks.\n\n3\n\n\n-----\n\n### 4 Upper Filters for Keyboards\n\nKeyboard keyloggers are a very classical example of introductory projects in kernel development. The are various paths one could follow to achieve the results\nwanted. Quite interestingly we started from a specific approach and transitioned\nto another more intricate one to achieve higher kevels of functionality, stability\nand effectiveness. The initial approach was setting an upper filter device and\na completion routine that will intercept and log keyboard ”MakeCodes” from\n”PKEYBOARD INPUT DATA” structure pointers. The code will hook also\non some other IRP Dispatch routines to ensure overall proper functionality. We\nshould note that the code is non-PnP so far and target to filter kbdclass, the\nclass driver under which all kinds of port-mini-port driver pairs exist for keyboards, regardless of their type (PS\n2, USB etc). Also, a bit of waiting will happen during the unload routine to ensure all IRPs were processed. However, for both of the driver cases, unloads are\nvery basic and don’t support PnP which may and will result to inconsistencies.\nSetting of the interception completion routine happens by the ”IoSetCompletionRoutine” call inside the Dispatch Routine for IRP MJ READ. In general,\nsuch a non-PnP aware filter driver may result in various issues, therefore, an alternative was chosen. This alternative included utilizing a KMDF driver inside\nwhich ”listens” to the PnP manager for new devices. It is worth noting that\none should register this filter as an ”UpperFilter” above ”kbdclass” inside the\nregistry under the appropriate GUID. What you will see in the code below is\nthe code setting the main hooking routine, after the appropriate callbacks and\ndata were setup and upon calling WDF DRIVER CONFIG INIT to listen for\ndevices, WDF OBJECT ATTRIBUTES initializer and even after having set the\nWDF Driver device. In the code below, we create a device with our extension\ndata.\n```\n    WdfFdoInitSetFilter(DeviceInit);\n    WdfDeviceInitSetDeviceType(DeviceInit, FILE_DEVICE_KEYBOARD);\n    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&wdfAttrib,\n      USB_TROLL_EXTENSION);\n    status = WdfDeviceCreate(&DeviceInit, &wdfAttrib,\n      &hControlDevice);\n    if (!NT_SUCCESS(status))\n    {\n      __leave;\n    }\n    WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&ioQueueConfig,\n      WdfIoQueueDispatchParallel);\n    ioQueueConfig.EvtIoInternalDeviceControl =\n      CbEvtIoInternalDeviceControl;\n\n```\n4\n\n\n-----\n\n```\n    status = WdfIoQueueCreate(hControlDevice,\n      &ioQueueConfig,\n      WDF_NO_OBJECT_ATTRIBUTES,\n      WDF_NO_HANDLE\n    );\n\n```\nTo simply put what will follow, when a new device is added, we will intercept\nit and attach ourselves as a filter, then using a modified WDF IO QUEUE CONFIG\nstructure with our own set PFN WDF IO QUEUE IO INTERNAL DEVICE CONTROL\nand by creating an I\nO queue through WdfIoQueueCreate, we essentially get a foothold so we can\nuse ”WdfRequestRetrieveInputBuffer” and maybe appropriate driver contexts\nand finally hook onto CONNECT DATA’s ClassService routine with ”ServiceCallbackDummy”. A function driver calls the class service callback in its ISR\ndispatch completion routine. The class service callback transfers input data\nfrom the input data buffer of a device to the class data queue. These conditions make it a prime hooking target. You can see below the code responsible\nfor placing the hooking routines themselves. More specifically, we change the\ndevice and service callback to our own.\n```\n_Function_class_(EVT_WDF_IO_QUEUE_IO_INTERNAL_DEVICE_CONTROL)\n_IRQL_requires_same_\n_IRQL_requires_max_(DISPATCH_LEVEL)\nVOID\nCbEvtIoInternalDeviceControl(\n  _In_ WDFQUEUE Queue,\n  _In_ WDFREQUEST Request,\n  _In_ size_t OutputBufferLength,\n  _In_ size_t InputBufferLength,\n  _In_ ULONG IoControlCode\n)\n{\n  BOOLEAN bRetSuccess = TRUE;\n  WDF_REQUEST_SEND_OPTIONS options;\n  WDFDEVICE hDevice;\n  NTSTATUS status = STATUS_UNSUCCESSFUL;\n  CUSTOM_EXTENSION pData = NULL;\n  PCONNECT_DATA connectData = NULL;\n  size_t length;\n  UNREFERENCED_PARAMETER(OutputBufferLength);\n  UNREFERENCED_PARAMETER(InputBufferLength);\n  UNREFERENCED_PARAMETER(Request);\n  hDevice = WdfIoQueueGetDevice(Queue);\n  pData = GetData(hDevice);\n  switch (IoControlCode)\n\n```\n5\n\n\n-----\n\n```\n  {\n  case IOCTL_INTERNAL_KEYBOARD_CONNECT:\n    if (pData->UpperConnectData.ClassService != NULL)\n    {\n      status = STATUS_SHARING_VIOLATION;\n      break;\n    }\n    status = WdfRequestRetrieveInputBuffer(Request,\n      sizeof(CONNECT_DATA),\n      &connectData,\n      &length);\n    if (!NT_SUCCESS(status)) {\n      break;\n    }\n    NT_ASSERT(length == InputBufferLength);\n    pData->UpperConnectData = *connectData;\n    connectData->ClassDeviceObject =\n      WdfDeviceWdmGetDeviceObject(hDevice);\n    connectData->ClassService = ServiceCallbackDummy;\n    break;\n  case IOCTL_INTERNAL_KEYBOARD_DISCONNECT:\n    break;\n  default:\n    break;\n  }\n  WDF_REQUEST_SEND_OPTIONS_INIT(&options,\n    WDF_REQUEST_SEND_OPTION_SEND_AND_FORGET);\n  bRetSuccess = WdfRequestSend(Request, WdfDeviceGetIoTarget(hDevice),\n    &options);\n  if (!bRetSuccess )\n  {\n    status = WdfRequestGetStatus(Request);\n    WdfRequestComplete(Request, status);\n  }\n  return;\n}\n\n```\nBelow you can find the relevant callback we spoofed previously so we can\nlog keystrokes via the ”MakeCode” intercepted through the buffer that was\nbeing passed through the stack. The concept behind the code is forwarding to\nthe next driver after we have en-queued a ”SafeLog” routine, that will take all\n\n6\n\n\n-----\n\nprecautions needed to log to our file the keyboard code safely in a multi-threaded\nenvironment.\n```\nVOID\nDummyServiceCallback(\n  _In_ PDEVICE_OBJECT DeviceObject,\n  _In_ PKEYBOARD_INPUT_DATA InputDataStart,\n  _In_ PKEYBOARD_INPUT_DATA InputDataEnd,\n  _Inout_ PULONG InputDataConsumed\n)\n{\n  CUSTOM_EXTENSION pData;\n  WDFDEVICE hDevice;\n  PKEYBOARD_INPUT_DATA pInputData;\n  hDevice = WdfWdmDeviceGetWdfDeviceHandle(DeviceObject);\n  pUData = CustomGetData(hDevice);\n  for (pInputData = InputDataStart; pInputData != InputDataEnd;\n    pInputData++)\n  {\n    TpkEnqueueWorkItem(&gDrv.ThreadPool,\n      SafeLog,\n      SafeLog,\n      (PVOID)pInputData->MakeCode);\n  }\n  (*(PSERVICE_CALLBACK_ROUTINE)(ULONG_PTR)pData->UpperConnectData.ClassService)(\n    pData->UpperConnectData.ClassDeviceObject,\n    InputDataStart,\n    InputDataEnd,\n    InputDataConsumed);\n}\n\n```\nTo sum up, this stealthier, lesser common and possibly more ”hacky” hooking\napproach was employed to increase the chances of the keyboard monitoring\ndriver of being more ”universal” and ”stable” accross all kind of Windows OS\nwhether on a Virtual Machine or a physical machine, unlike the predecessor.\n\n### 5 Microsoft-Windows-Kernel-Process and Its Use\n\nWe decided to utilize the aforementioned ETW provider to collect information\nabout Image Loads (incl. Drivers) and Process Creation events. We limited\nourselves to only these event categories. Below you can find some example code\nof adjusting and enabling providers on a certain trace session which will act as\na glue between the consumer and the provider.\n\n7\n\n\n-----\n\n```\nLoggerSession::LoggerSession(\n _In_ krabs::c_provider_callback CbHandler,\n _In_ bool EnableProcess) :\n BadUsbTrace(L\"BadUsbTrace\"),\n PrcProvider(L\"Microsoft-Windows-Kernel-Process\")\n{\n EnableProc = EnableProcess;\n if (EnableProc)\n {\n   PrcProvider.any(0x50);\n   PrcProvider.add_on_event_callback(CbHandler);\n   BadUsbTrace.enable(PrcProvider);\n }\n}\n\n```\nWe are interested into writing easily parse-able logs that will include timestamps, names of images and process IDs when applicable. We utilize KrabsETW’s parsing capabilities and created a callback handler to assist us with the\nprocess of creating logs. The code below could serve as a simplistic example\nof how we chose to handle the event data. The ”FileLog” class will create and\nsynchronously lock the file where we will output our logs as well as handle the\ntext processing. We use KrabsEtw’s default parser code to ”excavate” event\ndata we need and assign them to variables with proper initial values. We finally\ndecide to work with a ”std::wstring” and write our log from a C-string format.\n```\nvoid ProcHandler::CbProcHandler(\n _In_ const EVENT_RECORD& Record,\n _In_ const krabs::trace_context& TraceContext)\n{\n krabs::schema ProcSchema(Record, TraceContext.schema_locator);\n krabs::parser ProcParser(ProcSchema);\n const wchar_t* taskProcCreate = L\"ProcessStart\";\n const wchar_t* taskProcLoadImg = L\"ImageLoad\";\n FileLogger FileLog(L\"imagesprocs.txt\");\n if (wcscmp(ProcSchema.task_name(), taskProcCreate) == 0)\n {\n   uint32_t procId = 0;\n   ProcParser.try_parse(L\"ProcessID\", procId);\n   if (!procId)\n   {\n    return;\n   }\n   FILETIME createTime = { 0 };\n\n```\n8\n\n\n-----\n\n```\n   ProcParser.try_parse(L\"CreateTime\", createTime);\n   LARGE_INTEGER createTimeLInt = { 0 };\n   createTimeLInt.HighPart = createTime.dwHighDateTime;\n   createTimeLInt.LowPart = createTime.dwLowDateTime;\n   if (!createTimeLInt.QuadPart)\n   {\n    return;\n   }\n   std::wstring imageName = { 0 };\n   ProcParser.try_parse(L\"ImageName\", imageName);\n   if (!imageName.size())\n   {\n    return;\n   }\n   std::wstring timeStamp = std::to_wstring(createTimeLInt.QuadPart);\n   std::wstring procIdWstr = std::to_wstring(procId);\n   std::wstring logStr = L\"ProcessLog:\" + timeStamp + L\":\" +\n     procIdWstr + L\":\" + imageName + L\":EndProcessLog\\n\";\n   FileLog.LogToFile(logStr.c_str());\n }\n\n```\nBased on how we architected this initial provider, we decided to extend\nthe architecture but maintain the same backbone with additional providers or\nfeatures we may wanna add. An example graph of the architecture is provided\nbelow. Essentially, our ”ETW Logger Manager Class” sets the appropriate\ncallbacks and event limitations that will handle data and lo them appropriately\nusing the ”File Logger Class”.\n\n9\n\n\n-----\n\nFinally, we shall provide some raw output from the tool to give the reader an\nidea of what to expect. The ”ImageLog” entries represent the output received\nwhen a Razer mouse was attached and the ”ProcessLog” entries represent random process executions as an example.\n```\nImageLog:2968525321:\\Device\\HarddiskVolume3\\Windows\\System32\\drivers\\hidusb.sys:EndImageLog\nImageLog:1597723157:\\Device\\HarddiskVolume3\\Windows\\System32\\drivers\\RzDev_0084.sys:EndImageLog\nImageLog:1659522856:\\Device\\HarddiskVolume3\\Windows\\System32\\drivers\\RzCommon.sys:EndImageLog\n\n```\n10\n\n\n-----\n\n```\nProcessLog:133197924344035078:8884:\\Device\\HarddiskVolume3\\Windows\\\nSystem32\\dllhost.exe:EndProcessLog\nProcessLog:133197924344358867:17944:\\Device\\HarddiskVolume3\\Windows\\\nSystem32\\Taskmgr.exe:EndProcessLog\nProcessLog:133197924344422757:15076:\\Device\\HarddiskVolume3\\Windows\\\nSystem32\\consent.exe:EndProcessLog\nProcessLog:133197924344814263:11828:\\Device\\HarddiskVolume3\\Windows\\\nSystem32\\Taskmgr.exe:EndProcessLog\nProcessLog:133197924349657313:16168:\\Device\\HarddiskVolume3\\Program\n  Files\\Rivet Networks\\SmartByte\\RAPS.exe:EndProcessLog\nProcessLog:133197924364657393:13608:\\Device\\HarddiskVolume3\\Windows\\\nSystem32\\cmd.exe:EndProcessLog\nProcessLog:133197924364676889:15436:\\Device\\HarddiskVolume3\\Windows\\\nSystem32\\conhost.exe:EndProcessLog\n\n### 6 Microsoft-Windows-Kernel-PnP and Its Use\n\n```\nThe aforementioned provider, contains various events related to the PnP system\nand will allow us to have some extra information, or visibility if you will. Output\nby itself may not be self-explanatory and even chaotic at a mass scale, but its\nfinal goal is to be used in conjunction with other metrics in a log correlation\nprocess where its value will increase. Below you can see a part from a generic\nlog produced by the attachment of a Razer mouse, this will provide the reader\nwith an idea of what to expect as output.\n```\nPnpLog:USB\\VID_1532&PID_0084\\5&1c5b639f&0&2:133197915652312694:EndPnpLog\nPnpLog:USB\\VID_1532&PID_0084&MI_00\\6&34f4fee0&0&0000:133197915652451881:EndPnpLog\nPnpLog:USB\\VID_1532&PID_0084&MI_01\\6&34f4fee0&0&0001:133197915652492370:EndPnpLog\nPnpLog:USB\\VID_1532&PID_0084&MI_02\\6&34f4fee0&0&0002:133197915652554801:EndPnpLog\nPnpLog:USB\\VID_1532&PID_0084&MI_03\\6&34f4fee0&0&0003:133197915652586085:EndPnpLog\nPnpLog:HID\\VID_1532&PID_0084&MI_00\\7&f76681d&0&0000:133197915652597149:EndPnpLog\nPnpLog:HID\\VID_1532&PID_0084&MI_00\\7&f76681d&0&0000:133197915652597324:EndPnpLog\nPnpLog:HID\\VID_1532&PID_0084&MI_01&Col01\\7&334da5df&0&0000:133197915652599115:EndPnpLog\nPnpLog:HID\\VID_1532&PID_0084&MI_01&Col01\\7&334da5df&0&0000:133197915652599264:EndPnpLog\nPnpLog:HID\\VID_1532&PID_0084&MI_01&Col02\\7&334da5df&0&0001:133197915652600646:EndPnpLog\nPnpLog:HID\\VID_1532&PID_0084&MI_01&Col03\\7&334da5df&0&0002:133197915652605277:EndPnpLog\n\n```\n11\n\n\n-----\n\n```\nPnpLog:HID\\VID_1532&PID_0084&MI_01&Col04\\7&334da5df&0&0003:133197915652609096:EndPnpLog\nPnpLog:HID\\VID_1532&PID_0084&MI_01&Col05\\7&334da5df&0&0004:133197915652613813:EndPnpLog\nPnpLog:RZVIRTUAL\\VID_1532&PID_0084&MI_00&Col03\\7&334da5df&0&01:133197915652618792:EndPnpLog\nPnpLog:HID\\VID_1532&PID_0084&MI_02\\7&1b8a199a&0&0000:133197915652629790:EndPnpLog\nPnpLog:HID\\VID_1532&PID_0084&MI_02\\7&1b8a199a&0&0000:133197915652629984:EndPnpLog\nPnpLog:HID\\VID_1532&PID_0084&MI_03\\7&3c68d55&0&0000:133197915652633449:EndPnpLog\nPnpLog:RZCONTROL\\VID_1532&PID_0084&MI_00\\8&e070abb&0:133197915652692960:EndPnpLog\nPnpLog:RZCONTROL\\VID_1532&PID_0084&MI_00\\8&e070abb&0:133197915652692976:EndPnpLog\nPnpLog:HID\\VID_1532&PID_0084&MI_00&Col03\\8&16f5acbd&0&0000:133197915652697204:EndPnpLog\n\n```\nThere is no further need to provide code as the architecture was already\ndiscussed.\n\n### 7 Forensically Detecting the ”Rubber Ducky”\n\nFor our scenario, we utilized a publicly available ”Ruber Ducky” script that\nwould dump credentials and exfiltrate them right after.\nAs in every forensic analysis, we would need some indicators allowing us to\ninitial identify footprints that will lead to a correlation complex unraveling the\nattack’s steps. To start such a procedure, we will need to first have a full view\nof the raw data we can dig through. So far we have the following sets of data:\n\n  - Timestamp-infused logs of keyboard usage.\n\n  - Timestamp-infused logs of spawned processes.\n\n  - Timestamp-infused logs of drivers loaded.\n\n  - Timestamp-infused logs of PnP devices loaded.\n\nIn some cases, we could try directly finding continuous ”lock key” presses\nacross the log file. In our case, such an attack is out-of-scope, therefore we will\nattempt following a methodologically diferent procedure. Investigating the final\ntwo seemed like a more friendly approach towards human investigators. We will\nwant to note the fact that close to the loading of hidusb.sys the HID-related\ndrivers we can identify both powershell.exe presence and a PnP device named\n**”ATMEL”.**\nThe later device, can be easily linked with the malicious gadget as the brand’s\nname is visible on the chips.\n\n12\n\n\n-----\n\nAlthough, evading ”hard-coded data”-based detections is out of scope for\nthis study, it is worth noting that ”Ruber Ducky” provides spoofing capabilities\nfor Vendor and Product IDs. Given the behavioral nature of the detection and\nnot basing our indicators on a sole kind of data, we can confidently say that\neven if such data is spoofed, we would still be able to identify forensic footprints.\nFind below the relevant raw ETW-originating logs in chronological order\nwith the timestamps from ETW converted to human-readable form:\n```\nImageLog:\\Device\\HarddiskVolume2\\Windows\\System32\\drivers\\hidusb.sys:EndImageLog\nPnpLog:USBSTOR\\Disk&Ven_ATMEL&Prod_Mass_Storage&Rev_1.00\\7&85c08e4&0&111111111111&0:\n2023-02-02 21:48:10.094 -08:00:EndPnpLog\nProcessLog:2023-02-02 21:48:17.752 -08:00:3740:\n\\Device\\HarddiskVolume2\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe:EndProcessLog\nProcessLog:2023-02-02 21:48:17.849 -08:00:5248:\n\\Device\\HarddiskVolume2\\Windows\\System32\\conhost.exe:EndProcessLog\nProcessLog:2023-02-02 21:48:18.221 -08:00:8120:\n\\Device\\HarddiskVolume2\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe:EndProcessLog\nProcessLog:2023-02-02 21:48:18.224 -08:00:4004:\n\\Device\\HarddiskVolume2\\Windows\\System32\\conhost.exe:EndProcessLog\n\n```\nBased on our timestamps, we can now search through the keystroke log\nand identify an average count to see if ”powershell” launching was followed by\nfast-typing.\nBased on a quick calculation, upon converting the time-stamps to Windows\ntime, we identified **a large amount of keys to have been pressed within a**\nspan of approximately 10 seconds from just a moment prior to spawning\n\n13\n\n\n-----\n\n”powershell”, exceeding the average human typing capabilities. We could account the keystrokes pressed even before launching the command prompt of\n”PowerShell” but even through an approximation, the point has been proven\nand malicious BadUsb activity is highly probable to have happened based on\nthis behavior only. If we regard the extra information from the device, we can\nsecure our thoughts and claim to have successfully identified a BadUsb attack\n”post-mortem”.\n\n### 8 Graphical Representation of Keystroke Peak\n\nIn order to assist us get an idea of the actual spike and embrace a more friendly\napproach towards human cognitive capabilities, we will utilize a graph to represent the keystrokes across the line of time on a ”mass scale”. Notice before the\npeak, the line of normal typing activity compared to when the ”Ruber Ducky”\nwas plugged in. The blue graph can be safely compared to the ETW logs and\nrepresents the first forensic situation we are investigating. Please bare in mind\nthat the keystroke number is an estimation and not a definitive number representing their amount.\n\n### 9 Conclusion\n\nThis approach is by far not fool-proof and can increase in difficulty as the\nmetrics increase, including the size of the logs and the attacker’s attempts to\nobscure the timeline via sleeps and other strategies. This approach could have\n\n14\n\n\n-----\n\nbeen improved possibly with extra data visualization techniques, however the\ncore would remain the same. The main idea exhibited is how someone can\nfollow a ”forensic trajectory-like” logic based on data from the system’s kernel\nand tracing providers and how those data can be obtained safely and intuitively.\n\n### 10 References\n```\nhttps://www.bitdefender.com/blog/hotforsecurity/hp-laptops-found-carrying-keylogger-in-syna\nhttps://shop.hak5.org/products/usb-rubber-ducky-textbook\nhttps://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/kbdmou/\nns-kbdmou-_connect_data\nhttps://github.com/microsoft/krabsetw/tree/master/examples/NativeExamples\nhttps://github.com/repnz/etw-providers-docs/blob/master/\nhttps://www.digital-detective.net/dcode/\nhttps://www.cyberpointllc.com/blog-posts/cp-logging-keystrokeswith-event-tracing-for-windows-etw.php\n\n```\n15\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/AV Tech/2023-02-10 - Forensic Log-Based Detection of Keystroke Injection BadUSB Attacks.pdf"
    ],
    "report_names": [
        "2023-02-10 - Forensic Log-Based Detection of Keystroke Injection BadUSB Attacks.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1676081307,
    "ts_updated_at": 1743041151,
    "ts_creation_date": 1675991803,
    "ts_modification_date": 1675991803,
    "files": {
        "pdf": "https://archive.orkl.eu/aaa6dcdd891d74567c325365ed70d11d269da8e9.pdf",
        "text": "https://archive.orkl.eu/aaa6dcdd891d74567c325365ed70d11d269da8e9.txt",
        "img": "https://archive.orkl.eu/aaa6dcdd891d74567c325365ed70d11d269da8e9.jpg"
    }
}