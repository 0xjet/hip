{
    "id": "e1d2b2fd-6b46-47f3-810a-6f8403fbfb13",
    "created_at": "2023-01-12T15:09:43.291308Z",
    "updated_at": "2025-03-27T02:05:56.756569Z",
    "deleted_at": null,
    "sha1_hash": "699988a94968cbbe2028a8192aae286fe639fbdb",
    "title": "2019-04-04 - IcedID Banking Trojan Spruces Up Injection Tactics to Add Stealth",
    "authors": "",
    "file_creation_date": "2022-05-28T19:44:28Z",
    "file_modification_date": "2022-05-28T19:44:28Z",
    "file_size": 4582268,
    "plain_text": "# IcedID Banking Trojan Spruces Up Injection Tactics to Add Stealth\n\n**[securityintelligence.com/icedid-banking-trojan-spruces-up-injection-tactics-to-add-stealth/](https://securityintelligence.com/icedid-banking-trojan-spruces-up-injection-tactics-to-add-stealth/)**\n\nApril 4, 2019\n\n[Home&nbsp/](https://securityintelligence.com/) [Malware](https://securityintelligence.com/category/x-force/malware-threat/)\nIcedID Banking Trojan Spruces Up Injection Tactics to Add Stealth\n\n[Malware April 4 2019](https://securityintelligence.com/category/x-force/malware-threat/)\n\n\n-----\n\nBy [Nir Somech co-authored by Limor Kessem 10 min read](https://securityintelligence.com/author/nir-somech/)\nIBM X-Force Research proactively researches financial cybercrime threats on an ongoing\nbasis. In recent activity, [X-Force studied some changes made to the IcedID banking Trojan](https://www.ibm.com/security/xforce)\nthat help the malware act more stealthily on infected devices.\n\nBanking Trojans and the organized crime gangs that operate them have risen in the past\ndecade to become one of the most prominent online threats affecting the financial sector and\nonline service providers at large. These highly evolving malicious programs are often\nmodular and sophisticated and, in most cases, supported by an in-house developer that\nkeeps updating code to evade security controls.\n\nIt’s not always easy to keep up with threat evolution in-house. These details about the\nupdated injection method can help security professionals manage risk to their organization\nand detect updated versions of IcedID that use this injection tactic.\n\n## No New Threads to See Here\n\nBefore we delve into the reversing of IcedID’s modified injection, let’s summarize it in a few\nwords.\n\n### Prior to the Change\n\nPrior to the recent modifications, IcedID would write its shellcode to targeted operating\nsystem (OS) processes via ZwWriteVirtualMemory. IcedID used this tactic in cases where it\nwould inject code into either OS processes or when hooking browser processes.\n\n### After the Change\n\nIcedID separated the tactics for OS process injection and browser processes. When the\nmalware injects into an OS process, it creates a process in suspend state. It then hooks the\nRtlExitUserProcess, which is very often called to terminate userland processes. IcedID’s\ndeveloper counts on legitimate processes to call on this now-infected process, which will\nmake it jump to the shellcode and run it via a seemingly legitimate flow of events that would\nnot get flagged by most controls.\n\nWhen IcedID injects to a browser process, it hooks the NtWaitForSingleObject function,\nagain by using ZwWriteVirtualMemory.\n\n## A Closer Look Under the Hood\n\nTo demonstrate how the threat works, let’s begin when the IcedID payload launches its\nexecution routine on a target device. The malware starts by creating a svchost.exe process\ninstance in suspend state and injects its shellcode into that process. After the injection,\nsvchost.exe resumes and the payload terminates itself.\n\n\n-----\n\nThe newly malicious svchost.exe process writes the payload to the %ProgramData% folder\nwith a globally unique identifier (GUID)-like folder naming convention (the GUID is a 128-bit\ninteger number used to identify resources; the term GUID is generally used by developers\nworking with Microsoft technologies). It uses [a-z] [A-Z]{0-9} and the payload, and a name\nconvention of [a-z] {8-9}.exe. The value and file name are generated differently on each\noperating system running IcedID. However, the name will be the same upon subsequent\nexecutions on the same host.\n\nThis process also creates a scheduled task so that it will run every time the system reboots\nto allow IcedID to maintain persistence on the infected device.\n\nThe malicious svchost.exe creates three additional svchost.exe subprocesses and injects its\nshellcode into each one of them. We’ll explain the injection process in further detail in the\nfollowing section.\n\n_Figure 1: Three svchost.exe instances injected with IcedID shellcode._\n\nAt this point, with four svchost.exe processes in total, these instances will remain active until\nthe device is shut down at some point. After a reboot, these processes will be tasked with\nmonitoring the OS for the launch of a browser application. The malware will then attack the\nbrowser’s process as well and inject it with shellcode.\n\n### Two Injection Methods\n\nIcedID injects its shellcode into browser processes with the goal of eventually hooking the\nprocess and allowing the malware to begin intercepting and manipulating the victim’s online\nactivity.\n\nThe malware uses API hooking to inject and execute its shellcode via different legitimate\nthreads running on the victim’s device. Let’s look at that tactic more closely:\n\nIcedID allocates memory in a target process using the NtAllocateVirtualMemory\nfunction.\nThe malware writes the shellcode into the target process without suspending that\nprocess. To do that, IcedID uses the ZwWriteVirtualMemory or NtWriteVirtualMemory\nfunctions.\nNext, it hooks a frequently called API that’s commonly used by the target process.\n\nThere are two different API hooking scenarios we observed IcedID using:\n\n1. Injecting into a web-browser via svchost.exe; and\n\n\n-----\n\n2. Injecting into svchost.exe via its parent process.\n\nThe hooked API is called by the targeted process and the shellcode is thus executed.\n\nTo wipe its traces, the shellcode fixes the patched library’s function that was used to execute\nit so that tools that detect hooks and rootkits won’t show any trails of that patch. This\ninjection technique can evade security mechanisms that would otherwise detect suspicious\nAPI calls, such as the createRemoteThread (CRT), asynchronous procedure calls (APC) and\nother common malware tactics.\n\nRemotely setting up a hook in a target process without suspending the target process first\ncan cause unexpected behavior. This can easily result in a crash since two threads can\nexecute the code of the API at the same time.\n\n### Deeper Into the Browser Process Injection\n\nThe first injection tactic is from a svchost.exe process to a web browser. To begin, the\nmalware needs a detection mechanism to identify that the infected user has launched a\nbrowser application. To do that, IcedID takes a snapshot of all the running processes and\nscans them for browser processes.\n\n_Figure 2: IcedID scanning for running browser processes._\n\nThe scan creates an infinite loop that calls on IcedID’s function main_func. One of that\nfunction’s parameters is a pointer to another malware function: check_target_process.\nViewing the details of check_target_process reveals that it gets the process ID (PID) of the\nsvchost.exe it runs inside. Next, it calls NtQuerySystemInformation to fetch a list of all\nprocesses currently running on the device.\n\n\n-----\n\n_Figure 3: IcedID fetching process list to scan for open browser applications._\n\nThis scheme keeps running in a loop over all the operating system’s processes to allow the\nmalware to detect browser activity. When it encounters a potential browser process, IcedID\nchecks it via the check_target_process.\n\nThis last function uses two parameters to check whether a process is of interest or not:\n\n1. The target process’ ID; and\n2. The target process’ name.\n\nThe function encodes the process’ name and compares it with hardcoded strings the\ndeveloper created, representing the names of browsers IcedID can inject into.\n\n\n-----\n\n_Figure 4: IcedID checking for browser processes to inject its shellcode into._\n\nTo compare the process’ name to the preconfigured, hardcoded list, the malware calls the\nresolveProcessName function. That function receives the target process’ name as a\nparameter, decodes it and creates a hash of the result. That hash is what’s being compared\nto a list of precomputed hashes that translate into iexplore.exe, firefox.exe and chrome.exe.\n\nThe hash codes for the targeted web browsers are:\n\nFirefox.exe — 1EACD83D;\nIexplore.exe — 0D31A30C7; and\nChrome.exe — 0FA7442ED.\n\n_Figure 5: IcedID checking for popular browser processes to inject shellcode into._\n\nIf there’s no match, the function returns to its scanning routine, looking for other browser\nprocesses.\n\n\n-----\n\nThe next step for the malware is to call decode_target_process_event_name. This function\nreceives the targeted process’ PID as a parameter and generates an event name for the web\nbrowser process that’s about to be injected with IcedID’s shellcode.\n\nThis part of the injection mechanism is in place to compute the event name that the\nshellcode will create after the injection process so that it indicates to the malware that a\nspecific web browser’s process has already been injected.\n\nNow, after a match has been found and the validation of the target process is complete, the\nactual injection process begins by calling the function inject_target_process. Here, again, the\nparameter is the target process’ PID.\n\n_Figure 6: IcedID validates and begins injection of shellcode into browser process._\n\nThe inject_target_process function receives a handle to the target process using the\nOpenProcess API. It then checks whether the process is either 32-bit or 64-bit to prepare the\ncorrect code version for injection.\n\nNext up, the function that’s responsible for the injection starts by allocating memory in the\ntarget process. We can see the memory allocation call and then writing of the shellcode into\nthe target process using three Windows API functions:\n\n1. NtAllocateVirtualMemory;\n2. ZwProtectVirtualMemory; and\n3. ZwWriteVirtualMemory.\n\n\n-----\n\n_Figure 7: IcedID injects shellcode into targeted browser process._\n\nAfter it writes the shellcode into the process, IcedID calls to the next function for patching,\ndepending on which architecture applies:\n\npatch_NtWaitForSingleObject_32bit; or\npatch_NtWaitForSingleObject_64bit\n\nTo patch the NtWaitForSingleObject function and make it jump to the shellcode the next time\nit is called, IcedID begins by modifying the page protection status of that function using\nZwProtectVirtualMemory. Then, the malware applies the hook using ZwWriteVirtualMemory,\nand ends with switching the protection flag back to its normal permission state. From this\npoint on, subsequent calls to the NtWaitForSingleObject function will jump to the malware’s\ninjected shellcode and execute it.\n\nThe right-hand part of the image below shows the malware hooking the\nNtWaitForSingleObject function on the target process, in this case firefox.exe. The left part of\nthe image shows the targeted process with the newly hooked function.\n\n\n-----\n\n_Figure 8: Before and after IcedID’s browser process hooking._\n\nThe hooking process does not stop here; it is a perpetual loop that continues for as long as\nthe device is infected with IcedID. If the user opts to launch a different browser, the malware\nwill hook it as well and enable itself to intercept and interfere with the victim’s online banking\nactivities on any of the three browsers it can hook.\n\n### A Closer Look at IcedID’s Shellcode\n\nLet’s take a closer look at the shellcode that IcedID injects into browser processes. At the\nstarting point, the newly hooked browser process calls on the NtWaitForSingleObject\nfunction. The injected shellcode runs and fixes the hook to make sure the shellcode leading\nto the main function will only be called once and not loop back repeatedly, especially since\nNtWaitForSingleObject is a common API and will be called many times. This also wipes the\ntraces of the hook, which can make it harder for researchers to find.\n\nThe image below shows the starting address of the shellcode that is executed when the call\nfor NtWaitForSingleObject is launched by a legitimate thread from the hooked process.\n\n\n-----\n\n_Figure 9: Starting address of the shellcode executed when the call for NtWaitForSingleObject_\n_is launched._\n\nThe function fix_NtWaitForSingleObject will uninstall the hook from NtWaitForSingleObject in\nthe browser process, reinstating the original code that was there before the malware hooked\nit. Next, the shellcode will install the hooks inside the web browser’s process and then call\nNtWaitForSingleObject to continue executing the browser’s process.\n\n_Figure 10: IcedID restores the NtWaitForSingleObject function code to its original content._\n\nExamining the shellcode in WinDbg, a commonly used Windows debugger, we can see that\nNtWaitForSingleObject has indeed been restored to its original code.\n\n\n-----\n\nOne of the browser functions hooked by IcedID is Ws2_32:connect. This function redirects\nthe victim’s browsing traffic to the now-malicious svchost.exe process, allowing the malware\nto identify data the attacker wishes to receive, such as credentials, payment card details, etc.\nThe data is exfiltrated to the attacker’s command-and-control (C&C) sever.\n\nWe can see that the malware function hook_connect gets the same three parameters as the\nconnect function. First, it checks for the address family, browser type and port number and\nuses the information to determine whether to call the original connect function and exit or\ncontinue with the hook.\n\nIn the next step, the malware calls the original connect function with a new sockaddr object\nand new parameters: 127.0.0.1 as the IP address, AF_INET as the family address and a\nnew calculated port number. The traffic is ultimately redirected to the malicious svchost.exe\nprocess.\n\n_Figure 11: Reversing the hook installed on the connect function in the web browser._\n\nThis shellcode is what enables IcedID to gain some control and insight into what the victim is\ndoing online and allows the attacker to interfere with that activity.\n\n### Deeper Into the OS Process Injection\n\nThe second injection method IcedID uses is designed for injecting into processes of the\noperating system, not the browser.\n\n\n-----\n\nThis second tactic relies on the familiar method of creating a new process with the\nCREATE_SUSPEND flag and then hooking the RtlExitUserProcess API. Once the new\nprocess starts executing, it will fix the function back to its original state.\n\nThis injection method is an interaction between the different svchost.exe processes and the\nmalware’s payload.\n\n_Figure 12: Before and after IcedID’s hooks on targeted OS processes._\n\nThe left-hand part of the image above shows the svchost.exe process where a hook was\ninstalled on the RtlExitUserProcess API, making it jump to the shellcode the next time it is\ncalled by a legitimate thread from the svchost.exe process.\n\nWe can also see the start of the shellcode in the Interactive Disassembler (IDA), and we can\nsee that the first function being called fixes the hook that was installed on the\nRtlExitUserProcess API.\n\n\n-----\n\n_Figure 13: Starting address for the shellcode that’s executed upon a call to_\n_RtlExitUserProcess._\n\nExamining the code of the RtlExitUserProcess API after the removal of the malware’s hook,\nwe can see that the code was restored to its original state:\n\n_Figure 14: RtlExitUserProcess code restored to original content after uninstalling the hook._\n\n\n-----\n\nThis sums up IcedID s split injection tactics. It appears that the malware s operators are\ngetting advice from other coders, likely those working on the TrickBot project. These\nmodifications can make the malware’s activity stealthier, yet effective.\n\n## IcedID Keeps It Moving\n\n[IcedID emerged in 2017 as a modular banking Trojan with advanced capabilities to automate](https://securityintelligence.com/new-banking-trojan-icedid-discovered-by-ibm-x-force-research/)\nfraudulent transactions and control user devices to take over their bank accounts. Since its\ninitial analysis, it has been evolving gradually over time and showing explicit collaboration\nwith the TrickBot Trojan by ways of common distribution and feature similarity.\n\nIn August 2018, our researchers noted that IcedID had been upgraded to behave in a similar\nway to the TrickBot Trojan in terms of its deployment. The binary file had been modified to\nbecome smaller and no longer featured embedded modules. The malware’s plugins were\nbeing fetched and loaded on demand from a remote server after the Trojan was installed on\ninfected devices. These changes made IcedID stealthier, modular and also more similar to\nTrickBot.\n\nIn addition to its increased stealth level, IcedID started encrypting its binary file by\nobfuscating file names associated with its deployment on infected devices. Another TrickBotinspired modification saw IcedID add event objects, which are a means to coordinate\nmultiple threads of execution in Windows-based operating systems. IcedID began using\nnamed events to synchronize the execution between its core binary and the modular plugins\nit could fetch from its control server.\n\n[Although malware authors do sometimes copy from one another, these modifications were](https://securityintelligence.com/the-business-of-organized-cybercrime-rising-intergang-collaboration-in-2018/)\nnot coincidental. Even if we only looked at the fact that TrickBot and IcedID fetch one another\ninto infected devices, that would be indication enough that these Trojans are operated by\nteams that work together.\n\nX-Force data from 2018 placed IcedID in the top five most active banking Trojans on a global\nscale. The malware’s operators have links to other key cybergangs in the threat arena, and\nthey have been using IcedID to actively target the customers of major banks, payment card\nproviders, [e-commerce companies and cryptocurrency platforms. X-Force researchers](https://securityintelligence.com/icedid-operators-using-atsengine-injection-panel-to-hit-e-commerce-sites/)\nexpect this malware to continue targeting banks and payment platforms as we move into the\nsecond quarter of 2019.\n\n\n-----\n\n_Figure 15: Top most active banking Trojan families in 2019 (source: IBM Trusteer)._\n\n[Nir Somech](https://securityintelligence.com/author/nir-somech/)\nMalware Researcher – Trusteer IBM\n\nNir Somech is an engineer working as part of IBM X-Force research. He specializes in\nresearching attacks targeting the financial threat landscape. Nir holds ...\n\n\n-----\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-04-04 - IcedID Banking Trojan Spruces Up Injection Tactics to Add Stealth.pdf"
    ],
    "report_names": [
        "2019-04-04 - IcedID Banking Trojan Spruces Up Injection Tactics to Add Stealth.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1673536183,
    "ts_updated_at": 1743041156,
    "ts_creation_date": 1653767068,
    "ts_modification_date": 1653767068,
    "files": {
        "pdf": "https://archive.orkl.eu/699988a94968cbbe2028a8192aae286fe639fbdb.pdf",
        "text": "https://archive.orkl.eu/699988a94968cbbe2028a8192aae286fe639fbdb.txt",
        "img": "https://archive.orkl.eu/699988a94968cbbe2028a8192aae286fe639fbdb.jpg"
    }
}