{
    "id": "7c11b36d-d03c-4dbf-9166-29afc1c1d697",
    "created_at": "2023-01-12T15:04:01.882345Z",
    "updated_at": "2025-03-27T02:13:34.675156Z",
    "deleted_at": null,
    "sha1_hash": "be623aca9c6eeac0b4319e6b32c74bed2a261779",
    "title": "2022-02-17 - The story of a ransomware builder- from Thanos to Spook and beyond (Part 1)",
    "authors": "",
    "file_creation_date": "2022-05-28T19:23:28Z",
    "file_modification_date": "2022-05-28T19:23:28Z",
    "file_size": 2493973,
    "plain_text": "# The story of a ransomware builder: from Thanos to Spook and beyond (Part 1)\n\n**[sekoia.io/en/the-story-of-a-ransomware-builder-from-thanos-to-spook-and-beyond-part-1/](https://www.sekoia.io/en/the-story-of-a-ransomware-builder-from-thanos-to-spook-and-beyond-part-1/)**\n\nFebruary 17, 2022\n\n## Introduction\n\nDuring an onsite incident response analysis, CERT-Sekoia was contacted in order to\nrespond to a Spook ransomware attack.\n\nAfter gathering the evidence, we identified that malicious actors used a legitimate VPN\naccount to initiate the first connection. The account was also a Domain Administrator in the\ncompany Active Directory. All lateral movements used this account via RDP or SMB. We\nsuspect that this valid account was acquired earlier in 2021, and potentially from an initial\nAccess Broker, because:\n\nLocal computers’ files and artifacts show the presence of 2 executables containing\nMimikatz and netscanner with a last modification date back in July 2021;\nFrom the few residual logs available on the VPN appliance, shortly before the VPN\nsession was established, the user was added to the VPN allowed group. We identified\na web administration interface exposed to the internet;\nThe version of the software appliance was several months late in security updates,\nthus exposed to critical CVEs;\nThe duration of the attack (time elapsed between the 1st VPN connexion and the end\nof encryption routine) was less than an hour;\n\n\n-----\n\nRDP and SMB failed authentications show errors with incorrect domains, these\ndomains referring to known Spook’s victims, followed by other typo errors. It could\nindicate an operator making copy / paste actions.\n\nFinally, three binaries were executed remotely via PSExec, which led to the encryption of all\nof the companies’ files. It occurred only on the few systems up at the time of the operation (4\nAM on a Sunday morning). All 3 binaries had a prefix “Worker-”, but none of them were\nretrieved. We suppose that each of them has a specific purpose with the last one responsible\nfor covering threat actor’s actions. A ransom note was dropped on the victim’s desktops\ndetailing the payment and contact details to pay the ransom. The indicated website was the\nSpook leak website, hosted on a tor onion address.\n\nWhile attempting to recover the client’s files, it appeared that Volume Shadow Copies (VSC)\nhad not been deleted on the main file sharing server. Incident responders thus tested a VSC\nrecovery on a sample of files, which happened successfully.\n\n_Source: CERT-SEKOIA_\n\n## Understanding a Spook sample\n\nFollowing the previous incident response, we chose to focus on Spook ransomware. As per\nmany other ransomware, Spook was conceived using the Thanos builder. The Thanos\nbuilder was first advertised on the XSS forum in February 2020 by the actor Nosophoros. It\nwas sold using a subscription format, which explained its integration in other ransomware\nconsidered as variants, such as Spook. The most common sample found through different\nresources has the SHA-256\nhash: [8dad29bd09870ab9cacfdea9e7ab100d217ff128aea64fa4cac752362459991c.](https://www.virustotal.com/gui/file/8dad29bd09870ab9cacfdea9e7ab100d217ff128aea64fa4cac752362459991c)\n\n\n-----\n\nThe executable is an obfuscated .NET binary. [ExeInfo PE indicates the obfuscator](https://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/ExEinfo-PE.shtml)\ncommercial tool SmartAssembly in version 6.5.2–612.X.\n\n_Source: CERT-SEKOIA_\n\nWith this information, we fire [de4dot from the archived repository to get a readable version of](https://github.com/de4dot/de4dot)\nour sample. Unfortunately, the tool failed to deobfuscate function names, class names, and\nthe resource section that stores all the strings even though it detects an obfuscator. An\narticle from Fortinet dating back to July 2020 mentioned the same behavior, but did not\nprovide the process to get a readable sample.\n\n\n-----\n\n_Source: CERT-SEKOIA_\n\n[After a few Google searches, we found this very interesting article from Jason Reaves,](https://medium.com/walmartglobaltech/decoding-smartassembly-strings-a-haron-ransomware-case-study-9d0c5af7080b)\ndetailing how Haron (a former ransomware also built with Thanos) obfuscation works based\non SmartAssembly. He has not provided the SmartAssembly version within the article, but\n[from its sample it seems it’s 7.5.1.4370. By opening our sample in DNSpy, we get](https://github.com/dnSpy/dnSpy)\nv8.0.2.4779.\n\n_Source: CERT-SEKOIA_\n\n\n-----\n\nEven if the versions are different, we tried to follow his process. We retrieve the same type of\nconstructor to retrieve a string. Each different class declares a first attribute of\ntype GetString. It leads us to the module SmartAssembly.Delegates in our .NET browser.\n\n_Source: CERT-SEKOIA_\n\nThe second point is the usage\nof Strings.CreateGetStringDelegate (from SmartAssembly.HouseofCards module) based on\nthe class Strings (from SmartAssembly.StringsEncoding) with the\nparameter typeof(NameOfTheClass).\n\n_Source: CERT-SEKOIA_\n\nThis function retrieves the attribute GetType from the class parameter (of type GetString),\nand defines an unnamed DynamicMethod belonging to the class parameter’s module, taking\nan integer as input and returning a string. Then, it retrieves the first method of\n\n\n-----\n\nthe Strings class which returns a string value: the Get method like the screenshot below\nshows.\n\n_Source: CERT-SEKOIA_\n\nLet’s take a look at the Strings class now, where all the obfuscation mechanics happens.\nThis class stores basic information regarding where strings are located associated with\ndifferent constants:\n\n- An offset value, hardcoded with 75 as a class attribute;\n\n- An initial XOR value with the integer parameter sets to 107396847 (in hexa 0x666BEEF).\n\n_Source: CERT-SEKOIA_\n\nNotice, a cache feature to avoid decrypting a string several times, controlled by a class\nattribute cacheStrings sets at the initialization of the class with a default value to True.\n\n_Source: CERT-SEKOIA_\n\n\n-----\n\nWe learn that strings are located inside a manifest resource named {56258a19–7489–468b_86ee-e7899203d67c} and uncompressed with a custom Unzip command. This function is_\ndefined in the Zip module.\n\n_Source: CERT-SEKOIA_\n\nThis decompression function starts by creating a custom ZipStream attribute which is a child\nclass from MemoryStream with two additional methods:\n\n- ReadShort which returns the result of the parent class method ReadByte, which reads\nand casts a byte to Int32. If the parent’s method return -1 (end of stream) the function returns\n0;\n\n- ReadInt, same function but for a word (16 bytes) by using the ReadShort method.\n\nThe next step checks a header inside the resource file against the value ‘{z}\\x00’ (the code\nshows 8223355, which is the unsigned 32-bit value). From the resource we get ‘{z}\\x03’.\n\n_Source: CERT-SEKOIA_\n\nTo get the value where the next switch statement is based on, a 24 right bit-shift is performed\non the initial unsigned 32-bit integer read (do not forget that we are in little endian) leading to\nvalue 0x03. The switch has only two cases:\n\n- 1 = uncompress the content\n\n- 3 = decrypts with the symmetric algorithm AES and hardcoded values for key and initial\nvector\n\nIn this case the stream is decrypted. In the screenshot below, array2 represents the\nhardcoded key and array3 the hardcoded initial vector for the symmetric AES encryption\nalgorithm. Then, the new stream is passed again to the Unzip function.\n\n\n-----\n\n_Source: CERT-SEKOIA_\n\nUsing the same process as described above we managed to decrypt the first stream. The\nnewly decrypted one has the following header ‘{z}\\x01’: the switch case will go in the first\noption where data is simply uncompressed.\n\n_Source: CERT-SEKOIA_\n\nFinally, we get a chain of strings prefixed with a one byte value. Based on the article of Jason\nReaves, we thought that the integer prefix was the length of the string. We tried to use his\nproof of concept: it works for a small part of the data before raising an Exception regarding\nvalue to decode in UTF-8.\n\nBy looking in the GetFromResource method from the custom Strings class, it looks like\ndifferent operations are run before returning the final string. The first byte of the string is\nactually related to its length but does not represent the value itself for a specific case: if the\nvalue after the logical AND with 0x80 is not 0. In this case, the string length is evaluated\nthrough a long lambda function. We can split it in 3 parts:\n\nThe condition is again an AND operation with 0x40 value\n\n\n-----\n\nif true, then\n\n(num & 0x1F) << 24) + (bytes[index++] << 16) + (bytes[index++] << 8) + bytes[index++]\n\nif false\n\n((num & 0x3F) << 8) + bytes[index++]\n\nThe 0x80 (10000000in binary) and 0x40 (01000000 in binary) values are linked to the UTF-8\n[stream of a string as explained in this stack-overflow thread.](https://stackoverflow.com/questions/3911536/utf-8-unicode-whats-with-0xc0-and-0x80)\n\n_Source: CERT-SEKOIA_\n\nCompiling all this knowledge in a small Python script, we were able to decode the entire\nresource. Some of these strings show additional base64 and reversed base64 encoding\nschemas: we adjust the code to get a full plaintext.\n\n\n-----\n\n_Source: CERT-SEKOIA_\n\nBut one question remains, how to browse the original code and get the decoded string from\nthe resource that the function we are currently analyzing uses (associating an integer to its\nreadable value)?\n\n_Source: CERT-SEKOIA_\n\nHow to recover FTP method STOR from integer value 107364636 ?\n\n_Source: CERT-SEKOIA_\n\nSplitting into parts the python code and passing the integer observed to a decode function\ndoes not work. We missed something.\n\nBack to the delegate function in module HouseofCards and class Strings, we notice that 4\ncalls to Opcodes are used:\n\n_OpCodes.Ldarg_0 which pushes the argument at index 0 representing the integer used_\nby the Get method in the Strings class;\n_OpCodes.Ldc_I4 which pushes a 32-bit integer on the stack, in this case_\nthe MetadataToken of the input class (the AND operation with 0xFFFFFF = 16777215\nis meaningless);\n_OpCodes.Sub which subtracts the last value to the previous value pushed on the stack;_\n_OpCodes.Call which simply call the function Get of the Strings class with the result of_\nthe previous subtraction.\n\n\n-----\n\n_Source: CERT-SEKOIA_\n\nThe one-string decoder requires adding a subtraction with the value of the MetadaToken of\nthe function, which is printed as RID in DNSpy.\n\n[We have released the source code on the CERT GitHub repository, but](https://github.com/SekoiaLab/CERT-Services/tree/main/202202-thanos_story_of_a_ransomware) [Jiří Vinopal created](https://twitter.com/vinopaljiri/status/1470200362929901574?s=20)\n[an easier way to deal with SmartAssembly v8+ on his late 2021 tweet. By using the latest](https://twitter.com/vinopaljiri/status/1470200362929901574?s=20)\n[version (2015) of Simple Assembly Explorer and its integrated deobfuscator using the](https://github.com/wickyhu/simple-assembly-explorer/releases/tag/v1.14.4)\nprofile Name, String and Flow and checking the box Delegate Call, associated with the\n[famous old one de4dot, you get the sample deobfuscated and more readable. You just have](https://github.com/de4dot/de4dot)\nto spend some time on base64 strings.\n\nOur script is able to decode:\n\nThe entire resource content previously extracted from the malware;\nAn unique integer associated to its RID function to a plaintext string;\nSeveral strings associated to a rid.\n\nAll commands require the resource file (extracted from the sample), the key and initial vector\nhardcoded inside the malware (Module SmartAssembly.Zip — Method Unzip). The tool has\nbeen tested on different samples of Spook ransomware, but also on other ransomwares\nknown for using the Thanos builder (Hackbit, Haron, RecoveryGroup) or even on most\nrecent threat actors like Midas. This one has the same process, they just change the\nhardcoded value for the XOR and offset in the Get method of the custom Strings class. We\nadjust our code to be more customizable regarding this modification. The last version of\n[SmartAssembly tested (Midas ransomware) was v8.0.3.4821.](https://www.virustotal.com/gui/file/575d1ef0e51fbe96e7454b8f06b60118faf3e4ed7ef0f98908d0fcca6c0a9b82)\n\n## Conclusion\n\nTo conclude, starting from an incident response involving an opportunist threat actor, we\nsucceeded in providing fresh intelligence on how obfuscation is implemented by the Thanos\nbuilder. Considering that malicious actors can acquire this builder for a few dollars, we will\nsee in the second part, written by SEKOIA.IO’s Threat and Detection Team (TDR), how the\nabove-mentioned intelligence can be extended to the entire ransomware ecosystem.\n\n### Sources\n\n\n-----\n\nhttps://medium.com/walmartglobaltech/decoding-smartassembly-strings-a-haronransomware-case-study-9d0c5af7080b\n\n[https://stackoverflow.com/questions/3911536/utf-8-unicode-whats-with-0xc0-and-0x80](https://stackoverflow.com/questions/3911536/utf-8-unicode-whats-with-0xc0-and-0x80)\n\nhttps://www.fortinet.com/blog/threat-research/analysis-of-net-thanos-ransomware-supportingsafeboot-with-networking-mode\n\n[https://www.recordedfuture.com/thanos-ransomware-builder/](https://www.recordedfuture.com/thanos-ransomware-builder/)\n\nhttps://github.com/SekoiaLab/CERT-Services/tree/main/202202thanos_story_of_a_ransomware\n\n## Chat with our team!\n\nWould you like to know more about our solutions? Do you want to discover our XDR and CTI\nproducts? Do you have a cybersecurity project in your organization? Make an appointment\nand meet us!\n\n**[Contact us](https://www.sekoia.io/en/contact/)**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-02-17 - The story of a ransomware builder- from Thanos to Spook and beyond (Part 1).pdf"
    ],
    "report_names": [
        "2022-02-17 - The story of a ransomware builder- from Thanos to Spook and beyond (Part 1).pdf"
    ],
    "threat_actors": [
        {
            "id": "08c8f238-1df5-4e75-b4d8-276ebead502d",
            "created_at": "2023-01-06T13:46:39.344081Z",
            "updated_at": "2025-03-27T02:00:03.056208Z",
            "deleted_at": null,
            "main_name": "Copy-Paste",
            "aliases": [],
            "source_name": "MISPGALAXY:Copy-Paste",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535841,
    "ts_updated_at": 1743041614,
    "ts_creation_date": 1653765808,
    "ts_modification_date": 1653765808,
    "files": {
        "pdf": "https://archive.orkl.eu/be623aca9c6eeac0b4319e6b32c74bed2a261779.pdf",
        "text": "https://archive.orkl.eu/be623aca9c6eeac0b4319e6b32c74bed2a261779.txt",
        "img": "https://archive.orkl.eu/be623aca9c6eeac0b4319e6b32c74bed2a261779.jpg"
    }
}