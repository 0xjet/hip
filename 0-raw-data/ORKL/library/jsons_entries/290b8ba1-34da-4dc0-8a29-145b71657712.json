{
    "id": "290b8ba1-34da-4dc0-8a29-145b71657712",
    "created_at": "2023-01-12T15:04:11.669375Z",
    "updated_at": "2025-03-27T02:05:47.157418Z",
    "deleted_at": null,
    "sha1_hash": "bb7d18a41730ed552d57ac96983596d84e412cb9",
    "title": "2018-01-23 - A Walk-Through Tutorial, with Code, on Statically Unpacking the FinSpy VM- Part One, x86 Deobfuscation",
    "authors": "",
    "file_creation_date": "2022-05-28T18:26:17Z",
    "file_modification_date": "2022-05-28T18:26:17Z",
    "file_size": 198806,
    "plain_text": "# A Walk-Through Tutorial, with Code, on Statically Unpacking the FinSpy VM: Part One, x86 Deobfuscation\n\n**msreverseengineering.com/blog/2018/1/23/a-walk-through-tutorial-with-code-on-statically-unpacking-the-finspy-vm-**\npart-one-x86-deobfuscation\n\nJanuary 23, 2018\n\nJanuary 23, 2018 [Rolf Rolles](http://10.10.0.46/blog?author=5111cf9ee4b0a36262da10df)\n\n## 1. Introduction\n\nNormally when I publish about breaking virtual machine software protections, I do so to\npresent new techniques. Past examples have included:\n\nToday's document has a different focus. I am not going to be showcasing any particularly\nnew techniques. I will, instead, be providing a step-by-step walk-through of the process I\nused to analyze the FinSpy VM, including my thoughts along the way, the procedures and\nsource code I used, and summaries of the notes I took. The interested reader is\nencouraged to obtain the sample and walk through the analysis process for themselves.\n\nI have three motives in publishing this document:\n\n1. I think it's in the best interest of the security defense community if every malware\n\nanalyst is able to unpack the FinSpy malware VM whenever they encounter it (for\nobvious reasons).\n2. Reverse engineering is suffering from a drought of hands-on tutorial material in\n\nmodern times. I was fortunate to begin reverse engineering when such tutorials were\ncommon, and they were invaluable in helping me learn the craft. Slides are fine for\nlarge analyses, but for smaller ones, let's bring back tutorials for the sake of those that\nhave followed us.\n\n\n-----\n\n3. Publications on obfuscation, especially virtualization obfuscation, have become\n\nextremely abstruse particularly in the past five years. Many of these publications are\nlargely inaccessible to those not well-versed in master's degree-level program\nanalysis (or above). I want to demonstrate that easier techniques can still produce\nsurprisingly fast and useful results for some contemporary obfuscation techniques. (If\nyou want to learn more about program analysis-based approaches to deobfuscation,\n[there is currently a public offering of my SMT-based program analysis training class,](http://www.msreverseengineering.com/training-classes/)\nwhich has over 200 slides on modern deobfuscation with working, well-documented\ncode.)\n\n[Update: the rest of this document, the second and](http://www.msreverseengineering.com/blog/2018/1/31/finspy-vm-part-2-vm-analysis-and-bytecode-disassembly) [third parts, are now available online at](http://www.msreverseengineering.com/blog/2018/2/21/finspy-vm-unpacking-tutorial-part-3-devirtualization)\nthe links just given.\n\n## 2. Initial Steps\n\nThe first thing I did upon learning that a new FinSpy sample with VM was publicly\navailable was, of course, to obtain the sample. [VirusTotal gave the SHA256 hash; and I](https://www.virustotal.com/en/file/16070014b86f2254dcf273bbce78fb6eca43df9a6fc3c6ab85ec8f06a4063b06/analysis/)\n[obtained the corresponding sample from Hybrid-Analysis.](https://www.hybrid-analysis.com/sample/16070014b86f2254dcf273bbce78fb6eca43df9a6fc3c6ab85ec8f06a4063b06?environmentId=100)\n\nThe next step was to load the sample into IDA. The navigation bar immediately tipped me\noff that the binary was obfuscated:\n\nThe first half of the .text section is mostly colored grey and red, indicating data and\nnon-function code respectively.\nThe second half of the .text section is grey in the navigation bar, indicating data turned\ninto arrays.\n\nA normal binary would have a .text section that was mostly blue, indicating code within\nfunctions.\n\n## 3. Analysis of WinMain: Suspicions of VM-Based Obfuscation\n\nIDA's auto-analysis feature identified that the binary was compiled by the Microsoft Visual C\ncompiler. I began by identifying the WinMain function. Normally IDA would do this on my\nbehalf, but the code at that location is obfuscated, so IDA did not name it or turn it into a\nfunction. I located WinMain by examining the ___tmainCRTStartup function from the Visual\nC Run-Time and finding where it called into user-written code. The first few instructions\nresembled a normal function prologue; from there, the obfuscation immediately began.\n\n\n-----\n\n```\n.text:00406154   mov   edi, edi         ; Normal prologue\n.text:00406156   push  ebp           ; Normal prologue\n.text:00406157   mov   ebp, esp         ; Normal prologue\n.text:00406159   sub   esp, 0C94h        ; Normal prologue\n.text:0040615F   push  ebx           ; Save registers #1\n.text:00406160   push  esi           ; Save registers #1\n.text:00406161   push  edi           ; Save registers #1\n.text:00406162   push  edi           ; Save registers #2\n.text:00406163   push  edx           ; Save registers #2\n.text:00406164   mov   edx, offset byte_415E41 ; Obfuscation - #1\n.text:00406169   and   edi, 0C946B9C3h     ; Obfuscation - #2\n.text:0040616F   sub   edi, [edx+184h]     ; Obfuscation - #3\n.text:00406175   imul  edi, esp, 721D31h    ; Obfuscation - #4\n.text:0040617B   stc               ; Obfuscation\n.text:0040617C   sub   edi, [edx+0EEh]     ; Obfuscation - #5\n.text:00406182   shl   edi, cl         ; Obfuscation\n.text:00406184   sub   edi, [edx+39h]      ; Obfuscation - #6\n.text:0040618A   shl   edi, cl         ; Obfuscation\n.text:0040618C   imul  edi, ebp         ; Obfuscation\n.text:0040618F   mov   edi, edi         ; Obfuscation\n.text:00406191   stc               ; Obfuscation\n.text:00406192   sub   edi, 0A14686D0h     ; Obfuscation\n; ... obfuscation continues ...\n.text:004065A2   pop   edx           ; Restore registers\n.text:004065A3   pop   edi           ; Restore registers\n\n```\nThe obfuscation in the sequence above continues for several hundred instructions, nearly\nall of them consisting of random-looking modifications to the EDI register. I wanted to know\nA) whether the computations upon EDI were entirely immaterial junk instructions, or\nwhether a real value was being produced by this sequence, and B) whether the memory\nreferences in the lines labeled #1, #3, #5, and #6 were meaningful.\n\nAs for the first question, note that the values of the registers upon entering this sequence\nare unknown. We are, after all, in WinMain(), which uses the __cdecl calling convention,\nmeaning that the caller did not pass arguments in registers. Therefore, the value computed\non line #2 is unpredictable and can potentially change across different executions. Also, the\nvalue computed on line #4 is pure gibberish -- the value of the stack pointer will change\nacross runs (and the modification to EDI overwrites the values computed on lines #1-#3).\n\nAs for the second question, I skimmed the obfuscated listing and noticed that there were no\nwrites to memory, only reads, all intertwined with gibberish instructions like the ones just\ndescribed. Finally, the original value of edi is popped off the stack at the location near the\nend labeled \"restore registers\". So I was fairly confident that I was looking at a sequence of\ninstructions meant to do nothing, producing no meaningful change to the state of the\nprogram.\n\nFollowing that was a short sequence:\n\n\n-----\n\n```\n.text:004065A4   push  5A403Dh         ; Obfuscation\n.text:004065A9   push  ecx           ; Obfuscation\n.text:004065AA   sub   ecx, ecx         ; Obfuscation\n.text:004065AC   pop   ecx           ; Obfuscation\n.text:004065AD   jz   loc_401950        ; Transfer control elsewhere\n.text:004065AD ; -------------------------------------------------------------------------.text:004065B3   db 5 dup(0CCh)\n.text:004065B8 ; -------------------------------------------------------------------------.text:004065B8   mov   edi, edi\n.text:004065BA   push  ebp\n.text:004065BB   mov   ebp, esp\n.text:004065BD   sub   esp, 18h\n; ... followed by similar obfuscation to what we saw above ...\n\n```\nBy inspection, this sequence just pushes the value 5A403Dh onto the stack, and transfers\ncontrol to loc_401950. (The \"sub ecx, ecx\" instruction above sets the zero flag to 1,\ntherefore the JZ instruction will always branch.)\n\nNext we see the directive \"db 5 dup(0CCh)\" followed by \"mov edi, edi\". Reverse engineers\nwill recognize these sequences as the Microsoft Visual C compiler's implementation of hotpatching support. The details of hot-patching are less important than the observation that I\nexpected that the original pre-obfuscated binary contained a function that began at the\naddress of the first sequence, and ended before the \"db 5 dup(0CCh)\" sequence. I.e. I\nexpect that the obfuscator disassembled all of the code within this function, replaced it with\ngibberish instructions, placed a branch at the end to some other location, and then did the\nsame thing with the next function.\n\nThis is a good sign that we're dealing with a virtualization-based obfuscator: namely, it looks\nlike the binary was compiled with an ordinary compiler, then passed to a component that\noverwrote the original instructions (rather than merely encrypting them in-place, as would\nnormal packers).\n\n## 4. Learning More About the VM Entrypoint and VM Pre-Entry\n\nRecall again the second sequence of assembly code from the previous sequence:\n```\n.text:004065A4   push  5A403Dh         ; Obfuscation - #1\n.text:004065A9   push  ecx           ; Obfuscation\n.text:004065AA   sub   ecx, ecx         ; Obfuscation\n.text:004065AC   pop   ecx           ; Obfuscation\n.text:004065AD   jz   loc_401950        ; Transfer control elsewhere\n\n```\nSince -- by supposition -- all of the code from this function was replaced with gibberish,\nthere wasn't much to meaningfully analyze. My only real option was to examine the code at\nthe location loc_401950, the target of the JZ instruction on the last line. The first thing I\nnoticed at this location, loc 401950, was that there were 125 incoming references, nearly\n\n\n-----\n\nall of them of the form jz loc_401950, with some of the form jmp loc_401950 . Having\nanalyzed a number of VM-based obfuscators in my day, this location fits the pattern of\nbeing the part of the VM known as the \"entrypoint\" -- the part where the virtual CPU begins\nto execute. Usually this location will save the registers and flags onto the stack, before\nperforming any necessary setup, and finally beginning to execute VM instructions. VM\nentrypoints usually require a pointer or other identifier to the bytecode that will be executed\nby the VM; maybe that's the value from the instruction labeled #1 in the sequence above?\nLet's check another incoming reference to that location to verify:\n```\n.text:00408AB8   push  5A7440h ; #2\n.text:00408ABD   push  eax\n.text:00408ABE   sub   eax, eax\n.text:00408AC0   pop   eax\n.text:00408AC1   jz   loc_401950\n\n```\nThe other location leading to the entrypoint is functionally identical, apart from pushing a\ndifferent value onto the stack. This value is not a pointer; it does not correspond to an\naddress within the executable's memory image. Nevertheless, we expect that this value is\nsomehow responsible for telling the VM entrypoint where the bytecode is located.\n\n## 5. Analyzing the VM Entrypoint Code\n\nSo far we have determined that loc_401950 is the VM entrypoint, targeted by 125 branching\nlocations within the binary, which each push a different non-pointer DWORD before\nbranching. Let's start analyzing that code:\n```\n.text:00401950          loc_401950:\n.text:00401950 0F 82 D1 02 00 00   jb   loc_401C27\n.text:00401956 0F 83 CB 02 00 00   jnb   loc_401C27\n\n```\nImmediately we see an obvious and well-known form of obfuscation. The first line jumps to\nloc_401C27 if the \"below\" conditional is true, and the second line jumps to loc_401C27 if\nthe \"not below\" conditional is true. I.e., execution will reach loc_401C27 if either \"below\" or\n\"not below\" is true in the current EFLAGS context. I.e., these two instructions will transfer\ncontrol to loc_401C27 no matter what is in EFLAGS -- and in particular, we might as well\nreplace these two instructions with \"jmp loc_401C27\", as the effect would be identical.\n\nContinuing to analyze at loc_401C27, we see another instance of the same basic idea:\n```\n.text:00401C27          loc_401C27:\n.text:00401C27 77 CD         ja   short loc_401BF6\n.text:00401C29 76 CB         jbe   short loc_401BF6\n\n```\nHere we have an unconditional branch to loc_401BF6, split across two instructions -- a\n\"jump if above\", and \"jump if below or equals\", where \"above\" and \"below or equals\" are\nlogically opposite and mutually exclusive conditions.\n\n\n-----\n\nAfter this, at location loc_401BF6, there is a legitimate-looking instruction (push eax),\nfollowed by another conditional jump pair to loc_401D5C. At that location, there is another\nlegitimate-looking instruction (push ecx), followed by a conditional jump pair to loc_4019D2.\nAt that location, there is another legitimate-looking instruction (push edx), followed by\nanother conditional jump pair. It quickly became obvious that every legitimate instruction\nwas interspersed between one or two conditional jump pairs -- there are hundreds or\nthousands of these pairs throughout the binary.\n\nThough an extremely old and not particularly sophisticated form of obfuscation, it is\nnevertheless annoying and degrades the utility of one's disassembler. As I discussed in a\nprevious entry on IDA processor module extensions, IDA does not automatically recognize\nthat two opposite conditional branches to the same location are an unconditional branch to\nthat location. As a result, IDA thinks that the address following the second conditional\nbranch must necessarily contain code. Obfuscation authors exploit this by putting junk bytes\nafter the second conditional branch, which then causes the disassembler to generate\ngarbage instructions, which may overlap and occlude legitimate instructions following the\nbranch due to the variable-length encoding scheme for X86. (Note that IDA is not to blame\nfor this conundrum -- ultimately these problems are undecidable under ordinary Von\nNeumann-based models of program execution.) The result is that many of the legitimate\ninstructions get lost in the dreck generated by this process, and that, in order to follow the\ncode as usual in manual static analysis, one would spend a lot of time manually undefining\nthe gibberish instructions and re-defining the legitimate ones.\n\n## 6. Deobfuscating the Conditional Branch Obfuscation: Theory and Practice\n\nManually undefining and redefining instructions as just described, however, would be a\nwaste of time, so let's not do that. Speaking of IDA processor modules, once it became\nclear that this pattern repeated between every legitimate non-control-flow instruction, I got\nthe idea to write an IDA processor module extension to remove the obfuscation\nautomatically. IDA processor module extensions give us the ability to have a function of\nours called every time the disassembler encounters an instruction. If we could recognize\nthat the instruction we were disassembling was a conditional branch, and determine that the\nfollowing instruction contains its opposite conditional branch to the same target as the first,\nwe could replace the first one with an unconditional branch and NOP out the second branch\ninstruction.\n\nThus, the first task is to come up with a way to recognize instances of this obfuscation. It\nseemed like the easiest way would be to do this with byte pattern-recognition. In my\ncallback function that executes before an instruction is disassembled, I can inspect the raw\nbytes to determine whether I'm dealing with a conditional branch, and if so, what the\ncondition is and the branch target. Then I can apply the same logic to determine whether\n\n\n-----\n\nthe following instruction is a conditional branch and determine its condition and target. If the\nconditions are opposite and the branch targets are the same, we've found an instance of\nthe obfuscation and can neutralize it.\n\nIn practice, this is even easier than it sounds! Recall the first example from above,\nreproduced here for ease of reading:\n```\n.text:00401950 0F 82 D1 02 00 00   jb   loc_401C27\n.text:00401956 0F 83 CB 02 00 00   jnb   loc_401C27\n\n```\nEach of these two instructions is six bytes long. They both begin with the byte 0F (the x86\ntwo-byte escape opcode stem), are then followed by a byte in the range of 80 to 8F, and are\nthen followed by a DWORD encoding the displacement from the end of the instructions to\nthe branch targets. As a fortuitous quirk of x86 instruction encodings, opposite conditional\nbranches are encoded with adjacent bytes. I.e. 82 represents the long form of JB, and 83\nrepresents the long form of JNB. Two long branches have opposite condition codes if and\nonly if their second opcode byte differs from one another in the lowest bit (i.e. 0x82 ^ 0x83\n== 0x01). And note also that the DWORDs following the second opcode byte differ by\nexactly 6 -- the length of a long conditional branch instruction.\n\nThat's all we need to know for the long conditional branches. There is also a short form for\nconditionals, shown in the second example above and reproduced here for ease of reading:\n```\n.text:00401C27 77 CD         ja   short loc_401BF6\n.text:00401C29 76 CB         jbe   short loc_401BF6\n\n```\nVirtually identical comments apply to these sequences. The first bytes of both instructions\nare in the range of 0x70 to 0x7F, opposite conditions have differing lowest bits, and the\nsecond bytes differ from one another by exactly 2 -- the length of a short conditional branch\ninstruction.\n\n## 7. Deobfuscating the Conditional Branch Obfuscation: Implementation\n\n[I started by copying and pasting my code from the last time I did something like this. I first](http://www.msreverseengineering.com/blog/2015/6/29/transparent-deobfuscation-with-ida-processor-module-extensions)\ndeleted all the code that was specific to the last protection I broke with an IDA processor\nmodule extension. Since I've switched to IDA 7.0 in the meantime, and since IDA 7.0 made\nbreaking changes vis-a-vis prior APIs, I had to make a few modifications -- namely,\nrenaming the custom analysis function from deobX86Hook::custom_ana(self) to\ndeobX86Hook::ev_ana_insn(self, insn), and replacing every reference to idaapi.cmd.ea with\ninsn.ea. Also, my previous example would only run if the binary's MD5 matched a particular\nsum, so I copied and pasted the sum of my sample out of IDA's database preamble over\nthe previous MD5.\n\n\n-----\n\nFrom there I had to change the logic in custom_ana. The result was even simpler than my\nlast processor module extension. Here is the logic for recognizing and deobfuscating the\nshort form of the conditional branch obfuscation:\n```\nb1 = idaapi.get_byte(insn.ea)\nif b1 >= 0x70 and b1 <= 0x7F:\n  d1 = idaapi.get_byte(insn.ea+1)\n  b2 = idaapi.get_byte(insn.ea+2)\n  d2 = idaapi.get_byte(insn.ea+3)\n  if b2 == b1 ^ 0x01 and d1-2 == d2:\n    # Replace first byte of first conditional with 0xEB, the opcode for \"JMP\nrel8\"\n    idaapi.put_byte(insn.ea, 0xEB) \n    # Replace the following instruction with two 0x90 NOP instructions\n    idaapi.put_word(insn.ea+2, 0x9090)\n\n```\n[Deobfuscating the long form is nearly identical; see the code for details.](https://github.com/RolfRolles/FinSpyVM/blob/master/FinSpyDeob.py)\n\n## 8. Admiring My Handiwork, Cleaning up the Database a Bit\n\nNow I copied the processor module extension to %IDA%\\plugins and re-loaded the sample.\nIt had worked! The VM entrypoint had been replaced with:\n```\n.text:00401950 loc_401950:\n.text:00401950   jmp   loc_401C27\n\n```\nThough the navigation bar was still largely red and ugly, I immediately noticed a large\nfunction in the middle of the text section:\n\nLooking at it in graph mode, we can see that it's kind of ugly and not entirely as nice as\nanalyzing unobfuscated X86, but considering how trivial it was to get here, I'll take it over\nthe obfuscated version any day. The red nodes denote errant instructions physically located\nabove the valid ones in the white nodes. IDA's graphing algorithm includes any code within\nthe physically contiguous region of a function's chunks in the graph display, regardless of\nwhether they have incoming code cross-references, likely to make displays of exception\nhandlers nicer. It would be easy enough to remove these and strip the JMP instructions if\nyou wanted to write a plugin to do so.\n\n\n-----\n\nNext I was curious about the grey areas in the .text section navigation bar held. (Those\nareas denote defined data items, mixed in with the obfuscated code in the .text section.) I\nfigured that the data held there was most likely related to the obfuscator. I spent a minute\nlooking at the grey regions and found this immediately after the defined function:\n```\n.text:00402AE0   dd offset loc_402CF2\n.text:00402AE4   dd offset loc_402FBE\n; ... 30 similar lines deleted ...\n.text:00402B60   dd offset loc_4042DC\n.text:00402B64   dd offset loc_40434D\n\n```\n\n-----\n\n34 offsets, each of which contains code. Those are probably the VM instruction handlers.\nFor good measure, let's turn those into functions with an IDAPython one-liner:\n```\nfor pFuncEa in xrange(0x00402AE0, 0x00402B68, 4):\n  idaapi.add_func(idaapi.get_long(pFuncEa))\n\n```\nNow a large, contiguous chunk of the navigation bar for the .text section is blue. And at this\npoint I realized I had forgotten to create a function at the original dispatcher location, so I\ndid that manually and here was the resulting navigation bar:\n\nHex-Rays doesn't do a very good job with any of the functions we just defined, since they\nwere originally written in assembly language and use instructions and constructs not\nordinarily produced by compilers. I don't blame Hex-Rays for that and I hope they continue\nto optimize for standard compiler-based use cases and not weird ones like this.\n\nLastly, I held PageDown scrolling through the text section to see what was left. The majority\nof it was VM entrypoints like those we saw in section 3. There were a few functions that\nappeared like they had been produced by a compiler.\n\nSo now we have assessed what's in the text section -- a VM with 34 handlers, 125+\nvirtualized functions, and a handful of unvirtualized ones. Next time we'll take a look at the\nVM.\n\n## 9. Preview of Parts 2 and 3, and Beyond\n\nAfter this I spent a few hours analyzing the VM entrypoint and VM instruction handlers.\nNext, through static analysis I obtained the bytecode for the VM program contained within\nthis sample. I then wrote a disassembler for the VM. That's [part two.](http://www.msreverseengineering.com/blog/2018/1/31/finspy-vm-part-2-vm-analysis-and-bytecode-disassembly)\n\nFrom there, by staring at the disassembled VM bytecode I was able to write a simple\npattern-based deobfuscator. After that I re-generated the X86 machine code, which was not\nextremely difficult, but it was more laborious than I had originally anticipated. That's part\nthree.\n\nAfter that, I re-inserted the X86 machine code into the original binary and analyzed it. It\nturned out to be a fairly sophisticated dropper for one of two second-stage binaries. It was\nfairly heavy on system internals and had a few tricks that aren't widely documented, so I\nmay publish one or more of those as separate entries, and/or I may publish an analysis of\nthe entire dropper.\n\n\n-----\n\nFinally, I analyzed -- or rather, still am analyzing -- the second-stage binaries. They may or\nmay not prove worthy of publication.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2018/2018-01-23 - A Walk-Through Tutorial, with Code, on Statically Unpacking the FinSpy VM- Part One, x86 Deobfuscation.pdf"
    ],
    "report_names": [
        "2018-01-23 - A Walk-Through Tutorial, with Code, on Statically Unpacking the FinSpy VM- Part One, x86 Deobfuscation.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535851,
    "ts_updated_at": 1743041147,
    "ts_creation_date": 1653762377,
    "ts_modification_date": 1653762377,
    "files": {
        "pdf": "https://archive.orkl.eu/bb7d18a41730ed552d57ac96983596d84e412cb9.pdf",
        "text": "https://archive.orkl.eu/bb7d18a41730ed552d57ac96983596d84e412cb9.txt",
        "img": "https://archive.orkl.eu/bb7d18a41730ed552d57ac96983596d84e412cb9.jpg"
    }
}