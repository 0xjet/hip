{
    "id": "d0cc7702-7a00-48fa-86b4-86033ebd154a",
    "created_at": "2024-04-12T20:31:16.557531Z",
    "updated_at": "2025-03-27T02:05:30.589129Z",
    "deleted_at": null,
    "sha1_hash": "251de590e58a6ed577df670fa236deb9069b899c",
    "title": "",
    "authors": "",
    "file_creation_date": "2022-10-17T17:15:42Z",
    "file_modification_date": "2022-10-17T17:15:42Z",
    "file_size": 4546353,
    "plain_text": "# A Detailed Analysis of the\n\n Gafgyt Malware Targeting\n\n IoT Devices \n\n## Prepared by: Vlad Pasca, Senior Malware & Threat Analyst\n\n\n**SecurityScorecard.com**\n**info@securityscorecard.com**\n\n**Tower 49**\n**12 E 49[th] Street**\n\n**Suite 15-001**\n**New York, NY 10017**\n\n**1.800.682.1707**\n\n\n-----\n\n### Table of contents\n\nExecutive summary 2\n\nAnalysis and findings 2\n\nALPHA command 35\n\nGAME command 36\n\n\nGRE command 36\n\nICMP command 36\n\nJAIL command 36\n\nKICK command 36\n\nMIX command 36\n\nPLAIN command 36\n\nQUERY/QUERY2 command 36\n\nSPEC/SPEC2 command 36\n\nSTOP/stop/Stop command 36\n\nIndicators of Compromise 37\n\n\n-----\n\n### Executive summary \n\nGafgyt malware, also known as Bashlite, along with Mirai, have targeted millions of vulnerable IoT\ndevices in the last few years. The recently compiled sample we’ve analyzed borrowed some code\nleaked online from the Mirai botnet. The following commands are implemented: ALPHA, GAME,\nGRE, ICMP, JAIL, KICK, MIX, PLAIN, QUERY, SPEC, and STOP. The purpose of these commands is\nto perform multiple types of TCP and UDP DoS attacks, to target game servers running Valve’s\nSource Engine with DoS attacks, to perform “GRE flood” and ”ICMP flood” attacks, to perform\nHTTP DoS attacks on OVH servers. The last command is used to stop the malicious activity.\n\n\n### Analysis and findings\n\nSHA256: 05e278364de2475f93c7db4b286c66ab3b377b092a312aee7048fbe0d3f608aa\n\nThe ELF file is packed with UPX, as highlighted in the figure below.\n\nFigure 1\n\nThe malware writes the “14I2I34czY$” string to the standard output:\n\nFigure 2\n\nThe current process name is set to “/usr/bin/apt” using the prctl function (0xF = PR_SET_NAME):\n\n\n-----\n\nFigure 3\n\n\nThe process retrieves the current time in seconds, the process ID of the calling process, performs\nan XOR operation between the results, and sets the value as the seed for srandom:\n\nFigure 4\n\nThe XOR operation result between the current time in seconds and the current process ID is\npassed as a parameter to a function called init_rand. The implementation is identical to the one\n[presented here:](https://github.com/siaoshan33/DDoS-Scripts-1/blob/master/Netbios.c)\n\nFigure 5\n\nFigure 6\n\n\n-----\n\nFigure 7\n\nThe inet_addr function is utilized to convert the Google DNS server into binary data in network\nbyte order:\n\nFigure 8\n\nThe malware performs a connection to the Google DNS server on port 53 via a function call to\nconnect, as highlighted below:\n\nFigure 9\n\nThe ELF binary obtains the current address to which the socket is bound using the getsockname\nfunction:\n\nFigure 10\n\n\nThe malicious process calls a function called getOurIP. It creates a new socket by calling the\nsocket method (0x2 = AF_UNIX, 0x2 = SOCK_DGRAM):\n\nFigure 7\n\n\n-----\n\nThe process opens the kernel routing table from “/proc/net/route”:\n\n\nFigure 11\n\nThe above file is parsed, and the binary is looking for the “00000000” string:\n\nFigure 12\n\nThe ELF binary extracts the MAC address of the device using the ioctl method (0x8927 =\n**SIOCGIFHWADDR):**\n\nFigure 13\n\n\n-----\n\nThe fork function is utilized to create a new process by duplicating the calling process. The\nmalware ignores the SIGCHLD signal:\n\n\nFigure 14\n\nThe binary opens and reads the “/proc” directory using the opendir and readdir functions, as\nshown in figure 15.\n\nFigure 15\n\nThe process IDs that can be extracted from the subdirectories of the “/proc” folder are converted\nfrom strings to numbers. The malware avoids the current process and its parent process:\n\nFigure 16\n\n\n-----\n\nFigure 17\n\nThe process uses the isdigit and isalpha functions to verify if a character from the command line\nis a digit or an alphabetic character, respectively:\n\nFigure 18\n\n\nA function called killer_mirai_exists is implemented by the malware. The command line of the\nprocesses is extracted from the “/proc/<Process ID>/cmdline” file:\n\n\n-----\n\nA Mirai process is supposed to contain at least five letters and two digits in its name. If that’s the\ncase, the process is terminated using the kill function:\n\n\nFigure 19\n\nThe current process is daemonized by calling the setsid and fork methods:\n\nFigure 20\n\nThe ELF binary implements a function called initConnection. It will establish a connection with\nthe C2 server 45.61.186.4 on port 13561 (see figure 21).\n\nFigure 21\n\n\n-----\n\nFigure 22\n\nThe malware retrieves the file status flag of the socket and modifies it to include\n**SOCK_NONBLOCK by calling the fcntl64 method:**\n\nFigure 23\n\n\nA new socket is created, and the process calls a function named connectTimeout:\n\n\n-----\n\nIn the getHost function, the C2 IP address is converted into binary data in network byte order\nusing inet_addr:\n\n\nFigure 24\n\nThe connect function is utilized to perform a connection to the C2 server:\n\nFigure 25\n\nThe process extracts information about the error status via a call to getsockopt (0x1 =\n**SOL_SOCKET, 0x4 = SO_ERROR):**\n\nFigure 26\n\n\n-----\n\nThe IP address of the device is converted to a string, and the binary will send a packet containing\nthe string and the architecture that is hard-coded (“x86_64”) to the C2 server:\n\n\nFigure 27\n\nThe confirmation message that contains the device’s IP address and the architecture is sent to\nthe C2 server using the send method, as shown in the figure below.\n\nFigure 28\n\nThe ELF binary flushes the rules of all chains in iptables, stops the iptables and firewalld services,\nremoves the bash history, and clears the history for the current shell:\n\n\n-----\n\nFigure 29\n\nTwo DNS servers are added to the “/etc/resolv.conf” file:\n\nFigure 30\n\nThe malicious process implements a function called recvLine, which uses the recv method to\nread the response from the C2 server, as highlighted below:\n\nFigure 31\n\n\n-----\n\nFigure 32\n\nThe strtok function is utilized to split the response into a series of tokens based on the space\ndelimiter (see figure 33). A function called processCmd implements the received commands:\n\nFigure 33\n\nThe following commands are implemented: \"ALPHA\", \"GAME\", \"GRE\", \"SPEC2\", \"SPEC\", \"JAIL\",\n\"MIX\", \"ICMP\", \"QUERY2\", \"PLAIN\", \"QUERY\", \"KICK\", \"STOP\", \"stop\", and \"Stop\". An example of such\na command is shown below:\n\nFigure 34\n\n\n-----\n\nIn a function called listFork, the binary creates a child process using the fork method and stores\nits PID in a variabile called “pids”:\n\n\nFigure 35\n\nNow we’ll describe the functions that are used in the main commands: ftcp, vseattack1, rand_hex,\nudppac2, udppac, jailv1, icmpattack, rtcp, sendJUNK, tcpFl00d, ovhl7, udpfl00d, and kickv2.\n\n**ftcp function**\n\nFirstly, the malware expects a port number to be passed as a parameter; otherwise, it generates\none using a function called rand_cmwc:\n\nFigure 36\n\n\n-----\n\nThe function mentioned above implements a [Complement Multiply With Carry random number](https://en.wikipedia.org/wiki/Multiply-with-carry_pseudorandom_number_generator)\n\n[generator and is used to generate a 4-byte pseudo-random value:](https://en.wikipedia.org/wiki/Multiply-with-carry_pseudorandom_number_generator)\n\n\nFigure 37\n\nThe IP address that is transmitted by the C2 server and is supposed to be affected by a DoS attack\nis converted into binary data using inet_addr:\n\nFigure 38\n\n\n-----\n\nThe malicious binary creates a socket and modifies its type via a function call to setsockopt:\n\n\nFigure 39\n\nThe malware generates a random IP address using a function called getRandomIP, as displayed\nin figure 40.\n\nFigure 40\n\nThe random IP address is converted from host byte order to network byte order using htonl. In a\nfunction called makeIPPacket, the binary constructs the IP header (20 bytes) that contains the\nsource IP (= random IP address) and the destination IP that is targeted by the malware:\n\n\n-----\n\nFigure 41\n\nThe ELF binary computes the TCP checksum using the tcpcsum and csum functions that are\n[defined here. Multiple flood attack types were identified: “all”, “xmas”, “syn”, “rst”, “fin”, “ack”, and](https://github.com/flexingonlamers/Amp/blob/master/tcp-amp.c)\n“psh”:\n\nFigure 42\n\n\n-----\n\nFinally, the malware sends multiple packets to the target by calling the sendto method. A new\nrandom IP is generated, it is converted from host byte order to network byte order, and the\nalgorithm repeats the same steps described above until the target becomes unreachable:\n\n\nFigure 43\n\n**vseattack1 function**\n\nThe process expects a port number as a parameter or generates one using the rand_cmwc\nfunction. The IP address to be targeted is converted into binary data using inet_addr:\n\nFigure 44\n\nThe ELF binary creates a raw socket or a datagram socket, as displayed in the figure below.\n\nFigure 45\n\n\n-----\n\nA function called makeRandomStr is used to compute a random string:\n\n\nFigure 46\n\nA function called makevsepacket1 is similar to the function described in the first case; however,\nthe data sent contains a hard-coded buffer (see figure 48). In this case, the targets are game\nservers running Valve’s Source Engine.\n\nFigure 47\n\n\n-----\n\nFigure 48\n\nThe sendto method is used again to send data to the targeted server, as displayed in figure 49.\n\nFigure 49\n\n**rand_hex function**\n\nThe process creates a raw socket (0x2 = AF_INET, 0x3 = SOCK_RAW, 0x6 = IPPROTO_TCP):\n\nFigure 50\n\nIn the function called util_local_addr, the binary creates a datagram socket and performs a\nconnection to the Google DNS server “8.8.8.8” in order to obtain the device’s IP address (see\nfigure 51).\n\n\n-----\n\nFigure 51\n\nA network packet that has a similar header to the ones we’ve already covered is created:\n\nFigure 52\n\nThe binary implements two checksum functions called checksum_generic and\n[checksum_tcpudp. Their implemention can be found here.](https://github.com/jgamblin/Mirai-Source-Code/blob/master/mirai/bot/checksum.c)\n\n\n-----\n\nFigure 53\n\nThe inet_addr function is used to convert the targeted IP address into binary data in network\nbyte order. The malware sends hex-generated data to the target via a call to sendto:\n\nFigure 54\n\n**udppac/udppac2 function**\n\nThe ELF binary creates a socket and expects a port number as a parameter or generates one\nusing the rand_cmwc function:\n\n\n-----\n\nFigure 55\n\nThe target IP address is converted into binary data in network byte order, and the process\ngenerates a random string using a function called rand_str and performs a network connection\nto the target via a call to connect:\n\nFigure 56\n\nThe randomly generated string is sent to the target IP address by calling the send function\n(0x4000 = MSG_NOSIGNAL):\n\n\n-----\n\nFigure 57\n\n**jailv1 function**\n\nA datagram socket is created by the malware, and the system time in seconds is retrieved using\nthe time method (see figure 58).\n\nFigure 58\n\nThe gethostbyname function is utilized to obtain a structure of type hostent for an IP\naddress/domain specified by the C2 server:\n\nFigure 59\n\n\n-----\n\nThe process sends a hard-coded buffer containing hex values to the target IP address, as\nhighlighted in the figure below.\n\n\nFigure 60\n\n**icmpattack function**\n\nThe malware forks the process and creates a new socket:\n\nFigure 61\n\nThe port number specified by the C2 server is converted from host byte order to network byte\norder using htons, and the process calls the inet_addr function with the target IP as a parameter:\n\n\n-----\n\nFigure 62\n\nIn a function called rand, the process uses the random method to generate a pseudo-random\nnumber. The binary performs a network connection to the target by calling the connect method:\n\nFigure 63\n\nFinally, the malware sends multiple ICMP echo requests to the target server:\n\nFigure 64\n\n\n-----\n\n**rtcp function**\n\nThe binary calls the getHost function with the target IP as a parameter and then creates a raw\nsocket:\n\n\nFigure 65\n\nA random IP is generated and is included as the source IP in a network packet constructed using\nthe makeIPPacket function, as displayed in figure 66:\n\nFigure 66\n\nThe ELF binary computes the TCP checksum using the tcpcsum and csum functions:\n\n\n-----\n\nFigure 67\n\nThe sendto function is used to send the network packets to the target server:\n\nFigure 68\n\n**sendJUNK function**\n\nThe malicious process extracts the file descriptor table size using getdtablesize and converts the\ntarget IP address using inet_addr:\n\nFigure 69\n\n\n-----\n\nThe malware sends 170 bytes to the target server using the send function:\n\n\nFigure 70\n\nIn another branch of the function, a new stream socket is created, its file status flag is modified,\nand the binary connects to the target IP address (see figure 71).\n\nFigure 71\n\n**tcpFl00d function**\n\nThe malicious binary calls the getHost function and creates a raw socket:\n\n\n-----\n\nFigure 72\n\nA new random IP is generated, and the function called makeIPPacket is utilized to create a\nnetwork packet that will be sent to the target server. Multiple flood attack types were identified:\n“all”, \"syn\", \"rst\", \"fin\", \"ack\", and \"psh\":\n\nFigure 73\n\nThe TCP checksum is computed, and the process sends multiple requests until the target\nbecomes unreachable using the sendto method:\n\n\n-----\n\nFigure 74\n\n**ovhl7 function**\n\nThe binary randomly selects a user agent from a list and calls the fork function, as shown below.\n\nFigure 75\n\n\n-----\n\nFigure 76\n\nUsing the sprintf function, the malware constructs a PGET request with the “\\x00\\x01...\\xff” URI. A\nfunction called socket_connect is implemented, and the request is sent to the target server using\nthe write method:\n\nFigure 77\n\nIn the socket_connect function, the process calls the gethostbyname method, creates a stream\nsocket, modifies the TCP_NODELAY option, and connects to the target IP address:\n\n\n-----\n\nFigure 78\n\nFigure 79\n\n**udpfl00d function**\n\nA datagram socket or a raw socket is created, depending on the C2 response (see figure 80).\n\nFigure 80\n\n\n-----\n\nAs in the tcpFl00d function, the malicious process calls the findRandIP, makeIPPacket, and\nmakeRandomStr functions. The network packets containing random data are sent to the target\nserver using sendto:\n\n\nFigure 81\n\nFigure 82\n\n**kickv2 function**\n\nThe ELF binary creates a datagram socket and calls the gethostbyname function:\n\nFigure 83\n\n\n-----\n\nIt randomly selects a buffer from the “Trandstrings” array that is sent to a target mentioned by\nthe C2 server:\n\n\nFigure 84\n\nFigure 85\n\nNow we’ll describe all commands implemented by Gafgyt that call the functions we already\ndescribed. It’s important to mention that the 1st parameter of any command is supposed to be\nan IP address and the 2nd parameter is a port number.\n\n### ALPHA command\n\nThis command calls the ftcp function that performs multiple types of TCP DoS attacks.\n\n\n-----\n\n### GAME command\n\nThis command targets the game servers running Valve’s Source Engine with DoS attacks. It calls\nthe vseattack1 function.\n\n### GRE command\n\nThis command targets a server with “GRE flood” attacks. It calls the rand_hex function.\n\n\n### ICMP command\n\nThis command targets a server with “ICMP flood” attacks. It calls the icmpattack function.\n\n### JAIL command\n\nThis command calls the jailv1 function that performs DoS attacks.\n\n### KICK command\n\nThis command calls the kickv2 function that sends multiple hard-coded buffers to a target.\n\n### MIX command\n\nThis command targets a server with “GRE flood” and “ICMP flood” attacks. It calls the rand_hex\nand icmpattack functions.\n\n### PLAIN command\n\nThis command calls the udpfl00d function that targets a server with UDP DoS attacks.\n\n### QUERY/QUERY2 command\n\nThis command targets a server with multiple types of TCP DoS attacks and performs HTTP DoS\nattacks on OVH servers. It calls the rtcp, sendJUNK, tcpFl00d, and ovhl7 functions.\n\n### SPEC/SPEC2 command\n\nThis command calls the udppac/udppac2 function that performs DoS attacks.\n\n### STOP/stop/Stop command\n\nThis command is used to kill all spawned processes using the kill command.\n\n\n-----\n\n### Indicators of Compromise\n\n**C2 server**\n\n45.61.186.4:13561\n\n**SHA256**\n\n05e278364de2475f93c7db4b286c66ab3b377b092a312aee7048fbe0d3f608aa\n\n\n**User-Agents used by Gafgyt**\n\nMozilla/4.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/4.0; GTB7.4; InfoPath.2; SV1;.NET CLR\n4.4.58799; WOW64; en-US)\n\nMozilla/4.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0; FunWebProducts)\n\nMozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:25.0) Gecko/20100101 Firefox/25.0\n\nMozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:21.0) Gecko/20100101 Firefox/21.0\n\nMozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:24.0) Gecko/20100101 Firefox/24.0\n\nMozilla/5.0 (Macintosh; Intel Mac OS X 10_10; rv:33.0) Gecko/20100101 Firefox/33.0\n\nMozilla/5.0 (compatible; Konqueror/3.0; i686 Linux; 20021117)\n\nMozilla/5.0 (Windows NT 6.1; WOW64) SkypeUriPreview Preview/0.5\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://securityscorecard.com/wp-content/uploads/2024/01/Report-A-Detailed-Analysis-Of-The-Gafgyt-Malware-Targeting-IoT-Devices.pdf"
    ],
    "report_names": [
        "Report-A-Detailed-Analysis-Of-The-Gafgyt-Malware-Targeting-IoT-Devices.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1712953876,
    "ts_updated_at": 1743041130,
    "ts_creation_date": 1666026942,
    "ts_modification_date": 1666026942,
    "files": {
        "pdf": "https://archive.orkl.eu/251de590e58a6ed577df670fa236deb9069b899c.pdf",
        "text": "https://archive.orkl.eu/251de590e58a6ed577df670fa236deb9069b899c.txt",
        "img": "https://archive.orkl.eu/251de590e58a6ed577df670fa236deb9069b899c.jpg"
    }
}