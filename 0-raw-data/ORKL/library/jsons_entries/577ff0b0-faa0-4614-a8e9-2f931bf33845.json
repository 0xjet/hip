{
    "id": "577ff0b0-faa0-4614-a8e9-2f931bf33845",
    "created_at": "2023-04-05T02:09:53.073919Z",
    "updated_at": "2025-03-27T02:15:26.173123Z",
    "deleted_at": null,
    "sha1_hash": "7a4a2de5d5a268da12147648244971ce57316ce1",
    "title": "2023-03-06 - Brute Ratel - Scandinavian Defence",
    "authors": "",
    "file_creation_date": "2023-04-03T08:32:38Z",
    "file_modification_date": "2023-04-03T08:32:38Z",
    "file_size": 1079015,
    "plain_text": "# Brute Ratel analysis\n\n###### protectedmo.de/brute.html\n\n## Brute Ratel - Scandinavian Defence\n\n Disclaimer\n\n#### The opinions expressed in this post is that of the author and absolutely also that of the presenters' employers, parents, pets, governments, mentors, siblings, and the Council of the City of Eugene, Oregon.\n\n## Introduction\n\n#### Brute Ratel is a so-called \"red team\" malware created by some Twitter malware developer who claims to be an ex-EDR engineer. Right now, it is most known for being abused by various ransomware gangs and the author lying about that despite extensive proof otherwise. The reverse engineering project was instigated by these reports of abuse by RaaS. More specifically, abuse by Blackcat / ALPHV affiliates were reported by Sophos in private circles on July 1st 2022.\n\n The version being reverse engineered is called \"Scandinavian Defence\" - the version most commonly abused by TAs. However, other versions (up to the latest as of the time of writing, which is 27/01/2023) are available to this author, and might be discussed at a later date should time permit. However, the work done on the current version is enough to give an in- depth understanding of the way Brute Ratel was designed, and the author's capabilities and lack thereof.\n\n The payload was generated using the same leaked builder that is used extensively by threat actors. The generated format is a blob of position independent code, which takes the following form.\n\n Overview\n\n## Loader\n\n#### The generated loader is typically a shellcode (which is sometimes later stuffed into a PE file). The shellcode can be decompiled as:\n\n\n-----\n\n```\nx\n\n\n\n\n\nunsigned char base64_config[] = {};\n\nunsigned char encrypted_payload_followed_by_key[] = {};\n\nvoid *base64_config_dup = alloc_clone(base64_config, sizeof(base64_config));\n\nvoid *encrypted_payload_dup = alloc_clone(encrypted_payload_followed_by_key,\nsizeof(encrypted_payload_followed_by_key));\n\ndecrypt_and_run(encrypted_payload_dup, base64_config_dup);\n\n\n\n\n\n#### The function decrypt_and_run is a generic PE mapper that passes a context structure to the mapped PE containing the key. A RC4 key is stored in the last 8 bytes of encrypted_payload_followed_by_key, this is used for both payload decryption and config\n\n```\n\n-----\n\n#### decryption.\n\n It should be noted that the configuration and encrypted payload are initialised on the stack - that is, with a series of mov/push. The reasons for this are likely incompetence from the developer who doesn't know what RIP-relative addressing is.\n\n## Inner payload\n\n#### Inner payload initialisation\n\n The inner payload is a \"DLL\" file whose entrypoint takes a single pointer to a context structure provided by the outer layer. This context structure takes the following form:\n\n\n-----\n\n```\nxxxxxxxxxx\n\n\n\n\n\nstruct __unaligned __declspec(align(1)) BR_LOADER_CONTEXT\n\n{\n\n const char *config_base64;\n\n HANDLE event_initialisation_finished;\n\n __int64 config_key;\n\n __int64 loader_unmap_ptr;\n\n __int64 loader_clear1;\n\n __int64 loader_clear2;\n\n```\n\n-----\n\n```\n};\n\n\n\n\n\n#### The loader_unmap_ptr and loader_clear1/loader_clear2 are regions that the inner payload would clear and free upon initialisation, this is to clean up traces of the outer layer.\n\n Next, various APIs are initialised and syscall IDs grabbed. They are generic - nothing special to talk about there.\n\n The config is decrypted and stored into the context. This is done by base64 decoding and then RC4-ing with the key appended to the encrypted payload mentioned earlier. The format is as follows.\n\n```\n\n-----\n\n```\nxxxxxxxxxx\n\n\n\n\nsleep_callback_mode|sleep_time|sleep_jitter|doh_servers|doh_c2s|doh_fake_ip1|doh_fake_ip2|prepend_data|appen\n|config_flag_use_tls|http_hosts_array|http_port|user_agent|handshake_cds_auth|comms_crypto_key|path|config_h\n maybe?\n\n\n\n\n\n#### Each format entry is separated by |, with some supporting arrays that are separated by the character, such as the http host array etc. An example decoded config would be:\n\n```\n\n-----\n\n```\nxxxxxxxxxx\n\n\n\n\n0|60|40|||||cHJlcGVuZGVkIGRhdGEgd293|YXBwZW5kZWQgZGF0YSB3b3c=|0|1|rotational_host.com|443|shitty useragent\nhere|G8DQGVPJOPERI3OA|DEEP9FV3309VB55C|/lsdjfioasjdfiosdajo.php|i fucking hate malware: i fucking hate\nmalware|726b070f05876a8daa8269d69bcb52c321aa2d689f0bcd3033ad93aa0419b08c```\n\n\n\n\n\n#### Payload communication (encoding layer)\n\n Communication happens over either DoH or HTTP(s). Data is encrypted with a block cipher with the key specified in the config.\n\n HTTPs traffic is just data POST with appended/prepended data alongside custom headers, typical C2 stuff, nothing special.\n\n DNS communication is spread over a series of A/TX requests - A for sending and TX for receiving.\nFor requests of size less than 64 bytes the sequences is as follows:\n\n```\n\n-----\n\n```\nxxxxxxxxxx\n\n\n\n\n\nA: random.send_length.transaction_id.host\n\nA: random.send_data.transaction_id.host\n\ndo\n\n{\n\n  TX: random.transaction_id.host -> response\n\n} while (response.type != A && response.type != config_ip_termination)\n\n\n\n\n\n#### For requests of size larger than 64 bytes the sequence is as follows:\n\n```\n\n-----\n\n```\nxxxxxxxxxx\n\n\n\n\n\nA: random.send_length.transaction_id.host\n\n{\n\n  A: random.chunk.transaction_id.host\n\n  where chunk is 64 bytes chunks of the send data, with its content reversed\n\n}\n\n{\n\n  TX: random.transaction_id.host -> response\n\n} while (response.type != A && response.type != config_ip_termination)\n\n\n```\n\n-----\n\n#### All data is encrypted with an AES variant, more details will follow.\n\n Payload communication (internal layer)\n\n The communication starts with the following handshake.\n\n\n-----\n\n```\nxxxxxxxxxx\n\n\n\n\n\n{\n\n \"cds\": {\n\n  \"auth\": \"config.handshake_cds_auth\"\n\n },\n\n \"mtdt\": {\n\n  \"h_name\": \"hostname\",\n\n  \"wver\": \"{system_architecture}\",\n\n  \"arch\": \"x64\",\n\n```\n\n-----\n\n```\n          _,\n\n  \"p_name\": \"module_file_name\",\n\n  \"uid\": \"username_str [asterisk appended if elevated]\",\n\n  \"pid\": \"{current_pid}\",\n\n  \"tid\": \"current_tid\"\n\n }\n\n}\n\n\n\n\n\n#### Server response: The server response is a base64-encoded string, the decoded variant of which is used for the \"auth\" parameter of further requests.\n\n After this initial handshake, Brute Ratel loops and sends the check-in request.\n\n Check-in:\n\n```\n\n-----\n\n```\nx\n\n\n\n\n\n{\n\n \"cds\": {\n\n  \"auth\": \"handshake_response\"\n\n },\n​\n\n //optional\n\n \"dt\": {\n\n  \"chkin\": \"pending commands\"\n\n }\n\n```\n\n-----\n\n```\n}\n\n\n\n\n\n#### Server responses contain base64 encoded and encrypted commands. Commands are separated with \",\" and are each base64 encoded internally. A max of 50 concurrent commands are supported at a time.\n\n### Cryptography\n\n#### The cryptography used for encrypting communication is a variant of the AES block cipher. The table used is the exact same (though incremented by 1 at rest and \"decoded\" by subtracting 1 from every entry in the table at runtime). However, the operations are slightly different. An abridged decompilation follows. It should be noted that this author is not an expert at cryptography, and function names designated here might be inaccurate.\n\n```\n\n-----\n\n```\nxxxxxxxxxx\n\n\n\n\n\nvoid __usercall __spoils<rax,rdx,r8> br::crypto::cblock::sub_bytes(uint8_t *buffer@<rcx>)\n\n{\n\n __int64 i; // rax\n​\n\n for ( i = 0i64; i != 16; ++i )\n\n  buffer[i] = br::crypto::cblock::sbox[buffer[i]];\n\n}\n\nvoid __usercall __spoils<rax,rdx> br::crypto::cblock::shuffle_chunk_enc(uint8_t *a1@<rcx>)\n\n```\n\n-----\n\n```\n{\n\n __int64 i; // rax\n\n char v2[24]; // [rsp+0h] [rbp-18h]\n​\n\n v2[0] = *a1;\n\n v2[1] = a1[5];\n\n v2[2] = a1[10];\n\n v2[3] = a1[15];\n\n v2[4] = a1[4];\n\n v2[5] = a1[9];\n\n v2[6] = a1[14];\n\n v2[7] = a1[3];\n\n v2[8] = a1[8];\n\n v2[9] = a1[13];\n\n v2[10] = a1[2];\n\n```\n\n-----\n\n```\n v2[11] = a1[7];\n\n v2[12] = a1[12];\n\n v2[13] = a1[1];\n\n v2[14] = a1[6];\n\n v2[15] = a1[11];\n\n for ( i = 0i64; i != 16; ++i )\n\n  a1[i] = v2[i];\n\n}\n\nvoid __usercall __spoils<r8,rax,r9,r10> br::crypto::cblock::mix_sub_columns(uint8_t *a1@<rcx>)\n\n{\n\n v1 = a1[2];\n\n v2 = *a1;\n\n v3 = a1[3];\n\n v4 = a1[1];\n\n```\n\n-----\n\n```\n     ;\n\n v6 = a1[1];\n\n v42[0] = br::crypto::cblock::xtime3[v4] ^ br::crypto::cblock::xtime2[v2] ^ v3 ^ v1;\n\n v7 = v6 ^ v5;\n\n v8 = v1 ^ v6;\n\n v9 = br::crypto::cblock::xtime2[v4] ^ v3 ^ v2;\n\n v10 = v1;\n\n v11 = a1[6];\n\n v12 = br::crypto::cblock::xtime3[v10] ^ v9;\n\n v13 = br::crypto::cblock::xtime2[v10] ^ v7;\n\n v14 = br::crypto::cblock::xtime3[v2] ^ v8;\n\n v15 = a1[5];\n\n v42[1] = v12;\n\n v16 = br::crypto::cblock::xtime2[v3] ^ v14;\n\n v17 = a1[4];\n\n```\n\n-----\n\n```\n v18 = br::crypto::cblock::xtime3[v3] ^ v13;\n\n v19 = a1[7];\n\n v42[3] = v16;\n\n v42[2] = v18;\n\n v42[4] = br::crypto::cblock::xtime3[v15] ^ br::crypto::cblock::xtime2[v17] ^ v19 ^ v11;\n\n v20 = br::crypto::cblock::xtime3[v11] ^ br::crypto::cblock::xtime2[v15] ^ v19 ^ v17;\n\n v21 = br::crypto::cblock::xtime2[v11] ^ v15 ^ v17;\n\n v42[7] = br::crypto::cblock::xtime2[v19] ^ br::crypto::cblock::xtime3[v17] ^ v11 ^ v15;\n\n v22 = br::crypto::cblock::xtime3[v19] ^ v21;\n\n v42[5] = v20;\n\n v42[6] = v22;\n\n v23 = a1[8];\n\n v24 = a1[10];\n\n v25 = a1[11];\n\n```\n\n-----\n\n```\n     [ ];\n\n v27 = a1[8];\n\n v28 = a1[9];\n\n v42[8] = br::crypto::cblock::xtime3[v26] ^ br::crypto::cblock::xtime2[v23] ^ v25 ^ v24;\n\n v29 = br::crypto::cblock::xtime3[v24] ^ br::crypto::cblock::xtime2[v26] ^ v25 ^ v23;\n\n v30 = br::crypto::cblock::xtime3[v25] ^ br::crypto::cblock::xtime2[v24] ^ v28 ^ v27;\n\n v31 = v24 ^ v28;\n\n v32 = a1[14];\n\n v42[9] = v29;\n\n v33 = a1[13];\n\n v34 = br::crypto::cblock::xtime3[v23] ^ v31;\n\n v42[10] = v30;\n\n v35 = a1[12];\n\n v36 = br::crypto::cblock::xtime2[v25] ^ v34;\n\n v37 = a1[15];\n\n```\n\n-----\n\n```\n v42[11] = v36;\n\n v42[12] = br::crypto::cblock::xtime3[v33] ^ br::crypto::cblock::xtime2[v35] ^ v37 ^ v32;\n\n v38 = br::crypto::cblock::xtime2[v32] ^ v33 ^ v35;\n\n v39 = br::crypto::cblock::xtime3[v32] ^ br::crypto::cblock::xtime2[v33] ^ v37 ^ v35;\n\n v42[15] = br::crypto::cblock::xtime2[v37] ^ br::crypto::cblock::xtime3[v35] ^ v32 ^ v33;\n\n v40 = 0i64;\n\n v41 = br::crypto::cblock::xtime3[v37] ^ v38;\n\n v42[13] = v39;\n\n v42[14] = v41;\n\n do\n\n {\n\n  a1[v40] = v42[v40];\n\n  ++v40;\n\n }\n\n```\n\n-----\n\n```\n     ( );\n\n}\n\n__int64 __fastcall br::crypto::cblock::block_crypt_cbc(uint8_t *chunk_enc, const uint8_t *iv,\nBR_CRYPT_BLOCKSTATE *state)\n\n{\n\n __int64 i; // rax\n\n uint8_t v5; // r8\n\n uint8_t *ptr_state; // rsi\n\n const uint8_t *state_end; // r12\n\n const uint8_t *ptr_state_; // rdx\n\n __int64 result; // rax\n\n uint8_t local_chunk[16]; // [rsp+20h] [rbp-28h] BYREF\n​\n\n for ( i = 0i64; i != 16; local_chunk[i - 1] = v5 )\n\n  v5 = chunk_enc[i++];\n\n br::crypto::cblock::xor(local_chunk, iv);\n\n```\n\n-----\n\n```\n ptr_state = &state->field_0[16];\n\n state_end = &state->field_0[160];\n\n do\n\n {\n\n  br::crypto::cblock::sub_bytes(local_chunk);\n\n  br::crypto::cblock::shuffle_chunk_enc(local_chunk);\n\n  br::crypto::cblock::xtimes_crypt(local_chunk);\n\n  ptr_state_ = ptr_state;\n\n  ptr_state += 16;\n\n  br::crypto::cblock::xor(local_chunk, ptr_state_);\n\n }\n\n while ( state_end != ptr_state );\n\n br::crypto::cblock::sub_bytes(local_chunk);\n\n br::crypto::cblock::shuffle_chunk_enc(local_chunk);\n\n```\n\n-----\n\n```\n     yp ( _, _ );\n\n for ( result = 0i64; result != 16; ++result )\n\n  chunk_enc[result] = local_chunk[result];\n\n return result;\n\n}\n​\n\nvoid __usercall __spoils<r8,rax,r9,r10> br::crypto::cblock::inv_mix_sub_columns(char *a1@<rcx>)\n\n{\n\n v1 = (unsigned __int8)*a1;\n\n v2 = (unsigned __int8)a1[1];\n\n v3 = (unsigned __int8)a1[2];\n\n v4 = (unsigned __int8)a1[3];\n\n v32[0] = br::crypto::cblock::xtime9[v4] ^ br::crypto::cblock::xtime13[v3] ^\nbr::crypto::cblock::xtime11[v2] ^ br::crypto::cblock::xtime14[v1];\n\n v32[1] = br::crypto::cblock::xtime13[v4] ^ br::crypto::cblock::xtime11[v3] ^\nbr::crypto::cblock::xtime14[v2] ^ br::crypto::cblock::xtime9[v1];\n\n```\n\n-----\n\n```\n   [ ] yp [ ] yp [ ]\nbr::crypto::cblock::xtime9[v2] ^ br::crypto::cblock::xtime13[v1];\n\n v5 = br::crypto::cblock::xtime11[v1];\n\n v6 = (unsigned __int8)a1[4];\n\n v7 = br::crypto::cblock::xtime13[v2] ^ v5;\n\n v8 = (unsigned __int8)a1[5];\n\n v9 = br::crypto::cblock::xtime9[v3] ^ v7;\n\n v10 = (unsigned __int8)a1[6];\n\n v11 = br::crypto::cblock::xtime14[v4] ^ v9;\n\n v12 = (unsigned __int8)a1[7];\n\n v32[3] = v11;\n\n v32[4] = br::crypto::cblock::xtime9[v12] ^ br::crypto::cblock::xtime13[v10] ^\nbr::crypto::cblock::xtime11[v8] ^ br::crypto::cblock::xtime14[v6];\n\n v32[5] = br::crypto::cblock::xtime13[v12] ^ br::crypto::cblock::xtime11[v10] ^\nbr::crypto::cblock::xtime14[v8] ^ br::crypto::cblock::xtime9[v6];\n\n v32[6] = br::crypto::cblock::xtime11[v12] ^ br::crypto::cblock::xtime14[v10] ^\nbr::crypto::cblock::xtime9[v8] ^ br::crypto::cblock::xtime13[v6];\n\n v13 = br::crypto::cblock::xtime11[v6];\n\n```\n\n-----\n\n```\n     ( g __ ) [ ];\n\n v15 = br::crypto::cblock::xtime13[v8] ^ v13;\n\n v16 = (unsigned __int8)a1[9];\n\n v17 = br::crypto::cblock::xtime9[v10] ^ v15;\n\n v18 = (unsigned __int8)a1[10];\n\n v19 = br::crypto::cblock::xtime14[v12] ^ v17;\n\n v20 = (unsigned __int8)a1[11];\n\n v32[7] = v19;\n\n v32[8] = br::crypto::cblock::xtime9[v20] ^ br::crypto::cblock::xtime13[v18] ^\nbr::crypto::cblock::xtime11[v16] ^ br::crypto::cblock::xtime14[v14];\n\n v32[9] = br::crypto::cblock::xtime13[v20] ^ br::crypto::cblock::xtime11[v18] ^\nbr::crypto::cblock::xtime14[v16] ^ br::crypto::cblock::xtime9[v14];\n\n v32[10] = br::crypto::cblock::xtime11[v20] ^ br::crypto::cblock::xtime14[v18] ^\nbr::crypto::cblock::xtime9[v16] ^ br::crypto::cblock::xtime13[v14];\n\n v21 = br::crypto::cblock::xtime11[v14];\n\n v22 = (unsigned __int8)a1[12];\n\n v23 = br::crypto::cblock::xtime13[v16] ^ v21;\n\n```\n\n-----\n\n```\n     ( g __ ) [ ];\n\n v25 = br::crypto::cblock::xtime9[v18] ^ v23;\n\n v26 = (unsigned __int8)a1[14];\n\n v27 = br::crypto::cblock::xtime14[v20] ^ v25;\n\n v28 = (unsigned __int8)a1[15];\n\n v32[11] = v27;\n\n v32[12] = br::crypto::cblock::xtime9[v28] ^ br::crypto::cblock::xtime13[v26] ^\nbr::crypto::cblock::xtime11[v24] ^ br::crypto::cblock::xtime14[v22];\n\n v32[13] = br::crypto::cblock::xtime13[v28] ^ br::crypto::cblock::xtime11[v26] ^\nbr::crypto::cblock::xtime14[v24] ^ br::crypto::cblock::xtime9[v22];\n\n v29 = br::crypto::cblock::xtime13[v24] ^ br::crypto::cblock::xtime11[v22];\n\n v30 = br::crypto::cblock::xtime9[v26];\n\n v32[14] = br::crypto::cblock::xtime11[v28] ^ br::crypto::cblock::xtime14[v26] ^\nbr::crypto::cblock::xtime9[v24] ^ br::crypto::cblock::xtime13[v22];\n\n v31 = 0i64;\n\n v32[15] = v29 ^ v30 ^ br::crypto::cblock::xtime14[v28];\n\n do\n\n```\n\n-----\n\n```\n {\n\n  a1[v31] = v32[v31];\n\n  ++v31;\n\n }\n\n while ( v31 != 16 );\n\n}\n​\n\nvoid __usercall __spoils<rax,rdx,r8> br::crypto::cblock::rsub_bytes(const char *buffer@<rcx>)\n\n{\n\n __int64 i; // rax\n​\n\n for ( i = 0i64; i != 16; ++i )\n\n  buffer[i] = br::crypto::cblock::rsbox[(unsigned __int8)buffer[i]];\n\n}\n​\n\n```\n\n-----\n\n```\nvoid __usercall __spoils<rax,rdx> br::crypto::cblock::shuffle_chunk_dec(uint8_t *a1@<rcx>)\n\n{\n\n __int64 i; // rax\n\n char v2[24]; // [rsp+0h] [rbp-18h]\n​\n\n v2[0] = *a1;\n\n v2[1] = a1[13];\n\n v2[2] = a1[10];\n\n v2[3] = a1[7];\n\n v2[4] = a1[4];\n\n v2[5] = a1[1];\n\n v2[6] = a1[14];\n\n v2[7] = a1[11];\n\n v2[8] = a1[8];\n\n```\n\n-----\n\n```\n  [ ] [ ];\n\n v2[10] = a1[2];\n\n v2[11] = a1[15];\n\n v2[12] = a1[12];\n\n v2[13] = a1[9];\n\n v2[14] = a1[6];\n\n v2[15] = a1[3];\n\n for ( i = 0i64; i != 16; ++i )\n\n  a1[i] = v2[i];\n\n}\n​\n\n__int64 __fastcall br::crypto::cblock::block_decrypt_cbc(char *crypt_buf, const char *key,\nBR_CRYPT_BLOCKSTATE *block_state)\n\n{\n\n __int64 i; // rax\n\n char v6; // dl\n\n```\n\n-----\n\n```\n const uint8_t *state_skip_90; // rdi\n\n const uint8_t *v8; // rdx\n\n __int64 result; // rax\n\n uint8_t local_[16]; // [rsp+20h] [rbp-38h] BYREF\n​\n\n for ( i = 0i64; i != 16; local_[i - 1] = v6 )\n\n  v6 = crypt_buf[i++];\n\n state_skip_90 = &block_state->field_0[0x90];\n\n br::crypto::cblock::xor(local_, &block_state->field_0[0xA0]);\n\n br::crypto::cblock::shuffle_chunk_dec(local_);\n\n br::crypto::cblock::rsub_bytes((const char *)local_);\n\n do\n\n {\n\n  v8 = state_skip_90;\n\n```\n\n-----\n\n```\n     _ p_ ;\n\n  br::crypto::cblock::xor(local_, v8);\n\n  br::crypto::cblock::inv_mix_sub_columns((char *)local_);\n\n  br::crypto::cblock::shuffle_chunk_dec(local_);\n\n  br::crypto::cblock::rsub_bytes((const char *)local_);\n\n }\n\n while ( block_state != (BR_CRYPT_BLOCKSTATE *)state_skip_90 );\n\n br::crypto::cblock::xor(local_, (const uint8_t *)key);\n\n for ( result = 0i64; result != 16; ++result )\n\n  crypt_buf[result] = local_[result];\n\n return result;\n\n}\n\n\n\n\n\n### Functionalities overview\n\n#### The following commands are supported by Brute Ratel.\n\n```\n\n-----\n\n```\nxxxxxxxxxx\n\n\n\n\n\ndownload_file\n\nadd_privilege\n\nlist_applications\n\ndump_ipnet_table\n\nset_current_dir\n\nclear_coffargs\n\nclear_arg_string\n\nclear_child_string\n\n```\n\n-----\n\n```\n   _p\nload_coff\n\ncopy_file\n\ncrisis_monitor\n\ndcsync\n\nenable_dll_block\n\ndisable_dll_block\n\ndump_dns_cache_table\n\nlist_drivers\n\nclipboard_get\n\nquery_file_info\n\nprint_threadex\n\nprint_args\n\nprint_env_strings\n\nprint_expiry_time\n\n```\n\n-----\n\n```\ngrab_token\n\nping\n\nprint_idle_Time\n\nimpersonate_from_vault\n\nprint_network_info\n\nprint_active_tasks\n\nget_ticket_from_spn\n\nkeylog\n\npskill\n\nquery_ad\n\nprint_task_status\n\nmemsearch_perm\n\nlist_modules\n\nlist_tcp_listeners\n\n```\n\n-----\n\n```\n j\nlock_workstation\n\nnslookup\n\nls\n\nlist_logical_drives\n\nlstree\n\nimpersonate_user\n\nprocessdump_by_pid\n\nmemhook\n\nmkdir\n\nmovefile\n\ndo_group_user_query\n\nprint_udp_tcp_table\n\nquery_user_info\n\nrun_dll\n\n```\n\n-----\n\n```\nphish_for_creds\n\nrun_child_with_spoofed_args_and_inject2\n\nport_scan\n\ncat\n\npstree\n\nenumerate_process_remote\n\nclear_import\n\nwrite_file_and_start_service\n\nprocess_list\n\nset_import\n\ninject_with_import\n\npwd\n\nenum_sessions_on_host\n\nreg_query\n\n```\n\n-----\n\n```\n   _\ndelete_file\n\nrmdir\n\nprint_ip_forward_table\n\nrun_child_with_spoofed_arg\n\nrun_child_with_spoofed_arg_suspended\n\nrun_as_user\n\ndump_sam_hive\n\nprint_task_cheduler_folder\n\nscreenshot\n\ncreate_service\n\ndelete_service\n\nshellexec_hijack_service\n\nlist_services\n\nstart_service\n\n```\n\n-----\n\n```\nset_coffargs\n\nset_config_sleep_mode\n\nset_threadex\n\nset_creds_and_wmi_namespace_loc\n\nset_arg\n\nset_child\n\ntry_get_debug_privilege\n\nset_expiry_time\n\nset_parent\n\ndump_process_by_name\n\nnetshares\n\nsharescan\n\nload_dotnet_assembly\n\nshellexecutea\n\n```\n\n-----\n\n```\n j _ _ _p\nstart_listener_smb_named_pipe\n\nadd_socks_profile\n\nstart_socks\n\ncancel_all_tasks\n\nstart_listener_tcp\n\nset_spoof_address\n\nset_sleep_and_jitter\n\nstop_task\n\nswap_profile\n\nprint_sysinfo\n\nimpersonate_or_run_as_system\n\nprint_processes_and_threads\n\nexecute_command_n_times\n\ndump_token_vault\n\n```\n\n-----\n\n```\nupload\n\nprint_uptime\n\nprint_self_token_info\n\nclear_token_vault\n\nremove_token_from_vault\n\nclear_wmi_namespace_and_creds\n\nwmi_exec_on_remote\n\nwmi_query\n\nset_exit_flag_1\n\nset_exit_flag_2\n\nlist_windows\n\nprint_sessions\n\n\n\n\n\n```\n\n-----\n\n#### As the author of this post did not consult the brute ratel manual during the process of reverse engineering (except googling one to find out that \"CM\" stood for \"crisis-monitor\"), the naming represents the perspective of reverse engineering and likely differs from the perspective of a typical threat actor utilizing the malware.\n\n### Copy-pastas, focaccia, lasagna and piccata\n\n#### There are several commands in Brute Ratel that are interesting. The reasons for them being deemed interesting varies - sometimes it is because it is a paste of GPL2 code that violates the license, sometimes it is because of unique(ly bad) design choices.\n\n The first is the minidump. It is pasted ReactOS code (GPL2). It is important to note that the pasting was done in a remarkably obtuse way.\n\n Decompiled Minidump vs Reactos Minidump\n\n The malware author modified this by changing MinidumpWriteDump to write only several hardcoded streams, and also by making the minidump implementation write to a transacted file instead of to a regular file.\n\n Transaction handling for minidump\n\n Those who do detection engineering can already see the detection opportunities afforded here, and those who do software development can already see the incredible level of incompetence shown by this approach to modifying pasted code.\n\n Likewise, the DCSync code is also copypasted, albeit this time from Github.\n\n Transaction handling for minidump\n\n There is further copypaste of the AD Recon code, also from Github this time.\n\n Transaction handling for minidump\n\n There could be other locations that code are pasted that were not recognised.\n\n The COFF Loader is a bog-standard copy-paste of the implementation by TrustedSec with slight modifications. This can be confirmed by looking at the tail end of the code.\n\n Decompiled COFF Loader cleanup - top: IDA decompilation of Brute Ratel, bottom: code from TrustedSec's repository\n\n Indeed, another licence violation - as far as this author is aware the condition that \"redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution\" was not met.\n\n\n-----\n\n### SOCKs proxy\n\n#### Brute ratel has a SOCKs proxy implementation. There is not much that is notable about this, other than that it can use an alternative profile for transmitting data as opposed to the primary communication profile.\n\n Decrypt-and-Encrypt for forwarding\n\n### TCP/SMB Listener\n\n#### Brute Ratel implements a TCP/SMB listener that forwards data from a pipe/socket back to the host. Strangely, the author designed it so that data is decrypted by the payload prior to sending to the C2. The likely reason is, as was suspected of many other design choices, a severe lack of critical thinking.\n\n Decrypt-and-Encrypt for forwarding\n\n### Sleep-encrypt\n\n#### Sleep-encrypt has two mode, one we will call \"apc-driven\" and the other \"timer-driven\". Both share the similarity of suspending a random thread and stealing its CONTEXT for the purpose of generating fake CONTEXT strugtures. A second thread has a series of APCs that sets the code to RW, encrypts it, applies this fake CONTEXT to the main thread, sleep, restores the CONTEXT, and then decrypt the code and set it back to RX. A pseudocode of the chain follows:\n\n WaitForSingleObject(wait_event)\nNtProtectVirtualMemory(rw)\nCryptEncrypt(x) GetContextThread(primary, backup_ctx)\nSetContextThread(primary, cloned_ctx) WaitForSingleObjectEx(wait_event, wait_time) //will time out when sleep is over CryptDecrypt(x)\nNtProtectVirtualMemory(rx)\nSetContextThread(primary, backup_ctx)\n\n The difference lies in the trigger method. The timer uses the pair of RtlCreateTimer/RtlRegisterWait to set this chain up and execute it, whereas the other utilises NtQueueApcThread to do so. Both take place inside a fiber.\n\n Sleep logic\n\n## Detection recommendation\n\n#### The following section will be limited to basic immediately observable detections, as the author of the malware will likely read the post and tweak things based on the detection recommendations mentioned here.\n\n### Network\n\n\n-----\n\n#### The DoH beaconing behaviour is easily detectable, the pattern is rather unique. This can be done using the information provided above.\n\n### Endpoint\n\n#### Various methods can be used to detect Brute Ratel from an endpoint perspective, however these will be left out to avoid the malware author from realising things that he could not have realised on his own. The shameless self promotion section has more on access to such information.\n\n## Final notes\n\n#### Those are the most notable implementation details one would find reverse engineering Brute Ratel. Overall, we find an unimaginatively copy-pasted mess, with fundamental knowledge one would expect a software engineer (let alone one who is security conscious) to have to be missing, not to mention basic concepts such as \"not breaking software licences\" to be missing. It is not atypical for malware developers to not pay attention to these as they focus only on their own bottom line and not much more, even when labelled \"legitimate red team\" offerings.\n\n Shameless self promotion starts here\n\n For access to the fully labelled IDBs and code utilized in the process of reverse engineering Brute Ratel, join the Discord server and DM me for more information about subscription (yes, it is paid). Tired of doing reverse engineering for your job and want to offload it to someone who has the ability to stare at IDA Pro for 18 hours without standing up? We can arrange that too. You can also find me on Twitter and get notifications of upcoming streams and new posts there. Are you a competitor of Brute Ratel who enjoyed watching your competition being ripped apart? You can be next too, don't fret, but you should subscribe to the Patreon anyways to support the work of an independent reverse engineer. Feel free as well to toss a coin to your boymoder @ bc1qen9sqx4c3tyuz90ucflh8tfs2ljmskh9x8zcht if the traditional finance system is not your cup of tea.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-03-06 - Brute Ratel - Scandinavian Defence.pdf"
    ],
    "report_names": [
        "2023-03-06 - Brute Ratel - Scandinavian Defence.pdf"
    ],
    "threat_actors": [
        {
            "id": "dfee8b2e-d6b9-4143-a0d9-ca39396dd3bf",
            "created_at": "2022-10-25T16:07:24.467088Z",
            "updated_at": "2025-03-27T02:02:10.241387Z",
            "deleted_at": null,
            "main_name": "Circles",
            "aliases": [],
            "source_name": "ETDA:Circles",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "08c8f238-1df5-4e75-b4d8-276ebead502d",
            "created_at": "2023-01-06T13:46:39.344081Z",
            "updated_at": "2025-03-27T02:00:03.056208Z",
            "deleted_at": null,
            "main_name": "Copy-Paste",
            "aliases": [],
            "source_name": "MISPGALAXY:Copy-Paste",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "6e23ce43-e1ab-46e3-9f80-76fccf77682b",
            "created_at": "2022-10-25T16:07:23.303713Z",
            "updated_at": "2025-03-27T02:02:09.727245Z",
            "deleted_at": null,
            "main_name": "ALPHV",
            "aliases": [
                "ALPHV",
                "ALPHVM",
                "BlackCat Gang",
                "UNC4466"
            ],
            "source_name": "ETDA:ALPHV",
            "tools": [
                "ALPHV",
                "ALPHVM",
                "BlackCat",
                "GO Simple Tunnel",
                "GOST",
                "Impacket",
                "LaZagne",
                "MEGAsync",
                "Mimikatz",
                "Munchkin",
                "Noberus",
                "PsExec",
                "Remcom",
                "RemoteCommandExecution",
                "WebBrowserPassView"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1680660593,
    "ts_updated_at": 1743041726,
    "ts_creation_date": 1680510758,
    "ts_modification_date": 1680510758,
    "files": {
        "pdf": "https://archive.orkl.eu/7a4a2de5d5a268da12147648244971ce57316ce1.pdf",
        "text": "https://archive.orkl.eu/7a4a2de5d5a268da12147648244971ce57316ce1.txt",
        "img": "https://archive.orkl.eu/7a4a2de5d5a268da12147648244971ce57316ce1.jpg"
    }
}