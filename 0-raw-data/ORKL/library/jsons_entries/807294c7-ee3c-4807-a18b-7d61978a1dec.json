{
    "id": "807294c7-ee3c-4807-a18b-7d61978a1dec",
    "created_at": "2023-01-12T15:07:10.279106Z",
    "updated_at": "2025-03-27T02:05:34.193629Z",
    "deleted_at": null,
    "sha1_hash": "0cadb70c09689350c96469f72f57ce43b40e9b94",
    "title": "2022-08-25 - SmokeLoader Triage Taking a look how Smoke Loader works",
    "authors": "",
    "file_creation_date": "2022-09-01T10:30:29Z",
    "file_modification_date": "2022-09-01T10:30:29Z",
    "file_size": 413243,
    "plain_text": "# SmokeLoader Triage\n\n**[research.openanalysis.net/smoke/smokeloader/loader/config/yara/triage/2022/08/25/smokeloader.html](https://research.openanalysis.net/smoke/smokeloader/loader/config/yara/triage/2022/08/25/smokeloader.html)**\n\nOALABS Research August 25, 2022\n\n## Overview\n\n### Samples\n\n#### Packed parent cef4f5f561b5c481c67e0a9a3dd751d18d696b61c7a5dab5ebb29535093741b4 Unpacked SmokeLoader 041a05dd902a55029449bf412cedbe59a593f8d4e67d4ae37cf7a928c92f22ca\n\n### SmokeLoader Background\n\n#### This SmokeLoader sample is on MalwareBazaarand through sandbox runs we know that is was used to download Vidar. From JoeSandbox public report we know we should find the following config in this loader\n```\n{\n\n \"C2 list\": [\n\n  \"http://piratia.su/tmp/\",\n\n  \"http://piratia-life.ru/tmp/\",\n\n  \"http://diewebseite.at/tmp/\",\n\n  \"http://faktync.com/tmp/\",\n\n  \"http://mupsin.ru/tmp/\",\n\n  \"http://aingular.com/tmp/\",\n\n  \"http://mordo.ru/tmp/\"\n\n ]\n\n}\n\n\n### References\n\n#### Deep Analysis of SmokeLoader Historical Changes and Trends (Marcos Alvares)\n\n## Stage 2\n\n### Opaque predicate deobfuscation\n\n#### From this blog we have a simple jmp fix script.\n\n```\n\n-----\n\n```\nimport idc\n\nea = 0\n\nwhile True:\n\n  ea = min(idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, \"74 ? 75 ?\"), #\nJZ / JNZ\n\n       idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, \"75 ? 74 ?\")) #\nJNZ / JZ\n\n  if ea == idc.BADADDR:\n\n    break\n\n  idc.patch_byte(ea, 0xEB)  # JMP\n\n  idc.patch_byte(ea+2, 0x90) # NOP\n\n  idc.patch_byte(ea+3, 0x90) # NOP\n\n``\n\nOnce we fix the jmps we need to nop out the junk code between the code to allow IDA\nto convert this into a function\n\n```python\n\nimport idaapi\n\n\nstart = 0x00402DDD\n\nend = 0x00402EBF\n\nptr = start\n\nwhile ptr <= end:\n\n  next_ptr = next_head(ptr)\n\n  junk_bytes = next_ptr - ptr\n\n  if ida_bytes.get_bytes(ptr, 1) == b'\\xeb':\n\n    idaapi.patch_bytes(ptr, junk_bytes * b'\\x90')\n\n  ptr = next_ptr\n\n#### Or, we could use this excellent script from @anthonyprintup\n\n```\n\n-----\n\n```\nimport ida_ua\n\nimport ida_name\n\nimport ida_bytes\n\n\ndef decode_instruction(ea: int) -> ida_ua.insn_t:\n\n  instruction: ida_ua.insn_t = ida_ua.insn_t()\n\n  instruction_length = ida_ua.decode_insn(instruction, ea)\n\n  if not instruction_length:\n\n    return None\n\n  return instruction\n\n\ndef main():\n\n  begin: int = ida_name.get_name_ea(idaapi.BADADDR, \"start\")\n\n  end: int = begin + 0xE2\n\n  instructions: dict[int, ida_ua.insn_t] = {}\n\n  # Undefine the current code\n\n  ida_bytes.del_items(begin, 0, end)\n\n  # Follow the control flow and create instructions\n\n  instruction_ea: int = begin\n\n  while instruction_ea <= end:\n\n    if instruction_ea not in instructions.keys():\n\n      instruction: ida_ua.insn_t = ida_ua.insn_t()\n\n      instruction_length: int = ida_ua.create_insn(instruction_ea, instruction)\n\n    else:\n\n      instruction: ida_ua.insn_t = decode_instruction(instruction_ea)\n\n      instruction_length: int = instruction.size\n\n    if not instruction_length:\n\n      print(f\"Failed to create an instruction at address {instruction_ea=:#x}\")\n\n      return\n\n    # Append the current instruction address to the list\n\n    instructions[instruction.ip] = instruction\n\n    # Handle unconditional jumps\n\n    current_instruction_mnemonic: str = instruction.get_canon_mnem()\n\n    next_instruction: ida_ua.insn_t | None = decode_instruction(instruction_ea +\ninstruction.size)\n\n    if next_instruction is not None:\n\n      next_instruction_mnemonic: str = next_instruction.get_canon_mnem()\n\n      if (current_instruction_mnemonic == \"jnz\" and next_instruction_mnemonic\n== \"jz\") or \\\n\n          (current_instruction_mnemonic == \"jz\" and\nnext_instruction_mnemonic == \"jnz\"):\n\n        # Unconditional jump detected\n\n        assert instruction.ops[0].type == ida_ua.o_near\n\n        instruction_ea = instruction.ops[0].addr\n\n\n```\n\n-----\n\n```\n        ida_ua.create_insn(next_instruction.ip)\n\n        instructions[next_instruction.ip] = next_instruction\n\n        continue\n\n    if current_instruction_mnemonic == \"jmp\":\n\n      assert instruction.ops[0].type == ida_ua.o_near\n\n      instruction_ea = instruction.ops[0].addr\n\n    else:\n\n      instruction_ea += instruction.size\n\n  # NOP the remaining instructions\n\n  for ea in range(begin, end):\n\n    skip: bool = False\n\n    for _, instruction in instructions.items():\n\n      if ea in range(instruction.ip, instruction.ip + instruction.size):\n\n        skip = True\n\n        break\n\n    if skip:\n\n      continue\n\n    # Patch the address\n\n    ida_bytes.patch_bytes(ea, b\"\\x90\")\n\n\nif __name__ == \"__main__\":\n\n  main()\n\n#### After this we can see that the next function address is built using some stack/ret manipulation.\n\n### Function Decryption\n\n#### Some functions are encrypted. We can find the first one by following the obfuscated control flow until the first call . This call calls into a function which then calls the decryption function. The decryption function takes a size and a offset to the function that needs to be decrypted. The size is placed in the ecx register, and the function offset follows the call.\nmov   ecx, 0E7h ; 'รง\n\n The decryption itself is a single byte xor but the decryption key is moved into the edx register as a full DWORD (we only used the LSB).\nmov   edx, 76186250h\n\n From this blog we have a simple deobfuscation script updated for our sample. This script didn't perform well for some reason so we ended up manually decrypting the functions!\n\n```\n\n-----\n\n```\nimport idc\n\nimport idautils\n\ndef xor_chunk(offset, n):\n\n  ea = 0x400000 + offset\n\n  for i in range(n):\n\n    byte = ord(idc.get_bytes(ea+i, 1))\n\n    byte ^= 0x50\n\n    idc.patch_byte(ea+i, byte)\n\n\ndef decrypt(xref):\n\n  call_xref = list(idautils.CodeRefsTo(xref, 0))[0]\n\n  while True:\n\n    if idc.print_insn_mnem(call_xref) == 'push' and\nidc.get_operand_type(call_xref, 0) == idaapi.o_imm:\n\n      n = idc.get_operand_value(call_xref, 0)\n\n      break\n\n    if idc.print_insn_mnem(call_xref) == 'mov' and\nidc.get_operand_type(call_xref, 1) == idaapi.o_imm:\n\n      n = idc.get_operand_value(call_xref, 1)\n\n      break\n\n    call_xref = prev_head(call_xref)\n\n  n = idc.get_operand_value(call_xref, 0)\n\n  offset = (xref + 5) - 0x400000\n\n  xor_chunk(offset, n)\n\n  idc.create_insn(offset+0x400000)\n\n  ida_funcs.add_func(offset+0x400000)\n\n\n\nxor_chunk_addr = 0x00401118 # address of the xoring function\n\ndecrypt_xref_list = idautils.CodeRefsTo(xor_chunk_addr, 0)\n\nfor xref in decrypt_xref_list:\n\n  decrypt(xref)\n\n### API Hashing\n\n#### According to this blog we are expecting to see some API hashing using the djb2 algorithm. We can try to find this function by searching for the constant 0x1505.\n\n Though the djb2 algorithm is used for the API hashing the API hashes have some further obfuscation that prevents them from being resolved directly .... TODO\n\n```\n\n-----\n\n```\nimport requests\n\nhash = 812437175\n\ndef hash_djb2(s):                                  \n\n  hash = 5381\n\n  for x in s:\n\n    hash = (( hash << 5) + hash) + x\n\n  return hash & 0xFFFFFFFF\n\n\nTEST_1 = 1555243728\n\ntest = b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n\nprint(hash_djb2(test))\n\napi_name = b'CopyFileW\\x00'\n\napi_hash = 0x306cceb7\n\n\n\nprint(hex(hash_djb2(api_name)))\n\n205455184\n\n0x306cceb7\n\n## Extract Stage 3\n\n#### There is a 32-bit and a 64-bit version of stage 3 stored consecutivly in the binary. In older versions of the loader these stages where simply compressed with LZN1 but in this version there appears to be another step that is missing... TODO\n\n```\n\n-----\n\n```\ndata_string \n'5058187647a21889fa5d103a51605c8eb0621a575b63149f64673087b5753166bb323066f2465570508c1\n\ndata_string =\n'5036187647a21889fa5d1e12d6615c8ea0623a565b60149f1a8e1e471479b89d409f9877506c1a7a74460\n\ndef unhex(hex_string):\n\n  import binascii\n\n  if type(hex_string) == str:\n\n    return binascii.unhexlify(hex_string.encode('utf-8'))\n\n  else:\n\n    return binascii.unhexlify(hex_string)\n\n\ndata = unhex(data_string)\n\nimport struct\n\ndef decrypt_dw(data, dw):\n\n  out = b''\n\n  for i in range(0,(len(data)//4)*4,4):\n\n    tmp = struct.unpack('<I', data[i:i+4])[0]\n\n    out += struct.pack('<I', tmp ^ dw)\n\n  return out\n\n\nout = decrypt_dw(data, 0x76186250)\n\nout2 = []\n\nfor c in out:\n\n  out2.append(c^ 0x50)\n\n\nimport malduck\n\nptxt_data = malduck.lznt1(bytes(out2))\n\nprint(ptxt_data)\n\n#open('/tmp/out.bin','wb').write(ptxt_data)\n\nb''\n\n## Stage 3\n\n#### @doomedraven\n\n i need to leave in 3rd stage there is a cnc table, just search in 3rd stage for immediate value of 1000 and you will be pretty close to the table\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-25 - SmokeLoader Triage Taking a look how Smoke Loader works.pdf"
    ],
    "report_names": [
        "2022-08-25 - SmokeLoader Triage Taking a look how Smoke Loader works.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536030,
    "ts_updated_at": 1743041134,
    "ts_creation_date": 1662028229,
    "ts_modification_date": 1662028229,
    "files": {
        "pdf": "https://archive.orkl.eu/0cadb70c09689350c96469f72f57ce43b40e9b94.pdf",
        "text": "https://archive.orkl.eu/0cadb70c09689350c96469f72f57ce43b40e9b94.txt",
        "img": "https://archive.orkl.eu/0cadb70c09689350c96469f72f57ce43b40e9b94.jpg"
    }
}