{
    "id": "4a231ff8-64d2-42b3-8d53-d1ccf757d346",
    "created_at": "2023-01-12T15:00:37.115461Z",
    "updated_at": "2025-03-27T02:05:43.262611Z",
    "deleted_at": null,
    "sha1_hash": "d9647916d06a43473269564d11f8d8d17598d28e",
    "title": "2020-08-23 - Programmatically NOP the Current Selection in Ghidra",
    "authors": "",
    "file_creation_date": "2022-05-29T01:19:31Z",
    "file_modification_date": "2022-05-29T01:19:31Z",
    "file_size": 227617,
    "plain_text": "# Programmatically NOP the Current Selection in Ghidra\n\n**[blag.nullteilerfrei.de/2020/08/23/programmatically-nop-the-current-selection-in-ghidra/](https://blag.nullteilerfrei.de/2020/08/23/programmatically-nop-the-current-selection-in-ghidra/)**\n\nborn\n\nThe Zlob malware contains lots of bogus API calls to hinder analysis. This blag post\ndescribes how to use a script in Ghidra to automate the process of patching out those calls\nwith `NOP instructions. The malware employs some basic obfuscation techniques, one of`\nwhich is performing lots of API calls without side effects. This makes both the disassembly as\nwell as the decompile view hard to read. The following excerpts where take from a random\nsample belonging to this family (SHA256 hash\n```\n0b38ca277bbb042d43bd1f17c4e424e167020883526eb2527ba929b2f0990a8f ):\nff d5 | CALL EBP=>KERNEL32.DLL::GetCurrentThreadId\nff d5 | CALL EBP=>KERNEL32.DLL::GetCurrentThreadId\nff d6 | CALL ESI=>KERNEL32.DLL::GetLastError   \nff d7 | CALL EDI=>KERNEL32.DLL::GetConsoleCP   \nff d6 | CALL ESI=>KERNEL32.DLL::GetLastError   \nff d6 | CALL ESI=>KERNEL32.DLL::GetLastError   \nff d6 | CALL ESI=>KERNEL32.DLL::GetLastError   \nff d7 | CALL EDI=>KERNEL32.DLL::GetConsoleCP   \nff d6 | CALL ESI=>KERNEL32.DLL::GetLastError   \nff d7 | CALL EDI=>KERNEL32.DLL::GetConsoleCP   \nff d6 | CALL ESI=>KERNEL32.DLL::GetLastError   \n\n```\nAnd the corresponding decompile view:\n```\nGetCurrentThreadId();\nGetCurrentThreadId();\nGetLastError();\nGetConsoleCP();\nGetLastError();\nGetLastError();\nGetLastError();\nGetConsoleCP();\nGetLastError();\nGetConsoleCP();\nGetLastError();\n[...]\n\n```\nYou can \"just\" hit F2 on every call (and the following byte) to replace it with the `NOP`\ninstruction ( 0x90 ) but this is a more than tedious process. Let's write a handy script to\nautomate this:\n\n\n-----\n\n```\npublic void run() throws Exception {\n  if (currentSelection != null) {\n    AddressRangeIterator addressRanges = currentSelection.getAddressRanges(true);\n    for (AddressRange addressRange : addressRanges) {\n      nopOut(addressRange.getMinAddress(), addressRange.getLength());\n    }\n  }\n}\nprivate void nopOut(Address addressStart, long length) throws CancelledException,\nMemoryAccessException {\n  clearListing(addressStart, addressStart.add(length));\n  for (int i = 0; i < length; i++) {\n    Address address = addressStart.add(i);\n    setByte(address, (byte) 0x90);\n  }\n  disassemble(addressStart);\n}\n\n```\nIf you assign this script to the keyboard shortcut Ctrl-Alt-Shift-N for example, you can just\nselect regions of disassembly and hit that combination to replace everything with `NOP . ## A`\ntiny plot-twist Since selecting calls in the decompile view will also highlight disassembly, one\nmight think that you can as easily select region of the decompile view, execute the same\nscript and come to the same result. Sadly this is not the case: If you select a line in the\ndecompile view, the corresponding selection in the disassembly will always only have length\n1.\n\nWhile one might think that in the screenshot above, the selection in the disassembly has a\nlenght of 6 and ranges from 0x10003a34 to 0x10003a3a (exclusively) it is in fact three\nselections, each of length 1 starting at `0x10003a34,` `0x10003a36 and,` `0x10003a38 .`\nExecuting the above script will hence result in the byte sequence `90 d3 90 d3 90 d3`\nwhich cannot even be disassembled. So let's not pass in `addressRange.getLength() into`\nthe `nopOut function but instead extend the length such that the last instruction is always`\nincluded completely:\n\n\n-----\n\n```\n/\n * Searchers backwards for the last assembly instruction and returns the length\n * of the address range, potentially extended to fully include this last\n * instruction.\n */\nprivate long assemblyAlignedLength(AddressRange addressRange) {\n     long length = addressRange.getLength();\n     for (int i = 1; i <= MAX_ASSEMBLY_INSTRUCTION_LENGTH; i++) {\n          Instruction instruction =\ngetInstructionAt(addressRange.getMinAddress().add(length - i));\n          if (instruction != null) {\n              return length + (instruction.getLength() - i);\n          }\n     }\n     return length;\n}\n\n```\n[You can find the complete nts.java script on github!](https://github.com/nullteilerfrei/reversing-class/blob/master/scripts/java/NopThisShit.java)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-08-23 - Programmatically NOP the Current Selection in Ghidra.pdf"
    ],
    "report_names": [
        "2020-08-23 - Programmatically NOP the Current Selection in Ghidra.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535637,
    "ts_updated_at": 1743041143,
    "ts_creation_date": 1653787171,
    "ts_modification_date": 1653787171,
    "files": {
        "pdf": "https://archive.orkl.eu/d9647916d06a43473269564d11f8d8d17598d28e.pdf",
        "text": "https://archive.orkl.eu/d9647916d06a43473269564d11f8d8d17598d28e.txt",
        "img": "https://archive.orkl.eu/d9647916d06a43473269564d11f8d8d17598d28e.jpg"
    }
}