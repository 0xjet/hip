{
    "id": "788d9595-6b71-4a88-b6ce-6c1c1c2b9abc",
    "created_at": "2023-01-12T15:05:32.256114Z",
    "updated_at": "2025-03-27T02:05:44.409161Z",
    "deleted_at": null,
    "sha1_hash": "f824a7af02a8cfb442b381636876e10c1db714bf",
    "title": "2022-08-15 - Malware sandbox evasion in x64 assembly by checking ram size - Part 2",
    "authors": "",
    "file_creation_date": "2022-09-01T10:10:26Z",
    "file_modification_date": "2022-09-01T10:10:26Z",
    "file_size": 370014,
    "plain_text": "# Malware sandbox evasion in x64 assembly by checking ram size - Part 2\n\n**[accidentalrebel.com/malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2.html](https://www.accidentalrebel.com/malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2.html)**\n\n## AccidentalRebel.com\n\nKarlo is a programmer for 10+ years who switched to cyber security. He is currently working\nas a L2 SOC Analyst and is focusing on malware reverse engineering and development.\n\nIn the [previous post, I explored a sandbox evasion technique that uses](https://www.accidentalrebel.com/malware-sandbox-evasion-in-x64-assembly-by-checking-ram-size-part-2.html)\n```\n GetPhysicallyInstalledSystemMemory to check the size of the RAM of the machine.\n\n```\n[The idea behind this technique (MBC Technique ID: B0009.014) is that any value that is](https://github.com/MBCProject/mbc-markdown/blob/master/anti-behavioral-analysis/virtual-machine-detection.md)\nlower than 4GB may probably be a sandbox (to reduce costs). This information can then be\nused with other sandbox evasion techniques to confirm.\n\nFor part 2 of this series, I'll be talking about an alternative Windows API function called\n```\n GlobalMemoryStatusEx . This function is as straightforward as the first one, but requires\n\n```\nthe passing of a pointer to a C struct. This is significant because I'll be converting a working\nC code to x64 assembly so we can fully understand how it works under the hood.\n\n## Using GlobalMemoryStatusEx\n\nHere is an example of an implementation of `GlobalMemoryStatusEx in C that we'll later`\nbe converting to x64 assembly.\n\n\n-----\n\n```\n#include <stdio.h>\n\n#include <windows.h>\n\nint main(void)\n\n{\n\n  MEMORYSTATUSEX statex;\n\n  statex.dwLength = sizeof (statex);\n\n  GlobalMemoryStatusEx (&statex);\n\n  printf (\"Memory size: %*I64d\", 7, statex.ullTotalPhys/1024);\n\n}\n\n```\nYou will see that the first parameter for `GlobalMemoryStatusEx is expecting a pointer to a`\n```\nMEMORYSTATUSEX object. We need to declare the memory location statex by putting it\n\n```\nonto the stack. Before we can do that, however, we first need to know beforehand how\nmuch we would need to reserve.\n\n## Getting the size of the struct\n\nFinding out the size of a structure in C is easy with the `sizeof function. However, we`\ncan't really use this in assembly, so we have to determine it manually by adding up the\nsizes of each member of the struct.\n\nConsider the example struct definition below:\n```\nstruct TestStruct {\n\n  char member1;\n\n  int member2;\n\n  float member3;\n\n};\n\n```\nIf we would look at [this table containing the fundamental types and their sizes, we could](https://docs.microsoft.com/en-us/cpp/cpp/fundamental-types-cpp?view=msvc-170#sizes-of-built-in-types)\ndetermine the sizes of each member:\n```\n   member1 is of type char which has a size of 1 byte\n   member2 is of type int which is 4 bytes\n   member3 is of type float which also is 4 bytes\n\n```\nAdding all of these sizes results in `TestStruct having a total size of 9 bytes.`\n\nNow to apply the same computation to our `MEMORYSTATUSEX struct. Here is the definition`\nof the struct [according to MSDN:](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/ns-sysinfoapi-memorystatusex)\n\n\n-----\n\n```\ntypedef struct _MEMORYSTATUSEX {\n\n DWORD   dwLength;\n\n DWORD   dwMemoryLoad;\n\n DWORDLONG ullTotalPhys;\n\n DWORDLONG ullAvailPhys;\n\n DWORDLONG ullTotalPageFile;\n\n DWORDLONG ullAvailPageFile;\n\n DWORDLONG ullTotalVirtual;\n\n DWORDLONG ullAvailVirtual;\n\n DWORDLONG ullAvailExtendedVirtual;\n\n} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;\n\n```\nThe types that we have are `DWORD and` `DWORDLONG (which is just Window's own version`\nof `unsigned long and` `unsigned int64 ):`\n```\n   DWORD or unsigned long has a size of 4 bytes\n   DWORDLONG or unsigned int64 has a size of 8 bytes\n\n```\nSo adding the two `DWORD s and seven` `DWORDLONG s results in` `MEMORYSTATUSEX having a`\ntotal size of 64 bytes.\n\n## Initializing statex\n\nNow that we know the total size, we can now reserve this amount of space on the stack.\n```\n  sub rsp, 0x40  ; Reserve space for struct on stack\n\n          ; MEMORYSTATUSEX's is 64 bytes (0x40) in size\n\n\n```\nBefore we can call `GlobalMemoryStatusEx, however,` [MSDN states that the](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/ns-sysinfoapi-memorystatusex) `dwLength`\nmember should be first set. And this can be done by assigning 64 bytes to the\ncorresponding memory location on the stack.\n```\n  mov rax, 0x40 \n\n  mov [rsp], rax ; Assign 0x40 to dwLength\n\n  lea rcx, [rsp] ; Load the memory location of struct\n\n\n```\nWith this we can finally call our function:\n```\n  sub rsp, 32   ; Reserve shadow space\n\n  call  GlobalMemoryStatusEx\n\n  add rsp, 32   ; Release shadow space\n\n\n## Using the result\n\n```\nIf successful, the function `GlobalMemoryStatusEx populates the memory location we`\npassed to it, as shown below:\n\n\n-----\n\nThe struct member `ullTotalPhys now has the memory size that we need. And because`\nour stack pointer still points to the beginning of the struct, we can get this value by adding\nan offset to `rsp .`\n```\n  mov rax, [rsp+0x8] ; Retrive value of ullTotalPhys from stack\n\n\n```\nWe offset by `0x8 because the first 8 bytes is assigned to` `dwLength and` `dwMemoryLoad`\n(both at 4 bytes each).\n\n## Displaying the result\n\nAs seen above, the value returned by `GlobalMemoryStatusEx is in bytes. To be`\nconsistent with our example from the previous post, we need to convert this value to\nkilobytes by dividing it by `1024 .`\n```\n  mov rcx, 1024\n\n  xor rdx, rdx  ; Clear rdx; This is required before calling div\n\n  div rcx     ; Divide by 1024 to convert to KB\n\n\n```\nThe result of the above operation is saved to `rax which we can then move to` `rdx so we`\ncan pass it as the second argument to `printf .`\n```\n  mov rdx, rax  ; Argument 2; Result of ullTotalPhys / 1024\n\n  lea rcx, [msg_memory_size] ; Argument 1; Format string\n\n  sub rsp, 32   ; Reserve shadow space\n\n  call  printf\n\n  add rsp, 32   ; Release shadow space\n\n\n```\nWith this, we can now finally display the result on the console:\n\n\n-----\n\nHere is the full source code for reference:\n```\n  bits 64\n\n  default rel\n\nsegment .data\n\n  msg_memory_size db \"Memory size: %lld\", 0xd, 0xa, 0\n\nsegment .text\n\n  global main\n\n  extern ExitProcess\n\n  extern GlobalMemoryStatusEx\n\n  extern printf\n\nmain:\n\n  push  rbp\n\n  mov   rbp, rsp\n\n  sub rsp, 0x40  ; Reserve space for struct on stack\n\n          ; MEMORYSTATUSEX's is 64 bytes (0x40) in size\n\n  mov rax, 0x40 \n\n  mov [rsp], rax ; Assign 0x40 to dwLength\n\n  lea rcx, [rsp] ; Load the memory location of struct\n\n  sub rsp, 32   ; Reserve shadow space\n\n  call  GlobalMemoryStatusEx\n\n  add rsp, 32   ; Release shadow space\n\n  mov rax, [rsp+0x8] ; Retrive value of ullTotalPhys from stack\n\n  mov rcx, 1024\n\n  xor   rdx, rdx  ; Clear rdx; This is required before calling div\n\n  div rcx   ; Divide by 1024 to convert to KB\n\n  mov rdx, rax  ; Argument 2; Result of ullTotalPhys / 1024\n\n  lea rcx, [msg_memory_size] ; Argument 1; Format string\n\n  sub rsp, 32   ; Reserve shadow space\n\n  call  printf\n\n  add rsp, 32   ; Release shadow space\n\n  add rsp, 0x40  ; Release space of struct from stack\n\n  xor   rax, rax\n\n  call  ExitProcess\n\n\n## Conclusion\n\n```\nOver the past two blog posts, we've learned how to use `GlobalMemoryStatusEx and`\n```\nGetPhysicallyInstalledSystemMemory to determine the size of the RAM of a machine.\n\n```\nWe've also learned about using the stack to pass arguments to functions using x64\nassembly\n\n\n-----\n\nIn future posts I plan to continue exploring malware behavior and techniques and at the\nsame time teach x64 assembly so that we can both improve when writing and reverse\nengineering malware.\n\nUntil then, you can view the C and Assembly code along with the build scripts for this\n[evasion technique on this repository here.](https://github.com/accidentalrebel/sandbox-evasion-by-checking-ram-size)\n\n[Feel free to reach out to me on Twitter or](https://twitter.com/accidentalrebel) [LinkedIn for any questions or comments.](https://www.linkedin.com/in/juan-karlo-licudine/)\n\n## Comments\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-08-15 - Malware sandbox evasion in x64 assembly by checking ram size - Part 2.pdf"
    ],
    "report_names": [
        "2022-08-15 - Malware sandbox evasion in x64 assembly by checking ram size - Part 2.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535932,
    "ts_updated_at": 1743041144,
    "ts_creation_date": 1662027026,
    "ts_modification_date": 1662027026,
    "files": {
        "pdf": "https://archive.orkl.eu/f824a7af02a8cfb442b381636876e10c1db714bf.pdf",
        "text": "https://archive.orkl.eu/f824a7af02a8cfb442b381636876e10c1db714bf.txt",
        "img": "https://archive.orkl.eu/f824a7af02a8cfb442b381636876e10c1db714bf.jpg"
    }
}