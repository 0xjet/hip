{
    "id": "11d795b7-7122-46e9-85f1-700cb9b328d2",
    "created_at": "2022-10-25T16:48:13.19515Z",
    "updated_at": "2025-03-27T02:08:41.046091Z",
    "deleted_at": null,
    "sha1_hash": "084a9458973c1c5996891b4713249fe19b432139",
    "title": "carrer_erdelyiVB2004.pmd",
    "authors": "",
    "file_creation_date": "2004-10-06T09:54:04Z",
    "file_modification_date": "2004-10-06T09:54:04Z",
    "file_size": 885711,
    "plain_text": "# DIGITDIGITDIGITAL GENOME MAPPING –DIGITDIGITAL GENOME MAPPING –AL GENOME MAPPING –AL GENOME MAPPING –AL GENOME MAPPING – ADVADVADVANCED BINARADVADVANCED BINARANCED BINARANCED BINARY MALANCED BINARY MALY MALY MALWY MALWWWAREWAREAREAREARE ANALANALANALYSISANALANALYSISYSISYSISYSIS\n\nEro Carrera and Gergely Erdélyi\nF-Secure Corporation Anti-Virus Research Team,\nTammasaarenkatu 7, 00181, Helsinki, Finland\n\nTel +358 9 2520 0700 • Fax +358 9 2520 5001•\nEmail ero.carrera@f-secure.com •\ngergely.erdelyi@f-secure.com\n\n## ABSTRACTABSTRACTABSTRACTABSTRACTABSTRACT\n\nWindows binary malware has come a long way. Today’s\naverage worm is often tens or hundreds of kilobytes of\ncode exhibiting a level of complexity that surpasses\neven some operating systems. This degree of complexity,\ncoupled with the overwhelming flow of new malware,\ncalls for improvements to tools and techniques used\nin analysis.\n\nOur paper elaborates on how to use graph theory to aid the\nanalysis. Using graphs and extensions with the popular\nInteractive Disassembler Pro package, we hope to reduce\nthe time needed to understand the structure of complex\nmalware. These methods have proven to be helpful in\nfinding similarities and differences between different\nmalware variants and strains.\n\nFocusing on the differences by keeping off already known\ncode allows rapid analysis and classification of malware,\nwhile reducing redundant efforts.\n\n## 1. INTRODUCTION1. INTRODUCTION1. INTRODUCTION1. INTRODUCTION1. INTRODUCTION\n\nNowadays, reverse engineers – especially those within the\nanti-virus and forensics industries – face the challenge of\nidentifying and analysing a large number of binaries\nappearing at an incredible rate.\n\nSome of the difficulties analysts face are:\n\n - The sheer number of samples to check.\n\n - The amount of code to analyse on each of them.\n\n - Recognizing variants and versions of families of\nmalware and other software.\n\nMost of those problems can be solved with proper\nautomation and algorithms. Ideas and results from\nprototypes will be presented in this paper. We are\nintroducing a new platform based on Interactive\nDisassembler Pro and the Python programming language.\nThe aim is to aid development of research prototypes and\nadvanced analysis.\n\nThe resulting tools will be targeted to recognize similar\nfeatures in the structure of executables. The theoretical\nbase we rely on to achieve our objective will be graph\ntheory, by looking at representations of code in the form of\ngraphs. With them, the necessary level of abstraction is\n\n\nachieved and general features in the structure of a binary\nbecome distinguishable.\n\n## 2. PROGRAMMING IDA PRO2. PROGRAMMING IDA PRO2. PROGRAMMING IDA PRO2. PROGRAMMING IDA PRO2. PROGRAMMING IDA PRO\n\nPeople who perform analysis of binary code tend to collect\nand use a large arsenal of different tools. Apart from a\ngood hex editor, probably the most commonly used tool is\nInteractive Disassembler Pro (IDA) [1]. IDA has earned its\nreputation by being extremely versatile, flexible and\nextensible. The already remarkable set of features IDA has\ncan be further expanded with the built-in script language\nand compiled plugins. In the next section we will take a\nbrief look at both extension methods.\n\n## 2.1 I2.1 I2.1 IDC2.1 I2.1 IDCDCDCDC\n\nThe easy way to get started with IDA programming is\nIDC, the scripting language of IDA. The syntax of IDC is\nvery similar to ANSI C, which makes it familiar for\nexperienced C programmers. Unlike C, IDC is an\ninterpreted language which saves us from the tedious\nwrite-compile-fix development cycle of C.\n\nIDC comes with an extensive set of built-in functions that\ncover many aspects of the disassembly process as well as\nthe structure and data of the program being disassembled.\nThe semantics of all those functions are, not too\nsurprisingly, close to regular C functions.\n\nThe following simple program is an example of IDC code.\nIt is a trivial decryptor that uses XOR 0xFF to decrypt a\nzero-terminated ASCII string, starting from the current\ncursor position.\n\n#include <idc.idc>\n\nstatic main ()\n{\nauto baseaddr;\nauto key;\nauto c;\n\nbaseaddr = ScreenEA();\nkey = 0xFF;\n\nwhile (1)\n{\nc = Byte(baseaddr);\n\nif (c == 0) { break; }\n\nPatchByte(baseaddr, c ^ key);\nbaseaddr++;\n}\n}\n\n## 2.2 Plugins2.2 Plugins2.2 Plugins2.2 Plugins2.2 Plugins\n\nIn case the required code exceeds the capabilities of IDC\nwe can resort to writing an IDA plugin. The SDK comes\nwith IDA and defines an extensive API for plugins. Unlike\nIDC the API gives access even to the most intimate details\nof the IDA database and all other aspects of the\ndisassembly. IDA plugins can be incredibly powerful with\nthis level of control.\n\nPlugins are developed in C++ and can be compiled with\nBorland, Microsoft, Watcom or GNU C++ compilers.\n\n\n-----\n\nSince the code is compiled to native binary, the execution\nspeed is similar to any other native application. The main\ndisadvantage also comes from the need of compilation\nwhich makes the development tedious. Another problem is\nthat a small bug can crash the whole IDA application,\npossibly corrupting the database. The following example\nshows the plugin implementation of the XOR decryptor\nwith all the plugin administration code stripped.\n\nvoid decode (void)\n{\nea_t baseaddr;\nuchar key;\nuchar c;\n\nbaseaddr = get_screen_ea();\nkey = 0xFF;\n\nwhile (1)\n{\nc = get_byte(baseaddr);\n\nif (c == 0) { break; }\n\npatch_byte(baseaddr, c ^ key);\nbaseaddr++;\n}\n}\n\nThe look of the code did not change much. The IDA API\nfunctions have somewhat longer names and more specific\npurpose than the IDC counterparts. To implement certain\nIDC functions, often several IDA API calls and data\nconversions have to be made.\n\n## 3. NEED FOR CHANGE?3. NEED FOR CHANGE?3. NEED FOR CHANGE?3. NEED FOR CHANGE?3. NEED FOR CHANGE?\n\nWhat is wrong with IDC and plugin writing? Generally\nspeaking nothing. Either of them would be suitable to\nimplement anything that can be implemented with the help\nof IDA. On the other hand there are other points to\nconsider here. The undisputed dominance and popularity\nof C and C++ does not automatically mean that they are\nthe optimum choice for every task. The lack of complex,\nabstract data structures make C unsuitable for rapid\ndevelopment and prototyping. Without trying to start a\nlanguage debate we can also note that the extensions of\nC++ over C do not have the easiest to remember syntax\neither. C and C++ put efficiency over expressiveness,\nwhich certainly made sense when computing power was\nmore expensive than programmers’ time. However with\ncomputing horsepower getting cheaper and cheaper it does\nnot sound so crucial any more to spare clock cycles at the\nexpense of human productivity.\n\nWhat would be a better tool then?\n\nBefore jumping to conclusions it is necessary to examine\nthe most common practical applications of IDA extensions.\nAs far as we can tell the two most common are:\n\n - experimental reverse engineering tools\n\n - quick tools for malware analysis.\n\nExperimental tools evolve quickly, which clearly benefit\nfrom a development environment that supports frequent\ncode and interface changes. The programming language\nand the tools must not limit the researcher’s ability to\nsignificantly change the code whenever it is needed.\n\n\nCode written for malware analysis purposes usually solves\na single problem and, typically, it is not reused. Decryptors\nwritten for different malware’s string scramblers are a\ngood example of this group. According to our experience\nthese tools cannot be fully reused too often as malware\nchanges very rapidly, even in the same family.\n\nIn both cases the time required for development is more\nimportant than execution speed. The above observations\nlead us to the conclusion that we need to find a language\nwhich is very expressive, allows rapid prototyping and is\nembeddable into applications. Modern, very high-level\nscripting languages can easily fulfil these requirements.\nAfter the evaluation of several modern scripting languages\nour choice was Python.\n\n## 3.1 What is Python?3.1 What is Python?3.1 What is Python?3.1 What is Python?3.1 What is Python?\n\nQuoting from the Python website:\n\n“Python is an interpreted, interactive, object-oriented\n_programming language. It is often compared to Tcl, Perl,_\n_Scheme or Java._\n\n_“Python combines remarkable power with very clear_\n_syntax. It has modules, classes, exceptions, very high level_\n_dynamic data types, and dynamic typing. There are_\n_interfaces to many system calls and libraries, as well as to_\n_various windowing systems (X11, Motif, Tk, Mac, MFC)._\n_New built-in modules are easily written in C or C++._\n_Python is also usable as an extension language for_\n_applications that need a programmable interface.” [2]_\n\nEven though Python’s history started over a decade ago it\nhas gained mainstream recognition only quite recently.\nThe language is continuously evolving yet Python\ndevelopers have been able to maintain excellent backward\ncompatibility with older source code.\n\nOne slogan of the Python movement is: “Batteries\nincluded”. For most tasks all the required modules are\nincluded in the standard distribution. These modules range\nin functionality from simple data handling to server\napplication components. A large number of third-party\nmodules are also available, from simple utilities to\nscientific computing and number crunching.\n\n## 3.2 Why Python?3.2 Why Python?3.2 Why Python?3.2 Why Python?3.2 Why Python?\n\nPython has many properties that make it well suited for\nour needs. It is easy to learn – anyone with prior\nprogramming experience can pick it up really quickly. For\nnewcomers an excellent tutorial is available on the Python\nwebsite [3].\n\nThe language is object-oriented and supports different\nabstract code and data structures which make it easy to\nexpress complex algorithms. Python has built-in support\nfor lists, dictionaries (hashes) and tuples. Using these,\nalgorithms that would take several pages in C can be\nexpressed in just a few lines. This provides a perfect\nplayground for trying out ideas. If one of the ideas does\nnot work out the code can be thrown away without the\nslightest feeling of regret. The same thing is much more\n\n\n-----\n\npainful after the effort of chasing down all the pointers and\noff-by-one errors.\n\nOf course, just like anything else, Python has some\ndisadvantages too. Most notable is execution speed. The\nprograms are interpreted and sometimes run 2–20 times\nslower than the C/C++ implementations. Where the\nexecution speed is a primary factor Python might not be\nthe optimal choice. On the other hand Python is extremely\neasy to extend with C/C++ code. In most cases careful\nseparation of computationally intensive parts into C/C++\nextension modules solves the performance problem.\nAnother way of speeding up Python code is the use of\nPsyco [4], which is a Just-In-Time (JIT) compiler that can\nachieve significant speedup depending on the type of\nthe code.\n\n## 4. MEET IDAPYTHON4. MEET IDAPYTHON4. MEET IDAPYTHON4. MEET IDAPYTHON4. MEET IDAPYTHON\n\nOur attempt to make the raw power of IDA more\naccessible with a user-friendly, very high-level language\nresulted in the birth of IDAPython. Implementation-wise\nIDAPython is an IDA plugin which wraps the IDA API\nand connects it to the Python environment as an extension\nmodule. Scripts run inside IDA have access to both the\nIDA API and all installed Python modules.\n\nIDAPython consists of several modules, organized in three\nlayers:\n\n1. Low-level IDA API wrapper layer\n\n2. IDA API user layer with class definitions\n\n3. IDC-compatibility and utility modules\n\nThe following figure illustrates the structure of\nIDAPython:\n\n**_Figure 1. IDAPython organization._**\n\n## 4.1 Low-level wrapper layer4.1 Low-level wrapper layer4.1 Low-level wrapper layer4.1 Low-level wrapper layer4.1 Low-level wrapper layer\n\nThe low-level API layer is a direct Python wrapper around\nthe IDA API. This module is statically linked into the\nIDAPython plugin and can be imported with the name\n‘_idaapi’. The wrapper code is generated by Simplified\nWrapper Interface Generator (SWIG) [5]. _idaapi directly\nreflects the C++ IDA API, functions have the same name,\nsame arguments and return values. The IDA SDK\ndocumentation, with few exceptions, is directly applicable\nto the Python wrappers as well – although changes had to\nbe made where the C++ semantics are significantly\n\n\ndifferent from the Python. These differences from the\nofficial IDA API are documented in the plugin package.\nThe differences mostly concern functions that return data\nin their arguments or use complex or unusual arguments.\nFor example:\n\nIDA C++ API version:\n\nchar *get_func_name(\nea_t ea,\nchar *buf,\nsize_t bufsize);\n\nThe C++ version expects the function address and a\npointer to the output buffer with bufsize size. It either\nreturns the address of the output buffer or NULL if an\nerror occurred. The idea of output buffer pointers is not\nused in Python so we have to change the definition that\nmakes sense there as well.\n\nPython _idaapi module version:\n\n_idaapi.get_name(from, ea)\n\nIn the Python version the wrapper allocates memory for\nthe output string and returns either a Python string or\nNone if the function fails. Similar changes have to be\nmade to other functions too.\n\nThis module should not be used directly, all the functions\nand data are available in the upper level module described\nin the next section.\n\n## 4.2 User layer4.2 User layer4.2 User layer4.2 User layer4.2 User layer\n\nThe user layer module is called ‘idaapi’ which is a thin\nlayer on the top of the ‘_idaapi’ module. It contains all the\nfunctions and data from the module below and adds\nPython class definitions for the wrapped C++ classes,\nstructures and unions. Using these classes complex data\nstructures can be accessed with the usual class.member\nnotation.\n\nThis is the module that most user programs that need IDA\nAPI access should use.\n\n## 4.3 IDC compatibility module4.3 IDC compatibility module4.3 IDC compatibility module4.3 IDC compatibility module4.3 IDC compatibility module\n\nSince most experienced IDA users are familiar with the\nIDC language a compatibility module has been developed.\nAll the IDC definitions are automatically imported from\nthe ‘idc’ module to provide a familiar environment for\npeople with IDC experience. It also makes porting of IDC\nscript to Python easier. The IDC module is developed with\nmaximum compatibility in mind, however there are certain\nfunctions that have native implementation in the Python\nlibraries and thus were removed. In the current state over\nhalf of the IDC functions have been implemented, the final\ngoal is to implement all functions that are applicable in the\nPython environment.\n\n## 4.4 Idautils module4.4 Idautils module4.4 Idautils module4.4 Idautils module4.4 Idautils module\n\nTo lift the burden of using low-level functions for\neverything a new module was created. Idautils is a module\nthat contains assorted functions that wrap the most often\nused low-level code. Examples include functions that\n\n\n-----\n\nprovide a list representation of result that could previously\nbe collected with *First() and *Next() type of calls and\ncomplex loop conditions. The development of ‘idautils’ is\nin progress and it will be extended with any functionality\nthat qualifies to be included. All the functions are\nthoroughly documented with Python docstrings, so it is\neasy to experiment with them. A simple example follows\nin the next section to highlight the benefits of this module.\n\n## 5. EXAMPLE5. EXAMPLE5. EXAMPLE5. EXAMPLE5. EXAMPLE\n\nTo demonstrate the advantages of the new approach we are\ngoing to implement a relatively short program. The\npurpose of the program is to enumerate all defined functions\nin a given segment and list the places they are called from.\nTypical output of the tool is something like this:\n\nFunction _start at 0x8048520\nFunction call_gmon_start at 0x8048544\ncalled from _start(0x8048543)\ncalled from .init_proc(0x804848e)\nFunction __do_global_dtors_aux at 0x8048570\ncalled from .term_proc(0x8048741)\nFunction frame_dummy at 0x80485b0\ncalled from .init_proc(0x8048493)\nFunction main at 0x80485e4\nFunction __libc_csu_init at 0x8048658\nFunction __libc_csu_fini at 0x80486a0\nFunction __i686.get_pc_thunk.bx at 0x80486f2\ncalled from __libc_csu_init(0x8048660)\ncalled from __libc_csu_fini(0x80486ad)\nFunction __do_global_ctors_aux at 0x8048700\ncalled from .init_proc(0x8048498)\n\nThis example is deliberately kept simple to focus on the\nimplementation and not the algorithmic behaviour.\n\n## 5.1 IDC version5.1 IDC version5.1 IDC version5.1 IDC version5.1 IDC version\n\nFirst we implemented the small program in IDC:\n\n#include <idc.idc>\nstatic main()\n{\nauto ea, func, ref;\n\n// Get current ea\nea = ScreenEA();\n\n// Loop from start to end in the current segment\nfor (func=SegStart(ea);\nfunc ! = BADADDR && func < SegEnd(ea);\nfunc=NextFunction(func))\n{\n// If the current address is function process it\nif (GetFunctionFlags(func) ! = -1)\n{\nMessage(‘Function %s at 0x%x\\n‘,\nGetFunctionName(func), func);\n\n// Find all code references to func\nfor (ref=RfirstB(func);\nref ! = BADADDR;\nref=RnextB(func, ref))\n{\nMessage(‘ called from %s(0x%x)\\n‘,\nGetFunctionName(ref), ref);\n}\n}\n}\n}\n\n\nThe source code does exactly what we want it to do but it’s\nnot too easy on the eyes. It might need more than one\nglance to understand how it works, even after such short\ntime as going for a lunch break. One of the problems is the\nC way of iterating through lists, which involves several\nfunctions and loops with complex conditions.\n\n## 5.2 Python version5.2 Python version5.2 Python version5.2 Python version5.2 Python version\n\nThe second version was implemented in Python using only\nthe idaapi module:\n\nfrom idaapi import *\n\n# Get current\nea ea = get_screen_ea()\n\n# Get segment class\nseg = getseg(ea)\n\n# Loop from segment start to end\nfunc = get_func(seg.startEA)\n\nwhile func ! = None and func.startEA < seg.endEA:\nfuncea = func.startEA\nprint ‘Function %s at 0x%x‘ % \\\n(GetFunctionName(funcea), funcea)\n\nref = get_first_cref_to(funcea)\n\nwhile ref ! = BADADDR:\nprint ‘ called from %s(0x%x)‘ % \\\n(get_func_name(ref), ref)\nref = get_next_cref_to(funcea, ref)\n\nfunc = get_next_func(funcea)\n\nThe syntax has been converted to Python which uses\nindentation instead of braces for marking code blocks.\nThis program serves as a good example that a good choice\nof the programming language itself does not warrant easy\nto read source code. This version of the routine is still not\nas clear and easy to understand as we would like it to be.\n\n## 5.3 Python version with ‘idautils’5.3 Python version with ‘idautils’5.3 Python version with ‘idautils’5.3 Python version with ‘idautils’5.3 Python version with ‘idautils’\n\nThe last version of the script has been rewritten from\nscratch to utilize both the IDC and idautils module.\n\nfrom idautils import *\n\n# Get current ea\nea = ScreenEA()\n\n# Loop from start to end in the current segment\nfor funcea in Functions(SegStart(ea), SegEnd(ea)):\nprint ‘Function %s at 0x%x‘ % \\\n(GetFunctionName(funcea), funcea)\n\n# Find all code references to funcea\nfor ref in CodeRefsTo(funcea, 1):\nprint ‘ called from %s(0x%x)‘ % \\\n(GetFunctionName(ref), ref)\n\nThis version of the tool consists of six lines of effective\ncode which took two to three times more with the other\nimplementations. It is also much easier to understand than\nthe others. Although we are not suggesting that all source\nwill shrink to half its size, we are convinced that with the\nhelp of well-written, high-level wrappers over the most\ncommon functions code size and development time can be\nreduced. The main advantage of IDAPython is that any of\nthe layers can be used even in the same code with certain\nprecaution. One does not have to sacrifice the direct\ndatabase access for IDC or the idautils package.\n\n\n-----\n\n## 6. IDAPYTHON THE PLUGIN6. IDAPYTHON THE PLUGIN6. IDAPYTHON THE PLUGIN6. IDAPYTHON THE PLUGIN6. IDAPYTHON THE PLUGIN\n\n 6.1 Usage6.1 Usage6.1 Usage6.1 Usage6.1 Usage\n\nUsage of the plugin is similar to IDC. Python code can be\nexecuted by either loading it from a file or entering it into\na Python expression window. The latter is only suitable for\nexperiments with short Python statements. Possibility to\nsave the session could be added in the future as time\npermits. Future enhancements to the user interface might\ninclude features like a fully interactive Python session\ninside IDA. Unfortunately it is not possible to implement\nthat with the current IDA API.\n\nThe following screenshot shows the Python expression\nwindow:\n\n**_Figure 2. Example session._**\n\n## 6.2 Status and availability6.2 Status and availability6.2 Status and availability6.2 Status and availability6.2 Status and availability\n\nIDAPython is under heavy development, yet in an\nadvanced state already. The plugin is used in-house by the\n_F-Secure Antivirus Research Team on a regular basis._\nMore improvements and testing are in the works. By the\ntime this paper is published the first feature complete\nversion of the IDAPython plugin will be released at\nhttp://www.d-dome.net/idapython/. The package will\ninclude the full source code and can be used for any\npurpose, free of charge. The reader is invited to try it out\nand provide much valued feedback. Improvement ideas,\ncode and other contributions are most welcome.\n\n## 7. INTRODUCING GRAPHS7. INTRODUCING GRAPHS7. INTRODUCING GRAPHS7. INTRODUCING GRAPHS7. INTRODUCING GRAPHS\n\n 7.1 Pr7.1 Pr7.1 Previous work7.1 Pr7.1 Previous workevious workevious workevious work\n\nFar from being a seminal work, this paper attempts to raise\nthe importance of clear and visual methods of analysis.\nHalvar Flake is a distinguished figure in the binary reverse\nengineering world, he has been using graphs and similar\ncomparison metrics as used here in specific steps of our\nalgorithm, aiming at tools which find differences between\ndifferent versions of a given binary. Flake’s work [6]\nelaborates on the use of graphs for malware analysis and\nexposes some of the advantages that we will reintroduce in\nthis paper.\n\n\n## 7.2 The pr7.2 The pr7.2 The proposed appr7.2 The pr7.2 The proposed approposed approposed approachoposed approachoachoachoach\n\nGraphs have always provided a clear way of looking at\nproblems. Complex hierarchies instantly become easier to\nunderstand once they are represented in a way humans\nfind easy to assimilate. Graphs are one such way of\ndisplaying data, instead of more cumbersome\nrepresentations like endless lists of numbers and\nreferences to code and data as provided in a traditional\ndisassembly.\n\nAdditionally, a rich literature already exists on graph\ntheory with algorithms to treat and analyse them. Once we\nare consistently representing code as graphs, a door is\nopen to know mathematical methods for analysis and\nfurther topics such as clustering.\n\nIn this paper we will be representing code as graphs on\nglobal and function levels.\n\nGraphs provide abstraction, and that is exactly what\nenhances the ability to build simple algorithms to work on\ntop of them.\n\n## 7.3 Pr7.3 Pr7.3 Preparing the data for analysis7.3 Pr7.3 Preparing the data for analysiseparing the data for analysiseparing the data for analysiseparing the data for analysis\n\n 7.3.1 Exporting the data7.3.1 Exporting the data7.3.1 Exporting the data7.3.1 Exporting the data7.3.1 Exporting the data\n\nA tool was created to export IDA databases to a\nmetalanguage representation, after a given binary has been\nloaded into IDA. This tool does not export the whole set of\ninformation supported in IDA’s database format, but a\nsufficient subset including:\n\n - Every defined function.\n\n - Every instruction. The full binary representation,\nmnemonic and operands as presented by IDA to\nthe user.\n\n - All the defined referenced strings and names.\n\n - All code references.\n\n - Code flags: whether the code is flow (useful to\ncoherently extract the basic blocks of a function).\n\n - Miscellaneous flags: whether a function belongs to a\nknown library or is a thunk.\n\nAll this information has been found to be enough to\nprovide a fertile playground for our research. Future\nadditions will include all comments in order to add as\nmuch high-level readable information as possible.\n\nThe name REML was coined for the resulting\nmetalanguage file, standing for Reverse Engineering\n_Meta-Language, or RevEngML._\n\n## 7.3.2 Interfacing the data7.3.2 Interfacing the data7.3.2 Interfacing the data7.3.2 Interfacing the data7.3.2 Interfacing the data\n\nThe next step was generating an object-oriented\nframework, focusing on usability and ease of use, while\ngiving lower priority to performance issues.\n\nA Python module was created to work on the REML files.\nThe module implements a top Binary class, which\n\n\n-----\n\nprovides methods to access the generic binary information\nsuch as the entry point to the code and the list of its\nfunctions. It is also possible to query functions by their\nnames or addresses in their body.\n\nSubsequently, an extensive Function class was\nimplemented. Among others, it provides the following:\n\n - Access to all the instructions.\n\n - Ingoing and outgoing code and data references.\n\n - Generation of the list of basic blocks from which to\ngenerate a CFG (Control Flow Graph).\n\nA third, smaller class, was added under the rather\nunoriginal name Instruction in order to access the\ninstructions and their operands.\n\n## 7.3.3 Pr7.3.3 Pr7.3.3 Processing the data7.3.3 Pr7.3.3 Processing the dataocessing the dataocessing the dataocessing the data\n\nOur research and prototypes lie on top of the interface we\ncreated in order to access the data. It gave us, among other\npossibilities, that of quickly generating graphs from a\nbinary. In a fairly small number of lines (as compared\nwith IDA’s IDC language) we could iterate over the whole\nset of functions, gather their references and create a graph\nobject [7].\n\nWe took the approach that every single function in a\nbinary is represented by a vertex in the graph and calls\nbetween them translate to the graph’s edges.\n\n\nThe plotting algorithms and style were fine tuned, over\nsome initial testing period, until we achieved\nunderstandable representation of rather complex and\nextensive binaries.\n\nTwo main modes of visualization were found to provide\ngood results. A hierarchical representation provides good\nresults for binaries up to certain number of functions; this\nlayout is provided by the GraphViz’s dot.\n\nA second, radial layout (Figure 3), was obtained through\n_GraphViz’s twopi, which proved to be useful to visualize_\nlarger cases.\n\nAfter the initial visual advantages of graphs, exploiting\ntheir mathematical properties became the target of our\nefforts. This is the topic of the next section.\n\n## 8. ALGORITHMS BASED ON GRAPH8. ALGORITHMS BASED ON GRAPH8. ALGORITHMS BASED ON GRAPH8. ALGORITHMS BASED ON GRAPH8. ALGORITHMS BASED ON GRAPH REPRESENTREPRESENTREPRESENTAAAAATION OF BINARIESREPRESENTREPRESENT TION OF BINARIESTION OF BINARIESTION OF BINARIESTION OF BINARIES\n\n 8.1 Binary comparison, graph similarities8.1 Binary comparison, graph similarities8.1 Binary comparison, graph similarities8.1 Binary comparison, graph similarities8.1 Binary comparison, graph similarities\n\nIn this section we will address the process of finding how\nclose two binaries are to each other. The result of our\nalgorithms will be a value indicating how much of their\ncall flow graphs overlap or relate to each other.\n\nOnce we have such values, we are in the position of\nattempting to perform classification of malware by their\nsimilarities. Borrowing from the field of Phylogenetics [8],\nwe will apply clustering analysis algorithms in order to\nobtain a taxonomy of the malware at hand. The results\nfrom this approach are encouraging, indicating an area of\nresearch which should be explored further.\n\n## 8.1.1 The comparison algorithm8.1.1 The comparison algorithm8.1.1 The comparison algorithm8.1.1 The comparison algorithm8.1.1 The comparison algorithm\n\nGiven the graph representing the binary under analysis, we\nwill create its adjacency matrix. This matrix will have a\nrow and column for each of the functions present in the\nbinary, and its element in position (I, J) will indicate\nwhether a function in row I performs a call to the function\nin column J.\n\nThe objective we pursue is to be able to relate functions\nfrom two executables based on their position in the graph\nresulting from the connections among all the functions. A\nfunction which calls and is called by a given set of\nfunctions, is matched against another with a similar set of\ncalled and caller functions.\n\nFinding graph isomorphisms is known to be a fairly\ncomplex task, no polynomial time algorithm is known to\nsolve this problem. Fortunately, the problem at hand is\nmuch simpler as we have more information to put into\nour model.\n\n\nTo define a basic set of nodes from which to start, we\nchoose operating system and library calls. In other words,\nany function which does not perform a further call to code\nbelonging to the binary and which will have a common\n**_Figure 3. Mimail family graphs. Certain patterns can be_** name across different executables. With this approach we\n**_appreciated between members of this family._** automatically rule out binaries which do not call any such\n\n\n-----\n\nfunctions, although it would be still applicable if a\nresearcher would manually find a basic set of common\nfunctions between two binaries and name them accordingly.\n\nOnce we have a set of commonly named functions on two\ndifferent binaries, we compose an adjacency matrix and\nsuppose as identical the functions with identical unique\nrows in this matrix.\n\nWe incorporate the information gained in each pass and\nrerun the matching, effectively progressing through the\ngraph, until a maximum of functions is matched.\n\nAdditional optimizations have been put in place when\nambiguities arise, as function matching according to\nmetrics calculated from their internal structure.\n\nAfter the process in finished, we have a set of functions\ncommon to both binaries.\n\n## 8.1.2 Definition of the algorithm8.1.2 Definition of the algorithm8.1.2 Definition of the algorithm8.1.2 Definition of the algorithm8.1.2 Definition of the algorithm\n\n - We have two executables’ graphs which we want to\ncompare. A source S and a target one T. We define the\nfollowing:\n\n**– Sf = {set of all functions composing S}**\n\n**_– Tf = {set of all functions composing T}_**\n\n - Find the common set of atomic functions [9]. That is:\n\n - We define Sr = Sf – C and Tr = Tf – C as the sets of\nremaining functions to be matched.\n\n - Now, for we create a call-tree signature [10] for\n_f from C and consider it identical to_ if the\nsignature of generated from C is identical and\nunique.\n\n– If such match is found we augment the C matrix\nwith the signature of f. which will allow us to match\nhigher level functions not necessarily relying on API\nfunctions.\n\n - Once this algorithm does not yield any more matches,\nwe will have a matrix C containing all the functions\noccupying the same positions in the graphs of both S\nand T. At the end of the process we will have\nunmatched functions of two types.\n\n1. The ones which are different and can not be\nmatched.\n\n2. Functions which do not have unique signatures.\n\nIn a further development of the algorithm we enhanced its\nmatching capabilities by using a new kind of signature,\nnamely the list of edges connecting basic blocks from the\nfunctions CFG (CFG signatures). Functions with\nnon-unique call-tree signatures can be matched if unique\n_CFG signatures exist._\n\nWe implemented this enhancement to be run every time\nwe exhaust the call-tree signatures. Finding some\ncorrespondences between functions will often lead to\nadditional matches in further passes of the algorithm. This\nhas successfully increased the accuracy of our method.\n\n\n## 8.1.3 The index of similarity8.1.3 The index of similarity8.1.3 The index of similarity8.1.3 The index of similarity8.1.3 The index of similarity\n\nOnce we have a set of supposedly equivalent functions\nbetween both binaries, the index of similarity is obtained\nas follows.\n\nLet’s call the set of equivalent functions in the source\nbinary S, Se = {equivalent functions in S} and similarly\ndefine Te = {equivalent functions in T}, note that both sets\ncontain the API calls found to exist in both binaries. Let\ndenote the similarity index function and be\ndefined as:\n\nwhich leads to the non-symmetric similarity indexes (or\ndistances):\n\nwe define a final combined similarity as:\n\nThis function, will always yield a value between\n. . With values close to 0 indicating a low\ndegree of resemblance, and values near 1 for pairs of\nmalware which share almost all of their code.\n\n## 8.1.4 Case studies8.1.4 Case studies8.1.4 Case studies8.1.4 Case studies8.1.4 Case studies\n\nWe will now give the distance matrices for different\nfamilies of malware, the values are percentages indicating\nhow close the malware was found to be to each other.\nHere we will follow the procedure introduced in the\nprevious section.\n\n**_Mimail_**\n\nThe Mimail family exhibits high indexes of resemblance,\nas can be seen in the following distance matrices.\n\n**_Klez_**\n\nThe Klez family comparison also yields good results. The\nclassification splits the samples in two branches, one\ncontaining Klez variants A, B, C and D, and a second one\nwith E, F, G, H, I and J, see Figure 4.\n\n\n-----\n\n**_Netsky_**\n\nThe large family of Netsky appears clustered together as\nwell. A feature worth mentioning is the closeness to the\nSasser family, which was created by the same author. Such\nresemblance yields high indexes of similarity with our\nalgorithm, given the fact that the author used common\ncode in both families. See Figure 4.\n\n**_Roron_**\n\nThe Roron family is tightly clustered together given the\nvalues in distance matrix generated from the graphs. See\nFigure 4.\n\n**_Bagle_**\n\nThe Bagle worms provide an example where the similarity\nbetween certain variants is low. The reason for such results\nis that some of the variants were just dropping a backdoor\nand did lack their own replication system, actually\nrendering them quite different form each other. The\nalgorithm successfully indicates such fact.\n\n**_Sasser_**\n\nSasser is another sample of highly similar malware.\n\n\n**_Random selections_**\n\nWe will now show some distance matrices of randomly\npicked samples. We have previously shown families of\nmalware, which do not demonstrate well the case where\nsamples are different from each other. The following\ndata shows that unrelated samples yield low similarity\nindexes.\n\n## 8.2 Possibilities, exploiting the acquir8.2 Possibilities, exploiting the acquir8.2 Possibilities, exploiting the acquired8.2 Possibilities, exploiting the acquir8.2 Possibilities, exploiting the acquiredededed knowledgeknowledgeknowledgeknowledgeknowledge\n\nWe will now discuss several techniques which benefit\nfrom the foundations laid in section 8.1 of the paper. We\nwill briefly present several areas whose overall quality\nimproves by having some metric defining the degree of\nsimilarity between malware. This also relates to which\nparts of two specific binaries correlate, proving similar or\nthe same functionality. Some of the techniques discussed\nin this section have already been implemented and\npreliminary results are available; others, although briefly\ntested, lack a solid prototype.\n\n## 8.2.1 Clustering and classification8.2.1 Clustering and classification8.2.1 Clustering and classification8.2.1 Clustering and classification8.2.1 Clustering and classification\n\nOnce we created a reliable method to find approximate\ndistances, or similarity indexes between binaries, we can\nmove into such area as classification. Philippe Biondi\ndemonstrated to one of the authors the results of applying\nclustering algorithms, such as X-tree, to a previously\ngenerated distance matrix of malware. Those encouraging\nresults fostered further research of the topic.\n\n\n-----\n\n**_Figure 4. Phylogenetic classification of a group malware._**\n\n\n-----\n\nRecently Stephanie Wehner has done some work on\nclassification using techniques based on Kolmogorov\n_Complexity. Her preliminary results [11] show_\nclassifications of worms into families without any\nunderlying analysis performed on the samples. This\napproach is highly interesting when a fast classification\nis needed.\n\nOur approach is based on phylogenetics. An extensive\nliterature exists on that area on classification of taxa and\n_cluster analysis. A series of algorithms exist which can_\nbe applied to distance matrices, that is, a square matrix\nproviding numbers expressing how similar two OTU [12]\nor malware are to each other.\n\nAlgorithms such as Neighbor Joining [13] applied to such\nmatrices yield a hierarchical classification, which opens\nthe door to taxonomies of malware. New samples can\nimmediately be classified if a sample fulfilling certain\nrequirements is provided [14].\n\nIn the future, given a common algorithm agreed\nbeforehand, this procedure may aid in the classification\ntask and diminish the confusion caused by randomly\nnamed malware. The existing approach in biological\nsciences might prove of value, where popular taxa have\ncolloquial names, besides the purely scientific\nclassification.\n\nPrevious work [15] has already explored ways the\nphylogenetic approach may help in computer virus\nclassification, although the metric used in that case was\nbyte sequences present in the malware file.\n\nWe believe that approach is limited, as even simple\npolymorphic malware may result in no possibility of\napplication of the technique, let alone packed/encrypted\ncode.\n\nWhile our approach currently faces similar restrictions if\naiming for completely automated analysis, we already laid\na base which yields acceptable results with a strong metric\nsuch as the one provided by graph isomorphisms, see\nFigure 4.\n\n## 8.2.2 Helping quick analysis8.2.2 Helping quick analysis8.2.2 Helping quick analysis8.2.2 Helping quick analysis8.2.2 Helping quick analysis\n\nThe knowledge of which functions in two different\nvariants of malware are the same allows us to mine this\ninformation, aiding in rapid analysis of threats of the same\nfamily. Starting from an already analysed binary, the\npossibility exists (although it is not implemented yet) to\nmark certain areas on it, i.e. string references, registry\nkeys, port numbers; and track whether or not they have\nbeen modified from one variant to the next. If such\nmodification took place, we could obtain the new values\nand automatically generate the corresponding information\nin form of a description for the general public.\n\n## 8.2.3 Migrating analysis information8.2.3 Migrating analysis information8.2.3 Migrating analysis information8.2.3 Migrating analysis information8.2.3 Migrating analysis information between code versionsbetween code versionsbetween code versionsbetween code versionsbetween code versions\n\nPorting existing knowledge from the analysis of a variant\nto a recently discovered one has proved to be a practical\n\n\nand valuable tool. The knowledge of which functions map\nfrom a binary A to a binary B allows us to rename all the\nknown code in the, yet to be analysed, new variant. In\nsome cases it allows us to start an analysis with 80–90 per\ncent of the defined functions already meaningfully named.\n\nThis reduces the time needed for an initial overview\nand enables us to focus on more important parts of the\ncode and algorithms and not just reanalysing previously\nseen code.\n\n## 8.3 Other aspects of code visualisation8.3 Other aspects of code visualisation8.3 Other aspects of code visualisation8.3 Other aspects of code visualisation8.3 Other aspects of code visualisation using graphsusing graphsusing graphsusing graphsusing graphs\n\nRecently we created a tool which allows us to browse\na disassembly by just looking, scrolling and zooming\na graph.\n\nThe main interface shows the whole defined call tree of\nthe binary, every function node containing a list of the\nstrings referenced from within it. Clicking in any of the\nfunctions opens a new window, which shows its CFG\n(Control Flow Graph) and in each basic block node, a list\nof function and string references. Placing the mouse over\nany of the basic blocks shows the corresponding\ndisassembled code.\n\nMore features have been added, i.e.:\n\n - Rename functions\n\n - Search functions in the graph\n\n - Change visualizations modes (hierarchical or radial)\n\n - Compare different versions of binaries (common code\nis represented in red)\n\n - Export the renamed functions as an IDC script to\nrename them in the IDA DB.\n\nThe tool has allowed us, so far, to perform quick general\nanalysis of a binary. The holistic perspective provided is\nreally convenient when handling binaries with several\nlayers of abstraction, where the API calls may lay some\nlevels away from the investigated function. In a\ndisassembler such as IDA, perceiving the logical position\nand purpose of the function within the binary might be\nnearly impossible without jumping to all the called code.\nIn a graph, that becomes trivial, as all those relations are\npatent in one sight.\n\n## 9 CONCLUSIONS AND FUTURE9 CONCLUSIONS AND FUTURE9 CONCLUSIONS AND FUTURE9 CONCLUSIONS AND FUTURE9 CONCLUSIONS AND FUTURE DIRECTIONSDIRECTIONSDIRECTIONSDIRECTIONSDIRECTIONS\n\n 9.1 Limitations9.1 Limitations9.1 Limitations9.1 Limitations9.1 Limitations\n\nSeveral limitations exist to a fully automated graph\ngeneration, comparison and classification approach.\nMalware is commonly packed and/or encrypted.\nThat represents one major inconvenience which must\nbe overcome before achieving our final goal of full\nautomation.\n\nThe graph creation and comparison algorithms are\narchitecture-independent. The only requisite is the\n\n\n-----\n\nexistence of such concept as calls (branching is acceptable\nas long as IDA can recognize the functions).\n\nThe binaries must use API services provided by the\noperating system, and have a significant quantity of code.\n\n## 9.2 Futur9.2 Futur9.2 Future dir9.2 Futur9.2 Future dire dire directionse directionsectionsectionsections\n\nFurther research in the classification of malware promises\nto yield rewarding results. Some of the basic concepts\ndiscussed in this paper should be extended.\n\n## 9.2.1 Graph database9.2.1 Graph database9.2.1 Graph database9.2.1 Graph database9.2.1 Graph database\n\nThe creation of a graph database has not yet been\nexplored. In such a repository, the graph representation\nand properties of a binary would be stored. Upon arrival of\nnewly discovered malware, the database would be queried\nfor certain patterns. If the search turns out positive results,\ncomparisons and posterior classification would be\nperformed automatically.\n\n## REFERENCES & NOTESREFERENCES & NOTESREFERENCES & NOTESREFERENCES & NOTESREFERENCES & NOTES\n\n[1] Datarescue IDA page, http://www.datarescue.com/\nidabase/index.htm.\n\n[2] Python website, http://www.python.org/.\n\n[3] Guido van Rossum and Fred L. Drake, Jr.: Python\n_Tutorial, http://docs.python.org/tut/tut.html._\n\n[4] Psyco website, http://psyco.sourceforge.net/.\n\n[5] SWIG website, http://www.swig.org/.\n\n[6] Halvar Flake, ‘Graph-Based Binary Analysis’,\n_Blackhat Briefings 2002._\n\n[7] We also created a python module, namely pydot, to\nquickly generate and interact with appealing visual\nlayouts of graphs through AT&T’s renowned\nGraphViz software. The python module is publicly\navailable at one of the author’s personal website,\nhttp://dkbza.org/pydot.html.\n\n[8] _Phylogenetics: “Phylogenetics is the taxonomical_\nclassification of organisms based on how closely\nthey are related in terms of evolutionary\ndifferences.”\n\n[9] By ‘atomic function’ we mean a function which\nperforms no further calls and has a common name\nacross different executables. In such way that it can\nbe considered to be a basic building block. In graph\ntheory they are the leaf vertices with indegree 1 and\noutdegree 0.\n\n[10] A signature for a function f is created by inspecting\nthe list of atomic functions, La, and creating a\nbinary string, containing a 1 in position n if f calls\nthe atomic function in the index n of La and 0\notherwise.\n\n[11] S. Wehner, ‘Analyzing Worms using Compression’,\nhttp://homepages.cwi.nl/~wehner/worms/\n\n\n\n[12] In phylogenetics, the term OTU stands for\nOperational Taxonomical Units and refers to\nmembers of different species to be classified given\ntheir evolutionary differences.\n\n[13] N. Saitou and M. Nei, ‘The neighbor-joining\nmethod: a new method for reconstructing\nphylogenetic trees’, Mol. Biol. Evol. 4, pp406–425.\n\n[14] The sample must be unpacked/unencrypted and\nhave a properly reconstructed import table.\n\n[15] L.A. Goldberg, P.W. Goldberg, C.A. Phillips, G.\nSorkin, ‘Constructing Computer Virus\nPhylogenies’, Journal of Algorithms, Vol 26(1) (Jan.\n98) pp.188–208.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "bf5be533-fa31-4590-ae37-5761c97ffa34",
            "created_at": "2022-10-25T16:13:58.389257Z",
            "updated_at": "2022-10-25T16:13:58.389257Z",
            "deleted_at": null,
            "name": "Malpedia",
            "url": "https://malpedia.caad.fkie.fraunhofer.de",
            "description": "Malpedia is a free service offered by Fraunhofer FKIE",
            "reports": null
        }
    ],
    "references": [
        "https://archive.f-secure.com/weblog/archives/carrera_erdelyi_VB2004.pdf"
    ],
    "report_names": [
        "carrera_erdelyi_VB2004.pdf"
    ],
    "threat_actors": [
        {
            "id": "d90307b6-14a9-4d0b-9156-89e453d6eb13",
            "created_at": "2022-10-25T16:07:23.773944Z",
            "updated_at": "2025-03-27T02:02:09.974695Z",
            "deleted_at": null,
            "main_name": "Lead",
            "aliases": [
                "Casper",
                "TG-3279"
            ],
            "source_name": "ETDA:Lead",
            "tools": [
                "Agentemis",
                "BleDoor",
                "Cobalt Strike",
                "CobaltStrike",
                "RbDoor",
                "RibDoor",
                "Winnti",
                "cobeacon"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1666716493,
    "ts_updated_at": 1743041321,
    "ts_creation_date": 1097056444,
    "ts_modification_date": 1097056444,
    "files": {
        "pdf": "https://archive.orkl.eu/084a9458973c1c5996891b4713249fe19b432139.pdf",
        "text": "https://archive.orkl.eu/084a9458973c1c5996891b4713249fe19b432139.txt",
        "img": "https://archive.orkl.eu/084a9458973c1c5996891b4713249fe19b432139.jpg"
    }
}