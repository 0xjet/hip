{
    "id": "06ceb421-7816-4700-a1ea-646d51a06ee0",
    "created_at": "2023-01-12T15:09:30.111022Z",
    "updated_at": "2025-03-27T02:16:39.928495Z",
    "deleted_at": null,
    "sha1_hash": "319cff897524bfe360fa249af364eb75f492d290",
    "title": "2021-02-09 - Ghidra script to decrypt strings in Amadey 1.09",
    "authors": "",
    "file_creation_date": "2022-05-28T03:50:53Z",
    "file_modification_date": "2022-05-28T03:50:53Z",
    "file_size": 179860,
    "plain_text": "# Ghidra script to decrypt strings in Amadey 1.09\n\n**[maxkersten.nl/binary-analysis-course/analysis-scripts/ghidra-script-to-decrypt-strings-in-amadey-1-09/](https://maxkersten.nl/binary-analysis-course/analysis-scripts/ghidra-script-to-decrypt-strings-in-amadey-1-09/)**\n\n### This article was published on the 9th of February 2021. This article was updated on the 8th of December 2021.\n\n On the 21st of March 2019, the American National Security Agency (NSA) released Ghidra: a free and open-source reverse engineering tool. The tool can disassemble and decompile code for a variety of architectures. Additionally, users can create scripts in Python and Java using the exposed API. This article will cover the the string encryption in Amadey 1.09, and will provide a step-by-step guide to create an automatic string decryption script in Java.\n\n## Table of contents\n\n The sample\n\n### This sample is taken from KrabsOnSecurity‘s blog from Feburary 2019. The specific sample is the unpacked stage, as is described in the blog. The sample can be downloaded from VirusBay, Malware Bazaar, or MalShare. The hashes are given below.\n```\nMD5: dbaaa2699c639f652117e9176fd27fdf\nSHA-1: 3e4cd703deef2cfd1726095987766e2f062e9c57\nSHA-256: 654b53b4ef5b98b574f7478ad11192275178ca651d9e8496070651cd6f72656a\nSize: 51396 bytes\n\n Additionally, snippets from this blog by Lars A. Wallenborn and Jesko H. Hüttenhain about a Ghidra script to automatically decrypt strings in REvil samples are used. Within the code, credit to Lars’ and Jesko’s work and websites is given whenever it is used.\n\n## Scripting basics\n\n### Scripting in Ghidra can be done using Python and Java. Python scripts are executed with the help of Jython. As such, the native way of scripting in Ghidra, is with Java. Therefore, this is also what will be used in this article.\n\n In the official repository’s DevGuide, guidance is given with regards to configuring Ghidra with Eclipse. This is useful to develop Java based scripts in a proper IDE, with the option to debug the script.\n\n Once the environment is set-up, one will see that every script extends the GhidraScript class. This class forces the script to implement the run method, which is the starting point of the script’s code. Due to the inheritance of the GhidraScript class, the user has access to the\n\n```\n\n-----\n\n### FlatProgramAPI. Functions might be added to this class, but never removed. Or, as the NSA explains in the accompanied JavaDoc:\n```\nThis class is a flattened version of the Program API.\nNOTE:\n  1. NO METHODS SHOULD EVER BE REMOVED FROM THIS CLASS.\n  2. NO METHOD SIGNATURES SHOULD EVER BE CHANGED IN THIS CLASS. \nThis class is used by GhidraScript.\nChanging this class will break user scripts.\nThat is bad. Don't do that. \n\n Using Eclipse’s built-in auto-completion and JavaDoc viewer, its easy to view all functions that are directly accessible from the GhidraScript class. Alternatively, or additionally, one can read the publicly available JavaDoc on the NSA’s website.\n\n As is specified in the GhidraScript class, there are several variables that one can access within a script, without the need to initialise them. An excerpt of the Ghidra documentation is given below.\nAll scripts, when run, will be handed the current state in the form of class instance\nvariable. These variables are:\ncurrentProgram: the active program\ncurrentAddress: the address of the current cursor location in the tool\ncurrentLocation: the program location of the current cursor location in the tool, or\nnull if no program location exists\ncurrentSelection: the current selection in the tool, or null if no selection exists\ncurrentHighlight: the current highlight in the tool, or null if no highlight exists\n\n Knowing the basics of scripting before starting to write code will result in a more efficient use of your time, as well as cleaner code.\n\n## Outline\n\n### The goal of the script is to automatically decrypt the encrypted strings that are present within the binary. As such, it is essential to be able to decrypt the strings. For this reason, it is the first step in this article. After that, it is important to get the required information from the user. What that is precisely, will follow logically from the decryption routine.\n\n Knowing how to decrypt the strings is only part of the job, as one will also need to find all references to the decryption function call and its argument(s). Knowing the arguments for each call, and the decryption routine itself, will allow the script to decrypt all strings. Knowing how to add comments to the disassembly and decompiler view will show the result in an organised fashion to the analyst.\n\n```\n\n-----\n\n### Before putting all the pieces are put together, a method to cache decrypted strings will be introduced. This will reduce the time the script needs to run if the same string is encountered multiple times.\n\n In this article, a Ghidra build from the 21st of December 2020 (which has a few more commits than Ghidra 9.2.1) is used. Due to the usage of the FlatProgramAPI, it should run on future versions, and is likely to run on older versions.\n\n## Finding the decryption routine\n\n### After loading this sample in Ghidra and running the default analysers, it becomes apparent that the sample’s symbols were not stripped during the compilation. As such, it becomes easy to find the main function, as is given below. Note that the function is called _main.\n```\nint __cdecl _main(int _Argc,char **_Argv,char **_Env)\n{\n char *pcVar1;\n size_t in_stack_fffffff0;\n __alloca(in_stack_fffffff0);\n ___main();\n __Z10aBypassUACv();\n pcVar1 = __Z12aGetSelfPathv();\n __Z13aDropToSystemPc(pcVar1);\n pcVar1 = __Z19aGetSelfDestinationi(0);\n __Z11aAutoRunSetPc(pcVar1);\n __Z6aBasici(0);\n return 0;\n}\n\n The mangled names provide insight into what the functions do. These symbols can be misleading, and should not always be trusted as-is, but the symbols in this sample are representative for the functionality that is within the functions. The ___main function, note the triple underscore, does not contain code that was made by the author.\n\n Searching for encrypted strings can be done in a variety of ways. One can use the Defined Strings view (as found in the Window toolstrip menu), browse through the function tree to look for a name that is likely to handle encrypted strings (which is __Z8aDecryptPc), or click through the functions until one encounters a function call that seems to decrypt a string (as can be seen in __Z6aBasici).\n\n The decryption routine is given below.\n\n```\n\n-----\n\n```\nundefined __cdecl __Z8aDecryptPc(char param_1)\n{\n size_t sVar1;\n uint local_10;\n _memset(&_ZZ8aDecryptPcE14aDecryptResult,0,0x400);\n local_10 = 0;\n while( true ) {\n  sVar1 = _strlen(param_1);\n  if (sVar1 <= local_10) break;\n  sVar1 = _strlen(s_1ee76e11929a07445c5abd744aa407db_00405000);\n  (&_ZZ8aDecryptPcE14aDecryptResult)[local_10] =\n     param_1[local_10] - s_1ee76e11929a07445c5abd744aa407db_00405000[local_10 %\nsVar1];\n  local_10 = local_10 + 1;\n }\n return &_ZZ8aDecryptPcE14aDecryptResult;\n}\n\n### At first, two variables are declared, after which the memory buffer for the output is set. The variable local_10 is incremented with one at the end of every iteration in the while loop. Only when the length of the input is equal or bigger than the amount of iterations that have taken place, the endless loop breaks. At last, the result is returned. The decryption itself is based on the used key, together with the iterative value. Refactoring the method with more readable names, the function becomes easily readable.\nundefined * __cdecl __Z8aDecryptPc(char *input)\n{\n size_t inputLength;\n uint i;\n _memset(&result,0,0x400);\n i = 0;\n while( true ) {\n  inputLength = _strlen(input);\n  if (inputLength <= i) break;\n  inputLength = _strlen(key);\n  (&result)[i] = input[i] - key[i % inputLength];\n  i = i + 1;\n }\n return &result;\n}\n\n In conclusion, this function requires one argument, which is decrypted using a hardcoded key, after which the decrypted value is returned.\n\n## Remaking the decryption routine\n\n### As the Ghidra script is to be written in Java, the decryption routine is also to be written in Java. The ported function will take two arguments, rather than one. The first one is the input, which is the string to decrypt. As memory is read from the sample, the type of this variable is\n\n```\n\n-----\n\n### a byte array. The second argument is the decryption key, which is represented as a string. The ported function is more readable than the decompiled code, as can be seen below.\n```\nprivate String decrypt(byte[] input, String key) {\n     char[] keyArray = key.toCharArray();\n     int keyLength = keyArray.length;\n     byte[] output = new byte[input.length];\n     for (int i = 0; i < input.length; i++) {\n          output[i] = (byte) (input[i] - keyArray[i % keyLength]);\n     }\n     return new String(output);\n}\n\n## Getting user-input\n\n### Getting information from the user is a useful way to make a script more generic. If a specific malware family uses the same decryption routine with a different key per sample, one can request the key from the user, without the need to alter the decryption script.\n\n In Ghidra, one can request values from the user using the ask* functions, where the asterisk should be read as a wildcard, as there are many functions present to help. Aside from the added convenience of not having to write such a function, it is important to note that a user cannot provide an empty string to this dialog. The requested string cannot be null either, as closing the dialog will lead to the termination of the script, which is clearly shown to the user in Ghidra’s console.\n\n To print data to the console, one can use the built-in println and print functions. The difference is that the latter does not print the script name into the console.\n\n In this case, the askString function is used to request a string from the user. Within the script, two values will be required: the name of the decryption function and the key that is used to decrypt the encrypted input.\n\n## Getting all cross references for the decryption function\n\n### The decryption function’s name is obtained earlier on in the script, as the user provides the name. Based on that, one can get a list of functions that use this name. As symbol names do not have to be unique in Ghidra, it is possible that there are more functions with the same name. The code to obtain such a list is given below.\nList<Function> functions = getGlobalFunctions(functionName);\n\n Basic sanity checks to see if there are more functions with the given name can be implemented. The ReferenceIterator class is present in the currentProgram variable, which is already initialised. Using the getReferencesTo function, one can use an Address object to get\n\n```\n\n-----\n\n### all references to that address. To convert a raw address, which is represented as a Long, to an Address object, one can use the toAddr function. This function is accessible via the extended GhidraScript class.\n```\nReferenceIterator references =\ncurrentProgram.getReferenceManager().getReferencesTo(toAddr(decryptionFunctionAddress)\n\n To iterate over all references, one can use a simple for-loop, as is shown below.\nfor (Reference reference : references) {\n  Address address = reference.getFromAddress();\n  //...\n}\n\n This for-loop is the basis for the following steps, as these have to be done per reference. Obtaining the address for the reference is the first action that has to be completed.\n\n## Iterating all decryption calls\n\n### This part of the script is based upon two steps. The first one is being able to decrypt a given string, which is possible due to the decryption method that was written in an earlier step. The second step is to obtain the encrypted string for each function call. To do so, one can use code from the earlier mentioned blog by Lars A. Wallenborn and Jesko H. Hüttenhain.\n\n The function named getConstantCallArgument is used. This function requires two arguments, the first being an Address object, and the second is an integer array. The Address object is the address of the function call. The integer array is used to obtain one or more arguments of the given function’s call. The indices of the arguments in this array correspond with the arguments for the function call, where the first index is 1, unlike the usual 0 in an array. The function is given below.\n\n```\n\n-----\n\n```\n//Code by Lars A. Wallenborn and Jesko H. Hüttenhain (see\nhttps://blag.nullteilerfrei.de/2020/02/02/defeating-sodinokibi-revil-stringobfuscation-in-ghidra/) with a slight change in the exception handling by Max 'Libra'\nKersten\nprivate OptionalLong[] getConstantCallArgument(Address addr, int[] argumentIndices)\n          throws IllegalStateException, IllegalArgumentException {\n     int argumentPos = 0;\n     OptionalLong argumentValues[] = new OptionalLong[argumentIndices.length];\n     Function caller = getFunctionBefore(addr);\n     if (caller == null)\n          throw new IllegalStateException();\n     DecompInterface decompInterface = new DecompInterface();\n     decompInterface.openProgram(currentProgram);\n     DecompileResults decompileResults = decompInterface.decompileFunction(caller,\n120, monitor);\n     if (!decompileResults.decompileCompleted())\n          throw new IllegalStateException();\n     HighFunction highFunction = decompileResults.getHighFunction();\n     Iterator<PcodeOpAST> pCodes = highFunction.getPcodeOps(addr);\n     while (pCodes.hasNext()) {\n          PcodeOpAST instruction = pCodes.next();\n          if (instruction.getOpcode() == PcodeOp.CALL) {\n              for (int index : argumentIndices) {\n                   argumentValues[argumentPos] =\ntraceVarnodeValue(instruction.getInput(index));\n                   argumentPos++;\n              }\n          }\n     }\n     return argumentValues;\n}\n\n### This function returns an array of OptionalLong objects. Such an object can contain a Long, although it might not. In some cases, there might occur an error whilst retrieving the address, meaning that the object itself is actually set to null. To avoid returning null, the OptionalLong object is used.\n\n Within the function, the decompiler interface is used to get access to the PCode values. For each call, the Varnode‘s value is traced using traceVarnodeValue, which is also written by Lars A. Wallenborn and Jesko H. Hüttenhain. The code is given below.\n\n```\n\n-----\n\n```\n//Code by Lars A. Wallenborn and Jesko H. Hüttenhain (see\nhttps://blag.nullteilerfrei.de/2020/02/02/defeating-sodinokibi-revil-stringobfuscation-in-ghidra/) with a slight change in the exception handling by Max 'Libra'\nKersten\nprivate OptionalLong traceVarnodeValue(Varnode argument) throws\nIllegalArgumentException {\n     while (!argument.isConstant()) {\n          PcodeOp ins = argument.getDef();\n          if (ins == null)\n              break;\n          switch (ins.getOpcode()) {\n          case PcodeOp.CAST:\n          case PcodeOp.COPY:\n              argument = ins.getInput(0);\n              break;\n          case PcodeOp.PTRSUB:\n          case PcodeOp.PTRADD:\n              argument = ins.getInput(1);\n              break;\n          case PcodeOp.INT_MULT:\n          case PcodeOp.MULTIEQUAL:\n              return OptionalLong.empty();\n          default:\n              throw new IllegalArgumentException(String.format(\"Unknown\nopcode %s for variable copy at %08X\",\n                        ins.getMnemonic(),\nargument.getAddress().getOffset()));\n          }\n     }\n     return OptionalLong.of(argument.getOffset());\n}\n\n### Within the decryption routine in Amadey 1.09, only a single argument is used. This argument points to an encrypted value of a string. As such, the index one wants to retrieve is the only equal to one, meaning an integer array with the value 1 at index 0 is required as input. The address for the function is the address of each referenced function call of the decryption routine. The integer array is given below.\nint[] argumentIndices = { 1 };\n\n One can get the Long value from the OptionalLong object by using the getAsLong function, as can be seen in the code below.\nLong argument = arguments[0].getAsLong();\n\n Right now, all information to decrypt a string has been obtained, as the address of the encrypted string, the decryption key, and the decryption routine have been collected. The getDecryptedArgument function contains all code to decrypt an argument, which is then returned as a string. It requires an address as a Long, and the decryption string as a String. The code for the function is given below.\n\n```\n\n-----\n\n```\nprivate String getDecryptedArgument(Long argument, String key) throws\nMemoryAccessException {\n     MemoryBlock block = getMemoryBlock(toAddr(argument));\n     int size = ((Long) block.getSize()).intValue();\n     byte[] input = getBytes(toAddr(argument), size);\n     String decryptedValue = decrypt(input, key);\n     decryptedValue = decryptedValue.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\");\n     return getFirstReadableString(decryptedValue);\n}\n\n### At first, a memory block is read, based on the address of the given argument. The getMemoryBlock function is accessible via the GhidraScript class. The size of the block is stored in a different variable to increase the readability of the code. The getBytes function, also accessible via the GhidraScript class, gets the bytes from the given argument’s location until the location plus the given size.\n\n The decryptedValue string contains the decrypted string. If any newline and carriage return values are present in that string, they are escaped using the chained replace function calls. The input that was provided to the decryption function is much bigger than the actual string. As such, the first human readable string has to be recovered, which is done using the getFirstReadableString method.\n\n This method, as can be seen below, requires a string as input, and will return the first human readable string.\n\n```\n\n-----\n\n```\nprivate String getFirstReadableString(String input) {\n     int beginIndex = -1;\n     int endIndex = -1;\n     int asciiLow = 0;\n     int asciiHigh = 255;\n     for (int i = 0; i < input.toCharArray().length; i++) {\n          char currentChar = input.charAt(i);\n          if (currentChar < asciiHigh || currentChar > asciiLow) {\n              beginIndex = i;\n              break;\n          }\n     }\n     for (int i = 0; i < input.toCharArray().length; i++) {\n          char currentChar = input.charAt(i);\n          if (currentChar > asciiHigh || currentChar < asciiLow) {\n              endIndex = i;\n              break;\n          }\n     }\n     if (beginIndex >= 0 && endIndex >= 0) {\n          return input.substring(beginIndex, endIndex);\n     }\n     return \"NO_ASCII_STRING_FOUND\";\n}\n\n### This function declares four local integers, named beginIndex, endIndex, asciiLow, and asciiHigh. The first two are set to -1, whereas the last two are set to 0 and 255 respectively. The beginIndex and endIndex are used to store the beginning and ending indices of the first human readable string, whereas the latter two variables are hardcoded to define the beginning and ending of the human readable range of ASCII characters. Wide strings are out of scope for this function, as they are not used within this sample.\n\n The given string is iterated over twice: once for the first character, and once for the last character. Whilst this can be done in a single loop, this would decrease the code’s readability. As this function is rather rudimentary at best, the code’s optimisation has not been included in this article.\n\n The return value of this function is a substring of the provided input. If none of the characters are readable, then a default value is returned. This default value is never returned in the used sample.\n\n## Caching the decrypted results\n\n```\n\n-----\n\n### Even though some optimisation steps were left out in the previous step, this step is purely meant as an optimisation. Caching results is a useful way to easily decrease the time that the script takes, without adding a needless complex layer of logic into the code.\n\n At first, a mapping is created. Mappings are often known as dictionaries in other languages. In this case, the mapping will use addresses (as a Long) as a key, where the value at a given key is a String. The mapping’s keys are the locations of the encrypted variables, whereas the mapping’s values are decrypted strings. The creation of the mapping is given below.\n```\nMap<Long, String> handled = new HashMap<>();\n\n When iterating over the argument locations, the following if-statement is required to implement the caching of decrypted values.\nif (handled.containsKey(argument)) {\n  //...\n} else {\n  //...\n}\n\n As such, it checks if the given address already present in the mapping. If it is, the value for the given key should be used. Otherwise, it can go through the normal decryption process, and add the outcome to the given mapping. The lookup in the mapping is much quicker than the decryption routine, thereby saving several seconds in a small sample such as this. In testing on my local machine, the script’s runtime went down from 22 seconds to 16 seconds. Slower computers might benefit more of the caching, whereas faster computers might benefit less.\n\n## Adding comments and bookmarks\n\n### Once the decrypted values have been obtained, they need to be handed back to the user. This is done in multiple ways. One can add comments (both to the disassembly and decompiler views), bookmarks, and print the results in the output window. In the code below, both comment methods, as well as the bookmark creation, have been listed. Do note that existing bookmarks for a specific address will be overwritten with the createBookmark function.\n//Decompiler comment\ncurrentProgram.getListing().getCodeUnitAt(toAddr(argument)).setComment(CodeUnit.PLATE_\n comment);\n//Disassembly comment\ncurrentProgram.getListing().getCodeUnitAt(toAddr(argument)).setComment(CodeUnit.PRE_CO\n comment);\n//Bookmark creation\ncreateBookmark(toAddr(argument), \"Decrypted string\", \"The variable named \" +\ngetSymbolAt(toAddr(argument)) + \" is equal to \\\"\" + decryptedValue + \"\\\"\");\n\n## Putting it all together\n\n```\n\n-----\n\n### The complete script is given below. It contains a few more sanity checks, the most notable being the user feedback when providing details, and the check if there is only a single function with the provided name. When running the script, the following output is observed at the end, aside from the list of decrypted values in Ghidra’s console:\n```\nDecrypted 47 strings (using 11 cached strings), placed 210 comments, and \ncreated 47 bookmarks in 16 seconds!\n\n To show the difference in the decompiled code, two excerpts are given. The first excerpt is the decompiler output in Ghidra prior to running the string decryption script, as can be seen below.\n pcVar2 = __Z8aDecryptPc(&_aAV00);\n bVar1 = __Z7aPathAVPc(pcVar2);\n uVar3 = bVar1 != false;\n pcVar2 = __Z8aDecryptPc(&_aAV01);\n bVar1 = __Z7aPathAVPc(pcVar2);\n if (bVar1 != false) {\n  uVar3 = 2;\n }\n pcVar2 = __Z8aDecryptPc(&_aAV02);\n bVar1 = __Z7aPathAVPc(pcVar2);\n if (bVar1 != false) {\n  uVar3 = 3;\n }\n pcVar2 = __Z8aDecryptPc(&_aAV03);\n bVar1 = __Z7aPathAVPc(pcVar2);\n if (bVar1 != false) {\n  uVar3 = 4;\n }\n pcVar2 = __Z8aDecryptPc(&_aAV04);\n bVar1 = __Z7aPathAVPc(pcVar2);\n if (bVar1 != false) {\n  uVar3 = 5;\n }\n\n The second one contains the comments that have been added by the script.\n\n```\n\n-----\n\n```\n          / Decrypted value: AVAST Software /\n pcVar2 = __Z8aDecryptPc(&_aAV00);\n bVar1 = __Z7aPathAVPc(pcVar2);\n uVar3 = bVar1 != false;\n          /* Decrypted value: \"Avira\" */\n pcVar2 = __Z8aDecryptPc(&_aAV01);\n bVar1 = __Z7aPathAVPc(pcVar2);\n if (bVar1 != false) {\n  uVar3 = 2;\n }\n          /* Decrypted value: \"Kaspersky Lab\" */\n pcVar2 = __Z8aDecryptPc(&_aAV02);\n bVar1 = __Z7aPathAVPc(pcVar2);\n if (bVar1 != false) {\n  uVar3 = 3;\n }\n          /* Decrypted value: \"ESET\" */\n pcVar2 = __Z8aDecryptPc(&_aAV03);\n bVar1 = __Z7aPathAVPc(pcVar2);\n if (bVar1 != false) {\n  uVar3 = 4;\n }\n          /* Decrypted value: \"Panda Security\" */\n pcVar2 = __Z8aDecryptPc(&_aAV04);\n bVar1 = __Z7aPathAVPc(pcVar2);\n if (bVar1 != false) {\n  uVar3 = 5;\n }\n\n### The decompiled code becomes easily readable, especially with the included symbols. This allows the analyst to quickly analyse the malware’s functionality.\n\n## Conclusion\n\n### Scripting will greatly reduce the amount of time that an analyst needs to spend when looking at a repetitive task. Understanding the basics of Ghidra’s architecture will greatly reduce the amount of time an analyst needs to write such a script. By creating a heavily documented script, it becomes reusable for similar tasks in other samples. As such, each new script will make future work easier.\n\n Note that not all parts of the script in this article are required, more specifically the caching part. Even though it does save some time in this script, the overhead that it requires to write the code is longer than the time that is saved with it. When looking at a sample that has a really heavy decryption routine, and/or a lot of encrypted strings, the overhead might be worth it.\n\n This trade-off is up to the analyst to decide, and is also depending on the goal of analyst. Learning how to write such a script might involve more work that is not necessarily the most efficient for a given sample, but has a positive influence on the analyst’s future scripting abilities.\n\n```\n\n-----\n\n## The complete script\n\n### The complete script is given below. It can be added as a file to any working ghidra_script directory, or one can use the simple editor within Ghidra to create a new script and paste this script in it.\n\n\n-----\n\n```\n//This script is used to annotate function calls to decrypt strings with the\ndecrypted string. The decryption routine and key are taken from an Amadey sample\n(MD5: dbaaa2699c639f652117e9176fd27fdf). One can easily modify the code to make it\nsuitable for other families or decryption routines.\n//@author Max 'Libra' Kersten\n//@category String decryption\n//@keybinding \n//@menupath \n//@toolbar \nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.OptionalLong;\nimport ghidra.app.decompiler.DecompInterface;\nimport ghidra.app.decompiler.DecompileResults;\nimport ghidra.app.script.GhidraScript;\nimport ghidra.program.model.address.Address;\nimport ghidra.program.model.listing.CodeUnit;\nimport ghidra.program.model.listing.Function;\nimport ghidra.program.model.mem.MemoryAccessException;\nimport ghidra.program.model.mem.MemoryBlock;\nimport ghidra.program.model.pcode.HighFunction;\nimport ghidra.program.model.pcode.PcodeOp;\nimport ghidra.program.model.pcode.PcodeOpAST;\nimport ghidra.program.model.pcode.Varnode;\nimport ghidra.program.model.symbol.Reference;\nimport ghidra.program.model.symbol.ReferenceIterator;\npublic class Amadey extends GhidraScript {\n     /**\n     * Global variable that is used to keep track of the amount of decrypted\nstrings\n     */\n     private int decryptionCount;\n     /**\n     * Global variable that is used to keep track of the amount of comments that\n     * have been set\n     */\n     private int commentCount;\n     /**\n     * Global variable that is used to keep track of the amount of bookmarks that\n     * have been set\n     */\n     private int bookmarkCount;\n     /**\n     * Global variable that is used to keep track of the amount of variables that\n\n```\n\n-----\n\n```\n      have been cached\n     */\n     private int cacheCount;\n     /**\n     * This function is the first that is called by Ghidra when running the\nscript.\n     * In here, variables need to be initialised first. This script uses this\n     * function to obtain information from the user, and to verify this\ninformation.\n     * After the verification and other sanity checks, the \"handle\" function is\n     * called. In there, the decryption logic starts.\n     */\n     public void run() throws Exception {\n          // Initialisation of the three counters, starting at zero\n          decryptionCount = 0;\n          commentCount = 0;\n          bookmarkCount = 0;\n          cacheCount = 0;\n          /*\n          * Requesting the function name in a pop-up dialog. The result is\nprovided as\n          * the return value, which is stored into the variable\n          */\n          String functionName = askString(\"Function name required\",\n                   \"Please provide the name of the function that\ndecrypts the strings:\");\n          // Provide feedback to the user regarding the provided function name\n          println(\"Received function name: \" + functionName);\n          /*\n          * Request the decryption key in a pop-up dialog. The result is\nprovided as the\n          * return value, which is stored into the variable\n          */\n          String key = askString(\"Decryption key required\",\n                   \"Please provide the name of the function that is used\nduring the string decryption:\");\n          // Provide feedback to the user regarding the provided decryption key\n          println(\"Received decryption key: \" + key);\n          /*\n          * The lack of checks for null values or empty strings are omitted,\nas the\n          * pop-up dialog does not accept empty strings. Closing the dialog\nwill result\n          * in the cancellation of the whole script, which is out of scope to\nhandle\n          * here.\n          */\n          /*\n          * Get all the functions for the given name. Symbol names do not need\nto be\n\n```\n\n-----\n\n```\n           unique in Ghidra, hence the fact that a list is returned\n          */\n          List<Function> functions = getGlobalFunctions(functionName);\n          // If there is only one function with that name, it is safe to\ncontinue\n          if (functions.size() == 1) {\n              // The first, and only, function resides at index 0\n              Function function = functions.get(0);\n              /*\n               * The function address is the first address of the function,\nwhich is the\n               * minimum.\n               */\n              long decryptionFunctionAddress =\nfunction.getBody().getMinAddress().getOffset();\n              // Provide feedback to the user about the decryption function\ndetails\n              println(\"Decryption function (\" + function.getName() + \"\nfound at 0x\"\n                        + Long.toHexString(decryptionFunctionAddress)\n+ \")\");\n              // A divider is printed as the decryption process is about to\nstart\n              println(\"----------------------------------------------------------------\");\n              // To keep track of the time, the start time is saved\n              Instant begin = Instant.now();\n              // The \"handle\" function deals with the decryption logic\n              handle(decryptionFunctionAddress, key);\n              // After the function returns, the end time is saved\n              Instant end = Instant.now();\n              // The difference between the two is calculated\n              Duration duration = Duration.between(begin, end);\n              // As the decryption routine has finished, a new divided is\nprinted\n              println(\"----------------------------------------------------------------\");\n              // The collected statistics, as well as the time the script\ntook, are then\n              // printed\n              println(\"Decrypted \" + decryptionCount + \" strings (using \" +\ncacheCount + \" cached strings), placed \"\n                        + commentCount + \" comments, and created \" +\nbookmarkCount + \" bookmarks in \" + duration.toSeconds()\n                        + \" seconds!\");\n              // Provide more information about the script to the user\n              println(\"If you have any questions or suggestions, feel free\nto ping me on Twitter: @Libranalysis\");\n          } else if (functions.size() == 0) {\n              /*\n               * If no function is found, the user is notified and the\nscript returns\n\n```\n\n-----\n\n```\n               /\n              println(\"No functions were found for the given name, please\nmake sure the name is correct and try again.\");\n          } else if (functions.size() >= 2) {\n              /*\n               * If multiple functions are using the same name, the user\nshould pick a unique\n               * name for the decryption function and try again\n               */\n              println(\"More than one function with this name has been\nfound. Ensure that the name is unique and try again.\");\n          }\n     }\n     /**\n     * This function handles the string decryption logic. It caches the decrypted\n     * strings, meaning strings that are decrypted more than once, do not need to\nbe\n     * decrypted, as the mapping already exists. The decrypted variables and\n     * cross-references are commented in both the disassembly view, as well as\nthe\n     * decompiler. Additionally, bookmarks are added for each decrypted string.\n     * \n     * @param decryptionFunctionAddress the address of the decryption function\n     *                 within the sample\n     * @param key            the decryption key\n     */\n     private void handle(long decryptionFunctionAddress, String key) {\n          /*\n          * Create a mapping for handled strings and the address of the\nvariable the\n          * encrypted content resides at\n          */\n          Map<Long, String> handled = new HashMap<>();\n          /*\n          * The reference iterator is not limited to a reference amount limit,\nwhereas\n          * some other methods are\n          */\n          ReferenceIterator references = currentProgram.getReferenceManager()\n                   .getReferencesTo(toAddr(decryptionFunctionAddress));\n          // Iterate over all references\n          for (Reference reference : references) {\n              /*\n               * Get the address of the location that calls the string\ndecryption function\n               */\n              Address address = reference.getFromAddress();\n              /*\n               * Get the index of the argument that is to be decrypted.\nNote that the index\n               * count for this starts at 1 (unlike the usual starting\npoint of 0).\n\n```\n\n-----\n\n```\n               /\n              int[] argumentIndices = { 1 }; // The decryption routine has\nonly one argument\n              try {\n                   // Get an array with the addresses of the given\nindices, in this case only 1\n                   OptionalLong[] arguments =\ngetConstantCallArgument(address, argumentIndices);\n                   // Get the address from the array as a long\n                   Long argument = arguments[0].getAsLong();\n                   // Initialise the variables to ensure there are no\ncompiler errors\n                   String decryptedValue = \"\";\n                   String comment = \"\";\n                   /*\n                    * If the mapping already contains the address of the\nencrypted variable, it has\n                    * already been encountered (and thus decrypted)\nbefore. Simply obtaining the\n                    * value in the mapping for the given key (the\nvariable's address) yields the\n                    * correct result and decreases the time the script\nneeds to run\n                    */\n                   if (handled.containsKey(argument)) {\n                        decryptedValue = handled.get(argument);\n                        comment = \"Decrypted value (from cache): \\\"\"\n+ decryptedValue + \"\\\"\";\n                        //Increase the cache count with one\n                        cacheCount++;\n                   } else {\n                        /**\n                        * If the address of the encrypted variable\nis not present, it has not been\n                        * encountered before. As such, it needs to\nbe decrypted.\n                        */\n                        decryptedValue =\ngetDecryptedArgument(argument, key);\n                        comment = \"Decrypted value: \\\"\" +\ndecryptedValue + \"\\\"\";\n                        /*\n                        * Set comments at the variable itself in the\ndisassembly and decompiler views\n                        * respectively\n                        */\ncurrentProgram.getListing().getCodeUnitAt(toAddr(argument)).setComment(CodeUnit.PLATE_\n                                  comment);\ncurrentProgram.getListing().getCodeUnitAt(toAddr(argument)).setComment(CodeUnit.PRE_CO\n\n```\n\n-----\n\n```\n                                  comment);\n                        // Increase the comment count with two, based\non the above added comments\n                        commentCount += 2;\n                        // Create a bookmark at the encrypted\nvariable's address\n                        createBookmark(toAddr(argument), \"Decrypted\nstring\", \"The variable named \"\n                                  +\ngetSymbolAt(toAddr(argument)) + \" is equal to \\\"\" + decryptedValue + \"\\\"\");\n                        // Increase the bookmark count, based on the\nabove added bookmark\n                        bookmarkCount++;\n                        // Add this address (and the decrypted value)\nto the mapping\n                        handled.put(argument, decryptedValue);\n                   }\n                   /*\n                    * Regardless how the data was obtained, the user is\nprovided with feedback\n                    * related to decryption of the string. The argument\nis also printed, as it\n                    * becomes clickable in the console in Ghidra,\nallowing the user to navigate to\n                    * it by double clicking.\n                    */\n                   println(comment + \" (located at 0x\" +\nLong.toHexString(argument) + \" )\");\n                   /*\n                    * Set comments at the reference in the disassembly\nand decompiler views\n                    * respectively\n                    */\ncurrentProgram.getListing().getCodeUnitAt(reference.getFromAddress()).setComment(CodeU\n                             comment);\ncurrentProgram.getListing().getCodeUnitAt(reference.getFromAddress()).setComment(CodeU\n                             comment);\n                   // Increase the comment count with two, based on the\nabove added comments\n                   commentCount += 2;\n              } catch (Exception ex) {\n                   println(ex.getMessage());\n              }\n          }\n     }\n\n```\n\n-----\n\n```\n     /**\n     * Gets the decrypted argument from the given address, which is decrypted\nusing\n     * the given key\n     * \n     * @param argument the address of the argument\n     * @param key   the key that is used to decrypted the value at the\nargument\n     * @return the decrypted string\n     * @throws MemoryAccessException if an error occurs when obtaining the bytes\nat\n     *                the given address\n     */\n     private String getDecryptedArgument(Long argument, String key) throws\nMemoryAccessException {\n          // Gets the memory block at the argument's address\n          MemoryBlock block = getMemoryBlock(toAddr(argument));\n          // The size of the memory block\n          int size = ((Long) block.getSize()).intValue();\n          // Get the bytes at the given address for the given size\n          byte[] input = getBytes(toAddr(argument), size);\n          // Get the raw string from the decryption routine\n          String decryptedValue = decrypt(input, key);\n          /*\n          * Replace values that are lower than 32 in the ASCII table with\nescaped ones,\n          * only those which are used in this sample are visible here\n          */\n          decryptedValue = decryptedValue.replace(\"\\n\", \"\\\\n\").replace(\"\\r\",\n\"\\\\r\");\n          // Get the first readable string from the block of memory and return\nthat value\n          return getFirstReadableString(decryptedValue);\n     }\n     /**\n     * Gets the first readable ASCII string from a given input. If no such value\ncan\n     * be found, the function will return \"NO_ASCII_STRING_FOUND\".\n     * \n     * @param input the string to obtain the first readable ASCII string from\n     * @return the first readable ASCII string\n     */\n     private String getFirstReadableString(String input) {\n          // The begin index of the human readable ASCII string\n          int beginIndex = -1;\n          // The end index of the human readable ASCII string\n          int endIndex = -1;\n          // The lowest human readable ASCII value\n          int asciiLow = 0;\n          // The highest human readable ASCII value\n          int asciiHigh = 255;\n\n```\n\n-----\n\n```\n          / \n          * This loop iterates over the given string to find the first human\nreadable\n          * ASCII character. When it does, the beginIndex variable is set to\nthat value\n          * and the loop is broken.\n          */\n          for (int i = 0; i < input.toCharArray().length; i++) {\n              char currentChar = input.charAt(i);\n              if (currentChar < asciiHigh || currentChar > asciiLow) {\n                   beginIndex = i;\n                   break;\n              }\n          }\n          /*\n          * This loop iterates over the given string to find the last human\nreadable\n          * ASCII character. When it does, the endIndex variable is set to\nthat value and\n          * the loop is broken.\n          */\n          for (int i = 0; i < input.toCharArray().length; i++) {\n              char currentChar = input.charAt(i);\n              if (currentChar > asciiHigh || currentChar < asciiLow) {\n                   endIndex = i;\n                   break;\n              }\n          }\n          /*\n          * If the beginIndex and endIndex are equal to zero or more, both\nvalues have\n          * been found in the two loops. As such, the human readable substring\ncan be\n          * returned as a substring from the input at the given two indices.\n          */\n          if (beginIndex >= 0 && endIndex >= 0) {\n              return input.substring(beginIndex, endIndex);\n          }\n          /*\n          * If either (or both) of the indices could not be found, the default\nvalue is\n          * returned\n          */\n          return \"NO_ASCII_STRING_FOUND\";\n     }\n     /**\n     * The decryption routine that is present in this specific sample\n     * \n     * @param input the encrypted data\n     * @param key  the decryption key\n     * @return the decrypted string\n\n```\n\n-----\n\n```\n     /\n     private String decrypt(byte[] input, String key) {\n          // The key from the sample\n          char[] keyArray = key.toCharArray();\n          // The length of the key in the sample\n          int keyLength = keyArray.length;\n          // The encrypted data is stored in input\n          // The decrypted data\n          byte[] output = new byte[input.length];\n          // Loop through the input\n          for (int i = 0; i < input.length; i++) {\n              // Decrypt the character\n              output[i] = (byte) (input[i] - keyArray[i % keyLength]);\n          }\n          // Increase the decryption count\n          decryptionCount++;\n          // Return the decrypted string\n          return new String(output);\n     }\n     /**\n     * This function returns an array of optional longs. The size of this array\nis\n     * equal to the size of the argument indices' size. The indices of the\nfunctoin\n     * at the given address starts at 1, unlike the usual 0.\n     * \n     * @author Lars A. Wallenborn and Jesko H. Hüttenhain(see\n     *     https://blag.nullteilerfrei.de/2020/02/02/defeating-sodinokibirevil-string-obfuscation-in-ghidra/)\n     *     with a slight change in the exception handling by Max 'Libra'\nKersten\n     * \n     * @param addr      the address of the function\n     * @param argumentIndices the indices of the arguments of said function,\n     *            starting at 1\n     * @return an array of optional longs, with the addresses of the variables\n     * @throws IllegalStateException if the previously defined function is null\nor\n     *                if the decompiler fails to complete\n     * @throws UnknownVariableCopy  if the variable's varnode type is unknown\n     */\n     private OptionalLong[] getConstantCallArgument(Address addr, int[]\nargumentIndices)\n              throws IllegalStateException, IllegalArgumentException {\n          int argumentPos = 0;\n          OptionalLong argumentValues[] = new\nOptionalLong[argumentIndices.length];\n          Function caller = getFunctionBefore(addr);\n          if (caller == null)\n              throw new IllegalStateException();\n          DecompInterface decompInterface = new DecompInterface();\n          decompInterface.openProgram(currentProgram);\n\n```\n\n-----\n\n```\n          DecompileResults decompileResults \ndecompInterface.decompileFunction(caller, 120, monitor);\n          if (!decompileResults.decompileCompleted())\n              throw new IllegalStateException();\n          HighFunction highFunction = decompileResults.getHighFunction();\n          Iterator<PcodeOpAST> pCodes = highFunction.getPcodeOps(addr);\n          while (pCodes.hasNext()) {\n              PcodeOpAST instruction = pCodes.next();\n              if (instruction.getOpcode() == PcodeOp.CALL) {\n                   for (int index : argumentIndices) {\n                        argumentValues[argumentPos] =\ntraceVarnodeValue(instruction.getInput(index));\n                        argumentPos++;\n                   }\n              }\n          }\n          return argumentValues;\n     }\n     /**\n     * This function returns an optional long for the given argument's value.\n     * \n     * @author Lars A. Wallenborn and Jesko H. Hüttenhain (see\n     *     https://blag.nullteilerfrei.de/2020/02/02/defeating-sodinokibirevil-string-obfuscation-in-ghidra/),\n     *     with a slight change in the exception handling by Max 'Libra'\nKersten\n     * \n     * @param argument the instruction at the given index as a Varnode object\n     * @return the address of the argument's value\n     * @throws UnknownVariableCopy if the variable is unknown\n     */\n     private OptionalLong traceVarnodeValue(Varnode argument) throws\nIllegalArgumentException {\n          while (!argument.isConstant()) {\n              PcodeOp ins = argument.getDef();\n              if (ins == null)\n                   break;\n              switch (ins.getOpcode()) {\n              case PcodeOp.CAST:\n              case PcodeOp.COPY:\n                   argument = ins.getInput(0);\n                   break;\n              case PcodeOp.PTRSUB:\n              case PcodeOp.PTRADD:\n                   argument = ins.getInput(1);\n                   break;\n              case PcodeOp.INT_MULT:\n              case PcodeOp.MULTIEQUAL:\n                   return OptionalLong.empty();\n              default:\n                   throw new\nIllegalArgumentException(String.format(\"Unknown opcode %s for variable copy at %08X\",\n                             ins.getMnemonic(),\nargument.getAddress().getOffset()));\n\n```\n\n-----\n\n```\n              }\n          }\n          return OptionalLong.of(argument.getOffset());\n     }\n}\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-02-09 - Ghidra script to decrypt strings in Amadey 1.09.pdf"
    ],
    "report_names": [
        "2021-02-09 - Ghidra script to decrypt strings in Amadey 1.09.pdf"
    ],
    "threat_actors": [
        {
            "id": "b43e5ea9-d8c8-4efa-b5bf-f1efb37174ba",
            "created_at": "2022-10-25T16:07:24.36191Z",
            "updated_at": "2025-03-27T02:02:10.1909Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "Dark Halo",
                "Nobelium",
                "SolarStorm",
                "StellarParticle",
                "UNC2452"
            ],
            "source_name": "ETDA:UNC2452",
            "tools": [],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "70872c3a-e788-4b55-a7d6-b2df52001ad0",
            "created_at": "2023-01-06T13:46:39.18401Z",
            "updated_at": "2025-03-27T02:00:03.01553Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "DarkHalo",
                "StellarParticle",
                "NOBELIUM",
                "Solar Phoenix",
                "Midnight Blizzard"
            ],
            "source_name": "MISPGALAXY:UNC2452",
            "tools": [
                "SNOWYAMBER",
                "HALFRIG",
                "QUARTERRIG"
            ],
            "source_id": "MISPGALAXY",
            "reports": null
        },
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "1d3f9dec-b033-48a5-8b1e-f67a29429e89",
            "created_at": "2022-10-25T15:50:23.739197Z",
            "updated_at": "2025-03-27T02:00:55.536417Z",
            "deleted_at": null,
            "main_name": "UNC2452",
            "aliases": [
                "UNC2452",
                "NOBELIUM",
                "StellarParticle",
                "Dark Halo"
            ],
            "source_name": "MITRE:UNC2452",
            "tools": [
                "Sibot",
                "Mimikatz",
                "Cobalt Strike",
                "AdFind",
                "GoldMax"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "2864e40a-f233-4618-ac61-b03760a41cbb",
            "created_at": "2023-12-01T02:02:34.272108Z",
            "updated_at": "2025-03-27T02:02:10.209072Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "ETDA:WildCard",
            "tools": [
                "RustDown",
                "SysJoker"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "20d3a08a-3b97-4b2f-90b8-92a89089a57a",
            "created_at": "2022-10-25T15:50:23.548494Z",
            "updated_at": "2025-03-27T02:00:55.49688Z",
            "deleted_at": null,
            "main_name": "APT29",
            "aliases": [
                "APT29",
                "IRON RITUAL",
                "IRON HEMLOCK",
                "NobleBaron",
                "Dark Halo",
                "NOBELIUM",
                "UNC2452",
                "YTTRIUM",
                "The Dukes",
                "Cozy Bear",
                "CozyDuke",
                "SolarStorm",
                "Blue Kitsune",
                "UNC3524",
                "Midnight Blizzard"
            ],
            "source_name": "MITRE:APT29",
            "tools": [
                "PinchDuke",
                "ROADTools",
                "WellMail",
                "CozyCar",
                "Mimikatz",
                "Tasklist",
                "OnionDuke",
                "FatDuke",
                "POSHSPY",
                "EnvyScout",
                "SoreFang",
                "GeminiDuke",
                "GoldMax",
                "FoggyWeb",
                "SDelete",
                "PolyglotDuke",
                "AADInternals",
                "MiniDuke",
                "SeaDuke",
                "Sibot",
                "RegDuke",
                "CloudDuke",
                "GoldFinder",
                "AdFind",
                "PsExec",
                "NativeZone",
                "Systeminfo",
                "ipconfig",
                "Impacket",
                "Cobalt Strike",
                "PowerDuke",
                "QUIETEXIT",
                "HAMMERTOSS",
                "BoomBox",
                "CosmicDuke",
                "WellMess",
                "VaporRage",
                "LiteDuke"
            ],
            "source_id": "MITRE",
            "reports": null
        },
        {
            "id": "f27790ff-4ee0-40a5-9c84-2b523a9d3270",
            "created_at": "2022-10-25T16:07:23.341684Z",
            "updated_at": "2025-03-27T02:02:09.74554Z",
            "deleted_at": null,
            "main_name": "APT 29",
            "aliases": [
                "APT 29",
                "ATK 7",
                "Blue Dev 5",
                "BlueBravo",
                "Cloaked Ursa",
                "CloudLook",
                "Cozy Bear",
                "Dark Halo",
                "Earth Koshchei",
                "Grizzly Steppe",
                "Group 100",
                "ITG11",
                "Iron Hemlock",
                "Iron Ritual",
                "Midnight Blizzard",
                "Minidionis",
                "Nobelium",
                "NobleBaron",
                "Operation Ghost",
                "Operation Office monkeys",
                "Operation StellarParticle",
                "SilverFish",
                "Solar Phoenix",
                "SolarStorm",
                "StellarParticle",
                "TEMP.Monkeys",
                "The Dukes",
                "UNC2452",
                "UNC3524",
                "Yttrium"
            ],
            "source_name": "ETDA:APT 29",
            "tools": [
                "7-Zip",
                "ATI-Agent",
                "AdFind",
                "Agentemis",
                "AtNow",
                "BEATDROP",
                "BotgenStudios",
                "CEELOADER",
                "Cloud Duke",
                "CloudDuke",
                "CloudLook",
                "Cobalt Strike",
                "CobaltStrike",
                "CosmicDuke",
                "Cozer",
                "CozyBear",
                "CozyCar",
                "CozyDuke",
                "Danfuan",
                "EnvyScout",
                "EuroAPT",
                "FatDuke",
                "FoggyWeb",
                "GeminiDuke",
                "Geppei",
                "GoldFinder",
                "GoldMax",
                "GraphDrop",
                "GraphicalNeutrino",
                "GraphicalProton",
                "HAMMERTOSS",
                "HammerDuke",
                "LOLBAS",
                "LOLBins",
                "LiteDuke",
                "Living off the Land",
                "MagicWeb",
                "Mimikatz",
                "MiniDionis",
                "MiniDuke",
                "NemesisGemina",
                "NetDuke",
                "OnionDuke",
                "POSHSPY",
                "PinchDuke",
                "PolyglotDuke",
                "PowerDuke",
                "QUIETEXIT",
                "ROOTSAW",
                "RegDuke",
                "Rubeus",
                "SNOWYAMBER",
                "SPICYBEAT",
                "SUNSHUTTLE",
                "SeaDaddy",
                "SeaDask",
                "SeaDesk",
                "SeaDuke",
                "Sharp-SMBExec",
                "SharpView",
                "Sibot",
                "Solorigate",
                "SoreFang",
                "TinyBaron",
                "WINELOADER",
                "WellMail",
                "WellMess",
                "cobeacon",
                "elf.wellmess",
                "reGeorg",
                "tDiscoverer"
            ],
            "source_id": "ETDA",
            "reports": null
        },
        {
            "id": "256a6a2d-e8a2-4497-b399-628a7fad4b3e",
            "created_at": "2023-11-30T02:00:07.299845Z",
            "updated_at": "2025-03-27T02:00:03.257794Z",
            "deleted_at": null,
            "main_name": "WildCard",
            "aliases": [],
            "source_name": "MISPGALAXY:WildCard",
            "tools": [],
            "source_id": "MISPGALAXY",
            "reports": null
        }
    ],
    "ts_created_at": 1673536170,
    "ts_updated_at": 1743041799,
    "ts_creation_date": 1653709853,
    "ts_modification_date": 1653709853,
    "files": {
        "pdf": "https://archive.orkl.eu/319cff897524bfe360fa249af364eb75f492d290.pdf",
        "text": "https://archive.orkl.eu/319cff897524bfe360fa249af364eb75f492d290.txt",
        "img": "https://archive.orkl.eu/319cff897524bfe360fa249af364eb75f492d290.jpg"
    }
}