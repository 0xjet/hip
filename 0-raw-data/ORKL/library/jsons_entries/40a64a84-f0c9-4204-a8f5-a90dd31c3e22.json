{
    "id": "40a64a84-f0c9-4204-a8f5-a90dd31c3e22",
    "created_at": "2023-01-12T15:04:25.267257Z",
    "updated_at": "2025-03-27T02:05:48.158791Z",
    "deleted_at": null,
    "sha1_hash": "83566fffd7d1113d06b5acfec9a88144092502f2",
    "title": "2021-11-12 - Malware Analysis- Syscalls- Examining how to analyse malware that uses syscalls as opposed to API calls",
    "authors": "",
    "file_creation_date": "2022-05-28T15:22:36Z",
    "file_modification_date": "2022-05-28T15:22:36Z",
    "file_size": 657256,
    "plain_text": "# Malware Analysis: Syscalls\n\n**jmpesp.me/malware-analysis-syscalls-example/**\n\nm0rv4i November 12, 2021\n\n[This blog post can accompany a walkthrough video with herrcore on YouTube available here.](https://twitter.com/herrcore)\n\nIn the eternal cat-and-mouse chase between cyber attackers and cyber defenders, one of\nthe critical activities that defenders can perform is the analysis of malware to draw out IOCs\n(Indicators of Compromise) and determine what it is that the malware has actually done on a\nsystem.\n\nWhen malware is run on a Windows system it needs to interact with that system in some\nway. One of the most common ways to do so is by using the Windows API, where well\nknown API calls such `VirtualAllocateEx,` `WriteProcessMemory and`\n```\nCreateRemoteThread would allow malware to inject some malicious code into a process\n\n```\nand then run that code.\n\n\n-----\n\nFor this reason, when debugging malware one of the first things you ll see people do is set\nbreakpoints on these well known API calls and any others that could be used to perform\nmalicious actions.\n\nSimilarly, defensive software such as EDRs will often monitor these API calls, such as by\nhooking them so that when they are called they first take a detour into EDR code where the\narguments and behaviour can be analysed, before allowing the API call to continue.\n\nAttackers have attempted to circumvent this by going 'lower' and using internal or\nundocumented API calls, such as `RtlCreateUserThread or` `NtAllocateVirtualMemory,`\nbut these in turn are now also under close scrutiny.\n\nThe latest step is to move the angle of approach to as close to the kernel as possible, and to\nuse syscalls directly, but first we should probably cover what a syscall actually is.\n\n## Syscalls\n\nNote, the following applies to 64-bit executables on 64-bit Windows . While similar, 32-bit\napplications and on 32-bit Windows and WOW64 work slightly differently.\n\nAs alluded to above, the Windows Operating System (OS) has multiple layers of abstraction\nin order to allow developers internally some license to make changes to the way Windows\ninternals works without breaking any programs that use their APIs.\n\n[For example, Microsoft provide the Windows API with great documentation on msdn which](https://msdn.microsoft.com/)\ndevelopers that wish to interact with the OS are encouraged to use (for example\n```\nCreateThread in kernel32.dll which, unsurprisingly, creates a thread running some code).\n\n```\nThese API calls themselves may utilise other, lower level, internal or undocumented API\ncalls, such as `RtlCreateUserThread (in ntdll.dll), in order to provide that abstraction layer`\nand wrap code that may change or be platform dependent, etc.\n\nUltimately, most of these API calls need to make some change that needs to be handled by\nthe Windows Kernel (such as anything using hardware like reading and writing to disk).\n'Kernel space' is highly protected and userland code cannot make change to or call kernel\nfunctions, except through the use of syscalls.\n\n\n-----\n\nImage shamelessly pilfered from\n\nhttp://masters.donntu.org/\nThese syscalls takes place in functions in ntdll.dll (or Win32k for graphical calls), and are\nprefixed with `Nt or` `Zw, such as` `NtCreateThread . These are the functions that actually`\nperform the syscall, transferring execution from userland to the kernel in a controlled manner.\nSo when an application calls, for example, `CreateRemoteThread, the actual flow looks`\nsomething like this:\n\nImage nabbed from https://miro.medium.com/max/\nSo what does a syscall look like?\n\nEssentially a syscall is simply involves moving a predetermined number (the System Call\n_Number) into the_ `rax register and then invoking the` `syscall instruction, something like`\nthis:\n\n\n-----\n\nNtCreateThread in ntdll.dll making a syscall.\nThis then hands execution over to the kernel, which looks up the relevant function for this\nsyscall number in the System Service Dispatch Table (SSDT) and then invokes it.\n\n## Using Syscalls\n\nNow, using syscalls as a developer is risky as the syscall numbers are internal to Windows\nand can (and do) change with any update. So if you write code that uses the syscall\ninstruction directly you could have working code one minute and broken code the next.\n\nHowever, to attackers, they provide an excellent opportunity to hide their tracks by interacting\nwith the OS at the lowest possible userland level, bypassing any controls or detections in\nplace around the API layers and making life more difficult for reverse engineers as their\nbinaries will not have any of the usual imports for the activities they are performing. Similarly,\nthe usual breakpoints when dynamically reverse engineering malware on `VirtualProtect,`\n```\nVirtualAlloc, WriteProcessMemory etc are all useless, as those API calls are not\n\n```\nactually invoked.\n\nTo highlight this, I've written a simple example program that uses syscalls to execute some\n[benign 'Message Box' shellcode into a target process. The code is available here for anyone](https://github.com/m0rv4i/SyscallsExample)\ninterested in investigating further.\n\n[This program uses the popular Syswhispers2 project to do all the heavy lifting.](https://github.com/jthuraisamy/SysWhispers2)\nSyswhispers2 maintains a lookup table of known syscall numbers across Windows versions\nand updates and populates the `rax register with the appropriate value at runtime before`\ninvoking the `syscall instruction to perform the action.`\n\nThe functions are named after their 'real' counterparts to make it easy to develop in, but\nmake no mistake - these are not the real functions ntdll.dll.\n\n\n-----\n\nSyswhispers2\n\nassembly for NtAllocateVirtualMemory\nAs we can see above, a function hash identifier is passed to the Syswhispers2\n```\nGetSyscallNumber function which will determine the current OS and return the correct\n\n```\nsyscall number (in the `rax register, as per usual).`\n\nAfter other register values are restored, the `syscall instruction is then called.`\n\nThis assembly file, along with the respective header and C files generated by Syswhispers2,\ncan be imported in any project and provide you with the suite of functions you need to\nperform syscalls in your program and not use the Windows APIs at all.\n\nIn our example, we allocate some memory in the target process, write the shellcode to it,\nchange it to execute permissions and then create a thread in the process to run the code.\n\n\n-----\n\n```\n#include <iostream>\n#include \"shellcode.h\"\n#include \"syscalls.h\"\n#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)\nint main(int argc, char* argv[])\n{\n  printf(\"**** Syscalls Example! ****\\n\");\n  if (argc != 2) {\n    printf(\"[!] Usage: %s <pid to inject into>\\n\", argv[0]);\n    return EXIT_FAILURE;\n  }\n  auto pid = atoi(argv[1]);\n  if (!pid) {\n    printf(\"[-] Invalid PID: %s\\n\", argv[1]);\n    return EXIT_FAILURE;\n  }\n  HANDLE hProcess;\n  CLIENT_ID clientId{};\n  clientId.UniqueProcess = (HANDLE)pid;\n  OBJECT_ATTRIBUTES objectAttributes = { sizeof(objectAttributes) };\n  auto status = NtOpenProcess(&hProcess, PROCESS_ALL_ACCESS, &objectAttributes,\n&clientId);\n  if (!NT_SUCCESS(status)) {\n    printf(\"[-] Failed to open process: %d, NTSTATUS: 0x%x\\n\", pid, status);\n    return EXIT_FAILURE;\n  }\n  printf(\"[*] Successfully opened process %d\\n\", pid);\n  size_t shellcodeSize = sizeof(shellcode) / sizeof(shellcode[0]);\n  printf(\"[*] Shellcode length: %lld\\n\", shellcodeSize);\n  PVOID baseAddress = NULL;\n  size_t allocSize = shellcodeSize;\n  status = NtAllocateVirtualMemory(hProcess, &baseAddress, 0, &allocSize,\nMEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n  if (!NT_SUCCESS(status)) {\n    printf(\"[-] Failed to allocate memory, NTSTATUS: 0x%x\\n\", status);\n    return EXIT_FAILURE;\n  }\n  printf(\"[*] Successfully allocated RW memory at 0x%p of size %lld\\n\",\nbaseAddress, allocSize);\n  size_t bytesWritten;\n  status = NtWriteVirtualMemory(hProcess, baseAddress, &shellcode, shellcodeSize,\n\n```\n\n-----\n\n```\n&bytesWritten);\n  if (!NT_SUCCESS(status)) {\n    printf(\"[-] Failed to write shellcode to memory at 0x%p, NTSTATUS: 0x%x\\n\",\nbaseAddress, status);\n    return EXIT_FAILURE;\n  }\n  printf(\"[*] Successfully wrote shellcode to memory\\n\");\n  DWORD oldProtect;\n  status = NtProtectVirtualMemory(hProcess, &baseAddress, &shellcodeSize,\nPAGE_EXECUTE_READ, &oldProtect);\n  if (!NT_SUCCESS(status)) {\n    printf(\"[-] Failed to change permission to RX on memory at 0x%p, NTSTATUS:\n0x%x\\n\", baseAddress, status);\n    return EXIT_FAILURE;\n  }\n  printf(\"[*] Successfully changed memory protections to RX\\n\");\n  HANDLE hThread;\n  CONTEXT threadContext;\n  CLIENT_ID threadClientId;\n  USER_STACK teb;\n  status = NtCreateThreadEx(&hThread, GENERIC_EXECUTE, NULL, hProcess, baseAddress,\nNULL, FALSE, NULL, NULL, NULL, NULL); \n  if (!NT_SUCCESS(status)) {\n    printf(\"[-] Failed to create thread, NTSTATUS: 0x%x\\n\", status);\n    return EXIT_FAILURE;\n  }\n  printf(\"[*] Successfully created thread in process\\n\");\n  printf(\"[+] Shellcode injected using syscalls!\\n\");\n  return EXIT_SUCCESS;\n}\n\n```\nSyscalls example code using Syswhispers2\nAs you can see Syswhispers2 has made is super easy to use syscalls in malware, however\nany of this can be done manually of course or in slightly different ways by malware authors.\n\n### Analysis\n\nSo now to the meat of the matter, what does malware that uses syscalls look like under the\nmicroscope, and what do we need to know to look for?\n\nIf we examine our example binary in CFF Explorer we can see that, as expected, it doesn't\nimport any of the usual suspect API calls, similar to if it was using dynamic API resolution.\n\n\n-----\n\nOur syscalls example doesn't import any of the usual 'suspicious' imports.\nIf we run it in a debugger, none of our API breakpoints get hit.\n\nWhen we start to statically reverse engineer the binary we don't see calls to `LoadLibrary,`\nno API hashes or dynamic resolution.\n\nIf we see this, and suspect the use of syscalls, one quick and easy win is to simply check for\nany `syscall instructions. We can do this in IDA through the Text search with Find all`\n_occurrences checked._\n\n\n-----\n\nSearch for syscall instructions in IDA\n\nThe text search which find all occurrences of 'syscall', including syscall instructions.\nNormal applications should almost under no circumstances be making syscalls directly, and\ninstead be using API calls to interact with the OS. If you find syscall instructions it is a large\nred flag.\n\nExamining one of these instances we can see the function and recognise it from\nSyswhispers2, with the API hash being passed to the syscall number identification function\nand the the `syscall instruction itself at the bottom.`\n\nOne example\n\nof the syscall instruction found by the text search.\n\n\n-----\n\nWe can take this function hash ( 0xFBCC0E8 ) and search for it in our example project, or\nSyswhispers2 itself, and find that it is for `NtReadFile .`\n\nWe can\n\nmatch that call to the Syswhispers2 function.\nOf course this only works if the target is using Syswhispers2, but knowing that the PE is\nusing syscalls can help focus reversing efforts and ensure we don't miss anything. Attackers\ncan also use hard-coded syscall numbers if they know the specific version of Windows that\nthe payload will be run on, or write their own syscall number resolution routine.\n\nSimilarly, they can also set up a syscall and populate the `rax register but` `jmp to a`\nlegitimate `syscall instruction in ntdll.dll. In this case, our Text search wouldn't find`\nanything as there are no syscall instructions in the PE.\n\n### Dynamic Analysis\n\nThe best way however is to kernel debug the target and set breakpoints on the SSDT for\nfunctions of note (allocating virtual memory, writing to virtual memory etc), as this will allow\nthe analyst to track the activity with 100% certainty.\n\nThis topic warrants its own blog post however, so we shall cover this next time!\n\nAn alternative, if we searched and found `syscall instructions in the PE, is to take the list`\nof syscall instructions in IDA and use the relative offsets to place breakpoints on those calls\nwhen we're debugging the application.\n\n\n-----\n\nNoting the address and relative offset of the syscall instructions in IDA\nFor example, if we note the address of this instruction in IDA, we can see it's at a relative\noffset of `1B6D (0x140001B6d - the module base address of 0x140000000).`\n\nSo we can start debugging and stick a breakpoint on this offset (it is unlikely to be the same\naddress due to ASLR, but we can just add this offset to the module base address once its\nloaded) along with all the other syscall instructions, and from there start to build a picture of\nwhat the application is doing.\n\n_Edit: After this blog post went out_ _[readgsqword on twitter reached out and shared the](https://twitter.com/readgsqword)_\n_following code for idapython which I have included here._\n```\nfrom idautils import *\nfrom idaapi import *\nfrom idc import *\ndef breakpoint_syscall():\n name = get_input_file_path().split(\"\\\\\")[-1]\n for segea in Segments():\n  for funcea in Functions(segea, get_segm_end(segea)):\n    functionName = get_func_name(funcea)\n    for (startea, endea) in Chunks(funcea):\n      for head in Heads(startea, endea):\n       disasm_line = generate_disasm_line(head,0)\n       if disasm_line.find(\"syscall\") != -1 and disasm_line.find(\"Low latency\nsystem call\") != -1:\n        offset = head - get_imagebase()\n        print(\"bp %s:0+0x%08x;\"%(name, offset))\n        idc.add_bpt(head)\nbreakpoint_syscall()\n\n```\nIf you have IDA pro you can paste this in the Python prompt and it will set a breakpoint on\neach code line in a function containing a syscall instruction.\n\n\n-----\n\nFor x64dbg lovers, it will also print the command needed to set breakpoints for each offset in\nx64dbg, which can be copy pasted into the x64dbg command prompt.\n\nThe code snippit in action.\n\nThe output\n\ncan be used to set breakpoints in x64dbg.\n\nThe\n\nbreakpoints set successfully.\nHere we can see it has created breakpoints on all five of the syscalls used\n( NtOpenProcess, `NtAllocateVirtualMemory,` `NtWriteVirtualMemory,`\n```\nNtProtectVirtualmemory and NtCreateThreadEx )\n\n```\nNote this will only create breakpoints for syscalls IDA finds in a function, so if the code is\nelsewhere in a binary or IDA believes is it not used, then this will not include those calls.\nHowever the search technique can be used as a fallback in that case.\n\nWe start debugging the malware again and once we hit the entrypoint we have the module\naddress:\n\nThe entrypoint\nbreakpoint in x64dbg providing an address in the module.\n\n\n-----\n\nWe know that a syscall instruction is at offset `1B6D, so we stick a breakpoint on`\n\n```\n0x7FF7C6E31B6D\n\n```\n\nSet our breakpoint\n\nThis time, when we continue execution, we hit the breakpoint and x64dbg helpfully informs\nus that this syscall will call `NtAllocateVirtualMemory`\n\nx64dbg examines the syscall number in `rax and informs us this syscall is`\n```\nNtAllocateVirtualMemory\n\n```\nA quick search and we can see that the second argument to `NtAllocateVirtualMemory is`\na pointer to the location that will receive the base address of the allocation.\n```\nNtAllocateVirtualMemory, despite being an internal API call, is documented on MSDN.\n\n```\nThe Windows 64-bit calling convention passes the first four integer arguments in the `rcx,`\n```\nrdx, r8 and r9 registers, so if we follow rdx in the dump and step over the syscall, we\n\n```\nwill see this location being populated with a pointer to the base address of the allocation.\n\n```\nrdx\n\n```\n\npoints to this location before we step over the syscall.\n\n\n-----\n\nThe same\n\nlocation after the syscall.\nWe can right-click this location and choose integer -> hex 64 to show this location as a 64 bit\nint, then copy the value and examine that region in our target process (here notepad.exe).\n\nThe location as an int\n\nWe can then open up the target process in Process Hacker and examine this location in\nmemory, noting that it has indeed been allocated.\n\n\n-----\n\nThe\n\nallocation was successful.\nIf we continue execution, rinsing and repeating for the other syscalls, we see the region get\npopulated with the shellcode, the thread get created and then the message box pop as the\nshellcode is run.\n\n\n-----\n\nThe region\n\n\nafter the shellcode has been written to it.\n\nThe shellcode executing.\n\n\n-----\n\nIt s worth noting however that this technique (along with the static analysis with the search)\nonly works if the syscalls instructions take place inside the malware, such as with\nSyswhispers2, which is why the ultimate authority when dealing with syscall malware is a\nkernel mode debugger.\n\n## Summary\n\nUsing syscalls is a sophisticated technique available to attackers that take a little extra work\nbut allows the malware to bypass API hooks, breakpoints and detections by interacting with\nthe kernel directly via the syscall interface.\n\nKnowing what to look for then if you suspect the use of syscalls then is extremely useful, and\nhaving this knowledge in the back pocket can help you avoid running afoul of malware using\nthis technique. We've looked at what syscalls are, and some ways to help locate and debug\nwhat they are doing in 64bit Windows executables.\n\nYou can find the example projects (including a vanilla API example and a syscalls example)\n[used in this blog on GitHub here: https://github.com/m0rv4i/SyscallsExample](https://github.com/m0rv4i/SyscallsExample)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-11-12 - Malware Analysis- Syscalls- Examining how to analyse malware that uses syscalls as opposed to API calls.pdf"
    ],
    "report_names": [
        "2021-11-12 - Malware Analysis- Syscalls- Examining how to analyse malware that uses syscalls as opposed to API calls.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535865,
    "ts_updated_at": 1743041148,
    "ts_creation_date": 1653751356,
    "ts_modification_date": 1653751356,
    "files": {
        "pdf": "https://archive.orkl.eu/83566fffd7d1113d06b5acfec9a88144092502f2.pdf",
        "text": "https://archive.orkl.eu/83566fffd7d1113d06b5acfec9a88144092502f2.txt",
        "img": "https://archive.orkl.eu/83566fffd7d1113d06b5acfec9a88144092502f2.jpg"
    }
}