{
    "id": "796202ad-a0d7-4461-9154-53e3ee29111a",
    "created_at": "2023-01-12T15:06:52.520257Z",
    "updated_at": "2025-03-27T02:05:18.085315Z",
    "deleted_at": null,
    "sha1_hash": "d96af297bf8c6a1731d682e40c33c14885c85e82",
    "title": "2020-11-09 - WOW64!Hooks- WOW64 Subsystem Internals and Hooking Techniques",
    "authors": "",
    "file_creation_date": "2022-05-28T00:25:06Z",
    "file_modification_date": "2022-05-28T00:25:06Z",
    "file_size": 145738,
    "plain_text": "# WOW64!Hooks: WOW64 Subsystem Internals and Hooking Techniques\n\n**[fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html](https://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html)**\n\nThreat Research\n\nStephen Eckels\n\nNov 09, 2020\n\n18 mins read\n\nThreat Research\n\nMicrosoft is known for their backwards compatibility. When they rolled out the 64-bit variant\nof Windows years ago they needed to provide compatibility with existing 32-bit applications.\nIn order to provide seamless execution regardless of application bitness, the WoW (Windows\non Windows) system was coined. This layer, which will be referred to as ‘WOW64’ from here\n\n\n-----\n\non out, is responsible for translating all Windows API calls from 32-bit userspace to the 64-bit\noperating system kernel. This blog post is broken up into two sections. First we start by\ndiving deep into the WOW64 system. To do this, we trace a call from 32-bit userspace and\nfollow the steps it takes to finally transition to the kernel. The second part of the post\nassesses two hooking techniques and their effectiveness. I will cover how this system works,\nthe ways malware abuses it, and detail a mechanism by which all WoW syscalls can be\nhooked from userspace. Note that all information here is true as of Windows 10, version\n2004 and in some cases has changed from how previous Windows versions were\nimplemented.\n\n**Recognition**\n\nFirst and foremost, this is a topic which has existing research by multiple authors. This work\nwas critical in efficient exploration of the internals and research would have taken much\nlonger had these authors not publicly posted their awesome work. I would like to callout the\nfollowing references:\n\n[(wbenny): An extremely detailed view of WOW64 internals on ARM](https://wbenny.github.io/2018/11/04/wow64-internals.html)\n[(ReWolf): A PoC heaven’s gate implementation](http://blog.rewolf.pl/blog/?p=102)\n[(JustasMasiulis): A very clean C++ heaven’s gate implementation](https://github.com/JustasMasiulis/wow64pp)\n[(MalwareTech): A WOW64 segmentation explanation](https://www.malwaretech.com/2014/02/the-0x33-segment-selector-heavens-gate.html)\n\n**WOW64 Internals**\n\nTo understand how the WOW64 system works internally we will explore the call sequence\nstarting in 32-bit usermode before transitioning into the kernel from within a system DLL.\nWithin these system DLLs the operating system will check arguments and eventually\ntransition to a stub known as a syscall stub. This syscall stub is responsible for servicing the\nAPI call in the kernel. On a 64-bit system, the syscall stub is straightforward as it directly\nexecutes the syscall instruction as shown in Figure 1.\n\n\n-----\n\nNative x64 Syscall Stub\n\n\nFigure 1: Native x64 Syscall Stub\nFigure 2 shows a syscall stub for a 32-bit process running on WOW64\n\n\n-----\n\nWOW64 Syscall Stub\n\n\nFigure 2: WOW64 Syscall Stub\nNotice that instead of a syscall instruction in the WOW64 version, Wow64SystemServiceCall\nis called. In the WOW64 system what would normally be an entry into the kernel is instead\nreplaced by a call to a usermode routine. Following this Wow64SystemServiceCall, we can\nsee in Figure 3 that it immediately performs an indirect jmp through a pointer named\nWow64Transition.\n\n\n-----\n\nWow64SystemService transitions through a pointer Wow64Transition\n\n\nFigure 3: Wow64SystemService transitions through a pointer ‘Wow64Transition’\nNote that the Wow64SystemServiceCall function is found within ntdll labeled as\nntdll_77550000; a WOW64 process has two ntdll modules loaded, a 32-bit one and a 64-bit\none. WinDbg differentiates between these two by placing the address of the module after the\n32-bit variant. The 64-bit ntdll can be found in %WINDIR%\\System32 and the 32-bit in\n%WINDIR%\\SysWOW64. In the PDBs, the 64bit and 32bit ntdlls are referred to as ntdll.pdb\nand wntdll.pdb respectively, try loading them in a disassembler! Continuing with the call\ntrace, if we look at what the Wow64Transition pointer holds we can see its destination is\nwow64cpu!KiFastSystemCall. As an aside, note that the address of\nwow64cpu!KiFastSystemCall is held in the 32-bit TEB (Thread Environment Block) via\nmember WOW32Reserved, this isn’t relevant for this trace but is useful to know. In Figure 4\nwe see the body of KiFastSystemCall.\n\n\n-----\n\nKiFastSystemCall transitions to x64 mode via segment selector 0x33\n\n\nFigure 4: KiFastSystemCall transitions to x64 mode via segment selector 0x33\nThe KiFastSystemCall performs a jmp using the 0x33 segment selector to a memory location\njust after the instruction. This 0x33 segment transitions the CPU into 64-bit mode via a GDT\nentry as described by (MalwareTech).\n\nLet's recap the trace we've performed to this point. We started from a call in ntdll,\nNtResumeThread. This function calls the Wow64SystemServiceCall function which then\nexecutes the Wow64Transition. The KiFastSystemCall performs the transition from 32-bit to\n64-bit execution. The flow is shown in Figure 5.\n\n\n-----\n\n32-bit to 64-bit transition\n\n\nFigure 5: 32-bit to 64-bit transition\nThe destination of the CPU transition jump is the 64-bit code show in Figure 6.\n\n\n-----\n\nDestination of KiFastSystemCall\n\n\nFigure 6: Destination of KiFastSystemCall\nFigure 6 shows the first 64-bit instruction we’ve seen executed in this call trace so far. In\norder to understand it, we need to look at how the WOW64 system initializes itself. For a\ndetailed explanation of this refer to (wbenny). For now, we can look at the important parts in\nwow64cpu!RunSimulatedCode.\n\n\n-----\n\n64bit registers are saved in RunSimulatedCode\n\n\nFigure 7: 64bit registers are saved in RunSimulatedCode\nFigure 7 depicts the retrieval of the 64-bit TEB which is used to access Thread Local Storage\nat slot index 1. Then the moving of a function pointer table into register r15. The TLS data\nretrieved is an undocumented data structure WOW64_CPURESERVED that contains\nregister data and CPU state information used by the WOW64 layer to set and restore\nregisters across the 32-bit and 64-bit boundaries. Within this structure is the\nWOW64_CONTEXT structure, [partially documented on the Microsoft website. I have listed](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-wow64_context)\nboth structures at the end of this post. We’ll look at how this context structure is used later,\nbut for our understanding of the jmp earlier all we need to know is that r15 is a function\npointer table.\n\nIt’s interesting to note at this point the architecture of the WOW64 layer. From the\nperspective of the 64-bit kernel the execution of 32-bit (Wow64) usermode applications is\nessentially a big while loop. The loop executes x86 instructions in the processor's 32-bit\n\n\n-----\n\nexecution mode and occasionally exits the loop to service a system call. Because the kernel\nis 64-bit, the processor mode is temporarily switched to 64-bit, the system call serviced, then\nthe mode switched back and the loop continued where it was paused. One could say the\nWOW64 layer acts like an emulator where the instructions are instead executed on the\nphysical CPU.\n\nGoing back to the jmp instruction we saw in Figure 6, we now know what is occurring. The\ninstruction jmp [r15 + 0xF8] is equivalent to the C code jmp TurboThunkDispatch[0xF8 /\nsizeof(uint64_t)]. Looking at the function pointer at this index we can see we’re at the\nfunction wow64cpu!CpupReturnFromSimulatedCode (Figure 8).\n\n\nTurboThunk table's last function pointer entry is an exit routine\n\n\nFigure 8: TurboThunk table's last function pointer entry is an exit routine\nThis routine is responsible for saving the state of the 32-bit registers into the\nWOW64_CONTEXT structure we mentioned before as well as retrieving the arguments for\nthe syscall. There is some trickiness going on here, so let’s examine this in detail. First a\n\n\n-----\n\npointer to the stack is moved into r14 via xchg, the value at this location will be the return\naddress from the syscall stub where Wow64SystemServiceCall was called. The stack pointer\nr14 is then incremented by 4 to get a pointer to where the stack should be reset when it’s\ntime to restore all these context values. These two values are then stored in the context’s\nEIP and ESP variables respectively. The r14 stack pointer is then incremented one more\ntime to get the location where the __stdcall arguments are (remember stdcall passes all\narguments on the stack). This argument array is important for later, remember it. The\narguments pointer is moved into r11, so in C this means that r11 is equivalent to an array of\nstack slots where each slot is an argument uint32_t r11[argCount]. The rest of the registers\nand EFlags are then saved.\n\nOnce the 32-bit context is saved, the WOW64 layer then calculates the appropriate\nTurboThunk to invoke by grabbing the upper 16 bits of the syscall number and dispatches to\nthat thunk. Note that at the beginning of this array is the function\nTurboDispatchJumpAddressEnd, shown in Figure 9, which is invoked for functions that do\nnot support TurboThunks.\n\n\n-----\n\nTurboThunk table s first function pointer entry is an entry routine\n\n\nFigure 9: TurboThunk table's first function pointer entry is an entry routine\nTurboThunks are described by (wbenny)—read his blog post at this point if you have not. To\nsummarize the post, for functions that have simple arguments with widths <= sizeof(uint32_t)\nthe WOW64 layer will directly widen these arguments to 64 bits via zero or sign-extension\nand then perform a direct syscall into the kernel. This all occurs within wow64cpu, rather\nthan executing a more complex path detailed as follows. This acts as an optimization. For\nmore complex functions that do not support TurboThunks the\nTurboDispatchJumpAddressEnd stub is used which dispatches to wow64!SystemServiceEx\nto perform the system call as shown in Figure 10.\n\n\n-----\n\nComplex system calls go through Wow64SystemServiceEx\n\n\nFigure 10: Complex system calls go through Wow64SystemServiceEx\nWe’ll look at this routine in a moment as it’s the meat of this blog post, but for now let’s finish\nthis call trace. Once Wow64SystemServiceEx returns from doing the system call the return\nvalue in eax is moved into the WOW64_CONTEXT structure and then the 32-bit register\nstates are restored. There’s two paths for this, a common case and a case that appears to\nexist only to be used by NtContinue and other WOW64 internals. A flag at the start of the\nWOW64_CPURESERVED structure retrieved from the TLS slot is checked, and controls\nwhich restore path to follow as shown in Figure 11.\n\n\n-----\n\nCPU state is restored once the system call is done; there s a simple path and a\ncomplex one handling XMM registers\n\nFigure 11: CPU state is restored once the system call is done; there’s a simple path and a\ncomplex one handling XMM registers\nThe simpler case will build a jmp that uses the segment selector 0x23 to transition back to\n32-bit mode after restoring all the saved registers in the WOW64_CONTEXT. The more\ncomplex case will additionally restore some segments, xmm values, and the saved registers\nin the WOW64_CONTEXT structure and then will do an iret to transition back. The common\ncase jmp once built is shown in Figure 12.\n\n\n-----\n\nDynamically built jmp to transition back to 32bit mode\n\n\nFigure 12: Dynamically built jmp to transition back to 32bit mode\nAt this point our call trace is complete. The WOW64 layer has transitioned back to 32-bit\nmode and will continue execution at the ret after Wow64SystemServiceCall in the syscall\nstub we started with. Now that an understanding of the flow of the WOW64 layer itself is\nunderstood, let’s examine the Wow64SystemServiceEx call we glossed over before.\n\nA little bit into the Wow64SystemServiceEx routine, Figure 13 shows some interesting logic\nthat we will use later.\n\n\n-----\n\nLogging routines invoked before and after dispatching the syscalls\n\n\nFigure 13: Logging routines invoked before and after dispatching the syscalls\nThe routine starts by indexing into service tables which hold pointers to routines that convert\nthe passed argument array into the wider 64-bit types expected by the regular 64-bit system\nmodules. This argument array is exactly the stack slot that was stored earlier in r14.\n\nTwo calls to the LogService function exist, however these are only called if the DLL\n%WINDIR%\\system32\\wow64log.dll is loaded and has the exports Wow64LogInitialize,\nWow64LogSystemService, Wow64LogMessageArgList, and Wow64LogTerminate. This DLL\nis not present on Windows by default, but it can be placed there with administrator\nprivileges.\n\nThe next section will detail how this logging DLL can be used to hook syscalls that transition\nthrough this wow64layer. Because the logging routine LogService is invoked before and after\nthe syscall is serviced we can achieve a standard looking inline hook style callback function\ncapable of inspecting arguments and return values.\n\n\n-----\n\n**Bypassing Inline Hooks**\n\nAs described in this blog post, Windows provides a way for 32-bit applications to execute 64bit syscalls on a 64-bit system using the WOW64 layer. However, the segmentation switch\nwe noted earlier can be manually performed, and 64-bit shellcode can be written to setup a\nsyscall. This technique is popularly called “Heaven’s Gate”. JustasMasiulis’ work\n[call_function64 can be used as a reference to see how this may be done in practice](https://github.com/JustasMasiulis/wow64pp/blob/be72557d0bd2e997d985fd9c590529b62de3765b/include/wow64pp.hpp#L727)\n(JustasMasiulis). When system calls are performed this way the 32-bit syscall stub that the\nWOW64 layer uses is completely skipped in the execution chain. This is unfortunate for\nsecurity products or tracing tools because any inline hooks in-place on these stubs are also\nbypassed. Malware authors know this and utilize “Heaven’s Gate” as a bypass technique in\nsome cases. Figure 14 and Figure 15 shows the execution flow of a regular syscall stub\nthrough the WOW64 layer, and hooked syscall stub where malware utilizes “Heaven’s Gate”.\n\n\nNtResumeThread transitioning through the WOW64 layer\n\n\nFigure 14: NtResumeThread transitioning through the WOW64 layer\n\n\n-----\n\nNtResumeThread inline hook before transitioning through the WOW64 layer\n\n\nFigure 15: NtResumeThread inline hook before transitioning through the WOW64 layer\nAs seen in Figure 15, when using the Heaven’s Gate technique, execution begins after the\ninline hook and WOW64 layer is done. This is an effective bypass technique, but one that is\neasy to detect from a lower level such as a driver or hypervisor. The easiest bypass to inline\nhooks is simply to restore the original function bytes, usually from bytes on disk. Malware\nsuch as AgentTesla and Conti has been known to utilize this last evasion technique.\n\n**Hooking WOW64 via Inline Hooks**\n\nAs a malware analyst being able to detect when samples attempt to bypass the WOW64\nlayer can be very useful. The obvious technique to detect this is to place inline hooks on the\n64-bit syscall stubs as well as the 32-bit syscall stubs. If the 64-bit hook detects an\ninvocation that didn’t also pass through the 32-bit hook, then it’s known that a sample is\n\n\n-----\n\nutilizing Heaven s Gate. This technique can detect both evasion techniques previously\ndetailed. However, in practice this is very difficult to implement. Looking at the requirements\nthat must be satisfied to hook the 64-bit syscall stub we come up with this list:\n\n1. Install 64-bit hook from a 32-bit module\n\nHow do you read/write 64-bit address space from a 32-bit module?\n2. Implement a 64-bit callback from a 32-bit module\n\nTypically, inline hooking uses C functions as callback stubs, but we’re compiling a\n32-bit module so we’ll have a 32-bit callback instead of the required 64-bit one.\n\nTo solve the first challenge ntdll kindly provides the exports NtWow64ReadVirtualMemory64,\nNtWow64WriteVirtualMemory64, and NtWow64QueryInformationProcess64. Using these it is\npossible to read memory, write memory, and retrieve the PEB of a 64-bit module from a 32bit process. However, the second challenge is much harder as either shellcode or a JIT will\nbe required to craft a callback stub of the right bitness. In practice ASMJIT may be utilized for\nthis. This is however a very tedious technique to trace a large number of APIs. There are\nother challenges to this technique as well. For example, in modern Windows 10 the base\naddress of ntdll64 is set to a high 64-bit address rather than a lower 32-bit address as in\nWindows 7. Due to this, supporting returns from callbacks back up to the original hooked\nstub and allocating a trampoline within the required memory range is difficult since the\nstandard ret instruction doesn’t have enough bits on the stack to represent the 64-bit return\naddress.\n\nAs an aside, it should be noted that the WOW64 layer contains what is likely a bug when\ndealing with the NtWow64* functions. These APIs all take a HANDLE as first argument,\nwhich should be sign extended to 64-bits. However, this does not occur for these APIs,\ntherefore when using the pseudo handle -1 the call fails with STATUS_INVALID_HANDLE.\nThis bug was introduced in an unknown Windows 10 version. To successfully use these APIs\nOpenProcess must be used to retrieve a real, positive valued handle.\n\nI will not be covering the internals of how to inline hook the 64-bit syscall stub since this post\n[is already very long. Instead I will show how my hooking library PolyHook2 can be extended](https://github.com/stevemk14ebr/PolyHook_2_0)\nto support cross-architecture hooking using these Windows APIs, and leave the rest as an\nexercise to the reader. This works because PolyHook’s trampolines are not limited to +-2GB\nand do not spoil registers. The internals of how that is achieved is a topic for another post.\nFigure 16 depicts how to overload the C++ API of polyhook to read/write memory using the\naforementioned WinAPIs.\n\n\n-----\n\nOverloading the memory operations to read/write/protect 64-bit memory\n\n\nFigure 16: Overloading the memory operations to read/write/protect 64-bit memory\nOnce these inline hooks are in-place on the 64-bit syscall stubs, any application utilizing\nHeaven’s Gate will be properly intercepted. This hooking technique is very invasive and\ncomplicated and can still be bypassed if a sample was to directly execute a syscall\ninstruction rather than using the 64-bit module’s syscalls stub. Therefore, a driver or\nhypervisor is more suitable to detect this evasion technique. Instead we can focus on the\nmore common byte restoration evasion techniques and look for a way to hook the WOW64\nlayer itself. This doesn’t involve assembly modifications at all.\n\n**Hooking WOW64 via LogService**\n\nThinking back to the WOW64 layer’s execution flow we know that all calls which are sent\nthrough the Wow64SystemServiceEx routine may invoke the routine\nWow64LogSystemService if the logging DLL is loaded. We can utilize this logging DLL and\n\n\n-----\n\nroutine to implement hooks which can be written the exact same way as inline hooks, without\nmodifying any assembly.\n\nThe first step to implementing this is to force all API call paths through the\nWow64SystemServiceEx routine so that the log routine may be called. Remember earlier\nthat those that support TurboThunks will not take this path. Lucky for us we know that any\nTurboThunk entry that points to TurboDispatchJumpAddressEnd will take this path.\nTherefore, by pointing every entry in the TurboThunk table to point at that address, the\ndesired behavior is achieved. Windows kindly implements this patching via\nwow64cpu!BTCpuTurboThunkControl as shown in Figure 17.\n\n\nPatching the TurboThunk table is implemented for us\n\n\nFigure 17: Patching the TurboThunk table is implemented for us\nNote that in previous Windows versions the module which exported this and how it did is\ndifferent to Windows 10, version 2004. After invoking this patch routine all syscall paths\nthrough WOW64 go through Wow64SystemServiceEx and we can focus on crafting a\n\n\n-----\n\nlogging DLL that man-in-the-middles (MITMs) all calls. There are a couple of challenges to\nbe considered here:\n\n1. How do we determine which system call is currently occurring from the logging DLL?\n2. How are callbacks written? Wow64log is 64-bit DLL, we’d like a 32-bit callback.\n\nIs shellcode required, or can we make nice C style function callbacks?\n3. What APIs may we call? All that’s loaded is 64-bit ntdll.\n\nThe first concern is rather easy, from within the wow64log DLL we can read the syscall\nnumber from the syscall stubs to create a map of number to name. This is possible because\nsyscall stubs always start with the same assembly and the syscall number is at a static offset\nof 0x4. Figure 18 shows how we can then compare the values in this map against the syscall\nnumber passed to Wow64LogSystemService’s parameter structure\nWOW64_LOG_SERVICE.\n\ntypedef uint32_t* WOW64_ARGUMENTS;\nstruct WOW64_LOG_SERVICE\n{\nuint64_t BtLdrEntry;\nWOW64_ARGUMENTS Arguments;\nULONG ServiceTable;\nULONG ServiceNumber;\nNTSTATUS Status;\nBOOLEAN PostCall;\n};\n\nEXTERN_C\n__declspec(dllexport)\nNTSTATUS\nNTAPI\nWow64LogSystemService(WOW64_LOG_SERVICE* service)\n{\nfor (uint32_t i = 0; i < LAST_SYSCALL_ID; i++) {\nconst char* sysname = SysCallMap[i].name;\nuint32_t syscallNum = SysCallMap[i].SystemCallNumber;\nif (ServiceParameters->ServiceNumber != syscallNum)\ncontinue;\n//LOG sysname\n}\n}\n\nFigure 18: Minimal example of determining which syscall is occurring—in practice the service\ntable must be checked too\n\nWriting callbacks is a bit more challenging. The wow64log DLL is executing in 64-bit mode\nand we’d like to be able to write callbacks in 32-bit mode since it’s very easy to load\nadditional 32-bit modules into a WOW64 process. The best way to handle this is to write\n\n\n-----\n\nshellcode which is capable of transitioning back to 32-bit mode, execute the callback, then\ngo back to 64-bit mode to continue execution in the wow64log DLL. The segment transitions\nthemselves are rather easy at this point, we know we just need to use 0x23 or 0x33 segment\nselectors when jumping. But we also need to deal with the calling convention differences\nbetween 64-bit and 32-bit. Our shellcode will therefore be responsible for moving 64-bit\narguments’ register/stack slots to the 32-bit arguments register/stack slots. Enforcing that 32bit callbacks may only be __cdecl makes this easier as all arguments are on the stack and\nthe shellcode has full control of stack layout and cleanup. Figure 19 shows the locations of\nthe arguments for each calling convention. Once the first 4 arguments are relocated all\nfurther arguments can be moved in a loop since it’s simply moving stack values into lower\nslots. This is relatively easy to implement using external masm files in MSVC. Raw bytes will\nneed to be emitted at points rather than using the assembler due to the mix of architectures.\nAlternatively, GCC or Clang inline assembly could be used. ReWolf’s work achieves the\nopposite direction of 32-bit -> 64-bit and implements the shellcode via msvc inline asm. X64\nMSVC doesn’t support this and there are complications with REX prefixes when using that\nmethod. It’s nicer to use external masm files and rely on the linker to implement this\nshellcode.\n\n**Arg Number** **Cdecl Location** **Fastcall Location** **Special Case?**\n\n0 [ebp + 8] rcx Yes\n\n1 [ebp + 12] rdx Yes\n\n2 [ebp + 16] r8d Yes\n\n3 [ebp + 20] r9d Yes\n\n4 [ebp + 24] [rbp + 32 + 8] No\n\n5 [ebp + 28] [rbp + 32 + 16] No\n\n6 [ebp + 32] [rbp + 32 + 24] No\n\nFigure 19: Cdecl vs Fastcall argument positions\n\nOnce this shellcode is written and wrapped into a nice C++ function, it’s possible for the\nwow64log DLL to invoke the callback via a simple C style function pointer call shown in\nFigure 20.\n\n\n-----\n\ncall_function32 invokes shellcode to call a 32-bit callback from the 64-bit logging DLL\n\n\nFigure 20: call_function32 invokes shellcode to call a 32-bit callback from the 64-bit logging\nDLL\nFrom within the 32-bit callback any desired MITM operations can be performed, but\nrestrictions exist on which APIs are callable. Due to the context saving that the WOW64 layer\nperforms, 32-bit APIs that would re-enter the WOW64 layer may not be called as the context\nvalues would be corrupted. We are therefore limited to only APIs that won’t re-enter WOW64,\nwhich are those that are exported from the 64-bit ntdll. The NtWriteFile export may be used\nto easily write to stdout or a file, but we must re-enter the 64-bit execution mode and do the\ninverse argument mapping as before. This logging routine can be called from within the 32bit callbacks and is shown in Figure 21 and Figure 22.\n\n\n-----\n\ncall_function64 invokes shellcode to call the 64bit WriteFile from with the 32bit\ncallback\n\nFigure 21: call_function64 invokes shellcode to call the 64bit WriteFile from with the 32bit\ncallback\n\n\n-----\n\n32bit callbacks must log via routines that only call non-reentrant WOW64 APIs\n\n\nFigure 22: 32bit callbacks must log via routines that only call non-reentrant WOW64 APIs\nThe result is clean looking callback stubs that function exactly how inline hooks might, but\nwith zero assembly modifications required. Arguments can easily be manipulated as well, but\nthe return status may not be modified unless a little stack walk hackery is implemented. The\nonly other consideration is that the wow64log DLL itself needs to be carefully crafted to not\nbuild with any CRT mechanisms. The flags required are:\n\nDisable CRT with /NODEFAULT LIB (all C APIs now unavailable), set a new entry point\nname to not init CRT NtDllMain\nDisable all CRT security routines /GSDisable C++ exceptions\nRemove default linker libraries, only link ntdll.lib\nUse extern “C” __declspec(dllimport) <typedef> to link against the correct NtApis\n\n\n-----\n\nAn example of a program hooking its own system calls via wow64log inline hooks is shown\nin Figure 23.\n\n\nDemonstration of inline hooks in action\n\n\nFigure 23: Demonstration of inline hooks in action\n\n**Conclusion**\n\nUsing inline WOW64 hooks, wow64log hooks, and kernel/hypervisor hooks, all techniques of\nusermode hook evasion can be identified easily and automatically. Detecting which layers of\nhooks are skipped or bypassed will give insight into which evasion technique is employed.\nThe identifying table is:\n\n\n**Evasion Mode** **32bit**\n**Inline**\n\n\n**wow64Log** **64bit**\n**Inline**\n\n\n**Kernel/Hypervisor**\n\n\n-----\n\nPrologue Restore ❌ ✔ ✔ ✔\n\nHeavens Gate sys-stub ❌ ❌ ✔ ✔\n\n\nHeavens Gate direct\nsyscall\n\n**Structure Appendix**\n\n\n❌ ❌ ❌ ✔\n\n\nstruct _WOW64_CPURESERVED\n\n{\nUSHORT Flags;\n\nUSHORT MachineType;\n\nWOW64_CONTEXT Context;\n\nchar ContextEx[1024];\n\n};\n\ntypedef ULONG *WOW64_LOG_ARGUMENTS;\n\nstruct _WOW64_SYSTEM_SERVICE\n\n{\nunsigned __int32 SystemCallNumber : 12;\n\nunsigned __int32 ServiceTableIndex : 4;\n\nunsigned __int32 TurboThunkNumber : 5;\n\nunsigned __int32 AlwaysZero : 11;\n\n};\n\n#pragma pack(push, 1)\n\nstruct _WOW64_FLOATING_SAVE_AREA\n\n{\nDWORD ControlWord;\n\nDWORD StatusWord;\n\nDWORD TagWord;\n\nDWORD ErrorOffset;\n\nDWORD ErrorSelector;\n\nDWORD DataOffset;\n\nDWORD DataSelector;\n\nBYTE RegisterArea[80];\n\nDWORD Cr0NpxState;\n\n};\n\n#pragma pack(pop)\n\n\n-----\n\n#pragma pack(push, 1)\nstruct _WOW64_CONTEXT\n{\nDWORD ContextFlags;\nDWORD Dr0;\nDWORD Dr1;\nDWORD Dr2;\nDWORD Dr3;\nDWORD Dr6;\nDWORD Dr7;\nWOW64_FLOATING_SAVE_AREA FloatSave;\nDWORD SegGs;\nDWORD SegFs;\nDWORD SegEs;\nDWORD SegDs;\nDWORD Edi;\nDWORD Esi;\nDWORD Ebx;\nDWORD Edx;\nDWORD Ecx;\nDWORD Eax;\nDWORD Ebp;\nDWORD Eip;\nDWORD SegCs;\nDWORD EFlags;\nDWORD Esp;\nDWORD SegSs;\nBYTE ExtendedRegistersUnk[160];\nM128A Xmm0;\nM128A Xmm1;\nM128A Xmm2;\nM128A Xmm3;\nM128A Xmm4;\nM128A Xmm5;\nM128A Xmm6;\nM128A Xmm7;\nM128A Xmm8;\nM128A Xmm9;\nM128A Xmm10;\nM128A Xmm11;\nM128A Xmm12;\nM128A Xmm13;\n\n\n-----\n\nM128A Xmm14;\nM128A Xmm15;\n};\n#pragma pack(pop)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-11-09 - WOW64!Hooks- WOW64 Subsystem Internals and Hooking Techniques.pdf"
    ],
    "report_names": [
        "2020-11-09 - WOW64!Hooks- WOW64 Subsystem Internals and Hooking Techniques.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536012,
    "ts_updated_at": 1743041118,
    "ts_creation_date": 1653697506,
    "ts_modification_date": 1653697506,
    "files": {
        "pdf": "https://archive.orkl.eu/d96af297bf8c6a1731d682e40c33c14885c85e82.pdf",
        "text": "https://archive.orkl.eu/d96af297bf8c6a1731d682e40c33c14885c85e82.txt",
        "img": "https://archive.orkl.eu/d96af297bf8c6a1731d682e40c33c14885c85e82.jpg"
    }
}