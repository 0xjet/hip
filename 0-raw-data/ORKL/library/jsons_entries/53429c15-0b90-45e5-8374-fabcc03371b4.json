{
    "id": "53429c15-0b90-45e5-8374-fabcc03371b4",
    "created_at": "2023-01-12T15:08:52.519157Z",
    "updated_at": "2025-03-27T02:05:51.884956Z",
    "deleted_at": null,
    "sha1_hash": "447820ef3fde47427ecc66084347bc666b4b14b3",
    "title": "2021-08-17 - Snakes on a Domain- An Analysis of a Python Malware Loader",
    "authors": "",
    "file_creation_date": "2022-05-27T21:55:15Z",
    "file_modification_date": "2022-05-27T21:55:15Z",
    "file_size": 10950923,
    "plain_text": "# Snakes on a Domain: An Analysis of a Python Malware Loader\n\n**[huntress.com/blog/snakes-on-a-domain-an-analysis-of-a-python-malware-loader](https://www.huntress.com/blog/snakes-on-a-domain-an-analysis-of-a-python-malware-loader)**\n\nHackers and snakes‚Äîoh my! What do they have in common? Both are shady characters that\ncan hide in plain sight, just waiting for the right moment to strike.\n\nBut how do you know if you have any unwanted pests nearby? Often, you just need to go\nlooking for them‚Äîand that‚Äôs exactly what we did. Along the way, we found a very shady Python\n(and coincidentally, a friendly RAT) just waiting to strike.\n\nJoin us on our journey as we show just how important it is to keep your yard‚Äîboth the real one\nwith green grass and the virtual one with bytes and binaries‚Äîclean and tidy. Otherwise, you\nnever know what kind of shady creatures may be lurking in the shadows.\n\n## What Happened?\n\nWe recently investigated a suspicious link file persisting in a user‚Äôs startup folder. The file was\nnamed ‚Äúsysmon.lnk‚Äù and looked a bit fishy. After some quick initial investigation, we found that\nthe link was executing a malicious Python script that was used to inject a remote access Trojan\n(RAT) onto the system.\n\nAlong the way, we encountered a total of six consecutive payloads and some new offensive\ntooling which we found pretty interesting. Towards the end, we also experimented with some\ncustom scripts for de-obfuscating data and extracting configuration from the final RAT, resulting\nin some juicy indicators of compromise (IOCs) with 0 detections on VirusTotal (as of June 2021)\n\n\n-----\n\n## Let s Dive In\n\nBefore we go too much further, here‚Äôs a visual representation of the malware we encountered.\n\nWe stumbled upon a suspicious file (sysmon.lnk) that appeared to reside in a user‚Äôs startup\ndirectory. The nature of the startup directory is to hold files that automatically run when a user\nlogs into the computer. Since it looks just like a normal folder, all you need to do is copy and\npaste a file into the folder, and boom‚Äîyou can persist, or stick around, between reboots.\n\nThis provides an easy way for legitimate programs to stick around and keep running. Given its\nsimplicity and stealth, it‚Äôs a common place that attackers will place malware and malicious files\nthat they want to stick around.\n\nWant to learn more about persistence? Download our eBook Persistence: The Key to\nCybercriminal Stealth, Strategy and Success.\n\n\n-----\n\nHere s a snippet of what we saw:\n\nc:\\\\users\\\n<username>\\appdata\\roaming\\microsoft\\windows\\startmenu\\programs\\startup\\sysmon.lnk\n\nThis is a .lnk file (also known as a shortcut file), which redirects to another file or command on\nthe system. Inspecting the.lnk file can tell us where it points to.\n\nWhen we inspected sysmon.lnk, we found that it was redirecting to a suspicious ‚Äúctfmon.exe‚Äù\nwith ‚Äúupdate.py‚Äù passed as an argument. Both were residing in a suspicious-looking directory:\n\nc:\\users\\<username>\\appdata\\roaming\\PpvcbBQh\\ctfmon.exe\n\nc:\\Users\\<username>\\AppData\\Roaming\\PpvcbBQh\\update.py\n\nSo, we retrieved the files and did some analysis.\n\n## File Analysis\n\nFirst, we noticed that the hash of ctfmon.exe had 0 detections on VirusTotal, which we found\ninteresting at first but were able to understand after looking at the file‚Äôs information. (Typically we\ncan‚Äôt trust file version information without a valid signature, but in this case, the information\nmade sense).\n\nThe information suggested that ctfmon.exe is a renamed Python interpreter‚Äîspecifically, an\n[IronPython interpreter, which utilizes a branch of Python with access to .NET libraries. This](https://ironpython.net/)\nallows Python code to access deep Windows OS functionality typically reserved for .NET or\nPowerShell. This was interesting and provided enough information to confidently move on to the\nPython file.\n\nWe can see that the original file ctfmon.exe had 0 detections on VirusTotal, as technically it‚Äôs a\nlegitimate interpreter and not a malicious file.\n\n\n-----\n\nBelow, we can see the file description, indicating that it was a renamed IronPython interpreter.\nAlternatively, we could have also discovered this information using PeStudio or a similar tool.\n\nThis was enough information to determine the purpose of the ctfmon.exe file, so we moved on\nto the Update.py file, which we‚Äôll refer to as stage1.py.\n\n### Stage1.py\n\nWe first moved the Python file into a text editor within a Virtual Machine just in case it was\nmalicious‚Äîand spoiler alert: it was. üòÖ\n\nThis led us to a relatively small script with a large obfuscated string and some obfuscated\nvariable names. We can see the full script in this screenshot:\n\n\n-----\n\nThis wasn‚Äôt super pleasant to read, so we cleaned it up a bit and added comments, which left\nthis script:\n\nIf we inspect closer, we can see that the script achieves four main things:\n\nBase64 decodes an obfuscated string\nIt converts the Base64-decoded string into a bytearray of hex values\nThen, it decreases the value of each byte by 12 (decimal)\nFinally, it executes the resulting data\n\nBy copying out the obfuscated string and recreating the logic in CyberChef, we were able to\nretrieve another Python script‚Äîwhich we saved and named as stage2.py. The decoding logic\ncan be seen below:\n\n\n-----\n\n### Stage2.py\n\nWe copied the resulting script out of CyberChef and opened up stage2 in a text editor, where we\nquickly noticed another obfuscated string, as well as some imported libraries related to\nreflection. (In case you‚Äôre not familiar, [reflection is a common technique used to execute code](https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection)\nfrom memory without needing to save it to disk‚Äîin this case, the ‚Äúsomething‚Äù would be the\nobfuscated string containing malware.)\n\nBased on this information, we assumed that the script was decoding the string and loading the\nresults into memory for execution.\n\n\n-----\n\nIn the middle of the above screenshot, we can observe two main operations used to decode the\nstring:\n\nReplacing all ‚Äú!‚Äù exclamation marks with the letter ‚ÄúA‚Äù\nBase64 decoding the results\n\nThis didn‚Äôt seem too complicated, so we moved back to CyberChef and recreated the decoding\n[logic. This resulted in the appearance of an MZ header, indicating that we had successfully](https://en.wikipedia.org/wiki/DOS_MZ_executable)\ndecoded the data and retrieved an executable file. We saved this file and named it stage3.bin.\n\n### Stage3.bin\n\nSaving stage3 as an executable file, we were able to do some basic inspection using PeStudio\n[and Detect-It-Easy (DIE). This quickly led us to the conclusion that this was a .NET file and](https://github.com/horsicq/Detect-It-Easy)\nlikely another stager (based on the presence of a path referencing injector.pdb).\n\nBelow, we can see that DIE recognized the file as a .NET executable, which meant we could\nuse Dnspy or ILspy for analysis.\n\n\n-----\n\n[Below, we can also see the PDB path with references to ‚Äúinjector.pdb‚Äù, indicating that this is](https://en.wikipedia.org/wiki/Program_database)\nlikely another stager doing some kind of injection:\n\nSince we now knew that this was a .NET file, we moved over to Dnspy where we could view the\nsource code of the file. This can be seen below.\n\n\n-----\n\nJust looking at the function names alone, we got a strong indication of what the file was going to\n[do. We can see functions indicative of Injection (VirtualAlloc,](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) [WriteProcessMemory, etc.),](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)\n[Dynamic Library/Function loading (GetProcAddress,](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) [LoadLibrary) and decoding (compress,](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya)\ndecompress, base64_encode). Without looking at the code in detail, we could already assume\nthe core functionality: an obfuscated payload is going to be decoded and injected into a\nprocess.\n\nBrowsing to the main function, we quickly found the encoded payload. Combined with the\npreceding function calls (Load, Decompress, Base64), we can assume that the data is being\nBase64 decoded and then decompressed and loaded into memory.\n\nBelow, we can see the encoded string and related function calls:\n\n\n-----\n\nTowards the end of the encoded data, we also observed a reference to msbuild.exe. This\nbecame important later, as it turned out to be the second argument passed to the Mandark.Load\nmethod.\n\nNext, we browsed to the Mandark.Load method to find out what else was happening‚Äîand to\ndetermine the significance of that msbuild.exe argument.\n\nThis led us to the conclusion that the second argument passed to the load method becomes the\n[target process for the injection. We also noted the use of ZwUnmapViewOfSection, indicating](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwunmapviewofsection)\n[that this style of injection is process hollowing. MITRE ATT&CK defines process hollowing:](https://attack.mitre.org/techniques/T1055/012/)\n\n‚ÄúAdversaries may inject malicious code into suspended and hollowed processes in order\nto evade process-based defenses. Process hollowing is a method of executing arbitrary\ncode in the address space of a separate live process.‚Äù\n\nWe believe that MSBuild was likely targeted as it is often allowed to execute by default\napplication whitelisting tools, including Microsoft's own Applocker.\n\n\n-----\n\nWith this new knowledge, we decided to move back to the main function and try to decode the\ninjected payload. We already noted that Base64 encoding and compression was used.\n\nWe quickly inspected the decompress method to confirm the compression type‚Äîin this case, it\nwas Gzip.\n\n\n-----\n\nCombining the above information together, we were able to decode the next payload using\nCyberChef. This resulted in another MZ header for an executable file. We saved this file and\nnamed it stage4.bin. Note that this payload would likely have been injected into the msbuild.exe\nprocess.\n\n### Stage4.bin\n\nLoading up stage4.bin, we performed some basic static analysis and determined that it was not\nanother .NET file, so we weren‚Äôt able to use Dnspy.\n\nBelow, we can see the detected compiler using DIE, which suggested that it was written in\nC++/C and not .NET.\n\n\n-----\n\nUsing PeStudio, we noticed this exported function, which stood out to us as it indicated that this\nwas likely another loader (given away by the term ‚ÄúReflectiveLoader‚Äù).\n\nWe noted this and kept going.\n\nBrowsing further, we noticed this reference in the debug section of the file. This contained\nanother PDB path, and a very git-like folder structure.\n\n\n-----\n\nSome googling of keywords in the PDB path led us to believe that the file was likely an executeassembly loader, which is an open-source re-implementation of the Cobalt Strike executeassembly module:\n\nIf the GitHub repository is anything to go by, this is an extremely well-featured and interesting\nloader that incorporates some really cool evasion tactics. We could almost dedicate an entire\nblog to the capabilities of this loader, but today, we‚Äôll stick to its loading capabilities and try to\nfocus on finding the next payload.\n\nWithin the rest of the GitHub repository documentation, there was this particular tidbit (see\nbelow) which really stood out. It indicated the structure of embedded payloads, which should be\nin the format of ‚Äú0|0|0|0|1|sizeofpayload.b64_encoded_compressed_payload‚Äù. (Note: The\npayload is going to be in Gzip compressed and Base64 encoded format.)\n\n\n-----\n\nThis was super interesting because there was a very large string within the file, which matched\nthat exact description (and was 64983 bytes in size‚Äîmore than enough room for another\npayload).\n\nWe copied that string into CyberChef and re-implemented the decoding routine (Base64 and\nGzip decompress), which resulted in yet another executable file.\n\n\n-----\n\nYou know the drill by now‚Äîwe saved this file and named it stage5.bin.\n\n### Stage5.bin\n\nPerforming our usual static analysis of our latest file, we soon realized that it was another .NET\n(yay). Luckily, we could jump back into Dnspy and view the source code.\n\nMoving into Dnspy, we noted that there weren‚Äôt many functions this time‚Äîonly six in total:\n\n\n-----\n\nNavigating to the main function, we noted two large obfuscated strings:\n\nThe first one was just Base64 encoded and turned out to be an anti-malware scan interface\n(AMSI) patching script. Implemented by Microsoft, AMSI provides a framework for security\ntooling to monitor PowerShell script activity. The goal of an AMSI patch is to bypass this\nframework and reduce the chances of an antivirus or EDR detecting any malicious PowerShell\nactivity. (Later, we‚Äôll see that the malware does use PowerShell scripts, so this patch likely\nallows them to execute without being detected.)\n\nBelow, we can see the full AMSI patching script, which was lightly obfuscated.\n\n\n-----\n\nWe were able to decode the script, which loosely translated to this below.\n\nThe second string was far more interesting, as it incorporated a custom encoding routine\nalongside the Base64 and compression that we‚Äôve been so far accustomed to. This was an\nindication that we need more than just CyberChef alone to decode our next payload.\n\nIn order to get a better understanding of the obfuscation, we inspected the Cipher method and\nfound the encoding routine. It didn‚Äôt look standard, and clearly, it was something custom-built‚Äî\nalthough not extremely complicated to decode. Routines like this are often used to evade\nautomated analysis, as the non-standard nature hinders some automated tooling‚Äîoften\nrequiring manual intervention and analysis to decode properly.\n\n\n-----\n\nBelow, we can see the full custom routine, which takes an encoded string, a key and an\nencipher flag.\n\nBrowsing back to our main function, we quickly found the key ‚Äúavyhk‚Äù and encipher flag, which\nwas set to false.\n\nWe decided not to pursue CyberChef for this. After some careful inspection and analysis, we\nwere able to re-implement the routine using the equivalent Python code included below.\n\n\n-----\n\nUsing our new Python script, we wrote a wrapper around our cipher function and we were able\nto dump the decoded content to a new file. Using this, we ended up with another executable file:\nstage6.bin.\n\n### Stage6.bin\n\nWe saved and loaded the stage6.bin file into PeStudio and DIE for some static analysis and saw\nthat we had another .NET file. (Yay for Dnspy again!)\n\n\n-----\n\nOverall, we didn‚Äôt find anything of particular use within PeStudio, so we moved on to Dnspy. We\nwere able to determine that the file was a remote access Trojan (RAT), likely from the URSU\nfamily of malware.\n\nThis malware had all the typical functionality of a RAT, which included the ability to gather and\nenumerate system information, as well as download files and commands from a remote\ncommand-and-control server.\n\n### Analysis of the RAT\n\nBelow, we can see a graphic overview of the functionality of the final RAT payload.\n\n\n-----\n\n### Decrypting the Configuration\n\nAfter determining that this malware was likely a RAT, we decided to look for indicators of the C2\nserver and any configuration settings that we could use as indicators of compromise. Analyzing\nthe RAT code within Dnspy, we found an ‚ÄúInitializeSettings‚Äù method that was loading config data\nfrom values encrypted with AES256, and then encoding using Base64.\n\nHere‚Äôs the code for decrypting config data within the InitializeSettings method:\n\n\n-----\n\nBelow, we can see the AES256 encrypted and Base64-encoded values being loaded.\n\nAfter playing around with the decryption code, we were able to decrypt the config and pull out\nthe following values‚Äîincluding a port number, mutex name, version and grouping numbers, as\nwell as three domains of C2 servers.\n\n### Machine Enumeration\n\n[Through a combination of queries made to the OS, mostly via WMI queries, the malware](https://docs.microsoft.com/en-us/windows/win32/wmisdk/querying-wmi)\ngathered the following information to send to the C2 server:\n\nCurrently running antiviruses and security products\nUser privileges\nWhether the victim was connected to a domain\nExternal IP of the current machine\nNames of open windows and active processes\n\n\n-----\n\n### Anti-Analysis Checks\n\nAfter enumerating system information, the malware then executed some anti-analysis checks to\nsee if it was running inside of a virtual machine or analysis environment.\n\nThe malware contained several methods and functions for detecting this. These were relatively\nsimple and consisted of five main checks:\n\n**DetectManufacturer: Looks for VMware or VirtualBox in hardware descriptions**\n**DetectDebugger: Checks ‚ÄúDebugger.IsAttached‚Äù flag, also checks for the presence of a**\n**dnspy.xml file in the %appdata% directory**\n**DetectSandboxie: Looks for Sandboxie drivers (sbiedll.dll)**\n**IsSmallDisk: Checks if Disk Size is less than 61GB**\n**IsXP: Checks if the current OS is Windows XP**\n\nIf any of the above checks are true, then the malware cleans up and terminates itself with the\n‚ÄúfailFast‚Äù method.\n\nBelow, we can see the names of the anti-analysis functions being called.\n\nNone of them were particularly interesting or complex, and all followed a similar structure to the\nscreenshot below.\n\n### Final Persistence: Run Keys and Scheduled Tasks\n\nOnce the anti-analysis checks were completed, the malware established further persistence via\nscheduled tasks and run keys, depending on the current privilege level.\n\n\n-----\n\nIf admin privileges were available, then an elevated scheduled task is created. This would allow\nthe malware to persist with admin-level privileges across reboots, without the need for UAC\nprompts each time.\n\nIf only standard user privileges were available, a .bat script would be placed into the current\nuser‚Äôs run key, which would provide persistence with standard user privileges.\n\nUsing these indicators, we were able to find other artifacts left by the malware and develop\ndetections that could be used to alert on similar activity.\n\nYou can check for similar persistence via scheduled tasks and run keys by regularly reviewing\nthe following run key and scheduled task locations:\n\n**HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run**\n**HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run**\n**c:\\windows\\system32\\tasks**\n\n(Alternatively, [sign up for a free trial and we‚Äôll take a look for you!)](https://www.huntress.com/trial)\n\n### C2 Commands and Functionality\n\nOnce persistence had been established, the malware then contacted the command and control\nservers for further commands. These commands could be...\n\n**Update: Download new malware via PowerShell, start it, then kill the current process**\n**SavePlugin: Download and load a remote DLL**\n**Unload: Send a kill command over a named pipe**\n**Restart: Kill the current process and force a restart via a scheduled task**\n**Self-delete: Remove all persistence and kill the current process**\n\nSome short snippets of this functionality are in the screenshots below:\n\n\n-----\n\n### VirusTotal Check of Domains: 0/3\n\nAt the time of initial analysis (May 2021), all of the domains had 0/85 detections on VirusTotal‚Äî\nalthough one of them was marked as suspicious by one vendor.\n\n\n-----\n\n-----\n\n## Recommendations and Final Comments\n\nThat wraps up our analysis of this malware. We hope you enjoyed it as much as we did.\nHopefully, you learned something new and will soon be able to implement some of these\nanalysis techniques for yourself.\n\nAs we saw, even a relatively simple payload (like a RAT) can be implemented in a way that is\nhighly complex and difficult to detect, especially when using customized or unique files and\ndomains that slip past automated security tooling. Although automated tooling has its place, the\ndays are gone where you can rely on such tooling alone.\n\n[You should make sure that proactive and human-driven methods of threat hunting are built into](https://www.huntress.com/blog/what-is-human-powered-threat-hunting)\nyour security stack alongside layered tooling to hinder and decrease the likelihood of a\nsuccessful compromise.\n\nTo wrap things up, we‚Äôd like to make a few recommendations for dealing with this type of\nmalware:\n\n**Avoid relying on static signatures to detect malicious activity. This applies for both**\nnetwork and file-based indicators of compromise. All running executables and domains in\nthis investigation were ‚Äúlegitimate‚Äù and likely would not be blocked on hash alone.\n**Monitor and manually review suspicious files executing from runkeys, scheduled tasks**\nand persistent startup folders.\n**Monitor for process creation events where a Python file is being passed to a non-**\nPython or text editor executable.\n**Inspect any suspicious or non-standard process creation events. Baseline which**\nprocesses are expected to launch msbuild.exe, and alert on anything outside of this\nbaseline.\n\n\n-----\n\n**When analyzing suspicious files and domains, make sure to incorporate manual**\n**analysis and decoding into your process. Avoid relying solely on automated tooling**\nsuch as VirusTotal or online sandboxes.\n\nIndicators of Compromise\n\nDomains:\n\n**windowsupdatecdn[.]cn**\n**gjghvga7ffgb[.]xyz**\n**huugbbvuay4[.]cn**\nHashes:\n\n**ctfmon.exe:**\n**3e442cda613415aedf80b8a1cfa4181bf4b85c548c043b88334e4067dd6600a6**\n**Update.py:**\n**dd1fa3398a9cb727677501fd740d47e03f982621101cc7e6ab8dac457dca9125**\n**stage2:**\n**2CCADFC32DB49E67E80089F30C81F91DFFF4B20B8FC61714DF9E2348542007FD**\n**stage3:**\n**4591EDA045E3587A714BB11062EB258F82EE6F0637E6AA4D90F2D0B447A48EF7**\n**stage4:**\n**4417298524182564AED69261B6C556BDCE1E5B812EDC8A2ADDFC21998447D3C6**\n**stage5:**\n**9B775DFC58B5F82645A3C3165294D51C18F82EC1B19AC8A41BB320BEE92484ED**\n**stage6:**\n**169F5DBCD664C0B4FD65233E553FF605B30E974B6B16C90A1FB03404F1B01980**\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-08-17 - Snakes on a Domain- An Analysis of a Python Malware Loader.pdf"
    ],
    "report_names": [
        "2021-08-17 - Snakes on a Domain- An Analysis of a Python Malware Loader.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536132,
    "ts_updated_at": 1743041151,
    "ts_creation_date": 1653688515,
    "ts_modification_date": 1653688515,
    "files": {
        "pdf": "https://archive.orkl.eu/447820ef3fde47427ecc66084347bc666b4b14b3.pdf",
        "text": "https://archive.orkl.eu/447820ef3fde47427ecc66084347bc666b4b14b3.txt",
        "img": "https://archive.orkl.eu/447820ef3fde47427ecc66084347bc666b4b14b3.jpg"
    }
}