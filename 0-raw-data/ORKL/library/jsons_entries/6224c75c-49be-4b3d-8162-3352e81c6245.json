{
    "id": "6224c75c-49be-4b3d-8162-3352e81c6245",
    "created_at": "2023-01-12T15:07:48.848617Z",
    "updated_at": "2025-03-27T02:06:03.141361Z",
    "deleted_at": null,
    "sha1_hash": "e8f43f1c8f32ff72918e9b1760df7aad65fdb8e8",
    "title": "2020-05-24 - Zloader String Obfuscation",
    "authors": "",
    "file_creation_date": "2022-05-29T01:19:25Z",
    "file_modification_date": "2022-05-29T01:19:25Z",
    "file_size": 131299,
    "plain_text": "# Zloader String Obfuscation\n\n**[blag.nullteilerfrei.de/2020/05/24/zloader-string-obfuscation/](https://blag.nullteilerfrei.de/2020/05/24/zloader-string-obfuscation/)**\n\nborn\n\nThis blag post describes my though-process during identification of the string deobfuscation\n[method in a sample belonging to the Zloader malware family. Specifically, I wanted to identify](https://malpedia.caad.fkie.fraunhofer.de/details/win.zloader)\nthe function or functions responsible for string deobfuscation only using static analysis and\nGhidra, understand the algorithm, emulate it in Java and implement a Ghidra script to\ndeobfuscate all strings in a binary of this family. The target audience of this post are people\nthat have some experience with static reverse engineering and Ghidra but who always asked\nthemselves how the f those reversing wizards identify specific functionality within a binary\nwithout wasting hours, days and weeks. ## Target Sample We will be looking at the sample\nwith SHA256 hash\n```\n4029f9fcba1c53d86f2c59f07d5657930bd5ee64cca4c5929cbd3142484e815a, probably\n\n```\ncreated on 2020-04-08 18:19:58. According to people on the internet, this sample leverages\nstring obfuscation, API hashing, a Domain Generation Algorithm (DGA) and, code-level\nobfuscation techniques like constant unfolding, dead code insertion or arithmetic\nsubstitutions to hinder analysis. Right now, we only care about the string obfuscation and try\nto avoid looking at anything else. The malware family was first mentioned publicly by Fortinet\nin mid 2016: Their blog calls it _DELoader_ based on suspected targeting of Germany which\nin turn is based on geo-information of IPs in log files exposed by the operators in an open\ndirectory (\"DE\" is Germany's country code). The post also draws a connection to a handle\n_Aleksandr_ and usage of the banking Trojan _Zeus_, which seems to motivate the later\nname _Zloader_. ## Identify the Deobfuscation function Following the list of heuristics from a\nprevious blag post, we start at the entry point and while trying to avoid code that's too\ncomplicated, find a function that is called in a lot of other places too and, which adheres to\ncertain requirements on data flowing into and out of it. Without even traversing into any of the\nfunctions called after the entry point, we click every function and list its references (use `X if`\nyou [have the best Ghidra Keybindings available on the free market). Here is a table of called](https://mal.re/tmp/ghIDA.kbxml)\nfunctions together with their number of references (that is, not only calls at the entry point but\nin the whole binary): | Function | Xrefs | |--- |--- | | `FUN_030a3170 | 190 | |` `FUN_030ba440 |`\n55 | | `FUN_030a3340 | 33 | |` `FUN_030ba030 | 30 | |` `FUN_030b8710 | 29 | |`\n```\nFUN_030b1760 | 19 | | FUN_030a3400 | 14 | | FUN_030ba300 | 10 | | FUN_030ba9d0 | 7 |\n\n```\n| ... | ... | The list is sorted by the number of references and we will work our way down from\nthe highest number of cross references (is a handy script to generate such a list of functions\ntogether with their number of cross-references). ## First Things First The first candidate is\n```\nFUN_030a3170 . It seems to receive two arguments, both of which are used in conjunction\n\n```\nwith arithmetic operators like `% and` `< . This makes it plausible that Ghidra correctly`\nguessed their types to be numbers. So if this is indeed a string deobfuscation function, it\nneeds to access some sort of global variable containing the obfuscated variant of the string.\nIn order for this function to be able to deobfuscate more than one string, at least one of the\n\n\n-----\n\ntwo arguments should determine the concrete string within that global variable. But before\nwe dive into that, let us double check that the data types of the arguments are correct by\nlisting a few calls of the function:\n```\npcVar1 = (code *)FUN_030a3170(0,0x6aa0e84);\niVar2 = (*pcVar1)(2,0);\n[...]\npcVar1 = (code *)FUN_030a3170(0,uVar3);\nuVar3 = (*pcVar1)(iVar2,local_23c);\n[...]\npcVar1 = (code *)FUN_030a3170(0,0xfed02a7);\niVar4 = (*pcVar1)(iVar2,local_23c);\n\n```\nSo the first argument seems to be a small number and the second one a large one. What is\nmore interesting though is, that the return value of this function is not used as a string but is\n_called_ directly after. This suggests that the function we are looking at is not responsible for\nstring deobfuscation but merely to resolve some API functions, potentially with the help of\n[API hashing (see a post on API hashing if you want to learn about this technique in general).](https://blag.nullteilerfrei.de/2019/11/09/api-hashing-why-and-how/)\nLet's rename the function to `pr_ResolveApi and not investigate it any further, we are here`\nfor string deobfuscation! ## First Try, Second Attempt `FUN_030ba440 is a very short`\nfunction that just calls `FUN_03091c50 if it didn't receive the` `NULL pointer as an argument.`\nThis function in turn calls two other functions, one of which is our `pr_ResolveApi . The`\nother called function seems to be junk code but overall I'm confident that this aren't the\ndroids, we are looking for. ## Third Time's a Charm Let's take a look at `FUN_030a3340 :`\nGhidra determined that the function receives two pointer arguments. Looking at a few calls to\nthis function, the first argument always seems to be a global variable while the second\nargument is a local array variable. So if this is a string deobfuscation function, the first\nargument could be the obfuscated data while the second is a pointer where the result is\nwritten to. Following data flow within `FUN_030a3340 corroborates the second part of this`\nhypothesis: the content of `param_2 is copied to a local variable which is later returned. If`\nthe hypothesis is correct _and_ the malware sample uses an encryption scheme that needs\na key, `FUN_030a3340 would need to access some global variable to be used as a key -`\nbecause there is no parameter left for the key: according to our hypothesis, the first\nparameter is the obfuscated string while the second is an output parameter. The only global\nvariable (shown in purple in Ghidra) within the function is `PTR_DAT_030be000 . This variable`\nis used in two lines within `FUN_030a3340 :`\n```\nuVar4 = (short)(char)*PTR_DAT_030be000 ^ *param_1;\n[...]\nuVar1 = FUN_030aba90((uint)*(ushort *)((int)param_1 + iVar5), (short)\n(char)PTR_DAT_030be000[uVar6 % 0x11]);\n\n```\nHence this variable probably contains a pointer to an array. This array is indexed with `uVar6`\n```\n% 0x11 suggesting a length of 17:\n00000000 59 49 2c 72 54 66 79 23 46 33 4d 61 71 31 33 69 |YI,rTfy#F3Maq13i|\n00000010 66                        |f|\n\n```\n\n-----\n\nAt this point, instead of reverse engineering the whole function in detail, let s take a leap: In\nthe first of the two code lines above, `PTR_DAT_030be000 is Xor-ed with the first element of`\nthe `param_1 array. Hence it may point to an Xor-key of length 17. Let's look up one of the`\npassed arguments and Xor it with the above key: `puVar1 = FUN_030a3340((ushort`\n```\n*)ARRAY_030bc900,local_52); references ARRAY_030bc900 which contains the\n\n```\nfollowing data:\n```\n00000000 0a 00 26 00 4a 00 06 00 23 00 07 00 0b 00 46 00 |..&.J...#.....F.|\n00000010 1a 00 7e 00 24 00 02 00 03 00 5e 00 40 00 06 00 |..~.$.....^.@...|\n00000020 00 00 2d 00 49 00                 |..-.I.|\n\n```\nsadly, Xoring results in:\n```\n00000000 53 49 0a 72 1e 66 7f 23 65 33 4a 61 7a 31 75 69 |SI.r.f.#e3Jaz1ui|\n00000010 7c 59 37 2c 56 54 64 79 20 46 6d 4d 21 71 37 33 ||Y7,VTdy FmM!q73|\n00000020 69 66 74 49 65 72                 |iftIer|\n\n```\nBut you might have noticed that every second byte in the alleged obfuscated data is a zerobyte. This suggest that the data is in fact a wide string with all upper bytes set to zero. After\nremoving the zero-bytes, Xoring results in the following:\n```\n00000000 53 6f 66 74 77 61 72 65 5c 4d 69 63 72 6f 73 6f |Software\\Microso|\n00000010 66 74 00                     |ft.|\n\n```\nWe have found a string deobfuscation function! And we could also already determine that it\nuses Xor-encryption with a hard-coded key of length 17. Don't forget to rename\n```\nFUN_030a3340 to something like ev_WideStringDeobfuscate . It is also plausible, and\n\n```\ncan be confirmed by reversing `ev_WideStringDeobfuscate a bit more, that the`\nobfuscated data is null-terminated. So instead of passing the length of the obfuscated data\nas an argument, the length is simply determined by the first occurrence of the `\\0 -character.`\n## Due Diligence Now that we know that the global array pointed to by `PTR_DAT_030be000`\ncontains an Xor-Key, let's check for other references. As it turns out, the only other function\nreferencing it, is `FUN_030a3400 . This function is also on our list above (with 14 references)`\nand we just do the same leap of faith, we did above: look up a reference to it and Xor the\ndata passed as the argument\n```\n00000000 32 2c 5e 1c 31 0a 4a 11 68 57 21 0d 71      |2,^.1.J.hW!.q|\n\n```\nwith the hard-coded key:\n```\n00000000 6b 65 72 6e 65 6c 33 32 2e 64 6c 6c 00      |kernel32.dll.|\n\n```\nThere are no zero bytes in the obfuscated data, so maybe this is the non-wide-string variant\nof `ev_WideStringDeobfuscate . So let's rename` `FUN_030a3400 to`\n```\nev_StringDeobfuscate . ## Automation As always, let us automate the process of finding\n\n```\nall function references and deobfuscate the passed buffers. Roughly, we will follow this plan:\n\n- ask the user for name of deobfuscation function and parse its assembly to determine the\n\n\n-----\n\nXor-Key find all calls to the deobfuscation function and determine the first argument passed\nto the function * deobfuscate the data and enrich the different Ghidra views (namely,\nassembly listing, decompiled code and the bookmarks list) Let's first look at the only part that\nwasn't handled in other blag posts: parsing assembly and determining the Xor-Key. Both\ndeobfuscation functions use special `MOV instructions - namely,` `MOVZX (Move with Zero-`\nExtend) and `MOVSX (Move with Sign-Extension) - to read the Xor-Key from memory. Both`\ninstructions accept two operands, a source and a destionation, and copy the contents of the\nsource operand to the destination operand (while extending the value in some way that we\ndon't care about). Below, are the two instructions in question from the\n```\nev_StringDeobfuscate and ev_WideStringDeobfuscate functions respectively:\n030a3435 0F B6 30 ..0 movzx esi, byte ptr [eax]\n[...]\n030a3363 0F BE 19 ... movsx ebx, byte ptr [ecx]\n\n```\nThe first one copies the value referenced by the register `eax to` `esi while the second one`\ndoes the same for `ecx and` `ebx . Since there is only one of those move instruction in both`\nfunctions, our goal is to search for it and try to determine the value that was moved. This\nsituation also already demonstrates that compilers may use different registers in very similar\nsituation. It also means, that we need to do some extra work if we want to automate\ndiscovery of the Xor key: We cannot simply use the value from a fixed register but are merely\ngoing to iterate over all instructions within the function while tracking register values. For\ntracking register values let us use the following simple Java helper class:\n\n\n-----\n\n```\nprivate class InvalidRegisterNameException extends Exception {\n  public InvalidRegisterNameException(String registerName) {\n    super(String.format(\"Invalid register name: %s\", registerName));\n  }\n}\nprivate class RegisterValues {\n  private int[] values;\n  public boolean debug;\n  public RegisterValues() {\n    values = new int[8];\n    debug = false;\n  }\n  private int nameToIndex(String registerName) throws InvalidRegisterNameException\n{\n    if (registerName.equals(\"EAX\") || registerName.equals(\"AL\") ||\nregisterName.equals(\"AH\")) {\n      return 0;\n    } else if (registerName.equals(\"EBX\") || registerName.equals(\"BL\") ||\nregisterName.equals(\"BH\")) {\n      return 1;\n    } else if (registerName.equals(\"ECX\") || registerName.equals(\"CL\") ||\nregisterName.equals(\"CH\")) {\n      return 2;\n    } else if (registerName.equals(\"EDX\") || registerName.equals(\"DL\") ||\nregisterName.equals(\"DH\")) {\n      return 3;\n    } else if (registerName.equals(\"EBP\") || registerName.equals(\"BL\") ||\nregisterName.equals(\"BH\")) {\n      return 4;\n    } else if (registerName.equals(\"ESI\")) {\n      return 5;\n    } else if (registerName.equals(\"EDI\")) {\n      return 6;\n    } else if (registerName.equals(\"ESP\")) {\n      return 7;\n    } else {\n      throw new InvalidRegisterNameException(registerName);\n    }\n  }\n  public void set(String registerName, int value, Address address) throws\nInvalidRegisterNameException {\n    if (debug) {\n      println(String.format(\"0x%x writing 0x%x to %s\", address.getOffset(),\nvalue, registerName));\n    }\n    values[nameToIndex(registerName)] = value;\n  }\n  public int get(String registerName, Address address) throws\nInvalidRegisterNameException {\n    int registerValue = values[nameToIndex(registerName)];\n\n```\n\n-----\n\n```\n    if (debug) {\n      println(String.format(\"0x%x reading %s as 0x%x\", address.getOffset(),\nregisterName, registerValue));\n    }\n    return registerValue;\n  }\n}\n\n```\nAnd now, we can use this class to implement the actual algorithm to search for the Xor-Key:\n\n\n-----\n\n```\npublic byte[] readXorKey(Function func, int searchDepth) throws MemoryAccessException\n{\n  int i = 0;\n  RegisterValues currentValues = new RegisterValues();\n  for (Instruction instruction :\ncurrentProgram.getListing().getInstructions(func.getEntryPoint(), true)) {\n    try {\n      if (instruction.getMnemonicString().equals(\"MOVZX\")) {\n        // MOVSX EBX,byte ptr [ECX]=>BYTE_ARRAY_030bc4f0 =\n        // Index 0: EBX\n        // Index 1: ECX\n        String registerName = instruction.getOpObjects(1)[0].toString();\n        int registerValue = currentValues.get(registerName,\ninstruction.getAddress());\n        byte[] dataPtr = getOriginalBytes(toAddr(registerValue), 0x4);\n        if (dataPtr != null) {\n          byte[] data = getOriginalBytes(unpackAddressLE(dataPtr), 0x11);\n          if (data != null && data.length == 0x11) {\n            return data;\n          }\n        }\n      } else if (instruction.getMnemonicString().equals(\"MOV\")) {\n        // MOV ECX,dword ptr [030be000 == OBFU_PTR]\n        // Index 0: ECX\n        // Index 1: 030be000\n        String registerName = instruction.getOpObjects(0)[0].toString();\n        int copiedValue = instruction.getInt(1);\n        currentValues.set(registerName, copiedValue,\ninstruction.getAddress());\n      } else if (instruction.getMnemonicString().equals(\"RET\")) {\n        break;\n      }\n    } catch (InvalidRegisterNameException e) {\n      println(String.format(\"Exception: %s\", e.toString()));\n    }\n    i++;\n    if (i > searchDepth)\n      break;\n  }\n  byte[] defaultKey = { 0x59, 0x49, 0x2c, 0x72, 0x54, 0x66, 0x79, 0x23, 0x46, 0x33,\n0x4d, 0x61, 0x71, 0x31, 0x33,\n      0x69, 0x66 };\n  return defaultKey;\n}\n\n```\nThe function just returns a default key if identifying the value is not successful. Asking the\nuser for a function, [finding all references as well as tracking argument values of those calls](https://blag.nullteilerfrei.de/2020/02/02/defeating-sodinokibi-revil-string-obfuscation-in-ghidra/)\nhas been covered thoroughly in previous blag posts. So the only thing left is the obfuscation\nitself, which is a simple Xor with a multi-byte key:\n\n\n-----\n\n```\nprivate byte[] cryptXor(byte[] data, byte[] key) {\n  final byte[] ret = new byte[data.length];\n  for (int k = 0; k < data.length; k++)\n    ret[k] = (byte) (data[k] ^ key[k % key.length]);\n  return ret;\n}\n\n```\nAs always, you can find the fully working script to deobfuscate all strings in Zloader on\ngithub. ## Summary The string obfuscation used in Zloader is quite generic: the analysed\nsample contains two different functions that use the same global hard-coded Xor-key to\ndecrypt zero-terminated obfuscated data. It was possible to identify these functions without\nactual reverse engineering a lot of code in detail by starting at the entry point and looking at\nall calls sorted by number of other references of the called function. ## Deobfuscated\nStrings: For google-ability: | Address | Deobfuscated String |--- |--- | `0x0309111C |`\n```\nkernel32.dll | 0x0309133F | Software\\Microsoft (wide) | 0x03091AFF |\nSoftware\\Microsoft (wide) | 0x03091CE0 | BOT-INFO | 0x03091CF3 | It's a debug\nversion. | 0x03091D0F | Proxifier.exe (wide) | 0x03091D4A | BOT-INFO |\n0x03091D60 | Proxifier is a conflict program, form-grabber and web-injects\nwill not works. Terminate proxifier for solve this problem. | 0x0309218F |\nSeSecurityPrivilege (wide) | 0x030923E5 | Mozilla/5.0 (Windows NT 6.3;\nWin64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88\nSafari/537.36 | 0x030928F9 | Software\\Microsoft (wide) | 0x0309559F |\n/post.php | 0x030955F4 | https:// | 0x03095D99 | C:\\Windows\\SystemApps\\*\n\n```\n(wide) | `0x03095E1D |` `Microsoft.MicrosoftEdge (wide) |` `0x03095E57 |` `6.3 |`\n```\n0x030962E4 | HideClass (wide) | 0x03096332 | HideWindow (wide) | 0x03096348 |\nHideClass (wide) | 0x03096E37 | .exe (wide) | 0x03096E5B | .dll (wide) |\n0x03096E7A | .dll (wide) | 0x03096EAB | .exe (wide) | 0x03096F5F | .exe |\n0x03096FC8 | >> (wide) | 0x03097022 | .dll | 0x030972E1 |\nSoftware\\Microsoft\\ (wide) | 0x0309741D | UNKNOWN (wide) | 0x03097492 |\nSoftware\\Microsoft\\Windows NT\\CurrentVersion (wide) | 0x030974A5 |\nInstallDate (wide) | 0x030974CB | DigitalProductId (wide) | 0x030974F1 |\n%s_%08X%08X (wide) | 0x0309754F | INVALID_BOT_ID (wide) | 0x03097790 |\nrundll32.exe %s,DllRegisterServer (wide) | 0x030977C5 |\nSoftware\\Microsoft\\Windows\\CurrentVersion\\Run (wide) | 0x030977F9 |\nSoftware\\Microsoft\\Windows\\CurrentVersion\\Run (wide) | 0x03097CF2 |\nSoftware\\Microsoft\\ (wide) | 0x03098065 |\nSoftware\\Microsoft\\Windows\\CurrentVersion\\Run (wide) | 0x0309809E | .dll\n\n```\n(wide) | `0x03098174 |` `S:(ML;;NRNWNX;;;LW) (wide) |` `0x030986F1 |`\n```\nSoftware\\Microsoft\\ (wide) | 0x0309BD3F | .com\n\n```\nTags: [ghidra -](https://blag.nullteilerfrei.de/tag/ghidra/) [malware -](https://blag.nullteilerfrei.de/tag/malware/) [string-deobfuscation -](https://blag.nullteilerfrei.de/tag/string-deobfuscation/) [zloader](https://blag.nullteilerfrei.de/tag/zloader/)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-05-24 - Zloader String Obfuscation.pdf"
    ],
    "report_names": [
        "2020-05-24 - Zloader String Obfuscation.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536068,
    "ts_updated_at": 1743041163,
    "ts_creation_date": 1653787165,
    "ts_modification_date": 1653787165,
    "files": {
        "pdf": "https://archive.orkl.eu/e8f43f1c8f32ff72918e9b1760df7aad65fdb8e8.pdf",
        "text": "https://archive.orkl.eu/e8f43f1c8f32ff72918e9b1760df7aad65fdb8e8.txt",
        "img": "https://archive.orkl.eu/e8f43f1c8f32ff72918e9b1760df7aad65fdb8e8.jpg"
    }
}