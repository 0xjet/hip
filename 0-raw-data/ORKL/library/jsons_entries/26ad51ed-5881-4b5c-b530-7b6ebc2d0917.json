{
    "id": "26ad51ed-5881-4b5c-b530-7b6ebc2d0917",
    "created_at": "2023-03-03T02:06:44.235018Z",
    "updated_at": "2025-03-27T02:09:30.437131Z",
    "deleted_at": null,
    "sha1_hash": "b327a34b65ae860836b594f616c473d0e25e0fc8",
    "title": "2023-02-14 - Writing a decryptor for Jaff ransomware",
    "authors": "",
    "file_creation_date": "2023-03-01T09:33:35Z",
    "file_modification_date": "2023-03-01T09:33:35Z",
    "file_size": 554420,
    "plain_text": "# Writing a decryptor for Jaff ransomware\n\n**clairelevin.github.io/malware/2023/02/14/jaff.html**\n\n## Overview\n\n\nFebruary 14, 2023\n\n\nRecently, I’ve been trying to learn more about reverse engineering ransomware. Jaff is\nransomware from a campaign dating back to 2017, and I was told that it had a vulnerability\nthat would make it possible to write a decryptor. I analyzed a sample to see if I could\nrediscover the vulnerability myself.\n\n[You can find the sample I used on MalShare, and its SHA256 hash is](https://malshare.com/sample.php?action=detail&hash=0746594fc3e49975d3d94bac8e80c0cdaa96d90ede3b271e6f372f55b20bac2f)\n```\n0746594fc3e49975d3d94bac8e80c0cdaa96d90ede3b271e6f372f55b20bac2f.\n\n## Initial Observations\n\n```\nThe sample is a 32-bit PE excutable written in C++. The executable did not seem to import\nany functions related to cryptography, and it contained a very long chunk of encrypted data.\nThis meant that the most important functions of this program were likely being decrypted\ndynamically.\n\n\n-----\n\nBy setting breakpoints on VirtualAlloc and VirtualProtect, I kept track of each time a\nRWX segment of memory was allocated. After several calls to VirtualAlloc and\n```\nVirtualProtect, the program wrote a PE file to one of these segments, which I dumped\n\n```\nfrom memory. This turned out to be the actual encryptor, and it’s what I’ll be focusing on for\nthe remainder of my analysis.\n\n### Behaviors\n\nWhen run, the sample calls itself Ffv opg me liysj sfssezhz:\n\nAdditionally, a GET request is made to fkksjobnn43[.]org/a5/. As I don’t have access to\nthis C2 server, I have no way of knowing what was expected from this server or whether the\nencryption process would have proceeded differently if I’d been able to connect.\n\n### Strings, Imports, and Resources\n\n\n-----\n\nThe binary I dumped from memory imports cryptography-related functions such as\n```\nCryptEncrypt, CryptExportKey, and CryptGenKey, as well as file enumeration functions\n\n```\nsuch as FindFirstFileW and FindNextFileW. This is how I knew I was looking at the actual\nencryptor.\n\nAdditionally, there were several resources containing data used in the encryption process:\n```\n   #105: The string representation of the numbers\n   3532605403186136813956330618413416701813071856948273166600165081753910874\n   4401016633231304437224730790638615766740272106403143256 and\n   3532605403186136813956330618413416701813071856948273166600165082986456837\n   1094444203557601170206844003631101722202233367975968667.\n   #106: The file extensions to encrypt:\n   .xlsx .acd .pdf .pfx .crt .der .cad .dwg .MPEG .rar .veg .zip .txt .jpg .doc\n   .wbk .mdb .vcf .docx .ics .vsc .mdf .dsr .mdi .msg .xls .ppt .pps .obd .mpd .dot\n   .xlt .pot .obt .htm .html .mix .pub .vsd .png .ico .rtf .odt .3dm .3ds .dxf .max\n   .obj .7z .cbr .deb .gz .rpm .sitx .tar .tar.gz .zipx .aif .iff .m3u .m4a .mid\n   .key .vib .stl .psd .ova .xmod .wda .prn .zpf .swm .xml .xlsm .par .tib .waw\n   .001 .002 003. .004 .005 .006 .007 .008 .009 .010 .contact .dbx .jnt .mapimail\n   .oab .ods .ppsm .pptm .prf .pst .wab .1cd .3g2 .7ZIP .accdb .aoi .asf .asp. aspx\n   .asx .avi .bak .cer .cfg .class .config .css .csv .db .dds .fif .flv .idx .js\n   .kwm .laccdb .idf .lit .mbx .md .mlb .mov .mp3 .mp4 .mpg .pages .php .pwm .rm\n   .safe .sav .save .sql .srt .swf .thm .vob .wav .wma .wmv .xlsb .aac .ai .arw .c\n   .cdr .cls .cpi .cpp .cs .db3 .docm .dotm .dotx .drw .dxb .eps .fla .flac .fxg\n   .java .m .m4v .pcd .pct .pl .potm .potx .ppam .ppsx .ps .pspimage .r3d .rw2\n   .sldm .sldx .svg .tga .wps .xla .xlam .xlm .xltm .xltx .xlw .act .adp .al .bkp\n   .blend .cdf .cdx .cgm .cr2 .dac .dbf .dcr .ddd .design .dtd .fdb .fff .fpx .h\n   .iif .indd .jpeg .mos .nd .nsd .nsf .nsg .nsh .odc .odp .oil .pas .pat .pef .ptx\n   .qbb .qbm .sas7bdat .say .st4 .st6 .stc .sxc .sxw .tlg .wad .xlk .aiff .bin .bmp\n   .cmt .dat .dit .edb .flvv .gif .groups .hdd .hpp .log .m2ts .m4p .mkv .ndf\n   .nvram .ogg .ost .pab .pdb .pif .qed .qcow .qcow2 .rvt .st7 .stm .vbox .vdi .vhd\n   .vhdx .vmdk .vmsd .vmx .vmxf .3fr .3pr .ab4 .accde .accdt .ach .acr .adb .srw\n   .st5 .st8 .std .sti .stw .stx .sxd .sxg .sxi .sxm .tex .wallet .wb2 .wpd .x11\n   .x3f .xis .ycbcra .qbw .qbx .qby .raf .rat .raw .rdb rwl .rwz .s3db .sd0 .sda\n   .sdf .sqlite .sqlite3 .sqlitedb .sr .srf .oth .otp .ots .ott .p12 .p7b .p7c .pdd\n   .pem .plus_muhd .plc .pptx .psafe3 .py .qba .qbr.myd .ndd .nef .nk .nop .nrw\n\n   #109: The ransom note in HTML form, with the string [ID5] in place of the victim’s\n\n```\ndecryption ID.\n```\n   #110: The string .jaff, which is the extension appended to encrypted files.\n   #111: The URL fkksjobnn43[.]org/a5/.\n   #112: The ransom note in text form, again with [ID5] in place of the ID.\n\n```\n\n-----\n\n```\n   #113: A string of bytes which, when XORed with the second number in #106, gives the\n\n```\nstrings ReadMe.txt, ReadMe.bmp, and ReadMe.html.\n\nAdditionally, the string cmd /C del /Q /F %s found in the program suggests that it is\nintended to delete itself once encryption is complete.\n\n## The Encryption Process\n\nThe sample uses 256-bit AES to encrypt files. For debugging purposes, I set a breakpoint on\n```\nCryptImportKey to read the key blob from memory:\n\n```\nA new key is generated using CryptGenKey each time the program is run.\n\nBeginning with the root directory, the program enumerates all files and subdirectories and\nuses CryptEncrypt to AES encrypt each file. The program uses GetLogicalDrives to find\nall drives connected to the system, and encrypts all drives that are not CD-ROM drives\n(possibly because a CD-ROM drive would make a noticeable noise as it started up).\n\nThe .jaff extension is appended to the encrypted file, and the AES-encrypted bytes are\nwritten. We can see that there are multiple WriteFile calls to the encrypted file, revealing\nthat something else is appended to the .jaff file before the encrypted data:\n\nThe appended value turned out to be the ASCII representation of a large number.\n\n\n-----\n\nAdditionally, the ransom note is dropped in each encrypted directory. The note is dropped in\ntext, HTML, and image forms, with file names of ReadMe.txt, ReadMe.html, and ReadMe.bmp\nrespectively.\n\n\n-----\n\nA new victim ID is generated each time the program is run.\n\n## Encryption of the AES Key\n\nI suspected that the long number appended before the encrypted data in the .jaff files was\nlikely an encryption of the AES key. A new AES key was generated for each victim, so the\nprogram would need some way to store it.\n\n### Representing The Key Bytes\n\nI found that the AES key was being passed as an argument to sub_402d70. When passed\ninto this function, the AES key blob was being stored as a decimal representation in littleendian format, with each decimal digit being stored as a 16-bit integer. Each byte of the key\nblob was converted to three decimal digits; for instance, 08 would be stored as 008 and 8A\nwould be stored as 138. Additionally, the digit “1” was appended to the sequence:\n\nFor example, during one run of the program, the original AES key blob was the following:\n```\n08 02 00 00 10 66 00 00 20 00 00 00 52 8A A4 D0 46 E3 4F FE E8 C6 A0 F5 91 0C 25 81\n03 0E 5C 3C 57 F6 A0 43 08 32 C9 83 2C 01 FC 95\n\n\n```\nIt was stored as the sequence of bytes\n```\n04 00 04 00 00 00 01 00 03 00 01 00 01 00 00 00 02 00 00 00 05 00 00 00 08 00 00 00\n00 00 07 00 06 00 00 00 00 00 06 00 01 00 06 00 04 00 02 00 07 00 08 00 00 00 00 00\n06 00 00 00 02 00 09 00 00 00 04 00 01 00 00 00 03 00 00 00 00 00 09 00 02 00 01 00\n07 00 03 00 00 00 02 00 01 00 00 00 05 00 04 00 01 00 05 00 04 00 02 00 00 00 06 00\n01 00 08 00 09 00 01 00 02 00 03 00 02 00 04 00 05 00 02 00 09 00 07 00 00 00 07 00\n02 00 02 00 00 00 07 00 00 00 08 00 00 00 02 00 04 00 06 00 01 00 08 00 03 00 01 00\n02 00 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 00 03 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 00 00 00 01 00 06 00 01 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 02 00 00 00 00 00 08 00 00 00 00 00 01\n\n\n```\nwhich corresponds to the number\n```\n1008002000000016102000000032000000000082138164208070227079254232198160245145012037129\n003014092060087246160067008050201131044\n\n```\n\n-----\n\nTo convert this representation back into bytes, I used the following function:\n```\ndef convert_from_decimal(s):\n\n     result = b''\n\n     s_fixed = s[1:]\n\n     for i in range(0, len(s_fixed),3):\n\n          curr_num = s_fixed[i:i+3]\n\n          result += int(curr_num).to_bytes(1, 'little')\n\n     return result\n\n\n### Encrypting The Key\n\n```\nAt this point, it was time to look at what sub_402d70 was actually doing. The arguments to\nthe function were the AES key, an array of bytes that were either 1 or 0, and the decimal\nrepresentation of the number\n```\n353260540318613681395633061841341670181307185694827316660016508298645683710944\n44203557601170206844003631101722202233367975968667. Note that this is one of the two\n\n```\nnumbers that appeared in resource #105.\n\nBy experimenting with this subrouting in a debugger, I found that the program was calling\nfunctions that performed multiplication and division on arbitrarily large numbers. Sepecifically,\nthe AES key was being squared over and over, and something different was done with the\nresult based on the values in the array of 1s and 0s.\n\n\n-----\n\nThis proved to be the repeated-squaring method for modular exponentiation. The AES key\nwas being raised to an exponent, which was passed as an argument in binary form in order\nto aid in the repeated-squaring algorithm. The modulus was the long number stored in the\nresource.\n\nThe use of modular exponentiation immediately suggested that RSA was being used.\nNormally, this would mean we wouldn’t be able to decrypt the AES key, as we need the\nprivate key for that.\n\nHowever, resource #105 contains two numbers, and we’ve only used one so far. One of them\nis the public modulus n, and the other number is very close to it. It seemed possible that the\nsecond number was phi(n), which is needed to compute the private exponent d from the\npublic exponent e. I wrote the following script to test it:\n```\ndef rsa_decrypt(msg, e, n, phi_n):\n\n     d = pow(e, -1, phi_n)\n\n     return pow(msg, d, n)\n\n\n```\nSure enough, passing in the second number as phi(n) returned the decrypted AES key!\nSince the RSA key was hard-coded, this meant that we had enough information to write a\ndecryptor for any files encrypted with this sample, even if the AES key changed each time.\n\n## The Public Exponent\n\nTo generate the private exponent for the decryptor, I not only needed phi(n), but also the\npublic exponent. However, the program generated a new public exponent each time it was\nrun.\n\nUpon closer inspection, I found that the public exponent was usually close to the victim ID\ngiven in the ransom note. Sometimes they matched exactly, but sometimes the exponent\nwas slightly more than the ID, and occasionally they didn’t seem to match at all.\n\nEventually, I found that the victim ID seemed to be randomly generated. If a negative number\nwas generated, the bits were negated in order to produce a positive result.\n\nAfter correcting for this, I found that either the victim ID or its negation was always close to\nthe exponent, but there didn’t seem to be much of a pattern to the exact difference.\n\n\n-----\n\nIt turned out that the victim ID sometimes needed to be modified before it could work as a\npublic exponent. In RSA, the public exponent needs to be invertible modulo phi(n), meaning\nthat the exponent and phi(n) need to be relatively prime. However, the process that\ngenerated the victim IDs did not guarantee a result that was relatvely prime to phi(n).\n\n(This is just speculation, but my guess is that this is why phi(n) was hard-coded in the\nexecutable - they needed to guarantee that they had a valid public exponent, so they had to\ncheck whether the ID and phi(n) were relatively prime. However, this also gives us enough\ninformation to decrypt the files ourselves!)\n\nBy incrementing the victim ID until I got a number that was relatively prime to phi(n), I\nmanaged to retrieve the public exponent.\n```\ndef get_relatively_prime(e, phi_n):\n\n     while(math.gcd(e, phi_n) != 1):\n\n          e += 2\n\n     return e\n\n\n## Putting It All Together\n\n```\nWe now have enough information to write a decryptor that decrypts the victim’s files using\nonly the encrypted .jaff file and the ID number in the ransom note.\n\n\n-----\n\n```\nimport binascii\n\nimport math\n\nfrom Crypto.Cipher import AES\n\nfrom struct import pack, unpack\n\nphi_n =\n3532605403186136813956330618413416701813071856948273166600165081753910874440101663323\n1304437224730790638615766740272106403143256\n\nn =\n3532605403186136813956330618413416701813071856948273166600165082986456837109444420355\n7601170206844003631101722202233367975968667\n\ndef convert_from_decimal(s):\n\n     result = b''\n\n     s_fixed = s[1:]\n\n     for i in range(0, len(s_fixed),3):\n\n          curr_num = s_fixed[i:i+3]\n\n          result += int(curr_num).to_bytes(1, 'little')\n\n     return result\n\ndef rsa_decrypt(msg, e, n, phi_n):\n\n     d = pow(e, -1, phi_n)\n\n     return pow(msg, d, n)\n\ndef get_relatively_prime(e, phi_n):\n\n     while(math.gcd(e, phi_n) != 1):\n\n          e += 2\n\n     return e\n\ndef aes_decrypt(ciphertext, blob):\n\n     iv = b'\\x00'*16\n\n     key_bytes = blob[12:]\n\n     key = AES.new(key_bytes, AES.MODE_CBC, iv)\n\n     padded_text = ciphertext + b'\\x00'*(16 - len(ciphertext)%16)\n\n     return key.decrypt(padded_text)\n\ndef decrypt(filename, id):\n\n     #parse the encrypted AES key and data from the file\n\n     enc_file = open(filename, 'rb').read()\n\n     num_size = unpack('<I', enc_file[0:4])[0]\n\n     key_str = enc_file[4:num_size+4]\n\n     ciphertext = enc_file[num_size+8:]\n\n     keys = [int(i) for i in key_str.split()]\n\n     aes_key = []\n\n     #test both the victim ID and its negation for a valid public exponent\n\n```\n\n-----\n\n```\nexp1 = get_relatively_prime(id | 1, phi_n)\n\nfor k in keys: aes_key.append(rsa_decrypt(k, exp1, n, phi_n))\n\nif(str(aes_key[0]))[0:6] != '100800':\n\n     aes_key = []\n\n     not_id = ~id & 0xffffffff\n\n     exp2 = get_relatively_prime(not_id | 1, phi_n)\n\n     for k in keys: aes_key.append(rsa_decrypt(k, exp2, n, phi_n))\n\n#decode the key blob from its decimal representation\n\naes_key_bytes = b''\n\nfor k in aes_key: aes_key_bytes += convert_from_decimal(str(k))\n\nreturn aes_decrypt(ciphertext, aes_key_bytes)\n\n```\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2023/2023-02-14 - Writing a decryptor for Jaff ransomware.pdf"
    ],
    "report_names": [
        "2023-02-14 - Writing a decryptor for Jaff ransomware.pdf"
    ],
    "threat_actors": [
        {
            "id": "aa73cd6a-868c-4ae4-a5b2-7cb2c5ad1e9d",
            "created_at": "2022-10-25T16:07:24.139848Z",
            "updated_at": "2025-03-27T02:02:10.120505Z",
            "deleted_at": null,
            "main_name": "Safe",
            "aliases": [],
            "source_name": "ETDA:Safe",
            "tools": [
                "DebugView",
                "LZ77",
                "OpenDoc",
                "SafeDisk",
                "TypeConfig",
                "UPXShell",
                "UsbDoc",
                "UsbExe"
            ],
            "source_id": "ETDA",
            "reports": null
        }
    ],
    "ts_created_at": 1677809204,
    "ts_updated_at": 1743041370,
    "ts_creation_date": 1677663215,
    "ts_modification_date": 1677663215,
    "files": {
        "pdf": "https://archive.orkl.eu/b327a34b65ae860836b594f616c473d0e25e0fc8.pdf",
        "text": "https://archive.orkl.eu/b327a34b65ae860836b594f616c473d0e25e0fc8.txt",
        "img": "https://archive.orkl.eu/b327a34b65ae860836b594f616c473d0e25e0fc8.jpg"
    }
}