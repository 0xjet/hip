{
    "id": "f201658c-bca5-4b83-a5f8-db08181e4d73",
    "created_at": "2023-01-12T15:10:51.3745Z",
    "updated_at": "2025-03-27T02:05:39.215108Z",
    "deleted_at": null,
    "sha1_hash": "7b956dddd23502aa43dd3d272aabb75b00f6fd37",
    "title": "2021-03-29 - Zloader email campaign using MHTML to download and decrypt XLS",
    "authors": "",
    "file_creation_date": "2022-05-28T04:53:11Z",
    "file_modification_date": "2022-05-28T04:53:11Z",
    "file_size": 2194893,
    "plain_text": "# Zloader email campaign using MHTML to download and decrypt XLS\n\n**[hornetsecurity.com/en/threat-research/zloader-email-campaign-using-mhtml-to-download-and-decrypt-xls/](https://www.hornetsecurity.com/en/threat-research/zloader-email-campaign-using-mhtml-to-download-and-decrypt-xls/)**\n\nSecurity Lab March 29, 2021\n\n## Summary\n\nZloader1 malware (associated with the `kev configuration tag) is spreading via malspam`\nusing MIME encapsulation of aggregate HTML documents (MHTML)5 attachments. These\nMHTML files contain a Word document with VBA macros. The VBA macro code downloads\nand decrypts a password-protected XLS file, and after that, the XLS file decodes and\nexecutes the Zloader malware embedded within it.\n\n\n## Background\n\nIn February 2020, campaigns distributing Zloader ramped up usage of XLM (also known as\nExcel 4.0) macros. Detection of this old spreadsheet-based by design self-modifiable macro\ncode format by anti-virus software is far lower than detection of regular sequential not by\ndesign self-modifiable plain-text VBA macro source code. We already highlighted the abuse\n[of XLM macros in previous reports, e.g., XLM macros used to spread QakBot 2](https://www.hornetsecurity.com/en/threat-research/qakbot-distributed-by-xlsb-files/) or\n[BazarLoader .3](https://www.hornetsecurity.com/en/threat-research/bazarloaders-elaborate-flower-shop-lure/) However, as detection for XLM macro code has picked up with even Microsoft\nadding XLM macro support to AMSI,4 threat actors continue to evolve.\n\n\nStarting in January 2021, Hornetsecurity took notice of a new Zloader campaign using\nMHTML attachments. MIME encapsulation of aggregate HTML documents (MHTML)5 is a\nweb page archive format used to combine multiple files into one. It used base64 encoding\nand MIME-boundaries similar to multipart MIME encoding in emails. Microsoft Word can\nopen documents stored inside MHTML files.\n\n## Technical Analysis\n\nThe chain of infection of the Zloader MHTML campaign is as follows:\n\n\n-----\n\nWe will now outline each step of the attack chain.\n\n### Emails\n\nThe attack starts with emails.\n\n**Januar (first wave)**\n\nThe first emails were designed and built like purchase invoices.\n\n\n-----\n\nThe wording and pretext changed between emails of this campaign. However, the general\n“invoicing” theme remained constant.\n\nInitial email attacks were of low volume, the emails templates above have not been used\nmuch.\n\n**February**\n\nIn February, contract pretexts were added to the mix of invoice pretexts.\n\n\n-----\n\nAt one point, the numero sign ( № ) was used instead of the number sign ( # ).\n\nAfter that, with recent changes to the email template, the campaign’s volume started to\nincrease sharply.\n\n### Targets\n\nThe campaign targets international, Canadian, US, and British companies, mainly Englishspeaking users.\n\n\n-----\n\nHowever, the time histogram shows that on 2021-02-15, the majority of Zloader MHTML\nemails were destined for Canadian recipients.\n\n\n-----\n\nThe estimated distribution of recipients by industries would suggest a bias towards the\nprofessional services industry, i.e., consultancies, freelancers, funeral homes, law firms, etc.\n\n\n-----\n\n### MHTML documents\n\nThe MHTML document’s extension was set to .doc, so Microsoft Word will open the\ndocuments directly.\n\nThe smaller January campaign and later February campaign MHTML document’s main\ndifference is the image instructing the user to “enable content” and “enable editing”, i.e.,\nactivating macro execution.\n\nThe January campaign lure image looks as follows:\n\n\n-----\n\nThe February campaign lure image looks as follows:\n\n\n-----\n\nThe MHTML document is an ASCII document featuring multiple MIME-parts.\n\nOne MIME-part contains the lure image.\n\n\n-----\n\nThe other parts contain an `application/vnd.ms-officetheme and an` `application/x-`\n```\nmso file. Which (in addition to the text/xml files) are used by Microsoft Word to load the\n\n```\nembedded Word document.\n\nThe document will automatically execute the macro code on closing the document:\n\nThe VBA code uses `UserForm objects for obfuscation.`\n\n\n-----\n\nWithin the `ComboBox objects’ initialization code in the` `UserForm objects and various other`\nmechanisms, a download URL and a password are assembled and used within a call to the\nVBA function `CallByName . This calls the` `Workbook object’s` `open function with the`\n```\nfileName parameter set to the download URL, the Password parameter set to the\n\n```\nassembled password, and the other optional parameters left empty.\n\n\n-----\n\nThe call will cause Word to open Excel and download the encrypted XLS file from the URL\n```\nhttps://findinglala[.]com/down/doc.xls?ekyh_vD91041.z4730435.doc . Excel will\n\n```\nuse the provided password to decrypt the document.\n\nThe XLS document will use XLM macros to decode and use `rundll32.exe to execute an`\nembedded Zloader payload.\n\n### Zloader\n\nZloader is a fork of the famous Zeus banking Trojan. It is a loader that allows its operator to\nload additional malware onto infected devices.\n\n**Coarse dynamic analysis**\n\nThe via `rundll32.exe started Zloader process from the XLS document will spawn a`\nsuspended `msiexec.exe process and inject code into it.`\n\nFirst, the original DLL running in `rundll32.exe starts a` `msiexec.exe process.`\n\nThen, `WriteProcessMemory is used to write code into it.`\n\n\n-----\n\nEventually, the Zloader code running in `rundll32.exe resumes the thread in the`\n```\nmsiexec.exe process via NtResumeThread and the injected code starts running.\n\n```\nZloader will then generate a lot of random directories in `%APPDATA%\\Roaming .`\n\n\n-----\n\nIt then copies the original DLL into one of the folders. To this end, it first reads the original\nDLL into memory.\n\nIn the next step, data from the DLL is being written back into a new file.\n\nThe other folders remain empty but can be used at later points in time to hold additional data.\n\n\n-----\n\nThe original DLL is deleted.\n\nEventually, C2 communication initializes.\n\n\n-----\n\n**Unpacking**\n\nThe Zloader DLL injected into `msiexec.exe can be extracted either automatically via the`\nopen-source CAPE sandbox, manually dumped by breaking on `NtResumeThread in the`\noriginal `rundll32.exe process, then dumping the` `msiexec.exe process, or semi-`\nautomatically by using a tool such as `hollows_hunter` 5 (or PE-Sieve).\n\nThe following analysis was performed on a Zloader DLL dumped from the `msiexec.exe`\nprocess.\n\n**Obfuscation**\n\nThe Zloader malware is obfuscated. It makes extensive use of junk code, i.e., adding\nprogram instructions that do not contribute to the program logic with the sole purpose of\ncomplicating analysis. Further, it often calls complicated functions to perform trivial\ncalculations, making the code appear very complex. For example, the following is a function\nthat performs the binary AND operation on two parameters. The code is littered with such\njunk code.\n\n\n-----\n\n**Dynamic library, function and string resolution**\n\nFunctions are dynamically resolved at runtime via a hash lookup. Instead of calling a function\ndirectly, a proxy function returning a pointer to the desired function is called. The following\nexample shows the function with which Zloader deletes its original file. The function we\nnamed `zl_get_func received two parameters, the first is a library ID ( 0 is ntdll) and the`\nsecond is a hash of the function name that should be called.\n\n\n-----\n\nThis is standard practice in modern malware, so no suspicious imports are present in the\nbinary. It also makes a static analysis more complicated.\n\nObviously, the hash calculation also uses the previous mentioned junk code obfuscation.\n\n\n-----\n\nHowever, it can be reimplemented in Python as follows.\n```\ndef zl_hash(func_name):\n  func_name = func_name.lower()\n  hash = 0\n  for c in func_name:\n    a = 0 - (hash << 4)\n    hash = 0 - (a - ord(c))\n    b = 0x647400ac ^ 0x947400ac\n    b = hash & (~(b ^ hash))\n    if b != 0:\n      d = 0x647400ac ^ 0x6b8bff53\n      hash = (b >> 0x18) ^ (d & hash)\n  return hash\n\n```\nWith this function calls can be de-obfuscated.\n\nStrings are XOR encoded with a static repeating ASCII keystream.\n\n\n-----\n\n**Configuration**\n\nThe Zloader configuration is RC4 encrypted with a key using only ASCII as keyspace.\n\nThe data at the location we labeled `zl_encrypted_config can be decoded with the ASCII`\nstring handed as the second parameter to the function we named `zl_decrypt_config .`\nConsequently, the configuration of the Zloader sample will be revealed.\n\n\n-----\n\nThe configuration contains a botnet name the particular sample is associated with, a\ncampaign ID (presumably for the threat actors to keep track of infections per campaign), an\nRC4 key (used to encrypt and decrypt updated configuration stored in the registry) and last\nbut not least a list of command and control URLs the malware should connect to for\ncommands and updates.\n\nWe provide an update to the DC3-MWCP script included with the open-source CAPE\nsandbox that handles configuration extraction for the analyzed Zloader sample in the\nappendix. It helps automating the configuration extraction.\n\n### Malware objectives\n\nThe configurations of downloaded pieces of Zloader malware associates them with the `kev`\nbotnet. The `kev ID has been publicly observed since December 2020.`\n\nZloader has been identified as an access vector for Ryuk and Egregor ransomware\ndeployments. Whether the installments associated with the `kev configuration tag are part`\nof this or a different ransomware operation is currently unknown. However, by the direction\nthe current threat landscape is moving, it is highly likely the malware is also used to deploy\nransomware.\n\n## Conclusion and Countermeasures\n\nSpreading the attack into multiple encoded stages (document in HMTL; payload URL in\n```\nUserForm s; download of password-protected XLS; decoding of Zloader payload from\n\n```\ndecrypted XLS) shows that much effort was put into evading detection. Even after the\ncampaign ran for several weeks, the initial MHTML documents still only got 7 out of 61\ndetections when first scanned on VirusTotal.\n\n\n-----\n\nThe unusual MHTML encoding of the initial Word document can pose problems for security\nsoftware unfamiliar with this format. Its initial layer must be parsed differently from\nOLE/CDF/OpenXML-based Office documents and being ASCII plain-text may completely\nbypass some detections. For network-based protection software, it is impossible to\ninvestigate the intermediary downloaded XLS document with the Zloader payload – because\nit is encrypted. Another struggle is the low level of maliciousness of the initial Word\ndocument. While downloads from documents should always be deemed at least suspicious,\nin this case, only another Excel document was download. Some business workflows may\nrequire Word documents to download resources from web. Consequently, the observed\nbehaviour may fly under the radar. Hence, spreading the malicious components (download;\ndropper; Zloader malware) over multiple stages can bypass detection for some security\nsolutions.\n\nHornetsecurity’s [Spam Filtering Solutions and Malware Protection detects and quarantines](https://www.hornetsecurity.com/en/services/spam-filter/)\nthe outlined threat. Hornetsecurity’s [Advanced Threat Protection extends this protection by](https://www.hornetsecurity.com/en/services/advanced-threat-protection/)\nalso detecting yet unknown threats.\n\n## References\n\n Appendix\n\n### DC3-MWCP / CAPE configuration parser\n\n[The following DC3-MWCP configuration parser is an update to CAPE’s Zloader parser and](https://github.com/kevoreilly/CAPEv2/blob/master/modules/processing/parsers/mwcp/Zloader.py)\ncan be used as a drop in replacement (additionally we opened a pull request with the\nupstream project):\n\n\n-----\n\n```\n# Copyright (C) 2020 Kevin O Reilly (kevoreilly@gmail.com)\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program. If not, see <http://www.gnu.org/licenses/>.\nfrom mwcp.parser import Parser\nimport struct\nimport string\nimport pefile\nimport yara\nimport re\nfrom Crypto.Cipher import ARC4\nimport logging\nlog = logging.getLogger(__name__)\nrule_source = '''\nrule Zloader\n{\n  meta:\n    author = \"kevoreilly\"\n    description = \"Zloader Payload\"\n    cape_type = \"Zloader Payload\"\n  strings:\n    $rc4_init = {31 [1-3] 66 C7 8? 00 01 00 00 00 00 90 90 [0-5] 8? [5-90] 00 01\n00 00 [0-15] (74|75)}\n    $decrypt_conf = {e8 ?? ?? ?? ?? e8 ?? ?? ?? ?? e8 ?? ?? ?? ?? e8 ?? ?? ?? ??\n68 ?? ?? ?? ?? 68 ?? ?? ?? ?? e8 ?? ?? ?? ?? 83 c4 08 e8 ?? ?? ?? ??}\n  condition:\n    uint16(0) == 0x5A4D and any of them\n}\n'''\nMAX_STRING_SIZE = 32\nyara_rules = yara.compile(source=rule_source)\ndef decrypt_rc4(key, data):\n  cipher = ARC4.new(key)\n  return cipher.decrypt(data)\ndef string_from_offset(data, offset):\n  string = data[offset : offset + MAX_STRING_SIZE].split(b\"\\0\")[0]\n  return string\nclass Zloader(Parser):\n\n```\n\n-----\n\n```\n  DESCRIPTION Zloader configuration parser \n  AUTHOR = 'kevoreilly'\n  def run(self):\n    filebuf = self.file_object.file_data\n    pe = pefile.PE(data=filebuf, fast_load=False)\n    image_base = pe.OPTIONAL_HEADER.ImageBase\n    matches = yara_rules.match(data=filebuf)\n    if not matches:\n      return\n    for match in matches:\n      if match.rule != \"Zloader\":\n        continue\n      for item in match.strings:\n        if '$decrypt_conf' in item[1]:\n          decrypt_conf = int(item[0])+21\n    va = struct.unpack(\"I\",filebuf[decrypt_conf:decrypt_conf+4])[0]\n    key = string_from_offset(filebuf, pe.get_offset_from_rva(va-image_base))\n    data_offset =\npe.get_offset_from_rva(struct.unpack(\"I\",filebuf[decrypt_conf+5:decrypt_conf+9])[0]image_base)\n    enc_data = filebuf[data_offset:].split(b\"\\0\\0\")[0]\n    raw = decrypt_rc4(key, enc_data)\n    items = list(filter(None, raw.split(b'\\x00\\x00')))\n    self.reporter.add_metadata(\"other\", {\"Botnet name\":\nitems[1].lstrip(b'\\x00')})\n    self.reporter.add_metadata(\"other\", {\"Campaign ID\": items[2]})\n    for item in items:\n      item = item.lstrip(b'\\x00')\n      if item.startswith(b'http'):\n        self.reporter.add_metadata(\"address\", item)\n      elif len(item) == 16:\n        self.reporter.add_metadata(\"other\", {\"RC4 key\": item})\n    return\n\n## Indicators of Compromise (IOCs)\n\n### Email\n\n```\n**Subjects**\n\n\n-----\n\n```\nInvoicing details#?[0-9]+\n\n```\n\n-----\n\n```\nEssential contract Number #?[0-9]+ update\n\n```\n\n**Attachments**\n\nThe following regular expressions describe the attachment names used in the campaigns:\n```\n   ([a-z]{4,8}_){1,2}[a-z]{4,8}[0-9]+.doc\n   [A-z0-9][A-z][0-9]+.doc\n\n### Hashes\n\n```\nHashes of publicly available files:\n\n**MD5** **Filename** **Description**\n\n`6743ca84f7e9929c2179238e20934f57` `nG772044.doc` Zloader MHTML document\n\n\n-----\n\n**MD5** **Filename** **Description**\n\n`7a888f899a4850f02bad194bf01daaa7` `eU107462.doc` Zloader MHTML document\n\n`35ee0681eb3076674e01efec565f663b` `L1978883.doc` Zloader MHTML document\n\n`25e2cffc5621cab99bd0a36d234c234f` `QG915014.doc` Zloader MHTML document\n\n`222cb61e1041f3e4dbdc3493572388e6` `dY433632.doc` Zloader MHTML document\n\n### URLs\n\n```\nhttps://findinglala[.]com/down/doc.xls?ekyh_vD91041.z4730435.doc\n\n```\n\n### DNS\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2021/2021-03-29 - Zloader email campaign using MHTML to download and decrypt XLS.pdf"
    ],
    "report_names": [
        "2021-03-29 - Zloader email campaign using MHTML to download and decrypt XLS.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536251,
    "ts_updated_at": 1743041139,
    "ts_creation_date": 1653713591,
    "ts_modification_date": 1653713591,
    "files": {
        "pdf": "https://archive.orkl.eu/7b956dddd23502aa43dd3d272aabb75b00f6fd37.pdf",
        "text": "https://archive.orkl.eu/7b956dddd23502aa43dd3d272aabb75b00f6fd37.txt",
        "img": "https://archive.orkl.eu/7b956dddd23502aa43dd3d272aabb75b00f6fd37.jpg"
    }
}