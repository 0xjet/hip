{
    "id": "65fe7ad4-aa14-4589-826b-02f9a72205e6",
    "created_at": "2023-01-12T15:09:58.779798Z",
    "updated_at": "2025-03-27T02:05:41.691127Z",
    "deleted_at": null,
    "sha1_hash": "84e2c854a627be15067e4ac82ff490f05af504ca",
    "title": "2022-01-27 - Programs Hacking Programs- How to Extract Memory Information to Spot Linux Malware",
    "authors": "",
    "file_creation_date": "2022-05-28T02:29:37Z",
    "file_modification_date": "2022-05-28T02:29:37Z",
    "file_size": 3087556,
    "plain_text": "# How to Extract Memory Information to Spot Linux Malware\n\n**[crowdstrike.com/blog/how-to-extract-memory-information-to-spot-linux-malware/](https://www.crowdstrike.com/blog/how-to-extract-memory-information-to-spot-linux-malware/)**\n\nMatthew Hartzell January 27, 2022\n\nThreat actors go to great lengths to hide the intentions of the malware they produce\nThis blog demonstrates reliable methods for extracting information from popular Linux\nshells\nExtracted memory information can help categorize unknown software as malicious or\nbenign and could reveal information to help incident responders\nSome malware is only ever resident in memory, so memory scanning along with\nbehavioral analysis could be the only viable approach to detection and mitigation\n\n[Threat actors go to great lengths to hide the intentions of the malware they produce. For](https://www.crowdstrike.com/cybersecurity-101/malware/)\ninstance, binaries are often encrypted or packed. Typically, encrypting binaries is enough to\nthwart automated analysis platforms such as Cuckoo or other automated malware\nsandboxes. The implication is that automated detection of malicious programs might not be\nsuccessful.\n\n\n-----\n\nTypically, [ransomware does not have the encryption keys embedded in the software, as this](https://www.crowdstrike.com/cybersecurity-101/ransomware/)\nwould allow researchers to easily decrypt the encrypted files. This would also mean that the\nsame key is being used across multiple victims. Instead, ransomware actors generate a\npublic key and a private key when on target. These actors then encrypt the private key using\nthe public key, and there is a small window where the private key is unencrypted and in\nmemory. But, the inputs used to generate the private key could remain in memory,\nunencrypted. If security researchers can gather this information, it would allow the recreation\nof the public and private keys to help the victim recover without paying the ransom.\n\nAdditionally, fileless malware is becoming increasingly common, and in these cases,\nbehavioral detections and memory scanning may be the only means of detection and\n[mitigation. With fileless malware, important information can be stored in environment or local](https://www.crowdstrike.com/cybersecurity-101/malware/fileless-malware/)\nvariables. This technique obscures what is actually happening, even when security\nresearchers recover command history. What’s stored in the shell’s memory could be anything\nfrom encryption keys to `bash commands.`\n\nThreat actors employ memory-scanning techniques to accomplish tasks such as password\nstealing. They know that memory scanning is difficult and requires an upfront investment in\nreverse engineering, and therefore hiding certain information in the memory of a process\ncould be enough to thwart detection. Once the shell is closed, the memory will be cleaned up\nby the operating system, making reconstruction of that memory almost impossible.\n\n## Practical Use Cases\n\nWhen a malicious program is running, there will be artifacts in memory. Theoretically, by\nhalting the ransomware and dumping the memory, incident responders and security\nresearchers could obtain the malware’s secrets to help them piece together what happened.\nOr, perhaps an indicator of attack could be present in memory but not readily apparent in the\nbinary.\n\nAnother use case is analyzing packed or encrypted running programs. Even if the entire\nprogram is not unpacked at once, certain sections or segments must be unpacked for the\nprogram to run. Some of this information can be used as an indicator of malware. Inspecting\nthe process’s memory is the only way to obtain this information at run time.\n\nThe following script is from DarkRadiation ransomware, which is an example of “living off the\nland” malware.\n\nDarkRadiation script snippet\n\n\n-----\n\nIn this code snippet from DarkRadiation fileless ransomware, the three variables —\nPASS_DE, PASS_ENC and PASS_DEC — have limited visibility.\n\nPASS_DE is visible in memory and in network traffic\nPASS_ENC is visible in memory and in the command line used to launch the script\nPASS_DEC is visible in memory only\n\nMalware typically employs memory-scanning techniques to gather information. For example,\npoint-of-sale (POS) terminals routinely process personal information, PINs and credit card\nnumbers, and if an attacker could deploy malware to examine the memory on the POS\nterminal, this would allow the attacker to obtain a large amount of information either to use\nfor identity theft or to sell on the dark web.\n\nIn the case of WannaCry ransomware, researchers discovered artifacts in memory that\nenabled them to recreate the public and private keys used during the encryption process.\nThis discovery was a major blow to the malware actors’ operations as it enabled researchers\nto develop a recovery and decryption program for WannaCry victims.\n\n## Proof of Concept Using Linux\n\nWhether an attacker is trying to read another process’s memory, or if defenders are reading\nprocess memory to defend against attackers, the techniques are similar. For our purposes,\nwe inspected the memory of Linux shells such as `bash . This is useful as a proof of concept`\nbecause it demonstrates reliable methods for extracting information.\n\n### Methodology\n\nThe methodology at a high level is to parse the target process’s memory and associated\n```\nelf file. This is accomplished by reading the files:\n   /proc/<pid>/maps\n   /proc/<pid>/mem\n\n```\nThe files that reside under `/proc represent a pseudo-filesystem. These files are not real,`\nbut instead contain runtime system information. For more information, see `man proc .`\n\nUnder the `/proc/<pid>/ directory, the` `maps file shows the full path of the running`\nprogram and where the process is mapped in memory. The `mem file contains the memory of`\nthe running process to include the sections:\n\ntext\ndata\nbss\nheap\nloaded shared objects\n\n\n-----\n\nThere are many sections in all `elf files. The vast majority are not particularly interesting`\nfrom a malware perspective, but a few can be very interesting.\n\n.text: machine instructions for the CPU\n.data: initialized global variables\n.rodata: initialized read-only global variables (such as strings)\n.bss: uninitialized global variables\n.symtab: global symbol table\n.dynsym: symbol tables dedicated to dynamically linked symbols (runtime dependency\nlinking)\n.strtab: string table of .symtab section\n.dynstr: string table of .dynsym section\n\nWhile some sections can be stripped from an `elf file without affecting execution, other`\nsections cannot be removed.\n\n### Memory Scanning\n\nThe “trick” to memory scanning is to find the data of interest in memory. Different shells store\nhistory in different ways. `Bash uses a table,` `tcsh uses a doubly linked list, and` `zsh also`\nuses a doubly linked list, implemented in a ring. All shells examined are stripped of symbols\nbut have imports and exports that can be used to navigate to the data structure we are\nlooking for.\n\n### Bash\n```\nBash exports the symbol “ history_list ”. This function only has one line, returning a\n\n```\npointer to the data structure that contains the history.\n\nParsing the `elf file, we obtain the “ .dynsym ” and “ .dynstr ” sections. This is enough to`\nget the address offset of the “ history_list ” function.\n\nAlso, the symbol “ history_length ” is exported. This is important because it lets us know\nhow far to go when iterating through the table.\n\nTo obtain the actual length, we use the “ history_length ” symbol. We then read the\naddress that the symbol points to.\n\nTo obtain the address of the history table, we have to go to the text section to read the spot\nthat “ history_list ” returns. Then we have to parse the x86_64 instruction. This will give\nus the address of the table.\n\nOnce we have these two values, we simply iterate through the table.\n\n### Tcsh\n\n\n-----\n\nIt is a little more complicated to find the data structure in `tcsh than in` `bash or` `zsh`\nbecause there are no symbols we can use as reference points. Therefore, we have to go\nthrough the text section more extensively. The `elf header points to the entry point, which`\nis “ start ”. We can find “ main ” from there, as its address is the first parameter passed\ninto “ libc_start_main ”. Once in `main, a wide character string “ history ” is passed`\ninto another function that keeps track of the history length. The function call just after that is a\ncall to “ sethistory ”. This function gives us the length of the history and another function\ncall, “ discardExcess ”. A pointer to the data structure that contains the history’s linked list\nis checked for NULL right at the beginning of this function.\n\nAt this point, we have everything we need to parse the linked list and obtain the history.\n\n### Zsh\n```\nZsh is a bit easier because the binary exports the data structure we need. We get the offset\n\n```\naddress of the pointer by parsing the `elf file, and the value of the pointer by reading from`\nthat spot in memory.\n\nWe now have what we need to walk the link list implemented in a ring. This means we can\nwalk the list forward or backward from this pointer. If we intend to walk the entire list instead\nof just grabbing the most recent entry, we have to keep track of where we started, or we will\ngo around the ring forever.\n\n### A Detailed Walkthrough\n\nWe need the `pid` of the process we want to examine. For our purposes, in the target shell,\nwe can type `echo $$ . This prints the` `pid of the shell to the screen. If this were not`\npossible for some reason, the `ps command prints information on every process on a`\nsystem when certain parameters are used. See `man ps for more information.`\n\nOnce the `pid is obtained, we start examining the target process. Our program must be run`\nas `root . This is necessary to read another process’s memory. There are two files under`\nthe `/proc/<pid> directory that this program uses. As an example, say the process’s` `pid`\nis 3930. In this case, the files `/proc/3930/maps and` `/proc/3930/mem are both opened`\nfor reading. If we also want to change the process’s memory, the `/proc/3930/mem file`\ncould be opened in read/write mode.\n\nWe first read the `maps file. To better understand this file and get more information, see the`\nman page for proc.\n\n\n-----\n\nSample `maps file`\n\nFor our example, we have the following:\n```\n                     maps file for bash\n\n```\nThis tells us the full path of the original file and the address that file was used to load the\nbinary.\n\n### Acquiring the Data Structures\n\nUsing the full path to the `elf file, we open the binary file and parse the headers. We obtain`\nthe addresses of the various sections of the `elf file by reading the` `elf header, and then`\niterate the section headers. To make subsequent reading easier, we also copy the section\nheaders into a global array of structures.\n\n\n-----\n\nParsing section headers\n\nFor the purposes of examining `bash and` `zsh, we are interested in the` `.dynsym and`\n```\n.dynstr sections. The examination of the tcsh shell requires the .text and .data\n\n```\nsections.\n\nIn the case of `bash and` `zsh, simply iterate through the` `.dynsym section and call`\n```\nstrncmp to find the strings/symbols that we need.\n\n```\nWe use the `capstone library to parse instructions in the` `tcsh shell. We know that the`\naddress of `main is the first argument passed into` `libc_start_main . We therefore know`\nthat very near the entry point there will be an instruction similar to this:\n\n“ rdi, qword ptr [rip - 0x19c4] “\n\nThis instruction tells us to load the value found relative to the value of the `RIP register into`\nthe `RDI register. This value is the address of the` `main function.`\n\nContinuing to use `capstone, we start iterating through` `main, this time looking for a`\nreference to the wide character string “ history ”. We know that this string along with a\nhard-coded value of 100 are passed into the `sethistory function. The address of the`\nstring is moved into the register using the `lea mnemonic, while 0x64 (which is 100) is`\nmoved into `EDI using the` `mov mnemonic. When we see these instructions followed by a`\n```\ncall instruction, we have a high degree of confidence that we have found the correct\n\n```\ninstruction\n\n\n-----\n\nNext we start examining the instructions in the `sethistory function. Once here, the first`\ninstruction moves the `histlen global variable into the` `EDI register. The second`\ninstruction is a jump into the function `discardExcess . This is a` `jump instead of a` `call`\nbecause the compiler optimizations implemented this function inline. Once in discardExcess,\nthere are two `move commands to load the addresses of` `histTail and` `histCount into`\nregisters. Once we have these addresses, we are ready to simply iterate through the linked\nlist, which gives us the history.\n\n### Parsing the Data Structures\n```\nBash places the command line history in an array. Therefore, once we have the address of\n\n```\nthe table, we simply iterate through the table the number of times indicated by the length\nglobal variable.\n```\nZsh and tcsh both store the history in a link list, with the notable difference being that\nzsh uses a circular doubly linked list. Therefore, when walking through the linked list in\nzsh, you could go around the ring forever. This implementation means that it is easy to\n\n```\nwalk the list both forward and backward. We simply have to keep track of the starting point,\nand when we see that address again, we know that we have gone all the way around. With\n```\ntcsh, we simply follow the linked list until the next pointer points to NULL . With tcsh,\n\n```\nwe captured the address of the list’s length in our initial parsing, so alternately, we can just\niterate through the list the number of times indicated by this global variable.\n\n### Command Line Value\n\nAn example from DarkRadiation:\n\nIn this case, the password is being changed for all users except root. The standard input and\nstandard output of four different commands are piped together in one command line. If these\ncommands are inspected individually, it would be difficult to piece together what is actually\nhappening here. By going into the shell to obtain the history, we can see the entire command\nline and more easily reconstruct the attack.\n\n## Bottom Line\n\nScanning process memory is a powerful tool that both adversaries and security researchers\nuse. Threat actors can use memory during various stages of an attack lifecycle —\nreconnaissance, persistence, defense evasion, credential access and discovery — to\nachieve their goals.\n\n\n-----\n\nHowever, security researchers can use extracted memory information to reveal whether\nunknown software is malicious or benign, especially when popular Linux shells are abused.\n\nWhether it’s threats or sophisticated adversaries, CrowdStrike remains dedicated to our main\nmission: stopping breaches.\n\n**Additional Resources**\n\n_[Learn more about how the Falcon platform protects Linux systems in this solution brief.](https://www.crowdstrike.com/resources/data-sheets/linux-solution-brief/)_\n_Read this press release for information about CrowdStrike Falcon’s enhanced Linux_\n_protection: CrowdStrike Falcon Expands Linux Protection with Enhanced Prevention_\n_Capabilities_\n_[Visit the product website to learn how the powerful CrowdStrike Falcon platform](https://www.crowdstrike.com/endpoint-security-products/falcon-platform/)_\n_provides comprehensive protection across your organization, workers, data and_\n_identities._\n_[Get a full-featured free trial of CrowdStrike Falcon Prevent™ and learn how true next-](https://www.crowdstrike.com/resources/free-trials/try-falcon-prevent/)_\n_gen AV performs against today’s most sophisticated threats._\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2022/2022-01-27 - Programs Hacking Programs- How to Extract Memory Information to Spot Linux Malware.pdf"
    ],
    "report_names": [
        "2022-01-27 - Programs Hacking Programs- How to Extract Memory Information to Spot Linux Malware.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673536198,
    "ts_updated_at": 1743041141,
    "ts_creation_date": 1653704977,
    "ts_modification_date": 1653704977,
    "files": {
        "pdf": "https://archive.orkl.eu/84e2c854a627be15067e4ac82ff490f05af504ca.pdf",
        "text": "https://archive.orkl.eu/84e2c854a627be15067e4ac82ff490f05af504ca.txt",
        "img": "https://archive.orkl.eu/84e2c854a627be15067e4ac82ff490f05af504ca.jpg"
    }
}