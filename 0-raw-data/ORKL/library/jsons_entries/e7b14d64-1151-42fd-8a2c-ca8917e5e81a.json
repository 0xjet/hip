{
    "id": "e7b14d64-1151-42fd-8a2c-ca8917e5e81a",
    "created_at": "2023-01-12T14:59:02.721602Z",
    "updated_at": "2025-03-27T02:05:56.799567Z",
    "deleted_at": null,
    "sha1_hash": "3a9eb5a0f2d35f0d691761f27611a4e7ec77fd17",
    "title": "2020-12-23 - Detect RC4 in (malicious) binaries",
    "authors": "",
    "file_creation_date": "2022-05-27T21:13:17Z",
    "file_modification_date": "2022-05-27T21:13:17Z",
    "file_size": 396079,
    "plain_text": "# Learn to quickly detect RC4 encryption in (malicious) binaries\n\n**[0xc0decafe.com/2020/12/23/detect-rc4-in-malicious-binaries](https://0xc0decafe.com/2020/12/23/detect-rc4-in-malicious-binaries)**\n\nDecember 23, 2020\n\n[RC4 (also known as ARC4) is a simple stream cipher. It was designed in the late 1980s and](https://en.wikipedia.org/wiki/RC4)\nits internals became known to the public in the mid-1990s. While it is a very simple and fast\ncrypto algorithm, security researchers have discovered multiple flaws in it throughout the\nyears. Today, it is just another broken stream cipher.\n\nHowever, it is still used by software systems in the wild. Many malware families use it for\nencryption or better said: just for obfuscation purposes. Due to its simplicity and speed,\nmalware authors embed it directly in their source code or statically link it into their binaries.\nFor instance, ZLoader utilizes it to decrypt its configuration and Smokeloader encrypts its\nnetwork traffic with this stream cipher.\n\n[Even though they could utilize one of the crypto APIs offered by Windows like the WinCrypt*](https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptencrypt)\nfunctions, malware authors likely prefer this way as another way to ensure malware analysts’\njob security.\n\n\n-----\n\nIn contrast to other ciphers, RC4 does not rely on any constants that make it easy for tools\n[like findcrypt-yara to detect it in the binary. Nevertheless, tools like capa that take the](https://github.com/polymorf/findcrypt-yara)\nassembly code structure of the binary into account are capable of detecting RC4. More on\nhow capa does this later on.\n\n## Detection possibility: Key-Scheduling Algorithm (KSA)\n\n[While explaining RC4 is out of scope of this blog post (Wikipedia does a great job!), one of](https://en.wikipedia.org/wiki/RC4)\nthe most interesting parts of the algorithm is Key-Scheduling Algorithm (KSA). In a nutshell, it\ninitializes an internal array based on the provided key that is later utilized by another\nalgorithm to encrypt / decrypt. In pseudo code KSA looks like this (taken from [Wikipedia):](https://en.wikipedia.org/wiki/RC4)\n```\nfor i from 0 to 255   \n  S[i] := i \nendfor\nj := 0 \nfor i from 0 to 255   \n  j := (j + S[i] + key[i mod keylength]) mod 256  \n  swap values of S[i] and S[j] \nendfor\n\n```\nThe internal array S contains all possible byte values from `0x00 to` `0xFF . It is permuted in`\nthe KSA. This usually compiles down to something like the following:\n\n\n-----\n\nThe first and second blocks are the actual KSA. Note the two `cmp instructions ( cmp eax,`\n```\n100h and cmp r9d, 100h ). These are part of the two for loops are seen in the pseudo\n```\ncode (lines 1 and 5). The third block is the Pseudo-random generation algorithm (PRGA)\nused to encrypt/decrypt the plain/ciphertext. I won’t go much more into the details of the\n_[PRGA, please refer to the great Wikipedia article on RC4.](https://en.wikipedia.org/wiki/RC4)_\n\n## Detect RC4 encryption with yara\n\nThese two `for loops in the KSA are something where we could detect the presence of`\n_RC4 in the binary. But mind possible false positives! For years, I utilized a simple yara rule to_\ndetect this stream cipher.\n\n\n-----\n\n```\nrule rc4_ksa\n {\n   meta:\n     author = \"Thomas Barabosch\"\n     description = \"Searches potential setup loops of RC4's KSA\"\n   strings:\n     $s0 = { 3d 00 01 00 00 } // cmp eax, 256\n     $s1 = { 81 f? 00 01 00 00 } // cmp {ebx, ecx, edx}, 256\n     $s2 = { 48 3d 00 01 00 00 } // cmp rax, 256\n     $s3 = { 48 81 f? 00 01 00 00 } // cmp {rbx, rcx, …}, 256\n   condition:\n     any of them\n }\n\n```\nAs you can see, this rule targets exactly the `cmp instructions found in the KSA. While there`\nmay be better ways to do this, this is still a very fast approximation.\n\n## Detect RC4 encryption with capa\n\nNowadays, we have tools like capa that do a better job. But how does capa does it? I’ve\n[promised to tell you: on one side, capa detects if a binary is linked against OpenSSL or](https://github.com/fireeye/capa-rules/blob/1ff994f7916d66e39b4b5b8dbb310d0e0b051f7f/linking/static/openssl/linked-against-openssl.yml)\nimports [WinCrypt functions. This is trivial as you can see in the rule linked-against-](https://github.com/fireeye/capa-rules/blob/7c59ad39d138467fe67ab79532714b8fa7efede0/data-manipulation/encryption/rc4/encrypt-data-using-rc4-via-winapi.yml)\nopenssl.yml, which performs simple string matching:\n```\nrule:       \n meta:      \n  name: linked against OpenSSL      \n  namespace: linking/static/openssl     \n  author: william.ballenthin@fireeye.com    \n  scope: file    \n  examples:     \n   - 6cc148363200798a12091b97a17181a1    \n features:    \n  - or:    \n   - string: RC4 for x86_64, CRYPTOGAMS by <appro@openssl.org>     \n   - string: AES for x86_64, CRYPTOGAMS by <appro@openssl.org>     \n   - string: DSA-SHA1-old\n\n```\nOn the other side, capa detects the [KSA and](https://github.com/fireeye/capa-rules/blob/7c59ad39d138467fe67ab79532714b8fa7efede0/data-manipulation/encryption/rc4/encrypt-data-using-rc4-ksa.yml) [PRGA algorithms of RC4 based on the](https://github.com/fireeye/capa-rules/blob/7c59ad39d138467fe67ab79532714b8fa7efede0/data-manipulation/encryption/rc4/encrypt-data-using-rc4-prga.yml)\nassembly. This is more interesting since capa takes the structure of the binary into account.\n[The rule encrypt-data-using-rc4-ksa.yml detects the KSA as follows:](https://github.com/fireeye/capa-rules/blob/7c59ad39d138467fe67ab79532714b8fa7efede0/data-manipulation/encryption/rc4/encrypt-data-using-rc4-ksa.yml)\n\n\n-----\n\n```\nrule:         \n meta:         \n  name: encrypt data using RC4 KSA       \n  namespace: data-manipulation/encryption/rc4      \n  author: moritz.raabe@fireeye.com       \n  scope: function      \n  att&ck:      \n   - Defense Evasion::Obfuscated Files or Information [T1027]       \n  mbc:      \n   - Cryptography::Encrypt Data::RC4 [C0027.009]    \n   - Cryptography::Encryption Key::RC4 KSA [C0028.002]     \n  examples:     \n   - 34404A3FB9804977C6AB86CB991FB130:0x403D40      \n   - C805528F6844D7CAF5793C025B56F67D:0x4067AE      \n   - 9324D1A8AE37A36AE560C37448C9705A:0x404950      \n   - 782A48821D88060ADF0F7EF3E8759FEE3DDAD49E942DAAD18C5AF8AE0E9EB51E:0x405C42  \n   - 73CE04892E5F39EC82B00C02FC04C70F:0x40646E      \n features:       \n  - or:      \n   - and:    \n    - basic block:    \n     - and:    \n      - description: initialize S    \n      # misses if regular loop is used,     \n      # however we cannot model that a loop contains a certain number    \n      - characteristic: tight loop    \n      - or:    \n       - number: 0xFF    \n       - number: 0x100    \n    - or:     \n     - match: calculate modulo 256 via x86 assembly     \n     # compiler may do this via zero-extended mov from 8-bit register     \n     - count(mnemonic(movzx)): 2 or more    \n    - or:    \n     - description: modulo key length    \n     - mnemonic: div    \n     - mnemonic: idiv     \n   - and:     \n    - description: optimized, writes DWORDs instead of bytes    \n    - or:    \n     - number: 0xFFFEFDFC    \n     - mnemonic: sub    \n    - or:    \n     - number: 0x03020100     \n     - mnemonic: add    \n    - number: 0x4040404\n\n```\n_capa detects RC4 in two ways. The first way consists of three parts (lines 20-29)._\n\na basic block with a tight loop counting to `0xFF or` `0x100`\na match against another rule calculate modulo 256 via x86 assembly or two or more\n```\n   movzx mnemonics\n\n```\n\n-----\n\neither a `div or a` `idiv mnemonics that are utilized by the KSA for the module of`\n```\n   keylength (see pseudo algorithm of KSA)\n\n```\nThe second way detects optimizations where instead of bytes DWORDs are written by the\n_KSA (lines 38-46). For instance, the password cracker John optimizes the KSA like this (see_\n[opencl_rc4.h). It comprises an initialized array of 64 DWORDs:](https://github.com/openwall/john/blob/b81ed703ceb7ca62df50c2fa0d4ea366ef713a4a/run/opencl/opencl_rc4.h)\n```\n#ifdef RC4_IV32    \n__constant uint rc4_iv[64] = { 0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,    \n                0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c,    \n                0x23222120, 0x27262524, 0x2b2a2928, 0x2f2e2d2c,    \n                0x33323130, 0x37363534, 0x3b3a3938, 0x3f3e3d3c,    \n                0x43424140, 0x47464544, 0x4b4a4948, 0x4f4e4d4c,    \n                0x53525150, 0x57565554, 0x5b5a5958, 0x5f5e5d5c,    \n                0x63626160, 0x67666564, 0x6b6a6968, 0x6f6e6d6c,    \n                0x73727170, 0x77767574, 0x7b7a7978, 0x7f7e7d7c,    \n                0x83828180, 0x87868584, 0x8b8a8988, 0x8f8e8d8c,    \n                0x93929190, 0x97969594, 0x9b9a9998, 0x9f9e9d9c,    \n                0xa3a2a1a0, 0xa7a6a5a4, 0xabaaa9a8, 0xafaeadac,    \n                0xb3b2b1b0, 0xb7b6b5b4, 0xbbbab9b8, 0xbfbebdbc,   \n                0xc3c2c1c0, 0xc7c6c5c4, 0xcbcac9c8, 0xcfcecdcc,    \n                0xd3d2d1d0, 0xd7d6d5d4, 0xdbdad9d8, 0xdfdedddc,    \n                0xe3e2e1e0, 0xe7e6e5e4, 0xebeae9e8, 0xefeeedec,    \n                0xf3f2f1f0, 0xf7f6f5f4, 0xfbfaf9f8, 0xfffefdfc };   \n#endif\n\n```\nNow we can understand where the constants `0xFFFEFDFC and` `0x03020100 come from.`\n[Such an optimized version of RC4 was actually utilized in the original XBOX bootloader](https://mborgerson.com/deconstructing-the-xbox-boot-rom/)\n(there we can also see the utilization of the DWORD `0x4040404 ).`\n\nLet me tell you a tiny anecdote. A couple of years ago, a junior coworker reversed the whole\n_RC4 algorithm in a malicious binary and told some colleagues and me that they analyzed a_\ncustom crypto algorithm. We told them that this was just plain old RC4. The coworker was a\nlittle bit upset but they likely learned a lot from their tiny adventure in RC4. I hope that now\nyou are capable of spotting RC4 in (malicious) binaries and I’ve just saved you a couple of\nhours of reversing.\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2020/2020-12-23 - Detect RC4 in (malicious) binaries.pdf"
    ],
    "report_names": [
        "2020-12-23 - Detect RC4 in (malicious) binaries.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535542,
    "ts_updated_at": 1743041156,
    "ts_creation_date": 1653685997,
    "ts_modification_date": 1653685997,
    "files": {
        "pdf": "https://archive.orkl.eu/3a9eb5a0f2d35f0d691761f27611a4e7ec77fd17.pdf",
        "text": "https://archive.orkl.eu/3a9eb5a0f2d35f0d691761f27611a4e7ec77fd17.txt",
        "img": "https://archive.orkl.eu/3a9eb5a0f2d35f0d691761f27611a4e7ec77fd17.jpg"
    }
}