{
    "id": "f628bd57-53c4-4a2e-a4e1-cf2c83490fcd",
    "created_at": "2023-01-12T15:01:37.419183Z",
    "updated_at": "2025-03-27T02:05:36.027798Z",
    "deleted_at": null,
    "sha1_hash": "e46d8cd36421813bc00663db9032e620a4f34852",
    "title": "2019-10-31 - Dynamic Imports and Working Around Indirect Calls - Smokeloader Study Case",
    "authors": "",
    "file_creation_date": "2022-05-27T19:01:15Z",
    "file_modification_date": "2022-05-27T19:01:15Z",
    "file_size": 1664405,
    "plain_text": "# Dynamic Imports and Working Around Indirect Calls - Smokeloader Study Case\n\n**[m.alvar.es/2019/10/dynamic-imports-and-working-around.html](https://m.alvar.es/2019/10/dynamic-imports-and-working-around.html)**\n\nWhen reversing malware it is common to find an injected payload loading references to\nexternal resources (DLL functions). This happens for two main reasons:\n\n1. The hosting process does not have all resources necessary to the execution of the\n\ninjected payload;\n2. Making reversing engineering the malware trickier since the dumped segment will have\n\nall calls pointing to a meaningless address table.\n\nThis article explains how to revert this trick and get back API call names annotations in an\n_[IDApro database. A sample of](https://www.hex-rays.com/products/ida/)_ [Smokeloader was used for illustrating the ideas described in](http://security.neurolabs.club/2019/08/smokeloaders-hardcoded-domains-sneaky.html)\nthis post.\n\nThis article is divided in three main parts:\n\n1. Explaining the observed technique;\n2. How it works; and\n3. How to circumventing it in order to facilitate reversing.\n\nFirst of all, shout out to Sergei Frankoff from [Open Analysis for this](https://www.openanalysis.net/) [amazing video tutorial on](https://www.youtube.com/watch?v=hM2Zvsak3GM)\n[this same topic which inspired me to write about my analyses. Regards also to Mark Lim who](https://twitter.com/peta909)\nalso wrote a [very interesting article about labelling indirect calls in 2018. His article uses](https://findingvulns.blogspot.com/2018/04/using-ida-pro-debugger-and-idapython.html)\n_structures instead of patching the code (which is also a good approach) but I think it lacks_\nimportant details and I will try to cover these points in here.\n\nExamples presented in this article were extracted from the following Smokeloader sample:\n\nFilename:  p0n36i2d.exe\nMD5:     a8cc396b6f5568e94f28ca3381c7f9df\nSHA1:    12948e36584e1677e80f78b8cc5c20576024c13f\nSHA256:  17b548f9c8077f8ba66b70d55c383f87f92676520e2749850e555abb4d5f80a5\nSize:      215.5 KB (220672 bytes)\nType:     PE32 executable for MS Windows (GUI) Intel 80386 32-bit\n\nExplaining what is going on in the first stage (packer/crypter) is out of scope; this article\nfocuses on characteristics found in the final payload. This sample injects the main payload in\n[\"explorer.exe\" as it is possible to observe in this AnyRun sandbox analysis.](https://app.any.run/tasks/c3ab622a-8c68-42c8-aeb7-bf88226983cc/)\n\n_Figure 01 shows how the code looks immediately after the execution control passes to the_\ninjected code.\n\n\n-----\n\nFigure 01 - Smokeloader's final payload.\n\nThree points were marked in this code snip (1, 2 and 3). The first point (1) is the call to the\nmain function (located at 0x002F1853). This function expects to receive an address through\n_ECX register. This address points to a data segment where all temporary structures will be_\nstored.\n\nThe third point (3) is an indirect call to an address stored in register ESI plus offset 0xEAE.\nThe debugger was not able to resolve this address since the \"memory segment\" pointed by\n_ESI is not set at this point of the execution (Instruction Pointer pointing to 0x002F1844). This_\n**pattern usually is an indicator that this code will dynamically resolve and import**\n**external resources to a specific address table (in this case stored in what we called \"data**\n_segment\"). This is an interesting technique because this table can be moved around by_\nchanging the address stored in ESI as long as offsets are preserved. In this code ESI is set\nto \"0x002E0000\" which is the address of a read-and-write memory segment created during\nthe first stage. Figure 02 shows the region pointed by the offset 0xEAE which is empty at this\npoint of the execution.\n\n\n-----\n\nFigure 02 - Address pointed by the indirect call.\n\nThe second point (2) marks a function call immediately before the indirect call (3). This is a\nstrong indicator that the code for creating the address table must be somewhere inside this\nfunction. The address located in \"002E0EAE\" will be filled with pointers to the expected API\nfunction. Figure 3 shows this same memory region after the \"__load_libraries\" function is\nexecuted.\n\nFigure 03 - Address pointed by the indirect call is filled after the \"__load_libraries\" function\n\nis called\n\n_x32dbg has a memory dump visualisation mode called \"Address\" which will list every_\nfunction pointed to each address loaded in the call table we just described.\n\n\n-----\n\nFigure 04 - Resolved address in call table\n\n_Figure 04 shows that the position pointed by the indirected call listed in point (3) points to_\nfunction \"sleep\" inside \"kernel32.dll\". Basically this call table is an Array of unsigned integers\n(4 bytes) containing an address pointing to an API call in each position.\n\nThe \"__load_library\" function is responsible for creating this \"call table\" so the focus of this\narticle will move to understand how it works.\n\n--- End of part I --\nFigure 05 - \"__load_libraries\" zoomed out CFG representation.\n\n\n-----\n\nFigure 05 shows an overview of the ___load_library function created by IDA. This function is_\nquite large and performs few connected steps which we need to go through in order to fully\nunderstanding its behaviour. This function can be divided in three main sections:\n\n1. Code responsible for finding the base addresses for core libraries;\n2. Code responsible for loading addresses for calls within code libraries;\n3. The last section is responsible for loading other libraries necessary for executing the\n\nmalware.\n\n_Figure 06 presents the first part of the \"__load_libraries\" function. In its preamble the code_\nnavigates through the TEB [(Thread Environment Block) and loads 4 bytes from](https://en.wikipedia.org/wiki/Win32_Thread_Information_Block)\noffset 0x30 into register EAX. This address contains the address of the PEB (Process\n_[Environment Block). Next step is to get the location for the \"PEB_LDR_DATA\" structure](https://www.aldeid.com/wiki/PEB_LDR_DATA)_\nwhich is located in offset 0xC. This structure contains a linked list containing information\nabout all modules (DLLs) loaded by a specific process.\n\n\n-----\n\nFigure 06 - first section of the \"__load_libraries\" function.\n\n\n-----\n\nThe code accesses the offset 0xC in the _[PEB_LDR_DATA structure which contains the](https://www.aldeid.com/wiki/PEB_LDR_DATA)_\nhead element for the loaded modules in the order they were loaded by the process. Each\n[element in this linked list is a combination of \"_LDR_DATA_TABLE_ENTRY\" and](https://www.aldeid.com/wiki/LDR_DATA_TABLE_ENTRY)\n[\"_LIST_ENTRY\" structures. This structure has an entry to the base name of the module in](https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-list_entry)\nthe offset 0x30. Figure 07 summarises all this \"structure maze\" used in order to fetch loaded\nmodule names (excusez-moi for my paint brush skills :D).\n\nFigure 07 - Path through the process internal structures to get loaded DLL names and\n\nbase addresses\n\nThe main loop, beginning at \"loc_2F189F\" (Figure 06), goes through all modules loaded by\nthe \"explorer.exe\" process. This algorithm fetches the module name and calculates a hash\nout of it. The second smaller looping located at \"loc_2F18AB\" (Figure 06) is the part of the\ncode responsible for calculating this hash. Figure 08 shows the reversed code for this\nhashing algorithm.\n\n\n-----\n\nFigure 08 - Reversed hashing algorithm used in the first part of the analysed code\n\nMoving forward, after calculating a hash the algorithm does a XOR operation with a\nhardcoded value 0x25A56A90 and this value is compared with two hardcoded hashes:\n_0x4C5DACBC (kernel32.dll) and 0x7FA40424 (ntdll.dll). The base addresses of each DLL_\nare stored in two global variables located in the following addresses [ESI+0x1036] and\n\n_[ESI+0x103A]._\n\n**Bonus: these hardcoded hashes can be used for detecting this specific version of**\n**_Smokeloader._**\n\nSummarising, this first part of the code is responsible by finding the base address of two core\n_libraries in MS Windows (\"ntdll.dll\" and \"kernel32.dll\"). These addresses will be used for_\nfetching resources necessary for loading all other libraries required by the malware.\n\n_Figure 09 shows the second section of \"__load_libraries\". This figure shows the code with_\nsome functions names already figured out in order to make it more didactic.\n\n\n-----\n\n-----\n\nFigure 09 - second section of the \"__load_libraries\" function.\n\nThe first two basic blocks checks if the function was able to find \"ntdll.dll\" and \"kernel32.dll\"\nbase addresses. If these modules are available then the \"__load_procs_from_module\"\nfunction is invoked for filling the call table. This function receives 4 parameters and does not\nfollow the standard C calling convention. Two parameters are passed through the stack and\nthe other two through registers (ECX and EDX). This function expects a DLL base address\nin EDX, the data segment in ECX, an address to a list of unsigned ints (api calls hashes) and\na destination address (where the calls addresses will be stored). The last two parameters are\npushed in the stack.\n\n_Figure 10 shows the hardcoded hashes passed as parameter to_\n\"__load_procs_from_module\" function. This list will be used to determine which procedures\nwill be loaded in the call table.\n\nFigure 10 - Array of hashes of \"ntdll.dll\" function names\n\nNext step is to take a look inside \"__load_procs_from_module\" function. Figure 11 shows the\ncode for this function. Parameters and functions were named to facilitate the understanding\nof this code.\n\n\n-----\n\n-----\n\nFigure 11 - Code for \"__load_procs_from_modules\" function\n\nThis function iterates over a list of 4 bytes hashes received as parameter. Each element is\n_XORed with a hardcoded value (0x25A56A90) and passed to the function_\n\"__get_proc_address\" together with a base address of a library. This function iterates over\nall procedures names exported by a DLL, calculates a hash and compares it with the hash\nreceived as parameter. If it finds a match, \"__get_proc_address\" returns an address for the\nspecific function.\n\nLets take a closer look inside \"__get_proc_address\" to figure out how it navigates through\nthe loaded DLL. Figure 12 shows a snip of the code for this function.\n\n\n-----\n\n-----\n\nFigure 12 - Code for \"__get_proc_address\" function.\n\nThe preamble of the function fetches the address for the PE header by accessing offset\n_0x3C in the DLL base address. Next step it fetches the relative virtual address (RVA) for the_\nexport directory at offset 0x78 of the PE header. From the Export Directory structure this\nfunction fetches the following fields: NumberOfNames (offset 0x18), AddressOfNames (offset\n_0x20) and AddressOfNameOrdinals (offset 0x24). References for all these structures can be_\nfound in the [Corkami Windows Executable format overview.](https://github.com/corkami/pics/blob/master/binary/pe102/pe102.pdf)\n\nAfter loading information about the exports the code will iterates through the list of function\nnames and calculates a 4 bytes hash by calling the \"__hashing\" function (same algorithm\ndescribed in Figure 08). If the output of the \"__hashing\" function matches the hardcoded\nhash then the ordinal for that function is saved and the address related to that ordinal is\nreturned.\n\n_Figure 13 shows a code in Python that reproduces the above mentioned comparison_\nalgorithm using hardcoded hashes extracted from memory (Figure 10) and all function\nnames exported by ntdll.dll.\n\n\n-----\n\nFigure 13 - Reversing outcome for code responsible by resolving \"ntdll.dll\" hardcoded\n\nhashes\n\nThis code produces the following output:\n\n\n-----\n\nFinally, these addresses are used for filling the call table which will be referenced by indirect\ncalls in the main payload. It is possible to confirm that what was described so far is true by\nobserving the function addresses written in the data segment after executing the second\nsection of \"__load_libraries\". Figure 14 shows the part of the call table filled so far with the\nexpected \"ntdll.dll\" calls.\n\nFigure 14 - Segment of Smokeloader's dynamically generated call table\n\nThe last segment of the \"__load_libraries\" function de-obfuscates the remain libraries names\nand load them by using the same resources used for loading \"ntdll\" and \"kernel32\". The\nlibraries loaded by Smokeloader are: \"user32\", \"advapi32\", \"urlmon\", \"ole32\", \"winhttp\",\n\"ws2_32\", \"dnsapi\" and \"shell32\".\n\nNow that the whole process of creating the call table used by the indirect calls is described,\nnext step will get into fixing the memory containing the main payload by using IDA Python.\n\n\n-----\n\n**--- End of part II ---**\n\nWhen the main payload of Smokeloader is imported into IDApro it is possible to see code\ncontaining indirect calls which uses a base address stored in a register plus an offset. Figure\n_15 presents a snip of the main payload containing such indirect calls._\n\nFigure 15 - Indirect calls calling functions pointed at the dynamic generated calls table.\n\nThis characteristic makes the processing of reversing this code harder since the interaction\nwith other resources in the Operating System is not clear as all external calls is not explicit.\nThe goal in this part of the article is to patch these calls for pointing to addresses we going to\nmap and label (using IDA Python). The code below implements the change we want.\nThis code performs the following actions into our IDB:\n\n\n-----\n\n1. Reads a memory dump of the data segment of an executing Smokeloader binary (line\n\n_106);_\n2. Creates a DATA segment mapped into 0x00000000 (line 107).\n3. Loads the dumped data segment from the running sample into this new segment (line\n\n_35);_\n4. Imports API names extracted from x32dbg to specific positions in the new data\n\nsegment (line 112);\n5. Patches all indirect call instructions (opcode 55 9X) to direct call instructions (line 51).\n\n_Figure 16 shows the code listed after executing the script above. As we can see, all indirect_\ncalls were translated to direct calls to a labeled table located in the freshly created data\nsegment starting at address 0x00000000.\n\nFigure 16 - Patched code with calls containing meaningful labels.\n\nJust heads up for preventing people against messing up research IDBs: for obvious reasons\n(different instruction sets) the script above can not be used for patching 64 bits\n_Smokeloader IDBs but it could be easily adapted to do the same task._\n\n\n-----\n\n**--- End of part III ---**\n\nThat's all folks!\n\nThe ideas described in this article can be extended and used to analyse any other malware\nfamilies dynamically importing libraries and using indirect calls. Another thing cool for\nexperimenting in future would be write a script which loads DLLs and extracts labels\nstatically by using the reversed \"__hashing\" function and native functionalities in IDA for\n[mapping DLLs in the process address space.](https://github.com/nihilus/IDA-IDC-Scripts/blob/master/PE-scripts/pe_dlls.idc)\n\n\n-----",
    "language": "EN",
    "sources": [
        {
            "id": "05d7b179-7656-44d8-a74c-9ab34d3df3a2",
            "created_at": "2023-01-12T14:38:44.599904Z",
            "updated_at": "2023-01-12T14:38:44.599904Z",
            "deleted_at": null,
            "name": "VXUG",
            "url": "https://www.vx-underground.org",
            "description": "vx-underground Papers",
            "reports": null
        }
    ],
    "references": [
        "https://papers.vx-underground.org/papers/Malware Defense/Malware Analysis 2019/2019-10-31 - Dynamic Imports and Working Around Indirect Calls - Smokeloader Study Case.pdf"
    ],
    "report_names": [
        "2019-10-31 - Dynamic Imports and Working Around Indirect Calls - Smokeloader Study Case.pdf"
    ],
    "threat_actors": [],
    "ts_created_at": 1673535697,
    "ts_updated_at": 1743041136,
    "ts_creation_date": 1653678075,
    "ts_modification_date": 1653678075,
    "files": {
        "pdf": "https://archive.orkl.eu/e46d8cd36421813bc00663db9032e620a4f34852.pdf",
        "text": "https://archive.orkl.eu/e46d8cd36421813bc00663db9032e620a4f34852.txt",
        "img": "https://archive.orkl.eu/e46d8cd36421813bc00663db9032e620a4f34852.jpg"
    }
}